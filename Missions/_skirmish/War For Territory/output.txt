// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 77423 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 41997 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 5
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 41997 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 41997 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 41997 0 9
// PrepareGensher ;
 189: CALL 2104 0 0
// PreparePopov ;
 193: CALL 4499 0 0
// PreparePowell ;
 197: CALL 460 0 0
// PrepareSikorski ;
 201: CALL 6708 0 0
// MC_Start ( ) ;
 205: CALL 49272 0 0
// Action ;
 209: CALL 7115 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 2499 0 0
// InitMC_Powell ( ) ;
 284: CALL 682 0 0
// InitMC_Popov ( ) ;
 288: CALL 4832 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$30 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 1050
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 20
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 700
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 1 1$00 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 2100
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ; end_of_file
 457: PPOPN 3
 459: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , tmp ; begin
 460: LD_INT 0
 462: PPUSH
 463: PPUSH
 464: PPUSH
// powell_side := 4 ;
 465: LD_ADDR_EXP 11
 469: PUSH
 470: LD_INT 4
 472: ST_TO_ADDR
// uc_side := powell_side ;
 473: LD_ADDR_OWVAR 20
 477: PUSH
 478: LD_EXP 11
 482: ST_TO_ADDR
// uc_nation := 1 ;
 483: LD_ADDR_OWVAR 21
 487: PUSH
 488: LD_INT 1
 490: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 491: LD_ADDR_EXP 10
 495: PUSH
 496: LD_STRING Powell
 498: PPUSH
 499: CALL_OW 25
 503: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 504: LD_EXP 10
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 7
 514: PPUSH
 515: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 519: LD_EXP 10
 523: PPUSH
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 5
 529: PPUSH
 530: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 534: LD_EXP 10
 538: PPUSH
 539: LD_INT 3
 541: PPUSH
 542: LD_INT 6
 544: PPUSH
 545: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 549: LD_EXP 10
 553: PPUSH
 554: LD_INT 4
 556: PPUSH
 557: LD_INT 4
 559: PPUSH
 560: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 564: LD_EXP 10
 568: PPUSH
 569: LD_INT 4
 571: PPUSH
 572: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 2500 , 300 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 576: LD_ADDR_VAR 0 3
 580: PUSH
 581: LD_INT 4
 583: PPUSH
 584: LD_INT 1
 586: PPUSH
 587: LD_STRING 
 589: PPUSH
 590: LD_INT 8
 592: PUSH
 593: LD_INT 7
 595: PUSH
 596: LD_INT 6
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: PUSH
 604: LD_OWVAR 67
 608: ARRAY
 609: PPUSH
 610: LD_INT 2500
 612: PUSH
 613: LD_INT 300
 615: PUSH
 616: LD_INT 0
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: LD_INT 4
 626: PUSH
 627: LD_INT 4
 629: PUSH
 630: LD_INT 4
 632: PUSH
 633: LD_INT 4
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL 16944 0 6
 646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 647: LD_ADDR_EXP 23
 651: PUSH
 652: LD_EXP 23
 656: PPUSH
 657: LD_INT 1
 659: PPUSH
 660: LD_VAR 0 3
 664: PPUSH
 665: CALL_OW 1
 669: ST_TO_ADDR
// powellAttackGroup := [ ] ;
 670: LD_ADDR_EXP 12
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// end ;
 677: LD_VAR 0 1
 681: RET
// export function InitMC_Powell ( ) ; begin
 682: LD_INT 0
 684: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 685: LD_INT 1
 687: PPUSH
 688: LD_INT 1
 690: PPUSH
 691: CALL 72299 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 695: LD_INT 1
 697: PPUSH
 698: LD_INT 6
 700: PPUSH
 701: CALL 72243 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 705: LD_INT 1
 707: PPUSH
 708: LD_INT 167
 710: PUSH
 711: LD_INT 102
 713: PUSH
 714: LD_INT 0
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_INT 173
 724: PUSH
 725: LD_INT 83
 727: PUSH
 728: LD_INT 1
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 171
 738: PUSH
 739: LD_INT 141
 741: PUSH
 742: LD_INT 0
 744: PUSH
 745: EMPTY
 746: LIST
 747: LIST
 748: LIST
 749: PUSH
 750: LD_INT 178
 752: PUSH
 753: LD_INT 148
 755: PUSH
 756: LD_INT 1
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PPUSH
 770: CALL 71302 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
 774: LD_INT 1
 776: PPUSH
 777: LD_INT 11
 779: PUSH
 780: LD_INT 6
 782: PUSH
 783: LD_INT 7
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 72131 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 5
 800: PPUSH
 801: CALL 71813 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 805: LD_INT 1
 807: PPUSH
 808: LD_INT 4
 810: PPUSH
 811: CALL 71544 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 815: LD_INT 1
 817: PPUSH
 818: LD_INT 4
 820: PPUSH
 821: CALL 71163 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 825: LD_INT 1
 827: PPUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 2
 836: PUSH
 837: LD_INT 5
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 4
 848: PUSH
 849: LD_INT 1
 851: PUSH
 852: LD_INT 2
 854: PUSH
 855: LD_INT 6
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 4
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 7
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: PUSH
 882: LD_INT 4
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 2
 890: PUSH
 891: LD_INT 6
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_INT 4
 902: PUSH
 903: LD_INT 1
 905: PUSH
 906: LD_INT 2
 908: PUSH
 909: LD_INT 6
 911: PUSH
 912: EMPTY
 913: LIST
 914: LIST
 915: LIST
 916: LIST
 917: PUSH
 918: EMPTY
 919: LIST
 920: LIST
 921: LIST
 922: LIST
 923: LIST
 924: PPUSH
 925: CALL 70978 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] , [ b_turret , 194 , 146 , 4 ] , [ b_turret , 190 , 142 , 4 ] ] ) ;
 929: LD_INT 1
 931: PPUSH
 932: LD_INT 6
 934: PUSH
 935: LD_INT 200
 937: PUSH
 938: LD_INT 111
 940: PUSH
 941: LD_INT 4
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PUSH
 950: LD_INT 29
 952: PUSH
 953: LD_INT 167
 955: PUSH
 956: LD_INT 102
 958: PUSH
 959: LD_INT 0
 961: PUSH
 962: EMPTY
 963: LIST
 964: LIST
 965: LIST
 966: LIST
 967: PUSH
 968: LD_INT 4
 970: PUSH
 971: LD_INT 178
 973: PUSH
 974: LD_INT 117
 976: PUSH
 977: LD_INT 2
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: LIST
 984: LIST
 985: PUSH
 986: LD_INT 2
 988: PUSH
 989: LD_INT 201
 991: PUSH
 992: LD_INT 140
 994: PUSH
 995: LD_INT 4
 997: PUSH
 998: EMPTY
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 27
1006: PUSH
1007: LD_INT 206
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 3
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 27
1024: PUSH
1025: LD_INT 209
1027: PUSH
1028: LD_INT 128
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: EMPTY
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 27
1042: PUSH
1043: LD_INT 211
1045: PUSH
1046: LD_INT 132
1048: PUSH
1049: LD_INT 3
1051: PUSH
1052: EMPTY
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 30
1060: PUSH
1061: LD_INT 173
1063: PUSH
1064: LD_INT 83
1066: PUSH
1067: LD_INT 3
1069: PUSH
1070: EMPTY
1071: LIST
1072: LIST
1073: LIST
1074: LIST
1075: PUSH
1076: LD_INT 6
1078: PUSH
1079: LD_INT 186
1081: PUSH
1082: LD_INT 103
1084: PUSH
1085: LD_INT 2
1087: PUSH
1088: EMPTY
1089: LIST
1090: LIST
1091: LIST
1092: LIST
1093: PUSH
1094: LD_INT 33
1096: PUSH
1097: LD_INT 173
1099: PUSH
1100: LD_INT 99
1102: PUSH
1103: LD_INT 2
1105: PUSH
1106: EMPTY
1107: LIST
1108: LIST
1109: LIST
1110: LIST
1111: PUSH
1112: LD_INT 32
1114: PUSH
1115: LD_INT 174
1117: PUSH
1118: LD_INT 102
1120: PUSH
1121: LD_INT 2
1123: PUSH
1124: EMPTY
1125: LIST
1126: LIST
1127: LIST
1128: LIST
1129: PUSH
1130: LD_INT 32
1132: PUSH
1133: LD_INT 178
1135: PUSH
1136: LD_INT 100
1138: PUSH
1139: LD_INT 2
1141: PUSH
1142: EMPTY
1143: LIST
1144: LIST
1145: LIST
1146: LIST
1147: PUSH
1148: LD_INT 33
1150: PUSH
1151: LD_INT 174
1153: PUSH
1154: LD_INT 108
1156: PUSH
1157: LD_INT 1
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: PUSH
1166: LD_INT 33
1168: PUSH
1169: LD_INT 182
1171: PUSH
1172: LD_INT 122
1174: PUSH
1175: LD_INT 1
1177: PUSH
1178: EMPTY
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: PUSH
1184: LD_INT 36
1186: PUSH
1187: LD_INT 194
1189: PUSH
1190: LD_INT 124
1192: PUSH
1193: LD_INT 5
1195: PUSH
1196: EMPTY
1197: LIST
1198: LIST
1199: LIST
1200: LIST
1201: PUSH
1202: LD_INT 28
1204: PUSH
1205: LD_INT 204
1207: PUSH
1208: LD_INT 133
1210: PUSH
1211: LD_INT 3
1213: PUSH
1214: EMPTY
1215: LIST
1216: LIST
1217: LIST
1218: LIST
1219: PUSH
1220: LD_INT 27
1222: PUSH
1223: LD_INT 201
1225: PUSH
1226: LD_INT 133
1228: PUSH
1229: LD_INT 3
1231: PUSH
1232: EMPTY
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: PUSH
1238: LD_INT 28
1240: PUSH
1241: LD_INT 199
1243: PUSH
1244: LD_INT 119
1246: PUSH
1247: LD_INT 5
1249: PUSH
1250: EMPTY
1251: LIST
1252: LIST
1253: LIST
1254: LIST
1255: PUSH
1256: LD_INT 33
1258: PUSH
1259: LD_INT 184
1261: PUSH
1262: LD_INT 141
1264: PUSH
1265: LD_INT 1
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PUSH
1274: LD_INT 33
1276: PUSH
1277: LD_INT 183
1279: PUSH
1280: LD_INT 131
1282: PUSH
1283: LD_INT 2
1285: PUSH
1286: EMPTY
1287: LIST
1288: LIST
1289: LIST
1290: LIST
1291: PUSH
1292: LD_INT 33
1294: PUSH
1295: LD_INT 194
1297: PUSH
1298: LD_INT 146
1300: PUSH
1301: LD_INT 4
1303: PUSH
1304: EMPTY
1305: LIST
1306: LIST
1307: LIST
1308: LIST
1309: PUSH
1310: LD_INT 33
1312: PUSH
1313: LD_INT 190
1315: PUSH
1316: LD_INT 142
1318: PUSH
1319: LD_INT 4
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: EMPTY
1329: LIST
1330: LIST
1331: LIST
1332: LIST
1333: LIST
1334: LIST
1335: LIST
1336: LIST
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: LIST
1342: LIST
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 70870 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1356: LD_INT 1
1358: PPUSH
1359: LD_INT 10
1361: PUSH
1362: LD_INT 15
1364: PUSH
1365: LD_INT 12
1367: PUSH
1368: LD_INT 11
1370: PUSH
1371: EMPTY
1372: LIST
1373: LIST
1374: LIST
1375: LIST
1376: PPUSH
1377: CALL 71720 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1381: LD_INT 1
1383: PPUSH
1384: LD_INT 201
1386: PPUSH
1387: LD_INT 140
1389: PPUSH
1390: LD_INT 4
1392: PPUSH
1393: LD_INT 19
1395: PUSH
1396: LD_INT 16
1398: PUSH
1399: LD_INT 17
1401: PUSH
1402: LD_INT 18
1404: PUSH
1405: LD_INT 22
1407: PUSH
1408: EMPTY
1409: LIST
1410: LIST
1411: LIST
1412: LIST
1413: LIST
1414: PPUSH
1415: CALL 71925 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1419: LD_INT 1
1421: PPUSH
1422: LD_INT 0
1424: PPUSH
1425: CALL 71593 0 2
// end ;
1429: LD_VAR 0 1
1433: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1434: LD_INT 4
1436: PPUSH
1437: CALL_OW 302
1441: IFFALSE 2101
1443: GO 1445
1445: DISABLE
1446: LD_INT 0
1448: PPUSH
1449: PPUSH
1450: PPUSH
1451: PPUSH
1452: PPUSH
// begin enable ;
1453: ENABLE
// base := 1 ;
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: LD_INT 1
1461: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1462: LD_ADDR_VAR 0 3
1466: PUSH
1467: LD_INT 4
1469: PUSH
1470: LD_INT 1
1472: PUSH
1473: LD_INT 2
1475: PUSH
1476: LD_INT 6
1478: PUSH
1479: EMPTY
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: PUSH
1485: LD_INT 4
1487: PUSH
1488: LD_INT 1
1490: PUSH
1491: LD_INT 2
1493: PUSH
1494: LD_INT 6
1496: PUSH
1497: EMPTY
1498: LIST
1499: LIST
1500: LIST
1501: LIST
1502: PUSH
1503: LD_INT 3
1505: PUSH
1506: LD_INT 1
1508: PUSH
1509: LD_INT 2
1511: PUSH
1512: LD_INT 7
1514: PUSH
1515: EMPTY
1516: LIST
1517: LIST
1518: LIST
1519: LIST
1520: PUSH
1521: LD_INT 3
1523: PUSH
1524: LD_INT 1
1526: PUSH
1527: LD_INT 2
1529: PUSH
1530: LD_INT 7
1532: PUSH
1533: EMPTY
1534: LIST
1535: LIST
1536: LIST
1537: LIST
1538: PUSH
1539: EMPTY
1540: LIST
1541: LIST
1542: LIST
1543: LIST
1544: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1545: LD_ADDR_VAR 0 5
1549: PUSH
1550: LD_VAR 0 5
1554: PUSH
1555: LD_OWVAR 1
1559: PUSH
1560: LD_INT 21000
1562: DIV
1563: PLUS
1564: ST_TO_ADDR
// if amount > 8 then
1565: LD_VAR 0 5
1569: PUSH
1570: LD_INT 8
1572: GREATER
1573: IFFALSE 1583
// amount := 8 ;
1575: LD_ADDR_VAR 0 5
1579: PUSH
1580: LD_INT 8
1582: ST_TO_ADDR
// for i = 1 to amount do
1583: LD_ADDR_VAR 0 1
1587: PUSH
1588: DOUBLE
1589: LD_INT 1
1591: DEC
1592: ST_TO_ADDR
1593: LD_VAR 0 5
1597: PUSH
1598: FOR_TO
1599: IFFALSE 1683
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1601: LD_ADDR_VAR 0 3
1605: PUSH
1606: LD_VAR 0 3
1610: PPUSH
1611: LD_VAR 0 3
1615: PUSH
1616: LD_INT 1
1618: PLUS
1619: PPUSH
1620: LD_INT 3
1622: PUSH
1623: LD_INT 4
1625: PUSH
1626: EMPTY
1627: LIST
1628: LIST
1629: PUSH
1630: LD_INT 1
1632: PPUSH
1633: LD_INT 2
1635: PPUSH
1636: CALL_OW 12
1640: ARRAY
1641: PUSH
1642: LD_INT 1
1644: PUSH
1645: LD_INT 2
1647: PUSH
1648: LD_INT 7
1650: PUSH
1651: LD_INT 5
1653: PUSH
1654: EMPTY
1655: LIST
1656: LIST
1657: PUSH
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 2
1663: PPUSH
1664: CALL_OW 12
1668: ARRAY
1669: PUSH
1670: EMPTY
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PPUSH
1676: CALL_OW 2
1680: ST_TO_ADDR
1681: GO 1598
1683: POP
1684: POP
// MC_InsertProduceList ( base , tmp ) ;
1685: LD_VAR 0 2
1689: PPUSH
1690: LD_VAR 0 3
1694: PPUSH
1695: CALL 71026 0 2
// repeat wait ( 0 0$1 ) ;
1699: LD_INT 35
1701: PPUSH
1702: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
1706: LD_VAR 0 2
1710: PPUSH
1711: LD_INT 1
1713: PPUSH
1714: CALL 72444 0 2
1718: PUSH
1719: LD_VAR 0 5
1723: GREATEREQUAL
1724: IFFALSE 1699
// wait ( 0 0$30 ) ;
1726: LD_INT 1050
1728: PPUSH
1729: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
1733: LD_ADDR_VAR 0 4
1737: PUSH
1738: LD_EXP 42
1742: PUSH
1743: LD_VAR 0 2
1747: ARRAY
1748: PUSH
1749: LD_EXP 42
1753: PUSH
1754: LD_VAR 0 2
1758: ARRAY
1759: PPUSH
1760: LD_INT 2
1762: PUSH
1763: LD_INT 34
1765: PUSH
1766: LD_INT 12
1768: PUSH
1769: EMPTY
1770: LIST
1771: LIST
1772: PUSH
1773: LD_INT 34
1775: PUSH
1776: LD_INT 13
1778: PUSH
1779: EMPTY
1780: LIST
1781: LIST
1782: PUSH
1783: LD_INT 34
1785: PUSH
1786: LD_INT 14
1788: PUSH
1789: EMPTY
1790: LIST
1791: LIST
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: LIST
1797: LIST
1798: PPUSH
1799: CALL_OW 72
1803: DIFF
1804: ST_TO_ADDR
// if not attackers then
1805: LD_VAR 0 4
1809: NOT
1810: IFFALSE 1814
// exit ;
1812: GO 2101
// DialogPowellsAttack ;
1814: CALL 7246 0 0
// powellAttackGroup := attackers ;
1818: LD_ADDR_EXP 12
1822: PUSH
1823: LD_VAR 0 4
1827: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
1828: LD_ADDR_EXP 42
1832: PUSH
1833: LD_EXP 42
1837: PPUSH
1838: LD_VAR 0 2
1842: PPUSH
1843: LD_EXP 42
1847: PUSH
1848: LD_VAR 0 2
1852: ARRAY
1853: PUSH
1854: LD_VAR 0 4
1858: DIFF
1859: PPUSH
1860: CALL_OW 1
1864: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
1865: LD_EXP 9
1869: PUSH
1870: LD_INT 16
1872: PPUSH
1873: LD_INT 81
1875: PUSH
1876: LD_INT 4
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: PPUSH
1883: CALL_OW 70
1887: AND
1888: IFFALSE 1907
// ComAgressiveMove ( attackers , 135 , 21 ) else
1890: LD_VAR 0 4
1894: PPUSH
1895: LD_INT 135
1897: PPUSH
1898: LD_INT 21
1900: PPUSH
1901: CALL_OW 114
1905: GO 1922
// ComAgressiveMove ( attackers , 146 , 103 ) ;
1907: LD_VAR 0 4
1911: PPUSH
1912: LD_INT 146
1914: PPUSH
1915: LD_INT 103
1917: PPUSH
1918: CALL_OW 114
// wait ( 0 0$5 ) ;
1922: LD_INT 175
1924: PPUSH
1925: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
1929: LD_INT 35
1931: PPUSH
1932: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
1936: LD_VAR 0 4
1940: PPUSH
1941: LD_INT 60
1943: PUSH
1944: EMPTY
1945: LIST
1946: PPUSH
1947: CALL_OW 72
1951: NOT
1952: IFFALSE 1929
// if FilterAllUnits ( [ f_side , 3 ] ) then
1954: LD_INT 22
1956: PUSH
1957: LD_INT 3
1959: PUSH
1960: EMPTY
1961: LIST
1962: LIST
1963: PPUSH
1964: CALL_OW 69
1968: IFFALSE 1987
// ComAgressiveMove ( attackers , 102 , 116 ) else
1970: LD_VAR 0 4
1974: PPUSH
1975: LD_INT 102
1977: PPUSH
1978: LD_INT 116
1980: PPUSH
1981: CALL_OW 114
1985: GO 2002
// ComAgressiveMove ( attackers , 66 , 41 ) ;
1987: LD_VAR 0 4
1991: PPUSH
1992: LD_INT 66
1994: PPUSH
1995: LD_INT 41
1997: PPUSH
1998: CALL_OW 114
// wait ( 0 0$10 ) ;
2002: LD_INT 350
2004: PPUSH
2005: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2009: LD_INT 35
2011: PPUSH
2012: CALL_OW 67
// for i in attackers do
2016: LD_ADDR_VAR 0 1
2020: PUSH
2021: LD_VAR 0 4
2025: PUSH
2026: FOR_IN
2027: IFFALSE 2077
// if not HasTask ( i ) then
2029: LD_VAR 0 1
2033: PPUSH
2034: CALL_OW 314
2038: NOT
2039: IFFALSE 2075
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2041: LD_VAR 0 1
2045: PPUSH
2046: LD_INT 81
2048: PUSH
2049: LD_INT 4
2051: PUSH
2052: EMPTY
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 69
2060: PPUSH
2061: LD_VAR 0 1
2065: PPUSH
2066: CALL_OW 74
2070: PPUSH
2071: CALL_OW 115
2075: GO 2026
2077: POP
2078: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2079: LD_VAR 0 4
2083: PPUSH
2084: LD_INT 50
2086: PUSH
2087: EMPTY
2088: LIST
2089: PPUSH
2090: CALL_OW 72
2094: NOT
2095: IFFALSE 2009
// DialogPowellsAttackFailed ;
2097: CALL 7511 0 0
// end ; end_of_file
2101: PPOPN 5
2103: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , tmp , un ; begin
2104: LD_INT 0
2106: PPUSH
2107: PPUSH
2108: PPUSH
2109: PPUSH
// gensher_side := 2 ;
2110: LD_ADDR_EXP 14
2114: PUSH
2115: LD_INT 2
2117: ST_TO_ADDR
// uc_side := gensher_side ;
2118: LD_ADDR_OWVAR 20
2122: PUSH
2123: LD_EXP 14
2127: ST_TO_ADDR
// uc_nation := 2 ;
2128: LD_ADDR_OWVAR 21
2132: PUSH
2133: LD_INT 2
2135: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 3500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2136: LD_ADDR_VAR 0 3
2140: PUSH
2141: LD_INT 7
2143: PPUSH
2144: LD_INT 2
2146: PPUSH
2147: LD_STRING 
2149: PPUSH
2150: LD_INT 8
2152: PUSH
2153: LD_INT 7
2155: PUSH
2156: LD_INT 6
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: LIST
2163: PUSH
2164: LD_OWVAR 67
2168: ARRAY
2169: PPUSH
2170: LD_INT 3500
2172: PUSH
2173: LD_INT 300
2175: PUSH
2176: LD_INT 30
2178: PUSH
2179: EMPTY
2180: LIST
2181: LIST
2182: LIST
2183: PPUSH
2184: LD_INT 4
2186: PUSH
2187: LD_INT 4
2189: PUSH
2190: LD_INT 4
2192: PUSH
2193: LD_INT 4
2195: PUSH
2196: EMPTY
2197: LIST
2198: LIST
2199: LIST
2200: LIST
2201: PPUSH
2202: CALL 16944 0 6
2206: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
2207: LD_ADDR_EXP 23
2211: PUSH
2212: LD_EXP 23
2216: PPUSH
2217: LD_INT 2
2219: PPUSH
2220: LD_VAR 0 3
2224: PPUSH
2225: CALL_OW 1
2229: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
2230: LD_ADDR_VAR 0 3
2234: PUSH
2235: LD_INT 22
2237: PUSH
2238: LD_INT 2
2240: PUSH
2241: EMPTY
2242: LIST
2243: LIST
2244: PUSH
2245: LD_INT 30
2247: PUSH
2248: LD_INT 31
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: CALL_OW 69
2263: ST_TO_ADDR
// for i in tmp do
2264: LD_ADDR_VAR 0 2
2268: PUSH
2269: LD_VAR 0 3
2273: PUSH
2274: FOR_IN
2275: IFFALSE 2345
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
2277: LD_INT 0
2279: PPUSH
2280: LD_INT 1
2282: PPUSH
2283: LD_INT 4
2285: PUSH
2286: LD_INT 3
2288: PUSH
2289: LD_INT 3
2291: PUSH
2292: EMPTY
2293: LIST
2294: LIST
2295: LIST
2296: PUSH
2297: LD_OWVAR 67
2301: ARRAY
2302: PPUSH
2303: CALL_OW 380
// un := CreateHuman ;
2307: LD_ADDR_VAR 0 4
2311: PUSH
2312: CALL_OW 44
2316: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2317: LD_VAR 0 4
2321: PPUSH
2322: LD_INT 1
2324: PPUSH
2325: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2329: LD_VAR 0 4
2333: PPUSH
2334: LD_VAR 0 2
2338: PPUSH
2339: CALL_OW 52
// end ;
2343: GO 2274
2345: POP
2346: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
2347: LD_ADDR_VAR 0 3
2351: PUSH
2352: LD_INT 15
2354: PPUSH
2355: LD_INT 0
2357: PPUSH
2358: CALL_OW 517
2362: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: DOUBLE
2369: LD_INT 1
2371: DEC
2372: ST_TO_ADDR
2373: LD_VAR 0 3
2377: PUSH
2378: LD_INT 1
2380: ARRAY
2381: PUSH
2382: FOR_TO
2383: IFFALSE 2485
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
2385: LD_VAR 0 3
2389: PUSH
2390: LD_INT 1
2392: ARRAY
2393: PUSH
2394: LD_VAR 0 2
2398: ARRAY
2399: PPUSH
2400: LD_VAR 0 3
2404: PUSH
2405: LD_INT 2
2407: ARRAY
2408: PUSH
2409: LD_VAR 0 2
2413: ARRAY
2414: PPUSH
2415: LD_INT 2
2417: PPUSH
2418: LD_INT 0
2420: PPUSH
2421: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
2425: LD_ADDR_EXP 3
2429: PUSH
2430: LD_EXP 3
2434: PPUSH
2435: LD_EXP 3
2439: PUSH
2440: LD_INT 1
2442: PLUS
2443: PPUSH
2444: LD_VAR 0 3
2448: PUSH
2449: LD_INT 1
2451: ARRAY
2452: PUSH
2453: LD_VAR 0 2
2457: ARRAY
2458: PUSH
2459: LD_VAR 0 3
2463: PUSH
2464: LD_INT 2
2466: ARRAY
2467: PUSH
2468: LD_VAR 0 2
2472: ARRAY
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: PPUSH
2478: CALL_OW 2
2482: ST_TO_ADDR
// end ;
2483: GO 2382
2485: POP
2486: POP
// gensherAttackGroup := [ ] ;
2487: LD_ADDR_EXP 15
2491: PUSH
2492: EMPTY
2493: ST_TO_ADDR
// end ;
2494: LD_VAR 0 1
2498: RET
// export function InitMC_Gensher ( ) ; begin
2499: LD_INT 0
2501: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
2502: LD_INT 2
2504: PPUSH
2505: LD_INT 2
2507: PPUSH
2508: CALL 72299 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
2512: LD_INT 2
2514: PPUSH
2515: LD_INT 9
2517: PPUSH
2518: CALL 72243 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
2522: LD_INT 2
2524: PPUSH
2525: LD_INT 56
2527: PUSH
2528: LD_INT 23
2530: PUSH
2531: LD_INT 0
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: LIST
2538: PUSH
2539: LD_INT 52
2541: PUSH
2542: LD_INT 40
2544: PUSH
2545: LD_INT 1
2547: PUSH
2548: EMPTY
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL 71302 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
2561: LD_INT 2
2563: PPUSH
2564: LD_INT 27
2566: PUSH
2567: LD_INT 28
2569: PUSH
2570: EMPTY
2571: LIST
2572: LIST
2573: PPUSH
2574: CALL 72131 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
2578: LD_INT 2
2580: PPUSH
2581: LD_INT 8
2583: PPUSH
2584: CALL 71813 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
2588: LD_INT 2
2590: PPUSH
2591: LD_INT 7
2593: PPUSH
2594: CALL 71544 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
2598: LD_INT 2
2600: PPUSH
2601: LD_INT 4
2603: PPUSH
2604: CALL 71163 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
2608: LD_INT 2
2610: PPUSH
2611: LD_INT 13
2613: PUSH
2614: LD_INT 2
2616: PUSH
2617: LD_INT 1
2619: PUSH
2620: LD_INT 31
2622: PUSH
2623: EMPTY
2624: LIST
2625: LIST
2626: LIST
2627: LIST
2628: PUSH
2629: LD_INT 13
2631: PUSH
2632: LD_INT 2
2634: PUSH
2635: LD_INT 1
2637: PUSH
2638: LD_INT 31
2640: PUSH
2641: EMPTY
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: PUSH
2647: LD_INT 14
2649: PUSH
2650: LD_INT 1
2652: PUSH
2653: LD_INT 2
2655: PUSH
2656: LD_INT 27
2658: PUSH
2659: EMPTY
2660: LIST
2661: LIST
2662: LIST
2663: LIST
2664: PUSH
2665: LD_INT 14
2667: PUSH
2668: LD_INT 1
2670: PUSH
2671: LD_INT 2
2673: PUSH
2674: LD_INT 27
2676: PUSH
2677: EMPTY
2678: LIST
2679: LIST
2680: LIST
2681: LIST
2682: PUSH
2683: LD_INT 14
2685: PUSH
2686: LD_INT 1
2688: PUSH
2689: LD_INT 2
2691: PUSH
2692: LD_INT 28
2694: PUSH
2695: EMPTY
2696: LIST
2697: LIST
2698: LIST
2699: LIST
2700: PUSH
2701: LD_INT 14
2703: PUSH
2704: LD_INT 1
2706: PUSH
2707: LD_INT 1
2709: PUSH
2710: LD_INT 26
2712: PUSH
2713: EMPTY
2714: LIST
2715: LIST
2716: LIST
2717: LIST
2718: PUSH
2719: EMPTY
2720: LIST
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: LIST
2726: PPUSH
2727: CALL 70978 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
2731: LD_INT 2
2733: PPUSH
2734: LD_INT 6
2736: PUSH
2737: LD_INT 13
2739: PUSH
2740: LD_INT 18
2742: PUSH
2743: LD_INT 1
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PUSH
2752: LD_INT 6
2754: PUSH
2755: LD_INT 17
2757: PUSH
2758: LD_INT 27
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: LIST
2768: LIST
2769: PUSH
2770: LD_INT 27
2772: PUSH
2773: LD_INT 17
2775: PUSH
2776: LD_INT 3
2778: PUSH
2779: LD_INT 0
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: LIST
2787: PUSH
2788: LD_INT 29
2790: PUSH
2791: LD_INT 56
2793: PUSH
2794: LD_INT 23
2796: PUSH
2797: LD_INT 0
2799: PUSH
2800: EMPTY
2801: LIST
2802: LIST
2803: LIST
2804: LIST
2805: PUSH
2806: LD_INT 4
2808: PUSH
2809: LD_INT 42
2811: PUSH
2812: LD_INT 29
2814: PUSH
2815: LD_INT 5
2817: PUSH
2818: EMPTY
2819: LIST
2820: LIST
2821: LIST
2822: LIST
2823: PUSH
2824: LD_INT 2
2826: PUSH
2827: LD_INT 11
2829: PUSH
2830: LD_INT 7
2832: PUSH
2833: LD_INT 2
2835: PUSH
2836: EMPTY
2837: LIST
2838: LIST
2839: LIST
2840: LIST
2841: PUSH
2842: LD_INT 27
2844: PUSH
2845: LD_INT 20
2847: PUSH
2848: LD_INT 3
2850: PUSH
2851: LD_INT 0
2853: PUSH
2854: EMPTY
2855: LIST
2856: LIST
2857: LIST
2858: LIST
2859: PUSH
2860: LD_INT 27
2862: PUSH
2863: LD_INT 23
2865: PUSH
2866: LD_INT 3
2868: PUSH
2869: LD_INT 0
2871: PUSH
2872: EMPTY
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: PUSH
2878: LD_INT 27
2880: PUSH
2881: LD_INT 26
2883: PUSH
2884: LD_INT 3
2886: PUSH
2887: LD_INT 0
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: LIST
2895: PUSH
2896: LD_INT 32
2898: PUSH
2899: LD_INT 27
2901: PUSH
2902: LD_INT 44
2904: PUSH
2905: LD_INT 5
2907: PUSH
2908: EMPTY
2909: LIST
2910: LIST
2911: LIST
2912: LIST
2913: PUSH
2914: LD_INT 32
2916: PUSH
2917: LD_INT 41
2919: PUSH
2920: LD_INT 41
2922: PUSH
2923: LD_INT 5
2925: PUSH
2926: EMPTY
2927: LIST
2928: LIST
2929: LIST
2930: LIST
2931: PUSH
2932: LD_INT 32
2934: PUSH
2935: LD_INT 45
2937: PUSH
2938: LD_INT 24
2940: PUSH
2941: LD_INT 5
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: LIST
2948: LIST
2949: PUSH
2950: LD_INT 32
2952: PUSH
2953: LD_INT 48
2955: PUSH
2956: LD_INT 19
2958: PUSH
2959: LD_INT 5
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: PUSH
2968: LD_INT 32
2970: PUSH
2971: LD_INT 41
2973: PUSH
2974: LD_INT 3
2976: PUSH
2977: LD_INT 4
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: LIST
2984: LIST
2985: PUSH
2986: LD_INT 4
2988: PUSH
2989: LD_INT 44
2991: PUSH
2992: LD_INT 9
2994: PUSH
2995: LD_INT 4
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_INT 30
3006: PUSH
3007: LD_INT 52
3009: PUSH
3010: LD_INT 40
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: EMPTY
3017: LIST
3018: LIST
3019: LIST
3020: LIST
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: LIST
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: LIST
3034: LIST
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: PPUSH
3040: CALL 70870 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
3044: LD_INT 2
3046: PPUSH
3047: LD_INT 10
3049: PUSH
3050: LD_INT 15
3052: PUSH
3053: LD_INT 13
3055: PUSH
3056: LD_INT 11
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: PPUSH
3065: CALL 71720 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
3069: LD_INT 2
3071: PPUSH
3072: LD_INT 11
3074: PPUSH
3075: LD_INT 7
3077: PPUSH
3078: LD_INT 2
3080: PPUSH
3081: LD_INT 23
3083: PUSH
3084: LD_INT 16
3086: PUSH
3087: LD_INT 17
3089: PUSH
3090: LD_INT 18
3092: PUSH
3093: LD_INT 22
3095: PUSH
3096: EMPTY
3097: LIST
3098: LIST
3099: LIST
3100: LIST
3101: LIST
3102: PPUSH
3103: CALL 71925 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
3107: LD_INT 2
3109: PPUSH
3110: LD_INT 0
3112: PPUSH
3113: CALL 71593 0 2
// end ;
3117: LD_VAR 0 1
3121: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
3122: LD_EXP 3
3126: PUSH
3127: LD_INT 15
3129: PPUSH
3130: LD_INT 81
3132: PUSH
3133: LD_INT 2
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PPUSH
3140: CALL_OW 70
3144: AND
3145: IFFALSE 3358
3147: GO 3149
3149: DISABLE
3150: LD_INT 0
3152: PPUSH
3153: PPUSH
3154: PPUSH
3155: PPUSH
3156: PPUSH
// begin enable ;
3157: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
3158: LD_ADDR_VAR 0 3
3162: PUSH
3163: LD_INT 15
3165: PPUSH
3166: LD_INT 81
3168: PUSH
3169: LD_INT 2
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: PPUSH
3176: CALL_OW 70
3180: ST_TO_ADDR
// if not tmp then
3181: LD_VAR 0 3
3185: NOT
3186: IFFALSE 3190
// exit ;
3188: GO 3358
// for i in tmp do
3190: LD_ADDR_VAR 0 1
3194: PUSH
3195: LD_VAR 0 3
3199: PUSH
3200: FOR_IN
3201: IFFALSE 3356
// begin x := GetX ( i ) ;
3203: LD_ADDR_VAR 0 4
3207: PUSH
3208: LD_VAR 0 1
3212: PPUSH
3213: CALL_OW 250
3217: ST_TO_ADDR
// y := GetY ( i ) ;
3218: LD_ADDR_VAR 0 5
3222: PUSH
3223: LD_VAR 0 1
3227: PPUSH
3228: CALL_OW 251
3232: ST_TO_ADDR
// if MineAtPos ( x , y ) then
3233: LD_VAR 0 4
3237: PPUSH
3238: LD_VAR 0 5
3242: PPUSH
3243: CALL_OW 458
3247: IFFALSE 3354
// begin LaunchMineAtPos ( x , y , 2 ) ;
3249: LD_VAR 0 4
3253: PPUSH
3254: LD_VAR 0 5
3258: PPUSH
3259: LD_INT 2
3261: PPUSH
3262: CALL_OW 456
// for j = 1 to staticMines do
3266: LD_ADDR_VAR 0 2
3270: PUSH
3271: DOUBLE
3272: LD_INT 1
3274: DEC
3275: ST_TO_ADDR
3276: LD_EXP 3
3280: PUSH
3281: FOR_TO
3282: IFFALSE 3352
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
3284: LD_EXP 3
3288: PUSH
3289: LD_VAR 0 2
3293: ARRAY
3294: PUSH
3295: LD_INT 1
3297: ARRAY
3298: PUSH
3299: LD_VAR 0 4
3303: EQUAL
3304: PUSH
3305: LD_EXP 3
3309: PUSH
3310: LD_VAR 0 2
3314: ARRAY
3315: PUSH
3316: LD_INT 2
3318: ARRAY
3319: PUSH
3320: LD_VAR 0 5
3324: EQUAL
3325: AND
3326: IFFALSE 3350
// begin staticMines := Delete ( staticMines , j ) ;
3328: LD_ADDR_EXP 3
3332: PUSH
3333: LD_EXP 3
3337: PPUSH
3338: LD_VAR 0 2
3342: PPUSH
3343: CALL_OW 3
3347: ST_TO_ADDR
// break ;
3348: GO 3352
// end ;
3350: GO 3281
3352: POP
3353: POP
// end ; end ;
3354: GO 3200
3356: POP
3357: POP
// end ;
3358: PPOPN 5
3360: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
3361: LD_INT 7
3363: PPUSH
3364: CALL_OW 302
3368: PUSH
3369: LD_EXP 4
3373: NOT
3374: AND
3375: IFFALSE 3979
3377: GO 3379
3379: DISABLE
3380: LD_INT 0
3382: PPUSH
3383: PPUSH
3384: PPUSH
3385: PPUSH
3386: PPUSH
// begin enable ;
3387: ENABLE
// base := 2 ;
3388: LD_ADDR_VAR 0 2
3392: PUSH
3393: LD_INT 2
3395: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
3396: LD_ADDR_VAR 0 3
3400: PUSH
3401: LD_INT 14
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 2
3409: PUSH
3410: LD_INT 27
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: LD_INT 14
3421: PUSH
3422: LD_INT 1
3424: PUSH
3425: LD_INT 2
3427: PUSH
3428: LD_INT 27
3430: PUSH
3431: EMPTY
3432: LIST
3433: LIST
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 14
3439: PUSH
3440: LD_INT 1
3442: PUSH
3443: LD_INT 2
3445: PUSH
3446: LD_EXP 72
3450: PUSH
3451: EMPTY
3452: LIST
3453: LIST
3454: LIST
3455: LIST
3456: PUSH
3457: LD_INT 14
3459: PUSH
3460: LD_INT 1
3462: PUSH
3463: LD_INT 2
3465: PUSH
3466: LD_INT 26
3468: PUSH
3469: EMPTY
3470: LIST
3471: LIST
3472: LIST
3473: LIST
3474: PUSH
3475: EMPTY
3476: LIST
3477: LIST
3478: LIST
3479: LIST
3480: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
3481: LD_ADDR_VAR 0 5
3485: PUSH
3486: LD_VAR 0 5
3490: PUSH
3491: LD_OWVAR 1
3495: PUSH
3496: LD_INT 21000
3498: DIV
3499: PLUS
3500: ST_TO_ADDR
// if amount > 8 then
3501: LD_VAR 0 5
3505: PUSH
3506: LD_INT 8
3508: GREATER
3509: IFFALSE 3519
// amount := 8 ;
3511: LD_ADDR_VAR 0 5
3515: PUSH
3516: LD_INT 8
3518: ST_TO_ADDR
// for i = 1 to amount do
3519: LD_ADDR_VAR 0 1
3523: PUSH
3524: DOUBLE
3525: LD_INT 1
3527: DEC
3528: ST_TO_ADDR
3529: LD_VAR 0 5
3533: PUSH
3534: FOR_TO
3535: IFFALSE 3623
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
3537: LD_ADDR_VAR 0 3
3541: PUSH
3542: LD_VAR 0 3
3546: PPUSH
3547: LD_VAR 0 3
3551: PUSH
3552: LD_INT 1
3554: PLUS
3555: PPUSH
3556: LD_INT 14
3558: PUSH
3559: LD_INT 13
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: PUSH
3566: LD_INT 1
3568: PPUSH
3569: LD_INT 2
3571: PPUSH
3572: CALL_OW 12
3576: ARRAY
3577: PUSH
3578: LD_INT 1
3580: PUSH
3581: LD_INT 2
3583: PUSH
3584: LD_INT 28
3586: PUSH
3587: LD_INT 25
3589: PUSH
3590: LD_INT 27
3592: PUSH
3593: EMPTY
3594: LIST
3595: LIST
3596: LIST
3597: PUSH
3598: LD_INT 1
3600: PPUSH
3601: LD_INT 3
3603: PPUSH
3604: CALL_OW 12
3608: ARRAY
3609: PUSH
3610: EMPTY
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: PPUSH
3616: CALL_OW 2
3620: ST_TO_ADDR
3621: GO 3534
3623: POP
3624: POP
// MC_InsertProduceList ( base , tmp ) ;
3625: LD_VAR 0 2
3629: PPUSH
3630: LD_VAR 0 3
3634: PPUSH
3635: CALL 71026 0 2
// repeat wait ( 0 0$1 ) ;
3639: LD_INT 35
3641: PPUSH
3642: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3646: LD_VAR 0 2
3650: PPUSH
3651: LD_INT 1
3653: PPUSH
3654: CALL 72444 0 2
3658: PUSH
3659: LD_VAR 0 5
3663: GREATEREQUAL
3664: IFFALSE 3639
// wait ( 0 0$30 ) ;
3666: LD_INT 1050
3668: PPUSH
3669: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
3673: LD_ADDR_VAR 0 4
3677: PUSH
3678: LD_EXP 42
3682: PUSH
3683: LD_VAR 0 2
3687: ARRAY
3688: PUSH
3689: LD_EXP 42
3693: PUSH
3694: LD_VAR 0 2
3698: ARRAY
3699: PPUSH
3700: LD_INT 2
3702: PUSH
3703: LD_INT 34
3705: PUSH
3706: LD_INT 31
3708: PUSH
3709: EMPTY
3710: LIST
3711: LIST
3712: PUSH
3713: LD_INT 34
3715: PUSH
3716: LD_INT 32
3718: PUSH
3719: EMPTY
3720: LIST
3721: LIST
3722: PUSH
3723: LD_INT 34
3725: PUSH
3726: LD_EXP 73
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: LIST
3740: PPUSH
3741: CALL_OW 72
3745: DIFF
3746: ST_TO_ADDR
// if not attackers then
3747: LD_VAR 0 4
3751: NOT
3752: IFFALSE 3756
// exit ;
3754: GO 3979
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3756: LD_ADDR_EXP 42
3760: PUSH
3761: LD_EXP 42
3765: PPUSH
3766: LD_VAR 0 2
3770: PPUSH
3771: LD_EXP 42
3775: PUSH
3776: LD_VAR 0 2
3780: ARRAY
3781: PUSH
3782: LD_VAR 0 4
3786: DIFF
3787: PPUSH
3788: CALL_OW 1
3792: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
3793: LD_VAR 0 4
3797: PPUSH
3798: LD_INT 107
3800: PPUSH
3801: LD_INT 74
3803: PPUSH
3804: CALL_OW 114
// wait ( 0 0$5 ) ;
3808: LD_INT 175
3810: PPUSH
3811: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3815: LD_INT 35
3817: PPUSH
3818: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3822: LD_VAR 0 4
3826: PPUSH
3827: LD_INT 60
3829: PUSH
3830: EMPTY
3831: LIST
3832: PPUSH
3833: CALL_OW 72
3837: NOT
3838: IFFALSE 3815
// if rand ( 0 , 1 ) then
3840: LD_INT 0
3842: PPUSH
3843: LD_INT 1
3845: PPUSH
3846: CALL_OW 12
3850: IFFALSE 3869
// ComAgressiveMove ( attackers , 155 , 108 ) else
3852: LD_VAR 0 4
3856: PPUSH
3857: LD_INT 155
3859: PPUSH
3860: LD_INT 108
3862: PPUSH
3863: CALL_OW 114
3867: GO 3884
// ComAgressiveMove ( attackers , 149 , 55 ) ;
3869: LD_VAR 0 4
3873: PPUSH
3874: LD_INT 149
3876: PPUSH
3877: LD_INT 55
3879: PPUSH
3880: CALL_OW 114
// wait ( 0 0$10 ) ;
3884: LD_INT 350
3886: PPUSH
3887: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3891: LD_INT 35
3893: PPUSH
3894: CALL_OW 67
// for i in attackers do
3898: LD_ADDR_VAR 0 1
3902: PUSH
3903: LD_VAR 0 4
3907: PUSH
3908: FOR_IN
3909: IFFALSE 3959
// if not HasTask ( i ) then
3911: LD_VAR 0 1
3915: PPUSH
3916: CALL_OW 314
3920: NOT
3921: IFFALSE 3957
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
3923: LD_VAR 0 1
3927: PPUSH
3928: LD_INT 81
3930: PUSH
3931: LD_INT 2
3933: PUSH
3934: EMPTY
3935: LIST
3936: LIST
3937: PPUSH
3938: CALL_OW 69
3942: PPUSH
3943: LD_VAR 0 1
3947: PPUSH
3948: CALL_OW 74
3952: PPUSH
3953: CALL_OW 115
3957: GO 3908
3959: POP
3960: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
3961: LD_VAR 0 4
3965: PPUSH
3966: LD_INT 50
3968: PUSH
3969: EMPTY
3970: LIST
3971: PPUSH
3972: CALL_OW 72
3976: NOT
3977: IFFALSE 3891
// end ;
3979: PPOPN 5
3981: END
// every 20 20$00 trigger not arDestroyed and tick < 81 81$00 do var i , un , tmp ;
3982: LD_EXP 4
3986: NOT
3987: PUSH
3988: LD_OWVAR 1
3992: PUSH
3993: LD_INT 170100
3995: LESS
3996: AND
3997: IFFALSE 4496
3999: GO 4001
4001: DISABLE
4002: LD_INT 0
4004: PPUSH
4005: PPUSH
4006: PPUSH
// begin enable ;
4007: ENABLE
// tmp := [ ] ;
4008: LD_ADDR_VAR 0 3
4012: PUSH
4013: EMPTY
4014: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
4015: LD_ADDR_VAR 0 1
4019: PUSH
4020: DOUBLE
4021: LD_INT 1
4023: DEC
4024: ST_TO_ADDR
4025: LD_INT 4
4027: PUSH
4028: LD_INT 5
4030: PUSH
4031: LD_INT 5
4033: PUSH
4034: EMPTY
4035: LIST
4036: LIST
4037: LIST
4038: PUSH
4039: LD_OWVAR 67
4043: ARRAY
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4207
// begin uc_side := 2 ;
4048: LD_ADDR_OWVAR 20
4052: PUSH
4053: LD_INT 2
4055: ST_TO_ADDR
// uc_nation := 2 ;
4056: LD_ADDR_OWVAR 21
4060: PUSH
4061: LD_INT 2
4063: ST_TO_ADDR
// InitHC_All ( ) ;
4064: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
4068: LD_INT 0
4070: PPUSH
4071: LD_INT 1
4073: PPUSH
4074: LD_INT 5
4076: PUSH
4077: LD_INT 6
4079: PUSH
4080: LD_INT 7
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: LIST
4087: PUSH
4088: LD_OWVAR 67
4092: ARRAY
4093: PPUSH
4094: CALL_OW 380
// un := CreateHuman ;
4098: LD_ADDR_VAR 0 2
4102: PUSH
4103: CALL_OW 44
4107: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4108: LD_VAR 0 2
4112: PPUSH
4113: LD_INT 17
4115: PPUSH
4116: LD_INT 0
4118: PPUSH
4119: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
4123: LD_VAR 0 2
4127: PPUSH
4128: LD_INT 1
4130: PUSH
4131: LD_INT 8
4133: PUSH
4134: EMPTY
4135: LIST
4136: LIST
4137: PUSH
4138: LD_INT 1
4140: PPUSH
4141: LD_INT 2
4143: PPUSH
4144: CALL_OW 12
4148: ARRAY
4149: PPUSH
4150: CALL_OW 336
// ComMoveXY ( un , 73 , 24 ) ;
4154: LD_VAR 0 2
4158: PPUSH
4159: LD_INT 73
4161: PPUSH
4162: LD_INT 24
4164: PPUSH
4165: CALL_OW 111
// wait ( 0 0$2 ) ;
4169: LD_INT 70
4171: PPUSH
4172: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
4176: LD_ADDR_VAR 0 3
4180: PUSH
4181: LD_VAR 0 3
4185: PPUSH
4186: LD_VAR 0 3
4190: PUSH
4191: LD_INT 1
4193: PLUS
4194: PPUSH
4195: LD_VAR 0 2
4199: PPUSH
4200: CALL_OW 1
4204: ST_TO_ADDR
// end ;
4205: GO 4045
4207: POP
4208: POP
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
4209: LD_ADDR_VAR 0 1
4213: PUSH
4214: DOUBLE
4215: LD_INT 1
4217: DEC
4218: ST_TO_ADDR
4219: LD_INT 3
4221: PUSH
4222: LD_INT 4
4224: PUSH
4225: LD_INT 5
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: LIST
4232: PUSH
4233: LD_OWVAR 67
4237: ARRAY
4238: PUSH
4239: FOR_TO
4240: IFFALSE 4374
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
4242: LD_INT 14
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: LD_INT 5
4250: PPUSH
4251: LD_INT 29
4253: PUSH
4254: LD_INT 28
4256: PUSH
4257: LD_INT 27
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: LIST
4264: PUSH
4265: LD_INT 1
4267: PPUSH
4268: LD_INT 3
4270: PPUSH
4271: CALL_OW 12
4275: ARRAY
4276: PPUSH
4277: LD_INT 90
4279: PPUSH
4280: CALL 13497 0 5
// un := CreateVehicle ;
4284: LD_ADDR_VAR 0 2
4288: PUSH
4289: CALL_OW 45
4293: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4294: LD_VAR 0 2
4298: PPUSH
4299: LD_INT 2
4301: PPUSH
4302: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4306: LD_VAR 0 2
4310: PPUSH
4311: LD_INT 17
4313: PPUSH
4314: LD_INT 0
4316: PPUSH
4317: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
4321: LD_VAR 0 2
4325: PPUSH
4326: LD_INT 66
4328: PPUSH
4329: LD_INT 23
4331: PPUSH
4332: CALL_OW 111
// wait ( 0 0$3 ) ;
4336: LD_INT 105
4338: PPUSH
4339: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
4343: LD_ADDR_VAR 0 3
4347: PUSH
4348: LD_VAR 0 3
4352: PPUSH
4353: LD_VAR 0 3
4357: PUSH
4358: LD_INT 1
4360: PLUS
4361: PPUSH
4362: LD_VAR 0 2
4366: PPUSH
4367: CALL_OW 1
4371: ST_TO_ADDR
// end ;
4372: GO 4239
4374: POP
4375: POP
// if not tmp then
4376: LD_VAR 0 3
4380: NOT
4381: IFFALSE 4385
// exit ;
4383: GO 4496
// wait ( 0 0$5 ) ;
4385: LD_INT 175
4387: PPUSH
4388: CALL_OW 67
// repeat wait ( 0 0$3 ) ;
4392: LD_INT 105
4394: PPUSH
4395: CALL_OW 67
// for i in tmp do
4399: LD_ADDR_VAR 0 1
4403: PUSH
4404: LD_VAR 0 3
4408: PUSH
4409: FOR_IN
4410: IFFALSE 4487
// begin if not IsOk ( i ) or IsDead ( i ) then
4412: LD_VAR 0 1
4416: PPUSH
4417: CALL_OW 302
4421: NOT
4422: PUSH
4423: LD_VAR 0 1
4427: PPUSH
4428: CALL_OW 301
4432: OR
4433: IFFALSE 4451
// tmp := tmp diff i ;
4435: LD_ADDR_VAR 0 3
4439: PUSH
4440: LD_VAR 0 3
4444: PUSH
4445: LD_VAR 0 1
4449: DIFF
4450: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
4451: LD_VAR 0 1
4455: PPUSH
4456: LD_INT 81
4458: PUSH
4459: LD_INT 3
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: PPUSH
4466: CALL_OW 69
4470: PPUSH
4471: LD_VAR 0 1
4475: PPUSH
4476: CALL_OW 74
4480: PPUSH
4481: CALL_OW 115
// end ;
4485: GO 4409
4487: POP
4488: POP
// until not tmp ;
4489: LD_VAR 0 3
4493: NOT
4494: IFFALSE 4392
// end ; end_of_file
4496: PPOPN 3
4498: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp ; begin
4499: LD_INT 0
4501: PPUSH
4502: PPUSH
4503: PPUSH
4504: PPUSH
// popov_side := 3 ;
4505: LD_ADDR_EXP 17
4509: PUSH
4510: LD_INT 3
4512: ST_TO_ADDR
// uc_side := popov_side ;
4513: LD_ADDR_OWVAR 20
4517: PUSH
4518: LD_EXP 17
4522: ST_TO_ADDR
// uc_nation := 3 ;
4523: LD_ADDR_OWVAR 21
4527: PUSH
4528: LD_INT 3
4530: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 3500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
4531: LD_ADDR_VAR 0 4
4535: PUSH
4536: LD_INT 9
4538: PPUSH
4539: LD_INT 3
4541: PPUSH
4542: LD_STRING 
4544: PPUSH
4545: LD_INT 8
4547: PUSH
4548: LD_INT 7
4550: PUSH
4551: LD_INT 6
4553: PUSH
4554: EMPTY
4555: LIST
4556: LIST
4557: LIST
4558: PUSH
4559: LD_OWVAR 67
4563: ARRAY
4564: PPUSH
4565: LD_INT 3500
4567: PUSH
4568: LD_INT 300
4570: PUSH
4571: LD_INT 30
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: PPUSH
4579: LD_INT 4
4581: PUSH
4582: LD_INT 4
4584: PUSH
4585: LD_INT 4
4587: PUSH
4588: LD_INT 4
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: LIST
4596: PPUSH
4597: CALL 16944 0 6
4601: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
4602: LD_ADDR_EXP 23
4606: PUSH
4607: LD_EXP 23
4611: PPUSH
4612: LD_INT 3
4614: PPUSH
4615: LD_VAR 0 4
4619: PPUSH
4620: CALL_OW 1
4624: ST_TO_ADDR
// extraPopovForces := [ ] ;
4625: LD_ADDR_EXP 18
4629: PUSH
4630: EMPTY
4631: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
4632: LD_ADDR_VAR 0 2
4636: PUSH
4637: DOUBLE
4638: LD_INT 1
4640: DEC
4641: ST_TO_ADDR
4642: LD_INT 4
4644: PUSH
4645: LD_INT 5
4647: PUSH
4648: LD_INT 6
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: PUSH
4656: LD_OWVAR 67
4660: ARRAY
4661: PUSH
4662: FOR_TO
4663: IFFALSE 4766
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
4665: LD_INT 0
4667: PPUSH
4668: LD_INT 1
4670: PPUSH
4671: LD_INT 4
4673: PUSH
4674: LD_INT 5
4676: PUSH
4677: LD_INT 6
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PUSH
4685: LD_OWVAR 67
4689: ARRAY
4690: PPUSH
4691: CALL_OW 380
// un := CreateHuman ;
4695: LD_ADDR_VAR 0 3
4699: PUSH
4700: CALL_OW 44
4704: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
4705: LD_VAR 0 3
4709: PPUSH
4710: LD_INT 131
4712: PPUSH
4713: LD_INT 110
4715: PPUSH
4716: LD_INT 8
4718: PPUSH
4719: LD_INT 0
4721: PPUSH
4722: CALL_OW 50
// ComHold ( un ) ;
4726: LD_VAR 0 3
4730: PPUSH
4731: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
4735: LD_ADDR_EXP 18
4739: PUSH
4740: LD_EXP 18
4744: PPUSH
4745: LD_EXP 18
4749: PUSH
4750: LD_INT 1
4752: PLUS
4753: PPUSH
4754: LD_VAR 0 3
4758: PPUSH
4759: CALL_OW 1
4763: ST_TO_ADDR
// end ;
4764: GO 4662
4766: POP
4767: POP
// PrepareSoldier ( false , 6 ) ;
4768: LD_INT 0
4770: PPUSH
4771: LD_INT 6
4773: PPUSH
4774: CALL_OW 381
// un := CreateHuman ;
4778: LD_ADDR_VAR 0 3
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4788: LD_VAR 0 3
4792: PPUSH
4793: LD_INT 1
4795: PPUSH
4796: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
4800: LD_VAR 0 3
4804: PPUSH
4805: LD_INT 150
4807: PPUSH
4808: LD_INT 158
4810: PPUSH
4811: CALL_OW 428
4815: PPUSH
4816: CALL_OW 52
// popovAttackGroup := [ ] ;
4820: LD_ADDR_EXP 19
4824: PUSH
4825: EMPTY
4826: ST_TO_ADDR
// end ;
4827: LD_VAR 0 1
4831: RET
// export function InitMC_Popov ( ) ; begin
4832: LD_INT 0
4834: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
4835: LD_INT 3
4837: PPUSH
4838: LD_INT 3
4840: PPUSH
4841: CALL 72299 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
4845: LD_INT 3
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL 72243 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
4855: LD_INT 3
4857: PPUSH
4858: LD_INT 86
4860: PUSH
4861: LD_INT 118
4863: PUSH
4864: LD_INT 0
4866: PUSH
4867: EMPTY
4868: LIST
4869: LIST
4870: LIST
4871: PUSH
4872: LD_INT 123
4874: PUSH
4875: LD_INT 151
4877: PUSH
4878: LD_INT 1
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: LD_INT 106
4888: PUSH
4889: LD_INT 113
4891: PUSH
4892: LD_INT 0
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: LIST
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: LIST
4904: PPUSH
4905: CALL 71302 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_gatling_gun ] ) ;
4909: LD_INT 3
4911: PPUSH
4912: LD_INT 46
4914: PUSH
4915: LD_INT 45
4917: PUSH
4918: LD_INT 43
4920: PUSH
4921: EMPTY
4922: LIST
4923: LIST
4924: LIST
4925: PPUSH
4926: CALL 72131 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
4930: LD_INT 3
4932: PPUSH
4933: LD_INT 12
4935: PPUSH
4936: CALL 71813 0 2
// MC_SetTame ( 3 , popov_ape ) ;
4940: LD_INT 3
4942: PPUSH
4943: LD_INT 11
4945: PPUSH
4946: CALL 71544 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
4950: LD_INT 3
4952: PPUSH
4953: LD_INT 4
4955: PPUSH
4956: CALL 71163 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
4960: LD_INT 3
4962: PPUSH
4963: LD_INT 23
4965: PUSH
4966: LD_INT 1
4968: PUSH
4969: LD_INT 1
4971: PUSH
4972: LD_INT 44
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: PUSH
4981: LD_INT 23
4983: PUSH
4984: LD_INT 1
4986: PUSH
4987: LD_INT 3
4989: PUSH
4990: LD_INT 45
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: PUSH
4999: LD_INT 21
5001: PUSH
5002: LD_INT 1
5004: PUSH
5005: LD_INT 3
5007: PUSH
5008: LD_INT 43
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 21
5019: PUSH
5020: LD_INT 1
5022: PUSH
5023: LD_INT 3
5025: PUSH
5026: LD_INT 45
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PUSH
5035: EMPTY
5036: LIST
5037: LIST
5038: LIST
5039: LIST
5040: PPUSH
5041: CALL 70978 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ) ;
5045: LD_INT 3
5047: PPUSH
5048: LD_INT 6
5050: PUSH
5051: LD_INT 76
5053: PUSH
5054: LD_INT 145
5056: PUSH
5057: LD_INT 1
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 26
5068: PUSH
5069: LD_INT 87
5071: PUSH
5072: LD_INT 144
5074: PUSH
5075: LD_INT 0
5077: PUSH
5078: EMPTY
5079: LIST
5080: LIST
5081: LIST
5082: LIST
5083: PUSH
5084: LD_INT 29
5086: PUSH
5087: LD_INT 86
5089: PUSH
5090: LD_INT 118
5092: PUSH
5093: LD_INT 0
5095: PUSH
5096: EMPTY
5097: LIST
5098: LIST
5099: LIST
5100: LIST
5101: PUSH
5102: LD_INT 29
5104: PUSH
5105: LD_INT 106
5107: PUSH
5108: LD_INT 113
5110: PUSH
5111: LD_INT 0
5113: PUSH
5114: EMPTY
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 26
5122: PUSH
5123: LD_INT 87
5125: PUSH
5126: LD_INT 147
5128: PUSH
5129: LD_INT 1
5131: PUSH
5132: EMPTY
5133: LIST
5134: LIST
5135: LIST
5136: LIST
5137: PUSH
5138: LD_INT 2
5140: PUSH
5141: LD_INT 94
5143: PUSH
5144: LD_INT 161
5146: PUSH
5147: LD_INT 0
5149: PUSH
5150: EMPTY
5151: LIST
5152: LIST
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 6
5158: PUSH
5159: LD_INT 81
5161: PUSH
5162: LD_INT 155
5164: PUSH
5165: LD_INT 1
5167: PUSH
5168: EMPTY
5169: LIST
5170: LIST
5171: LIST
5172: LIST
5173: PUSH
5174: LD_INT 4
5176: PUSH
5177: LD_INT 103
5179: PUSH
5180: LD_INT 147
5182: PUSH
5183: LD_INT 3
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: LIST
5190: LIST
5191: PUSH
5192: LD_INT 26
5194: PUSH
5195: LD_INT 96
5197: PUSH
5198: LD_INT 152
5200: PUSH
5201: LD_INT 0
5203: PUSH
5204: EMPTY
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: PUSH
5210: LD_INT 26
5212: PUSH
5213: LD_INT 96
5215: PUSH
5216: LD_INT 149
5218: PUSH
5219: LD_INT 3
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: PUSH
5228: LD_INT 32
5230: PUSH
5231: LD_INT 109
5233: PUSH
5234: LD_INT 142
5236: PUSH
5237: LD_INT 3
5239: PUSH
5240: EMPTY
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: PUSH
5246: LD_INT 32
5248: PUSH
5249: LD_INT 112
5251: PUSH
5252: LD_INT 148
5254: PUSH
5255: LD_INT 3
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: LIST
5262: LIST
5263: PUSH
5264: LD_INT 33
5266: PUSH
5267: LD_INT 120
5269: PUSH
5270: LD_INT 159
5272: PUSH
5273: LD_INT 4
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: LIST
5280: LIST
5281: PUSH
5282: LD_INT 33
5284: PUSH
5285: LD_INT 122
5287: PUSH
5288: LD_INT 163
5290: PUSH
5291: LD_INT 4
5293: PUSH
5294: EMPTY
5295: LIST
5296: LIST
5297: LIST
5298: LIST
5299: PUSH
5300: LD_INT 33
5302: PUSH
5303: LD_INT 123
5305: PUSH
5306: LD_INT 167
5308: PUSH
5309: LD_INT 4
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: LIST
5316: LIST
5317: PUSH
5318: LD_INT 33
5320: PUSH
5321: LD_INT 59
5323: PUSH
5324: LD_INT 111
5326: PUSH
5327: LD_INT 3
5329: PUSH
5330: EMPTY
5331: LIST
5332: LIST
5333: LIST
5334: LIST
5335: PUSH
5336: LD_INT 33
5338: PUSH
5339: LD_INT 65
5341: PUSH
5342: LD_INT 111
5344: PUSH
5345: LD_INT 3
5347: PUSH
5348: EMPTY
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: PUSH
5354: LD_INT 33
5356: PUSH
5357: LD_INT 76
5359: PUSH
5360: LD_INT 117
5362: PUSH
5363: LD_INT 3
5365: PUSH
5366: EMPTY
5367: LIST
5368: LIST
5369: LIST
5370: LIST
5371: PUSH
5372: LD_INT 33
5374: PUSH
5375: LD_INT 80
5377: PUSH
5378: LD_INT 119
5380: PUSH
5381: LD_INT 3
5383: PUSH
5384: EMPTY
5385: LIST
5386: LIST
5387: LIST
5388: LIST
5389: PUSH
5390: LD_INT 33
5392: PUSH
5393: LD_INT 87
5395: PUSH
5396: LD_INT 125
5398: PUSH
5399: LD_INT 3
5401: PUSH
5402: EMPTY
5403: LIST
5404: LIST
5405: LIST
5406: LIST
5407: PUSH
5408: LD_INT 4
5410: PUSH
5411: LD_INT 92
5413: PUSH
5414: LD_INT 129
5416: PUSH
5417: LD_INT 3
5419: PUSH
5420: EMPTY
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: PUSH
5426: LD_INT 28
5428: PUSH
5429: LD_INT 85
5431: PUSH
5432: LD_INT 165
5434: PUSH
5435: LD_INT 0
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: LIST
5443: PUSH
5444: LD_INT 28
5446: PUSH
5447: LD_INT 83
5449: PUSH
5450: LD_INT 161
5452: PUSH
5453: LD_INT 4
5455: PUSH
5456: EMPTY
5457: LIST
5458: LIST
5459: LIST
5460: LIST
5461: PUSH
5462: LD_INT 28
5464: PUSH
5465: LD_INT 91
5467: PUSH
5468: LD_INT 166
5470: PUSH
5471: LD_INT 3
5473: PUSH
5474: EMPTY
5475: LIST
5476: LIST
5477: LIST
5478: LIST
5479: PUSH
5480: LD_INT 28
5482: PUSH
5483: LD_INT 102
5485: PUSH
5486: LD_INT 166
5488: PUSH
5489: LD_INT 2
5491: PUSH
5492: EMPTY
5493: LIST
5494: LIST
5495: LIST
5496: LIST
5497: PUSH
5498: EMPTY
5499: LIST
5500: LIST
5501: LIST
5502: LIST
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: PPUSH
5525: CALL 70870 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
5529: LD_INT 3
5531: PPUSH
5532: LD_INT 10
5534: PUSH
5535: LD_INT 12
5537: PUSH
5538: LD_INT 14
5540: PUSH
5541: LD_INT 11
5543: PUSH
5544: EMPTY
5545: LIST
5546: LIST
5547: LIST
5548: LIST
5549: PPUSH
5550: CALL 71720 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
5554: LD_INT 3
5556: PPUSH
5557: LD_INT 94
5559: PPUSH
5560: LD_INT 161
5562: PPUSH
5563: LD_INT 0
5565: PPUSH
5566: LD_INT 19
5568: PUSH
5569: LD_INT 17
5571: PUSH
5572: LD_INT 18
5574: PUSH
5575: LD_INT 24
5577: PUSH
5578: LD_INT 21
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: LIST
5587: PPUSH
5588: CALL 71925 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
5592: LD_INT 3
5594: PPUSH
5595: LD_INT 0
5597: PPUSH
5598: CALL 71593 0 2
// end ;
5602: LD_VAR 0 1
5606: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
5607: LD_INT 9
5609: PPUSH
5610: CALL_OW 302
5614: PUSH
5615: LD_EXP 5
5619: NOT
5620: AND
5621: IFFALSE 6187
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
5629: PPUSH
5630: PPUSH
5631: PPUSH
5632: PPUSH
// begin enable ;
5633: ENABLE
// base := 3 ;
5634: LD_ADDR_VAR 0 2
5638: PUSH
5639: LD_INT 3
5641: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
5642: LD_ADDR_VAR 0 3
5646: PUSH
5647: LD_INT 22
5649: PUSH
5650: LD_INT 1
5652: PUSH
5653: LD_INT 3
5655: PUSH
5656: LD_INT 44
5658: PUSH
5659: EMPTY
5660: LIST
5661: LIST
5662: LIST
5663: LIST
5664: PUSH
5665: LD_INT 24
5667: PUSH
5668: LD_INT 1
5670: PUSH
5671: LD_INT 3
5673: PUSH
5674: LD_INT 46
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: LIST
5682: PUSH
5683: LD_INT 24
5685: PUSH
5686: LD_INT 1
5688: PUSH
5689: LD_INT 3
5691: PUSH
5692: LD_INT 46
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_INT 24
5703: PUSH
5704: LD_INT 1
5706: PUSH
5707: LD_INT 3
5709: PUSH
5710: LD_INT 46
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: LIST
5717: LIST
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
5725: LD_ADDR_VAR 0 5
5729: PUSH
5730: LD_VAR 0 5
5734: PUSH
5735: LD_OWVAR 1
5739: PUSH
5740: LD_INT 21000
5742: DIV
5743: PLUS
5744: ST_TO_ADDR
// if amount > 8 then
5745: LD_VAR 0 5
5749: PUSH
5750: LD_INT 8
5752: GREATER
5753: IFFALSE 5763
// amount := 8 ;
5755: LD_ADDR_VAR 0 5
5759: PUSH
5760: LD_INT 8
5762: ST_TO_ADDR
// for i = 1 to amount do
5763: LD_ADDR_VAR 0 1
5767: PUSH
5768: DOUBLE
5769: LD_INT 1
5771: DEC
5772: ST_TO_ADDR
5773: LD_VAR 0 5
5777: PUSH
5778: FOR_TO
5779: IFFALSE 5844
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_VAR 0 3
5790: PPUSH
5791: LD_VAR 0 3
5795: PUSH
5796: LD_INT 1
5798: PLUS
5799: PPUSH
5800: LD_INT 24
5802: PUSH
5803: LD_INT 1
5805: PUSH
5806: LD_INT 3
5808: PUSH
5809: LD_INT 46
5811: PUSH
5812: LD_INT 45
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: PUSH
5819: LD_INT 1
5821: PPUSH
5822: LD_INT 2
5824: PPUSH
5825: CALL_OW 12
5829: ARRAY
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: LIST
5835: LIST
5836: PPUSH
5837: CALL_OW 2
5841: ST_TO_ADDR
5842: GO 5778
5844: POP
5845: POP
// MC_InsertProduceList ( base , tmp ) ;
5846: LD_VAR 0 2
5850: PPUSH
5851: LD_VAR 0 3
5855: PPUSH
5856: CALL 71026 0 2
// repeat wait ( 0 0$1 ) ;
5860: LD_INT 35
5862: PPUSH
5863: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5867: LD_VAR 0 2
5871: PPUSH
5872: LD_INT 1
5874: PPUSH
5875: CALL 72444 0 2
5879: PUSH
5880: LD_VAR 0 5
5884: GREATEREQUAL
5885: IFFALSE 5860
// wait ( 0 0$30 ) ;
5887: LD_INT 1050
5889: PPUSH
5890: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
5894: LD_ADDR_VAR 0 4
5898: PUSH
5899: LD_EXP 42
5903: PUSH
5904: LD_VAR 0 2
5908: ARRAY
5909: PUSH
5910: LD_EXP 42
5914: PUSH
5915: LD_VAR 0 2
5919: ARRAY
5920: PPUSH
5921: LD_INT 2
5923: PUSH
5924: LD_INT 34
5926: PUSH
5927: LD_INT 51
5929: PUSH
5930: EMPTY
5931: LIST
5932: LIST
5933: PUSH
5934: LD_INT 34
5936: PUSH
5937: LD_INT 52
5939: PUSH
5940: EMPTY
5941: LIST
5942: LIST
5943: PUSH
5944: EMPTY
5945: LIST
5946: LIST
5947: LIST
5948: PPUSH
5949: CALL_OW 72
5953: DIFF
5954: ST_TO_ADDR
// if not attackers then
5955: LD_VAR 0 4
5959: NOT
5960: IFFALSE 5964
// exit ;
5962: GO 6187
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5964: LD_ADDR_EXP 42
5968: PUSH
5969: LD_EXP 42
5973: PPUSH
5974: LD_VAR 0 2
5978: PPUSH
5979: LD_EXP 42
5983: PUSH
5984: LD_VAR 0 2
5988: ARRAY
5989: PUSH
5990: LD_VAR 0 4
5994: DIFF
5995: PPUSH
5996: CALL_OW 1
6000: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
6001: LD_VAR 0 4
6005: PPUSH
6006: LD_INT 107
6008: PPUSH
6009: LD_INT 74
6011: PPUSH
6012: CALL_OW 114
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
6023: LD_INT 35
6025: PPUSH
6026: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6030: LD_VAR 0 4
6034: PPUSH
6035: LD_INT 60
6037: PUSH
6038: EMPTY
6039: LIST
6040: PPUSH
6041: CALL_OW 72
6045: NOT
6046: IFFALSE 6023
// if rand ( 0 , 1 ) then
6048: LD_INT 0
6050: PPUSH
6051: LD_INT 1
6053: PPUSH
6054: CALL_OW 12
6058: IFFALSE 6077
// ComAgressiveMove ( attackers , 155 , 108 ) else
6060: LD_VAR 0 4
6064: PPUSH
6065: LD_INT 155
6067: PPUSH
6068: LD_INT 108
6070: PPUSH
6071: CALL_OW 114
6075: GO 6092
// ComAgressiveMove ( attackers , 149 , 55 ) ;
6077: LD_VAR 0 4
6081: PPUSH
6082: LD_INT 149
6084: PPUSH
6085: LD_INT 55
6087: PPUSH
6088: CALL_OW 114
// wait ( 0 0$10 ) ;
6092: LD_INT 350
6094: PPUSH
6095: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
6099: LD_INT 35
6101: PPUSH
6102: CALL_OW 67
// for i in attackers do
6106: LD_ADDR_VAR 0 1
6110: PUSH
6111: LD_VAR 0 4
6115: PUSH
6116: FOR_IN
6117: IFFALSE 6167
// if not HasTask ( i ) then
6119: LD_VAR 0 1
6123: PPUSH
6124: CALL_OW 314
6128: NOT
6129: IFFALSE 6165
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 81
6138: PUSH
6139: LD_INT 3
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 69
6150: PPUSH
6151: LD_VAR 0 1
6155: PPUSH
6156: CALL_OW 74
6160: PPUSH
6161: CALL_OW 115
6165: GO 6116
6167: POP
6168: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
6169: LD_VAR 0 4
6173: PPUSH
6174: LD_INT 50
6176: PUSH
6177: EMPTY
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: NOT
6185: IFFALSE 6099
// end ;
6187: PPOPN 5
6189: END
// every 24 24$00 trigger not ruDestroyed do var i , un , tmp ;
6190: LD_EXP 5
6194: NOT
6195: IFFALSE 6705
6197: GO 6199
6199: DISABLE
6200: LD_INT 0
6202: PPUSH
6203: PPUSH
6204: PPUSH
// begin enable ;
6205: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
6206: LD_OWVAR 67
6210: PUSH
6211: LD_INT 1
6213: EQUAL
6214: PUSH
6215: LD_OWVAR 1
6219: PUSH
6220: LD_INT 63000
6222: LESS
6223: AND
6224: IFFALSE 6228
// exit ;
6226: GO 6705
// tmp := [ ] ;
6228: LD_ADDR_VAR 0 3
6232: PUSH
6233: EMPTY
6234: ST_TO_ADDR
// for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6235: LD_ADDR_VAR 0 1
6239: PUSH
6240: DOUBLE
6241: LD_INT 1
6243: DEC
6244: ST_TO_ADDR
6245: LD_INT 2
6247: PUSH
6248: LD_INT 3
6250: PUSH
6251: LD_INT 4
6253: PUSH
6254: EMPTY
6255: LIST
6256: LIST
6257: LIST
6258: PUSH
6259: LD_OWVAR 67
6263: ARRAY
6264: PUSH
6265: FOR_TO
6266: IFFALSE 6408
// begin uc_side := 3 ;
6268: LD_ADDR_OWVAR 20
6272: PUSH
6273: LD_INT 3
6275: ST_TO_ADDR
// uc_nation := 3 ;
6276: LD_ADDR_OWVAR 21
6280: PUSH
6281: LD_INT 3
6283: ST_TO_ADDR
// InitHC_All ( ) ;
6284: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
6288: LD_INT 0
6290: PPUSH
6291: LD_INT 1
6293: PPUSH
6294: LD_INT 5
6296: PUSH
6297: LD_INT 6
6299: PUSH
6300: LD_INT 7
6302: PUSH
6303: EMPTY
6304: LIST
6305: LIST
6306: LIST
6307: PUSH
6308: LD_OWVAR 67
6312: ARRAY
6313: PPUSH
6314: CALL_OW 380
// un := CreateHuman ;
6318: LD_ADDR_VAR 0 2
6322: PUSH
6323: CALL_OW 44
6327: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
6328: LD_VAR 0 2
6332: PPUSH
6333: LD_INT 18
6335: PPUSH
6336: LD_INT 0
6338: PPUSH
6339: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
6343: LD_VAR 0 2
6347: PPUSH
6348: LD_INT 9
6350: PPUSH
6351: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
6355: LD_VAR 0 2
6359: PPUSH
6360: LD_INT 147
6362: PPUSH
6363: LD_INT 161
6365: PPUSH
6366: CALL_OW 111
// wait ( 0 0$2 ) ;
6370: LD_INT 70
6372: PPUSH
6373: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6377: LD_ADDR_VAR 0 3
6381: PUSH
6382: LD_VAR 0 3
6386: PPUSH
6387: LD_VAR 0 3
6391: PUSH
6392: LD_INT 1
6394: PLUS
6395: PPUSH
6396: LD_VAR 0 2
6400: PPUSH
6401: CALL_OW 1
6405: ST_TO_ADDR
// end ;
6406: GO 6265
6408: POP
6409: POP
// for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6410: LD_ADDR_VAR 0 1
6414: PUSH
6415: DOUBLE
6416: LD_INT 1
6418: DEC
6419: ST_TO_ADDR
6420: LD_INT 3
6422: PUSH
6423: LD_INT 4
6425: PUSH
6426: LD_INT 5
6428: PUSH
6429: EMPTY
6430: LIST
6431: LIST
6432: LIST
6433: PUSH
6434: LD_OWVAR 67
6438: ARRAY
6439: PUSH
6440: FOR_TO
6441: IFFALSE 6559
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] , 90 ) ;
6443: LD_INT 24
6445: PPUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: LD_INT 46
6454: PUSH
6455: LD_INT 45
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PUSH
6462: LD_INT 1
6464: PPUSH
6465: LD_INT 2
6467: PPUSH
6468: CALL_OW 12
6472: ARRAY
6473: PPUSH
6474: LD_INT 90
6476: PPUSH
6477: CALL 13497 0 5
// un := CreateVehicle ;
6481: LD_ADDR_VAR 0 2
6485: PUSH
6486: CALL_OW 45
6490: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
6491: LD_VAR 0 2
6495: PPUSH
6496: LD_INT 18
6498: PPUSH
6499: LD_INT 0
6501: PPUSH
6502: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
6506: LD_VAR 0 2
6510: PPUSH
6511: LD_INT 147
6513: PPUSH
6514: LD_INT 161
6516: PPUSH
6517: CALL_OW 111
// wait ( 0 0$3 ) ;
6521: LD_INT 105
6523: PPUSH
6524: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6528: LD_ADDR_VAR 0 3
6532: PUSH
6533: LD_VAR 0 3
6537: PPUSH
6538: LD_VAR 0 3
6542: PUSH
6543: LD_INT 1
6545: PLUS
6546: PPUSH
6547: LD_VAR 0 2
6551: PPUSH
6552: CALL_OW 1
6556: ST_TO_ADDR
// end ;
6557: GO 6440
6559: POP
6560: POP
// if not tmp then
6561: LD_VAR 0 3
6565: NOT
6566: IFFALSE 6570
// exit ;
6568: GO 6705
// wait ( 0 0$5 ) ;
6570: LD_INT 175
6572: PPUSH
6573: CALL_OW 67
// repeat wait ( 0 0$3 ) ;
6577: LD_INT 105
6579: PPUSH
6580: CALL_OW 67
// for i in tmp do
6584: LD_ADDR_VAR 0 1
6588: PUSH
6589: LD_VAR 0 3
6593: PUSH
6594: FOR_IN
6595: IFFALSE 6696
// begin if not IsOk ( i ) or IsDead ( i ) then
6597: LD_VAR 0 1
6601: PPUSH
6602: CALL_OW 302
6606: NOT
6607: PUSH
6608: LD_VAR 0 1
6612: PPUSH
6613: CALL_OW 301
6617: OR
6618: IFFALSE 6636
// tmp := tmp diff i ;
6620: LD_ADDR_VAR 0 3
6624: PUSH
6625: LD_VAR 0 3
6629: PUSH
6630: LD_VAR 0 1
6634: DIFF
6635: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
6636: LD_VAR 0 1
6640: PPUSH
6641: CALL_OW 257
6645: PUSH
6646: LD_INT 9
6648: EQUAL
6649: IFFALSE 6660
// ComSpaceTimeShoot ( i ) ;
6651: LD_VAR 0 1
6655: PPUSH
6656: CALL 9580 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
6660: LD_VAR 0 1
6664: PPUSH
6665: LD_INT 81
6667: PUSH
6668: LD_INT 3
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: PPUSH
6675: CALL_OW 69
6679: PPUSH
6680: LD_VAR 0 1
6684: PPUSH
6685: CALL_OW 74
6689: PPUSH
6690: CALL_OW 115
// end ;
6694: GO 6594
6696: POP
6697: POP
// until not tmp ;
6698: LD_VAR 0 3
6702: NOT
6703: IFFALSE 6577
// end ; end_of_file
6705: PPOPN 3
6707: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
6708: LD_INT 0
6710: PPUSH
6711: PPUSH
6712: PPUSH
6713: PPUSH
// uc_side := 1 ;
6714: LD_ADDR_OWVAR 20
6718: PUSH
6719: LD_INT 1
6721: ST_TO_ADDR
// uc_nation := 1 ;
6722: LD_ADDR_OWVAR 21
6726: PUSH
6727: LD_INT 1
6729: ST_TO_ADDR
// hc_importance := 100 ;
6730: LD_ADDR_OWVAR 32
6734: PUSH
6735: LD_INT 100
6737: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
6738: LD_ADDR_OWVAR 26
6742: PUSH
6743: LD_STRING Jeremy Sikorski
6745: ST_TO_ADDR
// hc_gallery := us ;
6746: LD_ADDR_OWVAR 33
6750: PUSH
6751: LD_STRING us
6753: ST_TO_ADDR
// hc_face_number := 19 ;
6754: LD_ADDR_OWVAR 34
6758: PUSH
6759: LD_INT 19
6761: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
6762: LD_INT 1
6764: PPUSH
6765: LD_INT 1
6767: PPUSH
6768: LD_INT 4
6770: PUSH
6771: LD_INT 4
6773: PUSH
6774: LD_INT 3
6776: PUSH
6777: EMPTY
6778: LIST
6779: LIST
6780: LIST
6781: PUSH
6782: LD_OWVAR 67
6786: ARRAY
6787: PPUSH
6788: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
6792: LD_ADDR_OWVAR 29
6796: PUSH
6797: LD_INT 10
6799: PUSH
6800: LD_INT 12
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: ST_TO_ADDR
// Sikorski := CreateHuman ;
6807: LD_ADDR_EXP 20
6811: PUSH
6812: CALL_OW 44
6816: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
6817: LD_EXP 20
6821: PPUSH
6822: LD_INT 133
6824: PPUSH
6825: LD_INT 19
6827: PPUSH
6828: LD_INT 2
6830: PPUSH
6831: LD_INT 0
6833: PPUSH
6834: CALL_OW 50
// InitHc_All ( ) ;
6838: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
6842: LD_ADDR_VAR 0 2
6846: PUSH
6847: DOUBLE
6848: LD_INT 1
6850: DEC
6851: ST_TO_ADDR
6852: LD_INT 4
6854: PUSH
6855: LD_INT 3
6857: PUSH
6858: LD_INT 3
6860: PUSH
6861: EMPTY
6862: LIST
6863: LIST
6864: LIST
6865: PUSH
6866: LD_OWVAR 67
6870: ARRAY
6871: PUSH
6872: FOR_TO
6873: IFFALSE 6989
// for j := 1 to 4 do
6875: LD_ADDR_VAR 0 3
6879: PUSH
6880: DOUBLE
6881: LD_INT 1
6883: DEC
6884: ST_TO_ADDR
6885: LD_INT 4
6887: PUSH
6888: FOR_TO
6889: IFFALSE 6985
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
6891: LD_INT 0
6893: PPUSH
6894: LD_VAR 0 3
6898: PPUSH
6899: LD_INT 5
6901: PUSH
6902: LD_INT 4
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: EMPTY
6909: LIST
6910: LIST
6911: LIST
6912: PUSH
6913: LD_OWVAR 67
6917: ARRAY
6918: PPUSH
6919: CALL_OW 380
// un := CreateHuman ;
6923: LD_ADDR_VAR 0 4
6927: PUSH
6928: CALL_OW 44
6932: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
6933: LD_VAR 0 4
6937: PPUSH
6938: LD_INT 0
6940: PPUSH
6941: LD_INT 5
6943: PPUSH
6944: CALL_OW 12
6948: PPUSH
6949: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
6953: LD_VAR 0 4
6957: PPUSH
6958: LD_INT 133
6960: PPUSH
6961: LD_INT 19
6963: PPUSH
6964: LD_INT 6
6966: PPUSH
6967: LD_INT 0
6969: PPUSH
6970: CALL_OW 50
// ComHold ( un ) ;
6974: LD_VAR 0 4
6978: PPUSH
6979: CALL_OW 140
// end ;
6983: GO 6888
6985: POP
6986: POP
6987: GO 6872
6989: POP
6990: POP
// vc_chassis := us_heavy_tracked ;
6991: LD_ADDR_OWVAR 37
6995: PUSH
6996: LD_INT 4
6998: ST_TO_ADDR
// vc_engine := engine_combustion ;
6999: LD_ADDR_OWVAR 39
7003: PUSH
7004: LD_INT 1
7006: ST_TO_ADDR
// vc_control := control_manual ;
7007: LD_ADDR_OWVAR 38
7011: PUSH
7012: LD_INT 1
7014: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7015: LD_ADDR_OWVAR 40
7019: PUSH
7020: LD_INT 14
7022: ST_TO_ADDR
// vc_fuel_battery := 60 ;
7023: LD_ADDR_OWVAR 41
7027: PUSH
7028: LD_INT 60
7030: ST_TO_ADDR
// un := CreateVehicle ;
7031: LD_ADDR_VAR 0 4
7035: PUSH
7036: CALL_OW 45
7040: ST_TO_ADDR
// SetDir ( un , 2 ) ;
7041: LD_VAR 0 4
7045: PPUSH
7046: LD_INT 2
7048: PPUSH
7049: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
7053: LD_VAR 0 4
7057: PPUSH
7058: LD_INT 128
7060: PPUSH
7061: LD_INT 12
7063: PPUSH
7064: LD_INT 0
7066: PPUSH
7067: CALL_OW 48
// for i := 1 to 3 do
7071: LD_ADDR_VAR 0 2
7075: PUSH
7076: DOUBLE
7077: LD_INT 1
7079: DEC
7080: ST_TO_ADDR
7081: LD_INT 3
7083: PUSH
7084: FOR_TO
7085: IFFALSE 7108
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
7087: LD_INT 5
7089: PPUSH
7090: LD_INT 133
7092: PPUSH
7093: LD_INT 19
7095: PPUSH
7096: LD_INT 3
7098: PPUSH
7099: LD_INT 0
7101: PPUSH
7102: CALL_OW 56
7106: GO 7084
7108: POP
7109: POP
// end ; end_of_file
7110: LD_VAR 0 1
7114: RET
// export function Action ; begin
7115: LD_INT 0
7117: PPUSH
// InGameOn ;
7118: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
7122: LD_INT 133
7124: PPUSH
7125: LD_INT 19
7127: PPUSH
7128: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
7132: LD_EXP 20
7136: PPUSH
7137: LD_STRING WT-DS-1
7139: PPUSH
7140: CALL_OW 88
// InGameOff ;
7144: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
7148: LD_STRING DestroyEnemy
7150: PPUSH
7151: CALL_OW 337
// wait ( 0 0$20 ) ;
7155: LD_INT 700
7157: PPUSH
7158: CALL_OW 67
// DialogueOn ;
7162: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
7166: LD_INT 100
7168: PPUSH
7169: LD_INT 37
7171: PPUSH
7172: LD_INT 1
7174: PPUSH
7175: LD_INT 30
7177: NEG
7178: PPUSH
7179: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
7183: LD_INT 100
7185: PPUSH
7186: LD_INT 37
7188: PPUSH
7189: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
7193: LD_EXP 10
7197: PPUSH
7198: LD_STRING WT-PL-1
7200: PPUSH
7201: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
7205: LD_EXP 20
7209: PPUSH
7210: LD_STRING WT-DS-2
7212: PPUSH
7213: CALL_OW 88
// DialogueOff ;
7217: CALL_OW 7
// wait ( 0 0$2 ) ;
7221: LD_INT 70
7223: PPUSH
7224: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
7228: LD_INT 100
7230: PPUSH
7231: LD_INT 37
7233: PPUSH
7234: LD_INT 1
7236: PPUSH
7237: CALL_OW 331
// end ;
7241: LD_VAR 0 1
7245: RET
// export function DialogPowellsAttack ; begin
7246: LD_INT 0
7248: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
7249: LD_EXP 10
7253: PPUSH
7254: LD_STRING WT-PL-8
7256: PPUSH
7257: CALL_OW 94
// end ;
7261: LD_VAR 0 1
7265: RET
// export function DialogContaminateSib ( x , y ) ; begin
7266: LD_INT 0
7268: PPUSH
// DialogueOn ;
7269: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
7273: LD_VAR 0 1
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
7287: LD_EXP 20
7291: PPUSH
7292: LD_STRING WT-DS-3
7294: PPUSH
7295: CALL_OW 88
// DialogueOff ;
7299: CALL_OW 7
// end ;
7303: LD_VAR 0 3
7307: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
7308: LD_EXP 8
7312: NOT
7313: PUSH
7314: LD_INT 1
7316: PPUSH
7317: LD_INT 81
7319: PUSH
7320: LD_INT 4
7322: PUSH
7323: EMPTY
7324: LIST
7325: LIST
7326: PPUSH
7327: CALL_OW 70
7331: PUSH
7332: LD_INT 3
7334: GREATER
7335: AND
7336: IFFALSE 7408
7338: GO 7340
7340: DISABLE
// begin powellInTrouble := true ;
7341: LD_ADDR_EXP 8
7345: PUSH
7346: LD_INT 1
7348: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
7349: LD_EXP 20
7353: PPUSH
7354: LD_STRING WT-DS-6
7356: PPUSH
7357: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
7361: LD_INT 1
7363: PPUSH
7364: LD_INT 22
7366: PUSH
7367: LD_INT 1
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PPUSH
7374: CALL_OW 70
7378: NOT
7379: IFFALSE 7393
// SayRadio ( Powell , WT-PL-6 ) ;
7381: LD_EXP 10
7385: PPUSH
7386: LD_STRING WT-PL-6
7388: PPUSH
7389: CALL_OW 94
// wait ( 1 1$30 ) ;
7393: LD_INT 3150
7395: PPUSH
7396: CALL_OW 67
// powellInTrouble := false ;
7400: LD_ADDR_EXP 8
7404: PUSH
7405: LD_INT 0
7407: ST_TO_ADDR
// end ;
7408: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
7409: LD_EXP 9
7413: NOT
7414: PUSH
7415: LD_INT 16
7417: PPUSH
7418: LD_INT 81
7420: PUSH
7421: LD_INT 1
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: PPUSH
7428: CALL_OW 70
7432: PUSH
7433: LD_INT 6
7435: GREATER
7436: AND
7437: IFFALSE 7510
7439: GO 7441
7441: DISABLE
// begin sikorskiInTrouble := true ;
7442: LD_ADDR_EXP 9
7446: PUSH
7447: LD_INT 1
7449: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
7450: LD_EXP 20
7454: PPUSH
7455: LD_STRING WT-DS-7
7457: PPUSH
7458: CALL_OW 88
// if not powellAttackGroup then
7462: LD_EXP 12
7466: NOT
7467: IFFALSE 7483
// SayRadio ( Powell , WT-PL-7n ) else
7469: LD_EXP 10
7473: PPUSH
7474: LD_STRING WT-PL-7n
7476: PPUSH
7477: CALL_OW 94
7481: GO 7495
// SayRadio ( Powell , WT-PL-7y ) ;
7483: LD_EXP 10
7487: PPUSH
7488: LD_STRING WT-PL-7y
7490: PPUSH
7491: CALL_OW 94
// wait ( 1 1$30 ) ;
7495: LD_INT 3150
7497: PPUSH
7498: CALL_OW 67
// sikorskiInTrouble := false ;
7502: LD_ADDR_EXP 9
7506: PUSH
7507: LD_INT 0
7509: ST_TO_ADDR
// end ;
7510: END
// export function DialogPowellsAttackFailed ; begin
7511: LD_INT 0
7513: PPUSH
// if not ruDestroyed then
7514: LD_EXP 5
7518: NOT
7519: IFFALSE 7535
// SayRadio ( Powell , WT-PL-9 ) else
7521: LD_EXP 10
7525: PPUSH
7526: LD_STRING WT-PL-9
7528: PPUSH
7529: CALL_OW 94
7533: GO 7547
// SayRadio ( Powell , WT-PL-10 ) ;
7535: LD_EXP 10
7539: PPUSH
7540: LD_STRING WT-PL-10
7542: PPUSH
7543: CALL_OW 94
// end ;
7547: LD_VAR 0 1
7551: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
7552: LD_INT 22
7554: PUSH
7555: LD_INT 2
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: LD_INT 21
7564: PUSH
7565: LD_INT 1
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: PPUSH
7576: CALL_OW 69
7580: PUSH
7581: LD_INT 0
7583: EQUAL
7584: IFFALSE 7628
7586: GO 7588
7588: DISABLE
// begin arDestroyed := true ;
7589: LD_ADDR_EXP 4
7593: PUSH
7594: LD_INT 1
7596: ST_TO_ADDR
// MC_Kill ( 2 ) ;
7597: LD_INT 2
7599: PPUSH
7600: CALL 47349 0 1
// Say ( Sikorski , WT-DS-4 ) ;
7604: LD_EXP 20
7608: PPUSH
7609: LD_STRING WT-DS-4
7611: PPUSH
7612: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
7616: LD_EXP 10
7620: PPUSH
7621: LD_STRING WT-PL-4
7623: PPUSH
7624: CALL_OW 94
// end ;
7628: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
7629: LD_INT 22
7631: PUSH
7632: LD_INT 3
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PUSH
7639: LD_INT 21
7641: PUSH
7642: LD_INT 1
7644: PUSH
7645: EMPTY
7646: LIST
7647: LIST
7648: PUSH
7649: EMPTY
7650: LIST
7651: LIST
7652: PPUSH
7653: CALL_OW 69
7657: PUSH
7658: LD_INT 0
7660: EQUAL
7661: IFFALSE 7705
7663: GO 7665
7665: DISABLE
// begin ruDestroyed := true ;
7666: LD_ADDR_EXP 5
7670: PUSH
7671: LD_INT 1
7673: ST_TO_ADDR
// MC_Kill ( 3 ) ;
7674: LD_INT 3
7676: PPUSH
7677: CALL 47349 0 1
// Say ( Sikorski , WT-DS-5 ) ;
7681: LD_EXP 20
7685: PPUSH
7686: LD_STRING WT-DS-5
7688: PPUSH
7689: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
7693: LD_EXP 10
7697: PPUSH
7698: LD_STRING WT-PL-5
7700: PPUSH
7701: CALL_OW 94
// end ;
7705: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
7706: LD_EXP 5
7710: PUSH
7711: LD_EXP 4
7715: AND
7716: IFFALSE 7889
7718: GO 7720
7720: DISABLE
// begin wait ( 0 0$3 ) ;
7721: LD_INT 105
7723: PPUSH
7724: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
7728: LD_OWVAR 1
7732: PUSH
7733: LD_INT 126000
7735: PUSH
7736: LD_INT 105000
7738: PUSH
7739: LD_INT 94500
7741: PUSH
7742: EMPTY
7743: LIST
7744: LIST
7745: LIST
7746: PUSH
7747: LD_OWVAR 67
7751: ARRAY
7752: GREATEREQUAL
7753: IFFALSE 7768
// AddMedal ( WoT-med-1 , - 1 ) else
7755: LD_STRING WoT-med-1
7757: PPUSH
7758: LD_INT 1
7760: NEG
7761: PPUSH
7762: CALL_OW 101
7766: GO 7778
// AddMedal ( WoT-med-1 , 1 ) ;
7768: LD_STRING WoT-med-1
7770: PPUSH
7771: LD_INT 1
7773: PPUSH
7774: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
7778: LD_EXP 6
7782: PUSH
7783: LD_INT 4
7785: PUSH
7786: LD_INT 3
7788: PUSH
7789: LD_INT 2
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: LD_OWVAR 67
7801: ARRAY
7802: GREATEREQUAL
7803: IFFALSE 7818
// AddMedal ( WoT-med-2 , - 1 ) else
7805: LD_STRING WoT-med-2
7807: PPUSH
7808: LD_INT 1
7810: NEG
7811: PPUSH
7812: CALL_OW 101
7816: GO 7828
// AddMedal ( WoT-med-2 , 1 ) ;
7818: LD_STRING WoT-med-2
7820: PPUSH
7821: LD_INT 1
7823: PPUSH
7824: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
7828: LD_EXP 7
7832: PUSH
7833: LD_INT 8
7835: PUSH
7836: LD_INT 6
7838: PUSH
7839: LD_INT 5
7841: PUSH
7842: EMPTY
7843: LIST
7844: LIST
7845: LIST
7846: PUSH
7847: LD_OWVAR 67
7851: ARRAY
7852: GREATEREQUAL
7853: IFFALSE 7868
// AddMedal ( WoT-med-3 , - 1 ) else
7855: LD_STRING WoT-med-3
7857: PPUSH
7858: LD_INT 1
7860: NEG
7861: PPUSH
7862: CALL_OW 101
7866: GO 7878
// AddMedal ( WoT-med-3 , 1 ) ;
7868: LD_STRING WoT-med-3
7870: PPUSH
7871: LD_INT 1
7873: PPUSH
7874: CALL_OW 101
// GiveMedals ( MAIN ) ;
7878: LD_STRING MAIN
7880: PPUSH
7881: CALL_OW 102
// YouWin ;
7885: CALL_OW 103
// end ; end_of_file
7889: END
// export function CustomEvent ( event ) ; begin
7890: LD_INT 0
7892: PPUSH
// end ;
7893: LD_VAR 0 2
7897: RET
// on Command ( com ) do var i , j , temp ;
7898: LD_INT 0
7900: PPUSH
7901: PPUSH
7902: PPUSH
// begin if com = 60 then
7903: LD_VAR 0 1
7907: PUSH
7908: LD_INT 60
7910: EQUAL
7911: IFFALSE 8090
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
7913: LD_ADDR_VAR 0 2
7917: PUSH
7918: LD_INT 22
7920: PUSH
7921: LD_INT 1
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PUSH
7928: LD_INT 2
7930: PUSH
7931: LD_INT 21
7933: PUSH
7934: LD_INT 1
7936: PUSH
7937: EMPTY
7938: LIST
7939: LIST
7940: PUSH
7941: LD_INT 34
7943: PUSH
7944: LD_INT 12
7946: PUSH
7947: EMPTY
7948: LIST
7949: LIST
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: PUSH
7956: EMPTY
7957: LIST
7958: LIST
7959: PPUSH
7960: CALL_OW 69
7964: PUSH
7965: FOR_IN
7966: IFFALSE 8088
// begin if GetTaskList ( i ) > 0 then
7968: LD_VAR 0 2
7972: PPUSH
7973: CALL_OW 437
7977: PUSH
7978: LD_INT 0
7980: GREATER
7981: IFFALSE 8086
// for j = 1 to GetTaskList ( i ) do
7983: LD_ADDR_VAR 0 3
7987: PUSH
7988: DOUBLE
7989: LD_INT 1
7991: DEC
7992: ST_TO_ADDR
7993: LD_VAR 0 2
7997: PPUSH
7998: CALL_OW 437
8002: PUSH
8003: FOR_TO
8004: IFFALSE 8084
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
8006: LD_ADDR_VAR 0 4
8010: PUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL_OW 437
8020: PUSH
8021: LD_VAR 0 3
8025: ARRAY
8026: PUSH
8027: LD_INT 4
8029: ARRAY
8030: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
8031: LD_VAR 0 4
8035: PPUSH
8036: CALL_OW 255
8040: PUSH
8041: LD_INT 4
8043: EQUAL
8044: PUSH
8045: LD_VAR 0 2
8049: PPUSH
8050: CALL_OW 437
8054: PUSH
8055: LD_VAR 0 3
8059: ARRAY
8060: PUSH
8061: LD_INT 1
8063: ARRAY
8064: PUSH
8065: LD_STRING <
8067: EQUAL
8068: AND
8069: IFFALSE 8082
// SetTaskList ( i , [ ] ) ;
8071: LD_VAR 0 2
8075: PPUSH
8076: EMPTY
8077: PPUSH
8078: CALL_OW 446
// end ;
8082: GO 8003
8084: POP
8085: POP
// end ;
8086: GO 7965
8088: POP
8089: POP
// end ; end ;
8090: PPOPN 4
8092: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 then
8093: LD_VAR 0 2
8097: PPUSH
8098: LD_VAR 0 3
8102: PPUSH
8103: CALL_OW 428
8107: PPUSH
8108: CALL_OW 255
8112: PUSH
8113: LD_INT 1
8115: EQUAL
8116: IFFALSE 8132
// DialogContaminateSib ( x , y ) ;
8118: LD_VAR 0 2
8122: PPUSH
8123: LD_VAR 0 3
8127: PPUSH
8128: CALL 7266 0 2
// end ;
8132: PPOPN 3
8134: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
8135: LD_VAR 0 1
8139: PPUSH
8140: CALL 74437 0 1
// if un = Powell then
8144: LD_VAR 0 1
8148: PUSH
8149: LD_EXP 10
8153: EQUAL
8154: IFFALSE 8163
// YouLost ( Powell ) ;
8156: LD_STRING Powell
8158: PPUSH
8159: CALL_OW 104
// if un = Sikorski then
8163: LD_VAR 0 1
8167: PUSH
8168: LD_EXP 20
8172: EQUAL
8173: IFFALSE 8182
// YouLost ( Sikorski ) ;
8175: LD_STRING Sikorski
8177: PPUSH
8178: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
8182: LD_VAR 0 1
8186: PUSH
8187: LD_INT 22
8189: PUSH
8190: LD_INT 1
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: PUSH
8197: LD_INT 21
8199: PUSH
8200: LD_INT 1
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PPUSH
8211: CALL_OW 69
8215: IN
8216: IFFALSE 8232
// loseCounter := loseCounter + 1 ;
8218: LD_ADDR_EXP 6
8222: PUSH
8223: LD_EXP 6
8227: PUSH
8228: LD_INT 1
8230: PLUS
8231: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
8232: LD_VAR 0 1
8236: PUSH
8237: LD_INT 22
8239: PUSH
8240: LD_INT 4
8242: PUSH
8243: EMPTY
8244: LIST
8245: LIST
8246: PUSH
8247: LD_INT 21
8249: PUSH
8250: LD_INT 1
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PUSH
8257: EMPTY
8258: LIST
8259: LIST
8260: PPUSH
8261: CALL_OW 69
8265: IN
8266: IFFALSE 8282
// powellLoseCounter := powellLoseCounter + 1 ;
8268: LD_ADDR_EXP 7
8272: PUSH
8273: LD_EXP 7
8277: PUSH
8278: LD_INT 1
8280: PLUS
8281: ST_TO_ADDR
// if un in powellAttackGroup then
8282: LD_VAR 0 1
8286: PUSH
8287: LD_EXP 12
8291: IN
8292: IFFALSE 8310
// powellAttackGroup := powellAttackGroup diff un ;
8294: LD_ADDR_EXP 12
8298: PUSH
8299: LD_EXP 12
8303: PUSH
8304: LD_VAR 0 1
8308: DIFF
8309: ST_TO_ADDR
// if un in gensherAttackGroup then
8310: LD_VAR 0 1
8314: PUSH
8315: LD_EXP 15
8319: IN
8320: IFFALSE 8338
// gensherAttackGroup := gensherAttackGroup diff un ;
8322: LD_ADDR_EXP 15
8326: PUSH
8327: LD_EXP 15
8331: PUSH
8332: LD_VAR 0 1
8336: DIFF
8337: ST_TO_ADDR
// if un in popovAttackGroup then
8338: LD_VAR 0 1
8342: PUSH
8343: LD_EXP 19
8347: IN
8348: IFFALSE 8366
// popovAttackGroup := popovAttackGroup diff un ;
8350: LD_ADDR_EXP 19
8354: PUSH
8355: LD_EXP 19
8359: PUSH
8360: LD_VAR 0 1
8364: DIFF
8365: ST_TO_ADDR
// end ;
8366: PPOPN 1
8368: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
8369: LD_VAR 0 1
8373: PPUSH
8374: LD_VAR 0 2
8378: PPUSH
8379: CALL 76771 0 2
// end ;
8383: PPOPN 2
8385: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
8386: LD_VAR 0 1
8390: PPUSH
8391: CALL 75839 0 1
// end ;
8395: PPOPN 1
8397: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
8398: LD_VAR 0 1
8402: PPUSH
8403: CALL 76080 0 1
// end ;
8407: PPOPN 1
8409: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
8410: LD_VAR 0 1
8414: PPUSH
8415: LD_VAR 0 2
8419: PPUSH
8420: CALL 74133 0 2
// end ;
8424: PPOPN 2
8426: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
8427: LD_VAR 0 1
8431: PPUSH
8432: LD_VAR 0 2
8436: PPUSH
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_VAR 0 4
8446: PPUSH
8447: LD_VAR 0 5
8451: PPUSH
8452: CALL 73753 0 5
// end ;
8456: PPOPN 5
8458: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
8459: LD_VAR 0 1
8463: PPUSH
8464: LD_VAR 0 2
8468: PPUSH
8469: CALL 73343 0 2
// end ;
8473: PPOPN 2
8475: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
8476: LD_VAR 0 1
8480: PPUSH
8481: LD_VAR 0 2
8485: PPUSH
8486: LD_VAR 0 3
8490: PPUSH
8491: LD_VAR 0 4
8495: PPUSH
8496: CALL 73181 0 4
// end ;
8500: PPOPN 4
8502: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
8503: LD_VAR 0 1
8507: PPUSH
8508: LD_VAR 0 2
8512: PPUSH
8513: LD_VAR 0 3
8517: PPUSH
8518: CALL 72956 0 3
// end ;
8522: PPOPN 3
8524: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
8525: LD_VAR 0 1
8529: PPUSH
8530: LD_VAR 0 2
8534: PPUSH
8535: CALL 72841 0 2
// end ;
8539: PPOPN 2
8541: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
8542: LD_VAR 0 1
8546: PPUSH
8547: LD_VAR 0 2
8551: PPUSH
8552: CALL 77066 0 2
// end ;
8556: PPOPN 2
8558: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
8559: LD_VAR 0 1
8563: PPUSH
8564: LD_VAR 0 2
8568: PPUSH
8569: LD_VAR 0 3
8573: PPUSH
8574: LD_VAR 0 4
8578: PPUSH
8579: CALL 77282 0 4
// end ;
8583: PPOPN 4
8585: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
8586: LD_VAR 0 1
8590: PPUSH
8591: LD_VAR 0 2
8595: PPUSH
8596: CALL 72650 0 2
// end ;
8600: PPOPN 2
8602: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
8603: LD_VAR 0 1
8607: PUSH
8608: LD_INT 1
8610: EQUAL
8611: PUSH
8612: LD_VAR 0 2
8616: PUSH
8617: LD_INT 4
8619: EQUAL
8620: AND
8621: IFFALSE 8630
// YouLost ( FriendlyFire ) ;
8623: LD_STRING FriendlyFire
8625: PPUSH
8626: CALL_OW 104
// end ; end_of_file
8630: PPOPN 2
8632: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
8633: LD_INT 0
8635: PPUSH
8636: PPUSH
// if exist_mode then
8637: LD_VAR 0 2
8641: IFFALSE 8666
// unit := CreateCharacter ( prefix & ident ) else
8643: LD_ADDR_VAR 0 5
8647: PUSH
8648: LD_VAR 0 3
8652: PUSH
8653: LD_VAR 0 1
8657: STR
8658: PPUSH
8659: CALL_OW 34
8663: ST_TO_ADDR
8664: GO 8681
// unit := NewCharacter ( ident ) ;
8666: LD_ADDR_VAR 0 5
8670: PUSH
8671: LD_VAR 0 1
8675: PPUSH
8676: CALL_OW 25
8680: ST_TO_ADDR
// result := unit ;
8681: LD_ADDR_VAR 0 4
8685: PUSH
8686: LD_VAR 0 5
8690: ST_TO_ADDR
// end ;
8691: LD_VAR 0 4
8695: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
8696: LD_INT 0
8698: PPUSH
8699: PPUSH
// if not side or not nation then
8700: LD_VAR 0 1
8704: NOT
8705: PUSH
8706: LD_VAR 0 2
8710: NOT
8711: OR
8712: IFFALSE 8716
// exit ;
8714: GO 9484
// case nation of nation_american :
8716: LD_VAR 0 2
8720: PUSH
8721: LD_INT 1
8723: DOUBLE
8724: EQUAL
8725: IFTRUE 8729
8727: GO 8943
8729: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
8730: LD_ADDR_VAR 0 4
8734: PUSH
8735: LD_INT 35
8737: PUSH
8738: LD_INT 45
8740: PUSH
8741: LD_INT 46
8743: PUSH
8744: LD_INT 47
8746: PUSH
8747: LD_INT 82
8749: PUSH
8750: LD_INT 83
8752: PUSH
8753: LD_INT 84
8755: PUSH
8756: LD_INT 85
8758: PUSH
8759: LD_INT 86
8761: PUSH
8762: LD_INT 1
8764: PUSH
8765: LD_INT 2
8767: PUSH
8768: LD_INT 6
8770: PUSH
8771: LD_INT 15
8773: PUSH
8774: LD_INT 16
8776: PUSH
8777: LD_INT 7
8779: PUSH
8780: LD_INT 12
8782: PUSH
8783: LD_INT 13
8785: PUSH
8786: LD_INT 10
8788: PUSH
8789: LD_INT 14
8791: PUSH
8792: LD_INT 20
8794: PUSH
8795: LD_INT 21
8797: PUSH
8798: LD_INT 22
8800: PUSH
8801: LD_INT 25
8803: PUSH
8804: LD_INT 32
8806: PUSH
8807: LD_INT 27
8809: PUSH
8810: LD_INT 36
8812: PUSH
8813: LD_INT 69
8815: PUSH
8816: LD_INT 39
8818: PUSH
8819: LD_INT 34
8821: PUSH
8822: LD_INT 40
8824: PUSH
8825: LD_INT 48
8827: PUSH
8828: LD_INT 49
8830: PUSH
8831: LD_INT 50
8833: PUSH
8834: LD_INT 51
8836: PUSH
8837: LD_INT 52
8839: PUSH
8840: LD_INT 53
8842: PUSH
8843: LD_INT 54
8845: PUSH
8846: LD_INT 55
8848: PUSH
8849: LD_INT 56
8851: PUSH
8852: LD_INT 57
8854: PUSH
8855: LD_INT 58
8857: PUSH
8858: LD_INT 59
8860: PUSH
8861: LD_INT 60
8863: PUSH
8864: LD_INT 61
8866: PUSH
8867: LD_INT 62
8869: PUSH
8870: LD_INT 80
8872: PUSH
8873: LD_INT 82
8875: PUSH
8876: LD_INT 83
8878: PUSH
8879: LD_INT 84
8881: PUSH
8882: LD_INT 85
8884: PUSH
8885: LD_INT 86
8887: PUSH
8888: EMPTY
8889: LIST
8890: LIST
8891: LIST
8892: LIST
8893: LIST
8894: LIST
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: LIST
8901: LIST
8902: LIST
8903: LIST
8904: LIST
8905: LIST
8906: LIST
8907: LIST
8908: LIST
8909: LIST
8910: LIST
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: LIST
8916: LIST
8917: LIST
8918: LIST
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: LIST
8925: LIST
8926: LIST
8927: LIST
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: LIST
8936: LIST
8937: LIST
8938: LIST
8939: LIST
8940: ST_TO_ADDR
8941: GO 9408
8943: LD_INT 2
8945: DOUBLE
8946: EQUAL
8947: IFTRUE 8951
8949: GO 9177
8951: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
8952: LD_ADDR_VAR 0 4
8956: PUSH
8957: LD_INT 35
8959: PUSH
8960: LD_INT 45
8962: PUSH
8963: LD_INT 46
8965: PUSH
8966: LD_INT 47
8968: PUSH
8969: LD_INT 82
8971: PUSH
8972: LD_INT 83
8974: PUSH
8975: LD_INT 84
8977: PUSH
8978: LD_INT 85
8980: PUSH
8981: LD_INT 87
8983: PUSH
8984: LD_INT 70
8986: PUSH
8987: LD_INT 1
8989: PUSH
8990: LD_INT 11
8992: PUSH
8993: LD_INT 3
8995: PUSH
8996: LD_INT 4
8998: PUSH
8999: LD_INT 5
9001: PUSH
9002: LD_INT 6
9004: PUSH
9005: LD_INT 15
9007: PUSH
9008: LD_INT 18
9010: PUSH
9011: LD_INT 7
9013: PUSH
9014: LD_INT 17
9016: PUSH
9017: LD_INT 8
9019: PUSH
9020: LD_INT 20
9022: PUSH
9023: LD_INT 21
9025: PUSH
9026: LD_INT 22
9028: PUSH
9029: LD_INT 72
9031: PUSH
9032: LD_INT 26
9034: PUSH
9035: LD_INT 69
9037: PUSH
9038: LD_INT 39
9040: PUSH
9041: LD_INT 40
9043: PUSH
9044: LD_INT 41
9046: PUSH
9047: LD_INT 42
9049: PUSH
9050: LD_INT 43
9052: PUSH
9053: LD_INT 48
9055: PUSH
9056: LD_INT 49
9058: PUSH
9059: LD_INT 50
9061: PUSH
9062: LD_INT 51
9064: PUSH
9065: LD_INT 52
9067: PUSH
9068: LD_INT 53
9070: PUSH
9071: LD_INT 54
9073: PUSH
9074: LD_INT 55
9076: PUSH
9077: LD_INT 56
9079: PUSH
9080: LD_INT 60
9082: PUSH
9083: LD_INT 61
9085: PUSH
9086: LD_INT 62
9088: PUSH
9089: LD_INT 66
9091: PUSH
9092: LD_INT 67
9094: PUSH
9095: LD_INT 68
9097: PUSH
9098: LD_INT 81
9100: PUSH
9101: LD_INT 82
9103: PUSH
9104: LD_INT 83
9106: PUSH
9107: LD_INT 84
9109: PUSH
9110: LD_INT 85
9112: PUSH
9113: LD_INT 87
9115: PUSH
9116: LD_INT 88
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: LIST
9123: LIST
9124: LIST
9125: LIST
9126: LIST
9127: LIST
9128: LIST
9129: LIST
9130: LIST
9131: LIST
9132: LIST
9133: LIST
9134: LIST
9135: LIST
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: LIST
9147: LIST
9148: LIST
9149: LIST
9150: LIST
9151: LIST
9152: LIST
9153: LIST
9154: LIST
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: LIST
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: LIST
9172: LIST
9173: LIST
9174: ST_TO_ADDR
9175: GO 9408
9177: LD_INT 3
9179: DOUBLE
9180: EQUAL
9181: IFTRUE 9185
9183: GO 9407
9185: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
9186: LD_ADDR_VAR 0 4
9190: PUSH
9191: LD_INT 46
9193: PUSH
9194: LD_INT 47
9196: PUSH
9197: LD_INT 1
9199: PUSH
9200: LD_INT 2
9202: PUSH
9203: LD_INT 82
9205: PUSH
9206: LD_INT 83
9208: PUSH
9209: LD_INT 84
9211: PUSH
9212: LD_INT 85
9214: PUSH
9215: LD_INT 86
9217: PUSH
9218: LD_INT 11
9220: PUSH
9221: LD_INT 9
9223: PUSH
9224: LD_INT 20
9226: PUSH
9227: LD_INT 19
9229: PUSH
9230: LD_INT 21
9232: PUSH
9233: LD_INT 24
9235: PUSH
9236: LD_INT 22
9238: PUSH
9239: LD_INT 25
9241: PUSH
9242: LD_INT 28
9244: PUSH
9245: LD_INT 29
9247: PUSH
9248: LD_INT 30
9250: PUSH
9251: LD_INT 31
9253: PUSH
9254: LD_INT 37
9256: PUSH
9257: LD_INT 38
9259: PUSH
9260: LD_INT 32
9262: PUSH
9263: LD_INT 27
9265: PUSH
9266: LD_INT 33
9268: PUSH
9269: LD_INT 69
9271: PUSH
9272: LD_INT 39
9274: PUSH
9275: LD_INT 34
9277: PUSH
9278: LD_INT 40
9280: PUSH
9281: LD_INT 71
9283: PUSH
9284: LD_INT 23
9286: PUSH
9287: LD_INT 44
9289: PUSH
9290: LD_INT 48
9292: PUSH
9293: LD_INT 49
9295: PUSH
9296: LD_INT 50
9298: PUSH
9299: LD_INT 51
9301: PUSH
9302: LD_INT 52
9304: PUSH
9305: LD_INT 53
9307: PUSH
9308: LD_INT 54
9310: PUSH
9311: LD_INT 55
9313: PUSH
9314: LD_INT 56
9316: PUSH
9317: LD_INT 57
9319: PUSH
9320: LD_INT 58
9322: PUSH
9323: LD_INT 59
9325: PUSH
9326: LD_INT 63
9328: PUSH
9329: LD_INT 64
9331: PUSH
9332: LD_INT 65
9334: PUSH
9335: LD_INT 82
9337: PUSH
9338: LD_INT 83
9340: PUSH
9341: LD_INT 84
9343: PUSH
9344: LD_INT 85
9346: PUSH
9347: LD_INT 86
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: LIST
9354: LIST
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: LIST
9360: LIST
9361: LIST
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: LIST
9367: LIST
9368: LIST
9369: LIST
9370: LIST
9371: LIST
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: LIST
9382: LIST
9383: LIST
9384: LIST
9385: LIST
9386: LIST
9387: LIST
9388: LIST
9389: LIST
9390: LIST
9391: LIST
9392: LIST
9393: LIST
9394: LIST
9395: LIST
9396: LIST
9397: LIST
9398: LIST
9399: LIST
9400: LIST
9401: LIST
9402: LIST
9403: LIST
9404: ST_TO_ADDR
9405: GO 9408
9407: POP
// if state > - 1 and state < 3 then
9408: LD_VAR 0 3
9412: PUSH
9413: LD_INT 1
9415: NEG
9416: GREATER
9417: PUSH
9418: LD_VAR 0 3
9422: PUSH
9423: LD_INT 3
9425: LESS
9426: AND
9427: IFFALSE 9484
// for i in result do
9429: LD_ADDR_VAR 0 5
9433: PUSH
9434: LD_VAR 0 4
9438: PUSH
9439: FOR_IN
9440: IFFALSE 9482
// if GetTech ( i , side ) <> state then
9442: LD_VAR 0 5
9446: PPUSH
9447: LD_VAR 0 1
9451: PPUSH
9452: CALL_OW 321
9456: PUSH
9457: LD_VAR 0 3
9461: NONEQUAL
9462: IFFALSE 9480
// result := result diff i ;
9464: LD_ADDR_VAR 0 4
9468: PUSH
9469: LD_VAR 0 4
9473: PUSH
9474: LD_VAR 0 5
9478: DIFF
9479: ST_TO_ADDR
9480: GO 9439
9482: POP
9483: POP
// end ;
9484: LD_VAR 0 4
9488: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
9489: LD_INT 0
9491: PPUSH
9492: PPUSH
9493: PPUSH
// result := true ;
9494: LD_ADDR_VAR 0 3
9498: PUSH
9499: LD_INT 1
9501: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
9502: LD_ADDR_VAR 0 5
9506: PUSH
9507: LD_VAR 0 2
9511: PPUSH
9512: CALL_OW 480
9516: ST_TO_ADDR
// if not tmp then
9517: LD_VAR 0 5
9521: NOT
9522: IFFALSE 9526
// exit ;
9524: GO 9575
// for i in tmp do
9526: LD_ADDR_VAR 0 4
9530: PUSH
9531: LD_VAR 0 5
9535: PUSH
9536: FOR_IN
9537: IFFALSE 9573
// if GetTech ( i , side ) <> state_researched then
9539: LD_VAR 0 4
9543: PPUSH
9544: LD_VAR 0 1
9548: PPUSH
9549: CALL_OW 321
9553: PUSH
9554: LD_INT 2
9556: NONEQUAL
9557: IFFALSE 9571
// begin result := false ;
9559: LD_ADDR_VAR 0 3
9563: PUSH
9564: LD_INT 0
9566: ST_TO_ADDR
// exit ;
9567: POP
9568: POP
9569: GO 9575
// end ;
9571: GO 9536
9573: POP
9574: POP
// end ;
9575: LD_VAR 0 3
9579: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
9580: LD_INT 0
9582: PPUSH
9583: PPUSH
9584: PPUSH
9585: PPUSH
9586: PPUSH
9587: PPUSH
9588: PPUSH
9589: PPUSH
9590: PPUSH
9591: PPUSH
9592: PPUSH
9593: PPUSH
9594: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
9595: LD_VAR 0 1
9599: NOT
9600: PUSH
9601: LD_VAR 0 1
9605: PPUSH
9606: CALL_OW 257
9610: PUSH
9611: LD_INT 9
9613: NONEQUAL
9614: OR
9615: IFFALSE 9619
// exit ;
9617: GO 10192
// side := GetSide ( unit ) ;
9619: LD_ADDR_VAR 0 9
9623: PUSH
9624: LD_VAR 0 1
9628: PPUSH
9629: CALL_OW 255
9633: ST_TO_ADDR
// tech_space := tech_spacanom ;
9634: LD_ADDR_VAR 0 12
9638: PUSH
9639: LD_INT 29
9641: ST_TO_ADDR
// tech_time := tech_taurad ;
9642: LD_ADDR_VAR 0 13
9646: PUSH
9647: LD_INT 28
9649: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
9650: LD_ADDR_VAR 0 11
9654: PUSH
9655: LD_VAR 0 1
9659: PPUSH
9660: CALL_OW 310
9664: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
9665: LD_VAR 0 11
9669: PPUSH
9670: CALL_OW 247
9674: PUSH
9675: LD_INT 2
9677: EQUAL
9678: IFFALSE 9682
// exit ;
9680: GO 10192
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
9682: LD_ADDR_VAR 0 8
9686: PUSH
9687: LD_INT 81
9689: PUSH
9690: LD_VAR 0 9
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PUSH
9699: LD_INT 3
9701: PUSH
9702: LD_INT 21
9704: PUSH
9705: LD_INT 3
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: PUSH
9712: EMPTY
9713: LIST
9714: LIST
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PPUSH
9720: CALL_OW 69
9724: ST_TO_ADDR
// if not tmp then
9725: LD_VAR 0 8
9729: NOT
9730: IFFALSE 9734
// exit ;
9732: GO 10192
// if in_unit then
9734: LD_VAR 0 11
9738: IFFALSE 9762
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
9740: LD_ADDR_VAR 0 10
9744: PUSH
9745: LD_VAR 0 8
9749: PPUSH
9750: LD_VAR 0 11
9754: PPUSH
9755: CALL_OW 74
9759: ST_TO_ADDR
9760: GO 9782
// enemy := NearestUnitToUnit ( tmp , unit ) ;
9762: LD_ADDR_VAR 0 10
9766: PUSH
9767: LD_VAR 0 8
9771: PPUSH
9772: LD_VAR 0 1
9776: PPUSH
9777: CALL_OW 74
9781: ST_TO_ADDR
// if not enemy then
9782: LD_VAR 0 10
9786: NOT
9787: IFFALSE 9791
// exit ;
9789: GO 10192
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
9791: LD_VAR 0 11
9795: PUSH
9796: LD_VAR 0 11
9800: PPUSH
9801: LD_VAR 0 10
9805: PPUSH
9806: CALL_OW 296
9810: PUSH
9811: LD_INT 13
9813: GREATER
9814: AND
9815: PUSH
9816: LD_VAR 0 1
9820: PPUSH
9821: LD_VAR 0 10
9825: PPUSH
9826: CALL_OW 296
9830: PUSH
9831: LD_INT 12
9833: GREATER
9834: OR
9835: IFFALSE 9839
// exit ;
9837: GO 10192
// missile := [ 1 ] ;
9839: LD_ADDR_VAR 0 14
9843: PUSH
9844: LD_INT 1
9846: PUSH
9847: EMPTY
9848: LIST
9849: ST_TO_ADDR
// if Researched ( side , tech_space ) then
9850: LD_VAR 0 9
9854: PPUSH
9855: LD_VAR 0 12
9859: PPUSH
9860: CALL_OW 325
9864: IFFALSE 9893
// missile := Insert ( missile , missile + 1 , 2 ) ;
9866: LD_ADDR_VAR 0 14
9870: PUSH
9871: LD_VAR 0 14
9875: PPUSH
9876: LD_VAR 0 14
9880: PUSH
9881: LD_INT 1
9883: PLUS
9884: PPUSH
9885: LD_INT 2
9887: PPUSH
9888: CALL_OW 2
9892: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
9893: LD_VAR 0 9
9897: PPUSH
9898: LD_VAR 0 13
9902: PPUSH
9903: CALL_OW 325
9907: PUSH
9908: LD_VAR 0 10
9912: PPUSH
9913: CALL_OW 255
9917: PPUSH
9918: LD_VAR 0 13
9922: PPUSH
9923: CALL_OW 325
9927: NOT
9928: AND
9929: IFFALSE 9958
// missile := Insert ( missile , missile + 1 , 3 ) ;
9931: LD_ADDR_VAR 0 14
9935: PUSH
9936: LD_VAR 0 14
9940: PPUSH
9941: LD_VAR 0 14
9945: PUSH
9946: LD_INT 1
9948: PLUS
9949: PPUSH
9950: LD_INT 3
9952: PPUSH
9953: CALL_OW 2
9957: ST_TO_ADDR
// if missile < 2 then
9958: LD_VAR 0 14
9962: PUSH
9963: LD_INT 2
9965: LESS
9966: IFFALSE 9970
// exit ;
9968: GO 10192
// x := GetX ( enemy ) ;
9970: LD_ADDR_VAR 0 4
9974: PUSH
9975: LD_VAR 0 10
9979: PPUSH
9980: CALL_OW 250
9984: ST_TO_ADDR
// y := GetY ( enemy ) ;
9985: LD_ADDR_VAR 0 5
9989: PUSH
9990: LD_VAR 0 10
9994: PPUSH
9995: CALL_OW 251
9999: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
10000: LD_ADDR_VAR 0 6
10004: PUSH
10005: LD_VAR 0 4
10009: PUSH
10010: LD_INT 1
10012: NEG
10013: PPUSH
10014: LD_INT 1
10016: PPUSH
10017: CALL_OW 12
10021: PLUS
10022: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
10023: LD_ADDR_VAR 0 7
10027: PUSH
10028: LD_VAR 0 5
10032: PUSH
10033: LD_INT 1
10035: NEG
10036: PPUSH
10037: LD_INT 1
10039: PPUSH
10040: CALL_OW 12
10044: PLUS
10045: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10046: LD_VAR 0 6
10050: PPUSH
10051: LD_VAR 0 7
10055: PPUSH
10056: CALL_OW 488
10060: NOT
10061: IFFALSE 10083
// begin _x := x ;
10063: LD_ADDR_VAR 0 6
10067: PUSH
10068: LD_VAR 0 4
10072: ST_TO_ADDR
// _y := y ;
10073: LD_ADDR_VAR 0 7
10077: PUSH
10078: LD_VAR 0 5
10082: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
10083: LD_ADDR_VAR 0 3
10087: PUSH
10088: LD_INT 1
10090: PPUSH
10091: LD_VAR 0 14
10095: PPUSH
10096: CALL_OW 12
10100: ST_TO_ADDR
// case i of 1 :
10101: LD_VAR 0 3
10105: PUSH
10106: LD_INT 1
10108: DOUBLE
10109: EQUAL
10110: IFTRUE 10114
10112: GO 10131
10114: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
10115: LD_VAR 0 1
10119: PPUSH
10120: LD_VAR 0 10
10124: PPUSH
10125: CALL_OW 115
10129: GO 10192
10131: LD_INT 2
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10161
10139: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
10140: LD_VAR 0 1
10144: PPUSH
10145: LD_VAR 0 6
10149: PPUSH
10150: LD_VAR 0 7
10154: PPUSH
10155: CALL_OW 153
10159: GO 10192
10161: LD_INT 3
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10191
10169: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
10170: LD_VAR 0 1
10174: PPUSH
10175: LD_VAR 0 6
10179: PPUSH
10180: LD_VAR 0 7
10184: PPUSH
10185: CALL_OW 154
10189: GO 10192
10191: POP
// end ;
10192: LD_VAR 0 2
10196: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
10197: LD_INT 0
10199: PPUSH
10200: PPUSH
10201: PPUSH
10202: PPUSH
10203: PPUSH
10204: PPUSH
// if not unit or not building then
10205: LD_VAR 0 1
10209: NOT
10210: PUSH
10211: LD_VAR 0 2
10215: NOT
10216: OR
10217: IFFALSE 10221
// exit ;
10219: GO 10379
// x := GetX ( building ) ;
10221: LD_ADDR_VAR 0 5
10225: PUSH
10226: LD_VAR 0 2
10230: PPUSH
10231: CALL_OW 250
10235: ST_TO_ADDR
// y := GetY ( building ) ;
10236: LD_ADDR_VAR 0 6
10240: PUSH
10241: LD_VAR 0 2
10245: PPUSH
10246: CALL_OW 251
10250: ST_TO_ADDR
// for i = 0 to 5 do
10251: LD_ADDR_VAR 0 4
10255: PUSH
10256: DOUBLE
10257: LD_INT 0
10259: DEC
10260: ST_TO_ADDR
10261: LD_INT 5
10263: PUSH
10264: FOR_TO
10265: IFFALSE 10377
// begin _x := ShiftX ( x , i , 3 ) ;
10267: LD_ADDR_VAR 0 7
10271: PUSH
10272: LD_VAR 0 5
10276: PPUSH
10277: LD_VAR 0 4
10281: PPUSH
10282: LD_INT 3
10284: PPUSH
10285: CALL_OW 272
10289: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
10290: LD_ADDR_VAR 0 8
10294: PUSH
10295: LD_VAR 0 6
10299: PPUSH
10300: LD_VAR 0 4
10304: PPUSH
10305: LD_INT 3
10307: PPUSH
10308: CALL_OW 273
10312: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10313: LD_VAR 0 7
10317: PPUSH
10318: LD_VAR 0 8
10322: PPUSH
10323: CALL_OW 488
10327: NOT
10328: IFFALSE 10332
// continue ;
10330: GO 10264
// if HexInfo ( _x , _y ) = 0 then
10332: LD_VAR 0 7
10336: PPUSH
10337: LD_VAR 0 8
10341: PPUSH
10342: CALL_OW 428
10346: PUSH
10347: LD_INT 0
10349: EQUAL
10350: IFFALSE 10375
// begin ComMoveXY ( unit , _x , _y ) ;
10352: LD_VAR 0 1
10356: PPUSH
10357: LD_VAR 0 7
10361: PPUSH
10362: LD_VAR 0 8
10366: PPUSH
10367: CALL_OW 111
// exit ;
10371: POP
10372: POP
10373: GO 10379
// end ; end ;
10375: GO 10264
10377: POP
10378: POP
// end ;
10379: LD_VAR 0 3
10383: RET
// export function ScanBase ( side , base_area ) ; begin
10384: LD_INT 0
10386: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
10387: LD_ADDR_VAR 0 3
10391: PUSH
10392: LD_VAR 0 2
10396: PPUSH
10397: LD_INT 81
10399: PUSH
10400: LD_VAR 0 1
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PPUSH
10409: CALL_OW 70
10413: ST_TO_ADDR
// end ;
10414: LD_VAR 0 3
10418: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
10419: LD_INT 0
10421: PPUSH
10422: PPUSH
10423: PPUSH
10424: PPUSH
// result := false ;
10425: LD_ADDR_VAR 0 2
10429: PUSH
10430: LD_INT 0
10432: ST_TO_ADDR
// side := GetSide ( unit ) ;
10433: LD_ADDR_VAR 0 3
10437: PUSH
10438: LD_VAR 0 1
10442: PPUSH
10443: CALL_OW 255
10447: ST_TO_ADDR
// nat := GetNation ( unit ) ;
10448: LD_ADDR_VAR 0 4
10452: PUSH
10453: LD_VAR 0 1
10457: PPUSH
10458: CALL_OW 248
10462: ST_TO_ADDR
// case nat of 1 :
10463: LD_VAR 0 4
10467: PUSH
10468: LD_INT 1
10470: DOUBLE
10471: EQUAL
10472: IFTRUE 10476
10474: GO 10487
10476: POP
// tech := tech_lassight ; 2 :
10477: LD_ADDR_VAR 0 5
10481: PUSH
10482: LD_INT 12
10484: ST_TO_ADDR
10485: GO 10526
10487: LD_INT 2
10489: DOUBLE
10490: EQUAL
10491: IFTRUE 10495
10493: GO 10506
10495: POP
// tech := tech_mortar ; 3 :
10496: LD_ADDR_VAR 0 5
10500: PUSH
10501: LD_INT 41
10503: ST_TO_ADDR
10504: GO 10526
10506: LD_INT 3
10508: DOUBLE
10509: EQUAL
10510: IFTRUE 10514
10512: GO 10525
10514: POP
// tech := tech_bazooka ; end ;
10515: LD_ADDR_VAR 0 5
10519: PUSH
10520: LD_INT 44
10522: ST_TO_ADDR
10523: GO 10526
10525: POP
// if Researched ( side , tech ) then
10526: LD_VAR 0 3
10530: PPUSH
10531: LD_VAR 0 5
10535: PPUSH
10536: CALL_OW 325
10540: IFFALSE 10567
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
10542: LD_ADDR_VAR 0 2
10546: PUSH
10547: LD_INT 5
10549: PUSH
10550: LD_INT 8
10552: PUSH
10553: LD_INT 9
10555: PUSH
10556: EMPTY
10557: LIST
10558: LIST
10559: LIST
10560: PUSH
10561: LD_VAR 0 4
10565: ARRAY
10566: ST_TO_ADDR
// end ;
10567: LD_VAR 0 2
10571: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
10572: LD_INT 0
10574: PPUSH
10575: PPUSH
10576: PPUSH
// if not mines then
10577: LD_VAR 0 2
10581: NOT
10582: IFFALSE 10586
// exit ;
10584: GO 10730
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10586: LD_ADDR_VAR 0 5
10590: PUSH
10591: LD_INT 81
10593: PUSH
10594: LD_VAR 0 1
10598: PUSH
10599: EMPTY
10600: LIST
10601: LIST
10602: PUSH
10603: LD_INT 3
10605: PUSH
10606: LD_INT 21
10608: PUSH
10609: LD_INT 3
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PUSH
10616: EMPTY
10617: LIST
10618: LIST
10619: PUSH
10620: EMPTY
10621: LIST
10622: LIST
10623: PPUSH
10624: CALL_OW 69
10628: ST_TO_ADDR
// for i in mines do
10629: LD_ADDR_VAR 0 4
10633: PUSH
10634: LD_VAR 0 2
10638: PUSH
10639: FOR_IN
10640: IFFALSE 10728
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
10642: LD_VAR 0 4
10646: PUSH
10647: LD_INT 1
10649: ARRAY
10650: PPUSH
10651: LD_VAR 0 4
10655: PUSH
10656: LD_INT 2
10658: ARRAY
10659: PPUSH
10660: CALL_OW 458
10664: NOT
10665: IFFALSE 10669
// continue ;
10667: GO 10639
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
10669: LD_VAR 0 4
10673: PUSH
10674: LD_INT 1
10676: ARRAY
10677: PPUSH
10678: LD_VAR 0 4
10682: PUSH
10683: LD_INT 2
10685: ARRAY
10686: PPUSH
10687: CALL_OW 428
10691: PUSH
10692: LD_VAR 0 5
10696: IN
10697: IFFALSE 10726
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
10699: LD_VAR 0 4
10703: PUSH
10704: LD_INT 1
10706: ARRAY
10707: PPUSH
10708: LD_VAR 0 4
10712: PUSH
10713: LD_INT 2
10715: ARRAY
10716: PPUSH
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 456
// end ;
10726: GO 10639
10728: POP
10729: POP
// end ;
10730: LD_VAR 0 3
10734: RET
// export function Count ( array ) ; var i ; begin
10735: LD_INT 0
10737: PPUSH
10738: PPUSH
// result := 0 ;
10739: LD_ADDR_VAR 0 2
10743: PUSH
10744: LD_INT 0
10746: ST_TO_ADDR
// for i in array do
10747: LD_ADDR_VAR 0 3
10751: PUSH
10752: LD_VAR 0 1
10756: PUSH
10757: FOR_IN
10758: IFFALSE 10782
// if i then
10760: LD_VAR 0 3
10764: IFFALSE 10780
// result := result + 1 ;
10766: LD_ADDR_VAR 0 2
10770: PUSH
10771: LD_VAR 0 2
10775: PUSH
10776: LD_INT 1
10778: PLUS
10779: ST_TO_ADDR
10780: GO 10757
10782: POP
10783: POP
// end ;
10784: LD_VAR 0 2
10788: RET
// export function IsEmpty ( building ) ; begin
10789: LD_INT 0
10791: PPUSH
// if not building then
10792: LD_VAR 0 1
10796: NOT
10797: IFFALSE 10801
// exit ;
10799: GO 10844
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
10801: LD_ADDR_VAR 0 2
10805: PUSH
10806: LD_VAR 0 1
10810: PUSH
10811: LD_INT 22
10813: PUSH
10814: LD_VAR 0 1
10818: PPUSH
10819: CALL_OW 255
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: PUSH
10828: LD_INT 58
10830: PUSH
10831: EMPTY
10832: LIST
10833: PUSH
10834: EMPTY
10835: LIST
10836: LIST
10837: PPUSH
10838: CALL_OW 69
10842: IN
10843: ST_TO_ADDR
// end ;
10844: LD_VAR 0 2
10848: RET
// export function IsNotFull ( building ) ; begin
10849: LD_INT 0
10851: PPUSH
// if not building then
10852: LD_VAR 0 1
10856: NOT
10857: IFFALSE 10861
// exit ;
10859: GO 10880
// result := UnitsInside ( building ) < 6 ;
10861: LD_ADDR_VAR 0 2
10865: PUSH
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL_OW 313
10875: PUSH
10876: LD_INT 6
10878: LESS
10879: ST_TO_ADDR
// end ;
10880: LD_VAR 0 2
10884: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
10885: LD_INT 0
10887: PPUSH
10888: PPUSH
10889: PPUSH
10890: PPUSH
// tmp := [ ] ;
10891: LD_ADDR_VAR 0 3
10895: PUSH
10896: EMPTY
10897: ST_TO_ADDR
// list := [ ] ;
10898: LD_ADDR_VAR 0 5
10902: PUSH
10903: EMPTY
10904: ST_TO_ADDR
// for i = 16 to 25 do
10905: LD_ADDR_VAR 0 4
10909: PUSH
10910: DOUBLE
10911: LD_INT 16
10913: DEC
10914: ST_TO_ADDR
10915: LD_INT 25
10917: PUSH
10918: FOR_TO
10919: IFFALSE 10992
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
10921: LD_ADDR_VAR 0 3
10925: PUSH
10926: LD_VAR 0 3
10930: PUSH
10931: LD_INT 22
10933: PUSH
10934: LD_VAR 0 1
10938: PPUSH
10939: CALL_OW 255
10943: PUSH
10944: EMPTY
10945: LIST
10946: LIST
10947: PUSH
10948: LD_INT 91
10950: PUSH
10951: LD_VAR 0 1
10955: PUSH
10956: LD_INT 6
10958: PUSH
10959: EMPTY
10960: LIST
10961: LIST
10962: LIST
10963: PUSH
10964: LD_INT 30
10966: PUSH
10967: LD_VAR 0 4
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: LIST
10980: PUSH
10981: EMPTY
10982: LIST
10983: PPUSH
10984: CALL_OW 69
10988: ADD
10989: ST_TO_ADDR
10990: GO 10918
10992: POP
10993: POP
// for i = 1 to tmp do
10994: LD_ADDR_VAR 0 4
10998: PUSH
10999: DOUBLE
11000: LD_INT 1
11002: DEC
11003: ST_TO_ADDR
11004: LD_VAR 0 3
11008: PUSH
11009: FOR_TO
11010: IFFALSE 11098
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11012: LD_ADDR_VAR 0 5
11016: PUSH
11017: LD_VAR 0 5
11021: PUSH
11022: LD_VAR 0 3
11026: PUSH
11027: LD_VAR 0 4
11031: ARRAY
11032: PPUSH
11033: CALL_OW 266
11037: PUSH
11038: LD_VAR 0 3
11042: PUSH
11043: LD_VAR 0 4
11047: ARRAY
11048: PPUSH
11049: CALL_OW 250
11053: PUSH
11054: LD_VAR 0 3
11058: PUSH
11059: LD_VAR 0 4
11063: ARRAY
11064: PPUSH
11065: CALL_OW 251
11069: PUSH
11070: LD_VAR 0 3
11074: PUSH
11075: LD_VAR 0 4
11079: ARRAY
11080: PPUSH
11081: CALL_OW 254
11085: PUSH
11086: EMPTY
11087: LIST
11088: LIST
11089: LIST
11090: LIST
11091: PUSH
11092: EMPTY
11093: LIST
11094: ADD
11095: ST_TO_ADDR
11096: GO 11009
11098: POP
11099: POP
// result := list ;
11100: LD_ADDR_VAR 0 2
11104: PUSH
11105: LD_VAR 0 5
11109: ST_TO_ADDR
// end ;
11110: LD_VAR 0 2
11114: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
11115: LD_INT 0
11117: PPUSH
11118: PPUSH
11119: PPUSH
11120: PPUSH
11121: PPUSH
11122: PPUSH
11123: PPUSH
// if not factory then
11124: LD_VAR 0 1
11128: NOT
11129: IFFALSE 11133
// exit ;
11131: GO 11726
// if control = control_apeman then
11133: LD_VAR 0 4
11137: PUSH
11138: LD_INT 5
11140: EQUAL
11141: IFFALSE 11250
// begin tmp := UnitsInside ( factory ) ;
11143: LD_ADDR_VAR 0 8
11147: PUSH
11148: LD_VAR 0 1
11152: PPUSH
11153: CALL_OW 313
11157: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
11158: LD_VAR 0 8
11162: PPUSH
11163: LD_INT 25
11165: PUSH
11166: LD_INT 12
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 72
11177: NOT
11178: IFFALSE 11188
// control := control_manual ;
11180: LD_ADDR_VAR 0 4
11184: PUSH
11185: LD_INT 1
11187: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
11188: LD_ADDR_VAR 0 8
11192: PUSH
11193: LD_VAR 0 1
11197: PPUSH
11198: CALL 10885 0 1
11202: ST_TO_ADDR
// if tmp then
11203: LD_VAR 0 8
11207: IFFALSE 11250
// begin for i in tmp do
11209: LD_ADDR_VAR 0 7
11213: PUSH
11214: LD_VAR 0 8
11218: PUSH
11219: FOR_IN
11220: IFFALSE 11248
// if i [ 1 ] = b_ext_radio then
11222: LD_VAR 0 7
11226: PUSH
11227: LD_INT 1
11229: ARRAY
11230: PUSH
11231: LD_INT 22
11233: EQUAL
11234: IFFALSE 11246
// begin control := control_remote ;
11236: LD_ADDR_VAR 0 4
11240: PUSH
11241: LD_INT 2
11243: ST_TO_ADDR
// break ;
11244: GO 11248
// end ;
11246: GO 11219
11248: POP
11249: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11250: LD_VAR 0 1
11254: PPUSH
11255: LD_VAR 0 2
11259: PPUSH
11260: LD_VAR 0 3
11264: PPUSH
11265: LD_VAR 0 4
11269: PPUSH
11270: LD_VAR 0 5
11274: PPUSH
11275: CALL_OW 448
11279: IFFALSE 11314
// begin result := [ chassis , engine , control , weapon ] ;
11281: LD_ADDR_VAR 0 6
11285: PUSH
11286: LD_VAR 0 2
11290: PUSH
11291: LD_VAR 0 3
11295: PUSH
11296: LD_VAR 0 4
11300: PUSH
11301: LD_VAR 0 5
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: ST_TO_ADDR
// exit ;
11312: GO 11726
// end ; _chassis := AvailableChassisList ( factory ) ;
11314: LD_ADDR_VAR 0 9
11318: PUSH
11319: LD_VAR 0 1
11323: PPUSH
11324: CALL_OW 475
11328: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
11329: LD_ADDR_VAR 0 11
11333: PUSH
11334: LD_VAR 0 1
11338: PPUSH
11339: CALL_OW 476
11343: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
11344: LD_ADDR_VAR 0 12
11348: PUSH
11349: LD_VAR 0 1
11353: PPUSH
11354: CALL_OW 477
11358: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
11359: LD_ADDR_VAR 0 10
11363: PUSH
11364: LD_VAR 0 1
11368: PPUSH
11369: CALL_OW 478
11373: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
11374: LD_VAR 0 9
11378: NOT
11379: PUSH
11380: LD_VAR 0 11
11384: NOT
11385: OR
11386: PUSH
11387: LD_VAR 0 12
11391: NOT
11392: OR
11393: PUSH
11394: LD_VAR 0 10
11398: NOT
11399: OR
11400: IFFALSE 11435
// begin result := [ chassis , engine , control , weapon ] ;
11402: LD_ADDR_VAR 0 6
11406: PUSH
11407: LD_VAR 0 2
11411: PUSH
11412: LD_VAR 0 3
11416: PUSH
11417: LD_VAR 0 4
11421: PUSH
11422: LD_VAR 0 5
11426: PUSH
11427: EMPTY
11428: LIST
11429: LIST
11430: LIST
11431: LIST
11432: ST_TO_ADDR
// exit ;
11433: GO 11726
// end ; if not chassis in _chassis then
11435: LD_VAR 0 2
11439: PUSH
11440: LD_VAR 0 9
11444: IN
11445: NOT
11446: IFFALSE 11472
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
11448: LD_ADDR_VAR 0 2
11452: PUSH
11453: LD_VAR 0 9
11457: PUSH
11458: LD_INT 1
11460: PPUSH
11461: LD_VAR 0 9
11465: PPUSH
11466: CALL_OW 12
11470: ARRAY
11471: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
11472: LD_VAR 0 2
11476: PPUSH
11477: LD_VAR 0 3
11481: PPUSH
11482: CALL 11731 0 2
11486: NOT
11487: IFFALSE 11546
// repeat engine := _engine [ 1 ] ;
11489: LD_ADDR_VAR 0 3
11493: PUSH
11494: LD_VAR 0 11
11498: PUSH
11499: LD_INT 1
11501: ARRAY
11502: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
11503: LD_ADDR_VAR 0 11
11507: PUSH
11508: LD_VAR 0 11
11512: PPUSH
11513: LD_INT 1
11515: PPUSH
11516: CALL_OW 3
11520: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
11521: LD_VAR 0 2
11525: PPUSH
11526: LD_VAR 0 3
11530: PPUSH
11531: CALL 11731 0 2
11535: PUSH
11536: LD_VAR 0 11
11540: PUSH
11541: EMPTY
11542: EQUAL
11543: OR
11544: IFFALSE 11489
// if not control in _control then
11546: LD_VAR 0 4
11550: PUSH
11551: LD_VAR 0 12
11555: IN
11556: NOT
11557: IFFALSE 11583
// control := _control [ rand ( 1 , _control ) ] ;
11559: LD_ADDR_VAR 0 4
11563: PUSH
11564: LD_VAR 0 12
11568: PUSH
11569: LD_INT 1
11571: PPUSH
11572: LD_VAR 0 12
11576: PPUSH
11577: CALL_OW 12
11581: ARRAY
11582: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
11583: LD_VAR 0 2
11587: PPUSH
11588: LD_VAR 0 5
11592: PPUSH
11593: CALL 11951 0 2
11597: NOT
11598: IFFALSE 11657
// repeat weapon := _weapon [ 1 ] ;
11600: LD_ADDR_VAR 0 5
11604: PUSH
11605: LD_VAR 0 10
11609: PUSH
11610: LD_INT 1
11612: ARRAY
11613: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
11614: LD_ADDR_VAR 0 10
11618: PUSH
11619: LD_VAR 0 10
11623: PPUSH
11624: LD_INT 1
11626: PPUSH
11627: CALL_OW 3
11631: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
11632: LD_VAR 0 2
11636: PPUSH
11637: LD_VAR 0 5
11641: PPUSH
11642: CALL 11951 0 2
11646: PUSH
11647: LD_VAR 0 10
11651: PUSH
11652: EMPTY
11653: EQUAL
11654: OR
11655: IFFALSE 11600
// result := [ ] ;
11657: LD_ADDR_VAR 0 6
11661: PUSH
11662: EMPTY
11663: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11664: LD_VAR 0 1
11668: PPUSH
11669: LD_VAR 0 2
11673: PPUSH
11674: LD_VAR 0 3
11678: PPUSH
11679: LD_VAR 0 4
11683: PPUSH
11684: LD_VAR 0 5
11688: PPUSH
11689: CALL_OW 448
11693: IFFALSE 11726
// result := [ chassis , engine , control , weapon ] ;
11695: LD_ADDR_VAR 0 6
11699: PUSH
11700: LD_VAR 0 2
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_VAR 0 4
11714: PUSH
11715: LD_VAR 0 5
11719: PUSH
11720: EMPTY
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: ST_TO_ADDR
// end ;
11726: LD_VAR 0 6
11730: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
11731: LD_INT 0
11733: PPUSH
// if not chassis or not engine then
11734: LD_VAR 0 1
11738: NOT
11739: PUSH
11740: LD_VAR 0 2
11744: NOT
11745: OR
11746: IFFALSE 11750
// exit ;
11748: GO 11946
// case engine of engine_solar :
11750: LD_VAR 0 2
11754: PUSH
11755: LD_INT 2
11757: DOUBLE
11758: EQUAL
11759: IFTRUE 11763
11761: GO 11801
11763: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
11764: LD_ADDR_VAR 0 3
11768: PUSH
11769: LD_INT 11
11771: PUSH
11772: LD_INT 12
11774: PUSH
11775: LD_INT 13
11777: PUSH
11778: LD_INT 14
11780: PUSH
11781: LD_INT 1
11783: PUSH
11784: LD_INT 2
11786: PUSH
11787: LD_INT 3
11789: PUSH
11790: EMPTY
11791: LIST
11792: LIST
11793: LIST
11794: LIST
11795: LIST
11796: LIST
11797: LIST
11798: ST_TO_ADDR
11799: GO 11930
11801: LD_INT 1
11803: DOUBLE
11804: EQUAL
11805: IFTRUE 11809
11807: GO 11871
11809: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_INT 11
11817: PUSH
11818: LD_INT 12
11820: PUSH
11821: LD_INT 13
11823: PUSH
11824: LD_INT 14
11826: PUSH
11827: LD_INT 1
11829: PUSH
11830: LD_INT 2
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: LD_INT 4
11838: PUSH
11839: LD_INT 5
11841: PUSH
11842: LD_INT 21
11844: PUSH
11845: LD_INT 23
11847: PUSH
11848: LD_INT 22
11850: PUSH
11851: LD_INT 24
11853: PUSH
11854: EMPTY
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: ST_TO_ADDR
11869: GO 11930
11871: LD_INT 3
11873: DOUBLE
11874: EQUAL
11875: IFTRUE 11879
11877: GO 11929
11879: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
11880: LD_ADDR_VAR 0 3
11884: PUSH
11885: LD_INT 13
11887: PUSH
11888: LD_INT 14
11890: PUSH
11891: LD_INT 2
11893: PUSH
11894: LD_INT 3
11896: PUSH
11897: LD_INT 4
11899: PUSH
11900: LD_INT 5
11902: PUSH
11903: LD_INT 21
11905: PUSH
11906: LD_INT 22
11908: PUSH
11909: LD_INT 23
11911: PUSH
11912: LD_INT 24
11914: PUSH
11915: EMPTY
11916: LIST
11917: LIST
11918: LIST
11919: LIST
11920: LIST
11921: LIST
11922: LIST
11923: LIST
11924: LIST
11925: LIST
11926: ST_TO_ADDR
11927: GO 11930
11929: POP
// result := ( chassis in result ) ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_VAR 0 1
11939: PUSH
11940: LD_VAR 0 3
11944: IN
11945: ST_TO_ADDR
// end ;
11946: LD_VAR 0 3
11950: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
11951: LD_INT 0
11953: PPUSH
// if not chassis or not weapon then
11954: LD_VAR 0 1
11958: NOT
11959: PUSH
11960: LD_VAR 0 2
11964: NOT
11965: OR
11966: IFFALSE 11970
// exit ;
11968: GO 13032
// case weapon of us_machine_gun :
11970: LD_VAR 0 2
11974: PUSH
11975: LD_INT 2
11977: DOUBLE
11978: EQUAL
11979: IFTRUE 11983
11981: GO 12013
11983: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
11984: LD_ADDR_VAR 0 3
11988: PUSH
11989: LD_INT 1
11991: PUSH
11992: LD_INT 2
11994: PUSH
11995: LD_INT 3
11997: PUSH
11998: LD_INT 4
12000: PUSH
12001: LD_INT 5
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: ST_TO_ADDR
12011: GO 13016
12013: LD_INT 3
12015: DOUBLE
12016: EQUAL
12017: IFTRUE 12021
12019: GO 12051
12021: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
12022: LD_ADDR_VAR 0 3
12026: PUSH
12027: LD_INT 1
12029: PUSH
12030: LD_INT 2
12032: PUSH
12033: LD_INT 3
12035: PUSH
12036: LD_INT 4
12038: PUSH
12039: LD_INT 5
12041: PUSH
12042: EMPTY
12043: LIST
12044: LIST
12045: LIST
12046: LIST
12047: LIST
12048: ST_TO_ADDR
12049: GO 13016
12051: LD_INT 11
12053: DOUBLE
12054: EQUAL
12055: IFTRUE 12059
12057: GO 12089
12059: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
12060: LD_ADDR_VAR 0 3
12064: PUSH
12065: LD_INT 1
12067: PUSH
12068: LD_INT 2
12070: PUSH
12071: LD_INT 3
12073: PUSH
12074: LD_INT 4
12076: PUSH
12077: LD_INT 5
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: ST_TO_ADDR
12087: GO 13016
12089: LD_INT 4
12091: DOUBLE
12092: EQUAL
12093: IFTRUE 12097
12095: GO 12123
12097: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
12098: LD_ADDR_VAR 0 3
12102: PUSH
12103: LD_INT 2
12105: PUSH
12106: LD_INT 3
12108: PUSH
12109: LD_INT 4
12111: PUSH
12112: LD_INT 5
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: LIST
12119: LIST
12120: ST_TO_ADDR
12121: GO 13016
12123: LD_INT 5
12125: DOUBLE
12126: EQUAL
12127: IFTRUE 12131
12129: GO 12157
12131: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
12132: LD_ADDR_VAR 0 3
12136: PUSH
12137: LD_INT 2
12139: PUSH
12140: LD_INT 3
12142: PUSH
12143: LD_INT 4
12145: PUSH
12146: LD_INT 5
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: ST_TO_ADDR
12155: GO 13016
12157: LD_INT 9
12159: DOUBLE
12160: EQUAL
12161: IFTRUE 12165
12163: GO 12191
12165: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
12166: LD_ADDR_VAR 0 3
12170: PUSH
12171: LD_INT 2
12173: PUSH
12174: LD_INT 3
12176: PUSH
12177: LD_INT 4
12179: PUSH
12180: LD_INT 5
12182: PUSH
12183: EMPTY
12184: LIST
12185: LIST
12186: LIST
12187: LIST
12188: ST_TO_ADDR
12189: GO 13016
12191: LD_INT 7
12193: DOUBLE
12194: EQUAL
12195: IFTRUE 12199
12197: GO 12225
12199: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
12200: LD_ADDR_VAR 0 3
12204: PUSH
12205: LD_INT 2
12207: PUSH
12208: LD_INT 3
12210: PUSH
12211: LD_INT 4
12213: PUSH
12214: LD_INT 5
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: ST_TO_ADDR
12223: GO 13016
12225: LD_INT 12
12227: DOUBLE
12228: EQUAL
12229: IFTRUE 12233
12231: GO 12259
12233: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
12234: LD_ADDR_VAR 0 3
12238: PUSH
12239: LD_INT 2
12241: PUSH
12242: LD_INT 3
12244: PUSH
12245: LD_INT 4
12247: PUSH
12248: LD_INT 5
12250: PUSH
12251: EMPTY
12252: LIST
12253: LIST
12254: LIST
12255: LIST
12256: ST_TO_ADDR
12257: GO 13016
12259: LD_INT 13
12261: DOUBLE
12262: EQUAL
12263: IFTRUE 12267
12265: GO 12293
12267: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
12268: LD_ADDR_VAR 0 3
12272: PUSH
12273: LD_INT 2
12275: PUSH
12276: LD_INT 3
12278: PUSH
12279: LD_INT 4
12281: PUSH
12282: LD_INT 5
12284: PUSH
12285: EMPTY
12286: LIST
12287: LIST
12288: LIST
12289: LIST
12290: ST_TO_ADDR
12291: GO 13016
12293: LD_INT 14
12295: DOUBLE
12296: EQUAL
12297: IFTRUE 12301
12299: GO 12319
12301: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
12302: LD_ADDR_VAR 0 3
12306: PUSH
12307: LD_INT 4
12309: PUSH
12310: LD_INT 5
12312: PUSH
12313: EMPTY
12314: LIST
12315: LIST
12316: ST_TO_ADDR
12317: GO 13016
12319: LD_INT 6
12321: DOUBLE
12322: EQUAL
12323: IFTRUE 12327
12325: GO 12345
12327: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
12328: LD_ADDR_VAR 0 3
12332: PUSH
12333: LD_INT 4
12335: PUSH
12336: LD_INT 5
12338: PUSH
12339: EMPTY
12340: LIST
12341: LIST
12342: ST_TO_ADDR
12343: GO 13016
12345: LD_INT 10
12347: DOUBLE
12348: EQUAL
12349: IFTRUE 12353
12351: GO 12371
12353: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
12354: LD_ADDR_VAR 0 3
12358: PUSH
12359: LD_INT 4
12361: PUSH
12362: LD_INT 5
12364: PUSH
12365: EMPTY
12366: LIST
12367: LIST
12368: ST_TO_ADDR
12369: GO 13016
12371: LD_INT 22
12373: DOUBLE
12374: EQUAL
12375: IFTRUE 12379
12377: GO 12405
12379: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
12380: LD_ADDR_VAR 0 3
12384: PUSH
12385: LD_INT 11
12387: PUSH
12388: LD_INT 12
12390: PUSH
12391: LD_INT 13
12393: PUSH
12394: LD_INT 14
12396: PUSH
12397: EMPTY
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: ST_TO_ADDR
12403: GO 13016
12405: LD_INT 23
12407: DOUBLE
12408: EQUAL
12409: IFTRUE 12413
12411: GO 12439
12413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
12414: LD_ADDR_VAR 0 3
12418: PUSH
12419: LD_INT 11
12421: PUSH
12422: LD_INT 12
12424: PUSH
12425: LD_INT 13
12427: PUSH
12428: LD_INT 14
12430: PUSH
12431: EMPTY
12432: LIST
12433: LIST
12434: LIST
12435: LIST
12436: ST_TO_ADDR
12437: GO 13016
12439: LD_INT 24
12441: DOUBLE
12442: EQUAL
12443: IFTRUE 12447
12445: GO 12473
12447: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
12448: LD_ADDR_VAR 0 3
12452: PUSH
12453: LD_INT 11
12455: PUSH
12456: LD_INT 12
12458: PUSH
12459: LD_INT 13
12461: PUSH
12462: LD_INT 14
12464: PUSH
12465: EMPTY
12466: LIST
12467: LIST
12468: LIST
12469: LIST
12470: ST_TO_ADDR
12471: GO 13016
12473: LD_INT 30
12475: DOUBLE
12476: EQUAL
12477: IFTRUE 12481
12479: GO 12507
12481: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
12482: LD_ADDR_VAR 0 3
12486: PUSH
12487: LD_INT 11
12489: PUSH
12490: LD_INT 12
12492: PUSH
12493: LD_INT 13
12495: PUSH
12496: LD_INT 14
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: ST_TO_ADDR
12505: GO 13016
12507: LD_INT 25
12509: DOUBLE
12510: EQUAL
12511: IFTRUE 12515
12513: GO 12533
12515: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
12516: LD_ADDR_VAR 0 3
12520: PUSH
12521: LD_INT 13
12523: PUSH
12524: LD_INT 14
12526: PUSH
12527: EMPTY
12528: LIST
12529: LIST
12530: ST_TO_ADDR
12531: GO 13016
12533: LD_INT 27
12535: DOUBLE
12536: EQUAL
12537: IFTRUE 12541
12539: GO 12559
12541: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
12542: LD_ADDR_VAR 0 3
12546: PUSH
12547: LD_INT 13
12549: PUSH
12550: LD_INT 14
12552: PUSH
12553: EMPTY
12554: LIST
12555: LIST
12556: ST_TO_ADDR
12557: GO 13016
12559: LD_EXP 72
12563: DOUBLE
12564: EQUAL
12565: IFTRUE 12569
12567: GO 12595
12569: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
12570: LD_ADDR_VAR 0 3
12574: PUSH
12575: LD_INT 11
12577: PUSH
12578: LD_INT 12
12580: PUSH
12581: LD_INT 13
12583: PUSH
12584: LD_INT 14
12586: PUSH
12587: EMPTY
12588: LIST
12589: LIST
12590: LIST
12591: LIST
12592: ST_TO_ADDR
12593: GO 13016
12595: LD_INT 28
12597: DOUBLE
12598: EQUAL
12599: IFTRUE 12603
12601: GO 12621
12603: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
12604: LD_ADDR_VAR 0 3
12608: PUSH
12609: LD_INT 13
12611: PUSH
12612: LD_INT 14
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: ST_TO_ADDR
12619: GO 13016
12621: LD_INT 29
12623: DOUBLE
12624: EQUAL
12625: IFTRUE 12629
12627: GO 12647
12629: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
12630: LD_ADDR_VAR 0 3
12634: PUSH
12635: LD_INT 13
12637: PUSH
12638: LD_INT 14
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: ST_TO_ADDR
12645: GO 13016
12647: LD_INT 31
12649: DOUBLE
12650: EQUAL
12651: IFTRUE 12655
12653: GO 12673
12655: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
12656: LD_ADDR_VAR 0 3
12660: PUSH
12661: LD_INT 13
12663: PUSH
12664: LD_INT 14
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: ST_TO_ADDR
12671: GO 13016
12673: LD_INT 26
12675: DOUBLE
12676: EQUAL
12677: IFTRUE 12681
12679: GO 12699
12681: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
12682: LD_ADDR_VAR 0 3
12686: PUSH
12687: LD_INT 13
12689: PUSH
12690: LD_INT 14
12692: PUSH
12693: EMPTY
12694: LIST
12695: LIST
12696: ST_TO_ADDR
12697: GO 13016
12699: LD_INT 42
12701: DOUBLE
12702: EQUAL
12703: IFTRUE 12707
12705: GO 12733
12707: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
12708: LD_ADDR_VAR 0 3
12712: PUSH
12713: LD_INT 21
12715: PUSH
12716: LD_INT 22
12718: PUSH
12719: LD_INT 23
12721: PUSH
12722: LD_INT 24
12724: PUSH
12725: EMPTY
12726: LIST
12727: LIST
12728: LIST
12729: LIST
12730: ST_TO_ADDR
12731: GO 13016
12733: LD_INT 43
12735: DOUBLE
12736: EQUAL
12737: IFTRUE 12741
12739: GO 12767
12741: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
12742: LD_ADDR_VAR 0 3
12746: PUSH
12747: LD_INT 21
12749: PUSH
12750: LD_INT 22
12752: PUSH
12753: LD_INT 23
12755: PUSH
12756: LD_INT 24
12758: PUSH
12759: EMPTY
12760: LIST
12761: LIST
12762: LIST
12763: LIST
12764: ST_TO_ADDR
12765: GO 13016
12767: LD_INT 44
12769: DOUBLE
12770: EQUAL
12771: IFTRUE 12775
12773: GO 12801
12775: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
12776: LD_ADDR_VAR 0 3
12780: PUSH
12781: LD_INT 21
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 23
12789: PUSH
12790: LD_INT 24
12792: PUSH
12793: EMPTY
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: ST_TO_ADDR
12799: GO 13016
12801: LD_INT 45
12803: DOUBLE
12804: EQUAL
12805: IFTRUE 12809
12807: GO 12835
12809: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
12810: LD_ADDR_VAR 0 3
12814: PUSH
12815: LD_INT 21
12817: PUSH
12818: LD_INT 22
12820: PUSH
12821: LD_INT 23
12823: PUSH
12824: LD_INT 24
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: LIST
12831: LIST
12832: ST_TO_ADDR
12833: GO 13016
12835: LD_INT 49
12837: DOUBLE
12838: EQUAL
12839: IFTRUE 12843
12841: GO 12869
12843: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
12844: LD_ADDR_VAR 0 3
12848: PUSH
12849: LD_INT 21
12851: PUSH
12852: LD_INT 22
12854: PUSH
12855: LD_INT 23
12857: PUSH
12858: LD_INT 24
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: ST_TO_ADDR
12867: GO 13016
12869: LD_INT 51
12871: DOUBLE
12872: EQUAL
12873: IFTRUE 12877
12875: GO 12903
12877: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
12878: LD_ADDR_VAR 0 3
12882: PUSH
12883: LD_INT 21
12885: PUSH
12886: LD_INT 22
12888: PUSH
12889: LD_INT 23
12891: PUSH
12892: LD_INT 24
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: ST_TO_ADDR
12901: GO 13016
12903: LD_INT 52
12905: DOUBLE
12906: EQUAL
12907: IFTRUE 12911
12909: GO 12937
12911: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
12912: LD_ADDR_VAR 0 3
12916: PUSH
12917: LD_INT 21
12919: PUSH
12920: LD_INT 22
12922: PUSH
12923: LD_INT 23
12925: PUSH
12926: LD_INT 24
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: ST_TO_ADDR
12935: GO 13016
12937: LD_INT 53
12939: DOUBLE
12940: EQUAL
12941: IFTRUE 12945
12943: GO 12963
12945: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
12946: LD_ADDR_VAR 0 3
12950: PUSH
12951: LD_INT 23
12953: PUSH
12954: LD_INT 24
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: ST_TO_ADDR
12961: GO 13016
12963: LD_INT 46
12965: DOUBLE
12966: EQUAL
12967: IFTRUE 12971
12969: GO 12989
12971: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
12972: LD_ADDR_VAR 0 3
12976: PUSH
12977: LD_INT 23
12979: PUSH
12980: LD_INT 24
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: ST_TO_ADDR
12987: GO 13016
12989: LD_INT 47
12991: DOUBLE
12992: EQUAL
12993: IFTRUE 12997
12995: GO 13015
12997: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
12998: LD_ADDR_VAR 0 3
13002: PUSH
13003: LD_INT 23
13005: PUSH
13006: LD_INT 24
13008: PUSH
13009: EMPTY
13010: LIST
13011: LIST
13012: ST_TO_ADDR
13013: GO 13016
13015: POP
// result := ( chassis in result ) ;
13016: LD_ADDR_VAR 0 3
13020: PUSH
13021: LD_VAR 0 1
13025: PUSH
13026: LD_VAR 0 3
13030: IN
13031: ST_TO_ADDR
// end ;
13032: LD_VAR 0 3
13036: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
13037: LD_INT 0
13039: PPUSH
13040: PPUSH
13041: PPUSH
13042: PPUSH
13043: PPUSH
13044: PPUSH
13045: PPUSH
// result := array ;
13046: LD_ADDR_VAR 0 5
13050: PUSH
13051: LD_VAR 0 1
13055: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
13056: LD_VAR 0 1
13060: NOT
13061: PUSH
13062: LD_VAR 0 2
13066: NOT
13067: OR
13068: PUSH
13069: LD_VAR 0 3
13073: NOT
13074: OR
13075: PUSH
13076: LD_VAR 0 2
13080: PUSH
13081: LD_VAR 0 1
13085: GREATER
13086: OR
13087: PUSH
13088: LD_VAR 0 3
13092: PUSH
13093: LD_VAR 0 1
13097: GREATER
13098: OR
13099: IFFALSE 13103
// exit ;
13101: GO 13399
// if direction then
13103: LD_VAR 0 4
13107: IFFALSE 13171
// begin d := 1 ;
13109: LD_ADDR_VAR 0 9
13113: PUSH
13114: LD_INT 1
13116: ST_TO_ADDR
// if i_from > i_to then
13117: LD_VAR 0 2
13121: PUSH
13122: LD_VAR 0 3
13126: GREATER
13127: IFFALSE 13153
// length := ( array - i_from ) + i_to else
13129: LD_ADDR_VAR 0 11
13133: PUSH
13134: LD_VAR 0 1
13138: PUSH
13139: LD_VAR 0 2
13143: MINUS
13144: PUSH
13145: LD_VAR 0 3
13149: PLUS
13150: ST_TO_ADDR
13151: GO 13169
// length := i_to - i_from ;
13153: LD_ADDR_VAR 0 11
13157: PUSH
13158: LD_VAR 0 3
13162: PUSH
13163: LD_VAR 0 2
13167: MINUS
13168: ST_TO_ADDR
// end else
13169: GO 13232
// begin d := - 1 ;
13171: LD_ADDR_VAR 0 9
13175: PUSH
13176: LD_INT 1
13178: NEG
13179: ST_TO_ADDR
// if i_from > i_to then
13180: LD_VAR 0 2
13184: PUSH
13185: LD_VAR 0 3
13189: GREATER
13190: IFFALSE 13210
// length := i_from - i_to else
13192: LD_ADDR_VAR 0 11
13196: PUSH
13197: LD_VAR 0 2
13201: PUSH
13202: LD_VAR 0 3
13206: MINUS
13207: ST_TO_ADDR
13208: GO 13232
// length := ( array - i_to ) + i_from ;
13210: LD_ADDR_VAR 0 11
13214: PUSH
13215: LD_VAR 0 1
13219: PUSH
13220: LD_VAR 0 3
13224: MINUS
13225: PUSH
13226: LD_VAR 0 2
13230: PLUS
13231: ST_TO_ADDR
// end ; if not length then
13232: LD_VAR 0 11
13236: NOT
13237: IFFALSE 13241
// exit ;
13239: GO 13399
// tmp := array ;
13241: LD_ADDR_VAR 0 10
13245: PUSH
13246: LD_VAR 0 1
13250: ST_TO_ADDR
// for i = 1 to length do
13251: LD_ADDR_VAR 0 6
13255: PUSH
13256: DOUBLE
13257: LD_INT 1
13259: DEC
13260: ST_TO_ADDR
13261: LD_VAR 0 11
13265: PUSH
13266: FOR_TO
13267: IFFALSE 13387
// begin for j = 1 to array do
13269: LD_ADDR_VAR 0 7
13273: PUSH
13274: DOUBLE
13275: LD_INT 1
13277: DEC
13278: ST_TO_ADDR
13279: LD_VAR 0 1
13283: PUSH
13284: FOR_TO
13285: IFFALSE 13373
// begin k := j + d ;
13287: LD_ADDR_VAR 0 8
13291: PUSH
13292: LD_VAR 0 7
13296: PUSH
13297: LD_VAR 0 9
13301: PLUS
13302: ST_TO_ADDR
// if k > array then
13303: LD_VAR 0 8
13307: PUSH
13308: LD_VAR 0 1
13312: GREATER
13313: IFFALSE 13323
// k := 1 ;
13315: LD_ADDR_VAR 0 8
13319: PUSH
13320: LD_INT 1
13322: ST_TO_ADDR
// if not k then
13323: LD_VAR 0 8
13327: NOT
13328: IFFALSE 13340
// k := array ;
13330: LD_ADDR_VAR 0 8
13334: PUSH
13335: LD_VAR 0 1
13339: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
13340: LD_ADDR_VAR 0 10
13344: PUSH
13345: LD_VAR 0 10
13349: PPUSH
13350: LD_VAR 0 8
13354: PPUSH
13355: LD_VAR 0 1
13359: PUSH
13360: LD_VAR 0 7
13364: ARRAY
13365: PPUSH
13366: CALL_OW 1
13370: ST_TO_ADDR
// end ;
13371: GO 13284
13373: POP
13374: POP
// array := tmp ;
13375: LD_ADDR_VAR 0 1
13379: PUSH
13380: LD_VAR 0 10
13384: ST_TO_ADDR
// end ;
13385: GO 13266
13387: POP
13388: POP
// result := array ;
13389: LD_ADDR_VAR 0 5
13393: PUSH
13394: LD_VAR 0 1
13398: ST_TO_ADDR
// end ;
13399: LD_VAR 0 5
13403: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
13404: LD_INT 0
13406: PPUSH
13407: PPUSH
// result := 0 ;
13408: LD_ADDR_VAR 0 3
13412: PUSH
13413: LD_INT 0
13415: ST_TO_ADDR
// if not array or not value in array then
13416: LD_VAR 0 1
13420: NOT
13421: PUSH
13422: LD_VAR 0 2
13426: PUSH
13427: LD_VAR 0 1
13431: IN
13432: NOT
13433: OR
13434: IFFALSE 13438
// exit ;
13436: GO 13492
// for i = 1 to array do
13438: LD_ADDR_VAR 0 4
13442: PUSH
13443: DOUBLE
13444: LD_INT 1
13446: DEC
13447: ST_TO_ADDR
13448: LD_VAR 0 1
13452: PUSH
13453: FOR_TO
13454: IFFALSE 13490
// if value = array [ i ] then
13456: LD_VAR 0 2
13460: PUSH
13461: LD_VAR 0 1
13465: PUSH
13466: LD_VAR 0 4
13470: ARRAY
13471: EQUAL
13472: IFFALSE 13488
// begin result := i ;
13474: LD_ADDR_VAR 0 3
13478: PUSH
13479: LD_VAR 0 4
13483: ST_TO_ADDR
// exit ;
13484: POP
13485: POP
13486: GO 13492
// end ;
13488: GO 13453
13490: POP
13491: POP
// end ;
13492: LD_VAR 0 3
13496: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
13497: LD_INT 0
13499: PPUSH
// vc_chassis := chassis ;
13500: LD_ADDR_OWVAR 37
13504: PUSH
13505: LD_VAR 0 1
13509: ST_TO_ADDR
// vc_engine := engine ;
13510: LD_ADDR_OWVAR 39
13514: PUSH
13515: LD_VAR 0 2
13519: ST_TO_ADDR
// vc_control := control ;
13520: LD_ADDR_OWVAR 38
13524: PUSH
13525: LD_VAR 0 3
13529: ST_TO_ADDR
// vc_weapon := weapon ;
13530: LD_ADDR_OWVAR 40
13534: PUSH
13535: LD_VAR 0 4
13539: ST_TO_ADDR
// vc_fuel_battery := fuel ;
13540: LD_ADDR_OWVAR 41
13544: PUSH
13545: LD_VAR 0 5
13549: ST_TO_ADDR
// end ;
13550: LD_VAR 0 6
13554: RET
// export function WantPlant ( unit ) ; var task ; begin
13555: LD_INT 0
13557: PPUSH
13558: PPUSH
// result := false ;
13559: LD_ADDR_VAR 0 2
13563: PUSH
13564: LD_INT 0
13566: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
13567: LD_ADDR_VAR 0 3
13571: PUSH
13572: LD_VAR 0 1
13576: PPUSH
13577: CALL_OW 437
13581: ST_TO_ADDR
// if task then
13582: LD_VAR 0 3
13586: IFFALSE 13614
// if task [ 1 ] [ 1 ] = p then
13588: LD_VAR 0 3
13592: PUSH
13593: LD_INT 1
13595: ARRAY
13596: PUSH
13597: LD_INT 1
13599: ARRAY
13600: PUSH
13601: LD_STRING p
13603: EQUAL
13604: IFFALSE 13614
// result := true ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 1
13613: ST_TO_ADDR
// end ;
13614: LD_VAR 0 2
13618: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
13619: LD_INT 0
13621: PPUSH
13622: PPUSH
13623: PPUSH
13624: PPUSH
// if pos < 1 then
13625: LD_VAR 0 2
13629: PUSH
13630: LD_INT 1
13632: LESS
13633: IFFALSE 13637
// exit ;
13635: GO 13940
// if pos = 1 then
13637: LD_VAR 0 2
13641: PUSH
13642: LD_INT 1
13644: EQUAL
13645: IFFALSE 13678
// result := Replace ( arr , pos [ 1 ] , value ) else
13647: LD_ADDR_VAR 0 4
13651: PUSH
13652: LD_VAR 0 1
13656: PPUSH
13657: LD_VAR 0 2
13661: PUSH
13662: LD_INT 1
13664: ARRAY
13665: PPUSH
13666: LD_VAR 0 3
13670: PPUSH
13671: CALL_OW 1
13675: ST_TO_ADDR
13676: GO 13940
// begin tmp := arr ;
13678: LD_ADDR_VAR 0 6
13682: PUSH
13683: LD_VAR 0 1
13687: ST_TO_ADDR
// s_arr := [ tmp ] ;
13688: LD_ADDR_VAR 0 7
13692: PUSH
13693: LD_VAR 0 6
13697: PUSH
13698: EMPTY
13699: LIST
13700: ST_TO_ADDR
// for i = 1 to pos - 1 do
13701: LD_ADDR_VAR 0 5
13705: PUSH
13706: DOUBLE
13707: LD_INT 1
13709: DEC
13710: ST_TO_ADDR
13711: LD_VAR 0 2
13715: PUSH
13716: LD_INT 1
13718: MINUS
13719: PUSH
13720: FOR_TO
13721: IFFALSE 13766
// begin tmp := tmp [ pos [ i ] ] ;
13723: LD_ADDR_VAR 0 6
13727: PUSH
13728: LD_VAR 0 6
13732: PUSH
13733: LD_VAR 0 2
13737: PUSH
13738: LD_VAR 0 5
13742: ARRAY
13743: ARRAY
13744: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
13745: LD_ADDR_VAR 0 7
13749: PUSH
13750: LD_VAR 0 7
13754: PUSH
13755: LD_VAR 0 6
13759: PUSH
13760: EMPTY
13761: LIST
13762: ADD
13763: ST_TO_ADDR
// end ;
13764: GO 13720
13766: POP
13767: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
13768: LD_ADDR_VAR 0 6
13772: PUSH
13773: LD_VAR 0 6
13777: PPUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 2
13787: ARRAY
13788: PPUSH
13789: LD_VAR 0 3
13793: PPUSH
13794: CALL_OW 1
13798: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
13799: LD_ADDR_VAR 0 7
13803: PUSH
13804: LD_VAR 0 7
13808: PPUSH
13809: LD_VAR 0 7
13813: PPUSH
13814: LD_VAR 0 6
13818: PPUSH
13819: CALL_OW 1
13823: ST_TO_ADDR
// for i = s_arr downto 2 do
13824: LD_ADDR_VAR 0 5
13828: PUSH
13829: DOUBLE
13830: LD_VAR 0 7
13834: INC
13835: ST_TO_ADDR
13836: LD_INT 2
13838: PUSH
13839: FOR_DOWNTO
13840: IFFALSE 13924
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
13842: LD_ADDR_VAR 0 6
13846: PUSH
13847: LD_VAR 0 7
13851: PUSH
13852: LD_VAR 0 5
13856: PUSH
13857: LD_INT 1
13859: MINUS
13860: ARRAY
13861: PPUSH
13862: LD_VAR 0 2
13866: PUSH
13867: LD_VAR 0 5
13871: PUSH
13872: LD_INT 1
13874: MINUS
13875: ARRAY
13876: PPUSH
13877: LD_VAR 0 7
13881: PUSH
13882: LD_VAR 0 5
13886: ARRAY
13887: PPUSH
13888: CALL_OW 1
13892: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
13893: LD_ADDR_VAR 0 7
13897: PUSH
13898: LD_VAR 0 7
13902: PPUSH
13903: LD_VAR 0 5
13907: PUSH
13908: LD_INT 1
13910: MINUS
13911: PPUSH
13912: LD_VAR 0 6
13916: PPUSH
13917: CALL_OW 1
13921: ST_TO_ADDR
// end ;
13922: GO 13839
13924: POP
13925: POP
// result := s_arr [ 1 ] ;
13926: LD_ADDR_VAR 0 4
13930: PUSH
13931: LD_VAR 0 7
13935: PUSH
13936: LD_INT 1
13938: ARRAY
13939: ST_TO_ADDR
// end ; end ;
13940: LD_VAR 0 4
13944: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
13945: LD_INT 0
13947: PPUSH
13948: PPUSH
// if not list then
13949: LD_VAR 0 1
13953: NOT
13954: IFFALSE 13958
// exit ;
13956: GO 14049
// i := list [ pos1 ] ;
13958: LD_ADDR_VAR 0 5
13962: PUSH
13963: LD_VAR 0 1
13967: PUSH
13968: LD_VAR 0 2
13972: ARRAY
13973: ST_TO_ADDR
// if not i then
13974: LD_VAR 0 5
13978: NOT
13979: IFFALSE 13983
// exit ;
13981: GO 14049
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
13983: LD_ADDR_VAR 0 1
13987: PUSH
13988: LD_VAR 0 1
13992: PPUSH
13993: LD_VAR 0 2
13997: PPUSH
13998: LD_VAR 0 1
14002: PUSH
14003: LD_VAR 0 3
14007: ARRAY
14008: PPUSH
14009: CALL_OW 1
14013: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
14014: LD_ADDR_VAR 0 1
14018: PUSH
14019: LD_VAR 0 1
14023: PPUSH
14024: LD_VAR 0 3
14028: PPUSH
14029: LD_VAR 0 5
14033: PPUSH
14034: CALL_OW 1
14038: ST_TO_ADDR
// result := list ;
14039: LD_ADDR_VAR 0 4
14043: PUSH
14044: LD_VAR 0 1
14048: ST_TO_ADDR
// end ;
14049: LD_VAR 0 4
14053: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
14054: LD_INT 0
14056: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
14057: LD_ADDR_VAR 0 5
14061: PUSH
14062: LD_VAR 0 1
14066: PPUSH
14067: CALL_OW 250
14071: PPUSH
14072: LD_VAR 0 1
14076: PPUSH
14077: CALL_OW 251
14081: PPUSH
14082: LD_VAR 0 2
14086: PPUSH
14087: LD_VAR 0 3
14091: PPUSH
14092: LD_VAR 0 4
14096: PPUSH
14097: CALL 14107 0 5
14101: ST_TO_ADDR
// end ;
14102: LD_VAR 0 5
14106: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
14107: LD_INT 0
14109: PPUSH
14110: PPUSH
14111: PPUSH
14112: PPUSH
// if not list then
14113: LD_VAR 0 3
14117: NOT
14118: IFFALSE 14122
// exit ;
14120: GO 14510
// result := [ ] ;
14122: LD_ADDR_VAR 0 6
14126: PUSH
14127: EMPTY
14128: ST_TO_ADDR
// for i in list do
14129: LD_ADDR_VAR 0 7
14133: PUSH
14134: LD_VAR 0 3
14138: PUSH
14139: FOR_IN
14140: IFFALSE 14342
// begin tmp := GetDistUnitXY ( i , x , y ) ;
14142: LD_ADDR_VAR 0 9
14146: PUSH
14147: LD_VAR 0 7
14151: PPUSH
14152: LD_VAR 0 1
14156: PPUSH
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 297
14166: ST_TO_ADDR
// if not result then
14167: LD_VAR 0 6
14171: NOT
14172: IFFALSE 14198
// result := [ [ i , tmp ] ] else
14174: LD_ADDR_VAR 0 6
14178: PUSH
14179: LD_VAR 0 7
14183: PUSH
14184: LD_VAR 0 9
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: PUSH
14193: EMPTY
14194: LIST
14195: ST_TO_ADDR
14196: GO 14340
// begin if result [ result ] [ 2 ] < tmp then
14198: LD_VAR 0 6
14202: PUSH
14203: LD_VAR 0 6
14207: ARRAY
14208: PUSH
14209: LD_INT 2
14211: ARRAY
14212: PUSH
14213: LD_VAR 0 9
14217: LESS
14218: IFFALSE 14260
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
14220: LD_ADDR_VAR 0 6
14224: PUSH
14225: LD_VAR 0 6
14229: PPUSH
14230: LD_VAR 0 6
14234: PUSH
14235: LD_INT 1
14237: PLUS
14238: PPUSH
14239: LD_VAR 0 7
14243: PUSH
14244: LD_VAR 0 9
14248: PUSH
14249: EMPTY
14250: LIST
14251: LIST
14252: PPUSH
14253: CALL_OW 2
14257: ST_TO_ADDR
14258: GO 14340
// for j = 1 to result do
14260: LD_ADDR_VAR 0 8
14264: PUSH
14265: DOUBLE
14266: LD_INT 1
14268: DEC
14269: ST_TO_ADDR
14270: LD_VAR 0 6
14274: PUSH
14275: FOR_TO
14276: IFFALSE 14338
// begin if tmp < result [ j ] [ 2 ] then
14278: LD_VAR 0 9
14282: PUSH
14283: LD_VAR 0 6
14287: PUSH
14288: LD_VAR 0 8
14292: ARRAY
14293: PUSH
14294: LD_INT 2
14296: ARRAY
14297: LESS
14298: IFFALSE 14336
// begin result := Insert ( result , j , [ i , tmp ] ) ;
14300: LD_ADDR_VAR 0 6
14304: PUSH
14305: LD_VAR 0 6
14309: PPUSH
14310: LD_VAR 0 8
14314: PPUSH
14315: LD_VAR 0 7
14319: PUSH
14320: LD_VAR 0 9
14324: PUSH
14325: EMPTY
14326: LIST
14327: LIST
14328: PPUSH
14329: CALL_OW 2
14333: ST_TO_ADDR
// break ;
14334: GO 14338
// end ; end ;
14336: GO 14275
14338: POP
14339: POP
// end ; end ;
14340: GO 14139
14342: POP
14343: POP
// if result and not asc then
14344: LD_VAR 0 6
14348: PUSH
14349: LD_VAR 0 4
14353: NOT
14354: AND
14355: IFFALSE 14430
// begin tmp := result ;
14357: LD_ADDR_VAR 0 9
14361: PUSH
14362: LD_VAR 0 6
14366: ST_TO_ADDR
// for i = tmp downto 1 do
14367: LD_ADDR_VAR 0 7
14371: PUSH
14372: DOUBLE
14373: LD_VAR 0 9
14377: INC
14378: ST_TO_ADDR
14379: LD_INT 1
14381: PUSH
14382: FOR_DOWNTO
14383: IFFALSE 14428
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
14385: LD_ADDR_VAR 0 6
14389: PUSH
14390: LD_VAR 0 6
14394: PPUSH
14395: LD_VAR 0 9
14399: PUSH
14400: LD_VAR 0 7
14404: MINUS
14405: PUSH
14406: LD_INT 1
14408: PLUS
14409: PPUSH
14410: LD_VAR 0 9
14414: PUSH
14415: LD_VAR 0 7
14419: ARRAY
14420: PPUSH
14421: CALL_OW 1
14425: ST_TO_ADDR
14426: GO 14382
14428: POP
14429: POP
// end ; tmp := [ ] ;
14430: LD_ADDR_VAR 0 9
14434: PUSH
14435: EMPTY
14436: ST_TO_ADDR
// if mode then
14437: LD_VAR 0 5
14441: IFFALSE 14510
// begin for i = 1 to result do
14443: LD_ADDR_VAR 0 7
14447: PUSH
14448: DOUBLE
14449: LD_INT 1
14451: DEC
14452: ST_TO_ADDR
14453: LD_VAR 0 6
14457: PUSH
14458: FOR_TO
14459: IFFALSE 14498
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
14461: LD_ADDR_VAR 0 9
14465: PUSH
14466: LD_VAR 0 9
14470: PPUSH
14471: LD_VAR 0 7
14475: PPUSH
14476: LD_VAR 0 6
14480: PUSH
14481: LD_VAR 0 7
14485: ARRAY
14486: PUSH
14487: LD_INT 1
14489: ARRAY
14490: PPUSH
14491: CALL_OW 1
14495: ST_TO_ADDR
14496: GO 14458
14498: POP
14499: POP
// result := tmp ;
14500: LD_ADDR_VAR 0 6
14504: PUSH
14505: LD_VAR 0 9
14509: ST_TO_ADDR
// end ; end ;
14510: LD_VAR 0 6
14514: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
14515: LD_INT 0
14517: PPUSH
14518: PPUSH
14519: PPUSH
14520: PPUSH
14521: PPUSH
14522: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
14523: LD_ADDR_VAR 0 5
14527: PUSH
14528: LD_INT 0
14530: PUSH
14531: LD_INT 0
14533: PUSH
14534: LD_INT 0
14536: PUSH
14537: EMPTY
14538: PUSH
14539: EMPTY
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: ST_TO_ADDR
// if not x or not y then
14545: LD_VAR 0 2
14549: NOT
14550: PUSH
14551: LD_VAR 0 3
14555: NOT
14556: OR
14557: IFFALSE 14561
// exit ;
14559: GO 16213
// if not range then
14561: LD_VAR 0 4
14565: NOT
14566: IFFALSE 14576
// range := 10 ;
14568: LD_ADDR_VAR 0 4
14572: PUSH
14573: LD_INT 10
14575: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14576: LD_ADDR_VAR 0 8
14580: PUSH
14581: LD_INT 81
14583: PUSH
14584: LD_VAR 0 1
14588: PUSH
14589: EMPTY
14590: LIST
14591: LIST
14592: PUSH
14593: LD_INT 92
14595: PUSH
14596: LD_VAR 0 2
14600: PUSH
14601: LD_VAR 0 3
14605: PUSH
14606: LD_VAR 0 4
14610: PUSH
14611: EMPTY
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: PUSH
14617: LD_INT 3
14619: PUSH
14620: LD_INT 21
14622: PUSH
14623: LD_INT 3
14625: PUSH
14626: EMPTY
14627: LIST
14628: LIST
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: EMPTY
14635: LIST
14636: LIST
14637: LIST
14638: PPUSH
14639: CALL_OW 69
14643: ST_TO_ADDR
// if not tmp then
14644: LD_VAR 0 8
14648: NOT
14649: IFFALSE 14653
// exit ;
14651: GO 16213
// for i in tmp do
14653: LD_ADDR_VAR 0 6
14657: PUSH
14658: LD_VAR 0 8
14662: PUSH
14663: FOR_IN
14664: IFFALSE 16188
// begin points := [ 0 , 0 , 0 ] ;
14666: LD_ADDR_VAR 0 9
14670: PUSH
14671: LD_INT 0
14673: PUSH
14674: LD_INT 0
14676: PUSH
14677: LD_INT 0
14679: PUSH
14680: EMPTY
14681: LIST
14682: LIST
14683: LIST
14684: ST_TO_ADDR
// bpoints := 1 ;
14685: LD_ADDR_VAR 0 10
14689: PUSH
14690: LD_INT 1
14692: ST_TO_ADDR
// case GetType ( i ) of unit_human :
14693: LD_VAR 0 6
14697: PPUSH
14698: CALL_OW 247
14702: PUSH
14703: LD_INT 1
14705: DOUBLE
14706: EQUAL
14707: IFTRUE 14711
14709: GO 15289
14711: POP
// begin if GetClass ( i ) = 1 then
14712: LD_VAR 0 6
14716: PPUSH
14717: CALL_OW 257
14721: PUSH
14722: LD_INT 1
14724: EQUAL
14725: IFFALSE 14746
// points := [ 10 , 5 , 3 ] ;
14727: LD_ADDR_VAR 0 9
14731: PUSH
14732: LD_INT 10
14734: PUSH
14735: LD_INT 5
14737: PUSH
14738: LD_INT 3
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: LIST
14745: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
14746: LD_VAR 0 6
14750: PPUSH
14751: CALL_OW 257
14755: PUSH
14756: LD_INT 2
14758: PUSH
14759: LD_INT 3
14761: PUSH
14762: LD_INT 4
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: IN
14770: IFFALSE 14791
// points := [ 3 , 2 , 1 ] ;
14772: LD_ADDR_VAR 0 9
14776: PUSH
14777: LD_INT 3
14779: PUSH
14780: LD_INT 2
14782: PUSH
14783: LD_INT 1
14785: PUSH
14786: EMPTY
14787: LIST
14788: LIST
14789: LIST
14790: ST_TO_ADDR
// if GetClass ( i ) = 5 then
14791: LD_VAR 0 6
14795: PPUSH
14796: CALL_OW 257
14800: PUSH
14801: LD_INT 5
14803: EQUAL
14804: IFFALSE 14825
// points := [ 130 , 5 , 2 ] ;
14806: LD_ADDR_VAR 0 9
14810: PUSH
14811: LD_INT 130
14813: PUSH
14814: LD_INT 5
14816: PUSH
14817: LD_INT 2
14819: PUSH
14820: EMPTY
14821: LIST
14822: LIST
14823: LIST
14824: ST_TO_ADDR
// if GetClass ( i ) = 8 then
14825: LD_VAR 0 6
14829: PPUSH
14830: CALL_OW 257
14834: PUSH
14835: LD_INT 8
14837: EQUAL
14838: IFFALSE 14859
// points := [ 35 , 35 , 30 ] ;
14840: LD_ADDR_VAR 0 9
14844: PUSH
14845: LD_INT 35
14847: PUSH
14848: LD_INT 35
14850: PUSH
14851: LD_INT 30
14853: PUSH
14854: EMPTY
14855: LIST
14856: LIST
14857: LIST
14858: ST_TO_ADDR
// if GetClass ( i ) = 9 then
14859: LD_VAR 0 6
14863: PPUSH
14864: CALL_OW 257
14868: PUSH
14869: LD_INT 9
14871: EQUAL
14872: IFFALSE 14893
// points := [ 20 , 55 , 40 ] ;
14874: LD_ADDR_VAR 0 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 55
14884: PUSH
14885: LD_INT 40
14887: PUSH
14888: EMPTY
14889: LIST
14890: LIST
14891: LIST
14892: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
14893: LD_VAR 0 6
14897: PPUSH
14898: CALL_OW 257
14902: PUSH
14903: LD_INT 12
14905: PUSH
14906: LD_INT 16
14908: PUSH
14909: EMPTY
14910: LIST
14911: LIST
14912: IN
14913: IFFALSE 14934
// points := [ 5 , 3 , 2 ] ;
14915: LD_ADDR_VAR 0 9
14919: PUSH
14920: LD_INT 5
14922: PUSH
14923: LD_INT 3
14925: PUSH
14926: LD_INT 2
14928: PUSH
14929: EMPTY
14930: LIST
14931: LIST
14932: LIST
14933: ST_TO_ADDR
// if GetClass ( i ) = 17 then
14934: LD_VAR 0 6
14938: PPUSH
14939: CALL_OW 257
14943: PUSH
14944: LD_INT 17
14946: EQUAL
14947: IFFALSE 14968
// points := [ 100 , 50 , 75 ] ;
14949: LD_ADDR_VAR 0 9
14953: PUSH
14954: LD_INT 100
14956: PUSH
14957: LD_INT 50
14959: PUSH
14960: LD_INT 75
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: LIST
14967: ST_TO_ADDR
// if GetClass ( i ) = 15 then
14968: LD_VAR 0 6
14972: PPUSH
14973: CALL_OW 257
14977: PUSH
14978: LD_INT 15
14980: EQUAL
14981: IFFALSE 15002
// points := [ 10 , 5 , 3 ] ;
14983: LD_ADDR_VAR 0 9
14987: PUSH
14988: LD_INT 10
14990: PUSH
14991: LD_INT 5
14993: PUSH
14994: LD_INT 3
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: LIST
15001: ST_TO_ADDR
// if GetClass ( i ) = 14 then
15002: LD_VAR 0 6
15006: PPUSH
15007: CALL_OW 257
15011: PUSH
15012: LD_INT 14
15014: EQUAL
15015: IFFALSE 15036
// points := [ 10 , 0 , 0 ] ;
15017: LD_ADDR_VAR 0 9
15021: PUSH
15022: LD_INT 10
15024: PUSH
15025: LD_INT 0
15027: PUSH
15028: LD_INT 0
15030: PUSH
15031: EMPTY
15032: LIST
15033: LIST
15034: LIST
15035: ST_TO_ADDR
// if GetClass ( i ) = 11 then
15036: LD_VAR 0 6
15040: PPUSH
15041: CALL_OW 257
15045: PUSH
15046: LD_INT 11
15048: EQUAL
15049: IFFALSE 15070
// points := [ 30 , 10 , 5 ] ;
15051: LD_ADDR_VAR 0 9
15055: PUSH
15056: LD_INT 30
15058: PUSH
15059: LD_INT 10
15061: PUSH
15062: LD_INT 5
15064: PUSH
15065: EMPTY
15066: LIST
15067: LIST
15068: LIST
15069: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
15070: LD_VAR 0 1
15074: PPUSH
15075: LD_INT 5
15077: PPUSH
15078: CALL_OW 321
15082: PUSH
15083: LD_INT 2
15085: EQUAL
15086: IFFALSE 15103
// bpoints := bpoints * 1.8 ;
15088: LD_ADDR_VAR 0 10
15092: PUSH
15093: LD_VAR 0 10
15097: PUSH
15098: LD_REAL  1.80000000000000E+0000
15101: MUL
15102: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
15103: LD_VAR 0 6
15107: PPUSH
15108: CALL_OW 257
15112: PUSH
15113: LD_INT 1
15115: PUSH
15116: LD_INT 2
15118: PUSH
15119: LD_INT 3
15121: PUSH
15122: LD_INT 4
15124: PUSH
15125: EMPTY
15126: LIST
15127: LIST
15128: LIST
15129: LIST
15130: IN
15131: PUSH
15132: LD_VAR 0 1
15136: PPUSH
15137: LD_INT 51
15139: PPUSH
15140: CALL_OW 321
15144: PUSH
15145: LD_INT 2
15147: EQUAL
15148: AND
15149: IFFALSE 15166
// bpoints := bpoints * 1.2 ;
15151: LD_ADDR_VAR 0 10
15155: PUSH
15156: LD_VAR 0 10
15160: PUSH
15161: LD_REAL  1.20000000000000E+0000
15164: MUL
15165: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
15166: LD_VAR 0 6
15170: PPUSH
15171: CALL_OW 257
15175: PUSH
15176: LD_INT 5
15178: PUSH
15179: LD_INT 7
15181: PUSH
15182: LD_INT 9
15184: PUSH
15185: EMPTY
15186: LIST
15187: LIST
15188: LIST
15189: IN
15190: PUSH
15191: LD_VAR 0 1
15195: PPUSH
15196: LD_INT 52
15198: PPUSH
15199: CALL_OW 321
15203: PUSH
15204: LD_INT 2
15206: EQUAL
15207: AND
15208: IFFALSE 15225
// bpoints := bpoints * 1.5 ;
15210: LD_ADDR_VAR 0 10
15214: PUSH
15215: LD_VAR 0 10
15219: PUSH
15220: LD_REAL  1.50000000000000E+0000
15223: MUL
15224: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
15225: LD_VAR 0 1
15229: PPUSH
15230: LD_INT 66
15232: PPUSH
15233: CALL_OW 321
15237: PUSH
15238: LD_INT 2
15240: EQUAL
15241: IFFALSE 15258
// bpoints := bpoints * 1.1 ;
15243: LD_ADDR_VAR 0 10
15247: PUSH
15248: LD_VAR 0 10
15252: PUSH
15253: LD_REAL  1.10000000000000E+0000
15256: MUL
15257: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
15258: LD_ADDR_VAR 0 10
15262: PUSH
15263: LD_VAR 0 10
15267: PUSH
15268: LD_VAR 0 6
15272: PPUSH
15273: LD_INT 1
15275: PPUSH
15276: CALL_OW 259
15280: PUSH
15281: LD_REAL  1.15000000000000E+0000
15284: MUL
15285: MUL
15286: ST_TO_ADDR
// end ; unit_vehicle :
15287: GO 16117
15289: LD_INT 2
15291: DOUBLE
15292: EQUAL
15293: IFTRUE 15297
15295: GO 16105
15297: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
15298: LD_VAR 0 6
15302: PPUSH
15303: CALL_OW 264
15307: PUSH
15308: LD_INT 2
15310: PUSH
15311: LD_INT 42
15313: PUSH
15314: LD_INT 24
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: LIST
15321: IN
15322: IFFALSE 15343
// points := [ 25 , 5 , 3 ] ;
15324: LD_ADDR_VAR 0 9
15328: PUSH
15329: LD_INT 25
15331: PUSH
15332: LD_INT 5
15334: PUSH
15335: LD_INT 3
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: LIST
15342: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
15343: LD_VAR 0 6
15347: PPUSH
15348: CALL_OW 264
15352: PUSH
15353: LD_INT 4
15355: PUSH
15356: LD_INT 43
15358: PUSH
15359: LD_INT 25
15361: PUSH
15362: EMPTY
15363: LIST
15364: LIST
15365: LIST
15366: IN
15367: IFFALSE 15388
// points := [ 40 , 15 , 5 ] ;
15369: LD_ADDR_VAR 0 9
15373: PUSH
15374: LD_INT 40
15376: PUSH
15377: LD_INT 15
15379: PUSH
15380: LD_INT 5
15382: PUSH
15383: EMPTY
15384: LIST
15385: LIST
15386: LIST
15387: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
15388: LD_VAR 0 6
15392: PPUSH
15393: CALL_OW 264
15397: PUSH
15398: LD_INT 3
15400: PUSH
15401: LD_INT 23
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: IN
15408: IFFALSE 15429
// points := [ 7 , 25 , 8 ] ;
15410: LD_ADDR_VAR 0 9
15414: PUSH
15415: LD_INT 7
15417: PUSH
15418: LD_INT 25
15420: PUSH
15421: LD_INT 8
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: LIST
15428: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
15429: LD_VAR 0 6
15433: PPUSH
15434: CALL_OW 264
15438: PUSH
15439: LD_INT 5
15441: PUSH
15442: LD_INT 27
15444: PUSH
15445: LD_INT 44
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: LIST
15452: IN
15453: IFFALSE 15474
// points := [ 14 , 50 , 16 ] ;
15455: LD_ADDR_VAR 0 9
15459: PUSH
15460: LD_INT 14
15462: PUSH
15463: LD_INT 50
15465: PUSH
15466: LD_INT 16
15468: PUSH
15469: EMPTY
15470: LIST
15471: LIST
15472: LIST
15473: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
15474: LD_VAR 0 6
15478: PPUSH
15479: CALL_OW 264
15483: PUSH
15484: LD_INT 6
15486: PUSH
15487: LD_INT 46
15489: PUSH
15490: EMPTY
15491: LIST
15492: LIST
15493: IN
15494: IFFALSE 15515
// points := [ 32 , 120 , 70 ] ;
15496: LD_ADDR_VAR 0 9
15500: PUSH
15501: LD_INT 32
15503: PUSH
15504: LD_INT 120
15506: PUSH
15507: LD_INT 70
15509: PUSH
15510: EMPTY
15511: LIST
15512: LIST
15513: LIST
15514: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
15515: LD_VAR 0 6
15519: PPUSH
15520: CALL_OW 264
15524: PUSH
15525: LD_INT 7
15527: PUSH
15528: LD_INT 28
15530: PUSH
15531: LD_INT 45
15533: PUSH
15534: LD_EXP 72
15538: PUSH
15539: EMPTY
15540: LIST
15541: LIST
15542: LIST
15543: LIST
15544: IN
15545: IFFALSE 15566
// points := [ 35 , 20 , 45 ] ;
15547: LD_ADDR_VAR 0 9
15551: PUSH
15552: LD_INT 35
15554: PUSH
15555: LD_INT 20
15557: PUSH
15558: LD_INT 45
15560: PUSH
15561: EMPTY
15562: LIST
15563: LIST
15564: LIST
15565: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
15566: LD_VAR 0 6
15570: PPUSH
15571: CALL_OW 264
15575: PUSH
15576: LD_INT 47
15578: PUSH
15579: EMPTY
15580: LIST
15581: IN
15582: IFFALSE 15603
// points := [ 67 , 45 , 75 ] ;
15584: LD_ADDR_VAR 0 9
15588: PUSH
15589: LD_INT 67
15591: PUSH
15592: LD_INT 45
15594: PUSH
15595: LD_INT 75
15597: PUSH
15598: EMPTY
15599: LIST
15600: LIST
15601: LIST
15602: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
15603: LD_VAR 0 6
15607: PPUSH
15608: CALL_OW 264
15612: PUSH
15613: LD_INT 26
15615: PUSH
15616: EMPTY
15617: LIST
15618: IN
15619: IFFALSE 15640
// points := [ 120 , 30 , 80 ] ;
15621: LD_ADDR_VAR 0 9
15625: PUSH
15626: LD_INT 120
15628: PUSH
15629: LD_INT 30
15631: PUSH
15632: LD_INT 80
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: LIST
15639: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
15640: LD_VAR 0 6
15644: PPUSH
15645: CALL_OW 264
15649: PUSH
15650: LD_INT 22
15652: PUSH
15653: EMPTY
15654: LIST
15655: IN
15656: IFFALSE 15677
// points := [ 40 , 1 , 1 ] ;
15658: LD_ADDR_VAR 0 9
15662: PUSH
15663: LD_INT 40
15665: PUSH
15666: LD_INT 1
15668: PUSH
15669: LD_INT 1
15671: PUSH
15672: EMPTY
15673: LIST
15674: LIST
15675: LIST
15676: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
15677: LD_VAR 0 6
15681: PPUSH
15682: CALL_OW 264
15686: PUSH
15687: LD_INT 29
15689: PUSH
15690: EMPTY
15691: LIST
15692: IN
15693: IFFALSE 15714
// points := [ 70 , 200 , 400 ] ;
15695: LD_ADDR_VAR 0 9
15699: PUSH
15700: LD_INT 70
15702: PUSH
15703: LD_INT 200
15705: PUSH
15706: LD_INT 400
15708: PUSH
15709: EMPTY
15710: LIST
15711: LIST
15712: LIST
15713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
15714: LD_VAR 0 6
15718: PPUSH
15719: CALL_OW 264
15723: PUSH
15724: LD_INT 14
15726: PUSH
15727: LD_INT 53
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: IN
15734: IFFALSE 15755
// points := [ 40 , 10 , 20 ] ;
15736: LD_ADDR_VAR 0 9
15740: PUSH
15741: LD_INT 40
15743: PUSH
15744: LD_INT 10
15746: PUSH
15747: LD_INT 20
15749: PUSH
15750: EMPTY
15751: LIST
15752: LIST
15753: LIST
15754: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
15755: LD_VAR 0 6
15759: PPUSH
15760: CALL_OW 264
15764: PUSH
15765: LD_INT 9
15767: PUSH
15768: EMPTY
15769: LIST
15770: IN
15771: IFFALSE 15792
// points := [ 5 , 70 , 20 ] ;
15773: LD_ADDR_VAR 0 9
15777: PUSH
15778: LD_INT 5
15780: PUSH
15781: LD_INT 70
15783: PUSH
15784: LD_INT 20
15786: PUSH
15787: EMPTY
15788: LIST
15789: LIST
15790: LIST
15791: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
15792: LD_VAR 0 6
15796: PPUSH
15797: CALL_OW 264
15801: PUSH
15802: LD_INT 10
15804: PUSH
15805: EMPTY
15806: LIST
15807: IN
15808: IFFALSE 15829
// points := [ 35 , 110 , 70 ] ;
15810: LD_ADDR_VAR 0 9
15814: PUSH
15815: LD_INT 35
15817: PUSH
15818: LD_INT 110
15820: PUSH
15821: LD_INT 70
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: LIST
15828: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
15829: LD_VAR 0 6
15833: PPUSH
15834: CALL_OW 265
15838: PUSH
15839: LD_INT 25
15841: EQUAL
15842: IFFALSE 15863
// points := [ 80 , 65 , 100 ] ;
15844: LD_ADDR_VAR 0 9
15848: PUSH
15849: LD_INT 80
15851: PUSH
15852: LD_INT 65
15854: PUSH
15855: LD_INT 100
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: LIST
15862: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
15863: LD_VAR 0 6
15867: PPUSH
15868: CALL_OW 263
15872: PUSH
15873: LD_INT 1
15875: EQUAL
15876: IFFALSE 15911
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
15878: LD_ADDR_VAR 0 10
15882: PUSH
15883: LD_VAR 0 10
15887: PUSH
15888: LD_VAR 0 6
15892: PPUSH
15893: CALL_OW 311
15897: PPUSH
15898: LD_INT 3
15900: PPUSH
15901: CALL_OW 259
15905: PUSH
15906: LD_INT 4
15908: MUL
15909: MUL
15910: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
15911: LD_VAR 0 6
15915: PPUSH
15916: CALL_OW 263
15920: PUSH
15921: LD_INT 2
15923: EQUAL
15924: IFFALSE 15975
// begin j := IsControledBy ( i ) ;
15926: LD_ADDR_VAR 0 7
15930: PUSH
15931: LD_VAR 0 6
15935: PPUSH
15936: CALL_OW 312
15940: ST_TO_ADDR
// if j then
15941: LD_VAR 0 7
15945: IFFALSE 15975
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
15947: LD_ADDR_VAR 0 10
15951: PUSH
15952: LD_VAR 0 10
15956: PUSH
15957: LD_VAR 0 7
15961: PPUSH
15962: LD_INT 3
15964: PPUSH
15965: CALL_OW 259
15969: PUSH
15970: LD_INT 3
15972: MUL
15973: MUL
15974: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
15975: LD_VAR 0 6
15979: PPUSH
15980: CALL_OW 264
15984: PUSH
15985: LD_INT 5
15987: PUSH
15988: LD_INT 6
15990: PUSH
15991: LD_INT 46
15993: PUSH
15994: LD_INT 44
15996: PUSH
15997: LD_INT 47
15999: PUSH
16000: LD_INT 45
16002: PUSH
16003: LD_INT 28
16005: PUSH
16006: LD_INT 7
16008: PUSH
16009: LD_INT 27
16011: PUSH
16012: LD_INT 29
16014: PUSH
16015: EMPTY
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: IN
16027: PUSH
16028: LD_VAR 0 1
16032: PPUSH
16033: LD_INT 52
16035: PPUSH
16036: CALL_OW 321
16040: PUSH
16041: LD_INT 2
16043: EQUAL
16044: AND
16045: IFFALSE 16062
// bpoints := bpoints * 1.2 ;
16047: LD_ADDR_VAR 0 10
16051: PUSH
16052: LD_VAR 0 10
16056: PUSH
16057: LD_REAL  1.20000000000000E+0000
16060: MUL
16061: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
16062: LD_VAR 0 6
16066: PPUSH
16067: CALL_OW 264
16071: PUSH
16072: LD_INT 6
16074: PUSH
16075: LD_INT 46
16077: PUSH
16078: LD_INT 47
16080: PUSH
16081: EMPTY
16082: LIST
16083: LIST
16084: LIST
16085: IN
16086: IFFALSE 16103
// bpoints := bpoints * 1.2 ;
16088: LD_ADDR_VAR 0 10
16092: PUSH
16093: LD_VAR 0 10
16097: PUSH
16098: LD_REAL  1.20000000000000E+0000
16101: MUL
16102: ST_TO_ADDR
// end ; unit_building :
16103: GO 16117
16105: LD_INT 3
16107: DOUBLE
16108: EQUAL
16109: IFTRUE 16113
16111: GO 16116
16113: POP
// ; end ;
16114: GO 16117
16116: POP
// for j = 1 to 3 do
16117: LD_ADDR_VAR 0 7
16121: PUSH
16122: DOUBLE
16123: LD_INT 1
16125: DEC
16126: ST_TO_ADDR
16127: LD_INT 3
16129: PUSH
16130: FOR_TO
16131: IFFALSE 16184
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
16133: LD_ADDR_VAR 0 5
16137: PUSH
16138: LD_VAR 0 5
16142: PPUSH
16143: LD_VAR 0 7
16147: PPUSH
16148: LD_VAR 0 5
16152: PUSH
16153: LD_VAR 0 7
16157: ARRAY
16158: PUSH
16159: LD_VAR 0 9
16163: PUSH
16164: LD_VAR 0 7
16168: ARRAY
16169: PUSH
16170: LD_VAR 0 10
16174: MUL
16175: PLUS
16176: PPUSH
16177: CALL_OW 1
16181: ST_TO_ADDR
16182: GO 16130
16184: POP
16185: POP
// end ;
16186: GO 14663
16188: POP
16189: POP
// result := Replace ( result , 4 , tmp ) ;
16190: LD_ADDR_VAR 0 5
16194: PUSH
16195: LD_VAR 0 5
16199: PPUSH
16200: LD_INT 4
16202: PPUSH
16203: LD_VAR 0 8
16207: PPUSH
16208: CALL_OW 1
16212: ST_TO_ADDR
// end ;
16213: LD_VAR 0 5
16217: RET
// export function DangerAtRange ( unit , range ) ; begin
16218: LD_INT 0
16220: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
16221: LD_ADDR_VAR 0 3
16225: PUSH
16226: LD_VAR 0 1
16230: PPUSH
16231: CALL_OW 255
16235: PPUSH
16236: LD_VAR 0 1
16240: PPUSH
16241: CALL_OW 250
16245: PPUSH
16246: LD_VAR 0 1
16250: PPUSH
16251: CALL_OW 251
16255: PPUSH
16256: LD_VAR 0 2
16260: PPUSH
16261: CALL 14515 0 4
16265: ST_TO_ADDR
// end ;
16266: LD_VAR 0 3
16270: RET
// export function DangerInArea ( side , area ) ; begin
16271: LD_INT 0
16273: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
16274: LD_ADDR_VAR 0 3
16278: PUSH
16279: LD_VAR 0 2
16283: PPUSH
16284: LD_INT 81
16286: PUSH
16287: LD_VAR 0 1
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: PPUSH
16296: CALL_OW 70
16300: ST_TO_ADDR
// end ;
16301: LD_VAR 0 3
16305: RET
// export function IsExtension ( b ) ; begin
16306: LD_INT 0
16308: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
16309: LD_ADDR_VAR 0 2
16313: PUSH
16314: LD_VAR 0 1
16318: PUSH
16319: LD_INT 23
16321: PUSH
16322: LD_INT 20
16324: PUSH
16325: LD_INT 22
16327: PUSH
16328: LD_INT 17
16330: PUSH
16331: LD_INT 24
16333: PUSH
16334: LD_INT 21
16336: PUSH
16337: LD_INT 19
16339: PUSH
16340: LD_INT 16
16342: PUSH
16343: LD_INT 25
16345: PUSH
16346: LD_INT 18
16348: PUSH
16349: EMPTY
16350: LIST
16351: LIST
16352: LIST
16353: LIST
16354: LIST
16355: LIST
16356: LIST
16357: LIST
16358: LIST
16359: LIST
16360: IN
16361: ST_TO_ADDR
// end ;
16362: LD_VAR 0 2
16366: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
16367: LD_INT 0
16369: PPUSH
16370: PPUSH
16371: PPUSH
// result := [ ] ;
16372: LD_ADDR_VAR 0 4
16376: PUSH
16377: EMPTY
16378: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
16379: LD_ADDR_VAR 0 5
16383: PUSH
16384: LD_VAR 0 2
16388: PPUSH
16389: LD_INT 21
16391: PUSH
16392: LD_INT 3
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PPUSH
16399: CALL_OW 70
16403: ST_TO_ADDR
// if not tmp then
16404: LD_VAR 0 5
16408: NOT
16409: IFFALSE 16413
// exit ;
16411: GO 16477
// if checkLink then
16413: LD_VAR 0 3
16417: IFFALSE 16467
// begin for i in tmp do
16419: LD_ADDR_VAR 0 6
16423: PUSH
16424: LD_VAR 0 5
16428: PUSH
16429: FOR_IN
16430: IFFALSE 16465
// if GetBase ( i ) <> base then
16432: LD_VAR 0 6
16436: PPUSH
16437: CALL_OW 274
16441: PUSH
16442: LD_VAR 0 1
16446: NONEQUAL
16447: IFFALSE 16463
// ComLinkToBase ( base , i ) ;
16449: LD_VAR 0 1
16453: PPUSH
16454: LD_VAR 0 6
16458: PPUSH
16459: CALL_OW 169
16463: GO 16429
16465: POP
16466: POP
// end ; result := tmp ;
16467: LD_ADDR_VAR 0 4
16471: PUSH
16472: LD_VAR 0 5
16476: ST_TO_ADDR
// end ;
16477: LD_VAR 0 4
16481: RET
// export function ComComplete ( units , b ) ; var i ; begin
16482: LD_INT 0
16484: PPUSH
16485: PPUSH
// if not units then
16486: LD_VAR 0 1
16490: NOT
16491: IFFALSE 16495
// exit ;
16493: GO 16585
// for i in units do
16495: LD_ADDR_VAR 0 4
16499: PUSH
16500: LD_VAR 0 1
16504: PUSH
16505: FOR_IN
16506: IFFALSE 16583
// if BuildingStatus ( b ) = bs_build then
16508: LD_VAR 0 2
16512: PPUSH
16513: CALL_OW 461
16517: PUSH
16518: LD_INT 1
16520: EQUAL
16521: IFFALSE 16581
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
16523: LD_VAR 0 4
16527: PPUSH
16528: LD_STRING h
16530: PUSH
16531: LD_VAR 0 2
16535: PPUSH
16536: CALL_OW 250
16540: PUSH
16541: LD_VAR 0 2
16545: PPUSH
16546: CALL_OW 251
16550: PUSH
16551: LD_VAR 0 2
16555: PUSH
16556: LD_INT 0
16558: PUSH
16559: LD_INT 0
16561: PUSH
16562: LD_INT 0
16564: PUSH
16565: EMPTY
16566: LIST
16567: LIST
16568: LIST
16569: LIST
16570: LIST
16571: LIST
16572: LIST
16573: PUSH
16574: EMPTY
16575: LIST
16576: PPUSH
16577: CALL_OW 446
16581: GO 16505
16583: POP
16584: POP
// end ;
16585: LD_VAR 0 3
16589: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
16590: LD_INT 0
16592: PPUSH
16593: PPUSH
16594: PPUSH
16595: PPUSH
16596: PPUSH
16597: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
16598: LD_VAR 0 1
16602: NOT
16603: PUSH
16604: LD_VAR 0 1
16608: PPUSH
16609: CALL_OW 263
16613: PUSH
16614: LD_INT 2
16616: EQUAL
16617: NOT
16618: OR
16619: IFFALSE 16623
// exit ;
16621: GO 16939
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
16623: LD_ADDR_VAR 0 6
16627: PUSH
16628: LD_INT 22
16630: PUSH
16631: LD_VAR 0 1
16635: PPUSH
16636: CALL_OW 255
16640: PUSH
16641: EMPTY
16642: LIST
16643: LIST
16644: PUSH
16645: LD_INT 2
16647: PUSH
16648: LD_INT 30
16650: PUSH
16651: LD_INT 36
16653: PUSH
16654: EMPTY
16655: LIST
16656: LIST
16657: PUSH
16658: LD_INT 34
16660: PUSH
16661: LD_INT 31
16663: PUSH
16664: EMPTY
16665: LIST
16666: LIST
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: LIST
16672: PUSH
16673: EMPTY
16674: LIST
16675: LIST
16676: PPUSH
16677: CALL_OW 69
16681: ST_TO_ADDR
// if not tmp then
16682: LD_VAR 0 6
16686: NOT
16687: IFFALSE 16691
// exit ;
16689: GO 16939
// result := [ ] ;
16691: LD_ADDR_VAR 0 2
16695: PUSH
16696: EMPTY
16697: ST_TO_ADDR
// for i in tmp do
16698: LD_ADDR_VAR 0 3
16702: PUSH
16703: LD_VAR 0 6
16707: PUSH
16708: FOR_IN
16709: IFFALSE 16780
// begin t := UnitsInside ( i ) ;
16711: LD_ADDR_VAR 0 4
16715: PUSH
16716: LD_VAR 0 3
16720: PPUSH
16721: CALL_OW 313
16725: ST_TO_ADDR
// if t then
16726: LD_VAR 0 4
16730: IFFALSE 16778
// for j in t do
16732: LD_ADDR_VAR 0 7
16736: PUSH
16737: LD_VAR 0 4
16741: PUSH
16742: FOR_IN
16743: IFFALSE 16776
// result := Insert ( result , result + 1 , j ) ;
16745: LD_ADDR_VAR 0 2
16749: PUSH
16750: LD_VAR 0 2
16754: PPUSH
16755: LD_VAR 0 2
16759: PUSH
16760: LD_INT 1
16762: PLUS
16763: PPUSH
16764: LD_VAR 0 7
16768: PPUSH
16769: CALL_OW 2
16773: ST_TO_ADDR
16774: GO 16742
16776: POP
16777: POP
// end ;
16778: GO 16708
16780: POP
16781: POP
// if not result then
16782: LD_VAR 0 2
16786: NOT
16787: IFFALSE 16791
// exit ;
16789: GO 16939
// mech := result [ 1 ] ;
16791: LD_ADDR_VAR 0 5
16795: PUSH
16796: LD_VAR 0 2
16800: PUSH
16801: LD_INT 1
16803: ARRAY
16804: ST_TO_ADDR
// if result > 1 then
16805: LD_VAR 0 2
16809: PUSH
16810: LD_INT 1
16812: GREATER
16813: IFFALSE 16925
// for i = 2 to result do
16815: LD_ADDR_VAR 0 3
16819: PUSH
16820: DOUBLE
16821: LD_INT 2
16823: DEC
16824: ST_TO_ADDR
16825: LD_VAR 0 2
16829: PUSH
16830: FOR_TO
16831: IFFALSE 16923
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
16833: LD_ADDR_VAR 0 4
16837: PUSH
16838: LD_VAR 0 2
16842: PUSH
16843: LD_VAR 0 3
16847: ARRAY
16848: PPUSH
16849: LD_INT 3
16851: PPUSH
16852: CALL_OW 259
16856: PUSH
16857: LD_VAR 0 2
16861: PUSH
16862: LD_VAR 0 3
16866: ARRAY
16867: PPUSH
16868: CALL_OW 432
16872: MINUS
16873: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
16874: LD_VAR 0 4
16878: PUSH
16879: LD_VAR 0 5
16883: PPUSH
16884: LD_INT 3
16886: PPUSH
16887: CALL_OW 259
16891: PUSH
16892: LD_VAR 0 5
16896: PPUSH
16897: CALL_OW 432
16901: MINUS
16902: GREATEREQUAL
16903: IFFALSE 16921
// mech := result [ i ] ;
16905: LD_ADDR_VAR 0 5
16909: PUSH
16910: LD_VAR 0 2
16914: PUSH
16915: LD_VAR 0 3
16919: ARRAY
16920: ST_TO_ADDR
// end ;
16921: GO 16830
16923: POP
16924: POP
// ComLinkTo ( vehicle , mech ) ;
16925: LD_VAR 0 1
16929: PPUSH
16930: LD_VAR 0 5
16934: PPUSH
16935: CALL_OW 135
// end ;
16939: LD_VAR 0 2
16943: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
16944: LD_INT 0
16946: PPUSH
16947: PPUSH
16948: PPUSH
16949: PPUSH
16950: PPUSH
16951: PPUSH
16952: PPUSH
16953: PPUSH
16954: PPUSH
16955: PPUSH
16956: PPUSH
16957: PPUSH
16958: PPUSH
// result := [ ] ;
16959: LD_ADDR_VAR 0 7
16963: PUSH
16964: EMPTY
16965: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
16966: LD_VAR 0 1
16970: PPUSH
16971: CALL_OW 266
16975: PUSH
16976: LD_INT 0
16978: PUSH
16979: LD_INT 1
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: IN
16986: NOT
16987: IFFALSE 16991
// exit ;
16989: GO 18625
// if name then
16991: LD_VAR 0 3
16995: IFFALSE 17011
// SetBName ( base_dep , name ) ;
16997: LD_VAR 0 1
17001: PPUSH
17002: LD_VAR 0 3
17006: PPUSH
17007: CALL_OW 500
// base := GetBase ( base_dep ) ;
17011: LD_ADDR_VAR 0 15
17015: PUSH
17016: LD_VAR 0 1
17020: PPUSH
17021: CALL_OW 274
17025: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
17026: LD_ADDR_VAR 0 16
17030: PUSH
17031: LD_VAR 0 1
17035: PPUSH
17036: CALL_OW 255
17040: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
17041: LD_ADDR_VAR 0 17
17045: PUSH
17046: LD_VAR 0 1
17050: PPUSH
17051: CALL_OW 248
17055: ST_TO_ADDR
// if sources then
17056: LD_VAR 0 5
17060: IFFALSE 17107
// for i = 1 to 3 do
17062: LD_ADDR_VAR 0 8
17066: PUSH
17067: DOUBLE
17068: LD_INT 1
17070: DEC
17071: ST_TO_ADDR
17072: LD_INT 3
17074: PUSH
17075: FOR_TO
17076: IFFALSE 17105
// AddResourceType ( base , i , sources [ i ] ) ;
17078: LD_VAR 0 15
17082: PPUSH
17083: LD_VAR 0 8
17087: PPUSH
17088: LD_VAR 0 5
17092: PUSH
17093: LD_VAR 0 8
17097: ARRAY
17098: PPUSH
17099: CALL_OW 276
17103: GO 17075
17105: POP
17106: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
17107: LD_ADDR_VAR 0 18
17111: PUSH
17112: LD_VAR 0 15
17116: PPUSH
17117: LD_VAR 0 2
17121: PPUSH
17122: LD_INT 1
17124: PPUSH
17125: CALL 16367 0 3
17129: ST_TO_ADDR
// InitHc ;
17130: CALL_OW 19
// InitUc ;
17134: CALL_OW 18
// uc_side := side ;
17138: LD_ADDR_OWVAR 20
17142: PUSH
17143: LD_VAR 0 16
17147: ST_TO_ADDR
// uc_nation := nation ;
17148: LD_ADDR_OWVAR 21
17152: PUSH
17153: LD_VAR 0 17
17157: ST_TO_ADDR
// if buildings then
17158: LD_VAR 0 18
17162: IFFALSE 18484
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
17164: LD_ADDR_VAR 0 19
17168: PUSH
17169: LD_VAR 0 18
17173: PPUSH
17174: LD_INT 2
17176: PUSH
17177: LD_INT 30
17179: PUSH
17180: LD_INT 29
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PUSH
17187: LD_INT 30
17189: PUSH
17190: LD_INT 30
17192: PUSH
17193: EMPTY
17194: LIST
17195: LIST
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: LIST
17201: PPUSH
17202: CALL_OW 72
17206: ST_TO_ADDR
// if tmp then
17207: LD_VAR 0 19
17211: IFFALSE 17259
// for i in tmp do
17213: LD_ADDR_VAR 0 8
17217: PUSH
17218: LD_VAR 0 19
17222: PUSH
17223: FOR_IN
17224: IFFALSE 17257
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
17226: LD_VAR 0 8
17230: PPUSH
17231: CALL_OW 250
17235: PPUSH
17236: LD_VAR 0 8
17240: PPUSH
17241: CALL_OW 251
17245: PPUSH
17246: LD_VAR 0 16
17250: PPUSH
17251: CALL_OW 441
17255: GO 17223
17257: POP
17258: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
17259: LD_VAR 0 18
17263: PPUSH
17264: LD_INT 2
17266: PUSH
17267: LD_INT 30
17269: PUSH
17270: LD_INT 32
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PUSH
17277: LD_INT 30
17279: PUSH
17280: LD_INT 33
17282: PUSH
17283: EMPTY
17284: LIST
17285: LIST
17286: PUSH
17287: EMPTY
17288: LIST
17289: LIST
17290: LIST
17291: PPUSH
17292: CALL_OW 72
17296: IFFALSE 17384
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
17298: LD_ADDR_VAR 0 8
17302: PUSH
17303: LD_VAR 0 18
17307: PPUSH
17308: LD_INT 2
17310: PUSH
17311: LD_INT 30
17313: PUSH
17314: LD_INT 32
17316: PUSH
17317: EMPTY
17318: LIST
17319: LIST
17320: PUSH
17321: LD_INT 30
17323: PUSH
17324: LD_INT 33
17326: PUSH
17327: EMPTY
17328: LIST
17329: LIST
17330: PUSH
17331: EMPTY
17332: LIST
17333: LIST
17334: LIST
17335: PPUSH
17336: CALL_OW 72
17340: PUSH
17341: FOR_IN
17342: IFFALSE 17382
// begin if not GetBWeapon ( i ) then
17344: LD_VAR 0 8
17348: PPUSH
17349: CALL_OW 269
17353: NOT
17354: IFFALSE 17380
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
17356: LD_VAR 0 8
17360: PPUSH
17361: LD_VAR 0 8
17365: PPUSH
17366: LD_VAR 0 2
17370: PPUSH
17371: CALL 18630 0 2
17375: PPUSH
17376: CALL_OW 431
// end ;
17380: GO 17341
17382: POP
17383: POP
// end ; for i = 1 to personel do
17384: LD_ADDR_VAR 0 8
17388: PUSH
17389: DOUBLE
17390: LD_INT 1
17392: DEC
17393: ST_TO_ADDR
17394: LD_VAR 0 6
17398: PUSH
17399: FOR_TO
17400: IFFALSE 18464
// begin if i > 4 then
17402: LD_VAR 0 8
17406: PUSH
17407: LD_INT 4
17409: GREATER
17410: IFFALSE 17414
// break ;
17412: GO 18464
// case i of 1 :
17414: LD_VAR 0 8
17418: PUSH
17419: LD_INT 1
17421: DOUBLE
17422: EQUAL
17423: IFTRUE 17427
17425: GO 17507
17427: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
17428: LD_ADDR_VAR 0 12
17432: PUSH
17433: LD_VAR 0 18
17437: PPUSH
17438: LD_INT 22
17440: PUSH
17441: LD_VAR 0 16
17445: PUSH
17446: EMPTY
17447: LIST
17448: LIST
17449: PUSH
17450: LD_INT 58
17452: PUSH
17453: EMPTY
17454: LIST
17455: PUSH
17456: LD_INT 2
17458: PUSH
17459: LD_INT 30
17461: PUSH
17462: LD_INT 32
17464: PUSH
17465: EMPTY
17466: LIST
17467: LIST
17468: PUSH
17469: LD_INT 30
17471: PUSH
17472: LD_INT 4
17474: PUSH
17475: EMPTY
17476: LIST
17477: LIST
17478: PUSH
17479: LD_INT 30
17481: PUSH
17482: LD_INT 5
17484: PUSH
17485: EMPTY
17486: LIST
17487: LIST
17488: PUSH
17489: EMPTY
17490: LIST
17491: LIST
17492: LIST
17493: LIST
17494: PUSH
17495: EMPTY
17496: LIST
17497: LIST
17498: LIST
17499: PPUSH
17500: CALL_OW 72
17504: ST_TO_ADDR
17505: GO 17729
17507: LD_INT 2
17509: DOUBLE
17510: EQUAL
17511: IFTRUE 17515
17513: GO 17577
17515: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
17516: LD_ADDR_VAR 0 12
17520: PUSH
17521: LD_VAR 0 18
17525: PPUSH
17526: LD_INT 22
17528: PUSH
17529: LD_VAR 0 16
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: PUSH
17538: LD_INT 2
17540: PUSH
17541: LD_INT 30
17543: PUSH
17544: LD_INT 0
17546: PUSH
17547: EMPTY
17548: LIST
17549: LIST
17550: PUSH
17551: LD_INT 30
17553: PUSH
17554: LD_INT 1
17556: PUSH
17557: EMPTY
17558: LIST
17559: LIST
17560: PUSH
17561: EMPTY
17562: LIST
17563: LIST
17564: LIST
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PPUSH
17570: CALL_OW 72
17574: ST_TO_ADDR
17575: GO 17729
17577: LD_INT 3
17579: DOUBLE
17580: EQUAL
17581: IFTRUE 17585
17583: GO 17647
17585: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
17586: LD_ADDR_VAR 0 12
17590: PUSH
17591: LD_VAR 0 18
17595: PPUSH
17596: LD_INT 22
17598: PUSH
17599: LD_VAR 0 16
17603: PUSH
17604: EMPTY
17605: LIST
17606: LIST
17607: PUSH
17608: LD_INT 2
17610: PUSH
17611: LD_INT 30
17613: PUSH
17614: LD_INT 2
17616: PUSH
17617: EMPTY
17618: LIST
17619: LIST
17620: PUSH
17621: LD_INT 30
17623: PUSH
17624: LD_INT 3
17626: PUSH
17627: EMPTY
17628: LIST
17629: LIST
17630: PUSH
17631: EMPTY
17632: LIST
17633: LIST
17634: LIST
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PPUSH
17640: CALL_OW 72
17644: ST_TO_ADDR
17645: GO 17729
17647: LD_INT 4
17649: DOUBLE
17650: EQUAL
17651: IFTRUE 17655
17653: GO 17728
17655: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
17656: LD_ADDR_VAR 0 12
17660: PUSH
17661: LD_VAR 0 18
17665: PPUSH
17666: LD_INT 22
17668: PUSH
17669: LD_VAR 0 16
17673: PUSH
17674: EMPTY
17675: LIST
17676: LIST
17677: PUSH
17678: LD_INT 2
17680: PUSH
17681: LD_INT 30
17683: PUSH
17684: LD_INT 6
17686: PUSH
17687: EMPTY
17688: LIST
17689: LIST
17690: PUSH
17691: LD_INT 30
17693: PUSH
17694: LD_INT 7
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: PUSH
17701: LD_INT 30
17703: PUSH
17704: LD_INT 8
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: LIST
17715: LIST
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PPUSH
17721: CALL_OW 72
17725: ST_TO_ADDR
17726: GO 17729
17728: POP
// if i = 1 then
17729: LD_VAR 0 8
17733: PUSH
17734: LD_INT 1
17736: EQUAL
17737: IFFALSE 17848
// begin tmp := [ ] ;
17739: LD_ADDR_VAR 0 19
17743: PUSH
17744: EMPTY
17745: ST_TO_ADDR
// for j in f do
17746: LD_ADDR_VAR 0 9
17750: PUSH
17751: LD_VAR 0 12
17755: PUSH
17756: FOR_IN
17757: IFFALSE 17830
// if GetBType ( j ) = b_bunker then
17759: LD_VAR 0 9
17763: PPUSH
17764: CALL_OW 266
17768: PUSH
17769: LD_INT 32
17771: EQUAL
17772: IFFALSE 17799
// tmp := Insert ( tmp , 1 , j ) else
17774: LD_ADDR_VAR 0 19
17778: PUSH
17779: LD_VAR 0 19
17783: PPUSH
17784: LD_INT 1
17786: PPUSH
17787: LD_VAR 0 9
17791: PPUSH
17792: CALL_OW 2
17796: ST_TO_ADDR
17797: GO 17828
// tmp := Insert ( tmp , tmp + 1 , j ) ;
17799: LD_ADDR_VAR 0 19
17803: PUSH
17804: LD_VAR 0 19
17808: PPUSH
17809: LD_VAR 0 19
17813: PUSH
17814: LD_INT 1
17816: PLUS
17817: PPUSH
17818: LD_VAR 0 9
17822: PPUSH
17823: CALL_OW 2
17827: ST_TO_ADDR
17828: GO 17756
17830: POP
17831: POP
// if tmp then
17832: LD_VAR 0 19
17836: IFFALSE 17848
// f := tmp ;
17838: LD_ADDR_VAR 0 12
17842: PUSH
17843: LD_VAR 0 19
17847: ST_TO_ADDR
// end ; x := personel [ i ] ;
17848: LD_ADDR_VAR 0 13
17852: PUSH
17853: LD_VAR 0 6
17857: PUSH
17858: LD_VAR 0 8
17862: ARRAY
17863: ST_TO_ADDR
// if x = - 1 then
17864: LD_VAR 0 13
17868: PUSH
17869: LD_INT 1
17871: NEG
17872: EQUAL
17873: IFFALSE 18082
// begin for j in f do
17875: LD_ADDR_VAR 0 9
17879: PUSH
17880: LD_VAR 0 12
17884: PUSH
17885: FOR_IN
17886: IFFALSE 18078
// repeat InitHc ;
17888: CALL_OW 19
// if GetBType ( j ) = b_barracks then
17892: LD_VAR 0 9
17896: PPUSH
17897: CALL_OW 266
17901: PUSH
17902: LD_INT 5
17904: EQUAL
17905: IFFALSE 17975
// begin if UnitsInside ( j ) < 3 then
17907: LD_VAR 0 9
17911: PPUSH
17912: CALL_OW 313
17916: PUSH
17917: LD_INT 3
17919: LESS
17920: IFFALSE 17956
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
17922: LD_INT 0
17924: PPUSH
17925: LD_INT 5
17927: PUSH
17928: LD_INT 8
17930: PUSH
17931: LD_INT 9
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: LIST
17938: PUSH
17939: LD_VAR 0 17
17943: ARRAY
17944: PPUSH
17945: LD_VAR 0 4
17949: PPUSH
17950: CALL_OW 380
17954: GO 17973
// PrepareHuman ( false , i , skill ) ;
17956: LD_INT 0
17958: PPUSH
17959: LD_VAR 0 8
17963: PPUSH
17964: LD_VAR 0 4
17968: PPUSH
17969: CALL_OW 380
// end else
17973: GO 17992
// PrepareHuman ( false , i , skill ) ;
17975: LD_INT 0
17977: PPUSH
17978: LD_VAR 0 8
17982: PPUSH
17983: LD_VAR 0 4
17987: PPUSH
17988: CALL_OW 380
// un := CreateHuman ;
17992: LD_ADDR_VAR 0 14
17996: PUSH
17997: CALL_OW 44
18001: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18002: LD_ADDR_VAR 0 7
18006: PUSH
18007: LD_VAR 0 7
18011: PPUSH
18012: LD_INT 1
18014: PPUSH
18015: LD_VAR 0 14
18019: PPUSH
18020: CALL_OW 2
18024: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
18025: LD_VAR 0 14
18029: PPUSH
18030: LD_VAR 0 9
18034: PPUSH
18035: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
18039: LD_VAR 0 9
18043: PPUSH
18044: CALL_OW 313
18048: PUSH
18049: LD_INT 6
18051: EQUAL
18052: PUSH
18053: LD_VAR 0 9
18057: PPUSH
18058: CALL_OW 266
18062: PUSH
18063: LD_INT 32
18065: PUSH
18066: LD_INT 31
18068: PUSH
18069: EMPTY
18070: LIST
18071: LIST
18072: IN
18073: OR
18074: IFFALSE 17888
18076: GO 17885
18078: POP
18079: POP
// end else
18080: GO 18462
// for j = 1 to x do
18082: LD_ADDR_VAR 0 9
18086: PUSH
18087: DOUBLE
18088: LD_INT 1
18090: DEC
18091: ST_TO_ADDR
18092: LD_VAR 0 13
18096: PUSH
18097: FOR_TO
18098: IFFALSE 18460
// begin InitHc ;
18100: CALL_OW 19
// if not f then
18104: LD_VAR 0 12
18108: NOT
18109: IFFALSE 18198
// begin PrepareHuman ( false , i , skill ) ;
18111: LD_INT 0
18113: PPUSH
18114: LD_VAR 0 8
18118: PPUSH
18119: LD_VAR 0 4
18123: PPUSH
18124: CALL_OW 380
// un := CreateHuman ;
18128: LD_ADDR_VAR 0 14
18132: PUSH
18133: CALL_OW 44
18137: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18138: LD_ADDR_VAR 0 7
18142: PUSH
18143: LD_VAR 0 7
18147: PPUSH
18148: LD_INT 1
18150: PPUSH
18151: LD_VAR 0 14
18155: PPUSH
18156: CALL_OW 2
18160: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18161: LD_VAR 0 14
18165: PPUSH
18166: LD_VAR 0 1
18170: PPUSH
18171: CALL_OW 250
18175: PPUSH
18176: LD_VAR 0 1
18180: PPUSH
18181: CALL_OW 251
18185: PPUSH
18186: LD_INT 10
18188: PPUSH
18189: LD_INT 0
18191: PPUSH
18192: CALL_OW 50
// continue ;
18196: GO 18097
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
18198: LD_VAR 0 12
18202: PUSH
18203: LD_INT 1
18205: ARRAY
18206: PPUSH
18207: CALL_OW 313
18211: PUSH
18212: LD_VAR 0 12
18216: PUSH
18217: LD_INT 1
18219: ARRAY
18220: PPUSH
18221: CALL_OW 266
18225: PUSH
18226: LD_INT 32
18228: PUSH
18229: LD_INT 31
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: IN
18236: AND
18237: PUSH
18238: LD_VAR 0 12
18242: PUSH
18243: LD_INT 1
18245: ARRAY
18246: PPUSH
18247: CALL_OW 313
18251: PUSH
18252: LD_INT 6
18254: EQUAL
18255: OR
18256: IFFALSE 18276
// f := Delete ( f , 1 ) ;
18258: LD_ADDR_VAR 0 12
18262: PUSH
18263: LD_VAR 0 12
18267: PPUSH
18268: LD_INT 1
18270: PPUSH
18271: CALL_OW 3
18275: ST_TO_ADDR
// if not f then
18276: LD_VAR 0 12
18280: NOT
18281: IFFALSE 18299
// begin x := x + 2 ;
18283: LD_ADDR_VAR 0 13
18287: PUSH
18288: LD_VAR 0 13
18292: PUSH
18293: LD_INT 2
18295: PLUS
18296: ST_TO_ADDR
// continue ;
18297: GO 18097
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
18299: LD_VAR 0 12
18303: PUSH
18304: LD_INT 1
18306: ARRAY
18307: PPUSH
18308: CALL_OW 266
18312: PUSH
18313: LD_INT 5
18315: EQUAL
18316: IFFALSE 18390
// begin if UnitsInside ( f [ 1 ] ) < 3 then
18318: LD_VAR 0 12
18322: PUSH
18323: LD_INT 1
18325: ARRAY
18326: PPUSH
18327: CALL_OW 313
18331: PUSH
18332: LD_INT 3
18334: LESS
18335: IFFALSE 18371
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18337: LD_INT 0
18339: PPUSH
18340: LD_INT 5
18342: PUSH
18343: LD_INT 8
18345: PUSH
18346: LD_INT 9
18348: PUSH
18349: EMPTY
18350: LIST
18351: LIST
18352: LIST
18353: PUSH
18354: LD_VAR 0 17
18358: ARRAY
18359: PPUSH
18360: LD_VAR 0 4
18364: PPUSH
18365: CALL_OW 380
18369: GO 18388
// PrepareHuman ( false , i , skill ) ;
18371: LD_INT 0
18373: PPUSH
18374: LD_VAR 0 8
18378: PPUSH
18379: LD_VAR 0 4
18383: PPUSH
18384: CALL_OW 380
// end else
18388: GO 18407
// PrepareHuman ( false , i , skill ) ;
18390: LD_INT 0
18392: PPUSH
18393: LD_VAR 0 8
18397: PPUSH
18398: LD_VAR 0 4
18402: PPUSH
18403: CALL_OW 380
// un := CreateHuman ;
18407: LD_ADDR_VAR 0 14
18411: PUSH
18412: CALL_OW 44
18416: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18417: LD_ADDR_VAR 0 7
18421: PUSH
18422: LD_VAR 0 7
18426: PPUSH
18427: LD_INT 1
18429: PPUSH
18430: LD_VAR 0 14
18434: PPUSH
18435: CALL_OW 2
18439: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
18440: LD_VAR 0 14
18444: PPUSH
18445: LD_VAR 0 12
18449: PUSH
18450: LD_INT 1
18452: ARRAY
18453: PPUSH
18454: CALL_OW 52
// end ;
18458: GO 18097
18460: POP
18461: POP
// end ;
18462: GO 17399
18464: POP
18465: POP
// result := result ^ buildings ;
18466: LD_ADDR_VAR 0 7
18470: PUSH
18471: LD_VAR 0 7
18475: PUSH
18476: LD_VAR 0 18
18480: ADD
18481: ST_TO_ADDR
// end else
18482: GO 18625
// begin for i = 1 to personel do
18484: LD_ADDR_VAR 0 8
18488: PUSH
18489: DOUBLE
18490: LD_INT 1
18492: DEC
18493: ST_TO_ADDR
18494: LD_VAR 0 6
18498: PUSH
18499: FOR_TO
18500: IFFALSE 18623
// begin if i > 4 then
18502: LD_VAR 0 8
18506: PUSH
18507: LD_INT 4
18509: GREATER
18510: IFFALSE 18514
// break ;
18512: GO 18623
// x := personel [ i ] ;
18514: LD_ADDR_VAR 0 13
18518: PUSH
18519: LD_VAR 0 6
18523: PUSH
18524: LD_VAR 0 8
18528: ARRAY
18529: ST_TO_ADDR
// if x = - 1 then
18530: LD_VAR 0 13
18534: PUSH
18535: LD_INT 1
18537: NEG
18538: EQUAL
18539: IFFALSE 18543
// continue ;
18541: GO 18499
// PrepareHuman ( false , i , skill ) ;
18543: LD_INT 0
18545: PPUSH
18546: LD_VAR 0 8
18550: PPUSH
18551: LD_VAR 0 4
18555: PPUSH
18556: CALL_OW 380
// un := CreateHuman ;
18560: LD_ADDR_VAR 0 14
18564: PUSH
18565: CALL_OW 44
18569: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18570: LD_VAR 0 14
18574: PPUSH
18575: LD_VAR 0 1
18579: PPUSH
18580: CALL_OW 250
18584: PPUSH
18585: LD_VAR 0 1
18589: PPUSH
18590: CALL_OW 251
18594: PPUSH
18595: LD_INT 10
18597: PPUSH
18598: LD_INT 0
18600: PPUSH
18601: CALL_OW 50
// result := result ^ un ;
18605: LD_ADDR_VAR 0 7
18609: PUSH
18610: LD_VAR 0 7
18614: PUSH
18615: LD_VAR 0 14
18619: ADD
18620: ST_TO_ADDR
// end ;
18621: GO 18499
18623: POP
18624: POP
// end ; end ;
18625: LD_VAR 0 7
18629: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
18630: LD_INT 0
18632: PPUSH
18633: PPUSH
18634: PPUSH
18635: PPUSH
18636: PPUSH
18637: PPUSH
18638: PPUSH
18639: PPUSH
18640: PPUSH
18641: PPUSH
18642: PPUSH
18643: PPUSH
18644: PPUSH
18645: PPUSH
18646: PPUSH
18647: PPUSH
// result := false ;
18648: LD_ADDR_VAR 0 3
18652: PUSH
18653: LD_INT 0
18655: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
18656: LD_VAR 0 1
18660: NOT
18661: PUSH
18662: LD_VAR 0 1
18666: PPUSH
18667: CALL_OW 266
18671: PUSH
18672: LD_INT 32
18674: PUSH
18675: LD_INT 33
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: IN
18682: NOT
18683: OR
18684: IFFALSE 18688
// exit ;
18686: GO 19797
// nat := GetNation ( tower ) ;
18688: LD_ADDR_VAR 0 12
18692: PUSH
18693: LD_VAR 0 1
18697: PPUSH
18698: CALL_OW 248
18702: ST_TO_ADDR
// side := GetSide ( tower ) ;
18703: LD_ADDR_VAR 0 16
18707: PUSH
18708: LD_VAR 0 1
18712: PPUSH
18713: CALL_OW 255
18717: ST_TO_ADDR
// x := GetX ( tower ) ;
18718: LD_ADDR_VAR 0 10
18722: PUSH
18723: LD_VAR 0 1
18727: PPUSH
18728: CALL_OW 250
18732: ST_TO_ADDR
// y := GetY ( tower ) ;
18733: LD_ADDR_VAR 0 11
18737: PUSH
18738: LD_VAR 0 1
18742: PPUSH
18743: CALL_OW 251
18747: ST_TO_ADDR
// if not x or not y then
18748: LD_VAR 0 10
18752: NOT
18753: PUSH
18754: LD_VAR 0 11
18758: NOT
18759: OR
18760: IFFALSE 18764
// exit ;
18762: GO 19797
// weapon := 0 ;
18764: LD_ADDR_VAR 0 18
18768: PUSH
18769: LD_INT 0
18771: ST_TO_ADDR
// fac_list := [ ] ;
18772: LD_ADDR_VAR 0 17
18776: PUSH
18777: EMPTY
18778: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
18779: LD_ADDR_VAR 0 6
18783: PUSH
18784: LD_VAR 0 1
18788: PPUSH
18789: CALL_OW 274
18793: PPUSH
18794: LD_VAR 0 2
18798: PPUSH
18799: LD_INT 0
18801: PPUSH
18802: CALL 16367 0 3
18806: PPUSH
18807: LD_INT 30
18809: PUSH
18810: LD_INT 3
18812: PUSH
18813: EMPTY
18814: LIST
18815: LIST
18816: PPUSH
18817: CALL_OW 72
18821: ST_TO_ADDR
// if not factories then
18822: LD_VAR 0 6
18826: NOT
18827: IFFALSE 18831
// exit ;
18829: GO 19797
// for i in factories do
18831: LD_ADDR_VAR 0 8
18835: PUSH
18836: LD_VAR 0 6
18840: PUSH
18841: FOR_IN
18842: IFFALSE 18867
// fac_list := fac_list union AvailableWeaponList ( i ) ;
18844: LD_ADDR_VAR 0 17
18848: PUSH
18849: LD_VAR 0 17
18853: PUSH
18854: LD_VAR 0 8
18858: PPUSH
18859: CALL_OW 478
18863: UNION
18864: ST_TO_ADDR
18865: GO 18841
18867: POP
18868: POP
// if not fac_list then
18869: LD_VAR 0 17
18873: NOT
18874: IFFALSE 18878
// exit ;
18876: GO 19797
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
18878: LD_ADDR_VAR 0 5
18882: PUSH
18883: LD_INT 4
18885: PUSH
18886: LD_INT 5
18888: PUSH
18889: LD_INT 9
18891: PUSH
18892: LD_INT 10
18894: PUSH
18895: LD_INT 6
18897: PUSH
18898: LD_INT 7
18900: PUSH
18901: LD_INT 11
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: LIST
18910: LIST
18911: LIST
18912: PUSH
18913: LD_INT 27
18915: PUSH
18916: LD_INT 28
18918: PUSH
18919: LD_INT 26
18921: PUSH
18922: LD_INT 30
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: PUSH
18931: LD_INT 43
18933: PUSH
18934: LD_INT 44
18936: PUSH
18937: LD_INT 46
18939: PUSH
18940: LD_INT 45
18942: PUSH
18943: LD_INT 47
18945: PUSH
18946: LD_INT 49
18948: PUSH
18949: EMPTY
18950: LIST
18951: LIST
18952: LIST
18953: LIST
18954: LIST
18955: LIST
18956: PUSH
18957: EMPTY
18958: LIST
18959: LIST
18960: LIST
18961: PUSH
18962: LD_VAR 0 12
18966: ARRAY
18967: ST_TO_ADDR
// list := list isect fac_list ;
18968: LD_ADDR_VAR 0 5
18972: PUSH
18973: LD_VAR 0 5
18977: PUSH
18978: LD_VAR 0 17
18982: ISECT
18983: ST_TO_ADDR
// if not list then
18984: LD_VAR 0 5
18988: NOT
18989: IFFALSE 18993
// exit ;
18991: GO 19797
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
18993: LD_VAR 0 12
18997: PUSH
18998: LD_INT 3
19000: EQUAL
19001: PUSH
19002: LD_INT 49
19004: PUSH
19005: LD_VAR 0 5
19009: IN
19010: AND
19011: PUSH
19012: LD_INT 31
19014: PPUSH
19015: LD_VAR 0 16
19019: PPUSH
19020: CALL_OW 321
19024: PUSH
19025: LD_INT 2
19027: EQUAL
19028: AND
19029: IFFALSE 19089
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
19031: LD_INT 22
19033: PUSH
19034: LD_VAR 0 16
19038: PUSH
19039: EMPTY
19040: LIST
19041: LIST
19042: PUSH
19043: LD_INT 35
19045: PUSH
19046: LD_INT 49
19048: PUSH
19049: EMPTY
19050: LIST
19051: LIST
19052: PUSH
19053: LD_INT 91
19055: PUSH
19056: LD_VAR 0 1
19060: PUSH
19061: LD_INT 10
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: LIST
19068: PUSH
19069: EMPTY
19070: LIST
19071: LIST
19072: LIST
19073: PPUSH
19074: CALL_OW 69
19078: NOT
19079: IFFALSE 19089
// weapon := ru_time_lapser ;
19081: LD_ADDR_VAR 0 18
19085: PUSH
19086: LD_INT 49
19088: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
19089: LD_VAR 0 12
19093: PUSH
19094: LD_INT 1
19096: PUSH
19097: LD_INT 2
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: IN
19104: PUSH
19105: LD_INT 11
19107: PUSH
19108: LD_VAR 0 5
19112: IN
19113: PUSH
19114: LD_INT 30
19116: PUSH
19117: LD_VAR 0 5
19121: IN
19122: OR
19123: AND
19124: PUSH
19125: LD_INT 6
19127: PPUSH
19128: LD_VAR 0 16
19132: PPUSH
19133: CALL_OW 321
19137: PUSH
19138: LD_INT 2
19140: EQUAL
19141: AND
19142: IFFALSE 19307
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
19144: LD_INT 22
19146: PUSH
19147: LD_VAR 0 16
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: PUSH
19156: LD_INT 2
19158: PUSH
19159: LD_INT 35
19161: PUSH
19162: LD_INT 11
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: PUSH
19169: LD_INT 35
19171: PUSH
19172: LD_INT 30
19174: PUSH
19175: EMPTY
19176: LIST
19177: LIST
19178: PUSH
19179: EMPTY
19180: LIST
19181: LIST
19182: LIST
19183: PUSH
19184: LD_INT 91
19186: PUSH
19187: LD_VAR 0 1
19191: PUSH
19192: LD_INT 18
19194: PUSH
19195: EMPTY
19196: LIST
19197: LIST
19198: LIST
19199: PUSH
19200: EMPTY
19201: LIST
19202: LIST
19203: LIST
19204: PPUSH
19205: CALL_OW 69
19209: NOT
19210: PUSH
19211: LD_INT 22
19213: PUSH
19214: LD_VAR 0 16
19218: PUSH
19219: EMPTY
19220: LIST
19221: LIST
19222: PUSH
19223: LD_INT 2
19225: PUSH
19226: LD_INT 30
19228: PUSH
19229: LD_INT 32
19231: PUSH
19232: EMPTY
19233: LIST
19234: LIST
19235: PUSH
19236: LD_INT 30
19238: PUSH
19239: LD_INT 33
19241: PUSH
19242: EMPTY
19243: LIST
19244: LIST
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: LIST
19250: PUSH
19251: LD_INT 91
19253: PUSH
19254: LD_VAR 0 1
19258: PUSH
19259: LD_INT 12
19261: PUSH
19262: EMPTY
19263: LIST
19264: LIST
19265: LIST
19266: PUSH
19267: EMPTY
19268: LIST
19269: LIST
19270: LIST
19271: PUSH
19272: EMPTY
19273: LIST
19274: PPUSH
19275: CALL_OW 69
19279: PUSH
19280: LD_INT 2
19282: GREATER
19283: AND
19284: IFFALSE 19307
// weapon := [ us_radar , ar_radar ] [ nat ] ;
19286: LD_ADDR_VAR 0 18
19290: PUSH
19291: LD_INT 11
19293: PUSH
19294: LD_INT 30
19296: PUSH
19297: EMPTY
19298: LIST
19299: LIST
19300: PUSH
19301: LD_VAR 0 12
19305: ARRAY
19306: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
19307: LD_VAR 0 18
19311: NOT
19312: PUSH
19313: LD_INT 40
19315: PPUSH
19316: LD_VAR 0 16
19320: PPUSH
19321: CALL_OW 321
19325: PUSH
19326: LD_INT 2
19328: EQUAL
19329: AND
19330: PUSH
19331: LD_INT 7
19333: PUSH
19334: LD_VAR 0 5
19338: IN
19339: PUSH
19340: LD_INT 28
19342: PUSH
19343: LD_VAR 0 5
19347: IN
19348: OR
19349: PUSH
19350: LD_INT 45
19352: PUSH
19353: LD_VAR 0 5
19357: IN
19358: OR
19359: AND
19360: IFFALSE 19614
// begin hex := GetHexInfo ( x , y ) ;
19362: LD_ADDR_VAR 0 4
19366: PUSH
19367: LD_VAR 0 10
19371: PPUSH
19372: LD_VAR 0 11
19376: PPUSH
19377: CALL_OW 546
19381: ST_TO_ADDR
// if hex [ 1 ] then
19382: LD_VAR 0 4
19386: PUSH
19387: LD_INT 1
19389: ARRAY
19390: IFFALSE 19394
// exit ;
19392: GO 19797
// height := hex [ 2 ] ;
19394: LD_ADDR_VAR 0 15
19398: PUSH
19399: LD_VAR 0 4
19403: PUSH
19404: LD_INT 2
19406: ARRAY
19407: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
19408: LD_ADDR_VAR 0 14
19412: PUSH
19413: LD_INT 0
19415: PUSH
19416: LD_INT 2
19418: PUSH
19419: LD_INT 3
19421: PUSH
19422: LD_INT 5
19424: PUSH
19425: EMPTY
19426: LIST
19427: LIST
19428: LIST
19429: LIST
19430: ST_TO_ADDR
// for i in tmp do
19431: LD_ADDR_VAR 0 8
19435: PUSH
19436: LD_VAR 0 14
19440: PUSH
19441: FOR_IN
19442: IFFALSE 19612
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
19444: LD_ADDR_VAR 0 9
19448: PUSH
19449: LD_VAR 0 10
19453: PPUSH
19454: LD_VAR 0 8
19458: PPUSH
19459: LD_INT 5
19461: PPUSH
19462: CALL_OW 272
19466: PUSH
19467: LD_VAR 0 11
19471: PPUSH
19472: LD_VAR 0 8
19476: PPUSH
19477: LD_INT 5
19479: PPUSH
19480: CALL_OW 273
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
19489: LD_VAR 0 9
19493: PUSH
19494: LD_INT 1
19496: ARRAY
19497: PPUSH
19498: LD_VAR 0 9
19502: PUSH
19503: LD_INT 2
19505: ARRAY
19506: PPUSH
19507: CALL_OW 488
19511: IFFALSE 19610
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
19513: LD_ADDR_VAR 0 4
19517: PUSH
19518: LD_VAR 0 9
19522: PUSH
19523: LD_INT 1
19525: ARRAY
19526: PPUSH
19527: LD_VAR 0 9
19531: PUSH
19532: LD_INT 2
19534: ARRAY
19535: PPUSH
19536: CALL_OW 546
19540: ST_TO_ADDR
// if hex [ 1 ] then
19541: LD_VAR 0 4
19545: PUSH
19546: LD_INT 1
19548: ARRAY
19549: IFFALSE 19553
// continue ;
19551: GO 19441
// h := hex [ 2 ] ;
19553: LD_ADDR_VAR 0 13
19557: PUSH
19558: LD_VAR 0 4
19562: PUSH
19563: LD_INT 2
19565: ARRAY
19566: ST_TO_ADDR
// if h + 7 < height then
19567: LD_VAR 0 13
19571: PUSH
19572: LD_INT 7
19574: PLUS
19575: PUSH
19576: LD_VAR 0 15
19580: LESS
19581: IFFALSE 19610
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
19583: LD_ADDR_VAR 0 18
19587: PUSH
19588: LD_INT 7
19590: PUSH
19591: LD_INT 28
19593: PUSH
19594: LD_INT 45
19596: PUSH
19597: EMPTY
19598: LIST
19599: LIST
19600: LIST
19601: PUSH
19602: LD_VAR 0 12
19606: ARRAY
19607: ST_TO_ADDR
// break ;
19608: GO 19612
// end ; end ; end ;
19610: GO 19441
19612: POP
19613: POP
// end ; if not weapon then
19614: LD_VAR 0 18
19618: NOT
19619: IFFALSE 19679
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
19621: LD_ADDR_VAR 0 5
19625: PUSH
19626: LD_VAR 0 5
19630: PUSH
19631: LD_INT 11
19633: PUSH
19634: LD_INT 30
19636: PUSH
19637: LD_INT 49
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: LIST
19644: DIFF
19645: ST_TO_ADDR
// if not list then
19646: LD_VAR 0 5
19650: NOT
19651: IFFALSE 19655
// exit ;
19653: GO 19797
// weapon := list [ rand ( 1 , list ) ] ;
19655: LD_ADDR_VAR 0 18
19659: PUSH
19660: LD_VAR 0 5
19664: PUSH
19665: LD_INT 1
19667: PPUSH
19668: LD_VAR 0 5
19672: PPUSH
19673: CALL_OW 12
19677: ARRAY
19678: ST_TO_ADDR
// end ; if weapon then
19679: LD_VAR 0 18
19683: IFFALSE 19797
// begin tmp := CostOfWeapon ( weapon ) ;
19685: LD_ADDR_VAR 0 14
19689: PUSH
19690: LD_VAR 0 18
19694: PPUSH
19695: CALL_OW 451
19699: ST_TO_ADDR
// j := GetBase ( tower ) ;
19700: LD_ADDR_VAR 0 9
19704: PUSH
19705: LD_VAR 0 1
19709: PPUSH
19710: CALL_OW 274
19714: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
19715: LD_VAR 0 9
19719: PPUSH
19720: LD_INT 1
19722: PPUSH
19723: CALL_OW 275
19727: PUSH
19728: LD_VAR 0 14
19732: PUSH
19733: LD_INT 1
19735: ARRAY
19736: GREATEREQUAL
19737: PUSH
19738: LD_VAR 0 9
19742: PPUSH
19743: LD_INT 2
19745: PPUSH
19746: CALL_OW 275
19750: PUSH
19751: LD_VAR 0 14
19755: PUSH
19756: LD_INT 2
19758: ARRAY
19759: GREATEREQUAL
19760: AND
19761: PUSH
19762: LD_VAR 0 9
19766: PPUSH
19767: LD_INT 3
19769: PPUSH
19770: CALL_OW 275
19774: PUSH
19775: LD_VAR 0 14
19779: PUSH
19780: LD_INT 3
19782: ARRAY
19783: GREATEREQUAL
19784: AND
19785: IFFALSE 19797
// result := weapon ;
19787: LD_ADDR_VAR 0 3
19791: PUSH
19792: LD_VAR 0 18
19796: ST_TO_ADDR
// end ; end ;
19797: LD_VAR 0 3
19801: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
19802: LD_INT 0
19804: PPUSH
19805: PPUSH
// result := true ;
19806: LD_ADDR_VAR 0 3
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// if array1 = array2 then
19814: LD_VAR 0 1
19818: PUSH
19819: LD_VAR 0 2
19823: EQUAL
19824: IFFALSE 19884
// begin for i = 1 to array1 do
19826: LD_ADDR_VAR 0 4
19830: PUSH
19831: DOUBLE
19832: LD_INT 1
19834: DEC
19835: ST_TO_ADDR
19836: LD_VAR 0 1
19840: PUSH
19841: FOR_TO
19842: IFFALSE 19880
// if array1 [ i ] <> array2 [ i ] then
19844: LD_VAR 0 1
19848: PUSH
19849: LD_VAR 0 4
19853: ARRAY
19854: PUSH
19855: LD_VAR 0 2
19859: PUSH
19860: LD_VAR 0 4
19864: ARRAY
19865: NONEQUAL
19866: IFFALSE 19878
// begin result := false ;
19868: LD_ADDR_VAR 0 3
19872: PUSH
19873: LD_INT 0
19875: ST_TO_ADDR
// break ;
19876: GO 19880
// end ;
19878: GO 19841
19880: POP
19881: POP
// end else
19882: GO 19892
// result := false ;
19884: LD_ADDR_VAR 0 3
19888: PUSH
19889: LD_INT 0
19891: ST_TO_ADDR
// end ;
19892: LD_VAR 0 3
19896: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
19897: LD_INT 0
19899: PPUSH
19900: PPUSH
// if not array1 or not array2 then
19901: LD_VAR 0 1
19905: NOT
19906: PUSH
19907: LD_VAR 0 2
19911: NOT
19912: OR
19913: IFFALSE 19917
// exit ;
19915: GO 19981
// result := true ;
19917: LD_ADDR_VAR 0 3
19921: PUSH
19922: LD_INT 1
19924: ST_TO_ADDR
// for i = 1 to array1 do
19925: LD_ADDR_VAR 0 4
19929: PUSH
19930: DOUBLE
19931: LD_INT 1
19933: DEC
19934: ST_TO_ADDR
19935: LD_VAR 0 1
19939: PUSH
19940: FOR_TO
19941: IFFALSE 19979
// if array1 [ i ] <> array2 [ i ] then
19943: LD_VAR 0 1
19947: PUSH
19948: LD_VAR 0 4
19952: ARRAY
19953: PUSH
19954: LD_VAR 0 2
19958: PUSH
19959: LD_VAR 0 4
19963: ARRAY
19964: NONEQUAL
19965: IFFALSE 19977
// begin result := false ;
19967: LD_ADDR_VAR 0 3
19971: PUSH
19972: LD_INT 0
19974: ST_TO_ADDR
// break ;
19975: GO 19979
// end ;
19977: GO 19940
19979: POP
19980: POP
// end ;
19981: LD_VAR 0 3
19985: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
19986: LD_INT 0
19988: PPUSH
19989: PPUSH
19990: PPUSH
// pom := GetBase ( fac ) ;
19991: LD_ADDR_VAR 0 5
19995: PUSH
19996: LD_VAR 0 1
20000: PPUSH
20001: CALL_OW 274
20005: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
20006: LD_ADDR_VAR 0 4
20010: PUSH
20011: LD_VAR 0 2
20015: PUSH
20016: LD_INT 1
20018: ARRAY
20019: PPUSH
20020: LD_VAR 0 2
20024: PUSH
20025: LD_INT 2
20027: ARRAY
20028: PPUSH
20029: LD_VAR 0 2
20033: PUSH
20034: LD_INT 3
20036: ARRAY
20037: PPUSH
20038: LD_VAR 0 2
20042: PUSH
20043: LD_INT 4
20045: ARRAY
20046: PPUSH
20047: CALL_OW 449
20051: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20052: LD_ADDR_VAR 0 3
20056: PUSH
20057: LD_VAR 0 5
20061: PPUSH
20062: LD_INT 1
20064: PPUSH
20065: CALL_OW 275
20069: PUSH
20070: LD_VAR 0 4
20074: PUSH
20075: LD_INT 1
20077: ARRAY
20078: GREATEREQUAL
20079: PUSH
20080: LD_VAR 0 5
20084: PPUSH
20085: LD_INT 2
20087: PPUSH
20088: CALL_OW 275
20092: PUSH
20093: LD_VAR 0 4
20097: PUSH
20098: LD_INT 2
20100: ARRAY
20101: GREATEREQUAL
20102: AND
20103: PUSH
20104: LD_VAR 0 5
20108: PPUSH
20109: LD_INT 3
20111: PPUSH
20112: CALL_OW 275
20116: PUSH
20117: LD_VAR 0 4
20121: PUSH
20122: LD_INT 3
20124: ARRAY
20125: GREATEREQUAL
20126: AND
20127: ST_TO_ADDR
// end ;
20128: LD_VAR 0 3
20132: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
20133: LD_INT 0
20135: PPUSH
20136: PPUSH
20137: PPUSH
20138: PPUSH
// pom := GetBase ( building ) ;
20139: LD_ADDR_VAR 0 3
20143: PUSH
20144: LD_VAR 0 1
20148: PPUSH
20149: CALL_OW 274
20153: ST_TO_ADDR
// if not pom then
20154: LD_VAR 0 3
20158: NOT
20159: IFFALSE 20163
// exit ;
20161: GO 20333
// btype := GetBType ( building ) ;
20163: LD_ADDR_VAR 0 5
20167: PUSH
20168: LD_VAR 0 1
20172: PPUSH
20173: CALL_OW 266
20177: ST_TO_ADDR
// if btype = b_armoury then
20178: LD_VAR 0 5
20182: PUSH
20183: LD_INT 4
20185: EQUAL
20186: IFFALSE 20196
// btype := b_barracks ;
20188: LD_ADDR_VAR 0 5
20192: PUSH
20193: LD_INT 5
20195: ST_TO_ADDR
// if btype = b_depot then
20196: LD_VAR 0 5
20200: PUSH
20201: LD_INT 0
20203: EQUAL
20204: IFFALSE 20214
// btype := b_warehouse ;
20206: LD_ADDR_VAR 0 5
20210: PUSH
20211: LD_INT 1
20213: ST_TO_ADDR
// if btype = b_workshop then
20214: LD_VAR 0 5
20218: PUSH
20219: LD_INT 2
20221: EQUAL
20222: IFFALSE 20232
// btype := b_factory ;
20224: LD_ADDR_VAR 0 5
20228: PUSH
20229: LD_INT 3
20231: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20232: LD_ADDR_VAR 0 4
20236: PUSH
20237: LD_VAR 0 5
20241: PPUSH
20242: LD_VAR 0 1
20246: PPUSH
20247: CALL_OW 248
20251: PPUSH
20252: CALL_OW 450
20256: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20257: LD_ADDR_VAR 0 2
20261: PUSH
20262: LD_VAR 0 3
20266: PPUSH
20267: LD_INT 1
20269: PPUSH
20270: CALL_OW 275
20274: PUSH
20275: LD_VAR 0 4
20279: PUSH
20280: LD_INT 1
20282: ARRAY
20283: GREATEREQUAL
20284: PUSH
20285: LD_VAR 0 3
20289: PPUSH
20290: LD_INT 2
20292: PPUSH
20293: CALL_OW 275
20297: PUSH
20298: LD_VAR 0 4
20302: PUSH
20303: LD_INT 2
20305: ARRAY
20306: GREATEREQUAL
20307: AND
20308: PUSH
20309: LD_VAR 0 3
20313: PPUSH
20314: LD_INT 3
20316: PPUSH
20317: CALL_OW 275
20321: PUSH
20322: LD_VAR 0 4
20326: PUSH
20327: LD_INT 3
20329: ARRAY
20330: GREATEREQUAL
20331: AND
20332: ST_TO_ADDR
// end ;
20333: LD_VAR 0 2
20337: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
20338: LD_INT 0
20340: PPUSH
20341: PPUSH
20342: PPUSH
// pom := GetBase ( building ) ;
20343: LD_ADDR_VAR 0 4
20347: PUSH
20348: LD_VAR 0 1
20352: PPUSH
20353: CALL_OW 274
20357: ST_TO_ADDR
// if not pom then
20358: LD_VAR 0 4
20362: NOT
20363: IFFALSE 20367
// exit ;
20365: GO 20468
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20367: LD_ADDR_VAR 0 5
20371: PUSH
20372: LD_VAR 0 2
20376: PPUSH
20377: LD_VAR 0 1
20381: PPUSH
20382: CALL_OW 248
20386: PPUSH
20387: CALL_OW 450
20391: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20392: LD_ADDR_VAR 0 3
20396: PUSH
20397: LD_VAR 0 4
20401: PPUSH
20402: LD_INT 1
20404: PPUSH
20405: CALL_OW 275
20409: PUSH
20410: LD_VAR 0 5
20414: PUSH
20415: LD_INT 1
20417: ARRAY
20418: GREATEREQUAL
20419: PUSH
20420: LD_VAR 0 4
20424: PPUSH
20425: LD_INT 2
20427: PPUSH
20428: CALL_OW 275
20432: PUSH
20433: LD_VAR 0 5
20437: PUSH
20438: LD_INT 2
20440: ARRAY
20441: GREATEREQUAL
20442: AND
20443: PUSH
20444: LD_VAR 0 4
20448: PPUSH
20449: LD_INT 3
20451: PPUSH
20452: CALL_OW 275
20456: PUSH
20457: LD_VAR 0 5
20461: PUSH
20462: LD_INT 3
20464: ARRAY
20465: GREATEREQUAL
20466: AND
20467: ST_TO_ADDR
// end ;
20468: LD_VAR 0 3
20472: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
20473: LD_INT 0
20475: PPUSH
20476: PPUSH
20477: PPUSH
20478: PPUSH
20479: PPUSH
20480: PPUSH
20481: PPUSH
20482: PPUSH
20483: PPUSH
20484: PPUSH
20485: PPUSH
// result := false ;
20486: LD_ADDR_VAR 0 8
20490: PUSH
20491: LD_INT 0
20493: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
20494: LD_VAR 0 5
20498: NOT
20499: PUSH
20500: LD_VAR 0 1
20504: NOT
20505: OR
20506: PUSH
20507: LD_VAR 0 2
20511: NOT
20512: OR
20513: PUSH
20514: LD_VAR 0 3
20518: NOT
20519: OR
20520: IFFALSE 20524
// exit ;
20522: GO 21338
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
20524: LD_ADDR_VAR 0 14
20528: PUSH
20529: LD_VAR 0 1
20533: PPUSH
20534: LD_VAR 0 2
20538: PPUSH
20539: LD_VAR 0 3
20543: PPUSH
20544: LD_VAR 0 4
20548: PPUSH
20549: LD_VAR 0 5
20553: PUSH
20554: LD_INT 1
20556: ARRAY
20557: PPUSH
20558: CALL_OW 248
20562: PPUSH
20563: LD_INT 0
20565: PPUSH
20566: CALL 22575 0 6
20570: ST_TO_ADDR
// if not hexes then
20571: LD_VAR 0 14
20575: NOT
20576: IFFALSE 20580
// exit ;
20578: GO 21338
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
20580: LD_ADDR_VAR 0 17
20584: PUSH
20585: LD_VAR 0 5
20589: PPUSH
20590: LD_INT 22
20592: PUSH
20593: LD_VAR 0 13
20597: PPUSH
20598: CALL_OW 255
20602: PUSH
20603: EMPTY
20604: LIST
20605: LIST
20606: PUSH
20607: LD_INT 2
20609: PUSH
20610: LD_INT 30
20612: PUSH
20613: LD_INT 0
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 30
20622: PUSH
20623: LD_INT 1
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: PUSH
20630: EMPTY
20631: LIST
20632: LIST
20633: LIST
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PPUSH
20639: CALL_OW 72
20643: ST_TO_ADDR
// for i = 1 to hexes do
20644: LD_ADDR_VAR 0 9
20648: PUSH
20649: DOUBLE
20650: LD_INT 1
20652: DEC
20653: ST_TO_ADDR
20654: LD_VAR 0 14
20658: PUSH
20659: FOR_TO
20660: IFFALSE 21336
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
20662: LD_ADDR_VAR 0 13
20666: PUSH
20667: LD_VAR 0 14
20671: PUSH
20672: LD_VAR 0 9
20676: ARRAY
20677: PUSH
20678: LD_INT 1
20680: ARRAY
20681: PPUSH
20682: LD_VAR 0 14
20686: PUSH
20687: LD_VAR 0 9
20691: ARRAY
20692: PUSH
20693: LD_INT 2
20695: ARRAY
20696: PPUSH
20697: CALL_OW 428
20701: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
20702: LD_VAR 0 14
20706: PUSH
20707: LD_VAR 0 9
20711: ARRAY
20712: PUSH
20713: LD_INT 1
20715: ARRAY
20716: PPUSH
20717: LD_VAR 0 14
20721: PUSH
20722: LD_VAR 0 9
20726: ARRAY
20727: PUSH
20728: LD_INT 2
20730: ARRAY
20731: PPUSH
20732: CALL_OW 351
20736: PUSH
20737: LD_VAR 0 14
20741: PUSH
20742: LD_VAR 0 9
20746: ARRAY
20747: PUSH
20748: LD_INT 1
20750: ARRAY
20751: PPUSH
20752: LD_VAR 0 14
20756: PUSH
20757: LD_VAR 0 9
20761: ARRAY
20762: PUSH
20763: LD_INT 2
20765: ARRAY
20766: PPUSH
20767: CALL_OW 488
20771: NOT
20772: OR
20773: PUSH
20774: LD_VAR 0 13
20778: PPUSH
20779: CALL_OW 247
20783: PUSH
20784: LD_INT 3
20786: EQUAL
20787: OR
20788: IFFALSE 20794
// exit ;
20790: POP
20791: POP
20792: GO 21338
// if not tmp then
20794: LD_VAR 0 13
20798: NOT
20799: IFFALSE 20803
// continue ;
20801: GO 20659
// result := true ;
20803: LD_ADDR_VAR 0 8
20807: PUSH
20808: LD_INT 1
20810: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
20811: LD_VAR 0 6
20815: PUSH
20816: LD_VAR 0 13
20820: PPUSH
20821: CALL_OW 247
20825: PUSH
20826: LD_INT 2
20828: EQUAL
20829: AND
20830: PUSH
20831: LD_VAR 0 13
20835: PPUSH
20836: CALL_OW 263
20840: PUSH
20841: LD_INT 1
20843: EQUAL
20844: AND
20845: IFFALSE 21009
// begin if IsDrivenBy ( tmp ) then
20847: LD_VAR 0 13
20851: PPUSH
20852: CALL_OW 311
20856: IFFALSE 20860
// continue ;
20858: GO 20659
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
20860: LD_VAR 0 6
20864: PPUSH
20865: LD_INT 3
20867: PUSH
20868: LD_INT 60
20870: PUSH
20871: EMPTY
20872: LIST
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: PUSH
20878: LD_INT 3
20880: PUSH
20881: LD_INT 55
20883: PUSH
20884: EMPTY
20885: LIST
20886: PUSH
20887: EMPTY
20888: LIST
20889: LIST
20890: PUSH
20891: EMPTY
20892: LIST
20893: LIST
20894: PPUSH
20895: CALL_OW 72
20899: IFFALSE 21007
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
20901: LD_ADDR_VAR 0 18
20905: PUSH
20906: LD_VAR 0 6
20910: PPUSH
20911: LD_INT 3
20913: PUSH
20914: LD_INT 60
20916: PUSH
20917: EMPTY
20918: LIST
20919: PUSH
20920: EMPTY
20921: LIST
20922: LIST
20923: PUSH
20924: LD_INT 3
20926: PUSH
20927: LD_INT 55
20929: PUSH
20930: EMPTY
20931: LIST
20932: PUSH
20933: EMPTY
20934: LIST
20935: LIST
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PPUSH
20941: CALL_OW 72
20945: PUSH
20946: LD_INT 1
20948: ARRAY
20949: ST_TO_ADDR
// if IsInUnit ( driver ) then
20950: LD_VAR 0 18
20954: PPUSH
20955: CALL_OW 310
20959: IFFALSE 20970
// ComExit ( driver ) ;
20961: LD_VAR 0 18
20965: PPUSH
20966: CALL 45759 0 1
// AddComEnterUnit ( driver , tmp ) ;
20970: LD_VAR 0 18
20974: PPUSH
20975: LD_VAR 0 13
20979: PPUSH
20980: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
20984: LD_VAR 0 18
20988: PPUSH
20989: LD_VAR 0 7
20993: PPUSH
20994: CALL_OW 173
// AddComExitVehicle ( driver ) ;
20998: LD_VAR 0 18
21002: PPUSH
21003: CALL_OW 181
// end ; continue ;
21007: GO 20659
// end ; if not cleaners or not tmp in cleaners then
21009: LD_VAR 0 6
21013: NOT
21014: PUSH
21015: LD_VAR 0 13
21019: PUSH
21020: LD_VAR 0 6
21024: IN
21025: NOT
21026: OR
21027: IFFALSE 21334
// begin if dep then
21029: LD_VAR 0 17
21033: IFFALSE 21169
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21035: LD_ADDR_VAR 0 16
21039: PUSH
21040: LD_VAR 0 17
21044: PUSH
21045: LD_INT 1
21047: ARRAY
21048: PPUSH
21049: CALL_OW 250
21053: PPUSH
21054: LD_VAR 0 17
21058: PUSH
21059: LD_INT 1
21061: ARRAY
21062: PPUSH
21063: CALL_OW 254
21067: PPUSH
21068: LD_INT 5
21070: PPUSH
21071: CALL_OW 272
21075: PUSH
21076: LD_VAR 0 17
21080: PUSH
21081: LD_INT 1
21083: ARRAY
21084: PPUSH
21085: CALL_OW 251
21089: PPUSH
21090: LD_VAR 0 17
21094: PUSH
21095: LD_INT 1
21097: ARRAY
21098: PPUSH
21099: CALL_OW 254
21103: PPUSH
21104: LD_INT 5
21106: PPUSH
21107: CALL_OW 273
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21116: LD_VAR 0 16
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PPUSH
21125: LD_VAR 0 16
21129: PUSH
21130: LD_INT 2
21132: ARRAY
21133: PPUSH
21134: CALL_OW 488
21138: IFFALSE 21169
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
21140: LD_VAR 0 13
21144: PPUSH
21145: LD_VAR 0 16
21149: PUSH
21150: LD_INT 1
21152: ARRAY
21153: PPUSH
21154: LD_VAR 0 16
21158: PUSH
21159: LD_INT 2
21161: ARRAY
21162: PPUSH
21163: CALL_OW 111
// continue ;
21167: GO 20659
// end ; end ; r := GetDir ( tmp ) ;
21169: LD_ADDR_VAR 0 15
21173: PUSH
21174: LD_VAR 0 13
21178: PPUSH
21179: CALL_OW 254
21183: ST_TO_ADDR
// if r = 5 then
21184: LD_VAR 0 15
21188: PUSH
21189: LD_INT 5
21191: EQUAL
21192: IFFALSE 21202
// r := 0 ;
21194: LD_ADDR_VAR 0 15
21198: PUSH
21199: LD_INT 0
21201: ST_TO_ADDR
// for j = r to 5 do
21202: LD_ADDR_VAR 0 10
21206: PUSH
21207: DOUBLE
21208: LD_VAR 0 15
21212: DEC
21213: ST_TO_ADDR
21214: LD_INT 5
21216: PUSH
21217: FOR_TO
21218: IFFALSE 21332
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
21220: LD_ADDR_VAR 0 11
21224: PUSH
21225: LD_VAR 0 13
21229: PPUSH
21230: CALL_OW 250
21234: PPUSH
21235: LD_VAR 0 10
21239: PPUSH
21240: LD_INT 2
21242: PPUSH
21243: CALL_OW 272
21247: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
21248: LD_ADDR_VAR 0 12
21252: PUSH
21253: LD_VAR 0 13
21257: PPUSH
21258: CALL_OW 251
21262: PPUSH
21263: LD_VAR 0 10
21267: PPUSH
21268: LD_INT 2
21270: PPUSH
21271: CALL_OW 273
21275: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
21276: LD_VAR 0 11
21280: PPUSH
21281: LD_VAR 0 12
21285: PPUSH
21286: CALL_OW 488
21290: PUSH
21291: LD_VAR 0 11
21295: PPUSH
21296: LD_VAR 0 12
21300: PPUSH
21301: CALL_OW 428
21305: NOT
21306: AND
21307: IFFALSE 21330
// begin ComMoveXY ( tmp , _x , _y ) ;
21309: LD_VAR 0 13
21313: PPUSH
21314: LD_VAR 0 11
21318: PPUSH
21319: LD_VAR 0 12
21323: PPUSH
21324: CALL_OW 111
// break ;
21328: GO 21332
// end ; end ;
21330: GO 21217
21332: POP
21333: POP
// end ; end ;
21334: GO 20659
21336: POP
21337: POP
// end ;
21338: LD_VAR 0 8
21342: RET
// export function BuildingTechInvented ( side , btype ) ; begin
21343: LD_INT 0
21345: PPUSH
// result := true ;
21346: LD_ADDR_VAR 0 3
21350: PUSH
21351: LD_INT 1
21353: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
21354: LD_VAR 0 2
21358: PUSH
21359: LD_INT 24
21361: DOUBLE
21362: EQUAL
21363: IFTRUE 21373
21365: LD_INT 33
21367: DOUBLE
21368: EQUAL
21369: IFTRUE 21373
21371: GO 21398
21373: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
21374: LD_ADDR_VAR 0 3
21378: PUSH
21379: LD_INT 32
21381: PPUSH
21382: LD_VAR 0 1
21386: PPUSH
21387: CALL_OW 321
21391: PUSH
21392: LD_INT 2
21394: EQUAL
21395: ST_TO_ADDR
21396: GO 21718
21398: LD_INT 20
21400: DOUBLE
21401: EQUAL
21402: IFTRUE 21406
21404: GO 21431
21406: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
21407: LD_ADDR_VAR 0 3
21411: PUSH
21412: LD_INT 6
21414: PPUSH
21415: LD_VAR 0 1
21419: PPUSH
21420: CALL_OW 321
21424: PUSH
21425: LD_INT 2
21427: EQUAL
21428: ST_TO_ADDR
21429: GO 21718
21431: LD_INT 22
21433: DOUBLE
21434: EQUAL
21435: IFTRUE 21445
21437: LD_INT 36
21439: DOUBLE
21440: EQUAL
21441: IFTRUE 21445
21443: GO 21470
21445: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
21446: LD_ADDR_VAR 0 3
21450: PUSH
21451: LD_INT 15
21453: PPUSH
21454: LD_VAR 0 1
21458: PPUSH
21459: CALL_OW 321
21463: PUSH
21464: LD_INT 2
21466: EQUAL
21467: ST_TO_ADDR
21468: GO 21718
21470: LD_INT 30
21472: DOUBLE
21473: EQUAL
21474: IFTRUE 21478
21476: GO 21503
21478: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
21479: LD_ADDR_VAR 0 3
21483: PUSH
21484: LD_INT 20
21486: PPUSH
21487: LD_VAR 0 1
21491: PPUSH
21492: CALL_OW 321
21496: PUSH
21497: LD_INT 2
21499: EQUAL
21500: ST_TO_ADDR
21501: GO 21718
21503: LD_INT 28
21505: DOUBLE
21506: EQUAL
21507: IFTRUE 21517
21509: LD_INT 21
21511: DOUBLE
21512: EQUAL
21513: IFTRUE 21517
21515: GO 21542
21517: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
21518: LD_ADDR_VAR 0 3
21522: PUSH
21523: LD_INT 21
21525: PPUSH
21526: LD_VAR 0 1
21530: PPUSH
21531: CALL_OW 321
21535: PUSH
21536: LD_INT 2
21538: EQUAL
21539: ST_TO_ADDR
21540: GO 21718
21542: LD_INT 16
21544: DOUBLE
21545: EQUAL
21546: IFTRUE 21550
21548: GO 21577
21550: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
21551: LD_ADDR_VAR 0 3
21555: PUSH
21556: LD_EXP 79
21560: PPUSH
21561: LD_VAR 0 1
21565: PPUSH
21566: CALL_OW 321
21570: PUSH
21571: LD_INT 2
21573: EQUAL
21574: ST_TO_ADDR
21575: GO 21718
21577: LD_INT 19
21579: DOUBLE
21580: EQUAL
21581: IFTRUE 21591
21583: LD_INT 23
21585: DOUBLE
21586: EQUAL
21587: IFTRUE 21591
21589: GO 21618
21591: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
21592: LD_ADDR_VAR 0 3
21596: PUSH
21597: LD_EXP 78
21601: PPUSH
21602: LD_VAR 0 1
21606: PPUSH
21607: CALL_OW 321
21611: PUSH
21612: LD_INT 2
21614: EQUAL
21615: ST_TO_ADDR
21616: GO 21718
21618: LD_INT 17
21620: DOUBLE
21621: EQUAL
21622: IFTRUE 21626
21624: GO 21651
21626: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
21627: LD_ADDR_VAR 0 3
21631: PUSH
21632: LD_INT 39
21634: PPUSH
21635: LD_VAR 0 1
21639: PPUSH
21640: CALL_OW 321
21644: PUSH
21645: LD_INT 2
21647: EQUAL
21648: ST_TO_ADDR
21649: GO 21718
21651: LD_INT 18
21653: DOUBLE
21654: EQUAL
21655: IFTRUE 21659
21657: GO 21684
21659: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
21660: LD_ADDR_VAR 0 3
21664: PUSH
21665: LD_INT 40
21667: PPUSH
21668: LD_VAR 0 1
21672: PPUSH
21673: CALL_OW 321
21677: PUSH
21678: LD_INT 2
21680: EQUAL
21681: ST_TO_ADDR
21682: GO 21718
21684: LD_INT 27
21686: DOUBLE
21687: EQUAL
21688: IFTRUE 21692
21690: GO 21717
21692: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
21693: LD_ADDR_VAR 0 3
21697: PUSH
21698: LD_INT 35
21700: PPUSH
21701: LD_VAR 0 1
21705: PPUSH
21706: CALL_OW 321
21710: PUSH
21711: LD_INT 2
21713: EQUAL
21714: ST_TO_ADDR
21715: GO 21718
21717: POP
// end ;
21718: LD_VAR 0 3
21722: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
21723: LD_INT 0
21725: PPUSH
21726: PPUSH
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
21732: PPUSH
21733: PPUSH
21734: PPUSH
21735: PPUSH
// result := false ;
21736: LD_ADDR_VAR 0 6
21740: PUSH
21741: LD_INT 0
21743: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
21744: LD_VAR 0 1
21748: NOT
21749: PUSH
21750: LD_VAR 0 1
21754: PPUSH
21755: CALL_OW 266
21759: PUSH
21760: LD_INT 0
21762: PUSH
21763: LD_INT 1
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: IN
21770: NOT
21771: OR
21772: PUSH
21773: LD_VAR 0 2
21777: NOT
21778: OR
21779: PUSH
21780: LD_VAR 0 5
21784: PUSH
21785: LD_INT 0
21787: PUSH
21788: LD_INT 1
21790: PUSH
21791: LD_INT 2
21793: PUSH
21794: LD_INT 3
21796: PUSH
21797: LD_INT 4
21799: PUSH
21800: LD_INT 5
21802: PUSH
21803: EMPTY
21804: LIST
21805: LIST
21806: LIST
21807: LIST
21808: LIST
21809: LIST
21810: IN
21811: NOT
21812: OR
21813: PUSH
21814: LD_VAR 0 3
21818: PPUSH
21819: LD_VAR 0 4
21823: PPUSH
21824: CALL_OW 488
21828: NOT
21829: OR
21830: IFFALSE 21834
// exit ;
21832: GO 22570
// side := GetSide ( depot ) ;
21834: LD_ADDR_VAR 0 9
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: CALL_OW 255
21848: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
21849: LD_VAR 0 9
21853: PPUSH
21854: LD_VAR 0 2
21858: PPUSH
21859: CALL 21343 0 2
21863: NOT
21864: IFFALSE 21868
// exit ;
21866: GO 22570
// pom := GetBase ( depot ) ;
21868: LD_ADDR_VAR 0 10
21872: PUSH
21873: LD_VAR 0 1
21877: PPUSH
21878: CALL_OW 274
21882: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
21883: LD_ADDR_VAR 0 11
21887: PUSH
21888: LD_VAR 0 2
21892: PPUSH
21893: LD_VAR 0 1
21897: PPUSH
21898: CALL_OW 248
21902: PPUSH
21903: CALL_OW 450
21907: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
21908: LD_VAR 0 10
21912: PPUSH
21913: LD_INT 1
21915: PPUSH
21916: CALL_OW 275
21920: PUSH
21921: LD_VAR 0 11
21925: PUSH
21926: LD_INT 1
21928: ARRAY
21929: GREATEREQUAL
21930: PUSH
21931: LD_VAR 0 10
21935: PPUSH
21936: LD_INT 2
21938: PPUSH
21939: CALL_OW 275
21943: PUSH
21944: LD_VAR 0 11
21948: PUSH
21949: LD_INT 2
21951: ARRAY
21952: GREATEREQUAL
21953: AND
21954: PUSH
21955: LD_VAR 0 10
21959: PPUSH
21960: LD_INT 3
21962: PPUSH
21963: CALL_OW 275
21967: PUSH
21968: LD_VAR 0 11
21972: PUSH
21973: LD_INT 3
21975: ARRAY
21976: GREATEREQUAL
21977: AND
21978: NOT
21979: IFFALSE 21983
// exit ;
21981: GO 22570
// if GetBType ( depot ) = b_depot then
21983: LD_VAR 0 1
21987: PPUSH
21988: CALL_OW 266
21992: PUSH
21993: LD_INT 0
21995: EQUAL
21996: IFFALSE 22008
// dist := 28 else
21998: LD_ADDR_VAR 0 14
22002: PUSH
22003: LD_INT 28
22005: ST_TO_ADDR
22006: GO 22016
// dist := 36 ;
22008: LD_ADDR_VAR 0 14
22012: PUSH
22013: LD_INT 36
22015: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22016: LD_VAR 0 1
22020: PPUSH
22021: LD_VAR 0 3
22025: PPUSH
22026: LD_VAR 0 4
22030: PPUSH
22031: CALL_OW 297
22035: PUSH
22036: LD_VAR 0 14
22040: GREATER
22041: IFFALSE 22045
// exit ;
22043: GO 22570
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22045: LD_ADDR_VAR 0 12
22049: PUSH
22050: LD_VAR 0 2
22054: PPUSH
22055: LD_VAR 0 3
22059: PPUSH
22060: LD_VAR 0 4
22064: PPUSH
22065: LD_VAR 0 5
22069: PPUSH
22070: LD_VAR 0 1
22074: PPUSH
22075: CALL_OW 248
22079: PPUSH
22080: LD_INT 0
22082: PPUSH
22083: CALL 22575 0 6
22087: ST_TO_ADDR
// if not hexes then
22088: LD_VAR 0 12
22092: NOT
22093: IFFALSE 22097
// exit ;
22095: GO 22570
// hex := GetHexInfo ( x , y ) ;
22097: LD_ADDR_VAR 0 15
22101: PUSH
22102: LD_VAR 0 3
22106: PPUSH
22107: LD_VAR 0 4
22111: PPUSH
22112: CALL_OW 546
22116: ST_TO_ADDR
// if hex [ 1 ] then
22117: LD_VAR 0 15
22121: PUSH
22122: LD_INT 1
22124: ARRAY
22125: IFFALSE 22129
// exit ;
22127: GO 22570
// height := hex [ 2 ] ;
22129: LD_ADDR_VAR 0 13
22133: PUSH
22134: LD_VAR 0 15
22138: PUSH
22139: LD_INT 2
22141: ARRAY
22142: ST_TO_ADDR
// for i = 1 to hexes do
22143: LD_ADDR_VAR 0 7
22147: PUSH
22148: DOUBLE
22149: LD_INT 1
22151: DEC
22152: ST_TO_ADDR
22153: LD_VAR 0 12
22157: PUSH
22158: FOR_TO
22159: IFFALSE 22489
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22161: LD_VAR 0 12
22165: PUSH
22166: LD_VAR 0 7
22170: ARRAY
22171: PUSH
22172: LD_INT 1
22174: ARRAY
22175: PPUSH
22176: LD_VAR 0 12
22180: PUSH
22181: LD_VAR 0 7
22185: ARRAY
22186: PUSH
22187: LD_INT 2
22189: ARRAY
22190: PPUSH
22191: CALL_OW 488
22195: NOT
22196: PUSH
22197: LD_VAR 0 12
22201: PUSH
22202: LD_VAR 0 7
22206: ARRAY
22207: PUSH
22208: LD_INT 1
22210: ARRAY
22211: PPUSH
22212: LD_VAR 0 12
22216: PUSH
22217: LD_VAR 0 7
22221: ARRAY
22222: PUSH
22223: LD_INT 2
22225: ARRAY
22226: PPUSH
22227: CALL_OW 428
22231: PUSH
22232: LD_INT 0
22234: GREATER
22235: OR
22236: PUSH
22237: LD_VAR 0 12
22241: PUSH
22242: LD_VAR 0 7
22246: ARRAY
22247: PUSH
22248: LD_INT 1
22250: ARRAY
22251: PPUSH
22252: LD_VAR 0 12
22256: PUSH
22257: LD_VAR 0 7
22261: ARRAY
22262: PUSH
22263: LD_INT 2
22265: ARRAY
22266: PPUSH
22267: CALL_OW 351
22271: OR
22272: IFFALSE 22278
// exit ;
22274: POP
22275: POP
22276: GO 22570
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22278: LD_ADDR_VAR 0 8
22282: PUSH
22283: LD_VAR 0 12
22287: PUSH
22288: LD_VAR 0 7
22292: ARRAY
22293: PUSH
22294: LD_INT 1
22296: ARRAY
22297: PPUSH
22298: LD_VAR 0 12
22302: PUSH
22303: LD_VAR 0 7
22307: ARRAY
22308: PUSH
22309: LD_INT 2
22311: ARRAY
22312: PPUSH
22313: CALL_OW 546
22317: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22318: LD_VAR 0 8
22322: PUSH
22323: LD_INT 1
22325: ARRAY
22326: PUSH
22327: LD_VAR 0 8
22331: PUSH
22332: LD_INT 2
22334: ARRAY
22335: PUSH
22336: LD_VAR 0 13
22340: PUSH
22341: LD_INT 2
22343: PLUS
22344: GREATER
22345: OR
22346: PUSH
22347: LD_VAR 0 8
22351: PUSH
22352: LD_INT 2
22354: ARRAY
22355: PUSH
22356: LD_VAR 0 13
22360: PUSH
22361: LD_INT 2
22363: MINUS
22364: LESS
22365: OR
22366: PUSH
22367: LD_VAR 0 8
22371: PUSH
22372: LD_INT 3
22374: ARRAY
22375: PUSH
22376: LD_INT 0
22378: PUSH
22379: LD_INT 8
22381: PUSH
22382: LD_INT 9
22384: PUSH
22385: LD_INT 10
22387: PUSH
22388: LD_INT 11
22390: PUSH
22391: LD_INT 12
22393: PUSH
22394: LD_INT 13
22396: PUSH
22397: LD_INT 16
22399: PUSH
22400: LD_INT 17
22402: PUSH
22403: LD_INT 18
22405: PUSH
22406: LD_INT 19
22408: PUSH
22409: LD_INT 20
22411: PUSH
22412: LD_INT 21
22414: PUSH
22415: EMPTY
22416: LIST
22417: LIST
22418: LIST
22419: LIST
22420: LIST
22421: LIST
22422: LIST
22423: LIST
22424: LIST
22425: LIST
22426: LIST
22427: LIST
22428: LIST
22429: IN
22430: NOT
22431: OR
22432: PUSH
22433: LD_VAR 0 8
22437: PUSH
22438: LD_INT 5
22440: ARRAY
22441: NOT
22442: OR
22443: PUSH
22444: LD_VAR 0 8
22448: PUSH
22449: LD_INT 6
22451: ARRAY
22452: PUSH
22453: LD_INT 1
22455: PUSH
22456: LD_INT 2
22458: PUSH
22459: LD_INT 7
22461: PUSH
22462: LD_INT 9
22464: PUSH
22465: LD_INT 10
22467: PUSH
22468: LD_INT 11
22470: PUSH
22471: EMPTY
22472: LIST
22473: LIST
22474: LIST
22475: LIST
22476: LIST
22477: LIST
22478: IN
22479: NOT
22480: OR
22481: IFFALSE 22487
// exit ;
22483: POP
22484: POP
22485: GO 22570
// end ;
22487: GO 22158
22489: POP
22490: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22491: LD_VAR 0 9
22495: PPUSH
22496: LD_VAR 0 3
22500: PPUSH
22501: LD_VAR 0 4
22505: PPUSH
22506: LD_INT 20
22508: PPUSH
22509: CALL 14515 0 4
22513: PUSH
22514: LD_INT 4
22516: ARRAY
22517: IFFALSE 22521
// exit ;
22519: GO 22570
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22521: LD_VAR 0 2
22525: PUSH
22526: LD_INT 29
22528: PUSH
22529: LD_INT 30
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: IN
22536: PUSH
22537: LD_VAR 0 3
22541: PPUSH
22542: LD_VAR 0 4
22546: PPUSH
22547: LD_VAR 0 9
22551: PPUSH
22552: CALL_OW 440
22556: NOT
22557: AND
22558: IFFALSE 22562
// exit ;
22560: GO 22570
// result := true ;
22562: LD_ADDR_VAR 0 6
22566: PUSH
22567: LD_INT 1
22569: ST_TO_ADDR
// end ;
22570: LD_VAR 0 6
22574: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
22575: LD_INT 0
22577: PPUSH
22578: PPUSH
22579: PPUSH
22580: PPUSH
22581: PPUSH
22582: PPUSH
22583: PPUSH
22584: PPUSH
22585: PPUSH
22586: PPUSH
22587: PPUSH
22588: PPUSH
22589: PPUSH
22590: PPUSH
22591: PPUSH
22592: PPUSH
22593: PPUSH
22594: PPUSH
22595: PPUSH
22596: PPUSH
22597: PPUSH
22598: PPUSH
22599: PPUSH
22600: PPUSH
22601: PPUSH
22602: PPUSH
22603: PPUSH
22604: PPUSH
22605: PPUSH
22606: PPUSH
22607: PPUSH
22608: PPUSH
22609: PPUSH
22610: PPUSH
22611: PPUSH
22612: PPUSH
22613: PPUSH
22614: PPUSH
22615: PPUSH
22616: PPUSH
22617: PPUSH
22618: PPUSH
22619: PPUSH
22620: PPUSH
22621: PPUSH
22622: PPUSH
22623: PPUSH
22624: PPUSH
22625: PPUSH
22626: PPUSH
22627: PPUSH
22628: PPUSH
22629: PPUSH
22630: PPUSH
22631: PPUSH
22632: PPUSH
22633: PPUSH
22634: PPUSH
// result = [ ] ;
22635: LD_ADDR_VAR 0 7
22639: PUSH
22640: EMPTY
22641: ST_TO_ADDR
// temp_list = [ ] ;
22642: LD_ADDR_VAR 0 9
22646: PUSH
22647: EMPTY
22648: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
22649: LD_VAR 0 4
22653: PUSH
22654: LD_INT 0
22656: PUSH
22657: LD_INT 1
22659: PUSH
22660: LD_INT 2
22662: PUSH
22663: LD_INT 3
22665: PUSH
22666: LD_INT 4
22668: PUSH
22669: LD_INT 5
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: IN
22680: NOT
22681: PUSH
22682: LD_VAR 0 1
22686: PUSH
22687: LD_INT 0
22689: PUSH
22690: LD_INT 1
22692: PUSH
22693: EMPTY
22694: LIST
22695: LIST
22696: IN
22697: PUSH
22698: LD_VAR 0 5
22702: PUSH
22703: LD_INT 1
22705: PUSH
22706: LD_INT 2
22708: PUSH
22709: LD_INT 3
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: IN
22717: NOT
22718: AND
22719: OR
22720: IFFALSE 22724
// exit ;
22722: GO 41115
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
22724: LD_VAR 0 1
22728: PUSH
22729: LD_INT 6
22731: PUSH
22732: LD_INT 7
22734: PUSH
22735: LD_INT 8
22737: PUSH
22738: LD_INT 13
22740: PUSH
22741: LD_INT 12
22743: PUSH
22744: LD_INT 15
22746: PUSH
22747: LD_INT 11
22749: PUSH
22750: LD_INT 14
22752: PUSH
22753: LD_INT 10
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: LIST
22760: LIST
22761: LIST
22762: LIST
22763: LIST
22764: LIST
22765: LIST
22766: IN
22767: IFFALSE 22777
// btype = b_lab ;
22769: LD_ADDR_VAR 0 1
22773: PUSH
22774: LD_INT 6
22776: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
22777: LD_VAR 0 6
22781: PUSH
22782: LD_INT 0
22784: PUSH
22785: LD_INT 1
22787: PUSH
22788: LD_INT 2
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: LIST
22795: IN
22796: NOT
22797: PUSH
22798: LD_VAR 0 1
22802: PUSH
22803: LD_INT 0
22805: PUSH
22806: LD_INT 1
22808: PUSH
22809: LD_INT 2
22811: PUSH
22812: LD_INT 3
22814: PUSH
22815: LD_INT 6
22817: PUSH
22818: LD_INT 36
22820: PUSH
22821: LD_INT 4
22823: PUSH
22824: LD_INT 5
22826: PUSH
22827: LD_INT 31
22829: PUSH
22830: LD_INT 32
22832: PUSH
22833: LD_INT 33
22835: PUSH
22836: EMPTY
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: LIST
22842: LIST
22843: LIST
22844: LIST
22845: LIST
22846: LIST
22847: LIST
22848: IN
22849: NOT
22850: PUSH
22851: LD_VAR 0 6
22855: PUSH
22856: LD_INT 1
22858: EQUAL
22859: AND
22860: OR
22861: PUSH
22862: LD_VAR 0 1
22866: PUSH
22867: LD_INT 2
22869: PUSH
22870: LD_INT 3
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: IN
22877: NOT
22878: PUSH
22879: LD_VAR 0 6
22883: PUSH
22884: LD_INT 2
22886: EQUAL
22887: AND
22888: OR
22889: IFFALSE 22899
// mode = 0 ;
22891: LD_ADDR_VAR 0 6
22895: PUSH
22896: LD_INT 0
22898: ST_TO_ADDR
// case mode of 0 :
22899: LD_VAR 0 6
22903: PUSH
22904: LD_INT 0
22906: DOUBLE
22907: EQUAL
22908: IFTRUE 22912
22910: GO 34365
22912: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
22913: LD_ADDR_VAR 0 11
22917: PUSH
22918: LD_INT 0
22920: PUSH
22921: LD_INT 0
22923: PUSH
22924: EMPTY
22925: LIST
22926: LIST
22927: PUSH
22928: LD_INT 0
22930: PUSH
22931: LD_INT 1
22933: NEG
22934: PUSH
22935: EMPTY
22936: LIST
22937: LIST
22938: PUSH
22939: LD_INT 1
22941: PUSH
22942: LD_INT 0
22944: PUSH
22945: EMPTY
22946: LIST
22947: LIST
22948: PUSH
22949: LD_INT 1
22951: PUSH
22952: LD_INT 1
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: PUSH
22959: LD_INT 0
22961: PUSH
22962: LD_INT 1
22964: PUSH
22965: EMPTY
22966: LIST
22967: LIST
22968: PUSH
22969: LD_INT 1
22971: NEG
22972: PUSH
22973: LD_INT 0
22975: PUSH
22976: EMPTY
22977: LIST
22978: LIST
22979: PUSH
22980: LD_INT 1
22982: NEG
22983: PUSH
22984: LD_INT 1
22986: NEG
22987: PUSH
22988: EMPTY
22989: LIST
22990: LIST
22991: PUSH
22992: LD_INT 1
22994: NEG
22995: PUSH
22996: LD_INT 2
22998: NEG
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PUSH
23004: LD_INT 0
23006: PUSH
23007: LD_INT 2
23009: NEG
23010: PUSH
23011: EMPTY
23012: LIST
23013: LIST
23014: PUSH
23015: LD_INT 1
23017: PUSH
23018: LD_INT 1
23020: NEG
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: LD_INT 1
23028: PUSH
23029: LD_INT 2
23031: PUSH
23032: EMPTY
23033: LIST
23034: LIST
23035: PUSH
23036: LD_INT 0
23038: PUSH
23039: LD_INT 2
23041: PUSH
23042: EMPTY
23043: LIST
23044: LIST
23045: PUSH
23046: LD_INT 1
23048: NEG
23049: PUSH
23050: LD_INT 1
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: LD_INT 1
23059: PUSH
23060: LD_INT 3
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: LD_INT 0
23069: PUSH
23070: LD_INT 3
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: PUSH
23077: LD_INT 1
23079: NEG
23080: PUSH
23081: LD_INT 2
23083: PUSH
23084: EMPTY
23085: LIST
23086: LIST
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: LIST
23092: LIST
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23106: LD_ADDR_VAR 0 12
23110: PUSH
23111: LD_INT 0
23113: PUSH
23114: LD_INT 0
23116: PUSH
23117: EMPTY
23118: LIST
23119: LIST
23120: PUSH
23121: LD_INT 0
23123: PUSH
23124: LD_INT 1
23126: NEG
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: LD_INT 0
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PUSH
23142: LD_INT 1
23144: PUSH
23145: LD_INT 1
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 0
23154: PUSH
23155: LD_INT 1
23157: PUSH
23158: EMPTY
23159: LIST
23160: LIST
23161: PUSH
23162: LD_INT 1
23164: NEG
23165: PUSH
23166: LD_INT 0
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PUSH
23173: LD_INT 1
23175: NEG
23176: PUSH
23177: LD_INT 1
23179: NEG
23180: PUSH
23181: EMPTY
23182: LIST
23183: LIST
23184: PUSH
23185: LD_INT 1
23187: PUSH
23188: LD_INT 1
23190: NEG
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: PUSH
23196: LD_INT 2
23198: PUSH
23199: LD_INT 0
23201: PUSH
23202: EMPTY
23203: LIST
23204: LIST
23205: PUSH
23206: LD_INT 2
23208: PUSH
23209: LD_INT 1
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 1
23218: NEG
23219: PUSH
23220: LD_INT 1
23222: PUSH
23223: EMPTY
23224: LIST
23225: LIST
23226: PUSH
23227: LD_INT 2
23229: NEG
23230: PUSH
23231: LD_INT 0
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: PUSH
23238: LD_INT 2
23240: NEG
23241: PUSH
23242: LD_INT 1
23244: NEG
23245: PUSH
23246: EMPTY
23247: LIST
23248: LIST
23249: PUSH
23250: LD_INT 2
23252: NEG
23253: PUSH
23254: LD_INT 1
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PUSH
23261: LD_INT 3
23263: NEG
23264: PUSH
23265: LD_INT 0
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: LD_INT 3
23274: NEG
23275: PUSH
23276: LD_INT 1
23278: NEG
23279: PUSH
23280: EMPTY
23281: LIST
23282: LIST
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: LIST
23288: LIST
23289: LIST
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: LIST
23295: LIST
23296: LIST
23297: LIST
23298: LIST
23299: LIST
23300: LIST
23301: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23302: LD_ADDR_VAR 0 13
23306: PUSH
23307: LD_INT 0
23309: PUSH
23310: LD_INT 0
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 0
23319: PUSH
23320: LD_INT 1
23322: NEG
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: LD_INT 1
23330: PUSH
23331: LD_INT 0
23333: PUSH
23334: EMPTY
23335: LIST
23336: LIST
23337: PUSH
23338: LD_INT 1
23340: PUSH
23341: LD_INT 1
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 0
23350: PUSH
23351: LD_INT 1
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 1
23360: NEG
23361: PUSH
23362: LD_INT 0
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 1
23371: NEG
23372: PUSH
23373: LD_INT 1
23375: NEG
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: PUSH
23381: LD_INT 1
23383: NEG
23384: PUSH
23385: LD_INT 2
23387: NEG
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PUSH
23393: LD_INT 2
23395: PUSH
23396: LD_INT 1
23398: PUSH
23399: EMPTY
23400: LIST
23401: LIST
23402: PUSH
23403: LD_INT 2
23405: PUSH
23406: LD_INT 2
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: LD_INT 1
23415: PUSH
23416: LD_INT 2
23418: PUSH
23419: EMPTY
23420: LIST
23421: LIST
23422: PUSH
23423: LD_INT 2
23425: NEG
23426: PUSH
23427: LD_INT 1
23429: NEG
23430: PUSH
23431: EMPTY
23432: LIST
23433: LIST
23434: PUSH
23435: LD_INT 2
23437: NEG
23438: PUSH
23439: LD_INT 2
23441: NEG
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 2
23449: NEG
23450: PUSH
23451: LD_INT 3
23453: NEG
23454: PUSH
23455: EMPTY
23456: LIST
23457: LIST
23458: PUSH
23459: LD_INT 3
23461: NEG
23462: PUSH
23463: LD_INT 2
23465: NEG
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PUSH
23471: LD_INT 3
23473: NEG
23474: PUSH
23475: LD_INT 3
23477: NEG
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: LIST
23487: LIST
23488: LIST
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: LIST
23494: LIST
23495: LIST
23496: LIST
23497: LIST
23498: LIST
23499: LIST
23500: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23501: LD_ADDR_VAR 0 14
23505: PUSH
23506: LD_INT 0
23508: PUSH
23509: LD_INT 0
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: PUSH
23516: LD_INT 0
23518: PUSH
23519: LD_INT 1
23521: NEG
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PUSH
23527: LD_INT 1
23529: PUSH
23530: LD_INT 0
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PUSH
23537: LD_INT 1
23539: PUSH
23540: LD_INT 1
23542: PUSH
23543: EMPTY
23544: LIST
23545: LIST
23546: PUSH
23547: LD_INT 0
23549: PUSH
23550: LD_INT 1
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: LD_INT 1
23559: NEG
23560: PUSH
23561: LD_INT 0
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: PUSH
23568: LD_INT 1
23570: NEG
23571: PUSH
23572: LD_INT 1
23574: NEG
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PUSH
23580: LD_INT 1
23582: NEG
23583: PUSH
23584: LD_INT 2
23586: NEG
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PUSH
23592: LD_INT 0
23594: PUSH
23595: LD_INT 2
23597: NEG
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: PUSH
23603: LD_INT 1
23605: PUSH
23606: LD_INT 1
23608: NEG
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 1
23616: PUSH
23617: LD_INT 2
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: PUSH
23624: LD_INT 0
23626: PUSH
23627: LD_INT 2
23629: PUSH
23630: EMPTY
23631: LIST
23632: LIST
23633: PUSH
23634: LD_INT 1
23636: NEG
23637: PUSH
23638: LD_INT 1
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: LD_INT 1
23647: NEG
23648: PUSH
23649: LD_INT 3
23651: NEG
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 0
23659: PUSH
23660: LD_INT 3
23662: NEG
23663: PUSH
23664: EMPTY
23665: LIST
23666: LIST
23667: PUSH
23668: LD_INT 1
23670: PUSH
23671: LD_INT 2
23673: NEG
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: LIST
23683: LIST
23684: LIST
23685: LIST
23686: LIST
23687: LIST
23688: LIST
23689: LIST
23690: LIST
23691: LIST
23692: LIST
23693: LIST
23694: LIST
23695: LIST
23696: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
23697: LD_ADDR_VAR 0 15
23701: PUSH
23702: LD_INT 0
23704: PUSH
23705: LD_INT 0
23707: PUSH
23708: EMPTY
23709: LIST
23710: LIST
23711: PUSH
23712: LD_INT 0
23714: PUSH
23715: LD_INT 1
23717: NEG
23718: PUSH
23719: EMPTY
23720: LIST
23721: LIST
23722: PUSH
23723: LD_INT 1
23725: PUSH
23726: LD_INT 0
23728: PUSH
23729: EMPTY
23730: LIST
23731: LIST
23732: PUSH
23733: LD_INT 1
23735: PUSH
23736: LD_INT 1
23738: PUSH
23739: EMPTY
23740: LIST
23741: LIST
23742: PUSH
23743: LD_INT 0
23745: PUSH
23746: LD_INT 1
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PUSH
23753: LD_INT 1
23755: NEG
23756: PUSH
23757: LD_INT 0
23759: PUSH
23760: EMPTY
23761: LIST
23762: LIST
23763: PUSH
23764: LD_INT 1
23766: NEG
23767: PUSH
23768: LD_INT 1
23770: NEG
23771: PUSH
23772: EMPTY
23773: LIST
23774: LIST
23775: PUSH
23776: LD_INT 1
23778: PUSH
23779: LD_INT 1
23781: NEG
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 2
23789: PUSH
23790: LD_INT 0
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 2
23799: PUSH
23800: LD_INT 1
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: LD_INT 1
23809: NEG
23810: PUSH
23811: LD_INT 1
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: PUSH
23818: LD_INT 2
23820: NEG
23821: PUSH
23822: LD_INT 0
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 2
23831: NEG
23832: PUSH
23833: LD_INT 1
23835: NEG
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: LD_INT 2
23843: PUSH
23844: LD_INT 1
23846: NEG
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 3
23854: PUSH
23855: LD_INT 0
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 3
23864: PUSH
23865: LD_INT 1
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: LIST
23880: LIST
23881: LIST
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: LIST
23887: LIST
23888: LIST
23889: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
23890: LD_ADDR_VAR 0 16
23894: PUSH
23895: LD_INT 0
23897: PUSH
23898: LD_INT 0
23900: PUSH
23901: EMPTY
23902: LIST
23903: LIST
23904: PUSH
23905: LD_INT 0
23907: PUSH
23908: LD_INT 1
23910: NEG
23911: PUSH
23912: EMPTY
23913: LIST
23914: LIST
23915: PUSH
23916: LD_INT 1
23918: PUSH
23919: LD_INT 0
23921: PUSH
23922: EMPTY
23923: LIST
23924: LIST
23925: PUSH
23926: LD_INT 1
23928: PUSH
23929: LD_INT 1
23931: PUSH
23932: EMPTY
23933: LIST
23934: LIST
23935: PUSH
23936: LD_INT 0
23938: PUSH
23939: LD_INT 1
23941: PUSH
23942: EMPTY
23943: LIST
23944: LIST
23945: PUSH
23946: LD_INT 1
23948: NEG
23949: PUSH
23950: LD_INT 0
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: LD_INT 1
23959: NEG
23960: PUSH
23961: LD_INT 1
23963: NEG
23964: PUSH
23965: EMPTY
23966: LIST
23967: LIST
23968: PUSH
23969: LD_INT 1
23971: NEG
23972: PUSH
23973: LD_INT 2
23975: NEG
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 2
23983: PUSH
23984: LD_INT 1
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 2
23993: PUSH
23994: LD_INT 2
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PUSH
24001: LD_INT 1
24003: PUSH
24004: LD_INT 2
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 2
24013: NEG
24014: PUSH
24015: LD_INT 1
24017: NEG
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PUSH
24023: LD_INT 2
24025: NEG
24026: PUSH
24027: LD_INT 2
24029: NEG
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: PUSH
24035: LD_INT 3
24037: PUSH
24038: LD_INT 2
24040: PUSH
24041: EMPTY
24042: LIST
24043: LIST
24044: PUSH
24045: LD_INT 3
24047: PUSH
24048: LD_INT 3
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 2
24057: PUSH
24058: LD_INT 3
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: LIST
24072: LIST
24073: LIST
24074: LIST
24075: LIST
24076: LIST
24077: LIST
24078: LIST
24079: LIST
24080: LIST
24081: LIST
24082: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24083: LD_ADDR_VAR 0 17
24087: PUSH
24088: LD_INT 0
24090: PUSH
24091: LD_INT 0
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: LD_INT 0
24100: PUSH
24101: LD_INT 1
24103: NEG
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 1
24111: PUSH
24112: LD_INT 0
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: PUSH
24119: LD_INT 1
24121: PUSH
24122: LD_INT 1
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: PUSH
24129: LD_INT 0
24131: PUSH
24132: LD_INT 1
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: LD_INT 1
24141: NEG
24142: PUSH
24143: LD_INT 0
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: LD_INT 1
24152: NEG
24153: PUSH
24154: LD_INT 1
24156: NEG
24157: PUSH
24158: EMPTY
24159: LIST
24160: LIST
24161: PUSH
24162: LD_INT 1
24164: NEG
24165: PUSH
24166: LD_INT 2
24168: NEG
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PUSH
24174: LD_INT 0
24176: PUSH
24177: LD_INT 2
24179: NEG
24180: PUSH
24181: EMPTY
24182: LIST
24183: LIST
24184: PUSH
24185: LD_INT 1
24187: PUSH
24188: LD_INT 1
24190: NEG
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: PUSH
24196: LD_INT 2
24198: PUSH
24199: LD_INT 0
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: PUSH
24206: LD_INT 2
24208: PUSH
24209: LD_INT 1
24211: PUSH
24212: EMPTY
24213: LIST
24214: LIST
24215: PUSH
24216: LD_INT 2
24218: PUSH
24219: LD_INT 2
24221: PUSH
24222: EMPTY
24223: LIST
24224: LIST
24225: PUSH
24226: LD_INT 1
24228: PUSH
24229: LD_INT 2
24231: PUSH
24232: EMPTY
24233: LIST
24234: LIST
24235: PUSH
24236: LD_INT 0
24238: PUSH
24239: LD_INT 2
24241: PUSH
24242: EMPTY
24243: LIST
24244: LIST
24245: PUSH
24246: LD_INT 1
24248: NEG
24249: PUSH
24250: LD_INT 1
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PUSH
24257: LD_INT 2
24259: NEG
24260: PUSH
24261: LD_INT 0
24263: PUSH
24264: EMPTY
24265: LIST
24266: LIST
24267: PUSH
24268: LD_INT 2
24270: NEG
24271: PUSH
24272: LD_INT 1
24274: NEG
24275: PUSH
24276: EMPTY
24277: LIST
24278: LIST
24279: PUSH
24280: LD_INT 2
24282: NEG
24283: PUSH
24284: LD_INT 2
24286: NEG
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: LIST
24296: LIST
24297: LIST
24298: LIST
24299: LIST
24300: LIST
24301: LIST
24302: LIST
24303: LIST
24304: LIST
24305: LIST
24306: LIST
24307: LIST
24308: LIST
24309: LIST
24310: LIST
24311: LIST
24312: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24313: LD_ADDR_VAR 0 18
24317: PUSH
24318: LD_INT 0
24320: PUSH
24321: LD_INT 0
24323: PUSH
24324: EMPTY
24325: LIST
24326: LIST
24327: PUSH
24328: LD_INT 0
24330: PUSH
24331: LD_INT 1
24333: NEG
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: LD_INT 1
24341: PUSH
24342: LD_INT 0
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: PUSH
24349: LD_INT 1
24351: PUSH
24352: LD_INT 1
24354: PUSH
24355: EMPTY
24356: LIST
24357: LIST
24358: PUSH
24359: LD_INT 0
24361: PUSH
24362: LD_INT 1
24364: PUSH
24365: EMPTY
24366: LIST
24367: LIST
24368: PUSH
24369: LD_INT 1
24371: NEG
24372: PUSH
24373: LD_INT 0
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: PUSH
24380: LD_INT 1
24382: NEG
24383: PUSH
24384: LD_INT 1
24386: NEG
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PUSH
24392: LD_INT 1
24394: NEG
24395: PUSH
24396: LD_INT 2
24398: NEG
24399: PUSH
24400: EMPTY
24401: LIST
24402: LIST
24403: PUSH
24404: LD_INT 0
24406: PUSH
24407: LD_INT 2
24409: NEG
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: PUSH
24415: LD_INT 1
24417: PUSH
24418: LD_INT 1
24420: NEG
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 2
24428: PUSH
24429: LD_INT 0
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: PUSH
24436: LD_INT 2
24438: PUSH
24439: LD_INT 1
24441: PUSH
24442: EMPTY
24443: LIST
24444: LIST
24445: PUSH
24446: LD_INT 2
24448: PUSH
24449: LD_INT 2
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: PUSH
24456: LD_INT 1
24458: PUSH
24459: LD_INT 2
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: PUSH
24466: LD_INT 0
24468: PUSH
24469: LD_INT 2
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: PUSH
24476: LD_INT 1
24478: NEG
24479: PUSH
24480: LD_INT 1
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PUSH
24487: LD_INT 2
24489: NEG
24490: PUSH
24491: LD_INT 0
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: PUSH
24498: LD_INT 2
24500: NEG
24501: PUSH
24502: LD_INT 1
24504: NEG
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: LD_INT 2
24512: NEG
24513: PUSH
24514: LD_INT 2
24516: NEG
24517: PUSH
24518: EMPTY
24519: LIST
24520: LIST
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: LIST
24532: LIST
24533: LIST
24534: LIST
24535: LIST
24536: LIST
24537: LIST
24538: LIST
24539: LIST
24540: LIST
24541: LIST
24542: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24543: LD_ADDR_VAR 0 19
24547: PUSH
24548: LD_INT 0
24550: PUSH
24551: LD_INT 0
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PUSH
24558: LD_INT 0
24560: PUSH
24561: LD_INT 1
24563: NEG
24564: PUSH
24565: EMPTY
24566: LIST
24567: LIST
24568: PUSH
24569: LD_INT 1
24571: PUSH
24572: LD_INT 0
24574: PUSH
24575: EMPTY
24576: LIST
24577: LIST
24578: PUSH
24579: LD_INT 1
24581: PUSH
24582: LD_INT 1
24584: PUSH
24585: EMPTY
24586: LIST
24587: LIST
24588: PUSH
24589: LD_INT 0
24591: PUSH
24592: LD_INT 1
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: PUSH
24599: LD_INT 1
24601: NEG
24602: PUSH
24603: LD_INT 0
24605: PUSH
24606: EMPTY
24607: LIST
24608: LIST
24609: PUSH
24610: LD_INT 1
24612: NEG
24613: PUSH
24614: LD_INT 1
24616: NEG
24617: PUSH
24618: EMPTY
24619: LIST
24620: LIST
24621: PUSH
24622: LD_INT 1
24624: NEG
24625: PUSH
24626: LD_INT 2
24628: NEG
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: PUSH
24634: LD_INT 0
24636: PUSH
24637: LD_INT 2
24639: NEG
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: PUSH
24645: LD_INT 1
24647: PUSH
24648: LD_INT 1
24650: NEG
24651: PUSH
24652: EMPTY
24653: LIST
24654: LIST
24655: PUSH
24656: LD_INT 2
24658: PUSH
24659: LD_INT 0
24661: PUSH
24662: EMPTY
24663: LIST
24664: LIST
24665: PUSH
24666: LD_INT 2
24668: PUSH
24669: LD_INT 1
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: PUSH
24676: LD_INT 2
24678: PUSH
24679: LD_INT 2
24681: PUSH
24682: EMPTY
24683: LIST
24684: LIST
24685: PUSH
24686: LD_INT 1
24688: PUSH
24689: LD_INT 2
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 0
24698: PUSH
24699: LD_INT 2
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 1
24708: NEG
24709: PUSH
24710: LD_INT 1
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 2
24719: NEG
24720: PUSH
24721: LD_INT 0
24723: PUSH
24724: EMPTY
24725: LIST
24726: LIST
24727: PUSH
24728: LD_INT 2
24730: NEG
24731: PUSH
24732: LD_INT 1
24734: NEG
24735: PUSH
24736: EMPTY
24737: LIST
24738: LIST
24739: PUSH
24740: LD_INT 2
24742: NEG
24743: PUSH
24744: LD_INT 2
24746: NEG
24747: PUSH
24748: EMPTY
24749: LIST
24750: LIST
24751: PUSH
24752: EMPTY
24753: LIST
24754: LIST
24755: LIST
24756: LIST
24757: LIST
24758: LIST
24759: LIST
24760: LIST
24761: LIST
24762: LIST
24763: LIST
24764: LIST
24765: LIST
24766: LIST
24767: LIST
24768: LIST
24769: LIST
24770: LIST
24771: LIST
24772: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24773: LD_ADDR_VAR 0 20
24777: PUSH
24778: LD_INT 0
24780: PUSH
24781: LD_INT 0
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: PUSH
24788: LD_INT 0
24790: PUSH
24791: LD_INT 1
24793: NEG
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PUSH
24799: LD_INT 1
24801: PUSH
24802: LD_INT 0
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: LD_INT 1
24811: PUSH
24812: LD_INT 1
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PUSH
24819: LD_INT 0
24821: PUSH
24822: LD_INT 1
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: PUSH
24829: LD_INT 1
24831: NEG
24832: PUSH
24833: LD_INT 0
24835: PUSH
24836: EMPTY
24837: LIST
24838: LIST
24839: PUSH
24840: LD_INT 1
24842: NEG
24843: PUSH
24844: LD_INT 1
24846: NEG
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: PUSH
24852: LD_INT 1
24854: NEG
24855: PUSH
24856: LD_INT 2
24858: NEG
24859: PUSH
24860: EMPTY
24861: LIST
24862: LIST
24863: PUSH
24864: LD_INT 0
24866: PUSH
24867: LD_INT 2
24869: NEG
24870: PUSH
24871: EMPTY
24872: LIST
24873: LIST
24874: PUSH
24875: LD_INT 1
24877: PUSH
24878: LD_INT 1
24880: NEG
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: PUSH
24886: LD_INT 2
24888: PUSH
24889: LD_INT 0
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: LD_INT 2
24898: PUSH
24899: LD_INT 1
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_INT 2
24908: PUSH
24909: LD_INT 2
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: PUSH
24916: LD_INT 1
24918: PUSH
24919: LD_INT 2
24921: PUSH
24922: EMPTY
24923: LIST
24924: LIST
24925: PUSH
24926: LD_INT 0
24928: PUSH
24929: LD_INT 2
24931: PUSH
24932: EMPTY
24933: LIST
24934: LIST
24935: PUSH
24936: LD_INT 1
24938: NEG
24939: PUSH
24940: LD_INT 1
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PUSH
24947: LD_INT 2
24949: NEG
24950: PUSH
24951: LD_INT 0
24953: PUSH
24954: EMPTY
24955: LIST
24956: LIST
24957: PUSH
24958: LD_INT 2
24960: NEG
24961: PUSH
24962: LD_INT 1
24964: NEG
24965: PUSH
24966: EMPTY
24967: LIST
24968: LIST
24969: PUSH
24970: LD_INT 2
24972: NEG
24973: PUSH
24974: LD_INT 2
24976: NEG
24977: PUSH
24978: EMPTY
24979: LIST
24980: LIST
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: LIST
24986: LIST
24987: LIST
24988: LIST
24989: LIST
24990: LIST
24991: LIST
24992: LIST
24993: LIST
24994: LIST
24995: LIST
24996: LIST
24997: LIST
24998: LIST
24999: LIST
25000: LIST
25001: LIST
25002: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25003: LD_ADDR_VAR 0 21
25007: PUSH
25008: LD_INT 0
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: EMPTY
25015: LIST
25016: LIST
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 1
25023: NEG
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 1
25031: PUSH
25032: LD_INT 0
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 1
25041: PUSH
25042: LD_INT 1
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 0
25051: PUSH
25052: LD_INT 1
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: PUSH
25059: LD_INT 1
25061: NEG
25062: PUSH
25063: LD_INT 0
25065: PUSH
25066: EMPTY
25067: LIST
25068: LIST
25069: PUSH
25070: LD_INT 1
25072: NEG
25073: PUSH
25074: LD_INT 1
25076: NEG
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 1
25084: NEG
25085: PUSH
25086: LD_INT 2
25088: NEG
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PUSH
25094: LD_INT 0
25096: PUSH
25097: LD_INT 2
25099: NEG
25100: PUSH
25101: EMPTY
25102: LIST
25103: LIST
25104: PUSH
25105: LD_INT 1
25107: PUSH
25108: LD_INT 1
25110: NEG
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: PUSH
25116: LD_INT 2
25118: PUSH
25119: LD_INT 0
25121: PUSH
25122: EMPTY
25123: LIST
25124: LIST
25125: PUSH
25126: LD_INT 2
25128: PUSH
25129: LD_INT 1
25131: PUSH
25132: EMPTY
25133: LIST
25134: LIST
25135: PUSH
25136: LD_INT 2
25138: PUSH
25139: LD_INT 2
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: LD_INT 1
25148: PUSH
25149: LD_INT 2
25151: PUSH
25152: EMPTY
25153: LIST
25154: LIST
25155: PUSH
25156: LD_INT 0
25158: PUSH
25159: LD_INT 2
25161: PUSH
25162: EMPTY
25163: LIST
25164: LIST
25165: PUSH
25166: LD_INT 1
25168: NEG
25169: PUSH
25170: LD_INT 1
25172: PUSH
25173: EMPTY
25174: LIST
25175: LIST
25176: PUSH
25177: LD_INT 2
25179: NEG
25180: PUSH
25181: LD_INT 0
25183: PUSH
25184: EMPTY
25185: LIST
25186: LIST
25187: PUSH
25188: LD_INT 2
25190: NEG
25191: PUSH
25192: LD_INT 1
25194: NEG
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PUSH
25200: LD_INT 2
25202: NEG
25203: PUSH
25204: LD_INT 2
25206: NEG
25207: PUSH
25208: EMPTY
25209: LIST
25210: LIST
25211: PUSH
25212: EMPTY
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: LIST
25219: LIST
25220: LIST
25221: LIST
25222: LIST
25223: LIST
25224: LIST
25225: LIST
25226: LIST
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25233: LD_ADDR_VAR 0 22
25237: PUSH
25238: LD_INT 0
25240: PUSH
25241: LD_INT 0
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 0
25250: PUSH
25251: LD_INT 1
25253: NEG
25254: PUSH
25255: EMPTY
25256: LIST
25257: LIST
25258: PUSH
25259: LD_INT 1
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: EMPTY
25266: LIST
25267: LIST
25268: PUSH
25269: LD_INT 1
25271: PUSH
25272: LD_INT 1
25274: PUSH
25275: EMPTY
25276: LIST
25277: LIST
25278: PUSH
25279: LD_INT 0
25281: PUSH
25282: LD_INT 1
25284: PUSH
25285: EMPTY
25286: LIST
25287: LIST
25288: PUSH
25289: LD_INT 1
25291: NEG
25292: PUSH
25293: LD_INT 0
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: PUSH
25300: LD_INT 1
25302: NEG
25303: PUSH
25304: LD_INT 1
25306: NEG
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: PUSH
25312: LD_INT 1
25314: NEG
25315: PUSH
25316: LD_INT 2
25318: NEG
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: LD_INT 0
25326: PUSH
25327: LD_INT 2
25329: NEG
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 1
25337: PUSH
25338: LD_INT 1
25340: NEG
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PUSH
25346: LD_INT 2
25348: PUSH
25349: LD_INT 0
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: PUSH
25356: LD_INT 2
25358: PUSH
25359: LD_INT 1
25361: PUSH
25362: EMPTY
25363: LIST
25364: LIST
25365: PUSH
25366: LD_INT 2
25368: PUSH
25369: LD_INT 2
25371: PUSH
25372: EMPTY
25373: LIST
25374: LIST
25375: PUSH
25376: LD_INT 1
25378: PUSH
25379: LD_INT 2
25381: PUSH
25382: EMPTY
25383: LIST
25384: LIST
25385: PUSH
25386: LD_INT 0
25388: PUSH
25389: LD_INT 2
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 1
25398: NEG
25399: PUSH
25400: LD_INT 1
25402: PUSH
25403: EMPTY
25404: LIST
25405: LIST
25406: PUSH
25407: LD_INT 2
25409: NEG
25410: PUSH
25411: LD_INT 0
25413: PUSH
25414: EMPTY
25415: LIST
25416: LIST
25417: PUSH
25418: LD_INT 2
25420: NEG
25421: PUSH
25422: LD_INT 1
25424: NEG
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PUSH
25430: LD_INT 2
25432: NEG
25433: PUSH
25434: LD_INT 2
25436: NEG
25437: PUSH
25438: EMPTY
25439: LIST
25440: LIST
25441: PUSH
25442: EMPTY
25443: LIST
25444: LIST
25445: LIST
25446: LIST
25447: LIST
25448: LIST
25449: LIST
25450: LIST
25451: LIST
25452: LIST
25453: LIST
25454: LIST
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: LIST
25461: LIST
25462: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25463: LD_ADDR_VAR 0 23
25467: PUSH
25468: LD_INT 0
25470: PUSH
25471: LD_INT 0
25473: PUSH
25474: EMPTY
25475: LIST
25476: LIST
25477: PUSH
25478: LD_INT 0
25480: PUSH
25481: LD_INT 1
25483: NEG
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: PUSH
25489: LD_INT 1
25491: PUSH
25492: LD_INT 0
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 1
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: EMPTY
25506: LIST
25507: LIST
25508: PUSH
25509: LD_INT 0
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: PUSH
25519: LD_INT 1
25521: NEG
25522: PUSH
25523: LD_INT 0
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 1
25532: NEG
25533: PUSH
25534: LD_INT 1
25536: NEG
25537: PUSH
25538: EMPTY
25539: LIST
25540: LIST
25541: PUSH
25542: LD_INT 1
25544: NEG
25545: PUSH
25546: LD_INT 2
25548: NEG
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 0
25556: PUSH
25557: LD_INT 2
25559: NEG
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PUSH
25565: LD_INT 1
25567: PUSH
25568: LD_INT 1
25570: NEG
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 0
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 2
25588: PUSH
25589: LD_INT 1
25591: PUSH
25592: EMPTY
25593: LIST
25594: LIST
25595: PUSH
25596: LD_INT 2
25598: PUSH
25599: LD_INT 2
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 1
25608: PUSH
25609: LD_INT 2
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PUSH
25616: LD_INT 0
25618: PUSH
25619: LD_INT 2
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: PUSH
25626: LD_INT 1
25628: NEG
25629: PUSH
25630: LD_INT 1
25632: PUSH
25633: EMPTY
25634: LIST
25635: LIST
25636: PUSH
25637: LD_INT 2
25639: NEG
25640: PUSH
25641: LD_INT 0
25643: PUSH
25644: EMPTY
25645: LIST
25646: LIST
25647: PUSH
25648: LD_INT 2
25650: NEG
25651: PUSH
25652: LD_INT 1
25654: NEG
25655: PUSH
25656: EMPTY
25657: LIST
25658: LIST
25659: PUSH
25660: LD_INT 2
25662: NEG
25663: PUSH
25664: LD_INT 2
25666: NEG
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 2
25674: NEG
25675: PUSH
25676: LD_INT 3
25678: NEG
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 1
25686: NEG
25687: PUSH
25688: LD_INT 3
25690: NEG
25691: PUSH
25692: EMPTY
25693: LIST
25694: LIST
25695: PUSH
25696: LD_INT 1
25698: PUSH
25699: LD_INT 2
25701: NEG
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: LD_INT 1
25712: NEG
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: LIST
25722: LIST
25723: LIST
25724: LIST
25725: LIST
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: LIST
25731: LIST
25732: LIST
25733: LIST
25734: LIST
25735: LIST
25736: LIST
25737: LIST
25738: LIST
25739: LIST
25740: LIST
25741: LIST
25742: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
25743: LD_ADDR_VAR 0 24
25747: PUSH
25748: LD_INT 0
25750: PUSH
25751: LD_INT 0
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: PUSH
25758: LD_INT 0
25760: PUSH
25761: LD_INT 1
25763: NEG
25764: PUSH
25765: EMPTY
25766: LIST
25767: LIST
25768: PUSH
25769: LD_INT 1
25771: PUSH
25772: LD_INT 0
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: PUSH
25779: LD_INT 1
25781: PUSH
25782: LD_INT 1
25784: PUSH
25785: EMPTY
25786: LIST
25787: LIST
25788: PUSH
25789: LD_INT 0
25791: PUSH
25792: LD_INT 1
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: LD_INT 1
25801: NEG
25802: PUSH
25803: LD_INT 0
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: PUSH
25810: LD_INT 1
25812: NEG
25813: PUSH
25814: LD_INT 1
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 1
25824: NEG
25825: PUSH
25826: LD_INT 2
25828: NEG
25829: PUSH
25830: EMPTY
25831: LIST
25832: LIST
25833: PUSH
25834: LD_INT 0
25836: PUSH
25837: LD_INT 2
25839: NEG
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: PUSH
25845: LD_INT 1
25847: PUSH
25848: LD_INT 1
25850: NEG
25851: PUSH
25852: EMPTY
25853: LIST
25854: LIST
25855: PUSH
25856: LD_INT 2
25858: PUSH
25859: LD_INT 0
25861: PUSH
25862: EMPTY
25863: LIST
25864: LIST
25865: PUSH
25866: LD_INT 2
25868: PUSH
25869: LD_INT 1
25871: PUSH
25872: EMPTY
25873: LIST
25874: LIST
25875: PUSH
25876: LD_INT 2
25878: PUSH
25879: LD_INT 2
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 1
25888: PUSH
25889: LD_INT 2
25891: PUSH
25892: EMPTY
25893: LIST
25894: LIST
25895: PUSH
25896: LD_INT 0
25898: PUSH
25899: LD_INT 2
25901: PUSH
25902: EMPTY
25903: LIST
25904: LIST
25905: PUSH
25906: LD_INT 1
25908: NEG
25909: PUSH
25910: LD_INT 1
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 2
25919: NEG
25920: PUSH
25921: LD_INT 0
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: PUSH
25928: LD_INT 2
25930: NEG
25931: PUSH
25932: LD_INT 1
25934: NEG
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 2
25942: NEG
25943: PUSH
25944: LD_INT 2
25946: NEG
25947: PUSH
25948: EMPTY
25949: LIST
25950: LIST
25951: PUSH
25952: LD_INT 1
25954: PUSH
25955: LD_INT 2
25957: NEG
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 2
25965: PUSH
25966: LD_INT 1
25968: NEG
25969: PUSH
25970: EMPTY
25971: LIST
25972: LIST
25973: PUSH
25974: LD_INT 3
25976: PUSH
25977: LD_INT 1
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 3
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: EMPTY
25995: LIST
25996: LIST
25997: LIST
25998: LIST
25999: LIST
26000: LIST
26001: LIST
26002: LIST
26003: LIST
26004: LIST
26005: LIST
26006: LIST
26007: LIST
26008: LIST
26009: LIST
26010: LIST
26011: LIST
26012: LIST
26013: LIST
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26019: LD_ADDR_VAR 0 25
26023: PUSH
26024: LD_INT 0
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 0
26036: PUSH
26037: LD_INT 1
26039: NEG
26040: PUSH
26041: EMPTY
26042: LIST
26043: LIST
26044: PUSH
26045: LD_INT 1
26047: PUSH
26048: LD_INT 0
26050: PUSH
26051: EMPTY
26052: LIST
26053: LIST
26054: PUSH
26055: LD_INT 1
26057: PUSH
26058: LD_INT 1
26060: PUSH
26061: EMPTY
26062: LIST
26063: LIST
26064: PUSH
26065: LD_INT 0
26067: PUSH
26068: LD_INT 1
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 1
26077: NEG
26078: PUSH
26079: LD_INT 0
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 1
26088: NEG
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 1
26100: NEG
26101: PUSH
26102: LD_INT 2
26104: NEG
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 2
26115: NEG
26116: PUSH
26117: EMPTY
26118: LIST
26119: LIST
26120: PUSH
26121: LD_INT 1
26123: PUSH
26124: LD_INT 1
26126: NEG
26127: PUSH
26128: EMPTY
26129: LIST
26130: LIST
26131: PUSH
26132: LD_INT 2
26134: PUSH
26135: LD_INT 0
26137: PUSH
26138: EMPTY
26139: LIST
26140: LIST
26141: PUSH
26142: LD_INT 2
26144: PUSH
26145: LD_INT 1
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 2
26154: PUSH
26155: LD_INT 2
26157: PUSH
26158: EMPTY
26159: LIST
26160: LIST
26161: PUSH
26162: LD_INT 1
26164: PUSH
26165: LD_INT 2
26167: PUSH
26168: EMPTY
26169: LIST
26170: LIST
26171: PUSH
26172: LD_INT 0
26174: PUSH
26175: LD_INT 2
26177: PUSH
26178: EMPTY
26179: LIST
26180: LIST
26181: PUSH
26182: LD_INT 1
26184: NEG
26185: PUSH
26186: LD_INT 1
26188: PUSH
26189: EMPTY
26190: LIST
26191: LIST
26192: PUSH
26193: LD_INT 2
26195: NEG
26196: PUSH
26197: LD_INT 0
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: PUSH
26204: LD_INT 2
26206: NEG
26207: PUSH
26208: LD_INT 1
26210: NEG
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 2
26218: NEG
26219: PUSH
26220: LD_INT 2
26222: NEG
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 3
26230: PUSH
26231: LD_INT 1
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 3
26240: PUSH
26241: LD_INT 2
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 2
26250: PUSH
26251: LD_INT 3
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: PUSH
26258: LD_INT 1
26260: PUSH
26261: LD_INT 3
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: EMPTY
26269: LIST
26270: LIST
26271: LIST
26272: LIST
26273: LIST
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26293: LD_ADDR_VAR 0 26
26297: PUSH
26298: LD_INT 0
26300: PUSH
26301: LD_INT 0
26303: PUSH
26304: EMPTY
26305: LIST
26306: LIST
26307: PUSH
26308: LD_INT 0
26310: PUSH
26311: LD_INT 1
26313: NEG
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 1
26321: PUSH
26322: LD_INT 0
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: PUSH
26329: LD_INT 1
26331: PUSH
26332: LD_INT 1
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 0
26341: PUSH
26342: LD_INT 1
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 1
26351: NEG
26352: PUSH
26353: LD_INT 0
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: PUSH
26360: LD_INT 1
26362: NEG
26363: PUSH
26364: LD_INT 1
26366: NEG
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 1
26374: NEG
26375: PUSH
26376: LD_INT 2
26378: NEG
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 0
26386: PUSH
26387: LD_INT 2
26389: NEG
26390: PUSH
26391: EMPTY
26392: LIST
26393: LIST
26394: PUSH
26395: LD_INT 1
26397: PUSH
26398: LD_INT 1
26400: NEG
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: PUSH
26406: LD_INT 2
26408: PUSH
26409: LD_INT 0
26411: PUSH
26412: EMPTY
26413: LIST
26414: LIST
26415: PUSH
26416: LD_INT 2
26418: PUSH
26419: LD_INT 1
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: PUSH
26426: LD_INT 2
26428: PUSH
26429: LD_INT 2
26431: PUSH
26432: EMPTY
26433: LIST
26434: LIST
26435: PUSH
26436: LD_INT 1
26438: PUSH
26439: LD_INT 2
26441: PUSH
26442: EMPTY
26443: LIST
26444: LIST
26445: PUSH
26446: LD_INT 0
26448: PUSH
26449: LD_INT 2
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: PUSH
26456: LD_INT 1
26458: NEG
26459: PUSH
26460: LD_INT 1
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PUSH
26467: LD_INT 2
26469: NEG
26470: PUSH
26471: LD_INT 0
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 2
26480: NEG
26481: PUSH
26482: LD_INT 1
26484: NEG
26485: PUSH
26486: EMPTY
26487: LIST
26488: LIST
26489: PUSH
26490: LD_INT 2
26492: NEG
26493: PUSH
26494: LD_INT 2
26496: NEG
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: PUSH
26502: LD_INT 2
26504: PUSH
26505: LD_INT 3
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 1
26514: PUSH
26515: LD_INT 3
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: LD_INT 1
26524: NEG
26525: PUSH
26526: LD_INT 2
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 2
26535: NEG
26536: PUSH
26537: LD_INT 1
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: EMPTY
26545: LIST
26546: LIST
26547: LIST
26548: LIST
26549: LIST
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
26569: LD_ADDR_VAR 0 27
26573: PUSH
26574: LD_INT 0
26576: PUSH
26577: LD_INT 0
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: LD_INT 0
26586: PUSH
26587: LD_INT 1
26589: NEG
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 1
26597: PUSH
26598: LD_INT 0
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 1
26607: PUSH
26608: LD_INT 1
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 0
26617: PUSH
26618: LD_INT 1
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: PUSH
26625: LD_INT 1
26627: NEG
26628: PUSH
26629: LD_INT 0
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 1
26638: NEG
26639: PUSH
26640: LD_INT 1
26642: NEG
26643: PUSH
26644: EMPTY
26645: LIST
26646: LIST
26647: PUSH
26648: LD_INT 1
26650: NEG
26651: PUSH
26652: LD_INT 2
26654: NEG
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: PUSH
26660: LD_INT 0
26662: PUSH
26663: LD_INT 2
26665: NEG
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 1
26673: PUSH
26674: LD_INT 1
26676: NEG
26677: PUSH
26678: EMPTY
26679: LIST
26680: LIST
26681: PUSH
26682: LD_INT 2
26684: PUSH
26685: LD_INT 0
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: PUSH
26692: LD_INT 2
26694: PUSH
26695: LD_INT 1
26697: PUSH
26698: EMPTY
26699: LIST
26700: LIST
26701: PUSH
26702: LD_INT 2
26704: PUSH
26705: LD_INT 2
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: PUSH
26712: LD_INT 1
26714: PUSH
26715: LD_INT 2
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 0
26724: PUSH
26725: LD_INT 2
26727: PUSH
26728: EMPTY
26729: LIST
26730: LIST
26731: PUSH
26732: LD_INT 1
26734: NEG
26735: PUSH
26736: LD_INT 1
26738: PUSH
26739: EMPTY
26740: LIST
26741: LIST
26742: PUSH
26743: LD_INT 2
26745: NEG
26746: PUSH
26747: LD_INT 0
26749: PUSH
26750: EMPTY
26751: LIST
26752: LIST
26753: PUSH
26754: LD_INT 2
26756: NEG
26757: PUSH
26758: LD_INT 1
26760: NEG
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: LD_INT 2
26772: NEG
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: LD_INT 1
26780: NEG
26781: PUSH
26782: LD_INT 2
26784: PUSH
26785: EMPTY
26786: LIST
26787: LIST
26788: PUSH
26789: LD_INT 2
26791: NEG
26792: PUSH
26793: LD_INT 1
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 3
26802: NEG
26803: PUSH
26804: LD_INT 1
26806: NEG
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 3
26814: NEG
26815: PUSH
26816: LD_INT 2
26818: NEG
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: LIST
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: LIST
26845: LIST
26846: LIST
26847: LIST
26848: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
26849: LD_ADDR_VAR 0 28
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 0
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: LD_INT 0
26866: PUSH
26867: LD_INT 1
26869: NEG
26870: PUSH
26871: EMPTY
26872: LIST
26873: LIST
26874: PUSH
26875: LD_INT 1
26877: PUSH
26878: LD_INT 0
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 1
26887: PUSH
26888: LD_INT 1
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 0
26897: PUSH
26898: LD_INT 1
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 1
26907: NEG
26908: PUSH
26909: LD_INT 0
26911: PUSH
26912: EMPTY
26913: LIST
26914: LIST
26915: PUSH
26916: LD_INT 1
26918: NEG
26919: PUSH
26920: LD_INT 1
26922: NEG
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 1
26930: NEG
26931: PUSH
26932: LD_INT 2
26934: NEG
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 0
26942: PUSH
26943: LD_INT 2
26945: NEG
26946: PUSH
26947: EMPTY
26948: LIST
26949: LIST
26950: PUSH
26951: LD_INT 1
26953: PUSH
26954: LD_INT 1
26956: NEG
26957: PUSH
26958: EMPTY
26959: LIST
26960: LIST
26961: PUSH
26962: LD_INT 2
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: LD_INT 2
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 2
26984: PUSH
26985: LD_INT 2
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: PUSH
26995: LD_INT 2
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: PUSH
27002: LD_INT 0
27004: PUSH
27005: LD_INT 2
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 1
27014: NEG
27015: PUSH
27016: LD_INT 1
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: PUSH
27023: LD_INT 2
27025: NEG
27026: PUSH
27027: LD_INT 0
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 2
27036: NEG
27037: PUSH
27038: LD_INT 1
27040: NEG
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 2
27048: NEG
27049: PUSH
27050: LD_INT 2
27052: NEG
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: PUSH
27058: LD_INT 2
27060: NEG
27061: PUSH
27062: LD_INT 3
27064: NEG
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 1
27072: NEG
27073: PUSH
27074: LD_INT 3
27076: NEG
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 3
27084: NEG
27085: PUSH
27086: LD_INT 1
27088: NEG
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 3
27096: NEG
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: LIST
27110: LIST
27111: LIST
27112: LIST
27113: LIST
27114: LIST
27115: LIST
27116: LIST
27117: LIST
27118: LIST
27119: LIST
27120: LIST
27121: LIST
27122: LIST
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27131: LD_ADDR_VAR 0 29
27135: PUSH
27136: LD_INT 0
27138: PUSH
27139: LD_INT 0
27141: PUSH
27142: EMPTY
27143: LIST
27144: LIST
27145: PUSH
27146: LD_INT 0
27148: PUSH
27149: LD_INT 1
27151: NEG
27152: PUSH
27153: EMPTY
27154: LIST
27155: LIST
27156: PUSH
27157: LD_INT 1
27159: PUSH
27160: LD_INT 0
27162: PUSH
27163: EMPTY
27164: LIST
27165: LIST
27166: PUSH
27167: LD_INT 1
27169: PUSH
27170: LD_INT 1
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: LD_INT 1
27182: PUSH
27183: EMPTY
27184: LIST
27185: LIST
27186: PUSH
27187: LD_INT 1
27189: NEG
27190: PUSH
27191: LD_INT 0
27193: PUSH
27194: EMPTY
27195: LIST
27196: LIST
27197: PUSH
27198: LD_INT 1
27200: NEG
27201: PUSH
27202: LD_INT 1
27204: NEG
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 2
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 0
27224: PUSH
27225: LD_INT 2
27227: NEG
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: PUSH
27236: LD_INT 1
27238: NEG
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: LD_INT 2
27246: PUSH
27247: LD_INT 0
27249: PUSH
27250: EMPTY
27251: LIST
27252: LIST
27253: PUSH
27254: LD_INT 2
27256: PUSH
27257: LD_INT 1
27259: PUSH
27260: EMPTY
27261: LIST
27262: LIST
27263: PUSH
27264: LD_INT 1
27266: PUSH
27267: LD_INT 2
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 0
27276: PUSH
27277: LD_INT 2
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 1
27286: NEG
27287: PUSH
27288: LD_INT 1
27290: PUSH
27291: EMPTY
27292: LIST
27293: LIST
27294: PUSH
27295: LD_INT 2
27297: NEG
27298: PUSH
27299: LD_INT 1
27301: NEG
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 2
27309: NEG
27310: PUSH
27311: LD_INT 2
27313: NEG
27314: PUSH
27315: EMPTY
27316: LIST
27317: LIST
27318: PUSH
27319: LD_INT 2
27321: NEG
27322: PUSH
27323: LD_INT 3
27325: NEG
27326: PUSH
27327: EMPTY
27328: LIST
27329: LIST
27330: PUSH
27331: LD_INT 2
27333: PUSH
27334: LD_INT 1
27336: NEG
27337: PUSH
27338: EMPTY
27339: LIST
27340: LIST
27341: PUSH
27342: LD_INT 3
27344: PUSH
27345: LD_INT 1
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: LD_INT 1
27354: PUSH
27355: LD_INT 3
27357: PUSH
27358: EMPTY
27359: LIST
27360: LIST
27361: PUSH
27362: LD_INT 1
27364: NEG
27365: PUSH
27366: LD_INT 2
27368: PUSH
27369: EMPTY
27370: LIST
27371: LIST
27372: PUSH
27373: LD_INT 3
27375: NEG
27376: PUSH
27377: LD_INT 2
27379: NEG
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: LIST
27399: LIST
27400: LIST
27401: LIST
27402: LIST
27403: LIST
27404: LIST
27405: LIST
27406: LIST
27407: LIST
27408: LIST
27409: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27410: LD_ADDR_VAR 0 30
27414: PUSH
27415: LD_INT 0
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 0
27427: PUSH
27428: LD_INT 1
27430: NEG
27431: PUSH
27432: EMPTY
27433: LIST
27434: LIST
27435: PUSH
27436: LD_INT 1
27438: PUSH
27439: LD_INT 0
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PUSH
27446: LD_INT 1
27448: PUSH
27449: LD_INT 1
27451: PUSH
27452: EMPTY
27453: LIST
27454: LIST
27455: PUSH
27456: LD_INT 0
27458: PUSH
27459: LD_INT 1
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: LD_INT 1
27468: NEG
27469: PUSH
27470: LD_INT 0
27472: PUSH
27473: EMPTY
27474: LIST
27475: LIST
27476: PUSH
27477: LD_INT 1
27479: NEG
27480: PUSH
27481: LD_INT 1
27483: NEG
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: LD_INT 1
27491: NEG
27492: PUSH
27493: LD_INT 2
27495: NEG
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: PUSH
27501: LD_INT 0
27503: PUSH
27504: LD_INT 2
27506: NEG
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 1
27514: PUSH
27515: LD_INT 1
27517: NEG
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 2
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 2
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 2
27545: PUSH
27546: LD_INT 2
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: LD_INT 1
27555: PUSH
27556: LD_INT 2
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 1
27565: NEG
27566: PUSH
27567: LD_INT 1
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: LD_INT 0
27580: PUSH
27581: EMPTY
27582: LIST
27583: LIST
27584: PUSH
27585: LD_INT 2
27587: NEG
27588: PUSH
27589: LD_INT 1
27591: NEG
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 1
27599: NEG
27600: PUSH
27601: LD_INT 3
27603: NEG
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: LD_INT 1
27611: PUSH
27612: LD_INT 2
27614: NEG
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 3
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 2
27632: PUSH
27633: LD_INT 3
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 2
27642: NEG
27643: PUSH
27644: LD_INT 1
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 3
27653: NEG
27654: PUSH
27655: LD_INT 1
27657: NEG
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: LIST
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27688: LD_ADDR_VAR 0 31
27692: PUSH
27693: LD_INT 0
27695: PUSH
27696: LD_INT 0
27698: PUSH
27699: EMPTY
27700: LIST
27701: LIST
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 1
27708: NEG
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 1
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 1
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: LD_INT 0
27736: PUSH
27737: LD_INT 1
27739: PUSH
27740: EMPTY
27741: LIST
27742: LIST
27743: PUSH
27744: LD_INT 1
27746: NEG
27747: PUSH
27748: LD_INT 0
27750: PUSH
27751: EMPTY
27752: LIST
27753: LIST
27754: PUSH
27755: LD_INT 1
27757: NEG
27758: PUSH
27759: LD_INT 1
27761: NEG
27762: PUSH
27763: EMPTY
27764: LIST
27765: LIST
27766: PUSH
27767: LD_INT 1
27769: NEG
27770: PUSH
27771: LD_INT 2
27773: NEG
27774: PUSH
27775: EMPTY
27776: LIST
27777: LIST
27778: PUSH
27779: LD_INT 1
27781: PUSH
27782: LD_INT 1
27784: NEG
27785: PUSH
27786: EMPTY
27787: LIST
27788: LIST
27789: PUSH
27790: LD_INT 2
27792: PUSH
27793: LD_INT 0
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: PUSH
27803: LD_INT 1
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: PUSH
27810: LD_INT 2
27812: PUSH
27813: LD_INT 2
27815: PUSH
27816: EMPTY
27817: LIST
27818: LIST
27819: PUSH
27820: LD_INT 1
27822: PUSH
27823: LD_INT 2
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 0
27832: PUSH
27833: LD_INT 2
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 1
27842: NEG
27843: PUSH
27844: LD_INT 1
27846: PUSH
27847: EMPTY
27848: LIST
27849: LIST
27850: PUSH
27851: LD_INT 2
27853: NEG
27854: PUSH
27855: LD_INT 1
27857: NEG
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 2
27865: NEG
27866: PUSH
27867: LD_INT 2
27869: NEG
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 2
27877: NEG
27878: PUSH
27879: LD_INT 3
27881: NEG
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 2
27889: PUSH
27890: LD_INT 1
27892: NEG
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 3
27900: PUSH
27901: LD_INT 1
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: LD_INT 1
27910: PUSH
27911: LD_INT 3
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 1
27920: NEG
27921: PUSH
27922: LD_INT 2
27924: PUSH
27925: EMPTY
27926: LIST
27927: LIST
27928: PUSH
27929: LD_INT 3
27931: NEG
27932: PUSH
27933: LD_INT 2
27935: NEG
27936: PUSH
27937: EMPTY
27938: LIST
27939: LIST
27940: PUSH
27941: EMPTY
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: LIST
27947: LIST
27948: LIST
27949: LIST
27950: LIST
27951: LIST
27952: LIST
27953: LIST
27954: LIST
27955: LIST
27956: LIST
27957: LIST
27958: LIST
27959: LIST
27960: LIST
27961: LIST
27962: LIST
27963: LIST
27964: LIST
27965: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27966: LD_ADDR_VAR 0 32
27970: PUSH
27971: LD_INT 0
27973: PUSH
27974: LD_INT 0
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 0
27983: PUSH
27984: LD_INT 1
27986: NEG
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: LD_INT 0
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 1
28004: PUSH
28005: LD_INT 1
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 0
28014: PUSH
28015: LD_INT 1
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: LD_INT 0
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 1
28035: NEG
28036: PUSH
28037: LD_INT 1
28039: NEG
28040: PUSH
28041: EMPTY
28042: LIST
28043: LIST
28044: PUSH
28045: LD_INT 1
28047: NEG
28048: PUSH
28049: LD_INT 2
28051: NEG
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 0
28059: PUSH
28060: LD_INT 2
28062: NEG
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 1
28070: PUSH
28071: LD_INT 1
28073: NEG
28074: PUSH
28075: EMPTY
28076: LIST
28077: LIST
28078: PUSH
28079: LD_INT 2
28081: PUSH
28082: LD_INT 1
28084: PUSH
28085: EMPTY
28086: LIST
28087: LIST
28088: PUSH
28089: LD_INT 2
28091: PUSH
28092: LD_INT 2
28094: PUSH
28095: EMPTY
28096: LIST
28097: LIST
28098: PUSH
28099: LD_INT 1
28101: PUSH
28102: LD_INT 2
28104: PUSH
28105: EMPTY
28106: LIST
28107: LIST
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: LD_INT 2
28114: PUSH
28115: EMPTY
28116: LIST
28117: LIST
28118: PUSH
28119: LD_INT 1
28121: NEG
28122: PUSH
28123: LD_INT 1
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 2
28132: NEG
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 2
28143: NEG
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: NEG
28156: PUSH
28157: LD_INT 3
28159: NEG
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: PUSH
28165: LD_INT 1
28167: PUSH
28168: LD_INT 2
28170: NEG
28171: PUSH
28172: EMPTY
28173: LIST
28174: LIST
28175: PUSH
28176: LD_INT 3
28178: PUSH
28179: LD_INT 2
28181: PUSH
28182: EMPTY
28183: LIST
28184: LIST
28185: PUSH
28186: LD_INT 2
28188: PUSH
28189: LD_INT 3
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 2
28198: NEG
28199: PUSH
28200: LD_INT 1
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 3
28209: NEG
28210: PUSH
28211: LD_INT 1
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: LIST
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28244: LD_ADDR_VAR 0 33
28248: PUSH
28249: LD_INT 0
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: EMPTY
28256: LIST
28257: LIST
28258: PUSH
28259: LD_INT 0
28261: PUSH
28262: LD_INT 1
28264: NEG
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 1
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: LD_INT 1
28285: PUSH
28286: EMPTY
28287: LIST
28288: LIST
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 1
28302: NEG
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: EMPTY
28308: LIST
28309: LIST
28310: PUSH
28311: LD_INT 1
28313: NEG
28314: PUSH
28315: LD_INT 1
28317: NEG
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: NEG
28326: PUSH
28327: LD_INT 2
28329: NEG
28330: PUSH
28331: EMPTY
28332: LIST
28333: LIST
28334: PUSH
28335: LD_INT 1
28337: PUSH
28338: LD_INT 1
28340: NEG
28341: PUSH
28342: EMPTY
28343: LIST
28344: LIST
28345: PUSH
28346: LD_INT 2
28348: PUSH
28349: LD_INT 0
28351: PUSH
28352: EMPTY
28353: LIST
28354: LIST
28355: PUSH
28356: LD_INT 2
28358: PUSH
28359: LD_INT 1
28361: PUSH
28362: EMPTY
28363: LIST
28364: LIST
28365: PUSH
28366: LD_INT 1
28368: PUSH
28369: LD_INT 2
28371: PUSH
28372: EMPTY
28373: LIST
28374: LIST
28375: PUSH
28376: LD_INT 0
28378: PUSH
28379: LD_INT 2
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: PUSH
28386: LD_INT 1
28388: NEG
28389: PUSH
28390: LD_INT 1
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: LD_INT 2
28399: NEG
28400: PUSH
28401: LD_INT 0
28403: PUSH
28404: EMPTY
28405: LIST
28406: LIST
28407: PUSH
28408: LD_INT 2
28410: NEG
28411: PUSH
28412: LD_INT 1
28414: NEG
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PUSH
28420: LD_INT 2
28422: NEG
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: EMPTY
28429: LIST
28430: LIST
28431: PUSH
28432: LD_INT 2
28434: NEG
28435: PUSH
28436: LD_INT 3
28438: NEG
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 2
28446: PUSH
28447: LD_INT 1
28449: NEG
28450: PUSH
28451: EMPTY
28452: LIST
28453: LIST
28454: PUSH
28455: LD_INT 3
28457: PUSH
28458: LD_INT 1
28460: PUSH
28461: EMPTY
28462: LIST
28463: LIST
28464: PUSH
28465: LD_INT 1
28467: PUSH
28468: LD_INT 3
28470: PUSH
28471: EMPTY
28472: LIST
28473: LIST
28474: PUSH
28475: LD_INT 1
28477: NEG
28478: PUSH
28479: LD_INT 2
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: LD_INT 3
28488: NEG
28489: PUSH
28490: LD_INT 2
28492: NEG
28493: PUSH
28494: EMPTY
28495: LIST
28496: LIST
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: LIST
28502: LIST
28503: LIST
28504: LIST
28505: LIST
28506: LIST
28507: LIST
28508: LIST
28509: LIST
28510: LIST
28511: LIST
28512: LIST
28513: LIST
28514: LIST
28515: LIST
28516: LIST
28517: LIST
28518: LIST
28519: LIST
28520: LIST
28521: LIST
28522: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28523: LD_ADDR_VAR 0 34
28527: PUSH
28528: LD_INT 0
28530: PUSH
28531: LD_INT 0
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 0
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: LD_INT 0
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: PUSH
28562: LD_INT 1
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 0
28571: PUSH
28572: LD_INT 1
28574: PUSH
28575: EMPTY
28576: LIST
28577: LIST
28578: PUSH
28579: LD_INT 1
28581: NEG
28582: PUSH
28583: LD_INT 0
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: LD_INT 1
28592: NEG
28593: PUSH
28594: LD_INT 1
28596: NEG
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: PUSH
28602: LD_INT 1
28604: NEG
28605: PUSH
28606: LD_INT 2
28608: NEG
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: LD_INT 0
28616: PUSH
28617: LD_INT 2
28619: NEG
28620: PUSH
28621: EMPTY
28622: LIST
28623: LIST
28624: PUSH
28625: LD_INT 1
28627: PUSH
28628: LD_INT 1
28630: NEG
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 2
28638: PUSH
28639: LD_INT 1
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 2
28648: PUSH
28649: LD_INT 2
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: LD_INT 2
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 2
28690: NEG
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: NEG
28703: PUSH
28704: LD_INT 2
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: NEG
28715: PUSH
28716: LD_INT 3
28718: NEG
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 1
28726: PUSH
28727: LD_INT 2
28729: NEG
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 3
28737: PUSH
28738: LD_INT 2
28740: PUSH
28741: EMPTY
28742: LIST
28743: LIST
28744: PUSH
28745: LD_INT 2
28747: PUSH
28748: LD_INT 3
28750: PUSH
28751: EMPTY
28752: LIST
28753: LIST
28754: PUSH
28755: LD_INT 2
28757: NEG
28758: PUSH
28759: LD_INT 1
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 3
28768: NEG
28769: PUSH
28770: LD_INT 1
28772: NEG
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
28803: LD_ADDR_VAR 0 35
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: LD_INT 0
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: LD_INT 1
28823: NEG
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 1
28831: PUSH
28832: LD_INT 0
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: LD_INT 1
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 0
28851: PUSH
28852: LD_INT 1
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 1
28861: NEG
28862: PUSH
28863: LD_INT 0
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: PUSH
28870: LD_INT 1
28872: NEG
28873: PUSH
28874: LD_INT 1
28876: NEG
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 2
28884: PUSH
28885: LD_INT 1
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 2
28894: NEG
28895: PUSH
28896: LD_INT 1
28898: NEG
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: LIST
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
28915: LD_ADDR_VAR 0 36
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: LD_INT 0
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 0
28932: PUSH
28933: LD_INT 1
28935: NEG
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: PUSH
28941: LD_INT 1
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 1
28953: PUSH
28954: LD_INT 1
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 0
28963: PUSH
28964: LD_INT 1
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 1
28973: NEG
28974: PUSH
28975: LD_INT 0
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 1
28984: NEG
28985: PUSH
28986: LD_INT 1
28988: NEG
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: LD_INT 1
28996: NEG
28997: PUSH
28998: LD_INT 2
29000: NEG
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: PUSH
29009: LD_INT 2
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29027: LD_ADDR_VAR 0 37
29031: PUSH
29032: LD_INT 0
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: LD_INT 0
29044: PUSH
29045: LD_INT 1
29047: NEG
29048: PUSH
29049: EMPTY
29050: LIST
29051: LIST
29052: PUSH
29053: LD_INT 1
29055: PUSH
29056: LD_INT 0
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 0
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 1
29085: NEG
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: EMPTY
29091: LIST
29092: LIST
29093: PUSH
29094: LD_INT 1
29096: NEG
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: LD_INT 1
29111: NEG
29112: PUSH
29113: EMPTY
29114: LIST
29115: LIST
29116: PUSH
29117: LD_INT 1
29119: NEG
29120: PUSH
29121: LD_INT 1
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29139: LD_ADDR_VAR 0 38
29143: PUSH
29144: LD_INT 0
29146: PUSH
29147: LD_INT 0
29149: PUSH
29150: EMPTY
29151: LIST
29152: LIST
29153: PUSH
29154: LD_INT 0
29156: PUSH
29157: LD_INT 1
29159: NEG
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 1
29167: PUSH
29168: LD_INT 0
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 1
29177: PUSH
29178: LD_INT 1
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 0
29187: PUSH
29188: LD_INT 1
29190: PUSH
29191: EMPTY
29192: LIST
29193: LIST
29194: PUSH
29195: LD_INT 1
29197: NEG
29198: PUSH
29199: LD_INT 0
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 1
29208: NEG
29209: PUSH
29210: LD_INT 1
29212: NEG
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: LD_INT 2
29220: PUSH
29221: LD_INT 1
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 2
29230: NEG
29231: PUSH
29232: LD_INT 1
29234: NEG
29235: PUSH
29236: EMPTY
29237: LIST
29238: LIST
29239: PUSH
29240: EMPTY
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29251: LD_ADDR_VAR 0 39
29255: PUSH
29256: LD_INT 0
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PUSH
29266: LD_INT 0
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: PUSH
29277: LD_INT 1
29279: PUSH
29280: LD_INT 0
29282: PUSH
29283: EMPTY
29284: LIST
29285: LIST
29286: PUSH
29287: LD_INT 1
29289: PUSH
29290: LD_INT 1
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: PUSH
29297: LD_INT 0
29299: PUSH
29300: LD_INT 1
29302: PUSH
29303: EMPTY
29304: LIST
29305: LIST
29306: PUSH
29307: LD_INT 1
29309: NEG
29310: PUSH
29311: LD_INT 0
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: LD_INT 1
29324: NEG
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: LD_INT 2
29336: NEG
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: PUSH
29345: LD_INT 2
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29363: LD_ADDR_VAR 0 40
29367: PUSH
29368: LD_INT 0
29370: PUSH
29371: LD_INT 0
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: PUSH
29378: LD_INT 0
29380: PUSH
29381: LD_INT 1
29383: NEG
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 1
29391: PUSH
29392: LD_INT 0
29394: PUSH
29395: EMPTY
29396: LIST
29397: LIST
29398: PUSH
29399: LD_INT 1
29401: PUSH
29402: LD_INT 1
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 0
29411: PUSH
29412: LD_INT 1
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 1
29421: NEG
29422: PUSH
29423: LD_INT 0
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: LD_INT 1
29436: NEG
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 1
29444: PUSH
29445: LD_INT 1
29447: NEG
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 1
29455: NEG
29456: PUSH
29457: LD_INT 1
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29475: LD_ADDR_VAR 0 41
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: LD_INT 1
29495: NEG
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: LD_INT 1
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PUSH
29531: LD_INT 1
29533: NEG
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: LD_INT 2
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 2
29579: PUSH
29580: LD_INT 0
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 2
29589: PUSH
29590: LD_INT 1
29592: PUSH
29593: EMPTY
29594: LIST
29595: LIST
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: LD_INT 2
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: PUSH
29607: LD_INT 1
29609: PUSH
29610: LD_INT 2
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 1
29619: NEG
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: LD_INT 0
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PUSH
29639: LD_INT 2
29641: NEG
29642: PUSH
29643: LD_INT 1
29645: NEG
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 2
29653: NEG
29654: PUSH
29655: LD_INT 2
29657: NEG
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 2
29665: NEG
29666: PUSH
29667: LD_INT 3
29669: NEG
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 2
29677: PUSH
29678: LD_INT 1
29680: NEG
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 3
29688: PUSH
29689: LD_INT 0
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 3
29698: PUSH
29699: LD_INT 1
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 3
29708: PUSH
29709: LD_INT 2
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 3
29718: PUSH
29719: LD_INT 3
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: LD_INT 2
29728: PUSH
29729: LD_INT 3
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: PUSH
29736: LD_INT 2
29738: NEG
29739: PUSH
29740: LD_INT 1
29742: PUSH
29743: EMPTY
29744: LIST
29745: LIST
29746: PUSH
29747: LD_INT 3
29749: NEG
29750: PUSH
29751: LD_INT 0
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 3
29760: NEG
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: EMPTY
29767: LIST
29768: LIST
29769: PUSH
29770: LD_INT 3
29772: NEG
29773: PUSH
29774: LD_INT 2
29776: NEG
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 3
29784: NEG
29785: PUSH
29786: LD_INT 3
29788: NEG
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: EMPTY
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29825: LD_ADDR_VAR 0 42
29829: PUSH
29830: LD_INT 0
29832: PUSH
29833: LD_INT 0
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: LD_INT 1
29845: NEG
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: LD_INT 0
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 1
29863: PUSH
29864: LD_INT 1
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: NEG
29884: PUSH
29885: LD_INT 0
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 2
29910: NEG
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 0
29918: PUSH
29919: LD_INT 2
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 2
29950: PUSH
29951: LD_INT 2
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 1
29960: PUSH
29961: LD_INT 2
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 0
29970: PUSH
29971: LD_INT 2
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 1
29980: NEG
29981: PUSH
29982: LD_INT 1
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: LD_INT 2
29991: NEG
29992: PUSH
29993: LD_INT 1
29995: NEG
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 2
30003: NEG
30004: PUSH
30005: LD_INT 2
30007: NEG
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 2
30015: NEG
30016: PUSH
30017: LD_INT 3
30019: NEG
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: LD_INT 3
30031: NEG
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 0
30039: PUSH
30040: LD_INT 3
30042: NEG
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 1
30050: PUSH
30051: LD_INT 2
30053: NEG
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 3
30061: PUSH
30062: LD_INT 2
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 3
30071: PUSH
30072: LD_INT 3
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 2
30081: PUSH
30082: LD_INT 3
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: PUSH
30092: LD_INT 3
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 0
30101: PUSH
30102: LD_INT 3
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: NEG
30112: PUSH
30113: LD_INT 2
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 3
30122: NEG
30123: PUSH
30124: LD_INT 2
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 3
30134: NEG
30135: PUSH
30136: LD_INT 3
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: LIST
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: LIST
30172: LIST
30173: LIST
30174: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30175: LD_ADDR_VAR 0 43
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: LD_INT 0
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 0
30192: PUSH
30193: LD_INT 1
30195: NEG
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: LD_INT 0
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 0
30223: PUSH
30224: LD_INT 1
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 1
30233: NEG
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 1
30244: NEG
30245: PUSH
30246: LD_INT 1
30248: NEG
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 1
30256: NEG
30257: PUSH
30258: LD_INT 2
30260: NEG
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: LD_INT 2
30271: NEG
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 2
30290: PUSH
30291: LD_INT 0
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: LD_INT 2
30300: PUSH
30301: LD_INT 1
30303: PUSH
30304: EMPTY
30305: LIST
30306: LIST
30307: PUSH
30308: LD_INT 1
30310: PUSH
30311: LD_INT 2
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: LD_INT 2
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 1
30330: NEG
30331: PUSH
30332: LD_INT 1
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 2
30341: NEG
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 2
30352: NEG
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: NEG
30365: PUSH
30366: LD_INT 3
30368: NEG
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: LD_INT 3
30379: NEG
30380: PUSH
30381: EMPTY
30382: LIST
30383: LIST
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 2
30398: PUSH
30399: LD_INT 1
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 3
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 3
30419: PUSH
30420: LD_INT 1
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: LD_INT 3
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 0
30439: PUSH
30440: LD_INT 3
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 1
30449: NEG
30450: PUSH
30451: LD_INT 2
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 2
30460: NEG
30461: PUSH
30462: LD_INT 1
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 3
30471: NEG
30472: PUSH
30473: LD_INT 0
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 3
30482: NEG
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: LIST
30496: LIST
30497: LIST
30498: LIST
30499: LIST
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30523: LD_ADDR_VAR 0 44
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: LD_INT 0
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 0
30540: PUSH
30541: LD_INT 1
30543: NEG
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: PUSH
30549: LD_INT 1
30551: PUSH
30552: LD_INT 0
30554: PUSH
30555: EMPTY
30556: LIST
30557: LIST
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: LD_INT 1
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 0
30571: PUSH
30572: LD_INT 1
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 1
30581: NEG
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 1
30592: NEG
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: LD_INT 2
30608: NEG
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: PUSH
30617: LD_INT 1
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 2
30627: PUSH
30628: LD_INT 0
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PUSH
30635: LD_INT 2
30637: PUSH
30638: LD_INT 1
30640: PUSH
30641: EMPTY
30642: LIST
30643: LIST
30644: PUSH
30645: LD_INT 2
30647: PUSH
30648: LD_INT 2
30650: PUSH
30651: EMPTY
30652: LIST
30653: LIST
30654: PUSH
30655: LD_INT 1
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: NEG
30668: PUSH
30669: LD_INT 1
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: LD_INT 2
30678: NEG
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 2
30689: NEG
30690: PUSH
30691: LD_INT 1
30693: NEG
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 2
30701: NEG
30702: PUSH
30703: LD_INT 2
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 2
30713: NEG
30714: PUSH
30715: LD_INT 3
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 2
30725: PUSH
30726: LD_INT 1
30728: NEG
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 3
30736: PUSH
30737: LD_INT 0
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 3
30746: PUSH
30747: LD_INT 1
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 3
30756: PUSH
30757: LD_INT 2
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 3
30766: PUSH
30767: LD_INT 3
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 2
30776: PUSH
30777: LD_INT 3
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 2
30786: NEG
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 3
30797: NEG
30798: PUSH
30799: LD_INT 0
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: LD_INT 1
30812: NEG
30813: PUSH
30814: EMPTY
30815: LIST
30816: LIST
30817: PUSH
30818: LD_INT 3
30820: NEG
30821: PUSH
30822: LD_INT 2
30824: NEG
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 3
30832: NEG
30833: PUSH
30834: LD_INT 3
30836: NEG
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: LIST
30872: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30873: LD_ADDR_VAR 0 45
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 0
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 0
30890: PUSH
30891: LD_INT 1
30893: NEG
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 1
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 1
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 0
30921: PUSH
30922: LD_INT 1
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 0
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: NEG
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 0
30966: PUSH
30967: LD_INT 2
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: LD_INT 1
30980: NEG
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: LD_INT 2
30988: PUSH
30989: LD_INT 1
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 2
30998: PUSH
30999: LD_INT 2
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: LD_INT 2
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: NEG
31029: PUSH
31030: LD_INT 1
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: LD_INT 1
31043: NEG
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 2
31051: NEG
31052: PUSH
31053: LD_INT 2
31055: NEG
31056: PUSH
31057: EMPTY
31058: LIST
31059: LIST
31060: PUSH
31061: LD_INT 2
31063: NEG
31064: PUSH
31065: LD_INT 3
31067: NEG
31068: PUSH
31069: EMPTY
31070: LIST
31071: LIST
31072: PUSH
31073: LD_INT 1
31075: NEG
31076: PUSH
31077: LD_INT 3
31079: NEG
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 0
31087: PUSH
31088: LD_INT 3
31090: NEG
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: LD_INT 2
31101: NEG
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 3
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 3
31119: PUSH
31120: LD_INT 3
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: PUSH
31127: LD_INT 2
31129: PUSH
31130: LD_INT 3
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: PUSH
31137: LD_INT 1
31139: PUSH
31140: LD_INT 3
31142: PUSH
31143: EMPTY
31144: LIST
31145: LIST
31146: PUSH
31147: LD_INT 0
31149: PUSH
31150: LD_INT 3
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 1
31159: NEG
31160: PUSH
31161: LD_INT 2
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 3
31170: NEG
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 3
31182: NEG
31183: PUSH
31184: LD_INT 3
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31223: LD_ADDR_VAR 0 46
31227: PUSH
31228: LD_INT 0
31230: PUSH
31231: LD_INT 0
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 0
31240: PUSH
31241: LD_INT 1
31243: NEG
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 1
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 1
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 0
31271: PUSH
31272: LD_INT 1
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 1
31281: NEG
31282: PUSH
31283: LD_INT 0
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: LD_INT 1
31296: NEG
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: LD_INT 2
31308: NEG
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: LD_INT 2
31319: NEG
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 1
31327: PUSH
31328: LD_INT 1
31330: NEG
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: PUSH
31339: LD_INT 0
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 2
31348: PUSH
31349: LD_INT 1
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 1
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 0
31368: PUSH
31369: LD_INT 2
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: NEG
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 2
31389: NEG
31390: PUSH
31391: LD_INT 0
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 2
31400: NEG
31401: PUSH
31402: LD_INT 1
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: LD_INT 3
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: LD_INT 3
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 2
31438: NEG
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 2
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 3
31457: PUSH
31458: LD_INT 0
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 3
31467: PUSH
31468: LD_INT 1
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: LD_INT 3
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 0
31487: PUSH
31488: LD_INT 3
31490: PUSH
31491: EMPTY
31492: LIST
31493: LIST
31494: PUSH
31495: LD_INT 1
31497: NEG
31498: PUSH
31499: LD_INT 2
31501: PUSH
31502: EMPTY
31503: LIST
31504: LIST
31505: PUSH
31506: LD_INT 2
31508: NEG
31509: PUSH
31510: LD_INT 1
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 3
31519: NEG
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 3
31530: NEG
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: LIST
31559: LIST
31560: LIST
31561: LIST
31562: LIST
31563: LIST
31564: LIST
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31571: LD_ADDR_VAR 0 47
31575: PUSH
31576: LD_INT 0
31578: PUSH
31579: LD_INT 0
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 0
31588: PUSH
31589: LD_INT 1
31591: NEG
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 1
31599: PUSH
31600: LD_INT 0
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: LD_INT 1
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 0
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 1
31629: NEG
31630: PUSH
31631: LD_INT 0
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 1
31640: NEG
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 1
31652: NEG
31653: PUSH
31654: LD_INT 2
31656: NEG
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: LD_INT 2
31667: NEG
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: LD_INT 1
31675: PUSH
31676: LD_INT 1
31678: NEG
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 2
31686: NEG
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 2
31698: NEG
31699: PUSH
31700: LD_INT 2
31702: NEG
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
31722: LD_ADDR_VAR 0 48
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 1
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: NEG
31804: PUSH
31805: LD_INT 2
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 0
31815: PUSH
31816: LD_INT 2
31818: NEG
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: LD_INT 1
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: LD_INT 0
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: LD_INT 1
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
31869: LD_ADDR_VAR 0 49
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 0
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 0
31917: PUSH
31918: LD_INT 1
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: LD_INT 0
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: LD_INT 1
31953: NEG
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 2
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 2
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: LD_INT 2
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32013: LD_ADDR_VAR 0 50
32017: PUSH
32018: LD_INT 0
32020: PUSH
32021: LD_INT 0
32023: PUSH
32024: EMPTY
32025: LIST
32026: LIST
32027: PUSH
32028: LD_INT 0
32030: PUSH
32031: LD_INT 1
32033: NEG
32034: PUSH
32035: EMPTY
32036: LIST
32037: LIST
32038: PUSH
32039: LD_INT 1
32041: PUSH
32042: LD_INT 0
32044: PUSH
32045: EMPTY
32046: LIST
32047: LIST
32048: PUSH
32049: LD_INT 1
32051: PUSH
32052: LD_INT 1
32054: PUSH
32055: EMPTY
32056: LIST
32057: LIST
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: LD_INT 1
32064: PUSH
32065: EMPTY
32066: LIST
32067: LIST
32068: PUSH
32069: LD_INT 1
32071: NEG
32072: PUSH
32073: LD_INT 0
32075: PUSH
32076: EMPTY
32077: LIST
32078: LIST
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 2
32104: PUSH
32105: LD_INT 2
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 1
32114: PUSH
32115: LD_INT 2
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: LD_INT 2
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: LD_INT 1
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32157: LD_ADDR_VAR 0 51
32161: PUSH
32162: LD_INT 0
32164: PUSH
32165: LD_INT 0
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 1
32226: NEG
32227: PUSH
32228: LD_INT 1
32230: NEG
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 1
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 2
32269: NEG
32270: PUSH
32271: LD_INT 0
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32304: LD_ADDR_VAR 0 52
32308: PUSH
32309: LD_INT 0
32311: PUSH
32312: LD_INT 0
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 0
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: LD_INT 0
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 1
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 1
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: NEG
32363: PUSH
32364: LD_INT 0
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: NEG
32374: PUSH
32375: LD_INT 1
32377: NEG
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 1
32385: NEG
32386: PUSH
32387: LD_INT 2
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 2
32419: NEG
32420: PUSH
32421: LD_INT 1
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: NEG
32432: PUSH
32433: LD_INT 2
32435: NEG
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32455: LD_ADDR_VAR 0 53
32459: PUSH
32460: LD_INT 0
32462: PUSH
32463: LD_INT 0
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 0
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: LD_INT 0
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 1
32493: PUSH
32494: LD_INT 1
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 1
32524: NEG
32525: PUSH
32526: LD_INT 1
32528: NEG
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: LD_INT 2
32540: NEG
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: LD_INT 2
32551: NEG
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 1
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 2
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PUSH
32578: LD_INT 2
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: PUSH
32588: LD_INT 2
32590: PUSH
32591: LD_INT 2
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: LD_INT 1
32600: PUSH
32601: LD_INT 2
32603: PUSH
32604: EMPTY
32605: LIST
32606: LIST
32607: PUSH
32608: LD_INT 0
32610: PUSH
32611: LD_INT 2
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 1
32620: NEG
32621: PUSH
32622: LD_INT 1
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 2
32631: NEG
32632: PUSH
32633: LD_INT 0
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 2
32642: NEG
32643: PUSH
32644: LD_INT 1
32646: NEG
32647: PUSH
32648: EMPTY
32649: LIST
32650: LIST
32651: PUSH
32652: LD_INT 2
32654: NEG
32655: PUSH
32656: LD_INT 2
32658: NEG
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32685: LD_ADDR_VAR 0 54
32689: PUSH
32690: LD_INT 0
32692: PUSH
32693: LD_INT 0
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: LD_INT 1
32705: NEG
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: LD_INT 0
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: PUSH
32724: LD_INT 1
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: LD_INT 0
32733: PUSH
32734: LD_INT 1
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 1
32743: NEG
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: NEG
32755: PUSH
32756: LD_INT 1
32758: NEG
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: LD_INT 2
32770: NEG
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 0
32778: PUSH
32779: LD_INT 2
32781: NEG
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 1
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 2
32800: PUSH
32801: LD_INT 0
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 2
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 2
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: PUSH
32831: LD_INT 2
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 0
32840: PUSH
32841: LD_INT 2
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 1
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: LD_INT 0
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: LIST
32901: LIST
32902: LIST
32903: LIST
32904: LIST
32905: LIST
32906: LIST
32907: LIST
32908: LIST
32909: LIST
32910: LIST
32911: LIST
32912: LIST
32913: LIST
32914: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32915: LD_ADDR_VAR 0 55
32919: PUSH
32920: LD_INT 0
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 0
32932: PUSH
32933: LD_INT 1
32935: NEG
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 1
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 1
32953: PUSH
32954: LD_INT 1
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 0
32963: PUSH
32964: LD_INT 1
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 1
32973: NEG
32974: PUSH
32975: LD_INT 0
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 1
32984: NEG
32985: PUSH
32986: LD_INT 1
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: LD_INT 2
33000: NEG
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 0
33008: PUSH
33009: LD_INT 2
33011: NEG
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: LD_INT 1
33022: NEG
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: LD_INT 0
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 2
33040: PUSH
33041: LD_INT 1
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 2
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: LD_INT 2
33063: PUSH
33064: EMPTY
33065: LIST
33066: LIST
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: LD_INT 2
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: EMPTY
33086: LIST
33087: LIST
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: LD_INT 0
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 2
33102: NEG
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 2
33114: NEG
33115: PUSH
33116: LD_INT 2
33118: NEG
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33145: LD_ADDR_VAR 0 56
33149: PUSH
33150: LD_INT 0
33152: PUSH
33153: LD_INT 0
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 0
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: LD_INT 0
33176: PUSH
33177: EMPTY
33178: LIST
33179: LIST
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: LD_INT 1
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 1
33203: NEG
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: LD_INT 1
33214: NEG
33215: PUSH
33216: LD_INT 1
33218: NEG
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: NEG
33227: PUSH
33228: LD_INT 2
33230: NEG
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: LD_INT 2
33241: NEG
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 2
33270: PUSH
33271: LD_INT 1
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 2
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 1
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 0
33300: PUSH
33301: LD_INT 2
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 1
33310: NEG
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 2
33321: NEG
33322: PUSH
33323: LD_INT 0
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 2
33348: NEG
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: LIST
33360: LIST
33361: LIST
33362: LIST
33363: LIST
33364: LIST
33365: LIST
33366: LIST
33367: LIST
33368: LIST
33369: LIST
33370: LIST
33371: LIST
33372: LIST
33373: LIST
33374: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33375: LD_ADDR_VAR 0 57
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 0
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: PUSH
33404: LD_INT 0
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: LD_INT 1
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: NEG
33445: PUSH
33446: LD_INT 1
33448: NEG
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 1
33456: NEG
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 2
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 2
33510: PUSH
33511: LD_INT 2
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 1
33520: PUSH
33521: LD_INT 2
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 2
33551: NEG
33552: PUSH
33553: LD_INT 0
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 2
33562: NEG
33563: PUSH
33564: LD_INT 1
33566: NEG
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 2
33574: NEG
33575: PUSH
33576: LD_INT 2
33578: NEG
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33605: LD_ADDR_VAR 0 58
33609: PUSH
33610: LD_INT 0
33612: PUSH
33613: LD_INT 0
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: LD_INT 1
33625: NEG
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: PUSH
33634: LD_INT 0
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 1
33643: PUSH
33644: LD_INT 1
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 0
33653: PUSH
33654: LD_INT 1
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 1
33663: NEG
33664: PUSH
33665: LD_INT 0
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 1
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 1
33686: NEG
33687: PUSH
33688: LD_INT 2
33690: NEG
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: LD_INT 2
33701: NEG
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 1
33709: PUSH
33710: LD_INT 1
33712: NEG
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 2
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 2
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 2
33740: PUSH
33741: LD_INT 2
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 1
33750: PUSH
33751: LD_INT 2
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: LD_INT 2
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 1
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 2
33781: NEG
33782: PUSH
33783: LD_INT 0
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 2
33792: NEG
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
33835: LD_ADDR_VAR 0 59
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 0
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 1
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 0
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: EMPTY
33888: LIST
33889: LIST
33890: PUSH
33891: LD_INT 1
33893: NEG
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
33923: LD_ADDR_VAR 0 60
33927: PUSH
33928: LD_INT 0
33930: PUSH
33931: LD_INT 0
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: LD_INT 1
33943: NEG
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 1
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 1
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 1
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: NEG
33993: PUSH
33994: LD_INT 1
33996: NEG
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34011: LD_ADDR_VAR 0 61
34015: PUSH
34016: LD_INT 0
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 0
34028: PUSH
34029: LD_INT 1
34031: NEG
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 1
34039: PUSH
34040: LD_INT 0
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: LD_INT 1
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34099: LD_ADDR_VAR 0 62
34103: PUSH
34104: LD_INT 0
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: EMPTY
34111: LIST
34112: LIST
34113: PUSH
34114: LD_INT 0
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 1
34127: PUSH
34128: LD_INT 0
34130: PUSH
34131: EMPTY
34132: LIST
34133: LIST
34134: PUSH
34135: LD_INT 1
34137: PUSH
34138: LD_INT 1
34140: PUSH
34141: EMPTY
34142: LIST
34143: LIST
34144: PUSH
34145: LD_INT 0
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: PUSH
34155: LD_INT 1
34157: NEG
34158: PUSH
34159: LD_INT 0
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: NEG
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34187: LD_ADDR_VAR 0 63
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: LD_INT 0
34197: PUSH
34198: EMPTY
34199: LIST
34200: LIST
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 1
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 0
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 1
34256: NEG
34257: PUSH
34258: LD_INT 1
34260: NEG
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34275: LD_ADDR_VAR 0 64
34279: PUSH
34280: LD_INT 0
34282: PUSH
34283: LD_INT 0
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 1
34295: NEG
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: NEG
34334: PUSH
34335: LD_INT 0
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: LD_INT 1
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: ST_TO_ADDR
// end ; 1 :
34363: GO 40260
34365: LD_INT 1
34367: DOUBLE
34368: EQUAL
34369: IFTRUE 34373
34371: GO 36996
34373: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34374: LD_ADDR_VAR 0 11
34378: PUSH
34379: LD_INT 1
34381: NEG
34382: PUSH
34383: LD_INT 3
34385: NEG
34386: PUSH
34387: EMPTY
34388: LIST
34389: LIST
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: LD_INT 3
34396: NEG
34397: PUSH
34398: EMPTY
34399: LIST
34400: LIST
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: LD_INT 2
34407: NEG
34408: PUSH
34409: EMPTY
34410: LIST
34411: LIST
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: LIST
34417: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34418: LD_ADDR_VAR 0 12
34422: PUSH
34423: LD_INT 2
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 3
34436: PUSH
34437: LD_INT 0
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: PUSH
34444: LD_INT 3
34446: PUSH
34447: LD_INT 1
34449: PUSH
34450: EMPTY
34451: LIST
34452: LIST
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: LIST
34458: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34459: LD_ADDR_VAR 0 13
34463: PUSH
34464: LD_INT 3
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 3
34476: PUSH
34477: LD_INT 3
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 2
34486: PUSH
34487: LD_INT 3
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: LIST
34498: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34499: LD_ADDR_VAR 0 14
34503: PUSH
34504: LD_INT 1
34506: PUSH
34507: LD_INT 3
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: LD_INT 3
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 1
34526: NEG
34527: PUSH
34528: LD_INT 2
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: LIST
34539: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34540: LD_ADDR_VAR 0 15
34544: PUSH
34545: LD_INT 2
34547: NEG
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 3
34558: NEG
34559: PUSH
34560: LD_INT 0
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 3
34569: NEG
34570: PUSH
34571: LD_INT 1
34573: NEG
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: LIST
34583: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34584: LD_ADDR_VAR 0 16
34588: PUSH
34589: LD_INT 2
34591: NEG
34592: PUSH
34593: LD_INT 3
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 3
34603: NEG
34604: PUSH
34605: LD_INT 2
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 3
34615: NEG
34616: PUSH
34617: LD_INT 3
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: LIST
34629: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34630: LD_ADDR_VAR 0 17
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: LD_INT 3
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 0
34649: PUSH
34650: LD_INT 3
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 2
34663: NEG
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34674: LD_ADDR_VAR 0 18
34678: PUSH
34679: LD_INT 2
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 3
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 3
34702: PUSH
34703: LD_INT 1
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: LIST
34714: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34715: LD_ADDR_VAR 0 19
34719: PUSH
34720: LD_INT 3
34722: PUSH
34723: LD_INT 2
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 3
34732: PUSH
34733: LD_INT 3
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 2
34742: PUSH
34743: LD_INT 3
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: LIST
34754: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34755: LD_ADDR_VAR 0 20
34759: PUSH
34760: LD_INT 1
34762: PUSH
34763: LD_INT 3
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: LD_INT 3
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 1
34782: NEG
34783: PUSH
34784: LD_INT 2
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: LIST
34795: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34796: LD_ADDR_VAR 0 21
34800: PUSH
34801: LD_INT 2
34803: NEG
34804: PUSH
34805: LD_INT 1
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 3
34814: NEG
34815: PUSH
34816: LD_INT 0
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 3
34825: NEG
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: LIST
34839: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34840: LD_ADDR_VAR 0 22
34844: PUSH
34845: LD_INT 2
34847: NEG
34848: PUSH
34849: LD_INT 3
34851: NEG
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 3
34859: NEG
34860: PUSH
34861: LD_INT 2
34863: NEG
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 3
34871: NEG
34872: PUSH
34873: LD_INT 3
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: LIST
34885: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
34886: LD_ADDR_VAR 0 23
34890: PUSH
34891: LD_INT 0
34893: PUSH
34894: LD_INT 3
34896: NEG
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 1
34904: NEG
34905: PUSH
34906: LD_INT 4
34908: NEG
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: LD_INT 3
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
34930: LD_ADDR_VAR 0 24
34934: PUSH
34935: LD_INT 3
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 3
34947: PUSH
34948: LD_INT 1
34950: NEG
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 4
34958: PUSH
34959: LD_INT 1
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: EMPTY
34967: LIST
34968: LIST
34969: LIST
34970: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
34971: LD_ADDR_VAR 0 25
34975: PUSH
34976: LD_INT 3
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 4
34988: PUSH
34989: LD_INT 3
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 3
34998: PUSH
34999: LD_INT 4
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: LIST
35010: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35011: LD_ADDR_VAR 0 26
35015: PUSH
35016: LD_INT 0
35018: PUSH
35019: LD_INT 3
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 1
35028: PUSH
35029: LD_INT 4
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: NEG
35039: PUSH
35040: LD_INT 3
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: LIST
35051: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35052: LD_ADDR_VAR 0 27
35056: PUSH
35057: LD_INT 3
35059: NEG
35060: PUSH
35061: LD_INT 0
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 3
35070: NEG
35071: PUSH
35072: LD_INT 1
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: LD_INT 4
35081: NEG
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: LIST
35095: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35096: LD_ADDR_VAR 0 28
35100: PUSH
35101: LD_INT 3
35103: NEG
35104: PUSH
35105: LD_INT 3
35107: NEG
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 3
35115: NEG
35116: PUSH
35117: LD_INT 4
35119: NEG
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 4
35127: NEG
35128: PUSH
35129: LD_INT 3
35131: NEG
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: LIST
35141: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35142: LD_ADDR_VAR 0 29
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: LD_INT 3
35153: NEG
35154: PUSH
35155: EMPTY
35156: LIST
35157: LIST
35158: PUSH
35159: LD_INT 0
35161: PUSH
35162: LD_INT 3
35164: NEG
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 1
35172: PUSH
35173: LD_INT 2
35175: NEG
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: LD_INT 4
35187: NEG
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: LD_INT 4
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 3
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: LD_INT 5
35221: NEG
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: PUSH
35227: LD_INT 0
35229: PUSH
35230: LD_INT 5
35232: NEG
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: PUSH
35241: LD_INT 4
35243: NEG
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: LD_INT 6
35255: NEG
35256: PUSH
35257: EMPTY
35258: LIST
35259: LIST
35260: PUSH
35261: LD_INT 0
35263: PUSH
35264: LD_INT 6
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: PUSH
35275: LD_INT 5
35277: NEG
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35297: LD_ADDR_VAR 0 30
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 3
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 3
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 3
35335: PUSH
35336: LD_INT 1
35338: NEG
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 4
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 4
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 4
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 5
35377: PUSH
35378: LD_INT 0
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 5
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 5
35397: PUSH
35398: LD_INT 1
35400: NEG
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 6
35408: PUSH
35409: LD_INT 0
35411: PUSH
35412: EMPTY
35413: LIST
35414: LIST
35415: PUSH
35416: LD_INT 6
35418: PUSH
35419: LD_INT 1
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: EMPTY
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35440: LD_ADDR_VAR 0 31
35444: PUSH
35445: LD_INT 3
35447: PUSH
35448: LD_INT 2
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 3
35457: PUSH
35458: LD_INT 3
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 2
35467: PUSH
35468: LD_INT 3
35470: PUSH
35471: EMPTY
35472: LIST
35473: LIST
35474: PUSH
35475: LD_INT 4
35477: PUSH
35478: LD_INT 3
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 4
35487: PUSH
35488: LD_INT 4
35490: PUSH
35491: EMPTY
35492: LIST
35493: LIST
35494: PUSH
35495: LD_INT 3
35497: PUSH
35498: LD_INT 4
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 5
35507: PUSH
35508: LD_INT 4
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: PUSH
35515: LD_INT 5
35517: PUSH
35518: LD_INT 5
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 4
35527: PUSH
35528: LD_INT 5
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 6
35537: PUSH
35538: LD_INT 5
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 6
35547: PUSH
35548: LD_INT 6
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 5
35557: PUSH
35558: LD_INT 6
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
35579: LD_ADDR_VAR 0 32
35583: PUSH
35584: LD_INT 1
35586: PUSH
35587: LD_INT 3
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 0
35596: PUSH
35597: LD_INT 3
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: LD_INT 2
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 1
35617: PUSH
35618: LD_INT 4
35620: PUSH
35621: EMPTY
35622: LIST
35623: LIST
35624: PUSH
35625: LD_INT 0
35627: PUSH
35628: LD_INT 4
35630: PUSH
35631: EMPTY
35632: LIST
35633: LIST
35634: PUSH
35635: LD_INT 1
35637: NEG
35638: PUSH
35639: LD_INT 3
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 1
35648: PUSH
35649: LD_INT 5
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: LD_INT 5
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: LD_INT 4
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 1
35679: PUSH
35680: LD_INT 6
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 6
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: LD_INT 5
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: LIST
35712: LIST
35713: LIST
35714: LIST
35715: LIST
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
35722: LD_ADDR_VAR 0 33
35726: PUSH
35727: LD_INT 2
35729: NEG
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 3
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 3
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 3
35763: NEG
35764: PUSH
35765: LD_INT 1
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 4
35774: NEG
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 4
35785: NEG
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 4
35797: NEG
35798: PUSH
35799: LD_INT 1
35801: PUSH
35802: EMPTY
35803: LIST
35804: LIST
35805: PUSH
35806: LD_INT 5
35808: NEG
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 5
35819: NEG
35820: PUSH
35821: LD_INT 1
35823: NEG
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 5
35831: NEG
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 6
35842: NEG
35843: PUSH
35844: LD_INT 0
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 6
35853: NEG
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
35877: LD_ADDR_VAR 0 34
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 3
35888: NEG
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 3
35896: NEG
35897: PUSH
35898: LD_INT 2
35900: NEG
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 3
35908: NEG
35909: PUSH
35910: LD_INT 3
35912: NEG
35913: PUSH
35914: EMPTY
35915: LIST
35916: LIST
35917: PUSH
35918: LD_INT 3
35920: NEG
35921: PUSH
35922: LD_INT 4
35924: NEG
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 4
35932: NEG
35933: PUSH
35934: LD_INT 3
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 4
35944: NEG
35945: PUSH
35946: LD_INT 4
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 4
35956: NEG
35957: PUSH
35958: LD_INT 5
35960: NEG
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 5
35968: NEG
35969: PUSH
35970: LD_INT 4
35972: NEG
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 5
35980: NEG
35981: PUSH
35982: LD_INT 5
35984: NEG
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 5
35992: NEG
35993: PUSH
35994: LD_INT 6
35996: NEG
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 6
36004: NEG
36005: PUSH
36006: LD_INT 5
36008: NEG
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 6
36016: NEG
36017: PUSH
36018: LD_INT 6
36020: NEG
36021: PUSH
36022: EMPTY
36023: LIST
36024: LIST
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: LIST
36030: LIST
36031: LIST
36032: LIST
36033: LIST
36034: LIST
36035: LIST
36036: LIST
36037: LIST
36038: LIST
36039: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36040: LD_ADDR_VAR 0 41
36044: PUSH
36045: LD_INT 0
36047: PUSH
36048: LD_INT 2
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 1
36058: NEG
36059: PUSH
36060: LD_INT 3
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: LD_INT 2
36073: NEG
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: LIST
36083: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36084: LD_ADDR_VAR 0 42
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 2
36101: PUSH
36102: LD_INT 1
36104: NEG
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: PUSH
36110: LD_INT 3
36112: PUSH
36113: LD_INT 1
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: LIST
36124: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36125: LD_ADDR_VAR 0 43
36129: PUSH
36130: LD_INT 2
36132: PUSH
36133: LD_INT 2
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: LD_INT 2
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 2
36152: PUSH
36153: LD_INT 3
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: LIST
36164: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36165: LD_ADDR_VAR 0 44
36169: PUSH
36170: LD_INT 0
36172: PUSH
36173: LD_INT 2
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 3
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: LD_INT 2
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: EMPTY
36202: LIST
36203: LIST
36204: LIST
36205: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36206: LD_ADDR_VAR 0 45
36210: PUSH
36211: LD_INT 2
36213: NEG
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: NEG
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: LD_INT 3
36235: NEG
36236: PUSH
36237: LD_INT 1
36239: NEG
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: LIST
36249: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36250: LD_ADDR_VAR 0 46
36254: PUSH
36255: LD_INT 2
36257: NEG
36258: PUSH
36259: LD_INT 2
36261: NEG
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: NEG
36270: PUSH
36271: LD_INT 3
36273: NEG
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 3
36281: NEG
36282: PUSH
36283: LD_INT 2
36285: NEG
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: LIST
36295: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36296: LD_ADDR_VAR 0 47
36300: PUSH
36301: LD_INT 2
36303: NEG
36304: PUSH
36305: LD_INT 3
36307: NEG
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: LD_INT 3
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36329: LD_ADDR_VAR 0 48
36333: PUSH
36334: LD_INT 1
36336: PUSH
36337: LD_INT 2
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 2
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36360: LD_ADDR_VAR 0 49
36364: PUSH
36365: LD_INT 3
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: PUSH
36378: LD_INT 2
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36389: LD_ADDR_VAR 0 50
36393: PUSH
36394: LD_INT 2
36396: PUSH
36397: LD_INT 3
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 1
36406: PUSH
36407: LD_INT 3
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36418: LD_ADDR_VAR 0 51
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: LD_INT 2
36429: PUSH
36430: EMPTY
36431: LIST
36432: LIST
36433: PUSH
36434: LD_INT 2
36436: NEG
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36449: LD_ADDR_VAR 0 52
36453: PUSH
36454: LD_INT 3
36456: NEG
36457: PUSH
36458: LD_INT 1
36460: NEG
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 3
36468: NEG
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36482: LD_ADDR_VAR 0 53
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: LD_INT 3
36493: NEG
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 3
36504: NEG
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: LD_INT 2
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: LIST
36525: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36526: LD_ADDR_VAR 0 54
36530: PUSH
36531: LD_INT 2
36533: PUSH
36534: LD_INT 1
36536: NEG
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 3
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 3
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: LIST
36566: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36567: LD_ADDR_VAR 0 55
36571: PUSH
36572: LD_INT 3
36574: PUSH
36575: LD_INT 2
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 3
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 2
36594: PUSH
36595: LD_INT 3
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: LIST
36606: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36607: LD_ADDR_VAR 0 56
36611: PUSH
36612: LD_INT 1
36614: PUSH
36615: LD_INT 3
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: PUSH
36622: LD_INT 0
36624: PUSH
36625: LD_INT 3
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 1
36634: NEG
36635: PUSH
36636: LD_INT 2
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36648: LD_ADDR_VAR 0 57
36652: PUSH
36653: LD_INT 2
36655: NEG
36656: PUSH
36657: LD_INT 1
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 3
36666: NEG
36667: PUSH
36668: LD_INT 0
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 3
36677: NEG
36678: PUSH
36679: LD_INT 1
36681: NEG
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: LIST
36691: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36692: LD_ADDR_VAR 0 58
36696: PUSH
36697: LD_INT 2
36699: NEG
36700: PUSH
36701: LD_INT 3
36703: NEG
36704: PUSH
36705: EMPTY
36706: LIST
36707: LIST
36708: PUSH
36709: LD_INT 3
36711: NEG
36712: PUSH
36713: LD_INT 2
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 3
36723: NEG
36724: PUSH
36725: LD_INT 3
36727: NEG
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: LIST
36737: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
36738: LD_ADDR_VAR 0 59
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: LD_INT 2
36749: NEG
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 0
36757: PUSH
36758: LD_INT 2
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: PUSH
36769: LD_INT 1
36771: NEG
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: LIST
36781: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36782: LD_ADDR_VAR 0 60
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: LD_INT 1
36792: NEG
36793: PUSH
36794: EMPTY
36795: LIST
36796: LIST
36797: PUSH
36798: LD_INT 2
36800: PUSH
36801: LD_INT 0
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: PUSH
36808: LD_INT 2
36810: PUSH
36811: LD_INT 1
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: LIST
36822: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36823: LD_ADDR_VAR 0 61
36827: PUSH
36828: LD_INT 2
36830: PUSH
36831: LD_INT 1
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: PUSH
36841: LD_INT 2
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: LD_INT 2
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: LIST
36862: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36863: LD_ADDR_VAR 0 62
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: LD_INT 2
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: LD_INT 2
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: NEG
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: LIST
36903: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
36904: LD_ADDR_VAR 0 63
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 2
36922: NEG
36923: PUSH
36924: LD_INT 0
36926: PUSH
36927: EMPTY
36928: LIST
36929: LIST
36930: PUSH
36931: LD_INT 2
36933: NEG
36934: PUSH
36935: LD_INT 1
36937: NEG
36938: PUSH
36939: EMPTY
36940: LIST
36941: LIST
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: LIST
36947: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36948: LD_ADDR_VAR 0 64
36952: PUSH
36953: LD_INT 1
36955: NEG
36956: PUSH
36957: LD_INT 2
36959: NEG
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 2
36967: NEG
36968: PUSH
36969: LD_INT 1
36971: NEG
36972: PUSH
36973: EMPTY
36974: LIST
36975: LIST
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: LD_INT 2
36983: NEG
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: LIST
36993: ST_TO_ADDR
// end ; 2 :
36994: GO 40260
36996: LD_INT 2
36998: DOUBLE
36999: EQUAL
37000: IFTRUE 37004
37002: GO 40259
37004: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37005: LD_ADDR_VAR 0 29
37009: PUSH
37010: LD_INT 4
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 4
37022: PUSH
37023: LD_INT 1
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 5
37033: PUSH
37034: LD_INT 0
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 5
37043: PUSH
37044: LD_INT 1
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 4
37053: PUSH
37054: LD_INT 1
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 3
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 3
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 3
37084: PUSH
37085: LD_INT 2
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 5
37095: PUSH
37096: LD_INT 2
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: LD_INT 3
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: LD_INT 2
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 4
37125: PUSH
37126: LD_INT 3
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 4
37135: PUSH
37136: LD_INT 4
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: LD_INT 4
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 2
37155: PUSH
37156: LD_INT 3
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 2
37165: PUSH
37166: LD_INT 2
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 4
37175: PUSH
37176: LD_INT 2
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 2
37185: PUSH
37186: LD_INT 4
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 4
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 0
37205: PUSH
37206: LD_INT 3
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: PUSH
37216: LD_INT 4
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 1
37225: PUSH
37226: LD_INT 5
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 0
37235: PUSH
37236: LD_INT 5
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: LD_INT 4
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 3
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 2
37267: PUSH
37268: LD_INT 5
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 2
37277: NEG
37278: PUSH
37279: LD_INT 3
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 3
37288: NEG
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: EMPTY
37294: LIST
37295: LIST
37296: PUSH
37297: LD_INT 3
37299: NEG
37300: PUSH
37301: LD_INT 1
37303: NEG
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 2
37311: NEG
37312: PUSH
37313: LD_INT 0
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 2
37322: NEG
37323: PUSH
37324: LD_INT 1
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: NEG
37334: PUSH
37335: LD_INT 1
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 4
37344: NEG
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 4
37355: NEG
37356: PUSH
37357: LD_INT 1
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 4
37367: NEG
37368: PUSH
37369: LD_INT 2
37371: NEG
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: PUSH
37377: LD_INT 2
37379: NEG
37380: PUSH
37381: LD_INT 2
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: LD_INT 4
37390: NEG
37391: PUSH
37392: LD_INT 4
37394: NEG
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 4
37402: NEG
37403: PUSH
37404: LD_INT 5
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 3
37414: NEG
37415: PUSH
37416: LD_INT 4
37418: NEG
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 3
37426: NEG
37427: PUSH
37428: LD_INT 3
37430: NEG
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 4
37438: NEG
37439: PUSH
37440: LD_INT 3
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 5
37450: NEG
37451: PUSH
37452: LD_INT 4
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 5
37462: NEG
37463: PUSH
37464: LD_INT 5
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 3
37474: NEG
37475: PUSH
37476: LD_INT 5
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 5
37486: NEG
37487: PUSH
37488: LD_INT 3
37490: NEG
37491: PUSH
37492: EMPTY
37493: LIST
37494: LIST
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: LIST
37500: LIST
37501: LIST
37502: LIST
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: LIST
37511: LIST
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
37543: LD_ADDR_VAR 0 30
37547: PUSH
37548: LD_INT 4
37550: PUSH
37551: LD_INT 4
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 4
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 5
37570: PUSH
37571: LD_INT 4
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 5
37580: PUSH
37581: LD_INT 5
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 4
37590: PUSH
37591: LD_INT 5
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 3
37600: PUSH
37601: LD_INT 4
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 3
37610: PUSH
37611: LD_INT 3
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 5
37620: PUSH
37621: LD_INT 3
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 3
37630: PUSH
37631: LD_INT 5
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 0
37640: PUSH
37641: LD_INT 3
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: LD_INT 2
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 1
37660: PUSH
37661: LD_INT 3
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: LD_INT 4
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 0
37680: PUSH
37681: LD_INT 4
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: NEG
37691: PUSH
37692: LD_INT 3
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 2
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 2
37712: PUSH
37713: LD_INT 4
37715: PUSH
37716: EMPTY
37717: LIST
37718: LIST
37719: PUSH
37720: LD_INT 2
37722: NEG
37723: PUSH
37724: LD_INT 2
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 4
37733: NEG
37734: PUSH
37735: LD_INT 0
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 4
37744: NEG
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 3
37756: NEG
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 3
37767: NEG
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 4
37778: NEG
37779: PUSH
37780: LD_INT 1
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 5
37789: NEG
37790: PUSH
37791: LD_INT 0
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 5
37800: NEG
37801: PUSH
37802: LD_INT 1
37804: NEG
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 5
37812: NEG
37813: PUSH
37814: LD_INT 2
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 3
37824: NEG
37825: PUSH
37826: LD_INT 2
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 3
37835: NEG
37836: PUSH
37837: LD_INT 3
37839: NEG
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 3
37847: NEG
37848: PUSH
37849: LD_INT 4
37851: NEG
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 2
37859: NEG
37860: PUSH
37861: LD_INT 3
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 2
37871: NEG
37872: PUSH
37873: LD_INT 2
37875: NEG
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: LD_INT 2
37887: NEG
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 4
37895: NEG
37896: PUSH
37897: LD_INT 3
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 4
37907: NEG
37908: PUSH
37909: LD_INT 4
37911: NEG
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 2
37919: NEG
37920: PUSH
37921: LD_INT 4
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 4
37931: NEG
37932: PUSH
37933: LD_INT 2
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 4
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: LD_INT 5
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: LD_INT 4
37968: NEG
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: PUSH
37977: LD_INT 3
37979: NEG
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 0
37987: PUSH
37988: LD_INT 3
37990: NEG
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: LD_INT 4
38002: NEG
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: LD_INT 5
38014: NEG
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 2
38022: PUSH
38023: LD_INT 3
38025: NEG
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 2
38033: NEG
38034: PUSH
38035: LD_INT 5
38037: NEG
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38090: LD_ADDR_VAR 0 31
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 4
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 0
38107: PUSH
38108: LD_INT 3
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: LD_INT 4
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: LD_INT 5
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: LD_INT 5
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: LD_INT 4
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 1
38158: NEG
38159: PUSH
38160: LD_INT 3
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: PUSH
38167: LD_INT 2
38169: PUSH
38170: LD_INT 5
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: LD_INT 2
38179: NEG
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 3
38190: NEG
38191: PUSH
38192: LD_INT 0
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 3
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: NEG
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: LD_INT 0
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 2
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 3
38235: NEG
38236: PUSH
38237: LD_INT 1
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 4
38246: NEG
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 4
38257: NEG
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 4
38269: NEG
38270: PUSH
38271: LD_INT 2
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 2
38281: NEG
38282: PUSH
38283: LD_INT 2
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 4
38292: NEG
38293: PUSH
38294: LD_INT 4
38296: NEG
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 4
38304: NEG
38305: PUSH
38306: LD_INT 5
38308: NEG
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: LD_INT 3
38316: NEG
38317: PUSH
38318: LD_INT 4
38320: NEG
38321: PUSH
38322: EMPTY
38323: LIST
38324: LIST
38325: PUSH
38326: LD_INT 3
38328: NEG
38329: PUSH
38330: LD_INT 3
38332: NEG
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: LD_INT 4
38340: NEG
38341: PUSH
38342: LD_INT 3
38344: NEG
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 5
38352: NEG
38353: PUSH
38354: LD_INT 4
38356: NEG
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 5
38364: NEG
38365: PUSH
38366: LD_INT 5
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 3
38376: NEG
38377: PUSH
38378: LD_INT 5
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 5
38388: NEG
38389: PUSH
38390: LD_INT 3
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: LD_INT 3
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: LD_INT 4
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: PUSH
38423: LD_INT 3
38425: NEG
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: LD_INT 2
38436: NEG
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: NEG
38456: PUSH
38457: LD_INT 3
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: LD_INT 4
38471: NEG
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 2
38479: PUSH
38480: LD_INT 2
38482: NEG
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: PUSH
38488: LD_INT 2
38490: NEG
38491: PUSH
38492: LD_INT 4
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 4
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 4
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 5
38523: PUSH
38524: LD_INT 0
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 5
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 4
38543: PUSH
38544: LD_INT 1
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 3
38553: PUSH
38554: LD_INT 0
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 3
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 3
38574: PUSH
38575: LD_INT 2
38577: NEG
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 5
38585: PUSH
38586: LD_INT 2
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: LIST
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: LIST
38636: LIST
38637: LIST
38638: LIST
38639: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
38640: LD_ADDR_VAR 0 32
38644: PUSH
38645: LD_INT 4
38647: NEG
38648: PUSH
38649: LD_INT 0
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 4
38658: NEG
38659: PUSH
38660: LD_INT 1
38662: NEG
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 3
38670: NEG
38671: PUSH
38672: LD_INT 0
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 3
38681: NEG
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 4
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 5
38703: NEG
38704: PUSH
38705: LD_INT 0
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 5
38714: NEG
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 5
38726: NEG
38727: PUSH
38728: LD_INT 2
38730: NEG
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 3
38738: NEG
38739: PUSH
38740: LD_INT 2
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 3
38749: NEG
38750: PUSH
38751: LD_INT 3
38753: NEG
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 3
38761: NEG
38762: PUSH
38763: LD_INT 4
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 2
38773: NEG
38774: PUSH
38775: LD_INT 3
38777: NEG
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: LD_INT 2
38789: NEG
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 3
38797: NEG
38798: PUSH
38799: LD_INT 2
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 4
38809: NEG
38810: PUSH
38811: LD_INT 3
38813: NEG
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: LD_INT 4
38821: NEG
38822: PUSH
38823: LD_INT 4
38825: NEG
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: LD_INT 4
38837: NEG
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: PUSH
38843: LD_INT 4
38845: NEG
38846: PUSH
38847: LD_INT 2
38849: NEG
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: LD_INT 4
38860: NEG
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: LD_INT 5
38871: NEG
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: LD_INT 4
38882: NEG
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: LD_INT 3
38893: NEG
38894: PUSH
38895: EMPTY
38896: LIST
38897: LIST
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: LD_INT 3
38904: NEG
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: LD_INT 4
38916: NEG
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 5
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 2
38936: PUSH
38937: LD_INT 3
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 2
38947: NEG
38948: PUSH
38949: LD_INT 5
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 3
38959: PUSH
38960: LD_INT 0
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 3
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 4
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 4
38990: PUSH
38991: LD_INT 1
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 3
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 2
39010: PUSH
39011: LD_INT 0
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 2
39020: PUSH
39021: LD_INT 1
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 2
39031: PUSH
39032: LD_INT 2
39034: NEG
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 4
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 4
39052: PUSH
39053: LD_INT 4
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 4
39062: PUSH
39063: LD_INT 3
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 5
39072: PUSH
39073: LD_INT 4
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 5
39082: PUSH
39083: LD_INT 5
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 4
39092: PUSH
39093: LD_INT 5
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 3
39102: PUSH
39103: LD_INT 4
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 3
39112: PUSH
39113: LD_INT 3
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 5
39122: PUSH
39123: LD_INT 3
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PUSH
39130: LD_INT 3
39132: PUSH
39133: LD_INT 5
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: LIST
39144: LIST
39145: LIST
39146: LIST
39147: LIST
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: LIST
39154: LIST
39155: LIST
39156: LIST
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39187: LD_ADDR_VAR 0 33
39191: PUSH
39192: LD_INT 4
39194: NEG
39195: PUSH
39196: LD_INT 4
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 4
39206: NEG
39207: PUSH
39208: LD_INT 5
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 3
39218: NEG
39219: PUSH
39220: LD_INT 4
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 3
39230: NEG
39231: PUSH
39232: LD_INT 3
39234: NEG
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 4
39242: NEG
39243: PUSH
39244: LD_INT 3
39246: NEG
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 5
39254: NEG
39255: PUSH
39256: LD_INT 4
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: LD_INT 5
39266: NEG
39267: PUSH
39268: LD_INT 5
39270: NEG
39271: PUSH
39272: EMPTY
39273: LIST
39274: LIST
39275: PUSH
39276: LD_INT 3
39278: NEG
39279: PUSH
39280: LD_INT 5
39282: NEG
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 5
39290: NEG
39291: PUSH
39292: LD_INT 3
39294: NEG
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 0
39302: PUSH
39303: LD_INT 3
39305: NEG
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: LD_INT 4
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: PUSH
39325: LD_INT 3
39327: NEG
39328: PUSH
39329: EMPTY
39330: LIST
39331: LIST
39332: PUSH
39333: LD_INT 1
39335: PUSH
39336: LD_INT 2
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 0
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 3
39361: NEG
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: LD_INT 4
39373: NEG
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 2
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 2
39392: NEG
39393: PUSH
39394: LD_INT 4
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: LD_INT 4
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 4
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 5
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: PUSH
39433: LD_INT 5
39435: PUSH
39436: LD_INT 1
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 4
39445: PUSH
39446: LD_INT 1
39448: PUSH
39449: EMPTY
39450: LIST
39451: LIST
39452: PUSH
39453: LD_INT 3
39455: PUSH
39456: LD_INT 0
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 3
39465: PUSH
39466: LD_INT 1
39468: NEG
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 3
39476: PUSH
39477: LD_INT 2
39479: NEG
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 5
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 3
39497: PUSH
39498: LD_INT 3
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 3
39507: PUSH
39508: LD_INT 2
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 4
39517: PUSH
39518: LD_INT 3
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 4
39527: PUSH
39528: LD_INT 4
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 3
39537: PUSH
39538: LD_INT 4
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 2
39547: PUSH
39548: LD_INT 3
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 2
39557: PUSH
39558: LD_INT 2
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 4
39567: PUSH
39568: LD_INT 2
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 2
39577: PUSH
39578: LD_INT 4
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: LD_INT 4
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 0
39597: PUSH
39598: LD_INT 3
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: PUSH
39608: LD_INT 4
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: LD_INT 5
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 0
39627: PUSH
39628: LD_INT 5
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 4
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 1
39648: NEG
39649: PUSH
39650: LD_INT 3
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 2
39659: PUSH
39660: LD_INT 5
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: NEG
39670: PUSH
39671: LD_INT 3
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: LIST
39701: LIST
39702: LIST
39703: LIST
39704: LIST
39705: LIST
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: LIST
39711: LIST
39712: LIST
39713: LIST
39714: LIST
39715: LIST
39716: LIST
39717: LIST
39718: LIST
39719: LIST
39720: LIST
39721: LIST
39722: LIST
39723: LIST
39724: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
39725: LD_ADDR_VAR 0 34
39729: PUSH
39730: LD_INT 0
39732: PUSH
39733: LD_INT 4
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: LD_INT 5
39746: NEG
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: PUSH
39755: LD_INT 4
39757: NEG
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 1
39765: PUSH
39766: LD_INT 3
39768: NEG
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: LD_INT 3
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: LD_INT 4
39791: NEG
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 1
39799: NEG
39800: PUSH
39801: LD_INT 5
39803: NEG
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 2
39811: PUSH
39812: LD_INT 3
39814: NEG
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 2
39822: NEG
39823: PUSH
39824: LD_INT 5
39826: NEG
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 3
39834: PUSH
39835: LD_INT 0
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 4
39855: PUSH
39856: LD_INT 0
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 4
39865: PUSH
39866: LD_INT 1
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 3
39875: PUSH
39876: LD_INT 1
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 2
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 2
39895: PUSH
39896: LD_INT 1
39898: NEG
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 2
39906: PUSH
39907: LD_INT 2
39909: NEG
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 4
39917: PUSH
39918: LD_INT 2
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 4
39927: PUSH
39928: LD_INT 4
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 4
39937: PUSH
39938: LD_INT 3
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 5
39947: PUSH
39948: LD_INT 4
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 5
39957: PUSH
39958: LD_INT 5
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 4
39967: PUSH
39968: LD_INT 5
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 3
39977: PUSH
39978: LD_INT 4
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 3
39987: PUSH
39988: LD_INT 3
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 5
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 3
40007: PUSH
40008: LD_INT 5
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: LD_INT 3
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: PUSH
40025: LD_INT 0
40027: PUSH
40028: LD_INT 2
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 1
40037: PUSH
40038: LD_INT 3
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 1
40047: PUSH
40048: LD_INT 4
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 0
40057: PUSH
40058: LD_INT 4
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: LD_INT 1
40067: NEG
40068: PUSH
40069: LD_INT 3
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 1
40078: NEG
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 2
40089: PUSH
40090: LD_INT 4
40092: PUSH
40093: EMPTY
40094: LIST
40095: LIST
40096: PUSH
40097: LD_INT 2
40099: NEG
40100: PUSH
40101: LD_INT 2
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 4
40110: NEG
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 4
40121: NEG
40122: PUSH
40123: LD_INT 1
40125: NEG
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 3
40133: NEG
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 3
40144: NEG
40145: PUSH
40146: LD_INT 1
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 4
40155: NEG
40156: PUSH
40157: LD_INT 1
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 5
40166: NEG
40167: PUSH
40168: LD_INT 0
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: LD_INT 5
40177: NEG
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 5
40189: NEG
40190: PUSH
40191: LD_INT 2
40193: NEG
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 3
40201: NEG
40202: PUSH
40203: LD_INT 2
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: ST_TO_ADDR
// end ; end ;
40257: GO 40260
40259: POP
// case btype of b_depot , b_warehouse :
40260: LD_VAR 0 1
40264: PUSH
40265: LD_INT 0
40267: DOUBLE
40268: EQUAL
40269: IFTRUE 40279
40271: LD_INT 1
40273: DOUBLE
40274: EQUAL
40275: IFTRUE 40279
40277: GO 40480
40279: POP
// case nation of nation_american :
40280: LD_VAR 0 5
40284: PUSH
40285: LD_INT 1
40287: DOUBLE
40288: EQUAL
40289: IFTRUE 40293
40291: GO 40349
40293: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40294: LD_ADDR_VAR 0 9
40298: PUSH
40299: LD_VAR 0 11
40303: PUSH
40304: LD_VAR 0 12
40308: PUSH
40309: LD_VAR 0 13
40313: PUSH
40314: LD_VAR 0 14
40318: PUSH
40319: LD_VAR 0 15
40323: PUSH
40324: LD_VAR 0 16
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: PUSH
40337: LD_VAR 0 4
40341: PUSH
40342: LD_INT 1
40344: PLUS
40345: ARRAY
40346: ST_TO_ADDR
40347: GO 40478
40349: LD_INT 2
40351: DOUBLE
40352: EQUAL
40353: IFTRUE 40357
40355: GO 40413
40357: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40358: LD_ADDR_VAR 0 9
40362: PUSH
40363: LD_VAR 0 17
40367: PUSH
40368: LD_VAR 0 18
40372: PUSH
40373: LD_VAR 0 19
40377: PUSH
40378: LD_VAR 0 20
40382: PUSH
40383: LD_VAR 0 21
40387: PUSH
40388: LD_VAR 0 22
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: LIST
40397: LIST
40398: LIST
40399: LIST
40400: PUSH
40401: LD_VAR 0 4
40405: PUSH
40406: LD_INT 1
40408: PLUS
40409: ARRAY
40410: ST_TO_ADDR
40411: GO 40478
40413: LD_INT 3
40415: DOUBLE
40416: EQUAL
40417: IFTRUE 40421
40419: GO 40477
40421: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40422: LD_ADDR_VAR 0 9
40426: PUSH
40427: LD_VAR 0 23
40431: PUSH
40432: LD_VAR 0 24
40436: PUSH
40437: LD_VAR 0 25
40441: PUSH
40442: LD_VAR 0 26
40446: PUSH
40447: LD_VAR 0 27
40451: PUSH
40452: LD_VAR 0 28
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: PUSH
40465: LD_VAR 0 4
40469: PUSH
40470: LD_INT 1
40472: PLUS
40473: ARRAY
40474: ST_TO_ADDR
40475: GO 40478
40477: POP
40478: GO 41033
40480: LD_INT 2
40482: DOUBLE
40483: EQUAL
40484: IFTRUE 40494
40486: LD_INT 3
40488: DOUBLE
40489: EQUAL
40490: IFTRUE 40494
40492: GO 40550
40494: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40495: LD_ADDR_VAR 0 9
40499: PUSH
40500: LD_VAR 0 29
40504: PUSH
40505: LD_VAR 0 30
40509: PUSH
40510: LD_VAR 0 31
40514: PUSH
40515: LD_VAR 0 32
40519: PUSH
40520: LD_VAR 0 33
40524: PUSH
40525: LD_VAR 0 34
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: PUSH
40538: LD_VAR 0 4
40542: PUSH
40543: LD_INT 1
40545: PLUS
40546: ARRAY
40547: ST_TO_ADDR
40548: GO 41033
40550: LD_INT 16
40552: DOUBLE
40553: EQUAL
40554: IFTRUE 40612
40556: LD_INT 17
40558: DOUBLE
40559: EQUAL
40560: IFTRUE 40612
40562: LD_INT 18
40564: DOUBLE
40565: EQUAL
40566: IFTRUE 40612
40568: LD_INT 19
40570: DOUBLE
40571: EQUAL
40572: IFTRUE 40612
40574: LD_INT 22
40576: DOUBLE
40577: EQUAL
40578: IFTRUE 40612
40580: LD_INT 20
40582: DOUBLE
40583: EQUAL
40584: IFTRUE 40612
40586: LD_INT 21
40588: DOUBLE
40589: EQUAL
40590: IFTRUE 40612
40592: LD_INT 23
40594: DOUBLE
40595: EQUAL
40596: IFTRUE 40612
40598: LD_INT 24
40600: DOUBLE
40601: EQUAL
40602: IFTRUE 40612
40604: LD_INT 25
40606: DOUBLE
40607: EQUAL
40608: IFTRUE 40612
40610: GO 40668
40612: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
40613: LD_ADDR_VAR 0 9
40617: PUSH
40618: LD_VAR 0 35
40622: PUSH
40623: LD_VAR 0 36
40627: PUSH
40628: LD_VAR 0 37
40632: PUSH
40633: LD_VAR 0 38
40637: PUSH
40638: LD_VAR 0 39
40642: PUSH
40643: LD_VAR 0 40
40647: PUSH
40648: EMPTY
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: PUSH
40656: LD_VAR 0 4
40660: PUSH
40661: LD_INT 1
40663: PLUS
40664: ARRAY
40665: ST_TO_ADDR
40666: GO 41033
40668: LD_INT 6
40670: DOUBLE
40671: EQUAL
40672: IFTRUE 40724
40674: LD_INT 7
40676: DOUBLE
40677: EQUAL
40678: IFTRUE 40724
40680: LD_INT 8
40682: DOUBLE
40683: EQUAL
40684: IFTRUE 40724
40686: LD_INT 13
40688: DOUBLE
40689: EQUAL
40690: IFTRUE 40724
40692: LD_INT 12
40694: DOUBLE
40695: EQUAL
40696: IFTRUE 40724
40698: LD_INT 15
40700: DOUBLE
40701: EQUAL
40702: IFTRUE 40724
40704: LD_INT 11
40706: DOUBLE
40707: EQUAL
40708: IFTRUE 40724
40710: LD_INT 14
40712: DOUBLE
40713: EQUAL
40714: IFTRUE 40724
40716: LD_INT 10
40718: DOUBLE
40719: EQUAL
40720: IFTRUE 40724
40722: GO 40780
40724: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
40725: LD_ADDR_VAR 0 9
40729: PUSH
40730: LD_VAR 0 41
40734: PUSH
40735: LD_VAR 0 42
40739: PUSH
40740: LD_VAR 0 43
40744: PUSH
40745: LD_VAR 0 44
40749: PUSH
40750: LD_VAR 0 45
40754: PUSH
40755: LD_VAR 0 46
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: LIST
40766: LIST
40767: PUSH
40768: LD_VAR 0 4
40772: PUSH
40773: LD_INT 1
40775: PLUS
40776: ARRAY
40777: ST_TO_ADDR
40778: GO 41033
40780: LD_INT 36
40782: DOUBLE
40783: EQUAL
40784: IFTRUE 40788
40786: GO 40844
40788: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
40789: LD_ADDR_VAR 0 9
40793: PUSH
40794: LD_VAR 0 47
40798: PUSH
40799: LD_VAR 0 48
40803: PUSH
40804: LD_VAR 0 49
40808: PUSH
40809: LD_VAR 0 50
40813: PUSH
40814: LD_VAR 0 51
40818: PUSH
40819: LD_VAR 0 52
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: LIST
40828: LIST
40829: LIST
40830: LIST
40831: PUSH
40832: LD_VAR 0 4
40836: PUSH
40837: LD_INT 1
40839: PLUS
40840: ARRAY
40841: ST_TO_ADDR
40842: GO 41033
40844: LD_INT 4
40846: DOUBLE
40847: EQUAL
40848: IFTRUE 40870
40850: LD_INT 5
40852: DOUBLE
40853: EQUAL
40854: IFTRUE 40870
40856: LD_INT 34
40858: DOUBLE
40859: EQUAL
40860: IFTRUE 40870
40862: LD_INT 37
40864: DOUBLE
40865: EQUAL
40866: IFTRUE 40870
40868: GO 40926
40870: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
40871: LD_ADDR_VAR 0 9
40875: PUSH
40876: LD_VAR 0 53
40880: PUSH
40881: LD_VAR 0 54
40885: PUSH
40886: LD_VAR 0 55
40890: PUSH
40891: LD_VAR 0 56
40895: PUSH
40896: LD_VAR 0 57
40900: PUSH
40901: LD_VAR 0 58
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: LIST
40913: PUSH
40914: LD_VAR 0 4
40918: PUSH
40919: LD_INT 1
40921: PLUS
40922: ARRAY
40923: ST_TO_ADDR
40924: GO 41033
40926: LD_INT 31
40928: DOUBLE
40929: EQUAL
40930: IFTRUE 40976
40932: LD_INT 32
40934: DOUBLE
40935: EQUAL
40936: IFTRUE 40976
40938: LD_INT 33
40940: DOUBLE
40941: EQUAL
40942: IFTRUE 40976
40944: LD_INT 27
40946: DOUBLE
40947: EQUAL
40948: IFTRUE 40976
40950: LD_INT 26
40952: DOUBLE
40953: EQUAL
40954: IFTRUE 40976
40956: LD_INT 28
40958: DOUBLE
40959: EQUAL
40960: IFTRUE 40976
40962: LD_INT 29
40964: DOUBLE
40965: EQUAL
40966: IFTRUE 40976
40968: LD_INT 30
40970: DOUBLE
40971: EQUAL
40972: IFTRUE 40976
40974: GO 41032
40976: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
40977: LD_ADDR_VAR 0 9
40981: PUSH
40982: LD_VAR 0 59
40986: PUSH
40987: LD_VAR 0 60
40991: PUSH
40992: LD_VAR 0 61
40996: PUSH
40997: LD_VAR 0 62
41001: PUSH
41002: LD_VAR 0 63
41006: PUSH
41007: LD_VAR 0 64
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: LIST
41019: PUSH
41020: LD_VAR 0 4
41024: PUSH
41025: LD_INT 1
41027: PLUS
41028: ARRAY
41029: ST_TO_ADDR
41030: GO 41033
41032: POP
// temp_list2 = [ ] ;
41033: LD_ADDR_VAR 0 10
41037: PUSH
41038: EMPTY
41039: ST_TO_ADDR
// for i in temp_list do
41040: LD_ADDR_VAR 0 8
41044: PUSH
41045: LD_VAR 0 9
41049: PUSH
41050: FOR_IN
41051: IFFALSE 41103
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41053: LD_ADDR_VAR 0 10
41057: PUSH
41058: LD_VAR 0 10
41062: PUSH
41063: LD_VAR 0 8
41067: PUSH
41068: LD_INT 1
41070: ARRAY
41071: PUSH
41072: LD_VAR 0 2
41076: PLUS
41077: PUSH
41078: LD_VAR 0 8
41082: PUSH
41083: LD_INT 2
41085: ARRAY
41086: PUSH
41087: LD_VAR 0 3
41091: PLUS
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: EMPTY
41098: LIST
41099: ADD
41100: ST_TO_ADDR
41101: GO 41050
41103: POP
41104: POP
// result = temp_list2 ;
41105: LD_ADDR_VAR 0 7
41109: PUSH
41110: LD_VAR 0 10
41114: ST_TO_ADDR
// end ;
41115: LD_VAR 0 7
41119: RET
// export function EnemyInRange ( unit , dist ) ; begin
41120: LD_INT 0
41122: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41123: LD_ADDR_VAR 0 3
41127: PUSH
41128: LD_VAR 0 1
41132: PPUSH
41133: CALL_OW 255
41137: PPUSH
41138: LD_VAR 0 1
41142: PPUSH
41143: CALL_OW 250
41147: PPUSH
41148: LD_VAR 0 1
41152: PPUSH
41153: CALL_OW 251
41157: PPUSH
41158: LD_VAR 0 2
41162: PPUSH
41163: CALL 14515 0 4
41167: PUSH
41168: LD_INT 4
41170: ARRAY
41171: ST_TO_ADDR
// end ;
41172: LD_VAR 0 3
41176: RET
// export function PlayerSeeMe ( unit ) ; begin
41177: LD_INT 0
41179: PPUSH
// result := See ( your_side , unit ) ;
41180: LD_ADDR_VAR 0 2
41184: PUSH
41185: LD_OWVAR 2
41189: PPUSH
41190: LD_VAR 0 1
41194: PPUSH
41195: CALL_OW 292
41199: ST_TO_ADDR
// end ;
41200: LD_VAR 0 2
41204: RET
// export function ReverseDir ( unit ) ; begin
41205: LD_INT 0
41207: PPUSH
// if not unit then
41208: LD_VAR 0 1
41212: NOT
41213: IFFALSE 41217
// exit ;
41215: GO 41240
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41217: LD_ADDR_VAR 0 2
41221: PUSH
41222: LD_VAR 0 1
41226: PPUSH
41227: CALL_OW 254
41231: PUSH
41232: LD_INT 3
41234: PLUS
41235: PUSH
41236: LD_INT 6
41238: MOD
41239: ST_TO_ADDR
// end ;
41240: LD_VAR 0 2
41244: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41245: LD_INT 0
41247: PPUSH
41248: PPUSH
41249: PPUSH
41250: PPUSH
41251: PPUSH
// if not hexes then
41252: LD_VAR 0 2
41256: NOT
41257: IFFALSE 41261
// exit ;
41259: GO 41409
// dist := 9999 ;
41261: LD_ADDR_VAR 0 5
41265: PUSH
41266: LD_INT 9999
41268: ST_TO_ADDR
// for i = 1 to hexes do
41269: LD_ADDR_VAR 0 4
41273: PUSH
41274: DOUBLE
41275: LD_INT 1
41277: DEC
41278: ST_TO_ADDR
41279: LD_VAR 0 2
41283: PUSH
41284: FOR_TO
41285: IFFALSE 41397
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41287: LD_VAR 0 1
41291: PPUSH
41292: LD_VAR 0 2
41296: PUSH
41297: LD_VAR 0 4
41301: ARRAY
41302: PUSH
41303: LD_INT 1
41305: ARRAY
41306: PPUSH
41307: LD_VAR 0 2
41311: PUSH
41312: LD_VAR 0 4
41316: ARRAY
41317: PUSH
41318: LD_INT 2
41320: ARRAY
41321: PPUSH
41322: CALL_OW 297
41326: PUSH
41327: LD_VAR 0 5
41331: LESS
41332: IFFALSE 41395
// begin hex := hexes [ i ] ;
41334: LD_ADDR_VAR 0 7
41338: PUSH
41339: LD_VAR 0 2
41343: PUSH
41344: LD_VAR 0 4
41348: ARRAY
41349: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41350: LD_ADDR_VAR 0 5
41354: PUSH
41355: LD_VAR 0 1
41359: PPUSH
41360: LD_VAR 0 2
41364: PUSH
41365: LD_VAR 0 4
41369: ARRAY
41370: PUSH
41371: LD_INT 1
41373: ARRAY
41374: PPUSH
41375: LD_VAR 0 2
41379: PUSH
41380: LD_VAR 0 4
41384: ARRAY
41385: PUSH
41386: LD_INT 2
41388: ARRAY
41389: PPUSH
41390: CALL_OW 297
41394: ST_TO_ADDR
// end ; end ;
41395: GO 41284
41397: POP
41398: POP
// result := hex ;
41399: LD_ADDR_VAR 0 3
41403: PUSH
41404: LD_VAR 0 7
41408: ST_TO_ADDR
// end ;
41409: LD_VAR 0 3
41413: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41414: LD_INT 0
41416: PPUSH
41417: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41418: LD_VAR 0 1
41422: NOT
41423: PUSH
41424: LD_VAR 0 1
41428: PUSH
41429: LD_INT 21
41431: PUSH
41432: LD_INT 2
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 23
41441: PUSH
41442: LD_INT 2
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PPUSH
41453: CALL_OW 69
41457: IN
41458: NOT
41459: OR
41460: IFFALSE 41464
// exit ;
41462: GO 41511
// for i = 1 to 3 do
41464: LD_ADDR_VAR 0 3
41468: PUSH
41469: DOUBLE
41470: LD_INT 1
41472: DEC
41473: ST_TO_ADDR
41474: LD_INT 3
41476: PUSH
41477: FOR_TO
41478: IFFALSE 41509
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41480: LD_VAR 0 1
41484: PPUSH
41485: CALL_OW 250
41489: PPUSH
41490: LD_VAR 0 1
41494: PPUSH
41495: CALL_OW 251
41499: PPUSH
41500: LD_INT 1
41502: PPUSH
41503: CALL_OW 453
41507: GO 41477
41509: POP
41510: POP
// end ;
41511: LD_VAR 0 2
41515: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41516: LD_INT 0
41518: PPUSH
41519: PPUSH
41520: PPUSH
41521: PPUSH
41522: PPUSH
41523: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
41524: LD_VAR 0 1
41528: NOT
41529: PUSH
41530: LD_VAR 0 2
41534: NOT
41535: OR
41536: PUSH
41537: LD_VAR 0 1
41541: PPUSH
41542: CALL_OW 314
41546: OR
41547: IFFALSE 41551
// exit ;
41549: GO 41992
// x := GetX ( enemy_unit ) ;
41551: LD_ADDR_VAR 0 7
41555: PUSH
41556: LD_VAR 0 2
41560: PPUSH
41561: CALL_OW 250
41565: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
41566: LD_ADDR_VAR 0 8
41570: PUSH
41571: LD_VAR 0 2
41575: PPUSH
41576: CALL_OW 251
41580: ST_TO_ADDR
// if not x or not y then
41581: LD_VAR 0 7
41585: NOT
41586: PUSH
41587: LD_VAR 0 8
41591: NOT
41592: OR
41593: IFFALSE 41597
// exit ;
41595: GO 41992
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
41597: LD_ADDR_VAR 0 6
41601: PUSH
41602: LD_VAR 0 7
41606: PPUSH
41607: LD_INT 0
41609: PPUSH
41610: LD_INT 4
41612: PPUSH
41613: CALL_OW 272
41617: PUSH
41618: LD_VAR 0 8
41622: PPUSH
41623: LD_INT 0
41625: PPUSH
41626: LD_INT 4
41628: PPUSH
41629: CALL_OW 273
41633: PUSH
41634: EMPTY
41635: LIST
41636: LIST
41637: PUSH
41638: LD_VAR 0 7
41642: PPUSH
41643: LD_INT 1
41645: PPUSH
41646: LD_INT 4
41648: PPUSH
41649: CALL_OW 272
41653: PUSH
41654: LD_VAR 0 8
41658: PPUSH
41659: LD_INT 1
41661: PPUSH
41662: LD_INT 4
41664: PPUSH
41665: CALL_OW 273
41669: PUSH
41670: EMPTY
41671: LIST
41672: LIST
41673: PUSH
41674: LD_VAR 0 7
41678: PPUSH
41679: LD_INT 2
41681: PPUSH
41682: LD_INT 4
41684: PPUSH
41685: CALL_OW 272
41689: PUSH
41690: LD_VAR 0 8
41694: PPUSH
41695: LD_INT 2
41697: PPUSH
41698: LD_INT 4
41700: PPUSH
41701: CALL_OW 273
41705: PUSH
41706: EMPTY
41707: LIST
41708: LIST
41709: PUSH
41710: LD_VAR 0 7
41714: PPUSH
41715: LD_INT 3
41717: PPUSH
41718: LD_INT 4
41720: PPUSH
41721: CALL_OW 272
41725: PUSH
41726: LD_VAR 0 8
41730: PPUSH
41731: LD_INT 3
41733: PPUSH
41734: LD_INT 4
41736: PPUSH
41737: CALL_OW 273
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_VAR 0 7
41750: PPUSH
41751: LD_INT 4
41753: PPUSH
41754: LD_INT 4
41756: PPUSH
41757: CALL_OW 272
41761: PUSH
41762: LD_VAR 0 8
41766: PPUSH
41767: LD_INT 4
41769: PPUSH
41770: LD_INT 4
41772: PPUSH
41773: CALL_OW 273
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_VAR 0 7
41786: PPUSH
41787: LD_INT 5
41789: PPUSH
41790: LD_INT 4
41792: PPUSH
41793: CALL_OW 272
41797: PUSH
41798: LD_VAR 0 8
41802: PPUSH
41803: LD_INT 5
41805: PPUSH
41806: LD_INT 4
41808: PPUSH
41809: CALL_OW 273
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: LIST
41822: LIST
41823: LIST
41824: LIST
41825: ST_TO_ADDR
// for i = tmp downto 1 do
41826: LD_ADDR_VAR 0 4
41830: PUSH
41831: DOUBLE
41832: LD_VAR 0 6
41836: INC
41837: ST_TO_ADDR
41838: LD_INT 1
41840: PUSH
41841: FOR_DOWNTO
41842: IFFALSE 41943
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
41844: LD_VAR 0 6
41848: PUSH
41849: LD_VAR 0 4
41853: ARRAY
41854: PUSH
41855: LD_INT 1
41857: ARRAY
41858: PPUSH
41859: LD_VAR 0 6
41863: PUSH
41864: LD_VAR 0 4
41868: ARRAY
41869: PUSH
41870: LD_INT 2
41872: ARRAY
41873: PPUSH
41874: CALL_OW 488
41878: NOT
41879: PUSH
41880: LD_VAR 0 6
41884: PUSH
41885: LD_VAR 0 4
41889: ARRAY
41890: PUSH
41891: LD_INT 1
41893: ARRAY
41894: PPUSH
41895: LD_VAR 0 6
41899: PUSH
41900: LD_VAR 0 4
41904: ARRAY
41905: PUSH
41906: LD_INT 2
41908: ARRAY
41909: PPUSH
41910: CALL_OW 428
41914: PUSH
41915: LD_INT 0
41917: NONEQUAL
41918: OR
41919: IFFALSE 41941
// tmp := Delete ( tmp , i ) ;
41921: LD_ADDR_VAR 0 6
41925: PUSH
41926: LD_VAR 0 6
41930: PPUSH
41931: LD_VAR 0 4
41935: PPUSH
41936: CALL_OW 3
41940: ST_TO_ADDR
41941: GO 41841
41943: POP
41944: POP
// j := GetClosestHex ( unit , tmp ) ;
41945: LD_ADDR_VAR 0 5
41949: PUSH
41950: LD_VAR 0 1
41954: PPUSH
41955: LD_VAR 0 6
41959: PPUSH
41960: CALL 41245 0 2
41964: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
41965: LD_VAR 0 1
41969: PPUSH
41970: LD_VAR 0 5
41974: PUSH
41975: LD_INT 1
41977: ARRAY
41978: PPUSH
41979: LD_VAR 0 5
41983: PUSH
41984: LD_INT 2
41986: ARRAY
41987: PPUSH
41988: CALL_OW 111
// end ;
41992: LD_VAR 0 3
41996: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
41997: LD_INT 0
41999: PPUSH
42000: PPUSH
42001: PPUSH
// uc_side = 0 ;
42002: LD_ADDR_OWVAR 20
42006: PUSH
42007: LD_INT 0
42009: ST_TO_ADDR
// uc_nation = 0 ;
42010: LD_ADDR_OWVAR 21
42014: PUSH
42015: LD_INT 0
42017: ST_TO_ADDR
// InitHc_All ( ) ;
42018: CALL_OW 584
// InitVc ;
42022: CALL_OW 20
// if mastodonts then
42026: LD_VAR 0 6
42030: IFFALSE 42097
// for i = 1 to mastodonts do
42032: LD_ADDR_VAR 0 11
42036: PUSH
42037: DOUBLE
42038: LD_INT 1
42040: DEC
42041: ST_TO_ADDR
42042: LD_VAR 0 6
42046: PUSH
42047: FOR_TO
42048: IFFALSE 42095
// begin vc_chassis := 31 ;
42050: LD_ADDR_OWVAR 37
42054: PUSH
42055: LD_INT 31
42057: ST_TO_ADDR
// vc_control := control_rider ;
42058: LD_ADDR_OWVAR 38
42062: PUSH
42063: LD_INT 4
42065: ST_TO_ADDR
// animal := CreateVehicle ;
42066: LD_ADDR_VAR 0 12
42070: PUSH
42071: CALL_OW 45
42075: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42076: LD_VAR 0 12
42080: PPUSH
42081: LD_VAR 0 8
42085: PPUSH
42086: LD_INT 0
42088: PPUSH
42089: CALL 44285 0 3
// end ;
42093: GO 42047
42095: POP
42096: POP
// if horses then
42097: LD_VAR 0 5
42101: IFFALSE 42168
// for i = 1 to horses do
42103: LD_ADDR_VAR 0 11
42107: PUSH
42108: DOUBLE
42109: LD_INT 1
42111: DEC
42112: ST_TO_ADDR
42113: LD_VAR 0 5
42117: PUSH
42118: FOR_TO
42119: IFFALSE 42166
// begin hc_class := 21 ;
42121: LD_ADDR_OWVAR 28
42125: PUSH
42126: LD_INT 21
42128: ST_TO_ADDR
// hc_gallery :=  ;
42129: LD_ADDR_OWVAR 33
42133: PUSH
42134: LD_STRING 
42136: ST_TO_ADDR
// animal := CreateHuman ;
42137: LD_ADDR_VAR 0 12
42141: PUSH
42142: CALL_OW 44
42146: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42147: LD_VAR 0 12
42151: PPUSH
42152: LD_VAR 0 8
42156: PPUSH
42157: LD_INT 0
42159: PPUSH
42160: CALL 44285 0 3
// end ;
42164: GO 42118
42166: POP
42167: POP
// if birds then
42168: LD_VAR 0 1
42172: IFFALSE 42239
// for i = 1 to birds do
42174: LD_ADDR_VAR 0 11
42178: PUSH
42179: DOUBLE
42180: LD_INT 1
42182: DEC
42183: ST_TO_ADDR
42184: LD_VAR 0 1
42188: PUSH
42189: FOR_TO
42190: IFFALSE 42237
// begin hc_class = 18 ;
42192: LD_ADDR_OWVAR 28
42196: PUSH
42197: LD_INT 18
42199: ST_TO_ADDR
// hc_gallery =  ;
42200: LD_ADDR_OWVAR 33
42204: PUSH
42205: LD_STRING 
42207: ST_TO_ADDR
// animal := CreateHuman ;
42208: LD_ADDR_VAR 0 12
42212: PUSH
42213: CALL_OW 44
42217: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42218: LD_VAR 0 12
42222: PPUSH
42223: LD_VAR 0 8
42227: PPUSH
42228: LD_INT 0
42230: PPUSH
42231: CALL 44285 0 3
// end ;
42235: GO 42189
42237: POP
42238: POP
// if tigers then
42239: LD_VAR 0 2
42243: IFFALSE 42327
// for i = 1 to tigers do
42245: LD_ADDR_VAR 0 11
42249: PUSH
42250: DOUBLE
42251: LD_INT 1
42253: DEC
42254: ST_TO_ADDR
42255: LD_VAR 0 2
42259: PUSH
42260: FOR_TO
42261: IFFALSE 42325
// begin hc_class = class_tiger ;
42263: LD_ADDR_OWVAR 28
42267: PUSH
42268: LD_INT 14
42270: ST_TO_ADDR
// hc_gallery =  ;
42271: LD_ADDR_OWVAR 33
42275: PUSH
42276: LD_STRING 
42278: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42279: LD_ADDR_OWVAR 35
42283: PUSH
42284: LD_INT 7
42286: NEG
42287: PPUSH
42288: LD_INT 7
42290: PPUSH
42291: CALL_OW 12
42295: ST_TO_ADDR
// animal := CreateHuman ;
42296: LD_ADDR_VAR 0 12
42300: PUSH
42301: CALL_OW 44
42305: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42306: LD_VAR 0 12
42310: PPUSH
42311: LD_VAR 0 8
42315: PPUSH
42316: LD_INT 0
42318: PPUSH
42319: CALL 44285 0 3
// end ;
42323: GO 42260
42325: POP
42326: POP
// if apemans then
42327: LD_VAR 0 3
42331: IFFALSE 42454
// for i = 1 to apemans do
42333: LD_ADDR_VAR 0 11
42337: PUSH
42338: DOUBLE
42339: LD_INT 1
42341: DEC
42342: ST_TO_ADDR
42343: LD_VAR 0 3
42347: PUSH
42348: FOR_TO
42349: IFFALSE 42452
// begin hc_class = class_apeman ;
42351: LD_ADDR_OWVAR 28
42355: PUSH
42356: LD_INT 12
42358: ST_TO_ADDR
// hc_gallery =  ;
42359: LD_ADDR_OWVAR 33
42363: PUSH
42364: LD_STRING 
42366: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42367: LD_ADDR_OWVAR 35
42371: PUSH
42372: LD_INT 5
42374: NEG
42375: PPUSH
42376: LD_INT 5
42378: PPUSH
42379: CALL_OW 12
42383: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42384: LD_ADDR_OWVAR 31
42388: PUSH
42389: LD_INT 1
42391: PPUSH
42392: LD_INT 3
42394: PPUSH
42395: CALL_OW 12
42399: PUSH
42400: LD_INT 1
42402: PPUSH
42403: LD_INT 3
42405: PPUSH
42406: CALL_OW 12
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: LD_INT 0
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: ST_TO_ADDR
// animal := CreateHuman ;
42423: LD_ADDR_VAR 0 12
42427: PUSH
42428: CALL_OW 44
42432: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42433: LD_VAR 0 12
42437: PPUSH
42438: LD_VAR 0 8
42442: PPUSH
42443: LD_INT 0
42445: PPUSH
42446: CALL 44285 0 3
// end ;
42450: GO 42348
42452: POP
42453: POP
// if enchidnas then
42454: LD_VAR 0 4
42458: IFFALSE 42525
// for i = 1 to enchidnas do
42460: LD_ADDR_VAR 0 11
42464: PUSH
42465: DOUBLE
42466: LD_INT 1
42468: DEC
42469: ST_TO_ADDR
42470: LD_VAR 0 4
42474: PUSH
42475: FOR_TO
42476: IFFALSE 42523
// begin hc_class = 13 ;
42478: LD_ADDR_OWVAR 28
42482: PUSH
42483: LD_INT 13
42485: ST_TO_ADDR
// hc_gallery =  ;
42486: LD_ADDR_OWVAR 33
42490: PUSH
42491: LD_STRING 
42493: ST_TO_ADDR
// animal := CreateHuman ;
42494: LD_ADDR_VAR 0 12
42498: PUSH
42499: CALL_OW 44
42503: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42504: LD_VAR 0 12
42508: PPUSH
42509: LD_VAR 0 8
42513: PPUSH
42514: LD_INT 0
42516: PPUSH
42517: CALL 44285 0 3
// end ;
42521: GO 42475
42523: POP
42524: POP
// if fishes then
42525: LD_VAR 0 7
42529: IFFALSE 42596
// for i = 1 to fishes do
42531: LD_ADDR_VAR 0 11
42535: PUSH
42536: DOUBLE
42537: LD_INT 1
42539: DEC
42540: ST_TO_ADDR
42541: LD_VAR 0 7
42545: PUSH
42546: FOR_TO
42547: IFFALSE 42594
// begin hc_class = 20 ;
42549: LD_ADDR_OWVAR 28
42553: PUSH
42554: LD_INT 20
42556: ST_TO_ADDR
// hc_gallery =  ;
42557: LD_ADDR_OWVAR 33
42561: PUSH
42562: LD_STRING 
42564: ST_TO_ADDR
// animal := CreateHuman ;
42565: LD_ADDR_VAR 0 12
42569: PUSH
42570: CALL_OW 44
42574: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
42575: LD_VAR 0 12
42579: PPUSH
42580: LD_VAR 0 9
42584: PPUSH
42585: LD_INT 0
42587: PPUSH
42588: CALL 44285 0 3
// end ;
42592: GO 42546
42594: POP
42595: POP
// end ;
42596: LD_VAR 0 10
42600: RET
// export function WantHeal ( sci , unit ) ; begin
42601: LD_INT 0
42603: PPUSH
// if GetTaskList ( sci ) > 0 then
42604: LD_VAR 0 1
42608: PPUSH
42609: CALL_OW 437
42613: PUSH
42614: LD_INT 0
42616: GREATER
42617: IFFALSE 42687
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
42619: LD_VAR 0 1
42623: PPUSH
42624: CALL_OW 437
42628: PUSH
42629: LD_INT 1
42631: ARRAY
42632: PUSH
42633: LD_INT 1
42635: ARRAY
42636: PUSH
42637: LD_STRING l
42639: EQUAL
42640: PUSH
42641: LD_VAR 0 1
42645: PPUSH
42646: CALL_OW 437
42650: PUSH
42651: LD_INT 1
42653: ARRAY
42654: PUSH
42655: LD_INT 4
42657: ARRAY
42658: PUSH
42659: LD_VAR 0 2
42663: EQUAL
42664: AND
42665: IFFALSE 42677
// result := true else
42667: LD_ADDR_VAR 0 3
42671: PUSH
42672: LD_INT 1
42674: ST_TO_ADDR
42675: GO 42685
// result := false ;
42677: LD_ADDR_VAR 0 3
42681: PUSH
42682: LD_INT 0
42684: ST_TO_ADDR
// end else
42685: GO 42695
// result := false ;
42687: LD_ADDR_VAR 0 3
42691: PUSH
42692: LD_INT 0
42694: ST_TO_ADDR
// end ;
42695: LD_VAR 0 3
42699: RET
// export function HealTarget ( sci ) ; begin
42700: LD_INT 0
42702: PPUSH
// if not sci then
42703: LD_VAR 0 1
42707: NOT
42708: IFFALSE 42712
// exit ;
42710: GO 42777
// result := 0 ;
42712: LD_ADDR_VAR 0 2
42716: PUSH
42717: LD_INT 0
42719: ST_TO_ADDR
// if GetTaskList ( sci ) then
42720: LD_VAR 0 1
42724: PPUSH
42725: CALL_OW 437
42729: IFFALSE 42777
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
42731: LD_VAR 0 1
42735: PPUSH
42736: CALL_OW 437
42740: PUSH
42741: LD_INT 1
42743: ARRAY
42744: PUSH
42745: LD_INT 1
42747: ARRAY
42748: PUSH
42749: LD_STRING l
42751: EQUAL
42752: IFFALSE 42777
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
42754: LD_ADDR_VAR 0 2
42758: PUSH
42759: LD_VAR 0 1
42763: PPUSH
42764: CALL_OW 437
42768: PUSH
42769: LD_INT 1
42771: ARRAY
42772: PUSH
42773: LD_INT 4
42775: ARRAY
42776: ST_TO_ADDR
// end ;
42777: LD_VAR 0 2
42781: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
42782: LD_INT 0
42784: PPUSH
42785: PPUSH
42786: PPUSH
42787: PPUSH
// if not base_units then
42788: LD_VAR 0 1
42792: NOT
42793: IFFALSE 42797
// exit ;
42795: GO 42884
// result := false ;
42797: LD_ADDR_VAR 0 2
42801: PUSH
42802: LD_INT 0
42804: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
42805: LD_ADDR_VAR 0 5
42809: PUSH
42810: LD_VAR 0 1
42814: PPUSH
42815: LD_INT 21
42817: PUSH
42818: LD_INT 3
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PPUSH
42825: CALL_OW 72
42829: ST_TO_ADDR
// if not tmp then
42830: LD_VAR 0 5
42834: NOT
42835: IFFALSE 42839
// exit ;
42837: GO 42884
// for i in tmp do
42839: LD_ADDR_VAR 0 3
42843: PUSH
42844: LD_VAR 0 5
42848: PUSH
42849: FOR_IN
42850: IFFALSE 42882
// begin result := EnemyInRange ( i , 22 ) ;
42852: LD_ADDR_VAR 0 2
42856: PUSH
42857: LD_VAR 0 3
42861: PPUSH
42862: LD_INT 22
42864: PPUSH
42865: CALL 41120 0 2
42869: ST_TO_ADDR
// if result then
42870: LD_VAR 0 2
42874: IFFALSE 42880
// exit ;
42876: POP
42877: POP
42878: GO 42884
// end ;
42880: GO 42849
42882: POP
42883: POP
// end ;
42884: LD_VAR 0 2
42888: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
42889: LD_INT 0
42891: PPUSH
42892: PPUSH
// if not units then
42893: LD_VAR 0 1
42897: NOT
42898: IFFALSE 42902
// exit ;
42900: GO 42972
// result := [ ] ;
42902: LD_ADDR_VAR 0 3
42906: PUSH
42907: EMPTY
42908: ST_TO_ADDR
// for i in units do
42909: LD_ADDR_VAR 0 4
42913: PUSH
42914: LD_VAR 0 1
42918: PUSH
42919: FOR_IN
42920: IFFALSE 42970
// if GetTag ( i ) = tag then
42922: LD_VAR 0 4
42926: PPUSH
42927: CALL_OW 110
42931: PUSH
42932: LD_VAR 0 2
42936: EQUAL
42937: IFFALSE 42968
// result := Insert ( result , result + 1 , i ) ;
42939: LD_ADDR_VAR 0 3
42943: PUSH
42944: LD_VAR 0 3
42948: PPUSH
42949: LD_VAR 0 3
42953: PUSH
42954: LD_INT 1
42956: PLUS
42957: PPUSH
42958: LD_VAR 0 4
42962: PPUSH
42963: CALL_OW 2
42967: ST_TO_ADDR
42968: GO 42919
42970: POP
42971: POP
// end ;
42972: LD_VAR 0 3
42976: RET
// export function IsDriver ( un ) ; begin
42977: LD_INT 0
42979: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
42980: LD_ADDR_VAR 0 2
42984: PUSH
42985: LD_VAR 0 1
42989: PUSH
42990: LD_INT 55
42992: PUSH
42993: EMPTY
42994: LIST
42995: PPUSH
42996: CALL_OW 69
43000: IN
43001: ST_TO_ADDR
// end ;
43002: LD_VAR 0 2
43006: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43007: LD_INT 0
43009: PPUSH
43010: PPUSH
// list := [ ] ;
43011: LD_ADDR_VAR 0 5
43015: PUSH
43016: EMPTY
43017: ST_TO_ADDR
// case d of 0 :
43018: LD_VAR 0 3
43022: PUSH
43023: LD_INT 0
43025: DOUBLE
43026: EQUAL
43027: IFTRUE 43031
43029: GO 43164
43031: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43032: LD_ADDR_VAR 0 5
43036: PUSH
43037: LD_VAR 0 1
43041: PUSH
43042: LD_INT 4
43044: MINUS
43045: PUSH
43046: LD_VAR 0 2
43050: PUSH
43051: LD_INT 4
43053: MINUS
43054: PUSH
43055: LD_INT 2
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: LIST
43062: PUSH
43063: LD_VAR 0 1
43067: PUSH
43068: LD_INT 3
43070: MINUS
43071: PUSH
43072: LD_VAR 0 2
43076: PUSH
43077: LD_INT 1
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: LIST
43084: PUSH
43085: LD_VAR 0 1
43089: PUSH
43090: LD_INT 4
43092: PLUS
43093: PUSH
43094: LD_VAR 0 2
43098: PUSH
43099: LD_INT 4
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: LIST
43106: PUSH
43107: LD_VAR 0 1
43111: PUSH
43112: LD_INT 3
43114: PLUS
43115: PUSH
43116: LD_VAR 0 2
43120: PUSH
43121: LD_INT 3
43123: PLUS
43124: PUSH
43125: LD_INT 5
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: LIST
43132: PUSH
43133: LD_VAR 0 1
43137: PUSH
43138: LD_VAR 0 2
43142: PUSH
43143: LD_INT 4
43145: PLUS
43146: PUSH
43147: LD_INT 0
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: LIST
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: ST_TO_ADDR
// end ; 1 :
43162: GO 43862
43164: LD_INT 1
43166: DOUBLE
43167: EQUAL
43168: IFTRUE 43172
43170: GO 43305
43172: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43173: LD_ADDR_VAR 0 5
43177: PUSH
43178: LD_VAR 0 1
43182: PUSH
43183: LD_VAR 0 2
43187: PUSH
43188: LD_INT 4
43190: MINUS
43191: PUSH
43192: LD_INT 3
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: LIST
43199: PUSH
43200: LD_VAR 0 1
43204: PUSH
43205: LD_INT 3
43207: MINUS
43208: PUSH
43209: LD_VAR 0 2
43213: PUSH
43214: LD_INT 3
43216: MINUS
43217: PUSH
43218: LD_INT 2
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: LIST
43225: PUSH
43226: LD_VAR 0 1
43230: PUSH
43231: LD_INT 4
43233: MINUS
43234: PUSH
43235: LD_VAR 0 2
43239: PUSH
43240: LD_INT 1
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: LIST
43247: PUSH
43248: LD_VAR 0 1
43252: PUSH
43253: LD_VAR 0 2
43257: PUSH
43258: LD_INT 3
43260: PLUS
43261: PUSH
43262: LD_INT 0
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: LIST
43269: PUSH
43270: LD_VAR 0 1
43274: PUSH
43275: LD_INT 4
43277: PLUS
43278: PUSH
43279: LD_VAR 0 2
43283: PUSH
43284: LD_INT 4
43286: PLUS
43287: PUSH
43288: LD_INT 5
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: LIST
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: LIST
43300: LIST
43301: LIST
43302: ST_TO_ADDR
// end ; 2 :
43303: GO 43862
43305: LD_INT 2
43307: DOUBLE
43308: EQUAL
43309: IFTRUE 43313
43311: GO 43442
43313: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43314: LD_ADDR_VAR 0 5
43318: PUSH
43319: LD_VAR 0 1
43323: PUSH
43324: LD_VAR 0 2
43328: PUSH
43329: LD_INT 3
43331: MINUS
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: LIST
43340: PUSH
43341: LD_VAR 0 1
43345: PUSH
43346: LD_INT 4
43348: PLUS
43349: PUSH
43350: LD_VAR 0 2
43354: PUSH
43355: LD_INT 4
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: LIST
43362: PUSH
43363: LD_VAR 0 1
43367: PUSH
43368: LD_VAR 0 2
43372: PUSH
43373: LD_INT 4
43375: PLUS
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: LIST
43384: PUSH
43385: LD_VAR 0 1
43389: PUSH
43390: LD_INT 3
43392: MINUS
43393: PUSH
43394: LD_VAR 0 2
43398: PUSH
43399: LD_INT 1
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: LIST
43406: PUSH
43407: LD_VAR 0 1
43411: PUSH
43412: LD_INT 4
43414: MINUS
43415: PUSH
43416: LD_VAR 0 2
43420: PUSH
43421: LD_INT 4
43423: MINUS
43424: PUSH
43425: LD_INT 2
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: LIST
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: ST_TO_ADDR
// end ; 3 :
43440: GO 43862
43442: LD_INT 3
43444: DOUBLE
43445: EQUAL
43446: IFTRUE 43450
43448: GO 43583
43450: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43451: LD_ADDR_VAR 0 5
43455: PUSH
43456: LD_VAR 0 1
43460: PUSH
43461: LD_INT 3
43463: PLUS
43464: PUSH
43465: LD_VAR 0 2
43469: PUSH
43470: LD_INT 4
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: LIST
43477: PUSH
43478: LD_VAR 0 1
43482: PUSH
43483: LD_INT 4
43485: PLUS
43486: PUSH
43487: LD_VAR 0 2
43491: PUSH
43492: LD_INT 4
43494: PLUS
43495: PUSH
43496: LD_INT 5
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 1
43508: PUSH
43509: LD_INT 4
43511: MINUS
43512: PUSH
43513: LD_VAR 0 2
43517: PUSH
43518: LD_INT 1
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: LIST
43525: PUSH
43526: LD_VAR 0 1
43530: PUSH
43531: LD_VAR 0 2
43535: PUSH
43536: LD_INT 4
43538: MINUS
43539: PUSH
43540: LD_INT 3
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: LIST
43547: PUSH
43548: LD_VAR 0 1
43552: PUSH
43553: LD_INT 3
43555: MINUS
43556: PUSH
43557: LD_VAR 0 2
43561: PUSH
43562: LD_INT 3
43564: MINUS
43565: PUSH
43566: LD_INT 2
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: LIST
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: ST_TO_ADDR
// end ; 4 :
43581: GO 43862
43583: LD_INT 4
43585: DOUBLE
43586: EQUAL
43587: IFTRUE 43591
43589: GO 43724
43591: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
43592: LD_ADDR_VAR 0 5
43596: PUSH
43597: LD_VAR 0 1
43601: PUSH
43602: LD_VAR 0 2
43606: PUSH
43607: LD_INT 4
43609: PLUS
43610: PUSH
43611: LD_INT 0
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: LIST
43618: PUSH
43619: LD_VAR 0 1
43623: PUSH
43624: LD_INT 3
43626: PLUS
43627: PUSH
43628: LD_VAR 0 2
43632: PUSH
43633: LD_INT 3
43635: PLUS
43636: PUSH
43637: LD_INT 5
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: LIST
43644: PUSH
43645: LD_VAR 0 1
43649: PUSH
43650: LD_INT 4
43652: PLUS
43653: PUSH
43654: LD_VAR 0 2
43658: PUSH
43659: LD_INT 4
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: LIST
43666: PUSH
43667: LD_VAR 0 1
43671: PUSH
43672: LD_VAR 0 2
43676: PUSH
43677: LD_INT 3
43679: MINUS
43680: PUSH
43681: LD_INT 3
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: LIST
43688: PUSH
43689: LD_VAR 0 1
43693: PUSH
43694: LD_INT 4
43696: MINUS
43697: PUSH
43698: LD_VAR 0 2
43702: PUSH
43703: LD_INT 4
43705: MINUS
43706: PUSH
43707: LD_INT 2
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: LIST
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: ST_TO_ADDR
// end ; 5 :
43722: GO 43862
43724: LD_INT 5
43726: DOUBLE
43727: EQUAL
43728: IFTRUE 43732
43730: GO 43861
43732: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
43733: LD_ADDR_VAR 0 5
43737: PUSH
43738: LD_VAR 0 1
43742: PUSH
43743: LD_INT 4
43745: MINUS
43746: PUSH
43747: LD_VAR 0 2
43751: PUSH
43752: LD_INT 1
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: LIST
43759: PUSH
43760: LD_VAR 0 1
43764: PUSH
43765: LD_VAR 0 2
43769: PUSH
43770: LD_INT 4
43772: MINUS
43773: PUSH
43774: LD_INT 3
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: LIST
43781: PUSH
43782: LD_VAR 0 1
43786: PUSH
43787: LD_INT 4
43789: PLUS
43790: PUSH
43791: LD_VAR 0 2
43795: PUSH
43796: LD_INT 4
43798: PLUS
43799: PUSH
43800: LD_INT 5
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: LIST
43807: PUSH
43808: LD_VAR 0 1
43812: PUSH
43813: LD_INT 3
43815: PLUS
43816: PUSH
43817: LD_VAR 0 2
43821: PUSH
43822: LD_INT 4
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: LIST
43829: PUSH
43830: LD_VAR 0 1
43834: PUSH
43835: LD_VAR 0 2
43839: PUSH
43840: LD_INT 3
43842: PLUS
43843: PUSH
43844: LD_INT 0
43846: PUSH
43847: EMPTY
43848: LIST
43849: LIST
43850: LIST
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: ST_TO_ADDR
// end ; end ;
43859: GO 43862
43861: POP
// result := list ;
43862: LD_ADDR_VAR 0 4
43866: PUSH
43867: LD_VAR 0 5
43871: ST_TO_ADDR
// end ;
43872: LD_VAR 0 4
43876: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
43877: LD_INT 0
43879: PPUSH
43880: PPUSH
43881: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
43882: LD_VAR 0 1
43886: NOT
43887: PUSH
43888: LD_VAR 0 2
43892: PUSH
43893: LD_INT 1
43895: PUSH
43896: LD_INT 2
43898: PUSH
43899: LD_INT 3
43901: PUSH
43902: LD_INT 4
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: IN
43911: NOT
43912: OR
43913: IFFALSE 43917
// exit ;
43915: GO 44009
// tmp := [ ] ;
43917: LD_ADDR_VAR 0 5
43921: PUSH
43922: EMPTY
43923: ST_TO_ADDR
// for i in units do
43924: LD_ADDR_VAR 0 4
43928: PUSH
43929: LD_VAR 0 1
43933: PUSH
43934: FOR_IN
43935: IFFALSE 43978
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
43937: LD_ADDR_VAR 0 5
43941: PUSH
43942: LD_VAR 0 5
43946: PPUSH
43947: LD_VAR 0 5
43951: PUSH
43952: LD_INT 1
43954: PLUS
43955: PPUSH
43956: LD_VAR 0 4
43960: PPUSH
43961: LD_VAR 0 2
43965: PPUSH
43966: CALL_OW 259
43970: PPUSH
43971: CALL_OW 2
43975: ST_TO_ADDR
43976: GO 43934
43978: POP
43979: POP
// if not tmp then
43980: LD_VAR 0 5
43984: NOT
43985: IFFALSE 43989
// exit ;
43987: GO 44009
// result := SortListByListDesc ( units , tmp ) ;
43989: LD_ADDR_VAR 0 3
43993: PUSH
43994: LD_VAR 0 1
43998: PPUSH
43999: LD_VAR 0 5
44003: PPUSH
44004: CALL_OW 77
44008: ST_TO_ADDR
// end ;
44009: LD_VAR 0 3
44013: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44014: LD_INT 0
44016: PPUSH
44017: PPUSH
44018: PPUSH
// result := false ;
44019: LD_ADDR_VAR 0 3
44023: PUSH
44024: LD_INT 0
44026: ST_TO_ADDR
// x := GetX ( building ) ;
44027: LD_ADDR_VAR 0 4
44031: PUSH
44032: LD_VAR 0 2
44036: PPUSH
44037: CALL_OW 250
44041: ST_TO_ADDR
// y := GetY ( building ) ;
44042: LD_ADDR_VAR 0 5
44046: PUSH
44047: LD_VAR 0 2
44051: PPUSH
44052: CALL_OW 251
44056: ST_TO_ADDR
// if not building or not x or not y then
44057: LD_VAR 0 2
44061: NOT
44062: PUSH
44063: LD_VAR 0 4
44067: NOT
44068: OR
44069: PUSH
44070: LD_VAR 0 5
44074: NOT
44075: OR
44076: IFFALSE 44080
// exit ;
44078: GO 44172
// if GetTaskList ( unit ) then
44080: LD_VAR 0 1
44084: PPUSH
44085: CALL_OW 437
44089: IFFALSE 44172
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44091: LD_STRING e
44093: PUSH
44094: LD_VAR 0 1
44098: PPUSH
44099: CALL_OW 437
44103: PUSH
44104: LD_INT 1
44106: ARRAY
44107: PUSH
44108: LD_INT 1
44110: ARRAY
44111: EQUAL
44112: PUSH
44113: LD_VAR 0 4
44117: PUSH
44118: LD_VAR 0 1
44122: PPUSH
44123: CALL_OW 437
44127: PUSH
44128: LD_INT 1
44130: ARRAY
44131: PUSH
44132: LD_INT 2
44134: ARRAY
44135: EQUAL
44136: AND
44137: PUSH
44138: LD_VAR 0 5
44142: PUSH
44143: LD_VAR 0 1
44147: PPUSH
44148: CALL_OW 437
44152: PUSH
44153: LD_INT 1
44155: ARRAY
44156: PUSH
44157: LD_INT 3
44159: ARRAY
44160: EQUAL
44161: AND
44162: IFFALSE 44172
// result := true end ;
44164: LD_ADDR_VAR 0 3
44168: PUSH
44169: LD_INT 1
44171: ST_TO_ADDR
// end ;
44172: LD_VAR 0 3
44176: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44177: LD_INT 0
44179: PPUSH
// result := false ;
44180: LD_ADDR_VAR 0 4
44184: PUSH
44185: LD_INT 0
44187: ST_TO_ADDR
// if GetTaskList ( unit ) then
44188: LD_VAR 0 1
44192: PPUSH
44193: CALL_OW 437
44197: IFFALSE 44280
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44199: LD_STRING M
44201: PUSH
44202: LD_VAR 0 1
44206: PPUSH
44207: CALL_OW 437
44211: PUSH
44212: LD_INT 1
44214: ARRAY
44215: PUSH
44216: LD_INT 1
44218: ARRAY
44219: EQUAL
44220: PUSH
44221: LD_VAR 0 2
44225: PUSH
44226: LD_VAR 0 1
44230: PPUSH
44231: CALL_OW 437
44235: PUSH
44236: LD_INT 1
44238: ARRAY
44239: PUSH
44240: LD_INT 2
44242: ARRAY
44243: EQUAL
44244: AND
44245: PUSH
44246: LD_VAR 0 3
44250: PUSH
44251: LD_VAR 0 1
44255: PPUSH
44256: CALL_OW 437
44260: PUSH
44261: LD_INT 1
44263: ARRAY
44264: PUSH
44265: LD_INT 3
44267: ARRAY
44268: EQUAL
44269: AND
44270: IFFALSE 44280
// result := true ;
44272: LD_ADDR_VAR 0 4
44276: PUSH
44277: LD_INT 1
44279: ST_TO_ADDR
// end ; end ;
44280: LD_VAR 0 4
44284: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44285: LD_INT 0
44287: PPUSH
44288: PPUSH
44289: PPUSH
44290: PPUSH
// if not unit or not area then
44291: LD_VAR 0 1
44295: NOT
44296: PUSH
44297: LD_VAR 0 2
44301: NOT
44302: OR
44303: IFFALSE 44307
// exit ;
44305: GO 44471
// tmp := AreaToList ( area , i ) ;
44307: LD_ADDR_VAR 0 6
44311: PUSH
44312: LD_VAR 0 2
44316: PPUSH
44317: LD_VAR 0 5
44321: PPUSH
44322: CALL_OW 517
44326: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44327: LD_ADDR_VAR 0 5
44331: PUSH
44332: DOUBLE
44333: LD_INT 1
44335: DEC
44336: ST_TO_ADDR
44337: LD_VAR 0 6
44341: PUSH
44342: LD_INT 1
44344: ARRAY
44345: PUSH
44346: FOR_TO
44347: IFFALSE 44469
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44349: LD_ADDR_VAR 0 7
44353: PUSH
44354: LD_VAR 0 6
44358: PUSH
44359: LD_INT 1
44361: ARRAY
44362: PUSH
44363: LD_VAR 0 5
44367: ARRAY
44368: PUSH
44369: LD_VAR 0 6
44373: PUSH
44374: LD_INT 2
44376: ARRAY
44377: PUSH
44378: LD_VAR 0 5
44382: ARRAY
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44388: LD_VAR 0 7
44392: PUSH
44393: LD_INT 1
44395: ARRAY
44396: PPUSH
44397: LD_VAR 0 7
44401: PUSH
44402: LD_INT 2
44404: ARRAY
44405: PPUSH
44406: CALL_OW 428
44410: PUSH
44411: LD_INT 0
44413: EQUAL
44414: IFFALSE 44467
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44416: LD_VAR 0 1
44420: PPUSH
44421: LD_VAR 0 7
44425: PUSH
44426: LD_INT 1
44428: ARRAY
44429: PPUSH
44430: LD_VAR 0 7
44434: PUSH
44435: LD_INT 2
44437: ARRAY
44438: PPUSH
44439: LD_VAR 0 3
44443: PPUSH
44444: CALL_OW 48
// result := IsPlaced ( unit ) ;
44448: LD_ADDR_VAR 0 4
44452: PUSH
44453: LD_VAR 0 1
44457: PPUSH
44458: CALL_OW 305
44462: ST_TO_ADDR
// exit ;
44463: POP
44464: POP
44465: GO 44471
// end ; end ;
44467: GO 44346
44469: POP
44470: POP
// end ;
44471: LD_VAR 0 4
44475: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44476: LD_INT 0
44478: PPUSH
44479: PPUSH
44480: PPUSH
// if not side or side > 8 then
44481: LD_VAR 0 1
44485: NOT
44486: PUSH
44487: LD_VAR 0 1
44491: PUSH
44492: LD_INT 8
44494: GREATER
44495: OR
44496: IFFALSE 44500
// exit ;
44498: GO 44687
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44500: LD_ADDR_VAR 0 4
44504: PUSH
44505: LD_INT 22
44507: PUSH
44508: LD_VAR 0 1
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 21
44519: PUSH
44520: LD_INT 3
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PPUSH
44531: CALL_OW 69
44535: ST_TO_ADDR
// if not tmp then
44536: LD_VAR 0 4
44540: NOT
44541: IFFALSE 44545
// exit ;
44543: GO 44687
// enable_addtolog := true ;
44545: LD_ADDR_OWVAR 81
44549: PUSH
44550: LD_INT 1
44552: ST_TO_ADDR
// AddToLog ( [ ) ;
44553: LD_STRING [
44555: PPUSH
44556: CALL_OW 561
// for i in tmp do
44560: LD_ADDR_VAR 0 3
44564: PUSH
44565: LD_VAR 0 4
44569: PUSH
44570: FOR_IN
44571: IFFALSE 44678
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
44573: LD_STRING [
44575: PUSH
44576: LD_VAR 0 3
44580: PPUSH
44581: CALL_OW 266
44585: STR
44586: PUSH
44587: LD_STRING , 
44589: STR
44590: PUSH
44591: LD_VAR 0 3
44595: PPUSH
44596: CALL_OW 250
44600: STR
44601: PUSH
44602: LD_STRING , 
44604: STR
44605: PUSH
44606: LD_VAR 0 3
44610: PPUSH
44611: CALL_OW 251
44615: STR
44616: PUSH
44617: LD_STRING , 
44619: STR
44620: PUSH
44621: LD_VAR 0 3
44625: PPUSH
44626: CALL_OW 254
44630: STR
44631: PUSH
44632: LD_STRING , 
44634: STR
44635: PUSH
44636: LD_VAR 0 3
44640: PPUSH
44641: LD_INT 1
44643: PPUSH
44644: CALL_OW 268
44648: STR
44649: PUSH
44650: LD_STRING , 
44652: STR
44653: PUSH
44654: LD_VAR 0 3
44658: PPUSH
44659: LD_INT 2
44661: PPUSH
44662: CALL_OW 268
44666: STR
44667: PUSH
44668: LD_STRING ],
44670: STR
44671: PPUSH
44672: CALL_OW 561
// end ;
44676: GO 44570
44678: POP
44679: POP
// AddToLog ( ]; ) ;
44680: LD_STRING ];
44682: PPUSH
44683: CALL_OW 561
// end ;
44687: LD_VAR 0 2
44691: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
44692: LD_INT 0
44694: PPUSH
44695: PPUSH
44696: PPUSH
44697: PPUSH
44698: PPUSH
// if not area or not rate or not max then
44699: LD_VAR 0 1
44703: NOT
44704: PUSH
44705: LD_VAR 0 2
44709: NOT
44710: OR
44711: PUSH
44712: LD_VAR 0 4
44716: NOT
44717: OR
44718: IFFALSE 44722
// exit ;
44720: GO 44914
// while 1 do
44722: LD_INT 1
44724: IFFALSE 44914
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
44726: LD_ADDR_VAR 0 9
44730: PUSH
44731: LD_VAR 0 1
44735: PPUSH
44736: LD_INT 1
44738: PPUSH
44739: CALL_OW 287
44743: PUSH
44744: LD_INT 10
44746: MUL
44747: ST_TO_ADDR
// r := rate / 10 ;
44748: LD_ADDR_VAR 0 7
44752: PUSH
44753: LD_VAR 0 2
44757: PUSH
44758: LD_INT 10
44760: DIVREAL
44761: ST_TO_ADDR
// time := 1 1$00 ;
44762: LD_ADDR_VAR 0 8
44766: PUSH
44767: LD_INT 2100
44769: ST_TO_ADDR
// if amount < min then
44770: LD_VAR 0 9
44774: PUSH
44775: LD_VAR 0 3
44779: LESS
44780: IFFALSE 44798
// r := r * 2 else
44782: LD_ADDR_VAR 0 7
44786: PUSH
44787: LD_VAR 0 7
44791: PUSH
44792: LD_INT 2
44794: MUL
44795: ST_TO_ADDR
44796: GO 44824
// if amount > max then
44798: LD_VAR 0 9
44802: PUSH
44803: LD_VAR 0 4
44807: GREATER
44808: IFFALSE 44824
// r := r / 2 ;
44810: LD_ADDR_VAR 0 7
44814: PUSH
44815: LD_VAR 0 7
44819: PUSH
44820: LD_INT 2
44822: DIVREAL
44823: ST_TO_ADDR
// time := time / r ;
44824: LD_ADDR_VAR 0 8
44828: PUSH
44829: LD_VAR 0 8
44833: PUSH
44834: LD_VAR 0 7
44838: DIVREAL
44839: ST_TO_ADDR
// if time < 0 then
44840: LD_VAR 0 8
44844: PUSH
44845: LD_INT 0
44847: LESS
44848: IFFALSE 44865
// time := time * - 1 ;
44850: LD_ADDR_VAR 0 8
44854: PUSH
44855: LD_VAR 0 8
44859: PUSH
44860: LD_INT 1
44862: NEG
44863: MUL
44864: ST_TO_ADDR
// wait ( time ) ;
44865: LD_VAR 0 8
44869: PPUSH
44870: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
44874: LD_INT 35
44876: PPUSH
44877: LD_INT 875
44879: PPUSH
44880: CALL_OW 12
44884: PPUSH
44885: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
44889: LD_INT 1
44891: PPUSH
44892: LD_INT 5
44894: PPUSH
44895: CALL_OW 12
44899: PPUSH
44900: LD_VAR 0 1
44904: PPUSH
44905: LD_INT 1
44907: PPUSH
44908: CALL_OW 55
// end ;
44912: GO 44722
// end ;
44914: LD_VAR 0 5
44918: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
44919: LD_INT 0
44921: PPUSH
44922: PPUSH
44923: PPUSH
44924: PPUSH
44925: PPUSH
44926: PPUSH
44927: PPUSH
44928: PPUSH
// if not turrets or not factories then
44929: LD_VAR 0 1
44933: NOT
44934: PUSH
44935: LD_VAR 0 2
44939: NOT
44940: OR
44941: IFFALSE 44945
// exit ;
44943: GO 45252
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
44945: LD_ADDR_VAR 0 10
44949: PUSH
44950: LD_INT 5
44952: PUSH
44953: LD_INT 6
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 2
44962: PUSH
44963: LD_INT 4
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 3
44972: PUSH
44973: LD_INT 5
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 24
44987: PUSH
44988: LD_INT 25
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 23
44997: PUSH
44998: LD_INT 27
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_INT 42
45011: PUSH
45012: LD_INT 43
45014: PUSH
45015: EMPTY
45016: LIST
45017: LIST
45018: PUSH
45019: LD_INT 44
45021: PUSH
45022: LD_INT 46
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 45
45031: PUSH
45032: LD_INT 47
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: LIST
45043: PUSH
45044: EMPTY
45045: LIST
45046: LIST
45047: LIST
45048: ST_TO_ADDR
// result := [ ] ;
45049: LD_ADDR_VAR 0 3
45053: PUSH
45054: EMPTY
45055: ST_TO_ADDR
// for i in turrets do
45056: LD_ADDR_VAR 0 4
45060: PUSH
45061: LD_VAR 0 1
45065: PUSH
45066: FOR_IN
45067: IFFALSE 45250
// begin nat := GetNation ( i ) ;
45069: LD_ADDR_VAR 0 7
45073: PUSH
45074: LD_VAR 0 4
45078: PPUSH
45079: CALL_OW 248
45083: ST_TO_ADDR
// weapon := 0 ;
45084: LD_ADDR_VAR 0 8
45088: PUSH
45089: LD_INT 0
45091: ST_TO_ADDR
// if not nat then
45092: LD_VAR 0 7
45096: NOT
45097: IFFALSE 45101
// continue ;
45099: GO 45066
// for j in list [ nat ] do
45101: LD_ADDR_VAR 0 5
45105: PUSH
45106: LD_VAR 0 10
45110: PUSH
45111: LD_VAR 0 7
45115: ARRAY
45116: PUSH
45117: FOR_IN
45118: IFFALSE 45159
// if GetBWeapon ( i ) = j [ 1 ] then
45120: LD_VAR 0 4
45124: PPUSH
45125: CALL_OW 269
45129: PUSH
45130: LD_VAR 0 5
45134: PUSH
45135: LD_INT 1
45137: ARRAY
45138: EQUAL
45139: IFFALSE 45157
// begin weapon := j [ 2 ] ;
45141: LD_ADDR_VAR 0 8
45145: PUSH
45146: LD_VAR 0 5
45150: PUSH
45151: LD_INT 2
45153: ARRAY
45154: ST_TO_ADDR
// break ;
45155: GO 45159
// end ;
45157: GO 45117
45159: POP
45160: POP
// if not weapon then
45161: LD_VAR 0 8
45165: NOT
45166: IFFALSE 45170
// continue ;
45168: GO 45066
// for k in factories do
45170: LD_ADDR_VAR 0 6
45174: PUSH
45175: LD_VAR 0 2
45179: PUSH
45180: FOR_IN
45181: IFFALSE 45246
// begin weapons := AvailableWeaponList ( k ) ;
45183: LD_ADDR_VAR 0 9
45187: PUSH
45188: LD_VAR 0 6
45192: PPUSH
45193: CALL_OW 478
45197: ST_TO_ADDR
// if not weapons then
45198: LD_VAR 0 9
45202: NOT
45203: IFFALSE 45207
// continue ;
45205: GO 45180
// if weapon in weapons then
45207: LD_VAR 0 8
45211: PUSH
45212: LD_VAR 0 9
45216: IN
45217: IFFALSE 45244
// begin result := [ i , weapon ] ;
45219: LD_ADDR_VAR 0 3
45223: PUSH
45224: LD_VAR 0 4
45228: PUSH
45229: LD_VAR 0 8
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: ST_TO_ADDR
// exit ;
45238: POP
45239: POP
45240: POP
45241: POP
45242: GO 45252
// end ; end ;
45244: GO 45180
45246: POP
45247: POP
// end ;
45248: GO 45066
45250: POP
45251: POP
// end ;
45252: LD_VAR 0 3
45256: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45257: LD_INT 0
45259: PPUSH
// if not side or side > 8 then
45260: LD_VAR 0 3
45264: NOT
45265: PUSH
45266: LD_VAR 0 3
45270: PUSH
45271: LD_INT 8
45273: GREATER
45274: OR
45275: IFFALSE 45279
// exit ;
45277: GO 45338
// if not range then
45279: LD_VAR 0 4
45283: NOT
45284: IFFALSE 45295
// range := - 12 ;
45286: LD_ADDR_VAR 0 4
45290: PUSH
45291: LD_INT 12
45293: NEG
45294: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45295: LD_VAR 0 1
45299: PPUSH
45300: LD_VAR 0 2
45304: PPUSH
45305: LD_VAR 0 3
45309: PPUSH
45310: LD_VAR 0 4
45314: PPUSH
45315: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45319: LD_VAR 0 1
45323: PPUSH
45324: LD_VAR 0 2
45328: PPUSH
45329: LD_VAR 0 3
45333: PPUSH
45334: CALL_OW 331
// end ;
45338: LD_VAR 0 5
45342: RET
// export function Video ( mode ) ; begin
45343: LD_INT 0
45345: PPUSH
// ingame_video = mode ;
45346: LD_ADDR_OWVAR 52
45350: PUSH
45351: LD_VAR 0 1
45355: ST_TO_ADDR
// interface_hidden = mode ;
45356: LD_ADDR_OWVAR 54
45360: PUSH
45361: LD_VAR 0 1
45365: ST_TO_ADDR
// end ;
45366: LD_VAR 0 2
45370: RET
// export function Join ( array , element ) ; begin
45371: LD_INT 0
45373: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45374: LD_ADDR_VAR 0 3
45378: PUSH
45379: LD_VAR 0 1
45383: PPUSH
45384: LD_VAR 0 1
45388: PUSH
45389: LD_INT 1
45391: PLUS
45392: PPUSH
45393: LD_VAR 0 2
45397: PPUSH
45398: CALL_OW 1
45402: ST_TO_ADDR
// end ;
45403: LD_VAR 0 3
45407: RET
// export function JoinUnion ( array , element ) ; begin
45408: LD_INT 0
45410: PPUSH
// result := array union element ;
45411: LD_ADDR_VAR 0 3
45415: PUSH
45416: LD_VAR 0 1
45420: PUSH
45421: LD_VAR 0 2
45425: UNION
45426: ST_TO_ADDR
// end ;
45427: LD_VAR 0 3
45431: RET
// export function GetBehemoths ( side ) ; begin
45432: LD_INT 0
45434: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45435: LD_ADDR_VAR 0 2
45439: PUSH
45440: LD_INT 22
45442: PUSH
45443: LD_VAR 0 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 31
45454: PUSH
45455: LD_INT 25
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PPUSH
45466: CALL_OW 69
45470: ST_TO_ADDR
// end ;
45471: LD_VAR 0 2
45475: RET
// export function Shuffle ( array ) ; var i , index ; begin
45476: LD_INT 0
45478: PPUSH
45479: PPUSH
45480: PPUSH
// result := [ ] ;
45481: LD_ADDR_VAR 0 2
45485: PUSH
45486: EMPTY
45487: ST_TO_ADDR
// if not array then
45488: LD_VAR 0 1
45492: NOT
45493: IFFALSE 45497
// exit ;
45495: GO 45596
// Randomize ;
45497: CALL_OW 10
// for i = array downto 1 do
45501: LD_ADDR_VAR 0 3
45505: PUSH
45506: DOUBLE
45507: LD_VAR 0 1
45511: INC
45512: ST_TO_ADDR
45513: LD_INT 1
45515: PUSH
45516: FOR_DOWNTO
45517: IFFALSE 45594
// begin index := rand ( 1 , array ) ;
45519: LD_ADDR_VAR 0 4
45523: PUSH
45524: LD_INT 1
45526: PPUSH
45527: LD_VAR 0 1
45531: PPUSH
45532: CALL_OW 12
45536: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
45537: LD_ADDR_VAR 0 2
45541: PUSH
45542: LD_VAR 0 2
45546: PPUSH
45547: LD_VAR 0 2
45551: PUSH
45552: LD_INT 1
45554: PLUS
45555: PPUSH
45556: LD_VAR 0 1
45560: PUSH
45561: LD_VAR 0 4
45565: ARRAY
45566: PPUSH
45567: CALL_OW 2
45571: ST_TO_ADDR
// array := Delete ( array , index ) ;
45572: LD_ADDR_VAR 0 1
45576: PUSH
45577: LD_VAR 0 1
45581: PPUSH
45582: LD_VAR 0 4
45586: PPUSH
45587: CALL_OW 3
45591: ST_TO_ADDR
// end ;
45592: GO 45516
45594: POP
45595: POP
// end ;
45596: LD_VAR 0 2
45600: RET
// export function GetBaseMaterials ( base ) ; begin
45601: LD_INT 0
45603: PPUSH
// result := [ 0 , 0 , 0 ] ;
45604: LD_ADDR_VAR 0 2
45608: PUSH
45609: LD_INT 0
45611: PUSH
45612: LD_INT 0
45614: PUSH
45615: LD_INT 0
45617: PUSH
45618: EMPTY
45619: LIST
45620: LIST
45621: LIST
45622: ST_TO_ADDR
// if not base then
45623: LD_VAR 0 1
45627: NOT
45628: IFFALSE 45632
// exit ;
45630: GO 45681
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
45632: LD_ADDR_VAR 0 2
45636: PUSH
45637: LD_VAR 0 1
45641: PPUSH
45642: LD_INT 1
45644: PPUSH
45645: CALL_OW 275
45649: PUSH
45650: LD_VAR 0 1
45654: PPUSH
45655: LD_INT 2
45657: PPUSH
45658: CALL_OW 275
45662: PUSH
45663: LD_VAR 0 1
45667: PPUSH
45668: LD_INT 3
45670: PPUSH
45671: CALL_OW 275
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: LIST
45680: ST_TO_ADDR
// end ;
45681: LD_VAR 0 2
45685: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
45686: LD_INT 0
45688: PPUSH
45689: PPUSH
// result := array ;
45690: LD_ADDR_VAR 0 3
45694: PUSH
45695: LD_VAR 0 1
45699: ST_TO_ADDR
// if size > 0 then
45700: LD_VAR 0 2
45704: PUSH
45705: LD_INT 0
45707: GREATER
45708: IFFALSE 45754
// for i := array downto size do
45710: LD_ADDR_VAR 0 4
45714: PUSH
45715: DOUBLE
45716: LD_VAR 0 1
45720: INC
45721: ST_TO_ADDR
45722: LD_VAR 0 2
45726: PUSH
45727: FOR_DOWNTO
45728: IFFALSE 45752
// result := Delete ( result , result ) ;
45730: LD_ADDR_VAR 0 3
45734: PUSH
45735: LD_VAR 0 3
45739: PPUSH
45740: LD_VAR 0 3
45744: PPUSH
45745: CALL_OW 3
45749: ST_TO_ADDR
45750: GO 45727
45752: POP
45753: POP
// end ;
45754: LD_VAR 0 3
45758: RET
// export function ComExit ( unit ) ; var tmp ; begin
45759: LD_INT 0
45761: PPUSH
45762: PPUSH
// if not IsInUnit ( unit ) then
45763: LD_VAR 0 1
45767: PPUSH
45768: CALL_OW 310
45772: NOT
45773: IFFALSE 45777
// exit ;
45775: GO 45837
// tmp := IsInUnit ( unit ) ;
45777: LD_ADDR_VAR 0 3
45781: PUSH
45782: LD_VAR 0 1
45786: PPUSH
45787: CALL_OW 310
45791: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
45792: LD_VAR 0 3
45796: PPUSH
45797: CALL_OW 247
45801: PUSH
45802: LD_INT 2
45804: EQUAL
45805: IFFALSE 45818
// ComExitVehicle ( unit ) else
45807: LD_VAR 0 1
45811: PPUSH
45812: CALL_OW 121
45816: GO 45827
// ComExitBuilding ( unit ) ;
45818: LD_VAR 0 1
45822: PPUSH
45823: CALL_OW 122
// result := tmp ;
45827: LD_ADDR_VAR 0 2
45831: PUSH
45832: LD_VAR 0 3
45836: ST_TO_ADDR
// end ;
45837: LD_VAR 0 2
45841: RET
// export function ComExitAll ( units ) ; var i ; begin
45842: LD_INT 0
45844: PPUSH
45845: PPUSH
// if not units then
45846: LD_VAR 0 1
45850: NOT
45851: IFFALSE 45855
// exit ;
45853: GO 45881
// for i in units do
45855: LD_ADDR_VAR 0 3
45859: PUSH
45860: LD_VAR 0 1
45864: PUSH
45865: FOR_IN
45866: IFFALSE 45879
// ComExit ( i ) ;
45868: LD_VAR 0 3
45872: PPUSH
45873: CALL 45759 0 1
45877: GO 45865
45879: POP
45880: POP
// end ;
45881: LD_VAR 0 2
45885: RET
// export function ResetHc ; begin
45886: LD_INT 0
45888: PPUSH
// InitHc ;
45889: CALL_OW 19
// hc_importance := 0 ;
45893: LD_ADDR_OWVAR 32
45897: PUSH
45898: LD_INT 0
45900: ST_TO_ADDR
// end ;
45901: LD_VAR 0 1
45905: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
45906: LD_INT 0
45908: PPUSH
45909: PPUSH
45910: PPUSH
// _x := ( x1 + x2 ) div 2 ;
45911: LD_ADDR_VAR 0 6
45915: PUSH
45916: LD_VAR 0 1
45920: PUSH
45921: LD_VAR 0 3
45925: PLUS
45926: PUSH
45927: LD_INT 2
45929: DIV
45930: ST_TO_ADDR
// if _x < 0 then
45931: LD_VAR 0 6
45935: PUSH
45936: LD_INT 0
45938: LESS
45939: IFFALSE 45956
// _x := _x * - 1 ;
45941: LD_ADDR_VAR 0 6
45945: PUSH
45946: LD_VAR 0 6
45950: PUSH
45951: LD_INT 1
45953: NEG
45954: MUL
45955: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
45956: LD_ADDR_VAR 0 7
45960: PUSH
45961: LD_VAR 0 2
45965: PUSH
45966: LD_VAR 0 4
45970: PLUS
45971: PUSH
45972: LD_INT 2
45974: DIV
45975: ST_TO_ADDR
// if _y < 0 then
45976: LD_VAR 0 7
45980: PUSH
45981: LD_INT 0
45983: LESS
45984: IFFALSE 46001
// _y := _y * - 1 ;
45986: LD_ADDR_VAR 0 7
45990: PUSH
45991: LD_VAR 0 7
45995: PUSH
45996: LD_INT 1
45998: NEG
45999: MUL
46000: ST_TO_ADDR
// result := [ _x , _y ] ;
46001: LD_ADDR_VAR 0 5
46005: PUSH
46006: LD_VAR 0 6
46010: PUSH
46011: LD_VAR 0 7
46015: PUSH
46016: EMPTY
46017: LIST
46018: LIST
46019: ST_TO_ADDR
// end ;
46020: LD_VAR 0 5
46024: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46025: LD_INT 0
46027: PPUSH
46028: PPUSH
46029: PPUSH
46030: PPUSH
// task := GetTaskList ( unit ) ;
46031: LD_ADDR_VAR 0 7
46035: PUSH
46036: LD_VAR 0 1
46040: PPUSH
46041: CALL_OW 437
46045: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46046: LD_VAR 0 7
46050: NOT
46051: PUSH
46052: LD_VAR 0 1
46056: PPUSH
46057: LD_VAR 0 2
46061: PPUSH
46062: CALL_OW 308
46066: NOT
46067: AND
46068: IFFALSE 46072
// exit ;
46070: GO 46190
// if IsInArea ( unit , area ) then
46072: LD_VAR 0 1
46076: PPUSH
46077: LD_VAR 0 2
46081: PPUSH
46082: CALL_OW 308
46086: IFFALSE 46104
// begin ComMoveToArea ( unit , goAway ) ;
46088: LD_VAR 0 1
46092: PPUSH
46093: LD_VAR 0 3
46097: PPUSH
46098: CALL_OW 113
// exit ;
46102: GO 46190
// end ; if task [ 1 ] [ 1 ] <> M then
46104: LD_VAR 0 7
46108: PUSH
46109: LD_INT 1
46111: ARRAY
46112: PUSH
46113: LD_INT 1
46115: ARRAY
46116: PUSH
46117: LD_STRING M
46119: NONEQUAL
46120: IFFALSE 46124
// exit ;
46122: GO 46190
// x := task [ 1 ] [ 2 ] ;
46124: LD_ADDR_VAR 0 5
46128: PUSH
46129: LD_VAR 0 7
46133: PUSH
46134: LD_INT 1
46136: ARRAY
46137: PUSH
46138: LD_INT 2
46140: ARRAY
46141: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46142: LD_ADDR_VAR 0 6
46146: PUSH
46147: LD_VAR 0 7
46151: PUSH
46152: LD_INT 1
46154: ARRAY
46155: PUSH
46156: LD_INT 3
46158: ARRAY
46159: ST_TO_ADDR
// if InArea ( x , y , area ) then
46160: LD_VAR 0 5
46164: PPUSH
46165: LD_VAR 0 6
46169: PPUSH
46170: LD_VAR 0 2
46174: PPUSH
46175: CALL_OW 309
46179: IFFALSE 46190
// ComStop ( unit ) ;
46181: LD_VAR 0 1
46185: PPUSH
46186: CALL_OW 141
// end ;
46190: LD_VAR 0 4
46194: RET
// export function Abs ( value ) ; begin
46195: LD_INT 0
46197: PPUSH
// result := value ;
46198: LD_ADDR_VAR 0 2
46202: PUSH
46203: LD_VAR 0 1
46207: ST_TO_ADDR
// if value < 0 then
46208: LD_VAR 0 1
46212: PUSH
46213: LD_INT 0
46215: LESS
46216: IFFALSE 46233
// result := value * - 1 ;
46218: LD_ADDR_VAR 0 2
46222: PUSH
46223: LD_VAR 0 1
46227: PUSH
46228: LD_INT 1
46230: NEG
46231: MUL
46232: ST_TO_ADDR
// end ;
46233: LD_VAR 0 2
46237: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46238: LD_INT 0
46240: PPUSH
46241: PPUSH
46242: PPUSH
46243: PPUSH
46244: PPUSH
46245: PPUSH
46246: PPUSH
46247: PPUSH
// if not unit or not building then
46248: LD_VAR 0 1
46252: NOT
46253: PUSH
46254: LD_VAR 0 2
46258: NOT
46259: OR
46260: IFFALSE 46264
// exit ;
46262: GO 46490
// x := GetX ( building ) ;
46264: LD_ADDR_VAR 0 4
46268: PUSH
46269: LD_VAR 0 2
46273: PPUSH
46274: CALL_OW 250
46278: ST_TO_ADDR
// y := GetY ( building ) ;
46279: LD_ADDR_VAR 0 6
46283: PUSH
46284: LD_VAR 0 2
46288: PPUSH
46289: CALL_OW 251
46293: ST_TO_ADDR
// d := GetDir ( building ) ;
46294: LD_ADDR_VAR 0 8
46298: PUSH
46299: LD_VAR 0 2
46303: PPUSH
46304: CALL_OW 254
46308: ST_TO_ADDR
// r := 4 ;
46309: LD_ADDR_VAR 0 9
46313: PUSH
46314: LD_INT 4
46316: ST_TO_ADDR
// for i := 1 to 5 do
46317: LD_ADDR_VAR 0 10
46321: PUSH
46322: DOUBLE
46323: LD_INT 1
46325: DEC
46326: ST_TO_ADDR
46327: LD_INT 5
46329: PUSH
46330: FOR_TO
46331: IFFALSE 46488
// begin _x := ShiftX ( x , d , r + i ) ;
46333: LD_ADDR_VAR 0 5
46337: PUSH
46338: LD_VAR 0 4
46342: PPUSH
46343: LD_VAR 0 8
46347: PPUSH
46348: LD_VAR 0 9
46352: PUSH
46353: LD_VAR 0 10
46357: PLUS
46358: PPUSH
46359: CALL_OW 272
46363: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46364: LD_ADDR_VAR 0 7
46368: PUSH
46369: LD_VAR 0 6
46373: PPUSH
46374: LD_VAR 0 8
46378: PPUSH
46379: LD_VAR 0 9
46383: PUSH
46384: LD_VAR 0 10
46388: PLUS
46389: PPUSH
46390: CALL_OW 273
46394: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46395: LD_VAR 0 5
46399: PPUSH
46400: LD_VAR 0 7
46404: PPUSH
46405: CALL_OW 488
46409: PUSH
46410: LD_VAR 0 5
46414: PPUSH
46415: LD_VAR 0 7
46419: PPUSH
46420: CALL_OW 428
46424: PPUSH
46425: CALL_OW 247
46429: PUSH
46430: LD_INT 3
46432: PUSH
46433: LD_INT 2
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: IN
46440: NOT
46441: AND
46442: IFFALSE 46486
// begin ComMoveXY ( unit , _x , _y ) ;
46444: LD_VAR 0 1
46448: PPUSH
46449: LD_VAR 0 5
46453: PPUSH
46454: LD_VAR 0 7
46458: PPUSH
46459: CALL_OW 111
// result := [ _x , _y ] ;
46463: LD_ADDR_VAR 0 3
46467: PUSH
46468: LD_VAR 0 5
46472: PUSH
46473: LD_VAR 0 7
46477: PUSH
46478: EMPTY
46479: LIST
46480: LIST
46481: ST_TO_ADDR
// exit ;
46482: POP
46483: POP
46484: GO 46490
// end ; end ;
46486: GO 46330
46488: POP
46489: POP
// end ;
46490: LD_VAR 0 3
46494: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46495: LD_INT 0
46497: PPUSH
46498: PPUSH
46499: PPUSH
// result := 0 ;
46500: LD_ADDR_VAR 0 3
46504: PUSH
46505: LD_INT 0
46507: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46508: LD_VAR 0 1
46512: PUSH
46513: LD_INT 0
46515: LESS
46516: PUSH
46517: LD_VAR 0 1
46521: PUSH
46522: LD_INT 8
46524: GREATER
46525: OR
46526: PUSH
46527: LD_VAR 0 2
46531: PUSH
46532: LD_INT 0
46534: LESS
46535: OR
46536: PUSH
46537: LD_VAR 0 2
46541: PUSH
46542: LD_INT 8
46544: GREATER
46545: OR
46546: IFFALSE 46550
// exit ;
46548: GO 46625
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46550: LD_ADDR_VAR 0 4
46554: PUSH
46555: LD_INT 22
46557: PUSH
46558: LD_VAR 0 2
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: PPUSH
46567: CALL_OW 69
46571: PUSH
46572: FOR_IN
46573: IFFALSE 46623
// begin un := UnitShoot ( i ) ;
46575: LD_ADDR_VAR 0 5
46579: PUSH
46580: LD_VAR 0 4
46584: PPUSH
46585: CALL_OW 504
46589: ST_TO_ADDR
// if GetSide ( un ) = side1 then
46590: LD_VAR 0 5
46594: PPUSH
46595: CALL_OW 255
46599: PUSH
46600: LD_VAR 0 1
46604: EQUAL
46605: IFFALSE 46621
// begin result := un ;
46607: LD_ADDR_VAR 0 3
46611: PUSH
46612: LD_VAR 0 5
46616: ST_TO_ADDR
// exit ;
46617: POP
46618: POP
46619: GO 46625
// end ; end ;
46621: GO 46572
46623: POP
46624: POP
// end ;
46625: LD_VAR 0 3
46629: RET
// export function GetCargoBay ( units ) ; begin
46630: LD_INT 0
46632: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
46633: LD_ADDR_VAR 0 2
46637: PUSH
46638: LD_VAR 0 1
46642: PPUSH
46643: LD_INT 2
46645: PUSH
46646: LD_INT 34
46648: PUSH
46649: LD_INT 12
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_INT 34
46658: PUSH
46659: LD_INT 51
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: PUSH
46666: LD_INT 34
46668: PUSH
46669: LD_INT 32
46671: PUSH
46672: EMPTY
46673: LIST
46674: LIST
46675: PUSH
46676: LD_INT 34
46678: PUSH
46679: LD_EXP 68
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: PPUSH
46695: CALL_OW 72
46699: ST_TO_ADDR
// end ;
46700: LD_VAR 0 2
46704: RET
// export function Negate ( value ) ; begin
46705: LD_INT 0
46707: PPUSH
// result := not value ;
46708: LD_ADDR_VAR 0 2
46712: PUSH
46713: LD_VAR 0 1
46717: NOT
46718: ST_TO_ADDR
// end ;
46719: LD_VAR 0 2
46723: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
46724: LD_INT 0
46726: PPUSH
// if x1 = x2 then
46727: LD_VAR 0 1
46731: PUSH
46732: LD_VAR 0 3
46736: EQUAL
46737: IFFALSE 46771
// begin if y1 > y2 then
46739: LD_VAR 0 2
46743: PUSH
46744: LD_VAR 0 4
46748: GREATER
46749: IFFALSE 46761
// result := 0 else
46751: LD_ADDR_VAR 0 5
46755: PUSH
46756: LD_INT 0
46758: ST_TO_ADDR
46759: GO 46769
// result := 3 ;
46761: LD_ADDR_VAR 0 5
46765: PUSH
46766: LD_INT 3
46768: ST_TO_ADDR
// exit ;
46769: GO 46857
// end ; if y1 = y2 then
46771: LD_VAR 0 2
46775: PUSH
46776: LD_VAR 0 4
46780: EQUAL
46781: IFFALSE 46815
// begin if x1 > x2 then
46783: LD_VAR 0 1
46787: PUSH
46788: LD_VAR 0 3
46792: GREATER
46793: IFFALSE 46805
// result := 1 else
46795: LD_ADDR_VAR 0 5
46799: PUSH
46800: LD_INT 1
46802: ST_TO_ADDR
46803: GO 46813
// result := 4 ;
46805: LD_ADDR_VAR 0 5
46809: PUSH
46810: LD_INT 4
46812: ST_TO_ADDR
// exit ;
46813: GO 46857
// end ; if x1 > x2 and y1 > y2 then
46815: LD_VAR 0 1
46819: PUSH
46820: LD_VAR 0 3
46824: GREATER
46825: PUSH
46826: LD_VAR 0 2
46830: PUSH
46831: LD_VAR 0 4
46835: GREATER
46836: AND
46837: IFFALSE 46849
// result := 2 else
46839: LD_ADDR_VAR 0 5
46843: PUSH
46844: LD_INT 2
46846: ST_TO_ADDR
46847: GO 46857
// result := 5 ;
46849: LD_ADDR_VAR 0 5
46853: PUSH
46854: LD_INT 5
46856: ST_TO_ADDR
// end ;
46857: LD_VAR 0 5
46861: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
46862: LD_INT 0
46864: PPUSH
46865: PPUSH
// if not driver or not IsInUnit ( driver ) then
46866: LD_VAR 0 1
46870: NOT
46871: PUSH
46872: LD_VAR 0 1
46876: PPUSH
46877: CALL_OW 310
46881: NOT
46882: OR
46883: IFFALSE 46887
// exit ;
46885: GO 46977
// vehicle := IsInUnit ( driver ) ;
46887: LD_ADDR_VAR 0 3
46891: PUSH
46892: LD_VAR 0 1
46896: PPUSH
46897: CALL_OW 310
46901: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
46902: LD_VAR 0 1
46906: PPUSH
46907: LD_STRING \
46909: PUSH
46910: LD_INT 0
46912: PUSH
46913: LD_INT 0
46915: PUSH
46916: LD_INT 0
46918: PUSH
46919: LD_INT 0
46921: PUSH
46922: LD_INT 0
46924: PUSH
46925: LD_INT 0
46927: PUSH
46928: EMPTY
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: PUSH
46937: LD_STRING E
46939: PUSH
46940: LD_INT 0
46942: PUSH
46943: LD_INT 0
46945: PUSH
46946: LD_VAR 0 3
46950: PUSH
46951: LD_INT 0
46953: PUSH
46954: LD_INT 0
46956: PUSH
46957: LD_INT 0
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: PPUSH
46973: CALL_OW 446
// end ;
46977: LD_VAR 0 2
46981: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
46982: LD_INT 0
46984: PPUSH
46985: PPUSH
46986: PPUSH
// tmp := [ ] ;
46987: LD_ADDR_VAR 0 5
46991: PUSH
46992: EMPTY
46993: ST_TO_ADDR
// for i in units do
46994: LD_ADDR_VAR 0 4
46998: PUSH
46999: LD_VAR 0 1
47003: PUSH
47004: FOR_IN
47005: IFFALSE 47043
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
47007: LD_ADDR_VAR 0 5
47011: PUSH
47012: LD_VAR 0 5
47016: PPUSH
47017: LD_VAR 0 5
47021: PUSH
47022: LD_INT 1
47024: PLUS
47025: PPUSH
47026: LD_VAR 0 4
47030: PPUSH
47031: CALL_OW 256
47035: PPUSH
47036: CALL_OW 2
47040: ST_TO_ADDR
47041: GO 47004
47043: POP
47044: POP
// if not tmp then
47045: LD_VAR 0 5
47049: NOT
47050: IFFALSE 47054
// exit ;
47052: GO 47102
// if asc then
47054: LD_VAR 0 2
47058: IFFALSE 47082
// result := SortListByListAsc ( units , tmp ) else
47060: LD_ADDR_VAR 0 3
47064: PUSH
47065: LD_VAR 0 1
47069: PPUSH
47070: LD_VAR 0 5
47074: PPUSH
47075: CALL_OW 76
47079: ST_TO_ADDR
47080: GO 47102
// result := SortListByListDesc ( units , tmp ) ;
47082: LD_ADDR_VAR 0 3
47086: PUSH
47087: LD_VAR 0 1
47091: PPUSH
47092: LD_VAR 0 5
47096: PPUSH
47097: CALL_OW 77
47101: ST_TO_ADDR
// end ; end_of_file
47102: LD_VAR 0 3
47106: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
47107: LD_INT 0
47109: PPUSH
47110: PPUSH
// skirmish := false ;
47111: LD_ADDR_EXP 21
47115: PUSH
47116: LD_INT 0
47118: ST_TO_ADDR
// debug_mc := false ;
47119: LD_ADDR_EXP 22
47123: PUSH
47124: LD_INT 0
47126: ST_TO_ADDR
// mc_bases := [ ] ;
47127: LD_ADDR_EXP 23
47131: PUSH
47132: EMPTY
47133: ST_TO_ADDR
// mc_sides := [ ] ;
47134: LD_ADDR_EXP 49
47138: PUSH
47139: EMPTY
47140: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47141: LD_ADDR_EXP 24
47145: PUSH
47146: EMPTY
47147: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47148: LD_ADDR_EXP 25
47152: PUSH
47153: EMPTY
47154: ST_TO_ADDR
// mc_need_heal := [ ] ;
47155: LD_ADDR_EXP 26
47159: PUSH
47160: EMPTY
47161: ST_TO_ADDR
// mc_healers := [ ] ;
47162: LD_ADDR_EXP 27
47166: PUSH
47167: EMPTY
47168: ST_TO_ADDR
// mc_build_list := [ ] ;
47169: LD_ADDR_EXP 28
47173: PUSH
47174: EMPTY
47175: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47176: LD_ADDR_EXP 55
47180: PUSH
47181: EMPTY
47182: ST_TO_ADDR
// mc_builders := [ ] ;
47183: LD_ADDR_EXP 29
47187: PUSH
47188: EMPTY
47189: ST_TO_ADDR
// mc_construct_list := [ ] ;
47190: LD_ADDR_EXP 30
47194: PUSH
47195: EMPTY
47196: ST_TO_ADDR
// mc_turret_list := [ ] ;
47197: LD_ADDR_EXP 31
47201: PUSH
47202: EMPTY
47203: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47204: LD_ADDR_EXP 32
47208: PUSH
47209: EMPTY
47210: ST_TO_ADDR
// mc_miners := [ ] ;
47211: LD_ADDR_EXP 37
47215: PUSH
47216: EMPTY
47217: ST_TO_ADDR
// mc_mines := [ ] ;
47218: LD_ADDR_EXP 36
47222: PUSH
47223: EMPTY
47224: ST_TO_ADDR
// mc_minefields := [ ] ;
47225: LD_ADDR_EXP 38
47229: PUSH
47230: EMPTY
47231: ST_TO_ADDR
// mc_crates := [ ] ;
47232: LD_ADDR_EXP 39
47236: PUSH
47237: EMPTY
47238: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47239: LD_ADDR_EXP 40
47243: PUSH
47244: EMPTY
47245: ST_TO_ADDR
// mc_crates_area := [ ] ;
47246: LD_ADDR_EXP 41
47250: PUSH
47251: EMPTY
47252: ST_TO_ADDR
// mc_vehicles := [ ] ;
47253: LD_ADDR_EXP 42
47257: PUSH
47258: EMPTY
47259: ST_TO_ADDR
// mc_attack := [ ] ;
47260: LD_ADDR_EXP 43
47264: PUSH
47265: EMPTY
47266: ST_TO_ADDR
// mc_produce := [ ] ;
47267: LD_ADDR_EXP 44
47271: PUSH
47272: EMPTY
47273: ST_TO_ADDR
// mc_defender := [ ] ;
47274: LD_ADDR_EXP 45
47278: PUSH
47279: EMPTY
47280: ST_TO_ADDR
// mc_parking := [ ] ;
47281: LD_ADDR_EXP 47
47285: PUSH
47286: EMPTY
47287: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47288: LD_ADDR_EXP 33
47292: PUSH
47293: EMPTY
47294: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47295: LD_ADDR_EXP 35
47299: PUSH
47300: EMPTY
47301: ST_TO_ADDR
// mc_scan := [ ] ;
47302: LD_ADDR_EXP 46
47306: PUSH
47307: EMPTY
47308: ST_TO_ADDR
// mc_scan_area := [ ] ;
47309: LD_ADDR_EXP 48
47313: PUSH
47314: EMPTY
47315: ST_TO_ADDR
// mc_tech := [ ] ;
47316: LD_ADDR_EXP 50
47320: PUSH
47321: EMPTY
47322: ST_TO_ADDR
// mc_class := [ ] ;
47323: LD_ADDR_EXP 64
47327: PUSH
47328: EMPTY
47329: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47330: LD_ADDR_EXP 65
47334: PUSH
47335: EMPTY
47336: ST_TO_ADDR
// mc_is_defending := [ ] ;
47337: LD_ADDR_EXP 66
47341: PUSH
47342: EMPTY
47343: ST_TO_ADDR
// end ;
47344: LD_VAR 0 1
47348: RET
// export function MC_Kill ( base ) ; begin
47349: LD_INT 0
47351: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47352: LD_ADDR_EXP 23
47356: PUSH
47357: LD_EXP 23
47361: PPUSH
47362: LD_VAR 0 1
47366: PPUSH
47367: EMPTY
47368: PPUSH
47369: CALL_OW 1
47373: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47374: LD_ADDR_EXP 24
47378: PUSH
47379: LD_EXP 24
47383: PPUSH
47384: LD_VAR 0 1
47388: PPUSH
47389: EMPTY
47390: PPUSH
47391: CALL_OW 1
47395: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47396: LD_ADDR_EXP 25
47400: PUSH
47401: LD_EXP 25
47405: PPUSH
47406: LD_VAR 0 1
47410: PPUSH
47411: EMPTY
47412: PPUSH
47413: CALL_OW 1
47417: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47418: LD_ADDR_EXP 26
47422: PUSH
47423: LD_EXP 26
47427: PPUSH
47428: LD_VAR 0 1
47432: PPUSH
47433: EMPTY
47434: PPUSH
47435: CALL_OW 1
47439: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47440: LD_ADDR_EXP 27
47444: PUSH
47445: LD_EXP 27
47449: PPUSH
47450: LD_VAR 0 1
47454: PPUSH
47455: EMPTY
47456: PPUSH
47457: CALL_OW 1
47461: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47462: LD_ADDR_EXP 28
47466: PUSH
47467: LD_EXP 28
47471: PPUSH
47472: LD_VAR 0 1
47476: PPUSH
47477: EMPTY
47478: PPUSH
47479: CALL_OW 1
47483: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
47484: LD_ADDR_EXP 29
47488: PUSH
47489: LD_EXP 29
47493: PPUSH
47494: LD_VAR 0 1
47498: PPUSH
47499: EMPTY
47500: PPUSH
47501: CALL_OW 1
47505: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
47506: LD_ADDR_EXP 30
47510: PUSH
47511: LD_EXP 30
47515: PPUSH
47516: LD_VAR 0 1
47520: PPUSH
47521: EMPTY
47522: PPUSH
47523: CALL_OW 1
47527: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
47528: LD_ADDR_EXP 31
47532: PUSH
47533: LD_EXP 31
47537: PPUSH
47538: LD_VAR 0 1
47542: PPUSH
47543: EMPTY
47544: PPUSH
47545: CALL_OW 1
47549: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
47550: LD_ADDR_EXP 32
47554: PUSH
47555: LD_EXP 32
47559: PPUSH
47560: LD_VAR 0 1
47564: PPUSH
47565: EMPTY
47566: PPUSH
47567: CALL_OW 1
47571: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
47572: LD_ADDR_EXP 33
47576: PUSH
47577: LD_EXP 33
47581: PPUSH
47582: LD_VAR 0 1
47586: PPUSH
47587: EMPTY
47588: PPUSH
47589: CALL_OW 1
47593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
47594: LD_ADDR_EXP 34
47598: PUSH
47599: LD_EXP 34
47603: PPUSH
47604: LD_VAR 0 1
47608: PPUSH
47609: LD_INT 0
47611: PPUSH
47612: CALL_OW 1
47616: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
47617: LD_ADDR_EXP 35
47621: PUSH
47622: LD_EXP 35
47626: PPUSH
47627: LD_VAR 0 1
47631: PPUSH
47632: EMPTY
47633: PPUSH
47634: CALL_OW 1
47638: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
47639: LD_ADDR_EXP 36
47643: PUSH
47644: LD_EXP 36
47648: PPUSH
47649: LD_VAR 0 1
47653: PPUSH
47654: EMPTY
47655: PPUSH
47656: CALL_OW 1
47660: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
47661: LD_ADDR_EXP 37
47665: PUSH
47666: LD_EXP 37
47670: PPUSH
47671: LD_VAR 0 1
47675: PPUSH
47676: EMPTY
47677: PPUSH
47678: CALL_OW 1
47682: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
47683: LD_ADDR_EXP 38
47687: PUSH
47688: LD_EXP 38
47692: PPUSH
47693: LD_VAR 0 1
47697: PPUSH
47698: EMPTY
47699: PPUSH
47700: CALL_OW 1
47704: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
47705: LD_ADDR_EXP 39
47709: PUSH
47710: LD_EXP 39
47714: PPUSH
47715: LD_VAR 0 1
47719: PPUSH
47720: EMPTY
47721: PPUSH
47722: CALL_OW 1
47726: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
47727: LD_ADDR_EXP 40
47731: PUSH
47732: LD_EXP 40
47736: PPUSH
47737: LD_VAR 0 1
47741: PPUSH
47742: EMPTY
47743: PPUSH
47744: CALL_OW 1
47748: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
47749: LD_ADDR_EXP 41
47753: PUSH
47754: LD_EXP 41
47758: PPUSH
47759: LD_VAR 0 1
47763: PPUSH
47764: EMPTY
47765: PPUSH
47766: CALL_OW 1
47770: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
47771: LD_ADDR_EXP 42
47775: PUSH
47776: LD_EXP 42
47780: PPUSH
47781: LD_VAR 0 1
47785: PPUSH
47786: EMPTY
47787: PPUSH
47788: CALL_OW 1
47792: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
47793: LD_ADDR_EXP 43
47797: PUSH
47798: LD_EXP 43
47802: PPUSH
47803: LD_VAR 0 1
47807: PPUSH
47808: EMPTY
47809: PPUSH
47810: CALL_OW 1
47814: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
47815: LD_ADDR_EXP 44
47819: PUSH
47820: LD_EXP 44
47824: PPUSH
47825: LD_VAR 0 1
47829: PPUSH
47830: EMPTY
47831: PPUSH
47832: CALL_OW 1
47836: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
47837: LD_ADDR_EXP 45
47841: PUSH
47842: LD_EXP 45
47846: PPUSH
47847: LD_VAR 0 1
47851: PPUSH
47852: EMPTY
47853: PPUSH
47854: CALL_OW 1
47858: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
47859: LD_ADDR_EXP 46
47863: PUSH
47864: LD_EXP 46
47868: PPUSH
47869: LD_VAR 0 1
47873: PPUSH
47874: EMPTY
47875: PPUSH
47876: CALL_OW 1
47880: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
47881: LD_ADDR_EXP 47
47885: PUSH
47886: LD_EXP 47
47890: PPUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: EMPTY
47897: PPUSH
47898: CALL_OW 1
47902: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
47903: LD_ADDR_EXP 48
47907: PUSH
47908: LD_EXP 48
47912: PPUSH
47913: LD_VAR 0 1
47917: PPUSH
47918: EMPTY
47919: PPUSH
47920: CALL_OW 1
47924: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
47925: LD_ADDR_EXP 50
47929: PUSH
47930: LD_EXP 50
47934: PPUSH
47935: LD_VAR 0 1
47939: PPUSH
47940: EMPTY
47941: PPUSH
47942: CALL_OW 1
47946: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
47947: LD_ADDR_EXP 52
47951: PUSH
47952: LD_EXP 52
47956: PPUSH
47957: LD_VAR 0 1
47961: PPUSH
47962: EMPTY
47963: PPUSH
47964: CALL_OW 1
47968: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
47969: LD_ADDR_EXP 53
47973: PUSH
47974: LD_EXP 53
47978: PPUSH
47979: LD_VAR 0 1
47983: PPUSH
47984: EMPTY
47985: PPUSH
47986: CALL_OW 1
47990: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
47991: LD_ADDR_EXP 54
47995: PUSH
47996: LD_EXP 54
48000: PPUSH
48001: LD_VAR 0 1
48005: PPUSH
48006: EMPTY
48007: PPUSH
48008: CALL_OW 1
48012: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48013: LD_ADDR_EXP 55
48017: PUSH
48018: LD_EXP 55
48022: PPUSH
48023: LD_VAR 0 1
48027: PPUSH
48028: EMPTY
48029: PPUSH
48030: CALL_OW 1
48034: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48035: LD_ADDR_EXP 56
48039: PUSH
48040: LD_EXP 56
48044: PPUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: EMPTY
48051: PPUSH
48052: CALL_OW 1
48056: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48057: LD_ADDR_EXP 57
48061: PUSH
48062: LD_EXP 57
48066: PPUSH
48067: LD_VAR 0 1
48071: PPUSH
48072: EMPTY
48073: PPUSH
48074: CALL_OW 1
48078: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48079: LD_ADDR_EXP 58
48083: PUSH
48084: LD_EXP 58
48088: PPUSH
48089: LD_VAR 0 1
48093: PPUSH
48094: EMPTY
48095: PPUSH
48096: CALL_OW 1
48100: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48101: LD_ADDR_EXP 59
48105: PUSH
48106: LD_EXP 59
48110: PPUSH
48111: LD_VAR 0 1
48115: PPUSH
48116: EMPTY
48117: PPUSH
48118: CALL_OW 1
48122: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48123: LD_ADDR_EXP 60
48127: PUSH
48128: LD_EXP 60
48132: PPUSH
48133: LD_VAR 0 1
48137: PPUSH
48138: EMPTY
48139: PPUSH
48140: CALL_OW 1
48144: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48145: LD_ADDR_EXP 61
48149: PUSH
48150: LD_EXP 61
48154: PPUSH
48155: LD_VAR 0 1
48159: PPUSH
48160: EMPTY
48161: PPUSH
48162: CALL_OW 1
48166: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48167: LD_ADDR_EXP 62
48171: PUSH
48172: LD_EXP 62
48176: PPUSH
48177: LD_VAR 0 1
48181: PPUSH
48182: EMPTY
48183: PPUSH
48184: CALL_OW 1
48188: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48189: LD_ADDR_EXP 63
48193: PUSH
48194: LD_EXP 63
48198: PPUSH
48199: LD_VAR 0 1
48203: PPUSH
48204: EMPTY
48205: PPUSH
48206: CALL_OW 1
48210: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48211: LD_ADDR_EXP 64
48215: PUSH
48216: LD_EXP 64
48220: PPUSH
48221: LD_VAR 0 1
48225: PPUSH
48226: EMPTY
48227: PPUSH
48228: CALL_OW 1
48232: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48233: LD_ADDR_EXP 65
48237: PUSH
48238: LD_EXP 65
48242: PPUSH
48243: LD_VAR 0 1
48247: PPUSH
48248: LD_INT 0
48250: PPUSH
48251: CALL_OW 1
48255: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
48256: LD_ADDR_EXP 66
48260: PUSH
48261: LD_EXP 66
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: LD_INT 0
48273: PPUSH
48274: CALL_OW 1
48278: ST_TO_ADDR
// end ;
48279: LD_VAR 0 2
48283: RET
// export function MC_Add ( side , units ) ; var base ; begin
48284: LD_INT 0
48286: PPUSH
48287: PPUSH
// base := mc_bases + 1 ;
48288: LD_ADDR_VAR 0 4
48292: PUSH
48293: LD_EXP 23
48297: PUSH
48298: LD_INT 1
48300: PLUS
48301: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48302: LD_ADDR_EXP 49
48306: PUSH
48307: LD_EXP 49
48311: PPUSH
48312: LD_VAR 0 4
48316: PPUSH
48317: LD_VAR 0 1
48321: PPUSH
48322: CALL_OW 1
48326: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48327: LD_ADDR_EXP 23
48331: PUSH
48332: LD_EXP 23
48336: PPUSH
48337: LD_VAR 0 4
48341: PPUSH
48342: LD_VAR 0 2
48346: PPUSH
48347: CALL_OW 1
48351: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48352: LD_ADDR_EXP 24
48356: PUSH
48357: LD_EXP 24
48361: PPUSH
48362: LD_VAR 0 4
48366: PPUSH
48367: EMPTY
48368: PPUSH
48369: CALL_OW 1
48373: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48374: LD_ADDR_EXP 25
48378: PUSH
48379: LD_EXP 25
48383: PPUSH
48384: LD_VAR 0 4
48388: PPUSH
48389: EMPTY
48390: PPUSH
48391: CALL_OW 1
48395: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48396: LD_ADDR_EXP 26
48400: PUSH
48401: LD_EXP 26
48405: PPUSH
48406: LD_VAR 0 4
48410: PPUSH
48411: EMPTY
48412: PPUSH
48413: CALL_OW 1
48417: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48418: LD_ADDR_EXP 27
48422: PUSH
48423: LD_EXP 27
48427: PPUSH
48428: LD_VAR 0 4
48432: PPUSH
48433: EMPTY
48434: PPUSH
48435: CALL_OW 1
48439: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48440: LD_ADDR_EXP 28
48444: PUSH
48445: LD_EXP 28
48449: PPUSH
48450: LD_VAR 0 4
48454: PPUSH
48455: EMPTY
48456: PPUSH
48457: CALL_OW 1
48461: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48462: LD_ADDR_EXP 29
48466: PUSH
48467: LD_EXP 29
48471: PPUSH
48472: LD_VAR 0 4
48476: PPUSH
48477: EMPTY
48478: PPUSH
48479: CALL_OW 1
48483: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48484: LD_ADDR_EXP 30
48488: PUSH
48489: LD_EXP 30
48493: PPUSH
48494: LD_VAR 0 4
48498: PPUSH
48499: EMPTY
48500: PPUSH
48501: CALL_OW 1
48505: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48506: LD_ADDR_EXP 31
48510: PUSH
48511: LD_EXP 31
48515: PPUSH
48516: LD_VAR 0 4
48520: PPUSH
48521: EMPTY
48522: PPUSH
48523: CALL_OW 1
48527: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48528: LD_ADDR_EXP 32
48532: PUSH
48533: LD_EXP 32
48537: PPUSH
48538: LD_VAR 0 4
48542: PPUSH
48543: EMPTY
48544: PPUSH
48545: CALL_OW 1
48549: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48550: LD_ADDR_EXP 33
48554: PUSH
48555: LD_EXP 33
48559: PPUSH
48560: LD_VAR 0 4
48564: PPUSH
48565: EMPTY
48566: PPUSH
48567: CALL_OW 1
48571: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48572: LD_ADDR_EXP 34
48576: PUSH
48577: LD_EXP 34
48581: PPUSH
48582: LD_VAR 0 4
48586: PPUSH
48587: LD_INT 0
48589: PPUSH
48590: CALL_OW 1
48594: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48595: LD_ADDR_EXP 35
48599: PUSH
48600: LD_EXP 35
48604: PPUSH
48605: LD_VAR 0 4
48609: PPUSH
48610: EMPTY
48611: PPUSH
48612: CALL_OW 1
48616: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48617: LD_ADDR_EXP 36
48621: PUSH
48622: LD_EXP 36
48626: PPUSH
48627: LD_VAR 0 4
48631: PPUSH
48632: EMPTY
48633: PPUSH
48634: CALL_OW 1
48638: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48639: LD_ADDR_EXP 37
48643: PUSH
48644: LD_EXP 37
48648: PPUSH
48649: LD_VAR 0 4
48653: PPUSH
48654: EMPTY
48655: PPUSH
48656: CALL_OW 1
48660: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48661: LD_ADDR_EXP 38
48665: PUSH
48666: LD_EXP 38
48670: PPUSH
48671: LD_VAR 0 4
48675: PPUSH
48676: EMPTY
48677: PPUSH
48678: CALL_OW 1
48682: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48683: LD_ADDR_EXP 39
48687: PUSH
48688: LD_EXP 39
48692: PPUSH
48693: LD_VAR 0 4
48697: PPUSH
48698: EMPTY
48699: PPUSH
48700: CALL_OW 1
48704: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48705: LD_ADDR_EXP 40
48709: PUSH
48710: LD_EXP 40
48714: PPUSH
48715: LD_VAR 0 4
48719: PPUSH
48720: EMPTY
48721: PPUSH
48722: CALL_OW 1
48726: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48727: LD_ADDR_EXP 41
48731: PUSH
48732: LD_EXP 41
48736: PPUSH
48737: LD_VAR 0 4
48741: PPUSH
48742: EMPTY
48743: PPUSH
48744: CALL_OW 1
48748: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48749: LD_ADDR_EXP 42
48753: PUSH
48754: LD_EXP 42
48758: PPUSH
48759: LD_VAR 0 4
48763: PPUSH
48764: EMPTY
48765: PPUSH
48766: CALL_OW 1
48770: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48771: LD_ADDR_EXP 43
48775: PUSH
48776: LD_EXP 43
48780: PPUSH
48781: LD_VAR 0 4
48785: PPUSH
48786: EMPTY
48787: PPUSH
48788: CALL_OW 1
48792: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48793: LD_ADDR_EXP 44
48797: PUSH
48798: LD_EXP 44
48802: PPUSH
48803: LD_VAR 0 4
48807: PPUSH
48808: EMPTY
48809: PPUSH
48810: CALL_OW 1
48814: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48815: LD_ADDR_EXP 45
48819: PUSH
48820: LD_EXP 45
48824: PPUSH
48825: LD_VAR 0 4
48829: PPUSH
48830: EMPTY
48831: PPUSH
48832: CALL_OW 1
48836: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48837: LD_ADDR_EXP 46
48841: PUSH
48842: LD_EXP 46
48846: PPUSH
48847: LD_VAR 0 4
48851: PPUSH
48852: EMPTY
48853: PPUSH
48854: CALL_OW 1
48858: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48859: LD_ADDR_EXP 47
48863: PUSH
48864: LD_EXP 47
48868: PPUSH
48869: LD_VAR 0 4
48873: PPUSH
48874: EMPTY
48875: PPUSH
48876: CALL_OW 1
48880: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48881: LD_ADDR_EXP 48
48885: PUSH
48886: LD_EXP 48
48890: PPUSH
48891: LD_VAR 0 4
48895: PPUSH
48896: EMPTY
48897: PPUSH
48898: CALL_OW 1
48902: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48903: LD_ADDR_EXP 50
48907: PUSH
48908: LD_EXP 50
48912: PPUSH
48913: LD_VAR 0 4
48917: PPUSH
48918: EMPTY
48919: PPUSH
48920: CALL_OW 1
48924: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48925: LD_ADDR_EXP 52
48929: PUSH
48930: LD_EXP 52
48934: PPUSH
48935: LD_VAR 0 4
48939: PPUSH
48940: EMPTY
48941: PPUSH
48942: CALL_OW 1
48946: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48947: LD_ADDR_EXP 53
48951: PUSH
48952: LD_EXP 53
48956: PPUSH
48957: LD_VAR 0 4
48961: PPUSH
48962: EMPTY
48963: PPUSH
48964: CALL_OW 1
48968: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48969: LD_ADDR_EXP 54
48973: PUSH
48974: LD_EXP 54
48978: PPUSH
48979: LD_VAR 0 4
48983: PPUSH
48984: EMPTY
48985: PPUSH
48986: CALL_OW 1
48990: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48991: LD_ADDR_EXP 55
48995: PUSH
48996: LD_EXP 55
49000: PPUSH
49001: LD_VAR 0 4
49005: PPUSH
49006: EMPTY
49007: PPUSH
49008: CALL_OW 1
49012: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49013: LD_ADDR_EXP 56
49017: PUSH
49018: LD_EXP 56
49022: PPUSH
49023: LD_VAR 0 4
49027: PPUSH
49028: EMPTY
49029: PPUSH
49030: CALL_OW 1
49034: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49035: LD_ADDR_EXP 57
49039: PUSH
49040: LD_EXP 57
49044: PPUSH
49045: LD_VAR 0 4
49049: PPUSH
49050: EMPTY
49051: PPUSH
49052: CALL_OW 1
49056: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49057: LD_ADDR_EXP 58
49061: PUSH
49062: LD_EXP 58
49066: PPUSH
49067: LD_VAR 0 4
49071: PPUSH
49072: EMPTY
49073: PPUSH
49074: CALL_OW 1
49078: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49079: LD_ADDR_EXP 59
49083: PUSH
49084: LD_EXP 59
49088: PPUSH
49089: LD_VAR 0 4
49093: PPUSH
49094: EMPTY
49095: PPUSH
49096: CALL_OW 1
49100: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49101: LD_ADDR_EXP 60
49105: PUSH
49106: LD_EXP 60
49110: PPUSH
49111: LD_VAR 0 4
49115: PPUSH
49116: EMPTY
49117: PPUSH
49118: CALL_OW 1
49122: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49123: LD_ADDR_EXP 61
49127: PUSH
49128: LD_EXP 61
49132: PPUSH
49133: LD_VAR 0 4
49137: PPUSH
49138: EMPTY
49139: PPUSH
49140: CALL_OW 1
49144: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49145: LD_ADDR_EXP 62
49149: PUSH
49150: LD_EXP 62
49154: PPUSH
49155: LD_VAR 0 4
49159: PPUSH
49160: EMPTY
49161: PPUSH
49162: CALL_OW 1
49166: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49167: LD_ADDR_EXP 63
49171: PUSH
49172: LD_EXP 63
49176: PPUSH
49177: LD_VAR 0 4
49181: PPUSH
49182: EMPTY
49183: PPUSH
49184: CALL_OW 1
49188: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49189: LD_ADDR_EXP 64
49193: PUSH
49194: LD_EXP 64
49198: PPUSH
49199: LD_VAR 0 4
49203: PPUSH
49204: EMPTY
49205: PPUSH
49206: CALL_OW 1
49210: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49211: LD_ADDR_EXP 65
49215: PUSH
49216: LD_EXP 65
49220: PPUSH
49221: LD_VAR 0 4
49225: PPUSH
49226: LD_INT 0
49228: PPUSH
49229: CALL_OW 1
49233: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
49234: LD_ADDR_EXP 66
49238: PUSH
49239: LD_EXP 66
49243: PPUSH
49244: LD_VAR 0 4
49248: PPUSH
49249: LD_INT 0
49251: PPUSH
49252: CALL_OW 1
49256: ST_TO_ADDR
// result := base ;
49257: LD_ADDR_VAR 0 3
49261: PUSH
49262: LD_VAR 0 4
49266: ST_TO_ADDR
// end ;
49267: LD_VAR 0 3
49271: RET
// export function MC_Start ( ) ; var i ; begin
49272: LD_INT 0
49274: PPUSH
49275: PPUSH
// for i = 1 to mc_bases do
49276: LD_ADDR_VAR 0 2
49280: PUSH
49281: DOUBLE
49282: LD_INT 1
49284: DEC
49285: ST_TO_ADDR
49286: LD_EXP 23
49290: PUSH
49291: FOR_TO
49292: IFFALSE 50392
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49294: LD_ADDR_EXP 23
49298: PUSH
49299: LD_EXP 23
49303: PPUSH
49304: LD_VAR 0 2
49308: PPUSH
49309: LD_EXP 23
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_INT 0
49322: DIFF
49323: PPUSH
49324: CALL_OW 1
49328: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49329: LD_ADDR_EXP 24
49333: PUSH
49334: LD_EXP 24
49338: PPUSH
49339: LD_VAR 0 2
49343: PPUSH
49344: EMPTY
49345: PPUSH
49346: CALL_OW 1
49350: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49351: LD_ADDR_EXP 25
49355: PUSH
49356: LD_EXP 25
49360: PPUSH
49361: LD_VAR 0 2
49365: PPUSH
49366: EMPTY
49367: PPUSH
49368: CALL_OW 1
49372: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49373: LD_ADDR_EXP 26
49377: PUSH
49378: LD_EXP 26
49382: PPUSH
49383: LD_VAR 0 2
49387: PPUSH
49388: EMPTY
49389: PPUSH
49390: CALL_OW 1
49394: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49395: LD_ADDR_EXP 27
49399: PUSH
49400: LD_EXP 27
49404: PPUSH
49405: LD_VAR 0 2
49409: PPUSH
49410: EMPTY
49411: PUSH
49412: EMPTY
49413: PUSH
49414: EMPTY
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 1
49422: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49423: LD_ADDR_EXP 28
49427: PUSH
49428: LD_EXP 28
49432: PPUSH
49433: LD_VAR 0 2
49437: PPUSH
49438: EMPTY
49439: PPUSH
49440: CALL_OW 1
49444: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49445: LD_ADDR_EXP 55
49449: PUSH
49450: LD_EXP 55
49454: PPUSH
49455: LD_VAR 0 2
49459: PPUSH
49460: EMPTY
49461: PPUSH
49462: CALL_OW 1
49466: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49467: LD_ADDR_EXP 29
49471: PUSH
49472: LD_EXP 29
49476: PPUSH
49477: LD_VAR 0 2
49481: PPUSH
49482: EMPTY
49483: PPUSH
49484: CALL_OW 1
49488: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
49489: LD_ADDR_EXP 30
49493: PUSH
49494: LD_EXP 30
49498: PPUSH
49499: LD_VAR 0 2
49503: PPUSH
49504: EMPTY
49505: PPUSH
49506: CALL_OW 1
49510: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
49511: LD_ADDR_EXP 31
49515: PUSH
49516: LD_EXP 31
49520: PPUSH
49521: LD_VAR 0 2
49525: PPUSH
49526: LD_EXP 23
49530: PUSH
49531: LD_VAR 0 2
49535: ARRAY
49536: PPUSH
49537: LD_INT 2
49539: PUSH
49540: LD_INT 30
49542: PUSH
49543: LD_INT 32
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 30
49552: PUSH
49553: LD_INT 33
49555: PUSH
49556: EMPTY
49557: LIST
49558: LIST
49559: PUSH
49560: EMPTY
49561: LIST
49562: LIST
49563: LIST
49564: PPUSH
49565: CALL_OW 72
49569: PPUSH
49570: CALL_OW 1
49574: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
49575: LD_ADDR_EXP 32
49579: PUSH
49580: LD_EXP 32
49584: PPUSH
49585: LD_VAR 0 2
49589: PPUSH
49590: LD_EXP 23
49594: PUSH
49595: LD_VAR 0 2
49599: ARRAY
49600: PPUSH
49601: LD_INT 2
49603: PUSH
49604: LD_INT 30
49606: PUSH
49607: LD_INT 32
49609: PUSH
49610: EMPTY
49611: LIST
49612: LIST
49613: PUSH
49614: LD_INT 30
49616: PUSH
49617: LD_INT 31
49619: PUSH
49620: EMPTY
49621: LIST
49622: LIST
49623: PUSH
49624: EMPTY
49625: LIST
49626: LIST
49627: LIST
49628: PUSH
49629: LD_INT 58
49631: PUSH
49632: EMPTY
49633: LIST
49634: PUSH
49635: EMPTY
49636: LIST
49637: LIST
49638: PPUSH
49639: CALL_OW 72
49643: PPUSH
49644: CALL_OW 1
49648: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
49649: LD_ADDR_EXP 33
49653: PUSH
49654: LD_EXP 33
49658: PPUSH
49659: LD_VAR 0 2
49663: PPUSH
49664: EMPTY
49665: PPUSH
49666: CALL_OW 1
49670: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
49671: LD_ADDR_EXP 37
49675: PUSH
49676: LD_EXP 37
49680: PPUSH
49681: LD_VAR 0 2
49685: PPUSH
49686: EMPTY
49687: PPUSH
49688: CALL_OW 1
49692: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
49693: LD_ADDR_EXP 36
49697: PUSH
49698: LD_EXP 36
49702: PPUSH
49703: LD_VAR 0 2
49707: PPUSH
49708: EMPTY
49709: PPUSH
49710: CALL_OW 1
49714: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
49715: LD_ADDR_EXP 38
49719: PUSH
49720: LD_EXP 38
49724: PPUSH
49725: LD_VAR 0 2
49729: PPUSH
49730: EMPTY
49731: PPUSH
49732: CALL_OW 1
49736: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
49737: LD_ADDR_EXP 39
49741: PUSH
49742: LD_EXP 39
49746: PPUSH
49747: LD_VAR 0 2
49751: PPUSH
49752: EMPTY
49753: PPUSH
49754: CALL_OW 1
49758: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
49759: LD_ADDR_EXP 40
49763: PUSH
49764: LD_EXP 40
49768: PPUSH
49769: LD_VAR 0 2
49773: PPUSH
49774: EMPTY
49775: PPUSH
49776: CALL_OW 1
49780: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
49781: LD_ADDR_EXP 41
49785: PUSH
49786: LD_EXP 41
49790: PPUSH
49791: LD_VAR 0 2
49795: PPUSH
49796: EMPTY
49797: PPUSH
49798: CALL_OW 1
49802: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
49803: LD_ADDR_EXP 42
49807: PUSH
49808: LD_EXP 42
49812: PPUSH
49813: LD_VAR 0 2
49817: PPUSH
49818: EMPTY
49819: PPUSH
49820: CALL_OW 1
49824: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49825: LD_ADDR_EXP 43
49829: PUSH
49830: LD_EXP 43
49834: PPUSH
49835: LD_VAR 0 2
49839: PPUSH
49840: EMPTY
49841: PPUSH
49842: CALL_OW 1
49846: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
49847: LD_ADDR_EXP 44
49851: PUSH
49852: LD_EXP 44
49856: PPUSH
49857: LD_VAR 0 2
49861: PPUSH
49862: EMPTY
49863: PPUSH
49864: CALL_OW 1
49868: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
49869: LD_ADDR_EXP 45
49873: PUSH
49874: LD_EXP 45
49878: PPUSH
49879: LD_VAR 0 2
49883: PPUSH
49884: EMPTY
49885: PPUSH
49886: CALL_OW 1
49890: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
49891: LD_ADDR_EXP 34
49895: PUSH
49896: LD_EXP 34
49900: PPUSH
49901: LD_VAR 0 2
49905: PPUSH
49906: LD_INT 0
49908: PPUSH
49909: CALL_OW 1
49913: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
49914: LD_ADDR_EXP 47
49918: PUSH
49919: LD_EXP 47
49923: PPUSH
49924: LD_VAR 0 2
49928: PPUSH
49929: LD_INT 0
49931: PPUSH
49932: CALL_OW 1
49936: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
49937: LD_ADDR_EXP 35
49941: PUSH
49942: LD_EXP 35
49946: PPUSH
49947: LD_VAR 0 2
49951: PPUSH
49952: EMPTY
49953: PPUSH
49954: CALL_OW 1
49958: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
49959: LD_ADDR_EXP 46
49963: PUSH
49964: LD_EXP 46
49968: PPUSH
49969: LD_VAR 0 2
49973: PPUSH
49974: LD_INT 0
49976: PPUSH
49977: CALL_OW 1
49981: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
49982: LD_ADDR_EXP 48
49986: PUSH
49987: LD_EXP 48
49991: PPUSH
49992: LD_VAR 0 2
49996: PPUSH
49997: EMPTY
49998: PPUSH
49999: CALL_OW 1
50003: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
50004: LD_ADDR_EXP 51
50008: PUSH
50009: LD_EXP 51
50013: PPUSH
50014: LD_VAR 0 2
50018: PPUSH
50019: LD_INT 0
50021: PPUSH
50022: CALL_OW 1
50026: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
50027: LD_ADDR_EXP 52
50031: PUSH
50032: LD_EXP 52
50036: PPUSH
50037: LD_VAR 0 2
50041: PPUSH
50042: EMPTY
50043: PPUSH
50044: CALL_OW 1
50048: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50049: LD_ADDR_EXP 53
50053: PUSH
50054: LD_EXP 53
50058: PPUSH
50059: LD_VAR 0 2
50063: PPUSH
50064: EMPTY
50065: PPUSH
50066: CALL_OW 1
50070: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50071: LD_ADDR_EXP 54
50075: PUSH
50076: LD_EXP 54
50080: PPUSH
50081: LD_VAR 0 2
50085: PPUSH
50086: EMPTY
50087: PPUSH
50088: CALL_OW 1
50092: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
50093: LD_ADDR_EXP 56
50097: PUSH
50098: LD_EXP 56
50102: PPUSH
50103: LD_VAR 0 2
50107: PPUSH
50108: LD_EXP 23
50112: PUSH
50113: LD_VAR 0 2
50117: ARRAY
50118: PPUSH
50119: LD_INT 2
50121: PUSH
50122: LD_INT 30
50124: PUSH
50125: LD_INT 6
50127: PUSH
50128: EMPTY
50129: LIST
50130: LIST
50131: PUSH
50132: LD_INT 30
50134: PUSH
50135: LD_INT 7
50137: PUSH
50138: EMPTY
50139: LIST
50140: LIST
50141: PUSH
50142: LD_INT 30
50144: PUSH
50145: LD_INT 8
50147: PUSH
50148: EMPTY
50149: LIST
50150: LIST
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: LIST
50156: LIST
50157: PPUSH
50158: CALL_OW 72
50162: PPUSH
50163: CALL_OW 1
50167: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50168: LD_ADDR_EXP 57
50172: PUSH
50173: LD_EXP 57
50177: PPUSH
50178: LD_VAR 0 2
50182: PPUSH
50183: EMPTY
50184: PPUSH
50185: CALL_OW 1
50189: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50190: LD_ADDR_EXP 58
50194: PUSH
50195: LD_EXP 58
50199: PPUSH
50200: LD_VAR 0 2
50204: PPUSH
50205: EMPTY
50206: PPUSH
50207: CALL_OW 1
50211: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50212: LD_ADDR_EXP 59
50216: PUSH
50217: LD_EXP 59
50221: PPUSH
50222: LD_VAR 0 2
50226: PPUSH
50227: EMPTY
50228: PPUSH
50229: CALL_OW 1
50233: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50234: LD_ADDR_EXP 60
50238: PUSH
50239: LD_EXP 60
50243: PPUSH
50244: LD_VAR 0 2
50248: PPUSH
50249: EMPTY
50250: PPUSH
50251: CALL_OW 1
50255: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50256: LD_ADDR_EXP 61
50260: PUSH
50261: LD_EXP 61
50265: PPUSH
50266: LD_VAR 0 2
50270: PPUSH
50271: EMPTY
50272: PPUSH
50273: CALL_OW 1
50277: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50278: LD_ADDR_EXP 62
50282: PUSH
50283: LD_EXP 62
50287: PPUSH
50288: LD_VAR 0 2
50292: PPUSH
50293: EMPTY
50294: PPUSH
50295: CALL_OW 1
50299: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50300: LD_ADDR_EXP 63
50304: PUSH
50305: LD_EXP 63
50309: PPUSH
50310: LD_VAR 0 2
50314: PPUSH
50315: EMPTY
50316: PPUSH
50317: CALL_OW 1
50321: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50322: LD_ADDR_EXP 64
50326: PUSH
50327: LD_EXP 64
50331: PPUSH
50332: LD_VAR 0 2
50336: PPUSH
50337: EMPTY
50338: PPUSH
50339: CALL_OW 1
50343: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50344: LD_ADDR_EXP 65
50348: PUSH
50349: LD_EXP 65
50353: PPUSH
50354: LD_VAR 0 2
50358: PPUSH
50359: LD_INT 0
50361: PPUSH
50362: CALL_OW 1
50366: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
50367: LD_ADDR_EXP 66
50371: PUSH
50372: LD_EXP 66
50376: PPUSH
50377: LD_VAR 0 2
50381: PPUSH
50382: LD_INT 0
50384: PPUSH
50385: CALL_OW 1
50389: ST_TO_ADDR
// end ;
50390: GO 49291
50392: POP
50393: POP
// MC_InitSides ( ) ;
50394: CALL 50680 0 0
// MC_InitResearch ( ) ;
50398: CALL 50419 0 0
// CustomInitMacro ( ) ;
50402: CALL 277 0 0
// skirmish := true ;
50406: LD_ADDR_EXP 21
50410: PUSH
50411: LD_INT 1
50413: ST_TO_ADDR
// end ;
50414: LD_VAR 0 1
50418: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50419: LD_INT 0
50421: PPUSH
50422: PPUSH
50423: PPUSH
50424: PPUSH
50425: PPUSH
50426: PPUSH
// if not mc_bases then
50427: LD_EXP 23
50431: NOT
50432: IFFALSE 50436
// exit ;
50434: GO 50675
// for i = 1 to 8 do
50436: LD_ADDR_VAR 0 2
50440: PUSH
50441: DOUBLE
50442: LD_INT 1
50444: DEC
50445: ST_TO_ADDR
50446: LD_INT 8
50448: PUSH
50449: FOR_TO
50450: IFFALSE 50476
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50452: LD_ADDR_EXP 50
50456: PUSH
50457: LD_EXP 50
50461: PPUSH
50462: LD_VAR 0 2
50466: PPUSH
50467: EMPTY
50468: PPUSH
50469: CALL_OW 1
50473: ST_TO_ADDR
50474: GO 50449
50476: POP
50477: POP
// tmp := [ ] ;
50478: LD_ADDR_VAR 0 5
50482: PUSH
50483: EMPTY
50484: ST_TO_ADDR
// for i = 1 to mc_sides do
50485: LD_ADDR_VAR 0 2
50489: PUSH
50490: DOUBLE
50491: LD_INT 1
50493: DEC
50494: ST_TO_ADDR
50495: LD_EXP 49
50499: PUSH
50500: FOR_TO
50501: IFFALSE 50559
// if not mc_sides [ i ] in tmp then
50503: LD_EXP 49
50507: PUSH
50508: LD_VAR 0 2
50512: ARRAY
50513: PUSH
50514: LD_VAR 0 5
50518: IN
50519: NOT
50520: IFFALSE 50557
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
50522: LD_ADDR_VAR 0 5
50526: PUSH
50527: LD_VAR 0 5
50531: PPUSH
50532: LD_VAR 0 5
50536: PUSH
50537: LD_INT 1
50539: PLUS
50540: PPUSH
50541: LD_EXP 49
50545: PUSH
50546: LD_VAR 0 2
50550: ARRAY
50551: PPUSH
50552: CALL_OW 2
50556: ST_TO_ADDR
50557: GO 50500
50559: POP
50560: POP
// if not tmp then
50561: LD_VAR 0 5
50565: NOT
50566: IFFALSE 50570
// exit ;
50568: GO 50675
// for j in tmp do
50570: LD_ADDR_VAR 0 3
50574: PUSH
50575: LD_VAR 0 5
50579: PUSH
50580: FOR_IN
50581: IFFALSE 50673
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
50583: LD_ADDR_VAR 0 6
50587: PUSH
50588: LD_INT 22
50590: PUSH
50591: LD_VAR 0 3
50595: PUSH
50596: EMPTY
50597: LIST
50598: LIST
50599: PPUSH
50600: CALL_OW 69
50604: ST_TO_ADDR
// if not un then
50605: LD_VAR 0 6
50609: NOT
50610: IFFALSE 50614
// continue ;
50612: GO 50580
// nation := GetNation ( un [ 1 ] ) ;
50614: LD_ADDR_VAR 0 4
50618: PUSH
50619: LD_VAR 0 6
50623: PUSH
50624: LD_INT 1
50626: ARRAY
50627: PPUSH
50628: CALL_OW 248
50632: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
50633: LD_ADDR_EXP 50
50637: PUSH
50638: LD_EXP 50
50642: PPUSH
50643: LD_VAR 0 3
50647: PPUSH
50648: LD_VAR 0 3
50652: PPUSH
50653: LD_VAR 0 4
50657: PPUSH
50658: LD_INT 1
50660: PPUSH
50661: CALL 8696 0 3
50665: PPUSH
50666: CALL_OW 1
50670: ST_TO_ADDR
// end ;
50671: GO 50580
50673: POP
50674: POP
// end ;
50675: LD_VAR 0 1
50679: RET
// export function MC_InitSides ( ) ; var i ; begin
50680: LD_INT 0
50682: PPUSH
50683: PPUSH
// if not mc_bases then
50684: LD_EXP 23
50688: NOT
50689: IFFALSE 50693
// exit ;
50691: GO 50767
// for i = 1 to mc_bases do
50693: LD_ADDR_VAR 0 2
50697: PUSH
50698: DOUBLE
50699: LD_INT 1
50701: DEC
50702: ST_TO_ADDR
50703: LD_EXP 23
50707: PUSH
50708: FOR_TO
50709: IFFALSE 50765
// if mc_bases [ i ] then
50711: LD_EXP 23
50715: PUSH
50716: LD_VAR 0 2
50720: ARRAY
50721: IFFALSE 50763
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
50723: LD_ADDR_EXP 49
50727: PUSH
50728: LD_EXP 49
50732: PPUSH
50733: LD_VAR 0 2
50737: PPUSH
50738: LD_EXP 23
50742: PUSH
50743: LD_VAR 0 2
50747: ARRAY
50748: PUSH
50749: LD_INT 1
50751: ARRAY
50752: PPUSH
50753: CALL_OW 255
50757: PPUSH
50758: CALL_OW 1
50762: ST_TO_ADDR
50763: GO 50708
50765: POP
50766: POP
// end ;
50767: LD_VAR 0 1
50771: RET
// every 0 0$03 trigger skirmish do
50772: LD_EXP 21
50776: IFFALSE 50930
50778: GO 50780
50780: DISABLE
// begin enable ;
50781: ENABLE
// MC_CheckBuildings ( ) ;
50782: CALL 55428 0 0
// MC_CheckPeopleLife ( ) ;
50786: CALL 55553 0 0
// RaiseSailEvent ( 100 ) ;
50790: LD_INT 100
50792: PPUSH
50793: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
50797: LD_INT 103
50799: PPUSH
50800: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
50804: LD_INT 104
50806: PPUSH
50807: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
50811: LD_INT 105
50813: PPUSH
50814: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
50818: LD_INT 106
50820: PPUSH
50821: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
50825: LD_INT 107
50827: PPUSH
50828: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
50832: LD_INT 108
50834: PPUSH
50835: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
50839: LD_INT 109
50841: PPUSH
50842: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
50846: LD_INT 110
50848: PPUSH
50849: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
50853: LD_INT 111
50855: PPUSH
50856: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
50860: LD_INT 112
50862: PPUSH
50863: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
50867: LD_INT 113
50869: PPUSH
50870: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
50874: LD_INT 120
50876: PPUSH
50877: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
50881: LD_INT 121
50883: PPUSH
50884: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
50888: LD_INT 122
50890: PPUSH
50891: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
50895: LD_INT 123
50897: PPUSH
50898: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
50902: LD_INT 124
50904: PPUSH
50905: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
50909: LD_INT 125
50911: PPUSH
50912: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
50916: LD_INT 126
50918: PPUSH
50919: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
50923: LD_INT 200
50925: PPUSH
50926: CALL_OW 427
// end ;
50930: END
// on SailEvent ( event ) do begin if event < 100 then
50931: LD_VAR 0 1
50935: PUSH
50936: LD_INT 100
50938: LESS
50939: IFFALSE 50950
// CustomEvent ( event ) ;
50941: LD_VAR 0 1
50945: PPUSH
50946: CALL 7890 0 1
// if event = 100 then
50950: LD_VAR 0 1
50954: PUSH
50955: LD_INT 100
50957: EQUAL
50958: IFFALSE 50964
// MC_ClassManager ( ) ;
50960: CALL 51356 0 0
// if event = 101 then
50964: LD_VAR 0 1
50968: PUSH
50969: LD_INT 101
50971: EQUAL
50972: IFFALSE 50978
// MC_RepairBuildings ( ) ;
50974: CALL 56138 0 0
// if event = 102 then
50978: LD_VAR 0 1
50982: PUSH
50983: LD_INT 102
50985: EQUAL
50986: IFFALSE 50992
// MC_Heal ( ) ;
50988: CALL 57023 0 0
// if event = 103 then
50992: LD_VAR 0 1
50996: PUSH
50997: LD_INT 103
50999: EQUAL
51000: IFFALSE 51006
// MC_Build ( ) ;
51002: CALL 57445 0 0
// if event = 104 then
51006: LD_VAR 0 1
51010: PUSH
51011: LD_INT 104
51013: EQUAL
51014: IFFALSE 51020
// MC_TurretWeapon ( ) ;
51016: CALL 59086 0 0
// if event = 105 then
51020: LD_VAR 0 1
51024: PUSH
51025: LD_INT 105
51027: EQUAL
51028: IFFALSE 51034
// MC_BuildUpgrade ( ) ;
51030: CALL 58637 0 0
// if event = 106 then
51034: LD_VAR 0 1
51038: PUSH
51039: LD_INT 106
51041: EQUAL
51042: IFFALSE 51048
// MC_PlantMines ( ) ;
51044: CALL 59516 0 0
// if event = 107 then
51048: LD_VAR 0 1
51052: PUSH
51053: LD_INT 107
51055: EQUAL
51056: IFFALSE 51062
// MC_CollectCrates ( ) ;
51058: CALL 60307 0 0
// if event = 108 then
51062: LD_VAR 0 1
51066: PUSH
51067: LD_INT 108
51069: EQUAL
51070: IFFALSE 51076
// MC_LinkRemoteControl ( ) ;
51072: CALL 62083 0 0
// if event = 109 then
51076: LD_VAR 0 1
51080: PUSH
51081: LD_INT 109
51083: EQUAL
51084: IFFALSE 51090
// MC_ProduceVehicle ( ) ;
51086: CALL 62264 0 0
// if event = 110 then
51090: LD_VAR 0 1
51094: PUSH
51095: LD_INT 110
51097: EQUAL
51098: IFFALSE 51104
// MC_SendAttack ( ) ;
51100: CALL 62730 0 0
// if event = 111 then
51104: LD_VAR 0 1
51108: PUSH
51109: LD_INT 111
51111: EQUAL
51112: IFFALSE 51118
// MC_Defend ( ) ;
51114: CALL 62838 0 0
// if event = 112 then
51118: LD_VAR 0 1
51122: PUSH
51123: LD_INT 112
51125: EQUAL
51126: IFFALSE 51132
// MC_Research ( ) ;
51128: CALL 63560 0 0
// if event = 113 then
51132: LD_VAR 0 1
51136: PUSH
51137: LD_INT 113
51139: EQUAL
51140: IFFALSE 51146
// MC_MinesTrigger ( ) ;
51142: CALL 64674 0 0
// if event = 120 then
51146: LD_VAR 0 1
51150: PUSH
51151: LD_INT 120
51153: EQUAL
51154: IFFALSE 51160
// MC_RepairVehicle ( ) ;
51156: CALL 64773 0 0
// if event = 121 then
51160: LD_VAR 0 1
51164: PUSH
51165: LD_INT 121
51167: EQUAL
51168: IFFALSE 51174
// MC_TameApe ( ) ;
51170: CALL 65503 0 0
// if event = 122 then
51174: LD_VAR 0 1
51178: PUSH
51179: LD_INT 122
51181: EQUAL
51182: IFFALSE 51188
// MC_ChangeApeClass ( ) ;
51184: CALL 66332 0 0
// if event = 123 then
51188: LD_VAR 0 1
51192: PUSH
51193: LD_INT 123
51195: EQUAL
51196: IFFALSE 51202
// MC_Bazooka ( ) ;
51198: CALL 66982 0 0
// if event = 124 then
51202: LD_VAR 0 1
51206: PUSH
51207: LD_INT 124
51209: EQUAL
51210: IFFALSE 51216
// MC_TeleportExit ( ) ;
51212: CALL 67180 0 0
// if event = 125 then
51216: LD_VAR 0 1
51220: PUSH
51221: LD_INT 125
51223: EQUAL
51224: IFFALSE 51230
// MC_Deposits ( ) ;
51226: CALL 67827 0 0
// if event = 126 then
51230: LD_VAR 0 1
51234: PUSH
51235: LD_INT 126
51237: EQUAL
51238: IFFALSE 51244
// MC_RemoteDriver ( ) ;
51240: CALL 68452 0 0
// if event = 200 then
51244: LD_VAR 0 1
51248: PUSH
51249: LD_INT 200
51251: EQUAL
51252: IFFALSE 51258
// MC_Idle ( ) ;
51254: CALL 70401 0 0
// end ;
51258: PPOPN 1
51260: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51261: LD_INT 0
51263: PPUSH
51264: PPUSH
// if not mc_bases [ base ] or not tag then
51265: LD_EXP 23
51269: PUSH
51270: LD_VAR 0 1
51274: ARRAY
51275: NOT
51276: PUSH
51277: LD_VAR 0 2
51281: NOT
51282: OR
51283: IFFALSE 51287
// exit ;
51285: GO 51351
// for i in mc_bases [ base ] union mc_ape [ base ] do
51287: LD_ADDR_VAR 0 4
51291: PUSH
51292: LD_EXP 23
51296: PUSH
51297: LD_VAR 0 1
51301: ARRAY
51302: PUSH
51303: LD_EXP 52
51307: PUSH
51308: LD_VAR 0 1
51312: ARRAY
51313: UNION
51314: PUSH
51315: FOR_IN
51316: IFFALSE 51349
// if GetTag ( i ) = tag then
51318: LD_VAR 0 4
51322: PPUSH
51323: CALL_OW 110
51327: PUSH
51328: LD_VAR 0 2
51332: EQUAL
51333: IFFALSE 51347
// SetTag ( i , 0 ) ;
51335: LD_VAR 0 4
51339: PPUSH
51340: LD_INT 0
51342: PPUSH
51343: CALL_OW 109
51347: GO 51315
51349: POP
51350: POP
// end ;
51351: LD_VAR 0 3
51355: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51356: LD_INT 0
51358: PPUSH
51359: PPUSH
51360: PPUSH
51361: PPUSH
51362: PPUSH
51363: PPUSH
51364: PPUSH
51365: PPUSH
// if not mc_bases then
51366: LD_EXP 23
51370: NOT
51371: IFFALSE 51375
// exit ;
51373: GO 51833
// for i = 1 to mc_bases do
51375: LD_ADDR_VAR 0 2
51379: PUSH
51380: DOUBLE
51381: LD_INT 1
51383: DEC
51384: ST_TO_ADDR
51385: LD_EXP 23
51389: PUSH
51390: FOR_TO
51391: IFFALSE 51831
// begin tmp := MC_ClassCheckReq ( i ) ;
51393: LD_ADDR_VAR 0 4
51397: PUSH
51398: LD_VAR 0 2
51402: PPUSH
51403: CALL 51838 0 1
51407: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51408: LD_ADDR_EXP 64
51412: PUSH
51413: LD_EXP 64
51417: PPUSH
51418: LD_VAR 0 2
51422: PPUSH
51423: LD_VAR 0 4
51427: PPUSH
51428: CALL_OW 1
51432: ST_TO_ADDR
// if not tmp then
51433: LD_VAR 0 4
51437: NOT
51438: IFFALSE 51442
// continue ;
51440: GO 51390
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51442: LD_ADDR_VAR 0 6
51446: PUSH
51447: LD_EXP 23
51451: PUSH
51452: LD_VAR 0 2
51456: ARRAY
51457: PPUSH
51458: LD_INT 2
51460: PUSH
51461: LD_INT 30
51463: PUSH
51464: LD_INT 4
51466: PUSH
51467: EMPTY
51468: LIST
51469: LIST
51470: PUSH
51471: LD_INT 30
51473: PUSH
51474: LD_INT 5
51476: PUSH
51477: EMPTY
51478: LIST
51479: LIST
51480: PUSH
51481: EMPTY
51482: LIST
51483: LIST
51484: LIST
51485: PPUSH
51486: CALL_OW 72
51490: PUSH
51491: LD_EXP 23
51495: PUSH
51496: LD_VAR 0 2
51500: ARRAY
51501: PPUSH
51502: LD_INT 2
51504: PUSH
51505: LD_INT 30
51507: PUSH
51508: LD_INT 0
51510: PUSH
51511: EMPTY
51512: LIST
51513: LIST
51514: PUSH
51515: LD_INT 30
51517: PUSH
51518: LD_INT 1
51520: PUSH
51521: EMPTY
51522: LIST
51523: LIST
51524: PUSH
51525: EMPTY
51526: LIST
51527: LIST
51528: LIST
51529: PPUSH
51530: CALL_OW 72
51534: PUSH
51535: LD_EXP 23
51539: PUSH
51540: LD_VAR 0 2
51544: ARRAY
51545: PPUSH
51546: LD_INT 30
51548: PUSH
51549: LD_INT 3
51551: PUSH
51552: EMPTY
51553: LIST
51554: LIST
51555: PPUSH
51556: CALL_OW 72
51560: PUSH
51561: LD_EXP 23
51565: PUSH
51566: LD_VAR 0 2
51570: ARRAY
51571: PPUSH
51572: LD_INT 2
51574: PUSH
51575: LD_INT 30
51577: PUSH
51578: LD_INT 6
51580: PUSH
51581: EMPTY
51582: LIST
51583: LIST
51584: PUSH
51585: LD_INT 30
51587: PUSH
51588: LD_INT 7
51590: PUSH
51591: EMPTY
51592: LIST
51593: LIST
51594: PUSH
51595: LD_INT 30
51597: PUSH
51598: LD_INT 8
51600: PUSH
51601: EMPTY
51602: LIST
51603: LIST
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: LIST
51609: LIST
51610: PPUSH
51611: CALL_OW 72
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: ST_TO_ADDR
// for j = 1 to 4 do
51622: LD_ADDR_VAR 0 3
51626: PUSH
51627: DOUBLE
51628: LD_INT 1
51630: DEC
51631: ST_TO_ADDR
51632: LD_INT 4
51634: PUSH
51635: FOR_TO
51636: IFFALSE 51827
// begin if not tmp [ j ] then
51638: LD_VAR 0 4
51642: PUSH
51643: LD_VAR 0 3
51647: ARRAY
51648: NOT
51649: IFFALSE 51653
// continue ;
51651: GO 51635
// for p in tmp [ j ] do
51653: LD_ADDR_VAR 0 5
51657: PUSH
51658: LD_VAR 0 4
51662: PUSH
51663: LD_VAR 0 3
51667: ARRAY
51668: PUSH
51669: FOR_IN
51670: IFFALSE 51823
// begin if not b [ j ] then
51672: LD_VAR 0 6
51676: PUSH
51677: LD_VAR 0 3
51681: ARRAY
51682: NOT
51683: IFFALSE 51687
// break ;
51685: GO 51823
// e := 0 ;
51687: LD_ADDR_VAR 0 7
51691: PUSH
51692: LD_INT 0
51694: ST_TO_ADDR
// for k in b [ j ] do
51695: LD_ADDR_VAR 0 8
51699: PUSH
51700: LD_VAR 0 6
51704: PUSH
51705: LD_VAR 0 3
51709: ARRAY
51710: PUSH
51711: FOR_IN
51712: IFFALSE 51739
// if IsNotFull ( k ) then
51714: LD_VAR 0 8
51718: PPUSH
51719: CALL 10849 0 1
51723: IFFALSE 51737
// begin e := k ;
51725: LD_ADDR_VAR 0 7
51729: PUSH
51730: LD_VAR 0 8
51734: ST_TO_ADDR
// break ;
51735: GO 51739
// end ;
51737: GO 51711
51739: POP
51740: POP
// if e and not UnitGoingToBuilding ( p , e ) then
51741: LD_VAR 0 7
51745: PUSH
51746: LD_VAR 0 5
51750: PPUSH
51751: LD_VAR 0 7
51755: PPUSH
51756: CALL 44014 0 2
51760: NOT
51761: AND
51762: IFFALSE 51821
// begin if IsInUnit ( p ) then
51764: LD_VAR 0 5
51768: PPUSH
51769: CALL_OW 310
51773: IFFALSE 51784
// ComExitBuilding ( p ) ;
51775: LD_VAR 0 5
51779: PPUSH
51780: CALL_OW 122
// ComEnterUnit ( p , e ) ;
51784: LD_VAR 0 5
51788: PPUSH
51789: LD_VAR 0 7
51793: PPUSH
51794: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
51798: LD_VAR 0 5
51802: PPUSH
51803: LD_VAR 0 3
51807: PPUSH
51808: CALL_OW 183
// AddComExitBuilding ( p ) ;
51812: LD_VAR 0 5
51816: PPUSH
51817: CALL_OW 182
// end ; end ;
51821: GO 51669
51823: POP
51824: POP
// end ;
51825: GO 51635
51827: POP
51828: POP
// end ;
51829: GO 51390
51831: POP
51832: POP
// end ;
51833: LD_VAR 0 1
51837: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
51838: LD_INT 0
51840: PPUSH
51841: PPUSH
51842: PPUSH
51843: PPUSH
51844: PPUSH
51845: PPUSH
51846: PPUSH
51847: PPUSH
51848: PPUSH
51849: PPUSH
51850: PPUSH
51851: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
51852: LD_VAR 0 1
51856: NOT
51857: PUSH
51858: LD_EXP 23
51862: PUSH
51863: LD_VAR 0 1
51867: ARRAY
51868: NOT
51869: OR
51870: PUSH
51871: LD_EXP 23
51875: PUSH
51876: LD_VAR 0 1
51880: ARRAY
51881: PPUSH
51882: LD_INT 2
51884: PUSH
51885: LD_INT 30
51887: PUSH
51888: LD_INT 0
51890: PUSH
51891: EMPTY
51892: LIST
51893: LIST
51894: PUSH
51895: LD_INT 30
51897: PUSH
51898: LD_INT 1
51900: PUSH
51901: EMPTY
51902: LIST
51903: LIST
51904: PUSH
51905: EMPTY
51906: LIST
51907: LIST
51908: LIST
51909: PPUSH
51910: CALL_OW 72
51914: NOT
51915: OR
51916: IFFALSE 51920
// exit ;
51918: GO 55423
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51920: LD_ADDR_VAR 0 4
51924: PUSH
51925: LD_EXP 23
51929: PUSH
51930: LD_VAR 0 1
51934: ARRAY
51935: PPUSH
51936: LD_INT 2
51938: PUSH
51939: LD_INT 25
51941: PUSH
51942: LD_INT 1
51944: PUSH
51945: EMPTY
51946: LIST
51947: LIST
51948: PUSH
51949: LD_INT 25
51951: PUSH
51952: LD_INT 2
51954: PUSH
51955: EMPTY
51956: LIST
51957: LIST
51958: PUSH
51959: LD_INT 25
51961: PUSH
51962: LD_INT 3
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: PUSH
51969: LD_INT 25
51971: PUSH
51972: LD_INT 4
51974: PUSH
51975: EMPTY
51976: LIST
51977: LIST
51978: PUSH
51979: LD_INT 25
51981: PUSH
51982: LD_INT 5
51984: PUSH
51985: EMPTY
51986: LIST
51987: LIST
51988: PUSH
51989: LD_INT 25
51991: PUSH
51992: LD_INT 8
51994: PUSH
51995: EMPTY
51996: LIST
51997: LIST
51998: PUSH
51999: LD_INT 25
52001: PUSH
52002: LD_INT 9
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PUSH
52009: EMPTY
52010: LIST
52011: LIST
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: LIST
52017: LIST
52018: PPUSH
52019: CALL_OW 72
52023: ST_TO_ADDR
// if not tmp then
52024: LD_VAR 0 4
52028: NOT
52029: IFFALSE 52033
// exit ;
52031: GO 55423
// for i in tmp do
52033: LD_ADDR_VAR 0 3
52037: PUSH
52038: LD_VAR 0 4
52042: PUSH
52043: FOR_IN
52044: IFFALSE 52075
// if GetTag ( i ) then
52046: LD_VAR 0 3
52050: PPUSH
52051: CALL_OW 110
52055: IFFALSE 52073
// tmp := tmp diff i ;
52057: LD_ADDR_VAR 0 4
52061: PUSH
52062: LD_VAR 0 4
52066: PUSH
52067: LD_VAR 0 3
52071: DIFF
52072: ST_TO_ADDR
52073: GO 52043
52075: POP
52076: POP
// if not tmp then
52077: LD_VAR 0 4
52081: NOT
52082: IFFALSE 52086
// exit ;
52084: GO 55423
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52086: LD_ADDR_VAR 0 5
52090: PUSH
52091: LD_EXP 23
52095: PUSH
52096: LD_VAR 0 1
52100: ARRAY
52101: PPUSH
52102: LD_INT 2
52104: PUSH
52105: LD_INT 25
52107: PUSH
52108: LD_INT 1
52110: PUSH
52111: EMPTY
52112: LIST
52113: LIST
52114: PUSH
52115: LD_INT 25
52117: PUSH
52118: LD_INT 5
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: PUSH
52125: LD_INT 25
52127: PUSH
52128: LD_INT 8
52130: PUSH
52131: EMPTY
52132: LIST
52133: LIST
52134: PUSH
52135: LD_INT 25
52137: PUSH
52138: LD_INT 9
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: PUSH
52145: EMPTY
52146: LIST
52147: LIST
52148: LIST
52149: LIST
52150: LIST
52151: PPUSH
52152: CALL_OW 72
52156: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52157: LD_ADDR_VAR 0 6
52161: PUSH
52162: LD_EXP 23
52166: PUSH
52167: LD_VAR 0 1
52171: ARRAY
52172: PPUSH
52173: LD_INT 25
52175: PUSH
52176: LD_INT 2
52178: PUSH
52179: EMPTY
52180: LIST
52181: LIST
52182: PPUSH
52183: CALL_OW 72
52187: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52188: LD_ADDR_VAR 0 7
52192: PUSH
52193: LD_EXP 23
52197: PUSH
52198: LD_VAR 0 1
52202: ARRAY
52203: PPUSH
52204: LD_INT 25
52206: PUSH
52207: LD_INT 3
52209: PUSH
52210: EMPTY
52211: LIST
52212: LIST
52213: PPUSH
52214: CALL_OW 72
52218: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52219: LD_ADDR_VAR 0 8
52223: PUSH
52224: LD_EXP 23
52228: PUSH
52229: LD_VAR 0 1
52233: ARRAY
52234: PPUSH
52235: LD_INT 25
52237: PUSH
52238: LD_INT 4
52240: PUSH
52241: EMPTY
52242: LIST
52243: LIST
52244: PUSH
52245: LD_INT 24
52247: PUSH
52248: LD_INT 251
52250: PUSH
52251: EMPTY
52252: LIST
52253: LIST
52254: PUSH
52255: EMPTY
52256: LIST
52257: LIST
52258: PPUSH
52259: CALL_OW 72
52263: ST_TO_ADDR
// if mc_scan [ base ] then
52264: LD_EXP 46
52268: PUSH
52269: LD_VAR 0 1
52273: ARRAY
52274: IFFALSE 52735
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52276: LD_ADDR_EXP 65
52280: PUSH
52281: LD_EXP 65
52285: PPUSH
52286: LD_VAR 0 1
52290: PPUSH
52291: LD_INT 4
52293: PPUSH
52294: CALL_OW 1
52298: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52299: LD_ADDR_VAR 0 12
52303: PUSH
52304: LD_EXP 23
52308: PUSH
52309: LD_VAR 0 1
52313: ARRAY
52314: PPUSH
52315: LD_INT 2
52317: PUSH
52318: LD_INT 30
52320: PUSH
52321: LD_INT 4
52323: PUSH
52324: EMPTY
52325: LIST
52326: LIST
52327: PUSH
52328: LD_INT 30
52330: PUSH
52331: LD_INT 5
52333: PUSH
52334: EMPTY
52335: LIST
52336: LIST
52337: PUSH
52338: EMPTY
52339: LIST
52340: LIST
52341: LIST
52342: PPUSH
52343: CALL_OW 72
52347: ST_TO_ADDR
// if not b then
52348: LD_VAR 0 12
52352: NOT
52353: IFFALSE 52357
// exit ;
52355: GO 55423
// p := [ ] ;
52357: LD_ADDR_VAR 0 11
52361: PUSH
52362: EMPTY
52363: ST_TO_ADDR
// if sci >= 2 then
52364: LD_VAR 0 8
52368: PUSH
52369: LD_INT 2
52371: GREATEREQUAL
52372: IFFALSE 52403
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52374: LD_ADDR_VAR 0 8
52378: PUSH
52379: LD_VAR 0 8
52383: PUSH
52384: LD_INT 1
52386: ARRAY
52387: PUSH
52388: LD_VAR 0 8
52392: PUSH
52393: LD_INT 2
52395: ARRAY
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: ST_TO_ADDR
52401: GO 52464
// if sci = 1 then
52403: LD_VAR 0 8
52407: PUSH
52408: LD_INT 1
52410: EQUAL
52411: IFFALSE 52432
// sci := [ sci [ 1 ] ] else
52413: LD_ADDR_VAR 0 8
52417: PUSH
52418: LD_VAR 0 8
52422: PUSH
52423: LD_INT 1
52425: ARRAY
52426: PUSH
52427: EMPTY
52428: LIST
52429: ST_TO_ADDR
52430: GO 52464
// if sci = 0 then
52432: LD_VAR 0 8
52436: PUSH
52437: LD_INT 0
52439: EQUAL
52440: IFFALSE 52464
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52442: LD_ADDR_VAR 0 11
52446: PUSH
52447: LD_VAR 0 4
52451: PPUSH
52452: LD_INT 4
52454: PPUSH
52455: CALL 43877 0 2
52459: PUSH
52460: LD_INT 1
52462: ARRAY
52463: ST_TO_ADDR
// if eng > 4 then
52464: LD_VAR 0 6
52468: PUSH
52469: LD_INT 4
52471: GREATER
52472: IFFALSE 52518
// for i = eng downto 4 do
52474: LD_ADDR_VAR 0 3
52478: PUSH
52479: DOUBLE
52480: LD_VAR 0 6
52484: INC
52485: ST_TO_ADDR
52486: LD_INT 4
52488: PUSH
52489: FOR_DOWNTO
52490: IFFALSE 52516
// eng := eng diff eng [ i ] ;
52492: LD_ADDR_VAR 0 6
52496: PUSH
52497: LD_VAR 0 6
52501: PUSH
52502: LD_VAR 0 6
52506: PUSH
52507: LD_VAR 0 3
52511: ARRAY
52512: DIFF
52513: ST_TO_ADDR
52514: GO 52489
52516: POP
52517: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
52518: LD_ADDR_VAR 0 4
52522: PUSH
52523: LD_VAR 0 4
52527: PUSH
52528: LD_VAR 0 5
52532: PUSH
52533: LD_VAR 0 6
52537: UNION
52538: PUSH
52539: LD_VAR 0 7
52543: UNION
52544: PUSH
52545: LD_VAR 0 8
52549: UNION
52550: DIFF
52551: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
52552: LD_ADDR_VAR 0 13
52556: PUSH
52557: LD_EXP 23
52561: PUSH
52562: LD_VAR 0 1
52566: ARRAY
52567: PPUSH
52568: LD_INT 2
52570: PUSH
52571: LD_INT 30
52573: PUSH
52574: LD_INT 32
52576: PUSH
52577: EMPTY
52578: LIST
52579: LIST
52580: PUSH
52581: LD_INT 30
52583: PUSH
52584: LD_INT 31
52586: PUSH
52587: EMPTY
52588: LIST
52589: LIST
52590: PUSH
52591: EMPTY
52592: LIST
52593: LIST
52594: LIST
52595: PPUSH
52596: CALL_OW 72
52600: PUSH
52601: LD_EXP 23
52605: PUSH
52606: LD_VAR 0 1
52610: ARRAY
52611: PPUSH
52612: LD_INT 2
52614: PUSH
52615: LD_INT 30
52617: PUSH
52618: LD_INT 4
52620: PUSH
52621: EMPTY
52622: LIST
52623: LIST
52624: PUSH
52625: LD_INT 30
52627: PUSH
52628: LD_INT 5
52630: PUSH
52631: EMPTY
52632: LIST
52633: LIST
52634: PUSH
52635: EMPTY
52636: LIST
52637: LIST
52638: LIST
52639: PPUSH
52640: CALL_OW 72
52644: PUSH
52645: LD_INT 6
52647: MUL
52648: PLUS
52649: ST_TO_ADDR
// if bcount < tmp then
52650: LD_VAR 0 13
52654: PUSH
52655: LD_VAR 0 4
52659: LESS
52660: IFFALSE 52706
// for i = tmp downto bcount do
52662: LD_ADDR_VAR 0 3
52666: PUSH
52667: DOUBLE
52668: LD_VAR 0 4
52672: INC
52673: ST_TO_ADDR
52674: LD_VAR 0 13
52678: PUSH
52679: FOR_DOWNTO
52680: IFFALSE 52704
// tmp := Delete ( tmp , tmp ) ;
52682: LD_ADDR_VAR 0 4
52686: PUSH
52687: LD_VAR 0 4
52691: PPUSH
52692: LD_VAR 0 4
52696: PPUSH
52697: CALL_OW 3
52701: ST_TO_ADDR
52702: GO 52679
52704: POP
52705: POP
// result := [ tmp , 0 , 0 , p ] ;
52706: LD_ADDR_VAR 0 2
52710: PUSH
52711: LD_VAR 0 4
52715: PUSH
52716: LD_INT 0
52718: PUSH
52719: LD_INT 0
52721: PUSH
52722: LD_VAR 0 11
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: LIST
52731: LIST
52732: ST_TO_ADDR
// exit ;
52733: GO 55423
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52735: LD_EXP 23
52739: PUSH
52740: LD_VAR 0 1
52744: ARRAY
52745: PPUSH
52746: LD_INT 2
52748: PUSH
52749: LD_INT 30
52751: PUSH
52752: LD_INT 6
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PUSH
52759: LD_INT 30
52761: PUSH
52762: LD_INT 7
52764: PUSH
52765: EMPTY
52766: LIST
52767: LIST
52768: PUSH
52769: LD_INT 30
52771: PUSH
52772: LD_INT 8
52774: PUSH
52775: EMPTY
52776: LIST
52777: LIST
52778: PUSH
52779: EMPTY
52780: LIST
52781: LIST
52782: LIST
52783: LIST
52784: PPUSH
52785: CALL_OW 72
52789: NOT
52790: PUSH
52791: LD_EXP 23
52795: PUSH
52796: LD_VAR 0 1
52800: ARRAY
52801: PPUSH
52802: LD_INT 30
52804: PUSH
52805: LD_INT 3
52807: PUSH
52808: EMPTY
52809: LIST
52810: LIST
52811: PPUSH
52812: CALL_OW 72
52816: NOT
52817: AND
52818: IFFALSE 52890
// begin if eng = tmp then
52820: LD_VAR 0 6
52824: PUSH
52825: LD_VAR 0 4
52829: EQUAL
52830: IFFALSE 52834
// exit ;
52832: GO 55423
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
52834: LD_ADDR_EXP 65
52838: PUSH
52839: LD_EXP 65
52843: PPUSH
52844: LD_VAR 0 1
52848: PPUSH
52849: LD_INT 1
52851: PPUSH
52852: CALL_OW 1
52856: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
52857: LD_ADDR_VAR 0 2
52861: PUSH
52862: LD_INT 0
52864: PUSH
52865: LD_VAR 0 4
52869: PUSH
52870: LD_VAR 0 6
52874: DIFF
52875: PUSH
52876: LD_INT 0
52878: PUSH
52879: LD_INT 0
52881: PUSH
52882: EMPTY
52883: LIST
52884: LIST
52885: LIST
52886: LIST
52887: ST_TO_ADDR
// exit ;
52888: GO 55423
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
52890: LD_EXP 50
52894: PUSH
52895: LD_EXP 49
52899: PUSH
52900: LD_VAR 0 1
52904: ARRAY
52905: ARRAY
52906: PUSH
52907: LD_EXP 23
52911: PUSH
52912: LD_VAR 0 1
52916: ARRAY
52917: PPUSH
52918: LD_INT 2
52920: PUSH
52921: LD_INT 30
52923: PUSH
52924: LD_INT 6
52926: PUSH
52927: EMPTY
52928: LIST
52929: LIST
52930: PUSH
52931: LD_INT 30
52933: PUSH
52934: LD_INT 7
52936: PUSH
52937: EMPTY
52938: LIST
52939: LIST
52940: PUSH
52941: LD_INT 30
52943: PUSH
52944: LD_INT 8
52946: PUSH
52947: EMPTY
52948: LIST
52949: LIST
52950: PUSH
52951: EMPTY
52952: LIST
52953: LIST
52954: LIST
52955: LIST
52956: PPUSH
52957: CALL_OW 72
52961: AND
52962: PUSH
52963: LD_EXP 23
52967: PUSH
52968: LD_VAR 0 1
52972: ARRAY
52973: PPUSH
52974: LD_INT 30
52976: PUSH
52977: LD_INT 3
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: PPUSH
52984: CALL_OW 72
52988: NOT
52989: AND
52990: IFFALSE 53204
// begin if sci >= 6 then
52992: LD_VAR 0 8
52996: PUSH
52997: LD_INT 6
52999: GREATEREQUAL
53000: IFFALSE 53004
// exit ;
53002: GO 55423
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
53004: LD_ADDR_EXP 65
53008: PUSH
53009: LD_EXP 65
53013: PPUSH
53014: LD_VAR 0 1
53018: PPUSH
53019: LD_INT 2
53021: PPUSH
53022: CALL_OW 1
53026: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
53027: LD_ADDR_VAR 0 9
53031: PUSH
53032: LD_VAR 0 4
53036: PUSH
53037: LD_VAR 0 8
53041: DIFF
53042: PPUSH
53043: LD_INT 4
53045: PPUSH
53046: CALL 43877 0 2
53050: ST_TO_ADDR
// p := [ ] ;
53051: LD_ADDR_VAR 0 11
53055: PUSH
53056: EMPTY
53057: ST_TO_ADDR
// if sci < 6 and sort > 6 then
53058: LD_VAR 0 8
53062: PUSH
53063: LD_INT 6
53065: LESS
53066: PUSH
53067: LD_VAR 0 9
53071: PUSH
53072: LD_INT 6
53074: GREATER
53075: AND
53076: IFFALSE 53157
// begin for i = 1 to 6 - sci do
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: DOUBLE
53084: LD_INT 1
53086: DEC
53087: ST_TO_ADDR
53088: LD_INT 6
53090: PUSH
53091: LD_VAR 0 8
53095: MINUS
53096: PUSH
53097: FOR_TO
53098: IFFALSE 53153
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
53100: LD_ADDR_VAR 0 11
53104: PUSH
53105: LD_VAR 0 11
53109: PPUSH
53110: LD_VAR 0 11
53114: PUSH
53115: LD_INT 1
53117: PLUS
53118: PPUSH
53119: LD_VAR 0 9
53123: PUSH
53124: LD_INT 1
53126: ARRAY
53127: PPUSH
53128: CALL_OW 2
53132: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53133: LD_ADDR_VAR 0 9
53137: PUSH
53138: LD_VAR 0 9
53142: PPUSH
53143: LD_INT 1
53145: PPUSH
53146: CALL_OW 3
53150: ST_TO_ADDR
// end ;
53151: GO 53097
53153: POP
53154: POP
// end else
53155: GO 53177
// if sort then
53157: LD_VAR 0 9
53161: IFFALSE 53177
// p := sort [ 1 ] ;
53163: LD_ADDR_VAR 0 11
53167: PUSH
53168: LD_VAR 0 9
53172: PUSH
53173: LD_INT 1
53175: ARRAY
53176: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53177: LD_ADDR_VAR 0 2
53181: PUSH
53182: LD_INT 0
53184: PUSH
53185: LD_INT 0
53187: PUSH
53188: LD_INT 0
53190: PUSH
53191: LD_VAR 0 11
53195: PUSH
53196: EMPTY
53197: LIST
53198: LIST
53199: LIST
53200: LIST
53201: ST_TO_ADDR
// exit ;
53202: GO 55423
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53204: LD_EXP 50
53208: PUSH
53209: LD_EXP 49
53213: PUSH
53214: LD_VAR 0 1
53218: ARRAY
53219: ARRAY
53220: PUSH
53221: LD_EXP 23
53225: PUSH
53226: LD_VAR 0 1
53230: ARRAY
53231: PPUSH
53232: LD_INT 2
53234: PUSH
53235: LD_INT 30
53237: PUSH
53238: LD_INT 6
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: PUSH
53245: LD_INT 30
53247: PUSH
53248: LD_INT 7
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: LD_INT 30
53257: PUSH
53258: LD_INT 8
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: PUSH
53265: EMPTY
53266: LIST
53267: LIST
53268: LIST
53269: LIST
53270: PPUSH
53271: CALL_OW 72
53275: AND
53276: PUSH
53277: LD_EXP 23
53281: PUSH
53282: LD_VAR 0 1
53286: ARRAY
53287: PPUSH
53288: LD_INT 30
53290: PUSH
53291: LD_INT 3
53293: PUSH
53294: EMPTY
53295: LIST
53296: LIST
53297: PPUSH
53298: CALL_OW 72
53302: AND
53303: IFFALSE 54037
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53305: LD_ADDR_EXP 65
53309: PUSH
53310: LD_EXP 65
53314: PPUSH
53315: LD_VAR 0 1
53319: PPUSH
53320: LD_INT 3
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53328: LD_ADDR_VAR 0 2
53332: PUSH
53333: LD_INT 0
53335: PUSH
53336: LD_INT 0
53338: PUSH
53339: LD_INT 0
53341: PUSH
53342: LD_INT 0
53344: PUSH
53345: EMPTY
53346: LIST
53347: LIST
53348: LIST
53349: LIST
53350: ST_TO_ADDR
// if not eng then
53351: LD_VAR 0 6
53355: NOT
53356: IFFALSE 53419
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53358: LD_ADDR_VAR 0 11
53362: PUSH
53363: LD_VAR 0 4
53367: PPUSH
53368: LD_INT 2
53370: PPUSH
53371: CALL 43877 0 2
53375: PUSH
53376: LD_INT 1
53378: ARRAY
53379: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53380: LD_ADDR_VAR 0 2
53384: PUSH
53385: LD_VAR 0 2
53389: PPUSH
53390: LD_INT 2
53392: PPUSH
53393: LD_VAR 0 11
53397: PPUSH
53398: CALL_OW 1
53402: ST_TO_ADDR
// tmp := tmp diff p ;
53403: LD_ADDR_VAR 0 4
53407: PUSH
53408: LD_VAR 0 4
53412: PUSH
53413: LD_VAR 0 11
53417: DIFF
53418: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53419: LD_VAR 0 4
53423: PUSH
53424: LD_VAR 0 8
53428: PUSH
53429: LD_INT 6
53431: LESS
53432: AND
53433: IFFALSE 53621
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53435: LD_ADDR_VAR 0 9
53439: PUSH
53440: LD_VAR 0 4
53444: PUSH
53445: LD_VAR 0 8
53449: PUSH
53450: LD_VAR 0 7
53454: UNION
53455: DIFF
53456: PPUSH
53457: LD_INT 4
53459: PPUSH
53460: CALL 43877 0 2
53464: ST_TO_ADDR
// p := [ ] ;
53465: LD_ADDR_VAR 0 11
53469: PUSH
53470: EMPTY
53471: ST_TO_ADDR
// if sort then
53472: LD_VAR 0 9
53476: IFFALSE 53592
// for i = 1 to 6 - sci do
53478: LD_ADDR_VAR 0 3
53482: PUSH
53483: DOUBLE
53484: LD_INT 1
53486: DEC
53487: ST_TO_ADDR
53488: LD_INT 6
53490: PUSH
53491: LD_VAR 0 8
53495: MINUS
53496: PUSH
53497: FOR_TO
53498: IFFALSE 53590
// begin if i = sort then
53500: LD_VAR 0 3
53504: PUSH
53505: LD_VAR 0 9
53509: EQUAL
53510: IFFALSE 53514
// break ;
53512: GO 53590
// if GetClass ( i ) = 4 then
53514: LD_VAR 0 3
53518: PPUSH
53519: CALL_OW 257
53523: PUSH
53524: LD_INT 4
53526: EQUAL
53527: IFFALSE 53531
// continue ;
53529: GO 53497
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53531: LD_ADDR_VAR 0 11
53535: PUSH
53536: LD_VAR 0 11
53540: PPUSH
53541: LD_VAR 0 11
53545: PUSH
53546: LD_INT 1
53548: PLUS
53549: PPUSH
53550: LD_VAR 0 9
53554: PUSH
53555: LD_VAR 0 3
53559: ARRAY
53560: PPUSH
53561: CALL_OW 2
53565: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53566: LD_ADDR_VAR 0 4
53570: PUSH
53571: LD_VAR 0 4
53575: PUSH
53576: LD_VAR 0 9
53580: PUSH
53581: LD_VAR 0 3
53585: ARRAY
53586: DIFF
53587: ST_TO_ADDR
// end ;
53588: GO 53497
53590: POP
53591: POP
// if p then
53592: LD_VAR 0 11
53596: IFFALSE 53621
// result := Replace ( result , 4 , p ) ;
53598: LD_ADDR_VAR 0 2
53602: PUSH
53603: LD_VAR 0 2
53607: PPUSH
53608: LD_INT 4
53610: PPUSH
53611: LD_VAR 0 11
53615: PPUSH
53616: CALL_OW 1
53620: ST_TO_ADDR
// end ; if tmp and mech < 6 then
53621: LD_VAR 0 4
53625: PUSH
53626: LD_VAR 0 7
53630: PUSH
53631: LD_INT 6
53633: LESS
53634: AND
53635: IFFALSE 53823
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
53637: LD_ADDR_VAR 0 9
53641: PUSH
53642: LD_VAR 0 4
53646: PUSH
53647: LD_VAR 0 8
53651: PUSH
53652: LD_VAR 0 7
53656: UNION
53657: DIFF
53658: PPUSH
53659: LD_INT 3
53661: PPUSH
53662: CALL 43877 0 2
53666: ST_TO_ADDR
// p := [ ] ;
53667: LD_ADDR_VAR 0 11
53671: PUSH
53672: EMPTY
53673: ST_TO_ADDR
// if sort then
53674: LD_VAR 0 9
53678: IFFALSE 53794
// for i = 1 to 6 - mech do
53680: LD_ADDR_VAR 0 3
53684: PUSH
53685: DOUBLE
53686: LD_INT 1
53688: DEC
53689: ST_TO_ADDR
53690: LD_INT 6
53692: PUSH
53693: LD_VAR 0 7
53697: MINUS
53698: PUSH
53699: FOR_TO
53700: IFFALSE 53792
// begin if i = sort then
53702: LD_VAR 0 3
53706: PUSH
53707: LD_VAR 0 9
53711: EQUAL
53712: IFFALSE 53716
// break ;
53714: GO 53792
// if GetClass ( i ) = 3 then
53716: LD_VAR 0 3
53720: PPUSH
53721: CALL_OW 257
53725: PUSH
53726: LD_INT 3
53728: EQUAL
53729: IFFALSE 53733
// continue ;
53731: GO 53699
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53733: LD_ADDR_VAR 0 11
53737: PUSH
53738: LD_VAR 0 11
53742: PPUSH
53743: LD_VAR 0 11
53747: PUSH
53748: LD_INT 1
53750: PLUS
53751: PPUSH
53752: LD_VAR 0 9
53756: PUSH
53757: LD_VAR 0 3
53761: ARRAY
53762: PPUSH
53763: CALL_OW 2
53767: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53768: LD_ADDR_VAR 0 4
53772: PUSH
53773: LD_VAR 0 4
53777: PUSH
53778: LD_VAR 0 9
53782: PUSH
53783: LD_VAR 0 3
53787: ARRAY
53788: DIFF
53789: ST_TO_ADDR
// end ;
53790: GO 53699
53792: POP
53793: POP
// if p then
53794: LD_VAR 0 11
53798: IFFALSE 53823
// result := Replace ( result , 3 , p ) ;
53800: LD_ADDR_VAR 0 2
53804: PUSH
53805: LD_VAR 0 2
53809: PPUSH
53810: LD_INT 3
53812: PPUSH
53813: LD_VAR 0 11
53817: PPUSH
53818: CALL_OW 1
53822: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
53823: LD_VAR 0 4
53827: PUSH
53828: LD_INT 6
53830: GREATER
53831: PUSH
53832: LD_VAR 0 6
53836: PUSH
53837: LD_INT 6
53839: LESS
53840: AND
53841: IFFALSE 54035
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
53843: LD_ADDR_VAR 0 9
53847: PUSH
53848: LD_VAR 0 4
53852: PUSH
53853: LD_VAR 0 8
53857: PUSH
53858: LD_VAR 0 7
53862: UNION
53863: PUSH
53864: LD_VAR 0 6
53868: UNION
53869: DIFF
53870: PPUSH
53871: LD_INT 2
53873: PPUSH
53874: CALL 43877 0 2
53878: ST_TO_ADDR
// p := [ ] ;
53879: LD_ADDR_VAR 0 11
53883: PUSH
53884: EMPTY
53885: ST_TO_ADDR
// if sort then
53886: LD_VAR 0 9
53890: IFFALSE 54006
// for i = 1 to 6 - eng do
53892: LD_ADDR_VAR 0 3
53896: PUSH
53897: DOUBLE
53898: LD_INT 1
53900: DEC
53901: ST_TO_ADDR
53902: LD_INT 6
53904: PUSH
53905: LD_VAR 0 6
53909: MINUS
53910: PUSH
53911: FOR_TO
53912: IFFALSE 54004
// begin if i = sort then
53914: LD_VAR 0 3
53918: PUSH
53919: LD_VAR 0 9
53923: EQUAL
53924: IFFALSE 53928
// break ;
53926: GO 54004
// if GetClass ( i ) = 2 then
53928: LD_VAR 0 3
53932: PPUSH
53933: CALL_OW 257
53937: PUSH
53938: LD_INT 2
53940: EQUAL
53941: IFFALSE 53945
// continue ;
53943: GO 53911
// p := Insert ( p , p + 1 , sort [ i ] ) ;
53945: LD_ADDR_VAR 0 11
53949: PUSH
53950: LD_VAR 0 11
53954: PPUSH
53955: LD_VAR 0 11
53959: PUSH
53960: LD_INT 1
53962: PLUS
53963: PPUSH
53964: LD_VAR 0 9
53968: PUSH
53969: LD_VAR 0 3
53973: ARRAY
53974: PPUSH
53975: CALL_OW 2
53979: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
53980: LD_ADDR_VAR 0 4
53984: PUSH
53985: LD_VAR 0 4
53989: PUSH
53990: LD_VAR 0 9
53994: PUSH
53995: LD_VAR 0 3
53999: ARRAY
54000: DIFF
54001: ST_TO_ADDR
// end ;
54002: GO 53911
54004: POP
54005: POP
// if p then
54006: LD_VAR 0 11
54010: IFFALSE 54035
// result := Replace ( result , 2 , p ) ;
54012: LD_ADDR_VAR 0 2
54016: PUSH
54017: LD_VAR 0 2
54021: PPUSH
54022: LD_INT 2
54024: PPUSH
54025: LD_VAR 0 11
54029: PPUSH
54030: CALL_OW 1
54034: ST_TO_ADDR
// end ; exit ;
54035: GO 55423
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
54037: LD_EXP 50
54041: PUSH
54042: LD_EXP 49
54046: PUSH
54047: LD_VAR 0 1
54051: ARRAY
54052: ARRAY
54053: NOT
54054: PUSH
54055: LD_EXP 23
54059: PUSH
54060: LD_VAR 0 1
54064: ARRAY
54065: PPUSH
54066: LD_INT 30
54068: PUSH
54069: LD_INT 3
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: PPUSH
54076: CALL_OW 72
54080: AND
54081: PUSH
54082: LD_EXP 28
54086: PUSH
54087: LD_VAR 0 1
54091: ARRAY
54092: AND
54093: IFFALSE 54701
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
54095: LD_ADDR_EXP 65
54099: PUSH
54100: LD_EXP 65
54104: PPUSH
54105: LD_VAR 0 1
54109: PPUSH
54110: LD_INT 5
54112: PPUSH
54113: CALL_OW 1
54117: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54118: LD_ADDR_VAR 0 2
54122: PUSH
54123: LD_INT 0
54125: PUSH
54126: LD_INT 0
54128: PUSH
54129: LD_INT 0
54131: PUSH
54132: LD_INT 0
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: LIST
54139: LIST
54140: ST_TO_ADDR
// if sci > 1 then
54141: LD_VAR 0 8
54145: PUSH
54146: LD_INT 1
54148: GREATER
54149: IFFALSE 54177
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54151: LD_ADDR_VAR 0 4
54155: PUSH
54156: LD_VAR 0 4
54160: PUSH
54161: LD_VAR 0 8
54165: PUSH
54166: LD_VAR 0 8
54170: PUSH
54171: LD_INT 1
54173: ARRAY
54174: DIFF
54175: DIFF
54176: ST_TO_ADDR
// if tmp and not sci then
54177: LD_VAR 0 4
54181: PUSH
54182: LD_VAR 0 8
54186: NOT
54187: AND
54188: IFFALSE 54257
// begin sort := SortBySkill ( tmp , 4 ) ;
54190: LD_ADDR_VAR 0 9
54194: PUSH
54195: LD_VAR 0 4
54199: PPUSH
54200: LD_INT 4
54202: PPUSH
54203: CALL 43877 0 2
54207: ST_TO_ADDR
// if sort then
54208: LD_VAR 0 9
54212: IFFALSE 54228
// p := sort [ 1 ] ;
54214: LD_ADDR_VAR 0 11
54218: PUSH
54219: LD_VAR 0 9
54223: PUSH
54224: LD_INT 1
54226: ARRAY
54227: ST_TO_ADDR
// if p then
54228: LD_VAR 0 11
54232: IFFALSE 54257
// result := Replace ( result , 4 , p ) ;
54234: LD_ADDR_VAR 0 2
54238: PUSH
54239: LD_VAR 0 2
54243: PPUSH
54244: LD_INT 4
54246: PPUSH
54247: LD_VAR 0 11
54251: PPUSH
54252: CALL_OW 1
54256: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54257: LD_ADDR_VAR 0 4
54261: PUSH
54262: LD_VAR 0 4
54266: PUSH
54267: LD_VAR 0 7
54271: DIFF
54272: ST_TO_ADDR
// if tmp and mech < 6 then
54273: LD_VAR 0 4
54277: PUSH
54278: LD_VAR 0 7
54282: PUSH
54283: LD_INT 6
54285: LESS
54286: AND
54287: IFFALSE 54475
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54289: LD_ADDR_VAR 0 9
54293: PUSH
54294: LD_VAR 0 4
54298: PUSH
54299: LD_VAR 0 8
54303: PUSH
54304: LD_VAR 0 7
54308: UNION
54309: DIFF
54310: PPUSH
54311: LD_INT 3
54313: PPUSH
54314: CALL 43877 0 2
54318: ST_TO_ADDR
// p := [ ] ;
54319: LD_ADDR_VAR 0 11
54323: PUSH
54324: EMPTY
54325: ST_TO_ADDR
// if sort then
54326: LD_VAR 0 9
54330: IFFALSE 54446
// for i = 1 to 6 - mech do
54332: LD_ADDR_VAR 0 3
54336: PUSH
54337: DOUBLE
54338: LD_INT 1
54340: DEC
54341: ST_TO_ADDR
54342: LD_INT 6
54344: PUSH
54345: LD_VAR 0 7
54349: MINUS
54350: PUSH
54351: FOR_TO
54352: IFFALSE 54444
// begin if i = sort then
54354: LD_VAR 0 3
54358: PUSH
54359: LD_VAR 0 9
54363: EQUAL
54364: IFFALSE 54368
// break ;
54366: GO 54444
// if GetClass ( i ) = 3 then
54368: LD_VAR 0 3
54372: PPUSH
54373: CALL_OW 257
54377: PUSH
54378: LD_INT 3
54380: EQUAL
54381: IFFALSE 54385
// continue ;
54383: GO 54351
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54385: LD_ADDR_VAR 0 11
54389: PUSH
54390: LD_VAR 0 11
54394: PPUSH
54395: LD_VAR 0 11
54399: PUSH
54400: LD_INT 1
54402: PLUS
54403: PPUSH
54404: LD_VAR 0 9
54408: PUSH
54409: LD_VAR 0 3
54413: ARRAY
54414: PPUSH
54415: CALL_OW 2
54419: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54420: LD_ADDR_VAR 0 4
54424: PUSH
54425: LD_VAR 0 4
54429: PUSH
54430: LD_VAR 0 9
54434: PUSH
54435: LD_VAR 0 3
54439: ARRAY
54440: DIFF
54441: ST_TO_ADDR
// end ;
54442: GO 54351
54444: POP
54445: POP
// if p then
54446: LD_VAR 0 11
54450: IFFALSE 54475
// result := Replace ( result , 3 , p ) ;
54452: LD_ADDR_VAR 0 2
54456: PUSH
54457: LD_VAR 0 2
54461: PPUSH
54462: LD_INT 3
54464: PPUSH
54465: LD_VAR 0 11
54469: PPUSH
54470: CALL_OW 1
54474: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54475: LD_ADDR_VAR 0 4
54479: PUSH
54480: LD_VAR 0 4
54484: PUSH
54485: LD_VAR 0 6
54489: DIFF
54490: ST_TO_ADDR
// if tmp and eng < 6 then
54491: LD_VAR 0 4
54495: PUSH
54496: LD_VAR 0 6
54500: PUSH
54501: LD_INT 6
54503: LESS
54504: AND
54505: IFFALSE 54699
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54507: LD_ADDR_VAR 0 9
54511: PUSH
54512: LD_VAR 0 4
54516: PUSH
54517: LD_VAR 0 8
54521: PUSH
54522: LD_VAR 0 7
54526: UNION
54527: PUSH
54528: LD_VAR 0 6
54532: UNION
54533: DIFF
54534: PPUSH
54535: LD_INT 2
54537: PPUSH
54538: CALL 43877 0 2
54542: ST_TO_ADDR
// p := [ ] ;
54543: LD_ADDR_VAR 0 11
54547: PUSH
54548: EMPTY
54549: ST_TO_ADDR
// if sort then
54550: LD_VAR 0 9
54554: IFFALSE 54670
// for i = 1 to 6 - eng do
54556: LD_ADDR_VAR 0 3
54560: PUSH
54561: DOUBLE
54562: LD_INT 1
54564: DEC
54565: ST_TO_ADDR
54566: LD_INT 6
54568: PUSH
54569: LD_VAR 0 6
54573: MINUS
54574: PUSH
54575: FOR_TO
54576: IFFALSE 54668
// begin if i = sort then
54578: LD_VAR 0 3
54582: PUSH
54583: LD_VAR 0 9
54587: EQUAL
54588: IFFALSE 54592
// break ;
54590: GO 54668
// if GetClass ( i ) = 2 then
54592: LD_VAR 0 3
54596: PPUSH
54597: CALL_OW 257
54601: PUSH
54602: LD_INT 2
54604: EQUAL
54605: IFFALSE 54609
// continue ;
54607: GO 54575
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54609: LD_ADDR_VAR 0 11
54613: PUSH
54614: LD_VAR 0 11
54618: PPUSH
54619: LD_VAR 0 11
54623: PUSH
54624: LD_INT 1
54626: PLUS
54627: PPUSH
54628: LD_VAR 0 9
54632: PUSH
54633: LD_VAR 0 3
54637: ARRAY
54638: PPUSH
54639: CALL_OW 2
54643: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54644: LD_ADDR_VAR 0 4
54648: PUSH
54649: LD_VAR 0 4
54653: PUSH
54654: LD_VAR 0 9
54658: PUSH
54659: LD_VAR 0 3
54663: ARRAY
54664: DIFF
54665: ST_TO_ADDR
// end ;
54666: GO 54575
54668: POP
54669: POP
// if p then
54670: LD_VAR 0 11
54674: IFFALSE 54699
// result := Replace ( result , 2 , p ) ;
54676: LD_ADDR_VAR 0 2
54680: PUSH
54681: LD_VAR 0 2
54685: PPUSH
54686: LD_INT 2
54688: PPUSH
54689: LD_VAR 0 11
54693: PPUSH
54694: CALL_OW 1
54698: ST_TO_ADDR
// end ; exit ;
54699: GO 55423
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
54701: LD_EXP 50
54705: PUSH
54706: LD_EXP 49
54710: PUSH
54711: LD_VAR 0 1
54715: ARRAY
54716: ARRAY
54717: NOT
54718: PUSH
54719: LD_EXP 23
54723: PUSH
54724: LD_VAR 0 1
54728: ARRAY
54729: PPUSH
54730: LD_INT 30
54732: PUSH
54733: LD_INT 3
54735: PUSH
54736: EMPTY
54737: LIST
54738: LIST
54739: PPUSH
54740: CALL_OW 72
54744: AND
54745: PUSH
54746: LD_EXP 28
54750: PUSH
54751: LD_VAR 0 1
54755: ARRAY
54756: NOT
54757: AND
54758: IFFALSE 55423
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
54760: LD_ADDR_EXP 65
54764: PUSH
54765: LD_EXP 65
54769: PPUSH
54770: LD_VAR 0 1
54774: PPUSH
54775: LD_INT 6
54777: PPUSH
54778: CALL_OW 1
54782: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54783: LD_ADDR_VAR 0 2
54787: PUSH
54788: LD_INT 0
54790: PUSH
54791: LD_INT 0
54793: PUSH
54794: LD_INT 0
54796: PUSH
54797: LD_INT 0
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: LIST
54804: LIST
54805: ST_TO_ADDR
// if sci >= 1 then
54806: LD_VAR 0 8
54810: PUSH
54811: LD_INT 1
54813: GREATEREQUAL
54814: IFFALSE 54836
// tmp := tmp diff sci [ 1 ] ;
54816: LD_ADDR_VAR 0 4
54820: PUSH
54821: LD_VAR 0 4
54825: PUSH
54826: LD_VAR 0 8
54830: PUSH
54831: LD_INT 1
54833: ARRAY
54834: DIFF
54835: ST_TO_ADDR
// if tmp and not sci then
54836: LD_VAR 0 4
54840: PUSH
54841: LD_VAR 0 8
54845: NOT
54846: AND
54847: IFFALSE 54916
// begin sort := SortBySkill ( tmp , 4 ) ;
54849: LD_ADDR_VAR 0 9
54853: PUSH
54854: LD_VAR 0 4
54858: PPUSH
54859: LD_INT 4
54861: PPUSH
54862: CALL 43877 0 2
54866: ST_TO_ADDR
// if sort then
54867: LD_VAR 0 9
54871: IFFALSE 54887
// p := sort [ 1 ] ;
54873: LD_ADDR_VAR 0 11
54877: PUSH
54878: LD_VAR 0 9
54882: PUSH
54883: LD_INT 1
54885: ARRAY
54886: ST_TO_ADDR
// if p then
54887: LD_VAR 0 11
54891: IFFALSE 54916
// result := Replace ( result , 4 , p ) ;
54893: LD_ADDR_VAR 0 2
54897: PUSH
54898: LD_VAR 0 2
54902: PPUSH
54903: LD_INT 4
54905: PPUSH
54906: LD_VAR 0 11
54910: PPUSH
54911: CALL_OW 1
54915: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54916: LD_ADDR_VAR 0 4
54920: PUSH
54921: LD_VAR 0 4
54925: PUSH
54926: LD_VAR 0 7
54930: DIFF
54931: ST_TO_ADDR
// if tmp and mech < 6 then
54932: LD_VAR 0 4
54936: PUSH
54937: LD_VAR 0 7
54941: PUSH
54942: LD_INT 6
54944: LESS
54945: AND
54946: IFFALSE 55128
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
54948: LD_ADDR_VAR 0 9
54952: PUSH
54953: LD_VAR 0 4
54957: PUSH
54958: LD_VAR 0 7
54962: DIFF
54963: PPUSH
54964: LD_INT 3
54966: PPUSH
54967: CALL 43877 0 2
54971: ST_TO_ADDR
// p := [ ] ;
54972: LD_ADDR_VAR 0 11
54976: PUSH
54977: EMPTY
54978: ST_TO_ADDR
// if sort then
54979: LD_VAR 0 9
54983: IFFALSE 55099
// for i = 1 to 6 - mech do
54985: LD_ADDR_VAR 0 3
54989: PUSH
54990: DOUBLE
54991: LD_INT 1
54993: DEC
54994: ST_TO_ADDR
54995: LD_INT 6
54997: PUSH
54998: LD_VAR 0 7
55002: MINUS
55003: PUSH
55004: FOR_TO
55005: IFFALSE 55097
// begin if i = sort then
55007: LD_VAR 0 3
55011: PUSH
55012: LD_VAR 0 9
55016: EQUAL
55017: IFFALSE 55021
// break ;
55019: GO 55097
// if GetClass ( i ) = 3 then
55021: LD_VAR 0 3
55025: PPUSH
55026: CALL_OW 257
55030: PUSH
55031: LD_INT 3
55033: EQUAL
55034: IFFALSE 55038
// continue ;
55036: GO 55004
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55038: LD_ADDR_VAR 0 11
55042: PUSH
55043: LD_VAR 0 11
55047: PPUSH
55048: LD_VAR 0 11
55052: PUSH
55053: LD_INT 1
55055: PLUS
55056: PPUSH
55057: LD_VAR 0 9
55061: PUSH
55062: LD_VAR 0 3
55066: ARRAY
55067: PPUSH
55068: CALL_OW 2
55072: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55073: LD_ADDR_VAR 0 4
55077: PUSH
55078: LD_VAR 0 4
55082: PUSH
55083: LD_VAR 0 9
55087: PUSH
55088: LD_VAR 0 3
55092: ARRAY
55093: DIFF
55094: ST_TO_ADDR
// end ;
55095: GO 55004
55097: POP
55098: POP
// if p then
55099: LD_VAR 0 11
55103: IFFALSE 55128
// result := Replace ( result , 3 , p ) ;
55105: LD_ADDR_VAR 0 2
55109: PUSH
55110: LD_VAR 0 2
55114: PPUSH
55115: LD_INT 3
55117: PPUSH
55118: LD_VAR 0 11
55122: PPUSH
55123: CALL_OW 1
55127: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55128: LD_ADDR_VAR 0 4
55132: PUSH
55133: LD_VAR 0 4
55137: PUSH
55138: LD_VAR 0 6
55142: DIFF
55143: ST_TO_ADDR
// if tmp and eng < 4 then
55144: LD_VAR 0 4
55148: PUSH
55149: LD_VAR 0 6
55153: PUSH
55154: LD_INT 4
55156: LESS
55157: AND
55158: IFFALSE 55348
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55160: LD_ADDR_VAR 0 9
55164: PUSH
55165: LD_VAR 0 4
55169: PUSH
55170: LD_VAR 0 7
55174: PUSH
55175: LD_VAR 0 6
55179: UNION
55180: DIFF
55181: PPUSH
55182: LD_INT 2
55184: PPUSH
55185: CALL 43877 0 2
55189: ST_TO_ADDR
// p := [ ] ;
55190: LD_ADDR_VAR 0 11
55194: PUSH
55195: EMPTY
55196: ST_TO_ADDR
// if sort then
55197: LD_VAR 0 9
55201: IFFALSE 55317
// for i = 1 to 4 - eng do
55203: LD_ADDR_VAR 0 3
55207: PUSH
55208: DOUBLE
55209: LD_INT 1
55211: DEC
55212: ST_TO_ADDR
55213: LD_INT 4
55215: PUSH
55216: LD_VAR 0 6
55220: MINUS
55221: PUSH
55222: FOR_TO
55223: IFFALSE 55315
// begin if i = sort then
55225: LD_VAR 0 3
55229: PUSH
55230: LD_VAR 0 9
55234: EQUAL
55235: IFFALSE 55239
// break ;
55237: GO 55315
// if GetClass ( i ) = 2 then
55239: LD_VAR 0 3
55243: PPUSH
55244: CALL_OW 257
55248: PUSH
55249: LD_INT 2
55251: EQUAL
55252: IFFALSE 55256
// continue ;
55254: GO 55222
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55256: LD_ADDR_VAR 0 11
55260: PUSH
55261: LD_VAR 0 11
55265: PPUSH
55266: LD_VAR 0 11
55270: PUSH
55271: LD_INT 1
55273: PLUS
55274: PPUSH
55275: LD_VAR 0 9
55279: PUSH
55280: LD_VAR 0 3
55284: ARRAY
55285: PPUSH
55286: CALL_OW 2
55290: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55291: LD_ADDR_VAR 0 4
55295: PUSH
55296: LD_VAR 0 4
55300: PUSH
55301: LD_VAR 0 9
55305: PUSH
55306: LD_VAR 0 3
55310: ARRAY
55311: DIFF
55312: ST_TO_ADDR
// end ;
55313: GO 55222
55315: POP
55316: POP
// if p then
55317: LD_VAR 0 11
55321: IFFALSE 55346
// result := Replace ( result , 2 , p ) ;
55323: LD_ADDR_VAR 0 2
55327: PUSH
55328: LD_VAR 0 2
55332: PPUSH
55333: LD_INT 2
55335: PPUSH
55336: LD_VAR 0 11
55340: PPUSH
55341: CALL_OW 1
55345: ST_TO_ADDR
// end else
55346: GO 55392
// for i = eng downto 5 do
55348: LD_ADDR_VAR 0 3
55352: PUSH
55353: DOUBLE
55354: LD_VAR 0 6
55358: INC
55359: ST_TO_ADDR
55360: LD_INT 5
55362: PUSH
55363: FOR_DOWNTO
55364: IFFALSE 55390
// tmp := tmp union eng [ i ] ;
55366: LD_ADDR_VAR 0 4
55370: PUSH
55371: LD_VAR 0 4
55375: PUSH
55376: LD_VAR 0 6
55380: PUSH
55381: LD_VAR 0 3
55385: ARRAY
55386: UNION
55387: ST_TO_ADDR
55388: GO 55363
55390: POP
55391: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55392: LD_ADDR_VAR 0 2
55396: PUSH
55397: LD_VAR 0 2
55401: PPUSH
55402: LD_INT 1
55404: PPUSH
55405: LD_VAR 0 4
55409: PUSH
55410: LD_VAR 0 5
55414: DIFF
55415: PPUSH
55416: CALL_OW 1
55420: ST_TO_ADDR
// exit ;
55421: GO 55423
// end ; end ;
55423: LD_VAR 0 2
55427: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55428: LD_INT 0
55430: PPUSH
55431: PPUSH
55432: PPUSH
// if not mc_bases then
55433: LD_EXP 23
55437: NOT
55438: IFFALSE 55442
// exit ;
55440: GO 55548
// for i = 1 to mc_bases do
55442: LD_ADDR_VAR 0 2
55446: PUSH
55447: DOUBLE
55448: LD_INT 1
55450: DEC
55451: ST_TO_ADDR
55452: LD_EXP 23
55456: PUSH
55457: FOR_TO
55458: IFFALSE 55539
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55460: LD_ADDR_VAR 0 3
55464: PUSH
55465: LD_EXP 23
55469: PUSH
55470: LD_VAR 0 2
55474: ARRAY
55475: PPUSH
55476: LD_INT 21
55478: PUSH
55479: LD_INT 3
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: PUSH
55486: LD_INT 3
55488: PUSH
55489: LD_INT 24
55491: PUSH
55492: LD_INT 1000
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: PUSH
55503: EMPTY
55504: LIST
55505: LIST
55506: PPUSH
55507: CALL_OW 72
55511: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
55512: LD_ADDR_EXP 24
55516: PUSH
55517: LD_EXP 24
55521: PPUSH
55522: LD_VAR 0 2
55526: PPUSH
55527: LD_VAR 0 3
55531: PPUSH
55532: CALL_OW 1
55536: ST_TO_ADDR
// end ;
55537: GO 55457
55539: POP
55540: POP
// RaiseSailEvent ( 101 ) ;
55541: LD_INT 101
55543: PPUSH
55544: CALL_OW 427
// end ;
55548: LD_VAR 0 1
55552: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
55553: LD_INT 0
55555: PPUSH
55556: PPUSH
55557: PPUSH
55558: PPUSH
55559: PPUSH
55560: PPUSH
55561: PPUSH
// if not mc_bases then
55562: LD_EXP 23
55566: NOT
55567: IFFALSE 55571
// exit ;
55569: GO 56133
// for i = 1 to mc_bases do
55571: LD_ADDR_VAR 0 2
55575: PUSH
55576: DOUBLE
55577: LD_INT 1
55579: DEC
55580: ST_TO_ADDR
55581: LD_EXP 23
55585: PUSH
55586: FOR_TO
55587: IFFALSE 56124
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
55589: LD_ADDR_VAR 0 5
55593: PUSH
55594: LD_EXP 23
55598: PUSH
55599: LD_VAR 0 2
55603: ARRAY
55604: PUSH
55605: LD_EXP 52
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: UNION
55616: PPUSH
55617: LD_INT 21
55619: PUSH
55620: LD_INT 1
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PUSH
55627: LD_INT 1
55629: PUSH
55630: LD_INT 3
55632: PUSH
55633: LD_INT 54
55635: PUSH
55636: EMPTY
55637: LIST
55638: PUSH
55639: EMPTY
55640: LIST
55641: LIST
55642: PUSH
55643: LD_INT 3
55645: PUSH
55646: LD_INT 24
55648: PUSH
55649: LD_INT 1000
55651: PUSH
55652: EMPTY
55653: LIST
55654: LIST
55655: PUSH
55656: EMPTY
55657: LIST
55658: LIST
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: LIST
55664: PUSH
55665: EMPTY
55666: LIST
55667: LIST
55668: PPUSH
55669: CALL_OW 72
55673: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
55674: LD_ADDR_VAR 0 6
55678: PUSH
55679: LD_EXP 23
55683: PUSH
55684: LD_VAR 0 2
55688: ARRAY
55689: PPUSH
55690: LD_INT 21
55692: PUSH
55693: LD_INT 1
55695: PUSH
55696: EMPTY
55697: LIST
55698: LIST
55699: PUSH
55700: LD_INT 1
55702: PUSH
55703: LD_INT 3
55705: PUSH
55706: LD_INT 54
55708: PUSH
55709: EMPTY
55710: LIST
55711: PUSH
55712: EMPTY
55713: LIST
55714: LIST
55715: PUSH
55716: LD_INT 3
55718: PUSH
55719: LD_INT 24
55721: PUSH
55722: LD_INT 250
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: PUSH
55733: EMPTY
55734: LIST
55735: LIST
55736: LIST
55737: PUSH
55738: EMPTY
55739: LIST
55740: LIST
55741: PPUSH
55742: CALL_OW 72
55746: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
55747: LD_ADDR_VAR 0 7
55751: PUSH
55752: LD_VAR 0 5
55756: PUSH
55757: LD_VAR 0 6
55761: DIFF
55762: ST_TO_ADDR
// if not need_heal_1 then
55763: LD_VAR 0 6
55767: NOT
55768: IFFALSE 55801
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
55770: LD_ADDR_EXP 26
55774: PUSH
55775: LD_EXP 26
55779: PPUSH
55780: LD_VAR 0 2
55784: PUSH
55785: LD_INT 1
55787: PUSH
55788: EMPTY
55789: LIST
55790: LIST
55791: PPUSH
55792: EMPTY
55793: PPUSH
55794: CALL 13619 0 3
55798: ST_TO_ADDR
55799: GO 55871
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
55801: LD_ADDR_EXP 26
55805: PUSH
55806: LD_EXP 26
55810: PPUSH
55811: LD_VAR 0 2
55815: PUSH
55816: LD_INT 1
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PPUSH
55823: LD_EXP 26
55827: PUSH
55828: LD_VAR 0 2
55832: ARRAY
55833: PUSH
55834: LD_INT 1
55836: ARRAY
55837: PPUSH
55838: LD_INT 3
55840: PUSH
55841: LD_INT 24
55843: PUSH
55844: LD_INT 1000
55846: PUSH
55847: EMPTY
55848: LIST
55849: LIST
55850: PUSH
55851: EMPTY
55852: LIST
55853: LIST
55854: PPUSH
55855: CALL_OW 72
55859: PUSH
55860: LD_VAR 0 6
55864: UNION
55865: PPUSH
55866: CALL 13619 0 3
55870: ST_TO_ADDR
// if not need_heal_2 then
55871: LD_VAR 0 7
55875: NOT
55876: IFFALSE 55909
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
55878: LD_ADDR_EXP 26
55882: PUSH
55883: LD_EXP 26
55887: PPUSH
55888: LD_VAR 0 2
55892: PUSH
55893: LD_INT 2
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: PPUSH
55900: EMPTY
55901: PPUSH
55902: CALL 13619 0 3
55906: ST_TO_ADDR
55907: GO 55941
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
55909: LD_ADDR_EXP 26
55913: PUSH
55914: LD_EXP 26
55918: PPUSH
55919: LD_VAR 0 2
55923: PUSH
55924: LD_INT 2
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: PPUSH
55931: LD_VAR 0 7
55935: PPUSH
55936: CALL 13619 0 3
55940: ST_TO_ADDR
// if need_heal_2 then
55941: LD_VAR 0 7
55945: IFFALSE 56106
// for j in need_heal_2 do
55947: LD_ADDR_VAR 0 3
55951: PUSH
55952: LD_VAR 0 7
55956: PUSH
55957: FOR_IN
55958: IFFALSE 56104
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
55960: LD_ADDR_VAR 0 5
55964: PUSH
55965: LD_EXP 23
55969: PUSH
55970: LD_VAR 0 2
55974: ARRAY
55975: PPUSH
55976: LD_INT 2
55978: PUSH
55979: LD_INT 30
55981: PUSH
55982: LD_INT 6
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: PUSH
55989: LD_INT 30
55991: PUSH
55992: LD_INT 7
55994: PUSH
55995: EMPTY
55996: LIST
55997: LIST
55998: PUSH
55999: LD_INT 30
56001: PUSH
56002: LD_INT 8
56004: PUSH
56005: EMPTY
56006: LIST
56007: LIST
56008: PUSH
56009: LD_INT 30
56011: PUSH
56012: LD_INT 0
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: PUSH
56019: LD_INT 30
56021: PUSH
56022: LD_INT 1
56024: PUSH
56025: EMPTY
56026: LIST
56027: LIST
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: LIST
56033: LIST
56034: LIST
56035: LIST
56036: PPUSH
56037: CALL_OW 72
56041: ST_TO_ADDR
// if tmp then
56042: LD_VAR 0 5
56046: IFFALSE 56102
// begin k := NearestUnitToUnit ( tmp , j ) ;
56048: LD_ADDR_VAR 0 4
56052: PUSH
56053: LD_VAR 0 5
56057: PPUSH
56058: LD_VAR 0 3
56062: PPUSH
56063: CALL_OW 74
56067: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
56068: LD_VAR 0 3
56072: PPUSH
56073: LD_VAR 0 4
56077: PPUSH
56078: CALL_OW 296
56082: PUSH
56083: LD_INT 5
56085: GREATER
56086: IFFALSE 56102
// ComMoveToNearbyEntrance ( j , k ) ;
56088: LD_VAR 0 3
56092: PPUSH
56093: LD_VAR 0 4
56097: PPUSH
56098: CALL 46238 0 2
// end ; end ;
56102: GO 55957
56104: POP
56105: POP
// if not need_heal_1 and not need_heal_2 then
56106: LD_VAR 0 6
56110: NOT
56111: PUSH
56112: LD_VAR 0 7
56116: NOT
56117: AND
56118: IFFALSE 56122
// continue ;
56120: GO 55586
// end ;
56122: GO 55586
56124: POP
56125: POP
// RaiseSailEvent ( 102 ) ;
56126: LD_INT 102
56128: PPUSH
56129: CALL_OW 427
// end ;
56133: LD_VAR 0 1
56137: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56138: LD_INT 0
56140: PPUSH
56141: PPUSH
56142: PPUSH
56143: PPUSH
56144: PPUSH
56145: PPUSH
56146: PPUSH
56147: PPUSH
// if not mc_bases then
56148: LD_EXP 23
56152: NOT
56153: IFFALSE 56157
// exit ;
56155: GO 57018
// for i = 1 to mc_bases do
56157: LD_ADDR_VAR 0 2
56161: PUSH
56162: DOUBLE
56163: LD_INT 1
56165: DEC
56166: ST_TO_ADDR
56167: LD_EXP 23
56171: PUSH
56172: FOR_TO
56173: IFFALSE 57016
// begin if not mc_building_need_repair [ i ] then
56175: LD_EXP 24
56179: PUSH
56180: LD_VAR 0 2
56184: ARRAY
56185: NOT
56186: IFFALSE 56373
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56188: LD_ADDR_VAR 0 6
56192: PUSH
56193: LD_EXP 42
56197: PUSH
56198: LD_VAR 0 2
56202: ARRAY
56203: PPUSH
56204: LD_INT 3
56206: PUSH
56207: LD_INT 24
56209: PUSH
56210: LD_INT 1000
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: PUSH
56221: LD_INT 2
56223: PUSH
56224: LD_INT 34
56226: PUSH
56227: LD_INT 13
56229: PUSH
56230: EMPTY
56231: LIST
56232: LIST
56233: PUSH
56234: LD_INT 34
56236: PUSH
56237: LD_INT 52
56239: PUSH
56240: EMPTY
56241: LIST
56242: LIST
56243: PUSH
56244: LD_INT 34
56246: PUSH
56247: LD_EXP 73
56251: PUSH
56252: EMPTY
56253: LIST
56254: LIST
56255: PUSH
56256: EMPTY
56257: LIST
56258: LIST
56259: LIST
56260: LIST
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PPUSH
56266: CALL_OW 72
56270: ST_TO_ADDR
// if cranes then
56271: LD_VAR 0 6
56275: IFFALSE 56337
// for j in cranes do
56277: LD_ADDR_VAR 0 3
56281: PUSH
56282: LD_VAR 0 6
56286: PUSH
56287: FOR_IN
56288: IFFALSE 56335
// if not IsInArea ( j , mc_parking [ i ] ) then
56290: LD_VAR 0 3
56294: PPUSH
56295: LD_EXP 47
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: PPUSH
56306: CALL_OW 308
56310: NOT
56311: IFFALSE 56333
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56313: LD_VAR 0 3
56317: PPUSH
56318: LD_EXP 47
56322: PUSH
56323: LD_VAR 0 2
56327: ARRAY
56328: PPUSH
56329: CALL_OW 113
56333: GO 56287
56335: POP
56336: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56337: LD_ADDR_EXP 25
56341: PUSH
56342: LD_EXP 25
56346: PPUSH
56347: LD_VAR 0 2
56351: PPUSH
56352: EMPTY
56353: PPUSH
56354: CALL_OW 1
56358: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56359: LD_VAR 0 2
56363: PPUSH
56364: LD_INT 101
56366: PPUSH
56367: CALL 51261 0 2
// continue ;
56371: GO 56172
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56373: LD_ADDR_EXP 29
56377: PUSH
56378: LD_EXP 29
56382: PPUSH
56383: LD_VAR 0 2
56387: PPUSH
56388: EMPTY
56389: PPUSH
56390: CALL_OW 1
56394: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56395: LD_VAR 0 2
56399: PPUSH
56400: LD_INT 103
56402: PPUSH
56403: CALL 51261 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56407: LD_ADDR_VAR 0 5
56411: PUSH
56412: LD_EXP 23
56416: PUSH
56417: LD_VAR 0 2
56421: ARRAY
56422: PUSH
56423: LD_EXP 52
56427: PUSH
56428: LD_VAR 0 2
56432: ARRAY
56433: UNION
56434: PPUSH
56435: LD_INT 2
56437: PUSH
56438: LD_INT 25
56440: PUSH
56441: LD_INT 2
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 25
56450: PUSH
56451: LD_INT 16
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: LIST
56462: PUSH
56463: EMPTY
56464: LIST
56465: PPUSH
56466: CALL_OW 72
56470: PUSH
56471: LD_EXP 26
56475: PUSH
56476: LD_VAR 0 2
56480: ARRAY
56481: PUSH
56482: LD_INT 1
56484: ARRAY
56485: PUSH
56486: LD_EXP 26
56490: PUSH
56491: LD_VAR 0 2
56495: ARRAY
56496: PUSH
56497: LD_INT 2
56499: ARRAY
56500: UNION
56501: DIFF
56502: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
56503: LD_ADDR_VAR 0 6
56507: PUSH
56508: LD_EXP 42
56512: PUSH
56513: LD_VAR 0 2
56517: ARRAY
56518: PPUSH
56519: LD_INT 2
56521: PUSH
56522: LD_INT 34
56524: PUSH
56525: LD_INT 13
56527: PUSH
56528: EMPTY
56529: LIST
56530: LIST
56531: PUSH
56532: LD_INT 34
56534: PUSH
56535: LD_INT 52
56537: PUSH
56538: EMPTY
56539: LIST
56540: LIST
56541: PUSH
56542: LD_INT 34
56544: PUSH
56545: LD_EXP 73
56549: PUSH
56550: EMPTY
56551: LIST
56552: LIST
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: LIST
56558: LIST
56559: PPUSH
56560: CALL_OW 72
56564: ST_TO_ADDR
// if cranes then
56565: LD_VAR 0 6
56569: IFFALSE 56705
// begin for j in cranes do
56571: LD_ADDR_VAR 0 3
56575: PUSH
56576: LD_VAR 0 6
56580: PUSH
56581: FOR_IN
56582: IFFALSE 56703
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
56584: LD_VAR 0 3
56588: PPUSH
56589: CALL_OW 256
56593: PUSH
56594: LD_INT 1000
56596: EQUAL
56597: PUSH
56598: LD_VAR 0 3
56602: PPUSH
56603: CALL_OW 314
56607: NOT
56608: AND
56609: IFFALSE 56643
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
56611: LD_VAR 0 3
56615: PPUSH
56616: LD_EXP 24
56620: PUSH
56621: LD_VAR 0 2
56625: ARRAY
56626: PPUSH
56627: LD_VAR 0 3
56631: PPUSH
56632: CALL_OW 74
56636: PPUSH
56637: CALL_OW 130
56641: GO 56701
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
56643: LD_VAR 0 3
56647: PPUSH
56648: CALL_OW 256
56652: PUSH
56653: LD_INT 500
56655: LESS
56656: PUSH
56657: LD_VAR 0 3
56661: PPUSH
56662: LD_EXP 47
56666: PUSH
56667: LD_VAR 0 2
56671: ARRAY
56672: PPUSH
56673: CALL_OW 308
56677: NOT
56678: AND
56679: IFFALSE 56701
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56681: LD_VAR 0 3
56685: PPUSH
56686: LD_EXP 47
56690: PUSH
56691: LD_VAR 0 2
56695: ARRAY
56696: PPUSH
56697: CALL_OW 113
// end ;
56701: GO 56581
56703: POP
56704: POP
// end ; if tmp > 3 then
56705: LD_VAR 0 5
56709: PUSH
56710: LD_INT 3
56712: GREATER
56713: IFFALSE 56733
// tmp := ShrinkArray ( tmp , 4 ) ;
56715: LD_ADDR_VAR 0 5
56719: PUSH
56720: LD_VAR 0 5
56724: PPUSH
56725: LD_INT 4
56727: PPUSH
56728: CALL 45686 0 2
56732: ST_TO_ADDR
// if not tmp then
56733: LD_VAR 0 5
56737: NOT
56738: IFFALSE 56742
// continue ;
56740: GO 56172
// for j in tmp do
56742: LD_ADDR_VAR 0 3
56746: PUSH
56747: LD_VAR 0 5
56751: PUSH
56752: FOR_IN
56753: IFFALSE 57012
// begin if IsInUnit ( j ) then
56755: LD_VAR 0 3
56759: PPUSH
56760: CALL_OW 310
56764: IFFALSE 56775
// ComExitBuilding ( j ) ;
56766: LD_VAR 0 3
56770: PPUSH
56771: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
56775: LD_VAR 0 3
56779: PUSH
56780: LD_EXP 25
56784: PUSH
56785: LD_VAR 0 2
56789: ARRAY
56790: IN
56791: NOT
56792: IFFALSE 56850
// begin SetTag ( j , 101 ) ;
56794: LD_VAR 0 3
56798: PPUSH
56799: LD_INT 101
56801: PPUSH
56802: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
56806: LD_ADDR_EXP 25
56810: PUSH
56811: LD_EXP 25
56815: PPUSH
56816: LD_VAR 0 2
56820: PUSH
56821: LD_EXP 25
56825: PUSH
56826: LD_VAR 0 2
56830: ARRAY
56831: PUSH
56832: LD_INT 1
56834: PLUS
56835: PUSH
56836: EMPTY
56837: LIST
56838: LIST
56839: PPUSH
56840: LD_VAR 0 3
56844: PPUSH
56845: CALL 13619 0 3
56849: ST_TO_ADDR
// end ; wait ( 1 ) ;
56850: LD_INT 1
56852: PPUSH
56853: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
56857: LD_ADDR_VAR 0 7
56861: PUSH
56862: LD_EXP 24
56866: PUSH
56867: LD_VAR 0 2
56871: ARRAY
56872: ST_TO_ADDR
// if mc_scan [ i ] then
56873: LD_EXP 46
56877: PUSH
56878: LD_VAR 0 2
56882: ARRAY
56883: IFFALSE 56945
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
56885: LD_ADDR_VAR 0 7
56889: PUSH
56890: LD_EXP 24
56894: PUSH
56895: LD_VAR 0 2
56899: ARRAY
56900: PPUSH
56901: LD_INT 3
56903: PUSH
56904: LD_INT 30
56906: PUSH
56907: LD_INT 32
56909: PUSH
56910: EMPTY
56911: LIST
56912: LIST
56913: PUSH
56914: LD_INT 30
56916: PUSH
56917: LD_INT 33
56919: PUSH
56920: EMPTY
56921: LIST
56922: LIST
56923: PUSH
56924: LD_INT 30
56926: PUSH
56927: LD_INT 31
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: PUSH
56934: EMPTY
56935: LIST
56936: LIST
56937: LIST
56938: LIST
56939: PPUSH
56940: CALL_OW 72
56944: ST_TO_ADDR
// if not to_repair_tmp then
56945: LD_VAR 0 7
56949: NOT
56950: IFFALSE 56954
// continue ;
56952: GO 56752
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
56954: LD_ADDR_VAR 0 8
56958: PUSH
56959: LD_VAR 0 7
56963: PPUSH
56964: LD_VAR 0 3
56968: PPUSH
56969: CALL_OW 74
56973: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
56974: LD_VAR 0 8
56978: PPUSH
56979: LD_INT 16
56981: PPUSH
56982: CALL 16218 0 2
56986: PUSH
56987: LD_INT 4
56989: ARRAY
56990: PUSH
56991: LD_INT 10
56993: LESS
56994: IFFALSE 57010
// ComRepairBuilding ( j , to_repair ) ;
56996: LD_VAR 0 3
57000: PPUSH
57001: LD_VAR 0 8
57005: PPUSH
57006: CALL_OW 130
// end ;
57010: GO 56752
57012: POP
57013: POP
// end ;
57014: GO 56172
57016: POP
57017: POP
// end ;
57018: LD_VAR 0 1
57022: RET
// export function MC_Heal ; var i , j , tmp ; begin
57023: LD_INT 0
57025: PPUSH
57026: PPUSH
57027: PPUSH
57028: PPUSH
// if not mc_bases then
57029: LD_EXP 23
57033: NOT
57034: IFFALSE 57038
// exit ;
57036: GO 57440
// for i = 1 to mc_bases do
57038: LD_ADDR_VAR 0 2
57042: PUSH
57043: DOUBLE
57044: LD_INT 1
57046: DEC
57047: ST_TO_ADDR
57048: LD_EXP 23
57052: PUSH
57053: FOR_TO
57054: IFFALSE 57438
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
57056: LD_EXP 26
57060: PUSH
57061: LD_VAR 0 2
57065: ARRAY
57066: PUSH
57067: LD_INT 1
57069: ARRAY
57070: NOT
57071: PUSH
57072: LD_EXP 26
57076: PUSH
57077: LD_VAR 0 2
57081: ARRAY
57082: PUSH
57083: LD_INT 2
57085: ARRAY
57086: NOT
57087: AND
57088: IFFALSE 57126
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
57090: LD_ADDR_EXP 27
57094: PUSH
57095: LD_EXP 27
57099: PPUSH
57100: LD_VAR 0 2
57104: PPUSH
57105: EMPTY
57106: PPUSH
57107: CALL_OW 1
57111: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
57112: LD_VAR 0 2
57116: PPUSH
57117: LD_INT 102
57119: PPUSH
57120: CALL 51261 0 2
// continue ;
57124: GO 57053
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57126: LD_ADDR_VAR 0 4
57130: PUSH
57131: LD_EXP 23
57135: PUSH
57136: LD_VAR 0 2
57140: ARRAY
57141: PPUSH
57142: LD_INT 25
57144: PUSH
57145: LD_INT 4
57147: PUSH
57148: EMPTY
57149: LIST
57150: LIST
57151: PPUSH
57152: CALL_OW 72
57156: ST_TO_ADDR
// if not tmp then
57157: LD_VAR 0 4
57161: NOT
57162: IFFALSE 57166
// continue ;
57164: GO 57053
// if mc_taming [ i ] then
57166: LD_EXP 54
57170: PUSH
57171: LD_VAR 0 2
57175: ARRAY
57176: IFFALSE 57200
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57178: LD_ADDR_EXP 54
57182: PUSH
57183: LD_EXP 54
57187: PPUSH
57188: LD_VAR 0 2
57192: PPUSH
57193: EMPTY
57194: PPUSH
57195: CALL_OW 1
57199: ST_TO_ADDR
// for j in tmp do
57200: LD_ADDR_VAR 0 3
57204: PUSH
57205: LD_VAR 0 4
57209: PUSH
57210: FOR_IN
57211: IFFALSE 57434
// begin if IsInUnit ( j ) then
57213: LD_VAR 0 3
57217: PPUSH
57218: CALL_OW 310
57222: IFFALSE 57233
// ComExitBuilding ( j ) ;
57224: LD_VAR 0 3
57228: PPUSH
57229: CALL_OW 122
// if not j in mc_healers [ i ] then
57233: LD_VAR 0 3
57237: PUSH
57238: LD_EXP 27
57242: PUSH
57243: LD_VAR 0 2
57247: ARRAY
57248: IN
57249: NOT
57250: IFFALSE 57296
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57252: LD_ADDR_EXP 27
57256: PUSH
57257: LD_EXP 27
57261: PPUSH
57262: LD_VAR 0 2
57266: PUSH
57267: LD_EXP 27
57271: PUSH
57272: LD_VAR 0 2
57276: ARRAY
57277: PUSH
57278: LD_INT 1
57280: PLUS
57281: PUSH
57282: EMPTY
57283: LIST
57284: LIST
57285: PPUSH
57286: LD_VAR 0 3
57290: PPUSH
57291: CALL 13619 0 3
57295: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57296: LD_VAR 0 3
57300: PPUSH
57301: CALL_OW 110
57305: PUSH
57306: LD_INT 102
57308: NONEQUAL
57309: IFFALSE 57323
// SetTag ( j , 102 ) ;
57311: LD_VAR 0 3
57315: PPUSH
57316: LD_INT 102
57318: PPUSH
57319: CALL_OW 109
// Wait ( 3 ) ;
57323: LD_INT 3
57325: PPUSH
57326: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57330: LD_EXP 26
57334: PUSH
57335: LD_VAR 0 2
57339: ARRAY
57340: PUSH
57341: LD_INT 1
57343: ARRAY
57344: IFFALSE 57376
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57346: LD_VAR 0 3
57350: PPUSH
57351: LD_EXP 26
57355: PUSH
57356: LD_VAR 0 2
57360: ARRAY
57361: PUSH
57362: LD_INT 1
57364: ARRAY
57365: PUSH
57366: LD_INT 1
57368: ARRAY
57369: PPUSH
57370: CALL_OW 128
57374: GO 57432
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57376: LD_VAR 0 3
57380: PPUSH
57381: CALL_OW 314
57385: NOT
57386: PUSH
57387: LD_EXP 26
57391: PUSH
57392: LD_VAR 0 2
57396: ARRAY
57397: PUSH
57398: LD_INT 2
57400: ARRAY
57401: AND
57402: IFFALSE 57432
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57404: LD_VAR 0 3
57408: PPUSH
57409: LD_EXP 26
57413: PUSH
57414: LD_VAR 0 2
57418: ARRAY
57419: PUSH
57420: LD_INT 2
57422: ARRAY
57423: PUSH
57424: LD_INT 1
57426: ARRAY
57427: PPUSH
57428: CALL_OW 128
// end ;
57432: GO 57210
57434: POP
57435: POP
// end ;
57436: GO 57053
57438: POP
57439: POP
// end ;
57440: LD_VAR 0 1
57444: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57445: LD_INT 0
57447: PPUSH
57448: PPUSH
57449: PPUSH
57450: PPUSH
57451: PPUSH
// if not mc_bases then
57452: LD_EXP 23
57456: NOT
57457: IFFALSE 57461
// exit ;
57459: GO 58632
// for i = 1 to mc_bases do
57461: LD_ADDR_VAR 0 2
57465: PUSH
57466: DOUBLE
57467: LD_INT 1
57469: DEC
57470: ST_TO_ADDR
57471: LD_EXP 23
57475: PUSH
57476: FOR_TO
57477: IFFALSE 58630
// begin if mc_scan [ i ] then
57479: LD_EXP 46
57483: PUSH
57484: LD_VAR 0 2
57488: ARRAY
57489: IFFALSE 57493
// continue ;
57491: GO 57476
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
57493: LD_EXP 28
57497: PUSH
57498: LD_VAR 0 2
57502: ARRAY
57503: NOT
57504: PUSH
57505: LD_EXP 30
57509: PUSH
57510: LD_VAR 0 2
57514: ARRAY
57515: NOT
57516: AND
57517: PUSH
57518: LD_EXP 29
57522: PUSH
57523: LD_VAR 0 2
57527: ARRAY
57528: AND
57529: IFFALSE 57567
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
57531: LD_ADDR_EXP 29
57535: PUSH
57536: LD_EXP 29
57540: PPUSH
57541: LD_VAR 0 2
57545: PPUSH
57546: EMPTY
57547: PPUSH
57548: CALL_OW 1
57552: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
57553: LD_VAR 0 2
57557: PPUSH
57558: LD_INT 103
57560: PPUSH
57561: CALL 51261 0 2
// continue ;
57565: GO 57476
// end ; if mc_construct_list [ i ] then
57567: LD_EXP 30
57571: PUSH
57572: LD_VAR 0 2
57576: ARRAY
57577: IFFALSE 57797
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
57579: LD_ADDR_VAR 0 4
57583: PUSH
57584: LD_EXP 23
57588: PUSH
57589: LD_VAR 0 2
57593: ARRAY
57594: PPUSH
57595: LD_INT 25
57597: PUSH
57598: LD_INT 2
57600: PUSH
57601: EMPTY
57602: LIST
57603: LIST
57604: PPUSH
57605: CALL_OW 72
57609: PUSH
57610: LD_EXP 25
57614: PUSH
57615: LD_VAR 0 2
57619: ARRAY
57620: DIFF
57621: ST_TO_ADDR
// if not tmp then
57622: LD_VAR 0 4
57626: NOT
57627: IFFALSE 57631
// continue ;
57629: GO 57476
// for j in tmp do
57631: LD_ADDR_VAR 0 3
57635: PUSH
57636: LD_VAR 0 4
57640: PUSH
57641: FOR_IN
57642: IFFALSE 57793
// begin if not mc_builders [ i ] then
57644: LD_EXP 29
57648: PUSH
57649: LD_VAR 0 2
57653: ARRAY
57654: NOT
57655: IFFALSE 57713
// begin SetTag ( j , 103 ) ;
57657: LD_VAR 0 3
57661: PPUSH
57662: LD_INT 103
57664: PPUSH
57665: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
57669: LD_ADDR_EXP 29
57673: PUSH
57674: LD_EXP 29
57678: PPUSH
57679: LD_VAR 0 2
57683: PUSH
57684: LD_EXP 29
57688: PUSH
57689: LD_VAR 0 2
57693: ARRAY
57694: PUSH
57695: LD_INT 1
57697: PLUS
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: PPUSH
57703: LD_VAR 0 3
57707: PPUSH
57708: CALL 13619 0 3
57712: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
57713: LD_VAR 0 3
57717: PPUSH
57718: CALL_OW 310
57722: IFFALSE 57733
// ComExitBuilding ( j ) ;
57724: LD_VAR 0 3
57728: PPUSH
57729: CALL_OW 122
// wait ( 3 ) ;
57733: LD_INT 3
57735: PPUSH
57736: CALL_OW 67
// if not mc_construct_list [ i ] then
57740: LD_EXP 30
57744: PUSH
57745: LD_VAR 0 2
57749: ARRAY
57750: NOT
57751: IFFALSE 57755
// break ;
57753: GO 57793
// if not HasTask ( j ) then
57755: LD_VAR 0 3
57759: PPUSH
57760: CALL_OW 314
57764: NOT
57765: IFFALSE 57791
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
57767: LD_VAR 0 3
57771: PPUSH
57772: LD_EXP 30
57776: PUSH
57777: LD_VAR 0 2
57781: ARRAY
57782: PUSH
57783: LD_INT 1
57785: ARRAY
57786: PPUSH
57787: CALL 16482 0 2
// end ;
57791: GO 57641
57793: POP
57794: POP
// end else
57795: GO 58628
// if mc_build_list [ i ] then
57797: LD_EXP 28
57801: PUSH
57802: LD_VAR 0 2
57806: ARRAY
57807: IFFALSE 58628
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57809: LD_ADDR_VAR 0 5
57813: PUSH
57814: LD_EXP 23
57818: PUSH
57819: LD_VAR 0 2
57823: ARRAY
57824: PPUSH
57825: LD_INT 2
57827: PUSH
57828: LD_INT 30
57830: PUSH
57831: LD_INT 0
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: LD_INT 30
57840: PUSH
57841: LD_INT 1
57843: PUSH
57844: EMPTY
57845: LIST
57846: LIST
57847: PUSH
57848: EMPTY
57849: LIST
57850: LIST
57851: LIST
57852: PPUSH
57853: CALL_OW 72
57857: ST_TO_ADDR
// if depot then
57858: LD_VAR 0 5
57862: IFFALSE 57880
// depot := depot [ 1 ] else
57864: LD_ADDR_VAR 0 5
57868: PUSH
57869: LD_VAR 0 5
57873: PUSH
57874: LD_INT 1
57876: ARRAY
57877: ST_TO_ADDR
57878: GO 57888
// depot := 0 ;
57880: LD_ADDR_VAR 0 5
57884: PUSH
57885: LD_INT 0
57887: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
57888: LD_EXP 28
57892: PUSH
57893: LD_VAR 0 2
57897: ARRAY
57898: PUSH
57899: LD_INT 1
57901: ARRAY
57902: PUSH
57903: LD_INT 1
57905: ARRAY
57906: PPUSH
57907: CALL 16306 0 1
57911: PUSH
57912: LD_EXP 23
57916: PUSH
57917: LD_VAR 0 2
57921: ARRAY
57922: PPUSH
57923: LD_INT 2
57925: PUSH
57926: LD_INT 30
57928: PUSH
57929: LD_INT 2
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: PUSH
57936: LD_INT 30
57938: PUSH
57939: LD_INT 3
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: LIST
57950: PPUSH
57951: CALL_OW 72
57955: NOT
57956: AND
57957: IFFALSE 58062
// begin for j = 1 to mc_build_list [ i ] do
57959: LD_ADDR_VAR 0 3
57963: PUSH
57964: DOUBLE
57965: LD_INT 1
57967: DEC
57968: ST_TO_ADDR
57969: LD_EXP 28
57973: PUSH
57974: LD_VAR 0 2
57978: ARRAY
57979: PUSH
57980: FOR_TO
57981: IFFALSE 58060
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
57983: LD_EXP 28
57987: PUSH
57988: LD_VAR 0 2
57992: ARRAY
57993: PUSH
57994: LD_VAR 0 3
57998: ARRAY
57999: PUSH
58000: LD_INT 1
58002: ARRAY
58003: PUSH
58004: LD_INT 2
58006: EQUAL
58007: IFFALSE 58058
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
58009: LD_ADDR_EXP 28
58013: PUSH
58014: LD_EXP 28
58018: PPUSH
58019: LD_VAR 0 2
58023: PPUSH
58024: LD_EXP 28
58028: PUSH
58029: LD_VAR 0 2
58033: ARRAY
58034: PPUSH
58035: LD_VAR 0 3
58039: PPUSH
58040: LD_INT 1
58042: PPUSH
58043: LD_INT 0
58045: PPUSH
58046: CALL 13037 0 4
58050: PPUSH
58051: CALL_OW 1
58055: ST_TO_ADDR
// break ;
58056: GO 58060
// end ;
58058: GO 57980
58060: POP
58061: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
58062: LD_EXP 28
58066: PUSH
58067: LD_VAR 0 2
58071: ARRAY
58072: PUSH
58073: LD_INT 1
58075: ARRAY
58076: PUSH
58077: LD_INT 1
58079: ARRAY
58080: PUSH
58081: LD_INT 0
58083: EQUAL
58084: PUSH
58085: LD_VAR 0 5
58089: PUSH
58090: LD_VAR 0 5
58094: PPUSH
58095: LD_EXP 28
58099: PUSH
58100: LD_VAR 0 2
58104: ARRAY
58105: PUSH
58106: LD_INT 1
58108: ARRAY
58109: PUSH
58110: LD_INT 1
58112: ARRAY
58113: PPUSH
58114: LD_EXP 28
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: PUSH
58125: LD_INT 1
58127: ARRAY
58128: PUSH
58129: LD_INT 2
58131: ARRAY
58132: PPUSH
58133: LD_EXP 28
58137: PUSH
58138: LD_VAR 0 2
58142: ARRAY
58143: PUSH
58144: LD_INT 1
58146: ARRAY
58147: PUSH
58148: LD_INT 3
58150: ARRAY
58151: PPUSH
58152: LD_EXP 28
58156: PUSH
58157: LD_VAR 0 2
58161: ARRAY
58162: PUSH
58163: LD_INT 1
58165: ARRAY
58166: PUSH
58167: LD_INT 4
58169: ARRAY
58170: PPUSH
58171: CALL 21723 0 5
58175: AND
58176: OR
58177: IFFALSE 58458
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58179: LD_ADDR_VAR 0 4
58183: PUSH
58184: LD_EXP 23
58188: PUSH
58189: LD_VAR 0 2
58193: ARRAY
58194: PPUSH
58195: LD_INT 25
58197: PUSH
58198: LD_INT 2
58200: PUSH
58201: EMPTY
58202: LIST
58203: LIST
58204: PPUSH
58205: CALL_OW 72
58209: PUSH
58210: LD_EXP 25
58214: PUSH
58215: LD_VAR 0 2
58219: ARRAY
58220: DIFF
58221: ST_TO_ADDR
// if not tmp then
58222: LD_VAR 0 4
58226: NOT
58227: IFFALSE 58231
// continue ;
58229: GO 57476
// for j in tmp do
58231: LD_ADDR_VAR 0 3
58235: PUSH
58236: LD_VAR 0 4
58240: PUSH
58241: FOR_IN
58242: IFFALSE 58454
// begin if not mc_builders [ i ] then
58244: LD_EXP 29
58248: PUSH
58249: LD_VAR 0 2
58253: ARRAY
58254: NOT
58255: IFFALSE 58313
// begin SetTag ( j , 103 ) ;
58257: LD_VAR 0 3
58261: PPUSH
58262: LD_INT 103
58264: PPUSH
58265: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58269: LD_ADDR_EXP 29
58273: PUSH
58274: LD_EXP 29
58278: PPUSH
58279: LD_VAR 0 2
58283: PUSH
58284: LD_EXP 29
58288: PUSH
58289: LD_VAR 0 2
58293: ARRAY
58294: PUSH
58295: LD_INT 1
58297: PLUS
58298: PUSH
58299: EMPTY
58300: LIST
58301: LIST
58302: PPUSH
58303: LD_VAR 0 3
58307: PPUSH
58308: CALL 13619 0 3
58312: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58313: LD_VAR 0 3
58317: PPUSH
58318: CALL_OW 310
58322: IFFALSE 58333
// ComExitBuilding ( j ) ;
58324: LD_VAR 0 3
58328: PPUSH
58329: CALL_OW 122
// wait ( 3 ) ;
58333: LD_INT 3
58335: PPUSH
58336: CALL_OW 67
// if not mc_build_list [ i ] then
58340: LD_EXP 28
58344: PUSH
58345: LD_VAR 0 2
58349: ARRAY
58350: NOT
58351: IFFALSE 58355
// break ;
58353: GO 58454
// if not HasTask ( j ) then
58355: LD_VAR 0 3
58359: PPUSH
58360: CALL_OW 314
58364: NOT
58365: IFFALSE 58452
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58367: LD_VAR 0 3
58371: PPUSH
58372: LD_EXP 28
58376: PUSH
58377: LD_VAR 0 2
58381: ARRAY
58382: PUSH
58383: LD_INT 1
58385: ARRAY
58386: PUSH
58387: LD_INT 1
58389: ARRAY
58390: PPUSH
58391: LD_EXP 28
58395: PUSH
58396: LD_VAR 0 2
58400: ARRAY
58401: PUSH
58402: LD_INT 1
58404: ARRAY
58405: PUSH
58406: LD_INT 2
58408: ARRAY
58409: PPUSH
58410: LD_EXP 28
58414: PUSH
58415: LD_VAR 0 2
58419: ARRAY
58420: PUSH
58421: LD_INT 1
58423: ARRAY
58424: PUSH
58425: LD_INT 3
58427: ARRAY
58428: PPUSH
58429: LD_EXP 28
58433: PUSH
58434: LD_VAR 0 2
58438: ARRAY
58439: PUSH
58440: LD_INT 1
58442: ARRAY
58443: PUSH
58444: LD_INT 4
58446: ARRAY
58447: PPUSH
58448: CALL_OW 145
// end ;
58452: GO 58241
58454: POP
58455: POP
// end else
58456: GO 58628
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
58458: LD_EXP 23
58462: PUSH
58463: LD_VAR 0 2
58467: ARRAY
58468: PPUSH
58469: LD_EXP 28
58473: PUSH
58474: LD_VAR 0 2
58478: ARRAY
58479: PUSH
58480: LD_INT 1
58482: ARRAY
58483: PUSH
58484: LD_INT 1
58486: ARRAY
58487: PPUSH
58488: LD_EXP 28
58492: PUSH
58493: LD_VAR 0 2
58497: ARRAY
58498: PUSH
58499: LD_INT 1
58501: ARRAY
58502: PUSH
58503: LD_INT 2
58505: ARRAY
58506: PPUSH
58507: LD_EXP 28
58511: PUSH
58512: LD_VAR 0 2
58516: ARRAY
58517: PUSH
58518: LD_INT 1
58520: ARRAY
58521: PUSH
58522: LD_INT 3
58524: ARRAY
58525: PPUSH
58526: LD_EXP 28
58530: PUSH
58531: LD_VAR 0 2
58535: ARRAY
58536: PUSH
58537: LD_INT 1
58539: ARRAY
58540: PUSH
58541: LD_INT 4
58543: ARRAY
58544: PPUSH
58545: LD_EXP 23
58549: PUSH
58550: LD_VAR 0 2
58554: ARRAY
58555: PPUSH
58556: LD_INT 21
58558: PUSH
58559: LD_INT 3
58561: PUSH
58562: EMPTY
58563: LIST
58564: LIST
58565: PPUSH
58566: CALL_OW 72
58570: PPUSH
58571: EMPTY
58572: PPUSH
58573: CALL 20473 0 7
58577: NOT
58578: IFFALSE 58628
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
58580: LD_ADDR_EXP 28
58584: PUSH
58585: LD_EXP 28
58589: PPUSH
58590: LD_VAR 0 2
58594: PPUSH
58595: LD_EXP 28
58599: PUSH
58600: LD_VAR 0 2
58604: ARRAY
58605: PPUSH
58606: LD_INT 1
58608: PPUSH
58609: LD_INT 1
58611: NEG
58612: PPUSH
58613: LD_INT 0
58615: PPUSH
58616: CALL 13037 0 4
58620: PPUSH
58621: CALL_OW 1
58625: ST_TO_ADDR
// continue ;
58626: GO 57476
// end ; end ; end ;
58628: GO 57476
58630: POP
58631: POP
// end ;
58632: LD_VAR 0 1
58636: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
58637: LD_INT 0
58639: PPUSH
58640: PPUSH
58641: PPUSH
58642: PPUSH
58643: PPUSH
58644: PPUSH
// if not mc_bases then
58645: LD_EXP 23
58649: NOT
58650: IFFALSE 58654
// exit ;
58652: GO 59081
// for i = 1 to mc_bases do
58654: LD_ADDR_VAR 0 2
58658: PUSH
58659: DOUBLE
58660: LD_INT 1
58662: DEC
58663: ST_TO_ADDR
58664: LD_EXP 23
58668: PUSH
58669: FOR_TO
58670: IFFALSE 59079
// begin tmp := mc_build_upgrade [ i ] ;
58672: LD_ADDR_VAR 0 4
58676: PUSH
58677: LD_EXP 55
58681: PUSH
58682: LD_VAR 0 2
58686: ARRAY
58687: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
58688: LD_ADDR_VAR 0 6
58692: PUSH
58693: LD_EXP 56
58697: PUSH
58698: LD_VAR 0 2
58702: ARRAY
58703: PPUSH
58704: LD_INT 2
58706: PUSH
58707: LD_INT 30
58709: PUSH
58710: LD_INT 6
58712: PUSH
58713: EMPTY
58714: LIST
58715: LIST
58716: PUSH
58717: LD_INT 30
58719: PUSH
58720: LD_INT 7
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PUSH
58727: EMPTY
58728: LIST
58729: LIST
58730: LIST
58731: PPUSH
58732: CALL_OW 72
58736: ST_TO_ADDR
// if not tmp and not lab then
58737: LD_VAR 0 4
58741: NOT
58742: PUSH
58743: LD_VAR 0 6
58747: NOT
58748: AND
58749: IFFALSE 58753
// continue ;
58751: GO 58669
// if tmp then
58753: LD_VAR 0 4
58757: IFFALSE 58877
// for j in tmp do
58759: LD_ADDR_VAR 0 3
58763: PUSH
58764: LD_VAR 0 4
58768: PUSH
58769: FOR_IN
58770: IFFALSE 58875
// begin if UpgradeCost ( j ) then
58772: LD_VAR 0 3
58776: PPUSH
58777: CALL 20133 0 1
58781: IFFALSE 58873
// begin ComUpgrade ( j ) ;
58783: LD_VAR 0 3
58787: PPUSH
58788: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
58792: LD_ADDR_EXP 55
58796: PUSH
58797: LD_EXP 55
58801: PPUSH
58802: LD_VAR 0 2
58806: PPUSH
58807: LD_EXP 55
58811: PUSH
58812: LD_VAR 0 2
58816: ARRAY
58817: PUSH
58818: LD_VAR 0 3
58822: DIFF
58823: PPUSH
58824: CALL_OW 1
58828: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
58829: LD_ADDR_EXP 30
58833: PUSH
58834: LD_EXP 30
58838: PPUSH
58839: LD_VAR 0 2
58843: PUSH
58844: LD_EXP 30
58848: PUSH
58849: LD_VAR 0 2
58853: ARRAY
58854: PUSH
58855: LD_INT 1
58857: PLUS
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PPUSH
58863: LD_VAR 0 3
58867: PPUSH
58868: CALL 13619 0 3
58872: ST_TO_ADDR
// end ; end ;
58873: GO 58769
58875: POP
58876: POP
// if not lab or not mc_lab_upgrade [ i ] then
58877: LD_VAR 0 6
58881: NOT
58882: PUSH
58883: LD_EXP 57
58887: PUSH
58888: LD_VAR 0 2
58892: ARRAY
58893: NOT
58894: OR
58895: IFFALSE 58899
// continue ;
58897: GO 58669
// for j in lab do
58899: LD_ADDR_VAR 0 3
58903: PUSH
58904: LD_VAR 0 6
58908: PUSH
58909: FOR_IN
58910: IFFALSE 59075
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
58912: LD_VAR 0 3
58916: PPUSH
58917: CALL_OW 266
58921: PUSH
58922: LD_INT 6
58924: PUSH
58925: LD_INT 7
58927: PUSH
58928: EMPTY
58929: LIST
58930: LIST
58931: IN
58932: PUSH
58933: LD_VAR 0 3
58937: PPUSH
58938: CALL_OW 461
58942: PUSH
58943: LD_INT 1
58945: NONEQUAL
58946: AND
58947: IFFALSE 59073
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
58949: LD_VAR 0 3
58953: PPUSH
58954: LD_EXP 57
58958: PUSH
58959: LD_VAR 0 2
58963: ARRAY
58964: PUSH
58965: LD_INT 1
58967: ARRAY
58968: PPUSH
58969: CALL 20338 0 2
58973: IFFALSE 59073
// begin ComCancel ( j ) ;
58975: LD_VAR 0 3
58979: PPUSH
58980: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
58984: LD_VAR 0 3
58988: PPUSH
58989: LD_EXP 57
58993: PUSH
58994: LD_VAR 0 2
58998: ARRAY
58999: PUSH
59000: LD_INT 1
59002: ARRAY
59003: PPUSH
59004: CALL_OW 207
// if not j in mc_construct_list [ i ] then
59008: LD_VAR 0 3
59012: PUSH
59013: LD_EXP 30
59017: PUSH
59018: LD_VAR 0 2
59022: ARRAY
59023: IN
59024: NOT
59025: IFFALSE 59071
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59027: LD_ADDR_EXP 30
59031: PUSH
59032: LD_EXP 30
59036: PPUSH
59037: LD_VAR 0 2
59041: PUSH
59042: LD_EXP 30
59046: PUSH
59047: LD_VAR 0 2
59051: ARRAY
59052: PUSH
59053: LD_INT 1
59055: PLUS
59056: PUSH
59057: EMPTY
59058: LIST
59059: LIST
59060: PPUSH
59061: LD_VAR 0 3
59065: PPUSH
59066: CALL 13619 0 3
59070: ST_TO_ADDR
// break ;
59071: GO 59075
// end ; end ; end ;
59073: GO 58909
59075: POP
59076: POP
// end ;
59077: GO 58669
59079: POP
59080: POP
// end ;
59081: LD_VAR 0 1
59085: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
59086: LD_INT 0
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
// if not mc_bases then
59097: LD_EXP 23
59101: NOT
59102: IFFALSE 59106
// exit ;
59104: GO 59511
// for i = 1 to mc_bases do
59106: LD_ADDR_VAR 0 2
59110: PUSH
59111: DOUBLE
59112: LD_INT 1
59114: DEC
59115: ST_TO_ADDR
59116: LD_EXP 23
59120: PUSH
59121: FOR_TO
59122: IFFALSE 59509
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
59124: LD_EXP 31
59128: PUSH
59129: LD_VAR 0 2
59133: ARRAY
59134: NOT
59135: PUSH
59136: LD_EXP 23
59140: PUSH
59141: LD_VAR 0 2
59145: ARRAY
59146: PPUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 3
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PPUSH
59157: CALL_OW 72
59161: NOT
59162: OR
59163: IFFALSE 59167
// continue ;
59165: GO 59121
// busy := false ;
59167: LD_ADDR_VAR 0 8
59171: PUSH
59172: LD_INT 0
59174: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59175: LD_ADDR_VAR 0 4
59179: PUSH
59180: LD_EXP 23
59184: PUSH
59185: LD_VAR 0 2
59189: ARRAY
59190: PPUSH
59191: LD_INT 30
59193: PUSH
59194: LD_INT 3
59196: PUSH
59197: EMPTY
59198: LIST
59199: LIST
59200: PPUSH
59201: CALL_OW 72
59205: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59206: LD_ADDR_VAR 0 6
59210: PUSH
59211: LD_EXP 31
59215: PUSH
59216: LD_VAR 0 2
59220: ARRAY
59221: PPUSH
59222: LD_INT 2
59224: PUSH
59225: LD_INT 30
59227: PUSH
59228: LD_INT 32
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: PUSH
59235: LD_INT 30
59237: PUSH
59238: LD_INT 33
59240: PUSH
59241: EMPTY
59242: LIST
59243: LIST
59244: PUSH
59245: EMPTY
59246: LIST
59247: LIST
59248: LIST
59249: PPUSH
59250: CALL_OW 72
59254: ST_TO_ADDR
// if not t then
59255: LD_VAR 0 6
59259: NOT
59260: IFFALSE 59264
// continue ;
59262: GO 59121
// for j in tmp do
59264: LD_ADDR_VAR 0 3
59268: PUSH
59269: LD_VAR 0 4
59273: PUSH
59274: FOR_IN
59275: IFFALSE 59305
// if not BuildingStatus ( j ) = bs_idle then
59277: LD_VAR 0 3
59281: PPUSH
59282: CALL_OW 461
59286: PUSH
59287: LD_INT 2
59289: EQUAL
59290: NOT
59291: IFFALSE 59303
// begin busy := true ;
59293: LD_ADDR_VAR 0 8
59297: PUSH
59298: LD_INT 1
59300: ST_TO_ADDR
// break ;
59301: GO 59305
// end ;
59303: GO 59274
59305: POP
59306: POP
// if busy then
59307: LD_VAR 0 8
59311: IFFALSE 59315
// continue ;
59313: GO 59121
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59315: LD_ADDR_VAR 0 7
59319: PUSH
59320: LD_VAR 0 6
59324: PPUSH
59325: LD_INT 35
59327: PUSH
59328: LD_INT 0
59330: PUSH
59331: EMPTY
59332: LIST
59333: LIST
59334: PPUSH
59335: CALL_OW 72
59339: ST_TO_ADDR
// if tw then
59340: LD_VAR 0 7
59344: IFFALSE 59421
// begin tw := tw [ 1 ] ;
59346: LD_ADDR_VAR 0 7
59350: PUSH
59351: LD_VAR 0 7
59355: PUSH
59356: LD_INT 1
59358: ARRAY
59359: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59360: LD_ADDR_VAR 0 9
59364: PUSH
59365: LD_VAR 0 7
59369: PPUSH
59370: LD_EXP 48
59374: PUSH
59375: LD_VAR 0 2
59379: ARRAY
59380: PPUSH
59381: CALL 18630 0 2
59385: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59386: LD_EXP 62
59390: PUSH
59391: LD_VAR 0 2
59395: ARRAY
59396: IFFALSE 59419
// if not weapon in mc_allowed_tower_weapons [ i ] then
59398: LD_VAR 0 9
59402: PUSH
59403: LD_EXP 62
59407: PUSH
59408: LD_VAR 0 2
59412: ARRAY
59413: IN
59414: NOT
59415: IFFALSE 59419
// continue ;
59417: GO 59121
// end else
59419: GO 59484
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59421: LD_ADDR_VAR 0 5
59425: PUSH
59426: LD_EXP 31
59430: PUSH
59431: LD_VAR 0 2
59435: ARRAY
59436: PPUSH
59437: LD_VAR 0 4
59441: PPUSH
59442: CALL 44919 0 2
59446: ST_TO_ADDR
// if not tmp2 then
59447: LD_VAR 0 5
59451: NOT
59452: IFFALSE 59456
// continue ;
59454: GO 59121
// tw := tmp2 [ 1 ] ;
59456: LD_ADDR_VAR 0 7
59460: PUSH
59461: LD_VAR 0 5
59465: PUSH
59466: LD_INT 1
59468: ARRAY
59469: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59470: LD_ADDR_VAR 0 9
59474: PUSH
59475: LD_VAR 0 5
59479: PUSH
59480: LD_INT 2
59482: ARRAY
59483: ST_TO_ADDR
// end ; if not weapon then
59484: LD_VAR 0 9
59488: NOT
59489: IFFALSE 59493
// continue ;
59491: GO 59121
// ComPlaceWeapon ( tw , weapon ) ;
59493: LD_VAR 0 7
59497: PPUSH
59498: LD_VAR 0 9
59502: PPUSH
59503: CALL_OW 148
// end ;
59507: GO 59121
59509: POP
59510: POP
// end ;
59511: LD_VAR 0 1
59515: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
59516: LD_INT 0
59518: PPUSH
59519: PPUSH
59520: PPUSH
59521: PPUSH
59522: PPUSH
59523: PPUSH
59524: PPUSH
// if not mc_bases then
59525: LD_EXP 23
59529: NOT
59530: IFFALSE 59534
// exit ;
59532: GO 60302
// for i = 1 to mc_bases do
59534: LD_ADDR_VAR 0 2
59538: PUSH
59539: DOUBLE
59540: LD_INT 1
59542: DEC
59543: ST_TO_ADDR
59544: LD_EXP 23
59548: PUSH
59549: FOR_TO
59550: IFFALSE 60300
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
59552: LD_EXP 36
59556: PUSH
59557: LD_VAR 0 2
59561: ARRAY
59562: NOT
59563: PUSH
59564: LD_EXP 36
59568: PUSH
59569: LD_VAR 0 2
59573: ARRAY
59574: PUSH
59575: LD_EXP 37
59579: PUSH
59580: LD_VAR 0 2
59584: ARRAY
59585: EQUAL
59586: OR
59587: PUSH
59588: LD_EXP 46
59592: PUSH
59593: LD_VAR 0 2
59597: ARRAY
59598: OR
59599: IFFALSE 59603
// continue ;
59601: GO 59549
// if mc_miners [ i ] then
59603: LD_EXP 37
59607: PUSH
59608: LD_VAR 0 2
59612: ARRAY
59613: IFFALSE 59987
// begin for j = mc_miners [ i ] downto 1 do
59615: LD_ADDR_VAR 0 3
59619: PUSH
59620: DOUBLE
59621: LD_EXP 37
59625: PUSH
59626: LD_VAR 0 2
59630: ARRAY
59631: INC
59632: ST_TO_ADDR
59633: LD_INT 1
59635: PUSH
59636: FOR_DOWNTO
59637: IFFALSE 59985
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
59639: LD_EXP 37
59643: PUSH
59644: LD_VAR 0 2
59648: ARRAY
59649: PUSH
59650: LD_VAR 0 3
59654: ARRAY
59655: PPUSH
59656: CALL_OW 301
59660: PUSH
59661: LD_EXP 37
59665: PUSH
59666: LD_VAR 0 2
59670: ARRAY
59671: PUSH
59672: LD_VAR 0 3
59676: ARRAY
59677: PPUSH
59678: CALL_OW 257
59682: PUSH
59683: LD_INT 1
59685: NONEQUAL
59686: OR
59687: IFFALSE 59750
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
59689: LD_ADDR_VAR 0 5
59693: PUSH
59694: LD_EXP 37
59698: PUSH
59699: LD_VAR 0 2
59703: ARRAY
59704: PUSH
59705: LD_EXP 37
59709: PUSH
59710: LD_VAR 0 2
59714: ARRAY
59715: PUSH
59716: LD_VAR 0 3
59720: ARRAY
59721: DIFF
59722: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
59723: LD_ADDR_EXP 37
59727: PUSH
59728: LD_EXP 37
59732: PPUSH
59733: LD_VAR 0 2
59737: PPUSH
59738: LD_VAR 0 5
59742: PPUSH
59743: CALL_OW 1
59747: ST_TO_ADDR
// continue ;
59748: GO 59636
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
59750: LD_EXP 37
59754: PUSH
59755: LD_VAR 0 2
59759: ARRAY
59760: PUSH
59761: LD_VAR 0 3
59765: ARRAY
59766: PPUSH
59767: CALL_OW 257
59771: PUSH
59772: LD_INT 1
59774: EQUAL
59775: PUSH
59776: LD_EXP 37
59780: PUSH
59781: LD_VAR 0 2
59785: ARRAY
59786: PUSH
59787: LD_VAR 0 3
59791: ARRAY
59792: PPUSH
59793: CALL_OW 459
59797: NOT
59798: AND
59799: PUSH
59800: LD_EXP 37
59804: PUSH
59805: LD_VAR 0 2
59809: ARRAY
59810: PUSH
59811: LD_VAR 0 3
59815: ARRAY
59816: PPUSH
59817: CALL_OW 314
59821: NOT
59822: AND
59823: IFFALSE 59983
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
59825: LD_EXP 37
59829: PUSH
59830: LD_VAR 0 2
59834: ARRAY
59835: PUSH
59836: LD_VAR 0 3
59840: ARRAY
59841: PPUSH
59842: CALL_OW 310
59846: IFFALSE 59869
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
59848: LD_EXP 37
59852: PUSH
59853: LD_VAR 0 2
59857: ARRAY
59858: PUSH
59859: LD_VAR 0 3
59863: ARRAY
59864: PPUSH
59865: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
59869: LD_EXP 37
59873: PUSH
59874: LD_VAR 0 2
59878: ARRAY
59879: PUSH
59880: LD_VAR 0 3
59884: ARRAY
59885: PPUSH
59886: CALL_OW 314
59890: NOT
59891: IFFALSE 59983
// begin r := rand ( 1 , mc_mines [ i ] ) ;
59893: LD_ADDR_VAR 0 7
59897: PUSH
59898: LD_INT 1
59900: PPUSH
59901: LD_EXP 36
59905: PUSH
59906: LD_VAR 0 2
59910: ARRAY
59911: PPUSH
59912: CALL_OW 12
59916: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
59917: LD_EXP 37
59921: PUSH
59922: LD_VAR 0 2
59926: ARRAY
59927: PUSH
59928: LD_VAR 0 3
59932: ARRAY
59933: PPUSH
59934: LD_EXP 36
59938: PUSH
59939: LD_VAR 0 2
59943: ARRAY
59944: PUSH
59945: LD_VAR 0 7
59949: ARRAY
59950: PUSH
59951: LD_INT 1
59953: ARRAY
59954: PPUSH
59955: LD_EXP 36
59959: PUSH
59960: LD_VAR 0 2
59964: ARRAY
59965: PUSH
59966: LD_VAR 0 7
59970: ARRAY
59971: PUSH
59972: LD_INT 2
59974: ARRAY
59975: PPUSH
59976: LD_INT 0
59978: PPUSH
59979: CALL_OW 193
// end ; end ; end ;
59983: GO 59636
59985: POP
59986: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
59987: LD_ADDR_VAR 0 5
59991: PUSH
59992: LD_EXP 23
59996: PUSH
59997: LD_VAR 0 2
60001: ARRAY
60002: PPUSH
60003: LD_INT 2
60005: PUSH
60006: LD_INT 30
60008: PUSH
60009: LD_INT 4
60011: PUSH
60012: EMPTY
60013: LIST
60014: LIST
60015: PUSH
60016: LD_INT 30
60018: PUSH
60019: LD_INT 5
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PUSH
60026: LD_INT 30
60028: PUSH
60029: LD_INT 32
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: PPUSH
60042: CALL_OW 72
60046: ST_TO_ADDR
// if not tmp then
60047: LD_VAR 0 5
60051: NOT
60052: IFFALSE 60056
// continue ;
60054: GO 59549
// list := [ ] ;
60056: LD_ADDR_VAR 0 6
60060: PUSH
60061: EMPTY
60062: ST_TO_ADDR
// for j in tmp do
60063: LD_ADDR_VAR 0 3
60067: PUSH
60068: LD_VAR 0 5
60072: PUSH
60073: FOR_IN
60074: IFFALSE 60143
// begin for k in UnitsInside ( j ) do
60076: LD_ADDR_VAR 0 4
60080: PUSH
60081: LD_VAR 0 3
60085: PPUSH
60086: CALL_OW 313
60090: PUSH
60091: FOR_IN
60092: IFFALSE 60139
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
60094: LD_VAR 0 4
60098: PPUSH
60099: CALL_OW 257
60103: PUSH
60104: LD_INT 1
60106: EQUAL
60107: PUSH
60108: LD_VAR 0 4
60112: PPUSH
60113: CALL_OW 459
60117: NOT
60118: AND
60119: IFFALSE 60137
// list := list ^ k ;
60121: LD_ADDR_VAR 0 6
60125: PUSH
60126: LD_VAR 0 6
60130: PUSH
60131: LD_VAR 0 4
60135: ADD
60136: ST_TO_ADDR
60137: GO 60091
60139: POP
60140: POP
// end ;
60141: GO 60073
60143: POP
60144: POP
// list := list diff mc_miners [ i ] ;
60145: LD_ADDR_VAR 0 6
60149: PUSH
60150: LD_VAR 0 6
60154: PUSH
60155: LD_EXP 37
60159: PUSH
60160: LD_VAR 0 2
60164: ARRAY
60165: DIFF
60166: ST_TO_ADDR
// if not list then
60167: LD_VAR 0 6
60171: NOT
60172: IFFALSE 60176
// continue ;
60174: GO 59549
// k := mc_mines [ i ] - mc_miners [ i ] ;
60176: LD_ADDR_VAR 0 4
60180: PUSH
60181: LD_EXP 36
60185: PUSH
60186: LD_VAR 0 2
60190: ARRAY
60191: PUSH
60192: LD_EXP 37
60196: PUSH
60197: LD_VAR 0 2
60201: ARRAY
60202: MINUS
60203: ST_TO_ADDR
// if k > list then
60204: LD_VAR 0 4
60208: PUSH
60209: LD_VAR 0 6
60213: GREATER
60214: IFFALSE 60226
// k := list ;
60216: LD_ADDR_VAR 0 4
60220: PUSH
60221: LD_VAR 0 6
60225: ST_TO_ADDR
// for j = 1 to k do
60226: LD_ADDR_VAR 0 3
60230: PUSH
60231: DOUBLE
60232: LD_INT 1
60234: DEC
60235: ST_TO_ADDR
60236: LD_VAR 0 4
60240: PUSH
60241: FOR_TO
60242: IFFALSE 60296
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60244: LD_ADDR_EXP 37
60248: PUSH
60249: LD_EXP 37
60253: PPUSH
60254: LD_VAR 0 2
60258: PUSH
60259: LD_EXP 37
60263: PUSH
60264: LD_VAR 0 2
60268: ARRAY
60269: PUSH
60270: LD_INT 1
60272: PLUS
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PPUSH
60278: LD_VAR 0 6
60282: PUSH
60283: LD_VAR 0 3
60287: ARRAY
60288: PPUSH
60289: CALL 13619 0 3
60293: ST_TO_ADDR
60294: GO 60241
60296: POP
60297: POP
// end ;
60298: GO 59549
60300: POP
60301: POP
// end ;
60302: LD_VAR 0 1
60306: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
60307: LD_INT 0
60309: PPUSH
60310: PPUSH
60311: PPUSH
60312: PPUSH
60313: PPUSH
60314: PPUSH
60315: PPUSH
60316: PPUSH
60317: PPUSH
60318: PPUSH
// if not mc_bases then
60319: LD_EXP 23
60323: NOT
60324: IFFALSE 60328
// exit ;
60326: GO 62078
// for i = 1 to mc_bases do
60328: LD_ADDR_VAR 0 2
60332: PUSH
60333: DOUBLE
60334: LD_INT 1
60336: DEC
60337: ST_TO_ADDR
60338: LD_EXP 23
60342: PUSH
60343: FOR_TO
60344: IFFALSE 62076
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60346: LD_EXP 23
60350: PUSH
60351: LD_VAR 0 2
60355: ARRAY
60356: NOT
60357: PUSH
60358: LD_EXP 30
60362: PUSH
60363: LD_VAR 0 2
60367: ARRAY
60368: OR
60369: IFFALSE 60373
// continue ;
60371: GO 60343
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60373: LD_EXP 39
60377: PUSH
60378: LD_VAR 0 2
60382: ARRAY
60383: NOT
60384: PUSH
60385: LD_EXP 40
60389: PUSH
60390: LD_VAR 0 2
60394: ARRAY
60395: AND
60396: IFFALSE 60434
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60398: LD_ADDR_EXP 40
60402: PUSH
60403: LD_EXP 40
60407: PPUSH
60408: LD_VAR 0 2
60412: PPUSH
60413: EMPTY
60414: PPUSH
60415: CALL_OW 1
60419: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60420: LD_VAR 0 2
60424: PPUSH
60425: LD_INT 107
60427: PPUSH
60428: CALL 51261 0 2
// continue ;
60432: GO 60343
// end ; target := [ ] ;
60434: LD_ADDR_VAR 0 6
60438: PUSH
60439: EMPTY
60440: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
60441: LD_ADDR_VAR 0 3
60445: PUSH
60446: DOUBLE
60447: LD_EXP 39
60451: PUSH
60452: LD_VAR 0 2
60456: ARRAY
60457: INC
60458: ST_TO_ADDR
60459: LD_INT 1
60461: PUSH
60462: FOR_DOWNTO
60463: IFFALSE 60723
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
60465: LD_EXP 39
60469: PUSH
60470: LD_VAR 0 2
60474: ARRAY
60475: PUSH
60476: LD_VAR 0 3
60480: ARRAY
60481: PUSH
60482: LD_INT 2
60484: ARRAY
60485: PPUSH
60486: LD_EXP 39
60490: PUSH
60491: LD_VAR 0 2
60495: ARRAY
60496: PUSH
60497: LD_VAR 0 3
60501: ARRAY
60502: PUSH
60503: LD_INT 3
60505: ARRAY
60506: PPUSH
60507: CALL_OW 488
60511: PUSH
60512: LD_EXP 39
60516: PUSH
60517: LD_VAR 0 2
60521: ARRAY
60522: PUSH
60523: LD_VAR 0 3
60527: ARRAY
60528: PUSH
60529: LD_INT 2
60531: ARRAY
60532: PPUSH
60533: LD_EXP 39
60537: PUSH
60538: LD_VAR 0 2
60542: ARRAY
60543: PUSH
60544: LD_VAR 0 3
60548: ARRAY
60549: PUSH
60550: LD_INT 3
60552: ARRAY
60553: PPUSH
60554: CALL_OW 284
60558: PUSH
60559: LD_INT 0
60561: EQUAL
60562: AND
60563: IFFALSE 60618
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
60565: LD_ADDR_VAR 0 5
60569: PUSH
60570: LD_EXP 39
60574: PUSH
60575: LD_VAR 0 2
60579: ARRAY
60580: PPUSH
60581: LD_VAR 0 3
60585: PPUSH
60586: CALL_OW 3
60590: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
60591: LD_ADDR_EXP 39
60595: PUSH
60596: LD_EXP 39
60600: PPUSH
60601: LD_VAR 0 2
60605: PPUSH
60606: LD_VAR 0 5
60610: PPUSH
60611: CALL_OW 1
60615: ST_TO_ADDR
// continue ;
60616: GO 60462
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
60618: LD_EXP 23
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PUSH
60629: LD_INT 1
60631: ARRAY
60632: PPUSH
60633: CALL_OW 255
60637: PPUSH
60638: LD_EXP 39
60642: PUSH
60643: LD_VAR 0 2
60647: ARRAY
60648: PUSH
60649: LD_VAR 0 3
60653: ARRAY
60654: PUSH
60655: LD_INT 2
60657: ARRAY
60658: PPUSH
60659: LD_EXP 39
60663: PUSH
60664: LD_VAR 0 2
60668: ARRAY
60669: PUSH
60670: LD_VAR 0 3
60674: ARRAY
60675: PUSH
60676: LD_INT 3
60678: ARRAY
60679: PPUSH
60680: LD_INT 30
60682: PPUSH
60683: CALL 14515 0 4
60687: PUSH
60688: LD_INT 4
60690: ARRAY
60691: PUSH
60692: LD_INT 0
60694: EQUAL
60695: IFFALSE 60721
// begin target := mc_crates [ i ] [ j ] ;
60697: LD_ADDR_VAR 0 6
60701: PUSH
60702: LD_EXP 39
60706: PUSH
60707: LD_VAR 0 2
60711: ARRAY
60712: PUSH
60713: LD_VAR 0 3
60717: ARRAY
60718: ST_TO_ADDR
// break ;
60719: GO 60723
// end ; end ;
60721: GO 60462
60723: POP
60724: POP
// if not target then
60725: LD_VAR 0 6
60729: NOT
60730: IFFALSE 60734
// continue ;
60732: GO 60343
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
60734: LD_ADDR_VAR 0 7
60738: PUSH
60739: LD_EXP 42
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: PPUSH
60750: LD_INT 2
60752: PUSH
60753: LD_INT 3
60755: PUSH
60756: LD_INT 58
60758: PUSH
60759: EMPTY
60760: LIST
60761: PUSH
60762: EMPTY
60763: LIST
60764: LIST
60765: PUSH
60766: LD_INT 61
60768: PUSH
60769: EMPTY
60770: LIST
60771: PUSH
60772: LD_INT 33
60774: PUSH
60775: LD_INT 5
60777: PUSH
60778: EMPTY
60779: LIST
60780: LIST
60781: PUSH
60782: LD_INT 33
60784: PUSH
60785: LD_INT 3
60787: PUSH
60788: EMPTY
60789: LIST
60790: LIST
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: LIST
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 2
60801: PUSH
60802: LD_INT 34
60804: PUSH
60805: LD_INT 32
60807: PUSH
60808: EMPTY
60809: LIST
60810: LIST
60811: PUSH
60812: LD_INT 34
60814: PUSH
60815: LD_INT 51
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: LD_INT 34
60824: PUSH
60825: LD_INT 12
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: LIST
60836: LIST
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PPUSH
60842: CALL_OW 72
60846: ST_TO_ADDR
// if not cargo then
60847: LD_VAR 0 7
60851: NOT
60852: IFFALSE 61495
// begin if mc_crates_collector [ i ] < 5 then
60854: LD_EXP 40
60858: PUSH
60859: LD_VAR 0 2
60863: ARRAY
60864: PUSH
60865: LD_INT 5
60867: LESS
60868: IFFALSE 61234
// begin if mc_ape [ i ] then
60870: LD_EXP 52
60874: PUSH
60875: LD_VAR 0 2
60879: ARRAY
60880: IFFALSE 60927
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
60882: LD_ADDR_VAR 0 5
60886: PUSH
60887: LD_EXP 52
60891: PUSH
60892: LD_VAR 0 2
60896: ARRAY
60897: PPUSH
60898: LD_INT 25
60900: PUSH
60901: LD_INT 16
60903: PUSH
60904: EMPTY
60905: LIST
60906: LIST
60907: PUSH
60908: LD_INT 24
60910: PUSH
60911: LD_INT 750
60913: PUSH
60914: EMPTY
60915: LIST
60916: LIST
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: PPUSH
60922: CALL_OW 72
60926: ST_TO_ADDR
// if not tmp then
60927: LD_VAR 0 5
60931: NOT
60932: IFFALSE 60979
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
60934: LD_ADDR_VAR 0 5
60938: PUSH
60939: LD_EXP 23
60943: PUSH
60944: LD_VAR 0 2
60948: ARRAY
60949: PPUSH
60950: LD_INT 25
60952: PUSH
60953: LD_INT 2
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PUSH
60960: LD_INT 24
60962: PUSH
60963: LD_INT 750
60965: PUSH
60966: EMPTY
60967: LIST
60968: LIST
60969: PUSH
60970: EMPTY
60971: LIST
60972: LIST
60973: PPUSH
60974: CALL_OW 72
60978: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
60979: LD_EXP 52
60983: PUSH
60984: LD_VAR 0 2
60988: ARRAY
60989: PUSH
60990: LD_EXP 23
60994: PUSH
60995: LD_VAR 0 2
60999: ARRAY
61000: PPUSH
61001: LD_INT 25
61003: PUSH
61004: LD_INT 2
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: LD_INT 24
61013: PUSH
61014: LD_INT 750
61016: PUSH
61017: EMPTY
61018: LIST
61019: LIST
61020: PUSH
61021: EMPTY
61022: LIST
61023: LIST
61024: PPUSH
61025: CALL_OW 72
61029: AND
61030: PUSH
61031: LD_VAR 0 5
61035: PUSH
61036: LD_INT 5
61038: LESS
61039: AND
61040: IFFALSE 61122
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
61042: LD_ADDR_VAR 0 3
61046: PUSH
61047: LD_EXP 23
61051: PUSH
61052: LD_VAR 0 2
61056: ARRAY
61057: PPUSH
61058: LD_INT 25
61060: PUSH
61061: LD_INT 2
61063: PUSH
61064: EMPTY
61065: LIST
61066: LIST
61067: PUSH
61068: LD_INT 24
61070: PUSH
61071: LD_INT 750
61073: PUSH
61074: EMPTY
61075: LIST
61076: LIST
61077: PUSH
61078: EMPTY
61079: LIST
61080: LIST
61081: PPUSH
61082: CALL_OW 72
61086: PUSH
61087: FOR_IN
61088: IFFALSE 61120
// begin tmp := tmp union j ;
61090: LD_ADDR_VAR 0 5
61094: PUSH
61095: LD_VAR 0 5
61099: PUSH
61100: LD_VAR 0 3
61104: UNION
61105: ST_TO_ADDR
// if tmp >= 5 then
61106: LD_VAR 0 5
61110: PUSH
61111: LD_INT 5
61113: GREATEREQUAL
61114: IFFALSE 61118
// break ;
61116: GO 61120
// end ;
61118: GO 61087
61120: POP
61121: POP
// end ; if not tmp then
61122: LD_VAR 0 5
61126: NOT
61127: IFFALSE 61131
// continue ;
61129: GO 60343
// for j in tmp do
61131: LD_ADDR_VAR 0 3
61135: PUSH
61136: LD_VAR 0 5
61140: PUSH
61141: FOR_IN
61142: IFFALSE 61232
// if not GetTag ( j ) then
61144: LD_VAR 0 3
61148: PPUSH
61149: CALL_OW 110
61153: NOT
61154: IFFALSE 61230
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61156: LD_ADDR_EXP 40
61160: PUSH
61161: LD_EXP 40
61165: PPUSH
61166: LD_VAR 0 2
61170: PUSH
61171: LD_EXP 40
61175: PUSH
61176: LD_VAR 0 2
61180: ARRAY
61181: PUSH
61182: LD_INT 1
61184: PLUS
61185: PUSH
61186: EMPTY
61187: LIST
61188: LIST
61189: PPUSH
61190: LD_VAR 0 3
61194: PPUSH
61195: CALL 13619 0 3
61199: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61200: LD_VAR 0 3
61204: PPUSH
61205: LD_INT 107
61207: PPUSH
61208: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61212: LD_EXP 40
61216: PUSH
61217: LD_VAR 0 2
61221: ARRAY
61222: PUSH
61223: LD_INT 5
61225: GREATEREQUAL
61226: IFFALSE 61230
// break ;
61228: GO 61232
// end ;
61230: GO 61141
61232: POP
61233: POP
// end ; if mc_crates_collector [ i ] and target then
61234: LD_EXP 40
61238: PUSH
61239: LD_VAR 0 2
61243: ARRAY
61244: PUSH
61245: LD_VAR 0 6
61249: AND
61250: IFFALSE 61493
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61252: LD_EXP 40
61256: PUSH
61257: LD_VAR 0 2
61261: ARRAY
61262: PUSH
61263: LD_VAR 0 6
61267: PUSH
61268: LD_INT 1
61270: ARRAY
61271: LESS
61272: IFFALSE 61292
// tmp := mc_crates_collector [ i ] else
61274: LD_ADDR_VAR 0 5
61278: PUSH
61279: LD_EXP 40
61283: PUSH
61284: LD_VAR 0 2
61288: ARRAY
61289: ST_TO_ADDR
61290: GO 61306
// tmp := target [ 1 ] ;
61292: LD_ADDR_VAR 0 5
61296: PUSH
61297: LD_VAR 0 6
61301: PUSH
61302: LD_INT 1
61304: ARRAY
61305: ST_TO_ADDR
// k := 0 ;
61306: LD_ADDR_VAR 0 4
61310: PUSH
61311: LD_INT 0
61313: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61314: LD_ADDR_VAR 0 3
61318: PUSH
61319: LD_EXP 40
61323: PUSH
61324: LD_VAR 0 2
61328: ARRAY
61329: PUSH
61330: FOR_IN
61331: IFFALSE 61491
// begin k := k + 1 ;
61333: LD_ADDR_VAR 0 4
61337: PUSH
61338: LD_VAR 0 4
61342: PUSH
61343: LD_INT 1
61345: PLUS
61346: ST_TO_ADDR
// if k > tmp then
61347: LD_VAR 0 4
61351: PUSH
61352: LD_VAR 0 5
61356: GREATER
61357: IFFALSE 61361
// break ;
61359: GO 61491
// if not GetClass ( j ) in [ 2 , 16 ] then
61361: LD_VAR 0 3
61365: PPUSH
61366: CALL_OW 257
61370: PUSH
61371: LD_INT 2
61373: PUSH
61374: LD_INT 16
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: IN
61381: NOT
61382: IFFALSE 61435
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61384: LD_ADDR_EXP 40
61388: PUSH
61389: LD_EXP 40
61393: PPUSH
61394: LD_VAR 0 2
61398: PPUSH
61399: LD_EXP 40
61403: PUSH
61404: LD_VAR 0 2
61408: ARRAY
61409: PUSH
61410: LD_VAR 0 3
61414: DIFF
61415: PPUSH
61416: CALL_OW 1
61420: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61421: LD_VAR 0 3
61425: PPUSH
61426: LD_INT 0
61428: PPUSH
61429: CALL_OW 109
// continue ;
61433: GO 61330
// end ; if IsInUnit ( j ) then
61435: LD_VAR 0 3
61439: PPUSH
61440: CALL_OW 310
61444: IFFALSE 61455
// ComExitBuilding ( j ) ;
61446: LD_VAR 0 3
61450: PPUSH
61451: CALL_OW 122
// wait ( 3 ) ;
61455: LD_INT 3
61457: PPUSH
61458: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
61462: LD_VAR 0 3
61466: PPUSH
61467: LD_VAR 0 6
61471: PUSH
61472: LD_INT 2
61474: ARRAY
61475: PPUSH
61476: LD_VAR 0 6
61480: PUSH
61481: LD_INT 3
61483: ARRAY
61484: PPUSH
61485: CALL_OW 117
// end ;
61489: GO 61330
61491: POP
61492: POP
// end ; end else
61493: GO 62074
// begin for j in cargo do
61495: LD_ADDR_VAR 0 3
61499: PUSH
61500: LD_VAR 0 7
61504: PUSH
61505: FOR_IN
61506: IFFALSE 62072
// begin if GetTag ( j ) <> 0 then
61508: LD_VAR 0 3
61512: PPUSH
61513: CALL_OW 110
61517: PUSH
61518: LD_INT 0
61520: NONEQUAL
61521: IFFALSE 61525
// continue ;
61523: GO 61505
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
61525: LD_VAR 0 3
61529: PPUSH
61530: CALL_OW 256
61534: PUSH
61535: LD_INT 1000
61537: LESS
61538: PUSH
61539: LD_VAR 0 3
61543: PPUSH
61544: LD_EXP 47
61548: PUSH
61549: LD_VAR 0 2
61553: ARRAY
61554: PPUSH
61555: CALL_OW 308
61559: NOT
61560: AND
61561: IFFALSE 61583
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61563: LD_VAR 0 3
61567: PPUSH
61568: LD_EXP 47
61572: PUSH
61573: LD_VAR 0 2
61577: ARRAY
61578: PPUSH
61579: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
61583: LD_VAR 0 3
61587: PPUSH
61588: CALL_OW 256
61592: PUSH
61593: LD_INT 1000
61595: LESS
61596: PUSH
61597: LD_VAR 0 3
61601: PPUSH
61602: LD_EXP 47
61606: PUSH
61607: LD_VAR 0 2
61611: ARRAY
61612: PPUSH
61613: CALL_OW 308
61617: AND
61618: IFFALSE 61622
// continue ;
61620: GO 61505
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
61622: LD_VAR 0 3
61626: PPUSH
61627: CALL_OW 262
61631: PUSH
61632: LD_INT 2
61634: EQUAL
61635: PUSH
61636: LD_VAR 0 3
61640: PPUSH
61641: CALL_OW 261
61645: PUSH
61646: LD_INT 15
61648: LESS
61649: AND
61650: IFFALSE 61654
// continue ;
61652: GO 61505
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
61654: LD_VAR 0 3
61658: PPUSH
61659: CALL_OW 262
61663: PUSH
61664: LD_INT 1
61666: EQUAL
61667: PUSH
61668: LD_VAR 0 3
61672: PPUSH
61673: CALL_OW 261
61677: PUSH
61678: LD_INT 10
61680: LESS
61681: AND
61682: IFFALSE 62011
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61684: LD_ADDR_VAR 0 8
61688: PUSH
61689: LD_EXP 23
61693: PUSH
61694: LD_VAR 0 2
61698: ARRAY
61699: PPUSH
61700: LD_INT 2
61702: PUSH
61703: LD_INT 30
61705: PUSH
61706: LD_INT 0
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: LD_INT 30
61715: PUSH
61716: LD_INT 1
61718: PUSH
61719: EMPTY
61720: LIST
61721: LIST
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: LIST
61727: PPUSH
61728: CALL_OW 72
61732: ST_TO_ADDR
// if not depot then
61733: LD_VAR 0 8
61737: NOT
61738: IFFALSE 61742
// continue ;
61740: GO 61505
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
61742: LD_VAR 0 3
61746: PPUSH
61747: LD_VAR 0 8
61751: PPUSH
61752: LD_VAR 0 3
61756: PPUSH
61757: CALL_OW 74
61761: PPUSH
61762: CALL_OW 296
61766: PUSH
61767: LD_INT 6
61769: LESS
61770: IFFALSE 61786
// SetFuel ( j , 100 ) else
61772: LD_VAR 0 3
61776: PPUSH
61777: LD_INT 100
61779: PPUSH
61780: CALL_OW 240
61784: GO 62011
// if GetFuel ( j ) = 0 then
61786: LD_VAR 0 3
61790: PPUSH
61791: CALL_OW 261
61795: PUSH
61796: LD_INT 0
61798: EQUAL
61799: IFFALSE 62011
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
61801: LD_ADDR_EXP 42
61805: PUSH
61806: LD_EXP 42
61810: PPUSH
61811: LD_VAR 0 2
61815: PPUSH
61816: LD_EXP 42
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PUSH
61827: LD_VAR 0 3
61831: DIFF
61832: PPUSH
61833: CALL_OW 1
61837: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
61838: LD_VAR 0 3
61842: PPUSH
61843: CALL_OW 263
61847: PUSH
61848: LD_INT 1
61850: EQUAL
61851: IFFALSE 61867
// ComExitVehicle ( IsInUnit ( j ) ) ;
61853: LD_VAR 0 3
61857: PPUSH
61858: CALL_OW 310
61862: PPUSH
61863: CALL_OW 121
// if GetControl ( j ) = control_remote then
61867: LD_VAR 0 3
61871: PPUSH
61872: CALL_OW 263
61876: PUSH
61877: LD_INT 2
61879: EQUAL
61880: IFFALSE 61891
// ComUnlink ( j ) ;
61882: LD_VAR 0 3
61886: PPUSH
61887: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
61891: LD_ADDR_VAR 0 9
61895: PUSH
61896: LD_VAR 0 2
61900: PPUSH
61901: LD_INT 3
61903: PPUSH
61904: CALL 71481 0 2
61908: ST_TO_ADDR
// if fac then
61909: LD_VAR 0 9
61913: IFFALSE 62009
// begin for k in fac do
61915: LD_ADDR_VAR 0 4
61919: PUSH
61920: LD_VAR 0 9
61924: PUSH
61925: FOR_IN
61926: IFFALSE 62007
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
61928: LD_ADDR_VAR 0 10
61932: PUSH
61933: LD_VAR 0 9
61937: PPUSH
61938: LD_VAR 0 3
61942: PPUSH
61943: CALL_OW 265
61947: PPUSH
61948: LD_VAR 0 3
61952: PPUSH
61953: CALL_OW 262
61957: PPUSH
61958: LD_VAR 0 3
61962: PPUSH
61963: CALL_OW 263
61967: PPUSH
61968: LD_VAR 0 3
61972: PPUSH
61973: CALL_OW 264
61977: PPUSH
61978: CALL 11115 0 5
61982: ST_TO_ADDR
// if components then
61983: LD_VAR 0 10
61987: IFFALSE 62005
// begin MC_InsertProduceList ( i , components ) ;
61989: LD_VAR 0 2
61993: PPUSH
61994: LD_VAR 0 10
61998: PPUSH
61999: CALL 71026 0 2
// break ;
62003: GO 62007
// end ; end ;
62005: GO 61925
62007: POP
62008: POP
// end ; continue ;
62009: GO 61505
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
62011: LD_VAR 0 3
62015: PPUSH
62016: LD_INT 1
62018: PPUSH
62019: CALL_OW 289
62023: PUSH
62024: LD_INT 100
62026: LESS
62027: PUSH
62028: LD_VAR 0 3
62032: PPUSH
62033: CALL_OW 314
62037: NOT
62038: AND
62039: IFFALSE 62068
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
62041: LD_VAR 0 3
62045: PPUSH
62046: LD_VAR 0 6
62050: PUSH
62051: LD_INT 2
62053: ARRAY
62054: PPUSH
62055: LD_VAR 0 6
62059: PUSH
62060: LD_INT 3
62062: ARRAY
62063: PPUSH
62064: CALL_OW 117
// break ;
62068: GO 62072
// end ;
62070: GO 61505
62072: POP
62073: POP
// end ; end ;
62074: GO 60343
62076: POP
62077: POP
// end ;
62078: LD_VAR 0 1
62082: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
62083: LD_INT 0
62085: PPUSH
62086: PPUSH
62087: PPUSH
62088: PPUSH
// if not mc_bases then
62089: LD_EXP 23
62093: NOT
62094: IFFALSE 62098
// exit ;
62096: GO 62259
// for i = 1 to mc_bases do
62098: LD_ADDR_VAR 0 2
62102: PUSH
62103: DOUBLE
62104: LD_INT 1
62106: DEC
62107: ST_TO_ADDR
62108: LD_EXP 23
62112: PUSH
62113: FOR_TO
62114: IFFALSE 62257
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
62116: LD_ADDR_VAR 0 4
62120: PUSH
62121: LD_EXP 42
62125: PUSH
62126: LD_VAR 0 2
62130: ARRAY
62131: PUSH
62132: LD_EXP 45
62136: PUSH
62137: LD_VAR 0 2
62141: ARRAY
62142: UNION
62143: PPUSH
62144: LD_INT 33
62146: PUSH
62147: LD_INT 2
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: PPUSH
62154: CALL_OW 72
62158: ST_TO_ADDR
// if tmp then
62159: LD_VAR 0 4
62163: IFFALSE 62255
// for j in tmp do
62165: LD_ADDR_VAR 0 3
62169: PUSH
62170: LD_VAR 0 4
62174: PUSH
62175: FOR_IN
62176: IFFALSE 62253
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62178: LD_VAR 0 3
62182: PPUSH
62183: CALL_OW 312
62187: NOT
62188: PUSH
62189: LD_VAR 0 3
62193: PPUSH
62194: CALL_OW 256
62198: PUSH
62199: LD_INT 250
62201: GREATEREQUAL
62202: AND
62203: IFFALSE 62216
// Connect ( j ) else
62205: LD_VAR 0 3
62209: PPUSH
62210: CALL 16590 0 1
62214: GO 62251
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62216: LD_VAR 0 3
62220: PPUSH
62221: CALL_OW 256
62225: PUSH
62226: LD_INT 250
62228: LESS
62229: PUSH
62230: LD_VAR 0 3
62234: PPUSH
62235: CALL_OW 312
62239: AND
62240: IFFALSE 62251
// ComUnlink ( j ) ;
62242: LD_VAR 0 3
62246: PPUSH
62247: CALL_OW 136
62251: GO 62175
62253: POP
62254: POP
// end ;
62255: GO 62113
62257: POP
62258: POP
// end ;
62259: LD_VAR 0 1
62263: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62264: LD_INT 0
62266: PPUSH
62267: PPUSH
62268: PPUSH
62269: PPUSH
62270: PPUSH
// if not mc_bases then
62271: LD_EXP 23
62275: NOT
62276: IFFALSE 62280
// exit ;
62278: GO 62725
// for i = 1 to mc_bases do
62280: LD_ADDR_VAR 0 2
62284: PUSH
62285: DOUBLE
62286: LD_INT 1
62288: DEC
62289: ST_TO_ADDR
62290: LD_EXP 23
62294: PUSH
62295: FOR_TO
62296: IFFALSE 62723
// begin if not mc_produce [ i ] then
62298: LD_EXP 44
62302: PUSH
62303: LD_VAR 0 2
62307: ARRAY
62308: NOT
62309: IFFALSE 62313
// continue ;
62311: GO 62295
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62313: LD_ADDR_VAR 0 5
62317: PUSH
62318: LD_EXP 23
62322: PUSH
62323: LD_VAR 0 2
62327: ARRAY
62328: PPUSH
62329: LD_INT 30
62331: PUSH
62332: LD_INT 3
62334: PUSH
62335: EMPTY
62336: LIST
62337: LIST
62338: PPUSH
62339: CALL_OW 72
62343: ST_TO_ADDR
// if not fac then
62344: LD_VAR 0 5
62348: NOT
62349: IFFALSE 62353
// continue ;
62351: GO 62295
// for j in fac do
62353: LD_ADDR_VAR 0 3
62357: PUSH
62358: LD_VAR 0 5
62362: PUSH
62363: FOR_IN
62364: IFFALSE 62719
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62366: LD_VAR 0 3
62370: PPUSH
62371: CALL_OW 461
62375: PUSH
62376: LD_INT 2
62378: NONEQUAL
62379: PUSH
62380: LD_VAR 0 3
62384: PPUSH
62385: LD_INT 15
62387: PPUSH
62388: CALL 16218 0 2
62392: PUSH
62393: LD_INT 4
62395: ARRAY
62396: OR
62397: IFFALSE 62401
// continue ;
62399: GO 62363
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62401: LD_VAR 0 3
62405: PPUSH
62406: LD_EXP 44
62410: PUSH
62411: LD_VAR 0 2
62415: ARRAY
62416: PUSH
62417: LD_INT 1
62419: ARRAY
62420: PUSH
62421: LD_INT 1
62423: ARRAY
62424: PPUSH
62425: LD_EXP 44
62429: PUSH
62430: LD_VAR 0 2
62434: ARRAY
62435: PUSH
62436: LD_INT 1
62438: ARRAY
62439: PUSH
62440: LD_INT 2
62442: ARRAY
62443: PPUSH
62444: LD_EXP 44
62448: PUSH
62449: LD_VAR 0 2
62453: ARRAY
62454: PUSH
62455: LD_INT 1
62457: ARRAY
62458: PUSH
62459: LD_INT 3
62461: ARRAY
62462: PPUSH
62463: LD_EXP 44
62467: PUSH
62468: LD_VAR 0 2
62472: ARRAY
62473: PUSH
62474: LD_INT 1
62476: ARRAY
62477: PUSH
62478: LD_INT 4
62480: ARRAY
62481: PPUSH
62482: CALL_OW 448
62486: PUSH
62487: LD_VAR 0 3
62491: PPUSH
62492: LD_EXP 44
62496: PUSH
62497: LD_VAR 0 2
62501: ARRAY
62502: PUSH
62503: LD_INT 1
62505: ARRAY
62506: PUSH
62507: LD_INT 1
62509: ARRAY
62510: PUSH
62511: LD_EXP 44
62515: PUSH
62516: LD_VAR 0 2
62520: ARRAY
62521: PUSH
62522: LD_INT 1
62524: ARRAY
62525: PUSH
62526: LD_INT 2
62528: ARRAY
62529: PUSH
62530: LD_EXP 44
62534: PUSH
62535: LD_VAR 0 2
62539: ARRAY
62540: PUSH
62541: LD_INT 1
62543: ARRAY
62544: PUSH
62545: LD_INT 3
62547: ARRAY
62548: PUSH
62549: LD_EXP 44
62553: PUSH
62554: LD_VAR 0 2
62558: ARRAY
62559: PUSH
62560: LD_INT 1
62562: ARRAY
62563: PUSH
62564: LD_INT 4
62566: ARRAY
62567: PUSH
62568: EMPTY
62569: LIST
62570: LIST
62571: LIST
62572: LIST
62573: PPUSH
62574: CALL 19986 0 2
62578: AND
62579: IFFALSE 62717
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
62581: LD_VAR 0 3
62585: PPUSH
62586: LD_EXP 44
62590: PUSH
62591: LD_VAR 0 2
62595: ARRAY
62596: PUSH
62597: LD_INT 1
62599: ARRAY
62600: PUSH
62601: LD_INT 1
62603: ARRAY
62604: PPUSH
62605: LD_EXP 44
62609: PUSH
62610: LD_VAR 0 2
62614: ARRAY
62615: PUSH
62616: LD_INT 1
62618: ARRAY
62619: PUSH
62620: LD_INT 2
62622: ARRAY
62623: PPUSH
62624: LD_EXP 44
62628: PUSH
62629: LD_VAR 0 2
62633: ARRAY
62634: PUSH
62635: LD_INT 1
62637: ARRAY
62638: PUSH
62639: LD_INT 3
62641: ARRAY
62642: PPUSH
62643: LD_EXP 44
62647: PUSH
62648: LD_VAR 0 2
62652: ARRAY
62653: PUSH
62654: LD_INT 1
62656: ARRAY
62657: PUSH
62658: LD_INT 4
62660: ARRAY
62661: PPUSH
62662: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
62666: LD_ADDR_VAR 0 4
62670: PUSH
62671: LD_EXP 44
62675: PUSH
62676: LD_VAR 0 2
62680: ARRAY
62681: PPUSH
62682: LD_INT 1
62684: PPUSH
62685: CALL_OW 3
62689: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62690: LD_ADDR_EXP 44
62694: PUSH
62695: LD_EXP 44
62699: PPUSH
62700: LD_VAR 0 2
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: CALL_OW 1
62714: ST_TO_ADDR
// break ;
62715: GO 62719
// end ; end ;
62717: GO 62363
62719: POP
62720: POP
// end ;
62721: GO 62295
62723: POP
62724: POP
// end ;
62725: LD_VAR 0 1
62729: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
62730: LD_INT 0
62732: PPUSH
62733: PPUSH
62734: PPUSH
// if not mc_bases then
62735: LD_EXP 23
62739: NOT
62740: IFFALSE 62744
// exit ;
62742: GO 62833
// for i = 1 to mc_bases do
62744: LD_ADDR_VAR 0 2
62748: PUSH
62749: DOUBLE
62750: LD_INT 1
62752: DEC
62753: ST_TO_ADDR
62754: LD_EXP 23
62758: PUSH
62759: FOR_TO
62760: IFFALSE 62831
// begin if mc_attack [ i ] then
62762: LD_EXP 43
62766: PUSH
62767: LD_VAR 0 2
62771: ARRAY
62772: IFFALSE 62829
// begin tmp := mc_attack [ i ] [ 1 ] ;
62774: LD_ADDR_VAR 0 3
62778: PUSH
62779: LD_EXP 43
62783: PUSH
62784: LD_VAR 0 2
62788: ARRAY
62789: PUSH
62790: LD_INT 1
62792: ARRAY
62793: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62794: LD_ADDR_EXP 43
62798: PUSH
62799: LD_EXP 43
62803: PPUSH
62804: LD_VAR 0 2
62808: PPUSH
62809: EMPTY
62810: PPUSH
62811: CALL_OW 1
62815: ST_TO_ADDR
// Attack ( tmp ) ;
62816: LD_VAR 0 3
62820: PPUSH
62821: CALL 77591 0 1
// exit ;
62825: POP
62826: POP
62827: GO 62833
// end ; end ;
62829: GO 62759
62831: POP
62832: POP
// end ;
62833: LD_VAR 0 1
62837: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
62838: LD_INT 0
62840: PPUSH
62841: PPUSH
62842: PPUSH
62843: PPUSH
62844: PPUSH
62845: PPUSH
62846: PPUSH
// if not mc_bases then
62847: LD_EXP 23
62851: NOT
62852: IFFALSE 62856
// exit ;
62854: GO 63555
// for i = 1 to mc_bases do
62856: LD_ADDR_VAR 0 2
62860: PUSH
62861: DOUBLE
62862: LD_INT 1
62864: DEC
62865: ST_TO_ADDR
62866: LD_EXP 23
62870: PUSH
62871: FOR_TO
62872: IFFALSE 63553
// begin if not mc_bases [ i ] then
62874: LD_EXP 23
62878: PUSH
62879: LD_VAR 0 2
62883: ARRAY
62884: NOT
62885: IFFALSE 62889
// continue ;
62887: GO 62871
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
62889: LD_ADDR_VAR 0 7
62893: PUSH
62894: LD_EXP 23
62898: PUSH
62899: LD_VAR 0 2
62903: ARRAY
62904: PUSH
62905: LD_INT 1
62907: ARRAY
62908: PPUSH
62909: CALL 10419 0 1
62913: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
62914: LD_ADDR_EXP 46
62918: PUSH
62919: LD_EXP 46
62923: PPUSH
62924: LD_VAR 0 2
62928: PPUSH
62929: LD_EXP 23
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: PUSH
62940: LD_INT 1
62942: ARRAY
62943: PPUSH
62944: CALL_OW 255
62948: PPUSH
62949: LD_EXP 48
62953: PUSH
62954: LD_VAR 0 2
62958: ARRAY
62959: PPUSH
62960: CALL 10384 0 2
62964: PPUSH
62965: CALL_OW 1
62969: ST_TO_ADDR
// if not mc_scan [ i ] then
62970: LD_EXP 46
62974: PUSH
62975: LD_VAR 0 2
62979: ARRAY
62980: NOT
62981: IFFALSE 63159
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62983: LD_ADDR_VAR 0 4
62987: PUSH
62988: LD_EXP 23
62992: PUSH
62993: LD_VAR 0 2
62997: ARRAY
62998: PPUSH
62999: LD_INT 2
63001: PUSH
63002: LD_INT 25
63004: PUSH
63005: LD_INT 5
63007: PUSH
63008: EMPTY
63009: LIST
63010: LIST
63011: PUSH
63012: LD_INT 25
63014: PUSH
63015: LD_INT 8
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: PUSH
63022: LD_INT 25
63024: PUSH
63025: LD_INT 9
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: LIST
63037: PPUSH
63038: CALL_OW 72
63042: ST_TO_ADDR
// if not tmp then
63043: LD_VAR 0 4
63047: NOT
63048: IFFALSE 63052
// continue ;
63050: GO 62871
// for j in tmp do
63052: LD_ADDR_VAR 0 3
63056: PUSH
63057: LD_VAR 0 4
63061: PUSH
63062: FOR_IN
63063: IFFALSE 63134
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
63065: LD_VAR 0 3
63069: PPUSH
63070: CALL_OW 310
63074: PPUSH
63075: CALL_OW 266
63079: PUSH
63080: LD_INT 5
63082: EQUAL
63083: PUSH
63084: LD_VAR 0 3
63088: PPUSH
63089: CALL_OW 257
63093: PUSH
63094: LD_INT 1
63096: EQUAL
63097: AND
63098: PUSH
63099: LD_VAR 0 3
63103: PPUSH
63104: CALL_OW 459
63108: NOT
63109: AND
63110: PUSH
63111: LD_VAR 0 7
63115: AND
63116: IFFALSE 63132
// ComChangeProfession ( j , class ) ;
63118: LD_VAR 0 3
63122: PPUSH
63123: LD_VAR 0 7
63127: PPUSH
63128: CALL_OW 123
63132: GO 63062
63134: POP
63135: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63136: LD_ADDR_EXP 66
63140: PUSH
63141: LD_EXP 66
63145: PPUSH
63146: LD_VAR 0 2
63150: PPUSH
63151: LD_INT 0
63153: PPUSH
63154: CALL_OW 1
63158: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
63159: LD_EXP 46
63163: PUSH
63164: LD_VAR 0 2
63168: ARRAY
63169: PUSH
63170: LD_EXP 66
63174: PUSH
63175: LD_VAR 0 2
63179: ARRAY
63180: NOT
63181: AND
63182: PUSH
63183: LD_EXP 45
63187: PUSH
63188: LD_VAR 0 2
63192: ARRAY
63193: NOT
63194: AND
63195: PUSH
63196: LD_EXP 23
63200: PUSH
63201: LD_VAR 0 2
63205: ARRAY
63206: PPUSH
63207: LD_INT 30
63209: PUSH
63210: LD_INT 32
63212: PUSH
63213: EMPTY
63214: LIST
63215: LIST
63216: PPUSH
63217: CALL_OW 72
63221: NOT
63222: AND
63223: PUSH
63224: LD_EXP 23
63228: PUSH
63229: LD_VAR 0 2
63233: ARRAY
63234: PPUSH
63235: LD_INT 2
63237: PUSH
63238: LD_INT 30
63240: PUSH
63241: LD_INT 4
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: LD_INT 30
63250: PUSH
63251: LD_INT 5
63253: PUSH
63254: EMPTY
63255: LIST
63256: LIST
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: LIST
63262: PPUSH
63263: CALL_OW 72
63267: NOT
63268: AND
63269: IFFALSE 63424
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63271: LD_ADDR_VAR 0 4
63275: PUSH
63276: LD_EXP 23
63280: PUSH
63281: LD_VAR 0 2
63285: ARRAY
63286: PPUSH
63287: LD_INT 2
63289: PUSH
63290: LD_INT 25
63292: PUSH
63293: LD_INT 1
63295: PUSH
63296: EMPTY
63297: LIST
63298: LIST
63299: PUSH
63300: LD_INT 25
63302: PUSH
63303: LD_INT 5
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: PUSH
63310: LD_INT 25
63312: PUSH
63313: LD_INT 8
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PUSH
63320: LD_INT 25
63322: PUSH
63323: LD_INT 9
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: PPUSH
63337: CALL_OW 72
63341: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63342: LD_ADDR_VAR 0 4
63346: PUSH
63347: LD_VAR 0 4
63351: PUSH
63352: LD_VAR 0 4
63356: PPUSH
63357: LD_INT 18
63359: PPUSH
63360: CALL 42889 0 2
63364: DIFF
63365: ST_TO_ADDR
// if tmp then
63366: LD_VAR 0 4
63370: IFFALSE 63424
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
63372: LD_ADDR_EXP 66
63376: PUSH
63377: LD_EXP 66
63381: PPUSH
63382: LD_VAR 0 2
63386: PPUSH
63387: LD_INT 1
63389: PPUSH
63390: CALL_OW 1
63394: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63395: LD_VAR 0 2
63399: PPUSH
63400: LD_VAR 0 4
63404: PPUSH
63405: LD_EXP 48
63409: PUSH
63410: LD_VAR 0 2
63414: ARRAY
63415: PPUSH
63416: CALL 82300 0 3
// exit ;
63420: POP
63421: POP
63422: GO 63555
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
63424: LD_EXP 46
63428: PUSH
63429: LD_VAR 0 2
63433: ARRAY
63434: PUSH
63435: LD_EXP 66
63439: PUSH
63440: LD_VAR 0 2
63444: ARRAY
63445: NOT
63446: AND
63447: PUSH
63448: LD_EXP 45
63452: PUSH
63453: LD_VAR 0 2
63457: ARRAY
63458: AND
63459: IFFALSE 63551
// begin tmp := mc_defender [ i ] ;
63461: LD_ADDR_VAR 0 4
63465: PUSH
63466: LD_EXP 45
63470: PUSH
63471: LD_VAR 0 2
63475: ARRAY
63476: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63477: LD_ADDR_EXP 45
63481: PUSH
63482: LD_EXP 45
63486: PPUSH
63487: LD_VAR 0 2
63491: PPUSH
63492: EMPTY
63493: PPUSH
63494: CALL_OW 1
63498: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
63499: LD_ADDR_EXP 66
63503: PUSH
63504: LD_EXP 66
63508: PPUSH
63509: LD_VAR 0 2
63513: PPUSH
63514: LD_INT 1
63516: PPUSH
63517: CALL_OW 1
63521: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
63522: LD_VAR 0 2
63526: PPUSH
63527: LD_VAR 0 4
63531: PPUSH
63532: LD_EXP 46
63536: PUSH
63537: LD_VAR 0 2
63541: ARRAY
63542: PPUSH
63543: CALL 82861 0 3
// exit ;
63547: POP
63548: POP
63549: GO 63555
// end ; end ;
63551: GO 62871
63553: POP
63554: POP
// end ;
63555: LD_VAR 0 1
63559: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
63560: LD_INT 0
63562: PPUSH
63563: PPUSH
63564: PPUSH
63565: PPUSH
63566: PPUSH
63567: PPUSH
63568: PPUSH
63569: PPUSH
63570: PPUSH
63571: PPUSH
63572: PPUSH
// if not mc_bases then
63573: LD_EXP 23
63577: NOT
63578: IFFALSE 63582
// exit ;
63580: GO 64669
// for i = 1 to mc_bases do
63582: LD_ADDR_VAR 0 2
63586: PUSH
63587: DOUBLE
63588: LD_INT 1
63590: DEC
63591: ST_TO_ADDR
63592: LD_EXP 23
63596: PUSH
63597: FOR_TO
63598: IFFALSE 64667
// begin tmp := mc_lab [ i ] ;
63600: LD_ADDR_VAR 0 6
63604: PUSH
63605: LD_EXP 56
63609: PUSH
63610: LD_VAR 0 2
63614: ARRAY
63615: ST_TO_ADDR
// if not tmp then
63616: LD_VAR 0 6
63620: NOT
63621: IFFALSE 63625
// continue ;
63623: GO 63597
// idle_lab := 0 ;
63625: LD_ADDR_VAR 0 11
63629: PUSH
63630: LD_INT 0
63632: ST_TO_ADDR
// for j in tmp do
63633: LD_ADDR_VAR 0 3
63637: PUSH
63638: LD_VAR 0 6
63642: PUSH
63643: FOR_IN
63644: IFFALSE 64663
// begin researching := false ;
63646: LD_ADDR_VAR 0 10
63650: PUSH
63651: LD_INT 0
63653: ST_TO_ADDR
// side := GetSide ( j ) ;
63654: LD_ADDR_VAR 0 4
63658: PUSH
63659: LD_VAR 0 3
63663: PPUSH
63664: CALL_OW 255
63668: ST_TO_ADDR
// if not mc_tech [ side ] then
63669: LD_EXP 50
63673: PUSH
63674: LD_VAR 0 4
63678: ARRAY
63679: NOT
63680: IFFALSE 63684
// continue ;
63682: GO 63643
// if BuildingStatus ( j ) = bs_idle then
63684: LD_VAR 0 3
63688: PPUSH
63689: CALL_OW 461
63693: PUSH
63694: LD_INT 2
63696: EQUAL
63697: IFFALSE 63885
// begin if idle_lab and UnitsInside ( j ) < 6 then
63699: LD_VAR 0 11
63703: PUSH
63704: LD_VAR 0 3
63708: PPUSH
63709: CALL_OW 313
63713: PUSH
63714: LD_INT 6
63716: LESS
63717: AND
63718: IFFALSE 63789
// begin tmp2 := UnitsInside ( idle_lab ) ;
63720: LD_ADDR_VAR 0 9
63724: PUSH
63725: LD_VAR 0 11
63729: PPUSH
63730: CALL_OW 313
63734: ST_TO_ADDR
// if tmp2 then
63735: LD_VAR 0 9
63739: IFFALSE 63781
// for x in tmp2 do
63741: LD_ADDR_VAR 0 7
63745: PUSH
63746: LD_VAR 0 9
63750: PUSH
63751: FOR_IN
63752: IFFALSE 63779
// begin ComExitBuilding ( x ) ;
63754: LD_VAR 0 7
63758: PPUSH
63759: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
63763: LD_VAR 0 7
63767: PPUSH
63768: LD_VAR 0 3
63772: PPUSH
63773: CALL_OW 180
// end ;
63777: GO 63751
63779: POP
63780: POP
// idle_lab := 0 ;
63781: LD_ADDR_VAR 0 11
63785: PUSH
63786: LD_INT 0
63788: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
63789: LD_ADDR_VAR 0 5
63793: PUSH
63794: LD_EXP 50
63798: PUSH
63799: LD_VAR 0 4
63803: ARRAY
63804: PUSH
63805: FOR_IN
63806: IFFALSE 63866
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
63808: LD_VAR 0 3
63812: PPUSH
63813: LD_VAR 0 5
63817: PPUSH
63818: CALL_OW 430
63822: PUSH
63823: LD_VAR 0 4
63827: PPUSH
63828: LD_VAR 0 5
63832: PPUSH
63833: CALL 9489 0 2
63837: AND
63838: IFFALSE 63864
// begin researching := true ;
63840: LD_ADDR_VAR 0 10
63844: PUSH
63845: LD_INT 1
63847: ST_TO_ADDR
// ComResearch ( j , t ) ;
63848: LD_VAR 0 3
63852: PPUSH
63853: LD_VAR 0 5
63857: PPUSH
63858: CALL_OW 124
// break ;
63862: GO 63866
// end ;
63864: GO 63805
63866: POP
63867: POP
// if not researching then
63868: LD_VAR 0 10
63872: NOT
63873: IFFALSE 63885
// idle_lab := j ;
63875: LD_ADDR_VAR 0 11
63879: PUSH
63880: LD_VAR 0 3
63884: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
63885: LD_VAR 0 3
63889: PPUSH
63890: CALL_OW 461
63894: PUSH
63895: LD_INT 10
63897: EQUAL
63898: IFFALSE 64486
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
63900: LD_EXP 52
63904: PUSH
63905: LD_VAR 0 2
63909: ARRAY
63910: NOT
63911: PUSH
63912: LD_EXP 53
63916: PUSH
63917: LD_VAR 0 2
63921: ARRAY
63922: NOT
63923: AND
63924: PUSH
63925: LD_EXP 50
63929: PUSH
63930: LD_VAR 0 4
63934: ARRAY
63935: PUSH
63936: LD_INT 1
63938: GREATER
63939: AND
63940: IFFALSE 64071
// begin ComCancel ( j ) ;
63942: LD_VAR 0 3
63946: PPUSH
63947: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
63951: LD_ADDR_EXP 50
63955: PUSH
63956: LD_EXP 50
63960: PPUSH
63961: LD_VAR 0 4
63965: PPUSH
63966: LD_EXP 50
63970: PUSH
63971: LD_VAR 0 4
63975: ARRAY
63976: PPUSH
63977: LD_EXP 50
63981: PUSH
63982: LD_VAR 0 4
63986: ARRAY
63987: PUSH
63988: LD_INT 1
63990: MINUS
63991: PPUSH
63992: LD_EXP 50
63996: PUSH
63997: LD_VAR 0 4
64001: ARRAY
64002: PPUSH
64003: LD_INT 0
64005: PPUSH
64006: CALL 13037 0 4
64010: PPUSH
64011: CALL_OW 1
64015: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
64016: LD_ADDR_EXP 50
64020: PUSH
64021: LD_EXP 50
64025: PPUSH
64026: LD_VAR 0 4
64030: PPUSH
64031: LD_EXP 50
64035: PUSH
64036: LD_VAR 0 4
64040: ARRAY
64041: PPUSH
64042: LD_EXP 50
64046: PUSH
64047: LD_VAR 0 4
64051: ARRAY
64052: PPUSH
64053: LD_INT 1
64055: PPUSH
64056: LD_INT 0
64058: PPUSH
64059: CALL 13037 0 4
64063: PPUSH
64064: CALL_OW 1
64068: ST_TO_ADDR
// continue ;
64069: GO 63643
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
64071: LD_EXP 52
64075: PUSH
64076: LD_VAR 0 2
64080: ARRAY
64081: PUSH
64082: LD_EXP 53
64086: PUSH
64087: LD_VAR 0 2
64091: ARRAY
64092: NOT
64093: AND
64094: IFFALSE 64221
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
64096: LD_ADDR_EXP 53
64100: PUSH
64101: LD_EXP 53
64105: PPUSH
64106: LD_VAR 0 2
64110: PUSH
64111: LD_EXP 53
64115: PUSH
64116: LD_VAR 0 2
64120: ARRAY
64121: PUSH
64122: LD_INT 1
64124: PLUS
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: PPUSH
64130: LD_EXP 52
64134: PUSH
64135: LD_VAR 0 2
64139: ARRAY
64140: PUSH
64141: LD_INT 1
64143: ARRAY
64144: PPUSH
64145: CALL 13619 0 3
64149: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
64150: LD_EXP 52
64154: PUSH
64155: LD_VAR 0 2
64159: ARRAY
64160: PUSH
64161: LD_INT 1
64163: ARRAY
64164: PPUSH
64165: LD_INT 112
64167: PPUSH
64168: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
64172: LD_ADDR_VAR 0 9
64176: PUSH
64177: LD_EXP 52
64181: PUSH
64182: LD_VAR 0 2
64186: ARRAY
64187: PPUSH
64188: LD_INT 1
64190: PPUSH
64191: CALL_OW 3
64195: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
64196: LD_ADDR_EXP 52
64200: PUSH
64201: LD_EXP 52
64205: PPUSH
64206: LD_VAR 0 2
64210: PPUSH
64211: LD_VAR 0 9
64215: PPUSH
64216: CALL_OW 1
64220: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
64221: LD_EXP 52
64225: PUSH
64226: LD_VAR 0 2
64230: ARRAY
64231: PUSH
64232: LD_EXP 53
64236: PUSH
64237: LD_VAR 0 2
64241: ARRAY
64242: AND
64243: PUSH
64244: LD_EXP 53
64248: PUSH
64249: LD_VAR 0 2
64253: ARRAY
64254: PUSH
64255: LD_INT 1
64257: ARRAY
64258: PPUSH
64259: CALL_OW 310
64263: NOT
64264: AND
64265: PUSH
64266: LD_VAR 0 3
64270: PPUSH
64271: CALL_OW 313
64275: PUSH
64276: LD_INT 6
64278: EQUAL
64279: AND
64280: IFFALSE 64336
// begin tmp2 := UnitsInside ( j ) ;
64282: LD_ADDR_VAR 0 9
64286: PUSH
64287: LD_VAR 0 3
64291: PPUSH
64292: CALL_OW 313
64296: ST_TO_ADDR
// if tmp2 = 6 then
64297: LD_VAR 0 9
64301: PUSH
64302: LD_INT 6
64304: EQUAL
64305: IFFALSE 64336
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64307: LD_VAR 0 9
64311: PUSH
64312: LD_INT 1
64314: ARRAY
64315: PPUSH
64316: LD_INT 112
64318: PPUSH
64319: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64323: LD_VAR 0 9
64327: PUSH
64328: LD_INT 1
64330: ARRAY
64331: PPUSH
64332: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64336: LD_EXP 53
64340: PUSH
64341: LD_VAR 0 2
64345: ARRAY
64346: PUSH
64347: LD_EXP 53
64351: PUSH
64352: LD_VAR 0 2
64356: ARRAY
64357: PUSH
64358: LD_INT 1
64360: ARRAY
64361: PPUSH
64362: CALL_OW 314
64366: NOT
64367: AND
64368: PUSH
64369: LD_EXP 53
64373: PUSH
64374: LD_VAR 0 2
64378: ARRAY
64379: PUSH
64380: LD_INT 1
64382: ARRAY
64383: PPUSH
64384: CALL_OW 310
64388: NOT
64389: AND
64390: IFFALSE 64416
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64392: LD_EXP 53
64396: PUSH
64397: LD_VAR 0 2
64401: ARRAY
64402: PUSH
64403: LD_INT 1
64405: ARRAY
64406: PPUSH
64407: LD_VAR 0 3
64411: PPUSH
64412: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
64416: LD_EXP 53
64420: PUSH
64421: LD_VAR 0 2
64425: ARRAY
64426: PUSH
64427: LD_INT 1
64429: ARRAY
64430: PPUSH
64431: CALL_OW 310
64435: PUSH
64436: LD_EXP 53
64440: PUSH
64441: LD_VAR 0 2
64445: ARRAY
64446: PUSH
64447: LD_INT 1
64449: ARRAY
64450: PPUSH
64451: CALL_OW 310
64455: PPUSH
64456: CALL_OW 461
64460: PUSH
64461: LD_INT 3
64463: NONEQUAL
64464: AND
64465: IFFALSE 64486
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
64467: LD_EXP 53
64471: PUSH
64472: LD_VAR 0 2
64476: ARRAY
64477: PUSH
64478: LD_INT 1
64480: ARRAY
64481: PPUSH
64482: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
64486: LD_VAR 0 3
64490: PPUSH
64491: CALL_OW 461
64495: PUSH
64496: LD_INT 6
64498: EQUAL
64499: PUSH
64500: LD_VAR 0 6
64504: PUSH
64505: LD_INT 1
64507: GREATER
64508: AND
64509: IFFALSE 64661
// begin sci := [ ] ;
64511: LD_ADDR_VAR 0 8
64515: PUSH
64516: EMPTY
64517: ST_TO_ADDR
// for x in ( tmp diff j ) do
64518: LD_ADDR_VAR 0 7
64522: PUSH
64523: LD_VAR 0 6
64527: PUSH
64528: LD_VAR 0 3
64532: DIFF
64533: PUSH
64534: FOR_IN
64535: IFFALSE 64587
// begin if sci = 6 then
64537: LD_VAR 0 8
64541: PUSH
64542: LD_INT 6
64544: EQUAL
64545: IFFALSE 64549
// break ;
64547: GO 64587
// if BuildingStatus ( x ) = bs_idle then
64549: LD_VAR 0 7
64553: PPUSH
64554: CALL_OW 461
64558: PUSH
64559: LD_INT 2
64561: EQUAL
64562: IFFALSE 64585
// sci := sci ^ UnitsInside ( x ) ;
64564: LD_ADDR_VAR 0 8
64568: PUSH
64569: LD_VAR 0 8
64573: PUSH
64574: LD_VAR 0 7
64578: PPUSH
64579: CALL_OW 313
64583: ADD
64584: ST_TO_ADDR
// end ;
64585: GO 64534
64587: POP
64588: POP
// if not sci then
64589: LD_VAR 0 8
64593: NOT
64594: IFFALSE 64598
// continue ;
64596: GO 63643
// for x in sci do
64598: LD_ADDR_VAR 0 7
64602: PUSH
64603: LD_VAR 0 8
64607: PUSH
64608: FOR_IN
64609: IFFALSE 64659
// if IsInUnit ( x ) and not HasTask ( x ) then
64611: LD_VAR 0 7
64615: PPUSH
64616: CALL_OW 310
64620: PUSH
64621: LD_VAR 0 7
64625: PPUSH
64626: CALL_OW 314
64630: NOT
64631: AND
64632: IFFALSE 64657
// begin ComExitBuilding ( x ) ;
64634: LD_VAR 0 7
64638: PPUSH
64639: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64643: LD_VAR 0 7
64647: PPUSH
64648: LD_VAR 0 3
64652: PPUSH
64653: CALL_OW 180
// end ;
64657: GO 64608
64659: POP
64660: POP
// end ; end ;
64661: GO 63643
64663: POP
64664: POP
// end ;
64665: GO 63597
64667: POP
64668: POP
// end ;
64669: LD_VAR 0 1
64673: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
64674: LD_INT 0
64676: PPUSH
64677: PPUSH
// if not mc_bases then
64678: LD_EXP 23
64682: NOT
64683: IFFALSE 64687
// exit ;
64685: GO 64768
// for i = 1 to mc_bases do
64687: LD_ADDR_VAR 0 2
64691: PUSH
64692: DOUBLE
64693: LD_INT 1
64695: DEC
64696: ST_TO_ADDR
64697: LD_EXP 23
64701: PUSH
64702: FOR_TO
64703: IFFALSE 64766
// if mc_mines [ i ] and mc_miners [ i ] then
64705: LD_EXP 36
64709: PUSH
64710: LD_VAR 0 2
64714: ARRAY
64715: PUSH
64716: LD_EXP 37
64720: PUSH
64721: LD_VAR 0 2
64725: ARRAY
64726: AND
64727: IFFALSE 64764
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
64729: LD_EXP 37
64733: PUSH
64734: LD_VAR 0 2
64738: ARRAY
64739: PUSH
64740: LD_INT 1
64742: ARRAY
64743: PPUSH
64744: CALL_OW 255
64748: PPUSH
64749: LD_EXP 36
64753: PUSH
64754: LD_VAR 0 2
64758: ARRAY
64759: PPUSH
64760: CALL 10572 0 2
64764: GO 64702
64766: POP
64767: POP
// end ;
64768: LD_VAR 0 1
64772: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
64773: LD_INT 0
64775: PPUSH
64776: PPUSH
64777: PPUSH
64778: PPUSH
64779: PPUSH
64780: PPUSH
64781: PPUSH
64782: PPUSH
// if not mc_bases or not mc_parking then
64783: LD_EXP 23
64787: NOT
64788: PUSH
64789: LD_EXP 47
64793: NOT
64794: OR
64795: IFFALSE 64799
// exit ;
64797: GO 65498
// for i = 1 to mc_bases do
64799: LD_ADDR_VAR 0 2
64803: PUSH
64804: DOUBLE
64805: LD_INT 1
64807: DEC
64808: ST_TO_ADDR
64809: LD_EXP 23
64813: PUSH
64814: FOR_TO
64815: IFFALSE 65496
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
64817: LD_EXP 23
64821: PUSH
64822: LD_VAR 0 2
64826: ARRAY
64827: NOT
64828: PUSH
64829: LD_EXP 47
64833: PUSH
64834: LD_VAR 0 2
64838: ARRAY
64839: NOT
64840: OR
64841: IFFALSE 64845
// continue ;
64843: GO 64814
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
64845: LD_ADDR_VAR 0 5
64849: PUSH
64850: LD_EXP 23
64854: PUSH
64855: LD_VAR 0 2
64859: ARRAY
64860: PUSH
64861: LD_INT 1
64863: ARRAY
64864: PPUSH
64865: CALL_OW 255
64869: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64870: LD_ADDR_VAR 0 6
64874: PUSH
64875: LD_EXP 23
64879: PUSH
64880: LD_VAR 0 2
64884: ARRAY
64885: PPUSH
64886: LD_INT 30
64888: PUSH
64889: LD_INT 3
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PPUSH
64896: CALL_OW 72
64900: ST_TO_ADDR
// if not fac then
64901: LD_VAR 0 6
64905: NOT
64906: IFFALSE 64957
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64908: LD_ADDR_VAR 0 6
64912: PUSH
64913: LD_EXP 23
64917: PUSH
64918: LD_VAR 0 2
64922: ARRAY
64923: PPUSH
64924: LD_INT 2
64926: PUSH
64927: LD_INT 30
64929: PUSH
64930: LD_INT 0
64932: PUSH
64933: EMPTY
64934: LIST
64935: LIST
64936: PUSH
64937: LD_INT 30
64939: PUSH
64940: LD_INT 1
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: LIST
64951: PPUSH
64952: CALL_OW 72
64956: ST_TO_ADDR
// if not fac then
64957: LD_VAR 0 6
64961: NOT
64962: IFFALSE 64966
// continue ;
64964: GO 64814
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64966: LD_ADDR_VAR 0 7
64970: PUSH
64971: LD_EXP 47
64975: PUSH
64976: LD_VAR 0 2
64980: ARRAY
64981: PPUSH
64982: LD_INT 22
64984: PUSH
64985: LD_VAR 0 5
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 21
64996: PUSH
64997: LD_INT 2
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 3
65006: PUSH
65007: LD_INT 24
65009: PUSH
65010: LD_INT 1000
65012: PUSH
65013: EMPTY
65014: LIST
65015: LIST
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: EMPTY
65022: LIST
65023: LIST
65024: LIST
65025: PPUSH
65026: CALL_OW 70
65030: ST_TO_ADDR
// for j in fac do
65031: LD_ADDR_VAR 0 3
65035: PUSH
65036: LD_VAR 0 6
65040: PUSH
65041: FOR_IN
65042: IFFALSE 65123
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65044: LD_ADDR_VAR 0 7
65048: PUSH
65049: LD_VAR 0 7
65053: PUSH
65054: LD_INT 22
65056: PUSH
65057: LD_VAR 0 5
65061: PUSH
65062: EMPTY
65063: LIST
65064: LIST
65065: PUSH
65066: LD_INT 91
65068: PUSH
65069: LD_VAR 0 3
65073: PUSH
65074: LD_INT 15
65076: PUSH
65077: EMPTY
65078: LIST
65079: LIST
65080: LIST
65081: PUSH
65082: LD_INT 21
65084: PUSH
65085: LD_INT 2
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 3
65094: PUSH
65095: LD_INT 24
65097: PUSH
65098: LD_INT 1000
65100: PUSH
65101: EMPTY
65102: LIST
65103: LIST
65104: PUSH
65105: EMPTY
65106: LIST
65107: LIST
65108: PUSH
65109: EMPTY
65110: LIST
65111: LIST
65112: LIST
65113: LIST
65114: PPUSH
65115: CALL_OW 69
65119: UNION
65120: ST_TO_ADDR
65121: GO 65041
65123: POP
65124: POP
// if not vehs then
65125: LD_VAR 0 7
65129: NOT
65130: IFFALSE 65156
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65132: LD_ADDR_EXP 35
65136: PUSH
65137: LD_EXP 35
65141: PPUSH
65142: LD_VAR 0 2
65146: PPUSH
65147: EMPTY
65148: PPUSH
65149: CALL_OW 1
65153: ST_TO_ADDR
// continue ;
65154: GO 64814
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65156: LD_ADDR_VAR 0 8
65160: PUSH
65161: LD_EXP 23
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PPUSH
65172: LD_INT 30
65174: PUSH
65175: LD_INT 3
65177: PUSH
65178: EMPTY
65179: LIST
65180: LIST
65181: PPUSH
65182: CALL_OW 72
65186: ST_TO_ADDR
// if tmp then
65187: LD_VAR 0 8
65191: IFFALSE 65294
// begin for j in tmp do
65193: LD_ADDR_VAR 0 3
65197: PUSH
65198: LD_VAR 0 8
65202: PUSH
65203: FOR_IN
65204: IFFALSE 65292
// for k in UnitsInside ( j ) do
65206: LD_ADDR_VAR 0 4
65210: PUSH
65211: LD_VAR 0 3
65215: PPUSH
65216: CALL_OW 313
65220: PUSH
65221: FOR_IN
65222: IFFALSE 65288
// if k then
65224: LD_VAR 0 4
65228: IFFALSE 65286
// if not k in mc_repair_vehicle [ i ] then
65230: LD_VAR 0 4
65234: PUSH
65235: LD_EXP 35
65239: PUSH
65240: LD_VAR 0 2
65244: ARRAY
65245: IN
65246: NOT
65247: IFFALSE 65286
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65249: LD_ADDR_EXP 35
65253: PUSH
65254: LD_EXP 35
65258: PPUSH
65259: LD_VAR 0 2
65263: PPUSH
65264: LD_EXP 35
65268: PUSH
65269: LD_VAR 0 2
65273: ARRAY
65274: PUSH
65275: LD_VAR 0 4
65279: UNION
65280: PPUSH
65281: CALL_OW 1
65285: ST_TO_ADDR
65286: GO 65221
65288: POP
65289: POP
65290: GO 65203
65292: POP
65293: POP
// end ; if not mc_repair_vehicle [ i ] then
65294: LD_EXP 35
65298: PUSH
65299: LD_VAR 0 2
65303: ARRAY
65304: NOT
65305: IFFALSE 65309
// continue ;
65307: GO 64814
// for j in mc_repair_vehicle [ i ] do
65309: LD_ADDR_VAR 0 3
65313: PUSH
65314: LD_EXP 35
65318: PUSH
65319: LD_VAR 0 2
65323: ARRAY
65324: PUSH
65325: FOR_IN
65326: IFFALSE 65492
// begin if GetClass ( j ) <> 3 then
65328: LD_VAR 0 3
65332: PPUSH
65333: CALL_OW 257
65337: PUSH
65338: LD_INT 3
65340: NONEQUAL
65341: IFFALSE 65382
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65343: LD_ADDR_EXP 35
65347: PUSH
65348: LD_EXP 35
65352: PPUSH
65353: LD_VAR 0 2
65357: PPUSH
65358: LD_EXP 35
65362: PUSH
65363: LD_VAR 0 2
65367: ARRAY
65368: PUSH
65369: LD_VAR 0 3
65373: DIFF
65374: PPUSH
65375: CALL_OW 1
65379: ST_TO_ADDR
// continue ;
65380: GO 65325
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65382: LD_VAR 0 3
65386: PPUSH
65387: CALL_OW 311
65391: NOT
65392: PUSH
65393: LD_VAR 0 3
65397: PUSH
65398: LD_EXP 26
65402: PUSH
65403: LD_VAR 0 2
65407: ARRAY
65408: PUSH
65409: LD_INT 1
65411: ARRAY
65412: IN
65413: NOT
65414: AND
65415: PUSH
65416: LD_VAR 0 3
65420: PUSH
65421: LD_EXP 26
65425: PUSH
65426: LD_VAR 0 2
65430: ARRAY
65431: PUSH
65432: LD_INT 2
65434: ARRAY
65435: IN
65436: NOT
65437: AND
65438: IFFALSE 65490
// begin if IsInUnit ( j ) then
65440: LD_VAR 0 3
65444: PPUSH
65445: CALL_OW 310
65449: IFFALSE 65460
// ComExitBuilding ( j ) ;
65451: LD_VAR 0 3
65455: PPUSH
65456: CALL_OW 122
// if not HasTask ( j ) then
65460: LD_VAR 0 3
65464: PPUSH
65465: CALL_OW 314
65469: NOT
65470: IFFALSE 65490
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
65472: LD_VAR 0 3
65476: PPUSH
65477: LD_VAR 0 7
65481: PUSH
65482: LD_INT 1
65484: ARRAY
65485: PPUSH
65486: CALL_OW 189
// end ; end ;
65490: GO 65325
65492: POP
65493: POP
// end ;
65494: GO 64814
65496: POP
65497: POP
// end ;
65498: LD_VAR 0 1
65502: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
65503: LD_INT 0
65505: PPUSH
65506: PPUSH
65507: PPUSH
65508: PPUSH
65509: PPUSH
65510: PPUSH
65511: PPUSH
65512: PPUSH
65513: PPUSH
65514: PPUSH
65515: PPUSH
// if not mc_bases then
65516: LD_EXP 23
65520: NOT
65521: IFFALSE 65525
// exit ;
65523: GO 66327
// for i = 1 to mc_bases do
65525: LD_ADDR_VAR 0 2
65529: PUSH
65530: DOUBLE
65531: LD_INT 1
65533: DEC
65534: ST_TO_ADDR
65535: LD_EXP 23
65539: PUSH
65540: FOR_TO
65541: IFFALSE 66325
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
65543: LD_EXP 51
65547: PUSH
65548: LD_VAR 0 2
65552: ARRAY
65553: NOT
65554: PUSH
65555: LD_EXP 26
65559: PUSH
65560: LD_VAR 0 2
65564: ARRAY
65565: PUSH
65566: LD_INT 1
65568: ARRAY
65569: OR
65570: PUSH
65571: LD_EXP 26
65575: PUSH
65576: LD_VAR 0 2
65580: ARRAY
65581: PUSH
65582: LD_INT 2
65584: ARRAY
65585: OR
65586: PUSH
65587: LD_EXP 49
65591: PUSH
65592: LD_VAR 0 2
65596: ARRAY
65597: PPUSH
65598: LD_INT 1
65600: PPUSH
65601: CALL_OW 325
65605: NOT
65606: OR
65607: PUSH
65608: LD_EXP 46
65612: PUSH
65613: LD_VAR 0 2
65617: ARRAY
65618: OR
65619: IFFALSE 65623
// continue ;
65621: GO 65540
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
65623: LD_ADDR_VAR 0 8
65627: PUSH
65628: LD_EXP 23
65632: PUSH
65633: LD_VAR 0 2
65637: ARRAY
65638: PPUSH
65639: LD_INT 25
65641: PUSH
65642: LD_INT 4
65644: PUSH
65645: EMPTY
65646: LIST
65647: LIST
65648: PUSH
65649: LD_INT 50
65651: PUSH
65652: EMPTY
65653: LIST
65654: PUSH
65655: LD_INT 3
65657: PUSH
65658: LD_INT 60
65660: PUSH
65661: EMPTY
65662: LIST
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: LIST
65672: PPUSH
65673: CALL_OW 72
65677: PUSH
65678: LD_EXP 27
65682: PUSH
65683: LD_VAR 0 2
65687: ARRAY
65688: DIFF
65689: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65690: LD_ADDR_VAR 0 9
65694: PUSH
65695: LD_EXP 23
65699: PUSH
65700: LD_VAR 0 2
65704: ARRAY
65705: PPUSH
65706: LD_INT 2
65708: PUSH
65709: LD_INT 30
65711: PUSH
65712: LD_INT 0
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 30
65721: PUSH
65722: LD_INT 1
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: LIST
65733: PPUSH
65734: CALL_OW 72
65738: ST_TO_ADDR
// if not tmp or not dep then
65739: LD_VAR 0 8
65743: NOT
65744: PUSH
65745: LD_VAR 0 9
65749: NOT
65750: OR
65751: IFFALSE 65755
// continue ;
65753: GO 65540
// side := GetSide ( tmp [ 1 ] ) ;
65755: LD_ADDR_VAR 0 11
65759: PUSH
65760: LD_VAR 0 8
65764: PUSH
65765: LD_INT 1
65767: ARRAY
65768: PPUSH
65769: CALL_OW 255
65773: ST_TO_ADDR
// dep := dep [ 1 ] ;
65774: LD_ADDR_VAR 0 9
65778: PUSH
65779: LD_VAR 0 9
65783: PUSH
65784: LD_INT 1
65786: ARRAY
65787: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
65788: LD_ADDR_VAR 0 7
65792: PUSH
65793: LD_EXP 51
65797: PUSH
65798: LD_VAR 0 2
65802: ARRAY
65803: PPUSH
65804: LD_INT 22
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 25
65816: PUSH
65817: LD_INT 12
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: PUSH
65824: EMPTY
65825: LIST
65826: LIST
65827: PPUSH
65828: CALL_OW 70
65832: PUSH
65833: LD_INT 22
65835: PUSH
65836: LD_INT 0
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: LD_INT 25
65845: PUSH
65846: LD_INT 12
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: LD_INT 91
65855: PUSH
65856: LD_VAR 0 9
65860: PUSH
65861: LD_INT 20
65863: PUSH
65864: EMPTY
65865: LIST
65866: LIST
65867: LIST
65868: PUSH
65869: EMPTY
65870: LIST
65871: LIST
65872: LIST
65873: PPUSH
65874: CALL_OW 69
65878: UNION
65879: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
65880: LD_ADDR_VAR 0 10
65884: PUSH
65885: LD_EXP 51
65889: PUSH
65890: LD_VAR 0 2
65894: ARRAY
65895: PPUSH
65896: LD_INT 81
65898: PUSH
65899: LD_VAR 0 11
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PPUSH
65908: CALL_OW 70
65912: ST_TO_ADDR
// if not apes or danger_at_area then
65913: LD_VAR 0 7
65917: NOT
65918: PUSH
65919: LD_VAR 0 10
65923: OR
65924: IFFALSE 65974
// begin if mc_taming [ i ] then
65926: LD_EXP 54
65930: PUSH
65931: LD_VAR 0 2
65935: ARRAY
65936: IFFALSE 65972
// begin MC_Reset ( i , 121 ) ;
65938: LD_VAR 0 2
65942: PPUSH
65943: LD_INT 121
65945: PPUSH
65946: CALL 51261 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65950: LD_ADDR_EXP 54
65954: PUSH
65955: LD_EXP 54
65959: PPUSH
65960: LD_VAR 0 2
65964: PPUSH
65965: EMPTY
65966: PPUSH
65967: CALL_OW 1
65971: ST_TO_ADDR
// end ; continue ;
65972: GO 65540
// end ; for j in tmp do
65974: LD_ADDR_VAR 0 3
65978: PUSH
65979: LD_VAR 0 8
65983: PUSH
65984: FOR_IN
65985: IFFALSE 66321
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
65987: LD_VAR 0 3
65991: PUSH
65992: LD_EXP 54
65996: PUSH
65997: LD_VAR 0 2
66001: ARRAY
66002: IN
66003: NOT
66004: PUSH
66005: LD_EXP 54
66009: PUSH
66010: LD_VAR 0 2
66014: ARRAY
66015: PUSH
66016: LD_INT 3
66018: LESS
66019: AND
66020: IFFALSE 66078
// begin SetTag ( j , 121 ) ;
66022: LD_VAR 0 3
66026: PPUSH
66027: LD_INT 121
66029: PPUSH
66030: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
66034: LD_ADDR_EXP 54
66038: PUSH
66039: LD_EXP 54
66043: PPUSH
66044: LD_VAR 0 2
66048: PUSH
66049: LD_EXP 54
66053: PUSH
66054: LD_VAR 0 2
66058: ARRAY
66059: PUSH
66060: LD_INT 1
66062: PLUS
66063: PUSH
66064: EMPTY
66065: LIST
66066: LIST
66067: PPUSH
66068: LD_VAR 0 3
66072: PPUSH
66073: CALL 13619 0 3
66077: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
66078: LD_VAR 0 3
66082: PUSH
66083: LD_EXP 54
66087: PUSH
66088: LD_VAR 0 2
66092: ARRAY
66093: IN
66094: IFFALSE 66319
// begin if GetClass ( j ) <> 4 then
66096: LD_VAR 0 3
66100: PPUSH
66101: CALL_OW 257
66105: PUSH
66106: LD_INT 4
66108: NONEQUAL
66109: IFFALSE 66162
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
66111: LD_ADDR_EXP 54
66115: PUSH
66116: LD_EXP 54
66120: PPUSH
66121: LD_VAR 0 2
66125: PPUSH
66126: LD_EXP 54
66130: PUSH
66131: LD_VAR 0 2
66135: ARRAY
66136: PUSH
66137: LD_VAR 0 3
66141: DIFF
66142: PPUSH
66143: CALL_OW 1
66147: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66148: LD_VAR 0 3
66152: PPUSH
66153: LD_INT 0
66155: PPUSH
66156: CALL_OW 109
// continue ;
66160: GO 65984
// end ; if IsInUnit ( j ) then
66162: LD_VAR 0 3
66166: PPUSH
66167: CALL_OW 310
66171: IFFALSE 66182
// ComExitBuilding ( j ) ;
66173: LD_VAR 0 3
66177: PPUSH
66178: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
66182: LD_ADDR_VAR 0 6
66186: PUSH
66187: LD_VAR 0 7
66191: PPUSH
66192: LD_VAR 0 3
66196: PPUSH
66197: CALL_OW 74
66201: ST_TO_ADDR
// if not ape then
66202: LD_VAR 0 6
66206: NOT
66207: IFFALSE 66211
// break ;
66209: GO 66321
// x := GetX ( ape ) ;
66211: LD_ADDR_VAR 0 4
66215: PUSH
66216: LD_VAR 0 6
66220: PPUSH
66221: CALL_OW 250
66225: ST_TO_ADDR
// y := GetY ( ape ) ;
66226: LD_ADDR_VAR 0 5
66230: PUSH
66231: LD_VAR 0 6
66235: PPUSH
66236: CALL_OW 251
66240: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66241: LD_VAR 0 4
66245: PPUSH
66246: LD_VAR 0 5
66250: PPUSH
66251: CALL_OW 488
66255: NOT
66256: PUSH
66257: LD_VAR 0 11
66261: PPUSH
66262: LD_VAR 0 4
66266: PPUSH
66267: LD_VAR 0 5
66271: PPUSH
66272: LD_INT 20
66274: PPUSH
66275: CALL 14515 0 4
66279: PUSH
66280: LD_INT 4
66282: ARRAY
66283: OR
66284: IFFALSE 66288
// break ;
66286: GO 66321
// if not HasTask ( j ) then
66288: LD_VAR 0 3
66292: PPUSH
66293: CALL_OW 314
66297: NOT
66298: IFFALSE 66319
// ComTameXY ( j , x , y ) ;
66300: LD_VAR 0 3
66304: PPUSH
66305: LD_VAR 0 4
66309: PPUSH
66310: LD_VAR 0 5
66314: PPUSH
66315: CALL_OW 131
// end ; end ;
66319: GO 65984
66321: POP
66322: POP
// end ;
66323: GO 65540
66325: POP
66326: POP
// end ;
66327: LD_VAR 0 1
66331: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66332: LD_INT 0
66334: PPUSH
66335: PPUSH
66336: PPUSH
66337: PPUSH
66338: PPUSH
66339: PPUSH
66340: PPUSH
66341: PPUSH
// if not mc_bases then
66342: LD_EXP 23
66346: NOT
66347: IFFALSE 66351
// exit ;
66349: GO 66977
// for i = 1 to mc_bases do
66351: LD_ADDR_VAR 0 2
66355: PUSH
66356: DOUBLE
66357: LD_INT 1
66359: DEC
66360: ST_TO_ADDR
66361: LD_EXP 23
66365: PUSH
66366: FOR_TO
66367: IFFALSE 66975
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66369: LD_EXP 52
66373: PUSH
66374: LD_VAR 0 2
66378: ARRAY
66379: NOT
66380: PUSH
66381: LD_EXP 52
66385: PUSH
66386: LD_VAR 0 2
66390: ARRAY
66391: PPUSH
66392: LD_INT 25
66394: PUSH
66395: LD_INT 12
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PPUSH
66402: CALL_OW 72
66406: NOT
66407: OR
66408: IFFALSE 66412
// continue ;
66410: GO 66366
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
66412: LD_ADDR_VAR 0 5
66416: PUSH
66417: LD_EXP 52
66421: PUSH
66422: LD_VAR 0 2
66426: ARRAY
66427: PUSH
66428: LD_INT 1
66430: ARRAY
66431: PPUSH
66432: CALL_OW 255
66436: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
66437: LD_VAR 0 5
66441: PPUSH
66442: LD_INT 2
66444: PPUSH
66445: CALL_OW 325
66449: IFFALSE 66702
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66451: LD_ADDR_VAR 0 4
66455: PUSH
66456: LD_EXP 52
66460: PUSH
66461: LD_VAR 0 2
66465: ARRAY
66466: PPUSH
66467: LD_INT 25
66469: PUSH
66470: LD_INT 16
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PPUSH
66477: CALL_OW 72
66481: ST_TO_ADDR
// if tmp < 6 then
66482: LD_VAR 0 4
66486: PUSH
66487: LD_INT 6
66489: LESS
66490: IFFALSE 66702
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66492: LD_ADDR_VAR 0 6
66496: PUSH
66497: LD_EXP 23
66501: PUSH
66502: LD_VAR 0 2
66506: ARRAY
66507: PPUSH
66508: LD_INT 2
66510: PUSH
66511: LD_INT 30
66513: PUSH
66514: LD_INT 0
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 30
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: LIST
66535: PPUSH
66536: CALL_OW 72
66540: ST_TO_ADDR
// if depot then
66541: LD_VAR 0 6
66545: IFFALSE 66702
// begin selected := 0 ;
66547: LD_ADDR_VAR 0 7
66551: PUSH
66552: LD_INT 0
66554: ST_TO_ADDR
// for j in depot do
66555: LD_ADDR_VAR 0 3
66559: PUSH
66560: LD_VAR 0 6
66564: PUSH
66565: FOR_IN
66566: IFFALSE 66597
// begin if UnitsInside ( j ) < 6 then
66568: LD_VAR 0 3
66572: PPUSH
66573: CALL_OW 313
66577: PUSH
66578: LD_INT 6
66580: LESS
66581: IFFALSE 66595
// begin selected := j ;
66583: LD_ADDR_VAR 0 7
66587: PUSH
66588: LD_VAR 0 3
66592: ST_TO_ADDR
// break ;
66593: GO 66597
// end ; end ;
66595: GO 66565
66597: POP
66598: POP
// if selected then
66599: LD_VAR 0 7
66603: IFFALSE 66702
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66605: LD_ADDR_VAR 0 3
66609: PUSH
66610: LD_EXP 52
66614: PUSH
66615: LD_VAR 0 2
66619: ARRAY
66620: PPUSH
66621: LD_INT 25
66623: PUSH
66624: LD_INT 12
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PPUSH
66631: CALL_OW 72
66635: PUSH
66636: FOR_IN
66637: IFFALSE 66700
// if not HasTask ( j ) then
66639: LD_VAR 0 3
66643: PPUSH
66644: CALL_OW 314
66648: NOT
66649: IFFALSE 66698
// begin if not IsInUnit ( j ) then
66651: LD_VAR 0 3
66655: PPUSH
66656: CALL_OW 310
66660: NOT
66661: IFFALSE 66677
// ComEnterUnit ( j , selected ) ;
66663: LD_VAR 0 3
66667: PPUSH
66668: LD_VAR 0 7
66672: PPUSH
66673: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
66677: LD_VAR 0 3
66681: PPUSH
66682: LD_INT 16
66684: PPUSH
66685: CALL_OW 183
// AddComExitBuilding ( j ) ;
66689: LD_VAR 0 3
66693: PPUSH
66694: CALL_OW 182
// end ;
66698: GO 66636
66700: POP
66701: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
66702: LD_VAR 0 5
66706: PPUSH
66707: LD_INT 11
66709: PPUSH
66710: CALL_OW 325
66714: IFFALSE 66973
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
66716: LD_ADDR_VAR 0 4
66720: PUSH
66721: LD_EXP 52
66725: PUSH
66726: LD_VAR 0 2
66730: ARRAY
66731: PPUSH
66732: LD_INT 25
66734: PUSH
66735: LD_INT 16
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PPUSH
66742: CALL_OW 72
66746: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
66747: LD_VAR 0 4
66751: PUSH
66752: LD_INT 6
66754: GREATEREQUAL
66755: PUSH
66756: LD_VAR 0 5
66760: PPUSH
66761: LD_INT 2
66763: PPUSH
66764: CALL_OW 325
66768: NOT
66769: OR
66770: IFFALSE 66973
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66772: LD_ADDR_VAR 0 8
66776: PUSH
66777: LD_EXP 23
66781: PUSH
66782: LD_VAR 0 2
66786: ARRAY
66787: PPUSH
66788: LD_INT 2
66790: PUSH
66791: LD_INT 30
66793: PUSH
66794: LD_INT 4
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: LD_INT 30
66803: PUSH
66804: LD_INT 5
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: EMPTY
66812: LIST
66813: LIST
66814: LIST
66815: PPUSH
66816: CALL_OW 72
66820: ST_TO_ADDR
// if barracks then
66821: LD_VAR 0 8
66825: IFFALSE 66973
// begin selected := 0 ;
66827: LD_ADDR_VAR 0 7
66831: PUSH
66832: LD_INT 0
66834: ST_TO_ADDR
// for j in barracks do
66835: LD_ADDR_VAR 0 3
66839: PUSH
66840: LD_VAR 0 8
66844: PUSH
66845: FOR_IN
66846: IFFALSE 66877
// begin if UnitsInside ( j ) < 6 then
66848: LD_VAR 0 3
66852: PPUSH
66853: CALL_OW 313
66857: PUSH
66858: LD_INT 6
66860: LESS
66861: IFFALSE 66875
// begin selected := j ;
66863: LD_ADDR_VAR 0 7
66867: PUSH
66868: LD_VAR 0 3
66872: ST_TO_ADDR
// break ;
66873: GO 66877
// end ; end ;
66875: GO 66845
66877: POP
66878: POP
// if selected then
66879: LD_VAR 0 7
66883: IFFALSE 66973
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
66885: LD_ADDR_VAR 0 3
66889: PUSH
66890: LD_EXP 52
66894: PUSH
66895: LD_VAR 0 2
66899: ARRAY
66900: PPUSH
66901: LD_INT 25
66903: PUSH
66904: LD_INT 12
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PPUSH
66911: CALL_OW 72
66915: PUSH
66916: FOR_IN
66917: IFFALSE 66971
// if not IsInUnit ( j ) and not HasTask ( j ) then
66919: LD_VAR 0 3
66923: PPUSH
66924: CALL_OW 310
66928: NOT
66929: PUSH
66930: LD_VAR 0 3
66934: PPUSH
66935: CALL_OW 314
66939: NOT
66940: AND
66941: IFFALSE 66969
// begin ComEnterUnit ( j , selected ) ;
66943: LD_VAR 0 3
66947: PPUSH
66948: LD_VAR 0 7
66952: PPUSH
66953: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
66957: LD_VAR 0 3
66961: PPUSH
66962: LD_INT 15
66964: PPUSH
66965: CALL_OW 183
// end ;
66969: GO 66916
66971: POP
66972: POP
// end ; end ; end ; end ; end ;
66973: GO 66366
66975: POP
66976: POP
// end ;
66977: LD_VAR 0 1
66981: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
66982: LD_INT 0
66984: PPUSH
66985: PPUSH
66986: PPUSH
66987: PPUSH
// if not mc_bases then
66988: LD_EXP 23
66992: NOT
66993: IFFALSE 66997
// exit ;
66995: GO 67175
// for i = 1 to mc_bases do
66997: LD_ADDR_VAR 0 2
67001: PUSH
67002: DOUBLE
67003: LD_INT 1
67005: DEC
67006: ST_TO_ADDR
67007: LD_EXP 23
67011: PUSH
67012: FOR_TO
67013: IFFALSE 67173
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
67015: LD_ADDR_VAR 0 4
67019: PUSH
67020: LD_EXP 23
67024: PUSH
67025: LD_VAR 0 2
67029: ARRAY
67030: PPUSH
67031: LD_INT 25
67033: PUSH
67034: LD_INT 9
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PPUSH
67041: CALL_OW 72
67045: ST_TO_ADDR
// if not tmp then
67046: LD_VAR 0 4
67050: NOT
67051: IFFALSE 67055
// continue ;
67053: GO 67012
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
67055: LD_EXP 49
67059: PUSH
67060: LD_VAR 0 2
67064: ARRAY
67065: PPUSH
67066: LD_INT 29
67068: PPUSH
67069: CALL_OW 325
67073: NOT
67074: PUSH
67075: LD_EXP 49
67079: PUSH
67080: LD_VAR 0 2
67084: ARRAY
67085: PPUSH
67086: LD_INT 28
67088: PPUSH
67089: CALL_OW 325
67093: NOT
67094: AND
67095: IFFALSE 67099
// continue ;
67097: GO 67012
// for j in tmp do
67099: LD_ADDR_VAR 0 3
67103: PUSH
67104: LD_VAR 0 4
67108: PUSH
67109: FOR_IN
67110: IFFALSE 67169
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67112: LD_VAR 0 3
67116: PUSH
67117: LD_EXP 26
67121: PUSH
67122: LD_VAR 0 2
67126: ARRAY
67127: PUSH
67128: LD_INT 1
67130: ARRAY
67131: IN
67132: NOT
67133: PUSH
67134: LD_VAR 0 3
67138: PUSH
67139: LD_EXP 26
67143: PUSH
67144: LD_VAR 0 2
67148: ARRAY
67149: PUSH
67150: LD_INT 2
67152: ARRAY
67153: IN
67154: NOT
67155: AND
67156: IFFALSE 67167
// ComSpaceTimeShoot ( j ) ;
67158: LD_VAR 0 3
67162: PPUSH
67163: CALL 9580 0 1
67167: GO 67109
67169: POP
67170: POP
// end ;
67171: GO 67012
67173: POP
67174: POP
// end ;
67175: LD_VAR 0 1
67179: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
67180: LD_INT 0
67182: PPUSH
67183: PPUSH
67184: PPUSH
67185: PPUSH
67186: PPUSH
67187: PPUSH
67188: PPUSH
67189: PPUSH
67190: PPUSH
// if not mc_bases then
67191: LD_EXP 23
67195: NOT
67196: IFFALSE 67200
// exit ;
67198: GO 67822
// for i = 1 to mc_bases do
67200: LD_ADDR_VAR 0 2
67204: PUSH
67205: DOUBLE
67206: LD_INT 1
67208: DEC
67209: ST_TO_ADDR
67210: LD_EXP 23
67214: PUSH
67215: FOR_TO
67216: IFFALSE 67820
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
67218: LD_EXP 58
67222: PUSH
67223: LD_VAR 0 2
67227: ARRAY
67228: NOT
67229: PUSH
67230: LD_INT 38
67232: PPUSH
67233: LD_EXP 49
67237: PUSH
67238: LD_VAR 0 2
67242: ARRAY
67243: PPUSH
67244: CALL_OW 321
67248: PUSH
67249: LD_INT 2
67251: NONEQUAL
67252: OR
67253: IFFALSE 67257
// continue ;
67255: GO 67215
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67257: LD_ADDR_VAR 0 8
67261: PUSH
67262: LD_EXP 23
67266: PUSH
67267: LD_VAR 0 2
67271: ARRAY
67272: PPUSH
67273: LD_INT 30
67275: PUSH
67276: LD_INT 34
67278: PUSH
67279: EMPTY
67280: LIST
67281: LIST
67282: PPUSH
67283: CALL_OW 72
67287: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67288: LD_ADDR_VAR 0 9
67292: PUSH
67293: LD_EXP 23
67297: PUSH
67298: LD_VAR 0 2
67302: ARRAY
67303: PPUSH
67304: LD_INT 25
67306: PUSH
67307: LD_INT 4
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PPUSH
67314: CALL_OW 72
67318: PPUSH
67319: LD_INT 0
67321: PPUSH
67322: CALL 42889 0 2
67326: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67327: LD_VAR 0 9
67331: NOT
67332: PUSH
67333: LD_VAR 0 8
67337: NOT
67338: OR
67339: PUSH
67340: LD_EXP 23
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: PPUSH
67351: LD_INT 124
67353: PPUSH
67354: CALL 42889 0 2
67358: OR
67359: IFFALSE 67363
// continue ;
67361: GO 67215
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67363: LD_EXP 59
67367: PUSH
67368: LD_VAR 0 2
67372: ARRAY
67373: PUSH
67374: LD_EXP 58
67378: PUSH
67379: LD_VAR 0 2
67383: ARRAY
67384: LESS
67385: PUSH
67386: LD_EXP 59
67390: PUSH
67391: LD_VAR 0 2
67395: ARRAY
67396: PUSH
67397: LD_VAR 0 8
67401: LESS
67402: AND
67403: IFFALSE 67818
// begin tmp := sci [ 1 ] ;
67405: LD_ADDR_VAR 0 7
67409: PUSH
67410: LD_VAR 0 9
67414: PUSH
67415: LD_INT 1
67417: ARRAY
67418: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
67419: LD_VAR 0 7
67423: PPUSH
67424: LD_INT 124
67426: PPUSH
67427: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
67431: LD_ADDR_VAR 0 3
67435: PUSH
67436: DOUBLE
67437: LD_EXP 58
67441: PUSH
67442: LD_VAR 0 2
67446: ARRAY
67447: INC
67448: ST_TO_ADDR
67449: LD_EXP 58
67453: PUSH
67454: LD_VAR 0 2
67458: ARRAY
67459: PUSH
67460: FOR_DOWNTO
67461: IFFALSE 67804
// begin if IsInUnit ( tmp ) then
67463: LD_VAR 0 7
67467: PPUSH
67468: CALL_OW 310
67472: IFFALSE 67483
// ComExitBuilding ( tmp ) ;
67474: LD_VAR 0 7
67478: PPUSH
67479: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
67483: LD_INT 35
67485: PPUSH
67486: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
67490: LD_VAR 0 7
67494: PPUSH
67495: CALL_OW 310
67499: NOT
67500: PUSH
67501: LD_VAR 0 7
67505: PPUSH
67506: CALL_OW 314
67510: NOT
67511: AND
67512: IFFALSE 67483
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
67514: LD_ADDR_VAR 0 6
67518: PUSH
67519: LD_VAR 0 7
67523: PPUSH
67524: CALL_OW 250
67528: PUSH
67529: LD_VAR 0 7
67533: PPUSH
67534: CALL_OW 251
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
67543: LD_INT 35
67545: PPUSH
67546: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
67550: LD_ADDR_VAR 0 4
67554: PUSH
67555: LD_EXP 58
67559: PUSH
67560: LD_VAR 0 2
67564: ARRAY
67565: PUSH
67566: LD_VAR 0 3
67570: ARRAY
67571: PUSH
67572: LD_INT 1
67574: ARRAY
67575: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
67576: LD_ADDR_VAR 0 5
67580: PUSH
67581: LD_EXP 58
67585: PUSH
67586: LD_VAR 0 2
67590: ARRAY
67591: PUSH
67592: LD_VAR 0 3
67596: ARRAY
67597: PUSH
67598: LD_INT 2
67600: ARRAY
67601: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
67602: LD_VAR 0 7
67606: PPUSH
67607: LD_INT 10
67609: PPUSH
67610: CALL 16218 0 2
67614: PUSH
67615: LD_INT 4
67617: ARRAY
67618: IFFALSE 67656
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
67620: LD_VAR 0 7
67624: PPUSH
67625: LD_VAR 0 6
67629: PUSH
67630: LD_INT 1
67632: ARRAY
67633: PPUSH
67634: LD_VAR 0 6
67638: PUSH
67639: LD_INT 2
67641: ARRAY
67642: PPUSH
67643: CALL_OW 111
// wait ( 0 0$10 ) ;
67647: LD_INT 350
67649: PPUSH
67650: CALL_OW 67
// end else
67654: GO 67682
// begin ComMoveXY ( tmp , x , y ) ;
67656: LD_VAR 0 7
67660: PPUSH
67661: LD_VAR 0 4
67665: PPUSH
67666: LD_VAR 0 5
67670: PPUSH
67671: CALL_OW 111
// wait ( 0 0$3 ) ;
67675: LD_INT 105
67677: PPUSH
67678: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
67682: LD_VAR 0 7
67686: PPUSH
67687: LD_VAR 0 4
67691: PPUSH
67692: LD_VAR 0 5
67696: PPUSH
67697: CALL_OW 307
67701: IFFALSE 67543
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
67703: LD_VAR 0 7
67707: PPUSH
67708: LD_VAR 0 4
67712: PPUSH
67713: LD_VAR 0 5
67717: PPUSH
67718: LD_VAR 0 8
67722: PUSH
67723: LD_VAR 0 3
67727: ARRAY
67728: PPUSH
67729: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
67733: LD_INT 35
67735: PPUSH
67736: CALL_OW 67
// until not HasTask ( tmp ) ;
67740: LD_VAR 0 7
67744: PPUSH
67745: CALL_OW 314
67749: NOT
67750: IFFALSE 67733
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
67752: LD_ADDR_EXP 59
67756: PUSH
67757: LD_EXP 59
67761: PPUSH
67762: LD_VAR 0 2
67766: PUSH
67767: LD_EXP 59
67771: PUSH
67772: LD_VAR 0 2
67776: ARRAY
67777: PUSH
67778: LD_INT 1
67780: PLUS
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PPUSH
67786: LD_VAR 0 8
67790: PUSH
67791: LD_VAR 0 3
67795: ARRAY
67796: PPUSH
67797: CALL 13619 0 3
67801: ST_TO_ADDR
// end ;
67802: GO 67460
67804: POP
67805: POP
// MC_Reset ( i , 124 ) ;
67806: LD_VAR 0 2
67810: PPUSH
67811: LD_INT 124
67813: PPUSH
67814: CALL 51261 0 2
// end ; end ;
67818: GO 67215
67820: POP
67821: POP
// end ;
67822: LD_VAR 0 1
67826: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
67827: LD_INT 0
67829: PPUSH
67830: PPUSH
67831: PPUSH
// if not mc_bases then
67832: LD_EXP 23
67836: NOT
67837: IFFALSE 67841
// exit ;
67839: GO 68447
// for i = 1 to mc_bases do
67841: LD_ADDR_VAR 0 2
67845: PUSH
67846: DOUBLE
67847: LD_INT 1
67849: DEC
67850: ST_TO_ADDR
67851: LD_EXP 23
67855: PUSH
67856: FOR_TO
67857: IFFALSE 68445
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67859: LD_ADDR_VAR 0 3
67863: PUSH
67864: LD_EXP 23
67868: PUSH
67869: LD_VAR 0 2
67873: ARRAY
67874: PPUSH
67875: LD_INT 25
67877: PUSH
67878: LD_INT 4
67880: PUSH
67881: EMPTY
67882: LIST
67883: LIST
67884: PPUSH
67885: CALL_OW 72
67889: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
67890: LD_VAR 0 3
67894: NOT
67895: PUSH
67896: LD_EXP 60
67900: PUSH
67901: LD_VAR 0 2
67905: ARRAY
67906: NOT
67907: OR
67908: PUSH
67909: LD_EXP 23
67913: PUSH
67914: LD_VAR 0 2
67918: ARRAY
67919: PPUSH
67920: LD_INT 2
67922: PUSH
67923: LD_INT 30
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: EMPTY
67930: LIST
67931: LIST
67932: PUSH
67933: LD_INT 30
67935: PUSH
67936: LD_INT 1
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: LIST
67947: PPUSH
67948: CALL_OW 72
67952: NOT
67953: OR
67954: IFFALSE 68004
// begin if mc_deposits_finder [ i ] then
67956: LD_EXP 61
67960: PUSH
67961: LD_VAR 0 2
67965: ARRAY
67966: IFFALSE 68002
// begin MC_Reset ( i , 125 ) ;
67968: LD_VAR 0 2
67972: PPUSH
67973: LD_INT 125
67975: PPUSH
67976: CALL 51261 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
67980: LD_ADDR_EXP 61
67984: PUSH
67985: LD_EXP 61
67989: PPUSH
67990: LD_VAR 0 2
67994: PPUSH
67995: EMPTY
67996: PPUSH
67997: CALL_OW 1
68001: ST_TO_ADDR
// end ; continue ;
68002: GO 67856
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
68004: LD_EXP 60
68008: PUSH
68009: LD_VAR 0 2
68013: ARRAY
68014: PUSH
68015: LD_INT 1
68017: ARRAY
68018: PUSH
68019: LD_INT 3
68021: ARRAY
68022: PUSH
68023: LD_INT 1
68025: EQUAL
68026: PUSH
68027: LD_INT 20
68029: PPUSH
68030: LD_EXP 49
68034: PUSH
68035: LD_VAR 0 2
68039: ARRAY
68040: PPUSH
68041: CALL_OW 321
68045: PUSH
68046: LD_INT 2
68048: NONEQUAL
68049: AND
68050: IFFALSE 68100
// begin if mc_deposits_finder [ i ] then
68052: LD_EXP 61
68056: PUSH
68057: LD_VAR 0 2
68061: ARRAY
68062: IFFALSE 68098
// begin MC_Reset ( i , 125 ) ;
68064: LD_VAR 0 2
68068: PPUSH
68069: LD_INT 125
68071: PPUSH
68072: CALL 51261 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68076: LD_ADDR_EXP 61
68080: PUSH
68081: LD_EXP 61
68085: PPUSH
68086: LD_VAR 0 2
68090: PPUSH
68091: EMPTY
68092: PPUSH
68093: CALL_OW 1
68097: ST_TO_ADDR
// end ; continue ;
68098: GO 67856
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
68100: LD_EXP 60
68104: PUSH
68105: LD_VAR 0 2
68109: ARRAY
68110: PUSH
68111: LD_INT 1
68113: ARRAY
68114: PUSH
68115: LD_INT 1
68117: ARRAY
68118: PPUSH
68119: LD_EXP 60
68123: PUSH
68124: LD_VAR 0 2
68128: ARRAY
68129: PUSH
68130: LD_INT 1
68132: ARRAY
68133: PUSH
68134: LD_INT 2
68136: ARRAY
68137: PPUSH
68138: LD_EXP 49
68142: PUSH
68143: LD_VAR 0 2
68147: ARRAY
68148: PPUSH
68149: CALL_OW 440
68153: IFFALSE 68196
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
68155: LD_ADDR_EXP 60
68159: PUSH
68160: LD_EXP 60
68164: PPUSH
68165: LD_VAR 0 2
68169: PPUSH
68170: LD_EXP 60
68174: PUSH
68175: LD_VAR 0 2
68179: ARRAY
68180: PPUSH
68181: LD_INT 1
68183: PPUSH
68184: CALL_OW 3
68188: PPUSH
68189: CALL_OW 1
68193: ST_TO_ADDR
68194: GO 68443
// begin if not mc_deposits_finder [ i ] then
68196: LD_EXP 61
68200: PUSH
68201: LD_VAR 0 2
68205: ARRAY
68206: NOT
68207: IFFALSE 68259
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
68209: LD_ADDR_EXP 61
68213: PUSH
68214: LD_EXP 61
68218: PPUSH
68219: LD_VAR 0 2
68223: PPUSH
68224: LD_VAR 0 3
68228: PUSH
68229: LD_INT 1
68231: ARRAY
68232: PUSH
68233: EMPTY
68234: LIST
68235: PPUSH
68236: CALL_OW 1
68240: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68241: LD_VAR 0 3
68245: PUSH
68246: LD_INT 1
68248: ARRAY
68249: PPUSH
68250: LD_INT 125
68252: PPUSH
68253: CALL_OW 109
// end else
68257: GO 68443
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68259: LD_EXP 61
68263: PUSH
68264: LD_VAR 0 2
68268: ARRAY
68269: PUSH
68270: LD_INT 1
68272: ARRAY
68273: PPUSH
68274: CALL_OW 310
68278: IFFALSE 68301
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68280: LD_EXP 61
68284: PUSH
68285: LD_VAR 0 2
68289: ARRAY
68290: PUSH
68291: LD_INT 1
68293: ARRAY
68294: PPUSH
68295: CALL_OW 122
68299: GO 68443
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68301: LD_EXP 61
68305: PUSH
68306: LD_VAR 0 2
68310: ARRAY
68311: PUSH
68312: LD_INT 1
68314: ARRAY
68315: PPUSH
68316: CALL_OW 314
68320: NOT
68321: PUSH
68322: LD_EXP 61
68326: PUSH
68327: LD_VAR 0 2
68331: ARRAY
68332: PUSH
68333: LD_INT 1
68335: ARRAY
68336: PPUSH
68337: LD_EXP 60
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PUSH
68348: LD_INT 1
68350: ARRAY
68351: PUSH
68352: LD_INT 1
68354: ARRAY
68355: PPUSH
68356: LD_EXP 60
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: PUSH
68367: LD_INT 1
68369: ARRAY
68370: PUSH
68371: LD_INT 2
68373: ARRAY
68374: PPUSH
68375: CALL_OW 297
68379: PUSH
68380: LD_INT 6
68382: GREATER
68383: AND
68384: IFFALSE 68443
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68386: LD_EXP 61
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: PUSH
68397: LD_INT 1
68399: ARRAY
68400: PPUSH
68401: LD_EXP 60
68405: PUSH
68406: LD_VAR 0 2
68410: ARRAY
68411: PUSH
68412: LD_INT 1
68414: ARRAY
68415: PUSH
68416: LD_INT 1
68418: ARRAY
68419: PPUSH
68420: LD_EXP 60
68424: PUSH
68425: LD_VAR 0 2
68429: ARRAY
68430: PUSH
68431: LD_INT 1
68433: ARRAY
68434: PUSH
68435: LD_INT 2
68437: ARRAY
68438: PPUSH
68439: CALL_OW 111
// end ; end ; end ;
68443: GO 67856
68445: POP
68446: POP
// end ;
68447: LD_VAR 0 1
68451: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
68452: LD_INT 0
68454: PPUSH
68455: PPUSH
68456: PPUSH
68457: PPUSH
68458: PPUSH
68459: PPUSH
68460: PPUSH
68461: PPUSH
68462: PPUSH
68463: PPUSH
68464: PPUSH
// if not mc_bases then
68465: LD_EXP 23
68469: NOT
68470: IFFALSE 68474
// exit ;
68472: GO 69414
// for i = 1 to mc_bases do
68474: LD_ADDR_VAR 0 2
68478: PUSH
68479: DOUBLE
68480: LD_INT 1
68482: DEC
68483: ST_TO_ADDR
68484: LD_EXP 23
68488: PUSH
68489: FOR_TO
68490: IFFALSE 69412
// begin if not mc_bases [ i ] or mc_scan [ i ] then
68492: LD_EXP 23
68496: PUSH
68497: LD_VAR 0 2
68501: ARRAY
68502: NOT
68503: PUSH
68504: LD_EXP 46
68508: PUSH
68509: LD_VAR 0 2
68513: ARRAY
68514: OR
68515: IFFALSE 68519
// continue ;
68517: GO 68489
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
68519: LD_ADDR_VAR 0 7
68523: PUSH
68524: LD_EXP 23
68528: PUSH
68529: LD_VAR 0 2
68533: ARRAY
68534: PUSH
68535: LD_INT 1
68537: ARRAY
68538: PPUSH
68539: CALL_OW 248
68543: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
68544: LD_VAR 0 7
68548: PUSH
68549: LD_INT 3
68551: EQUAL
68552: PUSH
68553: LD_EXP 42
68557: PUSH
68558: LD_VAR 0 2
68562: ARRAY
68563: PUSH
68564: LD_EXP 45
68568: PUSH
68569: LD_VAR 0 2
68573: ARRAY
68574: UNION
68575: PPUSH
68576: LD_INT 33
68578: PUSH
68579: LD_INT 2
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PPUSH
68586: CALL_OW 72
68590: NOT
68591: OR
68592: IFFALSE 68596
// continue ;
68594: GO 68489
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
68596: LD_ADDR_VAR 0 9
68600: PUSH
68601: LD_EXP 23
68605: PUSH
68606: LD_VAR 0 2
68610: ARRAY
68611: PPUSH
68612: LD_INT 30
68614: PUSH
68615: LD_INT 36
68617: PUSH
68618: EMPTY
68619: LIST
68620: LIST
68621: PPUSH
68622: CALL_OW 72
68626: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
68627: LD_ADDR_VAR 0 10
68631: PUSH
68632: LD_EXP 42
68636: PUSH
68637: LD_VAR 0 2
68641: ARRAY
68642: PPUSH
68643: LD_INT 34
68645: PUSH
68646: LD_INT 31
68648: PUSH
68649: EMPTY
68650: LIST
68651: LIST
68652: PPUSH
68653: CALL_OW 72
68657: ST_TO_ADDR
// if not cts and not mcts then
68658: LD_VAR 0 9
68662: NOT
68663: PUSH
68664: LD_VAR 0 10
68668: NOT
68669: AND
68670: IFFALSE 68674
// continue ;
68672: GO 68489
// x := cts ;
68674: LD_ADDR_VAR 0 11
68678: PUSH
68679: LD_VAR 0 9
68683: ST_TO_ADDR
// if not x then
68684: LD_VAR 0 11
68688: NOT
68689: IFFALSE 68701
// x := mcts ;
68691: LD_ADDR_VAR 0 11
68695: PUSH
68696: LD_VAR 0 10
68700: ST_TO_ADDR
// if not x then
68701: LD_VAR 0 11
68705: NOT
68706: IFFALSE 68710
// continue ;
68708: GO 68489
// if mc_remote_driver [ i ] then
68710: LD_EXP 63
68714: PUSH
68715: LD_VAR 0 2
68719: ARRAY
68720: IFFALSE 69107
// for j in mc_remote_driver [ i ] do
68722: LD_ADDR_VAR 0 3
68726: PUSH
68727: LD_EXP 63
68731: PUSH
68732: LD_VAR 0 2
68736: ARRAY
68737: PUSH
68738: FOR_IN
68739: IFFALSE 69105
// begin if GetClass ( j ) <> 3 then
68741: LD_VAR 0 3
68745: PPUSH
68746: CALL_OW 257
68750: PUSH
68751: LD_INT 3
68753: NONEQUAL
68754: IFFALSE 68807
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
68756: LD_ADDR_EXP 63
68760: PUSH
68761: LD_EXP 63
68765: PPUSH
68766: LD_VAR 0 2
68770: PPUSH
68771: LD_EXP 63
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PUSH
68782: LD_VAR 0 3
68786: DIFF
68787: PPUSH
68788: CALL_OW 1
68792: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68793: LD_VAR 0 3
68797: PPUSH
68798: LD_INT 0
68800: PPUSH
68801: CALL_OW 109
// continue ;
68805: GO 68738
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
68807: LD_EXP 42
68811: PUSH
68812: LD_VAR 0 2
68816: ARRAY
68817: PPUSH
68818: LD_INT 34
68820: PUSH
68821: LD_INT 31
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 58
68830: PUSH
68831: EMPTY
68832: LIST
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PPUSH
68838: CALL_OW 72
68842: PUSH
68843: LD_VAR 0 3
68847: PPUSH
68848: CALL 42977 0 1
68852: NOT
68853: AND
68854: IFFALSE 68925
// begin if IsInUnit ( j ) then
68856: LD_VAR 0 3
68860: PPUSH
68861: CALL_OW 310
68865: IFFALSE 68876
// ComExitBuilding ( j ) ;
68867: LD_VAR 0 3
68871: PPUSH
68872: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
68876: LD_VAR 0 3
68880: PPUSH
68881: LD_EXP 42
68885: PUSH
68886: LD_VAR 0 2
68890: ARRAY
68891: PPUSH
68892: LD_INT 34
68894: PUSH
68895: LD_INT 31
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 58
68904: PUSH
68905: EMPTY
68906: LIST
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PPUSH
68912: CALL_OW 72
68916: PUSH
68917: LD_INT 1
68919: ARRAY
68920: PPUSH
68921: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
68925: LD_VAR 0 3
68929: PPUSH
68930: CALL_OW 310
68934: NOT
68935: PUSH
68936: LD_VAR 0 3
68940: PPUSH
68941: CALL_OW 310
68945: PPUSH
68946: CALL_OW 266
68950: PUSH
68951: LD_INT 36
68953: NONEQUAL
68954: PUSH
68955: LD_VAR 0 3
68959: PPUSH
68960: CALL 42977 0 1
68964: NOT
68965: AND
68966: OR
68967: IFFALSE 69103
// begin if IsInUnit ( j ) then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 310
68978: IFFALSE 68989
// ComExitBuilding ( j ) ;
68980: LD_VAR 0 3
68984: PPUSH
68985: CALL_OW 122
// ct := 0 ;
68989: LD_ADDR_VAR 0 8
68993: PUSH
68994: LD_INT 0
68996: ST_TO_ADDR
// for k in x do
68997: LD_ADDR_VAR 0 4
69001: PUSH
69002: LD_VAR 0 11
69006: PUSH
69007: FOR_IN
69008: IFFALSE 69081
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
69010: LD_VAR 0 4
69014: PPUSH
69015: CALL_OW 264
69019: PUSH
69020: LD_INT 31
69022: EQUAL
69023: PUSH
69024: LD_VAR 0 4
69028: PPUSH
69029: CALL_OW 311
69033: NOT
69034: AND
69035: PUSH
69036: LD_VAR 0 4
69040: PPUSH
69041: CALL_OW 266
69045: PUSH
69046: LD_INT 36
69048: EQUAL
69049: PUSH
69050: LD_VAR 0 4
69054: PPUSH
69055: CALL_OW 313
69059: PUSH
69060: LD_INT 3
69062: LESS
69063: AND
69064: OR
69065: IFFALSE 69079
// begin ct := k ;
69067: LD_ADDR_VAR 0 8
69071: PUSH
69072: LD_VAR 0 4
69076: ST_TO_ADDR
// break ;
69077: GO 69081
// end ;
69079: GO 69007
69081: POP
69082: POP
// if ct then
69083: LD_VAR 0 8
69087: IFFALSE 69103
// ComEnterUnit ( j , ct ) ;
69089: LD_VAR 0 3
69093: PPUSH
69094: LD_VAR 0 8
69098: PPUSH
69099: CALL_OW 120
// end ; end ;
69103: GO 68738
69105: POP
69106: POP
// places := 0 ;
69107: LD_ADDR_VAR 0 5
69111: PUSH
69112: LD_INT 0
69114: ST_TO_ADDR
// for j = 1 to x do
69115: LD_ADDR_VAR 0 3
69119: PUSH
69120: DOUBLE
69121: LD_INT 1
69123: DEC
69124: ST_TO_ADDR
69125: LD_VAR 0 11
69129: PUSH
69130: FOR_TO
69131: IFFALSE 69207
// if GetWeapon ( x [ j ] ) = ar_control_tower then
69133: LD_VAR 0 11
69137: PUSH
69138: LD_VAR 0 3
69142: ARRAY
69143: PPUSH
69144: CALL_OW 264
69148: PUSH
69149: LD_INT 31
69151: EQUAL
69152: IFFALSE 69170
// places := places + 1 else
69154: LD_ADDR_VAR 0 5
69158: PUSH
69159: LD_VAR 0 5
69163: PUSH
69164: LD_INT 1
69166: PLUS
69167: ST_TO_ADDR
69168: GO 69205
// if GetBType ( x [ j ] ) = b_control_tower then
69170: LD_VAR 0 11
69174: PUSH
69175: LD_VAR 0 3
69179: ARRAY
69180: PPUSH
69181: CALL_OW 266
69185: PUSH
69186: LD_INT 36
69188: EQUAL
69189: IFFALSE 69205
// places := places + 3 ;
69191: LD_ADDR_VAR 0 5
69195: PUSH
69196: LD_VAR 0 5
69200: PUSH
69201: LD_INT 3
69203: PLUS
69204: ST_TO_ADDR
69205: GO 69130
69207: POP
69208: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
69209: LD_VAR 0 5
69213: PUSH
69214: LD_INT 0
69216: EQUAL
69217: PUSH
69218: LD_VAR 0 5
69222: PUSH
69223: LD_EXP 63
69227: PUSH
69228: LD_VAR 0 2
69232: ARRAY
69233: LESSEQUAL
69234: OR
69235: IFFALSE 69239
// continue ;
69237: GO 68489
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69239: LD_ADDR_VAR 0 6
69243: PUSH
69244: LD_EXP 23
69248: PUSH
69249: LD_VAR 0 2
69253: ARRAY
69254: PPUSH
69255: LD_INT 25
69257: PUSH
69258: LD_INT 3
69260: PUSH
69261: EMPTY
69262: LIST
69263: LIST
69264: PPUSH
69265: CALL_OW 72
69269: PUSH
69270: LD_EXP 63
69274: PUSH
69275: LD_VAR 0 2
69279: ARRAY
69280: DIFF
69281: PPUSH
69282: LD_INT 3
69284: PPUSH
69285: CALL 43877 0 2
69289: ST_TO_ADDR
// for j in tmp do
69290: LD_ADDR_VAR 0 3
69294: PUSH
69295: LD_VAR 0 6
69299: PUSH
69300: FOR_IN
69301: IFFALSE 69336
// if GetTag ( j ) > 0 then
69303: LD_VAR 0 3
69307: PPUSH
69308: CALL_OW 110
69312: PUSH
69313: LD_INT 0
69315: GREATER
69316: IFFALSE 69334
// tmp := tmp diff j ;
69318: LD_ADDR_VAR 0 6
69322: PUSH
69323: LD_VAR 0 6
69327: PUSH
69328: LD_VAR 0 3
69332: DIFF
69333: ST_TO_ADDR
69334: GO 69300
69336: POP
69337: POP
// if not tmp then
69338: LD_VAR 0 6
69342: NOT
69343: IFFALSE 69347
// continue ;
69345: GO 68489
// if places then
69347: LD_VAR 0 5
69351: IFFALSE 69410
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69353: LD_ADDR_EXP 63
69357: PUSH
69358: LD_EXP 63
69362: PPUSH
69363: LD_VAR 0 2
69367: PPUSH
69368: LD_EXP 63
69372: PUSH
69373: LD_VAR 0 2
69377: ARRAY
69378: PUSH
69379: LD_VAR 0 6
69383: PUSH
69384: LD_INT 1
69386: ARRAY
69387: UNION
69388: PPUSH
69389: CALL_OW 1
69393: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69394: LD_VAR 0 6
69398: PUSH
69399: LD_INT 1
69401: ARRAY
69402: PPUSH
69403: LD_INT 126
69405: PPUSH
69406: CALL_OW 109
// end ; end ;
69410: GO 68489
69412: POP
69413: POP
// end ;
69414: LD_VAR 0 1
69418: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
69419: LD_INT 0
69421: PPUSH
69422: PPUSH
69423: PPUSH
69424: PPUSH
69425: PPUSH
69426: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
69427: LD_VAR 0 1
69431: NOT
69432: PUSH
69433: LD_VAR 0 2
69437: NOT
69438: OR
69439: PUSH
69440: LD_VAR 0 3
69444: NOT
69445: OR
69446: PUSH
69447: LD_VAR 0 4
69451: PUSH
69452: LD_INT 1
69454: PUSH
69455: LD_INT 2
69457: PUSH
69458: LD_INT 3
69460: PUSH
69461: LD_INT 4
69463: PUSH
69464: LD_INT 5
69466: PUSH
69467: LD_INT 8
69469: PUSH
69470: LD_INT 9
69472: PUSH
69473: LD_INT 15
69475: PUSH
69476: LD_INT 16
69478: PUSH
69479: EMPTY
69480: LIST
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: IN
69490: NOT
69491: OR
69492: IFFALSE 69496
// exit ;
69494: GO 70396
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
69496: LD_ADDR_VAR 0 2
69500: PUSH
69501: LD_VAR 0 2
69505: PPUSH
69506: LD_INT 21
69508: PUSH
69509: LD_INT 3
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: PUSH
69516: LD_INT 24
69518: PUSH
69519: LD_INT 250
69521: PUSH
69522: EMPTY
69523: LIST
69524: LIST
69525: PUSH
69526: EMPTY
69527: LIST
69528: LIST
69529: PPUSH
69530: CALL_OW 72
69534: ST_TO_ADDR
// case class of 1 , 15 :
69535: LD_VAR 0 4
69539: PUSH
69540: LD_INT 1
69542: DOUBLE
69543: EQUAL
69544: IFTRUE 69554
69546: LD_INT 15
69548: DOUBLE
69549: EQUAL
69550: IFTRUE 69554
69552: GO 69639
69554: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
69555: LD_ADDR_VAR 0 8
69559: PUSH
69560: LD_VAR 0 2
69564: PPUSH
69565: LD_INT 2
69567: PUSH
69568: LD_INT 30
69570: PUSH
69571: LD_INT 32
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 30
69580: PUSH
69581: LD_INT 31
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: LIST
69592: PPUSH
69593: CALL_OW 72
69597: PUSH
69598: LD_VAR 0 2
69602: PPUSH
69603: LD_INT 2
69605: PUSH
69606: LD_INT 30
69608: PUSH
69609: LD_INT 4
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 30
69618: PUSH
69619: LD_INT 5
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: LIST
69630: PPUSH
69631: CALL_OW 72
69635: ADD
69636: ST_TO_ADDR
69637: GO 69885
69639: LD_INT 2
69641: DOUBLE
69642: EQUAL
69643: IFTRUE 69653
69645: LD_INT 16
69647: DOUBLE
69648: EQUAL
69649: IFTRUE 69653
69651: GO 69699
69653: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
69654: LD_ADDR_VAR 0 8
69658: PUSH
69659: LD_VAR 0 2
69663: PPUSH
69664: LD_INT 2
69666: PUSH
69667: LD_INT 30
69669: PUSH
69670: LD_INT 0
69672: PUSH
69673: EMPTY
69674: LIST
69675: LIST
69676: PUSH
69677: LD_INT 30
69679: PUSH
69680: LD_INT 1
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: LIST
69691: PPUSH
69692: CALL_OW 72
69696: ST_TO_ADDR
69697: GO 69885
69699: LD_INT 3
69701: DOUBLE
69702: EQUAL
69703: IFTRUE 69707
69705: GO 69753
69707: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
69708: LD_ADDR_VAR 0 8
69712: PUSH
69713: LD_VAR 0 2
69717: PPUSH
69718: LD_INT 2
69720: PUSH
69721: LD_INT 30
69723: PUSH
69724: LD_INT 2
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 30
69733: PUSH
69734: LD_INT 3
69736: PUSH
69737: EMPTY
69738: LIST
69739: LIST
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: LIST
69745: PPUSH
69746: CALL_OW 72
69750: ST_TO_ADDR
69751: GO 69885
69753: LD_INT 4
69755: DOUBLE
69756: EQUAL
69757: IFTRUE 69761
69759: GO 69818
69761: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
69762: LD_ADDR_VAR 0 8
69766: PUSH
69767: LD_VAR 0 2
69771: PPUSH
69772: LD_INT 2
69774: PUSH
69775: LD_INT 30
69777: PUSH
69778: LD_INT 6
69780: PUSH
69781: EMPTY
69782: LIST
69783: LIST
69784: PUSH
69785: LD_INT 30
69787: PUSH
69788: LD_INT 7
69790: PUSH
69791: EMPTY
69792: LIST
69793: LIST
69794: PUSH
69795: LD_INT 30
69797: PUSH
69798: LD_INT 8
69800: PUSH
69801: EMPTY
69802: LIST
69803: LIST
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: LIST
69809: LIST
69810: PPUSH
69811: CALL_OW 72
69815: ST_TO_ADDR
69816: GO 69885
69818: LD_INT 5
69820: DOUBLE
69821: EQUAL
69822: IFTRUE 69838
69824: LD_INT 8
69826: DOUBLE
69827: EQUAL
69828: IFTRUE 69838
69830: LD_INT 9
69832: DOUBLE
69833: EQUAL
69834: IFTRUE 69838
69836: GO 69884
69838: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
69839: LD_ADDR_VAR 0 8
69843: PUSH
69844: LD_VAR 0 2
69848: PPUSH
69849: LD_INT 2
69851: PUSH
69852: LD_INT 30
69854: PUSH
69855: LD_INT 4
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: LD_INT 30
69864: PUSH
69865: LD_INT 5
69867: PUSH
69868: EMPTY
69869: LIST
69870: LIST
69871: PUSH
69872: EMPTY
69873: LIST
69874: LIST
69875: LIST
69876: PPUSH
69877: CALL_OW 72
69881: ST_TO_ADDR
69882: GO 69885
69884: POP
// if not tmp then
69885: LD_VAR 0 8
69889: NOT
69890: IFFALSE 69894
// exit ;
69892: GO 70396
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
69894: LD_VAR 0 4
69898: PUSH
69899: LD_INT 1
69901: PUSH
69902: LD_INT 15
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: IN
69909: PUSH
69910: LD_EXP 32
69914: PUSH
69915: LD_VAR 0 1
69919: ARRAY
69920: AND
69921: IFFALSE 70077
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
69923: LD_ADDR_VAR 0 9
69927: PUSH
69928: LD_EXP 32
69932: PUSH
69933: LD_VAR 0 1
69937: ARRAY
69938: PUSH
69939: LD_INT 1
69941: ARRAY
69942: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
69943: LD_VAR 0 9
69947: PUSH
69948: LD_EXP 33
69952: PUSH
69953: LD_VAR 0 1
69957: ARRAY
69958: IN
69959: NOT
69960: IFFALSE 70075
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
69962: LD_ADDR_EXP 33
69966: PUSH
69967: LD_EXP 33
69971: PPUSH
69972: LD_VAR 0 1
69976: PUSH
69977: LD_EXP 33
69981: PUSH
69982: LD_VAR 0 1
69986: ARRAY
69987: PUSH
69988: LD_INT 1
69990: PLUS
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PPUSH
69996: LD_VAR 0 9
70000: PPUSH
70001: CALL 13619 0 3
70005: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
70006: LD_ADDR_EXP 32
70010: PUSH
70011: LD_EXP 32
70015: PPUSH
70016: LD_VAR 0 1
70020: PPUSH
70021: LD_EXP 32
70025: PUSH
70026: LD_VAR 0 1
70030: ARRAY
70031: PUSH
70032: LD_VAR 0 9
70036: DIFF
70037: PPUSH
70038: CALL_OW 1
70042: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
70043: LD_VAR 0 3
70047: PPUSH
70048: LD_EXP 33
70052: PUSH
70053: LD_VAR 0 1
70057: ARRAY
70058: PUSH
70059: LD_EXP 33
70063: PUSH
70064: LD_VAR 0 1
70068: ARRAY
70069: ARRAY
70070: PPUSH
70071: CALL_OW 120
// end ; exit ;
70075: GO 70396
// end ; if tmp > 1 then
70077: LD_VAR 0 8
70081: PUSH
70082: LD_INT 1
70084: GREATER
70085: IFFALSE 70189
// for i = 2 to tmp do
70087: LD_ADDR_VAR 0 6
70091: PUSH
70092: DOUBLE
70093: LD_INT 2
70095: DEC
70096: ST_TO_ADDR
70097: LD_VAR 0 8
70101: PUSH
70102: FOR_TO
70103: IFFALSE 70187
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
70105: LD_VAR 0 8
70109: PUSH
70110: LD_VAR 0 6
70114: ARRAY
70115: PPUSH
70116: CALL_OW 461
70120: PUSH
70121: LD_INT 6
70123: EQUAL
70124: IFFALSE 70185
// begin x := tmp [ i ] ;
70126: LD_ADDR_VAR 0 9
70130: PUSH
70131: LD_VAR 0 8
70135: PUSH
70136: LD_VAR 0 6
70140: ARRAY
70141: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
70142: LD_ADDR_VAR 0 8
70146: PUSH
70147: LD_VAR 0 8
70151: PPUSH
70152: LD_VAR 0 6
70156: PPUSH
70157: CALL_OW 3
70161: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
70162: LD_ADDR_VAR 0 8
70166: PUSH
70167: LD_VAR 0 8
70171: PPUSH
70172: LD_INT 1
70174: PPUSH
70175: LD_VAR 0 9
70179: PPUSH
70180: CALL_OW 2
70184: ST_TO_ADDR
// end ;
70185: GO 70102
70187: POP
70188: POP
// for i in tmp do
70189: LD_ADDR_VAR 0 6
70193: PUSH
70194: LD_VAR 0 8
70198: PUSH
70199: FOR_IN
70200: IFFALSE 70269
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
70202: LD_VAR 0 6
70206: PPUSH
70207: CALL_OW 313
70211: PUSH
70212: LD_INT 6
70214: LESS
70215: PUSH
70216: LD_VAR 0 6
70220: PPUSH
70221: CALL_OW 266
70225: PUSH
70226: LD_INT 31
70228: PUSH
70229: LD_INT 32
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: IN
70236: NOT
70237: AND
70238: PUSH
70239: LD_VAR 0 6
70243: PPUSH
70244: CALL_OW 313
70248: PUSH
70249: LD_INT 0
70251: EQUAL
70252: OR
70253: IFFALSE 70267
// begin j := i ;
70255: LD_ADDR_VAR 0 7
70259: PUSH
70260: LD_VAR 0 6
70264: ST_TO_ADDR
// break ;
70265: GO 70269
// end ; end ;
70267: GO 70199
70269: POP
70270: POP
// if j then
70271: LD_VAR 0 7
70275: IFFALSE 70293
// ComEnterUnit ( unit , j ) else
70277: LD_VAR 0 3
70281: PPUSH
70282: LD_VAR 0 7
70286: PPUSH
70287: CALL_OW 120
70291: GO 70396
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70293: LD_ADDR_VAR 0 10
70297: PUSH
70298: LD_VAR 0 2
70302: PPUSH
70303: LD_INT 2
70305: PUSH
70306: LD_INT 30
70308: PUSH
70309: LD_INT 0
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 30
70318: PUSH
70319: LD_INT 1
70321: PUSH
70322: EMPTY
70323: LIST
70324: LIST
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: LIST
70330: PPUSH
70331: CALL_OW 72
70335: ST_TO_ADDR
// if depot then
70336: LD_VAR 0 10
70340: IFFALSE 70396
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70342: LD_ADDR_VAR 0 10
70346: PUSH
70347: LD_VAR 0 10
70351: PPUSH
70352: LD_VAR 0 3
70356: PPUSH
70357: CALL_OW 74
70361: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70362: LD_VAR 0 3
70366: PPUSH
70367: LD_VAR 0 10
70371: PPUSH
70372: CALL_OW 296
70376: PUSH
70377: LD_INT 10
70379: GREATER
70380: IFFALSE 70396
// ComStandNearbyBuilding ( unit , depot ) ;
70382: LD_VAR 0 3
70386: PPUSH
70387: LD_VAR 0 10
70391: PPUSH
70392: CALL 10197 0 2
// end ; end ; end ;
70396: LD_VAR 0 5
70400: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
70401: LD_INT 0
70403: PPUSH
70404: PPUSH
70405: PPUSH
70406: PPUSH
// if not mc_bases then
70407: LD_EXP 23
70411: NOT
70412: IFFALSE 70416
// exit ;
70414: GO 70655
// for i = 1 to mc_bases do
70416: LD_ADDR_VAR 0 2
70420: PUSH
70421: DOUBLE
70422: LD_INT 1
70424: DEC
70425: ST_TO_ADDR
70426: LD_EXP 23
70430: PUSH
70431: FOR_TO
70432: IFFALSE 70653
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
70434: LD_ADDR_VAR 0 4
70438: PUSH
70439: LD_EXP 23
70443: PUSH
70444: LD_VAR 0 2
70448: ARRAY
70449: PPUSH
70450: LD_INT 21
70452: PUSH
70453: LD_INT 1
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PPUSH
70460: CALL_OW 72
70464: PUSH
70465: LD_EXP 52
70469: PUSH
70470: LD_VAR 0 2
70474: ARRAY
70475: UNION
70476: ST_TO_ADDR
// if not tmp then
70477: LD_VAR 0 4
70481: NOT
70482: IFFALSE 70486
// continue ;
70484: GO 70431
// for j in tmp do
70486: LD_ADDR_VAR 0 3
70490: PUSH
70491: LD_VAR 0 4
70495: PUSH
70496: FOR_IN
70497: IFFALSE 70649
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
70499: LD_VAR 0 3
70503: PPUSH
70504: CALL_OW 110
70508: NOT
70509: PUSH
70510: LD_VAR 0 3
70514: PPUSH
70515: CALL_OW 314
70519: NOT
70520: AND
70521: PUSH
70522: LD_VAR 0 3
70526: PPUSH
70527: CALL_OW 311
70531: NOT
70532: AND
70533: PUSH
70534: LD_VAR 0 3
70538: PPUSH
70539: CALL_OW 310
70543: NOT
70544: AND
70545: PUSH
70546: LD_VAR 0 3
70550: PUSH
70551: LD_EXP 26
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: PUSH
70562: LD_INT 1
70564: ARRAY
70565: IN
70566: NOT
70567: AND
70568: PUSH
70569: LD_VAR 0 3
70573: PUSH
70574: LD_EXP 26
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: PUSH
70585: LD_INT 2
70587: ARRAY
70588: IN
70589: NOT
70590: AND
70591: PUSH
70592: LD_VAR 0 3
70596: PUSH
70597: LD_EXP 35
70601: PUSH
70602: LD_VAR 0 2
70606: ARRAY
70607: IN
70608: NOT
70609: AND
70610: IFFALSE 70647
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
70612: LD_VAR 0 2
70616: PPUSH
70617: LD_EXP 23
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: PPUSH
70628: LD_VAR 0 3
70632: PPUSH
70633: LD_VAR 0 3
70637: PPUSH
70638: CALL_OW 257
70642: PPUSH
70643: CALL 69419 0 4
// end ;
70647: GO 70496
70649: POP
70650: POP
// end ;
70651: GO 70431
70653: POP
70654: POP
// end ;
70655: LD_VAR 0 1
70659: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
70660: LD_INT 0
70662: PPUSH
70663: PPUSH
70664: PPUSH
70665: PPUSH
70666: PPUSH
70667: PPUSH
// if not mc_bases [ base ] then
70668: LD_EXP 23
70672: PUSH
70673: LD_VAR 0 1
70677: ARRAY
70678: NOT
70679: IFFALSE 70683
// exit ;
70681: GO 70865
// tmp := [ ] ;
70683: LD_ADDR_VAR 0 6
70687: PUSH
70688: EMPTY
70689: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
70690: LD_ADDR_VAR 0 7
70694: PUSH
70695: LD_VAR 0 3
70699: PPUSH
70700: LD_INT 0
70702: PPUSH
70703: CALL_OW 517
70707: ST_TO_ADDR
// if not list then
70708: LD_VAR 0 7
70712: NOT
70713: IFFALSE 70717
// exit ;
70715: GO 70865
// for i = 1 to amount do
70717: LD_ADDR_VAR 0 5
70721: PUSH
70722: DOUBLE
70723: LD_INT 1
70725: DEC
70726: ST_TO_ADDR
70727: LD_VAR 0 2
70731: PUSH
70732: FOR_TO
70733: IFFALSE 70813
// begin x := rand ( 1 , list [ 1 ] ) ;
70735: LD_ADDR_VAR 0 8
70739: PUSH
70740: LD_INT 1
70742: PPUSH
70743: LD_VAR 0 7
70747: PUSH
70748: LD_INT 1
70750: ARRAY
70751: PPUSH
70752: CALL_OW 12
70756: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
70757: LD_ADDR_VAR 0 6
70761: PUSH
70762: LD_VAR 0 6
70766: PPUSH
70767: LD_VAR 0 5
70771: PPUSH
70772: LD_VAR 0 7
70776: PUSH
70777: LD_INT 1
70779: ARRAY
70780: PUSH
70781: LD_VAR 0 8
70785: ARRAY
70786: PUSH
70787: LD_VAR 0 7
70791: PUSH
70792: LD_INT 2
70794: ARRAY
70795: PUSH
70796: LD_VAR 0 8
70800: ARRAY
70801: PUSH
70802: EMPTY
70803: LIST
70804: LIST
70805: PPUSH
70806: CALL_OW 1
70810: ST_TO_ADDR
// end ;
70811: GO 70732
70813: POP
70814: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
70815: LD_ADDR_EXP 36
70819: PUSH
70820: LD_EXP 36
70824: PPUSH
70825: LD_VAR 0 1
70829: PPUSH
70830: LD_VAR 0 6
70834: PPUSH
70835: CALL_OW 1
70839: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
70840: LD_ADDR_EXP 38
70844: PUSH
70845: LD_EXP 38
70849: PPUSH
70850: LD_VAR 0 1
70854: PPUSH
70855: LD_VAR 0 3
70859: PPUSH
70860: CALL_OW 1
70864: ST_TO_ADDR
// end ;
70865: LD_VAR 0 4
70869: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
70870: LD_INT 0
70872: PPUSH
// if not mc_bases [ base ] then
70873: LD_EXP 23
70877: PUSH
70878: LD_VAR 0 1
70882: ARRAY
70883: NOT
70884: IFFALSE 70888
// exit ;
70886: GO 70913
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
70888: LD_ADDR_EXP 28
70892: PUSH
70893: LD_EXP 28
70897: PPUSH
70898: LD_VAR 0 1
70902: PPUSH
70903: LD_VAR 0 2
70907: PPUSH
70908: CALL_OW 1
70912: ST_TO_ADDR
// end ;
70913: LD_VAR 0 3
70917: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
70918: LD_INT 0
70920: PPUSH
// if not mc_bases [ base ] then
70921: LD_EXP 23
70925: PUSH
70926: LD_VAR 0 1
70930: ARRAY
70931: NOT
70932: IFFALSE 70936
// exit ;
70934: GO 70973
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
70936: LD_ADDR_EXP 28
70940: PUSH
70941: LD_EXP 28
70945: PPUSH
70946: LD_VAR 0 1
70950: PPUSH
70951: LD_EXP 28
70955: PUSH
70956: LD_VAR 0 1
70960: ARRAY
70961: PUSH
70962: LD_VAR 0 2
70966: UNION
70967: PPUSH
70968: CALL_OW 1
70972: ST_TO_ADDR
// end ;
70973: LD_VAR 0 3
70977: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
70978: LD_INT 0
70980: PPUSH
// if not mc_bases [ base ] then
70981: LD_EXP 23
70985: PUSH
70986: LD_VAR 0 1
70990: ARRAY
70991: NOT
70992: IFFALSE 70996
// exit ;
70994: GO 71021
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
70996: LD_ADDR_EXP 44
71000: PUSH
71001: LD_EXP 44
71005: PPUSH
71006: LD_VAR 0 1
71010: PPUSH
71011: LD_VAR 0 2
71015: PPUSH
71016: CALL_OW 1
71020: ST_TO_ADDR
// end ;
71021: LD_VAR 0 3
71025: RET
// export function MC_InsertProduceList ( base , components ) ; begin
71026: LD_INT 0
71028: PPUSH
// if not mc_bases [ base ] then
71029: LD_EXP 23
71033: PUSH
71034: LD_VAR 0 1
71038: ARRAY
71039: NOT
71040: IFFALSE 71044
// exit ;
71042: GO 71081
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
71044: LD_ADDR_EXP 44
71048: PUSH
71049: LD_EXP 44
71053: PPUSH
71054: LD_VAR 0 1
71058: PPUSH
71059: LD_EXP 44
71063: PUSH
71064: LD_VAR 0 1
71068: ARRAY
71069: PUSH
71070: LD_VAR 0 2
71074: ADD
71075: PPUSH
71076: CALL_OW 1
71080: ST_TO_ADDR
// end ;
71081: LD_VAR 0 3
71085: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
71086: LD_INT 0
71088: PPUSH
// if not mc_bases [ base ] then
71089: LD_EXP 23
71093: PUSH
71094: LD_VAR 0 1
71098: ARRAY
71099: NOT
71100: IFFALSE 71104
// exit ;
71102: GO 71158
// mc_defender := Replace ( mc_defender , base , deflist ) ;
71104: LD_ADDR_EXP 45
71108: PUSH
71109: LD_EXP 45
71113: PPUSH
71114: LD_VAR 0 1
71118: PPUSH
71119: LD_VAR 0 2
71123: PPUSH
71124: CALL_OW 1
71128: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
71129: LD_ADDR_EXP 34
71133: PUSH
71134: LD_EXP 34
71138: PPUSH
71139: LD_VAR 0 1
71143: PPUSH
71144: LD_VAR 0 2
71148: PUSH
71149: LD_INT 0
71151: PLUS
71152: PPUSH
71153: CALL_OW 1
71157: ST_TO_ADDR
// end ;
71158: LD_VAR 0 3
71162: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
71163: LD_INT 0
71165: PPUSH
// if not mc_bases [ base ] then
71166: LD_EXP 23
71170: PUSH
71171: LD_VAR 0 1
71175: ARRAY
71176: NOT
71177: IFFALSE 71181
// exit ;
71179: GO 71206
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
71181: LD_ADDR_EXP 34
71185: PUSH
71186: LD_EXP 34
71190: PPUSH
71191: LD_VAR 0 1
71195: PPUSH
71196: LD_VAR 0 2
71200: PPUSH
71201: CALL_OW 1
71205: ST_TO_ADDR
// end ;
71206: LD_VAR 0 3
71210: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
71211: LD_INT 0
71213: PPUSH
71214: PPUSH
71215: PPUSH
71216: PPUSH
// if not mc_bases [ base ] then
71217: LD_EXP 23
71221: PUSH
71222: LD_VAR 0 1
71226: ARRAY
71227: NOT
71228: IFFALSE 71232
// exit ;
71230: GO 71297
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
71232: LD_ADDR_EXP 43
71236: PUSH
71237: LD_EXP 43
71241: PPUSH
71242: LD_VAR 0 1
71246: PUSH
71247: LD_EXP 43
71251: PUSH
71252: LD_VAR 0 1
71256: ARRAY
71257: PUSH
71258: LD_INT 1
71260: PLUS
71261: PUSH
71262: EMPTY
71263: LIST
71264: LIST
71265: PPUSH
71266: LD_VAR 0 1
71270: PUSH
71271: LD_VAR 0 2
71275: PUSH
71276: LD_VAR 0 3
71280: PUSH
71281: LD_VAR 0 4
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: PPUSH
71292: CALL 13619 0 3
71296: ST_TO_ADDR
// end ;
71297: LD_VAR 0 5
71301: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71302: LD_INT 0
71304: PPUSH
// if not mc_bases [ base ] then
71305: LD_EXP 23
71309: PUSH
71310: LD_VAR 0 1
71314: ARRAY
71315: NOT
71316: IFFALSE 71320
// exit ;
71318: GO 71345
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71320: LD_ADDR_EXP 60
71324: PUSH
71325: LD_EXP 60
71329: PPUSH
71330: LD_VAR 0 1
71334: PPUSH
71335: LD_VAR 0 2
71339: PPUSH
71340: CALL_OW 1
71344: ST_TO_ADDR
// end ;
71345: LD_VAR 0 3
71349: RET
// export function MC_GetMinesField ( base ) ; begin
71350: LD_INT 0
71352: PPUSH
// result := mc_mines [ base ] ;
71353: LD_ADDR_VAR 0 2
71357: PUSH
71358: LD_EXP 36
71362: PUSH
71363: LD_VAR 0 1
71367: ARRAY
71368: ST_TO_ADDR
// end ;
71369: LD_VAR 0 2
71373: RET
// export function MC_GetProduceList ( base ) ; begin
71374: LD_INT 0
71376: PPUSH
// result := mc_produce [ base ] ;
71377: LD_ADDR_VAR 0 2
71381: PUSH
71382: LD_EXP 44
71386: PUSH
71387: LD_VAR 0 1
71391: ARRAY
71392: ST_TO_ADDR
// end ;
71393: LD_VAR 0 2
71397: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71398: LD_INT 0
71400: PPUSH
71401: PPUSH
// if not mc_bases then
71402: LD_EXP 23
71406: NOT
71407: IFFALSE 71411
// exit ;
71409: GO 71476
// if mc_bases [ base ] then
71411: LD_EXP 23
71415: PUSH
71416: LD_VAR 0 1
71420: ARRAY
71421: IFFALSE 71476
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71423: LD_ADDR_VAR 0 3
71427: PUSH
71428: LD_EXP 23
71432: PUSH
71433: LD_VAR 0 1
71437: ARRAY
71438: PPUSH
71439: LD_INT 30
71441: PUSH
71442: LD_VAR 0 2
71446: PUSH
71447: EMPTY
71448: LIST
71449: LIST
71450: PPUSH
71451: CALL_OW 72
71455: ST_TO_ADDR
// if result then
71456: LD_VAR 0 3
71460: IFFALSE 71476
// result := result [ 1 ] ;
71462: LD_ADDR_VAR 0 3
71466: PUSH
71467: LD_VAR 0 3
71471: PUSH
71472: LD_INT 1
71474: ARRAY
71475: ST_TO_ADDR
// end ; end ;
71476: LD_VAR 0 3
71480: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
71481: LD_INT 0
71483: PPUSH
71484: PPUSH
// if not mc_bases then
71485: LD_EXP 23
71489: NOT
71490: IFFALSE 71494
// exit ;
71492: GO 71539
// if mc_bases [ base ] then
71494: LD_EXP 23
71498: PUSH
71499: LD_VAR 0 1
71503: ARRAY
71504: IFFALSE 71539
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71506: LD_ADDR_VAR 0 3
71510: PUSH
71511: LD_EXP 23
71515: PUSH
71516: LD_VAR 0 1
71520: ARRAY
71521: PPUSH
71522: LD_INT 30
71524: PUSH
71525: LD_VAR 0 2
71529: PUSH
71530: EMPTY
71531: LIST
71532: LIST
71533: PPUSH
71534: CALL_OW 72
71538: ST_TO_ADDR
// end ;
71539: LD_VAR 0 3
71543: RET
// export function MC_SetTame ( base , area ) ; begin
71544: LD_INT 0
71546: PPUSH
// if not mc_bases or not base then
71547: LD_EXP 23
71551: NOT
71552: PUSH
71553: LD_VAR 0 1
71557: NOT
71558: OR
71559: IFFALSE 71563
// exit ;
71561: GO 71588
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
71563: LD_ADDR_EXP 51
71567: PUSH
71568: LD_EXP 51
71572: PPUSH
71573: LD_VAR 0 1
71577: PPUSH
71578: LD_VAR 0 2
71582: PPUSH
71583: CALL_OW 1
71587: ST_TO_ADDR
// end ;
71588: LD_VAR 0 3
71592: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
71593: LD_INT 0
71595: PPUSH
71596: PPUSH
// if not mc_bases or not base then
71597: LD_EXP 23
71601: NOT
71602: PUSH
71603: LD_VAR 0 1
71607: NOT
71608: OR
71609: IFFALSE 71613
// exit ;
71611: GO 71715
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
71613: LD_ADDR_VAR 0 4
71617: PUSH
71618: LD_EXP 23
71622: PUSH
71623: LD_VAR 0 1
71627: ARRAY
71628: PPUSH
71629: LD_INT 30
71631: PUSH
71632: LD_VAR 0 2
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PPUSH
71641: CALL_OW 72
71645: ST_TO_ADDR
// if not tmp then
71646: LD_VAR 0 4
71650: NOT
71651: IFFALSE 71655
// exit ;
71653: GO 71715
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
71655: LD_ADDR_EXP 55
71659: PUSH
71660: LD_EXP 55
71664: PPUSH
71665: LD_VAR 0 1
71669: PPUSH
71670: LD_EXP 55
71674: PUSH
71675: LD_VAR 0 1
71679: ARRAY
71680: PPUSH
71681: LD_EXP 55
71685: PUSH
71686: LD_VAR 0 1
71690: ARRAY
71691: PUSH
71692: LD_INT 1
71694: PLUS
71695: PPUSH
71696: LD_VAR 0 4
71700: PUSH
71701: LD_INT 1
71703: ARRAY
71704: PPUSH
71705: CALL_OW 2
71709: PPUSH
71710: CALL_OW 1
71714: ST_TO_ADDR
// end ;
71715: LD_VAR 0 3
71719: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
71720: LD_INT 0
71722: PPUSH
71723: PPUSH
// if not mc_bases or not base or not kinds then
71724: LD_EXP 23
71728: NOT
71729: PUSH
71730: LD_VAR 0 1
71734: NOT
71735: OR
71736: PUSH
71737: LD_VAR 0 2
71741: NOT
71742: OR
71743: IFFALSE 71747
// exit ;
71745: GO 71808
// for i in kinds do
71747: LD_ADDR_VAR 0 4
71751: PUSH
71752: LD_VAR 0 2
71756: PUSH
71757: FOR_IN
71758: IFFALSE 71806
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
71760: LD_ADDR_EXP 57
71764: PUSH
71765: LD_EXP 57
71769: PPUSH
71770: LD_VAR 0 1
71774: PUSH
71775: LD_EXP 57
71779: PUSH
71780: LD_VAR 0 1
71784: ARRAY
71785: PUSH
71786: LD_INT 1
71788: PLUS
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PPUSH
71794: LD_VAR 0 4
71798: PPUSH
71799: CALL 13619 0 3
71803: ST_TO_ADDR
71804: GO 71757
71806: POP
71807: POP
// end ;
71808: LD_VAR 0 3
71812: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
71813: LD_INT 0
71815: PPUSH
// if not mc_bases or not base or not areas then
71816: LD_EXP 23
71820: NOT
71821: PUSH
71822: LD_VAR 0 1
71826: NOT
71827: OR
71828: PUSH
71829: LD_VAR 0 2
71833: NOT
71834: OR
71835: IFFALSE 71839
// exit ;
71837: GO 71864
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
71839: LD_ADDR_EXP 41
71843: PUSH
71844: LD_EXP 41
71848: PPUSH
71849: LD_VAR 0 1
71853: PPUSH
71854: LD_VAR 0 2
71858: PPUSH
71859: CALL_OW 1
71863: ST_TO_ADDR
// end ;
71864: LD_VAR 0 3
71868: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
71869: LD_INT 0
71871: PPUSH
// if not mc_bases or not base or not teleports_exit then
71872: LD_EXP 23
71876: NOT
71877: PUSH
71878: LD_VAR 0 1
71882: NOT
71883: OR
71884: PUSH
71885: LD_VAR 0 2
71889: NOT
71890: OR
71891: IFFALSE 71895
// exit ;
71893: GO 71920
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
71895: LD_ADDR_EXP 58
71899: PUSH
71900: LD_EXP 58
71904: PPUSH
71905: LD_VAR 0 1
71909: PPUSH
71910: LD_VAR 0 2
71914: PPUSH
71915: CALL_OW 1
71919: ST_TO_ADDR
// end ;
71920: LD_VAR 0 3
71924: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
71925: LD_INT 0
71927: PPUSH
71928: PPUSH
71929: PPUSH
// if not mc_bases or not base or not ext_list then
71930: LD_EXP 23
71934: NOT
71935: PUSH
71936: LD_VAR 0 1
71940: NOT
71941: OR
71942: PUSH
71943: LD_VAR 0 5
71947: NOT
71948: OR
71949: IFFALSE 71953
// exit ;
71951: GO 72126
// tmp := GetFacExtXYD ( x , y , d ) ;
71953: LD_ADDR_VAR 0 8
71957: PUSH
71958: LD_VAR 0 2
71962: PPUSH
71963: LD_VAR 0 3
71967: PPUSH
71968: LD_VAR 0 4
71972: PPUSH
71973: CALL 43007 0 3
71977: ST_TO_ADDR
// if not tmp then
71978: LD_VAR 0 8
71982: NOT
71983: IFFALSE 71987
// exit ;
71985: GO 72126
// for i in tmp do
71987: LD_ADDR_VAR 0 7
71991: PUSH
71992: LD_VAR 0 8
71996: PUSH
71997: FOR_IN
71998: IFFALSE 72124
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
72000: LD_ADDR_EXP 28
72004: PUSH
72005: LD_EXP 28
72009: PPUSH
72010: LD_VAR 0 1
72014: PPUSH
72015: LD_EXP 28
72019: PUSH
72020: LD_VAR 0 1
72024: ARRAY
72025: PPUSH
72026: LD_EXP 28
72030: PUSH
72031: LD_VAR 0 1
72035: ARRAY
72036: PUSH
72037: LD_INT 1
72039: PLUS
72040: PPUSH
72041: LD_VAR 0 5
72045: PUSH
72046: LD_INT 1
72048: ARRAY
72049: PUSH
72050: LD_VAR 0 7
72054: PUSH
72055: LD_INT 1
72057: ARRAY
72058: PUSH
72059: LD_VAR 0 7
72063: PUSH
72064: LD_INT 2
72066: ARRAY
72067: PUSH
72068: LD_VAR 0 7
72072: PUSH
72073: LD_INT 3
72075: ARRAY
72076: PUSH
72077: EMPTY
72078: LIST
72079: LIST
72080: LIST
72081: LIST
72082: PPUSH
72083: CALL_OW 2
72087: PPUSH
72088: CALL_OW 1
72092: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
72093: LD_ADDR_VAR 0 5
72097: PUSH
72098: LD_VAR 0 5
72102: PPUSH
72103: LD_INT 1
72105: PPUSH
72106: CALL_OW 3
72110: ST_TO_ADDR
// if not ext_list then
72111: LD_VAR 0 5
72115: NOT
72116: IFFALSE 72122
// exit ;
72118: POP
72119: POP
72120: GO 72126
// end ;
72122: GO 71997
72124: POP
72125: POP
// end ;
72126: LD_VAR 0 6
72130: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
72131: LD_INT 0
72133: PPUSH
// if not mc_bases or not base or not weapon_list then
72134: LD_EXP 23
72138: NOT
72139: PUSH
72140: LD_VAR 0 1
72144: NOT
72145: OR
72146: PUSH
72147: LD_VAR 0 2
72151: NOT
72152: OR
72153: IFFALSE 72157
// exit ;
72155: GO 72182
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
72157: LD_ADDR_EXP 62
72161: PUSH
72162: LD_EXP 62
72166: PPUSH
72167: LD_VAR 0 1
72171: PPUSH
72172: LD_VAR 0 2
72176: PPUSH
72177: CALL_OW 1
72181: ST_TO_ADDR
// end ;
72182: LD_VAR 0 3
72186: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
72187: LD_INT 0
72189: PPUSH
// if not mc_bases or not base or not tech_list then
72190: LD_EXP 23
72194: NOT
72195: PUSH
72196: LD_VAR 0 1
72200: NOT
72201: OR
72202: PUSH
72203: LD_VAR 0 2
72207: NOT
72208: OR
72209: IFFALSE 72213
// exit ;
72211: GO 72238
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
72213: LD_ADDR_EXP 50
72217: PUSH
72218: LD_EXP 50
72222: PPUSH
72223: LD_VAR 0 1
72227: PPUSH
72228: LD_VAR 0 2
72232: PPUSH
72233: CALL_OW 1
72237: ST_TO_ADDR
// end ;
72238: LD_VAR 0 3
72242: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72243: LD_INT 0
72245: PPUSH
// if not mc_bases or not parking_area or not base then
72246: LD_EXP 23
72250: NOT
72251: PUSH
72252: LD_VAR 0 2
72256: NOT
72257: OR
72258: PUSH
72259: LD_VAR 0 1
72263: NOT
72264: OR
72265: IFFALSE 72269
// exit ;
72267: GO 72294
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72269: LD_ADDR_EXP 47
72273: PUSH
72274: LD_EXP 47
72278: PPUSH
72279: LD_VAR 0 1
72283: PPUSH
72284: LD_VAR 0 2
72288: PPUSH
72289: CALL_OW 1
72293: ST_TO_ADDR
// end ;
72294: LD_VAR 0 3
72298: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72299: LD_INT 0
72301: PPUSH
// if not mc_bases or not base or not scan_area then
72302: LD_EXP 23
72306: NOT
72307: PUSH
72308: LD_VAR 0 1
72312: NOT
72313: OR
72314: PUSH
72315: LD_VAR 0 2
72319: NOT
72320: OR
72321: IFFALSE 72325
// exit ;
72323: GO 72350
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72325: LD_ADDR_EXP 48
72329: PUSH
72330: LD_EXP 48
72334: PPUSH
72335: LD_VAR 0 1
72339: PPUSH
72340: LD_VAR 0 2
72344: PPUSH
72345: CALL_OW 1
72349: ST_TO_ADDR
// end ;
72350: LD_VAR 0 3
72354: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72355: LD_INT 0
72357: PPUSH
72358: PPUSH
// if not mc_bases or not base then
72359: LD_EXP 23
72363: NOT
72364: PUSH
72365: LD_VAR 0 1
72369: NOT
72370: OR
72371: IFFALSE 72375
// exit ;
72373: GO 72439
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72375: LD_ADDR_VAR 0 3
72379: PUSH
72380: LD_INT 1
72382: PUSH
72383: LD_INT 2
72385: PUSH
72386: LD_INT 3
72388: PUSH
72389: LD_INT 4
72391: PUSH
72392: LD_INT 11
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: LIST
72399: LIST
72400: LIST
72401: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
72402: LD_ADDR_EXP 50
72406: PUSH
72407: LD_EXP 50
72411: PPUSH
72412: LD_VAR 0 1
72416: PPUSH
72417: LD_EXP 50
72421: PUSH
72422: LD_VAR 0 1
72426: ARRAY
72427: PUSH
72428: LD_VAR 0 3
72432: DIFF
72433: PPUSH
72434: CALL_OW 1
72438: ST_TO_ADDR
// end ;
72439: LD_VAR 0 2
72443: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
72444: LD_INT 0
72446: PPUSH
// result := mc_vehicles [ base ] ;
72447: LD_ADDR_VAR 0 3
72451: PUSH
72452: LD_EXP 42
72456: PUSH
72457: LD_VAR 0 1
72461: ARRAY
72462: ST_TO_ADDR
// if onlyCombat then
72463: LD_VAR 0 2
72467: IFFALSE 72645
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
72469: LD_ADDR_VAR 0 3
72473: PUSH
72474: LD_VAR 0 3
72478: PUSH
72479: LD_VAR 0 3
72483: PPUSH
72484: LD_INT 2
72486: PUSH
72487: LD_INT 34
72489: PUSH
72490: LD_INT 12
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PUSH
72497: LD_INT 34
72499: PUSH
72500: LD_INT 51
72502: PUSH
72503: EMPTY
72504: LIST
72505: LIST
72506: PUSH
72507: LD_INT 34
72509: PUSH
72510: LD_EXP 68
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 34
72521: PUSH
72522: LD_INT 32
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 34
72531: PUSH
72532: LD_INT 13
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 34
72541: PUSH
72542: LD_INT 52
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 34
72551: PUSH
72552: LD_EXP 73
72556: PUSH
72557: EMPTY
72558: LIST
72559: LIST
72560: PUSH
72561: LD_INT 34
72563: PUSH
72564: LD_INT 14
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PUSH
72571: LD_INT 34
72573: PUSH
72574: LD_INT 53
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 34
72583: PUSH
72584: LD_EXP 67
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PUSH
72593: LD_INT 34
72595: PUSH
72596: LD_INT 31
72598: PUSH
72599: EMPTY
72600: LIST
72601: LIST
72602: PUSH
72603: LD_INT 34
72605: PUSH
72606: LD_INT 48
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: LD_INT 34
72615: PUSH
72616: LD_INT 8
72618: PUSH
72619: EMPTY
72620: LIST
72621: LIST
72622: PUSH
72623: EMPTY
72624: LIST
72625: LIST
72626: LIST
72627: LIST
72628: LIST
72629: LIST
72630: LIST
72631: LIST
72632: LIST
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: PPUSH
72639: CALL_OW 72
72643: DIFF
72644: ST_TO_ADDR
// end ; end_of_file
72645: LD_VAR 0 3
72649: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
72650: LD_INT 0
72652: PPUSH
72653: PPUSH
72654: PPUSH
// if not mc_bases or not skirmish then
72655: LD_EXP 23
72659: NOT
72660: PUSH
72661: LD_EXP 21
72665: NOT
72666: OR
72667: IFFALSE 72671
// exit ;
72669: GO 72836
// for i = 1 to mc_bases do
72671: LD_ADDR_VAR 0 4
72675: PUSH
72676: DOUBLE
72677: LD_INT 1
72679: DEC
72680: ST_TO_ADDR
72681: LD_EXP 23
72685: PUSH
72686: FOR_TO
72687: IFFALSE 72834
// begin if sci in mc_bases [ i ] then
72689: LD_VAR 0 2
72693: PUSH
72694: LD_EXP 23
72698: PUSH
72699: LD_VAR 0 4
72703: ARRAY
72704: IN
72705: IFFALSE 72832
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
72707: LD_ADDR_EXP 52
72711: PUSH
72712: LD_EXP 52
72716: PPUSH
72717: LD_VAR 0 4
72721: PUSH
72722: LD_EXP 52
72726: PUSH
72727: LD_VAR 0 4
72731: ARRAY
72732: PUSH
72733: LD_INT 1
72735: PLUS
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PPUSH
72741: LD_VAR 0 1
72745: PPUSH
72746: CALL 13619 0 3
72750: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
72751: LD_ADDR_VAR 0 5
72755: PUSH
72756: LD_EXP 23
72760: PUSH
72761: LD_VAR 0 4
72765: ARRAY
72766: PPUSH
72767: LD_INT 2
72769: PUSH
72770: LD_INT 30
72772: PUSH
72773: LD_INT 0
72775: PUSH
72776: EMPTY
72777: LIST
72778: LIST
72779: PUSH
72780: LD_INT 30
72782: PUSH
72783: LD_INT 1
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: LIST
72794: PPUSH
72795: CALL_OW 72
72799: PPUSH
72800: LD_VAR 0 1
72804: PPUSH
72805: CALL_OW 74
72809: ST_TO_ADDR
// if tmp then
72810: LD_VAR 0 5
72814: IFFALSE 72830
// ComStandNearbyBuilding ( ape , tmp ) ;
72816: LD_VAR 0 1
72820: PPUSH
72821: LD_VAR 0 5
72825: PPUSH
72826: CALL 10197 0 2
// break ;
72830: GO 72834
// end ; end ;
72832: GO 72686
72834: POP
72835: POP
// end ;
72836: LD_VAR 0 3
72840: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
72841: LD_INT 0
72843: PPUSH
72844: PPUSH
72845: PPUSH
// if not mc_bases or not skirmish then
72846: LD_EXP 23
72850: NOT
72851: PUSH
72852: LD_EXP 21
72856: NOT
72857: OR
72858: IFFALSE 72862
// exit ;
72860: GO 72951
// for i = 1 to mc_bases do
72862: LD_ADDR_VAR 0 4
72866: PUSH
72867: DOUBLE
72868: LD_INT 1
72870: DEC
72871: ST_TO_ADDR
72872: LD_EXP 23
72876: PUSH
72877: FOR_TO
72878: IFFALSE 72949
// begin if building in mc_busy_turret_list [ i ] then
72880: LD_VAR 0 1
72884: PUSH
72885: LD_EXP 33
72889: PUSH
72890: LD_VAR 0 4
72894: ARRAY
72895: IN
72896: IFFALSE 72947
// begin tmp := mc_busy_turret_list [ i ] diff building ;
72898: LD_ADDR_VAR 0 5
72902: PUSH
72903: LD_EXP 33
72907: PUSH
72908: LD_VAR 0 4
72912: ARRAY
72913: PUSH
72914: LD_VAR 0 1
72918: DIFF
72919: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
72920: LD_ADDR_EXP 33
72924: PUSH
72925: LD_EXP 33
72929: PPUSH
72930: LD_VAR 0 4
72934: PPUSH
72935: LD_VAR 0 5
72939: PPUSH
72940: CALL_OW 1
72944: ST_TO_ADDR
// break ;
72945: GO 72949
// end ; end ;
72947: GO 72877
72949: POP
72950: POP
// end ;
72951: LD_VAR 0 3
72955: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
72956: LD_INT 0
72958: PPUSH
72959: PPUSH
72960: PPUSH
// if not mc_bases or not skirmish then
72961: LD_EXP 23
72965: NOT
72966: PUSH
72967: LD_EXP 21
72971: NOT
72972: OR
72973: IFFALSE 72977
// exit ;
72975: GO 73176
// for i = 1 to mc_bases do
72977: LD_ADDR_VAR 0 5
72981: PUSH
72982: DOUBLE
72983: LD_INT 1
72985: DEC
72986: ST_TO_ADDR
72987: LD_EXP 23
72991: PUSH
72992: FOR_TO
72993: IFFALSE 73174
// if building in mc_bases [ i ] then
72995: LD_VAR 0 1
72999: PUSH
73000: LD_EXP 23
73004: PUSH
73005: LD_VAR 0 5
73009: ARRAY
73010: IN
73011: IFFALSE 73172
// begin tmp := mc_bases [ i ] diff building ;
73013: LD_ADDR_VAR 0 6
73017: PUSH
73018: LD_EXP 23
73022: PUSH
73023: LD_VAR 0 5
73027: ARRAY
73028: PUSH
73029: LD_VAR 0 1
73033: DIFF
73034: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
73035: LD_ADDR_EXP 23
73039: PUSH
73040: LD_EXP 23
73044: PPUSH
73045: LD_VAR 0 5
73049: PPUSH
73050: LD_VAR 0 6
73054: PPUSH
73055: CALL_OW 1
73059: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
73060: LD_VAR 0 1
73064: PUSH
73065: LD_EXP 31
73069: PUSH
73070: LD_VAR 0 5
73074: ARRAY
73075: IN
73076: IFFALSE 73115
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
73078: LD_ADDR_EXP 31
73082: PUSH
73083: LD_EXP 31
73087: PPUSH
73088: LD_VAR 0 5
73092: PPUSH
73093: LD_EXP 31
73097: PUSH
73098: LD_VAR 0 5
73102: ARRAY
73103: PUSH
73104: LD_VAR 0 1
73108: DIFF
73109: PPUSH
73110: CALL_OW 1
73114: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
73115: LD_VAR 0 1
73119: PUSH
73120: LD_EXP 32
73124: PUSH
73125: LD_VAR 0 5
73129: ARRAY
73130: IN
73131: IFFALSE 73170
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
73133: LD_ADDR_EXP 32
73137: PUSH
73138: LD_EXP 32
73142: PPUSH
73143: LD_VAR 0 5
73147: PPUSH
73148: LD_EXP 32
73152: PUSH
73153: LD_VAR 0 5
73157: ARRAY
73158: PUSH
73159: LD_VAR 0 1
73163: DIFF
73164: PPUSH
73165: CALL_OW 1
73169: ST_TO_ADDR
// break ;
73170: GO 73174
// end ;
73172: GO 72992
73174: POP
73175: POP
// end ;
73176: LD_VAR 0 4
73180: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
73181: LD_INT 0
73183: PPUSH
73184: PPUSH
73185: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
73186: LD_EXP 23
73190: NOT
73191: PUSH
73192: LD_EXP 21
73196: NOT
73197: OR
73198: PUSH
73199: LD_VAR 0 3
73203: PUSH
73204: LD_EXP 49
73208: IN
73209: NOT
73210: OR
73211: IFFALSE 73215
// exit ;
73213: GO 73338
// for i = 1 to mc_vehicles do
73215: LD_ADDR_VAR 0 6
73219: PUSH
73220: DOUBLE
73221: LD_INT 1
73223: DEC
73224: ST_TO_ADDR
73225: LD_EXP 42
73229: PUSH
73230: FOR_TO
73231: IFFALSE 73336
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
73233: LD_VAR 0 2
73237: PUSH
73238: LD_EXP 42
73242: PUSH
73243: LD_VAR 0 6
73247: ARRAY
73248: IN
73249: PUSH
73250: LD_VAR 0 1
73254: PUSH
73255: LD_EXP 42
73259: PUSH
73260: LD_VAR 0 6
73264: ARRAY
73265: IN
73266: OR
73267: IFFALSE 73334
// begin tmp := mc_vehicles [ i ] diff old ;
73269: LD_ADDR_VAR 0 7
73273: PUSH
73274: LD_EXP 42
73278: PUSH
73279: LD_VAR 0 6
73283: ARRAY
73284: PUSH
73285: LD_VAR 0 2
73289: DIFF
73290: ST_TO_ADDR
// tmp := tmp diff new ;
73291: LD_ADDR_VAR 0 7
73295: PUSH
73296: LD_VAR 0 7
73300: PUSH
73301: LD_VAR 0 1
73305: DIFF
73306: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73307: LD_ADDR_EXP 42
73311: PUSH
73312: LD_EXP 42
73316: PPUSH
73317: LD_VAR 0 6
73321: PPUSH
73322: LD_VAR 0 7
73326: PPUSH
73327: CALL_OW 1
73331: ST_TO_ADDR
// break ;
73332: GO 73336
// end ;
73334: GO 73230
73336: POP
73337: POP
// end ;
73338: LD_VAR 0 5
73342: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73343: LD_INT 0
73345: PPUSH
73346: PPUSH
73347: PPUSH
73348: PPUSH
// if not mc_bases or not skirmish then
73349: LD_EXP 23
73353: NOT
73354: PUSH
73355: LD_EXP 21
73359: NOT
73360: OR
73361: IFFALSE 73365
// exit ;
73363: GO 73748
// side := GetSide ( vehicle ) ;
73365: LD_ADDR_VAR 0 5
73369: PUSH
73370: LD_VAR 0 1
73374: PPUSH
73375: CALL_OW 255
73379: ST_TO_ADDR
// for i = 1 to mc_bases do
73380: LD_ADDR_VAR 0 4
73384: PUSH
73385: DOUBLE
73386: LD_INT 1
73388: DEC
73389: ST_TO_ADDR
73390: LD_EXP 23
73394: PUSH
73395: FOR_TO
73396: IFFALSE 73746
// begin if factory in mc_bases [ i ] then
73398: LD_VAR 0 2
73402: PUSH
73403: LD_EXP 23
73407: PUSH
73408: LD_VAR 0 4
73412: ARRAY
73413: IN
73414: IFFALSE 73744
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
73416: LD_EXP 45
73420: PUSH
73421: LD_VAR 0 4
73425: ARRAY
73426: PUSH
73427: LD_EXP 34
73431: PUSH
73432: LD_VAR 0 4
73436: ARRAY
73437: LESS
73438: PUSH
73439: LD_VAR 0 1
73443: PPUSH
73444: CALL_OW 264
73448: PUSH
73449: LD_INT 31
73451: PUSH
73452: LD_INT 32
73454: PUSH
73455: LD_INT 51
73457: PUSH
73458: LD_EXP 68
73462: PUSH
73463: LD_INT 12
73465: PUSH
73466: LD_INT 30
73468: PUSH
73469: LD_EXP 67
73473: PUSH
73474: LD_INT 11
73476: PUSH
73477: LD_INT 53
73479: PUSH
73480: LD_INT 14
73482: PUSH
73483: LD_EXP 71
73487: PUSH
73488: LD_INT 29
73490: PUSH
73491: LD_EXP 69
73495: PUSH
73496: LD_INT 13
73498: PUSH
73499: LD_INT 52
73501: PUSH
73502: LD_EXP 73
73506: PUSH
73507: LD_INT 48
73509: PUSH
73510: LD_INT 8
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: IN
73533: NOT
73534: AND
73535: IFFALSE 73583
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
73537: LD_ADDR_EXP 45
73541: PUSH
73542: LD_EXP 45
73546: PPUSH
73547: LD_VAR 0 4
73551: PUSH
73552: LD_EXP 45
73556: PUSH
73557: LD_VAR 0 4
73561: ARRAY
73562: PUSH
73563: LD_INT 1
73565: PLUS
73566: PUSH
73567: EMPTY
73568: LIST
73569: LIST
73570: PPUSH
73571: LD_VAR 0 1
73575: PPUSH
73576: CALL 13619 0 3
73580: ST_TO_ADDR
73581: GO 73627
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
73583: LD_ADDR_EXP 42
73587: PUSH
73588: LD_EXP 42
73592: PPUSH
73593: LD_VAR 0 4
73597: PUSH
73598: LD_EXP 42
73602: PUSH
73603: LD_VAR 0 4
73607: ARRAY
73608: PUSH
73609: LD_INT 1
73611: PLUS
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PPUSH
73617: LD_VAR 0 1
73621: PPUSH
73622: CALL 13619 0 3
73626: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
73627: LD_VAR 0 1
73631: PPUSH
73632: CALL_OW 263
73636: PUSH
73637: LD_INT 2
73639: EQUAL
73640: IFFALSE 73660
// begin repeat wait ( 0 0$1 ) ;
73642: LD_INT 35
73644: PPUSH
73645: CALL_OW 67
// until IsControledBy ( vehicle ) ;
73649: LD_VAR 0 1
73653: PPUSH
73654: CALL_OW 312
73658: IFFALSE 73642
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
73660: LD_VAR 0 1
73664: PPUSH
73665: LD_EXP 47
73669: PUSH
73670: LD_VAR 0 4
73674: ARRAY
73675: PPUSH
73676: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
73680: LD_VAR 0 1
73684: PPUSH
73685: CALL_OW 263
73689: PUSH
73690: LD_INT 1
73692: NONEQUAL
73693: IFFALSE 73697
// break ;
73695: GO 73746
// repeat wait ( 0 0$1 ) ;
73697: LD_INT 35
73699: PPUSH
73700: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
73704: LD_VAR 0 1
73708: PPUSH
73709: LD_EXP 47
73713: PUSH
73714: LD_VAR 0 4
73718: ARRAY
73719: PPUSH
73720: CALL_OW 308
73724: IFFALSE 73697
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
73726: LD_VAR 0 1
73730: PPUSH
73731: CALL_OW 311
73735: PPUSH
73736: CALL_OW 121
// exit ;
73740: POP
73741: POP
73742: GO 73748
// end ; end ;
73744: GO 73395
73746: POP
73747: POP
// end ;
73748: LD_VAR 0 3
73752: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
73753: LD_INT 0
73755: PPUSH
73756: PPUSH
73757: PPUSH
73758: PPUSH
// if not mc_bases or not skirmish then
73759: LD_EXP 23
73763: NOT
73764: PUSH
73765: LD_EXP 21
73769: NOT
73770: OR
73771: IFFALSE 73775
// exit ;
73773: GO 74128
// repeat wait ( 0 0$1 ) ;
73775: LD_INT 35
73777: PPUSH
73778: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
73782: LD_VAR 0 2
73786: PPUSH
73787: LD_VAR 0 3
73791: PPUSH
73792: CALL_OW 284
73796: IFFALSE 73775
// if GetResourceTypeXY ( x , y ) = mat_artefact then
73798: LD_VAR 0 2
73802: PPUSH
73803: LD_VAR 0 3
73807: PPUSH
73808: CALL_OW 283
73812: PUSH
73813: LD_INT 4
73815: EQUAL
73816: IFFALSE 73820
// exit ;
73818: GO 74128
// for i = 1 to mc_bases do
73820: LD_ADDR_VAR 0 7
73824: PUSH
73825: DOUBLE
73826: LD_INT 1
73828: DEC
73829: ST_TO_ADDR
73830: LD_EXP 23
73834: PUSH
73835: FOR_TO
73836: IFFALSE 74126
// begin if mc_crates_area [ i ] then
73838: LD_EXP 41
73842: PUSH
73843: LD_VAR 0 7
73847: ARRAY
73848: IFFALSE 73959
// for j in mc_crates_area [ i ] do
73850: LD_ADDR_VAR 0 8
73854: PUSH
73855: LD_EXP 41
73859: PUSH
73860: LD_VAR 0 7
73864: ARRAY
73865: PUSH
73866: FOR_IN
73867: IFFALSE 73957
// if InArea ( x , y , j ) then
73869: LD_VAR 0 2
73873: PPUSH
73874: LD_VAR 0 3
73878: PPUSH
73879: LD_VAR 0 8
73883: PPUSH
73884: CALL_OW 309
73888: IFFALSE 73955
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
73890: LD_ADDR_EXP 39
73894: PUSH
73895: LD_EXP 39
73899: PPUSH
73900: LD_VAR 0 7
73904: PUSH
73905: LD_EXP 39
73909: PUSH
73910: LD_VAR 0 7
73914: ARRAY
73915: PUSH
73916: LD_INT 1
73918: PLUS
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PPUSH
73924: LD_VAR 0 4
73928: PUSH
73929: LD_VAR 0 2
73933: PUSH
73934: LD_VAR 0 3
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: LIST
73943: PPUSH
73944: CALL 13619 0 3
73948: ST_TO_ADDR
// exit ;
73949: POP
73950: POP
73951: POP
73952: POP
73953: GO 74128
// end ;
73955: GO 73866
73957: POP
73958: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73959: LD_ADDR_VAR 0 9
73963: PUSH
73964: LD_EXP 23
73968: PUSH
73969: LD_VAR 0 7
73973: ARRAY
73974: PPUSH
73975: LD_INT 2
73977: PUSH
73978: LD_INT 30
73980: PUSH
73981: LD_INT 0
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 30
73990: PUSH
73991: LD_INT 1
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: EMPTY
73999: LIST
74000: LIST
74001: LIST
74002: PPUSH
74003: CALL_OW 72
74007: ST_TO_ADDR
// if not depot then
74008: LD_VAR 0 9
74012: NOT
74013: IFFALSE 74017
// continue ;
74015: GO 73835
// for j in depot do
74017: LD_ADDR_VAR 0 8
74021: PUSH
74022: LD_VAR 0 9
74026: PUSH
74027: FOR_IN
74028: IFFALSE 74122
// if GetDistUnitXY ( j , x , y ) < 30 then
74030: LD_VAR 0 8
74034: PPUSH
74035: LD_VAR 0 2
74039: PPUSH
74040: LD_VAR 0 3
74044: PPUSH
74045: CALL_OW 297
74049: PUSH
74050: LD_INT 30
74052: LESS
74053: IFFALSE 74120
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74055: LD_ADDR_EXP 39
74059: PUSH
74060: LD_EXP 39
74064: PPUSH
74065: LD_VAR 0 7
74069: PUSH
74070: LD_EXP 39
74074: PUSH
74075: LD_VAR 0 7
74079: ARRAY
74080: PUSH
74081: LD_INT 1
74083: PLUS
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PPUSH
74089: LD_VAR 0 4
74093: PUSH
74094: LD_VAR 0 2
74098: PUSH
74099: LD_VAR 0 3
74103: PUSH
74104: EMPTY
74105: LIST
74106: LIST
74107: LIST
74108: PPUSH
74109: CALL 13619 0 3
74113: ST_TO_ADDR
// exit ;
74114: POP
74115: POP
74116: POP
74117: POP
74118: GO 74128
// end ;
74120: GO 74027
74122: POP
74123: POP
// end ;
74124: GO 73835
74126: POP
74127: POP
// end ;
74128: LD_VAR 0 6
74132: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
74133: LD_INT 0
74135: PPUSH
74136: PPUSH
74137: PPUSH
74138: PPUSH
// if not mc_bases or not skirmish then
74139: LD_EXP 23
74143: NOT
74144: PUSH
74145: LD_EXP 21
74149: NOT
74150: OR
74151: IFFALSE 74155
// exit ;
74153: GO 74432
// side := GetSide ( lab ) ;
74155: LD_ADDR_VAR 0 4
74159: PUSH
74160: LD_VAR 0 2
74164: PPUSH
74165: CALL_OW 255
74169: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
74170: LD_VAR 0 4
74174: PUSH
74175: LD_EXP 49
74179: IN
74180: NOT
74181: PUSH
74182: LD_EXP 50
74186: NOT
74187: OR
74188: PUSH
74189: LD_EXP 23
74193: NOT
74194: OR
74195: IFFALSE 74199
// exit ;
74197: GO 74432
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
74199: LD_ADDR_EXP 50
74203: PUSH
74204: LD_EXP 50
74208: PPUSH
74209: LD_VAR 0 4
74213: PPUSH
74214: LD_EXP 50
74218: PUSH
74219: LD_VAR 0 4
74223: ARRAY
74224: PUSH
74225: LD_VAR 0 1
74229: DIFF
74230: PPUSH
74231: CALL_OW 1
74235: ST_TO_ADDR
// for i = 1 to mc_bases do
74236: LD_ADDR_VAR 0 5
74240: PUSH
74241: DOUBLE
74242: LD_INT 1
74244: DEC
74245: ST_TO_ADDR
74246: LD_EXP 23
74250: PUSH
74251: FOR_TO
74252: IFFALSE 74430
// begin if lab in mc_bases [ i ] then
74254: LD_VAR 0 2
74258: PUSH
74259: LD_EXP 23
74263: PUSH
74264: LD_VAR 0 5
74268: ARRAY
74269: IN
74270: IFFALSE 74428
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74272: LD_VAR 0 1
74276: PUSH
74277: LD_INT 11
74279: PUSH
74280: LD_INT 4
74282: PUSH
74283: LD_INT 3
74285: PUSH
74286: LD_INT 2
74288: PUSH
74289: EMPTY
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: IN
74295: PUSH
74296: LD_EXP 53
74300: PUSH
74301: LD_VAR 0 5
74305: ARRAY
74306: AND
74307: IFFALSE 74428
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74309: LD_ADDR_VAR 0 6
74313: PUSH
74314: LD_EXP 53
74318: PUSH
74319: LD_VAR 0 5
74323: ARRAY
74324: PUSH
74325: LD_INT 1
74327: ARRAY
74328: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74329: LD_ADDR_EXP 53
74333: PUSH
74334: LD_EXP 53
74338: PPUSH
74339: LD_VAR 0 5
74343: PPUSH
74344: EMPTY
74345: PPUSH
74346: CALL_OW 1
74350: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74351: LD_VAR 0 6
74355: PPUSH
74356: LD_INT 0
74358: PPUSH
74359: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74363: LD_VAR 0 6
74367: PPUSH
74368: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74372: LD_ADDR_EXP 52
74376: PUSH
74377: LD_EXP 52
74381: PPUSH
74382: LD_VAR 0 5
74386: PPUSH
74387: LD_EXP 52
74391: PUSH
74392: LD_VAR 0 5
74396: ARRAY
74397: PPUSH
74398: LD_INT 1
74400: PPUSH
74401: LD_VAR 0 6
74405: PPUSH
74406: CALL_OW 2
74410: PPUSH
74411: CALL_OW 1
74415: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
74416: LD_VAR 0 5
74420: PPUSH
74421: LD_INT 112
74423: PPUSH
74424: CALL 51261 0 2
// end ; end ; end ;
74428: GO 74251
74430: POP
74431: POP
// end ;
74432: LD_VAR 0 3
74436: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
74437: LD_INT 0
74439: PPUSH
74440: PPUSH
74441: PPUSH
74442: PPUSH
74443: PPUSH
74444: PPUSH
74445: PPUSH
74446: PPUSH
// if not mc_bases or not skirmish then
74447: LD_EXP 23
74451: NOT
74452: PUSH
74453: LD_EXP 21
74457: NOT
74458: OR
74459: IFFALSE 74463
// exit ;
74461: GO 75834
// for i = 1 to mc_bases do
74463: LD_ADDR_VAR 0 3
74467: PUSH
74468: DOUBLE
74469: LD_INT 1
74471: DEC
74472: ST_TO_ADDR
74473: LD_EXP 23
74477: PUSH
74478: FOR_TO
74479: IFFALSE 75832
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
74481: LD_VAR 0 1
74485: PUSH
74486: LD_EXP 23
74490: PUSH
74491: LD_VAR 0 3
74495: ARRAY
74496: IN
74497: PUSH
74498: LD_VAR 0 1
74502: PUSH
74503: LD_EXP 30
74507: PUSH
74508: LD_VAR 0 3
74512: ARRAY
74513: IN
74514: OR
74515: PUSH
74516: LD_VAR 0 1
74520: PUSH
74521: LD_EXP 45
74525: PUSH
74526: LD_VAR 0 3
74530: ARRAY
74531: IN
74532: OR
74533: PUSH
74534: LD_VAR 0 1
74538: PUSH
74539: LD_EXP 42
74543: PUSH
74544: LD_VAR 0 3
74548: ARRAY
74549: IN
74550: OR
74551: PUSH
74552: LD_VAR 0 1
74556: PUSH
74557: LD_EXP 52
74561: PUSH
74562: LD_VAR 0 3
74566: ARRAY
74567: IN
74568: OR
74569: PUSH
74570: LD_VAR 0 1
74574: PUSH
74575: LD_EXP 53
74579: PUSH
74580: LD_VAR 0 3
74584: ARRAY
74585: IN
74586: OR
74587: IFFALSE 75830
// begin if un in mc_ape [ i ] then
74589: LD_VAR 0 1
74593: PUSH
74594: LD_EXP 52
74598: PUSH
74599: LD_VAR 0 3
74603: ARRAY
74604: IN
74605: IFFALSE 74644
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
74607: LD_ADDR_EXP 52
74611: PUSH
74612: LD_EXP 52
74616: PPUSH
74617: LD_VAR 0 3
74621: PPUSH
74622: LD_EXP 52
74626: PUSH
74627: LD_VAR 0 3
74631: ARRAY
74632: PUSH
74633: LD_VAR 0 1
74637: DIFF
74638: PPUSH
74639: CALL_OW 1
74643: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
74644: LD_VAR 0 1
74648: PUSH
74649: LD_EXP 53
74653: PUSH
74654: LD_VAR 0 3
74658: ARRAY
74659: IN
74660: IFFALSE 74684
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74662: LD_ADDR_EXP 53
74666: PUSH
74667: LD_EXP 53
74671: PPUSH
74672: LD_VAR 0 3
74676: PPUSH
74677: EMPTY
74678: PPUSH
74679: CALL_OW 1
74683: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
74684: LD_VAR 0 1
74688: PPUSH
74689: CALL_OW 247
74693: PUSH
74694: LD_INT 2
74696: EQUAL
74697: PUSH
74698: LD_VAR 0 1
74702: PPUSH
74703: CALL_OW 110
74707: PUSH
74708: LD_INT 20
74710: EQUAL
74711: PUSH
74712: LD_VAR 0 1
74716: PUSH
74717: LD_EXP 45
74721: PUSH
74722: LD_VAR 0 3
74726: ARRAY
74727: IN
74728: OR
74729: PUSH
74730: LD_VAR 0 1
74734: PPUSH
74735: CALL_OW 264
74739: PUSH
74740: LD_INT 12
74742: PUSH
74743: LD_INT 51
74745: PUSH
74746: LD_EXP 68
74750: PUSH
74751: LD_INT 32
74753: PUSH
74754: LD_INT 13
74756: PUSH
74757: LD_INT 52
74759: PUSH
74760: LD_INT 31
74762: PUSH
74763: EMPTY
74764: LIST
74765: LIST
74766: LIST
74767: LIST
74768: LIST
74769: LIST
74770: LIST
74771: IN
74772: OR
74773: AND
74774: IFFALSE 75082
// begin if un in mc_defender [ i ] then
74776: LD_VAR 0 1
74780: PUSH
74781: LD_EXP 45
74785: PUSH
74786: LD_VAR 0 3
74790: ARRAY
74791: IN
74792: IFFALSE 74831
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
74794: LD_ADDR_EXP 45
74798: PUSH
74799: LD_EXP 45
74803: PPUSH
74804: LD_VAR 0 3
74808: PPUSH
74809: LD_EXP 45
74813: PUSH
74814: LD_VAR 0 3
74818: ARRAY
74819: PUSH
74820: LD_VAR 0 1
74824: DIFF
74825: PPUSH
74826: CALL_OW 1
74830: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
74831: LD_ADDR_VAR 0 8
74835: PUSH
74836: LD_VAR 0 3
74840: PPUSH
74841: LD_INT 3
74843: PPUSH
74844: CALL 71481 0 2
74848: ST_TO_ADDR
// if fac then
74849: LD_VAR 0 8
74853: IFFALSE 75082
// begin for j in fac do
74855: LD_ADDR_VAR 0 4
74859: PUSH
74860: LD_VAR 0 8
74864: PUSH
74865: FOR_IN
74866: IFFALSE 75080
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
74868: LD_ADDR_VAR 0 9
74872: PUSH
74873: LD_VAR 0 8
74877: PPUSH
74878: LD_VAR 0 1
74882: PPUSH
74883: CALL_OW 265
74887: PPUSH
74888: LD_VAR 0 1
74892: PPUSH
74893: CALL_OW 262
74897: PPUSH
74898: LD_VAR 0 1
74902: PPUSH
74903: CALL_OW 263
74907: PPUSH
74908: LD_VAR 0 1
74912: PPUSH
74913: CALL_OW 264
74917: PPUSH
74918: CALL 11115 0 5
74922: ST_TO_ADDR
// if components then
74923: LD_VAR 0 9
74927: IFFALSE 75078
// begin if GetWeapon ( un ) = ar_control_tower then
74929: LD_VAR 0 1
74933: PPUSH
74934: CALL_OW 264
74938: PUSH
74939: LD_INT 31
74941: EQUAL
74942: IFFALSE 75059
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
74944: LD_VAR 0 1
74948: PPUSH
74949: CALL_OW 311
74953: PPUSH
74954: LD_INT 0
74956: PPUSH
74957: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
74961: LD_ADDR_EXP 63
74965: PUSH
74966: LD_EXP 63
74970: PPUSH
74971: LD_VAR 0 3
74975: PPUSH
74976: LD_EXP 63
74980: PUSH
74981: LD_VAR 0 3
74985: ARRAY
74986: PUSH
74987: LD_VAR 0 1
74991: PPUSH
74992: CALL_OW 311
74996: DIFF
74997: PPUSH
74998: CALL_OW 1
75002: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
75003: LD_ADDR_VAR 0 7
75007: PUSH
75008: LD_EXP 44
75012: PUSH
75013: LD_VAR 0 3
75017: ARRAY
75018: PPUSH
75019: LD_INT 1
75021: PPUSH
75022: LD_VAR 0 9
75026: PPUSH
75027: CALL_OW 2
75031: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75032: LD_ADDR_EXP 44
75036: PUSH
75037: LD_EXP 44
75041: PPUSH
75042: LD_VAR 0 3
75046: PPUSH
75047: LD_VAR 0 7
75051: PPUSH
75052: CALL_OW 1
75056: ST_TO_ADDR
// end else
75057: GO 75076
// MC_InsertProduceList ( i , [ components ] ) ;
75059: LD_VAR 0 3
75063: PPUSH
75064: LD_VAR 0 9
75068: PUSH
75069: EMPTY
75070: LIST
75071: PPUSH
75072: CALL 71026 0 2
// break ;
75076: GO 75080
// end ; end ;
75078: GO 74865
75080: POP
75081: POP
// end ; end ; if GetType ( un ) = unit_building then
75082: LD_VAR 0 1
75086: PPUSH
75087: CALL_OW 247
75091: PUSH
75092: LD_INT 3
75094: EQUAL
75095: IFFALSE 75498
// begin btype := GetBType ( un ) ;
75097: LD_ADDR_VAR 0 5
75101: PUSH
75102: LD_VAR 0 1
75106: PPUSH
75107: CALL_OW 266
75111: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
75112: LD_VAR 0 5
75116: PUSH
75117: LD_INT 29
75119: PUSH
75120: LD_INT 30
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: IN
75127: IFFALSE 75200
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
75129: LD_VAR 0 1
75133: PPUSH
75134: CALL_OW 250
75138: PPUSH
75139: LD_VAR 0 1
75143: PPUSH
75144: CALL_OW 251
75148: PPUSH
75149: LD_VAR 0 1
75153: PPUSH
75154: CALL_OW 255
75158: PPUSH
75159: CALL_OW 440
75163: NOT
75164: IFFALSE 75200
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
75166: LD_VAR 0 1
75170: PPUSH
75171: CALL_OW 250
75175: PPUSH
75176: LD_VAR 0 1
75180: PPUSH
75181: CALL_OW 251
75185: PPUSH
75186: LD_VAR 0 1
75190: PPUSH
75191: CALL_OW 255
75195: PPUSH
75196: CALL_OW 441
// end ; if btype = b_warehouse then
75200: LD_VAR 0 5
75204: PUSH
75205: LD_INT 1
75207: EQUAL
75208: IFFALSE 75226
// begin btype := b_depot ;
75210: LD_ADDR_VAR 0 5
75214: PUSH
75215: LD_INT 0
75217: ST_TO_ADDR
// pos := 1 ;
75218: LD_ADDR_VAR 0 6
75222: PUSH
75223: LD_INT 1
75225: ST_TO_ADDR
// end ; if btype = b_factory then
75226: LD_VAR 0 5
75230: PUSH
75231: LD_INT 3
75233: EQUAL
75234: IFFALSE 75252
// begin btype := b_workshop ;
75236: LD_ADDR_VAR 0 5
75240: PUSH
75241: LD_INT 2
75243: ST_TO_ADDR
// pos := 1 ;
75244: LD_ADDR_VAR 0 6
75248: PUSH
75249: LD_INT 1
75251: ST_TO_ADDR
// end ; if btype = b_barracks then
75252: LD_VAR 0 5
75256: PUSH
75257: LD_INT 5
75259: EQUAL
75260: IFFALSE 75270
// btype := b_armoury ;
75262: LD_ADDR_VAR 0 5
75266: PUSH
75267: LD_INT 4
75269: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75270: LD_VAR 0 5
75274: PUSH
75275: LD_INT 7
75277: PUSH
75278: LD_INT 8
75280: PUSH
75281: EMPTY
75282: LIST
75283: LIST
75284: IN
75285: IFFALSE 75295
// btype := b_lab ;
75287: LD_ADDR_VAR 0 5
75291: PUSH
75292: LD_INT 6
75294: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75295: LD_ADDR_EXP 28
75299: PUSH
75300: LD_EXP 28
75304: PPUSH
75305: LD_VAR 0 3
75309: PUSH
75310: LD_EXP 28
75314: PUSH
75315: LD_VAR 0 3
75319: ARRAY
75320: PUSH
75321: LD_INT 1
75323: PLUS
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PPUSH
75329: LD_VAR 0 5
75333: PUSH
75334: LD_VAR 0 1
75338: PPUSH
75339: CALL_OW 250
75343: PUSH
75344: LD_VAR 0 1
75348: PPUSH
75349: CALL_OW 251
75353: PUSH
75354: LD_VAR 0 1
75358: PPUSH
75359: CALL_OW 254
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: LIST
75368: LIST
75369: PPUSH
75370: CALL 13619 0 3
75374: ST_TO_ADDR
// if pos = 1 then
75375: LD_VAR 0 6
75379: PUSH
75380: LD_INT 1
75382: EQUAL
75383: IFFALSE 75498
// begin tmp := mc_build_list [ i ] ;
75385: LD_ADDR_VAR 0 7
75389: PUSH
75390: LD_EXP 28
75394: PUSH
75395: LD_VAR 0 3
75399: ARRAY
75400: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75401: LD_VAR 0 7
75405: PPUSH
75406: LD_INT 2
75408: PUSH
75409: LD_INT 30
75411: PUSH
75412: LD_INT 0
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PUSH
75419: LD_INT 30
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: LIST
75433: PPUSH
75434: CALL_OW 72
75438: IFFALSE 75448
// pos := 2 ;
75440: LD_ADDR_VAR 0 6
75444: PUSH
75445: LD_INT 2
75447: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
75448: LD_ADDR_VAR 0 7
75452: PUSH
75453: LD_VAR 0 7
75457: PPUSH
75458: LD_VAR 0 6
75462: PPUSH
75463: LD_VAR 0 7
75467: PPUSH
75468: CALL 13945 0 3
75472: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
75473: LD_ADDR_EXP 28
75477: PUSH
75478: LD_EXP 28
75482: PPUSH
75483: LD_VAR 0 3
75487: PPUSH
75488: LD_VAR 0 7
75492: PPUSH
75493: CALL_OW 1
75497: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
75498: LD_VAR 0 1
75502: PUSH
75503: LD_EXP 23
75507: PUSH
75508: LD_VAR 0 3
75512: ARRAY
75513: IN
75514: IFFALSE 75553
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
75516: LD_ADDR_EXP 23
75520: PUSH
75521: LD_EXP 23
75525: PPUSH
75526: LD_VAR 0 3
75530: PPUSH
75531: LD_EXP 23
75535: PUSH
75536: LD_VAR 0 3
75540: ARRAY
75541: PUSH
75542: LD_VAR 0 1
75546: DIFF
75547: PPUSH
75548: CALL_OW 1
75552: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
75553: LD_VAR 0 1
75557: PUSH
75558: LD_EXP 30
75562: PUSH
75563: LD_VAR 0 3
75567: ARRAY
75568: IN
75569: IFFALSE 75608
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
75571: LD_ADDR_EXP 30
75575: PUSH
75576: LD_EXP 30
75580: PPUSH
75581: LD_VAR 0 3
75585: PPUSH
75586: LD_EXP 30
75590: PUSH
75591: LD_VAR 0 3
75595: ARRAY
75596: PUSH
75597: LD_VAR 0 1
75601: DIFF
75602: PPUSH
75603: CALL_OW 1
75607: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
75608: LD_VAR 0 1
75612: PUSH
75613: LD_EXP 42
75617: PUSH
75618: LD_VAR 0 3
75622: ARRAY
75623: IN
75624: IFFALSE 75663
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
75626: LD_ADDR_EXP 42
75630: PUSH
75631: LD_EXP 42
75635: PPUSH
75636: LD_VAR 0 3
75640: PPUSH
75641: LD_EXP 42
75645: PUSH
75646: LD_VAR 0 3
75650: ARRAY
75651: PUSH
75652: LD_VAR 0 1
75656: DIFF
75657: PPUSH
75658: CALL_OW 1
75662: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
75663: LD_VAR 0 1
75667: PUSH
75668: LD_EXP 45
75672: PUSH
75673: LD_VAR 0 3
75677: ARRAY
75678: IN
75679: IFFALSE 75718
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75681: LD_ADDR_EXP 45
75685: PUSH
75686: LD_EXP 45
75690: PPUSH
75691: LD_VAR 0 3
75695: PPUSH
75696: LD_EXP 45
75700: PUSH
75701: LD_VAR 0 3
75705: ARRAY
75706: PUSH
75707: LD_VAR 0 1
75711: DIFF
75712: PPUSH
75713: CALL_OW 1
75717: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
75718: LD_VAR 0 1
75722: PUSH
75723: LD_EXP 32
75727: PUSH
75728: LD_VAR 0 3
75732: ARRAY
75733: IN
75734: IFFALSE 75773
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
75736: LD_ADDR_EXP 32
75740: PUSH
75741: LD_EXP 32
75745: PPUSH
75746: LD_VAR 0 3
75750: PPUSH
75751: LD_EXP 32
75755: PUSH
75756: LD_VAR 0 3
75760: ARRAY
75761: PUSH
75762: LD_VAR 0 1
75766: DIFF
75767: PPUSH
75768: CALL_OW 1
75772: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
75773: LD_VAR 0 1
75777: PUSH
75778: LD_EXP 31
75782: PUSH
75783: LD_VAR 0 3
75787: ARRAY
75788: IN
75789: IFFALSE 75828
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
75791: LD_ADDR_EXP 31
75795: PUSH
75796: LD_EXP 31
75800: PPUSH
75801: LD_VAR 0 3
75805: PPUSH
75806: LD_EXP 31
75810: PUSH
75811: LD_VAR 0 3
75815: ARRAY
75816: PUSH
75817: LD_VAR 0 1
75821: DIFF
75822: PPUSH
75823: CALL_OW 1
75827: ST_TO_ADDR
// end ; break ;
75828: GO 75832
// end ;
75830: GO 74478
75832: POP
75833: POP
// end ;
75834: LD_VAR 0 2
75838: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
75839: LD_INT 0
75841: PPUSH
75842: PPUSH
75843: PPUSH
// if not mc_bases or not skirmish then
75844: LD_EXP 23
75848: NOT
75849: PUSH
75850: LD_EXP 21
75854: NOT
75855: OR
75856: IFFALSE 75860
// exit ;
75858: GO 76075
// for i = 1 to mc_bases do
75860: LD_ADDR_VAR 0 3
75864: PUSH
75865: DOUBLE
75866: LD_INT 1
75868: DEC
75869: ST_TO_ADDR
75870: LD_EXP 23
75874: PUSH
75875: FOR_TO
75876: IFFALSE 76073
// begin if building in mc_construct_list [ i ] then
75878: LD_VAR 0 1
75882: PUSH
75883: LD_EXP 30
75887: PUSH
75888: LD_VAR 0 3
75892: ARRAY
75893: IN
75894: IFFALSE 76071
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
75896: LD_ADDR_EXP 30
75900: PUSH
75901: LD_EXP 30
75905: PPUSH
75906: LD_VAR 0 3
75910: PPUSH
75911: LD_EXP 30
75915: PUSH
75916: LD_VAR 0 3
75920: ARRAY
75921: PUSH
75922: LD_VAR 0 1
75926: DIFF
75927: PPUSH
75928: CALL_OW 1
75932: ST_TO_ADDR
// if building in mc_lab [ i ] then
75933: LD_VAR 0 1
75937: PUSH
75938: LD_EXP 56
75942: PUSH
75943: LD_VAR 0 3
75947: ARRAY
75948: IN
75949: IFFALSE 76004
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
75951: LD_ADDR_EXP 57
75955: PUSH
75956: LD_EXP 57
75960: PPUSH
75961: LD_VAR 0 3
75965: PPUSH
75966: LD_EXP 57
75970: PUSH
75971: LD_VAR 0 3
75975: ARRAY
75976: PPUSH
75977: LD_INT 1
75979: PPUSH
75980: LD_EXP 57
75984: PUSH
75985: LD_VAR 0 3
75989: ARRAY
75990: PPUSH
75991: LD_INT 0
75993: PPUSH
75994: CALL 13037 0 4
75998: PPUSH
75999: CALL_OW 1
76003: ST_TO_ADDR
// if not building in mc_bases [ i ] then
76004: LD_VAR 0 1
76008: PUSH
76009: LD_EXP 23
76013: PUSH
76014: LD_VAR 0 3
76018: ARRAY
76019: IN
76020: NOT
76021: IFFALSE 76067
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76023: LD_ADDR_EXP 23
76027: PUSH
76028: LD_EXP 23
76032: PPUSH
76033: LD_VAR 0 3
76037: PUSH
76038: LD_EXP 23
76042: PUSH
76043: LD_VAR 0 3
76047: ARRAY
76048: PUSH
76049: LD_INT 1
76051: PLUS
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PPUSH
76057: LD_VAR 0 1
76061: PPUSH
76062: CALL 13619 0 3
76066: ST_TO_ADDR
// exit ;
76067: POP
76068: POP
76069: GO 76075
// end ; end ;
76071: GO 75875
76073: POP
76074: POP
// end ;
76075: LD_VAR 0 2
76079: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
76080: LD_INT 0
76082: PPUSH
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
76087: PPUSH
76088: PPUSH
// if not mc_bases or not skirmish then
76089: LD_EXP 23
76093: NOT
76094: PUSH
76095: LD_EXP 21
76099: NOT
76100: OR
76101: IFFALSE 76105
// exit ;
76103: GO 76766
// for i = 1 to mc_bases do
76105: LD_ADDR_VAR 0 3
76109: PUSH
76110: DOUBLE
76111: LD_INT 1
76113: DEC
76114: ST_TO_ADDR
76115: LD_EXP 23
76119: PUSH
76120: FOR_TO
76121: IFFALSE 76764
// begin if building in mc_construct_list [ i ] then
76123: LD_VAR 0 1
76127: PUSH
76128: LD_EXP 30
76132: PUSH
76133: LD_VAR 0 3
76137: ARRAY
76138: IN
76139: IFFALSE 76762
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76141: LD_ADDR_EXP 30
76145: PUSH
76146: LD_EXP 30
76150: PPUSH
76151: LD_VAR 0 3
76155: PPUSH
76156: LD_EXP 30
76160: PUSH
76161: LD_VAR 0 3
76165: ARRAY
76166: PUSH
76167: LD_VAR 0 1
76171: DIFF
76172: PPUSH
76173: CALL_OW 1
76177: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76178: LD_ADDR_EXP 23
76182: PUSH
76183: LD_EXP 23
76187: PPUSH
76188: LD_VAR 0 3
76192: PUSH
76193: LD_EXP 23
76197: PUSH
76198: LD_VAR 0 3
76202: ARRAY
76203: PUSH
76204: LD_INT 1
76206: PLUS
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: PPUSH
76212: LD_VAR 0 1
76216: PPUSH
76217: CALL 13619 0 3
76221: ST_TO_ADDR
// btype := GetBType ( building ) ;
76222: LD_ADDR_VAR 0 5
76226: PUSH
76227: LD_VAR 0 1
76231: PPUSH
76232: CALL_OW 266
76236: ST_TO_ADDR
// side := GetSide ( building ) ;
76237: LD_ADDR_VAR 0 8
76241: PUSH
76242: LD_VAR 0 1
76246: PPUSH
76247: CALL_OW 255
76251: ST_TO_ADDR
// if btype = b_lab then
76252: LD_VAR 0 5
76256: PUSH
76257: LD_INT 6
76259: EQUAL
76260: IFFALSE 76310
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76262: LD_ADDR_EXP 56
76266: PUSH
76267: LD_EXP 56
76271: PPUSH
76272: LD_VAR 0 3
76276: PUSH
76277: LD_EXP 56
76281: PUSH
76282: LD_VAR 0 3
76286: ARRAY
76287: PUSH
76288: LD_INT 1
76290: PLUS
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PPUSH
76296: LD_VAR 0 1
76300: PPUSH
76301: CALL 13619 0 3
76305: ST_TO_ADDR
// exit ;
76306: POP
76307: POP
76308: GO 76766
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76310: LD_VAR 0 5
76314: PUSH
76315: LD_INT 0
76317: PUSH
76318: LD_INT 2
76320: PUSH
76321: LD_INT 4
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: LIST
76328: IN
76329: IFFALSE 76453
// begin if btype = b_armoury then
76331: LD_VAR 0 5
76335: PUSH
76336: LD_INT 4
76338: EQUAL
76339: IFFALSE 76349
// btype := b_barracks ;
76341: LD_ADDR_VAR 0 5
76345: PUSH
76346: LD_INT 5
76348: ST_TO_ADDR
// if btype = b_depot then
76349: LD_VAR 0 5
76353: PUSH
76354: LD_INT 0
76356: EQUAL
76357: IFFALSE 76367
// btype := b_warehouse ;
76359: LD_ADDR_VAR 0 5
76363: PUSH
76364: LD_INT 1
76366: ST_TO_ADDR
// if btype = b_workshop then
76367: LD_VAR 0 5
76371: PUSH
76372: LD_INT 2
76374: EQUAL
76375: IFFALSE 76385
// btype := b_factory ;
76377: LD_ADDR_VAR 0 5
76381: PUSH
76382: LD_INT 3
76384: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76385: LD_VAR 0 5
76389: PPUSH
76390: LD_VAR 0 8
76394: PPUSH
76395: CALL_OW 323
76399: PUSH
76400: LD_INT 1
76402: EQUAL
76403: IFFALSE 76449
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
76405: LD_ADDR_EXP 55
76409: PUSH
76410: LD_EXP 55
76414: PPUSH
76415: LD_VAR 0 3
76419: PUSH
76420: LD_EXP 55
76424: PUSH
76425: LD_VAR 0 3
76429: ARRAY
76430: PUSH
76431: LD_INT 1
76433: PLUS
76434: PUSH
76435: EMPTY
76436: LIST
76437: LIST
76438: PPUSH
76439: LD_VAR 0 1
76443: PPUSH
76444: CALL 13619 0 3
76448: ST_TO_ADDR
// exit ;
76449: POP
76450: POP
76451: GO 76766
// end ; if btype in [ b_bunker , b_turret ] then
76453: LD_VAR 0 5
76457: PUSH
76458: LD_INT 32
76460: PUSH
76461: LD_INT 33
76463: PUSH
76464: EMPTY
76465: LIST
76466: LIST
76467: IN
76468: IFFALSE 76758
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
76470: LD_ADDR_EXP 31
76474: PUSH
76475: LD_EXP 31
76479: PPUSH
76480: LD_VAR 0 3
76484: PUSH
76485: LD_EXP 31
76489: PUSH
76490: LD_VAR 0 3
76494: ARRAY
76495: PUSH
76496: LD_INT 1
76498: PLUS
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PPUSH
76504: LD_VAR 0 1
76508: PPUSH
76509: CALL 13619 0 3
76513: ST_TO_ADDR
// if btype = b_bunker then
76514: LD_VAR 0 5
76518: PUSH
76519: LD_INT 32
76521: EQUAL
76522: IFFALSE 76758
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
76524: LD_ADDR_EXP 32
76528: PUSH
76529: LD_EXP 32
76533: PPUSH
76534: LD_VAR 0 3
76538: PUSH
76539: LD_EXP 32
76543: PUSH
76544: LD_VAR 0 3
76548: ARRAY
76549: PUSH
76550: LD_INT 1
76552: PLUS
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PPUSH
76558: LD_VAR 0 1
76562: PPUSH
76563: CALL 13619 0 3
76567: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
76568: LD_ADDR_VAR 0 6
76572: PUSH
76573: LD_EXP 23
76577: PUSH
76578: LD_VAR 0 3
76582: ARRAY
76583: PPUSH
76584: LD_INT 25
76586: PUSH
76587: LD_INT 1
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 3
76596: PUSH
76597: LD_INT 54
76599: PUSH
76600: EMPTY
76601: LIST
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: PUSH
76607: EMPTY
76608: LIST
76609: LIST
76610: PPUSH
76611: CALL_OW 72
76615: ST_TO_ADDR
// if tmp then
76616: LD_VAR 0 6
76620: IFFALSE 76626
// exit ;
76622: POP
76623: POP
76624: GO 76766
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76626: LD_ADDR_VAR 0 6
76630: PUSH
76631: LD_EXP 23
76635: PUSH
76636: LD_VAR 0 3
76640: ARRAY
76641: PPUSH
76642: LD_INT 2
76644: PUSH
76645: LD_INT 30
76647: PUSH
76648: LD_INT 4
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 30
76657: PUSH
76658: LD_INT 5
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: LIST
76669: PPUSH
76670: CALL_OW 72
76674: ST_TO_ADDR
// if not tmp then
76675: LD_VAR 0 6
76679: NOT
76680: IFFALSE 76686
// exit ;
76682: POP
76683: POP
76684: GO 76766
// for j in tmp do
76686: LD_ADDR_VAR 0 4
76690: PUSH
76691: LD_VAR 0 6
76695: PUSH
76696: FOR_IN
76697: IFFALSE 76756
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
76699: LD_ADDR_VAR 0 7
76703: PUSH
76704: LD_VAR 0 4
76708: PPUSH
76709: CALL_OW 313
76713: PPUSH
76714: LD_INT 25
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PPUSH
76724: CALL_OW 72
76728: ST_TO_ADDR
// if units then
76729: LD_VAR 0 7
76733: IFFALSE 76754
// begin ComExitBuilding ( units [ 1 ] ) ;
76735: LD_VAR 0 7
76739: PUSH
76740: LD_INT 1
76742: ARRAY
76743: PPUSH
76744: CALL_OW 122
// exit ;
76748: POP
76749: POP
76750: POP
76751: POP
76752: GO 76766
// end ; end ;
76754: GO 76696
76756: POP
76757: POP
// end ; end ; exit ;
76758: POP
76759: POP
76760: GO 76766
// end ; end ;
76762: GO 76120
76764: POP
76765: POP
// end ;
76766: LD_VAR 0 2
76770: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
76771: LD_INT 0
76773: PPUSH
76774: PPUSH
76775: PPUSH
76776: PPUSH
76777: PPUSH
76778: PPUSH
76779: PPUSH
// if not mc_bases or not skirmish then
76780: LD_EXP 23
76784: NOT
76785: PUSH
76786: LD_EXP 21
76790: NOT
76791: OR
76792: IFFALSE 76796
// exit ;
76794: GO 77061
// btype := GetBType ( building ) ;
76796: LD_ADDR_VAR 0 6
76800: PUSH
76801: LD_VAR 0 1
76805: PPUSH
76806: CALL_OW 266
76810: ST_TO_ADDR
// x := GetX ( building ) ;
76811: LD_ADDR_VAR 0 7
76815: PUSH
76816: LD_VAR 0 1
76820: PPUSH
76821: CALL_OW 250
76825: ST_TO_ADDR
// y := GetY ( building ) ;
76826: LD_ADDR_VAR 0 8
76830: PUSH
76831: LD_VAR 0 1
76835: PPUSH
76836: CALL_OW 251
76840: ST_TO_ADDR
// d := GetDir ( building ) ;
76841: LD_ADDR_VAR 0 9
76845: PUSH
76846: LD_VAR 0 1
76850: PPUSH
76851: CALL_OW 254
76855: ST_TO_ADDR
// for i = 1 to mc_bases do
76856: LD_ADDR_VAR 0 4
76860: PUSH
76861: DOUBLE
76862: LD_INT 1
76864: DEC
76865: ST_TO_ADDR
76866: LD_EXP 23
76870: PUSH
76871: FOR_TO
76872: IFFALSE 77059
// begin if not mc_build_list [ i ] then
76874: LD_EXP 28
76878: PUSH
76879: LD_VAR 0 4
76883: ARRAY
76884: NOT
76885: IFFALSE 76889
// continue ;
76887: GO 76871
// for j := 1 to mc_build_list [ i ] do
76889: LD_ADDR_VAR 0 5
76893: PUSH
76894: DOUBLE
76895: LD_INT 1
76897: DEC
76898: ST_TO_ADDR
76899: LD_EXP 28
76903: PUSH
76904: LD_VAR 0 4
76908: ARRAY
76909: PUSH
76910: FOR_TO
76911: IFFALSE 77055
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
76913: LD_VAR 0 6
76917: PUSH
76918: LD_VAR 0 7
76922: PUSH
76923: LD_VAR 0 8
76927: PUSH
76928: LD_VAR 0 9
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: LIST
76937: LIST
76938: PPUSH
76939: LD_EXP 28
76943: PUSH
76944: LD_VAR 0 4
76948: ARRAY
76949: PUSH
76950: LD_VAR 0 5
76954: ARRAY
76955: PPUSH
76956: CALL 19802 0 2
76960: IFFALSE 77053
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
76962: LD_ADDR_EXP 28
76966: PUSH
76967: LD_EXP 28
76971: PPUSH
76972: LD_VAR 0 4
76976: PPUSH
76977: LD_EXP 28
76981: PUSH
76982: LD_VAR 0 4
76986: ARRAY
76987: PPUSH
76988: LD_VAR 0 5
76992: PPUSH
76993: CALL_OW 3
76997: PPUSH
76998: CALL_OW 1
77002: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
77003: LD_ADDR_EXP 30
77007: PUSH
77008: LD_EXP 30
77012: PPUSH
77013: LD_VAR 0 4
77017: PUSH
77018: LD_EXP 30
77022: PUSH
77023: LD_VAR 0 4
77027: ARRAY
77028: PUSH
77029: LD_INT 1
77031: PLUS
77032: PUSH
77033: EMPTY
77034: LIST
77035: LIST
77036: PPUSH
77037: LD_VAR 0 1
77041: PPUSH
77042: CALL 13619 0 3
77046: ST_TO_ADDR
// exit ;
77047: POP
77048: POP
77049: POP
77050: POP
77051: GO 77061
// end ;
77053: GO 76910
77055: POP
77056: POP
// end ;
77057: GO 76871
77059: POP
77060: POP
// end ;
77061: LD_VAR 0 3
77065: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
77066: LD_INT 0
77068: PPUSH
77069: PPUSH
77070: PPUSH
// if not mc_bases or not skirmish then
77071: LD_EXP 23
77075: NOT
77076: PUSH
77077: LD_EXP 21
77081: NOT
77082: OR
77083: IFFALSE 77087
// exit ;
77085: GO 77277
// for i = 1 to mc_bases do
77087: LD_ADDR_VAR 0 4
77091: PUSH
77092: DOUBLE
77093: LD_INT 1
77095: DEC
77096: ST_TO_ADDR
77097: LD_EXP 23
77101: PUSH
77102: FOR_TO
77103: IFFALSE 77190
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
77105: LD_VAR 0 1
77109: PUSH
77110: LD_EXP 31
77114: PUSH
77115: LD_VAR 0 4
77119: ARRAY
77120: IN
77121: PUSH
77122: LD_VAR 0 1
77126: PUSH
77127: LD_EXP 32
77131: PUSH
77132: LD_VAR 0 4
77136: ARRAY
77137: IN
77138: NOT
77139: AND
77140: IFFALSE 77188
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
77142: LD_ADDR_EXP 32
77146: PUSH
77147: LD_EXP 32
77151: PPUSH
77152: LD_VAR 0 4
77156: PUSH
77157: LD_EXP 32
77161: PUSH
77162: LD_VAR 0 4
77166: ARRAY
77167: PUSH
77168: LD_INT 1
77170: PLUS
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PPUSH
77176: LD_VAR 0 1
77180: PPUSH
77181: CALL 13619 0 3
77185: ST_TO_ADDR
// break ;
77186: GO 77190
// end ; end ;
77188: GO 77102
77190: POP
77191: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
77192: LD_VAR 0 1
77196: PPUSH
77197: CALL_OW 257
77201: PUSH
77202: LD_EXP 49
77206: IN
77207: PUSH
77208: LD_VAR 0 1
77212: PPUSH
77213: CALL_OW 266
77217: PUSH
77218: LD_INT 5
77220: EQUAL
77221: AND
77222: PUSH
77223: LD_VAR 0 2
77227: PPUSH
77228: CALL_OW 110
77232: PUSH
77233: LD_INT 18
77235: NONEQUAL
77236: AND
77237: IFFALSE 77277
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
77239: LD_VAR 0 2
77243: PPUSH
77244: CALL_OW 257
77248: PUSH
77249: LD_INT 5
77251: PUSH
77252: LD_INT 8
77254: PUSH
77255: LD_INT 9
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: LIST
77262: IN
77263: IFFALSE 77277
// SetClass ( unit , 1 ) ;
77265: LD_VAR 0 2
77269: PPUSH
77270: LD_INT 1
77272: PPUSH
77273: CALL_OW 336
// end ;
77277: LD_VAR 0 3
77281: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77282: LD_INT 0
77284: PPUSH
77285: PPUSH
// if not mc_bases or not skirmish then
77286: LD_EXP 23
77290: NOT
77291: PUSH
77292: LD_EXP 21
77296: NOT
77297: OR
77298: IFFALSE 77302
// exit ;
77300: GO 77418
// if GetLives ( abandoned_vehicle ) > 250 then
77302: LD_VAR 0 2
77306: PPUSH
77307: CALL_OW 256
77311: PUSH
77312: LD_INT 250
77314: GREATER
77315: IFFALSE 77319
// exit ;
77317: GO 77418
// for i = 1 to mc_bases do
77319: LD_ADDR_VAR 0 6
77323: PUSH
77324: DOUBLE
77325: LD_INT 1
77327: DEC
77328: ST_TO_ADDR
77329: LD_EXP 23
77333: PUSH
77334: FOR_TO
77335: IFFALSE 77416
// begin if driver in mc_bases [ i ] then
77337: LD_VAR 0 1
77341: PUSH
77342: LD_EXP 23
77346: PUSH
77347: LD_VAR 0 6
77351: ARRAY
77352: IN
77353: IFFALSE 77414
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77355: LD_VAR 0 1
77359: PPUSH
77360: LD_EXP 23
77364: PUSH
77365: LD_VAR 0 6
77369: ARRAY
77370: PPUSH
77371: LD_INT 2
77373: PUSH
77374: LD_INT 30
77376: PUSH
77377: LD_INT 0
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 30
77386: PUSH
77387: LD_INT 1
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: EMPTY
77395: LIST
77396: LIST
77397: LIST
77398: PPUSH
77399: CALL_OW 72
77403: PUSH
77404: LD_INT 1
77406: ARRAY
77407: PPUSH
77408: CALL 46238 0 2
// break ;
77412: GO 77416
// end ; end ;
77414: GO 77334
77416: POP
77417: POP
// end ; end_of_file
77418: LD_VAR 0 5
77422: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
77423: LD_INT 0
77425: PPUSH
// ar_miner := 81 ;
77426: LD_ADDR_EXP 74
77430: PUSH
77431: LD_INT 81
77433: ST_TO_ADDR
// ar_crane := 88 ;
77434: LD_ADDR_EXP 73
77438: PUSH
77439: LD_INT 88
77441: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
77442: LD_ADDR_EXP 68
77446: PUSH
77447: LD_INT 89
77449: ST_TO_ADDR
// us_hack := 99 ;
77450: LD_ADDR_EXP 69
77454: PUSH
77455: LD_INT 99
77457: ST_TO_ADDR
// us_artillery := 97 ;
77458: LD_ADDR_EXP 70
77462: PUSH
77463: LD_INT 97
77465: ST_TO_ADDR
// ar_bio_bomb := 91 ;
77466: LD_ADDR_EXP 71
77470: PUSH
77471: LD_INT 91
77473: ST_TO_ADDR
// ar_mortar := 92 ;
77474: LD_ADDR_EXP 72
77478: PUSH
77479: LD_INT 92
77481: ST_TO_ADDR
// ru_radar := 98 ;
77482: LD_ADDR_EXP 67
77486: PUSH
77487: LD_INT 98
77489: ST_TO_ADDR
// tech_Artillery := 80 ;
77490: LD_ADDR_EXP 75
77494: PUSH
77495: LD_INT 80
77497: ST_TO_ADDR
// tech_RadMat := 81 ;
77498: LD_ADDR_EXP 76
77502: PUSH
77503: LD_INT 81
77505: ST_TO_ADDR
// tech_BasicTools := 82 ;
77506: LD_ADDR_EXP 77
77510: PUSH
77511: LD_INT 82
77513: ST_TO_ADDR
// tech_Cargo := 83 ;
77514: LD_ADDR_EXP 78
77518: PUSH
77519: LD_INT 83
77521: ST_TO_ADDR
// tech_Track := 84 ;
77522: LD_ADDR_EXP 79
77526: PUSH
77527: LD_INT 84
77529: ST_TO_ADDR
// tech_Crane := 85 ;
77530: LD_ADDR_EXP 80
77534: PUSH
77535: LD_INT 85
77537: ST_TO_ADDR
// tech_Bulldozer := 86 ;
77538: LD_ADDR_EXP 81
77542: PUSH
77543: LD_INT 86
77545: ST_TO_ADDR
// tech_Hovercraft := 87 ;
77546: LD_ADDR_EXP 82
77550: PUSH
77551: LD_INT 87
77553: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
77554: LD_ADDR_EXP 83
77558: PUSH
77559: LD_INT 88
77561: ST_TO_ADDR
// class_mastodont := 31 ;
77562: LD_ADDR_EXP 84
77566: PUSH
77567: LD_INT 31
77569: ST_TO_ADDR
// class_horse := 21 ;
77570: LD_ADDR_EXP 85
77574: PUSH
77575: LD_INT 21
77577: ST_TO_ADDR
// end ;
77578: LD_VAR 0 1
77582: RET
// every 1 do
77583: GO 77585
77585: DISABLE
// InitGlobalVariables ; end_of_file
77586: CALL 77423 0 0
77590: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
77591: LD_INT 0
77593: PPUSH
77594: PPUSH
77595: PPUSH
77596: PPUSH
77597: PPUSH
77598: PPUSH
77599: PPUSH
77600: PPUSH
77601: PPUSH
77602: PPUSH
77603: PPUSH
77604: PPUSH
77605: PPUSH
77606: PPUSH
77607: PPUSH
77608: PPUSH
77609: PPUSH
77610: PPUSH
77611: PPUSH
77612: PPUSH
77613: PPUSH
77614: PPUSH
77615: PPUSH
77616: PPUSH
77617: PPUSH
77618: PPUSH
77619: PPUSH
77620: PPUSH
77621: PPUSH
77622: PPUSH
77623: PPUSH
77624: PPUSH
77625: PPUSH
77626: PPUSH
// if not list then
77627: LD_VAR 0 1
77631: NOT
77632: IFFALSE 77636
// exit ;
77634: GO 82295
// base := list [ 1 ] ;
77636: LD_ADDR_VAR 0 3
77640: PUSH
77641: LD_VAR 0 1
77645: PUSH
77646: LD_INT 1
77648: ARRAY
77649: ST_TO_ADDR
// group := list [ 2 ] ;
77650: LD_ADDR_VAR 0 4
77654: PUSH
77655: LD_VAR 0 1
77659: PUSH
77660: LD_INT 2
77662: ARRAY
77663: ST_TO_ADDR
// path := list [ 3 ] ;
77664: LD_ADDR_VAR 0 5
77668: PUSH
77669: LD_VAR 0 1
77673: PUSH
77674: LD_INT 3
77676: ARRAY
77677: ST_TO_ADDR
// flags := list [ 4 ] ;
77678: LD_ADDR_VAR 0 6
77682: PUSH
77683: LD_VAR 0 1
77687: PUSH
77688: LD_INT 4
77690: ARRAY
77691: ST_TO_ADDR
// mined := [ ] ;
77692: LD_ADDR_VAR 0 27
77696: PUSH
77697: EMPTY
77698: ST_TO_ADDR
// bombed := [ ] ;
77699: LD_ADDR_VAR 0 28
77703: PUSH
77704: EMPTY
77705: ST_TO_ADDR
// healers := [ ] ;
77706: LD_ADDR_VAR 0 31
77710: PUSH
77711: EMPTY
77712: ST_TO_ADDR
// to_heal := [ ] ;
77713: LD_ADDR_VAR 0 30
77717: PUSH
77718: EMPTY
77719: ST_TO_ADDR
// repairs := [ ] ;
77720: LD_ADDR_VAR 0 33
77724: PUSH
77725: EMPTY
77726: ST_TO_ADDR
// to_repair := [ ] ;
77727: LD_ADDR_VAR 0 32
77731: PUSH
77732: EMPTY
77733: ST_TO_ADDR
// if not group or not path then
77734: LD_VAR 0 4
77738: NOT
77739: PUSH
77740: LD_VAR 0 5
77744: NOT
77745: OR
77746: IFFALSE 77750
// exit ;
77748: GO 82295
// side := GetSide ( group [ 1 ] ) ;
77750: LD_ADDR_VAR 0 35
77754: PUSH
77755: LD_VAR 0 4
77759: PUSH
77760: LD_INT 1
77762: ARRAY
77763: PPUSH
77764: CALL_OW 255
77768: ST_TO_ADDR
// if flags then
77769: LD_VAR 0 6
77773: IFFALSE 77917
// begin f_ignore_area := flags [ 1 ] ;
77775: LD_ADDR_VAR 0 17
77779: PUSH
77780: LD_VAR 0 6
77784: PUSH
77785: LD_INT 1
77787: ARRAY
77788: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
77789: LD_ADDR_VAR 0 18
77793: PUSH
77794: LD_VAR 0 6
77798: PUSH
77799: LD_INT 2
77801: ARRAY
77802: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
77803: LD_ADDR_VAR 0 19
77807: PUSH
77808: LD_VAR 0 6
77812: PUSH
77813: LD_INT 3
77815: ARRAY
77816: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
77817: LD_ADDR_VAR 0 20
77821: PUSH
77822: LD_VAR 0 6
77826: PUSH
77827: LD_INT 4
77829: ARRAY
77830: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
77831: LD_ADDR_VAR 0 21
77835: PUSH
77836: LD_VAR 0 6
77840: PUSH
77841: LD_INT 5
77843: ARRAY
77844: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
77845: LD_ADDR_VAR 0 22
77849: PUSH
77850: LD_VAR 0 6
77854: PUSH
77855: LD_INT 6
77857: ARRAY
77858: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
77859: LD_ADDR_VAR 0 23
77863: PUSH
77864: LD_VAR 0 6
77868: PUSH
77869: LD_INT 7
77871: ARRAY
77872: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
77873: LD_ADDR_VAR 0 24
77877: PUSH
77878: LD_VAR 0 6
77882: PUSH
77883: LD_INT 8
77885: ARRAY
77886: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
77887: LD_ADDR_VAR 0 25
77891: PUSH
77892: LD_VAR 0 6
77896: PUSH
77897: LD_INT 9
77899: ARRAY
77900: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
77901: LD_ADDR_VAR 0 26
77905: PUSH
77906: LD_VAR 0 6
77910: PUSH
77911: LD_INT 10
77913: ARRAY
77914: ST_TO_ADDR
// end else
77915: GO 77997
// begin f_ignore_area := false ;
77917: LD_ADDR_VAR 0 17
77921: PUSH
77922: LD_INT 0
77924: ST_TO_ADDR
// f_capture := false ;
77925: LD_ADDR_VAR 0 18
77929: PUSH
77930: LD_INT 0
77932: ST_TO_ADDR
// f_ignore_civ := false ;
77933: LD_ADDR_VAR 0 19
77937: PUSH
77938: LD_INT 0
77940: ST_TO_ADDR
// f_murder := false ;
77941: LD_ADDR_VAR 0 20
77945: PUSH
77946: LD_INT 0
77948: ST_TO_ADDR
// f_mines := false ;
77949: LD_ADDR_VAR 0 21
77953: PUSH
77954: LD_INT 0
77956: ST_TO_ADDR
// f_repair := false ;
77957: LD_ADDR_VAR 0 22
77961: PUSH
77962: LD_INT 0
77964: ST_TO_ADDR
// f_heal := false ;
77965: LD_ADDR_VAR 0 23
77969: PUSH
77970: LD_INT 0
77972: ST_TO_ADDR
// f_spacetime := false ;
77973: LD_ADDR_VAR 0 24
77977: PUSH
77978: LD_INT 0
77980: ST_TO_ADDR
// f_attack_depot := false ;
77981: LD_ADDR_VAR 0 25
77985: PUSH
77986: LD_INT 0
77988: ST_TO_ADDR
// f_crawl := false ;
77989: LD_ADDR_VAR 0 26
77993: PUSH
77994: LD_INT 0
77996: ST_TO_ADDR
// end ; if f_heal then
77997: LD_VAR 0 23
78001: IFFALSE 78028
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
78003: LD_ADDR_VAR 0 31
78007: PUSH
78008: LD_VAR 0 4
78012: PPUSH
78013: LD_INT 25
78015: PUSH
78016: LD_INT 4
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PPUSH
78023: CALL_OW 72
78027: ST_TO_ADDR
// if f_repair then
78028: LD_VAR 0 22
78032: IFFALSE 78059
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
78034: LD_ADDR_VAR 0 33
78038: PUSH
78039: LD_VAR 0 4
78043: PPUSH
78044: LD_INT 25
78046: PUSH
78047: LD_INT 3
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: PPUSH
78054: CALL_OW 72
78058: ST_TO_ADDR
// units_path := [ ] ;
78059: LD_ADDR_VAR 0 16
78063: PUSH
78064: EMPTY
78065: ST_TO_ADDR
// for i = 1 to group do
78066: LD_ADDR_VAR 0 7
78070: PUSH
78071: DOUBLE
78072: LD_INT 1
78074: DEC
78075: ST_TO_ADDR
78076: LD_VAR 0 4
78080: PUSH
78081: FOR_TO
78082: IFFALSE 78111
// units_path := Replace ( units_path , i , path ) ;
78084: LD_ADDR_VAR 0 16
78088: PUSH
78089: LD_VAR 0 16
78093: PPUSH
78094: LD_VAR 0 7
78098: PPUSH
78099: LD_VAR 0 5
78103: PPUSH
78104: CALL_OW 1
78108: ST_TO_ADDR
78109: GO 78081
78111: POP
78112: POP
// repeat for i = group downto 1 do
78113: LD_ADDR_VAR 0 7
78117: PUSH
78118: DOUBLE
78119: LD_VAR 0 4
78123: INC
78124: ST_TO_ADDR
78125: LD_INT 1
78127: PUSH
78128: FOR_DOWNTO
78129: IFFALSE 82251
// begin wait ( 5 ) ;
78131: LD_INT 5
78133: PPUSH
78134: CALL_OW 67
// tmp := [ ] ;
78138: LD_ADDR_VAR 0 14
78142: PUSH
78143: EMPTY
78144: ST_TO_ADDR
// attacking := false ;
78145: LD_ADDR_VAR 0 29
78149: PUSH
78150: LD_INT 0
78152: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78153: LD_VAR 0 4
78157: PUSH
78158: LD_VAR 0 7
78162: ARRAY
78163: PPUSH
78164: CALL_OW 301
78168: PUSH
78169: LD_VAR 0 4
78173: PUSH
78174: LD_VAR 0 7
78178: ARRAY
78179: NOT
78180: OR
78181: IFFALSE 78290
// begin if GetType ( group [ i ] ) = unit_human then
78183: LD_VAR 0 4
78187: PUSH
78188: LD_VAR 0 7
78192: ARRAY
78193: PPUSH
78194: CALL_OW 247
78198: PUSH
78199: LD_INT 1
78201: EQUAL
78202: IFFALSE 78248
// begin to_heal := to_heal diff group [ i ] ;
78204: LD_ADDR_VAR 0 30
78208: PUSH
78209: LD_VAR 0 30
78213: PUSH
78214: LD_VAR 0 4
78218: PUSH
78219: LD_VAR 0 7
78223: ARRAY
78224: DIFF
78225: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78226: LD_ADDR_VAR 0 31
78230: PUSH
78231: LD_VAR 0 31
78235: PUSH
78236: LD_VAR 0 4
78240: PUSH
78241: LD_VAR 0 7
78245: ARRAY
78246: DIFF
78247: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78248: LD_ADDR_VAR 0 4
78252: PUSH
78253: LD_VAR 0 4
78257: PPUSH
78258: LD_VAR 0 7
78262: PPUSH
78263: CALL_OW 3
78267: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78268: LD_ADDR_VAR 0 16
78272: PUSH
78273: LD_VAR 0 16
78277: PPUSH
78278: LD_VAR 0 7
78282: PPUSH
78283: CALL_OW 3
78287: ST_TO_ADDR
// continue ;
78288: GO 78128
// end ; if f_repair then
78290: LD_VAR 0 22
78294: IFFALSE 78783
// begin if GetType ( group [ i ] ) = unit_vehicle then
78296: LD_VAR 0 4
78300: PUSH
78301: LD_VAR 0 7
78305: ARRAY
78306: PPUSH
78307: CALL_OW 247
78311: PUSH
78312: LD_INT 2
78314: EQUAL
78315: IFFALSE 78505
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78317: LD_VAR 0 4
78321: PUSH
78322: LD_VAR 0 7
78326: ARRAY
78327: PPUSH
78328: CALL_OW 256
78332: PUSH
78333: LD_INT 700
78335: LESS
78336: PUSH
78337: LD_VAR 0 4
78341: PUSH
78342: LD_VAR 0 7
78346: ARRAY
78347: PUSH
78348: LD_VAR 0 32
78352: IN
78353: NOT
78354: AND
78355: IFFALSE 78379
// to_repair := to_repair union group [ i ] ;
78357: LD_ADDR_VAR 0 32
78361: PUSH
78362: LD_VAR 0 32
78366: PUSH
78367: LD_VAR 0 4
78371: PUSH
78372: LD_VAR 0 7
78376: ARRAY
78377: UNION
78378: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78379: LD_VAR 0 4
78383: PUSH
78384: LD_VAR 0 7
78388: ARRAY
78389: PPUSH
78390: CALL_OW 256
78394: PUSH
78395: LD_INT 1000
78397: EQUAL
78398: PUSH
78399: LD_VAR 0 4
78403: PUSH
78404: LD_VAR 0 7
78408: ARRAY
78409: PUSH
78410: LD_VAR 0 32
78414: IN
78415: AND
78416: IFFALSE 78440
// to_repair := to_repair diff group [ i ] ;
78418: LD_ADDR_VAR 0 32
78422: PUSH
78423: LD_VAR 0 32
78427: PUSH
78428: LD_VAR 0 4
78432: PUSH
78433: LD_VAR 0 7
78437: ARRAY
78438: DIFF
78439: ST_TO_ADDR
// if group [ i ] in to_repair then
78440: LD_VAR 0 4
78444: PUSH
78445: LD_VAR 0 7
78449: ARRAY
78450: PUSH
78451: LD_VAR 0 32
78455: IN
78456: IFFALSE 78503
// begin if not IsInArea ( group [ i ] , f_repair ) then
78458: LD_VAR 0 4
78462: PUSH
78463: LD_VAR 0 7
78467: ARRAY
78468: PPUSH
78469: LD_VAR 0 22
78473: PPUSH
78474: CALL_OW 308
78478: NOT
78479: IFFALSE 78501
// ComMoveToArea ( group [ i ] , f_repair ) ;
78481: LD_VAR 0 4
78485: PUSH
78486: LD_VAR 0 7
78490: ARRAY
78491: PPUSH
78492: LD_VAR 0 22
78496: PPUSH
78497: CALL_OW 113
// continue ;
78501: GO 78128
// end ; end else
78503: GO 78783
// if group [ i ] in repairs then
78505: LD_VAR 0 4
78509: PUSH
78510: LD_VAR 0 7
78514: ARRAY
78515: PUSH
78516: LD_VAR 0 33
78520: IN
78521: IFFALSE 78783
// begin if IsInUnit ( group [ i ] ) then
78523: LD_VAR 0 4
78527: PUSH
78528: LD_VAR 0 7
78532: ARRAY
78533: PPUSH
78534: CALL_OW 310
78538: IFFALSE 78606
// begin z := IsInUnit ( group [ i ] ) ;
78540: LD_ADDR_VAR 0 13
78544: PUSH
78545: LD_VAR 0 4
78549: PUSH
78550: LD_VAR 0 7
78554: ARRAY
78555: PPUSH
78556: CALL_OW 310
78560: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
78561: LD_VAR 0 13
78565: PUSH
78566: LD_VAR 0 32
78570: IN
78571: PUSH
78572: LD_VAR 0 13
78576: PPUSH
78577: LD_VAR 0 22
78581: PPUSH
78582: CALL_OW 308
78586: AND
78587: IFFALSE 78604
// ComExitVehicle ( group [ i ] ) ;
78589: LD_VAR 0 4
78593: PUSH
78594: LD_VAR 0 7
78598: ARRAY
78599: PPUSH
78600: CALL_OW 121
// end else
78604: GO 78783
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
78606: LD_ADDR_VAR 0 13
78610: PUSH
78611: LD_VAR 0 4
78615: PPUSH
78616: LD_INT 95
78618: PUSH
78619: LD_VAR 0 22
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 58
78630: PUSH
78631: EMPTY
78632: LIST
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PPUSH
78638: CALL_OW 72
78642: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
78643: LD_VAR 0 4
78647: PUSH
78648: LD_VAR 0 7
78652: ARRAY
78653: PPUSH
78654: CALL_OW 314
78658: NOT
78659: IFFALSE 78781
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
78661: LD_ADDR_VAR 0 10
78665: PUSH
78666: LD_VAR 0 13
78670: PPUSH
78671: LD_VAR 0 4
78675: PUSH
78676: LD_VAR 0 7
78680: ARRAY
78681: PPUSH
78682: CALL_OW 74
78686: ST_TO_ADDR
// if not x then
78687: LD_VAR 0 10
78691: NOT
78692: IFFALSE 78696
// continue ;
78694: GO 78128
// if GetLives ( x ) < 1000 then
78696: LD_VAR 0 10
78700: PPUSH
78701: CALL_OW 256
78705: PUSH
78706: LD_INT 1000
78708: LESS
78709: IFFALSE 78733
// ComRepairVehicle ( group [ i ] , x ) else
78711: LD_VAR 0 4
78715: PUSH
78716: LD_VAR 0 7
78720: ARRAY
78721: PPUSH
78722: LD_VAR 0 10
78726: PPUSH
78727: CALL_OW 129
78731: GO 78781
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
78733: LD_VAR 0 23
78737: PUSH
78738: LD_VAR 0 4
78742: PUSH
78743: LD_VAR 0 7
78747: ARRAY
78748: PPUSH
78749: CALL_OW 256
78753: PUSH
78754: LD_INT 1000
78756: LESS
78757: AND
78758: NOT
78759: IFFALSE 78781
// ComEnterUnit ( group [ i ] , x ) ;
78761: LD_VAR 0 4
78765: PUSH
78766: LD_VAR 0 7
78770: ARRAY
78771: PPUSH
78772: LD_VAR 0 10
78776: PPUSH
78777: CALL_OW 120
// end ; continue ;
78781: GO 78128
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
78783: LD_VAR 0 23
78787: PUSH
78788: LD_VAR 0 4
78792: PUSH
78793: LD_VAR 0 7
78797: ARRAY
78798: PPUSH
78799: CALL_OW 247
78803: PUSH
78804: LD_INT 1
78806: EQUAL
78807: AND
78808: IFFALSE 79286
// begin if group [ i ] in healers then
78810: LD_VAR 0 4
78814: PUSH
78815: LD_VAR 0 7
78819: ARRAY
78820: PUSH
78821: LD_VAR 0 31
78825: IN
78826: IFFALSE 79099
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
78828: LD_VAR 0 4
78832: PUSH
78833: LD_VAR 0 7
78837: ARRAY
78838: PPUSH
78839: LD_VAR 0 23
78843: PPUSH
78844: CALL_OW 308
78848: NOT
78849: PUSH
78850: LD_VAR 0 4
78854: PUSH
78855: LD_VAR 0 7
78859: ARRAY
78860: PPUSH
78861: CALL_OW 314
78865: NOT
78866: AND
78867: IFFALSE 78891
// ComMoveToArea ( group [ i ] , f_heal ) else
78869: LD_VAR 0 4
78873: PUSH
78874: LD_VAR 0 7
78878: ARRAY
78879: PPUSH
78880: LD_VAR 0 23
78884: PPUSH
78885: CALL_OW 113
78889: GO 79097
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
78891: LD_VAR 0 4
78895: PUSH
78896: LD_VAR 0 7
78900: ARRAY
78901: PPUSH
78902: CALL 42700 0 1
78906: PPUSH
78907: CALL_OW 256
78911: PUSH
78912: LD_INT 1000
78914: EQUAL
78915: IFFALSE 78934
// ComStop ( group [ i ] ) else
78917: LD_VAR 0 4
78921: PUSH
78922: LD_VAR 0 7
78926: ARRAY
78927: PPUSH
78928: CALL_OW 141
78932: GO 79097
// if not HasTask ( group [ i ] ) and to_heal then
78934: LD_VAR 0 4
78938: PUSH
78939: LD_VAR 0 7
78943: ARRAY
78944: PPUSH
78945: CALL_OW 314
78949: NOT
78950: PUSH
78951: LD_VAR 0 30
78955: AND
78956: IFFALSE 79097
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
78958: LD_ADDR_VAR 0 13
78962: PUSH
78963: LD_VAR 0 30
78967: PPUSH
78968: LD_INT 3
78970: PUSH
78971: LD_INT 54
78973: PUSH
78974: EMPTY
78975: LIST
78976: PUSH
78977: EMPTY
78978: LIST
78979: LIST
78980: PPUSH
78981: CALL_OW 72
78985: PPUSH
78986: LD_VAR 0 4
78990: PUSH
78991: LD_VAR 0 7
78995: ARRAY
78996: PPUSH
78997: CALL_OW 74
79001: ST_TO_ADDR
// if z then
79002: LD_VAR 0 13
79006: IFFALSE 79097
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
79008: LD_INT 91
79010: PUSH
79011: LD_VAR 0 13
79015: PUSH
79016: LD_INT 10
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: LIST
79023: PUSH
79024: LD_INT 81
79026: PUSH
79027: LD_VAR 0 13
79031: PPUSH
79032: CALL_OW 255
79036: PUSH
79037: EMPTY
79038: LIST
79039: LIST
79040: PUSH
79041: EMPTY
79042: LIST
79043: LIST
79044: PPUSH
79045: CALL_OW 69
79049: PUSH
79050: LD_INT 0
79052: EQUAL
79053: IFFALSE 79077
// ComHeal ( group [ i ] , z ) else
79055: LD_VAR 0 4
79059: PUSH
79060: LD_VAR 0 7
79064: ARRAY
79065: PPUSH
79066: LD_VAR 0 13
79070: PPUSH
79071: CALL_OW 128
79075: GO 79097
// ComMoveToArea ( group [ i ] , f_heal ) ;
79077: LD_VAR 0 4
79081: PUSH
79082: LD_VAR 0 7
79086: ARRAY
79087: PPUSH
79088: LD_VAR 0 23
79092: PPUSH
79093: CALL_OW 113
// end ; continue ;
79097: GO 78128
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
79099: LD_VAR 0 4
79103: PUSH
79104: LD_VAR 0 7
79108: ARRAY
79109: PPUSH
79110: CALL_OW 256
79114: PUSH
79115: LD_INT 700
79117: LESS
79118: PUSH
79119: LD_VAR 0 4
79123: PUSH
79124: LD_VAR 0 7
79128: ARRAY
79129: PUSH
79130: LD_VAR 0 30
79134: IN
79135: NOT
79136: AND
79137: IFFALSE 79161
// to_heal := to_heal union group [ i ] ;
79139: LD_ADDR_VAR 0 30
79143: PUSH
79144: LD_VAR 0 30
79148: PUSH
79149: LD_VAR 0 4
79153: PUSH
79154: LD_VAR 0 7
79158: ARRAY
79159: UNION
79160: ST_TO_ADDR
// if group [ i ] in to_heal then
79161: LD_VAR 0 4
79165: PUSH
79166: LD_VAR 0 7
79170: ARRAY
79171: PUSH
79172: LD_VAR 0 30
79176: IN
79177: IFFALSE 79286
// begin if GetLives ( group [ i ] ) = 1000 then
79179: LD_VAR 0 4
79183: PUSH
79184: LD_VAR 0 7
79188: ARRAY
79189: PPUSH
79190: CALL_OW 256
79194: PUSH
79195: LD_INT 1000
79197: EQUAL
79198: IFFALSE 79224
// to_heal := to_heal diff group [ i ] else
79200: LD_ADDR_VAR 0 30
79204: PUSH
79205: LD_VAR 0 30
79209: PUSH
79210: LD_VAR 0 4
79214: PUSH
79215: LD_VAR 0 7
79219: ARRAY
79220: DIFF
79221: ST_TO_ADDR
79222: GO 79286
// begin if not IsInArea ( group [ i ] , to_heal ) then
79224: LD_VAR 0 4
79228: PUSH
79229: LD_VAR 0 7
79233: ARRAY
79234: PPUSH
79235: LD_VAR 0 30
79239: PPUSH
79240: CALL_OW 308
79244: NOT
79245: IFFALSE 79269
// ComMoveToArea ( group [ i ] , f_heal ) else
79247: LD_VAR 0 4
79251: PUSH
79252: LD_VAR 0 7
79256: ARRAY
79257: PPUSH
79258: LD_VAR 0 23
79262: PPUSH
79263: CALL_OW 113
79267: GO 79284
// ComHold ( group [ i ] ) ;
79269: LD_VAR 0 4
79273: PUSH
79274: LD_VAR 0 7
79278: ARRAY
79279: PPUSH
79280: CALL_OW 140
// continue ;
79284: GO 78128
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79286: LD_VAR 0 4
79290: PUSH
79291: LD_VAR 0 7
79295: ARRAY
79296: PPUSH
79297: LD_INT 10
79299: PPUSH
79300: CALL 41120 0 2
79304: NOT
79305: PUSH
79306: LD_VAR 0 16
79310: PUSH
79311: LD_VAR 0 7
79315: ARRAY
79316: PUSH
79317: EMPTY
79318: EQUAL
79319: NOT
79320: AND
79321: IFFALSE 79587
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79323: LD_VAR 0 4
79327: PUSH
79328: LD_VAR 0 7
79332: ARRAY
79333: PPUSH
79334: CALL_OW 262
79338: PUSH
79339: LD_INT 1
79341: PUSH
79342: LD_INT 2
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: IN
79349: IFFALSE 79390
// if GetFuel ( group [ i ] ) < 10 then
79351: LD_VAR 0 4
79355: PUSH
79356: LD_VAR 0 7
79360: ARRAY
79361: PPUSH
79362: CALL_OW 261
79366: PUSH
79367: LD_INT 10
79369: LESS
79370: IFFALSE 79390
// SetFuel ( group [ i ] , 12 ) ;
79372: LD_VAR 0 4
79376: PUSH
79377: LD_VAR 0 7
79381: ARRAY
79382: PPUSH
79383: LD_INT 12
79385: PPUSH
79386: CALL_OW 240
// if units_path [ i ] then
79390: LD_VAR 0 16
79394: PUSH
79395: LD_VAR 0 7
79399: ARRAY
79400: IFFALSE 79585
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
79402: LD_VAR 0 4
79406: PUSH
79407: LD_VAR 0 7
79411: ARRAY
79412: PPUSH
79413: LD_VAR 0 16
79417: PUSH
79418: LD_VAR 0 7
79422: ARRAY
79423: PUSH
79424: LD_INT 1
79426: ARRAY
79427: PUSH
79428: LD_INT 1
79430: ARRAY
79431: PPUSH
79432: LD_VAR 0 16
79436: PUSH
79437: LD_VAR 0 7
79441: ARRAY
79442: PUSH
79443: LD_INT 1
79445: ARRAY
79446: PUSH
79447: LD_INT 2
79449: ARRAY
79450: PPUSH
79451: CALL_OW 297
79455: PUSH
79456: LD_INT 6
79458: GREATER
79459: IFFALSE 79534
// begin if not HasTask ( group [ i ] ) then
79461: LD_VAR 0 4
79465: PUSH
79466: LD_VAR 0 7
79470: ARRAY
79471: PPUSH
79472: CALL_OW 314
79476: NOT
79477: IFFALSE 79532
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
79479: LD_VAR 0 4
79483: PUSH
79484: LD_VAR 0 7
79488: ARRAY
79489: PPUSH
79490: LD_VAR 0 16
79494: PUSH
79495: LD_VAR 0 7
79499: ARRAY
79500: PUSH
79501: LD_INT 1
79503: ARRAY
79504: PUSH
79505: LD_INT 1
79507: ARRAY
79508: PPUSH
79509: LD_VAR 0 16
79513: PUSH
79514: LD_VAR 0 7
79518: ARRAY
79519: PUSH
79520: LD_INT 1
79522: ARRAY
79523: PUSH
79524: LD_INT 2
79526: ARRAY
79527: PPUSH
79528: CALL_OW 114
// end else
79532: GO 79585
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
79534: LD_ADDR_VAR 0 15
79538: PUSH
79539: LD_VAR 0 16
79543: PUSH
79544: LD_VAR 0 7
79548: ARRAY
79549: PPUSH
79550: LD_INT 1
79552: PPUSH
79553: CALL_OW 3
79557: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
79558: LD_ADDR_VAR 0 16
79562: PUSH
79563: LD_VAR 0 16
79567: PPUSH
79568: LD_VAR 0 7
79572: PPUSH
79573: LD_VAR 0 15
79577: PPUSH
79578: CALL_OW 1
79582: ST_TO_ADDR
// continue ;
79583: GO 78128
// end ; end ; end else
79585: GO 82249
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
79587: LD_ADDR_VAR 0 14
79591: PUSH
79592: LD_INT 81
79594: PUSH
79595: LD_VAR 0 4
79599: PUSH
79600: LD_VAR 0 7
79604: ARRAY
79605: PPUSH
79606: CALL_OW 255
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: PPUSH
79615: CALL_OW 69
79619: ST_TO_ADDR
// if not tmp then
79620: LD_VAR 0 14
79624: NOT
79625: IFFALSE 79629
// continue ;
79627: GO 78128
// if f_ignore_area then
79629: LD_VAR 0 17
79633: IFFALSE 79721
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
79635: LD_ADDR_VAR 0 15
79639: PUSH
79640: LD_VAR 0 14
79644: PPUSH
79645: LD_INT 3
79647: PUSH
79648: LD_INT 92
79650: PUSH
79651: LD_VAR 0 17
79655: PUSH
79656: LD_INT 1
79658: ARRAY
79659: PUSH
79660: LD_VAR 0 17
79664: PUSH
79665: LD_INT 2
79667: ARRAY
79668: PUSH
79669: LD_VAR 0 17
79673: PUSH
79674: LD_INT 3
79676: ARRAY
79677: PUSH
79678: EMPTY
79679: LIST
79680: LIST
79681: LIST
79682: LIST
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PPUSH
79688: CALL_OW 72
79692: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79693: LD_VAR 0 14
79697: PUSH
79698: LD_VAR 0 15
79702: DIFF
79703: IFFALSE 79721
// tmp := tmp diff tmp2 ;
79705: LD_ADDR_VAR 0 14
79709: PUSH
79710: LD_VAR 0 14
79714: PUSH
79715: LD_VAR 0 15
79719: DIFF
79720: ST_TO_ADDR
// end ; if not f_murder then
79721: LD_VAR 0 20
79725: NOT
79726: IFFALSE 79784
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
79728: LD_ADDR_VAR 0 15
79732: PUSH
79733: LD_VAR 0 14
79737: PPUSH
79738: LD_INT 3
79740: PUSH
79741: LD_INT 50
79743: PUSH
79744: EMPTY
79745: LIST
79746: PUSH
79747: EMPTY
79748: LIST
79749: LIST
79750: PPUSH
79751: CALL_OW 72
79755: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
79756: LD_VAR 0 14
79760: PUSH
79761: LD_VAR 0 15
79765: DIFF
79766: IFFALSE 79784
// tmp := tmp diff tmp2 ;
79768: LD_ADDR_VAR 0 14
79772: PUSH
79773: LD_VAR 0 14
79777: PUSH
79778: LD_VAR 0 15
79782: DIFF
79783: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
79784: LD_ADDR_VAR 0 14
79788: PUSH
79789: LD_VAR 0 4
79793: PUSH
79794: LD_VAR 0 7
79798: ARRAY
79799: PPUSH
79800: LD_VAR 0 14
79804: PPUSH
79805: LD_INT 1
79807: PPUSH
79808: LD_INT 1
79810: PPUSH
79811: CALL 14054 0 4
79815: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
79816: LD_VAR 0 4
79820: PUSH
79821: LD_VAR 0 7
79825: ARRAY
79826: PPUSH
79827: CALL_OW 257
79831: PUSH
79832: LD_INT 1
79834: EQUAL
79835: IFFALSE 80283
// begin if WantPlant ( group [ i ] ) then
79837: LD_VAR 0 4
79841: PUSH
79842: LD_VAR 0 7
79846: ARRAY
79847: PPUSH
79848: CALL 13555 0 1
79852: IFFALSE 79856
// continue ;
79854: GO 78128
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
79856: LD_VAR 0 18
79860: PUSH
79861: LD_VAR 0 4
79865: PUSH
79866: LD_VAR 0 7
79870: ARRAY
79871: PPUSH
79872: CALL_OW 310
79876: NOT
79877: AND
79878: PUSH
79879: LD_VAR 0 14
79883: PUSH
79884: LD_INT 1
79886: ARRAY
79887: PUSH
79888: LD_VAR 0 14
79892: PPUSH
79893: LD_INT 21
79895: PUSH
79896: LD_INT 2
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 58
79905: PUSH
79906: EMPTY
79907: LIST
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PPUSH
79913: CALL_OW 72
79917: IN
79918: AND
79919: IFFALSE 79955
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
79921: LD_VAR 0 4
79925: PUSH
79926: LD_VAR 0 7
79930: ARRAY
79931: PPUSH
79932: LD_VAR 0 14
79936: PUSH
79937: LD_INT 1
79939: ARRAY
79940: PPUSH
79941: CALL_OW 120
// attacking := true ;
79945: LD_ADDR_VAR 0 29
79949: PUSH
79950: LD_INT 1
79952: ST_TO_ADDR
// continue ;
79953: GO 78128
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
79955: LD_VAR 0 26
79959: PUSH
79960: LD_VAR 0 4
79964: PUSH
79965: LD_VAR 0 7
79969: ARRAY
79970: PPUSH
79971: CALL_OW 257
79975: PUSH
79976: LD_INT 1
79978: EQUAL
79979: AND
79980: PUSH
79981: LD_VAR 0 4
79985: PUSH
79986: LD_VAR 0 7
79990: ARRAY
79991: PPUSH
79992: CALL_OW 256
79996: PUSH
79997: LD_INT 800
79999: LESS
80000: AND
80001: PUSH
80002: LD_VAR 0 4
80006: PUSH
80007: LD_VAR 0 7
80011: ARRAY
80012: PPUSH
80013: CALL_OW 318
80017: NOT
80018: AND
80019: IFFALSE 80036
// ComCrawl ( group [ i ] ) ;
80021: LD_VAR 0 4
80025: PUSH
80026: LD_VAR 0 7
80030: ARRAY
80031: PPUSH
80032: CALL_OW 137
// if f_mines then
80036: LD_VAR 0 21
80040: IFFALSE 80283
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
80042: LD_VAR 0 14
80046: PUSH
80047: LD_INT 1
80049: ARRAY
80050: PPUSH
80051: CALL_OW 247
80055: PUSH
80056: LD_INT 3
80058: EQUAL
80059: PUSH
80060: LD_VAR 0 14
80064: PUSH
80065: LD_INT 1
80067: ARRAY
80068: PUSH
80069: LD_VAR 0 27
80073: IN
80074: NOT
80075: AND
80076: IFFALSE 80283
// begin x := GetX ( tmp [ 1 ] ) ;
80078: LD_ADDR_VAR 0 10
80082: PUSH
80083: LD_VAR 0 14
80087: PUSH
80088: LD_INT 1
80090: ARRAY
80091: PPUSH
80092: CALL_OW 250
80096: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
80097: LD_ADDR_VAR 0 11
80101: PUSH
80102: LD_VAR 0 14
80106: PUSH
80107: LD_INT 1
80109: ARRAY
80110: PPUSH
80111: CALL_OW 251
80115: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
80116: LD_ADDR_VAR 0 12
80120: PUSH
80121: LD_VAR 0 4
80125: PUSH
80126: LD_VAR 0 7
80130: ARRAY
80131: PPUSH
80132: CALL 41205 0 1
80136: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80137: LD_VAR 0 4
80141: PUSH
80142: LD_VAR 0 7
80146: ARRAY
80147: PPUSH
80148: LD_VAR 0 10
80152: PPUSH
80153: LD_VAR 0 11
80157: PPUSH
80158: LD_VAR 0 14
80162: PUSH
80163: LD_INT 1
80165: ARRAY
80166: PPUSH
80167: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80171: LD_VAR 0 4
80175: PUSH
80176: LD_VAR 0 7
80180: ARRAY
80181: PPUSH
80182: LD_VAR 0 10
80186: PPUSH
80187: LD_VAR 0 12
80191: PPUSH
80192: LD_INT 7
80194: PPUSH
80195: CALL_OW 272
80199: PPUSH
80200: LD_VAR 0 11
80204: PPUSH
80205: LD_VAR 0 12
80209: PPUSH
80210: LD_INT 7
80212: PPUSH
80213: CALL_OW 273
80217: PPUSH
80218: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80222: LD_VAR 0 4
80226: PUSH
80227: LD_VAR 0 7
80231: ARRAY
80232: PPUSH
80233: LD_INT 71
80235: PPUSH
80236: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80240: LD_ADDR_VAR 0 27
80244: PUSH
80245: LD_VAR 0 27
80249: PPUSH
80250: LD_VAR 0 27
80254: PUSH
80255: LD_INT 1
80257: PLUS
80258: PPUSH
80259: LD_VAR 0 14
80263: PUSH
80264: LD_INT 1
80266: ARRAY
80267: PPUSH
80268: CALL_OW 1
80272: ST_TO_ADDR
// attacking := true ;
80273: LD_ADDR_VAR 0 29
80277: PUSH
80278: LD_INT 1
80280: ST_TO_ADDR
// continue ;
80281: GO 78128
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80283: LD_VAR 0 4
80287: PUSH
80288: LD_VAR 0 7
80292: ARRAY
80293: PPUSH
80294: CALL_OW 257
80298: PUSH
80299: LD_INT 17
80301: EQUAL
80302: PUSH
80303: LD_VAR 0 4
80307: PUSH
80308: LD_VAR 0 7
80312: ARRAY
80313: PPUSH
80314: CALL_OW 110
80318: PUSH
80319: LD_INT 71
80321: EQUAL
80322: NOT
80323: AND
80324: IFFALSE 80470
// begin attacking := false ;
80326: LD_ADDR_VAR 0 29
80330: PUSH
80331: LD_INT 0
80333: ST_TO_ADDR
// k := 5 ;
80334: LD_ADDR_VAR 0 9
80338: PUSH
80339: LD_INT 5
80341: ST_TO_ADDR
// if tmp < k then
80342: LD_VAR 0 14
80346: PUSH
80347: LD_VAR 0 9
80351: LESS
80352: IFFALSE 80364
// k := tmp ;
80354: LD_ADDR_VAR 0 9
80358: PUSH
80359: LD_VAR 0 14
80363: ST_TO_ADDR
// for j = 1 to k do
80364: LD_ADDR_VAR 0 8
80368: PUSH
80369: DOUBLE
80370: LD_INT 1
80372: DEC
80373: ST_TO_ADDR
80374: LD_VAR 0 9
80378: PUSH
80379: FOR_TO
80380: IFFALSE 80468
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80382: LD_VAR 0 14
80386: PUSH
80387: LD_VAR 0 8
80391: ARRAY
80392: PUSH
80393: LD_VAR 0 14
80397: PPUSH
80398: LD_INT 58
80400: PUSH
80401: EMPTY
80402: LIST
80403: PPUSH
80404: CALL_OW 72
80408: IN
80409: NOT
80410: IFFALSE 80466
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
80412: LD_VAR 0 4
80416: PUSH
80417: LD_VAR 0 7
80421: ARRAY
80422: PPUSH
80423: LD_VAR 0 14
80427: PUSH
80428: LD_VAR 0 8
80432: ARRAY
80433: PPUSH
80434: CALL_OW 115
// attacking := true ;
80438: LD_ADDR_VAR 0 29
80442: PUSH
80443: LD_INT 1
80445: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
80446: LD_VAR 0 4
80450: PUSH
80451: LD_VAR 0 7
80455: ARRAY
80456: PPUSH
80457: LD_INT 71
80459: PPUSH
80460: CALL_OW 109
// continue ;
80464: GO 80379
// end ; end ;
80466: GO 80379
80468: POP
80469: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
80470: LD_VAR 0 4
80474: PUSH
80475: LD_VAR 0 7
80479: ARRAY
80480: PPUSH
80481: CALL_OW 257
80485: PUSH
80486: LD_INT 8
80488: EQUAL
80489: PUSH
80490: LD_VAR 0 4
80494: PUSH
80495: LD_VAR 0 7
80499: ARRAY
80500: PPUSH
80501: CALL_OW 264
80505: PUSH
80506: LD_INT 28
80508: PUSH
80509: LD_INT 45
80511: PUSH
80512: LD_INT 7
80514: PUSH
80515: LD_INT 47
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: IN
80524: OR
80525: IFFALSE 80781
// begin attacking := false ;
80527: LD_ADDR_VAR 0 29
80531: PUSH
80532: LD_INT 0
80534: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
80535: LD_VAR 0 14
80539: PUSH
80540: LD_INT 1
80542: ARRAY
80543: PPUSH
80544: CALL_OW 266
80548: PUSH
80549: LD_INT 32
80551: PUSH
80552: LD_INT 31
80554: PUSH
80555: LD_INT 33
80557: PUSH
80558: LD_INT 4
80560: PUSH
80561: LD_INT 5
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: IN
80571: IFFALSE 80757
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
80573: LD_ADDR_VAR 0 9
80577: PUSH
80578: LD_VAR 0 14
80582: PUSH
80583: LD_INT 1
80585: ARRAY
80586: PPUSH
80587: CALL_OW 266
80591: PPUSH
80592: LD_VAR 0 14
80596: PUSH
80597: LD_INT 1
80599: ARRAY
80600: PPUSH
80601: CALL_OW 250
80605: PPUSH
80606: LD_VAR 0 14
80610: PUSH
80611: LD_INT 1
80613: ARRAY
80614: PPUSH
80615: CALL_OW 251
80619: PPUSH
80620: LD_VAR 0 14
80624: PUSH
80625: LD_INT 1
80627: ARRAY
80628: PPUSH
80629: CALL_OW 254
80633: PPUSH
80634: LD_VAR 0 14
80638: PUSH
80639: LD_INT 1
80641: ARRAY
80642: PPUSH
80643: CALL_OW 248
80647: PPUSH
80648: LD_INT 0
80650: PPUSH
80651: CALL 22575 0 6
80655: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
80656: LD_ADDR_VAR 0 8
80660: PUSH
80661: LD_VAR 0 4
80665: PUSH
80666: LD_VAR 0 7
80670: ARRAY
80671: PPUSH
80672: LD_VAR 0 9
80676: PPUSH
80677: CALL 41245 0 2
80681: ST_TO_ADDR
// if j then
80682: LD_VAR 0 8
80686: IFFALSE 80755
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
80688: LD_VAR 0 8
80692: PUSH
80693: LD_INT 1
80695: ARRAY
80696: PPUSH
80697: LD_VAR 0 8
80701: PUSH
80702: LD_INT 2
80704: ARRAY
80705: PPUSH
80706: CALL_OW 488
80710: IFFALSE 80755
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
80712: LD_VAR 0 4
80716: PUSH
80717: LD_VAR 0 7
80721: ARRAY
80722: PPUSH
80723: LD_VAR 0 8
80727: PUSH
80728: LD_INT 1
80730: ARRAY
80731: PPUSH
80732: LD_VAR 0 8
80736: PUSH
80737: LD_INT 2
80739: ARRAY
80740: PPUSH
80741: CALL_OW 116
// attacking := true ;
80745: LD_ADDR_VAR 0 29
80749: PUSH
80750: LD_INT 1
80752: ST_TO_ADDR
// continue ;
80753: GO 78128
// end ; end else
80755: GO 80781
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
80757: LD_VAR 0 4
80761: PUSH
80762: LD_VAR 0 7
80766: ARRAY
80767: PPUSH
80768: LD_VAR 0 14
80772: PUSH
80773: LD_INT 1
80775: ARRAY
80776: PPUSH
80777: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
80781: LD_VAR 0 4
80785: PUSH
80786: LD_VAR 0 7
80790: ARRAY
80791: PPUSH
80792: CALL_OW 265
80796: PUSH
80797: LD_INT 11
80799: EQUAL
80800: IFFALSE 81078
// begin k := 10 ;
80802: LD_ADDR_VAR 0 9
80806: PUSH
80807: LD_INT 10
80809: ST_TO_ADDR
// x := 0 ;
80810: LD_ADDR_VAR 0 10
80814: PUSH
80815: LD_INT 0
80817: ST_TO_ADDR
// if tmp < k then
80818: LD_VAR 0 14
80822: PUSH
80823: LD_VAR 0 9
80827: LESS
80828: IFFALSE 80840
// k := tmp ;
80830: LD_ADDR_VAR 0 9
80834: PUSH
80835: LD_VAR 0 14
80839: ST_TO_ADDR
// for j = k downto 1 do
80840: LD_ADDR_VAR 0 8
80844: PUSH
80845: DOUBLE
80846: LD_VAR 0 9
80850: INC
80851: ST_TO_ADDR
80852: LD_INT 1
80854: PUSH
80855: FOR_DOWNTO
80856: IFFALSE 80931
// begin if GetType ( tmp [ j ] ) = unit_human then
80858: LD_VAR 0 14
80862: PUSH
80863: LD_VAR 0 8
80867: ARRAY
80868: PPUSH
80869: CALL_OW 247
80873: PUSH
80874: LD_INT 1
80876: EQUAL
80877: IFFALSE 80929
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
80879: LD_VAR 0 4
80883: PUSH
80884: LD_VAR 0 7
80888: ARRAY
80889: PPUSH
80890: LD_VAR 0 14
80894: PUSH
80895: LD_VAR 0 8
80899: ARRAY
80900: PPUSH
80901: CALL 41516 0 2
// x := tmp [ j ] ;
80905: LD_ADDR_VAR 0 10
80909: PUSH
80910: LD_VAR 0 14
80914: PUSH
80915: LD_VAR 0 8
80919: ARRAY
80920: ST_TO_ADDR
// attacking := true ;
80921: LD_ADDR_VAR 0 29
80925: PUSH
80926: LD_INT 1
80928: ST_TO_ADDR
// end ; end ;
80929: GO 80855
80931: POP
80932: POP
// if not x then
80933: LD_VAR 0 10
80937: NOT
80938: IFFALSE 81078
// begin attacking := true ;
80940: LD_ADDR_VAR 0 29
80944: PUSH
80945: LD_INT 1
80947: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
80948: LD_VAR 0 4
80952: PUSH
80953: LD_VAR 0 7
80957: ARRAY
80958: PPUSH
80959: CALL_OW 250
80963: PPUSH
80964: LD_VAR 0 4
80968: PUSH
80969: LD_VAR 0 7
80973: ARRAY
80974: PPUSH
80975: CALL_OW 251
80979: PPUSH
80980: CALL_OW 546
80984: PUSH
80985: LD_INT 2
80987: ARRAY
80988: PUSH
80989: LD_VAR 0 14
80993: PUSH
80994: LD_INT 1
80996: ARRAY
80997: PPUSH
80998: CALL_OW 250
81002: PPUSH
81003: LD_VAR 0 14
81007: PUSH
81008: LD_INT 1
81010: ARRAY
81011: PPUSH
81012: CALL_OW 251
81016: PPUSH
81017: CALL_OW 546
81021: PUSH
81022: LD_INT 2
81024: ARRAY
81025: EQUAL
81026: IFFALSE 81054
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
81028: LD_VAR 0 4
81032: PUSH
81033: LD_VAR 0 7
81037: ARRAY
81038: PPUSH
81039: LD_VAR 0 14
81043: PUSH
81044: LD_INT 1
81046: ARRAY
81047: PPUSH
81048: CALL 41516 0 2
81052: GO 81078
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81054: LD_VAR 0 4
81058: PUSH
81059: LD_VAR 0 7
81063: ARRAY
81064: PPUSH
81065: LD_VAR 0 14
81069: PUSH
81070: LD_INT 1
81072: ARRAY
81073: PPUSH
81074: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
81078: LD_VAR 0 4
81082: PUSH
81083: LD_VAR 0 7
81087: ARRAY
81088: PPUSH
81089: CALL_OW 264
81093: PUSH
81094: LD_INT 29
81096: EQUAL
81097: IFFALSE 81463
// begin if WantsToAttack ( group [ i ] ) in bombed then
81099: LD_VAR 0 4
81103: PUSH
81104: LD_VAR 0 7
81108: ARRAY
81109: PPUSH
81110: CALL_OW 319
81114: PUSH
81115: LD_VAR 0 28
81119: IN
81120: IFFALSE 81124
// continue ;
81122: GO 78128
// k := 8 ;
81124: LD_ADDR_VAR 0 9
81128: PUSH
81129: LD_INT 8
81131: ST_TO_ADDR
// x := 0 ;
81132: LD_ADDR_VAR 0 10
81136: PUSH
81137: LD_INT 0
81139: ST_TO_ADDR
// if tmp < k then
81140: LD_VAR 0 14
81144: PUSH
81145: LD_VAR 0 9
81149: LESS
81150: IFFALSE 81162
// k := tmp ;
81152: LD_ADDR_VAR 0 9
81156: PUSH
81157: LD_VAR 0 14
81161: ST_TO_ADDR
// for j = 1 to k do
81162: LD_ADDR_VAR 0 8
81166: PUSH
81167: DOUBLE
81168: LD_INT 1
81170: DEC
81171: ST_TO_ADDR
81172: LD_VAR 0 9
81176: PUSH
81177: FOR_TO
81178: IFFALSE 81310
// begin if GetType ( tmp [ j ] ) = unit_building then
81180: LD_VAR 0 14
81184: PUSH
81185: LD_VAR 0 8
81189: ARRAY
81190: PPUSH
81191: CALL_OW 247
81195: PUSH
81196: LD_INT 3
81198: EQUAL
81199: IFFALSE 81308
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81201: LD_VAR 0 14
81205: PUSH
81206: LD_VAR 0 8
81210: ARRAY
81211: PUSH
81212: LD_VAR 0 28
81216: IN
81217: NOT
81218: PUSH
81219: LD_VAR 0 14
81223: PUSH
81224: LD_VAR 0 8
81228: ARRAY
81229: PPUSH
81230: CALL_OW 313
81234: AND
81235: IFFALSE 81308
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81237: LD_VAR 0 4
81241: PUSH
81242: LD_VAR 0 7
81246: ARRAY
81247: PPUSH
81248: LD_VAR 0 14
81252: PUSH
81253: LD_VAR 0 8
81257: ARRAY
81258: PPUSH
81259: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81263: LD_ADDR_VAR 0 28
81267: PUSH
81268: LD_VAR 0 28
81272: PPUSH
81273: LD_VAR 0 28
81277: PUSH
81278: LD_INT 1
81280: PLUS
81281: PPUSH
81282: LD_VAR 0 14
81286: PUSH
81287: LD_VAR 0 8
81291: ARRAY
81292: PPUSH
81293: CALL_OW 1
81297: ST_TO_ADDR
// attacking := true ;
81298: LD_ADDR_VAR 0 29
81302: PUSH
81303: LD_INT 1
81305: ST_TO_ADDR
// break ;
81306: GO 81310
// end ; end ;
81308: GO 81177
81310: POP
81311: POP
// if not attacking and f_attack_depot then
81312: LD_VAR 0 29
81316: NOT
81317: PUSH
81318: LD_VAR 0 25
81322: AND
81323: IFFALSE 81418
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81325: LD_ADDR_VAR 0 13
81329: PUSH
81330: LD_VAR 0 14
81334: PPUSH
81335: LD_INT 2
81337: PUSH
81338: LD_INT 30
81340: PUSH
81341: LD_INT 0
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PUSH
81348: LD_INT 30
81350: PUSH
81351: LD_INT 1
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: LIST
81362: PPUSH
81363: CALL_OW 72
81367: ST_TO_ADDR
// if z then
81368: LD_VAR 0 13
81372: IFFALSE 81418
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81374: LD_VAR 0 4
81378: PUSH
81379: LD_VAR 0 7
81383: ARRAY
81384: PPUSH
81385: LD_VAR 0 13
81389: PPUSH
81390: LD_VAR 0 4
81394: PUSH
81395: LD_VAR 0 7
81399: ARRAY
81400: PPUSH
81401: CALL_OW 74
81405: PPUSH
81406: CALL_OW 115
// attacking := true ;
81410: LD_ADDR_VAR 0 29
81414: PUSH
81415: LD_INT 1
81417: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
81418: LD_VAR 0 4
81422: PUSH
81423: LD_VAR 0 7
81427: ARRAY
81428: PPUSH
81429: CALL_OW 256
81433: PUSH
81434: LD_INT 500
81436: LESS
81437: IFFALSE 81463
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81439: LD_VAR 0 4
81443: PUSH
81444: LD_VAR 0 7
81448: ARRAY
81449: PPUSH
81450: LD_VAR 0 14
81454: PUSH
81455: LD_INT 1
81457: ARRAY
81458: PPUSH
81459: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
81463: LD_VAR 0 4
81467: PUSH
81468: LD_VAR 0 7
81472: ARRAY
81473: PPUSH
81474: CALL_OW 264
81478: PUSH
81479: LD_INT 49
81481: EQUAL
81482: IFFALSE 81603
// begin if not HasTask ( group [ i ] ) then
81484: LD_VAR 0 4
81488: PUSH
81489: LD_VAR 0 7
81493: ARRAY
81494: PPUSH
81495: CALL_OW 314
81499: NOT
81500: IFFALSE 81603
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
81502: LD_ADDR_VAR 0 9
81506: PUSH
81507: LD_INT 81
81509: PUSH
81510: LD_VAR 0 4
81514: PUSH
81515: LD_VAR 0 7
81519: ARRAY
81520: PPUSH
81521: CALL_OW 255
81525: PUSH
81526: EMPTY
81527: LIST
81528: LIST
81529: PPUSH
81530: CALL_OW 69
81534: PPUSH
81535: LD_VAR 0 4
81539: PUSH
81540: LD_VAR 0 7
81544: ARRAY
81545: PPUSH
81546: CALL_OW 74
81550: ST_TO_ADDR
// if k then
81551: LD_VAR 0 9
81555: IFFALSE 81603
// if GetDistUnits ( group [ i ] , k ) > 10 then
81557: LD_VAR 0 4
81561: PUSH
81562: LD_VAR 0 7
81566: ARRAY
81567: PPUSH
81568: LD_VAR 0 9
81572: PPUSH
81573: CALL_OW 296
81577: PUSH
81578: LD_INT 10
81580: GREATER
81581: IFFALSE 81603
// ComMoveUnit ( group [ i ] , k ) ;
81583: LD_VAR 0 4
81587: PUSH
81588: LD_VAR 0 7
81592: ARRAY
81593: PPUSH
81594: LD_VAR 0 9
81598: PPUSH
81599: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81603: LD_VAR 0 4
81607: PUSH
81608: LD_VAR 0 7
81612: ARRAY
81613: PPUSH
81614: CALL_OW 256
81618: PUSH
81619: LD_INT 250
81621: LESS
81622: PUSH
81623: LD_VAR 0 4
81627: PUSH
81628: LD_VAR 0 7
81632: ARRAY
81633: PUSH
81634: LD_INT 21
81636: PUSH
81637: LD_INT 2
81639: PUSH
81640: EMPTY
81641: LIST
81642: LIST
81643: PUSH
81644: LD_INT 23
81646: PUSH
81647: LD_INT 2
81649: PUSH
81650: EMPTY
81651: LIST
81652: LIST
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PPUSH
81658: CALL_OW 69
81662: IN
81663: AND
81664: IFFALSE 81789
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
81666: LD_ADDR_VAR 0 9
81670: PUSH
81671: LD_OWVAR 3
81675: PUSH
81676: LD_VAR 0 4
81680: PUSH
81681: LD_VAR 0 7
81685: ARRAY
81686: DIFF
81687: PPUSH
81688: LD_VAR 0 4
81692: PUSH
81693: LD_VAR 0 7
81697: ARRAY
81698: PPUSH
81699: CALL_OW 74
81703: ST_TO_ADDR
// if not k then
81704: LD_VAR 0 9
81708: NOT
81709: IFFALSE 81713
// continue ;
81711: GO 78128
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
81713: LD_VAR 0 9
81717: PUSH
81718: LD_INT 81
81720: PUSH
81721: LD_VAR 0 4
81725: PUSH
81726: LD_VAR 0 7
81730: ARRAY
81731: PPUSH
81732: CALL_OW 255
81736: PUSH
81737: EMPTY
81738: LIST
81739: LIST
81740: PPUSH
81741: CALL_OW 69
81745: IN
81746: PUSH
81747: LD_VAR 0 9
81751: PPUSH
81752: LD_VAR 0 4
81756: PUSH
81757: LD_VAR 0 7
81761: ARRAY
81762: PPUSH
81763: CALL_OW 296
81767: PUSH
81768: LD_INT 5
81770: LESS
81771: AND
81772: IFFALSE 81789
// ComAutodestruct ( group [ i ] ) ;
81774: LD_VAR 0 4
81778: PUSH
81779: LD_VAR 0 7
81783: ARRAY
81784: PPUSH
81785: CALL 41414 0 1
// end ; if f_attack_depot then
81789: LD_VAR 0 25
81793: IFFALSE 81905
// begin k := 6 ;
81795: LD_ADDR_VAR 0 9
81799: PUSH
81800: LD_INT 6
81802: ST_TO_ADDR
// if tmp < k then
81803: LD_VAR 0 14
81807: PUSH
81808: LD_VAR 0 9
81812: LESS
81813: IFFALSE 81825
// k := tmp ;
81815: LD_ADDR_VAR 0 9
81819: PUSH
81820: LD_VAR 0 14
81824: ST_TO_ADDR
// for j = 1 to k do
81825: LD_ADDR_VAR 0 8
81829: PUSH
81830: DOUBLE
81831: LD_INT 1
81833: DEC
81834: ST_TO_ADDR
81835: LD_VAR 0 9
81839: PUSH
81840: FOR_TO
81841: IFFALSE 81903
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
81843: LD_VAR 0 8
81847: PPUSH
81848: CALL_OW 266
81852: PUSH
81853: LD_INT 0
81855: PUSH
81856: LD_INT 1
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: IN
81863: IFFALSE 81901
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81865: LD_VAR 0 4
81869: PUSH
81870: LD_VAR 0 7
81874: ARRAY
81875: PPUSH
81876: LD_VAR 0 14
81880: PUSH
81881: LD_VAR 0 8
81885: ARRAY
81886: PPUSH
81887: CALL_OW 115
// attacking := true ;
81891: LD_ADDR_VAR 0 29
81895: PUSH
81896: LD_INT 1
81898: ST_TO_ADDR
// break ;
81899: GO 81903
// end ;
81901: GO 81840
81903: POP
81904: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
81905: LD_VAR 0 4
81909: PUSH
81910: LD_VAR 0 7
81914: ARRAY
81915: PPUSH
81916: CALL_OW 302
81920: PUSH
81921: LD_VAR 0 29
81925: NOT
81926: AND
81927: IFFALSE 82249
// begin if GetTag ( group [ i ] ) = 71 then
81929: LD_VAR 0 4
81933: PUSH
81934: LD_VAR 0 7
81938: ARRAY
81939: PPUSH
81940: CALL_OW 110
81944: PUSH
81945: LD_INT 71
81947: EQUAL
81948: IFFALSE 81989
// begin if HasTask ( group [ i ] ) then
81950: LD_VAR 0 4
81954: PUSH
81955: LD_VAR 0 7
81959: ARRAY
81960: PPUSH
81961: CALL_OW 314
81965: IFFALSE 81971
// continue else
81967: GO 78128
81969: GO 81989
// SetTag ( group [ i ] , 0 ) ;
81971: LD_VAR 0 4
81975: PUSH
81976: LD_VAR 0 7
81980: ARRAY
81981: PPUSH
81982: LD_INT 0
81984: PPUSH
81985: CALL_OW 109
// end ; k := 8 ;
81989: LD_ADDR_VAR 0 9
81993: PUSH
81994: LD_INT 8
81996: ST_TO_ADDR
// x := 0 ;
81997: LD_ADDR_VAR 0 10
82001: PUSH
82002: LD_INT 0
82004: ST_TO_ADDR
// if tmp < k then
82005: LD_VAR 0 14
82009: PUSH
82010: LD_VAR 0 9
82014: LESS
82015: IFFALSE 82027
// k := tmp ;
82017: LD_ADDR_VAR 0 9
82021: PUSH
82022: LD_VAR 0 14
82026: ST_TO_ADDR
// for j = 1 to k do
82027: LD_ADDR_VAR 0 8
82031: PUSH
82032: DOUBLE
82033: LD_INT 1
82035: DEC
82036: ST_TO_ADDR
82037: LD_VAR 0 9
82041: PUSH
82042: FOR_TO
82043: IFFALSE 82141
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
82045: LD_VAR 0 14
82049: PUSH
82050: LD_VAR 0 8
82054: ARRAY
82055: PPUSH
82056: CALL_OW 247
82060: PUSH
82061: LD_INT 1
82063: EQUAL
82064: PUSH
82065: LD_VAR 0 14
82069: PUSH
82070: LD_VAR 0 8
82074: ARRAY
82075: PPUSH
82076: CALL_OW 256
82080: PUSH
82081: LD_INT 250
82083: LESS
82084: PUSH
82085: LD_VAR 0 20
82089: AND
82090: PUSH
82091: LD_VAR 0 20
82095: NOT
82096: PUSH
82097: LD_VAR 0 14
82101: PUSH
82102: LD_VAR 0 8
82106: ARRAY
82107: PPUSH
82108: CALL_OW 256
82112: PUSH
82113: LD_INT 250
82115: GREATEREQUAL
82116: AND
82117: OR
82118: AND
82119: IFFALSE 82139
// begin x := tmp [ j ] ;
82121: LD_ADDR_VAR 0 10
82125: PUSH
82126: LD_VAR 0 14
82130: PUSH
82131: LD_VAR 0 8
82135: ARRAY
82136: ST_TO_ADDR
// break ;
82137: GO 82141
// end ;
82139: GO 82042
82141: POP
82142: POP
// if x then
82143: LD_VAR 0 10
82147: IFFALSE 82171
// ComAttackUnit ( group [ i ] , x ) else
82149: LD_VAR 0 4
82153: PUSH
82154: LD_VAR 0 7
82158: ARRAY
82159: PPUSH
82160: LD_VAR 0 10
82164: PPUSH
82165: CALL_OW 115
82169: GO 82195
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82171: LD_VAR 0 4
82175: PUSH
82176: LD_VAR 0 7
82180: ARRAY
82181: PPUSH
82182: LD_VAR 0 14
82186: PUSH
82187: LD_INT 1
82189: ARRAY
82190: PPUSH
82191: CALL_OW 115
// if not HasTask ( group [ i ] ) then
82195: LD_VAR 0 4
82199: PUSH
82200: LD_VAR 0 7
82204: ARRAY
82205: PPUSH
82206: CALL_OW 314
82210: NOT
82211: IFFALSE 82249
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82213: LD_VAR 0 4
82217: PUSH
82218: LD_VAR 0 7
82222: ARRAY
82223: PPUSH
82224: LD_VAR 0 14
82228: PPUSH
82229: LD_VAR 0 4
82233: PUSH
82234: LD_VAR 0 7
82238: ARRAY
82239: PPUSH
82240: CALL_OW 74
82244: PPUSH
82245: CALL_OW 115
// end ; end ; end ;
82249: GO 78128
82251: POP
82252: POP
// wait ( 0 0$2 ) ;
82253: LD_INT 70
82255: PPUSH
82256: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82260: LD_VAR 0 4
82264: NOT
82265: PUSH
82266: LD_VAR 0 4
82270: PUSH
82271: EMPTY
82272: EQUAL
82273: OR
82274: PUSH
82275: LD_INT 81
82277: PUSH
82278: LD_VAR 0 35
82282: PUSH
82283: EMPTY
82284: LIST
82285: LIST
82286: PPUSH
82287: CALL_OW 69
82291: NOT
82292: OR
82293: IFFALSE 78113
// end ;
82295: LD_VAR 0 2
82299: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82300: LD_INT 0
82302: PPUSH
82303: PPUSH
82304: PPUSH
82305: PPUSH
82306: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82307: LD_VAR 0 1
82311: NOT
82312: PUSH
82313: LD_EXP 23
82317: PUSH
82318: LD_VAR 0 1
82322: ARRAY
82323: NOT
82324: OR
82325: PUSH
82326: LD_VAR 0 2
82330: NOT
82331: OR
82332: PUSH
82333: LD_VAR 0 3
82337: NOT
82338: OR
82339: IFFALSE 82343
// exit ;
82341: GO 82856
// side := mc_sides [ base ] ;
82343: LD_ADDR_VAR 0 6
82347: PUSH
82348: LD_EXP 49
82352: PUSH
82353: LD_VAR 0 1
82357: ARRAY
82358: ST_TO_ADDR
// if not side then
82359: LD_VAR 0 6
82363: NOT
82364: IFFALSE 82368
// exit ;
82366: GO 82856
// for i in solds do
82368: LD_ADDR_VAR 0 7
82372: PUSH
82373: LD_VAR 0 2
82377: PUSH
82378: FOR_IN
82379: IFFALSE 82440
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82381: LD_VAR 0 7
82385: PPUSH
82386: CALL_OW 310
82390: PPUSH
82391: CALL_OW 266
82395: PUSH
82396: LD_INT 32
82398: PUSH
82399: LD_INT 31
82401: PUSH
82402: EMPTY
82403: LIST
82404: LIST
82405: IN
82406: IFFALSE 82426
// solds := solds diff i else
82408: LD_ADDR_VAR 0 2
82412: PUSH
82413: LD_VAR 0 2
82417: PUSH
82418: LD_VAR 0 7
82422: DIFF
82423: ST_TO_ADDR
82424: GO 82438
// SetTag ( i , 18 ) ;
82426: LD_VAR 0 7
82430: PPUSH
82431: LD_INT 18
82433: PPUSH
82434: CALL_OW 109
82438: GO 82378
82440: POP
82441: POP
// if not solds then
82442: LD_VAR 0 2
82446: NOT
82447: IFFALSE 82451
// exit ;
82449: GO 82856
// repeat wait ( 0 0$2 ) ;
82451: LD_INT 70
82453: PPUSH
82454: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
82458: LD_ADDR_VAR 0 5
82462: PUSH
82463: LD_VAR 0 6
82467: PPUSH
82468: LD_VAR 0 3
82472: PPUSH
82473: CALL 10384 0 2
82477: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
82478: LD_EXP 23
82482: PUSH
82483: LD_VAR 0 1
82487: ARRAY
82488: NOT
82489: PUSH
82490: LD_EXP 23
82494: PUSH
82495: LD_VAR 0 1
82499: ARRAY
82500: PUSH
82501: EMPTY
82502: EQUAL
82503: OR
82504: IFFALSE 82541
// begin for i in solds do
82506: LD_ADDR_VAR 0 7
82510: PUSH
82511: LD_VAR 0 2
82515: PUSH
82516: FOR_IN
82517: IFFALSE 82530
// ComStop ( i ) ;
82519: LD_VAR 0 7
82523: PPUSH
82524: CALL_OW 141
82528: GO 82516
82530: POP
82531: POP
// solds := [ ] ;
82532: LD_ADDR_VAR 0 2
82536: PUSH
82537: EMPTY
82538: ST_TO_ADDR
// exit ;
82539: GO 82856
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
82541: LD_VAR 0 5
82545: NOT
82546: PUSH
82547: LD_VAR 0 5
82551: PUSH
82552: LD_INT 3
82554: GREATER
82555: OR
82556: PUSH
82557: LD_EXP 45
82561: PUSH
82562: LD_VAR 0 1
82566: ARRAY
82567: OR
82568: IFFALSE 82609
// begin for i in solds do
82570: LD_ADDR_VAR 0 7
82574: PUSH
82575: LD_VAR 0 2
82579: PUSH
82580: FOR_IN
82581: IFFALSE 82605
// if HasTask ( i ) then
82583: LD_VAR 0 7
82587: PPUSH
82588: CALL_OW 314
82592: IFFALSE 82603
// ComStop ( i ) ;
82594: LD_VAR 0 7
82598: PPUSH
82599: CALL_OW 141
82603: GO 82580
82605: POP
82606: POP
// break ;
82607: GO 82844
// end ; for i in solds do
82609: LD_ADDR_VAR 0 7
82613: PUSH
82614: LD_VAR 0 2
82618: PUSH
82619: FOR_IN
82620: IFFALSE 82836
// begin if IsInUnit ( i ) then
82622: LD_VAR 0 7
82626: PPUSH
82627: CALL_OW 310
82631: IFFALSE 82642
// ComExitBuilding ( i ) ;
82633: LD_VAR 0 7
82637: PPUSH
82638: CALL_OW 122
// if GetLives ( i ) > 333 then
82642: LD_VAR 0 7
82646: PPUSH
82647: CALL_OW 256
82651: PUSH
82652: LD_INT 333
82654: GREATER
82655: IFFALSE 82683
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
82657: LD_VAR 0 7
82661: PPUSH
82662: LD_VAR 0 5
82666: PPUSH
82667: LD_VAR 0 7
82671: PPUSH
82672: CALL_OW 74
82676: PPUSH
82677: CALL_OW 115
82681: GO 82834
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
82683: LD_ADDR_VAR 0 8
82687: PUSH
82688: LD_EXP 23
82692: PUSH
82693: LD_VAR 0 1
82697: ARRAY
82698: PPUSH
82699: LD_INT 2
82701: PUSH
82702: LD_INT 30
82704: PUSH
82705: LD_INT 0
82707: PUSH
82708: EMPTY
82709: LIST
82710: LIST
82711: PUSH
82712: LD_INT 30
82714: PUSH
82715: LD_INT 1
82717: PUSH
82718: EMPTY
82719: LIST
82720: LIST
82721: PUSH
82722: LD_INT 30
82724: PUSH
82725: LD_INT 6
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: PUSH
82732: EMPTY
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: PPUSH
82738: CALL_OW 72
82742: PPUSH
82743: LD_VAR 0 7
82747: PPUSH
82748: CALL_OW 74
82752: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
82753: LD_VAR 0 7
82757: PPUSH
82758: LD_VAR 0 8
82762: PPUSH
82763: CALL_OW 250
82767: PPUSH
82768: LD_INT 3
82770: PPUSH
82771: LD_INT 5
82773: PPUSH
82774: CALL_OW 272
82778: PPUSH
82779: LD_VAR 0 8
82783: PPUSH
82784: CALL_OW 251
82788: PPUSH
82789: LD_INT 3
82791: PPUSH
82792: LD_INT 5
82794: PPUSH
82795: CALL_OW 273
82799: PPUSH
82800: CALL_OW 111
// SetTag ( i , 0 ) ;
82804: LD_VAR 0 7
82808: PPUSH
82809: LD_INT 0
82811: PPUSH
82812: CALL_OW 109
// solds := solds diff i ;
82816: LD_ADDR_VAR 0 2
82820: PUSH
82821: LD_VAR 0 2
82825: PUSH
82826: LD_VAR 0 7
82830: DIFF
82831: ST_TO_ADDR
// continue ;
82832: GO 82619
// end ; end ;
82834: GO 82619
82836: POP
82837: POP
// until solds ;
82838: LD_VAR 0 2
82842: IFFALSE 82451
// MC_Reset ( base , 18 ) ;
82844: LD_VAR 0 1
82848: PPUSH
82849: LD_INT 18
82851: PPUSH
82852: CALL 51261 0 2
// end ;
82856: LD_VAR 0 4
82860: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
82861: LD_INT 0
82863: PPUSH
82864: PPUSH
82865: PPUSH
82866: PPUSH
82867: PPUSH
82868: PPUSH
82869: PPUSH
82870: PPUSH
82871: PPUSH
82872: PPUSH
82873: PPUSH
82874: PPUSH
82875: PPUSH
82876: PPUSH
82877: PPUSH
82878: PPUSH
82879: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
82880: LD_ADDR_VAR 0 13
82884: PUSH
82885: LD_EXP 23
82889: PUSH
82890: LD_VAR 0 1
82894: ARRAY
82895: PPUSH
82896: LD_INT 25
82898: PUSH
82899: LD_INT 3
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PPUSH
82906: CALL_OW 72
82910: ST_TO_ADDR
// if mc_remote_driver [ base ] then
82911: LD_EXP 63
82915: PUSH
82916: LD_VAR 0 1
82920: ARRAY
82921: IFFALSE 82945
// mechs := mechs diff mc_remote_driver [ base ] ;
82923: LD_ADDR_VAR 0 13
82927: PUSH
82928: LD_VAR 0 13
82932: PUSH
82933: LD_EXP 63
82937: PUSH
82938: LD_VAR 0 1
82942: ARRAY
82943: DIFF
82944: ST_TO_ADDR
// for i in mechs do
82945: LD_ADDR_VAR 0 5
82949: PUSH
82950: LD_VAR 0 13
82954: PUSH
82955: FOR_IN
82956: IFFALSE 82991
// if GetTag ( i ) > 0 then
82958: LD_VAR 0 5
82962: PPUSH
82963: CALL_OW 110
82967: PUSH
82968: LD_INT 0
82970: GREATER
82971: IFFALSE 82989
// mechs := mechs diff i ;
82973: LD_ADDR_VAR 0 13
82977: PUSH
82978: LD_VAR 0 13
82982: PUSH
82983: LD_VAR 0 5
82987: DIFF
82988: ST_TO_ADDR
82989: GO 82955
82991: POP
82992: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
82993: LD_ADDR_VAR 0 9
82997: PUSH
82998: LD_EXP 23
83002: PUSH
83003: LD_VAR 0 1
83007: ARRAY
83008: PPUSH
83009: LD_INT 2
83011: PUSH
83012: LD_INT 25
83014: PUSH
83015: LD_INT 1
83017: PUSH
83018: EMPTY
83019: LIST
83020: LIST
83021: PUSH
83022: LD_INT 25
83024: PUSH
83025: LD_INT 5
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: PUSH
83032: LD_INT 25
83034: PUSH
83035: LD_INT 8
83037: PUSH
83038: EMPTY
83039: LIST
83040: LIST
83041: PUSH
83042: LD_INT 25
83044: PUSH
83045: LD_INT 9
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: PPUSH
83059: CALL_OW 72
83063: ST_TO_ADDR
// if not defenders and not solds then
83064: LD_VAR 0 2
83068: NOT
83069: PUSH
83070: LD_VAR 0 9
83074: NOT
83075: AND
83076: IFFALSE 83080
// exit ;
83078: GO 84770
// depot_under_attack := false ;
83080: LD_ADDR_VAR 0 17
83084: PUSH
83085: LD_INT 0
83087: ST_TO_ADDR
// sold_defenders := [ ] ;
83088: LD_ADDR_VAR 0 18
83092: PUSH
83093: EMPTY
83094: ST_TO_ADDR
// if mechs then
83095: LD_VAR 0 13
83099: IFFALSE 83252
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
83101: LD_ADDR_VAR 0 5
83105: PUSH
83106: LD_VAR 0 2
83110: PPUSH
83111: LD_INT 21
83113: PUSH
83114: LD_INT 2
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PPUSH
83121: CALL_OW 72
83125: PUSH
83126: FOR_IN
83127: IFFALSE 83250
// begin if GetTag ( i ) <> 20 then
83129: LD_VAR 0 5
83133: PPUSH
83134: CALL_OW 110
83138: PUSH
83139: LD_INT 20
83141: NONEQUAL
83142: IFFALSE 83156
// SetTag ( i , 20 ) ;
83144: LD_VAR 0 5
83148: PPUSH
83149: LD_INT 20
83151: PPUSH
83152: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
83156: LD_VAR 0 5
83160: PPUSH
83161: CALL_OW 263
83165: PUSH
83166: LD_INT 1
83168: EQUAL
83169: PUSH
83170: LD_VAR 0 5
83174: PPUSH
83175: CALL_OW 311
83179: NOT
83180: AND
83181: IFFALSE 83248
// begin un := mechs [ 1 ] ;
83183: LD_ADDR_VAR 0 11
83187: PUSH
83188: LD_VAR 0 13
83192: PUSH
83193: LD_INT 1
83195: ARRAY
83196: ST_TO_ADDR
// ComExit ( un ) ;
83197: LD_VAR 0 11
83201: PPUSH
83202: CALL 45759 0 1
// AddComEnterUnit ( un , i ) ;
83206: LD_VAR 0 11
83210: PPUSH
83211: LD_VAR 0 5
83215: PPUSH
83216: CALL_OW 180
// SetTag ( un , 19 ) ;
83220: LD_VAR 0 11
83224: PPUSH
83225: LD_INT 19
83227: PPUSH
83228: CALL_OW 109
// mechs := mechs diff un ;
83232: LD_ADDR_VAR 0 13
83236: PUSH
83237: LD_VAR 0 13
83241: PUSH
83242: LD_VAR 0 11
83246: DIFF
83247: ST_TO_ADDR
// end ; end ;
83248: GO 83126
83250: POP
83251: POP
// if solds then
83252: LD_VAR 0 9
83256: IFFALSE 83315
// for i in solds do
83258: LD_ADDR_VAR 0 5
83262: PUSH
83263: LD_VAR 0 9
83267: PUSH
83268: FOR_IN
83269: IFFALSE 83313
// if not GetTag ( i ) then
83271: LD_VAR 0 5
83275: PPUSH
83276: CALL_OW 110
83280: NOT
83281: IFFALSE 83311
// begin defenders := defenders union i ;
83283: LD_ADDR_VAR 0 2
83287: PUSH
83288: LD_VAR 0 2
83292: PUSH
83293: LD_VAR 0 5
83297: UNION
83298: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83299: LD_VAR 0 5
83303: PPUSH
83304: LD_INT 18
83306: PPUSH
83307: CALL_OW 109
// end ;
83311: GO 83268
83313: POP
83314: POP
// repeat wait ( 0 0$2 ) ;
83315: LD_INT 70
83317: PPUSH
83318: CALL_OW 67
// enemy := mc_scan [ base ] ;
83322: LD_ADDR_VAR 0 3
83326: PUSH
83327: LD_EXP 46
83331: PUSH
83332: LD_VAR 0 1
83336: ARRAY
83337: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83338: LD_EXP 23
83342: PUSH
83343: LD_VAR 0 1
83347: ARRAY
83348: NOT
83349: PUSH
83350: LD_EXP 23
83354: PUSH
83355: LD_VAR 0 1
83359: ARRAY
83360: PUSH
83361: EMPTY
83362: EQUAL
83363: OR
83364: IFFALSE 83401
// begin for i in defenders do
83366: LD_ADDR_VAR 0 5
83370: PUSH
83371: LD_VAR 0 2
83375: PUSH
83376: FOR_IN
83377: IFFALSE 83390
// ComStop ( i ) ;
83379: LD_VAR 0 5
83383: PPUSH
83384: CALL_OW 141
83388: GO 83376
83390: POP
83391: POP
// defenders := [ ] ;
83392: LD_ADDR_VAR 0 2
83396: PUSH
83397: EMPTY
83398: ST_TO_ADDR
// exit ;
83399: GO 84770
// end ; for i in defenders do
83401: LD_ADDR_VAR 0 5
83405: PUSH
83406: LD_VAR 0 2
83410: PUSH
83411: FOR_IN
83412: IFFALSE 84230
// begin e := NearestUnitToUnit ( enemy , i ) ;
83414: LD_ADDR_VAR 0 14
83418: PUSH
83419: LD_VAR 0 3
83423: PPUSH
83424: LD_VAR 0 5
83428: PPUSH
83429: CALL_OW 74
83433: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83434: LD_ADDR_VAR 0 8
83438: PUSH
83439: LD_EXP 23
83443: PUSH
83444: LD_VAR 0 1
83448: ARRAY
83449: PPUSH
83450: LD_INT 2
83452: PUSH
83453: LD_INT 30
83455: PUSH
83456: LD_INT 0
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 30
83465: PUSH
83466: LD_INT 1
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: LIST
83477: PPUSH
83478: CALL_OW 72
83482: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
83483: LD_ADDR_VAR 0 17
83487: PUSH
83488: LD_VAR 0 8
83492: NOT
83493: PUSH
83494: LD_VAR 0 8
83498: PPUSH
83499: LD_INT 3
83501: PUSH
83502: LD_INT 24
83504: PUSH
83505: LD_INT 600
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: PPUSH
83516: CALL_OW 72
83520: OR
83521: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
83522: LD_VAR 0 5
83526: PPUSH
83527: CALL_OW 247
83531: PUSH
83532: LD_INT 2
83534: DOUBLE
83535: EQUAL
83536: IFTRUE 83540
83538: GO 83936
83540: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
83541: LD_VAR 0 5
83545: PPUSH
83546: CALL_OW 256
83550: PUSH
83551: LD_INT 1000
83553: EQUAL
83554: PUSH
83555: LD_VAR 0 5
83559: PPUSH
83560: LD_VAR 0 14
83564: PPUSH
83565: CALL_OW 296
83569: PUSH
83570: LD_INT 40
83572: LESS
83573: PUSH
83574: LD_VAR 0 14
83578: PPUSH
83579: LD_EXP 48
83583: PUSH
83584: LD_VAR 0 1
83588: ARRAY
83589: PPUSH
83590: CALL_OW 308
83594: OR
83595: AND
83596: IFFALSE 83718
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
83598: LD_VAR 0 5
83602: PPUSH
83603: CALL_OW 262
83607: PUSH
83608: LD_INT 1
83610: EQUAL
83611: PUSH
83612: LD_VAR 0 5
83616: PPUSH
83617: CALL_OW 261
83621: PUSH
83622: LD_INT 30
83624: LESS
83625: AND
83626: PUSH
83627: LD_VAR 0 8
83631: AND
83632: IFFALSE 83702
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
83634: LD_VAR 0 5
83638: PPUSH
83639: LD_VAR 0 8
83643: PPUSH
83644: LD_VAR 0 5
83648: PPUSH
83649: CALL_OW 74
83653: PPUSH
83654: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
83658: LD_VAR 0 5
83662: PPUSH
83663: LD_VAR 0 8
83667: PPUSH
83668: LD_VAR 0 5
83672: PPUSH
83673: CALL_OW 74
83677: PPUSH
83678: CALL_OW 296
83682: PUSH
83683: LD_INT 6
83685: LESS
83686: IFFALSE 83700
// SetFuel ( i , 100 ) ;
83688: LD_VAR 0 5
83692: PPUSH
83693: LD_INT 100
83695: PPUSH
83696: CALL_OW 240
// end else
83700: GO 83716
// ComAttackUnit ( i , e ) ;
83702: LD_VAR 0 5
83706: PPUSH
83707: LD_VAR 0 14
83711: PPUSH
83712: CALL_OW 115
// end else
83716: GO 83819
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
83718: LD_VAR 0 14
83722: PPUSH
83723: LD_EXP 48
83727: PUSH
83728: LD_VAR 0 1
83732: ARRAY
83733: PPUSH
83734: CALL_OW 308
83738: NOT
83739: PUSH
83740: LD_VAR 0 5
83744: PPUSH
83745: LD_VAR 0 14
83749: PPUSH
83750: CALL_OW 296
83754: PUSH
83755: LD_INT 40
83757: GREATEREQUAL
83758: AND
83759: PUSH
83760: LD_VAR 0 5
83764: PPUSH
83765: CALL_OW 256
83769: PUSH
83770: LD_INT 650
83772: LESSEQUAL
83773: OR
83774: PUSH
83775: LD_VAR 0 5
83779: PPUSH
83780: LD_EXP 47
83784: PUSH
83785: LD_VAR 0 1
83789: ARRAY
83790: PPUSH
83791: CALL_OW 308
83795: NOT
83796: AND
83797: IFFALSE 83819
// ComMoveToArea ( i , mc_parking [ base ] ) ;
83799: LD_VAR 0 5
83803: PPUSH
83804: LD_EXP 47
83808: PUSH
83809: LD_VAR 0 1
83813: ARRAY
83814: PPUSH
83815: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
83819: LD_VAR 0 5
83823: PPUSH
83824: CALL_OW 256
83828: PUSH
83829: LD_INT 1000
83831: LESS
83832: PUSH
83833: LD_VAR 0 5
83837: PPUSH
83838: CALL_OW 263
83842: PUSH
83843: LD_INT 1
83845: EQUAL
83846: AND
83847: PUSH
83848: LD_VAR 0 5
83852: PPUSH
83853: CALL_OW 311
83857: AND
83858: PUSH
83859: LD_VAR 0 5
83863: PPUSH
83864: LD_EXP 47
83868: PUSH
83869: LD_VAR 0 1
83873: ARRAY
83874: PPUSH
83875: CALL_OW 308
83879: AND
83880: IFFALSE 83934
// begin mech := IsDrivenBy ( i ) ;
83882: LD_ADDR_VAR 0 10
83886: PUSH
83887: LD_VAR 0 5
83891: PPUSH
83892: CALL_OW 311
83896: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
83897: LD_VAR 0 10
83901: PPUSH
83902: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
83906: LD_VAR 0 10
83910: PPUSH
83911: LD_VAR 0 5
83915: PPUSH
83916: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
83920: LD_VAR 0 10
83924: PPUSH
83925: LD_VAR 0 5
83929: PPUSH
83930: CALL_OW 180
// end ; end ; unit_human :
83934: GO 84201
83936: LD_INT 1
83938: DOUBLE
83939: EQUAL
83940: IFTRUE 83944
83942: GO 84200
83944: POP
// begin b := IsInUnit ( i ) ;
83945: LD_ADDR_VAR 0 19
83949: PUSH
83950: LD_VAR 0 5
83954: PPUSH
83955: CALL_OW 310
83959: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
83960: LD_ADDR_VAR 0 20
83964: PUSH
83965: LD_VAR 0 19
83969: NOT
83970: PUSH
83971: LD_VAR 0 19
83975: PPUSH
83976: CALL_OW 266
83980: PUSH
83981: LD_INT 32
83983: PUSH
83984: LD_INT 31
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: IN
83991: OR
83992: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
83993: LD_VAR 0 17
83997: PUSH
83998: LD_VAR 0 2
84002: PPUSH
84003: LD_INT 21
84005: PUSH
84006: LD_INT 2
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PPUSH
84013: CALL_OW 72
84017: PUSH
84018: LD_INT 1
84020: LESSEQUAL
84021: OR
84022: PUSH
84023: LD_VAR 0 20
84027: AND
84028: PUSH
84029: LD_VAR 0 5
84033: PUSH
84034: LD_VAR 0 18
84038: IN
84039: NOT
84040: AND
84041: IFFALSE 84134
// begin if b then
84043: LD_VAR 0 19
84047: IFFALSE 84096
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
84049: LD_VAR 0 19
84053: PPUSH
84054: LD_VAR 0 3
84058: PPUSH
84059: LD_VAR 0 19
84063: PPUSH
84064: CALL_OW 74
84068: PPUSH
84069: CALL_OW 296
84073: PUSH
84074: LD_INT 10
84076: LESS
84077: PUSH
84078: LD_VAR 0 19
84082: PPUSH
84083: CALL_OW 461
84087: PUSH
84088: LD_INT 7
84090: NONEQUAL
84091: AND
84092: IFFALSE 84096
// continue ;
84094: GO 83411
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
84096: LD_ADDR_VAR 0 18
84100: PUSH
84101: LD_VAR 0 18
84105: PPUSH
84106: LD_VAR 0 18
84110: PUSH
84111: LD_INT 1
84113: PLUS
84114: PPUSH
84115: LD_VAR 0 5
84119: PPUSH
84120: CALL_OW 1
84124: ST_TO_ADDR
// ComExitBuilding ( i ) ;
84125: LD_VAR 0 5
84129: PPUSH
84130: CALL_OW 122
// end ; if sold_defenders then
84134: LD_VAR 0 18
84138: IFFALSE 84198
// if i in sold_defenders then
84140: LD_VAR 0 5
84144: PUSH
84145: LD_VAR 0 18
84149: IN
84150: IFFALSE 84198
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
84152: LD_VAR 0 5
84156: PPUSH
84157: CALL_OW 314
84161: NOT
84162: PUSH
84163: LD_VAR 0 5
84167: PPUSH
84168: LD_VAR 0 14
84172: PPUSH
84173: CALL_OW 296
84177: PUSH
84178: LD_INT 30
84180: LESS
84181: AND
84182: IFFALSE 84198
// ComAttackUnit ( i , e ) ;
84184: LD_VAR 0 5
84188: PPUSH
84189: LD_VAR 0 14
84193: PPUSH
84194: CALL_OW 115
// end ; end ; end ;
84198: GO 84201
84200: POP
// if IsDead ( i ) then
84201: LD_VAR 0 5
84205: PPUSH
84206: CALL_OW 301
84210: IFFALSE 84228
// defenders := defenders diff i ;
84212: LD_ADDR_VAR 0 2
84216: PUSH
84217: LD_VAR 0 2
84221: PUSH
84222: LD_VAR 0 5
84226: DIFF
84227: ST_TO_ADDR
// end ;
84228: GO 83411
84230: POP
84231: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84232: LD_VAR 0 3
84236: NOT
84237: PUSH
84238: LD_VAR 0 2
84242: NOT
84243: OR
84244: PUSH
84245: LD_EXP 23
84249: PUSH
84250: LD_VAR 0 1
84254: ARRAY
84255: NOT
84256: OR
84257: IFFALSE 83315
// MC_Reset ( base , 18 ) ;
84259: LD_VAR 0 1
84263: PPUSH
84264: LD_INT 18
84266: PPUSH
84267: CALL 51261 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84271: LD_ADDR_VAR 0 2
84275: PUSH
84276: LD_VAR 0 2
84280: PUSH
84281: LD_VAR 0 2
84285: PPUSH
84286: LD_INT 2
84288: PUSH
84289: LD_INT 25
84291: PUSH
84292: LD_INT 1
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 25
84301: PUSH
84302: LD_INT 5
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 25
84311: PUSH
84312: LD_INT 8
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 25
84321: PUSH
84322: LD_INT 9
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: LIST
84333: LIST
84334: LIST
84335: PPUSH
84336: CALL_OW 72
84340: DIFF
84341: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
84342: LD_VAR 0 3
84346: NOT
84347: PUSH
84348: LD_VAR 0 2
84352: PPUSH
84353: LD_INT 21
84355: PUSH
84356: LD_INT 2
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PPUSH
84363: CALL_OW 72
84367: AND
84368: IFFALSE 84706
// begin tmp := FilterByTag ( defenders , 19 ) ;
84370: LD_ADDR_VAR 0 12
84374: PUSH
84375: LD_VAR 0 2
84379: PPUSH
84380: LD_INT 19
84382: PPUSH
84383: CALL 42889 0 2
84387: ST_TO_ADDR
// if tmp then
84388: LD_VAR 0 12
84392: IFFALSE 84462
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
84394: LD_ADDR_VAR 0 12
84398: PUSH
84399: LD_VAR 0 12
84403: PPUSH
84404: LD_INT 25
84406: PUSH
84407: LD_INT 3
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PPUSH
84414: CALL_OW 72
84418: ST_TO_ADDR
// if tmp then
84419: LD_VAR 0 12
84423: IFFALSE 84462
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
84425: LD_ADDR_EXP 35
84429: PUSH
84430: LD_EXP 35
84434: PPUSH
84435: LD_VAR 0 1
84439: PPUSH
84440: LD_EXP 35
84444: PUSH
84445: LD_VAR 0 1
84449: ARRAY
84450: PUSH
84451: LD_VAR 0 12
84455: UNION
84456: PPUSH
84457: CALL_OW 1
84461: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
84462: LD_VAR 0 1
84466: PPUSH
84467: LD_INT 19
84469: PPUSH
84470: CALL 51261 0 2
// repeat wait ( 0 0$1 ) ;
84474: LD_INT 35
84476: PPUSH
84477: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
84481: LD_EXP 23
84485: PUSH
84486: LD_VAR 0 1
84490: ARRAY
84491: NOT
84492: PUSH
84493: LD_EXP 23
84497: PUSH
84498: LD_VAR 0 1
84502: ARRAY
84503: PUSH
84504: EMPTY
84505: EQUAL
84506: OR
84507: IFFALSE 84544
// begin for i in defenders do
84509: LD_ADDR_VAR 0 5
84513: PUSH
84514: LD_VAR 0 2
84518: PUSH
84519: FOR_IN
84520: IFFALSE 84533
// ComStop ( i ) ;
84522: LD_VAR 0 5
84526: PPUSH
84527: CALL_OW 141
84531: GO 84519
84533: POP
84534: POP
// defenders := [ ] ;
84535: LD_ADDR_VAR 0 2
84539: PUSH
84540: EMPTY
84541: ST_TO_ADDR
// exit ;
84542: GO 84770
// end ; for i in defenders do
84544: LD_ADDR_VAR 0 5
84548: PUSH
84549: LD_VAR 0 2
84553: PUSH
84554: FOR_IN
84555: IFFALSE 84644
// begin if not IsInArea ( i , mc_parking [ base ] ) then
84557: LD_VAR 0 5
84561: PPUSH
84562: LD_EXP 47
84566: PUSH
84567: LD_VAR 0 1
84571: ARRAY
84572: PPUSH
84573: CALL_OW 308
84577: NOT
84578: IFFALSE 84602
// ComMoveToArea ( i , mc_parking [ base ] ) else
84580: LD_VAR 0 5
84584: PPUSH
84585: LD_EXP 47
84589: PUSH
84590: LD_VAR 0 1
84594: ARRAY
84595: PPUSH
84596: CALL_OW 113
84600: GO 84642
// if GetControl ( i ) = control_manual then
84602: LD_VAR 0 5
84606: PPUSH
84607: CALL_OW 263
84611: PUSH
84612: LD_INT 1
84614: EQUAL
84615: IFFALSE 84642
// if IsDrivenBy ( i ) then
84617: LD_VAR 0 5
84621: PPUSH
84622: CALL_OW 311
84626: IFFALSE 84642
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
84628: LD_VAR 0 5
84632: PPUSH
84633: CALL_OW 311
84637: PPUSH
84638: CALL_OW 121
// end ;
84642: GO 84554
84644: POP
84645: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
84646: LD_VAR 0 2
84650: PPUSH
84651: LD_INT 95
84653: PUSH
84654: LD_EXP 47
84658: PUSH
84659: LD_VAR 0 1
84663: ARRAY
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PPUSH
84669: CALL_OW 72
84673: PUSH
84674: LD_VAR 0 2
84678: EQUAL
84679: PUSH
84680: LD_EXP 46
84684: PUSH
84685: LD_VAR 0 1
84689: ARRAY
84690: OR
84691: PUSH
84692: LD_EXP 23
84696: PUSH
84697: LD_VAR 0 1
84701: ARRAY
84702: NOT
84703: OR
84704: IFFALSE 84474
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
84706: LD_ADDR_EXP 45
84710: PUSH
84711: LD_EXP 45
84715: PPUSH
84716: LD_VAR 0 1
84720: PPUSH
84721: LD_VAR 0 2
84725: PPUSH
84726: LD_INT 21
84728: PUSH
84729: LD_INT 2
84731: PUSH
84732: EMPTY
84733: LIST
84734: LIST
84735: PPUSH
84736: CALL_OW 72
84740: PPUSH
84741: CALL_OW 1
84745: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
84746: LD_VAR 0 1
84750: PPUSH
84751: LD_INT 19
84753: PPUSH
84754: CALL 51261 0 2
// MC_Reset ( base , 20 ) ;
84758: LD_VAR 0 1
84762: PPUSH
84763: LD_INT 20
84765: PPUSH
84766: CALL 51261 0 2
// end ; end_of_file
84770: LD_VAR 0 4
84774: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
84775: LD_INT 0
84777: PPUSH
84778: PPUSH
84779: PPUSH
84780: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
84781: LD_VAR 0 1
84785: PPUSH
84786: CALL_OW 264
84790: PUSH
84791: LD_EXP 71
84795: EQUAL
84796: IFFALSE 84868
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
84798: LD_INT 68
84800: PPUSH
84801: LD_VAR 0 1
84805: PPUSH
84806: CALL_OW 255
84810: PPUSH
84811: CALL_OW 321
84815: PUSH
84816: LD_INT 2
84818: EQUAL
84819: IFFALSE 84831
// eff := 70 else
84821: LD_ADDR_VAR 0 4
84825: PUSH
84826: LD_INT 70
84828: ST_TO_ADDR
84829: GO 84839
// eff := 30 ;
84831: LD_ADDR_VAR 0 4
84835: PUSH
84836: LD_INT 30
84838: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
84839: LD_VAR 0 1
84843: PPUSH
84844: CALL_OW 250
84848: PPUSH
84849: LD_VAR 0 1
84853: PPUSH
84854: CALL_OW 251
84858: PPUSH
84859: LD_VAR 0 4
84863: PPUSH
84864: CALL_OW 495
// end ; end ;
84868: LD_VAR 0 2
84872: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
84873: LD_INT 0
84875: PPUSH
// end ;
84876: LD_VAR 0 4
84880: RET
// export function SOS_Command ( cmd ) ; begin
84881: LD_INT 0
84883: PPUSH
// end ;
84884: LD_VAR 0 2
84888: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
84889: LD_INT 0
84891: PPUSH
// if cmd = 121 then
84892: LD_VAR 0 1
84896: PUSH
84897: LD_INT 121
84899: EQUAL
84900: IFFALSE 84902
// end ;
84902: LD_VAR 0 6
84906: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
84907: LD_INT 0
84909: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
84910: LD_VAR 0 1
84914: PUSH
84915: LD_INT 250
84917: EQUAL
84918: PUSH
84919: LD_VAR 0 2
84923: PPUSH
84924: CALL_OW 264
84928: PUSH
84929: LD_EXP 74
84933: EQUAL
84934: AND
84935: IFFALSE 84956
// MinerPlaceMine ( unit , x , y ) ;
84937: LD_VAR 0 2
84941: PPUSH
84942: LD_VAR 0 4
84946: PPUSH
84947: LD_VAR 0 5
84951: PPUSH
84952: CALL 87305 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
84956: LD_VAR 0 1
84960: PUSH
84961: LD_INT 251
84963: EQUAL
84964: PUSH
84965: LD_VAR 0 2
84969: PPUSH
84970: CALL_OW 264
84974: PUSH
84975: LD_EXP 74
84979: EQUAL
84980: AND
84981: IFFALSE 85002
// MinerDetonateMine ( unit , x , y ) ;
84983: LD_VAR 0 2
84987: PPUSH
84988: LD_VAR 0 4
84992: PPUSH
84993: LD_VAR 0 5
84997: PPUSH
84998: CALL 87582 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
85002: LD_VAR 0 1
85006: PUSH
85007: LD_INT 252
85009: EQUAL
85010: PUSH
85011: LD_VAR 0 2
85015: PPUSH
85016: CALL_OW 264
85020: PUSH
85021: LD_EXP 74
85025: EQUAL
85026: AND
85027: IFFALSE 85048
// MinerCreateMinefield ( unit , x , y ) ;
85029: LD_VAR 0 2
85033: PPUSH
85034: LD_VAR 0 4
85038: PPUSH
85039: LD_VAR 0 5
85043: PPUSH
85044: CALL 87999 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
85048: LD_VAR 0 1
85052: PUSH
85053: LD_INT 253
85055: EQUAL
85056: PUSH
85057: LD_VAR 0 2
85061: PPUSH
85062: CALL_OW 257
85066: PUSH
85067: LD_INT 5
85069: EQUAL
85070: AND
85071: IFFALSE 85092
// ComBinocular ( unit , x , y ) ;
85073: LD_VAR 0 2
85077: PPUSH
85078: LD_VAR 0 4
85082: PPUSH
85083: LD_VAR 0 5
85087: PPUSH
85088: CALL 88370 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
85092: LD_VAR 0 1
85096: PUSH
85097: LD_INT 254
85099: EQUAL
85100: PUSH
85101: LD_VAR 0 2
85105: PPUSH
85106: CALL_OW 264
85110: PUSH
85111: LD_EXP 69
85115: EQUAL
85116: AND
85117: PUSH
85118: LD_VAR 0 3
85122: PPUSH
85123: CALL_OW 263
85127: PUSH
85128: LD_INT 3
85130: EQUAL
85131: AND
85132: IFFALSE 85148
// HackDestroyVehicle ( unit , selectedUnit ) ;
85134: LD_VAR 0 2
85138: PPUSH
85139: LD_VAR 0 3
85143: PPUSH
85144: CALL 86665 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
85148: LD_VAR 0 1
85152: PUSH
85153: LD_INT 255
85155: EQUAL
85156: PUSH
85157: LD_VAR 0 2
85161: PPUSH
85162: CALL_OW 264
85166: PUSH
85167: LD_INT 14
85169: PUSH
85170: LD_INT 53
85172: PUSH
85173: EMPTY
85174: LIST
85175: LIST
85176: IN
85177: AND
85178: PUSH
85179: LD_VAR 0 4
85183: PPUSH
85184: LD_VAR 0 5
85188: PPUSH
85189: CALL_OW 488
85193: AND
85194: IFFALSE 85218
// CutTreeXYR ( unit , x , y , 12 ) ;
85196: LD_VAR 0 2
85200: PPUSH
85201: LD_VAR 0 4
85205: PPUSH
85206: LD_VAR 0 5
85210: PPUSH
85211: LD_INT 12
85213: PPUSH
85214: CALL 85231 0 4
// end ;
85218: LD_VAR 0 6
85222: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
85223: LD_INT 0
85225: PPUSH
// end ;
85226: LD_VAR 0 4
85230: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
85231: LD_INT 0
85233: PPUSH
85234: PPUSH
85235: PPUSH
85236: PPUSH
85237: PPUSH
85238: PPUSH
85239: PPUSH
85240: PPUSH
85241: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
85242: LD_VAR 0 1
85246: NOT
85247: PUSH
85248: LD_VAR 0 2
85252: PPUSH
85253: LD_VAR 0 3
85257: PPUSH
85258: CALL_OW 488
85262: NOT
85263: OR
85264: PUSH
85265: LD_VAR 0 4
85269: NOT
85270: OR
85271: IFFALSE 85275
// exit ;
85273: GO 85615
// list := [ ] ;
85275: LD_ADDR_VAR 0 13
85279: PUSH
85280: EMPTY
85281: ST_TO_ADDR
// if x - r < 0 then
85282: LD_VAR 0 2
85286: PUSH
85287: LD_VAR 0 4
85291: MINUS
85292: PUSH
85293: LD_INT 0
85295: LESS
85296: IFFALSE 85308
// min_x := 0 else
85298: LD_ADDR_VAR 0 7
85302: PUSH
85303: LD_INT 0
85305: ST_TO_ADDR
85306: GO 85324
// min_x := x - r ;
85308: LD_ADDR_VAR 0 7
85312: PUSH
85313: LD_VAR 0 2
85317: PUSH
85318: LD_VAR 0 4
85322: MINUS
85323: ST_TO_ADDR
// if y - r < 0 then
85324: LD_VAR 0 3
85328: PUSH
85329: LD_VAR 0 4
85333: MINUS
85334: PUSH
85335: LD_INT 0
85337: LESS
85338: IFFALSE 85350
// min_y := 0 else
85340: LD_ADDR_VAR 0 8
85344: PUSH
85345: LD_INT 0
85347: ST_TO_ADDR
85348: GO 85366
// min_y := y - r ;
85350: LD_ADDR_VAR 0 8
85354: PUSH
85355: LD_VAR 0 3
85359: PUSH
85360: LD_VAR 0 4
85364: MINUS
85365: ST_TO_ADDR
// max_x := x + r ;
85366: LD_ADDR_VAR 0 9
85370: PUSH
85371: LD_VAR 0 2
85375: PUSH
85376: LD_VAR 0 4
85380: PLUS
85381: ST_TO_ADDR
// max_y := y + r ;
85382: LD_ADDR_VAR 0 10
85386: PUSH
85387: LD_VAR 0 3
85391: PUSH
85392: LD_VAR 0 4
85396: PLUS
85397: ST_TO_ADDR
// for _x = min_x to max_x do
85398: LD_ADDR_VAR 0 11
85402: PUSH
85403: DOUBLE
85404: LD_VAR 0 7
85408: DEC
85409: ST_TO_ADDR
85410: LD_VAR 0 9
85414: PUSH
85415: FOR_TO
85416: IFFALSE 85533
// for _y = min_y to max_y do
85418: LD_ADDR_VAR 0 12
85422: PUSH
85423: DOUBLE
85424: LD_VAR 0 8
85428: DEC
85429: ST_TO_ADDR
85430: LD_VAR 0 10
85434: PUSH
85435: FOR_TO
85436: IFFALSE 85529
// begin if not ValidHex ( _x , _y ) then
85438: LD_VAR 0 11
85442: PPUSH
85443: LD_VAR 0 12
85447: PPUSH
85448: CALL_OW 488
85452: NOT
85453: IFFALSE 85457
// continue ;
85455: GO 85435
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
85457: LD_VAR 0 11
85461: PPUSH
85462: LD_VAR 0 12
85466: PPUSH
85467: CALL_OW 351
85471: PUSH
85472: LD_VAR 0 11
85476: PPUSH
85477: LD_VAR 0 12
85481: PPUSH
85482: CALL_OW 554
85486: AND
85487: IFFALSE 85527
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
85489: LD_ADDR_VAR 0 13
85493: PUSH
85494: LD_VAR 0 13
85498: PPUSH
85499: LD_VAR 0 13
85503: PUSH
85504: LD_INT 1
85506: PLUS
85507: PPUSH
85508: LD_VAR 0 11
85512: PUSH
85513: LD_VAR 0 12
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PPUSH
85522: CALL_OW 2
85526: ST_TO_ADDR
// end ;
85527: GO 85435
85529: POP
85530: POP
85531: GO 85415
85533: POP
85534: POP
// if not list then
85535: LD_VAR 0 13
85539: NOT
85540: IFFALSE 85544
// exit ;
85542: GO 85615
// for i in list do
85544: LD_ADDR_VAR 0 6
85548: PUSH
85549: LD_VAR 0 13
85553: PUSH
85554: FOR_IN
85555: IFFALSE 85613
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
85557: LD_VAR 0 1
85561: PPUSH
85562: LD_STRING M
85564: PUSH
85565: LD_VAR 0 6
85569: PUSH
85570: LD_INT 1
85572: ARRAY
85573: PUSH
85574: LD_VAR 0 6
85578: PUSH
85579: LD_INT 2
85581: ARRAY
85582: PUSH
85583: LD_INT 0
85585: PUSH
85586: LD_INT 0
85588: PUSH
85589: LD_INT 0
85591: PUSH
85592: LD_INT 0
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: LIST
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: PUSH
85604: EMPTY
85605: LIST
85606: PPUSH
85607: CALL_OW 447
85611: GO 85554
85613: POP
85614: POP
// end ;
85615: LD_VAR 0 5
85619: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
85620: LD_EXP 88
85624: NOT
85625: IFFALSE 85675
85627: GO 85629
85629: DISABLE
// begin initHack := true ;
85630: LD_ADDR_EXP 88
85634: PUSH
85635: LD_INT 1
85637: ST_TO_ADDR
// hackTanks := [ ] ;
85638: LD_ADDR_EXP 89
85642: PUSH
85643: EMPTY
85644: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
85645: LD_ADDR_EXP 90
85649: PUSH
85650: EMPTY
85651: ST_TO_ADDR
// hackLimit := 3 ;
85652: LD_ADDR_EXP 91
85656: PUSH
85657: LD_INT 3
85659: ST_TO_ADDR
// hackDist := 12 ;
85660: LD_ADDR_EXP 92
85664: PUSH
85665: LD_INT 12
85667: ST_TO_ADDR
// hackCounter := [ ] ;
85668: LD_ADDR_EXP 93
85672: PUSH
85673: EMPTY
85674: ST_TO_ADDR
// end ;
85675: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
85676: LD_EXP 88
85680: PUSH
85681: LD_INT 34
85683: PUSH
85684: LD_EXP 69
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PPUSH
85693: CALL_OW 69
85697: AND
85698: IFFALSE 85953
85700: GO 85702
85702: DISABLE
85703: LD_INT 0
85705: PPUSH
85706: PPUSH
// begin enable ;
85707: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
85708: LD_ADDR_VAR 0 1
85712: PUSH
85713: LD_INT 34
85715: PUSH
85716: LD_EXP 69
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PPUSH
85725: CALL_OW 69
85729: PUSH
85730: FOR_IN
85731: IFFALSE 85951
// begin if not i in hackTanks then
85733: LD_VAR 0 1
85737: PUSH
85738: LD_EXP 89
85742: IN
85743: NOT
85744: IFFALSE 85827
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
85746: LD_ADDR_EXP 89
85750: PUSH
85751: LD_EXP 89
85755: PPUSH
85756: LD_EXP 89
85760: PUSH
85761: LD_INT 1
85763: PLUS
85764: PPUSH
85765: LD_VAR 0 1
85769: PPUSH
85770: CALL_OW 1
85774: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
85775: LD_ADDR_EXP 90
85779: PUSH
85780: LD_EXP 90
85784: PPUSH
85785: LD_EXP 90
85789: PUSH
85790: LD_INT 1
85792: PLUS
85793: PPUSH
85794: EMPTY
85795: PPUSH
85796: CALL_OW 1
85800: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
85801: LD_ADDR_EXP 93
85805: PUSH
85806: LD_EXP 93
85810: PPUSH
85811: LD_EXP 93
85815: PUSH
85816: LD_INT 1
85818: PLUS
85819: PPUSH
85820: EMPTY
85821: PPUSH
85822: CALL_OW 1
85826: ST_TO_ADDR
// end ; if not IsOk ( i ) then
85827: LD_VAR 0 1
85831: PPUSH
85832: CALL_OW 302
85836: NOT
85837: IFFALSE 85850
// begin HackUnlinkAll ( i ) ;
85839: LD_VAR 0 1
85843: PPUSH
85844: CALL 85956 0 1
// continue ;
85848: GO 85730
// end ; HackCheckCapturedStatus ( i ) ;
85850: LD_VAR 0 1
85854: PPUSH
85855: CALL 86399 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
85859: LD_ADDR_VAR 0 2
85863: PUSH
85864: LD_INT 81
85866: PUSH
85867: LD_VAR 0 1
85871: PPUSH
85872: CALL_OW 255
85876: PUSH
85877: EMPTY
85878: LIST
85879: LIST
85880: PUSH
85881: LD_INT 33
85883: PUSH
85884: LD_INT 3
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 91
85893: PUSH
85894: LD_VAR 0 1
85898: PUSH
85899: LD_EXP 92
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: LIST
85908: PUSH
85909: LD_INT 50
85911: PUSH
85912: EMPTY
85913: LIST
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: PPUSH
85921: CALL_OW 69
85925: ST_TO_ADDR
// if not tmp then
85926: LD_VAR 0 2
85930: NOT
85931: IFFALSE 85935
// continue ;
85933: GO 85730
// HackLink ( i , tmp ) ;
85935: LD_VAR 0 1
85939: PPUSH
85940: LD_VAR 0 2
85944: PPUSH
85945: CALL 86092 0 2
// end ;
85949: GO 85730
85951: POP
85952: POP
// end ;
85953: PPOPN 2
85955: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
85956: LD_INT 0
85958: PPUSH
85959: PPUSH
85960: PPUSH
// if not hack in hackTanks then
85961: LD_VAR 0 1
85965: PUSH
85966: LD_EXP 89
85970: IN
85971: NOT
85972: IFFALSE 85976
// exit ;
85974: GO 86087
// index := GetElementIndex ( hackTanks , hack ) ;
85976: LD_ADDR_VAR 0 4
85980: PUSH
85981: LD_EXP 89
85985: PPUSH
85986: LD_VAR 0 1
85990: PPUSH
85991: CALL 13404 0 2
85995: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
85996: LD_EXP 90
86000: PUSH
86001: LD_VAR 0 4
86005: ARRAY
86006: IFFALSE 86087
// begin for i in hackTanksCaptured [ index ] do
86008: LD_ADDR_VAR 0 3
86012: PUSH
86013: LD_EXP 90
86017: PUSH
86018: LD_VAR 0 4
86022: ARRAY
86023: PUSH
86024: FOR_IN
86025: IFFALSE 86051
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
86027: LD_VAR 0 3
86031: PUSH
86032: LD_INT 1
86034: ARRAY
86035: PPUSH
86036: LD_VAR 0 3
86040: PUSH
86041: LD_INT 2
86043: ARRAY
86044: PPUSH
86045: CALL_OW 235
86049: GO 86024
86051: POP
86052: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
86053: LD_ADDR_EXP 90
86057: PUSH
86058: LD_EXP 90
86062: PPUSH
86063: LD_VAR 0 4
86067: PPUSH
86068: EMPTY
86069: PPUSH
86070: CALL_OW 1
86074: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
86075: LD_VAR 0 1
86079: PPUSH
86080: LD_INT 0
86082: PPUSH
86083: CALL_OW 505
// end ; end ;
86087: LD_VAR 0 2
86091: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
86092: LD_INT 0
86094: PPUSH
86095: PPUSH
86096: PPUSH
// if not hack in hackTanks or not vehicles then
86097: LD_VAR 0 1
86101: PUSH
86102: LD_EXP 89
86106: IN
86107: NOT
86108: PUSH
86109: LD_VAR 0 2
86113: NOT
86114: OR
86115: IFFALSE 86119
// exit ;
86117: GO 86394
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
86119: LD_ADDR_VAR 0 2
86123: PUSH
86124: LD_VAR 0 1
86128: PPUSH
86129: LD_VAR 0 2
86133: PPUSH
86134: LD_INT 1
86136: PPUSH
86137: LD_INT 1
86139: PPUSH
86140: CALL 14054 0 4
86144: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
86145: LD_ADDR_VAR 0 5
86149: PUSH
86150: LD_EXP 89
86154: PPUSH
86155: LD_VAR 0 1
86159: PPUSH
86160: CALL 13404 0 2
86164: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
86165: LD_EXP 90
86169: PUSH
86170: LD_VAR 0 5
86174: ARRAY
86175: PUSH
86176: LD_EXP 91
86180: LESS
86181: IFFALSE 86370
// begin for i := 1 to vehicles do
86183: LD_ADDR_VAR 0 4
86187: PUSH
86188: DOUBLE
86189: LD_INT 1
86191: DEC
86192: ST_TO_ADDR
86193: LD_VAR 0 2
86197: PUSH
86198: FOR_TO
86199: IFFALSE 86368
// begin if hackTanksCaptured [ index ] = hackLimit then
86201: LD_EXP 90
86205: PUSH
86206: LD_VAR 0 5
86210: ARRAY
86211: PUSH
86212: LD_EXP 91
86216: EQUAL
86217: IFFALSE 86221
// break ;
86219: GO 86368
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
86221: LD_ADDR_EXP 93
86225: PUSH
86226: LD_EXP 93
86230: PPUSH
86231: LD_VAR 0 5
86235: PPUSH
86236: LD_EXP 93
86240: PUSH
86241: LD_VAR 0 5
86245: ARRAY
86246: PUSH
86247: LD_INT 1
86249: PLUS
86250: PPUSH
86251: CALL_OW 1
86255: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
86256: LD_ADDR_EXP 90
86260: PUSH
86261: LD_EXP 90
86265: PPUSH
86266: LD_VAR 0 5
86270: PUSH
86271: LD_EXP 90
86275: PUSH
86276: LD_VAR 0 5
86280: ARRAY
86281: PUSH
86282: LD_INT 1
86284: PLUS
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PPUSH
86290: LD_VAR 0 2
86294: PUSH
86295: LD_VAR 0 4
86299: ARRAY
86300: PUSH
86301: LD_VAR 0 2
86305: PUSH
86306: LD_VAR 0 4
86310: ARRAY
86311: PPUSH
86312: CALL_OW 255
86316: PUSH
86317: EMPTY
86318: LIST
86319: LIST
86320: PPUSH
86321: CALL 13619 0 3
86325: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
86326: LD_VAR 0 2
86330: PUSH
86331: LD_VAR 0 4
86335: ARRAY
86336: PPUSH
86337: LD_VAR 0 1
86341: PPUSH
86342: CALL_OW 255
86346: PPUSH
86347: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
86351: LD_VAR 0 2
86355: PUSH
86356: LD_VAR 0 4
86360: ARRAY
86361: PPUSH
86362: CALL_OW 141
// end ;
86366: GO 86198
86368: POP
86369: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86370: LD_VAR 0 1
86374: PPUSH
86375: LD_EXP 90
86379: PUSH
86380: LD_VAR 0 5
86384: ARRAY
86385: PUSH
86386: LD_INT 0
86388: PLUS
86389: PPUSH
86390: CALL_OW 505
// end ;
86394: LD_VAR 0 3
86398: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
86399: LD_INT 0
86401: PPUSH
86402: PPUSH
86403: PPUSH
86404: PPUSH
// if not hack in hackTanks then
86405: LD_VAR 0 1
86409: PUSH
86410: LD_EXP 89
86414: IN
86415: NOT
86416: IFFALSE 86420
// exit ;
86418: GO 86660
// index := GetElementIndex ( hackTanks , hack ) ;
86420: LD_ADDR_VAR 0 4
86424: PUSH
86425: LD_EXP 89
86429: PPUSH
86430: LD_VAR 0 1
86434: PPUSH
86435: CALL 13404 0 2
86439: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
86440: LD_ADDR_VAR 0 3
86444: PUSH
86445: DOUBLE
86446: LD_EXP 90
86450: PUSH
86451: LD_VAR 0 4
86455: ARRAY
86456: INC
86457: ST_TO_ADDR
86458: LD_INT 1
86460: PUSH
86461: FOR_DOWNTO
86462: IFFALSE 86634
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
86464: LD_ADDR_VAR 0 5
86468: PUSH
86469: LD_EXP 90
86473: PUSH
86474: LD_VAR 0 4
86478: ARRAY
86479: PUSH
86480: LD_VAR 0 3
86484: ARRAY
86485: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
86486: LD_VAR 0 5
86490: PUSH
86491: LD_INT 1
86493: ARRAY
86494: PPUSH
86495: CALL_OW 302
86499: NOT
86500: PUSH
86501: LD_VAR 0 5
86505: PUSH
86506: LD_INT 1
86508: ARRAY
86509: PPUSH
86510: CALL_OW 255
86514: PUSH
86515: LD_VAR 0 1
86519: PPUSH
86520: CALL_OW 255
86524: NONEQUAL
86525: OR
86526: IFFALSE 86632
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
86528: LD_VAR 0 5
86532: PUSH
86533: LD_INT 1
86535: ARRAY
86536: PPUSH
86537: CALL_OW 305
86541: PUSH
86542: LD_VAR 0 5
86546: PUSH
86547: LD_INT 1
86549: ARRAY
86550: PPUSH
86551: CALL_OW 255
86555: PUSH
86556: LD_VAR 0 1
86560: PPUSH
86561: CALL_OW 255
86565: EQUAL
86566: AND
86567: IFFALSE 86591
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
86569: LD_VAR 0 5
86573: PUSH
86574: LD_INT 1
86576: ARRAY
86577: PPUSH
86578: LD_VAR 0 5
86582: PUSH
86583: LD_INT 2
86585: ARRAY
86586: PPUSH
86587: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
86591: LD_ADDR_EXP 90
86595: PUSH
86596: LD_EXP 90
86600: PPUSH
86601: LD_VAR 0 4
86605: PPUSH
86606: LD_EXP 90
86610: PUSH
86611: LD_VAR 0 4
86615: ARRAY
86616: PPUSH
86617: LD_VAR 0 3
86621: PPUSH
86622: CALL_OW 3
86626: PPUSH
86627: CALL_OW 1
86631: ST_TO_ADDR
// end ; end ;
86632: GO 86461
86634: POP
86635: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
86636: LD_VAR 0 1
86640: PPUSH
86641: LD_EXP 90
86645: PUSH
86646: LD_VAR 0 4
86650: ARRAY
86651: PUSH
86652: LD_INT 0
86654: PLUS
86655: PPUSH
86656: CALL_OW 505
// end ;
86660: LD_VAR 0 2
86664: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
86665: LD_INT 0
86667: PPUSH
86668: PPUSH
86669: PPUSH
86670: PPUSH
// if not hack in hackTanks then
86671: LD_VAR 0 1
86675: PUSH
86676: LD_EXP 89
86680: IN
86681: NOT
86682: IFFALSE 86686
// exit ;
86684: GO 86771
// index := GetElementIndex ( hackTanks , hack ) ;
86686: LD_ADDR_VAR 0 5
86690: PUSH
86691: LD_EXP 89
86695: PPUSH
86696: LD_VAR 0 1
86700: PPUSH
86701: CALL 13404 0 2
86705: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
86706: LD_ADDR_VAR 0 4
86710: PUSH
86711: DOUBLE
86712: LD_INT 1
86714: DEC
86715: ST_TO_ADDR
86716: LD_EXP 90
86720: PUSH
86721: LD_VAR 0 5
86725: ARRAY
86726: PUSH
86727: FOR_TO
86728: IFFALSE 86769
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
86730: LD_EXP 90
86734: PUSH
86735: LD_VAR 0 5
86739: ARRAY
86740: PUSH
86741: LD_VAR 0 4
86745: ARRAY
86746: PUSH
86747: LD_INT 1
86749: ARRAY
86750: PUSH
86751: LD_VAR 0 2
86755: EQUAL
86756: IFFALSE 86767
// KillUnit ( vehicle ) ;
86758: LD_VAR 0 2
86762: PPUSH
86763: CALL_OW 66
86767: GO 86727
86769: POP
86770: POP
// end ;
86771: LD_VAR 0 3
86775: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
86776: LD_EXP 94
86780: NOT
86781: IFFALSE 86816
86783: GO 86785
86785: DISABLE
// begin initMiner := true ;
86786: LD_ADDR_EXP 94
86790: PUSH
86791: LD_INT 1
86793: ST_TO_ADDR
// minersList := [ ] ;
86794: LD_ADDR_EXP 95
86798: PUSH
86799: EMPTY
86800: ST_TO_ADDR
// minerMinesList := [ ] ;
86801: LD_ADDR_EXP 96
86805: PUSH
86806: EMPTY
86807: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
86808: LD_ADDR_EXP 97
86812: PUSH
86813: LD_INT 5
86815: ST_TO_ADDR
// end ;
86816: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
86817: LD_EXP 94
86821: PUSH
86822: LD_INT 34
86824: PUSH
86825: LD_EXP 74
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PPUSH
86834: CALL_OW 69
86838: AND
86839: IFFALSE 87302
86841: GO 86843
86843: DISABLE
86844: LD_INT 0
86846: PPUSH
86847: PPUSH
86848: PPUSH
86849: PPUSH
// begin enable ;
86850: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
86851: LD_ADDR_VAR 0 1
86855: PUSH
86856: LD_INT 34
86858: PUSH
86859: LD_EXP 74
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PPUSH
86868: CALL_OW 69
86872: PUSH
86873: FOR_IN
86874: IFFALSE 86946
// begin if not i in minersList then
86876: LD_VAR 0 1
86880: PUSH
86881: LD_EXP 95
86885: IN
86886: NOT
86887: IFFALSE 86944
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
86889: LD_ADDR_EXP 95
86893: PUSH
86894: LD_EXP 95
86898: PPUSH
86899: LD_EXP 95
86903: PUSH
86904: LD_INT 1
86906: PLUS
86907: PPUSH
86908: LD_VAR 0 1
86912: PPUSH
86913: CALL_OW 1
86917: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
86918: LD_ADDR_EXP 96
86922: PUSH
86923: LD_EXP 96
86927: PPUSH
86928: LD_EXP 96
86932: PUSH
86933: LD_INT 1
86935: PLUS
86936: PPUSH
86937: EMPTY
86938: PPUSH
86939: CALL_OW 1
86943: ST_TO_ADDR
// end end ;
86944: GO 86873
86946: POP
86947: POP
// for i := minerMinesList downto 1 do
86948: LD_ADDR_VAR 0 1
86952: PUSH
86953: DOUBLE
86954: LD_EXP 96
86958: INC
86959: ST_TO_ADDR
86960: LD_INT 1
86962: PUSH
86963: FOR_DOWNTO
86964: IFFALSE 87300
// begin if IsLive ( minersList [ i ] ) then
86966: LD_EXP 95
86970: PUSH
86971: LD_VAR 0 1
86975: ARRAY
86976: PPUSH
86977: CALL_OW 300
86981: IFFALSE 87009
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
86983: LD_EXP 95
86987: PUSH
86988: LD_VAR 0 1
86992: ARRAY
86993: PPUSH
86994: LD_EXP 96
86998: PUSH
86999: LD_VAR 0 1
87003: ARRAY
87004: PPUSH
87005: CALL_OW 505
// if not minerMinesList [ i ] then
87009: LD_EXP 96
87013: PUSH
87014: LD_VAR 0 1
87018: ARRAY
87019: NOT
87020: IFFALSE 87024
// continue ;
87022: GO 86963
// for j := minerMinesList [ i ] downto 1 do
87024: LD_ADDR_VAR 0 2
87028: PUSH
87029: DOUBLE
87030: LD_EXP 96
87034: PUSH
87035: LD_VAR 0 1
87039: ARRAY
87040: INC
87041: ST_TO_ADDR
87042: LD_INT 1
87044: PUSH
87045: FOR_DOWNTO
87046: IFFALSE 87296
// begin side := GetSide ( minersList [ i ] ) ;
87048: LD_ADDR_VAR 0 3
87052: PUSH
87053: LD_EXP 95
87057: PUSH
87058: LD_VAR 0 1
87062: ARRAY
87063: PPUSH
87064: CALL_OW 255
87068: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
87069: LD_ADDR_VAR 0 4
87073: PUSH
87074: LD_EXP 96
87078: PUSH
87079: LD_VAR 0 1
87083: ARRAY
87084: PUSH
87085: LD_VAR 0 2
87089: ARRAY
87090: PUSH
87091: LD_INT 1
87093: ARRAY
87094: PPUSH
87095: LD_EXP 96
87099: PUSH
87100: LD_VAR 0 1
87104: ARRAY
87105: PUSH
87106: LD_VAR 0 2
87110: ARRAY
87111: PUSH
87112: LD_INT 2
87114: ARRAY
87115: PPUSH
87116: CALL_OW 428
87120: ST_TO_ADDR
// if not tmp then
87121: LD_VAR 0 4
87125: NOT
87126: IFFALSE 87130
// continue ;
87128: GO 87045
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
87130: LD_VAR 0 4
87134: PUSH
87135: LD_INT 81
87137: PUSH
87138: LD_VAR 0 3
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PPUSH
87147: CALL_OW 69
87151: IN
87152: PUSH
87153: LD_EXP 96
87157: PUSH
87158: LD_VAR 0 1
87162: ARRAY
87163: PUSH
87164: LD_VAR 0 2
87168: ARRAY
87169: PUSH
87170: LD_INT 1
87172: ARRAY
87173: PPUSH
87174: LD_EXP 96
87178: PUSH
87179: LD_VAR 0 1
87183: ARRAY
87184: PUSH
87185: LD_VAR 0 2
87189: ARRAY
87190: PUSH
87191: LD_INT 2
87193: ARRAY
87194: PPUSH
87195: CALL_OW 458
87199: AND
87200: IFFALSE 87294
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
87202: LD_EXP 96
87206: PUSH
87207: LD_VAR 0 1
87211: ARRAY
87212: PUSH
87213: LD_VAR 0 2
87217: ARRAY
87218: PUSH
87219: LD_INT 1
87221: ARRAY
87222: PPUSH
87223: LD_EXP 96
87227: PUSH
87228: LD_VAR 0 1
87232: ARRAY
87233: PUSH
87234: LD_VAR 0 2
87238: ARRAY
87239: PUSH
87240: LD_INT 2
87242: ARRAY
87243: PPUSH
87244: LD_VAR 0 3
87248: PPUSH
87249: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
87253: LD_ADDR_EXP 96
87257: PUSH
87258: LD_EXP 96
87262: PPUSH
87263: LD_VAR 0 1
87267: PPUSH
87268: LD_EXP 96
87272: PUSH
87273: LD_VAR 0 1
87277: ARRAY
87278: PPUSH
87279: LD_VAR 0 2
87283: PPUSH
87284: CALL_OW 3
87288: PPUSH
87289: CALL_OW 1
87293: ST_TO_ADDR
// end ; end ;
87294: GO 87045
87296: POP
87297: POP
// end ;
87298: GO 86963
87300: POP
87301: POP
// end ;
87302: PPOPN 4
87304: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87305: LD_INT 0
87307: PPUSH
87308: PPUSH
// result := false ;
87309: LD_ADDR_VAR 0 4
87313: PUSH
87314: LD_INT 0
87316: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
87317: LD_VAR 0 1
87321: PPUSH
87322: CALL_OW 264
87326: PUSH
87327: LD_EXP 74
87331: EQUAL
87332: NOT
87333: IFFALSE 87337
// exit ;
87335: GO 87577
// index := GetElementIndex ( minersList , unit ) ;
87337: LD_ADDR_VAR 0 5
87341: PUSH
87342: LD_EXP 95
87346: PPUSH
87347: LD_VAR 0 1
87351: PPUSH
87352: CALL 13404 0 2
87356: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
87357: LD_EXP 96
87361: PUSH
87362: LD_VAR 0 5
87366: ARRAY
87367: PUSH
87368: LD_EXP 97
87372: GREATEREQUAL
87373: IFFALSE 87377
// exit ;
87375: GO 87577
// ComMoveXY ( unit , x , y ) ;
87377: LD_VAR 0 1
87381: PPUSH
87382: LD_VAR 0 2
87386: PPUSH
87387: LD_VAR 0 3
87391: PPUSH
87392: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
87396: LD_INT 35
87398: PPUSH
87399: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
87403: LD_VAR 0 1
87407: PPUSH
87408: LD_VAR 0 2
87412: PPUSH
87413: LD_VAR 0 3
87417: PPUSH
87418: CALL 44177 0 3
87422: NOT
87423: PUSH
87424: LD_VAR 0 1
87428: PPUSH
87429: CALL_OW 314
87433: AND
87434: IFFALSE 87438
// exit ;
87436: GO 87577
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
87438: LD_VAR 0 2
87442: PPUSH
87443: LD_VAR 0 3
87447: PPUSH
87448: CALL_OW 428
87452: PUSH
87453: LD_VAR 0 1
87457: EQUAL
87458: PUSH
87459: LD_VAR 0 1
87463: PPUSH
87464: CALL_OW 314
87468: NOT
87469: AND
87470: IFFALSE 87396
// PlaySoundXY ( x , y , PlantMine ) ;
87472: LD_VAR 0 2
87476: PPUSH
87477: LD_VAR 0 3
87481: PPUSH
87482: LD_STRING PlantMine
87484: PPUSH
87485: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
87489: LD_VAR 0 2
87493: PPUSH
87494: LD_VAR 0 3
87498: PPUSH
87499: LD_VAR 0 1
87503: PPUSH
87504: CALL_OW 255
87508: PPUSH
87509: LD_INT 0
87511: PPUSH
87512: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
87516: LD_ADDR_EXP 96
87520: PUSH
87521: LD_EXP 96
87525: PPUSH
87526: LD_VAR 0 5
87530: PUSH
87531: LD_EXP 96
87535: PUSH
87536: LD_VAR 0 5
87540: ARRAY
87541: PUSH
87542: LD_INT 1
87544: PLUS
87545: PUSH
87546: EMPTY
87547: LIST
87548: LIST
87549: PPUSH
87550: LD_VAR 0 2
87554: PUSH
87555: LD_VAR 0 3
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: PPUSH
87564: CALL 13619 0 3
87568: ST_TO_ADDR
// result := true ;
87569: LD_ADDR_VAR 0 4
87573: PUSH
87574: LD_INT 1
87576: ST_TO_ADDR
// end ;
87577: LD_VAR 0 4
87581: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
87582: LD_INT 0
87584: PPUSH
87585: PPUSH
87586: PPUSH
// if not unit in minersList then
87587: LD_VAR 0 1
87591: PUSH
87592: LD_EXP 95
87596: IN
87597: NOT
87598: IFFALSE 87602
// exit ;
87600: GO 87994
// index := GetElementIndex ( minersList , unit ) ;
87602: LD_ADDR_VAR 0 6
87606: PUSH
87607: LD_EXP 95
87611: PPUSH
87612: LD_VAR 0 1
87616: PPUSH
87617: CALL 13404 0 2
87621: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
87622: LD_ADDR_VAR 0 5
87626: PUSH
87627: DOUBLE
87628: LD_EXP 96
87632: PUSH
87633: LD_VAR 0 6
87637: ARRAY
87638: INC
87639: ST_TO_ADDR
87640: LD_INT 1
87642: PUSH
87643: FOR_DOWNTO
87644: IFFALSE 87805
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
87646: LD_EXP 96
87650: PUSH
87651: LD_VAR 0 6
87655: ARRAY
87656: PUSH
87657: LD_VAR 0 5
87661: ARRAY
87662: PUSH
87663: LD_INT 1
87665: ARRAY
87666: PUSH
87667: LD_VAR 0 2
87671: EQUAL
87672: PUSH
87673: LD_EXP 96
87677: PUSH
87678: LD_VAR 0 6
87682: ARRAY
87683: PUSH
87684: LD_VAR 0 5
87688: ARRAY
87689: PUSH
87690: LD_INT 2
87692: ARRAY
87693: PUSH
87694: LD_VAR 0 3
87698: EQUAL
87699: AND
87700: IFFALSE 87803
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87702: LD_EXP 96
87706: PUSH
87707: LD_VAR 0 6
87711: ARRAY
87712: PUSH
87713: LD_VAR 0 5
87717: ARRAY
87718: PUSH
87719: LD_INT 1
87721: ARRAY
87722: PPUSH
87723: LD_EXP 96
87727: PUSH
87728: LD_VAR 0 6
87732: ARRAY
87733: PUSH
87734: LD_VAR 0 5
87738: ARRAY
87739: PUSH
87740: LD_INT 2
87742: ARRAY
87743: PPUSH
87744: LD_VAR 0 1
87748: PPUSH
87749: CALL_OW 255
87753: PPUSH
87754: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87758: LD_ADDR_EXP 96
87762: PUSH
87763: LD_EXP 96
87767: PPUSH
87768: LD_VAR 0 6
87772: PPUSH
87773: LD_EXP 96
87777: PUSH
87778: LD_VAR 0 6
87782: ARRAY
87783: PPUSH
87784: LD_VAR 0 5
87788: PPUSH
87789: CALL_OW 3
87793: PPUSH
87794: CALL_OW 1
87798: ST_TO_ADDR
// exit ;
87799: POP
87800: POP
87801: GO 87994
// end ; end ;
87803: GO 87643
87805: POP
87806: POP
// for i := minerMinesList [ index ] downto 1 do
87807: LD_ADDR_VAR 0 5
87811: PUSH
87812: DOUBLE
87813: LD_EXP 96
87817: PUSH
87818: LD_VAR 0 6
87822: ARRAY
87823: INC
87824: ST_TO_ADDR
87825: LD_INT 1
87827: PUSH
87828: FOR_DOWNTO
87829: IFFALSE 87992
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
87831: LD_EXP 96
87835: PUSH
87836: LD_VAR 0 6
87840: ARRAY
87841: PUSH
87842: LD_VAR 0 5
87846: ARRAY
87847: PUSH
87848: LD_INT 1
87850: ARRAY
87851: PPUSH
87852: LD_EXP 96
87856: PUSH
87857: LD_VAR 0 6
87861: ARRAY
87862: PUSH
87863: LD_VAR 0 5
87867: ARRAY
87868: PUSH
87869: LD_INT 2
87871: ARRAY
87872: PPUSH
87873: LD_VAR 0 2
87877: PPUSH
87878: LD_VAR 0 3
87882: PPUSH
87883: CALL_OW 298
87887: PUSH
87888: LD_INT 6
87890: LESS
87891: IFFALSE 87990
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
87893: LD_EXP 96
87897: PUSH
87898: LD_VAR 0 6
87902: ARRAY
87903: PUSH
87904: LD_VAR 0 5
87908: ARRAY
87909: PUSH
87910: LD_INT 1
87912: ARRAY
87913: PPUSH
87914: LD_EXP 96
87918: PUSH
87919: LD_VAR 0 6
87923: ARRAY
87924: PUSH
87925: LD_VAR 0 5
87929: ARRAY
87930: PUSH
87931: LD_INT 2
87933: ARRAY
87934: PPUSH
87935: LD_VAR 0 1
87939: PPUSH
87940: CALL_OW 255
87944: PPUSH
87945: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
87949: LD_ADDR_EXP 96
87953: PUSH
87954: LD_EXP 96
87958: PPUSH
87959: LD_VAR 0 6
87963: PPUSH
87964: LD_EXP 96
87968: PUSH
87969: LD_VAR 0 6
87973: ARRAY
87974: PPUSH
87975: LD_VAR 0 5
87979: PPUSH
87980: CALL_OW 3
87984: PPUSH
87985: CALL_OW 1
87989: ST_TO_ADDR
// end ; end ;
87990: GO 87828
87992: POP
87993: POP
// end ;
87994: LD_VAR 0 4
87998: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
87999: LD_INT 0
88001: PPUSH
88002: PPUSH
88003: PPUSH
88004: PPUSH
88005: PPUSH
88006: PPUSH
88007: PPUSH
88008: PPUSH
88009: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
88010: LD_VAR 0 1
88014: PPUSH
88015: CALL_OW 264
88019: PUSH
88020: LD_EXP 74
88024: EQUAL
88025: NOT
88026: PUSH
88027: LD_VAR 0 1
88031: PUSH
88032: LD_EXP 95
88036: IN
88037: NOT
88038: OR
88039: IFFALSE 88043
// exit ;
88041: GO 88365
// index := GetElementIndex ( minersList , unit ) ;
88043: LD_ADDR_VAR 0 6
88047: PUSH
88048: LD_EXP 95
88052: PPUSH
88053: LD_VAR 0 1
88057: PPUSH
88058: CALL 13404 0 2
88062: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
88063: LD_ADDR_VAR 0 8
88067: PUSH
88068: LD_EXP 97
88072: PUSH
88073: LD_EXP 96
88077: PUSH
88078: LD_VAR 0 6
88082: ARRAY
88083: MINUS
88084: ST_TO_ADDR
// if not minesFreeAmount then
88085: LD_VAR 0 8
88089: NOT
88090: IFFALSE 88094
// exit ;
88092: GO 88365
// tmp := [ ] ;
88094: LD_ADDR_VAR 0 7
88098: PUSH
88099: EMPTY
88100: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
88101: LD_ADDR_VAR 0 5
88105: PUSH
88106: DOUBLE
88107: LD_INT 1
88109: DEC
88110: ST_TO_ADDR
88111: LD_VAR 0 8
88115: PUSH
88116: FOR_TO
88117: IFFALSE 88312
// begin _d := rand ( 0 , 5 ) ;
88119: LD_ADDR_VAR 0 11
88123: PUSH
88124: LD_INT 0
88126: PPUSH
88127: LD_INT 5
88129: PPUSH
88130: CALL_OW 12
88134: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
88135: LD_ADDR_VAR 0 12
88139: PUSH
88140: LD_INT 2
88142: PPUSH
88143: LD_INT 6
88145: PPUSH
88146: CALL_OW 12
88150: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
88151: LD_ADDR_VAR 0 9
88155: PUSH
88156: LD_VAR 0 2
88160: PPUSH
88161: LD_VAR 0 11
88165: PPUSH
88166: LD_VAR 0 12
88170: PPUSH
88171: CALL_OW 272
88175: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
88176: LD_ADDR_VAR 0 10
88180: PUSH
88181: LD_VAR 0 3
88185: PPUSH
88186: LD_VAR 0 11
88190: PPUSH
88191: LD_VAR 0 12
88195: PPUSH
88196: CALL_OW 273
88200: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
88201: LD_VAR 0 9
88205: PPUSH
88206: LD_VAR 0 10
88210: PPUSH
88211: CALL_OW 488
88215: PUSH
88216: LD_VAR 0 9
88220: PUSH
88221: LD_VAR 0 10
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: PUSH
88230: LD_VAR 0 7
88234: IN
88235: NOT
88236: AND
88237: PUSH
88238: LD_VAR 0 9
88242: PPUSH
88243: LD_VAR 0 10
88247: PPUSH
88248: CALL_OW 458
88252: NOT
88253: AND
88254: IFFALSE 88296
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
88256: LD_ADDR_VAR 0 7
88260: PUSH
88261: LD_VAR 0 7
88265: PPUSH
88266: LD_VAR 0 7
88270: PUSH
88271: LD_INT 1
88273: PLUS
88274: PPUSH
88275: LD_VAR 0 9
88279: PUSH
88280: LD_VAR 0 10
88284: PUSH
88285: EMPTY
88286: LIST
88287: LIST
88288: PPUSH
88289: CALL_OW 1
88293: ST_TO_ADDR
88294: GO 88310
// i := i - 1 ;
88296: LD_ADDR_VAR 0 5
88300: PUSH
88301: LD_VAR 0 5
88305: PUSH
88306: LD_INT 1
88308: MINUS
88309: ST_TO_ADDR
// end ;
88310: GO 88116
88312: POP
88313: POP
// for i in tmp do
88314: LD_ADDR_VAR 0 5
88318: PUSH
88319: LD_VAR 0 7
88323: PUSH
88324: FOR_IN
88325: IFFALSE 88363
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
88327: LD_VAR 0 1
88331: PPUSH
88332: LD_VAR 0 5
88336: PUSH
88337: LD_INT 1
88339: ARRAY
88340: PPUSH
88341: LD_VAR 0 5
88345: PUSH
88346: LD_INT 2
88348: ARRAY
88349: PPUSH
88350: CALL 87305 0 3
88354: NOT
88355: IFFALSE 88361
// exit ;
88357: POP
88358: POP
88359: GO 88365
88361: GO 88324
88363: POP
88364: POP
// end ;
88365: LD_VAR 0 4
88369: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
88370: LD_INT 0
88372: PPUSH
88373: PPUSH
88374: PPUSH
88375: PPUSH
88376: PPUSH
88377: PPUSH
88378: PPUSH
// if not GetClass ( unit ) = class_sniper then
88379: LD_VAR 0 1
88383: PPUSH
88384: CALL_OW 257
88388: PUSH
88389: LD_INT 5
88391: EQUAL
88392: NOT
88393: IFFALSE 88397
// exit ;
88395: GO 88785
// dist := 8 ;
88397: LD_ADDR_VAR 0 5
88401: PUSH
88402: LD_INT 8
88404: ST_TO_ADDR
// viewRange := 12 ;
88405: LD_ADDR_VAR 0 7
88409: PUSH
88410: LD_INT 12
88412: ST_TO_ADDR
// side := GetSide ( unit ) ;
88413: LD_ADDR_VAR 0 6
88417: PUSH
88418: LD_VAR 0 1
88422: PPUSH
88423: CALL_OW 255
88427: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
88428: LD_INT 61
88430: PPUSH
88431: LD_VAR 0 6
88435: PPUSH
88436: CALL_OW 321
88440: PUSH
88441: LD_INT 2
88443: EQUAL
88444: IFFALSE 88454
// viewRange := 16 ;
88446: LD_ADDR_VAR 0 7
88450: PUSH
88451: LD_INT 16
88453: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
88454: LD_VAR 0 1
88458: PPUSH
88459: LD_VAR 0 2
88463: PPUSH
88464: LD_VAR 0 3
88468: PPUSH
88469: CALL_OW 297
88473: PUSH
88474: LD_VAR 0 5
88478: GREATER
88479: IFFALSE 88558
// begin ComMoveXY ( unit , x , y ) ;
88481: LD_VAR 0 1
88485: PPUSH
88486: LD_VAR 0 2
88490: PPUSH
88491: LD_VAR 0 3
88495: PPUSH
88496: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88500: LD_INT 35
88502: PPUSH
88503: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
88507: LD_VAR 0 1
88511: PPUSH
88512: LD_VAR 0 2
88516: PPUSH
88517: LD_VAR 0 3
88521: PPUSH
88522: CALL 44177 0 3
88526: NOT
88527: IFFALSE 88531
// exit ;
88529: GO 88785
// until GetDistUnitXY ( unit , x , y ) < dist ;
88531: LD_VAR 0 1
88535: PPUSH
88536: LD_VAR 0 2
88540: PPUSH
88541: LD_VAR 0 3
88545: PPUSH
88546: CALL_OW 297
88550: PUSH
88551: LD_VAR 0 5
88555: LESS
88556: IFFALSE 88500
// end ; ComTurnXY ( unit , x , y ) ;
88558: LD_VAR 0 1
88562: PPUSH
88563: LD_VAR 0 2
88567: PPUSH
88568: LD_VAR 0 3
88572: PPUSH
88573: CALL_OW 118
// wait ( 5 ) ;
88577: LD_INT 5
88579: PPUSH
88580: CALL_OW 67
// _d := GetDir ( unit ) ;
88584: LD_ADDR_VAR 0 10
88588: PUSH
88589: LD_VAR 0 1
88593: PPUSH
88594: CALL_OW 254
88598: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
88599: LD_ADDR_VAR 0 8
88603: PUSH
88604: LD_VAR 0 1
88608: PPUSH
88609: CALL_OW 250
88613: PPUSH
88614: LD_VAR 0 10
88618: PPUSH
88619: LD_VAR 0 5
88623: PPUSH
88624: CALL_OW 272
88628: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
88629: LD_ADDR_VAR 0 9
88633: PUSH
88634: LD_VAR 0 1
88638: PPUSH
88639: CALL_OW 251
88643: PPUSH
88644: LD_VAR 0 10
88648: PPUSH
88649: LD_VAR 0 5
88653: PPUSH
88654: CALL_OW 273
88658: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88659: LD_VAR 0 8
88663: PPUSH
88664: LD_VAR 0 9
88668: PPUSH
88669: CALL_OW 488
88673: NOT
88674: IFFALSE 88678
// exit ;
88676: GO 88785
// ComAnimCustom ( unit , 1 ) ;
88678: LD_VAR 0 1
88682: PPUSH
88683: LD_INT 1
88685: PPUSH
88686: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
88690: LD_VAR 0 8
88694: PPUSH
88695: LD_VAR 0 9
88699: PPUSH
88700: LD_VAR 0 6
88704: PPUSH
88705: LD_VAR 0 7
88709: PPUSH
88710: CALL_OW 330
// repeat wait ( 1 ) ;
88714: LD_INT 1
88716: PPUSH
88717: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
88721: LD_VAR 0 1
88725: PPUSH
88726: CALL_OW 316
88730: PUSH
88731: LD_VAR 0 1
88735: PPUSH
88736: CALL_OW 314
88740: OR
88741: PUSH
88742: LD_VAR 0 1
88746: PPUSH
88747: CALL_OW 302
88751: NOT
88752: OR
88753: PUSH
88754: LD_VAR 0 1
88758: PPUSH
88759: CALL_OW 301
88763: OR
88764: IFFALSE 88714
// RemoveSeeing ( _x , _y , side ) ;
88766: LD_VAR 0 8
88770: PPUSH
88771: LD_VAR 0 9
88775: PPUSH
88776: LD_VAR 0 6
88780: PPUSH
88781: CALL_OW 331
// end ; end_of_file end_of_file
88785: LD_VAR 0 4
88789: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
88790: LD_VAR 0 1
88794: PUSH
88795: LD_INT 200
88797: DOUBLE
88798: GREATEREQUAL
88799: IFFALSE 88807
88801: LD_INT 299
88803: DOUBLE
88804: LESSEQUAL
88805: IFTRUE 88809
88807: GO 88841
88809: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
88810: LD_VAR 0 1
88814: PPUSH
88815: LD_VAR 0 2
88819: PPUSH
88820: LD_VAR 0 3
88824: PPUSH
88825: LD_VAR 0 4
88829: PPUSH
88830: LD_VAR 0 5
88834: PPUSH
88835: CALL 84907 0 5
88839: GO 88918
88841: LD_INT 300
88843: DOUBLE
88844: GREATEREQUAL
88845: IFFALSE 88853
88847: LD_INT 399
88849: DOUBLE
88850: LESSEQUAL
88851: IFTRUE 88855
88853: GO 88917
88855: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
88856: LD_VAR 0 1
88860: PPUSH
88861: LD_VAR 0 2
88865: PPUSH
88866: LD_VAR 0 3
88870: PPUSH
88871: LD_VAR 0 4
88875: PPUSH
88876: LD_VAR 0 5
88880: PPUSH
88881: LD_VAR 0 6
88885: PPUSH
88886: LD_VAR 0 7
88890: PPUSH
88891: LD_VAR 0 8
88895: PPUSH
88896: LD_VAR 0 9
88900: PPUSH
88901: LD_VAR 0 10
88905: PPUSH
88906: LD_VAR 0 11
88910: PPUSH
88911: CALL 100145 0 11
88915: GO 88918
88917: POP
// end ;
88918: PPOPN 11
88920: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
88921: LD_VAR 0 1
88925: PPUSH
88926: LD_VAR 0 2
88930: PPUSH
88931: LD_VAR 0 3
88935: PPUSH
88936: LD_VAR 0 4
88940: PPUSH
88941: LD_VAR 0 5
88945: PPUSH
88946: CALL 84889 0 5
// end ; end_of_file
88950: PPOPN 5
88952: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
88953: LD_INT 0
88955: PPUSH
// if p2 = 100 then
88956: LD_VAR 0 2
88960: PUSH
88961: LD_INT 100
88963: EQUAL
88964: IFFALSE 89913
// begin if not StreamModeActive then
88966: LD_EXP 98
88970: NOT
88971: IFFALSE 88981
// StreamModeActive := true ;
88973: LD_ADDR_EXP 98
88977: PUSH
88978: LD_INT 1
88980: ST_TO_ADDR
// if p3 = 0 then
88981: LD_VAR 0 3
88985: PUSH
88986: LD_INT 0
88988: EQUAL
88989: IFFALSE 88995
// InitStreamMode ;
88991: CALL 90073 0 0
// if p3 = 1 then
88995: LD_VAR 0 3
88999: PUSH
89000: LD_INT 1
89002: EQUAL
89003: IFFALSE 89013
// sRocket := true ;
89005: LD_ADDR_EXP 103
89009: PUSH
89010: LD_INT 1
89012: ST_TO_ADDR
// if p3 = 2 then
89013: LD_VAR 0 3
89017: PUSH
89018: LD_INT 2
89020: EQUAL
89021: IFFALSE 89031
// sSpeed := true ;
89023: LD_ADDR_EXP 102
89027: PUSH
89028: LD_INT 1
89030: ST_TO_ADDR
// if p3 = 3 then
89031: LD_VAR 0 3
89035: PUSH
89036: LD_INT 3
89038: EQUAL
89039: IFFALSE 89049
// sEngine := true ;
89041: LD_ADDR_EXP 104
89045: PUSH
89046: LD_INT 1
89048: ST_TO_ADDR
// if p3 = 4 then
89049: LD_VAR 0 3
89053: PUSH
89054: LD_INT 4
89056: EQUAL
89057: IFFALSE 89067
// sSpec := true ;
89059: LD_ADDR_EXP 101
89063: PUSH
89064: LD_INT 1
89066: ST_TO_ADDR
// if p3 = 5 then
89067: LD_VAR 0 3
89071: PUSH
89072: LD_INT 5
89074: EQUAL
89075: IFFALSE 89085
// sLevel := true ;
89077: LD_ADDR_EXP 105
89081: PUSH
89082: LD_INT 1
89084: ST_TO_ADDR
// if p3 = 6 then
89085: LD_VAR 0 3
89089: PUSH
89090: LD_INT 6
89092: EQUAL
89093: IFFALSE 89103
// sArmoury := true ;
89095: LD_ADDR_EXP 106
89099: PUSH
89100: LD_INT 1
89102: ST_TO_ADDR
// if p3 = 7 then
89103: LD_VAR 0 3
89107: PUSH
89108: LD_INT 7
89110: EQUAL
89111: IFFALSE 89121
// sRadar := true ;
89113: LD_ADDR_EXP 107
89117: PUSH
89118: LD_INT 1
89120: ST_TO_ADDR
// if p3 = 8 then
89121: LD_VAR 0 3
89125: PUSH
89126: LD_INT 8
89128: EQUAL
89129: IFFALSE 89139
// sBunker := true ;
89131: LD_ADDR_EXP 108
89135: PUSH
89136: LD_INT 1
89138: ST_TO_ADDR
// if p3 = 9 then
89139: LD_VAR 0 3
89143: PUSH
89144: LD_INT 9
89146: EQUAL
89147: IFFALSE 89157
// sHack := true ;
89149: LD_ADDR_EXP 109
89153: PUSH
89154: LD_INT 1
89156: ST_TO_ADDR
// if p3 = 10 then
89157: LD_VAR 0 3
89161: PUSH
89162: LD_INT 10
89164: EQUAL
89165: IFFALSE 89175
// sFire := true ;
89167: LD_ADDR_EXP 110
89171: PUSH
89172: LD_INT 1
89174: ST_TO_ADDR
// if p3 = 11 then
89175: LD_VAR 0 3
89179: PUSH
89180: LD_INT 11
89182: EQUAL
89183: IFFALSE 89193
// sRefresh := true ;
89185: LD_ADDR_EXP 111
89189: PUSH
89190: LD_INT 1
89192: ST_TO_ADDR
// if p3 = 12 then
89193: LD_VAR 0 3
89197: PUSH
89198: LD_INT 12
89200: EQUAL
89201: IFFALSE 89211
// sExp := true ;
89203: LD_ADDR_EXP 112
89207: PUSH
89208: LD_INT 1
89210: ST_TO_ADDR
// if p3 = 13 then
89211: LD_VAR 0 3
89215: PUSH
89216: LD_INT 13
89218: EQUAL
89219: IFFALSE 89229
// sDepot := true ;
89221: LD_ADDR_EXP 113
89225: PUSH
89226: LD_INT 1
89228: ST_TO_ADDR
// if p3 = 14 then
89229: LD_VAR 0 3
89233: PUSH
89234: LD_INT 14
89236: EQUAL
89237: IFFALSE 89247
// sFlag := true ;
89239: LD_ADDR_EXP 114
89243: PUSH
89244: LD_INT 1
89246: ST_TO_ADDR
// if p3 = 15 then
89247: LD_VAR 0 3
89251: PUSH
89252: LD_INT 15
89254: EQUAL
89255: IFFALSE 89265
// sKamikadze := true ;
89257: LD_ADDR_EXP 122
89261: PUSH
89262: LD_INT 1
89264: ST_TO_ADDR
// if p3 = 16 then
89265: LD_VAR 0 3
89269: PUSH
89270: LD_INT 16
89272: EQUAL
89273: IFFALSE 89283
// sTroll := true ;
89275: LD_ADDR_EXP 123
89279: PUSH
89280: LD_INT 1
89282: ST_TO_ADDR
// if p3 = 17 then
89283: LD_VAR 0 3
89287: PUSH
89288: LD_INT 17
89290: EQUAL
89291: IFFALSE 89301
// sSlow := true ;
89293: LD_ADDR_EXP 124
89297: PUSH
89298: LD_INT 1
89300: ST_TO_ADDR
// if p3 = 18 then
89301: LD_VAR 0 3
89305: PUSH
89306: LD_INT 18
89308: EQUAL
89309: IFFALSE 89319
// sLack := true ;
89311: LD_ADDR_EXP 125
89315: PUSH
89316: LD_INT 1
89318: ST_TO_ADDR
// if p3 = 19 then
89319: LD_VAR 0 3
89323: PUSH
89324: LD_INT 19
89326: EQUAL
89327: IFFALSE 89337
// sTank := true ;
89329: LD_ADDR_EXP 127
89333: PUSH
89334: LD_INT 1
89336: ST_TO_ADDR
// if p3 = 20 then
89337: LD_VAR 0 3
89341: PUSH
89342: LD_INT 20
89344: EQUAL
89345: IFFALSE 89355
// sRemote := true ;
89347: LD_ADDR_EXP 128
89351: PUSH
89352: LD_INT 1
89354: ST_TO_ADDR
// if p3 = 21 then
89355: LD_VAR 0 3
89359: PUSH
89360: LD_INT 21
89362: EQUAL
89363: IFFALSE 89373
// sPowell := true ;
89365: LD_ADDR_EXP 129
89369: PUSH
89370: LD_INT 1
89372: ST_TO_ADDR
// if p3 = 22 then
89373: LD_VAR 0 3
89377: PUSH
89378: LD_INT 22
89380: EQUAL
89381: IFFALSE 89391
// sTeleport := true ;
89383: LD_ADDR_EXP 132
89387: PUSH
89388: LD_INT 1
89390: ST_TO_ADDR
// if p3 = 23 then
89391: LD_VAR 0 3
89395: PUSH
89396: LD_INT 23
89398: EQUAL
89399: IFFALSE 89409
// sOilTower := true ;
89401: LD_ADDR_EXP 134
89405: PUSH
89406: LD_INT 1
89408: ST_TO_ADDR
// if p3 = 24 then
89409: LD_VAR 0 3
89413: PUSH
89414: LD_INT 24
89416: EQUAL
89417: IFFALSE 89427
// sShovel := true ;
89419: LD_ADDR_EXP 135
89423: PUSH
89424: LD_INT 1
89426: ST_TO_ADDR
// if p3 = 25 then
89427: LD_VAR 0 3
89431: PUSH
89432: LD_INT 25
89434: EQUAL
89435: IFFALSE 89445
// sSheik := true ;
89437: LD_ADDR_EXP 136
89441: PUSH
89442: LD_INT 1
89444: ST_TO_ADDR
// if p3 = 26 then
89445: LD_VAR 0 3
89449: PUSH
89450: LD_INT 26
89452: EQUAL
89453: IFFALSE 89463
// sEarthquake := true ;
89455: LD_ADDR_EXP 138
89459: PUSH
89460: LD_INT 1
89462: ST_TO_ADDR
// if p3 = 27 then
89463: LD_VAR 0 3
89467: PUSH
89468: LD_INT 27
89470: EQUAL
89471: IFFALSE 89481
// sAI := true ;
89473: LD_ADDR_EXP 139
89477: PUSH
89478: LD_INT 1
89480: ST_TO_ADDR
// if p3 = 28 then
89481: LD_VAR 0 3
89485: PUSH
89486: LD_INT 28
89488: EQUAL
89489: IFFALSE 89499
// sCargo := true ;
89491: LD_ADDR_EXP 142
89495: PUSH
89496: LD_INT 1
89498: ST_TO_ADDR
// if p3 = 29 then
89499: LD_VAR 0 3
89503: PUSH
89504: LD_INT 29
89506: EQUAL
89507: IFFALSE 89517
// sDLaser := true ;
89509: LD_ADDR_EXP 143
89513: PUSH
89514: LD_INT 1
89516: ST_TO_ADDR
// if p3 = 30 then
89517: LD_VAR 0 3
89521: PUSH
89522: LD_INT 30
89524: EQUAL
89525: IFFALSE 89535
// sExchange := true ;
89527: LD_ADDR_EXP 144
89531: PUSH
89532: LD_INT 1
89534: ST_TO_ADDR
// if p3 = 31 then
89535: LD_VAR 0 3
89539: PUSH
89540: LD_INT 31
89542: EQUAL
89543: IFFALSE 89553
// sFac := true ;
89545: LD_ADDR_EXP 145
89549: PUSH
89550: LD_INT 1
89552: ST_TO_ADDR
// if p3 = 32 then
89553: LD_VAR 0 3
89557: PUSH
89558: LD_INT 32
89560: EQUAL
89561: IFFALSE 89571
// sPower := true ;
89563: LD_ADDR_EXP 146
89567: PUSH
89568: LD_INT 1
89570: ST_TO_ADDR
// if p3 = 33 then
89571: LD_VAR 0 3
89575: PUSH
89576: LD_INT 33
89578: EQUAL
89579: IFFALSE 89589
// sRandom := true ;
89581: LD_ADDR_EXP 147
89585: PUSH
89586: LD_INT 1
89588: ST_TO_ADDR
// if p3 = 34 then
89589: LD_VAR 0 3
89593: PUSH
89594: LD_INT 34
89596: EQUAL
89597: IFFALSE 89607
// sShield := true ;
89599: LD_ADDR_EXP 148
89603: PUSH
89604: LD_INT 1
89606: ST_TO_ADDR
// if p3 = 35 then
89607: LD_VAR 0 3
89611: PUSH
89612: LD_INT 35
89614: EQUAL
89615: IFFALSE 89625
// sTime := true ;
89617: LD_ADDR_EXP 149
89621: PUSH
89622: LD_INT 1
89624: ST_TO_ADDR
// if p3 = 36 then
89625: LD_VAR 0 3
89629: PUSH
89630: LD_INT 36
89632: EQUAL
89633: IFFALSE 89643
// sTools := true ;
89635: LD_ADDR_EXP 150
89639: PUSH
89640: LD_INT 1
89642: ST_TO_ADDR
// if p3 = 101 then
89643: LD_VAR 0 3
89647: PUSH
89648: LD_INT 101
89650: EQUAL
89651: IFFALSE 89661
// sSold := true ;
89653: LD_ADDR_EXP 115
89657: PUSH
89658: LD_INT 1
89660: ST_TO_ADDR
// if p3 = 102 then
89661: LD_VAR 0 3
89665: PUSH
89666: LD_INT 102
89668: EQUAL
89669: IFFALSE 89679
// sDiff := true ;
89671: LD_ADDR_EXP 116
89675: PUSH
89676: LD_INT 1
89678: ST_TO_ADDR
// if p3 = 103 then
89679: LD_VAR 0 3
89683: PUSH
89684: LD_INT 103
89686: EQUAL
89687: IFFALSE 89697
// sFog := true ;
89689: LD_ADDR_EXP 119
89693: PUSH
89694: LD_INT 1
89696: ST_TO_ADDR
// if p3 = 104 then
89697: LD_VAR 0 3
89701: PUSH
89702: LD_INT 104
89704: EQUAL
89705: IFFALSE 89715
// sReset := true ;
89707: LD_ADDR_EXP 120
89711: PUSH
89712: LD_INT 1
89714: ST_TO_ADDR
// if p3 = 105 then
89715: LD_VAR 0 3
89719: PUSH
89720: LD_INT 105
89722: EQUAL
89723: IFFALSE 89733
// sSun := true ;
89725: LD_ADDR_EXP 121
89729: PUSH
89730: LD_INT 1
89732: ST_TO_ADDR
// if p3 = 106 then
89733: LD_VAR 0 3
89737: PUSH
89738: LD_INT 106
89740: EQUAL
89741: IFFALSE 89751
// sTiger := true ;
89743: LD_ADDR_EXP 117
89747: PUSH
89748: LD_INT 1
89750: ST_TO_ADDR
// if p3 = 107 then
89751: LD_VAR 0 3
89755: PUSH
89756: LD_INT 107
89758: EQUAL
89759: IFFALSE 89769
// sBomb := true ;
89761: LD_ADDR_EXP 118
89765: PUSH
89766: LD_INT 1
89768: ST_TO_ADDR
// if p3 = 108 then
89769: LD_VAR 0 3
89773: PUSH
89774: LD_INT 108
89776: EQUAL
89777: IFFALSE 89787
// sWound := true ;
89779: LD_ADDR_EXP 126
89783: PUSH
89784: LD_INT 1
89786: ST_TO_ADDR
// if p3 = 109 then
89787: LD_VAR 0 3
89791: PUSH
89792: LD_INT 109
89794: EQUAL
89795: IFFALSE 89805
// sBetray := true ;
89797: LD_ADDR_EXP 130
89801: PUSH
89802: LD_INT 1
89804: ST_TO_ADDR
// if p3 = 110 then
89805: LD_VAR 0 3
89809: PUSH
89810: LD_INT 110
89812: EQUAL
89813: IFFALSE 89823
// sContamin := true ;
89815: LD_ADDR_EXP 131
89819: PUSH
89820: LD_INT 1
89822: ST_TO_ADDR
// if p3 = 111 then
89823: LD_VAR 0 3
89827: PUSH
89828: LD_INT 111
89830: EQUAL
89831: IFFALSE 89841
// sOil := true ;
89833: LD_ADDR_EXP 133
89837: PUSH
89838: LD_INT 1
89840: ST_TO_ADDR
// if p3 = 112 then
89841: LD_VAR 0 3
89845: PUSH
89846: LD_INT 112
89848: EQUAL
89849: IFFALSE 89859
// sStu := true ;
89851: LD_ADDR_EXP 137
89855: PUSH
89856: LD_INT 1
89858: ST_TO_ADDR
// if p3 = 113 then
89859: LD_VAR 0 3
89863: PUSH
89864: LD_INT 113
89866: EQUAL
89867: IFFALSE 89877
// sBazooka := true ;
89869: LD_ADDR_EXP 140
89873: PUSH
89874: LD_INT 1
89876: ST_TO_ADDR
// if p3 = 114 then
89877: LD_VAR 0 3
89881: PUSH
89882: LD_INT 114
89884: EQUAL
89885: IFFALSE 89895
// sMortar := true ;
89887: LD_ADDR_EXP 141
89891: PUSH
89892: LD_INT 1
89894: ST_TO_ADDR
// if p3 = 115 then
89895: LD_VAR 0 3
89899: PUSH
89900: LD_INT 115
89902: EQUAL
89903: IFFALSE 89913
// sRanger := true ;
89905: LD_ADDR_EXP 151
89909: PUSH
89910: LD_INT 1
89912: ST_TO_ADDR
// end ; if p2 = 101 then
89913: LD_VAR 0 2
89917: PUSH
89918: LD_INT 101
89920: EQUAL
89921: IFFALSE 90049
// begin case p3 of 1 :
89923: LD_VAR 0 3
89927: PUSH
89928: LD_INT 1
89930: DOUBLE
89931: EQUAL
89932: IFTRUE 89936
89934: GO 89943
89936: POP
// hHackUnlimitedResources ; 2 :
89937: CALL 101086 0 0
89941: GO 90049
89943: LD_INT 2
89945: DOUBLE
89946: EQUAL
89947: IFTRUE 89951
89949: GO 89958
89951: POP
// hHackSetLevel10 ; 3 :
89952: CALL 101219 0 0
89956: GO 90049
89958: LD_INT 3
89960: DOUBLE
89961: EQUAL
89962: IFTRUE 89966
89964: GO 89973
89966: POP
// hHackSetLevel10YourUnits ; 4 :
89967: CALL 101304 0 0
89971: GO 90049
89973: LD_INT 4
89975: DOUBLE
89976: EQUAL
89977: IFTRUE 89981
89979: GO 89988
89981: POP
// hHackInvincible ; 5 :
89982: CALL 101752 0 0
89986: GO 90049
89988: LD_INT 5
89990: DOUBLE
89991: EQUAL
89992: IFTRUE 89996
89994: GO 90003
89996: POP
// hHackInvisible ; 6 :
89997: CALL 101863 0 0
90001: GO 90049
90003: LD_INT 6
90005: DOUBLE
90006: EQUAL
90007: IFTRUE 90011
90009: GO 90018
90011: POP
// hHackChangeYourSide ; 7 :
90012: CALL 101920 0 0
90016: GO 90049
90018: LD_INT 7
90020: DOUBLE
90021: EQUAL
90022: IFTRUE 90026
90024: GO 90033
90026: POP
// hHackChangeUnitSide ; 8 :
90027: CALL 101962 0 0
90031: GO 90049
90033: LD_INT 8
90035: DOUBLE
90036: EQUAL
90037: IFTRUE 90041
90039: GO 90048
90041: POP
// hHackFog ; end ;
90042: CALL 102063 0 0
90046: GO 90049
90048: POP
// end ; end ;
90049: LD_VAR 0 7
90053: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
90054: GO 90056
90056: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90057: LD_STRING initStreamRollete();
90059: PPUSH
90060: CALL_OW 559
// InitStreamMode ;
90064: CALL 90073 0 0
// DefineStreamItems ( ) ;
90068: CALL 90513 0 0
// end ;
90072: END
// function InitStreamMode ; begin
90073: LD_INT 0
90075: PPUSH
// streamModeActive := false ;
90076: LD_ADDR_EXP 98
90080: PUSH
90081: LD_INT 0
90083: ST_TO_ADDR
// normalCounter := 36 ;
90084: LD_ADDR_EXP 99
90088: PUSH
90089: LD_INT 36
90091: ST_TO_ADDR
// hardcoreCounter := 16 ;
90092: LD_ADDR_EXP 100
90096: PUSH
90097: LD_INT 16
90099: ST_TO_ADDR
// sRocket := false ;
90100: LD_ADDR_EXP 103
90104: PUSH
90105: LD_INT 0
90107: ST_TO_ADDR
// sSpeed := false ;
90108: LD_ADDR_EXP 102
90112: PUSH
90113: LD_INT 0
90115: ST_TO_ADDR
// sEngine := false ;
90116: LD_ADDR_EXP 104
90120: PUSH
90121: LD_INT 0
90123: ST_TO_ADDR
// sSpec := false ;
90124: LD_ADDR_EXP 101
90128: PUSH
90129: LD_INT 0
90131: ST_TO_ADDR
// sLevel := false ;
90132: LD_ADDR_EXP 105
90136: PUSH
90137: LD_INT 0
90139: ST_TO_ADDR
// sArmoury := false ;
90140: LD_ADDR_EXP 106
90144: PUSH
90145: LD_INT 0
90147: ST_TO_ADDR
// sRadar := false ;
90148: LD_ADDR_EXP 107
90152: PUSH
90153: LD_INT 0
90155: ST_TO_ADDR
// sBunker := false ;
90156: LD_ADDR_EXP 108
90160: PUSH
90161: LD_INT 0
90163: ST_TO_ADDR
// sHack := false ;
90164: LD_ADDR_EXP 109
90168: PUSH
90169: LD_INT 0
90171: ST_TO_ADDR
// sFire := false ;
90172: LD_ADDR_EXP 110
90176: PUSH
90177: LD_INT 0
90179: ST_TO_ADDR
// sRefresh := false ;
90180: LD_ADDR_EXP 111
90184: PUSH
90185: LD_INT 0
90187: ST_TO_ADDR
// sExp := false ;
90188: LD_ADDR_EXP 112
90192: PUSH
90193: LD_INT 0
90195: ST_TO_ADDR
// sDepot := false ;
90196: LD_ADDR_EXP 113
90200: PUSH
90201: LD_INT 0
90203: ST_TO_ADDR
// sFlag := false ;
90204: LD_ADDR_EXP 114
90208: PUSH
90209: LD_INT 0
90211: ST_TO_ADDR
// sKamikadze := false ;
90212: LD_ADDR_EXP 122
90216: PUSH
90217: LD_INT 0
90219: ST_TO_ADDR
// sTroll := false ;
90220: LD_ADDR_EXP 123
90224: PUSH
90225: LD_INT 0
90227: ST_TO_ADDR
// sSlow := false ;
90228: LD_ADDR_EXP 124
90232: PUSH
90233: LD_INT 0
90235: ST_TO_ADDR
// sLack := false ;
90236: LD_ADDR_EXP 125
90240: PUSH
90241: LD_INT 0
90243: ST_TO_ADDR
// sTank := false ;
90244: LD_ADDR_EXP 127
90248: PUSH
90249: LD_INT 0
90251: ST_TO_ADDR
// sRemote := false ;
90252: LD_ADDR_EXP 128
90256: PUSH
90257: LD_INT 0
90259: ST_TO_ADDR
// sPowell := false ;
90260: LD_ADDR_EXP 129
90264: PUSH
90265: LD_INT 0
90267: ST_TO_ADDR
// sTeleport := false ;
90268: LD_ADDR_EXP 132
90272: PUSH
90273: LD_INT 0
90275: ST_TO_ADDR
// sOilTower := false ;
90276: LD_ADDR_EXP 134
90280: PUSH
90281: LD_INT 0
90283: ST_TO_ADDR
// sShovel := false ;
90284: LD_ADDR_EXP 135
90288: PUSH
90289: LD_INT 0
90291: ST_TO_ADDR
// sSheik := false ;
90292: LD_ADDR_EXP 136
90296: PUSH
90297: LD_INT 0
90299: ST_TO_ADDR
// sEarthquake := false ;
90300: LD_ADDR_EXP 138
90304: PUSH
90305: LD_INT 0
90307: ST_TO_ADDR
// sAI := false ;
90308: LD_ADDR_EXP 139
90312: PUSH
90313: LD_INT 0
90315: ST_TO_ADDR
// sCargo := false ;
90316: LD_ADDR_EXP 142
90320: PUSH
90321: LD_INT 0
90323: ST_TO_ADDR
// sDLaser := false ;
90324: LD_ADDR_EXP 143
90328: PUSH
90329: LD_INT 0
90331: ST_TO_ADDR
// sExchange := false ;
90332: LD_ADDR_EXP 144
90336: PUSH
90337: LD_INT 0
90339: ST_TO_ADDR
// sFac := false ;
90340: LD_ADDR_EXP 145
90344: PUSH
90345: LD_INT 0
90347: ST_TO_ADDR
// sPower := false ;
90348: LD_ADDR_EXP 146
90352: PUSH
90353: LD_INT 0
90355: ST_TO_ADDR
// sRandom := false ;
90356: LD_ADDR_EXP 147
90360: PUSH
90361: LD_INT 0
90363: ST_TO_ADDR
// sShield := false ;
90364: LD_ADDR_EXP 148
90368: PUSH
90369: LD_INT 0
90371: ST_TO_ADDR
// sTime := false ;
90372: LD_ADDR_EXP 149
90376: PUSH
90377: LD_INT 0
90379: ST_TO_ADDR
// sTools := false ;
90380: LD_ADDR_EXP 150
90384: PUSH
90385: LD_INT 0
90387: ST_TO_ADDR
// sSold := false ;
90388: LD_ADDR_EXP 115
90392: PUSH
90393: LD_INT 0
90395: ST_TO_ADDR
// sDiff := false ;
90396: LD_ADDR_EXP 116
90400: PUSH
90401: LD_INT 0
90403: ST_TO_ADDR
// sFog := false ;
90404: LD_ADDR_EXP 119
90408: PUSH
90409: LD_INT 0
90411: ST_TO_ADDR
// sReset := false ;
90412: LD_ADDR_EXP 120
90416: PUSH
90417: LD_INT 0
90419: ST_TO_ADDR
// sSun := false ;
90420: LD_ADDR_EXP 121
90424: PUSH
90425: LD_INT 0
90427: ST_TO_ADDR
// sTiger := false ;
90428: LD_ADDR_EXP 117
90432: PUSH
90433: LD_INT 0
90435: ST_TO_ADDR
// sBomb := false ;
90436: LD_ADDR_EXP 118
90440: PUSH
90441: LD_INT 0
90443: ST_TO_ADDR
// sWound := false ;
90444: LD_ADDR_EXP 126
90448: PUSH
90449: LD_INT 0
90451: ST_TO_ADDR
// sBetray := false ;
90452: LD_ADDR_EXP 130
90456: PUSH
90457: LD_INT 0
90459: ST_TO_ADDR
// sContamin := false ;
90460: LD_ADDR_EXP 131
90464: PUSH
90465: LD_INT 0
90467: ST_TO_ADDR
// sOil := false ;
90468: LD_ADDR_EXP 133
90472: PUSH
90473: LD_INT 0
90475: ST_TO_ADDR
// sStu := false ;
90476: LD_ADDR_EXP 137
90480: PUSH
90481: LD_INT 0
90483: ST_TO_ADDR
// sBazooka := false ;
90484: LD_ADDR_EXP 140
90488: PUSH
90489: LD_INT 0
90491: ST_TO_ADDR
// sMortar := false ;
90492: LD_ADDR_EXP 141
90496: PUSH
90497: LD_INT 0
90499: ST_TO_ADDR
// sRanger := false ;
90500: LD_ADDR_EXP 151
90504: PUSH
90505: LD_INT 0
90507: ST_TO_ADDR
// end ;
90508: LD_VAR 0 1
90512: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
90513: LD_INT 0
90515: PPUSH
90516: PPUSH
90517: PPUSH
90518: PPUSH
90519: PPUSH
// result := [ ] ;
90520: LD_ADDR_VAR 0 1
90524: PUSH
90525: EMPTY
90526: ST_TO_ADDR
// if campaign_id = 1 then
90527: LD_OWVAR 69
90531: PUSH
90532: LD_INT 1
90534: EQUAL
90535: IFFALSE 93473
// begin case mission_number of 1 :
90537: LD_OWVAR 70
90541: PUSH
90542: LD_INT 1
90544: DOUBLE
90545: EQUAL
90546: IFTRUE 90550
90548: GO 90614
90550: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
90551: LD_ADDR_VAR 0 1
90555: PUSH
90556: LD_INT 2
90558: PUSH
90559: LD_INT 4
90561: PUSH
90562: LD_INT 11
90564: PUSH
90565: LD_INT 12
90567: PUSH
90568: LD_INT 15
90570: PUSH
90571: LD_INT 16
90573: PUSH
90574: LD_INT 22
90576: PUSH
90577: LD_INT 23
90579: PUSH
90580: LD_INT 26
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 101
90596: PUSH
90597: LD_INT 102
90599: PUSH
90600: LD_INT 106
90602: PUSH
90603: EMPTY
90604: LIST
90605: LIST
90606: LIST
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: ST_TO_ADDR
90612: GO 93471
90614: LD_INT 2
90616: DOUBLE
90617: EQUAL
90618: IFTRUE 90622
90620: GO 90694
90622: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
90623: LD_ADDR_VAR 0 1
90627: PUSH
90628: LD_INT 2
90630: PUSH
90631: LD_INT 4
90633: PUSH
90634: LD_INT 11
90636: PUSH
90637: LD_INT 12
90639: PUSH
90640: LD_INT 15
90642: PUSH
90643: LD_INT 16
90645: PUSH
90646: LD_INT 22
90648: PUSH
90649: LD_INT 23
90651: PUSH
90652: LD_INT 26
90654: PUSH
90655: EMPTY
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: PUSH
90666: LD_INT 101
90668: PUSH
90669: LD_INT 102
90671: PUSH
90672: LD_INT 105
90674: PUSH
90675: LD_INT 106
90677: PUSH
90678: LD_INT 108
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: ST_TO_ADDR
90692: GO 93471
90694: LD_INT 3
90696: DOUBLE
90697: EQUAL
90698: IFTRUE 90702
90700: GO 90778
90702: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
90703: LD_ADDR_VAR 0 1
90707: PUSH
90708: LD_INT 2
90710: PUSH
90711: LD_INT 4
90713: PUSH
90714: LD_INT 5
90716: PUSH
90717: LD_INT 11
90719: PUSH
90720: LD_INT 12
90722: PUSH
90723: LD_INT 15
90725: PUSH
90726: LD_INT 16
90728: PUSH
90729: LD_INT 22
90731: PUSH
90732: LD_INT 26
90734: PUSH
90735: LD_INT 36
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 101
90752: PUSH
90753: LD_INT 102
90755: PUSH
90756: LD_INT 105
90758: PUSH
90759: LD_INT 106
90761: PUSH
90762: LD_INT 108
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: ST_TO_ADDR
90776: GO 93471
90778: LD_INT 4
90780: DOUBLE
90781: EQUAL
90782: IFTRUE 90786
90784: GO 90870
90786: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
90787: LD_ADDR_VAR 0 1
90791: PUSH
90792: LD_INT 2
90794: PUSH
90795: LD_INT 4
90797: PUSH
90798: LD_INT 5
90800: PUSH
90801: LD_INT 8
90803: PUSH
90804: LD_INT 11
90806: PUSH
90807: LD_INT 12
90809: PUSH
90810: LD_INT 15
90812: PUSH
90813: LD_INT 16
90815: PUSH
90816: LD_INT 22
90818: PUSH
90819: LD_INT 23
90821: PUSH
90822: LD_INT 26
90824: PUSH
90825: LD_INT 36
90827: PUSH
90828: EMPTY
90829: LIST
90830: LIST
90831: LIST
90832: LIST
90833: LIST
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: PUSH
90842: LD_INT 101
90844: PUSH
90845: LD_INT 102
90847: PUSH
90848: LD_INT 105
90850: PUSH
90851: LD_INT 106
90853: PUSH
90854: LD_INT 108
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: PUSH
90864: EMPTY
90865: LIST
90866: LIST
90867: ST_TO_ADDR
90868: GO 93471
90870: LD_INT 5
90872: DOUBLE
90873: EQUAL
90874: IFTRUE 90878
90876: GO 90978
90878: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
90879: LD_ADDR_VAR 0 1
90883: PUSH
90884: LD_INT 2
90886: PUSH
90887: LD_INT 4
90889: PUSH
90890: LD_INT 5
90892: PUSH
90893: LD_INT 6
90895: PUSH
90896: LD_INT 8
90898: PUSH
90899: LD_INT 11
90901: PUSH
90902: LD_INT 12
90904: PUSH
90905: LD_INT 15
90907: PUSH
90908: LD_INT 16
90910: PUSH
90911: LD_INT 22
90913: PUSH
90914: LD_INT 23
90916: PUSH
90917: LD_INT 25
90919: PUSH
90920: LD_INT 26
90922: PUSH
90923: LD_INT 36
90925: PUSH
90926: EMPTY
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 101
90944: PUSH
90945: LD_INT 102
90947: PUSH
90948: LD_INT 105
90950: PUSH
90951: LD_INT 106
90953: PUSH
90954: LD_INT 108
90956: PUSH
90957: LD_INT 109
90959: PUSH
90960: LD_INT 112
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: LIST
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: ST_TO_ADDR
90976: GO 93471
90978: LD_INT 6
90980: DOUBLE
90981: EQUAL
90982: IFTRUE 90986
90984: GO 91106
90986: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
90987: LD_ADDR_VAR 0 1
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: LD_INT 4
90997: PUSH
90998: LD_INT 5
91000: PUSH
91001: LD_INT 6
91003: PUSH
91004: LD_INT 8
91006: PUSH
91007: LD_INT 11
91009: PUSH
91010: LD_INT 12
91012: PUSH
91013: LD_INT 15
91015: PUSH
91016: LD_INT 16
91018: PUSH
91019: LD_INT 20
91021: PUSH
91022: LD_INT 21
91024: PUSH
91025: LD_INT 22
91027: PUSH
91028: LD_INT 23
91030: PUSH
91031: LD_INT 25
91033: PUSH
91034: LD_INT 26
91036: PUSH
91037: LD_INT 30
91039: PUSH
91040: LD_INT 31
91042: PUSH
91043: LD_INT 32
91045: PUSH
91046: LD_INT 36
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 101
91072: PUSH
91073: LD_INT 102
91075: PUSH
91076: LD_INT 105
91078: PUSH
91079: LD_INT 106
91081: PUSH
91082: LD_INT 108
91084: PUSH
91085: LD_INT 109
91087: PUSH
91088: LD_INT 112
91090: PUSH
91091: EMPTY
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: ST_TO_ADDR
91104: GO 93471
91106: LD_INT 7
91108: DOUBLE
91109: EQUAL
91110: IFTRUE 91114
91112: GO 91214
91114: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
91115: LD_ADDR_VAR 0 1
91119: PUSH
91120: LD_INT 2
91122: PUSH
91123: LD_INT 4
91125: PUSH
91126: LD_INT 5
91128: PUSH
91129: LD_INT 7
91131: PUSH
91132: LD_INT 11
91134: PUSH
91135: LD_INT 12
91137: PUSH
91138: LD_INT 15
91140: PUSH
91141: LD_INT 16
91143: PUSH
91144: LD_INT 20
91146: PUSH
91147: LD_INT 21
91149: PUSH
91150: LD_INT 22
91152: PUSH
91153: LD_INT 23
91155: PUSH
91156: LD_INT 25
91158: PUSH
91159: LD_INT 26
91161: PUSH
91162: EMPTY
91163: LIST
91164: LIST
91165: LIST
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: LIST
91174: LIST
91175: LIST
91176: LIST
91177: PUSH
91178: LD_INT 101
91180: PUSH
91181: LD_INT 102
91183: PUSH
91184: LD_INT 103
91186: PUSH
91187: LD_INT 105
91189: PUSH
91190: LD_INT 106
91192: PUSH
91193: LD_INT 108
91195: PUSH
91196: LD_INT 112
91198: PUSH
91199: EMPTY
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: ST_TO_ADDR
91212: GO 93471
91214: LD_INT 8
91216: DOUBLE
91217: EQUAL
91218: IFTRUE 91222
91220: GO 91350
91222: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
91223: LD_ADDR_VAR 0 1
91227: PUSH
91228: LD_INT 2
91230: PUSH
91231: LD_INT 4
91233: PUSH
91234: LD_INT 5
91236: PUSH
91237: LD_INT 6
91239: PUSH
91240: LD_INT 7
91242: PUSH
91243: LD_INT 8
91245: PUSH
91246: LD_INT 11
91248: PUSH
91249: LD_INT 12
91251: PUSH
91252: LD_INT 15
91254: PUSH
91255: LD_INT 16
91257: PUSH
91258: LD_INT 20
91260: PUSH
91261: LD_INT 21
91263: PUSH
91264: LD_INT 22
91266: PUSH
91267: LD_INT 23
91269: PUSH
91270: LD_INT 25
91272: PUSH
91273: LD_INT 26
91275: PUSH
91276: LD_INT 30
91278: PUSH
91279: LD_INT 31
91281: PUSH
91282: LD_INT 32
91284: PUSH
91285: LD_INT 36
91287: PUSH
91288: EMPTY
91289: LIST
91290: LIST
91291: LIST
91292: LIST
91293: LIST
91294: LIST
91295: LIST
91296: LIST
91297: LIST
91298: LIST
91299: LIST
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: PUSH
91310: LD_INT 101
91312: PUSH
91313: LD_INT 102
91315: PUSH
91316: LD_INT 103
91318: PUSH
91319: LD_INT 105
91321: PUSH
91322: LD_INT 106
91324: PUSH
91325: LD_INT 108
91327: PUSH
91328: LD_INT 109
91330: PUSH
91331: LD_INT 112
91333: PUSH
91334: EMPTY
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: LIST
91343: PUSH
91344: EMPTY
91345: LIST
91346: LIST
91347: ST_TO_ADDR
91348: GO 93471
91350: LD_INT 9
91352: DOUBLE
91353: EQUAL
91354: IFTRUE 91358
91356: GO 91494
91358: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
91359: LD_ADDR_VAR 0 1
91363: PUSH
91364: LD_INT 2
91366: PUSH
91367: LD_INT 4
91369: PUSH
91370: LD_INT 5
91372: PUSH
91373: LD_INT 6
91375: PUSH
91376: LD_INT 7
91378: PUSH
91379: LD_INT 8
91381: PUSH
91382: LD_INT 11
91384: PUSH
91385: LD_INT 12
91387: PUSH
91388: LD_INT 15
91390: PUSH
91391: LD_INT 16
91393: PUSH
91394: LD_INT 20
91396: PUSH
91397: LD_INT 21
91399: PUSH
91400: LD_INT 22
91402: PUSH
91403: LD_INT 23
91405: PUSH
91406: LD_INT 25
91408: PUSH
91409: LD_INT 26
91411: PUSH
91412: LD_INT 28
91414: PUSH
91415: LD_INT 30
91417: PUSH
91418: LD_INT 31
91420: PUSH
91421: LD_INT 32
91423: PUSH
91424: LD_INT 36
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: PUSH
91450: LD_INT 101
91452: PUSH
91453: LD_INT 102
91455: PUSH
91456: LD_INT 103
91458: PUSH
91459: LD_INT 105
91461: PUSH
91462: LD_INT 106
91464: PUSH
91465: LD_INT 108
91467: PUSH
91468: LD_INT 109
91470: PUSH
91471: LD_INT 112
91473: PUSH
91474: LD_INT 114
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: ST_TO_ADDR
91492: GO 93471
91494: LD_INT 10
91496: DOUBLE
91497: EQUAL
91498: IFTRUE 91502
91500: GO 91686
91502: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
91503: LD_ADDR_VAR 0 1
91507: PUSH
91508: LD_INT 2
91510: PUSH
91511: LD_INT 4
91513: PUSH
91514: LD_INT 5
91516: PUSH
91517: LD_INT 6
91519: PUSH
91520: LD_INT 7
91522: PUSH
91523: LD_INT 8
91525: PUSH
91526: LD_INT 9
91528: PUSH
91529: LD_INT 10
91531: PUSH
91532: LD_INT 11
91534: PUSH
91535: LD_INT 12
91537: PUSH
91538: LD_INT 13
91540: PUSH
91541: LD_INT 14
91543: PUSH
91544: LD_INT 15
91546: PUSH
91547: LD_INT 16
91549: PUSH
91550: LD_INT 17
91552: PUSH
91553: LD_INT 18
91555: PUSH
91556: LD_INT 19
91558: PUSH
91559: LD_INT 20
91561: PUSH
91562: LD_INT 21
91564: PUSH
91565: LD_INT 22
91567: PUSH
91568: LD_INT 23
91570: PUSH
91571: LD_INT 24
91573: PUSH
91574: LD_INT 25
91576: PUSH
91577: LD_INT 26
91579: PUSH
91580: LD_INT 28
91582: PUSH
91583: LD_INT 30
91585: PUSH
91586: LD_INT 31
91588: PUSH
91589: LD_INT 32
91591: PUSH
91592: LD_INT 36
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 101
91628: PUSH
91629: LD_INT 102
91631: PUSH
91632: LD_INT 103
91634: PUSH
91635: LD_INT 104
91637: PUSH
91638: LD_INT 105
91640: PUSH
91641: LD_INT 106
91643: PUSH
91644: LD_INT 107
91646: PUSH
91647: LD_INT 108
91649: PUSH
91650: LD_INT 109
91652: PUSH
91653: LD_INT 110
91655: PUSH
91656: LD_INT 111
91658: PUSH
91659: LD_INT 112
91661: PUSH
91662: LD_INT 114
91664: PUSH
91665: EMPTY
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: ST_TO_ADDR
91684: GO 93471
91686: LD_INT 11
91688: DOUBLE
91689: EQUAL
91690: IFTRUE 91694
91692: GO 91886
91694: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
91695: LD_ADDR_VAR 0 1
91699: PUSH
91700: LD_INT 2
91702: PUSH
91703: LD_INT 3
91705: PUSH
91706: LD_INT 4
91708: PUSH
91709: LD_INT 5
91711: PUSH
91712: LD_INT 6
91714: PUSH
91715: LD_INT 7
91717: PUSH
91718: LD_INT 8
91720: PUSH
91721: LD_INT 9
91723: PUSH
91724: LD_INT 10
91726: PUSH
91727: LD_INT 11
91729: PUSH
91730: LD_INT 12
91732: PUSH
91733: LD_INT 13
91735: PUSH
91736: LD_INT 14
91738: PUSH
91739: LD_INT 15
91741: PUSH
91742: LD_INT 16
91744: PUSH
91745: LD_INT 17
91747: PUSH
91748: LD_INT 18
91750: PUSH
91751: LD_INT 19
91753: PUSH
91754: LD_INT 20
91756: PUSH
91757: LD_INT 21
91759: PUSH
91760: LD_INT 22
91762: PUSH
91763: LD_INT 23
91765: PUSH
91766: LD_INT 24
91768: PUSH
91769: LD_INT 25
91771: PUSH
91772: LD_INT 26
91774: PUSH
91775: LD_INT 28
91777: PUSH
91778: LD_INT 30
91780: PUSH
91781: LD_INT 31
91783: PUSH
91784: LD_INT 32
91786: PUSH
91787: LD_INT 34
91789: PUSH
91790: LD_INT 36
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: LIST
91821: LIST
91822: LIST
91823: LIST
91824: LIST
91825: PUSH
91826: LD_INT 101
91828: PUSH
91829: LD_INT 102
91831: PUSH
91832: LD_INT 103
91834: PUSH
91835: LD_INT 104
91837: PUSH
91838: LD_INT 105
91840: PUSH
91841: LD_INT 106
91843: PUSH
91844: LD_INT 107
91846: PUSH
91847: LD_INT 108
91849: PUSH
91850: LD_INT 109
91852: PUSH
91853: LD_INT 110
91855: PUSH
91856: LD_INT 111
91858: PUSH
91859: LD_INT 112
91861: PUSH
91862: LD_INT 114
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: ST_TO_ADDR
91884: GO 93471
91886: LD_INT 12
91888: DOUBLE
91889: EQUAL
91890: IFTRUE 91894
91892: GO 92102
91894: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
91895: LD_ADDR_VAR 0 1
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: LD_INT 2
91905: PUSH
91906: LD_INT 3
91908: PUSH
91909: LD_INT 4
91911: PUSH
91912: LD_INT 5
91914: PUSH
91915: LD_INT 6
91917: PUSH
91918: LD_INT 7
91920: PUSH
91921: LD_INT 8
91923: PUSH
91924: LD_INT 9
91926: PUSH
91927: LD_INT 10
91929: PUSH
91930: LD_INT 11
91932: PUSH
91933: LD_INT 12
91935: PUSH
91936: LD_INT 13
91938: PUSH
91939: LD_INT 14
91941: PUSH
91942: LD_INT 15
91944: PUSH
91945: LD_INT 16
91947: PUSH
91948: LD_INT 17
91950: PUSH
91951: LD_INT 18
91953: PUSH
91954: LD_INT 19
91956: PUSH
91957: LD_INT 20
91959: PUSH
91960: LD_INT 21
91962: PUSH
91963: LD_INT 22
91965: PUSH
91966: LD_INT 23
91968: PUSH
91969: LD_INT 24
91971: PUSH
91972: LD_INT 25
91974: PUSH
91975: LD_INT 26
91977: PUSH
91978: LD_INT 27
91980: PUSH
91981: LD_INT 28
91983: PUSH
91984: LD_INT 30
91986: PUSH
91987: LD_INT 31
91989: PUSH
91990: LD_INT 32
91992: PUSH
91993: LD_INT 33
91995: PUSH
91996: LD_INT 34
91998: PUSH
91999: LD_INT 36
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: PUSH
92038: LD_INT 101
92040: PUSH
92041: LD_INT 102
92043: PUSH
92044: LD_INT 103
92046: PUSH
92047: LD_INT 104
92049: PUSH
92050: LD_INT 105
92052: PUSH
92053: LD_INT 106
92055: PUSH
92056: LD_INT 107
92058: PUSH
92059: LD_INT 108
92061: PUSH
92062: LD_INT 109
92064: PUSH
92065: LD_INT 110
92067: PUSH
92068: LD_INT 111
92070: PUSH
92071: LD_INT 112
92073: PUSH
92074: LD_INT 113
92076: PUSH
92077: LD_INT 114
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: PUSH
92096: EMPTY
92097: LIST
92098: LIST
92099: ST_TO_ADDR
92100: GO 93471
92102: LD_INT 13
92104: DOUBLE
92105: EQUAL
92106: IFTRUE 92110
92108: GO 92306
92110: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
92111: LD_ADDR_VAR 0 1
92115: PUSH
92116: LD_INT 1
92118: PUSH
92119: LD_INT 2
92121: PUSH
92122: LD_INT 3
92124: PUSH
92125: LD_INT 4
92127: PUSH
92128: LD_INT 5
92130: PUSH
92131: LD_INT 8
92133: PUSH
92134: LD_INT 9
92136: PUSH
92137: LD_INT 10
92139: PUSH
92140: LD_INT 11
92142: PUSH
92143: LD_INT 12
92145: PUSH
92146: LD_INT 14
92148: PUSH
92149: LD_INT 15
92151: PUSH
92152: LD_INT 16
92154: PUSH
92155: LD_INT 17
92157: PUSH
92158: LD_INT 18
92160: PUSH
92161: LD_INT 19
92163: PUSH
92164: LD_INT 20
92166: PUSH
92167: LD_INT 21
92169: PUSH
92170: LD_INT 22
92172: PUSH
92173: LD_INT 23
92175: PUSH
92176: LD_INT 24
92178: PUSH
92179: LD_INT 25
92181: PUSH
92182: LD_INT 26
92184: PUSH
92185: LD_INT 27
92187: PUSH
92188: LD_INT 28
92190: PUSH
92191: LD_INT 30
92193: PUSH
92194: LD_INT 31
92196: PUSH
92197: LD_INT 32
92199: PUSH
92200: LD_INT 33
92202: PUSH
92203: LD_INT 34
92205: PUSH
92206: LD_INT 36
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: LIST
92213: LIST
92214: LIST
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: LIST
92233: LIST
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: PUSH
92242: LD_INT 101
92244: PUSH
92245: LD_INT 102
92247: PUSH
92248: LD_INT 103
92250: PUSH
92251: LD_INT 104
92253: PUSH
92254: LD_INT 105
92256: PUSH
92257: LD_INT 106
92259: PUSH
92260: LD_INT 107
92262: PUSH
92263: LD_INT 108
92265: PUSH
92266: LD_INT 109
92268: PUSH
92269: LD_INT 110
92271: PUSH
92272: LD_INT 111
92274: PUSH
92275: LD_INT 112
92277: PUSH
92278: LD_INT 113
92280: PUSH
92281: LD_INT 114
92283: PUSH
92284: EMPTY
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: ST_TO_ADDR
92304: GO 93471
92306: LD_INT 14
92308: DOUBLE
92309: EQUAL
92310: IFTRUE 92314
92312: GO 92526
92314: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
92315: LD_ADDR_VAR 0 1
92319: PUSH
92320: LD_INT 1
92322: PUSH
92323: LD_INT 2
92325: PUSH
92326: LD_INT 3
92328: PUSH
92329: LD_INT 4
92331: PUSH
92332: LD_INT 5
92334: PUSH
92335: LD_INT 6
92337: PUSH
92338: LD_INT 7
92340: PUSH
92341: LD_INT 8
92343: PUSH
92344: LD_INT 9
92346: PUSH
92347: LD_INT 10
92349: PUSH
92350: LD_INT 11
92352: PUSH
92353: LD_INT 12
92355: PUSH
92356: LD_INT 13
92358: PUSH
92359: LD_INT 14
92361: PUSH
92362: LD_INT 15
92364: PUSH
92365: LD_INT 16
92367: PUSH
92368: LD_INT 17
92370: PUSH
92371: LD_INT 18
92373: PUSH
92374: LD_INT 19
92376: PUSH
92377: LD_INT 20
92379: PUSH
92380: LD_INT 21
92382: PUSH
92383: LD_INT 22
92385: PUSH
92386: LD_INT 23
92388: PUSH
92389: LD_INT 24
92391: PUSH
92392: LD_INT 25
92394: PUSH
92395: LD_INT 26
92397: PUSH
92398: LD_INT 27
92400: PUSH
92401: LD_INT 28
92403: PUSH
92404: LD_INT 29
92406: PUSH
92407: LD_INT 30
92409: PUSH
92410: LD_INT 31
92412: PUSH
92413: LD_INT 32
92415: PUSH
92416: LD_INT 33
92418: PUSH
92419: LD_INT 34
92421: PUSH
92422: LD_INT 36
92424: PUSH
92425: EMPTY
92426: LIST
92427: LIST
92428: LIST
92429: LIST
92430: LIST
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 101
92464: PUSH
92465: LD_INT 102
92467: PUSH
92468: LD_INT 103
92470: PUSH
92471: LD_INT 104
92473: PUSH
92474: LD_INT 105
92476: PUSH
92477: LD_INT 106
92479: PUSH
92480: LD_INT 107
92482: PUSH
92483: LD_INT 108
92485: PUSH
92486: LD_INT 109
92488: PUSH
92489: LD_INT 110
92491: PUSH
92492: LD_INT 111
92494: PUSH
92495: LD_INT 112
92497: PUSH
92498: LD_INT 113
92500: PUSH
92501: LD_INT 114
92503: PUSH
92504: EMPTY
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: LIST
92517: LIST
92518: LIST
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: ST_TO_ADDR
92524: GO 93471
92526: LD_INT 15
92528: DOUBLE
92529: EQUAL
92530: IFTRUE 92534
92532: GO 92746
92534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
92535: LD_ADDR_VAR 0 1
92539: PUSH
92540: LD_INT 1
92542: PUSH
92543: LD_INT 2
92545: PUSH
92546: LD_INT 3
92548: PUSH
92549: LD_INT 4
92551: PUSH
92552: LD_INT 5
92554: PUSH
92555: LD_INT 6
92557: PUSH
92558: LD_INT 7
92560: PUSH
92561: LD_INT 8
92563: PUSH
92564: LD_INT 9
92566: PUSH
92567: LD_INT 10
92569: PUSH
92570: LD_INT 11
92572: PUSH
92573: LD_INT 12
92575: PUSH
92576: LD_INT 13
92578: PUSH
92579: LD_INT 14
92581: PUSH
92582: LD_INT 15
92584: PUSH
92585: LD_INT 16
92587: PUSH
92588: LD_INT 17
92590: PUSH
92591: LD_INT 18
92593: PUSH
92594: LD_INT 19
92596: PUSH
92597: LD_INT 20
92599: PUSH
92600: LD_INT 21
92602: PUSH
92603: LD_INT 22
92605: PUSH
92606: LD_INT 23
92608: PUSH
92609: LD_INT 24
92611: PUSH
92612: LD_INT 25
92614: PUSH
92615: LD_INT 26
92617: PUSH
92618: LD_INT 27
92620: PUSH
92621: LD_INT 28
92623: PUSH
92624: LD_INT 29
92626: PUSH
92627: LD_INT 30
92629: PUSH
92630: LD_INT 31
92632: PUSH
92633: LD_INT 32
92635: PUSH
92636: LD_INT 33
92638: PUSH
92639: LD_INT 34
92641: PUSH
92642: LD_INT 36
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 101
92684: PUSH
92685: LD_INT 102
92687: PUSH
92688: LD_INT 103
92690: PUSH
92691: LD_INT 104
92693: PUSH
92694: LD_INT 105
92696: PUSH
92697: LD_INT 106
92699: PUSH
92700: LD_INT 107
92702: PUSH
92703: LD_INT 108
92705: PUSH
92706: LD_INT 109
92708: PUSH
92709: LD_INT 110
92711: PUSH
92712: LD_INT 111
92714: PUSH
92715: LD_INT 112
92717: PUSH
92718: LD_INT 113
92720: PUSH
92721: LD_INT 114
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: ST_TO_ADDR
92744: GO 93471
92746: LD_INT 16
92748: DOUBLE
92749: EQUAL
92750: IFTRUE 92754
92752: GO 92878
92754: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
92755: LD_ADDR_VAR 0 1
92759: PUSH
92760: LD_INT 2
92762: PUSH
92763: LD_INT 4
92765: PUSH
92766: LD_INT 5
92768: PUSH
92769: LD_INT 7
92771: PUSH
92772: LD_INT 11
92774: PUSH
92775: LD_INT 12
92777: PUSH
92778: LD_INT 15
92780: PUSH
92781: LD_INT 16
92783: PUSH
92784: LD_INT 20
92786: PUSH
92787: LD_INT 21
92789: PUSH
92790: LD_INT 22
92792: PUSH
92793: LD_INT 23
92795: PUSH
92796: LD_INT 25
92798: PUSH
92799: LD_INT 26
92801: PUSH
92802: LD_INT 30
92804: PUSH
92805: LD_INT 31
92807: PUSH
92808: LD_INT 32
92810: PUSH
92811: LD_INT 33
92813: PUSH
92814: LD_INT 34
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: PUSH
92838: LD_INT 101
92840: PUSH
92841: LD_INT 102
92843: PUSH
92844: LD_INT 103
92846: PUSH
92847: LD_INT 106
92849: PUSH
92850: LD_INT 108
92852: PUSH
92853: LD_INT 112
92855: PUSH
92856: LD_INT 113
92858: PUSH
92859: LD_INT 114
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: LIST
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: ST_TO_ADDR
92876: GO 93471
92878: LD_INT 17
92880: DOUBLE
92881: EQUAL
92882: IFTRUE 92886
92884: GO 93098
92886: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
92887: LD_ADDR_VAR 0 1
92891: PUSH
92892: LD_INT 1
92894: PUSH
92895: LD_INT 2
92897: PUSH
92898: LD_INT 3
92900: PUSH
92901: LD_INT 4
92903: PUSH
92904: LD_INT 5
92906: PUSH
92907: LD_INT 6
92909: PUSH
92910: LD_INT 7
92912: PUSH
92913: LD_INT 8
92915: PUSH
92916: LD_INT 9
92918: PUSH
92919: LD_INT 10
92921: PUSH
92922: LD_INT 11
92924: PUSH
92925: LD_INT 12
92927: PUSH
92928: LD_INT 13
92930: PUSH
92931: LD_INT 14
92933: PUSH
92934: LD_INT 15
92936: PUSH
92937: LD_INT 16
92939: PUSH
92940: LD_INT 17
92942: PUSH
92943: LD_INT 18
92945: PUSH
92946: LD_INT 19
92948: PUSH
92949: LD_INT 20
92951: PUSH
92952: LD_INT 21
92954: PUSH
92955: LD_INT 22
92957: PUSH
92958: LD_INT 23
92960: PUSH
92961: LD_INT 24
92963: PUSH
92964: LD_INT 25
92966: PUSH
92967: LD_INT 26
92969: PUSH
92970: LD_INT 27
92972: PUSH
92973: LD_INT 28
92975: PUSH
92976: LD_INT 29
92978: PUSH
92979: LD_INT 30
92981: PUSH
92982: LD_INT 31
92984: PUSH
92985: LD_INT 32
92987: PUSH
92988: LD_INT 33
92990: PUSH
92991: LD_INT 34
92993: PUSH
92994: LD_INT 36
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: LIST
93006: LIST
93007: LIST
93008: LIST
93009: LIST
93010: LIST
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: LIST
93020: LIST
93021: LIST
93022: LIST
93023: LIST
93024: LIST
93025: LIST
93026: LIST
93027: LIST
93028: LIST
93029: LIST
93030: LIST
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 101
93036: PUSH
93037: LD_INT 102
93039: PUSH
93040: LD_INT 103
93042: PUSH
93043: LD_INT 104
93045: PUSH
93046: LD_INT 105
93048: PUSH
93049: LD_INT 106
93051: PUSH
93052: LD_INT 107
93054: PUSH
93055: LD_INT 108
93057: PUSH
93058: LD_INT 109
93060: PUSH
93061: LD_INT 110
93063: PUSH
93064: LD_INT 111
93066: PUSH
93067: LD_INT 112
93069: PUSH
93070: LD_INT 113
93072: PUSH
93073: LD_INT 114
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: ST_TO_ADDR
93096: GO 93471
93098: LD_INT 18
93100: DOUBLE
93101: EQUAL
93102: IFTRUE 93106
93104: GO 93242
93106: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
93107: LD_ADDR_VAR 0 1
93111: PUSH
93112: LD_INT 2
93114: PUSH
93115: LD_INT 4
93117: PUSH
93118: LD_INT 5
93120: PUSH
93121: LD_INT 7
93123: PUSH
93124: LD_INT 11
93126: PUSH
93127: LD_INT 12
93129: PUSH
93130: LD_INT 15
93132: PUSH
93133: LD_INT 16
93135: PUSH
93136: LD_INT 20
93138: PUSH
93139: LD_INT 21
93141: PUSH
93142: LD_INT 22
93144: PUSH
93145: LD_INT 23
93147: PUSH
93148: LD_INT 25
93150: PUSH
93151: LD_INT 26
93153: PUSH
93154: LD_INT 30
93156: PUSH
93157: LD_INT 31
93159: PUSH
93160: LD_INT 32
93162: PUSH
93163: LD_INT 33
93165: PUSH
93166: LD_INT 34
93168: PUSH
93169: LD_INT 35
93171: PUSH
93172: LD_INT 36
93174: PUSH
93175: EMPTY
93176: LIST
93177: LIST
93178: LIST
93179: LIST
93180: LIST
93181: LIST
93182: LIST
93183: LIST
93184: LIST
93185: LIST
93186: LIST
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: PUSH
93198: LD_INT 101
93200: PUSH
93201: LD_INT 102
93203: PUSH
93204: LD_INT 103
93206: PUSH
93207: LD_INT 106
93209: PUSH
93210: LD_INT 108
93212: PUSH
93213: LD_INT 112
93215: PUSH
93216: LD_INT 113
93218: PUSH
93219: LD_INT 114
93221: PUSH
93222: LD_INT 115
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: LIST
93229: LIST
93230: LIST
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: ST_TO_ADDR
93240: GO 93471
93242: LD_INT 19
93244: DOUBLE
93245: EQUAL
93246: IFTRUE 93250
93248: GO 93470
93250: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
93251: LD_ADDR_VAR 0 1
93255: PUSH
93256: LD_INT 1
93258: PUSH
93259: LD_INT 2
93261: PUSH
93262: LD_INT 3
93264: PUSH
93265: LD_INT 4
93267: PUSH
93268: LD_INT 5
93270: PUSH
93271: LD_INT 6
93273: PUSH
93274: LD_INT 7
93276: PUSH
93277: LD_INT 8
93279: PUSH
93280: LD_INT 9
93282: PUSH
93283: LD_INT 10
93285: PUSH
93286: LD_INT 11
93288: PUSH
93289: LD_INT 12
93291: PUSH
93292: LD_INT 13
93294: PUSH
93295: LD_INT 14
93297: PUSH
93298: LD_INT 15
93300: PUSH
93301: LD_INT 16
93303: PUSH
93304: LD_INT 17
93306: PUSH
93307: LD_INT 18
93309: PUSH
93310: LD_INT 19
93312: PUSH
93313: LD_INT 20
93315: PUSH
93316: LD_INT 21
93318: PUSH
93319: LD_INT 22
93321: PUSH
93322: LD_INT 23
93324: PUSH
93325: LD_INT 24
93327: PUSH
93328: LD_INT 25
93330: PUSH
93331: LD_INT 26
93333: PUSH
93334: LD_INT 27
93336: PUSH
93337: LD_INT 28
93339: PUSH
93340: LD_INT 29
93342: PUSH
93343: LD_INT 30
93345: PUSH
93346: LD_INT 31
93348: PUSH
93349: LD_INT 32
93351: PUSH
93352: LD_INT 33
93354: PUSH
93355: LD_INT 34
93357: PUSH
93358: LD_INT 35
93360: PUSH
93361: LD_INT 36
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: PUSH
93402: LD_INT 101
93404: PUSH
93405: LD_INT 102
93407: PUSH
93408: LD_INT 103
93410: PUSH
93411: LD_INT 104
93413: PUSH
93414: LD_INT 105
93416: PUSH
93417: LD_INT 106
93419: PUSH
93420: LD_INT 107
93422: PUSH
93423: LD_INT 108
93425: PUSH
93426: LD_INT 109
93428: PUSH
93429: LD_INT 110
93431: PUSH
93432: LD_INT 111
93434: PUSH
93435: LD_INT 112
93437: PUSH
93438: LD_INT 113
93440: PUSH
93441: LD_INT 114
93443: PUSH
93444: LD_INT 115
93446: PUSH
93447: EMPTY
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: LIST
93462: LIST
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: ST_TO_ADDR
93468: GO 93471
93470: POP
// end else
93471: GO 93690
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
93473: LD_ADDR_VAR 0 1
93477: PUSH
93478: LD_INT 1
93480: PUSH
93481: LD_INT 2
93483: PUSH
93484: LD_INT 3
93486: PUSH
93487: LD_INT 4
93489: PUSH
93490: LD_INT 5
93492: PUSH
93493: LD_INT 6
93495: PUSH
93496: LD_INT 7
93498: PUSH
93499: LD_INT 8
93501: PUSH
93502: LD_INT 9
93504: PUSH
93505: LD_INT 10
93507: PUSH
93508: LD_INT 11
93510: PUSH
93511: LD_INT 12
93513: PUSH
93514: LD_INT 13
93516: PUSH
93517: LD_INT 14
93519: PUSH
93520: LD_INT 15
93522: PUSH
93523: LD_INT 16
93525: PUSH
93526: LD_INT 17
93528: PUSH
93529: LD_INT 18
93531: PUSH
93532: LD_INT 19
93534: PUSH
93535: LD_INT 20
93537: PUSH
93538: LD_INT 21
93540: PUSH
93541: LD_INT 22
93543: PUSH
93544: LD_INT 23
93546: PUSH
93547: LD_INT 24
93549: PUSH
93550: LD_INT 25
93552: PUSH
93553: LD_INT 26
93555: PUSH
93556: LD_INT 27
93558: PUSH
93559: LD_INT 28
93561: PUSH
93562: LD_INT 29
93564: PUSH
93565: LD_INT 30
93567: PUSH
93568: LD_INT 31
93570: PUSH
93571: LD_INT 32
93573: PUSH
93574: LD_INT 33
93576: PUSH
93577: LD_INT 34
93579: PUSH
93580: LD_INT 35
93582: PUSH
93583: LD_INT 36
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: LIST
93617: LIST
93618: LIST
93619: LIST
93620: LIST
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 101
93626: PUSH
93627: LD_INT 102
93629: PUSH
93630: LD_INT 103
93632: PUSH
93633: LD_INT 104
93635: PUSH
93636: LD_INT 105
93638: PUSH
93639: LD_INT 106
93641: PUSH
93642: LD_INT 107
93644: PUSH
93645: LD_INT 108
93647: PUSH
93648: LD_INT 109
93650: PUSH
93651: LD_INT 110
93653: PUSH
93654: LD_INT 111
93656: PUSH
93657: LD_INT 112
93659: PUSH
93660: LD_INT 113
93662: PUSH
93663: LD_INT 114
93665: PUSH
93666: LD_INT 115
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: LIST
93673: LIST
93674: LIST
93675: LIST
93676: LIST
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: PUSH
93686: EMPTY
93687: LIST
93688: LIST
93689: ST_TO_ADDR
// if result then
93690: LD_VAR 0 1
93694: IFFALSE 93983
// begin normal :=  ;
93696: LD_ADDR_VAR 0 3
93700: PUSH
93701: LD_STRING 
93703: ST_TO_ADDR
// hardcore :=  ;
93704: LD_ADDR_VAR 0 4
93708: PUSH
93709: LD_STRING 
93711: ST_TO_ADDR
// for i = 1 to normalCounter do
93712: LD_ADDR_VAR 0 5
93716: PUSH
93717: DOUBLE
93718: LD_INT 1
93720: DEC
93721: ST_TO_ADDR
93722: LD_EXP 99
93726: PUSH
93727: FOR_TO
93728: IFFALSE 93829
// begin tmp := 0 ;
93730: LD_ADDR_VAR 0 2
93734: PUSH
93735: LD_STRING 0
93737: ST_TO_ADDR
// if result [ 1 ] then
93738: LD_VAR 0 1
93742: PUSH
93743: LD_INT 1
93745: ARRAY
93746: IFFALSE 93811
// if result [ 1 ] [ 1 ] = i then
93748: LD_VAR 0 1
93752: PUSH
93753: LD_INT 1
93755: ARRAY
93756: PUSH
93757: LD_INT 1
93759: ARRAY
93760: PUSH
93761: LD_VAR 0 5
93765: EQUAL
93766: IFFALSE 93811
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93768: LD_ADDR_VAR 0 1
93772: PUSH
93773: LD_VAR 0 1
93777: PPUSH
93778: LD_INT 1
93780: PPUSH
93781: LD_VAR 0 1
93785: PUSH
93786: LD_INT 1
93788: ARRAY
93789: PPUSH
93790: LD_INT 1
93792: PPUSH
93793: CALL_OW 3
93797: PPUSH
93798: CALL_OW 1
93802: ST_TO_ADDR
// tmp := 1 ;
93803: LD_ADDR_VAR 0 2
93807: PUSH
93808: LD_STRING 1
93810: ST_TO_ADDR
// end ; normal := normal & tmp ;
93811: LD_ADDR_VAR 0 3
93815: PUSH
93816: LD_VAR 0 3
93820: PUSH
93821: LD_VAR 0 2
93825: STR
93826: ST_TO_ADDR
// end ;
93827: GO 93727
93829: POP
93830: POP
// for i = 1 to hardcoreCounter do
93831: LD_ADDR_VAR 0 5
93835: PUSH
93836: DOUBLE
93837: LD_INT 1
93839: DEC
93840: ST_TO_ADDR
93841: LD_EXP 100
93845: PUSH
93846: FOR_TO
93847: IFFALSE 93952
// begin tmp := 0 ;
93849: LD_ADDR_VAR 0 2
93853: PUSH
93854: LD_STRING 0
93856: ST_TO_ADDR
// if result [ 2 ] then
93857: LD_VAR 0 1
93861: PUSH
93862: LD_INT 2
93864: ARRAY
93865: IFFALSE 93934
// if result [ 2 ] [ 1 ] = 100 + i then
93867: LD_VAR 0 1
93871: PUSH
93872: LD_INT 2
93874: ARRAY
93875: PUSH
93876: LD_INT 1
93878: ARRAY
93879: PUSH
93880: LD_INT 100
93882: PUSH
93883: LD_VAR 0 5
93887: PLUS
93888: EQUAL
93889: IFFALSE 93934
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93891: LD_ADDR_VAR 0 1
93895: PUSH
93896: LD_VAR 0 1
93900: PPUSH
93901: LD_INT 2
93903: PPUSH
93904: LD_VAR 0 1
93908: PUSH
93909: LD_INT 2
93911: ARRAY
93912: PPUSH
93913: LD_INT 1
93915: PPUSH
93916: CALL_OW 3
93920: PPUSH
93921: CALL_OW 1
93925: ST_TO_ADDR
// tmp := 1 ;
93926: LD_ADDR_VAR 0 2
93930: PUSH
93931: LD_STRING 1
93933: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93934: LD_ADDR_VAR 0 4
93938: PUSH
93939: LD_VAR 0 4
93943: PUSH
93944: LD_VAR 0 2
93948: STR
93949: ST_TO_ADDR
// end ;
93950: GO 93846
93952: POP
93953: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
93954: LD_STRING getStreamItemsFromMission("
93956: PUSH
93957: LD_VAR 0 3
93961: STR
93962: PUSH
93963: LD_STRING ","
93965: STR
93966: PUSH
93967: LD_VAR 0 4
93971: STR
93972: PUSH
93973: LD_STRING ")
93975: STR
93976: PPUSH
93977: CALL_OW 559
// end else
93981: GO 93990
// ToLua ( getStreamItemsFromMission("","") ) ;
93983: LD_STRING getStreamItemsFromMission("","")
93985: PPUSH
93986: CALL_OW 559
// end ;
93990: LD_VAR 0 1
93994: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93995: LD_EXP 98
93999: PUSH
94000: LD_EXP 103
94004: AND
94005: IFFALSE 94129
94007: GO 94009
94009: DISABLE
94010: LD_INT 0
94012: PPUSH
94013: PPUSH
// begin enable ;
94014: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94015: LD_ADDR_VAR 0 2
94019: PUSH
94020: LD_INT 22
94022: PUSH
94023: LD_OWVAR 2
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: LD_INT 34
94037: PUSH
94038: LD_INT 7
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 34
94047: PUSH
94048: LD_INT 45
94050: PUSH
94051: EMPTY
94052: LIST
94053: LIST
94054: PUSH
94055: LD_INT 34
94057: PUSH
94058: LD_INT 28
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: PUSH
94065: LD_INT 34
94067: PUSH
94068: LD_INT 47
94070: PUSH
94071: EMPTY
94072: LIST
94073: LIST
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PPUSH
94086: CALL_OW 69
94090: ST_TO_ADDR
// if not tmp then
94091: LD_VAR 0 2
94095: NOT
94096: IFFALSE 94100
// exit ;
94098: GO 94129
// for i in tmp do
94100: LD_ADDR_VAR 0 1
94104: PUSH
94105: LD_VAR 0 2
94109: PUSH
94110: FOR_IN
94111: IFFALSE 94127
// begin SetLives ( i , 0 ) ;
94113: LD_VAR 0 1
94117: PPUSH
94118: LD_INT 0
94120: PPUSH
94121: CALL_OW 234
// end ;
94125: GO 94110
94127: POP
94128: POP
// end ;
94129: PPOPN 2
94131: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94132: LD_EXP 98
94136: PUSH
94137: LD_EXP 104
94141: AND
94142: IFFALSE 94226
94144: GO 94146
94146: DISABLE
94147: LD_INT 0
94149: PPUSH
94150: PPUSH
// begin enable ;
94151: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94152: LD_ADDR_VAR 0 2
94156: PUSH
94157: LD_INT 22
94159: PUSH
94160: LD_OWVAR 2
94164: PUSH
94165: EMPTY
94166: LIST
94167: LIST
94168: PUSH
94169: LD_INT 32
94171: PUSH
94172: LD_INT 3
94174: PUSH
94175: EMPTY
94176: LIST
94177: LIST
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PPUSH
94183: CALL_OW 69
94187: ST_TO_ADDR
// if not tmp then
94188: LD_VAR 0 2
94192: NOT
94193: IFFALSE 94197
// exit ;
94195: GO 94226
// for i in tmp do
94197: LD_ADDR_VAR 0 1
94201: PUSH
94202: LD_VAR 0 2
94206: PUSH
94207: FOR_IN
94208: IFFALSE 94224
// begin SetLives ( i , 0 ) ;
94210: LD_VAR 0 1
94214: PPUSH
94215: LD_INT 0
94217: PPUSH
94218: CALL_OW 234
// end ;
94222: GO 94207
94224: POP
94225: POP
// end ;
94226: PPOPN 2
94228: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94229: LD_EXP 98
94233: PUSH
94234: LD_EXP 101
94238: AND
94239: IFFALSE 94332
94241: GO 94243
94243: DISABLE
94244: LD_INT 0
94246: PPUSH
// begin enable ;
94247: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94248: LD_ADDR_VAR 0 1
94252: PUSH
94253: LD_INT 22
94255: PUSH
94256: LD_OWVAR 2
94260: PUSH
94261: EMPTY
94262: LIST
94263: LIST
94264: PUSH
94265: LD_INT 2
94267: PUSH
94268: LD_INT 25
94270: PUSH
94271: LD_INT 5
94273: PUSH
94274: EMPTY
94275: LIST
94276: LIST
94277: PUSH
94278: LD_INT 25
94280: PUSH
94281: LD_INT 9
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 25
94290: PUSH
94291: LD_INT 8
94293: PUSH
94294: EMPTY
94295: LIST
94296: LIST
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PPUSH
94308: CALL_OW 69
94312: PUSH
94313: FOR_IN
94314: IFFALSE 94330
// begin SetClass ( i , 1 ) ;
94316: LD_VAR 0 1
94320: PPUSH
94321: LD_INT 1
94323: PPUSH
94324: CALL_OW 336
// end ;
94328: GO 94313
94330: POP
94331: POP
// end ;
94332: PPOPN 1
94334: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94335: LD_EXP 98
94339: PUSH
94340: LD_EXP 102
94344: AND
94345: PUSH
94346: LD_OWVAR 65
94350: PUSH
94351: LD_INT 7
94353: LESS
94354: AND
94355: IFFALSE 94369
94357: GO 94359
94359: DISABLE
// begin enable ;
94360: ENABLE
// game_speed := 7 ;
94361: LD_ADDR_OWVAR 65
94365: PUSH
94366: LD_INT 7
94368: ST_TO_ADDR
// end ;
94369: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94370: LD_EXP 98
94374: PUSH
94375: LD_EXP 105
94379: AND
94380: IFFALSE 94582
94382: GO 94384
94384: DISABLE
94385: LD_INT 0
94387: PPUSH
94388: PPUSH
94389: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94390: LD_ADDR_VAR 0 3
94394: PUSH
94395: LD_INT 81
94397: PUSH
94398: LD_OWVAR 2
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 21
94409: PUSH
94410: LD_INT 1
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PPUSH
94421: CALL_OW 69
94425: ST_TO_ADDR
// if not tmp then
94426: LD_VAR 0 3
94430: NOT
94431: IFFALSE 94435
// exit ;
94433: GO 94582
// if tmp > 5 then
94435: LD_VAR 0 3
94439: PUSH
94440: LD_INT 5
94442: GREATER
94443: IFFALSE 94455
// k := 5 else
94445: LD_ADDR_VAR 0 2
94449: PUSH
94450: LD_INT 5
94452: ST_TO_ADDR
94453: GO 94465
// k := tmp ;
94455: LD_ADDR_VAR 0 2
94459: PUSH
94460: LD_VAR 0 3
94464: ST_TO_ADDR
// for i := 1 to k do
94465: LD_ADDR_VAR 0 1
94469: PUSH
94470: DOUBLE
94471: LD_INT 1
94473: DEC
94474: ST_TO_ADDR
94475: LD_VAR 0 2
94479: PUSH
94480: FOR_TO
94481: IFFALSE 94580
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94483: LD_VAR 0 3
94487: PUSH
94488: LD_VAR 0 1
94492: ARRAY
94493: PPUSH
94494: LD_VAR 0 1
94498: PUSH
94499: LD_INT 4
94501: MOD
94502: PUSH
94503: LD_INT 1
94505: PLUS
94506: PPUSH
94507: CALL_OW 259
94511: PUSH
94512: LD_INT 10
94514: LESS
94515: IFFALSE 94578
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94517: LD_VAR 0 3
94521: PUSH
94522: LD_VAR 0 1
94526: ARRAY
94527: PPUSH
94528: LD_VAR 0 1
94532: PUSH
94533: LD_INT 4
94535: MOD
94536: PUSH
94537: LD_INT 1
94539: PLUS
94540: PPUSH
94541: LD_VAR 0 3
94545: PUSH
94546: LD_VAR 0 1
94550: ARRAY
94551: PPUSH
94552: LD_VAR 0 1
94556: PUSH
94557: LD_INT 4
94559: MOD
94560: PUSH
94561: LD_INT 1
94563: PLUS
94564: PPUSH
94565: CALL_OW 259
94569: PUSH
94570: LD_INT 1
94572: PLUS
94573: PPUSH
94574: CALL_OW 237
94578: GO 94480
94580: POP
94581: POP
// end ;
94582: PPOPN 3
94584: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94585: LD_EXP 98
94589: PUSH
94590: LD_EXP 106
94594: AND
94595: IFFALSE 94615
94597: GO 94599
94599: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94600: LD_INT 4
94602: PPUSH
94603: LD_OWVAR 2
94607: PPUSH
94608: LD_INT 0
94610: PPUSH
94611: CALL_OW 324
94615: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94616: LD_EXP 98
94620: PUSH
94621: LD_EXP 135
94625: AND
94626: IFFALSE 94646
94628: GO 94630
94630: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94631: LD_INT 19
94633: PPUSH
94634: LD_OWVAR 2
94638: PPUSH
94639: LD_INT 0
94641: PPUSH
94642: CALL_OW 324
94646: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94647: LD_EXP 98
94651: PUSH
94652: LD_EXP 107
94656: AND
94657: IFFALSE 94759
94659: GO 94661
94661: DISABLE
94662: LD_INT 0
94664: PPUSH
94665: PPUSH
// begin enable ;
94666: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94667: LD_ADDR_VAR 0 2
94671: PUSH
94672: LD_INT 22
94674: PUSH
94675: LD_OWVAR 2
94679: PUSH
94680: EMPTY
94681: LIST
94682: LIST
94683: PUSH
94684: LD_INT 2
94686: PUSH
94687: LD_INT 34
94689: PUSH
94690: LD_INT 11
94692: PUSH
94693: EMPTY
94694: LIST
94695: LIST
94696: PUSH
94697: LD_INT 34
94699: PUSH
94700: LD_INT 30
94702: PUSH
94703: EMPTY
94704: LIST
94705: LIST
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: LIST
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PPUSH
94716: CALL_OW 69
94720: ST_TO_ADDR
// if not tmp then
94721: LD_VAR 0 2
94725: NOT
94726: IFFALSE 94730
// exit ;
94728: GO 94759
// for i in tmp do
94730: LD_ADDR_VAR 0 1
94734: PUSH
94735: LD_VAR 0 2
94739: PUSH
94740: FOR_IN
94741: IFFALSE 94757
// begin SetLives ( i , 0 ) ;
94743: LD_VAR 0 1
94747: PPUSH
94748: LD_INT 0
94750: PPUSH
94751: CALL_OW 234
// end ;
94755: GO 94740
94757: POP
94758: POP
// end ;
94759: PPOPN 2
94761: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94762: LD_EXP 98
94766: PUSH
94767: LD_EXP 108
94771: AND
94772: IFFALSE 94792
94774: GO 94776
94776: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94777: LD_INT 32
94779: PPUSH
94780: LD_OWVAR 2
94784: PPUSH
94785: LD_INT 0
94787: PPUSH
94788: CALL_OW 324
94792: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94793: LD_EXP 98
94797: PUSH
94798: LD_EXP 109
94802: AND
94803: IFFALSE 94984
94805: GO 94807
94807: DISABLE
94808: LD_INT 0
94810: PPUSH
94811: PPUSH
94812: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94813: LD_ADDR_VAR 0 2
94817: PUSH
94818: LD_INT 22
94820: PUSH
94821: LD_OWVAR 2
94825: PUSH
94826: EMPTY
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 33
94832: PUSH
94833: LD_INT 3
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PPUSH
94844: CALL_OW 69
94848: ST_TO_ADDR
// if not tmp then
94849: LD_VAR 0 2
94853: NOT
94854: IFFALSE 94858
// exit ;
94856: GO 94984
// side := 0 ;
94858: LD_ADDR_VAR 0 3
94862: PUSH
94863: LD_INT 0
94865: ST_TO_ADDR
// for i := 1 to 8 do
94866: LD_ADDR_VAR 0 1
94870: PUSH
94871: DOUBLE
94872: LD_INT 1
94874: DEC
94875: ST_TO_ADDR
94876: LD_INT 8
94878: PUSH
94879: FOR_TO
94880: IFFALSE 94928
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94882: LD_OWVAR 2
94886: PUSH
94887: LD_VAR 0 1
94891: NONEQUAL
94892: PUSH
94893: LD_OWVAR 2
94897: PPUSH
94898: LD_VAR 0 1
94902: PPUSH
94903: CALL_OW 81
94907: PUSH
94908: LD_INT 2
94910: EQUAL
94911: AND
94912: IFFALSE 94926
// begin side := i ;
94914: LD_ADDR_VAR 0 3
94918: PUSH
94919: LD_VAR 0 1
94923: ST_TO_ADDR
// break ;
94924: GO 94928
// end ;
94926: GO 94879
94928: POP
94929: POP
// if not side then
94930: LD_VAR 0 3
94934: NOT
94935: IFFALSE 94939
// exit ;
94937: GO 94984
// for i := 1 to tmp do
94939: LD_ADDR_VAR 0 1
94943: PUSH
94944: DOUBLE
94945: LD_INT 1
94947: DEC
94948: ST_TO_ADDR
94949: LD_VAR 0 2
94953: PUSH
94954: FOR_TO
94955: IFFALSE 94982
// if Prob ( 60 ) then
94957: LD_INT 60
94959: PPUSH
94960: CALL_OW 13
94964: IFFALSE 94980
// SetSide ( i , side ) ;
94966: LD_VAR 0 1
94970: PPUSH
94971: LD_VAR 0 3
94975: PPUSH
94976: CALL_OW 235
94980: GO 94954
94982: POP
94983: POP
// end ;
94984: PPOPN 3
94986: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94987: LD_EXP 98
94991: PUSH
94992: LD_EXP 111
94996: AND
94997: IFFALSE 95116
94999: GO 95001
95001: DISABLE
95002: LD_INT 0
95004: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95005: LD_ADDR_VAR 0 1
95009: PUSH
95010: LD_INT 22
95012: PUSH
95013: LD_OWVAR 2
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 21
95024: PUSH
95025: LD_INT 1
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 3
95034: PUSH
95035: LD_INT 23
95037: PUSH
95038: LD_INT 0
95040: PUSH
95041: EMPTY
95042: LIST
95043: LIST
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: EMPTY
95050: LIST
95051: LIST
95052: LIST
95053: PPUSH
95054: CALL_OW 69
95058: PUSH
95059: FOR_IN
95060: IFFALSE 95114
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95062: LD_VAR 0 1
95066: PPUSH
95067: CALL_OW 257
95071: PUSH
95072: LD_INT 1
95074: PUSH
95075: LD_INT 2
95077: PUSH
95078: LD_INT 3
95080: PUSH
95081: LD_INT 4
95083: PUSH
95084: EMPTY
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: IN
95090: IFFALSE 95112
// SetClass ( un , rand ( 1 , 4 ) ) ;
95092: LD_VAR 0 1
95096: PPUSH
95097: LD_INT 1
95099: PPUSH
95100: LD_INT 4
95102: PPUSH
95103: CALL_OW 12
95107: PPUSH
95108: CALL_OW 336
95112: GO 95059
95114: POP
95115: POP
// end ;
95116: PPOPN 1
95118: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95119: LD_EXP 98
95123: PUSH
95124: LD_EXP 110
95128: AND
95129: IFFALSE 95208
95131: GO 95133
95133: DISABLE
95134: LD_INT 0
95136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95137: LD_ADDR_VAR 0 1
95141: PUSH
95142: LD_INT 22
95144: PUSH
95145: LD_OWVAR 2
95149: PUSH
95150: EMPTY
95151: LIST
95152: LIST
95153: PUSH
95154: LD_INT 21
95156: PUSH
95157: LD_INT 3
95159: PUSH
95160: EMPTY
95161: LIST
95162: LIST
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PPUSH
95168: CALL_OW 69
95172: ST_TO_ADDR
// if not tmp then
95173: LD_VAR 0 1
95177: NOT
95178: IFFALSE 95182
// exit ;
95180: GO 95208
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95182: LD_VAR 0 1
95186: PUSH
95187: LD_INT 1
95189: PPUSH
95190: LD_VAR 0 1
95194: PPUSH
95195: CALL_OW 12
95199: ARRAY
95200: PPUSH
95201: LD_INT 100
95203: PPUSH
95204: CALL_OW 234
// end ;
95208: PPOPN 1
95210: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95211: LD_EXP 98
95215: PUSH
95216: LD_EXP 112
95220: AND
95221: IFFALSE 95319
95223: GO 95225
95225: DISABLE
95226: LD_INT 0
95228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95229: LD_ADDR_VAR 0 1
95233: PUSH
95234: LD_INT 22
95236: PUSH
95237: LD_OWVAR 2
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 21
95248: PUSH
95249: LD_INT 1
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: PPUSH
95260: CALL_OW 69
95264: ST_TO_ADDR
// if not tmp then
95265: LD_VAR 0 1
95269: NOT
95270: IFFALSE 95274
// exit ;
95272: GO 95319
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95274: LD_VAR 0 1
95278: PUSH
95279: LD_INT 1
95281: PPUSH
95282: LD_VAR 0 1
95286: PPUSH
95287: CALL_OW 12
95291: ARRAY
95292: PPUSH
95293: LD_INT 1
95295: PPUSH
95296: LD_INT 4
95298: PPUSH
95299: CALL_OW 12
95303: PPUSH
95304: LD_INT 3000
95306: PPUSH
95307: LD_INT 9000
95309: PPUSH
95310: CALL_OW 12
95314: PPUSH
95315: CALL_OW 492
// end ;
95319: PPOPN 1
95321: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95322: LD_EXP 98
95326: PUSH
95327: LD_EXP 113
95331: AND
95332: IFFALSE 95352
95334: GO 95336
95336: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95337: LD_INT 1
95339: PPUSH
95340: LD_OWVAR 2
95344: PPUSH
95345: LD_INT 0
95347: PPUSH
95348: CALL_OW 324
95352: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95353: LD_EXP 98
95357: PUSH
95358: LD_EXP 114
95362: AND
95363: IFFALSE 95446
95365: GO 95367
95367: DISABLE
95368: LD_INT 0
95370: PPUSH
95371: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95372: LD_ADDR_VAR 0 2
95376: PUSH
95377: LD_INT 22
95379: PUSH
95380: LD_OWVAR 2
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PUSH
95389: LD_INT 21
95391: PUSH
95392: LD_INT 3
95394: PUSH
95395: EMPTY
95396: LIST
95397: LIST
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PPUSH
95403: CALL_OW 69
95407: ST_TO_ADDR
// if not tmp then
95408: LD_VAR 0 2
95412: NOT
95413: IFFALSE 95417
// exit ;
95415: GO 95446
// for i in tmp do
95417: LD_ADDR_VAR 0 1
95421: PUSH
95422: LD_VAR 0 2
95426: PUSH
95427: FOR_IN
95428: IFFALSE 95444
// SetBLevel ( i , 10 ) ;
95430: LD_VAR 0 1
95434: PPUSH
95435: LD_INT 10
95437: PPUSH
95438: CALL_OW 241
95442: GO 95427
95444: POP
95445: POP
// end ;
95446: PPOPN 2
95448: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95449: LD_EXP 98
95453: PUSH
95454: LD_EXP 115
95458: AND
95459: IFFALSE 95570
95461: GO 95463
95463: DISABLE
95464: LD_INT 0
95466: PPUSH
95467: PPUSH
95468: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95469: LD_ADDR_VAR 0 3
95473: PUSH
95474: LD_INT 22
95476: PUSH
95477: LD_OWVAR 2
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PUSH
95486: LD_INT 25
95488: PUSH
95489: LD_INT 1
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: EMPTY
95497: LIST
95498: LIST
95499: PPUSH
95500: CALL_OW 69
95504: ST_TO_ADDR
// if not tmp then
95505: LD_VAR 0 3
95509: NOT
95510: IFFALSE 95514
// exit ;
95512: GO 95570
// un := tmp [ rand ( 1 , tmp ) ] ;
95514: LD_ADDR_VAR 0 2
95518: PUSH
95519: LD_VAR 0 3
95523: PUSH
95524: LD_INT 1
95526: PPUSH
95527: LD_VAR 0 3
95531: PPUSH
95532: CALL_OW 12
95536: ARRAY
95537: ST_TO_ADDR
// if Crawls ( un ) then
95538: LD_VAR 0 2
95542: PPUSH
95543: CALL_OW 318
95547: IFFALSE 95558
// ComWalk ( un ) ;
95549: LD_VAR 0 2
95553: PPUSH
95554: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95558: LD_VAR 0 2
95562: PPUSH
95563: LD_INT 5
95565: PPUSH
95566: CALL_OW 336
// end ;
95570: PPOPN 3
95572: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
95573: LD_EXP 98
95577: PUSH
95578: LD_EXP 116
95582: AND
95583: PUSH
95584: LD_OWVAR 67
95588: PUSH
95589: LD_INT 3
95591: LESS
95592: AND
95593: IFFALSE 95612
95595: GO 95597
95597: DISABLE
// Difficulty := Difficulty + 1 ;
95598: LD_ADDR_OWVAR 67
95602: PUSH
95603: LD_OWVAR 67
95607: PUSH
95608: LD_INT 1
95610: PLUS
95611: ST_TO_ADDR
95612: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95613: LD_EXP 98
95617: PUSH
95618: LD_EXP 117
95622: AND
95623: IFFALSE 95726
95625: GO 95627
95627: DISABLE
95628: LD_INT 0
95630: PPUSH
// begin for i := 1 to 5 do
95631: LD_ADDR_VAR 0 1
95635: PUSH
95636: DOUBLE
95637: LD_INT 1
95639: DEC
95640: ST_TO_ADDR
95641: LD_INT 5
95643: PUSH
95644: FOR_TO
95645: IFFALSE 95724
// begin uc_nation := nation_nature ;
95647: LD_ADDR_OWVAR 21
95651: PUSH
95652: LD_INT 0
95654: ST_TO_ADDR
// uc_side := 0 ;
95655: LD_ADDR_OWVAR 20
95659: PUSH
95660: LD_INT 0
95662: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95663: LD_ADDR_OWVAR 29
95667: PUSH
95668: LD_INT 12
95670: PUSH
95671: LD_INT 12
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: ST_TO_ADDR
// hc_agressivity := 20 ;
95678: LD_ADDR_OWVAR 35
95682: PUSH
95683: LD_INT 20
95685: ST_TO_ADDR
// hc_class := class_tiger ;
95686: LD_ADDR_OWVAR 28
95690: PUSH
95691: LD_INT 14
95693: ST_TO_ADDR
// hc_gallery :=  ;
95694: LD_ADDR_OWVAR 33
95698: PUSH
95699: LD_STRING 
95701: ST_TO_ADDR
// hc_name :=  ;
95702: LD_ADDR_OWVAR 26
95706: PUSH
95707: LD_STRING 
95709: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95710: CALL_OW 44
95714: PPUSH
95715: LD_INT 0
95717: PPUSH
95718: CALL_OW 51
// end ;
95722: GO 95644
95724: POP
95725: POP
// end ;
95726: PPOPN 1
95728: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95729: LD_EXP 98
95733: PUSH
95734: LD_EXP 118
95738: AND
95739: IFFALSE 95748
95741: GO 95743
95743: DISABLE
// StreamSibBomb ;
95744: CALL 95749 0 0
95748: END
// export function StreamSibBomb ; var i , x , y ; begin
95749: LD_INT 0
95751: PPUSH
95752: PPUSH
95753: PPUSH
95754: PPUSH
// result := false ;
95755: LD_ADDR_VAR 0 1
95759: PUSH
95760: LD_INT 0
95762: ST_TO_ADDR
// for i := 1 to 16 do
95763: LD_ADDR_VAR 0 2
95767: PUSH
95768: DOUBLE
95769: LD_INT 1
95771: DEC
95772: ST_TO_ADDR
95773: LD_INT 16
95775: PUSH
95776: FOR_TO
95777: IFFALSE 95976
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95779: LD_ADDR_VAR 0 3
95783: PUSH
95784: LD_INT 10
95786: PUSH
95787: LD_INT 20
95789: PUSH
95790: LD_INT 30
95792: PUSH
95793: LD_INT 40
95795: PUSH
95796: LD_INT 50
95798: PUSH
95799: LD_INT 60
95801: PUSH
95802: LD_INT 70
95804: PUSH
95805: LD_INT 80
95807: PUSH
95808: LD_INT 90
95810: PUSH
95811: LD_INT 100
95813: PUSH
95814: LD_INT 110
95816: PUSH
95817: LD_INT 120
95819: PUSH
95820: LD_INT 130
95822: PUSH
95823: LD_INT 140
95825: PUSH
95826: LD_INT 150
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: LIST
95836: LIST
95837: LIST
95838: LIST
95839: LIST
95840: LIST
95841: LIST
95842: LIST
95843: LIST
95844: LIST
95845: PUSH
95846: LD_INT 1
95848: PPUSH
95849: LD_INT 15
95851: PPUSH
95852: CALL_OW 12
95856: ARRAY
95857: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95858: LD_ADDR_VAR 0 4
95862: PUSH
95863: LD_INT 10
95865: PUSH
95866: LD_INT 20
95868: PUSH
95869: LD_INT 30
95871: PUSH
95872: LD_INT 40
95874: PUSH
95875: LD_INT 50
95877: PUSH
95878: LD_INT 60
95880: PUSH
95881: LD_INT 70
95883: PUSH
95884: LD_INT 80
95886: PUSH
95887: LD_INT 90
95889: PUSH
95890: LD_INT 100
95892: PUSH
95893: LD_INT 110
95895: PUSH
95896: LD_INT 120
95898: PUSH
95899: LD_INT 130
95901: PUSH
95902: LD_INT 140
95904: PUSH
95905: LD_INT 150
95907: PUSH
95908: EMPTY
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 1
95927: PPUSH
95928: LD_INT 15
95930: PPUSH
95931: CALL_OW 12
95935: ARRAY
95936: ST_TO_ADDR
// if ValidHex ( x , y ) then
95937: LD_VAR 0 3
95941: PPUSH
95942: LD_VAR 0 4
95946: PPUSH
95947: CALL_OW 488
95951: IFFALSE 95974
// begin result := [ x , y ] ;
95953: LD_ADDR_VAR 0 1
95957: PUSH
95958: LD_VAR 0 3
95962: PUSH
95963: LD_VAR 0 4
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: ST_TO_ADDR
// break ;
95972: GO 95976
// end ; end ;
95974: GO 95776
95976: POP
95977: POP
// if result then
95978: LD_VAR 0 1
95982: IFFALSE 96042
// begin ToLua ( playSibBomb() ) ;
95984: LD_STRING playSibBomb()
95986: PPUSH
95987: CALL_OW 559
// wait ( 0 0$14 ) ;
95991: LD_INT 490
95993: PPUSH
95994: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95998: LD_VAR 0 1
96002: PUSH
96003: LD_INT 1
96005: ARRAY
96006: PPUSH
96007: LD_VAR 0 1
96011: PUSH
96012: LD_INT 2
96014: ARRAY
96015: PPUSH
96016: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96020: LD_VAR 0 1
96024: PUSH
96025: LD_INT 1
96027: ARRAY
96028: PPUSH
96029: LD_VAR 0 1
96033: PUSH
96034: LD_INT 2
96036: ARRAY
96037: PPUSH
96038: CALL_OW 429
// end ; end ;
96042: LD_VAR 0 1
96046: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96047: LD_EXP 98
96051: PUSH
96052: LD_EXP 120
96056: AND
96057: IFFALSE 96069
96059: GO 96061
96061: DISABLE
// YouLost (  ) ;
96062: LD_STRING 
96064: PPUSH
96065: CALL_OW 104
96069: END
// every 0 0$1 trigger StreamModeActive and sFog do
96070: LD_EXP 98
96074: PUSH
96075: LD_EXP 119
96079: AND
96080: IFFALSE 96094
96082: GO 96084
96084: DISABLE
// FogOff ( your_side ) ;
96085: LD_OWVAR 2
96089: PPUSH
96090: CALL_OW 344
96094: END
// every 0 0$1 trigger StreamModeActive and sSun do
96095: LD_EXP 98
96099: PUSH
96100: LD_EXP 121
96104: AND
96105: IFFALSE 96133
96107: GO 96109
96109: DISABLE
// begin solar_recharge_percent := 0 ;
96110: LD_ADDR_OWVAR 79
96114: PUSH
96115: LD_INT 0
96117: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96118: LD_INT 10500
96120: PPUSH
96121: CALL_OW 67
// solar_recharge_percent := 100 ;
96125: LD_ADDR_OWVAR 79
96129: PUSH
96130: LD_INT 100
96132: ST_TO_ADDR
// end ;
96133: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96134: LD_EXP 98
96138: PUSH
96139: LD_EXP 122
96143: AND
96144: IFFALSE 96383
96146: GO 96148
96148: DISABLE
96149: LD_INT 0
96151: PPUSH
96152: PPUSH
96153: PPUSH
// begin tmp := [ ] ;
96154: LD_ADDR_VAR 0 3
96158: PUSH
96159: EMPTY
96160: ST_TO_ADDR
// for i := 1 to 6 do
96161: LD_ADDR_VAR 0 1
96165: PUSH
96166: DOUBLE
96167: LD_INT 1
96169: DEC
96170: ST_TO_ADDR
96171: LD_INT 6
96173: PUSH
96174: FOR_TO
96175: IFFALSE 96280
// begin uc_nation := nation_nature ;
96177: LD_ADDR_OWVAR 21
96181: PUSH
96182: LD_INT 0
96184: ST_TO_ADDR
// uc_side := 0 ;
96185: LD_ADDR_OWVAR 20
96189: PUSH
96190: LD_INT 0
96192: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96193: LD_ADDR_OWVAR 29
96197: PUSH
96198: LD_INT 12
96200: PUSH
96201: LD_INT 12
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: ST_TO_ADDR
// hc_agressivity := 20 ;
96208: LD_ADDR_OWVAR 35
96212: PUSH
96213: LD_INT 20
96215: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96216: LD_ADDR_OWVAR 28
96220: PUSH
96221: LD_INT 17
96223: ST_TO_ADDR
// hc_gallery :=  ;
96224: LD_ADDR_OWVAR 33
96228: PUSH
96229: LD_STRING 
96231: ST_TO_ADDR
// hc_name :=  ;
96232: LD_ADDR_OWVAR 26
96236: PUSH
96237: LD_STRING 
96239: ST_TO_ADDR
// un := CreateHuman ;
96240: LD_ADDR_VAR 0 2
96244: PUSH
96245: CALL_OW 44
96249: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96250: LD_VAR 0 2
96254: PPUSH
96255: LD_INT 1
96257: PPUSH
96258: CALL_OW 51
// tmp := tmp ^ un ;
96262: LD_ADDR_VAR 0 3
96266: PUSH
96267: LD_VAR 0 3
96271: PUSH
96272: LD_VAR 0 2
96276: ADD
96277: ST_TO_ADDR
// end ;
96278: GO 96174
96280: POP
96281: POP
// repeat wait ( 0 0$1 ) ;
96282: LD_INT 35
96284: PPUSH
96285: CALL_OW 67
// for un in tmp do
96289: LD_ADDR_VAR 0 2
96293: PUSH
96294: LD_VAR 0 3
96298: PUSH
96299: FOR_IN
96300: IFFALSE 96374
// begin if IsDead ( un ) then
96302: LD_VAR 0 2
96306: PPUSH
96307: CALL_OW 301
96311: IFFALSE 96331
// begin tmp := tmp diff un ;
96313: LD_ADDR_VAR 0 3
96317: PUSH
96318: LD_VAR 0 3
96322: PUSH
96323: LD_VAR 0 2
96327: DIFF
96328: ST_TO_ADDR
// continue ;
96329: GO 96299
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96331: LD_VAR 0 2
96335: PPUSH
96336: LD_INT 3
96338: PUSH
96339: LD_INT 22
96341: PUSH
96342: LD_INT 0
96344: PUSH
96345: EMPTY
96346: LIST
96347: LIST
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: PPUSH
96353: CALL_OW 69
96357: PPUSH
96358: LD_VAR 0 2
96362: PPUSH
96363: CALL_OW 74
96367: PPUSH
96368: CALL_OW 115
// end ;
96372: GO 96299
96374: POP
96375: POP
// until not tmp ;
96376: LD_VAR 0 3
96380: NOT
96381: IFFALSE 96282
// end ;
96383: PPOPN 3
96385: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96386: LD_EXP 98
96390: PUSH
96391: LD_EXP 123
96395: AND
96396: IFFALSE 96450
96398: GO 96400
96400: DISABLE
// begin ToLua ( displayTroll(); ) ;
96401: LD_STRING displayTroll();
96403: PPUSH
96404: CALL_OW 559
// wait ( 3 3$00 ) ;
96408: LD_INT 6300
96410: PPUSH
96411: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96415: LD_STRING hideTroll();
96417: PPUSH
96418: CALL_OW 559
// wait ( 1 1$00 ) ;
96422: LD_INT 2100
96424: PPUSH
96425: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96429: LD_STRING displayTroll();
96431: PPUSH
96432: CALL_OW 559
// wait ( 1 1$00 ) ;
96436: LD_INT 2100
96438: PPUSH
96439: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96443: LD_STRING hideTroll();
96445: PPUSH
96446: CALL_OW 559
// end ;
96450: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96451: LD_EXP 98
96455: PUSH
96456: LD_EXP 124
96460: AND
96461: IFFALSE 96524
96463: GO 96465
96465: DISABLE
96466: LD_INT 0
96468: PPUSH
// begin p := 0 ;
96469: LD_ADDR_VAR 0 1
96473: PUSH
96474: LD_INT 0
96476: ST_TO_ADDR
// repeat game_speed := 1 ;
96477: LD_ADDR_OWVAR 65
96481: PUSH
96482: LD_INT 1
96484: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96485: LD_INT 35
96487: PPUSH
96488: CALL_OW 67
// p := p + 1 ;
96492: LD_ADDR_VAR 0 1
96496: PUSH
96497: LD_VAR 0 1
96501: PUSH
96502: LD_INT 1
96504: PLUS
96505: ST_TO_ADDR
// until p >= 60 ;
96506: LD_VAR 0 1
96510: PUSH
96511: LD_INT 60
96513: GREATEREQUAL
96514: IFFALSE 96477
// game_speed := 4 ;
96516: LD_ADDR_OWVAR 65
96520: PUSH
96521: LD_INT 4
96523: ST_TO_ADDR
// end ;
96524: PPOPN 1
96526: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96527: LD_EXP 98
96531: PUSH
96532: LD_EXP 125
96536: AND
96537: IFFALSE 96683
96539: GO 96541
96541: DISABLE
96542: LD_INT 0
96544: PPUSH
96545: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96546: LD_ADDR_VAR 0 1
96550: PUSH
96551: LD_INT 22
96553: PUSH
96554: LD_OWVAR 2
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: LD_INT 2
96565: PUSH
96566: LD_INT 30
96568: PUSH
96569: LD_INT 0
96571: PUSH
96572: EMPTY
96573: LIST
96574: LIST
96575: PUSH
96576: LD_INT 30
96578: PUSH
96579: LD_INT 1
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: EMPTY
96587: LIST
96588: LIST
96589: LIST
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PPUSH
96595: CALL_OW 69
96599: ST_TO_ADDR
// if not depot then
96600: LD_VAR 0 1
96604: NOT
96605: IFFALSE 96609
// exit ;
96607: GO 96683
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96609: LD_ADDR_VAR 0 2
96613: PUSH
96614: LD_VAR 0 1
96618: PUSH
96619: LD_INT 1
96621: PPUSH
96622: LD_VAR 0 1
96626: PPUSH
96627: CALL_OW 12
96631: ARRAY
96632: PPUSH
96633: CALL_OW 274
96637: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96638: LD_VAR 0 2
96642: PPUSH
96643: LD_INT 1
96645: PPUSH
96646: LD_INT 0
96648: PPUSH
96649: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96653: LD_VAR 0 2
96657: PPUSH
96658: LD_INT 2
96660: PPUSH
96661: LD_INT 0
96663: PPUSH
96664: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96668: LD_VAR 0 2
96672: PPUSH
96673: LD_INT 3
96675: PPUSH
96676: LD_INT 0
96678: PPUSH
96679: CALL_OW 277
// end ;
96683: PPOPN 2
96685: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96686: LD_EXP 98
96690: PUSH
96691: LD_EXP 126
96695: AND
96696: IFFALSE 96793
96698: GO 96700
96700: DISABLE
96701: LD_INT 0
96703: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96704: LD_ADDR_VAR 0 1
96708: PUSH
96709: LD_INT 22
96711: PUSH
96712: LD_OWVAR 2
96716: PUSH
96717: EMPTY
96718: LIST
96719: LIST
96720: PUSH
96721: LD_INT 21
96723: PUSH
96724: LD_INT 1
96726: PUSH
96727: EMPTY
96728: LIST
96729: LIST
96730: PUSH
96731: LD_INT 3
96733: PUSH
96734: LD_INT 23
96736: PUSH
96737: LD_INT 0
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: LIST
96752: PPUSH
96753: CALL_OW 69
96757: ST_TO_ADDR
// if not tmp then
96758: LD_VAR 0 1
96762: NOT
96763: IFFALSE 96767
// exit ;
96765: GO 96793
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96767: LD_VAR 0 1
96771: PUSH
96772: LD_INT 1
96774: PPUSH
96775: LD_VAR 0 1
96779: PPUSH
96780: CALL_OW 12
96784: ARRAY
96785: PPUSH
96786: LD_INT 200
96788: PPUSH
96789: CALL_OW 234
// end ;
96793: PPOPN 1
96795: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96796: LD_EXP 98
96800: PUSH
96801: LD_EXP 127
96805: AND
96806: IFFALSE 96885
96808: GO 96810
96810: DISABLE
96811: LD_INT 0
96813: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96814: LD_ADDR_VAR 0 1
96818: PUSH
96819: LD_INT 22
96821: PUSH
96822: LD_OWVAR 2
96826: PUSH
96827: EMPTY
96828: LIST
96829: LIST
96830: PUSH
96831: LD_INT 21
96833: PUSH
96834: LD_INT 2
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PPUSH
96845: CALL_OW 69
96849: ST_TO_ADDR
// if not tmp then
96850: LD_VAR 0 1
96854: NOT
96855: IFFALSE 96859
// exit ;
96857: GO 96885
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96859: LD_VAR 0 1
96863: PUSH
96864: LD_INT 1
96866: PPUSH
96867: LD_VAR 0 1
96871: PPUSH
96872: CALL_OW 12
96876: ARRAY
96877: PPUSH
96878: LD_INT 60
96880: PPUSH
96881: CALL_OW 234
// end ;
96885: PPOPN 1
96887: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96888: LD_EXP 98
96892: PUSH
96893: LD_EXP 128
96897: AND
96898: IFFALSE 96997
96900: GO 96902
96902: DISABLE
96903: LD_INT 0
96905: PPUSH
96906: PPUSH
// begin enable ;
96907: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96908: LD_ADDR_VAR 0 1
96912: PUSH
96913: LD_INT 22
96915: PUSH
96916: LD_OWVAR 2
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: PUSH
96925: LD_INT 61
96927: PUSH
96928: EMPTY
96929: LIST
96930: PUSH
96931: LD_INT 33
96933: PUSH
96934: LD_INT 2
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: LIST
96945: PPUSH
96946: CALL_OW 69
96950: ST_TO_ADDR
// if not tmp then
96951: LD_VAR 0 1
96955: NOT
96956: IFFALSE 96960
// exit ;
96958: GO 96997
// for i in tmp do
96960: LD_ADDR_VAR 0 2
96964: PUSH
96965: LD_VAR 0 1
96969: PUSH
96970: FOR_IN
96971: IFFALSE 96995
// if IsControledBy ( i ) then
96973: LD_VAR 0 2
96977: PPUSH
96978: CALL_OW 312
96982: IFFALSE 96993
// ComUnlink ( i ) ;
96984: LD_VAR 0 2
96988: PPUSH
96989: CALL_OW 136
96993: GO 96970
96995: POP
96996: POP
// end ;
96997: PPOPN 2
96999: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97000: LD_EXP 98
97004: PUSH
97005: LD_EXP 129
97009: AND
97010: IFFALSE 97150
97012: GO 97014
97014: DISABLE
97015: LD_INT 0
97017: PPUSH
97018: PPUSH
// begin ToLua ( displayPowell(); ) ;
97019: LD_STRING displayPowell();
97021: PPUSH
97022: CALL_OW 559
// uc_side := 0 ;
97026: LD_ADDR_OWVAR 20
97030: PUSH
97031: LD_INT 0
97033: ST_TO_ADDR
// uc_nation := 2 ;
97034: LD_ADDR_OWVAR 21
97038: PUSH
97039: LD_INT 2
97041: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97042: LD_ADDR_OWVAR 37
97046: PUSH
97047: LD_INT 14
97049: ST_TO_ADDR
// vc_engine := engine_siberite ;
97050: LD_ADDR_OWVAR 39
97054: PUSH
97055: LD_INT 3
97057: ST_TO_ADDR
// vc_control := control_apeman ;
97058: LD_ADDR_OWVAR 38
97062: PUSH
97063: LD_INT 5
97065: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97066: LD_ADDR_OWVAR 40
97070: PUSH
97071: LD_INT 29
97073: ST_TO_ADDR
// un := CreateVehicle ;
97074: LD_ADDR_VAR 0 2
97078: PUSH
97079: CALL_OW 45
97083: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97084: LD_VAR 0 2
97088: PPUSH
97089: LD_INT 1
97091: PPUSH
97092: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97096: LD_INT 35
97098: PPUSH
97099: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97103: LD_VAR 0 2
97107: PPUSH
97108: LD_INT 22
97110: PUSH
97111: LD_OWVAR 2
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: PPUSH
97120: CALL_OW 69
97124: PPUSH
97125: LD_VAR 0 2
97129: PPUSH
97130: CALL_OW 74
97134: PPUSH
97135: CALL_OW 115
// until IsDead ( un ) ;
97139: LD_VAR 0 2
97143: PPUSH
97144: CALL_OW 301
97148: IFFALSE 97096
// end ;
97150: PPOPN 2
97152: END
// every 0 0$1 trigger StreamModeActive and sStu do
97153: LD_EXP 98
97157: PUSH
97158: LD_EXP 137
97162: AND
97163: IFFALSE 97179
97165: GO 97167
97167: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97168: LD_STRING displayStucuk();
97170: PPUSH
97171: CALL_OW 559
// ResetFog ;
97175: CALL_OW 335
// end ;
97179: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97180: LD_EXP 98
97184: PUSH
97185: LD_EXP 130
97189: AND
97190: IFFALSE 97331
97192: GO 97194
97194: DISABLE
97195: LD_INT 0
97197: PPUSH
97198: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97199: LD_ADDR_VAR 0 2
97203: PUSH
97204: LD_INT 22
97206: PUSH
97207: LD_OWVAR 2
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 21
97218: PUSH
97219: LD_INT 1
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PPUSH
97230: CALL_OW 69
97234: ST_TO_ADDR
// if not tmp then
97235: LD_VAR 0 2
97239: NOT
97240: IFFALSE 97244
// exit ;
97242: GO 97331
// un := tmp [ rand ( 1 , tmp ) ] ;
97244: LD_ADDR_VAR 0 1
97248: PUSH
97249: LD_VAR 0 2
97253: PUSH
97254: LD_INT 1
97256: PPUSH
97257: LD_VAR 0 2
97261: PPUSH
97262: CALL_OW 12
97266: ARRAY
97267: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97268: LD_VAR 0 1
97272: PPUSH
97273: LD_INT 0
97275: PPUSH
97276: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97280: LD_VAR 0 1
97284: PPUSH
97285: LD_OWVAR 3
97289: PUSH
97290: LD_VAR 0 1
97294: DIFF
97295: PPUSH
97296: LD_VAR 0 1
97300: PPUSH
97301: CALL_OW 74
97305: PPUSH
97306: CALL_OW 115
// wait ( 0 0$20 ) ;
97310: LD_INT 700
97312: PPUSH
97313: CALL_OW 67
// SetSide ( un , your_side ) ;
97317: LD_VAR 0 1
97321: PPUSH
97322: LD_OWVAR 2
97326: PPUSH
97327: CALL_OW 235
// end ;
97331: PPOPN 2
97333: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97334: LD_EXP 98
97338: PUSH
97339: LD_EXP 131
97343: AND
97344: IFFALSE 97450
97346: GO 97348
97348: DISABLE
97349: LD_INT 0
97351: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97352: LD_ADDR_VAR 0 1
97356: PUSH
97357: LD_INT 22
97359: PUSH
97360: LD_OWVAR 2
97364: PUSH
97365: EMPTY
97366: LIST
97367: LIST
97368: PUSH
97369: LD_INT 2
97371: PUSH
97372: LD_INT 30
97374: PUSH
97375: LD_INT 0
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 30
97384: PUSH
97385: LD_INT 1
97387: PUSH
97388: EMPTY
97389: LIST
97390: LIST
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: LIST
97396: PUSH
97397: EMPTY
97398: LIST
97399: LIST
97400: PPUSH
97401: CALL_OW 69
97405: ST_TO_ADDR
// if not depot then
97406: LD_VAR 0 1
97410: NOT
97411: IFFALSE 97415
// exit ;
97413: GO 97450
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97415: LD_VAR 0 1
97419: PUSH
97420: LD_INT 1
97422: ARRAY
97423: PPUSH
97424: CALL_OW 250
97428: PPUSH
97429: LD_VAR 0 1
97433: PUSH
97434: LD_INT 1
97436: ARRAY
97437: PPUSH
97438: CALL_OW 251
97442: PPUSH
97443: LD_INT 70
97445: PPUSH
97446: CALL_OW 495
// end ;
97450: PPOPN 1
97452: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97453: LD_EXP 98
97457: PUSH
97458: LD_EXP 132
97462: AND
97463: IFFALSE 97674
97465: GO 97467
97467: DISABLE
97468: LD_INT 0
97470: PPUSH
97471: PPUSH
97472: PPUSH
97473: PPUSH
97474: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97475: LD_ADDR_VAR 0 5
97479: PUSH
97480: LD_INT 22
97482: PUSH
97483: LD_OWVAR 2
97487: PUSH
97488: EMPTY
97489: LIST
97490: LIST
97491: PUSH
97492: LD_INT 21
97494: PUSH
97495: LD_INT 1
97497: PUSH
97498: EMPTY
97499: LIST
97500: LIST
97501: PUSH
97502: EMPTY
97503: LIST
97504: LIST
97505: PPUSH
97506: CALL_OW 69
97510: ST_TO_ADDR
// if not tmp then
97511: LD_VAR 0 5
97515: NOT
97516: IFFALSE 97520
// exit ;
97518: GO 97674
// for i in tmp do
97520: LD_ADDR_VAR 0 1
97524: PUSH
97525: LD_VAR 0 5
97529: PUSH
97530: FOR_IN
97531: IFFALSE 97672
// begin d := rand ( 0 , 5 ) ;
97533: LD_ADDR_VAR 0 4
97537: PUSH
97538: LD_INT 0
97540: PPUSH
97541: LD_INT 5
97543: PPUSH
97544: CALL_OW 12
97548: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97549: LD_ADDR_VAR 0 2
97553: PUSH
97554: LD_VAR 0 1
97558: PPUSH
97559: CALL_OW 250
97563: PPUSH
97564: LD_VAR 0 4
97568: PPUSH
97569: LD_INT 3
97571: PPUSH
97572: LD_INT 12
97574: PPUSH
97575: CALL_OW 12
97579: PPUSH
97580: CALL_OW 272
97584: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97585: LD_ADDR_VAR 0 3
97589: PUSH
97590: LD_VAR 0 1
97594: PPUSH
97595: CALL_OW 251
97599: PPUSH
97600: LD_VAR 0 4
97604: PPUSH
97605: LD_INT 3
97607: PPUSH
97608: LD_INT 12
97610: PPUSH
97611: CALL_OW 12
97615: PPUSH
97616: CALL_OW 273
97620: ST_TO_ADDR
// if ValidHex ( x , y ) then
97621: LD_VAR 0 2
97625: PPUSH
97626: LD_VAR 0 3
97630: PPUSH
97631: CALL_OW 488
97635: IFFALSE 97670
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97637: LD_VAR 0 1
97641: PPUSH
97642: LD_VAR 0 2
97646: PPUSH
97647: LD_VAR 0 3
97651: PPUSH
97652: LD_INT 3
97654: PPUSH
97655: LD_INT 6
97657: PPUSH
97658: CALL_OW 12
97662: PPUSH
97663: LD_INT 1
97665: PPUSH
97666: CALL_OW 483
// end ;
97670: GO 97530
97672: POP
97673: POP
// end ;
97674: PPOPN 5
97676: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97677: LD_EXP 98
97681: PUSH
97682: LD_EXP 133
97686: AND
97687: IFFALSE 97781
97689: GO 97691
97691: DISABLE
97692: LD_INT 0
97694: PPUSH
97695: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97696: LD_ADDR_VAR 0 2
97700: PUSH
97701: LD_INT 22
97703: PUSH
97704: LD_OWVAR 2
97708: PUSH
97709: EMPTY
97710: LIST
97711: LIST
97712: PUSH
97713: LD_INT 32
97715: PUSH
97716: LD_INT 1
97718: PUSH
97719: EMPTY
97720: LIST
97721: LIST
97722: PUSH
97723: LD_INT 21
97725: PUSH
97726: LD_INT 2
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: EMPTY
97734: LIST
97735: LIST
97736: LIST
97737: PPUSH
97738: CALL_OW 69
97742: ST_TO_ADDR
// if not tmp then
97743: LD_VAR 0 2
97747: NOT
97748: IFFALSE 97752
// exit ;
97750: GO 97781
// for i in tmp do
97752: LD_ADDR_VAR 0 1
97756: PUSH
97757: LD_VAR 0 2
97761: PUSH
97762: FOR_IN
97763: IFFALSE 97779
// SetFuel ( i , 0 ) ;
97765: LD_VAR 0 1
97769: PPUSH
97770: LD_INT 0
97772: PPUSH
97773: CALL_OW 240
97777: GO 97762
97779: POP
97780: POP
// end ;
97781: PPOPN 2
97783: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97784: LD_EXP 98
97788: PUSH
97789: LD_EXP 134
97793: AND
97794: IFFALSE 97860
97796: GO 97798
97798: DISABLE
97799: LD_INT 0
97801: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97802: LD_ADDR_VAR 0 1
97806: PUSH
97807: LD_INT 22
97809: PUSH
97810: LD_OWVAR 2
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PUSH
97819: LD_INT 30
97821: PUSH
97822: LD_INT 29
97824: PUSH
97825: EMPTY
97826: LIST
97827: LIST
97828: PUSH
97829: EMPTY
97830: LIST
97831: LIST
97832: PPUSH
97833: CALL_OW 69
97837: ST_TO_ADDR
// if not tmp then
97838: LD_VAR 0 1
97842: NOT
97843: IFFALSE 97847
// exit ;
97845: GO 97860
// DestroyUnit ( tmp [ 1 ] ) ;
97847: LD_VAR 0 1
97851: PUSH
97852: LD_INT 1
97854: ARRAY
97855: PPUSH
97856: CALL_OW 65
// end ;
97860: PPOPN 1
97862: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97863: LD_EXP 98
97867: PUSH
97868: LD_EXP 136
97872: AND
97873: IFFALSE 98002
97875: GO 97877
97877: DISABLE
97878: LD_INT 0
97880: PPUSH
// begin uc_side := 0 ;
97881: LD_ADDR_OWVAR 20
97885: PUSH
97886: LD_INT 0
97888: ST_TO_ADDR
// uc_nation := nation_arabian ;
97889: LD_ADDR_OWVAR 21
97893: PUSH
97894: LD_INT 2
97896: ST_TO_ADDR
// hc_gallery :=  ;
97897: LD_ADDR_OWVAR 33
97901: PUSH
97902: LD_STRING 
97904: ST_TO_ADDR
// hc_name :=  ;
97905: LD_ADDR_OWVAR 26
97909: PUSH
97910: LD_STRING 
97912: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97913: LD_INT 1
97915: PPUSH
97916: LD_INT 11
97918: PPUSH
97919: LD_INT 10
97921: PPUSH
97922: CALL_OW 380
// un := CreateHuman ;
97926: LD_ADDR_VAR 0 1
97930: PUSH
97931: CALL_OW 44
97935: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97936: LD_VAR 0 1
97940: PPUSH
97941: LD_INT 1
97943: PPUSH
97944: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97948: LD_INT 35
97950: PPUSH
97951: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97955: LD_VAR 0 1
97959: PPUSH
97960: LD_INT 22
97962: PUSH
97963: LD_OWVAR 2
97967: PUSH
97968: EMPTY
97969: LIST
97970: LIST
97971: PPUSH
97972: CALL_OW 69
97976: PPUSH
97977: LD_VAR 0 1
97981: PPUSH
97982: CALL_OW 74
97986: PPUSH
97987: CALL_OW 115
// until IsDead ( un ) ;
97991: LD_VAR 0 1
97995: PPUSH
97996: CALL_OW 301
98000: IFFALSE 97948
// end ;
98002: PPOPN 1
98004: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98005: LD_EXP 98
98009: PUSH
98010: LD_EXP 138
98014: AND
98015: IFFALSE 98027
98017: GO 98019
98019: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98020: LD_STRING earthquake(getX(game), 0, 32)
98022: PPUSH
98023: CALL_OW 559
98027: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98028: LD_EXP 98
98032: PUSH
98033: LD_EXP 139
98037: AND
98038: IFFALSE 98129
98040: GO 98042
98042: DISABLE
98043: LD_INT 0
98045: PPUSH
// begin enable ;
98046: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98047: LD_ADDR_VAR 0 1
98051: PUSH
98052: LD_INT 22
98054: PUSH
98055: LD_OWVAR 2
98059: PUSH
98060: EMPTY
98061: LIST
98062: LIST
98063: PUSH
98064: LD_INT 21
98066: PUSH
98067: LD_INT 2
98069: PUSH
98070: EMPTY
98071: LIST
98072: LIST
98073: PUSH
98074: LD_INT 33
98076: PUSH
98077: LD_INT 3
98079: PUSH
98080: EMPTY
98081: LIST
98082: LIST
98083: PUSH
98084: EMPTY
98085: LIST
98086: LIST
98087: LIST
98088: PPUSH
98089: CALL_OW 69
98093: ST_TO_ADDR
// if not tmp then
98094: LD_VAR 0 1
98098: NOT
98099: IFFALSE 98103
// exit ;
98101: GO 98129
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98103: LD_VAR 0 1
98107: PUSH
98108: LD_INT 1
98110: PPUSH
98111: LD_VAR 0 1
98115: PPUSH
98116: CALL_OW 12
98120: ARRAY
98121: PPUSH
98122: LD_INT 1
98124: PPUSH
98125: CALL_OW 234
// end ;
98129: PPOPN 1
98131: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98132: LD_EXP 98
98136: PUSH
98137: LD_EXP 140
98141: AND
98142: IFFALSE 98283
98144: GO 98146
98146: DISABLE
98147: LD_INT 0
98149: PPUSH
98150: PPUSH
98151: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98152: LD_ADDR_VAR 0 3
98156: PUSH
98157: LD_INT 22
98159: PUSH
98160: LD_OWVAR 2
98164: PUSH
98165: EMPTY
98166: LIST
98167: LIST
98168: PUSH
98169: LD_INT 25
98171: PUSH
98172: LD_INT 1
98174: PUSH
98175: EMPTY
98176: LIST
98177: LIST
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PPUSH
98183: CALL_OW 69
98187: ST_TO_ADDR
// if not tmp then
98188: LD_VAR 0 3
98192: NOT
98193: IFFALSE 98197
// exit ;
98195: GO 98283
// un := tmp [ rand ( 1 , tmp ) ] ;
98197: LD_ADDR_VAR 0 2
98201: PUSH
98202: LD_VAR 0 3
98206: PUSH
98207: LD_INT 1
98209: PPUSH
98210: LD_VAR 0 3
98214: PPUSH
98215: CALL_OW 12
98219: ARRAY
98220: ST_TO_ADDR
// if Crawls ( un ) then
98221: LD_VAR 0 2
98225: PPUSH
98226: CALL_OW 318
98230: IFFALSE 98241
// ComWalk ( un ) ;
98232: LD_VAR 0 2
98236: PPUSH
98237: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98241: LD_VAR 0 2
98245: PPUSH
98246: LD_INT 9
98248: PPUSH
98249: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98253: LD_INT 28
98255: PPUSH
98256: LD_OWVAR 2
98260: PPUSH
98261: LD_INT 2
98263: PPUSH
98264: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98268: LD_INT 29
98270: PPUSH
98271: LD_OWVAR 2
98275: PPUSH
98276: LD_INT 2
98278: PPUSH
98279: CALL_OW 322
// end ;
98283: PPOPN 3
98285: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98286: LD_EXP 98
98290: PUSH
98291: LD_EXP 141
98295: AND
98296: IFFALSE 98407
98298: GO 98300
98300: DISABLE
98301: LD_INT 0
98303: PPUSH
98304: PPUSH
98305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98306: LD_ADDR_VAR 0 3
98310: PUSH
98311: LD_INT 22
98313: PUSH
98314: LD_OWVAR 2
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 25
98325: PUSH
98326: LD_INT 1
98328: PUSH
98329: EMPTY
98330: LIST
98331: LIST
98332: PUSH
98333: EMPTY
98334: LIST
98335: LIST
98336: PPUSH
98337: CALL_OW 69
98341: ST_TO_ADDR
// if not tmp then
98342: LD_VAR 0 3
98346: NOT
98347: IFFALSE 98351
// exit ;
98349: GO 98407
// un := tmp [ rand ( 1 , tmp ) ] ;
98351: LD_ADDR_VAR 0 2
98355: PUSH
98356: LD_VAR 0 3
98360: PUSH
98361: LD_INT 1
98363: PPUSH
98364: LD_VAR 0 3
98368: PPUSH
98369: CALL_OW 12
98373: ARRAY
98374: ST_TO_ADDR
// if Crawls ( un ) then
98375: LD_VAR 0 2
98379: PPUSH
98380: CALL_OW 318
98384: IFFALSE 98395
// ComWalk ( un ) ;
98386: LD_VAR 0 2
98390: PPUSH
98391: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98395: LD_VAR 0 2
98399: PPUSH
98400: LD_INT 8
98402: PPUSH
98403: CALL_OW 336
// end ;
98407: PPOPN 3
98409: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98410: LD_EXP 98
98414: PUSH
98415: LD_EXP 142
98419: AND
98420: IFFALSE 98564
98422: GO 98424
98424: DISABLE
98425: LD_INT 0
98427: PPUSH
98428: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98429: LD_ADDR_VAR 0 2
98433: PUSH
98434: LD_INT 22
98436: PUSH
98437: LD_OWVAR 2
98441: PUSH
98442: EMPTY
98443: LIST
98444: LIST
98445: PUSH
98446: LD_INT 21
98448: PUSH
98449: LD_INT 2
98451: PUSH
98452: EMPTY
98453: LIST
98454: LIST
98455: PUSH
98456: LD_INT 2
98458: PUSH
98459: LD_INT 34
98461: PUSH
98462: LD_INT 12
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 34
98471: PUSH
98472: LD_INT 51
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: PUSH
98479: LD_INT 34
98481: PUSH
98482: LD_INT 32
98484: PUSH
98485: EMPTY
98486: LIST
98487: LIST
98488: PUSH
98489: EMPTY
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: LIST
98499: PPUSH
98500: CALL_OW 69
98504: ST_TO_ADDR
// if not tmp then
98505: LD_VAR 0 2
98509: NOT
98510: IFFALSE 98514
// exit ;
98512: GO 98564
// for i in tmp do
98514: LD_ADDR_VAR 0 1
98518: PUSH
98519: LD_VAR 0 2
98523: PUSH
98524: FOR_IN
98525: IFFALSE 98562
// if GetCargo ( i , mat_artifact ) = 0 then
98527: LD_VAR 0 1
98531: PPUSH
98532: LD_INT 4
98534: PPUSH
98535: CALL_OW 289
98539: PUSH
98540: LD_INT 0
98542: EQUAL
98543: IFFALSE 98560
// SetCargo ( i , mat_siberit , 100 ) ;
98545: LD_VAR 0 1
98549: PPUSH
98550: LD_INT 3
98552: PPUSH
98553: LD_INT 100
98555: PPUSH
98556: CALL_OW 290
98560: GO 98524
98562: POP
98563: POP
// end ;
98564: PPOPN 2
98566: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98567: LD_EXP 98
98571: PUSH
98572: LD_EXP 143
98576: AND
98577: IFFALSE 98760
98579: GO 98581
98581: DISABLE
98582: LD_INT 0
98584: PPUSH
98585: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98586: LD_ADDR_VAR 0 2
98590: PUSH
98591: LD_INT 22
98593: PUSH
98594: LD_OWVAR 2
98598: PUSH
98599: EMPTY
98600: LIST
98601: LIST
98602: PPUSH
98603: CALL_OW 69
98607: ST_TO_ADDR
// if not tmp then
98608: LD_VAR 0 2
98612: NOT
98613: IFFALSE 98617
// exit ;
98615: GO 98760
// for i := 1 to 2 do
98617: LD_ADDR_VAR 0 1
98621: PUSH
98622: DOUBLE
98623: LD_INT 1
98625: DEC
98626: ST_TO_ADDR
98627: LD_INT 2
98629: PUSH
98630: FOR_TO
98631: IFFALSE 98758
// begin uc_side := your_side ;
98633: LD_ADDR_OWVAR 20
98637: PUSH
98638: LD_OWVAR 2
98642: ST_TO_ADDR
// uc_nation := nation_american ;
98643: LD_ADDR_OWVAR 21
98647: PUSH
98648: LD_INT 1
98650: ST_TO_ADDR
// vc_chassis := us_morphling ;
98651: LD_ADDR_OWVAR 37
98655: PUSH
98656: LD_INT 5
98658: ST_TO_ADDR
// vc_engine := engine_siberite ;
98659: LD_ADDR_OWVAR 39
98663: PUSH
98664: LD_INT 3
98666: ST_TO_ADDR
// vc_control := control_computer ;
98667: LD_ADDR_OWVAR 38
98671: PUSH
98672: LD_INT 3
98674: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98675: LD_ADDR_OWVAR 40
98679: PUSH
98680: LD_INT 10
98682: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98683: LD_VAR 0 2
98687: PUSH
98688: LD_INT 1
98690: ARRAY
98691: PPUSH
98692: CALL_OW 310
98696: NOT
98697: IFFALSE 98744
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98699: CALL_OW 45
98703: PPUSH
98704: LD_VAR 0 2
98708: PUSH
98709: LD_INT 1
98711: ARRAY
98712: PPUSH
98713: CALL_OW 250
98717: PPUSH
98718: LD_VAR 0 2
98722: PUSH
98723: LD_INT 1
98725: ARRAY
98726: PPUSH
98727: CALL_OW 251
98731: PPUSH
98732: LD_INT 12
98734: PPUSH
98735: LD_INT 1
98737: PPUSH
98738: CALL_OW 50
98742: GO 98756
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98744: CALL_OW 45
98748: PPUSH
98749: LD_INT 1
98751: PPUSH
98752: CALL_OW 51
// end ;
98756: GO 98630
98758: POP
98759: POP
// end ;
98760: PPOPN 2
98762: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98763: LD_EXP 98
98767: PUSH
98768: LD_EXP 144
98772: AND
98773: IFFALSE 98995
98775: GO 98777
98777: DISABLE
98778: LD_INT 0
98780: PPUSH
98781: PPUSH
98782: PPUSH
98783: PPUSH
98784: PPUSH
98785: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98786: LD_ADDR_VAR 0 6
98790: PUSH
98791: LD_INT 22
98793: PUSH
98794: LD_OWVAR 2
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 21
98805: PUSH
98806: LD_INT 1
98808: PUSH
98809: EMPTY
98810: LIST
98811: LIST
98812: PUSH
98813: LD_INT 3
98815: PUSH
98816: LD_INT 23
98818: PUSH
98819: LD_INT 0
98821: PUSH
98822: EMPTY
98823: LIST
98824: LIST
98825: PUSH
98826: EMPTY
98827: LIST
98828: LIST
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: LIST
98834: PPUSH
98835: CALL_OW 69
98839: ST_TO_ADDR
// if not tmp then
98840: LD_VAR 0 6
98844: NOT
98845: IFFALSE 98849
// exit ;
98847: GO 98995
// s1 := rand ( 1 , 4 ) ;
98849: LD_ADDR_VAR 0 2
98853: PUSH
98854: LD_INT 1
98856: PPUSH
98857: LD_INT 4
98859: PPUSH
98860: CALL_OW 12
98864: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98865: LD_ADDR_VAR 0 4
98869: PUSH
98870: LD_VAR 0 6
98874: PUSH
98875: LD_INT 1
98877: ARRAY
98878: PPUSH
98879: LD_VAR 0 2
98883: PPUSH
98884: CALL_OW 259
98888: ST_TO_ADDR
// if s1 = 1 then
98889: LD_VAR 0 2
98893: PUSH
98894: LD_INT 1
98896: EQUAL
98897: IFFALSE 98917
// s2 := rand ( 2 , 4 ) else
98899: LD_ADDR_VAR 0 3
98903: PUSH
98904: LD_INT 2
98906: PPUSH
98907: LD_INT 4
98909: PPUSH
98910: CALL_OW 12
98914: ST_TO_ADDR
98915: GO 98925
// s2 := 1 ;
98917: LD_ADDR_VAR 0 3
98921: PUSH
98922: LD_INT 1
98924: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98925: LD_ADDR_VAR 0 5
98929: PUSH
98930: LD_VAR 0 6
98934: PUSH
98935: LD_INT 1
98937: ARRAY
98938: PPUSH
98939: LD_VAR 0 3
98943: PPUSH
98944: CALL_OW 259
98948: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98949: LD_VAR 0 6
98953: PUSH
98954: LD_INT 1
98956: ARRAY
98957: PPUSH
98958: LD_VAR 0 2
98962: PPUSH
98963: LD_VAR 0 5
98967: PPUSH
98968: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98972: LD_VAR 0 6
98976: PUSH
98977: LD_INT 1
98979: ARRAY
98980: PPUSH
98981: LD_VAR 0 3
98985: PPUSH
98986: LD_VAR 0 4
98990: PPUSH
98991: CALL_OW 237
// end ;
98995: PPOPN 6
98997: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98998: LD_EXP 98
99002: PUSH
99003: LD_EXP 145
99007: AND
99008: IFFALSE 99087
99010: GO 99012
99012: DISABLE
99013: LD_INT 0
99015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99016: LD_ADDR_VAR 0 1
99020: PUSH
99021: LD_INT 22
99023: PUSH
99024: LD_OWVAR 2
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_INT 30
99035: PUSH
99036: LD_INT 3
99038: PUSH
99039: EMPTY
99040: LIST
99041: LIST
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: PPUSH
99047: CALL_OW 69
99051: ST_TO_ADDR
// if not tmp then
99052: LD_VAR 0 1
99056: NOT
99057: IFFALSE 99061
// exit ;
99059: GO 99087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99061: LD_VAR 0 1
99065: PUSH
99066: LD_INT 1
99068: PPUSH
99069: LD_VAR 0 1
99073: PPUSH
99074: CALL_OW 12
99078: ARRAY
99079: PPUSH
99080: LD_INT 1
99082: PPUSH
99083: CALL_OW 234
// end ;
99087: PPOPN 1
99089: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99090: LD_EXP 98
99094: PUSH
99095: LD_EXP 146
99099: AND
99100: IFFALSE 99212
99102: GO 99104
99104: DISABLE
99105: LD_INT 0
99107: PPUSH
99108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99109: LD_ADDR_VAR 0 2
99113: PUSH
99114: LD_INT 22
99116: PUSH
99117: LD_OWVAR 2
99121: PUSH
99122: EMPTY
99123: LIST
99124: LIST
99125: PUSH
99126: LD_INT 2
99128: PUSH
99129: LD_INT 30
99131: PUSH
99132: LD_INT 27
99134: PUSH
99135: EMPTY
99136: LIST
99137: LIST
99138: PUSH
99139: LD_INT 30
99141: PUSH
99142: LD_INT 26
99144: PUSH
99145: EMPTY
99146: LIST
99147: LIST
99148: PUSH
99149: LD_INT 30
99151: PUSH
99152: LD_INT 28
99154: PUSH
99155: EMPTY
99156: LIST
99157: LIST
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: PUSH
99165: EMPTY
99166: LIST
99167: LIST
99168: PPUSH
99169: CALL_OW 69
99173: ST_TO_ADDR
// if not tmp then
99174: LD_VAR 0 2
99178: NOT
99179: IFFALSE 99183
// exit ;
99181: GO 99212
// for i in tmp do
99183: LD_ADDR_VAR 0 1
99187: PUSH
99188: LD_VAR 0 2
99192: PUSH
99193: FOR_IN
99194: IFFALSE 99210
// SetLives ( i , 1 ) ;
99196: LD_VAR 0 1
99200: PPUSH
99201: LD_INT 1
99203: PPUSH
99204: CALL_OW 234
99208: GO 99193
99210: POP
99211: POP
// end ;
99212: PPOPN 2
99214: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99215: LD_EXP 98
99219: PUSH
99220: LD_EXP 147
99224: AND
99225: IFFALSE 99499
99227: GO 99229
99229: DISABLE
99230: LD_INT 0
99232: PPUSH
99233: PPUSH
99234: PPUSH
// begin i := rand ( 1 , 7 ) ;
99235: LD_ADDR_VAR 0 1
99239: PUSH
99240: LD_INT 1
99242: PPUSH
99243: LD_INT 7
99245: PPUSH
99246: CALL_OW 12
99250: ST_TO_ADDR
// case i of 1 :
99251: LD_VAR 0 1
99255: PUSH
99256: LD_INT 1
99258: DOUBLE
99259: EQUAL
99260: IFTRUE 99264
99262: GO 99274
99264: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99265: LD_STRING earthquake(getX(game), 0, 32)
99267: PPUSH
99268: CALL_OW 559
99272: GO 99499
99274: LD_INT 2
99276: DOUBLE
99277: EQUAL
99278: IFTRUE 99282
99280: GO 99296
99282: POP
// begin ToLua ( displayStucuk(); ) ;
99283: LD_STRING displayStucuk();
99285: PPUSH
99286: CALL_OW 559
// ResetFog ;
99290: CALL_OW 335
// end ; 3 :
99294: GO 99499
99296: LD_INT 3
99298: DOUBLE
99299: EQUAL
99300: IFTRUE 99304
99302: GO 99408
99304: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99305: LD_ADDR_VAR 0 2
99309: PUSH
99310: LD_INT 22
99312: PUSH
99313: LD_OWVAR 2
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: PUSH
99322: LD_INT 25
99324: PUSH
99325: LD_INT 1
99327: PUSH
99328: EMPTY
99329: LIST
99330: LIST
99331: PUSH
99332: EMPTY
99333: LIST
99334: LIST
99335: PPUSH
99336: CALL_OW 69
99340: ST_TO_ADDR
// if not tmp then
99341: LD_VAR 0 2
99345: NOT
99346: IFFALSE 99350
// exit ;
99348: GO 99499
// un := tmp [ rand ( 1 , tmp ) ] ;
99350: LD_ADDR_VAR 0 3
99354: PUSH
99355: LD_VAR 0 2
99359: PUSH
99360: LD_INT 1
99362: PPUSH
99363: LD_VAR 0 2
99367: PPUSH
99368: CALL_OW 12
99372: ARRAY
99373: ST_TO_ADDR
// if Crawls ( un ) then
99374: LD_VAR 0 3
99378: PPUSH
99379: CALL_OW 318
99383: IFFALSE 99394
// ComWalk ( un ) ;
99385: LD_VAR 0 3
99389: PPUSH
99390: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99394: LD_VAR 0 3
99398: PPUSH
99399: LD_INT 8
99401: PPUSH
99402: CALL_OW 336
// end ; 4 :
99406: GO 99499
99408: LD_INT 4
99410: DOUBLE
99411: EQUAL
99412: IFTRUE 99416
99414: GO 99477
99416: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99417: LD_ADDR_VAR 0 2
99421: PUSH
99422: LD_INT 22
99424: PUSH
99425: LD_OWVAR 2
99429: PUSH
99430: EMPTY
99431: LIST
99432: LIST
99433: PUSH
99434: LD_INT 30
99436: PUSH
99437: LD_INT 29
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PUSH
99444: EMPTY
99445: LIST
99446: LIST
99447: PPUSH
99448: CALL_OW 69
99452: ST_TO_ADDR
// if not tmp then
99453: LD_VAR 0 2
99457: NOT
99458: IFFALSE 99462
// exit ;
99460: GO 99499
// DestroyUnit ( tmp [ 1 ] ) ;
99462: LD_VAR 0 2
99466: PUSH
99467: LD_INT 1
99469: ARRAY
99470: PPUSH
99471: CALL_OW 65
// end ; 5 .. 7 :
99475: GO 99499
99477: LD_INT 5
99479: DOUBLE
99480: GREATEREQUAL
99481: IFFALSE 99489
99483: LD_INT 7
99485: DOUBLE
99486: LESSEQUAL
99487: IFTRUE 99491
99489: GO 99498
99491: POP
// StreamSibBomb ; end ;
99492: CALL 95749 0 0
99496: GO 99499
99498: POP
// end ;
99499: PPOPN 3
99501: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99502: LD_EXP 98
99506: PUSH
99507: LD_EXP 148
99511: AND
99512: IFFALSE 99668
99514: GO 99516
99516: DISABLE
99517: LD_INT 0
99519: PPUSH
99520: PPUSH
99521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99522: LD_ADDR_VAR 0 2
99526: PUSH
99527: LD_INT 81
99529: PUSH
99530: LD_OWVAR 2
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: PUSH
99539: LD_INT 2
99541: PUSH
99542: LD_INT 21
99544: PUSH
99545: LD_INT 1
99547: PUSH
99548: EMPTY
99549: LIST
99550: LIST
99551: PUSH
99552: LD_INT 21
99554: PUSH
99555: LD_INT 2
99557: PUSH
99558: EMPTY
99559: LIST
99560: LIST
99561: PUSH
99562: EMPTY
99563: LIST
99564: LIST
99565: LIST
99566: PUSH
99567: EMPTY
99568: LIST
99569: LIST
99570: PPUSH
99571: CALL_OW 69
99575: ST_TO_ADDR
// if not tmp then
99576: LD_VAR 0 2
99580: NOT
99581: IFFALSE 99585
// exit ;
99583: GO 99668
// p := 0 ;
99585: LD_ADDR_VAR 0 3
99589: PUSH
99590: LD_INT 0
99592: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99593: LD_INT 35
99595: PPUSH
99596: CALL_OW 67
// p := p + 1 ;
99600: LD_ADDR_VAR 0 3
99604: PUSH
99605: LD_VAR 0 3
99609: PUSH
99610: LD_INT 1
99612: PLUS
99613: ST_TO_ADDR
// for i in tmp do
99614: LD_ADDR_VAR 0 1
99618: PUSH
99619: LD_VAR 0 2
99623: PUSH
99624: FOR_IN
99625: IFFALSE 99656
// if GetLives ( i ) < 1000 then
99627: LD_VAR 0 1
99631: PPUSH
99632: CALL_OW 256
99636: PUSH
99637: LD_INT 1000
99639: LESS
99640: IFFALSE 99654
// SetLives ( i , 1000 ) ;
99642: LD_VAR 0 1
99646: PPUSH
99647: LD_INT 1000
99649: PPUSH
99650: CALL_OW 234
99654: GO 99624
99656: POP
99657: POP
// until p > 20 ;
99658: LD_VAR 0 3
99662: PUSH
99663: LD_INT 20
99665: GREATER
99666: IFFALSE 99593
// end ;
99668: PPOPN 3
99670: END
// every 0 0$1 trigger StreamModeActive and sTime do
99671: LD_EXP 98
99675: PUSH
99676: LD_EXP 149
99680: AND
99681: IFFALSE 99716
99683: GO 99685
99685: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99686: LD_INT 28
99688: PPUSH
99689: LD_OWVAR 2
99693: PPUSH
99694: LD_INT 2
99696: PPUSH
99697: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99701: LD_INT 30
99703: PPUSH
99704: LD_OWVAR 2
99708: PPUSH
99709: LD_INT 2
99711: PPUSH
99712: CALL_OW 322
// end ;
99716: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99717: LD_EXP 98
99721: PUSH
99722: LD_EXP 150
99726: AND
99727: IFFALSE 99848
99729: GO 99731
99731: DISABLE
99732: LD_INT 0
99734: PPUSH
99735: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99736: LD_ADDR_VAR 0 2
99740: PUSH
99741: LD_INT 22
99743: PUSH
99744: LD_OWVAR 2
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PUSH
99753: LD_INT 21
99755: PUSH
99756: LD_INT 1
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: PUSH
99763: LD_INT 3
99765: PUSH
99766: LD_INT 23
99768: PUSH
99769: LD_INT 0
99771: PUSH
99772: EMPTY
99773: LIST
99774: LIST
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: EMPTY
99781: LIST
99782: LIST
99783: LIST
99784: PPUSH
99785: CALL_OW 69
99789: ST_TO_ADDR
// if not tmp then
99790: LD_VAR 0 2
99794: NOT
99795: IFFALSE 99799
// exit ;
99797: GO 99848
// for i in tmp do
99799: LD_ADDR_VAR 0 1
99803: PUSH
99804: LD_VAR 0 2
99808: PUSH
99809: FOR_IN
99810: IFFALSE 99846
// begin if Crawls ( i ) then
99812: LD_VAR 0 1
99816: PPUSH
99817: CALL_OW 318
99821: IFFALSE 99832
// ComWalk ( i ) ;
99823: LD_VAR 0 1
99827: PPUSH
99828: CALL_OW 138
// SetClass ( i , 2 ) ;
99832: LD_VAR 0 1
99836: PPUSH
99837: LD_INT 2
99839: PPUSH
99840: CALL_OW 336
// end ;
99844: GO 99809
99846: POP
99847: POP
// end ;
99848: PPOPN 2
99850: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99851: LD_EXP 98
99855: PUSH
99856: LD_EXP 151
99860: AND
99861: IFFALSE 100142
99863: GO 99865
99865: DISABLE
99866: LD_INT 0
99868: PPUSH
99869: PPUSH
99870: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99871: LD_OWVAR 2
99875: PPUSH
99876: LD_INT 9
99878: PPUSH
99879: LD_INT 1
99881: PPUSH
99882: LD_INT 1
99884: PPUSH
99885: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99889: LD_INT 9
99891: PPUSH
99892: LD_OWVAR 2
99896: PPUSH
99897: CALL_OW 343
// uc_side := 9 ;
99901: LD_ADDR_OWVAR 20
99905: PUSH
99906: LD_INT 9
99908: ST_TO_ADDR
// uc_nation := 2 ;
99909: LD_ADDR_OWVAR 21
99913: PUSH
99914: LD_INT 2
99916: ST_TO_ADDR
// hc_name := Dark Warrior ;
99917: LD_ADDR_OWVAR 26
99921: PUSH
99922: LD_STRING Dark Warrior
99924: ST_TO_ADDR
// hc_gallery :=  ;
99925: LD_ADDR_OWVAR 33
99929: PUSH
99930: LD_STRING 
99932: ST_TO_ADDR
// hc_noskilllimit := true ;
99933: LD_ADDR_OWVAR 76
99937: PUSH
99938: LD_INT 1
99940: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99941: LD_ADDR_OWVAR 31
99945: PUSH
99946: LD_INT 30
99948: PUSH
99949: LD_INT 30
99951: PUSH
99952: LD_INT 30
99954: PUSH
99955: LD_INT 30
99957: PUSH
99958: EMPTY
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: ST_TO_ADDR
// un := CreateHuman ;
99964: LD_ADDR_VAR 0 3
99968: PUSH
99969: CALL_OW 44
99973: ST_TO_ADDR
// hc_noskilllimit := false ;
99974: LD_ADDR_OWVAR 76
99978: PUSH
99979: LD_INT 0
99981: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99982: LD_VAR 0 3
99986: PPUSH
99987: LD_INT 1
99989: PPUSH
99990: CALL_OW 51
// p := 0 ;
99994: LD_ADDR_VAR 0 2
99998: PUSH
99999: LD_INT 0
100001: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100002: LD_INT 35
100004: PPUSH
100005: CALL_OW 67
// p := p + 1 ;
100009: LD_ADDR_VAR 0 2
100013: PUSH
100014: LD_VAR 0 2
100018: PUSH
100019: LD_INT 1
100021: PLUS
100022: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100023: LD_VAR 0 3
100027: PPUSH
100028: CALL_OW 256
100032: PUSH
100033: LD_INT 1000
100035: LESS
100036: IFFALSE 100050
// SetLives ( un , 1000 ) ;
100038: LD_VAR 0 3
100042: PPUSH
100043: LD_INT 1000
100045: PPUSH
100046: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100050: LD_VAR 0 3
100054: PPUSH
100055: LD_INT 81
100057: PUSH
100058: LD_OWVAR 2
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PUSH
100067: LD_INT 91
100069: PUSH
100070: LD_VAR 0 3
100074: PUSH
100075: LD_INT 30
100077: PUSH
100078: EMPTY
100079: LIST
100080: LIST
100081: LIST
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PPUSH
100087: CALL_OW 69
100091: PPUSH
100092: LD_VAR 0 3
100096: PPUSH
100097: CALL_OW 74
100101: PPUSH
100102: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
100106: LD_VAR 0 2
100110: PUSH
100111: LD_INT 60
100113: GREATER
100114: PUSH
100115: LD_VAR 0 3
100119: PPUSH
100120: CALL_OW 301
100124: OR
100125: IFFALSE 100002
// if un then
100127: LD_VAR 0 3
100131: IFFALSE 100142
// RemoveUnit ( un ) ;
100133: LD_VAR 0 3
100137: PPUSH
100138: CALL_OW 64
// end ;
100142: PPOPN 3
100144: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100145: LD_INT 0
100147: PPUSH
// case cmd of 301 :
100148: LD_VAR 0 1
100152: PUSH
100153: LD_INT 301
100155: DOUBLE
100156: EQUAL
100157: IFTRUE 100161
100159: GO 100193
100161: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100162: LD_VAR 0 6
100166: PPUSH
100167: LD_VAR 0 7
100171: PPUSH
100172: LD_VAR 0 8
100176: PPUSH
100177: LD_VAR 0 4
100181: PPUSH
100182: LD_VAR 0 5
100186: PPUSH
100187: CALL 101394 0 5
100191: GO 100314
100193: LD_INT 302
100195: DOUBLE
100196: EQUAL
100197: IFTRUE 100201
100199: GO 100238
100201: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100202: LD_VAR 0 6
100206: PPUSH
100207: LD_VAR 0 7
100211: PPUSH
100212: LD_VAR 0 8
100216: PPUSH
100217: LD_VAR 0 9
100221: PPUSH
100222: LD_VAR 0 4
100226: PPUSH
100227: LD_VAR 0 5
100231: PPUSH
100232: CALL 101485 0 6
100236: GO 100314
100238: LD_INT 303
100240: DOUBLE
100241: EQUAL
100242: IFTRUE 100246
100244: GO 100283
100246: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100247: LD_VAR 0 6
100251: PPUSH
100252: LD_VAR 0 7
100256: PPUSH
100257: LD_VAR 0 8
100261: PPUSH
100262: LD_VAR 0 9
100266: PPUSH
100267: LD_VAR 0 4
100271: PPUSH
100272: LD_VAR 0 5
100276: PPUSH
100277: CALL 100319 0 6
100281: GO 100314
100283: LD_INT 304
100285: DOUBLE
100286: EQUAL
100287: IFTRUE 100291
100289: GO 100313
100291: POP
// hHackTeleport ( unit , x , y ) ; end ;
100292: LD_VAR 0 2
100296: PPUSH
100297: LD_VAR 0 4
100301: PPUSH
100302: LD_VAR 0 5
100306: PPUSH
100307: CALL 102078 0 3
100311: GO 100314
100313: POP
// end ;
100314: LD_VAR 0 12
100318: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100319: LD_INT 0
100321: PPUSH
100322: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100323: LD_VAR 0 1
100327: PUSH
100328: LD_INT 1
100330: LESS
100331: PUSH
100332: LD_VAR 0 1
100336: PUSH
100337: LD_INT 3
100339: GREATER
100340: OR
100341: PUSH
100342: LD_VAR 0 5
100346: PPUSH
100347: LD_VAR 0 6
100351: PPUSH
100352: CALL_OW 428
100356: OR
100357: IFFALSE 100361
// exit ;
100359: GO 101081
// uc_side := your_side ;
100361: LD_ADDR_OWVAR 20
100365: PUSH
100366: LD_OWVAR 2
100370: ST_TO_ADDR
// uc_nation := nation ;
100371: LD_ADDR_OWVAR 21
100375: PUSH
100376: LD_VAR 0 1
100380: ST_TO_ADDR
// bc_level = 1 ;
100381: LD_ADDR_OWVAR 43
100385: PUSH
100386: LD_INT 1
100388: ST_TO_ADDR
// case btype of 1 :
100389: LD_VAR 0 2
100393: PUSH
100394: LD_INT 1
100396: DOUBLE
100397: EQUAL
100398: IFTRUE 100402
100400: GO 100413
100402: POP
// bc_type := b_depot ; 2 :
100403: LD_ADDR_OWVAR 42
100407: PUSH
100408: LD_INT 0
100410: ST_TO_ADDR
100411: GO 101025
100413: LD_INT 2
100415: DOUBLE
100416: EQUAL
100417: IFTRUE 100421
100419: GO 100432
100421: POP
// bc_type := b_warehouse ; 3 :
100422: LD_ADDR_OWVAR 42
100426: PUSH
100427: LD_INT 1
100429: ST_TO_ADDR
100430: GO 101025
100432: LD_INT 3
100434: DOUBLE
100435: EQUAL
100436: IFTRUE 100440
100438: GO 100451
100440: POP
// bc_type := b_lab ; 4 .. 9 :
100441: LD_ADDR_OWVAR 42
100445: PUSH
100446: LD_INT 6
100448: ST_TO_ADDR
100449: GO 101025
100451: LD_INT 4
100453: DOUBLE
100454: GREATEREQUAL
100455: IFFALSE 100463
100457: LD_INT 9
100459: DOUBLE
100460: LESSEQUAL
100461: IFTRUE 100465
100463: GO 100517
100465: POP
// begin bc_type := b_lab_half ;
100466: LD_ADDR_OWVAR 42
100470: PUSH
100471: LD_INT 7
100473: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100474: LD_ADDR_OWVAR 44
100478: PUSH
100479: LD_INT 10
100481: PUSH
100482: LD_INT 11
100484: PUSH
100485: LD_INT 12
100487: PUSH
100488: LD_INT 15
100490: PUSH
100491: LD_INT 14
100493: PUSH
100494: LD_INT 13
100496: PUSH
100497: EMPTY
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: PUSH
100505: LD_VAR 0 2
100509: PUSH
100510: LD_INT 3
100512: MINUS
100513: ARRAY
100514: ST_TO_ADDR
// end ; 10 .. 13 :
100515: GO 101025
100517: LD_INT 10
100519: DOUBLE
100520: GREATEREQUAL
100521: IFFALSE 100529
100523: LD_INT 13
100525: DOUBLE
100526: LESSEQUAL
100527: IFTRUE 100531
100529: GO 100608
100531: POP
// begin bc_type := b_lab_full ;
100532: LD_ADDR_OWVAR 42
100536: PUSH
100537: LD_INT 8
100539: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100540: LD_ADDR_OWVAR 44
100544: PUSH
100545: LD_INT 10
100547: PUSH
100548: LD_INT 12
100550: PUSH
100551: LD_INT 14
100553: PUSH
100554: LD_INT 13
100556: PUSH
100557: EMPTY
100558: LIST
100559: LIST
100560: LIST
100561: LIST
100562: PUSH
100563: LD_VAR 0 2
100567: PUSH
100568: LD_INT 9
100570: MINUS
100571: ARRAY
100572: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100573: LD_ADDR_OWVAR 45
100577: PUSH
100578: LD_INT 11
100580: PUSH
100581: LD_INT 15
100583: PUSH
100584: LD_INT 12
100586: PUSH
100587: LD_INT 15
100589: PUSH
100590: EMPTY
100591: LIST
100592: LIST
100593: LIST
100594: LIST
100595: PUSH
100596: LD_VAR 0 2
100600: PUSH
100601: LD_INT 9
100603: MINUS
100604: ARRAY
100605: ST_TO_ADDR
// end ; 14 :
100606: GO 101025
100608: LD_INT 14
100610: DOUBLE
100611: EQUAL
100612: IFTRUE 100616
100614: GO 100627
100616: POP
// bc_type := b_workshop ; 15 :
100617: LD_ADDR_OWVAR 42
100621: PUSH
100622: LD_INT 2
100624: ST_TO_ADDR
100625: GO 101025
100627: LD_INT 15
100629: DOUBLE
100630: EQUAL
100631: IFTRUE 100635
100633: GO 100646
100635: POP
// bc_type := b_factory ; 16 :
100636: LD_ADDR_OWVAR 42
100640: PUSH
100641: LD_INT 3
100643: ST_TO_ADDR
100644: GO 101025
100646: LD_INT 16
100648: DOUBLE
100649: EQUAL
100650: IFTRUE 100654
100652: GO 100665
100654: POP
// bc_type := b_ext_gun ; 17 :
100655: LD_ADDR_OWVAR 42
100659: PUSH
100660: LD_INT 17
100662: ST_TO_ADDR
100663: GO 101025
100665: LD_INT 17
100667: DOUBLE
100668: EQUAL
100669: IFTRUE 100673
100671: GO 100701
100673: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100674: LD_ADDR_OWVAR 42
100678: PUSH
100679: LD_INT 19
100681: PUSH
100682: LD_INT 23
100684: PUSH
100685: LD_INT 19
100687: PUSH
100688: EMPTY
100689: LIST
100690: LIST
100691: LIST
100692: PUSH
100693: LD_VAR 0 1
100697: ARRAY
100698: ST_TO_ADDR
100699: GO 101025
100701: LD_INT 18
100703: DOUBLE
100704: EQUAL
100705: IFTRUE 100709
100707: GO 100720
100709: POP
// bc_type := b_ext_radar ; 19 :
100710: LD_ADDR_OWVAR 42
100714: PUSH
100715: LD_INT 20
100717: ST_TO_ADDR
100718: GO 101025
100720: LD_INT 19
100722: DOUBLE
100723: EQUAL
100724: IFTRUE 100728
100726: GO 100739
100728: POP
// bc_type := b_ext_radio ; 20 :
100729: LD_ADDR_OWVAR 42
100733: PUSH
100734: LD_INT 22
100736: ST_TO_ADDR
100737: GO 101025
100739: LD_INT 20
100741: DOUBLE
100742: EQUAL
100743: IFTRUE 100747
100745: GO 100758
100747: POP
// bc_type := b_ext_siberium ; 21 :
100748: LD_ADDR_OWVAR 42
100752: PUSH
100753: LD_INT 21
100755: ST_TO_ADDR
100756: GO 101025
100758: LD_INT 21
100760: DOUBLE
100761: EQUAL
100762: IFTRUE 100766
100764: GO 100777
100766: POP
// bc_type := b_ext_computer ; 22 :
100767: LD_ADDR_OWVAR 42
100771: PUSH
100772: LD_INT 24
100774: ST_TO_ADDR
100775: GO 101025
100777: LD_INT 22
100779: DOUBLE
100780: EQUAL
100781: IFTRUE 100785
100783: GO 100796
100785: POP
// bc_type := b_ext_track ; 23 :
100786: LD_ADDR_OWVAR 42
100790: PUSH
100791: LD_INT 16
100793: ST_TO_ADDR
100794: GO 101025
100796: LD_INT 23
100798: DOUBLE
100799: EQUAL
100800: IFTRUE 100804
100802: GO 100815
100804: POP
// bc_type := b_ext_laser ; 24 :
100805: LD_ADDR_OWVAR 42
100809: PUSH
100810: LD_INT 25
100812: ST_TO_ADDR
100813: GO 101025
100815: LD_INT 24
100817: DOUBLE
100818: EQUAL
100819: IFTRUE 100823
100821: GO 100834
100823: POP
// bc_type := b_control_tower ; 25 :
100824: LD_ADDR_OWVAR 42
100828: PUSH
100829: LD_INT 36
100831: ST_TO_ADDR
100832: GO 101025
100834: LD_INT 25
100836: DOUBLE
100837: EQUAL
100838: IFTRUE 100842
100840: GO 100853
100842: POP
// bc_type := b_breastwork ; 26 :
100843: LD_ADDR_OWVAR 42
100847: PUSH
100848: LD_INT 31
100850: ST_TO_ADDR
100851: GO 101025
100853: LD_INT 26
100855: DOUBLE
100856: EQUAL
100857: IFTRUE 100861
100859: GO 100872
100861: POP
// bc_type := b_bunker ; 27 :
100862: LD_ADDR_OWVAR 42
100866: PUSH
100867: LD_INT 32
100869: ST_TO_ADDR
100870: GO 101025
100872: LD_INT 27
100874: DOUBLE
100875: EQUAL
100876: IFTRUE 100880
100878: GO 100891
100880: POP
// bc_type := b_turret ; 28 :
100881: LD_ADDR_OWVAR 42
100885: PUSH
100886: LD_INT 33
100888: ST_TO_ADDR
100889: GO 101025
100891: LD_INT 28
100893: DOUBLE
100894: EQUAL
100895: IFTRUE 100899
100897: GO 100910
100899: POP
// bc_type := b_armoury ; 29 :
100900: LD_ADDR_OWVAR 42
100904: PUSH
100905: LD_INT 4
100907: ST_TO_ADDR
100908: GO 101025
100910: LD_INT 29
100912: DOUBLE
100913: EQUAL
100914: IFTRUE 100918
100916: GO 100929
100918: POP
// bc_type := b_barracks ; 30 :
100919: LD_ADDR_OWVAR 42
100923: PUSH
100924: LD_INT 5
100926: ST_TO_ADDR
100927: GO 101025
100929: LD_INT 30
100931: DOUBLE
100932: EQUAL
100933: IFTRUE 100937
100935: GO 100948
100937: POP
// bc_type := b_solar_power ; 31 :
100938: LD_ADDR_OWVAR 42
100942: PUSH
100943: LD_INT 27
100945: ST_TO_ADDR
100946: GO 101025
100948: LD_INT 31
100950: DOUBLE
100951: EQUAL
100952: IFTRUE 100956
100954: GO 100967
100956: POP
// bc_type := b_oil_power ; 32 :
100957: LD_ADDR_OWVAR 42
100961: PUSH
100962: LD_INT 26
100964: ST_TO_ADDR
100965: GO 101025
100967: LD_INT 32
100969: DOUBLE
100970: EQUAL
100971: IFTRUE 100975
100973: GO 100986
100975: POP
// bc_type := b_siberite_power ; 33 :
100976: LD_ADDR_OWVAR 42
100980: PUSH
100981: LD_INT 28
100983: ST_TO_ADDR
100984: GO 101025
100986: LD_INT 33
100988: DOUBLE
100989: EQUAL
100990: IFTRUE 100994
100992: GO 101005
100994: POP
// bc_type := b_oil_mine ; 34 :
100995: LD_ADDR_OWVAR 42
100999: PUSH
101000: LD_INT 29
101002: ST_TO_ADDR
101003: GO 101025
101005: LD_INT 34
101007: DOUBLE
101008: EQUAL
101009: IFTRUE 101013
101011: GO 101024
101013: POP
// bc_type := b_siberite_mine ; end ;
101014: LD_ADDR_OWVAR 42
101018: PUSH
101019: LD_INT 30
101021: ST_TO_ADDR
101022: GO 101025
101024: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101025: LD_ADDR_VAR 0 8
101029: PUSH
101030: LD_VAR 0 5
101034: PPUSH
101035: LD_VAR 0 6
101039: PPUSH
101040: LD_VAR 0 3
101044: PPUSH
101045: CALL_OW 47
101049: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101050: LD_OWVAR 42
101054: PUSH
101055: LD_INT 32
101057: PUSH
101058: LD_INT 33
101060: PUSH
101061: EMPTY
101062: LIST
101063: LIST
101064: IN
101065: IFFALSE 101081
// PlaceWeaponTurret ( b , weapon ) ;
101067: LD_VAR 0 8
101071: PPUSH
101072: LD_VAR 0 4
101076: PPUSH
101077: CALL_OW 431
// end ;
101081: LD_VAR 0 7
101085: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101086: LD_INT 0
101088: PPUSH
101089: PPUSH
101090: PPUSH
101091: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101092: LD_ADDR_VAR 0 4
101096: PUSH
101097: LD_INT 22
101099: PUSH
101100: LD_OWVAR 2
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: PUSH
101109: LD_INT 2
101111: PUSH
101112: LD_INT 30
101114: PUSH
101115: LD_INT 0
101117: PUSH
101118: EMPTY
101119: LIST
101120: LIST
101121: PUSH
101122: LD_INT 30
101124: PUSH
101125: LD_INT 1
101127: PUSH
101128: EMPTY
101129: LIST
101130: LIST
101131: PUSH
101132: EMPTY
101133: LIST
101134: LIST
101135: LIST
101136: PUSH
101137: EMPTY
101138: LIST
101139: LIST
101140: PPUSH
101141: CALL_OW 69
101145: ST_TO_ADDR
// if not tmp then
101146: LD_VAR 0 4
101150: NOT
101151: IFFALSE 101155
// exit ;
101153: GO 101214
// for i in tmp do
101155: LD_ADDR_VAR 0 2
101159: PUSH
101160: LD_VAR 0 4
101164: PUSH
101165: FOR_IN
101166: IFFALSE 101212
// for j = 1 to 3 do
101168: LD_ADDR_VAR 0 3
101172: PUSH
101173: DOUBLE
101174: LD_INT 1
101176: DEC
101177: ST_TO_ADDR
101178: LD_INT 3
101180: PUSH
101181: FOR_TO
101182: IFFALSE 101208
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101184: LD_VAR 0 2
101188: PPUSH
101189: CALL_OW 274
101193: PPUSH
101194: LD_VAR 0 3
101198: PPUSH
101199: LD_INT 99999
101201: PPUSH
101202: CALL_OW 277
101206: GO 101181
101208: POP
101209: POP
101210: GO 101165
101212: POP
101213: POP
// end ;
101214: LD_VAR 0 1
101218: RET
// export function hHackSetLevel10 ; var i , j ; begin
101219: LD_INT 0
101221: PPUSH
101222: PPUSH
101223: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101224: LD_ADDR_VAR 0 2
101228: PUSH
101229: LD_INT 21
101231: PUSH
101232: LD_INT 1
101234: PUSH
101235: EMPTY
101236: LIST
101237: LIST
101238: PPUSH
101239: CALL_OW 69
101243: PUSH
101244: FOR_IN
101245: IFFALSE 101297
// if IsSelected ( i ) then
101247: LD_VAR 0 2
101251: PPUSH
101252: CALL_OW 306
101256: IFFALSE 101295
// begin for j := 1 to 4 do
101258: LD_ADDR_VAR 0 3
101262: PUSH
101263: DOUBLE
101264: LD_INT 1
101266: DEC
101267: ST_TO_ADDR
101268: LD_INT 4
101270: PUSH
101271: FOR_TO
101272: IFFALSE 101293
// SetSkill ( i , j , 10 ) ;
101274: LD_VAR 0 2
101278: PPUSH
101279: LD_VAR 0 3
101283: PPUSH
101284: LD_INT 10
101286: PPUSH
101287: CALL_OW 237
101291: GO 101271
101293: POP
101294: POP
// end ;
101295: GO 101244
101297: POP
101298: POP
// end ;
101299: LD_VAR 0 1
101303: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101304: LD_INT 0
101306: PPUSH
101307: PPUSH
101308: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101309: LD_ADDR_VAR 0 2
101313: PUSH
101314: LD_INT 22
101316: PUSH
101317: LD_OWVAR 2
101321: PUSH
101322: EMPTY
101323: LIST
101324: LIST
101325: PUSH
101326: LD_INT 21
101328: PUSH
101329: LD_INT 1
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: PPUSH
101340: CALL_OW 69
101344: PUSH
101345: FOR_IN
101346: IFFALSE 101387
// begin for j := 1 to 4 do
101348: LD_ADDR_VAR 0 3
101352: PUSH
101353: DOUBLE
101354: LD_INT 1
101356: DEC
101357: ST_TO_ADDR
101358: LD_INT 4
101360: PUSH
101361: FOR_TO
101362: IFFALSE 101383
// SetSkill ( i , j , 10 ) ;
101364: LD_VAR 0 2
101368: PPUSH
101369: LD_VAR 0 3
101373: PPUSH
101374: LD_INT 10
101376: PPUSH
101377: CALL_OW 237
101381: GO 101361
101383: POP
101384: POP
// end ;
101385: GO 101345
101387: POP
101388: POP
// end ;
101389: LD_VAR 0 1
101393: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101394: LD_INT 0
101396: PPUSH
// uc_side := your_side ;
101397: LD_ADDR_OWVAR 20
101401: PUSH
101402: LD_OWVAR 2
101406: ST_TO_ADDR
// uc_nation := nation ;
101407: LD_ADDR_OWVAR 21
101411: PUSH
101412: LD_VAR 0 1
101416: ST_TO_ADDR
// InitHc ;
101417: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101421: LD_INT 0
101423: PPUSH
101424: LD_VAR 0 2
101428: PPUSH
101429: LD_VAR 0 3
101433: PPUSH
101434: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101438: LD_VAR 0 4
101442: PPUSH
101443: LD_VAR 0 5
101447: PPUSH
101448: CALL_OW 428
101452: PUSH
101453: LD_INT 0
101455: EQUAL
101456: IFFALSE 101480
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101458: CALL_OW 44
101462: PPUSH
101463: LD_VAR 0 4
101467: PPUSH
101468: LD_VAR 0 5
101472: PPUSH
101473: LD_INT 1
101475: PPUSH
101476: CALL_OW 48
// end ;
101480: LD_VAR 0 6
101484: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101485: LD_INT 0
101487: PPUSH
101488: PPUSH
// uc_side := your_side ;
101489: LD_ADDR_OWVAR 20
101493: PUSH
101494: LD_OWVAR 2
101498: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101499: LD_VAR 0 1
101503: PUSH
101504: LD_INT 1
101506: PUSH
101507: LD_INT 2
101509: PUSH
101510: LD_INT 3
101512: PUSH
101513: LD_INT 4
101515: PUSH
101516: LD_INT 5
101518: PUSH
101519: EMPTY
101520: LIST
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: IN
101526: IFFALSE 101538
// uc_nation := nation_american else
101528: LD_ADDR_OWVAR 21
101532: PUSH
101533: LD_INT 1
101535: ST_TO_ADDR
101536: GO 101581
// if chassis in [ 11 , 12 , 13 , 14 ] then
101538: LD_VAR 0 1
101542: PUSH
101543: LD_INT 11
101545: PUSH
101546: LD_INT 12
101548: PUSH
101549: LD_INT 13
101551: PUSH
101552: LD_INT 14
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: IN
101561: IFFALSE 101573
// uc_nation := nation_arabian else
101563: LD_ADDR_OWVAR 21
101567: PUSH
101568: LD_INT 2
101570: ST_TO_ADDR
101571: GO 101581
// uc_nation := nation_russian ;
101573: LD_ADDR_OWVAR 21
101577: PUSH
101578: LD_INT 3
101580: ST_TO_ADDR
// vc_chassis := chassis ;
101581: LD_ADDR_OWVAR 37
101585: PUSH
101586: LD_VAR 0 1
101590: ST_TO_ADDR
// vc_engine := engine ;
101591: LD_ADDR_OWVAR 39
101595: PUSH
101596: LD_VAR 0 2
101600: ST_TO_ADDR
// vc_control := control ;
101601: LD_ADDR_OWVAR 38
101605: PUSH
101606: LD_VAR 0 3
101610: ST_TO_ADDR
// vc_weapon := weapon ;
101611: LD_ADDR_OWVAR 40
101615: PUSH
101616: LD_VAR 0 4
101620: ST_TO_ADDR
// un := CreateVehicle ;
101621: LD_ADDR_VAR 0 8
101625: PUSH
101626: CALL_OW 45
101630: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101631: LD_VAR 0 8
101635: PPUSH
101636: LD_INT 0
101638: PPUSH
101639: LD_INT 5
101641: PPUSH
101642: CALL_OW 12
101646: PPUSH
101647: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101651: LD_VAR 0 8
101655: PPUSH
101656: LD_VAR 0 5
101660: PPUSH
101661: LD_VAR 0 6
101665: PPUSH
101666: LD_INT 1
101668: PPUSH
101669: CALL_OW 48
// end ;
101673: LD_VAR 0 7
101677: RET
// export hInvincible ; every 1 do
101678: GO 101680
101680: DISABLE
// hInvincible := [ ] ;
101681: LD_ADDR_EXP 152
101685: PUSH
101686: EMPTY
101687: ST_TO_ADDR
101688: END
// every 10 do var i ;
101689: GO 101691
101691: DISABLE
101692: LD_INT 0
101694: PPUSH
// begin enable ;
101695: ENABLE
// if not hInvincible then
101696: LD_EXP 152
101700: NOT
101701: IFFALSE 101705
// exit ;
101703: GO 101749
// for i in hInvincible do
101705: LD_ADDR_VAR 0 1
101709: PUSH
101710: LD_EXP 152
101714: PUSH
101715: FOR_IN
101716: IFFALSE 101747
// if GetLives ( i ) < 1000 then
101718: LD_VAR 0 1
101722: PPUSH
101723: CALL_OW 256
101727: PUSH
101728: LD_INT 1000
101730: LESS
101731: IFFALSE 101745
// SetLives ( i , 1000 ) ;
101733: LD_VAR 0 1
101737: PPUSH
101738: LD_INT 1000
101740: PPUSH
101741: CALL_OW 234
101745: GO 101715
101747: POP
101748: POP
// end ;
101749: PPOPN 1
101751: END
// export function hHackInvincible ; var i ; begin
101752: LD_INT 0
101754: PPUSH
101755: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101756: LD_ADDR_VAR 0 2
101760: PUSH
101761: LD_INT 2
101763: PUSH
101764: LD_INT 21
101766: PUSH
101767: LD_INT 1
101769: PUSH
101770: EMPTY
101771: LIST
101772: LIST
101773: PUSH
101774: LD_INT 21
101776: PUSH
101777: LD_INT 2
101779: PUSH
101780: EMPTY
101781: LIST
101782: LIST
101783: PUSH
101784: EMPTY
101785: LIST
101786: LIST
101787: LIST
101788: PPUSH
101789: CALL_OW 69
101793: PUSH
101794: FOR_IN
101795: IFFALSE 101856
// if IsSelected ( i ) then
101797: LD_VAR 0 2
101801: PPUSH
101802: CALL_OW 306
101806: IFFALSE 101854
// begin if i in hInvincible then
101808: LD_VAR 0 2
101812: PUSH
101813: LD_EXP 152
101817: IN
101818: IFFALSE 101838
// hInvincible := hInvincible diff i else
101820: LD_ADDR_EXP 152
101824: PUSH
101825: LD_EXP 152
101829: PUSH
101830: LD_VAR 0 2
101834: DIFF
101835: ST_TO_ADDR
101836: GO 101854
// hInvincible := hInvincible union i ;
101838: LD_ADDR_EXP 152
101842: PUSH
101843: LD_EXP 152
101847: PUSH
101848: LD_VAR 0 2
101852: UNION
101853: ST_TO_ADDR
// end ;
101854: GO 101794
101856: POP
101857: POP
// end ;
101858: LD_VAR 0 1
101862: RET
// export function hHackInvisible ; var i , j ; begin
101863: LD_INT 0
101865: PPUSH
101866: PPUSH
101867: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101868: LD_ADDR_VAR 0 2
101872: PUSH
101873: LD_INT 21
101875: PUSH
101876: LD_INT 1
101878: PUSH
101879: EMPTY
101880: LIST
101881: LIST
101882: PPUSH
101883: CALL_OW 69
101887: PUSH
101888: FOR_IN
101889: IFFALSE 101913
// if IsSelected ( i ) then
101891: LD_VAR 0 2
101895: PPUSH
101896: CALL_OW 306
101900: IFFALSE 101911
// ComForceInvisible ( i ) ;
101902: LD_VAR 0 2
101906: PPUSH
101907: CALL_OW 496
101911: GO 101888
101913: POP
101914: POP
// end ;
101915: LD_VAR 0 1
101919: RET
// export function hHackChangeYourSide ; begin
101920: LD_INT 0
101922: PPUSH
// if your_side = 8 then
101923: LD_OWVAR 2
101927: PUSH
101928: LD_INT 8
101930: EQUAL
101931: IFFALSE 101943
// your_side := 0 else
101933: LD_ADDR_OWVAR 2
101937: PUSH
101938: LD_INT 0
101940: ST_TO_ADDR
101941: GO 101957
// your_side := your_side + 1 ;
101943: LD_ADDR_OWVAR 2
101947: PUSH
101948: LD_OWVAR 2
101952: PUSH
101953: LD_INT 1
101955: PLUS
101956: ST_TO_ADDR
// end ;
101957: LD_VAR 0 1
101961: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101962: LD_INT 0
101964: PPUSH
101965: PPUSH
101966: PPUSH
// for i in all_units do
101967: LD_ADDR_VAR 0 2
101971: PUSH
101972: LD_OWVAR 3
101976: PUSH
101977: FOR_IN
101978: IFFALSE 102056
// if IsSelected ( i ) then
101980: LD_VAR 0 2
101984: PPUSH
101985: CALL_OW 306
101989: IFFALSE 102054
// begin j := GetSide ( i ) ;
101991: LD_ADDR_VAR 0 3
101995: PUSH
101996: LD_VAR 0 2
102000: PPUSH
102001: CALL_OW 255
102005: ST_TO_ADDR
// if j = 8 then
102006: LD_VAR 0 3
102010: PUSH
102011: LD_INT 8
102013: EQUAL
102014: IFFALSE 102026
// j := 0 else
102016: LD_ADDR_VAR 0 3
102020: PUSH
102021: LD_INT 0
102023: ST_TO_ADDR
102024: GO 102040
// j := j + 1 ;
102026: LD_ADDR_VAR 0 3
102030: PUSH
102031: LD_VAR 0 3
102035: PUSH
102036: LD_INT 1
102038: PLUS
102039: ST_TO_ADDR
// SetSide ( i , j ) ;
102040: LD_VAR 0 2
102044: PPUSH
102045: LD_VAR 0 3
102049: PPUSH
102050: CALL_OW 235
// end ;
102054: GO 101977
102056: POP
102057: POP
// end ;
102058: LD_VAR 0 1
102062: RET
// export function hHackFog ; begin
102063: LD_INT 0
102065: PPUSH
// FogOff ( true ) ;
102066: LD_INT 1
102068: PPUSH
102069: CALL_OW 344
// end ;
102073: LD_VAR 0 1
102077: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102078: LD_INT 0
102080: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102081: LD_VAR 0 1
102085: PPUSH
102086: LD_VAR 0 2
102090: PPUSH
102091: LD_VAR 0 3
102095: PPUSH
102096: LD_INT 1
102098: PPUSH
102099: LD_INT 1
102101: PPUSH
102102: CALL_OW 483
// CenterOnXY ( x , y ) ;
102106: LD_VAR 0 2
102110: PPUSH
102111: LD_VAR 0 3
102115: PPUSH
102116: CALL_OW 84
// end ; end_of_file
102120: LD_VAR 0 4
102124: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
102125: LD_VAR 0 1
102129: PPUSH
102130: LD_VAR 0 2
102134: PPUSH
102135: LD_VAR 0 3
102139: PPUSH
102140: LD_VAR 0 4
102144: PPUSH
102145: LD_VAR 0 5
102149: PPUSH
102150: LD_VAR 0 6
102154: PPUSH
102155: CALL 88953 0 6
// end ;
102159: PPOPN 6
102161: END
