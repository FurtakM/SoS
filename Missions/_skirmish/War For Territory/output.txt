// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45272 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45272 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45272 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45272 0 9
// PrepareGensher ;
 185: CALL 3188 0 0
// PreparePopov ;
 189: CALL 6427 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9147 0 0
// MC_Start ( ) ;
 201: CALL 54716 0 0
// Action ;
 205: CALL 9554 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4354 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7617 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 19574 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 78093 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 78037 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 77096 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 77925 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 77607 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 77338 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 76957 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 76772 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 77719 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2481
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 76820 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 78238 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2481
// DialogPowellsAttack ;
2194: CALL 9685 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: PUSH
2250: LD_INT 16
2252: PPUSH
2253: LD_INT 81
2255: PUSH
2256: LD_INT 4
2258: PUSH
2259: EMPTY
2260: LIST
2261: LIST
2262: PPUSH
2263: CALL_OW 70
2267: AND
2268: IFFALSE 2287
// ComAgressiveMove ( attackers , 135 , 21 ) else
2270: LD_VAR 0 4
2274: PPUSH
2275: LD_INT 135
2277: PPUSH
2278: LD_INT 21
2280: PPUSH
2281: CALL_OW 114
2285: GO 2302
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2287: LD_VAR 0 4
2291: PPUSH
2292: LD_INT 146
2294: PPUSH
2295: LD_INT 103
2297: PPUSH
2298: CALL_OW 114
// wait ( 0 0$5 ) ;
2302: LD_INT 175
2304: PPUSH
2305: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2309: LD_INT 35
2311: PPUSH
2312: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2316: LD_VAR 0 4
2320: PPUSH
2321: LD_INT 60
2323: PUSH
2324: EMPTY
2325: LIST
2326: PPUSH
2327: CALL_OW 72
2331: NOT
2332: IFFALSE 2309
// if FilterAllUnits ( [ f_side , 3 ] ) then
2334: LD_INT 22
2336: PUSH
2337: LD_INT 3
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: CALL_OW 69
2348: IFFALSE 2367
// ComAgressiveMove ( attackers , 102 , 116 ) else
2350: LD_VAR 0 4
2354: PPUSH
2355: LD_INT 102
2357: PPUSH
2358: LD_INT 116
2360: PPUSH
2361: CALL_OW 114
2365: GO 2382
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2367: LD_VAR 0 4
2371: PPUSH
2372: LD_INT 66
2374: PPUSH
2375: LD_INT 41
2377: PPUSH
2378: CALL_OW 114
// wait ( 0 0$10 ) ;
2382: LD_INT 350
2384: PPUSH
2385: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2389: LD_INT 35
2391: PPUSH
2392: CALL_OW 67
// for i in attackers do
2396: LD_ADDR_VAR 0 1
2400: PUSH
2401: LD_VAR 0 4
2405: PUSH
2406: FOR_IN
2407: IFFALSE 2457
// if not HasTask ( i ) then
2409: LD_VAR 0 1
2413: PPUSH
2414: CALL_OW 314
2418: NOT
2419: IFFALSE 2455
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 81
2428: PUSH
2429: LD_INT 4
2431: PUSH
2432: EMPTY
2433: LIST
2434: LIST
2435: PPUSH
2436: CALL_OW 69
2440: PPUSH
2441: LD_VAR 0 1
2445: PPUSH
2446: CALL_OW 74
2450: PPUSH
2451: CALL_OW 115
2455: GO 2406
2457: POP
2458: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2459: LD_VAR 0 4
2463: PPUSH
2464: LD_INT 50
2466: PUSH
2467: EMPTY
2468: LIST
2469: PPUSH
2470: CALL_OW 72
2474: NOT
2475: IFFALSE 2389
// DialogPowellsAttackFailed ;
2477: CALL 9950 0 0
// end ;
2481: PPOPN 5
2483: END
// every 0 0$2 do var vehicles , mechs , i ;
2484: GO 2486
2486: DISABLE
2487: LD_INT 0
2489: PPUSH
2490: PPUSH
2491: PPUSH
// begin enable ;
2492: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2493: LD_ADDR_VAR 0 1
2497: PUSH
2498: LD_INT 22
2500: PUSH
2501: LD_INT 1
2503: PUSH
2504: EMPTY
2505: LIST
2506: LIST
2507: PUSH
2508: LD_INT 21
2510: PUSH
2511: LD_INT 2
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: PUSH
2518: LD_INT 3
2520: PUSH
2521: LD_INT 24
2523: PUSH
2524: LD_INT 1000
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PUSH
2531: EMPTY
2532: LIST
2533: LIST
2534: PUSH
2535: LD_INT 92
2537: PUSH
2538: LD_INT 191
2540: PUSH
2541: LD_INT 140
2543: PUSH
2544: LD_INT 10
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: LIST
2551: LIST
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: LIST
2557: LIST
2558: PPUSH
2559: CALL_OW 69
2563: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2564: LD_ADDR_VAR 0 2
2568: PUSH
2569: LD_INT 22
2571: PUSH
2572: LD_INT 4
2574: PUSH
2575: EMPTY
2576: LIST
2577: LIST
2578: PUSH
2579: LD_INT 25
2581: PUSH
2582: LD_INT 3
2584: PUSH
2585: EMPTY
2586: LIST
2587: LIST
2588: PUSH
2589: EMPTY
2590: LIST
2591: LIST
2592: PPUSH
2593: CALL_OW 69
2597: ST_TO_ADDR
// if not mechs then
2598: LD_VAR 0 2
2602: NOT
2603: IFFALSE 2607
// exit ;
2605: GO 2781
// if mc_remote_driver [ 1 ] then
2607: LD_EXP 63
2611: PUSH
2612: LD_INT 1
2614: ARRAY
2615: IFFALSE 2637
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2617: LD_ADDR_VAR 0 2
2621: PUSH
2622: LD_VAR 0 2
2626: PUSH
2627: LD_EXP 63
2631: PUSH
2632: LD_INT 1
2634: ARRAY
2635: DIFF
2636: ST_TO_ADDR
// if not mechs then
2637: LD_VAR 0 2
2641: NOT
2642: IFFALSE 2646
// exit ;
2644: GO 2781
// if vehicles then
2646: LD_VAR 0 1
2650: IFFALSE 2738
// begin for i in mechs do
2652: LD_ADDR_VAR 0 3
2656: PUSH
2657: LD_VAR 0 2
2661: PUSH
2662: FOR_IN
2663: IFFALSE 2734
// begin if GetTag ( i ) <> 120 then
2665: LD_VAR 0 3
2669: PPUSH
2670: CALL_OW 110
2674: PUSH
2675: LD_INT 120
2677: NONEQUAL
2678: IFFALSE 2692
// SetTag ( i , 120 ) ;
2680: LD_VAR 0 3
2684: PPUSH
2685: LD_INT 120
2687: PPUSH
2688: CALL_OW 109
// if IsInUnit ( i ) then
2692: LD_VAR 0 3
2696: PPUSH
2697: CALL_OW 310
2701: IFFALSE 2714
// ComExitBuilding ( i ) else
2703: LD_VAR 0 3
2707: PPUSH
2708: CALL_OW 122
2712: GO 2732
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: LD_VAR 0 1
2723: PUSH
2724: LD_INT 1
2726: ARRAY
2727: PPUSH
2728: CALL_OW 129
// end ;
2732: GO 2662
2734: POP
2735: POP
// end else
2736: GO 2781
// if FilterByTag ( mechs , 120 ) then
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 120
2745: PPUSH
2746: CALL 46164 0 2
2750: IFFALSE 2781
// begin for i in mechs do
2752: LD_ADDR_VAR 0 3
2756: PUSH
2757: LD_VAR 0 2
2761: PUSH
2762: FOR_IN
2763: IFFALSE 2779
// begin SetTag ( i , 0 ) ;
2765: LD_VAR 0 3
2769: PPUSH
2770: LD_INT 0
2772: PPUSH
2773: CALL_OW 109
// end ;
2777: GO 2762
2779: POP
2780: POP
// end ; end ;
2781: PPOPN 3
2783: END
// every 0 0$2 do var people , sci , i ;
2784: GO 2786
2786: DISABLE
2787: LD_INT 0
2789: PPUSH
2790: PPUSH
2791: PPUSH
// begin enable ;
2792: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2793: LD_ADDR_VAR 0 1
2797: PUSH
2798: LD_INT 22
2800: PUSH
2801: LD_INT 1
2803: PUSH
2804: EMPTY
2805: LIST
2806: LIST
2807: PUSH
2808: LD_INT 21
2810: PUSH
2811: LD_INT 1
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: PUSH
2818: LD_INT 3
2820: PUSH
2821: LD_INT 24
2823: PUSH
2824: LD_INT 1000
2826: PUSH
2827: EMPTY
2828: LIST
2829: LIST
2830: PUSH
2831: EMPTY
2832: LIST
2833: LIST
2834: PUSH
2835: LD_INT 92
2837: PUSH
2838: LD_INT 188
2840: PUSH
2841: LD_INT 112
2843: PUSH
2844: LD_INT 10
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: LIST
2851: LIST
2852: PUSH
2853: EMPTY
2854: LIST
2855: LIST
2856: LIST
2857: LIST
2858: PPUSH
2859: CALL_OW 69
2863: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2864: LD_ADDR_VAR 0 2
2868: PUSH
2869: LD_INT 22
2871: PUSH
2872: LD_INT 4
2874: PUSH
2875: EMPTY
2876: LIST
2877: LIST
2878: PUSH
2879: LD_INT 25
2881: PUSH
2882: LD_INT 4
2884: PUSH
2885: EMPTY
2886: LIST
2887: LIST
2888: PUSH
2889: EMPTY
2890: LIST
2891: LIST
2892: PPUSH
2893: CALL_OW 69
2897: ST_TO_ADDR
// if not sci then
2898: LD_VAR 0 2
2902: NOT
2903: IFFALSE 2907
// exit ;
2905: GO 3042
// if people then
2907: LD_VAR 0 1
2911: IFFALSE 2999
// begin for i in sci do
2913: LD_ADDR_VAR 0 3
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: FOR_IN
2924: IFFALSE 2995
// begin if GetTag ( i ) <> 102 then
2926: LD_VAR 0 3
2930: PPUSH
2931: CALL_OW 110
2935: PUSH
2936: LD_INT 102
2938: NONEQUAL
2939: IFFALSE 2953
// SetTag ( i , 102 ) ;
2941: LD_VAR 0 3
2945: PPUSH
2946: LD_INT 102
2948: PPUSH
2949: CALL_OW 109
// if IsInUnit ( i ) then
2953: LD_VAR 0 3
2957: PPUSH
2958: CALL_OW 310
2962: IFFALSE 2975
// ComExitBuilding ( i ) else
2964: LD_VAR 0 3
2968: PPUSH
2969: CALL_OW 122
2973: GO 2993
// ComHeal ( i , people [ 1 ] ) ;
2975: LD_VAR 0 3
2979: PPUSH
2980: LD_VAR 0 1
2984: PUSH
2985: LD_INT 1
2987: ARRAY
2988: PPUSH
2989: CALL_OW 128
// end ;
2993: GO 2923
2995: POP
2996: POP
// end else
2997: GO 3042
// if FilterByTag ( sci , 102 ) then
2999: LD_VAR 0 2
3003: PPUSH
3004: LD_INT 102
3006: PPUSH
3007: CALL 46164 0 2
3011: IFFALSE 3042
// begin for i in sci do
3013: LD_ADDR_VAR 0 3
3017: PUSH
3018: LD_VAR 0 2
3022: PUSH
3023: FOR_IN
3024: IFFALSE 3040
// begin SetTag ( i , 0 ) ;
3026: LD_VAR 0 3
3030: PPUSH
3031: LD_INT 0
3033: PPUSH
3034: CALL_OW 109
// end ;
3038: GO 3023
3040: POP
3041: POP
// end ; end ;
3042: PPOPN 3
3044: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3045: LD_INT 22
3047: PUSH
3048: LD_INT 4
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 33
3057: PUSH
3058: LD_INT 2
3060: PUSH
3061: EMPTY
3062: LIST
3063: LIST
3064: PUSH
3065: LD_INT 50
3067: PUSH
3068: EMPTY
3069: LIST
3070: PUSH
3071: LD_INT 3
3073: PUSH
3074: LD_INT 61
3076: PUSH
3077: EMPTY
3078: LIST
3079: PUSH
3080: EMPTY
3081: LIST
3082: LIST
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL_OW 69
3094: IFFALSE 3185
3096: GO 3098
3098: DISABLE
3099: LD_INT 0
3101: PPUSH
3102: PPUSH
// begin enable ;
3103: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3104: LD_ADDR_VAR 0 2
3108: PUSH
3109: LD_INT 22
3111: PUSH
3112: LD_INT 4
3114: PUSH
3115: EMPTY
3116: LIST
3117: LIST
3118: PUSH
3119: LD_INT 33
3121: PUSH
3122: LD_INT 2
3124: PUSH
3125: EMPTY
3126: LIST
3127: LIST
3128: PUSH
3129: LD_INT 50
3131: PUSH
3132: EMPTY
3133: LIST
3134: PUSH
3135: LD_INT 3
3137: PUSH
3138: LD_INT 61
3140: PUSH
3141: EMPTY
3142: LIST
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: PUSH
3148: EMPTY
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: PPUSH
3154: CALL_OW 69
3158: ST_TO_ADDR
// for i in tmp do
3159: LD_ADDR_VAR 0 1
3163: PUSH
3164: LD_VAR 0 2
3168: PUSH
3169: FOR_IN
3170: IFFALSE 3183
// Connect ( i ) ;
3172: LD_VAR 0 1
3176: PPUSH
3177: CALL 19221 0 1
3181: GO 3169
3183: POP
3184: POP
// end ; end_of_file
3185: PPOPN 2
3187: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3188: LD_INT 0
3190: PPUSH
3191: PPUSH
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
// gensher_side := 2 ;
3196: LD_ADDR_EXP 14
3200: PUSH
3201: LD_INT 2
3203: ST_TO_ADDR
// uc_side := gensher_side ;
3204: LD_ADDR_OWVAR 20
3208: PUSH
3209: LD_EXP 14
3213: ST_TO_ADDR
// uc_nation := 2 ;
3214: LD_ADDR_OWVAR 21
3218: PUSH
3219: LD_INT 2
3221: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3222: LD_ADDR_VAR 0 6
3226: PUSH
3227: LD_INT 5
3229: PUSH
3230: LD_INT 42
3232: PUSH
3233: LD_INT 29
3235: PUSH
3236: LD_INT 5
3238: PUSH
3239: EMPTY
3240: LIST
3241: LIST
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 5
3247: PUSH
3248: LD_INT 36
3250: PUSH
3251: LD_INT 40
3253: PUSH
3254: LD_INT 5
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: LIST
3261: LIST
3262: PUSH
3263: LD_INT 6
3265: PUSH
3266: LD_INT 13
3268: PUSH
3269: LD_INT 18
3271: PUSH
3272: LD_INT 1
3274: PUSH
3275: LD_INT 10
3277: PUSH
3278: LD_INT 15
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 27
3291: PUSH
3292: LD_INT 17
3294: PUSH
3295: LD_INT 3
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 29
3309: PUSH
3310: LD_INT 56
3312: PUSH
3313: LD_INT 23
3315: PUSH
3316: LD_INT 0
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 3
3327: PUSH
3328: LD_INT 11
3330: PUSH
3331: LD_INT 7
3333: PUSH
3334: LD_INT 2
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 27
3345: PUSH
3346: LD_INT 20
3348: PUSH
3349: LD_INT 3
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 27
3363: PUSH
3364: LD_INT 23
3366: PUSH
3367: LD_INT 3
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 27
3381: PUSH
3382: LD_INT 26
3384: PUSH
3385: LD_INT 3
3387: PUSH
3388: LD_INT 0
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 6
3399: PUSH
3400: LD_INT 17
3402: PUSH
3403: LD_INT 27
3405: PUSH
3406: LD_INT 1
3408: PUSH
3409: LD_INT 13
3411: PUSH
3412: LD_INT 11
3414: PUSH
3415: EMPTY
3416: LIST
3417: LIST
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: PUSH
3423: LD_INT 32
3425: PUSH
3426: LD_INT 27
3428: PUSH
3429: LD_INT 44
3431: PUSH
3432: LD_INT 5
3434: PUSH
3435: LD_INT 27
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: LIST
3442: LIST
3443: LIST
3444: PUSH
3445: LD_INT 32
3447: PUSH
3448: LD_INT 41
3450: PUSH
3451: LD_INT 41
3453: PUSH
3454: LD_INT 5
3456: PUSH
3457: LD_INT 27
3459: PUSH
3460: EMPTY
3461: LIST
3462: LIST
3463: LIST
3464: LIST
3465: LIST
3466: PUSH
3467: LD_INT 32
3469: PUSH
3470: LD_INT 45
3472: PUSH
3473: LD_INT 24
3475: PUSH
3476: LD_INT 5
3478: PUSH
3479: LD_INT 28
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: LIST
3488: PUSH
3489: LD_INT 32
3491: PUSH
3492: LD_INT 48
3494: PUSH
3495: LD_INT 19
3497: PUSH
3498: LD_INT 5
3500: PUSH
3501: LD_INT 28
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: LIST
3510: PUSH
3511: LD_INT 32
3513: PUSH
3514: LD_INT 41
3516: PUSH
3517: LD_INT 3
3519: PUSH
3520: LD_INT 4
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: EMPTY
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: PUSH
3533: LD_INT 5
3535: PUSH
3536: LD_INT 44
3538: PUSH
3539: LD_INT 9
3541: PUSH
3542: LD_INT 4
3544: PUSH
3545: EMPTY
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: PUSH
3551: LD_INT 30
3553: PUSH
3554: LD_INT 52
3556: PUSH
3557: LD_INT 40
3559: PUSH
3560: LD_INT 3
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: ST_TO_ADDR
// for i in list do
3588: LD_ADDR_VAR 0 2
3592: PUSH
3593: LD_VAR 0 6
3597: PUSH
3598: FOR_IN
3599: IFFALSE 3809
// begin uc_side := 2 ;
3601: LD_ADDR_OWVAR 20
3605: PUSH
3606: LD_INT 2
3608: ST_TO_ADDR
// uc_nation := 2 ;
3609: LD_ADDR_OWVAR 21
3613: PUSH
3614: LD_INT 2
3616: ST_TO_ADDR
// InitBc ;
3617: CALL_OW 21
// bc_type := i [ 1 ] ;
3621: LD_ADDR_OWVAR 42
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 1
3633: ARRAY
3634: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3635: LD_VAR 0 2
3639: PUSH
3640: LD_INT 1
3642: ARRAY
3643: PUSH
3644: LD_INT 29
3646: PUSH
3647: LD_INT 30
3649: PUSH
3650: EMPTY
3651: LIST
3652: LIST
3653: IN
3654: IFFALSE 3681
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3656: LD_VAR 0 2
3660: PUSH
3661: LD_INT 2
3663: ARRAY
3664: PPUSH
3665: LD_VAR 0 2
3669: PUSH
3670: LD_INT 3
3672: ARRAY
3673: PPUSH
3674: LD_INT 2
3676: PPUSH
3677: CALL_OW 441
// if i [ 1 ] = b_lab then
3681: LD_VAR 0 2
3685: PUSH
3686: LD_INT 1
3688: ARRAY
3689: PUSH
3690: LD_INT 6
3692: EQUAL
3693: IFFALSE 3731
// begin bc_type := b_lab_full ;
3695: LD_ADDR_OWVAR 42
3699: PUSH
3700: LD_INT 8
3702: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3703: LD_ADDR_OWVAR 44
3707: PUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 5
3715: ARRAY
3716: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3717: LD_ADDR_OWVAR 45
3721: PUSH
3722: LD_VAR 0 2
3726: PUSH
3727: LD_INT 6
3729: ARRAY
3730: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3731: LD_ADDR_VAR 0 3
3735: PUSH
3736: LD_VAR 0 2
3740: PUSH
3741: LD_INT 2
3743: ARRAY
3744: PPUSH
3745: LD_VAR 0 2
3749: PUSH
3750: LD_INT 3
3752: ARRAY
3753: PPUSH
3754: LD_VAR 0 2
3758: PUSH
3759: LD_INT 4
3761: ARRAY
3762: PPUSH
3763: CALL_OW 47
3767: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3768: LD_VAR 0 2
3772: PUSH
3773: LD_INT 1
3775: ARRAY
3776: PUSH
3777: LD_INT 33
3779: PUSH
3780: LD_INT 32
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: IN
3787: IFFALSE 3807
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3789: LD_VAR 0 3
3793: PPUSH
3794: LD_VAR 0 2
3798: PUSH
3799: LD_INT 5
3801: ARRAY
3802: PPUSH
3803: CALL_OW 431
// end ;
3807: GO 3598
3809: POP
3810: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3811: LD_ADDR_VAR 0 4
3815: PUSH
3816: LD_INT 7
3818: PPUSH
3819: LD_INT 2
3821: PPUSH
3822: LD_STRING 
3824: PPUSH
3825: LD_INT 8
3827: PUSH
3828: LD_INT 7
3830: PUSH
3831: LD_INT 6
3833: PUSH
3834: EMPTY
3835: LIST
3836: LIST
3837: LIST
3838: PUSH
3839: LD_OWVAR 67
3843: ARRAY
3844: PPUSH
3845: LD_INT 11500
3847: PUSH
3848: LD_INT 1100
3850: PUSH
3851: LD_INT 60
3853: PUSH
3854: EMPTY
3855: LIST
3856: LIST
3857: LIST
3858: PPUSH
3859: LD_INT 6
3861: PUSH
3862: LD_INT 6
3864: PUSH
3865: LD_INT 6
3867: PUSH
3868: LD_INT 6
3870: PUSH
3871: EMPTY
3872: LIST
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: CALL 19574 0 6
3881: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3882: LD_ADDR_EXP 23
3886: PUSH
3887: LD_EXP 23
3891: PPUSH
3892: LD_INT 2
3894: PPUSH
3895: LD_VAR 0 4
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 2
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 21
3912: PUSH
3913: LD_INT 3
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: UNION
3929: PPUSH
3930: CALL_OW 1
3934: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3935: LD_ADDR_VAR 0 4
3939: PUSH
3940: LD_INT 22
3942: PUSH
3943: LD_INT 2
3945: PUSH
3946: EMPTY
3947: LIST
3948: LIST
3949: PUSH
3950: LD_INT 30
3952: PUSH
3953: LD_INT 31
3955: PUSH
3956: EMPTY
3957: LIST
3958: LIST
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PPUSH
3964: CALL_OW 69
3968: ST_TO_ADDR
// for i in tmp do
3969: LD_ADDR_VAR 0 2
3973: PUSH
3974: LD_VAR 0 4
3978: PUSH
3979: FOR_IN
3980: IFFALSE 4050
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3982: LD_INT 0
3984: PPUSH
3985: LD_INT 1
3987: PPUSH
3988: LD_INT 4
3990: PUSH
3991: LD_INT 3
3993: PUSH
3994: LD_INT 3
3996: PUSH
3997: EMPTY
3998: LIST
3999: LIST
4000: LIST
4001: PUSH
4002: LD_OWVAR 67
4006: ARRAY
4007: PPUSH
4008: CALL_OW 380
// un := CreateHuman ;
4012: LD_ADDR_VAR 0 5
4016: PUSH
4017: CALL_OW 44
4021: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4022: LD_VAR 0 5
4026: PPUSH
4027: LD_INT 1
4029: PPUSH
4030: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4034: LD_VAR 0 5
4038: PPUSH
4039: LD_VAR 0 2
4043: PPUSH
4044: CALL_OW 52
// end ;
4048: GO 3979
4050: POP
4051: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4052: LD_ADDR_VAR 0 4
4056: PUSH
4057: LD_INT 15
4059: PPUSH
4060: LD_INT 0
4062: PPUSH
4063: CALL_OW 517
4067: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_VAR 0 4
4082: PUSH
4083: LD_INT 1
4085: ARRAY
4086: PUSH
4087: FOR_TO
4088: IFFALSE 4190
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4090: LD_VAR 0 4
4094: PUSH
4095: LD_INT 1
4097: ARRAY
4098: PUSH
4099: LD_VAR 0 2
4103: ARRAY
4104: PPUSH
4105: LD_VAR 0 4
4109: PUSH
4110: LD_INT 2
4112: ARRAY
4113: PUSH
4114: LD_VAR 0 2
4118: ARRAY
4119: PPUSH
4120: LD_INT 2
4122: PPUSH
4123: LD_INT 0
4125: PPUSH
4126: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4130: LD_ADDR_EXP 3
4134: PUSH
4135: LD_EXP 3
4139: PPUSH
4140: LD_EXP 3
4144: PUSH
4145: LD_INT 1
4147: PLUS
4148: PPUSH
4149: LD_VAR 0 4
4153: PUSH
4154: LD_INT 1
4156: ARRAY
4157: PUSH
4158: LD_VAR 0 2
4162: ARRAY
4163: PUSH
4164: LD_VAR 0 4
4168: PUSH
4169: LD_INT 2
4171: ARRAY
4172: PUSH
4173: LD_VAR 0 2
4177: ARRAY
4178: PUSH
4179: EMPTY
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL_OW 2
4187: ST_TO_ADDR
// end ;
4188: GO 4087
4190: POP
4191: POP
// if Difficulty > 1 then
4192: LD_OWVAR 67
4196: PUSH
4197: LD_INT 1
4199: GREATER
4200: IFFALSE 4342
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4202: LD_ADDR_VAR 0 4
4206: PUSH
4207: LD_INT 19
4209: PPUSH
4210: LD_INT 0
4212: PPUSH
4213: CALL_OW 517
4217: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_VAR 0 4
4232: PUSH
4233: LD_INT 1
4235: ARRAY
4236: PUSH
4237: FOR_TO
4238: IFFALSE 4340
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4240: LD_VAR 0 4
4244: PUSH
4245: LD_INT 1
4247: ARRAY
4248: PUSH
4249: LD_VAR 0 2
4253: ARRAY
4254: PPUSH
4255: LD_VAR 0 4
4259: PUSH
4260: LD_INT 2
4262: ARRAY
4263: PUSH
4264: LD_VAR 0 2
4268: ARRAY
4269: PPUSH
4270: LD_INT 2
4272: PPUSH
4273: LD_INT 0
4275: PPUSH
4276: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4280: LD_ADDR_EXP 3
4284: PUSH
4285: LD_EXP 3
4289: PPUSH
4290: LD_EXP 3
4294: PUSH
4295: LD_INT 1
4297: PLUS
4298: PPUSH
4299: LD_VAR 0 4
4303: PUSH
4304: LD_INT 1
4306: ARRAY
4307: PUSH
4308: LD_VAR 0 2
4312: ARRAY
4313: PUSH
4314: LD_VAR 0 4
4318: PUSH
4319: LD_INT 2
4321: ARRAY
4322: PUSH
4323: LD_VAR 0 2
4327: ARRAY
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL_OW 2
4337: ST_TO_ADDR
// end ;
4338: GO 4237
4340: POP
4341: POP
// end ; gensherAttackGroup := [ ] ;
4342: LD_ADDR_EXP 15
4346: PUSH
4347: EMPTY
4348: ST_TO_ADDR
// end ;
4349: LD_VAR 0 1
4353: RET
// export function InitMC_Gensher ( ) ; begin
4354: LD_INT 0
4356: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 2
4362: PPUSH
4363: CALL 78093 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 9
4372: PPUSH
4373: CALL 78037 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4377: LD_INT 2
4379: PPUSH
4380: LD_INT 56
4382: PUSH
4383: LD_INT 23
4385: PUSH
4386: LD_INT 0
4388: PUSH
4389: EMPTY
4390: LIST
4391: LIST
4392: LIST
4393: PUSH
4394: LD_INT 52
4396: PUSH
4397: LD_INT 40
4399: PUSH
4400: LD_INT 1
4402: PUSH
4403: EMPTY
4404: LIST
4405: LIST
4406: LIST
4407: PUSH
4408: EMPTY
4409: LIST
4410: LIST
4411: PPUSH
4412: CALL 77096 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4416: LD_INT 2
4418: PPUSH
4419: LD_INT 27
4421: PUSH
4422: LD_INT 28
4424: PUSH
4425: EMPTY
4426: LIST
4427: LIST
4428: PPUSH
4429: CALL 77925 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4433: LD_INT 2
4435: PPUSH
4436: LD_INT 8
4438: PPUSH
4439: CALL 77607 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4443: LD_INT 2
4445: PPUSH
4446: LD_INT 7
4448: PPUSH
4449: CALL 77338 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4453: LD_INT 2
4455: PPUSH
4456: LD_INT 4
4458: PPUSH
4459: CALL 76957 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4463: LD_INT 2
4465: PPUSH
4466: LD_INT 13
4468: PUSH
4469: LD_INT 2
4471: PUSH
4472: LD_INT 1
4474: PUSH
4475: LD_INT 31
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: PUSH
4484: LD_INT 13
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: LD_INT 1
4492: PUSH
4493: LD_INT 31
4495: PUSH
4496: EMPTY
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 14
4504: PUSH
4505: LD_INT 1
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 27
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: PUSH
4520: LD_INT 14
4522: PUSH
4523: LD_INT 1
4525: PUSH
4526: LD_INT 2
4528: PUSH
4529: LD_INT 27
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: PUSH
4538: LD_INT 14
4540: PUSH
4541: LD_INT 1
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: LD_INT 28
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 14
4558: PUSH
4559: LD_INT 1
4561: PUSH
4562: LD_INT 2
4564: PUSH
4565: LD_INT 26
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: LIST
4572: LIST
4573: PUSH
4574: EMPTY
4575: LIST
4576: LIST
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: PPUSH
4582: CALL 76772 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4586: LD_INT 2
4588: PPUSH
4589: LD_INT 11
4591: PPUSH
4592: LD_INT 7
4594: PPUSH
4595: LD_INT 2
4597: PPUSH
4598: LD_INT 23
4600: PUSH
4601: LD_INT 16
4603: PUSH
4604: LD_INT 17
4606: PUSH
4607: LD_INT 18
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: LIST
4618: LIST
4619: PPUSH
4620: CALL 77719 0 5
// end ;
4624: LD_VAR 0 1
4628: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4629: LD_EXP 3
4633: PUSH
4634: LD_INT 15
4636: PPUSH
4637: LD_INT 81
4639: PUSH
4640: LD_INT 2
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: PPUSH
4647: CALL_OW 70
4651: AND
4652: IFFALSE 4865
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
4660: PPUSH
4661: PPUSH
4662: PPUSH
4663: PPUSH
// begin enable ;
4664: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4665: LD_ADDR_VAR 0 3
4669: PUSH
4670: LD_INT 15
4672: PPUSH
4673: LD_INT 81
4675: PUSH
4676: LD_INT 2
4678: PUSH
4679: EMPTY
4680: LIST
4681: LIST
4682: PPUSH
4683: CALL_OW 70
4687: ST_TO_ADDR
// if not tmp then
4688: LD_VAR 0 3
4692: NOT
4693: IFFALSE 4697
// exit ;
4695: GO 4865
// for i in tmp do
4697: LD_ADDR_VAR 0 1
4701: PUSH
4702: LD_VAR 0 3
4706: PUSH
4707: FOR_IN
4708: IFFALSE 4863
// begin x := GetX ( i ) ;
4710: LD_ADDR_VAR 0 4
4714: PUSH
4715: LD_VAR 0 1
4719: PPUSH
4720: CALL_OW 250
4724: ST_TO_ADDR
// y := GetY ( i ) ;
4725: LD_ADDR_VAR 0 5
4729: PUSH
4730: LD_VAR 0 1
4734: PPUSH
4735: CALL_OW 251
4739: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4740: LD_VAR 0 4
4744: PPUSH
4745: LD_VAR 0 5
4749: PPUSH
4750: CALL_OW 458
4754: IFFALSE 4861
// begin LaunchMineAtPos ( x , y , 2 ) ;
4756: LD_VAR 0 4
4760: PPUSH
4761: LD_VAR 0 5
4765: PPUSH
4766: LD_INT 2
4768: PPUSH
4769: CALL_OW 456
// for j = 1 to staticMines do
4773: LD_ADDR_VAR 0 2
4777: PUSH
4778: DOUBLE
4779: LD_INT 1
4781: DEC
4782: ST_TO_ADDR
4783: LD_EXP 3
4787: PUSH
4788: FOR_TO
4789: IFFALSE 4859
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4791: LD_EXP 3
4795: PUSH
4796: LD_VAR 0 2
4800: ARRAY
4801: PUSH
4802: LD_INT 1
4804: ARRAY
4805: PUSH
4806: LD_VAR 0 4
4810: EQUAL
4811: PUSH
4812: LD_EXP 3
4816: PUSH
4817: LD_VAR 0 2
4821: ARRAY
4822: PUSH
4823: LD_INT 2
4825: ARRAY
4826: PUSH
4827: LD_VAR 0 5
4831: EQUAL
4832: AND
4833: IFFALSE 4857
// begin staticMines := Delete ( staticMines , j ) ;
4835: LD_ADDR_EXP 3
4839: PUSH
4840: LD_EXP 3
4844: PPUSH
4845: LD_VAR 0 2
4849: PPUSH
4850: CALL_OW 3
4854: ST_TO_ADDR
// break ;
4855: GO 4859
// end ;
4857: GO 4788
4859: POP
4860: POP
// end ; end ;
4861: GO 4707
4863: POP
4864: POP
// end ;
4865: PPOPN 5
4867: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4868: LD_INT 7
4870: PPUSH
4871: CALL_OW 302
4875: PUSH
4876: LD_EXP 4
4880: NOT
4881: AND
4882: IFFALSE 5482
4884: GO 4886
4886: DISABLE
4887: LD_INT 0
4889: PPUSH
4890: PPUSH
4891: PPUSH
4892: PPUSH
4893: PPUSH
// begin enable ;
4894: ENABLE
// base := 2 ;
4895: LD_ADDR_VAR 0 2
4899: PUSH
4900: LD_INT 2
4902: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4903: LD_ADDR_VAR 0 3
4907: PUSH
4908: LD_INT 14
4910: PUSH
4911: LD_INT 1
4913: PUSH
4914: LD_INT 2
4916: PUSH
4917: LD_INT 27
4919: PUSH
4920: EMPTY
4921: LIST
4922: LIST
4923: LIST
4924: LIST
4925: PUSH
4926: LD_INT 14
4928: PUSH
4929: LD_INT 1
4931: PUSH
4932: LD_INT 2
4934: PUSH
4935: LD_INT 27
4937: PUSH
4938: EMPTY
4939: LIST
4940: LIST
4941: LIST
4942: LIST
4943: PUSH
4944: LD_INT 14
4946: PUSH
4947: LD_INT 1
4949: PUSH
4950: LD_INT 2
4952: PUSH
4953: LD_INT 28
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 14
4964: PUSH
4965: LD_INT 1
4967: PUSH
4968: LD_INT 2
4970: PUSH
4971: LD_INT 26
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: PUSH
4980: EMPTY
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4986: LD_ADDR_VAR 0 5
4990: PUSH
4991: LD_VAR 0 5
4995: PUSH
4996: LD_OWVAR 1
5000: PUSH
5001: LD_INT 21000
5003: DIV
5004: PLUS
5005: ST_TO_ADDR
// if amount > 8 then
5006: LD_VAR 0 5
5010: PUSH
5011: LD_INT 8
5013: GREATER
5014: IFFALSE 5024
// amount := 8 ;
5016: LD_ADDR_VAR 0 5
5020: PUSH
5021: LD_INT 8
5023: ST_TO_ADDR
// for i = 1 to amount do
5024: LD_ADDR_VAR 0 1
5028: PUSH
5029: DOUBLE
5030: LD_INT 1
5032: DEC
5033: ST_TO_ADDR
5034: LD_VAR 0 5
5038: PUSH
5039: FOR_TO
5040: IFFALSE 5128
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5042: LD_ADDR_VAR 0 3
5046: PUSH
5047: LD_VAR 0 3
5051: PPUSH
5052: LD_VAR 0 3
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: PPUSH
5061: LD_INT 14
5063: PUSH
5064: LD_INT 13
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: LD_INT 1
5073: PPUSH
5074: LD_INT 2
5076: PPUSH
5077: CALL_OW 12
5081: ARRAY
5082: PUSH
5083: LD_INT 1
5085: PUSH
5086: LD_INT 2
5088: PUSH
5089: LD_INT 28
5091: PUSH
5092: LD_INT 25
5094: PUSH
5095: LD_INT 27
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: LIST
5102: PUSH
5103: LD_INT 1
5105: PPUSH
5106: LD_INT 3
5108: PPUSH
5109: CALL_OW 12
5113: ARRAY
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: PPUSH
5121: CALL_OW 2
5125: ST_TO_ADDR
5126: GO 5039
5128: POP
5129: POP
// MC_InsertProduceList ( base , tmp ) ;
5130: LD_VAR 0 2
5134: PPUSH
5135: LD_VAR 0 3
5139: PPUSH
5140: CALL 76820 0 2
// repeat wait ( 0 0$1 ) ;
5144: LD_INT 35
5146: PPUSH
5147: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5151: LD_VAR 0 2
5155: PPUSH
5156: LD_INT 1
5158: PPUSH
5159: CALL 78238 0 2
5163: PUSH
5164: LD_VAR 0 5
5168: GREATEREQUAL
5169: IFFALSE 5144
// wait ( 0 0$30 ) ;
5171: LD_INT 1050
5173: PPUSH
5174: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5178: LD_ADDR_VAR 0 4
5182: PUSH
5183: LD_EXP 42
5187: PUSH
5188: LD_VAR 0 2
5192: ARRAY
5193: PUSH
5194: LD_EXP 42
5198: PUSH
5199: LD_VAR 0 2
5203: ARRAY
5204: PPUSH
5205: LD_INT 2
5207: PUSH
5208: LD_INT 34
5210: PUSH
5211: LD_INT 31
5213: PUSH
5214: EMPTY
5215: LIST
5216: LIST
5217: PUSH
5218: LD_INT 34
5220: PUSH
5221: LD_INT 32
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: PUSH
5228: LD_INT 34
5230: PUSH
5231: LD_INT 88
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: PPUSH
5244: CALL_OW 72
5248: DIFF
5249: ST_TO_ADDR
// if not attackers then
5250: LD_VAR 0 4
5254: NOT
5255: IFFALSE 5259
// exit ;
5257: GO 5482
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5259: LD_ADDR_EXP 42
5263: PUSH
5264: LD_EXP 42
5268: PPUSH
5269: LD_VAR 0 2
5273: PPUSH
5274: LD_EXP 42
5278: PUSH
5279: LD_VAR 0 2
5283: ARRAY
5284: PUSH
5285: LD_VAR 0 4
5289: DIFF
5290: PPUSH
5291: CALL_OW 1
5295: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5296: LD_VAR 0 4
5300: PPUSH
5301: LD_INT 107
5303: PPUSH
5304: LD_INT 74
5306: PPUSH
5307: CALL_OW 114
// wait ( 0 0$5 ) ;
5311: LD_INT 175
5313: PPUSH
5314: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5318: LD_INT 35
5320: PPUSH
5321: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5325: LD_VAR 0 4
5329: PPUSH
5330: LD_INT 60
5332: PUSH
5333: EMPTY
5334: LIST
5335: PPUSH
5336: CALL_OW 72
5340: NOT
5341: IFFALSE 5318
// if rand ( 0 , 1 ) then
5343: LD_INT 0
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL_OW 12
5353: IFFALSE 5372
// ComAgressiveMove ( attackers , 155 , 108 ) else
5355: LD_VAR 0 4
5359: PPUSH
5360: LD_INT 155
5362: PPUSH
5363: LD_INT 108
5365: PPUSH
5366: CALL_OW 114
5370: GO 5387
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5372: LD_VAR 0 4
5376: PPUSH
5377: LD_INT 149
5379: PPUSH
5380: LD_INT 55
5382: PPUSH
5383: CALL_OW 114
// wait ( 0 0$10 ) ;
5387: LD_INT 350
5389: PPUSH
5390: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5394: LD_INT 35
5396: PPUSH
5397: CALL_OW 67
// for i in attackers do
5401: LD_ADDR_VAR 0 1
5405: PUSH
5406: LD_VAR 0 4
5410: PUSH
5411: FOR_IN
5412: IFFALSE 5462
// if not HasTask ( i ) then
5414: LD_VAR 0 1
5418: PPUSH
5419: CALL_OW 314
5423: NOT
5424: IFFALSE 5460
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5426: LD_VAR 0 1
5430: PPUSH
5431: LD_INT 81
5433: PUSH
5434: LD_INT 2
5436: PUSH
5437: EMPTY
5438: LIST
5439: LIST
5440: PPUSH
5441: CALL_OW 69
5445: PPUSH
5446: LD_VAR 0 1
5450: PPUSH
5451: CALL_OW 74
5455: PPUSH
5456: CALL_OW 115
5460: GO 5411
5462: POP
5463: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5464: LD_VAR 0 4
5468: PPUSH
5469: LD_INT 50
5471: PUSH
5472: EMPTY
5473: LIST
5474: PPUSH
5475: CALL_OW 72
5479: NOT
5480: IFFALSE 5394
// end ;
5482: PPOPN 5
5484: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5485: LD_EXP 4
5489: NOT
5490: PUSH
5491: LD_OWVAR 1
5495: PUSH
5496: LD_INT 191100
5498: LESS
5499: AND
5500: IFFALSE 6172
5502: GO 5504
5504: DISABLE
5505: LD_INT 0
5507: PPUSH
5508: PPUSH
5509: PPUSH
// begin enable ;
5510: ENABLE
// tmp := [ ] ;
5511: LD_ADDR_VAR 0 3
5515: PUSH
5516: EMPTY
5517: ST_TO_ADDR
// if tick < 35 35$00 then
5518: LD_OWVAR 1
5522: PUSH
5523: LD_INT 73500
5525: LESS
5526: IFFALSE 5724
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: DOUBLE
5534: LD_INT 1
5536: DEC
5537: ST_TO_ADDR
5538: LD_INT 4
5540: PUSH
5541: LD_INT 5
5543: PUSH
5544: LD_INT 5
5546: PUSH
5547: EMPTY
5548: LIST
5549: LIST
5550: LIST
5551: PUSH
5552: LD_OWVAR 67
5556: ARRAY
5557: PUSH
5558: FOR_TO
5559: IFFALSE 5720
// begin uc_side := 2 ;
5561: LD_ADDR_OWVAR 20
5565: PUSH
5566: LD_INT 2
5568: ST_TO_ADDR
// uc_nation := 2 ;
5569: LD_ADDR_OWVAR 21
5573: PUSH
5574: LD_INT 2
5576: ST_TO_ADDR
// InitHC_All ( ) ;
5577: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5581: LD_INT 0
5583: PPUSH
5584: LD_INT 1
5586: PPUSH
5587: LD_INT 5
5589: PUSH
5590: LD_INT 6
5592: PUSH
5593: LD_INT 7
5595: PUSH
5596: EMPTY
5597: LIST
5598: LIST
5599: LIST
5600: PUSH
5601: LD_OWVAR 67
5605: ARRAY
5606: PPUSH
5607: CALL_OW 380
// un := CreateHuman ;
5611: LD_ADDR_VAR 0 2
5615: PUSH
5616: CALL_OW 44
5620: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5621: LD_VAR 0 2
5625: PPUSH
5626: LD_INT 17
5628: PPUSH
5629: LD_INT 0
5631: PPUSH
5632: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5636: LD_VAR 0 2
5640: PPUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 8
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: LD_INT 1
5653: PPUSH
5654: LD_INT 2
5656: PPUSH
5657: CALL_OW 12
5661: ARRAY
5662: PPUSH
5663: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 111
5674: PPUSH
5675: LD_INT 34
5677: PPUSH
5678: CALL_OW 114
// wait ( 0 0$2 ) ;
5682: LD_INT 70
5684: PPUSH
5685: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5689: LD_ADDR_VAR 0 3
5693: PUSH
5694: LD_VAR 0 3
5698: PPUSH
5699: LD_VAR 0 3
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PPUSH
5708: LD_VAR 0 2
5712: PPUSH
5713: CALL_OW 1
5717: ST_TO_ADDR
// end ;
5718: GO 5558
5720: POP
5721: POP
// end else
5722: GO 5865
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5724: LD_ADDR_VAR 0 1
5728: PUSH
5729: DOUBLE
5730: LD_INT 1
5732: DEC
5733: ST_TO_ADDR
5734: LD_INT 4
5736: PUSH
5737: LD_INT 5
5739: PUSH
5740: LD_INT 5
5742: PUSH
5743: EMPTY
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_OWVAR 67
5752: ARRAY
5753: PUSH
5754: FOR_TO
5755: IFFALSE 5863
// begin uc_side := 2 ;
5757: LD_ADDR_OWVAR 20
5761: PUSH
5762: LD_INT 2
5764: ST_TO_ADDR
// uc_nation := 0 ;
5765: LD_ADDR_OWVAR 21
5769: PUSH
5770: LD_INT 0
5772: ST_TO_ADDR
// InitHC_All ( ) ;
5773: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5777: LD_ADDR_OWVAR 28
5781: PUSH
5782: LD_INT 17
5784: ST_TO_ADDR
// un := CreateHuman ;
5785: LD_ADDR_VAR 0 2
5789: PUSH
5790: CALL_OW 44
5794: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_INT 17
5802: PPUSH
5803: LD_INT 0
5805: PPUSH
5806: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5810: LD_VAR 0 2
5814: PPUSH
5815: LD_INT 110
5817: PPUSH
5818: LD_INT 33
5820: PPUSH
5821: CALL_OW 114
// wait ( 0 0$2 ) ;
5825: LD_INT 70
5827: PPUSH
5828: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5832: LD_ADDR_VAR 0 3
5836: PUSH
5837: LD_VAR 0 3
5841: PPUSH
5842: LD_VAR 0 3
5846: PUSH
5847: LD_INT 1
5849: PLUS
5850: PPUSH
5851: LD_VAR 0 2
5855: PPUSH
5856: CALL_OW 1
5860: ST_TO_ADDR
// end ;
5861: GO 5754
5863: POP
5864: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5865: LD_ADDR_VAR 0 1
5869: PUSH
5870: DOUBLE
5871: LD_INT 1
5873: DEC
5874: ST_TO_ADDR
5875: LD_INT 3
5877: PUSH
5878: LD_INT 4
5880: PUSH
5881: LD_INT 5
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_OWVAR 67
5893: ARRAY
5894: PUSH
5895: FOR_TO
5896: IFFALSE 6061
// begin uc_side := 2 ;
5898: LD_ADDR_OWVAR 20
5902: PUSH
5903: LD_INT 2
5905: ST_TO_ADDR
// uc_nation := 2 ;
5906: LD_ADDR_OWVAR 21
5910: PUSH
5911: LD_INT 2
5913: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5914: LD_INT 14
5916: PPUSH
5917: LD_INT 3
5919: PPUSH
5920: LD_INT 5
5922: PPUSH
5923: LD_INT 29
5925: PUSH
5926: LD_INT 28
5928: PUSH
5929: LD_INT 27
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: PUSH
5937: LD_INT 1
5939: PPUSH
5940: LD_INT 3
5942: PPUSH
5943: CALL_OW 12
5947: ARRAY
5948: PPUSH
5949: LD_INT 90
5951: PPUSH
5952: CALL 16130 0 5
// un := CreateVehicle ;
5956: LD_ADDR_VAR 0 2
5960: PUSH
5961: CALL_OW 45
5965: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: LD_INT 2
5973: PPUSH
5974: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_INT 17
5985: PPUSH
5986: LD_INT 0
5988: PPUSH
5989: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5993: LD_VAR 0 2
5997: PPUSH
5998: LD_INT 66
6000: PPUSH
6001: LD_INT 23
6003: PPUSH
6004: CALL_OW 111
// wait ( 0 0$3 ) ;
6008: LD_INT 105
6010: PPUSH
6011: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6015: LD_VAR 0 2
6019: PPUSH
6020: LD_INT 147
6022: PPUSH
6023: LD_INT 103
6025: PPUSH
6026: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6030: LD_ADDR_VAR 0 3
6034: PUSH
6035: LD_VAR 0 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 1
6047: PLUS
6048: PPUSH
6049: LD_VAR 0 2
6053: PPUSH
6054: CALL_OW 1
6058: ST_TO_ADDR
// end ;
6059: GO 5895
6061: POP
6062: POP
// if not tmp then
6063: LD_VAR 0 3
6067: NOT
6068: IFFALSE 6072
// exit ;
6070: GO 6172
// wait ( 0 0$5 ) ;
6072: LD_INT 175
6074: PPUSH
6075: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6079: LD_INT 70
6081: PPUSH
6082: CALL_OW 67
// for i in tmp do
6086: LD_ADDR_VAR 0 1
6090: PUSH
6091: LD_VAR 0 3
6095: PUSH
6096: FOR_IN
6097: IFFALSE 6163
// begin if not IsOk ( i ) then
6099: LD_VAR 0 1
6103: PPUSH
6104: CALL_OW 302
6108: NOT
6109: IFFALSE 6127
// tmp := tmp diff i ;
6111: LD_ADDR_VAR 0 3
6115: PUSH
6116: LD_VAR 0 3
6120: PUSH
6121: LD_VAR 0 1
6125: DIFF
6126: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6127: LD_VAR 0 1
6131: PPUSH
6132: LD_INT 81
6134: PUSH
6135: LD_INT 2
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 69
6146: PPUSH
6147: LD_VAR 0 1
6151: PPUSH
6152: CALL_OW 74
6156: PPUSH
6157: CALL_OW 115
// end ;
6161: GO 6096
6163: POP
6164: POP
// until not tmp ;
6165: LD_VAR 0 3
6169: NOT
6170: IFFALSE 6079
// end ;
6172: PPOPN 3
6174: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6175: LD_OWVAR 67
6179: PUSH
6180: LD_INT 1
6182: GREATER
6183: IFFALSE 6281
6185: GO 6187
6187: DISABLE
6188: LD_INT 0
6190: PPUSH
// begin uc_side := 2 ;
6191: LD_ADDR_OWVAR 20
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// uc_nation := 2 ;
6199: LD_ADDR_OWVAR 21
6203: PUSH
6204: LD_INT 2
6206: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 4
6212: PPUSH
6213: LD_INT 6
6215: PPUSH
6216: CALL_OW 380
// un := CreateHuman ;
6220: LD_ADDR_VAR 0 1
6224: PUSH
6225: CALL_OW 44
6229: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6230: LD_VAR 0 1
6234: PPUSH
6235: LD_INT 88
6237: PPUSH
6238: LD_INT 1
6240: PPUSH
6241: LD_INT 2
6243: PPUSH
6244: LD_INT 0
6246: PPUSH
6247: CALL 50723 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6251: LD_VAR 0 1
6255: PPUSH
6256: LD_INT 130
6258: PPUSH
6259: LD_INT 35
6261: PPUSH
6262: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 132
6273: PPUSH
6274: LD_INT 39
6276: PPUSH
6277: CALL_OW 218
// end ;
6281: PPOPN 1
6283: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6284: LD_INT 22
6286: PUSH
6287: LD_INT 2
6289: PUSH
6290: EMPTY
6291: LIST
6292: LIST
6293: PUSH
6294: LD_INT 33
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 50
6306: PUSH
6307: EMPTY
6308: LIST
6309: PUSH
6310: LD_INT 3
6312: PUSH
6313: LD_INT 61
6315: PUSH
6316: EMPTY
6317: LIST
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: PUSH
6323: EMPTY
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 69
6333: IFFALSE 6424
6335: GO 6337
6337: DISABLE
6338: LD_INT 0
6340: PPUSH
6341: PPUSH
// begin enable ;
6342: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6343: LD_ADDR_VAR 0 2
6347: PUSH
6348: LD_INT 22
6350: PUSH
6351: LD_INT 2
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PUSH
6358: LD_INT 33
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 50
6370: PUSH
6371: EMPTY
6372: LIST
6373: PUSH
6374: LD_INT 3
6376: PUSH
6377: LD_INT 61
6379: PUSH
6380: EMPTY
6381: LIST
6382: PUSH
6383: EMPTY
6384: LIST
6385: LIST
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: LIST
6391: LIST
6392: PPUSH
6393: CALL_OW 69
6397: ST_TO_ADDR
// for i in tmp do
6398: LD_ADDR_VAR 0 1
6402: PUSH
6403: LD_VAR 0 2
6407: PUSH
6408: FOR_IN
6409: IFFALSE 6422
// Connect ( i ) ;
6411: LD_VAR 0 1
6415: PPUSH
6416: CALL 19221 0 1
6420: GO 6408
6422: POP
6423: POP
// end ; end_of_file
6424: PPOPN 2
6426: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6427: LD_INT 0
6429: PPUSH
6430: PPUSH
6431: PPUSH
6432: PPUSH
6433: PPUSH
6434: PPUSH
// popov_side := 3 ;
6435: LD_ADDR_EXP 17
6439: PUSH
6440: LD_INT 3
6442: ST_TO_ADDR
// uc_side := popov_side ;
6443: LD_ADDR_OWVAR 20
6447: PUSH
6448: LD_EXP 17
6452: ST_TO_ADDR
// uc_nation := 3 ;
6453: LD_ADDR_OWVAR 21
6457: PUSH
6458: LD_INT 3
6460: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6461: LD_ADDR_VAR 0 6
6465: PUSH
6466: LD_INT 5
6468: PUSH
6469: LD_INT 103
6471: PUSH
6472: LD_INT 147
6474: PUSH
6475: LD_INT 3
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: LIST
6482: LIST
6483: PUSH
6484: LD_INT 5
6486: PUSH
6487: LD_INT 70
6489: PUSH
6490: LD_INT 117
6492: PUSH
6493: LD_INT 3
6495: PUSH
6496: EMPTY
6497: LIST
6498: LIST
6499: LIST
6500: LIST
6501: PUSH
6502: LD_INT 6
6504: PUSH
6505: LD_INT 76
6507: PUSH
6508: LD_INT 145
6510: PUSH
6511: LD_INT 1
6513: PUSH
6514: LD_INT 10
6516: PUSH
6517: LD_INT 11
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: LIST
6526: LIST
6527: PUSH
6528: LD_INT 26
6530: PUSH
6531: LD_INT 87
6533: PUSH
6534: LD_INT 144
6536: PUSH
6537: LD_INT 0
6539: PUSH
6540: EMPTY
6541: LIST
6542: LIST
6543: LIST
6544: LIST
6545: PUSH
6546: LD_INT 29
6548: PUSH
6549: LD_INT 86
6551: PUSH
6552: LD_INT 118
6554: PUSH
6555: LD_INT 0
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: PUSH
6564: LD_INT 29
6566: PUSH
6567: LD_INT 98
6569: PUSH
6570: LD_INT 121
6572: PUSH
6573: LD_INT 0
6575: PUSH
6576: EMPTY
6577: LIST
6578: LIST
6579: LIST
6580: LIST
6581: PUSH
6582: LD_INT 26
6584: PUSH
6585: LD_INT 87
6587: PUSH
6588: LD_INT 147
6590: PUSH
6591: LD_INT 1
6593: PUSH
6594: EMPTY
6595: LIST
6596: LIST
6597: LIST
6598: LIST
6599: PUSH
6600: LD_INT 30
6602: PUSH
6603: LD_INT 123
6605: PUSH
6606: LD_INT 151
6608: PUSH
6609: LD_INT 1
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PUSH
6618: LD_INT 3
6620: PUSH
6621: LD_INT 94
6623: PUSH
6624: LD_INT 161
6626: PUSH
6627: LD_INT 0
6629: PUSH
6630: EMPTY
6631: LIST
6632: LIST
6633: LIST
6634: LIST
6635: PUSH
6636: LD_INT 6
6638: PUSH
6639: LD_INT 81
6641: PUSH
6642: LD_INT 155
6644: PUSH
6645: LD_INT 1
6647: PUSH
6648: LD_INT 12
6650: PUSH
6651: LD_INT 14
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: LIST
6658: LIST
6659: LIST
6660: LIST
6661: PUSH
6662: LD_INT 26
6664: PUSH
6665: LD_INT 96
6667: PUSH
6668: LD_INT 152
6670: PUSH
6671: LD_INT 0
6673: PUSH
6674: EMPTY
6675: LIST
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: LD_INT 26
6682: PUSH
6683: LD_INT 96
6685: PUSH
6686: LD_INT 149
6688: PUSH
6689: LD_INT 3
6691: PUSH
6692: EMPTY
6693: LIST
6694: LIST
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 32
6700: PUSH
6701: LD_INT 109
6703: PUSH
6704: LD_INT 142
6706: PUSH
6707: LD_INT 3
6709: PUSH
6710: LD_INT 46
6712: PUSH
6713: EMPTY
6714: LIST
6715: LIST
6716: LIST
6717: LIST
6718: LIST
6719: PUSH
6720: LD_INT 32
6722: PUSH
6723: LD_INT 112
6725: PUSH
6726: LD_INT 148
6728: PUSH
6729: LD_INT 3
6731: PUSH
6732: LD_INT 46
6734: PUSH
6735: EMPTY
6736: LIST
6737: LIST
6738: LIST
6739: LIST
6740: LIST
6741: PUSH
6742: LD_INT 33
6744: PUSH
6745: LD_INT 120
6747: PUSH
6748: LD_INT 159
6750: PUSH
6751: LD_INT 4
6753: PUSH
6754: LD_INT 45
6756: PUSH
6757: EMPTY
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: PUSH
6764: LD_INT 33
6766: PUSH
6767: LD_INT 122
6769: PUSH
6770: LD_INT 163
6772: PUSH
6773: LD_INT 4
6775: PUSH
6776: LD_INT 45
6778: PUSH
6779: EMPTY
6780: LIST
6781: LIST
6782: LIST
6783: LIST
6784: LIST
6785: PUSH
6786: LD_INT 33
6788: PUSH
6789: LD_INT 123
6791: PUSH
6792: LD_INT 167
6794: PUSH
6795: LD_INT 4
6797: PUSH
6798: LD_INT 45
6800: PUSH
6801: EMPTY
6802: LIST
6803: LIST
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 33
6810: PUSH
6811: LD_INT 59
6813: PUSH
6814: LD_INT 111
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 45
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: LIST
6829: PUSH
6830: LD_INT 33
6832: PUSH
6833: LD_INT 65
6835: PUSH
6836: LD_INT 111
6838: PUSH
6839: LD_INT 3
6841: PUSH
6842: LD_INT 46
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: LIST
6849: LIST
6850: LIST
6851: PUSH
6852: LD_INT 33
6854: PUSH
6855: LD_INT 76
6857: PUSH
6858: LD_INT 117
6860: PUSH
6861: LD_INT 3
6863: PUSH
6864: LD_INT 45
6866: PUSH
6867: EMPTY
6868: LIST
6869: LIST
6870: LIST
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 33
6876: PUSH
6877: LD_INT 80
6879: PUSH
6880: LD_INT 119
6882: PUSH
6883: LD_INT 3
6885: PUSH
6886: LD_INT 46
6888: PUSH
6889: EMPTY
6890: LIST
6891: LIST
6892: LIST
6893: LIST
6894: LIST
6895: PUSH
6896: LD_INT 33
6898: PUSH
6899: LD_INT 87
6901: PUSH
6902: LD_INT 125
6904: PUSH
6905: LD_INT 3
6907: PUSH
6908: LD_INT 45
6910: PUSH
6911: EMPTY
6912: LIST
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: PUSH
6918: LD_INT 5
6920: PUSH
6921: LD_INT 92
6923: PUSH
6924: LD_INT 129
6926: PUSH
6927: LD_INT 3
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 28
6938: PUSH
6939: LD_INT 85
6941: PUSH
6942: LD_INT 165
6944: PUSH
6945: LD_INT 0
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PUSH
6954: LD_INT 28
6956: PUSH
6957: LD_INT 83
6959: PUSH
6960: LD_INT 161
6962: PUSH
6963: LD_INT 4
6965: PUSH
6966: EMPTY
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: PUSH
6972: LD_INT 28
6974: PUSH
6975: LD_INT 91
6977: PUSH
6978: LD_INT 166
6980: PUSH
6981: LD_INT 3
6983: PUSH
6984: EMPTY
6985: LIST
6986: LIST
6987: LIST
6988: LIST
6989: PUSH
6990: LD_INT 28
6992: PUSH
6993: LD_INT 102
6995: PUSH
6996: LD_INT 166
6998: PUSH
6999: LD_INT 2
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: LIST
7018: LIST
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: ST_TO_ADDR
// for i in list do
7037: LD_ADDR_VAR 0 2
7041: PUSH
7042: LD_VAR 0 6
7046: PUSH
7047: FOR_IN
7048: IFFALSE 7258
// begin uc_side := 3 ;
7050: LD_ADDR_OWVAR 20
7054: PUSH
7055: LD_INT 3
7057: ST_TO_ADDR
// uc_nation := 3 ;
7058: LD_ADDR_OWVAR 21
7062: PUSH
7063: LD_INT 3
7065: ST_TO_ADDR
// InitBc ;
7066: CALL_OW 21
// bc_type := i [ 1 ] ;
7070: LD_ADDR_OWVAR 42
7074: PUSH
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7084: LD_VAR 0 2
7088: PUSH
7089: LD_INT 1
7091: ARRAY
7092: PUSH
7093: LD_INT 29
7095: PUSH
7096: LD_INT 30
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: IN
7103: IFFALSE 7130
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7105: LD_VAR 0 2
7109: PUSH
7110: LD_INT 2
7112: ARRAY
7113: PPUSH
7114: LD_VAR 0 2
7118: PUSH
7119: LD_INT 3
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: CALL_OW 441
// if i [ 1 ] = b_lab then
7130: LD_VAR 0 2
7134: PUSH
7135: LD_INT 1
7137: ARRAY
7138: PUSH
7139: LD_INT 6
7141: EQUAL
7142: IFFALSE 7180
// begin bc_type := b_lab_full ;
7144: LD_ADDR_OWVAR 42
7148: PUSH
7149: LD_INT 8
7151: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7152: LD_ADDR_OWVAR 44
7156: PUSH
7157: LD_VAR 0 2
7161: PUSH
7162: LD_INT 5
7164: ARRAY
7165: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7166: LD_ADDR_OWVAR 45
7170: PUSH
7171: LD_VAR 0 2
7175: PUSH
7176: LD_INT 6
7178: ARRAY
7179: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7180: LD_ADDR_VAR 0 5
7184: PUSH
7185: LD_VAR 0 2
7189: PUSH
7190: LD_INT 2
7192: ARRAY
7193: PPUSH
7194: LD_VAR 0 2
7198: PUSH
7199: LD_INT 3
7201: ARRAY
7202: PPUSH
7203: LD_VAR 0 2
7207: PUSH
7208: LD_INT 4
7210: ARRAY
7211: PPUSH
7212: CALL_OW 47
7216: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7217: LD_VAR 0 2
7221: PUSH
7222: LD_INT 1
7224: ARRAY
7225: PUSH
7226: LD_INT 33
7228: PUSH
7229: LD_INT 32
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: IN
7236: IFFALSE 7256
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7238: LD_VAR 0 5
7242: PPUSH
7243: LD_VAR 0 2
7247: PUSH
7248: LD_INT 5
7250: ARRAY
7251: PPUSH
7252: CALL_OW 431
// end ;
7256: GO 7047
7258: POP
7259: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7260: LD_ADDR_VAR 0 4
7264: PUSH
7265: LD_INT 9
7267: PPUSH
7268: LD_INT 3
7270: PPUSH
7271: LD_STRING 
7273: PPUSH
7274: LD_INT 8
7276: PUSH
7277: LD_INT 7
7279: PUSH
7280: LD_INT 6
7282: PUSH
7283: EMPTY
7284: LIST
7285: LIST
7286: LIST
7287: PUSH
7288: LD_OWVAR 67
7292: ARRAY
7293: PPUSH
7294: LD_INT 11500
7296: PUSH
7297: LD_INT 1100
7299: PUSH
7300: LD_INT 60
7302: PUSH
7303: EMPTY
7304: LIST
7305: LIST
7306: LIST
7307: PPUSH
7308: LD_INT 6
7310: PUSH
7311: LD_INT 6
7313: PUSH
7314: LD_INT 6
7316: PUSH
7317: LD_INT 6
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PPUSH
7326: CALL 19574 0 6
7330: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7331: LD_ADDR_EXP 23
7335: PUSH
7336: LD_EXP 23
7340: PPUSH
7341: LD_INT 3
7343: PPUSH
7344: LD_VAR 0 4
7348: PUSH
7349: LD_INT 22
7351: PUSH
7352: LD_INT 3
7354: PUSH
7355: EMPTY
7356: LIST
7357: LIST
7358: PUSH
7359: LD_INT 21
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: EMPTY
7370: LIST
7371: LIST
7372: PPUSH
7373: CALL_OW 69
7377: UNION
7378: PPUSH
7379: CALL_OW 1
7383: ST_TO_ADDR
// extraPopovForces := [ ] ;
7384: LD_ADDR_EXP 18
7388: PUSH
7389: EMPTY
7390: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7391: LD_ADDR_VAR 0 2
7395: PUSH
7396: DOUBLE
7397: LD_INT 1
7399: DEC
7400: ST_TO_ADDR
7401: LD_INT 8
7403: PUSH
7404: LD_INT 9
7406: PUSH
7407: LD_INT 10
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: LIST
7414: PUSH
7415: LD_OWVAR 67
7419: ARRAY
7420: PUSH
7421: FOR_TO
7422: IFFALSE 7551
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7424: LD_INT 0
7426: PPUSH
7427: LD_INT 1
7429: PPUSH
7430: LD_INT 4
7432: PUSH
7433: LD_INT 5
7435: PUSH
7436: LD_INT 6
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: LIST
7443: PUSH
7444: LD_OWVAR 67
7448: ARRAY
7449: PPUSH
7450: CALL_OW 380
// un := CreateHuman ;
7454: LD_ADDR_VAR 0 3
7458: PUSH
7459: CALL_OW 44
7463: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7464: LD_INT 0
7466: PPUSH
7467: LD_INT 1
7469: PPUSH
7470: CALL_OW 12
7474: IFFALSE 7499
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7476: LD_VAR 0 3
7480: PPUSH
7481: LD_INT 131
7483: PPUSH
7484: LD_INT 110
7486: PPUSH
7487: LD_INT 8
7489: PPUSH
7490: LD_INT 0
7492: PPUSH
7493: CALL_OW 50
7497: GO 7520
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7499: LD_VAR 0 3
7503: PPUSH
7504: LD_INT 100
7506: PPUSH
7507: LD_INT 99
7509: PPUSH
7510: LD_INT 8
7512: PPUSH
7513: LD_INT 0
7515: PPUSH
7516: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7520: LD_ADDR_EXP 18
7524: PUSH
7525: LD_EXP 18
7529: PPUSH
7530: LD_EXP 18
7534: PUSH
7535: LD_INT 1
7537: PLUS
7538: PPUSH
7539: LD_VAR 0 3
7543: PPUSH
7544: CALL_OW 1
7548: ST_TO_ADDR
// end ;
7549: GO 7421
7551: POP
7552: POP
// PrepareSoldier ( false , 6 ) ;
7553: LD_INT 0
7555: PPUSH
7556: LD_INT 6
7558: PPUSH
7559: CALL_OW 381
// un := CreateHuman ;
7563: LD_ADDR_VAR 0 3
7567: PUSH
7568: CALL_OW 44
7572: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7573: LD_VAR 0 3
7577: PPUSH
7578: LD_INT 1
7580: PPUSH
7581: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7585: LD_VAR 0 3
7589: PPUSH
7590: LD_INT 150
7592: PPUSH
7593: LD_INT 158
7595: PPUSH
7596: CALL_OW 428
7600: PPUSH
7601: CALL_OW 52
// popovAttackGroup := [ ] ;
7605: LD_ADDR_EXP 19
7609: PUSH
7610: EMPTY
7611: ST_TO_ADDR
// end ;
7612: LD_VAR 0 1
7616: RET
// export function InitMC_Popov ( ) ; begin
7617: LD_INT 0
7619: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7620: LD_INT 3
7622: PPUSH
7623: LD_INT 3
7625: PPUSH
7626: CALL 78093 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 10
7635: PPUSH
7636: CALL 78037 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 86
7645: PUSH
7646: LD_INT 118
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: EMPTY
7653: LIST
7654: LIST
7655: LIST
7656: PUSH
7657: LD_INT 123
7659: PUSH
7660: LD_INT 151
7662: PUSH
7663: LD_INT 1
7665: PUSH
7666: EMPTY
7667: LIST
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 98
7673: PUSH
7674: LD_INT 121
7676: PUSH
7677: LD_INT 0
7679: PUSH
7680: EMPTY
7681: LIST
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PPUSH
7690: CALL 77096 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7694: LD_INT 3
7696: PPUSH
7697: LD_INT 46
7699: PUSH
7700: LD_INT 45
7702: PUSH
7703: EMPTY
7704: LIST
7705: LIST
7706: PPUSH
7707: CALL 77925 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7711: LD_INT 3
7713: PPUSH
7714: LD_INT 12
7716: PPUSH
7717: CALL 77607 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 11
7726: PPUSH
7727: CALL 77338 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 4
7736: PPUSH
7737: CALL 76957 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 23
7746: PUSH
7747: LD_INT 1
7749: PUSH
7750: LD_INT 3
7752: PUSH
7753: LD_INT 44
7755: PUSH
7756: EMPTY
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: PUSH
7762: LD_INT 23
7764: PUSH
7765: LD_INT 1
7767: PUSH
7768: LD_INT 3
7770: PUSH
7771: LD_INT 45
7773: PUSH
7774: EMPTY
7775: LIST
7776: LIST
7777: LIST
7778: LIST
7779: PUSH
7780: LD_INT 21
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: LD_INT 3
7788: PUSH
7789: LD_INT 44
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: LIST
7796: LIST
7797: PUSH
7798: LD_INT 21
7800: PUSH
7801: LD_INT 1
7803: PUSH
7804: LD_INT 3
7806: PUSH
7807: LD_INT 45
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: LIST
7820: LIST
7821: PPUSH
7822: CALL 76772 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7826: LD_INT 3
7828: PPUSH
7829: LD_INT 94
7831: PPUSH
7832: LD_INT 161
7834: PPUSH
7835: LD_INT 0
7837: PPUSH
7838: LD_INT 19
7840: PUSH
7841: LD_INT 17
7843: PUSH
7844: LD_INT 18
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 21
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: LIST
7857: LIST
7858: LIST
7859: PPUSH
7860: CALL 77719 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7864: LD_INT 3
7866: PPUSH
7867: LD_INT 21
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 51
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: EMPTY
7886: LIST
7887: PPUSH
7888: CALL 76820 0 2
// end ;
7892: LD_VAR 0 1
7896: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7897: LD_EXP 18
7901: PUSH
7902: LD_EXP 5
7906: NOT
7907: AND
7908: IFFALSE 7968
7910: GO 7912
7912: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7913: LD_EXP 18
7917: PPUSH
7918: LD_INT 106
7920: PPUSH
7921: LD_INT 137
7923: PPUSH
7924: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7928: LD_ADDR_EXP 23
7932: PUSH
7933: LD_EXP 23
7937: PPUSH
7938: LD_INT 3
7940: PPUSH
7941: LD_EXP 23
7945: PUSH
7946: LD_INT 3
7948: ARRAY
7949: PUSH
7950: LD_EXP 18
7954: UNION
7955: PPUSH
7956: CALL_OW 1
7960: ST_TO_ADDR
// extraPopovForces := [ ] ;
7961: LD_ADDR_EXP 18
7965: PUSH
7966: EMPTY
7967: ST_TO_ADDR
// end ;
7968: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7969: LD_INT 9
7971: PPUSH
7972: CALL_OW 302
7976: PUSH
7977: LD_EXP 5
7981: NOT
7982: AND
7983: IFFALSE 8549
7985: GO 7987
7987: DISABLE
7988: LD_INT 0
7990: PPUSH
7991: PPUSH
7992: PPUSH
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// base := 3 ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8004: LD_ADDR_VAR 0 3
8008: PUSH
8009: LD_INT 21
8011: PUSH
8012: LD_INT 1
8014: PUSH
8015: LD_INT 3
8017: PUSH
8018: LD_INT 44
8020: PUSH
8021: EMPTY
8022: LIST
8023: LIST
8024: LIST
8025: LIST
8026: PUSH
8027: LD_INT 23
8029: PUSH
8030: LD_INT 1
8032: PUSH
8033: LD_INT 3
8035: PUSH
8036: LD_INT 46
8038: PUSH
8039: EMPTY
8040: LIST
8041: LIST
8042: LIST
8043: LIST
8044: PUSH
8045: LD_INT 23
8047: PUSH
8048: LD_INT 1
8050: PUSH
8051: LD_INT 3
8053: PUSH
8054: LD_INT 46
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: LIST
8061: LIST
8062: PUSH
8063: LD_INT 23
8065: PUSH
8066: LD_INT 1
8068: PUSH
8069: LD_INT 3
8071: PUSH
8072: LD_INT 46
8074: PUSH
8075: EMPTY
8076: LIST
8077: LIST
8078: LIST
8079: LIST
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: LIST
8085: LIST
8086: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8087: LD_ADDR_VAR 0 5
8091: PUSH
8092: LD_VAR 0 5
8096: PUSH
8097: LD_OWVAR 1
8101: PUSH
8102: LD_INT 21000
8104: DIV
8105: PLUS
8106: ST_TO_ADDR
// if amount > 8 then
8107: LD_VAR 0 5
8111: PUSH
8112: LD_INT 8
8114: GREATER
8115: IFFALSE 8125
// amount := 8 ;
8117: LD_ADDR_VAR 0 5
8121: PUSH
8122: LD_INT 8
8124: ST_TO_ADDR
// for i = 1 to amount do
8125: LD_ADDR_VAR 0 1
8129: PUSH
8130: DOUBLE
8131: LD_INT 1
8133: DEC
8134: ST_TO_ADDR
8135: LD_VAR 0 5
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8206
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8143: LD_ADDR_VAR 0 3
8147: PUSH
8148: LD_VAR 0 3
8152: PPUSH
8153: LD_VAR 0 3
8157: PUSH
8158: LD_INT 1
8160: PLUS
8161: PPUSH
8162: LD_INT 23
8164: PUSH
8165: LD_INT 1
8167: PUSH
8168: LD_INT 3
8170: PUSH
8171: LD_INT 46
8173: PUSH
8174: LD_INT 45
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PUSH
8193: EMPTY
8194: LIST
8195: LIST
8196: LIST
8197: LIST
8198: PPUSH
8199: CALL_OW 2
8203: ST_TO_ADDR
8204: GO 8140
8206: POP
8207: POP
// MC_InsertProduceList ( base , tmp ) ;
8208: LD_VAR 0 2
8212: PPUSH
8213: LD_VAR 0 3
8217: PPUSH
8218: CALL 76820 0 2
// repeat wait ( 0 0$1 ) ;
8222: LD_INT 35
8224: PPUSH
8225: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8229: LD_VAR 0 2
8233: PPUSH
8234: LD_INT 1
8236: PPUSH
8237: CALL 78238 0 2
8241: PUSH
8242: LD_VAR 0 5
8246: GREATEREQUAL
8247: IFFALSE 8222
// wait ( 0 0$30 ) ;
8249: LD_INT 1050
8251: PPUSH
8252: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8256: LD_ADDR_VAR 0 4
8260: PUSH
8261: LD_EXP 42
8265: PUSH
8266: LD_VAR 0 2
8270: ARRAY
8271: PUSH
8272: LD_EXP 42
8276: PUSH
8277: LD_VAR 0 2
8281: ARRAY
8282: PPUSH
8283: LD_INT 2
8285: PUSH
8286: LD_INT 34
8288: PUSH
8289: LD_INT 51
8291: PUSH
8292: EMPTY
8293: LIST
8294: LIST
8295: PUSH
8296: LD_INT 34
8298: PUSH
8299: LD_INT 52
8301: PUSH
8302: EMPTY
8303: LIST
8304: LIST
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: LIST
8310: PPUSH
8311: CALL_OW 72
8315: DIFF
8316: ST_TO_ADDR
// if not attackers then
8317: LD_VAR 0 4
8321: NOT
8322: IFFALSE 8326
// exit ;
8324: GO 8549
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8326: LD_ADDR_EXP 42
8330: PUSH
8331: LD_EXP 42
8335: PPUSH
8336: LD_VAR 0 2
8340: PPUSH
8341: LD_EXP 42
8345: PUSH
8346: LD_VAR 0 2
8350: ARRAY
8351: PUSH
8352: LD_VAR 0 4
8356: DIFF
8357: PPUSH
8358: CALL_OW 1
8362: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8363: LD_VAR 0 4
8367: PPUSH
8368: LD_INT 107
8370: PPUSH
8371: LD_INT 74
8373: PPUSH
8374: CALL_OW 114
// wait ( 0 0$5 ) ;
8378: LD_INT 175
8380: PPUSH
8381: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8385: LD_INT 35
8387: PPUSH
8388: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8392: LD_VAR 0 4
8396: PPUSH
8397: LD_INT 60
8399: PUSH
8400: EMPTY
8401: LIST
8402: PPUSH
8403: CALL_OW 72
8407: NOT
8408: IFFALSE 8385
// if rand ( 0 , 1 ) then
8410: LD_INT 0
8412: PPUSH
8413: LD_INT 1
8415: PPUSH
8416: CALL_OW 12
8420: IFFALSE 8439
// ComAgressiveMove ( attackers , 155 , 108 ) else
8422: LD_VAR 0 4
8426: PPUSH
8427: LD_INT 155
8429: PPUSH
8430: LD_INT 108
8432: PPUSH
8433: CALL_OW 114
8437: GO 8454
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8439: LD_VAR 0 4
8443: PPUSH
8444: LD_INT 149
8446: PPUSH
8447: LD_INT 55
8449: PPUSH
8450: CALL_OW 114
// wait ( 0 0$10 ) ;
8454: LD_INT 350
8456: PPUSH
8457: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8461: LD_INT 35
8463: PPUSH
8464: CALL_OW 67
// for i in attackers do
8468: LD_ADDR_VAR 0 1
8472: PUSH
8473: LD_VAR 0 4
8477: PUSH
8478: FOR_IN
8479: IFFALSE 8529
// if not HasTask ( i ) then
8481: LD_VAR 0 1
8485: PPUSH
8486: CALL_OW 314
8490: NOT
8491: IFFALSE 8527
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8493: LD_VAR 0 1
8497: PPUSH
8498: LD_INT 81
8500: PUSH
8501: LD_INT 3
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PPUSH
8508: CALL_OW 69
8512: PPUSH
8513: LD_VAR 0 1
8517: PPUSH
8518: CALL_OW 74
8522: PPUSH
8523: CALL_OW 115
8527: GO 8478
8529: POP
8530: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8531: LD_VAR 0 4
8535: PPUSH
8536: LD_INT 50
8538: PUSH
8539: EMPTY
8540: LIST
8541: PPUSH
8542: CALL_OW 72
8546: NOT
8547: IFFALSE 8461
// end ;
8549: PPOPN 5
8551: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8552: LD_EXP 5
8556: NOT
8557: IFFALSE 9144
8559: GO 8561
8561: DISABLE
8562: LD_INT 0
8564: PPUSH
8565: PPUSH
8566: PPUSH
8567: PPUSH
// begin enable ;
8568: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8569: LD_OWVAR 67
8573: PUSH
8574: LD_INT 1
8576: EQUAL
8577: PUSH
8578: LD_OWVAR 1
8582: PUSH
8583: LD_INT 63000
8585: LESS
8586: AND
8587: IFFALSE 8591
// exit ;
8589: GO 9144
// tmp := [ ] ;
8591: LD_ADDR_VAR 0 3
8595: PUSH
8596: EMPTY
8597: ST_TO_ADDR
// if tick < 45 45$00 then
8598: LD_OWVAR 1
8602: PUSH
8603: LD_INT 94500
8605: LESS
8606: IFFALSE 8783
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8608: LD_ADDR_VAR 0 1
8612: PUSH
8613: DOUBLE
8614: LD_INT 1
8616: DEC
8617: ST_TO_ADDR
8618: LD_INT 2
8620: PUSH
8621: LD_INT 3
8623: PUSH
8624: LD_INT 4
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: LIST
8631: PUSH
8632: LD_OWVAR 67
8636: ARRAY
8637: PUSH
8638: FOR_TO
8639: IFFALSE 8781
// begin uc_side := 3 ;
8641: LD_ADDR_OWVAR 20
8645: PUSH
8646: LD_INT 3
8648: ST_TO_ADDR
// uc_nation := 3 ;
8649: LD_ADDR_OWVAR 21
8653: PUSH
8654: LD_INT 3
8656: ST_TO_ADDR
// InitHC_All ( ) ;
8657: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8661: LD_INT 0
8663: PPUSH
8664: LD_INT 1
8666: PPUSH
8667: LD_INT 5
8669: PUSH
8670: LD_INT 6
8672: PUSH
8673: LD_INT 7
8675: PUSH
8676: EMPTY
8677: LIST
8678: LIST
8679: LIST
8680: PUSH
8681: LD_OWVAR 67
8685: ARRAY
8686: PPUSH
8687: CALL_OW 380
// un := CreateHuman ;
8691: LD_ADDR_VAR 0 2
8695: PUSH
8696: CALL_OW 44
8700: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8701: LD_VAR 0 2
8705: PPUSH
8706: LD_INT 18
8708: PPUSH
8709: LD_INT 0
8711: PPUSH
8712: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8716: LD_VAR 0 2
8720: PPUSH
8721: LD_INT 9
8723: PPUSH
8724: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8728: LD_VAR 0 2
8732: PPUSH
8733: LD_INT 147
8735: PPUSH
8736: LD_INT 161
8738: PPUSH
8739: CALL_OW 111
// wait ( 0 0$2 ) ;
8743: LD_INT 70
8745: PPUSH
8746: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8750: LD_ADDR_VAR 0 3
8754: PUSH
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_VAR 0 3
8764: PUSH
8765: LD_INT 1
8767: PLUS
8768: PPUSH
8769: LD_VAR 0 2
8773: PPUSH
8774: CALL_OW 1
8778: ST_TO_ADDR
// end ;
8779: GO 8638
8781: POP
8782: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8783: LD_ADDR_VAR 0 4
8787: PUSH
8788: LD_INT 3
8790: PUSH
8791: LD_INT 4
8793: PUSH
8794: LD_INT 5
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: LIST
8801: PUSH
8802: LD_OWVAR 67
8806: ARRAY
8807: PUSH
8808: LD_OWVAR 1
8812: PUSH
8813: LD_INT 21000
8815: DIV
8816: PLUS
8817: ST_TO_ADDR
// if amount > 15 then
8818: LD_VAR 0 4
8822: PUSH
8823: LD_INT 15
8825: GREATER
8826: IFFALSE 8836
// amount := 15 ;
8828: LD_ADDR_VAR 0 4
8832: PUSH
8833: LD_INT 15
8835: ST_TO_ADDR
// for i := 1 to amount do
8836: LD_ADDR_VAR 0 1
8840: PUSH
8841: DOUBLE
8842: LD_INT 1
8844: DEC
8845: ST_TO_ADDR
8846: LD_VAR 0 4
8850: PUSH
8851: FOR_TO
8852: IFFALSE 8998
// begin uc_side := 3 ;
8854: LD_ADDR_OWVAR 20
8858: PUSH
8859: LD_INT 3
8861: ST_TO_ADDR
// uc_nation := 3 ;
8862: LD_ADDR_OWVAR 21
8866: PUSH
8867: LD_INT 3
8869: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8870: LD_INT 24
8872: PPUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 3
8878: PPUSH
8879: LD_INT 46
8881: PUSH
8882: LD_INT 45
8884: PUSH
8885: LD_INT 44
8887: PUSH
8888: LD_INT 43
8890: PUSH
8891: LD_INT 42
8893: PUSH
8894: EMPTY
8895: LIST
8896: LIST
8897: LIST
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 5
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 90
8915: PPUSH
8916: CALL 16130 0 5
// un := CreateVehicle ;
8920: LD_ADDR_VAR 0 2
8924: PUSH
8925: CALL_OW 45
8929: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8930: LD_VAR 0 2
8934: PPUSH
8935: LD_INT 18
8937: PPUSH
8938: LD_INT 0
8940: PPUSH
8941: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8945: LD_VAR 0 2
8949: PPUSH
8950: LD_INT 147
8952: PPUSH
8953: LD_INT 161
8955: PPUSH
8956: CALL_OW 111
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8967: LD_ADDR_VAR 0 3
8971: PUSH
8972: LD_VAR 0 3
8976: PPUSH
8977: LD_VAR 0 3
8981: PUSH
8982: LD_INT 1
8984: PLUS
8985: PPUSH
8986: LD_VAR 0 2
8990: PPUSH
8991: CALL_OW 1
8995: ST_TO_ADDR
// end ;
8996: GO 8851
8998: POP
8999: POP
// if not tmp then
9000: LD_VAR 0 3
9004: NOT
9005: IFFALSE 9009
// exit ;
9007: GO 9144
// wait ( 0 0$5 ) ;
9009: LD_INT 175
9011: PPUSH
9012: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9016: LD_INT 70
9018: PPUSH
9019: CALL_OW 67
// for i in tmp do
9023: LD_ADDR_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: PUSH
9033: FOR_IN
9034: IFFALSE 9135
// begin if not IsOk ( i ) or IsDead ( i ) then
9036: LD_VAR 0 1
9040: PPUSH
9041: CALL_OW 302
9045: NOT
9046: PUSH
9047: LD_VAR 0 1
9051: PPUSH
9052: CALL_OW 301
9056: OR
9057: IFFALSE 9075
// tmp := tmp diff i ;
9059: LD_ADDR_VAR 0 3
9063: PUSH
9064: LD_VAR 0 3
9068: PUSH
9069: LD_VAR 0 1
9073: DIFF
9074: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9075: LD_VAR 0 1
9079: PPUSH
9080: CALL_OW 257
9084: PUSH
9085: LD_INT 9
9087: EQUAL
9088: IFFALSE 9099
// ComSpaceTimeShoot ( i ) ;
9090: LD_VAR 0 1
9094: PPUSH
9095: CALL 12062 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9099: LD_VAR 0 1
9103: PPUSH
9104: LD_INT 81
9106: PUSH
9107: LD_INT 3
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: PPUSH
9114: CALL_OW 69
9118: PPUSH
9119: LD_VAR 0 1
9123: PPUSH
9124: CALL_OW 74
9128: PPUSH
9129: CALL_OW 115
// end ;
9133: GO 9033
9135: POP
9136: POP
// until not tmp ;
9137: LD_VAR 0 3
9141: NOT
9142: IFFALSE 9016
// end ; end_of_file
9144: PPOPN 4
9146: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9147: LD_INT 0
9149: PPUSH
9150: PPUSH
9151: PPUSH
9152: PPUSH
// uc_side := 1 ;
9153: LD_ADDR_OWVAR 20
9157: PUSH
9158: LD_INT 1
9160: ST_TO_ADDR
// uc_nation := 1 ;
9161: LD_ADDR_OWVAR 21
9165: PUSH
9166: LD_INT 1
9168: ST_TO_ADDR
// hc_importance := 100 ;
9169: LD_ADDR_OWVAR 32
9173: PUSH
9174: LD_INT 100
9176: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9177: LD_ADDR_OWVAR 26
9181: PUSH
9182: LD_STRING Jeremy Sikorski
9184: ST_TO_ADDR
// hc_gallery := us ;
9185: LD_ADDR_OWVAR 33
9189: PUSH
9190: LD_STRING us
9192: ST_TO_ADDR
// hc_face_number := 19 ;
9193: LD_ADDR_OWVAR 34
9197: PUSH
9198: LD_INT 19
9200: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9201: LD_INT 1
9203: PPUSH
9204: LD_INT 1
9206: PPUSH
9207: LD_INT 4
9209: PUSH
9210: LD_INT 4
9212: PUSH
9213: LD_INT 3
9215: PUSH
9216: EMPTY
9217: LIST
9218: LIST
9219: LIST
9220: PUSH
9221: LD_OWVAR 67
9225: ARRAY
9226: PPUSH
9227: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9231: LD_ADDR_OWVAR 29
9235: PUSH
9236: LD_INT 10
9238: PUSH
9239: LD_INT 12
9241: PUSH
9242: EMPTY
9243: LIST
9244: LIST
9245: ST_TO_ADDR
// Sikorski := CreateHuman ;
9246: LD_ADDR_EXP 20
9250: PUSH
9251: CALL_OW 44
9255: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9256: LD_EXP 20
9260: PPUSH
9261: LD_INT 133
9263: PPUSH
9264: LD_INT 19
9266: PPUSH
9267: LD_INT 2
9269: PPUSH
9270: LD_INT 0
9272: PPUSH
9273: CALL_OW 50
// InitHc_All ( ) ;
9277: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9281: LD_ADDR_VAR 0 2
9285: PUSH
9286: DOUBLE
9287: LD_INT 1
9289: DEC
9290: ST_TO_ADDR
9291: LD_INT 4
9293: PUSH
9294: LD_INT 3
9296: PUSH
9297: LD_INT 3
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: LIST
9304: PUSH
9305: LD_OWVAR 67
9309: ARRAY
9310: PUSH
9311: FOR_TO
9312: IFFALSE 9428
// for j := 1 to 4 do
9314: LD_ADDR_VAR 0 3
9318: PUSH
9319: DOUBLE
9320: LD_INT 1
9322: DEC
9323: ST_TO_ADDR
9324: LD_INT 4
9326: PUSH
9327: FOR_TO
9328: IFFALSE 9424
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9330: LD_INT 0
9332: PPUSH
9333: LD_VAR 0 3
9337: PPUSH
9338: LD_INT 5
9340: PUSH
9341: LD_INT 4
9343: PUSH
9344: LD_INT 3
9346: PUSH
9347: EMPTY
9348: LIST
9349: LIST
9350: LIST
9351: PUSH
9352: LD_OWVAR 67
9356: ARRAY
9357: PPUSH
9358: CALL_OW 380
// un := CreateHuman ;
9362: LD_ADDR_VAR 0 4
9366: PUSH
9367: CALL_OW 44
9371: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9372: LD_VAR 0 4
9376: PPUSH
9377: LD_INT 0
9379: PPUSH
9380: LD_INT 5
9382: PPUSH
9383: CALL_OW 12
9387: PPUSH
9388: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 133
9399: PPUSH
9400: LD_INT 19
9402: PPUSH
9403: LD_INT 6
9405: PPUSH
9406: LD_INT 0
9408: PPUSH
9409: CALL_OW 50
// ComHold ( un ) ;
9413: LD_VAR 0 4
9417: PPUSH
9418: CALL_OW 140
// end ;
9422: GO 9327
9424: POP
9425: POP
9426: GO 9311
9428: POP
9429: POP
// vc_chassis := us_heavy_tracked ;
9430: LD_ADDR_OWVAR 37
9434: PUSH
9435: LD_INT 4
9437: ST_TO_ADDR
// vc_engine := engine_combustion ;
9438: LD_ADDR_OWVAR 39
9442: PUSH
9443: LD_INT 1
9445: ST_TO_ADDR
// vc_control := control_manual ;
9446: LD_ADDR_OWVAR 38
9450: PUSH
9451: LD_INT 1
9453: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9454: LD_ADDR_OWVAR 40
9458: PUSH
9459: LD_INT 14
9461: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9462: LD_ADDR_OWVAR 41
9466: PUSH
9467: LD_INT 60
9469: ST_TO_ADDR
// un := CreateVehicle ;
9470: LD_ADDR_VAR 0 4
9474: PUSH
9475: CALL_OW 45
9479: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9480: LD_VAR 0 4
9484: PPUSH
9485: LD_INT 2
9487: PPUSH
9488: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9492: LD_VAR 0 4
9496: PPUSH
9497: LD_INT 128
9499: PPUSH
9500: LD_INT 12
9502: PPUSH
9503: LD_INT 0
9505: PPUSH
9506: CALL_OW 48
// for i := 1 to 3 do
9510: LD_ADDR_VAR 0 2
9514: PUSH
9515: DOUBLE
9516: LD_INT 1
9518: DEC
9519: ST_TO_ADDR
9520: LD_INT 3
9522: PUSH
9523: FOR_TO
9524: IFFALSE 9547
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9526: LD_INT 5
9528: PPUSH
9529: LD_INT 133
9531: PPUSH
9532: LD_INT 19
9534: PPUSH
9535: LD_INT 3
9537: PPUSH
9538: LD_INT 0
9540: PPUSH
9541: CALL_OW 56
9545: GO 9523
9547: POP
9548: POP
// end ; end_of_file
9549: LD_VAR 0 1
9553: RET
// export function Action ; begin
9554: LD_INT 0
9556: PPUSH
// InGameOn ;
9557: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9561: LD_INT 133
9563: PPUSH
9564: LD_INT 19
9566: PPUSH
9567: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9571: LD_EXP 20
9575: PPUSH
9576: LD_STRING WT-DS-1
9578: PPUSH
9579: CALL_OW 88
// InGameOff ;
9583: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9587: LD_STRING DestroyEnemy
9589: PPUSH
9590: CALL_OW 337
// wait ( 0 0$20 ) ;
9594: LD_INT 700
9596: PPUSH
9597: CALL_OW 67
// DialogueOn ;
9601: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9605: LD_INT 100
9607: PPUSH
9608: LD_INT 37
9610: PPUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 30
9616: NEG
9617: PPUSH
9618: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9622: LD_INT 100
9624: PPUSH
9625: LD_INT 37
9627: PPUSH
9628: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9632: LD_EXP 10
9636: PPUSH
9637: LD_STRING WT-PL-1
9639: PPUSH
9640: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9644: LD_EXP 20
9648: PPUSH
9649: LD_STRING WT-DS-2
9651: PPUSH
9652: CALL_OW 88
// DialogueOff ;
9656: CALL_OW 7
// wait ( 0 0$2 ) ;
9660: LD_INT 70
9662: PPUSH
9663: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9667: LD_INT 100
9669: PPUSH
9670: LD_INT 37
9672: PPUSH
9673: LD_INT 1
9675: PPUSH
9676: CALL_OW 331
// end ;
9680: LD_VAR 0 1
9684: RET
// export function DialogPowellsAttack ; begin
9685: LD_INT 0
9687: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9688: LD_EXP 10
9692: PPUSH
9693: LD_STRING WT-PL-8
9695: PPUSH
9696: CALL_OW 94
// end ;
9700: LD_VAR 0 1
9704: RET
// export function DialogContaminateSib ( x , y ) ; begin
9705: LD_INT 0
9707: PPUSH
// DialogueOn ;
9708: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9712: LD_VAR 0 1
9716: PPUSH
9717: LD_VAR 0 2
9721: PPUSH
9722: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9726: LD_EXP 20
9730: PPUSH
9731: LD_STRING WT-DS-3
9733: PPUSH
9734: CALL_OW 88
// DialogueOff ;
9738: CALL_OW 7
// end ;
9742: LD_VAR 0 3
9746: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9747: LD_EXP 8
9751: NOT
9752: PUSH
9753: LD_INT 1
9755: PPUSH
9756: LD_INT 81
9758: PUSH
9759: LD_INT 4
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: PPUSH
9766: CALL_OW 70
9770: PUSH
9771: LD_INT 3
9773: GREATER
9774: AND
9775: IFFALSE 9847
9777: GO 9779
9779: DISABLE
// begin powellInTrouble := true ;
9780: LD_ADDR_EXP 8
9784: PUSH
9785: LD_INT 1
9787: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9788: LD_EXP 20
9792: PPUSH
9793: LD_STRING WT-DS-6
9795: PPUSH
9796: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9800: LD_INT 1
9802: PPUSH
9803: LD_INT 22
9805: PUSH
9806: LD_INT 1
9808: PUSH
9809: EMPTY
9810: LIST
9811: LIST
9812: PPUSH
9813: CALL_OW 70
9817: NOT
9818: IFFALSE 9832
// SayRadio ( Powell , WT-PL-6 ) ;
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-6
9827: PPUSH
9828: CALL_OW 94
// wait ( 1 1$30 ) ;
9832: LD_INT 3150
9834: PPUSH
9835: CALL_OW 67
// powellInTrouble := false ;
9839: LD_ADDR_EXP 8
9843: PUSH
9844: LD_INT 0
9846: ST_TO_ADDR
// end ;
9847: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9848: LD_EXP 9
9852: NOT
9853: PUSH
9854: LD_INT 16
9856: PPUSH
9857: LD_INT 81
9859: PUSH
9860: LD_INT 1
9862: PUSH
9863: EMPTY
9864: LIST
9865: LIST
9866: PPUSH
9867: CALL_OW 70
9871: PUSH
9872: LD_INT 6
9874: GREATER
9875: AND
9876: IFFALSE 9949
9878: GO 9880
9880: DISABLE
// begin sikorskiInTrouble := true ;
9881: LD_ADDR_EXP 9
9885: PUSH
9886: LD_INT 1
9888: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9889: LD_EXP 20
9893: PPUSH
9894: LD_STRING WT-DS-7
9896: PPUSH
9897: CALL_OW 88
// if not powellAttackGroup then
9901: LD_EXP 12
9905: NOT
9906: IFFALSE 9922
// SayRadio ( Powell , WT-PL-7n ) else
9908: LD_EXP 10
9912: PPUSH
9913: LD_STRING WT-PL-7n
9915: PPUSH
9916: CALL_OW 94
9920: GO 9934
// SayRadio ( Powell , WT-PL-7y ) ;
9922: LD_EXP 10
9926: PPUSH
9927: LD_STRING WT-PL-7y
9929: PPUSH
9930: CALL_OW 94
// wait ( 1 1$30 ) ;
9934: LD_INT 3150
9936: PPUSH
9937: CALL_OW 67
// sikorskiInTrouble := false ;
9941: LD_ADDR_EXP 9
9945: PUSH
9946: LD_INT 0
9948: ST_TO_ADDR
// end ;
9949: END
// export function DialogPowellsAttackFailed ; begin
9950: LD_INT 0
9952: PPUSH
// if not ruDestroyed then
9953: LD_EXP 5
9957: NOT
9958: IFFALSE 9974
// SayRadio ( Powell , WT-PL-9 ) else
9960: LD_EXP 10
9964: PPUSH
9965: LD_STRING WT-PL-9
9967: PPUSH
9968: CALL_OW 94
9972: GO 9986
// SayRadio ( Powell , WT-PL-10 ) ;
9974: LD_EXP 10
9978: PPUSH
9979: LD_STRING WT-PL-10
9981: PPUSH
9982: CALL_OW 94
// end ;
9986: LD_VAR 0 1
9990: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9991: LD_INT 22
9993: PUSH
9994: LD_INT 2
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: LD_INT 21
10003: PUSH
10004: LD_INT 1
10006: PUSH
10007: EMPTY
10008: LIST
10009: LIST
10010: PUSH
10011: EMPTY
10012: LIST
10013: LIST
10014: PPUSH
10015: CALL_OW 69
10019: PUSH
10020: LD_INT 0
10022: EQUAL
10023: IFFALSE 10067
10025: GO 10027
10027: DISABLE
// begin arDestroyed := true ;
10028: LD_ADDR_EXP 4
10032: PUSH
10033: LD_INT 1
10035: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10036: LD_INT 2
10038: PPUSH
10039: CALL 52793 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10043: LD_EXP 20
10047: PPUSH
10048: LD_STRING WT-DS-4
10050: PPUSH
10051: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10055: LD_EXP 10
10059: PPUSH
10060: LD_STRING WT-PL-4
10062: PPUSH
10063: CALL_OW 94
// end ;
10067: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10068: LD_INT 22
10070: PUSH
10071: LD_INT 3
10073: PUSH
10074: EMPTY
10075: LIST
10076: LIST
10077: PUSH
10078: LD_INT 21
10080: PUSH
10081: LD_INT 1
10083: PUSH
10084: EMPTY
10085: LIST
10086: LIST
10087: PUSH
10088: EMPTY
10089: LIST
10090: LIST
10091: PPUSH
10092: CALL_OW 69
10096: PUSH
10097: LD_INT 0
10099: EQUAL
10100: IFFALSE 10144
10102: GO 10104
10104: DISABLE
// begin ruDestroyed := true ;
10105: LD_ADDR_EXP 5
10109: PUSH
10110: LD_INT 1
10112: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10113: LD_INT 3
10115: PPUSH
10116: CALL 52793 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10120: LD_EXP 20
10124: PPUSH
10125: LD_STRING WT-DS-5
10127: PPUSH
10128: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10132: LD_EXP 10
10136: PPUSH
10137: LD_STRING WT-PL-5
10139: PPUSH
10140: CALL_OW 94
// end ;
10144: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10145: LD_EXP 5
10149: PUSH
10150: LD_EXP 4
10154: AND
10155: IFFALSE 10328
10157: GO 10159
10159: DISABLE
// begin wait ( 0 0$3 ) ;
10160: LD_INT 105
10162: PPUSH
10163: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10167: LD_OWVAR 1
10171: PUSH
10172: LD_INT 126000
10174: PUSH
10175: LD_INT 105000
10177: PUSH
10178: LD_INT 94500
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PUSH
10186: LD_OWVAR 67
10190: ARRAY
10191: GREATEREQUAL
10192: IFFALSE 10207
// AddMedal ( WoT-med-1 , - 1 ) else
10194: LD_STRING WoT-med-1
10196: PPUSH
10197: LD_INT 1
10199: NEG
10200: PPUSH
10201: CALL_OW 101
10205: GO 10217
// AddMedal ( WoT-med-1 , 1 ) ;
10207: LD_STRING WoT-med-1
10209: PPUSH
10210: LD_INT 1
10212: PPUSH
10213: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10217: LD_EXP 6
10221: PUSH
10222: LD_INT 4
10224: PUSH
10225: LD_INT 3
10227: PUSH
10228: LD_INT 2
10230: PUSH
10231: EMPTY
10232: LIST
10233: LIST
10234: LIST
10235: PUSH
10236: LD_OWVAR 67
10240: ARRAY
10241: GREATEREQUAL
10242: IFFALSE 10257
// AddMedal ( WoT-med-2 , - 1 ) else
10244: LD_STRING WoT-med-2
10246: PPUSH
10247: LD_INT 1
10249: NEG
10250: PPUSH
10251: CALL_OW 101
10255: GO 10267
// AddMedal ( WoT-med-2 , 1 ) ;
10257: LD_STRING WoT-med-2
10259: PPUSH
10260: LD_INT 1
10262: PPUSH
10263: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10267: LD_EXP 7
10271: PUSH
10272: LD_INT 8
10274: PUSH
10275: LD_INT 6
10277: PUSH
10278: LD_INT 5
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: PUSH
10286: LD_OWVAR 67
10290: ARRAY
10291: GREATEREQUAL
10292: IFFALSE 10307
// AddMedal ( WoT-med-3 , - 1 ) else
10294: LD_STRING WoT-med-3
10296: PPUSH
10297: LD_INT 1
10299: NEG
10300: PPUSH
10301: CALL_OW 101
10305: GO 10317
// AddMedal ( WoT-med-3 , 1 ) ;
10307: LD_STRING WoT-med-3
10309: PPUSH
10310: LD_INT 1
10312: PPUSH
10313: CALL_OW 101
// GiveMedals ( MAIN ) ;
10317: LD_STRING MAIN
10319: PPUSH
10320: CALL_OW 102
// YouWin ;
10324: CALL_OW 103
// end ; end_of_file
10328: END
// export function CustomEvent ( event ) ; begin
10329: LD_INT 0
10331: PPUSH
// end ;
10332: LD_VAR 0 2
10336: RET
// on Command ( com ) do var i , j , temp ;
10337: LD_INT 0
10339: PPUSH
10340: PPUSH
10341: PPUSH
// begin if com = 60 then
10342: LD_VAR 0 1
10346: PUSH
10347: LD_INT 60
10349: EQUAL
10350: IFFALSE 10529
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10352: LD_ADDR_VAR 0 2
10356: PUSH
10357: LD_INT 22
10359: PUSH
10360: LD_INT 1
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: PUSH
10367: LD_INT 2
10369: PUSH
10370: LD_INT 21
10372: PUSH
10373: LD_INT 1
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 34
10382: PUSH
10383: LD_INT 12
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: EMPTY
10391: LIST
10392: LIST
10393: LIST
10394: PUSH
10395: EMPTY
10396: LIST
10397: LIST
10398: PPUSH
10399: CALL_OW 69
10403: PUSH
10404: FOR_IN
10405: IFFALSE 10527
// begin if GetTaskList ( i ) > 0 then
10407: LD_VAR 0 2
10411: PPUSH
10412: CALL_OW 437
10416: PUSH
10417: LD_INT 0
10419: GREATER
10420: IFFALSE 10525
// for j = 1 to GetTaskList ( i ) do
10422: LD_ADDR_VAR 0 3
10426: PUSH
10427: DOUBLE
10428: LD_INT 1
10430: DEC
10431: ST_TO_ADDR
10432: LD_VAR 0 2
10436: PPUSH
10437: CALL_OW 437
10441: PUSH
10442: FOR_TO
10443: IFFALSE 10523
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10445: LD_ADDR_VAR 0 4
10449: PUSH
10450: LD_VAR 0 2
10454: PPUSH
10455: CALL_OW 437
10459: PUSH
10460: LD_VAR 0 3
10464: ARRAY
10465: PUSH
10466: LD_INT 4
10468: ARRAY
10469: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10470: LD_VAR 0 4
10474: PPUSH
10475: CALL_OW 255
10479: PUSH
10480: LD_INT 4
10482: EQUAL
10483: PUSH
10484: LD_VAR 0 2
10488: PPUSH
10489: CALL_OW 437
10493: PUSH
10494: LD_VAR 0 3
10498: ARRAY
10499: PUSH
10500: LD_INT 1
10502: ARRAY
10503: PUSH
10504: LD_STRING <
10506: EQUAL
10507: AND
10508: IFFALSE 10521
// SetTaskList ( i , [ ] ) ;
10510: LD_VAR 0 2
10514: PPUSH
10515: EMPTY
10516: PPUSH
10517: CALL_OW 446
// end ;
10521: GO 10442
10523: POP
10524: POP
// end ;
10525: GO 10404
10527: POP
10528: POP
// end ; end ;
10529: PPOPN 4
10531: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10532: LD_VAR 0 2
10536: PPUSH
10537: LD_VAR 0 3
10541: PPUSH
10542: CALL_OW 428
10546: PPUSH
10547: CALL_OW 255
10551: PUSH
10552: LD_INT 1
10554: EQUAL
10555: PUSH
10556: LD_VAR 0 2
10560: PUSH
10561: LD_INT 132
10563: EQUAL
10564: PUSH
10565: LD_VAR 0 3
10569: PUSH
10570: LD_INT 39
10572: EQUAL
10573: AND
10574: OR
10575: IFFALSE 10591
// DialogContaminateSib ( x , y ) ;
10577: LD_VAR 0 2
10581: PPUSH
10582: LD_VAR 0 3
10586: PPUSH
10587: CALL 9705 0 2
// end ;
10591: PPOPN 3
10593: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10594: LD_VAR 0 1
10598: PPUSH
10599: CALL 90547 0 1
// MCE_UnitDestroyed ( un ) ;
10603: LD_VAR 0 1
10607: PPUSH
10608: CALL 80262 0 1
// if un = Powell then
10612: LD_VAR 0 1
10616: PUSH
10617: LD_EXP 10
10621: EQUAL
10622: IFFALSE 10631
// YouLost ( Powell ) ;
10624: LD_STRING Powell
10626: PPUSH
10627: CALL_OW 104
// if un = Sikorski then
10631: LD_VAR 0 1
10635: PUSH
10636: LD_EXP 20
10640: EQUAL
10641: IFFALSE 10650
// YouLost ( Sikorski ) ;
10643: LD_STRING Sikorski
10645: PPUSH
10646: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10650: LD_VAR 0 1
10654: PUSH
10655: LD_INT 22
10657: PUSH
10658: LD_INT 1
10660: PUSH
10661: EMPTY
10662: LIST
10663: LIST
10664: PUSH
10665: LD_INT 21
10667: PUSH
10668: LD_INT 1
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PUSH
10675: EMPTY
10676: LIST
10677: LIST
10678: PPUSH
10679: CALL_OW 69
10683: IN
10684: IFFALSE 10700
// loseCounter := loseCounter + 1 ;
10686: LD_ADDR_EXP 6
10690: PUSH
10691: LD_EXP 6
10695: PUSH
10696: LD_INT 1
10698: PLUS
10699: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10700: LD_VAR 0 1
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 4
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 21
10717: PUSH
10718: LD_INT 1
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: PPUSH
10729: CALL_OW 69
10733: IN
10734: IFFALSE 10750
// powellLoseCounter := powellLoseCounter + 1 ;
10736: LD_ADDR_EXP 7
10740: PUSH
10741: LD_EXP 7
10745: PUSH
10746: LD_INT 1
10748: PLUS
10749: ST_TO_ADDR
// if un in powellAttackGroup then
10750: LD_VAR 0 1
10754: PUSH
10755: LD_EXP 12
10759: IN
10760: IFFALSE 10778
// powellAttackGroup := powellAttackGroup diff un ;
10762: LD_ADDR_EXP 12
10766: PUSH
10767: LD_EXP 12
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// if un in gensherAttackGroup then
10778: LD_VAR 0 1
10782: PUSH
10783: LD_EXP 15
10787: IN
10788: IFFALSE 10806
// gensherAttackGroup := gensherAttackGroup diff un ;
10790: LD_ADDR_EXP 15
10794: PUSH
10795: LD_EXP 15
10799: PUSH
10800: LD_VAR 0 1
10804: DIFF
10805: ST_TO_ADDR
// if un in popovAttackGroup then
10806: LD_VAR 0 1
10810: PUSH
10811: LD_EXP 19
10815: IN
10816: IFFALSE 10834
// popovAttackGroup := popovAttackGroup diff un ;
10818: LD_ADDR_EXP 19
10822: PUSH
10823: LD_EXP 19
10827: PUSH
10828: LD_VAR 0 1
10832: DIFF
10833: ST_TO_ADDR
// end ;
10834: PPOPN 1
10836: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10837: LD_VAR 0 1
10841: PPUSH
10842: LD_VAR 0 2
10846: PPUSH
10847: CALL 82594 0 2
// end ;
10851: PPOPN 2
10853: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10854: LD_VAR 0 1
10858: PPUSH
10859: CALL 81662 0 1
// end ;
10863: PPOPN 1
10865: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10866: LD_VAR 0 1
10870: PPUSH
10871: CALL 81903 0 1
// end ;
10875: PPOPN 1
10877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_VAR 0 2
10887: PPUSH
10888: CALL 79958 0 2
// end ;
10892: PPOPN 2
10894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10895: LD_VAR 0 1
10899: PPUSH
10900: LD_VAR 0 2
10904: PPUSH
10905: LD_VAR 0 3
10909: PPUSH
10910: LD_VAR 0 4
10914: PPUSH
10915: LD_VAR 0 5
10919: PPUSH
10920: CALL 79578 0 5
// end ;
10924: PPOPN 5
10926: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10927: LD_VAR 0 1
10931: PPUSH
10932: LD_VAR 0 2
10936: PPUSH
10937: CALL 90667 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10941: LD_VAR 0 1
10945: PPUSH
10946: LD_VAR 0 2
10950: PPUSH
10951: CALL 79131 0 2
// end ;
10955: PPOPN 2
10957: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10958: LD_VAR 0 1
10962: PPUSH
10963: LD_VAR 0 2
10967: PPUSH
10968: LD_VAR 0 3
10972: PPUSH
10973: LD_VAR 0 4
10977: PPUSH
10978: CALL 78969 0 4
// end ;
10982: PPOPN 4
10984: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10985: LD_VAR 0 1
10989: PPUSH
10990: LD_VAR 0 2
10994: PPUSH
10995: LD_VAR 0 3
10999: PPUSH
11000: CALL 78744 0 3
// end ;
11004: PPOPN 3
11006: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11007: LD_VAR 0 1
11011: PPUSH
11012: LD_VAR 0 2
11016: PPUSH
11017: CALL 78629 0 2
// end ;
11021: PPOPN 2
11023: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11024: LD_VAR 0 1
11028: PPUSH
11029: LD_VAR 0 2
11033: PPUSH
11034: CALL 82889 0 2
// end ;
11038: PPOPN 2
11040: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11041: LD_VAR 0 1
11045: PPUSH
11046: LD_VAR 0 2
11050: PPUSH
11051: LD_VAR 0 3
11055: PPUSH
11056: LD_VAR 0 4
11060: PPUSH
11061: CALL 83105 0 4
// end ;
11065: PPOPN 4
11067: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11068: LD_VAR 0 1
11072: PPUSH
11073: LD_VAR 0 2
11077: PPUSH
11078: CALL 78438 0 2
// end ;
11082: PPOPN 2
11084: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11085: LD_VAR 0 1
11089: PUSH
11090: LD_INT 1
11092: EQUAL
11093: PUSH
11094: LD_VAR 0 2
11098: PUSH
11099: LD_INT 4
11101: EQUAL
11102: AND
11103: IFFALSE 11112
// YouLost ( FriendlyFire ) ;
11105: LD_STRING FriendlyFire
11107: PPUSH
11108: CALL_OW 104
// end ; end_of_file
11112: PPOPN 2
11114: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11115: LD_INT 0
11117: PPUSH
11118: PPUSH
// if exist_mode then
11119: LD_VAR 0 2
11123: IFFALSE 11148
// unit := CreateCharacter ( prefix & ident ) else
11125: LD_ADDR_VAR 0 5
11129: PUSH
11130: LD_VAR 0 3
11134: PUSH
11135: LD_VAR 0 1
11139: STR
11140: PPUSH
11141: CALL_OW 34
11145: ST_TO_ADDR
11146: GO 11163
// unit := NewCharacter ( ident ) ;
11148: LD_ADDR_VAR 0 5
11152: PUSH
11153: LD_VAR 0 1
11157: PPUSH
11158: CALL_OW 25
11162: ST_TO_ADDR
// result := unit ;
11163: LD_ADDR_VAR 0 4
11167: PUSH
11168: LD_VAR 0 5
11172: ST_TO_ADDR
// end ;
11173: LD_VAR 0 4
11177: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11178: LD_INT 0
11180: PPUSH
11181: PPUSH
// if not side or not nation then
11182: LD_VAR 0 1
11186: NOT
11187: PUSH
11188: LD_VAR 0 2
11192: NOT
11193: OR
11194: IFFALSE 11198
// exit ;
11196: GO 11966
// case nation of nation_american :
11198: LD_VAR 0 2
11202: PUSH
11203: LD_INT 1
11205: DOUBLE
11206: EQUAL
11207: IFTRUE 11211
11209: GO 11425
11211: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11212: LD_ADDR_VAR 0 4
11216: PUSH
11217: LD_INT 35
11219: PUSH
11220: LD_INT 45
11222: PUSH
11223: LD_INT 46
11225: PUSH
11226: LD_INT 47
11228: PUSH
11229: LD_INT 82
11231: PUSH
11232: LD_INT 83
11234: PUSH
11235: LD_INT 84
11237: PUSH
11238: LD_INT 85
11240: PUSH
11241: LD_INT 86
11243: PUSH
11244: LD_INT 1
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 6
11252: PUSH
11253: LD_INT 15
11255: PUSH
11256: LD_INT 16
11258: PUSH
11259: LD_INT 7
11261: PUSH
11262: LD_INT 12
11264: PUSH
11265: LD_INT 13
11267: PUSH
11268: LD_INT 10
11270: PUSH
11271: LD_INT 14
11273: PUSH
11274: LD_INT 20
11276: PUSH
11277: LD_INT 21
11279: PUSH
11280: LD_INT 22
11282: PUSH
11283: LD_INT 25
11285: PUSH
11286: LD_INT 32
11288: PUSH
11289: LD_INT 27
11291: PUSH
11292: LD_INT 36
11294: PUSH
11295: LD_INT 69
11297: PUSH
11298: LD_INT 39
11300: PUSH
11301: LD_INT 34
11303: PUSH
11304: LD_INT 40
11306: PUSH
11307: LD_INT 48
11309: PUSH
11310: LD_INT 49
11312: PUSH
11313: LD_INT 50
11315: PUSH
11316: LD_INT 51
11318: PUSH
11319: LD_INT 52
11321: PUSH
11322: LD_INT 53
11324: PUSH
11325: LD_INT 54
11327: PUSH
11328: LD_INT 55
11330: PUSH
11331: LD_INT 56
11333: PUSH
11334: LD_INT 57
11336: PUSH
11337: LD_INT 58
11339: PUSH
11340: LD_INT 59
11342: PUSH
11343: LD_INT 60
11345: PUSH
11346: LD_INT 61
11348: PUSH
11349: LD_INT 62
11351: PUSH
11352: LD_INT 80
11354: PUSH
11355: LD_INT 82
11357: PUSH
11358: LD_INT 83
11360: PUSH
11361: LD_INT 84
11363: PUSH
11364: LD_INT 85
11366: PUSH
11367: LD_INT 86
11369: PUSH
11370: EMPTY
11371: LIST
11372: LIST
11373: LIST
11374: LIST
11375: LIST
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: LIST
11410: LIST
11411: LIST
11412: LIST
11413: LIST
11414: LIST
11415: LIST
11416: LIST
11417: LIST
11418: LIST
11419: LIST
11420: LIST
11421: LIST
11422: ST_TO_ADDR
11423: GO 11890
11425: LD_INT 2
11427: DOUBLE
11428: EQUAL
11429: IFTRUE 11433
11431: GO 11659
11433: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11434: LD_ADDR_VAR 0 4
11438: PUSH
11439: LD_INT 35
11441: PUSH
11442: LD_INT 45
11444: PUSH
11445: LD_INT 46
11447: PUSH
11448: LD_INT 47
11450: PUSH
11451: LD_INT 82
11453: PUSH
11454: LD_INT 83
11456: PUSH
11457: LD_INT 84
11459: PUSH
11460: LD_INT 85
11462: PUSH
11463: LD_INT 87
11465: PUSH
11466: LD_INT 70
11468: PUSH
11469: LD_INT 1
11471: PUSH
11472: LD_INT 11
11474: PUSH
11475: LD_INT 3
11477: PUSH
11478: LD_INT 4
11480: PUSH
11481: LD_INT 5
11483: PUSH
11484: LD_INT 6
11486: PUSH
11487: LD_INT 15
11489: PUSH
11490: LD_INT 18
11492: PUSH
11493: LD_INT 7
11495: PUSH
11496: LD_INT 17
11498: PUSH
11499: LD_INT 8
11501: PUSH
11502: LD_INT 20
11504: PUSH
11505: LD_INT 21
11507: PUSH
11508: LD_INT 22
11510: PUSH
11511: LD_INT 72
11513: PUSH
11514: LD_INT 26
11516: PUSH
11517: LD_INT 69
11519: PUSH
11520: LD_INT 39
11522: PUSH
11523: LD_INT 40
11525: PUSH
11526: LD_INT 41
11528: PUSH
11529: LD_INT 42
11531: PUSH
11532: LD_INT 43
11534: PUSH
11535: LD_INT 48
11537: PUSH
11538: LD_INT 49
11540: PUSH
11541: LD_INT 50
11543: PUSH
11544: LD_INT 51
11546: PUSH
11547: LD_INT 52
11549: PUSH
11550: LD_INT 53
11552: PUSH
11553: LD_INT 54
11555: PUSH
11556: LD_INT 55
11558: PUSH
11559: LD_INT 56
11561: PUSH
11562: LD_INT 60
11564: PUSH
11565: LD_INT 61
11567: PUSH
11568: LD_INT 62
11570: PUSH
11571: LD_INT 66
11573: PUSH
11574: LD_INT 67
11576: PUSH
11577: LD_INT 68
11579: PUSH
11580: LD_INT 81
11582: PUSH
11583: LD_INT 82
11585: PUSH
11586: LD_INT 83
11588: PUSH
11589: LD_INT 84
11591: PUSH
11592: LD_INT 85
11594: PUSH
11595: LD_INT 87
11597: PUSH
11598: LD_INT 88
11600: PUSH
11601: EMPTY
11602: LIST
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: LIST
11612: LIST
11613: LIST
11614: LIST
11615: LIST
11616: LIST
11617: LIST
11618: LIST
11619: LIST
11620: LIST
11621: LIST
11622: LIST
11623: LIST
11624: LIST
11625: LIST
11626: LIST
11627: LIST
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: LIST
11637: LIST
11638: LIST
11639: LIST
11640: LIST
11641: LIST
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: LIST
11651: LIST
11652: LIST
11653: LIST
11654: LIST
11655: LIST
11656: ST_TO_ADDR
11657: GO 11890
11659: LD_INT 3
11661: DOUBLE
11662: EQUAL
11663: IFTRUE 11667
11665: GO 11889
11667: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11668: LD_ADDR_VAR 0 4
11672: PUSH
11673: LD_INT 46
11675: PUSH
11676: LD_INT 47
11678: PUSH
11679: LD_INT 1
11681: PUSH
11682: LD_INT 2
11684: PUSH
11685: LD_INT 82
11687: PUSH
11688: LD_INT 83
11690: PUSH
11691: LD_INT 84
11693: PUSH
11694: LD_INT 85
11696: PUSH
11697: LD_INT 86
11699: PUSH
11700: LD_INT 11
11702: PUSH
11703: LD_INT 9
11705: PUSH
11706: LD_INT 20
11708: PUSH
11709: LD_INT 19
11711: PUSH
11712: LD_INT 21
11714: PUSH
11715: LD_INT 24
11717: PUSH
11718: LD_INT 22
11720: PUSH
11721: LD_INT 25
11723: PUSH
11724: LD_INT 28
11726: PUSH
11727: LD_INT 29
11729: PUSH
11730: LD_INT 30
11732: PUSH
11733: LD_INT 31
11735: PUSH
11736: LD_INT 37
11738: PUSH
11739: LD_INT 38
11741: PUSH
11742: LD_INT 32
11744: PUSH
11745: LD_INT 27
11747: PUSH
11748: LD_INT 33
11750: PUSH
11751: LD_INT 69
11753: PUSH
11754: LD_INT 39
11756: PUSH
11757: LD_INT 34
11759: PUSH
11760: LD_INT 40
11762: PUSH
11763: LD_INT 71
11765: PUSH
11766: LD_INT 23
11768: PUSH
11769: LD_INT 44
11771: PUSH
11772: LD_INT 48
11774: PUSH
11775: LD_INT 49
11777: PUSH
11778: LD_INT 50
11780: PUSH
11781: LD_INT 51
11783: PUSH
11784: LD_INT 52
11786: PUSH
11787: LD_INT 53
11789: PUSH
11790: LD_INT 54
11792: PUSH
11793: LD_INT 55
11795: PUSH
11796: LD_INT 56
11798: PUSH
11799: LD_INT 57
11801: PUSH
11802: LD_INT 58
11804: PUSH
11805: LD_INT 59
11807: PUSH
11808: LD_INT 63
11810: PUSH
11811: LD_INT 64
11813: PUSH
11814: LD_INT 65
11816: PUSH
11817: LD_INT 82
11819: PUSH
11820: LD_INT 83
11822: PUSH
11823: LD_INT 84
11825: PUSH
11826: LD_INT 85
11828: PUSH
11829: LD_INT 86
11831: PUSH
11832: EMPTY
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: LIST
11860: LIST
11861: LIST
11862: LIST
11863: LIST
11864: LIST
11865: LIST
11866: LIST
11867: LIST
11868: LIST
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: ST_TO_ADDR
11887: GO 11890
11889: POP
// if state > - 1 and state < 3 then
11890: LD_VAR 0 3
11894: PUSH
11895: LD_INT 1
11897: NEG
11898: GREATER
11899: PUSH
11900: LD_VAR 0 3
11904: PUSH
11905: LD_INT 3
11907: LESS
11908: AND
11909: IFFALSE 11966
// for i in result do
11911: LD_ADDR_VAR 0 5
11915: PUSH
11916: LD_VAR 0 4
11920: PUSH
11921: FOR_IN
11922: IFFALSE 11964
// if GetTech ( i , side ) <> state then
11924: LD_VAR 0 5
11928: PPUSH
11929: LD_VAR 0 1
11933: PPUSH
11934: CALL_OW 321
11938: PUSH
11939: LD_VAR 0 3
11943: NONEQUAL
11944: IFFALSE 11962
// result := result diff i ;
11946: LD_ADDR_VAR 0 4
11950: PUSH
11951: LD_VAR 0 4
11955: PUSH
11956: LD_VAR 0 5
11960: DIFF
11961: ST_TO_ADDR
11962: GO 11921
11964: POP
11965: POP
// end ;
11966: LD_VAR 0 4
11970: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11971: LD_INT 0
11973: PPUSH
11974: PPUSH
11975: PPUSH
// result := true ;
11976: LD_ADDR_VAR 0 3
11980: PUSH
11981: LD_INT 1
11983: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11984: LD_ADDR_VAR 0 5
11988: PUSH
11989: LD_VAR 0 2
11993: PPUSH
11994: CALL_OW 480
11998: ST_TO_ADDR
// if not tmp then
11999: LD_VAR 0 5
12003: NOT
12004: IFFALSE 12008
// exit ;
12006: GO 12057
// for i in tmp do
12008: LD_ADDR_VAR 0 4
12012: PUSH
12013: LD_VAR 0 5
12017: PUSH
12018: FOR_IN
12019: IFFALSE 12055
// if GetTech ( i , side ) <> state_researched then
12021: LD_VAR 0 4
12025: PPUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 321
12035: PUSH
12036: LD_INT 2
12038: NONEQUAL
12039: IFFALSE 12053
// begin result := false ;
12041: LD_ADDR_VAR 0 3
12045: PUSH
12046: LD_INT 0
12048: ST_TO_ADDR
// exit ;
12049: POP
12050: POP
12051: GO 12057
// end ;
12053: GO 12018
12055: POP
12056: POP
// end ;
12057: LD_VAR 0 3
12061: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12062: LD_INT 0
12064: PPUSH
12065: PPUSH
12066: PPUSH
12067: PPUSH
12068: PPUSH
12069: PPUSH
12070: PPUSH
12071: PPUSH
12072: PPUSH
12073: PPUSH
12074: PPUSH
12075: PPUSH
12076: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12077: LD_VAR 0 1
12081: NOT
12082: PUSH
12083: LD_VAR 0 1
12087: PPUSH
12088: CALL_OW 257
12092: PUSH
12093: LD_INT 9
12095: NONEQUAL
12096: OR
12097: IFFALSE 12101
// exit ;
12099: GO 12674
// side := GetSide ( unit ) ;
12101: LD_ADDR_VAR 0 9
12105: PUSH
12106: LD_VAR 0 1
12110: PPUSH
12111: CALL_OW 255
12115: ST_TO_ADDR
// tech_space := tech_spacanom ;
12116: LD_ADDR_VAR 0 12
12120: PUSH
12121: LD_INT 29
12123: ST_TO_ADDR
// tech_time := tech_taurad ;
12124: LD_ADDR_VAR 0 13
12128: PUSH
12129: LD_INT 28
12131: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12132: LD_ADDR_VAR 0 11
12136: PUSH
12137: LD_VAR 0 1
12141: PPUSH
12142: CALL_OW 310
12146: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12147: LD_VAR 0 11
12151: PPUSH
12152: CALL_OW 247
12156: PUSH
12157: LD_INT 2
12159: EQUAL
12160: IFFALSE 12164
// exit ;
12162: GO 12674
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12164: LD_ADDR_VAR 0 8
12168: PUSH
12169: LD_INT 81
12171: PUSH
12172: LD_VAR 0 9
12176: PUSH
12177: EMPTY
12178: LIST
12179: LIST
12180: PUSH
12181: LD_INT 3
12183: PUSH
12184: LD_INT 21
12186: PUSH
12187: LD_INT 3
12189: PUSH
12190: EMPTY
12191: LIST
12192: LIST
12193: PUSH
12194: EMPTY
12195: LIST
12196: LIST
12197: PUSH
12198: EMPTY
12199: LIST
12200: LIST
12201: PPUSH
12202: CALL_OW 69
12206: ST_TO_ADDR
// if not tmp then
12207: LD_VAR 0 8
12211: NOT
12212: IFFALSE 12216
// exit ;
12214: GO 12674
// if in_unit then
12216: LD_VAR 0 11
12220: IFFALSE 12244
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12222: LD_ADDR_VAR 0 10
12226: PUSH
12227: LD_VAR 0 8
12231: PPUSH
12232: LD_VAR 0 11
12236: PPUSH
12237: CALL_OW 74
12241: ST_TO_ADDR
12242: GO 12264
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12244: LD_ADDR_VAR 0 10
12248: PUSH
12249: LD_VAR 0 8
12253: PPUSH
12254: LD_VAR 0 1
12258: PPUSH
12259: CALL_OW 74
12263: ST_TO_ADDR
// if not enemy then
12264: LD_VAR 0 10
12268: NOT
12269: IFFALSE 12273
// exit ;
12271: GO 12674
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12273: LD_VAR 0 11
12277: PUSH
12278: LD_VAR 0 11
12282: PPUSH
12283: LD_VAR 0 10
12287: PPUSH
12288: CALL_OW 296
12292: PUSH
12293: LD_INT 13
12295: GREATER
12296: AND
12297: PUSH
12298: LD_VAR 0 1
12302: PPUSH
12303: LD_VAR 0 10
12307: PPUSH
12308: CALL_OW 296
12312: PUSH
12313: LD_INT 12
12315: GREATER
12316: OR
12317: IFFALSE 12321
// exit ;
12319: GO 12674
// missile := [ 1 ] ;
12321: LD_ADDR_VAR 0 14
12325: PUSH
12326: LD_INT 1
12328: PUSH
12329: EMPTY
12330: LIST
12331: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12332: LD_VAR 0 9
12336: PPUSH
12337: LD_VAR 0 12
12341: PPUSH
12342: CALL_OW 325
12346: IFFALSE 12375
// missile := Replace ( missile , missile + 1 , 2 ) ;
12348: LD_ADDR_VAR 0 14
12352: PUSH
12353: LD_VAR 0 14
12357: PPUSH
12358: LD_VAR 0 14
12362: PUSH
12363: LD_INT 1
12365: PLUS
12366: PPUSH
12367: LD_INT 2
12369: PPUSH
12370: CALL_OW 1
12374: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12375: LD_VAR 0 9
12379: PPUSH
12380: LD_VAR 0 13
12384: PPUSH
12385: CALL_OW 325
12389: PUSH
12390: LD_VAR 0 10
12394: PPUSH
12395: CALL_OW 255
12399: PPUSH
12400: LD_VAR 0 13
12404: PPUSH
12405: CALL_OW 325
12409: NOT
12410: AND
12411: IFFALSE 12440
// missile := Replace ( missile , missile + 1 , 3 ) ;
12413: LD_ADDR_VAR 0 14
12417: PUSH
12418: LD_VAR 0 14
12422: PPUSH
12423: LD_VAR 0 14
12427: PUSH
12428: LD_INT 1
12430: PLUS
12431: PPUSH
12432: LD_INT 3
12434: PPUSH
12435: CALL_OW 1
12439: ST_TO_ADDR
// if missile < 2 then
12440: LD_VAR 0 14
12444: PUSH
12445: LD_INT 2
12447: LESS
12448: IFFALSE 12452
// exit ;
12450: GO 12674
// x := GetX ( enemy ) ;
12452: LD_ADDR_VAR 0 4
12456: PUSH
12457: LD_VAR 0 10
12461: PPUSH
12462: CALL_OW 250
12466: ST_TO_ADDR
// y := GetY ( enemy ) ;
12467: LD_ADDR_VAR 0 5
12471: PUSH
12472: LD_VAR 0 10
12476: PPUSH
12477: CALL_OW 251
12481: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12482: LD_ADDR_VAR 0 6
12486: PUSH
12487: LD_VAR 0 4
12491: PUSH
12492: LD_INT 1
12494: NEG
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 12
12503: PLUS
12504: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12505: LD_ADDR_VAR 0 7
12509: PUSH
12510: LD_VAR 0 5
12514: PUSH
12515: LD_INT 1
12517: NEG
12518: PPUSH
12519: LD_INT 1
12521: PPUSH
12522: CALL_OW 12
12526: PLUS
12527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12528: LD_VAR 0 6
12532: PPUSH
12533: LD_VAR 0 7
12537: PPUSH
12538: CALL_OW 488
12542: NOT
12543: IFFALSE 12565
// begin _x := x ;
12545: LD_ADDR_VAR 0 6
12549: PUSH
12550: LD_VAR 0 4
12554: ST_TO_ADDR
// _y := y ;
12555: LD_ADDR_VAR 0 7
12559: PUSH
12560: LD_VAR 0 5
12564: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12565: LD_ADDR_VAR 0 3
12569: PUSH
12570: LD_INT 1
12572: PPUSH
12573: LD_VAR 0 14
12577: PPUSH
12578: CALL_OW 12
12582: ST_TO_ADDR
// case i of 1 :
12583: LD_VAR 0 3
12587: PUSH
12588: LD_INT 1
12590: DOUBLE
12591: EQUAL
12592: IFTRUE 12596
12594: GO 12613
12596: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12597: LD_VAR 0 1
12601: PPUSH
12602: LD_VAR 0 10
12606: PPUSH
12607: CALL_OW 115
12611: GO 12674
12613: LD_INT 2
12615: DOUBLE
12616: EQUAL
12617: IFTRUE 12621
12619: GO 12643
12621: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12622: LD_VAR 0 1
12626: PPUSH
12627: LD_VAR 0 6
12631: PPUSH
12632: LD_VAR 0 7
12636: PPUSH
12637: CALL_OW 153
12641: GO 12674
12643: LD_INT 3
12645: DOUBLE
12646: EQUAL
12647: IFTRUE 12651
12649: GO 12673
12651: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12652: LD_VAR 0 1
12656: PPUSH
12657: LD_VAR 0 6
12661: PPUSH
12662: LD_VAR 0 7
12666: PPUSH
12667: CALL_OW 154
12671: GO 12674
12673: POP
// end ;
12674: LD_VAR 0 2
12678: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12679: LD_INT 0
12681: PPUSH
12682: PPUSH
12683: PPUSH
12684: PPUSH
12685: PPUSH
12686: PPUSH
// if not unit or not building then
12687: LD_VAR 0 1
12691: NOT
12692: PUSH
12693: LD_VAR 0 2
12697: NOT
12698: OR
12699: IFFALSE 12703
// exit ;
12701: GO 12861
// x := GetX ( building ) ;
12703: LD_ADDR_VAR 0 5
12707: PUSH
12708: LD_VAR 0 2
12712: PPUSH
12713: CALL_OW 250
12717: ST_TO_ADDR
// y := GetY ( building ) ;
12718: LD_ADDR_VAR 0 6
12722: PUSH
12723: LD_VAR 0 2
12727: PPUSH
12728: CALL_OW 251
12732: ST_TO_ADDR
// for i = 0 to 5 do
12733: LD_ADDR_VAR 0 4
12737: PUSH
12738: DOUBLE
12739: LD_INT 0
12741: DEC
12742: ST_TO_ADDR
12743: LD_INT 5
12745: PUSH
12746: FOR_TO
12747: IFFALSE 12859
// begin _x := ShiftX ( x , i , 3 ) ;
12749: LD_ADDR_VAR 0 7
12753: PUSH
12754: LD_VAR 0 5
12758: PPUSH
12759: LD_VAR 0 4
12763: PPUSH
12764: LD_INT 3
12766: PPUSH
12767: CALL_OW 272
12771: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12772: LD_ADDR_VAR 0 8
12776: PUSH
12777: LD_VAR 0 6
12781: PPUSH
12782: LD_VAR 0 4
12786: PPUSH
12787: LD_INT 3
12789: PPUSH
12790: CALL_OW 273
12794: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12795: LD_VAR 0 7
12799: PPUSH
12800: LD_VAR 0 8
12804: PPUSH
12805: CALL_OW 488
12809: NOT
12810: IFFALSE 12814
// continue ;
12812: GO 12746
// if HexInfo ( _x , _y ) = 0 then
12814: LD_VAR 0 7
12818: PPUSH
12819: LD_VAR 0 8
12823: PPUSH
12824: CALL_OW 428
12828: PUSH
12829: LD_INT 0
12831: EQUAL
12832: IFFALSE 12857
// begin ComMoveXY ( unit , _x , _y ) ;
12834: LD_VAR 0 1
12838: PPUSH
12839: LD_VAR 0 7
12843: PPUSH
12844: LD_VAR 0 8
12848: PPUSH
12849: CALL_OW 111
// exit ;
12853: POP
12854: POP
12855: GO 12861
// end ; end ;
12857: GO 12746
12859: POP
12860: POP
// end ;
12861: LD_VAR 0 3
12865: RET
// export function ScanBase ( side , base_area ) ; begin
12866: LD_INT 0
12868: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12869: LD_ADDR_VAR 0 3
12873: PUSH
12874: LD_VAR 0 2
12878: PPUSH
12879: LD_INT 81
12881: PUSH
12882: LD_VAR 0 1
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PPUSH
12891: CALL_OW 70
12895: ST_TO_ADDR
// end ;
12896: LD_VAR 0 3
12900: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12901: LD_INT 0
12903: PPUSH
12904: PPUSH
12905: PPUSH
12906: PPUSH
// result := false ;
12907: LD_ADDR_VAR 0 2
12911: PUSH
12912: LD_INT 0
12914: ST_TO_ADDR
// side := GetSide ( unit ) ;
12915: LD_ADDR_VAR 0 3
12919: PUSH
12920: LD_VAR 0 1
12924: PPUSH
12925: CALL_OW 255
12929: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12930: LD_ADDR_VAR 0 4
12934: PUSH
12935: LD_VAR 0 1
12939: PPUSH
12940: CALL_OW 248
12944: ST_TO_ADDR
// case nat of 1 :
12945: LD_VAR 0 4
12949: PUSH
12950: LD_INT 1
12952: DOUBLE
12953: EQUAL
12954: IFTRUE 12958
12956: GO 12969
12958: POP
// tech := tech_lassight ; 2 :
12959: LD_ADDR_VAR 0 5
12963: PUSH
12964: LD_INT 12
12966: ST_TO_ADDR
12967: GO 13008
12969: LD_INT 2
12971: DOUBLE
12972: EQUAL
12973: IFTRUE 12977
12975: GO 12988
12977: POP
// tech := tech_mortar ; 3 :
12978: LD_ADDR_VAR 0 5
12982: PUSH
12983: LD_INT 41
12985: ST_TO_ADDR
12986: GO 13008
12988: LD_INT 3
12990: DOUBLE
12991: EQUAL
12992: IFTRUE 12996
12994: GO 13007
12996: POP
// tech := tech_bazooka ; end ;
12997: LD_ADDR_VAR 0 5
13001: PUSH
13002: LD_INT 44
13004: ST_TO_ADDR
13005: GO 13008
13007: POP
// if Researched ( side , tech ) then
13008: LD_VAR 0 3
13012: PPUSH
13013: LD_VAR 0 5
13017: PPUSH
13018: CALL_OW 325
13022: IFFALSE 13049
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13024: LD_ADDR_VAR 0 2
13028: PUSH
13029: LD_INT 5
13031: PUSH
13032: LD_INT 8
13034: PUSH
13035: LD_INT 9
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: LD_VAR 0 4
13047: ARRAY
13048: ST_TO_ADDR
// end ;
13049: LD_VAR 0 2
13053: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13054: LD_INT 0
13056: PPUSH
13057: PPUSH
13058: PPUSH
// if not mines then
13059: LD_VAR 0 2
13063: NOT
13064: IFFALSE 13068
// exit ;
13066: GO 13212
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13068: LD_ADDR_VAR 0 5
13072: PUSH
13073: LD_INT 81
13075: PUSH
13076: LD_VAR 0 1
13080: PUSH
13081: EMPTY
13082: LIST
13083: LIST
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 21
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: EMPTY
13099: LIST
13100: LIST
13101: PUSH
13102: EMPTY
13103: LIST
13104: LIST
13105: PPUSH
13106: CALL_OW 69
13110: ST_TO_ADDR
// for i in mines do
13111: LD_ADDR_VAR 0 4
13115: PUSH
13116: LD_VAR 0 2
13120: PUSH
13121: FOR_IN
13122: IFFALSE 13210
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13124: LD_VAR 0 4
13128: PUSH
13129: LD_INT 1
13131: ARRAY
13132: PPUSH
13133: LD_VAR 0 4
13137: PUSH
13138: LD_INT 2
13140: ARRAY
13141: PPUSH
13142: CALL_OW 458
13146: NOT
13147: IFFALSE 13151
// continue ;
13149: GO 13121
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13151: LD_VAR 0 4
13155: PUSH
13156: LD_INT 1
13158: ARRAY
13159: PPUSH
13160: LD_VAR 0 4
13164: PUSH
13165: LD_INT 2
13167: ARRAY
13168: PPUSH
13169: CALL_OW 428
13173: PUSH
13174: LD_VAR 0 5
13178: IN
13179: IFFALSE 13208
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13181: LD_VAR 0 4
13185: PUSH
13186: LD_INT 1
13188: ARRAY
13189: PPUSH
13190: LD_VAR 0 4
13194: PUSH
13195: LD_INT 2
13197: ARRAY
13198: PPUSH
13199: LD_VAR 0 1
13203: PPUSH
13204: CALL_OW 456
// end ;
13208: GO 13121
13210: POP
13211: POP
// end ;
13212: LD_VAR 0 3
13216: RET
// export function Count ( array ) ; var i ; begin
13217: LD_INT 0
13219: PPUSH
13220: PPUSH
// result := 0 ;
13221: LD_ADDR_VAR 0 2
13225: PUSH
13226: LD_INT 0
13228: ST_TO_ADDR
// for i in array do
13229: LD_ADDR_VAR 0 3
13233: PUSH
13234: LD_VAR 0 1
13238: PUSH
13239: FOR_IN
13240: IFFALSE 13264
// if i then
13242: LD_VAR 0 3
13246: IFFALSE 13262
// result := result + 1 ;
13248: LD_ADDR_VAR 0 2
13252: PUSH
13253: LD_VAR 0 2
13257: PUSH
13258: LD_INT 1
13260: PLUS
13261: ST_TO_ADDR
13262: GO 13239
13264: POP
13265: POP
// end ;
13266: LD_VAR 0 2
13270: RET
// export function IsEmpty ( building ) ; begin
13271: LD_INT 0
13273: PPUSH
// if not building then
13274: LD_VAR 0 1
13278: NOT
13279: IFFALSE 13283
// exit ;
13281: GO 13326
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13283: LD_ADDR_VAR 0 2
13287: PUSH
13288: LD_VAR 0 1
13292: PUSH
13293: LD_INT 22
13295: PUSH
13296: LD_VAR 0 1
13300: PPUSH
13301: CALL_OW 255
13305: PUSH
13306: EMPTY
13307: LIST
13308: LIST
13309: PUSH
13310: LD_INT 58
13312: PUSH
13313: EMPTY
13314: LIST
13315: PUSH
13316: EMPTY
13317: LIST
13318: LIST
13319: PPUSH
13320: CALL_OW 69
13324: IN
13325: ST_TO_ADDR
// end ;
13326: LD_VAR 0 2
13330: RET
// export function IsNotFull ( building ) ; var places ; begin
13331: LD_INT 0
13333: PPUSH
13334: PPUSH
// if not building then
13335: LD_VAR 0 1
13339: NOT
13340: IFFALSE 13344
// exit ;
13342: GO 13515
// result := false ;
13344: LD_ADDR_VAR 0 2
13348: PUSH
13349: LD_INT 0
13351: ST_TO_ADDR
// places := 0 ;
13352: LD_ADDR_VAR 0 3
13356: PUSH
13357: LD_INT 0
13359: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13360: LD_VAR 0 1
13364: PPUSH
13365: CALL_OW 266
13369: PUSH
13370: LD_INT 0
13372: DOUBLE
13373: EQUAL
13374: IFTRUE 13432
13376: LD_INT 1
13378: DOUBLE
13379: EQUAL
13380: IFTRUE 13432
13382: LD_INT 6
13384: DOUBLE
13385: EQUAL
13386: IFTRUE 13432
13388: LD_INT 7
13390: DOUBLE
13391: EQUAL
13392: IFTRUE 13432
13394: LD_INT 8
13396: DOUBLE
13397: EQUAL
13398: IFTRUE 13432
13400: LD_INT 4
13402: DOUBLE
13403: EQUAL
13404: IFTRUE 13432
13406: LD_INT 5
13408: DOUBLE
13409: EQUAL
13410: IFTRUE 13432
13412: LD_INT 2
13414: DOUBLE
13415: EQUAL
13416: IFTRUE 13432
13418: LD_INT 3
13420: DOUBLE
13421: EQUAL
13422: IFTRUE 13432
13424: LD_INT 35
13426: DOUBLE
13427: EQUAL
13428: IFTRUE 13432
13430: GO 13443
13432: POP
// places := 6 ; b_bunker , b_breastwork :
13433: LD_ADDR_VAR 0 3
13437: PUSH
13438: LD_INT 6
13440: ST_TO_ADDR
13441: GO 13488
13443: LD_INT 32
13445: DOUBLE
13446: EQUAL
13447: IFTRUE 13457
13449: LD_INT 31
13451: DOUBLE
13452: EQUAL
13453: IFTRUE 13457
13455: GO 13468
13457: POP
// places := 1 ; b_control_tower :
13458: LD_ADDR_VAR 0 3
13462: PUSH
13463: LD_INT 1
13465: ST_TO_ADDR
13466: GO 13488
13468: LD_INT 36
13470: DOUBLE
13471: EQUAL
13472: IFTRUE 13476
13474: GO 13487
13476: POP
// places := 3 ; end ;
13477: LD_ADDR_VAR 0 3
13481: PUSH
13482: LD_INT 3
13484: ST_TO_ADDR
13485: GO 13488
13487: POP
// if places then
13488: LD_VAR 0 3
13492: IFFALSE 13515
// result := UnitsInside ( building ) < places ;
13494: LD_ADDR_VAR 0 2
13498: PUSH
13499: LD_VAR 0 1
13503: PPUSH
13504: CALL_OW 313
13508: PUSH
13509: LD_VAR 0 3
13513: LESS
13514: ST_TO_ADDR
// end ;
13515: LD_VAR 0 2
13519: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13520: LD_INT 0
13522: PPUSH
13523: PPUSH
13524: PPUSH
13525: PPUSH
// tmp := [ ] ;
13526: LD_ADDR_VAR 0 3
13530: PUSH
13531: EMPTY
13532: ST_TO_ADDR
// list := [ ] ;
13533: LD_ADDR_VAR 0 5
13537: PUSH
13538: EMPTY
13539: ST_TO_ADDR
// for i = 16 to 25 do
13540: LD_ADDR_VAR 0 4
13544: PUSH
13545: DOUBLE
13546: LD_INT 16
13548: DEC
13549: ST_TO_ADDR
13550: LD_INT 25
13552: PUSH
13553: FOR_TO
13554: IFFALSE 13627
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13556: LD_ADDR_VAR 0 3
13560: PUSH
13561: LD_VAR 0 3
13565: PUSH
13566: LD_INT 22
13568: PUSH
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 255
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 91
13585: PUSH
13586: LD_VAR 0 1
13590: PUSH
13591: LD_INT 6
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: LIST
13598: PUSH
13599: LD_INT 30
13601: PUSH
13602: LD_VAR 0 4
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: PPUSH
13619: CALL_OW 69
13623: ADD
13624: ST_TO_ADDR
13625: GO 13553
13627: POP
13628: POP
// for i = 1 to tmp do
13629: LD_ADDR_VAR 0 4
13633: PUSH
13634: DOUBLE
13635: LD_INT 1
13637: DEC
13638: ST_TO_ADDR
13639: LD_VAR 0 3
13643: PUSH
13644: FOR_TO
13645: IFFALSE 13733
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13647: LD_ADDR_VAR 0 5
13651: PUSH
13652: LD_VAR 0 5
13656: PUSH
13657: LD_VAR 0 3
13661: PUSH
13662: LD_VAR 0 4
13666: ARRAY
13667: PPUSH
13668: CALL_OW 266
13672: PUSH
13673: LD_VAR 0 3
13677: PUSH
13678: LD_VAR 0 4
13682: ARRAY
13683: PPUSH
13684: CALL_OW 250
13688: PUSH
13689: LD_VAR 0 3
13693: PUSH
13694: LD_VAR 0 4
13698: ARRAY
13699: PPUSH
13700: CALL_OW 251
13704: PUSH
13705: LD_VAR 0 3
13709: PUSH
13710: LD_VAR 0 4
13714: ARRAY
13715: PPUSH
13716: CALL_OW 254
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: LIST
13725: LIST
13726: PUSH
13727: EMPTY
13728: LIST
13729: ADD
13730: ST_TO_ADDR
13731: GO 13644
13733: POP
13734: POP
// result := list ;
13735: LD_ADDR_VAR 0 2
13739: PUSH
13740: LD_VAR 0 5
13744: ST_TO_ADDR
// end ;
13745: LD_VAR 0 2
13749: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13750: LD_INT 0
13752: PPUSH
13753: PPUSH
13754: PPUSH
13755: PPUSH
13756: PPUSH
13757: PPUSH
13758: PPUSH
// if not factory then
13759: LD_VAR 0 1
13763: NOT
13764: IFFALSE 13768
// exit ;
13766: GO 14361
// if control = control_apeman then
13768: LD_VAR 0 4
13772: PUSH
13773: LD_INT 5
13775: EQUAL
13776: IFFALSE 13885
// begin tmp := UnitsInside ( factory ) ;
13778: LD_ADDR_VAR 0 8
13782: PUSH
13783: LD_VAR 0 1
13787: PPUSH
13788: CALL_OW 313
13792: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13793: LD_VAR 0 8
13797: PPUSH
13798: LD_INT 25
13800: PUSH
13801: LD_INT 12
13803: PUSH
13804: EMPTY
13805: LIST
13806: LIST
13807: PPUSH
13808: CALL_OW 72
13812: NOT
13813: IFFALSE 13823
// control := control_manual ;
13815: LD_ADDR_VAR 0 4
13819: PUSH
13820: LD_INT 1
13822: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13823: LD_ADDR_VAR 0 8
13827: PUSH
13828: LD_VAR 0 1
13832: PPUSH
13833: CALL 13520 0 1
13837: ST_TO_ADDR
// if tmp then
13838: LD_VAR 0 8
13842: IFFALSE 13885
// begin for i in tmp do
13844: LD_ADDR_VAR 0 7
13848: PUSH
13849: LD_VAR 0 8
13853: PUSH
13854: FOR_IN
13855: IFFALSE 13883
// if i [ 1 ] = b_ext_radio then
13857: LD_VAR 0 7
13861: PUSH
13862: LD_INT 1
13864: ARRAY
13865: PUSH
13866: LD_INT 22
13868: EQUAL
13869: IFFALSE 13881
// begin control := control_remote ;
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: LD_INT 2
13878: ST_TO_ADDR
// break ;
13879: GO 13883
// end ;
13881: GO 13854
13883: POP
13884: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13885: LD_VAR 0 1
13889: PPUSH
13890: LD_VAR 0 2
13894: PPUSH
13895: LD_VAR 0 3
13899: PPUSH
13900: LD_VAR 0 4
13904: PPUSH
13905: LD_VAR 0 5
13909: PPUSH
13910: CALL_OW 448
13914: IFFALSE 13949
// begin result := [ chassis , engine , control , weapon ] ;
13916: LD_ADDR_VAR 0 6
13920: PUSH
13921: LD_VAR 0 2
13925: PUSH
13926: LD_VAR 0 3
13930: PUSH
13931: LD_VAR 0 4
13935: PUSH
13936: LD_VAR 0 5
13940: PUSH
13941: EMPTY
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: ST_TO_ADDR
// exit ;
13947: GO 14361
// end ; _chassis := AvailableChassisList ( factory ) ;
13949: LD_ADDR_VAR 0 9
13953: PUSH
13954: LD_VAR 0 1
13958: PPUSH
13959: CALL_OW 475
13963: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13964: LD_ADDR_VAR 0 11
13968: PUSH
13969: LD_VAR 0 1
13973: PPUSH
13974: CALL_OW 476
13978: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13979: LD_ADDR_VAR 0 12
13983: PUSH
13984: LD_VAR 0 1
13988: PPUSH
13989: CALL_OW 477
13993: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13994: LD_ADDR_VAR 0 10
13998: PUSH
13999: LD_VAR 0 1
14003: PPUSH
14004: CALL_OW 478
14008: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
14009: LD_VAR 0 9
14013: NOT
14014: PUSH
14015: LD_VAR 0 11
14019: NOT
14020: OR
14021: PUSH
14022: LD_VAR 0 12
14026: NOT
14027: OR
14028: PUSH
14029: LD_VAR 0 10
14033: NOT
14034: OR
14035: IFFALSE 14070
// begin result := [ chassis , engine , control , weapon ] ;
14037: LD_ADDR_VAR 0 6
14041: PUSH
14042: LD_VAR 0 2
14046: PUSH
14047: LD_VAR 0 3
14051: PUSH
14052: LD_VAR 0 4
14056: PUSH
14057: LD_VAR 0 5
14061: PUSH
14062: EMPTY
14063: LIST
14064: LIST
14065: LIST
14066: LIST
14067: ST_TO_ADDR
// exit ;
14068: GO 14361
// end ; if not chassis in _chassis then
14070: LD_VAR 0 2
14074: PUSH
14075: LD_VAR 0 9
14079: IN
14080: NOT
14081: IFFALSE 14107
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
14083: LD_ADDR_VAR 0 2
14087: PUSH
14088: LD_VAR 0 9
14092: PUSH
14093: LD_INT 1
14095: PPUSH
14096: LD_VAR 0 9
14100: PPUSH
14101: CALL_OW 12
14105: ARRAY
14106: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14107: LD_VAR 0 2
14111: PPUSH
14112: LD_VAR 0 3
14116: PPUSH
14117: CALL 14366 0 2
14121: NOT
14122: IFFALSE 14181
// repeat engine := _engine [ 1 ] ;
14124: LD_ADDR_VAR 0 3
14128: PUSH
14129: LD_VAR 0 11
14133: PUSH
14134: LD_INT 1
14136: ARRAY
14137: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14138: LD_ADDR_VAR 0 11
14142: PUSH
14143: LD_VAR 0 11
14147: PPUSH
14148: LD_INT 1
14150: PPUSH
14151: CALL_OW 3
14155: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14156: LD_VAR 0 2
14160: PPUSH
14161: LD_VAR 0 3
14165: PPUSH
14166: CALL 14366 0 2
14170: PUSH
14171: LD_VAR 0 11
14175: PUSH
14176: EMPTY
14177: EQUAL
14178: OR
14179: IFFALSE 14124
// if not control in _control then
14181: LD_VAR 0 4
14185: PUSH
14186: LD_VAR 0 12
14190: IN
14191: NOT
14192: IFFALSE 14218
// control := _control [ rand ( 1 , _control ) ] ;
14194: LD_ADDR_VAR 0 4
14198: PUSH
14199: LD_VAR 0 12
14203: PUSH
14204: LD_INT 1
14206: PPUSH
14207: LD_VAR 0 12
14211: PPUSH
14212: CALL_OW 12
14216: ARRAY
14217: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14218: LD_VAR 0 2
14222: PPUSH
14223: LD_VAR 0 5
14227: PPUSH
14228: CALL 14586 0 2
14232: NOT
14233: IFFALSE 14292
// repeat weapon := _weapon [ 1 ] ;
14235: LD_ADDR_VAR 0 5
14239: PUSH
14240: LD_VAR 0 10
14244: PUSH
14245: LD_INT 1
14247: ARRAY
14248: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14249: LD_ADDR_VAR 0 10
14253: PUSH
14254: LD_VAR 0 10
14258: PPUSH
14259: LD_INT 1
14261: PPUSH
14262: CALL_OW 3
14266: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14267: LD_VAR 0 2
14271: PPUSH
14272: LD_VAR 0 5
14276: PPUSH
14277: CALL 14586 0 2
14281: PUSH
14282: LD_VAR 0 10
14286: PUSH
14287: EMPTY
14288: EQUAL
14289: OR
14290: IFFALSE 14235
// result := [ ] ;
14292: LD_ADDR_VAR 0 6
14296: PUSH
14297: EMPTY
14298: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14299: LD_VAR 0 1
14303: PPUSH
14304: LD_VAR 0 2
14308: PPUSH
14309: LD_VAR 0 3
14313: PPUSH
14314: LD_VAR 0 4
14318: PPUSH
14319: LD_VAR 0 5
14323: PPUSH
14324: CALL_OW 448
14328: IFFALSE 14361
// result := [ chassis , engine , control , weapon ] ;
14330: LD_ADDR_VAR 0 6
14334: PUSH
14335: LD_VAR 0 2
14339: PUSH
14340: LD_VAR 0 3
14344: PUSH
14345: LD_VAR 0 4
14349: PUSH
14350: LD_VAR 0 5
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: ST_TO_ADDR
// end ;
14361: LD_VAR 0 6
14365: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14366: LD_INT 0
14368: PPUSH
// if not chassis or not engine then
14369: LD_VAR 0 1
14373: NOT
14374: PUSH
14375: LD_VAR 0 2
14379: NOT
14380: OR
14381: IFFALSE 14385
// exit ;
14383: GO 14581
// case engine of engine_solar :
14385: LD_VAR 0 2
14389: PUSH
14390: LD_INT 2
14392: DOUBLE
14393: EQUAL
14394: IFTRUE 14398
14396: GO 14436
14398: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14399: LD_ADDR_VAR 0 3
14403: PUSH
14404: LD_INT 11
14406: PUSH
14407: LD_INT 12
14409: PUSH
14410: LD_INT 13
14412: PUSH
14413: LD_INT 14
14415: PUSH
14416: LD_INT 1
14418: PUSH
14419: LD_INT 2
14421: PUSH
14422: LD_INT 3
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: ST_TO_ADDR
14434: GO 14565
14436: LD_INT 1
14438: DOUBLE
14439: EQUAL
14440: IFTRUE 14444
14442: GO 14506
14444: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14445: LD_ADDR_VAR 0 3
14449: PUSH
14450: LD_INT 11
14452: PUSH
14453: LD_INT 12
14455: PUSH
14456: LD_INT 13
14458: PUSH
14459: LD_INT 14
14461: PUSH
14462: LD_INT 1
14464: PUSH
14465: LD_INT 2
14467: PUSH
14468: LD_INT 3
14470: PUSH
14471: LD_INT 4
14473: PUSH
14474: LD_INT 5
14476: PUSH
14477: LD_INT 21
14479: PUSH
14480: LD_INT 23
14482: PUSH
14483: LD_INT 22
14485: PUSH
14486: LD_INT 24
14488: PUSH
14489: EMPTY
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: LIST
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: ST_TO_ADDR
14504: GO 14565
14506: LD_INT 3
14508: DOUBLE
14509: EQUAL
14510: IFTRUE 14514
14512: GO 14564
14514: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14515: LD_ADDR_VAR 0 3
14519: PUSH
14520: LD_INT 13
14522: PUSH
14523: LD_INT 14
14525: PUSH
14526: LD_INT 2
14528: PUSH
14529: LD_INT 3
14531: PUSH
14532: LD_INT 4
14534: PUSH
14535: LD_INT 5
14537: PUSH
14538: LD_INT 21
14540: PUSH
14541: LD_INT 22
14543: PUSH
14544: LD_INT 23
14546: PUSH
14547: LD_INT 24
14549: PUSH
14550: EMPTY
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: ST_TO_ADDR
14562: GO 14565
14564: POP
// result := ( chassis in result ) ;
14565: LD_ADDR_VAR 0 3
14569: PUSH
14570: LD_VAR 0 1
14574: PUSH
14575: LD_VAR 0 3
14579: IN
14580: ST_TO_ADDR
// end ;
14581: LD_VAR 0 3
14585: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14586: LD_INT 0
14588: PPUSH
// if not chassis or not weapon then
14589: LD_VAR 0 1
14593: NOT
14594: PUSH
14595: LD_VAR 0 2
14599: NOT
14600: OR
14601: IFFALSE 14605
// exit ;
14603: GO 15665
// case weapon of us_machine_gun :
14605: LD_VAR 0 2
14609: PUSH
14610: LD_INT 2
14612: DOUBLE
14613: EQUAL
14614: IFTRUE 14618
14616: GO 14648
14618: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14619: LD_ADDR_VAR 0 3
14623: PUSH
14624: LD_INT 1
14626: PUSH
14627: LD_INT 2
14629: PUSH
14630: LD_INT 3
14632: PUSH
14633: LD_INT 4
14635: PUSH
14636: LD_INT 5
14638: PUSH
14639: EMPTY
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: ST_TO_ADDR
14646: GO 15649
14648: LD_INT 3
14650: DOUBLE
14651: EQUAL
14652: IFTRUE 14656
14654: GO 14686
14656: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14657: LD_ADDR_VAR 0 3
14661: PUSH
14662: LD_INT 1
14664: PUSH
14665: LD_INT 2
14667: PUSH
14668: LD_INT 3
14670: PUSH
14671: LD_INT 4
14673: PUSH
14674: LD_INT 5
14676: PUSH
14677: EMPTY
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: ST_TO_ADDR
14684: GO 15649
14686: LD_INT 11
14688: DOUBLE
14689: EQUAL
14690: IFTRUE 14694
14692: GO 14724
14694: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14695: LD_ADDR_VAR 0 3
14699: PUSH
14700: LD_INT 1
14702: PUSH
14703: LD_INT 2
14705: PUSH
14706: LD_INT 3
14708: PUSH
14709: LD_INT 4
14711: PUSH
14712: LD_INT 5
14714: PUSH
14715: EMPTY
14716: LIST
14717: LIST
14718: LIST
14719: LIST
14720: LIST
14721: ST_TO_ADDR
14722: GO 15649
14724: LD_INT 4
14726: DOUBLE
14727: EQUAL
14728: IFTRUE 14732
14730: GO 14758
14732: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14733: LD_ADDR_VAR 0 3
14737: PUSH
14738: LD_INT 2
14740: PUSH
14741: LD_INT 3
14743: PUSH
14744: LD_INT 4
14746: PUSH
14747: LD_INT 5
14749: PUSH
14750: EMPTY
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: ST_TO_ADDR
14756: GO 15649
14758: LD_INT 5
14760: DOUBLE
14761: EQUAL
14762: IFTRUE 14766
14764: GO 14792
14766: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14767: LD_ADDR_VAR 0 3
14771: PUSH
14772: LD_INT 2
14774: PUSH
14775: LD_INT 3
14777: PUSH
14778: LD_INT 4
14780: PUSH
14781: LD_INT 5
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: ST_TO_ADDR
14790: GO 15649
14792: LD_INT 9
14794: DOUBLE
14795: EQUAL
14796: IFTRUE 14800
14798: GO 14826
14800: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14801: LD_ADDR_VAR 0 3
14805: PUSH
14806: LD_INT 2
14808: PUSH
14809: LD_INT 3
14811: PUSH
14812: LD_INT 4
14814: PUSH
14815: LD_INT 5
14817: PUSH
14818: EMPTY
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: ST_TO_ADDR
14824: GO 15649
14826: LD_INT 7
14828: DOUBLE
14829: EQUAL
14830: IFTRUE 14834
14832: GO 14860
14834: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14835: LD_ADDR_VAR 0 3
14839: PUSH
14840: LD_INT 2
14842: PUSH
14843: LD_INT 3
14845: PUSH
14846: LD_INT 4
14848: PUSH
14849: LD_INT 5
14851: PUSH
14852: EMPTY
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: ST_TO_ADDR
14858: GO 15649
14860: LD_INT 12
14862: DOUBLE
14863: EQUAL
14864: IFTRUE 14868
14866: GO 14894
14868: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14869: LD_ADDR_VAR 0 3
14873: PUSH
14874: LD_INT 2
14876: PUSH
14877: LD_INT 3
14879: PUSH
14880: LD_INT 4
14882: PUSH
14883: LD_INT 5
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: ST_TO_ADDR
14892: GO 15649
14894: LD_INT 13
14896: DOUBLE
14897: EQUAL
14898: IFTRUE 14902
14900: GO 14928
14902: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14903: LD_ADDR_VAR 0 3
14907: PUSH
14908: LD_INT 2
14910: PUSH
14911: LD_INT 3
14913: PUSH
14914: LD_INT 4
14916: PUSH
14917: LD_INT 5
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: LIST
14924: LIST
14925: ST_TO_ADDR
14926: GO 15649
14928: LD_INT 14
14930: DOUBLE
14931: EQUAL
14932: IFTRUE 14936
14934: GO 14954
14936: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14937: LD_ADDR_VAR 0 3
14941: PUSH
14942: LD_INT 4
14944: PUSH
14945: LD_INT 5
14947: PUSH
14948: EMPTY
14949: LIST
14950: LIST
14951: ST_TO_ADDR
14952: GO 15649
14954: LD_INT 6
14956: DOUBLE
14957: EQUAL
14958: IFTRUE 14962
14960: GO 14980
14962: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14963: LD_ADDR_VAR 0 3
14967: PUSH
14968: LD_INT 4
14970: PUSH
14971: LD_INT 5
14973: PUSH
14974: EMPTY
14975: LIST
14976: LIST
14977: ST_TO_ADDR
14978: GO 15649
14980: LD_INT 10
14982: DOUBLE
14983: EQUAL
14984: IFTRUE 14988
14986: GO 15006
14988: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14989: LD_ADDR_VAR 0 3
14993: PUSH
14994: LD_INT 4
14996: PUSH
14997: LD_INT 5
14999: PUSH
15000: EMPTY
15001: LIST
15002: LIST
15003: ST_TO_ADDR
15004: GO 15649
15006: LD_INT 22
15008: DOUBLE
15009: EQUAL
15010: IFTRUE 15014
15012: GO 15040
15014: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
15015: LD_ADDR_VAR 0 3
15019: PUSH
15020: LD_INT 11
15022: PUSH
15023: LD_INT 12
15025: PUSH
15026: LD_INT 13
15028: PUSH
15029: LD_INT 14
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: ST_TO_ADDR
15038: GO 15649
15040: LD_INT 23
15042: DOUBLE
15043: EQUAL
15044: IFTRUE 15048
15046: GO 15074
15048: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
15049: LD_ADDR_VAR 0 3
15053: PUSH
15054: LD_INT 11
15056: PUSH
15057: LD_INT 12
15059: PUSH
15060: LD_INT 13
15062: PUSH
15063: LD_INT 14
15065: PUSH
15066: EMPTY
15067: LIST
15068: LIST
15069: LIST
15070: LIST
15071: ST_TO_ADDR
15072: GO 15649
15074: LD_INT 24
15076: DOUBLE
15077: EQUAL
15078: IFTRUE 15082
15080: GO 15108
15082: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
15083: LD_ADDR_VAR 0 3
15087: PUSH
15088: LD_INT 11
15090: PUSH
15091: LD_INT 12
15093: PUSH
15094: LD_INT 13
15096: PUSH
15097: LD_INT 14
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: ST_TO_ADDR
15106: GO 15649
15108: LD_INT 30
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15142
15116: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15117: LD_ADDR_VAR 0 3
15121: PUSH
15122: LD_INT 11
15124: PUSH
15125: LD_INT 12
15127: PUSH
15128: LD_INT 13
15130: PUSH
15131: LD_INT 14
15133: PUSH
15134: EMPTY
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: ST_TO_ADDR
15140: GO 15649
15142: LD_INT 25
15144: DOUBLE
15145: EQUAL
15146: IFTRUE 15150
15148: GO 15168
15150: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15151: LD_ADDR_VAR 0 3
15155: PUSH
15156: LD_INT 13
15158: PUSH
15159: LD_INT 14
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: ST_TO_ADDR
15166: GO 15649
15168: LD_INT 27
15170: DOUBLE
15171: EQUAL
15172: IFTRUE 15176
15174: GO 15194
15176: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15177: LD_ADDR_VAR 0 3
15181: PUSH
15182: LD_INT 13
15184: PUSH
15185: LD_INT 14
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: ST_TO_ADDR
15192: GO 15649
15194: LD_INT 92
15196: DOUBLE
15197: EQUAL
15198: IFTRUE 15202
15200: GO 15228
15202: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15203: LD_ADDR_VAR 0 3
15207: PUSH
15208: LD_INT 11
15210: PUSH
15211: LD_INT 12
15213: PUSH
15214: LD_INT 13
15216: PUSH
15217: LD_INT 14
15219: PUSH
15220: EMPTY
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: ST_TO_ADDR
15226: GO 15649
15228: LD_INT 28
15230: DOUBLE
15231: EQUAL
15232: IFTRUE 15236
15234: GO 15254
15236: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15237: LD_ADDR_VAR 0 3
15241: PUSH
15242: LD_INT 13
15244: PUSH
15245: LD_INT 14
15247: PUSH
15248: EMPTY
15249: LIST
15250: LIST
15251: ST_TO_ADDR
15252: GO 15649
15254: LD_INT 29
15256: DOUBLE
15257: EQUAL
15258: IFTRUE 15262
15260: GO 15280
15262: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15263: LD_ADDR_VAR 0 3
15267: PUSH
15268: LD_INT 13
15270: PUSH
15271: LD_INT 14
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: ST_TO_ADDR
15278: GO 15649
15280: LD_INT 31
15282: DOUBLE
15283: EQUAL
15284: IFTRUE 15288
15286: GO 15306
15288: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15289: LD_ADDR_VAR 0 3
15293: PUSH
15294: LD_INT 13
15296: PUSH
15297: LD_INT 14
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: ST_TO_ADDR
15304: GO 15649
15306: LD_INT 26
15308: DOUBLE
15309: EQUAL
15310: IFTRUE 15314
15312: GO 15332
15314: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15315: LD_ADDR_VAR 0 3
15319: PUSH
15320: LD_INT 13
15322: PUSH
15323: LD_INT 14
15325: PUSH
15326: EMPTY
15327: LIST
15328: LIST
15329: ST_TO_ADDR
15330: GO 15649
15332: LD_INT 42
15334: DOUBLE
15335: EQUAL
15336: IFTRUE 15340
15338: GO 15366
15340: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15341: LD_ADDR_VAR 0 3
15345: PUSH
15346: LD_INT 21
15348: PUSH
15349: LD_INT 22
15351: PUSH
15352: LD_INT 23
15354: PUSH
15355: LD_INT 24
15357: PUSH
15358: EMPTY
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: ST_TO_ADDR
15364: GO 15649
15366: LD_INT 43
15368: DOUBLE
15369: EQUAL
15370: IFTRUE 15374
15372: GO 15400
15374: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15375: LD_ADDR_VAR 0 3
15379: PUSH
15380: LD_INT 21
15382: PUSH
15383: LD_INT 22
15385: PUSH
15386: LD_INT 23
15388: PUSH
15389: LD_INT 24
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: ST_TO_ADDR
15398: GO 15649
15400: LD_INT 44
15402: DOUBLE
15403: EQUAL
15404: IFTRUE 15408
15406: GO 15434
15408: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15409: LD_ADDR_VAR 0 3
15413: PUSH
15414: LD_INT 21
15416: PUSH
15417: LD_INT 22
15419: PUSH
15420: LD_INT 23
15422: PUSH
15423: LD_INT 24
15425: PUSH
15426: EMPTY
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: ST_TO_ADDR
15432: GO 15649
15434: LD_INT 45
15436: DOUBLE
15437: EQUAL
15438: IFTRUE 15442
15440: GO 15468
15442: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15443: LD_ADDR_VAR 0 3
15447: PUSH
15448: LD_INT 21
15450: PUSH
15451: LD_INT 22
15453: PUSH
15454: LD_INT 23
15456: PUSH
15457: LD_INT 24
15459: PUSH
15460: EMPTY
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: ST_TO_ADDR
15466: GO 15649
15468: LD_INT 49
15470: DOUBLE
15471: EQUAL
15472: IFTRUE 15476
15474: GO 15502
15476: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15477: LD_ADDR_VAR 0 3
15481: PUSH
15482: LD_INT 21
15484: PUSH
15485: LD_INT 22
15487: PUSH
15488: LD_INT 23
15490: PUSH
15491: LD_INT 24
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: LIST
15498: LIST
15499: ST_TO_ADDR
15500: GO 15649
15502: LD_INT 51
15504: DOUBLE
15505: EQUAL
15506: IFTRUE 15510
15508: GO 15536
15510: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15511: LD_ADDR_VAR 0 3
15515: PUSH
15516: LD_INT 21
15518: PUSH
15519: LD_INT 22
15521: PUSH
15522: LD_INT 23
15524: PUSH
15525: LD_INT 24
15527: PUSH
15528: EMPTY
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: ST_TO_ADDR
15534: GO 15649
15536: LD_INT 52
15538: DOUBLE
15539: EQUAL
15540: IFTRUE 15544
15542: GO 15570
15544: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15545: LD_ADDR_VAR 0 3
15549: PUSH
15550: LD_INT 21
15552: PUSH
15553: LD_INT 22
15555: PUSH
15556: LD_INT 23
15558: PUSH
15559: LD_INT 24
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: ST_TO_ADDR
15568: GO 15649
15570: LD_INT 53
15572: DOUBLE
15573: EQUAL
15574: IFTRUE 15578
15576: GO 15596
15578: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15579: LD_ADDR_VAR 0 3
15583: PUSH
15584: LD_INT 23
15586: PUSH
15587: LD_INT 24
15589: PUSH
15590: EMPTY
15591: LIST
15592: LIST
15593: ST_TO_ADDR
15594: GO 15649
15596: LD_INT 46
15598: DOUBLE
15599: EQUAL
15600: IFTRUE 15604
15602: GO 15622
15604: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15605: LD_ADDR_VAR 0 3
15609: PUSH
15610: LD_INT 23
15612: PUSH
15613: LD_INT 24
15615: PUSH
15616: EMPTY
15617: LIST
15618: LIST
15619: ST_TO_ADDR
15620: GO 15649
15622: LD_INT 47
15624: DOUBLE
15625: EQUAL
15626: IFTRUE 15630
15628: GO 15648
15630: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15631: LD_ADDR_VAR 0 3
15635: PUSH
15636: LD_INT 23
15638: PUSH
15639: LD_INT 24
15641: PUSH
15642: EMPTY
15643: LIST
15644: LIST
15645: ST_TO_ADDR
15646: GO 15649
15648: POP
// result := ( chassis in result ) ;
15649: LD_ADDR_VAR 0 3
15653: PUSH
15654: LD_VAR 0 1
15658: PUSH
15659: LD_VAR 0 3
15663: IN
15664: ST_TO_ADDR
// end ;
15665: LD_VAR 0 3
15669: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15670: LD_INT 0
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
// result := array ;
15679: LD_ADDR_VAR 0 5
15683: PUSH
15684: LD_VAR 0 1
15688: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15689: LD_VAR 0 1
15693: NOT
15694: PUSH
15695: LD_VAR 0 2
15699: NOT
15700: OR
15701: PUSH
15702: LD_VAR 0 3
15706: NOT
15707: OR
15708: PUSH
15709: LD_VAR 0 2
15713: PUSH
15714: LD_VAR 0 1
15718: GREATER
15719: OR
15720: PUSH
15721: LD_VAR 0 3
15725: PUSH
15726: LD_VAR 0 1
15730: GREATER
15731: OR
15732: IFFALSE 15736
// exit ;
15734: GO 16032
// if direction then
15736: LD_VAR 0 4
15740: IFFALSE 15804
// begin d := 1 ;
15742: LD_ADDR_VAR 0 9
15746: PUSH
15747: LD_INT 1
15749: ST_TO_ADDR
// if i_from > i_to then
15750: LD_VAR 0 2
15754: PUSH
15755: LD_VAR 0 3
15759: GREATER
15760: IFFALSE 15786
// length := ( array - i_from ) + i_to else
15762: LD_ADDR_VAR 0 11
15766: PUSH
15767: LD_VAR 0 1
15771: PUSH
15772: LD_VAR 0 2
15776: MINUS
15777: PUSH
15778: LD_VAR 0 3
15782: PLUS
15783: ST_TO_ADDR
15784: GO 15802
// length := i_to - i_from ;
15786: LD_ADDR_VAR 0 11
15790: PUSH
15791: LD_VAR 0 3
15795: PUSH
15796: LD_VAR 0 2
15800: MINUS
15801: ST_TO_ADDR
// end else
15802: GO 15865
// begin d := - 1 ;
15804: LD_ADDR_VAR 0 9
15808: PUSH
15809: LD_INT 1
15811: NEG
15812: ST_TO_ADDR
// if i_from > i_to then
15813: LD_VAR 0 2
15817: PUSH
15818: LD_VAR 0 3
15822: GREATER
15823: IFFALSE 15843
// length := i_from - i_to else
15825: LD_ADDR_VAR 0 11
15829: PUSH
15830: LD_VAR 0 2
15834: PUSH
15835: LD_VAR 0 3
15839: MINUS
15840: ST_TO_ADDR
15841: GO 15865
// length := ( array - i_to ) + i_from ;
15843: LD_ADDR_VAR 0 11
15847: PUSH
15848: LD_VAR 0 1
15852: PUSH
15853: LD_VAR 0 3
15857: MINUS
15858: PUSH
15859: LD_VAR 0 2
15863: PLUS
15864: ST_TO_ADDR
// end ; if not length then
15865: LD_VAR 0 11
15869: NOT
15870: IFFALSE 15874
// exit ;
15872: GO 16032
// tmp := array ;
15874: LD_ADDR_VAR 0 10
15878: PUSH
15879: LD_VAR 0 1
15883: ST_TO_ADDR
// for i = 1 to length do
15884: LD_ADDR_VAR 0 6
15888: PUSH
15889: DOUBLE
15890: LD_INT 1
15892: DEC
15893: ST_TO_ADDR
15894: LD_VAR 0 11
15898: PUSH
15899: FOR_TO
15900: IFFALSE 16020
// begin for j = 1 to array do
15902: LD_ADDR_VAR 0 7
15906: PUSH
15907: DOUBLE
15908: LD_INT 1
15910: DEC
15911: ST_TO_ADDR
15912: LD_VAR 0 1
15916: PUSH
15917: FOR_TO
15918: IFFALSE 16006
// begin k := j + d ;
15920: LD_ADDR_VAR 0 8
15924: PUSH
15925: LD_VAR 0 7
15929: PUSH
15930: LD_VAR 0 9
15934: PLUS
15935: ST_TO_ADDR
// if k > array then
15936: LD_VAR 0 8
15940: PUSH
15941: LD_VAR 0 1
15945: GREATER
15946: IFFALSE 15956
// k := 1 ;
15948: LD_ADDR_VAR 0 8
15952: PUSH
15953: LD_INT 1
15955: ST_TO_ADDR
// if not k then
15956: LD_VAR 0 8
15960: NOT
15961: IFFALSE 15973
// k := array ;
15963: LD_ADDR_VAR 0 8
15967: PUSH
15968: LD_VAR 0 1
15972: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15973: LD_ADDR_VAR 0 10
15977: PUSH
15978: LD_VAR 0 10
15982: PPUSH
15983: LD_VAR 0 8
15987: PPUSH
15988: LD_VAR 0 1
15992: PUSH
15993: LD_VAR 0 7
15997: ARRAY
15998: PPUSH
15999: CALL_OW 1
16003: ST_TO_ADDR
// end ;
16004: GO 15917
16006: POP
16007: POP
// array := tmp ;
16008: LD_ADDR_VAR 0 1
16012: PUSH
16013: LD_VAR 0 10
16017: ST_TO_ADDR
// end ;
16018: GO 15899
16020: POP
16021: POP
// result := array ;
16022: LD_ADDR_VAR 0 5
16026: PUSH
16027: LD_VAR 0 1
16031: ST_TO_ADDR
// end ;
16032: LD_VAR 0 5
16036: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
16037: LD_INT 0
16039: PPUSH
16040: PPUSH
// result := 0 ;
16041: LD_ADDR_VAR 0 3
16045: PUSH
16046: LD_INT 0
16048: ST_TO_ADDR
// if not array or not value in array then
16049: LD_VAR 0 1
16053: NOT
16054: PUSH
16055: LD_VAR 0 2
16059: PUSH
16060: LD_VAR 0 1
16064: IN
16065: NOT
16066: OR
16067: IFFALSE 16071
// exit ;
16069: GO 16125
// for i = 1 to array do
16071: LD_ADDR_VAR 0 4
16075: PUSH
16076: DOUBLE
16077: LD_INT 1
16079: DEC
16080: ST_TO_ADDR
16081: LD_VAR 0 1
16085: PUSH
16086: FOR_TO
16087: IFFALSE 16123
// if value = array [ i ] then
16089: LD_VAR 0 2
16093: PUSH
16094: LD_VAR 0 1
16098: PUSH
16099: LD_VAR 0 4
16103: ARRAY
16104: EQUAL
16105: IFFALSE 16121
// begin result := i ;
16107: LD_ADDR_VAR 0 3
16111: PUSH
16112: LD_VAR 0 4
16116: ST_TO_ADDR
// exit ;
16117: POP
16118: POP
16119: GO 16125
// end ;
16121: GO 16086
16123: POP
16124: POP
// end ;
16125: LD_VAR 0 3
16129: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16130: LD_INT 0
16132: PPUSH
// vc_chassis := chassis ;
16133: LD_ADDR_OWVAR 37
16137: PUSH
16138: LD_VAR 0 1
16142: ST_TO_ADDR
// vc_engine := engine ;
16143: LD_ADDR_OWVAR 39
16147: PUSH
16148: LD_VAR 0 2
16152: ST_TO_ADDR
// vc_control := control ;
16153: LD_ADDR_OWVAR 38
16157: PUSH
16158: LD_VAR 0 3
16162: ST_TO_ADDR
// vc_weapon := weapon ;
16163: LD_ADDR_OWVAR 40
16167: PUSH
16168: LD_VAR 0 4
16172: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16173: LD_ADDR_OWVAR 41
16177: PUSH
16178: LD_VAR 0 5
16182: ST_TO_ADDR
// end ;
16183: LD_VAR 0 6
16187: RET
// export function WantPlant ( unit ) ; var task ; begin
16188: LD_INT 0
16190: PPUSH
16191: PPUSH
// result := false ;
16192: LD_ADDR_VAR 0 2
16196: PUSH
16197: LD_INT 0
16199: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16200: LD_ADDR_VAR 0 3
16204: PUSH
16205: LD_VAR 0 1
16209: PPUSH
16210: CALL_OW 437
16214: ST_TO_ADDR
// if task then
16215: LD_VAR 0 3
16219: IFFALSE 16247
// if task [ 1 ] [ 1 ] = p then
16221: LD_VAR 0 3
16225: PUSH
16226: LD_INT 1
16228: ARRAY
16229: PUSH
16230: LD_INT 1
16232: ARRAY
16233: PUSH
16234: LD_STRING p
16236: EQUAL
16237: IFFALSE 16247
// result := true ;
16239: LD_ADDR_VAR 0 2
16243: PUSH
16244: LD_INT 1
16246: ST_TO_ADDR
// end ;
16247: LD_VAR 0 2
16251: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16252: LD_INT 0
16254: PPUSH
16255: PPUSH
16256: PPUSH
16257: PPUSH
// if pos < 1 then
16258: LD_VAR 0 2
16262: PUSH
16263: LD_INT 1
16265: LESS
16266: IFFALSE 16270
// exit ;
16268: GO 16573
// if pos = 1 then
16270: LD_VAR 0 2
16274: PUSH
16275: LD_INT 1
16277: EQUAL
16278: IFFALSE 16311
// result := Replace ( arr , pos [ 1 ] , value ) else
16280: LD_ADDR_VAR 0 4
16284: PUSH
16285: LD_VAR 0 1
16289: PPUSH
16290: LD_VAR 0 2
16294: PUSH
16295: LD_INT 1
16297: ARRAY
16298: PPUSH
16299: LD_VAR 0 3
16303: PPUSH
16304: CALL_OW 1
16308: ST_TO_ADDR
16309: GO 16573
// begin tmp := arr ;
16311: LD_ADDR_VAR 0 6
16315: PUSH
16316: LD_VAR 0 1
16320: ST_TO_ADDR
// s_arr := [ tmp ] ;
16321: LD_ADDR_VAR 0 7
16325: PUSH
16326: LD_VAR 0 6
16330: PUSH
16331: EMPTY
16332: LIST
16333: ST_TO_ADDR
// for i = 1 to pos - 1 do
16334: LD_ADDR_VAR 0 5
16338: PUSH
16339: DOUBLE
16340: LD_INT 1
16342: DEC
16343: ST_TO_ADDR
16344: LD_VAR 0 2
16348: PUSH
16349: LD_INT 1
16351: MINUS
16352: PUSH
16353: FOR_TO
16354: IFFALSE 16399
// begin tmp := tmp [ pos [ i ] ] ;
16356: LD_ADDR_VAR 0 6
16360: PUSH
16361: LD_VAR 0 6
16365: PUSH
16366: LD_VAR 0 2
16370: PUSH
16371: LD_VAR 0 5
16375: ARRAY
16376: ARRAY
16377: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16378: LD_ADDR_VAR 0 7
16382: PUSH
16383: LD_VAR 0 7
16387: PUSH
16388: LD_VAR 0 6
16392: PUSH
16393: EMPTY
16394: LIST
16395: ADD
16396: ST_TO_ADDR
// end ;
16397: GO 16353
16399: POP
16400: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16401: LD_ADDR_VAR 0 6
16405: PUSH
16406: LD_VAR 0 6
16410: PPUSH
16411: LD_VAR 0 2
16415: PUSH
16416: LD_VAR 0 2
16420: ARRAY
16421: PPUSH
16422: LD_VAR 0 3
16426: PPUSH
16427: CALL_OW 1
16431: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16432: LD_ADDR_VAR 0 7
16436: PUSH
16437: LD_VAR 0 7
16441: PPUSH
16442: LD_VAR 0 7
16446: PPUSH
16447: LD_VAR 0 6
16451: PPUSH
16452: CALL_OW 1
16456: ST_TO_ADDR
// for i = s_arr downto 2 do
16457: LD_ADDR_VAR 0 5
16461: PUSH
16462: DOUBLE
16463: LD_VAR 0 7
16467: INC
16468: ST_TO_ADDR
16469: LD_INT 2
16471: PUSH
16472: FOR_DOWNTO
16473: IFFALSE 16557
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16475: LD_ADDR_VAR 0 6
16479: PUSH
16480: LD_VAR 0 7
16484: PUSH
16485: LD_VAR 0 5
16489: PUSH
16490: LD_INT 1
16492: MINUS
16493: ARRAY
16494: PPUSH
16495: LD_VAR 0 2
16499: PUSH
16500: LD_VAR 0 5
16504: PUSH
16505: LD_INT 1
16507: MINUS
16508: ARRAY
16509: PPUSH
16510: LD_VAR 0 7
16514: PUSH
16515: LD_VAR 0 5
16519: ARRAY
16520: PPUSH
16521: CALL_OW 1
16525: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16526: LD_ADDR_VAR 0 7
16530: PUSH
16531: LD_VAR 0 7
16535: PPUSH
16536: LD_VAR 0 5
16540: PUSH
16541: LD_INT 1
16543: MINUS
16544: PPUSH
16545: LD_VAR 0 6
16549: PPUSH
16550: CALL_OW 1
16554: ST_TO_ADDR
// end ;
16555: GO 16472
16557: POP
16558: POP
// result := s_arr [ 1 ] ;
16559: LD_ADDR_VAR 0 4
16563: PUSH
16564: LD_VAR 0 7
16568: PUSH
16569: LD_INT 1
16571: ARRAY
16572: ST_TO_ADDR
// end ; end ;
16573: LD_VAR 0 4
16577: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16578: LD_INT 0
16580: PPUSH
16581: PPUSH
// if not list then
16582: LD_VAR 0 1
16586: NOT
16587: IFFALSE 16591
// exit ;
16589: GO 16682
// i := list [ pos1 ] ;
16591: LD_ADDR_VAR 0 5
16595: PUSH
16596: LD_VAR 0 1
16600: PUSH
16601: LD_VAR 0 2
16605: ARRAY
16606: ST_TO_ADDR
// if not i then
16607: LD_VAR 0 5
16611: NOT
16612: IFFALSE 16616
// exit ;
16614: GO 16682
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16616: LD_ADDR_VAR 0 1
16620: PUSH
16621: LD_VAR 0 1
16625: PPUSH
16626: LD_VAR 0 2
16630: PPUSH
16631: LD_VAR 0 1
16635: PUSH
16636: LD_VAR 0 3
16640: ARRAY
16641: PPUSH
16642: CALL_OW 1
16646: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16647: LD_ADDR_VAR 0 1
16651: PUSH
16652: LD_VAR 0 1
16656: PPUSH
16657: LD_VAR 0 3
16661: PPUSH
16662: LD_VAR 0 5
16666: PPUSH
16667: CALL_OW 1
16671: ST_TO_ADDR
// result := list ;
16672: LD_ADDR_VAR 0 4
16676: PUSH
16677: LD_VAR 0 1
16681: ST_TO_ADDR
// end ;
16682: LD_VAR 0 4
16686: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16687: LD_INT 0
16689: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16690: LD_ADDR_VAR 0 5
16694: PUSH
16695: LD_VAR 0 1
16699: PPUSH
16700: CALL_OW 250
16704: PPUSH
16705: LD_VAR 0 1
16709: PPUSH
16710: CALL_OW 251
16714: PPUSH
16715: LD_VAR 0 2
16719: PPUSH
16720: LD_VAR 0 3
16724: PPUSH
16725: LD_VAR 0 4
16729: PPUSH
16730: CALL 16740 0 5
16734: ST_TO_ADDR
// end ;
16735: LD_VAR 0 5
16739: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16740: LD_INT 0
16742: PPUSH
16743: PPUSH
16744: PPUSH
16745: PPUSH
// if not list then
16746: LD_VAR 0 3
16750: NOT
16751: IFFALSE 16755
// exit ;
16753: GO 17143
// result := [ ] ;
16755: LD_ADDR_VAR 0 6
16759: PUSH
16760: EMPTY
16761: ST_TO_ADDR
// for i in list do
16762: LD_ADDR_VAR 0 7
16766: PUSH
16767: LD_VAR 0 3
16771: PUSH
16772: FOR_IN
16773: IFFALSE 16975
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16775: LD_ADDR_VAR 0 9
16779: PUSH
16780: LD_VAR 0 7
16784: PPUSH
16785: LD_VAR 0 1
16789: PPUSH
16790: LD_VAR 0 2
16794: PPUSH
16795: CALL_OW 297
16799: ST_TO_ADDR
// if not result then
16800: LD_VAR 0 6
16804: NOT
16805: IFFALSE 16831
// result := [ [ i , tmp ] ] else
16807: LD_ADDR_VAR 0 6
16811: PUSH
16812: LD_VAR 0 7
16816: PUSH
16817: LD_VAR 0 9
16821: PUSH
16822: EMPTY
16823: LIST
16824: LIST
16825: PUSH
16826: EMPTY
16827: LIST
16828: ST_TO_ADDR
16829: GO 16973
// begin if result [ result ] [ 2 ] < tmp then
16831: LD_VAR 0 6
16835: PUSH
16836: LD_VAR 0 6
16840: ARRAY
16841: PUSH
16842: LD_INT 2
16844: ARRAY
16845: PUSH
16846: LD_VAR 0 9
16850: LESS
16851: IFFALSE 16893
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16853: LD_ADDR_VAR 0 6
16857: PUSH
16858: LD_VAR 0 6
16862: PPUSH
16863: LD_VAR 0 6
16867: PUSH
16868: LD_INT 1
16870: PLUS
16871: PPUSH
16872: LD_VAR 0 7
16876: PUSH
16877: LD_VAR 0 9
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: PPUSH
16886: CALL_OW 2
16890: ST_TO_ADDR
16891: GO 16973
// for j = 1 to result do
16893: LD_ADDR_VAR 0 8
16897: PUSH
16898: DOUBLE
16899: LD_INT 1
16901: DEC
16902: ST_TO_ADDR
16903: LD_VAR 0 6
16907: PUSH
16908: FOR_TO
16909: IFFALSE 16971
// begin if tmp < result [ j ] [ 2 ] then
16911: LD_VAR 0 9
16915: PUSH
16916: LD_VAR 0 6
16920: PUSH
16921: LD_VAR 0 8
16925: ARRAY
16926: PUSH
16927: LD_INT 2
16929: ARRAY
16930: LESS
16931: IFFALSE 16969
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16933: LD_ADDR_VAR 0 6
16937: PUSH
16938: LD_VAR 0 6
16942: PPUSH
16943: LD_VAR 0 8
16947: PPUSH
16948: LD_VAR 0 7
16952: PUSH
16953: LD_VAR 0 9
16957: PUSH
16958: EMPTY
16959: LIST
16960: LIST
16961: PPUSH
16962: CALL_OW 2
16966: ST_TO_ADDR
// break ;
16967: GO 16971
// end ; end ;
16969: GO 16908
16971: POP
16972: POP
// end ; end ;
16973: GO 16772
16975: POP
16976: POP
// if result and not asc then
16977: LD_VAR 0 6
16981: PUSH
16982: LD_VAR 0 4
16986: NOT
16987: AND
16988: IFFALSE 17063
// begin tmp := result ;
16990: LD_ADDR_VAR 0 9
16994: PUSH
16995: LD_VAR 0 6
16999: ST_TO_ADDR
// for i = tmp downto 1 do
17000: LD_ADDR_VAR 0 7
17004: PUSH
17005: DOUBLE
17006: LD_VAR 0 9
17010: INC
17011: ST_TO_ADDR
17012: LD_INT 1
17014: PUSH
17015: FOR_DOWNTO
17016: IFFALSE 17061
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
17018: LD_ADDR_VAR 0 6
17022: PUSH
17023: LD_VAR 0 6
17027: PPUSH
17028: LD_VAR 0 9
17032: PUSH
17033: LD_VAR 0 7
17037: MINUS
17038: PUSH
17039: LD_INT 1
17041: PLUS
17042: PPUSH
17043: LD_VAR 0 9
17047: PUSH
17048: LD_VAR 0 7
17052: ARRAY
17053: PPUSH
17054: CALL_OW 1
17058: ST_TO_ADDR
17059: GO 17015
17061: POP
17062: POP
// end ; tmp := [ ] ;
17063: LD_ADDR_VAR 0 9
17067: PUSH
17068: EMPTY
17069: ST_TO_ADDR
// if mode then
17070: LD_VAR 0 5
17074: IFFALSE 17143
// begin for i = 1 to result do
17076: LD_ADDR_VAR 0 7
17080: PUSH
17081: DOUBLE
17082: LD_INT 1
17084: DEC
17085: ST_TO_ADDR
17086: LD_VAR 0 6
17090: PUSH
17091: FOR_TO
17092: IFFALSE 17131
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17094: LD_ADDR_VAR 0 9
17098: PUSH
17099: LD_VAR 0 9
17103: PPUSH
17104: LD_VAR 0 7
17108: PPUSH
17109: LD_VAR 0 6
17113: PUSH
17114: LD_VAR 0 7
17118: ARRAY
17119: PUSH
17120: LD_INT 1
17122: ARRAY
17123: PPUSH
17124: CALL_OW 1
17128: ST_TO_ADDR
17129: GO 17091
17131: POP
17132: POP
// result := tmp ;
17133: LD_ADDR_VAR 0 6
17137: PUSH
17138: LD_VAR 0 9
17142: ST_TO_ADDR
// end ; end ;
17143: LD_VAR 0 6
17147: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17148: LD_INT 0
17150: PPUSH
17151: PPUSH
17152: PPUSH
17153: PPUSH
17154: PPUSH
17155: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17156: LD_ADDR_VAR 0 5
17160: PUSH
17161: LD_INT 0
17163: PUSH
17164: LD_INT 0
17166: PUSH
17167: LD_INT 0
17169: PUSH
17170: EMPTY
17171: PUSH
17172: EMPTY
17173: LIST
17174: LIST
17175: LIST
17176: LIST
17177: ST_TO_ADDR
// if not x or not y then
17178: LD_VAR 0 2
17182: NOT
17183: PUSH
17184: LD_VAR 0 3
17188: NOT
17189: OR
17190: IFFALSE 17194
// exit ;
17192: GO 18844
// if not range then
17194: LD_VAR 0 4
17198: NOT
17199: IFFALSE 17209
// range := 10 ;
17201: LD_ADDR_VAR 0 4
17205: PUSH
17206: LD_INT 10
17208: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17209: LD_ADDR_VAR 0 8
17213: PUSH
17214: LD_INT 81
17216: PUSH
17217: LD_VAR 0 1
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 92
17228: PUSH
17229: LD_VAR 0 2
17233: PUSH
17234: LD_VAR 0 3
17238: PUSH
17239: LD_VAR 0 4
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: LIST
17248: LIST
17249: PUSH
17250: LD_INT 3
17252: PUSH
17253: LD_INT 21
17255: PUSH
17256: LD_INT 3
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: PUSH
17263: EMPTY
17264: LIST
17265: LIST
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: LIST
17271: PPUSH
17272: CALL_OW 69
17276: ST_TO_ADDR
// if not tmp then
17277: LD_VAR 0 8
17281: NOT
17282: IFFALSE 17286
// exit ;
17284: GO 18844
// for i in tmp do
17286: LD_ADDR_VAR 0 6
17290: PUSH
17291: LD_VAR 0 8
17295: PUSH
17296: FOR_IN
17297: IFFALSE 18819
// begin points := [ 0 , 0 , 0 ] ;
17299: LD_ADDR_VAR 0 9
17303: PUSH
17304: LD_INT 0
17306: PUSH
17307: LD_INT 0
17309: PUSH
17310: LD_INT 0
17312: PUSH
17313: EMPTY
17314: LIST
17315: LIST
17316: LIST
17317: ST_TO_ADDR
// bpoints := 1 ;
17318: LD_ADDR_VAR 0 10
17322: PUSH
17323: LD_INT 1
17325: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17326: LD_VAR 0 6
17330: PPUSH
17331: CALL_OW 247
17335: PUSH
17336: LD_INT 1
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17922
17344: POP
// begin if GetClass ( i ) = 1 then
17345: LD_VAR 0 6
17349: PPUSH
17350: CALL_OW 257
17354: PUSH
17355: LD_INT 1
17357: EQUAL
17358: IFFALSE 17379
// points := [ 10 , 5 , 3 ] ;
17360: LD_ADDR_VAR 0 9
17364: PUSH
17365: LD_INT 10
17367: PUSH
17368: LD_INT 5
17370: PUSH
17371: LD_INT 3
17373: PUSH
17374: EMPTY
17375: LIST
17376: LIST
17377: LIST
17378: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17379: LD_VAR 0 6
17383: PPUSH
17384: CALL_OW 257
17388: PUSH
17389: LD_INT 2
17391: PUSH
17392: LD_INT 3
17394: PUSH
17395: LD_INT 4
17397: PUSH
17398: EMPTY
17399: LIST
17400: LIST
17401: LIST
17402: IN
17403: IFFALSE 17424
// points := [ 3 , 2 , 1 ] ;
17405: LD_ADDR_VAR 0 9
17409: PUSH
17410: LD_INT 3
17412: PUSH
17413: LD_INT 2
17415: PUSH
17416: LD_INT 1
17418: PUSH
17419: EMPTY
17420: LIST
17421: LIST
17422: LIST
17423: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17424: LD_VAR 0 6
17428: PPUSH
17429: CALL_OW 257
17433: PUSH
17434: LD_INT 5
17436: EQUAL
17437: IFFALSE 17458
// points := [ 130 , 5 , 2 ] ;
17439: LD_ADDR_VAR 0 9
17443: PUSH
17444: LD_INT 130
17446: PUSH
17447: LD_INT 5
17449: PUSH
17450: LD_INT 2
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: LIST
17457: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17458: LD_VAR 0 6
17462: PPUSH
17463: CALL_OW 257
17467: PUSH
17468: LD_INT 8
17470: EQUAL
17471: IFFALSE 17492
// points := [ 35 , 35 , 30 ] ;
17473: LD_ADDR_VAR 0 9
17477: PUSH
17478: LD_INT 35
17480: PUSH
17481: LD_INT 35
17483: PUSH
17484: LD_INT 30
17486: PUSH
17487: EMPTY
17488: LIST
17489: LIST
17490: LIST
17491: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17492: LD_VAR 0 6
17496: PPUSH
17497: CALL_OW 257
17501: PUSH
17502: LD_INT 9
17504: EQUAL
17505: IFFALSE 17526
// points := [ 20 , 55 , 40 ] ;
17507: LD_ADDR_VAR 0 9
17511: PUSH
17512: LD_INT 20
17514: PUSH
17515: LD_INT 55
17517: PUSH
17518: LD_INT 40
17520: PUSH
17521: EMPTY
17522: LIST
17523: LIST
17524: LIST
17525: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17526: LD_VAR 0 6
17530: PPUSH
17531: CALL_OW 257
17535: PUSH
17536: LD_INT 12
17538: PUSH
17539: LD_INT 16
17541: PUSH
17542: EMPTY
17543: LIST
17544: LIST
17545: IN
17546: IFFALSE 17567
// points := [ 5 , 3 , 2 ] ;
17548: LD_ADDR_VAR 0 9
17552: PUSH
17553: LD_INT 5
17555: PUSH
17556: LD_INT 3
17558: PUSH
17559: LD_INT 2
17561: PUSH
17562: EMPTY
17563: LIST
17564: LIST
17565: LIST
17566: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17567: LD_VAR 0 6
17571: PPUSH
17572: CALL_OW 257
17576: PUSH
17577: LD_INT 17
17579: EQUAL
17580: IFFALSE 17601
// points := [ 100 , 50 , 75 ] ;
17582: LD_ADDR_VAR 0 9
17586: PUSH
17587: LD_INT 100
17589: PUSH
17590: LD_INT 50
17592: PUSH
17593: LD_INT 75
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: LIST
17600: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17601: LD_VAR 0 6
17605: PPUSH
17606: CALL_OW 257
17610: PUSH
17611: LD_INT 15
17613: EQUAL
17614: IFFALSE 17635
// points := [ 10 , 5 , 3 ] ;
17616: LD_ADDR_VAR 0 9
17620: PUSH
17621: LD_INT 10
17623: PUSH
17624: LD_INT 5
17626: PUSH
17627: LD_INT 3
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: LIST
17634: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17635: LD_VAR 0 6
17639: PPUSH
17640: CALL_OW 257
17644: PUSH
17645: LD_INT 14
17647: EQUAL
17648: IFFALSE 17669
// points := [ 10 , 0 , 0 ] ;
17650: LD_ADDR_VAR 0 9
17654: PUSH
17655: LD_INT 10
17657: PUSH
17658: LD_INT 0
17660: PUSH
17661: LD_INT 0
17663: PUSH
17664: EMPTY
17665: LIST
17666: LIST
17667: LIST
17668: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17669: LD_VAR 0 6
17673: PPUSH
17674: CALL_OW 257
17678: PUSH
17679: LD_INT 11
17681: EQUAL
17682: IFFALSE 17703
// points := [ 30 , 10 , 5 ] ;
17684: LD_ADDR_VAR 0 9
17688: PUSH
17689: LD_INT 30
17691: PUSH
17692: LD_INT 10
17694: PUSH
17695: LD_INT 5
17697: PUSH
17698: EMPTY
17699: LIST
17700: LIST
17701: LIST
17702: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_INT 5
17710: PPUSH
17711: CALL_OW 321
17715: PUSH
17716: LD_INT 2
17718: EQUAL
17719: IFFALSE 17736
// bpoints := bpoints * 1.8 ;
17721: LD_ADDR_VAR 0 10
17725: PUSH
17726: LD_VAR 0 10
17730: PUSH
17731: LD_REAL  1.80000000000000E+0000
17734: MUL
17735: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17736: LD_VAR 0 6
17740: PPUSH
17741: CALL_OW 257
17745: PUSH
17746: LD_INT 1
17748: PUSH
17749: LD_INT 2
17751: PUSH
17752: LD_INT 3
17754: PUSH
17755: LD_INT 4
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: IN
17764: PUSH
17765: LD_VAR 0 1
17769: PPUSH
17770: LD_INT 51
17772: PPUSH
17773: CALL_OW 321
17777: PUSH
17778: LD_INT 2
17780: EQUAL
17781: AND
17782: IFFALSE 17799
// bpoints := bpoints * 1.2 ;
17784: LD_ADDR_VAR 0 10
17788: PUSH
17789: LD_VAR 0 10
17793: PUSH
17794: LD_REAL  1.20000000000000E+0000
17797: MUL
17798: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17799: LD_VAR 0 6
17803: PPUSH
17804: CALL_OW 257
17808: PUSH
17809: LD_INT 5
17811: PUSH
17812: LD_INT 7
17814: PUSH
17815: LD_INT 9
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: LIST
17822: IN
17823: PUSH
17824: LD_VAR 0 1
17828: PPUSH
17829: LD_INT 52
17831: PPUSH
17832: CALL_OW 321
17836: PUSH
17837: LD_INT 2
17839: EQUAL
17840: AND
17841: IFFALSE 17858
// bpoints := bpoints * 1.5 ;
17843: LD_ADDR_VAR 0 10
17847: PUSH
17848: LD_VAR 0 10
17852: PUSH
17853: LD_REAL  1.50000000000000E+0000
17856: MUL
17857: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17858: LD_VAR 0 1
17862: PPUSH
17863: LD_INT 66
17865: PPUSH
17866: CALL_OW 321
17870: PUSH
17871: LD_INT 2
17873: EQUAL
17874: IFFALSE 17891
// bpoints := bpoints * 1.1 ;
17876: LD_ADDR_VAR 0 10
17880: PUSH
17881: LD_VAR 0 10
17885: PUSH
17886: LD_REAL  1.10000000000000E+0000
17889: MUL
17890: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17891: LD_ADDR_VAR 0 10
17895: PUSH
17896: LD_VAR 0 10
17900: PUSH
17901: LD_VAR 0 6
17905: PPUSH
17906: LD_INT 1
17908: PPUSH
17909: CALL_OW 259
17913: PUSH
17914: LD_REAL  1.15000000000000E+0000
17917: MUL
17918: MUL
17919: ST_TO_ADDR
// end ; unit_vehicle :
17920: GO 18748
17922: LD_INT 2
17924: DOUBLE
17925: EQUAL
17926: IFTRUE 17930
17928: GO 18736
17930: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17931: LD_VAR 0 6
17935: PPUSH
17936: CALL_OW 264
17940: PUSH
17941: LD_INT 2
17943: PUSH
17944: LD_INT 42
17946: PUSH
17947: LD_INT 24
17949: PUSH
17950: EMPTY
17951: LIST
17952: LIST
17953: LIST
17954: IN
17955: IFFALSE 17976
// points := [ 25 , 5 , 3 ] ;
17957: LD_ADDR_VAR 0 9
17961: PUSH
17962: LD_INT 25
17964: PUSH
17965: LD_INT 5
17967: PUSH
17968: LD_INT 3
17970: PUSH
17971: EMPTY
17972: LIST
17973: LIST
17974: LIST
17975: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17976: LD_VAR 0 6
17980: PPUSH
17981: CALL_OW 264
17985: PUSH
17986: LD_INT 4
17988: PUSH
17989: LD_INT 43
17991: PUSH
17992: LD_INT 25
17994: PUSH
17995: EMPTY
17996: LIST
17997: LIST
17998: LIST
17999: IN
18000: IFFALSE 18021
// points := [ 40 , 15 , 5 ] ;
18002: LD_ADDR_VAR 0 9
18006: PUSH
18007: LD_INT 40
18009: PUSH
18010: LD_INT 15
18012: PUSH
18013: LD_INT 5
18015: PUSH
18016: EMPTY
18017: LIST
18018: LIST
18019: LIST
18020: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
18021: LD_VAR 0 6
18025: PPUSH
18026: CALL_OW 264
18030: PUSH
18031: LD_INT 3
18033: PUSH
18034: LD_INT 23
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: IN
18041: IFFALSE 18062
// points := [ 7 , 25 , 8 ] ;
18043: LD_ADDR_VAR 0 9
18047: PUSH
18048: LD_INT 7
18050: PUSH
18051: LD_INT 25
18053: PUSH
18054: LD_INT 8
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: LIST
18061: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
18062: LD_VAR 0 6
18066: PPUSH
18067: CALL_OW 264
18071: PUSH
18072: LD_INT 5
18074: PUSH
18075: LD_INT 27
18077: PUSH
18078: LD_INT 44
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: LIST
18085: IN
18086: IFFALSE 18107
// points := [ 14 , 50 , 16 ] ;
18088: LD_ADDR_VAR 0 9
18092: PUSH
18093: LD_INT 14
18095: PUSH
18096: LD_INT 50
18098: PUSH
18099: LD_INT 16
18101: PUSH
18102: EMPTY
18103: LIST
18104: LIST
18105: LIST
18106: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18107: LD_VAR 0 6
18111: PPUSH
18112: CALL_OW 264
18116: PUSH
18117: LD_INT 6
18119: PUSH
18120: LD_INT 46
18122: PUSH
18123: EMPTY
18124: LIST
18125: LIST
18126: IN
18127: IFFALSE 18148
// points := [ 32 , 120 , 70 ] ;
18129: LD_ADDR_VAR 0 9
18133: PUSH
18134: LD_INT 32
18136: PUSH
18137: LD_INT 120
18139: PUSH
18140: LD_INT 70
18142: PUSH
18143: EMPTY
18144: LIST
18145: LIST
18146: LIST
18147: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18148: LD_VAR 0 6
18152: PPUSH
18153: CALL_OW 264
18157: PUSH
18158: LD_INT 7
18160: PUSH
18161: LD_INT 28
18163: PUSH
18164: LD_INT 45
18166: PUSH
18167: LD_INT 92
18169: PUSH
18170: EMPTY
18171: LIST
18172: LIST
18173: LIST
18174: LIST
18175: IN
18176: IFFALSE 18197
// points := [ 35 , 20 , 45 ] ;
18178: LD_ADDR_VAR 0 9
18182: PUSH
18183: LD_INT 35
18185: PUSH
18186: LD_INT 20
18188: PUSH
18189: LD_INT 45
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: LIST
18196: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18197: LD_VAR 0 6
18201: PPUSH
18202: CALL_OW 264
18206: PUSH
18207: LD_INT 47
18209: PUSH
18210: EMPTY
18211: LIST
18212: IN
18213: IFFALSE 18234
// points := [ 67 , 45 , 75 ] ;
18215: LD_ADDR_VAR 0 9
18219: PUSH
18220: LD_INT 67
18222: PUSH
18223: LD_INT 45
18225: PUSH
18226: LD_INT 75
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: LIST
18233: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18234: LD_VAR 0 6
18238: PPUSH
18239: CALL_OW 264
18243: PUSH
18244: LD_INT 26
18246: PUSH
18247: EMPTY
18248: LIST
18249: IN
18250: IFFALSE 18271
// points := [ 120 , 30 , 80 ] ;
18252: LD_ADDR_VAR 0 9
18256: PUSH
18257: LD_INT 120
18259: PUSH
18260: LD_INT 30
18262: PUSH
18263: LD_INT 80
18265: PUSH
18266: EMPTY
18267: LIST
18268: LIST
18269: LIST
18270: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18271: LD_VAR 0 6
18275: PPUSH
18276: CALL_OW 264
18280: PUSH
18281: LD_INT 22
18283: PUSH
18284: EMPTY
18285: LIST
18286: IN
18287: IFFALSE 18308
// points := [ 40 , 1 , 1 ] ;
18289: LD_ADDR_VAR 0 9
18293: PUSH
18294: LD_INT 40
18296: PUSH
18297: LD_INT 1
18299: PUSH
18300: LD_INT 1
18302: PUSH
18303: EMPTY
18304: LIST
18305: LIST
18306: LIST
18307: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18308: LD_VAR 0 6
18312: PPUSH
18313: CALL_OW 264
18317: PUSH
18318: LD_INT 29
18320: PUSH
18321: EMPTY
18322: LIST
18323: IN
18324: IFFALSE 18345
// points := [ 70 , 200 , 400 ] ;
18326: LD_ADDR_VAR 0 9
18330: PUSH
18331: LD_INT 70
18333: PUSH
18334: LD_INT 200
18336: PUSH
18337: LD_INT 400
18339: PUSH
18340: EMPTY
18341: LIST
18342: LIST
18343: LIST
18344: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18345: LD_VAR 0 6
18349: PPUSH
18350: CALL_OW 264
18354: PUSH
18355: LD_INT 14
18357: PUSH
18358: LD_INT 53
18360: PUSH
18361: EMPTY
18362: LIST
18363: LIST
18364: IN
18365: IFFALSE 18386
// points := [ 40 , 10 , 20 ] ;
18367: LD_ADDR_VAR 0 9
18371: PUSH
18372: LD_INT 40
18374: PUSH
18375: LD_INT 10
18377: PUSH
18378: LD_INT 20
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: LIST
18385: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18386: LD_VAR 0 6
18390: PPUSH
18391: CALL_OW 264
18395: PUSH
18396: LD_INT 9
18398: PUSH
18399: EMPTY
18400: LIST
18401: IN
18402: IFFALSE 18423
// points := [ 5 , 70 , 20 ] ;
18404: LD_ADDR_VAR 0 9
18408: PUSH
18409: LD_INT 5
18411: PUSH
18412: LD_INT 70
18414: PUSH
18415: LD_INT 20
18417: PUSH
18418: EMPTY
18419: LIST
18420: LIST
18421: LIST
18422: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18423: LD_VAR 0 6
18427: PPUSH
18428: CALL_OW 264
18432: PUSH
18433: LD_INT 10
18435: PUSH
18436: EMPTY
18437: LIST
18438: IN
18439: IFFALSE 18460
// points := [ 35 , 110 , 70 ] ;
18441: LD_ADDR_VAR 0 9
18445: PUSH
18446: LD_INT 35
18448: PUSH
18449: LD_INT 110
18451: PUSH
18452: LD_INT 70
18454: PUSH
18455: EMPTY
18456: LIST
18457: LIST
18458: LIST
18459: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18460: LD_VAR 0 6
18464: PPUSH
18465: CALL_OW 265
18469: PUSH
18470: LD_INT 25
18472: EQUAL
18473: IFFALSE 18494
// points := [ 80 , 65 , 100 ] ;
18475: LD_ADDR_VAR 0 9
18479: PUSH
18480: LD_INT 80
18482: PUSH
18483: LD_INT 65
18485: PUSH
18486: LD_INT 100
18488: PUSH
18489: EMPTY
18490: LIST
18491: LIST
18492: LIST
18493: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18494: LD_VAR 0 6
18498: PPUSH
18499: CALL_OW 263
18503: PUSH
18504: LD_INT 1
18506: EQUAL
18507: IFFALSE 18542
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18509: LD_ADDR_VAR 0 10
18513: PUSH
18514: LD_VAR 0 10
18518: PUSH
18519: LD_VAR 0 6
18523: PPUSH
18524: CALL_OW 311
18528: PPUSH
18529: LD_INT 3
18531: PPUSH
18532: CALL_OW 259
18536: PUSH
18537: LD_INT 4
18539: MUL
18540: MUL
18541: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18542: LD_VAR 0 6
18546: PPUSH
18547: CALL_OW 263
18551: PUSH
18552: LD_INT 2
18554: EQUAL
18555: IFFALSE 18606
// begin j := IsControledBy ( i ) ;
18557: LD_ADDR_VAR 0 7
18561: PUSH
18562: LD_VAR 0 6
18566: PPUSH
18567: CALL_OW 312
18571: ST_TO_ADDR
// if j then
18572: LD_VAR 0 7
18576: IFFALSE 18606
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18578: LD_ADDR_VAR 0 10
18582: PUSH
18583: LD_VAR 0 10
18587: PUSH
18588: LD_VAR 0 7
18592: PPUSH
18593: LD_INT 3
18595: PPUSH
18596: CALL_OW 259
18600: PUSH
18601: LD_INT 3
18603: MUL
18604: MUL
18605: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18606: LD_VAR 0 6
18610: PPUSH
18611: CALL_OW 264
18615: PUSH
18616: LD_INT 5
18618: PUSH
18619: LD_INT 6
18621: PUSH
18622: LD_INT 46
18624: PUSH
18625: LD_INT 44
18627: PUSH
18628: LD_INT 47
18630: PUSH
18631: LD_INT 45
18633: PUSH
18634: LD_INT 28
18636: PUSH
18637: LD_INT 7
18639: PUSH
18640: LD_INT 27
18642: PUSH
18643: LD_INT 29
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: LIST
18653: LIST
18654: LIST
18655: LIST
18656: LIST
18657: IN
18658: PUSH
18659: LD_VAR 0 1
18663: PPUSH
18664: LD_INT 52
18666: PPUSH
18667: CALL_OW 321
18671: PUSH
18672: LD_INT 2
18674: EQUAL
18675: AND
18676: IFFALSE 18693
// bpoints := bpoints * 1.2 ;
18678: LD_ADDR_VAR 0 10
18682: PUSH
18683: LD_VAR 0 10
18687: PUSH
18688: LD_REAL  1.20000000000000E+0000
18691: MUL
18692: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18693: LD_VAR 0 6
18697: PPUSH
18698: CALL_OW 264
18702: PUSH
18703: LD_INT 6
18705: PUSH
18706: LD_INT 46
18708: PUSH
18709: LD_INT 47
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: LIST
18716: IN
18717: IFFALSE 18734
// bpoints := bpoints * 1.2 ;
18719: LD_ADDR_VAR 0 10
18723: PUSH
18724: LD_VAR 0 10
18728: PUSH
18729: LD_REAL  1.20000000000000E+0000
18732: MUL
18733: ST_TO_ADDR
// end ; unit_building :
18734: GO 18748
18736: LD_INT 3
18738: DOUBLE
18739: EQUAL
18740: IFTRUE 18744
18742: GO 18747
18744: POP
// ; end ;
18745: GO 18748
18747: POP
// for j = 1 to 3 do
18748: LD_ADDR_VAR 0 7
18752: PUSH
18753: DOUBLE
18754: LD_INT 1
18756: DEC
18757: ST_TO_ADDR
18758: LD_INT 3
18760: PUSH
18761: FOR_TO
18762: IFFALSE 18815
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18764: LD_ADDR_VAR 0 5
18768: PUSH
18769: LD_VAR 0 5
18773: PPUSH
18774: LD_VAR 0 7
18778: PPUSH
18779: LD_VAR 0 5
18783: PUSH
18784: LD_VAR 0 7
18788: ARRAY
18789: PUSH
18790: LD_VAR 0 9
18794: PUSH
18795: LD_VAR 0 7
18799: ARRAY
18800: PUSH
18801: LD_VAR 0 10
18805: MUL
18806: PLUS
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
18813: GO 18761
18815: POP
18816: POP
// end ;
18817: GO 17296
18819: POP
18820: POP
// result := Replace ( result , 4 , tmp ) ;
18821: LD_ADDR_VAR 0 5
18825: PUSH
18826: LD_VAR 0 5
18830: PPUSH
18831: LD_INT 4
18833: PPUSH
18834: LD_VAR 0 8
18838: PPUSH
18839: CALL_OW 1
18843: ST_TO_ADDR
// end ;
18844: LD_VAR 0 5
18848: RET
// export function DangerAtRange ( unit , range ) ; begin
18849: LD_INT 0
18851: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18852: LD_ADDR_VAR 0 3
18856: PUSH
18857: LD_VAR 0 1
18861: PPUSH
18862: CALL_OW 255
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: CALL_OW 250
18876: PPUSH
18877: LD_VAR 0 1
18881: PPUSH
18882: CALL_OW 251
18886: PPUSH
18887: LD_VAR 0 2
18891: PPUSH
18892: CALL 17148 0 4
18896: ST_TO_ADDR
// end ;
18897: LD_VAR 0 3
18901: RET
// export function DangerInArea ( side , area ) ; begin
18902: LD_INT 0
18904: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18905: LD_ADDR_VAR 0 3
18909: PUSH
18910: LD_VAR 0 2
18914: PPUSH
18915: LD_INT 81
18917: PUSH
18918: LD_VAR 0 1
18922: PUSH
18923: EMPTY
18924: LIST
18925: LIST
18926: PPUSH
18927: CALL_OW 70
18931: ST_TO_ADDR
// end ;
18932: LD_VAR 0 3
18936: RET
// export function IsExtension ( b ) ; begin
18937: LD_INT 0
18939: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18940: LD_ADDR_VAR 0 2
18944: PUSH
18945: LD_VAR 0 1
18949: PUSH
18950: LD_INT 23
18952: PUSH
18953: LD_INT 20
18955: PUSH
18956: LD_INT 22
18958: PUSH
18959: LD_INT 17
18961: PUSH
18962: LD_INT 24
18964: PUSH
18965: LD_INT 21
18967: PUSH
18968: LD_INT 19
18970: PUSH
18971: LD_INT 16
18973: PUSH
18974: LD_INT 25
18976: PUSH
18977: LD_INT 18
18979: PUSH
18980: EMPTY
18981: LIST
18982: LIST
18983: LIST
18984: LIST
18985: LIST
18986: LIST
18987: LIST
18988: LIST
18989: LIST
18990: LIST
18991: IN
18992: ST_TO_ADDR
// end ;
18993: LD_VAR 0 2
18997: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18998: LD_INT 0
19000: PPUSH
19001: PPUSH
19002: PPUSH
// result := [ ] ;
19003: LD_ADDR_VAR 0 4
19007: PUSH
19008: EMPTY
19009: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
19010: LD_ADDR_VAR 0 5
19014: PUSH
19015: LD_VAR 0 2
19019: PPUSH
19020: LD_INT 21
19022: PUSH
19023: LD_INT 3
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: PPUSH
19030: CALL_OW 70
19034: ST_TO_ADDR
// if not tmp then
19035: LD_VAR 0 5
19039: NOT
19040: IFFALSE 19044
// exit ;
19042: GO 19108
// if checkLink then
19044: LD_VAR 0 3
19048: IFFALSE 19098
// begin for i in tmp do
19050: LD_ADDR_VAR 0 6
19054: PUSH
19055: LD_VAR 0 5
19059: PUSH
19060: FOR_IN
19061: IFFALSE 19096
// if GetBase ( i ) <> base then
19063: LD_VAR 0 6
19067: PPUSH
19068: CALL_OW 274
19072: PUSH
19073: LD_VAR 0 1
19077: NONEQUAL
19078: IFFALSE 19094
// ComLinkToBase ( base , i ) ;
19080: LD_VAR 0 1
19084: PPUSH
19085: LD_VAR 0 6
19089: PPUSH
19090: CALL_OW 169
19094: GO 19060
19096: POP
19097: POP
// end ; result := tmp ;
19098: LD_ADDR_VAR 0 4
19102: PUSH
19103: LD_VAR 0 5
19107: ST_TO_ADDR
// end ;
19108: LD_VAR 0 4
19112: RET
// export function ComComplete ( units , b ) ; var i ; begin
19113: LD_INT 0
19115: PPUSH
19116: PPUSH
// if not units then
19117: LD_VAR 0 1
19121: NOT
19122: IFFALSE 19126
// exit ;
19124: GO 19216
// for i in units do
19126: LD_ADDR_VAR 0 4
19130: PUSH
19131: LD_VAR 0 1
19135: PUSH
19136: FOR_IN
19137: IFFALSE 19214
// if BuildingStatus ( b ) = bs_build then
19139: LD_VAR 0 2
19143: PPUSH
19144: CALL_OW 461
19148: PUSH
19149: LD_INT 1
19151: EQUAL
19152: IFFALSE 19212
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19154: LD_VAR 0 4
19158: PPUSH
19159: LD_STRING h
19161: PUSH
19162: LD_VAR 0 2
19166: PPUSH
19167: CALL_OW 250
19171: PUSH
19172: LD_VAR 0 2
19176: PPUSH
19177: CALL_OW 251
19181: PUSH
19182: LD_VAR 0 2
19186: PUSH
19187: LD_INT 0
19189: PUSH
19190: LD_INT 0
19192: PUSH
19193: LD_INT 0
19195: PUSH
19196: EMPTY
19197: LIST
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: PUSH
19205: EMPTY
19206: LIST
19207: PPUSH
19208: CALL_OW 446
19212: GO 19136
19214: POP
19215: POP
// end ;
19216: LD_VAR 0 3
19220: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19221: LD_INT 0
19223: PPUSH
19224: PPUSH
19225: PPUSH
19226: PPUSH
19227: PPUSH
19228: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19229: LD_VAR 0 1
19233: NOT
19234: PUSH
19235: LD_VAR 0 1
19239: PPUSH
19240: CALL_OW 263
19244: PUSH
19245: LD_INT 2
19247: NONEQUAL
19248: OR
19249: IFFALSE 19253
// exit ;
19251: GO 19569
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19253: LD_ADDR_VAR 0 6
19257: PUSH
19258: LD_INT 22
19260: PUSH
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 255
19270: PUSH
19271: EMPTY
19272: LIST
19273: LIST
19274: PUSH
19275: LD_INT 2
19277: PUSH
19278: LD_INT 30
19280: PUSH
19281: LD_INT 36
19283: PUSH
19284: EMPTY
19285: LIST
19286: LIST
19287: PUSH
19288: LD_INT 34
19290: PUSH
19291: LD_INT 31
19293: PUSH
19294: EMPTY
19295: LIST
19296: LIST
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: LIST
19302: PUSH
19303: EMPTY
19304: LIST
19305: LIST
19306: PPUSH
19307: CALL_OW 69
19311: ST_TO_ADDR
// if not tmp then
19312: LD_VAR 0 6
19316: NOT
19317: IFFALSE 19321
// exit ;
19319: GO 19569
// result := [ ] ;
19321: LD_ADDR_VAR 0 2
19325: PUSH
19326: EMPTY
19327: ST_TO_ADDR
// for i in tmp do
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_VAR 0 6
19337: PUSH
19338: FOR_IN
19339: IFFALSE 19410
// begin t := UnitsInside ( i ) ;
19341: LD_ADDR_VAR 0 4
19345: PUSH
19346: LD_VAR 0 3
19350: PPUSH
19351: CALL_OW 313
19355: ST_TO_ADDR
// if t then
19356: LD_VAR 0 4
19360: IFFALSE 19408
// for j in t do
19362: LD_ADDR_VAR 0 7
19366: PUSH
19367: LD_VAR 0 4
19371: PUSH
19372: FOR_IN
19373: IFFALSE 19406
// result := Replace ( result , result + 1 , j ) ;
19375: LD_ADDR_VAR 0 2
19379: PUSH
19380: LD_VAR 0 2
19384: PPUSH
19385: LD_VAR 0 2
19389: PUSH
19390: LD_INT 1
19392: PLUS
19393: PPUSH
19394: LD_VAR 0 7
19398: PPUSH
19399: CALL_OW 1
19403: ST_TO_ADDR
19404: GO 19372
19406: POP
19407: POP
// end ;
19408: GO 19338
19410: POP
19411: POP
// if not result then
19412: LD_VAR 0 2
19416: NOT
19417: IFFALSE 19421
// exit ;
19419: GO 19569
// mech := result [ 1 ] ;
19421: LD_ADDR_VAR 0 5
19425: PUSH
19426: LD_VAR 0 2
19430: PUSH
19431: LD_INT 1
19433: ARRAY
19434: ST_TO_ADDR
// if result > 1 then
19435: LD_VAR 0 2
19439: PUSH
19440: LD_INT 1
19442: GREATER
19443: IFFALSE 19555
// begin for i = 2 to result do
19445: LD_ADDR_VAR 0 3
19449: PUSH
19450: DOUBLE
19451: LD_INT 2
19453: DEC
19454: ST_TO_ADDR
19455: LD_VAR 0 2
19459: PUSH
19460: FOR_TO
19461: IFFALSE 19553
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19463: LD_ADDR_VAR 0 4
19467: PUSH
19468: LD_VAR 0 2
19472: PUSH
19473: LD_VAR 0 3
19477: ARRAY
19478: PPUSH
19479: LD_INT 3
19481: PPUSH
19482: CALL_OW 259
19486: PUSH
19487: LD_VAR 0 2
19491: PUSH
19492: LD_VAR 0 3
19496: ARRAY
19497: PPUSH
19498: CALL_OW 432
19502: MINUS
19503: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19504: LD_VAR 0 4
19508: PUSH
19509: LD_VAR 0 5
19513: PPUSH
19514: LD_INT 3
19516: PPUSH
19517: CALL_OW 259
19521: PUSH
19522: LD_VAR 0 5
19526: PPUSH
19527: CALL_OW 432
19531: MINUS
19532: GREATEREQUAL
19533: IFFALSE 19551
// mech := result [ i ] ;
19535: LD_ADDR_VAR 0 5
19539: PUSH
19540: LD_VAR 0 2
19544: PUSH
19545: LD_VAR 0 3
19549: ARRAY
19550: ST_TO_ADDR
// end ;
19551: GO 19460
19553: POP
19554: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19555: LD_VAR 0 1
19559: PPUSH
19560: LD_VAR 0 5
19564: PPUSH
19565: CALL_OW 135
// end ;
19569: LD_VAR 0 2
19573: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19574: LD_INT 0
19576: PPUSH
19577: PPUSH
19578: PPUSH
19579: PPUSH
19580: PPUSH
19581: PPUSH
19582: PPUSH
19583: PPUSH
19584: PPUSH
19585: PPUSH
19586: PPUSH
19587: PPUSH
19588: PPUSH
// result := [ ] ;
19589: LD_ADDR_VAR 0 7
19593: PUSH
19594: EMPTY
19595: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19596: LD_VAR 0 1
19600: PPUSH
19601: CALL_OW 266
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: LD_INT 1
19611: PUSH
19612: EMPTY
19613: LIST
19614: LIST
19615: IN
19616: NOT
19617: IFFALSE 19621
// exit ;
19619: GO 21255
// if name then
19621: LD_VAR 0 3
19625: IFFALSE 19641
// SetBName ( base_dep , name ) ;
19627: LD_VAR 0 1
19631: PPUSH
19632: LD_VAR 0 3
19636: PPUSH
19637: CALL_OW 500
// base := GetBase ( base_dep ) ;
19641: LD_ADDR_VAR 0 15
19645: PUSH
19646: LD_VAR 0 1
19650: PPUSH
19651: CALL_OW 274
19655: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19656: LD_ADDR_VAR 0 16
19660: PUSH
19661: LD_VAR 0 1
19665: PPUSH
19666: CALL_OW 255
19670: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19671: LD_ADDR_VAR 0 17
19675: PUSH
19676: LD_VAR 0 1
19680: PPUSH
19681: CALL_OW 248
19685: ST_TO_ADDR
// if sources then
19686: LD_VAR 0 5
19690: IFFALSE 19737
// for i = 1 to 3 do
19692: LD_ADDR_VAR 0 8
19696: PUSH
19697: DOUBLE
19698: LD_INT 1
19700: DEC
19701: ST_TO_ADDR
19702: LD_INT 3
19704: PUSH
19705: FOR_TO
19706: IFFALSE 19735
// AddResourceType ( base , i , sources [ i ] ) ;
19708: LD_VAR 0 15
19712: PPUSH
19713: LD_VAR 0 8
19717: PPUSH
19718: LD_VAR 0 5
19722: PUSH
19723: LD_VAR 0 8
19727: ARRAY
19728: PPUSH
19729: CALL_OW 276
19733: GO 19705
19735: POP
19736: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19737: LD_ADDR_VAR 0 18
19741: PUSH
19742: LD_VAR 0 15
19746: PPUSH
19747: LD_VAR 0 2
19751: PPUSH
19752: LD_INT 1
19754: PPUSH
19755: CALL 18998 0 3
19759: ST_TO_ADDR
// InitHc ;
19760: CALL_OW 19
// InitUc ;
19764: CALL_OW 18
// uc_side := side ;
19768: LD_ADDR_OWVAR 20
19772: PUSH
19773: LD_VAR 0 16
19777: ST_TO_ADDR
// uc_nation := nation ;
19778: LD_ADDR_OWVAR 21
19782: PUSH
19783: LD_VAR 0 17
19787: ST_TO_ADDR
// if buildings then
19788: LD_VAR 0 18
19792: IFFALSE 21114
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19794: LD_ADDR_VAR 0 19
19798: PUSH
19799: LD_VAR 0 18
19803: PPUSH
19804: LD_INT 2
19806: PUSH
19807: LD_INT 30
19809: PUSH
19810: LD_INT 29
19812: PUSH
19813: EMPTY
19814: LIST
19815: LIST
19816: PUSH
19817: LD_INT 30
19819: PUSH
19820: LD_INT 30
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: LIST
19831: PPUSH
19832: CALL_OW 72
19836: ST_TO_ADDR
// if tmp then
19837: LD_VAR 0 19
19841: IFFALSE 19889
// for i in tmp do
19843: LD_ADDR_VAR 0 8
19847: PUSH
19848: LD_VAR 0 19
19852: PUSH
19853: FOR_IN
19854: IFFALSE 19887
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19856: LD_VAR 0 8
19860: PPUSH
19861: CALL_OW 250
19865: PPUSH
19866: LD_VAR 0 8
19870: PPUSH
19871: CALL_OW 251
19875: PPUSH
19876: LD_VAR 0 16
19880: PPUSH
19881: CALL_OW 441
19885: GO 19853
19887: POP
19888: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19889: LD_VAR 0 18
19893: PPUSH
19894: LD_INT 2
19896: PUSH
19897: LD_INT 30
19899: PUSH
19900: LD_INT 32
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: PUSH
19907: LD_INT 30
19909: PUSH
19910: LD_INT 33
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: LIST
19921: PPUSH
19922: CALL_OW 72
19926: IFFALSE 20014
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19928: LD_ADDR_VAR 0 8
19932: PUSH
19933: LD_VAR 0 18
19937: PPUSH
19938: LD_INT 2
19940: PUSH
19941: LD_INT 30
19943: PUSH
19944: LD_INT 32
19946: PUSH
19947: EMPTY
19948: LIST
19949: LIST
19950: PUSH
19951: LD_INT 30
19953: PUSH
19954: LD_INT 33
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: PUSH
19961: EMPTY
19962: LIST
19963: LIST
19964: LIST
19965: PPUSH
19966: CALL_OW 72
19970: PUSH
19971: FOR_IN
19972: IFFALSE 20012
// begin if not GetBWeapon ( i ) then
19974: LD_VAR 0 8
19978: PPUSH
19979: CALL_OW 269
19983: NOT
19984: IFFALSE 20010
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19986: LD_VAR 0 8
19990: PPUSH
19991: LD_VAR 0 8
19995: PPUSH
19996: LD_VAR 0 2
20000: PPUSH
20001: CALL 21260 0 2
20005: PPUSH
20006: CALL_OW 431
// end ;
20010: GO 19971
20012: POP
20013: POP
// end ; for i = 1 to personel do
20014: LD_ADDR_VAR 0 8
20018: PUSH
20019: DOUBLE
20020: LD_INT 1
20022: DEC
20023: ST_TO_ADDR
20024: LD_VAR 0 6
20028: PUSH
20029: FOR_TO
20030: IFFALSE 21094
// begin if i > 4 then
20032: LD_VAR 0 8
20036: PUSH
20037: LD_INT 4
20039: GREATER
20040: IFFALSE 20044
// break ;
20042: GO 21094
// case i of 1 :
20044: LD_VAR 0 8
20048: PUSH
20049: LD_INT 1
20051: DOUBLE
20052: EQUAL
20053: IFTRUE 20057
20055: GO 20137
20057: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
20058: LD_ADDR_VAR 0 12
20062: PUSH
20063: LD_VAR 0 18
20067: PPUSH
20068: LD_INT 22
20070: PUSH
20071: LD_VAR 0 16
20075: PUSH
20076: EMPTY
20077: LIST
20078: LIST
20079: PUSH
20080: LD_INT 58
20082: PUSH
20083: EMPTY
20084: LIST
20085: PUSH
20086: LD_INT 2
20088: PUSH
20089: LD_INT 30
20091: PUSH
20092: LD_INT 32
20094: PUSH
20095: EMPTY
20096: LIST
20097: LIST
20098: PUSH
20099: LD_INT 30
20101: PUSH
20102: LD_INT 4
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 5
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: LIST
20123: LIST
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: LIST
20129: PPUSH
20130: CALL_OW 72
20134: ST_TO_ADDR
20135: GO 20359
20137: LD_INT 2
20139: DOUBLE
20140: EQUAL
20141: IFTRUE 20145
20143: GO 20207
20145: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20146: LD_ADDR_VAR 0 12
20150: PUSH
20151: LD_VAR 0 18
20155: PPUSH
20156: LD_INT 22
20158: PUSH
20159: LD_VAR 0 16
20163: PUSH
20164: EMPTY
20165: LIST
20166: LIST
20167: PUSH
20168: LD_INT 2
20170: PUSH
20171: LD_INT 30
20173: PUSH
20174: LD_INT 0
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: PUSH
20181: LD_INT 30
20183: PUSH
20184: LD_INT 1
20186: PUSH
20187: EMPTY
20188: LIST
20189: LIST
20190: PUSH
20191: EMPTY
20192: LIST
20193: LIST
20194: LIST
20195: PUSH
20196: EMPTY
20197: LIST
20198: LIST
20199: PPUSH
20200: CALL_OW 72
20204: ST_TO_ADDR
20205: GO 20359
20207: LD_INT 3
20209: DOUBLE
20210: EQUAL
20211: IFTRUE 20215
20213: GO 20277
20215: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20216: LD_ADDR_VAR 0 12
20220: PUSH
20221: LD_VAR 0 18
20225: PPUSH
20226: LD_INT 22
20228: PUSH
20229: LD_VAR 0 16
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PUSH
20238: LD_INT 2
20240: PUSH
20241: LD_INT 30
20243: PUSH
20244: LD_INT 2
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 30
20253: PUSH
20254: LD_INT 3
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: PUSH
20266: EMPTY
20267: LIST
20268: LIST
20269: PPUSH
20270: CALL_OW 72
20274: ST_TO_ADDR
20275: GO 20359
20277: LD_INT 4
20279: DOUBLE
20280: EQUAL
20281: IFTRUE 20285
20283: GO 20358
20285: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20286: LD_ADDR_VAR 0 12
20290: PUSH
20291: LD_VAR 0 18
20295: PPUSH
20296: LD_INT 22
20298: PUSH
20299: LD_VAR 0 16
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: PUSH
20308: LD_INT 2
20310: PUSH
20311: LD_INT 30
20313: PUSH
20314: LD_INT 6
20316: PUSH
20317: EMPTY
20318: LIST
20319: LIST
20320: PUSH
20321: LD_INT 30
20323: PUSH
20324: LD_INT 7
20326: PUSH
20327: EMPTY
20328: LIST
20329: LIST
20330: PUSH
20331: LD_INT 30
20333: PUSH
20334: LD_INT 8
20336: PUSH
20337: EMPTY
20338: LIST
20339: LIST
20340: PUSH
20341: EMPTY
20342: LIST
20343: LIST
20344: LIST
20345: LIST
20346: PUSH
20347: EMPTY
20348: LIST
20349: LIST
20350: PPUSH
20351: CALL_OW 72
20355: ST_TO_ADDR
20356: GO 20359
20358: POP
// if i = 1 then
20359: LD_VAR 0 8
20363: PUSH
20364: LD_INT 1
20366: EQUAL
20367: IFFALSE 20478
// begin tmp := [ ] ;
20369: LD_ADDR_VAR 0 19
20373: PUSH
20374: EMPTY
20375: ST_TO_ADDR
// for j in f do
20376: LD_ADDR_VAR 0 9
20380: PUSH
20381: LD_VAR 0 12
20385: PUSH
20386: FOR_IN
20387: IFFALSE 20460
// if GetBType ( j ) = b_bunker then
20389: LD_VAR 0 9
20393: PPUSH
20394: CALL_OW 266
20398: PUSH
20399: LD_INT 32
20401: EQUAL
20402: IFFALSE 20429
// tmp := Insert ( tmp , 1 , j ) else
20404: LD_ADDR_VAR 0 19
20408: PUSH
20409: LD_VAR 0 19
20413: PPUSH
20414: LD_INT 1
20416: PPUSH
20417: LD_VAR 0 9
20421: PPUSH
20422: CALL_OW 2
20426: ST_TO_ADDR
20427: GO 20458
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20429: LD_ADDR_VAR 0 19
20433: PUSH
20434: LD_VAR 0 19
20438: PPUSH
20439: LD_VAR 0 19
20443: PUSH
20444: LD_INT 1
20446: PLUS
20447: PPUSH
20448: LD_VAR 0 9
20452: PPUSH
20453: CALL_OW 2
20457: ST_TO_ADDR
20458: GO 20386
20460: POP
20461: POP
// if tmp then
20462: LD_VAR 0 19
20466: IFFALSE 20478
// f := tmp ;
20468: LD_ADDR_VAR 0 12
20472: PUSH
20473: LD_VAR 0 19
20477: ST_TO_ADDR
// end ; x := personel [ i ] ;
20478: LD_ADDR_VAR 0 13
20482: PUSH
20483: LD_VAR 0 6
20487: PUSH
20488: LD_VAR 0 8
20492: ARRAY
20493: ST_TO_ADDR
// if x = - 1 then
20494: LD_VAR 0 13
20498: PUSH
20499: LD_INT 1
20501: NEG
20502: EQUAL
20503: IFFALSE 20712
// begin for j in f do
20505: LD_ADDR_VAR 0 9
20509: PUSH
20510: LD_VAR 0 12
20514: PUSH
20515: FOR_IN
20516: IFFALSE 20708
// repeat InitHc ;
20518: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20522: LD_VAR 0 9
20526: PPUSH
20527: CALL_OW 266
20531: PUSH
20532: LD_INT 5
20534: EQUAL
20535: IFFALSE 20605
// begin if UnitsInside ( j ) < 3 then
20537: LD_VAR 0 9
20541: PPUSH
20542: CALL_OW 313
20546: PUSH
20547: LD_INT 3
20549: LESS
20550: IFFALSE 20586
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20552: LD_INT 0
20554: PPUSH
20555: LD_INT 5
20557: PUSH
20558: LD_INT 8
20560: PUSH
20561: LD_INT 9
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: LIST
20568: PUSH
20569: LD_VAR 0 17
20573: ARRAY
20574: PPUSH
20575: LD_VAR 0 4
20579: PPUSH
20580: CALL_OW 380
20584: GO 20603
// PrepareHuman ( false , i , skill ) ;
20586: LD_INT 0
20588: PPUSH
20589: LD_VAR 0 8
20593: PPUSH
20594: LD_VAR 0 4
20598: PPUSH
20599: CALL_OW 380
// end else
20603: GO 20622
// PrepareHuman ( false , i , skill ) ;
20605: LD_INT 0
20607: PPUSH
20608: LD_VAR 0 8
20612: PPUSH
20613: LD_VAR 0 4
20617: PPUSH
20618: CALL_OW 380
// un := CreateHuman ;
20622: LD_ADDR_VAR 0 14
20626: PUSH
20627: CALL_OW 44
20631: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20632: LD_ADDR_VAR 0 7
20636: PUSH
20637: LD_VAR 0 7
20641: PPUSH
20642: LD_INT 1
20644: PPUSH
20645: LD_VAR 0 14
20649: PPUSH
20650: CALL_OW 2
20654: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20655: LD_VAR 0 14
20659: PPUSH
20660: LD_VAR 0 9
20664: PPUSH
20665: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20669: LD_VAR 0 9
20673: PPUSH
20674: CALL_OW 313
20678: PUSH
20679: LD_INT 6
20681: EQUAL
20682: PUSH
20683: LD_VAR 0 9
20687: PPUSH
20688: CALL_OW 266
20692: PUSH
20693: LD_INT 32
20695: PUSH
20696: LD_INT 31
20698: PUSH
20699: EMPTY
20700: LIST
20701: LIST
20702: IN
20703: OR
20704: IFFALSE 20518
20706: GO 20515
20708: POP
20709: POP
// end else
20710: GO 21092
// for j = 1 to x do
20712: LD_ADDR_VAR 0 9
20716: PUSH
20717: DOUBLE
20718: LD_INT 1
20720: DEC
20721: ST_TO_ADDR
20722: LD_VAR 0 13
20726: PUSH
20727: FOR_TO
20728: IFFALSE 21090
// begin InitHc ;
20730: CALL_OW 19
// if not f then
20734: LD_VAR 0 12
20738: NOT
20739: IFFALSE 20828
// begin PrepareHuman ( false , i , skill ) ;
20741: LD_INT 0
20743: PPUSH
20744: LD_VAR 0 8
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: CALL_OW 380
// un := CreateHuman ;
20758: LD_ADDR_VAR 0 14
20762: PUSH
20763: CALL_OW 44
20767: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20768: LD_ADDR_VAR 0 7
20772: PUSH
20773: LD_VAR 0 7
20777: PPUSH
20778: LD_INT 1
20780: PPUSH
20781: LD_VAR 0 14
20785: PPUSH
20786: CALL_OW 2
20790: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20791: LD_VAR 0 14
20795: PPUSH
20796: LD_VAR 0 1
20800: PPUSH
20801: CALL_OW 250
20805: PPUSH
20806: LD_VAR 0 1
20810: PPUSH
20811: CALL_OW 251
20815: PPUSH
20816: LD_INT 10
20818: PPUSH
20819: LD_INT 0
20821: PPUSH
20822: CALL_OW 50
// continue ;
20826: GO 20727
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20828: LD_VAR 0 12
20832: PUSH
20833: LD_INT 1
20835: ARRAY
20836: PPUSH
20837: CALL_OW 313
20841: PUSH
20842: LD_VAR 0 12
20846: PUSH
20847: LD_INT 1
20849: ARRAY
20850: PPUSH
20851: CALL_OW 266
20855: PUSH
20856: LD_INT 32
20858: PUSH
20859: LD_INT 31
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: IN
20866: AND
20867: PUSH
20868: LD_VAR 0 12
20872: PUSH
20873: LD_INT 1
20875: ARRAY
20876: PPUSH
20877: CALL_OW 313
20881: PUSH
20882: LD_INT 6
20884: EQUAL
20885: OR
20886: IFFALSE 20906
// f := Delete ( f , 1 ) ;
20888: LD_ADDR_VAR 0 12
20892: PUSH
20893: LD_VAR 0 12
20897: PPUSH
20898: LD_INT 1
20900: PPUSH
20901: CALL_OW 3
20905: ST_TO_ADDR
// if not f then
20906: LD_VAR 0 12
20910: NOT
20911: IFFALSE 20929
// begin x := x + 2 ;
20913: LD_ADDR_VAR 0 13
20917: PUSH
20918: LD_VAR 0 13
20922: PUSH
20923: LD_INT 2
20925: PLUS
20926: ST_TO_ADDR
// continue ;
20927: GO 20727
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20929: LD_VAR 0 12
20933: PUSH
20934: LD_INT 1
20936: ARRAY
20937: PPUSH
20938: CALL_OW 266
20942: PUSH
20943: LD_INT 5
20945: EQUAL
20946: IFFALSE 21020
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20948: LD_VAR 0 12
20952: PUSH
20953: LD_INT 1
20955: ARRAY
20956: PPUSH
20957: CALL_OW 313
20961: PUSH
20962: LD_INT 3
20964: LESS
20965: IFFALSE 21001
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20967: LD_INT 0
20969: PPUSH
20970: LD_INT 5
20972: PUSH
20973: LD_INT 8
20975: PUSH
20976: LD_INT 9
20978: PUSH
20979: EMPTY
20980: LIST
20981: LIST
20982: LIST
20983: PUSH
20984: LD_VAR 0 17
20988: ARRAY
20989: PPUSH
20990: LD_VAR 0 4
20994: PPUSH
20995: CALL_OW 380
20999: GO 21018
// PrepareHuman ( false , i , skill ) ;
21001: LD_INT 0
21003: PPUSH
21004: LD_VAR 0 8
21008: PPUSH
21009: LD_VAR 0 4
21013: PPUSH
21014: CALL_OW 380
// end else
21018: GO 21037
// PrepareHuman ( false , i , skill ) ;
21020: LD_INT 0
21022: PPUSH
21023: LD_VAR 0 8
21027: PPUSH
21028: LD_VAR 0 4
21032: PPUSH
21033: CALL_OW 380
// un := CreateHuman ;
21037: LD_ADDR_VAR 0 14
21041: PUSH
21042: CALL_OW 44
21046: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21047: LD_ADDR_VAR 0 7
21051: PUSH
21052: LD_VAR 0 7
21056: PPUSH
21057: LD_INT 1
21059: PPUSH
21060: LD_VAR 0 14
21064: PPUSH
21065: CALL_OW 2
21069: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
21070: LD_VAR 0 14
21074: PPUSH
21075: LD_VAR 0 12
21079: PUSH
21080: LD_INT 1
21082: ARRAY
21083: PPUSH
21084: CALL_OW 52
// end ;
21088: GO 20727
21090: POP
21091: POP
// end ;
21092: GO 20029
21094: POP
21095: POP
// result := result ^ buildings ;
21096: LD_ADDR_VAR 0 7
21100: PUSH
21101: LD_VAR 0 7
21105: PUSH
21106: LD_VAR 0 18
21110: ADD
21111: ST_TO_ADDR
// end else
21112: GO 21255
// begin for i = 1 to personel do
21114: LD_ADDR_VAR 0 8
21118: PUSH
21119: DOUBLE
21120: LD_INT 1
21122: DEC
21123: ST_TO_ADDR
21124: LD_VAR 0 6
21128: PUSH
21129: FOR_TO
21130: IFFALSE 21253
// begin if i > 4 then
21132: LD_VAR 0 8
21136: PUSH
21137: LD_INT 4
21139: GREATER
21140: IFFALSE 21144
// break ;
21142: GO 21253
// x := personel [ i ] ;
21144: LD_ADDR_VAR 0 13
21148: PUSH
21149: LD_VAR 0 6
21153: PUSH
21154: LD_VAR 0 8
21158: ARRAY
21159: ST_TO_ADDR
// if x = - 1 then
21160: LD_VAR 0 13
21164: PUSH
21165: LD_INT 1
21167: NEG
21168: EQUAL
21169: IFFALSE 21173
// continue ;
21171: GO 21129
// PrepareHuman ( false , i , skill ) ;
21173: LD_INT 0
21175: PPUSH
21176: LD_VAR 0 8
21180: PPUSH
21181: LD_VAR 0 4
21185: PPUSH
21186: CALL_OW 380
// un := CreateHuman ;
21190: LD_ADDR_VAR 0 14
21194: PUSH
21195: CALL_OW 44
21199: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21200: LD_VAR 0 14
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: CALL_OW 250
21214: PPUSH
21215: LD_VAR 0 1
21219: PPUSH
21220: CALL_OW 251
21224: PPUSH
21225: LD_INT 10
21227: PPUSH
21228: LD_INT 0
21230: PPUSH
21231: CALL_OW 50
// result := result ^ un ;
21235: LD_ADDR_VAR 0 7
21239: PUSH
21240: LD_VAR 0 7
21244: PUSH
21245: LD_VAR 0 14
21249: ADD
21250: ST_TO_ADDR
// end ;
21251: GO 21129
21253: POP
21254: POP
// end ; end ;
21255: LD_VAR 0 7
21259: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21260: LD_INT 0
21262: PPUSH
21263: PPUSH
21264: PPUSH
21265: PPUSH
21266: PPUSH
21267: PPUSH
21268: PPUSH
21269: PPUSH
21270: PPUSH
21271: PPUSH
21272: PPUSH
21273: PPUSH
21274: PPUSH
21275: PPUSH
21276: PPUSH
21277: PPUSH
// result := false ;
21278: LD_ADDR_VAR 0 3
21282: PUSH
21283: LD_INT 0
21285: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21286: LD_VAR 0 1
21290: NOT
21291: PUSH
21292: LD_VAR 0 1
21296: PPUSH
21297: CALL_OW 266
21301: PUSH
21302: LD_INT 32
21304: PUSH
21305: LD_INT 33
21307: PUSH
21308: EMPTY
21309: LIST
21310: LIST
21311: IN
21312: NOT
21313: OR
21314: IFFALSE 21318
// exit ;
21316: GO 22427
// nat := GetNation ( tower ) ;
21318: LD_ADDR_VAR 0 12
21322: PUSH
21323: LD_VAR 0 1
21327: PPUSH
21328: CALL_OW 248
21332: ST_TO_ADDR
// side := GetSide ( tower ) ;
21333: LD_ADDR_VAR 0 16
21337: PUSH
21338: LD_VAR 0 1
21342: PPUSH
21343: CALL_OW 255
21347: ST_TO_ADDR
// x := GetX ( tower ) ;
21348: LD_ADDR_VAR 0 10
21352: PUSH
21353: LD_VAR 0 1
21357: PPUSH
21358: CALL_OW 250
21362: ST_TO_ADDR
// y := GetY ( tower ) ;
21363: LD_ADDR_VAR 0 11
21367: PUSH
21368: LD_VAR 0 1
21372: PPUSH
21373: CALL_OW 251
21377: ST_TO_ADDR
// if not x or not y then
21378: LD_VAR 0 10
21382: NOT
21383: PUSH
21384: LD_VAR 0 11
21388: NOT
21389: OR
21390: IFFALSE 21394
// exit ;
21392: GO 22427
// weapon := 0 ;
21394: LD_ADDR_VAR 0 18
21398: PUSH
21399: LD_INT 0
21401: ST_TO_ADDR
// fac_list := [ ] ;
21402: LD_ADDR_VAR 0 17
21406: PUSH
21407: EMPTY
21408: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21409: LD_ADDR_VAR 0 6
21413: PUSH
21414: LD_VAR 0 1
21418: PPUSH
21419: CALL_OW 274
21423: PPUSH
21424: LD_VAR 0 2
21428: PPUSH
21429: LD_INT 0
21431: PPUSH
21432: CALL 18998 0 3
21436: PPUSH
21437: LD_INT 30
21439: PUSH
21440: LD_INT 3
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PPUSH
21447: CALL_OW 72
21451: ST_TO_ADDR
// if not factories then
21452: LD_VAR 0 6
21456: NOT
21457: IFFALSE 21461
// exit ;
21459: GO 22427
// for i in factories do
21461: LD_ADDR_VAR 0 8
21465: PUSH
21466: LD_VAR 0 6
21470: PUSH
21471: FOR_IN
21472: IFFALSE 21497
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21474: LD_ADDR_VAR 0 17
21478: PUSH
21479: LD_VAR 0 17
21483: PUSH
21484: LD_VAR 0 8
21488: PPUSH
21489: CALL_OW 478
21493: UNION
21494: ST_TO_ADDR
21495: GO 21471
21497: POP
21498: POP
// if not fac_list then
21499: LD_VAR 0 17
21503: NOT
21504: IFFALSE 21508
// exit ;
21506: GO 22427
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21508: LD_ADDR_VAR 0 5
21512: PUSH
21513: LD_INT 4
21515: PUSH
21516: LD_INT 5
21518: PUSH
21519: LD_INT 9
21521: PUSH
21522: LD_INT 10
21524: PUSH
21525: LD_INT 6
21527: PUSH
21528: LD_INT 7
21530: PUSH
21531: LD_INT 11
21533: PUSH
21534: EMPTY
21535: LIST
21536: LIST
21537: LIST
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PUSH
21543: LD_INT 27
21545: PUSH
21546: LD_INT 28
21548: PUSH
21549: LD_INT 26
21551: PUSH
21552: LD_INT 30
21554: PUSH
21555: EMPTY
21556: LIST
21557: LIST
21558: LIST
21559: LIST
21560: PUSH
21561: LD_INT 43
21563: PUSH
21564: LD_INT 44
21566: PUSH
21567: LD_INT 46
21569: PUSH
21570: LD_INT 45
21572: PUSH
21573: LD_INT 47
21575: PUSH
21576: LD_INT 49
21578: PUSH
21579: EMPTY
21580: LIST
21581: LIST
21582: LIST
21583: LIST
21584: LIST
21585: LIST
21586: PUSH
21587: EMPTY
21588: LIST
21589: LIST
21590: LIST
21591: PUSH
21592: LD_VAR 0 12
21596: ARRAY
21597: ST_TO_ADDR
// list := list isect fac_list ;
21598: LD_ADDR_VAR 0 5
21602: PUSH
21603: LD_VAR 0 5
21607: PUSH
21608: LD_VAR 0 17
21612: ISECT
21613: ST_TO_ADDR
// if not list then
21614: LD_VAR 0 5
21618: NOT
21619: IFFALSE 21623
// exit ;
21621: GO 22427
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21623: LD_VAR 0 12
21627: PUSH
21628: LD_INT 3
21630: EQUAL
21631: PUSH
21632: LD_INT 49
21634: PUSH
21635: LD_VAR 0 5
21639: IN
21640: AND
21641: PUSH
21642: LD_INT 31
21644: PPUSH
21645: LD_VAR 0 16
21649: PPUSH
21650: CALL_OW 321
21654: PUSH
21655: LD_INT 2
21657: EQUAL
21658: AND
21659: IFFALSE 21719
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21661: LD_INT 22
21663: PUSH
21664: LD_VAR 0 16
21668: PUSH
21669: EMPTY
21670: LIST
21671: LIST
21672: PUSH
21673: LD_INT 35
21675: PUSH
21676: LD_INT 49
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: LD_INT 91
21685: PUSH
21686: LD_VAR 0 1
21690: PUSH
21691: LD_INT 10
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: LIST
21703: PPUSH
21704: CALL_OW 69
21708: NOT
21709: IFFALSE 21719
// weapon := ru_time_lapser ;
21711: LD_ADDR_VAR 0 18
21715: PUSH
21716: LD_INT 49
21718: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21719: LD_VAR 0 12
21723: PUSH
21724: LD_INT 1
21726: PUSH
21727: LD_INT 2
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: IN
21734: PUSH
21735: LD_INT 11
21737: PUSH
21738: LD_VAR 0 5
21742: IN
21743: PUSH
21744: LD_INT 30
21746: PUSH
21747: LD_VAR 0 5
21751: IN
21752: OR
21753: AND
21754: PUSH
21755: LD_INT 6
21757: PPUSH
21758: LD_VAR 0 16
21762: PPUSH
21763: CALL_OW 321
21767: PUSH
21768: LD_INT 2
21770: EQUAL
21771: AND
21772: IFFALSE 21937
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21774: LD_INT 22
21776: PUSH
21777: LD_VAR 0 16
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 2
21788: PUSH
21789: LD_INT 35
21791: PUSH
21792: LD_INT 11
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: PUSH
21799: LD_INT 35
21801: PUSH
21802: LD_INT 30
21804: PUSH
21805: EMPTY
21806: LIST
21807: LIST
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: LIST
21813: PUSH
21814: LD_INT 91
21816: PUSH
21817: LD_VAR 0 1
21821: PUSH
21822: LD_INT 18
21824: PUSH
21825: EMPTY
21826: LIST
21827: LIST
21828: LIST
21829: PUSH
21830: EMPTY
21831: LIST
21832: LIST
21833: LIST
21834: PPUSH
21835: CALL_OW 69
21839: NOT
21840: PUSH
21841: LD_INT 22
21843: PUSH
21844: LD_VAR 0 16
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PUSH
21853: LD_INT 2
21855: PUSH
21856: LD_INT 30
21858: PUSH
21859: LD_INT 32
21861: PUSH
21862: EMPTY
21863: LIST
21864: LIST
21865: PUSH
21866: LD_INT 30
21868: PUSH
21869: LD_INT 33
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PUSH
21881: LD_INT 91
21883: PUSH
21884: LD_VAR 0 1
21888: PUSH
21889: LD_INT 12
21891: PUSH
21892: EMPTY
21893: LIST
21894: LIST
21895: LIST
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: PUSH
21902: EMPTY
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: PUSH
21910: LD_INT 2
21912: GREATER
21913: AND
21914: IFFALSE 21937
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21916: LD_ADDR_VAR 0 18
21920: PUSH
21921: LD_INT 11
21923: PUSH
21924: LD_INT 30
21926: PUSH
21927: EMPTY
21928: LIST
21929: LIST
21930: PUSH
21931: LD_VAR 0 12
21935: ARRAY
21936: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21937: LD_VAR 0 18
21941: NOT
21942: PUSH
21943: LD_INT 40
21945: PPUSH
21946: LD_VAR 0 16
21950: PPUSH
21951: CALL_OW 321
21955: PUSH
21956: LD_INT 2
21958: EQUAL
21959: AND
21960: PUSH
21961: LD_INT 7
21963: PUSH
21964: LD_VAR 0 5
21968: IN
21969: PUSH
21970: LD_INT 28
21972: PUSH
21973: LD_VAR 0 5
21977: IN
21978: OR
21979: PUSH
21980: LD_INT 45
21982: PUSH
21983: LD_VAR 0 5
21987: IN
21988: OR
21989: AND
21990: IFFALSE 22244
// begin hex := GetHexInfo ( x , y ) ;
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 10
22001: PPUSH
22002: LD_VAR 0 11
22006: PPUSH
22007: CALL_OW 546
22011: ST_TO_ADDR
// if hex [ 1 ] then
22012: LD_VAR 0 4
22016: PUSH
22017: LD_INT 1
22019: ARRAY
22020: IFFALSE 22024
// exit ;
22022: GO 22427
// height := hex [ 2 ] ;
22024: LD_ADDR_VAR 0 15
22028: PUSH
22029: LD_VAR 0 4
22033: PUSH
22034: LD_INT 2
22036: ARRAY
22037: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
22038: LD_ADDR_VAR 0 14
22042: PUSH
22043: LD_INT 0
22045: PUSH
22046: LD_INT 2
22048: PUSH
22049: LD_INT 3
22051: PUSH
22052: LD_INT 5
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: LIST
22059: LIST
22060: ST_TO_ADDR
// for i in tmp do
22061: LD_ADDR_VAR 0 8
22065: PUSH
22066: LD_VAR 0 14
22070: PUSH
22071: FOR_IN
22072: IFFALSE 22242
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
22074: LD_ADDR_VAR 0 9
22078: PUSH
22079: LD_VAR 0 10
22083: PPUSH
22084: LD_VAR 0 8
22088: PPUSH
22089: LD_INT 5
22091: PPUSH
22092: CALL_OW 272
22096: PUSH
22097: LD_VAR 0 11
22101: PPUSH
22102: LD_VAR 0 8
22106: PPUSH
22107: LD_INT 5
22109: PPUSH
22110: CALL_OW 273
22114: PUSH
22115: EMPTY
22116: LIST
22117: LIST
22118: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22119: LD_VAR 0 9
22123: PUSH
22124: LD_INT 1
22126: ARRAY
22127: PPUSH
22128: LD_VAR 0 9
22132: PUSH
22133: LD_INT 2
22135: ARRAY
22136: PPUSH
22137: CALL_OW 488
22141: IFFALSE 22240
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22143: LD_ADDR_VAR 0 4
22147: PUSH
22148: LD_VAR 0 9
22152: PUSH
22153: LD_INT 1
22155: ARRAY
22156: PPUSH
22157: LD_VAR 0 9
22161: PUSH
22162: LD_INT 2
22164: ARRAY
22165: PPUSH
22166: CALL_OW 546
22170: ST_TO_ADDR
// if hex [ 1 ] then
22171: LD_VAR 0 4
22175: PUSH
22176: LD_INT 1
22178: ARRAY
22179: IFFALSE 22183
// continue ;
22181: GO 22071
// h := hex [ 2 ] ;
22183: LD_ADDR_VAR 0 13
22187: PUSH
22188: LD_VAR 0 4
22192: PUSH
22193: LD_INT 2
22195: ARRAY
22196: ST_TO_ADDR
// if h + 7 < height then
22197: LD_VAR 0 13
22201: PUSH
22202: LD_INT 7
22204: PLUS
22205: PUSH
22206: LD_VAR 0 15
22210: LESS
22211: IFFALSE 22240
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22213: LD_ADDR_VAR 0 18
22217: PUSH
22218: LD_INT 7
22220: PUSH
22221: LD_INT 28
22223: PUSH
22224: LD_INT 45
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: LIST
22231: PUSH
22232: LD_VAR 0 12
22236: ARRAY
22237: ST_TO_ADDR
// break ;
22238: GO 22242
// end ; end ; end ;
22240: GO 22071
22242: POP
22243: POP
// end ; if not weapon then
22244: LD_VAR 0 18
22248: NOT
22249: IFFALSE 22309
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22251: LD_ADDR_VAR 0 5
22255: PUSH
22256: LD_VAR 0 5
22260: PUSH
22261: LD_INT 11
22263: PUSH
22264: LD_INT 30
22266: PUSH
22267: LD_INT 49
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: LIST
22274: DIFF
22275: ST_TO_ADDR
// if not list then
22276: LD_VAR 0 5
22280: NOT
22281: IFFALSE 22285
// exit ;
22283: GO 22427
// weapon := list [ rand ( 1 , list ) ] ;
22285: LD_ADDR_VAR 0 18
22289: PUSH
22290: LD_VAR 0 5
22294: PUSH
22295: LD_INT 1
22297: PPUSH
22298: LD_VAR 0 5
22302: PPUSH
22303: CALL_OW 12
22307: ARRAY
22308: ST_TO_ADDR
// end ; if weapon then
22309: LD_VAR 0 18
22313: IFFALSE 22427
// begin tmp := CostOfWeapon ( weapon ) ;
22315: LD_ADDR_VAR 0 14
22319: PUSH
22320: LD_VAR 0 18
22324: PPUSH
22325: CALL_OW 451
22329: ST_TO_ADDR
// j := GetBase ( tower ) ;
22330: LD_ADDR_VAR 0 9
22334: PUSH
22335: LD_VAR 0 1
22339: PPUSH
22340: CALL_OW 274
22344: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22345: LD_VAR 0 9
22349: PPUSH
22350: LD_INT 1
22352: PPUSH
22353: CALL_OW 275
22357: PUSH
22358: LD_VAR 0 14
22362: PUSH
22363: LD_INT 1
22365: ARRAY
22366: GREATEREQUAL
22367: PUSH
22368: LD_VAR 0 9
22372: PPUSH
22373: LD_INT 2
22375: PPUSH
22376: CALL_OW 275
22380: PUSH
22381: LD_VAR 0 14
22385: PUSH
22386: LD_INT 2
22388: ARRAY
22389: GREATEREQUAL
22390: AND
22391: PUSH
22392: LD_VAR 0 9
22396: PPUSH
22397: LD_INT 3
22399: PPUSH
22400: CALL_OW 275
22404: PUSH
22405: LD_VAR 0 14
22409: PUSH
22410: LD_INT 3
22412: ARRAY
22413: GREATEREQUAL
22414: AND
22415: IFFALSE 22427
// result := weapon ;
22417: LD_ADDR_VAR 0 3
22421: PUSH
22422: LD_VAR 0 18
22426: ST_TO_ADDR
// end ; end ;
22427: LD_VAR 0 3
22431: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22432: LD_INT 0
22434: PPUSH
22435: PPUSH
// result := true ;
22436: LD_ADDR_VAR 0 3
22440: PUSH
22441: LD_INT 1
22443: ST_TO_ADDR
// if array1 = array2 then
22444: LD_VAR 0 1
22448: PUSH
22449: LD_VAR 0 2
22453: EQUAL
22454: IFFALSE 22514
// begin for i = 1 to array1 do
22456: LD_ADDR_VAR 0 4
22460: PUSH
22461: DOUBLE
22462: LD_INT 1
22464: DEC
22465: ST_TO_ADDR
22466: LD_VAR 0 1
22470: PUSH
22471: FOR_TO
22472: IFFALSE 22510
// if array1 [ i ] <> array2 [ i ] then
22474: LD_VAR 0 1
22478: PUSH
22479: LD_VAR 0 4
22483: ARRAY
22484: PUSH
22485: LD_VAR 0 2
22489: PUSH
22490: LD_VAR 0 4
22494: ARRAY
22495: NONEQUAL
22496: IFFALSE 22508
// begin result := false ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 0
22505: ST_TO_ADDR
// break ;
22506: GO 22510
// end ;
22508: GO 22471
22510: POP
22511: POP
// end else
22512: GO 22522
// result := false ;
22514: LD_ADDR_VAR 0 3
22518: PUSH
22519: LD_INT 0
22521: ST_TO_ADDR
// end ;
22522: LD_VAR 0 3
22526: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22527: LD_INT 0
22529: PPUSH
22530: PPUSH
// if not array1 or not array2 then
22531: LD_VAR 0 1
22535: NOT
22536: PUSH
22537: LD_VAR 0 2
22541: NOT
22542: OR
22543: IFFALSE 22547
// exit ;
22545: GO 22611
// result := true ;
22547: LD_ADDR_VAR 0 3
22551: PUSH
22552: LD_INT 1
22554: ST_TO_ADDR
// for i = 1 to array1 do
22555: LD_ADDR_VAR 0 4
22559: PUSH
22560: DOUBLE
22561: LD_INT 1
22563: DEC
22564: ST_TO_ADDR
22565: LD_VAR 0 1
22569: PUSH
22570: FOR_TO
22571: IFFALSE 22609
// if array1 [ i ] <> array2 [ i ] then
22573: LD_VAR 0 1
22577: PUSH
22578: LD_VAR 0 4
22582: ARRAY
22583: PUSH
22584: LD_VAR 0 2
22588: PUSH
22589: LD_VAR 0 4
22593: ARRAY
22594: NONEQUAL
22595: IFFALSE 22607
// begin result := false ;
22597: LD_ADDR_VAR 0 3
22601: PUSH
22602: LD_INT 0
22604: ST_TO_ADDR
// break ;
22605: GO 22609
// end ;
22607: GO 22570
22609: POP
22610: POP
// end ;
22611: LD_VAR 0 3
22615: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22616: LD_INT 0
22618: PPUSH
22619: PPUSH
22620: PPUSH
// pom := GetBase ( fac ) ;
22621: LD_ADDR_VAR 0 5
22625: PUSH
22626: LD_VAR 0 1
22630: PPUSH
22631: CALL_OW 274
22635: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22636: LD_ADDR_VAR 0 4
22640: PUSH
22641: LD_VAR 0 2
22645: PUSH
22646: LD_INT 1
22648: ARRAY
22649: PPUSH
22650: LD_VAR 0 2
22654: PUSH
22655: LD_INT 2
22657: ARRAY
22658: PPUSH
22659: LD_VAR 0 2
22663: PUSH
22664: LD_INT 3
22666: ARRAY
22667: PPUSH
22668: LD_VAR 0 2
22672: PUSH
22673: LD_INT 4
22675: ARRAY
22676: PPUSH
22677: CALL_OW 449
22681: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22682: LD_ADDR_VAR 0 3
22686: PUSH
22687: LD_VAR 0 5
22691: PPUSH
22692: LD_INT 1
22694: PPUSH
22695: CALL_OW 275
22699: PUSH
22700: LD_VAR 0 4
22704: PUSH
22705: LD_INT 1
22707: ARRAY
22708: GREATEREQUAL
22709: PUSH
22710: LD_VAR 0 5
22714: PPUSH
22715: LD_INT 2
22717: PPUSH
22718: CALL_OW 275
22722: PUSH
22723: LD_VAR 0 4
22727: PUSH
22728: LD_INT 2
22730: ARRAY
22731: GREATEREQUAL
22732: AND
22733: PUSH
22734: LD_VAR 0 5
22738: PPUSH
22739: LD_INT 3
22741: PPUSH
22742: CALL_OW 275
22746: PUSH
22747: LD_VAR 0 4
22751: PUSH
22752: LD_INT 3
22754: ARRAY
22755: GREATEREQUAL
22756: AND
22757: ST_TO_ADDR
// end ;
22758: LD_VAR 0 3
22762: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22763: LD_INT 0
22765: PPUSH
22766: PPUSH
22767: PPUSH
22768: PPUSH
// pom := GetBase ( building ) ;
22769: LD_ADDR_VAR 0 3
22773: PUSH
22774: LD_VAR 0 1
22778: PPUSH
22779: CALL_OW 274
22783: ST_TO_ADDR
// if not pom then
22784: LD_VAR 0 3
22788: NOT
22789: IFFALSE 22793
// exit ;
22791: GO 22963
// btype := GetBType ( building ) ;
22793: LD_ADDR_VAR 0 5
22797: PUSH
22798: LD_VAR 0 1
22802: PPUSH
22803: CALL_OW 266
22807: ST_TO_ADDR
// if btype = b_armoury then
22808: LD_VAR 0 5
22812: PUSH
22813: LD_INT 4
22815: EQUAL
22816: IFFALSE 22826
// btype := b_barracks ;
22818: LD_ADDR_VAR 0 5
22822: PUSH
22823: LD_INT 5
22825: ST_TO_ADDR
// if btype = b_depot then
22826: LD_VAR 0 5
22830: PUSH
22831: LD_INT 0
22833: EQUAL
22834: IFFALSE 22844
// btype := b_warehouse ;
22836: LD_ADDR_VAR 0 5
22840: PUSH
22841: LD_INT 1
22843: ST_TO_ADDR
// if btype = b_workshop then
22844: LD_VAR 0 5
22848: PUSH
22849: LD_INT 2
22851: EQUAL
22852: IFFALSE 22862
// btype := b_factory ;
22854: LD_ADDR_VAR 0 5
22858: PUSH
22859: LD_INT 3
22861: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22862: LD_ADDR_VAR 0 4
22866: PUSH
22867: LD_VAR 0 5
22871: PPUSH
22872: LD_VAR 0 1
22876: PPUSH
22877: CALL_OW 248
22881: PPUSH
22882: CALL_OW 450
22886: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22887: LD_ADDR_VAR 0 2
22891: PUSH
22892: LD_VAR 0 3
22896: PPUSH
22897: LD_INT 1
22899: PPUSH
22900: CALL_OW 275
22904: PUSH
22905: LD_VAR 0 4
22909: PUSH
22910: LD_INT 1
22912: ARRAY
22913: GREATEREQUAL
22914: PUSH
22915: LD_VAR 0 3
22919: PPUSH
22920: LD_INT 2
22922: PPUSH
22923: CALL_OW 275
22927: PUSH
22928: LD_VAR 0 4
22932: PUSH
22933: LD_INT 2
22935: ARRAY
22936: GREATEREQUAL
22937: AND
22938: PUSH
22939: LD_VAR 0 3
22943: PPUSH
22944: LD_INT 3
22946: PPUSH
22947: CALL_OW 275
22951: PUSH
22952: LD_VAR 0 4
22956: PUSH
22957: LD_INT 3
22959: ARRAY
22960: GREATEREQUAL
22961: AND
22962: ST_TO_ADDR
// end ;
22963: LD_VAR 0 2
22967: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22968: LD_INT 0
22970: PPUSH
22971: PPUSH
22972: PPUSH
// pom := GetBase ( building ) ;
22973: LD_ADDR_VAR 0 4
22977: PUSH
22978: LD_VAR 0 1
22982: PPUSH
22983: CALL_OW 274
22987: ST_TO_ADDR
// if not pom then
22988: LD_VAR 0 4
22992: NOT
22993: IFFALSE 22997
// exit ;
22995: GO 23098
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22997: LD_ADDR_VAR 0 5
23001: PUSH
23002: LD_VAR 0 2
23006: PPUSH
23007: LD_VAR 0 1
23011: PPUSH
23012: CALL_OW 248
23016: PPUSH
23017: CALL_OW 450
23021: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23022: LD_ADDR_VAR 0 3
23026: PUSH
23027: LD_VAR 0 4
23031: PPUSH
23032: LD_INT 1
23034: PPUSH
23035: CALL_OW 275
23039: PUSH
23040: LD_VAR 0 5
23044: PUSH
23045: LD_INT 1
23047: ARRAY
23048: GREATEREQUAL
23049: PUSH
23050: LD_VAR 0 4
23054: PPUSH
23055: LD_INT 2
23057: PPUSH
23058: CALL_OW 275
23062: PUSH
23063: LD_VAR 0 5
23067: PUSH
23068: LD_INT 2
23070: ARRAY
23071: GREATEREQUAL
23072: AND
23073: PUSH
23074: LD_VAR 0 4
23078: PPUSH
23079: LD_INT 3
23081: PPUSH
23082: CALL_OW 275
23086: PUSH
23087: LD_VAR 0 5
23091: PUSH
23092: LD_INT 3
23094: ARRAY
23095: GREATEREQUAL
23096: AND
23097: ST_TO_ADDR
// end ;
23098: LD_VAR 0 3
23102: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23103: LD_INT 0
23105: PPUSH
23106: PPUSH
23107: PPUSH
23108: PPUSH
23109: PPUSH
23110: PPUSH
23111: PPUSH
23112: PPUSH
23113: PPUSH
23114: PPUSH
23115: PPUSH
// result := false ;
23116: LD_ADDR_VAR 0 8
23120: PUSH
23121: LD_INT 0
23123: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23124: LD_VAR 0 5
23128: NOT
23129: PUSH
23130: LD_VAR 0 1
23134: NOT
23135: OR
23136: PUSH
23137: LD_VAR 0 2
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 3
23148: NOT
23149: OR
23150: IFFALSE 23154
// exit ;
23152: GO 23968
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23154: LD_ADDR_VAR 0 14
23158: PUSH
23159: LD_VAR 0 1
23163: PPUSH
23164: LD_VAR 0 2
23168: PPUSH
23169: LD_VAR 0 3
23173: PPUSH
23174: LD_VAR 0 4
23178: PPUSH
23179: LD_VAR 0 5
23183: PUSH
23184: LD_INT 1
23186: ARRAY
23187: PPUSH
23188: CALL_OW 248
23192: PPUSH
23193: LD_INT 0
23195: PPUSH
23196: CALL 25201 0 6
23200: ST_TO_ADDR
// if not hexes then
23201: LD_VAR 0 14
23205: NOT
23206: IFFALSE 23210
// exit ;
23208: GO 23968
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23210: LD_ADDR_VAR 0 17
23214: PUSH
23215: LD_VAR 0 5
23219: PPUSH
23220: LD_INT 22
23222: PUSH
23223: LD_VAR 0 13
23227: PPUSH
23228: CALL_OW 255
23232: PUSH
23233: EMPTY
23234: LIST
23235: LIST
23236: PUSH
23237: LD_INT 2
23239: PUSH
23240: LD_INT 30
23242: PUSH
23243: LD_INT 0
23245: PUSH
23246: EMPTY
23247: LIST
23248: LIST
23249: PUSH
23250: LD_INT 30
23252: PUSH
23253: LD_INT 1
23255: PUSH
23256: EMPTY
23257: LIST
23258: LIST
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: LIST
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PPUSH
23269: CALL_OW 72
23273: ST_TO_ADDR
// for i = 1 to hexes do
23274: LD_ADDR_VAR 0 9
23278: PUSH
23279: DOUBLE
23280: LD_INT 1
23282: DEC
23283: ST_TO_ADDR
23284: LD_VAR 0 14
23288: PUSH
23289: FOR_TO
23290: IFFALSE 23966
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23292: LD_ADDR_VAR 0 13
23296: PUSH
23297: LD_VAR 0 14
23301: PUSH
23302: LD_VAR 0 9
23306: ARRAY
23307: PUSH
23308: LD_INT 1
23310: ARRAY
23311: PPUSH
23312: LD_VAR 0 14
23316: PUSH
23317: LD_VAR 0 9
23321: ARRAY
23322: PUSH
23323: LD_INT 2
23325: ARRAY
23326: PPUSH
23327: CALL_OW 428
23331: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23332: LD_VAR 0 14
23336: PUSH
23337: LD_VAR 0 9
23341: ARRAY
23342: PUSH
23343: LD_INT 1
23345: ARRAY
23346: PPUSH
23347: LD_VAR 0 14
23351: PUSH
23352: LD_VAR 0 9
23356: ARRAY
23357: PUSH
23358: LD_INT 2
23360: ARRAY
23361: PPUSH
23362: CALL_OW 351
23366: PUSH
23367: LD_VAR 0 14
23371: PUSH
23372: LD_VAR 0 9
23376: ARRAY
23377: PUSH
23378: LD_INT 1
23380: ARRAY
23381: PPUSH
23382: LD_VAR 0 14
23386: PUSH
23387: LD_VAR 0 9
23391: ARRAY
23392: PUSH
23393: LD_INT 2
23395: ARRAY
23396: PPUSH
23397: CALL_OW 488
23401: NOT
23402: OR
23403: PUSH
23404: LD_VAR 0 13
23408: PPUSH
23409: CALL_OW 247
23413: PUSH
23414: LD_INT 3
23416: EQUAL
23417: OR
23418: IFFALSE 23424
// exit ;
23420: POP
23421: POP
23422: GO 23968
// if not tmp then
23424: LD_VAR 0 13
23428: NOT
23429: IFFALSE 23433
// continue ;
23431: GO 23289
// result := true ;
23433: LD_ADDR_VAR 0 8
23437: PUSH
23438: LD_INT 1
23440: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23441: LD_VAR 0 6
23445: PUSH
23446: LD_VAR 0 13
23450: PPUSH
23451: CALL_OW 247
23455: PUSH
23456: LD_INT 2
23458: EQUAL
23459: AND
23460: PUSH
23461: LD_VAR 0 13
23465: PPUSH
23466: CALL_OW 263
23470: PUSH
23471: LD_INT 1
23473: EQUAL
23474: AND
23475: IFFALSE 23639
// begin if IsDrivenBy ( tmp ) then
23477: LD_VAR 0 13
23481: PPUSH
23482: CALL_OW 311
23486: IFFALSE 23490
// continue ;
23488: GO 23289
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23490: LD_VAR 0 6
23494: PPUSH
23495: LD_INT 3
23497: PUSH
23498: LD_INT 60
23500: PUSH
23501: EMPTY
23502: LIST
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 3
23510: PUSH
23511: LD_INT 55
23513: PUSH
23514: EMPTY
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: PPUSH
23525: CALL_OW 72
23529: IFFALSE 23637
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23531: LD_ADDR_VAR 0 18
23535: PUSH
23536: LD_VAR 0 6
23540: PPUSH
23541: LD_INT 3
23543: PUSH
23544: LD_INT 60
23546: PUSH
23547: EMPTY
23548: LIST
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: LD_INT 3
23556: PUSH
23557: LD_INT 55
23559: PUSH
23560: EMPTY
23561: LIST
23562: PUSH
23563: EMPTY
23564: LIST
23565: LIST
23566: PUSH
23567: EMPTY
23568: LIST
23569: LIST
23570: PPUSH
23571: CALL_OW 72
23575: PUSH
23576: LD_INT 1
23578: ARRAY
23579: ST_TO_ADDR
// if IsInUnit ( driver ) then
23580: LD_VAR 0 18
23584: PPUSH
23585: CALL_OW 310
23589: IFFALSE 23600
// ComExit ( driver ) ;
23591: LD_VAR 0 18
23595: PPUSH
23596: CALL 48981 0 1
// AddComEnterUnit ( driver , tmp ) ;
23600: LD_VAR 0 18
23604: PPUSH
23605: LD_VAR 0 13
23609: PPUSH
23610: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23614: LD_VAR 0 18
23618: PPUSH
23619: LD_VAR 0 7
23623: PPUSH
23624: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23628: LD_VAR 0 18
23632: PPUSH
23633: CALL_OW 181
// end ; continue ;
23637: GO 23289
// end ; if not cleaners or not tmp in cleaners then
23639: LD_VAR 0 6
23643: NOT
23644: PUSH
23645: LD_VAR 0 13
23649: PUSH
23650: LD_VAR 0 6
23654: IN
23655: NOT
23656: OR
23657: IFFALSE 23964
// begin if dep then
23659: LD_VAR 0 17
23663: IFFALSE 23799
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23665: LD_ADDR_VAR 0 16
23669: PUSH
23670: LD_VAR 0 17
23674: PUSH
23675: LD_INT 1
23677: ARRAY
23678: PPUSH
23679: CALL_OW 250
23683: PPUSH
23684: LD_VAR 0 17
23688: PUSH
23689: LD_INT 1
23691: ARRAY
23692: PPUSH
23693: CALL_OW 254
23697: PPUSH
23698: LD_INT 5
23700: PPUSH
23701: CALL_OW 272
23705: PUSH
23706: LD_VAR 0 17
23710: PUSH
23711: LD_INT 1
23713: ARRAY
23714: PPUSH
23715: CALL_OW 251
23719: PPUSH
23720: LD_VAR 0 17
23724: PUSH
23725: LD_INT 1
23727: ARRAY
23728: PPUSH
23729: CALL_OW 254
23733: PPUSH
23734: LD_INT 5
23736: PPUSH
23737: CALL_OW 273
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23746: LD_VAR 0 16
23750: PUSH
23751: LD_INT 1
23753: ARRAY
23754: PPUSH
23755: LD_VAR 0 16
23759: PUSH
23760: LD_INT 2
23762: ARRAY
23763: PPUSH
23764: CALL_OW 488
23768: IFFALSE 23799
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23770: LD_VAR 0 13
23774: PPUSH
23775: LD_VAR 0 16
23779: PUSH
23780: LD_INT 1
23782: ARRAY
23783: PPUSH
23784: LD_VAR 0 16
23788: PUSH
23789: LD_INT 2
23791: ARRAY
23792: PPUSH
23793: CALL_OW 111
// continue ;
23797: GO 23289
// end ; end ; r := GetDir ( tmp ) ;
23799: LD_ADDR_VAR 0 15
23803: PUSH
23804: LD_VAR 0 13
23808: PPUSH
23809: CALL_OW 254
23813: ST_TO_ADDR
// if r = 5 then
23814: LD_VAR 0 15
23818: PUSH
23819: LD_INT 5
23821: EQUAL
23822: IFFALSE 23832
// r := 0 ;
23824: LD_ADDR_VAR 0 15
23828: PUSH
23829: LD_INT 0
23831: ST_TO_ADDR
// for j = r to 5 do
23832: LD_ADDR_VAR 0 10
23836: PUSH
23837: DOUBLE
23838: LD_VAR 0 15
23842: DEC
23843: ST_TO_ADDR
23844: LD_INT 5
23846: PUSH
23847: FOR_TO
23848: IFFALSE 23962
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23850: LD_ADDR_VAR 0 11
23854: PUSH
23855: LD_VAR 0 13
23859: PPUSH
23860: CALL_OW 250
23864: PPUSH
23865: LD_VAR 0 10
23869: PPUSH
23870: LD_INT 2
23872: PPUSH
23873: CALL_OW 272
23877: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23878: LD_ADDR_VAR 0 12
23882: PUSH
23883: LD_VAR 0 13
23887: PPUSH
23888: CALL_OW 251
23892: PPUSH
23893: LD_VAR 0 10
23897: PPUSH
23898: LD_INT 2
23900: PPUSH
23901: CALL_OW 273
23905: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23906: LD_VAR 0 11
23910: PPUSH
23911: LD_VAR 0 12
23915: PPUSH
23916: CALL_OW 488
23920: PUSH
23921: LD_VAR 0 11
23925: PPUSH
23926: LD_VAR 0 12
23930: PPUSH
23931: CALL_OW 428
23935: NOT
23936: AND
23937: IFFALSE 23960
// begin ComMoveXY ( tmp , _x , _y ) ;
23939: LD_VAR 0 13
23943: PPUSH
23944: LD_VAR 0 11
23948: PPUSH
23949: LD_VAR 0 12
23953: PPUSH
23954: CALL_OW 111
// break ;
23958: GO 23962
// end ; end ;
23960: GO 23847
23962: POP
23963: POP
// end ; end ;
23964: GO 23289
23966: POP
23967: POP
// end ;
23968: LD_VAR 0 8
23972: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23973: LD_INT 0
23975: PPUSH
// result := true ;
23976: LD_ADDR_VAR 0 3
23980: PUSH
23981: LD_INT 1
23983: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23984: LD_VAR 0 2
23988: PUSH
23989: LD_INT 24
23991: DOUBLE
23992: EQUAL
23993: IFTRUE 24003
23995: LD_INT 33
23997: DOUBLE
23998: EQUAL
23999: IFTRUE 24003
24001: GO 24028
24003: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
24004: LD_ADDR_VAR 0 3
24008: PUSH
24009: LD_INT 32
24011: PPUSH
24012: LD_VAR 0 1
24016: PPUSH
24017: CALL_OW 321
24021: PUSH
24022: LD_INT 2
24024: EQUAL
24025: ST_TO_ADDR
24026: GO 24344
24028: LD_INT 20
24030: DOUBLE
24031: EQUAL
24032: IFTRUE 24036
24034: GO 24061
24036: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
24037: LD_ADDR_VAR 0 3
24041: PUSH
24042: LD_INT 6
24044: PPUSH
24045: LD_VAR 0 1
24049: PPUSH
24050: CALL_OW 321
24054: PUSH
24055: LD_INT 2
24057: EQUAL
24058: ST_TO_ADDR
24059: GO 24344
24061: LD_INT 22
24063: DOUBLE
24064: EQUAL
24065: IFTRUE 24075
24067: LD_INT 36
24069: DOUBLE
24070: EQUAL
24071: IFTRUE 24075
24073: GO 24100
24075: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
24076: LD_ADDR_VAR 0 3
24080: PUSH
24081: LD_INT 15
24083: PPUSH
24084: LD_VAR 0 1
24088: PPUSH
24089: CALL_OW 321
24093: PUSH
24094: LD_INT 2
24096: EQUAL
24097: ST_TO_ADDR
24098: GO 24344
24100: LD_INT 30
24102: DOUBLE
24103: EQUAL
24104: IFTRUE 24108
24106: GO 24133
24108: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24109: LD_ADDR_VAR 0 3
24113: PUSH
24114: LD_INT 20
24116: PPUSH
24117: LD_VAR 0 1
24121: PPUSH
24122: CALL_OW 321
24126: PUSH
24127: LD_INT 2
24129: EQUAL
24130: ST_TO_ADDR
24131: GO 24344
24133: LD_INT 28
24135: DOUBLE
24136: EQUAL
24137: IFTRUE 24147
24139: LD_INT 21
24141: DOUBLE
24142: EQUAL
24143: IFTRUE 24147
24145: GO 24172
24147: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24148: LD_ADDR_VAR 0 3
24152: PUSH
24153: LD_INT 21
24155: PPUSH
24156: LD_VAR 0 1
24160: PPUSH
24161: CALL_OW 321
24165: PUSH
24166: LD_INT 2
24168: EQUAL
24169: ST_TO_ADDR
24170: GO 24344
24172: LD_INT 16
24174: DOUBLE
24175: EQUAL
24176: IFTRUE 24180
24178: GO 24205
24180: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24181: LD_ADDR_VAR 0 3
24185: PUSH
24186: LD_INT 84
24188: PPUSH
24189: LD_VAR 0 1
24193: PPUSH
24194: CALL_OW 321
24198: PUSH
24199: LD_INT 2
24201: EQUAL
24202: ST_TO_ADDR
24203: GO 24344
24205: LD_INT 19
24207: DOUBLE
24208: EQUAL
24209: IFTRUE 24219
24211: LD_INT 23
24213: DOUBLE
24214: EQUAL
24215: IFTRUE 24219
24217: GO 24244
24219: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24220: LD_ADDR_VAR 0 3
24224: PUSH
24225: LD_INT 83
24227: PPUSH
24228: LD_VAR 0 1
24232: PPUSH
24233: CALL_OW 321
24237: PUSH
24238: LD_INT 2
24240: EQUAL
24241: ST_TO_ADDR
24242: GO 24344
24244: LD_INT 17
24246: DOUBLE
24247: EQUAL
24248: IFTRUE 24252
24250: GO 24277
24252: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24253: LD_ADDR_VAR 0 3
24257: PUSH
24258: LD_INT 39
24260: PPUSH
24261: LD_VAR 0 1
24265: PPUSH
24266: CALL_OW 321
24270: PUSH
24271: LD_INT 2
24273: EQUAL
24274: ST_TO_ADDR
24275: GO 24344
24277: LD_INT 18
24279: DOUBLE
24280: EQUAL
24281: IFTRUE 24285
24283: GO 24310
24285: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24286: LD_ADDR_VAR 0 3
24290: PUSH
24291: LD_INT 40
24293: PPUSH
24294: LD_VAR 0 1
24298: PPUSH
24299: CALL_OW 321
24303: PUSH
24304: LD_INT 2
24306: EQUAL
24307: ST_TO_ADDR
24308: GO 24344
24310: LD_INT 27
24312: DOUBLE
24313: EQUAL
24314: IFTRUE 24318
24316: GO 24343
24318: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24319: LD_ADDR_VAR 0 3
24323: PUSH
24324: LD_INT 35
24326: PPUSH
24327: LD_VAR 0 1
24331: PPUSH
24332: CALL_OW 321
24336: PUSH
24337: LD_INT 2
24339: EQUAL
24340: ST_TO_ADDR
24341: GO 24344
24343: POP
// end ;
24344: LD_VAR 0 3
24348: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24349: LD_INT 0
24351: PPUSH
24352: PPUSH
24353: PPUSH
24354: PPUSH
24355: PPUSH
24356: PPUSH
24357: PPUSH
24358: PPUSH
24359: PPUSH
24360: PPUSH
24361: PPUSH
// result := false ;
24362: LD_ADDR_VAR 0 6
24366: PUSH
24367: LD_INT 0
24369: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24370: LD_VAR 0 1
24374: NOT
24375: PUSH
24376: LD_VAR 0 1
24380: PPUSH
24381: CALL_OW 266
24385: PUSH
24386: LD_INT 0
24388: PUSH
24389: LD_INT 1
24391: PUSH
24392: EMPTY
24393: LIST
24394: LIST
24395: IN
24396: NOT
24397: OR
24398: PUSH
24399: LD_VAR 0 2
24403: NOT
24404: OR
24405: PUSH
24406: LD_VAR 0 5
24410: PUSH
24411: LD_INT 0
24413: PUSH
24414: LD_INT 1
24416: PUSH
24417: LD_INT 2
24419: PUSH
24420: LD_INT 3
24422: PUSH
24423: LD_INT 4
24425: PUSH
24426: LD_INT 5
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: LIST
24435: LIST
24436: IN
24437: NOT
24438: OR
24439: PUSH
24440: LD_VAR 0 3
24444: PPUSH
24445: LD_VAR 0 4
24449: PPUSH
24450: CALL_OW 488
24454: NOT
24455: OR
24456: IFFALSE 24460
// exit ;
24458: GO 25196
// side := GetSide ( depot ) ;
24460: LD_ADDR_VAR 0 9
24464: PUSH
24465: LD_VAR 0 1
24469: PPUSH
24470: CALL_OW 255
24474: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24475: LD_VAR 0 9
24479: PPUSH
24480: LD_VAR 0 2
24484: PPUSH
24485: CALL 23973 0 2
24489: NOT
24490: IFFALSE 24494
// exit ;
24492: GO 25196
// pom := GetBase ( depot ) ;
24494: LD_ADDR_VAR 0 10
24498: PUSH
24499: LD_VAR 0 1
24503: PPUSH
24504: CALL_OW 274
24508: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24509: LD_ADDR_VAR 0 11
24513: PUSH
24514: LD_VAR 0 2
24518: PPUSH
24519: LD_VAR 0 1
24523: PPUSH
24524: CALL_OW 248
24528: PPUSH
24529: CALL_OW 450
24533: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24534: LD_VAR 0 10
24538: PPUSH
24539: LD_INT 1
24541: PPUSH
24542: CALL_OW 275
24546: PUSH
24547: LD_VAR 0 11
24551: PUSH
24552: LD_INT 1
24554: ARRAY
24555: GREATEREQUAL
24556: PUSH
24557: LD_VAR 0 10
24561: PPUSH
24562: LD_INT 2
24564: PPUSH
24565: CALL_OW 275
24569: PUSH
24570: LD_VAR 0 11
24574: PUSH
24575: LD_INT 2
24577: ARRAY
24578: GREATEREQUAL
24579: AND
24580: PUSH
24581: LD_VAR 0 10
24585: PPUSH
24586: LD_INT 3
24588: PPUSH
24589: CALL_OW 275
24593: PUSH
24594: LD_VAR 0 11
24598: PUSH
24599: LD_INT 3
24601: ARRAY
24602: GREATEREQUAL
24603: AND
24604: NOT
24605: IFFALSE 24609
// exit ;
24607: GO 25196
// if GetBType ( depot ) = b_depot then
24609: LD_VAR 0 1
24613: PPUSH
24614: CALL_OW 266
24618: PUSH
24619: LD_INT 0
24621: EQUAL
24622: IFFALSE 24634
// dist := 28 else
24624: LD_ADDR_VAR 0 14
24628: PUSH
24629: LD_INT 28
24631: ST_TO_ADDR
24632: GO 24642
// dist := 36 ;
24634: LD_ADDR_VAR 0 14
24638: PUSH
24639: LD_INT 36
24641: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24642: LD_VAR 0 1
24646: PPUSH
24647: LD_VAR 0 3
24651: PPUSH
24652: LD_VAR 0 4
24656: PPUSH
24657: CALL_OW 297
24661: PUSH
24662: LD_VAR 0 14
24666: GREATER
24667: IFFALSE 24671
// exit ;
24669: GO 25196
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24671: LD_ADDR_VAR 0 12
24675: PUSH
24676: LD_VAR 0 2
24680: PPUSH
24681: LD_VAR 0 3
24685: PPUSH
24686: LD_VAR 0 4
24690: PPUSH
24691: LD_VAR 0 5
24695: PPUSH
24696: LD_VAR 0 1
24700: PPUSH
24701: CALL_OW 248
24705: PPUSH
24706: LD_INT 0
24708: PPUSH
24709: CALL 25201 0 6
24713: ST_TO_ADDR
// if not hexes then
24714: LD_VAR 0 12
24718: NOT
24719: IFFALSE 24723
// exit ;
24721: GO 25196
// hex := GetHexInfo ( x , y ) ;
24723: LD_ADDR_VAR 0 15
24727: PUSH
24728: LD_VAR 0 3
24732: PPUSH
24733: LD_VAR 0 4
24737: PPUSH
24738: CALL_OW 546
24742: ST_TO_ADDR
// if hex [ 1 ] then
24743: LD_VAR 0 15
24747: PUSH
24748: LD_INT 1
24750: ARRAY
24751: IFFALSE 24755
// exit ;
24753: GO 25196
// height := hex [ 2 ] ;
24755: LD_ADDR_VAR 0 13
24759: PUSH
24760: LD_VAR 0 15
24764: PUSH
24765: LD_INT 2
24767: ARRAY
24768: ST_TO_ADDR
// for i = 1 to hexes do
24769: LD_ADDR_VAR 0 7
24773: PUSH
24774: DOUBLE
24775: LD_INT 1
24777: DEC
24778: ST_TO_ADDR
24779: LD_VAR 0 12
24783: PUSH
24784: FOR_TO
24785: IFFALSE 25115
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24787: LD_VAR 0 12
24791: PUSH
24792: LD_VAR 0 7
24796: ARRAY
24797: PUSH
24798: LD_INT 1
24800: ARRAY
24801: PPUSH
24802: LD_VAR 0 12
24806: PUSH
24807: LD_VAR 0 7
24811: ARRAY
24812: PUSH
24813: LD_INT 2
24815: ARRAY
24816: PPUSH
24817: CALL_OW 488
24821: NOT
24822: PUSH
24823: LD_VAR 0 12
24827: PUSH
24828: LD_VAR 0 7
24832: ARRAY
24833: PUSH
24834: LD_INT 1
24836: ARRAY
24837: PPUSH
24838: LD_VAR 0 12
24842: PUSH
24843: LD_VAR 0 7
24847: ARRAY
24848: PUSH
24849: LD_INT 2
24851: ARRAY
24852: PPUSH
24853: CALL_OW 428
24857: PUSH
24858: LD_INT 0
24860: GREATER
24861: OR
24862: PUSH
24863: LD_VAR 0 12
24867: PUSH
24868: LD_VAR 0 7
24872: ARRAY
24873: PUSH
24874: LD_INT 1
24876: ARRAY
24877: PPUSH
24878: LD_VAR 0 12
24882: PUSH
24883: LD_VAR 0 7
24887: ARRAY
24888: PUSH
24889: LD_INT 2
24891: ARRAY
24892: PPUSH
24893: CALL_OW 351
24897: OR
24898: IFFALSE 24904
// exit ;
24900: POP
24901: POP
24902: GO 25196
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24904: LD_ADDR_VAR 0 8
24908: PUSH
24909: LD_VAR 0 12
24913: PUSH
24914: LD_VAR 0 7
24918: ARRAY
24919: PUSH
24920: LD_INT 1
24922: ARRAY
24923: PPUSH
24924: LD_VAR 0 12
24928: PUSH
24929: LD_VAR 0 7
24933: ARRAY
24934: PUSH
24935: LD_INT 2
24937: ARRAY
24938: PPUSH
24939: CALL_OW 546
24943: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24944: LD_VAR 0 8
24948: PUSH
24949: LD_INT 1
24951: ARRAY
24952: PUSH
24953: LD_VAR 0 8
24957: PUSH
24958: LD_INT 2
24960: ARRAY
24961: PUSH
24962: LD_VAR 0 13
24966: PUSH
24967: LD_INT 2
24969: PLUS
24970: GREATER
24971: OR
24972: PUSH
24973: LD_VAR 0 8
24977: PUSH
24978: LD_INT 2
24980: ARRAY
24981: PUSH
24982: LD_VAR 0 13
24986: PUSH
24987: LD_INT 2
24989: MINUS
24990: LESS
24991: OR
24992: PUSH
24993: LD_VAR 0 8
24997: PUSH
24998: LD_INT 3
25000: ARRAY
25001: PUSH
25002: LD_INT 0
25004: PUSH
25005: LD_INT 8
25007: PUSH
25008: LD_INT 9
25010: PUSH
25011: LD_INT 10
25013: PUSH
25014: LD_INT 11
25016: PUSH
25017: LD_INT 12
25019: PUSH
25020: LD_INT 13
25022: PUSH
25023: LD_INT 16
25025: PUSH
25026: LD_INT 17
25028: PUSH
25029: LD_INT 18
25031: PUSH
25032: LD_INT 19
25034: PUSH
25035: LD_INT 20
25037: PUSH
25038: LD_INT 21
25040: PUSH
25041: EMPTY
25042: LIST
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: LIST
25050: LIST
25051: LIST
25052: LIST
25053: LIST
25054: LIST
25055: IN
25056: NOT
25057: OR
25058: PUSH
25059: LD_VAR 0 8
25063: PUSH
25064: LD_INT 5
25066: ARRAY
25067: NOT
25068: OR
25069: PUSH
25070: LD_VAR 0 8
25074: PUSH
25075: LD_INT 6
25077: ARRAY
25078: PUSH
25079: LD_INT 1
25081: PUSH
25082: LD_INT 2
25084: PUSH
25085: LD_INT 7
25087: PUSH
25088: LD_INT 9
25090: PUSH
25091: LD_INT 10
25093: PUSH
25094: LD_INT 11
25096: PUSH
25097: EMPTY
25098: LIST
25099: LIST
25100: LIST
25101: LIST
25102: LIST
25103: LIST
25104: IN
25105: NOT
25106: OR
25107: IFFALSE 25113
// exit ;
25109: POP
25110: POP
25111: GO 25196
// end ;
25113: GO 24784
25115: POP
25116: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25117: LD_VAR 0 9
25121: PPUSH
25122: LD_VAR 0 3
25126: PPUSH
25127: LD_VAR 0 4
25131: PPUSH
25132: LD_INT 20
25134: PPUSH
25135: CALL 17148 0 4
25139: PUSH
25140: LD_INT 4
25142: ARRAY
25143: IFFALSE 25147
// exit ;
25145: GO 25196
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25147: LD_VAR 0 2
25151: PUSH
25152: LD_INT 29
25154: PUSH
25155: LD_INT 30
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: IN
25162: PUSH
25163: LD_VAR 0 3
25167: PPUSH
25168: LD_VAR 0 4
25172: PPUSH
25173: LD_VAR 0 9
25177: PPUSH
25178: CALL_OW 440
25182: NOT
25183: AND
25184: IFFALSE 25188
// exit ;
25186: GO 25196
// result := true ;
25188: LD_ADDR_VAR 0 6
25192: PUSH
25193: LD_INT 1
25195: ST_TO_ADDR
// end ;
25196: LD_VAR 0 6
25200: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25201: LD_INT 0
25203: PPUSH
25204: PPUSH
25205: PPUSH
25206: PPUSH
25207: PPUSH
25208: PPUSH
25209: PPUSH
25210: PPUSH
25211: PPUSH
25212: PPUSH
25213: PPUSH
25214: PPUSH
25215: PPUSH
25216: PPUSH
25217: PPUSH
25218: PPUSH
25219: PPUSH
25220: PPUSH
25221: PPUSH
25222: PPUSH
25223: PPUSH
25224: PPUSH
25225: PPUSH
25226: PPUSH
25227: PPUSH
25228: PPUSH
25229: PPUSH
25230: PPUSH
25231: PPUSH
25232: PPUSH
25233: PPUSH
25234: PPUSH
25235: PPUSH
25236: PPUSH
25237: PPUSH
25238: PPUSH
25239: PPUSH
25240: PPUSH
25241: PPUSH
25242: PPUSH
25243: PPUSH
25244: PPUSH
25245: PPUSH
25246: PPUSH
25247: PPUSH
25248: PPUSH
25249: PPUSH
25250: PPUSH
25251: PPUSH
25252: PPUSH
25253: PPUSH
25254: PPUSH
25255: PPUSH
25256: PPUSH
25257: PPUSH
25258: PPUSH
25259: PPUSH
25260: PPUSH
// result = [ ] ;
25261: LD_ADDR_VAR 0 7
25265: PUSH
25266: EMPTY
25267: ST_TO_ADDR
// temp_list = [ ] ;
25268: LD_ADDR_VAR 0 9
25272: PUSH
25273: EMPTY
25274: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25275: LD_VAR 0 4
25279: PUSH
25280: LD_INT 0
25282: PUSH
25283: LD_INT 1
25285: PUSH
25286: LD_INT 2
25288: PUSH
25289: LD_INT 3
25291: PUSH
25292: LD_INT 4
25294: PUSH
25295: LD_INT 5
25297: PUSH
25298: EMPTY
25299: LIST
25300: LIST
25301: LIST
25302: LIST
25303: LIST
25304: LIST
25305: IN
25306: NOT
25307: PUSH
25308: LD_VAR 0 1
25312: PUSH
25313: LD_INT 0
25315: PUSH
25316: LD_INT 1
25318: PUSH
25319: EMPTY
25320: LIST
25321: LIST
25322: IN
25323: PUSH
25324: LD_VAR 0 5
25328: PUSH
25329: LD_INT 1
25331: PUSH
25332: LD_INT 2
25334: PUSH
25335: LD_INT 3
25337: PUSH
25338: EMPTY
25339: LIST
25340: LIST
25341: LIST
25342: IN
25343: NOT
25344: AND
25345: OR
25346: IFFALSE 25350
// exit ;
25348: GO 43741
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25350: LD_VAR 0 1
25354: PUSH
25355: LD_INT 6
25357: PUSH
25358: LD_INT 7
25360: PUSH
25361: LD_INT 8
25363: PUSH
25364: LD_INT 13
25366: PUSH
25367: LD_INT 12
25369: PUSH
25370: LD_INT 15
25372: PUSH
25373: LD_INT 11
25375: PUSH
25376: LD_INT 14
25378: PUSH
25379: LD_INT 10
25381: PUSH
25382: EMPTY
25383: LIST
25384: LIST
25385: LIST
25386: LIST
25387: LIST
25388: LIST
25389: LIST
25390: LIST
25391: LIST
25392: IN
25393: IFFALSE 25403
// btype = b_lab ;
25395: LD_ADDR_VAR 0 1
25399: PUSH
25400: LD_INT 6
25402: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25403: LD_VAR 0 6
25407: PUSH
25408: LD_INT 0
25410: PUSH
25411: LD_INT 1
25413: PUSH
25414: LD_INT 2
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: LIST
25421: IN
25422: NOT
25423: PUSH
25424: LD_VAR 0 1
25428: PUSH
25429: LD_INT 0
25431: PUSH
25432: LD_INT 1
25434: PUSH
25435: LD_INT 2
25437: PUSH
25438: LD_INT 3
25440: PUSH
25441: LD_INT 6
25443: PUSH
25444: LD_INT 36
25446: PUSH
25447: LD_INT 4
25449: PUSH
25450: LD_INT 5
25452: PUSH
25453: LD_INT 31
25455: PUSH
25456: LD_INT 32
25458: PUSH
25459: LD_INT 33
25461: PUSH
25462: EMPTY
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: IN
25475: NOT
25476: PUSH
25477: LD_VAR 0 6
25481: PUSH
25482: LD_INT 1
25484: EQUAL
25485: AND
25486: OR
25487: PUSH
25488: LD_VAR 0 1
25492: PUSH
25493: LD_INT 2
25495: PUSH
25496: LD_INT 3
25498: PUSH
25499: EMPTY
25500: LIST
25501: LIST
25502: IN
25503: NOT
25504: PUSH
25505: LD_VAR 0 6
25509: PUSH
25510: LD_INT 2
25512: EQUAL
25513: AND
25514: OR
25515: IFFALSE 25525
// mode = 0 ;
25517: LD_ADDR_VAR 0 6
25521: PUSH
25522: LD_INT 0
25524: ST_TO_ADDR
// case mode of 0 :
25525: LD_VAR 0 6
25529: PUSH
25530: LD_INT 0
25532: DOUBLE
25533: EQUAL
25534: IFTRUE 25538
25536: GO 36991
25538: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25539: LD_ADDR_VAR 0 11
25543: PUSH
25544: LD_INT 0
25546: PUSH
25547: LD_INT 0
25549: PUSH
25550: EMPTY
25551: LIST
25552: LIST
25553: PUSH
25554: LD_INT 0
25556: PUSH
25557: LD_INT 1
25559: NEG
25560: PUSH
25561: EMPTY
25562: LIST
25563: LIST
25564: PUSH
25565: LD_INT 1
25567: PUSH
25568: LD_INT 0
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: PUSH
25575: LD_INT 1
25577: PUSH
25578: LD_INT 1
25580: PUSH
25581: EMPTY
25582: LIST
25583: LIST
25584: PUSH
25585: LD_INT 0
25587: PUSH
25588: LD_INT 1
25590: PUSH
25591: EMPTY
25592: LIST
25593: LIST
25594: PUSH
25595: LD_INT 1
25597: NEG
25598: PUSH
25599: LD_INT 0
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 1
25608: NEG
25609: PUSH
25610: LD_INT 1
25612: NEG
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: LD_INT 1
25620: NEG
25621: PUSH
25622: LD_INT 2
25624: NEG
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: PUSH
25630: LD_INT 0
25632: PUSH
25633: LD_INT 2
25635: NEG
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: LD_INT 1
25643: PUSH
25644: LD_INT 1
25646: NEG
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: PUSH
25652: LD_INT 1
25654: PUSH
25655: LD_INT 2
25657: PUSH
25658: EMPTY
25659: LIST
25660: LIST
25661: PUSH
25662: LD_INT 0
25664: PUSH
25665: LD_INT 2
25667: PUSH
25668: EMPTY
25669: LIST
25670: LIST
25671: PUSH
25672: LD_INT 1
25674: NEG
25675: PUSH
25676: LD_INT 1
25678: PUSH
25679: EMPTY
25680: LIST
25681: LIST
25682: PUSH
25683: LD_INT 1
25685: PUSH
25686: LD_INT 3
25688: PUSH
25689: EMPTY
25690: LIST
25691: LIST
25692: PUSH
25693: LD_INT 0
25695: PUSH
25696: LD_INT 3
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: PUSH
25703: LD_INT 1
25705: NEG
25706: PUSH
25707: LD_INT 2
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: LIST
25718: LIST
25719: LIST
25720: LIST
25721: LIST
25722: LIST
25723: LIST
25724: LIST
25725: LIST
25726: LIST
25727: LIST
25728: LIST
25729: LIST
25730: LIST
25731: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25732: LD_ADDR_VAR 0 12
25736: PUSH
25737: LD_INT 0
25739: PUSH
25740: LD_INT 0
25742: PUSH
25743: EMPTY
25744: LIST
25745: LIST
25746: PUSH
25747: LD_INT 0
25749: PUSH
25750: LD_INT 1
25752: NEG
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: PUSH
25758: LD_INT 1
25760: PUSH
25761: LD_INT 0
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: LD_INT 1
25770: PUSH
25771: LD_INT 1
25773: PUSH
25774: EMPTY
25775: LIST
25776: LIST
25777: PUSH
25778: LD_INT 0
25780: PUSH
25781: LD_INT 1
25783: PUSH
25784: EMPTY
25785: LIST
25786: LIST
25787: PUSH
25788: LD_INT 1
25790: NEG
25791: PUSH
25792: LD_INT 0
25794: PUSH
25795: EMPTY
25796: LIST
25797: LIST
25798: PUSH
25799: LD_INT 1
25801: NEG
25802: PUSH
25803: LD_INT 1
25805: NEG
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: PUSH
25811: LD_INT 1
25813: PUSH
25814: LD_INT 1
25816: NEG
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 2
25824: PUSH
25825: LD_INT 0
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 2
25834: PUSH
25835: LD_INT 1
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 1
25844: NEG
25845: PUSH
25846: LD_INT 1
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 2
25855: NEG
25856: PUSH
25857: LD_INT 0
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 2
25866: NEG
25867: PUSH
25868: LD_INT 1
25870: NEG
25871: PUSH
25872: EMPTY
25873: LIST
25874: LIST
25875: PUSH
25876: LD_INT 2
25878: NEG
25879: PUSH
25880: LD_INT 1
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: LD_INT 3
25889: NEG
25890: PUSH
25891: LD_INT 0
25893: PUSH
25894: EMPTY
25895: LIST
25896: LIST
25897: PUSH
25898: LD_INT 3
25900: NEG
25901: PUSH
25902: LD_INT 1
25904: NEG
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: PUSH
25910: EMPTY
25911: LIST
25912: LIST
25913: LIST
25914: LIST
25915: LIST
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: LIST
25921: LIST
25922: LIST
25923: LIST
25924: LIST
25925: LIST
25926: LIST
25927: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25928: LD_ADDR_VAR 0 13
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 0
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: LD_INT 0
25945: PUSH
25946: LD_INT 1
25948: NEG
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PUSH
25954: LD_INT 1
25956: PUSH
25957: LD_INT 0
25959: PUSH
25960: EMPTY
25961: LIST
25962: LIST
25963: PUSH
25964: LD_INT 1
25966: PUSH
25967: LD_INT 1
25969: PUSH
25970: EMPTY
25971: LIST
25972: LIST
25973: PUSH
25974: LD_INT 0
25976: PUSH
25977: LD_INT 1
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: NEG
25987: PUSH
25988: LD_INT 0
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 1
25997: NEG
25998: PUSH
25999: LD_INT 1
26001: NEG
26002: PUSH
26003: EMPTY
26004: LIST
26005: LIST
26006: PUSH
26007: LD_INT 1
26009: NEG
26010: PUSH
26011: LD_INT 2
26013: NEG
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 2
26021: PUSH
26022: LD_INT 1
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: LD_INT 2
26031: PUSH
26032: LD_INT 2
26034: PUSH
26035: EMPTY
26036: LIST
26037: LIST
26038: PUSH
26039: LD_INT 1
26041: PUSH
26042: LD_INT 2
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: LD_INT 2
26051: NEG
26052: PUSH
26053: LD_INT 1
26055: NEG
26056: PUSH
26057: EMPTY
26058: LIST
26059: LIST
26060: PUSH
26061: LD_INT 2
26063: NEG
26064: PUSH
26065: LD_INT 2
26067: NEG
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 2
26075: NEG
26076: PUSH
26077: LD_INT 3
26079: NEG
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 3
26087: NEG
26088: PUSH
26089: LD_INT 2
26091: NEG
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 3
26099: NEG
26100: PUSH
26101: LD_INT 3
26103: NEG
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: LIST
26113: LIST
26114: LIST
26115: LIST
26116: LIST
26117: LIST
26118: LIST
26119: LIST
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: LIST
26125: LIST
26126: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26127: LD_ADDR_VAR 0 14
26131: PUSH
26132: LD_INT 0
26134: PUSH
26135: LD_INT 0
26137: PUSH
26138: EMPTY
26139: LIST
26140: LIST
26141: PUSH
26142: LD_INT 0
26144: PUSH
26145: LD_INT 1
26147: NEG
26148: PUSH
26149: EMPTY
26150: LIST
26151: LIST
26152: PUSH
26153: LD_INT 1
26155: PUSH
26156: LD_INT 0
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: LD_INT 1
26165: PUSH
26166: LD_INT 1
26168: PUSH
26169: EMPTY
26170: LIST
26171: LIST
26172: PUSH
26173: LD_INT 0
26175: PUSH
26176: LD_INT 1
26178: PUSH
26179: EMPTY
26180: LIST
26181: LIST
26182: PUSH
26183: LD_INT 1
26185: NEG
26186: PUSH
26187: LD_INT 0
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: LD_INT 1
26196: NEG
26197: PUSH
26198: LD_INT 1
26200: NEG
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 1
26208: NEG
26209: PUSH
26210: LD_INT 2
26212: NEG
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: LD_INT 0
26220: PUSH
26221: LD_INT 2
26223: NEG
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: PUSH
26229: LD_INT 1
26231: PUSH
26232: LD_INT 1
26234: NEG
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: PUSH
26240: LD_INT 1
26242: PUSH
26243: LD_INT 2
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PUSH
26250: LD_INT 0
26252: PUSH
26253: LD_INT 2
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 1
26262: NEG
26263: PUSH
26264: LD_INT 1
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 1
26273: NEG
26274: PUSH
26275: LD_INT 3
26277: NEG
26278: PUSH
26279: EMPTY
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: LD_INT 3
26288: NEG
26289: PUSH
26290: EMPTY
26291: LIST
26292: LIST
26293: PUSH
26294: LD_INT 1
26296: PUSH
26297: LD_INT 2
26299: NEG
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: PUSH
26305: EMPTY
26306: LIST
26307: LIST
26308: LIST
26309: LIST
26310: LIST
26311: LIST
26312: LIST
26313: LIST
26314: LIST
26315: LIST
26316: LIST
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: LIST
26322: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26323: LD_ADDR_VAR 0 15
26327: PUSH
26328: LD_INT 0
26330: PUSH
26331: LD_INT 0
26333: PUSH
26334: EMPTY
26335: LIST
26336: LIST
26337: PUSH
26338: LD_INT 0
26340: PUSH
26341: LD_INT 1
26343: NEG
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: PUSH
26349: LD_INT 1
26351: PUSH
26352: LD_INT 0
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PUSH
26359: LD_INT 1
26361: PUSH
26362: LD_INT 1
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: LD_INT 0
26371: PUSH
26372: LD_INT 1
26374: PUSH
26375: EMPTY
26376: LIST
26377: LIST
26378: PUSH
26379: LD_INT 1
26381: NEG
26382: PUSH
26383: LD_INT 0
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 1
26392: NEG
26393: PUSH
26394: LD_INT 1
26396: NEG
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: LD_INT 1
26404: PUSH
26405: LD_INT 1
26407: NEG
26408: PUSH
26409: EMPTY
26410: LIST
26411: LIST
26412: PUSH
26413: LD_INT 2
26415: PUSH
26416: LD_INT 0
26418: PUSH
26419: EMPTY
26420: LIST
26421: LIST
26422: PUSH
26423: LD_INT 2
26425: PUSH
26426: LD_INT 1
26428: PUSH
26429: EMPTY
26430: LIST
26431: LIST
26432: PUSH
26433: LD_INT 1
26435: NEG
26436: PUSH
26437: LD_INT 1
26439: PUSH
26440: EMPTY
26441: LIST
26442: LIST
26443: PUSH
26444: LD_INT 2
26446: NEG
26447: PUSH
26448: LD_INT 0
26450: PUSH
26451: EMPTY
26452: LIST
26453: LIST
26454: PUSH
26455: LD_INT 2
26457: NEG
26458: PUSH
26459: LD_INT 1
26461: NEG
26462: PUSH
26463: EMPTY
26464: LIST
26465: LIST
26466: PUSH
26467: LD_INT 2
26469: PUSH
26470: LD_INT 1
26472: NEG
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 3
26480: PUSH
26481: LD_INT 0
26483: PUSH
26484: EMPTY
26485: LIST
26486: LIST
26487: PUSH
26488: LD_INT 3
26490: PUSH
26491: LD_INT 1
26493: PUSH
26494: EMPTY
26495: LIST
26496: LIST
26497: PUSH
26498: EMPTY
26499: LIST
26500: LIST
26501: LIST
26502: LIST
26503: LIST
26504: LIST
26505: LIST
26506: LIST
26507: LIST
26508: LIST
26509: LIST
26510: LIST
26511: LIST
26512: LIST
26513: LIST
26514: LIST
26515: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26516: LD_ADDR_VAR 0 16
26520: PUSH
26521: LD_INT 0
26523: PUSH
26524: LD_INT 0
26526: PUSH
26527: EMPTY
26528: LIST
26529: LIST
26530: PUSH
26531: LD_INT 0
26533: PUSH
26534: LD_INT 1
26536: NEG
26537: PUSH
26538: EMPTY
26539: LIST
26540: LIST
26541: PUSH
26542: LD_INT 1
26544: PUSH
26545: LD_INT 0
26547: PUSH
26548: EMPTY
26549: LIST
26550: LIST
26551: PUSH
26552: LD_INT 1
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: PUSH
26562: LD_INT 0
26564: PUSH
26565: LD_INT 1
26567: PUSH
26568: EMPTY
26569: LIST
26570: LIST
26571: PUSH
26572: LD_INT 1
26574: NEG
26575: PUSH
26576: LD_INT 0
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 1
26585: NEG
26586: PUSH
26587: LD_INT 1
26589: NEG
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 1
26597: NEG
26598: PUSH
26599: LD_INT 2
26601: NEG
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PUSH
26607: LD_INT 2
26609: PUSH
26610: LD_INT 1
26612: PUSH
26613: EMPTY
26614: LIST
26615: LIST
26616: PUSH
26617: LD_INT 2
26619: PUSH
26620: LD_INT 2
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 1
26629: PUSH
26630: LD_INT 2
26632: PUSH
26633: EMPTY
26634: LIST
26635: LIST
26636: PUSH
26637: LD_INT 2
26639: NEG
26640: PUSH
26641: LD_INT 1
26643: NEG
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: LD_INT 2
26651: NEG
26652: PUSH
26653: LD_INT 2
26655: NEG
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: PUSH
26661: LD_INT 3
26663: PUSH
26664: LD_INT 2
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: PUSH
26671: LD_INT 3
26673: PUSH
26674: LD_INT 3
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 2
26683: PUSH
26684: LD_INT 3
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: LIST
26695: LIST
26696: LIST
26697: LIST
26698: LIST
26699: LIST
26700: LIST
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: LIST
26706: LIST
26707: LIST
26708: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26709: LD_ADDR_VAR 0 17
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 0
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: PUSH
26724: LD_INT 0
26726: PUSH
26727: LD_INT 1
26729: NEG
26730: PUSH
26731: EMPTY
26732: LIST
26733: LIST
26734: PUSH
26735: LD_INT 1
26737: PUSH
26738: LD_INT 0
26740: PUSH
26741: EMPTY
26742: LIST
26743: LIST
26744: PUSH
26745: LD_INT 1
26747: PUSH
26748: LD_INT 1
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PUSH
26755: LD_INT 0
26757: PUSH
26758: LD_INT 1
26760: PUSH
26761: EMPTY
26762: LIST
26763: LIST
26764: PUSH
26765: LD_INT 1
26767: NEG
26768: PUSH
26769: LD_INT 0
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: LD_INT 1
26778: NEG
26779: PUSH
26780: LD_INT 1
26782: NEG
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: LD_INT 2
26794: NEG
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 0
26802: PUSH
26803: LD_INT 2
26805: NEG
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: LD_INT 1
26813: PUSH
26814: LD_INT 1
26816: NEG
26817: PUSH
26818: EMPTY
26819: LIST
26820: LIST
26821: PUSH
26822: LD_INT 2
26824: PUSH
26825: LD_INT 0
26827: PUSH
26828: EMPTY
26829: LIST
26830: LIST
26831: PUSH
26832: LD_INT 2
26834: PUSH
26835: LD_INT 1
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 2
26844: PUSH
26845: LD_INT 2
26847: PUSH
26848: EMPTY
26849: LIST
26850: LIST
26851: PUSH
26852: LD_INT 1
26854: PUSH
26855: LD_INT 2
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: PUSH
26862: LD_INT 0
26864: PUSH
26865: LD_INT 2
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: LD_INT 1
26878: PUSH
26879: EMPTY
26880: LIST
26881: LIST
26882: PUSH
26883: LD_INT 2
26885: NEG
26886: PUSH
26887: LD_INT 0
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PUSH
26894: LD_INT 2
26896: NEG
26897: PUSH
26898: LD_INT 1
26900: NEG
26901: PUSH
26902: EMPTY
26903: LIST
26904: LIST
26905: PUSH
26906: LD_INT 2
26908: NEG
26909: PUSH
26910: LD_INT 2
26912: NEG
26913: PUSH
26914: EMPTY
26915: LIST
26916: LIST
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: LIST
26922: LIST
26923: LIST
26924: LIST
26925: LIST
26926: LIST
26927: LIST
26928: LIST
26929: LIST
26930: LIST
26931: LIST
26932: LIST
26933: LIST
26934: LIST
26935: LIST
26936: LIST
26937: LIST
26938: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26939: LD_ADDR_VAR 0 18
26943: PUSH
26944: LD_INT 0
26946: PUSH
26947: LD_INT 0
26949: PUSH
26950: EMPTY
26951: LIST
26952: LIST
26953: PUSH
26954: LD_INT 0
26956: PUSH
26957: LD_INT 1
26959: NEG
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: PUSH
26965: LD_INT 1
26967: PUSH
26968: LD_INT 0
26970: PUSH
26971: EMPTY
26972: LIST
26973: LIST
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: LD_INT 1
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: LD_INT 0
26987: PUSH
26988: LD_INT 1
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: LD_INT 1
26997: NEG
26998: PUSH
26999: LD_INT 0
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: LD_INT 1
27008: NEG
27009: PUSH
27010: LD_INT 1
27012: NEG
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 1
27020: NEG
27021: PUSH
27022: LD_INT 2
27024: NEG
27025: PUSH
27026: EMPTY
27027: LIST
27028: LIST
27029: PUSH
27030: LD_INT 0
27032: PUSH
27033: LD_INT 2
27035: NEG
27036: PUSH
27037: EMPTY
27038: LIST
27039: LIST
27040: PUSH
27041: LD_INT 1
27043: PUSH
27044: LD_INT 1
27046: NEG
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: PUSH
27052: LD_INT 2
27054: PUSH
27055: LD_INT 0
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 2
27064: PUSH
27065: LD_INT 1
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: LD_INT 2
27074: PUSH
27075: LD_INT 2
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 1
27084: PUSH
27085: LD_INT 2
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PUSH
27092: LD_INT 0
27094: PUSH
27095: LD_INT 2
27097: PUSH
27098: EMPTY
27099: LIST
27100: LIST
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: LD_INT 1
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 2
27115: NEG
27116: PUSH
27117: LD_INT 0
27119: PUSH
27120: EMPTY
27121: LIST
27122: LIST
27123: PUSH
27124: LD_INT 2
27126: NEG
27127: PUSH
27128: LD_INT 1
27130: NEG
27131: PUSH
27132: EMPTY
27133: LIST
27134: LIST
27135: PUSH
27136: LD_INT 2
27138: NEG
27139: PUSH
27140: LD_INT 2
27142: NEG
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: EMPTY
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: LIST
27154: LIST
27155: LIST
27156: LIST
27157: LIST
27158: LIST
27159: LIST
27160: LIST
27161: LIST
27162: LIST
27163: LIST
27164: LIST
27165: LIST
27166: LIST
27167: LIST
27168: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27169: LD_ADDR_VAR 0 19
27173: PUSH
27174: LD_INT 0
27176: PUSH
27177: LD_INT 0
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PUSH
27184: LD_INT 0
27186: PUSH
27187: LD_INT 1
27189: NEG
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 1
27197: PUSH
27198: LD_INT 0
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 1
27207: PUSH
27208: LD_INT 1
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: LD_INT 0
27217: PUSH
27218: LD_INT 1
27220: PUSH
27221: EMPTY
27222: LIST
27223: LIST
27224: PUSH
27225: LD_INT 1
27227: NEG
27228: PUSH
27229: LD_INT 0
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: LD_INT 1
27238: NEG
27239: PUSH
27240: LD_INT 1
27242: NEG
27243: PUSH
27244: EMPTY
27245: LIST
27246: LIST
27247: PUSH
27248: LD_INT 1
27250: NEG
27251: PUSH
27252: LD_INT 2
27254: NEG
27255: PUSH
27256: EMPTY
27257: LIST
27258: LIST
27259: PUSH
27260: LD_INT 0
27262: PUSH
27263: LD_INT 2
27265: NEG
27266: PUSH
27267: EMPTY
27268: LIST
27269: LIST
27270: PUSH
27271: LD_INT 1
27273: PUSH
27274: LD_INT 1
27276: NEG
27277: PUSH
27278: EMPTY
27279: LIST
27280: LIST
27281: PUSH
27282: LD_INT 2
27284: PUSH
27285: LD_INT 0
27287: PUSH
27288: EMPTY
27289: LIST
27290: LIST
27291: PUSH
27292: LD_INT 2
27294: PUSH
27295: LD_INT 1
27297: PUSH
27298: EMPTY
27299: LIST
27300: LIST
27301: PUSH
27302: LD_INT 2
27304: PUSH
27305: LD_INT 2
27307: PUSH
27308: EMPTY
27309: LIST
27310: LIST
27311: PUSH
27312: LD_INT 1
27314: PUSH
27315: LD_INT 2
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: LD_INT 2
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: LD_INT 1
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: PUSH
27343: LD_INT 2
27345: NEG
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 2
27356: NEG
27357: PUSH
27358: LD_INT 1
27360: NEG
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PUSH
27366: LD_INT 2
27368: NEG
27369: PUSH
27370: LD_INT 2
27372: NEG
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: EMPTY
27379: LIST
27380: LIST
27381: LIST
27382: LIST
27383: LIST
27384: LIST
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: LIST
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27399: LD_ADDR_VAR 0 20
27403: PUSH
27404: LD_INT 0
27406: PUSH
27407: LD_INT 0
27409: PUSH
27410: EMPTY
27411: LIST
27412: LIST
27413: PUSH
27414: LD_INT 0
27416: PUSH
27417: LD_INT 1
27419: NEG
27420: PUSH
27421: EMPTY
27422: LIST
27423: LIST
27424: PUSH
27425: LD_INT 1
27427: PUSH
27428: LD_INT 0
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: PUSH
27435: LD_INT 1
27437: PUSH
27438: LD_INT 1
27440: PUSH
27441: EMPTY
27442: LIST
27443: LIST
27444: PUSH
27445: LD_INT 0
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 1
27457: NEG
27458: PUSH
27459: LD_INT 0
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: LD_INT 1
27468: NEG
27469: PUSH
27470: LD_INT 1
27472: NEG
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: LD_INT 2
27484: NEG
27485: PUSH
27486: EMPTY
27487: LIST
27488: LIST
27489: PUSH
27490: LD_INT 0
27492: PUSH
27493: LD_INT 2
27495: NEG
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: PUSH
27501: LD_INT 1
27503: PUSH
27504: LD_INT 1
27506: NEG
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 2
27514: PUSH
27515: LD_INT 0
27517: PUSH
27518: EMPTY
27519: LIST
27520: LIST
27521: PUSH
27522: LD_INT 2
27524: PUSH
27525: LD_INT 1
27527: PUSH
27528: EMPTY
27529: LIST
27530: LIST
27531: PUSH
27532: LD_INT 2
27534: PUSH
27535: LD_INT 2
27537: PUSH
27538: EMPTY
27539: LIST
27540: LIST
27541: PUSH
27542: LD_INT 1
27544: PUSH
27545: LD_INT 2
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PUSH
27552: LD_INT 0
27554: PUSH
27555: LD_INT 2
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: LD_INT 1
27568: PUSH
27569: EMPTY
27570: LIST
27571: LIST
27572: PUSH
27573: LD_INT 2
27575: NEG
27576: PUSH
27577: LD_INT 0
27579: PUSH
27580: EMPTY
27581: LIST
27582: LIST
27583: PUSH
27584: LD_INT 2
27586: NEG
27587: PUSH
27588: LD_INT 1
27590: NEG
27591: PUSH
27592: EMPTY
27593: LIST
27594: LIST
27595: PUSH
27596: LD_INT 2
27598: NEG
27599: PUSH
27600: LD_INT 2
27602: NEG
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: LIST
27615: LIST
27616: LIST
27617: LIST
27618: LIST
27619: LIST
27620: LIST
27621: LIST
27622: LIST
27623: LIST
27624: LIST
27625: LIST
27626: LIST
27627: LIST
27628: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27629: LD_ADDR_VAR 0 21
27633: PUSH
27634: LD_INT 0
27636: PUSH
27637: LD_INT 0
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: PUSH
27644: LD_INT 0
27646: PUSH
27647: LD_INT 1
27649: NEG
27650: PUSH
27651: EMPTY
27652: LIST
27653: LIST
27654: PUSH
27655: LD_INT 1
27657: PUSH
27658: LD_INT 0
27660: PUSH
27661: EMPTY
27662: LIST
27663: LIST
27664: PUSH
27665: LD_INT 1
27667: PUSH
27668: LD_INT 1
27670: PUSH
27671: EMPTY
27672: LIST
27673: LIST
27674: PUSH
27675: LD_INT 0
27677: PUSH
27678: LD_INT 1
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 1
27687: NEG
27688: PUSH
27689: LD_INT 0
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: LD_INT 1
27698: NEG
27699: PUSH
27700: LD_INT 1
27702: NEG
27703: PUSH
27704: EMPTY
27705: LIST
27706: LIST
27707: PUSH
27708: LD_INT 1
27710: NEG
27711: PUSH
27712: LD_INT 2
27714: NEG
27715: PUSH
27716: EMPTY
27717: LIST
27718: LIST
27719: PUSH
27720: LD_INT 0
27722: PUSH
27723: LD_INT 2
27725: NEG
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: LD_INT 1
27736: NEG
27737: PUSH
27738: EMPTY
27739: LIST
27740: LIST
27741: PUSH
27742: LD_INT 2
27744: PUSH
27745: LD_INT 0
27747: PUSH
27748: EMPTY
27749: LIST
27750: LIST
27751: PUSH
27752: LD_INT 2
27754: PUSH
27755: LD_INT 1
27757: PUSH
27758: EMPTY
27759: LIST
27760: LIST
27761: PUSH
27762: LD_INT 2
27764: PUSH
27765: LD_INT 2
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: PUSH
27772: LD_INT 1
27774: PUSH
27775: LD_INT 2
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 0
27784: PUSH
27785: LD_INT 2
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: LD_INT 1
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 2
27805: NEG
27806: PUSH
27807: LD_INT 0
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 2
27816: NEG
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: LD_INT 2
27828: NEG
27829: PUSH
27830: LD_INT 2
27832: NEG
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: LIST
27851: LIST
27852: LIST
27853: LIST
27854: LIST
27855: LIST
27856: LIST
27857: LIST
27858: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27859: LD_ADDR_VAR 0 22
27863: PUSH
27864: LD_INT 0
27866: PUSH
27867: LD_INT 0
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 0
27876: PUSH
27877: LD_INT 1
27879: NEG
27880: PUSH
27881: EMPTY
27882: LIST
27883: LIST
27884: PUSH
27885: LD_INT 1
27887: PUSH
27888: LD_INT 0
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: PUSH
27895: LD_INT 1
27897: PUSH
27898: LD_INT 1
27900: PUSH
27901: EMPTY
27902: LIST
27903: LIST
27904: PUSH
27905: LD_INT 0
27907: PUSH
27908: LD_INT 1
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 1
27917: NEG
27918: PUSH
27919: LD_INT 0
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: LD_INT 1
27928: NEG
27929: PUSH
27930: LD_INT 1
27932: NEG
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: LD_INT 2
27944: NEG
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 0
27952: PUSH
27953: LD_INT 2
27955: NEG
27956: PUSH
27957: EMPTY
27958: LIST
27959: LIST
27960: PUSH
27961: LD_INT 1
27963: PUSH
27964: LD_INT 1
27966: NEG
27967: PUSH
27968: EMPTY
27969: LIST
27970: LIST
27971: PUSH
27972: LD_INT 2
27974: PUSH
27975: LD_INT 0
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: PUSH
27982: LD_INT 2
27984: PUSH
27985: LD_INT 1
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 2
27994: PUSH
27995: LD_INT 2
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 1
28004: PUSH
28005: LD_INT 2
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 0
28014: PUSH
28015: LD_INT 2
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: LD_INT 1
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: PUSH
28033: LD_INT 2
28035: NEG
28036: PUSH
28037: LD_INT 0
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: NEG
28047: PUSH
28048: LD_INT 1
28050: NEG
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 2
28058: NEG
28059: PUSH
28060: LD_INT 2
28062: NEG
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: LIST
28079: LIST
28080: LIST
28081: LIST
28082: LIST
28083: LIST
28084: LIST
28085: LIST
28086: LIST
28087: LIST
28088: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28089: LD_ADDR_VAR 0 23
28093: PUSH
28094: LD_INT 0
28096: PUSH
28097: LD_INT 0
28099: PUSH
28100: EMPTY
28101: LIST
28102: LIST
28103: PUSH
28104: LD_INT 0
28106: PUSH
28107: LD_INT 1
28109: NEG
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: PUSH
28115: LD_INT 1
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: EMPTY
28122: LIST
28123: LIST
28124: PUSH
28125: LD_INT 1
28127: PUSH
28128: LD_INT 1
28130: PUSH
28131: EMPTY
28132: LIST
28133: LIST
28134: PUSH
28135: LD_INT 0
28137: PUSH
28138: LD_INT 1
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: PUSH
28145: LD_INT 1
28147: NEG
28148: PUSH
28149: LD_INT 0
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 1
28158: NEG
28159: PUSH
28160: LD_INT 1
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: LD_INT 2
28174: NEG
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 0
28182: PUSH
28183: LD_INT 2
28185: NEG
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: LD_INT 1
28193: PUSH
28194: LD_INT 1
28196: NEG
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: LD_INT 2
28204: PUSH
28205: LD_INT 0
28207: PUSH
28208: EMPTY
28209: LIST
28210: LIST
28211: PUSH
28212: LD_INT 2
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: EMPTY
28219: LIST
28220: LIST
28221: PUSH
28222: LD_INT 2
28224: PUSH
28225: LD_INT 2
28227: PUSH
28228: EMPTY
28229: LIST
28230: LIST
28231: PUSH
28232: LD_INT 1
28234: PUSH
28235: LD_INT 2
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 2
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 1
28254: NEG
28255: PUSH
28256: LD_INT 1
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 2
28265: NEG
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 2
28276: NEG
28277: PUSH
28278: LD_INT 1
28280: NEG
28281: PUSH
28282: EMPTY
28283: LIST
28284: LIST
28285: PUSH
28286: LD_INT 2
28288: NEG
28289: PUSH
28290: LD_INT 2
28292: NEG
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: NEG
28301: PUSH
28302: LD_INT 3
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 1
28312: NEG
28313: PUSH
28314: LD_INT 3
28316: NEG
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: LIST
28348: LIST
28349: LIST
28350: LIST
28351: LIST
28352: LIST
28353: LIST
28354: LIST
28355: LIST
28356: LIST
28357: LIST
28358: LIST
28359: LIST
28360: LIST
28361: LIST
28362: LIST
28363: LIST
28364: LIST
28365: LIST
28366: LIST
28367: LIST
28368: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28369: LD_ADDR_VAR 0 24
28373: PUSH
28374: LD_INT 0
28376: PUSH
28377: LD_INT 0
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: PUSH
28384: LD_INT 0
28386: PUSH
28387: LD_INT 1
28389: NEG
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: PUSH
28395: LD_INT 1
28397: PUSH
28398: LD_INT 0
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PUSH
28405: LD_INT 1
28407: PUSH
28408: LD_INT 1
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 0
28417: PUSH
28418: LD_INT 1
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: NEG
28428: PUSH
28429: LD_INT 0
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: NEG
28439: PUSH
28440: LD_INT 1
28442: NEG
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: LD_INT 2
28454: NEG
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 0
28462: PUSH
28463: LD_INT 2
28465: NEG
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 1
28473: PUSH
28474: LD_INT 1
28476: NEG
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 2
28484: PUSH
28485: LD_INT 0
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PUSH
28492: LD_INT 2
28494: PUSH
28495: LD_INT 1
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 2
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 1
28514: PUSH
28515: LD_INT 2
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 0
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: NEG
28535: PUSH
28536: LD_INT 1
28538: PUSH
28539: EMPTY
28540: LIST
28541: LIST
28542: PUSH
28543: LD_INT 2
28545: NEG
28546: PUSH
28547: LD_INT 0
28549: PUSH
28550: EMPTY
28551: LIST
28552: LIST
28553: PUSH
28554: LD_INT 2
28556: NEG
28557: PUSH
28558: LD_INT 1
28560: NEG
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: LD_INT 2
28568: NEG
28569: PUSH
28570: LD_INT 2
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 2
28591: PUSH
28592: LD_INT 1
28594: NEG
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 3
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: EMPTY
28607: LIST
28608: LIST
28609: PUSH
28610: LD_INT 3
28612: PUSH
28613: LD_INT 2
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: LIST
28636: LIST
28637: LIST
28638: LIST
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28645: LD_ADDR_VAR 0 25
28649: PUSH
28650: LD_INT 0
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: LD_INT 0
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: LD_INT 1
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: LD_INT 1
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: NEG
28704: PUSH
28705: LD_INT 0
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: NEG
28715: PUSH
28716: LD_INT 1
28718: NEG
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 0
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 1
28749: PUSH
28750: LD_INT 1
28752: NEG
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 2
28760: PUSH
28761: LD_INT 0
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 2
28770: PUSH
28771: LD_INT 1
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 2
28780: PUSH
28781: LD_INT 2
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 0
28800: PUSH
28801: LD_INT 2
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: NEG
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: NEG
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 2
28832: NEG
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 2
28844: NEG
28845: PUSH
28846: LD_INT 2
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 3
28856: PUSH
28857: LD_INT 1
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: LD_INT 3
28866: PUSH
28867: LD_INT 2
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 2
28876: PUSH
28877: LD_INT 3
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 3
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: LIST
28898: LIST
28899: LIST
28900: LIST
28901: LIST
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: LIST
28907: LIST
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28919: LD_ADDR_VAR 0 26
28923: PUSH
28924: LD_INT 0
28926: PUSH
28927: LD_INT 0
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PUSH
28934: LD_INT 0
28936: PUSH
28937: LD_INT 1
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 1
28947: PUSH
28948: LD_INT 0
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 1
28957: PUSH
28958: LD_INT 1
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 0
28967: PUSH
28968: LD_INT 1
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: NEG
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: LD_INT 1
28988: NEG
28989: PUSH
28990: LD_INT 1
28992: NEG
28993: PUSH
28994: EMPTY
28995: LIST
28996: LIST
28997: PUSH
28998: LD_INT 1
29000: NEG
29001: PUSH
29002: LD_INT 2
29004: NEG
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: LD_INT 2
29015: NEG
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: LD_INT 1
29026: NEG
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: PUSH
29032: LD_INT 2
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: PUSH
29042: LD_INT 2
29044: PUSH
29045: LD_INT 1
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: LD_INT 2
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 1
29064: PUSH
29065: LD_INT 2
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 0
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: NEG
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 2
29095: NEG
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 2
29106: NEG
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: NEG
29119: PUSH
29120: LD_INT 2
29122: NEG
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: LD_INT 3
29133: PUSH
29134: EMPTY
29135: LIST
29136: LIST
29137: PUSH
29138: LD_INT 1
29140: PUSH
29141: LD_INT 3
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: LIST
29174: LIST
29175: LIST
29176: LIST
29177: LIST
29178: LIST
29179: LIST
29180: LIST
29181: LIST
29182: LIST
29183: LIST
29184: LIST
29185: LIST
29186: LIST
29187: LIST
29188: LIST
29189: LIST
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29195: LD_ADDR_VAR 0 27
29199: PUSH
29200: LD_INT 0
29202: PUSH
29203: LD_INT 0
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 0
29212: PUSH
29213: LD_INT 1
29215: NEG
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 1
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: LD_INT 1
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: LD_INT 1
29246: PUSH
29247: EMPTY
29248: LIST
29249: LIST
29250: PUSH
29251: LD_INT 1
29253: NEG
29254: PUSH
29255: LD_INT 0
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 1
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 1
29276: NEG
29277: PUSH
29278: LD_INT 2
29280: NEG
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: LD_INT 2
29291: NEG
29292: PUSH
29293: EMPTY
29294: LIST
29295: LIST
29296: PUSH
29297: LD_INT 1
29299: PUSH
29300: LD_INT 1
29302: NEG
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: LD_INT 2
29310: PUSH
29311: LD_INT 0
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 2
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: LD_INT 2
29330: PUSH
29331: LD_INT 2
29333: PUSH
29334: EMPTY
29335: LIST
29336: LIST
29337: PUSH
29338: LD_INT 1
29340: PUSH
29341: LD_INT 2
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 0
29350: PUSH
29351: LD_INT 2
29353: PUSH
29354: EMPTY
29355: LIST
29356: LIST
29357: PUSH
29358: LD_INT 1
29360: NEG
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 2
29371: NEG
29372: PUSH
29373: LD_INT 0
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 2
29382: NEG
29383: PUSH
29384: LD_INT 1
29386: NEG
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 2
29394: NEG
29395: PUSH
29396: LD_INT 2
29398: NEG
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: LD_INT 2
29410: PUSH
29411: EMPTY
29412: LIST
29413: LIST
29414: PUSH
29415: LD_INT 2
29417: NEG
29418: PUSH
29419: LD_INT 1
29421: PUSH
29422: EMPTY
29423: LIST
29424: LIST
29425: PUSH
29426: LD_INT 3
29428: NEG
29429: PUSH
29430: LD_INT 1
29432: NEG
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: PUSH
29438: LD_INT 3
29440: NEG
29441: PUSH
29442: LD_INT 2
29444: NEG
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29475: LD_ADDR_VAR 0 28
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: LD_INT 1
29495: NEG
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: LD_INT 1
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PUSH
29531: LD_INT 1
29533: NEG
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: LD_INT 2
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 1
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 2
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 2
29600: PUSH
29601: LD_INT 1
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 2
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: LD_INT 1
29620: PUSH
29621: LD_INT 2
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 0
29630: PUSH
29631: LD_INT 2
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 1
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: LD_INT 2
29651: NEG
29652: PUSH
29653: LD_INT 0
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 2
29662: NEG
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 2
29674: NEG
29675: PUSH
29676: LD_INT 2
29678: NEG
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: NEG
29687: PUSH
29688: LD_INT 3
29690: NEG
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 1
29698: NEG
29699: PUSH
29700: LD_INT 3
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 3
29710: NEG
29711: PUSH
29712: LD_INT 1
29714: NEG
29715: PUSH
29716: EMPTY
29717: LIST
29718: LIST
29719: PUSH
29720: LD_INT 3
29722: NEG
29723: PUSH
29724: LD_INT 2
29726: NEG
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: EMPTY
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: LIST
29749: LIST
29750: LIST
29751: LIST
29752: LIST
29753: LIST
29754: LIST
29755: LIST
29756: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29757: LD_ADDR_VAR 0 29
29761: PUSH
29762: LD_INT 0
29764: PUSH
29765: LD_INT 0
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 0
29774: PUSH
29775: LD_INT 1
29777: NEG
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: LD_INT 0
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: LD_INT 1
29795: PUSH
29796: LD_INT 1
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: LD_INT 0
29819: PUSH
29820: EMPTY
29821: LIST
29822: LIST
29823: PUSH
29824: LD_INT 1
29826: NEG
29827: PUSH
29828: LD_INT 1
29830: NEG
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 2
29842: NEG
29843: PUSH
29844: EMPTY
29845: LIST
29846: LIST
29847: PUSH
29848: LD_INT 0
29850: PUSH
29851: LD_INT 2
29853: NEG
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: LD_INT 1
29864: NEG
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 2
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: PUSH
29890: LD_INT 1
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: EMPTY
29897: LIST
29898: LIST
29899: PUSH
29900: LD_INT 0
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 1
29912: NEG
29913: PUSH
29914: LD_INT 1
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: LD_INT 1
29927: NEG
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 2
29935: NEG
29936: PUSH
29937: LD_INT 2
29939: NEG
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 2
29947: NEG
29948: PUSH
29949: LD_INT 3
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 2
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 3
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 3
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: NEG
29991: PUSH
29992: LD_INT 2
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 3
30001: NEG
30002: PUSH
30003: LD_INT 2
30005: NEG
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: LIST
30028: LIST
30029: LIST
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30036: LD_ADDR_VAR 0 30
30040: PUSH
30041: LD_INT 0
30043: PUSH
30044: LD_INT 0
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 0
30053: PUSH
30054: LD_INT 1
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: PUSH
30075: LD_INT 1
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 0
30084: PUSH
30085: LD_INT 1
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 1
30094: NEG
30095: PUSH
30096: LD_INT 0
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 1
30105: NEG
30106: PUSH
30107: LD_INT 1
30109: NEG
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 1
30117: NEG
30118: PUSH
30119: LD_INT 2
30121: NEG
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 0
30129: PUSH
30130: LD_INT 2
30132: NEG
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 1
30140: PUSH
30141: LD_INT 1
30143: NEG
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 2
30151: PUSH
30152: LD_INT 0
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 2
30161: PUSH
30162: LD_INT 1
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 2
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 2
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 1
30191: NEG
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 2
30202: NEG
30203: PUSH
30204: LD_INT 0
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 2
30213: NEG
30214: PUSH
30215: LD_INT 1
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 1
30225: NEG
30226: PUSH
30227: LD_INT 3
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 2
30240: NEG
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: LD_INT 3
30248: PUSH
30249: LD_INT 2
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 3
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: NEG
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 3
30279: NEG
30280: PUSH
30281: LD_INT 1
30283: NEG
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30314: LD_ADDR_VAR 0 31
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: LD_INT 0
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 0
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 1
30342: PUSH
30343: LD_INT 0
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 1
30352: PUSH
30353: LD_INT 1
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 0
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: LD_INT 0
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 1
30383: NEG
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 1
30395: NEG
30396: PUSH
30397: LD_INT 2
30399: NEG
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: LD_INT 1
30410: NEG
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PUSH
30416: LD_INT 2
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PUSH
30426: LD_INT 2
30428: PUSH
30429: LD_INT 1
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 2
30438: PUSH
30439: LD_INT 2
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 0
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 2
30479: NEG
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 2
30491: NEG
30492: PUSH
30493: LD_INT 2
30495: NEG
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: PUSH
30501: LD_INT 2
30503: NEG
30504: PUSH
30505: LD_INT 3
30507: NEG
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 2
30515: PUSH
30516: LD_INT 1
30518: NEG
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 3
30526: PUSH
30527: LD_INT 1
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: LD_INT 3
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 1
30546: NEG
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 3
30557: NEG
30558: PUSH
30559: LD_INT 2
30561: NEG
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30592: LD_ADDR_VAR 0 32
30596: PUSH
30597: LD_INT 0
30599: PUSH
30600: LD_INT 0
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 0
30609: PUSH
30610: LD_INT 1
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 1
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 0
30640: PUSH
30641: LD_INT 1
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 1
30650: NEG
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: NEG
30662: PUSH
30663: LD_INT 1
30665: NEG
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: LD_INT 2
30677: NEG
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 2
30688: NEG
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: PUSH
30697: LD_INT 1
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 1
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 2
30717: PUSH
30718: LD_INT 2
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: LD_INT 2
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 0
30737: PUSH
30738: LD_INT 2
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 2
30758: NEG
30759: PUSH
30760: LD_INT 0
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 1
30773: NEG
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 1
30781: NEG
30782: PUSH
30783: LD_INT 3
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 3
30804: PUSH
30805: LD_INT 2
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 2
30814: PUSH
30815: LD_INT 3
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 2
30824: NEG
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: LD_INT 3
30835: NEG
30836: PUSH
30837: LD_INT 1
30839: NEG
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30870: LD_ADDR_VAR 0 33
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 1
30890: NEG
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: PUSH
30909: LD_INT 1
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 0
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 1
30928: NEG
30929: PUSH
30930: LD_INT 0
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 1
30939: NEG
30940: PUSH
30941: LD_INT 1
30943: NEG
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 2
30955: NEG
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 1
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 2
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: LD_INT 1
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 1
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 1
31014: NEG
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: LD_INT 0
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 2
31036: NEG
31037: PUSH
31038: LD_INT 1
31040: NEG
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: PUSH
31046: LD_INT 2
31048: NEG
31049: PUSH
31050: LD_INT 2
31052: NEG
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 3
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: PUSH
31073: LD_INT 1
31075: NEG
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 3
31083: PUSH
31084: LD_INT 1
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: LD_INT 3
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 1
31103: NEG
31104: PUSH
31105: LD_INT 2
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 3
31114: NEG
31115: PUSH
31116: LD_INT 2
31118: NEG
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31149: LD_ADDR_VAR 0 34
31153: PUSH
31154: LD_INT 0
31156: PUSH
31157: LD_INT 0
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: LD_INT 1
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 0
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 1
31207: NEG
31208: PUSH
31209: LD_INT 0
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 1
31218: NEG
31219: PUSH
31220: LD_INT 1
31222: NEG
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: LD_INT 2
31234: NEG
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 2
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: LD_INT 2
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 1
31284: PUSH
31285: LD_INT 2
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: LD_INT 1
31298: PUSH
31299: EMPTY
31300: LIST
31301: LIST
31302: PUSH
31303: LD_INT 2
31305: NEG
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: EMPTY
31311: LIST
31312: LIST
31313: PUSH
31314: LD_INT 2
31316: NEG
31317: PUSH
31318: LD_INT 1
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 1
31340: NEG
31341: PUSH
31342: LD_INT 3
31344: NEG
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 1
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 3
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 2
31373: PUSH
31374: LD_INT 3
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 2
31383: NEG
31384: PUSH
31385: LD_INT 1
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 3
31394: NEG
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: LIST
31426: LIST
31427: LIST
31428: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31429: LD_ADDR_VAR 0 35
31433: PUSH
31434: LD_INT 0
31436: PUSH
31437: LD_INT 0
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 0
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 1
31457: PUSH
31458: LD_INT 0
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: LD_INT 1
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 1
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: LD_INT 0
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 1
31498: NEG
31499: PUSH
31500: LD_INT 1
31502: NEG
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 2
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 2
31520: NEG
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31541: LD_ADDR_VAR 0 36
31545: PUSH
31546: LD_INT 0
31548: PUSH
31549: LD_INT 0
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: LD_INT 1
31561: NEG
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: PUSH
31580: LD_INT 1
31582: PUSH
31583: EMPTY
31584: LIST
31585: LIST
31586: PUSH
31587: LD_INT 0
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: PUSH
31597: LD_INT 1
31599: NEG
31600: PUSH
31601: LD_INT 0
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 1
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: NEG
31623: PUSH
31624: LD_INT 2
31626: NEG
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31653: LD_ADDR_VAR 0 37
31657: PUSH
31658: LD_INT 0
31660: PUSH
31661: LD_INT 0
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: LD_INT 1
31673: NEG
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 1
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 1
31691: PUSH
31692: LD_INT 1
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: EMPTY
31706: LIST
31707: LIST
31708: PUSH
31709: LD_INT 1
31711: NEG
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 1
31722: NEG
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 1
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 1
31745: NEG
31746: PUSH
31747: LD_INT 1
31749: PUSH
31750: EMPTY
31751: LIST
31752: LIST
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31765: LD_ADDR_VAR 0 38
31769: PUSH
31770: LD_INT 0
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: LD_INT 1
31785: NEG
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: PUSH
31804: LD_INT 1
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: LD_INT 1
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: PUSH
31821: LD_INT 1
31823: NEG
31824: PUSH
31825: LD_INT 0
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 1
31834: NEG
31835: PUSH
31836: LD_INT 1
31838: NEG
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 2
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 2
31856: NEG
31857: PUSH
31858: LD_INT 1
31860: NEG
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31877: LD_ADDR_VAR 0 39
31881: PUSH
31882: LD_INT 0
31884: PUSH
31885: LD_INT 0
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 1
31897: NEG
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: LD_INT 0
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: PUSH
31916: LD_INT 1
31918: PUSH
31919: EMPTY
31920: LIST
31921: LIST
31922: PUSH
31923: LD_INT 0
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 1
31958: NEG
31959: PUSH
31960: LD_INT 2
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 1
31970: PUSH
31971: LD_INT 2
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: LIST
31985: LIST
31986: LIST
31987: LIST
31988: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31989: LD_ADDR_VAR 0 40
31993: PUSH
31994: LD_INT 0
31996: PUSH
31997: LD_INT 0
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 0
32006: PUSH
32007: LD_INT 1
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 0
32020: PUSH
32021: EMPTY
32022: LIST
32023: LIST
32024: PUSH
32025: LD_INT 1
32027: PUSH
32028: LD_INT 1
32030: PUSH
32031: EMPTY
32032: LIST
32033: LIST
32034: PUSH
32035: LD_INT 0
32037: PUSH
32038: LD_INT 1
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 1
32058: NEG
32059: PUSH
32060: LD_INT 1
32062: NEG
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: PUSH
32071: LD_INT 1
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 1
32081: NEG
32082: PUSH
32083: LD_INT 1
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: LIST
32099: LIST
32100: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32101: LD_ADDR_VAR 0 41
32105: PUSH
32106: LD_INT 0
32108: PUSH
32109: LD_INT 0
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 1
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: PUSH
32140: LD_INT 1
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 0
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: NEG
32160: PUSH
32161: LD_INT 0
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 1
32170: NEG
32171: PUSH
32172: LD_INT 1
32174: NEG
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 1
32182: NEG
32183: PUSH
32184: LD_INT 2
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: EMPTY
32200: LIST
32201: LIST
32202: PUSH
32203: LD_INT 2
32205: PUSH
32206: LD_INT 0
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 2
32215: PUSH
32216: LD_INT 1
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 2
32225: PUSH
32226: LD_INT 2
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 1
32235: PUSH
32236: LD_INT 2
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 0
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 2
32267: NEG
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 2
32279: NEG
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 2
32291: NEG
32292: PUSH
32293: LD_INT 3
32295: NEG
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: LD_INT 1
32306: NEG
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 3
32314: PUSH
32315: LD_INT 0
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 3
32324: PUSH
32325: LD_INT 1
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 3
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 3
32344: PUSH
32345: LD_INT 3
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 2
32354: PUSH
32355: LD_INT 3
32357: PUSH
32358: EMPTY
32359: LIST
32360: LIST
32361: PUSH
32362: LD_INT 2
32364: NEG
32365: PUSH
32366: LD_INT 1
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 3
32375: NEG
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 3
32386: NEG
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 3
32398: NEG
32399: PUSH
32400: LD_INT 2
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 3
32410: NEG
32411: PUSH
32412: LD_INT 3
32414: NEG
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: LIST
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32451: LD_ADDR_VAR 0 42
32455: PUSH
32456: LD_INT 0
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 0
32468: PUSH
32469: LD_INT 1
32471: NEG
32472: PUSH
32473: EMPTY
32474: LIST
32475: LIST
32476: PUSH
32477: LD_INT 1
32479: PUSH
32480: LD_INT 0
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: LD_INT 1
32489: PUSH
32490: LD_INT 1
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 0
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 0
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: LD_INT 1
32520: NEG
32521: PUSH
32522: LD_INT 1
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 2
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 0
32544: PUSH
32545: LD_INT 2
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: PUSH
32556: LD_INT 1
32558: NEG
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 2
32566: PUSH
32567: LD_INT 1
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: LD_INT 2
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: LD_INT 2
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: LD_INT 0
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 1
32606: NEG
32607: PUSH
32608: LD_INT 1
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: NEG
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 2
32629: NEG
32630: PUSH
32631: LD_INT 2
32633: NEG
32634: PUSH
32635: EMPTY
32636: LIST
32637: LIST
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: LD_INT 3
32645: NEG
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: LD_INT 1
32653: NEG
32654: PUSH
32655: LD_INT 3
32657: NEG
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 0
32665: PUSH
32666: LD_INT 3
32668: NEG
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 1
32676: PUSH
32677: LD_INT 2
32679: NEG
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 3
32687: PUSH
32688: LD_INT 2
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: LD_INT 3
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 2
32707: PUSH
32708: LD_INT 3
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: LD_INT 3
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 0
32727: PUSH
32728: LD_INT 3
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 1
32737: NEG
32738: PUSH
32739: LD_INT 2
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 3
32748: NEG
32749: PUSH
32750: LD_INT 2
32752: NEG
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 3
32760: NEG
32761: PUSH
32762: LD_INT 3
32764: NEG
32765: PUSH
32766: EMPTY
32767: LIST
32768: LIST
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32801: LD_ADDR_VAR 0 43
32805: PUSH
32806: LD_INT 0
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 0
32818: PUSH
32819: LD_INT 1
32821: NEG
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PUSH
32827: LD_INT 1
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: EMPTY
32834: LIST
32835: LIST
32836: PUSH
32837: LD_INT 1
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 0
32849: PUSH
32850: LD_INT 1
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 1
32859: NEG
32860: PUSH
32861: LD_INT 0
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 1
32870: NEG
32871: PUSH
32872: LD_INT 1
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 1
32882: NEG
32883: PUSH
32884: LD_INT 2
32886: NEG
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 0
32894: PUSH
32895: LD_INT 2
32897: NEG
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 1
32905: PUSH
32906: LD_INT 1
32908: NEG
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 2
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 2
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 1
32936: PUSH
32937: LD_INT 2
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: LD_INT 2
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 1
32956: NEG
32957: PUSH
32958: LD_INT 1
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: LD_INT 2
32967: NEG
32968: PUSH
32969: LD_INT 0
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: LD_INT 1
32982: NEG
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 1
32990: NEG
32991: PUSH
32992: LD_INT 3
32994: NEG
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 0
33002: PUSH
33003: LD_INT 3
33005: NEG
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 1
33013: PUSH
33014: LD_INT 2
33016: NEG
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: LD_INT 1
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 3
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 3
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 1
33055: PUSH
33056: LD_INT 3
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: LD_INT 3
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: LD_INT 2
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 2
33086: NEG
33087: PUSH
33088: LD_INT 1
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 3
33097: NEG
33098: PUSH
33099: LD_INT 0
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 3
33108: NEG
33109: PUSH
33110: LD_INT 1
33112: NEG
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33149: LD_ADDR_VAR 0 44
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: LD_INT 0
33159: PUSH
33160: EMPTY
33161: LIST
33162: LIST
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 0
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: NEG
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 1
33218: NEG
33219: PUSH
33220: LD_INT 1
33222: NEG
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: NEG
33231: PUSH
33232: LD_INT 2
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 1
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 2
33253: PUSH
33254: LD_INT 0
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 2
33263: PUSH
33264: LD_INT 1
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 2
33273: PUSH
33274: LD_INT 2
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 1
33283: PUSH
33284: LD_INT 2
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 1
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 2
33304: NEG
33305: PUSH
33306: LD_INT 0
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 2
33315: NEG
33316: PUSH
33317: LD_INT 1
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 2
33327: NEG
33328: PUSH
33329: LD_INT 2
33331: NEG
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: LD_INT 3
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 3
33362: PUSH
33363: LD_INT 0
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 3
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 3
33382: PUSH
33383: LD_INT 2
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 3
33392: PUSH
33393: LD_INT 3
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 2
33402: PUSH
33403: LD_INT 3
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 2
33412: NEG
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 3
33423: NEG
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 3
33434: NEG
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 3
33446: NEG
33447: PUSH
33448: LD_INT 2
33450: NEG
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 3
33458: NEG
33459: PUSH
33460: LD_INT 3
33462: NEG
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33499: LD_ADDR_VAR 0 45
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: LD_INT 0
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 0
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 0
33547: PUSH
33548: LD_INT 1
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: NEG
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: NEG
33581: PUSH
33582: LD_INT 2
33584: NEG
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: LD_INT 2
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 1
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: PUSH
33615: LD_INT 1
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 2
33624: PUSH
33625: LD_INT 2
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: LD_INT 2
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 0
33644: PUSH
33645: LD_INT 2
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 1
33654: NEG
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 2
33665: NEG
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: EMPTY
33672: LIST
33673: LIST
33674: PUSH
33675: LD_INT 2
33677: NEG
33678: PUSH
33679: LD_INT 2
33681: NEG
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: LD_INT 3
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 1
33701: NEG
33702: PUSH
33703: LD_INT 3
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 0
33713: PUSH
33714: LD_INT 3
33716: NEG
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 1
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 3
33735: PUSH
33736: LD_INT 2
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 3
33745: PUSH
33746: LD_INT 3
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 2
33755: PUSH
33756: LD_INT 3
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: PUSH
33766: LD_INT 3
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 0
33775: PUSH
33776: LD_INT 3
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: LD_INT 2
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 3
33796: NEG
33797: PUSH
33798: LD_INT 2
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 3
33808: NEG
33809: PUSH
33810: LD_INT 3
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33849: LD_ADDR_VAR 0 46
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 0
33859: PUSH
33860: EMPTY
33861: LIST
33862: LIST
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 0
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 1
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: NEG
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 1
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: LD_INT 2
33934: NEG
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 0
33942: PUSH
33943: LD_INT 2
33945: NEG
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: LD_INT 1
33956: NEG
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 2
33964: PUSH
33965: LD_INT 0
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 2
33974: PUSH
33975: LD_INT 1
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: LD_INT 2
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 0
33994: PUSH
33995: LD_INT 2
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: NEG
34005: PUSH
34006: LD_INT 1
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 0
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: LD_INT 1
34030: NEG
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 1
34038: NEG
34039: PUSH
34040: LD_INT 3
34042: NEG
34043: PUSH
34044: EMPTY
34045: LIST
34046: LIST
34047: PUSH
34048: LD_INT 0
34050: PUSH
34051: LD_INT 3
34053: NEG
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 1
34061: PUSH
34062: LD_INT 2
34064: NEG
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 2
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 3
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 3
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 1
34103: PUSH
34104: LD_INT 3
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 0
34113: PUSH
34114: LD_INT 3
34116: PUSH
34117: EMPTY
34118: LIST
34119: LIST
34120: PUSH
34121: LD_INT 1
34123: NEG
34124: PUSH
34125: LD_INT 2
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 2
34134: NEG
34135: PUSH
34136: LD_INT 1
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 3
34145: NEG
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 3
34156: NEG
34157: PUSH
34158: LD_INT 1
34160: NEG
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: LIST
34173: LIST
34174: LIST
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34197: LD_ADDR_VAR 0 47
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: LD_INT 0
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 0
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 0
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: LD_INT 1
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 0
34245: PUSH
34246: LD_INT 1
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: LD_INT 0
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: NEG
34267: PUSH
34268: LD_INT 1
34270: NEG
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 1
34278: NEG
34279: PUSH
34280: LD_INT 2
34282: NEG
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 2
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 1
34304: NEG
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 2
34312: NEG
34313: PUSH
34314: LD_INT 1
34316: NEG
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: NEG
34325: PUSH
34326: LD_INT 2
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34348: LD_ADDR_VAR 0 48
34352: PUSH
34353: LD_INT 0
34355: PUSH
34356: LD_INT 0
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 0
34365: PUSH
34366: LD_INT 1
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 1
34376: PUSH
34377: LD_INT 0
34379: PUSH
34380: EMPTY
34381: LIST
34382: LIST
34383: PUSH
34384: LD_INT 1
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 0
34396: PUSH
34397: LD_INT 1
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: PUSH
34404: LD_INT 1
34406: NEG
34407: PUSH
34408: LD_INT 0
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 1
34417: NEG
34418: PUSH
34419: LD_INT 1
34421: NEG
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 1
34429: NEG
34430: PUSH
34431: LD_INT 2
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 0
34441: PUSH
34442: LD_INT 2
34444: NEG
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: LD_INT 1
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 2
34463: PUSH
34464: LD_INT 0
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 2
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: EMPTY
34482: LIST
34483: LIST
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34495: LD_ADDR_VAR 0 49
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: LD_INT 0
34505: PUSH
34506: EMPTY
34507: LIST
34508: LIST
34509: PUSH
34510: LD_INT 0
34512: PUSH
34513: LD_INT 1
34515: NEG
34516: PUSH
34517: EMPTY
34518: LIST
34519: LIST
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: LD_INT 0
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: LD_INT 1
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 0
34543: PUSH
34544: LD_INT 1
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 1
34553: NEG
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 1
34564: NEG
34565: PUSH
34566: LD_INT 1
34568: NEG
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: LD_INT 1
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 0
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 2
34597: PUSH
34598: LD_INT 1
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: LD_INT 2
34607: PUSH
34608: LD_INT 2
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: LD_INT 2
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: EMPTY
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34639: LD_ADDR_VAR 0 50
34643: PUSH
34644: LD_INT 0
34646: PUSH
34647: LD_INT 0
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 0
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 1
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 1
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: LD_INT 1
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 1
34697: NEG
34698: PUSH
34699: LD_INT 0
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: LD_INT 1
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 2
34720: PUSH
34721: LD_INT 1
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PUSH
34728: LD_INT 2
34730: PUSH
34731: LD_INT 2
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 1
34740: PUSH
34741: LD_INT 2
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: LD_INT 2
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 1
34760: NEG
34761: PUSH
34762: LD_INT 1
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: LIST
34773: LIST
34774: LIST
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34783: LD_ADDR_VAR 0 51
34787: PUSH
34788: LD_INT 0
34790: PUSH
34791: LD_INT 0
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 0
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: LD_INT 0
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: PUSH
34819: LD_INT 1
34821: PUSH
34822: LD_INT 1
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 0
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: LD_INT 0
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 2
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: LD_INT 2
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 1
34884: NEG
34885: PUSH
34886: LD_INT 1
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 2
34895: NEG
34896: PUSH
34897: LD_INT 0
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 2
34906: NEG
34907: PUSH
34908: LD_INT 1
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: EMPTY
34917: LIST
34918: LIST
34919: LIST
34920: LIST
34921: LIST
34922: LIST
34923: LIST
34924: LIST
34925: LIST
34926: LIST
34927: LIST
34928: LIST
34929: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34930: LD_ADDR_VAR 0 52
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: LD_INT 0
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 0
34947: PUSH
34948: LD_INT 1
34950: NEG
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 1
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 1
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 0
34978: PUSH
34979: LD_INT 1
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 1
34988: NEG
34989: PUSH
34990: LD_INT 0
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 1
34999: NEG
35000: PUSH
35001: LD_INT 1
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: NEG
35012: PUSH
35013: LD_INT 2
35015: NEG
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: NEG
35024: PUSH
35025: LD_INT 1
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 2
35034: NEG
35035: PUSH
35036: LD_INT 0
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 2
35045: NEG
35046: PUSH
35047: LD_INT 1
35049: NEG
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 2
35057: NEG
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35081: LD_ADDR_VAR 0 53
35085: PUSH
35086: LD_INT 0
35088: PUSH
35089: LD_INT 0
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 0
35098: PUSH
35099: LD_INT 1
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 1
35109: PUSH
35110: LD_INT 0
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 1
35119: PUSH
35120: LD_INT 1
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 1
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 1
35139: NEG
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: NEG
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: EMPTY
35157: LIST
35158: LIST
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: LD_INT 2
35166: NEG
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: LD_INT 2
35177: NEG
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 1
35185: PUSH
35186: LD_INT 1
35188: NEG
35189: PUSH
35190: EMPTY
35191: LIST
35192: LIST
35193: PUSH
35194: LD_INT 2
35196: PUSH
35197: LD_INT 0
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 2
35206: PUSH
35207: LD_INT 1
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 2
35216: PUSH
35217: LD_INT 2
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 1
35226: PUSH
35227: LD_INT 2
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 0
35236: PUSH
35237: LD_INT 2
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: LD_INT 1
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 2
35257: NEG
35258: PUSH
35259: LD_INT 0
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: LD_INT 1
35272: NEG
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 2
35280: NEG
35281: PUSH
35282: LD_INT 2
35284: NEG
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35311: LD_ADDR_VAR 0 54
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 0
35328: PUSH
35329: LD_INT 1
35331: NEG
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: LD_INT 0
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: LD_INT 1
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 0
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 1
35369: NEG
35370: PUSH
35371: LD_INT 0
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: LD_INT 1
35380: NEG
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: LD_INT 2
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 0
35404: PUSH
35405: LD_INT 2
35407: NEG
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: PUSH
35416: LD_INT 1
35418: NEG
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 2
35426: PUSH
35427: LD_INT 0
35429: PUSH
35430: EMPTY
35431: LIST
35432: LIST
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: LD_INT 1
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 2
35446: PUSH
35447: LD_INT 2
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 1
35456: PUSH
35457: LD_INT 2
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: LD_INT 2
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: LD_INT 1
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 2
35487: NEG
35488: PUSH
35489: LD_INT 0
35491: PUSH
35492: EMPTY
35493: LIST
35494: LIST
35495: PUSH
35496: LD_INT 2
35498: NEG
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 2
35510: NEG
35511: PUSH
35512: LD_INT 2
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35541: LD_ADDR_VAR 0 55
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: LD_INT 0
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: LD_INT 1
35561: NEG
35562: PUSH
35563: EMPTY
35564: LIST
35565: LIST
35566: PUSH
35567: LD_INT 1
35569: PUSH
35570: LD_INT 0
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 0
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 1
35599: NEG
35600: PUSH
35601: LD_INT 0
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 1
35610: NEG
35611: PUSH
35612: LD_INT 1
35614: NEG
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: LD_INT 2
35626: NEG
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PUSH
35632: LD_INT 0
35634: PUSH
35635: LD_INT 2
35637: NEG
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: LD_INT 1
35645: PUSH
35646: LD_INT 1
35648: NEG
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 2
35656: PUSH
35657: LD_INT 0
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: LD_INT 1
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 2
35676: PUSH
35677: LD_INT 2
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: LD_INT 2
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 2
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 2
35717: NEG
35718: PUSH
35719: LD_INT 0
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: NEG
35729: PUSH
35730: LD_INT 1
35732: NEG
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: NEG
35741: PUSH
35742: LD_INT 2
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35771: LD_ADDR_VAR 0 56
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: LD_INT 0
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 0
35788: PUSH
35789: LD_INT 1
35791: NEG
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: LD_INT 0
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 0
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 1
35829: NEG
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: LD_INT 1
35840: NEG
35841: PUSH
35842: LD_INT 1
35844: NEG
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 2
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 0
35864: PUSH
35865: LD_INT 2
35867: NEG
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: PUSH
35876: LD_INT 1
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 2
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 2
35896: PUSH
35897: LD_INT 1
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 2
35906: PUSH
35907: LD_INT 2
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: PUSH
35917: LD_INT 2
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: LD_INT 2
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: LD_INT 1
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 2
35947: NEG
35948: PUSH
35949: LD_INT 0
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: NEG
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 2
35970: NEG
35971: PUSH
35972: LD_INT 2
35974: NEG
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36001: LD_ADDR_VAR 0 57
36005: PUSH
36006: LD_INT 0
36008: PUSH
36009: LD_INT 0
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 0
36018: PUSH
36019: LD_INT 1
36021: NEG
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 1
36029: PUSH
36030: LD_INT 0
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 1
36039: PUSH
36040: LD_INT 1
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 0
36049: PUSH
36050: LD_INT 1
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 1
36059: NEG
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: NEG
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: LD_INT 2
36086: NEG
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: LD_INT 2
36097: NEG
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 1
36105: PUSH
36106: LD_INT 1
36108: NEG
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 2
36116: PUSH
36117: LD_INT 0
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 2
36126: PUSH
36127: LD_INT 1
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 2
36136: PUSH
36137: LD_INT 2
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: PUSH
36147: LD_INT 2
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 2
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 1
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 2
36177: NEG
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: NEG
36189: PUSH
36190: LD_INT 1
36192: NEG
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: LD_INT 2
36200: NEG
36201: PUSH
36202: LD_INT 2
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36231: LD_ADDR_VAR 0 58
36235: PUSH
36236: LD_INT 0
36238: PUSH
36239: LD_INT 0
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 0
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: LD_INT 0
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: LD_INT 1
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 0
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 1
36300: NEG
36301: PUSH
36302: LD_INT 1
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 1
36312: NEG
36313: PUSH
36314: LD_INT 2
36316: NEG
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: LD_INT 2
36327: NEG
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 2
36346: PUSH
36347: LD_INT 0
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 2
36366: PUSH
36367: LD_INT 2
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: PUSH
36377: LD_INT 2
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: LD_INT 2
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 1
36396: NEG
36397: PUSH
36398: LD_INT 1
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 2
36407: NEG
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: LD_INT 1
36422: NEG
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 2
36430: NEG
36431: PUSH
36432: LD_INT 2
36434: NEG
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: EMPTY
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36461: LD_ADDR_VAR 0 59
36465: PUSH
36466: LD_INT 0
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: EMPTY
36484: LIST
36485: LIST
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: LD_INT 0
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 1
36499: PUSH
36500: LD_INT 1
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 1
36530: NEG
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36549: LD_ADDR_VAR 0 60
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: LD_INT 0
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: LD_INT 1
36569: NEG
36570: PUSH
36571: EMPTY
36572: LIST
36573: LIST
36574: PUSH
36575: LD_INT 1
36577: PUSH
36578: LD_INT 0
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: PUSH
36588: LD_INT 1
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: LD_INT 1
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 1
36607: NEG
36608: PUSH
36609: LD_INT 0
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 1
36618: NEG
36619: PUSH
36620: LD_INT 1
36622: NEG
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: LIST
36635: LIST
36636: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36637: LD_ADDR_VAR 0 61
36641: PUSH
36642: LD_INT 0
36644: PUSH
36645: LD_INT 0
36647: PUSH
36648: EMPTY
36649: LIST
36650: LIST
36651: PUSH
36652: LD_INT 0
36654: PUSH
36655: LD_INT 1
36657: NEG
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 1
36665: PUSH
36666: LD_INT 0
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 1
36675: PUSH
36676: LD_INT 1
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 0
36685: PUSH
36686: LD_INT 1
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: NEG
36696: PUSH
36697: LD_INT 0
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: NEG
36707: PUSH
36708: LD_INT 1
36710: NEG
36711: PUSH
36712: EMPTY
36713: LIST
36714: LIST
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: LIST
36720: LIST
36721: LIST
36722: LIST
36723: LIST
36724: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36725: LD_ADDR_VAR 0 62
36729: PUSH
36730: LD_INT 0
36732: PUSH
36733: LD_INT 0
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 0
36742: PUSH
36743: LD_INT 1
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: LD_INT 0
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 1
36763: PUSH
36764: LD_INT 1
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 0
36773: PUSH
36774: LD_INT 1
36776: PUSH
36777: EMPTY
36778: LIST
36779: LIST
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: LD_INT 0
36787: PUSH
36788: EMPTY
36789: LIST
36790: LIST
36791: PUSH
36792: LD_INT 1
36794: NEG
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: EMPTY
36805: LIST
36806: LIST
36807: LIST
36808: LIST
36809: LIST
36810: LIST
36811: LIST
36812: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36813: LD_ADDR_VAR 0 63
36817: PUSH
36818: LD_INT 0
36820: PUSH
36821: LD_INT 0
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: PUSH
36828: LD_INT 0
36830: PUSH
36831: LD_INT 1
36833: NEG
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 1
36841: PUSH
36842: LD_INT 0
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 1
36851: PUSH
36852: LD_INT 1
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 0
36861: PUSH
36862: LD_INT 1
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 1
36871: NEG
36872: PUSH
36873: LD_INT 0
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: LD_INT 1
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36901: LD_ADDR_VAR 0 64
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 0
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: LD_INT 1
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: LD_INT 0
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: LIST
36984: LIST
36985: LIST
36986: LIST
36987: LIST
36988: ST_TO_ADDR
// end ; 1 :
36989: GO 42886
36991: LD_INT 1
36993: DOUBLE
36994: EQUAL
36995: IFTRUE 36999
36997: GO 39622
36999: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37000: LD_ADDR_VAR 0 11
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37044: LD_ADDR_VAR 0 12
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37085: LD_ADDR_VAR 0 13
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37125: LD_ADDR_VAR 0 14
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37166: LD_ADDR_VAR 0 15
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 3
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: LIST
37209: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37210: LD_ADDR_VAR 0 16
37214: PUSH
37215: LD_INT 2
37217: NEG
37218: PUSH
37219: LD_INT 3
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37256: LD_ADDR_VAR 0 17
37260: PUSH
37261: LD_INT 1
37263: NEG
37264: PUSH
37265: LD_INT 3
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 0
37275: PUSH
37276: LD_INT 3
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 2
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: LIST
37299: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37300: LD_ADDR_VAR 0 18
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: LD_INT 1
37310: NEG
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 3
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 3
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37341: LD_ADDR_VAR 0 19
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: LD_INT 2
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 3
37358: PUSH
37359: LD_INT 3
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 2
37368: PUSH
37369: LD_INT 3
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37381: LD_ADDR_VAR 0 20
37385: PUSH
37386: LD_INT 1
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 0
37398: PUSH
37399: LD_INT 3
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: LD_INT 2
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37422: LD_ADDR_VAR 0 21
37426: PUSH
37427: LD_INT 2
37429: NEG
37430: PUSH
37431: LD_INT 1
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: NEG
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 3
37451: NEG
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37466: LD_ADDR_VAR 0 22
37470: PUSH
37471: LD_INT 2
37473: NEG
37474: PUSH
37475: LD_INT 3
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: NEG
37486: PUSH
37487: LD_INT 2
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 3
37497: NEG
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37512: LD_ADDR_VAR 0 23
37516: PUSH
37517: LD_INT 0
37519: PUSH
37520: LD_INT 3
37522: NEG
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 4
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 3
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: EMPTY
37552: LIST
37553: LIST
37554: LIST
37555: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37556: LD_ADDR_VAR 0 24
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: LD_INT 0
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 3
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 4
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: LIST
37596: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37597: LD_ADDR_VAR 0 25
37601: PUSH
37602: LD_INT 3
37604: PUSH
37605: LD_INT 3
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 4
37614: PUSH
37615: LD_INT 3
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 3
37624: PUSH
37625: LD_INT 4
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37637: LD_ADDR_VAR 0 26
37641: PUSH
37642: LD_INT 0
37644: PUSH
37645: LD_INT 3
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 4
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 3
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: LIST
37677: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37678: LD_ADDR_VAR 0 27
37682: PUSH
37683: LD_INT 3
37685: NEG
37686: PUSH
37687: LD_INT 0
37689: PUSH
37690: EMPTY
37691: LIST
37692: LIST
37693: PUSH
37694: LD_INT 3
37696: NEG
37697: PUSH
37698: LD_INT 1
37700: PUSH
37701: EMPTY
37702: LIST
37703: LIST
37704: PUSH
37705: LD_INT 4
37707: NEG
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: LIST
37721: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37722: LD_ADDR_VAR 0 28
37726: PUSH
37727: LD_INT 3
37729: NEG
37730: PUSH
37731: LD_INT 3
37733: NEG
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 3
37741: NEG
37742: PUSH
37743: LD_INT 4
37745: NEG
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 4
37753: NEG
37754: PUSH
37755: LD_INT 3
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: LIST
37767: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37768: LD_ADDR_VAR 0 29
37772: PUSH
37773: LD_INT 1
37775: NEG
37776: PUSH
37777: LD_INT 3
37779: NEG
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 0
37787: PUSH
37788: LD_INT 3
37790: NEG
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 1
37798: PUSH
37799: LD_INT 2
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 1
37809: NEG
37810: PUSH
37811: LD_INT 4
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 0
37821: PUSH
37822: LD_INT 4
37824: NEG
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 1
37832: PUSH
37833: LD_INT 3
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: NEG
37844: PUSH
37845: LD_INT 5
37847: NEG
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: LD_INT 5
37858: NEG
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: LD_INT 4
37869: NEG
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: LD_INT 6
37881: NEG
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PUSH
37887: LD_INT 0
37889: PUSH
37890: LD_INT 6
37892: NEG
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 1
37900: PUSH
37901: LD_INT 5
37903: NEG
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37923: LD_ADDR_VAR 0 30
37927: PUSH
37928: LD_INT 2
37930: PUSH
37931: LD_INT 1
37933: NEG
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 3
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 3
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 3
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 4
37972: PUSH
37973: LD_INT 0
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 4
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 4
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 5
38003: PUSH
38004: LD_INT 0
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: PUSH
38011: LD_INT 5
38013: PUSH
38014: LD_INT 1
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 5
38023: PUSH
38024: LD_INT 1
38026: NEG
38027: PUSH
38028: EMPTY
38029: LIST
38030: LIST
38031: PUSH
38032: LD_INT 6
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 6
38044: PUSH
38045: LD_INT 1
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38066: LD_ADDR_VAR 0 31
38070: PUSH
38071: LD_INT 3
38073: PUSH
38074: LD_INT 2
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 3
38083: PUSH
38084: LD_INT 3
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 2
38093: PUSH
38094: LD_INT 3
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 4
38103: PUSH
38104: LD_INT 3
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 4
38113: PUSH
38114: LD_INT 4
38116: PUSH
38117: EMPTY
38118: LIST
38119: LIST
38120: PUSH
38121: LD_INT 3
38123: PUSH
38124: LD_INT 4
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 5
38133: PUSH
38134: LD_INT 4
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 5
38143: PUSH
38144: LD_INT 5
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 4
38153: PUSH
38154: LD_INT 5
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 6
38163: PUSH
38164: LD_INT 5
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 6
38173: PUSH
38174: LD_INT 6
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 5
38183: PUSH
38184: LD_INT 6
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: LIST
38202: LIST
38203: LIST
38204: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38205: LD_ADDR_VAR 0 32
38209: PUSH
38210: LD_INT 1
38212: PUSH
38213: LD_INT 3
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 0
38222: PUSH
38223: LD_INT 3
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: NEG
38233: PUSH
38234: LD_INT 2
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: LD_INT 4
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 0
38253: PUSH
38254: LD_INT 4
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: LD_INT 3
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PUSH
38272: LD_INT 1
38274: PUSH
38275: LD_INT 5
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: LD_INT 5
38287: PUSH
38288: EMPTY
38289: LIST
38290: LIST
38291: PUSH
38292: LD_INT 1
38294: NEG
38295: PUSH
38296: LD_INT 4
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: LD_INT 6
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 0
38315: PUSH
38316: LD_INT 6
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: LD_INT 5
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: LIST
38347: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38348: LD_ADDR_VAR 0 33
38352: PUSH
38353: LD_INT 2
38355: NEG
38356: PUSH
38357: LD_INT 1
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 3
38366: NEG
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 3
38377: NEG
38378: PUSH
38379: LD_INT 1
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 3
38389: NEG
38390: PUSH
38391: LD_INT 1
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 4
38400: NEG
38401: PUSH
38402: LD_INT 0
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 4
38411: NEG
38412: PUSH
38413: LD_INT 1
38415: NEG
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 4
38423: NEG
38424: PUSH
38425: LD_INT 1
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 5
38434: NEG
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 5
38445: NEG
38446: PUSH
38447: LD_INT 1
38449: NEG
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 5
38457: NEG
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 6
38468: NEG
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 6
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38503: LD_ADDR_VAR 0 34
38507: PUSH
38508: LD_INT 2
38510: NEG
38511: PUSH
38512: LD_INT 3
38514: NEG
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 3
38522: NEG
38523: PUSH
38524: LD_INT 2
38526: NEG
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 3
38534: NEG
38535: PUSH
38536: LD_INT 3
38538: NEG
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PUSH
38544: LD_INT 3
38546: NEG
38547: PUSH
38548: LD_INT 4
38550: NEG
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 4
38558: NEG
38559: PUSH
38560: LD_INT 3
38562: NEG
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 4
38570: NEG
38571: PUSH
38572: LD_INT 4
38574: NEG
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 4
38582: NEG
38583: PUSH
38584: LD_INT 5
38586: NEG
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 5
38594: NEG
38595: PUSH
38596: LD_INT 4
38598: NEG
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 5
38606: NEG
38607: PUSH
38608: LD_INT 5
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 5
38618: NEG
38619: PUSH
38620: LD_INT 6
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 6
38630: NEG
38631: PUSH
38632: LD_INT 5
38634: NEG
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 6
38642: NEG
38643: PUSH
38644: LD_INT 6
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38666: LD_ADDR_VAR 0 41
38670: PUSH
38671: LD_INT 0
38673: PUSH
38674: LD_INT 2
38676: NEG
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 1
38684: NEG
38685: PUSH
38686: LD_INT 3
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: LD_INT 2
38699: NEG
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: LIST
38709: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38710: LD_ADDR_VAR 0 42
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: PUSH
38728: LD_INT 1
38730: NEG
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 3
38738: PUSH
38739: LD_INT 1
38741: PUSH
38742: EMPTY
38743: LIST
38744: LIST
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: LIST
38750: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38751: LD_ADDR_VAR 0 43
38755: PUSH
38756: LD_INT 2
38758: PUSH
38759: LD_INT 2
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 3
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 2
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: LIST
38790: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38791: LD_ADDR_VAR 0 44
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: LD_INT 2
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: LD_INT 3
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: LD_INT 2
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: EMPTY
38828: LIST
38829: LIST
38830: LIST
38831: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38832: LD_ADDR_VAR 0 45
38836: PUSH
38837: LD_INT 2
38839: NEG
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 2
38850: NEG
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 3
38861: NEG
38862: PUSH
38863: LD_INT 1
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: LIST
38875: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38876: LD_ADDR_VAR 0 46
38880: PUSH
38881: LD_INT 2
38883: NEG
38884: PUSH
38885: LD_INT 2
38887: NEG
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 2
38895: NEG
38896: PUSH
38897: LD_INT 3
38899: NEG
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 3
38907: NEG
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: LIST
38921: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38922: LD_ADDR_VAR 0 47
38926: PUSH
38927: LD_INT 2
38929: NEG
38930: PUSH
38931: LD_INT 3
38933: NEG
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: LD_INT 3
38945: NEG
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38955: LD_ADDR_VAR 0 48
38959: PUSH
38960: LD_INT 1
38962: PUSH
38963: LD_INT 2
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38986: LD_ADDR_VAR 0 49
38990: PUSH
38991: LD_INT 3
38993: PUSH
38994: LD_INT 1
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 3
39003: PUSH
39004: LD_INT 2
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39015: LD_ADDR_VAR 0 50
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: LD_INT 3
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 3
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39044: LD_ADDR_VAR 0 51
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: LD_INT 2
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 2
39062: NEG
39063: PUSH
39064: LD_INT 1
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39075: LD_ADDR_VAR 0 52
39079: PUSH
39080: LD_INT 3
39082: NEG
39083: PUSH
39084: LD_INT 1
39086: NEG
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 3
39094: NEG
39095: PUSH
39096: LD_INT 2
39098: NEG
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39108: LD_ADDR_VAR 0 53
39112: PUSH
39113: LD_INT 1
39115: NEG
39116: PUSH
39117: LD_INT 3
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: LD_INT 3
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: LD_INT 2
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39152: LD_ADDR_VAR 0 54
39156: PUSH
39157: LD_INT 2
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 3
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 3
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39193: LD_ADDR_VAR 0 55
39197: PUSH
39198: LD_INT 3
39200: PUSH
39201: LD_INT 2
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 3
39210: PUSH
39211: LD_INT 3
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: LD_INT 3
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39233: LD_ADDR_VAR 0 56
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: LD_INT 3
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 3
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: LD_INT 2
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39274: LD_ADDR_VAR 0 57
39278: PUSH
39279: LD_INT 2
39281: NEG
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 3
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 3
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39318: LD_ADDR_VAR 0 58
39322: PUSH
39323: LD_INT 2
39325: NEG
39326: PUSH
39327: LD_INT 3
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 3
39337: NEG
39338: PUSH
39339: LD_INT 2
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 3
39349: NEG
39350: PUSH
39351: LD_INT 3
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39364: LD_ADDR_VAR 0 59
39368: PUSH
39369: LD_INT 1
39371: NEG
39372: PUSH
39373: LD_INT 2
39375: NEG
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: LD_INT 2
39386: NEG
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 1
39394: PUSH
39395: LD_INT 1
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: EMPTY
39404: LIST
39405: LIST
39406: LIST
39407: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39408: LD_ADDR_VAR 0 60
39412: PUSH
39413: LD_INT 1
39415: PUSH
39416: LD_INT 1
39418: NEG
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 2
39426: PUSH
39427: LD_INT 0
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: LIST
39448: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39449: LD_ADDR_VAR 0 61
39453: PUSH
39454: LD_INT 2
39456: PUSH
39457: LD_INT 1
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 2
39466: PUSH
39467: LD_INT 2
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 1
39476: PUSH
39477: LD_INT 2
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: LIST
39488: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39489: LD_ADDR_VAR 0 62
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: LD_INT 2
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 2
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 1
39516: NEG
39517: PUSH
39518: LD_INT 1
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: EMPTY
39526: LIST
39527: LIST
39528: LIST
39529: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39530: LD_ADDR_VAR 0 63
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: LD_INT 1
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 2
39548: NEG
39549: PUSH
39550: LD_INT 0
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 2
39559: NEG
39560: PUSH
39561: LD_INT 1
39563: NEG
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: LIST
39573: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39574: LD_ADDR_VAR 0 64
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: PUSH
39583: LD_INT 2
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 2
39593: NEG
39594: PUSH
39595: LD_INT 1
39597: NEG
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 2
39605: NEG
39606: PUSH
39607: LD_INT 2
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: LIST
39619: ST_TO_ADDR
// end ; 2 :
39620: GO 42886
39622: LD_INT 2
39624: DOUBLE
39625: EQUAL
39626: IFTRUE 39630
39628: GO 42885
39630: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39631: LD_ADDR_VAR 0 29
39635: PUSH
39636: LD_INT 4
39638: PUSH
39639: LD_INT 0
39641: PUSH
39642: EMPTY
39643: LIST
39644: LIST
39645: PUSH
39646: LD_INT 4
39648: PUSH
39649: LD_INT 1
39651: NEG
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 5
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 5
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 4
39679: PUSH
39680: LD_INT 1
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 3
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 3
39699: PUSH
39700: LD_INT 1
39702: NEG
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 3
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 5
39721: PUSH
39722: LD_INT 2
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 3
39731: PUSH
39732: LD_INT 3
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: PUSH
39739: LD_INT 3
39741: PUSH
39742: LD_INT 2
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 4
39751: PUSH
39752: LD_INT 3
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 4
39761: PUSH
39762: LD_INT 4
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 3
39771: PUSH
39772: LD_INT 4
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: LD_INT 3
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 2
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 4
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 2
39811: PUSH
39812: LD_INT 4
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: LD_INT 4
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 0
39831: PUSH
39832: LD_INT 3
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: PUSH
39839: LD_INT 1
39841: PUSH
39842: LD_INT 4
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: LD_INT 5
39854: PUSH
39855: EMPTY
39856: LIST
39857: LIST
39858: PUSH
39859: LD_INT 0
39861: PUSH
39862: LD_INT 5
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: LD_INT 1
39871: NEG
39872: PUSH
39873: LD_INT 4
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 1
39882: NEG
39883: PUSH
39884: LD_INT 3
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: PUSH
39894: LD_INT 5
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 2
39903: NEG
39904: PUSH
39905: LD_INT 3
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 3
39914: NEG
39915: PUSH
39916: LD_INT 0
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 3
39925: NEG
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 2
39937: NEG
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 2
39948: NEG
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 3
39959: NEG
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 4
39970: NEG
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: EMPTY
39976: LIST
39977: LIST
39978: PUSH
39979: LD_INT 4
39981: NEG
39982: PUSH
39983: LD_INT 1
39985: NEG
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 4
39993: NEG
39994: PUSH
39995: LD_INT 2
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 2
40005: NEG
40006: PUSH
40007: LD_INT 2
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 4
40016: NEG
40017: PUSH
40018: LD_INT 4
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 4
40028: NEG
40029: PUSH
40030: LD_INT 5
40032: NEG
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 3
40040: NEG
40041: PUSH
40042: LD_INT 4
40044: NEG
40045: PUSH
40046: EMPTY
40047: LIST
40048: LIST
40049: PUSH
40050: LD_INT 3
40052: NEG
40053: PUSH
40054: LD_INT 3
40056: NEG
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 4
40064: NEG
40065: PUSH
40066: LD_INT 3
40068: NEG
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 5
40076: NEG
40077: PUSH
40078: LD_INT 4
40080: NEG
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 5
40088: NEG
40089: PUSH
40090: LD_INT 5
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 3
40100: NEG
40101: PUSH
40102: LD_INT 5
40104: NEG
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 5
40112: NEG
40113: PUSH
40114: LD_INT 3
40116: NEG
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40169: LD_ADDR_VAR 0 30
40173: PUSH
40174: LD_INT 4
40176: PUSH
40177: LD_INT 4
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 4
40186: PUSH
40187: LD_INT 3
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 5
40196: PUSH
40197: LD_INT 4
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 5
40206: PUSH
40207: LD_INT 5
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 4
40216: PUSH
40217: LD_INT 5
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 3
40226: PUSH
40227: LD_INT 4
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 3
40236: PUSH
40237: LD_INT 3
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 5
40246: PUSH
40247: LD_INT 3
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 3
40256: PUSH
40257: LD_INT 5
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 3
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 0
40276: PUSH
40277: LD_INT 2
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 1
40286: PUSH
40287: LD_INT 3
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 1
40296: PUSH
40297: LD_INT 4
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 0
40306: PUSH
40307: LD_INT 4
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 1
40316: NEG
40317: PUSH
40318: LD_INT 3
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 1
40327: NEG
40328: PUSH
40329: LD_INT 2
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 2
40338: PUSH
40339: LD_INT 4
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 2
40348: NEG
40349: PUSH
40350: LD_INT 2
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 4
40359: NEG
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 4
40370: NEG
40371: PUSH
40372: LD_INT 1
40374: NEG
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 3
40382: NEG
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 3
40393: NEG
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 4
40404: NEG
40405: PUSH
40406: LD_INT 1
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 5
40415: NEG
40416: PUSH
40417: LD_INT 0
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 5
40426: NEG
40427: PUSH
40428: LD_INT 1
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 5
40438: NEG
40439: PUSH
40440: LD_INT 2
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 3
40450: NEG
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 3
40461: NEG
40462: PUSH
40463: LD_INT 3
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 3
40473: NEG
40474: PUSH
40475: LD_INT 4
40477: NEG
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: LD_INT 2
40485: NEG
40486: PUSH
40487: LD_INT 3
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 2
40497: NEG
40498: PUSH
40499: LD_INT 2
40501: NEG
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: LD_INT 2
40513: NEG
40514: PUSH
40515: EMPTY
40516: LIST
40517: LIST
40518: PUSH
40519: LD_INT 4
40521: NEG
40522: PUSH
40523: LD_INT 3
40525: NEG
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: PUSH
40531: LD_INT 4
40533: NEG
40534: PUSH
40535: LD_INT 4
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 2
40545: NEG
40546: PUSH
40547: LD_INT 4
40549: NEG
40550: PUSH
40551: EMPTY
40552: LIST
40553: LIST
40554: PUSH
40555: LD_INT 4
40557: NEG
40558: PUSH
40559: LD_INT 2
40561: NEG
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 0
40569: PUSH
40570: LD_INT 4
40572: NEG
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: LD_INT 5
40583: NEG
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 1
40591: PUSH
40592: LD_INT 4
40594: NEG
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 1
40602: PUSH
40603: LD_INT 3
40605: NEG
40606: PUSH
40607: EMPTY
40608: LIST
40609: LIST
40610: PUSH
40611: LD_INT 0
40613: PUSH
40614: LD_INT 3
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 1
40624: NEG
40625: PUSH
40626: LD_INT 4
40628: NEG
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: LD_INT 5
40640: NEG
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 2
40648: PUSH
40649: LD_INT 3
40651: NEG
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 2
40659: NEG
40660: PUSH
40661: LD_INT 5
40663: NEG
40664: PUSH
40665: EMPTY
40666: LIST
40667: LIST
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40716: LD_ADDR_VAR 0 31
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_INT 4
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 0
40733: PUSH
40734: LD_INT 3
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 1
40743: PUSH
40744: LD_INT 4
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 1
40753: PUSH
40754: LD_INT 5
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: LD_INT 5
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 1
40773: NEG
40774: PUSH
40775: LD_INT 4
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 1
40784: NEG
40785: PUSH
40786: LD_INT 3
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 2
40795: PUSH
40796: LD_INT 5
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 2
40805: NEG
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: EMPTY
40811: LIST
40812: LIST
40813: PUSH
40814: LD_INT 3
40816: NEG
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 3
40827: NEG
40828: PUSH
40829: LD_INT 1
40831: NEG
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 2
40839: NEG
40840: PUSH
40841: LD_INT 0
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: LD_INT 2
40850: NEG
40851: PUSH
40852: LD_INT 1
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: LD_INT 3
40861: NEG
40862: PUSH
40863: LD_INT 1
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 4
40872: NEG
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 4
40883: NEG
40884: PUSH
40885: LD_INT 1
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 4
40895: NEG
40896: PUSH
40897: LD_INT 2
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 2
40907: NEG
40908: PUSH
40909: LD_INT 2
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 4
40918: NEG
40919: PUSH
40920: LD_INT 4
40922: NEG
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 4
40930: NEG
40931: PUSH
40932: LD_INT 5
40934: NEG
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 3
40942: NEG
40943: PUSH
40944: LD_INT 4
40946: NEG
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: PUSH
40952: LD_INT 3
40954: NEG
40955: PUSH
40956: LD_INT 3
40958: NEG
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 4
40966: NEG
40967: PUSH
40968: LD_INT 3
40970: NEG
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: PUSH
40976: LD_INT 5
40978: NEG
40979: PUSH
40980: LD_INT 4
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 5
40990: NEG
40991: PUSH
40992: LD_INT 5
40994: NEG
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: LD_INT 5
41006: NEG
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 5
41014: NEG
41015: PUSH
41016: LD_INT 3
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: LD_INT 0
41026: PUSH
41027: LD_INT 3
41029: NEG
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 0
41037: PUSH
41038: LD_INT 4
41040: NEG
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: LD_INT 1
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 1
41059: PUSH
41060: LD_INT 2
41062: NEG
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 0
41070: PUSH
41071: LD_INT 2
41073: NEG
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 1
41081: NEG
41082: PUSH
41083: LD_INT 3
41085: NEG
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 1
41093: NEG
41094: PUSH
41095: LD_INT 4
41097: NEG
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: LD_INT 2
41105: PUSH
41106: LD_INT 2
41108: NEG
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: PUSH
41114: LD_INT 2
41116: NEG
41117: PUSH
41118: LD_INT 4
41120: NEG
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 4
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 4
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 5
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 5
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 4
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: LD_INT 0
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 3
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: LD_INT 3
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: EMPTY
41206: LIST
41207: LIST
41208: PUSH
41209: LD_INT 5
41211: PUSH
41212: LD_INT 2
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: LIST
41223: LIST
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41266: LD_ADDR_VAR 0 32
41270: PUSH
41271: LD_INT 4
41273: NEG
41274: PUSH
41275: LD_INT 0
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 4
41284: NEG
41285: PUSH
41286: LD_INT 1
41288: NEG
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 3
41296: NEG
41297: PUSH
41298: LD_INT 0
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 3
41307: NEG
41308: PUSH
41309: LD_INT 1
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PUSH
41316: LD_INT 4
41318: NEG
41319: PUSH
41320: LD_INT 1
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 5
41329: NEG
41330: PUSH
41331: LD_INT 0
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 5
41340: NEG
41341: PUSH
41342: LD_INT 1
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 5
41352: NEG
41353: PUSH
41354: LD_INT 2
41356: NEG
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 3
41364: NEG
41365: PUSH
41366: LD_INT 2
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 3
41375: NEG
41376: PUSH
41377: LD_INT 3
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 3
41387: NEG
41388: PUSH
41389: LD_INT 4
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 2
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 2
41411: NEG
41412: PUSH
41413: LD_INT 2
41415: NEG
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: PUSH
41421: LD_INT 3
41423: NEG
41424: PUSH
41425: LD_INT 2
41427: NEG
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 4
41435: NEG
41436: PUSH
41437: LD_INT 3
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 4
41447: NEG
41448: PUSH
41449: LD_INT 4
41451: NEG
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: PUSH
41457: LD_INT 2
41459: NEG
41460: PUSH
41461: LD_INT 4
41463: NEG
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 4
41471: NEG
41472: PUSH
41473: LD_INT 2
41475: NEG
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: LD_INT 0
41483: PUSH
41484: LD_INT 4
41486: NEG
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 0
41494: PUSH
41495: LD_INT 5
41497: NEG
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 1
41505: PUSH
41506: LD_INT 4
41508: NEG
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 1
41516: PUSH
41517: LD_INT 3
41519: NEG
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: LD_INT 0
41527: PUSH
41528: LD_INT 3
41530: NEG
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 1
41538: NEG
41539: PUSH
41540: LD_INT 4
41542: NEG
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: LD_INT 5
41554: NEG
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: PUSH
41560: LD_INT 2
41562: PUSH
41563: LD_INT 3
41565: NEG
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 2
41573: NEG
41574: PUSH
41575: LD_INT 5
41577: NEG
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PUSH
41583: LD_INT 3
41585: PUSH
41586: LD_INT 0
41588: PUSH
41589: EMPTY
41590: LIST
41591: LIST
41592: PUSH
41593: LD_INT 3
41595: PUSH
41596: LD_INT 1
41598: NEG
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 4
41606: PUSH
41607: LD_INT 0
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 4
41616: PUSH
41617: LD_INT 1
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 3
41626: PUSH
41627: LD_INT 1
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 2
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 2
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 2
41657: PUSH
41658: LD_INT 2
41660: NEG
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 4
41668: PUSH
41669: LD_INT 2
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 4
41678: PUSH
41679: LD_INT 4
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 4
41688: PUSH
41689: LD_INT 3
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 5
41698: PUSH
41699: LD_INT 4
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 5
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 4
41718: PUSH
41719: LD_INT 5
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 3
41728: PUSH
41729: LD_INT 4
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 3
41738: PUSH
41739: LD_INT 3
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 5
41748: PUSH
41749: LD_INT 3
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: PUSH
41756: LD_INT 3
41758: PUSH
41759: LD_INT 5
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41813: LD_ADDR_VAR 0 33
41817: PUSH
41818: LD_INT 4
41820: NEG
41821: PUSH
41822: LD_INT 4
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 4
41832: NEG
41833: PUSH
41834: LD_INT 5
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: NEG
41845: PUSH
41846: LD_INT 4
41848: NEG
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 3
41856: NEG
41857: PUSH
41858: LD_INT 3
41860: NEG
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 4
41868: NEG
41869: PUSH
41870: LD_INT 3
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 5
41880: NEG
41881: PUSH
41882: LD_INT 4
41884: NEG
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 5
41892: NEG
41893: PUSH
41894: LD_INT 5
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 3
41904: NEG
41905: PUSH
41906: LD_INT 5
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 5
41916: NEG
41917: PUSH
41918: LD_INT 3
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 0
41928: PUSH
41929: LD_INT 3
41931: NEG
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 0
41939: PUSH
41940: LD_INT 4
41942: NEG
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 1
41950: PUSH
41951: LD_INT 3
41953: NEG
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 1
41961: PUSH
41962: LD_INT 2
41964: NEG
41965: PUSH
41966: EMPTY
41967: LIST
41968: LIST
41969: PUSH
41970: LD_INT 0
41972: PUSH
41973: LD_INT 2
41975: NEG
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 3
41987: NEG
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 1
41995: NEG
41996: PUSH
41997: LD_INT 4
41999: NEG
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 2
42007: PUSH
42008: LD_INT 2
42010: NEG
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 2
42018: NEG
42019: PUSH
42020: LD_INT 4
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 4
42030: PUSH
42031: LD_INT 0
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 4
42040: PUSH
42041: LD_INT 1
42043: NEG
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 5
42051: PUSH
42052: LD_INT 0
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 5
42061: PUSH
42062: LD_INT 1
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 4
42071: PUSH
42072: LD_INT 1
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 3
42081: PUSH
42082: LD_INT 0
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 3
42091: PUSH
42092: LD_INT 1
42094: NEG
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 3
42102: PUSH
42103: LD_INT 2
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 5
42113: PUSH
42114: LD_INT 2
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 3
42123: PUSH
42124: LD_INT 3
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 3
42133: PUSH
42134: LD_INT 2
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 4
42143: PUSH
42144: LD_INT 3
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 4
42153: PUSH
42154: LD_INT 4
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 3
42163: PUSH
42164: LD_INT 4
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 2
42173: PUSH
42174: LD_INT 3
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 2
42183: PUSH
42184: LD_INT 2
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 4
42193: PUSH
42194: LD_INT 2
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 2
42203: PUSH
42204: LD_INT 4
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 0
42213: PUSH
42214: LD_INT 4
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: LD_INT 3
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 1
42233: PUSH
42234: LD_INT 4
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 1
42243: PUSH
42244: LD_INT 5
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 0
42253: PUSH
42254: LD_INT 5
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 1
42263: NEG
42264: PUSH
42265: LD_INT 4
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 1
42274: NEG
42275: PUSH
42276: LD_INT 3
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 2
42285: PUSH
42286: LD_INT 5
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: NEG
42296: PUSH
42297: LD_INT 3
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: EMPTY
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: LIST
42336: LIST
42337: LIST
42338: LIST
42339: LIST
42340: LIST
42341: LIST
42342: LIST
42343: LIST
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42351: LD_ADDR_VAR 0 34
42355: PUSH
42356: LD_INT 0
42358: PUSH
42359: LD_INT 4
42361: NEG
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 0
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 1
42380: PUSH
42381: LD_INT 4
42383: NEG
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: PUSH
42389: LD_INT 1
42391: PUSH
42392: LD_INT 3
42394: NEG
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 0
42402: PUSH
42403: LD_INT 3
42405: NEG
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 4
42417: NEG
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: LD_INT 5
42429: NEG
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: PUSH
42438: LD_INT 3
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 2
42448: NEG
42449: PUSH
42450: LD_INT 5
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 3
42460: PUSH
42461: LD_INT 0
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 3
42470: PUSH
42471: LD_INT 1
42473: NEG
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 4
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 4
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 3
42501: PUSH
42502: LD_INT 1
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 2
42511: PUSH
42512: LD_INT 0
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 2
42521: PUSH
42522: LD_INT 1
42524: NEG
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 2
42532: PUSH
42533: LD_INT 2
42535: NEG
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 4
42543: PUSH
42544: LD_INT 2
42546: PUSH
42547: EMPTY
42548: LIST
42549: LIST
42550: PUSH
42551: LD_INT 4
42553: PUSH
42554: LD_INT 4
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 4
42563: PUSH
42564: LD_INT 3
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 5
42573: PUSH
42574: LD_INT 4
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 5
42583: PUSH
42584: LD_INT 5
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: LD_INT 5
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 3
42603: PUSH
42604: LD_INT 4
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 3
42613: PUSH
42614: LD_INT 3
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 5
42623: PUSH
42624: LD_INT 3
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: PUSH
42631: LD_INT 3
42633: PUSH
42634: LD_INT 5
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 0
42643: PUSH
42644: LD_INT 3
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 0
42653: PUSH
42654: LD_INT 2
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: LD_INT 3
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: PUSH
42674: LD_INT 4
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: LD_INT 4
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: NEG
42694: PUSH
42695: LD_INT 3
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: LD_INT 1
42704: NEG
42705: PUSH
42706: LD_INT 2
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: LD_INT 4
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 2
42725: NEG
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 4
42736: NEG
42737: PUSH
42738: LD_INT 0
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 4
42747: NEG
42748: PUSH
42749: LD_INT 1
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 3
42759: NEG
42760: PUSH
42761: LD_INT 0
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 3
42770: NEG
42771: PUSH
42772: LD_INT 1
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 4
42781: NEG
42782: PUSH
42783: LD_INT 1
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 5
42792: NEG
42793: PUSH
42794: LD_INT 0
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: LD_INT 5
42803: NEG
42804: PUSH
42805: LD_INT 1
42807: NEG
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 5
42815: NEG
42816: PUSH
42817: LD_INT 2
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 3
42827: NEG
42828: PUSH
42829: LD_INT 2
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: ST_TO_ADDR
// end ; end ;
42883: GO 42886
42885: POP
// case btype of b_depot , b_warehouse :
42886: LD_VAR 0 1
42890: PUSH
42891: LD_INT 0
42893: DOUBLE
42894: EQUAL
42895: IFTRUE 42905
42897: LD_INT 1
42899: DOUBLE
42900: EQUAL
42901: IFTRUE 42905
42903: GO 43106
42905: POP
// case nation of nation_american :
42906: LD_VAR 0 5
42910: PUSH
42911: LD_INT 1
42913: DOUBLE
42914: EQUAL
42915: IFTRUE 42919
42917: GO 42975
42919: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42920: LD_ADDR_VAR 0 9
42924: PUSH
42925: LD_VAR 0 11
42929: PUSH
42930: LD_VAR 0 12
42934: PUSH
42935: LD_VAR 0 13
42939: PUSH
42940: LD_VAR 0 14
42944: PUSH
42945: LD_VAR 0 15
42949: PUSH
42950: LD_VAR 0 16
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: PUSH
42963: LD_VAR 0 4
42967: PUSH
42968: LD_INT 1
42970: PLUS
42971: ARRAY
42972: ST_TO_ADDR
42973: GO 43104
42975: LD_INT 2
42977: DOUBLE
42978: EQUAL
42979: IFTRUE 42983
42981: GO 43039
42983: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42984: LD_ADDR_VAR 0 9
42988: PUSH
42989: LD_VAR 0 17
42993: PUSH
42994: LD_VAR 0 18
42998: PUSH
42999: LD_VAR 0 19
43003: PUSH
43004: LD_VAR 0 20
43008: PUSH
43009: LD_VAR 0 21
43013: PUSH
43014: LD_VAR 0 22
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: LIST
43026: PUSH
43027: LD_VAR 0 4
43031: PUSH
43032: LD_INT 1
43034: PLUS
43035: ARRAY
43036: ST_TO_ADDR
43037: GO 43104
43039: LD_INT 3
43041: DOUBLE
43042: EQUAL
43043: IFTRUE 43047
43045: GO 43103
43047: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43048: LD_ADDR_VAR 0 9
43052: PUSH
43053: LD_VAR 0 23
43057: PUSH
43058: LD_VAR 0 24
43062: PUSH
43063: LD_VAR 0 25
43067: PUSH
43068: LD_VAR 0 26
43072: PUSH
43073: LD_VAR 0 27
43077: PUSH
43078: LD_VAR 0 28
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: LIST
43087: LIST
43088: LIST
43089: LIST
43090: PUSH
43091: LD_VAR 0 4
43095: PUSH
43096: LD_INT 1
43098: PLUS
43099: ARRAY
43100: ST_TO_ADDR
43101: GO 43104
43103: POP
43104: GO 43659
43106: LD_INT 2
43108: DOUBLE
43109: EQUAL
43110: IFTRUE 43120
43112: LD_INT 3
43114: DOUBLE
43115: EQUAL
43116: IFTRUE 43120
43118: GO 43176
43120: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43121: LD_ADDR_VAR 0 9
43125: PUSH
43126: LD_VAR 0 29
43130: PUSH
43131: LD_VAR 0 30
43135: PUSH
43136: LD_VAR 0 31
43140: PUSH
43141: LD_VAR 0 32
43145: PUSH
43146: LD_VAR 0 33
43150: PUSH
43151: LD_VAR 0 34
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: LIST
43160: LIST
43161: LIST
43162: LIST
43163: PUSH
43164: LD_VAR 0 4
43168: PUSH
43169: LD_INT 1
43171: PLUS
43172: ARRAY
43173: ST_TO_ADDR
43174: GO 43659
43176: LD_INT 16
43178: DOUBLE
43179: EQUAL
43180: IFTRUE 43238
43182: LD_INT 17
43184: DOUBLE
43185: EQUAL
43186: IFTRUE 43238
43188: LD_INT 18
43190: DOUBLE
43191: EQUAL
43192: IFTRUE 43238
43194: LD_INT 19
43196: DOUBLE
43197: EQUAL
43198: IFTRUE 43238
43200: LD_INT 22
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43238
43206: LD_INT 20
43208: DOUBLE
43209: EQUAL
43210: IFTRUE 43238
43212: LD_INT 21
43214: DOUBLE
43215: EQUAL
43216: IFTRUE 43238
43218: LD_INT 23
43220: DOUBLE
43221: EQUAL
43222: IFTRUE 43238
43224: LD_INT 24
43226: DOUBLE
43227: EQUAL
43228: IFTRUE 43238
43230: LD_INT 25
43232: DOUBLE
43233: EQUAL
43234: IFTRUE 43238
43236: GO 43294
43238: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43239: LD_ADDR_VAR 0 9
43243: PUSH
43244: LD_VAR 0 35
43248: PUSH
43249: LD_VAR 0 36
43253: PUSH
43254: LD_VAR 0 37
43258: PUSH
43259: LD_VAR 0 38
43263: PUSH
43264: LD_VAR 0 39
43268: PUSH
43269: LD_VAR 0 40
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: PUSH
43282: LD_VAR 0 4
43286: PUSH
43287: LD_INT 1
43289: PLUS
43290: ARRAY
43291: ST_TO_ADDR
43292: GO 43659
43294: LD_INT 6
43296: DOUBLE
43297: EQUAL
43298: IFTRUE 43350
43300: LD_INT 7
43302: DOUBLE
43303: EQUAL
43304: IFTRUE 43350
43306: LD_INT 8
43308: DOUBLE
43309: EQUAL
43310: IFTRUE 43350
43312: LD_INT 13
43314: DOUBLE
43315: EQUAL
43316: IFTRUE 43350
43318: LD_INT 12
43320: DOUBLE
43321: EQUAL
43322: IFTRUE 43350
43324: LD_INT 15
43326: DOUBLE
43327: EQUAL
43328: IFTRUE 43350
43330: LD_INT 11
43332: DOUBLE
43333: EQUAL
43334: IFTRUE 43350
43336: LD_INT 14
43338: DOUBLE
43339: EQUAL
43340: IFTRUE 43350
43342: LD_INT 10
43344: DOUBLE
43345: EQUAL
43346: IFTRUE 43350
43348: GO 43406
43350: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43351: LD_ADDR_VAR 0 9
43355: PUSH
43356: LD_VAR 0 41
43360: PUSH
43361: LD_VAR 0 42
43365: PUSH
43366: LD_VAR 0 43
43370: PUSH
43371: LD_VAR 0 44
43375: PUSH
43376: LD_VAR 0 45
43380: PUSH
43381: LD_VAR 0 46
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: PUSH
43394: LD_VAR 0 4
43398: PUSH
43399: LD_INT 1
43401: PLUS
43402: ARRAY
43403: ST_TO_ADDR
43404: GO 43659
43406: LD_INT 36
43408: DOUBLE
43409: EQUAL
43410: IFTRUE 43414
43412: GO 43470
43414: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43415: LD_ADDR_VAR 0 9
43419: PUSH
43420: LD_VAR 0 47
43424: PUSH
43425: LD_VAR 0 48
43429: PUSH
43430: LD_VAR 0 49
43434: PUSH
43435: LD_VAR 0 50
43439: PUSH
43440: LD_VAR 0 51
43444: PUSH
43445: LD_VAR 0 52
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: PUSH
43458: LD_VAR 0 4
43462: PUSH
43463: LD_INT 1
43465: PLUS
43466: ARRAY
43467: ST_TO_ADDR
43468: GO 43659
43470: LD_INT 4
43472: DOUBLE
43473: EQUAL
43474: IFTRUE 43496
43476: LD_INT 5
43478: DOUBLE
43479: EQUAL
43480: IFTRUE 43496
43482: LD_INT 34
43484: DOUBLE
43485: EQUAL
43486: IFTRUE 43496
43488: LD_INT 37
43490: DOUBLE
43491: EQUAL
43492: IFTRUE 43496
43494: GO 43552
43496: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43497: LD_ADDR_VAR 0 9
43501: PUSH
43502: LD_VAR 0 53
43506: PUSH
43507: LD_VAR 0 54
43511: PUSH
43512: LD_VAR 0 55
43516: PUSH
43517: LD_VAR 0 56
43521: PUSH
43522: LD_VAR 0 57
43526: PUSH
43527: LD_VAR 0 58
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: PUSH
43540: LD_VAR 0 4
43544: PUSH
43545: LD_INT 1
43547: PLUS
43548: ARRAY
43549: ST_TO_ADDR
43550: GO 43659
43552: LD_INT 31
43554: DOUBLE
43555: EQUAL
43556: IFTRUE 43602
43558: LD_INT 32
43560: DOUBLE
43561: EQUAL
43562: IFTRUE 43602
43564: LD_INT 33
43566: DOUBLE
43567: EQUAL
43568: IFTRUE 43602
43570: LD_INT 27
43572: DOUBLE
43573: EQUAL
43574: IFTRUE 43602
43576: LD_INT 26
43578: DOUBLE
43579: EQUAL
43580: IFTRUE 43602
43582: LD_INT 28
43584: DOUBLE
43585: EQUAL
43586: IFTRUE 43602
43588: LD_INT 29
43590: DOUBLE
43591: EQUAL
43592: IFTRUE 43602
43594: LD_INT 30
43596: DOUBLE
43597: EQUAL
43598: IFTRUE 43602
43600: GO 43658
43602: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43603: LD_ADDR_VAR 0 9
43607: PUSH
43608: LD_VAR 0 59
43612: PUSH
43613: LD_VAR 0 60
43617: PUSH
43618: LD_VAR 0 61
43622: PUSH
43623: LD_VAR 0 62
43627: PUSH
43628: LD_VAR 0 63
43632: PUSH
43633: LD_VAR 0 64
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: PUSH
43646: LD_VAR 0 4
43650: PUSH
43651: LD_INT 1
43653: PLUS
43654: ARRAY
43655: ST_TO_ADDR
43656: GO 43659
43658: POP
// temp_list2 = [ ] ;
43659: LD_ADDR_VAR 0 10
43663: PUSH
43664: EMPTY
43665: ST_TO_ADDR
// for i in temp_list do
43666: LD_ADDR_VAR 0 8
43670: PUSH
43671: LD_VAR 0 9
43675: PUSH
43676: FOR_IN
43677: IFFALSE 43729
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43679: LD_ADDR_VAR 0 10
43683: PUSH
43684: LD_VAR 0 10
43688: PUSH
43689: LD_VAR 0 8
43693: PUSH
43694: LD_INT 1
43696: ARRAY
43697: PUSH
43698: LD_VAR 0 2
43702: PLUS
43703: PUSH
43704: LD_VAR 0 8
43708: PUSH
43709: LD_INT 2
43711: ARRAY
43712: PUSH
43713: LD_VAR 0 3
43717: PLUS
43718: PUSH
43719: EMPTY
43720: LIST
43721: LIST
43722: PUSH
43723: EMPTY
43724: LIST
43725: ADD
43726: ST_TO_ADDR
43727: GO 43676
43729: POP
43730: POP
// result = temp_list2 ;
43731: LD_ADDR_VAR 0 7
43735: PUSH
43736: LD_VAR 0 10
43740: ST_TO_ADDR
// end ;
43741: LD_VAR 0 7
43745: RET
// export function EnemyInRange ( unit , dist ) ; begin
43746: LD_INT 0
43748: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43749: LD_ADDR_VAR 0 3
43753: PUSH
43754: LD_VAR 0 1
43758: PPUSH
43759: CALL_OW 255
43763: PPUSH
43764: LD_VAR 0 1
43768: PPUSH
43769: CALL_OW 250
43773: PPUSH
43774: LD_VAR 0 1
43778: PPUSH
43779: CALL_OW 251
43783: PPUSH
43784: LD_VAR 0 2
43788: PPUSH
43789: CALL 17148 0 4
43793: PUSH
43794: LD_INT 4
43796: ARRAY
43797: ST_TO_ADDR
// end ;
43798: LD_VAR 0 3
43802: RET
// export function PlayerSeeMe ( unit ) ; begin
43803: LD_INT 0
43805: PPUSH
// result := See ( your_side , unit ) ;
43806: LD_ADDR_VAR 0 2
43810: PUSH
43811: LD_OWVAR 2
43815: PPUSH
43816: LD_VAR 0 1
43820: PPUSH
43821: CALL_OW 292
43825: ST_TO_ADDR
// end ;
43826: LD_VAR 0 2
43830: RET
// export function ReverseDir ( unit ) ; begin
43831: LD_INT 0
43833: PPUSH
// if not unit then
43834: LD_VAR 0 1
43838: NOT
43839: IFFALSE 43843
// exit ;
43841: GO 43866
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43843: LD_ADDR_VAR 0 2
43847: PUSH
43848: LD_VAR 0 1
43852: PPUSH
43853: CALL_OW 254
43857: PUSH
43858: LD_INT 3
43860: PLUS
43861: PUSH
43862: LD_INT 6
43864: MOD
43865: ST_TO_ADDR
// end ;
43866: LD_VAR 0 2
43870: RET
// export function ReverseArray ( array ) ; var i ; begin
43871: LD_INT 0
43873: PPUSH
43874: PPUSH
// if not array then
43875: LD_VAR 0 1
43879: NOT
43880: IFFALSE 43884
// exit ;
43882: GO 43939
// result := [ ] ;
43884: LD_ADDR_VAR 0 2
43888: PUSH
43889: EMPTY
43890: ST_TO_ADDR
// for i := array downto 1 do
43891: LD_ADDR_VAR 0 3
43895: PUSH
43896: DOUBLE
43897: LD_VAR 0 1
43901: INC
43902: ST_TO_ADDR
43903: LD_INT 1
43905: PUSH
43906: FOR_DOWNTO
43907: IFFALSE 43937
// result := Join ( result , array [ i ] ) ;
43909: LD_ADDR_VAR 0 2
43913: PUSH
43914: LD_VAR 0 2
43918: PPUSH
43919: LD_VAR 0 1
43923: PUSH
43924: LD_VAR 0 3
43928: ARRAY
43929: PPUSH
43930: CALL 48583 0 2
43934: ST_TO_ADDR
43935: GO 43906
43937: POP
43938: POP
// end ;
43939: LD_VAR 0 2
43943: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43944: LD_INT 0
43946: PPUSH
43947: PPUSH
43948: PPUSH
43949: PPUSH
43950: PPUSH
43951: PPUSH
// if not unit or not hexes then
43952: LD_VAR 0 1
43956: NOT
43957: PUSH
43958: LD_VAR 0 2
43962: NOT
43963: OR
43964: IFFALSE 43968
// exit ;
43966: GO 44091
// dist := 9999 ;
43968: LD_ADDR_VAR 0 5
43972: PUSH
43973: LD_INT 9999
43975: ST_TO_ADDR
// for i = 1 to hexes do
43976: LD_ADDR_VAR 0 4
43980: PUSH
43981: DOUBLE
43982: LD_INT 1
43984: DEC
43985: ST_TO_ADDR
43986: LD_VAR 0 2
43990: PUSH
43991: FOR_TO
43992: IFFALSE 44079
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43994: LD_ADDR_VAR 0 6
43998: PUSH
43999: LD_VAR 0 1
44003: PPUSH
44004: LD_VAR 0 2
44008: PUSH
44009: LD_VAR 0 4
44013: ARRAY
44014: PUSH
44015: LD_INT 1
44017: ARRAY
44018: PPUSH
44019: LD_VAR 0 2
44023: PUSH
44024: LD_VAR 0 4
44028: ARRAY
44029: PUSH
44030: LD_INT 2
44032: ARRAY
44033: PPUSH
44034: CALL_OW 297
44038: ST_TO_ADDR
// if tdist < dist then
44039: LD_VAR 0 6
44043: PUSH
44044: LD_VAR 0 5
44048: LESS
44049: IFFALSE 44077
// begin hex := hexes [ i ] ;
44051: LD_ADDR_VAR 0 8
44055: PUSH
44056: LD_VAR 0 2
44060: PUSH
44061: LD_VAR 0 4
44065: ARRAY
44066: ST_TO_ADDR
// dist := tdist ;
44067: LD_ADDR_VAR 0 5
44071: PUSH
44072: LD_VAR 0 6
44076: ST_TO_ADDR
// end ; end ;
44077: GO 43991
44079: POP
44080: POP
// result := hex ;
44081: LD_ADDR_VAR 0 3
44085: PUSH
44086: LD_VAR 0 8
44090: ST_TO_ADDR
// end ;
44091: LD_VAR 0 3
44095: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44096: LD_INT 0
44098: PPUSH
44099: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44100: LD_VAR 0 1
44104: NOT
44105: PUSH
44106: LD_VAR 0 1
44110: PUSH
44111: LD_INT 21
44113: PUSH
44114: LD_INT 2
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 23
44123: PUSH
44124: LD_INT 2
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PPUSH
44135: CALL_OW 69
44139: IN
44140: NOT
44141: OR
44142: IFFALSE 44146
// exit ;
44144: GO 44193
// for i = 1 to 3 do
44146: LD_ADDR_VAR 0 3
44150: PUSH
44151: DOUBLE
44152: LD_INT 1
44154: DEC
44155: ST_TO_ADDR
44156: LD_INT 3
44158: PUSH
44159: FOR_TO
44160: IFFALSE 44191
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44162: LD_VAR 0 1
44166: PPUSH
44167: CALL_OW 250
44171: PPUSH
44172: LD_VAR 0 1
44176: PPUSH
44177: CALL_OW 251
44181: PPUSH
44182: LD_INT 1
44184: PPUSH
44185: CALL_OW 453
44189: GO 44159
44191: POP
44192: POP
// end ;
44193: LD_VAR 0 2
44197: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44198: LD_INT 0
44200: PPUSH
44201: PPUSH
44202: PPUSH
44203: PPUSH
44204: PPUSH
44205: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44206: LD_VAR 0 1
44210: NOT
44211: PUSH
44212: LD_VAR 0 2
44216: NOT
44217: OR
44218: PUSH
44219: LD_VAR 0 1
44223: PPUSH
44224: CALL_OW 314
44228: OR
44229: IFFALSE 44233
// exit ;
44231: GO 44700
// if GetLives ( i ) < 250 then
44233: LD_VAR 0 4
44237: PPUSH
44238: CALL_OW 256
44242: PUSH
44243: LD_INT 250
44245: LESS
44246: IFFALSE 44259
// begin ComAutodestruct ( i ) ;
44248: LD_VAR 0 4
44252: PPUSH
44253: CALL 44096 0 1
// exit ;
44257: GO 44700
// end ; x := GetX ( enemy_unit ) ;
44259: LD_ADDR_VAR 0 7
44263: PUSH
44264: LD_VAR 0 2
44268: PPUSH
44269: CALL_OW 250
44273: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44274: LD_ADDR_VAR 0 8
44278: PUSH
44279: LD_VAR 0 2
44283: PPUSH
44284: CALL_OW 251
44288: ST_TO_ADDR
// if not x or not y then
44289: LD_VAR 0 7
44293: NOT
44294: PUSH
44295: LD_VAR 0 8
44299: NOT
44300: OR
44301: IFFALSE 44305
// exit ;
44303: GO 44700
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44305: LD_ADDR_VAR 0 6
44309: PUSH
44310: LD_VAR 0 7
44314: PPUSH
44315: LD_INT 0
44317: PPUSH
44318: LD_INT 4
44320: PPUSH
44321: CALL_OW 272
44325: PUSH
44326: LD_VAR 0 8
44330: PPUSH
44331: LD_INT 0
44333: PPUSH
44334: LD_INT 4
44336: PPUSH
44337: CALL_OW 273
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_VAR 0 7
44350: PPUSH
44351: LD_INT 1
44353: PPUSH
44354: LD_INT 4
44356: PPUSH
44357: CALL_OW 272
44361: PUSH
44362: LD_VAR 0 8
44366: PPUSH
44367: LD_INT 1
44369: PPUSH
44370: LD_INT 4
44372: PPUSH
44373: CALL_OW 273
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_VAR 0 7
44386: PPUSH
44387: LD_INT 2
44389: PPUSH
44390: LD_INT 4
44392: PPUSH
44393: CALL_OW 272
44397: PUSH
44398: LD_VAR 0 8
44402: PPUSH
44403: LD_INT 2
44405: PPUSH
44406: LD_INT 4
44408: PPUSH
44409: CALL_OW 273
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_VAR 0 7
44422: PPUSH
44423: LD_INT 3
44425: PPUSH
44426: LD_INT 4
44428: PPUSH
44429: CALL_OW 272
44433: PUSH
44434: LD_VAR 0 8
44438: PPUSH
44439: LD_INT 3
44441: PPUSH
44442: LD_INT 4
44444: PPUSH
44445: CALL_OW 273
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_VAR 0 7
44458: PPUSH
44459: LD_INT 4
44461: PPUSH
44462: LD_INT 4
44464: PPUSH
44465: CALL_OW 272
44469: PUSH
44470: LD_VAR 0 8
44474: PPUSH
44475: LD_INT 4
44477: PPUSH
44478: LD_INT 4
44480: PPUSH
44481: CALL_OW 273
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_VAR 0 7
44494: PPUSH
44495: LD_INT 5
44497: PPUSH
44498: LD_INT 4
44500: PPUSH
44501: CALL_OW 272
44505: PUSH
44506: LD_VAR 0 8
44510: PPUSH
44511: LD_INT 5
44513: PPUSH
44514: LD_INT 4
44516: PPUSH
44517: CALL_OW 273
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: ST_TO_ADDR
// for i = tmp downto 1 do
44534: LD_ADDR_VAR 0 4
44538: PUSH
44539: DOUBLE
44540: LD_VAR 0 6
44544: INC
44545: ST_TO_ADDR
44546: LD_INT 1
44548: PUSH
44549: FOR_DOWNTO
44550: IFFALSE 44651
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44552: LD_VAR 0 6
44556: PUSH
44557: LD_VAR 0 4
44561: ARRAY
44562: PUSH
44563: LD_INT 1
44565: ARRAY
44566: PPUSH
44567: LD_VAR 0 6
44571: PUSH
44572: LD_VAR 0 4
44576: ARRAY
44577: PUSH
44578: LD_INT 2
44580: ARRAY
44581: PPUSH
44582: CALL_OW 488
44586: NOT
44587: PUSH
44588: LD_VAR 0 6
44592: PUSH
44593: LD_VAR 0 4
44597: ARRAY
44598: PUSH
44599: LD_INT 1
44601: ARRAY
44602: PPUSH
44603: LD_VAR 0 6
44607: PUSH
44608: LD_VAR 0 4
44612: ARRAY
44613: PUSH
44614: LD_INT 2
44616: ARRAY
44617: PPUSH
44618: CALL_OW 428
44622: PUSH
44623: LD_INT 0
44625: NONEQUAL
44626: OR
44627: IFFALSE 44649
// tmp := Delete ( tmp , i ) ;
44629: LD_ADDR_VAR 0 6
44633: PUSH
44634: LD_VAR 0 6
44638: PPUSH
44639: LD_VAR 0 4
44643: PPUSH
44644: CALL_OW 3
44648: ST_TO_ADDR
44649: GO 44549
44651: POP
44652: POP
// j := GetClosestHex ( unit , tmp ) ;
44653: LD_ADDR_VAR 0 5
44657: PUSH
44658: LD_VAR 0 1
44662: PPUSH
44663: LD_VAR 0 6
44667: PPUSH
44668: CALL 43944 0 2
44672: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44673: LD_VAR 0 1
44677: PPUSH
44678: LD_VAR 0 5
44682: PUSH
44683: LD_INT 1
44685: ARRAY
44686: PPUSH
44687: LD_VAR 0 5
44691: PUSH
44692: LD_INT 2
44694: ARRAY
44695: PPUSH
44696: CALL_OW 111
// end ;
44700: LD_VAR 0 3
44704: RET
// export function PrepareApemanSoldier ( ) ; begin
44705: LD_INT 0
44707: PPUSH
// uc_nation := 0 ;
44708: LD_ADDR_OWVAR 21
44712: PUSH
44713: LD_INT 0
44715: ST_TO_ADDR
// hc_sex := sex_male ;
44716: LD_ADDR_OWVAR 27
44720: PUSH
44721: LD_INT 1
44723: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44724: LD_ADDR_OWVAR 28
44728: PUSH
44729: LD_INT 15
44731: ST_TO_ADDR
// hc_gallery :=  ;
44732: LD_ADDR_OWVAR 33
44736: PUSH
44737: LD_STRING 
44739: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44740: LD_ADDR_OWVAR 31
44744: PUSH
44745: LD_INT 0
44747: PPUSH
44748: LD_INT 3
44750: PPUSH
44751: CALL_OW 12
44755: PUSH
44756: LD_INT 0
44758: PPUSH
44759: LD_INT 3
44761: PPUSH
44762: CALL_OW 12
44766: PUSH
44767: LD_INT 0
44769: PUSH
44770: LD_INT 0
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: ST_TO_ADDR
// end ;
44779: LD_VAR 0 1
44783: RET
// export function PrepareApemanEngineer ( ) ; begin
44784: LD_INT 0
44786: PPUSH
// uc_nation := 0 ;
44787: LD_ADDR_OWVAR 21
44791: PUSH
44792: LD_INT 0
44794: ST_TO_ADDR
// hc_sex := sex_male ;
44795: LD_ADDR_OWVAR 27
44799: PUSH
44800: LD_INT 1
44802: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44803: LD_ADDR_OWVAR 28
44807: PUSH
44808: LD_INT 16
44810: ST_TO_ADDR
// hc_gallery :=  ;
44811: LD_ADDR_OWVAR 33
44815: PUSH
44816: LD_STRING 
44818: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44819: LD_ADDR_OWVAR 31
44823: PUSH
44824: LD_INT 0
44826: PPUSH
44827: LD_INT 3
44829: PPUSH
44830: CALL_OW 12
44834: PUSH
44835: LD_INT 0
44837: PPUSH
44838: LD_INT 3
44840: PPUSH
44841: CALL_OW 12
44845: PUSH
44846: LD_INT 0
44848: PUSH
44849: LD_INT 0
44851: PUSH
44852: EMPTY
44853: LIST
44854: LIST
44855: LIST
44856: LIST
44857: ST_TO_ADDR
// end ;
44858: LD_VAR 0 1
44862: RET
// export function PrepareApeman ( agressivity ) ; begin
44863: LD_INT 0
44865: PPUSH
// uc_side := 0 ;
44866: LD_ADDR_OWVAR 20
44870: PUSH
44871: LD_INT 0
44873: ST_TO_ADDR
// uc_nation := 0 ;
44874: LD_ADDR_OWVAR 21
44878: PUSH
44879: LD_INT 0
44881: ST_TO_ADDR
// hc_sex := sex_male ;
44882: LD_ADDR_OWVAR 27
44886: PUSH
44887: LD_INT 1
44889: ST_TO_ADDR
// hc_class := class_apeman ;
44890: LD_ADDR_OWVAR 28
44894: PUSH
44895: LD_INT 12
44897: ST_TO_ADDR
// hc_gallery :=  ;
44898: LD_ADDR_OWVAR 33
44902: PUSH
44903: LD_STRING 
44905: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44906: LD_ADDR_OWVAR 35
44910: PUSH
44911: LD_VAR 0 1
44915: NEG
44916: PPUSH
44917: LD_VAR 0 1
44921: PPUSH
44922: CALL_OW 12
44926: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44927: LD_ADDR_OWVAR 31
44931: PUSH
44932: LD_INT 0
44934: PPUSH
44935: LD_INT 3
44937: PPUSH
44938: CALL_OW 12
44942: PUSH
44943: LD_INT 0
44945: PPUSH
44946: LD_INT 3
44948: PPUSH
44949: CALL_OW 12
44953: PUSH
44954: LD_INT 0
44956: PUSH
44957: LD_INT 0
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: ST_TO_ADDR
// end ;
44966: LD_VAR 0 2
44970: RET
// export function PrepareTiger ( agressivity ) ; begin
44971: LD_INT 0
44973: PPUSH
// uc_side := 0 ;
44974: LD_ADDR_OWVAR 20
44978: PUSH
44979: LD_INT 0
44981: ST_TO_ADDR
// uc_nation := 0 ;
44982: LD_ADDR_OWVAR 21
44986: PUSH
44987: LD_INT 0
44989: ST_TO_ADDR
// hc_class := class_tiger ;
44990: LD_ADDR_OWVAR 28
44994: PUSH
44995: LD_INT 14
44997: ST_TO_ADDR
// hc_gallery :=  ;
44998: LD_ADDR_OWVAR 33
45002: PUSH
45003: LD_STRING 
45005: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45006: LD_ADDR_OWVAR 35
45010: PUSH
45011: LD_VAR 0 1
45015: NEG
45016: PPUSH
45017: LD_VAR 0 1
45021: PPUSH
45022: CALL_OW 12
45026: ST_TO_ADDR
// end ;
45027: LD_VAR 0 2
45031: RET
// export function PrepareEnchidna ( ) ; begin
45032: LD_INT 0
45034: PPUSH
// uc_side := 0 ;
45035: LD_ADDR_OWVAR 20
45039: PUSH
45040: LD_INT 0
45042: ST_TO_ADDR
// uc_nation := 0 ;
45043: LD_ADDR_OWVAR 21
45047: PUSH
45048: LD_INT 0
45050: ST_TO_ADDR
// hc_class := class_baggie ;
45051: LD_ADDR_OWVAR 28
45055: PUSH
45056: LD_INT 13
45058: ST_TO_ADDR
// hc_gallery :=  ;
45059: LD_ADDR_OWVAR 33
45063: PUSH
45064: LD_STRING 
45066: ST_TO_ADDR
// end ;
45067: LD_VAR 0 1
45071: RET
// export function PrepareFrog ( ) ; begin
45072: LD_INT 0
45074: PPUSH
// uc_side := 0 ;
45075: LD_ADDR_OWVAR 20
45079: PUSH
45080: LD_INT 0
45082: ST_TO_ADDR
// uc_nation := 0 ;
45083: LD_ADDR_OWVAR 21
45087: PUSH
45088: LD_INT 0
45090: ST_TO_ADDR
// hc_class := class_frog ;
45091: LD_ADDR_OWVAR 28
45095: PUSH
45096: LD_INT 19
45098: ST_TO_ADDR
// hc_gallery :=  ;
45099: LD_ADDR_OWVAR 33
45103: PUSH
45104: LD_STRING 
45106: ST_TO_ADDR
// end ;
45107: LD_VAR 0 1
45111: RET
// export function PrepareFish ( ) ; begin
45112: LD_INT 0
45114: PPUSH
// uc_side := 0 ;
45115: LD_ADDR_OWVAR 20
45119: PUSH
45120: LD_INT 0
45122: ST_TO_ADDR
// uc_nation := 0 ;
45123: LD_ADDR_OWVAR 21
45127: PUSH
45128: LD_INT 0
45130: ST_TO_ADDR
// hc_class := class_fish ;
45131: LD_ADDR_OWVAR 28
45135: PUSH
45136: LD_INT 20
45138: ST_TO_ADDR
// hc_gallery :=  ;
45139: LD_ADDR_OWVAR 33
45143: PUSH
45144: LD_STRING 
45146: ST_TO_ADDR
// end ;
45147: LD_VAR 0 1
45151: RET
// export function PrepareBird ( ) ; begin
45152: LD_INT 0
45154: PPUSH
// uc_side := 0 ;
45155: LD_ADDR_OWVAR 20
45159: PUSH
45160: LD_INT 0
45162: ST_TO_ADDR
// uc_nation := 0 ;
45163: LD_ADDR_OWVAR 21
45167: PUSH
45168: LD_INT 0
45170: ST_TO_ADDR
// hc_class := class_phororhacos ;
45171: LD_ADDR_OWVAR 28
45175: PUSH
45176: LD_INT 18
45178: ST_TO_ADDR
// hc_gallery :=  ;
45179: LD_ADDR_OWVAR 33
45183: PUSH
45184: LD_STRING 
45186: ST_TO_ADDR
// end ;
45187: LD_VAR 0 1
45191: RET
// export function PrepareHorse ( ) ; begin
45192: LD_INT 0
45194: PPUSH
// uc_side := 0 ;
45195: LD_ADDR_OWVAR 20
45199: PUSH
45200: LD_INT 0
45202: ST_TO_ADDR
// uc_nation := 0 ;
45203: LD_ADDR_OWVAR 21
45207: PUSH
45208: LD_INT 0
45210: ST_TO_ADDR
// hc_class := class_horse ;
45211: LD_ADDR_OWVAR 28
45215: PUSH
45216: LD_INT 21
45218: ST_TO_ADDR
// hc_gallery :=  ;
45219: LD_ADDR_OWVAR 33
45223: PUSH
45224: LD_STRING 
45226: ST_TO_ADDR
// end ;
45227: LD_VAR 0 1
45231: RET
// export function PrepareMastodont ( ) ; begin
45232: LD_INT 0
45234: PPUSH
// uc_side := 0 ;
45235: LD_ADDR_OWVAR 20
45239: PUSH
45240: LD_INT 0
45242: ST_TO_ADDR
// uc_nation := 0 ;
45243: LD_ADDR_OWVAR 21
45247: PUSH
45248: LD_INT 0
45250: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45251: LD_ADDR_OWVAR 37
45255: PUSH
45256: LD_INT 31
45258: ST_TO_ADDR
// vc_control := control_rider ;
45259: LD_ADDR_OWVAR 38
45263: PUSH
45264: LD_INT 4
45266: ST_TO_ADDR
// end ;
45267: LD_VAR 0 1
45271: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45272: LD_INT 0
45274: PPUSH
45275: PPUSH
45276: PPUSH
// uc_side = 0 ;
45277: LD_ADDR_OWVAR 20
45281: PUSH
45282: LD_INT 0
45284: ST_TO_ADDR
// uc_nation = 0 ;
45285: LD_ADDR_OWVAR 21
45289: PUSH
45290: LD_INT 0
45292: ST_TO_ADDR
// InitHc_All ( ) ;
45293: CALL_OW 584
// InitVc ;
45297: CALL_OW 20
// if mastodonts then
45301: LD_VAR 0 6
45305: IFFALSE 45372
// for i = 1 to mastodonts do
45307: LD_ADDR_VAR 0 11
45311: PUSH
45312: DOUBLE
45313: LD_INT 1
45315: DEC
45316: ST_TO_ADDR
45317: LD_VAR 0 6
45321: PUSH
45322: FOR_TO
45323: IFFALSE 45370
// begin vc_chassis := 31 ;
45325: LD_ADDR_OWVAR 37
45329: PUSH
45330: LD_INT 31
45332: ST_TO_ADDR
// vc_control := control_rider ;
45333: LD_ADDR_OWVAR 38
45337: PUSH
45338: LD_INT 4
45340: ST_TO_ADDR
// animal := CreateVehicle ;
45341: LD_ADDR_VAR 0 12
45345: PUSH
45346: CALL_OW 45
45350: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45351: LD_VAR 0 12
45355: PPUSH
45356: LD_VAR 0 8
45360: PPUSH
45361: LD_INT 0
45363: PPUSH
45364: CALL 47500 0 3
// end ;
45368: GO 45322
45370: POP
45371: POP
// if horses then
45372: LD_VAR 0 5
45376: IFFALSE 45443
// for i = 1 to horses do
45378: LD_ADDR_VAR 0 11
45382: PUSH
45383: DOUBLE
45384: LD_INT 1
45386: DEC
45387: ST_TO_ADDR
45388: LD_VAR 0 5
45392: PUSH
45393: FOR_TO
45394: IFFALSE 45441
// begin hc_class := 21 ;
45396: LD_ADDR_OWVAR 28
45400: PUSH
45401: LD_INT 21
45403: ST_TO_ADDR
// hc_gallery :=  ;
45404: LD_ADDR_OWVAR 33
45408: PUSH
45409: LD_STRING 
45411: ST_TO_ADDR
// animal := CreateHuman ;
45412: LD_ADDR_VAR 0 12
45416: PUSH
45417: CALL_OW 44
45421: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45422: LD_VAR 0 12
45426: PPUSH
45427: LD_VAR 0 8
45431: PPUSH
45432: LD_INT 0
45434: PPUSH
45435: CALL 47500 0 3
// end ;
45439: GO 45393
45441: POP
45442: POP
// if birds then
45443: LD_VAR 0 1
45447: IFFALSE 45514
// for i = 1 to birds do
45449: LD_ADDR_VAR 0 11
45453: PUSH
45454: DOUBLE
45455: LD_INT 1
45457: DEC
45458: ST_TO_ADDR
45459: LD_VAR 0 1
45463: PUSH
45464: FOR_TO
45465: IFFALSE 45512
// begin hc_class = 18 ;
45467: LD_ADDR_OWVAR 28
45471: PUSH
45472: LD_INT 18
45474: ST_TO_ADDR
// hc_gallery =  ;
45475: LD_ADDR_OWVAR 33
45479: PUSH
45480: LD_STRING 
45482: ST_TO_ADDR
// animal := CreateHuman ;
45483: LD_ADDR_VAR 0 12
45487: PUSH
45488: CALL_OW 44
45492: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45493: LD_VAR 0 12
45497: PPUSH
45498: LD_VAR 0 8
45502: PPUSH
45503: LD_INT 0
45505: PPUSH
45506: CALL 47500 0 3
// end ;
45510: GO 45464
45512: POP
45513: POP
// if tigers then
45514: LD_VAR 0 2
45518: IFFALSE 45602
// for i = 1 to tigers do
45520: LD_ADDR_VAR 0 11
45524: PUSH
45525: DOUBLE
45526: LD_INT 1
45528: DEC
45529: ST_TO_ADDR
45530: LD_VAR 0 2
45534: PUSH
45535: FOR_TO
45536: IFFALSE 45600
// begin hc_class = class_tiger ;
45538: LD_ADDR_OWVAR 28
45542: PUSH
45543: LD_INT 14
45545: ST_TO_ADDR
// hc_gallery =  ;
45546: LD_ADDR_OWVAR 33
45550: PUSH
45551: LD_STRING 
45553: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45554: LD_ADDR_OWVAR 35
45558: PUSH
45559: LD_INT 7
45561: NEG
45562: PPUSH
45563: LD_INT 7
45565: PPUSH
45566: CALL_OW 12
45570: ST_TO_ADDR
// animal := CreateHuman ;
45571: LD_ADDR_VAR 0 12
45575: PUSH
45576: CALL_OW 44
45580: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45581: LD_VAR 0 12
45585: PPUSH
45586: LD_VAR 0 8
45590: PPUSH
45591: LD_INT 0
45593: PPUSH
45594: CALL 47500 0 3
// end ;
45598: GO 45535
45600: POP
45601: POP
// if apemans then
45602: LD_VAR 0 3
45606: IFFALSE 45729
// for i = 1 to apemans do
45608: LD_ADDR_VAR 0 11
45612: PUSH
45613: DOUBLE
45614: LD_INT 1
45616: DEC
45617: ST_TO_ADDR
45618: LD_VAR 0 3
45622: PUSH
45623: FOR_TO
45624: IFFALSE 45727
// begin hc_class = class_apeman ;
45626: LD_ADDR_OWVAR 28
45630: PUSH
45631: LD_INT 12
45633: ST_TO_ADDR
// hc_gallery =  ;
45634: LD_ADDR_OWVAR 33
45638: PUSH
45639: LD_STRING 
45641: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45642: LD_ADDR_OWVAR 35
45646: PUSH
45647: LD_INT 2
45649: NEG
45650: PPUSH
45651: LD_INT 2
45653: PPUSH
45654: CALL_OW 12
45658: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45659: LD_ADDR_OWVAR 31
45663: PUSH
45664: LD_INT 1
45666: PPUSH
45667: LD_INT 3
45669: PPUSH
45670: CALL_OW 12
45674: PUSH
45675: LD_INT 1
45677: PPUSH
45678: LD_INT 3
45680: PPUSH
45681: CALL_OW 12
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: LD_INT 0
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: ST_TO_ADDR
// animal := CreateHuman ;
45698: LD_ADDR_VAR 0 12
45702: PUSH
45703: CALL_OW 44
45707: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45708: LD_VAR 0 12
45712: PPUSH
45713: LD_VAR 0 8
45717: PPUSH
45718: LD_INT 0
45720: PPUSH
45721: CALL 47500 0 3
// end ;
45725: GO 45623
45727: POP
45728: POP
// if enchidnas then
45729: LD_VAR 0 4
45733: IFFALSE 45800
// for i = 1 to enchidnas do
45735: LD_ADDR_VAR 0 11
45739: PUSH
45740: DOUBLE
45741: LD_INT 1
45743: DEC
45744: ST_TO_ADDR
45745: LD_VAR 0 4
45749: PUSH
45750: FOR_TO
45751: IFFALSE 45798
// begin hc_class = 13 ;
45753: LD_ADDR_OWVAR 28
45757: PUSH
45758: LD_INT 13
45760: ST_TO_ADDR
// hc_gallery =  ;
45761: LD_ADDR_OWVAR 33
45765: PUSH
45766: LD_STRING 
45768: ST_TO_ADDR
// animal := CreateHuman ;
45769: LD_ADDR_VAR 0 12
45773: PUSH
45774: CALL_OW 44
45778: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45779: LD_VAR 0 12
45783: PPUSH
45784: LD_VAR 0 8
45788: PPUSH
45789: LD_INT 0
45791: PPUSH
45792: CALL 47500 0 3
// end ;
45796: GO 45750
45798: POP
45799: POP
// if fishes then
45800: LD_VAR 0 7
45804: IFFALSE 45871
// for i = 1 to fishes do
45806: LD_ADDR_VAR 0 11
45810: PUSH
45811: DOUBLE
45812: LD_INT 1
45814: DEC
45815: ST_TO_ADDR
45816: LD_VAR 0 7
45820: PUSH
45821: FOR_TO
45822: IFFALSE 45869
// begin hc_class = 20 ;
45824: LD_ADDR_OWVAR 28
45828: PUSH
45829: LD_INT 20
45831: ST_TO_ADDR
// hc_gallery =  ;
45832: LD_ADDR_OWVAR 33
45836: PUSH
45837: LD_STRING 
45839: ST_TO_ADDR
// animal := CreateHuman ;
45840: LD_ADDR_VAR 0 12
45844: PUSH
45845: CALL_OW 44
45849: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45850: LD_VAR 0 12
45854: PPUSH
45855: LD_VAR 0 9
45859: PPUSH
45860: LD_INT 0
45862: PPUSH
45863: CALL 47500 0 3
// end ;
45867: GO 45821
45869: POP
45870: POP
// end ;
45871: LD_VAR 0 10
45875: RET
// export function WantHeal ( sci , unit ) ; begin
45876: LD_INT 0
45878: PPUSH
// if GetTaskList ( sci ) > 0 then
45879: LD_VAR 0 1
45883: PPUSH
45884: CALL_OW 437
45888: PUSH
45889: LD_INT 0
45891: GREATER
45892: IFFALSE 45962
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45894: LD_VAR 0 1
45898: PPUSH
45899: CALL_OW 437
45903: PUSH
45904: LD_INT 1
45906: ARRAY
45907: PUSH
45908: LD_INT 1
45910: ARRAY
45911: PUSH
45912: LD_STRING l
45914: EQUAL
45915: PUSH
45916: LD_VAR 0 1
45920: PPUSH
45921: CALL_OW 437
45925: PUSH
45926: LD_INT 1
45928: ARRAY
45929: PUSH
45930: LD_INT 4
45932: ARRAY
45933: PUSH
45934: LD_VAR 0 2
45938: EQUAL
45939: AND
45940: IFFALSE 45952
// result := true else
45942: LD_ADDR_VAR 0 3
45946: PUSH
45947: LD_INT 1
45949: ST_TO_ADDR
45950: GO 45960
// result := false ;
45952: LD_ADDR_VAR 0 3
45956: PUSH
45957: LD_INT 0
45959: ST_TO_ADDR
// end else
45960: GO 45970
// result := false ;
45962: LD_ADDR_VAR 0 3
45966: PUSH
45967: LD_INT 0
45969: ST_TO_ADDR
// end ;
45970: LD_VAR 0 3
45974: RET
// export function HealTarget ( sci ) ; begin
45975: LD_INT 0
45977: PPUSH
// if not sci then
45978: LD_VAR 0 1
45982: NOT
45983: IFFALSE 45987
// exit ;
45985: GO 46052
// result := 0 ;
45987: LD_ADDR_VAR 0 2
45991: PUSH
45992: LD_INT 0
45994: ST_TO_ADDR
// if GetTaskList ( sci ) then
45995: LD_VAR 0 1
45999: PPUSH
46000: CALL_OW 437
46004: IFFALSE 46052
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46006: LD_VAR 0 1
46010: PPUSH
46011: CALL_OW 437
46015: PUSH
46016: LD_INT 1
46018: ARRAY
46019: PUSH
46020: LD_INT 1
46022: ARRAY
46023: PUSH
46024: LD_STRING l
46026: EQUAL
46027: IFFALSE 46052
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46029: LD_ADDR_VAR 0 2
46033: PUSH
46034: LD_VAR 0 1
46038: PPUSH
46039: CALL_OW 437
46043: PUSH
46044: LD_INT 1
46046: ARRAY
46047: PUSH
46048: LD_INT 4
46050: ARRAY
46051: ST_TO_ADDR
// end ;
46052: LD_VAR 0 2
46056: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46057: LD_INT 0
46059: PPUSH
46060: PPUSH
46061: PPUSH
46062: PPUSH
// if not base_units then
46063: LD_VAR 0 1
46067: NOT
46068: IFFALSE 46072
// exit ;
46070: GO 46159
// result := false ;
46072: LD_ADDR_VAR 0 2
46076: PUSH
46077: LD_INT 0
46079: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46080: LD_ADDR_VAR 0 5
46084: PUSH
46085: LD_VAR 0 1
46089: PPUSH
46090: LD_INT 21
46092: PUSH
46093: LD_INT 3
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PPUSH
46100: CALL_OW 72
46104: ST_TO_ADDR
// if not tmp then
46105: LD_VAR 0 5
46109: NOT
46110: IFFALSE 46114
// exit ;
46112: GO 46159
// for i in tmp do
46114: LD_ADDR_VAR 0 3
46118: PUSH
46119: LD_VAR 0 5
46123: PUSH
46124: FOR_IN
46125: IFFALSE 46157
// begin result := EnemyInRange ( i , 22 ) ;
46127: LD_ADDR_VAR 0 2
46131: PUSH
46132: LD_VAR 0 3
46136: PPUSH
46137: LD_INT 22
46139: PPUSH
46140: CALL 43746 0 2
46144: ST_TO_ADDR
// if result then
46145: LD_VAR 0 2
46149: IFFALSE 46155
// exit ;
46151: POP
46152: POP
46153: GO 46159
// end ;
46155: GO 46124
46157: POP
46158: POP
// end ;
46159: LD_VAR 0 2
46163: RET
// export function FilterByTag ( units , tag ) ; begin
46164: LD_INT 0
46166: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46167: LD_ADDR_VAR 0 3
46171: PUSH
46172: LD_VAR 0 1
46176: PPUSH
46177: LD_INT 120
46179: PUSH
46180: LD_VAR 0 2
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PPUSH
46189: CALL_OW 72
46193: ST_TO_ADDR
// end ;
46194: LD_VAR 0 3
46198: RET
// export function IsDriver ( un ) ; begin
46199: LD_INT 0
46201: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46202: LD_ADDR_VAR 0 2
46206: PUSH
46207: LD_VAR 0 1
46211: PUSH
46212: LD_INT 55
46214: PUSH
46215: EMPTY
46216: LIST
46217: PPUSH
46218: CALL_OW 69
46222: IN
46223: ST_TO_ADDR
// end ;
46224: LD_VAR 0 2
46228: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46229: LD_INT 0
46231: PPUSH
46232: PPUSH
// list := [ ] ;
46233: LD_ADDR_VAR 0 5
46237: PUSH
46238: EMPTY
46239: ST_TO_ADDR
// case d of 0 :
46240: LD_VAR 0 3
46244: PUSH
46245: LD_INT 0
46247: DOUBLE
46248: EQUAL
46249: IFTRUE 46253
46251: GO 46386
46253: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46254: LD_ADDR_VAR 0 5
46258: PUSH
46259: LD_VAR 0 1
46263: PUSH
46264: LD_INT 4
46266: MINUS
46267: PUSH
46268: LD_VAR 0 2
46272: PUSH
46273: LD_INT 4
46275: MINUS
46276: PUSH
46277: LD_INT 2
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: LIST
46284: PUSH
46285: LD_VAR 0 1
46289: PUSH
46290: LD_INT 3
46292: MINUS
46293: PUSH
46294: LD_VAR 0 2
46298: PUSH
46299: LD_INT 1
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: LIST
46306: PUSH
46307: LD_VAR 0 1
46311: PUSH
46312: LD_INT 4
46314: PLUS
46315: PUSH
46316: LD_VAR 0 2
46320: PUSH
46321: LD_INT 4
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: LIST
46328: PUSH
46329: LD_VAR 0 1
46333: PUSH
46334: LD_INT 3
46336: PLUS
46337: PUSH
46338: LD_VAR 0 2
46342: PUSH
46343: LD_INT 3
46345: PLUS
46346: PUSH
46347: LD_INT 5
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: LIST
46354: PUSH
46355: LD_VAR 0 1
46359: PUSH
46360: LD_VAR 0 2
46364: PUSH
46365: LD_INT 4
46367: PLUS
46368: PUSH
46369: LD_INT 0
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: LIST
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: ST_TO_ADDR
// end ; 1 :
46384: GO 47084
46386: LD_INT 1
46388: DOUBLE
46389: EQUAL
46390: IFTRUE 46394
46392: GO 46527
46394: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46395: LD_ADDR_VAR 0 5
46399: PUSH
46400: LD_VAR 0 1
46404: PUSH
46405: LD_VAR 0 2
46409: PUSH
46410: LD_INT 4
46412: MINUS
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: LIST
46421: PUSH
46422: LD_VAR 0 1
46426: PUSH
46427: LD_INT 3
46429: MINUS
46430: PUSH
46431: LD_VAR 0 2
46435: PUSH
46436: LD_INT 3
46438: MINUS
46439: PUSH
46440: LD_INT 2
46442: PUSH
46443: EMPTY
46444: LIST
46445: LIST
46446: LIST
46447: PUSH
46448: LD_VAR 0 1
46452: PUSH
46453: LD_INT 4
46455: MINUS
46456: PUSH
46457: LD_VAR 0 2
46461: PUSH
46462: LD_INT 1
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: LIST
46469: PUSH
46470: LD_VAR 0 1
46474: PUSH
46475: LD_VAR 0 2
46479: PUSH
46480: LD_INT 3
46482: PLUS
46483: PUSH
46484: LD_INT 0
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: LIST
46491: PUSH
46492: LD_VAR 0 1
46496: PUSH
46497: LD_INT 4
46499: PLUS
46500: PUSH
46501: LD_VAR 0 2
46505: PUSH
46506: LD_INT 4
46508: PLUS
46509: PUSH
46510: LD_INT 5
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: LIST
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: LIST
46524: ST_TO_ADDR
// end ; 2 :
46525: GO 47084
46527: LD_INT 2
46529: DOUBLE
46530: EQUAL
46531: IFTRUE 46535
46533: GO 46664
46535: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46536: LD_ADDR_VAR 0 5
46540: PUSH
46541: LD_VAR 0 1
46545: PUSH
46546: LD_VAR 0 2
46550: PUSH
46551: LD_INT 3
46553: MINUS
46554: PUSH
46555: LD_INT 3
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: LIST
46562: PUSH
46563: LD_VAR 0 1
46567: PUSH
46568: LD_INT 4
46570: PLUS
46571: PUSH
46572: LD_VAR 0 2
46576: PUSH
46577: LD_INT 4
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: LIST
46584: PUSH
46585: LD_VAR 0 1
46589: PUSH
46590: LD_VAR 0 2
46594: PUSH
46595: LD_INT 4
46597: PLUS
46598: PUSH
46599: LD_INT 0
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: LIST
46606: PUSH
46607: LD_VAR 0 1
46611: PUSH
46612: LD_INT 3
46614: MINUS
46615: PUSH
46616: LD_VAR 0 2
46620: PUSH
46621: LD_INT 1
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: LIST
46628: PUSH
46629: LD_VAR 0 1
46633: PUSH
46634: LD_INT 4
46636: MINUS
46637: PUSH
46638: LD_VAR 0 2
46642: PUSH
46643: LD_INT 4
46645: MINUS
46646: PUSH
46647: LD_INT 2
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: LIST
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: ST_TO_ADDR
// end ; 3 :
46662: GO 47084
46664: LD_INT 3
46666: DOUBLE
46667: EQUAL
46668: IFTRUE 46672
46670: GO 46805
46672: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46673: LD_ADDR_VAR 0 5
46677: PUSH
46678: LD_VAR 0 1
46682: PUSH
46683: LD_INT 3
46685: PLUS
46686: PUSH
46687: LD_VAR 0 2
46691: PUSH
46692: LD_INT 4
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: LIST
46699: PUSH
46700: LD_VAR 0 1
46704: PUSH
46705: LD_INT 4
46707: PLUS
46708: PUSH
46709: LD_VAR 0 2
46713: PUSH
46714: LD_INT 4
46716: PLUS
46717: PUSH
46718: LD_INT 5
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: LIST
46725: PUSH
46726: LD_VAR 0 1
46730: PUSH
46731: LD_INT 4
46733: MINUS
46734: PUSH
46735: LD_VAR 0 2
46739: PUSH
46740: LD_INT 1
46742: PUSH
46743: EMPTY
46744: LIST
46745: LIST
46746: LIST
46747: PUSH
46748: LD_VAR 0 1
46752: PUSH
46753: LD_VAR 0 2
46757: PUSH
46758: LD_INT 4
46760: MINUS
46761: PUSH
46762: LD_INT 3
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: LIST
46769: PUSH
46770: LD_VAR 0 1
46774: PUSH
46775: LD_INT 3
46777: MINUS
46778: PUSH
46779: LD_VAR 0 2
46783: PUSH
46784: LD_INT 3
46786: MINUS
46787: PUSH
46788: LD_INT 2
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: LIST
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: LIST
46802: ST_TO_ADDR
// end ; 4 :
46803: GO 47084
46805: LD_INT 4
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 46946
46813: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46814: LD_ADDR_VAR 0 5
46818: PUSH
46819: LD_VAR 0 1
46823: PUSH
46824: LD_VAR 0 2
46828: PUSH
46829: LD_INT 4
46831: PLUS
46832: PUSH
46833: LD_INT 0
46835: PUSH
46836: EMPTY
46837: LIST
46838: LIST
46839: LIST
46840: PUSH
46841: LD_VAR 0 1
46845: PUSH
46846: LD_INT 3
46848: PLUS
46849: PUSH
46850: LD_VAR 0 2
46854: PUSH
46855: LD_INT 3
46857: PLUS
46858: PUSH
46859: LD_INT 5
46861: PUSH
46862: EMPTY
46863: LIST
46864: LIST
46865: LIST
46866: PUSH
46867: LD_VAR 0 1
46871: PUSH
46872: LD_INT 4
46874: PLUS
46875: PUSH
46876: LD_VAR 0 2
46880: PUSH
46881: LD_INT 4
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: LIST
46888: PUSH
46889: LD_VAR 0 1
46893: PUSH
46894: LD_VAR 0 2
46898: PUSH
46899: LD_INT 3
46901: MINUS
46902: PUSH
46903: LD_INT 3
46905: PUSH
46906: EMPTY
46907: LIST
46908: LIST
46909: LIST
46910: PUSH
46911: LD_VAR 0 1
46915: PUSH
46916: LD_INT 4
46918: MINUS
46919: PUSH
46920: LD_VAR 0 2
46924: PUSH
46925: LD_INT 4
46927: MINUS
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: LIST
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: LIST
46943: ST_TO_ADDR
// end ; 5 :
46944: GO 47084
46946: LD_INT 5
46948: DOUBLE
46949: EQUAL
46950: IFTRUE 46954
46952: GO 47083
46954: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46955: LD_ADDR_VAR 0 5
46959: PUSH
46960: LD_VAR 0 1
46964: PUSH
46965: LD_INT 4
46967: MINUS
46968: PUSH
46969: LD_VAR 0 2
46973: PUSH
46974: LD_INT 1
46976: PUSH
46977: EMPTY
46978: LIST
46979: LIST
46980: LIST
46981: PUSH
46982: LD_VAR 0 1
46986: PUSH
46987: LD_VAR 0 2
46991: PUSH
46992: LD_INT 4
46994: MINUS
46995: PUSH
46996: LD_INT 3
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: LIST
47003: PUSH
47004: LD_VAR 0 1
47008: PUSH
47009: LD_INT 4
47011: PLUS
47012: PUSH
47013: LD_VAR 0 2
47017: PUSH
47018: LD_INT 4
47020: PLUS
47021: PUSH
47022: LD_INT 5
47024: PUSH
47025: EMPTY
47026: LIST
47027: LIST
47028: LIST
47029: PUSH
47030: LD_VAR 0 1
47034: PUSH
47035: LD_INT 3
47037: PLUS
47038: PUSH
47039: LD_VAR 0 2
47043: PUSH
47044: LD_INT 4
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: LIST
47051: PUSH
47052: LD_VAR 0 1
47056: PUSH
47057: LD_VAR 0 2
47061: PUSH
47062: LD_INT 3
47064: PLUS
47065: PUSH
47066: LD_INT 0
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: LIST
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: ST_TO_ADDR
// end ; end ;
47081: GO 47084
47083: POP
// result := list ;
47084: LD_ADDR_VAR 0 4
47088: PUSH
47089: LD_VAR 0 5
47093: ST_TO_ADDR
// end ;
47094: LD_VAR 0 4
47098: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
47099: LD_INT 0
47101: PPUSH
47102: PPUSH
47103: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
47104: LD_VAR 0 1
47108: NOT
47109: PUSH
47110: LD_VAR 0 2
47114: PUSH
47115: LD_INT 1
47117: PUSH
47118: LD_INT 2
47120: PUSH
47121: LD_INT 3
47123: PUSH
47124: LD_INT 4
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: LIST
47131: LIST
47132: IN
47133: NOT
47134: OR
47135: IFFALSE 47139
// exit ;
47137: GO 47222
// tmp := [ ] ;
47139: LD_ADDR_VAR 0 5
47143: PUSH
47144: EMPTY
47145: ST_TO_ADDR
// for i in units do
47146: LD_ADDR_VAR 0 4
47150: PUSH
47151: LD_VAR 0 1
47155: PUSH
47156: FOR_IN
47157: IFFALSE 47191
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47159: LD_ADDR_VAR 0 5
47163: PUSH
47164: LD_VAR 0 5
47168: PPUSH
47169: LD_VAR 0 4
47173: PPUSH
47174: LD_VAR 0 2
47178: PPUSH
47179: CALL_OW 259
47183: PPUSH
47184: CALL 48583 0 2
47188: ST_TO_ADDR
47189: GO 47156
47191: POP
47192: POP
// if not tmp then
47193: LD_VAR 0 5
47197: NOT
47198: IFFALSE 47202
// exit ;
47200: GO 47222
// result := SortListByListDesc ( units , tmp ) ;
47202: LD_ADDR_VAR 0 3
47206: PUSH
47207: LD_VAR 0 1
47211: PPUSH
47212: LD_VAR 0 5
47216: PPUSH
47217: CALL_OW 77
47221: ST_TO_ADDR
// end ;
47222: LD_VAR 0 3
47226: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47227: LD_INT 0
47229: PPUSH
47230: PPUSH
47231: PPUSH
// result := false ;
47232: LD_ADDR_VAR 0 3
47236: PUSH
47237: LD_INT 0
47239: ST_TO_ADDR
// if not building then
47240: LD_VAR 0 2
47244: NOT
47245: IFFALSE 47249
// exit ;
47247: GO 47387
// x := GetX ( building ) ;
47249: LD_ADDR_VAR 0 4
47253: PUSH
47254: LD_VAR 0 2
47258: PPUSH
47259: CALL_OW 250
47263: ST_TO_ADDR
// y := GetY ( building ) ;
47264: LD_ADDR_VAR 0 5
47268: PUSH
47269: LD_VAR 0 2
47273: PPUSH
47274: CALL_OW 251
47278: ST_TO_ADDR
// if not x or not y then
47279: LD_VAR 0 4
47283: NOT
47284: PUSH
47285: LD_VAR 0 5
47289: NOT
47290: OR
47291: IFFALSE 47295
// exit ;
47293: GO 47387
// if GetTaskList ( unit ) then
47295: LD_VAR 0 1
47299: PPUSH
47300: CALL_OW 437
47304: IFFALSE 47387
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47306: LD_STRING e
47308: PUSH
47309: LD_VAR 0 1
47313: PPUSH
47314: CALL_OW 437
47318: PUSH
47319: LD_INT 1
47321: ARRAY
47322: PUSH
47323: LD_INT 1
47325: ARRAY
47326: EQUAL
47327: PUSH
47328: LD_VAR 0 4
47332: PUSH
47333: LD_VAR 0 1
47337: PPUSH
47338: CALL_OW 437
47342: PUSH
47343: LD_INT 1
47345: ARRAY
47346: PUSH
47347: LD_INT 2
47349: ARRAY
47350: EQUAL
47351: AND
47352: PUSH
47353: LD_VAR 0 5
47357: PUSH
47358: LD_VAR 0 1
47362: PPUSH
47363: CALL_OW 437
47367: PUSH
47368: LD_INT 1
47370: ARRAY
47371: PUSH
47372: LD_INT 3
47374: ARRAY
47375: EQUAL
47376: AND
47377: IFFALSE 47387
// result := true end ;
47379: LD_ADDR_VAR 0 3
47383: PUSH
47384: LD_INT 1
47386: ST_TO_ADDR
// end ;
47387: LD_VAR 0 3
47391: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47392: LD_INT 0
47394: PPUSH
// result := false ;
47395: LD_ADDR_VAR 0 4
47399: PUSH
47400: LD_INT 0
47402: ST_TO_ADDR
// if GetTaskList ( unit ) then
47403: LD_VAR 0 1
47407: PPUSH
47408: CALL_OW 437
47412: IFFALSE 47495
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47414: LD_STRING M
47416: PUSH
47417: LD_VAR 0 1
47421: PPUSH
47422: CALL_OW 437
47426: PUSH
47427: LD_INT 1
47429: ARRAY
47430: PUSH
47431: LD_INT 1
47433: ARRAY
47434: EQUAL
47435: PUSH
47436: LD_VAR 0 2
47440: PUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL_OW 437
47450: PUSH
47451: LD_INT 1
47453: ARRAY
47454: PUSH
47455: LD_INT 2
47457: ARRAY
47458: EQUAL
47459: AND
47460: PUSH
47461: LD_VAR 0 3
47465: PUSH
47466: LD_VAR 0 1
47470: PPUSH
47471: CALL_OW 437
47475: PUSH
47476: LD_INT 1
47478: ARRAY
47479: PUSH
47480: LD_INT 3
47482: ARRAY
47483: EQUAL
47484: AND
47485: IFFALSE 47495
// result := true ;
47487: LD_ADDR_VAR 0 4
47491: PUSH
47492: LD_INT 1
47494: ST_TO_ADDR
// end ; end ;
47495: LD_VAR 0 4
47499: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47500: LD_INT 0
47502: PPUSH
47503: PPUSH
47504: PPUSH
47505: PPUSH
// if not unit or not area then
47506: LD_VAR 0 1
47510: NOT
47511: PUSH
47512: LD_VAR 0 2
47516: NOT
47517: OR
47518: IFFALSE 47522
// exit ;
47520: GO 47686
// tmp := AreaToList ( area , i ) ;
47522: LD_ADDR_VAR 0 6
47526: PUSH
47527: LD_VAR 0 2
47531: PPUSH
47532: LD_VAR 0 5
47536: PPUSH
47537: CALL_OW 517
47541: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47542: LD_ADDR_VAR 0 5
47546: PUSH
47547: DOUBLE
47548: LD_INT 1
47550: DEC
47551: ST_TO_ADDR
47552: LD_VAR 0 6
47556: PUSH
47557: LD_INT 1
47559: ARRAY
47560: PUSH
47561: FOR_TO
47562: IFFALSE 47684
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47564: LD_ADDR_VAR 0 7
47568: PUSH
47569: LD_VAR 0 6
47573: PUSH
47574: LD_INT 1
47576: ARRAY
47577: PUSH
47578: LD_VAR 0 5
47582: ARRAY
47583: PUSH
47584: LD_VAR 0 6
47588: PUSH
47589: LD_INT 2
47591: ARRAY
47592: PUSH
47593: LD_VAR 0 5
47597: ARRAY
47598: PUSH
47599: EMPTY
47600: LIST
47601: LIST
47602: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47603: LD_VAR 0 7
47607: PUSH
47608: LD_INT 1
47610: ARRAY
47611: PPUSH
47612: LD_VAR 0 7
47616: PUSH
47617: LD_INT 2
47619: ARRAY
47620: PPUSH
47621: CALL_OW 428
47625: PUSH
47626: LD_INT 0
47628: EQUAL
47629: IFFALSE 47682
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47631: LD_VAR 0 1
47635: PPUSH
47636: LD_VAR 0 7
47640: PUSH
47641: LD_INT 1
47643: ARRAY
47644: PPUSH
47645: LD_VAR 0 7
47649: PUSH
47650: LD_INT 2
47652: ARRAY
47653: PPUSH
47654: LD_VAR 0 3
47658: PPUSH
47659: CALL_OW 48
// result := IsPlaced ( unit ) ;
47663: LD_ADDR_VAR 0 4
47667: PUSH
47668: LD_VAR 0 1
47672: PPUSH
47673: CALL_OW 305
47677: ST_TO_ADDR
// exit ;
47678: POP
47679: POP
47680: GO 47686
// end ; end ;
47682: GO 47561
47684: POP
47685: POP
// end ;
47686: LD_VAR 0 4
47690: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47691: LD_INT 0
47693: PPUSH
47694: PPUSH
47695: PPUSH
// if not side or side > 8 then
47696: LD_VAR 0 1
47700: NOT
47701: PUSH
47702: LD_VAR 0 1
47706: PUSH
47707: LD_INT 8
47709: GREATER
47710: OR
47711: IFFALSE 47715
// exit ;
47713: GO 47902
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47715: LD_ADDR_VAR 0 4
47719: PUSH
47720: LD_INT 22
47722: PUSH
47723: LD_VAR 0 1
47727: PUSH
47728: EMPTY
47729: LIST
47730: LIST
47731: PUSH
47732: LD_INT 21
47734: PUSH
47735: LD_INT 3
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: PUSH
47742: EMPTY
47743: LIST
47744: LIST
47745: PPUSH
47746: CALL_OW 69
47750: ST_TO_ADDR
// if not tmp then
47751: LD_VAR 0 4
47755: NOT
47756: IFFALSE 47760
// exit ;
47758: GO 47902
// enable_addtolog := true ;
47760: LD_ADDR_OWVAR 81
47764: PUSH
47765: LD_INT 1
47767: ST_TO_ADDR
// AddToLog ( [ ) ;
47768: LD_STRING [
47770: PPUSH
47771: CALL_OW 561
// for i in tmp do
47775: LD_ADDR_VAR 0 3
47779: PUSH
47780: LD_VAR 0 4
47784: PUSH
47785: FOR_IN
47786: IFFALSE 47893
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47788: LD_STRING [
47790: PUSH
47791: LD_VAR 0 3
47795: PPUSH
47796: CALL_OW 266
47800: STR
47801: PUSH
47802: LD_STRING , 
47804: STR
47805: PUSH
47806: LD_VAR 0 3
47810: PPUSH
47811: CALL_OW 250
47815: STR
47816: PUSH
47817: LD_STRING , 
47819: STR
47820: PUSH
47821: LD_VAR 0 3
47825: PPUSH
47826: CALL_OW 251
47830: STR
47831: PUSH
47832: LD_STRING , 
47834: STR
47835: PUSH
47836: LD_VAR 0 3
47840: PPUSH
47841: CALL_OW 254
47845: STR
47846: PUSH
47847: LD_STRING , 
47849: STR
47850: PUSH
47851: LD_VAR 0 3
47855: PPUSH
47856: LD_INT 1
47858: PPUSH
47859: CALL_OW 268
47863: STR
47864: PUSH
47865: LD_STRING , 
47867: STR
47868: PUSH
47869: LD_VAR 0 3
47873: PPUSH
47874: LD_INT 2
47876: PPUSH
47877: CALL_OW 268
47881: STR
47882: PUSH
47883: LD_STRING ],
47885: STR
47886: PPUSH
47887: CALL_OW 561
// end ;
47891: GO 47785
47893: POP
47894: POP
// AddToLog ( ]; ) ;
47895: LD_STRING ];
47897: PPUSH
47898: CALL_OW 561
// end ;
47902: LD_VAR 0 2
47906: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47907: LD_INT 0
47909: PPUSH
47910: PPUSH
47911: PPUSH
47912: PPUSH
47913: PPUSH
// if not area or not rate or not max then
47914: LD_VAR 0 1
47918: NOT
47919: PUSH
47920: LD_VAR 0 2
47924: NOT
47925: OR
47926: PUSH
47927: LD_VAR 0 4
47931: NOT
47932: OR
47933: IFFALSE 47937
// exit ;
47935: GO 48126
// while 1 do
47937: LD_INT 1
47939: IFFALSE 48126
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47941: LD_ADDR_VAR 0 9
47945: PUSH
47946: LD_VAR 0 1
47950: PPUSH
47951: LD_INT 1
47953: PPUSH
47954: CALL_OW 287
47958: PUSH
47959: LD_INT 10
47961: MUL
47962: ST_TO_ADDR
// r := rate / 10 ;
47963: LD_ADDR_VAR 0 7
47967: PUSH
47968: LD_VAR 0 2
47972: PUSH
47973: LD_INT 10
47975: DIVREAL
47976: ST_TO_ADDR
// time := 1 1$00 ;
47977: LD_ADDR_VAR 0 8
47981: PUSH
47982: LD_INT 2100
47984: ST_TO_ADDR
// if amount < min then
47985: LD_VAR 0 9
47989: PUSH
47990: LD_VAR 0 3
47994: LESS
47995: IFFALSE 48013
// r := r * 2 else
47997: LD_ADDR_VAR 0 7
48001: PUSH
48002: LD_VAR 0 7
48006: PUSH
48007: LD_INT 2
48009: MUL
48010: ST_TO_ADDR
48011: GO 48039
// if amount > max then
48013: LD_VAR 0 9
48017: PUSH
48018: LD_VAR 0 4
48022: GREATER
48023: IFFALSE 48039
// r := r / 2 ;
48025: LD_ADDR_VAR 0 7
48029: PUSH
48030: LD_VAR 0 7
48034: PUSH
48035: LD_INT 2
48037: DIVREAL
48038: ST_TO_ADDR
// time := time / r ;
48039: LD_ADDR_VAR 0 8
48043: PUSH
48044: LD_VAR 0 8
48048: PUSH
48049: LD_VAR 0 7
48053: DIVREAL
48054: ST_TO_ADDR
// if time < 0 then
48055: LD_VAR 0 8
48059: PUSH
48060: LD_INT 0
48062: LESS
48063: IFFALSE 48080
// time := time * - 1 ;
48065: LD_ADDR_VAR 0 8
48069: PUSH
48070: LD_VAR 0 8
48074: PUSH
48075: LD_INT 1
48077: NEG
48078: MUL
48079: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
48080: LD_VAR 0 8
48084: PUSH
48085: LD_INT 35
48087: PPUSH
48088: LD_INT 875
48090: PPUSH
48091: CALL_OW 12
48095: PLUS
48096: PPUSH
48097: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48101: LD_INT 1
48103: PPUSH
48104: LD_INT 5
48106: PPUSH
48107: CALL_OW 12
48111: PPUSH
48112: LD_VAR 0 1
48116: PPUSH
48117: LD_INT 1
48119: PPUSH
48120: CALL_OW 55
// end ;
48124: GO 47937
// end ;
48126: LD_VAR 0 5
48130: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48131: LD_INT 0
48133: PPUSH
48134: PPUSH
48135: PPUSH
48136: PPUSH
48137: PPUSH
48138: PPUSH
48139: PPUSH
48140: PPUSH
// if not turrets or not factories then
48141: LD_VAR 0 1
48145: NOT
48146: PUSH
48147: LD_VAR 0 2
48151: NOT
48152: OR
48153: IFFALSE 48157
// exit ;
48155: GO 48464
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48157: LD_ADDR_VAR 0 10
48161: PUSH
48162: LD_INT 5
48164: PUSH
48165: LD_INT 6
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: LD_INT 2
48174: PUSH
48175: LD_INT 4
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: LD_INT 3
48184: PUSH
48185: LD_INT 5
48187: PUSH
48188: EMPTY
48189: LIST
48190: LIST
48191: PUSH
48192: EMPTY
48193: LIST
48194: LIST
48195: LIST
48196: PUSH
48197: LD_INT 24
48199: PUSH
48200: LD_INT 25
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: PUSH
48207: LD_INT 23
48209: PUSH
48210: LD_INT 27
48212: PUSH
48213: EMPTY
48214: LIST
48215: LIST
48216: PUSH
48217: EMPTY
48218: LIST
48219: LIST
48220: PUSH
48221: LD_INT 42
48223: PUSH
48224: LD_INT 43
48226: PUSH
48227: EMPTY
48228: LIST
48229: LIST
48230: PUSH
48231: LD_INT 44
48233: PUSH
48234: LD_INT 46
48236: PUSH
48237: EMPTY
48238: LIST
48239: LIST
48240: PUSH
48241: LD_INT 45
48243: PUSH
48244: LD_INT 47
48246: PUSH
48247: EMPTY
48248: LIST
48249: LIST
48250: PUSH
48251: EMPTY
48252: LIST
48253: LIST
48254: LIST
48255: PUSH
48256: EMPTY
48257: LIST
48258: LIST
48259: LIST
48260: ST_TO_ADDR
// result := [ ] ;
48261: LD_ADDR_VAR 0 3
48265: PUSH
48266: EMPTY
48267: ST_TO_ADDR
// for i in turrets do
48268: LD_ADDR_VAR 0 4
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: FOR_IN
48279: IFFALSE 48462
// begin nat := GetNation ( i ) ;
48281: LD_ADDR_VAR 0 7
48285: PUSH
48286: LD_VAR 0 4
48290: PPUSH
48291: CALL_OW 248
48295: ST_TO_ADDR
// weapon := 0 ;
48296: LD_ADDR_VAR 0 8
48300: PUSH
48301: LD_INT 0
48303: ST_TO_ADDR
// if not nat then
48304: LD_VAR 0 7
48308: NOT
48309: IFFALSE 48313
// continue ;
48311: GO 48278
// for j in list [ nat ] do
48313: LD_ADDR_VAR 0 5
48317: PUSH
48318: LD_VAR 0 10
48322: PUSH
48323: LD_VAR 0 7
48327: ARRAY
48328: PUSH
48329: FOR_IN
48330: IFFALSE 48371
// if GetBWeapon ( i ) = j [ 1 ] then
48332: LD_VAR 0 4
48336: PPUSH
48337: CALL_OW 269
48341: PUSH
48342: LD_VAR 0 5
48346: PUSH
48347: LD_INT 1
48349: ARRAY
48350: EQUAL
48351: IFFALSE 48369
// begin weapon := j [ 2 ] ;
48353: LD_ADDR_VAR 0 8
48357: PUSH
48358: LD_VAR 0 5
48362: PUSH
48363: LD_INT 2
48365: ARRAY
48366: ST_TO_ADDR
// break ;
48367: GO 48371
// end ;
48369: GO 48329
48371: POP
48372: POP
// if not weapon then
48373: LD_VAR 0 8
48377: NOT
48378: IFFALSE 48382
// continue ;
48380: GO 48278
// for k in factories do
48382: LD_ADDR_VAR 0 6
48386: PUSH
48387: LD_VAR 0 2
48391: PUSH
48392: FOR_IN
48393: IFFALSE 48458
// begin weapons := AvailableWeaponList ( k ) ;
48395: LD_ADDR_VAR 0 9
48399: PUSH
48400: LD_VAR 0 6
48404: PPUSH
48405: CALL_OW 478
48409: ST_TO_ADDR
// if not weapons then
48410: LD_VAR 0 9
48414: NOT
48415: IFFALSE 48419
// continue ;
48417: GO 48392
// if weapon in weapons then
48419: LD_VAR 0 8
48423: PUSH
48424: LD_VAR 0 9
48428: IN
48429: IFFALSE 48456
// begin result := [ i , weapon ] ;
48431: LD_ADDR_VAR 0 3
48435: PUSH
48436: LD_VAR 0 4
48440: PUSH
48441: LD_VAR 0 8
48445: PUSH
48446: EMPTY
48447: LIST
48448: LIST
48449: ST_TO_ADDR
// exit ;
48450: POP
48451: POP
48452: POP
48453: POP
48454: GO 48464
// end ; end ;
48456: GO 48392
48458: POP
48459: POP
// end ;
48460: GO 48278
48462: POP
48463: POP
// end ;
48464: LD_VAR 0 3
48468: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48469: LD_INT 0
48471: PPUSH
// if not side or side > 8 then
48472: LD_VAR 0 3
48476: NOT
48477: PUSH
48478: LD_VAR 0 3
48482: PUSH
48483: LD_INT 8
48485: GREATER
48486: OR
48487: IFFALSE 48491
// exit ;
48489: GO 48550
// if not range then
48491: LD_VAR 0 4
48495: NOT
48496: IFFALSE 48507
// range := - 12 ;
48498: LD_ADDR_VAR 0 4
48502: PUSH
48503: LD_INT 12
48505: NEG
48506: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48507: LD_VAR 0 1
48511: PPUSH
48512: LD_VAR 0 2
48516: PPUSH
48517: LD_VAR 0 3
48521: PPUSH
48522: LD_VAR 0 4
48526: PPUSH
48527: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48531: LD_VAR 0 1
48535: PPUSH
48536: LD_VAR 0 2
48540: PPUSH
48541: LD_VAR 0 3
48545: PPUSH
48546: CALL_OW 331
// end ;
48550: LD_VAR 0 5
48554: RET
// export function Video ( mode ) ; begin
48555: LD_INT 0
48557: PPUSH
// ingame_video = mode ;
48558: LD_ADDR_OWVAR 52
48562: PUSH
48563: LD_VAR 0 1
48567: ST_TO_ADDR
// interface_hidden = mode ;
48568: LD_ADDR_OWVAR 54
48572: PUSH
48573: LD_VAR 0 1
48577: ST_TO_ADDR
// end ;
48578: LD_VAR 0 2
48582: RET
// export function Join ( array , element ) ; begin
48583: LD_INT 0
48585: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48586: LD_ADDR_VAR 0 3
48590: PUSH
48591: LD_VAR 0 1
48595: PPUSH
48596: LD_VAR 0 1
48600: PUSH
48601: LD_INT 1
48603: PLUS
48604: PPUSH
48605: LD_VAR 0 2
48609: PPUSH
48610: CALL_OW 1
48614: ST_TO_ADDR
// end ;
48615: LD_VAR 0 3
48619: RET
// export function JoinUnion ( array , element ) ; begin
48620: LD_INT 0
48622: PPUSH
// result := array union element ;
48623: LD_ADDR_VAR 0 3
48627: PUSH
48628: LD_VAR 0 1
48632: PUSH
48633: LD_VAR 0 2
48637: UNION
48638: ST_TO_ADDR
// end ;
48639: LD_VAR 0 3
48643: RET
// export function GetBehemoths ( side ) ; begin
48644: LD_INT 0
48646: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48647: LD_ADDR_VAR 0 2
48651: PUSH
48652: LD_INT 22
48654: PUSH
48655: LD_VAR 0 1
48659: PUSH
48660: EMPTY
48661: LIST
48662: LIST
48663: PUSH
48664: LD_INT 31
48666: PUSH
48667: LD_INT 25
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PPUSH
48678: CALL_OW 69
48682: ST_TO_ADDR
// end ;
48683: LD_VAR 0 2
48687: RET
// export function Shuffle ( array ) ; var i , index ; begin
48688: LD_INT 0
48690: PPUSH
48691: PPUSH
48692: PPUSH
// result := [ ] ;
48693: LD_ADDR_VAR 0 2
48697: PUSH
48698: EMPTY
48699: ST_TO_ADDR
// if not array then
48700: LD_VAR 0 1
48704: NOT
48705: IFFALSE 48709
// exit ;
48707: GO 48808
// Randomize ;
48709: CALL_OW 10
// for i = array downto 1 do
48713: LD_ADDR_VAR 0 3
48717: PUSH
48718: DOUBLE
48719: LD_VAR 0 1
48723: INC
48724: ST_TO_ADDR
48725: LD_INT 1
48727: PUSH
48728: FOR_DOWNTO
48729: IFFALSE 48806
// begin index := rand ( 1 , array ) ;
48731: LD_ADDR_VAR 0 4
48735: PUSH
48736: LD_INT 1
48738: PPUSH
48739: LD_VAR 0 1
48743: PPUSH
48744: CALL_OW 12
48748: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48749: LD_ADDR_VAR 0 2
48753: PUSH
48754: LD_VAR 0 2
48758: PPUSH
48759: LD_VAR 0 2
48763: PUSH
48764: LD_INT 1
48766: PLUS
48767: PPUSH
48768: LD_VAR 0 1
48772: PUSH
48773: LD_VAR 0 4
48777: ARRAY
48778: PPUSH
48779: CALL_OW 2
48783: ST_TO_ADDR
// array := Delete ( array , index ) ;
48784: LD_ADDR_VAR 0 1
48788: PUSH
48789: LD_VAR 0 1
48793: PPUSH
48794: LD_VAR 0 4
48798: PPUSH
48799: CALL_OW 3
48803: ST_TO_ADDR
// end ;
48804: GO 48728
48806: POP
48807: POP
// end ;
48808: LD_VAR 0 2
48812: RET
// export function GetBaseMaterials ( base ) ; begin
48813: LD_INT 0
48815: PPUSH
// result := [ 0 , 0 , 0 ] ;
48816: LD_ADDR_VAR 0 2
48820: PUSH
48821: LD_INT 0
48823: PUSH
48824: LD_INT 0
48826: PUSH
48827: LD_INT 0
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: LIST
48834: ST_TO_ADDR
// if not base then
48835: LD_VAR 0 1
48839: NOT
48840: IFFALSE 48844
// exit ;
48842: GO 48893
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48844: LD_ADDR_VAR 0 2
48848: PUSH
48849: LD_VAR 0 1
48853: PPUSH
48854: LD_INT 1
48856: PPUSH
48857: CALL_OW 275
48861: PUSH
48862: LD_VAR 0 1
48866: PPUSH
48867: LD_INT 2
48869: PPUSH
48870: CALL_OW 275
48874: PUSH
48875: LD_VAR 0 1
48879: PPUSH
48880: LD_INT 3
48882: PPUSH
48883: CALL_OW 275
48887: PUSH
48888: EMPTY
48889: LIST
48890: LIST
48891: LIST
48892: ST_TO_ADDR
// end ;
48893: LD_VAR 0 2
48897: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48898: LD_INT 0
48900: PPUSH
48901: PPUSH
// result := array ;
48902: LD_ADDR_VAR 0 3
48906: PUSH
48907: LD_VAR 0 1
48911: ST_TO_ADDR
// if size >= result then
48912: LD_VAR 0 2
48916: PUSH
48917: LD_VAR 0 3
48921: GREATEREQUAL
48922: IFFALSE 48926
// exit ;
48924: GO 48976
// if size then
48926: LD_VAR 0 2
48930: IFFALSE 48976
// for i := array downto size do
48932: LD_ADDR_VAR 0 4
48936: PUSH
48937: DOUBLE
48938: LD_VAR 0 1
48942: INC
48943: ST_TO_ADDR
48944: LD_VAR 0 2
48948: PUSH
48949: FOR_DOWNTO
48950: IFFALSE 48974
// result := Delete ( result , result ) ;
48952: LD_ADDR_VAR 0 3
48956: PUSH
48957: LD_VAR 0 3
48961: PPUSH
48962: LD_VAR 0 3
48966: PPUSH
48967: CALL_OW 3
48971: ST_TO_ADDR
48972: GO 48949
48974: POP
48975: POP
// end ;
48976: LD_VAR 0 3
48980: RET
// export function ComExit ( unit ) ; var tmp ; begin
48981: LD_INT 0
48983: PPUSH
48984: PPUSH
// if not IsInUnit ( unit ) then
48985: LD_VAR 0 1
48989: PPUSH
48990: CALL_OW 310
48994: NOT
48995: IFFALSE 48999
// exit ;
48997: GO 49059
// tmp := IsInUnit ( unit ) ;
48999: LD_ADDR_VAR 0 3
49003: PUSH
49004: LD_VAR 0 1
49008: PPUSH
49009: CALL_OW 310
49013: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49014: LD_VAR 0 3
49018: PPUSH
49019: CALL_OW 247
49023: PUSH
49024: LD_INT 2
49026: EQUAL
49027: IFFALSE 49040
// ComExitVehicle ( unit ) else
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 121
49038: GO 49049
// ComExitBuilding ( unit ) ;
49040: LD_VAR 0 1
49044: PPUSH
49045: CALL_OW 122
// result := tmp ;
49049: LD_ADDR_VAR 0 2
49053: PUSH
49054: LD_VAR 0 3
49058: ST_TO_ADDR
// end ;
49059: LD_VAR 0 2
49063: RET
// export function ComExitAll ( units ) ; var i ; begin
49064: LD_INT 0
49066: PPUSH
49067: PPUSH
// if not units then
49068: LD_VAR 0 1
49072: NOT
49073: IFFALSE 49077
// exit ;
49075: GO 49103
// for i in units do
49077: LD_ADDR_VAR 0 3
49081: PUSH
49082: LD_VAR 0 1
49086: PUSH
49087: FOR_IN
49088: IFFALSE 49101
// ComExit ( i ) ;
49090: LD_VAR 0 3
49094: PPUSH
49095: CALL 48981 0 1
49099: GO 49087
49101: POP
49102: POP
// end ;
49103: LD_VAR 0 2
49107: RET
// export function ResetHc ; begin
49108: LD_INT 0
49110: PPUSH
// InitHc ;
49111: CALL_OW 19
// hc_importance := 0 ;
49115: LD_ADDR_OWVAR 32
49119: PUSH
49120: LD_INT 0
49122: ST_TO_ADDR
// end ;
49123: LD_VAR 0 1
49127: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49128: LD_INT 0
49130: PPUSH
49131: PPUSH
49132: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49133: LD_ADDR_VAR 0 6
49137: PUSH
49138: LD_VAR 0 1
49142: PUSH
49143: LD_VAR 0 3
49147: PLUS
49148: PUSH
49149: LD_INT 2
49151: DIV
49152: ST_TO_ADDR
// if _x < 0 then
49153: LD_VAR 0 6
49157: PUSH
49158: LD_INT 0
49160: LESS
49161: IFFALSE 49178
// _x := _x * - 1 ;
49163: LD_ADDR_VAR 0 6
49167: PUSH
49168: LD_VAR 0 6
49172: PUSH
49173: LD_INT 1
49175: NEG
49176: MUL
49177: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49178: LD_ADDR_VAR 0 7
49182: PUSH
49183: LD_VAR 0 2
49187: PUSH
49188: LD_VAR 0 4
49192: PLUS
49193: PUSH
49194: LD_INT 2
49196: DIV
49197: ST_TO_ADDR
// if _y < 0 then
49198: LD_VAR 0 7
49202: PUSH
49203: LD_INT 0
49205: LESS
49206: IFFALSE 49223
// _y := _y * - 1 ;
49208: LD_ADDR_VAR 0 7
49212: PUSH
49213: LD_VAR 0 7
49217: PUSH
49218: LD_INT 1
49220: NEG
49221: MUL
49222: ST_TO_ADDR
// result := [ _x , _y ] ;
49223: LD_ADDR_VAR 0 5
49227: PUSH
49228: LD_VAR 0 6
49232: PUSH
49233: LD_VAR 0 7
49237: PUSH
49238: EMPTY
49239: LIST
49240: LIST
49241: ST_TO_ADDR
// end ;
49242: LD_VAR 0 5
49246: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49247: LD_INT 0
49249: PPUSH
49250: PPUSH
49251: PPUSH
49252: PPUSH
// task := GetTaskList ( unit ) ;
49253: LD_ADDR_VAR 0 7
49257: PUSH
49258: LD_VAR 0 1
49262: PPUSH
49263: CALL_OW 437
49267: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49268: LD_VAR 0 7
49272: NOT
49273: PUSH
49274: LD_VAR 0 1
49278: PPUSH
49279: LD_VAR 0 2
49283: PPUSH
49284: CALL_OW 308
49288: NOT
49289: AND
49290: IFFALSE 49294
// exit ;
49292: GO 49412
// if IsInArea ( unit , area ) then
49294: LD_VAR 0 1
49298: PPUSH
49299: LD_VAR 0 2
49303: PPUSH
49304: CALL_OW 308
49308: IFFALSE 49326
// begin ComMoveToArea ( unit , goAway ) ;
49310: LD_VAR 0 1
49314: PPUSH
49315: LD_VAR 0 3
49319: PPUSH
49320: CALL_OW 113
// exit ;
49324: GO 49412
// end ; if task [ 1 ] [ 1 ] <> M then
49326: LD_VAR 0 7
49330: PUSH
49331: LD_INT 1
49333: ARRAY
49334: PUSH
49335: LD_INT 1
49337: ARRAY
49338: PUSH
49339: LD_STRING M
49341: NONEQUAL
49342: IFFALSE 49346
// exit ;
49344: GO 49412
// x := task [ 1 ] [ 2 ] ;
49346: LD_ADDR_VAR 0 5
49350: PUSH
49351: LD_VAR 0 7
49355: PUSH
49356: LD_INT 1
49358: ARRAY
49359: PUSH
49360: LD_INT 2
49362: ARRAY
49363: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49364: LD_ADDR_VAR 0 6
49368: PUSH
49369: LD_VAR 0 7
49373: PUSH
49374: LD_INT 1
49376: ARRAY
49377: PUSH
49378: LD_INT 3
49380: ARRAY
49381: ST_TO_ADDR
// if InArea ( x , y , area ) then
49382: LD_VAR 0 5
49386: PPUSH
49387: LD_VAR 0 6
49391: PPUSH
49392: LD_VAR 0 2
49396: PPUSH
49397: CALL_OW 309
49401: IFFALSE 49412
// ComStop ( unit ) ;
49403: LD_VAR 0 1
49407: PPUSH
49408: CALL_OW 141
// end ;
49412: LD_VAR 0 4
49416: RET
// export function Abs ( value ) ; begin
49417: LD_INT 0
49419: PPUSH
// result := value ;
49420: LD_ADDR_VAR 0 2
49424: PUSH
49425: LD_VAR 0 1
49429: ST_TO_ADDR
// if value < 0 then
49430: LD_VAR 0 1
49434: PUSH
49435: LD_INT 0
49437: LESS
49438: IFFALSE 49455
// result := value * - 1 ;
49440: LD_ADDR_VAR 0 2
49444: PUSH
49445: LD_VAR 0 1
49449: PUSH
49450: LD_INT 1
49452: NEG
49453: MUL
49454: ST_TO_ADDR
// end ;
49455: LD_VAR 0 2
49459: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49460: LD_INT 0
49462: PPUSH
49463: PPUSH
49464: PPUSH
49465: PPUSH
49466: PPUSH
49467: PPUSH
49468: PPUSH
49469: PPUSH
// if not unit or not building then
49470: LD_VAR 0 1
49474: NOT
49475: PUSH
49476: LD_VAR 0 2
49480: NOT
49481: OR
49482: IFFALSE 49486
// exit ;
49484: GO 49712
// x := GetX ( building ) ;
49486: LD_ADDR_VAR 0 4
49490: PUSH
49491: LD_VAR 0 2
49495: PPUSH
49496: CALL_OW 250
49500: ST_TO_ADDR
// y := GetY ( building ) ;
49501: LD_ADDR_VAR 0 6
49505: PUSH
49506: LD_VAR 0 2
49510: PPUSH
49511: CALL_OW 251
49515: ST_TO_ADDR
// d := GetDir ( building ) ;
49516: LD_ADDR_VAR 0 8
49520: PUSH
49521: LD_VAR 0 2
49525: PPUSH
49526: CALL_OW 254
49530: ST_TO_ADDR
// r := 4 ;
49531: LD_ADDR_VAR 0 9
49535: PUSH
49536: LD_INT 4
49538: ST_TO_ADDR
// for i := 1 to 5 do
49539: LD_ADDR_VAR 0 10
49543: PUSH
49544: DOUBLE
49545: LD_INT 1
49547: DEC
49548: ST_TO_ADDR
49549: LD_INT 5
49551: PUSH
49552: FOR_TO
49553: IFFALSE 49710
// begin _x := ShiftX ( x , d , r + i ) ;
49555: LD_ADDR_VAR 0 5
49559: PUSH
49560: LD_VAR 0 4
49564: PPUSH
49565: LD_VAR 0 8
49569: PPUSH
49570: LD_VAR 0 9
49574: PUSH
49575: LD_VAR 0 10
49579: PLUS
49580: PPUSH
49581: CALL_OW 272
49585: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49586: LD_ADDR_VAR 0 7
49590: PUSH
49591: LD_VAR 0 6
49595: PPUSH
49596: LD_VAR 0 8
49600: PPUSH
49601: LD_VAR 0 9
49605: PUSH
49606: LD_VAR 0 10
49610: PLUS
49611: PPUSH
49612: CALL_OW 273
49616: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49617: LD_VAR 0 5
49621: PPUSH
49622: LD_VAR 0 7
49626: PPUSH
49627: CALL_OW 488
49631: PUSH
49632: LD_VAR 0 5
49636: PPUSH
49637: LD_VAR 0 7
49641: PPUSH
49642: CALL_OW 428
49646: PPUSH
49647: CALL_OW 247
49651: PUSH
49652: LD_INT 3
49654: PUSH
49655: LD_INT 2
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: IN
49662: NOT
49663: AND
49664: IFFALSE 49708
// begin ComMoveXY ( unit , _x , _y ) ;
49666: LD_VAR 0 1
49670: PPUSH
49671: LD_VAR 0 5
49675: PPUSH
49676: LD_VAR 0 7
49680: PPUSH
49681: CALL_OW 111
// result := [ _x , _y ] ;
49685: LD_ADDR_VAR 0 3
49689: PUSH
49690: LD_VAR 0 5
49694: PUSH
49695: LD_VAR 0 7
49699: PUSH
49700: EMPTY
49701: LIST
49702: LIST
49703: ST_TO_ADDR
// exit ;
49704: POP
49705: POP
49706: GO 49712
// end ; end ;
49708: GO 49552
49710: POP
49711: POP
// end ;
49712: LD_VAR 0 3
49716: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49717: LD_INT 0
49719: PPUSH
49720: PPUSH
49721: PPUSH
// result := 0 ;
49722: LD_ADDR_VAR 0 3
49726: PUSH
49727: LD_INT 0
49729: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49730: LD_VAR 0 1
49734: PUSH
49735: LD_INT 0
49737: LESS
49738: PUSH
49739: LD_VAR 0 1
49743: PUSH
49744: LD_INT 8
49746: GREATER
49747: OR
49748: PUSH
49749: LD_VAR 0 2
49753: PUSH
49754: LD_INT 0
49756: LESS
49757: OR
49758: PUSH
49759: LD_VAR 0 2
49763: PUSH
49764: LD_INT 8
49766: GREATER
49767: OR
49768: IFFALSE 49772
// exit ;
49770: GO 49847
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49772: LD_ADDR_VAR 0 4
49776: PUSH
49777: LD_INT 22
49779: PUSH
49780: LD_VAR 0 2
49784: PUSH
49785: EMPTY
49786: LIST
49787: LIST
49788: PPUSH
49789: CALL_OW 69
49793: PUSH
49794: FOR_IN
49795: IFFALSE 49845
// begin un := UnitShoot ( i ) ;
49797: LD_ADDR_VAR 0 5
49801: PUSH
49802: LD_VAR 0 4
49806: PPUSH
49807: CALL_OW 504
49811: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49812: LD_VAR 0 5
49816: PPUSH
49817: CALL_OW 255
49821: PUSH
49822: LD_VAR 0 1
49826: EQUAL
49827: IFFALSE 49843
// begin result := un ;
49829: LD_ADDR_VAR 0 3
49833: PUSH
49834: LD_VAR 0 5
49838: ST_TO_ADDR
// exit ;
49839: POP
49840: POP
49841: GO 49847
// end ; end ;
49843: GO 49794
49845: POP
49846: POP
// end ;
49847: LD_VAR 0 3
49851: RET
// export function GetCargoBay ( units ) ; begin
49852: LD_INT 0
49854: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49855: LD_ADDR_VAR 0 2
49859: PUSH
49860: LD_VAR 0 1
49864: PPUSH
49865: LD_INT 2
49867: PUSH
49868: LD_INT 34
49870: PUSH
49871: LD_INT 12
49873: PUSH
49874: EMPTY
49875: LIST
49876: LIST
49877: PUSH
49878: LD_INT 34
49880: PUSH
49881: LD_INT 51
49883: PUSH
49884: EMPTY
49885: LIST
49886: LIST
49887: PUSH
49888: LD_INT 34
49890: PUSH
49891: LD_INT 32
49893: PUSH
49894: EMPTY
49895: LIST
49896: LIST
49897: PUSH
49898: LD_INT 34
49900: PUSH
49901: LD_INT 89
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: PPUSH
49915: CALL_OW 72
49919: ST_TO_ADDR
// end ;
49920: LD_VAR 0 2
49924: RET
// export function Negate ( value ) ; begin
49925: LD_INT 0
49927: PPUSH
// result := not value ;
49928: LD_ADDR_VAR 0 2
49932: PUSH
49933: LD_VAR 0 1
49937: NOT
49938: ST_TO_ADDR
// end ;
49939: LD_VAR 0 2
49943: RET
// export function Inc ( value ) ; begin
49944: LD_INT 0
49946: PPUSH
// result := value + 1 ;
49947: LD_ADDR_VAR 0 2
49951: PUSH
49952: LD_VAR 0 1
49956: PUSH
49957: LD_INT 1
49959: PLUS
49960: ST_TO_ADDR
// end ;
49961: LD_VAR 0 2
49965: RET
// export function Dec ( value ) ; begin
49966: LD_INT 0
49968: PPUSH
// result := value - 1 ;
49969: LD_ADDR_VAR 0 2
49973: PUSH
49974: LD_VAR 0 1
49978: PUSH
49979: LD_INT 1
49981: MINUS
49982: ST_TO_ADDR
// end ;
49983: LD_VAR 0 2
49987: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49988: LD_INT 0
49990: PPUSH
49991: PPUSH
49992: PPUSH
49993: PPUSH
49994: PPUSH
49995: PPUSH
49996: PPUSH
49997: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49998: LD_VAR 0 1
50002: PPUSH
50003: LD_VAR 0 2
50007: PPUSH
50008: CALL_OW 488
50012: NOT
50013: PUSH
50014: LD_VAR 0 3
50018: PPUSH
50019: LD_VAR 0 4
50023: PPUSH
50024: CALL_OW 488
50028: NOT
50029: OR
50030: IFFALSE 50043
// begin result := - 1 ;
50032: LD_ADDR_VAR 0 5
50036: PUSH
50037: LD_INT 1
50039: NEG
50040: ST_TO_ADDR
// exit ;
50041: GO 50278
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
50043: LD_ADDR_VAR 0 12
50047: PUSH
50048: LD_VAR 0 1
50052: PPUSH
50053: LD_VAR 0 2
50057: PPUSH
50058: LD_VAR 0 3
50062: PPUSH
50063: LD_VAR 0 4
50067: PPUSH
50068: CALL 49128 0 4
50072: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
50073: LD_ADDR_VAR 0 11
50077: PUSH
50078: LD_VAR 0 1
50082: PPUSH
50083: LD_VAR 0 2
50087: PPUSH
50088: LD_VAR 0 12
50092: PUSH
50093: LD_INT 1
50095: ARRAY
50096: PPUSH
50097: LD_VAR 0 12
50101: PUSH
50102: LD_INT 2
50104: ARRAY
50105: PPUSH
50106: CALL_OW 298
50110: ST_TO_ADDR
// distance := 9999 ;
50111: LD_ADDR_VAR 0 10
50115: PUSH
50116: LD_INT 9999
50118: ST_TO_ADDR
// for i := 0 to 5 do
50119: LD_ADDR_VAR 0 6
50123: PUSH
50124: DOUBLE
50125: LD_INT 0
50127: DEC
50128: ST_TO_ADDR
50129: LD_INT 5
50131: PUSH
50132: FOR_TO
50133: IFFALSE 50276
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50135: LD_ADDR_VAR 0 7
50139: PUSH
50140: LD_VAR 0 1
50144: PPUSH
50145: LD_VAR 0 6
50149: PPUSH
50150: LD_VAR 0 11
50154: PPUSH
50155: CALL_OW 272
50159: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50160: LD_ADDR_VAR 0 8
50164: PUSH
50165: LD_VAR 0 2
50169: PPUSH
50170: LD_VAR 0 6
50174: PPUSH
50175: LD_VAR 0 11
50179: PPUSH
50180: CALL_OW 273
50184: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50185: LD_VAR 0 7
50189: PPUSH
50190: LD_VAR 0 8
50194: PPUSH
50195: CALL_OW 488
50199: NOT
50200: IFFALSE 50204
// continue ;
50202: GO 50132
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50204: LD_ADDR_VAR 0 9
50208: PUSH
50209: LD_VAR 0 12
50213: PUSH
50214: LD_INT 1
50216: ARRAY
50217: PPUSH
50218: LD_VAR 0 12
50222: PUSH
50223: LD_INT 2
50225: ARRAY
50226: PPUSH
50227: LD_VAR 0 7
50231: PPUSH
50232: LD_VAR 0 8
50236: PPUSH
50237: CALL_OW 298
50241: ST_TO_ADDR
// if tmp < distance then
50242: LD_VAR 0 9
50246: PUSH
50247: LD_VAR 0 10
50251: LESS
50252: IFFALSE 50274
// begin result := i ;
50254: LD_ADDR_VAR 0 5
50258: PUSH
50259: LD_VAR 0 6
50263: ST_TO_ADDR
// distance := tmp ;
50264: LD_ADDR_VAR 0 10
50268: PUSH
50269: LD_VAR 0 9
50273: ST_TO_ADDR
// end ; end ;
50274: GO 50132
50276: POP
50277: POP
// end ;
50278: LD_VAR 0 5
50282: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50283: LD_INT 0
50285: PPUSH
50286: PPUSH
// if not driver or not IsInUnit ( driver ) then
50287: LD_VAR 0 1
50291: NOT
50292: PUSH
50293: LD_VAR 0 1
50297: PPUSH
50298: CALL_OW 310
50302: NOT
50303: OR
50304: IFFALSE 50308
// exit ;
50306: GO 50398
// vehicle := IsInUnit ( driver ) ;
50308: LD_ADDR_VAR 0 3
50312: PUSH
50313: LD_VAR 0 1
50317: PPUSH
50318: CALL_OW 310
50322: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50323: LD_VAR 0 1
50327: PPUSH
50328: LD_STRING \
50330: PUSH
50331: LD_INT 0
50333: PUSH
50334: LD_INT 0
50336: PUSH
50337: LD_INT 0
50339: PUSH
50340: LD_INT 0
50342: PUSH
50343: LD_INT 0
50345: PUSH
50346: LD_INT 0
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: LIST
50353: LIST
50354: LIST
50355: LIST
50356: LIST
50357: PUSH
50358: LD_STRING E
50360: PUSH
50361: LD_INT 0
50363: PUSH
50364: LD_INT 0
50366: PUSH
50367: LD_VAR 0 3
50371: PUSH
50372: LD_INT 0
50374: PUSH
50375: LD_INT 0
50377: PUSH
50378: LD_INT 0
50380: PUSH
50381: EMPTY
50382: LIST
50383: LIST
50384: LIST
50385: LIST
50386: LIST
50387: LIST
50388: LIST
50389: PUSH
50390: EMPTY
50391: LIST
50392: LIST
50393: PPUSH
50394: CALL_OW 446
// end ;
50398: LD_VAR 0 2
50402: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50403: LD_INT 0
50405: PPUSH
50406: PPUSH
// if not driver or not IsInUnit ( driver ) then
50407: LD_VAR 0 1
50411: NOT
50412: PUSH
50413: LD_VAR 0 1
50417: PPUSH
50418: CALL_OW 310
50422: NOT
50423: OR
50424: IFFALSE 50428
// exit ;
50426: GO 50518
// vehicle := IsInUnit ( driver ) ;
50428: LD_ADDR_VAR 0 3
50432: PUSH
50433: LD_VAR 0 1
50437: PPUSH
50438: CALL_OW 310
50442: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50443: LD_VAR 0 1
50447: PPUSH
50448: LD_STRING \
50450: PUSH
50451: LD_INT 0
50453: PUSH
50454: LD_INT 0
50456: PUSH
50457: LD_INT 0
50459: PUSH
50460: LD_INT 0
50462: PUSH
50463: LD_INT 0
50465: PUSH
50466: LD_INT 0
50468: PUSH
50469: EMPTY
50470: LIST
50471: LIST
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: PUSH
50478: LD_STRING E
50480: PUSH
50481: LD_INT 0
50483: PUSH
50484: LD_INT 0
50486: PUSH
50487: LD_VAR 0 3
50491: PUSH
50492: LD_INT 0
50494: PUSH
50495: LD_INT 0
50497: PUSH
50498: LD_INT 0
50500: PUSH
50501: EMPTY
50502: LIST
50503: LIST
50504: LIST
50505: LIST
50506: LIST
50507: LIST
50508: LIST
50509: PUSH
50510: EMPTY
50511: LIST
50512: LIST
50513: PPUSH
50514: CALL_OW 447
// end ;
50518: LD_VAR 0 2
50522: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50523: LD_INT 0
50525: PPUSH
50526: PPUSH
50527: PPUSH
// tmp := [ ] ;
50528: LD_ADDR_VAR 0 5
50532: PUSH
50533: EMPTY
50534: ST_TO_ADDR
// for i in units do
50535: LD_ADDR_VAR 0 4
50539: PUSH
50540: LD_VAR 0 1
50544: PUSH
50545: FOR_IN
50546: IFFALSE 50584
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50548: LD_ADDR_VAR 0 5
50552: PUSH
50553: LD_VAR 0 5
50557: PPUSH
50558: LD_VAR 0 5
50562: PUSH
50563: LD_INT 1
50565: PLUS
50566: PPUSH
50567: LD_VAR 0 4
50571: PPUSH
50572: CALL_OW 256
50576: PPUSH
50577: CALL_OW 2
50581: ST_TO_ADDR
50582: GO 50545
50584: POP
50585: POP
// if not tmp then
50586: LD_VAR 0 5
50590: NOT
50591: IFFALSE 50595
// exit ;
50593: GO 50643
// if asc then
50595: LD_VAR 0 2
50599: IFFALSE 50623
// result := SortListByListAsc ( units , tmp ) else
50601: LD_ADDR_VAR 0 3
50605: PUSH
50606: LD_VAR 0 1
50610: PPUSH
50611: LD_VAR 0 5
50615: PPUSH
50616: CALL_OW 76
50620: ST_TO_ADDR
50621: GO 50643
// result := SortListByListDesc ( units , tmp ) ;
50623: LD_ADDR_VAR 0 3
50627: PUSH
50628: LD_VAR 0 1
50632: PPUSH
50633: LD_VAR 0 5
50637: PPUSH
50638: CALL_OW 77
50642: ST_TO_ADDR
// end ;
50643: LD_VAR 0 3
50647: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50648: LD_INT 0
50650: PPUSH
50651: PPUSH
// task := GetTaskList ( mech ) ;
50652: LD_ADDR_VAR 0 4
50656: PUSH
50657: LD_VAR 0 1
50661: PPUSH
50662: CALL_OW 437
50666: ST_TO_ADDR
// if not task then
50667: LD_VAR 0 4
50671: NOT
50672: IFFALSE 50676
// exit ;
50674: GO 50718
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50676: LD_ADDR_VAR 0 3
50680: PUSH
50681: LD_VAR 0 4
50685: PUSH
50686: LD_INT 1
50688: ARRAY
50689: PUSH
50690: LD_INT 1
50692: ARRAY
50693: PUSH
50694: LD_STRING r
50696: EQUAL
50697: PUSH
50698: LD_VAR 0 4
50702: PUSH
50703: LD_INT 1
50705: ARRAY
50706: PUSH
50707: LD_INT 4
50709: ARRAY
50710: PUSH
50711: LD_VAR 0 2
50715: EQUAL
50716: AND
50717: ST_TO_ADDR
// end ;
50718: LD_VAR 0 3
50722: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50723: LD_INT 0
50725: PPUSH
// SetDir ( unit , d ) ;
50726: LD_VAR 0 1
50730: PPUSH
50731: LD_VAR 0 4
50735: PPUSH
50736: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50740: LD_VAR 0 1
50744: PPUSH
50745: LD_VAR 0 2
50749: PPUSH
50750: LD_VAR 0 3
50754: PPUSH
50755: LD_VAR 0 5
50759: PPUSH
50760: CALL_OW 48
// end ;
50764: LD_VAR 0 6
50768: RET
// export function ToNaturalNumber ( number ) ; begin
50769: LD_INT 0
50771: PPUSH
// result := number div 1 ;
50772: LD_ADDR_VAR 0 2
50776: PUSH
50777: LD_VAR 0 1
50781: PUSH
50782: LD_INT 1
50784: DIV
50785: ST_TO_ADDR
// if number < 0 then
50786: LD_VAR 0 1
50790: PUSH
50791: LD_INT 0
50793: LESS
50794: IFFALSE 50804
// result := 0 ;
50796: LD_ADDR_VAR 0 2
50800: PUSH
50801: LD_INT 0
50803: ST_TO_ADDR
// end ;
50804: LD_VAR 0 2
50808: RET
// export function SortByClass ( units , class ) ; var un ; begin
50809: LD_INT 0
50811: PPUSH
50812: PPUSH
// if not units or not class then
50813: LD_VAR 0 1
50817: NOT
50818: PUSH
50819: LD_VAR 0 2
50823: NOT
50824: OR
50825: IFFALSE 50829
// exit ;
50827: GO 50924
// result := [ ] ;
50829: LD_ADDR_VAR 0 3
50833: PUSH
50834: EMPTY
50835: ST_TO_ADDR
// for un in units do
50836: LD_ADDR_VAR 0 4
50840: PUSH
50841: LD_VAR 0 1
50845: PUSH
50846: FOR_IN
50847: IFFALSE 50922
// if GetClass ( un ) = class then
50849: LD_VAR 0 4
50853: PPUSH
50854: CALL_OW 257
50858: PUSH
50859: LD_VAR 0 2
50863: EQUAL
50864: IFFALSE 50891
// result := Insert ( result , 1 , un ) else
50866: LD_ADDR_VAR 0 3
50870: PUSH
50871: LD_VAR 0 3
50875: PPUSH
50876: LD_INT 1
50878: PPUSH
50879: LD_VAR 0 4
50883: PPUSH
50884: CALL_OW 2
50888: ST_TO_ADDR
50889: GO 50920
// result := Replace ( result , result + 1 , un ) ;
50891: LD_ADDR_VAR 0 3
50895: PUSH
50896: LD_VAR 0 3
50900: PPUSH
50901: LD_VAR 0 3
50905: PUSH
50906: LD_INT 1
50908: PLUS
50909: PPUSH
50910: LD_VAR 0 4
50914: PPUSH
50915: CALL_OW 1
50919: ST_TO_ADDR
50920: GO 50846
50922: POP
50923: POP
// end ;
50924: LD_VAR 0 3
50928: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50929: LD_INT 0
50931: PPUSH
50932: PPUSH
50933: PPUSH
50934: PPUSH
50935: PPUSH
50936: PPUSH
50937: PPUSH
// result := [ ] ;
50938: LD_ADDR_VAR 0 4
50942: PUSH
50943: EMPTY
50944: ST_TO_ADDR
// if x - r < 0 then
50945: LD_VAR 0 1
50949: PUSH
50950: LD_VAR 0 3
50954: MINUS
50955: PUSH
50956: LD_INT 0
50958: LESS
50959: IFFALSE 50971
// min_x := 0 else
50961: LD_ADDR_VAR 0 8
50965: PUSH
50966: LD_INT 0
50968: ST_TO_ADDR
50969: GO 50987
// min_x := x - r ;
50971: LD_ADDR_VAR 0 8
50975: PUSH
50976: LD_VAR 0 1
50980: PUSH
50981: LD_VAR 0 3
50985: MINUS
50986: ST_TO_ADDR
// if y - r < 0 then
50987: LD_VAR 0 2
50991: PUSH
50992: LD_VAR 0 3
50996: MINUS
50997: PUSH
50998: LD_INT 0
51000: LESS
51001: IFFALSE 51013
// min_y := 0 else
51003: LD_ADDR_VAR 0 7
51007: PUSH
51008: LD_INT 0
51010: ST_TO_ADDR
51011: GO 51029
// min_y := y - r ;
51013: LD_ADDR_VAR 0 7
51017: PUSH
51018: LD_VAR 0 2
51022: PUSH
51023: LD_VAR 0 3
51027: MINUS
51028: ST_TO_ADDR
// max_x := x + r ;
51029: LD_ADDR_VAR 0 9
51033: PUSH
51034: LD_VAR 0 1
51038: PUSH
51039: LD_VAR 0 3
51043: PLUS
51044: ST_TO_ADDR
// max_y := y + r ;
51045: LD_ADDR_VAR 0 10
51049: PUSH
51050: LD_VAR 0 2
51054: PUSH
51055: LD_VAR 0 3
51059: PLUS
51060: ST_TO_ADDR
// for _x = min_x to max_x do
51061: LD_ADDR_VAR 0 5
51065: PUSH
51066: DOUBLE
51067: LD_VAR 0 8
51071: DEC
51072: ST_TO_ADDR
51073: LD_VAR 0 9
51077: PUSH
51078: FOR_TO
51079: IFFALSE 51180
// for _y = min_y to max_y do
51081: LD_ADDR_VAR 0 6
51085: PUSH
51086: DOUBLE
51087: LD_VAR 0 7
51091: DEC
51092: ST_TO_ADDR
51093: LD_VAR 0 10
51097: PUSH
51098: FOR_TO
51099: IFFALSE 51176
// begin if not ValidHex ( _x , _y ) then
51101: LD_VAR 0 5
51105: PPUSH
51106: LD_VAR 0 6
51110: PPUSH
51111: CALL_OW 488
51115: NOT
51116: IFFALSE 51120
// continue ;
51118: GO 51098
// if GetResourceTypeXY ( _x , _y ) then
51120: LD_VAR 0 5
51124: PPUSH
51125: LD_VAR 0 6
51129: PPUSH
51130: CALL_OW 283
51134: IFFALSE 51174
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
51136: LD_ADDR_VAR 0 4
51140: PUSH
51141: LD_VAR 0 4
51145: PPUSH
51146: LD_VAR 0 4
51150: PUSH
51151: LD_INT 1
51153: PLUS
51154: PPUSH
51155: LD_VAR 0 5
51159: PUSH
51160: LD_VAR 0 6
51164: PUSH
51165: EMPTY
51166: LIST
51167: LIST
51168: PPUSH
51169: CALL_OW 1
51173: ST_TO_ADDR
// end ;
51174: GO 51098
51176: POP
51177: POP
51178: GO 51078
51180: POP
51181: POP
// end ;
51182: LD_VAR 0 4
51186: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51187: LD_INT 0
51189: PPUSH
51190: PPUSH
51191: PPUSH
51192: PPUSH
51193: PPUSH
51194: PPUSH
51195: PPUSH
51196: PPUSH
// if not units then
51197: LD_VAR 0 1
51201: NOT
51202: IFFALSE 51206
// exit ;
51204: GO 51730
// result := UnitFilter ( units , [ f_ok ] ) ;
51206: LD_ADDR_VAR 0 3
51210: PUSH
51211: LD_VAR 0 1
51215: PPUSH
51216: LD_INT 50
51218: PUSH
51219: EMPTY
51220: LIST
51221: PPUSH
51222: CALL_OW 72
51226: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51227: LD_ADDR_VAR 0 8
51231: PUSH
51232: LD_VAR 0 1
51236: PUSH
51237: LD_INT 1
51239: ARRAY
51240: PPUSH
51241: CALL_OW 255
51245: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51246: LD_ADDR_VAR 0 10
51250: PUSH
51251: LD_INT 29
51253: PUSH
51254: LD_INT 91
51256: PUSH
51257: LD_INT 49
51259: PUSH
51260: EMPTY
51261: LIST
51262: LIST
51263: LIST
51264: ST_TO_ADDR
// if not result then
51265: LD_VAR 0 3
51269: NOT
51270: IFFALSE 51274
// exit ;
51272: GO 51730
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51274: LD_ADDR_VAR 0 5
51278: PUSH
51279: LD_INT 81
51281: PUSH
51282: LD_VAR 0 8
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: PPUSH
51291: CALL_OW 69
51295: ST_TO_ADDR
// for i in result do
51296: LD_ADDR_VAR 0 4
51300: PUSH
51301: LD_VAR 0 3
51305: PUSH
51306: FOR_IN
51307: IFFALSE 51728
// begin tag := GetTag ( i ) + 1 ;
51309: LD_ADDR_VAR 0 9
51313: PUSH
51314: LD_VAR 0 4
51318: PPUSH
51319: CALL_OW 110
51323: PUSH
51324: LD_INT 1
51326: PLUS
51327: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51328: LD_ADDR_VAR 0 7
51332: PUSH
51333: LD_VAR 0 4
51337: PPUSH
51338: CALL_OW 250
51342: PPUSH
51343: LD_VAR 0 4
51347: PPUSH
51348: CALL_OW 251
51352: PPUSH
51353: LD_INT 6
51355: PPUSH
51356: CALL 50929 0 3
51360: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51361: LD_VAR 0 4
51365: PPUSH
51366: CALL_OW 247
51370: PUSH
51371: LD_INT 2
51373: EQUAL
51374: PUSH
51375: LD_VAR 0 7
51379: AND
51380: PUSH
51381: LD_VAR 0 4
51385: PPUSH
51386: CALL_OW 264
51390: PUSH
51391: LD_VAR 0 10
51395: IN
51396: NOT
51397: AND
51398: IFFALSE 51437
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51400: LD_VAR 0 4
51404: PPUSH
51405: LD_VAR 0 7
51409: PUSH
51410: LD_INT 1
51412: ARRAY
51413: PUSH
51414: LD_INT 1
51416: ARRAY
51417: PPUSH
51418: LD_VAR 0 7
51422: PUSH
51423: LD_INT 1
51425: ARRAY
51426: PUSH
51427: LD_INT 2
51429: ARRAY
51430: PPUSH
51431: CALL_OW 116
51435: GO 51726
// if path > tag then
51437: LD_VAR 0 2
51441: PUSH
51442: LD_VAR 0 9
51446: GREATER
51447: IFFALSE 51655
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51449: LD_ADDR_VAR 0 6
51453: PUSH
51454: LD_VAR 0 5
51458: PPUSH
51459: LD_INT 91
51461: PUSH
51462: LD_VAR 0 4
51466: PUSH
51467: LD_INT 8
51469: PUSH
51470: EMPTY
51471: LIST
51472: LIST
51473: LIST
51474: PPUSH
51475: CALL_OW 72
51479: ST_TO_ADDR
// if nearEnemy then
51480: LD_VAR 0 6
51484: IFFALSE 51553
// begin if GetWeapon ( i ) = ru_time_lapser then
51486: LD_VAR 0 4
51490: PPUSH
51491: CALL_OW 264
51495: PUSH
51496: LD_INT 49
51498: EQUAL
51499: IFFALSE 51527
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51501: LD_VAR 0 4
51505: PPUSH
51506: LD_VAR 0 6
51510: PPUSH
51511: LD_VAR 0 4
51515: PPUSH
51516: CALL_OW 74
51520: PPUSH
51521: CALL_OW 112
51525: GO 51551
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51527: LD_VAR 0 4
51531: PPUSH
51532: LD_VAR 0 6
51536: PPUSH
51537: LD_VAR 0 4
51541: PPUSH
51542: CALL_OW 74
51546: PPUSH
51547: CALL_OW 115
// end else
51551: GO 51653
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51553: LD_VAR 0 4
51557: PPUSH
51558: LD_VAR 0 2
51562: PUSH
51563: LD_VAR 0 9
51567: ARRAY
51568: PUSH
51569: LD_INT 1
51571: ARRAY
51572: PPUSH
51573: LD_VAR 0 2
51577: PUSH
51578: LD_VAR 0 9
51582: ARRAY
51583: PUSH
51584: LD_INT 2
51586: ARRAY
51587: PPUSH
51588: CALL_OW 297
51592: PUSH
51593: LD_INT 6
51595: GREATER
51596: IFFALSE 51639
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51598: LD_VAR 0 4
51602: PPUSH
51603: LD_VAR 0 2
51607: PUSH
51608: LD_VAR 0 9
51612: ARRAY
51613: PUSH
51614: LD_INT 1
51616: ARRAY
51617: PPUSH
51618: LD_VAR 0 2
51622: PUSH
51623: LD_VAR 0 9
51627: ARRAY
51628: PUSH
51629: LD_INT 2
51631: ARRAY
51632: PPUSH
51633: CALL_OW 114
51637: GO 51653
// SetTag ( i , tag ) ;
51639: LD_VAR 0 4
51643: PPUSH
51644: LD_VAR 0 9
51648: PPUSH
51649: CALL_OW 109
// end else
51653: GO 51726
// if enemy then
51655: LD_VAR 0 5
51659: IFFALSE 51726
// begin if GetWeapon ( i ) = ru_time_lapser then
51661: LD_VAR 0 4
51665: PPUSH
51666: CALL_OW 264
51670: PUSH
51671: LD_INT 49
51673: EQUAL
51674: IFFALSE 51702
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51676: LD_VAR 0 4
51680: PPUSH
51681: LD_VAR 0 5
51685: PPUSH
51686: LD_VAR 0 4
51690: PPUSH
51691: CALL_OW 74
51695: PPUSH
51696: CALL_OW 112
51700: GO 51726
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51702: LD_VAR 0 4
51706: PPUSH
51707: LD_VAR 0 5
51711: PPUSH
51712: LD_VAR 0 4
51716: PPUSH
51717: CALL_OW 74
51721: PPUSH
51722: CALL_OW 115
// end ; end ;
51726: GO 51306
51728: POP
51729: POP
// end ;
51730: LD_VAR 0 3
51734: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51735: LD_INT 0
51737: PPUSH
51738: PPUSH
51739: PPUSH
// if not unit or IsInUnit ( unit ) then
51740: LD_VAR 0 1
51744: NOT
51745: PUSH
51746: LD_VAR 0 1
51750: PPUSH
51751: CALL_OW 310
51755: OR
51756: IFFALSE 51760
// exit ;
51758: GO 51851
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51760: LD_ADDR_VAR 0 4
51764: PUSH
51765: LD_VAR 0 1
51769: PPUSH
51770: CALL_OW 250
51774: PPUSH
51775: LD_VAR 0 2
51779: PPUSH
51780: LD_INT 1
51782: PPUSH
51783: CALL_OW 272
51787: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51788: LD_ADDR_VAR 0 5
51792: PUSH
51793: LD_VAR 0 1
51797: PPUSH
51798: CALL_OW 251
51802: PPUSH
51803: LD_VAR 0 2
51807: PPUSH
51808: LD_INT 1
51810: PPUSH
51811: CALL_OW 273
51815: ST_TO_ADDR
// if ValidHex ( x , y ) then
51816: LD_VAR 0 4
51820: PPUSH
51821: LD_VAR 0 5
51825: PPUSH
51826: CALL_OW 488
51830: IFFALSE 51851
// ComTurnXY ( unit , x , y ) ;
51832: LD_VAR 0 1
51836: PPUSH
51837: LD_VAR 0 4
51841: PPUSH
51842: LD_VAR 0 5
51846: PPUSH
51847: CALL_OW 118
// end ;
51851: LD_VAR 0 3
51855: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51856: LD_INT 0
51858: PPUSH
51859: PPUSH
// result := false ;
51860: LD_ADDR_VAR 0 3
51864: PUSH
51865: LD_INT 0
51867: ST_TO_ADDR
// if not units then
51868: LD_VAR 0 2
51872: NOT
51873: IFFALSE 51877
// exit ;
51875: GO 51922
// for i in units do
51877: LD_ADDR_VAR 0 4
51881: PUSH
51882: LD_VAR 0 2
51886: PUSH
51887: FOR_IN
51888: IFFALSE 51920
// if See ( side , i ) then
51890: LD_VAR 0 1
51894: PPUSH
51895: LD_VAR 0 4
51899: PPUSH
51900: CALL_OW 292
51904: IFFALSE 51918
// begin result := true ;
51906: LD_ADDR_VAR 0 3
51910: PUSH
51911: LD_INT 1
51913: ST_TO_ADDR
// exit ;
51914: POP
51915: POP
51916: GO 51922
// end ;
51918: GO 51887
51920: POP
51921: POP
// end ;
51922: LD_VAR 0 3
51926: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51927: LD_INT 0
51929: PPUSH
51930: PPUSH
51931: PPUSH
51932: PPUSH
// if not unit or not points then
51933: LD_VAR 0 1
51937: NOT
51938: PUSH
51939: LD_VAR 0 2
51943: NOT
51944: OR
51945: IFFALSE 51949
// exit ;
51947: GO 52039
// dist := 99999 ;
51949: LD_ADDR_VAR 0 5
51953: PUSH
51954: LD_INT 99999
51956: ST_TO_ADDR
// for i in points do
51957: LD_ADDR_VAR 0 4
51961: PUSH
51962: LD_VAR 0 2
51966: PUSH
51967: FOR_IN
51968: IFFALSE 52037
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51970: LD_ADDR_VAR 0 6
51974: PUSH
51975: LD_VAR 0 1
51979: PPUSH
51980: LD_VAR 0 4
51984: PUSH
51985: LD_INT 1
51987: ARRAY
51988: PPUSH
51989: LD_VAR 0 4
51993: PUSH
51994: LD_INT 2
51996: ARRAY
51997: PPUSH
51998: CALL_OW 297
52002: ST_TO_ADDR
// if tmpDist < dist then
52003: LD_VAR 0 6
52007: PUSH
52008: LD_VAR 0 5
52012: LESS
52013: IFFALSE 52035
// begin result := i ;
52015: LD_ADDR_VAR 0 3
52019: PUSH
52020: LD_VAR 0 4
52024: ST_TO_ADDR
// dist := tmpDist ;
52025: LD_ADDR_VAR 0 5
52029: PUSH
52030: LD_VAR 0 6
52034: ST_TO_ADDR
// end ; end ;
52035: GO 51967
52037: POP
52038: POP
// end ;
52039: LD_VAR 0 3
52043: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
52044: LD_INT 0
52046: PPUSH
// uc_side := side ;
52047: LD_ADDR_OWVAR 20
52051: PUSH
52052: LD_VAR 0 1
52056: ST_TO_ADDR
// uc_nation := 3 ;
52057: LD_ADDR_OWVAR 21
52061: PUSH
52062: LD_INT 3
52064: ST_TO_ADDR
// vc_chassis := 25 ;
52065: LD_ADDR_OWVAR 37
52069: PUSH
52070: LD_INT 25
52072: ST_TO_ADDR
// vc_engine := engine_siberite ;
52073: LD_ADDR_OWVAR 39
52077: PUSH
52078: LD_INT 3
52080: ST_TO_ADDR
// vc_control := control_computer ;
52081: LD_ADDR_OWVAR 38
52085: PUSH
52086: LD_INT 3
52088: ST_TO_ADDR
// vc_weapon := 59 ;
52089: LD_ADDR_OWVAR 40
52093: PUSH
52094: LD_INT 59
52096: ST_TO_ADDR
// result := CreateVehicle ;
52097: LD_ADDR_VAR 0 5
52101: PUSH
52102: CALL_OW 45
52106: ST_TO_ADDR
// SetDir ( result , d ) ;
52107: LD_VAR 0 5
52111: PPUSH
52112: LD_VAR 0 4
52116: PPUSH
52117: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
52121: LD_VAR 0 5
52125: PPUSH
52126: LD_VAR 0 2
52130: PPUSH
52131: LD_VAR 0 3
52135: PPUSH
52136: LD_INT 0
52138: PPUSH
52139: CALL_OW 48
// end ;
52143: LD_VAR 0 5
52147: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52148: LD_INT 0
52150: PPUSH
52151: PPUSH
52152: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52153: LD_ADDR_VAR 0 2
52157: PUSH
52158: LD_INT 0
52160: PUSH
52161: LD_INT 0
52163: PUSH
52164: LD_INT 0
52166: PUSH
52167: LD_INT 0
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52176: LD_VAR 0 1
52180: NOT
52181: PUSH
52182: LD_VAR 0 1
52186: PPUSH
52187: CALL_OW 264
52191: PUSH
52192: LD_INT 12
52194: PUSH
52195: LD_INT 51
52197: PUSH
52198: LD_INT 32
52200: PUSH
52201: LD_INT 89
52203: PUSH
52204: EMPTY
52205: LIST
52206: LIST
52207: LIST
52208: LIST
52209: IN
52210: NOT
52211: OR
52212: IFFALSE 52216
// exit ;
52214: GO 52314
// for i := 1 to 3 do
52216: LD_ADDR_VAR 0 3
52220: PUSH
52221: DOUBLE
52222: LD_INT 1
52224: DEC
52225: ST_TO_ADDR
52226: LD_INT 3
52228: PUSH
52229: FOR_TO
52230: IFFALSE 52312
// begin tmp := GetCargo ( cargo , i ) ;
52232: LD_ADDR_VAR 0 4
52236: PUSH
52237: LD_VAR 0 1
52241: PPUSH
52242: LD_VAR 0 3
52246: PPUSH
52247: CALL_OW 289
52251: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52252: LD_ADDR_VAR 0 2
52256: PUSH
52257: LD_VAR 0 2
52261: PPUSH
52262: LD_VAR 0 3
52266: PPUSH
52267: LD_VAR 0 4
52271: PPUSH
52272: CALL_OW 1
52276: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52277: LD_ADDR_VAR 0 2
52281: PUSH
52282: LD_VAR 0 2
52286: PPUSH
52287: LD_INT 4
52289: PPUSH
52290: LD_VAR 0 2
52294: PUSH
52295: LD_INT 4
52297: ARRAY
52298: PUSH
52299: LD_VAR 0 4
52303: PLUS
52304: PPUSH
52305: CALL_OW 1
52309: ST_TO_ADDR
// end ;
52310: GO 52229
52312: POP
52313: POP
// end ;
52314: LD_VAR 0 2
52318: RET
// export function Length ( array ) ; begin
52319: LD_INT 0
52321: PPUSH
// result := array + 0 ;
52322: LD_ADDR_VAR 0 2
52326: PUSH
52327: LD_VAR 0 1
52331: PUSH
52332: LD_INT 0
52334: PLUS
52335: ST_TO_ADDR
// end ;
52336: LD_VAR 0 2
52340: RET
// export function PrepareArray ( array ) ; begin
52341: LD_INT 0
52343: PPUSH
// result := array diff 0 ;
52344: LD_ADDR_VAR 0 2
52348: PUSH
52349: LD_VAR 0 1
52353: PUSH
52354: LD_INT 0
52356: DIFF
52357: ST_TO_ADDR
// if not result [ 1 ] then
52358: LD_VAR 0 2
52362: PUSH
52363: LD_INT 1
52365: ARRAY
52366: NOT
52367: IFFALSE 52387
// result := Delete ( result , 1 ) ;
52369: LD_ADDR_VAR 0 2
52373: PUSH
52374: LD_VAR 0 2
52378: PPUSH
52379: LD_INT 1
52381: PPUSH
52382: CALL_OW 3
52386: ST_TO_ADDR
// end ;
52387: LD_VAR 0 2
52391: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52392: LD_INT 0
52394: PPUSH
52395: PPUSH
52396: PPUSH
52397: PPUSH
// sibRocketRange := 25 ;
52398: LD_ADDR_VAR 0 6
52402: PUSH
52403: LD_INT 25
52405: ST_TO_ADDR
// result := false ;
52406: LD_ADDR_VAR 0 4
52410: PUSH
52411: LD_INT 0
52413: ST_TO_ADDR
// for i := 0 to 5 do
52414: LD_ADDR_VAR 0 5
52418: PUSH
52419: DOUBLE
52420: LD_INT 0
52422: DEC
52423: ST_TO_ADDR
52424: LD_INT 5
52426: PUSH
52427: FOR_TO
52428: IFFALSE 52495
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52430: LD_VAR 0 1
52434: PPUSH
52435: LD_VAR 0 5
52439: PPUSH
52440: LD_VAR 0 6
52444: PPUSH
52445: CALL_OW 272
52449: PPUSH
52450: LD_VAR 0 2
52454: PPUSH
52455: LD_VAR 0 5
52459: PPUSH
52460: LD_VAR 0 6
52464: PPUSH
52465: CALL_OW 273
52469: PPUSH
52470: LD_VAR 0 3
52474: PPUSH
52475: CALL_OW 309
52479: IFFALSE 52493
// begin result := true ;
52481: LD_ADDR_VAR 0 4
52485: PUSH
52486: LD_INT 1
52488: ST_TO_ADDR
// exit ;
52489: POP
52490: POP
52491: GO 52497
// end ;
52493: GO 52427
52495: POP
52496: POP
// end ;
52497: LD_VAR 0 4
52501: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52502: LD_INT 0
52504: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52505: LD_VAR 0 1
52509: PPUSH
52510: LD_VAR 0 2
52514: PPUSH
52515: LD_INT 0
52517: PPUSH
52518: LD_INT 0
52520: PPUSH
52521: LD_INT 1
52523: PPUSH
52524: LD_INT 0
52526: PPUSH
52527: CALL_OW 587
// end ; end_of_file
52531: LD_VAR 0 3
52535: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
52536: LD_INT 0
52538: PPUSH
52539: PPUSH
// skirmish := false ;
52540: LD_ADDR_EXP 21
52544: PUSH
52545: LD_INT 0
52547: ST_TO_ADDR
// debug_mc := false ;
52548: LD_ADDR_EXP 22
52552: PUSH
52553: LD_INT 0
52555: ST_TO_ADDR
// mc_bases := [ ] ;
52556: LD_ADDR_EXP 23
52560: PUSH
52561: EMPTY
52562: ST_TO_ADDR
// mc_sides := [ ] ;
52563: LD_ADDR_EXP 49
52567: PUSH
52568: EMPTY
52569: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52570: LD_ADDR_EXP 24
52574: PUSH
52575: EMPTY
52576: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52577: LD_ADDR_EXP 25
52581: PUSH
52582: EMPTY
52583: ST_TO_ADDR
// mc_need_heal := [ ] ;
52584: LD_ADDR_EXP 26
52588: PUSH
52589: EMPTY
52590: ST_TO_ADDR
// mc_healers := [ ] ;
52591: LD_ADDR_EXP 27
52595: PUSH
52596: EMPTY
52597: ST_TO_ADDR
// mc_build_list := [ ] ;
52598: LD_ADDR_EXP 28
52602: PUSH
52603: EMPTY
52604: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52605: LD_ADDR_EXP 55
52609: PUSH
52610: EMPTY
52611: ST_TO_ADDR
// mc_builders := [ ] ;
52612: LD_ADDR_EXP 29
52616: PUSH
52617: EMPTY
52618: ST_TO_ADDR
// mc_construct_list := [ ] ;
52619: LD_ADDR_EXP 30
52623: PUSH
52624: EMPTY
52625: ST_TO_ADDR
// mc_turret_list := [ ] ;
52626: LD_ADDR_EXP 31
52630: PUSH
52631: EMPTY
52632: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52633: LD_ADDR_EXP 32
52637: PUSH
52638: EMPTY
52639: ST_TO_ADDR
// mc_miners := [ ] ;
52640: LD_ADDR_EXP 37
52644: PUSH
52645: EMPTY
52646: ST_TO_ADDR
// mc_mines := [ ] ;
52647: LD_ADDR_EXP 36
52651: PUSH
52652: EMPTY
52653: ST_TO_ADDR
// mc_minefields := [ ] ;
52654: LD_ADDR_EXP 38
52658: PUSH
52659: EMPTY
52660: ST_TO_ADDR
// mc_crates := [ ] ;
52661: LD_ADDR_EXP 39
52665: PUSH
52666: EMPTY
52667: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52668: LD_ADDR_EXP 40
52672: PUSH
52673: EMPTY
52674: ST_TO_ADDR
// mc_crates_area := [ ] ;
52675: LD_ADDR_EXP 41
52679: PUSH
52680: EMPTY
52681: ST_TO_ADDR
// mc_vehicles := [ ] ;
52682: LD_ADDR_EXP 42
52686: PUSH
52687: EMPTY
52688: ST_TO_ADDR
// mc_attack := [ ] ;
52689: LD_ADDR_EXP 43
52693: PUSH
52694: EMPTY
52695: ST_TO_ADDR
// mc_produce := [ ] ;
52696: LD_ADDR_EXP 44
52700: PUSH
52701: EMPTY
52702: ST_TO_ADDR
// mc_defender := [ ] ;
52703: LD_ADDR_EXP 45
52707: PUSH
52708: EMPTY
52709: ST_TO_ADDR
// mc_parking := [ ] ;
52710: LD_ADDR_EXP 47
52714: PUSH
52715: EMPTY
52716: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52717: LD_ADDR_EXP 33
52721: PUSH
52722: EMPTY
52723: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52724: LD_ADDR_EXP 35
52728: PUSH
52729: EMPTY
52730: ST_TO_ADDR
// mc_scan := [ ] ;
52731: LD_ADDR_EXP 46
52735: PUSH
52736: EMPTY
52737: ST_TO_ADDR
// mc_scan_area := [ ] ;
52738: LD_ADDR_EXP 48
52742: PUSH
52743: EMPTY
52744: ST_TO_ADDR
// mc_tech := [ ] ;
52745: LD_ADDR_EXP 50
52749: PUSH
52750: EMPTY
52751: ST_TO_ADDR
// mc_class := [ ] ;
52752: LD_ADDR_EXP 64
52756: PUSH
52757: EMPTY
52758: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52759: LD_ADDR_EXP 65
52763: PUSH
52764: EMPTY
52765: ST_TO_ADDR
// mc_is_defending := [ ] ;
52766: LD_ADDR_EXP 66
52770: PUSH
52771: EMPTY
52772: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52773: LD_ADDR_EXP 57
52777: PUSH
52778: EMPTY
52779: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
52780: LD_ADDR_EXP 67
52784: PUSH
52785: LD_INT 0
52787: ST_TO_ADDR
// end ;
52788: LD_VAR 0 1
52792: RET
// export function MC_Kill ( base ) ; begin
52793: LD_INT 0
52795: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52796: LD_ADDR_EXP 23
52800: PUSH
52801: LD_EXP 23
52805: PPUSH
52806: LD_VAR 0 1
52810: PPUSH
52811: EMPTY
52812: PPUSH
52813: CALL_OW 1
52817: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52818: LD_ADDR_EXP 24
52822: PUSH
52823: LD_EXP 24
52827: PPUSH
52828: LD_VAR 0 1
52832: PPUSH
52833: EMPTY
52834: PPUSH
52835: CALL_OW 1
52839: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52840: LD_ADDR_EXP 25
52844: PUSH
52845: LD_EXP 25
52849: PPUSH
52850: LD_VAR 0 1
52854: PPUSH
52855: EMPTY
52856: PPUSH
52857: CALL_OW 1
52861: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52862: LD_ADDR_EXP 26
52866: PUSH
52867: LD_EXP 26
52871: PPUSH
52872: LD_VAR 0 1
52876: PPUSH
52877: EMPTY
52878: PPUSH
52879: CALL_OW 1
52883: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52884: LD_ADDR_EXP 27
52888: PUSH
52889: LD_EXP 27
52893: PPUSH
52894: LD_VAR 0 1
52898: PPUSH
52899: EMPTY
52900: PPUSH
52901: CALL_OW 1
52905: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52906: LD_ADDR_EXP 28
52910: PUSH
52911: LD_EXP 28
52915: PPUSH
52916: LD_VAR 0 1
52920: PPUSH
52921: EMPTY
52922: PPUSH
52923: CALL_OW 1
52927: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52928: LD_ADDR_EXP 29
52932: PUSH
52933: LD_EXP 29
52937: PPUSH
52938: LD_VAR 0 1
52942: PPUSH
52943: EMPTY
52944: PPUSH
52945: CALL_OW 1
52949: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52950: LD_ADDR_EXP 30
52954: PUSH
52955: LD_EXP 30
52959: PPUSH
52960: LD_VAR 0 1
52964: PPUSH
52965: EMPTY
52966: PPUSH
52967: CALL_OW 1
52971: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52972: LD_ADDR_EXP 31
52976: PUSH
52977: LD_EXP 31
52981: PPUSH
52982: LD_VAR 0 1
52986: PPUSH
52987: EMPTY
52988: PPUSH
52989: CALL_OW 1
52993: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52994: LD_ADDR_EXP 32
52998: PUSH
52999: LD_EXP 32
53003: PPUSH
53004: LD_VAR 0 1
53008: PPUSH
53009: EMPTY
53010: PPUSH
53011: CALL_OW 1
53015: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53016: LD_ADDR_EXP 33
53020: PUSH
53021: LD_EXP 33
53025: PPUSH
53026: LD_VAR 0 1
53030: PPUSH
53031: EMPTY
53032: PPUSH
53033: CALL_OW 1
53037: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53038: LD_ADDR_EXP 34
53042: PUSH
53043: LD_EXP 34
53047: PPUSH
53048: LD_VAR 0 1
53052: PPUSH
53053: LD_INT 0
53055: PPUSH
53056: CALL_OW 1
53060: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53061: LD_ADDR_EXP 35
53065: PUSH
53066: LD_EXP 35
53070: PPUSH
53071: LD_VAR 0 1
53075: PPUSH
53076: EMPTY
53077: PPUSH
53078: CALL_OW 1
53082: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53083: LD_ADDR_EXP 36
53087: PUSH
53088: LD_EXP 36
53092: PPUSH
53093: LD_VAR 0 1
53097: PPUSH
53098: EMPTY
53099: PPUSH
53100: CALL_OW 1
53104: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53105: LD_ADDR_EXP 37
53109: PUSH
53110: LD_EXP 37
53114: PPUSH
53115: LD_VAR 0 1
53119: PPUSH
53120: EMPTY
53121: PPUSH
53122: CALL_OW 1
53126: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53127: LD_ADDR_EXP 38
53131: PUSH
53132: LD_EXP 38
53136: PPUSH
53137: LD_VAR 0 1
53141: PPUSH
53142: EMPTY
53143: PPUSH
53144: CALL_OW 1
53148: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53149: LD_ADDR_EXP 39
53153: PUSH
53154: LD_EXP 39
53158: PPUSH
53159: LD_VAR 0 1
53163: PPUSH
53164: EMPTY
53165: PPUSH
53166: CALL_OW 1
53170: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53171: LD_ADDR_EXP 40
53175: PUSH
53176: LD_EXP 40
53180: PPUSH
53181: LD_VAR 0 1
53185: PPUSH
53186: EMPTY
53187: PPUSH
53188: CALL_OW 1
53192: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53193: LD_ADDR_EXP 41
53197: PUSH
53198: LD_EXP 41
53202: PPUSH
53203: LD_VAR 0 1
53207: PPUSH
53208: EMPTY
53209: PPUSH
53210: CALL_OW 1
53214: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53215: LD_ADDR_EXP 42
53219: PUSH
53220: LD_EXP 42
53224: PPUSH
53225: LD_VAR 0 1
53229: PPUSH
53230: EMPTY
53231: PPUSH
53232: CALL_OW 1
53236: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53237: LD_ADDR_EXP 43
53241: PUSH
53242: LD_EXP 43
53246: PPUSH
53247: LD_VAR 0 1
53251: PPUSH
53252: EMPTY
53253: PPUSH
53254: CALL_OW 1
53258: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53259: LD_ADDR_EXP 44
53263: PUSH
53264: LD_EXP 44
53268: PPUSH
53269: LD_VAR 0 1
53273: PPUSH
53274: EMPTY
53275: PPUSH
53276: CALL_OW 1
53280: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53281: LD_ADDR_EXP 45
53285: PUSH
53286: LD_EXP 45
53290: PPUSH
53291: LD_VAR 0 1
53295: PPUSH
53296: EMPTY
53297: PPUSH
53298: CALL_OW 1
53302: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53303: LD_ADDR_EXP 46
53307: PUSH
53308: LD_EXP 46
53312: PPUSH
53313: LD_VAR 0 1
53317: PPUSH
53318: EMPTY
53319: PPUSH
53320: CALL_OW 1
53324: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53325: LD_ADDR_EXP 47
53329: PUSH
53330: LD_EXP 47
53334: PPUSH
53335: LD_VAR 0 1
53339: PPUSH
53340: EMPTY
53341: PPUSH
53342: CALL_OW 1
53346: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53347: LD_ADDR_EXP 48
53351: PUSH
53352: LD_EXP 48
53356: PPUSH
53357: LD_VAR 0 1
53361: PPUSH
53362: EMPTY
53363: PPUSH
53364: CALL_OW 1
53368: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53369: LD_ADDR_EXP 50
53373: PUSH
53374: LD_EXP 50
53378: PPUSH
53379: LD_VAR 0 1
53383: PPUSH
53384: EMPTY
53385: PPUSH
53386: CALL_OW 1
53390: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53391: LD_ADDR_EXP 52
53395: PUSH
53396: LD_EXP 52
53400: PPUSH
53401: LD_VAR 0 1
53405: PPUSH
53406: EMPTY
53407: PPUSH
53408: CALL_OW 1
53412: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53413: LD_ADDR_EXP 53
53417: PUSH
53418: LD_EXP 53
53422: PPUSH
53423: LD_VAR 0 1
53427: PPUSH
53428: EMPTY
53429: PPUSH
53430: CALL_OW 1
53434: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53435: LD_ADDR_EXP 54
53439: PUSH
53440: LD_EXP 54
53444: PPUSH
53445: LD_VAR 0 1
53449: PPUSH
53450: EMPTY
53451: PPUSH
53452: CALL_OW 1
53456: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53457: LD_ADDR_EXP 55
53461: PUSH
53462: LD_EXP 55
53466: PPUSH
53467: LD_VAR 0 1
53471: PPUSH
53472: EMPTY
53473: PPUSH
53474: CALL_OW 1
53478: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53479: LD_ADDR_EXP 56
53483: PUSH
53484: LD_EXP 56
53488: PPUSH
53489: LD_VAR 0 1
53493: PPUSH
53494: EMPTY
53495: PPUSH
53496: CALL_OW 1
53500: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53501: LD_ADDR_EXP 57
53505: PUSH
53506: LD_EXP 57
53510: PPUSH
53511: LD_VAR 0 1
53515: PPUSH
53516: EMPTY
53517: PPUSH
53518: CALL_OW 1
53522: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53523: LD_ADDR_EXP 58
53527: PUSH
53528: LD_EXP 58
53532: PPUSH
53533: LD_VAR 0 1
53537: PPUSH
53538: EMPTY
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53545: LD_ADDR_EXP 59
53549: PUSH
53550: LD_EXP 59
53554: PPUSH
53555: LD_VAR 0 1
53559: PPUSH
53560: EMPTY
53561: PPUSH
53562: CALL_OW 1
53566: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53567: LD_ADDR_EXP 60
53571: PUSH
53572: LD_EXP 60
53576: PPUSH
53577: LD_VAR 0 1
53581: PPUSH
53582: EMPTY
53583: PPUSH
53584: CALL_OW 1
53588: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53589: LD_ADDR_EXP 61
53593: PUSH
53594: LD_EXP 61
53598: PPUSH
53599: LD_VAR 0 1
53603: PPUSH
53604: EMPTY
53605: PPUSH
53606: CALL_OW 1
53610: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53611: LD_ADDR_EXP 62
53615: PUSH
53616: LD_EXP 62
53620: PPUSH
53621: LD_VAR 0 1
53625: PPUSH
53626: EMPTY
53627: PPUSH
53628: CALL_OW 1
53632: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53633: LD_ADDR_EXP 63
53637: PUSH
53638: LD_EXP 63
53642: PPUSH
53643: LD_VAR 0 1
53647: PPUSH
53648: EMPTY
53649: PPUSH
53650: CALL_OW 1
53654: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53655: LD_ADDR_EXP 64
53659: PUSH
53660: LD_EXP 64
53664: PPUSH
53665: LD_VAR 0 1
53669: PPUSH
53670: EMPTY
53671: PPUSH
53672: CALL_OW 1
53676: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53677: LD_ADDR_EXP 65
53681: PUSH
53682: LD_EXP 65
53686: PPUSH
53687: LD_VAR 0 1
53691: PPUSH
53692: LD_INT 0
53694: PPUSH
53695: CALL_OW 1
53699: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53700: LD_ADDR_EXP 66
53704: PUSH
53705: LD_EXP 66
53709: PPUSH
53710: LD_VAR 0 1
53714: PPUSH
53715: LD_INT 0
53717: PPUSH
53718: CALL_OW 1
53722: ST_TO_ADDR
// end ;
53723: LD_VAR 0 2
53727: RET
// export function MC_Add ( side , units ) ; var base ; begin
53728: LD_INT 0
53730: PPUSH
53731: PPUSH
// base := mc_bases + 1 ;
53732: LD_ADDR_VAR 0 4
53736: PUSH
53737: LD_EXP 23
53741: PUSH
53742: LD_INT 1
53744: PLUS
53745: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53746: LD_ADDR_EXP 49
53750: PUSH
53751: LD_EXP 49
53755: PPUSH
53756: LD_VAR 0 4
53760: PPUSH
53761: LD_VAR 0 1
53765: PPUSH
53766: CALL_OW 1
53770: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53771: LD_ADDR_EXP 23
53775: PUSH
53776: LD_EXP 23
53780: PPUSH
53781: LD_VAR 0 4
53785: PPUSH
53786: LD_VAR 0 2
53790: PPUSH
53791: CALL_OW 1
53795: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53796: LD_ADDR_EXP 24
53800: PUSH
53801: LD_EXP 24
53805: PPUSH
53806: LD_VAR 0 4
53810: PPUSH
53811: EMPTY
53812: PPUSH
53813: CALL_OW 1
53817: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53818: LD_ADDR_EXP 25
53822: PUSH
53823: LD_EXP 25
53827: PPUSH
53828: LD_VAR 0 4
53832: PPUSH
53833: EMPTY
53834: PPUSH
53835: CALL_OW 1
53839: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53840: LD_ADDR_EXP 26
53844: PUSH
53845: LD_EXP 26
53849: PPUSH
53850: LD_VAR 0 4
53854: PPUSH
53855: EMPTY
53856: PPUSH
53857: CALL_OW 1
53861: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53862: LD_ADDR_EXP 27
53866: PUSH
53867: LD_EXP 27
53871: PPUSH
53872: LD_VAR 0 4
53876: PPUSH
53877: EMPTY
53878: PPUSH
53879: CALL_OW 1
53883: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53884: LD_ADDR_EXP 28
53888: PUSH
53889: LD_EXP 28
53893: PPUSH
53894: LD_VAR 0 4
53898: PPUSH
53899: EMPTY
53900: PPUSH
53901: CALL_OW 1
53905: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53906: LD_ADDR_EXP 29
53910: PUSH
53911: LD_EXP 29
53915: PPUSH
53916: LD_VAR 0 4
53920: PPUSH
53921: EMPTY
53922: PPUSH
53923: CALL_OW 1
53927: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53928: LD_ADDR_EXP 30
53932: PUSH
53933: LD_EXP 30
53937: PPUSH
53938: LD_VAR 0 4
53942: PPUSH
53943: EMPTY
53944: PPUSH
53945: CALL_OW 1
53949: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53950: LD_ADDR_EXP 31
53954: PUSH
53955: LD_EXP 31
53959: PPUSH
53960: LD_VAR 0 4
53964: PPUSH
53965: EMPTY
53966: PPUSH
53967: CALL_OW 1
53971: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53972: LD_ADDR_EXP 32
53976: PUSH
53977: LD_EXP 32
53981: PPUSH
53982: LD_VAR 0 4
53986: PPUSH
53987: EMPTY
53988: PPUSH
53989: CALL_OW 1
53993: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53994: LD_ADDR_EXP 33
53998: PUSH
53999: LD_EXP 33
54003: PPUSH
54004: LD_VAR 0 4
54008: PPUSH
54009: EMPTY
54010: PPUSH
54011: CALL_OW 1
54015: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54016: LD_ADDR_EXP 34
54020: PUSH
54021: LD_EXP 34
54025: PPUSH
54026: LD_VAR 0 4
54030: PPUSH
54031: LD_INT 0
54033: PPUSH
54034: CALL_OW 1
54038: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54039: LD_ADDR_EXP 35
54043: PUSH
54044: LD_EXP 35
54048: PPUSH
54049: LD_VAR 0 4
54053: PPUSH
54054: EMPTY
54055: PPUSH
54056: CALL_OW 1
54060: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54061: LD_ADDR_EXP 36
54065: PUSH
54066: LD_EXP 36
54070: PPUSH
54071: LD_VAR 0 4
54075: PPUSH
54076: EMPTY
54077: PPUSH
54078: CALL_OW 1
54082: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54083: LD_ADDR_EXP 37
54087: PUSH
54088: LD_EXP 37
54092: PPUSH
54093: LD_VAR 0 4
54097: PPUSH
54098: EMPTY
54099: PPUSH
54100: CALL_OW 1
54104: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54105: LD_ADDR_EXP 38
54109: PUSH
54110: LD_EXP 38
54114: PPUSH
54115: LD_VAR 0 4
54119: PPUSH
54120: EMPTY
54121: PPUSH
54122: CALL_OW 1
54126: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54127: LD_ADDR_EXP 39
54131: PUSH
54132: LD_EXP 39
54136: PPUSH
54137: LD_VAR 0 4
54141: PPUSH
54142: EMPTY
54143: PPUSH
54144: CALL_OW 1
54148: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54149: LD_ADDR_EXP 40
54153: PUSH
54154: LD_EXP 40
54158: PPUSH
54159: LD_VAR 0 4
54163: PPUSH
54164: EMPTY
54165: PPUSH
54166: CALL_OW 1
54170: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54171: LD_ADDR_EXP 41
54175: PUSH
54176: LD_EXP 41
54180: PPUSH
54181: LD_VAR 0 4
54185: PPUSH
54186: EMPTY
54187: PPUSH
54188: CALL_OW 1
54192: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54193: LD_ADDR_EXP 42
54197: PUSH
54198: LD_EXP 42
54202: PPUSH
54203: LD_VAR 0 4
54207: PPUSH
54208: EMPTY
54209: PPUSH
54210: CALL_OW 1
54214: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54215: LD_ADDR_EXP 43
54219: PUSH
54220: LD_EXP 43
54224: PPUSH
54225: LD_VAR 0 4
54229: PPUSH
54230: EMPTY
54231: PPUSH
54232: CALL_OW 1
54236: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54237: LD_ADDR_EXP 44
54241: PUSH
54242: LD_EXP 44
54246: PPUSH
54247: LD_VAR 0 4
54251: PPUSH
54252: EMPTY
54253: PPUSH
54254: CALL_OW 1
54258: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54259: LD_ADDR_EXP 45
54263: PUSH
54264: LD_EXP 45
54268: PPUSH
54269: LD_VAR 0 4
54273: PPUSH
54274: EMPTY
54275: PPUSH
54276: CALL_OW 1
54280: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54281: LD_ADDR_EXP 46
54285: PUSH
54286: LD_EXP 46
54290: PPUSH
54291: LD_VAR 0 4
54295: PPUSH
54296: EMPTY
54297: PPUSH
54298: CALL_OW 1
54302: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54303: LD_ADDR_EXP 47
54307: PUSH
54308: LD_EXP 47
54312: PPUSH
54313: LD_VAR 0 4
54317: PPUSH
54318: EMPTY
54319: PPUSH
54320: CALL_OW 1
54324: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54325: LD_ADDR_EXP 48
54329: PUSH
54330: LD_EXP 48
54334: PPUSH
54335: LD_VAR 0 4
54339: PPUSH
54340: EMPTY
54341: PPUSH
54342: CALL_OW 1
54346: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54347: LD_ADDR_EXP 50
54351: PUSH
54352: LD_EXP 50
54356: PPUSH
54357: LD_VAR 0 4
54361: PPUSH
54362: EMPTY
54363: PPUSH
54364: CALL_OW 1
54368: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54369: LD_ADDR_EXP 52
54373: PUSH
54374: LD_EXP 52
54378: PPUSH
54379: LD_VAR 0 4
54383: PPUSH
54384: EMPTY
54385: PPUSH
54386: CALL_OW 1
54390: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54391: LD_ADDR_EXP 53
54395: PUSH
54396: LD_EXP 53
54400: PPUSH
54401: LD_VAR 0 4
54405: PPUSH
54406: EMPTY
54407: PPUSH
54408: CALL_OW 1
54412: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54413: LD_ADDR_EXP 54
54417: PUSH
54418: LD_EXP 54
54422: PPUSH
54423: LD_VAR 0 4
54427: PPUSH
54428: EMPTY
54429: PPUSH
54430: CALL_OW 1
54434: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54435: LD_ADDR_EXP 55
54439: PUSH
54440: LD_EXP 55
54444: PPUSH
54445: LD_VAR 0 4
54449: PPUSH
54450: EMPTY
54451: PPUSH
54452: CALL_OW 1
54456: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54457: LD_ADDR_EXP 56
54461: PUSH
54462: LD_EXP 56
54466: PPUSH
54467: LD_VAR 0 4
54471: PPUSH
54472: EMPTY
54473: PPUSH
54474: CALL_OW 1
54478: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54479: LD_ADDR_EXP 57
54483: PUSH
54484: LD_EXP 57
54488: PPUSH
54489: LD_VAR 0 4
54493: PPUSH
54494: EMPTY
54495: PPUSH
54496: CALL_OW 1
54500: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54501: LD_ADDR_EXP 58
54505: PUSH
54506: LD_EXP 58
54510: PPUSH
54511: LD_VAR 0 4
54515: PPUSH
54516: EMPTY
54517: PPUSH
54518: CALL_OW 1
54522: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54523: LD_ADDR_EXP 59
54527: PUSH
54528: LD_EXP 59
54532: PPUSH
54533: LD_VAR 0 4
54537: PPUSH
54538: EMPTY
54539: PPUSH
54540: CALL_OW 1
54544: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54545: LD_ADDR_EXP 60
54549: PUSH
54550: LD_EXP 60
54554: PPUSH
54555: LD_VAR 0 4
54559: PPUSH
54560: EMPTY
54561: PPUSH
54562: CALL_OW 1
54566: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54567: LD_ADDR_EXP 61
54571: PUSH
54572: LD_EXP 61
54576: PPUSH
54577: LD_VAR 0 4
54581: PPUSH
54582: EMPTY
54583: PPUSH
54584: CALL_OW 1
54588: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54589: LD_ADDR_EXP 62
54593: PUSH
54594: LD_EXP 62
54598: PPUSH
54599: LD_VAR 0 4
54603: PPUSH
54604: EMPTY
54605: PPUSH
54606: CALL_OW 1
54610: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54611: LD_ADDR_EXP 63
54615: PUSH
54616: LD_EXP 63
54620: PPUSH
54621: LD_VAR 0 4
54625: PPUSH
54626: EMPTY
54627: PPUSH
54628: CALL_OW 1
54632: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54633: LD_ADDR_EXP 64
54637: PUSH
54638: LD_EXP 64
54642: PPUSH
54643: LD_VAR 0 4
54647: PPUSH
54648: EMPTY
54649: PPUSH
54650: CALL_OW 1
54654: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54655: LD_ADDR_EXP 65
54659: PUSH
54660: LD_EXP 65
54664: PPUSH
54665: LD_VAR 0 4
54669: PPUSH
54670: LD_INT 0
54672: PPUSH
54673: CALL_OW 1
54677: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54678: LD_ADDR_EXP 66
54682: PUSH
54683: LD_EXP 66
54687: PPUSH
54688: LD_VAR 0 4
54692: PPUSH
54693: LD_INT 0
54695: PPUSH
54696: CALL_OW 1
54700: ST_TO_ADDR
// result := base ;
54701: LD_ADDR_VAR 0 3
54705: PUSH
54706: LD_VAR 0 4
54710: ST_TO_ADDR
// end ;
54711: LD_VAR 0 3
54715: RET
// export function MC_Start ( ) ; var i ; begin
54716: LD_INT 0
54718: PPUSH
54719: PPUSH
// for i = 1 to mc_bases do
54720: LD_ADDR_VAR 0 2
54724: PUSH
54725: DOUBLE
54726: LD_INT 1
54728: DEC
54729: ST_TO_ADDR
54730: LD_EXP 23
54734: PUSH
54735: FOR_TO
54736: IFFALSE 55836
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54738: LD_ADDR_EXP 23
54742: PUSH
54743: LD_EXP 23
54747: PPUSH
54748: LD_VAR 0 2
54752: PPUSH
54753: LD_EXP 23
54757: PUSH
54758: LD_VAR 0 2
54762: ARRAY
54763: PUSH
54764: LD_INT 0
54766: DIFF
54767: PPUSH
54768: CALL_OW 1
54772: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54773: LD_ADDR_EXP 24
54777: PUSH
54778: LD_EXP 24
54782: PPUSH
54783: LD_VAR 0 2
54787: PPUSH
54788: EMPTY
54789: PPUSH
54790: CALL_OW 1
54794: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54795: LD_ADDR_EXP 25
54799: PUSH
54800: LD_EXP 25
54804: PPUSH
54805: LD_VAR 0 2
54809: PPUSH
54810: EMPTY
54811: PPUSH
54812: CALL_OW 1
54816: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54817: LD_ADDR_EXP 26
54821: PUSH
54822: LD_EXP 26
54826: PPUSH
54827: LD_VAR 0 2
54831: PPUSH
54832: EMPTY
54833: PPUSH
54834: CALL_OW 1
54838: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54839: LD_ADDR_EXP 27
54843: PUSH
54844: LD_EXP 27
54848: PPUSH
54849: LD_VAR 0 2
54853: PPUSH
54854: EMPTY
54855: PUSH
54856: EMPTY
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: PPUSH
54862: CALL_OW 1
54866: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54867: LD_ADDR_EXP 28
54871: PUSH
54872: LD_EXP 28
54876: PPUSH
54877: LD_VAR 0 2
54881: PPUSH
54882: EMPTY
54883: PPUSH
54884: CALL_OW 1
54888: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54889: LD_ADDR_EXP 55
54893: PUSH
54894: LD_EXP 55
54898: PPUSH
54899: LD_VAR 0 2
54903: PPUSH
54904: EMPTY
54905: PPUSH
54906: CALL_OW 1
54910: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54911: LD_ADDR_EXP 29
54915: PUSH
54916: LD_EXP 29
54920: PPUSH
54921: LD_VAR 0 2
54925: PPUSH
54926: EMPTY
54927: PPUSH
54928: CALL_OW 1
54932: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54933: LD_ADDR_EXP 30
54937: PUSH
54938: LD_EXP 30
54942: PPUSH
54943: LD_VAR 0 2
54947: PPUSH
54948: EMPTY
54949: PPUSH
54950: CALL_OW 1
54954: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54955: LD_ADDR_EXP 31
54959: PUSH
54960: LD_EXP 31
54964: PPUSH
54965: LD_VAR 0 2
54969: PPUSH
54970: LD_EXP 23
54974: PUSH
54975: LD_VAR 0 2
54979: ARRAY
54980: PPUSH
54981: LD_INT 2
54983: PUSH
54984: LD_INT 30
54986: PUSH
54987: LD_INT 32
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: PUSH
54994: LD_INT 30
54996: PUSH
54997: LD_INT 33
54999: PUSH
55000: EMPTY
55001: LIST
55002: LIST
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: LIST
55008: PPUSH
55009: CALL_OW 72
55013: PPUSH
55014: CALL_OW 1
55018: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
55019: LD_ADDR_EXP 32
55023: PUSH
55024: LD_EXP 32
55028: PPUSH
55029: LD_VAR 0 2
55033: PPUSH
55034: LD_EXP 23
55038: PUSH
55039: LD_VAR 0 2
55043: ARRAY
55044: PPUSH
55045: LD_INT 2
55047: PUSH
55048: LD_INT 30
55050: PUSH
55051: LD_INT 32
55053: PUSH
55054: EMPTY
55055: LIST
55056: LIST
55057: PUSH
55058: LD_INT 30
55060: PUSH
55061: LD_INT 31
55063: PUSH
55064: EMPTY
55065: LIST
55066: LIST
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: LIST
55072: PUSH
55073: LD_INT 58
55075: PUSH
55076: EMPTY
55077: LIST
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: PPUSH
55083: CALL_OW 72
55087: PPUSH
55088: CALL_OW 1
55092: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
55093: LD_ADDR_EXP 33
55097: PUSH
55098: LD_EXP 33
55102: PPUSH
55103: LD_VAR 0 2
55107: PPUSH
55108: EMPTY
55109: PPUSH
55110: CALL_OW 1
55114: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
55115: LD_ADDR_EXP 37
55119: PUSH
55120: LD_EXP 37
55124: PPUSH
55125: LD_VAR 0 2
55129: PPUSH
55130: EMPTY
55131: PPUSH
55132: CALL_OW 1
55136: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
55137: LD_ADDR_EXP 36
55141: PUSH
55142: LD_EXP 36
55146: PPUSH
55147: LD_VAR 0 2
55151: PPUSH
55152: EMPTY
55153: PPUSH
55154: CALL_OW 1
55158: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55159: LD_ADDR_EXP 38
55163: PUSH
55164: LD_EXP 38
55168: PPUSH
55169: LD_VAR 0 2
55173: PPUSH
55174: EMPTY
55175: PPUSH
55176: CALL_OW 1
55180: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55181: LD_ADDR_EXP 39
55185: PUSH
55186: LD_EXP 39
55190: PPUSH
55191: LD_VAR 0 2
55195: PPUSH
55196: EMPTY
55197: PPUSH
55198: CALL_OW 1
55202: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55203: LD_ADDR_EXP 40
55207: PUSH
55208: LD_EXP 40
55212: PPUSH
55213: LD_VAR 0 2
55217: PPUSH
55218: EMPTY
55219: PPUSH
55220: CALL_OW 1
55224: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55225: LD_ADDR_EXP 41
55229: PUSH
55230: LD_EXP 41
55234: PPUSH
55235: LD_VAR 0 2
55239: PPUSH
55240: EMPTY
55241: PPUSH
55242: CALL_OW 1
55246: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55247: LD_ADDR_EXP 42
55251: PUSH
55252: LD_EXP 42
55256: PPUSH
55257: LD_VAR 0 2
55261: PPUSH
55262: EMPTY
55263: PPUSH
55264: CALL_OW 1
55268: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55269: LD_ADDR_EXP 43
55273: PUSH
55274: LD_EXP 43
55278: PPUSH
55279: LD_VAR 0 2
55283: PPUSH
55284: EMPTY
55285: PPUSH
55286: CALL_OW 1
55290: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55291: LD_ADDR_EXP 44
55295: PUSH
55296: LD_EXP 44
55300: PPUSH
55301: LD_VAR 0 2
55305: PPUSH
55306: EMPTY
55307: PPUSH
55308: CALL_OW 1
55312: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55313: LD_ADDR_EXP 45
55317: PUSH
55318: LD_EXP 45
55322: PPUSH
55323: LD_VAR 0 2
55327: PPUSH
55328: EMPTY
55329: PPUSH
55330: CALL_OW 1
55334: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55335: LD_ADDR_EXP 34
55339: PUSH
55340: LD_EXP 34
55344: PPUSH
55345: LD_VAR 0 2
55349: PPUSH
55350: LD_INT 0
55352: PPUSH
55353: CALL_OW 1
55357: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55358: LD_ADDR_EXP 47
55362: PUSH
55363: LD_EXP 47
55367: PPUSH
55368: LD_VAR 0 2
55372: PPUSH
55373: LD_INT 0
55375: PPUSH
55376: CALL_OW 1
55380: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55381: LD_ADDR_EXP 35
55385: PUSH
55386: LD_EXP 35
55390: PPUSH
55391: LD_VAR 0 2
55395: PPUSH
55396: EMPTY
55397: PPUSH
55398: CALL_OW 1
55402: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55403: LD_ADDR_EXP 46
55407: PUSH
55408: LD_EXP 46
55412: PPUSH
55413: LD_VAR 0 2
55417: PPUSH
55418: LD_INT 0
55420: PPUSH
55421: CALL_OW 1
55425: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55426: LD_ADDR_EXP 48
55430: PUSH
55431: LD_EXP 48
55435: PPUSH
55436: LD_VAR 0 2
55440: PPUSH
55441: EMPTY
55442: PPUSH
55443: CALL_OW 1
55447: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55448: LD_ADDR_EXP 51
55452: PUSH
55453: LD_EXP 51
55457: PPUSH
55458: LD_VAR 0 2
55462: PPUSH
55463: LD_INT 0
55465: PPUSH
55466: CALL_OW 1
55470: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55471: LD_ADDR_EXP 52
55475: PUSH
55476: LD_EXP 52
55480: PPUSH
55481: LD_VAR 0 2
55485: PPUSH
55486: EMPTY
55487: PPUSH
55488: CALL_OW 1
55492: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55493: LD_ADDR_EXP 53
55497: PUSH
55498: LD_EXP 53
55502: PPUSH
55503: LD_VAR 0 2
55507: PPUSH
55508: EMPTY
55509: PPUSH
55510: CALL_OW 1
55514: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55515: LD_ADDR_EXP 54
55519: PUSH
55520: LD_EXP 54
55524: PPUSH
55525: LD_VAR 0 2
55529: PPUSH
55530: EMPTY
55531: PPUSH
55532: CALL_OW 1
55536: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55537: LD_ADDR_EXP 56
55541: PUSH
55542: LD_EXP 56
55546: PPUSH
55547: LD_VAR 0 2
55551: PPUSH
55552: LD_EXP 23
55556: PUSH
55557: LD_VAR 0 2
55561: ARRAY
55562: PPUSH
55563: LD_INT 2
55565: PUSH
55566: LD_INT 30
55568: PUSH
55569: LD_INT 6
55571: PUSH
55572: EMPTY
55573: LIST
55574: LIST
55575: PUSH
55576: LD_INT 30
55578: PUSH
55579: LD_INT 7
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PUSH
55586: LD_INT 30
55588: PUSH
55589: LD_INT 8
55591: PUSH
55592: EMPTY
55593: LIST
55594: LIST
55595: PUSH
55596: EMPTY
55597: LIST
55598: LIST
55599: LIST
55600: LIST
55601: PPUSH
55602: CALL_OW 72
55606: PPUSH
55607: CALL_OW 1
55611: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55612: LD_ADDR_EXP 57
55616: PUSH
55617: LD_EXP 57
55621: PPUSH
55622: LD_VAR 0 2
55626: PPUSH
55627: EMPTY
55628: PPUSH
55629: CALL_OW 1
55633: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55634: LD_ADDR_EXP 58
55638: PUSH
55639: LD_EXP 58
55643: PPUSH
55644: LD_VAR 0 2
55648: PPUSH
55649: EMPTY
55650: PPUSH
55651: CALL_OW 1
55655: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55656: LD_ADDR_EXP 59
55660: PUSH
55661: LD_EXP 59
55665: PPUSH
55666: LD_VAR 0 2
55670: PPUSH
55671: EMPTY
55672: PPUSH
55673: CALL_OW 1
55677: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55678: LD_ADDR_EXP 60
55682: PUSH
55683: LD_EXP 60
55687: PPUSH
55688: LD_VAR 0 2
55692: PPUSH
55693: EMPTY
55694: PPUSH
55695: CALL_OW 1
55699: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55700: LD_ADDR_EXP 61
55704: PUSH
55705: LD_EXP 61
55709: PPUSH
55710: LD_VAR 0 2
55714: PPUSH
55715: EMPTY
55716: PPUSH
55717: CALL_OW 1
55721: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55722: LD_ADDR_EXP 62
55726: PUSH
55727: LD_EXP 62
55731: PPUSH
55732: LD_VAR 0 2
55736: PPUSH
55737: EMPTY
55738: PPUSH
55739: CALL_OW 1
55743: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55744: LD_ADDR_EXP 63
55748: PUSH
55749: LD_EXP 63
55753: PPUSH
55754: LD_VAR 0 2
55758: PPUSH
55759: EMPTY
55760: PPUSH
55761: CALL_OW 1
55765: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55766: LD_ADDR_EXP 64
55770: PUSH
55771: LD_EXP 64
55775: PPUSH
55776: LD_VAR 0 2
55780: PPUSH
55781: EMPTY
55782: PPUSH
55783: CALL_OW 1
55787: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55788: LD_ADDR_EXP 65
55792: PUSH
55793: LD_EXP 65
55797: PPUSH
55798: LD_VAR 0 2
55802: PPUSH
55803: LD_INT 0
55805: PPUSH
55806: CALL_OW 1
55810: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55811: LD_ADDR_EXP 66
55815: PUSH
55816: LD_EXP 66
55820: PPUSH
55821: LD_VAR 0 2
55825: PPUSH
55826: LD_INT 0
55828: PPUSH
55829: CALL_OW 1
55833: ST_TO_ADDR
// end ;
55834: GO 54735
55836: POP
55837: POP
// MC_InitSides ( ) ;
55838: CALL 56124 0 0
// MC_InitResearch ( ) ;
55842: CALL 55863 0 0
// CustomInitMacro ( ) ;
55846: CALL 273 0 0
// skirmish := true ;
55850: LD_ADDR_EXP 21
55854: PUSH
55855: LD_INT 1
55857: ST_TO_ADDR
// end ;
55858: LD_VAR 0 1
55862: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55863: LD_INT 0
55865: PPUSH
55866: PPUSH
55867: PPUSH
55868: PPUSH
55869: PPUSH
55870: PPUSH
// if not mc_bases then
55871: LD_EXP 23
55875: NOT
55876: IFFALSE 55880
// exit ;
55878: GO 56119
// for i = 1 to 8 do
55880: LD_ADDR_VAR 0 2
55884: PUSH
55885: DOUBLE
55886: LD_INT 1
55888: DEC
55889: ST_TO_ADDR
55890: LD_INT 8
55892: PUSH
55893: FOR_TO
55894: IFFALSE 55920
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55896: LD_ADDR_EXP 50
55900: PUSH
55901: LD_EXP 50
55905: PPUSH
55906: LD_VAR 0 2
55910: PPUSH
55911: EMPTY
55912: PPUSH
55913: CALL_OW 1
55917: ST_TO_ADDR
55918: GO 55893
55920: POP
55921: POP
// tmp := [ ] ;
55922: LD_ADDR_VAR 0 5
55926: PUSH
55927: EMPTY
55928: ST_TO_ADDR
// for i = 1 to mc_sides do
55929: LD_ADDR_VAR 0 2
55933: PUSH
55934: DOUBLE
55935: LD_INT 1
55937: DEC
55938: ST_TO_ADDR
55939: LD_EXP 49
55943: PUSH
55944: FOR_TO
55945: IFFALSE 56003
// if not mc_sides [ i ] in tmp then
55947: LD_EXP 49
55951: PUSH
55952: LD_VAR 0 2
55956: ARRAY
55957: PUSH
55958: LD_VAR 0 5
55962: IN
55963: NOT
55964: IFFALSE 56001
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55966: LD_ADDR_VAR 0 5
55970: PUSH
55971: LD_VAR 0 5
55975: PPUSH
55976: LD_VAR 0 5
55980: PUSH
55981: LD_INT 1
55983: PLUS
55984: PPUSH
55985: LD_EXP 49
55989: PUSH
55990: LD_VAR 0 2
55994: ARRAY
55995: PPUSH
55996: CALL_OW 2
56000: ST_TO_ADDR
56001: GO 55944
56003: POP
56004: POP
// if not tmp then
56005: LD_VAR 0 5
56009: NOT
56010: IFFALSE 56014
// exit ;
56012: GO 56119
// for j in tmp do
56014: LD_ADDR_VAR 0 3
56018: PUSH
56019: LD_VAR 0 5
56023: PUSH
56024: FOR_IN
56025: IFFALSE 56117
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
56027: LD_ADDR_VAR 0 6
56031: PUSH
56032: LD_INT 22
56034: PUSH
56035: LD_VAR 0 3
56039: PUSH
56040: EMPTY
56041: LIST
56042: LIST
56043: PPUSH
56044: CALL_OW 69
56048: ST_TO_ADDR
// if not un then
56049: LD_VAR 0 6
56053: NOT
56054: IFFALSE 56058
// continue ;
56056: GO 56024
// nation := GetNation ( un [ 1 ] ) ;
56058: LD_ADDR_VAR 0 4
56062: PUSH
56063: LD_VAR 0 6
56067: PUSH
56068: LD_INT 1
56070: ARRAY
56071: PPUSH
56072: CALL_OW 248
56076: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
56077: LD_ADDR_EXP 50
56081: PUSH
56082: LD_EXP 50
56086: PPUSH
56087: LD_VAR 0 3
56091: PPUSH
56092: LD_VAR 0 3
56096: PPUSH
56097: LD_VAR 0 4
56101: PPUSH
56102: LD_INT 1
56104: PPUSH
56105: CALL 11178 0 3
56109: PPUSH
56110: CALL_OW 1
56114: ST_TO_ADDR
// end ;
56115: GO 56024
56117: POP
56118: POP
// end ;
56119: LD_VAR 0 1
56123: RET
// export function MC_InitSides ( ) ; var i ; begin
56124: LD_INT 0
56126: PPUSH
56127: PPUSH
// if not mc_bases then
56128: LD_EXP 23
56132: NOT
56133: IFFALSE 56137
// exit ;
56135: GO 56211
// for i = 1 to mc_bases do
56137: LD_ADDR_VAR 0 2
56141: PUSH
56142: DOUBLE
56143: LD_INT 1
56145: DEC
56146: ST_TO_ADDR
56147: LD_EXP 23
56151: PUSH
56152: FOR_TO
56153: IFFALSE 56209
// if mc_bases [ i ] then
56155: LD_EXP 23
56159: PUSH
56160: LD_VAR 0 2
56164: ARRAY
56165: IFFALSE 56207
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56167: LD_ADDR_EXP 49
56171: PUSH
56172: LD_EXP 49
56176: PPUSH
56177: LD_VAR 0 2
56181: PPUSH
56182: LD_EXP 23
56186: PUSH
56187: LD_VAR 0 2
56191: ARRAY
56192: PUSH
56193: LD_INT 1
56195: ARRAY
56196: PPUSH
56197: CALL_OW 255
56201: PPUSH
56202: CALL_OW 1
56206: ST_TO_ADDR
56207: GO 56152
56209: POP
56210: POP
// end ;
56211: LD_VAR 0 1
56215: RET
// every 0 0$03 trigger skirmish do
56216: LD_EXP 21
56220: IFFALSE 56374
56222: GO 56224
56224: DISABLE
// begin enable ;
56225: ENABLE
// MC_CheckBuildings ( ) ;
56226: CALL 60872 0 0
// MC_CheckPeopleLife ( ) ;
56230: CALL 61033 0 0
// RaiseSailEvent ( 100 ) ;
56234: LD_INT 100
56236: PPUSH
56237: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56241: LD_INT 103
56243: PPUSH
56244: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56248: LD_INT 104
56250: PPUSH
56251: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56255: LD_INT 105
56257: PPUSH
56258: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56262: LD_INT 106
56264: PPUSH
56265: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56269: LD_INT 107
56271: PPUSH
56272: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56276: LD_INT 108
56278: PPUSH
56279: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56283: LD_INT 109
56285: PPUSH
56286: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56290: LD_INT 110
56292: PPUSH
56293: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56297: LD_INT 111
56299: PPUSH
56300: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56304: LD_INT 112
56306: PPUSH
56307: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56311: LD_INT 113
56313: PPUSH
56314: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56318: LD_INT 120
56320: PPUSH
56321: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56325: LD_INT 121
56327: PPUSH
56328: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56332: LD_INT 122
56334: PPUSH
56335: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56339: LD_INT 123
56341: PPUSH
56342: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56346: LD_INT 124
56348: PPUSH
56349: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56353: LD_INT 125
56355: PPUSH
56356: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56360: LD_INT 126
56362: PPUSH
56363: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56367: LD_INT 200
56369: PPUSH
56370: CALL_OW 427
// end ;
56374: END
// on SailEvent ( event ) do begin if event < 100 then
56375: LD_VAR 0 1
56379: PUSH
56380: LD_INT 100
56382: LESS
56383: IFFALSE 56394
// CustomEvent ( event ) ;
56385: LD_VAR 0 1
56389: PPUSH
56390: CALL 10329 0 1
// if event = 100 then
56394: LD_VAR 0 1
56398: PUSH
56399: LD_INT 100
56401: EQUAL
56402: IFFALSE 56408
// MC_ClassManager ( ) ;
56404: CALL 56800 0 0
// if event = 101 then
56408: LD_VAR 0 1
56412: PUSH
56413: LD_INT 101
56415: EQUAL
56416: IFFALSE 56422
// MC_RepairBuildings ( ) ;
56418: CALL 61618 0 0
// if event = 102 then
56422: LD_VAR 0 1
56426: PUSH
56427: LD_INT 102
56429: EQUAL
56430: IFFALSE 56436
// MC_Heal ( ) ;
56432: CALL 62553 0 0
// if event = 103 then
56436: LD_VAR 0 1
56440: PUSH
56441: LD_INT 103
56443: EQUAL
56444: IFFALSE 56450
// MC_Build ( ) ;
56446: CALL 62975 0 0
// if event = 104 then
56450: LD_VAR 0 1
56454: PUSH
56455: LD_INT 104
56457: EQUAL
56458: IFFALSE 56464
// MC_TurretWeapon ( ) ;
56460: CALL 64609 0 0
// if event = 105 then
56464: LD_VAR 0 1
56468: PUSH
56469: LD_INT 105
56471: EQUAL
56472: IFFALSE 56478
// MC_BuildUpgrade ( ) ;
56474: CALL 64160 0 0
// if event = 106 then
56478: LD_VAR 0 1
56482: PUSH
56483: LD_INT 106
56485: EQUAL
56486: IFFALSE 56492
// MC_PlantMines ( ) ;
56488: CALL 65039 0 0
// if event = 107 then
56492: LD_VAR 0 1
56496: PUSH
56497: LD_INT 107
56499: EQUAL
56500: IFFALSE 56506
// MC_CollectCrates ( ) ;
56502: CALL 65830 0 0
// if event = 108 then
56506: LD_VAR 0 1
56510: PUSH
56511: LD_INT 108
56513: EQUAL
56514: IFFALSE 56520
// MC_LinkRemoteControl ( ) ;
56516: CALL 67680 0 0
// if event = 109 then
56520: LD_VAR 0 1
56524: PUSH
56525: LD_INT 109
56527: EQUAL
56528: IFFALSE 56534
// MC_ProduceVehicle ( ) ;
56530: CALL 67861 0 0
// if event = 110 then
56534: LD_VAR 0 1
56538: PUSH
56539: LD_INT 110
56541: EQUAL
56542: IFFALSE 56548
// MC_SendAttack ( ) ;
56544: CALL 68327 0 0
// if event = 111 then
56548: LD_VAR 0 1
56552: PUSH
56553: LD_INT 111
56555: EQUAL
56556: IFFALSE 56562
// MC_Defend ( ) ;
56558: CALL 68435 0 0
// if event = 112 then
56562: LD_VAR 0 1
56566: PUSH
56567: LD_INT 112
56569: EQUAL
56570: IFFALSE 56576
// MC_Research ( ) ;
56572: CALL 69315 0 0
// if event = 113 then
56576: LD_VAR 0 1
56580: PUSH
56581: LD_INT 113
56583: EQUAL
56584: IFFALSE 56590
// MC_MinesTrigger ( ) ;
56586: CALL 70429 0 0
// if event = 120 then
56590: LD_VAR 0 1
56594: PUSH
56595: LD_INT 120
56597: EQUAL
56598: IFFALSE 56604
// MC_RepairVehicle ( ) ;
56600: CALL 70528 0 0
// if event = 121 then
56604: LD_VAR 0 1
56608: PUSH
56609: LD_INT 121
56611: EQUAL
56612: IFFALSE 56618
// MC_TameApe ( ) ;
56614: CALL 71297 0 0
// if event = 122 then
56618: LD_VAR 0 1
56622: PUSH
56623: LD_INT 122
56625: EQUAL
56626: IFFALSE 56632
// MC_ChangeApeClass ( ) ;
56628: CALL 72126 0 0
// if event = 123 then
56632: LD_VAR 0 1
56636: PUSH
56637: LD_INT 123
56639: EQUAL
56640: IFFALSE 56646
// MC_Bazooka ( ) ;
56642: CALL 72776 0 0
// if event = 124 then
56646: LD_VAR 0 1
56650: PUSH
56651: LD_INT 124
56653: EQUAL
56654: IFFALSE 56660
// MC_TeleportExit ( ) ;
56656: CALL 72974 0 0
// if event = 125 then
56660: LD_VAR 0 1
56664: PUSH
56665: LD_INT 125
56667: EQUAL
56668: IFFALSE 56674
// MC_Deposits ( ) ;
56670: CALL 73621 0 0
// if event = 126 then
56674: LD_VAR 0 1
56678: PUSH
56679: LD_INT 126
56681: EQUAL
56682: IFFALSE 56688
// MC_RemoteDriver ( ) ;
56684: CALL 74246 0 0
// if event = 200 then
56688: LD_VAR 0 1
56692: PUSH
56693: LD_INT 200
56695: EQUAL
56696: IFFALSE 56702
// MC_Idle ( ) ;
56698: CALL 76195 0 0
// end ;
56702: PPOPN 1
56704: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56705: LD_INT 0
56707: PPUSH
56708: PPUSH
// if not mc_bases [ base ] or not tag then
56709: LD_EXP 23
56713: PUSH
56714: LD_VAR 0 1
56718: ARRAY
56719: NOT
56720: PUSH
56721: LD_VAR 0 2
56725: NOT
56726: OR
56727: IFFALSE 56731
// exit ;
56729: GO 56795
// for i in mc_bases [ base ] union mc_ape [ base ] do
56731: LD_ADDR_VAR 0 4
56735: PUSH
56736: LD_EXP 23
56740: PUSH
56741: LD_VAR 0 1
56745: ARRAY
56746: PUSH
56747: LD_EXP 52
56751: PUSH
56752: LD_VAR 0 1
56756: ARRAY
56757: UNION
56758: PUSH
56759: FOR_IN
56760: IFFALSE 56793
// if GetTag ( i ) = tag then
56762: LD_VAR 0 4
56766: PPUSH
56767: CALL_OW 110
56771: PUSH
56772: LD_VAR 0 2
56776: EQUAL
56777: IFFALSE 56791
// SetTag ( i , 0 ) ;
56779: LD_VAR 0 4
56783: PPUSH
56784: LD_INT 0
56786: PPUSH
56787: CALL_OW 109
56791: GO 56759
56793: POP
56794: POP
// end ;
56795: LD_VAR 0 3
56799: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56800: LD_INT 0
56802: PPUSH
56803: PPUSH
56804: PPUSH
56805: PPUSH
56806: PPUSH
56807: PPUSH
56808: PPUSH
56809: PPUSH
// if not mc_bases then
56810: LD_EXP 23
56814: NOT
56815: IFFALSE 56819
// exit ;
56817: GO 57277
// for i = 1 to mc_bases do
56819: LD_ADDR_VAR 0 2
56823: PUSH
56824: DOUBLE
56825: LD_INT 1
56827: DEC
56828: ST_TO_ADDR
56829: LD_EXP 23
56833: PUSH
56834: FOR_TO
56835: IFFALSE 57275
// begin tmp := MC_ClassCheckReq ( i ) ;
56837: LD_ADDR_VAR 0 4
56841: PUSH
56842: LD_VAR 0 2
56846: PPUSH
56847: CALL 57282 0 1
56851: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56852: LD_ADDR_EXP 64
56856: PUSH
56857: LD_EXP 64
56861: PPUSH
56862: LD_VAR 0 2
56866: PPUSH
56867: LD_VAR 0 4
56871: PPUSH
56872: CALL_OW 1
56876: ST_TO_ADDR
// if not tmp then
56877: LD_VAR 0 4
56881: NOT
56882: IFFALSE 56886
// continue ;
56884: GO 56834
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56886: LD_ADDR_VAR 0 6
56890: PUSH
56891: LD_EXP 23
56895: PUSH
56896: LD_VAR 0 2
56900: ARRAY
56901: PPUSH
56902: LD_INT 2
56904: PUSH
56905: LD_INT 30
56907: PUSH
56908: LD_INT 4
56910: PUSH
56911: EMPTY
56912: LIST
56913: LIST
56914: PUSH
56915: LD_INT 30
56917: PUSH
56918: LD_INT 5
56920: PUSH
56921: EMPTY
56922: LIST
56923: LIST
56924: PUSH
56925: EMPTY
56926: LIST
56927: LIST
56928: LIST
56929: PPUSH
56930: CALL_OW 72
56934: PUSH
56935: LD_EXP 23
56939: PUSH
56940: LD_VAR 0 2
56944: ARRAY
56945: PPUSH
56946: LD_INT 2
56948: PUSH
56949: LD_INT 30
56951: PUSH
56952: LD_INT 0
56954: PUSH
56955: EMPTY
56956: LIST
56957: LIST
56958: PUSH
56959: LD_INT 30
56961: PUSH
56962: LD_INT 1
56964: PUSH
56965: EMPTY
56966: LIST
56967: LIST
56968: PUSH
56969: EMPTY
56970: LIST
56971: LIST
56972: LIST
56973: PPUSH
56974: CALL_OW 72
56978: PUSH
56979: LD_EXP 23
56983: PUSH
56984: LD_VAR 0 2
56988: ARRAY
56989: PPUSH
56990: LD_INT 30
56992: PUSH
56993: LD_INT 3
56995: PUSH
56996: EMPTY
56997: LIST
56998: LIST
56999: PPUSH
57000: CALL_OW 72
57004: PUSH
57005: LD_EXP 23
57009: PUSH
57010: LD_VAR 0 2
57014: ARRAY
57015: PPUSH
57016: LD_INT 2
57018: PUSH
57019: LD_INT 30
57021: PUSH
57022: LD_INT 6
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: PUSH
57029: LD_INT 30
57031: PUSH
57032: LD_INT 7
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: PUSH
57039: LD_INT 30
57041: PUSH
57042: LD_INT 8
57044: PUSH
57045: EMPTY
57046: LIST
57047: LIST
57048: PUSH
57049: EMPTY
57050: LIST
57051: LIST
57052: LIST
57053: LIST
57054: PPUSH
57055: CALL_OW 72
57059: PUSH
57060: EMPTY
57061: LIST
57062: LIST
57063: LIST
57064: LIST
57065: ST_TO_ADDR
// for j = 1 to 4 do
57066: LD_ADDR_VAR 0 3
57070: PUSH
57071: DOUBLE
57072: LD_INT 1
57074: DEC
57075: ST_TO_ADDR
57076: LD_INT 4
57078: PUSH
57079: FOR_TO
57080: IFFALSE 57271
// begin if not tmp [ j ] then
57082: LD_VAR 0 4
57086: PUSH
57087: LD_VAR 0 3
57091: ARRAY
57092: NOT
57093: IFFALSE 57097
// continue ;
57095: GO 57079
// for p in tmp [ j ] do
57097: LD_ADDR_VAR 0 5
57101: PUSH
57102: LD_VAR 0 4
57106: PUSH
57107: LD_VAR 0 3
57111: ARRAY
57112: PUSH
57113: FOR_IN
57114: IFFALSE 57267
// begin if not b [ j ] then
57116: LD_VAR 0 6
57120: PUSH
57121: LD_VAR 0 3
57125: ARRAY
57126: NOT
57127: IFFALSE 57131
// break ;
57129: GO 57267
// e := 0 ;
57131: LD_ADDR_VAR 0 7
57135: PUSH
57136: LD_INT 0
57138: ST_TO_ADDR
// for k in b [ j ] do
57139: LD_ADDR_VAR 0 8
57143: PUSH
57144: LD_VAR 0 6
57148: PUSH
57149: LD_VAR 0 3
57153: ARRAY
57154: PUSH
57155: FOR_IN
57156: IFFALSE 57183
// if IsNotFull ( k ) then
57158: LD_VAR 0 8
57162: PPUSH
57163: CALL 13331 0 1
57167: IFFALSE 57181
// begin e := k ;
57169: LD_ADDR_VAR 0 7
57173: PUSH
57174: LD_VAR 0 8
57178: ST_TO_ADDR
// break ;
57179: GO 57183
// end ;
57181: GO 57155
57183: POP
57184: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57185: LD_VAR 0 7
57189: PUSH
57190: LD_VAR 0 5
57194: PPUSH
57195: LD_VAR 0 7
57199: PPUSH
57200: CALL 47227 0 2
57204: NOT
57205: AND
57206: IFFALSE 57265
// begin if IsInUnit ( p ) then
57208: LD_VAR 0 5
57212: PPUSH
57213: CALL_OW 310
57217: IFFALSE 57228
// ComExitBuilding ( p ) ;
57219: LD_VAR 0 5
57223: PPUSH
57224: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57228: LD_VAR 0 5
57232: PPUSH
57233: LD_VAR 0 7
57237: PPUSH
57238: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57242: LD_VAR 0 5
57246: PPUSH
57247: LD_VAR 0 3
57251: PPUSH
57252: CALL_OW 183
// AddComExitBuilding ( p ) ;
57256: LD_VAR 0 5
57260: PPUSH
57261: CALL_OW 182
// end ; end ;
57265: GO 57113
57267: POP
57268: POP
// end ;
57269: GO 57079
57271: POP
57272: POP
// end ;
57273: GO 56834
57275: POP
57276: POP
// end ;
57277: LD_VAR 0 1
57281: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57282: LD_INT 0
57284: PPUSH
57285: PPUSH
57286: PPUSH
57287: PPUSH
57288: PPUSH
57289: PPUSH
57290: PPUSH
57291: PPUSH
57292: PPUSH
57293: PPUSH
57294: PPUSH
57295: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57296: LD_VAR 0 1
57300: NOT
57301: PUSH
57302: LD_EXP 23
57306: PUSH
57307: LD_VAR 0 1
57311: ARRAY
57312: NOT
57313: OR
57314: PUSH
57315: LD_EXP 23
57319: PUSH
57320: LD_VAR 0 1
57324: ARRAY
57325: PPUSH
57326: LD_INT 2
57328: PUSH
57329: LD_INT 30
57331: PUSH
57332: LD_INT 0
57334: PUSH
57335: EMPTY
57336: LIST
57337: LIST
57338: PUSH
57339: LD_INT 30
57341: PUSH
57342: LD_INT 1
57344: PUSH
57345: EMPTY
57346: LIST
57347: LIST
57348: PUSH
57349: EMPTY
57350: LIST
57351: LIST
57352: LIST
57353: PPUSH
57354: CALL_OW 72
57358: NOT
57359: OR
57360: IFFALSE 57364
// exit ;
57362: GO 60867
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57364: LD_ADDR_VAR 0 4
57368: PUSH
57369: LD_EXP 23
57373: PUSH
57374: LD_VAR 0 1
57378: ARRAY
57379: PPUSH
57380: LD_INT 2
57382: PUSH
57383: LD_INT 25
57385: PUSH
57386: LD_INT 1
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PUSH
57393: LD_INT 25
57395: PUSH
57396: LD_INT 2
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: PUSH
57403: LD_INT 25
57405: PUSH
57406: LD_INT 3
57408: PUSH
57409: EMPTY
57410: LIST
57411: LIST
57412: PUSH
57413: LD_INT 25
57415: PUSH
57416: LD_INT 4
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: PUSH
57423: LD_INT 25
57425: PUSH
57426: LD_INT 5
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: PUSH
57433: LD_INT 25
57435: PUSH
57436: LD_INT 8
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: PUSH
57443: LD_INT 25
57445: PUSH
57446: LD_INT 9
57448: PUSH
57449: EMPTY
57450: LIST
57451: LIST
57452: PUSH
57453: EMPTY
57454: LIST
57455: LIST
57456: LIST
57457: LIST
57458: LIST
57459: LIST
57460: LIST
57461: LIST
57462: PPUSH
57463: CALL_OW 72
57467: ST_TO_ADDR
// if not tmp then
57468: LD_VAR 0 4
57472: NOT
57473: IFFALSE 57477
// exit ;
57475: GO 60867
// for i in tmp do
57477: LD_ADDR_VAR 0 3
57481: PUSH
57482: LD_VAR 0 4
57486: PUSH
57487: FOR_IN
57488: IFFALSE 57519
// if GetTag ( i ) then
57490: LD_VAR 0 3
57494: PPUSH
57495: CALL_OW 110
57499: IFFALSE 57517
// tmp := tmp diff i ;
57501: LD_ADDR_VAR 0 4
57505: PUSH
57506: LD_VAR 0 4
57510: PUSH
57511: LD_VAR 0 3
57515: DIFF
57516: ST_TO_ADDR
57517: GO 57487
57519: POP
57520: POP
// if not tmp then
57521: LD_VAR 0 4
57525: NOT
57526: IFFALSE 57530
// exit ;
57528: GO 60867
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57530: LD_ADDR_VAR 0 5
57534: PUSH
57535: LD_EXP 23
57539: PUSH
57540: LD_VAR 0 1
57544: ARRAY
57545: PPUSH
57546: LD_INT 2
57548: PUSH
57549: LD_INT 25
57551: PUSH
57552: LD_INT 1
57554: PUSH
57555: EMPTY
57556: LIST
57557: LIST
57558: PUSH
57559: LD_INT 25
57561: PUSH
57562: LD_INT 5
57564: PUSH
57565: EMPTY
57566: LIST
57567: LIST
57568: PUSH
57569: LD_INT 25
57571: PUSH
57572: LD_INT 8
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: PUSH
57579: LD_INT 25
57581: PUSH
57582: LD_INT 9
57584: PUSH
57585: EMPTY
57586: LIST
57587: LIST
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: LIST
57593: LIST
57594: LIST
57595: PPUSH
57596: CALL_OW 72
57600: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57601: LD_ADDR_VAR 0 6
57605: PUSH
57606: LD_EXP 23
57610: PUSH
57611: LD_VAR 0 1
57615: ARRAY
57616: PPUSH
57617: LD_INT 25
57619: PUSH
57620: LD_INT 2
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PPUSH
57627: CALL_OW 72
57631: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57632: LD_ADDR_VAR 0 7
57636: PUSH
57637: LD_EXP 23
57641: PUSH
57642: LD_VAR 0 1
57646: ARRAY
57647: PPUSH
57648: LD_INT 25
57650: PUSH
57651: LD_INT 3
57653: PUSH
57654: EMPTY
57655: LIST
57656: LIST
57657: PPUSH
57658: CALL_OW 72
57662: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57663: LD_ADDR_VAR 0 8
57667: PUSH
57668: LD_EXP 23
57672: PUSH
57673: LD_VAR 0 1
57677: ARRAY
57678: PPUSH
57679: LD_INT 25
57681: PUSH
57682: LD_INT 4
57684: PUSH
57685: EMPTY
57686: LIST
57687: LIST
57688: PUSH
57689: LD_INT 24
57691: PUSH
57692: LD_INT 251
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PUSH
57699: EMPTY
57700: LIST
57701: LIST
57702: PPUSH
57703: CALL_OW 72
57707: ST_TO_ADDR
// if mc_is_defending [ base ] then
57708: LD_EXP 66
57712: PUSH
57713: LD_VAR 0 1
57717: ARRAY
57718: IFFALSE 58179
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57720: LD_ADDR_EXP 65
57724: PUSH
57725: LD_EXP 65
57729: PPUSH
57730: LD_VAR 0 1
57734: PPUSH
57735: LD_INT 4
57737: PPUSH
57738: CALL_OW 1
57742: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57743: LD_ADDR_VAR 0 12
57747: PUSH
57748: LD_EXP 23
57752: PUSH
57753: LD_VAR 0 1
57757: ARRAY
57758: PPUSH
57759: LD_INT 2
57761: PUSH
57762: LD_INT 30
57764: PUSH
57765: LD_INT 4
57767: PUSH
57768: EMPTY
57769: LIST
57770: LIST
57771: PUSH
57772: LD_INT 30
57774: PUSH
57775: LD_INT 5
57777: PUSH
57778: EMPTY
57779: LIST
57780: LIST
57781: PUSH
57782: EMPTY
57783: LIST
57784: LIST
57785: LIST
57786: PPUSH
57787: CALL_OW 72
57791: ST_TO_ADDR
// if not b then
57792: LD_VAR 0 12
57796: NOT
57797: IFFALSE 57801
// exit ;
57799: GO 60867
// p := [ ] ;
57801: LD_ADDR_VAR 0 11
57805: PUSH
57806: EMPTY
57807: ST_TO_ADDR
// if sci >= 2 then
57808: LD_VAR 0 8
57812: PUSH
57813: LD_INT 2
57815: GREATEREQUAL
57816: IFFALSE 57847
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57818: LD_ADDR_VAR 0 8
57822: PUSH
57823: LD_VAR 0 8
57827: PUSH
57828: LD_INT 1
57830: ARRAY
57831: PUSH
57832: LD_VAR 0 8
57836: PUSH
57837: LD_INT 2
57839: ARRAY
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: ST_TO_ADDR
57845: GO 57908
// if sci = 1 then
57847: LD_VAR 0 8
57851: PUSH
57852: LD_INT 1
57854: EQUAL
57855: IFFALSE 57876
// sci := [ sci [ 1 ] ] else
57857: LD_ADDR_VAR 0 8
57861: PUSH
57862: LD_VAR 0 8
57866: PUSH
57867: LD_INT 1
57869: ARRAY
57870: PUSH
57871: EMPTY
57872: LIST
57873: ST_TO_ADDR
57874: GO 57908
// if sci = 0 then
57876: LD_VAR 0 8
57880: PUSH
57881: LD_INT 0
57883: EQUAL
57884: IFFALSE 57908
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57886: LD_ADDR_VAR 0 11
57890: PUSH
57891: LD_VAR 0 4
57895: PPUSH
57896: LD_INT 4
57898: PPUSH
57899: CALL 47099 0 2
57903: PUSH
57904: LD_INT 1
57906: ARRAY
57907: ST_TO_ADDR
// if eng > 4 then
57908: LD_VAR 0 6
57912: PUSH
57913: LD_INT 4
57915: GREATER
57916: IFFALSE 57962
// for i = eng downto 4 do
57918: LD_ADDR_VAR 0 3
57922: PUSH
57923: DOUBLE
57924: LD_VAR 0 6
57928: INC
57929: ST_TO_ADDR
57930: LD_INT 4
57932: PUSH
57933: FOR_DOWNTO
57934: IFFALSE 57960
// eng := eng diff eng [ i ] ;
57936: LD_ADDR_VAR 0 6
57940: PUSH
57941: LD_VAR 0 6
57945: PUSH
57946: LD_VAR 0 6
57950: PUSH
57951: LD_VAR 0 3
57955: ARRAY
57956: DIFF
57957: ST_TO_ADDR
57958: GO 57933
57960: POP
57961: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57962: LD_ADDR_VAR 0 4
57966: PUSH
57967: LD_VAR 0 4
57971: PUSH
57972: LD_VAR 0 5
57976: PUSH
57977: LD_VAR 0 6
57981: UNION
57982: PUSH
57983: LD_VAR 0 7
57987: UNION
57988: PUSH
57989: LD_VAR 0 8
57993: UNION
57994: DIFF
57995: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57996: LD_ADDR_VAR 0 13
58000: PUSH
58001: LD_EXP 23
58005: PUSH
58006: LD_VAR 0 1
58010: ARRAY
58011: PPUSH
58012: LD_INT 2
58014: PUSH
58015: LD_INT 30
58017: PUSH
58018: LD_INT 32
58020: PUSH
58021: EMPTY
58022: LIST
58023: LIST
58024: PUSH
58025: LD_INT 30
58027: PUSH
58028: LD_INT 31
58030: PUSH
58031: EMPTY
58032: LIST
58033: LIST
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: LIST
58039: PPUSH
58040: CALL_OW 72
58044: PUSH
58045: LD_EXP 23
58049: PUSH
58050: LD_VAR 0 1
58054: ARRAY
58055: PPUSH
58056: LD_INT 2
58058: PUSH
58059: LD_INT 30
58061: PUSH
58062: LD_INT 4
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: PUSH
58069: LD_INT 30
58071: PUSH
58072: LD_INT 5
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: PPUSH
58084: CALL_OW 72
58088: PUSH
58089: LD_INT 6
58091: MUL
58092: PLUS
58093: ST_TO_ADDR
// if bcount < tmp then
58094: LD_VAR 0 13
58098: PUSH
58099: LD_VAR 0 4
58103: LESS
58104: IFFALSE 58150
// for i = tmp downto bcount do
58106: LD_ADDR_VAR 0 3
58110: PUSH
58111: DOUBLE
58112: LD_VAR 0 4
58116: INC
58117: ST_TO_ADDR
58118: LD_VAR 0 13
58122: PUSH
58123: FOR_DOWNTO
58124: IFFALSE 58148
// tmp := Delete ( tmp , tmp ) ;
58126: LD_ADDR_VAR 0 4
58130: PUSH
58131: LD_VAR 0 4
58135: PPUSH
58136: LD_VAR 0 4
58140: PPUSH
58141: CALL_OW 3
58145: ST_TO_ADDR
58146: GO 58123
58148: POP
58149: POP
// result := [ tmp , 0 , 0 , p ] ;
58150: LD_ADDR_VAR 0 2
58154: PUSH
58155: LD_VAR 0 4
58159: PUSH
58160: LD_INT 0
58162: PUSH
58163: LD_INT 0
58165: PUSH
58166: LD_VAR 0 11
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: LIST
58175: LIST
58176: ST_TO_ADDR
// exit ;
58177: GO 60867
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58179: LD_EXP 23
58183: PUSH
58184: LD_VAR 0 1
58188: ARRAY
58189: PPUSH
58190: LD_INT 2
58192: PUSH
58193: LD_INT 30
58195: PUSH
58196: LD_INT 6
58198: PUSH
58199: EMPTY
58200: LIST
58201: LIST
58202: PUSH
58203: LD_INT 30
58205: PUSH
58206: LD_INT 7
58208: PUSH
58209: EMPTY
58210: LIST
58211: LIST
58212: PUSH
58213: LD_INT 30
58215: PUSH
58216: LD_INT 8
58218: PUSH
58219: EMPTY
58220: LIST
58221: LIST
58222: PUSH
58223: EMPTY
58224: LIST
58225: LIST
58226: LIST
58227: LIST
58228: PPUSH
58229: CALL_OW 72
58233: NOT
58234: PUSH
58235: LD_EXP 23
58239: PUSH
58240: LD_VAR 0 1
58244: ARRAY
58245: PPUSH
58246: LD_INT 30
58248: PUSH
58249: LD_INT 3
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: PPUSH
58256: CALL_OW 72
58260: NOT
58261: AND
58262: IFFALSE 58334
// begin if eng = tmp then
58264: LD_VAR 0 6
58268: PUSH
58269: LD_VAR 0 4
58273: EQUAL
58274: IFFALSE 58278
// exit ;
58276: GO 60867
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58278: LD_ADDR_EXP 65
58282: PUSH
58283: LD_EXP 65
58287: PPUSH
58288: LD_VAR 0 1
58292: PPUSH
58293: LD_INT 1
58295: PPUSH
58296: CALL_OW 1
58300: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58301: LD_ADDR_VAR 0 2
58305: PUSH
58306: LD_INT 0
58308: PUSH
58309: LD_VAR 0 4
58313: PUSH
58314: LD_VAR 0 6
58318: DIFF
58319: PUSH
58320: LD_INT 0
58322: PUSH
58323: LD_INT 0
58325: PUSH
58326: EMPTY
58327: LIST
58328: LIST
58329: LIST
58330: LIST
58331: ST_TO_ADDR
// exit ;
58332: GO 60867
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58334: LD_EXP 50
58338: PUSH
58339: LD_EXP 49
58343: PUSH
58344: LD_VAR 0 1
58348: ARRAY
58349: ARRAY
58350: PUSH
58351: LD_EXP 23
58355: PUSH
58356: LD_VAR 0 1
58360: ARRAY
58361: PPUSH
58362: LD_INT 2
58364: PUSH
58365: LD_INT 30
58367: PUSH
58368: LD_INT 6
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PUSH
58375: LD_INT 30
58377: PUSH
58378: LD_INT 7
58380: PUSH
58381: EMPTY
58382: LIST
58383: LIST
58384: PUSH
58385: LD_INT 30
58387: PUSH
58388: LD_INT 8
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: LIST
58399: LIST
58400: PPUSH
58401: CALL_OW 72
58405: AND
58406: PUSH
58407: LD_EXP 23
58411: PUSH
58412: LD_VAR 0 1
58416: ARRAY
58417: PPUSH
58418: LD_INT 30
58420: PUSH
58421: LD_INT 3
58423: PUSH
58424: EMPTY
58425: LIST
58426: LIST
58427: PPUSH
58428: CALL_OW 72
58432: NOT
58433: AND
58434: IFFALSE 58648
// begin if sci >= 6 then
58436: LD_VAR 0 8
58440: PUSH
58441: LD_INT 6
58443: GREATEREQUAL
58444: IFFALSE 58448
// exit ;
58446: GO 60867
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58448: LD_ADDR_EXP 65
58452: PUSH
58453: LD_EXP 65
58457: PPUSH
58458: LD_VAR 0 1
58462: PPUSH
58463: LD_INT 2
58465: PPUSH
58466: CALL_OW 1
58470: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58471: LD_ADDR_VAR 0 9
58475: PUSH
58476: LD_VAR 0 4
58480: PUSH
58481: LD_VAR 0 8
58485: DIFF
58486: PPUSH
58487: LD_INT 4
58489: PPUSH
58490: CALL 47099 0 2
58494: ST_TO_ADDR
// p := [ ] ;
58495: LD_ADDR_VAR 0 11
58499: PUSH
58500: EMPTY
58501: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58502: LD_VAR 0 8
58506: PUSH
58507: LD_INT 6
58509: LESS
58510: PUSH
58511: LD_VAR 0 9
58515: PUSH
58516: LD_INT 6
58518: GREATER
58519: AND
58520: IFFALSE 58601
// begin for i = 1 to 6 - sci do
58522: LD_ADDR_VAR 0 3
58526: PUSH
58527: DOUBLE
58528: LD_INT 1
58530: DEC
58531: ST_TO_ADDR
58532: LD_INT 6
58534: PUSH
58535: LD_VAR 0 8
58539: MINUS
58540: PUSH
58541: FOR_TO
58542: IFFALSE 58597
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58544: LD_ADDR_VAR 0 11
58548: PUSH
58549: LD_VAR 0 11
58553: PPUSH
58554: LD_VAR 0 11
58558: PUSH
58559: LD_INT 1
58561: PLUS
58562: PPUSH
58563: LD_VAR 0 9
58567: PUSH
58568: LD_INT 1
58570: ARRAY
58571: PPUSH
58572: CALL_OW 2
58576: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58577: LD_ADDR_VAR 0 9
58581: PUSH
58582: LD_VAR 0 9
58586: PPUSH
58587: LD_INT 1
58589: PPUSH
58590: CALL_OW 3
58594: ST_TO_ADDR
// end ;
58595: GO 58541
58597: POP
58598: POP
// end else
58599: GO 58621
// if sort then
58601: LD_VAR 0 9
58605: IFFALSE 58621
// p := sort [ 1 ] ;
58607: LD_ADDR_VAR 0 11
58611: PUSH
58612: LD_VAR 0 9
58616: PUSH
58617: LD_INT 1
58619: ARRAY
58620: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58621: LD_ADDR_VAR 0 2
58625: PUSH
58626: LD_INT 0
58628: PUSH
58629: LD_INT 0
58631: PUSH
58632: LD_INT 0
58634: PUSH
58635: LD_VAR 0 11
58639: PUSH
58640: EMPTY
58641: LIST
58642: LIST
58643: LIST
58644: LIST
58645: ST_TO_ADDR
// exit ;
58646: GO 60867
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58648: LD_EXP 50
58652: PUSH
58653: LD_EXP 49
58657: PUSH
58658: LD_VAR 0 1
58662: ARRAY
58663: ARRAY
58664: PUSH
58665: LD_EXP 23
58669: PUSH
58670: LD_VAR 0 1
58674: ARRAY
58675: PPUSH
58676: LD_INT 2
58678: PUSH
58679: LD_INT 30
58681: PUSH
58682: LD_INT 6
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: PUSH
58689: LD_INT 30
58691: PUSH
58692: LD_INT 7
58694: PUSH
58695: EMPTY
58696: LIST
58697: LIST
58698: PUSH
58699: LD_INT 30
58701: PUSH
58702: LD_INT 8
58704: PUSH
58705: EMPTY
58706: LIST
58707: LIST
58708: PUSH
58709: EMPTY
58710: LIST
58711: LIST
58712: LIST
58713: LIST
58714: PPUSH
58715: CALL_OW 72
58719: AND
58720: PUSH
58721: LD_EXP 23
58725: PUSH
58726: LD_VAR 0 1
58730: ARRAY
58731: PPUSH
58732: LD_INT 30
58734: PUSH
58735: LD_INT 3
58737: PUSH
58738: EMPTY
58739: LIST
58740: LIST
58741: PPUSH
58742: CALL_OW 72
58746: AND
58747: IFFALSE 59481
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58749: LD_ADDR_EXP 65
58753: PUSH
58754: LD_EXP 65
58758: PPUSH
58759: LD_VAR 0 1
58763: PPUSH
58764: LD_INT 3
58766: PPUSH
58767: CALL_OW 1
58771: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58772: LD_ADDR_VAR 0 2
58776: PUSH
58777: LD_INT 0
58779: PUSH
58780: LD_INT 0
58782: PUSH
58783: LD_INT 0
58785: PUSH
58786: LD_INT 0
58788: PUSH
58789: EMPTY
58790: LIST
58791: LIST
58792: LIST
58793: LIST
58794: ST_TO_ADDR
// if not eng then
58795: LD_VAR 0 6
58799: NOT
58800: IFFALSE 58863
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58802: LD_ADDR_VAR 0 11
58806: PUSH
58807: LD_VAR 0 4
58811: PPUSH
58812: LD_INT 2
58814: PPUSH
58815: CALL 47099 0 2
58819: PUSH
58820: LD_INT 1
58822: ARRAY
58823: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58824: LD_ADDR_VAR 0 2
58828: PUSH
58829: LD_VAR 0 2
58833: PPUSH
58834: LD_INT 2
58836: PPUSH
58837: LD_VAR 0 11
58841: PPUSH
58842: CALL_OW 1
58846: ST_TO_ADDR
// tmp := tmp diff p ;
58847: LD_ADDR_VAR 0 4
58851: PUSH
58852: LD_VAR 0 4
58856: PUSH
58857: LD_VAR 0 11
58861: DIFF
58862: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58863: LD_VAR 0 4
58867: PUSH
58868: LD_VAR 0 8
58872: PUSH
58873: LD_INT 6
58875: LESS
58876: AND
58877: IFFALSE 59065
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58879: LD_ADDR_VAR 0 9
58883: PUSH
58884: LD_VAR 0 4
58888: PUSH
58889: LD_VAR 0 8
58893: PUSH
58894: LD_VAR 0 7
58898: UNION
58899: DIFF
58900: PPUSH
58901: LD_INT 4
58903: PPUSH
58904: CALL 47099 0 2
58908: ST_TO_ADDR
// p := [ ] ;
58909: LD_ADDR_VAR 0 11
58913: PUSH
58914: EMPTY
58915: ST_TO_ADDR
// if sort then
58916: LD_VAR 0 9
58920: IFFALSE 59036
// for i = 1 to 6 - sci do
58922: LD_ADDR_VAR 0 3
58926: PUSH
58927: DOUBLE
58928: LD_INT 1
58930: DEC
58931: ST_TO_ADDR
58932: LD_INT 6
58934: PUSH
58935: LD_VAR 0 8
58939: MINUS
58940: PUSH
58941: FOR_TO
58942: IFFALSE 59034
// begin if i = sort then
58944: LD_VAR 0 3
58948: PUSH
58949: LD_VAR 0 9
58953: EQUAL
58954: IFFALSE 58958
// break ;
58956: GO 59034
// if GetClass ( i ) = 4 then
58958: LD_VAR 0 3
58962: PPUSH
58963: CALL_OW 257
58967: PUSH
58968: LD_INT 4
58970: EQUAL
58971: IFFALSE 58975
// continue ;
58973: GO 58941
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58975: LD_ADDR_VAR 0 11
58979: PUSH
58980: LD_VAR 0 11
58984: PPUSH
58985: LD_VAR 0 11
58989: PUSH
58990: LD_INT 1
58992: PLUS
58993: PPUSH
58994: LD_VAR 0 9
58998: PUSH
58999: LD_VAR 0 3
59003: ARRAY
59004: PPUSH
59005: CALL_OW 2
59009: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59010: LD_ADDR_VAR 0 4
59014: PUSH
59015: LD_VAR 0 4
59019: PUSH
59020: LD_VAR 0 9
59024: PUSH
59025: LD_VAR 0 3
59029: ARRAY
59030: DIFF
59031: ST_TO_ADDR
// end ;
59032: GO 58941
59034: POP
59035: POP
// if p then
59036: LD_VAR 0 11
59040: IFFALSE 59065
// result := Replace ( result , 4 , p ) ;
59042: LD_ADDR_VAR 0 2
59046: PUSH
59047: LD_VAR 0 2
59051: PPUSH
59052: LD_INT 4
59054: PPUSH
59055: LD_VAR 0 11
59059: PPUSH
59060: CALL_OW 1
59064: ST_TO_ADDR
// end ; if tmp and mech < 6 then
59065: LD_VAR 0 4
59069: PUSH
59070: LD_VAR 0 7
59074: PUSH
59075: LD_INT 6
59077: LESS
59078: AND
59079: IFFALSE 59267
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59081: LD_ADDR_VAR 0 9
59085: PUSH
59086: LD_VAR 0 4
59090: PUSH
59091: LD_VAR 0 8
59095: PUSH
59096: LD_VAR 0 7
59100: UNION
59101: DIFF
59102: PPUSH
59103: LD_INT 3
59105: PPUSH
59106: CALL 47099 0 2
59110: ST_TO_ADDR
// p := [ ] ;
59111: LD_ADDR_VAR 0 11
59115: PUSH
59116: EMPTY
59117: ST_TO_ADDR
// if sort then
59118: LD_VAR 0 9
59122: IFFALSE 59238
// for i = 1 to 6 - mech do
59124: LD_ADDR_VAR 0 3
59128: PUSH
59129: DOUBLE
59130: LD_INT 1
59132: DEC
59133: ST_TO_ADDR
59134: LD_INT 6
59136: PUSH
59137: LD_VAR 0 7
59141: MINUS
59142: PUSH
59143: FOR_TO
59144: IFFALSE 59236
// begin if i = sort then
59146: LD_VAR 0 3
59150: PUSH
59151: LD_VAR 0 9
59155: EQUAL
59156: IFFALSE 59160
// break ;
59158: GO 59236
// if GetClass ( i ) = 3 then
59160: LD_VAR 0 3
59164: PPUSH
59165: CALL_OW 257
59169: PUSH
59170: LD_INT 3
59172: EQUAL
59173: IFFALSE 59177
// continue ;
59175: GO 59143
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59177: LD_ADDR_VAR 0 11
59181: PUSH
59182: LD_VAR 0 11
59186: PPUSH
59187: LD_VAR 0 11
59191: PUSH
59192: LD_INT 1
59194: PLUS
59195: PPUSH
59196: LD_VAR 0 9
59200: PUSH
59201: LD_VAR 0 3
59205: ARRAY
59206: PPUSH
59207: CALL_OW 2
59211: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59212: LD_ADDR_VAR 0 4
59216: PUSH
59217: LD_VAR 0 4
59221: PUSH
59222: LD_VAR 0 9
59226: PUSH
59227: LD_VAR 0 3
59231: ARRAY
59232: DIFF
59233: ST_TO_ADDR
// end ;
59234: GO 59143
59236: POP
59237: POP
// if p then
59238: LD_VAR 0 11
59242: IFFALSE 59267
// result := Replace ( result , 3 , p ) ;
59244: LD_ADDR_VAR 0 2
59248: PUSH
59249: LD_VAR 0 2
59253: PPUSH
59254: LD_INT 3
59256: PPUSH
59257: LD_VAR 0 11
59261: PPUSH
59262: CALL_OW 1
59266: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59267: LD_VAR 0 4
59271: PUSH
59272: LD_INT 6
59274: GREATER
59275: PUSH
59276: LD_VAR 0 6
59280: PUSH
59281: LD_INT 6
59283: LESS
59284: AND
59285: IFFALSE 59479
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59287: LD_ADDR_VAR 0 9
59291: PUSH
59292: LD_VAR 0 4
59296: PUSH
59297: LD_VAR 0 8
59301: PUSH
59302: LD_VAR 0 7
59306: UNION
59307: PUSH
59308: LD_VAR 0 6
59312: UNION
59313: DIFF
59314: PPUSH
59315: LD_INT 2
59317: PPUSH
59318: CALL 47099 0 2
59322: ST_TO_ADDR
// p := [ ] ;
59323: LD_ADDR_VAR 0 11
59327: PUSH
59328: EMPTY
59329: ST_TO_ADDR
// if sort then
59330: LD_VAR 0 9
59334: IFFALSE 59450
// for i = 1 to 6 - eng do
59336: LD_ADDR_VAR 0 3
59340: PUSH
59341: DOUBLE
59342: LD_INT 1
59344: DEC
59345: ST_TO_ADDR
59346: LD_INT 6
59348: PUSH
59349: LD_VAR 0 6
59353: MINUS
59354: PUSH
59355: FOR_TO
59356: IFFALSE 59448
// begin if i = sort then
59358: LD_VAR 0 3
59362: PUSH
59363: LD_VAR 0 9
59367: EQUAL
59368: IFFALSE 59372
// break ;
59370: GO 59448
// if GetClass ( i ) = 2 then
59372: LD_VAR 0 3
59376: PPUSH
59377: CALL_OW 257
59381: PUSH
59382: LD_INT 2
59384: EQUAL
59385: IFFALSE 59389
// continue ;
59387: GO 59355
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59389: LD_ADDR_VAR 0 11
59393: PUSH
59394: LD_VAR 0 11
59398: PPUSH
59399: LD_VAR 0 11
59403: PUSH
59404: LD_INT 1
59406: PLUS
59407: PPUSH
59408: LD_VAR 0 9
59412: PUSH
59413: LD_VAR 0 3
59417: ARRAY
59418: PPUSH
59419: CALL_OW 2
59423: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59424: LD_ADDR_VAR 0 4
59428: PUSH
59429: LD_VAR 0 4
59433: PUSH
59434: LD_VAR 0 9
59438: PUSH
59439: LD_VAR 0 3
59443: ARRAY
59444: DIFF
59445: ST_TO_ADDR
// end ;
59446: GO 59355
59448: POP
59449: POP
// if p then
59450: LD_VAR 0 11
59454: IFFALSE 59479
// result := Replace ( result , 2 , p ) ;
59456: LD_ADDR_VAR 0 2
59460: PUSH
59461: LD_VAR 0 2
59465: PPUSH
59466: LD_INT 2
59468: PPUSH
59469: LD_VAR 0 11
59473: PPUSH
59474: CALL_OW 1
59478: ST_TO_ADDR
// end ; exit ;
59479: GO 60867
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59481: LD_EXP 50
59485: PUSH
59486: LD_EXP 49
59490: PUSH
59491: LD_VAR 0 1
59495: ARRAY
59496: ARRAY
59497: NOT
59498: PUSH
59499: LD_EXP 23
59503: PUSH
59504: LD_VAR 0 1
59508: ARRAY
59509: PPUSH
59510: LD_INT 30
59512: PUSH
59513: LD_INT 3
59515: PUSH
59516: EMPTY
59517: LIST
59518: LIST
59519: PPUSH
59520: CALL_OW 72
59524: AND
59525: PUSH
59526: LD_EXP 28
59530: PUSH
59531: LD_VAR 0 1
59535: ARRAY
59536: AND
59537: IFFALSE 60145
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59539: LD_ADDR_EXP 65
59543: PUSH
59544: LD_EXP 65
59548: PPUSH
59549: LD_VAR 0 1
59553: PPUSH
59554: LD_INT 5
59556: PPUSH
59557: CALL_OW 1
59561: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59562: LD_ADDR_VAR 0 2
59566: PUSH
59567: LD_INT 0
59569: PUSH
59570: LD_INT 0
59572: PUSH
59573: LD_INT 0
59575: PUSH
59576: LD_INT 0
59578: PUSH
59579: EMPTY
59580: LIST
59581: LIST
59582: LIST
59583: LIST
59584: ST_TO_ADDR
// if sci > 1 then
59585: LD_VAR 0 8
59589: PUSH
59590: LD_INT 1
59592: GREATER
59593: IFFALSE 59621
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59595: LD_ADDR_VAR 0 4
59599: PUSH
59600: LD_VAR 0 4
59604: PUSH
59605: LD_VAR 0 8
59609: PUSH
59610: LD_VAR 0 8
59614: PUSH
59615: LD_INT 1
59617: ARRAY
59618: DIFF
59619: DIFF
59620: ST_TO_ADDR
// if tmp and not sci then
59621: LD_VAR 0 4
59625: PUSH
59626: LD_VAR 0 8
59630: NOT
59631: AND
59632: IFFALSE 59701
// begin sort := SortBySkill ( tmp , 4 ) ;
59634: LD_ADDR_VAR 0 9
59638: PUSH
59639: LD_VAR 0 4
59643: PPUSH
59644: LD_INT 4
59646: PPUSH
59647: CALL 47099 0 2
59651: ST_TO_ADDR
// if sort then
59652: LD_VAR 0 9
59656: IFFALSE 59672
// p := sort [ 1 ] ;
59658: LD_ADDR_VAR 0 11
59662: PUSH
59663: LD_VAR 0 9
59667: PUSH
59668: LD_INT 1
59670: ARRAY
59671: ST_TO_ADDR
// if p then
59672: LD_VAR 0 11
59676: IFFALSE 59701
// result := Replace ( result , 4 , p ) ;
59678: LD_ADDR_VAR 0 2
59682: PUSH
59683: LD_VAR 0 2
59687: PPUSH
59688: LD_INT 4
59690: PPUSH
59691: LD_VAR 0 11
59695: PPUSH
59696: CALL_OW 1
59700: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59701: LD_ADDR_VAR 0 4
59705: PUSH
59706: LD_VAR 0 4
59710: PUSH
59711: LD_VAR 0 7
59715: DIFF
59716: ST_TO_ADDR
// if tmp and mech < 6 then
59717: LD_VAR 0 4
59721: PUSH
59722: LD_VAR 0 7
59726: PUSH
59727: LD_INT 6
59729: LESS
59730: AND
59731: IFFALSE 59919
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59733: LD_ADDR_VAR 0 9
59737: PUSH
59738: LD_VAR 0 4
59742: PUSH
59743: LD_VAR 0 8
59747: PUSH
59748: LD_VAR 0 7
59752: UNION
59753: DIFF
59754: PPUSH
59755: LD_INT 3
59757: PPUSH
59758: CALL 47099 0 2
59762: ST_TO_ADDR
// p := [ ] ;
59763: LD_ADDR_VAR 0 11
59767: PUSH
59768: EMPTY
59769: ST_TO_ADDR
// if sort then
59770: LD_VAR 0 9
59774: IFFALSE 59890
// for i = 1 to 6 - mech do
59776: LD_ADDR_VAR 0 3
59780: PUSH
59781: DOUBLE
59782: LD_INT 1
59784: DEC
59785: ST_TO_ADDR
59786: LD_INT 6
59788: PUSH
59789: LD_VAR 0 7
59793: MINUS
59794: PUSH
59795: FOR_TO
59796: IFFALSE 59888
// begin if i = sort then
59798: LD_VAR 0 3
59802: PUSH
59803: LD_VAR 0 9
59807: EQUAL
59808: IFFALSE 59812
// break ;
59810: GO 59888
// if GetClass ( i ) = 3 then
59812: LD_VAR 0 3
59816: PPUSH
59817: CALL_OW 257
59821: PUSH
59822: LD_INT 3
59824: EQUAL
59825: IFFALSE 59829
// continue ;
59827: GO 59795
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59829: LD_ADDR_VAR 0 11
59833: PUSH
59834: LD_VAR 0 11
59838: PPUSH
59839: LD_VAR 0 11
59843: PUSH
59844: LD_INT 1
59846: PLUS
59847: PPUSH
59848: LD_VAR 0 9
59852: PUSH
59853: LD_VAR 0 3
59857: ARRAY
59858: PPUSH
59859: CALL_OW 2
59863: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59864: LD_ADDR_VAR 0 4
59868: PUSH
59869: LD_VAR 0 4
59873: PUSH
59874: LD_VAR 0 9
59878: PUSH
59879: LD_VAR 0 3
59883: ARRAY
59884: DIFF
59885: ST_TO_ADDR
// end ;
59886: GO 59795
59888: POP
59889: POP
// if p then
59890: LD_VAR 0 11
59894: IFFALSE 59919
// result := Replace ( result , 3 , p ) ;
59896: LD_ADDR_VAR 0 2
59900: PUSH
59901: LD_VAR 0 2
59905: PPUSH
59906: LD_INT 3
59908: PPUSH
59909: LD_VAR 0 11
59913: PPUSH
59914: CALL_OW 1
59918: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59919: LD_ADDR_VAR 0 4
59923: PUSH
59924: LD_VAR 0 4
59928: PUSH
59929: LD_VAR 0 6
59933: DIFF
59934: ST_TO_ADDR
// if tmp and eng < 6 then
59935: LD_VAR 0 4
59939: PUSH
59940: LD_VAR 0 6
59944: PUSH
59945: LD_INT 6
59947: LESS
59948: AND
59949: IFFALSE 60143
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59951: LD_ADDR_VAR 0 9
59955: PUSH
59956: LD_VAR 0 4
59960: PUSH
59961: LD_VAR 0 8
59965: PUSH
59966: LD_VAR 0 7
59970: UNION
59971: PUSH
59972: LD_VAR 0 6
59976: UNION
59977: DIFF
59978: PPUSH
59979: LD_INT 2
59981: PPUSH
59982: CALL 47099 0 2
59986: ST_TO_ADDR
// p := [ ] ;
59987: LD_ADDR_VAR 0 11
59991: PUSH
59992: EMPTY
59993: ST_TO_ADDR
// if sort then
59994: LD_VAR 0 9
59998: IFFALSE 60114
// for i = 1 to 6 - eng do
60000: LD_ADDR_VAR 0 3
60004: PUSH
60005: DOUBLE
60006: LD_INT 1
60008: DEC
60009: ST_TO_ADDR
60010: LD_INT 6
60012: PUSH
60013: LD_VAR 0 6
60017: MINUS
60018: PUSH
60019: FOR_TO
60020: IFFALSE 60112
// begin if i = sort then
60022: LD_VAR 0 3
60026: PUSH
60027: LD_VAR 0 9
60031: EQUAL
60032: IFFALSE 60036
// break ;
60034: GO 60112
// if GetClass ( i ) = 2 then
60036: LD_VAR 0 3
60040: PPUSH
60041: CALL_OW 257
60045: PUSH
60046: LD_INT 2
60048: EQUAL
60049: IFFALSE 60053
// continue ;
60051: GO 60019
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60053: LD_ADDR_VAR 0 11
60057: PUSH
60058: LD_VAR 0 11
60062: PPUSH
60063: LD_VAR 0 11
60067: PUSH
60068: LD_INT 1
60070: PLUS
60071: PPUSH
60072: LD_VAR 0 9
60076: PUSH
60077: LD_VAR 0 3
60081: ARRAY
60082: PPUSH
60083: CALL_OW 2
60087: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60088: LD_ADDR_VAR 0 4
60092: PUSH
60093: LD_VAR 0 4
60097: PUSH
60098: LD_VAR 0 9
60102: PUSH
60103: LD_VAR 0 3
60107: ARRAY
60108: DIFF
60109: ST_TO_ADDR
// end ;
60110: GO 60019
60112: POP
60113: POP
// if p then
60114: LD_VAR 0 11
60118: IFFALSE 60143
// result := Replace ( result , 2 , p ) ;
60120: LD_ADDR_VAR 0 2
60124: PUSH
60125: LD_VAR 0 2
60129: PPUSH
60130: LD_INT 2
60132: PPUSH
60133: LD_VAR 0 11
60137: PPUSH
60138: CALL_OW 1
60142: ST_TO_ADDR
// end ; exit ;
60143: GO 60867
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
60145: LD_EXP 50
60149: PUSH
60150: LD_EXP 49
60154: PUSH
60155: LD_VAR 0 1
60159: ARRAY
60160: ARRAY
60161: NOT
60162: PUSH
60163: LD_EXP 23
60167: PUSH
60168: LD_VAR 0 1
60172: ARRAY
60173: PPUSH
60174: LD_INT 30
60176: PUSH
60177: LD_INT 3
60179: PUSH
60180: EMPTY
60181: LIST
60182: LIST
60183: PPUSH
60184: CALL_OW 72
60188: AND
60189: PUSH
60190: LD_EXP 28
60194: PUSH
60195: LD_VAR 0 1
60199: ARRAY
60200: NOT
60201: AND
60202: IFFALSE 60867
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60204: LD_ADDR_EXP 65
60208: PUSH
60209: LD_EXP 65
60213: PPUSH
60214: LD_VAR 0 1
60218: PPUSH
60219: LD_INT 6
60221: PPUSH
60222: CALL_OW 1
60226: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60227: LD_ADDR_VAR 0 2
60231: PUSH
60232: LD_INT 0
60234: PUSH
60235: LD_INT 0
60237: PUSH
60238: LD_INT 0
60240: PUSH
60241: LD_INT 0
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: LIST
60248: LIST
60249: ST_TO_ADDR
// if sci >= 1 then
60250: LD_VAR 0 8
60254: PUSH
60255: LD_INT 1
60257: GREATEREQUAL
60258: IFFALSE 60280
// tmp := tmp diff sci [ 1 ] ;
60260: LD_ADDR_VAR 0 4
60264: PUSH
60265: LD_VAR 0 4
60269: PUSH
60270: LD_VAR 0 8
60274: PUSH
60275: LD_INT 1
60277: ARRAY
60278: DIFF
60279: ST_TO_ADDR
// if tmp and not sci then
60280: LD_VAR 0 4
60284: PUSH
60285: LD_VAR 0 8
60289: NOT
60290: AND
60291: IFFALSE 60360
// begin sort := SortBySkill ( tmp , 4 ) ;
60293: LD_ADDR_VAR 0 9
60297: PUSH
60298: LD_VAR 0 4
60302: PPUSH
60303: LD_INT 4
60305: PPUSH
60306: CALL 47099 0 2
60310: ST_TO_ADDR
// if sort then
60311: LD_VAR 0 9
60315: IFFALSE 60331
// p := sort [ 1 ] ;
60317: LD_ADDR_VAR 0 11
60321: PUSH
60322: LD_VAR 0 9
60326: PUSH
60327: LD_INT 1
60329: ARRAY
60330: ST_TO_ADDR
// if p then
60331: LD_VAR 0 11
60335: IFFALSE 60360
// result := Replace ( result , 4 , p ) ;
60337: LD_ADDR_VAR 0 2
60341: PUSH
60342: LD_VAR 0 2
60346: PPUSH
60347: LD_INT 4
60349: PPUSH
60350: LD_VAR 0 11
60354: PPUSH
60355: CALL_OW 1
60359: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60360: LD_ADDR_VAR 0 4
60364: PUSH
60365: LD_VAR 0 4
60369: PUSH
60370: LD_VAR 0 7
60374: DIFF
60375: ST_TO_ADDR
// if tmp and mech < 6 then
60376: LD_VAR 0 4
60380: PUSH
60381: LD_VAR 0 7
60385: PUSH
60386: LD_INT 6
60388: LESS
60389: AND
60390: IFFALSE 60572
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60392: LD_ADDR_VAR 0 9
60396: PUSH
60397: LD_VAR 0 4
60401: PUSH
60402: LD_VAR 0 7
60406: DIFF
60407: PPUSH
60408: LD_INT 3
60410: PPUSH
60411: CALL 47099 0 2
60415: ST_TO_ADDR
// p := [ ] ;
60416: LD_ADDR_VAR 0 11
60420: PUSH
60421: EMPTY
60422: ST_TO_ADDR
// if sort then
60423: LD_VAR 0 9
60427: IFFALSE 60543
// for i = 1 to 6 - mech do
60429: LD_ADDR_VAR 0 3
60433: PUSH
60434: DOUBLE
60435: LD_INT 1
60437: DEC
60438: ST_TO_ADDR
60439: LD_INT 6
60441: PUSH
60442: LD_VAR 0 7
60446: MINUS
60447: PUSH
60448: FOR_TO
60449: IFFALSE 60541
// begin if i = sort then
60451: LD_VAR 0 3
60455: PUSH
60456: LD_VAR 0 9
60460: EQUAL
60461: IFFALSE 60465
// break ;
60463: GO 60541
// if GetClass ( i ) = 3 then
60465: LD_VAR 0 3
60469: PPUSH
60470: CALL_OW 257
60474: PUSH
60475: LD_INT 3
60477: EQUAL
60478: IFFALSE 60482
// continue ;
60480: GO 60448
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60482: LD_ADDR_VAR 0 11
60486: PUSH
60487: LD_VAR 0 11
60491: PPUSH
60492: LD_VAR 0 11
60496: PUSH
60497: LD_INT 1
60499: PLUS
60500: PPUSH
60501: LD_VAR 0 9
60505: PUSH
60506: LD_VAR 0 3
60510: ARRAY
60511: PPUSH
60512: CALL_OW 2
60516: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60517: LD_ADDR_VAR 0 4
60521: PUSH
60522: LD_VAR 0 4
60526: PUSH
60527: LD_VAR 0 9
60531: PUSH
60532: LD_VAR 0 3
60536: ARRAY
60537: DIFF
60538: ST_TO_ADDR
// end ;
60539: GO 60448
60541: POP
60542: POP
// if p then
60543: LD_VAR 0 11
60547: IFFALSE 60572
// result := Replace ( result , 3 , p ) ;
60549: LD_ADDR_VAR 0 2
60553: PUSH
60554: LD_VAR 0 2
60558: PPUSH
60559: LD_INT 3
60561: PPUSH
60562: LD_VAR 0 11
60566: PPUSH
60567: CALL_OW 1
60571: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60572: LD_ADDR_VAR 0 4
60576: PUSH
60577: LD_VAR 0 4
60581: PUSH
60582: LD_VAR 0 6
60586: DIFF
60587: ST_TO_ADDR
// if tmp and eng < 4 then
60588: LD_VAR 0 4
60592: PUSH
60593: LD_VAR 0 6
60597: PUSH
60598: LD_INT 4
60600: LESS
60601: AND
60602: IFFALSE 60792
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60604: LD_ADDR_VAR 0 9
60608: PUSH
60609: LD_VAR 0 4
60613: PUSH
60614: LD_VAR 0 7
60618: PUSH
60619: LD_VAR 0 6
60623: UNION
60624: DIFF
60625: PPUSH
60626: LD_INT 2
60628: PPUSH
60629: CALL 47099 0 2
60633: ST_TO_ADDR
// p := [ ] ;
60634: LD_ADDR_VAR 0 11
60638: PUSH
60639: EMPTY
60640: ST_TO_ADDR
// if sort then
60641: LD_VAR 0 9
60645: IFFALSE 60761
// for i = 1 to 4 - eng do
60647: LD_ADDR_VAR 0 3
60651: PUSH
60652: DOUBLE
60653: LD_INT 1
60655: DEC
60656: ST_TO_ADDR
60657: LD_INT 4
60659: PUSH
60660: LD_VAR 0 6
60664: MINUS
60665: PUSH
60666: FOR_TO
60667: IFFALSE 60759
// begin if i = sort then
60669: LD_VAR 0 3
60673: PUSH
60674: LD_VAR 0 9
60678: EQUAL
60679: IFFALSE 60683
// break ;
60681: GO 60759
// if GetClass ( i ) = 2 then
60683: LD_VAR 0 3
60687: PPUSH
60688: CALL_OW 257
60692: PUSH
60693: LD_INT 2
60695: EQUAL
60696: IFFALSE 60700
// continue ;
60698: GO 60666
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60700: LD_ADDR_VAR 0 11
60704: PUSH
60705: LD_VAR 0 11
60709: PPUSH
60710: LD_VAR 0 11
60714: PUSH
60715: LD_INT 1
60717: PLUS
60718: PPUSH
60719: LD_VAR 0 9
60723: PUSH
60724: LD_VAR 0 3
60728: ARRAY
60729: PPUSH
60730: CALL_OW 2
60734: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60735: LD_ADDR_VAR 0 4
60739: PUSH
60740: LD_VAR 0 4
60744: PUSH
60745: LD_VAR 0 9
60749: PUSH
60750: LD_VAR 0 3
60754: ARRAY
60755: DIFF
60756: ST_TO_ADDR
// end ;
60757: GO 60666
60759: POP
60760: POP
// if p then
60761: LD_VAR 0 11
60765: IFFALSE 60790
// result := Replace ( result , 2 , p ) ;
60767: LD_ADDR_VAR 0 2
60771: PUSH
60772: LD_VAR 0 2
60776: PPUSH
60777: LD_INT 2
60779: PPUSH
60780: LD_VAR 0 11
60784: PPUSH
60785: CALL_OW 1
60789: ST_TO_ADDR
// end else
60790: GO 60836
// for i = eng downto 5 do
60792: LD_ADDR_VAR 0 3
60796: PUSH
60797: DOUBLE
60798: LD_VAR 0 6
60802: INC
60803: ST_TO_ADDR
60804: LD_INT 5
60806: PUSH
60807: FOR_DOWNTO
60808: IFFALSE 60834
// tmp := tmp union eng [ i ] ;
60810: LD_ADDR_VAR 0 4
60814: PUSH
60815: LD_VAR 0 4
60819: PUSH
60820: LD_VAR 0 6
60824: PUSH
60825: LD_VAR 0 3
60829: ARRAY
60830: UNION
60831: ST_TO_ADDR
60832: GO 60807
60834: POP
60835: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60836: LD_ADDR_VAR 0 2
60840: PUSH
60841: LD_VAR 0 2
60845: PPUSH
60846: LD_INT 1
60848: PPUSH
60849: LD_VAR 0 4
60853: PUSH
60854: LD_VAR 0 5
60858: DIFF
60859: PPUSH
60860: CALL_OW 1
60864: ST_TO_ADDR
// exit ;
60865: GO 60867
// end ; end ;
60867: LD_VAR 0 2
60871: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60872: LD_INT 0
60874: PPUSH
60875: PPUSH
60876: PPUSH
// if not mc_bases then
60877: LD_EXP 23
60881: NOT
60882: IFFALSE 60886
// exit ;
60884: GO 61028
// for i = 1 to mc_bases do
60886: LD_ADDR_VAR 0 2
60890: PUSH
60891: DOUBLE
60892: LD_INT 1
60894: DEC
60895: ST_TO_ADDR
60896: LD_EXP 23
60900: PUSH
60901: FOR_TO
60902: IFFALSE 61019
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60904: LD_ADDR_VAR 0 3
60908: PUSH
60909: LD_EXP 23
60913: PUSH
60914: LD_VAR 0 2
60918: ARRAY
60919: PPUSH
60920: LD_INT 21
60922: PUSH
60923: LD_INT 3
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PUSH
60930: LD_INT 3
60932: PUSH
60933: LD_INT 2
60935: PUSH
60936: LD_INT 30
60938: PUSH
60939: LD_INT 29
60941: PUSH
60942: EMPTY
60943: LIST
60944: LIST
60945: PUSH
60946: LD_INT 30
60948: PUSH
60949: LD_INT 30
60951: PUSH
60952: EMPTY
60953: LIST
60954: LIST
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: LIST
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: PUSH
60965: LD_INT 3
60967: PUSH
60968: LD_INT 24
60970: PUSH
60971: LD_INT 1000
60973: PUSH
60974: EMPTY
60975: LIST
60976: LIST
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: LIST
60986: PPUSH
60987: CALL_OW 72
60991: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60992: LD_ADDR_EXP 24
60996: PUSH
60997: LD_EXP 24
61001: PPUSH
61002: LD_VAR 0 2
61006: PPUSH
61007: LD_VAR 0 3
61011: PPUSH
61012: CALL_OW 1
61016: ST_TO_ADDR
// end ;
61017: GO 60901
61019: POP
61020: POP
// RaiseSailEvent ( 101 ) ;
61021: LD_INT 101
61023: PPUSH
61024: CALL_OW 427
// end ;
61028: LD_VAR 0 1
61032: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
61033: LD_INT 0
61035: PPUSH
61036: PPUSH
61037: PPUSH
61038: PPUSH
61039: PPUSH
61040: PPUSH
61041: PPUSH
// if not mc_bases then
61042: LD_EXP 23
61046: NOT
61047: IFFALSE 61051
// exit ;
61049: GO 61613
// for i = 1 to mc_bases do
61051: LD_ADDR_VAR 0 2
61055: PUSH
61056: DOUBLE
61057: LD_INT 1
61059: DEC
61060: ST_TO_ADDR
61061: LD_EXP 23
61065: PUSH
61066: FOR_TO
61067: IFFALSE 61604
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
61069: LD_ADDR_VAR 0 5
61073: PUSH
61074: LD_EXP 23
61078: PUSH
61079: LD_VAR 0 2
61083: ARRAY
61084: PUSH
61085: LD_EXP 52
61089: PUSH
61090: LD_VAR 0 2
61094: ARRAY
61095: UNION
61096: PPUSH
61097: LD_INT 21
61099: PUSH
61100: LD_INT 1
61102: PUSH
61103: EMPTY
61104: LIST
61105: LIST
61106: PUSH
61107: LD_INT 1
61109: PUSH
61110: LD_INT 3
61112: PUSH
61113: LD_INT 54
61115: PUSH
61116: EMPTY
61117: LIST
61118: PUSH
61119: EMPTY
61120: LIST
61121: LIST
61122: PUSH
61123: LD_INT 3
61125: PUSH
61126: LD_INT 24
61128: PUSH
61129: LD_INT 1000
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: EMPTY
61137: LIST
61138: LIST
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: LIST
61144: PUSH
61145: EMPTY
61146: LIST
61147: LIST
61148: PPUSH
61149: CALL_OW 72
61153: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61154: LD_ADDR_VAR 0 6
61158: PUSH
61159: LD_EXP 23
61163: PUSH
61164: LD_VAR 0 2
61168: ARRAY
61169: PPUSH
61170: LD_INT 21
61172: PUSH
61173: LD_INT 1
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: PUSH
61180: LD_INT 1
61182: PUSH
61183: LD_INT 3
61185: PUSH
61186: LD_INT 54
61188: PUSH
61189: EMPTY
61190: LIST
61191: PUSH
61192: EMPTY
61193: LIST
61194: LIST
61195: PUSH
61196: LD_INT 3
61198: PUSH
61199: LD_INT 24
61201: PUSH
61202: LD_INT 250
61204: PUSH
61205: EMPTY
61206: LIST
61207: LIST
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: LIST
61217: PUSH
61218: EMPTY
61219: LIST
61220: LIST
61221: PPUSH
61222: CALL_OW 72
61226: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61227: LD_ADDR_VAR 0 7
61231: PUSH
61232: LD_VAR 0 5
61236: PUSH
61237: LD_VAR 0 6
61241: DIFF
61242: ST_TO_ADDR
// if not need_heal_1 then
61243: LD_VAR 0 6
61247: NOT
61248: IFFALSE 61281
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61250: LD_ADDR_EXP 26
61254: PUSH
61255: LD_EXP 26
61259: PPUSH
61260: LD_VAR 0 2
61264: PUSH
61265: LD_INT 1
61267: PUSH
61268: EMPTY
61269: LIST
61270: LIST
61271: PPUSH
61272: EMPTY
61273: PPUSH
61274: CALL 16252 0 3
61278: ST_TO_ADDR
61279: GO 61351
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61281: LD_ADDR_EXP 26
61285: PUSH
61286: LD_EXP 26
61290: PPUSH
61291: LD_VAR 0 2
61295: PUSH
61296: LD_INT 1
61298: PUSH
61299: EMPTY
61300: LIST
61301: LIST
61302: PPUSH
61303: LD_EXP 26
61307: PUSH
61308: LD_VAR 0 2
61312: ARRAY
61313: PUSH
61314: LD_INT 1
61316: ARRAY
61317: PPUSH
61318: LD_INT 3
61320: PUSH
61321: LD_INT 24
61323: PUSH
61324: LD_INT 1000
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: PPUSH
61335: CALL_OW 72
61339: PUSH
61340: LD_VAR 0 6
61344: UNION
61345: PPUSH
61346: CALL 16252 0 3
61350: ST_TO_ADDR
// if not need_heal_2 then
61351: LD_VAR 0 7
61355: NOT
61356: IFFALSE 61389
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61358: LD_ADDR_EXP 26
61362: PUSH
61363: LD_EXP 26
61367: PPUSH
61368: LD_VAR 0 2
61372: PUSH
61373: LD_INT 2
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: PPUSH
61380: EMPTY
61381: PPUSH
61382: CALL 16252 0 3
61386: ST_TO_ADDR
61387: GO 61421
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61389: LD_ADDR_EXP 26
61393: PUSH
61394: LD_EXP 26
61398: PPUSH
61399: LD_VAR 0 2
61403: PUSH
61404: LD_INT 2
61406: PUSH
61407: EMPTY
61408: LIST
61409: LIST
61410: PPUSH
61411: LD_VAR 0 7
61415: PPUSH
61416: CALL 16252 0 3
61420: ST_TO_ADDR
// if need_heal_2 then
61421: LD_VAR 0 7
61425: IFFALSE 61586
// for j in need_heal_2 do
61427: LD_ADDR_VAR 0 3
61431: PUSH
61432: LD_VAR 0 7
61436: PUSH
61437: FOR_IN
61438: IFFALSE 61584
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61440: LD_ADDR_VAR 0 5
61444: PUSH
61445: LD_EXP 23
61449: PUSH
61450: LD_VAR 0 2
61454: ARRAY
61455: PPUSH
61456: LD_INT 2
61458: PUSH
61459: LD_INT 30
61461: PUSH
61462: LD_INT 6
61464: PUSH
61465: EMPTY
61466: LIST
61467: LIST
61468: PUSH
61469: LD_INT 30
61471: PUSH
61472: LD_INT 7
61474: PUSH
61475: EMPTY
61476: LIST
61477: LIST
61478: PUSH
61479: LD_INT 30
61481: PUSH
61482: LD_INT 8
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PUSH
61489: LD_INT 30
61491: PUSH
61492: LD_INT 0
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PUSH
61499: LD_INT 30
61501: PUSH
61502: LD_INT 1
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: EMPTY
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: LIST
61515: LIST
61516: PPUSH
61517: CALL_OW 72
61521: ST_TO_ADDR
// if tmp then
61522: LD_VAR 0 5
61526: IFFALSE 61582
// begin k := NearestUnitToUnit ( tmp , j ) ;
61528: LD_ADDR_VAR 0 4
61532: PUSH
61533: LD_VAR 0 5
61537: PPUSH
61538: LD_VAR 0 3
61542: PPUSH
61543: CALL_OW 74
61547: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61548: LD_VAR 0 3
61552: PPUSH
61553: LD_VAR 0 4
61557: PPUSH
61558: CALL_OW 296
61562: PUSH
61563: LD_INT 5
61565: GREATER
61566: IFFALSE 61582
// ComMoveToNearbyEntrance ( j , k ) ;
61568: LD_VAR 0 3
61572: PPUSH
61573: LD_VAR 0 4
61577: PPUSH
61578: CALL 49460 0 2
// end ; end ;
61582: GO 61437
61584: POP
61585: POP
// if not need_heal_1 and not need_heal_2 then
61586: LD_VAR 0 6
61590: NOT
61591: PUSH
61592: LD_VAR 0 7
61596: NOT
61597: AND
61598: IFFALSE 61602
// continue ;
61600: GO 61066
// end ;
61602: GO 61066
61604: POP
61605: POP
// RaiseSailEvent ( 102 ) ;
61606: LD_INT 102
61608: PPUSH
61609: CALL_OW 427
// end ;
61613: LD_VAR 0 1
61617: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61618: LD_INT 0
61620: PPUSH
61621: PPUSH
61622: PPUSH
61623: PPUSH
61624: PPUSH
61625: PPUSH
61626: PPUSH
61627: PPUSH
// if not mc_bases then
61628: LD_EXP 23
61632: NOT
61633: IFFALSE 61637
// exit ;
61635: GO 62548
// for i = 1 to mc_bases do
61637: LD_ADDR_VAR 0 2
61641: PUSH
61642: DOUBLE
61643: LD_INT 1
61645: DEC
61646: ST_TO_ADDR
61647: LD_EXP 23
61651: PUSH
61652: FOR_TO
61653: IFFALSE 62546
// begin if not mc_building_need_repair [ i ] then
61655: LD_EXP 24
61659: PUSH
61660: LD_VAR 0 2
61664: ARRAY
61665: NOT
61666: IFFALSE 61851
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61668: LD_ADDR_VAR 0 6
61672: PUSH
61673: LD_EXP 42
61677: PUSH
61678: LD_VAR 0 2
61682: ARRAY
61683: PPUSH
61684: LD_INT 3
61686: PUSH
61687: LD_INT 24
61689: PUSH
61690: LD_INT 1000
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: PUSH
61697: EMPTY
61698: LIST
61699: LIST
61700: PUSH
61701: LD_INT 2
61703: PUSH
61704: LD_INT 34
61706: PUSH
61707: LD_INT 13
61709: PUSH
61710: EMPTY
61711: LIST
61712: LIST
61713: PUSH
61714: LD_INT 34
61716: PUSH
61717: LD_INT 52
61719: PUSH
61720: EMPTY
61721: LIST
61722: LIST
61723: PUSH
61724: LD_INT 34
61726: PUSH
61727: LD_INT 88
61729: PUSH
61730: EMPTY
61731: LIST
61732: LIST
61733: PUSH
61734: EMPTY
61735: LIST
61736: LIST
61737: LIST
61738: LIST
61739: PUSH
61740: EMPTY
61741: LIST
61742: LIST
61743: PPUSH
61744: CALL_OW 72
61748: ST_TO_ADDR
// if cranes then
61749: LD_VAR 0 6
61753: IFFALSE 61815
// for j in cranes do
61755: LD_ADDR_VAR 0 3
61759: PUSH
61760: LD_VAR 0 6
61764: PUSH
61765: FOR_IN
61766: IFFALSE 61813
// if not IsInArea ( j , mc_parking [ i ] ) then
61768: LD_VAR 0 3
61772: PPUSH
61773: LD_EXP 47
61777: PUSH
61778: LD_VAR 0 2
61782: ARRAY
61783: PPUSH
61784: CALL_OW 308
61788: NOT
61789: IFFALSE 61811
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61791: LD_VAR 0 3
61795: PPUSH
61796: LD_EXP 47
61800: PUSH
61801: LD_VAR 0 2
61805: ARRAY
61806: PPUSH
61807: CALL_OW 113
61811: GO 61765
61813: POP
61814: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61815: LD_ADDR_EXP 25
61819: PUSH
61820: LD_EXP 25
61824: PPUSH
61825: LD_VAR 0 2
61829: PPUSH
61830: EMPTY
61831: PPUSH
61832: CALL_OW 1
61836: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61837: LD_VAR 0 2
61841: PPUSH
61842: LD_INT 101
61844: PPUSH
61845: CALL 56705 0 2
// continue ;
61849: GO 61652
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61851: LD_ADDR_EXP 29
61855: PUSH
61856: LD_EXP 29
61860: PPUSH
61861: LD_VAR 0 2
61865: PPUSH
61866: EMPTY
61867: PPUSH
61868: CALL_OW 1
61872: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61873: LD_VAR 0 2
61877: PPUSH
61878: LD_INT 103
61880: PPUSH
61881: CALL 56705 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61885: LD_ADDR_VAR 0 5
61889: PUSH
61890: LD_EXP 23
61894: PUSH
61895: LD_VAR 0 2
61899: ARRAY
61900: PUSH
61901: LD_EXP 52
61905: PUSH
61906: LD_VAR 0 2
61910: ARRAY
61911: UNION
61912: PPUSH
61913: LD_INT 2
61915: PUSH
61916: LD_INT 25
61918: PUSH
61919: LD_INT 2
61921: PUSH
61922: EMPTY
61923: LIST
61924: LIST
61925: PUSH
61926: LD_INT 25
61928: PUSH
61929: LD_INT 16
61931: PUSH
61932: EMPTY
61933: LIST
61934: LIST
61935: PUSH
61936: EMPTY
61937: LIST
61938: LIST
61939: LIST
61940: PUSH
61941: EMPTY
61942: LIST
61943: PPUSH
61944: CALL_OW 72
61948: ST_TO_ADDR
// if mc_need_heal [ i ] then
61949: LD_EXP 26
61953: PUSH
61954: LD_VAR 0 2
61958: ARRAY
61959: IFFALSE 62003
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61961: LD_ADDR_VAR 0 5
61965: PUSH
61966: LD_VAR 0 5
61970: PUSH
61971: LD_EXP 26
61975: PUSH
61976: LD_VAR 0 2
61980: ARRAY
61981: PUSH
61982: LD_INT 1
61984: ARRAY
61985: PUSH
61986: LD_EXP 26
61990: PUSH
61991: LD_VAR 0 2
61995: ARRAY
61996: PUSH
61997: LD_INT 2
61999: ARRAY
62000: UNION
62001: DIFF
62002: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
62003: LD_ADDR_VAR 0 6
62007: PUSH
62008: LD_EXP 42
62012: PUSH
62013: LD_VAR 0 2
62017: ARRAY
62018: PPUSH
62019: LD_INT 2
62021: PUSH
62022: LD_INT 34
62024: PUSH
62025: LD_INT 13
62027: PUSH
62028: EMPTY
62029: LIST
62030: LIST
62031: PUSH
62032: LD_INT 34
62034: PUSH
62035: LD_INT 52
62037: PUSH
62038: EMPTY
62039: LIST
62040: LIST
62041: PUSH
62042: LD_INT 34
62044: PUSH
62045: LD_INT 88
62047: PUSH
62048: EMPTY
62049: LIST
62050: LIST
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: LIST
62056: LIST
62057: PPUSH
62058: CALL_OW 72
62062: ST_TO_ADDR
// if cranes then
62063: LD_VAR 0 6
62067: IFFALSE 62235
// begin for j in cranes do
62069: LD_ADDR_VAR 0 3
62073: PUSH
62074: LD_VAR 0 6
62078: PUSH
62079: FOR_IN
62080: IFFALSE 62233
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
62082: LD_VAR 0 3
62086: PPUSH
62087: CALL_OW 256
62091: PUSH
62092: LD_INT 1000
62094: EQUAL
62095: PUSH
62096: LD_VAR 0 3
62100: PPUSH
62101: CALL_OW 314
62105: NOT
62106: AND
62107: IFFALSE 62173
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
62109: LD_ADDR_VAR 0 8
62113: PUSH
62114: LD_EXP 24
62118: PUSH
62119: LD_VAR 0 2
62123: ARRAY
62124: PPUSH
62125: LD_VAR 0 3
62129: PPUSH
62130: CALL_OW 74
62134: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
62135: LD_VAR 0 8
62139: PPUSH
62140: LD_INT 16
62142: PPUSH
62143: CALL 18849 0 2
62147: PUSH
62148: LD_INT 4
62150: ARRAY
62151: PUSH
62152: LD_INT 10
62154: LESS
62155: IFFALSE 62171
// ComRepairBuilding ( j , to_repair ) ;
62157: LD_VAR 0 3
62161: PPUSH
62162: LD_VAR 0 8
62166: PPUSH
62167: CALL_OW 130
// end else
62171: GO 62231
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62173: LD_VAR 0 3
62177: PPUSH
62178: CALL_OW 256
62182: PUSH
62183: LD_INT 500
62185: LESS
62186: PUSH
62187: LD_VAR 0 3
62191: PPUSH
62192: LD_EXP 47
62196: PUSH
62197: LD_VAR 0 2
62201: ARRAY
62202: PPUSH
62203: CALL_OW 308
62207: NOT
62208: AND
62209: IFFALSE 62231
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62211: LD_VAR 0 3
62215: PPUSH
62216: LD_EXP 47
62220: PUSH
62221: LD_VAR 0 2
62225: ARRAY
62226: PPUSH
62227: CALL_OW 113
// end ;
62231: GO 62079
62233: POP
62234: POP
// end ; if tmp > 3 then
62235: LD_VAR 0 5
62239: PUSH
62240: LD_INT 3
62242: GREATER
62243: IFFALSE 62263
// tmp := ShrinkArray ( tmp , 4 ) ;
62245: LD_ADDR_VAR 0 5
62249: PUSH
62250: LD_VAR 0 5
62254: PPUSH
62255: LD_INT 4
62257: PPUSH
62258: CALL 48898 0 2
62262: ST_TO_ADDR
// if not tmp then
62263: LD_VAR 0 5
62267: NOT
62268: IFFALSE 62272
// continue ;
62270: GO 61652
// for j in tmp do
62272: LD_ADDR_VAR 0 3
62276: PUSH
62277: LD_VAR 0 5
62281: PUSH
62282: FOR_IN
62283: IFFALSE 62542
// begin if IsInUnit ( j ) then
62285: LD_VAR 0 3
62289: PPUSH
62290: CALL_OW 310
62294: IFFALSE 62305
// ComExitBuilding ( j ) ;
62296: LD_VAR 0 3
62300: PPUSH
62301: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62305: LD_VAR 0 3
62309: PUSH
62310: LD_EXP 25
62314: PUSH
62315: LD_VAR 0 2
62319: ARRAY
62320: IN
62321: NOT
62322: IFFALSE 62380
// begin SetTag ( j , 101 ) ;
62324: LD_VAR 0 3
62328: PPUSH
62329: LD_INT 101
62331: PPUSH
62332: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62336: LD_ADDR_EXP 25
62340: PUSH
62341: LD_EXP 25
62345: PPUSH
62346: LD_VAR 0 2
62350: PUSH
62351: LD_EXP 25
62355: PUSH
62356: LD_VAR 0 2
62360: ARRAY
62361: PUSH
62362: LD_INT 1
62364: PLUS
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: PPUSH
62370: LD_VAR 0 3
62374: PPUSH
62375: CALL 16252 0 3
62379: ST_TO_ADDR
// end ; wait ( 1 ) ;
62380: LD_INT 1
62382: PPUSH
62383: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62387: LD_ADDR_VAR 0 7
62391: PUSH
62392: LD_EXP 24
62396: PUSH
62397: LD_VAR 0 2
62401: ARRAY
62402: ST_TO_ADDR
// if mc_scan [ i ] then
62403: LD_EXP 46
62407: PUSH
62408: LD_VAR 0 2
62412: ARRAY
62413: IFFALSE 62475
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62415: LD_ADDR_VAR 0 7
62419: PUSH
62420: LD_EXP 24
62424: PUSH
62425: LD_VAR 0 2
62429: ARRAY
62430: PPUSH
62431: LD_INT 3
62433: PUSH
62434: LD_INT 30
62436: PUSH
62437: LD_INT 32
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PUSH
62444: LD_INT 30
62446: PUSH
62447: LD_INT 33
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: PUSH
62454: LD_INT 30
62456: PUSH
62457: LD_INT 31
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: PUSH
62464: EMPTY
62465: LIST
62466: LIST
62467: LIST
62468: LIST
62469: PPUSH
62470: CALL_OW 72
62474: ST_TO_ADDR
// if not to_repair_tmp then
62475: LD_VAR 0 7
62479: NOT
62480: IFFALSE 62484
// continue ;
62482: GO 62282
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62484: LD_ADDR_VAR 0 8
62488: PUSH
62489: LD_VAR 0 7
62493: PPUSH
62494: LD_VAR 0 3
62498: PPUSH
62499: CALL_OW 74
62503: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62504: LD_VAR 0 8
62508: PPUSH
62509: LD_INT 16
62511: PPUSH
62512: CALL 18849 0 2
62516: PUSH
62517: LD_INT 4
62519: ARRAY
62520: PUSH
62521: LD_INT 14
62523: LESS
62524: IFFALSE 62540
// ComRepairBuilding ( j , to_repair ) ;
62526: LD_VAR 0 3
62530: PPUSH
62531: LD_VAR 0 8
62535: PPUSH
62536: CALL_OW 130
// end ;
62540: GO 62282
62542: POP
62543: POP
// end ;
62544: GO 61652
62546: POP
62547: POP
// end ;
62548: LD_VAR 0 1
62552: RET
// export function MC_Heal ; var i , j , tmp ; begin
62553: LD_INT 0
62555: PPUSH
62556: PPUSH
62557: PPUSH
62558: PPUSH
// if not mc_bases then
62559: LD_EXP 23
62563: NOT
62564: IFFALSE 62568
// exit ;
62566: GO 62970
// for i = 1 to mc_bases do
62568: LD_ADDR_VAR 0 2
62572: PUSH
62573: DOUBLE
62574: LD_INT 1
62576: DEC
62577: ST_TO_ADDR
62578: LD_EXP 23
62582: PUSH
62583: FOR_TO
62584: IFFALSE 62968
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62586: LD_EXP 26
62590: PUSH
62591: LD_VAR 0 2
62595: ARRAY
62596: PUSH
62597: LD_INT 1
62599: ARRAY
62600: NOT
62601: PUSH
62602: LD_EXP 26
62606: PUSH
62607: LD_VAR 0 2
62611: ARRAY
62612: PUSH
62613: LD_INT 2
62615: ARRAY
62616: NOT
62617: AND
62618: IFFALSE 62656
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62620: LD_ADDR_EXP 27
62624: PUSH
62625: LD_EXP 27
62629: PPUSH
62630: LD_VAR 0 2
62634: PPUSH
62635: EMPTY
62636: PPUSH
62637: CALL_OW 1
62641: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62642: LD_VAR 0 2
62646: PPUSH
62647: LD_INT 102
62649: PPUSH
62650: CALL 56705 0 2
// continue ;
62654: GO 62583
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62656: LD_ADDR_VAR 0 4
62660: PUSH
62661: LD_EXP 23
62665: PUSH
62666: LD_VAR 0 2
62670: ARRAY
62671: PPUSH
62672: LD_INT 25
62674: PUSH
62675: LD_INT 4
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: PPUSH
62682: CALL_OW 72
62686: ST_TO_ADDR
// if not tmp then
62687: LD_VAR 0 4
62691: NOT
62692: IFFALSE 62696
// continue ;
62694: GO 62583
// if mc_taming [ i ] then
62696: LD_EXP 54
62700: PUSH
62701: LD_VAR 0 2
62705: ARRAY
62706: IFFALSE 62730
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62708: LD_ADDR_EXP 54
62712: PUSH
62713: LD_EXP 54
62717: PPUSH
62718: LD_VAR 0 2
62722: PPUSH
62723: EMPTY
62724: PPUSH
62725: CALL_OW 1
62729: ST_TO_ADDR
// for j in tmp do
62730: LD_ADDR_VAR 0 3
62734: PUSH
62735: LD_VAR 0 4
62739: PUSH
62740: FOR_IN
62741: IFFALSE 62964
// begin if IsInUnit ( j ) then
62743: LD_VAR 0 3
62747: PPUSH
62748: CALL_OW 310
62752: IFFALSE 62763
// ComExitBuilding ( j ) ;
62754: LD_VAR 0 3
62758: PPUSH
62759: CALL_OW 122
// if not j in mc_healers [ i ] then
62763: LD_VAR 0 3
62767: PUSH
62768: LD_EXP 27
62772: PUSH
62773: LD_VAR 0 2
62777: ARRAY
62778: IN
62779: NOT
62780: IFFALSE 62826
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62782: LD_ADDR_EXP 27
62786: PUSH
62787: LD_EXP 27
62791: PPUSH
62792: LD_VAR 0 2
62796: PUSH
62797: LD_EXP 27
62801: PUSH
62802: LD_VAR 0 2
62806: ARRAY
62807: PUSH
62808: LD_INT 1
62810: PLUS
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PPUSH
62816: LD_VAR 0 3
62820: PPUSH
62821: CALL 16252 0 3
62825: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62826: LD_VAR 0 3
62830: PPUSH
62831: CALL_OW 110
62835: PUSH
62836: LD_INT 102
62838: NONEQUAL
62839: IFFALSE 62853
// SetTag ( j , 102 ) ;
62841: LD_VAR 0 3
62845: PPUSH
62846: LD_INT 102
62848: PPUSH
62849: CALL_OW 109
// Wait ( 3 ) ;
62853: LD_INT 3
62855: PPUSH
62856: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62860: LD_EXP 26
62864: PUSH
62865: LD_VAR 0 2
62869: ARRAY
62870: PUSH
62871: LD_INT 1
62873: ARRAY
62874: IFFALSE 62906
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62876: LD_VAR 0 3
62880: PPUSH
62881: LD_EXP 26
62885: PUSH
62886: LD_VAR 0 2
62890: ARRAY
62891: PUSH
62892: LD_INT 1
62894: ARRAY
62895: PUSH
62896: LD_INT 1
62898: ARRAY
62899: PPUSH
62900: CALL_OW 128
62904: GO 62962
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62906: LD_VAR 0 3
62910: PPUSH
62911: CALL_OW 314
62915: NOT
62916: PUSH
62917: LD_EXP 26
62921: PUSH
62922: LD_VAR 0 2
62926: ARRAY
62927: PUSH
62928: LD_INT 2
62930: ARRAY
62931: AND
62932: IFFALSE 62962
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62934: LD_VAR 0 3
62938: PPUSH
62939: LD_EXP 26
62943: PUSH
62944: LD_VAR 0 2
62948: ARRAY
62949: PUSH
62950: LD_INT 2
62952: ARRAY
62953: PUSH
62954: LD_INT 1
62956: ARRAY
62957: PPUSH
62958: CALL_OW 128
// end ;
62962: GO 62740
62964: POP
62965: POP
// end ;
62966: GO 62583
62968: POP
62969: POP
// end ;
62970: LD_VAR 0 1
62974: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62975: LD_INT 0
62977: PPUSH
62978: PPUSH
62979: PPUSH
62980: PPUSH
62981: PPUSH
62982: PPUSH
// if not mc_bases then
62983: LD_EXP 23
62987: NOT
62988: IFFALSE 62992
// exit ;
62990: GO 64155
// for i = 1 to mc_bases do
62992: LD_ADDR_VAR 0 2
62996: PUSH
62997: DOUBLE
62998: LD_INT 1
63000: DEC
63001: ST_TO_ADDR
63002: LD_EXP 23
63006: PUSH
63007: FOR_TO
63008: IFFALSE 64153
// begin if mc_scan [ i ] then
63010: LD_EXP 46
63014: PUSH
63015: LD_VAR 0 2
63019: ARRAY
63020: IFFALSE 63024
// continue ;
63022: GO 63007
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63024: LD_EXP 28
63028: PUSH
63029: LD_VAR 0 2
63033: ARRAY
63034: NOT
63035: PUSH
63036: LD_EXP 30
63040: PUSH
63041: LD_VAR 0 2
63045: ARRAY
63046: NOT
63047: AND
63048: PUSH
63049: LD_EXP 29
63053: PUSH
63054: LD_VAR 0 2
63058: ARRAY
63059: AND
63060: IFFALSE 63098
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
63062: LD_ADDR_EXP 29
63066: PUSH
63067: LD_EXP 29
63071: PPUSH
63072: LD_VAR 0 2
63076: PPUSH
63077: EMPTY
63078: PPUSH
63079: CALL_OW 1
63083: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63084: LD_VAR 0 2
63088: PPUSH
63089: LD_INT 103
63091: PPUSH
63092: CALL 56705 0 2
// continue ;
63096: GO 63007
// end ; if mc_construct_list [ i ] then
63098: LD_EXP 30
63102: PUSH
63103: LD_VAR 0 2
63107: ARRAY
63108: IFFALSE 63328
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63110: LD_ADDR_VAR 0 5
63114: PUSH
63115: LD_EXP 23
63119: PUSH
63120: LD_VAR 0 2
63124: ARRAY
63125: PPUSH
63126: LD_INT 25
63128: PUSH
63129: LD_INT 2
63131: PUSH
63132: EMPTY
63133: LIST
63134: LIST
63135: PPUSH
63136: CALL_OW 72
63140: PUSH
63141: LD_EXP 25
63145: PUSH
63146: LD_VAR 0 2
63150: ARRAY
63151: DIFF
63152: ST_TO_ADDR
// if not tmp then
63153: LD_VAR 0 5
63157: NOT
63158: IFFALSE 63162
// continue ;
63160: GO 63007
// for j in tmp do
63162: LD_ADDR_VAR 0 3
63166: PUSH
63167: LD_VAR 0 5
63171: PUSH
63172: FOR_IN
63173: IFFALSE 63324
// begin if not mc_builders [ i ] then
63175: LD_EXP 29
63179: PUSH
63180: LD_VAR 0 2
63184: ARRAY
63185: NOT
63186: IFFALSE 63244
// begin SetTag ( j , 103 ) ;
63188: LD_VAR 0 3
63192: PPUSH
63193: LD_INT 103
63195: PPUSH
63196: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63200: LD_ADDR_EXP 29
63204: PUSH
63205: LD_EXP 29
63209: PPUSH
63210: LD_VAR 0 2
63214: PUSH
63215: LD_EXP 29
63219: PUSH
63220: LD_VAR 0 2
63224: ARRAY
63225: PUSH
63226: LD_INT 1
63228: PLUS
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PPUSH
63234: LD_VAR 0 3
63238: PPUSH
63239: CALL 16252 0 3
63243: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63244: LD_VAR 0 3
63248: PPUSH
63249: CALL_OW 310
63253: IFFALSE 63264
// ComExitBuilding ( j ) ;
63255: LD_VAR 0 3
63259: PPUSH
63260: CALL_OW 122
// wait ( 3 ) ;
63264: LD_INT 3
63266: PPUSH
63267: CALL_OW 67
// if not mc_construct_list [ i ] then
63271: LD_EXP 30
63275: PUSH
63276: LD_VAR 0 2
63280: ARRAY
63281: NOT
63282: IFFALSE 63286
// break ;
63284: GO 63324
// if not HasTask ( j ) then
63286: LD_VAR 0 3
63290: PPUSH
63291: CALL_OW 314
63295: NOT
63296: IFFALSE 63322
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63298: LD_VAR 0 3
63302: PPUSH
63303: LD_EXP 30
63307: PUSH
63308: LD_VAR 0 2
63312: ARRAY
63313: PUSH
63314: LD_INT 1
63316: ARRAY
63317: PPUSH
63318: CALL 19113 0 2
// end ;
63322: GO 63172
63324: POP
63325: POP
// end else
63326: GO 64151
// if mc_build_list [ i ] then
63328: LD_EXP 28
63332: PUSH
63333: LD_VAR 0 2
63337: ARRAY
63338: IFFALSE 64151
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63340: LD_EXP 28
63344: PUSH
63345: LD_VAR 0 2
63349: ARRAY
63350: PUSH
63351: LD_INT 1
63353: ARRAY
63354: PUSH
63355: LD_INT 1
63357: ARRAY
63358: PPUSH
63359: CALL 18937 0 1
63363: PUSH
63364: LD_EXP 23
63368: PUSH
63369: LD_VAR 0 2
63373: ARRAY
63374: PPUSH
63375: LD_INT 2
63377: PUSH
63378: LD_INT 30
63380: PUSH
63381: LD_INT 2
63383: PUSH
63384: EMPTY
63385: LIST
63386: LIST
63387: PUSH
63388: LD_INT 30
63390: PUSH
63391: LD_INT 3
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: EMPTY
63399: LIST
63400: LIST
63401: LIST
63402: PPUSH
63403: CALL_OW 72
63407: NOT
63408: AND
63409: IFFALSE 63514
// begin for j = 1 to mc_build_list [ i ] do
63411: LD_ADDR_VAR 0 3
63415: PUSH
63416: DOUBLE
63417: LD_INT 1
63419: DEC
63420: ST_TO_ADDR
63421: LD_EXP 28
63425: PUSH
63426: LD_VAR 0 2
63430: ARRAY
63431: PUSH
63432: FOR_TO
63433: IFFALSE 63512
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63435: LD_EXP 28
63439: PUSH
63440: LD_VAR 0 2
63444: ARRAY
63445: PUSH
63446: LD_VAR 0 3
63450: ARRAY
63451: PUSH
63452: LD_INT 1
63454: ARRAY
63455: PUSH
63456: LD_INT 2
63458: EQUAL
63459: IFFALSE 63510
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63461: LD_ADDR_EXP 28
63465: PUSH
63466: LD_EXP 28
63470: PPUSH
63471: LD_VAR 0 2
63475: PPUSH
63476: LD_EXP 28
63480: PUSH
63481: LD_VAR 0 2
63485: ARRAY
63486: PPUSH
63487: LD_VAR 0 3
63491: PPUSH
63492: LD_INT 1
63494: PPUSH
63495: LD_INT 0
63497: PPUSH
63498: CALL 15670 0 4
63502: PPUSH
63503: CALL_OW 1
63507: ST_TO_ADDR
// break ;
63508: GO 63512
// end ;
63510: GO 63432
63512: POP
63513: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63514: LD_ADDR_VAR 0 6
63518: PUSH
63519: LD_EXP 23
63523: PUSH
63524: LD_VAR 0 2
63528: ARRAY
63529: PPUSH
63530: LD_INT 2
63532: PUSH
63533: LD_INT 30
63535: PUSH
63536: LD_INT 0
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 30
63545: PUSH
63546: LD_INT 1
63548: PUSH
63549: EMPTY
63550: LIST
63551: LIST
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: LIST
63557: PPUSH
63558: CALL_OW 72
63562: ST_TO_ADDR
// for k := 1 to depot do
63563: LD_ADDR_VAR 0 4
63567: PUSH
63568: DOUBLE
63569: LD_INT 1
63571: DEC
63572: ST_TO_ADDR
63573: LD_VAR 0 6
63577: PUSH
63578: FOR_TO
63579: IFFALSE 64149
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63581: LD_EXP 28
63585: PUSH
63586: LD_VAR 0 2
63590: ARRAY
63591: PUSH
63592: LD_INT 1
63594: ARRAY
63595: PUSH
63596: LD_INT 1
63598: ARRAY
63599: PUSH
63600: LD_INT 0
63602: EQUAL
63603: PUSH
63604: LD_VAR 0 6
63608: PUSH
63609: LD_VAR 0 4
63613: ARRAY
63614: PPUSH
63615: LD_EXP 28
63619: PUSH
63620: LD_VAR 0 2
63624: ARRAY
63625: PUSH
63626: LD_INT 1
63628: ARRAY
63629: PUSH
63630: LD_INT 1
63632: ARRAY
63633: PPUSH
63634: LD_EXP 28
63638: PUSH
63639: LD_VAR 0 2
63643: ARRAY
63644: PUSH
63645: LD_INT 1
63647: ARRAY
63648: PUSH
63649: LD_INT 2
63651: ARRAY
63652: PPUSH
63653: LD_EXP 28
63657: PUSH
63658: LD_VAR 0 2
63662: ARRAY
63663: PUSH
63664: LD_INT 1
63666: ARRAY
63667: PUSH
63668: LD_INT 3
63670: ARRAY
63671: PPUSH
63672: LD_EXP 28
63676: PUSH
63677: LD_VAR 0 2
63681: ARRAY
63682: PUSH
63683: LD_INT 1
63685: ARRAY
63686: PUSH
63687: LD_INT 4
63689: ARRAY
63690: PPUSH
63691: CALL 24349 0 5
63695: OR
63696: IFFALSE 63977
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63698: LD_ADDR_VAR 0 5
63702: PUSH
63703: LD_EXP 23
63707: PUSH
63708: LD_VAR 0 2
63712: ARRAY
63713: PPUSH
63714: LD_INT 25
63716: PUSH
63717: LD_INT 2
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: PPUSH
63724: CALL_OW 72
63728: PUSH
63729: LD_EXP 25
63733: PUSH
63734: LD_VAR 0 2
63738: ARRAY
63739: DIFF
63740: ST_TO_ADDR
// if not tmp then
63741: LD_VAR 0 5
63745: NOT
63746: IFFALSE 63750
// continue ;
63748: GO 63578
// for j in tmp do
63750: LD_ADDR_VAR 0 3
63754: PUSH
63755: LD_VAR 0 5
63759: PUSH
63760: FOR_IN
63761: IFFALSE 63973
// begin if not mc_builders [ i ] then
63763: LD_EXP 29
63767: PUSH
63768: LD_VAR 0 2
63772: ARRAY
63773: NOT
63774: IFFALSE 63832
// begin SetTag ( j , 103 ) ;
63776: LD_VAR 0 3
63780: PPUSH
63781: LD_INT 103
63783: PPUSH
63784: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63788: LD_ADDR_EXP 29
63792: PUSH
63793: LD_EXP 29
63797: PPUSH
63798: LD_VAR 0 2
63802: PUSH
63803: LD_EXP 29
63807: PUSH
63808: LD_VAR 0 2
63812: ARRAY
63813: PUSH
63814: LD_INT 1
63816: PLUS
63817: PUSH
63818: EMPTY
63819: LIST
63820: LIST
63821: PPUSH
63822: LD_VAR 0 3
63826: PPUSH
63827: CALL 16252 0 3
63831: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63832: LD_VAR 0 3
63836: PPUSH
63837: CALL_OW 310
63841: IFFALSE 63852
// ComExitBuilding ( j ) ;
63843: LD_VAR 0 3
63847: PPUSH
63848: CALL_OW 122
// wait ( 3 ) ;
63852: LD_INT 3
63854: PPUSH
63855: CALL_OW 67
// if not mc_build_list [ i ] then
63859: LD_EXP 28
63863: PUSH
63864: LD_VAR 0 2
63868: ARRAY
63869: NOT
63870: IFFALSE 63874
// break ;
63872: GO 63973
// if not HasTask ( j ) then
63874: LD_VAR 0 3
63878: PPUSH
63879: CALL_OW 314
63883: NOT
63884: IFFALSE 63971
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63886: LD_VAR 0 3
63890: PPUSH
63891: LD_EXP 28
63895: PUSH
63896: LD_VAR 0 2
63900: ARRAY
63901: PUSH
63902: LD_INT 1
63904: ARRAY
63905: PUSH
63906: LD_INT 1
63908: ARRAY
63909: PPUSH
63910: LD_EXP 28
63914: PUSH
63915: LD_VAR 0 2
63919: ARRAY
63920: PUSH
63921: LD_INT 1
63923: ARRAY
63924: PUSH
63925: LD_INT 2
63927: ARRAY
63928: PPUSH
63929: LD_EXP 28
63933: PUSH
63934: LD_VAR 0 2
63938: ARRAY
63939: PUSH
63940: LD_INT 1
63942: ARRAY
63943: PUSH
63944: LD_INT 3
63946: ARRAY
63947: PPUSH
63948: LD_EXP 28
63952: PUSH
63953: LD_VAR 0 2
63957: ARRAY
63958: PUSH
63959: LD_INT 1
63961: ARRAY
63962: PUSH
63963: LD_INT 4
63965: ARRAY
63966: PPUSH
63967: CALL_OW 145
// end ;
63971: GO 63760
63973: POP
63974: POP
// end else
63975: GO 64147
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63977: LD_EXP 23
63981: PUSH
63982: LD_VAR 0 2
63986: ARRAY
63987: PPUSH
63988: LD_EXP 28
63992: PUSH
63993: LD_VAR 0 2
63997: ARRAY
63998: PUSH
63999: LD_INT 1
64001: ARRAY
64002: PUSH
64003: LD_INT 1
64005: ARRAY
64006: PPUSH
64007: LD_EXP 28
64011: PUSH
64012: LD_VAR 0 2
64016: ARRAY
64017: PUSH
64018: LD_INT 1
64020: ARRAY
64021: PUSH
64022: LD_INT 2
64024: ARRAY
64025: PPUSH
64026: LD_EXP 28
64030: PUSH
64031: LD_VAR 0 2
64035: ARRAY
64036: PUSH
64037: LD_INT 1
64039: ARRAY
64040: PUSH
64041: LD_INT 3
64043: ARRAY
64044: PPUSH
64045: LD_EXP 28
64049: PUSH
64050: LD_VAR 0 2
64054: ARRAY
64055: PUSH
64056: LD_INT 1
64058: ARRAY
64059: PUSH
64060: LD_INT 4
64062: ARRAY
64063: PPUSH
64064: LD_EXP 23
64068: PUSH
64069: LD_VAR 0 2
64073: ARRAY
64074: PPUSH
64075: LD_INT 21
64077: PUSH
64078: LD_INT 3
64080: PUSH
64081: EMPTY
64082: LIST
64083: LIST
64084: PPUSH
64085: CALL_OW 72
64089: PPUSH
64090: EMPTY
64091: PPUSH
64092: CALL 23103 0 7
64096: NOT
64097: IFFALSE 64147
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
64099: LD_ADDR_EXP 28
64103: PUSH
64104: LD_EXP 28
64108: PPUSH
64109: LD_VAR 0 2
64113: PPUSH
64114: LD_EXP 28
64118: PUSH
64119: LD_VAR 0 2
64123: ARRAY
64124: PPUSH
64125: LD_INT 1
64127: PPUSH
64128: LD_INT 1
64130: NEG
64131: PPUSH
64132: LD_INT 0
64134: PPUSH
64135: CALL 15670 0 4
64139: PPUSH
64140: CALL_OW 1
64144: ST_TO_ADDR
// continue ;
64145: GO 63578
// end ; end ;
64147: GO 63578
64149: POP
64150: POP
// end ; end ;
64151: GO 63007
64153: POP
64154: POP
// end ;
64155: LD_VAR 0 1
64159: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64160: LD_INT 0
64162: PPUSH
64163: PPUSH
64164: PPUSH
64165: PPUSH
64166: PPUSH
64167: PPUSH
// if not mc_bases then
64168: LD_EXP 23
64172: NOT
64173: IFFALSE 64177
// exit ;
64175: GO 64604
// for i = 1 to mc_bases do
64177: LD_ADDR_VAR 0 2
64181: PUSH
64182: DOUBLE
64183: LD_INT 1
64185: DEC
64186: ST_TO_ADDR
64187: LD_EXP 23
64191: PUSH
64192: FOR_TO
64193: IFFALSE 64602
// begin tmp := mc_build_upgrade [ i ] ;
64195: LD_ADDR_VAR 0 4
64199: PUSH
64200: LD_EXP 55
64204: PUSH
64205: LD_VAR 0 2
64209: ARRAY
64210: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64211: LD_ADDR_VAR 0 6
64215: PUSH
64216: LD_EXP 56
64220: PUSH
64221: LD_VAR 0 2
64225: ARRAY
64226: PPUSH
64227: LD_INT 2
64229: PUSH
64230: LD_INT 30
64232: PUSH
64233: LD_INT 6
64235: PUSH
64236: EMPTY
64237: LIST
64238: LIST
64239: PUSH
64240: LD_INT 30
64242: PUSH
64243: LD_INT 7
64245: PUSH
64246: EMPTY
64247: LIST
64248: LIST
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: LIST
64254: PPUSH
64255: CALL_OW 72
64259: ST_TO_ADDR
// if not tmp and not lab then
64260: LD_VAR 0 4
64264: NOT
64265: PUSH
64266: LD_VAR 0 6
64270: NOT
64271: AND
64272: IFFALSE 64276
// continue ;
64274: GO 64192
// if tmp then
64276: LD_VAR 0 4
64280: IFFALSE 64400
// for j in tmp do
64282: LD_ADDR_VAR 0 3
64286: PUSH
64287: LD_VAR 0 4
64291: PUSH
64292: FOR_IN
64293: IFFALSE 64398
// begin if UpgradeCost ( j ) then
64295: LD_VAR 0 3
64299: PPUSH
64300: CALL 22763 0 1
64304: IFFALSE 64396
// begin ComUpgrade ( j ) ;
64306: LD_VAR 0 3
64310: PPUSH
64311: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64315: LD_ADDR_EXP 55
64319: PUSH
64320: LD_EXP 55
64324: PPUSH
64325: LD_VAR 0 2
64329: PPUSH
64330: LD_EXP 55
64334: PUSH
64335: LD_VAR 0 2
64339: ARRAY
64340: PUSH
64341: LD_VAR 0 3
64345: DIFF
64346: PPUSH
64347: CALL_OW 1
64351: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64352: LD_ADDR_EXP 30
64356: PUSH
64357: LD_EXP 30
64361: PPUSH
64362: LD_VAR 0 2
64366: PUSH
64367: LD_EXP 30
64371: PUSH
64372: LD_VAR 0 2
64376: ARRAY
64377: PUSH
64378: LD_INT 1
64380: PLUS
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PPUSH
64386: LD_VAR 0 3
64390: PPUSH
64391: CALL 16252 0 3
64395: ST_TO_ADDR
// end ; end ;
64396: GO 64292
64398: POP
64399: POP
// if not lab or not mc_lab_upgrade [ i ] then
64400: LD_VAR 0 6
64404: NOT
64405: PUSH
64406: LD_EXP 57
64410: PUSH
64411: LD_VAR 0 2
64415: ARRAY
64416: NOT
64417: OR
64418: IFFALSE 64422
// continue ;
64420: GO 64192
// for j in lab do
64422: LD_ADDR_VAR 0 3
64426: PUSH
64427: LD_VAR 0 6
64431: PUSH
64432: FOR_IN
64433: IFFALSE 64598
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64435: LD_VAR 0 3
64439: PPUSH
64440: CALL_OW 266
64444: PUSH
64445: LD_INT 6
64447: PUSH
64448: LD_INT 7
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: IN
64455: PUSH
64456: LD_VAR 0 3
64460: PPUSH
64461: CALL_OW 461
64465: PUSH
64466: LD_INT 1
64468: NONEQUAL
64469: AND
64470: IFFALSE 64596
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64472: LD_VAR 0 3
64476: PPUSH
64477: LD_EXP 57
64481: PUSH
64482: LD_VAR 0 2
64486: ARRAY
64487: PUSH
64488: LD_INT 1
64490: ARRAY
64491: PPUSH
64492: CALL 22968 0 2
64496: IFFALSE 64596
// begin ComCancel ( j ) ;
64498: LD_VAR 0 3
64502: PPUSH
64503: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64507: LD_VAR 0 3
64511: PPUSH
64512: LD_EXP 57
64516: PUSH
64517: LD_VAR 0 2
64521: ARRAY
64522: PUSH
64523: LD_INT 1
64525: ARRAY
64526: PPUSH
64527: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64531: LD_VAR 0 3
64535: PUSH
64536: LD_EXP 30
64540: PUSH
64541: LD_VAR 0 2
64545: ARRAY
64546: IN
64547: NOT
64548: IFFALSE 64594
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64550: LD_ADDR_EXP 30
64554: PUSH
64555: LD_EXP 30
64559: PPUSH
64560: LD_VAR 0 2
64564: PUSH
64565: LD_EXP 30
64569: PUSH
64570: LD_VAR 0 2
64574: ARRAY
64575: PUSH
64576: LD_INT 1
64578: PLUS
64579: PUSH
64580: EMPTY
64581: LIST
64582: LIST
64583: PPUSH
64584: LD_VAR 0 3
64588: PPUSH
64589: CALL 16252 0 3
64593: ST_TO_ADDR
// break ;
64594: GO 64598
// end ; end ; end ;
64596: GO 64432
64598: POP
64599: POP
// end ;
64600: GO 64192
64602: POP
64603: POP
// end ;
64604: LD_VAR 0 1
64608: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64609: LD_INT 0
64611: PPUSH
64612: PPUSH
64613: PPUSH
64614: PPUSH
64615: PPUSH
64616: PPUSH
64617: PPUSH
64618: PPUSH
64619: PPUSH
// if not mc_bases then
64620: LD_EXP 23
64624: NOT
64625: IFFALSE 64629
// exit ;
64627: GO 65034
// for i = 1 to mc_bases do
64629: LD_ADDR_VAR 0 2
64633: PUSH
64634: DOUBLE
64635: LD_INT 1
64637: DEC
64638: ST_TO_ADDR
64639: LD_EXP 23
64643: PUSH
64644: FOR_TO
64645: IFFALSE 65032
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64647: LD_EXP 31
64651: PUSH
64652: LD_VAR 0 2
64656: ARRAY
64657: NOT
64658: PUSH
64659: LD_EXP 23
64663: PUSH
64664: LD_VAR 0 2
64668: ARRAY
64669: PPUSH
64670: LD_INT 30
64672: PUSH
64673: LD_INT 3
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: PPUSH
64680: CALL_OW 72
64684: NOT
64685: OR
64686: IFFALSE 64690
// continue ;
64688: GO 64644
// busy := false ;
64690: LD_ADDR_VAR 0 8
64694: PUSH
64695: LD_INT 0
64697: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64698: LD_ADDR_VAR 0 4
64702: PUSH
64703: LD_EXP 23
64707: PUSH
64708: LD_VAR 0 2
64712: ARRAY
64713: PPUSH
64714: LD_INT 30
64716: PUSH
64717: LD_INT 3
64719: PUSH
64720: EMPTY
64721: LIST
64722: LIST
64723: PPUSH
64724: CALL_OW 72
64728: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64729: LD_ADDR_VAR 0 6
64733: PUSH
64734: LD_EXP 31
64738: PUSH
64739: LD_VAR 0 2
64743: ARRAY
64744: PPUSH
64745: LD_INT 2
64747: PUSH
64748: LD_INT 30
64750: PUSH
64751: LD_INT 32
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PUSH
64758: LD_INT 30
64760: PUSH
64761: LD_INT 33
64763: PUSH
64764: EMPTY
64765: LIST
64766: LIST
64767: PUSH
64768: EMPTY
64769: LIST
64770: LIST
64771: LIST
64772: PPUSH
64773: CALL_OW 72
64777: ST_TO_ADDR
// if not t then
64778: LD_VAR 0 6
64782: NOT
64783: IFFALSE 64787
// continue ;
64785: GO 64644
// for j in tmp do
64787: LD_ADDR_VAR 0 3
64791: PUSH
64792: LD_VAR 0 4
64796: PUSH
64797: FOR_IN
64798: IFFALSE 64828
// if not BuildingStatus ( j ) = bs_idle then
64800: LD_VAR 0 3
64804: PPUSH
64805: CALL_OW 461
64809: PUSH
64810: LD_INT 2
64812: EQUAL
64813: NOT
64814: IFFALSE 64826
// begin busy := true ;
64816: LD_ADDR_VAR 0 8
64820: PUSH
64821: LD_INT 1
64823: ST_TO_ADDR
// break ;
64824: GO 64828
// end ;
64826: GO 64797
64828: POP
64829: POP
// if busy then
64830: LD_VAR 0 8
64834: IFFALSE 64838
// continue ;
64836: GO 64644
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64838: LD_ADDR_VAR 0 7
64842: PUSH
64843: LD_VAR 0 6
64847: PPUSH
64848: LD_INT 35
64850: PUSH
64851: LD_INT 0
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PPUSH
64858: CALL_OW 72
64862: ST_TO_ADDR
// if tw then
64863: LD_VAR 0 7
64867: IFFALSE 64944
// begin tw := tw [ 1 ] ;
64869: LD_ADDR_VAR 0 7
64873: PUSH
64874: LD_VAR 0 7
64878: PUSH
64879: LD_INT 1
64881: ARRAY
64882: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64883: LD_ADDR_VAR 0 9
64887: PUSH
64888: LD_VAR 0 7
64892: PPUSH
64893: LD_EXP 48
64897: PUSH
64898: LD_VAR 0 2
64902: ARRAY
64903: PPUSH
64904: CALL 21260 0 2
64908: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64909: LD_EXP 62
64913: PUSH
64914: LD_VAR 0 2
64918: ARRAY
64919: IFFALSE 64942
// if not weapon in mc_allowed_tower_weapons [ i ] then
64921: LD_VAR 0 9
64925: PUSH
64926: LD_EXP 62
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: IN
64937: NOT
64938: IFFALSE 64942
// continue ;
64940: GO 64644
// end else
64942: GO 65007
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64944: LD_ADDR_VAR 0 5
64948: PUSH
64949: LD_EXP 31
64953: PUSH
64954: LD_VAR 0 2
64958: ARRAY
64959: PPUSH
64960: LD_VAR 0 4
64964: PPUSH
64965: CALL 48131 0 2
64969: ST_TO_ADDR
// if not tmp2 then
64970: LD_VAR 0 5
64974: NOT
64975: IFFALSE 64979
// continue ;
64977: GO 64644
// tw := tmp2 [ 1 ] ;
64979: LD_ADDR_VAR 0 7
64983: PUSH
64984: LD_VAR 0 5
64988: PUSH
64989: LD_INT 1
64991: ARRAY
64992: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64993: LD_ADDR_VAR 0 9
64997: PUSH
64998: LD_VAR 0 5
65002: PUSH
65003: LD_INT 2
65005: ARRAY
65006: ST_TO_ADDR
// end ; if not weapon then
65007: LD_VAR 0 9
65011: NOT
65012: IFFALSE 65016
// continue ;
65014: GO 64644
// ComPlaceWeapon ( tw , weapon ) ;
65016: LD_VAR 0 7
65020: PPUSH
65021: LD_VAR 0 9
65025: PPUSH
65026: CALL_OW 148
// end ;
65030: GO 64644
65032: POP
65033: POP
// end ;
65034: LD_VAR 0 1
65038: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
65039: LD_INT 0
65041: PPUSH
65042: PPUSH
65043: PPUSH
65044: PPUSH
65045: PPUSH
65046: PPUSH
65047: PPUSH
// if not mc_bases then
65048: LD_EXP 23
65052: NOT
65053: IFFALSE 65057
// exit ;
65055: GO 65825
// for i = 1 to mc_bases do
65057: LD_ADDR_VAR 0 2
65061: PUSH
65062: DOUBLE
65063: LD_INT 1
65065: DEC
65066: ST_TO_ADDR
65067: LD_EXP 23
65071: PUSH
65072: FOR_TO
65073: IFFALSE 65823
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
65075: LD_EXP 36
65079: PUSH
65080: LD_VAR 0 2
65084: ARRAY
65085: NOT
65086: PUSH
65087: LD_EXP 36
65091: PUSH
65092: LD_VAR 0 2
65096: ARRAY
65097: PUSH
65098: LD_EXP 37
65102: PUSH
65103: LD_VAR 0 2
65107: ARRAY
65108: EQUAL
65109: OR
65110: PUSH
65111: LD_EXP 46
65115: PUSH
65116: LD_VAR 0 2
65120: ARRAY
65121: OR
65122: IFFALSE 65126
// continue ;
65124: GO 65072
// if mc_miners [ i ] then
65126: LD_EXP 37
65130: PUSH
65131: LD_VAR 0 2
65135: ARRAY
65136: IFFALSE 65510
// begin for j = mc_miners [ i ] downto 1 do
65138: LD_ADDR_VAR 0 3
65142: PUSH
65143: DOUBLE
65144: LD_EXP 37
65148: PUSH
65149: LD_VAR 0 2
65153: ARRAY
65154: INC
65155: ST_TO_ADDR
65156: LD_INT 1
65158: PUSH
65159: FOR_DOWNTO
65160: IFFALSE 65508
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65162: LD_EXP 37
65166: PUSH
65167: LD_VAR 0 2
65171: ARRAY
65172: PUSH
65173: LD_VAR 0 3
65177: ARRAY
65178: PPUSH
65179: CALL_OW 301
65183: PUSH
65184: LD_EXP 37
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: PUSH
65195: LD_VAR 0 3
65199: ARRAY
65200: PPUSH
65201: CALL_OW 257
65205: PUSH
65206: LD_INT 1
65208: NONEQUAL
65209: OR
65210: IFFALSE 65273
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65212: LD_ADDR_VAR 0 5
65216: PUSH
65217: LD_EXP 37
65221: PUSH
65222: LD_VAR 0 2
65226: ARRAY
65227: PUSH
65228: LD_EXP 37
65232: PUSH
65233: LD_VAR 0 2
65237: ARRAY
65238: PUSH
65239: LD_VAR 0 3
65243: ARRAY
65244: DIFF
65245: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65246: LD_ADDR_EXP 37
65250: PUSH
65251: LD_EXP 37
65255: PPUSH
65256: LD_VAR 0 2
65260: PPUSH
65261: LD_VAR 0 5
65265: PPUSH
65266: CALL_OW 1
65270: ST_TO_ADDR
// continue ;
65271: GO 65159
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65273: LD_EXP 37
65277: PUSH
65278: LD_VAR 0 2
65282: ARRAY
65283: PUSH
65284: LD_VAR 0 3
65288: ARRAY
65289: PPUSH
65290: CALL_OW 257
65294: PUSH
65295: LD_INT 1
65297: EQUAL
65298: PUSH
65299: LD_EXP 37
65303: PUSH
65304: LD_VAR 0 2
65308: ARRAY
65309: PUSH
65310: LD_VAR 0 3
65314: ARRAY
65315: PPUSH
65316: CALL_OW 459
65320: NOT
65321: AND
65322: PUSH
65323: LD_EXP 37
65327: PUSH
65328: LD_VAR 0 2
65332: ARRAY
65333: PUSH
65334: LD_VAR 0 3
65338: ARRAY
65339: PPUSH
65340: CALL_OW 314
65344: NOT
65345: AND
65346: IFFALSE 65506
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65348: LD_EXP 37
65352: PUSH
65353: LD_VAR 0 2
65357: ARRAY
65358: PUSH
65359: LD_VAR 0 3
65363: ARRAY
65364: PPUSH
65365: CALL_OW 310
65369: IFFALSE 65392
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65371: LD_EXP 37
65375: PUSH
65376: LD_VAR 0 2
65380: ARRAY
65381: PUSH
65382: LD_VAR 0 3
65386: ARRAY
65387: PPUSH
65388: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65392: LD_EXP 37
65396: PUSH
65397: LD_VAR 0 2
65401: ARRAY
65402: PUSH
65403: LD_VAR 0 3
65407: ARRAY
65408: PPUSH
65409: CALL_OW 314
65413: NOT
65414: IFFALSE 65506
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65416: LD_ADDR_VAR 0 7
65420: PUSH
65421: LD_INT 1
65423: PPUSH
65424: LD_EXP 36
65428: PUSH
65429: LD_VAR 0 2
65433: ARRAY
65434: PPUSH
65435: CALL_OW 12
65439: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65440: LD_EXP 37
65444: PUSH
65445: LD_VAR 0 2
65449: ARRAY
65450: PUSH
65451: LD_VAR 0 3
65455: ARRAY
65456: PPUSH
65457: LD_EXP 36
65461: PUSH
65462: LD_VAR 0 2
65466: ARRAY
65467: PUSH
65468: LD_VAR 0 7
65472: ARRAY
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: PPUSH
65478: LD_EXP 36
65482: PUSH
65483: LD_VAR 0 2
65487: ARRAY
65488: PUSH
65489: LD_VAR 0 7
65493: ARRAY
65494: PUSH
65495: LD_INT 2
65497: ARRAY
65498: PPUSH
65499: LD_INT 0
65501: PPUSH
65502: CALL_OW 193
// end ; end ; end ;
65506: GO 65159
65508: POP
65509: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65510: LD_ADDR_VAR 0 5
65514: PUSH
65515: LD_EXP 23
65519: PUSH
65520: LD_VAR 0 2
65524: ARRAY
65525: PPUSH
65526: LD_INT 2
65528: PUSH
65529: LD_INT 30
65531: PUSH
65532: LD_INT 4
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 30
65541: PUSH
65542: LD_INT 5
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 30
65551: PUSH
65552: LD_INT 32
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: PPUSH
65565: CALL_OW 72
65569: ST_TO_ADDR
// if not tmp then
65570: LD_VAR 0 5
65574: NOT
65575: IFFALSE 65579
// continue ;
65577: GO 65072
// list := [ ] ;
65579: LD_ADDR_VAR 0 6
65583: PUSH
65584: EMPTY
65585: ST_TO_ADDR
// for j in tmp do
65586: LD_ADDR_VAR 0 3
65590: PUSH
65591: LD_VAR 0 5
65595: PUSH
65596: FOR_IN
65597: IFFALSE 65666
// begin for k in UnitsInside ( j ) do
65599: LD_ADDR_VAR 0 4
65603: PUSH
65604: LD_VAR 0 3
65608: PPUSH
65609: CALL_OW 313
65613: PUSH
65614: FOR_IN
65615: IFFALSE 65662
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65617: LD_VAR 0 4
65621: PPUSH
65622: CALL_OW 257
65626: PUSH
65627: LD_INT 1
65629: EQUAL
65630: PUSH
65631: LD_VAR 0 4
65635: PPUSH
65636: CALL_OW 459
65640: NOT
65641: AND
65642: IFFALSE 65660
// list := list ^ k ;
65644: LD_ADDR_VAR 0 6
65648: PUSH
65649: LD_VAR 0 6
65653: PUSH
65654: LD_VAR 0 4
65658: ADD
65659: ST_TO_ADDR
65660: GO 65614
65662: POP
65663: POP
// end ;
65664: GO 65596
65666: POP
65667: POP
// list := list diff mc_miners [ i ] ;
65668: LD_ADDR_VAR 0 6
65672: PUSH
65673: LD_VAR 0 6
65677: PUSH
65678: LD_EXP 37
65682: PUSH
65683: LD_VAR 0 2
65687: ARRAY
65688: DIFF
65689: ST_TO_ADDR
// if not list then
65690: LD_VAR 0 6
65694: NOT
65695: IFFALSE 65699
// continue ;
65697: GO 65072
// k := mc_mines [ i ] - mc_miners [ i ] ;
65699: LD_ADDR_VAR 0 4
65703: PUSH
65704: LD_EXP 36
65708: PUSH
65709: LD_VAR 0 2
65713: ARRAY
65714: PUSH
65715: LD_EXP 37
65719: PUSH
65720: LD_VAR 0 2
65724: ARRAY
65725: MINUS
65726: ST_TO_ADDR
// if k > list then
65727: LD_VAR 0 4
65731: PUSH
65732: LD_VAR 0 6
65736: GREATER
65737: IFFALSE 65749
// k := list ;
65739: LD_ADDR_VAR 0 4
65743: PUSH
65744: LD_VAR 0 6
65748: ST_TO_ADDR
// for j = 1 to k do
65749: LD_ADDR_VAR 0 3
65753: PUSH
65754: DOUBLE
65755: LD_INT 1
65757: DEC
65758: ST_TO_ADDR
65759: LD_VAR 0 4
65763: PUSH
65764: FOR_TO
65765: IFFALSE 65819
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65767: LD_ADDR_EXP 37
65771: PUSH
65772: LD_EXP 37
65776: PPUSH
65777: LD_VAR 0 2
65781: PUSH
65782: LD_EXP 37
65786: PUSH
65787: LD_VAR 0 2
65791: ARRAY
65792: PUSH
65793: LD_INT 1
65795: PLUS
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PPUSH
65801: LD_VAR 0 6
65805: PUSH
65806: LD_VAR 0 3
65810: ARRAY
65811: PPUSH
65812: CALL 16252 0 3
65816: ST_TO_ADDR
65817: GO 65764
65819: POP
65820: POP
// end ;
65821: GO 65072
65823: POP
65824: POP
// end ;
65825: LD_VAR 0 1
65829: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65830: LD_INT 0
65832: PPUSH
65833: PPUSH
65834: PPUSH
65835: PPUSH
65836: PPUSH
65837: PPUSH
65838: PPUSH
65839: PPUSH
65840: PPUSH
65841: PPUSH
65842: PPUSH
// if not mc_bases then
65843: LD_EXP 23
65847: NOT
65848: IFFALSE 65852
// exit ;
65850: GO 67675
// for i = 1 to mc_bases do
65852: LD_ADDR_VAR 0 2
65856: PUSH
65857: DOUBLE
65858: LD_INT 1
65860: DEC
65861: ST_TO_ADDR
65862: LD_EXP 23
65866: PUSH
65867: FOR_TO
65868: IFFALSE 67673
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65870: LD_EXP 23
65874: PUSH
65875: LD_VAR 0 2
65879: ARRAY
65880: NOT
65881: PUSH
65882: LD_EXP 30
65886: PUSH
65887: LD_VAR 0 2
65891: ARRAY
65892: OR
65893: IFFALSE 65897
// continue ;
65895: GO 65867
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65897: LD_EXP 39
65901: PUSH
65902: LD_VAR 0 2
65906: ARRAY
65907: NOT
65908: PUSH
65909: LD_EXP 40
65913: PUSH
65914: LD_VAR 0 2
65918: ARRAY
65919: AND
65920: IFFALSE 65958
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65922: LD_ADDR_EXP 40
65926: PUSH
65927: LD_EXP 40
65931: PPUSH
65932: LD_VAR 0 2
65936: PPUSH
65937: EMPTY
65938: PPUSH
65939: CALL_OW 1
65943: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65944: LD_VAR 0 2
65948: PPUSH
65949: LD_INT 107
65951: PPUSH
65952: CALL 56705 0 2
// continue ;
65956: GO 65867
// end ; target := [ ] ;
65958: LD_ADDR_VAR 0 7
65962: PUSH
65963: EMPTY
65964: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65965: LD_ADDR_VAR 0 6
65969: PUSH
65970: LD_EXP 23
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: PUSH
65981: LD_INT 1
65983: ARRAY
65984: PPUSH
65985: CALL_OW 255
65989: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65990: LD_ADDR_VAR 0 9
65994: PUSH
65995: LD_EXP 23
65999: PUSH
66000: LD_VAR 0 2
66004: ARRAY
66005: PPUSH
66006: LD_INT 2
66008: PUSH
66009: LD_INT 30
66011: PUSH
66012: LD_INT 0
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 30
66021: PUSH
66022: LD_INT 1
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: LIST
66033: PPUSH
66034: CALL_OW 72
66038: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
66039: LD_ADDR_VAR 0 3
66043: PUSH
66044: DOUBLE
66045: LD_EXP 39
66049: PUSH
66050: LD_VAR 0 2
66054: ARRAY
66055: INC
66056: ST_TO_ADDR
66057: LD_INT 1
66059: PUSH
66060: FOR_DOWNTO
66061: IFFALSE 66306
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
66063: LD_EXP 39
66067: PUSH
66068: LD_VAR 0 2
66072: ARRAY
66073: PUSH
66074: LD_VAR 0 3
66078: ARRAY
66079: PUSH
66080: LD_INT 2
66082: ARRAY
66083: PPUSH
66084: LD_EXP 39
66088: PUSH
66089: LD_VAR 0 2
66093: ARRAY
66094: PUSH
66095: LD_VAR 0 3
66099: ARRAY
66100: PUSH
66101: LD_INT 3
66103: ARRAY
66104: PPUSH
66105: CALL_OW 488
66109: PUSH
66110: LD_EXP 39
66114: PUSH
66115: LD_VAR 0 2
66119: ARRAY
66120: PUSH
66121: LD_VAR 0 3
66125: ARRAY
66126: PUSH
66127: LD_INT 2
66129: ARRAY
66130: PPUSH
66131: LD_EXP 39
66135: PUSH
66136: LD_VAR 0 2
66140: ARRAY
66141: PUSH
66142: LD_VAR 0 3
66146: ARRAY
66147: PUSH
66148: LD_INT 3
66150: ARRAY
66151: PPUSH
66152: CALL_OW 284
66156: PUSH
66157: LD_INT 0
66159: EQUAL
66160: AND
66161: IFFALSE 66216
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66163: LD_ADDR_VAR 0 5
66167: PUSH
66168: LD_EXP 39
66172: PUSH
66173: LD_VAR 0 2
66177: ARRAY
66178: PPUSH
66179: LD_VAR 0 3
66183: PPUSH
66184: CALL_OW 3
66188: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66189: LD_ADDR_EXP 39
66193: PUSH
66194: LD_EXP 39
66198: PPUSH
66199: LD_VAR 0 2
66203: PPUSH
66204: LD_VAR 0 5
66208: PPUSH
66209: CALL_OW 1
66213: ST_TO_ADDR
// continue ;
66214: GO 66060
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66216: LD_VAR 0 6
66220: PPUSH
66221: LD_EXP 39
66225: PUSH
66226: LD_VAR 0 2
66230: ARRAY
66231: PUSH
66232: LD_VAR 0 3
66236: ARRAY
66237: PUSH
66238: LD_INT 2
66240: ARRAY
66241: PPUSH
66242: LD_EXP 39
66246: PUSH
66247: LD_VAR 0 2
66251: ARRAY
66252: PUSH
66253: LD_VAR 0 3
66257: ARRAY
66258: PUSH
66259: LD_INT 3
66261: ARRAY
66262: PPUSH
66263: LD_INT 30
66265: PPUSH
66266: CALL 17148 0 4
66270: PUSH
66271: LD_INT 4
66273: ARRAY
66274: PUSH
66275: LD_INT 0
66277: EQUAL
66278: IFFALSE 66304
// begin target := mc_crates [ i ] [ j ] ;
66280: LD_ADDR_VAR 0 7
66284: PUSH
66285: LD_EXP 39
66289: PUSH
66290: LD_VAR 0 2
66294: ARRAY
66295: PUSH
66296: LD_VAR 0 3
66300: ARRAY
66301: ST_TO_ADDR
// break ;
66302: GO 66306
// end ; end ;
66304: GO 66060
66306: POP
66307: POP
// if not target then
66308: LD_VAR 0 7
66312: NOT
66313: IFFALSE 66317
// continue ;
66315: GO 65867
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66317: LD_ADDR_VAR 0 8
66321: PUSH
66322: LD_EXP 42
66326: PUSH
66327: LD_VAR 0 2
66331: ARRAY
66332: PPUSH
66333: LD_INT 2
66335: PUSH
66336: LD_INT 3
66338: PUSH
66339: LD_INT 58
66341: PUSH
66342: EMPTY
66343: LIST
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: PUSH
66349: LD_INT 61
66351: PUSH
66352: EMPTY
66353: LIST
66354: PUSH
66355: LD_INT 33
66357: PUSH
66358: LD_INT 5
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 33
66367: PUSH
66368: LD_INT 3
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: PUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 34
66387: PUSH
66388: LD_INT 32
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 34
66397: PUSH
66398: LD_INT 51
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: LD_INT 34
66407: PUSH
66408: LD_INT 12
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PPUSH
66425: CALL_OW 72
66429: ST_TO_ADDR
// if not cargo then
66430: LD_VAR 0 8
66434: NOT
66435: IFFALSE 67141
// begin if mc_crates_collector [ i ] < 5 then
66437: LD_EXP 40
66441: PUSH
66442: LD_VAR 0 2
66446: ARRAY
66447: PUSH
66448: LD_INT 5
66450: LESS
66451: IFFALSE 66817
// begin if mc_ape [ i ] then
66453: LD_EXP 52
66457: PUSH
66458: LD_VAR 0 2
66462: ARRAY
66463: IFFALSE 66510
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66465: LD_ADDR_VAR 0 5
66469: PUSH
66470: LD_EXP 52
66474: PUSH
66475: LD_VAR 0 2
66479: ARRAY
66480: PPUSH
66481: LD_INT 25
66483: PUSH
66484: LD_INT 16
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: PUSH
66491: LD_INT 24
66493: PUSH
66494: LD_INT 750
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PPUSH
66505: CALL_OW 72
66509: ST_TO_ADDR
// if not tmp then
66510: LD_VAR 0 5
66514: NOT
66515: IFFALSE 66562
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66517: LD_ADDR_VAR 0 5
66521: PUSH
66522: LD_EXP 23
66526: PUSH
66527: LD_VAR 0 2
66531: ARRAY
66532: PPUSH
66533: LD_INT 25
66535: PUSH
66536: LD_INT 2
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 24
66545: PUSH
66546: LD_INT 750
66548: PUSH
66549: EMPTY
66550: LIST
66551: LIST
66552: PUSH
66553: EMPTY
66554: LIST
66555: LIST
66556: PPUSH
66557: CALL_OW 72
66561: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66562: LD_EXP 52
66566: PUSH
66567: LD_VAR 0 2
66571: ARRAY
66572: PUSH
66573: LD_EXP 23
66577: PUSH
66578: LD_VAR 0 2
66582: ARRAY
66583: PPUSH
66584: LD_INT 25
66586: PUSH
66587: LD_INT 2
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 24
66596: PUSH
66597: LD_INT 750
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PUSH
66604: EMPTY
66605: LIST
66606: LIST
66607: PPUSH
66608: CALL_OW 72
66612: AND
66613: PUSH
66614: LD_VAR 0 5
66618: PUSH
66619: LD_INT 5
66621: LESS
66622: AND
66623: IFFALSE 66705
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66625: LD_ADDR_VAR 0 3
66629: PUSH
66630: LD_EXP 23
66634: PUSH
66635: LD_VAR 0 2
66639: ARRAY
66640: PPUSH
66641: LD_INT 25
66643: PUSH
66644: LD_INT 2
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 24
66653: PUSH
66654: LD_INT 750
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PPUSH
66665: CALL_OW 72
66669: PUSH
66670: FOR_IN
66671: IFFALSE 66703
// begin tmp := tmp union j ;
66673: LD_ADDR_VAR 0 5
66677: PUSH
66678: LD_VAR 0 5
66682: PUSH
66683: LD_VAR 0 3
66687: UNION
66688: ST_TO_ADDR
// if tmp >= 5 then
66689: LD_VAR 0 5
66693: PUSH
66694: LD_INT 5
66696: GREATEREQUAL
66697: IFFALSE 66701
// break ;
66699: GO 66703
// end ;
66701: GO 66670
66703: POP
66704: POP
// end ; if not tmp then
66705: LD_VAR 0 5
66709: NOT
66710: IFFALSE 66714
// continue ;
66712: GO 65867
// for j in tmp do
66714: LD_ADDR_VAR 0 3
66718: PUSH
66719: LD_VAR 0 5
66723: PUSH
66724: FOR_IN
66725: IFFALSE 66815
// if not GetTag ( j ) then
66727: LD_VAR 0 3
66731: PPUSH
66732: CALL_OW 110
66736: NOT
66737: IFFALSE 66813
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66739: LD_ADDR_EXP 40
66743: PUSH
66744: LD_EXP 40
66748: PPUSH
66749: LD_VAR 0 2
66753: PUSH
66754: LD_EXP 40
66758: PUSH
66759: LD_VAR 0 2
66763: ARRAY
66764: PUSH
66765: LD_INT 1
66767: PLUS
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PPUSH
66773: LD_VAR 0 3
66777: PPUSH
66778: CALL 16252 0 3
66782: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66783: LD_VAR 0 3
66787: PPUSH
66788: LD_INT 107
66790: PPUSH
66791: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66795: LD_EXP 40
66799: PUSH
66800: LD_VAR 0 2
66804: ARRAY
66805: PUSH
66806: LD_INT 5
66808: GREATEREQUAL
66809: IFFALSE 66813
// break ;
66811: GO 66815
// end ;
66813: GO 66724
66815: POP
66816: POP
// end ; if mc_crates_collector [ i ] and target then
66817: LD_EXP 40
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: PUSH
66828: LD_VAR 0 7
66832: AND
66833: IFFALSE 67139
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66835: LD_EXP 40
66839: PUSH
66840: LD_VAR 0 2
66844: ARRAY
66845: PUSH
66846: LD_VAR 0 7
66850: PUSH
66851: LD_INT 1
66853: ARRAY
66854: LESS
66855: IFFALSE 66875
// tmp := mc_crates_collector [ i ] else
66857: LD_ADDR_VAR 0 5
66861: PUSH
66862: LD_EXP 40
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: ST_TO_ADDR
66873: GO 66889
// tmp := target [ 1 ] ;
66875: LD_ADDR_VAR 0 5
66879: PUSH
66880: LD_VAR 0 7
66884: PUSH
66885: LD_INT 1
66887: ARRAY
66888: ST_TO_ADDR
// k := 0 ;
66889: LD_ADDR_VAR 0 4
66893: PUSH
66894: LD_INT 0
66896: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66897: LD_ADDR_VAR 0 3
66901: PUSH
66902: LD_EXP 40
66906: PUSH
66907: LD_VAR 0 2
66911: ARRAY
66912: PUSH
66913: FOR_IN
66914: IFFALSE 67137
// begin k := k + 1 ;
66916: LD_ADDR_VAR 0 4
66920: PUSH
66921: LD_VAR 0 4
66925: PUSH
66926: LD_INT 1
66928: PLUS
66929: ST_TO_ADDR
// if k > tmp then
66930: LD_VAR 0 4
66934: PUSH
66935: LD_VAR 0 5
66939: GREATER
66940: IFFALSE 66944
// break ;
66942: GO 67137
// if not GetClass ( j ) in [ 2 , 16 ] then
66944: LD_VAR 0 3
66948: PPUSH
66949: CALL_OW 257
66953: PUSH
66954: LD_INT 2
66956: PUSH
66957: LD_INT 16
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: IN
66964: NOT
66965: IFFALSE 67018
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66967: LD_ADDR_EXP 40
66971: PUSH
66972: LD_EXP 40
66976: PPUSH
66977: LD_VAR 0 2
66981: PPUSH
66982: LD_EXP 40
66986: PUSH
66987: LD_VAR 0 2
66991: ARRAY
66992: PUSH
66993: LD_VAR 0 3
66997: DIFF
66998: PPUSH
66999: CALL_OW 1
67003: ST_TO_ADDR
// SetTag ( j , 0 ) ;
67004: LD_VAR 0 3
67008: PPUSH
67009: LD_INT 0
67011: PPUSH
67012: CALL_OW 109
// continue ;
67016: GO 66913
// end ; if IsInUnit ( j ) then
67018: LD_VAR 0 3
67022: PPUSH
67023: CALL_OW 310
67027: IFFALSE 67038
// ComExitBuilding ( j ) ;
67029: LD_VAR 0 3
67033: PPUSH
67034: CALL_OW 122
// wait ( 3 ) ;
67038: LD_INT 3
67040: PPUSH
67041: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
67045: LD_VAR 0 3
67049: PPUSH
67050: CALL_OW 314
67054: PUSH
67055: LD_VAR 0 6
67059: PPUSH
67060: LD_VAR 0 7
67064: PUSH
67065: LD_INT 2
67067: ARRAY
67068: PPUSH
67069: LD_VAR 0 7
67073: PUSH
67074: LD_INT 3
67076: ARRAY
67077: PPUSH
67078: LD_INT 30
67080: PPUSH
67081: CALL 17148 0 4
67085: PUSH
67086: LD_INT 4
67088: ARRAY
67089: AND
67090: IFFALSE 67108
// ComStandNearbyBuilding ( j , depot ) else
67092: LD_VAR 0 3
67096: PPUSH
67097: LD_VAR 0 9
67101: PPUSH
67102: CALL 12679 0 2
67106: GO 67135
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67108: LD_VAR 0 3
67112: PPUSH
67113: LD_VAR 0 7
67117: PUSH
67118: LD_INT 2
67120: ARRAY
67121: PPUSH
67122: LD_VAR 0 7
67126: PUSH
67127: LD_INT 3
67129: ARRAY
67130: PPUSH
67131: CALL_OW 117
// end ;
67135: GO 66913
67137: POP
67138: POP
// end ; end else
67139: GO 67671
// begin for j in cargo do
67141: LD_ADDR_VAR 0 3
67145: PUSH
67146: LD_VAR 0 8
67150: PUSH
67151: FOR_IN
67152: IFFALSE 67669
// begin if GetTag ( j ) <> 0 then
67154: LD_VAR 0 3
67158: PPUSH
67159: CALL_OW 110
67163: PUSH
67164: LD_INT 0
67166: NONEQUAL
67167: IFFALSE 67171
// continue ;
67169: GO 67151
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67171: LD_VAR 0 3
67175: PPUSH
67176: CALL_OW 256
67180: PUSH
67181: LD_INT 1000
67183: LESS
67184: PUSH
67185: LD_VAR 0 3
67189: PPUSH
67190: LD_EXP 47
67194: PUSH
67195: LD_VAR 0 2
67199: ARRAY
67200: PPUSH
67201: CALL_OW 308
67205: NOT
67206: AND
67207: IFFALSE 67229
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67209: LD_VAR 0 3
67213: PPUSH
67214: LD_EXP 47
67218: PUSH
67219: LD_VAR 0 2
67223: ARRAY
67224: PPUSH
67225: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67229: LD_VAR 0 3
67233: PPUSH
67234: CALL_OW 256
67238: PUSH
67239: LD_INT 1000
67241: LESS
67242: PUSH
67243: LD_VAR 0 3
67247: PPUSH
67248: LD_EXP 47
67252: PUSH
67253: LD_VAR 0 2
67257: ARRAY
67258: PPUSH
67259: CALL_OW 308
67263: AND
67264: IFFALSE 67268
// continue ;
67266: GO 67151
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67268: LD_VAR 0 3
67272: PPUSH
67273: CALL_OW 262
67277: PUSH
67278: LD_INT 2
67280: EQUAL
67281: PUSH
67282: LD_VAR 0 3
67286: PPUSH
67287: CALL_OW 261
67291: PUSH
67292: LD_INT 15
67294: LESS
67295: AND
67296: IFFALSE 67300
// continue ;
67298: GO 67151
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67300: LD_VAR 0 3
67304: PPUSH
67305: CALL_OW 262
67309: PUSH
67310: LD_INT 1
67312: EQUAL
67313: PUSH
67314: LD_VAR 0 3
67318: PPUSH
67319: CALL_OW 261
67323: PUSH
67324: LD_INT 10
67326: LESS
67327: AND
67328: IFFALSE 67608
// begin if not depot then
67330: LD_VAR 0 9
67334: NOT
67335: IFFALSE 67339
// continue ;
67337: GO 67151
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67339: LD_VAR 0 3
67343: PPUSH
67344: LD_VAR 0 9
67348: PPUSH
67349: LD_VAR 0 3
67353: PPUSH
67354: CALL_OW 74
67358: PPUSH
67359: CALL_OW 296
67363: PUSH
67364: LD_INT 6
67366: LESS
67367: IFFALSE 67383
// SetFuel ( j , 100 ) else
67369: LD_VAR 0 3
67373: PPUSH
67374: LD_INT 100
67376: PPUSH
67377: CALL_OW 240
67381: GO 67608
// if GetFuel ( j ) = 0 then
67383: LD_VAR 0 3
67387: PPUSH
67388: CALL_OW 261
67392: PUSH
67393: LD_INT 0
67395: EQUAL
67396: IFFALSE 67608
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67398: LD_ADDR_EXP 42
67402: PUSH
67403: LD_EXP 42
67407: PPUSH
67408: LD_VAR 0 2
67412: PPUSH
67413: LD_EXP 42
67417: PUSH
67418: LD_VAR 0 2
67422: ARRAY
67423: PUSH
67424: LD_VAR 0 3
67428: DIFF
67429: PPUSH
67430: CALL_OW 1
67434: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67435: LD_VAR 0 3
67439: PPUSH
67440: CALL_OW 263
67444: PUSH
67445: LD_INT 1
67447: EQUAL
67448: IFFALSE 67464
// ComExitVehicle ( IsInUnit ( j ) ) ;
67450: LD_VAR 0 3
67454: PPUSH
67455: CALL_OW 310
67459: PPUSH
67460: CALL_OW 121
// if GetControl ( j ) = control_remote then
67464: LD_VAR 0 3
67468: PPUSH
67469: CALL_OW 263
67473: PUSH
67474: LD_INT 2
67476: EQUAL
67477: IFFALSE 67488
// ComUnlink ( j ) ;
67479: LD_VAR 0 3
67483: PPUSH
67484: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67488: LD_ADDR_VAR 0 10
67492: PUSH
67493: LD_VAR 0 2
67497: PPUSH
67498: LD_INT 3
67500: PPUSH
67501: CALL 77275 0 2
67505: ST_TO_ADDR
// if fac then
67506: LD_VAR 0 10
67510: IFFALSE 67606
// begin for k in fac do
67512: LD_ADDR_VAR 0 4
67516: PUSH
67517: LD_VAR 0 10
67521: PUSH
67522: FOR_IN
67523: IFFALSE 67604
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67525: LD_ADDR_VAR 0 11
67529: PUSH
67530: LD_VAR 0 10
67534: PPUSH
67535: LD_VAR 0 3
67539: PPUSH
67540: CALL_OW 265
67544: PPUSH
67545: LD_VAR 0 3
67549: PPUSH
67550: CALL_OW 262
67554: PPUSH
67555: LD_VAR 0 3
67559: PPUSH
67560: CALL_OW 263
67564: PPUSH
67565: LD_VAR 0 3
67569: PPUSH
67570: CALL_OW 264
67574: PPUSH
67575: CALL 13750 0 5
67579: ST_TO_ADDR
// if components then
67580: LD_VAR 0 11
67584: IFFALSE 67602
// begin MC_InsertProduceList ( i , components ) ;
67586: LD_VAR 0 2
67590: PPUSH
67591: LD_VAR 0 11
67595: PPUSH
67596: CALL 76820 0 2
// break ;
67600: GO 67604
// end ; end ;
67602: GO 67522
67604: POP
67605: POP
// end ; continue ;
67606: GO 67151
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67608: LD_VAR 0 3
67612: PPUSH
67613: LD_INT 1
67615: PPUSH
67616: CALL_OW 289
67620: PUSH
67621: LD_INT 100
67623: LESS
67624: PUSH
67625: LD_VAR 0 3
67629: PPUSH
67630: CALL_OW 314
67634: NOT
67635: AND
67636: IFFALSE 67665
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67638: LD_VAR 0 3
67642: PPUSH
67643: LD_VAR 0 7
67647: PUSH
67648: LD_INT 2
67650: ARRAY
67651: PPUSH
67652: LD_VAR 0 7
67656: PUSH
67657: LD_INT 3
67659: ARRAY
67660: PPUSH
67661: CALL_OW 117
// break ;
67665: GO 67669
// end ;
67667: GO 67151
67669: POP
67670: POP
// end ; end ;
67671: GO 65867
67673: POP
67674: POP
// end ;
67675: LD_VAR 0 1
67679: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67680: LD_INT 0
67682: PPUSH
67683: PPUSH
67684: PPUSH
67685: PPUSH
// if not mc_bases then
67686: LD_EXP 23
67690: NOT
67691: IFFALSE 67695
// exit ;
67693: GO 67856
// for i = 1 to mc_bases do
67695: LD_ADDR_VAR 0 2
67699: PUSH
67700: DOUBLE
67701: LD_INT 1
67703: DEC
67704: ST_TO_ADDR
67705: LD_EXP 23
67709: PUSH
67710: FOR_TO
67711: IFFALSE 67854
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67713: LD_ADDR_VAR 0 4
67717: PUSH
67718: LD_EXP 42
67722: PUSH
67723: LD_VAR 0 2
67727: ARRAY
67728: PUSH
67729: LD_EXP 45
67733: PUSH
67734: LD_VAR 0 2
67738: ARRAY
67739: UNION
67740: PPUSH
67741: LD_INT 33
67743: PUSH
67744: LD_INT 2
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PPUSH
67751: CALL_OW 72
67755: ST_TO_ADDR
// if tmp then
67756: LD_VAR 0 4
67760: IFFALSE 67852
// for j in tmp do
67762: LD_ADDR_VAR 0 3
67766: PUSH
67767: LD_VAR 0 4
67771: PUSH
67772: FOR_IN
67773: IFFALSE 67850
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67775: LD_VAR 0 3
67779: PPUSH
67780: CALL_OW 312
67784: NOT
67785: PUSH
67786: LD_VAR 0 3
67790: PPUSH
67791: CALL_OW 256
67795: PUSH
67796: LD_INT 250
67798: GREATEREQUAL
67799: AND
67800: IFFALSE 67813
// Connect ( j ) else
67802: LD_VAR 0 3
67806: PPUSH
67807: CALL 19221 0 1
67811: GO 67848
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67813: LD_VAR 0 3
67817: PPUSH
67818: CALL_OW 256
67822: PUSH
67823: LD_INT 250
67825: LESS
67826: PUSH
67827: LD_VAR 0 3
67831: PPUSH
67832: CALL_OW 312
67836: AND
67837: IFFALSE 67848
// ComUnlink ( j ) ;
67839: LD_VAR 0 3
67843: PPUSH
67844: CALL_OW 136
67848: GO 67772
67850: POP
67851: POP
// end ;
67852: GO 67710
67854: POP
67855: POP
// end ;
67856: LD_VAR 0 1
67860: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67861: LD_INT 0
67863: PPUSH
67864: PPUSH
67865: PPUSH
67866: PPUSH
67867: PPUSH
// if not mc_bases then
67868: LD_EXP 23
67872: NOT
67873: IFFALSE 67877
// exit ;
67875: GO 68322
// for i = 1 to mc_bases do
67877: LD_ADDR_VAR 0 2
67881: PUSH
67882: DOUBLE
67883: LD_INT 1
67885: DEC
67886: ST_TO_ADDR
67887: LD_EXP 23
67891: PUSH
67892: FOR_TO
67893: IFFALSE 68320
// begin if not mc_produce [ i ] then
67895: LD_EXP 44
67899: PUSH
67900: LD_VAR 0 2
67904: ARRAY
67905: NOT
67906: IFFALSE 67910
// continue ;
67908: GO 67892
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67910: LD_ADDR_VAR 0 5
67914: PUSH
67915: LD_EXP 23
67919: PUSH
67920: LD_VAR 0 2
67924: ARRAY
67925: PPUSH
67926: LD_INT 30
67928: PUSH
67929: LD_INT 3
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PPUSH
67936: CALL_OW 72
67940: ST_TO_ADDR
// if not fac then
67941: LD_VAR 0 5
67945: NOT
67946: IFFALSE 67950
// continue ;
67948: GO 67892
// for j in fac do
67950: LD_ADDR_VAR 0 3
67954: PUSH
67955: LD_VAR 0 5
67959: PUSH
67960: FOR_IN
67961: IFFALSE 68316
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67963: LD_VAR 0 3
67967: PPUSH
67968: CALL_OW 461
67972: PUSH
67973: LD_INT 2
67975: NONEQUAL
67976: PUSH
67977: LD_VAR 0 3
67981: PPUSH
67982: LD_INT 15
67984: PPUSH
67985: CALL 18849 0 2
67989: PUSH
67990: LD_INT 4
67992: ARRAY
67993: OR
67994: IFFALSE 67998
// continue ;
67996: GO 67960
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67998: LD_VAR 0 3
68002: PPUSH
68003: LD_EXP 44
68007: PUSH
68008: LD_VAR 0 2
68012: ARRAY
68013: PUSH
68014: LD_INT 1
68016: ARRAY
68017: PUSH
68018: LD_INT 1
68020: ARRAY
68021: PPUSH
68022: LD_EXP 44
68026: PUSH
68027: LD_VAR 0 2
68031: ARRAY
68032: PUSH
68033: LD_INT 1
68035: ARRAY
68036: PUSH
68037: LD_INT 2
68039: ARRAY
68040: PPUSH
68041: LD_EXP 44
68045: PUSH
68046: LD_VAR 0 2
68050: ARRAY
68051: PUSH
68052: LD_INT 1
68054: ARRAY
68055: PUSH
68056: LD_INT 3
68058: ARRAY
68059: PPUSH
68060: LD_EXP 44
68064: PUSH
68065: LD_VAR 0 2
68069: ARRAY
68070: PUSH
68071: LD_INT 1
68073: ARRAY
68074: PUSH
68075: LD_INT 4
68077: ARRAY
68078: PPUSH
68079: CALL_OW 448
68083: PUSH
68084: LD_VAR 0 3
68088: PPUSH
68089: LD_EXP 44
68093: PUSH
68094: LD_VAR 0 2
68098: ARRAY
68099: PUSH
68100: LD_INT 1
68102: ARRAY
68103: PUSH
68104: LD_INT 1
68106: ARRAY
68107: PUSH
68108: LD_EXP 44
68112: PUSH
68113: LD_VAR 0 2
68117: ARRAY
68118: PUSH
68119: LD_INT 1
68121: ARRAY
68122: PUSH
68123: LD_INT 2
68125: ARRAY
68126: PUSH
68127: LD_EXP 44
68131: PUSH
68132: LD_VAR 0 2
68136: ARRAY
68137: PUSH
68138: LD_INT 1
68140: ARRAY
68141: PUSH
68142: LD_INT 3
68144: ARRAY
68145: PUSH
68146: LD_EXP 44
68150: PUSH
68151: LD_VAR 0 2
68155: ARRAY
68156: PUSH
68157: LD_INT 1
68159: ARRAY
68160: PUSH
68161: LD_INT 4
68163: ARRAY
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: LIST
68169: LIST
68170: PPUSH
68171: CALL 22616 0 2
68175: AND
68176: IFFALSE 68314
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68178: LD_VAR 0 3
68182: PPUSH
68183: LD_EXP 44
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: PUSH
68194: LD_INT 1
68196: ARRAY
68197: PUSH
68198: LD_INT 1
68200: ARRAY
68201: PPUSH
68202: LD_EXP 44
68206: PUSH
68207: LD_VAR 0 2
68211: ARRAY
68212: PUSH
68213: LD_INT 1
68215: ARRAY
68216: PUSH
68217: LD_INT 2
68219: ARRAY
68220: PPUSH
68221: LD_EXP 44
68225: PUSH
68226: LD_VAR 0 2
68230: ARRAY
68231: PUSH
68232: LD_INT 1
68234: ARRAY
68235: PUSH
68236: LD_INT 3
68238: ARRAY
68239: PPUSH
68240: LD_EXP 44
68244: PUSH
68245: LD_VAR 0 2
68249: ARRAY
68250: PUSH
68251: LD_INT 1
68253: ARRAY
68254: PUSH
68255: LD_INT 4
68257: ARRAY
68258: PPUSH
68259: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68263: LD_ADDR_VAR 0 4
68267: PUSH
68268: LD_EXP 44
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: PPUSH
68279: LD_INT 1
68281: PPUSH
68282: CALL_OW 3
68286: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68287: LD_ADDR_EXP 44
68291: PUSH
68292: LD_EXP 44
68296: PPUSH
68297: LD_VAR 0 2
68301: PPUSH
68302: LD_VAR 0 4
68306: PPUSH
68307: CALL_OW 1
68311: ST_TO_ADDR
// break ;
68312: GO 68316
// end ; end ;
68314: GO 67960
68316: POP
68317: POP
// end ;
68318: GO 67892
68320: POP
68321: POP
// end ;
68322: LD_VAR 0 1
68326: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68327: LD_INT 0
68329: PPUSH
68330: PPUSH
68331: PPUSH
// if not mc_bases then
68332: LD_EXP 23
68336: NOT
68337: IFFALSE 68341
// exit ;
68339: GO 68430
// for i = 1 to mc_bases do
68341: LD_ADDR_VAR 0 2
68345: PUSH
68346: DOUBLE
68347: LD_INT 1
68349: DEC
68350: ST_TO_ADDR
68351: LD_EXP 23
68355: PUSH
68356: FOR_TO
68357: IFFALSE 68428
// begin if mc_attack [ i ] then
68359: LD_EXP 43
68363: PUSH
68364: LD_VAR 0 2
68368: ARRAY
68369: IFFALSE 68426
// begin tmp := mc_attack [ i ] [ 1 ] ;
68371: LD_ADDR_VAR 0 3
68375: PUSH
68376: LD_EXP 43
68380: PUSH
68381: LD_VAR 0 2
68385: ARRAY
68386: PUSH
68387: LD_INT 1
68389: ARRAY
68390: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68391: LD_ADDR_EXP 43
68395: PUSH
68396: LD_EXP 43
68400: PPUSH
68401: LD_VAR 0 2
68405: PPUSH
68406: EMPTY
68407: PPUSH
68408: CALL_OW 1
68412: ST_TO_ADDR
// Attack ( tmp ) ;
68413: LD_VAR 0 3
68417: PPUSH
68418: CALL 83246 0 1
// exit ;
68422: POP
68423: POP
68424: GO 68430
// end ; end ;
68426: GO 68356
68428: POP
68429: POP
// end ;
68430: LD_VAR 0 1
68434: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68435: LD_INT 0
68437: PPUSH
68438: PPUSH
68439: PPUSH
68440: PPUSH
68441: PPUSH
68442: PPUSH
68443: PPUSH
// if not mc_bases then
68444: LD_EXP 23
68448: NOT
68449: IFFALSE 68453
// exit ;
68451: GO 69310
// for i = 1 to mc_bases do
68453: LD_ADDR_VAR 0 2
68457: PUSH
68458: DOUBLE
68459: LD_INT 1
68461: DEC
68462: ST_TO_ADDR
68463: LD_EXP 23
68467: PUSH
68468: FOR_TO
68469: IFFALSE 69308
// begin if not mc_bases [ i ] then
68471: LD_EXP 23
68475: PUSH
68476: LD_VAR 0 2
68480: ARRAY
68481: NOT
68482: IFFALSE 68486
// continue ;
68484: GO 68468
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68486: LD_ADDR_VAR 0 7
68490: PUSH
68491: LD_EXP 23
68495: PUSH
68496: LD_VAR 0 2
68500: ARRAY
68501: PUSH
68502: LD_INT 1
68504: ARRAY
68505: PPUSH
68506: CALL 12901 0 1
68510: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68511: LD_ADDR_EXP 46
68515: PUSH
68516: LD_EXP 46
68520: PPUSH
68521: LD_VAR 0 2
68525: PPUSH
68526: LD_EXP 23
68530: PUSH
68531: LD_VAR 0 2
68535: ARRAY
68536: PUSH
68537: LD_INT 1
68539: ARRAY
68540: PPUSH
68541: CALL_OW 255
68545: PPUSH
68546: LD_EXP 48
68550: PUSH
68551: LD_VAR 0 2
68555: ARRAY
68556: PPUSH
68557: CALL 12866 0 2
68561: PPUSH
68562: CALL_OW 1
68566: ST_TO_ADDR
// if not mc_scan [ i ] then
68567: LD_EXP 46
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: NOT
68578: IFFALSE 68756
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68580: LD_ADDR_EXP 66
68584: PUSH
68585: LD_EXP 66
68589: PPUSH
68590: LD_VAR 0 2
68594: PPUSH
68595: LD_INT 0
68597: PPUSH
68598: CALL_OW 1
68602: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68603: LD_ADDR_VAR 0 4
68607: PUSH
68608: LD_EXP 23
68612: PUSH
68613: LD_VAR 0 2
68617: ARRAY
68618: PPUSH
68619: LD_INT 2
68621: PUSH
68622: LD_INT 25
68624: PUSH
68625: LD_INT 5
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 25
68634: PUSH
68635: LD_INT 8
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 25
68644: PUSH
68645: LD_INT 9
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: PPUSH
68658: CALL_OW 72
68662: ST_TO_ADDR
// if not tmp then
68663: LD_VAR 0 4
68667: NOT
68668: IFFALSE 68672
// continue ;
68670: GO 68468
// for j in tmp do
68672: LD_ADDR_VAR 0 3
68676: PUSH
68677: LD_VAR 0 4
68681: PUSH
68682: FOR_IN
68683: IFFALSE 68754
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68685: LD_VAR 0 3
68689: PPUSH
68690: CALL_OW 310
68694: PPUSH
68695: CALL_OW 266
68699: PUSH
68700: LD_INT 5
68702: EQUAL
68703: PUSH
68704: LD_VAR 0 3
68708: PPUSH
68709: CALL_OW 257
68713: PUSH
68714: LD_INT 1
68716: EQUAL
68717: AND
68718: PUSH
68719: LD_VAR 0 3
68723: PPUSH
68724: CALL_OW 459
68728: NOT
68729: AND
68730: PUSH
68731: LD_VAR 0 7
68735: AND
68736: IFFALSE 68752
// ComChangeProfession ( j , class ) ;
68738: LD_VAR 0 3
68742: PPUSH
68743: LD_VAR 0 7
68747: PPUSH
68748: CALL_OW 123
68752: GO 68682
68754: POP
68755: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68756: LD_EXP 46
68760: PUSH
68761: LD_VAR 0 2
68765: ARRAY
68766: PUSH
68767: LD_EXP 66
68771: PUSH
68772: LD_VAR 0 2
68776: ARRAY
68777: NOT
68778: AND
68779: PUSH
68780: LD_EXP 45
68784: PUSH
68785: LD_VAR 0 2
68789: ARRAY
68790: NOT
68791: AND
68792: PUSH
68793: LD_EXP 23
68797: PUSH
68798: LD_VAR 0 2
68802: ARRAY
68803: PPUSH
68804: LD_INT 50
68806: PUSH
68807: EMPTY
68808: LIST
68809: PUSH
68810: LD_INT 2
68812: PUSH
68813: LD_INT 30
68815: PUSH
68816: LD_INT 32
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: PUSH
68823: LD_INT 30
68825: PUSH
68826: LD_INT 33
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PUSH
68833: LD_INT 30
68835: PUSH
68836: LD_INT 4
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 30
68845: PUSH
68846: LD_INT 5
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: EMPTY
68854: LIST
68855: LIST
68856: LIST
68857: LIST
68858: LIST
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PPUSH
68864: CALL_OW 72
68868: PUSH
68869: LD_INT 4
68871: LESS
68872: PUSH
68873: LD_EXP 23
68877: PUSH
68878: LD_VAR 0 2
68882: ARRAY
68883: PPUSH
68884: LD_INT 3
68886: PUSH
68887: LD_INT 24
68889: PUSH
68890: LD_INT 1000
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PUSH
68901: LD_INT 2
68903: PUSH
68904: LD_INT 30
68906: PUSH
68907: LD_INT 0
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 30
68916: PUSH
68917: LD_INT 1
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PPUSH
68933: CALL_OW 72
68937: OR
68938: AND
68939: IFFALSE 69190
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68941: LD_ADDR_EXP 66
68945: PUSH
68946: LD_EXP 66
68950: PPUSH
68951: LD_VAR 0 2
68955: PPUSH
68956: LD_INT 1
68958: PPUSH
68959: CALL_OW 1
68963: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68964: LD_ADDR_VAR 0 4
68968: PUSH
68969: LD_EXP 23
68973: PUSH
68974: LD_VAR 0 2
68978: ARRAY
68979: PPUSH
68980: LD_INT 2
68982: PUSH
68983: LD_INT 25
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 25
68995: PUSH
68996: LD_INT 5
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: LD_INT 25
69005: PUSH
69006: LD_INT 8
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 25
69015: PUSH
69016: LD_INT 9
69018: PUSH
69019: EMPTY
69020: LIST
69021: LIST
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: LIST
69027: LIST
69028: LIST
69029: PPUSH
69030: CALL_OW 72
69034: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
69035: LD_ADDR_VAR 0 4
69039: PUSH
69040: LD_VAR 0 4
69044: PUSH
69045: LD_VAR 0 4
69049: PPUSH
69050: LD_INT 18
69052: PPUSH
69053: CALL 46164 0 2
69057: DIFF
69058: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69059: LD_VAR 0 4
69063: NOT
69064: PUSH
69065: LD_EXP 23
69069: PUSH
69070: LD_VAR 0 2
69074: ARRAY
69075: PPUSH
69076: LD_INT 2
69078: PUSH
69079: LD_INT 30
69081: PUSH
69082: LD_INT 4
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 30
69091: PUSH
69092: LD_INT 5
69094: PUSH
69095: EMPTY
69096: LIST
69097: LIST
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: LIST
69103: PPUSH
69104: CALL_OW 72
69108: NOT
69109: AND
69110: IFFALSE 69172
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
69112: LD_ADDR_VAR 0 4
69116: PUSH
69117: LD_EXP 23
69121: PUSH
69122: LD_VAR 0 2
69126: ARRAY
69127: PPUSH
69128: LD_INT 2
69130: PUSH
69131: LD_INT 25
69133: PUSH
69134: LD_INT 2
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: PUSH
69141: LD_INT 25
69143: PUSH
69144: LD_INT 3
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 25
69153: PUSH
69154: LD_INT 4
69156: PUSH
69157: EMPTY
69158: LIST
69159: LIST
69160: PUSH
69161: EMPTY
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: PPUSH
69167: CALL_OW 72
69171: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69172: LD_VAR 0 2
69176: PPUSH
69177: LD_VAR 0 4
69181: PPUSH
69182: CALL 87955 0 2
// exit ;
69186: POP
69187: POP
69188: GO 69310
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69190: LD_EXP 46
69194: PUSH
69195: LD_VAR 0 2
69199: ARRAY
69200: PUSH
69201: LD_EXP 66
69205: PUSH
69206: LD_VAR 0 2
69210: ARRAY
69211: NOT
69212: AND
69213: PUSH
69214: LD_EXP 45
69218: PUSH
69219: LD_VAR 0 2
69223: ARRAY
69224: AND
69225: IFFALSE 69306
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69227: LD_ADDR_EXP 66
69231: PUSH
69232: LD_EXP 66
69236: PPUSH
69237: LD_VAR 0 2
69241: PPUSH
69242: LD_INT 1
69244: PPUSH
69245: CALL_OW 1
69249: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69250: LD_ADDR_VAR 0 4
69254: PUSH
69255: LD_EXP 45
69259: PUSH
69260: LD_VAR 0 2
69264: ARRAY
69265: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69266: LD_ADDR_EXP 45
69270: PUSH
69271: LD_EXP 45
69275: PPUSH
69276: LD_VAR 0 2
69280: PPUSH
69281: EMPTY
69282: PPUSH
69283: CALL_OW 1
69287: ST_TO_ADDR
// Defend ( i , tmp ) ;
69288: LD_VAR 0 2
69292: PPUSH
69293: LD_VAR 0 4
69297: PPUSH
69298: CALL 88551 0 2
// exit ;
69302: POP
69303: POP
69304: GO 69310
// end ; end ;
69306: GO 68468
69308: POP
69309: POP
// end ;
69310: LD_VAR 0 1
69314: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69315: LD_INT 0
69317: PPUSH
69318: PPUSH
69319: PPUSH
69320: PPUSH
69321: PPUSH
69322: PPUSH
69323: PPUSH
69324: PPUSH
69325: PPUSH
69326: PPUSH
69327: PPUSH
// if not mc_bases then
69328: LD_EXP 23
69332: NOT
69333: IFFALSE 69337
// exit ;
69335: GO 70424
// for i = 1 to mc_bases do
69337: LD_ADDR_VAR 0 2
69341: PUSH
69342: DOUBLE
69343: LD_INT 1
69345: DEC
69346: ST_TO_ADDR
69347: LD_EXP 23
69351: PUSH
69352: FOR_TO
69353: IFFALSE 70422
// begin tmp := mc_lab [ i ] ;
69355: LD_ADDR_VAR 0 6
69359: PUSH
69360: LD_EXP 56
69364: PUSH
69365: LD_VAR 0 2
69369: ARRAY
69370: ST_TO_ADDR
// if not tmp then
69371: LD_VAR 0 6
69375: NOT
69376: IFFALSE 69380
// continue ;
69378: GO 69352
// idle_lab := 0 ;
69380: LD_ADDR_VAR 0 11
69384: PUSH
69385: LD_INT 0
69387: ST_TO_ADDR
// for j in tmp do
69388: LD_ADDR_VAR 0 3
69392: PUSH
69393: LD_VAR 0 6
69397: PUSH
69398: FOR_IN
69399: IFFALSE 70418
// begin researching := false ;
69401: LD_ADDR_VAR 0 10
69405: PUSH
69406: LD_INT 0
69408: ST_TO_ADDR
// side := GetSide ( j ) ;
69409: LD_ADDR_VAR 0 4
69413: PUSH
69414: LD_VAR 0 3
69418: PPUSH
69419: CALL_OW 255
69423: ST_TO_ADDR
// if not mc_tech [ side ] then
69424: LD_EXP 50
69428: PUSH
69429: LD_VAR 0 4
69433: ARRAY
69434: NOT
69435: IFFALSE 69439
// continue ;
69437: GO 69398
// if BuildingStatus ( j ) = bs_idle then
69439: LD_VAR 0 3
69443: PPUSH
69444: CALL_OW 461
69448: PUSH
69449: LD_INT 2
69451: EQUAL
69452: IFFALSE 69640
// begin if idle_lab and UnitsInside ( j ) < 6 then
69454: LD_VAR 0 11
69458: PUSH
69459: LD_VAR 0 3
69463: PPUSH
69464: CALL_OW 313
69468: PUSH
69469: LD_INT 6
69471: LESS
69472: AND
69473: IFFALSE 69544
// begin tmp2 := UnitsInside ( idle_lab ) ;
69475: LD_ADDR_VAR 0 9
69479: PUSH
69480: LD_VAR 0 11
69484: PPUSH
69485: CALL_OW 313
69489: ST_TO_ADDR
// if tmp2 then
69490: LD_VAR 0 9
69494: IFFALSE 69536
// for x in tmp2 do
69496: LD_ADDR_VAR 0 7
69500: PUSH
69501: LD_VAR 0 9
69505: PUSH
69506: FOR_IN
69507: IFFALSE 69534
// begin ComExitBuilding ( x ) ;
69509: LD_VAR 0 7
69513: PPUSH
69514: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69518: LD_VAR 0 7
69522: PPUSH
69523: LD_VAR 0 3
69527: PPUSH
69528: CALL_OW 180
// end ;
69532: GO 69506
69534: POP
69535: POP
// idle_lab := 0 ;
69536: LD_ADDR_VAR 0 11
69540: PUSH
69541: LD_INT 0
69543: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69544: LD_ADDR_VAR 0 5
69548: PUSH
69549: LD_EXP 50
69553: PUSH
69554: LD_VAR 0 4
69558: ARRAY
69559: PUSH
69560: FOR_IN
69561: IFFALSE 69621
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69563: LD_VAR 0 3
69567: PPUSH
69568: LD_VAR 0 5
69572: PPUSH
69573: CALL_OW 430
69577: PUSH
69578: LD_VAR 0 4
69582: PPUSH
69583: LD_VAR 0 5
69587: PPUSH
69588: CALL 11971 0 2
69592: AND
69593: IFFALSE 69619
// begin researching := true ;
69595: LD_ADDR_VAR 0 10
69599: PUSH
69600: LD_INT 1
69602: ST_TO_ADDR
// ComResearch ( j , t ) ;
69603: LD_VAR 0 3
69607: PPUSH
69608: LD_VAR 0 5
69612: PPUSH
69613: CALL_OW 124
// break ;
69617: GO 69621
// end ;
69619: GO 69560
69621: POP
69622: POP
// if not researching then
69623: LD_VAR 0 10
69627: NOT
69628: IFFALSE 69640
// idle_lab := j ;
69630: LD_ADDR_VAR 0 11
69634: PUSH
69635: LD_VAR 0 3
69639: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69640: LD_VAR 0 3
69644: PPUSH
69645: CALL_OW 461
69649: PUSH
69650: LD_INT 10
69652: EQUAL
69653: IFFALSE 70241
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69655: LD_EXP 52
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: NOT
69666: PUSH
69667: LD_EXP 53
69671: PUSH
69672: LD_VAR 0 2
69676: ARRAY
69677: NOT
69678: AND
69679: PUSH
69680: LD_EXP 50
69684: PUSH
69685: LD_VAR 0 4
69689: ARRAY
69690: PUSH
69691: LD_INT 1
69693: GREATER
69694: AND
69695: IFFALSE 69826
// begin ComCancel ( j ) ;
69697: LD_VAR 0 3
69701: PPUSH
69702: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69706: LD_ADDR_EXP 50
69710: PUSH
69711: LD_EXP 50
69715: PPUSH
69716: LD_VAR 0 4
69720: PPUSH
69721: LD_EXP 50
69725: PUSH
69726: LD_VAR 0 4
69730: ARRAY
69731: PPUSH
69732: LD_EXP 50
69736: PUSH
69737: LD_VAR 0 4
69741: ARRAY
69742: PUSH
69743: LD_INT 1
69745: MINUS
69746: PPUSH
69747: LD_EXP 50
69751: PUSH
69752: LD_VAR 0 4
69756: ARRAY
69757: PPUSH
69758: LD_INT 0
69760: PPUSH
69761: CALL 15670 0 4
69765: PPUSH
69766: CALL_OW 1
69770: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69771: LD_ADDR_EXP 50
69775: PUSH
69776: LD_EXP 50
69780: PPUSH
69781: LD_VAR 0 4
69785: PPUSH
69786: LD_EXP 50
69790: PUSH
69791: LD_VAR 0 4
69795: ARRAY
69796: PPUSH
69797: LD_EXP 50
69801: PUSH
69802: LD_VAR 0 4
69806: ARRAY
69807: PPUSH
69808: LD_INT 1
69810: PPUSH
69811: LD_INT 0
69813: PPUSH
69814: CALL 15670 0 4
69818: PPUSH
69819: CALL_OW 1
69823: ST_TO_ADDR
// continue ;
69824: GO 69398
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69826: LD_EXP 52
69830: PUSH
69831: LD_VAR 0 2
69835: ARRAY
69836: PUSH
69837: LD_EXP 53
69841: PUSH
69842: LD_VAR 0 2
69846: ARRAY
69847: NOT
69848: AND
69849: IFFALSE 69976
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69851: LD_ADDR_EXP 53
69855: PUSH
69856: LD_EXP 53
69860: PPUSH
69861: LD_VAR 0 2
69865: PUSH
69866: LD_EXP 53
69870: PUSH
69871: LD_VAR 0 2
69875: ARRAY
69876: PUSH
69877: LD_INT 1
69879: PLUS
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PPUSH
69885: LD_EXP 52
69889: PUSH
69890: LD_VAR 0 2
69894: ARRAY
69895: PUSH
69896: LD_INT 1
69898: ARRAY
69899: PPUSH
69900: CALL 16252 0 3
69904: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69905: LD_EXP 52
69909: PUSH
69910: LD_VAR 0 2
69914: ARRAY
69915: PUSH
69916: LD_INT 1
69918: ARRAY
69919: PPUSH
69920: LD_INT 112
69922: PPUSH
69923: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69927: LD_ADDR_VAR 0 9
69931: PUSH
69932: LD_EXP 52
69936: PUSH
69937: LD_VAR 0 2
69941: ARRAY
69942: PPUSH
69943: LD_INT 1
69945: PPUSH
69946: CALL_OW 3
69950: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69951: LD_ADDR_EXP 52
69955: PUSH
69956: LD_EXP 52
69960: PPUSH
69961: LD_VAR 0 2
69965: PPUSH
69966: LD_VAR 0 9
69970: PPUSH
69971: CALL_OW 1
69975: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69976: LD_EXP 52
69980: PUSH
69981: LD_VAR 0 2
69985: ARRAY
69986: PUSH
69987: LD_EXP 53
69991: PUSH
69992: LD_VAR 0 2
69996: ARRAY
69997: AND
69998: PUSH
69999: LD_EXP 53
70003: PUSH
70004: LD_VAR 0 2
70008: ARRAY
70009: PUSH
70010: LD_INT 1
70012: ARRAY
70013: PPUSH
70014: CALL_OW 310
70018: NOT
70019: AND
70020: PUSH
70021: LD_VAR 0 3
70025: PPUSH
70026: CALL_OW 313
70030: PUSH
70031: LD_INT 6
70033: EQUAL
70034: AND
70035: IFFALSE 70091
// begin tmp2 := UnitsInside ( j ) ;
70037: LD_ADDR_VAR 0 9
70041: PUSH
70042: LD_VAR 0 3
70046: PPUSH
70047: CALL_OW 313
70051: ST_TO_ADDR
// if tmp2 = 6 then
70052: LD_VAR 0 9
70056: PUSH
70057: LD_INT 6
70059: EQUAL
70060: IFFALSE 70091
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70062: LD_VAR 0 9
70066: PUSH
70067: LD_INT 1
70069: ARRAY
70070: PPUSH
70071: LD_INT 112
70073: PPUSH
70074: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70078: LD_VAR 0 9
70082: PUSH
70083: LD_INT 1
70085: ARRAY
70086: PPUSH
70087: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70091: LD_EXP 53
70095: PUSH
70096: LD_VAR 0 2
70100: ARRAY
70101: PUSH
70102: LD_EXP 53
70106: PUSH
70107: LD_VAR 0 2
70111: ARRAY
70112: PUSH
70113: LD_INT 1
70115: ARRAY
70116: PPUSH
70117: CALL_OW 314
70121: NOT
70122: AND
70123: PUSH
70124: LD_EXP 53
70128: PUSH
70129: LD_VAR 0 2
70133: ARRAY
70134: PUSH
70135: LD_INT 1
70137: ARRAY
70138: PPUSH
70139: CALL_OW 310
70143: NOT
70144: AND
70145: IFFALSE 70171
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70147: LD_EXP 53
70151: PUSH
70152: LD_VAR 0 2
70156: ARRAY
70157: PUSH
70158: LD_INT 1
70160: ARRAY
70161: PPUSH
70162: LD_VAR 0 3
70166: PPUSH
70167: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70171: LD_EXP 53
70175: PUSH
70176: LD_VAR 0 2
70180: ARRAY
70181: PUSH
70182: LD_INT 1
70184: ARRAY
70185: PPUSH
70186: CALL_OW 310
70190: PUSH
70191: LD_EXP 53
70195: PUSH
70196: LD_VAR 0 2
70200: ARRAY
70201: PUSH
70202: LD_INT 1
70204: ARRAY
70205: PPUSH
70206: CALL_OW 310
70210: PPUSH
70211: CALL_OW 461
70215: PUSH
70216: LD_INT 3
70218: NONEQUAL
70219: AND
70220: IFFALSE 70241
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70222: LD_EXP 53
70226: PUSH
70227: LD_VAR 0 2
70231: ARRAY
70232: PUSH
70233: LD_INT 1
70235: ARRAY
70236: PPUSH
70237: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70241: LD_VAR 0 3
70245: PPUSH
70246: CALL_OW 461
70250: PUSH
70251: LD_INT 6
70253: EQUAL
70254: PUSH
70255: LD_VAR 0 6
70259: PUSH
70260: LD_INT 1
70262: GREATER
70263: AND
70264: IFFALSE 70416
// begin sci := [ ] ;
70266: LD_ADDR_VAR 0 8
70270: PUSH
70271: EMPTY
70272: ST_TO_ADDR
// for x in ( tmp diff j ) do
70273: LD_ADDR_VAR 0 7
70277: PUSH
70278: LD_VAR 0 6
70282: PUSH
70283: LD_VAR 0 3
70287: DIFF
70288: PUSH
70289: FOR_IN
70290: IFFALSE 70342
// begin if sci = 6 then
70292: LD_VAR 0 8
70296: PUSH
70297: LD_INT 6
70299: EQUAL
70300: IFFALSE 70304
// break ;
70302: GO 70342
// if BuildingStatus ( x ) = bs_idle then
70304: LD_VAR 0 7
70308: PPUSH
70309: CALL_OW 461
70313: PUSH
70314: LD_INT 2
70316: EQUAL
70317: IFFALSE 70340
// sci := sci ^ UnitsInside ( x ) ;
70319: LD_ADDR_VAR 0 8
70323: PUSH
70324: LD_VAR 0 8
70328: PUSH
70329: LD_VAR 0 7
70333: PPUSH
70334: CALL_OW 313
70338: ADD
70339: ST_TO_ADDR
// end ;
70340: GO 70289
70342: POP
70343: POP
// if not sci then
70344: LD_VAR 0 8
70348: NOT
70349: IFFALSE 70353
// continue ;
70351: GO 69398
// for x in sci do
70353: LD_ADDR_VAR 0 7
70357: PUSH
70358: LD_VAR 0 8
70362: PUSH
70363: FOR_IN
70364: IFFALSE 70414
// if IsInUnit ( x ) and not HasTask ( x ) then
70366: LD_VAR 0 7
70370: PPUSH
70371: CALL_OW 310
70375: PUSH
70376: LD_VAR 0 7
70380: PPUSH
70381: CALL_OW 314
70385: NOT
70386: AND
70387: IFFALSE 70412
// begin ComExitBuilding ( x ) ;
70389: LD_VAR 0 7
70393: PPUSH
70394: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70398: LD_VAR 0 7
70402: PPUSH
70403: LD_VAR 0 3
70407: PPUSH
70408: CALL_OW 180
// end ;
70412: GO 70363
70414: POP
70415: POP
// end ; end ;
70416: GO 69398
70418: POP
70419: POP
// end ;
70420: GO 69352
70422: POP
70423: POP
// end ;
70424: LD_VAR 0 1
70428: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70429: LD_INT 0
70431: PPUSH
70432: PPUSH
// if not mc_bases then
70433: LD_EXP 23
70437: NOT
70438: IFFALSE 70442
// exit ;
70440: GO 70523
// for i = 1 to mc_bases do
70442: LD_ADDR_VAR 0 2
70446: PUSH
70447: DOUBLE
70448: LD_INT 1
70450: DEC
70451: ST_TO_ADDR
70452: LD_EXP 23
70456: PUSH
70457: FOR_TO
70458: IFFALSE 70521
// if mc_mines [ i ] and mc_miners [ i ] then
70460: LD_EXP 36
70464: PUSH
70465: LD_VAR 0 2
70469: ARRAY
70470: PUSH
70471: LD_EXP 37
70475: PUSH
70476: LD_VAR 0 2
70480: ARRAY
70481: AND
70482: IFFALSE 70519
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70484: LD_EXP 37
70488: PUSH
70489: LD_VAR 0 2
70493: ARRAY
70494: PUSH
70495: LD_INT 1
70497: ARRAY
70498: PPUSH
70499: CALL_OW 255
70503: PPUSH
70504: LD_EXP 36
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PPUSH
70515: CALL 13054 0 2
70519: GO 70457
70521: POP
70522: POP
// end ;
70523: LD_VAR 0 1
70527: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70528: LD_INT 0
70530: PPUSH
70531: PPUSH
70532: PPUSH
70533: PPUSH
70534: PPUSH
70535: PPUSH
70536: PPUSH
70537: PPUSH
// if not mc_bases or not mc_parking then
70538: LD_EXP 23
70542: NOT
70543: PUSH
70544: LD_EXP 47
70548: NOT
70549: OR
70550: IFFALSE 70554
// exit ;
70552: GO 71292
// for i = 1 to mc_bases do
70554: LD_ADDR_VAR 0 2
70558: PUSH
70559: DOUBLE
70560: LD_INT 1
70562: DEC
70563: ST_TO_ADDR
70564: LD_EXP 23
70568: PUSH
70569: FOR_TO
70570: IFFALSE 71290
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70572: LD_EXP 23
70576: PUSH
70577: LD_VAR 0 2
70581: ARRAY
70582: NOT
70583: PUSH
70584: LD_EXP 47
70588: PUSH
70589: LD_VAR 0 2
70593: ARRAY
70594: NOT
70595: OR
70596: IFFALSE 70600
// continue ;
70598: GO 70569
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70600: LD_ADDR_VAR 0 5
70604: PUSH
70605: LD_EXP 23
70609: PUSH
70610: LD_VAR 0 2
70614: ARRAY
70615: PUSH
70616: LD_INT 1
70618: ARRAY
70619: PPUSH
70620: CALL_OW 255
70624: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70625: LD_ADDR_VAR 0 6
70629: PUSH
70630: LD_EXP 23
70634: PUSH
70635: LD_VAR 0 2
70639: ARRAY
70640: PPUSH
70641: LD_INT 30
70643: PUSH
70644: LD_INT 3
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PPUSH
70651: CALL_OW 72
70655: ST_TO_ADDR
// if not fac then
70656: LD_VAR 0 6
70660: NOT
70661: IFFALSE 70712
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70663: LD_ADDR_VAR 0 6
70667: PUSH
70668: LD_EXP 23
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: PPUSH
70679: LD_INT 2
70681: PUSH
70682: LD_INT 30
70684: PUSH
70685: LD_INT 0
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: PUSH
70692: LD_INT 30
70694: PUSH
70695: LD_INT 1
70697: PUSH
70698: EMPTY
70699: LIST
70700: LIST
70701: PUSH
70702: EMPTY
70703: LIST
70704: LIST
70705: LIST
70706: PPUSH
70707: CALL_OW 72
70711: ST_TO_ADDR
// if not fac then
70712: LD_VAR 0 6
70716: NOT
70717: IFFALSE 70721
// continue ;
70719: GO 70569
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70721: LD_ADDR_VAR 0 7
70725: PUSH
70726: LD_EXP 47
70730: PUSH
70731: LD_VAR 0 2
70735: ARRAY
70736: PPUSH
70737: LD_INT 22
70739: PUSH
70740: LD_VAR 0 5
70744: PUSH
70745: EMPTY
70746: LIST
70747: LIST
70748: PUSH
70749: LD_INT 21
70751: PUSH
70752: LD_INT 2
70754: PUSH
70755: EMPTY
70756: LIST
70757: LIST
70758: PUSH
70759: LD_INT 3
70761: PUSH
70762: LD_INT 60
70764: PUSH
70765: EMPTY
70766: LIST
70767: PUSH
70768: EMPTY
70769: LIST
70770: LIST
70771: PUSH
70772: LD_INT 3
70774: PUSH
70775: LD_INT 24
70777: PUSH
70778: LD_INT 1000
70780: PUSH
70781: EMPTY
70782: LIST
70783: LIST
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: EMPTY
70790: LIST
70791: LIST
70792: LIST
70793: LIST
70794: PPUSH
70795: CALL_OW 70
70799: ST_TO_ADDR
// for j in fac do
70800: LD_ADDR_VAR 0 3
70804: PUSH
70805: LD_VAR 0 6
70809: PUSH
70810: FOR_IN
70811: IFFALSE 70906
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70813: LD_ADDR_VAR 0 7
70817: PUSH
70818: LD_VAR 0 7
70822: PUSH
70823: LD_INT 22
70825: PUSH
70826: LD_VAR 0 5
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 91
70837: PUSH
70838: LD_VAR 0 3
70842: PUSH
70843: LD_INT 15
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 21
70853: PUSH
70854: LD_INT 2
70856: PUSH
70857: EMPTY
70858: LIST
70859: LIST
70860: PUSH
70861: LD_INT 3
70863: PUSH
70864: LD_INT 60
70866: PUSH
70867: EMPTY
70868: LIST
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 3
70876: PUSH
70877: LD_INT 24
70879: PUSH
70880: LD_INT 1000
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: EMPTY
70888: LIST
70889: LIST
70890: PUSH
70891: EMPTY
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: PPUSH
70898: CALL_OW 69
70902: UNION
70903: ST_TO_ADDR
70904: GO 70810
70906: POP
70907: POP
// if not vehs then
70908: LD_VAR 0 7
70912: NOT
70913: IFFALSE 70939
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70915: LD_ADDR_EXP 35
70919: PUSH
70920: LD_EXP 35
70924: PPUSH
70925: LD_VAR 0 2
70929: PPUSH
70930: EMPTY
70931: PPUSH
70932: CALL_OW 1
70936: ST_TO_ADDR
// continue ;
70937: GO 70569
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70939: LD_ADDR_VAR 0 8
70943: PUSH
70944: LD_EXP 23
70948: PUSH
70949: LD_VAR 0 2
70953: ARRAY
70954: PPUSH
70955: LD_INT 30
70957: PUSH
70958: LD_INT 3
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PPUSH
70965: CALL_OW 72
70969: ST_TO_ADDR
// if tmp then
70970: LD_VAR 0 8
70974: IFFALSE 71077
// begin for j in tmp do
70976: LD_ADDR_VAR 0 3
70980: PUSH
70981: LD_VAR 0 8
70985: PUSH
70986: FOR_IN
70987: IFFALSE 71075
// for k in UnitsInside ( j ) do
70989: LD_ADDR_VAR 0 4
70993: PUSH
70994: LD_VAR 0 3
70998: PPUSH
70999: CALL_OW 313
71003: PUSH
71004: FOR_IN
71005: IFFALSE 71071
// if k then
71007: LD_VAR 0 4
71011: IFFALSE 71069
// if not k in mc_repair_vehicle [ i ] then
71013: LD_VAR 0 4
71017: PUSH
71018: LD_EXP 35
71022: PUSH
71023: LD_VAR 0 2
71027: ARRAY
71028: IN
71029: NOT
71030: IFFALSE 71069
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71032: LD_ADDR_EXP 35
71036: PUSH
71037: LD_EXP 35
71041: PPUSH
71042: LD_VAR 0 2
71046: PPUSH
71047: LD_EXP 35
71051: PUSH
71052: LD_VAR 0 2
71056: ARRAY
71057: PUSH
71058: LD_VAR 0 4
71062: UNION
71063: PPUSH
71064: CALL_OW 1
71068: ST_TO_ADDR
71069: GO 71004
71071: POP
71072: POP
71073: GO 70986
71075: POP
71076: POP
// end ; if not mc_repair_vehicle [ i ] then
71077: LD_EXP 35
71081: PUSH
71082: LD_VAR 0 2
71086: ARRAY
71087: NOT
71088: IFFALSE 71092
// continue ;
71090: GO 70569
// for j in mc_repair_vehicle [ i ] do
71092: LD_ADDR_VAR 0 3
71096: PUSH
71097: LD_EXP 35
71101: PUSH
71102: LD_VAR 0 2
71106: ARRAY
71107: PUSH
71108: FOR_IN
71109: IFFALSE 71286
// begin if GetClass ( j ) <> 3 then
71111: LD_VAR 0 3
71115: PPUSH
71116: CALL_OW 257
71120: PUSH
71121: LD_INT 3
71123: NONEQUAL
71124: IFFALSE 71165
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71126: LD_ADDR_EXP 35
71130: PUSH
71131: LD_EXP 35
71135: PPUSH
71136: LD_VAR 0 2
71140: PPUSH
71141: LD_EXP 35
71145: PUSH
71146: LD_VAR 0 2
71150: ARRAY
71151: PUSH
71152: LD_VAR 0 3
71156: DIFF
71157: PPUSH
71158: CALL_OW 1
71162: ST_TO_ADDR
// continue ;
71163: GO 71108
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71165: LD_VAR 0 3
71169: PPUSH
71170: CALL_OW 311
71174: NOT
71175: PUSH
71176: LD_VAR 0 3
71180: PUSH
71181: LD_EXP 26
71185: PUSH
71186: LD_VAR 0 2
71190: ARRAY
71191: PUSH
71192: LD_INT 1
71194: ARRAY
71195: IN
71196: NOT
71197: AND
71198: PUSH
71199: LD_VAR 0 3
71203: PUSH
71204: LD_EXP 26
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_INT 2
71217: ARRAY
71218: IN
71219: NOT
71220: AND
71221: IFFALSE 71284
// begin if IsInUnit ( j ) then
71223: LD_VAR 0 3
71227: PPUSH
71228: CALL_OW 310
71232: IFFALSE 71245
// ComExitBuilding ( j ) else
71234: LD_VAR 0 3
71238: PPUSH
71239: CALL_OW 122
71243: GO 71284
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71245: LD_VAR 0 3
71249: PPUSH
71250: LD_VAR 0 7
71254: PUSH
71255: LD_INT 1
71257: ARRAY
71258: PPUSH
71259: CALL 50648 0 2
71263: NOT
71264: IFFALSE 71284
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71266: LD_VAR 0 3
71270: PPUSH
71271: LD_VAR 0 7
71275: PUSH
71276: LD_INT 1
71278: ARRAY
71279: PPUSH
71280: CALL_OW 129
// end ; end ;
71284: GO 71108
71286: POP
71287: POP
// end ;
71288: GO 70569
71290: POP
71291: POP
// end ;
71292: LD_VAR 0 1
71296: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71297: LD_INT 0
71299: PPUSH
71300: PPUSH
71301: PPUSH
71302: PPUSH
71303: PPUSH
71304: PPUSH
71305: PPUSH
71306: PPUSH
71307: PPUSH
71308: PPUSH
71309: PPUSH
// if not mc_bases then
71310: LD_EXP 23
71314: NOT
71315: IFFALSE 71319
// exit ;
71317: GO 72121
// for i = 1 to mc_bases do
71319: LD_ADDR_VAR 0 2
71323: PUSH
71324: DOUBLE
71325: LD_INT 1
71327: DEC
71328: ST_TO_ADDR
71329: LD_EXP 23
71333: PUSH
71334: FOR_TO
71335: IFFALSE 72119
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71337: LD_EXP 51
71341: PUSH
71342: LD_VAR 0 2
71346: ARRAY
71347: NOT
71348: PUSH
71349: LD_EXP 26
71353: PUSH
71354: LD_VAR 0 2
71358: ARRAY
71359: PUSH
71360: LD_INT 1
71362: ARRAY
71363: OR
71364: PUSH
71365: LD_EXP 26
71369: PUSH
71370: LD_VAR 0 2
71374: ARRAY
71375: PUSH
71376: LD_INT 2
71378: ARRAY
71379: OR
71380: PUSH
71381: LD_EXP 49
71385: PUSH
71386: LD_VAR 0 2
71390: ARRAY
71391: PPUSH
71392: LD_INT 1
71394: PPUSH
71395: CALL_OW 325
71399: NOT
71400: OR
71401: PUSH
71402: LD_EXP 46
71406: PUSH
71407: LD_VAR 0 2
71411: ARRAY
71412: OR
71413: IFFALSE 71417
// continue ;
71415: GO 71334
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71417: LD_ADDR_VAR 0 8
71421: PUSH
71422: LD_EXP 23
71426: PUSH
71427: LD_VAR 0 2
71431: ARRAY
71432: PPUSH
71433: LD_INT 25
71435: PUSH
71436: LD_INT 4
71438: PUSH
71439: EMPTY
71440: LIST
71441: LIST
71442: PUSH
71443: LD_INT 50
71445: PUSH
71446: EMPTY
71447: LIST
71448: PUSH
71449: LD_INT 3
71451: PUSH
71452: LD_INT 60
71454: PUSH
71455: EMPTY
71456: LIST
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: LIST
71466: PPUSH
71467: CALL_OW 72
71471: PUSH
71472: LD_EXP 27
71476: PUSH
71477: LD_VAR 0 2
71481: ARRAY
71482: DIFF
71483: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71484: LD_ADDR_VAR 0 9
71488: PUSH
71489: LD_EXP 23
71493: PUSH
71494: LD_VAR 0 2
71498: ARRAY
71499: PPUSH
71500: LD_INT 2
71502: PUSH
71503: LD_INT 30
71505: PUSH
71506: LD_INT 0
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 30
71515: PUSH
71516: LD_INT 1
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: EMPTY
71524: LIST
71525: LIST
71526: LIST
71527: PPUSH
71528: CALL_OW 72
71532: ST_TO_ADDR
// if not tmp or not dep then
71533: LD_VAR 0 8
71537: NOT
71538: PUSH
71539: LD_VAR 0 9
71543: NOT
71544: OR
71545: IFFALSE 71549
// continue ;
71547: GO 71334
// side := GetSide ( tmp [ 1 ] ) ;
71549: LD_ADDR_VAR 0 11
71553: PUSH
71554: LD_VAR 0 8
71558: PUSH
71559: LD_INT 1
71561: ARRAY
71562: PPUSH
71563: CALL_OW 255
71567: ST_TO_ADDR
// dep := dep [ 1 ] ;
71568: LD_ADDR_VAR 0 9
71572: PUSH
71573: LD_VAR 0 9
71577: PUSH
71578: LD_INT 1
71580: ARRAY
71581: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71582: LD_ADDR_VAR 0 7
71586: PUSH
71587: LD_EXP 51
71591: PUSH
71592: LD_VAR 0 2
71596: ARRAY
71597: PPUSH
71598: LD_INT 22
71600: PUSH
71601: LD_INT 0
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: PUSH
71608: LD_INT 25
71610: PUSH
71611: LD_INT 12
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PPUSH
71622: CALL_OW 70
71626: PUSH
71627: LD_INT 22
71629: PUSH
71630: LD_INT 0
71632: PUSH
71633: EMPTY
71634: LIST
71635: LIST
71636: PUSH
71637: LD_INT 25
71639: PUSH
71640: LD_INT 12
71642: PUSH
71643: EMPTY
71644: LIST
71645: LIST
71646: PUSH
71647: LD_INT 91
71649: PUSH
71650: LD_VAR 0 9
71654: PUSH
71655: LD_INT 20
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: LIST
71662: PUSH
71663: EMPTY
71664: LIST
71665: LIST
71666: LIST
71667: PPUSH
71668: CALL_OW 69
71672: UNION
71673: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71674: LD_ADDR_VAR 0 10
71678: PUSH
71679: LD_EXP 51
71683: PUSH
71684: LD_VAR 0 2
71688: ARRAY
71689: PPUSH
71690: LD_INT 81
71692: PUSH
71693: LD_VAR 0 11
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PPUSH
71702: CALL_OW 70
71706: ST_TO_ADDR
// if not apes or danger_at_area then
71707: LD_VAR 0 7
71711: NOT
71712: PUSH
71713: LD_VAR 0 10
71717: OR
71718: IFFALSE 71768
// begin if mc_taming [ i ] then
71720: LD_EXP 54
71724: PUSH
71725: LD_VAR 0 2
71729: ARRAY
71730: IFFALSE 71766
// begin MC_Reset ( i , 121 ) ;
71732: LD_VAR 0 2
71736: PPUSH
71737: LD_INT 121
71739: PPUSH
71740: CALL 56705 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71744: LD_ADDR_EXP 54
71748: PUSH
71749: LD_EXP 54
71753: PPUSH
71754: LD_VAR 0 2
71758: PPUSH
71759: EMPTY
71760: PPUSH
71761: CALL_OW 1
71765: ST_TO_ADDR
// end ; continue ;
71766: GO 71334
// end ; for j in tmp do
71768: LD_ADDR_VAR 0 3
71772: PUSH
71773: LD_VAR 0 8
71777: PUSH
71778: FOR_IN
71779: IFFALSE 72115
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71781: LD_VAR 0 3
71785: PUSH
71786: LD_EXP 54
71790: PUSH
71791: LD_VAR 0 2
71795: ARRAY
71796: IN
71797: NOT
71798: PUSH
71799: LD_EXP 54
71803: PUSH
71804: LD_VAR 0 2
71808: ARRAY
71809: PUSH
71810: LD_INT 3
71812: LESS
71813: AND
71814: IFFALSE 71872
// begin SetTag ( j , 121 ) ;
71816: LD_VAR 0 3
71820: PPUSH
71821: LD_INT 121
71823: PPUSH
71824: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71828: LD_ADDR_EXP 54
71832: PUSH
71833: LD_EXP 54
71837: PPUSH
71838: LD_VAR 0 2
71842: PUSH
71843: LD_EXP 54
71847: PUSH
71848: LD_VAR 0 2
71852: ARRAY
71853: PUSH
71854: LD_INT 1
71856: PLUS
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PPUSH
71862: LD_VAR 0 3
71866: PPUSH
71867: CALL 16252 0 3
71871: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71872: LD_VAR 0 3
71876: PUSH
71877: LD_EXP 54
71881: PUSH
71882: LD_VAR 0 2
71886: ARRAY
71887: IN
71888: IFFALSE 72113
// begin if GetClass ( j ) <> 4 then
71890: LD_VAR 0 3
71894: PPUSH
71895: CALL_OW 257
71899: PUSH
71900: LD_INT 4
71902: NONEQUAL
71903: IFFALSE 71956
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71905: LD_ADDR_EXP 54
71909: PUSH
71910: LD_EXP 54
71914: PPUSH
71915: LD_VAR 0 2
71919: PPUSH
71920: LD_EXP 54
71924: PUSH
71925: LD_VAR 0 2
71929: ARRAY
71930: PUSH
71931: LD_VAR 0 3
71935: DIFF
71936: PPUSH
71937: CALL_OW 1
71941: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71942: LD_VAR 0 3
71946: PPUSH
71947: LD_INT 0
71949: PPUSH
71950: CALL_OW 109
// continue ;
71954: GO 71778
// end ; if IsInUnit ( j ) then
71956: LD_VAR 0 3
71960: PPUSH
71961: CALL_OW 310
71965: IFFALSE 71976
// ComExitBuilding ( j ) ;
71967: LD_VAR 0 3
71971: PPUSH
71972: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71976: LD_ADDR_VAR 0 6
71980: PUSH
71981: LD_VAR 0 7
71985: PPUSH
71986: LD_VAR 0 3
71990: PPUSH
71991: CALL_OW 74
71995: ST_TO_ADDR
// if not ape then
71996: LD_VAR 0 6
72000: NOT
72001: IFFALSE 72005
// break ;
72003: GO 72115
// x := GetX ( ape ) ;
72005: LD_ADDR_VAR 0 4
72009: PUSH
72010: LD_VAR 0 6
72014: PPUSH
72015: CALL_OW 250
72019: ST_TO_ADDR
// y := GetY ( ape ) ;
72020: LD_ADDR_VAR 0 5
72024: PUSH
72025: LD_VAR 0 6
72029: PPUSH
72030: CALL_OW 251
72034: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72035: LD_VAR 0 4
72039: PPUSH
72040: LD_VAR 0 5
72044: PPUSH
72045: CALL_OW 488
72049: NOT
72050: PUSH
72051: LD_VAR 0 11
72055: PPUSH
72056: LD_VAR 0 4
72060: PPUSH
72061: LD_VAR 0 5
72065: PPUSH
72066: LD_INT 20
72068: PPUSH
72069: CALL 17148 0 4
72073: PUSH
72074: LD_INT 4
72076: ARRAY
72077: OR
72078: IFFALSE 72082
// break ;
72080: GO 72115
// if not HasTask ( j ) then
72082: LD_VAR 0 3
72086: PPUSH
72087: CALL_OW 314
72091: NOT
72092: IFFALSE 72113
// ComTameXY ( j , x , y ) ;
72094: LD_VAR 0 3
72098: PPUSH
72099: LD_VAR 0 4
72103: PPUSH
72104: LD_VAR 0 5
72108: PPUSH
72109: CALL_OW 131
// end ; end ;
72113: GO 71778
72115: POP
72116: POP
// end ;
72117: GO 71334
72119: POP
72120: POP
// end ;
72121: LD_VAR 0 1
72125: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72126: LD_INT 0
72128: PPUSH
72129: PPUSH
72130: PPUSH
72131: PPUSH
72132: PPUSH
72133: PPUSH
72134: PPUSH
72135: PPUSH
// if not mc_bases then
72136: LD_EXP 23
72140: NOT
72141: IFFALSE 72145
// exit ;
72143: GO 72771
// for i = 1 to mc_bases do
72145: LD_ADDR_VAR 0 2
72149: PUSH
72150: DOUBLE
72151: LD_INT 1
72153: DEC
72154: ST_TO_ADDR
72155: LD_EXP 23
72159: PUSH
72160: FOR_TO
72161: IFFALSE 72769
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72163: LD_EXP 52
72167: PUSH
72168: LD_VAR 0 2
72172: ARRAY
72173: NOT
72174: PUSH
72175: LD_EXP 52
72179: PUSH
72180: LD_VAR 0 2
72184: ARRAY
72185: PPUSH
72186: LD_INT 25
72188: PUSH
72189: LD_INT 12
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PPUSH
72196: CALL_OW 72
72200: NOT
72201: OR
72202: IFFALSE 72206
// continue ;
72204: GO 72160
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72206: LD_ADDR_VAR 0 5
72210: PUSH
72211: LD_EXP 52
72215: PUSH
72216: LD_VAR 0 2
72220: ARRAY
72221: PUSH
72222: LD_INT 1
72224: ARRAY
72225: PPUSH
72226: CALL_OW 255
72230: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72231: LD_VAR 0 5
72235: PPUSH
72236: LD_INT 2
72238: PPUSH
72239: CALL_OW 325
72243: IFFALSE 72496
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72245: LD_ADDR_VAR 0 4
72249: PUSH
72250: LD_EXP 52
72254: PUSH
72255: LD_VAR 0 2
72259: ARRAY
72260: PPUSH
72261: LD_INT 25
72263: PUSH
72264: LD_INT 16
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PPUSH
72271: CALL_OW 72
72275: ST_TO_ADDR
// if tmp < 6 then
72276: LD_VAR 0 4
72280: PUSH
72281: LD_INT 6
72283: LESS
72284: IFFALSE 72496
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72286: LD_ADDR_VAR 0 6
72290: PUSH
72291: LD_EXP 23
72295: PUSH
72296: LD_VAR 0 2
72300: ARRAY
72301: PPUSH
72302: LD_INT 2
72304: PUSH
72305: LD_INT 30
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 30
72317: PUSH
72318: LD_INT 1
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: LIST
72329: PPUSH
72330: CALL_OW 72
72334: ST_TO_ADDR
// if depot then
72335: LD_VAR 0 6
72339: IFFALSE 72496
// begin selected := 0 ;
72341: LD_ADDR_VAR 0 7
72345: PUSH
72346: LD_INT 0
72348: ST_TO_ADDR
// for j in depot do
72349: LD_ADDR_VAR 0 3
72353: PUSH
72354: LD_VAR 0 6
72358: PUSH
72359: FOR_IN
72360: IFFALSE 72391
// begin if UnitsInside ( j ) < 6 then
72362: LD_VAR 0 3
72366: PPUSH
72367: CALL_OW 313
72371: PUSH
72372: LD_INT 6
72374: LESS
72375: IFFALSE 72389
// begin selected := j ;
72377: LD_ADDR_VAR 0 7
72381: PUSH
72382: LD_VAR 0 3
72386: ST_TO_ADDR
// break ;
72387: GO 72391
// end ; end ;
72389: GO 72359
72391: POP
72392: POP
// if selected then
72393: LD_VAR 0 7
72397: IFFALSE 72496
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72399: LD_ADDR_VAR 0 3
72403: PUSH
72404: LD_EXP 52
72408: PUSH
72409: LD_VAR 0 2
72413: ARRAY
72414: PPUSH
72415: LD_INT 25
72417: PUSH
72418: LD_INT 12
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PPUSH
72425: CALL_OW 72
72429: PUSH
72430: FOR_IN
72431: IFFALSE 72494
// if not HasTask ( j ) then
72433: LD_VAR 0 3
72437: PPUSH
72438: CALL_OW 314
72442: NOT
72443: IFFALSE 72492
// begin if not IsInUnit ( j ) then
72445: LD_VAR 0 3
72449: PPUSH
72450: CALL_OW 310
72454: NOT
72455: IFFALSE 72471
// ComEnterUnit ( j , selected ) ;
72457: LD_VAR 0 3
72461: PPUSH
72462: LD_VAR 0 7
72466: PPUSH
72467: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72471: LD_VAR 0 3
72475: PPUSH
72476: LD_INT 16
72478: PPUSH
72479: CALL_OW 183
// AddComExitBuilding ( j ) ;
72483: LD_VAR 0 3
72487: PPUSH
72488: CALL_OW 182
// end ;
72492: GO 72430
72494: POP
72495: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72496: LD_VAR 0 5
72500: PPUSH
72501: LD_INT 11
72503: PPUSH
72504: CALL_OW 325
72508: IFFALSE 72767
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72510: LD_ADDR_VAR 0 4
72514: PUSH
72515: LD_EXP 52
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PPUSH
72526: LD_INT 25
72528: PUSH
72529: LD_INT 16
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: PPUSH
72536: CALL_OW 72
72540: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72541: LD_VAR 0 4
72545: PUSH
72546: LD_INT 6
72548: GREATEREQUAL
72549: PUSH
72550: LD_VAR 0 5
72554: PPUSH
72555: LD_INT 2
72557: PPUSH
72558: CALL_OW 325
72562: NOT
72563: OR
72564: IFFALSE 72767
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72566: LD_ADDR_VAR 0 8
72570: PUSH
72571: LD_EXP 23
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PPUSH
72582: LD_INT 2
72584: PUSH
72585: LD_INT 30
72587: PUSH
72588: LD_INT 4
72590: PUSH
72591: EMPTY
72592: LIST
72593: LIST
72594: PUSH
72595: LD_INT 30
72597: PUSH
72598: LD_INT 5
72600: PUSH
72601: EMPTY
72602: LIST
72603: LIST
72604: PUSH
72605: EMPTY
72606: LIST
72607: LIST
72608: LIST
72609: PPUSH
72610: CALL_OW 72
72614: ST_TO_ADDR
// if barracks then
72615: LD_VAR 0 8
72619: IFFALSE 72767
// begin selected := 0 ;
72621: LD_ADDR_VAR 0 7
72625: PUSH
72626: LD_INT 0
72628: ST_TO_ADDR
// for j in barracks do
72629: LD_ADDR_VAR 0 3
72633: PUSH
72634: LD_VAR 0 8
72638: PUSH
72639: FOR_IN
72640: IFFALSE 72671
// begin if UnitsInside ( j ) < 6 then
72642: LD_VAR 0 3
72646: PPUSH
72647: CALL_OW 313
72651: PUSH
72652: LD_INT 6
72654: LESS
72655: IFFALSE 72669
// begin selected := j ;
72657: LD_ADDR_VAR 0 7
72661: PUSH
72662: LD_VAR 0 3
72666: ST_TO_ADDR
// break ;
72667: GO 72671
// end ; end ;
72669: GO 72639
72671: POP
72672: POP
// if selected then
72673: LD_VAR 0 7
72677: IFFALSE 72767
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72679: LD_ADDR_VAR 0 3
72683: PUSH
72684: LD_EXP 52
72688: PUSH
72689: LD_VAR 0 2
72693: ARRAY
72694: PPUSH
72695: LD_INT 25
72697: PUSH
72698: LD_INT 12
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PPUSH
72705: CALL_OW 72
72709: PUSH
72710: FOR_IN
72711: IFFALSE 72765
// if not IsInUnit ( j ) and not HasTask ( j ) then
72713: LD_VAR 0 3
72717: PPUSH
72718: CALL_OW 310
72722: NOT
72723: PUSH
72724: LD_VAR 0 3
72728: PPUSH
72729: CALL_OW 314
72733: NOT
72734: AND
72735: IFFALSE 72763
// begin ComEnterUnit ( j , selected ) ;
72737: LD_VAR 0 3
72741: PPUSH
72742: LD_VAR 0 7
72746: PPUSH
72747: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72751: LD_VAR 0 3
72755: PPUSH
72756: LD_INT 15
72758: PPUSH
72759: CALL_OW 183
// end ;
72763: GO 72710
72765: POP
72766: POP
// end ; end ; end ; end ; end ;
72767: GO 72160
72769: POP
72770: POP
// end ;
72771: LD_VAR 0 1
72775: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72776: LD_INT 0
72778: PPUSH
72779: PPUSH
72780: PPUSH
72781: PPUSH
// if not mc_bases then
72782: LD_EXP 23
72786: NOT
72787: IFFALSE 72791
// exit ;
72789: GO 72969
// for i = 1 to mc_bases do
72791: LD_ADDR_VAR 0 2
72795: PUSH
72796: DOUBLE
72797: LD_INT 1
72799: DEC
72800: ST_TO_ADDR
72801: LD_EXP 23
72805: PUSH
72806: FOR_TO
72807: IFFALSE 72967
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72809: LD_ADDR_VAR 0 4
72813: PUSH
72814: LD_EXP 23
72818: PUSH
72819: LD_VAR 0 2
72823: ARRAY
72824: PPUSH
72825: LD_INT 25
72827: PUSH
72828: LD_INT 9
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PPUSH
72835: CALL_OW 72
72839: ST_TO_ADDR
// if not tmp then
72840: LD_VAR 0 4
72844: NOT
72845: IFFALSE 72849
// continue ;
72847: GO 72806
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72849: LD_EXP 49
72853: PUSH
72854: LD_VAR 0 2
72858: ARRAY
72859: PPUSH
72860: LD_INT 29
72862: PPUSH
72863: CALL_OW 325
72867: NOT
72868: PUSH
72869: LD_EXP 49
72873: PUSH
72874: LD_VAR 0 2
72878: ARRAY
72879: PPUSH
72880: LD_INT 28
72882: PPUSH
72883: CALL_OW 325
72887: NOT
72888: AND
72889: IFFALSE 72893
// continue ;
72891: GO 72806
// for j in tmp do
72893: LD_ADDR_VAR 0 3
72897: PUSH
72898: LD_VAR 0 4
72902: PUSH
72903: FOR_IN
72904: IFFALSE 72963
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72906: LD_VAR 0 3
72910: PUSH
72911: LD_EXP 26
72915: PUSH
72916: LD_VAR 0 2
72920: ARRAY
72921: PUSH
72922: LD_INT 1
72924: ARRAY
72925: IN
72926: NOT
72927: PUSH
72928: LD_VAR 0 3
72932: PUSH
72933: LD_EXP 26
72937: PUSH
72938: LD_VAR 0 2
72942: ARRAY
72943: PUSH
72944: LD_INT 2
72946: ARRAY
72947: IN
72948: NOT
72949: AND
72950: IFFALSE 72961
// ComSpaceTimeShoot ( j ) ;
72952: LD_VAR 0 3
72956: PPUSH
72957: CALL 12062 0 1
72961: GO 72903
72963: POP
72964: POP
// end ;
72965: GO 72806
72967: POP
72968: POP
// end ;
72969: LD_VAR 0 1
72973: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72974: LD_INT 0
72976: PPUSH
72977: PPUSH
72978: PPUSH
72979: PPUSH
72980: PPUSH
72981: PPUSH
72982: PPUSH
72983: PPUSH
72984: PPUSH
// if not mc_bases then
72985: LD_EXP 23
72989: NOT
72990: IFFALSE 72994
// exit ;
72992: GO 73616
// for i = 1 to mc_bases do
72994: LD_ADDR_VAR 0 2
72998: PUSH
72999: DOUBLE
73000: LD_INT 1
73002: DEC
73003: ST_TO_ADDR
73004: LD_EXP 23
73008: PUSH
73009: FOR_TO
73010: IFFALSE 73614
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73012: LD_EXP 58
73016: PUSH
73017: LD_VAR 0 2
73021: ARRAY
73022: NOT
73023: PUSH
73024: LD_INT 38
73026: PPUSH
73027: LD_EXP 49
73031: PUSH
73032: LD_VAR 0 2
73036: ARRAY
73037: PPUSH
73038: CALL_OW 321
73042: PUSH
73043: LD_INT 2
73045: NONEQUAL
73046: OR
73047: IFFALSE 73051
// continue ;
73049: GO 73009
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73051: LD_ADDR_VAR 0 8
73055: PUSH
73056: LD_EXP 23
73060: PUSH
73061: LD_VAR 0 2
73065: ARRAY
73066: PPUSH
73067: LD_INT 30
73069: PUSH
73070: LD_INT 34
73072: PUSH
73073: EMPTY
73074: LIST
73075: LIST
73076: PPUSH
73077: CALL_OW 72
73081: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73082: LD_ADDR_VAR 0 9
73086: PUSH
73087: LD_EXP 23
73091: PUSH
73092: LD_VAR 0 2
73096: ARRAY
73097: PPUSH
73098: LD_INT 25
73100: PUSH
73101: LD_INT 4
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PPUSH
73108: CALL_OW 72
73112: PPUSH
73113: LD_INT 0
73115: PPUSH
73116: CALL 46164 0 2
73120: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73121: LD_VAR 0 9
73125: NOT
73126: PUSH
73127: LD_VAR 0 8
73131: NOT
73132: OR
73133: PUSH
73134: LD_EXP 23
73138: PUSH
73139: LD_VAR 0 2
73143: ARRAY
73144: PPUSH
73145: LD_INT 124
73147: PPUSH
73148: CALL 46164 0 2
73152: OR
73153: IFFALSE 73157
// continue ;
73155: GO 73009
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73157: LD_EXP 59
73161: PUSH
73162: LD_VAR 0 2
73166: ARRAY
73167: PUSH
73168: LD_EXP 58
73172: PUSH
73173: LD_VAR 0 2
73177: ARRAY
73178: LESS
73179: PUSH
73180: LD_EXP 59
73184: PUSH
73185: LD_VAR 0 2
73189: ARRAY
73190: PUSH
73191: LD_VAR 0 8
73195: LESS
73196: AND
73197: IFFALSE 73612
// begin tmp := sci [ 1 ] ;
73199: LD_ADDR_VAR 0 7
73203: PUSH
73204: LD_VAR 0 9
73208: PUSH
73209: LD_INT 1
73211: ARRAY
73212: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73213: LD_VAR 0 7
73217: PPUSH
73218: LD_INT 124
73220: PPUSH
73221: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73225: LD_ADDR_VAR 0 3
73229: PUSH
73230: DOUBLE
73231: LD_EXP 58
73235: PUSH
73236: LD_VAR 0 2
73240: ARRAY
73241: INC
73242: ST_TO_ADDR
73243: LD_EXP 58
73247: PUSH
73248: LD_VAR 0 2
73252: ARRAY
73253: PUSH
73254: FOR_DOWNTO
73255: IFFALSE 73598
// begin if IsInUnit ( tmp ) then
73257: LD_VAR 0 7
73261: PPUSH
73262: CALL_OW 310
73266: IFFALSE 73277
// ComExitBuilding ( tmp ) ;
73268: LD_VAR 0 7
73272: PPUSH
73273: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73277: LD_INT 35
73279: PPUSH
73280: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73284: LD_VAR 0 7
73288: PPUSH
73289: CALL_OW 310
73293: NOT
73294: PUSH
73295: LD_VAR 0 7
73299: PPUSH
73300: CALL_OW 314
73304: NOT
73305: AND
73306: IFFALSE 73277
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73308: LD_ADDR_VAR 0 6
73312: PUSH
73313: LD_VAR 0 7
73317: PPUSH
73318: CALL_OW 250
73322: PUSH
73323: LD_VAR 0 7
73327: PPUSH
73328: CALL_OW 251
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73337: LD_INT 35
73339: PPUSH
73340: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73344: LD_ADDR_VAR 0 4
73348: PUSH
73349: LD_EXP 58
73353: PUSH
73354: LD_VAR 0 2
73358: ARRAY
73359: PUSH
73360: LD_VAR 0 3
73364: ARRAY
73365: PUSH
73366: LD_INT 1
73368: ARRAY
73369: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73370: LD_ADDR_VAR 0 5
73374: PUSH
73375: LD_EXP 58
73379: PUSH
73380: LD_VAR 0 2
73384: ARRAY
73385: PUSH
73386: LD_VAR 0 3
73390: ARRAY
73391: PUSH
73392: LD_INT 2
73394: ARRAY
73395: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73396: LD_VAR 0 7
73400: PPUSH
73401: LD_INT 10
73403: PPUSH
73404: CALL 18849 0 2
73408: PUSH
73409: LD_INT 4
73411: ARRAY
73412: IFFALSE 73450
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73414: LD_VAR 0 7
73418: PPUSH
73419: LD_VAR 0 6
73423: PUSH
73424: LD_INT 1
73426: ARRAY
73427: PPUSH
73428: LD_VAR 0 6
73432: PUSH
73433: LD_INT 2
73435: ARRAY
73436: PPUSH
73437: CALL_OW 111
// wait ( 0 0$10 ) ;
73441: LD_INT 350
73443: PPUSH
73444: CALL_OW 67
// end else
73448: GO 73476
// begin ComMoveXY ( tmp , x , y ) ;
73450: LD_VAR 0 7
73454: PPUSH
73455: LD_VAR 0 4
73459: PPUSH
73460: LD_VAR 0 5
73464: PPUSH
73465: CALL_OW 111
// wait ( 0 0$3 ) ;
73469: LD_INT 105
73471: PPUSH
73472: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73476: LD_VAR 0 7
73480: PPUSH
73481: LD_VAR 0 4
73485: PPUSH
73486: LD_VAR 0 5
73490: PPUSH
73491: CALL_OW 307
73495: IFFALSE 73337
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73497: LD_VAR 0 7
73501: PPUSH
73502: LD_VAR 0 4
73506: PPUSH
73507: LD_VAR 0 5
73511: PPUSH
73512: LD_VAR 0 8
73516: PUSH
73517: LD_VAR 0 3
73521: ARRAY
73522: PPUSH
73523: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73527: LD_INT 35
73529: PPUSH
73530: CALL_OW 67
// until not HasTask ( tmp ) ;
73534: LD_VAR 0 7
73538: PPUSH
73539: CALL_OW 314
73543: NOT
73544: IFFALSE 73527
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73546: LD_ADDR_EXP 59
73550: PUSH
73551: LD_EXP 59
73555: PPUSH
73556: LD_VAR 0 2
73560: PUSH
73561: LD_EXP 59
73565: PUSH
73566: LD_VAR 0 2
73570: ARRAY
73571: PUSH
73572: LD_INT 1
73574: PLUS
73575: PUSH
73576: EMPTY
73577: LIST
73578: LIST
73579: PPUSH
73580: LD_VAR 0 8
73584: PUSH
73585: LD_VAR 0 3
73589: ARRAY
73590: PPUSH
73591: CALL 16252 0 3
73595: ST_TO_ADDR
// end ;
73596: GO 73254
73598: POP
73599: POP
// MC_Reset ( i , 124 ) ;
73600: LD_VAR 0 2
73604: PPUSH
73605: LD_INT 124
73607: PPUSH
73608: CALL 56705 0 2
// end ; end ;
73612: GO 73009
73614: POP
73615: POP
// end ;
73616: LD_VAR 0 1
73620: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73621: LD_INT 0
73623: PPUSH
73624: PPUSH
73625: PPUSH
// if not mc_bases then
73626: LD_EXP 23
73630: NOT
73631: IFFALSE 73635
// exit ;
73633: GO 74241
// for i = 1 to mc_bases do
73635: LD_ADDR_VAR 0 2
73639: PUSH
73640: DOUBLE
73641: LD_INT 1
73643: DEC
73644: ST_TO_ADDR
73645: LD_EXP 23
73649: PUSH
73650: FOR_TO
73651: IFFALSE 74239
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73653: LD_ADDR_VAR 0 3
73657: PUSH
73658: LD_EXP 23
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PPUSH
73669: LD_INT 25
73671: PUSH
73672: LD_INT 4
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PPUSH
73679: CALL_OW 72
73683: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73684: LD_VAR 0 3
73688: NOT
73689: PUSH
73690: LD_EXP 60
73694: PUSH
73695: LD_VAR 0 2
73699: ARRAY
73700: NOT
73701: OR
73702: PUSH
73703: LD_EXP 23
73707: PUSH
73708: LD_VAR 0 2
73712: ARRAY
73713: PPUSH
73714: LD_INT 2
73716: PUSH
73717: LD_INT 30
73719: PUSH
73720: LD_INT 0
73722: PUSH
73723: EMPTY
73724: LIST
73725: LIST
73726: PUSH
73727: LD_INT 30
73729: PUSH
73730: LD_INT 1
73732: PUSH
73733: EMPTY
73734: LIST
73735: LIST
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: LIST
73741: PPUSH
73742: CALL_OW 72
73746: NOT
73747: OR
73748: IFFALSE 73798
// begin if mc_deposits_finder [ i ] then
73750: LD_EXP 61
73754: PUSH
73755: LD_VAR 0 2
73759: ARRAY
73760: IFFALSE 73796
// begin MC_Reset ( i , 125 ) ;
73762: LD_VAR 0 2
73766: PPUSH
73767: LD_INT 125
73769: PPUSH
73770: CALL 56705 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73774: LD_ADDR_EXP 61
73778: PUSH
73779: LD_EXP 61
73783: PPUSH
73784: LD_VAR 0 2
73788: PPUSH
73789: EMPTY
73790: PPUSH
73791: CALL_OW 1
73795: ST_TO_ADDR
// end ; continue ;
73796: GO 73650
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73798: LD_EXP 60
73802: PUSH
73803: LD_VAR 0 2
73807: ARRAY
73808: PUSH
73809: LD_INT 1
73811: ARRAY
73812: PUSH
73813: LD_INT 3
73815: ARRAY
73816: PUSH
73817: LD_INT 1
73819: EQUAL
73820: PUSH
73821: LD_INT 20
73823: PPUSH
73824: LD_EXP 49
73828: PUSH
73829: LD_VAR 0 2
73833: ARRAY
73834: PPUSH
73835: CALL_OW 321
73839: PUSH
73840: LD_INT 2
73842: NONEQUAL
73843: AND
73844: IFFALSE 73894
// begin if mc_deposits_finder [ i ] then
73846: LD_EXP 61
73850: PUSH
73851: LD_VAR 0 2
73855: ARRAY
73856: IFFALSE 73892
// begin MC_Reset ( i , 125 ) ;
73858: LD_VAR 0 2
73862: PPUSH
73863: LD_INT 125
73865: PPUSH
73866: CALL 56705 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73870: LD_ADDR_EXP 61
73874: PUSH
73875: LD_EXP 61
73879: PPUSH
73880: LD_VAR 0 2
73884: PPUSH
73885: EMPTY
73886: PPUSH
73887: CALL_OW 1
73891: ST_TO_ADDR
// end ; continue ;
73892: GO 73650
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73894: LD_EXP 60
73898: PUSH
73899: LD_VAR 0 2
73903: ARRAY
73904: PUSH
73905: LD_INT 1
73907: ARRAY
73908: PUSH
73909: LD_INT 1
73911: ARRAY
73912: PPUSH
73913: LD_EXP 60
73917: PUSH
73918: LD_VAR 0 2
73922: ARRAY
73923: PUSH
73924: LD_INT 1
73926: ARRAY
73927: PUSH
73928: LD_INT 2
73930: ARRAY
73931: PPUSH
73932: LD_EXP 49
73936: PUSH
73937: LD_VAR 0 2
73941: ARRAY
73942: PPUSH
73943: CALL_OW 440
73947: IFFALSE 73990
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73949: LD_ADDR_EXP 60
73953: PUSH
73954: LD_EXP 60
73958: PPUSH
73959: LD_VAR 0 2
73963: PPUSH
73964: LD_EXP 60
73968: PUSH
73969: LD_VAR 0 2
73973: ARRAY
73974: PPUSH
73975: LD_INT 1
73977: PPUSH
73978: CALL_OW 3
73982: PPUSH
73983: CALL_OW 1
73987: ST_TO_ADDR
73988: GO 74237
// begin if not mc_deposits_finder [ i ] then
73990: LD_EXP 61
73994: PUSH
73995: LD_VAR 0 2
73999: ARRAY
74000: NOT
74001: IFFALSE 74053
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74003: LD_ADDR_EXP 61
74007: PUSH
74008: LD_EXP 61
74012: PPUSH
74013: LD_VAR 0 2
74017: PPUSH
74018: LD_VAR 0 3
74022: PUSH
74023: LD_INT 1
74025: ARRAY
74026: PUSH
74027: EMPTY
74028: LIST
74029: PPUSH
74030: CALL_OW 1
74034: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74035: LD_VAR 0 3
74039: PUSH
74040: LD_INT 1
74042: ARRAY
74043: PPUSH
74044: LD_INT 125
74046: PPUSH
74047: CALL_OW 109
// end else
74051: GO 74237
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74053: LD_EXP 61
74057: PUSH
74058: LD_VAR 0 2
74062: ARRAY
74063: PUSH
74064: LD_INT 1
74066: ARRAY
74067: PPUSH
74068: CALL_OW 310
74072: IFFALSE 74095
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74074: LD_EXP 61
74078: PUSH
74079: LD_VAR 0 2
74083: ARRAY
74084: PUSH
74085: LD_INT 1
74087: ARRAY
74088: PPUSH
74089: CALL_OW 122
74093: GO 74237
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74095: LD_EXP 61
74099: PUSH
74100: LD_VAR 0 2
74104: ARRAY
74105: PUSH
74106: LD_INT 1
74108: ARRAY
74109: PPUSH
74110: CALL_OW 314
74114: NOT
74115: PUSH
74116: LD_EXP 61
74120: PUSH
74121: LD_VAR 0 2
74125: ARRAY
74126: PUSH
74127: LD_INT 1
74129: ARRAY
74130: PPUSH
74131: LD_EXP 60
74135: PUSH
74136: LD_VAR 0 2
74140: ARRAY
74141: PUSH
74142: LD_INT 1
74144: ARRAY
74145: PUSH
74146: LD_INT 1
74148: ARRAY
74149: PPUSH
74150: LD_EXP 60
74154: PUSH
74155: LD_VAR 0 2
74159: ARRAY
74160: PUSH
74161: LD_INT 1
74163: ARRAY
74164: PUSH
74165: LD_INT 2
74167: ARRAY
74168: PPUSH
74169: CALL_OW 297
74173: PUSH
74174: LD_INT 6
74176: GREATER
74177: AND
74178: IFFALSE 74237
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74180: LD_EXP 61
74184: PUSH
74185: LD_VAR 0 2
74189: ARRAY
74190: PUSH
74191: LD_INT 1
74193: ARRAY
74194: PPUSH
74195: LD_EXP 60
74199: PUSH
74200: LD_VAR 0 2
74204: ARRAY
74205: PUSH
74206: LD_INT 1
74208: ARRAY
74209: PUSH
74210: LD_INT 1
74212: ARRAY
74213: PPUSH
74214: LD_EXP 60
74218: PUSH
74219: LD_VAR 0 2
74223: ARRAY
74224: PUSH
74225: LD_INT 1
74227: ARRAY
74228: PUSH
74229: LD_INT 2
74231: ARRAY
74232: PPUSH
74233: CALL_OW 111
// end ; end ; end ;
74237: GO 73650
74239: POP
74240: POP
// end ;
74241: LD_VAR 0 1
74245: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74246: LD_INT 0
74248: PPUSH
74249: PPUSH
74250: PPUSH
74251: PPUSH
74252: PPUSH
74253: PPUSH
74254: PPUSH
74255: PPUSH
74256: PPUSH
74257: PPUSH
74258: PPUSH
// if not mc_bases then
74259: LD_EXP 23
74263: NOT
74264: IFFALSE 74268
// exit ;
74266: GO 75208
// for i = 1 to mc_bases do
74268: LD_ADDR_VAR 0 2
74272: PUSH
74273: DOUBLE
74274: LD_INT 1
74276: DEC
74277: ST_TO_ADDR
74278: LD_EXP 23
74282: PUSH
74283: FOR_TO
74284: IFFALSE 75206
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74286: LD_EXP 23
74290: PUSH
74291: LD_VAR 0 2
74295: ARRAY
74296: NOT
74297: PUSH
74298: LD_EXP 46
74302: PUSH
74303: LD_VAR 0 2
74307: ARRAY
74308: OR
74309: IFFALSE 74313
// continue ;
74311: GO 74283
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74313: LD_ADDR_VAR 0 7
74317: PUSH
74318: LD_EXP 23
74322: PUSH
74323: LD_VAR 0 2
74327: ARRAY
74328: PUSH
74329: LD_INT 1
74331: ARRAY
74332: PPUSH
74333: CALL_OW 248
74337: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74338: LD_VAR 0 7
74342: PUSH
74343: LD_INT 3
74345: EQUAL
74346: PUSH
74347: LD_EXP 42
74351: PUSH
74352: LD_VAR 0 2
74356: ARRAY
74357: PUSH
74358: LD_EXP 45
74362: PUSH
74363: LD_VAR 0 2
74367: ARRAY
74368: UNION
74369: PPUSH
74370: LD_INT 33
74372: PUSH
74373: LD_INT 2
74375: PUSH
74376: EMPTY
74377: LIST
74378: LIST
74379: PPUSH
74380: CALL_OW 72
74384: NOT
74385: OR
74386: IFFALSE 74390
// continue ;
74388: GO 74283
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74390: LD_ADDR_VAR 0 9
74394: PUSH
74395: LD_EXP 23
74399: PUSH
74400: LD_VAR 0 2
74404: ARRAY
74405: PPUSH
74406: LD_INT 30
74408: PUSH
74409: LD_INT 36
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PPUSH
74416: CALL_OW 72
74420: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74421: LD_ADDR_VAR 0 10
74425: PUSH
74426: LD_EXP 42
74430: PUSH
74431: LD_VAR 0 2
74435: ARRAY
74436: PPUSH
74437: LD_INT 34
74439: PUSH
74440: LD_INT 31
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PPUSH
74447: CALL_OW 72
74451: ST_TO_ADDR
// if not cts and not mcts then
74452: LD_VAR 0 9
74456: NOT
74457: PUSH
74458: LD_VAR 0 10
74462: NOT
74463: AND
74464: IFFALSE 74468
// continue ;
74466: GO 74283
// x := cts ;
74468: LD_ADDR_VAR 0 11
74472: PUSH
74473: LD_VAR 0 9
74477: ST_TO_ADDR
// if not x then
74478: LD_VAR 0 11
74482: NOT
74483: IFFALSE 74495
// x := mcts ;
74485: LD_ADDR_VAR 0 11
74489: PUSH
74490: LD_VAR 0 10
74494: ST_TO_ADDR
// if not x then
74495: LD_VAR 0 11
74499: NOT
74500: IFFALSE 74504
// continue ;
74502: GO 74283
// if mc_remote_driver [ i ] then
74504: LD_EXP 63
74508: PUSH
74509: LD_VAR 0 2
74513: ARRAY
74514: IFFALSE 74901
// for j in mc_remote_driver [ i ] do
74516: LD_ADDR_VAR 0 3
74520: PUSH
74521: LD_EXP 63
74525: PUSH
74526: LD_VAR 0 2
74530: ARRAY
74531: PUSH
74532: FOR_IN
74533: IFFALSE 74899
// begin if GetClass ( j ) <> 3 then
74535: LD_VAR 0 3
74539: PPUSH
74540: CALL_OW 257
74544: PUSH
74545: LD_INT 3
74547: NONEQUAL
74548: IFFALSE 74601
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74550: LD_ADDR_EXP 63
74554: PUSH
74555: LD_EXP 63
74559: PPUSH
74560: LD_VAR 0 2
74564: PPUSH
74565: LD_EXP 63
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: PUSH
74576: LD_VAR 0 3
74580: DIFF
74581: PPUSH
74582: CALL_OW 1
74586: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74587: LD_VAR 0 3
74591: PPUSH
74592: LD_INT 0
74594: PPUSH
74595: CALL_OW 109
// continue ;
74599: GO 74532
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74601: LD_EXP 42
74605: PUSH
74606: LD_VAR 0 2
74610: ARRAY
74611: PPUSH
74612: LD_INT 34
74614: PUSH
74615: LD_INT 31
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: PUSH
74622: LD_INT 58
74624: PUSH
74625: EMPTY
74626: LIST
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: PPUSH
74632: CALL_OW 72
74636: PUSH
74637: LD_VAR 0 3
74641: PPUSH
74642: CALL 46199 0 1
74646: NOT
74647: AND
74648: IFFALSE 74719
// begin if IsInUnit ( j ) then
74650: LD_VAR 0 3
74654: PPUSH
74655: CALL_OW 310
74659: IFFALSE 74670
// ComExitBuilding ( j ) ;
74661: LD_VAR 0 3
74665: PPUSH
74666: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74670: LD_VAR 0 3
74674: PPUSH
74675: LD_EXP 42
74679: PUSH
74680: LD_VAR 0 2
74684: ARRAY
74685: PPUSH
74686: LD_INT 34
74688: PUSH
74689: LD_INT 31
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: PUSH
74696: LD_INT 58
74698: PUSH
74699: EMPTY
74700: LIST
74701: PUSH
74702: EMPTY
74703: LIST
74704: LIST
74705: PPUSH
74706: CALL_OW 72
74710: PUSH
74711: LD_INT 1
74713: ARRAY
74714: PPUSH
74715: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74719: LD_VAR 0 3
74723: PPUSH
74724: CALL_OW 310
74728: NOT
74729: PUSH
74730: LD_VAR 0 3
74734: PPUSH
74735: CALL_OW 310
74739: PPUSH
74740: CALL_OW 266
74744: PUSH
74745: LD_INT 36
74747: NONEQUAL
74748: PUSH
74749: LD_VAR 0 3
74753: PPUSH
74754: CALL 46199 0 1
74758: NOT
74759: AND
74760: OR
74761: IFFALSE 74897
// begin if IsInUnit ( j ) then
74763: LD_VAR 0 3
74767: PPUSH
74768: CALL_OW 310
74772: IFFALSE 74783
// ComExitBuilding ( j ) ;
74774: LD_VAR 0 3
74778: PPUSH
74779: CALL_OW 122
// ct := 0 ;
74783: LD_ADDR_VAR 0 8
74787: PUSH
74788: LD_INT 0
74790: ST_TO_ADDR
// for k in x do
74791: LD_ADDR_VAR 0 4
74795: PUSH
74796: LD_VAR 0 11
74800: PUSH
74801: FOR_IN
74802: IFFALSE 74875
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74804: LD_VAR 0 4
74808: PPUSH
74809: CALL_OW 264
74813: PUSH
74814: LD_INT 31
74816: EQUAL
74817: PUSH
74818: LD_VAR 0 4
74822: PPUSH
74823: CALL_OW 311
74827: NOT
74828: AND
74829: PUSH
74830: LD_VAR 0 4
74834: PPUSH
74835: CALL_OW 266
74839: PUSH
74840: LD_INT 36
74842: EQUAL
74843: PUSH
74844: LD_VAR 0 4
74848: PPUSH
74849: CALL_OW 313
74853: PUSH
74854: LD_INT 3
74856: LESS
74857: AND
74858: OR
74859: IFFALSE 74873
// begin ct := k ;
74861: LD_ADDR_VAR 0 8
74865: PUSH
74866: LD_VAR 0 4
74870: ST_TO_ADDR
// break ;
74871: GO 74875
// end ;
74873: GO 74801
74875: POP
74876: POP
// if ct then
74877: LD_VAR 0 8
74881: IFFALSE 74897
// ComEnterUnit ( j , ct ) ;
74883: LD_VAR 0 3
74887: PPUSH
74888: LD_VAR 0 8
74892: PPUSH
74893: CALL_OW 120
// end ; end ;
74897: GO 74532
74899: POP
74900: POP
// places := 0 ;
74901: LD_ADDR_VAR 0 5
74905: PUSH
74906: LD_INT 0
74908: ST_TO_ADDR
// for j = 1 to x do
74909: LD_ADDR_VAR 0 3
74913: PUSH
74914: DOUBLE
74915: LD_INT 1
74917: DEC
74918: ST_TO_ADDR
74919: LD_VAR 0 11
74923: PUSH
74924: FOR_TO
74925: IFFALSE 75001
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74927: LD_VAR 0 11
74931: PUSH
74932: LD_VAR 0 3
74936: ARRAY
74937: PPUSH
74938: CALL_OW 264
74942: PUSH
74943: LD_INT 31
74945: EQUAL
74946: IFFALSE 74964
// places := places + 1 else
74948: LD_ADDR_VAR 0 5
74952: PUSH
74953: LD_VAR 0 5
74957: PUSH
74958: LD_INT 1
74960: PLUS
74961: ST_TO_ADDR
74962: GO 74999
// if GetBType ( x [ j ] ) = b_control_tower then
74964: LD_VAR 0 11
74968: PUSH
74969: LD_VAR 0 3
74973: ARRAY
74974: PPUSH
74975: CALL_OW 266
74979: PUSH
74980: LD_INT 36
74982: EQUAL
74983: IFFALSE 74999
// places := places + 3 ;
74985: LD_ADDR_VAR 0 5
74989: PUSH
74990: LD_VAR 0 5
74994: PUSH
74995: LD_INT 3
74997: PLUS
74998: ST_TO_ADDR
74999: GO 74924
75001: POP
75002: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
75003: LD_VAR 0 5
75007: PUSH
75008: LD_INT 0
75010: EQUAL
75011: PUSH
75012: LD_VAR 0 5
75016: PUSH
75017: LD_EXP 63
75021: PUSH
75022: LD_VAR 0 2
75026: ARRAY
75027: LESSEQUAL
75028: OR
75029: IFFALSE 75033
// continue ;
75031: GO 74283
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75033: LD_ADDR_VAR 0 6
75037: PUSH
75038: LD_EXP 23
75042: PUSH
75043: LD_VAR 0 2
75047: ARRAY
75048: PPUSH
75049: LD_INT 25
75051: PUSH
75052: LD_INT 3
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PPUSH
75059: CALL_OW 72
75063: PUSH
75064: LD_EXP 63
75068: PUSH
75069: LD_VAR 0 2
75073: ARRAY
75074: DIFF
75075: PPUSH
75076: LD_INT 3
75078: PPUSH
75079: CALL 47099 0 2
75083: ST_TO_ADDR
// for j in tmp do
75084: LD_ADDR_VAR 0 3
75088: PUSH
75089: LD_VAR 0 6
75093: PUSH
75094: FOR_IN
75095: IFFALSE 75130
// if GetTag ( j ) > 0 then
75097: LD_VAR 0 3
75101: PPUSH
75102: CALL_OW 110
75106: PUSH
75107: LD_INT 0
75109: GREATER
75110: IFFALSE 75128
// tmp := tmp diff j ;
75112: LD_ADDR_VAR 0 6
75116: PUSH
75117: LD_VAR 0 6
75121: PUSH
75122: LD_VAR 0 3
75126: DIFF
75127: ST_TO_ADDR
75128: GO 75094
75130: POP
75131: POP
// if not tmp then
75132: LD_VAR 0 6
75136: NOT
75137: IFFALSE 75141
// continue ;
75139: GO 74283
// if places then
75141: LD_VAR 0 5
75145: IFFALSE 75204
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75147: LD_ADDR_EXP 63
75151: PUSH
75152: LD_EXP 63
75156: PPUSH
75157: LD_VAR 0 2
75161: PPUSH
75162: LD_EXP 63
75166: PUSH
75167: LD_VAR 0 2
75171: ARRAY
75172: PUSH
75173: LD_VAR 0 6
75177: PUSH
75178: LD_INT 1
75180: ARRAY
75181: UNION
75182: PPUSH
75183: CALL_OW 1
75187: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75188: LD_VAR 0 6
75192: PUSH
75193: LD_INT 1
75195: ARRAY
75196: PPUSH
75197: LD_INT 126
75199: PPUSH
75200: CALL_OW 109
// end ; end ;
75204: GO 74283
75206: POP
75207: POP
// end ;
75208: LD_VAR 0 1
75212: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75213: LD_INT 0
75215: PPUSH
75216: PPUSH
75217: PPUSH
75218: PPUSH
75219: PPUSH
75220: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75221: LD_VAR 0 1
75225: NOT
75226: PUSH
75227: LD_VAR 0 2
75231: NOT
75232: OR
75233: PUSH
75234: LD_VAR 0 3
75238: NOT
75239: OR
75240: PUSH
75241: LD_VAR 0 4
75245: PUSH
75246: LD_INT 1
75248: PUSH
75249: LD_INT 2
75251: PUSH
75252: LD_INT 3
75254: PUSH
75255: LD_INT 4
75257: PUSH
75258: LD_INT 5
75260: PUSH
75261: LD_INT 8
75263: PUSH
75264: LD_INT 9
75266: PUSH
75267: LD_INT 15
75269: PUSH
75270: LD_INT 16
75272: PUSH
75273: EMPTY
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: LIST
75281: LIST
75282: LIST
75283: IN
75284: NOT
75285: OR
75286: IFFALSE 75290
// exit ;
75288: GO 76190
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75290: LD_ADDR_VAR 0 2
75294: PUSH
75295: LD_VAR 0 2
75299: PPUSH
75300: LD_INT 21
75302: PUSH
75303: LD_INT 3
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: PUSH
75310: LD_INT 24
75312: PUSH
75313: LD_INT 250
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PPUSH
75324: CALL_OW 72
75328: ST_TO_ADDR
// case class of 1 , 15 :
75329: LD_VAR 0 4
75333: PUSH
75334: LD_INT 1
75336: DOUBLE
75337: EQUAL
75338: IFTRUE 75348
75340: LD_INT 15
75342: DOUBLE
75343: EQUAL
75344: IFTRUE 75348
75346: GO 75433
75348: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75349: LD_ADDR_VAR 0 8
75353: PUSH
75354: LD_VAR 0 2
75358: PPUSH
75359: LD_INT 2
75361: PUSH
75362: LD_INT 30
75364: PUSH
75365: LD_INT 32
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 30
75374: PUSH
75375: LD_INT 31
75377: PUSH
75378: EMPTY
75379: LIST
75380: LIST
75381: PUSH
75382: EMPTY
75383: LIST
75384: LIST
75385: LIST
75386: PPUSH
75387: CALL_OW 72
75391: PUSH
75392: LD_VAR 0 2
75396: PPUSH
75397: LD_INT 2
75399: PUSH
75400: LD_INT 30
75402: PUSH
75403: LD_INT 4
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: PUSH
75410: LD_INT 30
75412: PUSH
75413: LD_INT 5
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: LIST
75424: PPUSH
75425: CALL_OW 72
75429: ADD
75430: ST_TO_ADDR
75431: GO 75679
75433: LD_INT 2
75435: DOUBLE
75436: EQUAL
75437: IFTRUE 75447
75439: LD_INT 16
75441: DOUBLE
75442: EQUAL
75443: IFTRUE 75447
75445: GO 75493
75447: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75448: LD_ADDR_VAR 0 8
75452: PUSH
75453: LD_VAR 0 2
75457: PPUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 30
75463: PUSH
75464: LD_INT 0
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 30
75473: PUSH
75474: LD_INT 1
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: LIST
75485: PPUSH
75486: CALL_OW 72
75490: ST_TO_ADDR
75491: GO 75679
75493: LD_INT 3
75495: DOUBLE
75496: EQUAL
75497: IFTRUE 75501
75499: GO 75547
75501: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75502: LD_ADDR_VAR 0 8
75506: PUSH
75507: LD_VAR 0 2
75511: PPUSH
75512: LD_INT 2
75514: PUSH
75515: LD_INT 30
75517: PUSH
75518: LD_INT 2
75520: PUSH
75521: EMPTY
75522: LIST
75523: LIST
75524: PUSH
75525: LD_INT 30
75527: PUSH
75528: LD_INT 3
75530: PUSH
75531: EMPTY
75532: LIST
75533: LIST
75534: PUSH
75535: EMPTY
75536: LIST
75537: LIST
75538: LIST
75539: PPUSH
75540: CALL_OW 72
75544: ST_TO_ADDR
75545: GO 75679
75547: LD_INT 4
75549: DOUBLE
75550: EQUAL
75551: IFTRUE 75555
75553: GO 75612
75555: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75556: LD_ADDR_VAR 0 8
75560: PUSH
75561: LD_VAR 0 2
75565: PPUSH
75566: LD_INT 2
75568: PUSH
75569: LD_INT 30
75571: PUSH
75572: LD_INT 6
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 30
75581: PUSH
75582: LD_INT 7
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: LD_INT 30
75591: PUSH
75592: LD_INT 8
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: PUSH
75599: EMPTY
75600: LIST
75601: LIST
75602: LIST
75603: LIST
75604: PPUSH
75605: CALL_OW 72
75609: ST_TO_ADDR
75610: GO 75679
75612: LD_INT 5
75614: DOUBLE
75615: EQUAL
75616: IFTRUE 75632
75618: LD_INT 8
75620: DOUBLE
75621: EQUAL
75622: IFTRUE 75632
75624: LD_INT 9
75626: DOUBLE
75627: EQUAL
75628: IFTRUE 75632
75630: GO 75678
75632: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75633: LD_ADDR_VAR 0 8
75637: PUSH
75638: LD_VAR 0 2
75642: PPUSH
75643: LD_INT 2
75645: PUSH
75646: LD_INT 30
75648: PUSH
75649: LD_INT 4
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: PUSH
75656: LD_INT 30
75658: PUSH
75659: LD_INT 5
75661: PUSH
75662: EMPTY
75663: LIST
75664: LIST
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: LIST
75670: PPUSH
75671: CALL_OW 72
75675: ST_TO_ADDR
75676: GO 75679
75678: POP
// if not tmp then
75679: LD_VAR 0 8
75683: NOT
75684: IFFALSE 75688
// exit ;
75686: GO 76190
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75688: LD_VAR 0 4
75692: PUSH
75693: LD_INT 1
75695: PUSH
75696: LD_INT 15
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: IN
75703: PUSH
75704: LD_EXP 32
75708: PUSH
75709: LD_VAR 0 1
75713: ARRAY
75714: AND
75715: IFFALSE 75871
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75717: LD_ADDR_VAR 0 9
75721: PUSH
75722: LD_EXP 32
75726: PUSH
75727: LD_VAR 0 1
75731: ARRAY
75732: PUSH
75733: LD_INT 1
75735: ARRAY
75736: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75737: LD_VAR 0 9
75741: PUSH
75742: LD_EXP 33
75746: PUSH
75747: LD_VAR 0 1
75751: ARRAY
75752: IN
75753: NOT
75754: IFFALSE 75869
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75756: LD_ADDR_EXP 33
75760: PUSH
75761: LD_EXP 33
75765: PPUSH
75766: LD_VAR 0 1
75770: PUSH
75771: LD_EXP 33
75775: PUSH
75776: LD_VAR 0 1
75780: ARRAY
75781: PUSH
75782: LD_INT 1
75784: PLUS
75785: PUSH
75786: EMPTY
75787: LIST
75788: LIST
75789: PPUSH
75790: LD_VAR 0 9
75794: PPUSH
75795: CALL 16252 0 3
75799: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75800: LD_ADDR_EXP 32
75804: PUSH
75805: LD_EXP 32
75809: PPUSH
75810: LD_VAR 0 1
75814: PPUSH
75815: LD_EXP 32
75819: PUSH
75820: LD_VAR 0 1
75824: ARRAY
75825: PUSH
75826: LD_VAR 0 9
75830: DIFF
75831: PPUSH
75832: CALL_OW 1
75836: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75837: LD_VAR 0 3
75841: PPUSH
75842: LD_EXP 33
75846: PUSH
75847: LD_VAR 0 1
75851: ARRAY
75852: PUSH
75853: LD_EXP 33
75857: PUSH
75858: LD_VAR 0 1
75862: ARRAY
75863: ARRAY
75864: PPUSH
75865: CALL_OW 120
// end ; exit ;
75869: GO 76190
// end ; if tmp > 1 then
75871: LD_VAR 0 8
75875: PUSH
75876: LD_INT 1
75878: GREATER
75879: IFFALSE 75983
// for i = 2 to tmp do
75881: LD_ADDR_VAR 0 6
75885: PUSH
75886: DOUBLE
75887: LD_INT 2
75889: DEC
75890: ST_TO_ADDR
75891: LD_VAR 0 8
75895: PUSH
75896: FOR_TO
75897: IFFALSE 75981
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75899: LD_VAR 0 8
75903: PUSH
75904: LD_VAR 0 6
75908: ARRAY
75909: PPUSH
75910: CALL_OW 461
75914: PUSH
75915: LD_INT 6
75917: EQUAL
75918: IFFALSE 75979
// begin x := tmp [ i ] ;
75920: LD_ADDR_VAR 0 9
75924: PUSH
75925: LD_VAR 0 8
75929: PUSH
75930: LD_VAR 0 6
75934: ARRAY
75935: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75936: LD_ADDR_VAR 0 8
75940: PUSH
75941: LD_VAR 0 8
75945: PPUSH
75946: LD_VAR 0 6
75950: PPUSH
75951: CALL_OW 3
75955: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75956: LD_ADDR_VAR 0 8
75960: PUSH
75961: LD_VAR 0 8
75965: PPUSH
75966: LD_INT 1
75968: PPUSH
75969: LD_VAR 0 9
75973: PPUSH
75974: CALL_OW 2
75978: ST_TO_ADDR
// end ;
75979: GO 75896
75981: POP
75982: POP
// for i in tmp do
75983: LD_ADDR_VAR 0 6
75987: PUSH
75988: LD_VAR 0 8
75992: PUSH
75993: FOR_IN
75994: IFFALSE 76063
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75996: LD_VAR 0 6
76000: PPUSH
76001: CALL_OW 313
76005: PUSH
76006: LD_INT 6
76008: LESS
76009: PUSH
76010: LD_VAR 0 6
76014: PPUSH
76015: CALL_OW 266
76019: PUSH
76020: LD_INT 31
76022: PUSH
76023: LD_INT 32
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: IN
76030: NOT
76031: AND
76032: PUSH
76033: LD_VAR 0 6
76037: PPUSH
76038: CALL_OW 313
76042: PUSH
76043: LD_INT 0
76045: EQUAL
76046: OR
76047: IFFALSE 76061
// begin j := i ;
76049: LD_ADDR_VAR 0 7
76053: PUSH
76054: LD_VAR 0 6
76058: ST_TO_ADDR
// break ;
76059: GO 76063
// end ; end ;
76061: GO 75993
76063: POP
76064: POP
// if j then
76065: LD_VAR 0 7
76069: IFFALSE 76087
// ComEnterUnit ( unit , j ) else
76071: LD_VAR 0 3
76075: PPUSH
76076: LD_VAR 0 7
76080: PPUSH
76081: CALL_OW 120
76085: GO 76190
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76087: LD_ADDR_VAR 0 10
76091: PUSH
76092: LD_VAR 0 2
76096: PPUSH
76097: LD_INT 2
76099: PUSH
76100: LD_INT 30
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 30
76112: PUSH
76113: LD_INT 1
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: LIST
76124: PPUSH
76125: CALL_OW 72
76129: ST_TO_ADDR
// if depot then
76130: LD_VAR 0 10
76134: IFFALSE 76190
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76136: LD_ADDR_VAR 0 10
76140: PUSH
76141: LD_VAR 0 10
76145: PPUSH
76146: LD_VAR 0 3
76150: PPUSH
76151: CALL_OW 74
76155: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76156: LD_VAR 0 3
76160: PPUSH
76161: LD_VAR 0 10
76165: PPUSH
76166: CALL_OW 296
76170: PUSH
76171: LD_INT 10
76173: GREATER
76174: IFFALSE 76190
// ComStandNearbyBuilding ( unit , depot ) ;
76176: LD_VAR 0 3
76180: PPUSH
76181: LD_VAR 0 10
76185: PPUSH
76186: CALL 12679 0 2
// end ; end ; end ;
76190: LD_VAR 0 5
76194: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76195: LD_INT 0
76197: PPUSH
76198: PPUSH
76199: PPUSH
76200: PPUSH
// if not mc_bases then
76201: LD_EXP 23
76205: NOT
76206: IFFALSE 76210
// exit ;
76208: GO 76449
// for i = 1 to mc_bases do
76210: LD_ADDR_VAR 0 2
76214: PUSH
76215: DOUBLE
76216: LD_INT 1
76218: DEC
76219: ST_TO_ADDR
76220: LD_EXP 23
76224: PUSH
76225: FOR_TO
76226: IFFALSE 76447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76228: LD_ADDR_VAR 0 4
76232: PUSH
76233: LD_EXP 23
76237: PUSH
76238: LD_VAR 0 2
76242: ARRAY
76243: PPUSH
76244: LD_INT 21
76246: PUSH
76247: LD_INT 1
76249: PUSH
76250: EMPTY
76251: LIST
76252: LIST
76253: PPUSH
76254: CALL_OW 72
76258: PUSH
76259: LD_EXP 52
76263: PUSH
76264: LD_VAR 0 2
76268: ARRAY
76269: UNION
76270: ST_TO_ADDR
// if not tmp then
76271: LD_VAR 0 4
76275: NOT
76276: IFFALSE 76280
// continue ;
76278: GO 76225
// for j in tmp do
76280: LD_ADDR_VAR 0 3
76284: PUSH
76285: LD_VAR 0 4
76289: PUSH
76290: FOR_IN
76291: IFFALSE 76443
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76293: LD_VAR 0 3
76297: PPUSH
76298: CALL_OW 110
76302: NOT
76303: PUSH
76304: LD_VAR 0 3
76308: PPUSH
76309: CALL_OW 314
76313: NOT
76314: AND
76315: PUSH
76316: LD_VAR 0 3
76320: PPUSH
76321: CALL_OW 311
76325: NOT
76326: AND
76327: PUSH
76328: LD_VAR 0 3
76332: PPUSH
76333: CALL_OW 310
76337: NOT
76338: AND
76339: PUSH
76340: LD_VAR 0 3
76344: PUSH
76345: LD_EXP 26
76349: PUSH
76350: LD_VAR 0 2
76354: ARRAY
76355: PUSH
76356: LD_INT 1
76358: ARRAY
76359: IN
76360: NOT
76361: AND
76362: PUSH
76363: LD_VAR 0 3
76367: PUSH
76368: LD_EXP 26
76372: PUSH
76373: LD_VAR 0 2
76377: ARRAY
76378: PUSH
76379: LD_INT 2
76381: ARRAY
76382: IN
76383: NOT
76384: AND
76385: PUSH
76386: LD_VAR 0 3
76390: PUSH
76391: LD_EXP 35
76395: PUSH
76396: LD_VAR 0 2
76400: ARRAY
76401: IN
76402: NOT
76403: AND
76404: IFFALSE 76441
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76406: LD_VAR 0 2
76410: PPUSH
76411: LD_EXP 23
76415: PUSH
76416: LD_VAR 0 2
76420: ARRAY
76421: PPUSH
76422: LD_VAR 0 3
76426: PPUSH
76427: LD_VAR 0 3
76431: PPUSH
76432: CALL_OW 257
76436: PPUSH
76437: CALL 75213 0 4
// end ;
76441: GO 76290
76443: POP
76444: POP
// end ;
76445: GO 76225
76447: POP
76448: POP
// end ;
76449: LD_VAR 0 1
76453: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76454: LD_INT 0
76456: PPUSH
76457: PPUSH
76458: PPUSH
76459: PPUSH
76460: PPUSH
76461: PPUSH
// if not mc_bases [ base ] then
76462: LD_EXP 23
76466: PUSH
76467: LD_VAR 0 1
76471: ARRAY
76472: NOT
76473: IFFALSE 76477
// exit ;
76475: GO 76659
// tmp := [ ] ;
76477: LD_ADDR_VAR 0 6
76481: PUSH
76482: EMPTY
76483: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76484: LD_ADDR_VAR 0 7
76488: PUSH
76489: LD_VAR 0 3
76493: PPUSH
76494: LD_INT 0
76496: PPUSH
76497: CALL_OW 517
76501: ST_TO_ADDR
// if not list then
76502: LD_VAR 0 7
76506: NOT
76507: IFFALSE 76511
// exit ;
76509: GO 76659
// for i = 1 to amount do
76511: LD_ADDR_VAR 0 5
76515: PUSH
76516: DOUBLE
76517: LD_INT 1
76519: DEC
76520: ST_TO_ADDR
76521: LD_VAR 0 2
76525: PUSH
76526: FOR_TO
76527: IFFALSE 76607
// begin x := rand ( 1 , list [ 1 ] ) ;
76529: LD_ADDR_VAR 0 8
76533: PUSH
76534: LD_INT 1
76536: PPUSH
76537: LD_VAR 0 7
76541: PUSH
76542: LD_INT 1
76544: ARRAY
76545: PPUSH
76546: CALL_OW 12
76550: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76551: LD_ADDR_VAR 0 6
76555: PUSH
76556: LD_VAR 0 6
76560: PPUSH
76561: LD_VAR 0 5
76565: PPUSH
76566: LD_VAR 0 7
76570: PUSH
76571: LD_INT 1
76573: ARRAY
76574: PUSH
76575: LD_VAR 0 8
76579: ARRAY
76580: PUSH
76581: LD_VAR 0 7
76585: PUSH
76586: LD_INT 2
76588: ARRAY
76589: PUSH
76590: LD_VAR 0 8
76594: ARRAY
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PPUSH
76600: CALL_OW 1
76604: ST_TO_ADDR
// end ;
76605: GO 76526
76607: POP
76608: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76609: LD_ADDR_EXP 36
76613: PUSH
76614: LD_EXP 36
76618: PPUSH
76619: LD_VAR 0 1
76623: PPUSH
76624: LD_VAR 0 6
76628: PPUSH
76629: CALL_OW 1
76633: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76634: LD_ADDR_EXP 38
76638: PUSH
76639: LD_EXP 38
76643: PPUSH
76644: LD_VAR 0 1
76648: PPUSH
76649: LD_VAR 0 3
76653: PPUSH
76654: CALL_OW 1
76658: ST_TO_ADDR
// end ;
76659: LD_VAR 0 4
76663: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76664: LD_INT 0
76666: PPUSH
// if not mc_bases [ base ] then
76667: LD_EXP 23
76671: PUSH
76672: LD_VAR 0 1
76676: ARRAY
76677: NOT
76678: IFFALSE 76682
// exit ;
76680: GO 76707
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76682: LD_ADDR_EXP 28
76686: PUSH
76687: LD_EXP 28
76691: PPUSH
76692: LD_VAR 0 1
76696: PPUSH
76697: LD_VAR 0 2
76701: PPUSH
76702: CALL_OW 1
76706: ST_TO_ADDR
// end ;
76707: LD_VAR 0 3
76711: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76712: LD_INT 0
76714: PPUSH
// if not mc_bases [ base ] then
76715: LD_EXP 23
76719: PUSH
76720: LD_VAR 0 1
76724: ARRAY
76725: NOT
76726: IFFALSE 76730
// exit ;
76728: GO 76767
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76730: LD_ADDR_EXP 28
76734: PUSH
76735: LD_EXP 28
76739: PPUSH
76740: LD_VAR 0 1
76744: PPUSH
76745: LD_EXP 28
76749: PUSH
76750: LD_VAR 0 1
76754: ARRAY
76755: PUSH
76756: LD_VAR 0 2
76760: UNION
76761: PPUSH
76762: CALL_OW 1
76766: ST_TO_ADDR
// end ;
76767: LD_VAR 0 3
76771: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76772: LD_INT 0
76774: PPUSH
// if not mc_bases [ base ] then
76775: LD_EXP 23
76779: PUSH
76780: LD_VAR 0 1
76784: ARRAY
76785: NOT
76786: IFFALSE 76790
// exit ;
76788: GO 76815
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76790: LD_ADDR_EXP 44
76794: PUSH
76795: LD_EXP 44
76799: PPUSH
76800: LD_VAR 0 1
76804: PPUSH
76805: LD_VAR 0 2
76809: PPUSH
76810: CALL_OW 1
76814: ST_TO_ADDR
// end ;
76815: LD_VAR 0 3
76819: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76820: LD_INT 0
76822: PPUSH
// if not mc_bases [ base ] then
76823: LD_EXP 23
76827: PUSH
76828: LD_VAR 0 1
76832: ARRAY
76833: NOT
76834: IFFALSE 76838
// exit ;
76836: GO 76875
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76838: LD_ADDR_EXP 44
76842: PUSH
76843: LD_EXP 44
76847: PPUSH
76848: LD_VAR 0 1
76852: PPUSH
76853: LD_EXP 44
76857: PUSH
76858: LD_VAR 0 1
76862: ARRAY
76863: PUSH
76864: LD_VAR 0 2
76868: ADD
76869: PPUSH
76870: CALL_OW 1
76874: ST_TO_ADDR
// end ;
76875: LD_VAR 0 3
76879: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76880: LD_INT 0
76882: PPUSH
// if not mc_bases [ base ] then
76883: LD_EXP 23
76887: PUSH
76888: LD_VAR 0 1
76892: ARRAY
76893: NOT
76894: IFFALSE 76898
// exit ;
76896: GO 76952
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76898: LD_ADDR_EXP 45
76902: PUSH
76903: LD_EXP 45
76907: PPUSH
76908: LD_VAR 0 1
76912: PPUSH
76913: LD_VAR 0 2
76917: PPUSH
76918: CALL_OW 1
76922: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76923: LD_ADDR_EXP 34
76927: PUSH
76928: LD_EXP 34
76932: PPUSH
76933: LD_VAR 0 1
76937: PPUSH
76938: LD_VAR 0 2
76942: PUSH
76943: LD_INT 0
76945: PLUS
76946: PPUSH
76947: CALL_OW 1
76951: ST_TO_ADDR
// end ;
76952: LD_VAR 0 3
76956: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76957: LD_INT 0
76959: PPUSH
// if not mc_bases [ base ] then
76960: LD_EXP 23
76964: PUSH
76965: LD_VAR 0 1
76969: ARRAY
76970: NOT
76971: IFFALSE 76975
// exit ;
76973: GO 77000
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76975: LD_ADDR_EXP 34
76979: PUSH
76980: LD_EXP 34
76984: PPUSH
76985: LD_VAR 0 1
76989: PPUSH
76990: LD_VAR 0 2
76994: PPUSH
76995: CALL_OW 1
76999: ST_TO_ADDR
// end ;
77000: LD_VAR 0 3
77004: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77005: LD_INT 0
77007: PPUSH
77008: PPUSH
77009: PPUSH
77010: PPUSH
// if not mc_bases [ base ] then
77011: LD_EXP 23
77015: PUSH
77016: LD_VAR 0 1
77020: ARRAY
77021: NOT
77022: IFFALSE 77026
// exit ;
77024: GO 77091
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77026: LD_ADDR_EXP 43
77030: PUSH
77031: LD_EXP 43
77035: PPUSH
77036: LD_VAR 0 1
77040: PUSH
77041: LD_EXP 43
77045: PUSH
77046: LD_VAR 0 1
77050: ARRAY
77051: PUSH
77052: LD_INT 1
77054: PLUS
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PPUSH
77060: LD_VAR 0 1
77064: PUSH
77065: LD_VAR 0 2
77069: PUSH
77070: LD_VAR 0 3
77074: PUSH
77075: LD_VAR 0 4
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: PPUSH
77086: CALL 16252 0 3
77090: ST_TO_ADDR
// end ;
77091: LD_VAR 0 5
77095: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77096: LD_INT 0
77098: PPUSH
// if not mc_bases [ base ] then
77099: LD_EXP 23
77103: PUSH
77104: LD_VAR 0 1
77108: ARRAY
77109: NOT
77110: IFFALSE 77114
// exit ;
77112: GO 77139
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77114: LD_ADDR_EXP 60
77118: PUSH
77119: LD_EXP 60
77123: PPUSH
77124: LD_VAR 0 1
77128: PPUSH
77129: LD_VAR 0 2
77133: PPUSH
77134: CALL_OW 1
77138: ST_TO_ADDR
// end ;
77139: LD_VAR 0 3
77143: RET
// export function MC_GetMinesField ( base ) ; begin
77144: LD_INT 0
77146: PPUSH
// result := mc_mines [ base ] ;
77147: LD_ADDR_VAR 0 2
77151: PUSH
77152: LD_EXP 36
77156: PUSH
77157: LD_VAR 0 1
77161: ARRAY
77162: ST_TO_ADDR
// end ;
77163: LD_VAR 0 2
77167: RET
// export function MC_GetProduceList ( base ) ; begin
77168: LD_INT 0
77170: PPUSH
// result := mc_produce [ base ] ;
77171: LD_ADDR_VAR 0 2
77175: PUSH
77176: LD_EXP 44
77180: PUSH
77181: LD_VAR 0 1
77185: ARRAY
77186: ST_TO_ADDR
// end ;
77187: LD_VAR 0 2
77191: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77192: LD_INT 0
77194: PPUSH
77195: PPUSH
// if not mc_bases then
77196: LD_EXP 23
77200: NOT
77201: IFFALSE 77205
// exit ;
77203: GO 77270
// if mc_bases [ base ] then
77205: LD_EXP 23
77209: PUSH
77210: LD_VAR 0 1
77214: ARRAY
77215: IFFALSE 77270
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77217: LD_ADDR_VAR 0 3
77221: PUSH
77222: LD_EXP 23
77226: PUSH
77227: LD_VAR 0 1
77231: ARRAY
77232: PPUSH
77233: LD_INT 30
77235: PUSH
77236: LD_VAR 0 2
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PPUSH
77245: CALL_OW 72
77249: ST_TO_ADDR
// if result then
77250: LD_VAR 0 3
77254: IFFALSE 77270
// result := result [ 1 ] ;
77256: LD_ADDR_VAR 0 3
77260: PUSH
77261: LD_VAR 0 3
77265: PUSH
77266: LD_INT 1
77268: ARRAY
77269: ST_TO_ADDR
// end ; end ;
77270: LD_VAR 0 3
77274: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77275: LD_INT 0
77277: PPUSH
77278: PPUSH
// if not mc_bases then
77279: LD_EXP 23
77283: NOT
77284: IFFALSE 77288
// exit ;
77286: GO 77333
// if mc_bases [ base ] then
77288: LD_EXP 23
77292: PUSH
77293: LD_VAR 0 1
77297: ARRAY
77298: IFFALSE 77333
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77300: LD_ADDR_VAR 0 3
77304: PUSH
77305: LD_EXP 23
77309: PUSH
77310: LD_VAR 0 1
77314: ARRAY
77315: PPUSH
77316: LD_INT 30
77318: PUSH
77319: LD_VAR 0 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PPUSH
77328: CALL_OW 72
77332: ST_TO_ADDR
// end ;
77333: LD_VAR 0 3
77337: RET
// export function MC_SetTame ( base , area ) ; begin
77338: LD_INT 0
77340: PPUSH
// if not mc_bases or not base then
77341: LD_EXP 23
77345: NOT
77346: PUSH
77347: LD_VAR 0 1
77351: NOT
77352: OR
77353: IFFALSE 77357
// exit ;
77355: GO 77382
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77357: LD_ADDR_EXP 51
77361: PUSH
77362: LD_EXP 51
77366: PPUSH
77367: LD_VAR 0 1
77371: PPUSH
77372: LD_VAR 0 2
77376: PPUSH
77377: CALL_OW 1
77381: ST_TO_ADDR
// end ;
77382: LD_VAR 0 3
77386: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77387: LD_INT 0
77389: PPUSH
77390: PPUSH
// if not mc_bases or not base then
77391: LD_EXP 23
77395: NOT
77396: PUSH
77397: LD_VAR 0 1
77401: NOT
77402: OR
77403: IFFALSE 77407
// exit ;
77405: GO 77509
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77407: LD_ADDR_VAR 0 4
77411: PUSH
77412: LD_EXP 23
77416: PUSH
77417: LD_VAR 0 1
77421: ARRAY
77422: PPUSH
77423: LD_INT 30
77425: PUSH
77426: LD_VAR 0 2
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PPUSH
77435: CALL_OW 72
77439: ST_TO_ADDR
// if not tmp then
77440: LD_VAR 0 4
77444: NOT
77445: IFFALSE 77449
// exit ;
77447: GO 77509
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77449: LD_ADDR_EXP 55
77453: PUSH
77454: LD_EXP 55
77458: PPUSH
77459: LD_VAR 0 1
77463: PPUSH
77464: LD_EXP 55
77468: PUSH
77469: LD_VAR 0 1
77473: ARRAY
77474: PPUSH
77475: LD_EXP 55
77479: PUSH
77480: LD_VAR 0 1
77484: ARRAY
77485: PUSH
77486: LD_INT 1
77488: PLUS
77489: PPUSH
77490: LD_VAR 0 4
77494: PUSH
77495: LD_INT 1
77497: ARRAY
77498: PPUSH
77499: CALL_OW 2
77503: PPUSH
77504: CALL_OW 1
77508: ST_TO_ADDR
// end ;
77509: LD_VAR 0 3
77513: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77514: LD_INT 0
77516: PPUSH
77517: PPUSH
// if not mc_bases or not base or not kinds then
77518: LD_EXP 23
77522: NOT
77523: PUSH
77524: LD_VAR 0 1
77528: NOT
77529: OR
77530: PUSH
77531: LD_VAR 0 2
77535: NOT
77536: OR
77537: IFFALSE 77541
// exit ;
77539: GO 77602
// for i in kinds do
77541: LD_ADDR_VAR 0 4
77545: PUSH
77546: LD_VAR 0 2
77550: PUSH
77551: FOR_IN
77552: IFFALSE 77600
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77554: LD_ADDR_EXP 57
77558: PUSH
77559: LD_EXP 57
77563: PPUSH
77564: LD_VAR 0 1
77568: PUSH
77569: LD_EXP 57
77573: PUSH
77574: LD_VAR 0 1
77578: ARRAY
77579: PUSH
77580: LD_INT 1
77582: PLUS
77583: PUSH
77584: EMPTY
77585: LIST
77586: LIST
77587: PPUSH
77588: LD_VAR 0 4
77592: PPUSH
77593: CALL 16252 0 3
77597: ST_TO_ADDR
77598: GO 77551
77600: POP
77601: POP
// end ;
77602: LD_VAR 0 3
77606: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77607: LD_INT 0
77609: PPUSH
// if not mc_bases or not base or not areas then
77610: LD_EXP 23
77614: NOT
77615: PUSH
77616: LD_VAR 0 1
77620: NOT
77621: OR
77622: PUSH
77623: LD_VAR 0 2
77627: NOT
77628: OR
77629: IFFALSE 77633
// exit ;
77631: GO 77658
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77633: LD_ADDR_EXP 41
77637: PUSH
77638: LD_EXP 41
77642: PPUSH
77643: LD_VAR 0 1
77647: PPUSH
77648: LD_VAR 0 2
77652: PPUSH
77653: CALL_OW 1
77657: ST_TO_ADDR
// end ;
77658: LD_VAR 0 3
77662: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77663: LD_INT 0
77665: PPUSH
// if not mc_bases or not base or not teleports_exit then
77666: LD_EXP 23
77670: NOT
77671: PUSH
77672: LD_VAR 0 1
77676: NOT
77677: OR
77678: PUSH
77679: LD_VAR 0 2
77683: NOT
77684: OR
77685: IFFALSE 77689
// exit ;
77687: GO 77714
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77689: LD_ADDR_EXP 58
77693: PUSH
77694: LD_EXP 58
77698: PPUSH
77699: LD_VAR 0 1
77703: PPUSH
77704: LD_VAR 0 2
77708: PPUSH
77709: CALL_OW 1
77713: ST_TO_ADDR
// end ;
77714: LD_VAR 0 3
77718: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77719: LD_INT 0
77721: PPUSH
77722: PPUSH
77723: PPUSH
// if not mc_bases or not base or not ext_list then
77724: LD_EXP 23
77728: NOT
77729: PUSH
77730: LD_VAR 0 1
77734: NOT
77735: OR
77736: PUSH
77737: LD_VAR 0 5
77741: NOT
77742: OR
77743: IFFALSE 77747
// exit ;
77745: GO 77920
// tmp := GetFacExtXYD ( x , y , d ) ;
77747: LD_ADDR_VAR 0 8
77751: PUSH
77752: LD_VAR 0 2
77756: PPUSH
77757: LD_VAR 0 3
77761: PPUSH
77762: LD_VAR 0 4
77766: PPUSH
77767: CALL 46229 0 3
77771: ST_TO_ADDR
// if not tmp then
77772: LD_VAR 0 8
77776: NOT
77777: IFFALSE 77781
// exit ;
77779: GO 77920
// for i in tmp do
77781: LD_ADDR_VAR 0 7
77785: PUSH
77786: LD_VAR 0 8
77790: PUSH
77791: FOR_IN
77792: IFFALSE 77918
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77794: LD_ADDR_EXP 28
77798: PUSH
77799: LD_EXP 28
77803: PPUSH
77804: LD_VAR 0 1
77808: PPUSH
77809: LD_EXP 28
77813: PUSH
77814: LD_VAR 0 1
77818: ARRAY
77819: PPUSH
77820: LD_EXP 28
77824: PUSH
77825: LD_VAR 0 1
77829: ARRAY
77830: PUSH
77831: LD_INT 1
77833: PLUS
77834: PPUSH
77835: LD_VAR 0 5
77839: PUSH
77840: LD_INT 1
77842: ARRAY
77843: PUSH
77844: LD_VAR 0 7
77848: PUSH
77849: LD_INT 1
77851: ARRAY
77852: PUSH
77853: LD_VAR 0 7
77857: PUSH
77858: LD_INT 2
77860: ARRAY
77861: PUSH
77862: LD_VAR 0 7
77866: PUSH
77867: LD_INT 3
77869: ARRAY
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: LIST
77875: LIST
77876: PPUSH
77877: CALL_OW 2
77881: PPUSH
77882: CALL_OW 1
77886: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77887: LD_ADDR_VAR 0 5
77891: PUSH
77892: LD_VAR 0 5
77896: PPUSH
77897: LD_INT 1
77899: PPUSH
77900: CALL_OW 3
77904: ST_TO_ADDR
// if not ext_list then
77905: LD_VAR 0 5
77909: NOT
77910: IFFALSE 77916
// exit ;
77912: POP
77913: POP
77914: GO 77920
// end ;
77916: GO 77791
77918: POP
77919: POP
// end ;
77920: LD_VAR 0 6
77924: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77925: LD_INT 0
77927: PPUSH
// if not mc_bases or not base or not weapon_list then
77928: LD_EXP 23
77932: NOT
77933: PUSH
77934: LD_VAR 0 1
77938: NOT
77939: OR
77940: PUSH
77941: LD_VAR 0 2
77945: NOT
77946: OR
77947: IFFALSE 77951
// exit ;
77949: GO 77976
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77951: LD_ADDR_EXP 62
77955: PUSH
77956: LD_EXP 62
77960: PPUSH
77961: LD_VAR 0 1
77965: PPUSH
77966: LD_VAR 0 2
77970: PPUSH
77971: CALL_OW 1
77975: ST_TO_ADDR
// end ;
77976: LD_VAR 0 3
77980: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77981: LD_INT 0
77983: PPUSH
// if not mc_bases or not base or not tech_list then
77984: LD_EXP 23
77988: NOT
77989: PUSH
77990: LD_VAR 0 1
77994: NOT
77995: OR
77996: PUSH
77997: LD_VAR 0 2
78001: NOT
78002: OR
78003: IFFALSE 78007
// exit ;
78005: GO 78032
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78007: LD_ADDR_EXP 50
78011: PUSH
78012: LD_EXP 50
78016: PPUSH
78017: LD_VAR 0 1
78021: PPUSH
78022: LD_VAR 0 2
78026: PPUSH
78027: CALL_OW 1
78031: ST_TO_ADDR
// end ;
78032: LD_VAR 0 3
78036: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78037: LD_INT 0
78039: PPUSH
// if not mc_bases or not parking_area or not base then
78040: LD_EXP 23
78044: NOT
78045: PUSH
78046: LD_VAR 0 2
78050: NOT
78051: OR
78052: PUSH
78053: LD_VAR 0 1
78057: NOT
78058: OR
78059: IFFALSE 78063
// exit ;
78061: GO 78088
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78063: LD_ADDR_EXP 47
78067: PUSH
78068: LD_EXP 47
78072: PPUSH
78073: LD_VAR 0 1
78077: PPUSH
78078: LD_VAR 0 2
78082: PPUSH
78083: CALL_OW 1
78087: ST_TO_ADDR
// end ;
78088: LD_VAR 0 3
78092: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78093: LD_INT 0
78095: PPUSH
// if not mc_bases or not base or not scan_area then
78096: LD_EXP 23
78100: NOT
78101: PUSH
78102: LD_VAR 0 1
78106: NOT
78107: OR
78108: PUSH
78109: LD_VAR 0 2
78113: NOT
78114: OR
78115: IFFALSE 78119
// exit ;
78117: GO 78144
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78119: LD_ADDR_EXP 48
78123: PUSH
78124: LD_EXP 48
78128: PPUSH
78129: LD_VAR 0 1
78133: PPUSH
78134: LD_VAR 0 2
78138: PPUSH
78139: CALL_OW 1
78143: ST_TO_ADDR
// end ;
78144: LD_VAR 0 3
78148: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78149: LD_INT 0
78151: PPUSH
78152: PPUSH
// if not mc_bases or not base then
78153: LD_EXP 23
78157: NOT
78158: PUSH
78159: LD_VAR 0 1
78163: NOT
78164: OR
78165: IFFALSE 78169
// exit ;
78167: GO 78233
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78169: LD_ADDR_VAR 0 3
78173: PUSH
78174: LD_INT 1
78176: PUSH
78177: LD_INT 2
78179: PUSH
78180: LD_INT 3
78182: PUSH
78183: LD_INT 4
78185: PUSH
78186: LD_INT 11
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78196: LD_ADDR_EXP 50
78200: PUSH
78201: LD_EXP 50
78205: PPUSH
78206: LD_VAR 0 1
78210: PPUSH
78211: LD_EXP 50
78215: PUSH
78216: LD_VAR 0 1
78220: ARRAY
78221: PUSH
78222: LD_VAR 0 3
78226: DIFF
78227: PPUSH
78228: CALL_OW 1
78232: ST_TO_ADDR
// end ;
78233: LD_VAR 0 2
78237: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78238: LD_INT 0
78240: PPUSH
// result := mc_vehicles [ base ] ;
78241: LD_ADDR_VAR 0 3
78245: PUSH
78246: LD_EXP 42
78250: PUSH
78251: LD_VAR 0 1
78255: ARRAY
78256: ST_TO_ADDR
// if onlyCombat then
78257: LD_VAR 0 2
78261: IFFALSE 78433
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78263: LD_ADDR_VAR 0 3
78267: PUSH
78268: LD_VAR 0 3
78272: PUSH
78273: LD_VAR 0 3
78277: PPUSH
78278: LD_INT 2
78280: PUSH
78281: LD_INT 34
78283: PUSH
78284: LD_INT 12
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 34
78293: PUSH
78294: LD_INT 51
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 34
78303: PUSH
78304: LD_INT 89
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: PUSH
78311: LD_INT 34
78313: PUSH
78314: LD_INT 32
78316: PUSH
78317: EMPTY
78318: LIST
78319: LIST
78320: PUSH
78321: LD_INT 34
78323: PUSH
78324: LD_INT 13
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 34
78333: PUSH
78334: LD_INT 52
78336: PUSH
78337: EMPTY
78338: LIST
78339: LIST
78340: PUSH
78341: LD_INT 34
78343: PUSH
78344: LD_INT 88
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 34
78353: PUSH
78354: LD_INT 14
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: PUSH
78361: LD_INT 34
78363: PUSH
78364: LD_INT 53
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: PUSH
78371: LD_INT 34
78373: PUSH
78374: LD_INT 98
78376: PUSH
78377: EMPTY
78378: LIST
78379: LIST
78380: PUSH
78381: LD_INT 34
78383: PUSH
78384: LD_INT 31
78386: PUSH
78387: EMPTY
78388: LIST
78389: LIST
78390: PUSH
78391: LD_INT 34
78393: PUSH
78394: LD_INT 48
78396: PUSH
78397: EMPTY
78398: LIST
78399: LIST
78400: PUSH
78401: LD_INT 34
78403: PUSH
78404: LD_INT 8
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: EMPTY
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: PPUSH
78427: CALL_OW 72
78431: DIFF
78432: ST_TO_ADDR
// end ; end_of_file
78433: LD_VAR 0 3
78437: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78438: LD_INT 0
78440: PPUSH
78441: PPUSH
78442: PPUSH
// if not mc_bases or not skirmish then
78443: LD_EXP 23
78447: NOT
78448: PUSH
78449: LD_EXP 21
78453: NOT
78454: OR
78455: IFFALSE 78459
// exit ;
78457: GO 78624
// for i = 1 to mc_bases do
78459: LD_ADDR_VAR 0 4
78463: PUSH
78464: DOUBLE
78465: LD_INT 1
78467: DEC
78468: ST_TO_ADDR
78469: LD_EXP 23
78473: PUSH
78474: FOR_TO
78475: IFFALSE 78622
// begin if sci in mc_bases [ i ] then
78477: LD_VAR 0 2
78481: PUSH
78482: LD_EXP 23
78486: PUSH
78487: LD_VAR 0 4
78491: ARRAY
78492: IN
78493: IFFALSE 78620
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78495: LD_ADDR_EXP 52
78499: PUSH
78500: LD_EXP 52
78504: PPUSH
78505: LD_VAR 0 4
78509: PUSH
78510: LD_EXP 52
78514: PUSH
78515: LD_VAR 0 4
78519: ARRAY
78520: PUSH
78521: LD_INT 1
78523: PLUS
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: PPUSH
78529: LD_VAR 0 1
78533: PPUSH
78534: CALL 16252 0 3
78538: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78539: LD_ADDR_VAR 0 5
78543: PUSH
78544: LD_EXP 23
78548: PUSH
78549: LD_VAR 0 4
78553: ARRAY
78554: PPUSH
78555: LD_INT 2
78557: PUSH
78558: LD_INT 30
78560: PUSH
78561: LD_INT 0
78563: PUSH
78564: EMPTY
78565: LIST
78566: LIST
78567: PUSH
78568: LD_INT 30
78570: PUSH
78571: LD_INT 1
78573: PUSH
78574: EMPTY
78575: LIST
78576: LIST
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: LIST
78582: PPUSH
78583: CALL_OW 72
78587: PPUSH
78588: LD_VAR 0 1
78592: PPUSH
78593: CALL_OW 74
78597: ST_TO_ADDR
// if tmp then
78598: LD_VAR 0 5
78602: IFFALSE 78618
// ComStandNearbyBuilding ( ape , tmp ) ;
78604: LD_VAR 0 1
78608: PPUSH
78609: LD_VAR 0 5
78613: PPUSH
78614: CALL 12679 0 2
// break ;
78618: GO 78622
// end ; end ;
78620: GO 78474
78622: POP
78623: POP
// end ;
78624: LD_VAR 0 3
78628: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78629: LD_INT 0
78631: PPUSH
78632: PPUSH
78633: PPUSH
// if not mc_bases or not skirmish then
78634: LD_EXP 23
78638: NOT
78639: PUSH
78640: LD_EXP 21
78644: NOT
78645: OR
78646: IFFALSE 78650
// exit ;
78648: GO 78739
// for i = 1 to mc_bases do
78650: LD_ADDR_VAR 0 4
78654: PUSH
78655: DOUBLE
78656: LD_INT 1
78658: DEC
78659: ST_TO_ADDR
78660: LD_EXP 23
78664: PUSH
78665: FOR_TO
78666: IFFALSE 78737
// begin if building in mc_busy_turret_list [ i ] then
78668: LD_VAR 0 1
78672: PUSH
78673: LD_EXP 33
78677: PUSH
78678: LD_VAR 0 4
78682: ARRAY
78683: IN
78684: IFFALSE 78735
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78686: LD_ADDR_VAR 0 5
78690: PUSH
78691: LD_EXP 33
78695: PUSH
78696: LD_VAR 0 4
78700: ARRAY
78701: PUSH
78702: LD_VAR 0 1
78706: DIFF
78707: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78708: LD_ADDR_EXP 33
78712: PUSH
78713: LD_EXP 33
78717: PPUSH
78718: LD_VAR 0 4
78722: PPUSH
78723: LD_VAR 0 5
78727: PPUSH
78728: CALL_OW 1
78732: ST_TO_ADDR
// break ;
78733: GO 78737
// end ; end ;
78735: GO 78665
78737: POP
78738: POP
// end ;
78739: LD_VAR 0 3
78743: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78744: LD_INT 0
78746: PPUSH
78747: PPUSH
78748: PPUSH
// if not mc_bases or not skirmish then
78749: LD_EXP 23
78753: NOT
78754: PUSH
78755: LD_EXP 21
78759: NOT
78760: OR
78761: IFFALSE 78765
// exit ;
78763: GO 78964
// for i = 1 to mc_bases do
78765: LD_ADDR_VAR 0 5
78769: PUSH
78770: DOUBLE
78771: LD_INT 1
78773: DEC
78774: ST_TO_ADDR
78775: LD_EXP 23
78779: PUSH
78780: FOR_TO
78781: IFFALSE 78962
// if building in mc_bases [ i ] then
78783: LD_VAR 0 1
78787: PUSH
78788: LD_EXP 23
78792: PUSH
78793: LD_VAR 0 5
78797: ARRAY
78798: IN
78799: IFFALSE 78960
// begin tmp := mc_bases [ i ] diff building ;
78801: LD_ADDR_VAR 0 6
78805: PUSH
78806: LD_EXP 23
78810: PUSH
78811: LD_VAR 0 5
78815: ARRAY
78816: PUSH
78817: LD_VAR 0 1
78821: DIFF
78822: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78823: LD_ADDR_EXP 23
78827: PUSH
78828: LD_EXP 23
78832: PPUSH
78833: LD_VAR 0 5
78837: PPUSH
78838: LD_VAR 0 6
78842: PPUSH
78843: CALL_OW 1
78847: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78848: LD_VAR 0 1
78852: PUSH
78853: LD_EXP 31
78857: PUSH
78858: LD_VAR 0 5
78862: ARRAY
78863: IN
78864: IFFALSE 78903
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78866: LD_ADDR_EXP 31
78870: PUSH
78871: LD_EXP 31
78875: PPUSH
78876: LD_VAR 0 5
78880: PPUSH
78881: LD_EXP 31
78885: PUSH
78886: LD_VAR 0 5
78890: ARRAY
78891: PUSH
78892: LD_VAR 0 1
78896: DIFF
78897: PPUSH
78898: CALL_OW 1
78902: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78903: LD_VAR 0 1
78907: PUSH
78908: LD_EXP 32
78912: PUSH
78913: LD_VAR 0 5
78917: ARRAY
78918: IN
78919: IFFALSE 78958
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78921: LD_ADDR_EXP 32
78925: PUSH
78926: LD_EXP 32
78930: PPUSH
78931: LD_VAR 0 5
78935: PPUSH
78936: LD_EXP 32
78940: PUSH
78941: LD_VAR 0 5
78945: ARRAY
78946: PUSH
78947: LD_VAR 0 1
78951: DIFF
78952: PPUSH
78953: CALL_OW 1
78957: ST_TO_ADDR
// break ;
78958: GO 78962
// end ;
78960: GO 78780
78962: POP
78963: POP
// end ;
78964: LD_VAR 0 4
78968: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78969: LD_INT 0
78971: PPUSH
78972: PPUSH
78973: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78974: LD_EXP 23
78978: NOT
78979: PUSH
78980: LD_EXP 21
78984: NOT
78985: OR
78986: PUSH
78987: LD_VAR 0 3
78991: PUSH
78992: LD_EXP 49
78996: IN
78997: NOT
78998: OR
78999: IFFALSE 79003
// exit ;
79001: GO 79126
// for i = 1 to mc_vehicles do
79003: LD_ADDR_VAR 0 6
79007: PUSH
79008: DOUBLE
79009: LD_INT 1
79011: DEC
79012: ST_TO_ADDR
79013: LD_EXP 42
79017: PUSH
79018: FOR_TO
79019: IFFALSE 79124
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79021: LD_VAR 0 2
79025: PUSH
79026: LD_EXP 42
79030: PUSH
79031: LD_VAR 0 6
79035: ARRAY
79036: IN
79037: PUSH
79038: LD_VAR 0 1
79042: PUSH
79043: LD_EXP 42
79047: PUSH
79048: LD_VAR 0 6
79052: ARRAY
79053: IN
79054: OR
79055: IFFALSE 79122
// begin tmp := mc_vehicles [ i ] diff old ;
79057: LD_ADDR_VAR 0 7
79061: PUSH
79062: LD_EXP 42
79066: PUSH
79067: LD_VAR 0 6
79071: ARRAY
79072: PUSH
79073: LD_VAR 0 2
79077: DIFF
79078: ST_TO_ADDR
// tmp := tmp diff new ;
79079: LD_ADDR_VAR 0 7
79083: PUSH
79084: LD_VAR 0 7
79088: PUSH
79089: LD_VAR 0 1
79093: DIFF
79094: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79095: LD_ADDR_EXP 42
79099: PUSH
79100: LD_EXP 42
79104: PPUSH
79105: LD_VAR 0 6
79109: PPUSH
79110: LD_VAR 0 7
79114: PPUSH
79115: CALL_OW 1
79119: ST_TO_ADDR
// break ;
79120: GO 79124
// end ;
79122: GO 79018
79124: POP
79125: POP
// end ;
79126: LD_VAR 0 5
79130: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79131: LD_INT 0
79133: PPUSH
79134: PPUSH
79135: PPUSH
79136: PPUSH
// if not mc_bases or not skirmish then
79137: LD_EXP 23
79141: NOT
79142: PUSH
79143: LD_EXP 21
79147: NOT
79148: OR
79149: IFFALSE 79153
// exit ;
79151: GO 79573
// repeat wait ( 0 0$1 ) ;
79153: LD_INT 35
79155: PPUSH
79156: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
79160: LD_EXP 67
79164: NOT
79165: IFFALSE 79153
// mc_block_vehicle_constructed_thread := true ;
79167: LD_ADDR_EXP 67
79171: PUSH
79172: LD_INT 1
79174: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
79175: LD_ADDR_VAR 0 5
79179: PUSH
79180: LD_VAR 0 1
79184: PPUSH
79185: CALL_OW 255
79189: ST_TO_ADDR
// for i = 1 to mc_bases do
79190: LD_ADDR_VAR 0 4
79194: PUSH
79195: DOUBLE
79196: LD_INT 1
79198: DEC
79199: ST_TO_ADDR
79200: LD_EXP 23
79204: PUSH
79205: FOR_TO
79206: IFFALSE 79563
// begin if factory in mc_bases [ i ] then
79208: LD_VAR 0 2
79212: PUSH
79213: LD_EXP 23
79217: PUSH
79218: LD_VAR 0 4
79222: ARRAY
79223: IN
79224: IFFALSE 79561
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79226: LD_EXP 45
79230: PUSH
79231: LD_VAR 0 4
79235: ARRAY
79236: PUSH
79237: LD_EXP 34
79241: PUSH
79242: LD_VAR 0 4
79246: ARRAY
79247: LESS
79248: PUSH
79249: LD_VAR 0 1
79253: PPUSH
79254: CALL_OW 264
79258: PUSH
79259: LD_INT 31
79261: PUSH
79262: LD_INT 32
79264: PUSH
79265: LD_INT 51
79267: PUSH
79268: LD_INT 89
79270: PUSH
79271: LD_INT 12
79273: PUSH
79274: LD_INT 30
79276: PUSH
79277: LD_INT 98
79279: PUSH
79280: LD_INT 11
79282: PUSH
79283: LD_INT 53
79285: PUSH
79286: LD_INT 14
79288: PUSH
79289: LD_INT 91
79291: PUSH
79292: LD_INT 29
79294: PUSH
79295: LD_INT 99
79297: PUSH
79298: LD_INT 13
79300: PUSH
79301: LD_INT 52
79303: PUSH
79304: LD_INT 88
79306: PUSH
79307: LD_INT 48
79309: PUSH
79310: LD_INT 8
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: IN
79333: NOT
79334: AND
79335: IFFALSE 79383
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79337: LD_ADDR_EXP 45
79341: PUSH
79342: LD_EXP 45
79346: PPUSH
79347: LD_VAR 0 4
79351: PUSH
79352: LD_EXP 45
79356: PUSH
79357: LD_VAR 0 4
79361: ARRAY
79362: PUSH
79363: LD_INT 1
79365: PLUS
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PPUSH
79371: LD_VAR 0 1
79375: PPUSH
79376: CALL 16252 0 3
79380: ST_TO_ADDR
79381: GO 79427
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79383: LD_ADDR_EXP 42
79387: PUSH
79388: LD_EXP 42
79392: PPUSH
79393: LD_VAR 0 4
79397: PUSH
79398: LD_EXP 42
79402: PUSH
79403: LD_VAR 0 4
79407: ARRAY
79408: PUSH
79409: LD_INT 1
79411: PLUS
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PPUSH
79417: LD_VAR 0 1
79421: PPUSH
79422: CALL 16252 0 3
79426: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
79427: LD_ADDR_EXP 67
79431: PUSH
79432: LD_INT 0
79434: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79435: LD_VAR 0 1
79439: PPUSH
79440: CALL_OW 263
79444: PUSH
79445: LD_INT 2
79447: EQUAL
79448: IFFALSE 79477
// begin repeat wait ( 0 0$3 ) ;
79450: LD_INT 105
79452: PPUSH
79453: CALL_OW 67
// Connect ( vehicle ) ;
79457: LD_VAR 0 1
79461: PPUSH
79462: CALL 19221 0 1
// until IsControledBy ( vehicle ) ;
79466: LD_VAR 0 1
79470: PPUSH
79471: CALL_OW 312
79475: IFFALSE 79450
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79477: LD_VAR 0 1
79481: PPUSH
79482: LD_EXP 47
79486: PUSH
79487: LD_VAR 0 4
79491: ARRAY
79492: PPUSH
79493: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79497: LD_VAR 0 1
79501: PPUSH
79502: CALL_OW 263
79506: PUSH
79507: LD_INT 1
79509: NONEQUAL
79510: IFFALSE 79514
// break ;
79512: GO 79563
// repeat wait ( 0 0$1 ) ;
79514: LD_INT 35
79516: PPUSH
79517: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79521: LD_VAR 0 1
79525: PPUSH
79526: LD_EXP 47
79530: PUSH
79531: LD_VAR 0 4
79535: ARRAY
79536: PPUSH
79537: CALL_OW 308
79541: IFFALSE 79514
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79543: LD_VAR 0 1
79547: PPUSH
79548: CALL_OW 311
79552: PPUSH
79553: CALL_OW 121
// exit ;
79557: POP
79558: POP
79559: GO 79573
// end ; end ;
79561: GO 79205
79563: POP
79564: POP
// mc_block_vehicle_constructed_thread := false ;
79565: LD_ADDR_EXP 67
79569: PUSH
79570: LD_INT 0
79572: ST_TO_ADDR
// end ;
79573: LD_VAR 0 3
79577: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79578: LD_INT 0
79580: PPUSH
79581: PPUSH
79582: PPUSH
79583: PPUSH
// if not mc_bases or not skirmish then
79584: LD_EXP 23
79588: NOT
79589: PUSH
79590: LD_EXP 21
79594: NOT
79595: OR
79596: IFFALSE 79600
// exit ;
79598: GO 79953
// repeat wait ( 0 0$1 ) ;
79600: LD_INT 35
79602: PPUSH
79603: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79607: LD_VAR 0 2
79611: PPUSH
79612: LD_VAR 0 3
79616: PPUSH
79617: CALL_OW 284
79621: IFFALSE 79600
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79623: LD_VAR 0 2
79627: PPUSH
79628: LD_VAR 0 3
79632: PPUSH
79633: CALL_OW 283
79637: PUSH
79638: LD_INT 4
79640: EQUAL
79641: IFFALSE 79645
// exit ;
79643: GO 79953
// for i = 1 to mc_bases do
79645: LD_ADDR_VAR 0 7
79649: PUSH
79650: DOUBLE
79651: LD_INT 1
79653: DEC
79654: ST_TO_ADDR
79655: LD_EXP 23
79659: PUSH
79660: FOR_TO
79661: IFFALSE 79951
// begin if mc_crates_area [ i ] then
79663: LD_EXP 41
79667: PUSH
79668: LD_VAR 0 7
79672: ARRAY
79673: IFFALSE 79784
// for j in mc_crates_area [ i ] do
79675: LD_ADDR_VAR 0 8
79679: PUSH
79680: LD_EXP 41
79684: PUSH
79685: LD_VAR 0 7
79689: ARRAY
79690: PUSH
79691: FOR_IN
79692: IFFALSE 79782
// if InArea ( x , y , j ) then
79694: LD_VAR 0 2
79698: PPUSH
79699: LD_VAR 0 3
79703: PPUSH
79704: LD_VAR 0 8
79708: PPUSH
79709: CALL_OW 309
79713: IFFALSE 79780
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79715: LD_ADDR_EXP 39
79719: PUSH
79720: LD_EXP 39
79724: PPUSH
79725: LD_VAR 0 7
79729: PUSH
79730: LD_EXP 39
79734: PUSH
79735: LD_VAR 0 7
79739: ARRAY
79740: PUSH
79741: LD_INT 1
79743: PLUS
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PPUSH
79749: LD_VAR 0 4
79753: PUSH
79754: LD_VAR 0 2
79758: PUSH
79759: LD_VAR 0 3
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: LIST
79768: PPUSH
79769: CALL 16252 0 3
79773: ST_TO_ADDR
// exit ;
79774: POP
79775: POP
79776: POP
79777: POP
79778: GO 79953
// end ;
79780: GO 79691
79782: POP
79783: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79784: LD_ADDR_VAR 0 9
79788: PUSH
79789: LD_EXP 23
79793: PUSH
79794: LD_VAR 0 7
79798: ARRAY
79799: PPUSH
79800: LD_INT 2
79802: PUSH
79803: LD_INT 30
79805: PUSH
79806: LD_INT 0
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 30
79815: PUSH
79816: LD_INT 1
79818: PUSH
79819: EMPTY
79820: LIST
79821: LIST
79822: PUSH
79823: EMPTY
79824: LIST
79825: LIST
79826: LIST
79827: PPUSH
79828: CALL_OW 72
79832: ST_TO_ADDR
// if not depot then
79833: LD_VAR 0 9
79837: NOT
79838: IFFALSE 79842
// continue ;
79840: GO 79660
// for j in depot do
79842: LD_ADDR_VAR 0 8
79846: PUSH
79847: LD_VAR 0 9
79851: PUSH
79852: FOR_IN
79853: IFFALSE 79947
// if GetDistUnitXY ( j , x , y ) < 30 then
79855: LD_VAR 0 8
79859: PPUSH
79860: LD_VAR 0 2
79864: PPUSH
79865: LD_VAR 0 3
79869: PPUSH
79870: CALL_OW 297
79874: PUSH
79875: LD_INT 30
79877: LESS
79878: IFFALSE 79945
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79880: LD_ADDR_EXP 39
79884: PUSH
79885: LD_EXP 39
79889: PPUSH
79890: LD_VAR 0 7
79894: PUSH
79895: LD_EXP 39
79899: PUSH
79900: LD_VAR 0 7
79904: ARRAY
79905: PUSH
79906: LD_INT 1
79908: PLUS
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PPUSH
79914: LD_VAR 0 4
79918: PUSH
79919: LD_VAR 0 2
79923: PUSH
79924: LD_VAR 0 3
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: LIST
79933: PPUSH
79934: CALL 16252 0 3
79938: ST_TO_ADDR
// exit ;
79939: POP
79940: POP
79941: POP
79942: POP
79943: GO 79953
// end ;
79945: GO 79852
79947: POP
79948: POP
// end ;
79949: GO 79660
79951: POP
79952: POP
// end ;
79953: LD_VAR 0 6
79957: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79958: LD_INT 0
79960: PPUSH
79961: PPUSH
79962: PPUSH
79963: PPUSH
// if not mc_bases or not skirmish then
79964: LD_EXP 23
79968: NOT
79969: PUSH
79970: LD_EXP 21
79974: NOT
79975: OR
79976: IFFALSE 79980
// exit ;
79978: GO 80257
// side := GetSide ( lab ) ;
79980: LD_ADDR_VAR 0 4
79984: PUSH
79985: LD_VAR 0 2
79989: PPUSH
79990: CALL_OW 255
79994: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79995: LD_VAR 0 4
79999: PUSH
80000: LD_EXP 49
80004: IN
80005: NOT
80006: PUSH
80007: LD_EXP 50
80011: NOT
80012: OR
80013: PUSH
80014: LD_EXP 23
80018: NOT
80019: OR
80020: IFFALSE 80024
// exit ;
80022: GO 80257
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80024: LD_ADDR_EXP 50
80028: PUSH
80029: LD_EXP 50
80033: PPUSH
80034: LD_VAR 0 4
80038: PPUSH
80039: LD_EXP 50
80043: PUSH
80044: LD_VAR 0 4
80048: ARRAY
80049: PUSH
80050: LD_VAR 0 1
80054: DIFF
80055: PPUSH
80056: CALL_OW 1
80060: ST_TO_ADDR
// for i = 1 to mc_bases do
80061: LD_ADDR_VAR 0 5
80065: PUSH
80066: DOUBLE
80067: LD_INT 1
80069: DEC
80070: ST_TO_ADDR
80071: LD_EXP 23
80075: PUSH
80076: FOR_TO
80077: IFFALSE 80255
// begin if lab in mc_bases [ i ] then
80079: LD_VAR 0 2
80083: PUSH
80084: LD_EXP 23
80088: PUSH
80089: LD_VAR 0 5
80093: ARRAY
80094: IN
80095: IFFALSE 80253
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80097: LD_VAR 0 1
80101: PUSH
80102: LD_INT 11
80104: PUSH
80105: LD_INT 4
80107: PUSH
80108: LD_INT 3
80110: PUSH
80111: LD_INT 2
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: IN
80120: PUSH
80121: LD_EXP 53
80125: PUSH
80126: LD_VAR 0 5
80130: ARRAY
80131: AND
80132: IFFALSE 80253
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80134: LD_ADDR_VAR 0 6
80138: PUSH
80139: LD_EXP 53
80143: PUSH
80144: LD_VAR 0 5
80148: ARRAY
80149: PUSH
80150: LD_INT 1
80152: ARRAY
80153: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80154: LD_ADDR_EXP 53
80158: PUSH
80159: LD_EXP 53
80163: PPUSH
80164: LD_VAR 0 5
80168: PPUSH
80169: EMPTY
80170: PPUSH
80171: CALL_OW 1
80175: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80176: LD_VAR 0 6
80180: PPUSH
80181: LD_INT 0
80183: PPUSH
80184: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80188: LD_VAR 0 6
80192: PPUSH
80193: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80197: LD_ADDR_EXP 52
80201: PUSH
80202: LD_EXP 52
80206: PPUSH
80207: LD_VAR 0 5
80211: PPUSH
80212: LD_EXP 52
80216: PUSH
80217: LD_VAR 0 5
80221: ARRAY
80222: PPUSH
80223: LD_INT 1
80225: PPUSH
80226: LD_VAR 0 6
80230: PPUSH
80231: CALL_OW 2
80235: PPUSH
80236: CALL_OW 1
80240: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80241: LD_VAR 0 5
80245: PPUSH
80246: LD_INT 112
80248: PPUSH
80249: CALL 56705 0 2
// end ; end ; end ;
80253: GO 80076
80255: POP
80256: POP
// end ;
80257: LD_VAR 0 3
80261: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80262: LD_INT 0
80264: PPUSH
80265: PPUSH
80266: PPUSH
80267: PPUSH
80268: PPUSH
80269: PPUSH
80270: PPUSH
80271: PPUSH
// if not mc_bases or not skirmish then
80272: LD_EXP 23
80276: NOT
80277: PUSH
80278: LD_EXP 21
80282: NOT
80283: OR
80284: IFFALSE 80288
// exit ;
80286: GO 81657
// for i = 1 to mc_bases do
80288: LD_ADDR_VAR 0 3
80292: PUSH
80293: DOUBLE
80294: LD_INT 1
80296: DEC
80297: ST_TO_ADDR
80298: LD_EXP 23
80302: PUSH
80303: FOR_TO
80304: IFFALSE 81655
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80306: LD_VAR 0 1
80310: PUSH
80311: LD_EXP 23
80315: PUSH
80316: LD_VAR 0 3
80320: ARRAY
80321: IN
80322: PUSH
80323: LD_VAR 0 1
80327: PUSH
80328: LD_EXP 30
80332: PUSH
80333: LD_VAR 0 3
80337: ARRAY
80338: IN
80339: OR
80340: PUSH
80341: LD_VAR 0 1
80345: PUSH
80346: LD_EXP 45
80350: PUSH
80351: LD_VAR 0 3
80355: ARRAY
80356: IN
80357: OR
80358: PUSH
80359: LD_VAR 0 1
80363: PUSH
80364: LD_EXP 42
80368: PUSH
80369: LD_VAR 0 3
80373: ARRAY
80374: IN
80375: OR
80376: PUSH
80377: LD_VAR 0 1
80381: PUSH
80382: LD_EXP 52
80386: PUSH
80387: LD_VAR 0 3
80391: ARRAY
80392: IN
80393: OR
80394: PUSH
80395: LD_VAR 0 1
80399: PUSH
80400: LD_EXP 53
80404: PUSH
80405: LD_VAR 0 3
80409: ARRAY
80410: IN
80411: OR
80412: IFFALSE 81653
// begin if un in mc_ape [ i ] then
80414: LD_VAR 0 1
80418: PUSH
80419: LD_EXP 52
80423: PUSH
80424: LD_VAR 0 3
80428: ARRAY
80429: IN
80430: IFFALSE 80469
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80432: LD_ADDR_EXP 52
80436: PUSH
80437: LD_EXP 52
80441: PPUSH
80442: LD_VAR 0 3
80446: PPUSH
80447: LD_EXP 52
80451: PUSH
80452: LD_VAR 0 3
80456: ARRAY
80457: PUSH
80458: LD_VAR 0 1
80462: DIFF
80463: PPUSH
80464: CALL_OW 1
80468: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80469: LD_VAR 0 1
80473: PUSH
80474: LD_EXP 53
80478: PUSH
80479: LD_VAR 0 3
80483: ARRAY
80484: IN
80485: IFFALSE 80509
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80487: LD_ADDR_EXP 53
80491: PUSH
80492: LD_EXP 53
80496: PPUSH
80497: LD_VAR 0 3
80501: PPUSH
80502: EMPTY
80503: PPUSH
80504: CALL_OW 1
80508: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80509: LD_VAR 0 1
80513: PPUSH
80514: CALL_OW 247
80518: PUSH
80519: LD_INT 2
80521: EQUAL
80522: PUSH
80523: LD_VAR 0 1
80527: PPUSH
80528: CALL_OW 110
80532: PUSH
80533: LD_INT 20
80535: EQUAL
80536: PUSH
80537: LD_VAR 0 1
80541: PUSH
80542: LD_EXP 45
80546: PUSH
80547: LD_VAR 0 3
80551: ARRAY
80552: IN
80553: OR
80554: PUSH
80555: LD_VAR 0 1
80559: PPUSH
80560: CALL_OW 264
80564: PUSH
80565: LD_INT 12
80567: PUSH
80568: LD_INT 51
80570: PUSH
80571: LD_INT 89
80573: PUSH
80574: LD_INT 32
80576: PUSH
80577: LD_INT 13
80579: PUSH
80580: LD_INT 52
80582: PUSH
80583: LD_INT 31
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: LIST
80590: LIST
80591: LIST
80592: LIST
80593: LIST
80594: IN
80595: OR
80596: AND
80597: IFFALSE 80905
// begin if un in mc_defender [ i ] then
80599: LD_VAR 0 1
80603: PUSH
80604: LD_EXP 45
80608: PUSH
80609: LD_VAR 0 3
80613: ARRAY
80614: IN
80615: IFFALSE 80654
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80617: LD_ADDR_EXP 45
80621: PUSH
80622: LD_EXP 45
80626: PPUSH
80627: LD_VAR 0 3
80631: PPUSH
80632: LD_EXP 45
80636: PUSH
80637: LD_VAR 0 3
80641: ARRAY
80642: PUSH
80643: LD_VAR 0 1
80647: DIFF
80648: PPUSH
80649: CALL_OW 1
80653: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80654: LD_ADDR_VAR 0 8
80658: PUSH
80659: LD_VAR 0 3
80663: PPUSH
80664: LD_INT 3
80666: PPUSH
80667: CALL 77275 0 2
80671: ST_TO_ADDR
// if fac then
80672: LD_VAR 0 8
80676: IFFALSE 80905
// begin for j in fac do
80678: LD_ADDR_VAR 0 4
80682: PUSH
80683: LD_VAR 0 8
80687: PUSH
80688: FOR_IN
80689: IFFALSE 80903
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80691: LD_ADDR_VAR 0 9
80695: PUSH
80696: LD_VAR 0 8
80700: PPUSH
80701: LD_VAR 0 1
80705: PPUSH
80706: CALL_OW 265
80710: PPUSH
80711: LD_VAR 0 1
80715: PPUSH
80716: CALL_OW 262
80720: PPUSH
80721: LD_VAR 0 1
80725: PPUSH
80726: CALL_OW 263
80730: PPUSH
80731: LD_VAR 0 1
80735: PPUSH
80736: CALL_OW 264
80740: PPUSH
80741: CALL 13750 0 5
80745: ST_TO_ADDR
// if components then
80746: LD_VAR 0 9
80750: IFFALSE 80901
// begin if GetWeapon ( un ) = ar_control_tower then
80752: LD_VAR 0 1
80756: PPUSH
80757: CALL_OW 264
80761: PUSH
80762: LD_INT 31
80764: EQUAL
80765: IFFALSE 80882
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80767: LD_VAR 0 1
80771: PPUSH
80772: CALL_OW 311
80776: PPUSH
80777: LD_INT 0
80779: PPUSH
80780: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80784: LD_ADDR_EXP 63
80788: PUSH
80789: LD_EXP 63
80793: PPUSH
80794: LD_VAR 0 3
80798: PPUSH
80799: LD_EXP 63
80803: PUSH
80804: LD_VAR 0 3
80808: ARRAY
80809: PUSH
80810: LD_VAR 0 1
80814: PPUSH
80815: CALL_OW 311
80819: DIFF
80820: PPUSH
80821: CALL_OW 1
80825: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80826: LD_ADDR_VAR 0 7
80830: PUSH
80831: LD_EXP 44
80835: PUSH
80836: LD_VAR 0 3
80840: ARRAY
80841: PPUSH
80842: LD_INT 1
80844: PPUSH
80845: LD_VAR 0 9
80849: PPUSH
80850: CALL_OW 2
80854: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80855: LD_ADDR_EXP 44
80859: PUSH
80860: LD_EXP 44
80864: PPUSH
80865: LD_VAR 0 3
80869: PPUSH
80870: LD_VAR 0 7
80874: PPUSH
80875: CALL_OW 1
80879: ST_TO_ADDR
// end else
80880: GO 80899
// MC_InsertProduceList ( i , [ components ] ) ;
80882: LD_VAR 0 3
80886: PPUSH
80887: LD_VAR 0 9
80891: PUSH
80892: EMPTY
80893: LIST
80894: PPUSH
80895: CALL 76820 0 2
// break ;
80899: GO 80903
// end ; end ;
80901: GO 80688
80903: POP
80904: POP
// end ; end ; if GetType ( un ) = unit_building then
80905: LD_VAR 0 1
80909: PPUSH
80910: CALL_OW 247
80914: PUSH
80915: LD_INT 3
80917: EQUAL
80918: IFFALSE 81321
// begin btype := GetBType ( un ) ;
80920: LD_ADDR_VAR 0 5
80924: PUSH
80925: LD_VAR 0 1
80929: PPUSH
80930: CALL_OW 266
80934: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80935: LD_VAR 0 5
80939: PUSH
80940: LD_INT 29
80942: PUSH
80943: LD_INT 30
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: IN
80950: IFFALSE 81023
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80952: LD_VAR 0 1
80956: PPUSH
80957: CALL_OW 250
80961: PPUSH
80962: LD_VAR 0 1
80966: PPUSH
80967: CALL_OW 251
80971: PPUSH
80972: LD_VAR 0 1
80976: PPUSH
80977: CALL_OW 255
80981: PPUSH
80982: CALL_OW 440
80986: NOT
80987: IFFALSE 81023
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80989: LD_VAR 0 1
80993: PPUSH
80994: CALL_OW 250
80998: PPUSH
80999: LD_VAR 0 1
81003: PPUSH
81004: CALL_OW 251
81008: PPUSH
81009: LD_VAR 0 1
81013: PPUSH
81014: CALL_OW 255
81018: PPUSH
81019: CALL_OW 441
// end ; if btype = b_warehouse then
81023: LD_VAR 0 5
81027: PUSH
81028: LD_INT 1
81030: EQUAL
81031: IFFALSE 81049
// begin btype := b_depot ;
81033: LD_ADDR_VAR 0 5
81037: PUSH
81038: LD_INT 0
81040: ST_TO_ADDR
// pos := 1 ;
81041: LD_ADDR_VAR 0 6
81045: PUSH
81046: LD_INT 1
81048: ST_TO_ADDR
// end ; if btype = b_factory then
81049: LD_VAR 0 5
81053: PUSH
81054: LD_INT 3
81056: EQUAL
81057: IFFALSE 81075
// begin btype := b_workshop ;
81059: LD_ADDR_VAR 0 5
81063: PUSH
81064: LD_INT 2
81066: ST_TO_ADDR
// pos := 1 ;
81067: LD_ADDR_VAR 0 6
81071: PUSH
81072: LD_INT 1
81074: ST_TO_ADDR
// end ; if btype = b_barracks then
81075: LD_VAR 0 5
81079: PUSH
81080: LD_INT 5
81082: EQUAL
81083: IFFALSE 81093
// btype := b_armoury ;
81085: LD_ADDR_VAR 0 5
81089: PUSH
81090: LD_INT 4
81092: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81093: LD_VAR 0 5
81097: PUSH
81098: LD_INT 7
81100: PUSH
81101: LD_INT 8
81103: PUSH
81104: EMPTY
81105: LIST
81106: LIST
81107: IN
81108: IFFALSE 81118
// btype := b_lab ;
81110: LD_ADDR_VAR 0 5
81114: PUSH
81115: LD_INT 6
81117: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81118: LD_ADDR_EXP 28
81122: PUSH
81123: LD_EXP 28
81127: PPUSH
81128: LD_VAR 0 3
81132: PUSH
81133: LD_EXP 28
81137: PUSH
81138: LD_VAR 0 3
81142: ARRAY
81143: PUSH
81144: LD_INT 1
81146: PLUS
81147: PUSH
81148: EMPTY
81149: LIST
81150: LIST
81151: PPUSH
81152: LD_VAR 0 5
81156: PUSH
81157: LD_VAR 0 1
81161: PPUSH
81162: CALL_OW 250
81166: PUSH
81167: LD_VAR 0 1
81171: PPUSH
81172: CALL_OW 251
81176: PUSH
81177: LD_VAR 0 1
81181: PPUSH
81182: CALL_OW 254
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: PPUSH
81193: CALL 16252 0 3
81197: ST_TO_ADDR
// if pos = 1 then
81198: LD_VAR 0 6
81202: PUSH
81203: LD_INT 1
81205: EQUAL
81206: IFFALSE 81321
// begin tmp := mc_build_list [ i ] ;
81208: LD_ADDR_VAR 0 7
81212: PUSH
81213: LD_EXP 28
81217: PUSH
81218: LD_VAR 0 3
81222: ARRAY
81223: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81224: LD_VAR 0 7
81228: PPUSH
81229: LD_INT 2
81231: PUSH
81232: LD_INT 30
81234: PUSH
81235: LD_INT 0
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 30
81244: PUSH
81245: LD_INT 1
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: LIST
81256: PPUSH
81257: CALL_OW 72
81261: IFFALSE 81271
// pos := 2 ;
81263: LD_ADDR_VAR 0 6
81267: PUSH
81268: LD_INT 2
81270: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81271: LD_ADDR_VAR 0 7
81275: PUSH
81276: LD_VAR 0 7
81280: PPUSH
81281: LD_VAR 0 6
81285: PPUSH
81286: LD_VAR 0 7
81290: PPUSH
81291: CALL 16578 0 3
81295: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81296: LD_ADDR_EXP 28
81300: PUSH
81301: LD_EXP 28
81305: PPUSH
81306: LD_VAR 0 3
81310: PPUSH
81311: LD_VAR 0 7
81315: PPUSH
81316: CALL_OW 1
81320: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81321: LD_VAR 0 1
81325: PUSH
81326: LD_EXP 23
81330: PUSH
81331: LD_VAR 0 3
81335: ARRAY
81336: IN
81337: IFFALSE 81376
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81339: LD_ADDR_EXP 23
81343: PUSH
81344: LD_EXP 23
81348: PPUSH
81349: LD_VAR 0 3
81353: PPUSH
81354: LD_EXP 23
81358: PUSH
81359: LD_VAR 0 3
81363: ARRAY
81364: PUSH
81365: LD_VAR 0 1
81369: DIFF
81370: PPUSH
81371: CALL_OW 1
81375: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81376: LD_VAR 0 1
81380: PUSH
81381: LD_EXP 30
81385: PUSH
81386: LD_VAR 0 3
81390: ARRAY
81391: IN
81392: IFFALSE 81431
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81394: LD_ADDR_EXP 30
81398: PUSH
81399: LD_EXP 30
81403: PPUSH
81404: LD_VAR 0 3
81408: PPUSH
81409: LD_EXP 30
81413: PUSH
81414: LD_VAR 0 3
81418: ARRAY
81419: PUSH
81420: LD_VAR 0 1
81424: DIFF
81425: PPUSH
81426: CALL_OW 1
81430: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81431: LD_VAR 0 1
81435: PUSH
81436: LD_EXP 42
81440: PUSH
81441: LD_VAR 0 3
81445: ARRAY
81446: IN
81447: IFFALSE 81486
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81449: LD_ADDR_EXP 42
81453: PUSH
81454: LD_EXP 42
81458: PPUSH
81459: LD_VAR 0 3
81463: PPUSH
81464: LD_EXP 42
81468: PUSH
81469: LD_VAR 0 3
81473: ARRAY
81474: PUSH
81475: LD_VAR 0 1
81479: DIFF
81480: PPUSH
81481: CALL_OW 1
81485: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81486: LD_VAR 0 1
81490: PUSH
81491: LD_EXP 45
81495: PUSH
81496: LD_VAR 0 3
81500: ARRAY
81501: IN
81502: IFFALSE 81541
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81504: LD_ADDR_EXP 45
81508: PUSH
81509: LD_EXP 45
81513: PPUSH
81514: LD_VAR 0 3
81518: PPUSH
81519: LD_EXP 45
81523: PUSH
81524: LD_VAR 0 3
81528: ARRAY
81529: PUSH
81530: LD_VAR 0 1
81534: DIFF
81535: PPUSH
81536: CALL_OW 1
81540: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81541: LD_VAR 0 1
81545: PUSH
81546: LD_EXP 32
81550: PUSH
81551: LD_VAR 0 3
81555: ARRAY
81556: IN
81557: IFFALSE 81596
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81559: LD_ADDR_EXP 32
81563: PUSH
81564: LD_EXP 32
81568: PPUSH
81569: LD_VAR 0 3
81573: PPUSH
81574: LD_EXP 32
81578: PUSH
81579: LD_VAR 0 3
81583: ARRAY
81584: PUSH
81585: LD_VAR 0 1
81589: DIFF
81590: PPUSH
81591: CALL_OW 1
81595: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81596: LD_VAR 0 1
81600: PUSH
81601: LD_EXP 31
81605: PUSH
81606: LD_VAR 0 3
81610: ARRAY
81611: IN
81612: IFFALSE 81651
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81614: LD_ADDR_EXP 31
81618: PUSH
81619: LD_EXP 31
81623: PPUSH
81624: LD_VAR 0 3
81628: PPUSH
81629: LD_EXP 31
81633: PUSH
81634: LD_VAR 0 3
81638: ARRAY
81639: PUSH
81640: LD_VAR 0 1
81644: DIFF
81645: PPUSH
81646: CALL_OW 1
81650: ST_TO_ADDR
// end ; break ;
81651: GO 81655
// end ;
81653: GO 80303
81655: POP
81656: POP
// end ;
81657: LD_VAR 0 2
81661: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81662: LD_INT 0
81664: PPUSH
81665: PPUSH
81666: PPUSH
// if not mc_bases or not skirmish then
81667: LD_EXP 23
81671: NOT
81672: PUSH
81673: LD_EXP 21
81677: NOT
81678: OR
81679: IFFALSE 81683
// exit ;
81681: GO 81898
// for i = 1 to mc_bases do
81683: LD_ADDR_VAR 0 3
81687: PUSH
81688: DOUBLE
81689: LD_INT 1
81691: DEC
81692: ST_TO_ADDR
81693: LD_EXP 23
81697: PUSH
81698: FOR_TO
81699: IFFALSE 81896
// begin if building in mc_construct_list [ i ] then
81701: LD_VAR 0 1
81705: PUSH
81706: LD_EXP 30
81710: PUSH
81711: LD_VAR 0 3
81715: ARRAY
81716: IN
81717: IFFALSE 81894
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81719: LD_ADDR_EXP 30
81723: PUSH
81724: LD_EXP 30
81728: PPUSH
81729: LD_VAR 0 3
81733: PPUSH
81734: LD_EXP 30
81738: PUSH
81739: LD_VAR 0 3
81743: ARRAY
81744: PUSH
81745: LD_VAR 0 1
81749: DIFF
81750: PPUSH
81751: CALL_OW 1
81755: ST_TO_ADDR
// if building in mc_lab [ i ] then
81756: LD_VAR 0 1
81760: PUSH
81761: LD_EXP 56
81765: PUSH
81766: LD_VAR 0 3
81770: ARRAY
81771: IN
81772: IFFALSE 81827
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81774: LD_ADDR_EXP 57
81778: PUSH
81779: LD_EXP 57
81783: PPUSH
81784: LD_VAR 0 3
81788: PPUSH
81789: LD_EXP 57
81793: PUSH
81794: LD_VAR 0 3
81798: ARRAY
81799: PPUSH
81800: LD_INT 1
81802: PPUSH
81803: LD_EXP 57
81807: PUSH
81808: LD_VAR 0 3
81812: ARRAY
81813: PPUSH
81814: LD_INT 0
81816: PPUSH
81817: CALL 15670 0 4
81821: PPUSH
81822: CALL_OW 1
81826: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81827: LD_VAR 0 1
81831: PUSH
81832: LD_EXP 23
81836: PUSH
81837: LD_VAR 0 3
81841: ARRAY
81842: IN
81843: NOT
81844: IFFALSE 81890
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81846: LD_ADDR_EXP 23
81850: PUSH
81851: LD_EXP 23
81855: PPUSH
81856: LD_VAR 0 3
81860: PUSH
81861: LD_EXP 23
81865: PUSH
81866: LD_VAR 0 3
81870: ARRAY
81871: PUSH
81872: LD_INT 1
81874: PLUS
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PPUSH
81880: LD_VAR 0 1
81884: PPUSH
81885: CALL 16252 0 3
81889: ST_TO_ADDR
// exit ;
81890: POP
81891: POP
81892: GO 81898
// end ; end ;
81894: GO 81698
81896: POP
81897: POP
// end ;
81898: LD_VAR 0 2
81902: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81903: LD_INT 0
81905: PPUSH
81906: PPUSH
81907: PPUSH
81908: PPUSH
81909: PPUSH
81910: PPUSH
81911: PPUSH
// if not mc_bases or not skirmish then
81912: LD_EXP 23
81916: NOT
81917: PUSH
81918: LD_EXP 21
81922: NOT
81923: OR
81924: IFFALSE 81928
// exit ;
81926: GO 82589
// for i = 1 to mc_bases do
81928: LD_ADDR_VAR 0 3
81932: PUSH
81933: DOUBLE
81934: LD_INT 1
81936: DEC
81937: ST_TO_ADDR
81938: LD_EXP 23
81942: PUSH
81943: FOR_TO
81944: IFFALSE 82587
// begin if building in mc_construct_list [ i ] then
81946: LD_VAR 0 1
81950: PUSH
81951: LD_EXP 30
81955: PUSH
81956: LD_VAR 0 3
81960: ARRAY
81961: IN
81962: IFFALSE 82585
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81964: LD_ADDR_EXP 30
81968: PUSH
81969: LD_EXP 30
81973: PPUSH
81974: LD_VAR 0 3
81978: PPUSH
81979: LD_EXP 30
81983: PUSH
81984: LD_VAR 0 3
81988: ARRAY
81989: PUSH
81990: LD_VAR 0 1
81994: DIFF
81995: PPUSH
81996: CALL_OW 1
82000: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82001: LD_ADDR_EXP 23
82005: PUSH
82006: LD_EXP 23
82010: PPUSH
82011: LD_VAR 0 3
82015: PUSH
82016: LD_EXP 23
82020: PUSH
82021: LD_VAR 0 3
82025: ARRAY
82026: PUSH
82027: LD_INT 1
82029: PLUS
82030: PUSH
82031: EMPTY
82032: LIST
82033: LIST
82034: PPUSH
82035: LD_VAR 0 1
82039: PPUSH
82040: CALL 16252 0 3
82044: ST_TO_ADDR
// btype := GetBType ( building ) ;
82045: LD_ADDR_VAR 0 5
82049: PUSH
82050: LD_VAR 0 1
82054: PPUSH
82055: CALL_OW 266
82059: ST_TO_ADDR
// side := GetSide ( building ) ;
82060: LD_ADDR_VAR 0 8
82064: PUSH
82065: LD_VAR 0 1
82069: PPUSH
82070: CALL_OW 255
82074: ST_TO_ADDR
// if btype = b_lab then
82075: LD_VAR 0 5
82079: PUSH
82080: LD_INT 6
82082: EQUAL
82083: IFFALSE 82133
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82085: LD_ADDR_EXP 56
82089: PUSH
82090: LD_EXP 56
82094: PPUSH
82095: LD_VAR 0 3
82099: PUSH
82100: LD_EXP 56
82104: PUSH
82105: LD_VAR 0 3
82109: ARRAY
82110: PUSH
82111: LD_INT 1
82113: PLUS
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: PPUSH
82119: LD_VAR 0 1
82123: PPUSH
82124: CALL 16252 0 3
82128: ST_TO_ADDR
// exit ;
82129: POP
82130: POP
82131: GO 82589
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82133: LD_VAR 0 5
82137: PUSH
82138: LD_INT 0
82140: PUSH
82141: LD_INT 2
82143: PUSH
82144: LD_INT 4
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: LIST
82151: IN
82152: IFFALSE 82276
// begin if btype = b_armoury then
82154: LD_VAR 0 5
82158: PUSH
82159: LD_INT 4
82161: EQUAL
82162: IFFALSE 82172
// btype := b_barracks ;
82164: LD_ADDR_VAR 0 5
82168: PUSH
82169: LD_INT 5
82171: ST_TO_ADDR
// if btype = b_depot then
82172: LD_VAR 0 5
82176: PUSH
82177: LD_INT 0
82179: EQUAL
82180: IFFALSE 82190
// btype := b_warehouse ;
82182: LD_ADDR_VAR 0 5
82186: PUSH
82187: LD_INT 1
82189: ST_TO_ADDR
// if btype = b_workshop then
82190: LD_VAR 0 5
82194: PUSH
82195: LD_INT 2
82197: EQUAL
82198: IFFALSE 82208
// btype := b_factory ;
82200: LD_ADDR_VAR 0 5
82204: PUSH
82205: LD_INT 3
82207: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82208: LD_VAR 0 5
82212: PPUSH
82213: LD_VAR 0 8
82217: PPUSH
82218: CALL_OW 323
82222: PUSH
82223: LD_INT 1
82225: EQUAL
82226: IFFALSE 82272
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82228: LD_ADDR_EXP 55
82232: PUSH
82233: LD_EXP 55
82237: PPUSH
82238: LD_VAR 0 3
82242: PUSH
82243: LD_EXP 55
82247: PUSH
82248: LD_VAR 0 3
82252: ARRAY
82253: PUSH
82254: LD_INT 1
82256: PLUS
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PPUSH
82262: LD_VAR 0 1
82266: PPUSH
82267: CALL 16252 0 3
82271: ST_TO_ADDR
// exit ;
82272: POP
82273: POP
82274: GO 82589
// end ; if btype in [ b_bunker , b_turret ] then
82276: LD_VAR 0 5
82280: PUSH
82281: LD_INT 32
82283: PUSH
82284: LD_INT 33
82286: PUSH
82287: EMPTY
82288: LIST
82289: LIST
82290: IN
82291: IFFALSE 82581
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82293: LD_ADDR_EXP 31
82297: PUSH
82298: LD_EXP 31
82302: PPUSH
82303: LD_VAR 0 3
82307: PUSH
82308: LD_EXP 31
82312: PUSH
82313: LD_VAR 0 3
82317: ARRAY
82318: PUSH
82319: LD_INT 1
82321: PLUS
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PPUSH
82327: LD_VAR 0 1
82331: PPUSH
82332: CALL 16252 0 3
82336: ST_TO_ADDR
// if btype = b_bunker then
82337: LD_VAR 0 5
82341: PUSH
82342: LD_INT 32
82344: EQUAL
82345: IFFALSE 82581
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82347: LD_ADDR_EXP 32
82351: PUSH
82352: LD_EXP 32
82356: PPUSH
82357: LD_VAR 0 3
82361: PUSH
82362: LD_EXP 32
82366: PUSH
82367: LD_VAR 0 3
82371: ARRAY
82372: PUSH
82373: LD_INT 1
82375: PLUS
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: PPUSH
82381: LD_VAR 0 1
82385: PPUSH
82386: CALL 16252 0 3
82390: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82391: LD_ADDR_VAR 0 6
82395: PUSH
82396: LD_EXP 23
82400: PUSH
82401: LD_VAR 0 3
82405: ARRAY
82406: PPUSH
82407: LD_INT 25
82409: PUSH
82410: LD_INT 1
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 3
82419: PUSH
82420: LD_INT 54
82422: PUSH
82423: EMPTY
82424: LIST
82425: PUSH
82426: EMPTY
82427: LIST
82428: LIST
82429: PUSH
82430: EMPTY
82431: LIST
82432: LIST
82433: PPUSH
82434: CALL_OW 72
82438: ST_TO_ADDR
// if tmp then
82439: LD_VAR 0 6
82443: IFFALSE 82449
// exit ;
82445: POP
82446: POP
82447: GO 82589
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82449: LD_ADDR_VAR 0 6
82453: PUSH
82454: LD_EXP 23
82458: PUSH
82459: LD_VAR 0 3
82463: ARRAY
82464: PPUSH
82465: LD_INT 2
82467: PUSH
82468: LD_INT 30
82470: PUSH
82471: LD_INT 4
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 30
82480: PUSH
82481: LD_INT 5
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: EMPTY
82489: LIST
82490: LIST
82491: LIST
82492: PPUSH
82493: CALL_OW 72
82497: ST_TO_ADDR
// if not tmp then
82498: LD_VAR 0 6
82502: NOT
82503: IFFALSE 82509
// exit ;
82505: POP
82506: POP
82507: GO 82589
// for j in tmp do
82509: LD_ADDR_VAR 0 4
82513: PUSH
82514: LD_VAR 0 6
82518: PUSH
82519: FOR_IN
82520: IFFALSE 82579
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82522: LD_ADDR_VAR 0 7
82526: PUSH
82527: LD_VAR 0 4
82531: PPUSH
82532: CALL_OW 313
82536: PPUSH
82537: LD_INT 25
82539: PUSH
82540: LD_INT 1
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PPUSH
82547: CALL_OW 72
82551: ST_TO_ADDR
// if units then
82552: LD_VAR 0 7
82556: IFFALSE 82577
// begin ComExitBuilding ( units [ 1 ] ) ;
82558: LD_VAR 0 7
82562: PUSH
82563: LD_INT 1
82565: ARRAY
82566: PPUSH
82567: CALL_OW 122
// exit ;
82571: POP
82572: POP
82573: POP
82574: POP
82575: GO 82589
// end ; end ;
82577: GO 82519
82579: POP
82580: POP
// end ; end ; exit ;
82581: POP
82582: POP
82583: GO 82589
// end ; end ;
82585: GO 81943
82587: POP
82588: POP
// end ;
82589: LD_VAR 0 2
82593: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82594: LD_INT 0
82596: PPUSH
82597: PPUSH
82598: PPUSH
82599: PPUSH
82600: PPUSH
82601: PPUSH
82602: PPUSH
// if not mc_bases or not skirmish then
82603: LD_EXP 23
82607: NOT
82608: PUSH
82609: LD_EXP 21
82613: NOT
82614: OR
82615: IFFALSE 82619
// exit ;
82617: GO 82884
// btype := GetBType ( building ) ;
82619: LD_ADDR_VAR 0 6
82623: PUSH
82624: LD_VAR 0 1
82628: PPUSH
82629: CALL_OW 266
82633: ST_TO_ADDR
// x := GetX ( building ) ;
82634: LD_ADDR_VAR 0 7
82638: PUSH
82639: LD_VAR 0 1
82643: PPUSH
82644: CALL_OW 250
82648: ST_TO_ADDR
// y := GetY ( building ) ;
82649: LD_ADDR_VAR 0 8
82653: PUSH
82654: LD_VAR 0 1
82658: PPUSH
82659: CALL_OW 251
82663: ST_TO_ADDR
// d := GetDir ( building ) ;
82664: LD_ADDR_VAR 0 9
82668: PUSH
82669: LD_VAR 0 1
82673: PPUSH
82674: CALL_OW 254
82678: ST_TO_ADDR
// for i = 1 to mc_bases do
82679: LD_ADDR_VAR 0 4
82683: PUSH
82684: DOUBLE
82685: LD_INT 1
82687: DEC
82688: ST_TO_ADDR
82689: LD_EXP 23
82693: PUSH
82694: FOR_TO
82695: IFFALSE 82882
// begin if not mc_build_list [ i ] then
82697: LD_EXP 28
82701: PUSH
82702: LD_VAR 0 4
82706: ARRAY
82707: NOT
82708: IFFALSE 82712
// continue ;
82710: GO 82694
// for j := 1 to mc_build_list [ i ] do
82712: LD_ADDR_VAR 0 5
82716: PUSH
82717: DOUBLE
82718: LD_INT 1
82720: DEC
82721: ST_TO_ADDR
82722: LD_EXP 28
82726: PUSH
82727: LD_VAR 0 4
82731: ARRAY
82732: PUSH
82733: FOR_TO
82734: IFFALSE 82878
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82736: LD_VAR 0 6
82740: PUSH
82741: LD_VAR 0 7
82745: PUSH
82746: LD_VAR 0 8
82750: PUSH
82751: LD_VAR 0 9
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: LIST
82760: LIST
82761: PPUSH
82762: LD_EXP 28
82766: PUSH
82767: LD_VAR 0 4
82771: ARRAY
82772: PUSH
82773: LD_VAR 0 5
82777: ARRAY
82778: PPUSH
82779: CALL 22432 0 2
82783: IFFALSE 82876
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82785: LD_ADDR_EXP 28
82789: PUSH
82790: LD_EXP 28
82794: PPUSH
82795: LD_VAR 0 4
82799: PPUSH
82800: LD_EXP 28
82804: PUSH
82805: LD_VAR 0 4
82809: ARRAY
82810: PPUSH
82811: LD_VAR 0 5
82815: PPUSH
82816: CALL_OW 3
82820: PPUSH
82821: CALL_OW 1
82825: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82826: LD_ADDR_EXP 30
82830: PUSH
82831: LD_EXP 30
82835: PPUSH
82836: LD_VAR 0 4
82840: PUSH
82841: LD_EXP 30
82845: PUSH
82846: LD_VAR 0 4
82850: ARRAY
82851: PUSH
82852: LD_INT 1
82854: PLUS
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PPUSH
82860: LD_VAR 0 1
82864: PPUSH
82865: CALL 16252 0 3
82869: ST_TO_ADDR
// exit ;
82870: POP
82871: POP
82872: POP
82873: POP
82874: GO 82884
// end ;
82876: GO 82733
82878: POP
82879: POP
// end ;
82880: GO 82694
82882: POP
82883: POP
// end ;
82884: LD_VAR 0 3
82888: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82889: LD_INT 0
82891: PPUSH
82892: PPUSH
82893: PPUSH
// if not mc_bases or not skirmish then
82894: LD_EXP 23
82898: NOT
82899: PUSH
82900: LD_EXP 21
82904: NOT
82905: OR
82906: IFFALSE 82910
// exit ;
82908: GO 83100
// for i = 1 to mc_bases do
82910: LD_ADDR_VAR 0 4
82914: PUSH
82915: DOUBLE
82916: LD_INT 1
82918: DEC
82919: ST_TO_ADDR
82920: LD_EXP 23
82924: PUSH
82925: FOR_TO
82926: IFFALSE 83013
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82928: LD_VAR 0 1
82932: PUSH
82933: LD_EXP 31
82937: PUSH
82938: LD_VAR 0 4
82942: ARRAY
82943: IN
82944: PUSH
82945: LD_VAR 0 1
82949: PUSH
82950: LD_EXP 32
82954: PUSH
82955: LD_VAR 0 4
82959: ARRAY
82960: IN
82961: NOT
82962: AND
82963: IFFALSE 83011
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82965: LD_ADDR_EXP 32
82969: PUSH
82970: LD_EXP 32
82974: PPUSH
82975: LD_VAR 0 4
82979: PUSH
82980: LD_EXP 32
82984: PUSH
82985: LD_VAR 0 4
82989: ARRAY
82990: PUSH
82991: LD_INT 1
82993: PLUS
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PPUSH
82999: LD_VAR 0 1
83003: PPUSH
83004: CALL 16252 0 3
83008: ST_TO_ADDR
// break ;
83009: GO 83013
// end ; end ;
83011: GO 82925
83013: POP
83014: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83015: LD_VAR 0 1
83019: PPUSH
83020: CALL_OW 257
83024: PUSH
83025: LD_EXP 49
83029: IN
83030: PUSH
83031: LD_VAR 0 1
83035: PPUSH
83036: CALL_OW 266
83040: PUSH
83041: LD_INT 5
83043: EQUAL
83044: AND
83045: PUSH
83046: LD_VAR 0 2
83050: PPUSH
83051: CALL_OW 110
83055: PUSH
83056: LD_INT 18
83058: NONEQUAL
83059: AND
83060: IFFALSE 83100
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83062: LD_VAR 0 2
83066: PPUSH
83067: CALL_OW 257
83071: PUSH
83072: LD_INT 5
83074: PUSH
83075: LD_INT 8
83077: PUSH
83078: LD_INT 9
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: LIST
83085: IN
83086: IFFALSE 83100
// SetClass ( unit , 1 ) ;
83088: LD_VAR 0 2
83092: PPUSH
83093: LD_INT 1
83095: PPUSH
83096: CALL_OW 336
// end ;
83100: LD_VAR 0 3
83104: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83105: LD_INT 0
83107: PPUSH
83108: PPUSH
// if not mc_bases or not skirmish then
83109: LD_EXP 23
83113: NOT
83114: PUSH
83115: LD_EXP 21
83119: NOT
83120: OR
83121: IFFALSE 83125
// exit ;
83123: GO 83241
// if GetLives ( abandoned_vehicle ) > 250 then
83125: LD_VAR 0 2
83129: PPUSH
83130: CALL_OW 256
83134: PUSH
83135: LD_INT 250
83137: GREATER
83138: IFFALSE 83142
// exit ;
83140: GO 83241
// for i = 1 to mc_bases do
83142: LD_ADDR_VAR 0 6
83146: PUSH
83147: DOUBLE
83148: LD_INT 1
83150: DEC
83151: ST_TO_ADDR
83152: LD_EXP 23
83156: PUSH
83157: FOR_TO
83158: IFFALSE 83239
// begin if driver in mc_bases [ i ] then
83160: LD_VAR 0 1
83164: PUSH
83165: LD_EXP 23
83169: PUSH
83170: LD_VAR 0 6
83174: ARRAY
83175: IN
83176: IFFALSE 83237
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83178: LD_VAR 0 1
83182: PPUSH
83183: LD_EXP 23
83187: PUSH
83188: LD_VAR 0 6
83192: ARRAY
83193: PPUSH
83194: LD_INT 2
83196: PUSH
83197: LD_INT 30
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 30
83209: PUSH
83210: LD_INT 1
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: LIST
83221: PPUSH
83222: CALL_OW 72
83226: PUSH
83227: LD_INT 1
83229: ARRAY
83230: PPUSH
83231: CALL 49460 0 2
// break ;
83235: GO 83239
// end ; end ;
83237: GO 83157
83239: POP
83240: POP
// end ; end_of_file
83241: LD_VAR 0 5
83245: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83246: LD_INT 0
83248: PPUSH
83249: PPUSH
83250: PPUSH
83251: PPUSH
83252: PPUSH
83253: PPUSH
83254: PPUSH
83255: PPUSH
83256: PPUSH
83257: PPUSH
83258: PPUSH
83259: PPUSH
83260: PPUSH
83261: PPUSH
83262: PPUSH
83263: PPUSH
83264: PPUSH
83265: PPUSH
83266: PPUSH
83267: PPUSH
83268: PPUSH
83269: PPUSH
83270: PPUSH
83271: PPUSH
83272: PPUSH
83273: PPUSH
83274: PPUSH
83275: PPUSH
83276: PPUSH
83277: PPUSH
83278: PPUSH
83279: PPUSH
83280: PPUSH
83281: PPUSH
// if not list then
83282: LD_VAR 0 1
83286: NOT
83287: IFFALSE 83291
// exit ;
83289: GO 87950
// base := list [ 1 ] ;
83291: LD_ADDR_VAR 0 3
83295: PUSH
83296: LD_VAR 0 1
83300: PUSH
83301: LD_INT 1
83303: ARRAY
83304: ST_TO_ADDR
// group := list [ 2 ] ;
83305: LD_ADDR_VAR 0 4
83309: PUSH
83310: LD_VAR 0 1
83314: PUSH
83315: LD_INT 2
83317: ARRAY
83318: ST_TO_ADDR
// path := list [ 3 ] ;
83319: LD_ADDR_VAR 0 5
83323: PUSH
83324: LD_VAR 0 1
83328: PUSH
83329: LD_INT 3
83331: ARRAY
83332: ST_TO_ADDR
// flags := list [ 4 ] ;
83333: LD_ADDR_VAR 0 6
83337: PUSH
83338: LD_VAR 0 1
83342: PUSH
83343: LD_INT 4
83345: ARRAY
83346: ST_TO_ADDR
// mined := [ ] ;
83347: LD_ADDR_VAR 0 27
83351: PUSH
83352: EMPTY
83353: ST_TO_ADDR
// bombed := [ ] ;
83354: LD_ADDR_VAR 0 28
83358: PUSH
83359: EMPTY
83360: ST_TO_ADDR
// healers := [ ] ;
83361: LD_ADDR_VAR 0 31
83365: PUSH
83366: EMPTY
83367: ST_TO_ADDR
// to_heal := [ ] ;
83368: LD_ADDR_VAR 0 30
83372: PUSH
83373: EMPTY
83374: ST_TO_ADDR
// repairs := [ ] ;
83375: LD_ADDR_VAR 0 33
83379: PUSH
83380: EMPTY
83381: ST_TO_ADDR
// to_repair := [ ] ;
83382: LD_ADDR_VAR 0 32
83386: PUSH
83387: EMPTY
83388: ST_TO_ADDR
// if not group or not path then
83389: LD_VAR 0 4
83393: NOT
83394: PUSH
83395: LD_VAR 0 5
83399: NOT
83400: OR
83401: IFFALSE 83405
// exit ;
83403: GO 87950
// side := GetSide ( group [ 1 ] ) ;
83405: LD_ADDR_VAR 0 35
83409: PUSH
83410: LD_VAR 0 4
83414: PUSH
83415: LD_INT 1
83417: ARRAY
83418: PPUSH
83419: CALL_OW 255
83423: ST_TO_ADDR
// if flags then
83424: LD_VAR 0 6
83428: IFFALSE 83572
// begin f_ignore_area := flags [ 1 ] ;
83430: LD_ADDR_VAR 0 17
83434: PUSH
83435: LD_VAR 0 6
83439: PUSH
83440: LD_INT 1
83442: ARRAY
83443: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83444: LD_ADDR_VAR 0 18
83448: PUSH
83449: LD_VAR 0 6
83453: PUSH
83454: LD_INT 2
83456: ARRAY
83457: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83458: LD_ADDR_VAR 0 19
83462: PUSH
83463: LD_VAR 0 6
83467: PUSH
83468: LD_INT 3
83470: ARRAY
83471: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83472: LD_ADDR_VAR 0 20
83476: PUSH
83477: LD_VAR 0 6
83481: PUSH
83482: LD_INT 4
83484: ARRAY
83485: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83486: LD_ADDR_VAR 0 21
83490: PUSH
83491: LD_VAR 0 6
83495: PUSH
83496: LD_INT 5
83498: ARRAY
83499: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83500: LD_ADDR_VAR 0 22
83504: PUSH
83505: LD_VAR 0 6
83509: PUSH
83510: LD_INT 6
83512: ARRAY
83513: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83514: LD_ADDR_VAR 0 23
83518: PUSH
83519: LD_VAR 0 6
83523: PUSH
83524: LD_INT 7
83526: ARRAY
83527: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83528: LD_ADDR_VAR 0 24
83532: PUSH
83533: LD_VAR 0 6
83537: PUSH
83538: LD_INT 8
83540: ARRAY
83541: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83542: LD_ADDR_VAR 0 25
83546: PUSH
83547: LD_VAR 0 6
83551: PUSH
83552: LD_INT 9
83554: ARRAY
83555: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83556: LD_ADDR_VAR 0 26
83560: PUSH
83561: LD_VAR 0 6
83565: PUSH
83566: LD_INT 10
83568: ARRAY
83569: ST_TO_ADDR
// end else
83570: GO 83652
// begin f_ignore_area := false ;
83572: LD_ADDR_VAR 0 17
83576: PUSH
83577: LD_INT 0
83579: ST_TO_ADDR
// f_capture := false ;
83580: LD_ADDR_VAR 0 18
83584: PUSH
83585: LD_INT 0
83587: ST_TO_ADDR
// f_ignore_civ := false ;
83588: LD_ADDR_VAR 0 19
83592: PUSH
83593: LD_INT 0
83595: ST_TO_ADDR
// f_murder := false ;
83596: LD_ADDR_VAR 0 20
83600: PUSH
83601: LD_INT 0
83603: ST_TO_ADDR
// f_mines := false ;
83604: LD_ADDR_VAR 0 21
83608: PUSH
83609: LD_INT 0
83611: ST_TO_ADDR
// f_repair := false ;
83612: LD_ADDR_VAR 0 22
83616: PUSH
83617: LD_INT 0
83619: ST_TO_ADDR
// f_heal := false ;
83620: LD_ADDR_VAR 0 23
83624: PUSH
83625: LD_INT 0
83627: ST_TO_ADDR
// f_spacetime := false ;
83628: LD_ADDR_VAR 0 24
83632: PUSH
83633: LD_INT 0
83635: ST_TO_ADDR
// f_attack_depot := false ;
83636: LD_ADDR_VAR 0 25
83640: PUSH
83641: LD_INT 0
83643: ST_TO_ADDR
// f_crawl := false ;
83644: LD_ADDR_VAR 0 26
83648: PUSH
83649: LD_INT 0
83651: ST_TO_ADDR
// end ; if f_heal then
83652: LD_VAR 0 23
83656: IFFALSE 83683
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83658: LD_ADDR_VAR 0 31
83662: PUSH
83663: LD_VAR 0 4
83667: PPUSH
83668: LD_INT 25
83670: PUSH
83671: LD_INT 4
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: PPUSH
83678: CALL_OW 72
83682: ST_TO_ADDR
// if f_repair then
83683: LD_VAR 0 22
83687: IFFALSE 83714
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83689: LD_ADDR_VAR 0 33
83693: PUSH
83694: LD_VAR 0 4
83698: PPUSH
83699: LD_INT 25
83701: PUSH
83702: LD_INT 3
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PPUSH
83709: CALL_OW 72
83713: ST_TO_ADDR
// units_path := [ ] ;
83714: LD_ADDR_VAR 0 16
83718: PUSH
83719: EMPTY
83720: ST_TO_ADDR
// for i = 1 to group do
83721: LD_ADDR_VAR 0 7
83725: PUSH
83726: DOUBLE
83727: LD_INT 1
83729: DEC
83730: ST_TO_ADDR
83731: LD_VAR 0 4
83735: PUSH
83736: FOR_TO
83737: IFFALSE 83766
// units_path := Replace ( units_path , i , path ) ;
83739: LD_ADDR_VAR 0 16
83743: PUSH
83744: LD_VAR 0 16
83748: PPUSH
83749: LD_VAR 0 7
83753: PPUSH
83754: LD_VAR 0 5
83758: PPUSH
83759: CALL_OW 1
83763: ST_TO_ADDR
83764: GO 83736
83766: POP
83767: POP
// repeat for i = group downto 1 do
83768: LD_ADDR_VAR 0 7
83772: PUSH
83773: DOUBLE
83774: LD_VAR 0 4
83778: INC
83779: ST_TO_ADDR
83780: LD_INT 1
83782: PUSH
83783: FOR_DOWNTO
83784: IFFALSE 87906
// begin wait ( 5 ) ;
83786: LD_INT 5
83788: PPUSH
83789: CALL_OW 67
// tmp := [ ] ;
83793: LD_ADDR_VAR 0 14
83797: PUSH
83798: EMPTY
83799: ST_TO_ADDR
// attacking := false ;
83800: LD_ADDR_VAR 0 29
83804: PUSH
83805: LD_INT 0
83807: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83808: LD_VAR 0 4
83812: PUSH
83813: LD_VAR 0 7
83817: ARRAY
83818: PPUSH
83819: CALL_OW 301
83823: PUSH
83824: LD_VAR 0 4
83828: PUSH
83829: LD_VAR 0 7
83833: ARRAY
83834: NOT
83835: OR
83836: IFFALSE 83945
// begin if GetType ( group [ i ] ) = unit_human then
83838: LD_VAR 0 4
83842: PUSH
83843: LD_VAR 0 7
83847: ARRAY
83848: PPUSH
83849: CALL_OW 247
83853: PUSH
83854: LD_INT 1
83856: EQUAL
83857: IFFALSE 83903
// begin to_heal := to_heal diff group [ i ] ;
83859: LD_ADDR_VAR 0 30
83863: PUSH
83864: LD_VAR 0 30
83868: PUSH
83869: LD_VAR 0 4
83873: PUSH
83874: LD_VAR 0 7
83878: ARRAY
83879: DIFF
83880: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83881: LD_ADDR_VAR 0 31
83885: PUSH
83886: LD_VAR 0 31
83890: PUSH
83891: LD_VAR 0 4
83895: PUSH
83896: LD_VAR 0 7
83900: ARRAY
83901: DIFF
83902: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83903: LD_ADDR_VAR 0 4
83907: PUSH
83908: LD_VAR 0 4
83912: PPUSH
83913: LD_VAR 0 7
83917: PPUSH
83918: CALL_OW 3
83922: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83923: LD_ADDR_VAR 0 16
83927: PUSH
83928: LD_VAR 0 16
83932: PPUSH
83933: LD_VAR 0 7
83937: PPUSH
83938: CALL_OW 3
83942: ST_TO_ADDR
// continue ;
83943: GO 83783
// end ; if f_repair then
83945: LD_VAR 0 22
83949: IFFALSE 84438
// begin if GetType ( group [ i ] ) = unit_vehicle then
83951: LD_VAR 0 4
83955: PUSH
83956: LD_VAR 0 7
83960: ARRAY
83961: PPUSH
83962: CALL_OW 247
83966: PUSH
83967: LD_INT 2
83969: EQUAL
83970: IFFALSE 84160
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83972: LD_VAR 0 4
83976: PUSH
83977: LD_VAR 0 7
83981: ARRAY
83982: PPUSH
83983: CALL_OW 256
83987: PUSH
83988: LD_INT 700
83990: LESS
83991: PUSH
83992: LD_VAR 0 4
83996: PUSH
83997: LD_VAR 0 7
84001: ARRAY
84002: PUSH
84003: LD_VAR 0 32
84007: IN
84008: NOT
84009: AND
84010: IFFALSE 84034
// to_repair := to_repair union group [ i ] ;
84012: LD_ADDR_VAR 0 32
84016: PUSH
84017: LD_VAR 0 32
84021: PUSH
84022: LD_VAR 0 4
84026: PUSH
84027: LD_VAR 0 7
84031: ARRAY
84032: UNION
84033: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
84034: LD_VAR 0 4
84038: PUSH
84039: LD_VAR 0 7
84043: ARRAY
84044: PPUSH
84045: CALL_OW 256
84049: PUSH
84050: LD_INT 1000
84052: EQUAL
84053: PUSH
84054: LD_VAR 0 4
84058: PUSH
84059: LD_VAR 0 7
84063: ARRAY
84064: PUSH
84065: LD_VAR 0 32
84069: IN
84070: AND
84071: IFFALSE 84095
// to_repair := to_repair diff group [ i ] ;
84073: LD_ADDR_VAR 0 32
84077: PUSH
84078: LD_VAR 0 32
84082: PUSH
84083: LD_VAR 0 4
84087: PUSH
84088: LD_VAR 0 7
84092: ARRAY
84093: DIFF
84094: ST_TO_ADDR
// if group [ i ] in to_repair then
84095: LD_VAR 0 4
84099: PUSH
84100: LD_VAR 0 7
84104: ARRAY
84105: PUSH
84106: LD_VAR 0 32
84110: IN
84111: IFFALSE 84158
// begin if not IsInArea ( group [ i ] , f_repair ) then
84113: LD_VAR 0 4
84117: PUSH
84118: LD_VAR 0 7
84122: ARRAY
84123: PPUSH
84124: LD_VAR 0 22
84128: PPUSH
84129: CALL_OW 308
84133: NOT
84134: IFFALSE 84156
// ComMoveToArea ( group [ i ] , f_repair ) ;
84136: LD_VAR 0 4
84140: PUSH
84141: LD_VAR 0 7
84145: ARRAY
84146: PPUSH
84147: LD_VAR 0 22
84151: PPUSH
84152: CALL_OW 113
// continue ;
84156: GO 83783
// end ; end else
84158: GO 84438
// if group [ i ] in repairs then
84160: LD_VAR 0 4
84164: PUSH
84165: LD_VAR 0 7
84169: ARRAY
84170: PUSH
84171: LD_VAR 0 33
84175: IN
84176: IFFALSE 84438
// begin if IsInUnit ( group [ i ] ) then
84178: LD_VAR 0 4
84182: PUSH
84183: LD_VAR 0 7
84187: ARRAY
84188: PPUSH
84189: CALL_OW 310
84193: IFFALSE 84261
// begin z := IsInUnit ( group [ i ] ) ;
84195: LD_ADDR_VAR 0 13
84199: PUSH
84200: LD_VAR 0 4
84204: PUSH
84205: LD_VAR 0 7
84209: ARRAY
84210: PPUSH
84211: CALL_OW 310
84215: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84216: LD_VAR 0 13
84220: PUSH
84221: LD_VAR 0 32
84225: IN
84226: PUSH
84227: LD_VAR 0 13
84231: PPUSH
84232: LD_VAR 0 22
84236: PPUSH
84237: CALL_OW 308
84241: AND
84242: IFFALSE 84259
// ComExitVehicle ( group [ i ] ) ;
84244: LD_VAR 0 4
84248: PUSH
84249: LD_VAR 0 7
84253: ARRAY
84254: PPUSH
84255: CALL_OW 121
// end else
84259: GO 84438
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84261: LD_ADDR_VAR 0 13
84265: PUSH
84266: LD_VAR 0 4
84270: PPUSH
84271: LD_INT 95
84273: PUSH
84274: LD_VAR 0 22
84278: PUSH
84279: EMPTY
84280: LIST
84281: LIST
84282: PUSH
84283: LD_INT 58
84285: PUSH
84286: EMPTY
84287: LIST
84288: PUSH
84289: EMPTY
84290: LIST
84291: LIST
84292: PPUSH
84293: CALL_OW 72
84297: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84298: LD_VAR 0 4
84302: PUSH
84303: LD_VAR 0 7
84307: ARRAY
84308: PPUSH
84309: CALL_OW 314
84313: NOT
84314: IFFALSE 84436
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84316: LD_ADDR_VAR 0 10
84320: PUSH
84321: LD_VAR 0 13
84325: PPUSH
84326: LD_VAR 0 4
84330: PUSH
84331: LD_VAR 0 7
84335: ARRAY
84336: PPUSH
84337: CALL_OW 74
84341: ST_TO_ADDR
// if not x then
84342: LD_VAR 0 10
84346: NOT
84347: IFFALSE 84351
// continue ;
84349: GO 83783
// if GetLives ( x ) < 1000 then
84351: LD_VAR 0 10
84355: PPUSH
84356: CALL_OW 256
84360: PUSH
84361: LD_INT 1000
84363: LESS
84364: IFFALSE 84388
// ComRepairVehicle ( group [ i ] , x ) else
84366: LD_VAR 0 4
84370: PUSH
84371: LD_VAR 0 7
84375: ARRAY
84376: PPUSH
84377: LD_VAR 0 10
84381: PPUSH
84382: CALL_OW 129
84386: GO 84436
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84388: LD_VAR 0 23
84392: PUSH
84393: LD_VAR 0 4
84397: PUSH
84398: LD_VAR 0 7
84402: ARRAY
84403: PPUSH
84404: CALL_OW 256
84408: PUSH
84409: LD_INT 1000
84411: LESS
84412: AND
84413: NOT
84414: IFFALSE 84436
// ComEnterUnit ( group [ i ] , x ) ;
84416: LD_VAR 0 4
84420: PUSH
84421: LD_VAR 0 7
84425: ARRAY
84426: PPUSH
84427: LD_VAR 0 10
84431: PPUSH
84432: CALL_OW 120
// end ; continue ;
84436: GO 83783
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84438: LD_VAR 0 23
84442: PUSH
84443: LD_VAR 0 4
84447: PUSH
84448: LD_VAR 0 7
84452: ARRAY
84453: PPUSH
84454: CALL_OW 247
84458: PUSH
84459: LD_INT 1
84461: EQUAL
84462: AND
84463: IFFALSE 84941
// begin if group [ i ] in healers then
84465: LD_VAR 0 4
84469: PUSH
84470: LD_VAR 0 7
84474: ARRAY
84475: PUSH
84476: LD_VAR 0 31
84480: IN
84481: IFFALSE 84754
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84483: LD_VAR 0 4
84487: PUSH
84488: LD_VAR 0 7
84492: ARRAY
84493: PPUSH
84494: LD_VAR 0 23
84498: PPUSH
84499: CALL_OW 308
84503: NOT
84504: PUSH
84505: LD_VAR 0 4
84509: PUSH
84510: LD_VAR 0 7
84514: ARRAY
84515: PPUSH
84516: CALL_OW 314
84520: NOT
84521: AND
84522: IFFALSE 84546
// ComMoveToArea ( group [ i ] , f_heal ) else
84524: LD_VAR 0 4
84528: PUSH
84529: LD_VAR 0 7
84533: ARRAY
84534: PPUSH
84535: LD_VAR 0 23
84539: PPUSH
84540: CALL_OW 113
84544: GO 84752
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84546: LD_VAR 0 4
84550: PUSH
84551: LD_VAR 0 7
84555: ARRAY
84556: PPUSH
84557: CALL 45975 0 1
84561: PPUSH
84562: CALL_OW 256
84566: PUSH
84567: LD_INT 1000
84569: EQUAL
84570: IFFALSE 84589
// ComStop ( group [ i ] ) else
84572: LD_VAR 0 4
84576: PUSH
84577: LD_VAR 0 7
84581: ARRAY
84582: PPUSH
84583: CALL_OW 141
84587: GO 84752
// if not HasTask ( group [ i ] ) and to_heal then
84589: LD_VAR 0 4
84593: PUSH
84594: LD_VAR 0 7
84598: ARRAY
84599: PPUSH
84600: CALL_OW 314
84604: NOT
84605: PUSH
84606: LD_VAR 0 30
84610: AND
84611: IFFALSE 84752
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84613: LD_ADDR_VAR 0 13
84617: PUSH
84618: LD_VAR 0 30
84622: PPUSH
84623: LD_INT 3
84625: PUSH
84626: LD_INT 54
84628: PUSH
84629: EMPTY
84630: LIST
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PPUSH
84636: CALL_OW 72
84640: PPUSH
84641: LD_VAR 0 4
84645: PUSH
84646: LD_VAR 0 7
84650: ARRAY
84651: PPUSH
84652: CALL_OW 74
84656: ST_TO_ADDR
// if z then
84657: LD_VAR 0 13
84661: IFFALSE 84752
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84663: LD_INT 91
84665: PUSH
84666: LD_VAR 0 13
84670: PUSH
84671: LD_INT 10
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 81
84681: PUSH
84682: LD_VAR 0 13
84686: PPUSH
84687: CALL_OW 255
84691: PUSH
84692: EMPTY
84693: LIST
84694: LIST
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PPUSH
84700: CALL_OW 69
84704: PUSH
84705: LD_INT 0
84707: EQUAL
84708: IFFALSE 84732
// ComHeal ( group [ i ] , z ) else
84710: LD_VAR 0 4
84714: PUSH
84715: LD_VAR 0 7
84719: ARRAY
84720: PPUSH
84721: LD_VAR 0 13
84725: PPUSH
84726: CALL_OW 128
84730: GO 84752
// ComMoveToArea ( group [ i ] , f_heal ) ;
84732: LD_VAR 0 4
84736: PUSH
84737: LD_VAR 0 7
84741: ARRAY
84742: PPUSH
84743: LD_VAR 0 23
84747: PPUSH
84748: CALL_OW 113
// end ; continue ;
84752: GO 83783
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84754: LD_VAR 0 4
84758: PUSH
84759: LD_VAR 0 7
84763: ARRAY
84764: PPUSH
84765: CALL_OW 256
84769: PUSH
84770: LD_INT 700
84772: LESS
84773: PUSH
84774: LD_VAR 0 4
84778: PUSH
84779: LD_VAR 0 7
84783: ARRAY
84784: PUSH
84785: LD_VAR 0 30
84789: IN
84790: NOT
84791: AND
84792: IFFALSE 84816
// to_heal := to_heal union group [ i ] ;
84794: LD_ADDR_VAR 0 30
84798: PUSH
84799: LD_VAR 0 30
84803: PUSH
84804: LD_VAR 0 4
84808: PUSH
84809: LD_VAR 0 7
84813: ARRAY
84814: UNION
84815: ST_TO_ADDR
// if group [ i ] in to_heal then
84816: LD_VAR 0 4
84820: PUSH
84821: LD_VAR 0 7
84825: ARRAY
84826: PUSH
84827: LD_VAR 0 30
84831: IN
84832: IFFALSE 84941
// begin if GetLives ( group [ i ] ) = 1000 then
84834: LD_VAR 0 4
84838: PUSH
84839: LD_VAR 0 7
84843: ARRAY
84844: PPUSH
84845: CALL_OW 256
84849: PUSH
84850: LD_INT 1000
84852: EQUAL
84853: IFFALSE 84879
// to_heal := to_heal diff group [ i ] else
84855: LD_ADDR_VAR 0 30
84859: PUSH
84860: LD_VAR 0 30
84864: PUSH
84865: LD_VAR 0 4
84869: PUSH
84870: LD_VAR 0 7
84874: ARRAY
84875: DIFF
84876: ST_TO_ADDR
84877: GO 84941
// begin if not IsInArea ( group [ i ] , to_heal ) then
84879: LD_VAR 0 4
84883: PUSH
84884: LD_VAR 0 7
84888: ARRAY
84889: PPUSH
84890: LD_VAR 0 30
84894: PPUSH
84895: CALL_OW 308
84899: NOT
84900: IFFALSE 84924
// ComMoveToArea ( group [ i ] , f_heal ) else
84902: LD_VAR 0 4
84906: PUSH
84907: LD_VAR 0 7
84911: ARRAY
84912: PPUSH
84913: LD_VAR 0 23
84917: PPUSH
84918: CALL_OW 113
84922: GO 84939
// ComHold ( group [ i ] ) ;
84924: LD_VAR 0 4
84928: PUSH
84929: LD_VAR 0 7
84933: ARRAY
84934: PPUSH
84935: CALL_OW 140
// continue ;
84939: GO 83783
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84941: LD_VAR 0 4
84945: PUSH
84946: LD_VAR 0 7
84950: ARRAY
84951: PPUSH
84952: LD_INT 10
84954: PPUSH
84955: CALL 43746 0 2
84959: NOT
84960: PUSH
84961: LD_VAR 0 16
84965: PUSH
84966: LD_VAR 0 7
84970: ARRAY
84971: PUSH
84972: EMPTY
84973: EQUAL
84974: NOT
84975: AND
84976: IFFALSE 85242
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84978: LD_VAR 0 4
84982: PUSH
84983: LD_VAR 0 7
84987: ARRAY
84988: PPUSH
84989: CALL_OW 262
84993: PUSH
84994: LD_INT 1
84996: PUSH
84997: LD_INT 2
84999: PUSH
85000: EMPTY
85001: LIST
85002: LIST
85003: IN
85004: IFFALSE 85045
// if GetFuel ( group [ i ] ) < 10 then
85006: LD_VAR 0 4
85010: PUSH
85011: LD_VAR 0 7
85015: ARRAY
85016: PPUSH
85017: CALL_OW 261
85021: PUSH
85022: LD_INT 10
85024: LESS
85025: IFFALSE 85045
// SetFuel ( group [ i ] , 12 ) ;
85027: LD_VAR 0 4
85031: PUSH
85032: LD_VAR 0 7
85036: ARRAY
85037: PPUSH
85038: LD_INT 12
85040: PPUSH
85041: CALL_OW 240
// if units_path [ i ] then
85045: LD_VAR 0 16
85049: PUSH
85050: LD_VAR 0 7
85054: ARRAY
85055: IFFALSE 85240
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
85057: LD_VAR 0 4
85061: PUSH
85062: LD_VAR 0 7
85066: ARRAY
85067: PPUSH
85068: LD_VAR 0 16
85072: PUSH
85073: LD_VAR 0 7
85077: ARRAY
85078: PUSH
85079: LD_INT 1
85081: ARRAY
85082: PUSH
85083: LD_INT 1
85085: ARRAY
85086: PPUSH
85087: LD_VAR 0 16
85091: PUSH
85092: LD_VAR 0 7
85096: ARRAY
85097: PUSH
85098: LD_INT 1
85100: ARRAY
85101: PUSH
85102: LD_INT 2
85104: ARRAY
85105: PPUSH
85106: CALL_OW 297
85110: PUSH
85111: LD_INT 6
85113: GREATER
85114: IFFALSE 85189
// begin if not HasTask ( group [ i ] ) then
85116: LD_VAR 0 4
85120: PUSH
85121: LD_VAR 0 7
85125: ARRAY
85126: PPUSH
85127: CALL_OW 314
85131: NOT
85132: IFFALSE 85187
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
85134: LD_VAR 0 4
85138: PUSH
85139: LD_VAR 0 7
85143: ARRAY
85144: PPUSH
85145: LD_VAR 0 16
85149: PUSH
85150: LD_VAR 0 7
85154: ARRAY
85155: PUSH
85156: LD_INT 1
85158: ARRAY
85159: PUSH
85160: LD_INT 1
85162: ARRAY
85163: PPUSH
85164: LD_VAR 0 16
85168: PUSH
85169: LD_VAR 0 7
85173: ARRAY
85174: PUSH
85175: LD_INT 1
85177: ARRAY
85178: PUSH
85179: LD_INT 2
85181: ARRAY
85182: PPUSH
85183: CALL_OW 114
// end else
85187: GO 85240
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
85189: LD_ADDR_VAR 0 15
85193: PUSH
85194: LD_VAR 0 16
85198: PUSH
85199: LD_VAR 0 7
85203: ARRAY
85204: PPUSH
85205: LD_INT 1
85207: PPUSH
85208: CALL_OW 3
85212: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
85213: LD_ADDR_VAR 0 16
85217: PUSH
85218: LD_VAR 0 16
85222: PPUSH
85223: LD_VAR 0 7
85227: PPUSH
85228: LD_VAR 0 15
85232: PPUSH
85233: CALL_OW 1
85237: ST_TO_ADDR
// continue ;
85238: GO 83783
// end ; end ; end else
85240: GO 87904
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85242: LD_ADDR_VAR 0 14
85246: PUSH
85247: LD_INT 81
85249: PUSH
85250: LD_VAR 0 4
85254: PUSH
85255: LD_VAR 0 7
85259: ARRAY
85260: PPUSH
85261: CALL_OW 255
85265: PUSH
85266: EMPTY
85267: LIST
85268: LIST
85269: PPUSH
85270: CALL_OW 69
85274: ST_TO_ADDR
// if not tmp then
85275: LD_VAR 0 14
85279: NOT
85280: IFFALSE 85284
// continue ;
85282: GO 83783
// if f_ignore_area then
85284: LD_VAR 0 17
85288: IFFALSE 85376
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85290: LD_ADDR_VAR 0 15
85294: PUSH
85295: LD_VAR 0 14
85299: PPUSH
85300: LD_INT 3
85302: PUSH
85303: LD_INT 92
85305: PUSH
85306: LD_VAR 0 17
85310: PUSH
85311: LD_INT 1
85313: ARRAY
85314: PUSH
85315: LD_VAR 0 17
85319: PUSH
85320: LD_INT 2
85322: ARRAY
85323: PUSH
85324: LD_VAR 0 17
85328: PUSH
85329: LD_INT 3
85331: ARRAY
85332: PUSH
85333: EMPTY
85334: LIST
85335: LIST
85336: LIST
85337: LIST
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PPUSH
85343: CALL_OW 72
85347: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85348: LD_VAR 0 14
85352: PUSH
85353: LD_VAR 0 15
85357: DIFF
85358: IFFALSE 85376
// tmp := tmp diff tmp2 ;
85360: LD_ADDR_VAR 0 14
85364: PUSH
85365: LD_VAR 0 14
85369: PUSH
85370: LD_VAR 0 15
85374: DIFF
85375: ST_TO_ADDR
// end ; if not f_murder then
85376: LD_VAR 0 20
85380: NOT
85381: IFFALSE 85439
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85383: LD_ADDR_VAR 0 15
85387: PUSH
85388: LD_VAR 0 14
85392: PPUSH
85393: LD_INT 3
85395: PUSH
85396: LD_INT 50
85398: PUSH
85399: EMPTY
85400: LIST
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PPUSH
85406: CALL_OW 72
85410: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85411: LD_VAR 0 14
85415: PUSH
85416: LD_VAR 0 15
85420: DIFF
85421: IFFALSE 85439
// tmp := tmp diff tmp2 ;
85423: LD_ADDR_VAR 0 14
85427: PUSH
85428: LD_VAR 0 14
85432: PUSH
85433: LD_VAR 0 15
85437: DIFF
85438: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85439: LD_ADDR_VAR 0 14
85443: PUSH
85444: LD_VAR 0 4
85448: PUSH
85449: LD_VAR 0 7
85453: ARRAY
85454: PPUSH
85455: LD_VAR 0 14
85459: PPUSH
85460: LD_INT 1
85462: PPUSH
85463: LD_INT 1
85465: PPUSH
85466: CALL 16687 0 4
85470: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85471: LD_VAR 0 4
85475: PUSH
85476: LD_VAR 0 7
85480: ARRAY
85481: PPUSH
85482: CALL_OW 257
85486: PUSH
85487: LD_INT 1
85489: EQUAL
85490: IFFALSE 85938
// begin if WantPlant ( group [ i ] ) then
85492: LD_VAR 0 4
85496: PUSH
85497: LD_VAR 0 7
85501: ARRAY
85502: PPUSH
85503: CALL 16188 0 1
85507: IFFALSE 85511
// continue ;
85509: GO 83783
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85511: LD_VAR 0 18
85515: PUSH
85516: LD_VAR 0 4
85520: PUSH
85521: LD_VAR 0 7
85525: ARRAY
85526: PPUSH
85527: CALL_OW 310
85531: NOT
85532: AND
85533: PUSH
85534: LD_VAR 0 14
85538: PUSH
85539: LD_INT 1
85541: ARRAY
85542: PUSH
85543: LD_VAR 0 14
85547: PPUSH
85548: LD_INT 21
85550: PUSH
85551: LD_INT 2
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 58
85560: PUSH
85561: EMPTY
85562: LIST
85563: PUSH
85564: EMPTY
85565: LIST
85566: LIST
85567: PPUSH
85568: CALL_OW 72
85572: IN
85573: AND
85574: IFFALSE 85610
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85576: LD_VAR 0 4
85580: PUSH
85581: LD_VAR 0 7
85585: ARRAY
85586: PPUSH
85587: LD_VAR 0 14
85591: PUSH
85592: LD_INT 1
85594: ARRAY
85595: PPUSH
85596: CALL_OW 120
// attacking := true ;
85600: LD_ADDR_VAR 0 29
85604: PUSH
85605: LD_INT 1
85607: ST_TO_ADDR
// continue ;
85608: GO 83783
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85610: LD_VAR 0 26
85614: PUSH
85615: LD_VAR 0 4
85619: PUSH
85620: LD_VAR 0 7
85624: ARRAY
85625: PPUSH
85626: CALL_OW 257
85630: PUSH
85631: LD_INT 1
85633: EQUAL
85634: AND
85635: PUSH
85636: LD_VAR 0 4
85640: PUSH
85641: LD_VAR 0 7
85645: ARRAY
85646: PPUSH
85647: CALL_OW 256
85651: PUSH
85652: LD_INT 800
85654: LESS
85655: AND
85656: PUSH
85657: LD_VAR 0 4
85661: PUSH
85662: LD_VAR 0 7
85666: ARRAY
85667: PPUSH
85668: CALL_OW 318
85672: NOT
85673: AND
85674: IFFALSE 85691
// ComCrawl ( group [ i ] ) ;
85676: LD_VAR 0 4
85680: PUSH
85681: LD_VAR 0 7
85685: ARRAY
85686: PPUSH
85687: CALL_OW 137
// if f_mines then
85691: LD_VAR 0 21
85695: IFFALSE 85938
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85697: LD_VAR 0 14
85701: PUSH
85702: LD_INT 1
85704: ARRAY
85705: PPUSH
85706: CALL_OW 247
85710: PUSH
85711: LD_INT 3
85713: EQUAL
85714: PUSH
85715: LD_VAR 0 14
85719: PUSH
85720: LD_INT 1
85722: ARRAY
85723: PUSH
85724: LD_VAR 0 27
85728: IN
85729: NOT
85730: AND
85731: IFFALSE 85938
// begin x := GetX ( tmp [ 1 ] ) ;
85733: LD_ADDR_VAR 0 10
85737: PUSH
85738: LD_VAR 0 14
85742: PUSH
85743: LD_INT 1
85745: ARRAY
85746: PPUSH
85747: CALL_OW 250
85751: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85752: LD_ADDR_VAR 0 11
85756: PUSH
85757: LD_VAR 0 14
85761: PUSH
85762: LD_INT 1
85764: ARRAY
85765: PPUSH
85766: CALL_OW 251
85770: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85771: LD_ADDR_VAR 0 12
85775: PUSH
85776: LD_VAR 0 4
85780: PUSH
85781: LD_VAR 0 7
85785: ARRAY
85786: PPUSH
85787: CALL 43831 0 1
85791: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85792: LD_VAR 0 4
85796: PUSH
85797: LD_VAR 0 7
85801: ARRAY
85802: PPUSH
85803: LD_VAR 0 10
85807: PPUSH
85808: LD_VAR 0 11
85812: PPUSH
85813: LD_VAR 0 14
85817: PUSH
85818: LD_INT 1
85820: ARRAY
85821: PPUSH
85822: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85826: LD_VAR 0 4
85830: PUSH
85831: LD_VAR 0 7
85835: ARRAY
85836: PPUSH
85837: LD_VAR 0 10
85841: PPUSH
85842: LD_VAR 0 12
85846: PPUSH
85847: LD_INT 7
85849: PPUSH
85850: CALL_OW 272
85854: PPUSH
85855: LD_VAR 0 11
85859: PPUSH
85860: LD_VAR 0 12
85864: PPUSH
85865: LD_INT 7
85867: PPUSH
85868: CALL_OW 273
85872: PPUSH
85873: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85877: LD_VAR 0 4
85881: PUSH
85882: LD_VAR 0 7
85886: ARRAY
85887: PPUSH
85888: LD_INT 71
85890: PPUSH
85891: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85895: LD_ADDR_VAR 0 27
85899: PUSH
85900: LD_VAR 0 27
85904: PPUSH
85905: LD_VAR 0 27
85909: PUSH
85910: LD_INT 1
85912: PLUS
85913: PPUSH
85914: LD_VAR 0 14
85918: PUSH
85919: LD_INT 1
85921: ARRAY
85922: PPUSH
85923: CALL_OW 1
85927: ST_TO_ADDR
// attacking := true ;
85928: LD_ADDR_VAR 0 29
85932: PUSH
85933: LD_INT 1
85935: ST_TO_ADDR
// continue ;
85936: GO 83783
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85938: LD_VAR 0 4
85942: PUSH
85943: LD_VAR 0 7
85947: ARRAY
85948: PPUSH
85949: CALL_OW 257
85953: PUSH
85954: LD_INT 17
85956: EQUAL
85957: PUSH
85958: LD_VAR 0 4
85962: PUSH
85963: LD_VAR 0 7
85967: ARRAY
85968: PPUSH
85969: CALL_OW 110
85973: PUSH
85974: LD_INT 71
85976: EQUAL
85977: NOT
85978: AND
85979: IFFALSE 86125
// begin attacking := false ;
85981: LD_ADDR_VAR 0 29
85985: PUSH
85986: LD_INT 0
85988: ST_TO_ADDR
// k := 5 ;
85989: LD_ADDR_VAR 0 9
85993: PUSH
85994: LD_INT 5
85996: ST_TO_ADDR
// if tmp < k then
85997: LD_VAR 0 14
86001: PUSH
86002: LD_VAR 0 9
86006: LESS
86007: IFFALSE 86019
// k := tmp ;
86009: LD_ADDR_VAR 0 9
86013: PUSH
86014: LD_VAR 0 14
86018: ST_TO_ADDR
// for j = 1 to k do
86019: LD_ADDR_VAR 0 8
86023: PUSH
86024: DOUBLE
86025: LD_INT 1
86027: DEC
86028: ST_TO_ADDR
86029: LD_VAR 0 9
86033: PUSH
86034: FOR_TO
86035: IFFALSE 86123
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
86037: LD_VAR 0 14
86041: PUSH
86042: LD_VAR 0 8
86046: ARRAY
86047: PUSH
86048: LD_VAR 0 14
86052: PPUSH
86053: LD_INT 58
86055: PUSH
86056: EMPTY
86057: LIST
86058: PPUSH
86059: CALL_OW 72
86063: IN
86064: NOT
86065: IFFALSE 86121
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86067: LD_VAR 0 4
86071: PUSH
86072: LD_VAR 0 7
86076: ARRAY
86077: PPUSH
86078: LD_VAR 0 14
86082: PUSH
86083: LD_VAR 0 8
86087: ARRAY
86088: PPUSH
86089: CALL_OW 115
// attacking := true ;
86093: LD_ADDR_VAR 0 29
86097: PUSH
86098: LD_INT 1
86100: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
86101: LD_VAR 0 4
86105: PUSH
86106: LD_VAR 0 7
86110: ARRAY
86111: PPUSH
86112: LD_INT 71
86114: PPUSH
86115: CALL_OW 109
// continue ;
86119: GO 86034
// end ; end ;
86121: GO 86034
86123: POP
86124: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
86125: LD_VAR 0 4
86129: PUSH
86130: LD_VAR 0 7
86134: ARRAY
86135: PPUSH
86136: CALL_OW 257
86140: PUSH
86141: LD_INT 8
86143: EQUAL
86144: PUSH
86145: LD_VAR 0 4
86149: PUSH
86150: LD_VAR 0 7
86154: ARRAY
86155: PPUSH
86156: CALL_OW 264
86160: PUSH
86161: LD_INT 28
86163: PUSH
86164: LD_INT 45
86166: PUSH
86167: LD_INT 7
86169: PUSH
86170: LD_INT 47
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: IN
86179: OR
86180: IFFALSE 86436
// begin attacking := false ;
86182: LD_ADDR_VAR 0 29
86186: PUSH
86187: LD_INT 0
86189: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
86190: LD_VAR 0 14
86194: PUSH
86195: LD_INT 1
86197: ARRAY
86198: PPUSH
86199: CALL_OW 266
86203: PUSH
86204: LD_INT 32
86206: PUSH
86207: LD_INT 31
86209: PUSH
86210: LD_INT 33
86212: PUSH
86213: LD_INT 4
86215: PUSH
86216: LD_INT 5
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: IN
86226: IFFALSE 86412
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86228: LD_ADDR_VAR 0 9
86232: PUSH
86233: LD_VAR 0 14
86237: PUSH
86238: LD_INT 1
86240: ARRAY
86241: PPUSH
86242: CALL_OW 266
86246: PPUSH
86247: LD_VAR 0 14
86251: PUSH
86252: LD_INT 1
86254: ARRAY
86255: PPUSH
86256: CALL_OW 250
86260: PPUSH
86261: LD_VAR 0 14
86265: PUSH
86266: LD_INT 1
86268: ARRAY
86269: PPUSH
86270: CALL_OW 251
86274: PPUSH
86275: LD_VAR 0 14
86279: PUSH
86280: LD_INT 1
86282: ARRAY
86283: PPUSH
86284: CALL_OW 254
86288: PPUSH
86289: LD_VAR 0 14
86293: PUSH
86294: LD_INT 1
86296: ARRAY
86297: PPUSH
86298: CALL_OW 248
86302: PPUSH
86303: LD_INT 0
86305: PPUSH
86306: CALL 25201 0 6
86310: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86311: LD_ADDR_VAR 0 8
86315: PUSH
86316: LD_VAR 0 4
86320: PUSH
86321: LD_VAR 0 7
86325: ARRAY
86326: PPUSH
86327: LD_VAR 0 9
86331: PPUSH
86332: CALL 43944 0 2
86336: ST_TO_ADDR
// if j then
86337: LD_VAR 0 8
86341: IFFALSE 86410
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86343: LD_VAR 0 8
86347: PUSH
86348: LD_INT 1
86350: ARRAY
86351: PPUSH
86352: LD_VAR 0 8
86356: PUSH
86357: LD_INT 2
86359: ARRAY
86360: PPUSH
86361: CALL_OW 488
86365: IFFALSE 86410
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86367: LD_VAR 0 4
86371: PUSH
86372: LD_VAR 0 7
86376: ARRAY
86377: PPUSH
86378: LD_VAR 0 8
86382: PUSH
86383: LD_INT 1
86385: ARRAY
86386: PPUSH
86387: LD_VAR 0 8
86391: PUSH
86392: LD_INT 2
86394: ARRAY
86395: PPUSH
86396: CALL_OW 116
// attacking := true ;
86400: LD_ADDR_VAR 0 29
86404: PUSH
86405: LD_INT 1
86407: ST_TO_ADDR
// continue ;
86408: GO 83783
// end ; end else
86410: GO 86436
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86412: LD_VAR 0 4
86416: PUSH
86417: LD_VAR 0 7
86421: ARRAY
86422: PPUSH
86423: LD_VAR 0 14
86427: PUSH
86428: LD_INT 1
86430: ARRAY
86431: PPUSH
86432: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86436: LD_VAR 0 4
86440: PUSH
86441: LD_VAR 0 7
86445: ARRAY
86446: PPUSH
86447: CALL_OW 265
86451: PUSH
86452: LD_INT 11
86454: EQUAL
86455: IFFALSE 86733
// begin k := 10 ;
86457: LD_ADDR_VAR 0 9
86461: PUSH
86462: LD_INT 10
86464: ST_TO_ADDR
// x := 0 ;
86465: LD_ADDR_VAR 0 10
86469: PUSH
86470: LD_INT 0
86472: ST_TO_ADDR
// if tmp < k then
86473: LD_VAR 0 14
86477: PUSH
86478: LD_VAR 0 9
86482: LESS
86483: IFFALSE 86495
// k := tmp ;
86485: LD_ADDR_VAR 0 9
86489: PUSH
86490: LD_VAR 0 14
86494: ST_TO_ADDR
// for j = k downto 1 do
86495: LD_ADDR_VAR 0 8
86499: PUSH
86500: DOUBLE
86501: LD_VAR 0 9
86505: INC
86506: ST_TO_ADDR
86507: LD_INT 1
86509: PUSH
86510: FOR_DOWNTO
86511: IFFALSE 86586
// begin if GetType ( tmp [ j ] ) = unit_human then
86513: LD_VAR 0 14
86517: PUSH
86518: LD_VAR 0 8
86522: ARRAY
86523: PPUSH
86524: CALL_OW 247
86528: PUSH
86529: LD_INT 1
86531: EQUAL
86532: IFFALSE 86584
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86534: LD_VAR 0 4
86538: PUSH
86539: LD_VAR 0 7
86543: ARRAY
86544: PPUSH
86545: LD_VAR 0 14
86549: PUSH
86550: LD_VAR 0 8
86554: ARRAY
86555: PPUSH
86556: CALL 44198 0 2
// x := tmp [ j ] ;
86560: LD_ADDR_VAR 0 10
86564: PUSH
86565: LD_VAR 0 14
86569: PUSH
86570: LD_VAR 0 8
86574: ARRAY
86575: ST_TO_ADDR
// attacking := true ;
86576: LD_ADDR_VAR 0 29
86580: PUSH
86581: LD_INT 1
86583: ST_TO_ADDR
// end ; end ;
86584: GO 86510
86586: POP
86587: POP
// if not x then
86588: LD_VAR 0 10
86592: NOT
86593: IFFALSE 86733
// begin attacking := true ;
86595: LD_ADDR_VAR 0 29
86599: PUSH
86600: LD_INT 1
86602: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86603: LD_VAR 0 4
86607: PUSH
86608: LD_VAR 0 7
86612: ARRAY
86613: PPUSH
86614: CALL_OW 250
86618: PPUSH
86619: LD_VAR 0 4
86623: PUSH
86624: LD_VAR 0 7
86628: ARRAY
86629: PPUSH
86630: CALL_OW 251
86634: PPUSH
86635: CALL_OW 546
86639: PUSH
86640: LD_INT 2
86642: ARRAY
86643: PUSH
86644: LD_VAR 0 14
86648: PUSH
86649: LD_INT 1
86651: ARRAY
86652: PPUSH
86653: CALL_OW 250
86657: PPUSH
86658: LD_VAR 0 14
86662: PUSH
86663: LD_INT 1
86665: ARRAY
86666: PPUSH
86667: CALL_OW 251
86671: PPUSH
86672: CALL_OW 546
86676: PUSH
86677: LD_INT 2
86679: ARRAY
86680: EQUAL
86681: IFFALSE 86709
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86683: LD_VAR 0 4
86687: PUSH
86688: LD_VAR 0 7
86692: ARRAY
86693: PPUSH
86694: LD_VAR 0 14
86698: PUSH
86699: LD_INT 1
86701: ARRAY
86702: PPUSH
86703: CALL 44198 0 2
86707: GO 86733
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86709: LD_VAR 0 4
86713: PUSH
86714: LD_VAR 0 7
86718: ARRAY
86719: PPUSH
86720: LD_VAR 0 14
86724: PUSH
86725: LD_INT 1
86727: ARRAY
86728: PPUSH
86729: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86733: LD_VAR 0 4
86737: PUSH
86738: LD_VAR 0 7
86742: ARRAY
86743: PPUSH
86744: CALL_OW 264
86748: PUSH
86749: LD_INT 29
86751: EQUAL
86752: IFFALSE 87118
// begin if WantsToAttack ( group [ i ] ) in bombed then
86754: LD_VAR 0 4
86758: PUSH
86759: LD_VAR 0 7
86763: ARRAY
86764: PPUSH
86765: CALL_OW 319
86769: PUSH
86770: LD_VAR 0 28
86774: IN
86775: IFFALSE 86779
// continue ;
86777: GO 83783
// k := 8 ;
86779: LD_ADDR_VAR 0 9
86783: PUSH
86784: LD_INT 8
86786: ST_TO_ADDR
// x := 0 ;
86787: LD_ADDR_VAR 0 10
86791: PUSH
86792: LD_INT 0
86794: ST_TO_ADDR
// if tmp < k then
86795: LD_VAR 0 14
86799: PUSH
86800: LD_VAR 0 9
86804: LESS
86805: IFFALSE 86817
// k := tmp ;
86807: LD_ADDR_VAR 0 9
86811: PUSH
86812: LD_VAR 0 14
86816: ST_TO_ADDR
// for j = 1 to k do
86817: LD_ADDR_VAR 0 8
86821: PUSH
86822: DOUBLE
86823: LD_INT 1
86825: DEC
86826: ST_TO_ADDR
86827: LD_VAR 0 9
86831: PUSH
86832: FOR_TO
86833: IFFALSE 86965
// begin if GetType ( tmp [ j ] ) = unit_building then
86835: LD_VAR 0 14
86839: PUSH
86840: LD_VAR 0 8
86844: ARRAY
86845: PPUSH
86846: CALL_OW 247
86850: PUSH
86851: LD_INT 3
86853: EQUAL
86854: IFFALSE 86963
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86856: LD_VAR 0 14
86860: PUSH
86861: LD_VAR 0 8
86865: ARRAY
86866: PUSH
86867: LD_VAR 0 28
86871: IN
86872: NOT
86873: PUSH
86874: LD_VAR 0 14
86878: PUSH
86879: LD_VAR 0 8
86883: ARRAY
86884: PPUSH
86885: CALL_OW 313
86889: AND
86890: IFFALSE 86963
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86892: LD_VAR 0 4
86896: PUSH
86897: LD_VAR 0 7
86901: ARRAY
86902: PPUSH
86903: LD_VAR 0 14
86907: PUSH
86908: LD_VAR 0 8
86912: ARRAY
86913: PPUSH
86914: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86918: LD_ADDR_VAR 0 28
86922: PUSH
86923: LD_VAR 0 28
86927: PPUSH
86928: LD_VAR 0 28
86932: PUSH
86933: LD_INT 1
86935: PLUS
86936: PPUSH
86937: LD_VAR 0 14
86941: PUSH
86942: LD_VAR 0 8
86946: ARRAY
86947: PPUSH
86948: CALL_OW 1
86952: ST_TO_ADDR
// attacking := true ;
86953: LD_ADDR_VAR 0 29
86957: PUSH
86958: LD_INT 1
86960: ST_TO_ADDR
// break ;
86961: GO 86965
// end ; end ;
86963: GO 86832
86965: POP
86966: POP
// if not attacking and f_attack_depot then
86967: LD_VAR 0 29
86971: NOT
86972: PUSH
86973: LD_VAR 0 25
86977: AND
86978: IFFALSE 87073
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86980: LD_ADDR_VAR 0 13
86984: PUSH
86985: LD_VAR 0 14
86989: PPUSH
86990: LD_INT 2
86992: PUSH
86993: LD_INT 30
86995: PUSH
86996: LD_INT 0
86998: PUSH
86999: EMPTY
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 30
87005: PUSH
87006: LD_INT 1
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: LIST
87017: PPUSH
87018: CALL_OW 72
87022: ST_TO_ADDR
// if z then
87023: LD_VAR 0 13
87027: IFFALSE 87073
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
87029: LD_VAR 0 4
87033: PUSH
87034: LD_VAR 0 7
87038: ARRAY
87039: PPUSH
87040: LD_VAR 0 13
87044: PPUSH
87045: LD_VAR 0 4
87049: PUSH
87050: LD_VAR 0 7
87054: ARRAY
87055: PPUSH
87056: CALL_OW 74
87060: PPUSH
87061: CALL_OW 115
// attacking := true ;
87065: LD_ADDR_VAR 0 29
87069: PUSH
87070: LD_INT 1
87072: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
87073: LD_VAR 0 4
87077: PUSH
87078: LD_VAR 0 7
87082: ARRAY
87083: PPUSH
87084: CALL_OW 256
87088: PUSH
87089: LD_INT 500
87091: LESS
87092: IFFALSE 87118
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87094: LD_VAR 0 4
87098: PUSH
87099: LD_VAR 0 7
87103: ARRAY
87104: PPUSH
87105: LD_VAR 0 14
87109: PUSH
87110: LD_INT 1
87112: ARRAY
87113: PPUSH
87114: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
87118: LD_VAR 0 4
87122: PUSH
87123: LD_VAR 0 7
87127: ARRAY
87128: PPUSH
87129: CALL_OW 264
87133: PUSH
87134: LD_INT 49
87136: EQUAL
87137: IFFALSE 87258
// begin if not HasTask ( group [ i ] ) then
87139: LD_VAR 0 4
87143: PUSH
87144: LD_VAR 0 7
87148: ARRAY
87149: PPUSH
87150: CALL_OW 314
87154: NOT
87155: IFFALSE 87258
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
87157: LD_ADDR_VAR 0 9
87161: PUSH
87162: LD_INT 81
87164: PUSH
87165: LD_VAR 0 4
87169: PUSH
87170: LD_VAR 0 7
87174: ARRAY
87175: PPUSH
87176: CALL_OW 255
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PPUSH
87185: CALL_OW 69
87189: PPUSH
87190: LD_VAR 0 4
87194: PUSH
87195: LD_VAR 0 7
87199: ARRAY
87200: PPUSH
87201: CALL_OW 74
87205: ST_TO_ADDR
// if k then
87206: LD_VAR 0 9
87210: IFFALSE 87258
// if GetDistUnits ( group [ i ] , k ) > 10 then
87212: LD_VAR 0 4
87216: PUSH
87217: LD_VAR 0 7
87221: ARRAY
87222: PPUSH
87223: LD_VAR 0 9
87227: PPUSH
87228: CALL_OW 296
87232: PUSH
87233: LD_INT 10
87235: GREATER
87236: IFFALSE 87258
// ComMoveUnit ( group [ i ] , k ) ;
87238: LD_VAR 0 4
87242: PUSH
87243: LD_VAR 0 7
87247: ARRAY
87248: PPUSH
87249: LD_VAR 0 9
87253: PPUSH
87254: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87258: LD_VAR 0 4
87262: PUSH
87263: LD_VAR 0 7
87267: ARRAY
87268: PPUSH
87269: CALL_OW 256
87273: PUSH
87274: LD_INT 250
87276: LESS
87277: PUSH
87278: LD_VAR 0 4
87282: PUSH
87283: LD_VAR 0 7
87287: ARRAY
87288: PUSH
87289: LD_INT 21
87291: PUSH
87292: LD_INT 2
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 23
87301: PUSH
87302: LD_INT 2
87304: PUSH
87305: EMPTY
87306: LIST
87307: LIST
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PPUSH
87313: CALL_OW 69
87317: IN
87318: AND
87319: IFFALSE 87444
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87321: LD_ADDR_VAR 0 9
87325: PUSH
87326: LD_OWVAR 3
87330: PUSH
87331: LD_VAR 0 4
87335: PUSH
87336: LD_VAR 0 7
87340: ARRAY
87341: DIFF
87342: PPUSH
87343: LD_VAR 0 4
87347: PUSH
87348: LD_VAR 0 7
87352: ARRAY
87353: PPUSH
87354: CALL_OW 74
87358: ST_TO_ADDR
// if not k then
87359: LD_VAR 0 9
87363: NOT
87364: IFFALSE 87368
// continue ;
87366: GO 83783
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87368: LD_VAR 0 9
87372: PUSH
87373: LD_INT 81
87375: PUSH
87376: LD_VAR 0 4
87380: PUSH
87381: LD_VAR 0 7
87385: ARRAY
87386: PPUSH
87387: CALL_OW 255
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PPUSH
87396: CALL_OW 69
87400: IN
87401: PUSH
87402: LD_VAR 0 9
87406: PPUSH
87407: LD_VAR 0 4
87411: PUSH
87412: LD_VAR 0 7
87416: ARRAY
87417: PPUSH
87418: CALL_OW 296
87422: PUSH
87423: LD_INT 5
87425: LESS
87426: AND
87427: IFFALSE 87444
// ComAutodestruct ( group [ i ] ) ;
87429: LD_VAR 0 4
87433: PUSH
87434: LD_VAR 0 7
87438: ARRAY
87439: PPUSH
87440: CALL 44096 0 1
// end ; if f_attack_depot then
87444: LD_VAR 0 25
87448: IFFALSE 87560
// begin k := 6 ;
87450: LD_ADDR_VAR 0 9
87454: PUSH
87455: LD_INT 6
87457: ST_TO_ADDR
// if tmp < k then
87458: LD_VAR 0 14
87462: PUSH
87463: LD_VAR 0 9
87467: LESS
87468: IFFALSE 87480
// k := tmp ;
87470: LD_ADDR_VAR 0 9
87474: PUSH
87475: LD_VAR 0 14
87479: ST_TO_ADDR
// for j = 1 to k do
87480: LD_ADDR_VAR 0 8
87484: PUSH
87485: DOUBLE
87486: LD_INT 1
87488: DEC
87489: ST_TO_ADDR
87490: LD_VAR 0 9
87494: PUSH
87495: FOR_TO
87496: IFFALSE 87558
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87498: LD_VAR 0 8
87502: PPUSH
87503: CALL_OW 266
87507: PUSH
87508: LD_INT 0
87510: PUSH
87511: LD_INT 1
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: IN
87518: IFFALSE 87556
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87520: LD_VAR 0 4
87524: PUSH
87525: LD_VAR 0 7
87529: ARRAY
87530: PPUSH
87531: LD_VAR 0 14
87535: PUSH
87536: LD_VAR 0 8
87540: ARRAY
87541: PPUSH
87542: CALL_OW 115
// attacking := true ;
87546: LD_ADDR_VAR 0 29
87550: PUSH
87551: LD_INT 1
87553: ST_TO_ADDR
// break ;
87554: GO 87558
// end ;
87556: GO 87495
87558: POP
87559: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87560: LD_VAR 0 4
87564: PUSH
87565: LD_VAR 0 7
87569: ARRAY
87570: PPUSH
87571: CALL_OW 302
87575: PUSH
87576: LD_VAR 0 29
87580: NOT
87581: AND
87582: IFFALSE 87904
// begin if GetTag ( group [ i ] ) = 71 then
87584: LD_VAR 0 4
87588: PUSH
87589: LD_VAR 0 7
87593: ARRAY
87594: PPUSH
87595: CALL_OW 110
87599: PUSH
87600: LD_INT 71
87602: EQUAL
87603: IFFALSE 87644
// begin if HasTask ( group [ i ] ) then
87605: LD_VAR 0 4
87609: PUSH
87610: LD_VAR 0 7
87614: ARRAY
87615: PPUSH
87616: CALL_OW 314
87620: IFFALSE 87626
// continue else
87622: GO 83783
87624: GO 87644
// SetTag ( group [ i ] , 0 ) ;
87626: LD_VAR 0 4
87630: PUSH
87631: LD_VAR 0 7
87635: ARRAY
87636: PPUSH
87637: LD_INT 0
87639: PPUSH
87640: CALL_OW 109
// end ; k := 8 ;
87644: LD_ADDR_VAR 0 9
87648: PUSH
87649: LD_INT 8
87651: ST_TO_ADDR
// x := 0 ;
87652: LD_ADDR_VAR 0 10
87656: PUSH
87657: LD_INT 0
87659: ST_TO_ADDR
// if tmp < k then
87660: LD_VAR 0 14
87664: PUSH
87665: LD_VAR 0 9
87669: LESS
87670: IFFALSE 87682
// k := tmp ;
87672: LD_ADDR_VAR 0 9
87676: PUSH
87677: LD_VAR 0 14
87681: ST_TO_ADDR
// for j = 1 to k do
87682: LD_ADDR_VAR 0 8
87686: PUSH
87687: DOUBLE
87688: LD_INT 1
87690: DEC
87691: ST_TO_ADDR
87692: LD_VAR 0 9
87696: PUSH
87697: FOR_TO
87698: IFFALSE 87796
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87700: LD_VAR 0 14
87704: PUSH
87705: LD_VAR 0 8
87709: ARRAY
87710: PPUSH
87711: CALL_OW 247
87715: PUSH
87716: LD_INT 1
87718: EQUAL
87719: PUSH
87720: LD_VAR 0 14
87724: PUSH
87725: LD_VAR 0 8
87729: ARRAY
87730: PPUSH
87731: CALL_OW 256
87735: PUSH
87736: LD_INT 250
87738: LESS
87739: PUSH
87740: LD_VAR 0 20
87744: AND
87745: PUSH
87746: LD_VAR 0 20
87750: NOT
87751: PUSH
87752: LD_VAR 0 14
87756: PUSH
87757: LD_VAR 0 8
87761: ARRAY
87762: PPUSH
87763: CALL_OW 256
87767: PUSH
87768: LD_INT 250
87770: GREATEREQUAL
87771: AND
87772: OR
87773: AND
87774: IFFALSE 87794
// begin x := tmp [ j ] ;
87776: LD_ADDR_VAR 0 10
87780: PUSH
87781: LD_VAR 0 14
87785: PUSH
87786: LD_VAR 0 8
87790: ARRAY
87791: ST_TO_ADDR
// break ;
87792: GO 87796
// end ;
87794: GO 87697
87796: POP
87797: POP
// if x then
87798: LD_VAR 0 10
87802: IFFALSE 87826
// ComAttackUnit ( group [ i ] , x ) else
87804: LD_VAR 0 4
87808: PUSH
87809: LD_VAR 0 7
87813: ARRAY
87814: PPUSH
87815: LD_VAR 0 10
87819: PPUSH
87820: CALL_OW 115
87824: GO 87850
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87826: LD_VAR 0 4
87830: PUSH
87831: LD_VAR 0 7
87835: ARRAY
87836: PPUSH
87837: LD_VAR 0 14
87841: PUSH
87842: LD_INT 1
87844: ARRAY
87845: PPUSH
87846: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87850: LD_VAR 0 4
87854: PUSH
87855: LD_VAR 0 7
87859: ARRAY
87860: PPUSH
87861: CALL_OW 314
87865: NOT
87866: IFFALSE 87904
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87868: LD_VAR 0 4
87872: PUSH
87873: LD_VAR 0 7
87877: ARRAY
87878: PPUSH
87879: LD_VAR 0 14
87883: PPUSH
87884: LD_VAR 0 4
87888: PUSH
87889: LD_VAR 0 7
87893: ARRAY
87894: PPUSH
87895: CALL_OW 74
87899: PPUSH
87900: CALL_OW 115
// end ; end ; end ;
87904: GO 83783
87906: POP
87907: POP
// wait ( 0 0$2 ) ;
87908: LD_INT 70
87910: PPUSH
87911: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87915: LD_VAR 0 4
87919: NOT
87920: PUSH
87921: LD_VAR 0 4
87925: PUSH
87926: EMPTY
87927: EQUAL
87928: OR
87929: PUSH
87930: LD_INT 81
87932: PUSH
87933: LD_VAR 0 35
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PPUSH
87942: CALL_OW 69
87946: NOT
87947: OR
87948: IFFALSE 83768
// end ;
87950: LD_VAR 0 2
87954: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87955: LD_INT 0
87957: PPUSH
87958: PPUSH
87959: PPUSH
87960: PPUSH
87961: PPUSH
87962: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87963: LD_VAR 0 1
87967: NOT
87968: PUSH
87969: LD_EXP 23
87973: PUSH
87974: LD_VAR 0 1
87978: ARRAY
87979: NOT
87980: OR
87981: PUSH
87982: LD_VAR 0 2
87986: NOT
87987: OR
87988: IFFALSE 87992
// exit ;
87990: GO 88546
// side := mc_sides [ base ] ;
87992: LD_ADDR_VAR 0 6
87996: PUSH
87997: LD_EXP 49
88001: PUSH
88002: LD_VAR 0 1
88006: ARRAY
88007: ST_TO_ADDR
// if not side then
88008: LD_VAR 0 6
88012: NOT
88013: IFFALSE 88017
// exit ;
88015: GO 88546
// for i in solds do
88017: LD_ADDR_VAR 0 7
88021: PUSH
88022: LD_VAR 0 2
88026: PUSH
88027: FOR_IN
88028: IFFALSE 88089
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
88030: LD_VAR 0 7
88034: PPUSH
88035: CALL_OW 310
88039: PPUSH
88040: CALL_OW 266
88044: PUSH
88045: LD_INT 32
88047: PUSH
88048: LD_INT 31
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: IN
88055: IFFALSE 88075
// solds := solds diff i else
88057: LD_ADDR_VAR 0 2
88061: PUSH
88062: LD_VAR 0 2
88066: PUSH
88067: LD_VAR 0 7
88071: DIFF
88072: ST_TO_ADDR
88073: GO 88087
// SetTag ( i , 18 ) ;
88075: LD_VAR 0 7
88079: PPUSH
88080: LD_INT 18
88082: PPUSH
88083: CALL_OW 109
88087: GO 88027
88089: POP
88090: POP
// if not solds then
88091: LD_VAR 0 2
88095: NOT
88096: IFFALSE 88100
// exit ;
88098: GO 88546
// repeat wait ( 0 0$2 ) ;
88100: LD_INT 70
88102: PPUSH
88103: CALL_OW 67
// enemy := mc_scan [ base ] ;
88107: LD_ADDR_VAR 0 4
88111: PUSH
88112: LD_EXP 46
88116: PUSH
88117: LD_VAR 0 1
88121: ARRAY
88122: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88123: LD_EXP 23
88127: PUSH
88128: LD_VAR 0 1
88132: ARRAY
88133: NOT
88134: PUSH
88135: LD_EXP 23
88139: PUSH
88140: LD_VAR 0 1
88144: ARRAY
88145: PUSH
88146: EMPTY
88147: EQUAL
88148: OR
88149: IFFALSE 88186
// begin for i in solds do
88151: LD_ADDR_VAR 0 7
88155: PUSH
88156: LD_VAR 0 2
88160: PUSH
88161: FOR_IN
88162: IFFALSE 88175
// ComStop ( i ) ;
88164: LD_VAR 0 7
88168: PPUSH
88169: CALL_OW 141
88173: GO 88161
88175: POP
88176: POP
// solds := [ ] ;
88177: LD_ADDR_VAR 0 2
88181: PUSH
88182: EMPTY
88183: ST_TO_ADDR
// exit ;
88184: GO 88546
// end ; for i in solds do
88186: LD_ADDR_VAR 0 7
88190: PUSH
88191: LD_VAR 0 2
88195: PUSH
88196: FOR_IN
88197: IFFALSE 88518
// begin if IsInUnit ( i ) then
88199: LD_VAR 0 7
88203: PPUSH
88204: CALL_OW 310
88208: IFFALSE 88219
// ComExitBuilding ( i ) ;
88210: LD_VAR 0 7
88214: PPUSH
88215: CALL_OW 122
// if GetLives ( i ) > 500 then
88219: LD_VAR 0 7
88223: PPUSH
88224: CALL_OW 256
88228: PUSH
88229: LD_INT 500
88231: GREATER
88232: IFFALSE 88285
// begin e := NearestUnitToUnit ( enemy , i ) ;
88234: LD_ADDR_VAR 0 5
88238: PUSH
88239: LD_VAR 0 4
88243: PPUSH
88244: LD_VAR 0 7
88248: PPUSH
88249: CALL_OW 74
88253: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88254: LD_VAR 0 7
88258: PPUSH
88259: LD_VAR 0 5
88263: PPUSH
88264: CALL_OW 250
88268: PPUSH
88269: LD_VAR 0 5
88273: PPUSH
88274: CALL_OW 251
88278: PPUSH
88279: CALL_OW 114
// end else
88283: GO 88516
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88285: LD_VAR 0 7
88289: PPUSH
88290: LD_EXP 23
88294: PUSH
88295: LD_VAR 0 1
88299: ARRAY
88300: PPUSH
88301: LD_INT 2
88303: PUSH
88304: LD_INT 30
88306: PUSH
88307: LD_INT 0
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 30
88316: PUSH
88317: LD_INT 1
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 30
88326: PUSH
88327: LD_INT 6
88329: PUSH
88330: EMPTY
88331: LIST
88332: LIST
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: PPUSH
88340: CALL_OW 72
88344: PPUSH
88345: LD_VAR 0 7
88349: PPUSH
88350: CALL_OW 74
88354: PPUSH
88355: CALL_OW 296
88359: PUSH
88360: LD_INT 10
88362: GREATER
88363: IFFALSE 88516
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88365: LD_ADDR_VAR 0 8
88369: PUSH
88370: LD_EXP 23
88374: PUSH
88375: LD_VAR 0 1
88379: ARRAY
88380: PPUSH
88381: LD_INT 2
88383: PUSH
88384: LD_INT 30
88386: PUSH
88387: LD_INT 0
88389: PUSH
88390: EMPTY
88391: LIST
88392: LIST
88393: PUSH
88394: LD_INT 30
88396: PUSH
88397: LD_INT 1
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 30
88406: PUSH
88407: LD_INT 6
88409: PUSH
88410: EMPTY
88411: LIST
88412: LIST
88413: PUSH
88414: EMPTY
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: PPUSH
88420: CALL_OW 72
88424: PPUSH
88425: LD_VAR 0 7
88429: PPUSH
88430: CALL_OW 74
88434: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88435: LD_VAR 0 7
88439: PPUSH
88440: LD_VAR 0 8
88444: PPUSH
88445: CALL_OW 250
88449: PPUSH
88450: LD_INT 3
88452: PPUSH
88453: LD_INT 5
88455: PPUSH
88456: CALL_OW 272
88460: PPUSH
88461: LD_VAR 0 8
88465: PPUSH
88466: CALL_OW 251
88470: PPUSH
88471: LD_INT 3
88473: PPUSH
88474: LD_INT 5
88476: PPUSH
88477: CALL_OW 273
88481: PPUSH
88482: CALL_OW 111
// SetTag ( i , 0 ) ;
88486: LD_VAR 0 7
88490: PPUSH
88491: LD_INT 0
88493: PPUSH
88494: CALL_OW 109
// solds := solds diff i ;
88498: LD_ADDR_VAR 0 2
88502: PUSH
88503: LD_VAR 0 2
88507: PUSH
88508: LD_VAR 0 7
88512: DIFF
88513: ST_TO_ADDR
// continue ;
88514: GO 88196
// end ; end ;
88516: GO 88196
88518: POP
88519: POP
// until not solds or not enemy ;
88520: LD_VAR 0 2
88524: NOT
88525: PUSH
88526: LD_VAR 0 4
88530: NOT
88531: OR
88532: IFFALSE 88100
// MC_Reset ( base , 18 ) ;
88534: LD_VAR 0 1
88538: PPUSH
88539: LD_INT 18
88541: PPUSH
88542: CALL 56705 0 2
// end ;
88546: LD_VAR 0 3
88550: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88551: LD_INT 0
88553: PPUSH
88554: PPUSH
88555: PPUSH
88556: PPUSH
88557: PPUSH
88558: PPUSH
88559: PPUSH
88560: PPUSH
88561: PPUSH
88562: PPUSH
88563: PPUSH
88564: PPUSH
88565: PPUSH
88566: PPUSH
88567: PPUSH
88568: PPUSH
88569: PPUSH
88570: PPUSH
88571: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88572: LD_ADDR_VAR 0 12
88576: PUSH
88577: LD_EXP 23
88581: PUSH
88582: LD_VAR 0 1
88586: ARRAY
88587: PPUSH
88588: LD_INT 25
88590: PUSH
88591: LD_INT 3
88593: PUSH
88594: EMPTY
88595: LIST
88596: LIST
88597: PPUSH
88598: CALL_OW 72
88602: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88603: LD_EXP 63
88607: PUSH
88608: LD_VAR 0 1
88612: ARRAY
88613: IFFALSE 88637
// mechs := mechs diff mc_remote_driver [ base ] ;
88615: LD_ADDR_VAR 0 12
88619: PUSH
88620: LD_VAR 0 12
88624: PUSH
88625: LD_EXP 63
88629: PUSH
88630: LD_VAR 0 1
88634: ARRAY
88635: DIFF
88636: ST_TO_ADDR
// for i in mechs do
88637: LD_ADDR_VAR 0 4
88641: PUSH
88642: LD_VAR 0 12
88646: PUSH
88647: FOR_IN
88648: IFFALSE 88683
// if GetTag ( i ) > 0 then
88650: LD_VAR 0 4
88654: PPUSH
88655: CALL_OW 110
88659: PUSH
88660: LD_INT 0
88662: GREATER
88663: IFFALSE 88681
// mechs := mechs diff i ;
88665: LD_ADDR_VAR 0 12
88669: PUSH
88670: LD_VAR 0 12
88674: PUSH
88675: LD_VAR 0 4
88679: DIFF
88680: ST_TO_ADDR
88681: GO 88647
88683: POP
88684: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88685: LD_ADDR_VAR 0 8
88689: PUSH
88690: LD_EXP 23
88694: PUSH
88695: LD_VAR 0 1
88699: ARRAY
88700: PPUSH
88701: LD_INT 2
88703: PUSH
88704: LD_INT 25
88706: PUSH
88707: LD_INT 1
88709: PUSH
88710: EMPTY
88711: LIST
88712: LIST
88713: PUSH
88714: LD_INT 25
88716: PUSH
88717: LD_INT 5
88719: PUSH
88720: EMPTY
88721: LIST
88722: LIST
88723: PUSH
88724: LD_INT 25
88726: PUSH
88727: LD_INT 8
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: PUSH
88734: LD_INT 25
88736: PUSH
88737: LD_INT 9
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: PUSH
88744: EMPTY
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: PPUSH
88751: CALL_OW 72
88755: ST_TO_ADDR
// if not defenders and not solds then
88756: LD_VAR 0 2
88760: NOT
88761: PUSH
88762: LD_VAR 0 8
88766: NOT
88767: AND
88768: IFFALSE 88772
// exit ;
88770: GO 90542
// depot_under_attack := false ;
88772: LD_ADDR_VAR 0 16
88776: PUSH
88777: LD_INT 0
88779: ST_TO_ADDR
// sold_defenders := [ ] ;
88780: LD_ADDR_VAR 0 17
88784: PUSH
88785: EMPTY
88786: ST_TO_ADDR
// if mechs then
88787: LD_VAR 0 12
88791: IFFALSE 88944
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88793: LD_ADDR_VAR 0 4
88797: PUSH
88798: LD_VAR 0 2
88802: PPUSH
88803: LD_INT 21
88805: PUSH
88806: LD_INT 2
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PPUSH
88813: CALL_OW 72
88817: PUSH
88818: FOR_IN
88819: IFFALSE 88942
// begin if GetTag ( i ) <> 20 then
88821: LD_VAR 0 4
88825: PPUSH
88826: CALL_OW 110
88830: PUSH
88831: LD_INT 20
88833: NONEQUAL
88834: IFFALSE 88848
// SetTag ( i , 20 ) ;
88836: LD_VAR 0 4
88840: PPUSH
88841: LD_INT 20
88843: PPUSH
88844: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88848: LD_VAR 0 4
88852: PPUSH
88853: CALL_OW 263
88857: PUSH
88858: LD_INT 1
88860: EQUAL
88861: PUSH
88862: LD_VAR 0 4
88866: PPUSH
88867: CALL_OW 311
88871: NOT
88872: AND
88873: IFFALSE 88940
// begin un := mechs [ 1 ] ;
88875: LD_ADDR_VAR 0 10
88879: PUSH
88880: LD_VAR 0 12
88884: PUSH
88885: LD_INT 1
88887: ARRAY
88888: ST_TO_ADDR
// ComExit ( un ) ;
88889: LD_VAR 0 10
88893: PPUSH
88894: CALL 48981 0 1
// AddComEnterUnit ( un , i ) ;
88898: LD_VAR 0 10
88902: PPUSH
88903: LD_VAR 0 4
88907: PPUSH
88908: CALL_OW 180
// SetTag ( un , 19 ) ;
88912: LD_VAR 0 10
88916: PPUSH
88917: LD_INT 19
88919: PPUSH
88920: CALL_OW 109
// mechs := mechs diff un ;
88924: LD_ADDR_VAR 0 12
88928: PUSH
88929: LD_VAR 0 12
88933: PUSH
88934: LD_VAR 0 10
88938: DIFF
88939: ST_TO_ADDR
// end ; end ;
88940: GO 88818
88942: POP
88943: POP
// if solds then
88944: LD_VAR 0 8
88948: IFFALSE 89007
// for i in solds do
88950: LD_ADDR_VAR 0 4
88954: PUSH
88955: LD_VAR 0 8
88959: PUSH
88960: FOR_IN
88961: IFFALSE 89005
// if not GetTag ( i ) then
88963: LD_VAR 0 4
88967: PPUSH
88968: CALL_OW 110
88972: NOT
88973: IFFALSE 89003
// begin defenders := defenders union i ;
88975: LD_ADDR_VAR 0 2
88979: PUSH
88980: LD_VAR 0 2
88984: PUSH
88985: LD_VAR 0 4
88989: UNION
88990: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88991: LD_VAR 0 4
88995: PPUSH
88996: LD_INT 18
88998: PPUSH
88999: CALL_OW 109
// end ;
89003: GO 88960
89005: POP
89006: POP
// repeat wait ( 0 0$2 ) ;
89007: LD_INT 70
89009: PPUSH
89010: CALL_OW 67
// enemy := mc_scan [ base ] ;
89014: LD_ADDR_VAR 0 21
89018: PUSH
89019: LD_EXP 46
89023: PUSH
89024: LD_VAR 0 1
89028: ARRAY
89029: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
89030: LD_EXP 23
89034: PUSH
89035: LD_VAR 0 1
89039: ARRAY
89040: NOT
89041: PUSH
89042: LD_EXP 23
89046: PUSH
89047: LD_VAR 0 1
89051: ARRAY
89052: PUSH
89053: EMPTY
89054: EQUAL
89055: OR
89056: IFFALSE 89093
// begin for i in defenders do
89058: LD_ADDR_VAR 0 4
89062: PUSH
89063: LD_VAR 0 2
89067: PUSH
89068: FOR_IN
89069: IFFALSE 89082
// ComStop ( i ) ;
89071: LD_VAR 0 4
89075: PPUSH
89076: CALL_OW 141
89080: GO 89068
89082: POP
89083: POP
// defenders := [ ] ;
89084: LD_ADDR_VAR 0 2
89088: PUSH
89089: EMPTY
89090: ST_TO_ADDR
// exit ;
89091: GO 90542
// end ; for i in defenders do
89093: LD_ADDR_VAR 0 4
89097: PUSH
89098: LD_VAR 0 2
89102: PUSH
89103: FOR_IN
89104: IFFALSE 90002
// begin e := NearestUnitToUnit ( enemy , i ) ;
89106: LD_ADDR_VAR 0 13
89110: PUSH
89111: LD_VAR 0 21
89115: PPUSH
89116: LD_VAR 0 4
89120: PPUSH
89121: CALL_OW 74
89125: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89126: LD_ADDR_VAR 0 7
89130: PUSH
89131: LD_EXP 23
89135: PUSH
89136: LD_VAR 0 1
89140: ARRAY
89141: PPUSH
89142: LD_INT 2
89144: PUSH
89145: LD_INT 30
89147: PUSH
89148: LD_INT 0
89150: PUSH
89151: EMPTY
89152: LIST
89153: LIST
89154: PUSH
89155: LD_INT 30
89157: PUSH
89158: LD_INT 1
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: EMPTY
89166: LIST
89167: LIST
89168: LIST
89169: PPUSH
89170: CALL_OW 72
89174: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
89175: LD_ADDR_VAR 0 16
89179: PUSH
89180: LD_VAR 0 7
89184: NOT
89185: PUSH
89186: LD_VAR 0 7
89190: PPUSH
89191: LD_INT 3
89193: PUSH
89194: LD_INT 24
89196: PUSH
89197: LD_INT 600
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: PPUSH
89208: CALL_OW 72
89212: OR
89213: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
89214: LD_VAR 0 4
89218: PPUSH
89219: CALL_OW 247
89223: PUSH
89224: LD_INT 2
89226: DOUBLE
89227: EQUAL
89228: IFTRUE 89232
89230: GO 89628
89232: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89233: LD_VAR 0 4
89237: PPUSH
89238: CALL_OW 256
89242: PUSH
89243: LD_INT 1000
89245: EQUAL
89246: PUSH
89247: LD_VAR 0 4
89251: PPUSH
89252: LD_VAR 0 13
89256: PPUSH
89257: CALL_OW 296
89261: PUSH
89262: LD_INT 40
89264: LESS
89265: PUSH
89266: LD_VAR 0 13
89270: PPUSH
89271: LD_EXP 48
89275: PUSH
89276: LD_VAR 0 1
89280: ARRAY
89281: PPUSH
89282: CALL_OW 308
89286: OR
89287: AND
89288: IFFALSE 89410
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89290: LD_VAR 0 4
89294: PPUSH
89295: CALL_OW 262
89299: PUSH
89300: LD_INT 1
89302: EQUAL
89303: PUSH
89304: LD_VAR 0 4
89308: PPUSH
89309: CALL_OW 261
89313: PUSH
89314: LD_INT 30
89316: LESS
89317: AND
89318: PUSH
89319: LD_VAR 0 7
89323: AND
89324: IFFALSE 89394
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89326: LD_VAR 0 4
89330: PPUSH
89331: LD_VAR 0 7
89335: PPUSH
89336: LD_VAR 0 4
89340: PPUSH
89341: CALL_OW 74
89345: PPUSH
89346: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89350: LD_VAR 0 4
89354: PPUSH
89355: LD_VAR 0 7
89359: PPUSH
89360: LD_VAR 0 4
89364: PPUSH
89365: CALL_OW 74
89369: PPUSH
89370: CALL_OW 296
89374: PUSH
89375: LD_INT 6
89377: LESS
89378: IFFALSE 89392
// SetFuel ( i , 100 ) ;
89380: LD_VAR 0 4
89384: PPUSH
89385: LD_INT 100
89387: PPUSH
89388: CALL_OW 240
// end else
89392: GO 89408
// ComAttackUnit ( i , e ) ;
89394: LD_VAR 0 4
89398: PPUSH
89399: LD_VAR 0 13
89403: PPUSH
89404: CALL_OW 115
// end else
89408: GO 89511
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89410: LD_VAR 0 13
89414: PPUSH
89415: LD_EXP 48
89419: PUSH
89420: LD_VAR 0 1
89424: ARRAY
89425: PPUSH
89426: CALL_OW 308
89430: NOT
89431: PUSH
89432: LD_VAR 0 4
89436: PPUSH
89437: LD_VAR 0 13
89441: PPUSH
89442: CALL_OW 296
89446: PUSH
89447: LD_INT 40
89449: GREATEREQUAL
89450: AND
89451: PUSH
89452: LD_VAR 0 4
89456: PPUSH
89457: CALL_OW 256
89461: PUSH
89462: LD_INT 650
89464: LESSEQUAL
89465: OR
89466: PUSH
89467: LD_VAR 0 4
89471: PPUSH
89472: LD_EXP 47
89476: PUSH
89477: LD_VAR 0 1
89481: ARRAY
89482: PPUSH
89483: CALL_OW 308
89487: NOT
89488: AND
89489: IFFALSE 89511
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89491: LD_VAR 0 4
89495: PPUSH
89496: LD_EXP 47
89500: PUSH
89501: LD_VAR 0 1
89505: ARRAY
89506: PPUSH
89507: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89511: LD_VAR 0 4
89515: PPUSH
89516: CALL_OW 256
89520: PUSH
89521: LD_INT 1000
89523: LESS
89524: PUSH
89525: LD_VAR 0 4
89529: PPUSH
89530: CALL_OW 263
89534: PUSH
89535: LD_INT 1
89537: EQUAL
89538: AND
89539: PUSH
89540: LD_VAR 0 4
89544: PPUSH
89545: CALL_OW 311
89549: AND
89550: PUSH
89551: LD_VAR 0 4
89555: PPUSH
89556: LD_EXP 47
89560: PUSH
89561: LD_VAR 0 1
89565: ARRAY
89566: PPUSH
89567: CALL_OW 308
89571: AND
89572: IFFALSE 89626
// begin mech := IsDrivenBy ( i ) ;
89574: LD_ADDR_VAR 0 9
89578: PUSH
89579: LD_VAR 0 4
89583: PPUSH
89584: CALL_OW 311
89588: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89589: LD_VAR 0 9
89593: PPUSH
89594: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89598: LD_VAR 0 9
89602: PPUSH
89603: LD_VAR 0 4
89607: PPUSH
89608: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89612: LD_VAR 0 9
89616: PPUSH
89617: LD_VAR 0 4
89621: PPUSH
89622: CALL_OW 180
// end ; end ; unit_human :
89626: GO 89973
89628: LD_INT 1
89630: DOUBLE
89631: EQUAL
89632: IFTRUE 89636
89634: GO 89972
89636: POP
// begin b := IsInUnit ( i ) ;
89637: LD_ADDR_VAR 0 18
89641: PUSH
89642: LD_VAR 0 4
89646: PPUSH
89647: CALL_OW 310
89651: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89652: LD_ADDR_VAR 0 19
89656: PUSH
89657: LD_VAR 0 18
89661: NOT
89662: PUSH
89663: LD_VAR 0 18
89667: PPUSH
89668: CALL_OW 266
89672: PUSH
89673: LD_INT 32
89675: PUSH
89676: LD_INT 31
89678: PUSH
89679: EMPTY
89680: LIST
89681: LIST
89682: IN
89683: OR
89684: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89685: LD_VAR 0 18
89689: PPUSH
89690: CALL_OW 266
89694: PUSH
89695: LD_INT 5
89697: EQUAL
89698: PUSH
89699: LD_VAR 0 4
89703: PPUSH
89704: CALL_OW 257
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: LD_INT 2
89714: PUSH
89715: LD_INT 3
89717: PUSH
89718: LD_INT 4
89720: PUSH
89721: EMPTY
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: IN
89727: AND
89728: IFFALSE 89765
// begin class := AllowSpecClass ( i ) ;
89730: LD_ADDR_VAR 0 20
89734: PUSH
89735: LD_VAR 0 4
89739: PPUSH
89740: CALL 12901 0 1
89744: ST_TO_ADDR
// if class then
89745: LD_VAR 0 20
89749: IFFALSE 89765
// ComChangeProfession ( i , class ) ;
89751: LD_VAR 0 4
89755: PPUSH
89756: LD_VAR 0 20
89760: PPUSH
89761: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89765: LD_VAR 0 16
89769: PUSH
89770: LD_VAR 0 2
89774: PPUSH
89775: LD_INT 21
89777: PUSH
89778: LD_INT 2
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PPUSH
89785: CALL_OW 72
89789: PUSH
89790: LD_INT 1
89792: LESSEQUAL
89793: OR
89794: PUSH
89795: LD_VAR 0 19
89799: AND
89800: PUSH
89801: LD_VAR 0 4
89805: PUSH
89806: LD_VAR 0 17
89810: IN
89811: NOT
89812: AND
89813: IFFALSE 89906
// begin if b then
89815: LD_VAR 0 18
89819: IFFALSE 89868
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89821: LD_VAR 0 18
89825: PPUSH
89826: LD_VAR 0 21
89830: PPUSH
89831: LD_VAR 0 18
89835: PPUSH
89836: CALL_OW 74
89840: PPUSH
89841: CALL_OW 296
89845: PUSH
89846: LD_INT 10
89848: LESS
89849: PUSH
89850: LD_VAR 0 18
89854: PPUSH
89855: CALL_OW 461
89859: PUSH
89860: LD_INT 7
89862: NONEQUAL
89863: AND
89864: IFFALSE 89868
// continue ;
89866: GO 89103
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89868: LD_ADDR_VAR 0 17
89872: PUSH
89873: LD_VAR 0 17
89877: PPUSH
89878: LD_VAR 0 17
89882: PUSH
89883: LD_INT 1
89885: PLUS
89886: PPUSH
89887: LD_VAR 0 4
89891: PPUSH
89892: CALL_OW 1
89896: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89897: LD_VAR 0 4
89901: PPUSH
89902: CALL_OW 122
// end ; if sold_defenders then
89906: LD_VAR 0 17
89910: IFFALSE 89970
// if i in sold_defenders then
89912: LD_VAR 0 4
89916: PUSH
89917: LD_VAR 0 17
89921: IN
89922: IFFALSE 89970
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89924: LD_VAR 0 4
89928: PPUSH
89929: CALL_OW 314
89933: NOT
89934: PUSH
89935: LD_VAR 0 4
89939: PPUSH
89940: LD_VAR 0 13
89944: PPUSH
89945: CALL_OW 296
89949: PUSH
89950: LD_INT 30
89952: LESS
89953: AND
89954: IFFALSE 89970
// ComAttackUnit ( i , e ) ;
89956: LD_VAR 0 4
89960: PPUSH
89961: LD_VAR 0 13
89965: PPUSH
89966: CALL_OW 115
// end ; end ; end ;
89970: GO 89973
89972: POP
// if IsDead ( i ) then
89973: LD_VAR 0 4
89977: PPUSH
89978: CALL_OW 301
89982: IFFALSE 90000
// defenders := defenders diff i ;
89984: LD_ADDR_VAR 0 2
89988: PUSH
89989: LD_VAR 0 2
89993: PUSH
89994: LD_VAR 0 4
89998: DIFF
89999: ST_TO_ADDR
// end ;
90000: GO 89103
90002: POP
90003: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
90004: LD_VAR 0 21
90008: NOT
90009: PUSH
90010: LD_VAR 0 2
90014: NOT
90015: OR
90016: PUSH
90017: LD_EXP 23
90021: PUSH
90022: LD_VAR 0 1
90026: ARRAY
90027: NOT
90028: OR
90029: IFFALSE 89007
// MC_Reset ( base , 18 ) ;
90031: LD_VAR 0 1
90035: PPUSH
90036: LD_INT 18
90038: PPUSH
90039: CALL 56705 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
90043: LD_ADDR_VAR 0 2
90047: PUSH
90048: LD_VAR 0 2
90052: PUSH
90053: LD_VAR 0 2
90057: PPUSH
90058: LD_INT 2
90060: PUSH
90061: LD_INT 25
90063: PUSH
90064: LD_INT 1
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: LD_INT 25
90073: PUSH
90074: LD_INT 5
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 25
90083: PUSH
90084: LD_INT 8
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 25
90093: PUSH
90094: LD_INT 9
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: PPUSH
90108: CALL_OW 72
90112: DIFF
90113: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
90114: LD_VAR 0 21
90118: NOT
90119: PUSH
90120: LD_VAR 0 2
90124: PPUSH
90125: LD_INT 21
90127: PUSH
90128: LD_INT 2
90130: PUSH
90131: EMPTY
90132: LIST
90133: LIST
90134: PPUSH
90135: CALL_OW 72
90139: AND
90140: IFFALSE 90478
// begin tmp := FilterByTag ( defenders , 19 ) ;
90142: LD_ADDR_VAR 0 11
90146: PUSH
90147: LD_VAR 0 2
90151: PPUSH
90152: LD_INT 19
90154: PPUSH
90155: CALL 46164 0 2
90159: ST_TO_ADDR
// if tmp then
90160: LD_VAR 0 11
90164: IFFALSE 90234
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
90166: LD_ADDR_VAR 0 11
90170: PUSH
90171: LD_VAR 0 11
90175: PPUSH
90176: LD_INT 25
90178: PUSH
90179: LD_INT 3
90181: PUSH
90182: EMPTY
90183: LIST
90184: LIST
90185: PPUSH
90186: CALL_OW 72
90190: ST_TO_ADDR
// if tmp then
90191: LD_VAR 0 11
90195: IFFALSE 90234
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
90197: LD_ADDR_EXP 35
90201: PUSH
90202: LD_EXP 35
90206: PPUSH
90207: LD_VAR 0 1
90211: PPUSH
90212: LD_EXP 35
90216: PUSH
90217: LD_VAR 0 1
90221: ARRAY
90222: PUSH
90223: LD_VAR 0 11
90227: UNION
90228: PPUSH
90229: CALL_OW 1
90233: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90234: LD_VAR 0 1
90238: PPUSH
90239: LD_INT 19
90241: PPUSH
90242: CALL 56705 0 2
// repeat wait ( 0 0$1 ) ;
90246: LD_INT 35
90248: PPUSH
90249: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90253: LD_EXP 23
90257: PUSH
90258: LD_VAR 0 1
90262: ARRAY
90263: NOT
90264: PUSH
90265: LD_EXP 23
90269: PUSH
90270: LD_VAR 0 1
90274: ARRAY
90275: PUSH
90276: EMPTY
90277: EQUAL
90278: OR
90279: IFFALSE 90316
// begin for i in defenders do
90281: LD_ADDR_VAR 0 4
90285: PUSH
90286: LD_VAR 0 2
90290: PUSH
90291: FOR_IN
90292: IFFALSE 90305
// ComStop ( i ) ;
90294: LD_VAR 0 4
90298: PPUSH
90299: CALL_OW 141
90303: GO 90291
90305: POP
90306: POP
// defenders := [ ] ;
90307: LD_ADDR_VAR 0 2
90311: PUSH
90312: EMPTY
90313: ST_TO_ADDR
// exit ;
90314: GO 90542
// end ; for i in defenders do
90316: LD_ADDR_VAR 0 4
90320: PUSH
90321: LD_VAR 0 2
90325: PUSH
90326: FOR_IN
90327: IFFALSE 90416
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90329: LD_VAR 0 4
90333: PPUSH
90334: LD_EXP 47
90338: PUSH
90339: LD_VAR 0 1
90343: ARRAY
90344: PPUSH
90345: CALL_OW 308
90349: NOT
90350: IFFALSE 90374
// ComMoveToArea ( i , mc_parking [ base ] ) else
90352: LD_VAR 0 4
90356: PPUSH
90357: LD_EXP 47
90361: PUSH
90362: LD_VAR 0 1
90366: ARRAY
90367: PPUSH
90368: CALL_OW 113
90372: GO 90414
// if GetControl ( i ) = control_manual then
90374: LD_VAR 0 4
90378: PPUSH
90379: CALL_OW 263
90383: PUSH
90384: LD_INT 1
90386: EQUAL
90387: IFFALSE 90414
// if IsDrivenBy ( i ) then
90389: LD_VAR 0 4
90393: PPUSH
90394: CALL_OW 311
90398: IFFALSE 90414
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90400: LD_VAR 0 4
90404: PPUSH
90405: CALL_OW 311
90409: PPUSH
90410: CALL_OW 121
// end ;
90414: GO 90326
90416: POP
90417: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90418: LD_VAR 0 2
90422: PPUSH
90423: LD_INT 95
90425: PUSH
90426: LD_EXP 47
90430: PUSH
90431: LD_VAR 0 1
90435: ARRAY
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PPUSH
90441: CALL_OW 72
90445: PUSH
90446: LD_VAR 0 2
90450: EQUAL
90451: PUSH
90452: LD_EXP 46
90456: PUSH
90457: LD_VAR 0 1
90461: ARRAY
90462: OR
90463: PUSH
90464: LD_EXP 23
90468: PUSH
90469: LD_VAR 0 1
90473: ARRAY
90474: NOT
90475: OR
90476: IFFALSE 90246
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90478: LD_ADDR_EXP 45
90482: PUSH
90483: LD_EXP 45
90487: PPUSH
90488: LD_VAR 0 1
90492: PPUSH
90493: LD_VAR 0 2
90497: PPUSH
90498: LD_INT 21
90500: PUSH
90501: LD_INT 2
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: PPUSH
90508: CALL_OW 72
90512: PPUSH
90513: CALL_OW 1
90517: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90518: LD_VAR 0 1
90522: PPUSH
90523: LD_INT 19
90525: PPUSH
90526: CALL 56705 0 2
// MC_Reset ( base , 20 ) ;
90530: LD_VAR 0 1
90534: PPUSH
90535: LD_INT 20
90537: PPUSH
90538: CALL 56705 0 2
// end ; end_of_file
90542: LD_VAR 0 3
90546: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90547: LD_INT 0
90549: PPUSH
90550: PPUSH
90551: PPUSH
90552: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90553: LD_VAR 0 1
90557: PPUSH
90558: CALL_OW 264
90562: PUSH
90563: LD_INT 91
90565: EQUAL
90566: IFFALSE 90638
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90568: LD_INT 68
90570: PPUSH
90571: LD_VAR 0 1
90575: PPUSH
90576: CALL_OW 255
90580: PPUSH
90581: CALL_OW 321
90585: PUSH
90586: LD_INT 2
90588: EQUAL
90589: IFFALSE 90601
// eff := 70 else
90591: LD_ADDR_VAR 0 4
90595: PUSH
90596: LD_INT 70
90598: ST_TO_ADDR
90599: GO 90609
// eff := 30 ;
90601: LD_ADDR_VAR 0 4
90605: PUSH
90606: LD_INT 30
90608: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90609: LD_VAR 0 1
90613: PPUSH
90614: CALL_OW 250
90618: PPUSH
90619: LD_VAR 0 1
90623: PPUSH
90624: CALL_OW 251
90628: PPUSH
90629: LD_VAR 0 4
90633: PPUSH
90634: CALL_OW 495
// end ; end ;
90638: LD_VAR 0 2
90642: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90643: LD_INT 0
90645: PPUSH
// end ;
90646: LD_VAR 0 4
90650: RET
// export function SOS_Command ( cmd ) ; begin
90651: LD_INT 0
90653: PPUSH
// end ;
90654: LD_VAR 0 2
90658: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90659: LD_INT 0
90661: PPUSH
// end ;
90662: LD_VAR 0 6
90666: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90667: LD_INT 0
90669: PPUSH
90670: PPUSH
// if not vehicle or not factory then
90671: LD_VAR 0 1
90675: NOT
90676: PUSH
90677: LD_VAR 0 2
90681: NOT
90682: OR
90683: IFFALSE 90687
// exit ;
90685: GO 90918
// if factoryWaypoints >= factory then
90687: LD_EXP 137
90691: PUSH
90692: LD_VAR 0 2
90696: GREATEREQUAL
90697: IFFALSE 90918
// if factoryWaypoints [ factory ] then
90699: LD_EXP 137
90703: PUSH
90704: LD_VAR 0 2
90708: ARRAY
90709: IFFALSE 90918
// begin if GetControl ( vehicle ) = control_manual then
90711: LD_VAR 0 1
90715: PPUSH
90716: CALL_OW 263
90720: PUSH
90721: LD_INT 1
90723: EQUAL
90724: IFFALSE 90805
// begin driver := IsDrivenBy ( vehicle ) ;
90726: LD_ADDR_VAR 0 4
90730: PUSH
90731: LD_VAR 0 1
90735: PPUSH
90736: CALL_OW 311
90740: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90741: LD_VAR 0 4
90745: PPUSH
90746: LD_EXP 137
90750: PUSH
90751: LD_VAR 0 2
90755: ARRAY
90756: PUSH
90757: LD_INT 3
90759: ARRAY
90760: PPUSH
90761: LD_EXP 137
90765: PUSH
90766: LD_VAR 0 2
90770: ARRAY
90771: PUSH
90772: LD_INT 4
90774: ARRAY
90775: PPUSH
90776: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90780: LD_VAR 0 4
90784: PPUSH
90785: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90789: LD_VAR 0 4
90793: PPUSH
90794: LD_VAR 0 2
90798: PPUSH
90799: CALL_OW 180
// end else
90803: GO 90918
// if GetControl ( vehicle ) = control_remote then
90805: LD_VAR 0 1
90809: PPUSH
90810: CALL_OW 263
90814: PUSH
90815: LD_INT 2
90817: EQUAL
90818: IFFALSE 90879
// begin wait ( 0 0$2 ) ;
90820: LD_INT 70
90822: PPUSH
90823: CALL_OW 67
// if Connect ( vehicle ) then
90827: LD_VAR 0 1
90831: PPUSH
90832: CALL 19221 0 1
90836: IFFALSE 90877
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90838: LD_VAR 0 1
90842: PPUSH
90843: LD_EXP 137
90847: PUSH
90848: LD_VAR 0 2
90852: ARRAY
90853: PUSH
90854: LD_INT 3
90856: ARRAY
90857: PPUSH
90858: LD_EXP 137
90862: PUSH
90863: LD_VAR 0 2
90867: ARRAY
90868: PUSH
90869: LD_INT 4
90871: ARRAY
90872: PPUSH
90873: CALL_OW 171
// end else
90877: GO 90918
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90879: LD_VAR 0 1
90883: PPUSH
90884: LD_EXP 137
90888: PUSH
90889: LD_VAR 0 2
90893: ARRAY
90894: PUSH
90895: LD_INT 3
90897: ARRAY
90898: PPUSH
90899: LD_EXP 137
90903: PUSH
90904: LD_VAR 0 2
90908: ARRAY
90909: PUSH
90910: LD_INT 4
90912: ARRAY
90913: PPUSH
90914: CALL_OW 171
// end ; end ;
90918: LD_VAR 0 3
90922: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90923: LD_INT 0
90925: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90926: LD_VAR 0 1
90930: PUSH
90931: LD_INT 250
90933: EQUAL
90934: PUSH
90935: LD_VAR 0 2
90939: PPUSH
90940: CALL_OW 264
90944: PUSH
90945: LD_INT 81
90947: EQUAL
90948: AND
90949: IFFALSE 90970
// MinerPlaceMine ( unit , x , y ) ;
90951: LD_VAR 0 2
90955: PPUSH
90956: LD_VAR 0 4
90960: PPUSH
90961: LD_VAR 0 5
90965: PPUSH
90966: CALL 93355 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90970: LD_VAR 0 1
90974: PUSH
90975: LD_INT 251
90977: EQUAL
90978: PUSH
90979: LD_VAR 0 2
90983: PPUSH
90984: CALL_OW 264
90988: PUSH
90989: LD_INT 81
90991: EQUAL
90992: AND
90993: IFFALSE 91014
// MinerDetonateMine ( unit , x , y ) ;
90995: LD_VAR 0 2
90999: PPUSH
91000: LD_VAR 0 4
91004: PPUSH
91005: LD_VAR 0 5
91009: PPUSH
91010: CALL 93630 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
91014: LD_VAR 0 1
91018: PUSH
91019: LD_INT 252
91021: EQUAL
91022: PUSH
91023: LD_VAR 0 2
91027: PPUSH
91028: CALL_OW 264
91032: PUSH
91033: LD_INT 81
91035: EQUAL
91036: AND
91037: IFFALSE 91058
// MinerCreateMinefield ( unit , x , y ) ;
91039: LD_VAR 0 2
91043: PPUSH
91044: LD_VAR 0 4
91048: PPUSH
91049: LD_VAR 0 5
91053: PPUSH
91054: CALL 94047 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
91058: LD_VAR 0 1
91062: PUSH
91063: LD_INT 253
91065: EQUAL
91066: PUSH
91067: LD_VAR 0 2
91071: PPUSH
91072: CALL_OW 257
91076: PUSH
91077: LD_INT 5
91079: EQUAL
91080: AND
91081: IFFALSE 91102
// ComBinocular ( unit , x , y ) ;
91083: LD_VAR 0 2
91087: PPUSH
91088: LD_VAR 0 4
91092: PPUSH
91093: LD_VAR 0 5
91097: PPUSH
91098: CALL 94416 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
91102: LD_VAR 0 1
91106: PUSH
91107: LD_INT 254
91109: EQUAL
91110: PUSH
91111: LD_VAR 0 2
91115: PPUSH
91116: CALL_OW 264
91120: PUSH
91121: LD_INT 99
91123: EQUAL
91124: AND
91125: PUSH
91126: LD_VAR 0 3
91130: PPUSH
91131: CALL_OW 263
91135: PUSH
91136: LD_INT 3
91138: EQUAL
91139: AND
91140: IFFALSE 91156
// HackDestroyVehicle ( unit , selectedUnit ) ;
91142: LD_VAR 0 2
91146: PPUSH
91147: LD_VAR 0 3
91151: PPUSH
91152: CALL 92719 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
91156: LD_VAR 0 1
91160: PUSH
91161: LD_INT 255
91163: EQUAL
91164: PUSH
91165: LD_VAR 0 2
91169: PPUSH
91170: CALL_OW 264
91174: PUSH
91175: LD_INT 14
91177: PUSH
91178: LD_INT 53
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: IN
91185: AND
91186: PUSH
91187: LD_VAR 0 4
91191: PPUSH
91192: LD_VAR 0 5
91196: PPUSH
91197: CALL_OW 488
91201: AND
91202: IFFALSE 91226
// CutTreeXYR ( unit , x , y , 12 ) ;
91204: LD_VAR 0 2
91208: PPUSH
91209: LD_VAR 0 4
91213: PPUSH
91214: LD_VAR 0 5
91218: PPUSH
91219: LD_INT 12
91221: PPUSH
91222: CALL 91289 0 4
// if cmd = 256 then
91226: LD_VAR 0 1
91230: PUSH
91231: LD_INT 256
91233: EQUAL
91234: IFFALSE 91255
// SetFactoryWaypoint ( unit , x , y ) ;
91236: LD_VAR 0 2
91240: PPUSH
91241: LD_VAR 0 4
91245: PPUSH
91246: LD_VAR 0 5
91250: PPUSH
91251: CALL 109482 0 3
// if cmd = 257 then
91255: LD_VAR 0 1
91259: PUSH
91260: LD_INT 257
91262: EQUAL
91263: IFFALSE 91284
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91265: LD_VAR 0 2
91269: PPUSH
91270: LD_VAR 0 4
91274: PPUSH
91275: LD_VAR 0 5
91279: PPUSH
91280: CALL 109844 0 3
// end ;
91284: LD_VAR 0 6
91288: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91289: LD_INT 0
91291: PPUSH
91292: PPUSH
91293: PPUSH
91294: PPUSH
91295: PPUSH
91296: PPUSH
91297: PPUSH
91298: PPUSH
91299: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91300: LD_VAR 0 1
91304: NOT
91305: PUSH
91306: LD_VAR 0 2
91310: PPUSH
91311: LD_VAR 0 3
91315: PPUSH
91316: CALL_OW 488
91320: NOT
91321: OR
91322: PUSH
91323: LD_VAR 0 4
91327: NOT
91328: OR
91329: IFFALSE 91333
// exit ;
91331: GO 91673
// list := [ ] ;
91333: LD_ADDR_VAR 0 13
91337: PUSH
91338: EMPTY
91339: ST_TO_ADDR
// if x - r < 0 then
91340: LD_VAR 0 2
91344: PUSH
91345: LD_VAR 0 4
91349: MINUS
91350: PUSH
91351: LD_INT 0
91353: LESS
91354: IFFALSE 91366
// min_x := 0 else
91356: LD_ADDR_VAR 0 7
91360: PUSH
91361: LD_INT 0
91363: ST_TO_ADDR
91364: GO 91382
// min_x := x - r ;
91366: LD_ADDR_VAR 0 7
91370: PUSH
91371: LD_VAR 0 2
91375: PUSH
91376: LD_VAR 0 4
91380: MINUS
91381: ST_TO_ADDR
// if y - r < 0 then
91382: LD_VAR 0 3
91386: PUSH
91387: LD_VAR 0 4
91391: MINUS
91392: PUSH
91393: LD_INT 0
91395: LESS
91396: IFFALSE 91408
// min_y := 0 else
91398: LD_ADDR_VAR 0 8
91402: PUSH
91403: LD_INT 0
91405: ST_TO_ADDR
91406: GO 91424
// min_y := y - r ;
91408: LD_ADDR_VAR 0 8
91412: PUSH
91413: LD_VAR 0 3
91417: PUSH
91418: LD_VAR 0 4
91422: MINUS
91423: ST_TO_ADDR
// max_x := x + r ;
91424: LD_ADDR_VAR 0 9
91428: PUSH
91429: LD_VAR 0 2
91433: PUSH
91434: LD_VAR 0 4
91438: PLUS
91439: ST_TO_ADDR
// max_y := y + r ;
91440: LD_ADDR_VAR 0 10
91444: PUSH
91445: LD_VAR 0 3
91449: PUSH
91450: LD_VAR 0 4
91454: PLUS
91455: ST_TO_ADDR
// for _x = min_x to max_x do
91456: LD_ADDR_VAR 0 11
91460: PUSH
91461: DOUBLE
91462: LD_VAR 0 7
91466: DEC
91467: ST_TO_ADDR
91468: LD_VAR 0 9
91472: PUSH
91473: FOR_TO
91474: IFFALSE 91591
// for _y = min_y to max_y do
91476: LD_ADDR_VAR 0 12
91480: PUSH
91481: DOUBLE
91482: LD_VAR 0 8
91486: DEC
91487: ST_TO_ADDR
91488: LD_VAR 0 10
91492: PUSH
91493: FOR_TO
91494: IFFALSE 91587
// begin if not ValidHex ( _x , _y ) then
91496: LD_VAR 0 11
91500: PPUSH
91501: LD_VAR 0 12
91505: PPUSH
91506: CALL_OW 488
91510: NOT
91511: IFFALSE 91515
// continue ;
91513: GO 91493
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91515: LD_VAR 0 11
91519: PPUSH
91520: LD_VAR 0 12
91524: PPUSH
91525: CALL_OW 351
91529: PUSH
91530: LD_VAR 0 11
91534: PPUSH
91535: LD_VAR 0 12
91539: PPUSH
91540: CALL_OW 554
91544: AND
91545: IFFALSE 91585
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91547: LD_ADDR_VAR 0 13
91551: PUSH
91552: LD_VAR 0 13
91556: PPUSH
91557: LD_VAR 0 13
91561: PUSH
91562: LD_INT 1
91564: PLUS
91565: PPUSH
91566: LD_VAR 0 11
91570: PUSH
91571: LD_VAR 0 12
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PPUSH
91580: CALL_OW 2
91584: ST_TO_ADDR
// end ;
91585: GO 91493
91587: POP
91588: POP
91589: GO 91473
91591: POP
91592: POP
// if not list then
91593: LD_VAR 0 13
91597: NOT
91598: IFFALSE 91602
// exit ;
91600: GO 91673
// for i in list do
91602: LD_ADDR_VAR 0 6
91606: PUSH
91607: LD_VAR 0 13
91611: PUSH
91612: FOR_IN
91613: IFFALSE 91671
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91615: LD_VAR 0 1
91619: PPUSH
91620: LD_STRING M
91622: PUSH
91623: LD_VAR 0 6
91627: PUSH
91628: LD_INT 1
91630: ARRAY
91631: PUSH
91632: LD_VAR 0 6
91636: PUSH
91637: LD_INT 2
91639: ARRAY
91640: PUSH
91641: LD_INT 0
91643: PUSH
91644: LD_INT 0
91646: PUSH
91647: LD_INT 0
91649: PUSH
91650: LD_INT 0
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: PUSH
91662: EMPTY
91663: LIST
91664: PPUSH
91665: CALL_OW 447
91669: GO 91612
91671: POP
91672: POP
// end ;
91673: LD_VAR 0 5
91677: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91678: LD_EXP 68
91682: NOT
91683: IFFALSE 91733
91685: GO 91687
91687: DISABLE
// begin initHack := true ;
91688: LD_ADDR_EXP 68
91692: PUSH
91693: LD_INT 1
91695: ST_TO_ADDR
// hackTanks := [ ] ;
91696: LD_ADDR_EXP 69
91700: PUSH
91701: EMPTY
91702: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91703: LD_ADDR_EXP 70
91707: PUSH
91708: EMPTY
91709: ST_TO_ADDR
// hackLimit := 3 ;
91710: LD_ADDR_EXP 71
91714: PUSH
91715: LD_INT 3
91717: ST_TO_ADDR
// hackDist := 12 ;
91718: LD_ADDR_EXP 72
91722: PUSH
91723: LD_INT 12
91725: ST_TO_ADDR
// hackCounter := [ ] ;
91726: LD_ADDR_EXP 73
91730: PUSH
91731: EMPTY
91732: ST_TO_ADDR
// end ;
91733: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91734: LD_EXP 68
91738: PUSH
91739: LD_INT 34
91741: PUSH
91742: LD_INT 99
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: PPUSH
91749: CALL_OW 69
91753: AND
91754: IFFALSE 92007
91756: GO 91758
91758: DISABLE
91759: LD_INT 0
91761: PPUSH
91762: PPUSH
// begin enable ;
91763: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91764: LD_ADDR_VAR 0 1
91768: PUSH
91769: LD_INT 34
91771: PUSH
91772: LD_INT 99
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PPUSH
91779: CALL_OW 69
91783: PUSH
91784: FOR_IN
91785: IFFALSE 92005
// begin if not i in hackTanks then
91787: LD_VAR 0 1
91791: PUSH
91792: LD_EXP 69
91796: IN
91797: NOT
91798: IFFALSE 91881
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91800: LD_ADDR_EXP 69
91804: PUSH
91805: LD_EXP 69
91809: PPUSH
91810: LD_EXP 69
91814: PUSH
91815: LD_INT 1
91817: PLUS
91818: PPUSH
91819: LD_VAR 0 1
91823: PPUSH
91824: CALL_OW 1
91828: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91829: LD_ADDR_EXP 70
91833: PUSH
91834: LD_EXP 70
91838: PPUSH
91839: LD_EXP 70
91843: PUSH
91844: LD_INT 1
91846: PLUS
91847: PPUSH
91848: EMPTY
91849: PPUSH
91850: CALL_OW 1
91854: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91855: LD_ADDR_EXP 73
91859: PUSH
91860: LD_EXP 73
91864: PPUSH
91865: LD_EXP 73
91869: PUSH
91870: LD_INT 1
91872: PLUS
91873: PPUSH
91874: EMPTY
91875: PPUSH
91876: CALL_OW 1
91880: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91881: LD_VAR 0 1
91885: PPUSH
91886: CALL_OW 302
91890: NOT
91891: IFFALSE 91904
// begin HackUnlinkAll ( i ) ;
91893: LD_VAR 0 1
91897: PPUSH
91898: CALL 92010 0 1
// continue ;
91902: GO 91784
// end ; HackCheckCapturedStatus ( i ) ;
91904: LD_VAR 0 1
91908: PPUSH
91909: CALL 92453 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91913: LD_ADDR_VAR 0 2
91917: PUSH
91918: LD_INT 81
91920: PUSH
91921: LD_VAR 0 1
91925: PPUSH
91926: CALL_OW 255
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 33
91937: PUSH
91938: LD_INT 3
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 91
91947: PUSH
91948: LD_VAR 0 1
91952: PUSH
91953: LD_EXP 72
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: LIST
91962: PUSH
91963: LD_INT 50
91965: PUSH
91966: EMPTY
91967: LIST
91968: PUSH
91969: EMPTY
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: PPUSH
91975: CALL_OW 69
91979: ST_TO_ADDR
// if not tmp then
91980: LD_VAR 0 2
91984: NOT
91985: IFFALSE 91989
// continue ;
91987: GO 91784
// HackLink ( i , tmp ) ;
91989: LD_VAR 0 1
91993: PPUSH
91994: LD_VAR 0 2
91998: PPUSH
91999: CALL 92146 0 2
// end ;
92003: GO 91784
92005: POP
92006: POP
// end ;
92007: PPOPN 2
92009: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
92010: LD_INT 0
92012: PPUSH
92013: PPUSH
92014: PPUSH
// if not hack in hackTanks then
92015: LD_VAR 0 1
92019: PUSH
92020: LD_EXP 69
92024: IN
92025: NOT
92026: IFFALSE 92030
// exit ;
92028: GO 92141
// index := GetElementIndex ( hackTanks , hack ) ;
92030: LD_ADDR_VAR 0 4
92034: PUSH
92035: LD_EXP 69
92039: PPUSH
92040: LD_VAR 0 1
92044: PPUSH
92045: CALL 16037 0 2
92049: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
92050: LD_EXP 70
92054: PUSH
92055: LD_VAR 0 4
92059: ARRAY
92060: IFFALSE 92141
// begin for i in hackTanksCaptured [ index ] do
92062: LD_ADDR_VAR 0 3
92066: PUSH
92067: LD_EXP 70
92071: PUSH
92072: LD_VAR 0 4
92076: ARRAY
92077: PUSH
92078: FOR_IN
92079: IFFALSE 92105
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
92081: LD_VAR 0 3
92085: PUSH
92086: LD_INT 1
92088: ARRAY
92089: PPUSH
92090: LD_VAR 0 3
92094: PUSH
92095: LD_INT 2
92097: ARRAY
92098: PPUSH
92099: CALL_OW 235
92103: GO 92078
92105: POP
92106: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
92107: LD_ADDR_EXP 70
92111: PUSH
92112: LD_EXP 70
92116: PPUSH
92117: LD_VAR 0 4
92121: PPUSH
92122: EMPTY
92123: PPUSH
92124: CALL_OW 1
92128: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
92129: LD_VAR 0 1
92133: PPUSH
92134: LD_INT 0
92136: PPUSH
92137: CALL_OW 505
// end ; end ;
92141: LD_VAR 0 2
92145: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
92146: LD_INT 0
92148: PPUSH
92149: PPUSH
92150: PPUSH
// if not hack in hackTanks or not vehicles then
92151: LD_VAR 0 1
92155: PUSH
92156: LD_EXP 69
92160: IN
92161: NOT
92162: PUSH
92163: LD_VAR 0 2
92167: NOT
92168: OR
92169: IFFALSE 92173
// exit ;
92171: GO 92448
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
92173: LD_ADDR_VAR 0 2
92177: PUSH
92178: LD_VAR 0 1
92182: PPUSH
92183: LD_VAR 0 2
92187: PPUSH
92188: LD_INT 1
92190: PPUSH
92191: LD_INT 1
92193: PPUSH
92194: CALL 16687 0 4
92198: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
92199: LD_ADDR_VAR 0 5
92203: PUSH
92204: LD_EXP 69
92208: PPUSH
92209: LD_VAR 0 1
92213: PPUSH
92214: CALL 16037 0 2
92218: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92219: LD_EXP 70
92223: PUSH
92224: LD_VAR 0 5
92228: ARRAY
92229: PUSH
92230: LD_EXP 71
92234: LESS
92235: IFFALSE 92424
// begin for i := 1 to vehicles do
92237: LD_ADDR_VAR 0 4
92241: PUSH
92242: DOUBLE
92243: LD_INT 1
92245: DEC
92246: ST_TO_ADDR
92247: LD_VAR 0 2
92251: PUSH
92252: FOR_TO
92253: IFFALSE 92422
// begin if hackTanksCaptured [ index ] = hackLimit then
92255: LD_EXP 70
92259: PUSH
92260: LD_VAR 0 5
92264: ARRAY
92265: PUSH
92266: LD_EXP 71
92270: EQUAL
92271: IFFALSE 92275
// break ;
92273: GO 92422
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92275: LD_ADDR_EXP 73
92279: PUSH
92280: LD_EXP 73
92284: PPUSH
92285: LD_VAR 0 5
92289: PPUSH
92290: LD_EXP 73
92294: PUSH
92295: LD_VAR 0 5
92299: ARRAY
92300: PUSH
92301: LD_INT 1
92303: PLUS
92304: PPUSH
92305: CALL_OW 1
92309: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92310: LD_ADDR_EXP 70
92314: PUSH
92315: LD_EXP 70
92319: PPUSH
92320: LD_VAR 0 5
92324: PUSH
92325: LD_EXP 70
92329: PUSH
92330: LD_VAR 0 5
92334: ARRAY
92335: PUSH
92336: LD_INT 1
92338: PLUS
92339: PUSH
92340: EMPTY
92341: LIST
92342: LIST
92343: PPUSH
92344: LD_VAR 0 2
92348: PUSH
92349: LD_VAR 0 4
92353: ARRAY
92354: PUSH
92355: LD_VAR 0 2
92359: PUSH
92360: LD_VAR 0 4
92364: ARRAY
92365: PPUSH
92366: CALL_OW 255
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: PPUSH
92375: CALL 16252 0 3
92379: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92380: LD_VAR 0 2
92384: PUSH
92385: LD_VAR 0 4
92389: ARRAY
92390: PPUSH
92391: LD_VAR 0 1
92395: PPUSH
92396: CALL_OW 255
92400: PPUSH
92401: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92405: LD_VAR 0 2
92409: PUSH
92410: LD_VAR 0 4
92414: ARRAY
92415: PPUSH
92416: CALL_OW 141
// end ;
92420: GO 92252
92422: POP
92423: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92424: LD_VAR 0 1
92428: PPUSH
92429: LD_EXP 70
92433: PUSH
92434: LD_VAR 0 5
92438: ARRAY
92439: PUSH
92440: LD_INT 0
92442: PLUS
92443: PPUSH
92444: CALL_OW 505
// end ;
92448: LD_VAR 0 3
92452: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92453: LD_INT 0
92455: PPUSH
92456: PPUSH
92457: PPUSH
92458: PPUSH
// if not hack in hackTanks then
92459: LD_VAR 0 1
92463: PUSH
92464: LD_EXP 69
92468: IN
92469: NOT
92470: IFFALSE 92474
// exit ;
92472: GO 92714
// index := GetElementIndex ( hackTanks , hack ) ;
92474: LD_ADDR_VAR 0 4
92478: PUSH
92479: LD_EXP 69
92483: PPUSH
92484: LD_VAR 0 1
92488: PPUSH
92489: CALL 16037 0 2
92493: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92494: LD_ADDR_VAR 0 3
92498: PUSH
92499: DOUBLE
92500: LD_EXP 70
92504: PUSH
92505: LD_VAR 0 4
92509: ARRAY
92510: INC
92511: ST_TO_ADDR
92512: LD_INT 1
92514: PUSH
92515: FOR_DOWNTO
92516: IFFALSE 92688
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92518: LD_ADDR_VAR 0 5
92522: PUSH
92523: LD_EXP 70
92527: PUSH
92528: LD_VAR 0 4
92532: ARRAY
92533: PUSH
92534: LD_VAR 0 3
92538: ARRAY
92539: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92540: LD_VAR 0 5
92544: PUSH
92545: LD_INT 1
92547: ARRAY
92548: PPUSH
92549: CALL_OW 302
92553: NOT
92554: PUSH
92555: LD_VAR 0 5
92559: PUSH
92560: LD_INT 1
92562: ARRAY
92563: PPUSH
92564: CALL_OW 255
92568: PUSH
92569: LD_VAR 0 1
92573: PPUSH
92574: CALL_OW 255
92578: NONEQUAL
92579: OR
92580: IFFALSE 92686
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92582: LD_VAR 0 5
92586: PUSH
92587: LD_INT 1
92589: ARRAY
92590: PPUSH
92591: CALL_OW 305
92595: PUSH
92596: LD_VAR 0 5
92600: PUSH
92601: LD_INT 1
92603: ARRAY
92604: PPUSH
92605: CALL_OW 255
92609: PUSH
92610: LD_VAR 0 1
92614: PPUSH
92615: CALL_OW 255
92619: EQUAL
92620: AND
92621: IFFALSE 92645
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92623: LD_VAR 0 5
92627: PUSH
92628: LD_INT 1
92630: ARRAY
92631: PPUSH
92632: LD_VAR 0 5
92636: PUSH
92637: LD_INT 2
92639: ARRAY
92640: PPUSH
92641: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92645: LD_ADDR_EXP 70
92649: PUSH
92650: LD_EXP 70
92654: PPUSH
92655: LD_VAR 0 4
92659: PPUSH
92660: LD_EXP 70
92664: PUSH
92665: LD_VAR 0 4
92669: ARRAY
92670: PPUSH
92671: LD_VAR 0 3
92675: PPUSH
92676: CALL_OW 3
92680: PPUSH
92681: CALL_OW 1
92685: ST_TO_ADDR
// end ; end ;
92686: GO 92515
92688: POP
92689: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92690: LD_VAR 0 1
92694: PPUSH
92695: LD_EXP 70
92699: PUSH
92700: LD_VAR 0 4
92704: ARRAY
92705: PUSH
92706: LD_INT 0
92708: PLUS
92709: PPUSH
92710: CALL_OW 505
// end ;
92714: LD_VAR 0 2
92718: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92719: LD_INT 0
92721: PPUSH
92722: PPUSH
92723: PPUSH
92724: PPUSH
// if not hack in hackTanks then
92725: LD_VAR 0 1
92729: PUSH
92730: LD_EXP 69
92734: IN
92735: NOT
92736: IFFALSE 92740
// exit ;
92738: GO 92825
// index := GetElementIndex ( hackTanks , hack ) ;
92740: LD_ADDR_VAR 0 5
92744: PUSH
92745: LD_EXP 69
92749: PPUSH
92750: LD_VAR 0 1
92754: PPUSH
92755: CALL 16037 0 2
92759: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92760: LD_ADDR_VAR 0 4
92764: PUSH
92765: DOUBLE
92766: LD_INT 1
92768: DEC
92769: ST_TO_ADDR
92770: LD_EXP 70
92774: PUSH
92775: LD_VAR 0 5
92779: ARRAY
92780: PUSH
92781: FOR_TO
92782: IFFALSE 92823
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92784: LD_EXP 70
92788: PUSH
92789: LD_VAR 0 5
92793: ARRAY
92794: PUSH
92795: LD_VAR 0 4
92799: ARRAY
92800: PUSH
92801: LD_INT 1
92803: ARRAY
92804: PUSH
92805: LD_VAR 0 2
92809: EQUAL
92810: IFFALSE 92821
// KillUnit ( vehicle ) ;
92812: LD_VAR 0 2
92816: PPUSH
92817: CALL_OW 66
92821: GO 92781
92823: POP
92824: POP
// end ;
92825: LD_VAR 0 3
92829: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92830: LD_EXP 74
92834: NOT
92835: IFFALSE 92870
92837: GO 92839
92839: DISABLE
// begin initMiner := true ;
92840: LD_ADDR_EXP 74
92844: PUSH
92845: LD_INT 1
92847: ST_TO_ADDR
// minersList := [ ] ;
92848: LD_ADDR_EXP 75
92852: PUSH
92853: EMPTY
92854: ST_TO_ADDR
// minerMinesList := [ ] ;
92855: LD_ADDR_EXP 76
92859: PUSH
92860: EMPTY
92861: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92862: LD_ADDR_EXP 77
92866: PUSH
92867: LD_INT 5
92869: ST_TO_ADDR
// end ;
92870: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92871: LD_EXP 74
92875: PUSH
92876: LD_INT 34
92878: PUSH
92879: LD_INT 81
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PPUSH
92886: CALL_OW 69
92890: AND
92891: IFFALSE 93352
92893: GO 92895
92895: DISABLE
92896: LD_INT 0
92898: PPUSH
92899: PPUSH
92900: PPUSH
92901: PPUSH
// begin enable ;
92902: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92903: LD_ADDR_VAR 0 1
92907: PUSH
92908: LD_INT 34
92910: PUSH
92911: LD_INT 81
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: PPUSH
92918: CALL_OW 69
92922: PUSH
92923: FOR_IN
92924: IFFALSE 92996
// begin if not i in minersList then
92926: LD_VAR 0 1
92930: PUSH
92931: LD_EXP 75
92935: IN
92936: NOT
92937: IFFALSE 92994
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92939: LD_ADDR_EXP 75
92943: PUSH
92944: LD_EXP 75
92948: PPUSH
92949: LD_EXP 75
92953: PUSH
92954: LD_INT 1
92956: PLUS
92957: PPUSH
92958: LD_VAR 0 1
92962: PPUSH
92963: CALL_OW 1
92967: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92968: LD_ADDR_EXP 76
92972: PUSH
92973: LD_EXP 76
92977: PPUSH
92978: LD_EXP 76
92982: PUSH
92983: LD_INT 1
92985: PLUS
92986: PPUSH
92987: EMPTY
92988: PPUSH
92989: CALL_OW 1
92993: ST_TO_ADDR
// end end ;
92994: GO 92923
92996: POP
92997: POP
// for i := minerMinesList downto 1 do
92998: LD_ADDR_VAR 0 1
93002: PUSH
93003: DOUBLE
93004: LD_EXP 76
93008: INC
93009: ST_TO_ADDR
93010: LD_INT 1
93012: PUSH
93013: FOR_DOWNTO
93014: IFFALSE 93350
// begin if IsLive ( minersList [ i ] ) then
93016: LD_EXP 75
93020: PUSH
93021: LD_VAR 0 1
93025: ARRAY
93026: PPUSH
93027: CALL_OW 300
93031: IFFALSE 93059
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
93033: LD_EXP 75
93037: PUSH
93038: LD_VAR 0 1
93042: ARRAY
93043: PPUSH
93044: LD_EXP 76
93048: PUSH
93049: LD_VAR 0 1
93053: ARRAY
93054: PPUSH
93055: CALL_OW 505
// if not minerMinesList [ i ] then
93059: LD_EXP 76
93063: PUSH
93064: LD_VAR 0 1
93068: ARRAY
93069: NOT
93070: IFFALSE 93074
// continue ;
93072: GO 93013
// for j := minerMinesList [ i ] downto 1 do
93074: LD_ADDR_VAR 0 2
93078: PUSH
93079: DOUBLE
93080: LD_EXP 76
93084: PUSH
93085: LD_VAR 0 1
93089: ARRAY
93090: INC
93091: ST_TO_ADDR
93092: LD_INT 1
93094: PUSH
93095: FOR_DOWNTO
93096: IFFALSE 93346
// begin side := GetSide ( minersList [ i ] ) ;
93098: LD_ADDR_VAR 0 3
93102: PUSH
93103: LD_EXP 75
93107: PUSH
93108: LD_VAR 0 1
93112: ARRAY
93113: PPUSH
93114: CALL_OW 255
93118: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
93119: LD_ADDR_VAR 0 4
93123: PUSH
93124: LD_EXP 76
93128: PUSH
93129: LD_VAR 0 1
93133: ARRAY
93134: PUSH
93135: LD_VAR 0 2
93139: ARRAY
93140: PUSH
93141: LD_INT 1
93143: ARRAY
93144: PPUSH
93145: LD_EXP 76
93149: PUSH
93150: LD_VAR 0 1
93154: ARRAY
93155: PUSH
93156: LD_VAR 0 2
93160: ARRAY
93161: PUSH
93162: LD_INT 2
93164: ARRAY
93165: PPUSH
93166: CALL_OW 428
93170: ST_TO_ADDR
// if not tmp then
93171: LD_VAR 0 4
93175: NOT
93176: IFFALSE 93180
// continue ;
93178: GO 93095
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
93180: LD_VAR 0 4
93184: PUSH
93185: LD_INT 81
93187: PUSH
93188: LD_VAR 0 3
93192: PUSH
93193: EMPTY
93194: LIST
93195: LIST
93196: PPUSH
93197: CALL_OW 69
93201: IN
93202: PUSH
93203: LD_EXP 76
93207: PUSH
93208: LD_VAR 0 1
93212: ARRAY
93213: PUSH
93214: LD_VAR 0 2
93218: ARRAY
93219: PUSH
93220: LD_INT 1
93222: ARRAY
93223: PPUSH
93224: LD_EXP 76
93228: PUSH
93229: LD_VAR 0 1
93233: ARRAY
93234: PUSH
93235: LD_VAR 0 2
93239: ARRAY
93240: PUSH
93241: LD_INT 2
93243: ARRAY
93244: PPUSH
93245: CALL_OW 458
93249: AND
93250: IFFALSE 93344
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93252: LD_EXP 76
93256: PUSH
93257: LD_VAR 0 1
93261: ARRAY
93262: PUSH
93263: LD_VAR 0 2
93267: ARRAY
93268: PUSH
93269: LD_INT 1
93271: ARRAY
93272: PPUSH
93273: LD_EXP 76
93277: PUSH
93278: LD_VAR 0 1
93282: ARRAY
93283: PUSH
93284: LD_VAR 0 2
93288: ARRAY
93289: PUSH
93290: LD_INT 2
93292: ARRAY
93293: PPUSH
93294: LD_VAR 0 3
93298: PPUSH
93299: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93303: LD_ADDR_EXP 76
93307: PUSH
93308: LD_EXP 76
93312: PPUSH
93313: LD_VAR 0 1
93317: PPUSH
93318: LD_EXP 76
93322: PUSH
93323: LD_VAR 0 1
93327: ARRAY
93328: PPUSH
93329: LD_VAR 0 2
93333: PPUSH
93334: CALL_OW 3
93338: PPUSH
93339: CALL_OW 1
93343: ST_TO_ADDR
// end ; end ;
93344: GO 93095
93346: POP
93347: POP
// end ;
93348: GO 93013
93350: POP
93351: POP
// end ;
93352: PPOPN 4
93354: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93355: LD_INT 0
93357: PPUSH
93358: PPUSH
// result := false ;
93359: LD_ADDR_VAR 0 4
93363: PUSH
93364: LD_INT 0
93366: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93367: LD_VAR 0 1
93371: PPUSH
93372: CALL_OW 264
93376: PUSH
93377: LD_INT 81
93379: EQUAL
93380: NOT
93381: IFFALSE 93385
// exit ;
93383: GO 93625
// index := GetElementIndex ( minersList , unit ) ;
93385: LD_ADDR_VAR 0 5
93389: PUSH
93390: LD_EXP 75
93394: PPUSH
93395: LD_VAR 0 1
93399: PPUSH
93400: CALL 16037 0 2
93404: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93405: LD_EXP 76
93409: PUSH
93410: LD_VAR 0 5
93414: ARRAY
93415: PUSH
93416: LD_EXP 77
93420: GREATEREQUAL
93421: IFFALSE 93425
// exit ;
93423: GO 93625
// ComMoveXY ( unit , x , y ) ;
93425: LD_VAR 0 1
93429: PPUSH
93430: LD_VAR 0 2
93434: PPUSH
93435: LD_VAR 0 3
93439: PPUSH
93440: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93444: LD_INT 35
93446: PPUSH
93447: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93451: LD_VAR 0 1
93455: PPUSH
93456: LD_VAR 0 2
93460: PPUSH
93461: LD_VAR 0 3
93465: PPUSH
93466: CALL 47392 0 3
93470: NOT
93471: PUSH
93472: LD_VAR 0 1
93476: PPUSH
93477: CALL_OW 314
93481: AND
93482: IFFALSE 93486
// exit ;
93484: GO 93625
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93486: LD_VAR 0 2
93490: PPUSH
93491: LD_VAR 0 3
93495: PPUSH
93496: CALL_OW 428
93500: PUSH
93501: LD_VAR 0 1
93505: EQUAL
93506: PUSH
93507: LD_VAR 0 1
93511: PPUSH
93512: CALL_OW 314
93516: NOT
93517: AND
93518: IFFALSE 93444
// PlaySoundXY ( x , y , PlantMine ) ;
93520: LD_VAR 0 2
93524: PPUSH
93525: LD_VAR 0 3
93529: PPUSH
93530: LD_STRING PlantMine
93532: PPUSH
93533: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93537: LD_VAR 0 2
93541: PPUSH
93542: LD_VAR 0 3
93546: PPUSH
93547: LD_VAR 0 1
93551: PPUSH
93552: CALL_OW 255
93556: PPUSH
93557: LD_INT 0
93559: PPUSH
93560: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93564: LD_ADDR_EXP 76
93568: PUSH
93569: LD_EXP 76
93573: PPUSH
93574: LD_VAR 0 5
93578: PUSH
93579: LD_EXP 76
93583: PUSH
93584: LD_VAR 0 5
93588: ARRAY
93589: PUSH
93590: LD_INT 1
93592: PLUS
93593: PUSH
93594: EMPTY
93595: LIST
93596: LIST
93597: PPUSH
93598: LD_VAR 0 2
93602: PUSH
93603: LD_VAR 0 3
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PPUSH
93612: CALL 16252 0 3
93616: ST_TO_ADDR
// result := true ;
93617: LD_ADDR_VAR 0 4
93621: PUSH
93622: LD_INT 1
93624: ST_TO_ADDR
// end ;
93625: LD_VAR 0 4
93629: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93630: LD_INT 0
93632: PPUSH
93633: PPUSH
93634: PPUSH
// if not unit in minersList then
93635: LD_VAR 0 1
93639: PUSH
93640: LD_EXP 75
93644: IN
93645: NOT
93646: IFFALSE 93650
// exit ;
93648: GO 94042
// index := GetElementIndex ( minersList , unit ) ;
93650: LD_ADDR_VAR 0 6
93654: PUSH
93655: LD_EXP 75
93659: PPUSH
93660: LD_VAR 0 1
93664: PPUSH
93665: CALL 16037 0 2
93669: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93670: LD_ADDR_VAR 0 5
93674: PUSH
93675: DOUBLE
93676: LD_EXP 76
93680: PUSH
93681: LD_VAR 0 6
93685: ARRAY
93686: INC
93687: ST_TO_ADDR
93688: LD_INT 1
93690: PUSH
93691: FOR_DOWNTO
93692: IFFALSE 93853
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93694: LD_EXP 76
93698: PUSH
93699: LD_VAR 0 6
93703: ARRAY
93704: PUSH
93705: LD_VAR 0 5
93709: ARRAY
93710: PUSH
93711: LD_INT 1
93713: ARRAY
93714: PUSH
93715: LD_VAR 0 2
93719: EQUAL
93720: PUSH
93721: LD_EXP 76
93725: PUSH
93726: LD_VAR 0 6
93730: ARRAY
93731: PUSH
93732: LD_VAR 0 5
93736: ARRAY
93737: PUSH
93738: LD_INT 2
93740: ARRAY
93741: PUSH
93742: LD_VAR 0 3
93746: EQUAL
93747: AND
93748: IFFALSE 93851
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93750: LD_EXP 76
93754: PUSH
93755: LD_VAR 0 6
93759: ARRAY
93760: PUSH
93761: LD_VAR 0 5
93765: ARRAY
93766: PUSH
93767: LD_INT 1
93769: ARRAY
93770: PPUSH
93771: LD_EXP 76
93775: PUSH
93776: LD_VAR 0 6
93780: ARRAY
93781: PUSH
93782: LD_VAR 0 5
93786: ARRAY
93787: PUSH
93788: LD_INT 2
93790: ARRAY
93791: PPUSH
93792: LD_VAR 0 1
93796: PPUSH
93797: CALL_OW 255
93801: PPUSH
93802: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93806: LD_ADDR_EXP 76
93810: PUSH
93811: LD_EXP 76
93815: PPUSH
93816: LD_VAR 0 6
93820: PPUSH
93821: LD_EXP 76
93825: PUSH
93826: LD_VAR 0 6
93830: ARRAY
93831: PPUSH
93832: LD_VAR 0 5
93836: PPUSH
93837: CALL_OW 3
93841: PPUSH
93842: CALL_OW 1
93846: ST_TO_ADDR
// exit ;
93847: POP
93848: POP
93849: GO 94042
// end ; end ;
93851: GO 93691
93853: POP
93854: POP
// for i := minerMinesList [ index ] downto 1 do
93855: LD_ADDR_VAR 0 5
93859: PUSH
93860: DOUBLE
93861: LD_EXP 76
93865: PUSH
93866: LD_VAR 0 6
93870: ARRAY
93871: INC
93872: ST_TO_ADDR
93873: LD_INT 1
93875: PUSH
93876: FOR_DOWNTO
93877: IFFALSE 94040
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93879: LD_EXP 76
93883: PUSH
93884: LD_VAR 0 6
93888: ARRAY
93889: PUSH
93890: LD_VAR 0 5
93894: ARRAY
93895: PUSH
93896: LD_INT 1
93898: ARRAY
93899: PPUSH
93900: LD_EXP 76
93904: PUSH
93905: LD_VAR 0 6
93909: ARRAY
93910: PUSH
93911: LD_VAR 0 5
93915: ARRAY
93916: PUSH
93917: LD_INT 2
93919: ARRAY
93920: PPUSH
93921: LD_VAR 0 2
93925: PPUSH
93926: LD_VAR 0 3
93930: PPUSH
93931: CALL_OW 298
93935: PUSH
93936: LD_INT 6
93938: LESS
93939: IFFALSE 94038
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93941: LD_EXP 76
93945: PUSH
93946: LD_VAR 0 6
93950: ARRAY
93951: PUSH
93952: LD_VAR 0 5
93956: ARRAY
93957: PUSH
93958: LD_INT 1
93960: ARRAY
93961: PPUSH
93962: LD_EXP 76
93966: PUSH
93967: LD_VAR 0 6
93971: ARRAY
93972: PUSH
93973: LD_VAR 0 5
93977: ARRAY
93978: PUSH
93979: LD_INT 2
93981: ARRAY
93982: PPUSH
93983: LD_VAR 0 1
93987: PPUSH
93988: CALL_OW 255
93992: PPUSH
93993: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93997: LD_ADDR_EXP 76
94001: PUSH
94002: LD_EXP 76
94006: PPUSH
94007: LD_VAR 0 6
94011: PPUSH
94012: LD_EXP 76
94016: PUSH
94017: LD_VAR 0 6
94021: ARRAY
94022: PPUSH
94023: LD_VAR 0 5
94027: PPUSH
94028: CALL_OW 3
94032: PPUSH
94033: CALL_OW 1
94037: ST_TO_ADDR
// end ; end ;
94038: GO 93876
94040: POP
94041: POP
// end ;
94042: LD_VAR 0 4
94046: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
94047: LD_INT 0
94049: PPUSH
94050: PPUSH
94051: PPUSH
94052: PPUSH
94053: PPUSH
94054: PPUSH
94055: PPUSH
94056: PPUSH
94057: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
94058: LD_VAR 0 1
94062: PPUSH
94063: CALL_OW 264
94067: PUSH
94068: LD_INT 81
94070: EQUAL
94071: NOT
94072: PUSH
94073: LD_VAR 0 1
94077: PUSH
94078: LD_EXP 75
94082: IN
94083: NOT
94084: OR
94085: IFFALSE 94089
// exit ;
94087: GO 94411
// index := GetElementIndex ( minersList , unit ) ;
94089: LD_ADDR_VAR 0 6
94093: PUSH
94094: LD_EXP 75
94098: PPUSH
94099: LD_VAR 0 1
94103: PPUSH
94104: CALL 16037 0 2
94108: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
94109: LD_ADDR_VAR 0 8
94113: PUSH
94114: LD_EXP 77
94118: PUSH
94119: LD_EXP 76
94123: PUSH
94124: LD_VAR 0 6
94128: ARRAY
94129: MINUS
94130: ST_TO_ADDR
// if not minesFreeAmount then
94131: LD_VAR 0 8
94135: NOT
94136: IFFALSE 94140
// exit ;
94138: GO 94411
// tmp := [ ] ;
94140: LD_ADDR_VAR 0 7
94144: PUSH
94145: EMPTY
94146: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
94147: LD_ADDR_VAR 0 5
94151: PUSH
94152: DOUBLE
94153: LD_INT 1
94155: DEC
94156: ST_TO_ADDR
94157: LD_VAR 0 8
94161: PUSH
94162: FOR_TO
94163: IFFALSE 94358
// begin _d := rand ( 0 , 5 ) ;
94165: LD_ADDR_VAR 0 11
94169: PUSH
94170: LD_INT 0
94172: PPUSH
94173: LD_INT 5
94175: PPUSH
94176: CALL_OW 12
94180: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
94181: LD_ADDR_VAR 0 12
94185: PUSH
94186: LD_INT 2
94188: PPUSH
94189: LD_INT 6
94191: PPUSH
94192: CALL_OW 12
94196: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
94197: LD_ADDR_VAR 0 9
94201: PUSH
94202: LD_VAR 0 2
94206: PPUSH
94207: LD_VAR 0 11
94211: PPUSH
94212: LD_VAR 0 12
94216: PPUSH
94217: CALL_OW 272
94221: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94222: LD_ADDR_VAR 0 10
94226: PUSH
94227: LD_VAR 0 3
94231: PPUSH
94232: LD_VAR 0 11
94236: PPUSH
94237: LD_VAR 0 12
94241: PPUSH
94242: CALL_OW 273
94246: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94247: LD_VAR 0 9
94251: PPUSH
94252: LD_VAR 0 10
94256: PPUSH
94257: CALL_OW 488
94261: PUSH
94262: LD_VAR 0 9
94266: PUSH
94267: LD_VAR 0 10
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_VAR 0 7
94280: IN
94281: NOT
94282: AND
94283: PUSH
94284: LD_VAR 0 9
94288: PPUSH
94289: LD_VAR 0 10
94293: PPUSH
94294: CALL_OW 458
94298: NOT
94299: AND
94300: IFFALSE 94342
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94302: LD_ADDR_VAR 0 7
94306: PUSH
94307: LD_VAR 0 7
94311: PPUSH
94312: LD_VAR 0 7
94316: PUSH
94317: LD_INT 1
94319: PLUS
94320: PPUSH
94321: LD_VAR 0 9
94325: PUSH
94326: LD_VAR 0 10
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: PPUSH
94335: CALL_OW 1
94339: ST_TO_ADDR
94340: GO 94356
// i := i - 1 ;
94342: LD_ADDR_VAR 0 5
94346: PUSH
94347: LD_VAR 0 5
94351: PUSH
94352: LD_INT 1
94354: MINUS
94355: ST_TO_ADDR
// end ;
94356: GO 94162
94358: POP
94359: POP
// for i in tmp do
94360: LD_ADDR_VAR 0 5
94364: PUSH
94365: LD_VAR 0 7
94369: PUSH
94370: FOR_IN
94371: IFFALSE 94409
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94373: LD_VAR 0 1
94377: PPUSH
94378: LD_VAR 0 5
94382: PUSH
94383: LD_INT 1
94385: ARRAY
94386: PPUSH
94387: LD_VAR 0 5
94391: PUSH
94392: LD_INT 2
94394: ARRAY
94395: PPUSH
94396: CALL 93355 0 3
94400: NOT
94401: IFFALSE 94407
// exit ;
94403: POP
94404: POP
94405: GO 94411
94407: GO 94370
94409: POP
94410: POP
// end ;
94411: LD_VAR 0 4
94415: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94416: LD_INT 0
94418: PPUSH
94419: PPUSH
94420: PPUSH
94421: PPUSH
94422: PPUSH
94423: PPUSH
94424: PPUSH
// if not GetClass ( unit ) = class_sniper then
94425: LD_VAR 0 1
94429: PPUSH
94430: CALL_OW 257
94434: PUSH
94435: LD_INT 5
94437: EQUAL
94438: NOT
94439: IFFALSE 94443
// exit ;
94441: GO 94831
// dist := 8 ;
94443: LD_ADDR_VAR 0 5
94447: PUSH
94448: LD_INT 8
94450: ST_TO_ADDR
// viewRange := 12 ;
94451: LD_ADDR_VAR 0 7
94455: PUSH
94456: LD_INT 12
94458: ST_TO_ADDR
// side := GetSide ( unit ) ;
94459: LD_ADDR_VAR 0 6
94463: PUSH
94464: LD_VAR 0 1
94468: PPUSH
94469: CALL_OW 255
94473: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94474: LD_INT 61
94476: PPUSH
94477: LD_VAR 0 6
94481: PPUSH
94482: CALL_OW 321
94486: PUSH
94487: LD_INT 2
94489: EQUAL
94490: IFFALSE 94500
// viewRange := 16 ;
94492: LD_ADDR_VAR 0 7
94496: PUSH
94497: LD_INT 16
94499: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94500: LD_VAR 0 1
94504: PPUSH
94505: LD_VAR 0 2
94509: PPUSH
94510: LD_VAR 0 3
94514: PPUSH
94515: CALL_OW 297
94519: PUSH
94520: LD_VAR 0 5
94524: GREATER
94525: IFFALSE 94604
// begin ComMoveXY ( unit , x , y ) ;
94527: LD_VAR 0 1
94531: PPUSH
94532: LD_VAR 0 2
94536: PPUSH
94537: LD_VAR 0 3
94541: PPUSH
94542: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94546: LD_INT 35
94548: PPUSH
94549: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94553: LD_VAR 0 1
94557: PPUSH
94558: LD_VAR 0 2
94562: PPUSH
94563: LD_VAR 0 3
94567: PPUSH
94568: CALL 47392 0 3
94572: NOT
94573: IFFALSE 94577
// exit ;
94575: GO 94831
// until GetDistUnitXY ( unit , x , y ) < dist ;
94577: LD_VAR 0 1
94581: PPUSH
94582: LD_VAR 0 2
94586: PPUSH
94587: LD_VAR 0 3
94591: PPUSH
94592: CALL_OW 297
94596: PUSH
94597: LD_VAR 0 5
94601: LESS
94602: IFFALSE 94546
// end ; ComTurnXY ( unit , x , y ) ;
94604: LD_VAR 0 1
94608: PPUSH
94609: LD_VAR 0 2
94613: PPUSH
94614: LD_VAR 0 3
94618: PPUSH
94619: CALL_OW 118
// wait ( 5 ) ;
94623: LD_INT 5
94625: PPUSH
94626: CALL_OW 67
// _d := GetDir ( unit ) ;
94630: LD_ADDR_VAR 0 10
94634: PUSH
94635: LD_VAR 0 1
94639: PPUSH
94640: CALL_OW 254
94644: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94645: LD_ADDR_VAR 0 8
94649: PUSH
94650: LD_VAR 0 1
94654: PPUSH
94655: CALL_OW 250
94659: PPUSH
94660: LD_VAR 0 10
94664: PPUSH
94665: LD_VAR 0 5
94669: PPUSH
94670: CALL_OW 272
94674: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94675: LD_ADDR_VAR 0 9
94679: PUSH
94680: LD_VAR 0 1
94684: PPUSH
94685: CALL_OW 251
94689: PPUSH
94690: LD_VAR 0 10
94694: PPUSH
94695: LD_VAR 0 5
94699: PPUSH
94700: CALL_OW 273
94704: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94705: LD_VAR 0 8
94709: PPUSH
94710: LD_VAR 0 9
94714: PPUSH
94715: CALL_OW 488
94719: NOT
94720: IFFALSE 94724
// exit ;
94722: GO 94831
// ComAnimCustom ( unit , 1 ) ;
94724: LD_VAR 0 1
94728: PPUSH
94729: LD_INT 1
94731: PPUSH
94732: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94736: LD_VAR 0 8
94740: PPUSH
94741: LD_VAR 0 9
94745: PPUSH
94746: LD_VAR 0 6
94750: PPUSH
94751: LD_VAR 0 7
94755: PPUSH
94756: CALL_OW 330
// repeat wait ( 1 ) ;
94760: LD_INT 1
94762: PPUSH
94763: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94767: LD_VAR 0 1
94771: PPUSH
94772: CALL_OW 316
94776: PUSH
94777: LD_VAR 0 1
94781: PPUSH
94782: CALL_OW 314
94786: OR
94787: PUSH
94788: LD_VAR 0 1
94792: PPUSH
94793: CALL_OW 302
94797: NOT
94798: OR
94799: PUSH
94800: LD_VAR 0 1
94804: PPUSH
94805: CALL_OW 301
94809: OR
94810: IFFALSE 94760
// RemoveSeeing ( _x , _y , side ) ;
94812: LD_VAR 0 8
94816: PPUSH
94817: LD_VAR 0 9
94821: PPUSH
94822: LD_VAR 0 6
94826: PPUSH
94827: CALL_OW 331
// end ; end_of_file end_of_file
94831: LD_VAR 0 4
94835: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94836: LD_VAR 0 1
94840: PUSH
94841: LD_INT 200
94843: DOUBLE
94844: GREATEREQUAL
94845: IFFALSE 94853
94847: LD_INT 299
94849: DOUBLE
94850: LESSEQUAL
94851: IFTRUE 94855
94853: GO 94887
94855: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94856: LD_VAR 0 1
94860: PPUSH
94861: LD_VAR 0 2
94865: PPUSH
94866: LD_VAR 0 3
94870: PPUSH
94871: LD_VAR 0 4
94875: PPUSH
94876: LD_VAR 0 5
94880: PPUSH
94881: CALL 90923 0 5
94885: GO 94964
94887: LD_INT 300
94889: DOUBLE
94890: GREATEREQUAL
94891: IFFALSE 94899
94893: LD_INT 399
94895: DOUBLE
94896: LESSEQUAL
94897: IFTRUE 94901
94899: GO 94963
94901: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94902: LD_VAR 0 1
94906: PPUSH
94907: LD_VAR 0 2
94911: PPUSH
94912: LD_VAR 0 3
94916: PPUSH
94917: LD_VAR 0 4
94921: PPUSH
94922: LD_VAR 0 5
94926: PPUSH
94927: LD_VAR 0 6
94931: PPUSH
94932: LD_VAR 0 7
94936: PPUSH
94937: LD_VAR 0 8
94941: PPUSH
94942: LD_VAR 0 9
94946: PPUSH
94947: LD_VAR 0 10
94951: PPUSH
94952: LD_VAR 0 11
94956: PPUSH
94957: CALL 107502 0 11
94961: GO 94964
94963: POP
// end ;
94964: PPOPN 11
94966: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94967: LD_VAR 0 1
94971: PPUSH
94972: LD_VAR 0 2
94976: PPUSH
94977: LD_VAR 0 3
94981: PPUSH
94982: LD_VAR 0 4
94986: PPUSH
94987: LD_VAR 0 5
94991: PPUSH
94992: CALL 90659 0 5
// end ; end_of_file
94996: PPOPN 5
94998: END
// export globalGameSaveCounter ; every 0 0$1 do
94999: GO 95001
95001: DISABLE
// begin enable ;
95002: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
95003: LD_STRING updateTimer(
95005: PUSH
95006: LD_OWVAR 1
95010: STR
95011: PUSH
95012: LD_STRING );
95014: STR
95015: PPUSH
95016: CALL_OW 559
// end ;
95020: END
// every 0 0$1 do
95021: GO 95023
95023: DISABLE
// begin globalGameSaveCounter := 0 ;
95024: LD_ADDR_EXP 78
95028: PUSH
95029: LD_INT 0
95031: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
95032: LD_STRING setGameSaveCounter(0)
95034: PPUSH
95035: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
95039: LD_STRING initStreamRollete();
95041: PPUSH
95042: CALL_OW 559
// InitStreamMode ;
95046: CALL 96372 0 0
// DefineStreamItems ( false ) ;
95050: LD_INT 0
95052: PPUSH
95053: CALL 96836 0 1
// end ;
95057: END
// export function SOS_MapStart ( ) ; begin
95058: LD_INT 0
95060: PPUSH
// if streamModeActive then
95061: LD_EXP 79
95065: IFFALSE 95074
// DefineStreamItems ( true ) ;
95067: LD_INT 1
95069: PPUSH
95070: CALL 96836 0 1
// UpdateLuaVariables ( ) ;
95074: CALL 95091 0 0
// UpdateFactoryWaypoints ( ) ;
95078: CALL 109697 0 0
// UpdateWarehouseGatheringPoints ( ) ;
95082: CALL 109954 0 0
// end ;
95086: LD_VAR 0 1
95090: RET
// function UpdateLuaVariables ( ) ; begin
95091: LD_INT 0
95093: PPUSH
// if globalGameSaveCounter then
95094: LD_EXP 78
95098: IFFALSE 95132
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
95100: LD_ADDR_EXP 78
95104: PUSH
95105: LD_EXP 78
95109: PPUSH
95110: CALL 49944 0 1
95114: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
95115: LD_STRING setGameSaveCounter(
95117: PUSH
95118: LD_EXP 78
95122: STR
95123: PUSH
95124: LD_STRING )
95126: STR
95127: PPUSH
95128: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
95132: LD_STRING setGameDifficulty(
95134: PUSH
95135: LD_OWVAR 67
95139: STR
95140: PUSH
95141: LD_STRING )
95143: STR
95144: PPUSH
95145: CALL_OW 559
// end ;
95149: LD_VAR 0 1
95153: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95154: LD_INT 0
95156: PPUSH
// if p2 = stream_mode then
95157: LD_VAR 0 2
95161: PUSH
95162: LD_INT 100
95164: EQUAL
95165: IFFALSE 96168
// begin if not StreamModeActive then
95167: LD_EXP 79
95171: NOT
95172: IFFALSE 95182
// StreamModeActive := true ;
95174: LD_ADDR_EXP 79
95178: PUSH
95179: LD_INT 1
95181: ST_TO_ADDR
// if p3 = 0 then
95182: LD_VAR 0 3
95186: PUSH
95187: LD_INT 0
95189: EQUAL
95190: IFFALSE 95196
// InitStreamMode ;
95192: CALL 96372 0 0
// if p3 = 1 then
95196: LD_VAR 0 3
95200: PUSH
95201: LD_INT 1
95203: EQUAL
95204: IFFALSE 95214
// sRocket := true ;
95206: LD_ADDR_EXP 84
95210: PUSH
95211: LD_INT 1
95213: ST_TO_ADDR
// if p3 = 2 then
95214: LD_VAR 0 3
95218: PUSH
95219: LD_INT 2
95221: EQUAL
95222: IFFALSE 95232
// sSpeed := true ;
95224: LD_ADDR_EXP 83
95228: PUSH
95229: LD_INT 1
95231: ST_TO_ADDR
// if p3 = 3 then
95232: LD_VAR 0 3
95236: PUSH
95237: LD_INT 3
95239: EQUAL
95240: IFFALSE 95250
// sEngine := true ;
95242: LD_ADDR_EXP 85
95246: PUSH
95247: LD_INT 1
95249: ST_TO_ADDR
// if p3 = 4 then
95250: LD_VAR 0 3
95254: PUSH
95255: LD_INT 4
95257: EQUAL
95258: IFFALSE 95268
// sSpec := true ;
95260: LD_ADDR_EXP 82
95264: PUSH
95265: LD_INT 1
95267: ST_TO_ADDR
// if p3 = 5 then
95268: LD_VAR 0 3
95272: PUSH
95273: LD_INT 5
95275: EQUAL
95276: IFFALSE 95286
// sLevel := true ;
95278: LD_ADDR_EXP 86
95282: PUSH
95283: LD_INT 1
95285: ST_TO_ADDR
// if p3 = 6 then
95286: LD_VAR 0 3
95290: PUSH
95291: LD_INT 6
95293: EQUAL
95294: IFFALSE 95304
// sArmoury := true ;
95296: LD_ADDR_EXP 87
95300: PUSH
95301: LD_INT 1
95303: ST_TO_ADDR
// if p3 = 7 then
95304: LD_VAR 0 3
95308: PUSH
95309: LD_INT 7
95311: EQUAL
95312: IFFALSE 95322
// sRadar := true ;
95314: LD_ADDR_EXP 88
95318: PUSH
95319: LD_INT 1
95321: ST_TO_ADDR
// if p3 = 8 then
95322: LD_VAR 0 3
95326: PUSH
95327: LD_INT 8
95329: EQUAL
95330: IFFALSE 95340
// sBunker := true ;
95332: LD_ADDR_EXP 89
95336: PUSH
95337: LD_INT 1
95339: ST_TO_ADDR
// if p3 = 9 then
95340: LD_VAR 0 3
95344: PUSH
95345: LD_INT 9
95347: EQUAL
95348: IFFALSE 95358
// sHack := true ;
95350: LD_ADDR_EXP 90
95354: PUSH
95355: LD_INT 1
95357: ST_TO_ADDR
// if p3 = 10 then
95358: LD_VAR 0 3
95362: PUSH
95363: LD_INT 10
95365: EQUAL
95366: IFFALSE 95376
// sFire := true ;
95368: LD_ADDR_EXP 91
95372: PUSH
95373: LD_INT 1
95375: ST_TO_ADDR
// if p3 = 11 then
95376: LD_VAR 0 3
95380: PUSH
95381: LD_INT 11
95383: EQUAL
95384: IFFALSE 95394
// sRefresh := true ;
95386: LD_ADDR_EXP 92
95390: PUSH
95391: LD_INT 1
95393: ST_TO_ADDR
// if p3 = 12 then
95394: LD_VAR 0 3
95398: PUSH
95399: LD_INT 12
95401: EQUAL
95402: IFFALSE 95412
// sExp := true ;
95404: LD_ADDR_EXP 93
95408: PUSH
95409: LD_INT 1
95411: ST_TO_ADDR
// if p3 = 13 then
95412: LD_VAR 0 3
95416: PUSH
95417: LD_INT 13
95419: EQUAL
95420: IFFALSE 95430
// sDepot := true ;
95422: LD_ADDR_EXP 94
95426: PUSH
95427: LD_INT 1
95429: ST_TO_ADDR
// if p3 = 14 then
95430: LD_VAR 0 3
95434: PUSH
95435: LD_INT 14
95437: EQUAL
95438: IFFALSE 95448
// sFlag := true ;
95440: LD_ADDR_EXP 95
95444: PUSH
95445: LD_INT 1
95447: ST_TO_ADDR
// if p3 = 15 then
95448: LD_VAR 0 3
95452: PUSH
95453: LD_INT 15
95455: EQUAL
95456: IFFALSE 95466
// sKamikadze := true ;
95458: LD_ADDR_EXP 103
95462: PUSH
95463: LD_INT 1
95465: ST_TO_ADDR
// if p3 = 16 then
95466: LD_VAR 0 3
95470: PUSH
95471: LD_INT 16
95473: EQUAL
95474: IFFALSE 95484
// sTroll := true ;
95476: LD_ADDR_EXP 104
95480: PUSH
95481: LD_INT 1
95483: ST_TO_ADDR
// if p3 = 17 then
95484: LD_VAR 0 3
95488: PUSH
95489: LD_INT 17
95491: EQUAL
95492: IFFALSE 95502
// sSlow := true ;
95494: LD_ADDR_EXP 105
95498: PUSH
95499: LD_INT 1
95501: ST_TO_ADDR
// if p3 = 18 then
95502: LD_VAR 0 3
95506: PUSH
95507: LD_INT 18
95509: EQUAL
95510: IFFALSE 95520
// sLack := true ;
95512: LD_ADDR_EXP 106
95516: PUSH
95517: LD_INT 1
95519: ST_TO_ADDR
// if p3 = 19 then
95520: LD_VAR 0 3
95524: PUSH
95525: LD_INT 19
95527: EQUAL
95528: IFFALSE 95538
// sTank := true ;
95530: LD_ADDR_EXP 108
95534: PUSH
95535: LD_INT 1
95537: ST_TO_ADDR
// if p3 = 20 then
95538: LD_VAR 0 3
95542: PUSH
95543: LD_INT 20
95545: EQUAL
95546: IFFALSE 95556
// sRemote := true ;
95548: LD_ADDR_EXP 109
95552: PUSH
95553: LD_INT 1
95555: ST_TO_ADDR
// if p3 = 21 then
95556: LD_VAR 0 3
95560: PUSH
95561: LD_INT 21
95563: EQUAL
95564: IFFALSE 95574
// sPowell := true ;
95566: LD_ADDR_EXP 110
95570: PUSH
95571: LD_INT 1
95573: ST_TO_ADDR
// if p3 = 22 then
95574: LD_VAR 0 3
95578: PUSH
95579: LD_INT 22
95581: EQUAL
95582: IFFALSE 95592
// sTeleport := true ;
95584: LD_ADDR_EXP 113
95588: PUSH
95589: LD_INT 1
95591: ST_TO_ADDR
// if p3 = 23 then
95592: LD_VAR 0 3
95596: PUSH
95597: LD_INT 23
95599: EQUAL
95600: IFFALSE 95610
// sOilTower := true ;
95602: LD_ADDR_EXP 115
95606: PUSH
95607: LD_INT 1
95609: ST_TO_ADDR
// if p3 = 24 then
95610: LD_VAR 0 3
95614: PUSH
95615: LD_INT 24
95617: EQUAL
95618: IFFALSE 95628
// sShovel := true ;
95620: LD_ADDR_EXP 116
95624: PUSH
95625: LD_INT 1
95627: ST_TO_ADDR
// if p3 = 25 then
95628: LD_VAR 0 3
95632: PUSH
95633: LD_INT 25
95635: EQUAL
95636: IFFALSE 95646
// sSheik := true ;
95638: LD_ADDR_EXP 117
95642: PUSH
95643: LD_INT 1
95645: ST_TO_ADDR
// if p3 = 26 then
95646: LD_VAR 0 3
95650: PUSH
95651: LD_INT 26
95653: EQUAL
95654: IFFALSE 95664
// sEarthquake := true ;
95656: LD_ADDR_EXP 119
95660: PUSH
95661: LD_INT 1
95663: ST_TO_ADDR
// if p3 = 27 then
95664: LD_VAR 0 3
95668: PUSH
95669: LD_INT 27
95671: EQUAL
95672: IFFALSE 95682
// sAI := true ;
95674: LD_ADDR_EXP 120
95678: PUSH
95679: LD_INT 1
95681: ST_TO_ADDR
// if p3 = 28 then
95682: LD_VAR 0 3
95686: PUSH
95687: LD_INT 28
95689: EQUAL
95690: IFFALSE 95700
// sCargo := true ;
95692: LD_ADDR_EXP 123
95696: PUSH
95697: LD_INT 1
95699: ST_TO_ADDR
// if p3 = 29 then
95700: LD_VAR 0 3
95704: PUSH
95705: LD_INT 29
95707: EQUAL
95708: IFFALSE 95718
// sDLaser := true ;
95710: LD_ADDR_EXP 124
95714: PUSH
95715: LD_INT 1
95717: ST_TO_ADDR
// if p3 = 30 then
95718: LD_VAR 0 3
95722: PUSH
95723: LD_INT 30
95725: EQUAL
95726: IFFALSE 95736
// sExchange := true ;
95728: LD_ADDR_EXP 125
95732: PUSH
95733: LD_INT 1
95735: ST_TO_ADDR
// if p3 = 31 then
95736: LD_VAR 0 3
95740: PUSH
95741: LD_INT 31
95743: EQUAL
95744: IFFALSE 95754
// sFac := true ;
95746: LD_ADDR_EXP 126
95750: PUSH
95751: LD_INT 1
95753: ST_TO_ADDR
// if p3 = 32 then
95754: LD_VAR 0 3
95758: PUSH
95759: LD_INT 32
95761: EQUAL
95762: IFFALSE 95772
// sPower := true ;
95764: LD_ADDR_EXP 127
95768: PUSH
95769: LD_INT 1
95771: ST_TO_ADDR
// if p3 = 33 then
95772: LD_VAR 0 3
95776: PUSH
95777: LD_INT 33
95779: EQUAL
95780: IFFALSE 95790
// sRandom := true ;
95782: LD_ADDR_EXP 128
95786: PUSH
95787: LD_INT 1
95789: ST_TO_ADDR
// if p3 = 34 then
95790: LD_VAR 0 3
95794: PUSH
95795: LD_INT 34
95797: EQUAL
95798: IFFALSE 95808
// sShield := true ;
95800: LD_ADDR_EXP 129
95804: PUSH
95805: LD_INT 1
95807: ST_TO_ADDR
// if p3 = 35 then
95808: LD_VAR 0 3
95812: PUSH
95813: LD_INT 35
95815: EQUAL
95816: IFFALSE 95826
// sTime := true ;
95818: LD_ADDR_EXP 130
95822: PUSH
95823: LD_INT 1
95825: ST_TO_ADDR
// if p3 = 36 then
95826: LD_VAR 0 3
95830: PUSH
95831: LD_INT 36
95833: EQUAL
95834: IFFALSE 95844
// sTools := true ;
95836: LD_ADDR_EXP 131
95840: PUSH
95841: LD_INT 1
95843: ST_TO_ADDR
// if p3 = 101 then
95844: LD_VAR 0 3
95848: PUSH
95849: LD_INT 101
95851: EQUAL
95852: IFFALSE 95862
// sSold := true ;
95854: LD_ADDR_EXP 96
95858: PUSH
95859: LD_INT 1
95861: ST_TO_ADDR
// if p3 = 102 then
95862: LD_VAR 0 3
95866: PUSH
95867: LD_INT 102
95869: EQUAL
95870: IFFALSE 95880
// sDiff := true ;
95872: LD_ADDR_EXP 97
95876: PUSH
95877: LD_INT 1
95879: ST_TO_ADDR
// if p3 = 103 then
95880: LD_VAR 0 3
95884: PUSH
95885: LD_INT 103
95887: EQUAL
95888: IFFALSE 95898
// sFog := true ;
95890: LD_ADDR_EXP 100
95894: PUSH
95895: LD_INT 1
95897: ST_TO_ADDR
// if p3 = 104 then
95898: LD_VAR 0 3
95902: PUSH
95903: LD_INT 104
95905: EQUAL
95906: IFFALSE 95916
// sReset := true ;
95908: LD_ADDR_EXP 101
95912: PUSH
95913: LD_INT 1
95915: ST_TO_ADDR
// if p3 = 105 then
95916: LD_VAR 0 3
95920: PUSH
95921: LD_INT 105
95923: EQUAL
95924: IFFALSE 95934
// sSun := true ;
95926: LD_ADDR_EXP 102
95930: PUSH
95931: LD_INT 1
95933: ST_TO_ADDR
// if p3 = 106 then
95934: LD_VAR 0 3
95938: PUSH
95939: LD_INT 106
95941: EQUAL
95942: IFFALSE 95952
// sTiger := true ;
95944: LD_ADDR_EXP 98
95948: PUSH
95949: LD_INT 1
95951: ST_TO_ADDR
// if p3 = 107 then
95952: LD_VAR 0 3
95956: PUSH
95957: LD_INT 107
95959: EQUAL
95960: IFFALSE 95970
// sBomb := true ;
95962: LD_ADDR_EXP 99
95966: PUSH
95967: LD_INT 1
95969: ST_TO_ADDR
// if p3 = 108 then
95970: LD_VAR 0 3
95974: PUSH
95975: LD_INT 108
95977: EQUAL
95978: IFFALSE 95988
// sWound := true ;
95980: LD_ADDR_EXP 107
95984: PUSH
95985: LD_INT 1
95987: ST_TO_ADDR
// if p3 = 109 then
95988: LD_VAR 0 3
95992: PUSH
95993: LD_INT 109
95995: EQUAL
95996: IFFALSE 96006
// sBetray := true ;
95998: LD_ADDR_EXP 111
96002: PUSH
96003: LD_INT 1
96005: ST_TO_ADDR
// if p3 = 110 then
96006: LD_VAR 0 3
96010: PUSH
96011: LD_INT 110
96013: EQUAL
96014: IFFALSE 96024
// sContamin := true ;
96016: LD_ADDR_EXP 112
96020: PUSH
96021: LD_INT 1
96023: ST_TO_ADDR
// if p3 = 111 then
96024: LD_VAR 0 3
96028: PUSH
96029: LD_INT 111
96031: EQUAL
96032: IFFALSE 96042
// sOil := true ;
96034: LD_ADDR_EXP 114
96038: PUSH
96039: LD_INT 1
96041: ST_TO_ADDR
// if p3 = 112 then
96042: LD_VAR 0 3
96046: PUSH
96047: LD_INT 112
96049: EQUAL
96050: IFFALSE 96060
// sStu := true ;
96052: LD_ADDR_EXP 118
96056: PUSH
96057: LD_INT 1
96059: ST_TO_ADDR
// if p3 = 113 then
96060: LD_VAR 0 3
96064: PUSH
96065: LD_INT 113
96067: EQUAL
96068: IFFALSE 96078
// sBazooka := true ;
96070: LD_ADDR_EXP 121
96074: PUSH
96075: LD_INT 1
96077: ST_TO_ADDR
// if p3 = 114 then
96078: LD_VAR 0 3
96082: PUSH
96083: LD_INT 114
96085: EQUAL
96086: IFFALSE 96096
// sMortar := true ;
96088: LD_ADDR_EXP 122
96092: PUSH
96093: LD_INT 1
96095: ST_TO_ADDR
// if p3 = 115 then
96096: LD_VAR 0 3
96100: PUSH
96101: LD_INT 115
96103: EQUAL
96104: IFFALSE 96114
// sRanger := true ;
96106: LD_ADDR_EXP 132
96110: PUSH
96111: LD_INT 1
96113: ST_TO_ADDR
// if p3 = 116 then
96114: LD_VAR 0 3
96118: PUSH
96119: LD_INT 116
96121: EQUAL
96122: IFFALSE 96132
// sComputer := true ;
96124: LD_ADDR_EXP 133
96128: PUSH
96129: LD_INT 1
96131: ST_TO_ADDR
// if p3 = 117 then
96132: LD_VAR 0 3
96136: PUSH
96137: LD_INT 117
96139: EQUAL
96140: IFFALSE 96150
// s30 := true ;
96142: LD_ADDR_EXP 134
96146: PUSH
96147: LD_INT 1
96149: ST_TO_ADDR
// if p3 = 118 then
96150: LD_VAR 0 3
96154: PUSH
96155: LD_INT 118
96157: EQUAL
96158: IFFALSE 96168
// s60 := true ;
96160: LD_ADDR_EXP 135
96164: PUSH
96165: LD_INT 1
96167: ST_TO_ADDR
// end ; if p2 = hack_mode then
96168: LD_VAR 0 2
96172: PUSH
96173: LD_INT 101
96175: EQUAL
96176: IFFALSE 96304
// begin case p3 of 1 :
96178: LD_VAR 0 3
96182: PUSH
96183: LD_INT 1
96185: DOUBLE
96186: EQUAL
96187: IFTRUE 96191
96189: GO 96198
96191: POP
// hHackUnlimitedResources ; 2 :
96192: CALL 108443 0 0
96196: GO 96304
96198: LD_INT 2
96200: DOUBLE
96201: EQUAL
96202: IFTRUE 96206
96204: GO 96213
96206: POP
// hHackSetLevel10 ; 3 :
96207: CALL 108576 0 0
96211: GO 96304
96213: LD_INT 3
96215: DOUBLE
96216: EQUAL
96217: IFTRUE 96221
96219: GO 96228
96221: POP
// hHackSetLevel10YourUnits ; 4 :
96222: CALL 108661 0 0
96226: GO 96304
96228: LD_INT 4
96230: DOUBLE
96231: EQUAL
96232: IFTRUE 96236
96234: GO 96243
96236: POP
// hHackInvincible ; 5 :
96237: CALL 109109 0 0
96241: GO 96304
96243: LD_INT 5
96245: DOUBLE
96246: EQUAL
96247: IFTRUE 96251
96249: GO 96258
96251: POP
// hHackInvisible ; 6 :
96252: CALL 109220 0 0
96256: GO 96304
96258: LD_INT 6
96260: DOUBLE
96261: EQUAL
96262: IFTRUE 96266
96264: GO 96273
96266: POP
// hHackChangeYourSide ; 7 :
96267: CALL 109277 0 0
96271: GO 96304
96273: LD_INT 7
96275: DOUBLE
96276: EQUAL
96277: IFTRUE 96281
96279: GO 96288
96281: POP
// hHackChangeUnitSide ; 8 :
96282: CALL 109319 0 0
96286: GO 96304
96288: LD_INT 8
96290: DOUBLE
96291: EQUAL
96292: IFTRUE 96296
96294: GO 96303
96296: POP
// hHackFog ; end ;
96297: CALL 109420 0 0
96301: GO 96304
96303: POP
// end ; if p2 = game_save_mode then
96304: LD_VAR 0 2
96308: PUSH
96309: LD_INT 102
96311: EQUAL
96312: IFFALSE 96367
// begin if p3 = 1 then
96314: LD_VAR 0 3
96318: PUSH
96319: LD_INT 1
96321: EQUAL
96322: IFFALSE 96334
// globalGameSaveCounter := p4 ;
96324: LD_ADDR_EXP 78
96328: PUSH
96329: LD_VAR 0 4
96333: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96334: LD_VAR 0 3
96338: PUSH
96339: LD_INT 2
96341: EQUAL
96342: PUSH
96343: LD_EXP 78
96347: AND
96348: IFFALSE 96367
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96350: LD_STRING setGameSaveCounter(
96352: PUSH
96353: LD_EXP 78
96357: STR
96358: PUSH
96359: LD_STRING )
96361: STR
96362: PPUSH
96363: CALL_OW 559
// end ; end ;
96367: LD_VAR 0 7
96371: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
96372: LD_INT 0
96374: PPUSH
// streamModeActive := false ;
96375: LD_ADDR_EXP 79
96379: PUSH
96380: LD_INT 0
96382: ST_TO_ADDR
// normalCounter := 36 ;
96383: LD_ADDR_EXP 80
96387: PUSH
96388: LD_INT 36
96390: ST_TO_ADDR
// hardcoreCounter := 18 ;
96391: LD_ADDR_EXP 81
96395: PUSH
96396: LD_INT 18
96398: ST_TO_ADDR
// sRocket := false ;
96399: LD_ADDR_EXP 84
96403: PUSH
96404: LD_INT 0
96406: ST_TO_ADDR
// sSpeed := false ;
96407: LD_ADDR_EXP 83
96411: PUSH
96412: LD_INT 0
96414: ST_TO_ADDR
// sEngine := false ;
96415: LD_ADDR_EXP 85
96419: PUSH
96420: LD_INT 0
96422: ST_TO_ADDR
// sSpec := false ;
96423: LD_ADDR_EXP 82
96427: PUSH
96428: LD_INT 0
96430: ST_TO_ADDR
// sLevel := false ;
96431: LD_ADDR_EXP 86
96435: PUSH
96436: LD_INT 0
96438: ST_TO_ADDR
// sArmoury := false ;
96439: LD_ADDR_EXP 87
96443: PUSH
96444: LD_INT 0
96446: ST_TO_ADDR
// sRadar := false ;
96447: LD_ADDR_EXP 88
96451: PUSH
96452: LD_INT 0
96454: ST_TO_ADDR
// sBunker := false ;
96455: LD_ADDR_EXP 89
96459: PUSH
96460: LD_INT 0
96462: ST_TO_ADDR
// sHack := false ;
96463: LD_ADDR_EXP 90
96467: PUSH
96468: LD_INT 0
96470: ST_TO_ADDR
// sFire := false ;
96471: LD_ADDR_EXP 91
96475: PUSH
96476: LD_INT 0
96478: ST_TO_ADDR
// sRefresh := false ;
96479: LD_ADDR_EXP 92
96483: PUSH
96484: LD_INT 0
96486: ST_TO_ADDR
// sExp := false ;
96487: LD_ADDR_EXP 93
96491: PUSH
96492: LD_INT 0
96494: ST_TO_ADDR
// sDepot := false ;
96495: LD_ADDR_EXP 94
96499: PUSH
96500: LD_INT 0
96502: ST_TO_ADDR
// sFlag := false ;
96503: LD_ADDR_EXP 95
96507: PUSH
96508: LD_INT 0
96510: ST_TO_ADDR
// sKamikadze := false ;
96511: LD_ADDR_EXP 103
96515: PUSH
96516: LD_INT 0
96518: ST_TO_ADDR
// sTroll := false ;
96519: LD_ADDR_EXP 104
96523: PUSH
96524: LD_INT 0
96526: ST_TO_ADDR
// sSlow := false ;
96527: LD_ADDR_EXP 105
96531: PUSH
96532: LD_INT 0
96534: ST_TO_ADDR
// sLack := false ;
96535: LD_ADDR_EXP 106
96539: PUSH
96540: LD_INT 0
96542: ST_TO_ADDR
// sTank := false ;
96543: LD_ADDR_EXP 108
96547: PUSH
96548: LD_INT 0
96550: ST_TO_ADDR
// sRemote := false ;
96551: LD_ADDR_EXP 109
96555: PUSH
96556: LD_INT 0
96558: ST_TO_ADDR
// sPowell := false ;
96559: LD_ADDR_EXP 110
96563: PUSH
96564: LD_INT 0
96566: ST_TO_ADDR
// sTeleport := false ;
96567: LD_ADDR_EXP 113
96571: PUSH
96572: LD_INT 0
96574: ST_TO_ADDR
// sOilTower := false ;
96575: LD_ADDR_EXP 115
96579: PUSH
96580: LD_INT 0
96582: ST_TO_ADDR
// sShovel := false ;
96583: LD_ADDR_EXP 116
96587: PUSH
96588: LD_INT 0
96590: ST_TO_ADDR
// sSheik := false ;
96591: LD_ADDR_EXP 117
96595: PUSH
96596: LD_INT 0
96598: ST_TO_ADDR
// sEarthquake := false ;
96599: LD_ADDR_EXP 119
96603: PUSH
96604: LD_INT 0
96606: ST_TO_ADDR
// sAI := false ;
96607: LD_ADDR_EXP 120
96611: PUSH
96612: LD_INT 0
96614: ST_TO_ADDR
// sCargo := false ;
96615: LD_ADDR_EXP 123
96619: PUSH
96620: LD_INT 0
96622: ST_TO_ADDR
// sDLaser := false ;
96623: LD_ADDR_EXP 124
96627: PUSH
96628: LD_INT 0
96630: ST_TO_ADDR
// sExchange := false ;
96631: LD_ADDR_EXP 125
96635: PUSH
96636: LD_INT 0
96638: ST_TO_ADDR
// sFac := false ;
96639: LD_ADDR_EXP 126
96643: PUSH
96644: LD_INT 0
96646: ST_TO_ADDR
// sPower := false ;
96647: LD_ADDR_EXP 127
96651: PUSH
96652: LD_INT 0
96654: ST_TO_ADDR
// sRandom := false ;
96655: LD_ADDR_EXP 128
96659: PUSH
96660: LD_INT 0
96662: ST_TO_ADDR
// sShield := false ;
96663: LD_ADDR_EXP 129
96667: PUSH
96668: LD_INT 0
96670: ST_TO_ADDR
// sTime := false ;
96671: LD_ADDR_EXP 130
96675: PUSH
96676: LD_INT 0
96678: ST_TO_ADDR
// sTools := false ;
96679: LD_ADDR_EXP 131
96683: PUSH
96684: LD_INT 0
96686: ST_TO_ADDR
// sSold := false ;
96687: LD_ADDR_EXP 96
96691: PUSH
96692: LD_INT 0
96694: ST_TO_ADDR
// sDiff := false ;
96695: LD_ADDR_EXP 97
96699: PUSH
96700: LD_INT 0
96702: ST_TO_ADDR
// sFog := false ;
96703: LD_ADDR_EXP 100
96707: PUSH
96708: LD_INT 0
96710: ST_TO_ADDR
// sReset := false ;
96711: LD_ADDR_EXP 101
96715: PUSH
96716: LD_INT 0
96718: ST_TO_ADDR
// sSun := false ;
96719: LD_ADDR_EXP 102
96723: PUSH
96724: LD_INT 0
96726: ST_TO_ADDR
// sTiger := false ;
96727: LD_ADDR_EXP 98
96731: PUSH
96732: LD_INT 0
96734: ST_TO_ADDR
// sBomb := false ;
96735: LD_ADDR_EXP 99
96739: PUSH
96740: LD_INT 0
96742: ST_TO_ADDR
// sWound := false ;
96743: LD_ADDR_EXP 107
96747: PUSH
96748: LD_INT 0
96750: ST_TO_ADDR
// sBetray := false ;
96751: LD_ADDR_EXP 111
96755: PUSH
96756: LD_INT 0
96758: ST_TO_ADDR
// sContamin := false ;
96759: LD_ADDR_EXP 112
96763: PUSH
96764: LD_INT 0
96766: ST_TO_ADDR
// sOil := false ;
96767: LD_ADDR_EXP 114
96771: PUSH
96772: LD_INT 0
96774: ST_TO_ADDR
// sStu := false ;
96775: LD_ADDR_EXP 118
96779: PUSH
96780: LD_INT 0
96782: ST_TO_ADDR
// sBazooka := false ;
96783: LD_ADDR_EXP 121
96787: PUSH
96788: LD_INT 0
96790: ST_TO_ADDR
// sMortar := false ;
96791: LD_ADDR_EXP 122
96795: PUSH
96796: LD_INT 0
96798: ST_TO_ADDR
// sRanger := false ;
96799: LD_ADDR_EXP 132
96803: PUSH
96804: LD_INT 0
96806: ST_TO_ADDR
// sComputer := false ;
96807: LD_ADDR_EXP 133
96811: PUSH
96812: LD_INT 0
96814: ST_TO_ADDR
// s30 := false ;
96815: LD_ADDR_EXP 134
96819: PUSH
96820: LD_INT 0
96822: ST_TO_ADDR
// s60 := false ;
96823: LD_ADDR_EXP 135
96827: PUSH
96828: LD_INT 0
96830: ST_TO_ADDR
// end ;
96831: LD_VAR 0 1
96835: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96836: LD_INT 0
96838: PPUSH
96839: PPUSH
96840: PPUSH
96841: PPUSH
96842: PPUSH
96843: PPUSH
96844: PPUSH
// result := [ ] ;
96845: LD_ADDR_VAR 0 2
96849: PUSH
96850: EMPTY
96851: ST_TO_ADDR
// if campaign_id = 1 then
96852: LD_OWVAR 69
96856: PUSH
96857: LD_INT 1
96859: EQUAL
96860: IFFALSE 100026
// begin case mission_number of 1 :
96862: LD_OWVAR 70
96866: PUSH
96867: LD_INT 1
96869: DOUBLE
96870: EQUAL
96871: IFTRUE 96875
96873: GO 96951
96875: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96876: LD_ADDR_VAR 0 2
96880: PUSH
96881: LD_INT 2
96883: PUSH
96884: LD_INT 4
96886: PUSH
96887: LD_INT 11
96889: PUSH
96890: LD_INT 12
96892: PUSH
96893: LD_INT 15
96895: PUSH
96896: LD_INT 16
96898: PUSH
96899: LD_INT 22
96901: PUSH
96902: LD_INT 23
96904: PUSH
96905: LD_INT 26
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: PUSH
96919: LD_INT 101
96921: PUSH
96922: LD_INT 102
96924: PUSH
96925: LD_INT 106
96927: PUSH
96928: LD_INT 116
96930: PUSH
96931: LD_INT 117
96933: PUSH
96934: LD_INT 118
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: PUSH
96945: EMPTY
96946: LIST
96947: LIST
96948: ST_TO_ADDR
96949: GO 100024
96951: LD_INT 2
96953: DOUBLE
96954: EQUAL
96955: IFTRUE 96959
96957: GO 97043
96959: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96960: LD_ADDR_VAR 0 2
96964: PUSH
96965: LD_INT 2
96967: PUSH
96968: LD_INT 4
96970: PUSH
96971: LD_INT 11
96973: PUSH
96974: LD_INT 12
96976: PUSH
96977: LD_INT 15
96979: PUSH
96980: LD_INT 16
96982: PUSH
96983: LD_INT 22
96985: PUSH
96986: LD_INT 23
96988: PUSH
96989: LD_INT 26
96991: PUSH
96992: EMPTY
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 101
97005: PUSH
97006: LD_INT 102
97008: PUSH
97009: LD_INT 105
97011: PUSH
97012: LD_INT 106
97014: PUSH
97015: LD_INT 108
97017: PUSH
97018: LD_INT 116
97020: PUSH
97021: LD_INT 117
97023: PUSH
97024: LD_INT 118
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: ST_TO_ADDR
97041: GO 100024
97043: LD_INT 3
97045: DOUBLE
97046: EQUAL
97047: IFTRUE 97051
97049: GO 97139
97051: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
97052: LD_ADDR_VAR 0 2
97056: PUSH
97057: LD_INT 2
97059: PUSH
97060: LD_INT 4
97062: PUSH
97063: LD_INT 5
97065: PUSH
97066: LD_INT 11
97068: PUSH
97069: LD_INT 12
97071: PUSH
97072: LD_INT 15
97074: PUSH
97075: LD_INT 16
97077: PUSH
97078: LD_INT 22
97080: PUSH
97081: LD_INT 26
97083: PUSH
97084: LD_INT 36
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: LIST
97091: LIST
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 101
97101: PUSH
97102: LD_INT 102
97104: PUSH
97105: LD_INT 105
97107: PUSH
97108: LD_INT 106
97110: PUSH
97111: LD_INT 108
97113: PUSH
97114: LD_INT 116
97116: PUSH
97117: LD_INT 117
97119: PUSH
97120: LD_INT 118
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: ST_TO_ADDR
97137: GO 100024
97139: LD_INT 4
97141: DOUBLE
97142: EQUAL
97143: IFTRUE 97147
97145: GO 97243
97147: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
97148: LD_ADDR_VAR 0 2
97152: PUSH
97153: LD_INT 2
97155: PUSH
97156: LD_INT 4
97158: PUSH
97159: LD_INT 5
97161: PUSH
97162: LD_INT 8
97164: PUSH
97165: LD_INT 11
97167: PUSH
97168: LD_INT 12
97170: PUSH
97171: LD_INT 15
97173: PUSH
97174: LD_INT 16
97176: PUSH
97177: LD_INT 22
97179: PUSH
97180: LD_INT 23
97182: PUSH
97183: LD_INT 26
97185: PUSH
97186: LD_INT 36
97188: PUSH
97189: EMPTY
97190: LIST
97191: LIST
97192: LIST
97193: LIST
97194: LIST
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: PUSH
97203: LD_INT 101
97205: PUSH
97206: LD_INT 102
97208: PUSH
97209: LD_INT 105
97211: PUSH
97212: LD_INT 106
97214: PUSH
97215: LD_INT 108
97217: PUSH
97218: LD_INT 116
97220: PUSH
97221: LD_INT 117
97223: PUSH
97224: LD_INT 118
97226: PUSH
97227: EMPTY
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: PUSH
97237: EMPTY
97238: LIST
97239: LIST
97240: ST_TO_ADDR
97241: GO 100024
97243: LD_INT 5
97245: DOUBLE
97246: EQUAL
97247: IFTRUE 97251
97249: GO 97363
97251: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97252: LD_ADDR_VAR 0 2
97256: PUSH
97257: LD_INT 2
97259: PUSH
97260: LD_INT 4
97262: PUSH
97263: LD_INT 5
97265: PUSH
97266: LD_INT 6
97268: PUSH
97269: LD_INT 8
97271: PUSH
97272: LD_INT 11
97274: PUSH
97275: LD_INT 12
97277: PUSH
97278: LD_INT 15
97280: PUSH
97281: LD_INT 16
97283: PUSH
97284: LD_INT 22
97286: PUSH
97287: LD_INT 23
97289: PUSH
97290: LD_INT 25
97292: PUSH
97293: LD_INT 26
97295: PUSH
97296: LD_INT 36
97298: PUSH
97299: EMPTY
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: LIST
97314: PUSH
97315: LD_INT 101
97317: PUSH
97318: LD_INT 102
97320: PUSH
97321: LD_INT 105
97323: PUSH
97324: LD_INT 106
97326: PUSH
97327: LD_INT 108
97329: PUSH
97330: LD_INT 109
97332: PUSH
97333: LD_INT 112
97335: PUSH
97336: LD_INT 116
97338: PUSH
97339: LD_INT 117
97341: PUSH
97342: LD_INT 118
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: LIST
97351: LIST
97352: LIST
97353: LIST
97354: LIST
97355: LIST
97356: PUSH
97357: EMPTY
97358: LIST
97359: LIST
97360: ST_TO_ADDR
97361: GO 100024
97363: LD_INT 6
97365: DOUBLE
97366: EQUAL
97367: IFTRUE 97371
97369: GO 97503
97371: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97372: LD_ADDR_VAR 0 2
97376: PUSH
97377: LD_INT 2
97379: PUSH
97380: LD_INT 4
97382: PUSH
97383: LD_INT 5
97385: PUSH
97386: LD_INT 6
97388: PUSH
97389: LD_INT 8
97391: PUSH
97392: LD_INT 11
97394: PUSH
97395: LD_INT 12
97397: PUSH
97398: LD_INT 15
97400: PUSH
97401: LD_INT 16
97403: PUSH
97404: LD_INT 20
97406: PUSH
97407: LD_INT 21
97409: PUSH
97410: LD_INT 22
97412: PUSH
97413: LD_INT 23
97415: PUSH
97416: LD_INT 25
97418: PUSH
97419: LD_INT 26
97421: PUSH
97422: LD_INT 30
97424: PUSH
97425: LD_INT 31
97427: PUSH
97428: LD_INT 32
97430: PUSH
97431: LD_INT 36
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: LIST
97438: LIST
97439: LIST
97440: LIST
97441: LIST
97442: LIST
97443: LIST
97444: LIST
97445: LIST
97446: LIST
97447: LIST
97448: LIST
97449: LIST
97450: LIST
97451: LIST
97452: LIST
97453: LIST
97454: PUSH
97455: LD_INT 101
97457: PUSH
97458: LD_INT 102
97460: PUSH
97461: LD_INT 105
97463: PUSH
97464: LD_INT 106
97466: PUSH
97467: LD_INT 108
97469: PUSH
97470: LD_INT 109
97472: PUSH
97473: LD_INT 112
97475: PUSH
97476: LD_INT 116
97478: PUSH
97479: LD_INT 117
97481: PUSH
97482: LD_INT 118
97484: PUSH
97485: EMPTY
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: ST_TO_ADDR
97501: GO 100024
97503: LD_INT 7
97505: DOUBLE
97506: EQUAL
97507: IFTRUE 97511
97509: GO 97623
97511: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97512: LD_ADDR_VAR 0 2
97516: PUSH
97517: LD_INT 2
97519: PUSH
97520: LD_INT 4
97522: PUSH
97523: LD_INT 5
97525: PUSH
97526: LD_INT 7
97528: PUSH
97529: LD_INT 11
97531: PUSH
97532: LD_INT 12
97534: PUSH
97535: LD_INT 15
97537: PUSH
97538: LD_INT 16
97540: PUSH
97541: LD_INT 20
97543: PUSH
97544: LD_INT 21
97546: PUSH
97547: LD_INT 22
97549: PUSH
97550: LD_INT 23
97552: PUSH
97553: LD_INT 25
97555: PUSH
97556: LD_INT 26
97558: PUSH
97559: EMPTY
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 101
97577: PUSH
97578: LD_INT 102
97580: PUSH
97581: LD_INT 103
97583: PUSH
97584: LD_INT 105
97586: PUSH
97587: LD_INT 106
97589: PUSH
97590: LD_INT 108
97592: PUSH
97593: LD_INT 112
97595: PUSH
97596: LD_INT 116
97598: PUSH
97599: LD_INT 117
97601: PUSH
97602: LD_INT 118
97604: PUSH
97605: EMPTY
97606: LIST
97607: LIST
97608: LIST
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: LIST
97614: LIST
97615: LIST
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: ST_TO_ADDR
97621: GO 100024
97623: LD_INT 8
97625: DOUBLE
97626: EQUAL
97627: IFTRUE 97631
97629: GO 97771
97631: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97632: LD_ADDR_VAR 0 2
97636: PUSH
97637: LD_INT 2
97639: PUSH
97640: LD_INT 4
97642: PUSH
97643: LD_INT 5
97645: PUSH
97646: LD_INT 6
97648: PUSH
97649: LD_INT 7
97651: PUSH
97652: LD_INT 8
97654: PUSH
97655: LD_INT 11
97657: PUSH
97658: LD_INT 12
97660: PUSH
97661: LD_INT 15
97663: PUSH
97664: LD_INT 16
97666: PUSH
97667: LD_INT 20
97669: PUSH
97670: LD_INT 21
97672: PUSH
97673: LD_INT 22
97675: PUSH
97676: LD_INT 23
97678: PUSH
97679: LD_INT 25
97681: PUSH
97682: LD_INT 26
97684: PUSH
97685: LD_INT 30
97687: PUSH
97688: LD_INT 31
97690: PUSH
97691: LD_INT 32
97693: PUSH
97694: LD_INT 36
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: LIST
97701: LIST
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: LIST
97716: LIST
97717: LIST
97718: PUSH
97719: LD_INT 101
97721: PUSH
97722: LD_INT 102
97724: PUSH
97725: LD_INT 103
97727: PUSH
97728: LD_INT 105
97730: PUSH
97731: LD_INT 106
97733: PUSH
97734: LD_INT 108
97736: PUSH
97737: LD_INT 109
97739: PUSH
97740: LD_INT 112
97742: PUSH
97743: LD_INT 116
97745: PUSH
97746: LD_INT 117
97748: PUSH
97749: LD_INT 118
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: ST_TO_ADDR
97769: GO 100024
97771: LD_INT 9
97773: DOUBLE
97774: EQUAL
97775: IFTRUE 97779
97777: GO 97927
97779: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97780: LD_ADDR_VAR 0 2
97784: PUSH
97785: LD_INT 2
97787: PUSH
97788: LD_INT 4
97790: PUSH
97791: LD_INT 5
97793: PUSH
97794: LD_INT 6
97796: PUSH
97797: LD_INT 7
97799: PUSH
97800: LD_INT 8
97802: PUSH
97803: LD_INT 11
97805: PUSH
97806: LD_INT 12
97808: PUSH
97809: LD_INT 15
97811: PUSH
97812: LD_INT 16
97814: PUSH
97815: LD_INT 20
97817: PUSH
97818: LD_INT 21
97820: PUSH
97821: LD_INT 22
97823: PUSH
97824: LD_INT 23
97826: PUSH
97827: LD_INT 25
97829: PUSH
97830: LD_INT 26
97832: PUSH
97833: LD_INT 28
97835: PUSH
97836: LD_INT 30
97838: PUSH
97839: LD_INT 31
97841: PUSH
97842: LD_INT 32
97844: PUSH
97845: LD_INT 36
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: PUSH
97871: LD_INT 101
97873: PUSH
97874: LD_INT 102
97876: PUSH
97877: LD_INT 103
97879: PUSH
97880: LD_INT 105
97882: PUSH
97883: LD_INT 106
97885: PUSH
97886: LD_INT 108
97888: PUSH
97889: LD_INT 109
97891: PUSH
97892: LD_INT 112
97894: PUSH
97895: LD_INT 114
97897: PUSH
97898: LD_INT 116
97900: PUSH
97901: LD_INT 117
97903: PUSH
97904: LD_INT 118
97906: PUSH
97907: EMPTY
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: LIST
97919: LIST
97920: PUSH
97921: EMPTY
97922: LIST
97923: LIST
97924: ST_TO_ADDR
97925: GO 100024
97927: LD_INT 10
97929: DOUBLE
97930: EQUAL
97931: IFTRUE 97935
97933: GO 98131
97935: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97936: LD_ADDR_VAR 0 2
97940: PUSH
97941: LD_INT 2
97943: PUSH
97944: LD_INT 4
97946: PUSH
97947: LD_INT 5
97949: PUSH
97950: LD_INT 6
97952: PUSH
97953: LD_INT 7
97955: PUSH
97956: LD_INT 8
97958: PUSH
97959: LD_INT 9
97961: PUSH
97962: LD_INT 10
97964: PUSH
97965: LD_INT 11
97967: PUSH
97968: LD_INT 12
97970: PUSH
97971: LD_INT 13
97973: PUSH
97974: LD_INT 14
97976: PUSH
97977: LD_INT 15
97979: PUSH
97980: LD_INT 16
97982: PUSH
97983: LD_INT 17
97985: PUSH
97986: LD_INT 18
97988: PUSH
97989: LD_INT 19
97991: PUSH
97992: LD_INT 20
97994: PUSH
97995: LD_INT 21
97997: PUSH
97998: LD_INT 22
98000: PUSH
98001: LD_INT 23
98003: PUSH
98004: LD_INT 24
98006: PUSH
98007: LD_INT 25
98009: PUSH
98010: LD_INT 26
98012: PUSH
98013: LD_INT 28
98015: PUSH
98016: LD_INT 30
98018: PUSH
98019: LD_INT 31
98021: PUSH
98022: LD_INT 32
98024: PUSH
98025: LD_INT 36
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: LIST
98032: LIST
98033: LIST
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: LIST
98039: LIST
98040: LIST
98041: LIST
98042: LIST
98043: LIST
98044: LIST
98045: LIST
98046: LIST
98047: LIST
98048: LIST
98049: LIST
98050: LIST
98051: LIST
98052: LIST
98053: LIST
98054: LIST
98055: LIST
98056: LIST
98057: LIST
98058: PUSH
98059: LD_INT 101
98061: PUSH
98062: LD_INT 102
98064: PUSH
98065: LD_INT 103
98067: PUSH
98068: LD_INT 104
98070: PUSH
98071: LD_INT 105
98073: PUSH
98074: LD_INT 106
98076: PUSH
98077: LD_INT 107
98079: PUSH
98080: LD_INT 108
98082: PUSH
98083: LD_INT 109
98085: PUSH
98086: LD_INT 110
98088: PUSH
98089: LD_INT 111
98091: PUSH
98092: LD_INT 112
98094: PUSH
98095: LD_INT 114
98097: PUSH
98098: LD_INT 116
98100: PUSH
98101: LD_INT 117
98103: PUSH
98104: LD_INT 118
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: LIST
98120: LIST
98121: LIST
98122: LIST
98123: LIST
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: ST_TO_ADDR
98129: GO 100024
98131: LD_INT 11
98133: DOUBLE
98134: EQUAL
98135: IFTRUE 98139
98137: GO 98343
98139: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
98140: LD_ADDR_VAR 0 2
98144: PUSH
98145: LD_INT 2
98147: PUSH
98148: LD_INT 3
98150: PUSH
98151: LD_INT 4
98153: PUSH
98154: LD_INT 5
98156: PUSH
98157: LD_INT 6
98159: PUSH
98160: LD_INT 7
98162: PUSH
98163: LD_INT 8
98165: PUSH
98166: LD_INT 9
98168: PUSH
98169: LD_INT 10
98171: PUSH
98172: LD_INT 11
98174: PUSH
98175: LD_INT 12
98177: PUSH
98178: LD_INT 13
98180: PUSH
98181: LD_INT 14
98183: PUSH
98184: LD_INT 15
98186: PUSH
98187: LD_INT 16
98189: PUSH
98190: LD_INT 17
98192: PUSH
98193: LD_INT 18
98195: PUSH
98196: LD_INT 19
98198: PUSH
98199: LD_INT 20
98201: PUSH
98202: LD_INT 21
98204: PUSH
98205: LD_INT 22
98207: PUSH
98208: LD_INT 23
98210: PUSH
98211: LD_INT 24
98213: PUSH
98214: LD_INT 25
98216: PUSH
98217: LD_INT 26
98219: PUSH
98220: LD_INT 28
98222: PUSH
98223: LD_INT 30
98225: PUSH
98226: LD_INT 31
98228: PUSH
98229: LD_INT 32
98231: PUSH
98232: LD_INT 34
98234: PUSH
98235: LD_INT 36
98237: PUSH
98238: EMPTY
98239: LIST
98240: LIST
98241: LIST
98242: LIST
98243: LIST
98244: LIST
98245: LIST
98246: LIST
98247: LIST
98248: LIST
98249: LIST
98250: LIST
98251: LIST
98252: LIST
98253: LIST
98254: LIST
98255: LIST
98256: LIST
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: PUSH
98271: LD_INT 101
98273: PUSH
98274: LD_INT 102
98276: PUSH
98277: LD_INT 103
98279: PUSH
98280: LD_INT 104
98282: PUSH
98283: LD_INT 105
98285: PUSH
98286: LD_INT 106
98288: PUSH
98289: LD_INT 107
98291: PUSH
98292: LD_INT 108
98294: PUSH
98295: LD_INT 109
98297: PUSH
98298: LD_INT 110
98300: PUSH
98301: LD_INT 111
98303: PUSH
98304: LD_INT 112
98306: PUSH
98307: LD_INT 114
98309: PUSH
98310: LD_INT 116
98312: PUSH
98313: LD_INT 117
98315: PUSH
98316: LD_INT 118
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: LIST
98328: LIST
98329: LIST
98330: LIST
98331: LIST
98332: LIST
98333: LIST
98334: LIST
98335: LIST
98336: PUSH
98337: EMPTY
98338: LIST
98339: LIST
98340: ST_TO_ADDR
98341: GO 100024
98343: LD_INT 12
98345: DOUBLE
98346: EQUAL
98347: IFTRUE 98351
98349: GO 98571
98351: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98352: LD_ADDR_VAR 0 2
98356: PUSH
98357: LD_INT 1
98359: PUSH
98360: LD_INT 2
98362: PUSH
98363: LD_INT 3
98365: PUSH
98366: LD_INT 4
98368: PUSH
98369: LD_INT 5
98371: PUSH
98372: LD_INT 6
98374: PUSH
98375: LD_INT 7
98377: PUSH
98378: LD_INT 8
98380: PUSH
98381: LD_INT 9
98383: PUSH
98384: LD_INT 10
98386: PUSH
98387: LD_INT 11
98389: PUSH
98390: LD_INT 12
98392: PUSH
98393: LD_INT 13
98395: PUSH
98396: LD_INT 14
98398: PUSH
98399: LD_INT 15
98401: PUSH
98402: LD_INT 16
98404: PUSH
98405: LD_INT 17
98407: PUSH
98408: LD_INT 18
98410: PUSH
98411: LD_INT 19
98413: PUSH
98414: LD_INT 20
98416: PUSH
98417: LD_INT 21
98419: PUSH
98420: LD_INT 22
98422: PUSH
98423: LD_INT 23
98425: PUSH
98426: LD_INT 24
98428: PUSH
98429: LD_INT 25
98431: PUSH
98432: LD_INT 26
98434: PUSH
98435: LD_INT 27
98437: PUSH
98438: LD_INT 28
98440: PUSH
98441: LD_INT 30
98443: PUSH
98444: LD_INT 31
98446: PUSH
98447: LD_INT 32
98449: PUSH
98450: LD_INT 33
98452: PUSH
98453: LD_INT 34
98455: PUSH
98456: LD_INT 36
98458: PUSH
98459: EMPTY
98460: LIST
98461: LIST
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: LIST
98467: LIST
98468: LIST
98469: LIST
98470: LIST
98471: LIST
98472: LIST
98473: LIST
98474: LIST
98475: LIST
98476: LIST
98477: LIST
98478: LIST
98479: LIST
98480: LIST
98481: LIST
98482: LIST
98483: LIST
98484: LIST
98485: LIST
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: LIST
98491: LIST
98492: LIST
98493: LIST
98494: PUSH
98495: LD_INT 101
98497: PUSH
98498: LD_INT 102
98500: PUSH
98501: LD_INT 103
98503: PUSH
98504: LD_INT 104
98506: PUSH
98507: LD_INT 105
98509: PUSH
98510: LD_INT 106
98512: PUSH
98513: LD_INT 107
98515: PUSH
98516: LD_INT 108
98518: PUSH
98519: LD_INT 109
98521: PUSH
98522: LD_INT 110
98524: PUSH
98525: LD_INT 111
98527: PUSH
98528: LD_INT 112
98530: PUSH
98531: LD_INT 113
98533: PUSH
98534: LD_INT 114
98536: PUSH
98537: LD_INT 116
98539: PUSH
98540: LD_INT 117
98542: PUSH
98543: LD_INT 118
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: LIST
98557: LIST
98558: LIST
98559: LIST
98560: LIST
98561: LIST
98562: LIST
98563: LIST
98564: PUSH
98565: EMPTY
98566: LIST
98567: LIST
98568: ST_TO_ADDR
98569: GO 100024
98571: LD_INT 13
98573: DOUBLE
98574: EQUAL
98575: IFTRUE 98579
98577: GO 98787
98579: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98580: LD_ADDR_VAR 0 2
98584: PUSH
98585: LD_INT 1
98587: PUSH
98588: LD_INT 2
98590: PUSH
98591: LD_INT 3
98593: PUSH
98594: LD_INT 4
98596: PUSH
98597: LD_INT 5
98599: PUSH
98600: LD_INT 8
98602: PUSH
98603: LD_INT 9
98605: PUSH
98606: LD_INT 10
98608: PUSH
98609: LD_INT 11
98611: PUSH
98612: LD_INT 12
98614: PUSH
98615: LD_INT 14
98617: PUSH
98618: LD_INT 15
98620: PUSH
98621: LD_INT 16
98623: PUSH
98624: LD_INT 17
98626: PUSH
98627: LD_INT 18
98629: PUSH
98630: LD_INT 19
98632: PUSH
98633: LD_INT 20
98635: PUSH
98636: LD_INT 21
98638: PUSH
98639: LD_INT 22
98641: PUSH
98642: LD_INT 23
98644: PUSH
98645: LD_INT 24
98647: PUSH
98648: LD_INT 25
98650: PUSH
98651: LD_INT 26
98653: PUSH
98654: LD_INT 27
98656: PUSH
98657: LD_INT 28
98659: PUSH
98660: LD_INT 30
98662: PUSH
98663: LD_INT 31
98665: PUSH
98666: LD_INT 32
98668: PUSH
98669: LD_INT 33
98671: PUSH
98672: LD_INT 34
98674: PUSH
98675: LD_INT 36
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: LIST
98682: LIST
98683: LIST
98684: LIST
98685: LIST
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: LIST
98696: LIST
98697: LIST
98698: LIST
98699: LIST
98700: LIST
98701: LIST
98702: LIST
98703: LIST
98704: LIST
98705: LIST
98706: LIST
98707: LIST
98708: LIST
98709: LIST
98710: PUSH
98711: LD_INT 101
98713: PUSH
98714: LD_INT 102
98716: PUSH
98717: LD_INT 103
98719: PUSH
98720: LD_INT 104
98722: PUSH
98723: LD_INT 105
98725: PUSH
98726: LD_INT 106
98728: PUSH
98729: LD_INT 107
98731: PUSH
98732: LD_INT 108
98734: PUSH
98735: LD_INT 109
98737: PUSH
98738: LD_INT 110
98740: PUSH
98741: LD_INT 111
98743: PUSH
98744: LD_INT 112
98746: PUSH
98747: LD_INT 113
98749: PUSH
98750: LD_INT 114
98752: PUSH
98753: LD_INT 116
98755: PUSH
98756: LD_INT 117
98758: PUSH
98759: LD_INT 118
98761: PUSH
98762: EMPTY
98763: LIST
98764: LIST
98765: LIST
98766: LIST
98767: LIST
98768: LIST
98769: LIST
98770: LIST
98771: LIST
98772: LIST
98773: LIST
98774: LIST
98775: LIST
98776: LIST
98777: LIST
98778: LIST
98779: LIST
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: ST_TO_ADDR
98785: GO 100024
98787: LD_INT 14
98789: DOUBLE
98790: EQUAL
98791: IFTRUE 98795
98793: GO 99019
98795: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98796: LD_ADDR_VAR 0 2
98800: PUSH
98801: LD_INT 1
98803: PUSH
98804: LD_INT 2
98806: PUSH
98807: LD_INT 3
98809: PUSH
98810: LD_INT 4
98812: PUSH
98813: LD_INT 5
98815: PUSH
98816: LD_INT 6
98818: PUSH
98819: LD_INT 7
98821: PUSH
98822: LD_INT 8
98824: PUSH
98825: LD_INT 9
98827: PUSH
98828: LD_INT 10
98830: PUSH
98831: LD_INT 11
98833: PUSH
98834: LD_INT 12
98836: PUSH
98837: LD_INT 13
98839: PUSH
98840: LD_INT 14
98842: PUSH
98843: LD_INT 15
98845: PUSH
98846: LD_INT 16
98848: PUSH
98849: LD_INT 17
98851: PUSH
98852: LD_INT 18
98854: PUSH
98855: LD_INT 19
98857: PUSH
98858: LD_INT 20
98860: PUSH
98861: LD_INT 21
98863: PUSH
98864: LD_INT 22
98866: PUSH
98867: LD_INT 23
98869: PUSH
98870: LD_INT 24
98872: PUSH
98873: LD_INT 25
98875: PUSH
98876: LD_INT 26
98878: PUSH
98879: LD_INT 27
98881: PUSH
98882: LD_INT 28
98884: PUSH
98885: LD_INT 29
98887: PUSH
98888: LD_INT 30
98890: PUSH
98891: LD_INT 31
98893: PUSH
98894: LD_INT 32
98896: PUSH
98897: LD_INT 33
98899: PUSH
98900: LD_INT 34
98902: PUSH
98903: LD_INT 36
98905: PUSH
98906: EMPTY
98907: LIST
98908: LIST
98909: LIST
98910: LIST
98911: LIST
98912: LIST
98913: LIST
98914: LIST
98915: LIST
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: LIST
98922: LIST
98923: LIST
98924: LIST
98925: LIST
98926: LIST
98927: LIST
98928: LIST
98929: LIST
98930: LIST
98931: LIST
98932: LIST
98933: LIST
98934: LIST
98935: LIST
98936: LIST
98937: LIST
98938: LIST
98939: LIST
98940: LIST
98941: LIST
98942: PUSH
98943: LD_INT 101
98945: PUSH
98946: LD_INT 102
98948: PUSH
98949: LD_INT 103
98951: PUSH
98952: LD_INT 104
98954: PUSH
98955: LD_INT 105
98957: PUSH
98958: LD_INT 106
98960: PUSH
98961: LD_INT 107
98963: PUSH
98964: LD_INT 108
98966: PUSH
98967: LD_INT 109
98969: PUSH
98970: LD_INT 110
98972: PUSH
98973: LD_INT 111
98975: PUSH
98976: LD_INT 112
98978: PUSH
98979: LD_INT 113
98981: PUSH
98982: LD_INT 114
98984: PUSH
98985: LD_INT 116
98987: PUSH
98988: LD_INT 117
98990: PUSH
98991: LD_INT 118
98993: PUSH
98994: EMPTY
98995: LIST
98996: LIST
98997: LIST
98998: LIST
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: ST_TO_ADDR
99017: GO 100024
99019: LD_INT 15
99021: DOUBLE
99022: EQUAL
99023: IFTRUE 99027
99025: GO 99251
99027: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
99028: LD_ADDR_VAR 0 2
99032: PUSH
99033: LD_INT 1
99035: PUSH
99036: LD_INT 2
99038: PUSH
99039: LD_INT 3
99041: PUSH
99042: LD_INT 4
99044: PUSH
99045: LD_INT 5
99047: PUSH
99048: LD_INT 6
99050: PUSH
99051: LD_INT 7
99053: PUSH
99054: LD_INT 8
99056: PUSH
99057: LD_INT 9
99059: PUSH
99060: LD_INT 10
99062: PUSH
99063: LD_INT 11
99065: PUSH
99066: LD_INT 12
99068: PUSH
99069: LD_INT 13
99071: PUSH
99072: LD_INT 14
99074: PUSH
99075: LD_INT 15
99077: PUSH
99078: LD_INT 16
99080: PUSH
99081: LD_INT 17
99083: PUSH
99084: LD_INT 18
99086: PUSH
99087: LD_INT 19
99089: PUSH
99090: LD_INT 20
99092: PUSH
99093: LD_INT 21
99095: PUSH
99096: LD_INT 22
99098: PUSH
99099: LD_INT 23
99101: PUSH
99102: LD_INT 24
99104: PUSH
99105: LD_INT 25
99107: PUSH
99108: LD_INT 26
99110: PUSH
99111: LD_INT 27
99113: PUSH
99114: LD_INT 28
99116: PUSH
99117: LD_INT 29
99119: PUSH
99120: LD_INT 30
99122: PUSH
99123: LD_INT 31
99125: PUSH
99126: LD_INT 32
99128: PUSH
99129: LD_INT 33
99131: PUSH
99132: LD_INT 34
99134: PUSH
99135: LD_INT 36
99137: PUSH
99138: EMPTY
99139: LIST
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: LIST
99160: LIST
99161: LIST
99162: LIST
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: LIST
99168: LIST
99169: LIST
99170: LIST
99171: LIST
99172: LIST
99173: LIST
99174: PUSH
99175: LD_INT 101
99177: PUSH
99178: LD_INT 102
99180: PUSH
99181: LD_INT 103
99183: PUSH
99184: LD_INT 104
99186: PUSH
99187: LD_INT 105
99189: PUSH
99190: LD_INT 106
99192: PUSH
99193: LD_INT 107
99195: PUSH
99196: LD_INT 108
99198: PUSH
99199: LD_INT 109
99201: PUSH
99202: LD_INT 110
99204: PUSH
99205: LD_INT 111
99207: PUSH
99208: LD_INT 112
99210: PUSH
99211: LD_INT 113
99213: PUSH
99214: LD_INT 114
99216: PUSH
99217: LD_INT 116
99219: PUSH
99220: LD_INT 117
99222: PUSH
99223: LD_INT 118
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: LIST
99233: LIST
99234: LIST
99235: LIST
99236: LIST
99237: LIST
99238: LIST
99239: LIST
99240: LIST
99241: LIST
99242: LIST
99243: LIST
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: ST_TO_ADDR
99249: GO 100024
99251: LD_INT 16
99253: DOUBLE
99254: EQUAL
99255: IFTRUE 99259
99257: GO 99395
99259: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99260: LD_ADDR_VAR 0 2
99264: PUSH
99265: LD_INT 2
99267: PUSH
99268: LD_INT 4
99270: PUSH
99271: LD_INT 5
99273: PUSH
99274: LD_INT 7
99276: PUSH
99277: LD_INT 11
99279: PUSH
99280: LD_INT 12
99282: PUSH
99283: LD_INT 15
99285: PUSH
99286: LD_INT 16
99288: PUSH
99289: LD_INT 20
99291: PUSH
99292: LD_INT 21
99294: PUSH
99295: LD_INT 22
99297: PUSH
99298: LD_INT 23
99300: PUSH
99301: LD_INT 25
99303: PUSH
99304: LD_INT 26
99306: PUSH
99307: LD_INT 30
99309: PUSH
99310: LD_INT 31
99312: PUSH
99313: LD_INT 32
99315: PUSH
99316: LD_INT 33
99318: PUSH
99319: LD_INT 34
99321: PUSH
99322: EMPTY
99323: LIST
99324: LIST
99325: LIST
99326: LIST
99327: LIST
99328: LIST
99329: LIST
99330: LIST
99331: LIST
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: PUSH
99343: LD_INT 101
99345: PUSH
99346: LD_INT 102
99348: PUSH
99349: LD_INT 103
99351: PUSH
99352: LD_INT 106
99354: PUSH
99355: LD_INT 108
99357: PUSH
99358: LD_INT 112
99360: PUSH
99361: LD_INT 113
99363: PUSH
99364: LD_INT 114
99366: PUSH
99367: LD_INT 116
99369: PUSH
99370: LD_INT 117
99372: PUSH
99373: LD_INT 118
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: ST_TO_ADDR
99393: GO 100024
99395: LD_INT 17
99397: DOUBLE
99398: EQUAL
99399: IFTRUE 99403
99401: GO 99627
99403: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99404: LD_ADDR_VAR 0 2
99408: PUSH
99409: LD_INT 1
99411: PUSH
99412: LD_INT 2
99414: PUSH
99415: LD_INT 3
99417: PUSH
99418: LD_INT 4
99420: PUSH
99421: LD_INT 5
99423: PUSH
99424: LD_INT 6
99426: PUSH
99427: LD_INT 7
99429: PUSH
99430: LD_INT 8
99432: PUSH
99433: LD_INT 9
99435: PUSH
99436: LD_INT 10
99438: PUSH
99439: LD_INT 11
99441: PUSH
99442: LD_INT 12
99444: PUSH
99445: LD_INT 13
99447: PUSH
99448: LD_INT 14
99450: PUSH
99451: LD_INT 15
99453: PUSH
99454: LD_INT 16
99456: PUSH
99457: LD_INT 17
99459: PUSH
99460: LD_INT 18
99462: PUSH
99463: LD_INT 19
99465: PUSH
99466: LD_INT 20
99468: PUSH
99469: LD_INT 21
99471: PUSH
99472: LD_INT 22
99474: PUSH
99475: LD_INT 23
99477: PUSH
99478: LD_INT 24
99480: PUSH
99481: LD_INT 25
99483: PUSH
99484: LD_INT 26
99486: PUSH
99487: LD_INT 27
99489: PUSH
99490: LD_INT 28
99492: PUSH
99493: LD_INT 29
99495: PUSH
99496: LD_INT 30
99498: PUSH
99499: LD_INT 31
99501: PUSH
99502: LD_INT 32
99504: PUSH
99505: LD_INT 33
99507: PUSH
99508: LD_INT 34
99510: PUSH
99511: LD_INT 36
99513: PUSH
99514: EMPTY
99515: LIST
99516: LIST
99517: LIST
99518: LIST
99519: LIST
99520: LIST
99521: LIST
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: LIST
99544: LIST
99545: LIST
99546: LIST
99547: LIST
99548: LIST
99549: LIST
99550: PUSH
99551: LD_INT 101
99553: PUSH
99554: LD_INT 102
99556: PUSH
99557: LD_INT 103
99559: PUSH
99560: LD_INT 104
99562: PUSH
99563: LD_INT 105
99565: PUSH
99566: LD_INT 106
99568: PUSH
99569: LD_INT 107
99571: PUSH
99572: LD_INT 108
99574: PUSH
99575: LD_INT 109
99577: PUSH
99578: LD_INT 110
99580: PUSH
99581: LD_INT 111
99583: PUSH
99584: LD_INT 112
99586: PUSH
99587: LD_INT 113
99589: PUSH
99590: LD_INT 114
99592: PUSH
99593: LD_INT 116
99595: PUSH
99596: LD_INT 117
99598: PUSH
99599: LD_INT 118
99601: PUSH
99602: EMPTY
99603: LIST
99604: LIST
99605: LIST
99606: LIST
99607: LIST
99608: LIST
99609: LIST
99610: LIST
99611: LIST
99612: LIST
99613: LIST
99614: LIST
99615: LIST
99616: LIST
99617: LIST
99618: LIST
99619: LIST
99620: PUSH
99621: EMPTY
99622: LIST
99623: LIST
99624: ST_TO_ADDR
99625: GO 100024
99627: LD_INT 18
99629: DOUBLE
99630: EQUAL
99631: IFTRUE 99635
99633: GO 99783
99635: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99636: LD_ADDR_VAR 0 2
99640: PUSH
99641: LD_INT 2
99643: PUSH
99644: LD_INT 4
99646: PUSH
99647: LD_INT 5
99649: PUSH
99650: LD_INT 7
99652: PUSH
99653: LD_INT 11
99655: PUSH
99656: LD_INT 12
99658: PUSH
99659: LD_INT 15
99661: PUSH
99662: LD_INT 16
99664: PUSH
99665: LD_INT 20
99667: PUSH
99668: LD_INT 21
99670: PUSH
99671: LD_INT 22
99673: PUSH
99674: LD_INT 23
99676: PUSH
99677: LD_INT 25
99679: PUSH
99680: LD_INT 26
99682: PUSH
99683: LD_INT 30
99685: PUSH
99686: LD_INT 31
99688: PUSH
99689: LD_INT 32
99691: PUSH
99692: LD_INT 33
99694: PUSH
99695: LD_INT 34
99697: PUSH
99698: LD_INT 35
99700: PUSH
99701: LD_INT 36
99703: PUSH
99704: EMPTY
99705: LIST
99706: LIST
99707: LIST
99708: LIST
99709: LIST
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: LIST
99717: LIST
99718: LIST
99719: LIST
99720: LIST
99721: LIST
99722: LIST
99723: LIST
99724: LIST
99725: LIST
99726: PUSH
99727: LD_INT 101
99729: PUSH
99730: LD_INT 102
99732: PUSH
99733: LD_INT 103
99735: PUSH
99736: LD_INT 106
99738: PUSH
99739: LD_INT 108
99741: PUSH
99742: LD_INT 112
99744: PUSH
99745: LD_INT 113
99747: PUSH
99748: LD_INT 114
99750: PUSH
99751: LD_INT 115
99753: PUSH
99754: LD_INT 116
99756: PUSH
99757: LD_INT 117
99759: PUSH
99760: LD_INT 118
99762: PUSH
99763: EMPTY
99764: LIST
99765: LIST
99766: LIST
99767: LIST
99768: LIST
99769: LIST
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: LIST
99775: LIST
99776: PUSH
99777: EMPTY
99778: LIST
99779: LIST
99780: ST_TO_ADDR
99781: GO 100024
99783: LD_INT 19
99785: DOUBLE
99786: EQUAL
99787: IFTRUE 99791
99789: GO 100023
99791: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99792: LD_ADDR_VAR 0 2
99796: PUSH
99797: LD_INT 1
99799: PUSH
99800: LD_INT 2
99802: PUSH
99803: LD_INT 3
99805: PUSH
99806: LD_INT 4
99808: PUSH
99809: LD_INT 5
99811: PUSH
99812: LD_INT 6
99814: PUSH
99815: LD_INT 7
99817: PUSH
99818: LD_INT 8
99820: PUSH
99821: LD_INT 9
99823: PUSH
99824: LD_INT 10
99826: PUSH
99827: LD_INT 11
99829: PUSH
99830: LD_INT 12
99832: PUSH
99833: LD_INT 13
99835: PUSH
99836: LD_INT 14
99838: PUSH
99839: LD_INT 15
99841: PUSH
99842: LD_INT 16
99844: PUSH
99845: LD_INT 17
99847: PUSH
99848: LD_INT 18
99850: PUSH
99851: LD_INT 19
99853: PUSH
99854: LD_INT 20
99856: PUSH
99857: LD_INT 21
99859: PUSH
99860: LD_INT 22
99862: PUSH
99863: LD_INT 23
99865: PUSH
99866: LD_INT 24
99868: PUSH
99869: LD_INT 25
99871: PUSH
99872: LD_INT 26
99874: PUSH
99875: LD_INT 27
99877: PUSH
99878: LD_INT 28
99880: PUSH
99881: LD_INT 29
99883: PUSH
99884: LD_INT 30
99886: PUSH
99887: LD_INT 31
99889: PUSH
99890: LD_INT 32
99892: PUSH
99893: LD_INT 33
99895: PUSH
99896: LD_INT 34
99898: PUSH
99899: LD_INT 35
99901: PUSH
99902: LD_INT 36
99904: PUSH
99905: EMPTY
99906: LIST
99907: LIST
99908: LIST
99909: LIST
99910: LIST
99911: LIST
99912: LIST
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: PUSH
99943: LD_INT 101
99945: PUSH
99946: LD_INT 102
99948: PUSH
99949: LD_INT 103
99951: PUSH
99952: LD_INT 104
99954: PUSH
99955: LD_INT 105
99957: PUSH
99958: LD_INT 106
99960: PUSH
99961: LD_INT 107
99963: PUSH
99964: LD_INT 108
99966: PUSH
99967: LD_INT 109
99969: PUSH
99970: LD_INT 110
99972: PUSH
99973: LD_INT 111
99975: PUSH
99976: LD_INT 112
99978: PUSH
99979: LD_INT 113
99981: PUSH
99982: LD_INT 114
99984: PUSH
99985: LD_INT 115
99987: PUSH
99988: LD_INT 116
99990: PUSH
99991: LD_INT 117
99993: PUSH
99994: LD_INT 118
99996: PUSH
99997: EMPTY
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: PUSH
100017: EMPTY
100018: LIST
100019: LIST
100020: ST_TO_ADDR
100021: GO 100024
100023: POP
// end else
100024: GO 100255
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
100026: LD_ADDR_VAR 0 2
100030: PUSH
100031: LD_INT 1
100033: PUSH
100034: LD_INT 2
100036: PUSH
100037: LD_INT 3
100039: PUSH
100040: LD_INT 4
100042: PUSH
100043: LD_INT 5
100045: PUSH
100046: LD_INT 6
100048: PUSH
100049: LD_INT 7
100051: PUSH
100052: LD_INT 8
100054: PUSH
100055: LD_INT 9
100057: PUSH
100058: LD_INT 10
100060: PUSH
100061: LD_INT 11
100063: PUSH
100064: LD_INT 12
100066: PUSH
100067: LD_INT 13
100069: PUSH
100070: LD_INT 14
100072: PUSH
100073: LD_INT 15
100075: PUSH
100076: LD_INT 16
100078: PUSH
100079: LD_INT 17
100081: PUSH
100082: LD_INT 18
100084: PUSH
100085: LD_INT 19
100087: PUSH
100088: LD_INT 20
100090: PUSH
100091: LD_INT 21
100093: PUSH
100094: LD_INT 22
100096: PUSH
100097: LD_INT 23
100099: PUSH
100100: LD_INT 24
100102: PUSH
100103: LD_INT 25
100105: PUSH
100106: LD_INT 26
100108: PUSH
100109: LD_INT 27
100111: PUSH
100112: LD_INT 28
100114: PUSH
100115: LD_INT 29
100117: PUSH
100118: LD_INT 30
100120: PUSH
100121: LD_INT 31
100123: PUSH
100124: LD_INT 32
100126: PUSH
100127: LD_INT 33
100129: PUSH
100130: LD_INT 34
100132: PUSH
100133: LD_INT 35
100135: PUSH
100136: LD_INT 36
100138: PUSH
100139: EMPTY
100140: LIST
100141: LIST
100142: LIST
100143: LIST
100144: LIST
100145: LIST
100146: LIST
100147: LIST
100148: LIST
100149: LIST
100150: LIST
100151: LIST
100152: LIST
100153: LIST
100154: LIST
100155: LIST
100156: LIST
100157: LIST
100158: LIST
100159: LIST
100160: LIST
100161: LIST
100162: LIST
100163: LIST
100164: LIST
100165: LIST
100166: LIST
100167: LIST
100168: LIST
100169: LIST
100170: LIST
100171: LIST
100172: LIST
100173: LIST
100174: LIST
100175: LIST
100176: PUSH
100177: LD_INT 101
100179: PUSH
100180: LD_INT 102
100182: PUSH
100183: LD_INT 103
100185: PUSH
100186: LD_INT 104
100188: PUSH
100189: LD_INT 105
100191: PUSH
100192: LD_INT 106
100194: PUSH
100195: LD_INT 107
100197: PUSH
100198: LD_INT 108
100200: PUSH
100201: LD_INT 109
100203: PUSH
100204: LD_INT 110
100206: PUSH
100207: LD_INT 111
100209: PUSH
100210: LD_INT 112
100212: PUSH
100213: LD_INT 113
100215: PUSH
100216: LD_INT 114
100218: PUSH
100219: LD_INT 115
100221: PUSH
100222: LD_INT 116
100224: PUSH
100225: LD_INT 117
100227: PUSH
100228: LD_INT 118
100230: PUSH
100231: EMPTY
100232: LIST
100233: LIST
100234: LIST
100235: LIST
100236: LIST
100237: LIST
100238: LIST
100239: LIST
100240: LIST
100241: LIST
100242: LIST
100243: LIST
100244: LIST
100245: LIST
100246: LIST
100247: LIST
100248: LIST
100249: LIST
100250: PUSH
100251: EMPTY
100252: LIST
100253: LIST
100254: ST_TO_ADDR
// if result then
100255: LD_VAR 0 2
100259: IFFALSE 101045
// begin normal :=  ;
100261: LD_ADDR_VAR 0 5
100265: PUSH
100266: LD_STRING 
100268: ST_TO_ADDR
// hardcore :=  ;
100269: LD_ADDR_VAR 0 6
100273: PUSH
100274: LD_STRING 
100276: ST_TO_ADDR
// active :=  ;
100277: LD_ADDR_VAR 0 7
100281: PUSH
100282: LD_STRING 
100284: ST_TO_ADDR
// for i = 1 to normalCounter do
100285: LD_ADDR_VAR 0 8
100289: PUSH
100290: DOUBLE
100291: LD_INT 1
100293: DEC
100294: ST_TO_ADDR
100295: LD_EXP 80
100299: PUSH
100300: FOR_TO
100301: IFFALSE 100402
// begin tmp := 0 ;
100303: LD_ADDR_VAR 0 3
100307: PUSH
100308: LD_STRING 0
100310: ST_TO_ADDR
// if result [ 1 ] then
100311: LD_VAR 0 2
100315: PUSH
100316: LD_INT 1
100318: ARRAY
100319: IFFALSE 100384
// if result [ 1 ] [ 1 ] = i then
100321: LD_VAR 0 2
100325: PUSH
100326: LD_INT 1
100328: ARRAY
100329: PUSH
100330: LD_INT 1
100332: ARRAY
100333: PUSH
100334: LD_VAR 0 8
100338: EQUAL
100339: IFFALSE 100384
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100341: LD_ADDR_VAR 0 2
100345: PUSH
100346: LD_VAR 0 2
100350: PPUSH
100351: LD_INT 1
100353: PPUSH
100354: LD_VAR 0 2
100358: PUSH
100359: LD_INT 1
100361: ARRAY
100362: PPUSH
100363: LD_INT 1
100365: PPUSH
100366: CALL_OW 3
100370: PPUSH
100371: CALL_OW 1
100375: ST_TO_ADDR
// tmp := 1 ;
100376: LD_ADDR_VAR 0 3
100380: PUSH
100381: LD_STRING 1
100383: ST_TO_ADDR
// end ; normal := normal & tmp ;
100384: LD_ADDR_VAR 0 5
100388: PUSH
100389: LD_VAR 0 5
100393: PUSH
100394: LD_VAR 0 3
100398: STR
100399: ST_TO_ADDR
// end ;
100400: GO 100300
100402: POP
100403: POP
// for i = 1 to hardcoreCounter do
100404: LD_ADDR_VAR 0 8
100408: PUSH
100409: DOUBLE
100410: LD_INT 1
100412: DEC
100413: ST_TO_ADDR
100414: LD_EXP 81
100418: PUSH
100419: FOR_TO
100420: IFFALSE 100525
// begin tmp := 0 ;
100422: LD_ADDR_VAR 0 3
100426: PUSH
100427: LD_STRING 0
100429: ST_TO_ADDR
// if result [ 2 ] then
100430: LD_VAR 0 2
100434: PUSH
100435: LD_INT 2
100437: ARRAY
100438: IFFALSE 100507
// if result [ 2 ] [ 1 ] = 100 + i then
100440: LD_VAR 0 2
100444: PUSH
100445: LD_INT 2
100447: ARRAY
100448: PUSH
100449: LD_INT 1
100451: ARRAY
100452: PUSH
100453: LD_INT 100
100455: PUSH
100456: LD_VAR 0 8
100460: PLUS
100461: EQUAL
100462: IFFALSE 100507
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100464: LD_ADDR_VAR 0 2
100468: PUSH
100469: LD_VAR 0 2
100473: PPUSH
100474: LD_INT 2
100476: PPUSH
100477: LD_VAR 0 2
100481: PUSH
100482: LD_INT 2
100484: ARRAY
100485: PPUSH
100486: LD_INT 1
100488: PPUSH
100489: CALL_OW 3
100493: PPUSH
100494: CALL_OW 1
100498: ST_TO_ADDR
// tmp := 1 ;
100499: LD_ADDR_VAR 0 3
100503: PUSH
100504: LD_STRING 1
100506: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100507: LD_ADDR_VAR 0 6
100511: PUSH
100512: LD_VAR 0 6
100516: PUSH
100517: LD_VAR 0 3
100521: STR
100522: ST_TO_ADDR
// end ;
100523: GO 100419
100525: POP
100526: POP
// if isGameLoad then
100527: LD_VAR 0 1
100531: IFFALSE 101006
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100533: LD_ADDR_VAR 0 4
100537: PUSH
100538: LD_EXP 84
100542: PUSH
100543: LD_EXP 83
100547: PUSH
100548: LD_EXP 85
100552: PUSH
100553: LD_EXP 82
100557: PUSH
100558: LD_EXP 86
100562: PUSH
100563: LD_EXP 87
100567: PUSH
100568: LD_EXP 88
100572: PUSH
100573: LD_EXP 89
100577: PUSH
100578: LD_EXP 90
100582: PUSH
100583: LD_EXP 91
100587: PUSH
100588: LD_EXP 92
100592: PUSH
100593: LD_EXP 93
100597: PUSH
100598: LD_EXP 94
100602: PUSH
100603: LD_EXP 95
100607: PUSH
100608: LD_EXP 103
100612: PUSH
100613: LD_EXP 104
100617: PUSH
100618: LD_EXP 105
100622: PUSH
100623: LD_EXP 106
100627: PUSH
100628: LD_EXP 108
100632: PUSH
100633: LD_EXP 109
100637: PUSH
100638: LD_EXP 110
100642: PUSH
100643: LD_EXP 113
100647: PUSH
100648: LD_EXP 115
100652: PUSH
100653: LD_EXP 116
100657: PUSH
100658: LD_EXP 117
100662: PUSH
100663: LD_EXP 119
100667: PUSH
100668: LD_EXP 120
100672: PUSH
100673: LD_EXP 123
100677: PUSH
100678: LD_EXP 124
100682: PUSH
100683: LD_EXP 125
100687: PUSH
100688: LD_EXP 126
100692: PUSH
100693: LD_EXP 127
100697: PUSH
100698: LD_EXP 128
100702: PUSH
100703: LD_EXP 129
100707: PUSH
100708: LD_EXP 130
100712: PUSH
100713: LD_EXP 131
100717: PUSH
100718: LD_EXP 96
100722: PUSH
100723: LD_EXP 97
100727: PUSH
100728: LD_EXP 100
100732: PUSH
100733: LD_EXP 101
100737: PUSH
100738: LD_EXP 102
100742: PUSH
100743: LD_EXP 98
100747: PUSH
100748: LD_EXP 99
100752: PUSH
100753: LD_EXP 107
100757: PUSH
100758: LD_EXP 111
100762: PUSH
100763: LD_EXP 112
100767: PUSH
100768: LD_EXP 114
100772: PUSH
100773: LD_EXP 118
100777: PUSH
100778: LD_EXP 121
100782: PUSH
100783: LD_EXP 122
100787: PUSH
100788: LD_EXP 132
100792: PUSH
100793: LD_EXP 133
100797: PUSH
100798: LD_EXP 134
100802: PUSH
100803: LD_EXP 135
100807: PUSH
100808: EMPTY
100809: LIST
100810: LIST
100811: LIST
100812: LIST
100813: LIST
100814: LIST
100815: LIST
100816: LIST
100817: LIST
100818: LIST
100819: LIST
100820: LIST
100821: LIST
100822: LIST
100823: LIST
100824: LIST
100825: LIST
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: LIST
100831: LIST
100832: LIST
100833: LIST
100834: LIST
100835: LIST
100836: LIST
100837: LIST
100838: LIST
100839: LIST
100840: LIST
100841: LIST
100842: LIST
100843: LIST
100844: LIST
100845: LIST
100846: LIST
100847: LIST
100848: LIST
100849: LIST
100850: LIST
100851: LIST
100852: LIST
100853: LIST
100854: LIST
100855: LIST
100856: LIST
100857: LIST
100858: LIST
100859: LIST
100860: LIST
100861: LIST
100862: LIST
100863: ST_TO_ADDR
// tmp :=  ;
100864: LD_ADDR_VAR 0 3
100868: PUSH
100869: LD_STRING 
100871: ST_TO_ADDR
// for i = 1 to normalCounter do
100872: LD_ADDR_VAR 0 8
100876: PUSH
100877: DOUBLE
100878: LD_INT 1
100880: DEC
100881: ST_TO_ADDR
100882: LD_EXP 80
100886: PUSH
100887: FOR_TO
100888: IFFALSE 100924
// begin if flags [ i ] then
100890: LD_VAR 0 4
100894: PUSH
100895: LD_VAR 0 8
100899: ARRAY
100900: IFFALSE 100922
// tmp := tmp & i & ; ;
100902: LD_ADDR_VAR 0 3
100906: PUSH
100907: LD_VAR 0 3
100911: PUSH
100912: LD_VAR 0 8
100916: STR
100917: PUSH
100918: LD_STRING ;
100920: STR
100921: ST_TO_ADDR
// end ;
100922: GO 100887
100924: POP
100925: POP
// for i = 1 to hardcoreCounter do
100926: LD_ADDR_VAR 0 8
100930: PUSH
100931: DOUBLE
100932: LD_INT 1
100934: DEC
100935: ST_TO_ADDR
100936: LD_EXP 81
100940: PUSH
100941: FOR_TO
100942: IFFALSE 100988
// begin if flags [ normalCounter + i ] then
100944: LD_VAR 0 4
100948: PUSH
100949: LD_EXP 80
100953: PUSH
100954: LD_VAR 0 8
100958: PLUS
100959: ARRAY
100960: IFFALSE 100986
// tmp := tmp & ( 100 + i ) & ; ;
100962: LD_ADDR_VAR 0 3
100966: PUSH
100967: LD_VAR 0 3
100971: PUSH
100972: LD_INT 100
100974: PUSH
100975: LD_VAR 0 8
100979: PLUS
100980: STR
100981: PUSH
100982: LD_STRING ;
100984: STR
100985: ST_TO_ADDR
// end ;
100986: GO 100941
100988: POP
100989: POP
// if tmp then
100990: LD_VAR 0 3
100994: IFFALSE 101006
// active := tmp ;
100996: LD_ADDR_VAR 0 7
101000: PUSH
101001: LD_VAR 0 3
101005: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
101006: LD_STRING getStreamItemsFromMission("
101008: PUSH
101009: LD_VAR 0 5
101013: STR
101014: PUSH
101015: LD_STRING ","
101017: STR
101018: PUSH
101019: LD_VAR 0 6
101023: STR
101024: PUSH
101025: LD_STRING ","
101027: STR
101028: PUSH
101029: LD_VAR 0 7
101033: STR
101034: PUSH
101035: LD_STRING ")
101037: STR
101038: PPUSH
101039: CALL_OW 559
// end else
101043: GO 101052
// ToLua ( getStreamItemsFromMission("","","") ) ;
101045: LD_STRING getStreamItemsFromMission("","","")
101047: PPUSH
101048: CALL_OW 559
// end ;
101052: LD_VAR 0 2
101056: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
101057: LD_EXP 79
101061: PUSH
101062: LD_EXP 84
101066: AND
101067: IFFALSE 101191
101069: GO 101071
101071: DISABLE
101072: LD_INT 0
101074: PPUSH
101075: PPUSH
// begin enable ;
101076: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
101077: LD_ADDR_VAR 0 2
101081: PUSH
101082: LD_INT 22
101084: PUSH
101085: LD_OWVAR 2
101089: PUSH
101090: EMPTY
101091: LIST
101092: LIST
101093: PUSH
101094: LD_INT 2
101096: PUSH
101097: LD_INT 34
101099: PUSH
101100: LD_INT 7
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: PUSH
101107: LD_INT 34
101109: PUSH
101110: LD_INT 45
101112: PUSH
101113: EMPTY
101114: LIST
101115: LIST
101116: PUSH
101117: LD_INT 34
101119: PUSH
101120: LD_INT 28
101122: PUSH
101123: EMPTY
101124: LIST
101125: LIST
101126: PUSH
101127: LD_INT 34
101129: PUSH
101130: LD_INT 47
101132: PUSH
101133: EMPTY
101134: LIST
101135: LIST
101136: PUSH
101137: EMPTY
101138: LIST
101139: LIST
101140: LIST
101141: LIST
101142: LIST
101143: PUSH
101144: EMPTY
101145: LIST
101146: LIST
101147: PPUSH
101148: CALL_OW 69
101152: ST_TO_ADDR
// if not tmp then
101153: LD_VAR 0 2
101157: NOT
101158: IFFALSE 101162
// exit ;
101160: GO 101191
// for i in tmp do
101162: LD_ADDR_VAR 0 1
101166: PUSH
101167: LD_VAR 0 2
101171: PUSH
101172: FOR_IN
101173: IFFALSE 101189
// begin SetLives ( i , 0 ) ;
101175: LD_VAR 0 1
101179: PPUSH
101180: LD_INT 0
101182: PPUSH
101183: CALL_OW 234
// end ;
101187: GO 101172
101189: POP
101190: POP
// end ;
101191: PPOPN 2
101193: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
101194: LD_EXP 79
101198: PUSH
101199: LD_EXP 85
101203: AND
101204: IFFALSE 101288
101206: GO 101208
101208: DISABLE
101209: LD_INT 0
101211: PPUSH
101212: PPUSH
// begin enable ;
101213: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101214: LD_ADDR_VAR 0 2
101218: PUSH
101219: LD_INT 22
101221: PUSH
101222: LD_OWVAR 2
101226: PUSH
101227: EMPTY
101228: LIST
101229: LIST
101230: PUSH
101231: LD_INT 32
101233: PUSH
101234: LD_INT 3
101236: PUSH
101237: EMPTY
101238: LIST
101239: LIST
101240: PUSH
101241: EMPTY
101242: LIST
101243: LIST
101244: PPUSH
101245: CALL_OW 69
101249: ST_TO_ADDR
// if not tmp then
101250: LD_VAR 0 2
101254: NOT
101255: IFFALSE 101259
// exit ;
101257: GO 101288
// for i in tmp do
101259: LD_ADDR_VAR 0 1
101263: PUSH
101264: LD_VAR 0 2
101268: PUSH
101269: FOR_IN
101270: IFFALSE 101286
// begin SetLives ( i , 0 ) ;
101272: LD_VAR 0 1
101276: PPUSH
101277: LD_INT 0
101279: PPUSH
101280: CALL_OW 234
// end ;
101284: GO 101269
101286: POP
101287: POP
// end ;
101288: PPOPN 2
101290: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101291: LD_EXP 79
101295: PUSH
101296: LD_EXP 82
101300: AND
101301: IFFALSE 101394
101303: GO 101305
101305: DISABLE
101306: LD_INT 0
101308: PPUSH
// begin enable ;
101309: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101310: LD_ADDR_VAR 0 1
101314: PUSH
101315: LD_INT 22
101317: PUSH
101318: LD_OWVAR 2
101322: PUSH
101323: EMPTY
101324: LIST
101325: LIST
101326: PUSH
101327: LD_INT 2
101329: PUSH
101330: LD_INT 25
101332: PUSH
101333: LD_INT 5
101335: PUSH
101336: EMPTY
101337: LIST
101338: LIST
101339: PUSH
101340: LD_INT 25
101342: PUSH
101343: LD_INT 9
101345: PUSH
101346: EMPTY
101347: LIST
101348: LIST
101349: PUSH
101350: LD_INT 25
101352: PUSH
101353: LD_INT 8
101355: PUSH
101356: EMPTY
101357: LIST
101358: LIST
101359: PUSH
101360: EMPTY
101361: LIST
101362: LIST
101363: LIST
101364: LIST
101365: PUSH
101366: EMPTY
101367: LIST
101368: LIST
101369: PPUSH
101370: CALL_OW 69
101374: PUSH
101375: FOR_IN
101376: IFFALSE 101392
// begin SetClass ( i , 1 ) ;
101378: LD_VAR 0 1
101382: PPUSH
101383: LD_INT 1
101385: PPUSH
101386: CALL_OW 336
// end ;
101390: GO 101375
101392: POP
101393: POP
// end ;
101394: PPOPN 1
101396: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101397: LD_EXP 79
101401: PUSH
101402: LD_EXP 83
101406: AND
101407: PUSH
101408: LD_OWVAR 65
101412: PUSH
101413: LD_INT 7
101415: LESS
101416: AND
101417: IFFALSE 101431
101419: GO 101421
101421: DISABLE
// begin enable ;
101422: ENABLE
// game_speed := 7 ;
101423: LD_ADDR_OWVAR 65
101427: PUSH
101428: LD_INT 7
101430: ST_TO_ADDR
// end ;
101431: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101432: LD_EXP 79
101436: PUSH
101437: LD_EXP 86
101441: AND
101442: IFFALSE 101644
101444: GO 101446
101446: DISABLE
101447: LD_INT 0
101449: PPUSH
101450: PPUSH
101451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101452: LD_ADDR_VAR 0 3
101456: PUSH
101457: LD_INT 81
101459: PUSH
101460: LD_OWVAR 2
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: PUSH
101469: LD_INT 21
101471: PUSH
101472: LD_INT 1
101474: PUSH
101475: EMPTY
101476: LIST
101477: LIST
101478: PUSH
101479: EMPTY
101480: LIST
101481: LIST
101482: PPUSH
101483: CALL_OW 69
101487: ST_TO_ADDR
// if not tmp then
101488: LD_VAR 0 3
101492: NOT
101493: IFFALSE 101497
// exit ;
101495: GO 101644
// if tmp > 5 then
101497: LD_VAR 0 3
101501: PUSH
101502: LD_INT 5
101504: GREATER
101505: IFFALSE 101517
// k := 5 else
101507: LD_ADDR_VAR 0 2
101511: PUSH
101512: LD_INT 5
101514: ST_TO_ADDR
101515: GO 101527
// k := tmp ;
101517: LD_ADDR_VAR 0 2
101521: PUSH
101522: LD_VAR 0 3
101526: ST_TO_ADDR
// for i := 1 to k do
101527: LD_ADDR_VAR 0 1
101531: PUSH
101532: DOUBLE
101533: LD_INT 1
101535: DEC
101536: ST_TO_ADDR
101537: LD_VAR 0 2
101541: PUSH
101542: FOR_TO
101543: IFFALSE 101642
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101545: LD_VAR 0 3
101549: PUSH
101550: LD_VAR 0 1
101554: ARRAY
101555: PPUSH
101556: LD_VAR 0 1
101560: PUSH
101561: LD_INT 4
101563: MOD
101564: PUSH
101565: LD_INT 1
101567: PLUS
101568: PPUSH
101569: CALL_OW 259
101573: PUSH
101574: LD_INT 10
101576: LESS
101577: IFFALSE 101640
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101579: LD_VAR 0 3
101583: PUSH
101584: LD_VAR 0 1
101588: ARRAY
101589: PPUSH
101590: LD_VAR 0 1
101594: PUSH
101595: LD_INT 4
101597: MOD
101598: PUSH
101599: LD_INT 1
101601: PLUS
101602: PPUSH
101603: LD_VAR 0 3
101607: PUSH
101608: LD_VAR 0 1
101612: ARRAY
101613: PPUSH
101614: LD_VAR 0 1
101618: PUSH
101619: LD_INT 4
101621: MOD
101622: PUSH
101623: LD_INT 1
101625: PLUS
101626: PPUSH
101627: CALL_OW 259
101631: PUSH
101632: LD_INT 1
101634: PLUS
101635: PPUSH
101636: CALL_OW 237
101640: GO 101542
101642: POP
101643: POP
// end ;
101644: PPOPN 3
101646: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101647: LD_EXP 79
101651: PUSH
101652: LD_EXP 87
101656: AND
101657: IFFALSE 101677
101659: GO 101661
101661: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101662: LD_INT 4
101664: PPUSH
101665: LD_OWVAR 2
101669: PPUSH
101670: LD_INT 0
101672: PPUSH
101673: CALL_OW 324
101677: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101678: LD_EXP 79
101682: PUSH
101683: LD_EXP 116
101687: AND
101688: IFFALSE 101708
101690: GO 101692
101692: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101693: LD_INT 19
101695: PPUSH
101696: LD_OWVAR 2
101700: PPUSH
101701: LD_INT 0
101703: PPUSH
101704: CALL_OW 324
101708: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101709: LD_EXP 79
101713: PUSH
101714: LD_EXP 88
101718: AND
101719: IFFALSE 101821
101721: GO 101723
101723: DISABLE
101724: LD_INT 0
101726: PPUSH
101727: PPUSH
// begin enable ;
101728: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101729: LD_ADDR_VAR 0 2
101733: PUSH
101734: LD_INT 22
101736: PUSH
101737: LD_OWVAR 2
101741: PUSH
101742: EMPTY
101743: LIST
101744: LIST
101745: PUSH
101746: LD_INT 2
101748: PUSH
101749: LD_INT 34
101751: PUSH
101752: LD_INT 11
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: LD_INT 34
101761: PUSH
101762: LD_INT 30
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: PUSH
101769: EMPTY
101770: LIST
101771: LIST
101772: LIST
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PPUSH
101778: CALL_OW 69
101782: ST_TO_ADDR
// if not tmp then
101783: LD_VAR 0 2
101787: NOT
101788: IFFALSE 101792
// exit ;
101790: GO 101821
// for i in tmp do
101792: LD_ADDR_VAR 0 1
101796: PUSH
101797: LD_VAR 0 2
101801: PUSH
101802: FOR_IN
101803: IFFALSE 101819
// begin SetLives ( i , 0 ) ;
101805: LD_VAR 0 1
101809: PPUSH
101810: LD_INT 0
101812: PPUSH
101813: CALL_OW 234
// end ;
101817: GO 101802
101819: POP
101820: POP
// end ;
101821: PPOPN 2
101823: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101824: LD_EXP 79
101828: PUSH
101829: LD_EXP 89
101833: AND
101834: IFFALSE 101854
101836: GO 101838
101838: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101839: LD_INT 32
101841: PPUSH
101842: LD_OWVAR 2
101846: PPUSH
101847: LD_INT 0
101849: PPUSH
101850: CALL_OW 324
101854: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101855: LD_EXP 79
101859: PUSH
101860: LD_EXP 90
101864: AND
101865: IFFALSE 102046
101867: GO 101869
101869: DISABLE
101870: LD_INT 0
101872: PPUSH
101873: PPUSH
101874: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101875: LD_ADDR_VAR 0 2
101879: PUSH
101880: LD_INT 22
101882: PUSH
101883: LD_OWVAR 2
101887: PUSH
101888: EMPTY
101889: LIST
101890: LIST
101891: PUSH
101892: LD_INT 33
101894: PUSH
101895: LD_INT 3
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: PUSH
101902: EMPTY
101903: LIST
101904: LIST
101905: PPUSH
101906: CALL_OW 69
101910: ST_TO_ADDR
// if not tmp then
101911: LD_VAR 0 2
101915: NOT
101916: IFFALSE 101920
// exit ;
101918: GO 102046
// side := 0 ;
101920: LD_ADDR_VAR 0 3
101924: PUSH
101925: LD_INT 0
101927: ST_TO_ADDR
// for i := 1 to 8 do
101928: LD_ADDR_VAR 0 1
101932: PUSH
101933: DOUBLE
101934: LD_INT 1
101936: DEC
101937: ST_TO_ADDR
101938: LD_INT 8
101940: PUSH
101941: FOR_TO
101942: IFFALSE 101990
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101944: LD_OWVAR 2
101948: PUSH
101949: LD_VAR 0 1
101953: NONEQUAL
101954: PUSH
101955: LD_OWVAR 2
101959: PPUSH
101960: LD_VAR 0 1
101964: PPUSH
101965: CALL_OW 81
101969: PUSH
101970: LD_INT 2
101972: EQUAL
101973: AND
101974: IFFALSE 101988
// begin side := i ;
101976: LD_ADDR_VAR 0 3
101980: PUSH
101981: LD_VAR 0 1
101985: ST_TO_ADDR
// break ;
101986: GO 101990
// end ;
101988: GO 101941
101990: POP
101991: POP
// if not side then
101992: LD_VAR 0 3
101996: NOT
101997: IFFALSE 102001
// exit ;
101999: GO 102046
// for i := 1 to tmp do
102001: LD_ADDR_VAR 0 1
102005: PUSH
102006: DOUBLE
102007: LD_INT 1
102009: DEC
102010: ST_TO_ADDR
102011: LD_VAR 0 2
102015: PUSH
102016: FOR_TO
102017: IFFALSE 102044
// if Prob ( 60 ) then
102019: LD_INT 60
102021: PPUSH
102022: CALL_OW 13
102026: IFFALSE 102042
// SetSide ( i , side ) ;
102028: LD_VAR 0 1
102032: PPUSH
102033: LD_VAR 0 3
102037: PPUSH
102038: CALL_OW 235
102042: GO 102016
102044: POP
102045: POP
// end ;
102046: PPOPN 3
102048: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
102049: LD_EXP 79
102053: PUSH
102054: LD_EXP 92
102058: AND
102059: IFFALSE 102178
102061: GO 102063
102063: DISABLE
102064: LD_INT 0
102066: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
102067: LD_ADDR_VAR 0 1
102071: PUSH
102072: LD_INT 22
102074: PUSH
102075: LD_OWVAR 2
102079: PUSH
102080: EMPTY
102081: LIST
102082: LIST
102083: PUSH
102084: LD_INT 21
102086: PUSH
102087: LD_INT 1
102089: PUSH
102090: EMPTY
102091: LIST
102092: LIST
102093: PUSH
102094: LD_INT 3
102096: PUSH
102097: LD_INT 23
102099: PUSH
102100: LD_INT 0
102102: PUSH
102103: EMPTY
102104: LIST
102105: LIST
102106: PUSH
102107: EMPTY
102108: LIST
102109: LIST
102110: PUSH
102111: EMPTY
102112: LIST
102113: LIST
102114: LIST
102115: PPUSH
102116: CALL_OW 69
102120: PUSH
102121: FOR_IN
102122: IFFALSE 102176
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
102124: LD_VAR 0 1
102128: PPUSH
102129: CALL_OW 257
102133: PUSH
102134: LD_INT 1
102136: PUSH
102137: LD_INT 2
102139: PUSH
102140: LD_INT 3
102142: PUSH
102143: LD_INT 4
102145: PUSH
102146: EMPTY
102147: LIST
102148: LIST
102149: LIST
102150: LIST
102151: IN
102152: IFFALSE 102174
// SetClass ( un , rand ( 1 , 4 ) ) ;
102154: LD_VAR 0 1
102158: PPUSH
102159: LD_INT 1
102161: PPUSH
102162: LD_INT 4
102164: PPUSH
102165: CALL_OW 12
102169: PPUSH
102170: CALL_OW 336
102174: GO 102121
102176: POP
102177: POP
// end ;
102178: PPOPN 1
102180: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
102181: LD_EXP 79
102185: PUSH
102186: LD_EXP 91
102190: AND
102191: IFFALSE 102270
102193: GO 102195
102195: DISABLE
102196: LD_INT 0
102198: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102199: LD_ADDR_VAR 0 1
102203: PUSH
102204: LD_INT 22
102206: PUSH
102207: LD_OWVAR 2
102211: PUSH
102212: EMPTY
102213: LIST
102214: LIST
102215: PUSH
102216: LD_INT 21
102218: PUSH
102219: LD_INT 3
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: PUSH
102226: EMPTY
102227: LIST
102228: LIST
102229: PPUSH
102230: CALL_OW 69
102234: ST_TO_ADDR
// if not tmp then
102235: LD_VAR 0 1
102239: NOT
102240: IFFALSE 102244
// exit ;
102242: GO 102270
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102244: LD_VAR 0 1
102248: PUSH
102249: LD_INT 1
102251: PPUSH
102252: LD_VAR 0 1
102256: PPUSH
102257: CALL_OW 12
102261: ARRAY
102262: PPUSH
102263: LD_INT 100
102265: PPUSH
102266: CALL_OW 234
// end ;
102270: PPOPN 1
102272: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102273: LD_EXP 79
102277: PUSH
102278: LD_EXP 93
102282: AND
102283: IFFALSE 102381
102285: GO 102287
102287: DISABLE
102288: LD_INT 0
102290: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102291: LD_ADDR_VAR 0 1
102295: PUSH
102296: LD_INT 22
102298: PUSH
102299: LD_OWVAR 2
102303: PUSH
102304: EMPTY
102305: LIST
102306: LIST
102307: PUSH
102308: LD_INT 21
102310: PUSH
102311: LD_INT 1
102313: PUSH
102314: EMPTY
102315: LIST
102316: LIST
102317: PUSH
102318: EMPTY
102319: LIST
102320: LIST
102321: PPUSH
102322: CALL_OW 69
102326: ST_TO_ADDR
// if not tmp then
102327: LD_VAR 0 1
102331: NOT
102332: IFFALSE 102336
// exit ;
102334: GO 102381
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102336: LD_VAR 0 1
102340: PUSH
102341: LD_INT 1
102343: PPUSH
102344: LD_VAR 0 1
102348: PPUSH
102349: CALL_OW 12
102353: ARRAY
102354: PPUSH
102355: LD_INT 1
102357: PPUSH
102358: LD_INT 4
102360: PPUSH
102361: CALL_OW 12
102365: PPUSH
102366: LD_INT 3000
102368: PPUSH
102369: LD_INT 9000
102371: PPUSH
102372: CALL_OW 12
102376: PPUSH
102377: CALL_OW 492
// end ;
102381: PPOPN 1
102383: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102384: LD_EXP 79
102388: PUSH
102389: LD_EXP 94
102393: AND
102394: IFFALSE 102414
102396: GO 102398
102398: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102399: LD_INT 1
102401: PPUSH
102402: LD_OWVAR 2
102406: PPUSH
102407: LD_INT 0
102409: PPUSH
102410: CALL_OW 324
102414: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102415: LD_EXP 79
102419: PUSH
102420: LD_EXP 95
102424: AND
102425: IFFALSE 102508
102427: GO 102429
102429: DISABLE
102430: LD_INT 0
102432: PPUSH
102433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102434: LD_ADDR_VAR 0 2
102438: PUSH
102439: LD_INT 22
102441: PUSH
102442: LD_OWVAR 2
102446: PUSH
102447: EMPTY
102448: LIST
102449: LIST
102450: PUSH
102451: LD_INT 21
102453: PUSH
102454: LD_INT 3
102456: PUSH
102457: EMPTY
102458: LIST
102459: LIST
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PPUSH
102465: CALL_OW 69
102469: ST_TO_ADDR
// if not tmp then
102470: LD_VAR 0 2
102474: NOT
102475: IFFALSE 102479
// exit ;
102477: GO 102508
// for i in tmp do
102479: LD_ADDR_VAR 0 1
102483: PUSH
102484: LD_VAR 0 2
102488: PUSH
102489: FOR_IN
102490: IFFALSE 102506
// SetBLevel ( i , 10 ) ;
102492: LD_VAR 0 1
102496: PPUSH
102497: LD_INT 10
102499: PPUSH
102500: CALL_OW 241
102504: GO 102489
102506: POP
102507: POP
// end ;
102508: PPOPN 2
102510: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102511: LD_EXP 79
102515: PUSH
102516: LD_EXP 96
102520: AND
102521: IFFALSE 102632
102523: GO 102525
102525: DISABLE
102526: LD_INT 0
102528: PPUSH
102529: PPUSH
102530: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102531: LD_ADDR_VAR 0 3
102535: PUSH
102536: LD_INT 22
102538: PUSH
102539: LD_OWVAR 2
102543: PUSH
102544: EMPTY
102545: LIST
102546: LIST
102547: PUSH
102548: LD_INT 25
102550: PUSH
102551: LD_INT 1
102553: PUSH
102554: EMPTY
102555: LIST
102556: LIST
102557: PUSH
102558: EMPTY
102559: LIST
102560: LIST
102561: PPUSH
102562: CALL_OW 69
102566: ST_TO_ADDR
// if not tmp then
102567: LD_VAR 0 3
102571: NOT
102572: IFFALSE 102576
// exit ;
102574: GO 102632
// un := tmp [ rand ( 1 , tmp ) ] ;
102576: LD_ADDR_VAR 0 2
102580: PUSH
102581: LD_VAR 0 3
102585: PUSH
102586: LD_INT 1
102588: PPUSH
102589: LD_VAR 0 3
102593: PPUSH
102594: CALL_OW 12
102598: ARRAY
102599: ST_TO_ADDR
// if Crawls ( un ) then
102600: LD_VAR 0 2
102604: PPUSH
102605: CALL_OW 318
102609: IFFALSE 102620
// ComWalk ( un ) ;
102611: LD_VAR 0 2
102615: PPUSH
102616: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102620: LD_VAR 0 2
102624: PPUSH
102625: LD_INT 5
102627: PPUSH
102628: CALL_OW 336
// end ;
102632: PPOPN 3
102634: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102635: LD_EXP 79
102639: PUSH
102640: LD_EXP 97
102644: AND
102645: PUSH
102646: LD_OWVAR 67
102650: PUSH
102651: LD_INT 4
102653: LESS
102654: AND
102655: IFFALSE 102674
102657: GO 102659
102659: DISABLE
// begin Difficulty := Difficulty + 1 ;
102660: LD_ADDR_OWVAR 67
102664: PUSH
102665: LD_OWVAR 67
102669: PUSH
102670: LD_INT 1
102672: PLUS
102673: ST_TO_ADDR
// end ;
102674: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102675: LD_EXP 79
102679: PUSH
102680: LD_EXP 98
102684: AND
102685: IFFALSE 102788
102687: GO 102689
102689: DISABLE
102690: LD_INT 0
102692: PPUSH
// begin for i := 1 to 5 do
102693: LD_ADDR_VAR 0 1
102697: PUSH
102698: DOUBLE
102699: LD_INT 1
102701: DEC
102702: ST_TO_ADDR
102703: LD_INT 5
102705: PUSH
102706: FOR_TO
102707: IFFALSE 102786
// begin uc_nation := nation_nature ;
102709: LD_ADDR_OWVAR 21
102713: PUSH
102714: LD_INT 0
102716: ST_TO_ADDR
// uc_side := 0 ;
102717: LD_ADDR_OWVAR 20
102721: PUSH
102722: LD_INT 0
102724: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102725: LD_ADDR_OWVAR 29
102729: PUSH
102730: LD_INT 12
102732: PUSH
102733: LD_INT 12
102735: PUSH
102736: EMPTY
102737: LIST
102738: LIST
102739: ST_TO_ADDR
// hc_agressivity := 20 ;
102740: LD_ADDR_OWVAR 35
102744: PUSH
102745: LD_INT 20
102747: ST_TO_ADDR
// hc_class := class_tiger ;
102748: LD_ADDR_OWVAR 28
102752: PUSH
102753: LD_INT 14
102755: ST_TO_ADDR
// hc_gallery :=  ;
102756: LD_ADDR_OWVAR 33
102760: PUSH
102761: LD_STRING 
102763: ST_TO_ADDR
// hc_name :=  ;
102764: LD_ADDR_OWVAR 26
102768: PUSH
102769: LD_STRING 
102771: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102772: CALL_OW 44
102776: PPUSH
102777: LD_INT 0
102779: PPUSH
102780: CALL_OW 51
// end ;
102784: GO 102706
102786: POP
102787: POP
// end ;
102788: PPOPN 1
102790: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102791: LD_EXP 79
102795: PUSH
102796: LD_EXP 99
102800: AND
102801: IFFALSE 102810
102803: GO 102805
102805: DISABLE
// StreamSibBomb ;
102806: CALL 102811 0 0
102810: END
// export function StreamSibBomb ; var i , x , y ; begin
102811: LD_INT 0
102813: PPUSH
102814: PPUSH
102815: PPUSH
102816: PPUSH
// result := false ;
102817: LD_ADDR_VAR 0 1
102821: PUSH
102822: LD_INT 0
102824: ST_TO_ADDR
// for i := 1 to 16 do
102825: LD_ADDR_VAR 0 2
102829: PUSH
102830: DOUBLE
102831: LD_INT 1
102833: DEC
102834: ST_TO_ADDR
102835: LD_INT 16
102837: PUSH
102838: FOR_TO
102839: IFFALSE 103038
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102841: LD_ADDR_VAR 0 3
102845: PUSH
102846: LD_INT 10
102848: PUSH
102849: LD_INT 20
102851: PUSH
102852: LD_INT 30
102854: PUSH
102855: LD_INT 40
102857: PUSH
102858: LD_INT 50
102860: PUSH
102861: LD_INT 60
102863: PUSH
102864: LD_INT 70
102866: PUSH
102867: LD_INT 80
102869: PUSH
102870: LD_INT 90
102872: PUSH
102873: LD_INT 100
102875: PUSH
102876: LD_INT 110
102878: PUSH
102879: LD_INT 120
102881: PUSH
102882: LD_INT 130
102884: PUSH
102885: LD_INT 140
102887: PUSH
102888: LD_INT 150
102890: PUSH
102891: EMPTY
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: LIST
102897: LIST
102898: LIST
102899: LIST
102900: LIST
102901: LIST
102902: LIST
102903: LIST
102904: LIST
102905: LIST
102906: LIST
102907: PUSH
102908: LD_INT 1
102910: PPUSH
102911: LD_INT 15
102913: PPUSH
102914: CALL_OW 12
102918: ARRAY
102919: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102920: LD_ADDR_VAR 0 4
102924: PUSH
102925: LD_INT 10
102927: PUSH
102928: LD_INT 20
102930: PUSH
102931: LD_INT 30
102933: PUSH
102934: LD_INT 40
102936: PUSH
102937: LD_INT 50
102939: PUSH
102940: LD_INT 60
102942: PUSH
102943: LD_INT 70
102945: PUSH
102946: LD_INT 80
102948: PUSH
102949: LD_INT 90
102951: PUSH
102952: LD_INT 100
102954: PUSH
102955: LD_INT 110
102957: PUSH
102958: LD_INT 120
102960: PUSH
102961: LD_INT 130
102963: PUSH
102964: LD_INT 140
102966: PUSH
102967: LD_INT 150
102969: PUSH
102970: EMPTY
102971: LIST
102972: LIST
102973: LIST
102974: LIST
102975: LIST
102976: LIST
102977: LIST
102978: LIST
102979: LIST
102980: LIST
102981: LIST
102982: LIST
102983: LIST
102984: LIST
102985: LIST
102986: PUSH
102987: LD_INT 1
102989: PPUSH
102990: LD_INT 15
102992: PPUSH
102993: CALL_OW 12
102997: ARRAY
102998: ST_TO_ADDR
// if ValidHex ( x , y ) then
102999: LD_VAR 0 3
103003: PPUSH
103004: LD_VAR 0 4
103008: PPUSH
103009: CALL_OW 488
103013: IFFALSE 103036
// begin result := [ x , y ] ;
103015: LD_ADDR_VAR 0 1
103019: PUSH
103020: LD_VAR 0 3
103024: PUSH
103025: LD_VAR 0 4
103029: PUSH
103030: EMPTY
103031: LIST
103032: LIST
103033: ST_TO_ADDR
// break ;
103034: GO 103038
// end ; end ;
103036: GO 102838
103038: POP
103039: POP
// if result then
103040: LD_VAR 0 1
103044: IFFALSE 103104
// begin ToLua ( playSibBomb() ) ;
103046: LD_STRING playSibBomb()
103048: PPUSH
103049: CALL_OW 559
// wait ( 0 0$14 ) ;
103053: LD_INT 490
103055: PPUSH
103056: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
103060: LD_VAR 0 1
103064: PUSH
103065: LD_INT 1
103067: ARRAY
103068: PPUSH
103069: LD_VAR 0 1
103073: PUSH
103074: LD_INT 2
103076: ARRAY
103077: PPUSH
103078: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
103082: LD_VAR 0 1
103086: PUSH
103087: LD_INT 1
103089: ARRAY
103090: PPUSH
103091: LD_VAR 0 1
103095: PUSH
103096: LD_INT 2
103098: ARRAY
103099: PPUSH
103100: CALL_OW 429
// end ; end ;
103104: LD_VAR 0 1
103108: RET
// every 0 0$1 trigger StreamModeActive and sReset do
103109: LD_EXP 79
103113: PUSH
103114: LD_EXP 101
103118: AND
103119: IFFALSE 103131
103121: GO 103123
103123: DISABLE
// YouLost (  ) ;
103124: LD_STRING 
103126: PPUSH
103127: CALL_OW 104
103131: END
// every 0 0$1 trigger StreamModeActive and sFog do
103132: LD_EXP 79
103136: PUSH
103137: LD_EXP 100
103141: AND
103142: IFFALSE 103156
103144: GO 103146
103146: DISABLE
// FogOff ( your_side ) ;
103147: LD_OWVAR 2
103151: PPUSH
103152: CALL_OW 344
103156: END
// every 0 0$1 trigger StreamModeActive and sSun do
103157: LD_EXP 79
103161: PUSH
103162: LD_EXP 102
103166: AND
103167: IFFALSE 103195
103169: GO 103171
103171: DISABLE
// begin solar_recharge_percent := 0 ;
103172: LD_ADDR_OWVAR 79
103176: PUSH
103177: LD_INT 0
103179: ST_TO_ADDR
// wait ( 5 5$00 ) ;
103180: LD_INT 10500
103182: PPUSH
103183: CALL_OW 67
// solar_recharge_percent := 100 ;
103187: LD_ADDR_OWVAR 79
103191: PUSH
103192: LD_INT 100
103194: ST_TO_ADDR
// end ;
103195: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
103196: LD_EXP 79
103200: PUSH
103201: LD_EXP 103
103205: AND
103206: IFFALSE 103445
103208: GO 103210
103210: DISABLE
103211: LD_INT 0
103213: PPUSH
103214: PPUSH
103215: PPUSH
// begin tmp := [ ] ;
103216: LD_ADDR_VAR 0 3
103220: PUSH
103221: EMPTY
103222: ST_TO_ADDR
// for i := 1 to 6 do
103223: LD_ADDR_VAR 0 1
103227: PUSH
103228: DOUBLE
103229: LD_INT 1
103231: DEC
103232: ST_TO_ADDR
103233: LD_INT 6
103235: PUSH
103236: FOR_TO
103237: IFFALSE 103342
// begin uc_nation := nation_nature ;
103239: LD_ADDR_OWVAR 21
103243: PUSH
103244: LD_INT 0
103246: ST_TO_ADDR
// uc_side := 0 ;
103247: LD_ADDR_OWVAR 20
103251: PUSH
103252: LD_INT 0
103254: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103255: LD_ADDR_OWVAR 29
103259: PUSH
103260: LD_INT 12
103262: PUSH
103263: LD_INT 12
103265: PUSH
103266: EMPTY
103267: LIST
103268: LIST
103269: ST_TO_ADDR
// hc_agressivity := 20 ;
103270: LD_ADDR_OWVAR 35
103274: PUSH
103275: LD_INT 20
103277: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103278: LD_ADDR_OWVAR 28
103282: PUSH
103283: LD_INT 17
103285: ST_TO_ADDR
// hc_gallery :=  ;
103286: LD_ADDR_OWVAR 33
103290: PUSH
103291: LD_STRING 
103293: ST_TO_ADDR
// hc_name :=  ;
103294: LD_ADDR_OWVAR 26
103298: PUSH
103299: LD_STRING 
103301: ST_TO_ADDR
// un := CreateHuman ;
103302: LD_ADDR_VAR 0 2
103306: PUSH
103307: CALL_OW 44
103311: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103312: LD_VAR 0 2
103316: PPUSH
103317: LD_INT 1
103319: PPUSH
103320: CALL_OW 51
// tmp := tmp ^ un ;
103324: LD_ADDR_VAR 0 3
103328: PUSH
103329: LD_VAR 0 3
103333: PUSH
103334: LD_VAR 0 2
103338: ADD
103339: ST_TO_ADDR
// end ;
103340: GO 103236
103342: POP
103343: POP
// repeat wait ( 0 0$1 ) ;
103344: LD_INT 35
103346: PPUSH
103347: CALL_OW 67
// for un in tmp do
103351: LD_ADDR_VAR 0 2
103355: PUSH
103356: LD_VAR 0 3
103360: PUSH
103361: FOR_IN
103362: IFFALSE 103436
// begin if IsDead ( un ) then
103364: LD_VAR 0 2
103368: PPUSH
103369: CALL_OW 301
103373: IFFALSE 103393
// begin tmp := tmp diff un ;
103375: LD_ADDR_VAR 0 3
103379: PUSH
103380: LD_VAR 0 3
103384: PUSH
103385: LD_VAR 0 2
103389: DIFF
103390: ST_TO_ADDR
// continue ;
103391: GO 103361
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103393: LD_VAR 0 2
103397: PPUSH
103398: LD_INT 3
103400: PUSH
103401: LD_INT 22
103403: PUSH
103404: LD_INT 0
103406: PUSH
103407: EMPTY
103408: LIST
103409: LIST
103410: PUSH
103411: EMPTY
103412: LIST
103413: LIST
103414: PPUSH
103415: CALL_OW 69
103419: PPUSH
103420: LD_VAR 0 2
103424: PPUSH
103425: CALL_OW 74
103429: PPUSH
103430: CALL_OW 115
// end ;
103434: GO 103361
103436: POP
103437: POP
// until not tmp ;
103438: LD_VAR 0 3
103442: NOT
103443: IFFALSE 103344
// end ;
103445: PPOPN 3
103447: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103448: LD_EXP 79
103452: PUSH
103453: LD_EXP 104
103457: AND
103458: IFFALSE 103512
103460: GO 103462
103462: DISABLE
// begin ToLua ( displayTroll(); ) ;
103463: LD_STRING displayTroll();
103465: PPUSH
103466: CALL_OW 559
// wait ( 3 3$00 ) ;
103470: LD_INT 6300
103472: PPUSH
103473: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103477: LD_STRING hideTroll();
103479: PPUSH
103480: CALL_OW 559
// wait ( 1 1$00 ) ;
103484: LD_INT 2100
103486: PPUSH
103487: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103491: LD_STRING displayTroll();
103493: PPUSH
103494: CALL_OW 559
// wait ( 1 1$00 ) ;
103498: LD_INT 2100
103500: PPUSH
103501: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103505: LD_STRING hideTroll();
103507: PPUSH
103508: CALL_OW 559
// end ;
103512: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103513: LD_EXP 79
103517: PUSH
103518: LD_EXP 105
103522: AND
103523: IFFALSE 103586
103525: GO 103527
103527: DISABLE
103528: LD_INT 0
103530: PPUSH
// begin p := 0 ;
103531: LD_ADDR_VAR 0 1
103535: PUSH
103536: LD_INT 0
103538: ST_TO_ADDR
// repeat game_speed := 1 ;
103539: LD_ADDR_OWVAR 65
103543: PUSH
103544: LD_INT 1
103546: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103547: LD_INT 35
103549: PPUSH
103550: CALL_OW 67
// p := p + 1 ;
103554: LD_ADDR_VAR 0 1
103558: PUSH
103559: LD_VAR 0 1
103563: PUSH
103564: LD_INT 1
103566: PLUS
103567: ST_TO_ADDR
// until p >= 60 ;
103568: LD_VAR 0 1
103572: PUSH
103573: LD_INT 60
103575: GREATEREQUAL
103576: IFFALSE 103539
// game_speed := 4 ;
103578: LD_ADDR_OWVAR 65
103582: PUSH
103583: LD_INT 4
103585: ST_TO_ADDR
// end ;
103586: PPOPN 1
103588: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103589: LD_EXP 79
103593: PUSH
103594: LD_EXP 106
103598: AND
103599: IFFALSE 103745
103601: GO 103603
103603: DISABLE
103604: LD_INT 0
103606: PPUSH
103607: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103608: LD_ADDR_VAR 0 1
103612: PUSH
103613: LD_INT 22
103615: PUSH
103616: LD_OWVAR 2
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: PUSH
103625: LD_INT 2
103627: PUSH
103628: LD_INT 30
103630: PUSH
103631: LD_INT 0
103633: PUSH
103634: EMPTY
103635: LIST
103636: LIST
103637: PUSH
103638: LD_INT 30
103640: PUSH
103641: LD_INT 1
103643: PUSH
103644: EMPTY
103645: LIST
103646: LIST
103647: PUSH
103648: EMPTY
103649: LIST
103650: LIST
103651: LIST
103652: PUSH
103653: EMPTY
103654: LIST
103655: LIST
103656: PPUSH
103657: CALL_OW 69
103661: ST_TO_ADDR
// if not depot then
103662: LD_VAR 0 1
103666: NOT
103667: IFFALSE 103671
// exit ;
103669: GO 103745
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103671: LD_ADDR_VAR 0 2
103675: PUSH
103676: LD_VAR 0 1
103680: PUSH
103681: LD_INT 1
103683: PPUSH
103684: LD_VAR 0 1
103688: PPUSH
103689: CALL_OW 12
103693: ARRAY
103694: PPUSH
103695: CALL_OW 274
103699: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103700: LD_VAR 0 2
103704: PPUSH
103705: LD_INT 1
103707: PPUSH
103708: LD_INT 0
103710: PPUSH
103711: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103715: LD_VAR 0 2
103719: PPUSH
103720: LD_INT 2
103722: PPUSH
103723: LD_INT 0
103725: PPUSH
103726: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103730: LD_VAR 0 2
103734: PPUSH
103735: LD_INT 3
103737: PPUSH
103738: LD_INT 0
103740: PPUSH
103741: CALL_OW 277
// end ;
103745: PPOPN 2
103747: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103748: LD_EXP 79
103752: PUSH
103753: LD_EXP 107
103757: AND
103758: IFFALSE 103855
103760: GO 103762
103762: DISABLE
103763: LD_INT 0
103765: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103766: LD_ADDR_VAR 0 1
103770: PUSH
103771: LD_INT 22
103773: PUSH
103774: LD_OWVAR 2
103778: PUSH
103779: EMPTY
103780: LIST
103781: LIST
103782: PUSH
103783: LD_INT 21
103785: PUSH
103786: LD_INT 1
103788: PUSH
103789: EMPTY
103790: LIST
103791: LIST
103792: PUSH
103793: LD_INT 3
103795: PUSH
103796: LD_INT 23
103798: PUSH
103799: LD_INT 0
103801: PUSH
103802: EMPTY
103803: LIST
103804: LIST
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PUSH
103810: EMPTY
103811: LIST
103812: LIST
103813: LIST
103814: PPUSH
103815: CALL_OW 69
103819: ST_TO_ADDR
// if not tmp then
103820: LD_VAR 0 1
103824: NOT
103825: IFFALSE 103829
// exit ;
103827: GO 103855
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103829: LD_VAR 0 1
103833: PUSH
103834: LD_INT 1
103836: PPUSH
103837: LD_VAR 0 1
103841: PPUSH
103842: CALL_OW 12
103846: ARRAY
103847: PPUSH
103848: LD_INT 200
103850: PPUSH
103851: CALL_OW 234
// end ;
103855: PPOPN 1
103857: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103858: LD_EXP 79
103862: PUSH
103863: LD_EXP 108
103867: AND
103868: IFFALSE 103947
103870: GO 103872
103872: DISABLE
103873: LD_INT 0
103875: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103876: LD_ADDR_VAR 0 1
103880: PUSH
103881: LD_INT 22
103883: PUSH
103884: LD_OWVAR 2
103888: PUSH
103889: EMPTY
103890: LIST
103891: LIST
103892: PUSH
103893: LD_INT 21
103895: PUSH
103896: LD_INT 2
103898: PUSH
103899: EMPTY
103900: LIST
103901: LIST
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PPUSH
103907: CALL_OW 69
103911: ST_TO_ADDR
// if not tmp then
103912: LD_VAR 0 1
103916: NOT
103917: IFFALSE 103921
// exit ;
103919: GO 103947
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103921: LD_VAR 0 1
103925: PUSH
103926: LD_INT 1
103928: PPUSH
103929: LD_VAR 0 1
103933: PPUSH
103934: CALL_OW 12
103938: ARRAY
103939: PPUSH
103940: LD_INT 60
103942: PPUSH
103943: CALL_OW 234
// end ;
103947: PPOPN 1
103949: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103950: LD_EXP 79
103954: PUSH
103955: LD_EXP 109
103959: AND
103960: IFFALSE 104059
103962: GO 103964
103964: DISABLE
103965: LD_INT 0
103967: PPUSH
103968: PPUSH
// begin enable ;
103969: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103970: LD_ADDR_VAR 0 1
103974: PUSH
103975: LD_INT 22
103977: PUSH
103978: LD_OWVAR 2
103982: PUSH
103983: EMPTY
103984: LIST
103985: LIST
103986: PUSH
103987: LD_INT 61
103989: PUSH
103990: EMPTY
103991: LIST
103992: PUSH
103993: LD_INT 33
103995: PUSH
103996: LD_INT 2
103998: PUSH
103999: EMPTY
104000: LIST
104001: LIST
104002: PUSH
104003: EMPTY
104004: LIST
104005: LIST
104006: LIST
104007: PPUSH
104008: CALL_OW 69
104012: ST_TO_ADDR
// if not tmp then
104013: LD_VAR 0 1
104017: NOT
104018: IFFALSE 104022
// exit ;
104020: GO 104059
// for i in tmp do
104022: LD_ADDR_VAR 0 2
104026: PUSH
104027: LD_VAR 0 1
104031: PUSH
104032: FOR_IN
104033: IFFALSE 104057
// if IsControledBy ( i ) then
104035: LD_VAR 0 2
104039: PPUSH
104040: CALL_OW 312
104044: IFFALSE 104055
// ComUnlink ( i ) ;
104046: LD_VAR 0 2
104050: PPUSH
104051: CALL_OW 136
104055: GO 104032
104057: POP
104058: POP
// end ;
104059: PPOPN 2
104061: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
104062: LD_EXP 79
104066: PUSH
104067: LD_EXP 110
104071: AND
104072: IFFALSE 104212
104074: GO 104076
104076: DISABLE
104077: LD_INT 0
104079: PPUSH
104080: PPUSH
// begin ToLua ( displayPowell(); ) ;
104081: LD_STRING displayPowell();
104083: PPUSH
104084: CALL_OW 559
// uc_side := 0 ;
104088: LD_ADDR_OWVAR 20
104092: PUSH
104093: LD_INT 0
104095: ST_TO_ADDR
// uc_nation := 2 ;
104096: LD_ADDR_OWVAR 21
104100: PUSH
104101: LD_INT 2
104103: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
104104: LD_ADDR_OWVAR 37
104108: PUSH
104109: LD_INT 14
104111: ST_TO_ADDR
// vc_engine := engine_siberite ;
104112: LD_ADDR_OWVAR 39
104116: PUSH
104117: LD_INT 3
104119: ST_TO_ADDR
// vc_control := control_apeman ;
104120: LD_ADDR_OWVAR 38
104124: PUSH
104125: LD_INT 5
104127: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
104128: LD_ADDR_OWVAR 40
104132: PUSH
104133: LD_INT 29
104135: ST_TO_ADDR
// un := CreateVehicle ;
104136: LD_ADDR_VAR 0 2
104140: PUSH
104141: CALL_OW 45
104145: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104146: LD_VAR 0 2
104150: PPUSH
104151: LD_INT 1
104153: PPUSH
104154: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104158: LD_INT 35
104160: PPUSH
104161: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104165: LD_VAR 0 2
104169: PPUSH
104170: LD_INT 22
104172: PUSH
104173: LD_OWVAR 2
104177: PUSH
104178: EMPTY
104179: LIST
104180: LIST
104181: PPUSH
104182: CALL_OW 69
104186: PPUSH
104187: LD_VAR 0 2
104191: PPUSH
104192: CALL_OW 74
104196: PPUSH
104197: CALL_OW 115
// until IsDead ( un ) ;
104201: LD_VAR 0 2
104205: PPUSH
104206: CALL_OW 301
104210: IFFALSE 104158
// end ;
104212: PPOPN 2
104214: END
// every 0 0$1 trigger StreamModeActive and sStu do
104215: LD_EXP 79
104219: PUSH
104220: LD_EXP 118
104224: AND
104225: IFFALSE 104241
104227: GO 104229
104229: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104230: LD_STRING displayStucuk();
104232: PPUSH
104233: CALL_OW 559
// ResetFog ;
104237: CALL_OW 335
// end ;
104241: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104242: LD_EXP 79
104246: PUSH
104247: LD_EXP 111
104251: AND
104252: IFFALSE 104393
104254: GO 104256
104256: DISABLE
104257: LD_INT 0
104259: PPUSH
104260: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104261: LD_ADDR_VAR 0 2
104265: PUSH
104266: LD_INT 22
104268: PUSH
104269: LD_OWVAR 2
104273: PUSH
104274: EMPTY
104275: LIST
104276: LIST
104277: PUSH
104278: LD_INT 21
104280: PUSH
104281: LD_INT 1
104283: PUSH
104284: EMPTY
104285: LIST
104286: LIST
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: PPUSH
104292: CALL_OW 69
104296: ST_TO_ADDR
// if not tmp then
104297: LD_VAR 0 2
104301: NOT
104302: IFFALSE 104306
// exit ;
104304: GO 104393
// un := tmp [ rand ( 1 , tmp ) ] ;
104306: LD_ADDR_VAR 0 1
104310: PUSH
104311: LD_VAR 0 2
104315: PUSH
104316: LD_INT 1
104318: PPUSH
104319: LD_VAR 0 2
104323: PPUSH
104324: CALL_OW 12
104328: ARRAY
104329: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104330: LD_VAR 0 1
104334: PPUSH
104335: LD_INT 0
104337: PPUSH
104338: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104342: LD_VAR 0 1
104346: PPUSH
104347: LD_OWVAR 3
104351: PUSH
104352: LD_VAR 0 1
104356: DIFF
104357: PPUSH
104358: LD_VAR 0 1
104362: PPUSH
104363: CALL_OW 74
104367: PPUSH
104368: CALL_OW 115
// wait ( 0 0$20 ) ;
104372: LD_INT 700
104374: PPUSH
104375: CALL_OW 67
// SetSide ( un , your_side ) ;
104379: LD_VAR 0 1
104383: PPUSH
104384: LD_OWVAR 2
104388: PPUSH
104389: CALL_OW 235
// end ;
104393: PPOPN 2
104395: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104396: LD_EXP 79
104400: PUSH
104401: LD_EXP 112
104405: AND
104406: IFFALSE 104512
104408: GO 104410
104410: DISABLE
104411: LD_INT 0
104413: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104414: LD_ADDR_VAR 0 1
104418: PUSH
104419: LD_INT 22
104421: PUSH
104422: LD_OWVAR 2
104426: PUSH
104427: EMPTY
104428: LIST
104429: LIST
104430: PUSH
104431: LD_INT 2
104433: PUSH
104434: LD_INT 30
104436: PUSH
104437: LD_INT 0
104439: PUSH
104440: EMPTY
104441: LIST
104442: LIST
104443: PUSH
104444: LD_INT 30
104446: PUSH
104447: LD_INT 1
104449: PUSH
104450: EMPTY
104451: LIST
104452: LIST
104453: PUSH
104454: EMPTY
104455: LIST
104456: LIST
104457: LIST
104458: PUSH
104459: EMPTY
104460: LIST
104461: LIST
104462: PPUSH
104463: CALL_OW 69
104467: ST_TO_ADDR
// if not depot then
104468: LD_VAR 0 1
104472: NOT
104473: IFFALSE 104477
// exit ;
104475: GO 104512
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104477: LD_VAR 0 1
104481: PUSH
104482: LD_INT 1
104484: ARRAY
104485: PPUSH
104486: CALL_OW 250
104490: PPUSH
104491: LD_VAR 0 1
104495: PUSH
104496: LD_INT 1
104498: ARRAY
104499: PPUSH
104500: CALL_OW 251
104504: PPUSH
104505: LD_INT 70
104507: PPUSH
104508: CALL_OW 495
// end ;
104512: PPOPN 1
104514: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104515: LD_EXP 79
104519: PUSH
104520: LD_EXP 113
104524: AND
104525: IFFALSE 104736
104527: GO 104529
104529: DISABLE
104530: LD_INT 0
104532: PPUSH
104533: PPUSH
104534: PPUSH
104535: PPUSH
104536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104537: LD_ADDR_VAR 0 5
104541: PUSH
104542: LD_INT 22
104544: PUSH
104545: LD_OWVAR 2
104549: PUSH
104550: EMPTY
104551: LIST
104552: LIST
104553: PUSH
104554: LD_INT 21
104556: PUSH
104557: LD_INT 1
104559: PUSH
104560: EMPTY
104561: LIST
104562: LIST
104563: PUSH
104564: EMPTY
104565: LIST
104566: LIST
104567: PPUSH
104568: CALL_OW 69
104572: ST_TO_ADDR
// if not tmp then
104573: LD_VAR 0 5
104577: NOT
104578: IFFALSE 104582
// exit ;
104580: GO 104736
// for i in tmp do
104582: LD_ADDR_VAR 0 1
104586: PUSH
104587: LD_VAR 0 5
104591: PUSH
104592: FOR_IN
104593: IFFALSE 104734
// begin d := rand ( 0 , 5 ) ;
104595: LD_ADDR_VAR 0 4
104599: PUSH
104600: LD_INT 0
104602: PPUSH
104603: LD_INT 5
104605: PPUSH
104606: CALL_OW 12
104610: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104611: LD_ADDR_VAR 0 2
104615: PUSH
104616: LD_VAR 0 1
104620: PPUSH
104621: CALL_OW 250
104625: PPUSH
104626: LD_VAR 0 4
104630: PPUSH
104631: LD_INT 3
104633: PPUSH
104634: LD_INT 12
104636: PPUSH
104637: CALL_OW 12
104641: PPUSH
104642: CALL_OW 272
104646: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104647: LD_ADDR_VAR 0 3
104651: PUSH
104652: LD_VAR 0 1
104656: PPUSH
104657: CALL_OW 251
104661: PPUSH
104662: LD_VAR 0 4
104666: PPUSH
104667: LD_INT 3
104669: PPUSH
104670: LD_INT 12
104672: PPUSH
104673: CALL_OW 12
104677: PPUSH
104678: CALL_OW 273
104682: ST_TO_ADDR
// if ValidHex ( x , y ) then
104683: LD_VAR 0 2
104687: PPUSH
104688: LD_VAR 0 3
104692: PPUSH
104693: CALL_OW 488
104697: IFFALSE 104732
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104699: LD_VAR 0 1
104703: PPUSH
104704: LD_VAR 0 2
104708: PPUSH
104709: LD_VAR 0 3
104713: PPUSH
104714: LD_INT 3
104716: PPUSH
104717: LD_INT 6
104719: PPUSH
104720: CALL_OW 12
104724: PPUSH
104725: LD_INT 1
104727: PPUSH
104728: CALL_OW 483
// end ;
104732: GO 104592
104734: POP
104735: POP
// end ;
104736: PPOPN 5
104738: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104739: LD_EXP 79
104743: PUSH
104744: LD_EXP 114
104748: AND
104749: IFFALSE 104843
104751: GO 104753
104753: DISABLE
104754: LD_INT 0
104756: PPUSH
104757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104758: LD_ADDR_VAR 0 2
104762: PUSH
104763: LD_INT 22
104765: PUSH
104766: LD_OWVAR 2
104770: PUSH
104771: EMPTY
104772: LIST
104773: LIST
104774: PUSH
104775: LD_INT 32
104777: PUSH
104778: LD_INT 1
104780: PUSH
104781: EMPTY
104782: LIST
104783: LIST
104784: PUSH
104785: LD_INT 21
104787: PUSH
104788: LD_INT 2
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: PUSH
104795: EMPTY
104796: LIST
104797: LIST
104798: LIST
104799: PPUSH
104800: CALL_OW 69
104804: ST_TO_ADDR
// if not tmp then
104805: LD_VAR 0 2
104809: NOT
104810: IFFALSE 104814
// exit ;
104812: GO 104843
// for i in tmp do
104814: LD_ADDR_VAR 0 1
104818: PUSH
104819: LD_VAR 0 2
104823: PUSH
104824: FOR_IN
104825: IFFALSE 104841
// SetFuel ( i , 0 ) ;
104827: LD_VAR 0 1
104831: PPUSH
104832: LD_INT 0
104834: PPUSH
104835: CALL_OW 240
104839: GO 104824
104841: POP
104842: POP
// end ;
104843: PPOPN 2
104845: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104846: LD_EXP 79
104850: PUSH
104851: LD_EXP 115
104855: AND
104856: IFFALSE 104922
104858: GO 104860
104860: DISABLE
104861: LD_INT 0
104863: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104864: LD_ADDR_VAR 0 1
104868: PUSH
104869: LD_INT 22
104871: PUSH
104872: LD_OWVAR 2
104876: PUSH
104877: EMPTY
104878: LIST
104879: LIST
104880: PUSH
104881: LD_INT 30
104883: PUSH
104884: LD_INT 29
104886: PUSH
104887: EMPTY
104888: LIST
104889: LIST
104890: PUSH
104891: EMPTY
104892: LIST
104893: LIST
104894: PPUSH
104895: CALL_OW 69
104899: ST_TO_ADDR
// if not tmp then
104900: LD_VAR 0 1
104904: NOT
104905: IFFALSE 104909
// exit ;
104907: GO 104922
// DestroyUnit ( tmp [ 1 ] ) ;
104909: LD_VAR 0 1
104913: PUSH
104914: LD_INT 1
104916: ARRAY
104917: PPUSH
104918: CALL_OW 65
// end ;
104922: PPOPN 1
104924: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104925: LD_EXP 79
104929: PUSH
104930: LD_EXP 117
104934: AND
104935: IFFALSE 105064
104937: GO 104939
104939: DISABLE
104940: LD_INT 0
104942: PPUSH
// begin uc_side := 0 ;
104943: LD_ADDR_OWVAR 20
104947: PUSH
104948: LD_INT 0
104950: ST_TO_ADDR
// uc_nation := nation_arabian ;
104951: LD_ADDR_OWVAR 21
104955: PUSH
104956: LD_INT 2
104958: ST_TO_ADDR
// hc_gallery :=  ;
104959: LD_ADDR_OWVAR 33
104963: PUSH
104964: LD_STRING 
104966: ST_TO_ADDR
// hc_name :=  ;
104967: LD_ADDR_OWVAR 26
104971: PUSH
104972: LD_STRING 
104974: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104975: LD_INT 1
104977: PPUSH
104978: LD_INT 11
104980: PPUSH
104981: LD_INT 10
104983: PPUSH
104984: CALL_OW 380
// un := CreateHuman ;
104988: LD_ADDR_VAR 0 1
104992: PUSH
104993: CALL_OW 44
104997: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104998: LD_VAR 0 1
105002: PPUSH
105003: LD_INT 1
105005: PPUSH
105006: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
105010: LD_INT 35
105012: PPUSH
105013: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
105017: LD_VAR 0 1
105021: PPUSH
105022: LD_INT 22
105024: PUSH
105025: LD_OWVAR 2
105029: PUSH
105030: EMPTY
105031: LIST
105032: LIST
105033: PPUSH
105034: CALL_OW 69
105038: PPUSH
105039: LD_VAR 0 1
105043: PPUSH
105044: CALL_OW 74
105048: PPUSH
105049: CALL_OW 115
// until IsDead ( un ) ;
105053: LD_VAR 0 1
105057: PPUSH
105058: CALL_OW 301
105062: IFFALSE 105010
// end ;
105064: PPOPN 1
105066: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
105067: LD_EXP 79
105071: PUSH
105072: LD_EXP 119
105076: AND
105077: IFFALSE 105089
105079: GO 105081
105081: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
105082: LD_STRING earthquake(getX(game), 0, 32)
105084: PPUSH
105085: CALL_OW 559
105089: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
105090: LD_EXP 79
105094: PUSH
105095: LD_EXP 120
105099: AND
105100: IFFALSE 105191
105102: GO 105104
105104: DISABLE
105105: LD_INT 0
105107: PPUSH
// begin enable ;
105108: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
105109: LD_ADDR_VAR 0 1
105113: PUSH
105114: LD_INT 22
105116: PUSH
105117: LD_OWVAR 2
105121: PUSH
105122: EMPTY
105123: LIST
105124: LIST
105125: PUSH
105126: LD_INT 21
105128: PUSH
105129: LD_INT 2
105131: PUSH
105132: EMPTY
105133: LIST
105134: LIST
105135: PUSH
105136: LD_INT 33
105138: PUSH
105139: LD_INT 3
105141: PUSH
105142: EMPTY
105143: LIST
105144: LIST
105145: PUSH
105146: EMPTY
105147: LIST
105148: LIST
105149: LIST
105150: PPUSH
105151: CALL_OW 69
105155: ST_TO_ADDR
// if not tmp then
105156: LD_VAR 0 1
105160: NOT
105161: IFFALSE 105165
// exit ;
105163: GO 105191
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105165: LD_VAR 0 1
105169: PUSH
105170: LD_INT 1
105172: PPUSH
105173: LD_VAR 0 1
105177: PPUSH
105178: CALL_OW 12
105182: ARRAY
105183: PPUSH
105184: LD_INT 1
105186: PPUSH
105187: CALL_OW 234
// end ;
105191: PPOPN 1
105193: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
105194: LD_EXP 79
105198: PUSH
105199: LD_EXP 121
105203: AND
105204: IFFALSE 105345
105206: GO 105208
105208: DISABLE
105209: LD_INT 0
105211: PPUSH
105212: PPUSH
105213: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105214: LD_ADDR_VAR 0 3
105218: PUSH
105219: LD_INT 22
105221: PUSH
105222: LD_OWVAR 2
105226: PUSH
105227: EMPTY
105228: LIST
105229: LIST
105230: PUSH
105231: LD_INT 25
105233: PUSH
105234: LD_INT 1
105236: PUSH
105237: EMPTY
105238: LIST
105239: LIST
105240: PUSH
105241: EMPTY
105242: LIST
105243: LIST
105244: PPUSH
105245: CALL_OW 69
105249: ST_TO_ADDR
// if not tmp then
105250: LD_VAR 0 3
105254: NOT
105255: IFFALSE 105259
// exit ;
105257: GO 105345
// un := tmp [ rand ( 1 , tmp ) ] ;
105259: LD_ADDR_VAR 0 2
105263: PUSH
105264: LD_VAR 0 3
105268: PUSH
105269: LD_INT 1
105271: PPUSH
105272: LD_VAR 0 3
105276: PPUSH
105277: CALL_OW 12
105281: ARRAY
105282: ST_TO_ADDR
// if Crawls ( un ) then
105283: LD_VAR 0 2
105287: PPUSH
105288: CALL_OW 318
105292: IFFALSE 105303
// ComWalk ( un ) ;
105294: LD_VAR 0 2
105298: PPUSH
105299: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105303: LD_VAR 0 2
105307: PPUSH
105308: LD_INT 9
105310: PPUSH
105311: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105315: LD_INT 28
105317: PPUSH
105318: LD_OWVAR 2
105322: PPUSH
105323: LD_INT 2
105325: PPUSH
105326: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105330: LD_INT 29
105332: PPUSH
105333: LD_OWVAR 2
105337: PPUSH
105338: LD_INT 2
105340: PPUSH
105341: CALL_OW 322
// end ;
105345: PPOPN 3
105347: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105348: LD_EXP 79
105352: PUSH
105353: LD_EXP 122
105357: AND
105358: IFFALSE 105469
105360: GO 105362
105362: DISABLE
105363: LD_INT 0
105365: PPUSH
105366: PPUSH
105367: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105368: LD_ADDR_VAR 0 3
105372: PUSH
105373: LD_INT 22
105375: PUSH
105376: LD_OWVAR 2
105380: PUSH
105381: EMPTY
105382: LIST
105383: LIST
105384: PUSH
105385: LD_INT 25
105387: PUSH
105388: LD_INT 1
105390: PUSH
105391: EMPTY
105392: LIST
105393: LIST
105394: PUSH
105395: EMPTY
105396: LIST
105397: LIST
105398: PPUSH
105399: CALL_OW 69
105403: ST_TO_ADDR
// if not tmp then
105404: LD_VAR 0 3
105408: NOT
105409: IFFALSE 105413
// exit ;
105411: GO 105469
// un := tmp [ rand ( 1 , tmp ) ] ;
105413: LD_ADDR_VAR 0 2
105417: PUSH
105418: LD_VAR 0 3
105422: PUSH
105423: LD_INT 1
105425: PPUSH
105426: LD_VAR 0 3
105430: PPUSH
105431: CALL_OW 12
105435: ARRAY
105436: ST_TO_ADDR
// if Crawls ( un ) then
105437: LD_VAR 0 2
105441: PPUSH
105442: CALL_OW 318
105446: IFFALSE 105457
// ComWalk ( un ) ;
105448: LD_VAR 0 2
105452: PPUSH
105453: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105457: LD_VAR 0 2
105461: PPUSH
105462: LD_INT 8
105464: PPUSH
105465: CALL_OW 336
// end ;
105469: PPOPN 3
105471: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105472: LD_EXP 79
105476: PUSH
105477: LD_EXP 123
105481: AND
105482: IFFALSE 105626
105484: GO 105486
105486: DISABLE
105487: LD_INT 0
105489: PPUSH
105490: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105491: LD_ADDR_VAR 0 2
105495: PUSH
105496: LD_INT 22
105498: PUSH
105499: LD_OWVAR 2
105503: PUSH
105504: EMPTY
105505: LIST
105506: LIST
105507: PUSH
105508: LD_INT 21
105510: PUSH
105511: LD_INT 2
105513: PUSH
105514: EMPTY
105515: LIST
105516: LIST
105517: PUSH
105518: LD_INT 2
105520: PUSH
105521: LD_INT 34
105523: PUSH
105524: LD_INT 12
105526: PUSH
105527: EMPTY
105528: LIST
105529: LIST
105530: PUSH
105531: LD_INT 34
105533: PUSH
105534: LD_INT 51
105536: PUSH
105537: EMPTY
105538: LIST
105539: LIST
105540: PUSH
105541: LD_INT 34
105543: PUSH
105544: LD_INT 32
105546: PUSH
105547: EMPTY
105548: LIST
105549: LIST
105550: PUSH
105551: EMPTY
105552: LIST
105553: LIST
105554: LIST
105555: LIST
105556: PUSH
105557: EMPTY
105558: LIST
105559: LIST
105560: LIST
105561: PPUSH
105562: CALL_OW 69
105566: ST_TO_ADDR
// if not tmp then
105567: LD_VAR 0 2
105571: NOT
105572: IFFALSE 105576
// exit ;
105574: GO 105626
// for i in tmp do
105576: LD_ADDR_VAR 0 1
105580: PUSH
105581: LD_VAR 0 2
105585: PUSH
105586: FOR_IN
105587: IFFALSE 105624
// if GetCargo ( i , mat_artifact ) = 0 then
105589: LD_VAR 0 1
105593: PPUSH
105594: LD_INT 4
105596: PPUSH
105597: CALL_OW 289
105601: PUSH
105602: LD_INT 0
105604: EQUAL
105605: IFFALSE 105622
// SetCargo ( i , mat_siberit , 100 ) ;
105607: LD_VAR 0 1
105611: PPUSH
105612: LD_INT 3
105614: PPUSH
105615: LD_INT 100
105617: PPUSH
105618: CALL_OW 290
105622: GO 105586
105624: POP
105625: POP
// end ;
105626: PPOPN 2
105628: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105629: LD_EXP 79
105633: PUSH
105634: LD_EXP 124
105638: AND
105639: IFFALSE 105822
105641: GO 105643
105643: DISABLE
105644: LD_INT 0
105646: PPUSH
105647: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105648: LD_ADDR_VAR 0 2
105652: PUSH
105653: LD_INT 22
105655: PUSH
105656: LD_OWVAR 2
105660: PUSH
105661: EMPTY
105662: LIST
105663: LIST
105664: PPUSH
105665: CALL_OW 69
105669: ST_TO_ADDR
// if not tmp then
105670: LD_VAR 0 2
105674: NOT
105675: IFFALSE 105679
// exit ;
105677: GO 105822
// for i := 1 to 2 do
105679: LD_ADDR_VAR 0 1
105683: PUSH
105684: DOUBLE
105685: LD_INT 1
105687: DEC
105688: ST_TO_ADDR
105689: LD_INT 2
105691: PUSH
105692: FOR_TO
105693: IFFALSE 105820
// begin uc_side := your_side ;
105695: LD_ADDR_OWVAR 20
105699: PUSH
105700: LD_OWVAR 2
105704: ST_TO_ADDR
// uc_nation := nation_american ;
105705: LD_ADDR_OWVAR 21
105709: PUSH
105710: LD_INT 1
105712: ST_TO_ADDR
// vc_chassis := us_morphling ;
105713: LD_ADDR_OWVAR 37
105717: PUSH
105718: LD_INT 5
105720: ST_TO_ADDR
// vc_engine := engine_siberite ;
105721: LD_ADDR_OWVAR 39
105725: PUSH
105726: LD_INT 3
105728: ST_TO_ADDR
// vc_control := control_computer ;
105729: LD_ADDR_OWVAR 38
105733: PUSH
105734: LD_INT 3
105736: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105737: LD_ADDR_OWVAR 40
105741: PUSH
105742: LD_INT 10
105744: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105745: LD_VAR 0 2
105749: PUSH
105750: LD_INT 1
105752: ARRAY
105753: PPUSH
105754: CALL_OW 310
105758: NOT
105759: IFFALSE 105806
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105761: CALL_OW 45
105765: PPUSH
105766: LD_VAR 0 2
105770: PUSH
105771: LD_INT 1
105773: ARRAY
105774: PPUSH
105775: CALL_OW 250
105779: PPUSH
105780: LD_VAR 0 2
105784: PUSH
105785: LD_INT 1
105787: ARRAY
105788: PPUSH
105789: CALL_OW 251
105793: PPUSH
105794: LD_INT 12
105796: PPUSH
105797: LD_INT 1
105799: PPUSH
105800: CALL_OW 50
105804: GO 105818
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105806: CALL_OW 45
105810: PPUSH
105811: LD_INT 1
105813: PPUSH
105814: CALL_OW 51
// end ;
105818: GO 105692
105820: POP
105821: POP
// end ;
105822: PPOPN 2
105824: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105825: LD_EXP 79
105829: PUSH
105830: LD_EXP 125
105834: AND
105835: IFFALSE 106057
105837: GO 105839
105839: DISABLE
105840: LD_INT 0
105842: PPUSH
105843: PPUSH
105844: PPUSH
105845: PPUSH
105846: PPUSH
105847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105848: LD_ADDR_VAR 0 6
105852: PUSH
105853: LD_INT 22
105855: PUSH
105856: LD_OWVAR 2
105860: PUSH
105861: EMPTY
105862: LIST
105863: LIST
105864: PUSH
105865: LD_INT 21
105867: PUSH
105868: LD_INT 1
105870: PUSH
105871: EMPTY
105872: LIST
105873: LIST
105874: PUSH
105875: LD_INT 3
105877: PUSH
105878: LD_INT 23
105880: PUSH
105881: LD_INT 0
105883: PUSH
105884: EMPTY
105885: LIST
105886: LIST
105887: PUSH
105888: EMPTY
105889: LIST
105890: LIST
105891: PUSH
105892: EMPTY
105893: LIST
105894: LIST
105895: LIST
105896: PPUSH
105897: CALL_OW 69
105901: ST_TO_ADDR
// if not tmp then
105902: LD_VAR 0 6
105906: NOT
105907: IFFALSE 105911
// exit ;
105909: GO 106057
// s1 := rand ( 1 , 4 ) ;
105911: LD_ADDR_VAR 0 2
105915: PUSH
105916: LD_INT 1
105918: PPUSH
105919: LD_INT 4
105921: PPUSH
105922: CALL_OW 12
105926: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105927: LD_ADDR_VAR 0 4
105931: PUSH
105932: LD_VAR 0 6
105936: PUSH
105937: LD_INT 1
105939: ARRAY
105940: PPUSH
105941: LD_VAR 0 2
105945: PPUSH
105946: CALL_OW 259
105950: ST_TO_ADDR
// if s1 = 1 then
105951: LD_VAR 0 2
105955: PUSH
105956: LD_INT 1
105958: EQUAL
105959: IFFALSE 105979
// s2 := rand ( 2 , 4 ) else
105961: LD_ADDR_VAR 0 3
105965: PUSH
105966: LD_INT 2
105968: PPUSH
105969: LD_INT 4
105971: PPUSH
105972: CALL_OW 12
105976: ST_TO_ADDR
105977: GO 105987
// s2 := 1 ;
105979: LD_ADDR_VAR 0 3
105983: PUSH
105984: LD_INT 1
105986: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105987: LD_ADDR_VAR 0 5
105991: PUSH
105992: LD_VAR 0 6
105996: PUSH
105997: LD_INT 1
105999: ARRAY
106000: PPUSH
106001: LD_VAR 0 3
106005: PPUSH
106006: CALL_OW 259
106010: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
106011: LD_VAR 0 6
106015: PUSH
106016: LD_INT 1
106018: ARRAY
106019: PPUSH
106020: LD_VAR 0 2
106024: PPUSH
106025: LD_VAR 0 5
106029: PPUSH
106030: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
106034: LD_VAR 0 6
106038: PUSH
106039: LD_INT 1
106041: ARRAY
106042: PPUSH
106043: LD_VAR 0 3
106047: PPUSH
106048: LD_VAR 0 4
106052: PPUSH
106053: CALL_OW 237
// end ;
106057: PPOPN 6
106059: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
106060: LD_EXP 79
106064: PUSH
106065: LD_EXP 126
106069: AND
106070: IFFALSE 106149
106072: GO 106074
106074: DISABLE
106075: LD_INT 0
106077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
106078: LD_ADDR_VAR 0 1
106082: PUSH
106083: LD_INT 22
106085: PUSH
106086: LD_OWVAR 2
106090: PUSH
106091: EMPTY
106092: LIST
106093: LIST
106094: PUSH
106095: LD_INT 30
106097: PUSH
106098: LD_INT 3
106100: PUSH
106101: EMPTY
106102: LIST
106103: LIST
106104: PUSH
106105: EMPTY
106106: LIST
106107: LIST
106108: PPUSH
106109: CALL_OW 69
106113: ST_TO_ADDR
// if not tmp then
106114: LD_VAR 0 1
106118: NOT
106119: IFFALSE 106123
// exit ;
106121: GO 106149
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
106123: LD_VAR 0 1
106127: PUSH
106128: LD_INT 1
106130: PPUSH
106131: LD_VAR 0 1
106135: PPUSH
106136: CALL_OW 12
106140: ARRAY
106141: PPUSH
106142: LD_INT 1
106144: PPUSH
106145: CALL_OW 234
// end ;
106149: PPOPN 1
106151: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
106152: LD_EXP 79
106156: PUSH
106157: LD_EXP 127
106161: AND
106162: IFFALSE 106274
106164: GO 106166
106166: DISABLE
106167: LD_INT 0
106169: PPUSH
106170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
106171: LD_ADDR_VAR 0 2
106175: PUSH
106176: LD_INT 22
106178: PUSH
106179: LD_OWVAR 2
106183: PUSH
106184: EMPTY
106185: LIST
106186: LIST
106187: PUSH
106188: LD_INT 2
106190: PUSH
106191: LD_INT 30
106193: PUSH
106194: LD_INT 27
106196: PUSH
106197: EMPTY
106198: LIST
106199: LIST
106200: PUSH
106201: LD_INT 30
106203: PUSH
106204: LD_INT 26
106206: PUSH
106207: EMPTY
106208: LIST
106209: LIST
106210: PUSH
106211: LD_INT 30
106213: PUSH
106214: LD_INT 28
106216: PUSH
106217: EMPTY
106218: LIST
106219: LIST
106220: PUSH
106221: EMPTY
106222: LIST
106223: LIST
106224: LIST
106225: LIST
106226: PUSH
106227: EMPTY
106228: LIST
106229: LIST
106230: PPUSH
106231: CALL_OW 69
106235: ST_TO_ADDR
// if not tmp then
106236: LD_VAR 0 2
106240: NOT
106241: IFFALSE 106245
// exit ;
106243: GO 106274
// for i in tmp do
106245: LD_ADDR_VAR 0 1
106249: PUSH
106250: LD_VAR 0 2
106254: PUSH
106255: FOR_IN
106256: IFFALSE 106272
// SetLives ( i , 1 ) ;
106258: LD_VAR 0 1
106262: PPUSH
106263: LD_INT 1
106265: PPUSH
106266: CALL_OW 234
106270: GO 106255
106272: POP
106273: POP
// end ;
106274: PPOPN 2
106276: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106277: LD_EXP 79
106281: PUSH
106282: LD_EXP 128
106286: AND
106287: IFFALSE 106574
106289: GO 106291
106291: DISABLE
106292: LD_INT 0
106294: PPUSH
106295: PPUSH
106296: PPUSH
// begin i := rand ( 1 , 7 ) ;
106297: LD_ADDR_VAR 0 1
106301: PUSH
106302: LD_INT 1
106304: PPUSH
106305: LD_INT 7
106307: PPUSH
106308: CALL_OW 12
106312: ST_TO_ADDR
// case i of 1 :
106313: LD_VAR 0 1
106317: PUSH
106318: LD_INT 1
106320: DOUBLE
106321: EQUAL
106322: IFTRUE 106326
106324: GO 106336
106326: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106327: LD_STRING earthquake(getX(game), 0, 32)
106329: PPUSH
106330: CALL_OW 559
106334: GO 106574
106336: LD_INT 2
106338: DOUBLE
106339: EQUAL
106340: IFTRUE 106344
106342: GO 106358
106344: POP
// begin ToLua ( displayStucuk(); ) ;
106345: LD_STRING displayStucuk();
106347: PPUSH
106348: CALL_OW 559
// ResetFog ;
106352: CALL_OW 335
// end ; 3 :
106356: GO 106574
106358: LD_INT 3
106360: DOUBLE
106361: EQUAL
106362: IFTRUE 106366
106364: GO 106470
106366: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106367: LD_ADDR_VAR 0 2
106371: PUSH
106372: LD_INT 22
106374: PUSH
106375: LD_OWVAR 2
106379: PUSH
106380: EMPTY
106381: LIST
106382: LIST
106383: PUSH
106384: LD_INT 25
106386: PUSH
106387: LD_INT 1
106389: PUSH
106390: EMPTY
106391: LIST
106392: LIST
106393: PUSH
106394: EMPTY
106395: LIST
106396: LIST
106397: PPUSH
106398: CALL_OW 69
106402: ST_TO_ADDR
// if not tmp then
106403: LD_VAR 0 2
106407: NOT
106408: IFFALSE 106412
// exit ;
106410: GO 106574
// un := tmp [ rand ( 1 , tmp ) ] ;
106412: LD_ADDR_VAR 0 3
106416: PUSH
106417: LD_VAR 0 2
106421: PUSH
106422: LD_INT 1
106424: PPUSH
106425: LD_VAR 0 2
106429: PPUSH
106430: CALL_OW 12
106434: ARRAY
106435: ST_TO_ADDR
// if Crawls ( un ) then
106436: LD_VAR 0 3
106440: PPUSH
106441: CALL_OW 318
106445: IFFALSE 106456
// ComWalk ( un ) ;
106447: LD_VAR 0 3
106451: PPUSH
106452: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106456: LD_VAR 0 3
106460: PPUSH
106461: LD_INT 8
106463: PPUSH
106464: CALL_OW 336
// end ; 4 :
106468: GO 106574
106470: LD_INT 4
106472: DOUBLE
106473: EQUAL
106474: IFTRUE 106478
106476: GO 106552
106478: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106479: LD_ADDR_VAR 0 2
106483: PUSH
106484: LD_INT 22
106486: PUSH
106487: LD_OWVAR 2
106491: PUSH
106492: EMPTY
106493: LIST
106494: LIST
106495: PUSH
106496: LD_INT 30
106498: PUSH
106499: LD_INT 29
106501: PUSH
106502: EMPTY
106503: LIST
106504: LIST
106505: PUSH
106506: EMPTY
106507: LIST
106508: LIST
106509: PPUSH
106510: CALL_OW 69
106514: ST_TO_ADDR
// if not tmp then
106515: LD_VAR 0 2
106519: NOT
106520: IFFALSE 106524
// exit ;
106522: GO 106574
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106524: LD_VAR 0 2
106528: PUSH
106529: LD_INT 1
106531: ARRAY
106532: PPUSH
106533: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106537: LD_VAR 0 2
106541: PUSH
106542: LD_INT 1
106544: ARRAY
106545: PPUSH
106546: CALL_OW 65
// end ; 5 .. 7 :
106550: GO 106574
106552: LD_INT 5
106554: DOUBLE
106555: GREATEREQUAL
106556: IFFALSE 106564
106558: LD_INT 7
106560: DOUBLE
106561: LESSEQUAL
106562: IFTRUE 106566
106564: GO 106573
106566: POP
// StreamSibBomb ; end ;
106567: CALL 102811 0 0
106571: GO 106574
106573: POP
// end ;
106574: PPOPN 3
106576: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106577: LD_EXP 79
106581: PUSH
106582: LD_EXP 129
106586: AND
106587: IFFALSE 106743
106589: GO 106591
106591: DISABLE
106592: LD_INT 0
106594: PPUSH
106595: PPUSH
106596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106597: LD_ADDR_VAR 0 2
106601: PUSH
106602: LD_INT 81
106604: PUSH
106605: LD_OWVAR 2
106609: PUSH
106610: EMPTY
106611: LIST
106612: LIST
106613: PUSH
106614: LD_INT 2
106616: PUSH
106617: LD_INT 21
106619: PUSH
106620: LD_INT 1
106622: PUSH
106623: EMPTY
106624: LIST
106625: LIST
106626: PUSH
106627: LD_INT 21
106629: PUSH
106630: LD_INT 2
106632: PUSH
106633: EMPTY
106634: LIST
106635: LIST
106636: PUSH
106637: EMPTY
106638: LIST
106639: LIST
106640: LIST
106641: PUSH
106642: EMPTY
106643: LIST
106644: LIST
106645: PPUSH
106646: CALL_OW 69
106650: ST_TO_ADDR
// if not tmp then
106651: LD_VAR 0 2
106655: NOT
106656: IFFALSE 106660
// exit ;
106658: GO 106743
// p := 0 ;
106660: LD_ADDR_VAR 0 3
106664: PUSH
106665: LD_INT 0
106667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106668: LD_INT 35
106670: PPUSH
106671: CALL_OW 67
// p := p + 1 ;
106675: LD_ADDR_VAR 0 3
106679: PUSH
106680: LD_VAR 0 3
106684: PUSH
106685: LD_INT 1
106687: PLUS
106688: ST_TO_ADDR
// for i in tmp do
106689: LD_ADDR_VAR 0 1
106693: PUSH
106694: LD_VAR 0 2
106698: PUSH
106699: FOR_IN
106700: IFFALSE 106731
// if GetLives ( i ) < 1000 then
106702: LD_VAR 0 1
106706: PPUSH
106707: CALL_OW 256
106711: PUSH
106712: LD_INT 1000
106714: LESS
106715: IFFALSE 106729
// SetLives ( i , 1000 ) ;
106717: LD_VAR 0 1
106721: PPUSH
106722: LD_INT 1000
106724: PPUSH
106725: CALL_OW 234
106729: GO 106699
106731: POP
106732: POP
// until p > 20 ;
106733: LD_VAR 0 3
106737: PUSH
106738: LD_INT 20
106740: GREATER
106741: IFFALSE 106668
// end ;
106743: PPOPN 3
106745: END
// every 0 0$1 trigger StreamModeActive and sTime do
106746: LD_EXP 79
106750: PUSH
106751: LD_EXP 130
106755: AND
106756: IFFALSE 106791
106758: GO 106760
106760: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106761: LD_INT 28
106763: PPUSH
106764: LD_OWVAR 2
106768: PPUSH
106769: LD_INT 2
106771: PPUSH
106772: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106776: LD_INT 30
106778: PPUSH
106779: LD_OWVAR 2
106783: PPUSH
106784: LD_INT 2
106786: PPUSH
106787: CALL_OW 322
// end ;
106791: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106792: LD_EXP 79
106796: PUSH
106797: LD_EXP 131
106801: AND
106802: IFFALSE 106923
106804: GO 106806
106806: DISABLE
106807: LD_INT 0
106809: PPUSH
106810: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106811: LD_ADDR_VAR 0 2
106815: PUSH
106816: LD_INT 22
106818: PUSH
106819: LD_OWVAR 2
106823: PUSH
106824: EMPTY
106825: LIST
106826: LIST
106827: PUSH
106828: LD_INT 21
106830: PUSH
106831: LD_INT 1
106833: PUSH
106834: EMPTY
106835: LIST
106836: LIST
106837: PUSH
106838: LD_INT 3
106840: PUSH
106841: LD_INT 23
106843: PUSH
106844: LD_INT 0
106846: PUSH
106847: EMPTY
106848: LIST
106849: LIST
106850: PUSH
106851: EMPTY
106852: LIST
106853: LIST
106854: PUSH
106855: EMPTY
106856: LIST
106857: LIST
106858: LIST
106859: PPUSH
106860: CALL_OW 69
106864: ST_TO_ADDR
// if not tmp then
106865: LD_VAR 0 2
106869: NOT
106870: IFFALSE 106874
// exit ;
106872: GO 106923
// for i in tmp do
106874: LD_ADDR_VAR 0 1
106878: PUSH
106879: LD_VAR 0 2
106883: PUSH
106884: FOR_IN
106885: IFFALSE 106921
// begin if Crawls ( i ) then
106887: LD_VAR 0 1
106891: PPUSH
106892: CALL_OW 318
106896: IFFALSE 106907
// ComWalk ( i ) ;
106898: LD_VAR 0 1
106902: PPUSH
106903: CALL_OW 138
// SetClass ( i , 2 ) ;
106907: LD_VAR 0 1
106911: PPUSH
106912: LD_INT 2
106914: PPUSH
106915: CALL_OW 336
// end ;
106919: GO 106884
106921: POP
106922: POP
// end ;
106923: PPOPN 2
106925: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106926: LD_EXP 79
106930: PUSH
106931: LD_EXP 132
106935: AND
106936: IFFALSE 107224
106938: GO 106940
106940: DISABLE
106941: LD_INT 0
106943: PPUSH
106944: PPUSH
106945: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106946: LD_OWVAR 2
106950: PPUSH
106951: LD_INT 9
106953: PPUSH
106954: LD_INT 1
106956: PPUSH
106957: LD_INT 1
106959: PPUSH
106960: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106964: LD_INT 9
106966: PPUSH
106967: LD_OWVAR 2
106971: PPUSH
106972: CALL_OW 343
// uc_side := 9 ;
106976: LD_ADDR_OWVAR 20
106980: PUSH
106981: LD_INT 9
106983: ST_TO_ADDR
// uc_nation := 2 ;
106984: LD_ADDR_OWVAR 21
106988: PUSH
106989: LD_INT 2
106991: ST_TO_ADDR
// hc_name := Dark Warrior ;
106992: LD_ADDR_OWVAR 26
106996: PUSH
106997: LD_STRING Dark Warrior
106999: ST_TO_ADDR
// hc_gallery :=  ;
107000: LD_ADDR_OWVAR 33
107004: PUSH
107005: LD_STRING 
107007: ST_TO_ADDR
// hc_noskilllimit := true ;
107008: LD_ADDR_OWVAR 76
107012: PUSH
107013: LD_INT 1
107015: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
107016: LD_ADDR_OWVAR 31
107020: PUSH
107021: LD_INT 30
107023: PUSH
107024: LD_INT 30
107026: PUSH
107027: LD_INT 30
107029: PUSH
107030: LD_INT 30
107032: PUSH
107033: EMPTY
107034: LIST
107035: LIST
107036: LIST
107037: LIST
107038: ST_TO_ADDR
// un := CreateHuman ;
107039: LD_ADDR_VAR 0 3
107043: PUSH
107044: CALL_OW 44
107048: ST_TO_ADDR
// hc_noskilllimit := false ;
107049: LD_ADDR_OWVAR 76
107053: PUSH
107054: LD_INT 0
107056: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
107057: LD_VAR 0 3
107061: PPUSH
107062: LD_INT 1
107064: PPUSH
107065: CALL_OW 51
// ToLua ( playRanger() ) ;
107069: LD_STRING playRanger()
107071: PPUSH
107072: CALL_OW 559
// p := 0 ;
107076: LD_ADDR_VAR 0 2
107080: PUSH
107081: LD_INT 0
107083: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
107084: LD_INT 35
107086: PPUSH
107087: CALL_OW 67
// p := p + 1 ;
107091: LD_ADDR_VAR 0 2
107095: PUSH
107096: LD_VAR 0 2
107100: PUSH
107101: LD_INT 1
107103: PLUS
107104: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
107105: LD_VAR 0 3
107109: PPUSH
107110: CALL_OW 256
107114: PUSH
107115: LD_INT 1000
107117: LESS
107118: IFFALSE 107132
// SetLives ( un , 1000 ) ;
107120: LD_VAR 0 3
107124: PPUSH
107125: LD_INT 1000
107127: PPUSH
107128: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
107132: LD_VAR 0 3
107136: PPUSH
107137: LD_INT 81
107139: PUSH
107140: LD_OWVAR 2
107144: PUSH
107145: EMPTY
107146: LIST
107147: LIST
107148: PUSH
107149: LD_INT 91
107151: PUSH
107152: LD_VAR 0 3
107156: PUSH
107157: LD_INT 30
107159: PUSH
107160: EMPTY
107161: LIST
107162: LIST
107163: LIST
107164: PUSH
107165: EMPTY
107166: LIST
107167: LIST
107168: PPUSH
107169: CALL_OW 69
107173: PPUSH
107174: LD_VAR 0 3
107178: PPUSH
107179: CALL_OW 74
107183: PPUSH
107184: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
107188: LD_VAR 0 2
107192: PUSH
107193: LD_INT 80
107195: GREATER
107196: PUSH
107197: LD_VAR 0 3
107201: PPUSH
107202: CALL_OW 301
107206: OR
107207: IFFALSE 107084
// if un then
107209: LD_VAR 0 3
107213: IFFALSE 107224
// RemoveUnit ( un ) ;
107215: LD_VAR 0 3
107219: PPUSH
107220: CALL_OW 64
// end ;
107224: PPOPN 3
107226: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107227: LD_EXP 133
107231: IFFALSE 107347
107233: GO 107235
107235: DISABLE
107236: LD_INT 0
107238: PPUSH
107239: PPUSH
107240: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107241: LD_ADDR_VAR 0 2
107245: PUSH
107246: LD_INT 81
107248: PUSH
107249: LD_OWVAR 2
107253: PUSH
107254: EMPTY
107255: LIST
107256: LIST
107257: PUSH
107258: LD_INT 21
107260: PUSH
107261: LD_INT 1
107263: PUSH
107264: EMPTY
107265: LIST
107266: LIST
107267: PUSH
107268: EMPTY
107269: LIST
107270: LIST
107271: PPUSH
107272: CALL_OW 69
107276: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107277: LD_STRING playComputer()
107279: PPUSH
107280: CALL_OW 559
// if not tmp then
107284: LD_VAR 0 2
107288: NOT
107289: IFFALSE 107293
// exit ;
107291: GO 107347
// for i in tmp do
107293: LD_ADDR_VAR 0 1
107297: PUSH
107298: LD_VAR 0 2
107302: PUSH
107303: FOR_IN
107304: IFFALSE 107345
// for j := 1 to 4 do
107306: LD_ADDR_VAR 0 3
107310: PUSH
107311: DOUBLE
107312: LD_INT 1
107314: DEC
107315: ST_TO_ADDR
107316: LD_INT 4
107318: PUSH
107319: FOR_TO
107320: IFFALSE 107341
// SetSkill ( i , j , 10 ) ;
107322: LD_VAR 0 1
107326: PPUSH
107327: LD_VAR 0 3
107331: PPUSH
107332: LD_INT 10
107334: PPUSH
107335: CALL_OW 237
107339: GO 107319
107341: POP
107342: POP
107343: GO 107303
107345: POP
107346: POP
// end ;
107347: PPOPN 3
107349: END
// every 0 0$1 trigger s30 do var i , tmp ;
107350: LD_EXP 134
107354: IFFALSE 107423
107356: GO 107358
107358: DISABLE
107359: LD_INT 0
107361: PPUSH
107362: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107363: LD_ADDR_VAR 0 2
107367: PUSH
107368: LD_INT 22
107370: PUSH
107371: LD_OWVAR 2
107375: PUSH
107376: EMPTY
107377: LIST
107378: LIST
107379: PPUSH
107380: CALL_OW 69
107384: ST_TO_ADDR
// if not tmp then
107385: LD_VAR 0 2
107389: NOT
107390: IFFALSE 107394
// exit ;
107392: GO 107423
// for i in tmp do
107394: LD_ADDR_VAR 0 1
107398: PUSH
107399: LD_VAR 0 2
107403: PUSH
107404: FOR_IN
107405: IFFALSE 107421
// SetLives ( i , 300 ) ;
107407: LD_VAR 0 1
107411: PPUSH
107412: LD_INT 300
107414: PPUSH
107415: CALL_OW 234
107419: GO 107404
107421: POP
107422: POP
// end ;
107423: PPOPN 2
107425: END
// every 0 0$1 trigger s60 do var i , tmp ;
107426: LD_EXP 135
107430: IFFALSE 107499
107432: GO 107434
107434: DISABLE
107435: LD_INT 0
107437: PPUSH
107438: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107439: LD_ADDR_VAR 0 2
107443: PUSH
107444: LD_INT 22
107446: PUSH
107447: LD_OWVAR 2
107451: PUSH
107452: EMPTY
107453: LIST
107454: LIST
107455: PPUSH
107456: CALL_OW 69
107460: ST_TO_ADDR
// if not tmp then
107461: LD_VAR 0 2
107465: NOT
107466: IFFALSE 107470
// exit ;
107468: GO 107499
// for i in tmp do
107470: LD_ADDR_VAR 0 1
107474: PUSH
107475: LD_VAR 0 2
107479: PUSH
107480: FOR_IN
107481: IFFALSE 107497
// SetLives ( i , 600 ) ;
107483: LD_VAR 0 1
107487: PPUSH
107488: LD_INT 600
107490: PPUSH
107491: CALL_OW 234
107495: GO 107480
107497: POP
107498: POP
// end ;
107499: PPOPN 2
107501: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107502: LD_INT 0
107504: PPUSH
// case cmd of 301 :
107505: LD_VAR 0 1
107509: PUSH
107510: LD_INT 301
107512: DOUBLE
107513: EQUAL
107514: IFTRUE 107518
107516: GO 107550
107518: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107519: LD_VAR 0 6
107523: PPUSH
107524: LD_VAR 0 7
107528: PPUSH
107529: LD_VAR 0 8
107533: PPUSH
107534: LD_VAR 0 4
107538: PPUSH
107539: LD_VAR 0 5
107543: PPUSH
107544: CALL 108751 0 5
107548: GO 107671
107550: LD_INT 302
107552: DOUBLE
107553: EQUAL
107554: IFTRUE 107558
107556: GO 107595
107558: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107559: LD_VAR 0 6
107563: PPUSH
107564: LD_VAR 0 7
107568: PPUSH
107569: LD_VAR 0 8
107573: PPUSH
107574: LD_VAR 0 9
107578: PPUSH
107579: LD_VAR 0 4
107583: PPUSH
107584: LD_VAR 0 5
107588: PPUSH
107589: CALL 108842 0 6
107593: GO 107671
107595: LD_INT 303
107597: DOUBLE
107598: EQUAL
107599: IFTRUE 107603
107601: GO 107640
107603: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107604: LD_VAR 0 6
107608: PPUSH
107609: LD_VAR 0 7
107613: PPUSH
107614: LD_VAR 0 8
107618: PPUSH
107619: LD_VAR 0 9
107623: PPUSH
107624: LD_VAR 0 4
107628: PPUSH
107629: LD_VAR 0 5
107633: PPUSH
107634: CALL 107676 0 6
107638: GO 107671
107640: LD_INT 304
107642: DOUBLE
107643: EQUAL
107644: IFTRUE 107648
107646: GO 107670
107648: POP
// hHackTeleport ( unit , x , y ) ; end ;
107649: LD_VAR 0 2
107653: PPUSH
107654: LD_VAR 0 4
107658: PPUSH
107659: LD_VAR 0 5
107663: PPUSH
107664: CALL 109435 0 3
107668: GO 107671
107670: POP
// end ;
107671: LD_VAR 0 12
107675: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107676: LD_INT 0
107678: PPUSH
107679: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107680: LD_VAR 0 1
107684: PUSH
107685: LD_INT 1
107687: LESS
107688: PUSH
107689: LD_VAR 0 1
107693: PUSH
107694: LD_INT 3
107696: GREATER
107697: OR
107698: PUSH
107699: LD_VAR 0 5
107703: PPUSH
107704: LD_VAR 0 6
107708: PPUSH
107709: CALL_OW 428
107713: OR
107714: IFFALSE 107718
// exit ;
107716: GO 108438
// uc_side := your_side ;
107718: LD_ADDR_OWVAR 20
107722: PUSH
107723: LD_OWVAR 2
107727: ST_TO_ADDR
// uc_nation := nation ;
107728: LD_ADDR_OWVAR 21
107732: PUSH
107733: LD_VAR 0 1
107737: ST_TO_ADDR
// bc_level = 1 ;
107738: LD_ADDR_OWVAR 43
107742: PUSH
107743: LD_INT 1
107745: ST_TO_ADDR
// case btype of 1 :
107746: LD_VAR 0 2
107750: PUSH
107751: LD_INT 1
107753: DOUBLE
107754: EQUAL
107755: IFTRUE 107759
107757: GO 107770
107759: POP
// bc_type := b_depot ; 2 :
107760: LD_ADDR_OWVAR 42
107764: PUSH
107765: LD_INT 0
107767: ST_TO_ADDR
107768: GO 108382
107770: LD_INT 2
107772: DOUBLE
107773: EQUAL
107774: IFTRUE 107778
107776: GO 107789
107778: POP
// bc_type := b_warehouse ; 3 :
107779: LD_ADDR_OWVAR 42
107783: PUSH
107784: LD_INT 1
107786: ST_TO_ADDR
107787: GO 108382
107789: LD_INT 3
107791: DOUBLE
107792: EQUAL
107793: IFTRUE 107797
107795: GO 107808
107797: POP
// bc_type := b_lab ; 4 .. 9 :
107798: LD_ADDR_OWVAR 42
107802: PUSH
107803: LD_INT 6
107805: ST_TO_ADDR
107806: GO 108382
107808: LD_INT 4
107810: DOUBLE
107811: GREATEREQUAL
107812: IFFALSE 107820
107814: LD_INT 9
107816: DOUBLE
107817: LESSEQUAL
107818: IFTRUE 107822
107820: GO 107874
107822: POP
// begin bc_type := b_lab_half ;
107823: LD_ADDR_OWVAR 42
107827: PUSH
107828: LD_INT 7
107830: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107831: LD_ADDR_OWVAR 44
107835: PUSH
107836: LD_INT 10
107838: PUSH
107839: LD_INT 11
107841: PUSH
107842: LD_INT 12
107844: PUSH
107845: LD_INT 15
107847: PUSH
107848: LD_INT 14
107850: PUSH
107851: LD_INT 13
107853: PUSH
107854: EMPTY
107855: LIST
107856: LIST
107857: LIST
107858: LIST
107859: LIST
107860: LIST
107861: PUSH
107862: LD_VAR 0 2
107866: PUSH
107867: LD_INT 3
107869: MINUS
107870: ARRAY
107871: ST_TO_ADDR
// end ; 10 .. 13 :
107872: GO 108382
107874: LD_INT 10
107876: DOUBLE
107877: GREATEREQUAL
107878: IFFALSE 107886
107880: LD_INT 13
107882: DOUBLE
107883: LESSEQUAL
107884: IFTRUE 107888
107886: GO 107965
107888: POP
// begin bc_type := b_lab_full ;
107889: LD_ADDR_OWVAR 42
107893: PUSH
107894: LD_INT 8
107896: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107897: LD_ADDR_OWVAR 44
107901: PUSH
107902: LD_INT 10
107904: PUSH
107905: LD_INT 12
107907: PUSH
107908: LD_INT 14
107910: PUSH
107911: LD_INT 13
107913: PUSH
107914: EMPTY
107915: LIST
107916: LIST
107917: LIST
107918: LIST
107919: PUSH
107920: LD_VAR 0 2
107924: PUSH
107925: LD_INT 9
107927: MINUS
107928: ARRAY
107929: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107930: LD_ADDR_OWVAR 45
107934: PUSH
107935: LD_INT 11
107937: PUSH
107938: LD_INT 15
107940: PUSH
107941: LD_INT 12
107943: PUSH
107944: LD_INT 15
107946: PUSH
107947: EMPTY
107948: LIST
107949: LIST
107950: LIST
107951: LIST
107952: PUSH
107953: LD_VAR 0 2
107957: PUSH
107958: LD_INT 9
107960: MINUS
107961: ARRAY
107962: ST_TO_ADDR
// end ; 14 :
107963: GO 108382
107965: LD_INT 14
107967: DOUBLE
107968: EQUAL
107969: IFTRUE 107973
107971: GO 107984
107973: POP
// bc_type := b_workshop ; 15 :
107974: LD_ADDR_OWVAR 42
107978: PUSH
107979: LD_INT 2
107981: ST_TO_ADDR
107982: GO 108382
107984: LD_INT 15
107986: DOUBLE
107987: EQUAL
107988: IFTRUE 107992
107990: GO 108003
107992: POP
// bc_type := b_factory ; 16 :
107993: LD_ADDR_OWVAR 42
107997: PUSH
107998: LD_INT 3
108000: ST_TO_ADDR
108001: GO 108382
108003: LD_INT 16
108005: DOUBLE
108006: EQUAL
108007: IFTRUE 108011
108009: GO 108022
108011: POP
// bc_type := b_ext_gun ; 17 :
108012: LD_ADDR_OWVAR 42
108016: PUSH
108017: LD_INT 17
108019: ST_TO_ADDR
108020: GO 108382
108022: LD_INT 17
108024: DOUBLE
108025: EQUAL
108026: IFTRUE 108030
108028: GO 108058
108030: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
108031: LD_ADDR_OWVAR 42
108035: PUSH
108036: LD_INT 19
108038: PUSH
108039: LD_INT 23
108041: PUSH
108042: LD_INT 19
108044: PUSH
108045: EMPTY
108046: LIST
108047: LIST
108048: LIST
108049: PUSH
108050: LD_VAR 0 1
108054: ARRAY
108055: ST_TO_ADDR
108056: GO 108382
108058: LD_INT 18
108060: DOUBLE
108061: EQUAL
108062: IFTRUE 108066
108064: GO 108077
108066: POP
// bc_type := b_ext_radar ; 19 :
108067: LD_ADDR_OWVAR 42
108071: PUSH
108072: LD_INT 20
108074: ST_TO_ADDR
108075: GO 108382
108077: LD_INT 19
108079: DOUBLE
108080: EQUAL
108081: IFTRUE 108085
108083: GO 108096
108085: POP
// bc_type := b_ext_radio ; 20 :
108086: LD_ADDR_OWVAR 42
108090: PUSH
108091: LD_INT 22
108093: ST_TO_ADDR
108094: GO 108382
108096: LD_INT 20
108098: DOUBLE
108099: EQUAL
108100: IFTRUE 108104
108102: GO 108115
108104: POP
// bc_type := b_ext_siberium ; 21 :
108105: LD_ADDR_OWVAR 42
108109: PUSH
108110: LD_INT 21
108112: ST_TO_ADDR
108113: GO 108382
108115: LD_INT 21
108117: DOUBLE
108118: EQUAL
108119: IFTRUE 108123
108121: GO 108134
108123: POP
// bc_type := b_ext_computer ; 22 :
108124: LD_ADDR_OWVAR 42
108128: PUSH
108129: LD_INT 24
108131: ST_TO_ADDR
108132: GO 108382
108134: LD_INT 22
108136: DOUBLE
108137: EQUAL
108138: IFTRUE 108142
108140: GO 108153
108142: POP
// bc_type := b_ext_track ; 23 :
108143: LD_ADDR_OWVAR 42
108147: PUSH
108148: LD_INT 16
108150: ST_TO_ADDR
108151: GO 108382
108153: LD_INT 23
108155: DOUBLE
108156: EQUAL
108157: IFTRUE 108161
108159: GO 108172
108161: POP
// bc_type := b_ext_laser ; 24 :
108162: LD_ADDR_OWVAR 42
108166: PUSH
108167: LD_INT 25
108169: ST_TO_ADDR
108170: GO 108382
108172: LD_INT 24
108174: DOUBLE
108175: EQUAL
108176: IFTRUE 108180
108178: GO 108191
108180: POP
// bc_type := b_control_tower ; 25 :
108181: LD_ADDR_OWVAR 42
108185: PUSH
108186: LD_INT 36
108188: ST_TO_ADDR
108189: GO 108382
108191: LD_INT 25
108193: DOUBLE
108194: EQUAL
108195: IFTRUE 108199
108197: GO 108210
108199: POP
// bc_type := b_breastwork ; 26 :
108200: LD_ADDR_OWVAR 42
108204: PUSH
108205: LD_INT 31
108207: ST_TO_ADDR
108208: GO 108382
108210: LD_INT 26
108212: DOUBLE
108213: EQUAL
108214: IFTRUE 108218
108216: GO 108229
108218: POP
// bc_type := b_bunker ; 27 :
108219: LD_ADDR_OWVAR 42
108223: PUSH
108224: LD_INT 32
108226: ST_TO_ADDR
108227: GO 108382
108229: LD_INT 27
108231: DOUBLE
108232: EQUAL
108233: IFTRUE 108237
108235: GO 108248
108237: POP
// bc_type := b_turret ; 28 :
108238: LD_ADDR_OWVAR 42
108242: PUSH
108243: LD_INT 33
108245: ST_TO_ADDR
108246: GO 108382
108248: LD_INT 28
108250: DOUBLE
108251: EQUAL
108252: IFTRUE 108256
108254: GO 108267
108256: POP
// bc_type := b_armoury ; 29 :
108257: LD_ADDR_OWVAR 42
108261: PUSH
108262: LD_INT 4
108264: ST_TO_ADDR
108265: GO 108382
108267: LD_INT 29
108269: DOUBLE
108270: EQUAL
108271: IFTRUE 108275
108273: GO 108286
108275: POP
// bc_type := b_barracks ; 30 :
108276: LD_ADDR_OWVAR 42
108280: PUSH
108281: LD_INT 5
108283: ST_TO_ADDR
108284: GO 108382
108286: LD_INT 30
108288: DOUBLE
108289: EQUAL
108290: IFTRUE 108294
108292: GO 108305
108294: POP
// bc_type := b_solar_power ; 31 :
108295: LD_ADDR_OWVAR 42
108299: PUSH
108300: LD_INT 27
108302: ST_TO_ADDR
108303: GO 108382
108305: LD_INT 31
108307: DOUBLE
108308: EQUAL
108309: IFTRUE 108313
108311: GO 108324
108313: POP
// bc_type := b_oil_power ; 32 :
108314: LD_ADDR_OWVAR 42
108318: PUSH
108319: LD_INT 26
108321: ST_TO_ADDR
108322: GO 108382
108324: LD_INT 32
108326: DOUBLE
108327: EQUAL
108328: IFTRUE 108332
108330: GO 108343
108332: POP
// bc_type := b_siberite_power ; 33 :
108333: LD_ADDR_OWVAR 42
108337: PUSH
108338: LD_INT 28
108340: ST_TO_ADDR
108341: GO 108382
108343: LD_INT 33
108345: DOUBLE
108346: EQUAL
108347: IFTRUE 108351
108349: GO 108362
108351: POP
// bc_type := b_oil_mine ; 34 :
108352: LD_ADDR_OWVAR 42
108356: PUSH
108357: LD_INT 29
108359: ST_TO_ADDR
108360: GO 108382
108362: LD_INT 34
108364: DOUBLE
108365: EQUAL
108366: IFTRUE 108370
108368: GO 108381
108370: POP
// bc_type := b_siberite_mine ; end ;
108371: LD_ADDR_OWVAR 42
108375: PUSH
108376: LD_INT 30
108378: ST_TO_ADDR
108379: GO 108382
108381: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108382: LD_ADDR_VAR 0 8
108386: PUSH
108387: LD_VAR 0 5
108391: PPUSH
108392: LD_VAR 0 6
108396: PPUSH
108397: LD_VAR 0 3
108401: PPUSH
108402: CALL_OW 47
108406: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108407: LD_OWVAR 42
108411: PUSH
108412: LD_INT 32
108414: PUSH
108415: LD_INT 33
108417: PUSH
108418: EMPTY
108419: LIST
108420: LIST
108421: IN
108422: IFFALSE 108438
// PlaceWeaponTurret ( b , weapon ) ;
108424: LD_VAR 0 8
108428: PPUSH
108429: LD_VAR 0 4
108433: PPUSH
108434: CALL_OW 431
// end ;
108438: LD_VAR 0 7
108442: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108443: LD_INT 0
108445: PPUSH
108446: PPUSH
108447: PPUSH
108448: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108449: LD_ADDR_VAR 0 4
108453: PUSH
108454: LD_INT 22
108456: PUSH
108457: LD_OWVAR 2
108461: PUSH
108462: EMPTY
108463: LIST
108464: LIST
108465: PUSH
108466: LD_INT 2
108468: PUSH
108469: LD_INT 30
108471: PUSH
108472: LD_INT 0
108474: PUSH
108475: EMPTY
108476: LIST
108477: LIST
108478: PUSH
108479: LD_INT 30
108481: PUSH
108482: LD_INT 1
108484: PUSH
108485: EMPTY
108486: LIST
108487: LIST
108488: PUSH
108489: EMPTY
108490: LIST
108491: LIST
108492: LIST
108493: PUSH
108494: EMPTY
108495: LIST
108496: LIST
108497: PPUSH
108498: CALL_OW 69
108502: ST_TO_ADDR
// if not tmp then
108503: LD_VAR 0 4
108507: NOT
108508: IFFALSE 108512
// exit ;
108510: GO 108571
// for i in tmp do
108512: LD_ADDR_VAR 0 2
108516: PUSH
108517: LD_VAR 0 4
108521: PUSH
108522: FOR_IN
108523: IFFALSE 108569
// for j = 1 to 3 do
108525: LD_ADDR_VAR 0 3
108529: PUSH
108530: DOUBLE
108531: LD_INT 1
108533: DEC
108534: ST_TO_ADDR
108535: LD_INT 3
108537: PUSH
108538: FOR_TO
108539: IFFALSE 108565
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108541: LD_VAR 0 2
108545: PPUSH
108546: CALL_OW 274
108550: PPUSH
108551: LD_VAR 0 3
108555: PPUSH
108556: LD_INT 99999
108558: PPUSH
108559: CALL_OW 277
108563: GO 108538
108565: POP
108566: POP
108567: GO 108522
108569: POP
108570: POP
// end ;
108571: LD_VAR 0 1
108575: RET
// export function hHackSetLevel10 ; var i , j ; begin
108576: LD_INT 0
108578: PPUSH
108579: PPUSH
108580: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108581: LD_ADDR_VAR 0 2
108585: PUSH
108586: LD_INT 21
108588: PUSH
108589: LD_INT 1
108591: PUSH
108592: EMPTY
108593: LIST
108594: LIST
108595: PPUSH
108596: CALL_OW 69
108600: PUSH
108601: FOR_IN
108602: IFFALSE 108654
// if IsSelected ( i ) then
108604: LD_VAR 0 2
108608: PPUSH
108609: CALL_OW 306
108613: IFFALSE 108652
// begin for j := 1 to 4 do
108615: LD_ADDR_VAR 0 3
108619: PUSH
108620: DOUBLE
108621: LD_INT 1
108623: DEC
108624: ST_TO_ADDR
108625: LD_INT 4
108627: PUSH
108628: FOR_TO
108629: IFFALSE 108650
// SetSkill ( i , j , 10 ) ;
108631: LD_VAR 0 2
108635: PPUSH
108636: LD_VAR 0 3
108640: PPUSH
108641: LD_INT 10
108643: PPUSH
108644: CALL_OW 237
108648: GO 108628
108650: POP
108651: POP
// end ;
108652: GO 108601
108654: POP
108655: POP
// end ;
108656: LD_VAR 0 1
108660: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108661: LD_INT 0
108663: PPUSH
108664: PPUSH
108665: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108666: LD_ADDR_VAR 0 2
108670: PUSH
108671: LD_INT 22
108673: PUSH
108674: LD_OWVAR 2
108678: PUSH
108679: EMPTY
108680: LIST
108681: LIST
108682: PUSH
108683: LD_INT 21
108685: PUSH
108686: LD_INT 1
108688: PUSH
108689: EMPTY
108690: LIST
108691: LIST
108692: PUSH
108693: EMPTY
108694: LIST
108695: LIST
108696: PPUSH
108697: CALL_OW 69
108701: PUSH
108702: FOR_IN
108703: IFFALSE 108744
// begin for j := 1 to 4 do
108705: LD_ADDR_VAR 0 3
108709: PUSH
108710: DOUBLE
108711: LD_INT 1
108713: DEC
108714: ST_TO_ADDR
108715: LD_INT 4
108717: PUSH
108718: FOR_TO
108719: IFFALSE 108740
// SetSkill ( i , j , 10 ) ;
108721: LD_VAR 0 2
108725: PPUSH
108726: LD_VAR 0 3
108730: PPUSH
108731: LD_INT 10
108733: PPUSH
108734: CALL_OW 237
108738: GO 108718
108740: POP
108741: POP
// end ;
108742: GO 108702
108744: POP
108745: POP
// end ;
108746: LD_VAR 0 1
108750: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108751: LD_INT 0
108753: PPUSH
// uc_side := your_side ;
108754: LD_ADDR_OWVAR 20
108758: PUSH
108759: LD_OWVAR 2
108763: ST_TO_ADDR
// uc_nation := nation ;
108764: LD_ADDR_OWVAR 21
108768: PUSH
108769: LD_VAR 0 1
108773: ST_TO_ADDR
// InitHc ;
108774: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108778: LD_INT 0
108780: PPUSH
108781: LD_VAR 0 2
108785: PPUSH
108786: LD_VAR 0 3
108790: PPUSH
108791: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108795: LD_VAR 0 4
108799: PPUSH
108800: LD_VAR 0 5
108804: PPUSH
108805: CALL_OW 428
108809: PUSH
108810: LD_INT 0
108812: EQUAL
108813: IFFALSE 108837
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108815: CALL_OW 44
108819: PPUSH
108820: LD_VAR 0 4
108824: PPUSH
108825: LD_VAR 0 5
108829: PPUSH
108830: LD_INT 1
108832: PPUSH
108833: CALL_OW 48
// end ;
108837: LD_VAR 0 6
108841: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108842: LD_INT 0
108844: PPUSH
108845: PPUSH
// uc_side := your_side ;
108846: LD_ADDR_OWVAR 20
108850: PUSH
108851: LD_OWVAR 2
108855: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108856: LD_VAR 0 1
108860: PUSH
108861: LD_INT 1
108863: PUSH
108864: LD_INT 2
108866: PUSH
108867: LD_INT 3
108869: PUSH
108870: LD_INT 4
108872: PUSH
108873: LD_INT 5
108875: PUSH
108876: EMPTY
108877: LIST
108878: LIST
108879: LIST
108880: LIST
108881: LIST
108882: IN
108883: IFFALSE 108895
// uc_nation := nation_american else
108885: LD_ADDR_OWVAR 21
108889: PUSH
108890: LD_INT 1
108892: ST_TO_ADDR
108893: GO 108938
// if chassis in [ 11 , 12 , 13 , 14 ] then
108895: LD_VAR 0 1
108899: PUSH
108900: LD_INT 11
108902: PUSH
108903: LD_INT 12
108905: PUSH
108906: LD_INT 13
108908: PUSH
108909: LD_INT 14
108911: PUSH
108912: EMPTY
108913: LIST
108914: LIST
108915: LIST
108916: LIST
108917: IN
108918: IFFALSE 108930
// uc_nation := nation_arabian else
108920: LD_ADDR_OWVAR 21
108924: PUSH
108925: LD_INT 2
108927: ST_TO_ADDR
108928: GO 108938
// uc_nation := nation_russian ;
108930: LD_ADDR_OWVAR 21
108934: PUSH
108935: LD_INT 3
108937: ST_TO_ADDR
// vc_chassis := chassis ;
108938: LD_ADDR_OWVAR 37
108942: PUSH
108943: LD_VAR 0 1
108947: ST_TO_ADDR
// vc_engine := engine ;
108948: LD_ADDR_OWVAR 39
108952: PUSH
108953: LD_VAR 0 2
108957: ST_TO_ADDR
// vc_control := control ;
108958: LD_ADDR_OWVAR 38
108962: PUSH
108963: LD_VAR 0 3
108967: ST_TO_ADDR
// vc_weapon := weapon ;
108968: LD_ADDR_OWVAR 40
108972: PUSH
108973: LD_VAR 0 4
108977: ST_TO_ADDR
// un := CreateVehicle ;
108978: LD_ADDR_VAR 0 8
108982: PUSH
108983: CALL_OW 45
108987: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108988: LD_VAR 0 8
108992: PPUSH
108993: LD_INT 0
108995: PPUSH
108996: LD_INT 5
108998: PPUSH
108999: CALL_OW 12
109003: PPUSH
109004: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
109008: LD_VAR 0 8
109012: PPUSH
109013: LD_VAR 0 5
109017: PPUSH
109018: LD_VAR 0 6
109022: PPUSH
109023: LD_INT 1
109025: PPUSH
109026: CALL_OW 48
// end ;
109030: LD_VAR 0 7
109034: RET
// export hInvincible ; every 1 do
109035: GO 109037
109037: DISABLE
// hInvincible := [ ] ;
109038: LD_ADDR_EXP 136
109042: PUSH
109043: EMPTY
109044: ST_TO_ADDR
109045: END
// every 10 do var i ;
109046: GO 109048
109048: DISABLE
109049: LD_INT 0
109051: PPUSH
// begin enable ;
109052: ENABLE
// if not hInvincible then
109053: LD_EXP 136
109057: NOT
109058: IFFALSE 109062
// exit ;
109060: GO 109106
// for i in hInvincible do
109062: LD_ADDR_VAR 0 1
109066: PUSH
109067: LD_EXP 136
109071: PUSH
109072: FOR_IN
109073: IFFALSE 109104
// if GetLives ( i ) < 1000 then
109075: LD_VAR 0 1
109079: PPUSH
109080: CALL_OW 256
109084: PUSH
109085: LD_INT 1000
109087: LESS
109088: IFFALSE 109102
// SetLives ( i , 1000 ) ;
109090: LD_VAR 0 1
109094: PPUSH
109095: LD_INT 1000
109097: PPUSH
109098: CALL_OW 234
109102: GO 109072
109104: POP
109105: POP
// end ;
109106: PPOPN 1
109108: END
// export function hHackInvincible ; var i ; begin
109109: LD_INT 0
109111: PPUSH
109112: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
109113: LD_ADDR_VAR 0 2
109117: PUSH
109118: LD_INT 2
109120: PUSH
109121: LD_INT 21
109123: PUSH
109124: LD_INT 1
109126: PUSH
109127: EMPTY
109128: LIST
109129: LIST
109130: PUSH
109131: LD_INT 21
109133: PUSH
109134: LD_INT 2
109136: PUSH
109137: EMPTY
109138: LIST
109139: LIST
109140: PUSH
109141: EMPTY
109142: LIST
109143: LIST
109144: LIST
109145: PPUSH
109146: CALL_OW 69
109150: PUSH
109151: FOR_IN
109152: IFFALSE 109213
// if IsSelected ( i ) then
109154: LD_VAR 0 2
109158: PPUSH
109159: CALL_OW 306
109163: IFFALSE 109211
// begin if i in hInvincible then
109165: LD_VAR 0 2
109169: PUSH
109170: LD_EXP 136
109174: IN
109175: IFFALSE 109195
// hInvincible := hInvincible diff i else
109177: LD_ADDR_EXP 136
109181: PUSH
109182: LD_EXP 136
109186: PUSH
109187: LD_VAR 0 2
109191: DIFF
109192: ST_TO_ADDR
109193: GO 109211
// hInvincible := hInvincible union i ;
109195: LD_ADDR_EXP 136
109199: PUSH
109200: LD_EXP 136
109204: PUSH
109205: LD_VAR 0 2
109209: UNION
109210: ST_TO_ADDR
// end ;
109211: GO 109151
109213: POP
109214: POP
// end ;
109215: LD_VAR 0 1
109219: RET
// export function hHackInvisible ; var i , j ; begin
109220: LD_INT 0
109222: PPUSH
109223: PPUSH
109224: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109225: LD_ADDR_VAR 0 2
109229: PUSH
109230: LD_INT 21
109232: PUSH
109233: LD_INT 1
109235: PUSH
109236: EMPTY
109237: LIST
109238: LIST
109239: PPUSH
109240: CALL_OW 69
109244: PUSH
109245: FOR_IN
109246: IFFALSE 109270
// if IsSelected ( i ) then
109248: LD_VAR 0 2
109252: PPUSH
109253: CALL_OW 306
109257: IFFALSE 109268
// ComForceInvisible ( i ) ;
109259: LD_VAR 0 2
109263: PPUSH
109264: CALL_OW 496
109268: GO 109245
109270: POP
109271: POP
// end ;
109272: LD_VAR 0 1
109276: RET
// export function hHackChangeYourSide ; begin
109277: LD_INT 0
109279: PPUSH
// if your_side = 8 then
109280: LD_OWVAR 2
109284: PUSH
109285: LD_INT 8
109287: EQUAL
109288: IFFALSE 109300
// your_side := 0 else
109290: LD_ADDR_OWVAR 2
109294: PUSH
109295: LD_INT 0
109297: ST_TO_ADDR
109298: GO 109314
// your_side := your_side + 1 ;
109300: LD_ADDR_OWVAR 2
109304: PUSH
109305: LD_OWVAR 2
109309: PUSH
109310: LD_INT 1
109312: PLUS
109313: ST_TO_ADDR
// end ;
109314: LD_VAR 0 1
109318: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109319: LD_INT 0
109321: PPUSH
109322: PPUSH
109323: PPUSH
// for i in all_units do
109324: LD_ADDR_VAR 0 2
109328: PUSH
109329: LD_OWVAR 3
109333: PUSH
109334: FOR_IN
109335: IFFALSE 109413
// if IsSelected ( i ) then
109337: LD_VAR 0 2
109341: PPUSH
109342: CALL_OW 306
109346: IFFALSE 109411
// begin j := GetSide ( i ) ;
109348: LD_ADDR_VAR 0 3
109352: PUSH
109353: LD_VAR 0 2
109357: PPUSH
109358: CALL_OW 255
109362: ST_TO_ADDR
// if j = 8 then
109363: LD_VAR 0 3
109367: PUSH
109368: LD_INT 8
109370: EQUAL
109371: IFFALSE 109383
// j := 0 else
109373: LD_ADDR_VAR 0 3
109377: PUSH
109378: LD_INT 0
109380: ST_TO_ADDR
109381: GO 109397
// j := j + 1 ;
109383: LD_ADDR_VAR 0 3
109387: PUSH
109388: LD_VAR 0 3
109392: PUSH
109393: LD_INT 1
109395: PLUS
109396: ST_TO_ADDR
// SetSide ( i , j ) ;
109397: LD_VAR 0 2
109401: PPUSH
109402: LD_VAR 0 3
109406: PPUSH
109407: CALL_OW 235
// end ;
109411: GO 109334
109413: POP
109414: POP
// end ;
109415: LD_VAR 0 1
109419: RET
// export function hHackFog ; begin
109420: LD_INT 0
109422: PPUSH
// FogOff ( true ) ;
109423: LD_INT 1
109425: PPUSH
109426: CALL_OW 344
// end ;
109430: LD_VAR 0 1
109434: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109435: LD_INT 0
109437: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109438: LD_VAR 0 1
109442: PPUSH
109443: LD_VAR 0 2
109447: PPUSH
109448: LD_VAR 0 3
109452: PPUSH
109453: LD_INT 1
109455: PPUSH
109456: LD_INT 1
109458: PPUSH
109459: CALL_OW 483
// CenterOnXY ( x , y ) ;
109463: LD_VAR 0 2
109467: PPUSH
109468: LD_VAR 0 3
109472: PPUSH
109473: CALL_OW 84
// end ;
109477: LD_VAR 0 4
109481: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109482: LD_INT 0
109484: PPUSH
109485: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109486: LD_VAR 0 1
109490: NOT
109491: PUSH
109492: LD_VAR 0 2
109496: PPUSH
109497: LD_VAR 0 3
109501: PPUSH
109502: CALL_OW 488
109506: NOT
109507: OR
109508: PUSH
109509: LD_VAR 0 1
109513: PPUSH
109514: CALL_OW 266
109518: PUSH
109519: LD_INT 3
109521: NONEQUAL
109522: PUSH
109523: LD_VAR 0 1
109527: PPUSH
109528: CALL_OW 247
109532: PUSH
109533: LD_INT 1
109535: EQUAL
109536: NOT
109537: AND
109538: OR
109539: IFFALSE 109543
// exit ;
109541: GO 109692
// if GetType ( factory ) = unit_human then
109543: LD_VAR 0 1
109547: PPUSH
109548: CALL_OW 247
109552: PUSH
109553: LD_INT 1
109555: EQUAL
109556: IFFALSE 109573
// factory := IsInUnit ( factory ) ;
109558: LD_ADDR_VAR 0 1
109562: PUSH
109563: LD_VAR 0 1
109567: PPUSH
109568: CALL_OW 310
109572: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109573: LD_VAR 0 1
109577: PPUSH
109578: CALL_OW 266
109582: PUSH
109583: LD_INT 3
109585: NONEQUAL
109586: IFFALSE 109590
// exit ;
109588: GO 109692
// if HexInfo ( x , y ) = factory then
109590: LD_VAR 0 2
109594: PPUSH
109595: LD_VAR 0 3
109599: PPUSH
109600: CALL_OW 428
109604: PUSH
109605: LD_VAR 0 1
109609: EQUAL
109610: IFFALSE 109637
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109612: LD_ADDR_EXP 137
109616: PUSH
109617: LD_EXP 137
109621: PPUSH
109622: LD_VAR 0 1
109626: PPUSH
109627: LD_INT 0
109629: PPUSH
109630: CALL_OW 1
109634: ST_TO_ADDR
109635: GO 109688
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109637: LD_ADDR_EXP 137
109641: PUSH
109642: LD_EXP 137
109646: PPUSH
109647: LD_VAR 0 1
109651: PPUSH
109652: LD_VAR 0 1
109656: PPUSH
109657: CALL_OW 255
109661: PUSH
109662: LD_VAR 0 1
109666: PUSH
109667: LD_VAR 0 2
109671: PUSH
109672: LD_VAR 0 3
109676: PUSH
109677: EMPTY
109678: LIST
109679: LIST
109680: LIST
109681: LIST
109682: PPUSH
109683: CALL_OW 1
109687: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109688: CALL 109697 0 0
// end ;
109692: LD_VAR 0 4
109696: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109697: LD_INT 0
109699: PPUSH
109700: PPUSH
109701: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109702: LD_STRING resetFactoryWaypoint();
109704: PPUSH
109705: CALL_OW 559
// if factoryWaypoints then
109709: LD_EXP 137
109713: IFFALSE 109839
// begin list := PrepareArray ( factoryWaypoints ) ;
109715: LD_ADDR_VAR 0 3
109719: PUSH
109720: LD_EXP 137
109724: PPUSH
109725: CALL 52341 0 1
109729: ST_TO_ADDR
// for i := 1 to list do
109730: LD_ADDR_VAR 0 2
109734: PUSH
109735: DOUBLE
109736: LD_INT 1
109738: DEC
109739: ST_TO_ADDR
109740: LD_VAR 0 3
109744: PUSH
109745: FOR_TO
109746: IFFALSE 109837
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109748: LD_STRING setFactoryWaypointXY(
109750: PUSH
109751: LD_VAR 0 3
109755: PUSH
109756: LD_VAR 0 2
109760: ARRAY
109761: PUSH
109762: LD_INT 1
109764: ARRAY
109765: STR
109766: PUSH
109767: LD_STRING ,
109769: STR
109770: PUSH
109771: LD_VAR 0 3
109775: PUSH
109776: LD_VAR 0 2
109780: ARRAY
109781: PUSH
109782: LD_INT 2
109784: ARRAY
109785: STR
109786: PUSH
109787: LD_STRING ,
109789: STR
109790: PUSH
109791: LD_VAR 0 3
109795: PUSH
109796: LD_VAR 0 2
109800: ARRAY
109801: PUSH
109802: LD_INT 3
109804: ARRAY
109805: STR
109806: PUSH
109807: LD_STRING ,
109809: STR
109810: PUSH
109811: LD_VAR 0 3
109815: PUSH
109816: LD_VAR 0 2
109820: ARRAY
109821: PUSH
109822: LD_INT 4
109824: ARRAY
109825: STR
109826: PUSH
109827: LD_STRING )
109829: STR
109830: PPUSH
109831: CALL_OW 559
109835: GO 109745
109837: POP
109838: POP
// end ; end ;
109839: LD_VAR 0 1
109843: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109844: LD_INT 0
109846: PPUSH
// if HexInfo ( x , y ) = warehouse then
109847: LD_VAR 0 2
109851: PPUSH
109852: LD_VAR 0 3
109856: PPUSH
109857: CALL_OW 428
109861: PUSH
109862: LD_VAR 0 1
109866: EQUAL
109867: IFFALSE 109894
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109869: LD_ADDR_EXP 138
109873: PUSH
109874: LD_EXP 138
109878: PPUSH
109879: LD_VAR 0 1
109883: PPUSH
109884: LD_INT 0
109886: PPUSH
109887: CALL_OW 1
109891: ST_TO_ADDR
109892: GO 109945
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109894: LD_ADDR_EXP 138
109898: PUSH
109899: LD_EXP 138
109903: PPUSH
109904: LD_VAR 0 1
109908: PPUSH
109909: LD_VAR 0 1
109913: PPUSH
109914: CALL_OW 255
109918: PUSH
109919: LD_VAR 0 1
109923: PUSH
109924: LD_VAR 0 2
109928: PUSH
109929: LD_VAR 0 3
109933: PUSH
109934: EMPTY
109935: LIST
109936: LIST
109937: LIST
109938: LIST
109939: PPUSH
109940: CALL_OW 1
109944: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109945: CALL 109954 0 0
// end ;
109949: LD_VAR 0 4
109953: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109954: LD_INT 0
109956: PPUSH
109957: PPUSH
109958: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109959: LD_STRING resetWarehouseGatheringPoints();
109961: PPUSH
109962: CALL_OW 559
// if warehouseGatheringPoints then
109966: LD_EXP 138
109970: IFFALSE 110096
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109972: LD_ADDR_VAR 0 3
109976: PUSH
109977: LD_EXP 138
109981: PPUSH
109982: CALL 52341 0 1
109986: ST_TO_ADDR
// for i := 1 to list do
109987: LD_ADDR_VAR 0 2
109991: PUSH
109992: DOUBLE
109993: LD_INT 1
109995: DEC
109996: ST_TO_ADDR
109997: LD_VAR 0 3
110001: PUSH
110002: FOR_TO
110003: IFFALSE 110094
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
110005: LD_STRING setWarehouseGatheringPointXY(
110007: PUSH
110008: LD_VAR 0 3
110012: PUSH
110013: LD_VAR 0 2
110017: ARRAY
110018: PUSH
110019: LD_INT 1
110021: ARRAY
110022: STR
110023: PUSH
110024: LD_STRING ,
110026: STR
110027: PUSH
110028: LD_VAR 0 3
110032: PUSH
110033: LD_VAR 0 2
110037: ARRAY
110038: PUSH
110039: LD_INT 2
110041: ARRAY
110042: STR
110043: PUSH
110044: LD_STRING ,
110046: STR
110047: PUSH
110048: LD_VAR 0 3
110052: PUSH
110053: LD_VAR 0 2
110057: ARRAY
110058: PUSH
110059: LD_INT 3
110061: ARRAY
110062: STR
110063: PUSH
110064: LD_STRING ,
110066: STR
110067: PUSH
110068: LD_VAR 0 3
110072: PUSH
110073: LD_VAR 0 2
110077: ARRAY
110078: PUSH
110079: LD_INT 4
110081: ARRAY
110082: STR
110083: PUSH
110084: LD_STRING )
110086: STR
110087: PPUSH
110088: CALL_OW 559
110092: GO 110002
110094: POP
110095: POP
// end ; end ;
110096: LD_VAR 0 1
110100: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
110101: LD_EXP 138
110105: IFFALSE 110790
110107: GO 110109
110109: DISABLE
110110: LD_INT 0
110112: PPUSH
110113: PPUSH
110114: PPUSH
110115: PPUSH
110116: PPUSH
110117: PPUSH
110118: PPUSH
110119: PPUSH
110120: PPUSH
// begin enable ;
110121: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
110122: LD_ADDR_VAR 0 3
110126: PUSH
110127: LD_EXP 138
110131: PPUSH
110132: CALL 52341 0 1
110136: ST_TO_ADDR
// if not list then
110137: LD_VAR 0 3
110141: NOT
110142: IFFALSE 110146
// exit ;
110144: GO 110790
// for i := 1 to list do
110146: LD_ADDR_VAR 0 1
110150: PUSH
110151: DOUBLE
110152: LD_INT 1
110154: DEC
110155: ST_TO_ADDR
110156: LD_VAR 0 3
110160: PUSH
110161: FOR_TO
110162: IFFALSE 110788
// begin depot := list [ i ] [ 2 ] ;
110164: LD_ADDR_VAR 0 8
110168: PUSH
110169: LD_VAR 0 3
110173: PUSH
110174: LD_VAR 0 1
110178: ARRAY
110179: PUSH
110180: LD_INT 2
110182: ARRAY
110183: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110184: LD_ADDR_VAR 0 5
110188: PUSH
110189: LD_VAR 0 3
110193: PUSH
110194: LD_VAR 0 1
110198: ARRAY
110199: PUSH
110200: LD_INT 1
110202: ARRAY
110203: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110204: LD_VAR 0 8
110208: PPUSH
110209: CALL_OW 301
110213: PUSH
110214: LD_VAR 0 5
110218: PUSH
110219: LD_VAR 0 8
110223: PPUSH
110224: CALL_OW 255
110228: NONEQUAL
110229: OR
110230: IFFALSE 110259
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110232: LD_ADDR_EXP 138
110236: PUSH
110237: LD_EXP 138
110241: PPUSH
110242: LD_VAR 0 8
110246: PPUSH
110247: LD_INT 0
110249: PPUSH
110250: CALL_OW 1
110254: ST_TO_ADDR
// exit ;
110255: POP
110256: POP
110257: GO 110790
// end ; x := list [ i ] [ 3 ] ;
110259: LD_ADDR_VAR 0 6
110263: PUSH
110264: LD_VAR 0 3
110268: PUSH
110269: LD_VAR 0 1
110273: ARRAY
110274: PUSH
110275: LD_INT 3
110277: ARRAY
110278: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110279: LD_ADDR_VAR 0 7
110283: PUSH
110284: LD_VAR 0 3
110288: PUSH
110289: LD_VAR 0 1
110293: ARRAY
110294: PUSH
110295: LD_INT 4
110297: ARRAY
110298: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110299: LD_ADDR_VAR 0 9
110303: PUSH
110304: LD_VAR 0 6
110308: PPUSH
110309: LD_VAR 0 7
110313: PPUSH
110314: LD_INT 16
110316: PPUSH
110317: CALL 50929 0 3
110321: ST_TO_ADDR
// if not cratesNearbyPoint then
110322: LD_VAR 0 9
110326: NOT
110327: IFFALSE 110333
// exit ;
110329: POP
110330: POP
110331: GO 110790
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110333: LD_ADDR_VAR 0 4
110337: PUSH
110338: LD_INT 22
110340: PUSH
110341: LD_VAR 0 5
110345: PUSH
110346: EMPTY
110347: LIST
110348: LIST
110349: PUSH
110350: LD_INT 3
110352: PUSH
110353: LD_INT 60
110355: PUSH
110356: EMPTY
110357: LIST
110358: PUSH
110359: EMPTY
110360: LIST
110361: LIST
110362: PUSH
110363: LD_INT 91
110365: PUSH
110366: LD_VAR 0 8
110370: PUSH
110371: LD_INT 6
110373: PUSH
110374: EMPTY
110375: LIST
110376: LIST
110377: LIST
110378: PUSH
110379: LD_INT 2
110381: PUSH
110382: LD_INT 25
110384: PUSH
110385: LD_INT 2
110387: PUSH
110388: EMPTY
110389: LIST
110390: LIST
110391: PUSH
110392: LD_INT 25
110394: PUSH
110395: LD_INT 16
110397: PUSH
110398: EMPTY
110399: LIST
110400: LIST
110401: PUSH
110402: EMPTY
110403: LIST
110404: LIST
110405: LIST
110406: PUSH
110407: EMPTY
110408: LIST
110409: LIST
110410: LIST
110411: LIST
110412: PPUSH
110413: CALL_OW 69
110417: PUSH
110418: LD_VAR 0 8
110422: PPUSH
110423: CALL_OW 313
110427: PPUSH
110428: LD_INT 3
110430: PUSH
110431: LD_INT 60
110433: PUSH
110434: EMPTY
110435: LIST
110436: PUSH
110437: EMPTY
110438: LIST
110439: LIST
110440: PUSH
110441: LD_INT 2
110443: PUSH
110444: LD_INT 25
110446: PUSH
110447: LD_INT 2
110449: PUSH
110450: EMPTY
110451: LIST
110452: LIST
110453: PUSH
110454: LD_INT 25
110456: PUSH
110457: LD_INT 16
110459: PUSH
110460: EMPTY
110461: LIST
110462: LIST
110463: PUSH
110464: EMPTY
110465: LIST
110466: LIST
110467: LIST
110468: PUSH
110469: EMPTY
110470: LIST
110471: LIST
110472: PPUSH
110473: CALL_OW 72
110477: UNION
110478: ST_TO_ADDR
// if tmp then
110479: LD_VAR 0 4
110483: IFFALSE 110563
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110485: LD_ADDR_VAR 0 4
110489: PUSH
110490: LD_VAR 0 4
110494: PPUSH
110495: LD_INT 3
110497: PPUSH
110498: CALL 48898 0 2
110502: ST_TO_ADDR
// for j in tmp do
110503: LD_ADDR_VAR 0 2
110507: PUSH
110508: LD_VAR 0 4
110512: PUSH
110513: FOR_IN
110514: IFFALSE 110557
// begin if IsInUnit ( j ) then
110516: LD_VAR 0 2
110520: PPUSH
110521: CALL_OW 310
110525: IFFALSE 110536
// ComExit ( j ) ;
110527: LD_VAR 0 2
110531: PPUSH
110532: CALL 48981 0 1
// AddComCollect ( j , x , y ) ;
110536: LD_VAR 0 2
110540: PPUSH
110541: LD_VAR 0 6
110545: PPUSH
110546: LD_VAR 0 7
110550: PPUSH
110551: CALL_OW 177
// end ;
110555: GO 110513
110557: POP
110558: POP
// exit ;
110559: POP
110560: POP
110561: GO 110790
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110563: LD_ADDR_VAR 0 4
110567: PUSH
110568: LD_INT 22
110570: PUSH
110571: LD_VAR 0 5
110575: PUSH
110576: EMPTY
110577: LIST
110578: LIST
110579: PUSH
110580: LD_INT 91
110582: PUSH
110583: LD_VAR 0 8
110587: PUSH
110588: LD_INT 8
110590: PUSH
110591: EMPTY
110592: LIST
110593: LIST
110594: LIST
110595: PUSH
110596: LD_INT 2
110598: PUSH
110599: LD_INT 34
110601: PUSH
110602: LD_INT 12
110604: PUSH
110605: EMPTY
110606: LIST
110607: LIST
110608: PUSH
110609: LD_INT 34
110611: PUSH
110612: LD_INT 51
110614: PUSH
110615: EMPTY
110616: LIST
110617: LIST
110618: PUSH
110619: LD_INT 34
110621: PUSH
110622: LD_INT 32
110624: PUSH
110625: EMPTY
110626: LIST
110627: LIST
110628: PUSH
110629: LD_INT 34
110631: PUSH
110632: LD_INT 89
110634: PUSH
110635: EMPTY
110636: LIST
110637: LIST
110638: PUSH
110639: EMPTY
110640: LIST
110641: LIST
110642: LIST
110643: LIST
110644: LIST
110645: PUSH
110646: EMPTY
110647: LIST
110648: LIST
110649: LIST
110650: PPUSH
110651: CALL_OW 69
110655: ST_TO_ADDR
// if tmp then
110656: LD_VAR 0 4
110660: IFFALSE 110786
// begin for j in tmp do
110662: LD_ADDR_VAR 0 2
110666: PUSH
110667: LD_VAR 0 4
110671: PUSH
110672: FOR_IN
110673: IFFALSE 110784
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110675: LD_VAR 0 2
110679: PPUSH
110680: CALL_OW 262
110684: PUSH
110685: LD_INT 3
110687: EQUAL
110688: PUSH
110689: LD_VAR 0 2
110693: PPUSH
110694: CALL_OW 261
110698: PUSH
110699: LD_INT 20
110701: GREATER
110702: OR
110703: PUSH
110704: LD_VAR 0 2
110708: PPUSH
110709: CALL_OW 314
110713: NOT
110714: AND
110715: PUSH
110716: LD_VAR 0 2
110720: PPUSH
110721: CALL_OW 263
110725: PUSH
110726: LD_INT 1
110728: NONEQUAL
110729: PUSH
110730: LD_VAR 0 2
110734: PPUSH
110735: CALL_OW 311
110739: OR
110740: AND
110741: IFFALSE 110782
// begin ComCollect ( j , x , y ) ;
110743: LD_VAR 0 2
110747: PPUSH
110748: LD_VAR 0 6
110752: PPUSH
110753: LD_VAR 0 7
110757: PPUSH
110758: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110762: LD_VAR 0 2
110766: PPUSH
110767: LD_VAR 0 8
110771: PPUSH
110772: CALL_OW 172
// exit ;
110776: POP
110777: POP
110778: POP
110779: POP
110780: GO 110790
// end ;
110782: GO 110672
110784: POP
110785: POP
// end ; end ;
110786: GO 110161
110788: POP
110789: POP
// end ; end_of_file
110790: PPOPN 9
110792: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110793: LD_VAR 0 1
110797: PPUSH
110798: LD_VAR 0 2
110802: PPUSH
110803: LD_VAR 0 3
110807: PPUSH
110808: LD_VAR 0 4
110812: PPUSH
110813: LD_VAR 0 5
110817: PPUSH
110818: LD_VAR 0 6
110822: PPUSH
110823: CALL 95154 0 6
// end ;
110827: PPOPN 6
110829: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110830: LD_INT 0
110832: PPUSH
// begin if not units then
110833: LD_VAR 0 1
110837: NOT
110838: IFFALSE 110842
// exit ;
110840: GO 110842
// end ;
110842: PPOPN 7
110844: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110845: CALL 95058 0 0
// end ;
110849: PPOPN 1
110851: END
