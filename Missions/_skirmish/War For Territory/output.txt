// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45998 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45998 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45998 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45998 0 9
// PrepareGensher ;
 185: CALL 3190 0 0
// PreparePopov ;
 189: CALL 6437 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9165 0 0
// MC_Start ( ) ;
 201: CALL 56881 0 0
// Action ;
 205: CALL 9572 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4356 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7627 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 20004 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 80544 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 80484 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 79515 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 80364 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 80034 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 79757 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 79376 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 79191 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 80154 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2483
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 79239 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 80695 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2483
// DialogPowellsAttack ;
2194: CALL 9703 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: IFFALSE 2270
2251: PUSH
2252: LD_INT 16
2254: PPUSH
2255: LD_INT 81
2257: PUSH
2258: LD_INT 4
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PPUSH
2265: CALL_OW 70
2269: AND
2270: IFFALSE 2289
// ComAgressiveMove ( attackers , 135 , 21 ) else
2272: LD_VAR 0 4
2276: PPUSH
2277: LD_INT 135
2279: PPUSH
2280: LD_INT 21
2282: PPUSH
2283: CALL_OW 114
2287: GO 2304
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2289: LD_VAR 0 4
2293: PPUSH
2294: LD_INT 146
2296: PPUSH
2297: LD_INT 103
2299: PPUSH
2300: CALL_OW 114
// wait ( 0 0$5 ) ;
2304: LD_INT 175
2306: PPUSH
2307: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2311: LD_INT 35
2313: PPUSH
2314: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2318: LD_VAR 0 4
2322: PPUSH
2323: LD_INT 60
2325: PUSH
2326: EMPTY
2327: LIST
2328: PPUSH
2329: CALL_OW 72
2333: NOT
2334: IFFALSE 2311
// if FilterAllUnits ( [ f_side , 3 ] ) then
2336: LD_INT 22
2338: PUSH
2339: LD_INT 3
2341: PUSH
2342: EMPTY
2343: LIST
2344: LIST
2345: PPUSH
2346: CALL_OW 69
2350: IFFALSE 2369
// ComAgressiveMove ( attackers , 102 , 116 ) else
2352: LD_VAR 0 4
2356: PPUSH
2357: LD_INT 102
2359: PPUSH
2360: LD_INT 116
2362: PPUSH
2363: CALL_OW 114
2367: GO 2384
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2369: LD_VAR 0 4
2373: PPUSH
2374: LD_INT 66
2376: PPUSH
2377: LD_INT 41
2379: PPUSH
2380: CALL_OW 114
// wait ( 0 0$10 ) ;
2384: LD_INT 350
2386: PPUSH
2387: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2391: LD_INT 35
2393: PPUSH
2394: CALL_OW 67
// for i in attackers do
2398: LD_ADDR_VAR 0 1
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: FOR_IN
2409: IFFALSE 2459
// if not HasTask ( i ) then
2411: LD_VAR 0 1
2415: PPUSH
2416: CALL_OW 314
2420: NOT
2421: IFFALSE 2457
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2423: LD_VAR 0 1
2427: PPUSH
2428: LD_INT 81
2430: PUSH
2431: LD_INT 4
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PPUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 74
2452: PPUSH
2453: CALL_OW 115
2457: GO 2408
2459: POP
2460: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 50
2468: PUSH
2469: EMPTY
2470: LIST
2471: PPUSH
2472: CALL_OW 72
2476: NOT
2477: IFFALSE 2391
// DialogPowellsAttackFailed ;
2479: CALL 9972 0 0
// end ;
2483: PPOPN 5
2485: END
// every 0 0$2 do var vehicles , mechs , i ;
2486: GO 2488
2488: DISABLE
2489: LD_INT 0
2491: PPUSH
2492: PPUSH
2493: PPUSH
// begin enable ;
2494: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2495: LD_ADDR_VAR 0 1
2499: PUSH
2500: LD_INT 22
2502: PUSH
2503: LD_INT 1
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 21
2512: PUSH
2513: LD_INT 2
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: LD_INT 3
2522: PUSH
2523: LD_INT 24
2525: PUSH
2526: LD_INT 1000
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: PUSH
2537: LD_INT 92
2539: PUSH
2540: LD_INT 191
2542: PUSH
2543: LD_INT 140
2545: PUSH
2546: LD_INT 10
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: LIST
2559: LIST
2560: PPUSH
2561: CALL_OW 69
2565: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2566: LD_ADDR_VAR 0 2
2570: PUSH
2571: LD_INT 22
2573: PUSH
2574: LD_INT 4
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 25
2583: PUSH
2584: LD_INT 3
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 69
2599: ST_TO_ADDR
// if not mechs then
2600: LD_VAR 0 2
2604: NOT
2605: IFFALSE 2609
// exit ;
2607: GO 2783
// if mc_remote_driver [ 1 ] then
2609: LD_EXP 63
2613: PUSH
2614: LD_INT 1
2616: ARRAY
2617: IFFALSE 2639
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_VAR 0 2
2628: PUSH
2629: LD_EXP 63
2633: PUSH
2634: LD_INT 1
2636: ARRAY
2637: DIFF
2638: ST_TO_ADDR
// if not mechs then
2639: LD_VAR 0 2
2643: NOT
2644: IFFALSE 2648
// exit ;
2646: GO 2783
// if vehicles then
2648: LD_VAR 0 1
2652: IFFALSE 2740
// begin for i in mechs do
2654: LD_ADDR_VAR 0 3
2658: PUSH
2659: LD_VAR 0 2
2663: PUSH
2664: FOR_IN
2665: IFFALSE 2736
// begin if GetTag ( i ) <> 120 then
2667: LD_VAR 0 3
2671: PPUSH
2672: CALL_OW 110
2676: PUSH
2677: LD_INT 120
2679: NONEQUAL
2680: IFFALSE 2694
// SetTag ( i , 120 ) ;
2682: LD_VAR 0 3
2686: PPUSH
2687: LD_INT 120
2689: PPUSH
2690: CALL_OW 109
// if IsInUnit ( i ) then
2694: LD_VAR 0 3
2698: PPUSH
2699: CALL_OW 310
2703: IFFALSE 2716
// ComExitBuilding ( i ) else
2705: LD_VAR 0 3
2709: PPUSH
2710: CALL_OW 122
2714: GO 2734
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2716: LD_VAR 0 3
2720: PPUSH
2721: LD_VAR 0 1
2725: PUSH
2726: LD_INT 1
2728: ARRAY
2729: PPUSH
2730: CALL_OW 129
// end ;
2734: GO 2664
2736: POP
2737: POP
// end else
2738: GO 2783
// if FilterByTag ( mechs , 120 ) then
2740: LD_VAR 0 2
2744: PPUSH
2745: LD_INT 120
2747: PPUSH
2748: CALL 46892 0 2
2752: IFFALSE 2783
// begin for i in mechs do
2754: LD_ADDR_VAR 0 3
2758: PUSH
2759: LD_VAR 0 2
2763: PUSH
2764: FOR_IN
2765: IFFALSE 2781
// begin SetTag ( i , 0 ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 0
2774: PPUSH
2775: CALL_OW 109
// end ;
2779: GO 2764
2781: POP
2782: POP
// end ; end ;
2783: PPOPN 3
2785: END
// every 0 0$2 do var people , sci , i ;
2786: GO 2788
2788: DISABLE
2789: LD_INT 0
2791: PPUSH
2792: PPUSH
2793: PPUSH
// begin enable ;
2794: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2795: LD_ADDR_VAR 0 1
2799: PUSH
2800: LD_INT 22
2802: PUSH
2803: LD_INT 1
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: LD_INT 21
2812: PUSH
2813: LD_INT 1
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 3
2822: PUSH
2823: LD_INT 24
2825: PUSH
2826: LD_INT 1000
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 92
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 112
2845: PUSH
2846: LD_INT 10
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2866: LD_ADDR_VAR 0 2
2870: PUSH
2871: LD_INT 22
2873: PUSH
2874: LD_INT 4
2876: PUSH
2877: EMPTY
2878: LIST
2879: LIST
2880: PUSH
2881: LD_INT 25
2883: PUSH
2884: LD_INT 4
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: PPUSH
2895: CALL_OW 69
2899: ST_TO_ADDR
// if not sci then
2900: LD_VAR 0 2
2904: NOT
2905: IFFALSE 2909
// exit ;
2907: GO 3044
// if people then
2909: LD_VAR 0 1
2913: IFFALSE 3001
// begin for i in sci do
2915: LD_ADDR_VAR 0 3
2919: PUSH
2920: LD_VAR 0 2
2924: PUSH
2925: FOR_IN
2926: IFFALSE 2997
// begin if GetTag ( i ) <> 102 then
2928: LD_VAR 0 3
2932: PPUSH
2933: CALL_OW 110
2937: PUSH
2938: LD_INT 102
2940: NONEQUAL
2941: IFFALSE 2955
// SetTag ( i , 102 ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_INT 102
2950: PPUSH
2951: CALL_OW 109
// if IsInUnit ( i ) then
2955: LD_VAR 0 3
2959: PPUSH
2960: CALL_OW 310
2964: IFFALSE 2977
// ComExitBuilding ( i ) else
2966: LD_VAR 0 3
2970: PPUSH
2971: CALL_OW 122
2975: GO 2995
// ComHeal ( i , people [ 1 ] ) ;
2977: LD_VAR 0 3
2981: PPUSH
2982: LD_VAR 0 1
2986: PUSH
2987: LD_INT 1
2989: ARRAY
2990: PPUSH
2991: CALL_OW 128
// end ;
2995: GO 2925
2997: POP
2998: POP
// end else
2999: GO 3044
// if FilterByTag ( sci , 102 ) then
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 102
3008: PPUSH
3009: CALL 46892 0 2
3013: IFFALSE 3044
// begin for i in sci do
3015: LD_ADDR_VAR 0 3
3019: PUSH
3020: LD_VAR 0 2
3024: PUSH
3025: FOR_IN
3026: IFFALSE 3042
// begin SetTag ( i , 0 ) ;
3028: LD_VAR 0 3
3032: PPUSH
3033: LD_INT 0
3035: PPUSH
3036: CALL_OW 109
// end ;
3040: GO 3025
3042: POP
3043: POP
// end ; end ;
3044: PPOPN 3
3046: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3047: LD_INT 22
3049: PUSH
3050: LD_INT 4
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 33
3059: PUSH
3060: LD_INT 2
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 50
3069: PUSH
3070: EMPTY
3071: LIST
3072: PUSH
3073: LD_INT 3
3075: PUSH
3076: LD_INT 61
3078: PUSH
3079: EMPTY
3080: LIST
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PPUSH
3092: CALL_OW 69
3096: IFFALSE 3187
3098: GO 3100
3100: DISABLE
3101: LD_INT 0
3103: PPUSH
3104: PPUSH
// begin enable ;
3105: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3106: LD_ADDR_VAR 0 2
3110: PUSH
3111: LD_INT 22
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 33
3123: PUSH
3124: LD_INT 2
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: LD_INT 50
3133: PUSH
3134: EMPTY
3135: LIST
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: LD_INT 61
3142: PUSH
3143: EMPTY
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: PPUSH
3156: CALL_OW 69
3160: ST_TO_ADDR
// for i in tmp do
3161: LD_ADDR_VAR 0 1
3165: PUSH
3166: LD_VAR 0 2
3170: PUSH
3171: FOR_IN
3172: IFFALSE 3185
// Connect ( i ) ;
3174: LD_VAR 0 1
3178: PPUSH
3179: CALL 19649 0 1
3183: GO 3171
3185: POP
3186: POP
// end ; end_of_file
3187: PPOPN 2
3189: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3190: LD_INT 0
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
3196: PPUSH
3197: PPUSH
// gensher_side := 2 ;
3198: LD_ADDR_EXP 14
3202: PUSH
3203: LD_INT 2
3205: ST_TO_ADDR
// uc_side := gensher_side ;
3206: LD_ADDR_OWVAR 20
3210: PUSH
3211: LD_EXP 14
3215: ST_TO_ADDR
// uc_nation := 2 ;
3216: LD_ADDR_OWVAR 21
3220: PUSH
3221: LD_INT 2
3223: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3224: LD_ADDR_VAR 0 6
3228: PUSH
3229: LD_INT 5
3231: PUSH
3232: LD_INT 42
3234: PUSH
3235: LD_INT 29
3237: PUSH
3238: LD_INT 5
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: PUSH
3247: LD_INT 5
3249: PUSH
3250: LD_INT 36
3252: PUSH
3253: LD_INT 40
3255: PUSH
3256: LD_INT 5
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: LIST
3263: LIST
3264: PUSH
3265: LD_INT 6
3267: PUSH
3268: LD_INT 13
3270: PUSH
3271: LD_INT 18
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: LD_INT 10
3279: PUSH
3280: LD_INT 15
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: PUSH
3291: LD_INT 27
3293: PUSH
3294: LD_INT 17
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: PUSH
3309: LD_INT 29
3311: PUSH
3312: LD_INT 56
3314: PUSH
3315: LD_INT 23
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: LD_INT 11
3332: PUSH
3333: LD_INT 7
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: LIST
3343: LIST
3344: PUSH
3345: LD_INT 27
3347: PUSH
3348: LD_INT 20
3350: PUSH
3351: LD_INT 3
3353: PUSH
3354: LD_INT 0
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_INT 27
3365: PUSH
3366: LD_INT 23
3368: PUSH
3369: LD_INT 3
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: PUSH
3381: LD_INT 27
3383: PUSH
3384: LD_INT 26
3386: PUSH
3387: LD_INT 3
3389: PUSH
3390: LD_INT 0
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_INT 6
3401: PUSH
3402: LD_INT 17
3404: PUSH
3405: LD_INT 27
3407: PUSH
3408: LD_INT 1
3410: PUSH
3411: LD_INT 13
3413: PUSH
3414: LD_INT 11
3416: PUSH
3417: EMPTY
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: PUSH
3425: LD_INT 32
3427: PUSH
3428: LD_INT 27
3430: PUSH
3431: LD_INT 44
3433: PUSH
3434: LD_INT 5
3436: PUSH
3437: LD_INT 27
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: PUSH
3447: LD_INT 32
3449: PUSH
3450: LD_INT 41
3452: PUSH
3453: LD_INT 41
3455: PUSH
3456: LD_INT 5
3458: PUSH
3459: LD_INT 27
3461: PUSH
3462: EMPTY
3463: LIST
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 32
3471: PUSH
3472: LD_INT 45
3474: PUSH
3475: LD_INT 24
3477: PUSH
3478: LD_INT 5
3480: PUSH
3481: LD_INT 28
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: LIST
3490: PUSH
3491: LD_INT 32
3493: PUSH
3494: LD_INT 48
3496: PUSH
3497: LD_INT 19
3499: PUSH
3500: LD_INT 5
3502: PUSH
3503: LD_INT 28
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 41
3518: PUSH
3519: LD_INT 3
3521: PUSH
3522: LD_INT 4
3524: PUSH
3525: LD_INT 28
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: PUSH
3535: LD_INT 5
3537: PUSH
3538: LD_INT 44
3540: PUSH
3541: LD_INT 9
3543: PUSH
3544: LD_INT 4
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 30
3555: PUSH
3556: LD_INT 52
3558: PUSH
3559: LD_INT 40
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: ST_TO_ADDR
// for i in list do
3590: LD_ADDR_VAR 0 2
3594: PUSH
3595: LD_VAR 0 6
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3811
// begin uc_side := 2 ;
3603: LD_ADDR_OWVAR 20
3607: PUSH
3608: LD_INT 2
3610: ST_TO_ADDR
// uc_nation := 2 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 2
3618: ST_TO_ADDR
// InitBc ;
3619: CALL_OW 21
// bc_type := i [ 1 ] ;
3623: LD_ADDR_OWVAR 42
3627: PUSH
3628: LD_VAR 0 2
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3637: LD_VAR 0 2
3641: PUSH
3642: LD_INT 1
3644: ARRAY
3645: PUSH
3646: LD_INT 29
3648: PUSH
3649: LD_INT 30
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: IN
3656: IFFALSE 3683
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3658: LD_VAR 0 2
3662: PUSH
3663: LD_INT 2
3665: ARRAY
3666: PPUSH
3667: LD_VAR 0 2
3671: PUSH
3672: LD_INT 3
3674: ARRAY
3675: PPUSH
3676: LD_INT 2
3678: PPUSH
3679: CALL_OW 441
// if i [ 1 ] = b_lab then
3683: LD_VAR 0 2
3687: PUSH
3688: LD_INT 1
3690: ARRAY
3691: PUSH
3692: LD_INT 6
3694: EQUAL
3695: IFFALSE 3733
// begin bc_type := b_lab_full ;
3697: LD_ADDR_OWVAR 42
3701: PUSH
3702: LD_INT 8
3704: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3705: LD_ADDR_OWVAR 44
3709: PUSH
3710: LD_VAR 0 2
3714: PUSH
3715: LD_INT 5
3717: ARRAY
3718: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3719: LD_ADDR_OWVAR 45
3723: PUSH
3724: LD_VAR 0 2
3728: PUSH
3729: LD_INT 6
3731: ARRAY
3732: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3733: LD_ADDR_VAR 0 3
3737: PUSH
3738: LD_VAR 0 2
3742: PUSH
3743: LD_INT 2
3745: ARRAY
3746: PPUSH
3747: LD_VAR 0 2
3751: PUSH
3752: LD_INT 3
3754: ARRAY
3755: PPUSH
3756: LD_VAR 0 2
3760: PUSH
3761: LD_INT 4
3763: ARRAY
3764: PPUSH
3765: CALL_OW 47
3769: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3770: LD_VAR 0 2
3774: PUSH
3775: LD_INT 1
3777: ARRAY
3778: PUSH
3779: LD_INT 33
3781: PUSH
3782: LD_INT 32
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3809
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3791: LD_VAR 0 3
3795: PPUSH
3796: LD_VAR 0 2
3800: PUSH
3801: LD_INT 5
3803: ARRAY
3804: PPUSH
3805: CALL_OW 431
// end ;
3809: GO 3600
3811: POP
3812: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3813: LD_ADDR_VAR 0 4
3817: PUSH
3818: LD_INT 7
3820: PPUSH
3821: LD_INT 2
3823: PPUSH
3824: LD_STRING 
3826: PPUSH
3827: LD_INT 8
3829: PUSH
3830: LD_INT 7
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: PUSH
3841: LD_OWVAR 67
3845: ARRAY
3846: PPUSH
3847: LD_INT 11500
3849: PUSH
3850: LD_INT 1100
3852: PUSH
3853: LD_INT 60
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: PPUSH
3861: LD_INT 6
3863: PUSH
3864: LD_INT 6
3866: PUSH
3867: LD_INT 6
3869: PUSH
3870: LD_INT 6
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL 20004 0 6
3883: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3884: LD_ADDR_EXP 23
3888: PUSH
3889: LD_EXP 23
3893: PPUSH
3894: LD_INT 2
3896: PPUSH
3897: LD_VAR 0 4
3901: PUSH
3902: LD_INT 22
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: LD_INT 21
3914: PUSH
3915: LD_INT 3
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PPUSH
3926: CALL_OW 69
3930: UNION
3931: PPUSH
3932: CALL_OW 1
3936: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3937: LD_ADDR_VAR 0 4
3941: PUSH
3942: LD_INT 22
3944: PUSH
3945: LD_INT 2
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 30
3954: PUSH
3955: LD_INT 31
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PPUSH
3966: CALL_OW 69
3970: ST_TO_ADDR
// for i in tmp do
3971: LD_ADDR_VAR 0 2
3975: PUSH
3976: LD_VAR 0 4
3980: PUSH
3981: FOR_IN
3982: IFFALSE 4052
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3984: LD_INT 0
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 4
3992: PUSH
3993: LD_INT 3
3995: PUSH
3996: LD_INT 3
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_OWVAR 67
4008: ARRAY
4009: PPUSH
4010: CALL_OW 380
// un := CreateHuman ;
4014: LD_ADDR_VAR 0 5
4018: PUSH
4019: CALL_OW 44
4023: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4024: LD_VAR 0 5
4028: PPUSH
4029: LD_INT 1
4031: PPUSH
4032: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4036: LD_VAR 0 5
4040: PPUSH
4041: LD_VAR 0 2
4045: PPUSH
4046: CALL_OW 52
// end ;
4050: GO 3981
4052: POP
4053: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4054: LD_ADDR_VAR 0 4
4058: PUSH
4059: LD_INT 15
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: CALL_OW 517
4069: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4070: LD_ADDR_VAR 0 2
4074: PUSH
4075: DOUBLE
4076: LD_INT 1
4078: DEC
4079: ST_TO_ADDR
4080: LD_VAR 0 4
4084: PUSH
4085: LD_INT 1
4087: ARRAY
4088: PUSH
4089: FOR_TO
4090: IFFALSE 4192
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4092: LD_VAR 0 4
4096: PUSH
4097: LD_INT 1
4099: ARRAY
4100: PUSH
4101: LD_VAR 0 2
4105: ARRAY
4106: PPUSH
4107: LD_VAR 0 4
4111: PUSH
4112: LD_INT 2
4114: ARRAY
4115: PUSH
4116: LD_VAR 0 2
4120: ARRAY
4121: PPUSH
4122: LD_INT 2
4124: PPUSH
4125: LD_INT 0
4127: PPUSH
4128: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4132: LD_ADDR_EXP 3
4136: PUSH
4137: LD_EXP 3
4141: PPUSH
4142: LD_EXP 3
4146: PUSH
4147: LD_INT 1
4149: PLUS
4150: PPUSH
4151: LD_VAR 0 4
4155: PUSH
4156: LD_INT 1
4158: ARRAY
4159: PUSH
4160: LD_VAR 0 2
4164: ARRAY
4165: PUSH
4166: LD_VAR 0 4
4170: PUSH
4171: LD_INT 2
4173: ARRAY
4174: PUSH
4175: LD_VAR 0 2
4179: ARRAY
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 2
4189: ST_TO_ADDR
// end ;
4190: GO 4089
4192: POP
4193: POP
// if Difficulty > 1 then
4194: LD_OWVAR 67
4198: PUSH
4199: LD_INT 1
4201: GREATER
4202: IFFALSE 4344
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4204: LD_ADDR_VAR 0 4
4208: PUSH
4209: LD_INT 19
4211: PPUSH
4212: LD_INT 0
4214: PPUSH
4215: CALL_OW 517
4219: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4220: LD_ADDR_VAR 0 2
4224: PUSH
4225: DOUBLE
4226: LD_INT 1
4228: DEC
4229: ST_TO_ADDR
4230: LD_VAR 0 4
4234: PUSH
4235: LD_INT 1
4237: ARRAY
4238: PUSH
4239: FOR_TO
4240: IFFALSE 4342
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4242: LD_VAR 0 4
4246: PUSH
4247: LD_INT 1
4249: ARRAY
4250: PUSH
4251: LD_VAR 0 2
4255: ARRAY
4256: PPUSH
4257: LD_VAR 0 4
4261: PUSH
4262: LD_INT 2
4264: ARRAY
4265: PUSH
4266: LD_VAR 0 2
4270: ARRAY
4271: PPUSH
4272: LD_INT 2
4274: PPUSH
4275: LD_INT 0
4277: PPUSH
4278: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4282: LD_ADDR_EXP 3
4286: PUSH
4287: LD_EXP 3
4291: PPUSH
4292: LD_EXP 3
4296: PUSH
4297: LD_INT 1
4299: PLUS
4300: PPUSH
4301: LD_VAR 0 4
4305: PUSH
4306: LD_INT 1
4308: ARRAY
4309: PUSH
4310: LD_VAR 0 2
4314: ARRAY
4315: PUSH
4316: LD_VAR 0 4
4320: PUSH
4321: LD_INT 2
4323: ARRAY
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PPUSH
4335: CALL_OW 2
4339: ST_TO_ADDR
// end ;
4340: GO 4239
4342: POP
4343: POP
// end ; gensherAttackGroup := [ ] ;
4344: LD_ADDR_EXP 15
4348: PUSH
4349: EMPTY
4350: ST_TO_ADDR
// end ;
4351: LD_VAR 0 1
4355: RET
// export function InitMC_Gensher ( ) ; begin
4356: LD_INT 0
4358: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4359: LD_INT 2
4361: PPUSH
4362: LD_INT 2
4364: PPUSH
4365: CALL 80544 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4369: LD_INT 2
4371: PPUSH
4372: LD_INT 9
4374: PPUSH
4375: CALL 80484 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4379: LD_INT 2
4381: PPUSH
4382: LD_INT 56
4384: PUSH
4385: LD_INT 23
4387: PUSH
4388: LD_INT 0
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PUSH
4396: LD_INT 52
4398: PUSH
4399: LD_INT 40
4401: PUSH
4402: LD_INT 1
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PPUSH
4414: CALL 79515 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4418: LD_INT 2
4420: PPUSH
4421: LD_INT 27
4423: PUSH
4424: LD_INT 28
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL 80364 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4435: LD_INT 2
4437: PPUSH
4438: LD_INT 8
4440: PPUSH
4441: CALL 80034 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4445: LD_INT 2
4447: PPUSH
4448: LD_INT 7
4450: PPUSH
4451: CALL 79757 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4455: LD_INT 2
4457: PPUSH
4458: LD_INT 4
4460: PPUSH
4461: CALL 79376 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4465: LD_INT 2
4467: PPUSH
4468: LD_INT 13
4470: PUSH
4471: LD_INT 2
4473: PUSH
4474: LD_INT 1
4476: PUSH
4477: LD_INT 31
4479: PUSH
4480: EMPTY
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 13
4488: PUSH
4489: LD_INT 2
4491: PUSH
4492: LD_INT 1
4494: PUSH
4495: LD_INT 31
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: LIST
4502: LIST
4503: PUSH
4504: LD_INT 14
4506: PUSH
4507: LD_INT 1
4509: PUSH
4510: LD_INT 2
4512: PUSH
4513: LD_INT 27
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PUSH
4522: LD_INT 14
4524: PUSH
4525: LD_INT 1
4527: PUSH
4528: LD_INT 2
4530: PUSH
4531: LD_INT 27
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: PUSH
4540: LD_INT 14
4542: PUSH
4543: LD_INT 1
4545: PUSH
4546: LD_INT 2
4548: PUSH
4549: LD_INT 28
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: LIST
4556: LIST
4557: PUSH
4558: LD_INT 14
4560: PUSH
4561: LD_INT 1
4563: PUSH
4564: LD_INT 2
4566: PUSH
4567: LD_INT 26
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: PPUSH
4584: CALL 79191 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4588: LD_INT 2
4590: PPUSH
4591: LD_INT 11
4593: PPUSH
4594: LD_INT 7
4596: PPUSH
4597: LD_INT 2
4599: PPUSH
4600: LD_INT 23
4602: PUSH
4603: LD_INT 16
4605: PUSH
4606: LD_INT 17
4608: PUSH
4609: LD_INT 18
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: LIST
4619: LIST
4620: LIST
4621: PPUSH
4622: CALL 80154 0 5
// end ;
4626: LD_VAR 0 1
4630: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4631: LD_EXP 3
4635: IFFALSE 4656
4637: PUSH
4638: LD_INT 15
4640: PPUSH
4641: LD_INT 81
4643: PUSH
4644: LD_INT 2
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PPUSH
4651: CALL_OW 70
4655: AND
4656: IFFALSE 4871
4658: GO 4660
4660: DISABLE
4661: LD_INT 0
4663: PPUSH
4664: PPUSH
4665: PPUSH
4666: PPUSH
4667: PPUSH
// begin enable ;
4668: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4669: LD_ADDR_VAR 0 3
4673: PUSH
4674: LD_INT 15
4676: PPUSH
4677: LD_INT 81
4679: PUSH
4680: LD_INT 2
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 70
4691: ST_TO_ADDR
// if not tmp then
4692: LD_VAR 0 3
4696: NOT
4697: IFFALSE 4701
// exit ;
4699: GO 4871
// for i in tmp do
4701: LD_ADDR_VAR 0 1
4705: PUSH
4706: LD_VAR 0 3
4710: PUSH
4711: FOR_IN
4712: IFFALSE 4869
// begin x := GetX ( i ) ;
4714: LD_ADDR_VAR 0 4
4718: PUSH
4719: LD_VAR 0 1
4723: PPUSH
4724: CALL_OW 250
4728: ST_TO_ADDR
// y := GetY ( i ) ;
4729: LD_ADDR_VAR 0 5
4733: PUSH
4734: LD_VAR 0 1
4738: PPUSH
4739: CALL_OW 251
4743: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 458
4758: IFFALSE 4867
// begin LaunchMineAtPos ( x , y , 2 ) ;
4760: LD_VAR 0 4
4764: PPUSH
4765: LD_VAR 0 5
4769: PPUSH
4770: LD_INT 2
4772: PPUSH
4773: CALL_OW 456
// for j = 1 to staticMines do
4777: LD_ADDR_VAR 0 2
4781: PUSH
4782: DOUBLE
4783: LD_INT 1
4785: DEC
4786: ST_TO_ADDR
4787: LD_EXP 3
4791: PUSH
4792: FOR_TO
4793: IFFALSE 4865
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4795: LD_EXP 3
4799: PUSH
4800: LD_VAR 0 2
4804: ARRAY
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PUSH
4810: LD_VAR 0 4
4814: EQUAL
4815: IFFALSE 4839
4817: PUSH
4818: LD_EXP 3
4822: PUSH
4823: LD_VAR 0 2
4827: ARRAY
4828: PUSH
4829: LD_INT 2
4831: ARRAY
4832: PUSH
4833: LD_VAR 0 5
4837: EQUAL
4838: AND
4839: IFFALSE 4863
// begin staticMines := Delete ( staticMines , j ) ;
4841: LD_ADDR_EXP 3
4845: PUSH
4846: LD_EXP 3
4850: PPUSH
4851: LD_VAR 0 2
4855: PPUSH
4856: CALL_OW 3
4860: ST_TO_ADDR
// break ;
4861: GO 4865
// end ;
4863: GO 4792
4865: POP
4866: POP
// end ; end ;
4867: GO 4711
4869: POP
4870: POP
// end ;
4871: PPOPN 5
4873: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4874: LD_INT 7
4876: PPUSH
4877: CALL_OW 302
4881: IFFALSE 4890
4883: PUSH
4884: LD_EXP 4
4888: NOT
4889: AND
4890: IFFALSE 5490
4892: GO 4894
4894: DISABLE
4895: LD_INT 0
4897: PPUSH
4898: PPUSH
4899: PPUSH
4900: PPUSH
4901: PPUSH
// begin enable ;
4902: ENABLE
// base := 2 ;
4903: LD_ADDR_VAR 0 2
4907: PUSH
4908: LD_INT 2
4910: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_INT 14
4918: PUSH
4919: LD_INT 1
4921: PUSH
4922: LD_INT 2
4924: PUSH
4925: LD_INT 27
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 14
4936: PUSH
4937: LD_INT 1
4939: PUSH
4940: LD_INT 2
4942: PUSH
4943: LD_INT 27
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: PUSH
4952: LD_INT 14
4954: PUSH
4955: LD_INT 1
4957: PUSH
4958: LD_INT 2
4960: PUSH
4961: LD_INT 28
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_INT 14
4972: PUSH
4973: LD_INT 1
4975: PUSH
4976: LD_INT 2
4978: PUSH
4979: LD_INT 26
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4994: LD_ADDR_VAR 0 5
4998: PUSH
4999: LD_VAR 0 5
5003: PUSH
5004: LD_OWVAR 1
5008: PUSH
5009: LD_INT 21000
5011: DIV
5012: PLUS
5013: ST_TO_ADDR
// if amount > 8 then
5014: LD_VAR 0 5
5018: PUSH
5019: LD_INT 8
5021: GREATER
5022: IFFALSE 5032
// amount := 8 ;
5024: LD_ADDR_VAR 0 5
5028: PUSH
5029: LD_INT 8
5031: ST_TO_ADDR
// for i = 1 to amount do
5032: LD_ADDR_VAR 0 1
5036: PUSH
5037: DOUBLE
5038: LD_INT 1
5040: DEC
5041: ST_TO_ADDR
5042: LD_VAR 0 5
5046: PUSH
5047: FOR_TO
5048: IFFALSE 5136
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5050: LD_ADDR_VAR 0 3
5054: PUSH
5055: LD_VAR 0 3
5059: PPUSH
5060: LD_VAR 0 3
5064: PUSH
5065: LD_INT 1
5067: PLUS
5068: PPUSH
5069: LD_INT 14
5071: PUSH
5072: LD_INT 13
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: LD_INT 1
5081: PPUSH
5082: LD_INT 2
5084: PPUSH
5085: CALL_OW 12
5089: ARRAY
5090: PUSH
5091: LD_INT 1
5093: PUSH
5094: LD_INT 2
5096: PUSH
5097: LD_INT 28
5099: PUSH
5100: LD_INT 25
5102: PUSH
5103: LD_INT 27
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 1
5113: PPUSH
5114: LD_INT 3
5116: PPUSH
5117: CALL_OW 12
5121: ARRAY
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: LIST
5127: LIST
5128: PPUSH
5129: CALL_OW 2
5133: ST_TO_ADDR
5134: GO 5047
5136: POP
5137: POP
// MC_InsertProduceList ( base , tmp ) ;
5138: LD_VAR 0 2
5142: PPUSH
5143: LD_VAR 0 3
5147: PPUSH
5148: CALL 79239 0 2
// repeat wait ( 0 0$1 ) ;
5152: LD_INT 35
5154: PPUSH
5155: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5159: LD_VAR 0 2
5163: PPUSH
5164: LD_INT 1
5166: PPUSH
5167: CALL 80695 0 2
5171: PUSH
5172: LD_VAR 0 5
5176: GREATEREQUAL
5177: IFFALSE 5152
// wait ( 0 0$30 ) ;
5179: LD_INT 1050
5181: PPUSH
5182: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5186: LD_ADDR_VAR 0 4
5190: PUSH
5191: LD_EXP 42
5195: PUSH
5196: LD_VAR 0 2
5200: ARRAY
5201: PUSH
5202: LD_EXP 42
5206: PUSH
5207: LD_VAR 0 2
5211: ARRAY
5212: PPUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 34
5218: PUSH
5219: LD_INT 31
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 34
5228: PUSH
5229: LD_INT 32
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 34
5238: PUSH
5239: LD_INT 88
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: LIST
5250: LIST
5251: PPUSH
5252: CALL_OW 72
5256: DIFF
5257: ST_TO_ADDR
// if not attackers then
5258: LD_VAR 0 4
5262: NOT
5263: IFFALSE 5267
// exit ;
5265: GO 5490
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5267: LD_ADDR_EXP 42
5271: PUSH
5272: LD_EXP 42
5276: PPUSH
5277: LD_VAR 0 2
5281: PPUSH
5282: LD_EXP 42
5286: PUSH
5287: LD_VAR 0 2
5291: ARRAY
5292: PUSH
5293: LD_VAR 0 4
5297: DIFF
5298: PPUSH
5299: CALL_OW 1
5303: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5304: LD_VAR 0 4
5308: PPUSH
5309: LD_INT 107
5311: PPUSH
5312: LD_INT 74
5314: PPUSH
5315: CALL_OW 114
// wait ( 0 0$5 ) ;
5319: LD_INT 175
5321: PPUSH
5322: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5326: LD_INT 35
5328: PPUSH
5329: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5333: LD_VAR 0 4
5337: PPUSH
5338: LD_INT 60
5340: PUSH
5341: EMPTY
5342: LIST
5343: PPUSH
5344: CALL_OW 72
5348: NOT
5349: IFFALSE 5326
// if rand ( 0 , 1 ) then
5351: LD_INT 0
5353: PPUSH
5354: LD_INT 1
5356: PPUSH
5357: CALL_OW 12
5361: IFFALSE 5380
// ComAgressiveMove ( attackers , 155 , 108 ) else
5363: LD_VAR 0 4
5367: PPUSH
5368: LD_INT 155
5370: PPUSH
5371: LD_INT 108
5373: PPUSH
5374: CALL_OW 114
5378: GO 5395
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5380: LD_VAR 0 4
5384: PPUSH
5385: LD_INT 149
5387: PPUSH
5388: LD_INT 55
5390: PPUSH
5391: CALL_OW 114
// wait ( 0 0$10 ) ;
5395: LD_INT 350
5397: PPUSH
5398: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5402: LD_INT 35
5404: PPUSH
5405: CALL_OW 67
// for i in attackers do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_VAR 0 4
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5470
// if not HasTask ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 314
5431: NOT
5432: IFFALSE 5468
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5434: LD_VAR 0 1
5438: PPUSH
5439: LD_INT 81
5441: PUSH
5442: LD_INT 2
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PPUSH
5449: CALL_OW 69
5453: PPUSH
5454: LD_VAR 0 1
5458: PPUSH
5459: CALL_OW 74
5463: PPUSH
5464: CALL_OW 115
5468: GO 5419
5470: POP
5471: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5472: LD_VAR 0 4
5476: PPUSH
5477: LD_INT 50
5479: PUSH
5480: EMPTY
5481: LIST
5482: PPUSH
5483: CALL_OW 72
5487: NOT
5488: IFFALSE 5402
// end ;
5490: PPOPN 5
5492: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5493: LD_EXP 4
5497: NOT
5498: IFFALSE 5510
5500: PUSH
5501: LD_OWVAR 1
5505: PUSH
5506: LD_INT 191100
5508: LESS
5509: AND
5510: IFFALSE 6182
5512: GO 5514
5514: DISABLE
5515: LD_INT 0
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin enable ;
5520: ENABLE
// tmp := [ ] ;
5521: LD_ADDR_VAR 0 3
5525: PUSH
5526: EMPTY
5527: ST_TO_ADDR
// if tick < 35 35$00 then
5528: LD_OWVAR 1
5532: PUSH
5533: LD_INT 73500
5535: LESS
5536: IFFALSE 5734
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5538: LD_ADDR_VAR 0 1
5542: PUSH
5543: DOUBLE
5544: LD_INT 1
5546: DEC
5547: ST_TO_ADDR
5548: LD_INT 4
5550: PUSH
5551: LD_INT 5
5553: PUSH
5554: LD_INT 5
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: LIST
5561: PUSH
5562: LD_OWVAR 67
5566: ARRAY
5567: PUSH
5568: FOR_TO
5569: IFFALSE 5730
// begin uc_side := 2 ;
5571: LD_ADDR_OWVAR 20
5575: PUSH
5576: LD_INT 2
5578: ST_TO_ADDR
// uc_nation := 2 ;
5579: LD_ADDR_OWVAR 21
5583: PUSH
5584: LD_INT 2
5586: ST_TO_ADDR
// InitHC_All ( ) ;
5587: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5591: LD_INT 0
5593: PPUSH
5594: LD_INT 1
5596: PPUSH
5597: LD_INT 5
5599: PUSH
5600: LD_INT 6
5602: PUSH
5603: LD_INT 7
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PUSH
5611: LD_OWVAR 67
5615: ARRAY
5616: PPUSH
5617: CALL_OW 380
// un := CreateHuman ;
5621: LD_ADDR_VAR 0 2
5625: PUSH
5626: CALL_OW 44
5630: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5631: LD_VAR 0 2
5635: PPUSH
5636: LD_INT 17
5638: PPUSH
5639: LD_INT 0
5641: PPUSH
5642: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5646: LD_VAR 0 2
5650: PPUSH
5651: LD_INT 1
5653: PUSH
5654: LD_INT 8
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: PUSH
5661: LD_INT 1
5663: PPUSH
5664: LD_INT 2
5666: PPUSH
5667: CALL_OW 12
5671: ARRAY
5672: PPUSH
5673: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5677: LD_VAR 0 2
5681: PPUSH
5682: LD_INT 111
5684: PPUSH
5685: LD_INT 34
5687: PPUSH
5688: CALL_OW 114
// wait ( 0 0$2 ) ;
5692: LD_INT 70
5694: PPUSH
5695: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5699: LD_ADDR_VAR 0 3
5703: PUSH
5704: LD_VAR 0 3
5708: PPUSH
5709: LD_VAR 0 3
5713: PUSH
5714: LD_INT 1
5716: PLUS
5717: PPUSH
5718: LD_VAR 0 2
5722: PPUSH
5723: CALL_OW 1
5727: ST_TO_ADDR
// end ;
5728: GO 5568
5730: POP
5731: POP
// end else
5732: GO 5875
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 4
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 5
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: PUSH
5758: LD_OWVAR 67
5762: ARRAY
5763: PUSH
5764: FOR_TO
5765: IFFALSE 5873
// begin uc_side := 2 ;
5767: LD_ADDR_OWVAR 20
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// uc_nation := 0 ;
5775: LD_ADDR_OWVAR 21
5779: PUSH
5780: LD_INT 0
5782: ST_TO_ADDR
// InitHC_All ( ) ;
5783: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5787: LD_ADDR_OWVAR 28
5791: PUSH
5792: LD_INT 17
5794: ST_TO_ADDR
// un := CreateHuman ;
5795: LD_ADDR_VAR 0 2
5799: PUSH
5800: CALL_OW 44
5804: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5805: LD_VAR 0 2
5809: PPUSH
5810: LD_INT 17
5812: PPUSH
5813: LD_INT 0
5815: PPUSH
5816: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5820: LD_VAR 0 2
5824: PPUSH
5825: LD_INT 110
5827: PPUSH
5828: LD_INT 33
5830: PPUSH
5831: CALL_OW 114
// wait ( 0 0$2 ) ;
5835: LD_INT 70
5837: PPUSH
5838: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5842: LD_ADDR_VAR 0 3
5846: PUSH
5847: LD_VAR 0 3
5851: PPUSH
5852: LD_VAR 0 3
5856: PUSH
5857: LD_INT 1
5859: PLUS
5860: PPUSH
5861: LD_VAR 0 2
5865: PPUSH
5866: CALL_OW 1
5870: ST_TO_ADDR
// end ;
5871: GO 5764
5873: POP
5874: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_INT 3
5887: PUSH
5888: LD_INT 4
5890: PUSH
5891: LD_INT 5
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_OWVAR 67
5903: ARRAY
5904: PUSH
5905: FOR_TO
5906: IFFALSE 6071
// begin uc_side := 2 ;
5908: LD_ADDR_OWVAR 20
5912: PUSH
5913: LD_INT 2
5915: ST_TO_ADDR
// uc_nation := 2 ;
5916: LD_ADDR_OWVAR 21
5920: PUSH
5921: LD_INT 2
5923: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5924: LD_INT 14
5926: PPUSH
5927: LD_INT 3
5929: PPUSH
5930: LD_INT 5
5932: PPUSH
5933: LD_INT 29
5935: PUSH
5936: LD_INT 28
5938: PUSH
5939: LD_INT 27
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 1
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: CALL_OW 12
5957: ARRAY
5958: PPUSH
5959: LD_INT 90
5961: PPUSH
5962: CALL 16167 0 5
// un := CreateVehicle ;
5966: LD_ADDR_VAR 0 2
5970: PUSH
5971: CALL_OW 45
5975: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5976: LD_VAR 0 2
5980: PPUSH
5981: LD_INT 2
5983: PPUSH
5984: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5988: LD_VAR 0 2
5992: PPUSH
5993: LD_INT 17
5995: PPUSH
5996: LD_INT 0
5998: PPUSH
5999: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
6003: LD_VAR 0 2
6007: PPUSH
6008: LD_INT 66
6010: PPUSH
6011: LD_INT 23
6013: PPUSH
6014: CALL_OW 111
// wait ( 0 0$3 ) ;
6018: LD_INT 105
6020: PPUSH
6021: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6025: LD_VAR 0 2
6029: PPUSH
6030: LD_INT 147
6032: PPUSH
6033: LD_INT 103
6035: PPUSH
6036: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6040: LD_ADDR_VAR 0 3
6044: PUSH
6045: LD_VAR 0 3
6049: PPUSH
6050: LD_VAR 0 3
6054: PUSH
6055: LD_INT 1
6057: PLUS
6058: PPUSH
6059: LD_VAR 0 2
6063: PPUSH
6064: CALL_OW 1
6068: ST_TO_ADDR
// end ;
6069: GO 5905
6071: POP
6072: POP
// if not tmp then
6073: LD_VAR 0 3
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6182
// wait ( 0 0$5 ) ;
6082: LD_INT 175
6084: PPUSH
6085: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6089: LD_INT 70
6091: PPUSH
6092: CALL_OW 67
// for i in tmp do
6096: LD_ADDR_VAR 0 1
6100: PUSH
6101: LD_VAR 0 3
6105: PUSH
6106: FOR_IN
6107: IFFALSE 6173
// begin if not IsOk ( i ) then
6109: LD_VAR 0 1
6113: PPUSH
6114: CALL_OW 302
6118: NOT
6119: IFFALSE 6137
// tmp := tmp diff i ;
6121: LD_ADDR_VAR 0 3
6125: PUSH
6126: LD_VAR 0 3
6130: PUSH
6131: LD_VAR 0 1
6135: DIFF
6136: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6137: LD_VAR 0 1
6141: PPUSH
6142: LD_INT 81
6144: PUSH
6145: LD_INT 2
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: PPUSH
6157: LD_VAR 0 1
6161: PPUSH
6162: CALL_OW 74
6166: PPUSH
6167: CALL_OW 115
// end ;
6171: GO 6106
6173: POP
6174: POP
// until not tmp ;
6175: LD_VAR 0 3
6179: NOT
6180: IFFALSE 6089
// end ;
6182: PPOPN 3
6184: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6185: LD_OWVAR 67
6189: PUSH
6190: LD_INT 1
6192: GREATER
6193: IFFALSE 6291
6195: GO 6197
6197: DISABLE
6198: LD_INT 0
6200: PPUSH
// begin uc_side := 2 ;
6201: LD_ADDR_OWVAR 20
6205: PUSH
6206: LD_INT 2
6208: ST_TO_ADDR
// uc_nation := 2 ;
6209: LD_ADDR_OWVAR 21
6213: PUSH
6214: LD_INT 2
6216: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6217: LD_INT 0
6219: PPUSH
6220: LD_INT 4
6222: PPUSH
6223: LD_INT 6
6225: PPUSH
6226: CALL_OW 380
// un := CreateHuman ;
6230: LD_ADDR_VAR 0 1
6234: PUSH
6235: CALL_OW 44
6239: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6240: LD_VAR 0 1
6244: PPUSH
6245: LD_INT 88
6247: PPUSH
6248: LD_INT 1
6250: PPUSH
6251: LD_INT 2
6253: PPUSH
6254: LD_INT 0
6256: PPUSH
6257: CALL 51507 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 130
6268: PPUSH
6269: LD_INT 35
6271: PPUSH
6272: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6276: LD_VAR 0 1
6280: PPUSH
6281: LD_INT 132
6283: PPUSH
6284: LD_INT 39
6286: PPUSH
6287: CALL_OW 218
// end ;
6291: PPOPN 1
6293: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6294: LD_INT 22
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 33
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 50
6316: PUSH
6317: EMPTY
6318: LIST
6319: PUSH
6320: LD_INT 3
6322: PUSH
6323: LD_INT 61
6325: PUSH
6326: EMPTY
6327: LIST
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PPUSH
6339: CALL_OW 69
6343: IFFALSE 6434
6345: GO 6347
6347: DISABLE
6348: LD_INT 0
6350: PPUSH
6351: PPUSH
// begin enable ;
6352: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6353: LD_ADDR_VAR 0 2
6357: PUSH
6358: LD_INT 22
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 33
6370: PUSH
6371: LD_INT 2
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 50
6380: PUSH
6381: EMPTY
6382: LIST
6383: PUSH
6384: LD_INT 3
6386: PUSH
6387: LD_INT 61
6389: PUSH
6390: EMPTY
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PPUSH
6403: CALL_OW 69
6407: ST_TO_ADDR
// for i in tmp do
6408: LD_ADDR_VAR 0 1
6412: PUSH
6413: LD_VAR 0 2
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6432
// Connect ( i ) ;
6421: LD_VAR 0 1
6425: PPUSH
6426: CALL 19649 0 1
6430: GO 6418
6432: POP
6433: POP
// end ; end_of_file
6434: PPOPN 2
6436: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6437: LD_INT 0
6439: PPUSH
6440: PPUSH
6441: PPUSH
6442: PPUSH
6443: PPUSH
6444: PPUSH
// popov_side := 3 ;
6445: LD_ADDR_EXP 17
6449: PUSH
6450: LD_INT 3
6452: ST_TO_ADDR
// uc_side := popov_side ;
6453: LD_ADDR_OWVAR 20
6457: PUSH
6458: LD_EXP 17
6462: ST_TO_ADDR
// uc_nation := 3 ;
6463: LD_ADDR_OWVAR 21
6467: PUSH
6468: LD_INT 3
6470: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6471: LD_ADDR_VAR 0 6
6475: PUSH
6476: LD_INT 5
6478: PUSH
6479: LD_INT 103
6481: PUSH
6482: LD_INT 147
6484: PUSH
6485: LD_INT 3
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 5
6496: PUSH
6497: LD_INT 70
6499: PUSH
6500: LD_INT 117
6502: PUSH
6503: LD_INT 3
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 6
6514: PUSH
6515: LD_INT 76
6517: PUSH
6518: LD_INT 145
6520: PUSH
6521: LD_INT 1
6523: PUSH
6524: LD_INT 10
6526: PUSH
6527: LD_INT 11
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: LIST
6534: LIST
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 26
6540: PUSH
6541: LD_INT 87
6543: PUSH
6544: LD_INT 144
6546: PUSH
6547: LD_INT 0
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 29
6558: PUSH
6559: LD_INT 86
6561: PUSH
6562: LD_INT 118
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 29
6576: PUSH
6577: LD_INT 98
6579: PUSH
6580: LD_INT 121
6582: PUSH
6583: LD_INT 0
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PUSH
6592: LD_INT 26
6594: PUSH
6595: LD_INT 87
6597: PUSH
6598: LD_INT 147
6600: PUSH
6601: LD_INT 1
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 30
6612: PUSH
6613: LD_INT 123
6615: PUSH
6616: LD_INT 151
6618: PUSH
6619: LD_INT 1
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 3
6630: PUSH
6631: LD_INT 94
6633: PUSH
6634: LD_INT 161
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 6
6648: PUSH
6649: LD_INT 81
6651: PUSH
6652: LD_INT 155
6654: PUSH
6655: LD_INT 1
6657: PUSH
6658: LD_INT 12
6660: PUSH
6661: LD_INT 14
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 26
6674: PUSH
6675: LD_INT 96
6677: PUSH
6678: LD_INT 152
6680: PUSH
6681: LD_INT 0
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 26
6692: PUSH
6693: LD_INT 96
6695: PUSH
6696: LD_INT 149
6698: PUSH
6699: LD_INT 3
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 32
6710: PUSH
6711: LD_INT 109
6713: PUSH
6714: LD_INT 142
6716: PUSH
6717: LD_INT 3
6719: PUSH
6720: LD_INT 46
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 32
6732: PUSH
6733: LD_INT 112
6735: PUSH
6736: LD_INT 148
6738: PUSH
6739: LD_INT 3
6741: PUSH
6742: LD_INT 46
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 120
6757: PUSH
6758: LD_INT 159
6760: PUSH
6761: LD_INT 4
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 122
6779: PUSH
6780: LD_INT 163
6782: PUSH
6783: LD_INT 4
6785: PUSH
6786: LD_INT 45
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 123
6801: PUSH
6802: LD_INT 167
6804: PUSH
6805: LD_INT 4
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 59
6823: PUSH
6824: LD_INT 111
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 45
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 65
6845: PUSH
6846: LD_INT 111
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 46
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 33
6864: PUSH
6865: LD_INT 76
6867: PUSH
6868: LD_INT 117
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: LD_INT 45
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 33
6886: PUSH
6887: LD_INT 80
6889: PUSH
6890: LD_INT 119
6892: PUSH
6893: LD_INT 3
6895: PUSH
6896: LD_INT 46
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: PUSH
6906: LD_INT 33
6908: PUSH
6909: LD_INT 87
6911: PUSH
6912: LD_INT 125
6914: PUSH
6915: LD_INT 3
6917: PUSH
6918: LD_INT 45
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 5
6930: PUSH
6931: LD_INT 92
6933: PUSH
6934: LD_INT 129
6936: PUSH
6937: LD_INT 3
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 28
6948: PUSH
6949: LD_INT 85
6951: PUSH
6952: LD_INT 165
6954: PUSH
6955: LD_INT 0
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 28
6966: PUSH
6967: LD_INT 83
6969: PUSH
6970: LD_INT 161
6972: PUSH
6973: LD_INT 4
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: LD_INT 28
6984: PUSH
6985: LD_INT 91
6987: PUSH
6988: LD_INT 166
6990: PUSH
6991: LD_INT 3
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: LIST
6999: PUSH
7000: LD_INT 28
7002: PUSH
7003: LD_INT 102
7005: PUSH
7006: LD_INT 166
7008: PUSH
7009: LD_INT 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: LIST
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: ST_TO_ADDR
// for i in list do
7047: LD_ADDR_VAR 0 2
7051: PUSH
7052: LD_VAR 0 6
7056: PUSH
7057: FOR_IN
7058: IFFALSE 7268
// begin uc_side := 3 ;
7060: LD_ADDR_OWVAR 20
7064: PUSH
7065: LD_INT 3
7067: ST_TO_ADDR
// uc_nation := 3 ;
7068: LD_ADDR_OWVAR 21
7072: PUSH
7073: LD_INT 3
7075: ST_TO_ADDR
// InitBc ;
7076: CALL_OW 21
// bc_type := i [ 1 ] ;
7080: LD_ADDR_OWVAR 42
7084: PUSH
7085: LD_VAR 0 2
7089: PUSH
7090: LD_INT 1
7092: ARRAY
7093: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7094: LD_VAR 0 2
7098: PUSH
7099: LD_INT 1
7101: ARRAY
7102: PUSH
7103: LD_INT 29
7105: PUSH
7106: LD_INT 30
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: IN
7113: IFFALSE 7140
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_INT 3
7131: ARRAY
7132: PPUSH
7133: LD_INT 3
7135: PPUSH
7136: CALL_OW 441
// if i [ 1 ] = b_lab then
7140: LD_VAR 0 2
7144: PUSH
7145: LD_INT 1
7147: ARRAY
7148: PUSH
7149: LD_INT 6
7151: EQUAL
7152: IFFALSE 7190
// begin bc_type := b_lab_full ;
7154: LD_ADDR_OWVAR 42
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7162: LD_ADDR_OWVAR 44
7166: PUSH
7167: LD_VAR 0 2
7171: PUSH
7172: LD_INT 5
7174: ARRAY
7175: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7176: LD_ADDR_OWVAR 45
7180: PUSH
7181: LD_VAR 0 2
7185: PUSH
7186: LD_INT 6
7188: ARRAY
7189: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7190: LD_ADDR_VAR 0 5
7194: PUSH
7195: LD_VAR 0 2
7199: PUSH
7200: LD_INT 2
7202: ARRAY
7203: PPUSH
7204: LD_VAR 0 2
7208: PUSH
7209: LD_INT 3
7211: ARRAY
7212: PPUSH
7213: LD_VAR 0 2
7217: PUSH
7218: LD_INT 4
7220: ARRAY
7221: PPUSH
7222: CALL_OW 47
7226: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7227: LD_VAR 0 2
7231: PUSH
7232: LD_INT 1
7234: ARRAY
7235: PUSH
7236: LD_INT 33
7238: PUSH
7239: LD_INT 32
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: IN
7246: IFFALSE 7266
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7248: LD_VAR 0 5
7252: PPUSH
7253: LD_VAR 0 2
7257: PUSH
7258: LD_INT 5
7260: ARRAY
7261: PPUSH
7262: CALL_OW 431
// end ;
7266: GO 7057
7268: POP
7269: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7270: LD_ADDR_VAR 0 4
7274: PUSH
7275: LD_INT 9
7277: PPUSH
7278: LD_INT 3
7280: PPUSH
7281: LD_STRING 
7283: PPUSH
7284: LD_INT 8
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 6
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: PUSH
7298: LD_OWVAR 67
7302: ARRAY
7303: PPUSH
7304: LD_INT 11500
7306: PUSH
7307: LD_INT 1100
7309: PUSH
7310: LD_INT 60
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: LIST
7317: PPUSH
7318: LD_INT 6
7320: PUSH
7321: LD_INT 6
7323: PUSH
7324: LD_INT 6
7326: PUSH
7327: LD_INT 6
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: LIST
7334: LIST
7335: PPUSH
7336: CALL 20004 0 6
7340: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7341: LD_ADDR_EXP 23
7345: PUSH
7346: LD_EXP 23
7350: PPUSH
7351: LD_INT 3
7353: PPUSH
7354: LD_VAR 0 4
7358: PUSH
7359: LD_INT 22
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: LD_INT 21
7371: PUSH
7372: LD_INT 3
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PPUSH
7383: CALL_OW 69
7387: UNION
7388: PPUSH
7389: CALL_OW 1
7393: ST_TO_ADDR
// extraPopovForces := [ ] ;
7394: LD_ADDR_EXP 18
7398: PUSH
7399: EMPTY
7400: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7401: LD_ADDR_VAR 0 2
7405: PUSH
7406: DOUBLE
7407: LD_INT 1
7409: DEC
7410: ST_TO_ADDR
7411: LD_INT 8
7413: PUSH
7414: LD_INT 9
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: PUSH
7425: LD_OWVAR 67
7429: ARRAY
7430: PUSH
7431: FOR_TO
7432: IFFALSE 7561
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7434: LD_INT 0
7436: PPUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 4
7442: PUSH
7443: LD_INT 5
7445: PUSH
7446: LD_INT 6
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: LIST
7453: PUSH
7454: LD_OWVAR 67
7458: ARRAY
7459: PPUSH
7460: CALL_OW 380
// un := CreateHuman ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: CALL_OW 44
7473: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7474: LD_INT 0
7476: PPUSH
7477: LD_INT 1
7479: PPUSH
7480: CALL_OW 12
7484: IFFALSE 7509
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7486: LD_VAR 0 3
7490: PPUSH
7491: LD_INT 131
7493: PPUSH
7494: LD_INT 110
7496: PPUSH
7497: LD_INT 8
7499: PPUSH
7500: LD_INT 0
7502: PPUSH
7503: CALL_OW 50
7507: GO 7530
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7509: LD_VAR 0 3
7513: PPUSH
7514: LD_INT 100
7516: PPUSH
7517: LD_INT 99
7519: PPUSH
7520: LD_INT 8
7522: PPUSH
7523: LD_INT 0
7525: PPUSH
7526: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7530: LD_ADDR_EXP 18
7534: PUSH
7535: LD_EXP 18
7539: PPUSH
7540: LD_EXP 18
7544: PUSH
7545: LD_INT 1
7547: PLUS
7548: PPUSH
7549: LD_VAR 0 3
7553: PPUSH
7554: CALL_OW 1
7558: ST_TO_ADDR
// end ;
7559: GO 7431
7561: POP
7562: POP
// PrepareSoldier ( false , 6 ) ;
7563: LD_INT 0
7565: PPUSH
7566: LD_INT 6
7568: PPUSH
7569: CALL_OW 381
// un := CreateHuman ;
7573: LD_ADDR_VAR 0 3
7577: PUSH
7578: CALL_OW 44
7582: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7583: LD_VAR 0 3
7587: PPUSH
7588: LD_INT 1
7590: PPUSH
7591: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7595: LD_VAR 0 3
7599: PPUSH
7600: LD_INT 150
7602: PPUSH
7603: LD_INT 158
7605: PPUSH
7606: CALL_OW 428
7610: PPUSH
7611: CALL_OW 52
// popovAttackGroup := [ ] ;
7615: LD_ADDR_EXP 19
7619: PUSH
7620: EMPTY
7621: ST_TO_ADDR
// end ;
7622: LD_VAR 0 1
7626: RET
// export function InitMC_Popov ( ) ; begin
7627: LD_INT 0
7629: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 3
7635: PPUSH
7636: CALL 80544 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 10
7645: PPUSH
7646: CALL 80484 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7650: LD_INT 3
7652: PPUSH
7653: LD_INT 86
7655: PUSH
7656: LD_INT 118
7658: PUSH
7659: LD_INT 0
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: PUSH
7667: LD_INT 123
7669: PUSH
7670: LD_INT 151
7672: PUSH
7673: LD_INT 1
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: PUSH
7681: LD_INT 98
7683: PUSH
7684: LD_INT 121
7686: PUSH
7687: LD_INT 0
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL 79515 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7704: LD_INT 3
7706: PPUSH
7707: LD_INT 46
7709: PUSH
7710: LD_INT 45
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PPUSH
7717: CALL 80364 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 12
7726: PPUSH
7727: CALL 80034 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 11
7736: PPUSH
7737: CALL 79757 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 4
7746: PPUSH
7747: CALL 79376 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7751: LD_INT 3
7753: PPUSH
7754: LD_INT 23
7756: PUSH
7757: LD_INT 1
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 44
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 23
7774: PUSH
7775: LD_INT 1
7777: PUSH
7778: LD_INT 3
7780: PUSH
7781: LD_INT 45
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 21
7792: PUSH
7793: LD_INT 1
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: LD_INT 44
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 21
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: LD_INT 45
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: LIST
7830: LIST
7831: PPUSH
7832: CALL 79191 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7836: LD_INT 3
7838: PPUSH
7839: LD_INT 94
7841: PPUSH
7842: LD_INT 161
7844: PPUSH
7845: LD_INT 0
7847: PPUSH
7848: LD_INT 19
7850: PUSH
7851: LD_INT 17
7853: PUSH
7854: LD_INT 18
7856: PUSH
7857: LD_INT 24
7859: PUSH
7860: LD_INT 21
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: LIST
7867: LIST
7868: LIST
7869: PPUSH
7870: CALL 80154 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 21
7879: PUSH
7880: LD_INT 1
7882: PUSH
7883: LD_INT 3
7885: PUSH
7886: LD_INT 51
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: LIST
7893: LIST
7894: PUSH
7895: EMPTY
7896: LIST
7897: PPUSH
7898: CALL 79239 0 2
// end ;
7902: LD_VAR 0 1
7906: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7907: LD_EXP 18
7911: IFFALSE 7920
7913: PUSH
7914: LD_EXP 5
7918: NOT
7919: AND
7920: IFFALSE 7980
7922: GO 7924
7924: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7925: LD_EXP 18
7929: PPUSH
7930: LD_INT 106
7932: PPUSH
7933: LD_INT 137
7935: PPUSH
7936: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7940: LD_ADDR_EXP 23
7944: PUSH
7945: LD_EXP 23
7949: PPUSH
7950: LD_INT 3
7952: PPUSH
7953: LD_EXP 23
7957: PUSH
7958: LD_INT 3
7960: ARRAY
7961: PUSH
7962: LD_EXP 18
7966: UNION
7967: PPUSH
7968: CALL_OW 1
7972: ST_TO_ADDR
// extraPopovForces := [ ] ;
7973: LD_ADDR_EXP 18
7977: PUSH
7978: EMPTY
7979: ST_TO_ADDR
// end ;
7980: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7981: LD_INT 9
7983: PPUSH
7984: CALL_OW 302
7988: IFFALSE 7997
7990: PUSH
7991: LD_EXP 5
7995: NOT
7996: AND
7997: IFFALSE 8563
7999: GO 8001
8001: DISABLE
8002: LD_INT 0
8004: PPUSH
8005: PPUSH
8006: PPUSH
8007: PPUSH
8008: PPUSH
// begin enable ;
8009: ENABLE
// base := 3 ;
8010: LD_ADDR_VAR 0 2
8014: PUSH
8015: LD_INT 3
8017: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8018: LD_ADDR_VAR 0 3
8022: PUSH
8023: LD_INT 21
8025: PUSH
8026: LD_INT 1
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: LD_INT 44
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 23
8043: PUSH
8044: LD_INT 1
8046: PUSH
8047: LD_INT 3
8049: PUSH
8050: LD_INT 46
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: LIST
8058: PUSH
8059: LD_INT 23
8061: PUSH
8062: LD_INT 1
8064: PUSH
8065: LD_INT 3
8067: PUSH
8068: LD_INT 46
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_INT 23
8079: PUSH
8080: LD_INT 1
8082: PUSH
8083: LD_INT 3
8085: PUSH
8086: LD_INT 46
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8101: LD_ADDR_VAR 0 5
8105: PUSH
8106: LD_VAR 0 5
8110: PUSH
8111: LD_OWVAR 1
8115: PUSH
8116: LD_INT 21000
8118: DIV
8119: PLUS
8120: ST_TO_ADDR
// if amount > 8 then
8121: LD_VAR 0 5
8125: PUSH
8126: LD_INT 8
8128: GREATER
8129: IFFALSE 8139
// amount := 8 ;
8131: LD_ADDR_VAR 0 5
8135: PUSH
8136: LD_INT 8
8138: ST_TO_ADDR
// for i = 1 to amount do
8139: LD_ADDR_VAR 0 1
8143: PUSH
8144: DOUBLE
8145: LD_INT 1
8147: DEC
8148: ST_TO_ADDR
8149: LD_VAR 0 5
8153: PUSH
8154: FOR_TO
8155: IFFALSE 8220
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8157: LD_ADDR_VAR 0 3
8161: PUSH
8162: LD_VAR 0 3
8166: PPUSH
8167: LD_VAR 0 3
8171: PUSH
8172: LD_INT 1
8174: PLUS
8175: PPUSH
8176: LD_INT 23
8178: PUSH
8179: LD_INT 1
8181: PUSH
8182: LD_INT 3
8184: PUSH
8185: LD_INT 46
8187: PUSH
8188: LD_INT 45
8190: PUSH
8191: EMPTY
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 1
8197: PPUSH
8198: LD_INT 2
8200: PPUSH
8201: CALL_OW 12
8205: ARRAY
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 2
8217: ST_TO_ADDR
8218: GO 8154
8220: POP
8221: POP
// MC_InsertProduceList ( base , tmp ) ;
8222: LD_VAR 0 2
8226: PPUSH
8227: LD_VAR 0 3
8231: PPUSH
8232: CALL 79239 0 2
// repeat wait ( 0 0$1 ) ;
8236: LD_INT 35
8238: PPUSH
8239: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8243: LD_VAR 0 2
8247: PPUSH
8248: LD_INT 1
8250: PPUSH
8251: CALL 80695 0 2
8255: PUSH
8256: LD_VAR 0 5
8260: GREATEREQUAL
8261: IFFALSE 8236
// wait ( 0 0$30 ) ;
8263: LD_INT 1050
8265: PPUSH
8266: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8270: LD_ADDR_VAR 0 4
8274: PUSH
8275: LD_EXP 42
8279: PUSH
8280: LD_VAR 0 2
8284: ARRAY
8285: PUSH
8286: LD_EXP 42
8290: PUSH
8291: LD_VAR 0 2
8295: ARRAY
8296: PPUSH
8297: LD_INT 2
8299: PUSH
8300: LD_INT 34
8302: PUSH
8303: LD_INT 51
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: PUSH
8310: LD_INT 34
8312: PUSH
8313: LD_INT 52
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 72
8329: DIFF
8330: ST_TO_ADDR
// if not attackers then
8331: LD_VAR 0 4
8335: NOT
8336: IFFALSE 8340
// exit ;
8338: GO 8563
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8340: LD_ADDR_EXP 42
8344: PUSH
8345: LD_EXP 42
8349: PPUSH
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_EXP 42
8359: PUSH
8360: LD_VAR 0 2
8364: ARRAY
8365: PUSH
8366: LD_VAR 0 4
8370: DIFF
8371: PPUSH
8372: CALL_OW 1
8376: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8377: LD_VAR 0 4
8381: PPUSH
8382: LD_INT 107
8384: PPUSH
8385: LD_INT 74
8387: PPUSH
8388: CALL_OW 114
// wait ( 0 0$5 ) ;
8392: LD_INT 175
8394: PPUSH
8395: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8399: LD_INT 35
8401: PPUSH
8402: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8406: LD_VAR 0 4
8410: PPUSH
8411: LD_INT 60
8413: PUSH
8414: EMPTY
8415: LIST
8416: PPUSH
8417: CALL_OW 72
8421: NOT
8422: IFFALSE 8399
// if rand ( 0 , 1 ) then
8424: LD_INT 0
8426: PPUSH
8427: LD_INT 1
8429: PPUSH
8430: CALL_OW 12
8434: IFFALSE 8453
// ComAgressiveMove ( attackers , 155 , 108 ) else
8436: LD_VAR 0 4
8440: PPUSH
8441: LD_INT 155
8443: PPUSH
8444: LD_INT 108
8446: PPUSH
8447: CALL_OW 114
8451: GO 8468
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8453: LD_VAR 0 4
8457: PPUSH
8458: LD_INT 149
8460: PPUSH
8461: LD_INT 55
8463: PPUSH
8464: CALL_OW 114
// wait ( 0 0$10 ) ;
8468: LD_INT 350
8470: PPUSH
8471: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8475: LD_INT 35
8477: PPUSH
8478: CALL_OW 67
// for i in attackers do
8482: LD_ADDR_VAR 0 1
8486: PUSH
8487: LD_VAR 0 4
8491: PUSH
8492: FOR_IN
8493: IFFALSE 8543
// if not HasTask ( i ) then
8495: LD_VAR 0 1
8499: PPUSH
8500: CALL_OW 314
8504: NOT
8505: IFFALSE 8541
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8507: LD_VAR 0 1
8511: PPUSH
8512: LD_INT 81
8514: PUSH
8515: LD_INT 3
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PPUSH
8527: LD_VAR 0 1
8531: PPUSH
8532: CALL_OW 74
8536: PPUSH
8537: CALL_OW 115
8541: GO 8492
8543: POP
8544: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8545: LD_VAR 0 4
8549: PPUSH
8550: LD_INT 50
8552: PUSH
8553: EMPTY
8554: LIST
8555: PPUSH
8556: CALL_OW 72
8560: NOT
8561: IFFALSE 8475
// end ;
8563: PPOPN 5
8565: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8566: LD_EXP 5
8570: NOT
8571: IFFALSE 9162
8573: GO 8575
8575: DISABLE
8576: LD_INT 0
8578: PPUSH
8579: PPUSH
8580: PPUSH
8581: PPUSH
// begin enable ;
8582: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8583: LD_OWVAR 67
8587: PUSH
8588: LD_INT 1
8590: EQUAL
8591: IFFALSE 8603
8593: PUSH
8594: LD_OWVAR 1
8598: PUSH
8599: LD_INT 63000
8601: LESS
8602: AND
8603: IFFALSE 8607
// exit ;
8605: GO 9162
// tmp := [ ] ;
8607: LD_ADDR_VAR 0 3
8611: PUSH
8612: EMPTY
8613: ST_TO_ADDR
// if tick < 45 45$00 then
8614: LD_OWVAR 1
8618: PUSH
8619: LD_INT 94500
8621: LESS
8622: IFFALSE 8799
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8624: LD_ADDR_VAR 0 1
8628: PUSH
8629: DOUBLE
8630: LD_INT 1
8632: DEC
8633: ST_TO_ADDR
8634: LD_INT 2
8636: PUSH
8637: LD_INT 3
8639: PUSH
8640: LD_INT 4
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: PUSH
8648: LD_OWVAR 67
8652: ARRAY
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8797
// begin uc_side := 3 ;
8657: LD_ADDR_OWVAR 20
8661: PUSH
8662: LD_INT 3
8664: ST_TO_ADDR
// uc_nation := 3 ;
8665: LD_ADDR_OWVAR 21
8669: PUSH
8670: LD_INT 3
8672: ST_TO_ADDR
// InitHC_All ( ) ;
8673: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8677: LD_INT 0
8679: PPUSH
8680: LD_INT 1
8682: PPUSH
8683: LD_INT 5
8685: PUSH
8686: LD_INT 6
8688: PUSH
8689: LD_INT 7
8691: PUSH
8692: EMPTY
8693: LIST
8694: LIST
8695: LIST
8696: PUSH
8697: LD_OWVAR 67
8701: ARRAY
8702: PPUSH
8703: CALL_OW 380
// un := CreateHuman ;
8707: LD_ADDR_VAR 0 2
8711: PUSH
8712: CALL_OW 44
8716: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8717: LD_VAR 0 2
8721: PPUSH
8722: LD_INT 18
8724: PPUSH
8725: LD_INT 0
8727: PPUSH
8728: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8732: LD_VAR 0 2
8736: PPUSH
8737: LD_INT 9
8739: PPUSH
8740: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8744: LD_VAR 0 2
8748: PPUSH
8749: LD_INT 147
8751: PPUSH
8752: LD_INT 161
8754: PPUSH
8755: CALL_OW 111
// wait ( 0 0$2 ) ;
8759: LD_INT 70
8761: PPUSH
8762: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 3
8775: PPUSH
8776: LD_VAR 0 3
8780: PUSH
8781: LD_INT 1
8783: PLUS
8784: PPUSH
8785: LD_VAR 0 2
8789: PPUSH
8790: CALL_OW 1
8794: ST_TO_ADDR
// end ;
8795: GO 8654
8797: POP
8798: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8799: LD_ADDR_VAR 0 4
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 4
8809: PUSH
8810: LD_INT 5
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: LIST
8817: PUSH
8818: LD_OWVAR 67
8822: ARRAY
8823: PUSH
8824: LD_OWVAR 1
8828: PUSH
8829: LD_INT 21000
8831: DIV
8832: PLUS
8833: ST_TO_ADDR
// if amount > 15 then
8834: LD_VAR 0 4
8838: PUSH
8839: LD_INT 15
8841: GREATER
8842: IFFALSE 8852
// amount := 15 ;
8844: LD_ADDR_VAR 0 4
8848: PUSH
8849: LD_INT 15
8851: ST_TO_ADDR
// for i := 1 to amount do
8852: LD_ADDR_VAR 0 1
8856: PUSH
8857: DOUBLE
8858: LD_INT 1
8860: DEC
8861: ST_TO_ADDR
8862: LD_VAR 0 4
8866: PUSH
8867: FOR_TO
8868: IFFALSE 9014
// begin uc_side := 3 ;
8870: LD_ADDR_OWVAR 20
8874: PUSH
8875: LD_INT 3
8877: ST_TO_ADDR
// uc_nation := 3 ;
8878: LD_ADDR_OWVAR 21
8882: PUSH
8883: LD_INT 3
8885: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8886: LD_INT 24
8888: PPUSH
8889: LD_INT 1
8891: PPUSH
8892: LD_INT 3
8894: PPUSH
8895: LD_INT 46
8897: PUSH
8898: LD_INT 45
8900: PUSH
8901: LD_INT 44
8903: PUSH
8904: LD_INT 43
8906: PUSH
8907: LD_INT 42
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: LIST
8916: PUSH
8917: LD_INT 1
8919: PPUSH
8920: LD_INT 5
8922: PPUSH
8923: CALL_OW 12
8927: ARRAY
8928: PPUSH
8929: LD_INT 90
8931: PPUSH
8932: CALL 16167 0 5
// un := CreateVehicle ;
8936: LD_ADDR_VAR 0 2
8940: PUSH
8941: CALL_OW 45
8945: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8946: LD_VAR 0 2
8950: PPUSH
8951: LD_INT 18
8953: PPUSH
8954: LD_INT 0
8956: PPUSH
8957: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8961: LD_VAR 0 2
8965: PPUSH
8966: LD_INT 147
8968: PPUSH
8969: LD_INT 161
8971: PPUSH
8972: CALL_OW 111
// wait ( 0 0$3 ) ;
8976: LD_INT 105
8978: PPUSH
8979: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8983: LD_ADDR_VAR 0 3
8987: PUSH
8988: LD_VAR 0 3
8992: PPUSH
8993: LD_VAR 0 3
8997: PUSH
8998: LD_INT 1
9000: PLUS
9001: PPUSH
9002: LD_VAR 0 2
9006: PPUSH
9007: CALL_OW 1
9011: ST_TO_ADDR
// end ;
9012: GO 8867
9014: POP
9015: POP
// if not tmp then
9016: LD_VAR 0 3
9020: NOT
9021: IFFALSE 9025
// exit ;
9023: GO 9162
// wait ( 0 0$5 ) ;
9025: LD_INT 175
9027: PPUSH
9028: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9032: LD_INT 70
9034: PPUSH
9035: CALL_OW 67
// for i in tmp do
9039: LD_ADDR_VAR 0 1
9043: PUSH
9044: LD_VAR 0 3
9048: PUSH
9049: FOR_IN
9050: IFFALSE 9153
// begin if not IsOk ( i ) or IsDead ( i ) then
9052: LD_VAR 0 1
9056: PPUSH
9057: CALL_OW 302
9061: NOT
9062: IFTRUE 9075
9064: PUSH
9065: LD_VAR 0 1
9069: PPUSH
9070: CALL_OW 301
9074: OR
9075: IFFALSE 9093
// tmp := tmp diff i ;
9077: LD_ADDR_VAR 0 3
9081: PUSH
9082: LD_VAR 0 3
9086: PUSH
9087: LD_VAR 0 1
9091: DIFF
9092: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9093: LD_VAR 0 1
9097: PPUSH
9098: CALL_OW 257
9102: PUSH
9103: LD_INT 9
9105: EQUAL
9106: IFFALSE 9117
// ComSpaceTimeShoot ( i ) ;
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL 12206 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9117: LD_VAR 0 1
9121: PPUSH
9122: LD_INT 81
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PPUSH
9132: CALL_OW 69
9136: PPUSH
9137: LD_VAR 0 1
9141: PPUSH
9142: CALL_OW 74
9146: PPUSH
9147: CALL_OW 115
// end ;
9151: GO 9049
9153: POP
9154: POP
// until not tmp ;
9155: LD_VAR 0 3
9159: NOT
9160: IFFALSE 9032
// end ; end_of_file
9162: PPOPN 4
9164: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9165: LD_INT 0
9167: PPUSH
9168: PPUSH
9169: PPUSH
9170: PPUSH
// uc_side := 1 ;
9171: LD_ADDR_OWVAR 20
9175: PUSH
9176: LD_INT 1
9178: ST_TO_ADDR
// uc_nation := 1 ;
9179: LD_ADDR_OWVAR 21
9183: PUSH
9184: LD_INT 1
9186: ST_TO_ADDR
// hc_importance := 100 ;
9187: LD_ADDR_OWVAR 32
9191: PUSH
9192: LD_INT 100
9194: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9195: LD_ADDR_OWVAR 26
9199: PUSH
9200: LD_STRING Jeremy Sikorski
9202: ST_TO_ADDR
// hc_gallery := us ;
9203: LD_ADDR_OWVAR 33
9207: PUSH
9208: LD_STRING us
9210: ST_TO_ADDR
// hc_face_number := 19 ;
9211: LD_ADDR_OWVAR 34
9215: PUSH
9216: LD_INT 19
9218: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9219: LD_INT 1
9221: PPUSH
9222: LD_INT 1
9224: PPUSH
9225: LD_INT 4
9227: PUSH
9228: LD_INT 4
9230: PUSH
9231: LD_INT 3
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: LIST
9238: PUSH
9239: LD_OWVAR 67
9243: ARRAY
9244: PPUSH
9245: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9249: LD_ADDR_OWVAR 29
9253: PUSH
9254: LD_INT 10
9256: PUSH
9257: LD_INT 12
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: ST_TO_ADDR
// Sikorski := CreateHuman ;
9264: LD_ADDR_EXP 20
9268: PUSH
9269: CALL_OW 44
9273: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9274: LD_EXP 20
9278: PPUSH
9279: LD_INT 133
9281: PPUSH
9282: LD_INT 19
9284: PPUSH
9285: LD_INT 2
9287: PPUSH
9288: LD_INT 0
9290: PPUSH
9291: CALL_OW 50
// InitHc_All ( ) ;
9295: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9299: LD_ADDR_VAR 0 2
9303: PUSH
9304: DOUBLE
9305: LD_INT 1
9307: DEC
9308: ST_TO_ADDR
9309: LD_INT 4
9311: PUSH
9312: LD_INT 3
9314: PUSH
9315: LD_INT 3
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: PUSH
9323: LD_OWVAR 67
9327: ARRAY
9328: PUSH
9329: FOR_TO
9330: IFFALSE 9446
// for j := 1 to 4 do
9332: LD_ADDR_VAR 0 3
9336: PUSH
9337: DOUBLE
9338: LD_INT 1
9340: DEC
9341: ST_TO_ADDR
9342: LD_INT 4
9344: PUSH
9345: FOR_TO
9346: IFFALSE 9442
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9348: LD_INT 0
9350: PPUSH
9351: LD_VAR 0 3
9355: PPUSH
9356: LD_INT 5
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: LD_INT 3
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: LIST
9369: PUSH
9370: LD_OWVAR 67
9374: ARRAY
9375: PPUSH
9376: CALL_OW 380
// un := CreateHuman ;
9380: LD_ADDR_VAR 0 4
9384: PUSH
9385: CALL_OW 44
9389: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9390: LD_VAR 0 4
9394: PPUSH
9395: LD_INT 0
9397: PPUSH
9398: LD_INT 5
9400: PPUSH
9401: CALL_OW 12
9405: PPUSH
9406: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9410: LD_VAR 0 4
9414: PPUSH
9415: LD_INT 133
9417: PPUSH
9418: LD_INT 19
9420: PPUSH
9421: LD_INT 6
9423: PPUSH
9424: LD_INT 0
9426: PPUSH
9427: CALL_OW 50
// ComHold ( un ) ;
9431: LD_VAR 0 4
9435: PPUSH
9436: CALL_OW 140
// end ;
9440: GO 9345
9442: POP
9443: POP
9444: GO 9329
9446: POP
9447: POP
// vc_chassis := us_heavy_tracked ;
9448: LD_ADDR_OWVAR 37
9452: PUSH
9453: LD_INT 4
9455: ST_TO_ADDR
// vc_engine := engine_combustion ;
9456: LD_ADDR_OWVAR 39
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// vc_control := control_manual ;
9464: LD_ADDR_OWVAR 38
9468: PUSH
9469: LD_INT 1
9471: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9472: LD_ADDR_OWVAR 40
9476: PUSH
9477: LD_INT 14
9479: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9480: LD_ADDR_OWVAR 41
9484: PUSH
9485: LD_INT 60
9487: ST_TO_ADDR
// un := CreateVehicle ;
9488: LD_ADDR_VAR 0 4
9492: PUSH
9493: CALL_OW 45
9497: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9498: LD_VAR 0 4
9502: PPUSH
9503: LD_INT 2
9505: PPUSH
9506: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9510: LD_VAR 0 4
9514: PPUSH
9515: LD_INT 128
9517: PPUSH
9518: LD_INT 12
9520: PPUSH
9521: LD_INT 0
9523: PPUSH
9524: CALL_OW 48
// for i := 1 to 3 do
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: DOUBLE
9534: LD_INT 1
9536: DEC
9537: ST_TO_ADDR
9538: LD_INT 3
9540: PUSH
9541: FOR_TO
9542: IFFALSE 9565
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9544: LD_INT 5
9546: PPUSH
9547: LD_INT 133
9549: PPUSH
9550: LD_INT 19
9552: PPUSH
9553: LD_INT 3
9555: PPUSH
9556: LD_INT 0
9558: PPUSH
9559: CALL_OW 56
9563: GO 9541
9565: POP
9566: POP
// end ; end_of_file
9567: LD_VAR 0 1
9571: RET
// export function Action ; begin
9572: LD_INT 0
9574: PPUSH
// InGameOn ;
9575: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9579: LD_INT 133
9581: PPUSH
9582: LD_INT 19
9584: PPUSH
9585: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9589: LD_EXP 20
9593: PPUSH
9594: LD_STRING WT-DS-1
9596: PPUSH
9597: CALL_OW 88
// InGameOff ;
9601: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9605: LD_STRING DestroyEnemy
9607: PPUSH
9608: CALL_OW 337
// wait ( 0 0$20 ) ;
9612: LD_INT 700
9614: PPUSH
9615: CALL_OW 67
// DialogueOn ;
9619: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9623: LD_INT 100
9625: PPUSH
9626: LD_INT 37
9628: PPUSH
9629: LD_INT 1
9631: PPUSH
9632: LD_INT 30
9634: NEG
9635: PPUSH
9636: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9640: LD_INT 100
9642: PPUSH
9643: LD_INT 37
9645: PPUSH
9646: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9650: LD_EXP 10
9654: PPUSH
9655: LD_STRING WT-PL-1
9657: PPUSH
9658: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9662: LD_EXP 20
9666: PPUSH
9667: LD_STRING WT-DS-2
9669: PPUSH
9670: CALL_OW 88
// DialogueOff ;
9674: CALL_OW 7
// wait ( 0 0$2 ) ;
9678: LD_INT 70
9680: PPUSH
9681: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9685: LD_INT 100
9687: PPUSH
9688: LD_INT 37
9690: PPUSH
9691: LD_INT 1
9693: PPUSH
9694: CALL_OW 331
// end ;
9698: LD_VAR 0 1
9702: RET
// export function DialogPowellsAttack ; begin
9703: LD_INT 0
9705: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9706: LD_EXP 10
9710: PPUSH
9711: LD_STRING WT-PL-8
9713: PPUSH
9714: CALL_OW 94
// end ;
9718: LD_VAR 0 1
9722: RET
// export function DialogContaminateSib ( x , y ) ; begin
9723: LD_INT 0
9725: PPUSH
// DialogueOn ;
9726: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9730: LD_VAR 0 1
9734: PPUSH
9735: LD_VAR 0 2
9739: PPUSH
9740: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9744: LD_EXP 20
9748: PPUSH
9749: LD_STRING WT-DS-3
9751: PPUSH
9752: CALL_OW 88
// DialogueOff ;
9756: CALL_OW 7
// end ;
9760: LD_VAR 0 3
9764: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9765: LD_EXP 8
9769: NOT
9770: IFFALSE 9795
9772: PUSH
9773: LD_INT 1
9775: PPUSH
9776: LD_INT 81
9778: PUSH
9779: LD_INT 4
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 70
9790: PUSH
9791: LD_INT 3
9793: GREATER
9794: AND
9795: IFFALSE 9867
9797: GO 9799
9799: DISABLE
// begin powellInTrouble := true ;
9800: LD_ADDR_EXP 8
9804: PUSH
9805: LD_INT 1
9807: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9808: LD_EXP 20
9812: PPUSH
9813: LD_STRING WT-DS-6
9815: PPUSH
9816: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9820: LD_INT 1
9822: PPUSH
9823: LD_INT 22
9825: PUSH
9826: LD_INT 1
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 70
9837: NOT
9838: IFFALSE 9852
// SayRadio ( Powell , WT-PL-6 ) ;
9840: LD_EXP 10
9844: PPUSH
9845: LD_STRING WT-PL-6
9847: PPUSH
9848: CALL_OW 94
// wait ( 1 1$30 ) ;
9852: LD_INT 3150
9854: PPUSH
9855: CALL_OW 67
// powellInTrouble := false ;
9859: LD_ADDR_EXP 8
9863: PUSH
9864: LD_INT 0
9866: ST_TO_ADDR
// end ;
9867: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9868: LD_EXP 9
9872: NOT
9873: IFFALSE 9898
9875: PUSH
9876: LD_INT 16
9878: PPUSH
9879: LD_INT 81
9881: PUSH
9882: LD_INT 1
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 70
9893: PUSH
9894: LD_INT 6
9896: GREATER
9897: AND
9898: IFFALSE 9971
9900: GO 9902
9902: DISABLE
// begin sikorskiInTrouble := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9911: LD_EXP 20
9915: PPUSH
9916: LD_STRING WT-DS-7
9918: PPUSH
9919: CALL_OW 88
// if not powellAttackGroup then
9923: LD_EXP 12
9927: NOT
9928: IFFALSE 9944
// SayRadio ( Powell , WT-PL-7n ) else
9930: LD_EXP 10
9934: PPUSH
9935: LD_STRING WT-PL-7n
9937: PPUSH
9938: CALL_OW 94
9942: GO 9956
// SayRadio ( Powell , WT-PL-7y ) ;
9944: LD_EXP 10
9948: PPUSH
9949: LD_STRING WT-PL-7y
9951: PPUSH
9952: CALL_OW 94
// wait ( 1 1$30 ) ;
9956: LD_INT 3150
9958: PPUSH
9959: CALL_OW 67
// sikorskiInTrouble := false ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 0
9970: ST_TO_ADDR
// end ;
9971: END
// export function DialogPowellsAttackFailed ; begin
9972: LD_INT 0
9974: PPUSH
// if not ruDestroyed then
9975: LD_EXP 5
9979: NOT
9980: IFFALSE 9996
// SayRadio ( Powell , WT-PL-9 ) else
9982: LD_EXP 10
9986: PPUSH
9987: LD_STRING WT-PL-9
9989: PPUSH
9990: CALL_OW 94
9994: GO 10008
// SayRadio ( Powell , WT-PL-10 ) ;
9996: LD_EXP 10
10000: PPUSH
10001: LD_STRING WT-PL-10
10003: PPUSH
10004: CALL_OW 94
// end ;
10008: LD_VAR 0 1
10012: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10013: LD_INT 22
10015: PUSH
10016: LD_INT 2
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PUSH
10023: LD_INT 21
10025: PUSH
10026: LD_INT 1
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 69
10041: PUSH
10042: LD_INT 0
10044: EQUAL
10045: IFFALSE 10089
10047: GO 10049
10049: DISABLE
// begin arDestroyed := true ;
10050: LD_ADDR_EXP 4
10054: PUSH
10055: LD_INT 1
10057: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10058: LD_INT 2
10060: PPUSH
10061: CALL 54958 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10065: LD_EXP 20
10069: PPUSH
10070: LD_STRING WT-DS-4
10072: PPUSH
10073: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10077: LD_EXP 10
10081: PPUSH
10082: LD_STRING WT-PL-4
10084: PPUSH
10085: CALL_OW 94
// end ;
10089: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10090: LD_INT 22
10092: PUSH
10093: LD_INT 3
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 21
10102: PUSH
10103: LD_INT 1
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PPUSH
10114: CALL_OW 69
10118: PUSH
10119: LD_INT 0
10121: EQUAL
10122: IFFALSE 10166
10124: GO 10126
10126: DISABLE
// begin ruDestroyed := true ;
10127: LD_ADDR_EXP 5
10131: PUSH
10132: LD_INT 1
10134: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10135: LD_INT 3
10137: PPUSH
10138: CALL 54958 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10142: LD_EXP 20
10146: PPUSH
10147: LD_STRING WT-DS-5
10149: PPUSH
10150: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10154: LD_EXP 10
10158: PPUSH
10159: LD_STRING WT-PL-5
10161: PPUSH
10162: CALL_OW 94
// end ;
10166: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10167: LD_EXP 5
10171: IFFALSE 10179
10173: PUSH
10174: LD_EXP 4
10178: AND
10179: IFFALSE 10352
10181: GO 10183
10183: DISABLE
// begin wait ( 0 0$3 ) ;
10184: LD_INT 105
10186: PPUSH
10187: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10191: LD_OWVAR 1
10195: PUSH
10196: LD_INT 126000
10198: PUSH
10199: LD_INT 105000
10201: PUSH
10202: LD_INT 94500
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_OWVAR 67
10214: ARRAY
10215: GREATEREQUAL
10216: IFFALSE 10231
// AddMedal ( WoT-med-1 , - 1 ) else
10218: LD_STRING WoT-med-1
10220: PPUSH
10221: LD_INT 1
10223: NEG
10224: PPUSH
10225: CALL_OW 101
10229: GO 10241
// AddMedal ( WoT-med-1 , 1 ) ;
10231: LD_STRING WoT-med-1
10233: PPUSH
10234: LD_INT 1
10236: PPUSH
10237: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10241: LD_EXP 6
10245: PUSH
10246: LD_INT 4
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 2
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: PUSH
10260: LD_OWVAR 67
10264: ARRAY
10265: GREATEREQUAL
10266: IFFALSE 10281
// AddMedal ( WoT-med-2 , - 1 ) else
10268: LD_STRING WoT-med-2
10270: PPUSH
10271: LD_INT 1
10273: NEG
10274: PPUSH
10275: CALL_OW 101
10279: GO 10291
// AddMedal ( WoT-med-2 , 1 ) ;
10281: LD_STRING WoT-med-2
10283: PPUSH
10284: LD_INT 1
10286: PPUSH
10287: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10291: LD_EXP 7
10295: PUSH
10296: LD_INT 8
10298: PUSH
10299: LD_INT 6
10301: PUSH
10302: LD_INT 5
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: LIST
10309: PUSH
10310: LD_OWVAR 67
10314: ARRAY
10315: GREATEREQUAL
10316: IFFALSE 10331
// AddMedal ( WoT-med-3 , - 1 ) else
10318: LD_STRING WoT-med-3
10320: PPUSH
10321: LD_INT 1
10323: NEG
10324: PPUSH
10325: CALL_OW 101
10329: GO 10341
// AddMedal ( WoT-med-3 , 1 ) ;
10331: LD_STRING WoT-med-3
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 101
// GiveMedals ( MAIN ) ;
10341: LD_STRING MAIN
10343: PPUSH
10344: CALL_OW 102
// YouWin ;
10348: CALL_OW 103
// end ; end_of_file
10352: END
// export function CustomEvent ( event ) ; begin
10353: LD_INT 0
10355: PPUSH
// end ;
10356: LD_VAR 0 2
10360: RET
// on Command ( com ) do var i , j , temp ;
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
10365: PPUSH
// begin if com = 60 then
10366: LD_VAR 0 1
10370: PUSH
10371: LD_INT 60
10373: EQUAL
10374: IFFALSE 10555
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10376: LD_ADDR_VAR 0 2
10380: PUSH
10381: LD_INT 22
10383: PUSH
10384: LD_INT 1
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: LD_INT 2
10393: PUSH
10394: LD_INT 21
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 34
10406: PUSH
10407: LD_INT 12
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PUSH
10414: EMPTY
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: PPUSH
10423: CALL_OW 69
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10553
// begin if GetTaskList ( i ) > 0 then
10431: LD_VAR 0 2
10435: PPUSH
10436: CALL_OW 437
10440: PUSH
10441: LD_INT 0
10443: GREATER
10444: IFFALSE 10551
// for j = 1 to GetTaskList ( i ) do
10446: LD_ADDR_VAR 0 3
10450: PUSH
10451: DOUBLE
10452: LD_INT 1
10454: DEC
10455: ST_TO_ADDR
10456: LD_VAR 0 2
10460: PPUSH
10461: CALL_OW 437
10465: PUSH
10466: FOR_TO
10467: IFFALSE 10549
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10469: LD_ADDR_VAR 0 4
10473: PUSH
10474: LD_VAR 0 2
10478: PPUSH
10479: CALL_OW 437
10483: PUSH
10484: LD_VAR 0 3
10488: ARRAY
10489: PUSH
10490: LD_INT 4
10492: ARRAY
10493: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10494: LD_VAR 0 4
10498: PPUSH
10499: CALL_OW 255
10503: PUSH
10504: LD_INT 4
10506: EQUAL
10507: IFFALSE 10534
10509: PUSH
10510: LD_VAR 0 2
10514: PPUSH
10515: CALL_OW 437
10519: PUSH
10520: LD_VAR 0 3
10524: ARRAY
10525: PUSH
10526: LD_INT 1
10528: ARRAY
10529: PUSH
10530: LD_STRING <
10532: EQUAL
10533: AND
10534: IFFALSE 10547
// SetTaskList ( i , [ ] ) ;
10536: LD_VAR 0 2
10540: PPUSH
10541: EMPTY
10542: PPUSH
10543: CALL_OW 446
// end ;
10547: GO 10466
10549: POP
10550: POP
// end ;
10551: GO 10428
10553: POP
10554: POP
// end ; end ;
10555: PPOPN 4
10557: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10558: LD_VAR 0 2
10562: PPUSH
10563: LD_VAR 0 3
10567: PPUSH
10568: CALL_OW 428
10572: PPUSH
10573: CALL_OW 255
10577: PUSH
10578: LD_INT 1
10580: EQUAL
10581: IFTRUE 10605
10583: PUSH
10584: LD_VAR 0 2
10588: PUSH
10589: LD_INT 132
10591: EQUAL
10592: IFFALSE 10604
10594: PUSH
10595: LD_VAR 0 3
10599: PUSH
10600: LD_INT 39
10602: EQUAL
10603: AND
10604: OR
10605: IFFALSE 10621
// DialogContaminateSib ( x , y ) ;
10607: LD_VAR 0 2
10611: PPUSH
10612: LD_VAR 0 3
10616: PPUSH
10617: CALL 9723 0 2
// end ;
10621: PPOPN 3
10623: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10624: LD_VAR 0 1
10628: PPUSH
10629: CALL 93186 0 1
// MCE_UnitDestroyed ( un ) ;
10633: LD_VAR 0 1
10637: PPUSH
10638: CALL 82745 0 1
// if un = Powell then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_EXP 10
10651: EQUAL
10652: IFFALSE 10661
// YouLost ( Powell ) ;
10654: LD_STRING Powell
10656: PPUSH
10657: CALL_OW 104
// if un = Sikorski then
10661: LD_VAR 0 1
10665: PUSH
10666: LD_EXP 20
10670: EQUAL
10671: IFFALSE 10680
// YouLost ( Sikorski ) ;
10673: LD_STRING Sikorski
10675: PPUSH
10676: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10680: LD_VAR 0 1
10684: PUSH
10685: LD_INT 22
10687: PUSH
10688: LD_INT 1
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PUSH
10695: LD_INT 21
10697: PUSH
10698: LD_INT 1
10700: PUSH
10701: EMPTY
10702: LIST
10703: LIST
10704: PUSH
10705: EMPTY
10706: LIST
10707: LIST
10708: PPUSH
10709: CALL_OW 69
10713: IN
10714: IFFALSE 10730
// loseCounter := loseCounter + 1 ;
10716: LD_ADDR_EXP 6
10720: PUSH
10721: LD_EXP 6
10725: PUSH
10726: LD_INT 1
10728: PLUS
10729: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10730: LD_VAR 0 1
10734: PUSH
10735: LD_INT 22
10737: PUSH
10738: LD_INT 4
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: LD_INT 21
10747: PUSH
10748: LD_INT 1
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: PPUSH
10759: CALL_OW 69
10763: IN
10764: IFFALSE 10780
// powellLoseCounter := powellLoseCounter + 1 ;
10766: LD_ADDR_EXP 7
10770: PUSH
10771: LD_EXP 7
10775: PUSH
10776: LD_INT 1
10778: PLUS
10779: ST_TO_ADDR
// if un in powellAttackGroup then
10780: LD_VAR 0 1
10784: PUSH
10785: LD_EXP 12
10789: IN
10790: IFFALSE 10808
// powellAttackGroup := powellAttackGroup diff un ;
10792: LD_ADDR_EXP 12
10796: PUSH
10797: LD_EXP 12
10801: PUSH
10802: LD_VAR 0 1
10806: DIFF
10807: ST_TO_ADDR
// if un in gensherAttackGroup then
10808: LD_VAR 0 1
10812: PUSH
10813: LD_EXP 15
10817: IN
10818: IFFALSE 10836
// gensherAttackGroup := gensherAttackGroup diff un ;
10820: LD_ADDR_EXP 15
10824: PUSH
10825: LD_EXP 15
10829: PUSH
10830: LD_VAR 0 1
10834: DIFF
10835: ST_TO_ADDR
// if un in popovAttackGroup then
10836: LD_VAR 0 1
10840: PUSH
10841: LD_EXP 19
10845: IN
10846: IFFALSE 10864
// popovAttackGroup := popovAttackGroup diff un ;
10848: LD_ADDR_EXP 19
10852: PUSH
10853: LD_EXP 19
10857: PUSH
10858: LD_VAR 0 1
10862: DIFF
10863: ST_TO_ADDR
// end ;
10864: PPOPN 1
10866: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10867: LD_VAR 0 1
10871: PPUSH
10872: LD_VAR 0 2
10876: PPUSH
10877: CALL 85099 0 2
// end ;
10881: PPOPN 2
10883: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10884: LD_VAR 0 1
10888: PPUSH
10889: CALL 84163 0 1
// end ;
10893: PPOPN 1
10895: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: CALL 84406 0 1
// end ;
10905: PPOPN 1
10907: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_VAR 0 2
10917: PPUSH
10918: CALL 82433 0 2
// end ;
10922: PPOPN 2
10924: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10925: LD_VAR 0 1
10929: PPUSH
10930: LD_VAR 0 2
10934: PPUSH
10935: LD_VAR 0 3
10939: PPUSH
10940: LD_VAR 0 4
10944: PPUSH
10945: LD_VAR 0 5
10949: PPUSH
10950: CALL 82051 0 5
// end ;
10954: PPOPN 5
10956: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 93244 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10971: LD_VAR 0 1
10975: PPUSH
10976: LD_VAR 0 2
10980: PPUSH
10981: CALL 81600 0 2
// end ;
10985: PPOPN 2
10987: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10988: LD_VAR 0 1
10992: PPUSH
10993: LD_VAR 0 2
10997: PPUSH
10998: LD_VAR 0 3
11002: PPUSH
11003: LD_VAR 0 4
11007: PPUSH
11008: CALL 81432 0 4
// end ;
11012: PPOPN 4
11014: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11015: LD_VAR 0 1
11019: PPUSH
11020: LD_VAR 0 2
11024: PPUSH
11025: LD_VAR 0 3
11029: PPUSH
11030: CALL 81205 0 3
// end ;
11034: PPOPN 3
11036: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11037: LD_VAR 0 1
11041: PPUSH
11042: LD_VAR 0 2
11046: PPUSH
11047: CALL 81088 0 2
// end ;
11051: PPOPN 2
11053: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11054: LD_VAR 0 1
11058: PPUSH
11059: LD_VAR 0 2
11063: PPUSH
11064: CALL 85396 0 2
// end ;
11068: PPOPN 2
11070: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11071: LD_VAR 0 1
11075: PPUSH
11076: LD_VAR 0 2
11080: PPUSH
11081: LD_VAR 0 3
11085: PPUSH
11086: LD_VAR 0 4
11090: PPUSH
11091: CALL 85620 0 4
// end ;
11095: PPOPN 4
11097: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11098: LD_VAR 0 1
11102: PPUSH
11103: LD_VAR 0 2
11107: PPUSH
11108: CALL 80895 0 2
// end ;
11112: PPOPN 2
11114: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11115: LD_VAR 0 1
11119: PUSH
11120: LD_INT 1
11122: EQUAL
11123: IFFALSE 11135
11125: PUSH
11126: LD_VAR 0 2
11130: PUSH
11131: LD_INT 4
11133: EQUAL
11134: AND
11135: IFFALSE 11144
// YouLost ( FriendlyFire ) ;
11137: LD_STRING FriendlyFire
11139: PPUSH
11140: CALL_OW 104
// end ; end_of_file
11144: PPOPN 2
11146: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11147: LD_INT 0
11149: PPUSH
11150: PPUSH
// if exist_mode then
11151: LD_VAR 0 2
11155: IFFALSE 11201
// begin unit := CreateCharacter ( prefix & ident ) ;
11157: LD_ADDR_VAR 0 5
11161: PUSH
11162: LD_VAR 0 3
11166: PUSH
11167: LD_VAR 0 1
11171: STR
11172: PPUSH
11173: CALL_OW 34
11177: ST_TO_ADDR
// if unit then
11178: LD_VAR 0 5
11182: IFFALSE 11199
// DeleteCharacters ( prefix & ident ) ;
11184: LD_VAR 0 3
11188: PUSH
11189: LD_VAR 0 1
11193: STR
11194: PPUSH
11195: CALL_OW 40
// end else
11199: GO 11216
// unit := NewCharacter ( ident ) ;
11201: LD_ADDR_VAR 0 5
11205: PUSH
11206: LD_VAR 0 1
11210: PPUSH
11211: CALL_OW 25
11215: ST_TO_ADDR
// result := unit ;
11216: LD_ADDR_VAR 0 4
11220: PUSH
11221: LD_VAR 0 5
11225: ST_TO_ADDR
// end ;
11226: LD_VAR 0 4
11230: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// if exist_mode then
11235: LD_VAR 0 2
11239: IFFALSE 11264
// unit := CreateCharacter ( prefix & ident ) else
11241: LD_ADDR_VAR 0 5
11245: PUSH
11246: LD_VAR 0 3
11250: PUSH
11251: LD_VAR 0 1
11255: STR
11256: PPUSH
11257: CALL_OW 34
11261: ST_TO_ADDR
11262: GO 11279
// unit := NewCharacter ( ident ) ;
11264: LD_ADDR_VAR 0 5
11268: PUSH
11269: LD_VAR 0 1
11273: PPUSH
11274: CALL_OW 25
11278: ST_TO_ADDR
// result := unit ;
11279: LD_ADDR_VAR 0 4
11283: PUSH
11284: LD_VAR 0 5
11288: ST_TO_ADDR
// end ;
11289: LD_VAR 0 4
11293: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11294: LD_INT 0
11296: PPUSH
11297: PPUSH
// if not side or not nation then
11298: LD_VAR 0 1
11302: NOT
11303: IFTRUE 11312
11305: PUSH
11306: LD_VAR 0 2
11310: NOT
11311: OR
11312: IFFALSE 11316
// exit ;
11314: GO 12110
// case nation of nation_american :
11316: LD_VAR 0 2
11320: PUSH
11321: LD_INT 1
11323: DOUBLE
11324: EQUAL
11325: IFTRUE 11329
11327: GO 11551
11329: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
11330: LD_ADDR_VAR 0 4
11334: PUSH
11335: LD_INT 35
11337: PUSH
11338: LD_INT 45
11340: PUSH
11341: LD_INT 46
11343: PUSH
11344: LD_INT 47
11346: PUSH
11347: LD_INT 82
11349: PUSH
11350: LD_INT 83
11352: PUSH
11353: LD_INT 84
11355: PUSH
11356: LD_INT 85
11358: PUSH
11359: LD_INT 86
11361: PUSH
11362: LD_INT 1
11364: PUSH
11365: LD_INT 2
11367: PUSH
11368: LD_INT 6
11370: PUSH
11371: LD_INT 15
11373: PUSH
11374: LD_INT 16
11376: PUSH
11377: LD_INT 7
11379: PUSH
11380: LD_INT 12
11382: PUSH
11383: LD_INT 13
11385: PUSH
11386: LD_INT 10
11388: PUSH
11389: LD_INT 14
11391: PUSH
11392: LD_INT 20
11394: PUSH
11395: LD_INT 21
11397: PUSH
11398: LD_INT 22
11400: PUSH
11401: LD_INT 25
11403: PUSH
11404: LD_INT 32
11406: PUSH
11407: LD_INT 27
11409: PUSH
11410: LD_INT 36
11412: PUSH
11413: LD_INT 69
11415: PUSH
11416: LD_INT 39
11418: PUSH
11419: LD_INT 34
11421: PUSH
11422: LD_INT 40
11424: PUSH
11425: LD_INT 48
11427: PUSH
11428: LD_INT 49
11430: PUSH
11431: LD_INT 50
11433: PUSH
11434: LD_INT 51
11436: PUSH
11437: LD_INT 52
11439: PUSH
11440: LD_INT 53
11442: PUSH
11443: LD_INT 54
11445: PUSH
11446: LD_INT 55
11448: PUSH
11449: LD_INT 56
11451: PUSH
11452: LD_INT 57
11454: PUSH
11455: LD_INT 58
11457: PUSH
11458: LD_INT 59
11460: PUSH
11461: LD_INT 60
11463: PUSH
11464: LD_INT 61
11466: PUSH
11467: LD_INT 62
11469: PUSH
11470: LD_INT 80
11472: PUSH
11473: LD_INT 82
11475: PUSH
11476: LD_INT 83
11478: PUSH
11479: LD_INT 84
11481: PUSH
11482: LD_INT 85
11484: PUSH
11485: LD_INT 86
11487: PUSH
11488: LD_INT 90
11490: PUSH
11491: LD_INT 93
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
11549: GO 12032
11551: LD_INT 2
11553: DOUBLE
11554: EQUAL
11555: IFTRUE 11559
11557: GO 11793
11559: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
11560: LD_ADDR_VAR 0 4
11564: PUSH
11565: LD_INT 35
11567: PUSH
11568: LD_INT 45
11570: PUSH
11571: LD_INT 46
11573: PUSH
11574: LD_INT 47
11576: PUSH
11577: LD_INT 82
11579: PUSH
11580: LD_INT 83
11582: PUSH
11583: LD_INT 84
11585: PUSH
11586: LD_INT 85
11588: PUSH
11589: LD_INT 87
11591: PUSH
11592: LD_INT 70
11594: PUSH
11595: LD_INT 1
11597: PUSH
11598: LD_INT 11
11600: PUSH
11601: LD_INT 3
11603: PUSH
11604: LD_INT 4
11606: PUSH
11607: LD_INT 5
11609: PUSH
11610: LD_INT 6
11612: PUSH
11613: LD_INT 15
11615: PUSH
11616: LD_INT 18
11618: PUSH
11619: LD_INT 7
11621: PUSH
11622: LD_INT 17
11624: PUSH
11625: LD_INT 8
11627: PUSH
11628: LD_INT 20
11630: PUSH
11631: LD_INT 21
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_INT 72
11639: PUSH
11640: LD_INT 26
11642: PUSH
11643: LD_INT 69
11645: PUSH
11646: LD_INT 39
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 41
11654: PUSH
11655: LD_INT 42
11657: PUSH
11658: LD_INT 43
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 60
11690: PUSH
11691: LD_INT 61
11693: PUSH
11694: LD_INT 62
11696: PUSH
11697: LD_INT 66
11699: PUSH
11700: LD_INT 67
11702: PUSH
11703: LD_INT 68
11705: PUSH
11706: LD_INT 81
11708: PUSH
11709: LD_INT 82
11711: PUSH
11712: LD_INT 83
11714: PUSH
11715: LD_INT 84
11717: PUSH
11718: LD_INT 85
11720: PUSH
11721: LD_INT 87
11723: PUSH
11724: LD_INT 88
11726: PUSH
11727: LD_INT 92
11729: PUSH
11730: LD_INT 94
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: ST_TO_ADDR
11791: GO 12032
11793: LD_INT 3
11795: DOUBLE
11796: EQUAL
11797: IFTRUE 11801
11799: GO 12031
11801: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
11802: LD_ADDR_VAR 0 4
11806: PUSH
11807: LD_INT 46
11809: PUSH
11810: LD_INT 47
11812: PUSH
11813: LD_INT 1
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: LD_INT 82
11821: PUSH
11822: LD_INT 83
11824: PUSH
11825: LD_INT 84
11827: PUSH
11828: LD_INT 85
11830: PUSH
11831: LD_INT 86
11833: PUSH
11834: LD_INT 11
11836: PUSH
11837: LD_INT 9
11839: PUSH
11840: LD_INT 20
11842: PUSH
11843: LD_INT 19
11845: PUSH
11846: LD_INT 21
11848: PUSH
11849: LD_INT 24
11851: PUSH
11852: LD_INT 22
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 28
11860: PUSH
11861: LD_INT 29
11863: PUSH
11864: LD_INT 30
11866: PUSH
11867: LD_INT 31
11869: PUSH
11870: LD_INT 37
11872: PUSH
11873: LD_INT 38
11875: PUSH
11876: LD_INT 32
11878: PUSH
11879: LD_INT 27
11881: PUSH
11882: LD_INT 33
11884: PUSH
11885: LD_INT 69
11887: PUSH
11888: LD_INT 39
11890: PUSH
11891: LD_INT 34
11893: PUSH
11894: LD_INT 40
11896: PUSH
11897: LD_INT 71
11899: PUSH
11900: LD_INT 23
11902: PUSH
11903: LD_INT 44
11905: PUSH
11906: LD_INT 48
11908: PUSH
11909: LD_INT 49
11911: PUSH
11912: LD_INT 50
11914: PUSH
11915: LD_INT 51
11917: PUSH
11918: LD_INT 52
11920: PUSH
11921: LD_INT 53
11923: PUSH
11924: LD_INT 54
11926: PUSH
11927: LD_INT 55
11929: PUSH
11930: LD_INT 56
11932: PUSH
11933: LD_INT 57
11935: PUSH
11936: LD_INT 58
11938: PUSH
11939: LD_INT 59
11941: PUSH
11942: LD_INT 63
11944: PUSH
11945: LD_INT 64
11947: PUSH
11948: LD_INT 65
11950: PUSH
11951: LD_INT 82
11953: PUSH
11954: LD_INT 83
11956: PUSH
11957: LD_INT 84
11959: PUSH
11960: LD_INT 85
11962: PUSH
11963: LD_INT 86
11965: PUSH
11966: LD_INT 89
11968: PUSH
11969: LD_INT 91
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: LIST
12028: ST_TO_ADDR
12029: GO 12032
12031: POP
// if state > - 1 and state < 3 then
12032: LD_VAR 0 3
12036: PUSH
12037: LD_INT 1
12039: NEG
12040: GREATER
12041: IFFALSE 12053
12043: PUSH
12044: LD_VAR 0 3
12048: PUSH
12049: LD_INT 3
12051: LESS
12052: AND
12053: IFFALSE 12110
// for i in result do
12055: LD_ADDR_VAR 0 5
12059: PUSH
12060: LD_VAR 0 4
12064: PUSH
12065: FOR_IN
12066: IFFALSE 12108
// if GetTech ( i , side ) <> state then
12068: LD_VAR 0 5
12072: PPUSH
12073: LD_VAR 0 1
12077: PPUSH
12078: CALL_OW 321
12082: PUSH
12083: LD_VAR 0 3
12087: NONEQUAL
12088: IFFALSE 12106
// result := result diff i ;
12090: LD_ADDR_VAR 0 4
12094: PUSH
12095: LD_VAR 0 4
12099: PUSH
12100: LD_VAR 0 5
12104: DIFF
12105: ST_TO_ADDR
12106: GO 12065
12108: POP
12109: POP
// end ;
12110: LD_VAR 0 4
12114: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
12115: LD_INT 0
12117: PPUSH
12118: PPUSH
12119: PPUSH
// result := true ;
12120: LD_ADDR_VAR 0 3
12124: PUSH
12125: LD_INT 1
12127: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
12128: LD_ADDR_VAR 0 5
12132: PUSH
12133: LD_VAR 0 2
12137: PPUSH
12138: CALL_OW 480
12142: ST_TO_ADDR
// if not tmp then
12143: LD_VAR 0 5
12147: NOT
12148: IFFALSE 12152
// exit ;
12150: GO 12201
// for i in tmp do
12152: LD_ADDR_VAR 0 4
12156: PUSH
12157: LD_VAR 0 5
12161: PUSH
12162: FOR_IN
12163: IFFALSE 12199
// if GetTech ( i , side ) <> state_researched then
12165: LD_VAR 0 4
12169: PPUSH
12170: LD_VAR 0 1
12174: PPUSH
12175: CALL_OW 321
12179: PUSH
12180: LD_INT 2
12182: NONEQUAL
12183: IFFALSE 12197
// begin result := false ;
12185: LD_ADDR_VAR 0 3
12189: PUSH
12190: LD_INT 0
12192: ST_TO_ADDR
// exit ;
12193: POP
12194: POP
12195: GO 12201
// end ;
12197: GO 12162
12199: POP
12200: POP
// end ;
12201: LD_VAR 0 3
12205: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12206: LD_INT 0
12208: PPUSH
12209: PPUSH
12210: PPUSH
12211: PPUSH
12212: PPUSH
12213: PPUSH
12214: PPUSH
12215: PPUSH
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12221: LD_VAR 0 1
12225: NOT
12226: IFTRUE 12243
12228: PUSH
12229: LD_VAR 0 1
12233: PPUSH
12234: CALL_OW 257
12238: PUSH
12239: LD_INT 9
12241: NONEQUAL
12242: OR
12243: IFFALSE 12247
// exit ;
12245: GO 12826
// side := GetSide ( unit ) ;
12247: LD_ADDR_VAR 0 9
12251: PUSH
12252: LD_VAR 0 1
12256: PPUSH
12257: CALL_OW 255
12261: ST_TO_ADDR
// tech_space := tech_spacanom ;
12262: LD_ADDR_VAR 0 12
12266: PUSH
12267: LD_INT 29
12269: ST_TO_ADDR
// tech_time := tech_taurad ;
12270: LD_ADDR_VAR 0 13
12274: PUSH
12275: LD_INT 28
12277: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12278: LD_ADDR_VAR 0 11
12282: PUSH
12283: LD_VAR 0 1
12287: PPUSH
12288: CALL_OW 310
12292: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12293: LD_VAR 0 11
12297: PPUSH
12298: CALL_OW 247
12302: PUSH
12303: LD_INT 2
12305: EQUAL
12306: IFFALSE 12310
// exit ;
12308: GO 12826
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12310: LD_ADDR_VAR 0 8
12314: PUSH
12315: LD_INT 81
12317: PUSH
12318: LD_VAR 0 9
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: PUSH
12327: LD_INT 3
12329: PUSH
12330: LD_INT 21
12332: PUSH
12333: LD_INT 3
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PPUSH
12348: CALL_OW 69
12352: ST_TO_ADDR
// if not tmp then
12353: LD_VAR 0 8
12357: NOT
12358: IFFALSE 12362
// exit ;
12360: GO 12826
// if in_unit then
12362: LD_VAR 0 11
12366: IFFALSE 12390
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12368: LD_ADDR_VAR 0 10
12372: PUSH
12373: LD_VAR 0 8
12377: PPUSH
12378: LD_VAR 0 11
12382: PPUSH
12383: CALL_OW 74
12387: ST_TO_ADDR
12388: GO 12410
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12390: LD_ADDR_VAR 0 10
12394: PUSH
12395: LD_VAR 0 8
12399: PPUSH
12400: LD_VAR 0 1
12404: PPUSH
12405: CALL_OW 74
12409: ST_TO_ADDR
// if not enemy then
12410: LD_VAR 0 10
12414: NOT
12415: IFFALSE 12419
// exit ;
12417: GO 12826
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12419: LD_VAR 0 11
12423: IFFALSE 12445
12425: PUSH
12426: LD_VAR 0 11
12430: PPUSH
12431: LD_VAR 0 10
12435: PPUSH
12436: CALL_OW 296
12440: PUSH
12441: LD_INT 13
12443: GREATER
12444: AND
12445: IFTRUE 12467
12447: PUSH
12448: LD_VAR 0 1
12452: PPUSH
12453: LD_VAR 0 10
12457: PPUSH
12458: CALL_OW 296
12462: PUSH
12463: LD_INT 12
12465: GREATER
12466: OR
12467: IFFALSE 12471
// exit ;
12469: GO 12826
// missile := [ 1 ] ;
12471: LD_ADDR_VAR 0 14
12475: PUSH
12476: LD_INT 1
12478: PUSH
12479: EMPTY
12480: LIST
12481: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12482: LD_VAR 0 9
12486: PPUSH
12487: LD_VAR 0 12
12491: PPUSH
12492: CALL_OW 325
12496: IFFALSE 12525
// missile := Replace ( missile , missile + 1 , 2 ) ;
12498: LD_ADDR_VAR 0 14
12502: PUSH
12503: LD_VAR 0 14
12507: PPUSH
12508: LD_VAR 0 14
12512: PUSH
12513: LD_INT 1
12515: PLUS
12516: PPUSH
12517: LD_INT 2
12519: PPUSH
12520: CALL_OW 1
12524: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12525: LD_VAR 0 9
12529: PPUSH
12530: LD_VAR 0 13
12534: PPUSH
12535: CALL_OW 325
12539: IFFALSE 12563
12541: PUSH
12542: LD_VAR 0 10
12546: PPUSH
12547: CALL_OW 255
12551: PPUSH
12552: LD_VAR 0 13
12556: PPUSH
12557: CALL_OW 325
12561: NOT
12562: AND
12563: IFFALSE 12592
// missile := Replace ( missile , missile + 1 , 3 ) ;
12565: LD_ADDR_VAR 0 14
12569: PUSH
12570: LD_VAR 0 14
12574: PPUSH
12575: LD_VAR 0 14
12579: PUSH
12580: LD_INT 1
12582: PLUS
12583: PPUSH
12584: LD_INT 3
12586: PPUSH
12587: CALL_OW 1
12591: ST_TO_ADDR
// if missile < 2 then
12592: LD_VAR 0 14
12596: PUSH
12597: LD_INT 2
12599: LESS
12600: IFFALSE 12604
// exit ;
12602: GO 12826
// x := GetX ( enemy ) ;
12604: LD_ADDR_VAR 0 4
12608: PUSH
12609: LD_VAR 0 10
12613: PPUSH
12614: CALL_OW 250
12618: ST_TO_ADDR
// y := GetY ( enemy ) ;
12619: LD_ADDR_VAR 0 5
12623: PUSH
12624: LD_VAR 0 10
12628: PPUSH
12629: CALL_OW 251
12633: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12634: LD_ADDR_VAR 0 6
12638: PUSH
12639: LD_VAR 0 4
12643: PUSH
12644: LD_INT 1
12646: NEG
12647: PPUSH
12648: LD_INT 1
12650: PPUSH
12651: CALL_OW 12
12655: PLUS
12656: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12657: LD_ADDR_VAR 0 7
12661: PUSH
12662: LD_VAR 0 5
12666: PUSH
12667: LD_INT 1
12669: NEG
12670: PPUSH
12671: LD_INT 1
12673: PPUSH
12674: CALL_OW 12
12678: PLUS
12679: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12680: LD_VAR 0 6
12684: PPUSH
12685: LD_VAR 0 7
12689: PPUSH
12690: CALL_OW 488
12694: NOT
12695: IFFALSE 12717
// begin _x := x ;
12697: LD_ADDR_VAR 0 6
12701: PUSH
12702: LD_VAR 0 4
12706: ST_TO_ADDR
// _y := y ;
12707: LD_ADDR_VAR 0 7
12711: PUSH
12712: LD_VAR 0 5
12716: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_INT 1
12724: PPUSH
12725: LD_VAR 0 14
12729: PPUSH
12730: CALL_OW 12
12734: ST_TO_ADDR
// case i of 1 :
12735: LD_VAR 0 3
12739: PUSH
12740: LD_INT 1
12742: DOUBLE
12743: EQUAL
12744: IFTRUE 12748
12746: GO 12765
12748: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12749: LD_VAR 0 1
12753: PPUSH
12754: LD_VAR 0 10
12758: PPUSH
12759: CALL_OW 115
12763: GO 12826
12765: LD_INT 2
12767: DOUBLE
12768: EQUAL
12769: IFTRUE 12773
12771: GO 12795
12773: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12774: LD_VAR 0 1
12778: PPUSH
12779: LD_VAR 0 6
12783: PPUSH
12784: LD_VAR 0 7
12788: PPUSH
12789: CALL_OW 153
12793: GO 12826
12795: LD_INT 3
12797: DOUBLE
12798: EQUAL
12799: IFTRUE 12803
12801: GO 12825
12803: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 6
12813: PPUSH
12814: LD_VAR 0 7
12818: PPUSH
12819: CALL_OW 154
12823: GO 12826
12825: POP
// end ;
12826: LD_VAR 0 2
12830: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12831: LD_INT 0
12833: PPUSH
12834: PPUSH
12835: PPUSH
12836: PPUSH
12837: PPUSH
12838: PPUSH
// if not unit or not building then
12839: LD_VAR 0 1
12843: NOT
12844: IFTRUE 12853
12846: PUSH
12847: LD_VAR 0 2
12851: NOT
12852: OR
12853: IFFALSE 12857
// exit ;
12855: GO 13015
// x := GetX ( building ) ;
12857: LD_ADDR_VAR 0 5
12861: PUSH
12862: LD_VAR 0 2
12866: PPUSH
12867: CALL_OW 250
12871: ST_TO_ADDR
// y := GetY ( building ) ;
12872: LD_ADDR_VAR 0 6
12876: PUSH
12877: LD_VAR 0 2
12881: PPUSH
12882: CALL_OW 251
12886: ST_TO_ADDR
// for i := 0 to 5 do
12887: LD_ADDR_VAR 0 4
12891: PUSH
12892: DOUBLE
12893: LD_INT 0
12895: DEC
12896: ST_TO_ADDR
12897: LD_INT 5
12899: PUSH
12900: FOR_TO
12901: IFFALSE 13013
// begin _x := ShiftX ( x , i , 3 ) ;
12903: LD_ADDR_VAR 0 7
12907: PUSH
12908: LD_VAR 0 5
12912: PPUSH
12913: LD_VAR 0 4
12917: PPUSH
12918: LD_INT 3
12920: PPUSH
12921: CALL_OW 272
12925: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12926: LD_ADDR_VAR 0 8
12930: PUSH
12931: LD_VAR 0 6
12935: PPUSH
12936: LD_VAR 0 4
12940: PPUSH
12941: LD_INT 3
12943: PPUSH
12944: CALL_OW 273
12948: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12949: LD_VAR 0 7
12953: PPUSH
12954: LD_VAR 0 8
12958: PPUSH
12959: CALL_OW 488
12963: NOT
12964: IFFALSE 12968
// continue ;
12966: GO 12900
// if HexInfo ( _x , _y ) = 0 then
12968: LD_VAR 0 7
12972: PPUSH
12973: LD_VAR 0 8
12977: PPUSH
12978: CALL_OW 428
12982: PUSH
12983: LD_INT 0
12985: EQUAL
12986: IFFALSE 13011
// begin ComMoveXY ( unit , _x , _y ) ;
12988: LD_VAR 0 1
12992: PPUSH
12993: LD_VAR 0 7
12997: PPUSH
12998: LD_VAR 0 8
13002: PPUSH
13003: CALL_OW 111
// exit ;
13007: POP
13008: POP
13009: GO 13015
// end ; end ;
13011: GO 12900
13013: POP
13014: POP
// end ;
13015: LD_VAR 0 3
13019: RET
// export function ScanBase ( side , base_area ) ; begin
13020: LD_INT 0
13022: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
13023: LD_ADDR_VAR 0 3
13027: PUSH
13028: LD_VAR 0 2
13032: PPUSH
13033: LD_INT 81
13035: PUSH
13036: LD_VAR 0 1
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 70
13049: ST_TO_ADDR
// end ;
13050: LD_VAR 0 3
13054: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
13055: LD_INT 0
13057: PPUSH
13058: PPUSH
13059: PPUSH
13060: PPUSH
// result := false ;
13061: LD_ADDR_VAR 0 2
13065: PUSH
13066: LD_INT 0
13068: ST_TO_ADDR
// side := GetSide ( unit ) ;
13069: LD_ADDR_VAR 0 3
13073: PUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 255
13083: ST_TO_ADDR
// nat := GetNation ( unit ) ;
13084: LD_ADDR_VAR 0 4
13088: PUSH
13089: LD_VAR 0 1
13093: PPUSH
13094: CALL_OW 248
13098: ST_TO_ADDR
// case nat of 1 :
13099: LD_VAR 0 4
13103: PUSH
13104: LD_INT 1
13106: DOUBLE
13107: EQUAL
13108: IFTRUE 13112
13110: GO 13123
13112: POP
// tech := tech_lassight ; 2 :
13113: LD_ADDR_VAR 0 5
13117: PUSH
13118: LD_INT 12
13120: ST_TO_ADDR
13121: GO 13162
13123: LD_INT 2
13125: DOUBLE
13126: EQUAL
13127: IFTRUE 13131
13129: GO 13142
13131: POP
// tech := tech_mortar ; 3 :
13132: LD_ADDR_VAR 0 5
13136: PUSH
13137: LD_INT 41
13139: ST_TO_ADDR
13140: GO 13162
13142: LD_INT 3
13144: DOUBLE
13145: EQUAL
13146: IFTRUE 13150
13148: GO 13161
13150: POP
// tech := tech_bazooka ; end ;
13151: LD_ADDR_VAR 0 5
13155: PUSH
13156: LD_INT 44
13158: ST_TO_ADDR
13159: GO 13162
13161: POP
// if Researched ( side , tech ) then
13162: LD_VAR 0 3
13166: PPUSH
13167: LD_VAR 0 5
13171: PPUSH
13172: CALL_OW 325
13176: IFFALSE 13203
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13178: LD_ADDR_VAR 0 2
13182: PUSH
13183: LD_INT 5
13185: PUSH
13186: LD_INT 8
13188: PUSH
13189: LD_INT 9
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: LIST
13196: PUSH
13197: LD_VAR 0 4
13201: ARRAY
13202: ST_TO_ADDR
// end ;
13203: LD_VAR 0 2
13207: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13208: LD_INT 0
13210: PPUSH
13211: PPUSH
13212: PPUSH
// if not mines then
13213: LD_VAR 0 2
13217: NOT
13218: IFFALSE 13222
// exit ;
13220: GO 13366
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13222: LD_ADDR_VAR 0 5
13226: PUSH
13227: LD_INT 81
13229: PUSH
13230: LD_VAR 0 1
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 3
13241: PUSH
13242: LD_INT 21
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: PPUSH
13260: CALL_OW 69
13264: ST_TO_ADDR
// for i in mines do
13265: LD_ADDR_VAR 0 4
13269: PUSH
13270: LD_VAR 0 2
13274: PUSH
13275: FOR_IN
13276: IFFALSE 13364
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13278: LD_VAR 0 4
13282: PUSH
13283: LD_INT 1
13285: ARRAY
13286: PPUSH
13287: LD_VAR 0 4
13291: PUSH
13292: LD_INT 2
13294: ARRAY
13295: PPUSH
13296: CALL_OW 458
13300: NOT
13301: IFFALSE 13305
// continue ;
13303: GO 13275
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13305: LD_VAR 0 4
13309: PUSH
13310: LD_INT 1
13312: ARRAY
13313: PPUSH
13314: LD_VAR 0 4
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PPUSH
13323: CALL_OW 428
13327: PUSH
13328: LD_VAR 0 5
13332: IN
13333: IFFALSE 13362
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13335: LD_VAR 0 4
13339: PUSH
13340: LD_INT 1
13342: ARRAY
13343: PPUSH
13344: LD_VAR 0 4
13348: PUSH
13349: LD_INT 2
13351: ARRAY
13352: PPUSH
13353: LD_VAR 0 1
13357: PPUSH
13358: CALL_OW 456
// end ;
13362: GO 13275
13364: POP
13365: POP
// end ;
13366: LD_VAR 0 3
13370: RET
// export function Count ( array ) ; begin
13371: LD_INT 0
13373: PPUSH
// result := array + 0 ;
13374: LD_ADDR_VAR 0 2
13378: PUSH
13379: LD_VAR 0 1
13383: PUSH
13384: LD_INT 0
13386: PLUS
13387: ST_TO_ADDR
// end ;
13388: LD_VAR 0 2
13392: RET
// export function IsEmpty ( building ) ; begin
13393: LD_INT 0
13395: PPUSH
// if not building then
13396: LD_VAR 0 1
13400: NOT
13401: IFFALSE 13405
// exit ;
13403: GO 13448
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13405: LD_ADDR_VAR 0 2
13409: PUSH
13410: LD_VAR 0 1
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_VAR 0 1
13422: PPUSH
13423: CALL_OW 255
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 58
13434: PUSH
13435: EMPTY
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PPUSH
13442: CALL_OW 69
13446: IN
13447: ST_TO_ADDR
// end ;
13448: LD_VAR 0 2
13452: RET
// export function IsNotFull ( building ) ; var places ; begin
13453: LD_INT 0
13455: PPUSH
13456: PPUSH
// if not building then
13457: LD_VAR 0 1
13461: NOT
13462: IFFALSE 13466
// exit ;
13464: GO 13494
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
13466: LD_ADDR_VAR 0 2
13470: PUSH
13471: LD_VAR 0 1
13475: PPUSH
13476: LD_INT 3
13478: PUSH
13479: LD_INT 62
13481: PUSH
13482: EMPTY
13483: LIST
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PPUSH
13489: CALL_OW 72
13493: ST_TO_ADDR
// end ;
13494: LD_VAR 0 2
13498: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13499: LD_INT 0
13501: PPUSH
13502: PPUSH
13503: PPUSH
13504: PPUSH
// tmp := [ ] ;
13505: LD_ADDR_VAR 0 3
13509: PUSH
13510: EMPTY
13511: ST_TO_ADDR
// list := [ ] ;
13512: LD_ADDR_VAR 0 5
13516: PUSH
13517: EMPTY
13518: ST_TO_ADDR
// for i = 16 to 25 do
13519: LD_ADDR_VAR 0 4
13523: PUSH
13524: DOUBLE
13525: LD_INT 16
13527: DEC
13528: ST_TO_ADDR
13529: LD_INT 25
13531: PUSH
13532: FOR_TO
13533: IFFALSE 13606
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13535: LD_ADDR_VAR 0 3
13539: PUSH
13540: LD_VAR 0 3
13544: PUSH
13545: LD_INT 22
13547: PUSH
13548: LD_VAR 0 1
13552: PPUSH
13553: CALL_OW 255
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 91
13564: PUSH
13565: LD_VAR 0 1
13569: PUSH
13570: LD_INT 6
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 30
13580: PUSH
13581: LD_VAR 0 4
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: LIST
13594: PUSH
13595: EMPTY
13596: LIST
13597: PPUSH
13598: CALL_OW 69
13602: ADD
13603: ST_TO_ADDR
13604: GO 13532
13606: POP
13607: POP
// for i = 1 to tmp do
13608: LD_ADDR_VAR 0 4
13612: PUSH
13613: DOUBLE
13614: LD_INT 1
13616: DEC
13617: ST_TO_ADDR
13618: LD_VAR 0 3
13622: PUSH
13623: FOR_TO
13624: IFFALSE 13712
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13626: LD_ADDR_VAR 0 5
13630: PUSH
13631: LD_VAR 0 5
13635: PUSH
13636: LD_VAR 0 3
13640: PUSH
13641: LD_VAR 0 4
13645: ARRAY
13646: PPUSH
13647: CALL_OW 266
13651: PUSH
13652: LD_VAR 0 3
13656: PUSH
13657: LD_VAR 0 4
13661: ARRAY
13662: PPUSH
13663: CALL_OW 250
13667: PUSH
13668: LD_VAR 0 3
13672: PUSH
13673: LD_VAR 0 4
13677: ARRAY
13678: PPUSH
13679: CALL_OW 251
13683: PUSH
13684: LD_VAR 0 3
13688: PUSH
13689: LD_VAR 0 4
13693: ARRAY
13694: PPUSH
13695: CALL_OW 254
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: PUSH
13706: EMPTY
13707: LIST
13708: ADD
13709: ST_TO_ADDR
13710: GO 13623
13712: POP
13713: POP
// result := list ;
13714: LD_ADDR_VAR 0 2
13718: PUSH
13719: LD_VAR 0 5
13723: ST_TO_ADDR
// end ;
13724: LD_VAR 0 2
13728: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13729: LD_INT 0
13731: PPUSH
13732: PPUSH
13733: PPUSH
13734: PPUSH
13735: PPUSH
13736: PPUSH
13737: PPUSH
// if not factory then
13738: LD_VAR 0 1
13742: NOT
13743: IFFALSE 13747
// exit ;
13745: GO 14350
// if control = control_apeman then
13747: LD_VAR 0 4
13751: PUSH
13752: LD_INT 5
13754: EQUAL
13755: IFFALSE 13864
// begin tmp := UnitsInside ( factory ) ;
13757: LD_ADDR_VAR 0 8
13761: PUSH
13762: LD_VAR 0 1
13766: PPUSH
13767: CALL_OW 313
13771: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13772: LD_VAR 0 8
13776: PPUSH
13777: LD_INT 25
13779: PUSH
13780: LD_INT 12
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: PPUSH
13787: CALL_OW 72
13791: NOT
13792: IFFALSE 13802
// control := control_manual ;
13794: LD_ADDR_VAR 0 4
13798: PUSH
13799: LD_INT 1
13801: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13802: LD_ADDR_VAR 0 8
13806: PUSH
13807: LD_VAR 0 1
13811: PPUSH
13812: CALL 13499 0 1
13816: ST_TO_ADDR
// if tmp then
13817: LD_VAR 0 8
13821: IFFALSE 13864
// begin for i in tmp do
13823: LD_ADDR_VAR 0 7
13827: PUSH
13828: LD_VAR 0 8
13832: PUSH
13833: FOR_IN
13834: IFFALSE 13862
// if i [ 1 ] = b_ext_radio then
13836: LD_VAR 0 7
13840: PUSH
13841: LD_INT 1
13843: ARRAY
13844: PUSH
13845: LD_INT 22
13847: EQUAL
13848: IFFALSE 13860
// begin control := control_remote ;
13850: LD_ADDR_VAR 0 4
13854: PUSH
13855: LD_INT 2
13857: ST_TO_ADDR
// break ;
13858: GO 13862
// end ;
13860: GO 13833
13862: POP
13863: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13864: LD_VAR 0 1
13868: PPUSH
13869: LD_VAR 0 2
13873: PPUSH
13874: LD_VAR 0 3
13878: PPUSH
13879: LD_VAR 0 4
13883: PPUSH
13884: LD_VAR 0 5
13888: PPUSH
13889: CALL_OW 448
13893: IFFALSE 13928
// begin result := [ chassis , engine , control , weapon ] ;
13895: LD_ADDR_VAR 0 6
13899: PUSH
13900: LD_VAR 0 2
13904: PUSH
13905: LD_VAR 0 3
13909: PUSH
13910: LD_VAR 0 4
13914: PUSH
13915: LD_VAR 0 5
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: ST_TO_ADDR
// exit ;
13926: GO 14350
// end ; _chassis := AvailableChassisList ( factory ) ;
13928: LD_ADDR_VAR 0 9
13932: PUSH
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 475
13942: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13943: LD_ADDR_VAR 0 11
13947: PUSH
13948: LD_VAR 0 1
13952: PPUSH
13953: CALL_OW 476
13957: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13958: LD_ADDR_VAR 0 12
13962: PUSH
13963: LD_VAR 0 1
13967: PPUSH
13968: CALL_OW 477
13972: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13973: LD_ADDR_VAR 0 10
13977: PUSH
13978: LD_VAR 0 1
13982: PPUSH
13983: CALL_OW 478
13987: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13988: LD_VAR 0 9
13992: NOT
13993: IFTRUE 14002
13995: PUSH
13996: LD_VAR 0 11
14000: NOT
14001: OR
14002: IFTRUE 14011
14004: PUSH
14005: LD_VAR 0 12
14009: NOT
14010: OR
14011: IFTRUE 14020
14013: PUSH
14014: LD_VAR 0 10
14018: NOT
14019: OR
14020: IFFALSE 14055
// begin result := [ chassis , engine , control , weapon ] ;
14022: LD_ADDR_VAR 0 6
14026: PUSH
14027: LD_VAR 0 2
14031: PUSH
14032: LD_VAR 0 3
14036: PUSH
14037: LD_VAR 0 4
14041: PUSH
14042: LD_VAR 0 5
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: ST_TO_ADDR
// exit ;
14053: GO 14350
// end ; if not chassis in _chassis then
14055: LD_VAR 0 2
14059: PUSH
14060: LD_VAR 0 9
14064: IN
14065: NOT
14066: IFFALSE 14092
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
14068: LD_ADDR_VAR 0 2
14072: PUSH
14073: LD_VAR 0 9
14077: PUSH
14078: LD_INT 1
14080: PPUSH
14081: LD_VAR 0 9
14085: PPUSH
14086: CALL_OW 12
14090: ARRAY
14091: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_VAR 0 3
14101: PPUSH
14102: CALL 14355 0 2
14106: NOT
14107: IFFALSE 14168
// repeat engine := _engine [ 1 ] ;
14109: LD_ADDR_VAR 0 3
14113: PUSH
14114: LD_VAR 0 11
14118: PUSH
14119: LD_INT 1
14121: ARRAY
14122: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14123: LD_ADDR_VAR 0 11
14127: PUSH
14128: LD_VAR 0 11
14132: PPUSH
14133: LD_INT 1
14135: PPUSH
14136: CALL_OW 3
14140: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14141: LD_VAR 0 2
14145: PPUSH
14146: LD_VAR 0 3
14150: PPUSH
14151: CALL 14355 0 2
14155: IFTRUE 14166
14157: PUSH
14158: LD_VAR 0 11
14162: PUSH
14163: EMPTY
14164: EQUAL
14165: OR
14166: IFFALSE 14109
// if not control in _control then
14168: LD_VAR 0 4
14172: PUSH
14173: LD_VAR 0 12
14177: IN
14178: NOT
14179: IFFALSE 14205
// control := _control [ rand ( 1 , _control ) ] ;
14181: LD_ADDR_VAR 0 4
14185: PUSH
14186: LD_VAR 0 12
14190: PUSH
14191: LD_INT 1
14193: PPUSH
14194: LD_VAR 0 12
14198: PPUSH
14199: CALL_OW 12
14203: ARRAY
14204: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14205: LD_VAR 0 2
14209: PPUSH
14210: LD_VAR 0 5
14214: PPUSH
14215: CALL 14577 0 2
14219: NOT
14220: IFFALSE 14281
// repeat weapon := _weapon [ 1 ] ;
14222: LD_ADDR_VAR 0 5
14226: PUSH
14227: LD_VAR 0 10
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14236: LD_ADDR_VAR 0 10
14240: PUSH
14241: LD_VAR 0 10
14245: PPUSH
14246: LD_INT 1
14248: PPUSH
14249: CALL_OW 3
14253: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14254: LD_VAR 0 2
14258: PPUSH
14259: LD_VAR 0 5
14263: PPUSH
14264: CALL 14577 0 2
14268: IFTRUE 14279
14270: PUSH
14271: LD_VAR 0 10
14275: PUSH
14276: EMPTY
14277: EQUAL
14278: OR
14279: IFFALSE 14222
// result := [ ] ;
14281: LD_ADDR_VAR 0 6
14285: PUSH
14286: EMPTY
14287: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14288: LD_VAR 0 1
14292: PPUSH
14293: LD_VAR 0 2
14297: PPUSH
14298: LD_VAR 0 3
14302: PPUSH
14303: LD_VAR 0 4
14307: PPUSH
14308: LD_VAR 0 5
14312: PPUSH
14313: CALL_OW 448
14317: IFFALSE 14350
// result := [ chassis , engine , control , weapon ] ;
14319: LD_ADDR_VAR 0 6
14323: PUSH
14324: LD_VAR 0 2
14328: PUSH
14329: LD_VAR 0 3
14333: PUSH
14334: LD_VAR 0 4
14338: PUSH
14339: LD_VAR 0 5
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 6
14354: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14355: LD_INT 0
14357: PPUSH
// if not chassis or not engine then
14358: LD_VAR 0 1
14362: NOT
14363: IFTRUE 14372
14365: PUSH
14366: LD_VAR 0 2
14370: NOT
14371: OR
14372: IFFALSE 14376
// exit ;
14374: GO 14572
// case engine of engine_solar :
14376: LD_VAR 0 2
14380: PUSH
14381: LD_INT 2
14383: DOUBLE
14384: EQUAL
14385: IFTRUE 14389
14387: GO 14427
14389: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_INT 11
14397: PUSH
14398: LD_INT 12
14400: PUSH
14401: LD_INT 13
14403: PUSH
14404: LD_INT 14
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: LD_INT 2
14412: PUSH
14413: LD_INT 3
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: LIST
14424: ST_TO_ADDR
14425: GO 14556
14427: LD_INT 1
14429: DOUBLE
14430: EQUAL
14431: IFTRUE 14435
14433: GO 14497
14435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14436: LD_ADDR_VAR 0 3
14440: PUSH
14441: LD_INT 11
14443: PUSH
14444: LD_INT 12
14446: PUSH
14447: LD_INT 13
14449: PUSH
14450: LD_INT 14
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: LD_INT 2
14458: PUSH
14459: LD_INT 3
14461: PUSH
14462: LD_INT 4
14464: PUSH
14465: LD_INT 5
14467: PUSH
14468: LD_INT 21
14470: PUSH
14471: LD_INT 23
14473: PUSH
14474: LD_INT 22
14476: PUSH
14477: LD_INT 24
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: ST_TO_ADDR
14495: GO 14556
14497: LD_INT 3
14499: DOUBLE
14500: EQUAL
14501: IFTRUE 14505
14503: GO 14555
14505: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14506: LD_ADDR_VAR 0 3
14510: PUSH
14511: LD_INT 13
14513: PUSH
14514: LD_INT 14
14516: PUSH
14517: LD_INT 2
14519: PUSH
14520: LD_INT 3
14522: PUSH
14523: LD_INT 4
14525: PUSH
14526: LD_INT 5
14528: PUSH
14529: LD_INT 21
14531: PUSH
14532: LD_INT 22
14534: PUSH
14535: LD_INT 23
14537: PUSH
14538: LD_INT 24
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: ST_TO_ADDR
14553: GO 14556
14555: POP
// result := ( chassis in result ) ;
14556: LD_ADDR_VAR 0 3
14560: PUSH
14561: LD_VAR 0 1
14565: PUSH
14566: LD_VAR 0 3
14570: IN
14571: ST_TO_ADDR
// end ;
14572: LD_VAR 0 3
14576: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14577: LD_INT 0
14579: PPUSH
// if not chassis or not weapon then
14580: LD_VAR 0 1
14584: NOT
14585: IFTRUE 14594
14587: PUSH
14588: LD_VAR 0 2
14592: NOT
14593: OR
14594: IFFALSE 14598
// exit ;
14596: GO 15692
// case weapon of us_machine_gun :
14598: LD_VAR 0 2
14602: PUSH
14603: LD_INT 2
14605: DOUBLE
14606: EQUAL
14607: IFTRUE 14611
14609: GO 14641
14611: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14612: LD_ADDR_VAR 0 3
14616: PUSH
14617: LD_INT 1
14619: PUSH
14620: LD_INT 2
14622: PUSH
14623: LD_INT 3
14625: PUSH
14626: LD_INT 4
14628: PUSH
14629: LD_INT 5
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: ST_TO_ADDR
14639: GO 15676
14641: LD_INT 3
14643: DOUBLE
14644: EQUAL
14645: IFTRUE 14649
14647: GO 14679
14649: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14650: LD_ADDR_VAR 0 3
14654: PUSH
14655: LD_INT 1
14657: PUSH
14658: LD_INT 2
14660: PUSH
14661: LD_INT 3
14663: PUSH
14664: LD_INT 4
14666: PUSH
14667: LD_INT 5
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: ST_TO_ADDR
14677: GO 15676
14679: LD_INT 11
14681: DOUBLE
14682: EQUAL
14683: IFTRUE 14687
14685: GO 14717
14687: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14688: LD_ADDR_VAR 0 3
14692: PUSH
14693: LD_INT 1
14695: PUSH
14696: LD_INT 2
14698: PUSH
14699: LD_INT 3
14701: PUSH
14702: LD_INT 4
14704: PUSH
14705: LD_INT 5
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: ST_TO_ADDR
14715: GO 15676
14717: LD_INT 4
14719: DOUBLE
14720: EQUAL
14721: IFTRUE 14725
14723: GO 14751
14725: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14726: LD_ADDR_VAR 0 3
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: LD_INT 3
14736: PUSH
14737: LD_INT 4
14739: PUSH
14740: LD_INT 5
14742: PUSH
14743: EMPTY
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: ST_TO_ADDR
14749: GO 15676
14751: LD_INT 5
14753: DOUBLE
14754: EQUAL
14755: IFTRUE 14759
14757: GO 14785
14759: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14760: LD_ADDR_VAR 0 3
14764: PUSH
14765: LD_INT 2
14767: PUSH
14768: LD_INT 3
14770: PUSH
14771: LD_INT 4
14773: PUSH
14774: LD_INT 5
14776: PUSH
14777: EMPTY
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: ST_TO_ADDR
14783: GO 15676
14785: LD_INT 9
14787: DOUBLE
14788: EQUAL
14789: IFTRUE 14793
14791: GO 14819
14793: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_INT 2
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: LD_INT 4
14807: PUSH
14808: LD_INT 5
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: ST_TO_ADDR
14817: GO 15676
14819: LD_INT 7
14821: DOUBLE
14822: EQUAL
14823: IFTRUE 14827
14825: GO 14853
14827: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14828: LD_ADDR_VAR 0 3
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: LD_INT 3
14838: PUSH
14839: LD_INT 4
14841: PUSH
14842: LD_INT 5
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: ST_TO_ADDR
14851: GO 15676
14853: LD_INT 12
14855: DOUBLE
14856: EQUAL
14857: IFTRUE 14861
14859: GO 14887
14861: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14862: LD_ADDR_VAR 0 3
14866: PUSH
14867: LD_INT 2
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: LD_INT 4
14875: PUSH
14876: LD_INT 5
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: ST_TO_ADDR
14885: GO 15676
14887: LD_INT 13
14889: DOUBLE
14890: EQUAL
14891: IFTRUE 14895
14893: GO 14921
14895: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14896: LD_ADDR_VAR 0 3
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: LD_INT 3
14906: PUSH
14907: LD_INT 4
14909: PUSH
14910: LD_INT 5
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: ST_TO_ADDR
14919: GO 15676
14921: LD_INT 14
14923: DOUBLE
14924: EQUAL
14925: IFTRUE 14929
14927: GO 14947
14929: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14930: LD_ADDR_VAR 0 3
14934: PUSH
14935: LD_INT 4
14937: PUSH
14938: LD_INT 5
14940: PUSH
14941: EMPTY
14942: LIST
14943: LIST
14944: ST_TO_ADDR
14945: GO 15676
14947: LD_INT 6
14949: DOUBLE
14950: EQUAL
14951: IFTRUE 14955
14953: GO 14973
14955: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14956: LD_ADDR_VAR 0 3
14960: PUSH
14961: LD_INT 4
14963: PUSH
14964: LD_INT 5
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: ST_TO_ADDR
14971: GO 15676
14973: LD_INT 10
14975: DOUBLE
14976: EQUAL
14977: IFTRUE 14981
14979: GO 14999
14981: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14982: LD_ADDR_VAR 0 3
14986: PUSH
14987: LD_INT 4
14989: PUSH
14990: LD_INT 5
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: ST_TO_ADDR
14997: GO 15676
14999: LD_INT 22
15001: DOUBLE
15002: EQUAL
15003: IFTRUE 15007
15005: GO 15033
15007: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
15008: LD_ADDR_VAR 0 3
15012: PUSH
15013: LD_INT 11
15015: PUSH
15016: LD_INT 12
15018: PUSH
15019: LD_INT 13
15021: PUSH
15022: LD_INT 14
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: ST_TO_ADDR
15031: GO 15676
15033: LD_INT 23
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15067
15041: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 11
15049: PUSH
15050: LD_INT 12
15052: PUSH
15053: LD_INT 13
15055: PUSH
15056: LD_INT 14
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: ST_TO_ADDR
15065: GO 15676
15067: LD_INT 24
15069: DOUBLE
15070: EQUAL
15071: IFTRUE 15075
15073: GO 15101
15075: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
15076: LD_ADDR_VAR 0 3
15080: PUSH
15081: LD_INT 11
15083: PUSH
15084: LD_INT 12
15086: PUSH
15087: LD_INT 13
15089: PUSH
15090: LD_INT 14
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: ST_TO_ADDR
15099: GO 15676
15101: LD_INT 30
15103: DOUBLE
15104: EQUAL
15105: IFTRUE 15109
15107: GO 15135
15109: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15110: LD_ADDR_VAR 0 3
15114: PUSH
15115: LD_INT 11
15117: PUSH
15118: LD_INT 12
15120: PUSH
15121: LD_INT 13
15123: PUSH
15124: LD_INT 14
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: ST_TO_ADDR
15133: GO 15676
15135: LD_INT 25
15137: DOUBLE
15138: EQUAL
15139: IFTRUE 15143
15141: GO 15161
15143: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15144: LD_ADDR_VAR 0 3
15148: PUSH
15149: LD_INT 13
15151: PUSH
15152: LD_INT 14
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: ST_TO_ADDR
15159: GO 15676
15161: LD_INT 27
15163: DOUBLE
15164: EQUAL
15165: IFTRUE 15169
15167: GO 15187
15169: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15170: LD_ADDR_VAR 0 3
15174: PUSH
15175: LD_INT 13
15177: PUSH
15178: LD_INT 14
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: ST_TO_ADDR
15185: GO 15676
15187: LD_INT 92
15189: DOUBLE
15190: EQUAL
15191: IFTRUE 15195
15193: GO 15221
15195: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15196: LD_ADDR_VAR 0 3
15200: PUSH
15201: LD_INT 11
15203: PUSH
15204: LD_INT 12
15206: PUSH
15207: LD_INT 13
15209: PUSH
15210: LD_INT 14
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: ST_TO_ADDR
15219: GO 15676
15221: LD_INT 28
15223: DOUBLE
15224: EQUAL
15225: IFTRUE 15229
15227: GO 15247
15229: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15230: LD_ADDR_VAR 0 3
15234: PUSH
15235: LD_INT 13
15237: PUSH
15238: LD_INT 14
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: ST_TO_ADDR
15245: GO 15676
15247: LD_INT 29
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15273
15255: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15256: LD_ADDR_VAR 0 3
15260: PUSH
15261: LD_INT 13
15263: PUSH
15264: LD_INT 14
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: ST_TO_ADDR
15271: GO 15676
15273: LD_INT 31
15275: DOUBLE
15276: EQUAL
15277: IFTRUE 15281
15279: GO 15299
15281: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15282: LD_ADDR_VAR 0 3
15286: PUSH
15287: LD_INT 13
15289: PUSH
15290: LD_INT 14
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: ST_TO_ADDR
15297: GO 15676
15299: LD_INT 26
15301: DOUBLE
15302: EQUAL
15303: IFTRUE 15307
15305: GO 15325
15307: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15308: LD_ADDR_VAR 0 3
15312: PUSH
15313: LD_INT 13
15315: PUSH
15316: LD_INT 14
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: ST_TO_ADDR
15323: GO 15676
15325: LD_INT 42
15327: DOUBLE
15328: EQUAL
15329: IFTRUE 15333
15331: GO 15359
15333: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15334: LD_ADDR_VAR 0 3
15338: PUSH
15339: LD_INT 21
15341: PUSH
15342: LD_INT 22
15344: PUSH
15345: LD_INT 23
15347: PUSH
15348: LD_INT 24
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: ST_TO_ADDR
15357: GO 15676
15359: LD_INT 43
15361: DOUBLE
15362: EQUAL
15363: IFTRUE 15367
15365: GO 15393
15367: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15368: LD_ADDR_VAR 0 3
15372: PUSH
15373: LD_INT 21
15375: PUSH
15376: LD_INT 22
15378: PUSH
15379: LD_INT 23
15381: PUSH
15382: LD_INT 24
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: ST_TO_ADDR
15391: GO 15676
15393: LD_INT 44
15395: DOUBLE
15396: EQUAL
15397: IFTRUE 15401
15399: GO 15427
15401: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15402: LD_ADDR_VAR 0 3
15406: PUSH
15407: LD_INT 21
15409: PUSH
15410: LD_INT 22
15412: PUSH
15413: LD_INT 23
15415: PUSH
15416: LD_INT 24
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: LIST
15423: LIST
15424: ST_TO_ADDR
15425: GO 15676
15427: LD_INT 45
15429: DOUBLE
15430: EQUAL
15431: IFTRUE 15435
15433: GO 15461
15435: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: LD_INT 21
15443: PUSH
15444: LD_INT 22
15446: PUSH
15447: LD_INT 23
15449: PUSH
15450: LD_INT 24
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: ST_TO_ADDR
15459: GO 15676
15461: LD_INT 49
15463: DOUBLE
15464: EQUAL
15465: IFTRUE 15469
15467: GO 15495
15469: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15470: LD_ADDR_VAR 0 3
15474: PUSH
15475: LD_INT 21
15477: PUSH
15478: LD_INT 22
15480: PUSH
15481: LD_INT 23
15483: PUSH
15484: LD_INT 24
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: ST_TO_ADDR
15493: GO 15676
15495: LD_INT 51
15497: DOUBLE
15498: EQUAL
15499: IFTRUE 15503
15501: GO 15529
15503: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15504: LD_ADDR_VAR 0 3
15508: PUSH
15509: LD_INT 21
15511: PUSH
15512: LD_INT 22
15514: PUSH
15515: LD_INT 23
15517: PUSH
15518: LD_INT 24
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: ST_TO_ADDR
15527: GO 15676
15529: LD_INT 52
15531: DOUBLE
15532: EQUAL
15533: IFTRUE 15537
15535: GO 15563
15537: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15538: LD_ADDR_VAR 0 3
15542: PUSH
15543: LD_INT 21
15545: PUSH
15546: LD_INT 22
15548: PUSH
15549: LD_INT 23
15551: PUSH
15552: LD_INT 24
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: ST_TO_ADDR
15561: GO 15676
15563: LD_INT 53
15565: DOUBLE
15566: EQUAL
15567: IFTRUE 15571
15569: GO 15589
15571: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15572: LD_ADDR_VAR 0 3
15576: PUSH
15577: LD_INT 23
15579: PUSH
15580: LD_INT 24
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: ST_TO_ADDR
15587: GO 15676
15589: LD_INT 46
15591: DOUBLE
15592: EQUAL
15593: IFTRUE 15597
15595: GO 15615
15597: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15598: LD_ADDR_VAR 0 3
15602: PUSH
15603: LD_INT 23
15605: PUSH
15606: LD_INT 24
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: ST_TO_ADDR
15613: GO 15676
15615: LD_INT 47
15617: DOUBLE
15618: EQUAL
15619: IFTRUE 15623
15621: GO 15641
15623: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
15624: LD_ADDR_VAR 0 3
15628: PUSH
15629: LD_INT 23
15631: PUSH
15632: LD_INT 24
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: ST_TO_ADDR
15639: GO 15676
15641: LD_INT 98
15643: DOUBLE
15644: EQUAL
15645: IFTRUE 15649
15647: GO 15675
15649: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15650: LD_ADDR_VAR 0 3
15654: PUSH
15655: LD_INT 21
15657: PUSH
15658: LD_INT 22
15660: PUSH
15661: LD_INT 23
15663: PUSH
15664: LD_INT 24
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: ST_TO_ADDR
15673: GO 15676
15675: POP
// result := ( chassis in result ) ;
15676: LD_ADDR_VAR 0 3
15680: PUSH
15681: LD_VAR 0 1
15685: PUSH
15686: LD_VAR 0 3
15690: IN
15691: ST_TO_ADDR
// end ;
15692: LD_VAR 0 3
15696: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15697: LD_INT 0
15699: PPUSH
15700: PPUSH
15701: PPUSH
15702: PPUSH
15703: PPUSH
15704: PPUSH
15705: PPUSH
// result := array ;
15706: LD_ADDR_VAR 0 5
15710: PUSH
15711: LD_VAR 0 1
15715: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15716: LD_VAR 0 1
15720: NOT
15721: IFTRUE 15730
15723: PUSH
15724: LD_VAR 0 2
15728: NOT
15729: OR
15730: IFTRUE 15739
15732: PUSH
15733: LD_VAR 0 3
15737: NOT
15738: OR
15739: IFTRUE 15753
15741: PUSH
15742: LD_VAR 0 2
15746: PUSH
15747: LD_VAR 0 1
15751: GREATER
15752: OR
15753: IFTRUE 15767
15755: PUSH
15756: LD_VAR 0 3
15760: PUSH
15761: LD_VAR 0 1
15765: GREATER
15766: OR
15767: IFFALSE 15771
// exit ;
15769: GO 16067
// if direction then
15771: LD_VAR 0 4
15775: IFFALSE 15839
// begin d := 1 ;
15777: LD_ADDR_VAR 0 9
15781: PUSH
15782: LD_INT 1
15784: ST_TO_ADDR
// if i_from > i_to then
15785: LD_VAR 0 2
15789: PUSH
15790: LD_VAR 0 3
15794: GREATER
15795: IFFALSE 15821
// length := ( array - i_from ) + i_to else
15797: LD_ADDR_VAR 0 11
15801: PUSH
15802: LD_VAR 0 1
15806: PUSH
15807: LD_VAR 0 2
15811: MINUS
15812: PUSH
15813: LD_VAR 0 3
15817: PLUS
15818: ST_TO_ADDR
15819: GO 15837
// length := i_to - i_from ;
15821: LD_ADDR_VAR 0 11
15825: PUSH
15826: LD_VAR 0 3
15830: PUSH
15831: LD_VAR 0 2
15835: MINUS
15836: ST_TO_ADDR
// end else
15837: GO 15900
// begin d := - 1 ;
15839: LD_ADDR_VAR 0 9
15843: PUSH
15844: LD_INT 1
15846: NEG
15847: ST_TO_ADDR
// if i_from > i_to then
15848: LD_VAR 0 2
15852: PUSH
15853: LD_VAR 0 3
15857: GREATER
15858: IFFALSE 15878
// length := i_from - i_to else
15860: LD_ADDR_VAR 0 11
15864: PUSH
15865: LD_VAR 0 2
15869: PUSH
15870: LD_VAR 0 3
15874: MINUS
15875: ST_TO_ADDR
15876: GO 15900
// length := ( array - i_to ) + i_from ;
15878: LD_ADDR_VAR 0 11
15882: PUSH
15883: LD_VAR 0 1
15887: PUSH
15888: LD_VAR 0 3
15892: MINUS
15893: PUSH
15894: LD_VAR 0 2
15898: PLUS
15899: ST_TO_ADDR
// end ; if not length then
15900: LD_VAR 0 11
15904: NOT
15905: IFFALSE 15909
// exit ;
15907: GO 16067
// tmp := array ;
15909: LD_ADDR_VAR 0 10
15913: PUSH
15914: LD_VAR 0 1
15918: ST_TO_ADDR
// for i = 1 to length do
15919: LD_ADDR_VAR 0 6
15923: PUSH
15924: DOUBLE
15925: LD_INT 1
15927: DEC
15928: ST_TO_ADDR
15929: LD_VAR 0 11
15933: PUSH
15934: FOR_TO
15935: IFFALSE 16055
// begin for j = 1 to array do
15937: LD_ADDR_VAR 0 7
15941: PUSH
15942: DOUBLE
15943: LD_INT 1
15945: DEC
15946: ST_TO_ADDR
15947: LD_VAR 0 1
15951: PUSH
15952: FOR_TO
15953: IFFALSE 16041
// begin k := j + d ;
15955: LD_ADDR_VAR 0 8
15959: PUSH
15960: LD_VAR 0 7
15964: PUSH
15965: LD_VAR 0 9
15969: PLUS
15970: ST_TO_ADDR
// if k > array then
15971: LD_VAR 0 8
15975: PUSH
15976: LD_VAR 0 1
15980: GREATER
15981: IFFALSE 15991
// k := 1 ;
15983: LD_ADDR_VAR 0 8
15987: PUSH
15988: LD_INT 1
15990: ST_TO_ADDR
// if not k then
15991: LD_VAR 0 8
15995: NOT
15996: IFFALSE 16008
// k := array ;
15998: LD_ADDR_VAR 0 8
16002: PUSH
16003: LD_VAR 0 1
16007: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
16008: LD_ADDR_VAR 0 10
16012: PUSH
16013: LD_VAR 0 10
16017: PPUSH
16018: LD_VAR 0 8
16022: PPUSH
16023: LD_VAR 0 1
16027: PUSH
16028: LD_VAR 0 7
16032: ARRAY
16033: PPUSH
16034: CALL_OW 1
16038: ST_TO_ADDR
// end ;
16039: GO 15952
16041: POP
16042: POP
// array := tmp ;
16043: LD_ADDR_VAR 0 1
16047: PUSH
16048: LD_VAR 0 10
16052: ST_TO_ADDR
// end ;
16053: GO 15934
16055: POP
16056: POP
// result := array ;
16057: LD_ADDR_VAR 0 5
16061: PUSH
16062: LD_VAR 0 1
16066: ST_TO_ADDR
// end ;
16067: LD_VAR 0 5
16071: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
16072: LD_INT 0
16074: PPUSH
16075: PPUSH
// result := 0 ;
16076: LD_ADDR_VAR 0 3
16080: PUSH
16081: LD_INT 0
16083: ST_TO_ADDR
// if not array or not value in array then
16084: LD_VAR 0 1
16088: NOT
16089: IFTRUE 16104
16091: PUSH
16092: LD_VAR 0 2
16096: PUSH
16097: LD_VAR 0 1
16101: IN
16102: NOT
16103: OR
16104: IFFALSE 16108
// exit ;
16106: GO 16162
// for i = 1 to array do
16108: LD_ADDR_VAR 0 4
16112: PUSH
16113: DOUBLE
16114: LD_INT 1
16116: DEC
16117: ST_TO_ADDR
16118: LD_VAR 0 1
16122: PUSH
16123: FOR_TO
16124: IFFALSE 16160
// if value = array [ i ] then
16126: LD_VAR 0 2
16130: PUSH
16131: LD_VAR 0 1
16135: PUSH
16136: LD_VAR 0 4
16140: ARRAY
16141: EQUAL
16142: IFFALSE 16158
// begin result := i ;
16144: LD_ADDR_VAR 0 3
16148: PUSH
16149: LD_VAR 0 4
16153: ST_TO_ADDR
// exit ;
16154: POP
16155: POP
16156: GO 16162
// end ;
16158: GO 16123
16160: POP
16161: POP
// end ;
16162: LD_VAR 0 3
16166: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16167: LD_INT 0
16169: PPUSH
// vc_chassis := chassis ;
16170: LD_ADDR_OWVAR 37
16174: PUSH
16175: LD_VAR 0 1
16179: ST_TO_ADDR
// vc_engine := engine ;
16180: LD_ADDR_OWVAR 39
16184: PUSH
16185: LD_VAR 0 2
16189: ST_TO_ADDR
// vc_control := control ;
16190: LD_ADDR_OWVAR 38
16194: PUSH
16195: LD_VAR 0 3
16199: ST_TO_ADDR
// vc_weapon := weapon ;
16200: LD_ADDR_OWVAR 40
16204: PUSH
16205: LD_VAR 0 4
16209: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16210: LD_ADDR_OWVAR 41
16214: PUSH
16215: LD_VAR 0 5
16219: ST_TO_ADDR
// end ;
16220: LD_VAR 0 6
16224: RET
// export function WantPlant ( unit ) ; var task ; begin
16225: LD_INT 0
16227: PPUSH
16228: PPUSH
// result := false ;
16229: LD_ADDR_VAR 0 2
16233: PUSH
16234: LD_INT 0
16236: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16237: LD_ADDR_VAR 0 3
16241: PUSH
16242: LD_VAR 0 1
16246: PPUSH
16247: CALL_OW 437
16251: ST_TO_ADDR
// if task then
16252: LD_VAR 0 3
16256: IFFALSE 16284
// if task [ 1 ] [ 1 ] = p then
16258: LD_VAR 0 3
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PUSH
16267: LD_INT 1
16269: ARRAY
16270: PUSH
16271: LD_STRING p
16273: EQUAL
16274: IFFALSE 16284
// result := true ;
16276: LD_ADDR_VAR 0 2
16280: PUSH
16281: LD_INT 1
16283: ST_TO_ADDR
// end ;
16284: LD_VAR 0 2
16288: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16289: LD_INT 0
16291: PPUSH
16292: PPUSH
16293: PPUSH
16294: PPUSH
// if pos < 1 then
16295: LD_VAR 0 2
16299: PUSH
16300: LD_INT 1
16302: LESS
16303: IFFALSE 16307
// exit ;
16305: GO 16610
// if pos = 1 then
16307: LD_VAR 0 2
16311: PUSH
16312: LD_INT 1
16314: EQUAL
16315: IFFALSE 16348
// result := Replace ( arr , pos [ 1 ] , value ) else
16317: LD_ADDR_VAR 0 4
16321: PUSH
16322: LD_VAR 0 1
16326: PPUSH
16327: LD_VAR 0 2
16331: PUSH
16332: LD_INT 1
16334: ARRAY
16335: PPUSH
16336: LD_VAR 0 3
16340: PPUSH
16341: CALL_OW 1
16345: ST_TO_ADDR
16346: GO 16610
// begin tmp := arr ;
16348: LD_ADDR_VAR 0 6
16352: PUSH
16353: LD_VAR 0 1
16357: ST_TO_ADDR
// s_arr := [ tmp ] ;
16358: LD_ADDR_VAR 0 7
16362: PUSH
16363: LD_VAR 0 6
16367: PUSH
16368: EMPTY
16369: LIST
16370: ST_TO_ADDR
// for i = 1 to pos - 1 do
16371: LD_ADDR_VAR 0 5
16375: PUSH
16376: DOUBLE
16377: LD_INT 1
16379: DEC
16380: ST_TO_ADDR
16381: LD_VAR 0 2
16385: PUSH
16386: LD_INT 1
16388: MINUS
16389: PUSH
16390: FOR_TO
16391: IFFALSE 16436
// begin tmp := tmp [ pos [ i ] ] ;
16393: LD_ADDR_VAR 0 6
16397: PUSH
16398: LD_VAR 0 6
16402: PUSH
16403: LD_VAR 0 2
16407: PUSH
16408: LD_VAR 0 5
16412: ARRAY
16413: ARRAY
16414: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16415: LD_ADDR_VAR 0 7
16419: PUSH
16420: LD_VAR 0 7
16424: PUSH
16425: LD_VAR 0 6
16429: PUSH
16430: EMPTY
16431: LIST
16432: ADD
16433: ST_TO_ADDR
// end ;
16434: GO 16390
16436: POP
16437: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16438: LD_ADDR_VAR 0 6
16442: PUSH
16443: LD_VAR 0 6
16447: PPUSH
16448: LD_VAR 0 2
16452: PUSH
16453: LD_VAR 0 2
16457: ARRAY
16458: PPUSH
16459: LD_VAR 0 3
16463: PPUSH
16464: CALL_OW 1
16468: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16469: LD_ADDR_VAR 0 7
16473: PUSH
16474: LD_VAR 0 7
16478: PPUSH
16479: LD_VAR 0 7
16483: PPUSH
16484: LD_VAR 0 6
16488: PPUSH
16489: CALL_OW 1
16493: ST_TO_ADDR
// for i = s_arr downto 2 do
16494: LD_ADDR_VAR 0 5
16498: PUSH
16499: DOUBLE
16500: LD_VAR 0 7
16504: INC
16505: ST_TO_ADDR
16506: LD_INT 2
16508: PUSH
16509: FOR_DOWNTO
16510: IFFALSE 16594
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16512: LD_ADDR_VAR 0 6
16516: PUSH
16517: LD_VAR 0 7
16521: PUSH
16522: LD_VAR 0 5
16526: PUSH
16527: LD_INT 1
16529: MINUS
16530: ARRAY
16531: PPUSH
16532: LD_VAR 0 2
16536: PUSH
16537: LD_VAR 0 5
16541: PUSH
16542: LD_INT 1
16544: MINUS
16545: ARRAY
16546: PPUSH
16547: LD_VAR 0 7
16551: PUSH
16552: LD_VAR 0 5
16556: ARRAY
16557: PPUSH
16558: CALL_OW 1
16562: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16563: LD_ADDR_VAR 0 7
16567: PUSH
16568: LD_VAR 0 7
16572: PPUSH
16573: LD_VAR 0 5
16577: PUSH
16578: LD_INT 1
16580: MINUS
16581: PPUSH
16582: LD_VAR 0 6
16586: PPUSH
16587: CALL_OW 1
16591: ST_TO_ADDR
// end ;
16592: GO 16509
16594: POP
16595: POP
// result := s_arr [ 1 ] ;
16596: LD_ADDR_VAR 0 4
16600: PUSH
16601: LD_VAR 0 7
16605: PUSH
16606: LD_INT 1
16608: ARRAY
16609: ST_TO_ADDR
// end ; end ;
16610: LD_VAR 0 4
16614: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16615: LD_INT 0
16617: PPUSH
16618: PPUSH
// if not list then
16619: LD_VAR 0 1
16623: NOT
16624: IFFALSE 16628
// exit ;
16626: GO 16719
// i := list [ pos1 ] ;
16628: LD_ADDR_VAR 0 5
16632: PUSH
16633: LD_VAR 0 1
16637: PUSH
16638: LD_VAR 0 2
16642: ARRAY
16643: ST_TO_ADDR
// if not i then
16644: LD_VAR 0 5
16648: NOT
16649: IFFALSE 16653
// exit ;
16651: GO 16719
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16653: LD_ADDR_VAR 0 1
16657: PUSH
16658: LD_VAR 0 1
16662: PPUSH
16663: LD_VAR 0 2
16667: PPUSH
16668: LD_VAR 0 1
16672: PUSH
16673: LD_VAR 0 3
16677: ARRAY
16678: PPUSH
16679: CALL_OW 1
16683: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16684: LD_ADDR_VAR 0 1
16688: PUSH
16689: LD_VAR 0 1
16693: PPUSH
16694: LD_VAR 0 3
16698: PPUSH
16699: LD_VAR 0 5
16703: PPUSH
16704: CALL_OW 1
16708: ST_TO_ADDR
// result := list ;
16709: LD_ADDR_VAR 0 4
16713: PUSH
16714: LD_VAR 0 1
16718: ST_TO_ADDR
// end ;
16719: LD_VAR 0 4
16723: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16724: LD_INT 0
16726: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16727: LD_ADDR_VAR 0 5
16731: PUSH
16732: LD_VAR 0 1
16736: PPUSH
16737: CALL_OW 250
16741: PPUSH
16742: LD_VAR 0 1
16746: PPUSH
16747: CALL_OW 251
16751: PPUSH
16752: LD_VAR 0 2
16756: PPUSH
16757: LD_VAR 0 3
16761: PPUSH
16762: LD_VAR 0 4
16766: PPUSH
16767: CALL 17149 0 5
16771: ST_TO_ADDR
// end ;
16772: LD_VAR 0 5
16776: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
16777: LD_INT 0
16779: PPUSH
16780: PPUSH
16781: PPUSH
16782: PPUSH
// if not list or not unit then
16783: LD_VAR 0 2
16787: NOT
16788: IFTRUE 16797
16790: PUSH
16791: LD_VAR 0 1
16795: NOT
16796: OR
16797: IFFALSE 16801
// exit ;
16799: GO 17144
// result := [ ] ;
16801: LD_ADDR_VAR 0 5
16805: PUSH
16806: EMPTY
16807: ST_TO_ADDR
// for i in list do
16808: LD_ADDR_VAR 0 6
16812: PUSH
16813: LD_VAR 0 2
16817: PUSH
16818: FOR_IN
16819: IFFALSE 17037
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
16821: LD_ADDR_VAR 0 8
16825: PUSH
16826: LD_VAR 0 1
16830: PPUSH
16831: LD_VAR 0 6
16835: PUSH
16836: LD_INT 1
16838: ARRAY
16839: PPUSH
16840: LD_VAR 0 6
16844: PUSH
16845: LD_INT 2
16847: ARRAY
16848: PPUSH
16849: CALL_OW 297
16853: ST_TO_ADDR
// if not Count ( result ) then
16854: LD_VAR 0 5
16858: PPUSH
16859: CALL 13371 0 1
16863: NOT
16864: IFFALSE 16897
// begin result := Join ( result , [ i , tmp ] ) ;
16866: LD_ADDR_VAR 0 5
16870: PUSH
16871: LD_VAR 0 5
16875: PPUSH
16876: LD_VAR 0 6
16880: PUSH
16881: LD_VAR 0 8
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PPUSH
16890: CALL 49347 0 2
16894: ST_TO_ADDR
// continue ;
16895: GO 16818
// end ; if result [ result ] [ 2 ] <= tmp then
16897: LD_VAR 0 5
16901: PUSH
16902: LD_VAR 0 5
16906: ARRAY
16907: PUSH
16908: LD_INT 2
16910: ARRAY
16911: PUSH
16912: LD_VAR 0 8
16916: LESSEQUAL
16917: IFFALSE 16950
// result := Join ( result , [ i , tmp ] ) else
16919: LD_ADDR_VAR 0 5
16923: PUSH
16924: LD_VAR 0 5
16928: PPUSH
16929: LD_VAR 0 6
16933: PUSH
16934: LD_VAR 0 8
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: PPUSH
16943: CALL 49347 0 2
16947: ST_TO_ADDR
16948: GO 17035
// begin for j := 1 to Count ( result ) do
16950: LD_ADDR_VAR 0 7
16954: PUSH
16955: DOUBLE
16956: LD_INT 1
16958: DEC
16959: ST_TO_ADDR
16960: LD_VAR 0 5
16964: PPUSH
16965: CALL 13371 0 1
16969: PUSH
16970: FOR_TO
16971: IFFALSE 17033
// begin if tmp < result [ j ] [ 2 ] then
16973: LD_VAR 0 8
16977: PUSH
16978: LD_VAR 0 5
16982: PUSH
16983: LD_VAR 0 7
16987: ARRAY
16988: PUSH
16989: LD_INT 2
16991: ARRAY
16992: LESS
16993: IFFALSE 17031
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16995: LD_ADDR_VAR 0 5
16999: PUSH
17000: LD_VAR 0 5
17004: PPUSH
17005: LD_VAR 0 7
17009: PPUSH
17010: LD_VAR 0 6
17014: PUSH
17015: LD_VAR 0 8
17019: PUSH
17020: EMPTY
17021: LIST
17022: LIST
17023: PPUSH
17024: CALL_OW 2
17028: ST_TO_ADDR
// break ;
17029: GO 17033
// end ; end ;
17031: GO 16970
17033: POP
17034: POP
// end ; end ;
17035: GO 16818
17037: POP
17038: POP
// if result and not asc then
17039: LD_VAR 0 5
17043: IFFALSE 17052
17045: PUSH
17046: LD_VAR 0 3
17050: NOT
17051: AND
17052: IFFALSE 17069
// result := ReverseArray ( result ) ;
17054: LD_ADDR_VAR 0 5
17058: PUSH
17059: LD_VAR 0 5
17063: PPUSH
17064: CALL 44427 0 1
17068: ST_TO_ADDR
// tmp := [ ] ;
17069: LD_ADDR_VAR 0 8
17073: PUSH
17074: EMPTY
17075: ST_TO_ADDR
// if mode then
17076: LD_VAR 0 4
17080: IFFALSE 17144
// begin for i := 1 to result do
17082: LD_ADDR_VAR 0 6
17086: PUSH
17087: DOUBLE
17088: LD_INT 1
17090: DEC
17091: ST_TO_ADDR
17092: LD_VAR 0 5
17096: PUSH
17097: FOR_TO
17098: IFFALSE 17132
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
17100: LD_ADDR_VAR 0 8
17104: PUSH
17105: LD_VAR 0 8
17109: PPUSH
17110: LD_VAR 0 5
17114: PUSH
17115: LD_VAR 0 6
17119: ARRAY
17120: PUSH
17121: LD_INT 1
17123: ARRAY
17124: PPUSH
17125: CALL 49347 0 2
17129: ST_TO_ADDR
17130: GO 17097
17132: POP
17133: POP
// result := tmp ;
17134: LD_ADDR_VAR 0 5
17138: PUSH
17139: LD_VAR 0 8
17143: ST_TO_ADDR
// end ; end ;
17144: LD_VAR 0 5
17148: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
17149: LD_INT 0
17151: PPUSH
17152: PPUSH
17153: PPUSH
17154: PPUSH
// if not list then
17155: LD_VAR 0 3
17159: NOT
17160: IFFALSE 17164
// exit ;
17162: GO 17554
// result := [ ] ;
17164: LD_ADDR_VAR 0 6
17168: PUSH
17169: EMPTY
17170: ST_TO_ADDR
// for i in list do
17171: LD_ADDR_VAR 0 7
17175: PUSH
17176: LD_VAR 0 3
17180: PUSH
17181: FOR_IN
17182: IFFALSE 17384
// begin tmp := GetDistUnitXY ( i , x , y ) ;
17184: LD_ADDR_VAR 0 9
17188: PUSH
17189: LD_VAR 0 7
17193: PPUSH
17194: LD_VAR 0 1
17198: PPUSH
17199: LD_VAR 0 2
17203: PPUSH
17204: CALL_OW 297
17208: ST_TO_ADDR
// if not result then
17209: LD_VAR 0 6
17213: NOT
17214: IFFALSE 17240
// result := [ [ i , tmp ] ] else
17216: LD_ADDR_VAR 0 6
17220: PUSH
17221: LD_VAR 0 7
17225: PUSH
17226: LD_VAR 0 9
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: EMPTY
17236: LIST
17237: ST_TO_ADDR
17238: GO 17382
// begin if result [ result ] [ 2 ] <= tmp then
17240: LD_VAR 0 6
17244: PUSH
17245: LD_VAR 0 6
17249: ARRAY
17250: PUSH
17251: LD_INT 2
17253: ARRAY
17254: PUSH
17255: LD_VAR 0 9
17259: LESSEQUAL
17260: IFFALSE 17302
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
17262: LD_ADDR_VAR 0 6
17266: PUSH
17267: LD_VAR 0 6
17271: PPUSH
17272: LD_VAR 0 6
17276: PUSH
17277: LD_INT 1
17279: PLUS
17280: PPUSH
17281: LD_VAR 0 7
17285: PUSH
17286: LD_VAR 0 9
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: PPUSH
17295: CALL_OW 2
17299: ST_TO_ADDR
17300: GO 17382
// for j := 1 to result do
17302: LD_ADDR_VAR 0 8
17306: PUSH
17307: DOUBLE
17308: LD_INT 1
17310: DEC
17311: ST_TO_ADDR
17312: LD_VAR 0 6
17316: PUSH
17317: FOR_TO
17318: IFFALSE 17380
// begin if tmp < result [ j ] [ 2 ] then
17320: LD_VAR 0 9
17324: PUSH
17325: LD_VAR 0 6
17329: PUSH
17330: LD_VAR 0 8
17334: ARRAY
17335: PUSH
17336: LD_INT 2
17338: ARRAY
17339: LESS
17340: IFFALSE 17378
// begin result := Insert ( result , j , [ i , tmp ] ) ;
17342: LD_ADDR_VAR 0 6
17346: PUSH
17347: LD_VAR 0 6
17351: PPUSH
17352: LD_VAR 0 8
17356: PPUSH
17357: LD_VAR 0 7
17361: PUSH
17362: LD_VAR 0 9
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PPUSH
17371: CALL_OW 2
17375: ST_TO_ADDR
// break ;
17376: GO 17380
// end ; end ;
17378: GO 17317
17380: POP
17381: POP
// end ; end ;
17382: GO 17181
17384: POP
17385: POP
// if result and not asc then
17386: LD_VAR 0 6
17390: IFFALSE 17399
17392: PUSH
17393: LD_VAR 0 4
17397: NOT
17398: AND
17399: IFFALSE 17474
// begin tmp := result ;
17401: LD_ADDR_VAR 0 9
17405: PUSH
17406: LD_VAR 0 6
17410: ST_TO_ADDR
// for i = tmp downto 1 do
17411: LD_ADDR_VAR 0 7
17415: PUSH
17416: DOUBLE
17417: LD_VAR 0 9
17421: INC
17422: ST_TO_ADDR
17423: LD_INT 1
17425: PUSH
17426: FOR_DOWNTO
17427: IFFALSE 17472
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
17429: LD_ADDR_VAR 0 6
17433: PUSH
17434: LD_VAR 0 6
17438: PPUSH
17439: LD_VAR 0 9
17443: PUSH
17444: LD_VAR 0 7
17448: MINUS
17449: PUSH
17450: LD_INT 1
17452: PLUS
17453: PPUSH
17454: LD_VAR 0 9
17458: PUSH
17459: LD_VAR 0 7
17463: ARRAY
17464: PPUSH
17465: CALL_OW 1
17469: ST_TO_ADDR
17470: GO 17426
17472: POP
17473: POP
// end ; tmp := [ ] ;
17474: LD_ADDR_VAR 0 9
17478: PUSH
17479: EMPTY
17480: ST_TO_ADDR
// if mode then
17481: LD_VAR 0 5
17485: IFFALSE 17554
// begin for i = 1 to result do
17487: LD_ADDR_VAR 0 7
17491: PUSH
17492: DOUBLE
17493: LD_INT 1
17495: DEC
17496: ST_TO_ADDR
17497: LD_VAR 0 6
17501: PUSH
17502: FOR_TO
17503: IFFALSE 17542
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17505: LD_ADDR_VAR 0 9
17509: PUSH
17510: LD_VAR 0 9
17514: PPUSH
17515: LD_VAR 0 7
17519: PPUSH
17520: LD_VAR 0 6
17524: PUSH
17525: LD_VAR 0 7
17529: ARRAY
17530: PUSH
17531: LD_INT 1
17533: ARRAY
17534: PPUSH
17535: CALL_OW 1
17539: ST_TO_ADDR
17540: GO 17502
17542: POP
17543: POP
// result := tmp ;
17544: LD_ADDR_VAR 0 6
17548: PUSH
17549: LD_VAR 0 9
17553: ST_TO_ADDR
// end ; end ;
17554: LD_VAR 0 6
17558: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17559: LD_INT 0
17561: PPUSH
17562: PPUSH
17563: PPUSH
17564: PPUSH
17565: PPUSH
17566: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17567: LD_ADDR_VAR 0 5
17571: PUSH
17572: LD_INT 0
17574: PUSH
17575: LD_INT 0
17577: PUSH
17578: LD_INT 0
17580: PUSH
17581: EMPTY
17582: PUSH
17583: EMPTY
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: ST_TO_ADDR
// if not x or not y then
17589: LD_VAR 0 2
17593: NOT
17594: IFTRUE 17603
17596: PUSH
17597: LD_VAR 0 3
17601: NOT
17602: OR
17603: IFFALSE 17607
// exit ;
17605: GO 19263
// if not range then
17607: LD_VAR 0 4
17611: NOT
17612: IFFALSE 17622
// range := 10 ;
17614: LD_ADDR_VAR 0 4
17618: PUSH
17619: LD_INT 10
17621: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17622: LD_ADDR_VAR 0 8
17626: PUSH
17627: LD_INT 81
17629: PUSH
17630: LD_VAR 0 1
17634: PUSH
17635: EMPTY
17636: LIST
17637: LIST
17638: PUSH
17639: LD_INT 92
17641: PUSH
17642: LD_VAR 0 2
17646: PUSH
17647: LD_VAR 0 3
17651: PUSH
17652: LD_VAR 0 4
17656: PUSH
17657: EMPTY
17658: LIST
17659: LIST
17660: LIST
17661: LIST
17662: PUSH
17663: LD_INT 3
17665: PUSH
17666: LD_INT 21
17668: PUSH
17669: LD_INT 3
17671: PUSH
17672: EMPTY
17673: LIST
17674: LIST
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: PPUSH
17685: CALL_OW 69
17689: ST_TO_ADDR
// if not tmp then
17690: LD_VAR 0 8
17694: NOT
17695: IFFALSE 17699
// exit ;
17697: GO 19263
// for i in tmp do
17699: LD_ADDR_VAR 0 6
17703: PUSH
17704: LD_VAR 0 8
17708: PUSH
17709: FOR_IN
17710: IFFALSE 19238
// begin points := [ 0 , 0 , 0 ] ;
17712: LD_ADDR_VAR 0 9
17716: PUSH
17717: LD_INT 0
17719: PUSH
17720: LD_INT 0
17722: PUSH
17723: LD_INT 0
17725: PUSH
17726: EMPTY
17727: LIST
17728: LIST
17729: LIST
17730: ST_TO_ADDR
// bpoints := 1 ;
17731: LD_ADDR_VAR 0 10
17735: PUSH
17736: LD_INT 1
17738: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17739: LD_VAR 0 6
17743: PPUSH
17744: CALL_OW 247
17748: PUSH
17749: LD_INT 1
17751: DOUBLE
17752: EQUAL
17753: IFTRUE 17757
17755: GO 18339
17757: POP
// begin if GetClass ( i ) = 1 then
17758: LD_VAR 0 6
17762: PPUSH
17763: CALL_OW 257
17767: PUSH
17768: LD_INT 1
17770: EQUAL
17771: IFFALSE 17792
// points := [ 10 , 5 , 3 ] ;
17773: LD_ADDR_VAR 0 9
17777: PUSH
17778: LD_INT 10
17780: PUSH
17781: LD_INT 5
17783: PUSH
17784: LD_INT 3
17786: PUSH
17787: EMPTY
17788: LIST
17789: LIST
17790: LIST
17791: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17792: LD_VAR 0 6
17796: PPUSH
17797: CALL_OW 257
17801: PUSH
17802: LD_INT 2
17804: PUSH
17805: LD_INT 3
17807: PUSH
17808: LD_INT 4
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: IN
17816: IFFALSE 17837
// points := [ 3 , 2 , 1 ] ;
17818: LD_ADDR_VAR 0 9
17822: PUSH
17823: LD_INT 3
17825: PUSH
17826: LD_INT 2
17828: PUSH
17829: LD_INT 1
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: LIST
17836: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17837: LD_VAR 0 6
17841: PPUSH
17842: CALL_OW 257
17846: PUSH
17847: LD_INT 5
17849: EQUAL
17850: IFFALSE 17871
// points := [ 130 , 5 , 2 ] ;
17852: LD_ADDR_VAR 0 9
17856: PUSH
17857: LD_INT 130
17859: PUSH
17860: LD_INT 5
17862: PUSH
17863: LD_INT 2
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: LIST
17870: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17871: LD_VAR 0 6
17875: PPUSH
17876: CALL_OW 257
17880: PUSH
17881: LD_INT 8
17883: EQUAL
17884: IFFALSE 17905
// points := [ 35 , 35 , 30 ] ;
17886: LD_ADDR_VAR 0 9
17890: PUSH
17891: LD_INT 35
17893: PUSH
17894: LD_INT 35
17896: PUSH
17897: LD_INT 30
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: LIST
17904: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17905: LD_VAR 0 6
17909: PPUSH
17910: CALL_OW 257
17914: PUSH
17915: LD_INT 9
17917: EQUAL
17918: IFFALSE 17939
// points := [ 20 , 55 , 40 ] ;
17920: LD_ADDR_VAR 0 9
17924: PUSH
17925: LD_INT 20
17927: PUSH
17928: LD_INT 55
17930: PUSH
17931: LD_INT 40
17933: PUSH
17934: EMPTY
17935: LIST
17936: LIST
17937: LIST
17938: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17939: LD_VAR 0 6
17943: PPUSH
17944: CALL_OW 257
17948: PUSH
17949: LD_INT 12
17951: PUSH
17952: LD_INT 16
17954: PUSH
17955: EMPTY
17956: LIST
17957: LIST
17958: IN
17959: IFFALSE 17980
// points := [ 5 , 3 , 2 ] ;
17961: LD_ADDR_VAR 0 9
17965: PUSH
17966: LD_INT 5
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: LD_INT 2
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: LIST
17979: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17980: LD_VAR 0 6
17984: PPUSH
17985: CALL_OW 257
17989: PUSH
17990: LD_INT 17
17992: EQUAL
17993: IFFALSE 18014
// points := [ 100 , 50 , 75 ] ;
17995: LD_ADDR_VAR 0 9
17999: PUSH
18000: LD_INT 100
18002: PUSH
18003: LD_INT 50
18005: PUSH
18006: LD_INT 75
18008: PUSH
18009: EMPTY
18010: LIST
18011: LIST
18012: LIST
18013: ST_TO_ADDR
// if GetClass ( i ) = 15 then
18014: LD_VAR 0 6
18018: PPUSH
18019: CALL_OW 257
18023: PUSH
18024: LD_INT 15
18026: EQUAL
18027: IFFALSE 18048
// points := [ 10 , 5 , 3 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 10
18036: PUSH
18037: LD_INT 5
18039: PUSH
18040: LD_INT 3
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetClass ( i ) = 14 then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 257
18057: PUSH
18058: LD_INT 14
18060: EQUAL
18061: IFFALSE 18082
// points := [ 10 , 0 , 0 ] ;
18063: LD_ADDR_VAR 0 9
18067: PUSH
18068: LD_INT 10
18070: PUSH
18071: LD_INT 0
18073: PUSH
18074: LD_INT 0
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: ST_TO_ADDR
// if GetClass ( i ) = 11 then
18082: LD_VAR 0 6
18086: PPUSH
18087: CALL_OW 257
18091: PUSH
18092: LD_INT 11
18094: EQUAL
18095: IFFALSE 18116
// points := [ 30 , 10 , 5 ] ;
18097: LD_ADDR_VAR 0 9
18101: PUSH
18102: LD_INT 30
18104: PUSH
18105: LD_INT 10
18107: PUSH
18108: LD_INT 5
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
18116: LD_VAR 0 1
18120: PPUSH
18121: LD_INT 5
18123: PPUSH
18124: CALL_OW 321
18128: PUSH
18129: LD_INT 2
18131: EQUAL
18132: IFFALSE 18149
// bpoints := bpoints * 1.8 ;
18134: LD_ADDR_VAR 0 10
18138: PUSH
18139: LD_VAR 0 10
18143: PUSH
18144: LD_REAL  1.80000000000000E+0000
18147: MUL
18148: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
18149: LD_VAR 0 6
18153: PPUSH
18154: CALL_OW 257
18158: PUSH
18159: LD_INT 1
18161: PUSH
18162: LD_INT 2
18164: PUSH
18165: LD_INT 3
18167: PUSH
18168: LD_INT 4
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: LIST
18175: LIST
18176: IN
18177: IFFALSE 18197
18179: PUSH
18180: LD_VAR 0 1
18184: PPUSH
18185: LD_INT 51
18187: PPUSH
18188: CALL_OW 321
18192: PUSH
18193: LD_INT 2
18195: EQUAL
18196: AND
18197: IFFALSE 18214
// bpoints := bpoints * 1.2 ;
18199: LD_ADDR_VAR 0 10
18203: PUSH
18204: LD_VAR 0 10
18208: PUSH
18209: LD_REAL  1.20000000000000E+0000
18212: MUL
18213: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
18214: LD_VAR 0 6
18218: PPUSH
18219: CALL_OW 257
18223: PUSH
18224: LD_INT 5
18226: PUSH
18227: LD_INT 7
18229: PUSH
18230: LD_INT 9
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: IN
18238: IFFALSE 18258
18240: PUSH
18241: LD_VAR 0 1
18245: PPUSH
18246: LD_INT 52
18248: PPUSH
18249: CALL_OW 321
18253: PUSH
18254: LD_INT 2
18256: EQUAL
18257: AND
18258: IFFALSE 18275
// bpoints := bpoints * 1.5 ;
18260: LD_ADDR_VAR 0 10
18264: PUSH
18265: LD_VAR 0 10
18269: PUSH
18270: LD_REAL  1.50000000000000E+0000
18273: MUL
18274: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
18275: LD_VAR 0 1
18279: PPUSH
18280: LD_INT 66
18282: PPUSH
18283: CALL_OW 321
18287: PUSH
18288: LD_INT 2
18290: EQUAL
18291: IFFALSE 18308
// bpoints := bpoints * 1.1 ;
18293: LD_ADDR_VAR 0 10
18297: PUSH
18298: LD_VAR 0 10
18302: PUSH
18303: LD_REAL  1.10000000000000E+0000
18306: MUL
18307: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
18308: LD_ADDR_VAR 0 10
18312: PUSH
18313: LD_VAR 0 10
18317: PUSH
18318: LD_VAR 0 6
18322: PPUSH
18323: LD_INT 1
18325: PPUSH
18326: CALL_OW 259
18330: PUSH
18331: LD_REAL  1.15000000000000E+0000
18334: MUL
18335: MUL
18336: ST_TO_ADDR
// end ; unit_vehicle :
18337: GO 19167
18339: LD_INT 2
18341: DOUBLE
18342: EQUAL
18343: IFTRUE 18347
18345: GO 19155
18347: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
18348: LD_VAR 0 6
18352: PPUSH
18353: CALL_OW 264
18357: PUSH
18358: LD_INT 2
18360: PUSH
18361: LD_INT 42
18363: PUSH
18364: LD_INT 24
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: LIST
18371: IN
18372: IFFALSE 18393
// points := [ 25 , 5 , 3 ] ;
18374: LD_ADDR_VAR 0 9
18378: PUSH
18379: LD_INT 25
18381: PUSH
18382: LD_INT 5
18384: PUSH
18385: LD_INT 3
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
18393: LD_VAR 0 6
18397: PPUSH
18398: CALL_OW 264
18402: PUSH
18403: LD_INT 4
18405: PUSH
18406: LD_INT 43
18408: PUSH
18409: LD_INT 25
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: IN
18417: IFFALSE 18438
// points := [ 40 , 15 , 5 ] ;
18419: LD_ADDR_VAR 0 9
18423: PUSH
18424: LD_INT 40
18426: PUSH
18427: LD_INT 15
18429: PUSH
18430: LD_INT 5
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: LIST
18437: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
18438: LD_VAR 0 6
18442: PPUSH
18443: CALL_OW 264
18447: PUSH
18448: LD_INT 3
18450: PUSH
18451: LD_INT 23
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: IN
18458: IFFALSE 18479
// points := [ 7 , 25 , 8 ] ;
18460: LD_ADDR_VAR 0 9
18464: PUSH
18465: LD_INT 7
18467: PUSH
18468: LD_INT 25
18470: PUSH
18471: LD_INT 8
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: LIST
18478: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
18479: LD_VAR 0 6
18483: PPUSH
18484: CALL_OW 264
18488: PUSH
18489: LD_INT 5
18491: PUSH
18492: LD_INT 27
18494: PUSH
18495: LD_INT 44
18497: PUSH
18498: EMPTY
18499: LIST
18500: LIST
18501: LIST
18502: IN
18503: IFFALSE 18524
// points := [ 14 , 50 , 16 ] ;
18505: LD_ADDR_VAR 0 9
18509: PUSH
18510: LD_INT 14
18512: PUSH
18513: LD_INT 50
18515: PUSH
18516: LD_INT 16
18518: PUSH
18519: EMPTY
18520: LIST
18521: LIST
18522: LIST
18523: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18524: LD_VAR 0 6
18528: PPUSH
18529: CALL_OW 264
18533: PUSH
18534: LD_INT 6
18536: PUSH
18537: LD_INT 46
18539: PUSH
18540: EMPTY
18541: LIST
18542: LIST
18543: IN
18544: IFFALSE 18565
// points := [ 32 , 120 , 70 ] ;
18546: LD_ADDR_VAR 0 9
18550: PUSH
18551: LD_INT 32
18553: PUSH
18554: LD_INT 120
18556: PUSH
18557: LD_INT 70
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: LIST
18564: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18565: LD_VAR 0 6
18569: PPUSH
18570: CALL_OW 264
18574: PUSH
18575: LD_INT 7
18577: PUSH
18578: LD_INT 28
18580: PUSH
18581: LD_INT 45
18583: PUSH
18584: LD_INT 92
18586: PUSH
18587: EMPTY
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: IN
18593: IFFALSE 18614
// points := [ 35 , 20 , 45 ] ;
18595: LD_ADDR_VAR 0 9
18599: PUSH
18600: LD_INT 35
18602: PUSH
18603: LD_INT 20
18605: PUSH
18606: LD_INT 45
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18614: LD_VAR 0 6
18618: PPUSH
18619: CALL_OW 264
18623: PUSH
18624: LD_INT 47
18626: PUSH
18627: EMPTY
18628: LIST
18629: IN
18630: IFFALSE 18651
// points := [ 67 , 45 , 75 ] ;
18632: LD_ADDR_VAR 0 9
18636: PUSH
18637: LD_INT 67
18639: PUSH
18640: LD_INT 45
18642: PUSH
18643: LD_INT 75
18645: PUSH
18646: EMPTY
18647: LIST
18648: LIST
18649: LIST
18650: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18651: LD_VAR 0 6
18655: PPUSH
18656: CALL_OW 264
18660: PUSH
18661: LD_INT 26
18663: PUSH
18664: EMPTY
18665: LIST
18666: IN
18667: IFFALSE 18688
// points := [ 120 , 30 , 80 ] ;
18669: LD_ADDR_VAR 0 9
18673: PUSH
18674: LD_INT 120
18676: PUSH
18677: LD_INT 30
18679: PUSH
18680: LD_INT 80
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: LIST
18687: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18688: LD_VAR 0 6
18692: PPUSH
18693: CALL_OW 264
18697: PUSH
18698: LD_INT 22
18700: PUSH
18701: EMPTY
18702: LIST
18703: IN
18704: IFFALSE 18725
// points := [ 40 , 1 , 1 ] ;
18706: LD_ADDR_VAR 0 9
18710: PUSH
18711: LD_INT 40
18713: PUSH
18714: LD_INT 1
18716: PUSH
18717: LD_INT 1
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: LIST
18724: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18725: LD_VAR 0 6
18729: PPUSH
18730: CALL_OW 264
18734: PUSH
18735: LD_INT 29
18737: PUSH
18738: EMPTY
18739: LIST
18740: IN
18741: IFFALSE 18762
// points := [ 70 , 200 , 400 ] ;
18743: LD_ADDR_VAR 0 9
18747: PUSH
18748: LD_INT 70
18750: PUSH
18751: LD_INT 200
18753: PUSH
18754: LD_INT 400
18756: PUSH
18757: EMPTY
18758: LIST
18759: LIST
18760: LIST
18761: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18762: LD_VAR 0 6
18766: PPUSH
18767: CALL_OW 264
18771: PUSH
18772: LD_INT 14
18774: PUSH
18775: LD_INT 53
18777: PUSH
18778: EMPTY
18779: LIST
18780: LIST
18781: IN
18782: IFFALSE 18803
// points := [ 40 , 10 , 20 ] ;
18784: LD_ADDR_VAR 0 9
18788: PUSH
18789: LD_INT 40
18791: PUSH
18792: LD_INT 10
18794: PUSH
18795: LD_INT 20
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: LIST
18802: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18803: LD_VAR 0 6
18807: PPUSH
18808: CALL_OW 264
18812: PUSH
18813: LD_INT 9
18815: PUSH
18816: EMPTY
18817: LIST
18818: IN
18819: IFFALSE 18840
// points := [ 5 , 70 , 20 ] ;
18821: LD_ADDR_VAR 0 9
18825: PUSH
18826: LD_INT 5
18828: PUSH
18829: LD_INT 70
18831: PUSH
18832: LD_INT 20
18834: PUSH
18835: EMPTY
18836: LIST
18837: LIST
18838: LIST
18839: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18840: LD_VAR 0 6
18844: PPUSH
18845: CALL_OW 264
18849: PUSH
18850: LD_INT 10
18852: PUSH
18853: EMPTY
18854: LIST
18855: IN
18856: IFFALSE 18877
// points := [ 35 , 110 , 70 ] ;
18858: LD_ADDR_VAR 0 9
18862: PUSH
18863: LD_INT 35
18865: PUSH
18866: LD_INT 110
18868: PUSH
18869: LD_INT 70
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18877: LD_VAR 0 6
18881: PPUSH
18882: CALL_OW 265
18886: PUSH
18887: LD_INT 25
18889: EQUAL
18890: IFFALSE 18911
// points := [ 80 , 65 , 100 ] ;
18892: LD_ADDR_VAR 0 9
18896: PUSH
18897: LD_INT 80
18899: PUSH
18900: LD_INT 65
18902: PUSH
18903: LD_INT 100
18905: PUSH
18906: EMPTY
18907: LIST
18908: LIST
18909: LIST
18910: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18911: LD_VAR 0 6
18915: PPUSH
18916: CALL_OW 263
18920: PUSH
18921: LD_INT 1
18923: EQUAL
18924: IFFALSE 18959
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18926: LD_ADDR_VAR 0 10
18930: PUSH
18931: LD_VAR 0 10
18935: PUSH
18936: LD_VAR 0 6
18940: PPUSH
18941: CALL_OW 311
18945: PPUSH
18946: LD_INT 3
18948: PPUSH
18949: CALL_OW 259
18953: PUSH
18954: LD_INT 4
18956: MUL
18957: MUL
18958: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18959: LD_VAR 0 6
18963: PPUSH
18964: CALL_OW 263
18968: PUSH
18969: LD_INT 2
18971: EQUAL
18972: IFFALSE 19023
// begin j := IsControledBy ( i ) ;
18974: LD_ADDR_VAR 0 7
18978: PUSH
18979: LD_VAR 0 6
18983: PPUSH
18984: CALL_OW 312
18988: ST_TO_ADDR
// if j then
18989: LD_VAR 0 7
18993: IFFALSE 19023
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18995: LD_ADDR_VAR 0 10
18999: PUSH
19000: LD_VAR 0 10
19004: PUSH
19005: LD_VAR 0 7
19009: PPUSH
19010: LD_INT 3
19012: PPUSH
19013: CALL_OW 259
19017: PUSH
19018: LD_INT 3
19020: MUL
19021: MUL
19022: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
19023: LD_VAR 0 6
19027: PPUSH
19028: CALL_OW 264
19032: PUSH
19033: LD_INT 5
19035: PUSH
19036: LD_INT 6
19038: PUSH
19039: LD_INT 46
19041: PUSH
19042: LD_INT 44
19044: PUSH
19045: LD_INT 47
19047: PUSH
19048: LD_INT 45
19050: PUSH
19051: LD_INT 28
19053: PUSH
19054: LD_INT 7
19056: PUSH
19057: LD_INT 27
19059: PUSH
19060: LD_INT 29
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: LIST
19072: LIST
19073: LIST
19074: IN
19075: IFFALSE 19095
19077: PUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: LD_INT 52
19085: PPUSH
19086: CALL_OW 321
19090: PUSH
19091: LD_INT 2
19093: EQUAL
19094: AND
19095: IFFALSE 19112
// bpoints := bpoints * 1.2 ;
19097: LD_ADDR_VAR 0 10
19101: PUSH
19102: LD_VAR 0 10
19106: PUSH
19107: LD_REAL  1.20000000000000E+0000
19110: MUL
19111: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
19112: LD_VAR 0 6
19116: PPUSH
19117: CALL_OW 264
19121: PUSH
19122: LD_INT 6
19124: PUSH
19125: LD_INT 46
19127: PUSH
19128: LD_INT 47
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: IN
19136: IFFALSE 19153
// bpoints := bpoints * 1.2 ;
19138: LD_ADDR_VAR 0 10
19142: PUSH
19143: LD_VAR 0 10
19147: PUSH
19148: LD_REAL  1.20000000000000E+0000
19151: MUL
19152: ST_TO_ADDR
// end ; unit_building :
19153: GO 19167
19155: LD_INT 3
19157: DOUBLE
19158: EQUAL
19159: IFTRUE 19163
19161: GO 19166
19163: POP
// ; end ;
19164: GO 19167
19166: POP
// for j = 1 to 3 do
19167: LD_ADDR_VAR 0 7
19171: PUSH
19172: DOUBLE
19173: LD_INT 1
19175: DEC
19176: ST_TO_ADDR
19177: LD_INT 3
19179: PUSH
19180: FOR_TO
19181: IFFALSE 19234
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
19183: LD_ADDR_VAR 0 5
19187: PUSH
19188: LD_VAR 0 5
19192: PPUSH
19193: LD_VAR 0 7
19197: PPUSH
19198: LD_VAR 0 5
19202: PUSH
19203: LD_VAR 0 7
19207: ARRAY
19208: PUSH
19209: LD_VAR 0 9
19213: PUSH
19214: LD_VAR 0 7
19218: ARRAY
19219: PUSH
19220: LD_VAR 0 10
19224: MUL
19225: PLUS
19226: PPUSH
19227: CALL_OW 1
19231: ST_TO_ADDR
19232: GO 19180
19234: POP
19235: POP
// end ;
19236: GO 17709
19238: POP
19239: POP
// result := Replace ( result , 4 , tmp ) ;
19240: LD_ADDR_VAR 0 5
19244: PUSH
19245: LD_VAR 0 5
19249: PPUSH
19250: LD_INT 4
19252: PPUSH
19253: LD_VAR 0 8
19257: PPUSH
19258: CALL_OW 1
19262: ST_TO_ADDR
// end ;
19263: LD_VAR 0 5
19267: RET
// export function DangerAtRange ( unit , range ) ; begin
19268: LD_INT 0
19270: PPUSH
// if not unit then
19271: LD_VAR 0 1
19275: NOT
19276: IFFALSE 19280
// exit ;
19278: GO 19325
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
19280: LD_ADDR_VAR 0 3
19284: PUSH
19285: LD_VAR 0 1
19289: PPUSH
19290: CALL_OW 255
19294: PPUSH
19295: LD_VAR 0 1
19299: PPUSH
19300: CALL_OW 250
19304: PPUSH
19305: LD_VAR 0 1
19309: PPUSH
19310: CALL_OW 251
19314: PPUSH
19315: LD_VAR 0 2
19319: PPUSH
19320: CALL 17559 0 4
19324: ST_TO_ADDR
// end ;
19325: LD_VAR 0 3
19329: RET
// export function DangerInArea ( side , area ) ; begin
19330: LD_INT 0
19332: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
19333: LD_ADDR_VAR 0 3
19337: PUSH
19338: LD_VAR 0 2
19342: PPUSH
19343: LD_INT 81
19345: PUSH
19346: LD_VAR 0 1
19350: PUSH
19351: EMPTY
19352: LIST
19353: LIST
19354: PPUSH
19355: CALL_OW 70
19359: ST_TO_ADDR
// end ;
19360: LD_VAR 0 3
19364: RET
// export function IsExtension ( b ) ; begin
19365: LD_INT 0
19367: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
19368: LD_ADDR_VAR 0 2
19372: PUSH
19373: LD_VAR 0 1
19377: PUSH
19378: LD_INT 23
19380: PUSH
19381: LD_INT 20
19383: PUSH
19384: LD_INT 22
19386: PUSH
19387: LD_INT 17
19389: PUSH
19390: LD_INT 24
19392: PUSH
19393: LD_INT 21
19395: PUSH
19396: LD_INT 19
19398: PUSH
19399: LD_INT 16
19401: PUSH
19402: LD_INT 25
19404: PUSH
19405: LD_INT 18
19407: PUSH
19408: EMPTY
19409: LIST
19410: LIST
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: IN
19420: ST_TO_ADDR
// end ;
19421: LD_VAR 0 2
19425: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
19426: LD_INT 0
19428: PPUSH
19429: PPUSH
19430: PPUSH
// result := [ ] ;
19431: LD_ADDR_VAR 0 4
19435: PUSH
19436: EMPTY
19437: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
19438: LD_ADDR_VAR 0 5
19442: PUSH
19443: LD_VAR 0 2
19447: PPUSH
19448: LD_INT 21
19450: PUSH
19451: LD_INT 3
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PPUSH
19458: CALL_OW 70
19462: ST_TO_ADDR
// if not tmp then
19463: LD_VAR 0 5
19467: NOT
19468: IFFALSE 19472
// exit ;
19470: GO 19536
// if checkLink then
19472: LD_VAR 0 3
19476: IFFALSE 19526
// begin for i in tmp do
19478: LD_ADDR_VAR 0 6
19482: PUSH
19483: LD_VAR 0 5
19487: PUSH
19488: FOR_IN
19489: IFFALSE 19524
// if GetBase ( i ) <> base then
19491: LD_VAR 0 6
19495: PPUSH
19496: CALL_OW 274
19500: PUSH
19501: LD_VAR 0 1
19505: NONEQUAL
19506: IFFALSE 19522
// ComLinkToBase ( base , i ) ;
19508: LD_VAR 0 1
19512: PPUSH
19513: LD_VAR 0 6
19517: PPUSH
19518: CALL_OW 169
19522: GO 19488
19524: POP
19525: POP
// end ; result := tmp ;
19526: LD_ADDR_VAR 0 4
19530: PUSH
19531: LD_VAR 0 5
19535: ST_TO_ADDR
// end ;
19536: LD_VAR 0 4
19540: RET
// export function ComComplete ( units , b ) ; var i ; begin
19541: LD_INT 0
19543: PPUSH
19544: PPUSH
// if not units then
19545: LD_VAR 0 1
19549: NOT
19550: IFFALSE 19554
// exit ;
19552: GO 19644
// for i in units do
19554: LD_ADDR_VAR 0 4
19558: PUSH
19559: LD_VAR 0 1
19563: PUSH
19564: FOR_IN
19565: IFFALSE 19642
// if BuildingStatus ( b ) = bs_build then
19567: LD_VAR 0 2
19571: PPUSH
19572: CALL_OW 461
19576: PUSH
19577: LD_INT 1
19579: EQUAL
19580: IFFALSE 19640
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19582: LD_VAR 0 4
19586: PPUSH
19587: LD_STRING h
19589: PUSH
19590: LD_VAR 0 2
19594: PPUSH
19595: CALL_OW 250
19599: PUSH
19600: LD_VAR 0 2
19604: PPUSH
19605: CALL_OW 251
19609: PUSH
19610: LD_VAR 0 2
19614: PUSH
19615: LD_INT 0
19617: PUSH
19618: LD_INT 0
19620: PUSH
19621: LD_INT 0
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: LIST
19628: LIST
19629: LIST
19630: LIST
19631: LIST
19632: PUSH
19633: EMPTY
19634: LIST
19635: PPUSH
19636: CALL_OW 446
19640: GO 19564
19642: POP
19643: POP
// end ;
19644: LD_VAR 0 3
19648: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19649: LD_INT 0
19651: PPUSH
19652: PPUSH
19653: PPUSH
19654: PPUSH
19655: PPUSH
19656: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19657: LD_VAR 0 1
19661: NOT
19662: IFTRUE 19679
19664: PUSH
19665: LD_VAR 0 1
19669: PPUSH
19670: CALL_OW 263
19674: PUSH
19675: LD_INT 2
19677: NONEQUAL
19678: OR
19679: IFFALSE 19683
// exit ;
19681: GO 19999
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19683: LD_ADDR_VAR 0 6
19687: PUSH
19688: LD_INT 22
19690: PUSH
19691: LD_VAR 0 1
19695: PPUSH
19696: CALL_OW 255
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: PUSH
19705: LD_INT 2
19707: PUSH
19708: LD_INT 30
19710: PUSH
19711: LD_INT 36
19713: PUSH
19714: EMPTY
19715: LIST
19716: LIST
19717: PUSH
19718: LD_INT 34
19720: PUSH
19721: LD_INT 31
19723: PUSH
19724: EMPTY
19725: LIST
19726: LIST
19727: PUSH
19728: EMPTY
19729: LIST
19730: LIST
19731: LIST
19732: PUSH
19733: EMPTY
19734: LIST
19735: LIST
19736: PPUSH
19737: CALL_OW 69
19741: ST_TO_ADDR
// if not tmp then
19742: LD_VAR 0 6
19746: NOT
19747: IFFALSE 19751
// exit ;
19749: GO 19999
// result := [ ] ;
19751: LD_ADDR_VAR 0 2
19755: PUSH
19756: EMPTY
19757: ST_TO_ADDR
// for i in tmp do
19758: LD_ADDR_VAR 0 3
19762: PUSH
19763: LD_VAR 0 6
19767: PUSH
19768: FOR_IN
19769: IFFALSE 19840
// begin t := UnitsInside ( i ) ;
19771: LD_ADDR_VAR 0 4
19775: PUSH
19776: LD_VAR 0 3
19780: PPUSH
19781: CALL_OW 313
19785: ST_TO_ADDR
// if t then
19786: LD_VAR 0 4
19790: IFFALSE 19838
// for j in t do
19792: LD_ADDR_VAR 0 7
19796: PUSH
19797: LD_VAR 0 4
19801: PUSH
19802: FOR_IN
19803: IFFALSE 19836
// result := Replace ( result , result + 1 , j ) ;
19805: LD_ADDR_VAR 0 2
19809: PUSH
19810: LD_VAR 0 2
19814: PPUSH
19815: LD_VAR 0 2
19819: PUSH
19820: LD_INT 1
19822: PLUS
19823: PPUSH
19824: LD_VAR 0 7
19828: PPUSH
19829: CALL_OW 1
19833: ST_TO_ADDR
19834: GO 19802
19836: POP
19837: POP
// end ;
19838: GO 19768
19840: POP
19841: POP
// if not result then
19842: LD_VAR 0 2
19846: NOT
19847: IFFALSE 19851
// exit ;
19849: GO 19999
// mech := result [ 1 ] ;
19851: LD_ADDR_VAR 0 5
19855: PUSH
19856: LD_VAR 0 2
19860: PUSH
19861: LD_INT 1
19863: ARRAY
19864: ST_TO_ADDR
// if result > 1 then
19865: LD_VAR 0 2
19869: PUSH
19870: LD_INT 1
19872: GREATER
19873: IFFALSE 19985
// begin for i = 2 to result do
19875: LD_ADDR_VAR 0 3
19879: PUSH
19880: DOUBLE
19881: LD_INT 2
19883: DEC
19884: ST_TO_ADDR
19885: LD_VAR 0 2
19889: PUSH
19890: FOR_TO
19891: IFFALSE 19983
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19893: LD_ADDR_VAR 0 4
19897: PUSH
19898: LD_VAR 0 2
19902: PUSH
19903: LD_VAR 0 3
19907: ARRAY
19908: PPUSH
19909: LD_INT 3
19911: PPUSH
19912: CALL_OW 259
19916: PUSH
19917: LD_VAR 0 2
19921: PUSH
19922: LD_VAR 0 3
19926: ARRAY
19927: PPUSH
19928: CALL_OW 432
19932: MINUS
19933: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19934: LD_VAR 0 4
19938: PUSH
19939: LD_VAR 0 5
19943: PPUSH
19944: LD_INT 3
19946: PPUSH
19947: CALL_OW 259
19951: PUSH
19952: LD_VAR 0 5
19956: PPUSH
19957: CALL_OW 432
19961: MINUS
19962: GREATEREQUAL
19963: IFFALSE 19981
// mech := result [ i ] ;
19965: LD_ADDR_VAR 0 5
19969: PUSH
19970: LD_VAR 0 2
19974: PUSH
19975: LD_VAR 0 3
19979: ARRAY
19980: ST_TO_ADDR
// end ;
19981: GO 19890
19983: POP
19984: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19985: LD_VAR 0 1
19989: PPUSH
19990: LD_VAR 0 5
19994: PPUSH
19995: CALL_OW 135
// end ;
19999: LD_VAR 0 2
20003: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
20004: LD_INT 0
20006: PPUSH
20007: PPUSH
20008: PPUSH
20009: PPUSH
20010: PPUSH
20011: PPUSH
20012: PPUSH
20013: PPUSH
20014: PPUSH
20015: PPUSH
20016: PPUSH
20017: PPUSH
20018: PPUSH
// result := [ ] ;
20019: LD_ADDR_VAR 0 7
20023: PUSH
20024: EMPTY
20025: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
20026: LD_VAR 0 1
20030: PPUSH
20031: CALL_OW 266
20035: PUSH
20036: LD_INT 0
20038: PUSH
20039: LD_INT 1
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: IN
20046: NOT
20047: IFFALSE 20051
// exit ;
20049: GO 21691
// if name then
20051: LD_VAR 0 3
20055: IFFALSE 20071
// SetBName ( base_dep , name ) ;
20057: LD_VAR 0 1
20061: PPUSH
20062: LD_VAR 0 3
20066: PPUSH
20067: CALL_OW 500
// base := GetBase ( base_dep ) ;
20071: LD_ADDR_VAR 0 15
20075: PUSH
20076: LD_VAR 0 1
20080: PPUSH
20081: CALL_OW 274
20085: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
20086: LD_ADDR_VAR 0 16
20090: PUSH
20091: LD_VAR 0 1
20095: PPUSH
20096: CALL_OW 255
20100: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
20101: LD_ADDR_VAR 0 17
20105: PUSH
20106: LD_VAR 0 1
20110: PPUSH
20111: CALL_OW 248
20115: ST_TO_ADDR
// if sources then
20116: LD_VAR 0 5
20120: IFFALSE 20167
// for i = 1 to 3 do
20122: LD_ADDR_VAR 0 8
20126: PUSH
20127: DOUBLE
20128: LD_INT 1
20130: DEC
20131: ST_TO_ADDR
20132: LD_INT 3
20134: PUSH
20135: FOR_TO
20136: IFFALSE 20165
// AddResourceType ( base , i , sources [ i ] ) ;
20138: LD_VAR 0 15
20142: PPUSH
20143: LD_VAR 0 8
20147: PPUSH
20148: LD_VAR 0 5
20152: PUSH
20153: LD_VAR 0 8
20157: ARRAY
20158: PPUSH
20159: CALL_OW 276
20163: GO 20135
20165: POP
20166: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
20167: LD_ADDR_VAR 0 18
20171: PUSH
20172: LD_VAR 0 15
20176: PPUSH
20177: LD_VAR 0 2
20181: PPUSH
20182: LD_INT 1
20184: PPUSH
20185: CALL 19426 0 3
20189: ST_TO_ADDR
// InitHc ;
20190: CALL_OW 19
// InitUc ;
20194: CALL_OW 18
// uc_side := side ;
20198: LD_ADDR_OWVAR 20
20202: PUSH
20203: LD_VAR 0 16
20207: ST_TO_ADDR
// uc_nation := nation ;
20208: LD_ADDR_OWVAR 21
20212: PUSH
20213: LD_VAR 0 17
20217: ST_TO_ADDR
// if buildings then
20218: LD_VAR 0 18
20222: IFFALSE 21550
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
20224: LD_ADDR_VAR 0 19
20228: PUSH
20229: LD_VAR 0 18
20233: PPUSH
20234: LD_INT 2
20236: PUSH
20237: LD_INT 30
20239: PUSH
20240: LD_INT 29
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: PUSH
20247: LD_INT 30
20249: PUSH
20250: LD_INT 30
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: LIST
20261: PPUSH
20262: CALL_OW 72
20266: ST_TO_ADDR
// if tmp then
20267: LD_VAR 0 19
20271: IFFALSE 20319
// for i in tmp do
20273: LD_ADDR_VAR 0 8
20277: PUSH
20278: LD_VAR 0 19
20282: PUSH
20283: FOR_IN
20284: IFFALSE 20317
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
20286: LD_VAR 0 8
20290: PPUSH
20291: CALL_OW 250
20295: PPUSH
20296: LD_VAR 0 8
20300: PPUSH
20301: CALL_OW 251
20305: PPUSH
20306: LD_VAR 0 16
20310: PPUSH
20311: CALL_OW 441
20315: GO 20283
20317: POP
20318: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
20319: LD_VAR 0 18
20323: PPUSH
20324: LD_INT 2
20326: PUSH
20327: LD_INT 30
20329: PUSH
20330: LD_INT 32
20332: PUSH
20333: EMPTY
20334: LIST
20335: LIST
20336: PUSH
20337: LD_INT 30
20339: PUSH
20340: LD_INT 33
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: EMPTY
20348: LIST
20349: LIST
20350: LIST
20351: PPUSH
20352: CALL_OW 72
20356: IFFALSE 20444
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
20358: LD_ADDR_VAR 0 8
20362: PUSH
20363: LD_VAR 0 18
20367: PPUSH
20368: LD_INT 2
20370: PUSH
20371: LD_INT 30
20373: PUSH
20374: LD_INT 32
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PUSH
20381: LD_INT 30
20383: PUSH
20384: LD_INT 33
20386: PUSH
20387: EMPTY
20388: LIST
20389: LIST
20390: PUSH
20391: EMPTY
20392: LIST
20393: LIST
20394: LIST
20395: PPUSH
20396: CALL_OW 72
20400: PUSH
20401: FOR_IN
20402: IFFALSE 20442
// begin if not GetBWeapon ( i ) then
20404: LD_VAR 0 8
20408: PPUSH
20409: CALL_OW 269
20413: NOT
20414: IFFALSE 20440
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
20416: LD_VAR 0 8
20420: PPUSH
20421: LD_VAR 0 8
20425: PPUSH
20426: LD_VAR 0 2
20430: PPUSH
20431: CALL 21696 0 2
20435: PPUSH
20436: CALL_OW 431
// end ;
20440: GO 20401
20442: POP
20443: POP
// end ; for i = 1 to personel do
20444: LD_ADDR_VAR 0 8
20448: PUSH
20449: DOUBLE
20450: LD_INT 1
20452: DEC
20453: ST_TO_ADDR
20454: LD_VAR 0 6
20458: PUSH
20459: FOR_TO
20460: IFFALSE 21530
// begin if i > 4 then
20462: LD_VAR 0 8
20466: PUSH
20467: LD_INT 4
20469: GREATER
20470: IFFALSE 20474
// break ;
20472: GO 21530
// case i of 1 :
20474: LD_VAR 0 8
20478: PUSH
20479: LD_INT 1
20481: DOUBLE
20482: EQUAL
20483: IFTRUE 20487
20485: GO 20567
20487: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
20488: LD_ADDR_VAR 0 12
20492: PUSH
20493: LD_VAR 0 18
20497: PPUSH
20498: LD_INT 22
20500: PUSH
20501: LD_VAR 0 16
20505: PUSH
20506: EMPTY
20507: LIST
20508: LIST
20509: PUSH
20510: LD_INT 58
20512: PUSH
20513: EMPTY
20514: LIST
20515: PUSH
20516: LD_INT 2
20518: PUSH
20519: LD_INT 30
20521: PUSH
20522: LD_INT 32
20524: PUSH
20525: EMPTY
20526: LIST
20527: LIST
20528: PUSH
20529: LD_INT 30
20531: PUSH
20532: LD_INT 4
20534: PUSH
20535: EMPTY
20536: LIST
20537: LIST
20538: PUSH
20539: LD_INT 30
20541: PUSH
20542: LD_INT 5
20544: PUSH
20545: EMPTY
20546: LIST
20547: LIST
20548: PUSH
20549: EMPTY
20550: LIST
20551: LIST
20552: LIST
20553: LIST
20554: PUSH
20555: EMPTY
20556: LIST
20557: LIST
20558: LIST
20559: PPUSH
20560: CALL_OW 72
20564: ST_TO_ADDR
20565: GO 20789
20567: LD_INT 2
20569: DOUBLE
20570: EQUAL
20571: IFTRUE 20575
20573: GO 20637
20575: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20576: LD_ADDR_VAR 0 12
20580: PUSH
20581: LD_VAR 0 18
20585: PPUSH
20586: LD_INT 22
20588: PUSH
20589: LD_VAR 0 16
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 2
20600: PUSH
20601: LD_INT 30
20603: PUSH
20604: LD_INT 0
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: PUSH
20611: LD_INT 30
20613: PUSH
20614: LD_INT 1
20616: PUSH
20617: EMPTY
20618: LIST
20619: LIST
20620: PUSH
20621: EMPTY
20622: LIST
20623: LIST
20624: LIST
20625: PUSH
20626: EMPTY
20627: LIST
20628: LIST
20629: PPUSH
20630: CALL_OW 72
20634: ST_TO_ADDR
20635: GO 20789
20637: LD_INT 3
20639: DOUBLE
20640: EQUAL
20641: IFTRUE 20645
20643: GO 20707
20645: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20646: LD_ADDR_VAR 0 12
20650: PUSH
20651: LD_VAR 0 18
20655: PPUSH
20656: LD_INT 22
20658: PUSH
20659: LD_VAR 0 16
20663: PUSH
20664: EMPTY
20665: LIST
20666: LIST
20667: PUSH
20668: LD_INT 2
20670: PUSH
20671: LD_INT 30
20673: PUSH
20674: LD_INT 2
20676: PUSH
20677: EMPTY
20678: LIST
20679: LIST
20680: PUSH
20681: LD_INT 30
20683: PUSH
20684: LD_INT 3
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: PUSH
20691: EMPTY
20692: LIST
20693: LIST
20694: LIST
20695: PUSH
20696: EMPTY
20697: LIST
20698: LIST
20699: PPUSH
20700: CALL_OW 72
20704: ST_TO_ADDR
20705: GO 20789
20707: LD_INT 4
20709: DOUBLE
20710: EQUAL
20711: IFTRUE 20715
20713: GO 20788
20715: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20716: LD_ADDR_VAR 0 12
20720: PUSH
20721: LD_VAR 0 18
20725: PPUSH
20726: LD_INT 22
20728: PUSH
20729: LD_VAR 0 16
20733: PUSH
20734: EMPTY
20735: LIST
20736: LIST
20737: PUSH
20738: LD_INT 2
20740: PUSH
20741: LD_INT 30
20743: PUSH
20744: LD_INT 6
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: PUSH
20751: LD_INT 30
20753: PUSH
20754: LD_INT 7
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PUSH
20761: LD_INT 30
20763: PUSH
20764: LD_INT 8
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: LIST
20775: LIST
20776: PUSH
20777: EMPTY
20778: LIST
20779: LIST
20780: PPUSH
20781: CALL_OW 72
20785: ST_TO_ADDR
20786: GO 20789
20788: POP
// if i = 1 then
20789: LD_VAR 0 8
20793: PUSH
20794: LD_INT 1
20796: EQUAL
20797: IFFALSE 20908
// begin tmp := [ ] ;
20799: LD_ADDR_VAR 0 19
20803: PUSH
20804: EMPTY
20805: ST_TO_ADDR
// for j in f do
20806: LD_ADDR_VAR 0 9
20810: PUSH
20811: LD_VAR 0 12
20815: PUSH
20816: FOR_IN
20817: IFFALSE 20890
// if GetBType ( j ) = b_bunker then
20819: LD_VAR 0 9
20823: PPUSH
20824: CALL_OW 266
20828: PUSH
20829: LD_INT 32
20831: EQUAL
20832: IFFALSE 20859
// tmp := Insert ( tmp , 1 , j ) else
20834: LD_ADDR_VAR 0 19
20838: PUSH
20839: LD_VAR 0 19
20843: PPUSH
20844: LD_INT 1
20846: PPUSH
20847: LD_VAR 0 9
20851: PPUSH
20852: CALL_OW 2
20856: ST_TO_ADDR
20857: GO 20888
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20859: LD_ADDR_VAR 0 19
20863: PUSH
20864: LD_VAR 0 19
20868: PPUSH
20869: LD_VAR 0 19
20873: PUSH
20874: LD_INT 1
20876: PLUS
20877: PPUSH
20878: LD_VAR 0 9
20882: PPUSH
20883: CALL_OW 2
20887: ST_TO_ADDR
20888: GO 20816
20890: POP
20891: POP
// if tmp then
20892: LD_VAR 0 19
20896: IFFALSE 20908
// f := tmp ;
20898: LD_ADDR_VAR 0 12
20902: PUSH
20903: LD_VAR 0 19
20907: ST_TO_ADDR
// end ; x := personel [ i ] ;
20908: LD_ADDR_VAR 0 13
20912: PUSH
20913: LD_VAR 0 6
20917: PUSH
20918: LD_VAR 0 8
20922: ARRAY
20923: ST_TO_ADDR
// if x = - 1 then
20924: LD_VAR 0 13
20928: PUSH
20929: LD_INT 1
20931: NEG
20932: EQUAL
20933: IFFALSE 21144
// begin for j in f do
20935: LD_ADDR_VAR 0 9
20939: PUSH
20940: LD_VAR 0 12
20944: PUSH
20945: FOR_IN
20946: IFFALSE 21140
// repeat InitHc ;
20948: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20952: LD_VAR 0 9
20956: PPUSH
20957: CALL_OW 266
20961: PUSH
20962: LD_INT 5
20964: EQUAL
20965: IFFALSE 21035
// begin if UnitsInside ( j ) < 3 then
20967: LD_VAR 0 9
20971: PPUSH
20972: CALL_OW 313
20976: PUSH
20977: LD_INT 3
20979: LESS
20980: IFFALSE 21016
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20982: LD_INT 0
20984: PPUSH
20985: LD_INT 5
20987: PUSH
20988: LD_INT 8
20990: PUSH
20991: LD_INT 9
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: LIST
20998: PUSH
20999: LD_VAR 0 17
21003: ARRAY
21004: PPUSH
21005: LD_VAR 0 4
21009: PPUSH
21010: CALL_OW 380
21014: GO 21033
// PrepareHuman ( false , i , skill ) ;
21016: LD_INT 0
21018: PPUSH
21019: LD_VAR 0 8
21023: PPUSH
21024: LD_VAR 0 4
21028: PPUSH
21029: CALL_OW 380
// end else
21033: GO 21052
// PrepareHuman ( false , i , skill ) ;
21035: LD_INT 0
21037: PPUSH
21038: LD_VAR 0 8
21042: PPUSH
21043: LD_VAR 0 4
21047: PPUSH
21048: CALL_OW 380
// un := CreateHuman ;
21052: LD_ADDR_VAR 0 14
21056: PUSH
21057: CALL_OW 44
21061: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21062: LD_ADDR_VAR 0 7
21066: PUSH
21067: LD_VAR 0 7
21071: PPUSH
21072: LD_INT 1
21074: PPUSH
21075: LD_VAR 0 14
21079: PPUSH
21080: CALL_OW 2
21084: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
21085: LD_VAR 0 14
21089: PPUSH
21090: LD_VAR 0 9
21094: PPUSH
21095: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
21099: LD_VAR 0 9
21103: PPUSH
21104: CALL_OW 313
21108: PUSH
21109: LD_INT 6
21111: EQUAL
21112: IFTRUE 21136
21114: PUSH
21115: LD_VAR 0 9
21119: PPUSH
21120: CALL_OW 266
21124: PUSH
21125: LD_INT 32
21127: PUSH
21128: LD_INT 31
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: IN
21135: OR
21136: IFFALSE 20948
21138: GO 20945
21140: POP
21141: POP
// end else
21142: GO 21528
// for j = 1 to x do
21144: LD_ADDR_VAR 0 9
21148: PUSH
21149: DOUBLE
21150: LD_INT 1
21152: DEC
21153: ST_TO_ADDR
21154: LD_VAR 0 13
21158: PUSH
21159: FOR_TO
21160: IFFALSE 21526
// begin InitHc ;
21162: CALL_OW 19
// if not f then
21166: LD_VAR 0 12
21170: NOT
21171: IFFALSE 21260
// begin PrepareHuman ( false , i , skill ) ;
21173: LD_INT 0
21175: PPUSH
21176: LD_VAR 0 8
21180: PPUSH
21181: LD_VAR 0 4
21185: PPUSH
21186: CALL_OW 380
// un := CreateHuman ;
21190: LD_ADDR_VAR 0 14
21194: PUSH
21195: CALL_OW 44
21199: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21200: LD_ADDR_VAR 0 7
21204: PUSH
21205: LD_VAR 0 7
21209: PPUSH
21210: LD_INT 1
21212: PPUSH
21213: LD_VAR 0 14
21217: PPUSH
21218: CALL_OW 2
21222: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21223: LD_VAR 0 14
21227: PPUSH
21228: LD_VAR 0 1
21232: PPUSH
21233: CALL_OW 250
21237: PPUSH
21238: LD_VAR 0 1
21242: PPUSH
21243: CALL_OW 251
21247: PPUSH
21248: LD_INT 10
21250: PPUSH
21251: LD_INT 0
21253: PPUSH
21254: CALL_OW 50
// continue ;
21258: GO 21159
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
21260: LD_VAR 0 12
21264: PUSH
21265: LD_INT 1
21267: ARRAY
21268: PPUSH
21269: CALL_OW 313
21273: IFFALSE 21301
21275: PUSH
21276: LD_VAR 0 12
21280: PUSH
21281: LD_INT 1
21283: ARRAY
21284: PPUSH
21285: CALL_OW 266
21289: PUSH
21290: LD_INT 32
21292: PUSH
21293: LD_INT 31
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: IN
21300: AND
21301: IFTRUE 21322
21303: PUSH
21304: LD_VAR 0 12
21308: PUSH
21309: LD_INT 1
21311: ARRAY
21312: PPUSH
21313: CALL_OW 313
21317: PUSH
21318: LD_INT 6
21320: EQUAL
21321: OR
21322: IFFALSE 21342
// f := Delete ( f , 1 ) ;
21324: LD_ADDR_VAR 0 12
21328: PUSH
21329: LD_VAR 0 12
21333: PPUSH
21334: LD_INT 1
21336: PPUSH
21337: CALL_OW 3
21341: ST_TO_ADDR
// if not f then
21342: LD_VAR 0 12
21346: NOT
21347: IFFALSE 21365
// begin x := x + 2 ;
21349: LD_ADDR_VAR 0 13
21353: PUSH
21354: LD_VAR 0 13
21358: PUSH
21359: LD_INT 2
21361: PLUS
21362: ST_TO_ADDR
// continue ;
21363: GO 21159
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
21365: LD_VAR 0 12
21369: PUSH
21370: LD_INT 1
21372: ARRAY
21373: PPUSH
21374: CALL_OW 266
21378: PUSH
21379: LD_INT 5
21381: EQUAL
21382: IFFALSE 21456
// begin if UnitsInside ( f [ 1 ] ) < 3 then
21384: LD_VAR 0 12
21388: PUSH
21389: LD_INT 1
21391: ARRAY
21392: PPUSH
21393: CALL_OW 313
21397: PUSH
21398: LD_INT 3
21400: LESS
21401: IFFALSE 21437
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
21403: LD_INT 0
21405: PPUSH
21406: LD_INT 5
21408: PUSH
21409: LD_INT 8
21411: PUSH
21412: LD_INT 9
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: LIST
21419: PUSH
21420: LD_VAR 0 17
21424: ARRAY
21425: PPUSH
21426: LD_VAR 0 4
21430: PPUSH
21431: CALL_OW 380
21435: GO 21454
// PrepareHuman ( false , i , skill ) ;
21437: LD_INT 0
21439: PPUSH
21440: LD_VAR 0 8
21444: PPUSH
21445: LD_VAR 0 4
21449: PPUSH
21450: CALL_OW 380
// end else
21454: GO 21473
// PrepareHuman ( false , i , skill ) ;
21456: LD_INT 0
21458: PPUSH
21459: LD_VAR 0 8
21463: PPUSH
21464: LD_VAR 0 4
21468: PPUSH
21469: CALL_OW 380
// un := CreateHuman ;
21473: LD_ADDR_VAR 0 14
21477: PUSH
21478: CALL_OW 44
21482: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21483: LD_ADDR_VAR 0 7
21487: PUSH
21488: LD_VAR 0 7
21492: PPUSH
21493: LD_INT 1
21495: PPUSH
21496: LD_VAR 0 14
21500: PPUSH
21501: CALL_OW 2
21505: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
21506: LD_VAR 0 14
21510: PPUSH
21511: LD_VAR 0 12
21515: PUSH
21516: LD_INT 1
21518: ARRAY
21519: PPUSH
21520: CALL_OW 52
// end ;
21524: GO 21159
21526: POP
21527: POP
// end ;
21528: GO 20459
21530: POP
21531: POP
// result := result ^ buildings ;
21532: LD_ADDR_VAR 0 7
21536: PUSH
21537: LD_VAR 0 7
21541: PUSH
21542: LD_VAR 0 18
21546: ADD
21547: ST_TO_ADDR
// end else
21548: GO 21691
// begin for i = 1 to personel do
21550: LD_ADDR_VAR 0 8
21554: PUSH
21555: DOUBLE
21556: LD_INT 1
21558: DEC
21559: ST_TO_ADDR
21560: LD_VAR 0 6
21564: PUSH
21565: FOR_TO
21566: IFFALSE 21689
// begin if i > 4 then
21568: LD_VAR 0 8
21572: PUSH
21573: LD_INT 4
21575: GREATER
21576: IFFALSE 21580
// break ;
21578: GO 21689
// x := personel [ i ] ;
21580: LD_ADDR_VAR 0 13
21584: PUSH
21585: LD_VAR 0 6
21589: PUSH
21590: LD_VAR 0 8
21594: ARRAY
21595: ST_TO_ADDR
// if x = - 1 then
21596: LD_VAR 0 13
21600: PUSH
21601: LD_INT 1
21603: NEG
21604: EQUAL
21605: IFFALSE 21609
// continue ;
21607: GO 21565
// PrepareHuman ( false , i , skill ) ;
21609: LD_INT 0
21611: PPUSH
21612: LD_VAR 0 8
21616: PPUSH
21617: LD_VAR 0 4
21621: PPUSH
21622: CALL_OW 380
// un := CreateHuman ;
21626: LD_ADDR_VAR 0 14
21630: PUSH
21631: CALL_OW 44
21635: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21636: LD_VAR 0 14
21640: PPUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: CALL_OW 250
21650: PPUSH
21651: LD_VAR 0 1
21655: PPUSH
21656: CALL_OW 251
21660: PPUSH
21661: LD_INT 10
21663: PPUSH
21664: LD_INT 0
21666: PPUSH
21667: CALL_OW 50
// result := result ^ un ;
21671: LD_ADDR_VAR 0 7
21675: PUSH
21676: LD_VAR 0 7
21680: PUSH
21681: LD_VAR 0 14
21685: ADD
21686: ST_TO_ADDR
// end ;
21687: GO 21565
21689: POP
21690: POP
// end ; end ;
21691: LD_VAR 0 7
21695: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21696: LD_INT 0
21698: PPUSH
21699: PPUSH
21700: PPUSH
21701: PPUSH
21702: PPUSH
21703: PPUSH
21704: PPUSH
21705: PPUSH
21706: PPUSH
21707: PPUSH
21708: PPUSH
21709: PPUSH
21710: PPUSH
21711: PPUSH
21712: PPUSH
21713: PPUSH
// result := false ;
21714: LD_ADDR_VAR 0 3
21718: PUSH
21719: LD_INT 0
21721: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21722: LD_VAR 0 1
21726: NOT
21727: IFTRUE 21752
21729: PUSH
21730: LD_VAR 0 1
21734: PPUSH
21735: CALL_OW 266
21739: PUSH
21740: LD_INT 32
21742: PUSH
21743: LD_INT 33
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: IN
21750: NOT
21751: OR
21752: IFFALSE 21756
// exit ;
21754: GO 22891
// nat := GetNation ( tower ) ;
21756: LD_ADDR_VAR 0 12
21760: PUSH
21761: LD_VAR 0 1
21765: PPUSH
21766: CALL_OW 248
21770: ST_TO_ADDR
// side := GetSide ( tower ) ;
21771: LD_ADDR_VAR 0 16
21775: PUSH
21776: LD_VAR 0 1
21780: PPUSH
21781: CALL_OW 255
21785: ST_TO_ADDR
// x := GetX ( tower ) ;
21786: LD_ADDR_VAR 0 10
21790: PUSH
21791: LD_VAR 0 1
21795: PPUSH
21796: CALL_OW 250
21800: ST_TO_ADDR
// y := GetY ( tower ) ;
21801: LD_ADDR_VAR 0 11
21805: PUSH
21806: LD_VAR 0 1
21810: PPUSH
21811: CALL_OW 251
21815: ST_TO_ADDR
// if not x or not y then
21816: LD_VAR 0 10
21820: NOT
21821: IFTRUE 21830
21823: PUSH
21824: LD_VAR 0 11
21828: NOT
21829: OR
21830: IFFALSE 21834
// exit ;
21832: GO 22891
// weapon := 0 ;
21834: LD_ADDR_VAR 0 18
21838: PUSH
21839: LD_INT 0
21841: ST_TO_ADDR
// fac_list := [ ] ;
21842: LD_ADDR_VAR 0 17
21846: PUSH
21847: EMPTY
21848: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21849: LD_ADDR_VAR 0 6
21853: PUSH
21854: LD_VAR 0 1
21858: PPUSH
21859: CALL_OW 274
21863: PPUSH
21864: LD_VAR 0 2
21868: PPUSH
21869: LD_INT 0
21871: PPUSH
21872: CALL 19426 0 3
21876: PPUSH
21877: LD_INT 30
21879: PUSH
21880: LD_INT 3
21882: PUSH
21883: EMPTY
21884: LIST
21885: LIST
21886: PPUSH
21887: CALL_OW 72
21891: ST_TO_ADDR
// if not factories then
21892: LD_VAR 0 6
21896: NOT
21897: IFFALSE 21901
// exit ;
21899: GO 22891
// for i in factories do
21901: LD_ADDR_VAR 0 8
21905: PUSH
21906: LD_VAR 0 6
21910: PUSH
21911: FOR_IN
21912: IFFALSE 21937
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21914: LD_ADDR_VAR 0 17
21918: PUSH
21919: LD_VAR 0 17
21923: PUSH
21924: LD_VAR 0 8
21928: PPUSH
21929: CALL_OW 478
21933: UNION
21934: ST_TO_ADDR
21935: GO 21911
21937: POP
21938: POP
// if not fac_list then
21939: LD_VAR 0 17
21943: NOT
21944: IFFALSE 21948
// exit ;
21946: GO 22891
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21948: LD_ADDR_VAR 0 5
21952: PUSH
21953: LD_INT 4
21955: PUSH
21956: LD_INT 5
21958: PUSH
21959: LD_INT 9
21961: PUSH
21962: LD_INT 10
21964: PUSH
21965: LD_INT 6
21967: PUSH
21968: LD_INT 7
21970: PUSH
21971: LD_INT 11
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 27
21985: PUSH
21986: LD_INT 28
21988: PUSH
21989: LD_INT 26
21991: PUSH
21992: LD_INT 30
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: LIST
21999: LIST
22000: PUSH
22001: LD_INT 43
22003: PUSH
22004: LD_INT 44
22006: PUSH
22007: LD_INT 46
22009: PUSH
22010: LD_INT 45
22012: PUSH
22013: LD_INT 47
22015: PUSH
22016: LD_INT 49
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: LIST
22023: LIST
22024: LIST
22025: LIST
22026: PUSH
22027: EMPTY
22028: LIST
22029: LIST
22030: LIST
22031: PUSH
22032: LD_VAR 0 12
22036: ARRAY
22037: ST_TO_ADDR
// list := list isect fac_list ;
22038: LD_ADDR_VAR 0 5
22042: PUSH
22043: LD_VAR 0 5
22047: PUSH
22048: LD_VAR 0 17
22052: ISECT
22053: ST_TO_ADDR
// if not list then
22054: LD_VAR 0 5
22058: NOT
22059: IFFALSE 22063
// exit ;
22061: GO 22891
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
22063: LD_VAR 0 12
22067: PUSH
22068: LD_INT 3
22070: EQUAL
22071: IFFALSE 22083
22073: PUSH
22074: LD_INT 49
22076: PUSH
22077: LD_VAR 0 5
22081: IN
22082: AND
22083: IFFALSE 22103
22085: PUSH
22086: LD_INT 31
22088: PPUSH
22089: LD_VAR 0 16
22093: PPUSH
22094: CALL_OW 321
22098: PUSH
22099: LD_INT 2
22101: EQUAL
22102: AND
22103: IFFALSE 22163
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
22105: LD_INT 22
22107: PUSH
22108: LD_VAR 0 16
22112: PUSH
22113: EMPTY
22114: LIST
22115: LIST
22116: PUSH
22117: LD_INT 35
22119: PUSH
22120: LD_INT 49
22122: PUSH
22123: EMPTY
22124: LIST
22125: LIST
22126: PUSH
22127: LD_INT 91
22129: PUSH
22130: LD_VAR 0 1
22134: PUSH
22135: LD_INT 10
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: LIST
22142: PUSH
22143: EMPTY
22144: LIST
22145: LIST
22146: LIST
22147: PPUSH
22148: CALL_OW 69
22152: NOT
22153: IFFALSE 22163
// weapon := ru_time_lapser ;
22155: LD_ADDR_VAR 0 18
22159: PUSH
22160: LD_INT 49
22162: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
22163: LD_VAR 0 12
22167: PUSH
22168: LD_INT 1
22170: PUSH
22171: LD_INT 2
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: IN
22178: IFFALSE 22202
22180: PUSH
22181: LD_INT 11
22183: PUSH
22184: LD_VAR 0 5
22188: IN
22189: IFTRUE 22201
22191: PUSH
22192: LD_INT 30
22194: PUSH
22195: LD_VAR 0 5
22199: IN
22200: OR
22201: AND
22202: IFFALSE 22222
22204: PUSH
22205: LD_INT 6
22207: PPUSH
22208: LD_VAR 0 16
22212: PPUSH
22213: CALL_OW 321
22217: PUSH
22218: LD_INT 2
22220: EQUAL
22221: AND
22222: IFFALSE 22389
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
22224: LD_INT 22
22226: PUSH
22227: LD_VAR 0 16
22231: PUSH
22232: EMPTY
22233: LIST
22234: LIST
22235: PUSH
22236: LD_INT 2
22238: PUSH
22239: LD_INT 35
22241: PUSH
22242: LD_INT 11
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: LD_INT 35
22251: PUSH
22252: LD_INT 30
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: PUSH
22259: EMPTY
22260: LIST
22261: LIST
22262: LIST
22263: PUSH
22264: LD_INT 91
22266: PUSH
22267: LD_VAR 0 1
22271: PUSH
22272: LD_INT 18
22274: PUSH
22275: EMPTY
22276: LIST
22277: LIST
22278: LIST
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: LIST
22284: PPUSH
22285: CALL_OW 69
22289: NOT
22290: IFFALSE 22366
22292: PUSH
22293: LD_INT 22
22295: PUSH
22296: LD_VAR 0 16
22300: PUSH
22301: EMPTY
22302: LIST
22303: LIST
22304: PUSH
22305: LD_INT 2
22307: PUSH
22308: LD_INT 30
22310: PUSH
22311: LD_INT 32
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PUSH
22318: LD_INT 30
22320: PUSH
22321: LD_INT 33
22323: PUSH
22324: EMPTY
22325: LIST
22326: LIST
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: LIST
22332: PUSH
22333: LD_INT 91
22335: PUSH
22336: LD_VAR 0 1
22340: PUSH
22341: LD_INT 12
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: LIST
22348: PUSH
22349: EMPTY
22350: LIST
22351: LIST
22352: LIST
22353: PUSH
22354: EMPTY
22355: LIST
22356: PPUSH
22357: CALL_OW 69
22361: PUSH
22362: LD_INT 2
22364: GREATER
22365: AND
22366: IFFALSE 22389
// weapon := [ us_radar , ar_radar ] [ nat ] ;
22368: LD_ADDR_VAR 0 18
22372: PUSH
22373: LD_INT 11
22375: PUSH
22376: LD_INT 30
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PUSH
22383: LD_VAR 0 12
22387: ARRAY
22388: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
22389: LD_VAR 0 18
22393: NOT
22394: IFFALSE 22414
22396: PUSH
22397: LD_INT 40
22399: PPUSH
22400: LD_VAR 0 16
22404: PPUSH
22405: CALL_OW 321
22409: PUSH
22410: LD_INT 2
22412: EQUAL
22413: AND
22414: IFFALSE 22450
22416: PUSH
22417: LD_INT 7
22419: PUSH
22420: LD_VAR 0 5
22424: IN
22425: IFTRUE 22437
22427: PUSH
22428: LD_INT 28
22430: PUSH
22431: LD_VAR 0 5
22435: IN
22436: OR
22437: IFTRUE 22449
22439: PUSH
22440: LD_INT 45
22442: PUSH
22443: LD_VAR 0 5
22447: IN
22448: OR
22449: AND
22450: IFFALSE 22704
// begin hex := GetHexInfo ( x , y ) ;
22452: LD_ADDR_VAR 0 4
22456: PUSH
22457: LD_VAR 0 10
22461: PPUSH
22462: LD_VAR 0 11
22466: PPUSH
22467: CALL_OW 546
22471: ST_TO_ADDR
// if hex [ 1 ] then
22472: LD_VAR 0 4
22476: PUSH
22477: LD_INT 1
22479: ARRAY
22480: IFFALSE 22484
// exit ;
22482: GO 22891
// height := hex [ 2 ] ;
22484: LD_ADDR_VAR 0 15
22488: PUSH
22489: LD_VAR 0 4
22493: PUSH
22494: LD_INT 2
22496: ARRAY
22497: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
22498: LD_ADDR_VAR 0 14
22502: PUSH
22503: LD_INT 0
22505: PUSH
22506: LD_INT 2
22508: PUSH
22509: LD_INT 3
22511: PUSH
22512: LD_INT 5
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: LIST
22519: LIST
22520: ST_TO_ADDR
// for i in tmp do
22521: LD_ADDR_VAR 0 8
22525: PUSH
22526: LD_VAR 0 14
22530: PUSH
22531: FOR_IN
22532: IFFALSE 22702
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
22534: LD_ADDR_VAR 0 9
22538: PUSH
22539: LD_VAR 0 10
22543: PPUSH
22544: LD_VAR 0 8
22548: PPUSH
22549: LD_INT 5
22551: PPUSH
22552: CALL_OW 272
22556: PUSH
22557: LD_VAR 0 11
22561: PPUSH
22562: LD_VAR 0 8
22566: PPUSH
22567: LD_INT 5
22569: PPUSH
22570: CALL_OW 273
22574: PUSH
22575: EMPTY
22576: LIST
22577: LIST
22578: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22579: LD_VAR 0 9
22583: PUSH
22584: LD_INT 1
22586: ARRAY
22587: PPUSH
22588: LD_VAR 0 9
22592: PUSH
22593: LD_INT 2
22595: ARRAY
22596: PPUSH
22597: CALL_OW 488
22601: IFFALSE 22700
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22603: LD_ADDR_VAR 0 4
22607: PUSH
22608: LD_VAR 0 9
22612: PUSH
22613: LD_INT 1
22615: ARRAY
22616: PPUSH
22617: LD_VAR 0 9
22621: PUSH
22622: LD_INT 2
22624: ARRAY
22625: PPUSH
22626: CALL_OW 546
22630: ST_TO_ADDR
// if hex [ 1 ] then
22631: LD_VAR 0 4
22635: PUSH
22636: LD_INT 1
22638: ARRAY
22639: IFFALSE 22643
// continue ;
22641: GO 22531
// h := hex [ 2 ] ;
22643: LD_ADDR_VAR 0 13
22647: PUSH
22648: LD_VAR 0 4
22652: PUSH
22653: LD_INT 2
22655: ARRAY
22656: ST_TO_ADDR
// if h + 7 < height then
22657: LD_VAR 0 13
22661: PUSH
22662: LD_INT 7
22664: PLUS
22665: PUSH
22666: LD_VAR 0 15
22670: LESS
22671: IFFALSE 22700
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22673: LD_ADDR_VAR 0 18
22677: PUSH
22678: LD_INT 7
22680: PUSH
22681: LD_INT 28
22683: PUSH
22684: LD_INT 45
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: LIST
22691: PUSH
22692: LD_VAR 0 12
22696: ARRAY
22697: ST_TO_ADDR
// break ;
22698: GO 22702
// end ; end ; end ;
22700: GO 22531
22702: POP
22703: POP
// end ; if not weapon then
22704: LD_VAR 0 18
22708: NOT
22709: IFFALSE 22769
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22711: LD_ADDR_VAR 0 5
22715: PUSH
22716: LD_VAR 0 5
22720: PUSH
22721: LD_INT 11
22723: PUSH
22724: LD_INT 30
22726: PUSH
22727: LD_INT 49
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: DIFF
22735: ST_TO_ADDR
// if not list then
22736: LD_VAR 0 5
22740: NOT
22741: IFFALSE 22745
// exit ;
22743: GO 22891
// weapon := list [ rand ( 1 , list ) ] ;
22745: LD_ADDR_VAR 0 18
22749: PUSH
22750: LD_VAR 0 5
22754: PUSH
22755: LD_INT 1
22757: PPUSH
22758: LD_VAR 0 5
22762: PPUSH
22763: CALL_OW 12
22767: ARRAY
22768: ST_TO_ADDR
// end ; if weapon then
22769: LD_VAR 0 18
22773: IFFALSE 22891
// begin tmp := CostOfWeapon ( weapon ) ;
22775: LD_ADDR_VAR 0 14
22779: PUSH
22780: LD_VAR 0 18
22784: PPUSH
22785: CALL_OW 451
22789: ST_TO_ADDR
// j := GetBase ( tower ) ;
22790: LD_ADDR_VAR 0 9
22794: PUSH
22795: LD_VAR 0 1
22799: PPUSH
22800: CALL_OW 274
22804: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22805: LD_VAR 0 9
22809: PPUSH
22810: LD_INT 1
22812: PPUSH
22813: CALL_OW 275
22817: PUSH
22818: LD_VAR 0 14
22822: PUSH
22823: LD_INT 1
22825: ARRAY
22826: GREATEREQUAL
22827: IFFALSE 22853
22829: PUSH
22830: LD_VAR 0 9
22834: PPUSH
22835: LD_INT 2
22837: PPUSH
22838: CALL_OW 275
22842: PUSH
22843: LD_VAR 0 14
22847: PUSH
22848: LD_INT 2
22850: ARRAY
22851: GREATEREQUAL
22852: AND
22853: IFFALSE 22879
22855: PUSH
22856: LD_VAR 0 9
22860: PPUSH
22861: LD_INT 3
22863: PPUSH
22864: CALL_OW 275
22868: PUSH
22869: LD_VAR 0 14
22873: PUSH
22874: LD_INT 3
22876: ARRAY
22877: GREATEREQUAL
22878: AND
22879: IFFALSE 22891
// result := weapon ;
22881: LD_ADDR_VAR 0 3
22885: PUSH
22886: LD_VAR 0 18
22890: ST_TO_ADDR
// end ; end ;
22891: LD_VAR 0 3
22895: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22896: LD_INT 0
22898: PPUSH
22899: PPUSH
// result := true ;
22900: LD_ADDR_VAR 0 3
22904: PUSH
22905: LD_INT 1
22907: ST_TO_ADDR
// if array1 = array2 then
22908: LD_VAR 0 1
22912: PUSH
22913: LD_VAR 0 2
22917: EQUAL
22918: IFFALSE 22978
// begin for i = 1 to array1 do
22920: LD_ADDR_VAR 0 4
22924: PUSH
22925: DOUBLE
22926: LD_INT 1
22928: DEC
22929: ST_TO_ADDR
22930: LD_VAR 0 1
22934: PUSH
22935: FOR_TO
22936: IFFALSE 22974
// if array1 [ i ] <> array2 [ i ] then
22938: LD_VAR 0 1
22942: PUSH
22943: LD_VAR 0 4
22947: ARRAY
22948: PUSH
22949: LD_VAR 0 2
22953: PUSH
22954: LD_VAR 0 4
22958: ARRAY
22959: NONEQUAL
22960: IFFALSE 22972
// begin result := false ;
22962: LD_ADDR_VAR 0 3
22966: PUSH
22967: LD_INT 0
22969: ST_TO_ADDR
// break ;
22970: GO 22974
// end ;
22972: GO 22935
22974: POP
22975: POP
// end else
22976: GO 22986
// result := false ;
22978: LD_ADDR_VAR 0 3
22982: PUSH
22983: LD_INT 0
22985: ST_TO_ADDR
// end ;
22986: LD_VAR 0 3
22990: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22991: LD_INT 0
22993: PPUSH
22994: PPUSH
// if not array1 or not array2 then
22995: LD_VAR 0 1
22999: NOT
23000: IFTRUE 23009
23002: PUSH
23003: LD_VAR 0 2
23007: NOT
23008: OR
23009: IFFALSE 23013
// exit ;
23011: GO 23077
// result := true ;
23013: LD_ADDR_VAR 0 3
23017: PUSH
23018: LD_INT 1
23020: ST_TO_ADDR
// for i = 1 to array1 do
23021: LD_ADDR_VAR 0 4
23025: PUSH
23026: DOUBLE
23027: LD_INT 1
23029: DEC
23030: ST_TO_ADDR
23031: LD_VAR 0 1
23035: PUSH
23036: FOR_TO
23037: IFFALSE 23075
// if array1 [ i ] <> array2 [ i ] then
23039: LD_VAR 0 1
23043: PUSH
23044: LD_VAR 0 4
23048: ARRAY
23049: PUSH
23050: LD_VAR 0 2
23054: PUSH
23055: LD_VAR 0 4
23059: ARRAY
23060: NONEQUAL
23061: IFFALSE 23073
// begin result := false ;
23063: LD_ADDR_VAR 0 3
23067: PUSH
23068: LD_INT 0
23070: ST_TO_ADDR
// break ;
23071: GO 23075
// end ;
23073: GO 23036
23075: POP
23076: POP
// end ;
23077: LD_VAR 0 3
23081: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
23082: LD_INT 0
23084: PPUSH
23085: PPUSH
23086: PPUSH
// pom := GetBase ( fac ) ;
23087: LD_ADDR_VAR 0 5
23091: PUSH
23092: LD_VAR 0 1
23096: PPUSH
23097: CALL_OW 274
23101: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
23102: LD_ADDR_VAR 0 4
23106: PUSH
23107: LD_VAR 0 2
23111: PUSH
23112: LD_INT 1
23114: ARRAY
23115: PPUSH
23116: LD_VAR 0 2
23120: PUSH
23121: LD_INT 2
23123: ARRAY
23124: PPUSH
23125: LD_VAR 0 2
23129: PUSH
23130: LD_INT 3
23132: ARRAY
23133: PPUSH
23134: LD_VAR 0 2
23138: PUSH
23139: LD_INT 4
23141: ARRAY
23142: PPUSH
23143: CALL_OW 449
23147: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23148: LD_ADDR_VAR 0 3
23152: PUSH
23153: LD_VAR 0 5
23157: PPUSH
23158: LD_INT 1
23160: PPUSH
23161: CALL_OW 275
23165: PUSH
23166: LD_VAR 0 4
23170: PUSH
23171: LD_INT 1
23173: ARRAY
23174: GREATEREQUAL
23175: IFFALSE 23201
23177: PUSH
23178: LD_VAR 0 5
23182: PPUSH
23183: LD_INT 2
23185: PPUSH
23186: CALL_OW 275
23190: PUSH
23191: LD_VAR 0 4
23195: PUSH
23196: LD_INT 2
23198: ARRAY
23199: GREATEREQUAL
23200: AND
23201: IFFALSE 23227
23203: PUSH
23204: LD_VAR 0 5
23208: PPUSH
23209: LD_INT 3
23211: PPUSH
23212: CALL_OW 275
23216: PUSH
23217: LD_VAR 0 4
23221: PUSH
23222: LD_INT 3
23224: ARRAY
23225: GREATEREQUAL
23226: AND
23227: ST_TO_ADDR
// end ;
23228: LD_VAR 0 3
23232: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
23233: LD_INT 0
23235: PPUSH
23236: PPUSH
23237: PPUSH
23238: PPUSH
// pom := GetBase ( building ) ;
23239: LD_ADDR_VAR 0 3
23243: PUSH
23244: LD_VAR 0 1
23248: PPUSH
23249: CALL_OW 274
23253: ST_TO_ADDR
// if not pom then
23254: LD_VAR 0 3
23258: NOT
23259: IFFALSE 23263
// exit ;
23261: GO 23437
// btype := GetBType ( building ) ;
23263: LD_ADDR_VAR 0 5
23267: PUSH
23268: LD_VAR 0 1
23272: PPUSH
23273: CALL_OW 266
23277: ST_TO_ADDR
// if btype = b_armoury then
23278: LD_VAR 0 5
23282: PUSH
23283: LD_INT 4
23285: EQUAL
23286: IFFALSE 23296
// btype := b_barracks ;
23288: LD_ADDR_VAR 0 5
23292: PUSH
23293: LD_INT 5
23295: ST_TO_ADDR
// if btype = b_depot then
23296: LD_VAR 0 5
23300: PUSH
23301: LD_INT 0
23303: EQUAL
23304: IFFALSE 23314
// btype := b_warehouse ;
23306: LD_ADDR_VAR 0 5
23310: PUSH
23311: LD_INT 1
23313: ST_TO_ADDR
// if btype = b_workshop then
23314: LD_VAR 0 5
23318: PUSH
23319: LD_INT 2
23321: EQUAL
23322: IFFALSE 23332
// btype := b_factory ;
23324: LD_ADDR_VAR 0 5
23328: PUSH
23329: LD_INT 3
23331: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23332: LD_ADDR_VAR 0 4
23336: PUSH
23337: LD_VAR 0 5
23341: PPUSH
23342: LD_VAR 0 1
23346: PPUSH
23347: CALL_OW 248
23351: PPUSH
23352: CALL_OW 450
23356: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23357: LD_ADDR_VAR 0 2
23361: PUSH
23362: LD_VAR 0 3
23366: PPUSH
23367: LD_INT 1
23369: PPUSH
23370: CALL_OW 275
23374: PUSH
23375: LD_VAR 0 4
23379: PUSH
23380: LD_INT 1
23382: ARRAY
23383: GREATEREQUAL
23384: IFFALSE 23410
23386: PUSH
23387: LD_VAR 0 3
23391: PPUSH
23392: LD_INT 2
23394: PPUSH
23395: CALL_OW 275
23399: PUSH
23400: LD_VAR 0 4
23404: PUSH
23405: LD_INT 2
23407: ARRAY
23408: GREATEREQUAL
23409: AND
23410: IFFALSE 23436
23412: PUSH
23413: LD_VAR 0 3
23417: PPUSH
23418: LD_INT 3
23420: PPUSH
23421: CALL_OW 275
23425: PUSH
23426: LD_VAR 0 4
23430: PUSH
23431: LD_INT 3
23433: ARRAY
23434: GREATEREQUAL
23435: AND
23436: ST_TO_ADDR
// end ;
23437: LD_VAR 0 2
23441: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
23442: LD_INT 0
23444: PPUSH
23445: PPUSH
23446: PPUSH
// pom := GetBase ( building ) ;
23447: LD_ADDR_VAR 0 4
23451: PUSH
23452: LD_VAR 0 1
23456: PPUSH
23457: CALL_OW 274
23461: ST_TO_ADDR
// if not pom then
23462: LD_VAR 0 4
23466: NOT
23467: IFFALSE 23471
// exit ;
23469: GO 23576
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23471: LD_ADDR_VAR 0 5
23475: PUSH
23476: LD_VAR 0 2
23480: PPUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 248
23490: PPUSH
23491: CALL_OW 450
23495: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23496: LD_ADDR_VAR 0 3
23500: PUSH
23501: LD_VAR 0 4
23505: PPUSH
23506: LD_INT 1
23508: PPUSH
23509: CALL_OW 275
23513: PUSH
23514: LD_VAR 0 5
23518: PUSH
23519: LD_INT 1
23521: ARRAY
23522: GREATEREQUAL
23523: IFFALSE 23549
23525: PUSH
23526: LD_VAR 0 4
23530: PPUSH
23531: LD_INT 2
23533: PPUSH
23534: CALL_OW 275
23538: PUSH
23539: LD_VAR 0 5
23543: PUSH
23544: LD_INT 2
23546: ARRAY
23547: GREATEREQUAL
23548: AND
23549: IFFALSE 23575
23551: PUSH
23552: LD_VAR 0 4
23556: PPUSH
23557: LD_INT 3
23559: PPUSH
23560: CALL_OW 275
23564: PUSH
23565: LD_VAR 0 5
23569: PUSH
23570: LD_INT 3
23572: ARRAY
23573: GREATEREQUAL
23574: AND
23575: ST_TO_ADDR
// end ;
23576: LD_VAR 0 3
23580: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23581: LD_INT 0
23583: PPUSH
23584: PPUSH
23585: PPUSH
23586: PPUSH
23587: PPUSH
23588: PPUSH
23589: PPUSH
23590: PPUSH
23591: PPUSH
23592: PPUSH
23593: PPUSH
// result := false ;
23594: LD_ADDR_VAR 0 8
23598: PUSH
23599: LD_INT 0
23601: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23602: LD_VAR 0 5
23606: NOT
23607: IFTRUE 23616
23609: PUSH
23610: LD_VAR 0 1
23614: NOT
23615: OR
23616: IFTRUE 23625
23618: PUSH
23619: LD_VAR 0 2
23623: NOT
23624: OR
23625: IFTRUE 23634
23627: PUSH
23628: LD_VAR 0 3
23632: NOT
23633: OR
23634: IFFALSE 23638
// exit ;
23636: GO 24464
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23638: LD_ADDR_VAR 0 14
23642: PUSH
23643: LD_VAR 0 1
23647: PPUSH
23648: LD_VAR 0 2
23652: PPUSH
23653: LD_VAR 0 3
23657: PPUSH
23658: LD_VAR 0 4
23662: PPUSH
23663: LD_VAR 0 5
23667: PUSH
23668: LD_INT 1
23670: ARRAY
23671: PPUSH
23672: CALL_OW 248
23676: PPUSH
23677: LD_INT 0
23679: PPUSH
23680: CALL 25745 0 6
23684: ST_TO_ADDR
// if not hexes then
23685: LD_VAR 0 14
23689: NOT
23690: IFFALSE 23694
// exit ;
23692: GO 24464
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23694: LD_ADDR_VAR 0 17
23698: PUSH
23699: LD_VAR 0 5
23703: PPUSH
23704: LD_INT 22
23706: PUSH
23707: LD_VAR 0 13
23711: PPUSH
23712: CALL_OW 255
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: PUSH
23721: LD_INT 2
23723: PUSH
23724: LD_INT 30
23726: PUSH
23727: LD_INT 0
23729: PUSH
23730: EMPTY
23731: LIST
23732: LIST
23733: PUSH
23734: LD_INT 30
23736: PUSH
23737: LD_INT 1
23739: PUSH
23740: EMPTY
23741: LIST
23742: LIST
23743: PUSH
23744: EMPTY
23745: LIST
23746: LIST
23747: LIST
23748: PUSH
23749: EMPTY
23750: LIST
23751: LIST
23752: PPUSH
23753: CALL_OW 72
23757: ST_TO_ADDR
// for i = 1 to hexes do
23758: LD_ADDR_VAR 0 9
23762: PUSH
23763: DOUBLE
23764: LD_INT 1
23766: DEC
23767: ST_TO_ADDR
23768: LD_VAR 0 14
23772: PUSH
23773: FOR_TO
23774: IFFALSE 24462
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23776: LD_ADDR_VAR 0 13
23780: PUSH
23781: LD_VAR 0 14
23785: PUSH
23786: LD_VAR 0 9
23790: ARRAY
23791: PUSH
23792: LD_INT 1
23794: ARRAY
23795: PPUSH
23796: LD_VAR 0 14
23800: PUSH
23801: LD_VAR 0 9
23805: ARRAY
23806: PUSH
23807: LD_INT 2
23809: ARRAY
23810: PPUSH
23811: CALL_OW 428
23815: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23816: LD_VAR 0 14
23820: PUSH
23821: LD_VAR 0 9
23825: ARRAY
23826: PUSH
23827: LD_INT 1
23829: ARRAY
23830: PPUSH
23831: LD_VAR 0 14
23835: PUSH
23836: LD_VAR 0 9
23840: ARRAY
23841: PUSH
23842: LD_INT 2
23844: ARRAY
23845: PPUSH
23846: CALL_OW 351
23850: IFTRUE 23889
23852: PUSH
23853: LD_VAR 0 14
23857: PUSH
23858: LD_VAR 0 9
23862: ARRAY
23863: PUSH
23864: LD_INT 1
23866: ARRAY
23867: PPUSH
23868: LD_VAR 0 14
23872: PUSH
23873: LD_VAR 0 9
23877: ARRAY
23878: PUSH
23879: LD_INT 2
23881: ARRAY
23882: PPUSH
23883: CALL_OW 488
23887: NOT
23888: OR
23889: IFTRUE 23906
23891: PUSH
23892: LD_VAR 0 13
23896: PPUSH
23897: CALL_OW 247
23901: PUSH
23902: LD_INT 3
23904: EQUAL
23905: OR
23906: IFFALSE 23912
// exit ;
23908: POP
23909: POP
23910: GO 24464
// if not tmp then
23912: LD_VAR 0 13
23916: NOT
23917: IFFALSE 23921
// continue ;
23919: GO 23773
// result := true ;
23921: LD_ADDR_VAR 0 8
23925: PUSH
23926: LD_INT 1
23928: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23929: LD_VAR 0 6
23933: IFFALSE 23950
23935: PUSH
23936: LD_VAR 0 13
23940: PPUSH
23941: CALL_OW 247
23945: PUSH
23946: LD_INT 2
23948: EQUAL
23949: AND
23950: IFFALSE 23967
23952: PUSH
23953: LD_VAR 0 13
23957: PPUSH
23958: CALL_OW 263
23962: PUSH
23963: LD_INT 1
23965: EQUAL
23966: AND
23967: IFFALSE 24131
// begin if IsDrivenBy ( tmp ) then
23969: LD_VAR 0 13
23973: PPUSH
23974: CALL_OW 311
23978: IFFALSE 23982
// continue ;
23980: GO 23773
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23982: LD_VAR 0 6
23986: PPUSH
23987: LD_INT 3
23989: PUSH
23990: LD_INT 60
23992: PUSH
23993: EMPTY
23994: LIST
23995: PUSH
23996: EMPTY
23997: LIST
23998: LIST
23999: PUSH
24000: LD_INT 3
24002: PUSH
24003: LD_INT 55
24005: PUSH
24006: EMPTY
24007: LIST
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: PUSH
24013: EMPTY
24014: LIST
24015: LIST
24016: PPUSH
24017: CALL_OW 72
24021: IFFALSE 24129
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
24023: LD_ADDR_VAR 0 18
24027: PUSH
24028: LD_VAR 0 6
24032: PPUSH
24033: LD_INT 3
24035: PUSH
24036: LD_INT 60
24038: PUSH
24039: EMPTY
24040: LIST
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PUSH
24046: LD_INT 3
24048: PUSH
24049: LD_INT 55
24051: PUSH
24052: EMPTY
24053: LIST
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: PPUSH
24063: CALL_OW 72
24067: PUSH
24068: LD_INT 1
24070: ARRAY
24071: ST_TO_ADDR
// if IsInUnit ( driver ) then
24072: LD_VAR 0 18
24076: PPUSH
24077: CALL_OW 310
24081: IFFALSE 24092
// ComExit ( driver ) ;
24083: LD_VAR 0 18
24087: PPUSH
24088: CALL 49745 0 1
// AddComEnterUnit ( driver , tmp ) ;
24092: LD_VAR 0 18
24096: PPUSH
24097: LD_VAR 0 13
24101: PPUSH
24102: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
24106: LD_VAR 0 18
24110: PPUSH
24111: LD_VAR 0 7
24115: PPUSH
24116: CALL_OW 173
// AddComExitVehicle ( driver ) ;
24120: LD_VAR 0 18
24124: PPUSH
24125: CALL_OW 181
// end ; continue ;
24129: GO 23773
// end ; if not cleaners or not tmp in cleaners then
24131: LD_VAR 0 6
24135: NOT
24136: IFTRUE 24151
24138: PUSH
24139: LD_VAR 0 13
24143: PUSH
24144: LD_VAR 0 6
24148: IN
24149: NOT
24150: OR
24151: IFFALSE 24460
// begin if dep then
24153: LD_VAR 0 17
24157: IFFALSE 24293
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
24159: LD_ADDR_VAR 0 16
24163: PUSH
24164: LD_VAR 0 17
24168: PUSH
24169: LD_INT 1
24171: ARRAY
24172: PPUSH
24173: CALL_OW 250
24177: PPUSH
24178: LD_VAR 0 17
24182: PUSH
24183: LD_INT 1
24185: ARRAY
24186: PPUSH
24187: CALL_OW 254
24191: PPUSH
24192: LD_INT 5
24194: PPUSH
24195: CALL_OW 272
24199: PUSH
24200: LD_VAR 0 17
24204: PUSH
24205: LD_INT 1
24207: ARRAY
24208: PPUSH
24209: CALL_OW 251
24213: PPUSH
24214: LD_VAR 0 17
24218: PUSH
24219: LD_INT 1
24221: ARRAY
24222: PPUSH
24223: CALL_OW 254
24227: PPUSH
24228: LD_INT 5
24230: PPUSH
24231: CALL_OW 273
24235: PUSH
24236: EMPTY
24237: LIST
24238: LIST
24239: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
24240: LD_VAR 0 16
24244: PUSH
24245: LD_INT 1
24247: ARRAY
24248: PPUSH
24249: LD_VAR 0 16
24253: PUSH
24254: LD_INT 2
24256: ARRAY
24257: PPUSH
24258: CALL_OW 488
24262: IFFALSE 24293
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
24264: LD_VAR 0 13
24268: PPUSH
24269: LD_VAR 0 16
24273: PUSH
24274: LD_INT 1
24276: ARRAY
24277: PPUSH
24278: LD_VAR 0 16
24282: PUSH
24283: LD_INT 2
24285: ARRAY
24286: PPUSH
24287: CALL_OW 111
// continue ;
24291: GO 23773
// end ; end ; r := GetDir ( tmp ) ;
24293: LD_ADDR_VAR 0 15
24297: PUSH
24298: LD_VAR 0 13
24302: PPUSH
24303: CALL_OW 254
24307: ST_TO_ADDR
// if r = 5 then
24308: LD_VAR 0 15
24312: PUSH
24313: LD_INT 5
24315: EQUAL
24316: IFFALSE 24326
// r := 0 ;
24318: LD_ADDR_VAR 0 15
24322: PUSH
24323: LD_INT 0
24325: ST_TO_ADDR
// for j = r to 5 do
24326: LD_ADDR_VAR 0 10
24330: PUSH
24331: DOUBLE
24332: LD_VAR 0 15
24336: DEC
24337: ST_TO_ADDR
24338: LD_INT 5
24340: PUSH
24341: FOR_TO
24342: IFFALSE 24458
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
24344: LD_ADDR_VAR 0 11
24348: PUSH
24349: LD_VAR 0 13
24353: PPUSH
24354: CALL_OW 250
24358: PPUSH
24359: LD_VAR 0 10
24363: PPUSH
24364: LD_INT 2
24366: PPUSH
24367: CALL_OW 272
24371: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
24372: LD_ADDR_VAR 0 12
24376: PUSH
24377: LD_VAR 0 13
24381: PPUSH
24382: CALL_OW 251
24386: PPUSH
24387: LD_VAR 0 10
24391: PPUSH
24392: LD_INT 2
24394: PPUSH
24395: CALL_OW 273
24399: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
24400: LD_VAR 0 11
24404: PPUSH
24405: LD_VAR 0 12
24409: PPUSH
24410: CALL_OW 488
24414: IFFALSE 24433
24416: PUSH
24417: LD_VAR 0 11
24421: PPUSH
24422: LD_VAR 0 12
24426: PPUSH
24427: CALL_OW 428
24431: NOT
24432: AND
24433: IFFALSE 24456
// begin ComMoveXY ( tmp , _x , _y ) ;
24435: LD_VAR 0 13
24439: PPUSH
24440: LD_VAR 0 11
24444: PPUSH
24445: LD_VAR 0 12
24449: PPUSH
24450: CALL_OW 111
// break ;
24454: GO 24458
// end ; end ;
24456: GO 24341
24458: POP
24459: POP
// end ; end ;
24460: GO 23773
24462: POP
24463: POP
// end ;
24464: LD_VAR 0 8
24468: RET
// export function BuildingTechInvented ( side , btype ) ; begin
24469: LD_INT 0
24471: PPUSH
// result := true ;
24472: LD_ADDR_VAR 0 3
24476: PUSH
24477: LD_INT 1
24479: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
24480: LD_VAR 0 2
24484: PUSH
24485: LD_INT 24
24487: DOUBLE
24488: EQUAL
24489: IFTRUE 24499
24491: LD_INT 33
24493: DOUBLE
24494: EQUAL
24495: IFTRUE 24499
24497: GO 24524
24499: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
24500: LD_ADDR_VAR 0 3
24504: PUSH
24505: LD_INT 32
24507: PPUSH
24508: LD_VAR 0 1
24512: PPUSH
24513: CALL_OW 321
24517: PUSH
24518: LD_INT 2
24520: EQUAL
24521: ST_TO_ADDR
24522: GO 24840
24524: LD_INT 20
24526: DOUBLE
24527: EQUAL
24528: IFTRUE 24532
24530: GO 24557
24532: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
24533: LD_ADDR_VAR 0 3
24537: PUSH
24538: LD_INT 6
24540: PPUSH
24541: LD_VAR 0 1
24545: PPUSH
24546: CALL_OW 321
24550: PUSH
24551: LD_INT 2
24553: EQUAL
24554: ST_TO_ADDR
24555: GO 24840
24557: LD_INT 22
24559: DOUBLE
24560: EQUAL
24561: IFTRUE 24571
24563: LD_INT 36
24565: DOUBLE
24566: EQUAL
24567: IFTRUE 24571
24569: GO 24596
24571: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
24572: LD_ADDR_VAR 0 3
24576: PUSH
24577: LD_INT 15
24579: PPUSH
24580: LD_VAR 0 1
24584: PPUSH
24585: CALL_OW 321
24589: PUSH
24590: LD_INT 2
24592: EQUAL
24593: ST_TO_ADDR
24594: GO 24840
24596: LD_INT 30
24598: DOUBLE
24599: EQUAL
24600: IFTRUE 24604
24602: GO 24629
24604: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24605: LD_ADDR_VAR 0 3
24609: PUSH
24610: LD_INT 20
24612: PPUSH
24613: LD_VAR 0 1
24617: PPUSH
24618: CALL_OW 321
24622: PUSH
24623: LD_INT 2
24625: EQUAL
24626: ST_TO_ADDR
24627: GO 24840
24629: LD_INT 28
24631: DOUBLE
24632: EQUAL
24633: IFTRUE 24643
24635: LD_INT 21
24637: DOUBLE
24638: EQUAL
24639: IFTRUE 24643
24641: GO 24668
24643: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24644: LD_ADDR_VAR 0 3
24648: PUSH
24649: LD_INT 21
24651: PPUSH
24652: LD_VAR 0 1
24656: PPUSH
24657: CALL_OW 321
24661: PUSH
24662: LD_INT 2
24664: EQUAL
24665: ST_TO_ADDR
24666: GO 24840
24668: LD_INT 16
24670: DOUBLE
24671: EQUAL
24672: IFTRUE 24676
24674: GO 24701
24676: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24677: LD_ADDR_VAR 0 3
24681: PUSH
24682: LD_INT 84
24684: PPUSH
24685: LD_VAR 0 1
24689: PPUSH
24690: CALL_OW 321
24694: PUSH
24695: LD_INT 2
24697: EQUAL
24698: ST_TO_ADDR
24699: GO 24840
24701: LD_INT 19
24703: DOUBLE
24704: EQUAL
24705: IFTRUE 24715
24707: LD_INT 23
24709: DOUBLE
24710: EQUAL
24711: IFTRUE 24715
24713: GO 24740
24715: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24716: LD_ADDR_VAR 0 3
24720: PUSH
24721: LD_INT 83
24723: PPUSH
24724: LD_VAR 0 1
24728: PPUSH
24729: CALL_OW 321
24733: PUSH
24734: LD_INT 2
24736: EQUAL
24737: ST_TO_ADDR
24738: GO 24840
24740: LD_INT 17
24742: DOUBLE
24743: EQUAL
24744: IFTRUE 24748
24746: GO 24773
24748: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24749: LD_ADDR_VAR 0 3
24753: PUSH
24754: LD_INT 39
24756: PPUSH
24757: LD_VAR 0 1
24761: PPUSH
24762: CALL_OW 321
24766: PUSH
24767: LD_INT 2
24769: EQUAL
24770: ST_TO_ADDR
24771: GO 24840
24773: LD_INT 18
24775: DOUBLE
24776: EQUAL
24777: IFTRUE 24781
24779: GO 24806
24781: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24782: LD_ADDR_VAR 0 3
24786: PUSH
24787: LD_INT 40
24789: PPUSH
24790: LD_VAR 0 1
24794: PPUSH
24795: CALL_OW 321
24799: PUSH
24800: LD_INT 2
24802: EQUAL
24803: ST_TO_ADDR
24804: GO 24840
24806: LD_INT 27
24808: DOUBLE
24809: EQUAL
24810: IFTRUE 24814
24812: GO 24839
24814: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24815: LD_ADDR_VAR 0 3
24819: PUSH
24820: LD_INT 35
24822: PPUSH
24823: LD_VAR 0 1
24827: PPUSH
24828: CALL_OW 321
24832: PUSH
24833: LD_INT 2
24835: EQUAL
24836: ST_TO_ADDR
24837: GO 24840
24839: POP
// end ;
24840: LD_VAR 0 3
24844: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24845: LD_INT 0
24847: PPUSH
24848: PPUSH
24849: PPUSH
24850: PPUSH
24851: PPUSH
24852: PPUSH
24853: PPUSH
24854: PPUSH
24855: PPUSH
24856: PPUSH
24857: PPUSH
// result := false ;
24858: LD_ADDR_VAR 0 6
24862: PUSH
24863: LD_INT 0
24865: ST_TO_ADDR
// if btype = b_depot then
24866: LD_VAR 0 2
24870: PUSH
24871: LD_INT 0
24873: EQUAL
24874: IFFALSE 24886
// begin result := true ;
24876: LD_ADDR_VAR 0 6
24880: PUSH
24881: LD_INT 1
24883: ST_TO_ADDR
// exit ;
24884: GO 25740
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24886: LD_VAR 0 1
24890: NOT
24891: IFTRUE 24916
24893: PUSH
24894: LD_VAR 0 1
24898: PPUSH
24899: CALL_OW 266
24903: PUSH
24904: LD_INT 0
24906: PUSH
24907: LD_INT 1
24909: PUSH
24910: EMPTY
24911: LIST
24912: LIST
24913: IN
24914: NOT
24915: OR
24916: IFTRUE 24925
24918: PUSH
24919: LD_VAR 0 2
24923: NOT
24924: OR
24925: IFTRUE 24961
24927: PUSH
24928: LD_VAR 0 5
24932: PUSH
24933: LD_INT 0
24935: PUSH
24936: LD_INT 1
24938: PUSH
24939: LD_INT 2
24941: PUSH
24942: LD_INT 3
24944: PUSH
24945: LD_INT 4
24947: PUSH
24948: LD_INT 5
24950: PUSH
24951: EMPTY
24952: LIST
24953: LIST
24954: LIST
24955: LIST
24956: LIST
24957: LIST
24958: IN
24959: NOT
24960: OR
24961: IFTRUE 24980
24963: PUSH
24964: LD_VAR 0 3
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 488
24978: NOT
24979: OR
24980: IFFALSE 24984
// exit ;
24982: GO 25740
// side := GetSide ( depot ) ;
24984: LD_ADDR_VAR 0 9
24988: PUSH
24989: LD_VAR 0 1
24993: PPUSH
24994: CALL_OW 255
24998: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24999: LD_VAR 0 9
25003: PPUSH
25004: LD_VAR 0 2
25008: PPUSH
25009: CALL 24469 0 2
25013: NOT
25014: IFFALSE 25018
// exit ;
25016: GO 25740
// pom := GetBase ( depot ) ;
25018: LD_ADDR_VAR 0 10
25022: PUSH
25023: LD_VAR 0 1
25027: PPUSH
25028: CALL_OW 274
25032: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
25033: LD_ADDR_VAR 0 11
25037: PUSH
25038: LD_VAR 0 2
25042: PPUSH
25043: LD_VAR 0 1
25047: PPUSH
25048: CALL_OW 248
25052: PPUSH
25053: CALL_OW 450
25057: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
25058: LD_VAR 0 10
25062: PPUSH
25063: LD_INT 1
25065: PPUSH
25066: CALL_OW 275
25070: PUSH
25071: LD_VAR 0 11
25075: PUSH
25076: LD_INT 1
25078: ARRAY
25079: GREATEREQUAL
25080: IFFALSE 25106
25082: PUSH
25083: LD_VAR 0 10
25087: PPUSH
25088: LD_INT 2
25090: PPUSH
25091: CALL_OW 275
25095: PUSH
25096: LD_VAR 0 11
25100: PUSH
25101: LD_INT 2
25103: ARRAY
25104: GREATEREQUAL
25105: AND
25106: IFFALSE 25132
25108: PUSH
25109: LD_VAR 0 10
25113: PPUSH
25114: LD_INT 3
25116: PPUSH
25117: CALL_OW 275
25121: PUSH
25122: LD_VAR 0 11
25126: PUSH
25127: LD_INT 3
25129: ARRAY
25130: GREATEREQUAL
25131: AND
25132: NOT
25133: IFFALSE 25137
// exit ;
25135: GO 25740
// if GetBType ( depot ) = b_depot then
25137: LD_VAR 0 1
25141: PPUSH
25142: CALL_OW 266
25146: PUSH
25147: LD_INT 0
25149: EQUAL
25150: IFFALSE 25162
// dist := 28 else
25152: LD_ADDR_VAR 0 14
25156: PUSH
25157: LD_INT 28
25159: ST_TO_ADDR
25160: GO 25170
// dist := 36 ;
25162: LD_ADDR_VAR 0 14
25166: PUSH
25167: LD_INT 36
25169: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
25170: LD_VAR 0 1
25174: PPUSH
25175: LD_VAR 0 3
25179: PPUSH
25180: LD_VAR 0 4
25184: PPUSH
25185: CALL_OW 297
25189: PUSH
25190: LD_VAR 0 14
25194: GREATER
25195: IFFALSE 25199
// exit ;
25197: GO 25740
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
25199: LD_ADDR_VAR 0 12
25203: PUSH
25204: LD_VAR 0 2
25208: PPUSH
25209: LD_VAR 0 3
25213: PPUSH
25214: LD_VAR 0 4
25218: PPUSH
25219: LD_VAR 0 5
25223: PPUSH
25224: LD_VAR 0 1
25228: PPUSH
25229: CALL_OW 248
25233: PPUSH
25234: LD_INT 0
25236: PPUSH
25237: CALL 25745 0 6
25241: ST_TO_ADDR
// if not hexes then
25242: LD_VAR 0 12
25246: NOT
25247: IFFALSE 25251
// exit ;
25249: GO 25740
// hex := GetHexInfo ( x , y ) ;
25251: LD_ADDR_VAR 0 15
25255: PUSH
25256: LD_VAR 0 3
25260: PPUSH
25261: LD_VAR 0 4
25265: PPUSH
25266: CALL_OW 546
25270: ST_TO_ADDR
// if hex [ 1 ] then
25271: LD_VAR 0 15
25275: PUSH
25276: LD_INT 1
25278: ARRAY
25279: IFFALSE 25283
// exit ;
25281: GO 25740
// height := hex [ 2 ] ;
25283: LD_ADDR_VAR 0 13
25287: PUSH
25288: LD_VAR 0 15
25292: PUSH
25293: LD_INT 2
25295: ARRAY
25296: ST_TO_ADDR
// for i = 1 to hexes do
25297: LD_ADDR_VAR 0 7
25301: PUSH
25302: DOUBLE
25303: LD_INT 1
25305: DEC
25306: ST_TO_ADDR
25307: LD_VAR 0 12
25311: PUSH
25312: FOR_TO
25313: IFFALSE 25657
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25315: LD_VAR 0 12
25319: PUSH
25320: LD_VAR 0 7
25324: ARRAY
25325: PUSH
25326: LD_INT 1
25328: ARRAY
25329: PPUSH
25330: LD_VAR 0 12
25334: PUSH
25335: LD_VAR 0 7
25339: ARRAY
25340: PUSH
25341: LD_INT 2
25343: ARRAY
25344: PPUSH
25345: CALL_OW 488
25349: NOT
25350: IFTRUE 25392
25352: PUSH
25353: LD_VAR 0 12
25357: PUSH
25358: LD_VAR 0 7
25362: ARRAY
25363: PUSH
25364: LD_INT 1
25366: ARRAY
25367: PPUSH
25368: LD_VAR 0 12
25372: PUSH
25373: LD_VAR 0 7
25377: ARRAY
25378: PUSH
25379: LD_INT 2
25381: ARRAY
25382: PPUSH
25383: CALL_OW 428
25387: PUSH
25388: LD_INT 0
25390: GREATER
25391: OR
25392: IFTRUE 25430
25394: PUSH
25395: LD_VAR 0 12
25399: PUSH
25400: LD_VAR 0 7
25404: ARRAY
25405: PUSH
25406: LD_INT 1
25408: ARRAY
25409: PPUSH
25410: LD_VAR 0 12
25414: PUSH
25415: LD_VAR 0 7
25419: ARRAY
25420: PUSH
25421: LD_INT 2
25423: ARRAY
25424: PPUSH
25425: CALL_OW 351
25429: OR
25430: IFFALSE 25436
// exit ;
25432: POP
25433: POP
25434: GO 25740
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25436: LD_ADDR_VAR 0 8
25440: PUSH
25441: LD_VAR 0 12
25445: PUSH
25446: LD_VAR 0 7
25450: ARRAY
25451: PUSH
25452: LD_INT 1
25454: ARRAY
25455: PPUSH
25456: LD_VAR 0 12
25460: PUSH
25461: LD_VAR 0 7
25465: ARRAY
25466: PUSH
25467: LD_INT 2
25469: ARRAY
25470: PPUSH
25471: CALL_OW 546
25475: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
25476: LD_VAR 0 8
25480: PUSH
25481: LD_INT 1
25483: ARRAY
25484: IFTRUE 25506
25486: PUSH
25487: LD_VAR 0 8
25491: PUSH
25492: LD_INT 2
25494: ARRAY
25495: PUSH
25496: LD_VAR 0 13
25500: PUSH
25501: LD_INT 2
25503: PLUS
25504: GREATER
25505: OR
25506: IFTRUE 25528
25508: PUSH
25509: LD_VAR 0 8
25513: PUSH
25514: LD_INT 2
25516: ARRAY
25517: PUSH
25518: LD_VAR 0 13
25522: PUSH
25523: LD_INT 2
25525: MINUS
25526: LESS
25527: OR
25528: IFTRUE 25596
25530: PUSH
25531: LD_VAR 0 8
25535: PUSH
25536: LD_INT 3
25538: ARRAY
25539: PUSH
25540: LD_INT 0
25542: PUSH
25543: LD_INT 8
25545: PUSH
25546: LD_INT 9
25548: PUSH
25549: LD_INT 10
25551: PUSH
25552: LD_INT 11
25554: PUSH
25555: LD_INT 12
25557: PUSH
25558: LD_INT 13
25560: PUSH
25561: LD_INT 16
25563: PUSH
25564: LD_INT 17
25566: PUSH
25567: LD_INT 18
25569: PUSH
25570: LD_INT 19
25572: PUSH
25573: LD_INT 20
25575: PUSH
25576: LD_INT 21
25578: PUSH
25579: EMPTY
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: IN
25594: NOT
25595: OR
25596: IFTRUE 25609
25598: PUSH
25599: LD_VAR 0 8
25603: PUSH
25604: LD_INT 5
25606: ARRAY
25607: NOT
25608: OR
25609: IFTRUE 25649
25611: PUSH
25612: LD_VAR 0 8
25616: PUSH
25617: LD_INT 6
25619: ARRAY
25620: PUSH
25621: LD_INT 1
25623: PUSH
25624: LD_INT 2
25626: PUSH
25627: LD_INT 7
25629: PUSH
25630: LD_INT 9
25632: PUSH
25633: LD_INT 10
25635: PUSH
25636: LD_INT 11
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: LIST
25643: LIST
25644: LIST
25645: LIST
25646: IN
25647: NOT
25648: OR
25649: IFFALSE 25655
// exit ;
25651: POP
25652: POP
25653: GO 25740
// end ;
25655: GO 25312
25657: POP
25658: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25659: LD_VAR 0 9
25663: PPUSH
25664: LD_VAR 0 3
25668: PPUSH
25669: LD_VAR 0 4
25673: PPUSH
25674: LD_INT 20
25676: PPUSH
25677: CALL 17559 0 4
25681: PUSH
25682: LD_INT 4
25684: ARRAY
25685: IFFALSE 25689
// exit ;
25687: GO 25740
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25689: LD_VAR 0 2
25693: PUSH
25694: LD_INT 29
25696: PUSH
25697: LD_INT 30
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: IN
25704: IFFALSE 25728
25706: PUSH
25707: LD_VAR 0 3
25711: PPUSH
25712: LD_VAR 0 4
25716: PPUSH
25717: LD_VAR 0 9
25721: PPUSH
25722: CALL_OW 440
25726: NOT
25727: AND
25728: IFFALSE 25732
// exit ;
25730: GO 25740
// result := true ;
25732: LD_ADDR_VAR 0 6
25736: PUSH
25737: LD_INT 1
25739: ST_TO_ADDR
// end ;
25740: LD_VAR 0 6
25744: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25745: LD_INT 0
25747: PPUSH
25748: PPUSH
25749: PPUSH
25750: PPUSH
25751: PPUSH
25752: PPUSH
25753: PPUSH
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
25759: PPUSH
25760: PPUSH
25761: PPUSH
25762: PPUSH
25763: PPUSH
25764: PPUSH
25765: PPUSH
25766: PPUSH
25767: PPUSH
25768: PPUSH
25769: PPUSH
25770: PPUSH
25771: PPUSH
25772: PPUSH
25773: PPUSH
25774: PPUSH
25775: PPUSH
25776: PPUSH
25777: PPUSH
25778: PPUSH
25779: PPUSH
25780: PPUSH
25781: PPUSH
25782: PPUSH
25783: PPUSH
25784: PPUSH
25785: PPUSH
25786: PPUSH
25787: PPUSH
25788: PPUSH
25789: PPUSH
25790: PPUSH
25791: PPUSH
25792: PPUSH
25793: PPUSH
25794: PPUSH
25795: PPUSH
25796: PPUSH
25797: PPUSH
25798: PPUSH
25799: PPUSH
25800: PPUSH
25801: PPUSH
25802: PPUSH
25803: PPUSH
25804: PPUSH
// result = [ ] ;
25805: LD_ADDR_VAR 0 7
25809: PUSH
25810: EMPTY
25811: ST_TO_ADDR
// temp_list = [ ] ;
25812: LD_ADDR_VAR 0 9
25816: PUSH
25817: EMPTY
25818: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25819: LD_VAR 0 4
25823: PUSH
25824: LD_INT 0
25826: PUSH
25827: LD_INT 1
25829: PUSH
25830: LD_INT 2
25832: PUSH
25833: LD_INT 3
25835: PUSH
25836: LD_INT 4
25838: PUSH
25839: LD_INT 5
25841: PUSH
25842: EMPTY
25843: LIST
25844: LIST
25845: LIST
25846: LIST
25847: LIST
25848: LIST
25849: IN
25850: NOT
25851: IFTRUE 25894
25853: PUSH
25854: LD_VAR 0 1
25858: PUSH
25859: LD_INT 0
25861: PUSH
25862: LD_INT 1
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: IN
25869: IFFALSE 25893
25871: PUSH
25872: LD_VAR 0 5
25876: PUSH
25877: LD_INT 1
25879: PUSH
25880: LD_INT 2
25882: PUSH
25883: LD_INT 3
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: LIST
25890: IN
25891: NOT
25892: AND
25893: OR
25894: IFFALSE 25898
// exit ;
25896: GO 44297
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25898: LD_VAR 0 1
25902: PUSH
25903: LD_INT 6
25905: PUSH
25906: LD_INT 7
25908: PUSH
25909: LD_INT 8
25911: PUSH
25912: LD_INT 13
25914: PUSH
25915: LD_INT 12
25917: PUSH
25918: LD_INT 15
25920: PUSH
25921: LD_INT 11
25923: PUSH
25924: LD_INT 14
25926: PUSH
25927: LD_INT 10
25929: PUSH
25930: EMPTY
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: LIST
25940: IN
25941: IFFALSE 25951
// btype = b_lab ;
25943: LD_ADDR_VAR 0 1
25947: PUSH
25948: LD_INT 6
25950: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25951: LD_VAR 0 6
25955: PUSH
25956: LD_INT 0
25958: PUSH
25959: LD_INT 1
25961: PUSH
25962: LD_INT 2
25964: PUSH
25965: EMPTY
25966: LIST
25967: LIST
25968: LIST
25969: IN
25970: NOT
25971: IFTRUE 26039
25973: PUSH
25974: LD_VAR 0 1
25978: PUSH
25979: LD_INT 0
25981: PUSH
25982: LD_INT 1
25984: PUSH
25985: LD_INT 2
25987: PUSH
25988: LD_INT 3
25990: PUSH
25991: LD_INT 6
25993: PUSH
25994: LD_INT 36
25996: PUSH
25997: LD_INT 4
25999: PUSH
26000: LD_INT 5
26002: PUSH
26003: LD_INT 31
26005: PUSH
26006: LD_INT 32
26008: PUSH
26009: LD_INT 33
26011: PUSH
26012: EMPTY
26013: LIST
26014: LIST
26015: LIST
26016: LIST
26017: LIST
26018: LIST
26019: LIST
26020: LIST
26021: LIST
26022: LIST
26023: LIST
26024: IN
26025: NOT
26026: IFFALSE 26038
26028: PUSH
26029: LD_VAR 0 6
26033: PUSH
26034: LD_INT 1
26036: EQUAL
26037: AND
26038: OR
26039: IFTRUE 26071
26041: PUSH
26042: LD_VAR 0 1
26046: PUSH
26047: LD_INT 2
26049: PUSH
26050: LD_INT 3
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: IN
26057: NOT
26058: IFFALSE 26070
26060: PUSH
26061: LD_VAR 0 6
26065: PUSH
26066: LD_INT 2
26068: EQUAL
26069: AND
26070: OR
26071: IFFALSE 26081
// mode = 0 ;
26073: LD_ADDR_VAR 0 6
26077: PUSH
26078: LD_INT 0
26080: ST_TO_ADDR
// case mode of 0 :
26081: LD_VAR 0 6
26085: PUSH
26086: LD_INT 0
26088: DOUBLE
26089: EQUAL
26090: IFTRUE 26094
26092: GO 37547
26094: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
26095: LD_ADDR_VAR 0 11
26099: PUSH
26100: LD_INT 0
26102: PUSH
26103: LD_INT 0
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 1
26115: NEG
26116: PUSH
26117: EMPTY
26118: LIST
26119: LIST
26120: PUSH
26121: LD_INT 1
26123: PUSH
26124: LD_INT 0
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: PUSH
26131: LD_INT 1
26133: PUSH
26134: LD_INT 1
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PUSH
26141: LD_INT 0
26143: PUSH
26144: LD_INT 1
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_INT 1
26153: NEG
26154: PUSH
26155: LD_INT 0
26157: PUSH
26158: EMPTY
26159: LIST
26160: LIST
26161: PUSH
26162: LD_INT 1
26164: NEG
26165: PUSH
26166: LD_INT 1
26168: NEG
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: LD_INT 1
26176: NEG
26177: PUSH
26178: LD_INT 2
26180: NEG
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 0
26188: PUSH
26189: LD_INT 2
26191: NEG
26192: PUSH
26193: EMPTY
26194: LIST
26195: LIST
26196: PUSH
26197: LD_INT 1
26199: PUSH
26200: LD_INT 1
26202: NEG
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 1
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: LD_INT 0
26220: PUSH
26221: LD_INT 2
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 1
26230: NEG
26231: PUSH
26232: LD_INT 1
26234: PUSH
26235: EMPTY
26236: LIST
26237: LIST
26238: PUSH
26239: LD_INT 1
26241: PUSH
26242: LD_INT 3
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 0
26251: PUSH
26252: LD_INT 3
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 1
26261: NEG
26262: PUSH
26263: LD_INT 2
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: LIST
26274: LIST
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26288: LD_ADDR_VAR 0 12
26292: PUSH
26293: LD_INT 0
26295: PUSH
26296: LD_INT 0
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: PUSH
26303: LD_INT 0
26305: PUSH
26306: LD_INT 1
26308: NEG
26309: PUSH
26310: EMPTY
26311: LIST
26312: LIST
26313: PUSH
26314: LD_INT 1
26316: PUSH
26317: LD_INT 0
26319: PUSH
26320: EMPTY
26321: LIST
26322: LIST
26323: PUSH
26324: LD_INT 1
26326: PUSH
26327: LD_INT 1
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PUSH
26334: LD_INT 0
26336: PUSH
26337: LD_INT 1
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 1
26346: NEG
26347: PUSH
26348: LD_INT 0
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: LD_INT 1
26357: NEG
26358: PUSH
26359: LD_INT 1
26361: NEG
26362: PUSH
26363: EMPTY
26364: LIST
26365: LIST
26366: PUSH
26367: LD_INT 1
26369: PUSH
26370: LD_INT 1
26372: NEG
26373: PUSH
26374: EMPTY
26375: LIST
26376: LIST
26377: PUSH
26378: LD_INT 2
26380: PUSH
26381: LD_INT 0
26383: PUSH
26384: EMPTY
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 2
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 1
26400: NEG
26401: PUSH
26402: LD_INT 1
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 2
26411: NEG
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 2
26422: NEG
26423: PUSH
26424: LD_INT 1
26426: NEG
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: LD_INT 2
26434: NEG
26435: PUSH
26436: LD_INT 1
26438: PUSH
26439: EMPTY
26440: LIST
26441: LIST
26442: PUSH
26443: LD_INT 3
26445: NEG
26446: PUSH
26447: LD_INT 0
26449: PUSH
26450: EMPTY
26451: LIST
26452: LIST
26453: PUSH
26454: LD_INT 3
26456: NEG
26457: PUSH
26458: LD_INT 1
26460: NEG
26461: PUSH
26462: EMPTY
26463: LIST
26464: LIST
26465: PUSH
26466: EMPTY
26467: LIST
26468: LIST
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: LIST
26474: LIST
26475: LIST
26476: LIST
26477: LIST
26478: LIST
26479: LIST
26480: LIST
26481: LIST
26482: LIST
26483: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26484: LD_ADDR_VAR 0 13
26488: PUSH
26489: LD_INT 0
26491: PUSH
26492: LD_INT 0
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 0
26501: PUSH
26502: LD_INT 1
26504: NEG
26505: PUSH
26506: EMPTY
26507: LIST
26508: LIST
26509: PUSH
26510: LD_INT 1
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: PUSH
26523: LD_INT 1
26525: PUSH
26526: EMPTY
26527: LIST
26528: LIST
26529: PUSH
26530: LD_INT 0
26532: PUSH
26533: LD_INT 1
26535: PUSH
26536: EMPTY
26537: LIST
26538: LIST
26539: PUSH
26540: LD_INT 1
26542: NEG
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 1
26553: NEG
26554: PUSH
26555: LD_INT 1
26557: NEG
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 1
26565: NEG
26566: PUSH
26567: LD_INT 2
26569: NEG
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: PUSH
26575: LD_INT 2
26577: PUSH
26578: LD_INT 1
26580: PUSH
26581: EMPTY
26582: LIST
26583: LIST
26584: PUSH
26585: LD_INT 2
26587: PUSH
26588: LD_INT 2
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 1
26597: PUSH
26598: LD_INT 2
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 2
26607: NEG
26608: PUSH
26609: LD_INT 1
26611: NEG
26612: PUSH
26613: EMPTY
26614: LIST
26615: LIST
26616: PUSH
26617: LD_INT 2
26619: NEG
26620: PUSH
26621: LD_INT 2
26623: NEG
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: LD_INT 2
26631: NEG
26632: PUSH
26633: LD_INT 3
26635: NEG
26636: PUSH
26637: EMPTY
26638: LIST
26639: LIST
26640: PUSH
26641: LD_INT 3
26643: NEG
26644: PUSH
26645: LD_INT 2
26647: NEG
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: LD_INT 3
26655: NEG
26656: PUSH
26657: LD_INT 3
26659: NEG
26660: PUSH
26661: EMPTY
26662: LIST
26663: LIST
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26683: LD_ADDR_VAR 0 14
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 0
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 1
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: LD_INT 0
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: LD_INT 1
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: NEG
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 1
26752: NEG
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 1
26798: PUSH
26799: LD_INT 2
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 0
26808: PUSH
26809: LD_INT 2
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 1
26818: NEG
26819: PUSH
26820: LD_INT 1
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PUSH
26827: LD_INT 1
26829: NEG
26830: PUSH
26831: LD_INT 3
26833: NEG
26834: PUSH
26835: EMPTY
26836: LIST
26837: LIST
26838: PUSH
26839: LD_INT 0
26841: PUSH
26842: LD_INT 3
26844: NEG
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 1
26852: PUSH
26853: LD_INT 2
26855: NEG
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: LIST
26865: LIST
26866: LIST
26867: LIST
26868: LIST
26869: LIST
26870: LIST
26871: LIST
26872: LIST
26873: LIST
26874: LIST
26875: LIST
26876: LIST
26877: LIST
26878: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26879: LD_ADDR_VAR 0 15
26883: PUSH
26884: LD_INT 0
26886: PUSH
26887: LD_INT 0
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: PUSH
26894: LD_INT 0
26896: PUSH
26897: LD_INT 1
26899: NEG
26900: PUSH
26901: EMPTY
26902: LIST
26903: LIST
26904: PUSH
26905: LD_INT 1
26907: PUSH
26908: LD_INT 0
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: PUSH
26915: LD_INT 1
26917: PUSH
26918: LD_INT 1
26920: PUSH
26921: EMPTY
26922: LIST
26923: LIST
26924: PUSH
26925: LD_INT 0
26927: PUSH
26928: LD_INT 1
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 1
26937: NEG
26938: PUSH
26939: LD_INT 0
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 1
26948: NEG
26949: PUSH
26950: LD_INT 1
26952: NEG
26953: PUSH
26954: EMPTY
26955: LIST
26956: LIST
26957: PUSH
26958: LD_INT 1
26960: PUSH
26961: LD_INT 1
26963: NEG
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 2
26971: PUSH
26972: LD_INT 0
26974: PUSH
26975: EMPTY
26976: LIST
26977: LIST
26978: PUSH
26979: LD_INT 2
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: PUSH
26989: LD_INT 1
26991: NEG
26992: PUSH
26993: LD_INT 1
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 2
27002: NEG
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: LD_INT 2
27013: NEG
27014: PUSH
27015: LD_INT 1
27017: NEG
27018: PUSH
27019: EMPTY
27020: LIST
27021: LIST
27022: PUSH
27023: LD_INT 2
27025: PUSH
27026: LD_INT 1
27028: NEG
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: LD_INT 3
27036: PUSH
27037: LD_INT 0
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PUSH
27044: LD_INT 3
27046: PUSH
27047: LD_INT 1
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: LIST
27057: LIST
27058: LIST
27059: LIST
27060: LIST
27061: LIST
27062: LIST
27063: LIST
27064: LIST
27065: LIST
27066: LIST
27067: LIST
27068: LIST
27069: LIST
27070: LIST
27071: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
27072: LD_ADDR_VAR 0 16
27076: PUSH
27077: LD_INT 0
27079: PUSH
27080: LD_INT 0
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 0
27089: PUSH
27090: LD_INT 1
27092: NEG
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 1
27100: PUSH
27101: LD_INT 0
27103: PUSH
27104: EMPTY
27105: LIST
27106: LIST
27107: PUSH
27108: LD_INT 1
27110: PUSH
27111: LD_INT 1
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: LD_INT 1
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 1
27130: NEG
27131: PUSH
27132: LD_INT 0
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 1
27141: NEG
27142: PUSH
27143: LD_INT 1
27145: NEG
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 1
27153: NEG
27154: PUSH
27155: LD_INT 2
27157: NEG
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: PUSH
27163: LD_INT 2
27165: PUSH
27166: LD_INT 1
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: LD_INT 2
27175: PUSH
27176: LD_INT 2
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: PUSH
27183: LD_INT 1
27185: PUSH
27186: LD_INT 2
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: PUSH
27193: LD_INT 2
27195: NEG
27196: PUSH
27197: LD_INT 1
27199: NEG
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 2
27207: NEG
27208: PUSH
27209: LD_INT 2
27211: NEG
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: PUSH
27217: LD_INT 3
27219: PUSH
27220: LD_INT 2
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PUSH
27227: LD_INT 3
27229: PUSH
27230: LD_INT 3
27232: PUSH
27233: EMPTY
27234: LIST
27235: LIST
27236: PUSH
27237: LD_INT 2
27239: PUSH
27240: LD_INT 3
27242: PUSH
27243: EMPTY
27244: LIST
27245: LIST
27246: PUSH
27247: EMPTY
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: LIST
27256: LIST
27257: LIST
27258: LIST
27259: LIST
27260: LIST
27261: LIST
27262: LIST
27263: LIST
27264: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27265: LD_ADDR_VAR 0 17
27269: PUSH
27270: LD_INT 0
27272: PUSH
27273: LD_INT 0
27275: PUSH
27276: EMPTY
27277: LIST
27278: LIST
27279: PUSH
27280: LD_INT 0
27282: PUSH
27283: LD_INT 1
27285: NEG
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: PUSH
27291: LD_INT 1
27293: PUSH
27294: LD_INT 0
27296: PUSH
27297: EMPTY
27298: LIST
27299: LIST
27300: PUSH
27301: LD_INT 1
27303: PUSH
27304: LD_INT 1
27306: PUSH
27307: EMPTY
27308: LIST
27309: LIST
27310: PUSH
27311: LD_INT 0
27313: PUSH
27314: LD_INT 1
27316: PUSH
27317: EMPTY
27318: LIST
27319: LIST
27320: PUSH
27321: LD_INT 1
27323: NEG
27324: PUSH
27325: LD_INT 0
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 1
27346: NEG
27347: PUSH
27348: LD_INT 2
27350: NEG
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: PUSH
27356: LD_INT 0
27358: PUSH
27359: LD_INT 2
27361: NEG
27362: PUSH
27363: EMPTY
27364: LIST
27365: LIST
27366: PUSH
27367: LD_INT 1
27369: PUSH
27370: LD_INT 1
27372: NEG
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 2
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 2
27390: PUSH
27391: LD_INT 1
27393: PUSH
27394: EMPTY
27395: LIST
27396: LIST
27397: PUSH
27398: LD_INT 2
27400: PUSH
27401: LD_INT 2
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: LD_INT 1
27410: PUSH
27411: LD_INT 2
27413: PUSH
27414: EMPTY
27415: LIST
27416: LIST
27417: PUSH
27418: LD_INT 0
27420: PUSH
27421: LD_INT 2
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 1
27430: NEG
27431: PUSH
27432: LD_INT 1
27434: PUSH
27435: EMPTY
27436: LIST
27437: LIST
27438: PUSH
27439: LD_INT 2
27441: NEG
27442: PUSH
27443: LD_INT 0
27445: PUSH
27446: EMPTY
27447: LIST
27448: LIST
27449: PUSH
27450: LD_INT 2
27452: NEG
27453: PUSH
27454: LD_INT 1
27456: NEG
27457: PUSH
27458: EMPTY
27459: LIST
27460: LIST
27461: PUSH
27462: LD_INT 2
27464: NEG
27465: PUSH
27466: LD_INT 2
27468: NEG
27469: PUSH
27470: EMPTY
27471: LIST
27472: LIST
27473: PUSH
27474: EMPTY
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: LIST
27481: LIST
27482: LIST
27483: LIST
27484: LIST
27485: LIST
27486: LIST
27487: LIST
27488: LIST
27489: LIST
27490: LIST
27491: LIST
27492: LIST
27493: LIST
27494: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27495: LD_ADDR_VAR 0 18
27499: PUSH
27500: LD_INT 0
27502: PUSH
27503: LD_INT 0
27505: PUSH
27506: EMPTY
27507: LIST
27508: LIST
27509: PUSH
27510: LD_INT 0
27512: PUSH
27513: LD_INT 1
27515: NEG
27516: PUSH
27517: EMPTY
27518: LIST
27519: LIST
27520: PUSH
27521: LD_INT 1
27523: PUSH
27524: LD_INT 0
27526: PUSH
27527: EMPTY
27528: LIST
27529: LIST
27530: PUSH
27531: LD_INT 1
27533: PUSH
27534: LD_INT 1
27536: PUSH
27537: EMPTY
27538: LIST
27539: LIST
27540: PUSH
27541: LD_INT 0
27543: PUSH
27544: LD_INT 1
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PUSH
27551: LD_INT 1
27553: NEG
27554: PUSH
27555: LD_INT 0
27557: PUSH
27558: EMPTY
27559: LIST
27560: LIST
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 1
27576: NEG
27577: PUSH
27578: LD_INT 2
27580: NEG
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: PUSH
27586: LD_INT 0
27588: PUSH
27589: LD_INT 2
27591: NEG
27592: PUSH
27593: EMPTY
27594: LIST
27595: LIST
27596: PUSH
27597: LD_INT 1
27599: PUSH
27600: LD_INT 1
27602: NEG
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 2
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 2
27620: PUSH
27621: LD_INT 1
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 2
27630: PUSH
27631: LD_INT 2
27633: PUSH
27634: EMPTY
27635: LIST
27636: LIST
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: LD_INT 2
27643: PUSH
27644: EMPTY
27645: LIST
27646: LIST
27647: PUSH
27648: LD_INT 0
27650: PUSH
27651: LD_INT 2
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: PUSH
27658: LD_INT 1
27660: NEG
27661: PUSH
27662: LD_INT 1
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 2
27671: NEG
27672: PUSH
27673: LD_INT 0
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: PUSH
27680: LD_INT 2
27682: NEG
27683: PUSH
27684: LD_INT 1
27686: NEG
27687: PUSH
27688: EMPTY
27689: LIST
27690: LIST
27691: PUSH
27692: LD_INT 2
27694: NEG
27695: PUSH
27696: LD_INT 2
27698: NEG
27699: PUSH
27700: EMPTY
27701: LIST
27702: LIST
27703: PUSH
27704: EMPTY
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: LIST
27719: LIST
27720: LIST
27721: LIST
27722: LIST
27723: LIST
27724: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27725: LD_ADDR_VAR 0 19
27729: PUSH
27730: LD_INT 0
27732: PUSH
27733: LD_INT 0
27735: PUSH
27736: EMPTY
27737: LIST
27738: LIST
27739: PUSH
27740: LD_INT 0
27742: PUSH
27743: LD_INT 1
27745: NEG
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PUSH
27751: LD_INT 1
27753: PUSH
27754: LD_INT 0
27756: PUSH
27757: EMPTY
27758: LIST
27759: LIST
27760: PUSH
27761: LD_INT 1
27763: PUSH
27764: LD_INT 1
27766: PUSH
27767: EMPTY
27768: LIST
27769: LIST
27770: PUSH
27771: LD_INT 0
27773: PUSH
27774: LD_INT 1
27776: PUSH
27777: EMPTY
27778: LIST
27779: LIST
27780: PUSH
27781: LD_INT 1
27783: NEG
27784: PUSH
27785: LD_INT 0
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: LD_INT 1
27798: NEG
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 1
27806: NEG
27807: PUSH
27808: LD_INT 2
27810: NEG
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: PUSH
27816: LD_INT 0
27818: PUSH
27819: LD_INT 2
27821: NEG
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 1
27829: PUSH
27830: LD_INT 1
27832: NEG
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 2
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 2
27850: PUSH
27851: LD_INT 1
27853: PUSH
27854: EMPTY
27855: LIST
27856: LIST
27857: PUSH
27858: LD_INT 2
27860: PUSH
27861: LD_INT 2
27863: PUSH
27864: EMPTY
27865: LIST
27866: LIST
27867: PUSH
27868: LD_INT 1
27870: PUSH
27871: LD_INT 2
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 0
27880: PUSH
27881: LD_INT 2
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 1
27890: NEG
27891: PUSH
27892: LD_INT 1
27894: PUSH
27895: EMPTY
27896: LIST
27897: LIST
27898: PUSH
27899: LD_INT 2
27901: NEG
27902: PUSH
27903: LD_INT 0
27905: PUSH
27906: EMPTY
27907: LIST
27908: LIST
27909: PUSH
27910: LD_INT 2
27912: NEG
27913: PUSH
27914: LD_INT 1
27916: NEG
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 2
27924: NEG
27925: PUSH
27926: LD_INT 2
27928: NEG
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: LIST
27947: LIST
27948: LIST
27949: LIST
27950: LIST
27951: LIST
27952: LIST
27953: LIST
27954: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27955: LD_ADDR_VAR 0 20
27959: PUSH
27960: LD_INT 0
27962: PUSH
27963: LD_INT 0
27965: PUSH
27966: EMPTY
27967: LIST
27968: LIST
27969: PUSH
27970: LD_INT 0
27972: PUSH
27973: LD_INT 1
27975: NEG
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 1
27983: PUSH
27984: LD_INT 0
27986: PUSH
27987: EMPTY
27988: LIST
27989: LIST
27990: PUSH
27991: LD_INT 1
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: EMPTY
27998: LIST
27999: LIST
28000: PUSH
28001: LD_INT 0
28003: PUSH
28004: LD_INT 1
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 1
28013: NEG
28014: PUSH
28015: LD_INT 0
28017: PUSH
28018: EMPTY
28019: LIST
28020: LIST
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: LD_INT 1
28028: NEG
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 1
28036: NEG
28037: PUSH
28038: LD_INT 2
28040: NEG
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: LD_INT 0
28048: PUSH
28049: LD_INT 2
28051: NEG
28052: PUSH
28053: EMPTY
28054: LIST
28055: LIST
28056: PUSH
28057: LD_INT 1
28059: PUSH
28060: LD_INT 1
28062: NEG
28063: PUSH
28064: EMPTY
28065: LIST
28066: LIST
28067: PUSH
28068: LD_INT 2
28070: PUSH
28071: LD_INT 0
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PUSH
28078: LD_INT 2
28080: PUSH
28081: LD_INT 1
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: LD_INT 2
28090: PUSH
28091: LD_INT 2
28093: PUSH
28094: EMPTY
28095: LIST
28096: LIST
28097: PUSH
28098: LD_INT 1
28100: PUSH
28101: LD_INT 2
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: LD_INT 0
28110: PUSH
28111: LD_INT 2
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 1
28120: NEG
28121: PUSH
28122: LD_INT 1
28124: PUSH
28125: EMPTY
28126: LIST
28127: LIST
28128: PUSH
28129: LD_INT 2
28131: NEG
28132: PUSH
28133: LD_INT 0
28135: PUSH
28136: EMPTY
28137: LIST
28138: LIST
28139: PUSH
28140: LD_INT 2
28142: NEG
28143: PUSH
28144: LD_INT 1
28146: NEG
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PUSH
28152: LD_INT 2
28154: NEG
28155: PUSH
28156: LD_INT 2
28158: NEG
28159: PUSH
28160: EMPTY
28161: LIST
28162: LIST
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: LIST
28168: LIST
28169: LIST
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: LIST
28175: LIST
28176: LIST
28177: LIST
28178: LIST
28179: LIST
28180: LIST
28181: LIST
28182: LIST
28183: LIST
28184: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28185: LD_ADDR_VAR 0 21
28189: PUSH
28190: LD_INT 0
28192: PUSH
28193: LD_INT 0
28195: PUSH
28196: EMPTY
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 0
28202: PUSH
28203: LD_INT 1
28205: NEG
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PUSH
28211: LD_INT 1
28213: PUSH
28214: LD_INT 0
28216: PUSH
28217: EMPTY
28218: LIST
28219: LIST
28220: PUSH
28221: LD_INT 1
28223: PUSH
28224: LD_INT 1
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 0
28233: PUSH
28234: LD_INT 1
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: LD_INT 1
28243: NEG
28244: PUSH
28245: LD_INT 0
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 1
28254: NEG
28255: PUSH
28256: LD_INT 1
28258: NEG
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: LD_INT 1
28266: NEG
28267: PUSH
28268: LD_INT 2
28270: NEG
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 0
28278: PUSH
28279: LD_INT 2
28281: NEG
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 1
28289: PUSH
28290: LD_INT 1
28292: NEG
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: PUSH
28301: LD_INT 0
28303: PUSH
28304: EMPTY
28305: LIST
28306: LIST
28307: PUSH
28308: LD_INT 2
28310: PUSH
28311: LD_INT 1
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 2
28320: PUSH
28321: LD_INT 2
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 1
28330: PUSH
28331: LD_INT 2
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 0
28340: PUSH
28341: LD_INT 2
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 1
28350: NEG
28351: PUSH
28352: LD_INT 1
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: LD_INT 2
28361: NEG
28362: PUSH
28363: LD_INT 0
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 2
28372: NEG
28373: PUSH
28374: LD_INT 1
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: NEG
28385: PUSH
28386: LD_INT 2
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: LIST
28413: LIST
28414: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28415: LD_ADDR_VAR 0 22
28419: PUSH
28420: LD_INT 0
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: EMPTY
28427: LIST
28428: LIST
28429: PUSH
28430: LD_INT 0
28432: PUSH
28433: LD_INT 1
28435: NEG
28436: PUSH
28437: EMPTY
28438: LIST
28439: LIST
28440: PUSH
28441: LD_INT 1
28443: PUSH
28444: LD_INT 0
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: LD_INT 1
28453: PUSH
28454: LD_INT 1
28456: PUSH
28457: EMPTY
28458: LIST
28459: LIST
28460: PUSH
28461: LD_INT 0
28463: PUSH
28464: LD_INT 1
28466: PUSH
28467: EMPTY
28468: LIST
28469: LIST
28470: PUSH
28471: LD_INT 1
28473: NEG
28474: PUSH
28475: LD_INT 0
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: LD_INT 1
28488: NEG
28489: PUSH
28490: EMPTY
28491: LIST
28492: LIST
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: LD_INT 2
28500: NEG
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: PUSH
28506: LD_INT 0
28508: PUSH
28509: LD_INT 2
28511: NEG
28512: PUSH
28513: EMPTY
28514: LIST
28515: LIST
28516: PUSH
28517: LD_INT 1
28519: PUSH
28520: LD_INT 1
28522: NEG
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: PUSH
28528: LD_INT 2
28530: PUSH
28531: LD_INT 0
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 2
28540: PUSH
28541: LD_INT 1
28543: PUSH
28544: EMPTY
28545: LIST
28546: LIST
28547: PUSH
28548: LD_INT 2
28550: PUSH
28551: LD_INT 2
28553: PUSH
28554: EMPTY
28555: LIST
28556: LIST
28557: PUSH
28558: LD_INT 1
28560: PUSH
28561: LD_INT 2
28563: PUSH
28564: EMPTY
28565: LIST
28566: LIST
28567: PUSH
28568: LD_INT 0
28570: PUSH
28571: LD_INT 2
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: LD_INT 1
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: LD_INT 2
28591: NEG
28592: PUSH
28593: LD_INT 0
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_INT 2
28602: NEG
28603: PUSH
28604: LD_INT 1
28606: NEG
28607: PUSH
28608: EMPTY
28609: LIST
28610: LIST
28611: PUSH
28612: LD_INT 2
28614: NEG
28615: PUSH
28616: LD_INT 2
28618: NEG
28619: PUSH
28620: EMPTY
28621: LIST
28622: LIST
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: LIST
28636: LIST
28637: LIST
28638: LIST
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28645: LD_ADDR_VAR 0 23
28649: PUSH
28650: LD_INT 0
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: LD_INT 0
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: LD_INT 1
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 0
28693: PUSH
28694: LD_INT 1
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: NEG
28704: PUSH
28705: LD_INT 0
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 1
28714: NEG
28715: PUSH
28716: LD_INT 1
28718: NEG
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 1
28726: NEG
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 0
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 1
28749: PUSH
28750: LD_INT 1
28752: NEG
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 2
28760: PUSH
28761: LD_INT 0
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 2
28770: PUSH
28771: LD_INT 1
28773: PUSH
28774: EMPTY
28775: LIST
28776: LIST
28777: PUSH
28778: LD_INT 2
28780: PUSH
28781: LD_INT 2
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 0
28800: PUSH
28801: LD_INT 2
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: NEG
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 2
28821: NEG
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: EMPTY
28827: LIST
28828: LIST
28829: PUSH
28830: LD_INT 2
28832: NEG
28833: PUSH
28834: LD_INT 1
28836: NEG
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: LD_INT 2
28844: NEG
28845: PUSH
28846: LD_INT 2
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 2
28856: NEG
28857: PUSH
28858: LD_INT 3
28860: NEG
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: LD_INT 1
28868: NEG
28869: PUSH
28870: LD_INT 3
28872: NEG
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: PUSH
28878: LD_INT 1
28880: PUSH
28881: LD_INT 2
28883: NEG
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 2
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: LIST
28904: LIST
28905: LIST
28906: LIST
28907: LIST
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28925: LD_ADDR_VAR 0 24
28929: PUSH
28930: LD_INT 0
28932: PUSH
28933: LD_INT 0
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 0
28942: PUSH
28943: LD_INT 1
28945: NEG
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 1
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: EMPTY
28958: LIST
28959: LIST
28960: PUSH
28961: LD_INT 1
28963: PUSH
28964: LD_INT 1
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: PUSH
28971: LD_INT 0
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: NEG
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 1
28994: NEG
28995: PUSH
28996: LD_INT 1
28998: NEG
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 1
29006: NEG
29007: PUSH
29008: LD_INT 2
29010: NEG
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: LD_INT 0
29018: PUSH
29019: LD_INT 2
29021: NEG
29022: PUSH
29023: EMPTY
29024: LIST
29025: LIST
29026: PUSH
29027: LD_INT 1
29029: PUSH
29030: LD_INT 1
29032: NEG
29033: PUSH
29034: EMPTY
29035: LIST
29036: LIST
29037: PUSH
29038: LD_INT 2
29040: PUSH
29041: LD_INT 0
29043: PUSH
29044: EMPTY
29045: LIST
29046: LIST
29047: PUSH
29048: LD_INT 2
29050: PUSH
29051: LD_INT 1
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: PUSH
29058: LD_INT 2
29060: PUSH
29061: LD_INT 2
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 1
29070: PUSH
29071: LD_INT 2
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 1
29090: NEG
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 2
29101: NEG
29102: PUSH
29103: LD_INT 0
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 2
29112: NEG
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 2
29124: NEG
29125: PUSH
29126: LD_INT 2
29128: NEG
29129: PUSH
29130: EMPTY
29131: LIST
29132: LIST
29133: PUSH
29134: LD_INT 1
29136: PUSH
29137: LD_INT 2
29139: NEG
29140: PUSH
29141: EMPTY
29142: LIST
29143: LIST
29144: PUSH
29145: LD_INT 2
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 3
29158: PUSH
29159: LD_INT 1
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 3
29168: PUSH
29169: LD_INT 2
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: LIST
29180: LIST
29181: LIST
29182: LIST
29183: LIST
29184: LIST
29185: LIST
29186: LIST
29187: LIST
29188: LIST
29189: LIST
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
29201: LD_ADDR_VAR 0 25
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: LD_INT 0
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 0
29218: PUSH
29219: LD_INT 1
29221: NEG
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 1
29229: PUSH
29230: LD_INT 0
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 1
29239: PUSH
29240: LD_INT 1
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: PUSH
29253: EMPTY
29254: LIST
29255: LIST
29256: PUSH
29257: LD_INT 1
29259: NEG
29260: PUSH
29261: LD_INT 0
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: NEG
29271: PUSH
29272: LD_INT 1
29274: NEG
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: NEG
29283: PUSH
29284: LD_INT 2
29286: NEG
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: LD_INT 2
29297: NEG
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 1
29305: PUSH
29306: LD_INT 1
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 2
29316: PUSH
29317: LD_INT 0
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 2
29326: PUSH
29327: LD_INT 1
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 2
29336: PUSH
29337: LD_INT 2
29339: PUSH
29340: EMPTY
29341: LIST
29342: LIST
29343: PUSH
29344: LD_INT 1
29346: PUSH
29347: LD_INT 2
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 0
29356: PUSH
29357: LD_INT 2
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 1
29366: NEG
29367: PUSH
29368: LD_INT 1
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 2
29377: NEG
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 2
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: NEG
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 2
29400: NEG
29401: PUSH
29402: LD_INT 2
29404: NEG
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 3
29412: PUSH
29413: LD_INT 1
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 3
29422: PUSH
29423: LD_INT 2
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 2
29432: PUSH
29433: LD_INT 3
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: PUSH
29443: LD_INT 3
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
29475: LD_ADDR_VAR 0 26
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 0
29492: PUSH
29493: LD_INT 1
29495: NEG
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 0
29523: PUSH
29524: LD_INT 1
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: PUSH
29531: LD_INT 1
29533: NEG
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: LD_INT 2
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 0
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 1
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 2
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 2
29600: PUSH
29601: LD_INT 1
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: PUSH
29608: LD_INT 2
29610: PUSH
29611: LD_INT 2
29613: PUSH
29614: EMPTY
29615: LIST
29616: LIST
29617: PUSH
29618: LD_INT 1
29620: PUSH
29621: LD_INT 2
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 0
29630: PUSH
29631: LD_INT 2
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 1
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: PUSH
29645: EMPTY
29646: LIST
29647: LIST
29648: PUSH
29649: LD_INT 2
29651: NEG
29652: PUSH
29653: LD_INT 0
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 2
29662: NEG
29663: PUSH
29664: LD_INT 1
29666: NEG
29667: PUSH
29668: EMPTY
29669: LIST
29670: LIST
29671: PUSH
29672: LD_INT 2
29674: NEG
29675: PUSH
29676: LD_INT 2
29678: NEG
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: LD_INT 3
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 1
29696: PUSH
29697: LD_INT 3
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: LD_INT 2
29710: PUSH
29711: EMPTY
29712: LIST
29713: LIST
29714: PUSH
29715: LD_INT 2
29717: NEG
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: EMPTY
29723: LIST
29724: LIST
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: LIST
29746: LIST
29747: LIST
29748: LIST
29749: LIST
29750: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29751: LD_ADDR_VAR 0 27
29755: PUSH
29756: LD_INT 0
29758: PUSH
29759: LD_INT 0
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 0
29768: PUSH
29769: LD_INT 1
29771: NEG
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 1
29779: PUSH
29780: LD_INT 0
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: PUSH
29790: LD_INT 1
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 0
29799: PUSH
29800: LD_INT 1
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 1
29809: NEG
29810: PUSH
29811: LD_INT 0
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 1
29820: NEG
29821: PUSH
29822: LD_INT 1
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: NEG
29833: PUSH
29834: LD_INT 2
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: LD_INT 2
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: LD_INT 1
29858: NEG
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: LD_INT 0
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 2
29876: PUSH
29877: LD_INT 1
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 2
29886: PUSH
29887: LD_INT 2
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 1
29896: PUSH
29897: LD_INT 2
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 0
29906: PUSH
29907: LD_INT 2
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 1
29916: NEG
29917: PUSH
29918: LD_INT 1
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 2
29927: NEG
29928: PUSH
29929: LD_INT 0
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 2
29938: NEG
29939: PUSH
29940: LD_INT 1
29942: NEG
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 2
29950: NEG
29951: PUSH
29952: LD_INT 2
29954: NEG
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 2
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 2
29973: NEG
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 3
29984: NEG
29985: PUSH
29986: LD_INT 1
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 3
29996: NEG
29997: PUSH
29998: LD_INT 2
30000: NEG
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: LIST
30028: LIST
30029: LIST
30030: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
30031: LD_ADDR_VAR 0 28
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: LD_INT 0
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 0
30048: PUSH
30049: LD_INT 1
30051: NEG
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: LD_INT 1
30059: PUSH
30060: LD_INT 0
30062: PUSH
30063: EMPTY
30064: LIST
30065: LIST
30066: PUSH
30067: LD_INT 1
30069: PUSH
30070: LD_INT 1
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 0
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 1
30112: NEG
30113: PUSH
30114: LD_INT 2
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 0
30124: PUSH
30125: LD_INT 2
30127: NEG
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: LD_INT 1
30138: NEG
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 2
30146: PUSH
30147: LD_INT 0
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: LD_INT 2
30156: PUSH
30157: LD_INT 1
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 2
30166: PUSH
30167: LD_INT 2
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: LD_INT 2
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 0
30186: PUSH
30187: LD_INT 2
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: NEG
30197: PUSH
30198: LD_INT 1
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 2
30207: NEG
30208: PUSH
30209: LD_INT 0
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 2
30218: NEG
30219: PUSH
30220: LD_INT 1
30222: NEG
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 2
30230: NEG
30231: PUSH
30232: LD_INT 2
30234: NEG
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: LD_INT 2
30242: NEG
30243: PUSH
30244: LD_INT 3
30246: NEG
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: LD_INT 3
30258: NEG
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 3
30266: NEG
30267: PUSH
30268: LD_INT 1
30270: NEG
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 3
30278: NEG
30279: PUSH
30280: LD_INT 2
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30313: LD_ADDR_VAR 0 29
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 1
30333: NEG
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 1
30351: PUSH
30352: LD_INT 1
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 0
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: LD_INT 1
30371: NEG
30372: PUSH
30373: LD_INT 0
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: LD_INT 1
30386: NEG
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: LD_INT 2
30398: NEG
30399: PUSH
30400: EMPTY
30401: LIST
30402: LIST
30403: PUSH
30404: LD_INT 0
30406: PUSH
30407: LD_INT 2
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: PUSH
30418: LD_INT 1
30420: NEG
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PUSH
30426: LD_INT 2
30428: PUSH
30429: LD_INT 0
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: PUSH
30436: LD_INT 2
30438: PUSH
30439: LD_INT 1
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 1
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: PUSH
30456: LD_INT 0
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: LD_INT 1
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 2
30479: NEG
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 2
30491: NEG
30492: PUSH
30493: LD_INT 2
30495: NEG
30496: PUSH
30497: EMPTY
30498: LIST
30499: LIST
30500: PUSH
30501: LD_INT 2
30503: NEG
30504: PUSH
30505: LD_INT 3
30507: NEG
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 2
30515: PUSH
30516: LD_INT 1
30518: NEG
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: LD_INT 3
30526: PUSH
30527: LD_INT 1
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: LD_INT 3
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 1
30546: NEG
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 3
30557: NEG
30558: PUSH
30559: LD_INT 2
30561: NEG
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: LIST
30571: LIST
30572: LIST
30573: LIST
30574: LIST
30575: LIST
30576: LIST
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30592: LD_ADDR_VAR 0 30
30596: PUSH
30597: LD_INT 0
30599: PUSH
30600: LD_INT 0
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 0
30609: PUSH
30610: LD_INT 1
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 1
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 1
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 0
30640: PUSH
30641: LD_INT 1
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 1
30650: NEG
30651: PUSH
30652: LD_INT 0
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 1
30661: NEG
30662: PUSH
30663: LD_INT 1
30665: NEG
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: LD_INT 2
30677: NEG
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 2
30688: NEG
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 1
30696: PUSH
30697: LD_INT 1
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 2
30707: PUSH
30708: LD_INT 0
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: LD_INT 2
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 2
30727: PUSH
30728: LD_INT 2
30730: PUSH
30731: EMPTY
30732: LIST
30733: LIST
30734: PUSH
30735: LD_INT 1
30737: PUSH
30738: LD_INT 2
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 2
30758: NEG
30759: PUSH
30760: LD_INT 0
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 1
30773: NEG
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 1
30781: NEG
30782: PUSH
30783: LD_INT 3
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 3
30804: PUSH
30805: LD_INT 2
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 2
30814: PUSH
30815: LD_INT 3
30817: PUSH
30818: EMPTY
30819: LIST
30820: LIST
30821: PUSH
30822: LD_INT 2
30824: NEG
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: EMPTY
30830: LIST
30831: LIST
30832: PUSH
30833: LD_INT 3
30835: NEG
30836: PUSH
30837: LD_INT 1
30839: NEG
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30870: LD_ADDR_VAR 0 31
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 1
30890: NEG
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 1
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: PUSH
30909: LD_INT 1
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 0
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 1
30928: NEG
30929: PUSH
30930: LD_INT 0
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 1
30939: NEG
30940: PUSH
30941: LD_INT 1
30943: NEG
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 2
30955: NEG
30956: PUSH
30957: EMPTY
30958: LIST
30959: LIST
30960: PUSH
30961: LD_INT 1
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 2
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: LD_INT 1
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 1
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: LD_INT 2
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 2
31035: NEG
31036: PUSH
31037: LD_INT 1
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 2
31047: NEG
31048: PUSH
31049: LD_INT 2
31051: NEG
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 2
31059: NEG
31060: PUSH
31061: LD_INT 3
31063: NEG
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 2
31071: PUSH
31072: LD_INT 1
31074: NEG
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 3
31082: PUSH
31083: LD_INT 1
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: LD_INT 3
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 1
31102: NEG
31103: PUSH
31104: LD_INT 2
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 3
31113: NEG
31114: PUSH
31115: LD_INT 2
31117: NEG
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: EMPTY
31124: LIST
31125: LIST
31126: LIST
31127: LIST
31128: LIST
31129: LIST
31130: LIST
31131: LIST
31132: LIST
31133: LIST
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31148: LD_ADDR_VAR 0 32
31152: PUSH
31153: LD_INT 0
31155: PUSH
31156: LD_INT 0
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 0
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 1
31176: PUSH
31177: LD_INT 0
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 1
31186: PUSH
31187: LD_INT 1
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 0
31196: PUSH
31197: LD_INT 1
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 1
31206: NEG
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: NEG
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: LD_INT 2
31233: NEG
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: LD_INT 2
31244: NEG
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 1
31252: PUSH
31253: LD_INT 1
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 2
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 2
31273: PUSH
31274: LD_INT 2
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: PUSH
31284: LD_INT 2
31286: PUSH
31287: EMPTY
31288: LIST
31289: LIST
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: LD_INT 2
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: NEG
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 2
31325: NEG
31326: PUSH
31327: LD_INT 1
31329: NEG
31330: PUSH
31331: EMPTY
31332: LIST
31333: LIST
31334: PUSH
31335: LD_INT 1
31337: NEG
31338: PUSH
31339: LD_INT 3
31341: NEG
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 1
31349: PUSH
31350: LD_INT 2
31352: NEG
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 3
31360: PUSH
31361: LD_INT 2
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 2
31370: PUSH
31371: LD_INT 3
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 2
31380: NEG
31381: PUSH
31382: LD_INT 1
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 3
31391: NEG
31392: PUSH
31393: LD_INT 1
31395: NEG
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: LIST
31414: LIST
31415: LIST
31416: LIST
31417: LIST
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31426: LD_ADDR_VAR 0 33
31430: PUSH
31431: LD_INT 0
31433: PUSH
31434: LD_INT 0
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: LD_INT 0
31443: PUSH
31444: LD_INT 1
31446: NEG
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 1
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 1
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 0
31474: PUSH
31475: LD_INT 1
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: LD_INT 0
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: NEG
31508: PUSH
31509: LD_INT 2
31511: NEG
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 1
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 2
31530: PUSH
31531: LD_INT 0
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: LD_INT 1
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 0
31560: PUSH
31561: LD_INT 2
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 1
31570: NEG
31571: PUSH
31572: LD_INT 1
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 2
31581: NEG
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 2
31592: NEG
31593: PUSH
31594: LD_INT 1
31596: NEG
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 2
31604: NEG
31605: PUSH
31606: LD_INT 2
31608: NEG
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 2
31616: NEG
31617: PUSH
31618: LD_INT 3
31620: NEG
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 2
31628: PUSH
31629: LD_INT 1
31631: NEG
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 3
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 3
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: LD_INT 2
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 3
31670: NEG
31671: PUSH
31672: LD_INT 2
31674: NEG
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: LIST
31698: LIST
31699: LIST
31700: LIST
31701: LIST
31702: LIST
31703: LIST
31704: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31705: LD_ADDR_VAR 0 34
31709: PUSH
31710: LD_INT 0
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 0
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 1
31743: PUSH
31744: LD_INT 1
31746: PUSH
31747: EMPTY
31748: LIST
31749: LIST
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: LD_INT 1
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 1
31763: NEG
31764: PUSH
31765: LD_INT 0
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: LD_INT 1
31778: NEG
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: PUSH
31784: LD_INT 1
31786: NEG
31787: PUSH
31788: LD_INT 2
31790: NEG
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: LD_INT 2
31801: NEG
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: PUSH
31810: LD_INT 1
31812: NEG
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 2
31820: PUSH
31821: LD_INT 1
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 2
31830: PUSH
31831: LD_INT 2
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: LD_INT 2
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: LD_INT 2
31861: NEG
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: EMPTY
31867: LIST
31868: LIST
31869: PUSH
31870: LD_INT 2
31872: NEG
31873: PUSH
31874: LD_INT 1
31876: NEG
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: NEG
31885: PUSH
31886: LD_INT 2
31888: NEG
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: LD_INT 1
31896: NEG
31897: PUSH
31898: LD_INT 3
31900: NEG
31901: PUSH
31902: EMPTY
31903: LIST
31904: LIST
31905: PUSH
31906: LD_INT 1
31908: PUSH
31909: LD_INT 2
31911: NEG
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 3
31919: PUSH
31920: LD_INT 2
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 2
31929: PUSH
31930: LD_INT 3
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 2
31939: NEG
31940: PUSH
31941: LD_INT 1
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 3
31950: NEG
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: EMPTY
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: LIST
31974: LIST
31975: LIST
31976: LIST
31977: LIST
31978: LIST
31979: LIST
31980: LIST
31981: LIST
31982: LIST
31983: LIST
31984: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31985: LD_ADDR_VAR 0 35
31989: PUSH
31990: LD_INT 0
31992: PUSH
31993: LD_INT 0
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 0
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: EMPTY
32008: LIST
32009: LIST
32010: PUSH
32011: LD_INT 1
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 1
32023: PUSH
32024: LD_INT 1
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 0
32033: PUSH
32034: LD_INT 1
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: NEG
32044: PUSH
32045: LD_INT 0
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: LD_INT 1
32054: NEG
32055: PUSH
32056: LD_INT 1
32058: NEG
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 2
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: EMPTY
32071: LIST
32072: LIST
32073: PUSH
32074: LD_INT 2
32076: NEG
32077: PUSH
32078: LD_INT 1
32080: NEG
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32097: LD_ADDR_VAR 0 36
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: LD_INT 1
32117: NEG
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 1
32125: PUSH
32126: LD_INT 0
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 1
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 0
32145: PUSH
32146: LD_INT 1
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 1
32155: NEG
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: NEG
32167: PUSH
32168: LD_INT 1
32170: NEG
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 1
32178: NEG
32179: PUSH
32180: LD_INT 2
32182: NEG
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 1
32190: PUSH
32191: LD_INT 2
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32209: LD_ADDR_VAR 0 37
32213: PUSH
32214: LD_INT 0
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: LD_INT 1
32229: NEG
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: LD_INT 0
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 1
32247: PUSH
32248: LD_INT 1
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: LD_INT 1
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: NEG
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 1
32278: NEG
32279: PUSH
32280: LD_INT 1
32282: NEG
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: LD_INT 1
32290: PUSH
32291: LD_INT 1
32293: NEG
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 1
32301: NEG
32302: PUSH
32303: LD_INT 1
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32321: LD_ADDR_VAR 0 38
32325: PUSH
32326: LD_INT 0
32328: PUSH
32329: LD_INT 0
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: LD_INT 0
32338: PUSH
32339: LD_INT 1
32341: NEG
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 1
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: LD_INT 1
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 1
32379: NEG
32380: PUSH
32381: LD_INT 0
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 1
32394: NEG
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 2
32402: PUSH
32403: LD_INT 1
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32433: LD_ADDR_VAR 0 39
32437: PUSH
32438: LD_INT 0
32440: PUSH
32441: LD_INT 0
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 1
32453: NEG
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: LD_INT 1
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: LD_INT 1
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: NEG
32492: PUSH
32493: LD_INT 0
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: NEG
32503: PUSH
32504: LD_INT 1
32506: NEG
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 1
32514: NEG
32515: PUSH
32516: LD_INT 2
32518: NEG
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 1
32526: PUSH
32527: LD_INT 2
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32545: LD_ADDR_VAR 0 40
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: LD_INT 1
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32657: LD_ADDR_VAR 0 41
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 1
32685: PUSH
32686: LD_INT 0
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: PUSH
32696: LD_INT 1
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: LD_INT 1
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 1
32715: NEG
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 1
32738: NEG
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 1
32750: PUSH
32751: LD_INT 1
32753: NEG
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 2
32761: PUSH
32762: LD_INT 0
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 2
32771: PUSH
32772: LD_INT 1
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: LD_INT 2
32781: PUSH
32782: LD_INT 2
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 1
32791: PUSH
32792: LD_INT 2
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: NEG
32802: PUSH
32803: LD_INT 1
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 2
32812: NEG
32813: PUSH
32814: LD_INT 0
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 2
32823: NEG
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 2
32835: NEG
32836: PUSH
32837: LD_INT 2
32839: NEG
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 2
32847: NEG
32848: PUSH
32849: LD_INT 3
32851: NEG
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 3
32870: PUSH
32871: LD_INT 0
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 3
32880: PUSH
32881: LD_INT 1
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 3
32890: PUSH
32891: LD_INT 2
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 3
32900: PUSH
32901: LD_INT 3
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 2
32910: PUSH
32911: LD_INT 3
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 2
32920: NEG
32921: PUSH
32922: LD_INT 1
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 3
32931: NEG
32932: PUSH
32933: LD_INT 0
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 3
32942: NEG
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 3
32954: NEG
32955: PUSH
32956: LD_INT 2
32958: NEG
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 3
32966: NEG
32967: PUSH
32968: LD_INT 3
32970: NEG
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33007: LD_ADDR_VAR 0 42
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 1
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 0
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 0
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 2
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 0
33100: PUSH
33101: LD_INT 2
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: PUSH
33112: LD_INT 1
33114: NEG
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 2
33122: PUSH
33123: LD_INT 1
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: PUSH
33130: LD_INT 2
33132: PUSH
33133: LD_INT 2
33135: PUSH
33136: EMPTY
33137: LIST
33138: LIST
33139: PUSH
33140: LD_INT 1
33142: PUSH
33143: LD_INT 2
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: LD_INT 0
33152: PUSH
33153: LD_INT 2
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 1
33162: NEG
33163: PUSH
33164: LD_INT 1
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: NEG
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 2
33185: NEG
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 2
33197: NEG
33198: PUSH
33199: LD_INT 3
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: NEG
33210: PUSH
33211: LD_INT 3
33213: NEG
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 0
33221: PUSH
33222: LD_INT 3
33224: NEG
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 1
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 3
33243: PUSH
33244: LD_INT 2
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 3
33253: PUSH
33254: LD_INT 3
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 2
33263: PUSH
33264: LD_INT 3
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: LD_INT 1
33273: PUSH
33274: LD_INT 3
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 0
33283: PUSH
33284: LD_INT 3
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 3
33304: NEG
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 3
33316: NEG
33317: PUSH
33318: LD_INT 3
33320: NEG
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33357: LD_ADDR_VAR 0 43
33361: PUSH
33362: LD_INT 0
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: LD_INT 2
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 2
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: LD_INT 1
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 1
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: LD_INT 2
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 1
33512: NEG
33513: PUSH
33514: LD_INT 1
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 2
33523: NEG
33524: PUSH
33525: LD_INT 0
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 2
33534: NEG
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: NEG
33547: PUSH
33548: LD_INT 3
33550: NEG
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 0
33558: PUSH
33559: LD_INT 3
33561: NEG
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 1
33569: PUSH
33570: LD_INT 2
33572: NEG
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 2
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 3
33591: PUSH
33592: LD_INT 0
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 3
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: PUSH
33612: LD_INT 3
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 0
33621: PUSH
33622: LD_INT 3
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: NEG
33632: PUSH
33633: LD_INT 2
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 2
33642: NEG
33643: PUSH
33644: LD_INT 1
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 3
33653: NEG
33654: PUSH
33655: LD_INT 0
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 3
33664: NEG
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33705: LD_ADDR_VAR 0 44
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 0
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: LD_INT 1
33725: NEG
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 1
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 0
33753: PUSH
33754: LD_INT 1
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 1
33763: NEG
33764: PUSH
33765: LD_INT 0
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: LD_INT 1
33778: NEG
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: LD_INT 2
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 1
33801: NEG
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 2
33809: PUSH
33810: LD_INT 0
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: LD_INT 2
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 1
33849: NEG
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 2
33860: NEG
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 2
33883: NEG
33884: PUSH
33885: LD_INT 2
33887: NEG
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: NEG
33896: PUSH
33897: LD_INT 3
33899: NEG
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 2
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 3
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 3
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 3
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 3
33948: PUSH
33949: LD_INT 3
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: PUSH
33959: LD_INT 3
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 3
33979: NEG
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 3
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 3
34002: NEG
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 3
34014: NEG
34015: PUSH
34016: LD_INT 3
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34055: LD_ADDR_VAR 0 45
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 1
34113: NEG
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 2
34180: PUSH
34181: LD_INT 2
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: PUSH
34191: LD_INT 2
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 0
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 1
34210: NEG
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: LD_INT 1
34225: NEG
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: LD_INT 2
34237: NEG
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: LD_INT 3
34249: NEG
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: LD_INT 3
34261: NEG
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 0
34269: PUSH
34270: LD_INT 3
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 3
34291: PUSH
34292: LD_INT 2
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 3
34301: PUSH
34302: LD_INT 3
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 2
34311: PUSH
34312: LD_INT 3
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 1
34321: PUSH
34322: LD_INT 3
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 0
34331: PUSH
34332: LD_INT 3
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 1
34341: NEG
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: EMPTY
34347: LIST
34348: LIST
34349: PUSH
34350: LD_INT 3
34352: NEG
34353: PUSH
34354: LD_INT 2
34356: NEG
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 3
34364: NEG
34365: PUSH
34366: LD_INT 3
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34405: LD_ADDR_VAR 0 46
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 0
34422: PUSH
34423: LD_INT 1
34425: NEG
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 0
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 0
34453: PUSH
34454: LD_INT 1
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 1
34463: NEG
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 1
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: NEG
34487: PUSH
34488: LD_INT 2
34490: NEG
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 0
34498: PUSH
34499: LD_INT 2
34501: NEG
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: PUSH
34510: LD_INT 1
34512: NEG
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 2
34520: PUSH
34521: LD_INT 0
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 2
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 1
34540: PUSH
34541: LD_INT 2
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: LD_INT 2
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: LD_INT 1
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 2
34571: NEG
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 2
34582: NEG
34583: PUSH
34584: LD_INT 1
34586: NEG
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 1
34594: NEG
34595: PUSH
34596: LD_INT 3
34598: NEG
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 0
34606: PUSH
34607: LD_INT 3
34609: NEG
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 1
34617: PUSH
34618: LD_INT 2
34620: NEG
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 2
34628: PUSH
34629: LD_INT 1
34631: NEG
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 3
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 1
34659: PUSH
34660: LD_INT 3
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 0
34669: PUSH
34670: LD_INT 3
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: LD_INT 1
34679: NEG
34680: PUSH
34681: LD_INT 2
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 2
34690: NEG
34691: PUSH
34692: LD_INT 1
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 3
34701: NEG
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 3
34712: NEG
34713: PUSH
34714: LD_INT 1
34716: NEG
34717: PUSH
34718: EMPTY
34719: LIST
34720: LIST
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34753: LD_ADDR_VAR 0 47
34757: PUSH
34758: LD_INT 0
34760: PUSH
34761: LD_INT 0
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 0
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: PUSH
34792: LD_INT 1
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 0
34801: PUSH
34802: LD_INT 1
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: NEG
34812: PUSH
34813: LD_INT 0
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: LD_INT 1
34826: NEG
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PUSH
34832: LD_INT 1
34834: NEG
34835: PUSH
34836: LD_INT 2
34838: NEG
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 1
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 2
34868: NEG
34869: PUSH
34870: LD_INT 1
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 2
34880: NEG
34881: PUSH
34882: LD_INT 2
34884: NEG
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34904: LD_ADDR_VAR 0 48
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: LD_INT 0
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 0
34921: PUSH
34922: LD_INT 1
34924: NEG
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: LD_INT 1
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 0
34952: PUSH
34953: LD_INT 1
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: LD_INT 0
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 1
34973: NEG
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 1
34985: NEG
34986: PUSH
34987: LD_INT 2
34989: NEG
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 0
34997: PUSH
34998: LD_INT 2
35000: NEG
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: LD_INT 1
35011: NEG
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 2
35019: PUSH
35020: LD_INT 0
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 2
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
35051: LD_ADDR_VAR 0 49
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 0
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 0
35068: PUSH
35069: LD_INT 1
35071: NEG
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: PUSH
35080: LD_INT 0
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PUSH
35087: LD_INT 1
35089: PUSH
35090: LD_INT 1
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: LD_INT 0
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 1
35109: NEG
35110: PUSH
35111: LD_INT 0
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 1
35120: NEG
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 2
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 2
35153: PUSH
35154: LD_INT 1
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 2
35163: PUSH
35164: LD_INT 2
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: LD_INT 2
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
35195: LD_ADDR_VAR 0 50
35199: PUSH
35200: LD_INT 0
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 0
35212: PUSH
35213: LD_INT 1
35215: NEG
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: PUSH
35234: LD_INT 1
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 0
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: EMPTY
35248: LIST
35249: LIST
35250: PUSH
35251: LD_INT 1
35253: NEG
35254: PUSH
35255: LD_INT 0
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 1
35264: NEG
35265: PUSH
35266: LD_INT 1
35268: NEG
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 2
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 2
35286: PUSH
35287: LD_INT 2
35289: PUSH
35290: EMPTY
35291: LIST
35292: LIST
35293: PUSH
35294: LD_INT 1
35296: PUSH
35297: LD_INT 2
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 0
35306: PUSH
35307: LD_INT 2
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: NEG
35317: PUSH
35318: LD_INT 1
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: LIST
35329: LIST
35330: LIST
35331: LIST
35332: LIST
35333: LIST
35334: LIST
35335: LIST
35336: LIST
35337: LIST
35338: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35339: LD_ADDR_VAR 0 51
35343: PUSH
35344: LD_INT 0
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 1
35377: PUSH
35378: LD_INT 1
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 0
35387: PUSH
35388: LD_INT 1
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: NEG
35398: PUSH
35399: LD_INT 0
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: PUSH
35406: LD_INT 1
35408: NEG
35409: PUSH
35410: LD_INT 1
35412: NEG
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 1
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: NEG
35441: PUSH
35442: LD_INT 1
35444: PUSH
35445: EMPTY
35446: LIST
35447: LIST
35448: PUSH
35449: LD_INT 2
35451: NEG
35452: PUSH
35453: LD_INT 0
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 2
35462: NEG
35463: PUSH
35464: LD_INT 1
35466: NEG
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: EMPTY
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35486: LD_ADDR_VAR 0 52
35490: PUSH
35491: LD_INT 0
35493: PUSH
35494: LD_INT 0
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: LD_INT 1
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 1
35555: NEG
35556: PUSH
35557: LD_INT 1
35559: NEG
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: NEG
35568: PUSH
35569: LD_INT 2
35571: NEG
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: LD_INT 1
35583: PUSH
35584: EMPTY
35585: LIST
35586: LIST
35587: PUSH
35588: LD_INT 2
35590: NEG
35591: PUSH
35592: LD_INT 0
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: NEG
35602: PUSH
35603: LD_INT 1
35605: NEG
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: NEG
35614: PUSH
35615: LD_INT 2
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35637: LD_ADDR_VAR 0 53
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: LD_INT 0
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 0
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 1
35665: PUSH
35666: LD_INT 0
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: EMPTY
35680: LIST
35681: LIST
35682: PUSH
35683: LD_INT 0
35685: PUSH
35686: LD_INT 1
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: LD_INT 2
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: LD_INT 2
35733: NEG
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 1
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: LD_INT 2
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 2
35762: PUSH
35763: LD_INT 1
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 2
35772: PUSH
35773: LD_INT 2
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 1
35782: PUSH
35783: LD_INT 2
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 0
35792: PUSH
35793: LD_INT 2
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PUSH
35800: LD_INT 1
35802: NEG
35803: PUSH
35804: LD_INT 1
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 2
35813: NEG
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 2
35824: NEG
35825: PUSH
35826: LD_INT 1
35828: NEG
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 2
35836: NEG
35837: PUSH
35838: LD_INT 2
35840: NEG
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: LIST
35865: LIST
35866: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35867: LD_ADDR_VAR 0 54
35871: PUSH
35872: LD_INT 0
35874: PUSH
35875: LD_INT 0
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 1
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 1
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 0
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: NEG
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: LD_INT 1
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 1
35948: NEG
35949: PUSH
35950: LD_INT 2
35952: NEG
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: LD_INT 2
35963: NEG
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: PUSH
35972: LD_INT 1
35974: NEG
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 2
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 2
35992: PUSH
35993: LD_INT 1
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 2
36002: PUSH
36003: LD_INT 2
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: PUSH
36013: LD_INT 2
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 0
36022: PUSH
36023: LD_INT 2
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 1
36032: NEG
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: NEG
36044: PUSH
36045: LD_INT 0
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 2
36054: NEG
36055: PUSH
36056: LD_INT 1
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 2
36066: NEG
36067: PUSH
36068: LD_INT 2
36070: NEG
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36097: LD_ADDR_VAR 0 55
36101: PUSH
36102: LD_INT 0
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: LD_INT 1
36117: NEG
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: LD_INT 0
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 1
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: NEG
36156: PUSH
36157: LD_INT 0
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: LD_INT 2
36182: NEG
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PUSH
36188: LD_INT 0
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 1
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 2
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 2
36222: PUSH
36223: LD_INT 1
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 2
36232: PUSH
36233: LD_INT 2
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 0
36252: PUSH
36253: LD_INT 2
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: NEG
36263: PUSH
36264: LD_INT 1
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 2
36273: NEG
36274: PUSH
36275: LD_INT 0
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 2
36284: NEG
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 2
36296: NEG
36297: PUSH
36298: LD_INT 2
36300: NEG
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36327: LD_ADDR_VAR 0 56
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 0
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 1
36347: NEG
36348: PUSH
36349: EMPTY
36350: LIST
36351: LIST
36352: PUSH
36353: LD_INT 1
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 1
36365: PUSH
36366: LD_INT 1
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 0
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 1
36385: NEG
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: EMPTY
36391: LIST
36392: LIST
36393: PUSH
36394: LD_INT 1
36396: NEG
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 1
36408: NEG
36409: PUSH
36410: LD_INT 2
36412: NEG
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 2
36423: NEG
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 1
36431: PUSH
36432: LD_INT 1
36434: NEG
36435: PUSH
36436: EMPTY
36437: LIST
36438: LIST
36439: PUSH
36440: LD_INT 2
36442: PUSH
36443: LD_INT 0
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 2
36452: PUSH
36453: LD_INT 1
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 2
36462: PUSH
36463: LD_INT 2
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 1
36472: PUSH
36473: LD_INT 2
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 0
36482: PUSH
36483: LD_INT 2
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 1
36492: NEG
36493: PUSH
36494: LD_INT 1
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 2
36503: NEG
36504: PUSH
36505: LD_INT 0
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 2
36514: NEG
36515: PUSH
36516: LD_INT 1
36518: NEG
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: NEG
36527: PUSH
36528: LD_INT 2
36530: NEG
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36557: LD_ADDR_VAR 0 57
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 1
36638: NEG
36639: PUSH
36640: LD_INT 2
36642: NEG
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 0
36650: PUSH
36651: LD_INT 2
36653: NEG
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: PUSH
36659: LD_INT 1
36661: PUSH
36662: LD_INT 1
36664: NEG
36665: PUSH
36666: EMPTY
36667: LIST
36668: LIST
36669: PUSH
36670: LD_INT 2
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: LD_INT 2
36682: PUSH
36683: LD_INT 1
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PUSH
36690: LD_INT 2
36692: PUSH
36693: LD_INT 2
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 1
36702: PUSH
36703: LD_INT 2
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 0
36712: PUSH
36713: LD_INT 2
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 1
36722: NEG
36723: PUSH
36724: LD_INT 1
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 2
36733: NEG
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: NEG
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 2
36756: NEG
36757: PUSH
36758: LD_INT 2
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: LIST
36785: LIST
36786: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36787: LD_ADDR_VAR 0 58
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: LD_INT 0
36797: PUSH
36798: EMPTY
36799: LIST
36800: LIST
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 1
36807: NEG
36808: PUSH
36809: EMPTY
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 1
36815: PUSH
36816: LD_INT 0
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: LD_INT 1
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 1
36845: NEG
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 1
36856: NEG
36857: PUSH
36858: LD_INT 1
36860: NEG
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 1
36868: NEG
36869: PUSH
36870: LD_INT 2
36872: NEG
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: LD_INT 2
36883: NEG
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 1
36891: PUSH
36892: LD_INT 1
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 2
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: LD_INT 2
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: PUSH
36972: LD_INT 2
36974: NEG
36975: PUSH
36976: LD_INT 1
36978: NEG
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 2
36986: NEG
36987: PUSH
36988: LD_INT 2
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37017: LD_ADDR_VAR 0 59
37021: PUSH
37022: LD_INT 0
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: LD_INT 1
37037: NEG
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: LD_INT 1
37045: PUSH
37046: LD_INT 0
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 1
37055: PUSH
37056: LD_INT 1
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: LD_INT 1
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 1
37075: NEG
37076: PUSH
37077: LD_INT 0
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: LD_INT 1
37086: NEG
37087: PUSH
37088: LD_INT 1
37090: NEG
37091: PUSH
37092: EMPTY
37093: LIST
37094: LIST
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: LIST
37100: LIST
37101: LIST
37102: LIST
37103: LIST
37104: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37105: LD_ADDR_VAR 0 60
37109: PUSH
37110: LD_INT 0
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 0
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 1
37133: PUSH
37134: LD_INT 0
37136: PUSH
37137: EMPTY
37138: LIST
37139: LIST
37140: PUSH
37141: LD_INT 1
37143: PUSH
37144: LD_INT 1
37146: PUSH
37147: EMPTY
37148: LIST
37149: LIST
37150: PUSH
37151: LD_INT 0
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: NEG
37164: PUSH
37165: LD_INT 0
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: NEG
37175: PUSH
37176: LD_INT 1
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37193: LD_ADDR_VAR 0 61
37197: PUSH
37198: LD_INT 0
37200: PUSH
37201: LD_INT 0
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 0
37210: PUSH
37211: LD_INT 1
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 1
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 1
37231: PUSH
37232: LD_INT 1
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 0
37241: PUSH
37242: LD_INT 1
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: NEG
37252: PUSH
37253: LD_INT 0
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 1
37262: NEG
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: EMPTY
37273: LIST
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: LIST
37280: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37281: LD_ADDR_VAR 0 62
37285: PUSH
37286: LD_INT 0
37288: PUSH
37289: LD_INT 0
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 0
37298: PUSH
37299: LD_INT 1
37301: NEG
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: LD_INT 0
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: PUSH
37320: LD_INT 1
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 0
37329: PUSH
37330: LD_INT 1
37332: PUSH
37333: EMPTY
37334: LIST
37335: LIST
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37369: LD_ADDR_VAR 0 63
37373: PUSH
37374: LD_INT 0
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: LD_INT 1
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: LD_INT 1
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: LD_INT 1
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 1
37427: NEG
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: LD_INT 1
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37457: LD_ADDR_VAR 0 64
37461: PUSH
37462: LD_INT 0
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 0
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: LD_INT 0
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 1
37495: PUSH
37496: LD_INT 1
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: LD_INT 0
37519: PUSH
37520: EMPTY
37521: LIST
37522: LIST
37523: PUSH
37524: LD_INT 1
37526: NEG
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: ST_TO_ADDR
// end ; 1 :
37545: GO 43442
37547: LD_INT 1
37549: DOUBLE
37550: EQUAL
37551: IFTRUE 37555
37553: GO 40178
37555: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37556: LD_ADDR_VAR 0 11
37560: PUSH
37561: LD_INT 1
37563: NEG
37564: PUSH
37565: LD_INT 3
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 0
37575: PUSH
37576: LD_INT 3
37578: NEG
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 1
37586: PUSH
37587: LD_INT 2
37589: NEG
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: LIST
37599: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37600: LD_ADDR_VAR 0 12
37604: PUSH
37605: LD_INT 2
37607: PUSH
37608: LD_INT 1
37610: NEG
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 3
37618: PUSH
37619: LD_INT 0
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: PUSH
37626: LD_INT 3
37628: PUSH
37629: LD_INT 1
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: LIST
37640: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37641: LD_ADDR_VAR 0 13
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: LD_INT 2
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 3
37658: PUSH
37659: LD_INT 3
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 2
37668: PUSH
37669: LD_INT 3
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: EMPTY
37677: LIST
37678: LIST
37679: LIST
37680: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37681: LD_ADDR_VAR 0 14
37685: PUSH
37686: LD_INT 1
37688: PUSH
37689: LD_INT 3
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: LD_INT 3
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: LD_INT 2
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: LIST
37721: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37722: LD_ADDR_VAR 0 15
37726: PUSH
37727: LD_INT 2
37729: NEG
37730: PUSH
37731: LD_INT 1
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 3
37740: NEG
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 3
37751: NEG
37752: PUSH
37753: LD_INT 1
37755: NEG
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: LIST
37765: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37766: LD_ADDR_VAR 0 16
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: LD_INT 3
37777: NEG
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 3
37785: NEG
37786: PUSH
37787: LD_INT 2
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 3
37797: NEG
37798: PUSH
37799: LD_INT 3
37801: NEG
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: LIST
37811: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37812: LD_ADDR_VAR 0 17
37816: PUSH
37817: LD_INT 1
37819: NEG
37820: PUSH
37821: LD_INT 3
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 0
37831: PUSH
37832: LD_INT 3
37834: NEG
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 1
37842: PUSH
37843: LD_INT 2
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: LIST
37855: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37856: LD_ADDR_VAR 0 18
37860: PUSH
37861: LD_INT 2
37863: PUSH
37864: LD_INT 1
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 3
37874: PUSH
37875: LD_INT 0
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 3
37884: PUSH
37885: LD_INT 1
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: LIST
37896: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37897: LD_ADDR_VAR 0 19
37901: PUSH
37902: LD_INT 3
37904: PUSH
37905: LD_INT 2
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 3
37914: PUSH
37915: LD_INT 3
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 2
37924: PUSH
37925: LD_INT 3
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37937: LD_ADDR_VAR 0 20
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 3
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: LD_INT 3
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: NEG
37965: PUSH
37966: LD_INT 2
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: EMPTY
37974: LIST
37975: LIST
37976: LIST
37977: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37978: LD_ADDR_VAR 0 21
37982: PUSH
37983: LD_INT 2
37985: NEG
37986: PUSH
37987: LD_INT 1
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 3
37996: NEG
37997: PUSH
37998: LD_INT 0
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 3
38007: NEG
38008: PUSH
38009: LD_INT 1
38011: NEG
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: LIST
38021: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38022: LD_ADDR_VAR 0 22
38026: PUSH
38027: LD_INT 2
38029: NEG
38030: PUSH
38031: LD_INT 3
38033: NEG
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 3
38041: NEG
38042: PUSH
38043: LD_INT 2
38045: NEG
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 3
38053: NEG
38054: PUSH
38055: LD_INT 3
38057: NEG
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: LIST
38067: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
38068: LD_ADDR_VAR 0 23
38072: PUSH
38073: LD_INT 0
38075: PUSH
38076: LD_INT 3
38078: NEG
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: NEG
38087: PUSH
38088: LD_INT 4
38090: NEG
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 1
38098: PUSH
38099: LD_INT 3
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: LIST
38111: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
38112: LD_ADDR_VAR 0 24
38116: PUSH
38117: LD_INT 3
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 3
38129: PUSH
38130: LD_INT 1
38132: NEG
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 4
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: LIST
38152: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
38153: LD_ADDR_VAR 0 25
38157: PUSH
38158: LD_INT 3
38160: PUSH
38161: LD_INT 3
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 4
38170: PUSH
38171: LD_INT 3
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 3
38180: PUSH
38181: LD_INT 4
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: LIST
38192: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
38193: LD_ADDR_VAR 0 26
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 3
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: PUSH
38211: LD_INT 4
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: LD_INT 3
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: LIST
38233: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
38234: LD_ADDR_VAR 0 27
38238: PUSH
38239: LD_INT 3
38241: NEG
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 3
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 4
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: LIST
38277: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
38278: LD_ADDR_VAR 0 28
38282: PUSH
38283: LD_INT 3
38285: NEG
38286: PUSH
38287: LD_INT 3
38289: NEG
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 3
38297: NEG
38298: PUSH
38299: LD_INT 4
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 4
38309: NEG
38310: PUSH
38311: LD_INT 3
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: LIST
38323: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
38324: LD_ADDR_VAR 0 29
38328: PUSH
38329: LD_INT 1
38331: NEG
38332: PUSH
38333: LD_INT 3
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 0
38343: PUSH
38344: LD_INT 3
38346: NEG
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: LD_INT 2
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: NEG
38366: PUSH
38367: LD_INT 4
38369: NEG
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: LD_INT 4
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: PUSH
38389: LD_INT 3
38391: NEG
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: LD_INT 5
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: LD_INT 5
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: PUSH
38423: LD_INT 4
38425: NEG
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: NEG
38434: PUSH
38435: LD_INT 6
38437: NEG
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 0
38445: PUSH
38446: LD_INT 6
38448: NEG
38449: PUSH
38450: EMPTY
38451: LIST
38452: LIST
38453: PUSH
38454: LD_INT 1
38456: PUSH
38457: LD_INT 5
38459: NEG
38460: PUSH
38461: EMPTY
38462: LIST
38463: LIST
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
38479: LD_ADDR_VAR 0 30
38483: PUSH
38484: LD_INT 2
38486: PUSH
38487: LD_INT 1
38489: NEG
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 3
38497: PUSH
38498: LD_INT 0
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 3
38507: PUSH
38508: LD_INT 1
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 3
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 4
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 4
38538: PUSH
38539: LD_INT 1
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 4
38548: PUSH
38549: LD_INT 1
38551: NEG
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 5
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 5
38569: PUSH
38570: LD_INT 1
38572: PUSH
38573: EMPTY
38574: LIST
38575: LIST
38576: PUSH
38577: LD_INT 5
38579: PUSH
38580: LD_INT 1
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: LD_INT 6
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 6
38600: PUSH
38601: LD_INT 1
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38622: LD_ADDR_VAR 0 31
38626: PUSH
38627: LD_INT 3
38629: PUSH
38630: LD_INT 2
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 3
38639: PUSH
38640: LD_INT 3
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 2
38649: PUSH
38650: LD_INT 3
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 4
38659: PUSH
38660: LD_INT 3
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 4
38669: PUSH
38670: LD_INT 4
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 3
38679: PUSH
38680: LD_INT 4
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: LD_INT 5
38689: PUSH
38690: LD_INT 4
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 5
38699: PUSH
38700: LD_INT 5
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 4
38709: PUSH
38710: LD_INT 5
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 6
38719: PUSH
38720: LD_INT 5
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 6
38729: PUSH
38730: LD_INT 6
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 5
38739: PUSH
38740: LD_INT 6
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38761: LD_ADDR_VAR 0 32
38765: PUSH
38766: LD_INT 1
38768: PUSH
38769: LD_INT 3
38771: PUSH
38772: EMPTY
38773: LIST
38774: LIST
38775: PUSH
38776: LD_INT 0
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: EMPTY
38783: LIST
38784: LIST
38785: PUSH
38786: LD_INT 1
38788: NEG
38789: PUSH
38790: LD_INT 2
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: LD_INT 4
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 0
38809: PUSH
38810: LD_INT 4
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: NEG
38820: PUSH
38821: LD_INT 3
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 1
38830: PUSH
38831: LD_INT 5
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 5
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: LD_INT 4
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 6
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: LD_INT 6
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 1
38881: NEG
38882: PUSH
38883: LD_INT 5
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38904: LD_ADDR_VAR 0 33
38908: PUSH
38909: LD_INT 2
38911: NEG
38912: PUSH
38913: LD_INT 1
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 3
38922: NEG
38923: PUSH
38924: LD_INT 0
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 3
38933: NEG
38934: PUSH
38935: LD_INT 1
38937: NEG
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 3
38945: NEG
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 4
38956: NEG
38957: PUSH
38958: LD_INT 0
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 4
38967: NEG
38968: PUSH
38969: LD_INT 1
38971: NEG
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 4
38979: NEG
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 5
38990: NEG
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 5
39001: NEG
39002: PUSH
39003: LD_INT 1
39005: NEG
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: LD_INT 5
39013: NEG
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 6
39024: NEG
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 6
39035: NEG
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
39059: LD_ADDR_VAR 0 34
39063: PUSH
39064: LD_INT 2
39066: NEG
39067: PUSH
39068: LD_INT 3
39070: NEG
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 3
39078: NEG
39079: PUSH
39080: LD_INT 2
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: LD_INT 3
39090: NEG
39091: PUSH
39092: LD_INT 3
39094: NEG
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 3
39102: NEG
39103: PUSH
39104: LD_INT 4
39106: NEG
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 4
39114: NEG
39115: PUSH
39116: LD_INT 3
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 4
39126: NEG
39127: PUSH
39128: LD_INT 4
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 4
39138: NEG
39139: PUSH
39140: LD_INT 5
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 5
39150: NEG
39151: PUSH
39152: LD_INT 4
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 5
39162: NEG
39163: PUSH
39164: LD_INT 5
39166: NEG
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 5
39174: NEG
39175: PUSH
39176: LD_INT 6
39178: NEG
39179: PUSH
39180: EMPTY
39181: LIST
39182: LIST
39183: PUSH
39184: LD_INT 6
39186: NEG
39187: PUSH
39188: LD_INT 5
39190: NEG
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 6
39198: NEG
39199: PUSH
39200: LD_INT 6
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: LIST
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
39222: LD_ADDR_VAR 0 41
39226: PUSH
39227: LD_INT 0
39229: PUSH
39230: LD_INT 2
39232: NEG
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: PUSH
39238: LD_INT 1
39240: NEG
39241: PUSH
39242: LD_INT 3
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 2
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
39266: LD_ADDR_VAR 0 42
39270: PUSH
39271: LD_INT 2
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 2
39283: PUSH
39284: LD_INT 1
39286: NEG
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 3
39294: PUSH
39295: LD_INT 1
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
39307: LD_ADDR_VAR 0 43
39311: PUSH
39312: LD_INT 2
39314: PUSH
39315: LD_INT 2
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 3
39324: PUSH
39325: LD_INT 2
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 2
39334: PUSH
39335: LD_INT 3
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: LIST
39346: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
39347: LD_ADDR_VAR 0 44
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: LD_INT 2
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: LD_INT 3
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: LD_INT 2
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: LIST
39387: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39388: LD_ADDR_VAR 0 45
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: LD_INT 0
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 3
39417: NEG
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
39432: LD_ADDR_VAR 0 46
39436: PUSH
39437: LD_INT 2
39439: NEG
39440: PUSH
39441: LD_INT 2
39443: NEG
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: LD_INT 3
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 3
39463: NEG
39464: PUSH
39465: LD_INT 2
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: LIST
39477: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
39478: LD_ADDR_VAR 0 47
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: LD_INT 3
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: NEG
39498: PUSH
39499: LD_INT 3
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
39511: LD_ADDR_VAR 0 48
39515: PUSH
39516: LD_INT 1
39518: PUSH
39519: LD_INT 2
39521: NEG
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 2
39529: PUSH
39530: LD_INT 1
39532: NEG
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
39542: LD_ADDR_VAR 0 49
39546: PUSH
39547: LD_INT 3
39549: PUSH
39550: LD_INT 1
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 3
39559: PUSH
39560: LD_INT 2
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39571: LD_ADDR_VAR 0 50
39575: PUSH
39576: LD_INT 2
39578: PUSH
39579: LD_INT 3
39581: PUSH
39582: EMPTY
39583: LIST
39584: LIST
39585: PUSH
39586: LD_INT 1
39588: PUSH
39589: LD_INT 3
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39600: LD_ADDR_VAR 0 51
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 2
39611: PUSH
39612: EMPTY
39613: LIST
39614: LIST
39615: PUSH
39616: LD_INT 2
39618: NEG
39619: PUSH
39620: LD_INT 1
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39631: LD_ADDR_VAR 0 52
39635: PUSH
39636: LD_INT 3
39638: NEG
39639: PUSH
39640: LD_INT 1
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: LD_INT 3
39650: NEG
39651: PUSH
39652: LD_INT 2
39654: NEG
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39664: LD_ADDR_VAR 0 53
39668: PUSH
39669: LD_INT 1
39671: NEG
39672: PUSH
39673: LD_INT 3
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: LD_INT 3
39686: NEG
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: LD_INT 2
39697: NEG
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: LIST
39707: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39708: LD_ADDR_VAR 0 54
39712: PUSH
39713: LD_INT 2
39715: PUSH
39716: LD_INT 1
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 3
39726: PUSH
39727: LD_INT 0
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PUSH
39734: LD_INT 3
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: LIST
39748: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39749: LD_ADDR_VAR 0 55
39753: PUSH
39754: LD_INT 3
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 3
39766: PUSH
39767: LD_INT 3
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: LD_INT 3
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: LIST
39788: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39789: LD_ADDR_VAR 0 56
39793: PUSH
39794: LD_INT 1
39796: PUSH
39797: LD_INT 3
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: LD_INT 3
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 1
39816: NEG
39817: PUSH
39818: LD_INT 2
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: LIST
39829: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39830: LD_ADDR_VAR 0 57
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: LD_INT 1
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 3
39848: NEG
39849: PUSH
39850: LD_INT 0
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: NEG
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: LIST
39873: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39874: LD_ADDR_VAR 0 58
39878: PUSH
39879: LD_INT 2
39881: NEG
39882: PUSH
39883: LD_INT 3
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 3
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 3
39905: NEG
39906: PUSH
39907: LD_INT 3
39909: NEG
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: LIST
39919: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39920: LD_ADDR_VAR 0 59
39924: PUSH
39925: LD_INT 1
39927: NEG
39928: PUSH
39929: LD_INT 2
39931: NEG
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: LD_INT 2
39942: NEG
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: LD_INT 1
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: LIST
39963: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39964: LD_ADDR_VAR 0 60
39968: PUSH
39969: LD_INT 1
39971: PUSH
39972: LD_INT 1
39974: NEG
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 2
39982: PUSH
39983: LD_INT 0
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: LD_INT 2
39992: PUSH
39993: LD_INT 1
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: LIST
40004: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40005: LD_ADDR_VAR 0 61
40009: PUSH
40010: LD_INT 2
40012: PUSH
40013: LD_INT 1
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 2
40022: PUSH
40023: LD_INT 2
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: LD_INT 2
40035: PUSH
40036: EMPTY
40037: LIST
40038: LIST
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: LIST
40044: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40045: LD_ADDR_VAR 0 62
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: LD_INT 2
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 0
40062: PUSH
40063: LD_INT 2
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 1
40072: NEG
40073: PUSH
40074: LD_INT 1
40076: PUSH
40077: EMPTY
40078: LIST
40079: LIST
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: LIST
40085: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40086: LD_ADDR_VAR 0 63
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 1
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 2
40104: NEG
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 2
40115: NEG
40116: PUSH
40117: LD_INT 1
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: LIST
40129: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40130: LD_ADDR_VAR 0 64
40134: PUSH
40135: LD_INT 1
40137: NEG
40138: PUSH
40139: LD_INT 2
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 2
40149: NEG
40150: PUSH
40151: LD_INT 1
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 2
40161: NEG
40162: PUSH
40163: LD_INT 2
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: LIST
40175: ST_TO_ADDR
// end ; 2 :
40176: GO 43442
40178: LD_INT 2
40180: DOUBLE
40181: EQUAL
40182: IFTRUE 40186
40184: GO 43441
40186: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
40187: LD_ADDR_VAR 0 29
40191: PUSH
40192: LD_INT 4
40194: PUSH
40195: LD_INT 0
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 4
40204: PUSH
40205: LD_INT 1
40207: NEG
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: PUSH
40213: LD_INT 5
40215: PUSH
40216: LD_INT 0
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 5
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 4
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 3
40255: PUSH
40256: LD_INT 1
40258: NEG
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 3
40266: PUSH
40267: LD_INT 2
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 5
40277: PUSH
40278: LD_INT 2
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 3
40287: PUSH
40288: LD_INT 3
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 3
40297: PUSH
40298: LD_INT 2
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 4
40307: PUSH
40308: LD_INT 3
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 4
40317: PUSH
40318: LD_INT 4
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 3
40327: PUSH
40328: LD_INT 4
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: LD_INT 3
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 2
40347: PUSH
40348: LD_INT 2
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 4
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 2
40367: PUSH
40368: LD_INT 4
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: LD_INT 4
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 0
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: LD_INT 4
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: PUSH
40408: LD_INT 5
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 0
40417: PUSH
40418: LD_INT 5
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: LD_INT 4
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 1
40438: NEG
40439: PUSH
40440: LD_INT 3
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 2
40449: PUSH
40450: LD_INT 5
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 2
40459: NEG
40460: PUSH
40461: LD_INT 3
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 3
40470: NEG
40471: PUSH
40472: LD_INT 0
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 3
40481: NEG
40482: PUSH
40483: LD_INT 1
40485: NEG
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 2
40493: NEG
40494: PUSH
40495: LD_INT 0
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 2
40504: NEG
40505: PUSH
40506: LD_INT 1
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 3
40515: NEG
40516: PUSH
40517: LD_INT 1
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: LD_INT 4
40526: NEG
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 4
40537: NEG
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 4
40549: NEG
40550: PUSH
40551: LD_INT 2
40553: NEG
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 2
40561: NEG
40562: PUSH
40563: LD_INT 2
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 4
40572: NEG
40573: PUSH
40574: LD_INT 4
40576: NEG
40577: PUSH
40578: EMPTY
40579: LIST
40580: LIST
40581: PUSH
40582: LD_INT 4
40584: NEG
40585: PUSH
40586: LD_INT 5
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 3
40596: NEG
40597: PUSH
40598: LD_INT 4
40600: NEG
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 3
40608: NEG
40609: PUSH
40610: LD_INT 3
40612: NEG
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: LD_INT 4
40620: NEG
40621: PUSH
40622: LD_INT 3
40624: NEG
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 5
40632: NEG
40633: PUSH
40634: LD_INT 4
40636: NEG
40637: PUSH
40638: EMPTY
40639: LIST
40640: LIST
40641: PUSH
40642: LD_INT 5
40644: NEG
40645: PUSH
40646: LD_INT 5
40648: NEG
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 3
40656: NEG
40657: PUSH
40658: LD_INT 5
40660: NEG
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 5
40668: NEG
40669: PUSH
40670: LD_INT 3
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: LIST
40701: LIST
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: LIST
40707: LIST
40708: LIST
40709: LIST
40710: LIST
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40725: LD_ADDR_VAR 0 30
40729: PUSH
40730: LD_INT 4
40732: PUSH
40733: LD_INT 4
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: PUSH
40740: LD_INT 4
40742: PUSH
40743: LD_INT 3
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 5
40752: PUSH
40753: LD_INT 4
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 5
40762: PUSH
40763: LD_INT 5
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 4
40772: PUSH
40773: LD_INT 5
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: LD_INT 3
40782: PUSH
40783: LD_INT 4
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 5
40802: PUSH
40803: LD_INT 3
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 3
40812: PUSH
40813: LD_INT 5
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: LD_INT 3
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 0
40832: PUSH
40833: LD_INT 2
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 1
40842: PUSH
40843: LD_INT 3
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 1
40852: PUSH
40853: LD_INT 4
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_INT 4
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: LD_INT 3
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: LD_INT 2
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 2
40894: PUSH
40895: LD_INT 4
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 2
40904: NEG
40905: PUSH
40906: LD_INT 2
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 4
40915: NEG
40916: PUSH
40917: LD_INT 0
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 4
40926: NEG
40927: PUSH
40928: LD_INT 1
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 3
40949: NEG
40950: PUSH
40951: LD_INT 1
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 4
40960: NEG
40961: PUSH
40962: LD_INT 1
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 5
40971: NEG
40972: PUSH
40973: LD_INT 0
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 5
40982: NEG
40983: PUSH
40984: LD_INT 1
40986: NEG
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 5
40994: NEG
40995: PUSH
40996: LD_INT 2
40998: NEG
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 3
41006: NEG
41007: PUSH
41008: LD_INT 2
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 3
41017: NEG
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 3
41029: NEG
41030: PUSH
41031: LD_INT 4
41033: NEG
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: LD_INT 2
41041: NEG
41042: PUSH
41043: LD_INT 3
41045: NEG
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: LD_INT 2
41053: NEG
41054: PUSH
41055: LD_INT 2
41057: NEG
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 3
41065: NEG
41066: PUSH
41067: LD_INT 2
41069: NEG
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 4
41077: NEG
41078: PUSH
41079: LD_INT 3
41081: NEG
41082: PUSH
41083: EMPTY
41084: LIST
41085: LIST
41086: PUSH
41087: LD_INT 4
41089: NEG
41090: PUSH
41091: LD_INT 4
41093: NEG
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 2
41101: NEG
41102: PUSH
41103: LD_INT 4
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 4
41113: NEG
41114: PUSH
41115: LD_INT 2
41117: NEG
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 0
41125: PUSH
41126: LD_INT 4
41128: NEG
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 0
41136: PUSH
41137: LD_INT 5
41139: NEG
41140: PUSH
41141: EMPTY
41142: LIST
41143: LIST
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: LD_INT 4
41150: NEG
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 1
41158: PUSH
41159: LD_INT 3
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: LD_INT 3
41172: NEG
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: LD_INT 1
41180: NEG
41181: PUSH
41182: LD_INT 4
41184: NEG
41185: PUSH
41186: EMPTY
41187: LIST
41188: LIST
41189: PUSH
41190: LD_INT 1
41192: NEG
41193: PUSH
41194: LD_INT 5
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 2
41204: PUSH
41205: LD_INT 3
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 2
41215: NEG
41216: PUSH
41217: LD_INT 5
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: EMPTY
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: LIST
41250: LIST
41251: LIST
41252: LIST
41253: LIST
41254: LIST
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: LIST
41270: LIST
41271: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
41272: LD_ADDR_VAR 0 31
41276: PUSH
41277: LD_INT 0
41279: PUSH
41280: LD_INT 4
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 0
41289: PUSH
41290: LD_INT 3
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: LD_INT 4
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: LD_INT 5
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 0
41319: PUSH
41320: LD_INT 5
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 1
41329: NEG
41330: PUSH
41331: LD_INT 4
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: LD_INT 1
41340: NEG
41341: PUSH
41342: LD_INT 3
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 2
41351: PUSH
41352: LD_INT 5
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 2
41361: NEG
41362: PUSH
41363: LD_INT 3
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 3
41372: NEG
41373: PUSH
41374: LD_INT 0
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 3
41383: NEG
41384: PUSH
41385: LD_INT 1
41387: NEG
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 2
41395: NEG
41396: PUSH
41397: LD_INT 0
41399: PUSH
41400: EMPTY
41401: LIST
41402: LIST
41403: PUSH
41404: LD_INT 2
41406: NEG
41407: PUSH
41408: LD_INT 1
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 3
41417: NEG
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 4
41428: NEG
41429: PUSH
41430: LD_INT 0
41432: PUSH
41433: EMPTY
41434: LIST
41435: LIST
41436: PUSH
41437: LD_INT 4
41439: NEG
41440: PUSH
41441: LD_INT 1
41443: NEG
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: NEG
41452: PUSH
41453: LD_INT 2
41455: NEG
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 2
41463: NEG
41464: PUSH
41465: LD_INT 2
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: LD_INT 4
41474: NEG
41475: PUSH
41476: LD_INT 4
41478: NEG
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 4
41486: NEG
41487: PUSH
41488: LD_INT 5
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 3
41498: NEG
41499: PUSH
41500: LD_INT 4
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 3
41510: NEG
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 4
41522: NEG
41523: PUSH
41524: LD_INT 3
41526: NEG
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 5
41534: NEG
41535: PUSH
41536: LD_INT 4
41538: NEG
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 5
41546: NEG
41547: PUSH
41548: LD_INT 5
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 3
41558: NEG
41559: PUSH
41560: LD_INT 5
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 5
41570: NEG
41571: PUSH
41572: LD_INT 3
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 3
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 0
41593: PUSH
41594: LD_INT 4
41596: NEG
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 1
41604: PUSH
41605: LD_INT 3
41607: NEG
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 1
41615: PUSH
41616: LD_INT 2
41618: NEG
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 0
41626: PUSH
41627: LD_INT 2
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 1
41637: NEG
41638: PUSH
41639: LD_INT 3
41641: NEG
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: PUSH
41647: LD_INT 1
41649: NEG
41650: PUSH
41651: LD_INT 4
41653: NEG
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 2
41661: PUSH
41662: LD_INT 2
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 2
41672: NEG
41673: PUSH
41674: LD_INT 4
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 4
41684: PUSH
41685: LD_INT 0
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 4
41694: PUSH
41695: LD_INT 1
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 5
41705: PUSH
41706: LD_INT 0
41708: PUSH
41709: EMPTY
41710: LIST
41711: LIST
41712: PUSH
41713: LD_INT 5
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 4
41725: PUSH
41726: LD_INT 1
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 3
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 3
41745: PUSH
41746: LD_INT 1
41748: NEG
41749: PUSH
41750: EMPTY
41751: LIST
41752: LIST
41753: PUSH
41754: LD_INT 3
41756: PUSH
41757: LD_INT 2
41759: NEG
41760: PUSH
41761: EMPTY
41762: LIST
41763: LIST
41764: PUSH
41765: LD_INT 5
41767: PUSH
41768: LD_INT 2
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: EMPTY
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: LIST
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: LIST
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: LIST
41813: LIST
41814: LIST
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41822: LD_ADDR_VAR 0 32
41826: PUSH
41827: LD_INT 4
41829: NEG
41830: PUSH
41831: LD_INT 0
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 4
41840: NEG
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 3
41852: NEG
41853: PUSH
41854: LD_INT 0
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 3
41863: NEG
41864: PUSH
41865: LD_INT 1
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 4
41874: NEG
41875: PUSH
41876: LD_INT 1
41878: PUSH
41879: EMPTY
41880: LIST
41881: LIST
41882: PUSH
41883: LD_INT 5
41885: NEG
41886: PUSH
41887: LD_INT 0
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 5
41896: NEG
41897: PUSH
41898: LD_INT 1
41900: NEG
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 5
41908: NEG
41909: PUSH
41910: LD_INT 2
41912: NEG
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 3
41920: NEG
41921: PUSH
41922: LD_INT 2
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 3
41931: NEG
41932: PUSH
41933: LD_INT 3
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 3
41943: NEG
41944: PUSH
41945: LD_INT 4
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 2
41955: NEG
41956: PUSH
41957: LD_INT 3
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 2
41967: NEG
41968: PUSH
41969: LD_INT 2
41971: NEG
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 3
41979: NEG
41980: PUSH
41981: LD_INT 2
41983: NEG
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 4
41991: NEG
41992: PUSH
41993: LD_INT 3
41995: NEG
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 4
42003: NEG
42004: PUSH
42005: LD_INT 4
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 2
42015: NEG
42016: PUSH
42017: LD_INT 4
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 4
42027: NEG
42028: PUSH
42029: LD_INT 2
42031: NEG
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 0
42039: PUSH
42040: LD_INT 4
42042: NEG
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 0
42050: PUSH
42051: LD_INT 5
42053: NEG
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: PUSH
42062: LD_INT 4
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: PUSH
42073: LD_INT 3
42075: NEG
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 0
42083: PUSH
42084: LD_INT 3
42086: NEG
42087: PUSH
42088: EMPTY
42089: LIST
42090: LIST
42091: PUSH
42092: LD_INT 1
42094: NEG
42095: PUSH
42096: LD_INT 4
42098: NEG
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: NEG
42107: PUSH
42108: LD_INT 5
42110: NEG
42111: PUSH
42112: EMPTY
42113: LIST
42114: LIST
42115: PUSH
42116: LD_INT 2
42118: PUSH
42119: LD_INT 3
42121: NEG
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 2
42129: NEG
42130: PUSH
42131: LD_INT 5
42133: NEG
42134: PUSH
42135: EMPTY
42136: LIST
42137: LIST
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 0
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 3
42151: PUSH
42152: LD_INT 1
42154: NEG
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 4
42162: PUSH
42163: LD_INT 0
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 4
42172: PUSH
42173: LD_INT 1
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: PUSH
42180: LD_INT 3
42182: PUSH
42183: LD_INT 1
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 2
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 2
42202: PUSH
42203: LD_INT 1
42205: NEG
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 2
42213: PUSH
42214: LD_INT 2
42216: NEG
42217: PUSH
42218: EMPTY
42219: LIST
42220: LIST
42221: PUSH
42222: LD_INT 4
42224: PUSH
42225: LD_INT 2
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 4
42234: PUSH
42235: LD_INT 4
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: LD_INT 4
42244: PUSH
42245: LD_INT 3
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 5
42254: PUSH
42255: LD_INT 4
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 5
42264: PUSH
42265: LD_INT 5
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 4
42274: PUSH
42275: LD_INT 5
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 3
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: LD_INT 3
42294: PUSH
42295: LD_INT 3
42297: PUSH
42298: EMPTY
42299: LIST
42300: LIST
42301: PUSH
42302: LD_INT 5
42304: PUSH
42305: LD_INT 3
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: LD_INT 3
42314: PUSH
42315: LD_INT 5
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: LIST
42335: LIST
42336: LIST
42337: LIST
42338: LIST
42339: LIST
42340: LIST
42341: LIST
42342: LIST
42343: LIST
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: LIST
42366: LIST
42367: LIST
42368: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
42369: LD_ADDR_VAR 0 33
42373: PUSH
42374: LD_INT 4
42376: NEG
42377: PUSH
42378: LD_INT 4
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: LD_INT 5
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: LD_INT 4
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 3
42412: NEG
42413: PUSH
42414: LD_INT 3
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 4
42424: NEG
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 5
42436: NEG
42437: PUSH
42438: LD_INT 4
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 5
42448: NEG
42449: PUSH
42450: LD_INT 5
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 3
42460: NEG
42461: PUSH
42462: LD_INT 5
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 5
42472: NEG
42473: PUSH
42474: LD_INT 3
42476: NEG
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: LD_INT 3
42487: NEG
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 0
42495: PUSH
42496: LD_INT 4
42498: NEG
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: LD_INT 3
42509: NEG
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: PUSH
42518: LD_INT 2
42520: NEG
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 0
42528: PUSH
42529: LD_INT 2
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: LD_INT 1
42539: NEG
42540: PUSH
42541: LD_INT 3
42543: NEG
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 4
42555: NEG
42556: PUSH
42557: EMPTY
42558: LIST
42559: LIST
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: LD_INT 2
42566: NEG
42567: PUSH
42568: EMPTY
42569: LIST
42570: LIST
42571: PUSH
42572: LD_INT 2
42574: NEG
42575: PUSH
42576: LD_INT 4
42578: NEG
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 4
42586: PUSH
42587: LD_INT 0
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 4
42596: PUSH
42597: LD_INT 1
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 5
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 5
42617: PUSH
42618: LD_INT 1
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PUSH
42625: LD_INT 4
42627: PUSH
42628: LD_INT 1
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 3
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 3
42647: PUSH
42648: LD_INT 1
42650: NEG
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 3
42658: PUSH
42659: LD_INT 2
42661: NEG
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 5
42669: PUSH
42670: LD_INT 2
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 3
42679: PUSH
42680: LD_INT 3
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 3
42689: PUSH
42690: LD_INT 2
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 4
42699: PUSH
42700: LD_INT 3
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 4
42709: PUSH
42710: LD_INT 4
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 3
42719: PUSH
42720: LD_INT 4
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: LD_INT 2
42729: PUSH
42730: LD_INT 3
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: PUSH
42737: LD_INT 2
42739: PUSH
42740: LD_INT 2
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: PUSH
42747: LD_INT 4
42749: PUSH
42750: LD_INT 2
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 2
42759: PUSH
42760: LD_INT 4
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 0
42769: PUSH
42770: LD_INT 4
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 0
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: LD_INT 4
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: LD_INT 1
42799: PUSH
42800: LD_INT 5
42802: PUSH
42803: EMPTY
42804: LIST
42805: LIST
42806: PUSH
42807: LD_INT 0
42809: PUSH
42810: LD_INT 5
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 1
42819: NEG
42820: PUSH
42821: LD_INT 4
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 1
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 2
42841: PUSH
42842: LD_INT 5
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 2
42851: NEG
42852: PUSH
42853: LD_INT 3
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: LIST
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: LIST
42886: LIST
42887: LIST
42888: LIST
42889: LIST
42890: LIST
42891: LIST
42892: LIST
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: LIST
42900: LIST
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42907: LD_ADDR_VAR 0 34
42911: PUSH
42912: LD_INT 0
42914: PUSH
42915: LD_INT 4
42917: NEG
42918: PUSH
42919: EMPTY
42920: LIST
42921: LIST
42922: PUSH
42923: LD_INT 0
42925: PUSH
42926: LD_INT 5
42928: NEG
42929: PUSH
42930: EMPTY
42931: LIST
42932: LIST
42933: PUSH
42934: LD_INT 1
42936: PUSH
42937: LD_INT 4
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 1
42947: PUSH
42948: LD_INT 3
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 0
42958: PUSH
42959: LD_INT 3
42961: NEG
42962: PUSH
42963: EMPTY
42964: LIST
42965: LIST
42966: PUSH
42967: LD_INT 1
42969: NEG
42970: PUSH
42971: LD_INT 4
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 1
42981: NEG
42982: PUSH
42983: LD_INT 5
42985: NEG
42986: PUSH
42987: EMPTY
42988: LIST
42989: LIST
42990: PUSH
42991: LD_INT 2
42993: PUSH
42994: LD_INT 3
42996: NEG
42997: PUSH
42998: EMPTY
42999: LIST
43000: LIST
43001: PUSH
43002: LD_INT 2
43004: NEG
43005: PUSH
43006: LD_INT 5
43008: NEG
43009: PUSH
43010: EMPTY
43011: LIST
43012: LIST
43013: PUSH
43014: LD_INT 3
43016: PUSH
43017: LD_INT 0
43019: PUSH
43020: EMPTY
43021: LIST
43022: LIST
43023: PUSH
43024: LD_INT 3
43026: PUSH
43027: LD_INT 1
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 4
43037: PUSH
43038: LD_INT 0
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 4
43047: PUSH
43048: LD_INT 1
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 3
43057: PUSH
43058: LD_INT 1
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: LD_INT 2
43067: PUSH
43068: LD_INT 0
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 2
43077: PUSH
43078: LD_INT 1
43080: NEG
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: PUSH
43086: LD_INT 2
43088: PUSH
43089: LD_INT 2
43091: NEG
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 4
43099: PUSH
43100: LD_INT 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 4
43109: PUSH
43110: LD_INT 4
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 4
43119: PUSH
43120: LD_INT 3
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 5
43129: PUSH
43130: LD_INT 4
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 5
43139: PUSH
43140: LD_INT 5
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 4
43149: PUSH
43150: LD_INT 5
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 3
43159: PUSH
43160: LD_INT 4
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 3
43169: PUSH
43170: LD_INT 3
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 5
43179: PUSH
43180: LD_INT 3
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PUSH
43187: LD_INT 3
43189: PUSH
43190: LD_INT 5
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 3
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 0
43209: PUSH
43210: LD_INT 2
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 1
43219: PUSH
43220: LD_INT 3
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 1
43229: PUSH
43230: LD_INT 4
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 0
43239: PUSH
43240: LD_INT 4
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 1
43249: NEG
43250: PUSH
43251: LD_INT 3
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 1
43260: NEG
43261: PUSH
43262: LD_INT 2
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: LD_INT 2
43271: PUSH
43272: LD_INT 4
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 2
43281: NEG
43282: PUSH
43283: LD_INT 2
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 4
43292: NEG
43293: PUSH
43294: LD_INT 0
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 4
43303: NEG
43304: PUSH
43305: LD_INT 1
43307: NEG
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 3
43315: NEG
43316: PUSH
43317: LD_INT 0
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 3
43326: NEG
43327: PUSH
43328: LD_INT 1
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: PUSH
43335: LD_INT 4
43337: NEG
43338: PUSH
43339: LD_INT 1
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 5
43348: NEG
43349: PUSH
43350: LD_INT 0
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 5
43359: NEG
43360: PUSH
43361: LD_INT 1
43363: NEG
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PUSH
43369: LD_INT 5
43371: NEG
43372: PUSH
43373: LD_INT 2
43375: NEG
43376: PUSH
43377: EMPTY
43378: LIST
43379: LIST
43380: PUSH
43381: LD_INT 3
43383: NEG
43384: PUSH
43385: LD_INT 2
43387: PUSH
43388: EMPTY
43389: LIST
43390: LIST
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: LIST
43410: LIST
43411: LIST
43412: LIST
43413: LIST
43414: LIST
43415: LIST
43416: LIST
43417: LIST
43418: LIST
43419: LIST
43420: LIST
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: LIST
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: ST_TO_ADDR
// end ; end ;
43439: GO 43442
43441: POP
// case btype of b_depot , b_warehouse :
43442: LD_VAR 0 1
43446: PUSH
43447: LD_INT 0
43449: DOUBLE
43450: EQUAL
43451: IFTRUE 43461
43453: LD_INT 1
43455: DOUBLE
43456: EQUAL
43457: IFTRUE 43461
43459: GO 43662
43461: POP
// case nation of nation_american :
43462: LD_VAR 0 5
43466: PUSH
43467: LD_INT 1
43469: DOUBLE
43470: EQUAL
43471: IFTRUE 43475
43473: GO 43531
43475: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
43476: LD_ADDR_VAR 0 9
43480: PUSH
43481: LD_VAR 0 11
43485: PUSH
43486: LD_VAR 0 12
43490: PUSH
43491: LD_VAR 0 13
43495: PUSH
43496: LD_VAR 0 14
43500: PUSH
43501: LD_VAR 0 15
43505: PUSH
43506: LD_VAR 0 16
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: PUSH
43519: LD_VAR 0 4
43523: PUSH
43524: LD_INT 1
43526: PLUS
43527: ARRAY
43528: ST_TO_ADDR
43529: GO 43660
43531: LD_INT 2
43533: DOUBLE
43534: EQUAL
43535: IFTRUE 43539
43537: GO 43595
43539: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
43540: LD_ADDR_VAR 0 9
43544: PUSH
43545: LD_VAR 0 17
43549: PUSH
43550: LD_VAR 0 18
43554: PUSH
43555: LD_VAR 0 19
43559: PUSH
43560: LD_VAR 0 20
43564: PUSH
43565: LD_VAR 0 21
43569: PUSH
43570: LD_VAR 0 22
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: PUSH
43583: LD_VAR 0 4
43587: PUSH
43588: LD_INT 1
43590: PLUS
43591: ARRAY
43592: ST_TO_ADDR
43593: GO 43660
43595: LD_INT 3
43597: DOUBLE
43598: EQUAL
43599: IFTRUE 43603
43601: GO 43659
43603: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43604: LD_ADDR_VAR 0 9
43608: PUSH
43609: LD_VAR 0 23
43613: PUSH
43614: LD_VAR 0 24
43618: PUSH
43619: LD_VAR 0 25
43623: PUSH
43624: LD_VAR 0 26
43628: PUSH
43629: LD_VAR 0 27
43633: PUSH
43634: LD_VAR 0 28
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: LIST
43643: LIST
43644: LIST
43645: LIST
43646: PUSH
43647: LD_VAR 0 4
43651: PUSH
43652: LD_INT 1
43654: PLUS
43655: ARRAY
43656: ST_TO_ADDR
43657: GO 43660
43659: POP
43660: GO 44215
43662: LD_INT 2
43664: DOUBLE
43665: EQUAL
43666: IFTRUE 43676
43668: LD_INT 3
43670: DOUBLE
43671: EQUAL
43672: IFTRUE 43676
43674: GO 43732
43676: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43677: LD_ADDR_VAR 0 9
43681: PUSH
43682: LD_VAR 0 29
43686: PUSH
43687: LD_VAR 0 30
43691: PUSH
43692: LD_VAR 0 31
43696: PUSH
43697: LD_VAR 0 32
43701: PUSH
43702: LD_VAR 0 33
43706: PUSH
43707: LD_VAR 0 34
43711: PUSH
43712: EMPTY
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: PUSH
43720: LD_VAR 0 4
43724: PUSH
43725: LD_INT 1
43727: PLUS
43728: ARRAY
43729: ST_TO_ADDR
43730: GO 44215
43732: LD_INT 16
43734: DOUBLE
43735: EQUAL
43736: IFTRUE 43794
43738: LD_INT 17
43740: DOUBLE
43741: EQUAL
43742: IFTRUE 43794
43744: LD_INT 18
43746: DOUBLE
43747: EQUAL
43748: IFTRUE 43794
43750: LD_INT 19
43752: DOUBLE
43753: EQUAL
43754: IFTRUE 43794
43756: LD_INT 22
43758: DOUBLE
43759: EQUAL
43760: IFTRUE 43794
43762: LD_INT 20
43764: DOUBLE
43765: EQUAL
43766: IFTRUE 43794
43768: LD_INT 21
43770: DOUBLE
43771: EQUAL
43772: IFTRUE 43794
43774: LD_INT 23
43776: DOUBLE
43777: EQUAL
43778: IFTRUE 43794
43780: LD_INT 24
43782: DOUBLE
43783: EQUAL
43784: IFTRUE 43794
43786: LD_INT 25
43788: DOUBLE
43789: EQUAL
43790: IFTRUE 43794
43792: GO 43850
43794: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43795: LD_ADDR_VAR 0 9
43799: PUSH
43800: LD_VAR 0 35
43804: PUSH
43805: LD_VAR 0 36
43809: PUSH
43810: LD_VAR 0 37
43814: PUSH
43815: LD_VAR 0 38
43819: PUSH
43820: LD_VAR 0 39
43824: PUSH
43825: LD_VAR 0 40
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: PUSH
43838: LD_VAR 0 4
43842: PUSH
43843: LD_INT 1
43845: PLUS
43846: ARRAY
43847: ST_TO_ADDR
43848: GO 44215
43850: LD_INT 6
43852: DOUBLE
43853: EQUAL
43854: IFTRUE 43906
43856: LD_INT 7
43858: DOUBLE
43859: EQUAL
43860: IFTRUE 43906
43862: LD_INT 8
43864: DOUBLE
43865: EQUAL
43866: IFTRUE 43906
43868: LD_INT 13
43870: DOUBLE
43871: EQUAL
43872: IFTRUE 43906
43874: LD_INT 12
43876: DOUBLE
43877: EQUAL
43878: IFTRUE 43906
43880: LD_INT 15
43882: DOUBLE
43883: EQUAL
43884: IFTRUE 43906
43886: LD_INT 11
43888: DOUBLE
43889: EQUAL
43890: IFTRUE 43906
43892: LD_INT 14
43894: DOUBLE
43895: EQUAL
43896: IFTRUE 43906
43898: LD_INT 10
43900: DOUBLE
43901: EQUAL
43902: IFTRUE 43906
43904: GO 43962
43906: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43907: LD_ADDR_VAR 0 9
43911: PUSH
43912: LD_VAR 0 41
43916: PUSH
43917: LD_VAR 0 42
43921: PUSH
43922: LD_VAR 0 43
43926: PUSH
43927: LD_VAR 0 44
43931: PUSH
43932: LD_VAR 0 45
43936: PUSH
43937: LD_VAR 0 46
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: PUSH
43950: LD_VAR 0 4
43954: PUSH
43955: LD_INT 1
43957: PLUS
43958: ARRAY
43959: ST_TO_ADDR
43960: GO 44215
43962: LD_INT 36
43964: DOUBLE
43965: EQUAL
43966: IFTRUE 43970
43968: GO 44026
43970: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43971: LD_ADDR_VAR 0 9
43975: PUSH
43976: LD_VAR 0 47
43980: PUSH
43981: LD_VAR 0 48
43985: PUSH
43986: LD_VAR 0 49
43990: PUSH
43991: LD_VAR 0 50
43995: PUSH
43996: LD_VAR 0 51
44000: PUSH
44001: LD_VAR 0 52
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: PUSH
44014: LD_VAR 0 4
44018: PUSH
44019: LD_INT 1
44021: PLUS
44022: ARRAY
44023: ST_TO_ADDR
44024: GO 44215
44026: LD_INT 4
44028: DOUBLE
44029: EQUAL
44030: IFTRUE 44052
44032: LD_INT 5
44034: DOUBLE
44035: EQUAL
44036: IFTRUE 44052
44038: LD_INT 34
44040: DOUBLE
44041: EQUAL
44042: IFTRUE 44052
44044: LD_INT 37
44046: DOUBLE
44047: EQUAL
44048: IFTRUE 44052
44050: GO 44108
44052: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
44053: LD_ADDR_VAR 0 9
44057: PUSH
44058: LD_VAR 0 53
44062: PUSH
44063: LD_VAR 0 54
44067: PUSH
44068: LD_VAR 0 55
44072: PUSH
44073: LD_VAR 0 56
44077: PUSH
44078: LD_VAR 0 57
44082: PUSH
44083: LD_VAR 0 58
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: PUSH
44096: LD_VAR 0 4
44100: PUSH
44101: LD_INT 1
44103: PLUS
44104: ARRAY
44105: ST_TO_ADDR
44106: GO 44215
44108: LD_INT 31
44110: DOUBLE
44111: EQUAL
44112: IFTRUE 44158
44114: LD_INT 32
44116: DOUBLE
44117: EQUAL
44118: IFTRUE 44158
44120: LD_INT 33
44122: DOUBLE
44123: EQUAL
44124: IFTRUE 44158
44126: LD_INT 27
44128: DOUBLE
44129: EQUAL
44130: IFTRUE 44158
44132: LD_INT 26
44134: DOUBLE
44135: EQUAL
44136: IFTRUE 44158
44138: LD_INT 28
44140: DOUBLE
44141: EQUAL
44142: IFTRUE 44158
44144: LD_INT 29
44146: DOUBLE
44147: EQUAL
44148: IFTRUE 44158
44150: LD_INT 30
44152: DOUBLE
44153: EQUAL
44154: IFTRUE 44158
44156: GO 44214
44158: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
44159: LD_ADDR_VAR 0 9
44163: PUSH
44164: LD_VAR 0 59
44168: PUSH
44169: LD_VAR 0 60
44173: PUSH
44174: LD_VAR 0 61
44178: PUSH
44179: LD_VAR 0 62
44183: PUSH
44184: LD_VAR 0 63
44188: PUSH
44189: LD_VAR 0 64
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: PUSH
44202: LD_VAR 0 4
44206: PUSH
44207: LD_INT 1
44209: PLUS
44210: ARRAY
44211: ST_TO_ADDR
44212: GO 44215
44214: POP
// temp_list2 = [ ] ;
44215: LD_ADDR_VAR 0 10
44219: PUSH
44220: EMPTY
44221: ST_TO_ADDR
// for i in temp_list do
44222: LD_ADDR_VAR 0 8
44226: PUSH
44227: LD_VAR 0 9
44231: PUSH
44232: FOR_IN
44233: IFFALSE 44285
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
44235: LD_ADDR_VAR 0 10
44239: PUSH
44240: LD_VAR 0 10
44244: PUSH
44245: LD_VAR 0 8
44249: PUSH
44250: LD_INT 1
44252: ARRAY
44253: PUSH
44254: LD_VAR 0 2
44258: PLUS
44259: PUSH
44260: LD_VAR 0 8
44264: PUSH
44265: LD_INT 2
44267: ARRAY
44268: PUSH
44269: LD_VAR 0 3
44273: PLUS
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: EMPTY
44280: LIST
44281: ADD
44282: ST_TO_ADDR
44283: GO 44232
44285: POP
44286: POP
// result = temp_list2 ;
44287: LD_ADDR_VAR 0 7
44291: PUSH
44292: LD_VAR 0 10
44296: ST_TO_ADDR
// end ;
44297: LD_VAR 0 7
44301: RET
// export function EnemyInRange ( unit , dist ) ; begin
44302: LD_INT 0
44304: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
44305: LD_ADDR_VAR 0 3
44309: PUSH
44310: LD_VAR 0 1
44314: PPUSH
44315: CALL_OW 255
44319: PPUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: CALL_OW 250
44329: PPUSH
44330: LD_VAR 0 1
44334: PPUSH
44335: CALL_OW 251
44339: PPUSH
44340: LD_VAR 0 2
44344: PPUSH
44345: CALL 17559 0 4
44349: PUSH
44350: LD_INT 4
44352: ARRAY
44353: ST_TO_ADDR
// end ;
44354: LD_VAR 0 3
44358: RET
// export function PlayerSeeMe ( unit ) ; begin
44359: LD_INT 0
44361: PPUSH
// result := See ( your_side , unit ) ;
44362: LD_ADDR_VAR 0 2
44366: PUSH
44367: LD_OWVAR 2
44371: PPUSH
44372: LD_VAR 0 1
44376: PPUSH
44377: CALL_OW 292
44381: ST_TO_ADDR
// end ;
44382: LD_VAR 0 2
44386: RET
// export function ReverseDir ( unit ) ; begin
44387: LD_INT 0
44389: PPUSH
// if not unit then
44390: LD_VAR 0 1
44394: NOT
44395: IFFALSE 44399
// exit ;
44397: GO 44422
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
44399: LD_ADDR_VAR 0 2
44403: PUSH
44404: LD_VAR 0 1
44408: PPUSH
44409: CALL_OW 254
44413: PUSH
44414: LD_INT 3
44416: PLUS
44417: PUSH
44418: LD_INT 6
44420: MOD
44421: ST_TO_ADDR
// end ;
44422: LD_VAR 0 2
44426: RET
// export function ReverseArray ( array ) ; var i ; begin
44427: LD_INT 0
44429: PPUSH
44430: PPUSH
// if not array then
44431: LD_VAR 0 1
44435: NOT
44436: IFFALSE 44440
// exit ;
44438: GO 44495
// result := [ ] ;
44440: LD_ADDR_VAR 0 2
44444: PUSH
44445: EMPTY
44446: ST_TO_ADDR
// for i := array downto 1 do
44447: LD_ADDR_VAR 0 3
44451: PUSH
44452: DOUBLE
44453: LD_VAR 0 1
44457: INC
44458: ST_TO_ADDR
44459: LD_INT 1
44461: PUSH
44462: FOR_DOWNTO
44463: IFFALSE 44493
// result := Join ( result , array [ i ] ) ;
44465: LD_ADDR_VAR 0 2
44469: PUSH
44470: LD_VAR 0 2
44474: PPUSH
44475: LD_VAR 0 1
44479: PUSH
44480: LD_VAR 0 3
44484: ARRAY
44485: PPUSH
44486: CALL 49347 0 2
44490: ST_TO_ADDR
44491: GO 44462
44493: POP
44494: POP
// end ;
44495: LD_VAR 0 2
44499: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
44500: LD_INT 0
44502: PPUSH
44503: PPUSH
44504: PPUSH
44505: PPUSH
44506: PPUSH
44507: PPUSH
// if not unit or not hexes then
44508: LD_VAR 0 1
44512: NOT
44513: IFTRUE 44522
44515: PUSH
44516: LD_VAR 0 2
44520: NOT
44521: OR
44522: IFFALSE 44526
// exit ;
44524: GO 44649
// dist := 9999 ;
44526: LD_ADDR_VAR 0 5
44530: PUSH
44531: LD_INT 9999
44533: ST_TO_ADDR
// for i = 1 to hexes do
44534: LD_ADDR_VAR 0 4
44538: PUSH
44539: DOUBLE
44540: LD_INT 1
44542: DEC
44543: ST_TO_ADDR
44544: LD_VAR 0 2
44548: PUSH
44549: FOR_TO
44550: IFFALSE 44637
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44552: LD_ADDR_VAR 0 6
44556: PUSH
44557: LD_VAR 0 1
44561: PPUSH
44562: LD_VAR 0 2
44566: PUSH
44567: LD_VAR 0 4
44571: ARRAY
44572: PUSH
44573: LD_INT 1
44575: ARRAY
44576: PPUSH
44577: LD_VAR 0 2
44581: PUSH
44582: LD_VAR 0 4
44586: ARRAY
44587: PUSH
44588: LD_INT 2
44590: ARRAY
44591: PPUSH
44592: CALL_OW 297
44596: ST_TO_ADDR
// if tdist < dist then
44597: LD_VAR 0 6
44601: PUSH
44602: LD_VAR 0 5
44606: LESS
44607: IFFALSE 44635
// begin hex := hexes [ i ] ;
44609: LD_ADDR_VAR 0 8
44613: PUSH
44614: LD_VAR 0 2
44618: PUSH
44619: LD_VAR 0 4
44623: ARRAY
44624: ST_TO_ADDR
// dist := tdist ;
44625: LD_ADDR_VAR 0 5
44629: PUSH
44630: LD_VAR 0 6
44634: ST_TO_ADDR
// end ; end ;
44635: GO 44549
44637: POP
44638: POP
// result := hex ;
44639: LD_ADDR_VAR 0 3
44643: PUSH
44644: LD_VAR 0 8
44648: ST_TO_ADDR
// end ;
44649: LD_VAR 0 3
44653: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44654: LD_INT 0
44656: PPUSH
44657: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44658: LD_VAR 0 1
44662: NOT
44663: IFTRUE 44702
44665: PUSH
44666: LD_VAR 0 1
44670: PUSH
44671: LD_INT 21
44673: PUSH
44674: LD_INT 2
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 23
44683: PUSH
44684: LD_INT 2
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PPUSH
44695: CALL_OW 69
44699: IN
44700: NOT
44701: OR
44702: IFFALSE 44706
// exit ;
44704: GO 44753
// for i = 1 to 3 do
44706: LD_ADDR_VAR 0 3
44710: PUSH
44711: DOUBLE
44712: LD_INT 1
44714: DEC
44715: ST_TO_ADDR
44716: LD_INT 3
44718: PUSH
44719: FOR_TO
44720: IFFALSE 44751
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44722: LD_VAR 0 1
44726: PPUSH
44727: CALL_OW 250
44731: PPUSH
44732: LD_VAR 0 1
44736: PPUSH
44737: CALL_OW 251
44741: PPUSH
44742: LD_INT 1
44744: PPUSH
44745: CALL_OW 453
44749: GO 44719
44751: POP
44752: POP
// end ;
44753: LD_VAR 0 2
44757: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44758: LD_INT 0
44760: PPUSH
44761: PPUSH
44762: PPUSH
44763: PPUSH
44764: PPUSH
44765: PPUSH
// if not unit or not enemy_unit then
44766: LD_VAR 0 1
44770: NOT
44771: IFTRUE 44780
44773: PUSH
44774: LD_VAR 0 2
44778: NOT
44779: OR
44780: IFFALSE 44784
// exit ;
44782: GO 45265
// if GetLives ( i ) < 250 then
44784: LD_VAR 0 4
44788: PPUSH
44789: CALL_OW 256
44793: PUSH
44794: LD_INT 250
44796: LESS
44797: IFFALSE 44810
// begin ComAutodestruct ( i ) ;
44799: LD_VAR 0 4
44803: PPUSH
44804: CALL 44654 0 1
// exit ;
44808: GO 45265
// end ; x := GetX ( enemy_unit ) ;
44810: LD_ADDR_VAR 0 7
44814: PUSH
44815: LD_VAR 0 2
44819: PPUSH
44820: CALL_OW 250
44824: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44825: LD_ADDR_VAR 0 8
44829: PUSH
44830: LD_VAR 0 2
44834: PPUSH
44835: CALL_OW 251
44839: ST_TO_ADDR
// if not x or not y then
44840: LD_VAR 0 7
44844: NOT
44845: IFTRUE 44854
44847: PUSH
44848: LD_VAR 0 8
44852: NOT
44853: OR
44854: IFFALSE 44858
// exit ;
44856: GO 45265
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44858: LD_ADDR_VAR 0 6
44862: PUSH
44863: LD_VAR 0 7
44867: PPUSH
44868: LD_INT 0
44870: PPUSH
44871: LD_INT 4
44873: PPUSH
44874: CALL_OW 272
44878: PUSH
44879: LD_VAR 0 8
44883: PPUSH
44884: LD_INT 0
44886: PPUSH
44887: LD_INT 4
44889: PPUSH
44890: CALL_OW 273
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_VAR 0 7
44903: PPUSH
44904: LD_INT 1
44906: PPUSH
44907: LD_INT 4
44909: PPUSH
44910: CALL_OW 272
44914: PUSH
44915: LD_VAR 0 8
44919: PPUSH
44920: LD_INT 1
44922: PPUSH
44923: LD_INT 4
44925: PPUSH
44926: CALL_OW 273
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_VAR 0 7
44939: PPUSH
44940: LD_INT 2
44942: PPUSH
44943: LD_INT 4
44945: PPUSH
44946: CALL_OW 272
44950: PUSH
44951: LD_VAR 0 8
44955: PPUSH
44956: LD_INT 2
44958: PPUSH
44959: LD_INT 4
44961: PPUSH
44962: CALL_OW 273
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_VAR 0 7
44975: PPUSH
44976: LD_INT 3
44978: PPUSH
44979: LD_INT 4
44981: PPUSH
44982: CALL_OW 272
44986: PUSH
44987: LD_VAR 0 8
44991: PPUSH
44992: LD_INT 3
44994: PPUSH
44995: LD_INT 4
44997: PPUSH
44998: CALL_OW 273
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_VAR 0 7
45011: PPUSH
45012: LD_INT 4
45014: PPUSH
45015: LD_INT 4
45017: PPUSH
45018: CALL_OW 272
45022: PUSH
45023: LD_VAR 0 8
45027: PPUSH
45028: LD_INT 4
45030: PPUSH
45031: LD_INT 4
45033: PPUSH
45034: CALL_OW 273
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_VAR 0 7
45047: PPUSH
45048: LD_INT 5
45050: PPUSH
45051: LD_INT 4
45053: PPUSH
45054: CALL_OW 272
45058: PUSH
45059: LD_VAR 0 8
45063: PPUSH
45064: LD_INT 5
45066: PPUSH
45067: LD_INT 4
45069: PPUSH
45070: CALL_OW 273
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: ST_TO_ADDR
// for i = tmp downto 1 do
45087: LD_ADDR_VAR 0 4
45091: PUSH
45092: DOUBLE
45093: LD_VAR 0 6
45097: INC
45098: ST_TO_ADDR
45099: LD_INT 1
45101: PUSH
45102: FOR_DOWNTO
45103: IFFALSE 45206
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
45105: LD_VAR 0 6
45109: PUSH
45110: LD_VAR 0 4
45114: ARRAY
45115: PUSH
45116: LD_INT 1
45118: ARRAY
45119: PPUSH
45120: LD_VAR 0 6
45124: PUSH
45125: LD_VAR 0 4
45129: ARRAY
45130: PUSH
45131: LD_INT 2
45133: ARRAY
45134: PPUSH
45135: CALL_OW 488
45139: NOT
45140: IFTRUE 45182
45142: PUSH
45143: LD_VAR 0 6
45147: PUSH
45148: LD_VAR 0 4
45152: ARRAY
45153: PUSH
45154: LD_INT 1
45156: ARRAY
45157: PPUSH
45158: LD_VAR 0 6
45162: PUSH
45163: LD_VAR 0 4
45167: ARRAY
45168: PUSH
45169: LD_INT 2
45171: ARRAY
45172: PPUSH
45173: CALL_OW 428
45177: PUSH
45178: LD_INT 0
45180: NONEQUAL
45181: OR
45182: IFFALSE 45204
// tmp := Delete ( tmp , i ) ;
45184: LD_ADDR_VAR 0 6
45188: PUSH
45189: LD_VAR 0 6
45193: PPUSH
45194: LD_VAR 0 4
45198: PPUSH
45199: CALL_OW 3
45203: ST_TO_ADDR
45204: GO 45102
45206: POP
45207: POP
// j := GetClosestHex ( unit , tmp ) ;
45208: LD_ADDR_VAR 0 5
45212: PUSH
45213: LD_VAR 0 1
45217: PPUSH
45218: LD_VAR 0 6
45222: PPUSH
45223: CALL 44500 0 2
45227: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
45228: LD_VAR 0 1
45232: PPUSH
45233: LD_VAR 0 5
45237: PUSH
45238: LD_INT 1
45240: ARRAY
45241: PPUSH
45242: LD_VAR 0 5
45246: PUSH
45247: LD_INT 2
45249: ARRAY
45250: PPUSH
45251: CALL_OW 111
// result := j ;
45255: LD_ADDR_VAR 0 3
45259: PUSH
45260: LD_VAR 0 5
45264: ST_TO_ADDR
// end ;
45265: LD_VAR 0 3
45269: RET
// export function PrepareApemanSoldier ( ) ; begin
45270: LD_INT 0
45272: PPUSH
// uc_nation := 0 ;
45273: LD_ADDR_OWVAR 21
45277: PUSH
45278: LD_INT 0
45280: ST_TO_ADDR
// hc_sex := sex_male ;
45281: LD_ADDR_OWVAR 27
45285: PUSH
45286: LD_INT 1
45288: ST_TO_ADDR
// hc_name :=  ;
45289: LD_ADDR_OWVAR 26
45293: PUSH
45294: LD_STRING 
45296: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
45297: LD_ADDR_OWVAR 28
45301: PUSH
45302: LD_INT 15
45304: ST_TO_ADDR
// hc_gallery :=  ;
45305: LD_ADDR_OWVAR 33
45309: PUSH
45310: LD_STRING 
45312: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45313: LD_ADDR_OWVAR 31
45317: PUSH
45318: LD_INT 0
45320: PPUSH
45321: LD_INT 3
45323: PPUSH
45324: CALL_OW 12
45328: PUSH
45329: LD_INT 0
45331: PPUSH
45332: LD_INT 3
45334: PPUSH
45335: CALL_OW 12
45339: PUSH
45340: LD_INT 0
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
45352: LD_ADDR_OWVAR 29
45356: PUSH
45357: LD_INT 10
45359: PUSH
45360: LD_INT 12
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: ST_TO_ADDR
// end ;
45367: LD_VAR 0 1
45371: RET
// export function PrepareApemanEngineer ( ) ; begin
45372: LD_INT 0
45374: PPUSH
// uc_nation := 0 ;
45375: LD_ADDR_OWVAR 21
45379: PUSH
45380: LD_INT 0
45382: ST_TO_ADDR
// hc_sex := sex_male ;
45383: LD_ADDR_OWVAR 27
45387: PUSH
45388: LD_INT 1
45390: ST_TO_ADDR
// hc_name :=  ;
45391: LD_ADDR_OWVAR 26
45395: PUSH
45396: LD_STRING 
45398: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
45399: LD_ADDR_OWVAR 28
45403: PUSH
45404: LD_INT 16
45406: ST_TO_ADDR
// hc_gallery :=  ;
45407: LD_ADDR_OWVAR 33
45411: PUSH
45412: LD_STRING 
45414: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45415: LD_ADDR_OWVAR 31
45419: PUSH
45420: LD_INT 0
45422: PPUSH
45423: LD_INT 3
45425: PPUSH
45426: CALL_OW 12
45430: PUSH
45431: LD_INT 0
45433: PPUSH
45434: LD_INT 3
45436: PPUSH
45437: CALL_OW 12
45441: PUSH
45442: LD_INT 0
45444: PUSH
45445: LD_INT 0
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
45454: LD_ADDR_OWVAR 29
45458: PUSH
45459: LD_INT 10
45461: PUSH
45462: LD_INT 12
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: ST_TO_ADDR
// end ;
45469: LD_VAR 0 1
45473: RET
// export function PrepareApeman ( agressivity ) ; begin
45474: LD_INT 0
45476: PPUSH
// uc_side := 0 ;
45477: LD_ADDR_OWVAR 20
45481: PUSH
45482: LD_INT 0
45484: ST_TO_ADDR
// uc_nation := 0 ;
45485: LD_ADDR_OWVAR 21
45489: PUSH
45490: LD_INT 0
45492: ST_TO_ADDR
// hc_sex := sex_male ;
45493: LD_ADDR_OWVAR 27
45497: PUSH
45498: LD_INT 1
45500: ST_TO_ADDR
// hc_class := class_apeman ;
45501: LD_ADDR_OWVAR 28
45505: PUSH
45506: LD_INT 12
45508: ST_TO_ADDR
// hc_gallery :=  ;
45509: LD_ADDR_OWVAR 33
45513: PUSH
45514: LD_STRING 
45516: ST_TO_ADDR
// hc_name :=  ;
45517: LD_ADDR_OWVAR 26
45521: PUSH
45522: LD_STRING 
45524: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
45525: LD_ADDR_OWVAR 29
45529: PUSH
45530: LD_INT 10
45532: PUSH
45533: LD_INT 12
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// if agressivity = 0 then
45540: LD_VAR 0 1
45544: PUSH
45545: LD_INT 0
45547: EQUAL
45548: IFFALSE 45560
// hc_agressivity := 0 else
45550: LD_ADDR_OWVAR 35
45554: PUSH
45555: LD_INT 0
45557: ST_TO_ADDR
45558: GO 45581
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45560: LD_ADDR_OWVAR 35
45564: PUSH
45565: LD_VAR 0 1
45569: NEG
45570: PPUSH
45571: LD_VAR 0 1
45575: PPUSH
45576: CALL_OW 12
45580: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45581: LD_ADDR_OWVAR 31
45585: PUSH
45586: LD_INT 0
45588: PPUSH
45589: LD_INT 3
45591: PPUSH
45592: CALL_OW 12
45596: PUSH
45597: LD_INT 0
45599: PPUSH
45600: LD_INT 3
45602: PPUSH
45603: CALL_OW 12
45607: PUSH
45608: LD_INT 0
45610: PUSH
45611: LD_INT 0
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: ST_TO_ADDR
// end ;
45620: LD_VAR 0 2
45624: RET
// export function PrepareTiger ( agressivity ) ; begin
45625: LD_INT 0
45627: PPUSH
// uc_side := 0 ;
45628: LD_ADDR_OWVAR 20
45632: PUSH
45633: LD_INT 0
45635: ST_TO_ADDR
// uc_nation := 0 ;
45636: LD_ADDR_OWVAR 21
45640: PUSH
45641: LD_INT 0
45643: ST_TO_ADDR
// InitHc ;
45644: CALL_OW 19
// hc_class := class_tiger ;
45648: LD_ADDR_OWVAR 28
45652: PUSH
45653: LD_INT 14
45655: ST_TO_ADDR
// hc_gallery :=  ;
45656: LD_ADDR_OWVAR 33
45660: PUSH
45661: LD_STRING 
45663: ST_TO_ADDR
// hc_name :=  ;
45664: LD_ADDR_OWVAR 26
45668: PUSH
45669: LD_STRING 
45671: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45672: LD_ADDR_OWVAR 35
45676: PUSH
45677: LD_VAR 0 1
45681: NEG
45682: PPUSH
45683: LD_VAR 0 1
45687: PPUSH
45688: CALL_OW 12
45692: ST_TO_ADDR
// end ;
45693: LD_VAR 0 2
45697: RET
// export function PrepareEnchidna ( ) ; begin
45698: LD_INT 0
45700: PPUSH
// uc_side := 0 ;
45701: LD_ADDR_OWVAR 20
45705: PUSH
45706: LD_INT 0
45708: ST_TO_ADDR
// uc_nation := 0 ;
45709: LD_ADDR_OWVAR 21
45713: PUSH
45714: LD_INT 0
45716: ST_TO_ADDR
// InitHc ;
45717: CALL_OW 19
// hc_class := class_baggie ;
45721: LD_ADDR_OWVAR 28
45725: PUSH
45726: LD_INT 13
45728: ST_TO_ADDR
// hc_gallery :=  ;
45729: LD_ADDR_OWVAR 33
45733: PUSH
45734: LD_STRING 
45736: ST_TO_ADDR
// hc_name :=  ;
45737: LD_ADDR_OWVAR 26
45741: PUSH
45742: LD_STRING 
45744: ST_TO_ADDR
// end ;
45745: LD_VAR 0 1
45749: RET
// export function PrepareFrog ( ) ; begin
45750: LD_INT 0
45752: PPUSH
// uc_side := 0 ;
45753: LD_ADDR_OWVAR 20
45757: PUSH
45758: LD_INT 0
45760: ST_TO_ADDR
// uc_nation := 0 ;
45761: LD_ADDR_OWVAR 21
45765: PUSH
45766: LD_INT 0
45768: ST_TO_ADDR
// InitHc ;
45769: CALL_OW 19
// hc_class := class_frog ;
45773: LD_ADDR_OWVAR 28
45777: PUSH
45778: LD_INT 19
45780: ST_TO_ADDR
// hc_gallery :=  ;
45781: LD_ADDR_OWVAR 33
45785: PUSH
45786: LD_STRING 
45788: ST_TO_ADDR
// hc_name :=  ;
45789: LD_ADDR_OWVAR 26
45793: PUSH
45794: LD_STRING 
45796: ST_TO_ADDR
// end ;
45797: LD_VAR 0 1
45801: RET
// export function PrepareFish ( ) ; begin
45802: LD_INT 0
45804: PPUSH
// uc_side := 0 ;
45805: LD_ADDR_OWVAR 20
45809: PUSH
45810: LD_INT 0
45812: ST_TO_ADDR
// uc_nation := 0 ;
45813: LD_ADDR_OWVAR 21
45817: PUSH
45818: LD_INT 0
45820: ST_TO_ADDR
// InitHc ;
45821: CALL_OW 19
// hc_class := class_fish ;
45825: LD_ADDR_OWVAR 28
45829: PUSH
45830: LD_INT 20
45832: ST_TO_ADDR
// hc_gallery :=  ;
45833: LD_ADDR_OWVAR 33
45837: PUSH
45838: LD_STRING 
45840: ST_TO_ADDR
// hc_name :=  ;
45841: LD_ADDR_OWVAR 26
45845: PUSH
45846: LD_STRING 
45848: ST_TO_ADDR
// end ;
45849: LD_VAR 0 1
45853: RET
// export function PrepareBird ( ) ; begin
45854: LD_INT 0
45856: PPUSH
// uc_side := 0 ;
45857: LD_ADDR_OWVAR 20
45861: PUSH
45862: LD_INT 0
45864: ST_TO_ADDR
// uc_nation := 0 ;
45865: LD_ADDR_OWVAR 21
45869: PUSH
45870: LD_INT 0
45872: ST_TO_ADDR
// InitHc ;
45873: CALL_OW 19
// hc_class := class_phororhacos ;
45877: LD_ADDR_OWVAR 28
45881: PUSH
45882: LD_INT 18
45884: ST_TO_ADDR
// hc_gallery :=  ;
45885: LD_ADDR_OWVAR 33
45889: PUSH
45890: LD_STRING 
45892: ST_TO_ADDR
// hc_name :=  ;
45893: LD_ADDR_OWVAR 26
45897: PUSH
45898: LD_STRING 
45900: ST_TO_ADDR
// end ;
45901: LD_VAR 0 1
45905: RET
// export function PrepareHorse ( ) ; begin
45906: LD_INT 0
45908: PPUSH
// uc_side := 0 ;
45909: LD_ADDR_OWVAR 20
45913: PUSH
45914: LD_INT 0
45916: ST_TO_ADDR
// uc_nation := 0 ;
45917: LD_ADDR_OWVAR 21
45921: PUSH
45922: LD_INT 0
45924: ST_TO_ADDR
// InitHc ;
45925: CALL_OW 19
// hc_class := class_horse ;
45929: LD_ADDR_OWVAR 28
45933: PUSH
45934: LD_INT 21
45936: ST_TO_ADDR
// hc_gallery :=  ;
45937: LD_ADDR_OWVAR 33
45941: PUSH
45942: LD_STRING 
45944: ST_TO_ADDR
// hc_name :=  ;
45945: LD_ADDR_OWVAR 26
45949: PUSH
45950: LD_STRING 
45952: ST_TO_ADDR
// end ;
45953: LD_VAR 0 1
45957: RET
// export function PrepareMastodont ( ) ; begin
45958: LD_INT 0
45960: PPUSH
// uc_side := 0 ;
45961: LD_ADDR_OWVAR 20
45965: PUSH
45966: LD_INT 0
45968: ST_TO_ADDR
// uc_nation := 0 ;
45969: LD_ADDR_OWVAR 21
45973: PUSH
45974: LD_INT 0
45976: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45977: LD_ADDR_OWVAR 37
45981: PUSH
45982: LD_INT 31
45984: ST_TO_ADDR
// vc_control := control_rider ;
45985: LD_ADDR_OWVAR 38
45989: PUSH
45990: LD_INT 4
45992: ST_TO_ADDR
// end ;
45993: LD_VAR 0 1
45997: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45998: LD_INT 0
46000: PPUSH
46001: PPUSH
46002: PPUSH
// uc_side = 0 ;
46003: LD_ADDR_OWVAR 20
46007: PUSH
46008: LD_INT 0
46010: ST_TO_ADDR
// uc_nation = 0 ;
46011: LD_ADDR_OWVAR 21
46015: PUSH
46016: LD_INT 0
46018: ST_TO_ADDR
// InitHc_All ( ) ;
46019: CALL_OW 584
// InitVc ;
46023: CALL_OW 20
// if mastodonts then
46027: LD_VAR 0 6
46031: IFFALSE 46098
// for i = 1 to mastodonts do
46033: LD_ADDR_VAR 0 11
46037: PUSH
46038: DOUBLE
46039: LD_INT 1
46041: DEC
46042: ST_TO_ADDR
46043: LD_VAR 0 6
46047: PUSH
46048: FOR_TO
46049: IFFALSE 46096
// begin vc_chassis := 31 ;
46051: LD_ADDR_OWVAR 37
46055: PUSH
46056: LD_INT 31
46058: ST_TO_ADDR
// vc_control := control_rider ;
46059: LD_ADDR_OWVAR 38
46063: PUSH
46064: LD_INT 4
46066: ST_TO_ADDR
// animal := CreateVehicle ;
46067: LD_ADDR_VAR 0 12
46071: PUSH
46072: CALL_OW 45
46076: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46077: LD_VAR 0 12
46081: PPUSH
46082: LD_VAR 0 8
46086: PPUSH
46087: LD_INT 0
46089: PPUSH
46090: CALL 48240 0 3
// end ;
46094: GO 46048
46096: POP
46097: POP
// if horses then
46098: LD_VAR 0 5
46102: IFFALSE 46169
// for i = 1 to horses do
46104: LD_ADDR_VAR 0 11
46108: PUSH
46109: DOUBLE
46110: LD_INT 1
46112: DEC
46113: ST_TO_ADDR
46114: LD_VAR 0 5
46118: PUSH
46119: FOR_TO
46120: IFFALSE 46167
// begin hc_class := 21 ;
46122: LD_ADDR_OWVAR 28
46126: PUSH
46127: LD_INT 21
46129: ST_TO_ADDR
// hc_gallery :=  ;
46130: LD_ADDR_OWVAR 33
46134: PUSH
46135: LD_STRING 
46137: ST_TO_ADDR
// animal := CreateHuman ;
46138: LD_ADDR_VAR 0 12
46142: PUSH
46143: CALL_OW 44
46147: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46148: LD_VAR 0 12
46152: PPUSH
46153: LD_VAR 0 8
46157: PPUSH
46158: LD_INT 0
46160: PPUSH
46161: CALL 48240 0 3
// end ;
46165: GO 46119
46167: POP
46168: POP
// if birds then
46169: LD_VAR 0 1
46173: IFFALSE 46240
// for i = 1 to birds do
46175: LD_ADDR_VAR 0 11
46179: PUSH
46180: DOUBLE
46181: LD_INT 1
46183: DEC
46184: ST_TO_ADDR
46185: LD_VAR 0 1
46189: PUSH
46190: FOR_TO
46191: IFFALSE 46238
// begin hc_class := 18 ;
46193: LD_ADDR_OWVAR 28
46197: PUSH
46198: LD_INT 18
46200: ST_TO_ADDR
// hc_gallery =  ;
46201: LD_ADDR_OWVAR 33
46205: PUSH
46206: LD_STRING 
46208: ST_TO_ADDR
// animal := CreateHuman ;
46209: LD_ADDR_VAR 0 12
46213: PUSH
46214: CALL_OW 44
46218: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46219: LD_VAR 0 12
46223: PPUSH
46224: LD_VAR 0 8
46228: PPUSH
46229: LD_INT 0
46231: PPUSH
46232: CALL 48240 0 3
// end ;
46236: GO 46190
46238: POP
46239: POP
// if tigers then
46240: LD_VAR 0 2
46244: IFFALSE 46328
// for i = 1 to tigers do
46246: LD_ADDR_VAR 0 11
46250: PUSH
46251: DOUBLE
46252: LD_INT 1
46254: DEC
46255: ST_TO_ADDR
46256: LD_VAR 0 2
46260: PUSH
46261: FOR_TO
46262: IFFALSE 46326
// begin hc_class = class_tiger ;
46264: LD_ADDR_OWVAR 28
46268: PUSH
46269: LD_INT 14
46271: ST_TO_ADDR
// hc_gallery =  ;
46272: LD_ADDR_OWVAR 33
46276: PUSH
46277: LD_STRING 
46279: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46280: LD_ADDR_OWVAR 35
46284: PUSH
46285: LD_INT 7
46287: NEG
46288: PPUSH
46289: LD_INT 7
46291: PPUSH
46292: CALL_OW 12
46296: ST_TO_ADDR
// animal := CreateHuman ;
46297: LD_ADDR_VAR 0 12
46301: PUSH
46302: CALL_OW 44
46306: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46307: LD_VAR 0 12
46311: PPUSH
46312: LD_VAR 0 8
46316: PPUSH
46317: LD_INT 0
46319: PPUSH
46320: CALL 48240 0 3
// end ;
46324: GO 46261
46326: POP
46327: POP
// if apemans then
46328: LD_VAR 0 3
46332: IFFALSE 46455
// for i = 1 to apemans do
46334: LD_ADDR_VAR 0 11
46338: PUSH
46339: DOUBLE
46340: LD_INT 1
46342: DEC
46343: ST_TO_ADDR
46344: LD_VAR 0 3
46348: PUSH
46349: FOR_TO
46350: IFFALSE 46453
// begin hc_class = class_apeman ;
46352: LD_ADDR_OWVAR 28
46356: PUSH
46357: LD_INT 12
46359: ST_TO_ADDR
// hc_gallery =  ;
46360: LD_ADDR_OWVAR 33
46364: PUSH
46365: LD_STRING 
46367: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
46368: LD_ADDR_OWVAR 35
46372: PUSH
46373: LD_INT 2
46375: NEG
46376: PPUSH
46377: LD_INT 2
46379: PPUSH
46380: CALL_OW 12
46384: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46385: LD_ADDR_OWVAR 31
46389: PUSH
46390: LD_INT 1
46392: PPUSH
46393: LD_INT 3
46395: PPUSH
46396: CALL_OW 12
46400: PUSH
46401: LD_INT 1
46403: PPUSH
46404: LD_INT 3
46406: PPUSH
46407: CALL_OW 12
46411: PUSH
46412: LD_INT 0
46414: PUSH
46415: LD_INT 0
46417: PUSH
46418: EMPTY
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: ST_TO_ADDR
// animal := CreateHuman ;
46424: LD_ADDR_VAR 0 12
46428: PUSH
46429: CALL_OW 44
46433: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46434: LD_VAR 0 12
46438: PPUSH
46439: LD_VAR 0 8
46443: PPUSH
46444: LD_INT 0
46446: PPUSH
46447: CALL 48240 0 3
// end ;
46451: GO 46349
46453: POP
46454: POP
// if enchidnas then
46455: LD_VAR 0 4
46459: IFFALSE 46526
// for i = 1 to enchidnas do
46461: LD_ADDR_VAR 0 11
46465: PUSH
46466: DOUBLE
46467: LD_INT 1
46469: DEC
46470: ST_TO_ADDR
46471: LD_VAR 0 4
46475: PUSH
46476: FOR_TO
46477: IFFALSE 46524
// begin hc_class = 13 ;
46479: LD_ADDR_OWVAR 28
46483: PUSH
46484: LD_INT 13
46486: ST_TO_ADDR
// hc_gallery =  ;
46487: LD_ADDR_OWVAR 33
46491: PUSH
46492: LD_STRING 
46494: ST_TO_ADDR
// animal := CreateHuman ;
46495: LD_ADDR_VAR 0 12
46499: PUSH
46500: CALL_OW 44
46504: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46505: LD_VAR 0 12
46509: PPUSH
46510: LD_VAR 0 8
46514: PPUSH
46515: LD_INT 0
46517: PPUSH
46518: CALL 48240 0 3
// end ;
46522: GO 46476
46524: POP
46525: POP
// if fishes then
46526: LD_VAR 0 7
46530: IFFALSE 46597
// for i = 1 to fishes do
46532: LD_ADDR_VAR 0 11
46536: PUSH
46537: DOUBLE
46538: LD_INT 1
46540: DEC
46541: ST_TO_ADDR
46542: LD_VAR 0 7
46546: PUSH
46547: FOR_TO
46548: IFFALSE 46595
// begin hc_class = 20 ;
46550: LD_ADDR_OWVAR 28
46554: PUSH
46555: LD_INT 20
46557: ST_TO_ADDR
// hc_gallery =  ;
46558: LD_ADDR_OWVAR 33
46562: PUSH
46563: LD_STRING 
46565: ST_TO_ADDR
// animal := CreateHuman ;
46566: LD_ADDR_VAR 0 12
46570: PUSH
46571: CALL_OW 44
46575: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46576: LD_VAR 0 12
46580: PPUSH
46581: LD_VAR 0 9
46585: PPUSH
46586: LD_INT 0
46588: PPUSH
46589: CALL 48240 0 3
// end ;
46593: GO 46547
46595: POP
46596: POP
// end ;
46597: LD_VAR 0 10
46601: RET
// export function WantHeal ( sci , unit ) ; begin
46602: LD_INT 0
46604: PPUSH
// if GetTaskList ( sci ) > 0 then
46605: LD_VAR 0 1
46609: PPUSH
46610: CALL_OW 437
46614: PUSH
46615: LD_INT 0
46617: GREATER
46618: IFFALSE 46690
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46620: LD_VAR 0 1
46624: PPUSH
46625: CALL_OW 437
46629: PUSH
46630: LD_INT 1
46632: ARRAY
46633: PUSH
46634: LD_INT 1
46636: ARRAY
46637: PUSH
46638: LD_STRING l
46640: EQUAL
46641: IFFALSE 46668
46643: PUSH
46644: LD_VAR 0 1
46648: PPUSH
46649: CALL_OW 437
46653: PUSH
46654: LD_INT 1
46656: ARRAY
46657: PUSH
46658: LD_INT 4
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 2
46666: EQUAL
46667: AND
46668: IFFALSE 46680
// result := true else
46670: LD_ADDR_VAR 0 3
46674: PUSH
46675: LD_INT 1
46677: ST_TO_ADDR
46678: GO 46688
// result := false ;
46680: LD_ADDR_VAR 0 3
46684: PUSH
46685: LD_INT 0
46687: ST_TO_ADDR
// end else
46688: GO 46698
// result := false ;
46690: LD_ADDR_VAR 0 3
46694: PUSH
46695: LD_INT 0
46697: ST_TO_ADDR
// end ;
46698: LD_VAR 0 3
46702: RET
// export function HealTarget ( sci ) ; begin
46703: LD_INT 0
46705: PPUSH
// if not sci then
46706: LD_VAR 0 1
46710: NOT
46711: IFFALSE 46715
// exit ;
46713: GO 46780
// result := 0 ;
46715: LD_ADDR_VAR 0 2
46719: PUSH
46720: LD_INT 0
46722: ST_TO_ADDR
// if GetTaskList ( sci ) then
46723: LD_VAR 0 1
46727: PPUSH
46728: CALL_OW 437
46732: IFFALSE 46780
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46734: LD_VAR 0 1
46738: PPUSH
46739: CALL_OW 437
46743: PUSH
46744: LD_INT 1
46746: ARRAY
46747: PUSH
46748: LD_INT 1
46750: ARRAY
46751: PUSH
46752: LD_STRING l
46754: EQUAL
46755: IFFALSE 46780
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46757: LD_ADDR_VAR 0 2
46761: PUSH
46762: LD_VAR 0 1
46766: PPUSH
46767: CALL_OW 437
46771: PUSH
46772: LD_INT 1
46774: ARRAY
46775: PUSH
46776: LD_INT 4
46778: ARRAY
46779: ST_TO_ADDR
// end ;
46780: LD_VAR 0 2
46784: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46785: LD_INT 0
46787: PPUSH
46788: PPUSH
46789: PPUSH
46790: PPUSH
// if not base_units then
46791: LD_VAR 0 1
46795: NOT
46796: IFFALSE 46800
// exit ;
46798: GO 46887
// result := false ;
46800: LD_ADDR_VAR 0 2
46804: PUSH
46805: LD_INT 0
46807: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46808: LD_ADDR_VAR 0 5
46812: PUSH
46813: LD_VAR 0 1
46817: PPUSH
46818: LD_INT 21
46820: PUSH
46821: LD_INT 3
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: PPUSH
46828: CALL_OW 72
46832: ST_TO_ADDR
// if not tmp then
46833: LD_VAR 0 5
46837: NOT
46838: IFFALSE 46842
// exit ;
46840: GO 46887
// for i in tmp do
46842: LD_ADDR_VAR 0 3
46846: PUSH
46847: LD_VAR 0 5
46851: PUSH
46852: FOR_IN
46853: IFFALSE 46885
// begin result := EnemyInRange ( i , 22 ) ;
46855: LD_ADDR_VAR 0 2
46859: PUSH
46860: LD_VAR 0 3
46864: PPUSH
46865: LD_INT 22
46867: PPUSH
46868: CALL 44302 0 2
46872: ST_TO_ADDR
// if result then
46873: LD_VAR 0 2
46877: IFFALSE 46883
// exit ;
46879: POP
46880: POP
46881: GO 46887
// end ;
46883: GO 46852
46885: POP
46886: POP
// end ;
46887: LD_VAR 0 2
46891: RET
// export function FilterByTag ( units , tag ) ; begin
46892: LD_INT 0
46894: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46895: LD_ADDR_VAR 0 3
46899: PUSH
46900: LD_VAR 0 1
46904: PPUSH
46905: LD_INT 120
46907: PUSH
46908: LD_VAR 0 2
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: PPUSH
46917: CALL_OW 72
46921: ST_TO_ADDR
// end ;
46922: LD_VAR 0 3
46926: RET
// export function IsDriver ( un ) ; begin
46927: LD_INT 0
46929: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46930: LD_ADDR_VAR 0 2
46934: PUSH
46935: LD_VAR 0 1
46939: PUSH
46940: LD_INT 55
46942: PUSH
46943: EMPTY
46944: LIST
46945: PPUSH
46946: CALL_OW 69
46950: IN
46951: ST_TO_ADDR
// end ;
46952: LD_VAR 0 2
46956: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46957: LD_INT 0
46959: PPUSH
46960: PPUSH
// list := [ ] ;
46961: LD_ADDR_VAR 0 5
46965: PUSH
46966: EMPTY
46967: ST_TO_ADDR
// case d of 0 :
46968: LD_VAR 0 3
46972: PUSH
46973: LD_INT 0
46975: DOUBLE
46976: EQUAL
46977: IFTRUE 46981
46979: GO 47114
46981: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46982: LD_ADDR_VAR 0 5
46986: PUSH
46987: LD_VAR 0 1
46991: PUSH
46992: LD_INT 4
46994: MINUS
46995: PUSH
46996: LD_VAR 0 2
47000: PUSH
47001: LD_INT 4
47003: MINUS
47004: PUSH
47005: LD_INT 2
47007: PUSH
47008: EMPTY
47009: LIST
47010: LIST
47011: LIST
47012: PUSH
47013: LD_VAR 0 1
47017: PUSH
47018: LD_INT 3
47020: MINUS
47021: PUSH
47022: LD_VAR 0 2
47026: PUSH
47027: LD_INT 1
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: LIST
47034: PUSH
47035: LD_VAR 0 1
47039: PUSH
47040: LD_INT 4
47042: PLUS
47043: PUSH
47044: LD_VAR 0 2
47048: PUSH
47049: LD_INT 4
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: LIST
47056: PUSH
47057: LD_VAR 0 1
47061: PUSH
47062: LD_INT 3
47064: PLUS
47065: PUSH
47066: LD_VAR 0 2
47070: PUSH
47071: LD_INT 3
47073: PLUS
47074: PUSH
47075: LD_INT 5
47077: PUSH
47078: EMPTY
47079: LIST
47080: LIST
47081: LIST
47082: PUSH
47083: LD_VAR 0 1
47087: PUSH
47088: LD_VAR 0 2
47092: PUSH
47093: LD_INT 4
47095: PLUS
47096: PUSH
47097: LD_INT 0
47099: PUSH
47100: EMPTY
47101: LIST
47102: LIST
47103: LIST
47104: PUSH
47105: EMPTY
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: ST_TO_ADDR
// end ; 1 :
47112: GO 47812
47114: LD_INT 1
47116: DOUBLE
47117: EQUAL
47118: IFTRUE 47122
47120: GO 47255
47122: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47123: LD_ADDR_VAR 0 5
47127: PUSH
47128: LD_VAR 0 1
47132: PUSH
47133: LD_VAR 0 2
47137: PUSH
47138: LD_INT 4
47140: MINUS
47141: PUSH
47142: LD_INT 3
47144: PUSH
47145: EMPTY
47146: LIST
47147: LIST
47148: LIST
47149: PUSH
47150: LD_VAR 0 1
47154: PUSH
47155: LD_INT 3
47157: MINUS
47158: PUSH
47159: LD_VAR 0 2
47163: PUSH
47164: LD_INT 3
47166: MINUS
47167: PUSH
47168: LD_INT 2
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: LIST
47175: PUSH
47176: LD_VAR 0 1
47180: PUSH
47181: LD_INT 4
47183: MINUS
47184: PUSH
47185: LD_VAR 0 2
47189: PUSH
47190: LD_INT 1
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: LIST
47197: PUSH
47198: LD_VAR 0 1
47202: PUSH
47203: LD_VAR 0 2
47207: PUSH
47208: LD_INT 3
47210: PLUS
47211: PUSH
47212: LD_INT 0
47214: PUSH
47215: EMPTY
47216: LIST
47217: LIST
47218: LIST
47219: PUSH
47220: LD_VAR 0 1
47224: PUSH
47225: LD_INT 4
47227: PLUS
47228: PUSH
47229: LD_VAR 0 2
47233: PUSH
47234: LD_INT 4
47236: PLUS
47237: PUSH
47238: LD_INT 5
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: LIST
47245: PUSH
47246: EMPTY
47247: LIST
47248: LIST
47249: LIST
47250: LIST
47251: LIST
47252: ST_TO_ADDR
// end ; 2 :
47253: GO 47812
47255: LD_INT 2
47257: DOUBLE
47258: EQUAL
47259: IFTRUE 47263
47261: GO 47392
47263: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47264: LD_ADDR_VAR 0 5
47268: PUSH
47269: LD_VAR 0 1
47273: PUSH
47274: LD_VAR 0 2
47278: PUSH
47279: LD_INT 3
47281: MINUS
47282: PUSH
47283: LD_INT 3
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: LIST
47290: PUSH
47291: LD_VAR 0 1
47295: PUSH
47296: LD_INT 4
47298: PLUS
47299: PUSH
47300: LD_VAR 0 2
47304: PUSH
47305: LD_INT 4
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: LIST
47312: PUSH
47313: LD_VAR 0 1
47317: PUSH
47318: LD_VAR 0 2
47322: PUSH
47323: LD_INT 4
47325: PLUS
47326: PUSH
47327: LD_INT 0
47329: PUSH
47330: EMPTY
47331: LIST
47332: LIST
47333: LIST
47334: PUSH
47335: LD_VAR 0 1
47339: PUSH
47340: LD_INT 3
47342: MINUS
47343: PUSH
47344: LD_VAR 0 2
47348: PUSH
47349: LD_INT 1
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: LIST
47356: PUSH
47357: LD_VAR 0 1
47361: PUSH
47362: LD_INT 4
47364: MINUS
47365: PUSH
47366: LD_VAR 0 2
47370: PUSH
47371: LD_INT 4
47373: MINUS
47374: PUSH
47375: LD_INT 2
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: LIST
47382: PUSH
47383: EMPTY
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: ST_TO_ADDR
// end ; 3 :
47390: GO 47812
47392: LD_INT 3
47394: DOUBLE
47395: EQUAL
47396: IFTRUE 47400
47398: GO 47533
47400: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47401: LD_ADDR_VAR 0 5
47405: PUSH
47406: LD_VAR 0 1
47410: PUSH
47411: LD_INT 3
47413: PLUS
47414: PUSH
47415: LD_VAR 0 2
47419: PUSH
47420: LD_INT 4
47422: PUSH
47423: EMPTY
47424: LIST
47425: LIST
47426: LIST
47427: PUSH
47428: LD_VAR 0 1
47432: PUSH
47433: LD_INT 4
47435: PLUS
47436: PUSH
47437: LD_VAR 0 2
47441: PUSH
47442: LD_INT 4
47444: PLUS
47445: PUSH
47446: LD_INT 5
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: LIST
47453: PUSH
47454: LD_VAR 0 1
47458: PUSH
47459: LD_INT 4
47461: MINUS
47462: PUSH
47463: LD_VAR 0 2
47467: PUSH
47468: LD_INT 1
47470: PUSH
47471: EMPTY
47472: LIST
47473: LIST
47474: LIST
47475: PUSH
47476: LD_VAR 0 1
47480: PUSH
47481: LD_VAR 0 2
47485: PUSH
47486: LD_INT 4
47488: MINUS
47489: PUSH
47490: LD_INT 3
47492: PUSH
47493: EMPTY
47494: LIST
47495: LIST
47496: LIST
47497: PUSH
47498: LD_VAR 0 1
47502: PUSH
47503: LD_INT 3
47505: MINUS
47506: PUSH
47507: LD_VAR 0 2
47511: PUSH
47512: LD_INT 3
47514: MINUS
47515: PUSH
47516: LD_INT 2
47518: PUSH
47519: EMPTY
47520: LIST
47521: LIST
47522: LIST
47523: PUSH
47524: EMPTY
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: ST_TO_ADDR
// end ; 4 :
47531: GO 47812
47533: LD_INT 4
47535: DOUBLE
47536: EQUAL
47537: IFTRUE 47541
47539: GO 47674
47541: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47542: LD_ADDR_VAR 0 5
47546: PUSH
47547: LD_VAR 0 1
47551: PUSH
47552: LD_VAR 0 2
47556: PUSH
47557: LD_INT 4
47559: PLUS
47560: PUSH
47561: LD_INT 0
47563: PUSH
47564: EMPTY
47565: LIST
47566: LIST
47567: LIST
47568: PUSH
47569: LD_VAR 0 1
47573: PUSH
47574: LD_INT 3
47576: PLUS
47577: PUSH
47578: LD_VAR 0 2
47582: PUSH
47583: LD_INT 3
47585: PLUS
47586: PUSH
47587: LD_INT 5
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: PUSH
47595: LD_VAR 0 1
47599: PUSH
47600: LD_INT 4
47602: PLUS
47603: PUSH
47604: LD_VAR 0 2
47608: PUSH
47609: LD_INT 4
47611: PUSH
47612: EMPTY
47613: LIST
47614: LIST
47615: LIST
47616: PUSH
47617: LD_VAR 0 1
47621: PUSH
47622: LD_VAR 0 2
47626: PUSH
47627: LD_INT 3
47629: MINUS
47630: PUSH
47631: LD_INT 3
47633: PUSH
47634: EMPTY
47635: LIST
47636: LIST
47637: LIST
47638: PUSH
47639: LD_VAR 0 1
47643: PUSH
47644: LD_INT 4
47646: MINUS
47647: PUSH
47648: LD_VAR 0 2
47652: PUSH
47653: LD_INT 4
47655: MINUS
47656: PUSH
47657: LD_INT 2
47659: PUSH
47660: EMPTY
47661: LIST
47662: LIST
47663: LIST
47664: PUSH
47665: EMPTY
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: ST_TO_ADDR
// end ; 5 :
47672: GO 47812
47674: LD_INT 5
47676: DOUBLE
47677: EQUAL
47678: IFTRUE 47682
47680: GO 47811
47682: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47683: LD_ADDR_VAR 0 5
47687: PUSH
47688: LD_VAR 0 1
47692: PUSH
47693: LD_INT 4
47695: MINUS
47696: PUSH
47697: LD_VAR 0 2
47701: PUSH
47702: LD_INT 1
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: LIST
47709: PUSH
47710: LD_VAR 0 1
47714: PUSH
47715: LD_VAR 0 2
47719: PUSH
47720: LD_INT 4
47722: MINUS
47723: PUSH
47724: LD_INT 3
47726: PUSH
47727: EMPTY
47728: LIST
47729: LIST
47730: LIST
47731: PUSH
47732: LD_VAR 0 1
47736: PUSH
47737: LD_INT 4
47739: PLUS
47740: PUSH
47741: LD_VAR 0 2
47745: PUSH
47746: LD_INT 4
47748: PLUS
47749: PUSH
47750: LD_INT 5
47752: PUSH
47753: EMPTY
47754: LIST
47755: LIST
47756: LIST
47757: PUSH
47758: LD_VAR 0 1
47762: PUSH
47763: LD_INT 3
47765: PLUS
47766: PUSH
47767: LD_VAR 0 2
47771: PUSH
47772: LD_INT 4
47774: PUSH
47775: EMPTY
47776: LIST
47777: LIST
47778: LIST
47779: PUSH
47780: LD_VAR 0 1
47784: PUSH
47785: LD_VAR 0 2
47789: PUSH
47790: LD_INT 3
47792: PLUS
47793: PUSH
47794: LD_INT 0
47796: PUSH
47797: EMPTY
47798: LIST
47799: LIST
47800: LIST
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: LIST
47806: LIST
47807: LIST
47808: ST_TO_ADDR
// end ; end ;
47809: GO 47812
47811: POP
// result := list ;
47812: LD_ADDR_VAR 0 4
47816: PUSH
47817: LD_VAR 0 5
47821: ST_TO_ADDR
// end ;
47822: LD_VAR 0 4
47826: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
47827: LD_INT 0
47829: PPUSH
47830: PPUSH
47831: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
47832: LD_VAR 0 1
47836: NOT
47837: IFTRUE 47865
47839: PUSH
47840: LD_VAR 0 2
47844: PUSH
47845: LD_INT 1
47847: PUSH
47848: LD_INT 2
47850: PUSH
47851: LD_INT 3
47853: PUSH
47854: LD_INT 4
47856: PUSH
47857: EMPTY
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: IN
47863: NOT
47864: OR
47865: IFFALSE 47869
// exit ;
47867: GO 47952
// tmp := [ ] ;
47869: LD_ADDR_VAR 0 5
47873: PUSH
47874: EMPTY
47875: ST_TO_ADDR
// for i in units do
47876: LD_ADDR_VAR 0 4
47880: PUSH
47881: LD_VAR 0 1
47885: PUSH
47886: FOR_IN
47887: IFFALSE 47921
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47889: LD_ADDR_VAR 0 5
47893: PUSH
47894: LD_VAR 0 5
47898: PPUSH
47899: LD_VAR 0 4
47903: PPUSH
47904: LD_VAR 0 2
47908: PPUSH
47909: CALL_OW 259
47913: PPUSH
47914: CALL 49347 0 2
47918: ST_TO_ADDR
47919: GO 47886
47921: POP
47922: POP
// if not tmp then
47923: LD_VAR 0 5
47927: NOT
47928: IFFALSE 47932
// exit ;
47930: GO 47952
// result := SortListByListDesc ( units , tmp ) ;
47932: LD_ADDR_VAR 0 3
47936: PUSH
47937: LD_VAR 0 1
47941: PPUSH
47942: LD_VAR 0 5
47946: PPUSH
47947: CALL_OW 77
47951: ST_TO_ADDR
// end ;
47952: LD_VAR 0 3
47956: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47957: LD_INT 0
47959: PPUSH
47960: PPUSH
47961: PPUSH
// result := false ;
47962: LD_ADDR_VAR 0 3
47966: PUSH
47967: LD_INT 0
47969: ST_TO_ADDR
// if not building then
47970: LD_VAR 0 2
47974: NOT
47975: IFFALSE 47979
// exit ;
47977: GO 48123
// x := GetX ( building ) ;
47979: LD_ADDR_VAR 0 4
47983: PUSH
47984: LD_VAR 0 2
47988: PPUSH
47989: CALL_OW 250
47993: ST_TO_ADDR
// y := GetY ( building ) ;
47994: LD_ADDR_VAR 0 5
47998: PUSH
47999: LD_VAR 0 2
48003: PPUSH
48004: CALL_OW 251
48008: ST_TO_ADDR
// if not x or not y then
48009: LD_VAR 0 4
48013: NOT
48014: IFTRUE 48023
48016: PUSH
48017: LD_VAR 0 5
48021: NOT
48022: OR
48023: IFFALSE 48027
// exit ;
48025: GO 48123
// if GetTaskList ( unit ) then
48027: LD_VAR 0 1
48031: PPUSH
48032: CALL_OW 437
48036: IFFALSE 48123
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48038: LD_STRING e
48040: PUSH
48041: LD_VAR 0 1
48045: PPUSH
48046: CALL_OW 437
48050: PUSH
48051: LD_INT 1
48053: ARRAY
48054: PUSH
48055: LD_INT 1
48057: ARRAY
48058: EQUAL
48059: IFFALSE 48086
48061: PUSH
48062: LD_VAR 0 4
48066: PUSH
48067: LD_VAR 0 1
48071: PPUSH
48072: CALL_OW 437
48076: PUSH
48077: LD_INT 1
48079: ARRAY
48080: PUSH
48081: LD_INT 2
48083: ARRAY
48084: EQUAL
48085: AND
48086: IFFALSE 48113
48088: PUSH
48089: LD_VAR 0 5
48093: PUSH
48094: LD_VAR 0 1
48098: PPUSH
48099: CALL_OW 437
48103: PUSH
48104: LD_INT 1
48106: ARRAY
48107: PUSH
48108: LD_INT 3
48110: ARRAY
48111: EQUAL
48112: AND
48113: IFFALSE 48123
// result := true end ;
48115: LD_ADDR_VAR 0 3
48119: PUSH
48120: LD_INT 1
48122: ST_TO_ADDR
// end ;
48123: LD_VAR 0 3
48127: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48128: LD_INT 0
48130: PPUSH
// result := false ;
48131: LD_ADDR_VAR 0 4
48135: PUSH
48136: LD_INT 0
48138: ST_TO_ADDR
// if GetTaskList ( unit ) then
48139: LD_VAR 0 1
48143: PPUSH
48144: CALL_OW 437
48148: IFFALSE 48235
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48150: LD_STRING M
48152: PUSH
48153: LD_VAR 0 1
48157: PPUSH
48158: CALL_OW 437
48162: PUSH
48163: LD_INT 1
48165: ARRAY
48166: PUSH
48167: LD_INT 1
48169: ARRAY
48170: EQUAL
48171: IFFALSE 48198
48173: PUSH
48174: LD_VAR 0 2
48178: PUSH
48179: LD_VAR 0 1
48183: PPUSH
48184: CALL_OW 437
48188: PUSH
48189: LD_INT 1
48191: ARRAY
48192: PUSH
48193: LD_INT 2
48195: ARRAY
48196: EQUAL
48197: AND
48198: IFFALSE 48225
48200: PUSH
48201: LD_VAR 0 3
48205: PUSH
48206: LD_VAR 0 1
48210: PPUSH
48211: CALL_OW 437
48215: PUSH
48216: LD_INT 1
48218: ARRAY
48219: PUSH
48220: LD_INT 3
48222: ARRAY
48223: EQUAL
48224: AND
48225: IFFALSE 48235
// result := true ;
48227: LD_ADDR_VAR 0 4
48231: PUSH
48232: LD_INT 1
48234: ST_TO_ADDR
// end ; end ;
48235: LD_VAR 0 4
48239: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48240: LD_INT 0
48242: PPUSH
48243: PPUSH
48244: PPUSH
48245: PPUSH
// if not unit or not area then
48246: LD_VAR 0 1
48250: NOT
48251: IFTRUE 48260
48253: PUSH
48254: LD_VAR 0 2
48258: NOT
48259: OR
48260: IFFALSE 48264
// exit ;
48262: GO 48440
// tmp := AreaToList ( area , i ) ;
48264: LD_ADDR_VAR 0 6
48268: PUSH
48269: LD_VAR 0 2
48273: PPUSH
48274: LD_VAR 0 5
48278: PPUSH
48279: CALL_OW 517
48283: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48284: LD_ADDR_VAR 0 5
48288: PUSH
48289: DOUBLE
48290: LD_INT 1
48292: DEC
48293: ST_TO_ADDR
48294: LD_VAR 0 6
48298: PUSH
48299: LD_INT 1
48301: ARRAY
48302: PUSH
48303: FOR_TO
48304: IFFALSE 48438
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48306: LD_ADDR_VAR 0 7
48310: PUSH
48311: LD_VAR 0 6
48315: PUSH
48316: LD_INT 1
48318: ARRAY
48319: PUSH
48320: LD_VAR 0 5
48324: ARRAY
48325: PUSH
48326: LD_VAR 0 6
48330: PUSH
48331: LD_INT 2
48333: ARRAY
48334: PUSH
48335: LD_VAR 0 5
48339: ARRAY
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
48345: LD_INT 92
48347: PUSH
48348: LD_VAR 0 7
48352: PUSH
48353: LD_INT 1
48355: ARRAY
48356: PUSH
48357: LD_VAR 0 7
48361: PUSH
48362: LD_INT 2
48364: ARRAY
48365: PUSH
48366: LD_INT 2
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: PPUSH
48375: CALL_OW 69
48379: PUSH
48380: LD_INT 0
48382: EQUAL
48383: IFFALSE 48436
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48385: LD_VAR 0 1
48389: PPUSH
48390: LD_VAR 0 7
48394: PUSH
48395: LD_INT 1
48397: ARRAY
48398: PPUSH
48399: LD_VAR 0 7
48403: PUSH
48404: LD_INT 2
48406: ARRAY
48407: PPUSH
48408: LD_VAR 0 3
48412: PPUSH
48413: CALL_OW 48
// result := IsPlaced ( unit ) ;
48417: LD_ADDR_VAR 0 4
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: CALL_OW 305
48431: ST_TO_ADDR
// exit ;
48432: POP
48433: POP
48434: GO 48440
// end ; end ;
48436: GO 48303
48438: POP
48439: POP
// end ;
48440: LD_VAR 0 4
48444: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48445: LD_INT 0
48447: PPUSH
48448: PPUSH
48449: PPUSH
// if not side or side > 8 then
48450: LD_VAR 0 1
48454: NOT
48455: IFTRUE 48467
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_INT 8
48465: GREATER
48466: OR
48467: IFFALSE 48471
// exit ;
48469: GO 48658
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48471: LD_ADDR_VAR 0 4
48475: PUSH
48476: LD_INT 22
48478: PUSH
48479: LD_VAR 0 1
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PUSH
48488: LD_INT 21
48490: PUSH
48491: LD_INT 3
48493: PUSH
48494: EMPTY
48495: LIST
48496: LIST
48497: PUSH
48498: EMPTY
48499: LIST
48500: LIST
48501: PPUSH
48502: CALL_OW 69
48506: ST_TO_ADDR
// if not tmp then
48507: LD_VAR 0 4
48511: NOT
48512: IFFALSE 48516
// exit ;
48514: GO 48658
// enable_addtolog := true ;
48516: LD_ADDR_OWVAR 81
48520: PUSH
48521: LD_INT 1
48523: ST_TO_ADDR
// AddToLog ( [ ) ;
48524: LD_STRING [
48526: PPUSH
48527: CALL_OW 561
// for i in tmp do
48531: LD_ADDR_VAR 0 3
48535: PUSH
48536: LD_VAR 0 4
48540: PUSH
48541: FOR_IN
48542: IFFALSE 48649
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48544: LD_STRING [
48546: PUSH
48547: LD_VAR 0 3
48551: PPUSH
48552: CALL_OW 266
48556: STR
48557: PUSH
48558: LD_STRING , 
48560: STR
48561: PUSH
48562: LD_VAR 0 3
48566: PPUSH
48567: CALL_OW 250
48571: STR
48572: PUSH
48573: LD_STRING , 
48575: STR
48576: PUSH
48577: LD_VAR 0 3
48581: PPUSH
48582: CALL_OW 251
48586: STR
48587: PUSH
48588: LD_STRING , 
48590: STR
48591: PUSH
48592: LD_VAR 0 3
48596: PPUSH
48597: CALL_OW 254
48601: STR
48602: PUSH
48603: LD_STRING , 
48605: STR
48606: PUSH
48607: LD_VAR 0 3
48611: PPUSH
48612: LD_INT 1
48614: PPUSH
48615: CALL_OW 268
48619: STR
48620: PUSH
48621: LD_STRING , 
48623: STR
48624: PUSH
48625: LD_VAR 0 3
48629: PPUSH
48630: LD_INT 2
48632: PPUSH
48633: CALL_OW 268
48637: STR
48638: PUSH
48639: LD_STRING ],
48641: STR
48642: PPUSH
48643: CALL_OW 561
// end ;
48647: GO 48541
48649: POP
48650: POP
// AddToLog ( ]; ) ;
48651: LD_STRING ];
48653: PPUSH
48654: CALL_OW 561
// end ;
48658: LD_VAR 0 2
48662: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48663: LD_INT 0
48665: PPUSH
48666: PPUSH
48667: PPUSH
48668: PPUSH
48669: PPUSH
// if not area or not rate or not max then
48670: LD_VAR 0 1
48674: NOT
48675: IFTRUE 48684
48677: PUSH
48678: LD_VAR 0 2
48682: NOT
48683: OR
48684: IFTRUE 48693
48686: PUSH
48687: LD_VAR 0 4
48691: NOT
48692: OR
48693: IFFALSE 48697
// exit ;
48695: GO 48886
// while 1 do
48697: LD_INT 1
48699: IFFALSE 48886
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48701: LD_ADDR_VAR 0 9
48705: PUSH
48706: LD_VAR 0 1
48710: PPUSH
48711: LD_INT 1
48713: PPUSH
48714: CALL_OW 287
48718: PUSH
48719: LD_INT 10
48721: MUL
48722: ST_TO_ADDR
// r := rate / 10 ;
48723: LD_ADDR_VAR 0 7
48727: PUSH
48728: LD_VAR 0 2
48732: PUSH
48733: LD_INT 10
48735: DIVREAL
48736: ST_TO_ADDR
// time := 1 1$00 ;
48737: LD_ADDR_VAR 0 8
48741: PUSH
48742: LD_INT 2100
48744: ST_TO_ADDR
// if amount < min then
48745: LD_VAR 0 9
48749: PUSH
48750: LD_VAR 0 3
48754: LESS
48755: IFFALSE 48773
// r := r * 2 else
48757: LD_ADDR_VAR 0 7
48761: PUSH
48762: LD_VAR 0 7
48766: PUSH
48767: LD_INT 2
48769: MUL
48770: ST_TO_ADDR
48771: GO 48799
// if amount > max then
48773: LD_VAR 0 9
48777: PUSH
48778: LD_VAR 0 4
48782: GREATER
48783: IFFALSE 48799
// r := r / 2 ;
48785: LD_ADDR_VAR 0 7
48789: PUSH
48790: LD_VAR 0 7
48794: PUSH
48795: LD_INT 2
48797: DIVREAL
48798: ST_TO_ADDR
// time := time / r ;
48799: LD_ADDR_VAR 0 8
48803: PUSH
48804: LD_VAR 0 8
48808: PUSH
48809: LD_VAR 0 7
48813: DIVREAL
48814: ST_TO_ADDR
// if time < 0 then
48815: LD_VAR 0 8
48819: PUSH
48820: LD_INT 0
48822: LESS
48823: IFFALSE 48840
// time := time * - 1 ;
48825: LD_ADDR_VAR 0 8
48829: PUSH
48830: LD_VAR 0 8
48834: PUSH
48835: LD_INT 1
48837: NEG
48838: MUL
48839: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
48840: LD_VAR 0 8
48844: PUSH
48845: LD_INT 35
48847: PPUSH
48848: LD_INT 875
48850: PPUSH
48851: CALL_OW 12
48855: PLUS
48856: PPUSH
48857: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48861: LD_INT 1
48863: PPUSH
48864: LD_INT 5
48866: PPUSH
48867: CALL_OW 12
48871: PPUSH
48872: LD_VAR 0 1
48876: PPUSH
48877: LD_INT 1
48879: PPUSH
48880: CALL_OW 55
// end ;
48884: GO 48697
// end ;
48886: LD_VAR 0 5
48890: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48891: LD_INT 0
48893: PPUSH
48894: PPUSH
48895: PPUSH
48896: PPUSH
48897: PPUSH
48898: PPUSH
48899: PPUSH
48900: PPUSH
// if not turrets or not factories then
48901: LD_VAR 0 1
48905: NOT
48906: IFTRUE 48915
48908: PUSH
48909: LD_VAR 0 2
48913: NOT
48914: OR
48915: IFFALSE 48919
// exit ;
48917: GO 49226
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48919: LD_ADDR_VAR 0 10
48923: PUSH
48924: LD_INT 5
48926: PUSH
48927: LD_INT 6
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 2
48936: PUSH
48937: LD_INT 4
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: PUSH
48944: LD_INT 3
48946: PUSH
48947: LD_INT 5
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: EMPTY
48955: LIST
48956: LIST
48957: LIST
48958: PUSH
48959: LD_INT 24
48961: PUSH
48962: LD_INT 25
48964: PUSH
48965: EMPTY
48966: LIST
48967: LIST
48968: PUSH
48969: LD_INT 23
48971: PUSH
48972: LD_INT 27
48974: PUSH
48975: EMPTY
48976: LIST
48977: LIST
48978: PUSH
48979: EMPTY
48980: LIST
48981: LIST
48982: PUSH
48983: LD_INT 42
48985: PUSH
48986: LD_INT 43
48988: PUSH
48989: EMPTY
48990: LIST
48991: LIST
48992: PUSH
48993: LD_INT 44
48995: PUSH
48996: LD_INT 46
48998: PUSH
48999: EMPTY
49000: LIST
49001: LIST
49002: PUSH
49003: LD_INT 45
49005: PUSH
49006: LD_INT 47
49008: PUSH
49009: EMPTY
49010: LIST
49011: LIST
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: LIST
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: LIST
49022: ST_TO_ADDR
// result := [ ] ;
49023: LD_ADDR_VAR 0 3
49027: PUSH
49028: EMPTY
49029: ST_TO_ADDR
// for i in turrets do
49030: LD_ADDR_VAR 0 4
49034: PUSH
49035: LD_VAR 0 1
49039: PUSH
49040: FOR_IN
49041: IFFALSE 49224
// begin nat := GetNation ( i ) ;
49043: LD_ADDR_VAR 0 7
49047: PUSH
49048: LD_VAR 0 4
49052: PPUSH
49053: CALL_OW 248
49057: ST_TO_ADDR
// weapon := 0 ;
49058: LD_ADDR_VAR 0 8
49062: PUSH
49063: LD_INT 0
49065: ST_TO_ADDR
// if not nat then
49066: LD_VAR 0 7
49070: NOT
49071: IFFALSE 49075
// continue ;
49073: GO 49040
// for j in list [ nat ] do
49075: LD_ADDR_VAR 0 5
49079: PUSH
49080: LD_VAR 0 10
49084: PUSH
49085: LD_VAR 0 7
49089: ARRAY
49090: PUSH
49091: FOR_IN
49092: IFFALSE 49133
// if GetBWeapon ( i ) = j [ 1 ] then
49094: LD_VAR 0 4
49098: PPUSH
49099: CALL_OW 269
49103: PUSH
49104: LD_VAR 0 5
49108: PUSH
49109: LD_INT 1
49111: ARRAY
49112: EQUAL
49113: IFFALSE 49131
// begin weapon := j [ 2 ] ;
49115: LD_ADDR_VAR 0 8
49119: PUSH
49120: LD_VAR 0 5
49124: PUSH
49125: LD_INT 2
49127: ARRAY
49128: ST_TO_ADDR
// break ;
49129: GO 49133
// end ;
49131: GO 49091
49133: POP
49134: POP
// if not weapon then
49135: LD_VAR 0 8
49139: NOT
49140: IFFALSE 49144
// continue ;
49142: GO 49040
// for k in factories do
49144: LD_ADDR_VAR 0 6
49148: PUSH
49149: LD_VAR 0 2
49153: PUSH
49154: FOR_IN
49155: IFFALSE 49220
// begin weapons := AvailableWeaponList ( k ) ;
49157: LD_ADDR_VAR 0 9
49161: PUSH
49162: LD_VAR 0 6
49166: PPUSH
49167: CALL_OW 478
49171: ST_TO_ADDR
// if not weapons then
49172: LD_VAR 0 9
49176: NOT
49177: IFFALSE 49181
// continue ;
49179: GO 49154
// if weapon in weapons then
49181: LD_VAR 0 8
49185: PUSH
49186: LD_VAR 0 9
49190: IN
49191: IFFALSE 49218
// begin result := [ i , weapon ] ;
49193: LD_ADDR_VAR 0 3
49197: PUSH
49198: LD_VAR 0 4
49202: PUSH
49203: LD_VAR 0 8
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: ST_TO_ADDR
// exit ;
49212: POP
49213: POP
49214: POP
49215: POP
49216: GO 49226
// end ; end ;
49218: GO 49154
49220: POP
49221: POP
// end ;
49222: GO 49040
49224: POP
49225: POP
// end ;
49226: LD_VAR 0 3
49230: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49231: LD_INT 0
49233: PPUSH
// if not side or side > 8 then
49234: LD_VAR 0 3
49238: NOT
49239: IFTRUE 49251
49241: PUSH
49242: LD_VAR 0 3
49246: PUSH
49247: LD_INT 8
49249: GREATER
49250: OR
49251: IFFALSE 49255
// exit ;
49253: GO 49314
// if not range then
49255: LD_VAR 0 4
49259: NOT
49260: IFFALSE 49271
// range := - 12 ;
49262: LD_ADDR_VAR 0 4
49266: PUSH
49267: LD_INT 12
49269: NEG
49270: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49271: LD_VAR 0 1
49275: PPUSH
49276: LD_VAR 0 2
49280: PPUSH
49281: LD_VAR 0 3
49285: PPUSH
49286: LD_VAR 0 4
49290: PPUSH
49291: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49295: LD_VAR 0 1
49299: PPUSH
49300: LD_VAR 0 2
49304: PPUSH
49305: LD_VAR 0 3
49309: PPUSH
49310: CALL_OW 331
// end ;
49314: LD_VAR 0 5
49318: RET
// export function Video ( mode ) ; begin
49319: LD_INT 0
49321: PPUSH
// ingame_video = mode ;
49322: LD_ADDR_OWVAR 52
49326: PUSH
49327: LD_VAR 0 1
49331: ST_TO_ADDR
// interface_hidden = mode ;
49332: LD_ADDR_OWVAR 54
49336: PUSH
49337: LD_VAR 0 1
49341: ST_TO_ADDR
// end ;
49342: LD_VAR 0 2
49346: RET
// export function Join ( array , element ) ; begin
49347: LD_INT 0
49349: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49350: LD_ADDR_VAR 0 3
49354: PUSH
49355: LD_VAR 0 1
49359: PPUSH
49360: LD_VAR 0 1
49364: PUSH
49365: LD_INT 1
49367: PLUS
49368: PPUSH
49369: LD_VAR 0 2
49373: PPUSH
49374: CALL_OW 1
49378: ST_TO_ADDR
// end ;
49379: LD_VAR 0 3
49383: RET
// export function JoinUnion ( array , element ) ; begin
49384: LD_INT 0
49386: PPUSH
// result := array union element ;
49387: LD_ADDR_VAR 0 3
49391: PUSH
49392: LD_VAR 0 1
49396: PUSH
49397: LD_VAR 0 2
49401: UNION
49402: ST_TO_ADDR
// end ;
49403: LD_VAR 0 3
49407: RET
// export function GetBehemoths ( side ) ; begin
49408: LD_INT 0
49410: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
49411: LD_ADDR_VAR 0 2
49415: PUSH
49416: LD_INT 22
49418: PUSH
49419: LD_VAR 0 1
49423: PUSH
49424: EMPTY
49425: LIST
49426: LIST
49427: PUSH
49428: LD_INT 31
49430: PUSH
49431: LD_INT 25
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: PPUSH
49442: CALL_OW 69
49446: ST_TO_ADDR
// end ;
49447: LD_VAR 0 2
49451: RET
// export function Shuffle ( array ) ; var i , index ; begin
49452: LD_INT 0
49454: PPUSH
49455: PPUSH
49456: PPUSH
// result := [ ] ;
49457: LD_ADDR_VAR 0 2
49461: PUSH
49462: EMPTY
49463: ST_TO_ADDR
// if not array then
49464: LD_VAR 0 1
49468: NOT
49469: IFFALSE 49473
// exit ;
49471: GO 49572
// Randomize ;
49473: CALL_OW 10
// for i = array downto 1 do
49477: LD_ADDR_VAR 0 3
49481: PUSH
49482: DOUBLE
49483: LD_VAR 0 1
49487: INC
49488: ST_TO_ADDR
49489: LD_INT 1
49491: PUSH
49492: FOR_DOWNTO
49493: IFFALSE 49570
// begin index := rand ( 1 , array ) ;
49495: LD_ADDR_VAR 0 4
49499: PUSH
49500: LD_INT 1
49502: PPUSH
49503: LD_VAR 0 1
49507: PPUSH
49508: CALL_OW 12
49512: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49513: LD_ADDR_VAR 0 2
49517: PUSH
49518: LD_VAR 0 2
49522: PPUSH
49523: LD_VAR 0 2
49527: PUSH
49528: LD_INT 1
49530: PLUS
49531: PPUSH
49532: LD_VAR 0 1
49536: PUSH
49537: LD_VAR 0 4
49541: ARRAY
49542: PPUSH
49543: CALL_OW 2
49547: ST_TO_ADDR
// array := Delete ( array , index ) ;
49548: LD_ADDR_VAR 0 1
49552: PUSH
49553: LD_VAR 0 1
49557: PPUSH
49558: LD_VAR 0 4
49562: PPUSH
49563: CALL_OW 3
49567: ST_TO_ADDR
// end ;
49568: GO 49492
49570: POP
49571: POP
// end ;
49572: LD_VAR 0 2
49576: RET
// export function GetBaseMaterials ( base ) ; begin
49577: LD_INT 0
49579: PPUSH
// result := [ 0 , 0 , 0 ] ;
49580: LD_ADDR_VAR 0 2
49584: PUSH
49585: LD_INT 0
49587: PUSH
49588: LD_INT 0
49590: PUSH
49591: LD_INT 0
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: LIST
49598: ST_TO_ADDR
// if not base then
49599: LD_VAR 0 1
49603: NOT
49604: IFFALSE 49608
// exit ;
49606: GO 49657
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49608: LD_ADDR_VAR 0 2
49612: PUSH
49613: LD_VAR 0 1
49617: PPUSH
49618: LD_INT 1
49620: PPUSH
49621: CALL_OW 275
49625: PUSH
49626: LD_VAR 0 1
49630: PPUSH
49631: LD_INT 2
49633: PPUSH
49634: CALL_OW 275
49638: PUSH
49639: LD_VAR 0 1
49643: PPUSH
49644: LD_INT 3
49646: PPUSH
49647: CALL_OW 275
49651: PUSH
49652: EMPTY
49653: LIST
49654: LIST
49655: LIST
49656: ST_TO_ADDR
// end ;
49657: LD_VAR 0 2
49661: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49662: LD_INT 0
49664: PPUSH
49665: PPUSH
// result := array ;
49666: LD_ADDR_VAR 0 3
49670: PUSH
49671: LD_VAR 0 1
49675: ST_TO_ADDR
// if size >= result then
49676: LD_VAR 0 2
49680: PUSH
49681: LD_VAR 0 3
49685: GREATEREQUAL
49686: IFFALSE 49690
// exit ;
49688: GO 49740
// if size then
49690: LD_VAR 0 2
49694: IFFALSE 49740
// for i := array downto size do
49696: LD_ADDR_VAR 0 4
49700: PUSH
49701: DOUBLE
49702: LD_VAR 0 1
49706: INC
49707: ST_TO_ADDR
49708: LD_VAR 0 2
49712: PUSH
49713: FOR_DOWNTO
49714: IFFALSE 49738
// result := Delete ( result , result ) ;
49716: LD_ADDR_VAR 0 3
49720: PUSH
49721: LD_VAR 0 3
49725: PPUSH
49726: LD_VAR 0 3
49730: PPUSH
49731: CALL_OW 3
49735: ST_TO_ADDR
49736: GO 49713
49738: POP
49739: POP
// end ;
49740: LD_VAR 0 3
49744: RET
// export function ComExit ( unit ) ; var tmp ; begin
49745: LD_INT 0
49747: PPUSH
49748: PPUSH
// if not IsInUnit ( unit ) then
49749: LD_VAR 0 1
49753: PPUSH
49754: CALL_OW 310
49758: NOT
49759: IFFALSE 49763
// exit ;
49761: GO 49823
// tmp := IsInUnit ( unit ) ;
49763: LD_ADDR_VAR 0 3
49767: PUSH
49768: LD_VAR 0 1
49772: PPUSH
49773: CALL_OW 310
49777: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49778: LD_VAR 0 3
49782: PPUSH
49783: CALL_OW 247
49787: PUSH
49788: LD_INT 2
49790: EQUAL
49791: IFFALSE 49804
// ComExitVehicle ( unit ) else
49793: LD_VAR 0 1
49797: PPUSH
49798: CALL_OW 121
49802: GO 49813
// ComExitBuilding ( unit ) ;
49804: LD_VAR 0 1
49808: PPUSH
49809: CALL_OW 122
// result := tmp ;
49813: LD_ADDR_VAR 0 2
49817: PUSH
49818: LD_VAR 0 3
49822: ST_TO_ADDR
// end ;
49823: LD_VAR 0 2
49827: RET
// export function ComExitAll ( units ) ; var i ; begin
49828: LD_INT 0
49830: PPUSH
49831: PPUSH
// if not units then
49832: LD_VAR 0 1
49836: NOT
49837: IFFALSE 49841
// exit ;
49839: GO 49867
// for i in units do
49841: LD_ADDR_VAR 0 3
49845: PUSH
49846: LD_VAR 0 1
49850: PUSH
49851: FOR_IN
49852: IFFALSE 49865
// ComExit ( i ) ;
49854: LD_VAR 0 3
49858: PPUSH
49859: CALL 49745 0 1
49863: GO 49851
49865: POP
49866: POP
// end ;
49867: LD_VAR 0 2
49871: RET
// export function ResetHc ; begin
49872: LD_INT 0
49874: PPUSH
// InitHc ;
49875: CALL_OW 19
// hc_importance := 0 ;
49879: LD_ADDR_OWVAR 32
49883: PUSH
49884: LD_INT 0
49886: ST_TO_ADDR
// end ;
49887: LD_VAR 0 1
49891: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49892: LD_INT 0
49894: PPUSH
49895: PPUSH
49896: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49897: LD_ADDR_VAR 0 6
49901: PUSH
49902: LD_VAR 0 1
49906: PUSH
49907: LD_VAR 0 3
49911: PLUS
49912: PUSH
49913: LD_INT 2
49915: DIV
49916: ST_TO_ADDR
// if _x < 0 then
49917: LD_VAR 0 6
49921: PUSH
49922: LD_INT 0
49924: LESS
49925: IFFALSE 49942
// _x := _x * - 1 ;
49927: LD_ADDR_VAR 0 6
49931: PUSH
49932: LD_VAR 0 6
49936: PUSH
49937: LD_INT 1
49939: NEG
49940: MUL
49941: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49942: LD_ADDR_VAR 0 7
49946: PUSH
49947: LD_VAR 0 2
49951: PUSH
49952: LD_VAR 0 4
49956: PLUS
49957: PUSH
49958: LD_INT 2
49960: DIV
49961: ST_TO_ADDR
// if _y < 0 then
49962: LD_VAR 0 7
49966: PUSH
49967: LD_INT 0
49969: LESS
49970: IFFALSE 49987
// _y := _y * - 1 ;
49972: LD_ADDR_VAR 0 7
49976: PUSH
49977: LD_VAR 0 7
49981: PUSH
49982: LD_INT 1
49984: NEG
49985: MUL
49986: ST_TO_ADDR
// result := [ _x , _y ] ;
49987: LD_ADDR_VAR 0 5
49991: PUSH
49992: LD_VAR 0 6
49996: PUSH
49997: LD_VAR 0 7
50001: PUSH
50002: EMPTY
50003: LIST
50004: LIST
50005: ST_TO_ADDR
// end ;
50006: LD_VAR 0 5
50010: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50011: LD_INT 0
50013: PPUSH
50014: PPUSH
50015: PPUSH
50016: PPUSH
// task := GetTaskList ( unit ) ;
50017: LD_ADDR_VAR 0 7
50021: PUSH
50022: LD_VAR 0 1
50026: PPUSH
50027: CALL_OW 437
50031: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50032: LD_VAR 0 7
50036: NOT
50037: IFFALSE 50056
50039: PUSH
50040: LD_VAR 0 1
50044: PPUSH
50045: LD_VAR 0 2
50049: PPUSH
50050: CALL_OW 308
50054: NOT
50055: AND
50056: IFFALSE 50060
// exit ;
50058: GO 50178
// if IsInArea ( unit , area ) then
50060: LD_VAR 0 1
50064: PPUSH
50065: LD_VAR 0 2
50069: PPUSH
50070: CALL_OW 308
50074: IFFALSE 50092
// begin ComMoveToArea ( unit , goAway ) ;
50076: LD_VAR 0 1
50080: PPUSH
50081: LD_VAR 0 3
50085: PPUSH
50086: CALL_OW 113
// exit ;
50090: GO 50178
// end ; if task [ 1 ] [ 1 ] <> M then
50092: LD_VAR 0 7
50096: PUSH
50097: LD_INT 1
50099: ARRAY
50100: PUSH
50101: LD_INT 1
50103: ARRAY
50104: PUSH
50105: LD_STRING M
50107: NONEQUAL
50108: IFFALSE 50112
// exit ;
50110: GO 50178
// x := task [ 1 ] [ 2 ] ;
50112: LD_ADDR_VAR 0 5
50116: PUSH
50117: LD_VAR 0 7
50121: PUSH
50122: LD_INT 1
50124: ARRAY
50125: PUSH
50126: LD_INT 2
50128: ARRAY
50129: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50130: LD_ADDR_VAR 0 6
50134: PUSH
50135: LD_VAR 0 7
50139: PUSH
50140: LD_INT 1
50142: ARRAY
50143: PUSH
50144: LD_INT 3
50146: ARRAY
50147: ST_TO_ADDR
// if InArea ( x , y , area ) then
50148: LD_VAR 0 5
50152: PPUSH
50153: LD_VAR 0 6
50157: PPUSH
50158: LD_VAR 0 2
50162: PPUSH
50163: CALL_OW 309
50167: IFFALSE 50178
// ComStop ( unit ) ;
50169: LD_VAR 0 1
50173: PPUSH
50174: CALL_OW 141
// end ;
50178: LD_VAR 0 4
50182: RET
// export function Abs ( value ) ; begin
50183: LD_INT 0
50185: PPUSH
// result := value ;
50186: LD_ADDR_VAR 0 2
50190: PUSH
50191: LD_VAR 0 1
50195: ST_TO_ADDR
// if value < 0 then
50196: LD_VAR 0 1
50200: PUSH
50201: LD_INT 0
50203: LESS
50204: IFFALSE 50221
// result := value * - 1 ;
50206: LD_ADDR_VAR 0 2
50210: PUSH
50211: LD_VAR 0 1
50215: PUSH
50216: LD_INT 1
50218: NEG
50219: MUL
50220: ST_TO_ADDR
// end ;
50221: LD_VAR 0 2
50225: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
50226: LD_INT 0
50228: PPUSH
50229: PPUSH
50230: PPUSH
50231: PPUSH
50232: PPUSH
50233: PPUSH
50234: PPUSH
50235: PPUSH
// if not unit or not building then
50236: LD_VAR 0 1
50240: NOT
50241: IFTRUE 50250
50243: PUSH
50244: LD_VAR 0 2
50248: NOT
50249: OR
50250: IFFALSE 50254
// exit ;
50252: GO 50482
// x := GetX ( building ) ;
50254: LD_ADDR_VAR 0 4
50258: PUSH
50259: LD_VAR 0 2
50263: PPUSH
50264: CALL_OW 250
50268: ST_TO_ADDR
// y := GetY ( building ) ;
50269: LD_ADDR_VAR 0 6
50273: PUSH
50274: LD_VAR 0 2
50278: PPUSH
50279: CALL_OW 251
50283: ST_TO_ADDR
// d := GetDir ( building ) ;
50284: LD_ADDR_VAR 0 8
50288: PUSH
50289: LD_VAR 0 2
50293: PPUSH
50294: CALL_OW 254
50298: ST_TO_ADDR
// r := 4 ;
50299: LD_ADDR_VAR 0 9
50303: PUSH
50304: LD_INT 4
50306: ST_TO_ADDR
// for i := 1 to 5 do
50307: LD_ADDR_VAR 0 10
50311: PUSH
50312: DOUBLE
50313: LD_INT 1
50315: DEC
50316: ST_TO_ADDR
50317: LD_INT 5
50319: PUSH
50320: FOR_TO
50321: IFFALSE 50480
// begin _x := ShiftX ( x , d , r + i ) ;
50323: LD_ADDR_VAR 0 5
50327: PUSH
50328: LD_VAR 0 4
50332: PPUSH
50333: LD_VAR 0 8
50337: PPUSH
50338: LD_VAR 0 9
50342: PUSH
50343: LD_VAR 0 10
50347: PLUS
50348: PPUSH
50349: CALL_OW 272
50353: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
50354: LD_ADDR_VAR 0 7
50358: PUSH
50359: LD_VAR 0 6
50363: PPUSH
50364: LD_VAR 0 8
50368: PPUSH
50369: LD_VAR 0 9
50373: PUSH
50374: LD_VAR 0 10
50378: PLUS
50379: PPUSH
50380: CALL_OW 273
50384: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
50385: LD_VAR 0 5
50389: PPUSH
50390: LD_VAR 0 7
50394: PPUSH
50395: CALL_OW 488
50399: IFFALSE 50434
50401: PUSH
50402: LD_VAR 0 5
50406: PPUSH
50407: LD_VAR 0 7
50411: PPUSH
50412: CALL_OW 428
50416: PPUSH
50417: CALL_OW 247
50421: PUSH
50422: LD_INT 3
50424: PUSH
50425: LD_INT 2
50427: PUSH
50428: EMPTY
50429: LIST
50430: LIST
50431: IN
50432: NOT
50433: AND
50434: IFFALSE 50478
// begin ComMoveXY ( unit , _x , _y ) ;
50436: LD_VAR 0 1
50440: PPUSH
50441: LD_VAR 0 5
50445: PPUSH
50446: LD_VAR 0 7
50450: PPUSH
50451: CALL_OW 111
// result := [ _x , _y ] ;
50455: LD_ADDR_VAR 0 3
50459: PUSH
50460: LD_VAR 0 5
50464: PUSH
50465: LD_VAR 0 7
50469: PUSH
50470: EMPTY
50471: LIST
50472: LIST
50473: ST_TO_ADDR
// exit ;
50474: POP
50475: POP
50476: GO 50482
// end ; end ;
50478: GO 50320
50480: POP
50481: POP
// end ;
50482: LD_VAR 0 3
50486: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
50487: LD_INT 0
50489: PPUSH
50490: PPUSH
50491: PPUSH
// result := 0 ;
50492: LD_ADDR_VAR 0 3
50496: PUSH
50497: LD_INT 0
50499: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
50500: LD_VAR 0 1
50504: PUSH
50505: LD_INT 0
50507: LESS
50508: IFTRUE 50520
50510: PUSH
50511: LD_VAR 0 1
50515: PUSH
50516: LD_INT 8
50518: GREATER
50519: OR
50520: IFTRUE 50532
50522: PUSH
50523: LD_VAR 0 2
50527: PUSH
50528: LD_INT 0
50530: LESS
50531: OR
50532: IFTRUE 50544
50534: PUSH
50535: LD_VAR 0 2
50539: PUSH
50540: LD_INT 8
50542: GREATER
50543: OR
50544: IFFALSE 50548
// exit ;
50546: GO 50623
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
50548: LD_ADDR_VAR 0 4
50552: PUSH
50553: LD_INT 22
50555: PUSH
50556: LD_VAR 0 2
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PPUSH
50565: CALL_OW 69
50569: PUSH
50570: FOR_IN
50571: IFFALSE 50621
// begin un := UnitShoot ( i ) ;
50573: LD_ADDR_VAR 0 5
50577: PUSH
50578: LD_VAR 0 4
50582: PPUSH
50583: CALL_OW 504
50587: ST_TO_ADDR
// if GetSide ( un ) = side1 then
50588: LD_VAR 0 5
50592: PPUSH
50593: CALL_OW 255
50597: PUSH
50598: LD_VAR 0 1
50602: EQUAL
50603: IFFALSE 50619
// begin result := un ;
50605: LD_ADDR_VAR 0 3
50609: PUSH
50610: LD_VAR 0 5
50614: ST_TO_ADDR
// exit ;
50615: POP
50616: POP
50617: GO 50623
// end ; end ;
50619: GO 50570
50621: POP
50622: POP
// end ;
50623: LD_VAR 0 3
50627: RET
// export function GetCargoBay ( units ) ; begin
50628: LD_INT 0
50630: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
50631: LD_ADDR_VAR 0 2
50635: PUSH
50636: LD_VAR 0 1
50640: PPUSH
50641: LD_INT 2
50643: PUSH
50644: LD_INT 34
50646: PUSH
50647: LD_INT 12
50649: PUSH
50650: EMPTY
50651: LIST
50652: LIST
50653: PUSH
50654: LD_INT 34
50656: PUSH
50657: LD_INT 51
50659: PUSH
50660: EMPTY
50661: LIST
50662: LIST
50663: PUSH
50664: LD_INT 34
50666: PUSH
50667: LD_INT 32
50669: PUSH
50670: EMPTY
50671: LIST
50672: LIST
50673: PUSH
50674: LD_INT 34
50676: PUSH
50677: LD_INT 89
50679: PUSH
50680: EMPTY
50681: LIST
50682: LIST
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: LIST
50688: LIST
50689: LIST
50690: PPUSH
50691: CALL_OW 72
50695: ST_TO_ADDR
// end ;
50696: LD_VAR 0 2
50700: RET
// export function Negate ( value ) ; begin
50701: LD_INT 0
50703: PPUSH
// result := not value ;
50704: LD_ADDR_VAR 0 2
50708: PUSH
50709: LD_VAR 0 1
50713: NOT
50714: ST_TO_ADDR
// end ;
50715: LD_VAR 0 2
50719: RET
// export function Inc ( value ) ; begin
50720: LD_INT 0
50722: PPUSH
// result := value + 1 ;
50723: LD_ADDR_VAR 0 2
50727: PUSH
50728: LD_VAR 0 1
50732: PUSH
50733: LD_INT 1
50735: PLUS
50736: ST_TO_ADDR
// end ;
50737: LD_VAR 0 2
50741: RET
// export function Dec ( value ) ; begin
50742: LD_INT 0
50744: PPUSH
// result := value - 1 ;
50745: LD_ADDR_VAR 0 2
50749: PUSH
50750: LD_VAR 0 1
50754: PUSH
50755: LD_INT 1
50757: MINUS
50758: ST_TO_ADDR
// end ;
50759: LD_VAR 0 2
50763: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
50764: LD_INT 0
50766: PPUSH
50767: PPUSH
50768: PPUSH
50769: PPUSH
50770: PPUSH
50771: PPUSH
50772: PPUSH
50773: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
50774: LD_VAR 0 1
50778: PPUSH
50779: LD_VAR 0 2
50783: PPUSH
50784: CALL_OW 488
50788: NOT
50789: IFTRUE 50808
50791: PUSH
50792: LD_VAR 0 3
50796: PPUSH
50797: LD_VAR 0 4
50801: PPUSH
50802: CALL_OW 488
50806: NOT
50807: OR
50808: IFFALSE 50821
// begin result := - 1 ;
50810: LD_ADDR_VAR 0 5
50814: PUSH
50815: LD_INT 1
50817: NEG
50818: ST_TO_ADDR
// exit ;
50819: GO 51056
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
50821: LD_ADDR_VAR 0 12
50825: PUSH
50826: LD_VAR 0 1
50830: PPUSH
50831: LD_VAR 0 2
50835: PPUSH
50836: LD_VAR 0 3
50840: PPUSH
50841: LD_VAR 0 4
50845: PPUSH
50846: CALL 49892 0 4
50850: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
50851: LD_ADDR_VAR 0 11
50855: PUSH
50856: LD_VAR 0 1
50860: PPUSH
50861: LD_VAR 0 2
50865: PPUSH
50866: LD_VAR 0 12
50870: PUSH
50871: LD_INT 1
50873: ARRAY
50874: PPUSH
50875: LD_VAR 0 12
50879: PUSH
50880: LD_INT 2
50882: ARRAY
50883: PPUSH
50884: CALL_OW 298
50888: ST_TO_ADDR
// distance := 9999 ;
50889: LD_ADDR_VAR 0 10
50893: PUSH
50894: LD_INT 9999
50896: ST_TO_ADDR
// for i := 0 to 5 do
50897: LD_ADDR_VAR 0 6
50901: PUSH
50902: DOUBLE
50903: LD_INT 0
50905: DEC
50906: ST_TO_ADDR
50907: LD_INT 5
50909: PUSH
50910: FOR_TO
50911: IFFALSE 51054
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50913: LD_ADDR_VAR 0 7
50917: PUSH
50918: LD_VAR 0 1
50922: PPUSH
50923: LD_VAR 0 6
50927: PPUSH
50928: LD_VAR 0 11
50932: PPUSH
50933: CALL_OW 272
50937: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50938: LD_ADDR_VAR 0 8
50942: PUSH
50943: LD_VAR 0 2
50947: PPUSH
50948: LD_VAR 0 6
50952: PPUSH
50953: LD_VAR 0 11
50957: PPUSH
50958: CALL_OW 273
50962: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50963: LD_VAR 0 7
50967: PPUSH
50968: LD_VAR 0 8
50972: PPUSH
50973: CALL_OW 488
50977: NOT
50978: IFFALSE 50982
// continue ;
50980: GO 50910
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50982: LD_ADDR_VAR 0 9
50986: PUSH
50987: LD_VAR 0 12
50991: PUSH
50992: LD_INT 1
50994: ARRAY
50995: PPUSH
50996: LD_VAR 0 12
51000: PUSH
51001: LD_INT 2
51003: ARRAY
51004: PPUSH
51005: LD_VAR 0 7
51009: PPUSH
51010: LD_VAR 0 8
51014: PPUSH
51015: CALL_OW 298
51019: ST_TO_ADDR
// if tmp < distance then
51020: LD_VAR 0 9
51024: PUSH
51025: LD_VAR 0 10
51029: LESS
51030: IFFALSE 51052
// begin result := i ;
51032: LD_ADDR_VAR 0 5
51036: PUSH
51037: LD_VAR 0 6
51041: ST_TO_ADDR
// distance := tmp ;
51042: LD_ADDR_VAR 0 10
51046: PUSH
51047: LD_VAR 0 9
51051: ST_TO_ADDR
// end ; end ;
51052: GO 50910
51054: POP
51055: POP
// end ;
51056: LD_VAR 0 5
51060: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51061: LD_INT 0
51063: PPUSH
51064: PPUSH
// if not driver or not IsInUnit ( driver ) then
51065: LD_VAR 0 1
51069: NOT
51070: IFTRUE 51084
51072: PUSH
51073: LD_VAR 0 1
51077: PPUSH
51078: CALL_OW 310
51082: NOT
51083: OR
51084: IFFALSE 51088
// exit ;
51086: GO 51178
// vehicle := IsInUnit ( driver ) ;
51088: LD_ADDR_VAR 0 3
51092: PUSH
51093: LD_VAR 0 1
51097: PPUSH
51098: CALL_OW 310
51102: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51103: LD_VAR 0 1
51107: PPUSH
51108: LD_STRING \
51110: PUSH
51111: LD_INT 0
51113: PUSH
51114: LD_INT 0
51116: PUSH
51117: LD_INT 0
51119: PUSH
51120: LD_INT 0
51122: PUSH
51123: LD_INT 0
51125: PUSH
51126: LD_INT 0
51128: PUSH
51129: EMPTY
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: PUSH
51138: LD_STRING E
51140: PUSH
51141: LD_INT 0
51143: PUSH
51144: LD_INT 0
51146: PUSH
51147: LD_VAR 0 3
51151: PUSH
51152: LD_INT 0
51154: PUSH
51155: LD_INT 0
51157: PUSH
51158: LD_INT 0
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: LIST
51165: LIST
51166: LIST
51167: LIST
51168: LIST
51169: PUSH
51170: EMPTY
51171: LIST
51172: LIST
51173: PPUSH
51174: CALL_OW 446
// end ;
51178: LD_VAR 0 2
51182: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51183: LD_INT 0
51185: PPUSH
51186: PPUSH
// if not driver or not IsInUnit ( driver ) then
51187: LD_VAR 0 1
51191: NOT
51192: IFTRUE 51206
51194: PUSH
51195: LD_VAR 0 1
51199: PPUSH
51200: CALL_OW 310
51204: NOT
51205: OR
51206: IFFALSE 51210
// exit ;
51208: GO 51300
// vehicle := IsInUnit ( driver ) ;
51210: LD_ADDR_VAR 0 3
51214: PUSH
51215: LD_VAR 0 1
51219: PPUSH
51220: CALL_OW 310
51224: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51225: LD_VAR 0 1
51229: PPUSH
51230: LD_STRING \
51232: PUSH
51233: LD_INT 0
51235: PUSH
51236: LD_INT 0
51238: PUSH
51239: LD_INT 0
51241: PUSH
51242: LD_INT 0
51244: PUSH
51245: LD_INT 0
51247: PUSH
51248: LD_INT 0
51250: PUSH
51251: EMPTY
51252: LIST
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: LIST
51258: LIST
51259: PUSH
51260: LD_STRING E
51262: PUSH
51263: LD_INT 0
51265: PUSH
51266: LD_INT 0
51268: PUSH
51269: LD_VAR 0 3
51273: PUSH
51274: LD_INT 0
51276: PUSH
51277: LD_INT 0
51279: PUSH
51280: LD_INT 0
51282: PUSH
51283: EMPTY
51284: LIST
51285: LIST
51286: LIST
51287: LIST
51288: LIST
51289: LIST
51290: LIST
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PPUSH
51296: CALL_OW 447
// end ;
51300: LD_VAR 0 2
51304: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
51305: LD_INT 0
51307: PPUSH
51308: PPUSH
51309: PPUSH
// tmp := [ ] ;
51310: LD_ADDR_VAR 0 5
51314: PUSH
51315: EMPTY
51316: ST_TO_ADDR
// for i in units do
51317: LD_ADDR_VAR 0 4
51321: PUSH
51322: LD_VAR 0 1
51326: PUSH
51327: FOR_IN
51328: IFFALSE 51366
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
51330: LD_ADDR_VAR 0 5
51334: PUSH
51335: LD_VAR 0 5
51339: PPUSH
51340: LD_VAR 0 5
51344: PUSH
51345: LD_INT 1
51347: PLUS
51348: PPUSH
51349: LD_VAR 0 4
51353: PPUSH
51354: CALL_OW 256
51358: PPUSH
51359: CALL_OW 2
51363: ST_TO_ADDR
51364: GO 51327
51366: POP
51367: POP
// if not tmp then
51368: LD_VAR 0 5
51372: NOT
51373: IFFALSE 51377
// exit ;
51375: GO 51425
// if asc then
51377: LD_VAR 0 2
51381: IFFALSE 51405
// result := SortListByListAsc ( units , tmp ) else
51383: LD_ADDR_VAR 0 3
51387: PUSH
51388: LD_VAR 0 1
51392: PPUSH
51393: LD_VAR 0 5
51397: PPUSH
51398: CALL_OW 76
51402: ST_TO_ADDR
51403: GO 51425
// result := SortListByListDesc ( units , tmp ) ;
51405: LD_ADDR_VAR 0 3
51409: PUSH
51410: LD_VAR 0 1
51414: PPUSH
51415: LD_VAR 0 5
51419: PPUSH
51420: CALL_OW 77
51424: ST_TO_ADDR
// end ;
51425: LD_VAR 0 3
51429: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
51430: LD_INT 0
51432: PPUSH
51433: PPUSH
// task := GetTaskList ( mech ) ;
51434: LD_ADDR_VAR 0 4
51438: PUSH
51439: LD_VAR 0 1
51443: PPUSH
51444: CALL_OW 437
51448: ST_TO_ADDR
// if not task then
51449: LD_VAR 0 4
51453: NOT
51454: IFFALSE 51458
// exit ;
51456: GO 51502
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
51458: LD_ADDR_VAR 0 3
51462: PUSH
51463: LD_VAR 0 4
51467: PUSH
51468: LD_INT 1
51470: ARRAY
51471: PUSH
51472: LD_INT 1
51474: ARRAY
51475: PUSH
51476: LD_STRING r
51478: EQUAL
51479: IFFALSE 51501
51481: PUSH
51482: LD_VAR 0 4
51486: PUSH
51487: LD_INT 1
51489: ARRAY
51490: PUSH
51491: LD_INT 4
51493: ARRAY
51494: PUSH
51495: LD_VAR 0 2
51499: EQUAL
51500: AND
51501: ST_TO_ADDR
// end ;
51502: LD_VAR 0 3
51506: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
51507: LD_INT 0
51509: PPUSH
// SetDir ( unit , d ) ;
51510: LD_VAR 0 1
51514: PPUSH
51515: LD_VAR 0 4
51519: PPUSH
51520: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
51524: LD_ADDR_VAR 0 6
51528: PUSH
51529: LD_VAR 0 1
51533: PPUSH
51534: LD_VAR 0 2
51538: PPUSH
51539: LD_VAR 0 3
51543: PPUSH
51544: LD_VAR 0 5
51548: PPUSH
51549: CALL_OW 48
51553: ST_TO_ADDR
// end ;
51554: LD_VAR 0 6
51558: RET
// export function ToNaturalNumber ( number ) ; begin
51559: LD_INT 0
51561: PPUSH
// result := number div 1 ;
51562: LD_ADDR_VAR 0 2
51566: PUSH
51567: LD_VAR 0 1
51571: PUSH
51572: LD_INT 1
51574: DIV
51575: ST_TO_ADDR
// if number < 0 then
51576: LD_VAR 0 1
51580: PUSH
51581: LD_INT 0
51583: LESS
51584: IFFALSE 51594
// result := 0 ;
51586: LD_ADDR_VAR 0 2
51590: PUSH
51591: LD_INT 0
51593: ST_TO_ADDR
// end ;
51594: LD_VAR 0 2
51598: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
51599: LD_INT 0
51601: PPUSH
51602: PPUSH
51603: PPUSH
// if not buildings then
51604: LD_VAR 0 1
51608: NOT
51609: IFFALSE 51613
// exit ;
51611: GO 51728
// tmp := [ ] ;
51613: LD_ADDR_VAR 0 5
51617: PUSH
51618: EMPTY
51619: ST_TO_ADDR
// for b in buildings do
51620: LD_ADDR_VAR 0 4
51624: PUSH
51625: LD_VAR 0 1
51629: PUSH
51630: FOR_IN
51631: IFFALSE 51669
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
51633: LD_ADDR_VAR 0 5
51637: PUSH
51638: LD_VAR 0 5
51642: PPUSH
51643: LD_VAR 0 5
51647: PUSH
51648: LD_INT 1
51650: PLUS
51651: PPUSH
51652: LD_VAR 0 4
51656: PPUSH
51657: CALL_OW 266
51661: PPUSH
51662: CALL_OW 1
51666: ST_TO_ADDR
51667: GO 51630
51669: POP
51670: POP
// if not tmp then
51671: LD_VAR 0 5
51675: NOT
51676: IFFALSE 51680
// exit ;
51678: GO 51728
// if asc then
51680: LD_VAR 0 2
51684: IFFALSE 51708
// result := SortListByListAsc ( buildings , tmp ) else
51686: LD_ADDR_VAR 0 3
51690: PUSH
51691: LD_VAR 0 1
51695: PPUSH
51696: LD_VAR 0 5
51700: PPUSH
51701: CALL_OW 76
51705: ST_TO_ADDR
51706: GO 51728
// result := SortListByListDesc ( buildings , tmp ) ;
51708: LD_ADDR_VAR 0 3
51712: PUSH
51713: LD_VAR 0 1
51717: PPUSH
51718: LD_VAR 0 5
51722: PPUSH
51723: CALL_OW 77
51727: ST_TO_ADDR
// end ;
51728: LD_VAR 0 3
51732: RET
// export function SortByClass ( units , class ) ; var un ; begin
51733: LD_INT 0
51735: PPUSH
51736: PPUSH
// if not units or not class then
51737: LD_VAR 0 1
51741: NOT
51742: IFTRUE 51751
51744: PUSH
51745: LD_VAR 0 2
51749: NOT
51750: OR
51751: IFFALSE 51755
// exit ;
51753: GO 51850
// result := [ ] ;
51755: LD_ADDR_VAR 0 3
51759: PUSH
51760: EMPTY
51761: ST_TO_ADDR
// for un in units do
51762: LD_ADDR_VAR 0 4
51766: PUSH
51767: LD_VAR 0 1
51771: PUSH
51772: FOR_IN
51773: IFFALSE 51848
// if GetClass ( un ) = class then
51775: LD_VAR 0 4
51779: PPUSH
51780: CALL_OW 257
51784: PUSH
51785: LD_VAR 0 2
51789: EQUAL
51790: IFFALSE 51817
// result := Insert ( result , 1 , un ) else
51792: LD_ADDR_VAR 0 3
51796: PUSH
51797: LD_VAR 0 3
51801: PPUSH
51802: LD_INT 1
51804: PPUSH
51805: LD_VAR 0 4
51809: PPUSH
51810: CALL_OW 2
51814: ST_TO_ADDR
51815: GO 51846
// result := Replace ( result , result + 1 , un ) ;
51817: LD_ADDR_VAR 0 3
51821: PUSH
51822: LD_VAR 0 3
51826: PPUSH
51827: LD_VAR 0 3
51831: PUSH
51832: LD_INT 1
51834: PLUS
51835: PPUSH
51836: LD_VAR 0 4
51840: PPUSH
51841: CALL_OW 1
51845: ST_TO_ADDR
51846: GO 51772
51848: POP
51849: POP
// end ;
51850: LD_VAR 0 3
51854: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
51855: LD_INT 0
51857: PPUSH
51858: PPUSH
51859: PPUSH
51860: PPUSH
51861: PPUSH
51862: PPUSH
51863: PPUSH
// result := [ ] ;
51864: LD_ADDR_VAR 0 4
51868: PUSH
51869: EMPTY
51870: ST_TO_ADDR
// if x - r < 0 then
51871: LD_VAR 0 1
51875: PUSH
51876: LD_VAR 0 3
51880: MINUS
51881: PUSH
51882: LD_INT 0
51884: LESS
51885: IFFALSE 51897
// min_x := 0 else
51887: LD_ADDR_VAR 0 8
51891: PUSH
51892: LD_INT 0
51894: ST_TO_ADDR
51895: GO 51913
// min_x := x - r ;
51897: LD_ADDR_VAR 0 8
51901: PUSH
51902: LD_VAR 0 1
51906: PUSH
51907: LD_VAR 0 3
51911: MINUS
51912: ST_TO_ADDR
// if y - r < 0 then
51913: LD_VAR 0 2
51917: PUSH
51918: LD_VAR 0 3
51922: MINUS
51923: PUSH
51924: LD_INT 0
51926: LESS
51927: IFFALSE 51939
// min_y := 0 else
51929: LD_ADDR_VAR 0 7
51933: PUSH
51934: LD_INT 0
51936: ST_TO_ADDR
51937: GO 51955
// min_y := y - r ;
51939: LD_ADDR_VAR 0 7
51943: PUSH
51944: LD_VAR 0 2
51948: PUSH
51949: LD_VAR 0 3
51953: MINUS
51954: ST_TO_ADDR
// max_x := x + r ;
51955: LD_ADDR_VAR 0 9
51959: PUSH
51960: LD_VAR 0 1
51964: PUSH
51965: LD_VAR 0 3
51969: PLUS
51970: ST_TO_ADDR
// max_y := y + r ;
51971: LD_ADDR_VAR 0 10
51975: PUSH
51976: LD_VAR 0 2
51980: PUSH
51981: LD_VAR 0 3
51985: PLUS
51986: ST_TO_ADDR
// for _x = min_x to max_x do
51987: LD_ADDR_VAR 0 5
51991: PUSH
51992: DOUBLE
51993: LD_VAR 0 8
51997: DEC
51998: ST_TO_ADDR
51999: LD_VAR 0 9
52003: PUSH
52004: FOR_TO
52005: IFFALSE 52106
// for _y = min_y to max_y do
52007: LD_ADDR_VAR 0 6
52011: PUSH
52012: DOUBLE
52013: LD_VAR 0 7
52017: DEC
52018: ST_TO_ADDR
52019: LD_VAR 0 10
52023: PUSH
52024: FOR_TO
52025: IFFALSE 52102
// begin if not ValidHex ( _x , _y ) then
52027: LD_VAR 0 5
52031: PPUSH
52032: LD_VAR 0 6
52036: PPUSH
52037: CALL_OW 488
52041: NOT
52042: IFFALSE 52046
// continue ;
52044: GO 52024
// if GetResourceTypeXY ( _x , _y ) then
52046: LD_VAR 0 5
52050: PPUSH
52051: LD_VAR 0 6
52055: PPUSH
52056: CALL_OW 283
52060: IFFALSE 52100
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52062: LD_ADDR_VAR 0 4
52066: PUSH
52067: LD_VAR 0 4
52071: PPUSH
52072: LD_VAR 0 4
52076: PUSH
52077: LD_INT 1
52079: PLUS
52080: PPUSH
52081: LD_VAR 0 5
52085: PUSH
52086: LD_VAR 0 6
52090: PUSH
52091: EMPTY
52092: LIST
52093: LIST
52094: PPUSH
52095: CALL_OW 1
52099: ST_TO_ADDR
// end ;
52100: GO 52024
52102: POP
52103: POP
52104: GO 52004
52106: POP
52107: POP
// end ;
52108: LD_VAR 0 4
52112: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
52113: LD_INT 0
52115: PPUSH
52116: PPUSH
52117: PPUSH
52118: PPUSH
52119: PPUSH
52120: PPUSH
52121: PPUSH
52122: PPUSH
// if not units then
52123: LD_VAR 0 1
52127: NOT
52128: IFFALSE 52132
// exit ;
52130: GO 52664
// result := UnitFilter ( units , [ f_ok ] ) ;
52132: LD_ADDR_VAR 0 3
52136: PUSH
52137: LD_VAR 0 1
52141: PPUSH
52142: LD_INT 50
52144: PUSH
52145: EMPTY
52146: LIST
52147: PPUSH
52148: CALL_OW 72
52152: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52153: LD_ADDR_VAR 0 8
52157: PUSH
52158: LD_VAR 0 1
52162: PUSH
52163: LD_INT 1
52165: ARRAY
52166: PPUSH
52167: CALL_OW 255
52171: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
52172: LD_ADDR_VAR 0 10
52176: PUSH
52177: LD_INT 29
52179: PUSH
52180: LD_INT 91
52182: PUSH
52183: LD_INT 49
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: LIST
52190: ST_TO_ADDR
// if not result then
52191: LD_VAR 0 3
52195: NOT
52196: IFFALSE 52200
// exit ;
52198: GO 52664
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
52200: LD_ADDR_VAR 0 5
52204: PUSH
52205: LD_INT 81
52207: PUSH
52208: LD_VAR 0 8
52212: PUSH
52213: EMPTY
52214: LIST
52215: LIST
52216: PPUSH
52217: CALL_OW 69
52221: ST_TO_ADDR
// for i in result do
52222: LD_ADDR_VAR 0 4
52226: PUSH
52227: LD_VAR 0 3
52231: PUSH
52232: FOR_IN
52233: IFFALSE 52662
// begin tag := GetTag ( i ) + 1 ;
52235: LD_ADDR_VAR 0 9
52239: PUSH
52240: LD_VAR 0 4
52244: PPUSH
52245: CALL_OW 110
52249: PUSH
52250: LD_INT 1
52252: PLUS
52253: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
52254: LD_ADDR_VAR 0 7
52258: PUSH
52259: LD_VAR 0 4
52263: PPUSH
52264: CALL_OW 250
52268: PPUSH
52269: LD_VAR 0 4
52273: PPUSH
52274: CALL_OW 251
52278: PPUSH
52279: LD_INT 4
52281: PPUSH
52282: CALL 51855 0 3
52286: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
52287: LD_VAR 0 4
52291: PPUSH
52292: CALL_OW 247
52296: PUSH
52297: LD_INT 2
52299: EQUAL
52300: IFFALSE 52312
52302: PUSH
52303: LD_VAR 0 7
52307: PUSH
52308: LD_INT 2
52310: GREATER
52311: AND
52312: IFFALSE 52332
52314: PUSH
52315: LD_VAR 0 4
52319: PPUSH
52320: CALL_OW 264
52324: PUSH
52325: LD_VAR 0 10
52329: IN
52330: NOT
52331: AND
52332: IFFALSE 52371
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
52334: LD_VAR 0 4
52338: PPUSH
52339: LD_VAR 0 7
52343: PUSH
52344: LD_INT 1
52346: ARRAY
52347: PUSH
52348: LD_INT 1
52350: ARRAY
52351: PPUSH
52352: LD_VAR 0 7
52356: PUSH
52357: LD_INT 1
52359: ARRAY
52360: PUSH
52361: LD_INT 2
52363: ARRAY
52364: PPUSH
52365: CALL_OW 116
52369: GO 52660
// if path > tag then
52371: LD_VAR 0 2
52375: PUSH
52376: LD_VAR 0 9
52380: GREATER
52381: IFFALSE 52589
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
52383: LD_ADDR_VAR 0 6
52387: PUSH
52388: LD_VAR 0 5
52392: PPUSH
52393: LD_INT 91
52395: PUSH
52396: LD_VAR 0 4
52400: PUSH
52401: LD_INT 8
52403: PUSH
52404: EMPTY
52405: LIST
52406: LIST
52407: LIST
52408: PPUSH
52409: CALL_OW 72
52413: ST_TO_ADDR
// if nearEnemy then
52414: LD_VAR 0 6
52418: IFFALSE 52487
// begin if GetWeapon ( i ) = ru_time_lapser then
52420: LD_VAR 0 4
52424: PPUSH
52425: CALL_OW 264
52429: PUSH
52430: LD_INT 49
52432: EQUAL
52433: IFFALSE 52461
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
52435: LD_VAR 0 4
52439: PPUSH
52440: LD_VAR 0 6
52444: PPUSH
52445: LD_VAR 0 4
52449: PPUSH
52450: CALL_OW 74
52454: PPUSH
52455: CALL_OW 112
52459: GO 52485
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
52461: LD_VAR 0 4
52465: PPUSH
52466: LD_VAR 0 6
52470: PPUSH
52471: LD_VAR 0 4
52475: PPUSH
52476: CALL_OW 74
52480: PPUSH
52481: CALL 53745 0 2
// end else
52485: GO 52587
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
52487: LD_VAR 0 4
52491: PPUSH
52492: LD_VAR 0 2
52496: PUSH
52497: LD_VAR 0 9
52501: ARRAY
52502: PUSH
52503: LD_INT 1
52505: ARRAY
52506: PPUSH
52507: LD_VAR 0 2
52511: PUSH
52512: LD_VAR 0 9
52516: ARRAY
52517: PUSH
52518: LD_INT 2
52520: ARRAY
52521: PPUSH
52522: CALL_OW 297
52526: PUSH
52527: LD_INT 6
52529: GREATER
52530: IFFALSE 52573
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
52532: LD_VAR 0 4
52536: PPUSH
52537: LD_VAR 0 2
52541: PUSH
52542: LD_VAR 0 9
52546: ARRAY
52547: PUSH
52548: LD_INT 1
52550: ARRAY
52551: PPUSH
52552: LD_VAR 0 2
52556: PUSH
52557: LD_VAR 0 9
52561: ARRAY
52562: PUSH
52563: LD_INT 2
52565: ARRAY
52566: PPUSH
52567: CALL_OW 114
52571: GO 52587
// SetTag ( i , tag ) ;
52573: LD_VAR 0 4
52577: PPUSH
52578: LD_VAR 0 9
52582: PPUSH
52583: CALL_OW 109
// end else
52587: GO 52660
// if enemy then
52589: LD_VAR 0 5
52593: IFFALSE 52660
// begin if GetWeapon ( i ) = ru_time_lapser then
52595: LD_VAR 0 4
52599: PPUSH
52600: CALL_OW 264
52604: PUSH
52605: LD_INT 49
52607: EQUAL
52608: IFFALSE 52636
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52610: LD_VAR 0 4
52614: PPUSH
52615: LD_VAR 0 5
52619: PPUSH
52620: LD_VAR 0 4
52624: PPUSH
52625: CALL_OW 74
52629: PPUSH
52630: CALL_OW 112
52634: GO 52660
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
52636: LD_VAR 0 4
52640: PPUSH
52641: LD_VAR 0 5
52645: PPUSH
52646: LD_VAR 0 4
52650: PPUSH
52651: CALL_OW 74
52655: PPUSH
52656: CALL 53745 0 2
// end ; end ;
52660: GO 52232
52662: POP
52663: POP
// end ;
52664: LD_VAR 0 3
52668: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
52669: LD_INT 0
52671: PPUSH
52672: PPUSH
52673: PPUSH
// if not unit or IsInUnit ( unit ) then
52674: LD_VAR 0 1
52678: NOT
52679: IFTRUE 52692
52681: PUSH
52682: LD_VAR 0 1
52686: PPUSH
52687: CALL_OW 310
52691: OR
52692: IFFALSE 52696
// exit ;
52694: GO 52787
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
52696: LD_ADDR_VAR 0 4
52700: PUSH
52701: LD_VAR 0 1
52705: PPUSH
52706: CALL_OW 250
52710: PPUSH
52711: LD_VAR 0 2
52715: PPUSH
52716: LD_INT 1
52718: PPUSH
52719: CALL_OW 272
52723: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
52724: LD_ADDR_VAR 0 5
52728: PUSH
52729: LD_VAR 0 1
52733: PPUSH
52734: CALL_OW 251
52738: PPUSH
52739: LD_VAR 0 2
52743: PPUSH
52744: LD_INT 1
52746: PPUSH
52747: CALL_OW 273
52751: ST_TO_ADDR
// if ValidHex ( x , y ) then
52752: LD_VAR 0 4
52756: PPUSH
52757: LD_VAR 0 5
52761: PPUSH
52762: CALL_OW 488
52766: IFFALSE 52787
// ComTurnXY ( unit , x , y ) ;
52768: LD_VAR 0 1
52772: PPUSH
52773: LD_VAR 0 4
52777: PPUSH
52778: LD_VAR 0 5
52782: PPUSH
52783: CALL_OW 118
// end ;
52787: LD_VAR 0 3
52791: RET
// export function SeeUnits ( side , units ) ; var i ; begin
52792: LD_INT 0
52794: PPUSH
52795: PPUSH
// result := false ;
52796: LD_ADDR_VAR 0 3
52800: PUSH
52801: LD_INT 0
52803: ST_TO_ADDR
// if not units then
52804: LD_VAR 0 2
52808: NOT
52809: IFFALSE 52813
// exit ;
52811: GO 52858
// for i in units do
52813: LD_ADDR_VAR 0 4
52817: PUSH
52818: LD_VAR 0 2
52822: PUSH
52823: FOR_IN
52824: IFFALSE 52856
// if See ( side , i ) then
52826: LD_VAR 0 1
52830: PPUSH
52831: LD_VAR 0 4
52835: PPUSH
52836: CALL_OW 292
52840: IFFALSE 52854
// begin result := true ;
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: LD_INT 1
52849: ST_TO_ADDR
// exit ;
52850: POP
52851: POP
52852: GO 52858
// end ;
52854: GO 52823
52856: POP
52857: POP
// end ;
52858: LD_VAR 0 3
52862: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
52863: LD_INT 0
52865: PPUSH
52866: PPUSH
52867: PPUSH
52868: PPUSH
// if not unit or not points then
52869: LD_VAR 0 1
52873: NOT
52874: IFTRUE 52883
52876: PUSH
52877: LD_VAR 0 2
52881: NOT
52882: OR
52883: IFFALSE 52887
// exit ;
52885: GO 52977
// dist := 99999 ;
52887: LD_ADDR_VAR 0 5
52891: PUSH
52892: LD_INT 99999
52894: ST_TO_ADDR
// for i in points do
52895: LD_ADDR_VAR 0 4
52899: PUSH
52900: LD_VAR 0 2
52904: PUSH
52905: FOR_IN
52906: IFFALSE 52975
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
52908: LD_ADDR_VAR 0 6
52912: PUSH
52913: LD_VAR 0 1
52917: PPUSH
52918: LD_VAR 0 4
52922: PUSH
52923: LD_INT 1
52925: ARRAY
52926: PPUSH
52927: LD_VAR 0 4
52931: PUSH
52932: LD_INT 2
52934: ARRAY
52935: PPUSH
52936: CALL_OW 297
52940: ST_TO_ADDR
// if tmpDist < dist then
52941: LD_VAR 0 6
52945: PUSH
52946: LD_VAR 0 5
52950: LESS
52951: IFFALSE 52973
// begin result := i ;
52953: LD_ADDR_VAR 0 3
52957: PUSH
52958: LD_VAR 0 4
52962: ST_TO_ADDR
// dist := tmpDist ;
52963: LD_ADDR_VAR 0 5
52967: PUSH
52968: LD_VAR 0 6
52972: ST_TO_ADDR
// end ; end ;
52973: GO 52905
52975: POP
52976: POP
// end ;
52977: LD_VAR 0 3
52981: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
52982: LD_INT 0
52984: PPUSH
// uc_side := side ;
52985: LD_ADDR_OWVAR 20
52989: PUSH
52990: LD_VAR 0 1
52994: ST_TO_ADDR
// uc_nation := 3 ;
52995: LD_ADDR_OWVAR 21
52999: PUSH
53000: LD_INT 3
53002: ST_TO_ADDR
// vc_chassis := 25 ;
53003: LD_ADDR_OWVAR 37
53007: PUSH
53008: LD_INT 25
53010: ST_TO_ADDR
// vc_engine := engine_siberite ;
53011: LD_ADDR_OWVAR 39
53015: PUSH
53016: LD_INT 3
53018: ST_TO_ADDR
// vc_control := control_computer ;
53019: LD_ADDR_OWVAR 38
53023: PUSH
53024: LD_INT 3
53026: ST_TO_ADDR
// vc_weapon := 59 ;
53027: LD_ADDR_OWVAR 40
53031: PUSH
53032: LD_INT 59
53034: ST_TO_ADDR
// result := CreateVehicle ;
53035: LD_ADDR_VAR 0 5
53039: PUSH
53040: CALL_OW 45
53044: ST_TO_ADDR
// SetDir ( result , d ) ;
53045: LD_VAR 0 5
53049: PPUSH
53050: LD_VAR 0 4
53054: PPUSH
53055: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
53059: LD_VAR 0 5
53063: PPUSH
53064: LD_VAR 0 2
53068: PPUSH
53069: LD_VAR 0 3
53073: PPUSH
53074: LD_INT 0
53076: PPUSH
53077: CALL_OW 48
// end ;
53081: LD_VAR 0 5
53085: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
53086: LD_INT 0
53088: PPUSH
53089: PPUSH
53090: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
53091: LD_ADDR_VAR 0 2
53095: PUSH
53096: LD_INT 0
53098: PUSH
53099: LD_INT 0
53101: PUSH
53102: LD_INT 0
53104: PUSH
53105: LD_INT 0
53107: PUSH
53108: EMPTY
53109: LIST
53110: LIST
53111: LIST
53112: LIST
53113: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
53114: LD_VAR 0 1
53118: NOT
53119: IFTRUE 53152
53121: PUSH
53122: LD_VAR 0 1
53126: PPUSH
53127: CALL_OW 264
53131: PUSH
53132: LD_INT 12
53134: PUSH
53135: LD_INT 51
53137: PUSH
53138: LD_INT 32
53140: PUSH
53141: LD_INT 89
53143: PUSH
53144: EMPTY
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: IN
53150: NOT
53151: OR
53152: IFFALSE 53156
// exit ;
53154: GO 53254
// for i := 1 to 3 do
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: DOUBLE
53162: LD_INT 1
53164: DEC
53165: ST_TO_ADDR
53166: LD_INT 3
53168: PUSH
53169: FOR_TO
53170: IFFALSE 53252
// begin tmp := GetCargo ( cargo , i ) ;
53172: LD_ADDR_VAR 0 4
53176: PUSH
53177: LD_VAR 0 1
53181: PPUSH
53182: LD_VAR 0 3
53186: PPUSH
53187: CALL_OW 289
53191: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
53192: LD_ADDR_VAR 0 2
53196: PUSH
53197: LD_VAR 0 2
53201: PPUSH
53202: LD_VAR 0 3
53206: PPUSH
53207: LD_VAR 0 4
53211: PPUSH
53212: CALL_OW 1
53216: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
53217: LD_ADDR_VAR 0 2
53221: PUSH
53222: LD_VAR 0 2
53226: PPUSH
53227: LD_INT 4
53229: PPUSH
53230: LD_VAR 0 2
53234: PUSH
53235: LD_INT 4
53237: ARRAY
53238: PUSH
53239: LD_VAR 0 4
53243: PLUS
53244: PPUSH
53245: CALL_OW 1
53249: ST_TO_ADDR
// end ;
53250: GO 53169
53252: POP
53253: POP
// end ;
53254: LD_VAR 0 2
53258: RET
// export function Length ( array ) ; begin
53259: LD_INT 0
53261: PPUSH
// result := array + 0 ;
53262: LD_ADDR_VAR 0 2
53266: PUSH
53267: LD_VAR 0 1
53271: PUSH
53272: LD_INT 0
53274: PLUS
53275: ST_TO_ADDR
// end ;
53276: LD_VAR 0 2
53280: RET
// export function PrepareArray ( array ) ; begin
53281: LD_INT 0
53283: PPUSH
// result := array diff 0 ;
53284: LD_ADDR_VAR 0 2
53288: PUSH
53289: LD_VAR 0 1
53293: PUSH
53294: LD_INT 0
53296: DIFF
53297: ST_TO_ADDR
// if not result [ 1 ] then
53298: LD_VAR 0 2
53302: PUSH
53303: LD_INT 1
53305: ARRAY
53306: NOT
53307: IFFALSE 53327
// result := Delete ( result , 1 ) ;
53309: LD_ADDR_VAR 0 2
53313: PUSH
53314: LD_VAR 0 2
53318: PPUSH
53319: LD_INT 1
53321: PPUSH
53322: CALL_OW 3
53326: ST_TO_ADDR
// end ;
53327: LD_VAR 0 2
53331: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
53332: LD_INT 0
53334: PPUSH
53335: PPUSH
53336: PPUSH
53337: PPUSH
// sibRocketRange := 25 ;
53338: LD_ADDR_VAR 0 6
53342: PUSH
53343: LD_INT 25
53345: ST_TO_ADDR
// result := false ;
53346: LD_ADDR_VAR 0 4
53350: PUSH
53351: LD_INT 0
53353: ST_TO_ADDR
// for i := 0 to 5 do
53354: LD_ADDR_VAR 0 5
53358: PUSH
53359: DOUBLE
53360: LD_INT 0
53362: DEC
53363: ST_TO_ADDR
53364: LD_INT 5
53366: PUSH
53367: FOR_TO
53368: IFFALSE 53435
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
53370: LD_VAR 0 1
53374: PPUSH
53375: LD_VAR 0 5
53379: PPUSH
53380: LD_VAR 0 6
53384: PPUSH
53385: CALL_OW 272
53389: PPUSH
53390: LD_VAR 0 2
53394: PPUSH
53395: LD_VAR 0 5
53399: PPUSH
53400: LD_VAR 0 6
53404: PPUSH
53405: CALL_OW 273
53409: PPUSH
53410: LD_VAR 0 3
53414: PPUSH
53415: CALL_OW 309
53419: IFFALSE 53433
// begin result := true ;
53421: LD_ADDR_VAR 0 4
53425: PUSH
53426: LD_INT 1
53428: ST_TO_ADDR
// exit ;
53429: POP
53430: POP
53431: GO 53437
// end ;
53433: GO 53367
53435: POP
53436: POP
// end ;
53437: LD_VAR 0 4
53441: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
53442: LD_INT 0
53444: PPUSH
53445: PPUSH
53446: PPUSH
// if btype = b_depot then
53447: LD_VAR 0 2
53451: PUSH
53452: LD_INT 0
53454: EQUAL
53455: IFFALSE 53467
// begin result := true ;
53457: LD_ADDR_VAR 0 3
53461: PUSH
53462: LD_INT 1
53464: ST_TO_ADDR
// exit ;
53465: GO 53587
// end ; pom := GetBase ( depot ) ;
53467: LD_ADDR_VAR 0 4
53471: PUSH
53472: LD_VAR 0 1
53476: PPUSH
53477: CALL_OW 274
53481: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
53482: LD_ADDR_VAR 0 5
53486: PUSH
53487: LD_VAR 0 2
53491: PPUSH
53492: LD_VAR 0 1
53496: PPUSH
53497: CALL_OW 248
53501: PPUSH
53502: CALL_OW 450
53506: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
53507: LD_ADDR_VAR 0 3
53511: PUSH
53512: LD_VAR 0 4
53516: PPUSH
53517: LD_INT 1
53519: PPUSH
53520: CALL_OW 275
53524: PUSH
53525: LD_VAR 0 5
53529: PUSH
53530: LD_INT 1
53532: ARRAY
53533: GREATEREQUAL
53534: IFFALSE 53560
53536: PUSH
53537: LD_VAR 0 4
53541: PPUSH
53542: LD_INT 2
53544: PPUSH
53545: CALL_OW 275
53549: PUSH
53550: LD_VAR 0 5
53554: PUSH
53555: LD_INT 2
53557: ARRAY
53558: GREATEREQUAL
53559: AND
53560: IFFALSE 53586
53562: PUSH
53563: LD_VAR 0 4
53567: PPUSH
53568: LD_INT 3
53570: PPUSH
53571: CALL_OW 275
53575: PUSH
53576: LD_VAR 0 5
53580: PUSH
53581: LD_INT 3
53583: ARRAY
53584: GREATEREQUAL
53585: AND
53586: ST_TO_ADDR
// end ;
53587: LD_VAR 0 3
53591: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
53592: LD_INT 0
53594: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
53595: LD_VAR 0 1
53599: PPUSH
53600: LD_VAR 0 2
53604: PPUSH
53605: LD_INT 0
53607: PPUSH
53608: LD_INT 0
53610: PPUSH
53611: LD_INT 1
53613: PPUSH
53614: LD_INT 0
53616: PPUSH
53617: CALL_OW 587
// end ;
53621: LD_VAR 0 3
53625: RET
// export function CenterOnNow ( unit ) ; begin
53626: LD_INT 0
53628: PPUSH
// result := IsInUnit ( unit ) ;
53629: LD_ADDR_VAR 0 2
53633: PUSH
53634: LD_VAR 0 1
53638: PPUSH
53639: CALL_OW 310
53643: ST_TO_ADDR
// if not result then
53644: LD_VAR 0 2
53648: NOT
53649: IFFALSE 53661
// result := unit ;
53651: LD_ADDR_VAR 0 2
53655: PUSH
53656: LD_VAR 0 1
53660: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
53661: LD_VAR 0 1
53665: PPUSH
53666: CALL_OW 87
// end ;
53670: LD_VAR 0 2
53674: RET
// export function ComMoveHex ( unit , hex ) ; begin
53675: LD_INT 0
53677: PPUSH
// if not hex then
53678: LD_VAR 0 2
53682: NOT
53683: IFFALSE 53687
// exit ;
53685: GO 53740
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
53687: LD_VAR 0 2
53691: PUSH
53692: LD_INT 1
53694: ARRAY
53695: PPUSH
53696: LD_VAR 0 2
53700: PUSH
53701: LD_INT 2
53703: ARRAY
53704: PPUSH
53705: CALL_OW 428
53709: IFFALSE 53713
// exit ;
53711: GO 53740
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
53713: LD_VAR 0 1
53717: PPUSH
53718: LD_VAR 0 2
53722: PUSH
53723: LD_INT 1
53725: ARRAY
53726: PPUSH
53727: LD_VAR 0 2
53731: PUSH
53732: LD_INT 2
53734: ARRAY
53735: PPUSH
53736: CALL_OW 111
// end ;
53740: LD_VAR 0 3
53744: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
53745: LD_INT 0
53747: PPUSH
53748: PPUSH
53749: PPUSH
// if not unit or not enemy then
53750: LD_VAR 0 1
53754: NOT
53755: IFTRUE 53764
53757: PUSH
53758: LD_VAR 0 2
53762: NOT
53763: OR
53764: IFFALSE 53768
// exit ;
53766: GO 53894
// x := GetX ( enemy ) ;
53768: LD_ADDR_VAR 0 4
53772: PUSH
53773: LD_VAR 0 2
53777: PPUSH
53778: CALL_OW 250
53782: ST_TO_ADDR
// y := GetY ( enemy ) ;
53783: LD_ADDR_VAR 0 5
53787: PUSH
53788: LD_VAR 0 2
53792: PPUSH
53793: CALL_OW 251
53797: ST_TO_ADDR
// if ValidHex ( x , y ) then
53798: LD_VAR 0 4
53802: PPUSH
53803: LD_VAR 0 5
53807: PPUSH
53808: CALL_OW 488
53812: IFFALSE 53894
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
53814: LD_VAR 0 2
53818: PPUSH
53819: CALL_OW 247
53823: PUSH
53824: LD_INT 3
53826: PUSH
53827: LD_INT 2
53829: PUSH
53830: EMPTY
53831: LIST
53832: LIST
53833: IN
53834: IFTRUE 53857
53836: PUSH
53837: LD_VAR 0 1
53841: PPUSH
53842: CALL_OW 255
53846: PPUSH
53847: LD_VAR 0 2
53851: PPUSH
53852: CALL_OW 292
53856: OR
53857: IFFALSE 53875
// ComAttackUnit ( unit , enemy ) else
53859: LD_VAR 0 1
53863: PPUSH
53864: LD_VAR 0 2
53868: PPUSH
53869: CALL_OW 115
53873: GO 53894
// ComAgressiveMove ( unit , x , y ) ;
53875: LD_VAR 0 1
53879: PPUSH
53880: LD_VAR 0 4
53884: PPUSH
53885: LD_VAR 0 5
53889: PPUSH
53890: CALL_OW 114
// end ;
53894: LD_VAR 0 3
53898: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
53899: LD_INT 0
53901: PPUSH
53902: PPUSH
53903: PPUSH
// list := AreaToList ( area , 0 ) ;
53904: LD_ADDR_VAR 0 5
53908: PUSH
53909: LD_VAR 0 1
53913: PPUSH
53914: LD_INT 0
53916: PPUSH
53917: CALL_OW 517
53921: ST_TO_ADDR
// if not list then
53922: LD_VAR 0 5
53926: NOT
53927: IFFALSE 53931
// exit ;
53929: GO 54061
// if all then
53931: LD_VAR 0 2
53935: IFFALSE 54023
// begin for i := 1 to list [ 1 ] do
53937: LD_ADDR_VAR 0 4
53941: PUSH
53942: DOUBLE
53943: LD_INT 1
53945: DEC
53946: ST_TO_ADDR
53947: LD_VAR 0 5
53951: PUSH
53952: LD_INT 1
53954: ARRAY
53955: PUSH
53956: FOR_TO
53957: IFFALSE 54019
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
53959: LD_ADDR_VAR 0 3
53963: PUSH
53964: LD_VAR 0 3
53968: PPUSH
53969: LD_VAR 0 3
53973: PUSH
53974: LD_INT 1
53976: PLUS
53977: PPUSH
53978: LD_VAR 0 5
53982: PUSH
53983: LD_INT 1
53985: ARRAY
53986: PUSH
53987: LD_VAR 0 4
53991: ARRAY
53992: PUSH
53993: LD_VAR 0 5
53997: PUSH
53998: LD_INT 2
54000: ARRAY
54001: PUSH
54002: LD_VAR 0 4
54006: ARRAY
54007: PUSH
54008: EMPTY
54009: LIST
54010: LIST
54011: PPUSH
54012: CALL_OW 1
54016: ST_TO_ADDR
54017: GO 53956
54019: POP
54020: POP
// exit ;
54021: GO 54061
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
54023: LD_ADDR_VAR 0 3
54027: PUSH
54028: LD_VAR 0 5
54032: PUSH
54033: LD_INT 1
54035: ARRAY
54036: PUSH
54037: LD_INT 1
54039: ARRAY
54040: PUSH
54041: LD_VAR 0 5
54045: PUSH
54046: LD_INT 2
54048: ARRAY
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: PUSH
54058: EMPTY
54059: LIST
54060: ST_TO_ADDR
// end ;
54061: LD_VAR 0 3
54065: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
54066: LD_INT 0
54068: PPUSH
54069: PPUSH
// list := AreaToList ( area , 0 ) ;
54070: LD_ADDR_VAR 0 4
54074: PUSH
54075: LD_VAR 0 1
54079: PPUSH
54080: LD_INT 0
54082: PPUSH
54083: CALL_OW 517
54087: ST_TO_ADDR
// if not list then
54088: LD_VAR 0 4
54092: NOT
54093: IFFALSE 54097
// exit ;
54095: GO 54138
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
54097: LD_ADDR_VAR 0 3
54101: PUSH
54102: LD_VAR 0 4
54106: PUSH
54107: LD_INT 1
54109: ARRAY
54110: PUSH
54111: LD_INT 1
54113: ARRAY
54114: PUSH
54115: LD_VAR 0 4
54119: PUSH
54120: LD_INT 2
54122: ARRAY
54123: PUSH
54124: LD_INT 1
54126: ARRAY
54127: PUSH
54128: LD_VAR 0 2
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: LIST
54137: ST_TO_ADDR
// end ;
54138: LD_VAR 0 3
54142: RET
// export function First ( array ) ; begin
54143: LD_INT 0
54145: PPUSH
// if not array then
54146: LD_VAR 0 1
54150: NOT
54151: IFFALSE 54155
// exit ;
54153: GO 54169
// result := array [ 1 ] ;
54155: LD_ADDR_VAR 0 2
54159: PUSH
54160: LD_VAR 0 1
54164: PUSH
54165: LD_INT 1
54167: ARRAY
54168: ST_TO_ADDR
// end ;
54169: LD_VAR 0 2
54173: RET
// export function Last ( array ) ; begin
54174: LD_INT 0
54176: PPUSH
// if not array then
54177: LD_VAR 0 1
54181: NOT
54182: IFFALSE 54186
// exit ;
54184: GO 54202
// result := array [ array ] ;
54186: LD_ADDR_VAR 0 2
54190: PUSH
54191: LD_VAR 0 1
54195: PUSH
54196: LD_VAR 0 1
54200: ARRAY
54201: ST_TO_ADDR
// end ;
54202: LD_VAR 0 2
54206: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
54207: LD_INT 0
54209: PPUSH
54210: PPUSH
// result := [ ] ;
54211: LD_ADDR_VAR 0 5
54215: PUSH
54216: EMPTY
54217: ST_TO_ADDR
// if not array then
54218: LD_VAR 0 1
54222: NOT
54223: IFFALSE 54227
// exit ;
54225: GO 54339
// for i := 1 to array do
54227: LD_ADDR_VAR 0 6
54231: PUSH
54232: DOUBLE
54233: LD_INT 1
54235: DEC
54236: ST_TO_ADDR
54237: LD_VAR 0 1
54241: PUSH
54242: FOR_TO
54243: IFFALSE 54337
// if array [ i ] [ index ] = value then
54245: LD_VAR 0 1
54249: PUSH
54250: LD_VAR 0 6
54254: ARRAY
54255: PUSH
54256: LD_VAR 0 2
54260: ARRAY
54261: PUSH
54262: LD_VAR 0 3
54266: EQUAL
54267: IFFALSE 54335
// begin if indexColumn then
54269: LD_VAR 0 4
54273: IFFALSE 54309
// result := Join ( result , array [ i ] [ indexColumn ] ) else
54275: LD_ADDR_VAR 0 5
54279: PUSH
54280: LD_VAR 0 5
54284: PPUSH
54285: LD_VAR 0 1
54289: PUSH
54290: LD_VAR 0 6
54294: ARRAY
54295: PUSH
54296: LD_VAR 0 4
54300: ARRAY
54301: PPUSH
54302: CALL 49347 0 2
54306: ST_TO_ADDR
54307: GO 54335
// result := Join ( result , array [ i ] ) ;
54309: LD_ADDR_VAR 0 5
54313: PUSH
54314: LD_VAR 0 5
54318: PPUSH
54319: LD_VAR 0 1
54323: PUSH
54324: LD_VAR 0 6
54328: ARRAY
54329: PPUSH
54330: CALL 49347 0 2
54334: ST_TO_ADDR
// end ;
54335: GO 54242
54337: POP
54338: POP
// end ;
54339: LD_VAR 0 5
54343: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
54344: LD_INT 0
54346: PPUSH
// if not vehicles or not parkingPoint then
54347: LD_VAR 0 1
54351: NOT
54352: IFTRUE 54361
54354: PUSH
54355: LD_VAR 0 2
54359: NOT
54360: OR
54361: IFFALSE 54365
// exit ;
54363: GO 54463
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
54365: LD_ADDR_VAR 0 1
54369: PUSH
54370: LD_VAR 0 1
54374: PPUSH
54375: LD_INT 50
54377: PUSH
54378: EMPTY
54379: LIST
54380: PUSH
54381: LD_INT 3
54383: PUSH
54384: LD_INT 92
54386: PUSH
54387: LD_VAR 0 2
54391: PUSH
54392: LD_INT 1
54394: ARRAY
54395: PUSH
54396: LD_VAR 0 2
54400: PUSH
54401: LD_INT 2
54403: ARRAY
54404: PUSH
54405: LD_INT 8
54407: PUSH
54408: EMPTY
54409: LIST
54410: LIST
54411: LIST
54412: LIST
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: PUSH
54418: EMPTY
54419: LIST
54420: LIST
54421: PPUSH
54422: CALL_OW 72
54426: ST_TO_ADDR
// if not vehicles then
54427: LD_VAR 0 1
54431: NOT
54432: IFFALSE 54436
// exit ;
54434: GO 54463
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
54436: LD_VAR 0 1
54440: PPUSH
54441: LD_VAR 0 2
54445: PUSH
54446: LD_INT 1
54448: ARRAY
54449: PPUSH
54450: LD_VAR 0 2
54454: PUSH
54455: LD_INT 2
54457: ARRAY
54458: PPUSH
54459: CALL_OW 111
// end ;
54463: LD_VAR 0 3
54467: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
54468: LD_INT 0
54470: PPUSH
54471: PPUSH
54472: PPUSH
// if not side or not area then
54473: LD_VAR 0 1
54477: NOT
54478: IFTRUE 54487
54480: PUSH
54481: LD_VAR 0 2
54485: NOT
54486: OR
54487: IFFALSE 54491
// exit ;
54489: GO 54610
// tmp := AreaToList ( area , 0 ) ;
54491: LD_ADDR_VAR 0 5
54495: PUSH
54496: LD_VAR 0 2
54500: PPUSH
54501: LD_INT 0
54503: PPUSH
54504: CALL_OW 517
54508: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
54509: LD_ADDR_VAR 0 4
54513: PUSH
54514: DOUBLE
54515: LD_INT 1
54517: DEC
54518: ST_TO_ADDR
54519: LD_VAR 0 5
54523: PUSH
54524: LD_INT 1
54526: ARRAY
54527: PUSH
54528: FOR_TO
54529: IFFALSE 54608
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
54531: LD_VAR 0 5
54535: PUSH
54536: LD_INT 1
54538: ARRAY
54539: PUSH
54540: LD_VAR 0 4
54544: ARRAY
54545: PPUSH
54546: LD_VAR 0 5
54550: PUSH
54551: LD_INT 2
54553: ARRAY
54554: PUSH
54555: LD_VAR 0 4
54559: ARRAY
54560: PPUSH
54561: CALL_OW 351
54565: IFFALSE 54606
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
54567: LD_VAR 0 5
54571: PUSH
54572: LD_INT 1
54574: ARRAY
54575: PUSH
54576: LD_VAR 0 4
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 5
54586: PUSH
54587: LD_INT 2
54589: ARRAY
54590: PUSH
54591: LD_VAR 0 4
54595: ARRAY
54596: PPUSH
54597: LD_VAR 0 1
54601: PPUSH
54602: CALL_OW 244
// end ;
54606: GO 54528
54608: POP
54609: POP
// end ;
54610: LD_VAR 0 3
54614: RET
// export function UniqueArray ( array ) ; var i ; begin
54615: LD_INT 0
54617: PPUSH
54618: PPUSH
// result := [ ] ;
54619: LD_ADDR_VAR 0 2
54623: PUSH
54624: EMPTY
54625: ST_TO_ADDR
// if not array then
54626: LD_VAR 0 1
54630: NOT
54631: IFFALSE 54635
// exit ;
54633: GO 54696
// for i := 1 to array do
54635: LD_ADDR_VAR 0 3
54639: PUSH
54640: DOUBLE
54641: LD_INT 1
54643: DEC
54644: ST_TO_ADDR
54645: LD_VAR 0 1
54649: PUSH
54650: FOR_TO
54651: IFFALSE 54694
// if not array [ i ] in result then
54653: LD_VAR 0 1
54657: PUSH
54658: LD_VAR 0 3
54662: ARRAY
54663: PUSH
54664: LD_VAR 0 2
54668: IN
54669: NOT
54670: IFFALSE 54692
// result := Join ( result , i ) ;
54672: LD_ADDR_VAR 0 2
54676: PUSH
54677: LD_VAR 0 2
54681: PPUSH
54682: LD_VAR 0 3
54686: PPUSH
54687: CALL 49347 0 2
54691: ST_TO_ADDR
54692: GO 54650
54694: POP
54695: POP
// end ; end_of_file
54696: LD_VAR 0 2
54700: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
54701: LD_INT 0
54703: PPUSH
54704: PPUSH
// skirmish := false ;
54705: LD_ADDR_EXP 21
54709: PUSH
54710: LD_INT 0
54712: ST_TO_ADDR
// debug_mc := false ;
54713: LD_ADDR_EXP 22
54717: PUSH
54718: LD_INT 0
54720: ST_TO_ADDR
// mc_bases := [ ] ;
54721: LD_ADDR_EXP 23
54725: PUSH
54726: EMPTY
54727: ST_TO_ADDR
// mc_sides := [ ] ;
54728: LD_ADDR_EXP 49
54732: PUSH
54733: EMPTY
54734: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54735: LD_ADDR_EXP 24
54739: PUSH
54740: EMPTY
54741: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54742: LD_ADDR_EXP 25
54746: PUSH
54747: EMPTY
54748: ST_TO_ADDR
// mc_need_heal := [ ] ;
54749: LD_ADDR_EXP 26
54753: PUSH
54754: EMPTY
54755: ST_TO_ADDR
// mc_healers := [ ] ;
54756: LD_ADDR_EXP 27
54760: PUSH
54761: EMPTY
54762: ST_TO_ADDR
// mc_build_list := [ ] ;
54763: LD_ADDR_EXP 28
54767: PUSH
54768: EMPTY
54769: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54770: LD_ADDR_EXP 55
54774: PUSH
54775: EMPTY
54776: ST_TO_ADDR
// mc_builders := [ ] ;
54777: LD_ADDR_EXP 29
54781: PUSH
54782: EMPTY
54783: ST_TO_ADDR
// mc_construct_list := [ ] ;
54784: LD_ADDR_EXP 30
54788: PUSH
54789: EMPTY
54790: ST_TO_ADDR
// mc_turret_list := [ ] ;
54791: LD_ADDR_EXP 31
54795: PUSH
54796: EMPTY
54797: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54798: LD_ADDR_EXP 32
54802: PUSH
54803: EMPTY
54804: ST_TO_ADDR
// mc_miners := [ ] ;
54805: LD_ADDR_EXP 37
54809: PUSH
54810: EMPTY
54811: ST_TO_ADDR
// mc_mines := [ ] ;
54812: LD_ADDR_EXP 36
54816: PUSH
54817: EMPTY
54818: ST_TO_ADDR
// mc_minefields := [ ] ;
54819: LD_ADDR_EXP 38
54823: PUSH
54824: EMPTY
54825: ST_TO_ADDR
// mc_crates := [ ] ;
54826: LD_ADDR_EXP 39
54830: PUSH
54831: EMPTY
54832: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54833: LD_ADDR_EXP 40
54837: PUSH
54838: EMPTY
54839: ST_TO_ADDR
// mc_crates_area := [ ] ;
54840: LD_ADDR_EXP 41
54844: PUSH
54845: EMPTY
54846: ST_TO_ADDR
// mc_vehicles := [ ] ;
54847: LD_ADDR_EXP 42
54851: PUSH
54852: EMPTY
54853: ST_TO_ADDR
// mc_attack := [ ] ;
54854: LD_ADDR_EXP 43
54858: PUSH
54859: EMPTY
54860: ST_TO_ADDR
// mc_produce := [ ] ;
54861: LD_ADDR_EXP 44
54865: PUSH
54866: EMPTY
54867: ST_TO_ADDR
// mc_defender := [ ] ;
54868: LD_ADDR_EXP 45
54872: PUSH
54873: EMPTY
54874: ST_TO_ADDR
// mc_parking := [ ] ;
54875: LD_ADDR_EXP 47
54879: PUSH
54880: EMPTY
54881: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54882: LD_ADDR_EXP 33
54886: PUSH
54887: EMPTY
54888: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54889: LD_ADDR_EXP 35
54893: PUSH
54894: EMPTY
54895: ST_TO_ADDR
// mc_scan := [ ] ;
54896: LD_ADDR_EXP 46
54900: PUSH
54901: EMPTY
54902: ST_TO_ADDR
// mc_scan_area := [ ] ;
54903: LD_ADDR_EXP 48
54907: PUSH
54908: EMPTY
54909: ST_TO_ADDR
// mc_tech := [ ] ;
54910: LD_ADDR_EXP 50
54914: PUSH
54915: EMPTY
54916: ST_TO_ADDR
// mc_class := [ ] ;
54917: LD_ADDR_EXP 64
54921: PUSH
54922: EMPTY
54923: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54924: LD_ADDR_EXP 65
54928: PUSH
54929: EMPTY
54930: ST_TO_ADDR
// mc_is_defending := [ ] ;
54931: LD_ADDR_EXP 66
54935: PUSH
54936: EMPTY
54937: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
54938: LD_ADDR_EXP 57
54942: PUSH
54943: EMPTY
54944: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
54945: LD_ADDR_EXP 67
54949: PUSH
54950: LD_INT 0
54952: ST_TO_ADDR
// end ;
54953: LD_VAR 0 1
54957: RET
// export function MC_Kill ( base ) ; begin
54958: LD_INT 0
54960: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54961: LD_ADDR_EXP 23
54965: PUSH
54966: LD_EXP 23
54970: PPUSH
54971: LD_VAR 0 1
54975: PPUSH
54976: EMPTY
54977: PPUSH
54978: CALL_OW 1
54982: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54983: LD_ADDR_EXP 24
54987: PUSH
54988: LD_EXP 24
54992: PPUSH
54993: LD_VAR 0 1
54997: PPUSH
54998: EMPTY
54999: PPUSH
55000: CALL_OW 1
55004: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55005: LD_ADDR_EXP 25
55009: PUSH
55010: LD_EXP 25
55014: PPUSH
55015: LD_VAR 0 1
55019: PPUSH
55020: EMPTY
55021: PPUSH
55022: CALL_OW 1
55026: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55027: LD_ADDR_EXP 26
55031: PUSH
55032: LD_EXP 26
55036: PPUSH
55037: LD_VAR 0 1
55041: PPUSH
55042: EMPTY
55043: PPUSH
55044: CALL_OW 1
55048: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55049: LD_ADDR_EXP 27
55053: PUSH
55054: LD_EXP 27
55058: PPUSH
55059: LD_VAR 0 1
55063: PPUSH
55064: EMPTY
55065: PPUSH
55066: CALL_OW 1
55070: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55071: LD_ADDR_EXP 28
55075: PUSH
55076: LD_EXP 28
55080: PPUSH
55081: LD_VAR 0 1
55085: PPUSH
55086: EMPTY
55087: PPUSH
55088: CALL_OW 1
55092: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55093: LD_ADDR_EXP 29
55097: PUSH
55098: LD_EXP 29
55102: PPUSH
55103: LD_VAR 0 1
55107: PPUSH
55108: EMPTY
55109: PPUSH
55110: CALL_OW 1
55114: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55115: LD_ADDR_EXP 30
55119: PUSH
55120: LD_EXP 30
55124: PPUSH
55125: LD_VAR 0 1
55129: PPUSH
55130: EMPTY
55131: PPUSH
55132: CALL_OW 1
55136: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55137: LD_ADDR_EXP 31
55141: PUSH
55142: LD_EXP 31
55146: PPUSH
55147: LD_VAR 0 1
55151: PPUSH
55152: EMPTY
55153: PPUSH
55154: CALL_OW 1
55158: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55159: LD_ADDR_EXP 32
55163: PUSH
55164: LD_EXP 32
55168: PPUSH
55169: LD_VAR 0 1
55173: PPUSH
55174: EMPTY
55175: PPUSH
55176: CALL_OW 1
55180: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55181: LD_ADDR_EXP 33
55185: PUSH
55186: LD_EXP 33
55190: PPUSH
55191: LD_VAR 0 1
55195: PPUSH
55196: EMPTY
55197: PPUSH
55198: CALL_OW 1
55202: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55203: LD_ADDR_EXP 34
55207: PUSH
55208: LD_EXP 34
55212: PPUSH
55213: LD_VAR 0 1
55217: PPUSH
55218: LD_INT 0
55220: PPUSH
55221: CALL_OW 1
55225: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55226: LD_ADDR_EXP 35
55230: PUSH
55231: LD_EXP 35
55235: PPUSH
55236: LD_VAR 0 1
55240: PPUSH
55241: EMPTY
55242: PPUSH
55243: CALL_OW 1
55247: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55248: LD_ADDR_EXP 36
55252: PUSH
55253: LD_EXP 36
55257: PPUSH
55258: LD_VAR 0 1
55262: PPUSH
55263: EMPTY
55264: PPUSH
55265: CALL_OW 1
55269: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55270: LD_ADDR_EXP 37
55274: PUSH
55275: LD_EXP 37
55279: PPUSH
55280: LD_VAR 0 1
55284: PPUSH
55285: EMPTY
55286: PPUSH
55287: CALL_OW 1
55291: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55292: LD_ADDR_EXP 38
55296: PUSH
55297: LD_EXP 38
55301: PPUSH
55302: LD_VAR 0 1
55306: PPUSH
55307: EMPTY
55308: PPUSH
55309: CALL_OW 1
55313: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55314: LD_ADDR_EXP 39
55318: PUSH
55319: LD_EXP 39
55323: PPUSH
55324: LD_VAR 0 1
55328: PPUSH
55329: EMPTY
55330: PPUSH
55331: CALL_OW 1
55335: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55336: LD_ADDR_EXP 40
55340: PUSH
55341: LD_EXP 40
55345: PPUSH
55346: LD_VAR 0 1
55350: PPUSH
55351: EMPTY
55352: PPUSH
55353: CALL_OW 1
55357: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55358: LD_ADDR_EXP 41
55362: PUSH
55363: LD_EXP 41
55367: PPUSH
55368: LD_VAR 0 1
55372: PPUSH
55373: EMPTY
55374: PPUSH
55375: CALL_OW 1
55379: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55380: LD_ADDR_EXP 42
55384: PUSH
55385: LD_EXP 42
55389: PPUSH
55390: LD_VAR 0 1
55394: PPUSH
55395: EMPTY
55396: PPUSH
55397: CALL_OW 1
55401: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55402: LD_ADDR_EXP 43
55406: PUSH
55407: LD_EXP 43
55411: PPUSH
55412: LD_VAR 0 1
55416: PPUSH
55417: EMPTY
55418: PPUSH
55419: CALL_OW 1
55423: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55424: LD_ADDR_EXP 44
55428: PUSH
55429: LD_EXP 44
55433: PPUSH
55434: LD_VAR 0 1
55438: PPUSH
55439: EMPTY
55440: PPUSH
55441: CALL_OW 1
55445: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55446: LD_ADDR_EXP 45
55450: PUSH
55451: LD_EXP 45
55455: PPUSH
55456: LD_VAR 0 1
55460: PPUSH
55461: EMPTY
55462: PPUSH
55463: CALL_OW 1
55467: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55468: LD_ADDR_EXP 46
55472: PUSH
55473: LD_EXP 46
55477: PPUSH
55478: LD_VAR 0 1
55482: PPUSH
55483: EMPTY
55484: PPUSH
55485: CALL_OW 1
55489: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55490: LD_ADDR_EXP 47
55494: PUSH
55495: LD_EXP 47
55499: PPUSH
55500: LD_VAR 0 1
55504: PPUSH
55505: EMPTY
55506: PPUSH
55507: CALL_OW 1
55511: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55512: LD_ADDR_EXP 48
55516: PUSH
55517: LD_EXP 48
55521: PPUSH
55522: LD_VAR 0 1
55526: PPUSH
55527: EMPTY
55528: PPUSH
55529: CALL_OW 1
55533: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55534: LD_ADDR_EXP 50
55538: PUSH
55539: LD_EXP 50
55543: PPUSH
55544: LD_VAR 0 1
55548: PPUSH
55549: EMPTY
55550: PPUSH
55551: CALL_OW 1
55555: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55556: LD_ADDR_EXP 52
55560: PUSH
55561: LD_EXP 52
55565: PPUSH
55566: LD_VAR 0 1
55570: PPUSH
55571: EMPTY
55572: PPUSH
55573: CALL_OW 1
55577: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55578: LD_ADDR_EXP 53
55582: PUSH
55583: LD_EXP 53
55587: PPUSH
55588: LD_VAR 0 1
55592: PPUSH
55593: EMPTY
55594: PPUSH
55595: CALL_OW 1
55599: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55600: LD_ADDR_EXP 54
55604: PUSH
55605: LD_EXP 54
55609: PPUSH
55610: LD_VAR 0 1
55614: PPUSH
55615: EMPTY
55616: PPUSH
55617: CALL_OW 1
55621: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55622: LD_ADDR_EXP 55
55626: PUSH
55627: LD_EXP 55
55631: PPUSH
55632: LD_VAR 0 1
55636: PPUSH
55637: EMPTY
55638: PPUSH
55639: CALL_OW 1
55643: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55644: LD_ADDR_EXP 56
55648: PUSH
55649: LD_EXP 56
55653: PPUSH
55654: LD_VAR 0 1
55658: PPUSH
55659: EMPTY
55660: PPUSH
55661: CALL_OW 1
55665: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55666: LD_ADDR_EXP 57
55670: PUSH
55671: LD_EXP 57
55675: PPUSH
55676: LD_VAR 0 1
55680: PPUSH
55681: EMPTY
55682: PPUSH
55683: CALL_OW 1
55687: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55688: LD_ADDR_EXP 58
55692: PUSH
55693: LD_EXP 58
55697: PPUSH
55698: LD_VAR 0 1
55702: PPUSH
55703: EMPTY
55704: PPUSH
55705: CALL_OW 1
55709: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55710: LD_ADDR_EXP 59
55714: PUSH
55715: LD_EXP 59
55719: PPUSH
55720: LD_VAR 0 1
55724: PPUSH
55725: EMPTY
55726: PPUSH
55727: CALL_OW 1
55731: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55732: LD_ADDR_EXP 60
55736: PUSH
55737: LD_EXP 60
55741: PPUSH
55742: LD_VAR 0 1
55746: PPUSH
55747: EMPTY
55748: PPUSH
55749: CALL_OW 1
55753: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55754: LD_ADDR_EXP 61
55758: PUSH
55759: LD_EXP 61
55763: PPUSH
55764: LD_VAR 0 1
55768: PPUSH
55769: EMPTY
55770: PPUSH
55771: CALL_OW 1
55775: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55776: LD_ADDR_EXP 62
55780: PUSH
55781: LD_EXP 62
55785: PPUSH
55786: LD_VAR 0 1
55790: PPUSH
55791: EMPTY
55792: PPUSH
55793: CALL_OW 1
55797: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55798: LD_ADDR_EXP 63
55802: PUSH
55803: LD_EXP 63
55807: PPUSH
55808: LD_VAR 0 1
55812: PPUSH
55813: EMPTY
55814: PPUSH
55815: CALL_OW 1
55819: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55820: LD_ADDR_EXP 64
55824: PUSH
55825: LD_EXP 64
55829: PPUSH
55830: LD_VAR 0 1
55834: PPUSH
55835: EMPTY
55836: PPUSH
55837: CALL_OW 1
55841: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55842: LD_ADDR_EXP 65
55846: PUSH
55847: LD_EXP 65
55851: PPUSH
55852: LD_VAR 0 1
55856: PPUSH
55857: LD_INT 0
55859: PPUSH
55860: CALL_OW 1
55864: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55865: LD_ADDR_EXP 66
55869: PUSH
55870: LD_EXP 66
55874: PPUSH
55875: LD_VAR 0 1
55879: PPUSH
55880: LD_INT 0
55882: PPUSH
55883: CALL_OW 1
55887: ST_TO_ADDR
// end ;
55888: LD_VAR 0 2
55892: RET
// export function MC_Add ( side , units ) ; var base ; begin
55893: LD_INT 0
55895: PPUSH
55896: PPUSH
// base := mc_bases + 1 ;
55897: LD_ADDR_VAR 0 4
55901: PUSH
55902: LD_EXP 23
55906: PUSH
55907: LD_INT 1
55909: PLUS
55910: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55911: LD_ADDR_EXP 49
55915: PUSH
55916: LD_EXP 49
55920: PPUSH
55921: LD_VAR 0 4
55925: PPUSH
55926: LD_VAR 0 1
55930: PPUSH
55931: CALL_OW 1
55935: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55936: LD_ADDR_EXP 23
55940: PUSH
55941: LD_EXP 23
55945: PPUSH
55946: LD_VAR 0 4
55950: PPUSH
55951: LD_VAR 0 2
55955: PPUSH
55956: CALL_OW 1
55960: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55961: LD_ADDR_EXP 24
55965: PUSH
55966: LD_EXP 24
55970: PPUSH
55971: LD_VAR 0 4
55975: PPUSH
55976: EMPTY
55977: PPUSH
55978: CALL_OW 1
55982: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55983: LD_ADDR_EXP 25
55987: PUSH
55988: LD_EXP 25
55992: PPUSH
55993: LD_VAR 0 4
55997: PPUSH
55998: EMPTY
55999: PPUSH
56000: CALL_OW 1
56004: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56005: LD_ADDR_EXP 26
56009: PUSH
56010: LD_EXP 26
56014: PPUSH
56015: LD_VAR 0 4
56019: PPUSH
56020: EMPTY
56021: PPUSH
56022: CALL_OW 1
56026: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56027: LD_ADDR_EXP 27
56031: PUSH
56032: LD_EXP 27
56036: PPUSH
56037: LD_VAR 0 4
56041: PPUSH
56042: EMPTY
56043: PPUSH
56044: CALL_OW 1
56048: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56049: LD_ADDR_EXP 28
56053: PUSH
56054: LD_EXP 28
56058: PPUSH
56059: LD_VAR 0 4
56063: PPUSH
56064: EMPTY
56065: PPUSH
56066: CALL_OW 1
56070: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56071: LD_ADDR_EXP 29
56075: PUSH
56076: LD_EXP 29
56080: PPUSH
56081: LD_VAR 0 4
56085: PPUSH
56086: EMPTY
56087: PPUSH
56088: CALL_OW 1
56092: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56093: LD_ADDR_EXP 30
56097: PUSH
56098: LD_EXP 30
56102: PPUSH
56103: LD_VAR 0 4
56107: PPUSH
56108: EMPTY
56109: PPUSH
56110: CALL_OW 1
56114: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56115: LD_ADDR_EXP 31
56119: PUSH
56120: LD_EXP 31
56124: PPUSH
56125: LD_VAR 0 4
56129: PPUSH
56130: EMPTY
56131: PPUSH
56132: CALL_OW 1
56136: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56137: LD_ADDR_EXP 32
56141: PUSH
56142: LD_EXP 32
56146: PPUSH
56147: LD_VAR 0 4
56151: PPUSH
56152: EMPTY
56153: PPUSH
56154: CALL_OW 1
56158: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56159: LD_ADDR_EXP 33
56163: PUSH
56164: LD_EXP 33
56168: PPUSH
56169: LD_VAR 0 4
56173: PPUSH
56174: EMPTY
56175: PPUSH
56176: CALL_OW 1
56180: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56181: LD_ADDR_EXP 34
56185: PUSH
56186: LD_EXP 34
56190: PPUSH
56191: LD_VAR 0 4
56195: PPUSH
56196: LD_INT 0
56198: PPUSH
56199: CALL_OW 1
56203: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56204: LD_ADDR_EXP 35
56208: PUSH
56209: LD_EXP 35
56213: PPUSH
56214: LD_VAR 0 4
56218: PPUSH
56219: EMPTY
56220: PPUSH
56221: CALL_OW 1
56225: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56226: LD_ADDR_EXP 36
56230: PUSH
56231: LD_EXP 36
56235: PPUSH
56236: LD_VAR 0 4
56240: PPUSH
56241: EMPTY
56242: PPUSH
56243: CALL_OW 1
56247: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56248: LD_ADDR_EXP 37
56252: PUSH
56253: LD_EXP 37
56257: PPUSH
56258: LD_VAR 0 4
56262: PPUSH
56263: EMPTY
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56270: LD_ADDR_EXP 38
56274: PUSH
56275: LD_EXP 38
56279: PPUSH
56280: LD_VAR 0 4
56284: PPUSH
56285: EMPTY
56286: PPUSH
56287: CALL_OW 1
56291: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56292: LD_ADDR_EXP 39
56296: PUSH
56297: LD_EXP 39
56301: PPUSH
56302: LD_VAR 0 4
56306: PPUSH
56307: EMPTY
56308: PPUSH
56309: CALL_OW 1
56313: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56314: LD_ADDR_EXP 40
56318: PUSH
56319: LD_EXP 40
56323: PPUSH
56324: LD_VAR 0 4
56328: PPUSH
56329: EMPTY
56330: PPUSH
56331: CALL_OW 1
56335: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56336: LD_ADDR_EXP 41
56340: PUSH
56341: LD_EXP 41
56345: PPUSH
56346: LD_VAR 0 4
56350: PPUSH
56351: EMPTY
56352: PPUSH
56353: CALL_OW 1
56357: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56358: LD_ADDR_EXP 42
56362: PUSH
56363: LD_EXP 42
56367: PPUSH
56368: LD_VAR 0 4
56372: PPUSH
56373: EMPTY
56374: PPUSH
56375: CALL_OW 1
56379: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56380: LD_ADDR_EXP 43
56384: PUSH
56385: LD_EXP 43
56389: PPUSH
56390: LD_VAR 0 4
56394: PPUSH
56395: EMPTY
56396: PPUSH
56397: CALL_OW 1
56401: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56402: LD_ADDR_EXP 44
56406: PUSH
56407: LD_EXP 44
56411: PPUSH
56412: LD_VAR 0 4
56416: PPUSH
56417: EMPTY
56418: PPUSH
56419: CALL_OW 1
56423: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56424: LD_ADDR_EXP 45
56428: PUSH
56429: LD_EXP 45
56433: PPUSH
56434: LD_VAR 0 4
56438: PPUSH
56439: EMPTY
56440: PPUSH
56441: CALL_OW 1
56445: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56446: LD_ADDR_EXP 46
56450: PUSH
56451: LD_EXP 46
56455: PPUSH
56456: LD_VAR 0 4
56460: PPUSH
56461: EMPTY
56462: PPUSH
56463: CALL_OW 1
56467: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56468: LD_ADDR_EXP 47
56472: PUSH
56473: LD_EXP 47
56477: PPUSH
56478: LD_VAR 0 4
56482: PPUSH
56483: EMPTY
56484: PPUSH
56485: CALL_OW 1
56489: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56490: LD_ADDR_EXP 48
56494: PUSH
56495: LD_EXP 48
56499: PPUSH
56500: LD_VAR 0 4
56504: PPUSH
56505: EMPTY
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56512: LD_ADDR_EXP 50
56516: PUSH
56517: LD_EXP 50
56521: PPUSH
56522: LD_VAR 0 4
56526: PPUSH
56527: EMPTY
56528: PPUSH
56529: CALL_OW 1
56533: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56534: LD_ADDR_EXP 52
56538: PUSH
56539: LD_EXP 52
56543: PPUSH
56544: LD_VAR 0 4
56548: PPUSH
56549: EMPTY
56550: PPUSH
56551: CALL_OW 1
56555: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56556: LD_ADDR_EXP 53
56560: PUSH
56561: LD_EXP 53
56565: PPUSH
56566: LD_VAR 0 4
56570: PPUSH
56571: EMPTY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56578: LD_ADDR_EXP 54
56582: PUSH
56583: LD_EXP 54
56587: PPUSH
56588: LD_VAR 0 4
56592: PPUSH
56593: EMPTY
56594: PPUSH
56595: CALL_OW 1
56599: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56600: LD_ADDR_EXP 55
56604: PUSH
56605: LD_EXP 55
56609: PPUSH
56610: LD_VAR 0 4
56614: PPUSH
56615: EMPTY
56616: PPUSH
56617: CALL_OW 1
56621: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56622: LD_ADDR_EXP 56
56626: PUSH
56627: LD_EXP 56
56631: PPUSH
56632: LD_VAR 0 4
56636: PPUSH
56637: EMPTY
56638: PPUSH
56639: CALL_OW 1
56643: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56644: LD_ADDR_EXP 57
56648: PUSH
56649: LD_EXP 57
56653: PPUSH
56654: LD_VAR 0 4
56658: PPUSH
56659: EMPTY
56660: PPUSH
56661: CALL_OW 1
56665: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56666: LD_ADDR_EXP 58
56670: PUSH
56671: LD_EXP 58
56675: PPUSH
56676: LD_VAR 0 4
56680: PPUSH
56681: EMPTY
56682: PPUSH
56683: CALL_OW 1
56687: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56688: LD_ADDR_EXP 59
56692: PUSH
56693: LD_EXP 59
56697: PPUSH
56698: LD_VAR 0 4
56702: PPUSH
56703: EMPTY
56704: PPUSH
56705: CALL_OW 1
56709: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56710: LD_ADDR_EXP 60
56714: PUSH
56715: LD_EXP 60
56719: PPUSH
56720: LD_VAR 0 4
56724: PPUSH
56725: EMPTY
56726: PPUSH
56727: CALL_OW 1
56731: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56732: LD_ADDR_EXP 61
56736: PUSH
56737: LD_EXP 61
56741: PPUSH
56742: LD_VAR 0 4
56746: PPUSH
56747: EMPTY
56748: PPUSH
56749: CALL_OW 1
56753: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56754: LD_ADDR_EXP 62
56758: PUSH
56759: LD_EXP 62
56763: PPUSH
56764: LD_VAR 0 4
56768: PPUSH
56769: EMPTY
56770: PPUSH
56771: CALL_OW 1
56775: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56776: LD_ADDR_EXP 63
56780: PUSH
56781: LD_EXP 63
56785: PPUSH
56786: LD_VAR 0 4
56790: PPUSH
56791: EMPTY
56792: PPUSH
56793: CALL_OW 1
56797: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56798: LD_ADDR_EXP 64
56802: PUSH
56803: LD_EXP 64
56807: PPUSH
56808: LD_VAR 0 4
56812: PPUSH
56813: EMPTY
56814: PPUSH
56815: CALL_OW 1
56819: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56820: LD_ADDR_EXP 65
56824: PUSH
56825: LD_EXP 65
56829: PPUSH
56830: LD_VAR 0 4
56834: PPUSH
56835: LD_INT 0
56837: PPUSH
56838: CALL_OW 1
56842: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56843: LD_ADDR_EXP 66
56847: PUSH
56848: LD_EXP 66
56852: PPUSH
56853: LD_VAR 0 4
56857: PPUSH
56858: LD_INT 0
56860: PPUSH
56861: CALL_OW 1
56865: ST_TO_ADDR
// result := base ;
56866: LD_ADDR_VAR 0 3
56870: PUSH
56871: LD_VAR 0 4
56875: ST_TO_ADDR
// end ;
56876: LD_VAR 0 3
56880: RET
// export function MC_Start ( ) ; var i ; begin
56881: LD_INT 0
56883: PPUSH
56884: PPUSH
// for i = 1 to mc_bases do
56885: LD_ADDR_VAR 0 2
56889: PUSH
56890: DOUBLE
56891: LD_INT 1
56893: DEC
56894: ST_TO_ADDR
56895: LD_EXP 23
56899: PUSH
56900: FOR_TO
56901: IFFALSE 58001
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56903: LD_ADDR_EXP 23
56907: PUSH
56908: LD_EXP 23
56912: PPUSH
56913: LD_VAR 0 2
56917: PPUSH
56918: LD_EXP 23
56922: PUSH
56923: LD_VAR 0 2
56927: ARRAY
56928: PUSH
56929: LD_INT 0
56931: DIFF
56932: PPUSH
56933: CALL_OW 1
56937: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56938: LD_ADDR_EXP 24
56942: PUSH
56943: LD_EXP 24
56947: PPUSH
56948: LD_VAR 0 2
56952: PPUSH
56953: EMPTY
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56960: LD_ADDR_EXP 25
56964: PUSH
56965: LD_EXP 25
56969: PPUSH
56970: LD_VAR 0 2
56974: PPUSH
56975: EMPTY
56976: PPUSH
56977: CALL_OW 1
56981: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56982: LD_ADDR_EXP 26
56986: PUSH
56987: LD_EXP 26
56991: PPUSH
56992: LD_VAR 0 2
56996: PPUSH
56997: EMPTY
56998: PPUSH
56999: CALL_OW 1
57003: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57004: LD_ADDR_EXP 27
57008: PUSH
57009: LD_EXP 27
57013: PPUSH
57014: LD_VAR 0 2
57018: PPUSH
57019: EMPTY
57020: PUSH
57021: EMPTY
57022: PUSH
57023: EMPTY
57024: LIST
57025: LIST
57026: PPUSH
57027: CALL_OW 1
57031: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57032: LD_ADDR_EXP 28
57036: PUSH
57037: LD_EXP 28
57041: PPUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: EMPTY
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57054: LD_ADDR_EXP 55
57058: PUSH
57059: LD_EXP 55
57063: PPUSH
57064: LD_VAR 0 2
57068: PPUSH
57069: EMPTY
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57076: LD_ADDR_EXP 29
57080: PUSH
57081: LD_EXP 29
57085: PPUSH
57086: LD_VAR 0 2
57090: PPUSH
57091: EMPTY
57092: PPUSH
57093: CALL_OW 1
57097: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57098: LD_ADDR_EXP 30
57102: PUSH
57103: LD_EXP 30
57107: PPUSH
57108: LD_VAR 0 2
57112: PPUSH
57113: EMPTY
57114: PPUSH
57115: CALL_OW 1
57119: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57120: LD_ADDR_EXP 31
57124: PUSH
57125: LD_EXP 31
57129: PPUSH
57130: LD_VAR 0 2
57134: PPUSH
57135: LD_EXP 23
57139: PUSH
57140: LD_VAR 0 2
57144: ARRAY
57145: PPUSH
57146: LD_INT 2
57148: PUSH
57149: LD_INT 30
57151: PUSH
57152: LD_INT 32
57154: PUSH
57155: EMPTY
57156: LIST
57157: LIST
57158: PUSH
57159: LD_INT 30
57161: PUSH
57162: LD_INT 33
57164: PUSH
57165: EMPTY
57166: LIST
57167: LIST
57168: PUSH
57169: EMPTY
57170: LIST
57171: LIST
57172: LIST
57173: PPUSH
57174: CALL_OW 72
57178: PPUSH
57179: CALL_OW 1
57183: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57184: LD_ADDR_EXP 32
57188: PUSH
57189: LD_EXP 32
57193: PPUSH
57194: LD_VAR 0 2
57198: PPUSH
57199: LD_EXP 23
57203: PUSH
57204: LD_VAR 0 2
57208: ARRAY
57209: PPUSH
57210: LD_INT 2
57212: PUSH
57213: LD_INT 30
57215: PUSH
57216: LD_INT 32
57218: PUSH
57219: EMPTY
57220: LIST
57221: LIST
57222: PUSH
57223: LD_INT 30
57225: PUSH
57226: LD_INT 31
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: EMPTY
57234: LIST
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 58
57240: PUSH
57241: EMPTY
57242: LIST
57243: PUSH
57244: EMPTY
57245: LIST
57246: LIST
57247: PPUSH
57248: CALL_OW 72
57252: PPUSH
57253: CALL_OW 1
57257: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57258: LD_ADDR_EXP 33
57262: PUSH
57263: LD_EXP 33
57267: PPUSH
57268: LD_VAR 0 2
57272: PPUSH
57273: EMPTY
57274: PPUSH
57275: CALL_OW 1
57279: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57280: LD_ADDR_EXP 37
57284: PUSH
57285: LD_EXP 37
57289: PPUSH
57290: LD_VAR 0 2
57294: PPUSH
57295: EMPTY
57296: PPUSH
57297: CALL_OW 1
57301: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57302: LD_ADDR_EXP 36
57306: PUSH
57307: LD_EXP 36
57311: PPUSH
57312: LD_VAR 0 2
57316: PPUSH
57317: EMPTY
57318: PPUSH
57319: CALL_OW 1
57323: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57324: LD_ADDR_EXP 38
57328: PUSH
57329: LD_EXP 38
57333: PPUSH
57334: LD_VAR 0 2
57338: PPUSH
57339: EMPTY
57340: PPUSH
57341: CALL_OW 1
57345: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57346: LD_ADDR_EXP 39
57350: PUSH
57351: LD_EXP 39
57355: PPUSH
57356: LD_VAR 0 2
57360: PPUSH
57361: EMPTY
57362: PPUSH
57363: CALL_OW 1
57367: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57368: LD_ADDR_EXP 40
57372: PUSH
57373: LD_EXP 40
57377: PPUSH
57378: LD_VAR 0 2
57382: PPUSH
57383: EMPTY
57384: PPUSH
57385: CALL_OW 1
57389: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57390: LD_ADDR_EXP 41
57394: PUSH
57395: LD_EXP 41
57399: PPUSH
57400: LD_VAR 0 2
57404: PPUSH
57405: EMPTY
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57412: LD_ADDR_EXP 42
57416: PUSH
57417: LD_EXP 42
57421: PPUSH
57422: LD_VAR 0 2
57426: PPUSH
57427: EMPTY
57428: PPUSH
57429: CALL_OW 1
57433: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57434: LD_ADDR_EXP 43
57438: PUSH
57439: LD_EXP 43
57443: PPUSH
57444: LD_VAR 0 2
57448: PPUSH
57449: EMPTY
57450: PPUSH
57451: CALL_OW 1
57455: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57456: LD_ADDR_EXP 44
57460: PUSH
57461: LD_EXP 44
57465: PPUSH
57466: LD_VAR 0 2
57470: PPUSH
57471: EMPTY
57472: PPUSH
57473: CALL_OW 1
57477: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57478: LD_ADDR_EXP 45
57482: PUSH
57483: LD_EXP 45
57487: PPUSH
57488: LD_VAR 0 2
57492: PPUSH
57493: EMPTY
57494: PPUSH
57495: CALL_OW 1
57499: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57500: LD_ADDR_EXP 34
57504: PUSH
57505: LD_EXP 34
57509: PPUSH
57510: LD_VAR 0 2
57514: PPUSH
57515: LD_INT 0
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57523: LD_ADDR_EXP 47
57527: PUSH
57528: LD_EXP 47
57532: PPUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: LD_INT 0
57540: PPUSH
57541: CALL_OW 1
57545: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57546: LD_ADDR_EXP 35
57550: PUSH
57551: LD_EXP 35
57555: PPUSH
57556: LD_VAR 0 2
57560: PPUSH
57561: EMPTY
57562: PPUSH
57563: CALL_OW 1
57567: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57568: LD_ADDR_EXP 46
57572: PUSH
57573: LD_EXP 46
57577: PPUSH
57578: LD_VAR 0 2
57582: PPUSH
57583: LD_INT 0
57585: PPUSH
57586: CALL_OW 1
57590: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57591: LD_ADDR_EXP 48
57595: PUSH
57596: LD_EXP 48
57600: PPUSH
57601: LD_VAR 0 2
57605: PPUSH
57606: EMPTY
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57613: LD_ADDR_EXP 51
57617: PUSH
57618: LD_EXP 51
57622: PPUSH
57623: LD_VAR 0 2
57627: PPUSH
57628: LD_INT 0
57630: PPUSH
57631: CALL_OW 1
57635: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57636: LD_ADDR_EXP 52
57640: PUSH
57641: LD_EXP 52
57645: PPUSH
57646: LD_VAR 0 2
57650: PPUSH
57651: EMPTY
57652: PPUSH
57653: CALL_OW 1
57657: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57658: LD_ADDR_EXP 53
57662: PUSH
57663: LD_EXP 53
57667: PPUSH
57668: LD_VAR 0 2
57672: PPUSH
57673: EMPTY
57674: PPUSH
57675: CALL_OW 1
57679: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57680: LD_ADDR_EXP 54
57684: PUSH
57685: LD_EXP 54
57689: PPUSH
57690: LD_VAR 0 2
57694: PPUSH
57695: EMPTY
57696: PPUSH
57697: CALL_OW 1
57701: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57702: LD_ADDR_EXP 56
57706: PUSH
57707: LD_EXP 56
57711: PPUSH
57712: LD_VAR 0 2
57716: PPUSH
57717: LD_EXP 23
57721: PUSH
57722: LD_VAR 0 2
57726: ARRAY
57727: PPUSH
57728: LD_INT 2
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 6
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: LD_INT 30
57743: PUSH
57744: LD_INT 7
57746: PUSH
57747: EMPTY
57748: LIST
57749: LIST
57750: PUSH
57751: LD_INT 30
57753: PUSH
57754: LD_INT 8
57756: PUSH
57757: EMPTY
57758: LIST
57759: LIST
57760: PUSH
57761: EMPTY
57762: LIST
57763: LIST
57764: LIST
57765: LIST
57766: PPUSH
57767: CALL_OW 72
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57777: LD_ADDR_EXP 57
57781: PUSH
57782: LD_EXP 57
57786: PPUSH
57787: LD_VAR 0 2
57791: PPUSH
57792: EMPTY
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57799: LD_ADDR_EXP 58
57803: PUSH
57804: LD_EXP 58
57808: PPUSH
57809: LD_VAR 0 2
57813: PPUSH
57814: EMPTY
57815: PPUSH
57816: CALL_OW 1
57820: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57821: LD_ADDR_EXP 59
57825: PUSH
57826: LD_EXP 59
57830: PPUSH
57831: LD_VAR 0 2
57835: PPUSH
57836: EMPTY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57843: LD_ADDR_EXP 60
57847: PUSH
57848: LD_EXP 60
57852: PPUSH
57853: LD_VAR 0 2
57857: PPUSH
57858: EMPTY
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57865: LD_ADDR_EXP 61
57869: PUSH
57870: LD_EXP 61
57874: PPUSH
57875: LD_VAR 0 2
57879: PPUSH
57880: EMPTY
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57887: LD_ADDR_EXP 62
57891: PUSH
57892: LD_EXP 62
57896: PPUSH
57897: LD_VAR 0 2
57901: PPUSH
57902: EMPTY
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57909: LD_ADDR_EXP 63
57913: PUSH
57914: LD_EXP 63
57918: PPUSH
57919: LD_VAR 0 2
57923: PPUSH
57924: EMPTY
57925: PPUSH
57926: CALL_OW 1
57930: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57931: LD_ADDR_EXP 64
57935: PUSH
57936: LD_EXP 64
57940: PPUSH
57941: LD_VAR 0 2
57945: PPUSH
57946: EMPTY
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57953: LD_ADDR_EXP 65
57957: PUSH
57958: LD_EXP 65
57962: PPUSH
57963: LD_VAR 0 2
57967: PPUSH
57968: LD_INT 0
57970: PPUSH
57971: CALL_OW 1
57975: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57976: LD_ADDR_EXP 66
57980: PUSH
57981: LD_EXP 66
57985: PPUSH
57986: LD_VAR 0 2
57990: PPUSH
57991: LD_INT 0
57993: PPUSH
57994: CALL_OW 1
57998: ST_TO_ADDR
// end ;
57999: GO 56900
58001: POP
58002: POP
// MC_InitSides ( ) ;
58003: CALL 58289 0 0
// MC_InitResearch ( ) ;
58007: CALL 58028 0 0
// CustomInitMacro ( ) ;
58011: CALL 273 0 0
// skirmish := true ;
58015: LD_ADDR_EXP 21
58019: PUSH
58020: LD_INT 1
58022: ST_TO_ADDR
// end ;
58023: LD_VAR 0 1
58027: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58028: LD_INT 0
58030: PPUSH
58031: PPUSH
58032: PPUSH
58033: PPUSH
58034: PPUSH
58035: PPUSH
// if not mc_bases then
58036: LD_EXP 23
58040: NOT
58041: IFFALSE 58045
// exit ;
58043: GO 58284
// for i = 1 to 8 do
58045: LD_ADDR_VAR 0 2
58049: PUSH
58050: DOUBLE
58051: LD_INT 1
58053: DEC
58054: ST_TO_ADDR
58055: LD_INT 8
58057: PUSH
58058: FOR_TO
58059: IFFALSE 58085
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58061: LD_ADDR_EXP 50
58065: PUSH
58066: LD_EXP 50
58070: PPUSH
58071: LD_VAR 0 2
58075: PPUSH
58076: EMPTY
58077: PPUSH
58078: CALL_OW 1
58082: ST_TO_ADDR
58083: GO 58058
58085: POP
58086: POP
// tmp := [ ] ;
58087: LD_ADDR_VAR 0 5
58091: PUSH
58092: EMPTY
58093: ST_TO_ADDR
// for i = 1 to mc_sides do
58094: LD_ADDR_VAR 0 2
58098: PUSH
58099: DOUBLE
58100: LD_INT 1
58102: DEC
58103: ST_TO_ADDR
58104: LD_EXP 49
58108: PUSH
58109: FOR_TO
58110: IFFALSE 58168
// if not mc_sides [ i ] in tmp then
58112: LD_EXP 49
58116: PUSH
58117: LD_VAR 0 2
58121: ARRAY
58122: PUSH
58123: LD_VAR 0 5
58127: IN
58128: NOT
58129: IFFALSE 58166
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58131: LD_ADDR_VAR 0 5
58135: PUSH
58136: LD_VAR 0 5
58140: PPUSH
58141: LD_VAR 0 5
58145: PUSH
58146: LD_INT 1
58148: PLUS
58149: PPUSH
58150: LD_EXP 49
58154: PUSH
58155: LD_VAR 0 2
58159: ARRAY
58160: PPUSH
58161: CALL_OW 2
58165: ST_TO_ADDR
58166: GO 58109
58168: POP
58169: POP
// if not tmp then
58170: LD_VAR 0 5
58174: NOT
58175: IFFALSE 58179
// exit ;
58177: GO 58284
// for j in tmp do
58179: LD_ADDR_VAR 0 3
58183: PUSH
58184: LD_VAR 0 5
58188: PUSH
58189: FOR_IN
58190: IFFALSE 58282
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58192: LD_ADDR_VAR 0 6
58196: PUSH
58197: LD_INT 22
58199: PUSH
58200: LD_VAR 0 3
58204: PUSH
58205: EMPTY
58206: LIST
58207: LIST
58208: PPUSH
58209: CALL_OW 69
58213: ST_TO_ADDR
// if not un then
58214: LD_VAR 0 6
58218: NOT
58219: IFFALSE 58223
// continue ;
58221: GO 58189
// nation := GetNation ( un [ 1 ] ) ;
58223: LD_ADDR_VAR 0 4
58227: PUSH
58228: LD_VAR 0 6
58232: PUSH
58233: LD_INT 1
58235: ARRAY
58236: PPUSH
58237: CALL_OW 248
58241: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58242: LD_ADDR_EXP 50
58246: PUSH
58247: LD_EXP 50
58251: PPUSH
58252: LD_VAR 0 3
58256: PPUSH
58257: LD_VAR 0 3
58261: PPUSH
58262: LD_VAR 0 4
58266: PPUSH
58267: LD_INT 1
58269: PPUSH
58270: CALL 11294 0 3
58274: PPUSH
58275: CALL_OW 1
58279: ST_TO_ADDR
// end ;
58280: GO 58189
58282: POP
58283: POP
// end ;
58284: LD_VAR 0 1
58288: RET
// export function MC_InitSides ( ) ; var i ; begin
58289: LD_INT 0
58291: PPUSH
58292: PPUSH
// if not mc_bases then
58293: LD_EXP 23
58297: NOT
58298: IFFALSE 58302
// exit ;
58300: GO 58376
// for i = 1 to mc_bases do
58302: LD_ADDR_VAR 0 2
58306: PUSH
58307: DOUBLE
58308: LD_INT 1
58310: DEC
58311: ST_TO_ADDR
58312: LD_EXP 23
58316: PUSH
58317: FOR_TO
58318: IFFALSE 58374
// if mc_bases [ i ] then
58320: LD_EXP 23
58324: PUSH
58325: LD_VAR 0 2
58329: ARRAY
58330: IFFALSE 58372
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58332: LD_ADDR_EXP 49
58336: PUSH
58337: LD_EXP 49
58341: PPUSH
58342: LD_VAR 0 2
58346: PPUSH
58347: LD_EXP 23
58351: PUSH
58352: LD_VAR 0 2
58356: ARRAY
58357: PUSH
58358: LD_INT 1
58360: ARRAY
58361: PPUSH
58362: CALL_OW 255
58366: PPUSH
58367: CALL_OW 1
58371: ST_TO_ADDR
58372: GO 58317
58374: POP
58375: POP
// end ;
58376: LD_VAR 0 1
58380: RET
// every 0 0$03 trigger skirmish do
58381: LD_EXP 21
58385: IFFALSE 58539
58387: GO 58389
58389: DISABLE
// begin enable ;
58390: ENABLE
// MC_CheckBuildings ( ) ;
58391: CALL 63097 0 0
// MC_CheckPeopleLife ( ) ;
58395: CALL 63258 0 0
// RaiseSailEvent ( 100 ) ;
58399: LD_INT 100
58401: PPUSH
58402: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58406: LD_INT 103
58408: PPUSH
58409: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58413: LD_INT 104
58415: PPUSH
58416: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58420: LD_INT 105
58422: PPUSH
58423: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58427: LD_INT 106
58429: PPUSH
58430: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58434: LD_INT 107
58436: PPUSH
58437: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58441: LD_INT 108
58443: PPUSH
58444: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58448: LD_INT 109
58450: PPUSH
58451: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58455: LD_INT 110
58457: PPUSH
58458: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58462: LD_INT 111
58464: PPUSH
58465: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58469: LD_INT 112
58471: PPUSH
58472: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58476: LD_INT 113
58478: PPUSH
58479: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58483: LD_INT 120
58485: PPUSH
58486: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58490: LD_INT 121
58492: PPUSH
58493: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58497: LD_INT 122
58499: PPUSH
58500: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58504: LD_INT 123
58506: PPUSH
58507: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58511: LD_INT 124
58513: PPUSH
58514: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58518: LD_INT 125
58520: PPUSH
58521: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58525: LD_INT 126
58527: PPUSH
58528: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58532: LD_INT 200
58534: PPUSH
58535: CALL_OW 427
// end ;
58539: END
// on SailEvent ( event ) do begin if event < 100 then
58540: LD_VAR 0 1
58544: PUSH
58545: LD_INT 100
58547: LESS
58548: IFFALSE 58559
// CustomEvent ( event ) ;
58550: LD_VAR 0 1
58554: PPUSH
58555: CALL 10353 0 1
// if event = 100 then
58559: LD_VAR 0 1
58563: PUSH
58564: LD_INT 100
58566: EQUAL
58567: IFFALSE 58573
// MC_ClassManager ( ) ;
58569: CALL 58967 0 0
// if event = 101 then
58573: LD_VAR 0 1
58577: PUSH
58578: LD_INT 101
58580: EQUAL
58581: IFFALSE 58587
// MC_RepairBuildings ( ) ;
58583: CALL 63845 0 0
// if event = 102 then
58587: LD_VAR 0 1
58591: PUSH
58592: LD_INT 102
58594: EQUAL
58595: IFFALSE 58601
// MC_Heal ( ) ;
58597: CALL 64784 0 0
// if event = 103 then
58601: LD_VAR 0 1
58605: PUSH
58606: LD_INT 103
58608: EQUAL
58609: IFFALSE 58615
// MC_Build ( ) ;
58611: CALL 65210 0 0
// if event = 104 then
58615: LD_VAR 0 1
58619: PUSH
58620: LD_INT 104
58622: EQUAL
58623: IFFALSE 58629
// MC_TurretWeapon ( ) ;
58625: CALL 66858 0 0
// if event = 105 then
58629: LD_VAR 0 1
58633: PUSH
58634: LD_INT 105
58636: EQUAL
58637: IFFALSE 58643
// MC_BuildUpgrade ( ) ;
58639: CALL 66403 0 0
// if event = 106 then
58643: LD_VAR 0 1
58647: PUSH
58648: LD_INT 106
58650: EQUAL
58651: IFFALSE 58657
// MC_PlantMines ( ) ;
58653: CALL 67290 0 0
// if event = 107 then
58657: LD_VAR 0 1
58661: PUSH
58662: LD_INT 107
58664: EQUAL
58665: IFFALSE 58671
// MC_CollectCrates ( ) ;
58667: CALL 68100 0 0
// if event = 108 then
58671: LD_VAR 0 1
58675: PUSH
58676: LD_INT 108
58678: EQUAL
58679: IFFALSE 58685
// MC_LinkRemoteControl ( ) ;
58681: CALL 69974 0 0
// if event = 109 then
58685: LD_VAR 0 1
58689: PUSH
58690: LD_INT 109
58692: EQUAL
58693: IFFALSE 58699
// MC_ProduceVehicle ( ) ;
58695: CALL 70159 0 0
// if event = 110 then
58699: LD_VAR 0 1
58703: PUSH
58704: LD_INT 110
58706: EQUAL
58707: IFFALSE 58713
// MC_SendAttack ( ) ;
58709: CALL 70629 0 0
// if event = 111 then
58713: LD_VAR 0 1
58717: PUSH
58718: LD_INT 111
58720: EQUAL
58721: IFFALSE 58727
// MC_Defend ( ) ;
58723: CALL 70737 0 0
// if event = 112 then
58727: LD_VAR 0 1
58731: PUSH
58732: LD_INT 112
58734: EQUAL
58735: IFFALSE 58741
// MC_Research ( ) ;
58737: CALL 71637 0 0
// if event = 113 then
58741: LD_VAR 0 1
58745: PUSH
58746: LD_INT 113
58748: EQUAL
58749: IFFALSE 58755
// MC_MinesTrigger ( ) ;
58751: CALL 72777 0 0
// if event = 120 then
58755: LD_VAR 0 1
58759: PUSH
58760: LD_INT 120
58762: EQUAL
58763: IFFALSE 58769
// MC_RepairVehicle ( ) ;
58765: CALL 72878 0 0
// if event = 121 then
58769: LD_VAR 0 1
58773: PUSH
58774: LD_INT 121
58776: EQUAL
58777: IFFALSE 58783
// MC_TameApe ( ) ;
58779: CALL 73655 0 0
// if event = 122 then
58783: LD_VAR 0 1
58787: PUSH
58788: LD_INT 122
58790: EQUAL
58791: IFFALSE 58797
// MC_ChangeApeClass ( ) ;
58793: CALL 74500 0 0
// if event = 123 then
58797: LD_VAR 0 1
58801: PUSH
58802: LD_INT 123
58804: EQUAL
58805: IFFALSE 58811
// MC_Bazooka ( ) ;
58807: CALL 75156 0 0
// if event = 124 then
58811: LD_VAR 0 1
58815: PUSH
58816: LD_INT 124
58818: EQUAL
58819: IFFALSE 58825
// MC_TeleportExit ( ) ;
58821: CALL 75358 0 0
// if event = 125 then
58825: LD_VAR 0 1
58829: PUSH
58830: LD_INT 125
58832: EQUAL
58833: IFFALSE 58839
// MC_Deposits ( ) ;
58835: CALL 76015 0 0
// if event = 126 then
58839: LD_VAR 0 1
58843: PUSH
58844: LD_INT 126
58846: EQUAL
58847: IFFALSE 58853
// MC_RemoteDriver ( ) ;
58849: CALL 76648 0 0
// if event = 200 then
58853: LD_VAR 0 1
58857: PUSH
58858: LD_INT 200
58860: EQUAL
58861: IFFALSE 58867
// MC_Idle ( ) ;
58863: CALL 78583 0 0
// end ;
58867: PPOPN 1
58869: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58870: LD_INT 0
58872: PPUSH
58873: PPUSH
// if not mc_bases [ base ] or not tag then
58874: LD_EXP 23
58878: PUSH
58879: LD_VAR 0 1
58883: ARRAY
58884: NOT
58885: IFTRUE 58894
58887: PUSH
58888: LD_VAR 0 2
58892: NOT
58893: OR
58894: IFFALSE 58898
// exit ;
58896: GO 58962
// for i in mc_bases [ base ] union mc_ape [ base ] do
58898: LD_ADDR_VAR 0 4
58902: PUSH
58903: LD_EXP 23
58907: PUSH
58908: LD_VAR 0 1
58912: ARRAY
58913: PUSH
58914: LD_EXP 52
58918: PUSH
58919: LD_VAR 0 1
58923: ARRAY
58924: UNION
58925: PUSH
58926: FOR_IN
58927: IFFALSE 58960
// if GetTag ( i ) = tag then
58929: LD_VAR 0 4
58933: PPUSH
58934: CALL_OW 110
58938: PUSH
58939: LD_VAR 0 2
58943: EQUAL
58944: IFFALSE 58958
// SetTag ( i , 0 ) ;
58946: LD_VAR 0 4
58950: PPUSH
58951: LD_INT 0
58953: PPUSH
58954: CALL_OW 109
58958: GO 58926
58960: POP
58961: POP
// end ;
58962: LD_VAR 0 3
58966: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58967: LD_INT 0
58969: PPUSH
58970: PPUSH
58971: PPUSH
58972: PPUSH
58973: PPUSH
58974: PPUSH
58975: PPUSH
58976: PPUSH
// if not mc_bases then
58977: LD_EXP 23
58981: NOT
58982: IFFALSE 58986
// exit ;
58984: GO 59437
// for i = 1 to mc_bases do
58986: LD_ADDR_VAR 0 2
58990: PUSH
58991: DOUBLE
58992: LD_INT 1
58994: DEC
58995: ST_TO_ADDR
58996: LD_EXP 23
59000: PUSH
59001: FOR_TO
59002: IFFALSE 59435
// begin tmp := MC_ClassCheckReq ( i ) ;
59004: LD_ADDR_VAR 0 4
59008: PUSH
59009: LD_VAR 0 2
59013: PPUSH
59014: CALL 59442 0 1
59018: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59019: LD_ADDR_EXP 64
59023: PUSH
59024: LD_EXP 64
59028: PPUSH
59029: LD_VAR 0 2
59033: PPUSH
59034: LD_VAR 0 4
59038: PPUSH
59039: CALL_OW 1
59043: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59044: LD_ADDR_VAR 0 6
59048: PUSH
59049: LD_EXP 23
59053: PUSH
59054: LD_VAR 0 2
59058: ARRAY
59059: PPUSH
59060: LD_INT 2
59062: PUSH
59063: LD_INT 30
59065: PUSH
59066: LD_INT 4
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PUSH
59073: LD_INT 30
59075: PUSH
59076: LD_INT 5
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: PUSH
59083: EMPTY
59084: LIST
59085: LIST
59086: LIST
59087: PPUSH
59088: CALL_OW 72
59092: PUSH
59093: LD_EXP 23
59097: PUSH
59098: LD_VAR 0 2
59102: ARRAY
59103: PPUSH
59104: LD_INT 2
59106: PUSH
59107: LD_INT 30
59109: PUSH
59110: LD_INT 0
59112: PUSH
59113: EMPTY
59114: LIST
59115: LIST
59116: PUSH
59117: LD_INT 30
59119: PUSH
59120: LD_INT 1
59122: PUSH
59123: EMPTY
59124: LIST
59125: LIST
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: LIST
59131: PPUSH
59132: CALL_OW 72
59136: PUSH
59137: LD_EXP 23
59141: PUSH
59142: LD_VAR 0 2
59146: ARRAY
59147: PPUSH
59148: LD_INT 30
59150: PUSH
59151: LD_INT 3
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: PPUSH
59158: CALL_OW 72
59162: PUSH
59163: LD_EXP 23
59167: PUSH
59168: LD_VAR 0 2
59172: ARRAY
59173: PPUSH
59174: LD_INT 2
59176: PUSH
59177: LD_INT 30
59179: PUSH
59180: LD_INT 6
59182: PUSH
59183: EMPTY
59184: LIST
59185: LIST
59186: PUSH
59187: LD_INT 30
59189: PUSH
59190: LD_INT 7
59192: PUSH
59193: EMPTY
59194: LIST
59195: LIST
59196: PUSH
59197: LD_INT 30
59199: PUSH
59200: LD_INT 8
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: LIST
59212: PPUSH
59213: CALL_OW 72
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: LIST
59222: LIST
59223: ST_TO_ADDR
// for j := 1 to 4 do
59224: LD_ADDR_VAR 0 3
59228: PUSH
59229: DOUBLE
59230: LD_INT 1
59232: DEC
59233: ST_TO_ADDR
59234: LD_INT 4
59236: PUSH
59237: FOR_TO
59238: IFFALSE 59431
// begin if not tmp [ j ] then
59240: LD_VAR 0 4
59244: PUSH
59245: LD_VAR 0 3
59249: ARRAY
59250: NOT
59251: IFFALSE 59255
// continue ;
59253: GO 59237
// for p in tmp [ j ] do
59255: LD_ADDR_VAR 0 5
59259: PUSH
59260: LD_VAR 0 4
59264: PUSH
59265: LD_VAR 0 3
59269: ARRAY
59270: PUSH
59271: FOR_IN
59272: IFFALSE 59427
// begin if not b [ j ] then
59274: LD_VAR 0 6
59278: PUSH
59279: LD_VAR 0 3
59283: ARRAY
59284: NOT
59285: IFFALSE 59289
// break ;
59287: GO 59427
// e := 0 ;
59289: LD_ADDR_VAR 0 7
59293: PUSH
59294: LD_INT 0
59296: ST_TO_ADDR
// for k in b [ j ] do
59297: LD_ADDR_VAR 0 8
59301: PUSH
59302: LD_VAR 0 6
59306: PUSH
59307: LD_VAR 0 3
59311: ARRAY
59312: PUSH
59313: FOR_IN
59314: IFFALSE 59341
// if IsNotFull ( k ) then
59316: LD_VAR 0 8
59320: PPUSH
59321: CALL 13453 0 1
59325: IFFALSE 59339
// begin e := k ;
59327: LD_ADDR_VAR 0 7
59331: PUSH
59332: LD_VAR 0 8
59336: ST_TO_ADDR
// break ;
59337: GO 59341
// end ;
59339: GO 59313
59341: POP
59342: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59343: LD_VAR 0 7
59347: IFFALSE 59366
59349: PUSH
59350: LD_VAR 0 5
59354: PPUSH
59355: LD_VAR 0 7
59359: PPUSH
59360: CALL 47957 0 2
59364: NOT
59365: AND
59366: IFFALSE 59425
// begin if IsInUnit ( p ) then
59368: LD_VAR 0 5
59372: PPUSH
59373: CALL_OW 310
59377: IFFALSE 59388
// ComExitBuilding ( p ) ;
59379: LD_VAR 0 5
59383: PPUSH
59384: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59388: LD_VAR 0 5
59392: PPUSH
59393: LD_VAR 0 7
59397: PPUSH
59398: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59402: LD_VAR 0 5
59406: PPUSH
59407: LD_VAR 0 3
59411: PPUSH
59412: CALL_OW 183
// AddComExitBuilding ( p ) ;
59416: LD_VAR 0 5
59420: PPUSH
59421: CALL_OW 182
// end ; end ;
59425: GO 59271
59427: POP
59428: POP
// end ;
59429: GO 59237
59431: POP
59432: POP
// end ;
59433: GO 59001
59435: POP
59436: POP
// end ;
59437: LD_VAR 0 1
59441: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59442: LD_INT 0
59444: PPUSH
59445: PPUSH
59446: PPUSH
59447: PPUSH
59448: PPUSH
59449: PPUSH
59450: PPUSH
59451: PPUSH
59452: PPUSH
59453: PPUSH
59454: PPUSH
59455: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59456: LD_ADDR_VAR 0 2
59460: PUSH
59461: LD_INT 0
59463: PUSH
59464: LD_INT 0
59466: PUSH
59467: LD_INT 0
59469: PUSH
59470: LD_INT 0
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: LIST
59477: LIST
59478: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59479: LD_VAR 0 1
59483: NOT
59484: IFTRUE 59499
59486: PUSH
59487: LD_EXP 23
59491: PUSH
59492: LD_VAR 0 1
59496: ARRAY
59497: NOT
59498: OR
59499: IFTRUE 59547
59501: PUSH
59502: LD_EXP 23
59506: PUSH
59507: LD_VAR 0 1
59511: ARRAY
59512: PPUSH
59513: LD_INT 2
59515: PUSH
59516: LD_INT 30
59518: PUSH
59519: LD_INT 0
59521: PUSH
59522: EMPTY
59523: LIST
59524: LIST
59525: PUSH
59526: LD_INT 30
59528: PUSH
59529: LD_INT 1
59531: PUSH
59532: EMPTY
59533: LIST
59534: LIST
59535: PUSH
59536: EMPTY
59537: LIST
59538: LIST
59539: LIST
59540: PPUSH
59541: CALL_OW 72
59545: NOT
59546: OR
59547: IFFALSE 59551
// exit ;
59549: GO 63092
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59551: LD_ADDR_VAR 0 4
59555: PUSH
59556: LD_EXP 23
59560: PUSH
59561: LD_VAR 0 1
59565: ARRAY
59566: PPUSH
59567: LD_INT 2
59569: PUSH
59570: LD_INT 25
59572: PUSH
59573: LD_INT 1
59575: PUSH
59576: EMPTY
59577: LIST
59578: LIST
59579: PUSH
59580: LD_INT 25
59582: PUSH
59583: LD_INT 2
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: PUSH
59590: LD_INT 25
59592: PUSH
59593: LD_INT 3
59595: PUSH
59596: EMPTY
59597: LIST
59598: LIST
59599: PUSH
59600: LD_INT 25
59602: PUSH
59603: LD_INT 4
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: PUSH
59610: LD_INT 25
59612: PUSH
59613: LD_INT 5
59615: PUSH
59616: EMPTY
59617: LIST
59618: LIST
59619: PUSH
59620: LD_INT 25
59622: PUSH
59623: LD_INT 8
59625: PUSH
59626: EMPTY
59627: LIST
59628: LIST
59629: PUSH
59630: LD_INT 25
59632: PUSH
59633: LD_INT 9
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: LIST
59644: LIST
59645: LIST
59646: LIST
59647: LIST
59648: LIST
59649: PPUSH
59650: CALL_OW 72
59654: ST_TO_ADDR
// if not tmp then
59655: LD_VAR 0 4
59659: NOT
59660: IFFALSE 59664
// exit ;
59662: GO 63092
// for i in tmp do
59664: LD_ADDR_VAR 0 3
59668: PUSH
59669: LD_VAR 0 4
59673: PUSH
59674: FOR_IN
59675: IFFALSE 59706
// if GetTag ( i ) then
59677: LD_VAR 0 3
59681: PPUSH
59682: CALL_OW 110
59686: IFFALSE 59704
// tmp := tmp diff i ;
59688: LD_ADDR_VAR 0 4
59692: PUSH
59693: LD_VAR 0 4
59697: PUSH
59698: LD_VAR 0 3
59702: DIFF
59703: ST_TO_ADDR
59704: GO 59674
59706: POP
59707: POP
// if not tmp then
59708: LD_VAR 0 4
59712: NOT
59713: IFFALSE 59717
// exit ;
59715: GO 63092
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59717: LD_ADDR_VAR 0 5
59721: PUSH
59722: LD_EXP 23
59726: PUSH
59727: LD_VAR 0 1
59731: ARRAY
59732: PPUSH
59733: LD_INT 2
59735: PUSH
59736: LD_INT 25
59738: PUSH
59739: LD_INT 1
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: PUSH
59746: LD_INT 25
59748: PUSH
59749: LD_INT 5
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: LD_INT 25
59758: PUSH
59759: LD_INT 8
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: LD_INT 25
59768: PUSH
59769: LD_INT 9
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: LIST
59780: LIST
59781: LIST
59782: PPUSH
59783: CALL_OW 72
59787: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59788: LD_ADDR_VAR 0 6
59792: PUSH
59793: LD_EXP 23
59797: PUSH
59798: LD_VAR 0 1
59802: ARRAY
59803: PPUSH
59804: LD_INT 25
59806: PUSH
59807: LD_INT 2
59809: PUSH
59810: EMPTY
59811: LIST
59812: LIST
59813: PPUSH
59814: CALL_OW 72
59818: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59819: LD_ADDR_VAR 0 7
59823: PUSH
59824: LD_EXP 23
59828: PUSH
59829: LD_VAR 0 1
59833: ARRAY
59834: PPUSH
59835: LD_INT 25
59837: PUSH
59838: LD_INT 3
59840: PUSH
59841: EMPTY
59842: LIST
59843: LIST
59844: PPUSH
59845: CALL_OW 72
59849: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59850: LD_ADDR_VAR 0 8
59854: PUSH
59855: LD_EXP 23
59859: PUSH
59860: LD_VAR 0 1
59864: ARRAY
59865: PPUSH
59866: LD_INT 25
59868: PUSH
59869: LD_INT 4
59871: PUSH
59872: EMPTY
59873: LIST
59874: LIST
59875: PUSH
59876: LD_INT 24
59878: PUSH
59879: LD_INT 251
59881: PUSH
59882: EMPTY
59883: LIST
59884: LIST
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: PPUSH
59890: CALL_OW 72
59894: ST_TO_ADDR
// if mc_is_defending [ base ] then
59895: LD_EXP 66
59899: PUSH
59900: LD_VAR 0 1
59904: ARRAY
59905: IFFALSE 60366
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59907: LD_ADDR_EXP 65
59911: PUSH
59912: LD_EXP 65
59916: PPUSH
59917: LD_VAR 0 1
59921: PPUSH
59922: LD_INT 4
59924: PPUSH
59925: CALL_OW 1
59929: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59930: LD_ADDR_VAR 0 12
59934: PUSH
59935: LD_EXP 23
59939: PUSH
59940: LD_VAR 0 1
59944: ARRAY
59945: PPUSH
59946: LD_INT 2
59948: PUSH
59949: LD_INT 30
59951: PUSH
59952: LD_INT 4
59954: PUSH
59955: EMPTY
59956: LIST
59957: LIST
59958: PUSH
59959: LD_INT 30
59961: PUSH
59962: LD_INT 5
59964: PUSH
59965: EMPTY
59966: LIST
59967: LIST
59968: PUSH
59969: EMPTY
59970: LIST
59971: LIST
59972: LIST
59973: PPUSH
59974: CALL_OW 72
59978: ST_TO_ADDR
// if not b then
59979: LD_VAR 0 12
59983: NOT
59984: IFFALSE 59988
// exit ;
59986: GO 63092
// p := [ ] ;
59988: LD_ADDR_VAR 0 11
59992: PUSH
59993: EMPTY
59994: ST_TO_ADDR
// if sci >= 2 then
59995: LD_VAR 0 8
59999: PUSH
60000: LD_INT 2
60002: GREATEREQUAL
60003: IFFALSE 60034
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60005: LD_ADDR_VAR 0 8
60009: PUSH
60010: LD_VAR 0 8
60014: PUSH
60015: LD_INT 1
60017: ARRAY
60018: PUSH
60019: LD_VAR 0 8
60023: PUSH
60024: LD_INT 2
60026: ARRAY
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: ST_TO_ADDR
60032: GO 60095
// if sci = 1 then
60034: LD_VAR 0 8
60038: PUSH
60039: LD_INT 1
60041: EQUAL
60042: IFFALSE 60063
// sci := [ sci [ 1 ] ] else
60044: LD_ADDR_VAR 0 8
60048: PUSH
60049: LD_VAR 0 8
60053: PUSH
60054: LD_INT 1
60056: ARRAY
60057: PUSH
60058: EMPTY
60059: LIST
60060: ST_TO_ADDR
60061: GO 60095
// if sci = 0 then
60063: LD_VAR 0 8
60067: PUSH
60068: LD_INT 0
60070: EQUAL
60071: IFFALSE 60095
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60073: LD_ADDR_VAR 0 11
60077: PUSH
60078: LD_VAR 0 4
60082: PPUSH
60083: LD_INT 4
60085: PPUSH
60086: CALL 47827 0 2
60090: PUSH
60091: LD_INT 1
60093: ARRAY
60094: ST_TO_ADDR
// if eng > 4 then
60095: LD_VAR 0 6
60099: PUSH
60100: LD_INT 4
60102: GREATER
60103: IFFALSE 60149
// for i = eng downto 4 do
60105: LD_ADDR_VAR 0 3
60109: PUSH
60110: DOUBLE
60111: LD_VAR 0 6
60115: INC
60116: ST_TO_ADDR
60117: LD_INT 4
60119: PUSH
60120: FOR_DOWNTO
60121: IFFALSE 60147
// eng := eng diff eng [ i ] ;
60123: LD_ADDR_VAR 0 6
60127: PUSH
60128: LD_VAR 0 6
60132: PUSH
60133: LD_VAR 0 6
60137: PUSH
60138: LD_VAR 0 3
60142: ARRAY
60143: DIFF
60144: ST_TO_ADDR
60145: GO 60120
60147: POP
60148: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60149: LD_ADDR_VAR 0 4
60153: PUSH
60154: LD_VAR 0 4
60158: PUSH
60159: LD_VAR 0 5
60163: PUSH
60164: LD_VAR 0 6
60168: UNION
60169: PUSH
60170: LD_VAR 0 7
60174: UNION
60175: PUSH
60176: LD_VAR 0 8
60180: UNION
60181: DIFF
60182: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60183: LD_ADDR_VAR 0 13
60187: PUSH
60188: LD_EXP 23
60192: PUSH
60193: LD_VAR 0 1
60197: ARRAY
60198: PPUSH
60199: LD_INT 2
60201: PUSH
60202: LD_INT 30
60204: PUSH
60205: LD_INT 32
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 31
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: EMPTY
60223: LIST
60224: LIST
60225: LIST
60226: PPUSH
60227: CALL_OW 72
60231: PUSH
60232: LD_EXP 23
60236: PUSH
60237: LD_VAR 0 1
60241: ARRAY
60242: PPUSH
60243: LD_INT 2
60245: PUSH
60246: LD_INT 30
60248: PUSH
60249: LD_INT 4
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: PUSH
60256: LD_INT 30
60258: PUSH
60259: LD_INT 5
60261: PUSH
60262: EMPTY
60263: LIST
60264: LIST
60265: PUSH
60266: EMPTY
60267: LIST
60268: LIST
60269: LIST
60270: PPUSH
60271: CALL_OW 72
60275: PUSH
60276: LD_INT 6
60278: MUL
60279: PLUS
60280: ST_TO_ADDR
// if bcount < tmp then
60281: LD_VAR 0 13
60285: PUSH
60286: LD_VAR 0 4
60290: LESS
60291: IFFALSE 60337
// for i = tmp downto bcount do
60293: LD_ADDR_VAR 0 3
60297: PUSH
60298: DOUBLE
60299: LD_VAR 0 4
60303: INC
60304: ST_TO_ADDR
60305: LD_VAR 0 13
60309: PUSH
60310: FOR_DOWNTO
60311: IFFALSE 60335
// tmp := Delete ( tmp , tmp ) ;
60313: LD_ADDR_VAR 0 4
60317: PUSH
60318: LD_VAR 0 4
60322: PPUSH
60323: LD_VAR 0 4
60327: PPUSH
60328: CALL_OW 3
60332: ST_TO_ADDR
60333: GO 60310
60335: POP
60336: POP
// result := [ tmp , 0 , 0 , p ] ;
60337: LD_ADDR_VAR 0 2
60341: PUSH
60342: LD_VAR 0 4
60346: PUSH
60347: LD_INT 0
60349: PUSH
60350: LD_INT 0
60352: PUSH
60353: LD_VAR 0 11
60357: PUSH
60358: EMPTY
60359: LIST
60360: LIST
60361: LIST
60362: LIST
60363: ST_TO_ADDR
// exit ;
60364: GO 63092
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60366: LD_EXP 23
60370: PUSH
60371: LD_VAR 0 1
60375: ARRAY
60376: PPUSH
60377: LD_INT 2
60379: PUSH
60380: LD_INT 30
60382: PUSH
60383: LD_INT 6
60385: PUSH
60386: EMPTY
60387: LIST
60388: LIST
60389: PUSH
60390: LD_INT 30
60392: PUSH
60393: LD_INT 7
60395: PUSH
60396: EMPTY
60397: LIST
60398: LIST
60399: PUSH
60400: LD_INT 30
60402: PUSH
60403: LD_INT 8
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PUSH
60410: EMPTY
60411: LIST
60412: LIST
60413: LIST
60414: LIST
60415: PPUSH
60416: CALL_OW 72
60420: NOT
60421: IFFALSE 60451
60423: PUSH
60424: LD_EXP 23
60428: PUSH
60429: LD_VAR 0 1
60433: ARRAY
60434: PPUSH
60435: LD_INT 30
60437: PUSH
60438: LD_INT 3
60440: PUSH
60441: EMPTY
60442: LIST
60443: LIST
60444: PPUSH
60445: CALL_OW 72
60449: NOT
60450: AND
60451: IFFALSE 60523
// begin if eng = tmp then
60453: LD_VAR 0 6
60457: PUSH
60458: LD_VAR 0 4
60462: EQUAL
60463: IFFALSE 60467
// exit ;
60465: GO 63092
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60467: LD_ADDR_EXP 65
60471: PUSH
60472: LD_EXP 65
60476: PPUSH
60477: LD_VAR 0 1
60481: PPUSH
60482: LD_INT 1
60484: PPUSH
60485: CALL_OW 1
60489: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60490: LD_ADDR_VAR 0 2
60494: PUSH
60495: LD_INT 0
60497: PUSH
60498: LD_VAR 0 4
60502: PUSH
60503: LD_VAR 0 6
60507: DIFF
60508: PUSH
60509: LD_INT 0
60511: PUSH
60512: LD_INT 0
60514: PUSH
60515: EMPTY
60516: LIST
60517: LIST
60518: LIST
60519: LIST
60520: ST_TO_ADDR
// exit ;
60521: GO 63092
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60523: LD_EXP 50
60527: PUSH
60528: LD_EXP 49
60532: PUSH
60533: LD_VAR 0 1
60537: ARRAY
60538: ARRAY
60539: IFFALSE 60597
60541: PUSH
60542: LD_EXP 23
60546: PUSH
60547: LD_VAR 0 1
60551: ARRAY
60552: PPUSH
60553: LD_INT 2
60555: PUSH
60556: LD_INT 30
60558: PUSH
60559: LD_INT 6
60561: PUSH
60562: EMPTY
60563: LIST
60564: LIST
60565: PUSH
60566: LD_INT 30
60568: PUSH
60569: LD_INT 7
60571: PUSH
60572: EMPTY
60573: LIST
60574: LIST
60575: PUSH
60576: LD_INT 30
60578: PUSH
60579: LD_INT 8
60581: PUSH
60582: EMPTY
60583: LIST
60584: LIST
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: LIST
60590: LIST
60591: PPUSH
60592: CALL_OW 72
60596: AND
60597: IFFALSE 60627
60599: PUSH
60600: LD_EXP 23
60604: PUSH
60605: LD_VAR 0 1
60609: ARRAY
60610: PPUSH
60611: LD_INT 30
60613: PUSH
60614: LD_INT 3
60616: PUSH
60617: EMPTY
60618: LIST
60619: LIST
60620: PPUSH
60621: CALL_OW 72
60625: NOT
60626: AND
60627: IFFALSE 60843
// begin if sci >= 6 then
60629: LD_VAR 0 8
60633: PUSH
60634: LD_INT 6
60636: GREATEREQUAL
60637: IFFALSE 60641
// exit ;
60639: GO 63092
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60641: LD_ADDR_EXP 65
60645: PUSH
60646: LD_EXP 65
60650: PPUSH
60651: LD_VAR 0 1
60655: PPUSH
60656: LD_INT 2
60658: PPUSH
60659: CALL_OW 1
60663: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60664: LD_ADDR_VAR 0 9
60668: PUSH
60669: LD_VAR 0 4
60673: PUSH
60674: LD_VAR 0 8
60678: DIFF
60679: PPUSH
60680: LD_INT 4
60682: PPUSH
60683: CALL 47827 0 2
60687: ST_TO_ADDR
// p := [ ] ;
60688: LD_ADDR_VAR 0 11
60692: PUSH
60693: EMPTY
60694: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60695: LD_VAR 0 8
60699: PUSH
60700: LD_INT 6
60702: LESS
60703: IFFALSE 60715
60705: PUSH
60706: LD_VAR 0 9
60710: PUSH
60711: LD_INT 6
60713: GREATER
60714: AND
60715: IFFALSE 60796
// begin for i = 1 to 6 - sci do
60717: LD_ADDR_VAR 0 3
60721: PUSH
60722: DOUBLE
60723: LD_INT 1
60725: DEC
60726: ST_TO_ADDR
60727: LD_INT 6
60729: PUSH
60730: LD_VAR 0 8
60734: MINUS
60735: PUSH
60736: FOR_TO
60737: IFFALSE 60792
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60739: LD_ADDR_VAR 0 11
60743: PUSH
60744: LD_VAR 0 11
60748: PPUSH
60749: LD_VAR 0 11
60753: PUSH
60754: LD_INT 1
60756: PLUS
60757: PPUSH
60758: LD_VAR 0 9
60762: PUSH
60763: LD_INT 1
60765: ARRAY
60766: PPUSH
60767: CALL_OW 2
60771: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60772: LD_ADDR_VAR 0 9
60776: PUSH
60777: LD_VAR 0 9
60781: PPUSH
60782: LD_INT 1
60784: PPUSH
60785: CALL_OW 3
60789: ST_TO_ADDR
// end ;
60790: GO 60736
60792: POP
60793: POP
// end else
60794: GO 60816
// if sort then
60796: LD_VAR 0 9
60800: IFFALSE 60816
// p := sort [ 1 ] ;
60802: LD_ADDR_VAR 0 11
60806: PUSH
60807: LD_VAR 0 9
60811: PUSH
60812: LD_INT 1
60814: ARRAY
60815: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60816: LD_ADDR_VAR 0 2
60820: PUSH
60821: LD_INT 0
60823: PUSH
60824: LD_INT 0
60826: PUSH
60827: LD_INT 0
60829: PUSH
60830: LD_VAR 0 11
60834: PUSH
60835: EMPTY
60836: LIST
60837: LIST
60838: LIST
60839: LIST
60840: ST_TO_ADDR
// exit ;
60841: GO 63092
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60843: LD_EXP 50
60847: PUSH
60848: LD_EXP 49
60852: PUSH
60853: LD_VAR 0 1
60857: ARRAY
60858: ARRAY
60859: IFFALSE 60917
60861: PUSH
60862: LD_EXP 23
60866: PUSH
60867: LD_VAR 0 1
60871: ARRAY
60872: PPUSH
60873: LD_INT 2
60875: PUSH
60876: LD_INT 30
60878: PUSH
60879: LD_INT 6
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PUSH
60886: LD_INT 30
60888: PUSH
60889: LD_INT 7
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: LD_INT 30
60898: PUSH
60899: LD_INT 8
60901: PUSH
60902: EMPTY
60903: LIST
60904: LIST
60905: PUSH
60906: EMPTY
60907: LIST
60908: LIST
60909: LIST
60910: LIST
60911: PPUSH
60912: CALL_OW 72
60916: AND
60917: IFFALSE 60946
60919: PUSH
60920: LD_EXP 23
60924: PUSH
60925: LD_VAR 0 1
60929: ARRAY
60930: PPUSH
60931: LD_INT 30
60933: PUSH
60934: LD_INT 3
60936: PUSH
60937: EMPTY
60938: LIST
60939: LIST
60940: PPUSH
60941: CALL_OW 72
60945: AND
60946: IFFALSE 61686
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60948: LD_ADDR_EXP 65
60952: PUSH
60953: LD_EXP 65
60957: PPUSH
60958: LD_VAR 0 1
60962: PPUSH
60963: LD_INT 3
60965: PPUSH
60966: CALL_OW 1
60970: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60971: LD_ADDR_VAR 0 2
60975: PUSH
60976: LD_INT 0
60978: PUSH
60979: LD_INT 0
60981: PUSH
60982: LD_INT 0
60984: PUSH
60985: LD_INT 0
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: LIST
60992: LIST
60993: ST_TO_ADDR
// if not eng then
60994: LD_VAR 0 6
60998: NOT
60999: IFFALSE 61062
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61001: LD_ADDR_VAR 0 11
61005: PUSH
61006: LD_VAR 0 4
61010: PPUSH
61011: LD_INT 2
61013: PPUSH
61014: CALL 47827 0 2
61018: PUSH
61019: LD_INT 1
61021: ARRAY
61022: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61023: LD_ADDR_VAR 0 2
61027: PUSH
61028: LD_VAR 0 2
61032: PPUSH
61033: LD_INT 2
61035: PPUSH
61036: LD_VAR 0 11
61040: PPUSH
61041: CALL_OW 1
61045: ST_TO_ADDR
// tmp := tmp diff p ;
61046: LD_ADDR_VAR 0 4
61050: PUSH
61051: LD_VAR 0 4
61055: PUSH
61056: LD_VAR 0 11
61060: DIFF
61061: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61062: LD_VAR 0 4
61066: IFFALSE 61078
61068: PUSH
61069: LD_VAR 0 8
61073: PUSH
61074: LD_INT 6
61076: LESS
61077: AND
61078: IFFALSE 61266
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61080: LD_ADDR_VAR 0 9
61084: PUSH
61085: LD_VAR 0 4
61089: PUSH
61090: LD_VAR 0 8
61094: PUSH
61095: LD_VAR 0 7
61099: UNION
61100: DIFF
61101: PPUSH
61102: LD_INT 4
61104: PPUSH
61105: CALL 47827 0 2
61109: ST_TO_ADDR
// p := [ ] ;
61110: LD_ADDR_VAR 0 11
61114: PUSH
61115: EMPTY
61116: ST_TO_ADDR
// if sort then
61117: LD_VAR 0 9
61121: IFFALSE 61237
// for i = 1 to 6 - sci do
61123: LD_ADDR_VAR 0 3
61127: PUSH
61128: DOUBLE
61129: LD_INT 1
61131: DEC
61132: ST_TO_ADDR
61133: LD_INT 6
61135: PUSH
61136: LD_VAR 0 8
61140: MINUS
61141: PUSH
61142: FOR_TO
61143: IFFALSE 61235
// begin if i = sort then
61145: LD_VAR 0 3
61149: PUSH
61150: LD_VAR 0 9
61154: EQUAL
61155: IFFALSE 61159
// break ;
61157: GO 61235
// if GetClass ( i ) = 4 then
61159: LD_VAR 0 3
61163: PPUSH
61164: CALL_OW 257
61168: PUSH
61169: LD_INT 4
61171: EQUAL
61172: IFFALSE 61176
// continue ;
61174: GO 61142
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61176: LD_ADDR_VAR 0 11
61180: PUSH
61181: LD_VAR 0 11
61185: PPUSH
61186: LD_VAR 0 11
61190: PUSH
61191: LD_INT 1
61193: PLUS
61194: PPUSH
61195: LD_VAR 0 9
61199: PUSH
61200: LD_VAR 0 3
61204: ARRAY
61205: PPUSH
61206: CALL_OW 2
61210: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61211: LD_ADDR_VAR 0 4
61215: PUSH
61216: LD_VAR 0 4
61220: PUSH
61221: LD_VAR 0 9
61225: PUSH
61226: LD_VAR 0 3
61230: ARRAY
61231: DIFF
61232: ST_TO_ADDR
// end ;
61233: GO 61142
61235: POP
61236: POP
// if p then
61237: LD_VAR 0 11
61241: IFFALSE 61266
// result := Replace ( result , 4 , p ) ;
61243: LD_ADDR_VAR 0 2
61247: PUSH
61248: LD_VAR 0 2
61252: PPUSH
61253: LD_INT 4
61255: PPUSH
61256: LD_VAR 0 11
61260: PPUSH
61261: CALL_OW 1
61265: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61266: LD_VAR 0 4
61270: IFFALSE 61282
61272: PUSH
61273: LD_VAR 0 7
61277: PUSH
61278: LD_INT 6
61280: LESS
61281: AND
61282: IFFALSE 61470
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61284: LD_ADDR_VAR 0 9
61288: PUSH
61289: LD_VAR 0 4
61293: PUSH
61294: LD_VAR 0 8
61298: PUSH
61299: LD_VAR 0 7
61303: UNION
61304: DIFF
61305: PPUSH
61306: LD_INT 3
61308: PPUSH
61309: CALL 47827 0 2
61313: ST_TO_ADDR
// p := [ ] ;
61314: LD_ADDR_VAR 0 11
61318: PUSH
61319: EMPTY
61320: ST_TO_ADDR
// if sort then
61321: LD_VAR 0 9
61325: IFFALSE 61441
// for i = 1 to 6 - mech do
61327: LD_ADDR_VAR 0 3
61331: PUSH
61332: DOUBLE
61333: LD_INT 1
61335: DEC
61336: ST_TO_ADDR
61337: LD_INT 6
61339: PUSH
61340: LD_VAR 0 7
61344: MINUS
61345: PUSH
61346: FOR_TO
61347: IFFALSE 61439
// begin if i = sort then
61349: LD_VAR 0 3
61353: PUSH
61354: LD_VAR 0 9
61358: EQUAL
61359: IFFALSE 61363
// break ;
61361: GO 61439
// if GetClass ( i ) = 3 then
61363: LD_VAR 0 3
61367: PPUSH
61368: CALL_OW 257
61372: PUSH
61373: LD_INT 3
61375: EQUAL
61376: IFFALSE 61380
// continue ;
61378: GO 61346
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61380: LD_ADDR_VAR 0 11
61384: PUSH
61385: LD_VAR 0 11
61389: PPUSH
61390: LD_VAR 0 11
61394: PUSH
61395: LD_INT 1
61397: PLUS
61398: PPUSH
61399: LD_VAR 0 9
61403: PUSH
61404: LD_VAR 0 3
61408: ARRAY
61409: PPUSH
61410: CALL_OW 2
61414: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61415: LD_ADDR_VAR 0 4
61419: PUSH
61420: LD_VAR 0 4
61424: PUSH
61425: LD_VAR 0 9
61429: PUSH
61430: LD_VAR 0 3
61434: ARRAY
61435: DIFF
61436: ST_TO_ADDR
// end ;
61437: GO 61346
61439: POP
61440: POP
// if p then
61441: LD_VAR 0 11
61445: IFFALSE 61470
// result := Replace ( result , 3 , p ) ;
61447: LD_ADDR_VAR 0 2
61451: PUSH
61452: LD_VAR 0 2
61456: PPUSH
61457: LD_INT 3
61459: PPUSH
61460: LD_VAR 0 11
61464: PPUSH
61465: CALL_OW 1
61469: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61470: LD_VAR 0 4
61474: PUSH
61475: LD_INT 6
61477: GREATER
61478: IFFALSE 61490
61480: PUSH
61481: LD_VAR 0 6
61485: PUSH
61486: LD_INT 6
61488: LESS
61489: AND
61490: IFFALSE 61684
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61492: LD_ADDR_VAR 0 9
61496: PUSH
61497: LD_VAR 0 4
61501: PUSH
61502: LD_VAR 0 8
61506: PUSH
61507: LD_VAR 0 7
61511: UNION
61512: PUSH
61513: LD_VAR 0 6
61517: UNION
61518: DIFF
61519: PPUSH
61520: LD_INT 2
61522: PPUSH
61523: CALL 47827 0 2
61527: ST_TO_ADDR
// p := [ ] ;
61528: LD_ADDR_VAR 0 11
61532: PUSH
61533: EMPTY
61534: ST_TO_ADDR
// if sort then
61535: LD_VAR 0 9
61539: IFFALSE 61655
// for i = 1 to 6 - eng do
61541: LD_ADDR_VAR 0 3
61545: PUSH
61546: DOUBLE
61547: LD_INT 1
61549: DEC
61550: ST_TO_ADDR
61551: LD_INT 6
61553: PUSH
61554: LD_VAR 0 6
61558: MINUS
61559: PUSH
61560: FOR_TO
61561: IFFALSE 61653
// begin if i = sort then
61563: LD_VAR 0 3
61567: PUSH
61568: LD_VAR 0 9
61572: EQUAL
61573: IFFALSE 61577
// break ;
61575: GO 61653
// if GetClass ( i ) = 2 then
61577: LD_VAR 0 3
61581: PPUSH
61582: CALL_OW 257
61586: PUSH
61587: LD_INT 2
61589: EQUAL
61590: IFFALSE 61594
// continue ;
61592: GO 61560
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61594: LD_ADDR_VAR 0 11
61598: PUSH
61599: LD_VAR 0 11
61603: PPUSH
61604: LD_VAR 0 11
61608: PUSH
61609: LD_INT 1
61611: PLUS
61612: PPUSH
61613: LD_VAR 0 9
61617: PUSH
61618: LD_VAR 0 3
61622: ARRAY
61623: PPUSH
61624: CALL_OW 2
61628: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61629: LD_ADDR_VAR 0 4
61633: PUSH
61634: LD_VAR 0 4
61638: PUSH
61639: LD_VAR 0 9
61643: PUSH
61644: LD_VAR 0 3
61648: ARRAY
61649: DIFF
61650: ST_TO_ADDR
// end ;
61651: GO 61560
61653: POP
61654: POP
// if p then
61655: LD_VAR 0 11
61659: IFFALSE 61684
// result := Replace ( result , 2 , p ) ;
61661: LD_ADDR_VAR 0 2
61665: PUSH
61666: LD_VAR 0 2
61670: PPUSH
61671: LD_INT 2
61673: PPUSH
61674: LD_VAR 0 11
61678: PPUSH
61679: CALL_OW 1
61683: ST_TO_ADDR
// end ; exit ;
61684: GO 63092
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61686: LD_EXP 50
61690: PUSH
61691: LD_EXP 49
61695: PUSH
61696: LD_VAR 0 1
61700: ARRAY
61701: ARRAY
61702: NOT
61703: IFFALSE 61732
61705: PUSH
61706: LD_EXP 23
61710: PUSH
61711: LD_VAR 0 1
61715: ARRAY
61716: PPUSH
61717: LD_INT 30
61719: PUSH
61720: LD_INT 3
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: PPUSH
61727: CALL_OW 72
61731: AND
61732: IFFALSE 61746
61734: PUSH
61735: LD_EXP 28
61739: PUSH
61740: LD_VAR 0 1
61744: ARRAY
61745: AND
61746: IFFALSE 62360
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61748: LD_ADDR_EXP 65
61752: PUSH
61753: LD_EXP 65
61757: PPUSH
61758: LD_VAR 0 1
61762: PPUSH
61763: LD_INT 5
61765: PPUSH
61766: CALL_OW 1
61770: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61771: LD_ADDR_VAR 0 2
61775: PUSH
61776: LD_INT 0
61778: PUSH
61779: LD_INT 0
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: LD_INT 0
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: LIST
61792: LIST
61793: ST_TO_ADDR
// if sci > 1 then
61794: LD_VAR 0 8
61798: PUSH
61799: LD_INT 1
61801: GREATER
61802: IFFALSE 61830
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61804: LD_ADDR_VAR 0 4
61808: PUSH
61809: LD_VAR 0 4
61813: PUSH
61814: LD_VAR 0 8
61818: PUSH
61819: LD_VAR 0 8
61823: PUSH
61824: LD_INT 1
61826: ARRAY
61827: DIFF
61828: DIFF
61829: ST_TO_ADDR
// if tmp and not sci then
61830: LD_VAR 0 4
61834: IFFALSE 61843
61836: PUSH
61837: LD_VAR 0 8
61841: NOT
61842: AND
61843: IFFALSE 61912
// begin sort := SortBySkill ( tmp , 4 ) ;
61845: LD_ADDR_VAR 0 9
61849: PUSH
61850: LD_VAR 0 4
61854: PPUSH
61855: LD_INT 4
61857: PPUSH
61858: CALL 47827 0 2
61862: ST_TO_ADDR
// if sort then
61863: LD_VAR 0 9
61867: IFFALSE 61883
// p := sort [ 1 ] ;
61869: LD_ADDR_VAR 0 11
61873: PUSH
61874: LD_VAR 0 9
61878: PUSH
61879: LD_INT 1
61881: ARRAY
61882: ST_TO_ADDR
// if p then
61883: LD_VAR 0 11
61887: IFFALSE 61912
// result := Replace ( result , 4 , p ) ;
61889: LD_ADDR_VAR 0 2
61893: PUSH
61894: LD_VAR 0 2
61898: PPUSH
61899: LD_INT 4
61901: PPUSH
61902: LD_VAR 0 11
61906: PPUSH
61907: CALL_OW 1
61911: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61912: LD_ADDR_VAR 0 4
61916: PUSH
61917: LD_VAR 0 4
61921: PUSH
61922: LD_VAR 0 7
61926: DIFF
61927: ST_TO_ADDR
// if tmp and mech < 6 then
61928: LD_VAR 0 4
61932: IFFALSE 61944
61934: PUSH
61935: LD_VAR 0 7
61939: PUSH
61940: LD_INT 6
61942: LESS
61943: AND
61944: IFFALSE 62132
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61946: LD_ADDR_VAR 0 9
61950: PUSH
61951: LD_VAR 0 4
61955: PUSH
61956: LD_VAR 0 8
61960: PUSH
61961: LD_VAR 0 7
61965: UNION
61966: DIFF
61967: PPUSH
61968: LD_INT 3
61970: PPUSH
61971: CALL 47827 0 2
61975: ST_TO_ADDR
// p := [ ] ;
61976: LD_ADDR_VAR 0 11
61980: PUSH
61981: EMPTY
61982: ST_TO_ADDR
// if sort then
61983: LD_VAR 0 9
61987: IFFALSE 62103
// for i = 1 to 6 - mech do
61989: LD_ADDR_VAR 0 3
61993: PUSH
61994: DOUBLE
61995: LD_INT 1
61997: DEC
61998: ST_TO_ADDR
61999: LD_INT 6
62001: PUSH
62002: LD_VAR 0 7
62006: MINUS
62007: PUSH
62008: FOR_TO
62009: IFFALSE 62101
// begin if i = sort then
62011: LD_VAR 0 3
62015: PUSH
62016: LD_VAR 0 9
62020: EQUAL
62021: IFFALSE 62025
// break ;
62023: GO 62101
// if GetClass ( i ) = 3 then
62025: LD_VAR 0 3
62029: PPUSH
62030: CALL_OW 257
62034: PUSH
62035: LD_INT 3
62037: EQUAL
62038: IFFALSE 62042
// continue ;
62040: GO 62008
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62042: LD_ADDR_VAR 0 11
62046: PUSH
62047: LD_VAR 0 11
62051: PPUSH
62052: LD_VAR 0 11
62056: PUSH
62057: LD_INT 1
62059: PLUS
62060: PPUSH
62061: LD_VAR 0 9
62065: PUSH
62066: LD_VAR 0 3
62070: ARRAY
62071: PPUSH
62072: CALL_OW 2
62076: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62077: LD_ADDR_VAR 0 4
62081: PUSH
62082: LD_VAR 0 4
62086: PUSH
62087: LD_VAR 0 9
62091: PUSH
62092: LD_VAR 0 3
62096: ARRAY
62097: DIFF
62098: ST_TO_ADDR
// end ;
62099: GO 62008
62101: POP
62102: POP
// if p then
62103: LD_VAR 0 11
62107: IFFALSE 62132
// result := Replace ( result , 3 , p ) ;
62109: LD_ADDR_VAR 0 2
62113: PUSH
62114: LD_VAR 0 2
62118: PPUSH
62119: LD_INT 3
62121: PPUSH
62122: LD_VAR 0 11
62126: PPUSH
62127: CALL_OW 1
62131: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62132: LD_ADDR_VAR 0 4
62136: PUSH
62137: LD_VAR 0 4
62141: PUSH
62142: LD_VAR 0 6
62146: DIFF
62147: ST_TO_ADDR
// if tmp and eng < 6 then
62148: LD_VAR 0 4
62152: IFFALSE 62164
62154: PUSH
62155: LD_VAR 0 6
62159: PUSH
62160: LD_INT 6
62162: LESS
62163: AND
62164: IFFALSE 62358
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62166: LD_ADDR_VAR 0 9
62170: PUSH
62171: LD_VAR 0 4
62175: PUSH
62176: LD_VAR 0 8
62180: PUSH
62181: LD_VAR 0 7
62185: UNION
62186: PUSH
62187: LD_VAR 0 6
62191: UNION
62192: DIFF
62193: PPUSH
62194: LD_INT 2
62196: PPUSH
62197: CALL 47827 0 2
62201: ST_TO_ADDR
// p := [ ] ;
62202: LD_ADDR_VAR 0 11
62206: PUSH
62207: EMPTY
62208: ST_TO_ADDR
// if sort then
62209: LD_VAR 0 9
62213: IFFALSE 62329
// for i = 1 to 6 - eng do
62215: LD_ADDR_VAR 0 3
62219: PUSH
62220: DOUBLE
62221: LD_INT 1
62223: DEC
62224: ST_TO_ADDR
62225: LD_INT 6
62227: PUSH
62228: LD_VAR 0 6
62232: MINUS
62233: PUSH
62234: FOR_TO
62235: IFFALSE 62327
// begin if i = sort then
62237: LD_VAR 0 3
62241: PUSH
62242: LD_VAR 0 9
62246: EQUAL
62247: IFFALSE 62251
// break ;
62249: GO 62327
// if GetClass ( i ) = 2 then
62251: LD_VAR 0 3
62255: PPUSH
62256: CALL_OW 257
62260: PUSH
62261: LD_INT 2
62263: EQUAL
62264: IFFALSE 62268
// continue ;
62266: GO 62234
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62268: LD_ADDR_VAR 0 11
62272: PUSH
62273: LD_VAR 0 11
62277: PPUSH
62278: LD_VAR 0 11
62282: PUSH
62283: LD_INT 1
62285: PLUS
62286: PPUSH
62287: LD_VAR 0 9
62291: PUSH
62292: LD_VAR 0 3
62296: ARRAY
62297: PPUSH
62298: CALL_OW 2
62302: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62303: LD_ADDR_VAR 0 4
62307: PUSH
62308: LD_VAR 0 4
62312: PUSH
62313: LD_VAR 0 9
62317: PUSH
62318: LD_VAR 0 3
62322: ARRAY
62323: DIFF
62324: ST_TO_ADDR
// end ;
62325: GO 62234
62327: POP
62328: POP
// if p then
62329: LD_VAR 0 11
62333: IFFALSE 62358
// result := Replace ( result , 2 , p ) ;
62335: LD_ADDR_VAR 0 2
62339: PUSH
62340: LD_VAR 0 2
62344: PPUSH
62345: LD_INT 2
62347: PPUSH
62348: LD_VAR 0 11
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// end ; exit ;
62358: GO 63092
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62360: LD_EXP 50
62364: PUSH
62365: LD_EXP 49
62369: PUSH
62370: LD_VAR 0 1
62374: ARRAY
62375: ARRAY
62376: NOT
62377: IFFALSE 62406
62379: PUSH
62380: LD_EXP 23
62384: PUSH
62385: LD_VAR 0 1
62389: ARRAY
62390: PPUSH
62391: LD_INT 30
62393: PUSH
62394: LD_INT 3
62396: PUSH
62397: EMPTY
62398: LIST
62399: LIST
62400: PPUSH
62401: CALL_OW 72
62405: AND
62406: IFFALSE 62421
62408: PUSH
62409: LD_EXP 28
62413: PUSH
62414: LD_VAR 0 1
62418: ARRAY
62419: NOT
62420: AND
62421: IFFALSE 63092
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62423: LD_ADDR_EXP 65
62427: PUSH
62428: LD_EXP 65
62432: PPUSH
62433: LD_VAR 0 1
62437: PPUSH
62438: LD_INT 6
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62446: LD_ADDR_VAR 0 2
62450: PUSH
62451: LD_INT 0
62453: PUSH
62454: LD_INT 0
62456: PUSH
62457: LD_INT 0
62459: PUSH
62460: LD_INT 0
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: ST_TO_ADDR
// if sci >= 1 then
62469: LD_VAR 0 8
62473: PUSH
62474: LD_INT 1
62476: GREATEREQUAL
62477: IFFALSE 62499
// tmp := tmp diff sci [ 1 ] ;
62479: LD_ADDR_VAR 0 4
62483: PUSH
62484: LD_VAR 0 4
62488: PUSH
62489: LD_VAR 0 8
62493: PUSH
62494: LD_INT 1
62496: ARRAY
62497: DIFF
62498: ST_TO_ADDR
// if tmp and not sci then
62499: LD_VAR 0 4
62503: IFFALSE 62512
62505: PUSH
62506: LD_VAR 0 8
62510: NOT
62511: AND
62512: IFFALSE 62581
// begin sort := SortBySkill ( tmp , 4 ) ;
62514: LD_ADDR_VAR 0 9
62518: PUSH
62519: LD_VAR 0 4
62523: PPUSH
62524: LD_INT 4
62526: PPUSH
62527: CALL 47827 0 2
62531: ST_TO_ADDR
// if sort then
62532: LD_VAR 0 9
62536: IFFALSE 62552
// p := sort [ 1 ] ;
62538: LD_ADDR_VAR 0 11
62542: PUSH
62543: LD_VAR 0 9
62547: PUSH
62548: LD_INT 1
62550: ARRAY
62551: ST_TO_ADDR
// if p then
62552: LD_VAR 0 11
62556: IFFALSE 62581
// result := Replace ( result , 4 , p ) ;
62558: LD_ADDR_VAR 0 2
62562: PUSH
62563: LD_VAR 0 2
62567: PPUSH
62568: LD_INT 4
62570: PPUSH
62571: LD_VAR 0 11
62575: PPUSH
62576: CALL_OW 1
62580: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62581: LD_ADDR_VAR 0 4
62585: PUSH
62586: LD_VAR 0 4
62590: PUSH
62591: LD_VAR 0 7
62595: DIFF
62596: ST_TO_ADDR
// if tmp and mech < 6 then
62597: LD_VAR 0 4
62601: IFFALSE 62613
62603: PUSH
62604: LD_VAR 0 7
62608: PUSH
62609: LD_INT 6
62611: LESS
62612: AND
62613: IFFALSE 62795
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62615: LD_ADDR_VAR 0 9
62619: PUSH
62620: LD_VAR 0 4
62624: PUSH
62625: LD_VAR 0 7
62629: DIFF
62630: PPUSH
62631: LD_INT 3
62633: PPUSH
62634: CALL 47827 0 2
62638: ST_TO_ADDR
// p := [ ] ;
62639: LD_ADDR_VAR 0 11
62643: PUSH
62644: EMPTY
62645: ST_TO_ADDR
// if sort then
62646: LD_VAR 0 9
62650: IFFALSE 62766
// for i = 1 to 6 - mech do
62652: LD_ADDR_VAR 0 3
62656: PUSH
62657: DOUBLE
62658: LD_INT 1
62660: DEC
62661: ST_TO_ADDR
62662: LD_INT 6
62664: PUSH
62665: LD_VAR 0 7
62669: MINUS
62670: PUSH
62671: FOR_TO
62672: IFFALSE 62764
// begin if i = sort then
62674: LD_VAR 0 3
62678: PUSH
62679: LD_VAR 0 9
62683: EQUAL
62684: IFFALSE 62688
// break ;
62686: GO 62764
// if GetClass ( i ) = 3 then
62688: LD_VAR 0 3
62692: PPUSH
62693: CALL_OW 257
62697: PUSH
62698: LD_INT 3
62700: EQUAL
62701: IFFALSE 62705
// continue ;
62703: GO 62671
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62705: LD_ADDR_VAR 0 11
62709: PUSH
62710: LD_VAR 0 11
62714: PPUSH
62715: LD_VAR 0 11
62719: PUSH
62720: LD_INT 1
62722: PLUS
62723: PPUSH
62724: LD_VAR 0 9
62728: PUSH
62729: LD_VAR 0 3
62733: ARRAY
62734: PPUSH
62735: CALL_OW 2
62739: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62740: LD_ADDR_VAR 0 4
62744: PUSH
62745: LD_VAR 0 4
62749: PUSH
62750: LD_VAR 0 9
62754: PUSH
62755: LD_VAR 0 3
62759: ARRAY
62760: DIFF
62761: ST_TO_ADDR
// end ;
62762: GO 62671
62764: POP
62765: POP
// if p then
62766: LD_VAR 0 11
62770: IFFALSE 62795
// result := Replace ( result , 3 , p ) ;
62772: LD_ADDR_VAR 0 2
62776: PUSH
62777: LD_VAR 0 2
62781: PPUSH
62782: LD_INT 3
62784: PPUSH
62785: LD_VAR 0 11
62789: PPUSH
62790: CALL_OW 1
62794: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62795: LD_ADDR_VAR 0 4
62799: PUSH
62800: LD_VAR 0 4
62804: PUSH
62805: LD_VAR 0 6
62809: DIFF
62810: ST_TO_ADDR
// if tmp and eng < 4 then
62811: LD_VAR 0 4
62815: IFFALSE 62827
62817: PUSH
62818: LD_VAR 0 6
62822: PUSH
62823: LD_INT 4
62825: LESS
62826: AND
62827: IFFALSE 63017
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62829: LD_ADDR_VAR 0 9
62833: PUSH
62834: LD_VAR 0 4
62838: PUSH
62839: LD_VAR 0 7
62843: PUSH
62844: LD_VAR 0 6
62848: UNION
62849: DIFF
62850: PPUSH
62851: LD_INT 2
62853: PPUSH
62854: CALL 47827 0 2
62858: ST_TO_ADDR
// p := [ ] ;
62859: LD_ADDR_VAR 0 11
62863: PUSH
62864: EMPTY
62865: ST_TO_ADDR
// if sort then
62866: LD_VAR 0 9
62870: IFFALSE 62986
// for i = 1 to 4 - eng do
62872: LD_ADDR_VAR 0 3
62876: PUSH
62877: DOUBLE
62878: LD_INT 1
62880: DEC
62881: ST_TO_ADDR
62882: LD_INT 4
62884: PUSH
62885: LD_VAR 0 6
62889: MINUS
62890: PUSH
62891: FOR_TO
62892: IFFALSE 62984
// begin if i = sort then
62894: LD_VAR 0 3
62898: PUSH
62899: LD_VAR 0 9
62903: EQUAL
62904: IFFALSE 62908
// break ;
62906: GO 62984
// if GetClass ( i ) = 2 then
62908: LD_VAR 0 3
62912: PPUSH
62913: CALL_OW 257
62917: PUSH
62918: LD_INT 2
62920: EQUAL
62921: IFFALSE 62925
// continue ;
62923: GO 62891
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62925: LD_ADDR_VAR 0 11
62929: PUSH
62930: LD_VAR 0 11
62934: PPUSH
62935: LD_VAR 0 11
62939: PUSH
62940: LD_INT 1
62942: PLUS
62943: PPUSH
62944: LD_VAR 0 9
62948: PUSH
62949: LD_VAR 0 3
62953: ARRAY
62954: PPUSH
62955: CALL_OW 2
62959: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62960: LD_ADDR_VAR 0 4
62964: PUSH
62965: LD_VAR 0 4
62969: PUSH
62970: LD_VAR 0 9
62974: PUSH
62975: LD_VAR 0 3
62979: ARRAY
62980: DIFF
62981: ST_TO_ADDR
// end ;
62982: GO 62891
62984: POP
62985: POP
// if p then
62986: LD_VAR 0 11
62990: IFFALSE 63015
// result := Replace ( result , 2 , p ) ;
62992: LD_ADDR_VAR 0 2
62996: PUSH
62997: LD_VAR 0 2
63001: PPUSH
63002: LD_INT 2
63004: PPUSH
63005: LD_VAR 0 11
63009: PPUSH
63010: CALL_OW 1
63014: ST_TO_ADDR
// end else
63015: GO 63061
// for i = eng downto 5 do
63017: LD_ADDR_VAR 0 3
63021: PUSH
63022: DOUBLE
63023: LD_VAR 0 6
63027: INC
63028: ST_TO_ADDR
63029: LD_INT 5
63031: PUSH
63032: FOR_DOWNTO
63033: IFFALSE 63059
// tmp := tmp union eng [ i ] ;
63035: LD_ADDR_VAR 0 4
63039: PUSH
63040: LD_VAR 0 4
63044: PUSH
63045: LD_VAR 0 6
63049: PUSH
63050: LD_VAR 0 3
63054: ARRAY
63055: UNION
63056: ST_TO_ADDR
63057: GO 63032
63059: POP
63060: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63061: LD_ADDR_VAR 0 2
63065: PUSH
63066: LD_VAR 0 2
63070: PPUSH
63071: LD_INT 1
63073: PPUSH
63074: LD_VAR 0 4
63078: PUSH
63079: LD_VAR 0 5
63083: DIFF
63084: PPUSH
63085: CALL_OW 1
63089: ST_TO_ADDR
// exit ;
63090: GO 63092
// end ; end ;
63092: LD_VAR 0 2
63096: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63097: LD_INT 0
63099: PPUSH
63100: PPUSH
63101: PPUSH
// if not mc_bases then
63102: LD_EXP 23
63106: NOT
63107: IFFALSE 63111
// exit ;
63109: GO 63253
// for i = 1 to mc_bases do
63111: LD_ADDR_VAR 0 2
63115: PUSH
63116: DOUBLE
63117: LD_INT 1
63119: DEC
63120: ST_TO_ADDR
63121: LD_EXP 23
63125: PUSH
63126: FOR_TO
63127: IFFALSE 63244
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63129: LD_ADDR_VAR 0 3
63133: PUSH
63134: LD_EXP 23
63138: PUSH
63139: LD_VAR 0 2
63143: ARRAY
63144: PPUSH
63145: LD_INT 21
63147: PUSH
63148: LD_INT 3
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 3
63157: PUSH
63158: LD_INT 2
63160: PUSH
63161: LD_INT 30
63163: PUSH
63164: LD_INT 29
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 30
63173: PUSH
63174: LD_INT 30
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: LIST
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: PUSH
63190: LD_INT 3
63192: PUSH
63193: LD_INT 24
63195: PUSH
63196: LD_INT 1000
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: LIST
63211: PPUSH
63212: CALL_OW 72
63216: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63217: LD_ADDR_EXP 24
63221: PUSH
63222: LD_EXP 24
63226: PPUSH
63227: LD_VAR 0 2
63231: PPUSH
63232: LD_VAR 0 3
63236: PPUSH
63237: CALL_OW 1
63241: ST_TO_ADDR
// end ;
63242: GO 63126
63244: POP
63245: POP
// RaiseSailEvent ( 101 ) ;
63246: LD_INT 101
63248: PPUSH
63249: CALL_OW 427
// end ;
63253: LD_VAR 0 1
63257: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63258: LD_INT 0
63260: PPUSH
63261: PPUSH
63262: PPUSH
63263: PPUSH
63264: PPUSH
63265: PPUSH
63266: PPUSH
// if not mc_bases then
63267: LD_EXP 23
63271: NOT
63272: IFFALSE 63276
// exit ;
63274: GO 63840
// for i = 1 to mc_bases do
63276: LD_ADDR_VAR 0 2
63280: PUSH
63281: DOUBLE
63282: LD_INT 1
63284: DEC
63285: ST_TO_ADDR
63286: LD_EXP 23
63290: PUSH
63291: FOR_TO
63292: IFFALSE 63831
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63294: LD_ADDR_VAR 0 5
63298: PUSH
63299: LD_EXP 23
63303: PUSH
63304: LD_VAR 0 2
63308: ARRAY
63309: PUSH
63310: LD_EXP 52
63314: PUSH
63315: LD_VAR 0 2
63319: ARRAY
63320: UNION
63321: PPUSH
63322: LD_INT 21
63324: PUSH
63325: LD_INT 1
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PUSH
63332: LD_INT 1
63334: PUSH
63335: LD_INT 3
63337: PUSH
63338: LD_INT 54
63340: PUSH
63341: EMPTY
63342: LIST
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 3
63350: PUSH
63351: LD_INT 24
63353: PUSH
63354: LD_INT 1000
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: EMPTY
63362: LIST
63363: LIST
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: LIST
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: PPUSH
63374: CALL_OW 72
63378: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63379: LD_ADDR_VAR 0 6
63383: PUSH
63384: LD_EXP 23
63388: PUSH
63389: LD_VAR 0 2
63393: ARRAY
63394: PPUSH
63395: LD_INT 21
63397: PUSH
63398: LD_INT 1
63400: PUSH
63401: EMPTY
63402: LIST
63403: LIST
63404: PUSH
63405: LD_INT 1
63407: PUSH
63408: LD_INT 3
63410: PUSH
63411: LD_INT 54
63413: PUSH
63414: EMPTY
63415: LIST
63416: PUSH
63417: EMPTY
63418: LIST
63419: LIST
63420: PUSH
63421: LD_INT 3
63423: PUSH
63424: LD_INT 24
63426: PUSH
63427: LD_INT 250
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: PUSH
63438: EMPTY
63439: LIST
63440: LIST
63441: LIST
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PPUSH
63447: CALL_OW 72
63451: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63452: LD_ADDR_VAR 0 7
63456: PUSH
63457: LD_VAR 0 5
63461: PUSH
63462: LD_VAR 0 6
63466: DIFF
63467: ST_TO_ADDR
// if not need_heal_1 then
63468: LD_VAR 0 6
63472: NOT
63473: IFFALSE 63506
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63475: LD_ADDR_EXP 26
63479: PUSH
63480: LD_EXP 26
63484: PPUSH
63485: LD_VAR 0 2
63489: PUSH
63490: LD_INT 1
63492: PUSH
63493: EMPTY
63494: LIST
63495: LIST
63496: PPUSH
63497: EMPTY
63498: PPUSH
63499: CALL 16289 0 3
63503: ST_TO_ADDR
63504: GO 63576
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63506: LD_ADDR_EXP 26
63510: PUSH
63511: LD_EXP 26
63515: PPUSH
63516: LD_VAR 0 2
63520: PUSH
63521: LD_INT 1
63523: PUSH
63524: EMPTY
63525: LIST
63526: LIST
63527: PPUSH
63528: LD_EXP 26
63532: PUSH
63533: LD_VAR 0 2
63537: ARRAY
63538: PUSH
63539: LD_INT 1
63541: ARRAY
63542: PPUSH
63543: LD_INT 3
63545: PUSH
63546: LD_INT 24
63548: PUSH
63549: LD_INT 1000
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: EMPTY
63557: LIST
63558: LIST
63559: PPUSH
63560: CALL_OW 72
63564: PUSH
63565: LD_VAR 0 6
63569: UNION
63570: PPUSH
63571: CALL 16289 0 3
63575: ST_TO_ADDR
// if not need_heal_2 then
63576: LD_VAR 0 7
63580: NOT
63581: IFFALSE 63614
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63583: LD_ADDR_EXP 26
63587: PUSH
63588: LD_EXP 26
63592: PPUSH
63593: LD_VAR 0 2
63597: PUSH
63598: LD_INT 2
63600: PUSH
63601: EMPTY
63602: LIST
63603: LIST
63604: PPUSH
63605: EMPTY
63606: PPUSH
63607: CALL 16289 0 3
63611: ST_TO_ADDR
63612: GO 63646
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63614: LD_ADDR_EXP 26
63618: PUSH
63619: LD_EXP 26
63623: PPUSH
63624: LD_VAR 0 2
63628: PUSH
63629: LD_INT 2
63631: PUSH
63632: EMPTY
63633: LIST
63634: LIST
63635: PPUSH
63636: LD_VAR 0 7
63640: PPUSH
63641: CALL 16289 0 3
63645: ST_TO_ADDR
// if need_heal_2 then
63646: LD_VAR 0 7
63650: IFFALSE 63811
// for j in need_heal_2 do
63652: LD_ADDR_VAR 0 3
63656: PUSH
63657: LD_VAR 0 7
63661: PUSH
63662: FOR_IN
63663: IFFALSE 63809
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63665: LD_ADDR_VAR 0 5
63669: PUSH
63670: LD_EXP 23
63674: PUSH
63675: LD_VAR 0 2
63679: ARRAY
63680: PPUSH
63681: LD_INT 2
63683: PUSH
63684: LD_INT 30
63686: PUSH
63687: LD_INT 6
63689: PUSH
63690: EMPTY
63691: LIST
63692: LIST
63693: PUSH
63694: LD_INT 30
63696: PUSH
63697: LD_INT 7
63699: PUSH
63700: EMPTY
63701: LIST
63702: LIST
63703: PUSH
63704: LD_INT 30
63706: PUSH
63707: LD_INT 8
63709: PUSH
63710: EMPTY
63711: LIST
63712: LIST
63713: PUSH
63714: LD_INT 30
63716: PUSH
63717: LD_INT 0
63719: PUSH
63720: EMPTY
63721: LIST
63722: LIST
63723: PUSH
63724: LD_INT 30
63726: PUSH
63727: LD_INT 1
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: LIST
63738: LIST
63739: LIST
63740: LIST
63741: PPUSH
63742: CALL_OW 72
63746: ST_TO_ADDR
// if tmp then
63747: LD_VAR 0 5
63751: IFFALSE 63807
// begin k := NearestUnitToUnit ( tmp , j ) ;
63753: LD_ADDR_VAR 0 4
63757: PUSH
63758: LD_VAR 0 5
63762: PPUSH
63763: LD_VAR 0 3
63767: PPUSH
63768: CALL_OW 74
63772: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63773: LD_VAR 0 3
63777: PPUSH
63778: LD_VAR 0 4
63782: PPUSH
63783: CALL_OW 296
63787: PUSH
63788: LD_INT 5
63790: GREATER
63791: IFFALSE 63807
// ComMoveToNearbyEntrance ( j , k ) ;
63793: LD_VAR 0 3
63797: PPUSH
63798: LD_VAR 0 4
63802: PPUSH
63803: CALL 50226 0 2
// end ; end ;
63807: GO 63662
63809: POP
63810: POP
// if not need_heal_1 and not need_heal_2 then
63811: LD_VAR 0 6
63815: NOT
63816: IFFALSE 63825
63818: PUSH
63819: LD_VAR 0 7
63823: NOT
63824: AND
63825: IFFALSE 63829
// continue ;
63827: GO 63291
// end ;
63829: GO 63291
63831: POP
63832: POP
// RaiseSailEvent ( 102 ) ;
63833: LD_INT 102
63835: PPUSH
63836: CALL_OW 427
// end ;
63840: LD_VAR 0 1
63844: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63845: LD_INT 0
63847: PPUSH
63848: PPUSH
63849: PPUSH
63850: PPUSH
63851: PPUSH
63852: PPUSH
63853: PPUSH
63854: PPUSH
// if not mc_bases then
63855: LD_EXP 23
63859: NOT
63860: IFFALSE 63864
// exit ;
63862: GO 64779
// for i = 1 to mc_bases do
63864: LD_ADDR_VAR 0 2
63868: PUSH
63869: DOUBLE
63870: LD_INT 1
63872: DEC
63873: ST_TO_ADDR
63874: LD_EXP 23
63878: PUSH
63879: FOR_TO
63880: IFFALSE 64777
// begin if not mc_building_need_repair [ i ] then
63882: LD_EXP 24
63886: PUSH
63887: LD_VAR 0 2
63891: ARRAY
63892: NOT
63893: IFFALSE 64078
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63895: LD_ADDR_VAR 0 6
63899: PUSH
63900: LD_EXP 42
63904: PUSH
63905: LD_VAR 0 2
63909: ARRAY
63910: PPUSH
63911: LD_INT 3
63913: PUSH
63914: LD_INT 24
63916: PUSH
63917: LD_INT 1000
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 2
63930: PUSH
63931: LD_INT 34
63933: PUSH
63934: LD_INT 13
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 34
63943: PUSH
63944: LD_INT 52
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 34
63953: PUSH
63954: LD_INT 88
63956: PUSH
63957: EMPTY
63958: LIST
63959: LIST
63960: PUSH
63961: EMPTY
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: PUSH
63967: EMPTY
63968: LIST
63969: LIST
63970: PPUSH
63971: CALL_OW 72
63975: ST_TO_ADDR
// if cranes then
63976: LD_VAR 0 6
63980: IFFALSE 64042
// for j in cranes do
63982: LD_ADDR_VAR 0 3
63986: PUSH
63987: LD_VAR 0 6
63991: PUSH
63992: FOR_IN
63993: IFFALSE 64040
// if not IsInArea ( j , mc_parking [ i ] ) then
63995: LD_VAR 0 3
63999: PPUSH
64000: LD_EXP 47
64004: PUSH
64005: LD_VAR 0 2
64009: ARRAY
64010: PPUSH
64011: CALL_OW 308
64015: NOT
64016: IFFALSE 64038
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64018: LD_VAR 0 3
64022: PPUSH
64023: LD_EXP 47
64027: PUSH
64028: LD_VAR 0 2
64032: ARRAY
64033: PPUSH
64034: CALL_OW 113
64038: GO 63992
64040: POP
64041: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64042: LD_ADDR_EXP 25
64046: PUSH
64047: LD_EXP 25
64051: PPUSH
64052: LD_VAR 0 2
64056: PPUSH
64057: EMPTY
64058: PPUSH
64059: CALL_OW 1
64063: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64064: LD_VAR 0 2
64068: PPUSH
64069: LD_INT 101
64071: PPUSH
64072: CALL 58870 0 2
// continue ;
64076: GO 63879
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64078: LD_ADDR_EXP 29
64082: PUSH
64083: LD_EXP 29
64087: PPUSH
64088: LD_VAR 0 2
64092: PPUSH
64093: EMPTY
64094: PPUSH
64095: CALL_OW 1
64099: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64100: LD_VAR 0 2
64104: PPUSH
64105: LD_INT 103
64107: PPUSH
64108: CALL 58870 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64112: LD_ADDR_VAR 0 5
64116: PUSH
64117: LD_EXP 23
64121: PUSH
64122: LD_VAR 0 2
64126: ARRAY
64127: PUSH
64128: LD_EXP 52
64132: PUSH
64133: LD_VAR 0 2
64137: ARRAY
64138: UNION
64139: PPUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 25
64145: PUSH
64146: LD_INT 2
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: PUSH
64153: LD_INT 25
64155: PUSH
64156: LD_INT 16
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: EMPTY
64164: LIST
64165: LIST
64166: LIST
64167: PUSH
64168: EMPTY
64169: LIST
64170: PPUSH
64171: CALL_OW 72
64175: ST_TO_ADDR
// if mc_need_heal [ i ] then
64176: LD_EXP 26
64180: PUSH
64181: LD_VAR 0 2
64185: ARRAY
64186: IFFALSE 64230
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64188: LD_ADDR_VAR 0 5
64192: PUSH
64193: LD_VAR 0 5
64197: PUSH
64198: LD_EXP 26
64202: PUSH
64203: LD_VAR 0 2
64207: ARRAY
64208: PUSH
64209: LD_INT 1
64211: ARRAY
64212: PUSH
64213: LD_EXP 26
64217: PUSH
64218: LD_VAR 0 2
64222: ARRAY
64223: PUSH
64224: LD_INT 2
64226: ARRAY
64227: UNION
64228: DIFF
64229: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64230: LD_ADDR_VAR 0 6
64234: PUSH
64235: LD_EXP 42
64239: PUSH
64240: LD_VAR 0 2
64244: ARRAY
64245: PPUSH
64246: LD_INT 2
64248: PUSH
64249: LD_INT 34
64251: PUSH
64252: LD_INT 13
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: PUSH
64259: LD_INT 34
64261: PUSH
64262: LD_INT 52
64264: PUSH
64265: EMPTY
64266: LIST
64267: LIST
64268: PUSH
64269: LD_INT 34
64271: PUSH
64272: LD_INT 88
64274: PUSH
64275: EMPTY
64276: LIST
64277: LIST
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: LIST
64283: LIST
64284: PPUSH
64285: CALL_OW 72
64289: ST_TO_ADDR
// if cranes then
64290: LD_VAR 0 6
64294: IFFALSE 64466
// begin for j in cranes do
64296: LD_ADDR_VAR 0 3
64300: PUSH
64301: LD_VAR 0 6
64305: PUSH
64306: FOR_IN
64307: IFFALSE 64464
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64309: LD_VAR 0 3
64313: PPUSH
64314: CALL_OW 256
64318: PUSH
64319: LD_INT 1000
64321: EQUAL
64322: IFFALSE 64336
64324: PUSH
64325: LD_VAR 0 3
64329: PPUSH
64330: CALL_OW 314
64334: NOT
64335: AND
64336: IFFALSE 64402
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
64338: LD_ADDR_VAR 0 8
64342: PUSH
64343: LD_EXP 24
64347: PUSH
64348: LD_VAR 0 2
64352: ARRAY
64353: PPUSH
64354: LD_VAR 0 3
64358: PPUSH
64359: CALL_OW 74
64363: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64364: LD_VAR 0 8
64368: PPUSH
64369: LD_INT 16
64371: PPUSH
64372: CALL 19268 0 2
64376: PUSH
64377: LD_INT 4
64379: ARRAY
64380: PUSH
64381: LD_INT 10
64383: LESS
64384: IFFALSE 64400
// ComRepairBuilding ( j , to_repair ) ;
64386: LD_VAR 0 3
64390: PPUSH
64391: LD_VAR 0 8
64395: PPUSH
64396: CALL_OW 130
// end else
64400: GO 64462
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64402: LD_VAR 0 3
64406: PPUSH
64407: CALL_OW 256
64411: PUSH
64412: LD_INT 500
64414: LESS
64415: IFFALSE 64440
64417: PUSH
64418: LD_VAR 0 3
64422: PPUSH
64423: LD_EXP 47
64427: PUSH
64428: LD_VAR 0 2
64432: ARRAY
64433: PPUSH
64434: CALL_OW 308
64438: NOT
64439: AND
64440: IFFALSE 64462
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64442: LD_VAR 0 3
64446: PPUSH
64447: LD_EXP 47
64451: PUSH
64452: LD_VAR 0 2
64456: ARRAY
64457: PPUSH
64458: CALL_OW 113
// end ;
64462: GO 64306
64464: POP
64465: POP
// end ; if tmp > 3 then
64466: LD_VAR 0 5
64470: PUSH
64471: LD_INT 3
64473: GREATER
64474: IFFALSE 64494
// tmp := ShrinkArray ( tmp , 4 ) ;
64476: LD_ADDR_VAR 0 5
64480: PUSH
64481: LD_VAR 0 5
64485: PPUSH
64486: LD_INT 4
64488: PPUSH
64489: CALL 49662 0 2
64493: ST_TO_ADDR
// if not tmp then
64494: LD_VAR 0 5
64498: NOT
64499: IFFALSE 64503
// continue ;
64501: GO 63879
// for j in tmp do
64503: LD_ADDR_VAR 0 3
64507: PUSH
64508: LD_VAR 0 5
64512: PUSH
64513: FOR_IN
64514: IFFALSE 64773
// begin if IsInUnit ( j ) then
64516: LD_VAR 0 3
64520: PPUSH
64521: CALL_OW 310
64525: IFFALSE 64536
// ComExitBuilding ( j ) ;
64527: LD_VAR 0 3
64531: PPUSH
64532: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64536: LD_VAR 0 3
64540: PUSH
64541: LD_EXP 25
64545: PUSH
64546: LD_VAR 0 2
64550: ARRAY
64551: IN
64552: NOT
64553: IFFALSE 64611
// begin SetTag ( j , 101 ) ;
64555: LD_VAR 0 3
64559: PPUSH
64560: LD_INT 101
64562: PPUSH
64563: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64567: LD_ADDR_EXP 25
64571: PUSH
64572: LD_EXP 25
64576: PPUSH
64577: LD_VAR 0 2
64581: PUSH
64582: LD_EXP 25
64586: PUSH
64587: LD_VAR 0 2
64591: ARRAY
64592: PUSH
64593: LD_INT 1
64595: PLUS
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: PPUSH
64601: LD_VAR 0 3
64605: PPUSH
64606: CALL 16289 0 3
64610: ST_TO_ADDR
// end ; wait ( 1 ) ;
64611: LD_INT 1
64613: PPUSH
64614: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64618: LD_ADDR_VAR 0 7
64622: PUSH
64623: LD_EXP 24
64627: PUSH
64628: LD_VAR 0 2
64632: ARRAY
64633: ST_TO_ADDR
// if mc_scan [ i ] then
64634: LD_EXP 46
64638: PUSH
64639: LD_VAR 0 2
64643: ARRAY
64644: IFFALSE 64706
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64646: LD_ADDR_VAR 0 7
64650: PUSH
64651: LD_EXP 24
64655: PUSH
64656: LD_VAR 0 2
64660: ARRAY
64661: PPUSH
64662: LD_INT 3
64664: PUSH
64665: LD_INT 30
64667: PUSH
64668: LD_INT 32
64670: PUSH
64671: EMPTY
64672: LIST
64673: LIST
64674: PUSH
64675: LD_INT 30
64677: PUSH
64678: LD_INT 33
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: LD_INT 30
64687: PUSH
64688: LD_INT 31
64690: PUSH
64691: EMPTY
64692: LIST
64693: LIST
64694: PUSH
64695: EMPTY
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: PPUSH
64701: CALL_OW 72
64705: ST_TO_ADDR
// if not to_repair_tmp then
64706: LD_VAR 0 7
64710: NOT
64711: IFFALSE 64715
// continue ;
64713: GO 64513
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64715: LD_ADDR_VAR 0 8
64719: PUSH
64720: LD_VAR 0 7
64724: PPUSH
64725: LD_VAR 0 3
64729: PPUSH
64730: CALL_OW 74
64734: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
64735: LD_VAR 0 8
64739: PPUSH
64740: LD_INT 16
64742: PPUSH
64743: CALL 19268 0 2
64747: PUSH
64748: LD_INT 4
64750: ARRAY
64751: PUSH
64752: LD_INT 14
64754: LESS
64755: IFFALSE 64771
// ComRepairBuilding ( j , to_repair ) ;
64757: LD_VAR 0 3
64761: PPUSH
64762: LD_VAR 0 8
64766: PPUSH
64767: CALL_OW 130
// end ;
64771: GO 64513
64773: POP
64774: POP
// end ;
64775: GO 63879
64777: POP
64778: POP
// end ;
64779: LD_VAR 0 1
64783: RET
// export function MC_Heal ; var i , j , tmp ; begin
64784: LD_INT 0
64786: PPUSH
64787: PPUSH
64788: PPUSH
64789: PPUSH
// if not mc_bases then
64790: LD_EXP 23
64794: NOT
64795: IFFALSE 64799
// exit ;
64797: GO 65205
// for i = 1 to mc_bases do
64799: LD_ADDR_VAR 0 2
64803: PUSH
64804: DOUBLE
64805: LD_INT 1
64807: DEC
64808: ST_TO_ADDR
64809: LD_EXP 23
64813: PUSH
64814: FOR_TO
64815: IFFALSE 65203
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64817: LD_EXP 26
64821: PUSH
64822: LD_VAR 0 2
64826: ARRAY
64827: PUSH
64828: LD_INT 1
64830: ARRAY
64831: NOT
64832: IFFALSE 64851
64834: PUSH
64835: LD_EXP 26
64839: PUSH
64840: LD_VAR 0 2
64844: ARRAY
64845: PUSH
64846: LD_INT 2
64848: ARRAY
64849: NOT
64850: AND
64851: IFFALSE 64889
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64853: LD_ADDR_EXP 27
64857: PUSH
64858: LD_EXP 27
64862: PPUSH
64863: LD_VAR 0 2
64867: PPUSH
64868: EMPTY
64869: PPUSH
64870: CALL_OW 1
64874: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64875: LD_VAR 0 2
64879: PPUSH
64880: LD_INT 102
64882: PPUSH
64883: CALL 58870 0 2
// continue ;
64887: GO 64814
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64889: LD_ADDR_VAR 0 4
64893: PUSH
64894: LD_EXP 23
64898: PUSH
64899: LD_VAR 0 2
64903: ARRAY
64904: PPUSH
64905: LD_INT 25
64907: PUSH
64908: LD_INT 4
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PPUSH
64915: CALL_OW 72
64919: ST_TO_ADDR
// if not tmp then
64920: LD_VAR 0 4
64924: NOT
64925: IFFALSE 64929
// continue ;
64927: GO 64814
// if mc_taming [ i ] then
64929: LD_EXP 54
64933: PUSH
64934: LD_VAR 0 2
64938: ARRAY
64939: IFFALSE 64963
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64941: LD_ADDR_EXP 54
64945: PUSH
64946: LD_EXP 54
64950: PPUSH
64951: LD_VAR 0 2
64955: PPUSH
64956: EMPTY
64957: PPUSH
64958: CALL_OW 1
64962: ST_TO_ADDR
// for j in tmp do
64963: LD_ADDR_VAR 0 3
64967: PUSH
64968: LD_VAR 0 4
64972: PUSH
64973: FOR_IN
64974: IFFALSE 65199
// begin if IsInUnit ( j ) then
64976: LD_VAR 0 3
64980: PPUSH
64981: CALL_OW 310
64985: IFFALSE 64996
// ComExitBuilding ( j ) ;
64987: LD_VAR 0 3
64991: PPUSH
64992: CALL_OW 122
// if not j in mc_healers [ i ] then
64996: LD_VAR 0 3
65000: PUSH
65001: LD_EXP 27
65005: PUSH
65006: LD_VAR 0 2
65010: ARRAY
65011: IN
65012: NOT
65013: IFFALSE 65059
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65015: LD_ADDR_EXP 27
65019: PUSH
65020: LD_EXP 27
65024: PPUSH
65025: LD_VAR 0 2
65029: PUSH
65030: LD_EXP 27
65034: PUSH
65035: LD_VAR 0 2
65039: ARRAY
65040: PUSH
65041: LD_INT 1
65043: PLUS
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PPUSH
65049: LD_VAR 0 3
65053: PPUSH
65054: CALL 16289 0 3
65058: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65059: LD_VAR 0 3
65063: PPUSH
65064: CALL_OW 110
65068: PUSH
65069: LD_INT 102
65071: NONEQUAL
65072: IFFALSE 65086
// SetTag ( j , 102 ) ;
65074: LD_VAR 0 3
65078: PPUSH
65079: LD_INT 102
65081: PPUSH
65082: CALL_OW 109
// Wait ( 3 ) ;
65086: LD_INT 3
65088: PPUSH
65089: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65093: LD_EXP 26
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: PUSH
65104: LD_INT 1
65106: ARRAY
65107: IFFALSE 65139
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65109: LD_VAR 0 3
65113: PPUSH
65114: LD_EXP 26
65118: PUSH
65119: LD_VAR 0 2
65123: ARRAY
65124: PUSH
65125: LD_INT 1
65127: ARRAY
65128: PUSH
65129: LD_INT 1
65131: ARRAY
65132: PPUSH
65133: CALL_OW 128
65137: GO 65197
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65139: LD_VAR 0 3
65143: PPUSH
65144: CALL_OW 314
65148: NOT
65149: IFFALSE 65167
65151: PUSH
65152: LD_EXP 26
65156: PUSH
65157: LD_VAR 0 2
65161: ARRAY
65162: PUSH
65163: LD_INT 2
65165: ARRAY
65166: AND
65167: IFFALSE 65197
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65169: LD_VAR 0 3
65173: PPUSH
65174: LD_EXP 26
65178: PUSH
65179: LD_VAR 0 2
65183: ARRAY
65184: PUSH
65185: LD_INT 2
65187: ARRAY
65188: PUSH
65189: LD_INT 1
65191: ARRAY
65192: PPUSH
65193: CALL_OW 128
// end ;
65197: GO 64973
65199: POP
65200: POP
// end ;
65201: GO 64814
65203: POP
65204: POP
// end ;
65205: LD_VAR 0 1
65209: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
65210: LD_INT 0
65212: PPUSH
65213: PPUSH
65214: PPUSH
65215: PPUSH
65216: PPUSH
65217: PPUSH
// if not mc_bases then
65218: LD_EXP 23
65222: NOT
65223: IFFALSE 65227
// exit ;
65225: GO 66398
// for i = 1 to mc_bases do
65227: LD_ADDR_VAR 0 2
65231: PUSH
65232: DOUBLE
65233: LD_INT 1
65235: DEC
65236: ST_TO_ADDR
65237: LD_EXP 23
65241: PUSH
65242: FOR_TO
65243: IFFALSE 66396
// begin if mc_scan [ i ] then
65245: LD_EXP 46
65249: PUSH
65250: LD_VAR 0 2
65254: ARRAY
65255: IFFALSE 65259
// continue ;
65257: GO 65242
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65259: LD_EXP 28
65263: PUSH
65264: LD_VAR 0 2
65268: ARRAY
65269: NOT
65270: IFFALSE 65285
65272: PUSH
65273: LD_EXP 30
65277: PUSH
65278: LD_VAR 0 2
65282: ARRAY
65283: NOT
65284: AND
65285: IFFALSE 65299
65287: PUSH
65288: LD_EXP 29
65292: PUSH
65293: LD_VAR 0 2
65297: ARRAY
65298: AND
65299: IFFALSE 65337
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65301: LD_ADDR_EXP 29
65305: PUSH
65306: LD_EXP 29
65310: PPUSH
65311: LD_VAR 0 2
65315: PPUSH
65316: EMPTY
65317: PPUSH
65318: CALL_OW 1
65322: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65323: LD_VAR 0 2
65327: PPUSH
65328: LD_INT 103
65330: PPUSH
65331: CALL 58870 0 2
// continue ;
65335: GO 65242
// end ; if mc_construct_list [ i ] then
65337: LD_EXP 30
65341: PUSH
65342: LD_VAR 0 2
65346: ARRAY
65347: IFFALSE 65567
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65349: LD_ADDR_VAR 0 5
65353: PUSH
65354: LD_EXP 23
65358: PUSH
65359: LD_VAR 0 2
65363: ARRAY
65364: PPUSH
65365: LD_INT 25
65367: PUSH
65368: LD_INT 2
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PPUSH
65375: CALL_OW 72
65379: PUSH
65380: LD_EXP 25
65384: PUSH
65385: LD_VAR 0 2
65389: ARRAY
65390: DIFF
65391: ST_TO_ADDR
// if not tmp then
65392: LD_VAR 0 5
65396: NOT
65397: IFFALSE 65401
// continue ;
65399: GO 65242
// for j in tmp do
65401: LD_ADDR_VAR 0 3
65405: PUSH
65406: LD_VAR 0 5
65410: PUSH
65411: FOR_IN
65412: IFFALSE 65563
// begin if not mc_builders [ i ] then
65414: LD_EXP 29
65418: PUSH
65419: LD_VAR 0 2
65423: ARRAY
65424: NOT
65425: IFFALSE 65483
// begin SetTag ( j , 103 ) ;
65427: LD_VAR 0 3
65431: PPUSH
65432: LD_INT 103
65434: PPUSH
65435: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65439: LD_ADDR_EXP 29
65443: PUSH
65444: LD_EXP 29
65448: PPUSH
65449: LD_VAR 0 2
65453: PUSH
65454: LD_EXP 29
65458: PUSH
65459: LD_VAR 0 2
65463: ARRAY
65464: PUSH
65465: LD_INT 1
65467: PLUS
65468: PUSH
65469: EMPTY
65470: LIST
65471: LIST
65472: PPUSH
65473: LD_VAR 0 3
65477: PPUSH
65478: CALL 16289 0 3
65482: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65483: LD_VAR 0 3
65487: PPUSH
65488: CALL_OW 310
65492: IFFALSE 65503
// ComExitBuilding ( j ) ;
65494: LD_VAR 0 3
65498: PPUSH
65499: CALL_OW 122
// wait ( 3 ) ;
65503: LD_INT 3
65505: PPUSH
65506: CALL_OW 67
// if not mc_construct_list [ i ] then
65510: LD_EXP 30
65514: PUSH
65515: LD_VAR 0 2
65519: ARRAY
65520: NOT
65521: IFFALSE 65525
// break ;
65523: GO 65563
// if not HasTask ( j ) then
65525: LD_VAR 0 3
65529: PPUSH
65530: CALL_OW 314
65534: NOT
65535: IFFALSE 65561
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65537: LD_VAR 0 3
65541: PPUSH
65542: LD_EXP 30
65546: PUSH
65547: LD_VAR 0 2
65551: ARRAY
65552: PUSH
65553: LD_INT 1
65555: ARRAY
65556: PPUSH
65557: CALL 19541 0 2
// end ;
65561: GO 65411
65563: POP
65564: POP
// end else
65565: GO 66394
// if mc_build_list [ i ] then
65567: LD_EXP 28
65571: PUSH
65572: LD_VAR 0 2
65576: ARRAY
65577: IFFALSE 66394
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65579: LD_EXP 28
65583: PUSH
65584: LD_VAR 0 2
65588: ARRAY
65589: PUSH
65590: LD_INT 1
65592: ARRAY
65593: PUSH
65594: LD_INT 1
65596: ARRAY
65597: PPUSH
65598: CALL 19365 0 1
65602: IFFALSE 65650
65604: PUSH
65605: LD_EXP 23
65609: PUSH
65610: LD_VAR 0 2
65614: ARRAY
65615: PPUSH
65616: LD_INT 2
65618: PUSH
65619: LD_INT 30
65621: PUSH
65622: LD_INT 2
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 30
65631: PUSH
65632: LD_INT 3
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: PUSH
65639: EMPTY
65640: LIST
65641: LIST
65642: LIST
65643: PPUSH
65644: CALL_OW 72
65648: NOT
65649: AND
65650: IFFALSE 65755
// begin for j = 1 to mc_build_list [ i ] do
65652: LD_ADDR_VAR 0 3
65656: PUSH
65657: DOUBLE
65658: LD_INT 1
65660: DEC
65661: ST_TO_ADDR
65662: LD_EXP 28
65666: PUSH
65667: LD_VAR 0 2
65671: ARRAY
65672: PUSH
65673: FOR_TO
65674: IFFALSE 65753
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65676: LD_EXP 28
65680: PUSH
65681: LD_VAR 0 2
65685: ARRAY
65686: PUSH
65687: LD_VAR 0 3
65691: ARRAY
65692: PUSH
65693: LD_INT 1
65695: ARRAY
65696: PUSH
65697: LD_INT 2
65699: EQUAL
65700: IFFALSE 65751
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65702: LD_ADDR_EXP 28
65706: PUSH
65707: LD_EXP 28
65711: PPUSH
65712: LD_VAR 0 2
65716: PPUSH
65717: LD_EXP 28
65721: PUSH
65722: LD_VAR 0 2
65726: ARRAY
65727: PPUSH
65728: LD_VAR 0 3
65732: PPUSH
65733: LD_INT 1
65735: PPUSH
65736: LD_INT 0
65738: PPUSH
65739: CALL 15697 0 4
65743: PPUSH
65744: CALL_OW 1
65748: ST_TO_ADDR
// break ;
65749: GO 65753
// end ;
65751: GO 65673
65753: POP
65754: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65755: LD_ADDR_VAR 0 6
65759: PUSH
65760: LD_EXP 23
65764: PUSH
65765: LD_VAR 0 2
65769: ARRAY
65770: PPUSH
65771: LD_INT 2
65773: PUSH
65774: LD_INT 30
65776: PUSH
65777: LD_INT 0
65779: PUSH
65780: EMPTY
65781: LIST
65782: LIST
65783: PUSH
65784: LD_INT 30
65786: PUSH
65787: LD_INT 1
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: LIST
65798: PPUSH
65799: CALL_OW 72
65803: ST_TO_ADDR
// for k := 1 to depot do
65804: LD_ADDR_VAR 0 4
65808: PUSH
65809: DOUBLE
65810: LD_INT 1
65812: DEC
65813: ST_TO_ADDR
65814: LD_VAR 0 6
65818: PUSH
65819: FOR_TO
65820: IFFALSE 66392
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65822: LD_EXP 28
65826: PUSH
65827: LD_VAR 0 2
65831: ARRAY
65832: PUSH
65833: LD_INT 1
65835: ARRAY
65836: PUSH
65837: LD_INT 1
65839: ARRAY
65840: PUSH
65841: LD_INT 0
65843: EQUAL
65844: IFTRUE 65939
65846: PUSH
65847: LD_VAR 0 6
65851: PUSH
65852: LD_VAR 0 4
65856: ARRAY
65857: PPUSH
65858: LD_EXP 28
65862: PUSH
65863: LD_VAR 0 2
65867: ARRAY
65868: PUSH
65869: LD_INT 1
65871: ARRAY
65872: PUSH
65873: LD_INT 1
65875: ARRAY
65876: PPUSH
65877: LD_EXP 28
65881: PUSH
65882: LD_VAR 0 2
65886: ARRAY
65887: PUSH
65888: LD_INT 1
65890: ARRAY
65891: PUSH
65892: LD_INT 2
65894: ARRAY
65895: PPUSH
65896: LD_EXP 28
65900: PUSH
65901: LD_VAR 0 2
65905: ARRAY
65906: PUSH
65907: LD_INT 1
65909: ARRAY
65910: PUSH
65911: LD_INT 3
65913: ARRAY
65914: PPUSH
65915: LD_EXP 28
65919: PUSH
65920: LD_VAR 0 2
65924: ARRAY
65925: PUSH
65926: LD_INT 1
65928: ARRAY
65929: PUSH
65930: LD_INT 4
65932: ARRAY
65933: PPUSH
65934: CALL 24845 0 5
65938: OR
65939: IFFALSE 66220
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65941: LD_ADDR_VAR 0 5
65945: PUSH
65946: LD_EXP 23
65950: PUSH
65951: LD_VAR 0 2
65955: ARRAY
65956: PPUSH
65957: LD_INT 25
65959: PUSH
65960: LD_INT 2
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PPUSH
65967: CALL_OW 72
65971: PUSH
65972: LD_EXP 25
65976: PUSH
65977: LD_VAR 0 2
65981: ARRAY
65982: DIFF
65983: ST_TO_ADDR
// if not tmp then
65984: LD_VAR 0 5
65988: NOT
65989: IFFALSE 65993
// continue ;
65991: GO 65819
// for j in tmp do
65993: LD_ADDR_VAR 0 3
65997: PUSH
65998: LD_VAR 0 5
66002: PUSH
66003: FOR_IN
66004: IFFALSE 66216
// begin if not mc_builders [ i ] then
66006: LD_EXP 29
66010: PUSH
66011: LD_VAR 0 2
66015: ARRAY
66016: NOT
66017: IFFALSE 66075
// begin SetTag ( j , 103 ) ;
66019: LD_VAR 0 3
66023: PPUSH
66024: LD_INT 103
66026: PPUSH
66027: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66031: LD_ADDR_EXP 29
66035: PUSH
66036: LD_EXP 29
66040: PPUSH
66041: LD_VAR 0 2
66045: PUSH
66046: LD_EXP 29
66050: PUSH
66051: LD_VAR 0 2
66055: ARRAY
66056: PUSH
66057: LD_INT 1
66059: PLUS
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PPUSH
66065: LD_VAR 0 3
66069: PPUSH
66070: CALL 16289 0 3
66074: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66075: LD_VAR 0 3
66079: PPUSH
66080: CALL_OW 310
66084: IFFALSE 66095
// ComExitBuilding ( j ) ;
66086: LD_VAR 0 3
66090: PPUSH
66091: CALL_OW 122
// wait ( 3 ) ;
66095: LD_INT 3
66097: PPUSH
66098: CALL_OW 67
// if not mc_build_list [ i ] then
66102: LD_EXP 28
66106: PUSH
66107: LD_VAR 0 2
66111: ARRAY
66112: NOT
66113: IFFALSE 66117
// break ;
66115: GO 66216
// if not HasTask ( j ) then
66117: LD_VAR 0 3
66121: PPUSH
66122: CALL_OW 314
66126: NOT
66127: IFFALSE 66214
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66129: LD_VAR 0 3
66133: PPUSH
66134: LD_EXP 28
66138: PUSH
66139: LD_VAR 0 2
66143: ARRAY
66144: PUSH
66145: LD_INT 1
66147: ARRAY
66148: PUSH
66149: LD_INT 1
66151: ARRAY
66152: PPUSH
66153: LD_EXP 28
66157: PUSH
66158: LD_VAR 0 2
66162: ARRAY
66163: PUSH
66164: LD_INT 1
66166: ARRAY
66167: PUSH
66168: LD_INT 2
66170: ARRAY
66171: PPUSH
66172: LD_EXP 28
66176: PUSH
66177: LD_VAR 0 2
66181: ARRAY
66182: PUSH
66183: LD_INT 1
66185: ARRAY
66186: PUSH
66187: LD_INT 3
66189: ARRAY
66190: PPUSH
66191: LD_EXP 28
66195: PUSH
66196: LD_VAR 0 2
66200: ARRAY
66201: PUSH
66202: LD_INT 1
66204: ARRAY
66205: PUSH
66206: LD_INT 4
66208: ARRAY
66209: PPUSH
66210: CALL_OW 145
// end ;
66214: GO 66003
66216: POP
66217: POP
// end else
66218: GO 66390
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66220: LD_EXP 23
66224: PUSH
66225: LD_VAR 0 2
66229: ARRAY
66230: PPUSH
66231: LD_EXP 28
66235: PUSH
66236: LD_VAR 0 2
66240: ARRAY
66241: PUSH
66242: LD_INT 1
66244: ARRAY
66245: PUSH
66246: LD_INT 1
66248: ARRAY
66249: PPUSH
66250: LD_EXP 28
66254: PUSH
66255: LD_VAR 0 2
66259: ARRAY
66260: PUSH
66261: LD_INT 1
66263: ARRAY
66264: PUSH
66265: LD_INT 2
66267: ARRAY
66268: PPUSH
66269: LD_EXP 28
66273: PUSH
66274: LD_VAR 0 2
66278: ARRAY
66279: PUSH
66280: LD_INT 1
66282: ARRAY
66283: PUSH
66284: LD_INT 3
66286: ARRAY
66287: PPUSH
66288: LD_EXP 28
66292: PUSH
66293: LD_VAR 0 2
66297: ARRAY
66298: PUSH
66299: LD_INT 1
66301: ARRAY
66302: PUSH
66303: LD_INT 4
66305: ARRAY
66306: PPUSH
66307: LD_EXP 23
66311: PUSH
66312: LD_VAR 0 2
66316: ARRAY
66317: PPUSH
66318: LD_INT 21
66320: PUSH
66321: LD_INT 3
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PPUSH
66328: CALL_OW 72
66332: PPUSH
66333: EMPTY
66334: PPUSH
66335: CALL 23581 0 7
66339: NOT
66340: IFFALSE 66390
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66342: LD_ADDR_EXP 28
66346: PUSH
66347: LD_EXP 28
66351: PPUSH
66352: LD_VAR 0 2
66356: PPUSH
66357: LD_EXP 28
66361: PUSH
66362: LD_VAR 0 2
66366: ARRAY
66367: PPUSH
66368: LD_INT 1
66370: PPUSH
66371: LD_INT 1
66373: NEG
66374: PPUSH
66375: LD_INT 0
66377: PPUSH
66378: CALL 15697 0 4
66382: PPUSH
66383: CALL_OW 1
66387: ST_TO_ADDR
// continue ;
66388: GO 65819
// end ; end ;
66390: GO 65819
66392: POP
66393: POP
// end ; end ;
66394: GO 65242
66396: POP
66397: POP
// end ;
66398: LD_VAR 0 1
66402: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66403: LD_INT 0
66405: PPUSH
66406: PPUSH
66407: PPUSH
66408: PPUSH
66409: PPUSH
66410: PPUSH
// if not mc_bases then
66411: LD_EXP 23
66415: NOT
66416: IFFALSE 66420
// exit ;
66418: GO 66853
// for i = 1 to mc_bases do
66420: LD_ADDR_VAR 0 2
66424: PUSH
66425: DOUBLE
66426: LD_INT 1
66428: DEC
66429: ST_TO_ADDR
66430: LD_EXP 23
66434: PUSH
66435: FOR_TO
66436: IFFALSE 66851
// begin tmp := mc_build_upgrade [ i ] ;
66438: LD_ADDR_VAR 0 4
66442: PUSH
66443: LD_EXP 55
66447: PUSH
66448: LD_VAR 0 2
66452: ARRAY
66453: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66454: LD_ADDR_VAR 0 6
66458: PUSH
66459: LD_EXP 56
66463: PUSH
66464: LD_VAR 0 2
66468: ARRAY
66469: PPUSH
66470: LD_INT 2
66472: PUSH
66473: LD_INT 30
66475: PUSH
66476: LD_INT 6
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 30
66485: PUSH
66486: LD_INT 7
66488: PUSH
66489: EMPTY
66490: LIST
66491: LIST
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: LIST
66497: PPUSH
66498: CALL_OW 72
66502: ST_TO_ADDR
// if not tmp and not lab then
66503: LD_VAR 0 4
66507: NOT
66508: IFFALSE 66517
66510: PUSH
66511: LD_VAR 0 6
66515: NOT
66516: AND
66517: IFFALSE 66521
// continue ;
66519: GO 66435
// if tmp then
66521: LD_VAR 0 4
66525: IFFALSE 66645
// for j in tmp do
66527: LD_ADDR_VAR 0 3
66531: PUSH
66532: LD_VAR 0 4
66536: PUSH
66537: FOR_IN
66538: IFFALSE 66643
// begin if UpgradeCost ( j ) then
66540: LD_VAR 0 3
66544: PPUSH
66545: CALL 23233 0 1
66549: IFFALSE 66641
// begin ComUpgrade ( j ) ;
66551: LD_VAR 0 3
66555: PPUSH
66556: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66560: LD_ADDR_EXP 55
66564: PUSH
66565: LD_EXP 55
66569: PPUSH
66570: LD_VAR 0 2
66574: PPUSH
66575: LD_EXP 55
66579: PUSH
66580: LD_VAR 0 2
66584: ARRAY
66585: PUSH
66586: LD_VAR 0 3
66590: DIFF
66591: PPUSH
66592: CALL_OW 1
66596: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66597: LD_ADDR_EXP 30
66601: PUSH
66602: LD_EXP 30
66606: PPUSH
66607: LD_VAR 0 2
66611: PUSH
66612: LD_EXP 30
66616: PUSH
66617: LD_VAR 0 2
66621: ARRAY
66622: PUSH
66623: LD_INT 1
66625: PLUS
66626: PUSH
66627: EMPTY
66628: LIST
66629: LIST
66630: PPUSH
66631: LD_VAR 0 3
66635: PPUSH
66636: CALL 16289 0 3
66640: ST_TO_ADDR
// end ; end ;
66641: GO 66537
66643: POP
66644: POP
// if not lab or not mc_lab_upgrade [ i ] then
66645: LD_VAR 0 6
66649: NOT
66650: IFTRUE 66665
66652: PUSH
66653: LD_EXP 57
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: NOT
66664: OR
66665: IFFALSE 66669
// continue ;
66667: GO 66435
// for j in lab do
66669: LD_ADDR_VAR 0 3
66673: PUSH
66674: LD_VAR 0 6
66678: PUSH
66679: FOR_IN
66680: IFFALSE 66847
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66682: LD_VAR 0 3
66686: PPUSH
66687: CALL_OW 266
66691: PUSH
66692: LD_INT 6
66694: PUSH
66695: LD_INT 7
66697: PUSH
66698: EMPTY
66699: LIST
66700: LIST
66701: IN
66702: IFFALSE 66719
66704: PUSH
66705: LD_VAR 0 3
66709: PPUSH
66710: CALL_OW 461
66714: PUSH
66715: LD_INT 1
66717: NONEQUAL
66718: AND
66719: IFFALSE 66845
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66721: LD_VAR 0 3
66725: PPUSH
66726: LD_EXP 57
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: PUSH
66737: LD_INT 1
66739: ARRAY
66740: PPUSH
66741: CALL 23442 0 2
66745: IFFALSE 66845
// begin ComCancel ( j ) ;
66747: LD_VAR 0 3
66751: PPUSH
66752: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66756: LD_VAR 0 3
66760: PPUSH
66761: LD_EXP 57
66765: PUSH
66766: LD_VAR 0 2
66770: ARRAY
66771: PUSH
66772: LD_INT 1
66774: ARRAY
66775: PPUSH
66776: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66780: LD_VAR 0 3
66784: PUSH
66785: LD_EXP 30
66789: PUSH
66790: LD_VAR 0 2
66794: ARRAY
66795: IN
66796: NOT
66797: IFFALSE 66843
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66799: LD_ADDR_EXP 30
66803: PUSH
66804: LD_EXP 30
66808: PPUSH
66809: LD_VAR 0 2
66813: PUSH
66814: LD_EXP 30
66818: PUSH
66819: LD_VAR 0 2
66823: ARRAY
66824: PUSH
66825: LD_INT 1
66827: PLUS
66828: PUSH
66829: EMPTY
66830: LIST
66831: LIST
66832: PPUSH
66833: LD_VAR 0 3
66837: PPUSH
66838: CALL 16289 0 3
66842: ST_TO_ADDR
// break ;
66843: GO 66847
// end ; end ; end ;
66845: GO 66679
66847: POP
66848: POP
// end ;
66849: GO 66435
66851: POP
66852: POP
// end ;
66853: LD_VAR 0 1
66857: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66858: LD_INT 0
66860: PPUSH
66861: PPUSH
66862: PPUSH
66863: PPUSH
66864: PPUSH
66865: PPUSH
66866: PPUSH
66867: PPUSH
66868: PPUSH
// if not mc_bases then
66869: LD_EXP 23
66873: NOT
66874: IFFALSE 66878
// exit ;
66876: GO 67285
// for i = 1 to mc_bases do
66878: LD_ADDR_VAR 0 2
66882: PUSH
66883: DOUBLE
66884: LD_INT 1
66886: DEC
66887: ST_TO_ADDR
66888: LD_EXP 23
66892: PUSH
66893: FOR_TO
66894: IFFALSE 67283
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66896: LD_EXP 31
66900: PUSH
66901: LD_VAR 0 2
66905: ARRAY
66906: NOT
66907: IFTRUE 66937
66909: PUSH
66910: LD_EXP 23
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PPUSH
66921: LD_INT 30
66923: PUSH
66924: LD_INT 3
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PPUSH
66931: CALL_OW 72
66935: NOT
66936: OR
66937: IFFALSE 66941
// continue ;
66939: GO 66893
// busy := false ;
66941: LD_ADDR_VAR 0 8
66945: PUSH
66946: LD_INT 0
66948: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66949: LD_ADDR_VAR 0 4
66953: PUSH
66954: LD_EXP 23
66958: PUSH
66959: LD_VAR 0 2
66963: ARRAY
66964: PPUSH
66965: LD_INT 30
66967: PUSH
66968: LD_INT 3
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PPUSH
66975: CALL_OW 72
66979: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66980: LD_ADDR_VAR 0 6
66984: PUSH
66985: LD_EXP 31
66989: PUSH
66990: LD_VAR 0 2
66994: ARRAY
66995: PPUSH
66996: LD_INT 2
66998: PUSH
66999: LD_INT 30
67001: PUSH
67002: LD_INT 32
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: PUSH
67009: LD_INT 30
67011: PUSH
67012: LD_INT 33
67014: PUSH
67015: EMPTY
67016: LIST
67017: LIST
67018: PUSH
67019: EMPTY
67020: LIST
67021: LIST
67022: LIST
67023: PPUSH
67024: CALL_OW 72
67028: ST_TO_ADDR
// if not t then
67029: LD_VAR 0 6
67033: NOT
67034: IFFALSE 67038
// continue ;
67036: GO 66893
// for j in tmp do
67038: LD_ADDR_VAR 0 3
67042: PUSH
67043: LD_VAR 0 4
67047: PUSH
67048: FOR_IN
67049: IFFALSE 67079
// if not BuildingStatus ( j ) = bs_idle then
67051: LD_VAR 0 3
67055: PPUSH
67056: CALL_OW 461
67060: PUSH
67061: LD_INT 2
67063: EQUAL
67064: NOT
67065: IFFALSE 67077
// begin busy := true ;
67067: LD_ADDR_VAR 0 8
67071: PUSH
67072: LD_INT 1
67074: ST_TO_ADDR
// break ;
67075: GO 67079
// end ;
67077: GO 67048
67079: POP
67080: POP
// if busy then
67081: LD_VAR 0 8
67085: IFFALSE 67089
// continue ;
67087: GO 66893
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67089: LD_ADDR_VAR 0 7
67093: PUSH
67094: LD_VAR 0 6
67098: PPUSH
67099: LD_INT 35
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: EMPTY
67106: LIST
67107: LIST
67108: PPUSH
67109: CALL_OW 72
67113: ST_TO_ADDR
// if tw then
67114: LD_VAR 0 7
67118: IFFALSE 67195
// begin tw := tw [ 1 ] ;
67120: LD_ADDR_VAR 0 7
67124: PUSH
67125: LD_VAR 0 7
67129: PUSH
67130: LD_INT 1
67132: ARRAY
67133: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67134: LD_ADDR_VAR 0 9
67138: PUSH
67139: LD_VAR 0 7
67143: PPUSH
67144: LD_EXP 48
67148: PUSH
67149: LD_VAR 0 2
67153: ARRAY
67154: PPUSH
67155: CALL 21696 0 2
67159: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67160: LD_EXP 62
67164: PUSH
67165: LD_VAR 0 2
67169: ARRAY
67170: IFFALSE 67193
// if not weapon in mc_allowed_tower_weapons [ i ] then
67172: LD_VAR 0 9
67176: PUSH
67177: LD_EXP 62
67181: PUSH
67182: LD_VAR 0 2
67186: ARRAY
67187: IN
67188: NOT
67189: IFFALSE 67193
// continue ;
67191: GO 66893
// end else
67193: GO 67258
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67195: LD_ADDR_VAR 0 5
67199: PUSH
67200: LD_EXP 31
67204: PUSH
67205: LD_VAR 0 2
67209: ARRAY
67210: PPUSH
67211: LD_VAR 0 4
67215: PPUSH
67216: CALL 48891 0 2
67220: ST_TO_ADDR
// if not tmp2 then
67221: LD_VAR 0 5
67225: NOT
67226: IFFALSE 67230
// continue ;
67228: GO 66893
// tw := tmp2 [ 1 ] ;
67230: LD_ADDR_VAR 0 7
67234: PUSH
67235: LD_VAR 0 5
67239: PUSH
67240: LD_INT 1
67242: ARRAY
67243: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67244: LD_ADDR_VAR 0 9
67248: PUSH
67249: LD_VAR 0 5
67253: PUSH
67254: LD_INT 2
67256: ARRAY
67257: ST_TO_ADDR
// end ; if not weapon then
67258: LD_VAR 0 9
67262: NOT
67263: IFFALSE 67267
// continue ;
67265: GO 66893
// ComPlaceWeapon ( tw , weapon ) ;
67267: LD_VAR 0 7
67271: PPUSH
67272: LD_VAR 0 9
67276: PPUSH
67277: CALL_OW 148
// end ;
67281: GO 66893
67283: POP
67284: POP
// end ;
67285: LD_VAR 0 1
67289: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67290: LD_INT 0
67292: PPUSH
67293: PPUSH
67294: PPUSH
67295: PPUSH
67296: PPUSH
67297: PPUSH
67298: PPUSH
// if not mc_bases then
67299: LD_EXP 23
67303: NOT
67304: IFFALSE 67308
// exit ;
67306: GO 68095
// for i = 1 to mc_bases do
67308: LD_ADDR_VAR 0 2
67312: PUSH
67313: DOUBLE
67314: LD_INT 1
67316: DEC
67317: ST_TO_ADDR
67318: LD_EXP 23
67322: PUSH
67323: FOR_TO
67324: IFFALSE 68093
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67326: LD_EXP 36
67330: PUSH
67331: LD_VAR 0 2
67335: ARRAY
67336: NOT
67337: IFTRUE 67363
67339: PUSH
67340: LD_EXP 36
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: PUSH
67351: LD_EXP 37
67355: PUSH
67356: LD_VAR 0 2
67360: ARRAY
67361: EQUAL
67362: OR
67363: IFTRUE 67377
67365: PUSH
67366: LD_EXP 46
67370: PUSH
67371: LD_VAR 0 2
67375: ARRAY
67376: OR
67377: IFFALSE 67381
// continue ;
67379: GO 67323
// if mc_miners [ i ] then
67381: LD_EXP 37
67385: PUSH
67386: LD_VAR 0 2
67390: ARRAY
67391: IFFALSE 67778
// begin for j = mc_miners [ i ] downto 1 do
67393: LD_ADDR_VAR 0 3
67397: PUSH
67398: DOUBLE
67399: LD_EXP 37
67403: PUSH
67404: LD_VAR 0 2
67408: ARRAY
67409: INC
67410: ST_TO_ADDR
67411: LD_INT 1
67413: PUSH
67414: FOR_DOWNTO
67415: IFFALSE 67776
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67417: LD_EXP 37
67421: PUSH
67422: LD_VAR 0 2
67426: ARRAY
67427: PUSH
67428: LD_VAR 0 3
67432: ARRAY
67433: PPUSH
67434: CALL_OW 301
67438: IFTRUE 67467
67440: PUSH
67441: LD_EXP 37
67445: PUSH
67446: LD_VAR 0 2
67450: ARRAY
67451: PUSH
67452: LD_VAR 0 3
67456: ARRAY
67457: PPUSH
67458: CALL_OW 257
67462: PUSH
67463: LD_INT 1
67465: NONEQUAL
67466: OR
67467: IFFALSE 67530
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67469: LD_ADDR_VAR 0 5
67473: PUSH
67474: LD_EXP 37
67478: PUSH
67479: LD_VAR 0 2
67483: ARRAY
67484: PUSH
67485: LD_EXP 37
67489: PUSH
67490: LD_VAR 0 2
67494: ARRAY
67495: PUSH
67496: LD_VAR 0 3
67500: ARRAY
67501: DIFF
67502: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67503: LD_ADDR_EXP 37
67507: PUSH
67508: LD_EXP 37
67512: PPUSH
67513: LD_VAR 0 2
67517: PPUSH
67518: LD_VAR 0 5
67522: PPUSH
67523: CALL_OW 1
67527: ST_TO_ADDR
// continue ;
67528: GO 67414
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67530: LD_EXP 37
67534: PUSH
67535: LD_VAR 0 2
67539: ARRAY
67540: PUSH
67541: LD_VAR 0 3
67545: ARRAY
67546: PPUSH
67547: CALL_OW 257
67551: PUSH
67552: LD_INT 1
67554: EQUAL
67555: IFFALSE 67581
67557: PUSH
67558: LD_EXP 37
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: PUSH
67569: LD_VAR 0 3
67573: ARRAY
67574: PPUSH
67575: CALL_OW 459
67579: NOT
67580: AND
67581: IFFALSE 67607
67583: PUSH
67584: LD_EXP 37
67588: PUSH
67589: LD_VAR 0 2
67593: ARRAY
67594: PUSH
67595: LD_VAR 0 3
67599: ARRAY
67600: PPUSH
67601: CALL_OW 314
67605: NOT
67606: AND
67607: IFFALSE 67774
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67609: LD_EXP 37
67613: PUSH
67614: LD_VAR 0 2
67618: ARRAY
67619: PUSH
67620: LD_VAR 0 3
67624: ARRAY
67625: PPUSH
67626: CALL_OW 310
67630: IFFALSE 67653
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67632: LD_EXP 37
67636: PUSH
67637: LD_VAR 0 2
67641: ARRAY
67642: PUSH
67643: LD_VAR 0 3
67647: ARRAY
67648: PPUSH
67649: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67653: LD_EXP 37
67657: PUSH
67658: LD_VAR 0 2
67662: ARRAY
67663: PUSH
67664: LD_VAR 0 3
67668: ARRAY
67669: PPUSH
67670: CALL_OW 314
67674: NOT
67675: IFFALSE 67774
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
67677: LD_ADDR_VAR 0 7
67681: PUSH
67682: LD_VAR 0 3
67686: PUSH
67687: LD_EXP 36
67691: PUSH
67692: LD_VAR 0 2
67696: ARRAY
67697: PPUSH
67698: CALL 13371 0 1
67702: MOD
67703: PUSH
67704: LD_INT 1
67706: PLUS
67707: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67708: LD_EXP 37
67712: PUSH
67713: LD_VAR 0 2
67717: ARRAY
67718: PUSH
67719: LD_VAR 0 3
67723: ARRAY
67724: PPUSH
67725: LD_EXP 36
67729: PUSH
67730: LD_VAR 0 2
67734: ARRAY
67735: PUSH
67736: LD_VAR 0 7
67740: ARRAY
67741: PUSH
67742: LD_INT 1
67744: ARRAY
67745: PPUSH
67746: LD_EXP 36
67750: PUSH
67751: LD_VAR 0 2
67755: ARRAY
67756: PUSH
67757: LD_VAR 0 7
67761: ARRAY
67762: PUSH
67763: LD_INT 2
67765: ARRAY
67766: PPUSH
67767: LD_INT 0
67769: PPUSH
67770: CALL_OW 193
// end ; end ; end ;
67774: GO 67414
67776: POP
67777: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67778: LD_ADDR_VAR 0 5
67782: PUSH
67783: LD_EXP 23
67787: PUSH
67788: LD_VAR 0 2
67792: ARRAY
67793: PPUSH
67794: LD_INT 2
67796: PUSH
67797: LD_INT 30
67799: PUSH
67800: LD_INT 4
67802: PUSH
67803: EMPTY
67804: LIST
67805: LIST
67806: PUSH
67807: LD_INT 30
67809: PUSH
67810: LD_INT 5
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 30
67819: PUSH
67820: LD_INT 32
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: PPUSH
67833: CALL_OW 72
67837: ST_TO_ADDR
// if not tmp then
67838: LD_VAR 0 5
67842: NOT
67843: IFFALSE 67847
// continue ;
67845: GO 67323
// list := [ ] ;
67847: LD_ADDR_VAR 0 6
67851: PUSH
67852: EMPTY
67853: ST_TO_ADDR
// for j in tmp do
67854: LD_ADDR_VAR 0 3
67858: PUSH
67859: LD_VAR 0 5
67863: PUSH
67864: FOR_IN
67865: IFFALSE 67936
// begin for k in UnitsInside ( j ) do
67867: LD_ADDR_VAR 0 4
67871: PUSH
67872: LD_VAR 0 3
67876: PPUSH
67877: CALL_OW 313
67881: PUSH
67882: FOR_IN
67883: IFFALSE 67932
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67885: LD_VAR 0 4
67889: PPUSH
67890: CALL_OW 257
67894: PUSH
67895: LD_INT 1
67897: EQUAL
67898: IFFALSE 67912
67900: PUSH
67901: LD_VAR 0 4
67905: PPUSH
67906: CALL_OW 459
67910: NOT
67911: AND
67912: IFFALSE 67930
// list := list ^ k ;
67914: LD_ADDR_VAR 0 6
67918: PUSH
67919: LD_VAR 0 6
67923: PUSH
67924: LD_VAR 0 4
67928: ADD
67929: ST_TO_ADDR
67930: GO 67882
67932: POP
67933: POP
// end ;
67934: GO 67864
67936: POP
67937: POP
// list := list diff mc_miners [ i ] ;
67938: LD_ADDR_VAR 0 6
67942: PUSH
67943: LD_VAR 0 6
67947: PUSH
67948: LD_EXP 37
67952: PUSH
67953: LD_VAR 0 2
67957: ARRAY
67958: DIFF
67959: ST_TO_ADDR
// if not list then
67960: LD_VAR 0 6
67964: NOT
67965: IFFALSE 67969
// continue ;
67967: GO 67323
// k := mc_mines [ i ] - mc_miners [ i ] ;
67969: LD_ADDR_VAR 0 4
67973: PUSH
67974: LD_EXP 36
67978: PUSH
67979: LD_VAR 0 2
67983: ARRAY
67984: PUSH
67985: LD_EXP 37
67989: PUSH
67990: LD_VAR 0 2
67994: ARRAY
67995: MINUS
67996: ST_TO_ADDR
// if k > list then
67997: LD_VAR 0 4
68001: PUSH
68002: LD_VAR 0 6
68006: GREATER
68007: IFFALSE 68019
// k := list ;
68009: LD_ADDR_VAR 0 4
68013: PUSH
68014: LD_VAR 0 6
68018: ST_TO_ADDR
// for j = 1 to k do
68019: LD_ADDR_VAR 0 3
68023: PUSH
68024: DOUBLE
68025: LD_INT 1
68027: DEC
68028: ST_TO_ADDR
68029: LD_VAR 0 4
68033: PUSH
68034: FOR_TO
68035: IFFALSE 68089
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68037: LD_ADDR_EXP 37
68041: PUSH
68042: LD_EXP 37
68046: PPUSH
68047: LD_VAR 0 2
68051: PUSH
68052: LD_EXP 37
68056: PUSH
68057: LD_VAR 0 2
68061: ARRAY
68062: PUSH
68063: LD_INT 1
68065: PLUS
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PPUSH
68071: LD_VAR 0 6
68075: PUSH
68076: LD_VAR 0 3
68080: ARRAY
68081: PPUSH
68082: CALL 16289 0 3
68086: ST_TO_ADDR
68087: GO 68034
68089: POP
68090: POP
// end ;
68091: GO 67323
68093: POP
68094: POP
// end ;
68095: LD_VAR 0 1
68099: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68100: LD_INT 0
68102: PPUSH
68103: PPUSH
68104: PPUSH
68105: PPUSH
68106: PPUSH
68107: PPUSH
68108: PPUSH
68109: PPUSH
68110: PPUSH
68111: PPUSH
68112: PPUSH
// if not mc_bases then
68113: LD_EXP 23
68117: NOT
68118: IFFALSE 68122
// exit ;
68120: GO 69969
// for i = 1 to mc_bases do
68122: LD_ADDR_VAR 0 2
68126: PUSH
68127: DOUBLE
68128: LD_INT 1
68130: DEC
68131: ST_TO_ADDR
68132: LD_EXP 23
68136: PUSH
68137: FOR_TO
68138: IFFALSE 69967
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68140: LD_EXP 23
68144: PUSH
68145: LD_VAR 0 2
68149: ARRAY
68150: NOT
68151: IFTRUE 68165
68153: PUSH
68154: LD_EXP 30
68158: PUSH
68159: LD_VAR 0 2
68163: ARRAY
68164: OR
68165: IFFALSE 68169
// continue ;
68167: GO 68137
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68169: LD_EXP 39
68173: PUSH
68174: LD_VAR 0 2
68178: ARRAY
68179: NOT
68180: IFFALSE 68194
68182: PUSH
68183: LD_EXP 40
68187: PUSH
68188: LD_VAR 0 2
68192: ARRAY
68193: AND
68194: IFFALSE 68232
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68196: LD_ADDR_EXP 40
68200: PUSH
68201: LD_EXP 40
68205: PPUSH
68206: LD_VAR 0 2
68210: PPUSH
68211: EMPTY
68212: PPUSH
68213: CALL_OW 1
68217: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68218: LD_VAR 0 2
68222: PPUSH
68223: LD_INT 107
68225: PPUSH
68226: CALL 58870 0 2
// continue ;
68230: GO 68137
// end ; target := [ ] ;
68232: LD_ADDR_VAR 0 7
68236: PUSH
68237: EMPTY
68238: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68239: LD_ADDR_VAR 0 6
68243: PUSH
68244: LD_EXP 23
68248: PUSH
68249: LD_VAR 0 2
68253: ARRAY
68254: PUSH
68255: LD_INT 1
68257: ARRAY
68258: PPUSH
68259: CALL_OW 255
68263: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68264: LD_ADDR_VAR 0 9
68268: PUSH
68269: LD_EXP 23
68273: PUSH
68274: LD_VAR 0 2
68278: ARRAY
68279: PPUSH
68280: LD_INT 2
68282: PUSH
68283: LD_INT 30
68285: PUSH
68286: LD_INT 0
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 30
68295: PUSH
68296: LD_INT 1
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: LIST
68307: PPUSH
68308: CALL_OW 72
68312: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68313: LD_ADDR_VAR 0 3
68317: PUSH
68318: DOUBLE
68319: LD_EXP 39
68323: PUSH
68324: LD_VAR 0 2
68328: ARRAY
68329: INC
68330: ST_TO_ADDR
68331: LD_INT 1
68333: PUSH
68334: FOR_DOWNTO
68335: IFFALSE 68582
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68337: LD_EXP 39
68341: PUSH
68342: LD_VAR 0 2
68346: ARRAY
68347: PUSH
68348: LD_VAR 0 3
68352: ARRAY
68353: PUSH
68354: LD_INT 2
68356: ARRAY
68357: PPUSH
68358: LD_EXP 39
68362: PUSH
68363: LD_VAR 0 2
68367: ARRAY
68368: PUSH
68369: LD_VAR 0 3
68373: ARRAY
68374: PUSH
68375: LD_INT 3
68377: ARRAY
68378: PPUSH
68379: CALL_OW 488
68383: IFFALSE 68437
68385: PUSH
68386: LD_EXP 39
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: PUSH
68397: LD_VAR 0 3
68401: ARRAY
68402: PUSH
68403: LD_INT 2
68405: ARRAY
68406: PPUSH
68407: LD_EXP 39
68411: PUSH
68412: LD_VAR 0 2
68416: ARRAY
68417: PUSH
68418: LD_VAR 0 3
68422: ARRAY
68423: PUSH
68424: LD_INT 3
68426: ARRAY
68427: PPUSH
68428: CALL_OW 284
68432: PUSH
68433: LD_INT 0
68435: EQUAL
68436: AND
68437: IFFALSE 68492
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68439: LD_ADDR_VAR 0 5
68443: PUSH
68444: LD_EXP 39
68448: PUSH
68449: LD_VAR 0 2
68453: ARRAY
68454: PPUSH
68455: LD_VAR 0 3
68459: PPUSH
68460: CALL_OW 3
68464: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68465: LD_ADDR_EXP 39
68469: PUSH
68470: LD_EXP 39
68474: PPUSH
68475: LD_VAR 0 2
68479: PPUSH
68480: LD_VAR 0 5
68484: PPUSH
68485: CALL_OW 1
68489: ST_TO_ADDR
// continue ;
68490: GO 68334
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68492: LD_VAR 0 6
68496: PPUSH
68497: LD_EXP 39
68501: PUSH
68502: LD_VAR 0 2
68506: ARRAY
68507: PUSH
68508: LD_VAR 0 3
68512: ARRAY
68513: PUSH
68514: LD_INT 2
68516: ARRAY
68517: PPUSH
68518: LD_EXP 39
68522: PUSH
68523: LD_VAR 0 2
68527: ARRAY
68528: PUSH
68529: LD_VAR 0 3
68533: ARRAY
68534: PUSH
68535: LD_INT 3
68537: ARRAY
68538: PPUSH
68539: LD_INT 30
68541: PPUSH
68542: CALL 17559 0 4
68546: PUSH
68547: LD_INT 4
68549: ARRAY
68550: PUSH
68551: LD_INT 0
68553: EQUAL
68554: IFFALSE 68580
// begin target := mc_crates [ i ] [ j ] ;
68556: LD_ADDR_VAR 0 7
68560: PUSH
68561: LD_EXP 39
68565: PUSH
68566: LD_VAR 0 2
68570: ARRAY
68571: PUSH
68572: LD_VAR 0 3
68576: ARRAY
68577: ST_TO_ADDR
// break ;
68578: GO 68582
// end ; end ;
68580: GO 68334
68582: POP
68583: POP
// if not target then
68584: LD_VAR 0 7
68588: NOT
68589: IFFALSE 68593
// continue ;
68591: GO 68137
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68593: LD_ADDR_VAR 0 8
68597: PUSH
68598: LD_EXP 42
68602: PUSH
68603: LD_VAR 0 2
68607: ARRAY
68608: PPUSH
68609: LD_INT 2
68611: PUSH
68612: LD_INT 3
68614: PUSH
68615: LD_INT 58
68617: PUSH
68618: EMPTY
68619: LIST
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: PUSH
68625: LD_INT 61
68627: PUSH
68628: EMPTY
68629: LIST
68630: PUSH
68631: LD_INT 33
68633: PUSH
68634: LD_INT 5
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: PUSH
68641: LD_INT 33
68643: PUSH
68644: LD_INT 3
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: LIST
68655: LIST
68656: LIST
68657: PUSH
68658: LD_INT 2
68660: PUSH
68661: LD_INT 34
68663: PUSH
68664: LD_INT 32
68666: PUSH
68667: EMPTY
68668: LIST
68669: LIST
68670: PUSH
68671: LD_INT 34
68673: PUSH
68674: LD_INT 51
68676: PUSH
68677: EMPTY
68678: LIST
68679: LIST
68680: PUSH
68681: LD_INT 34
68683: PUSH
68684: LD_INT 12
68686: PUSH
68687: EMPTY
68688: LIST
68689: LIST
68690: PUSH
68691: EMPTY
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PPUSH
68701: CALL_OW 72
68705: ST_TO_ADDR
// if not cargo then
68706: LD_VAR 0 8
68710: NOT
68711: IFFALSE 69425
// begin if mc_crates_collector [ i ] < 5 then
68713: LD_EXP 40
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: PUSH
68724: LD_INT 5
68726: LESS
68727: IFFALSE 69097
// begin if mc_ape [ i ] then
68729: LD_EXP 52
68733: PUSH
68734: LD_VAR 0 2
68738: ARRAY
68739: IFFALSE 68786
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68741: LD_ADDR_VAR 0 5
68745: PUSH
68746: LD_EXP 52
68750: PUSH
68751: LD_VAR 0 2
68755: ARRAY
68756: PPUSH
68757: LD_INT 25
68759: PUSH
68760: LD_INT 16
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 24
68769: PUSH
68770: LD_INT 750
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PPUSH
68781: CALL_OW 72
68785: ST_TO_ADDR
// if not tmp then
68786: LD_VAR 0 5
68790: NOT
68791: IFFALSE 68838
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68793: LD_ADDR_VAR 0 5
68797: PUSH
68798: LD_EXP 23
68802: PUSH
68803: LD_VAR 0 2
68807: ARRAY
68808: PPUSH
68809: LD_INT 25
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 24
68821: PUSH
68822: LD_INT 750
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: EMPTY
68830: LIST
68831: LIST
68832: PPUSH
68833: CALL_OW 72
68837: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68838: LD_EXP 52
68842: PUSH
68843: LD_VAR 0 2
68847: ARRAY
68848: IFFALSE 68891
68850: PUSH
68851: LD_EXP 23
68855: PUSH
68856: LD_VAR 0 2
68860: ARRAY
68861: PPUSH
68862: LD_INT 25
68864: PUSH
68865: LD_INT 2
68867: PUSH
68868: EMPTY
68869: LIST
68870: LIST
68871: PUSH
68872: LD_INT 24
68874: PUSH
68875: LD_INT 750
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PPUSH
68886: CALL_OW 72
68890: AND
68891: IFFALSE 68903
68893: PUSH
68894: LD_VAR 0 5
68898: PUSH
68899: LD_INT 5
68901: LESS
68902: AND
68903: IFFALSE 68985
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68905: LD_ADDR_VAR 0 3
68909: PUSH
68910: LD_EXP 23
68914: PUSH
68915: LD_VAR 0 2
68919: ARRAY
68920: PPUSH
68921: LD_INT 25
68923: PUSH
68924: LD_INT 2
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 24
68933: PUSH
68934: LD_INT 750
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PPUSH
68945: CALL_OW 72
68949: PUSH
68950: FOR_IN
68951: IFFALSE 68983
// begin tmp := tmp union j ;
68953: LD_ADDR_VAR 0 5
68957: PUSH
68958: LD_VAR 0 5
68962: PUSH
68963: LD_VAR 0 3
68967: UNION
68968: ST_TO_ADDR
// if tmp >= 5 then
68969: LD_VAR 0 5
68973: PUSH
68974: LD_INT 5
68976: GREATEREQUAL
68977: IFFALSE 68981
// break ;
68979: GO 68983
// end ;
68981: GO 68950
68983: POP
68984: POP
// end ; if not tmp then
68985: LD_VAR 0 5
68989: NOT
68990: IFFALSE 68994
// continue ;
68992: GO 68137
// for j in tmp do
68994: LD_ADDR_VAR 0 3
68998: PUSH
68999: LD_VAR 0 5
69003: PUSH
69004: FOR_IN
69005: IFFALSE 69095
// if not GetTag ( j ) then
69007: LD_VAR 0 3
69011: PPUSH
69012: CALL_OW 110
69016: NOT
69017: IFFALSE 69093
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69019: LD_ADDR_EXP 40
69023: PUSH
69024: LD_EXP 40
69028: PPUSH
69029: LD_VAR 0 2
69033: PUSH
69034: LD_EXP 40
69038: PUSH
69039: LD_VAR 0 2
69043: ARRAY
69044: PUSH
69045: LD_INT 1
69047: PLUS
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PPUSH
69053: LD_VAR 0 3
69057: PPUSH
69058: CALL 16289 0 3
69062: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69063: LD_VAR 0 3
69067: PPUSH
69068: LD_INT 107
69070: PPUSH
69071: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69075: LD_EXP 40
69079: PUSH
69080: LD_VAR 0 2
69084: ARRAY
69085: PUSH
69086: LD_INT 5
69088: GREATEREQUAL
69089: IFFALSE 69093
// break ;
69091: GO 69095
// end ;
69093: GO 69004
69095: POP
69096: POP
// end ; if mc_crates_collector [ i ] and target then
69097: LD_EXP 40
69101: PUSH
69102: LD_VAR 0 2
69106: ARRAY
69107: IFFALSE 69115
69109: PUSH
69110: LD_VAR 0 7
69114: AND
69115: IFFALSE 69423
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69117: LD_EXP 40
69121: PUSH
69122: LD_VAR 0 2
69126: ARRAY
69127: PUSH
69128: LD_VAR 0 7
69132: PUSH
69133: LD_INT 1
69135: ARRAY
69136: LESS
69137: IFFALSE 69157
// tmp := mc_crates_collector [ i ] else
69139: LD_ADDR_VAR 0 5
69143: PUSH
69144: LD_EXP 40
69148: PUSH
69149: LD_VAR 0 2
69153: ARRAY
69154: ST_TO_ADDR
69155: GO 69171
// tmp := target [ 1 ] ;
69157: LD_ADDR_VAR 0 5
69161: PUSH
69162: LD_VAR 0 7
69166: PUSH
69167: LD_INT 1
69169: ARRAY
69170: ST_TO_ADDR
// k := 0 ;
69171: LD_ADDR_VAR 0 4
69175: PUSH
69176: LD_INT 0
69178: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69179: LD_ADDR_VAR 0 3
69183: PUSH
69184: LD_EXP 40
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: PUSH
69195: FOR_IN
69196: IFFALSE 69421
// begin k := k + 1 ;
69198: LD_ADDR_VAR 0 4
69202: PUSH
69203: LD_VAR 0 4
69207: PUSH
69208: LD_INT 1
69210: PLUS
69211: ST_TO_ADDR
// if k > tmp then
69212: LD_VAR 0 4
69216: PUSH
69217: LD_VAR 0 5
69221: GREATER
69222: IFFALSE 69226
// break ;
69224: GO 69421
// if not GetClass ( j ) in [ 2 , 16 ] then
69226: LD_VAR 0 3
69230: PPUSH
69231: CALL_OW 257
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: LD_INT 16
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: IN
69246: NOT
69247: IFFALSE 69300
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69249: LD_ADDR_EXP 40
69253: PUSH
69254: LD_EXP 40
69258: PPUSH
69259: LD_VAR 0 2
69263: PPUSH
69264: LD_EXP 40
69268: PUSH
69269: LD_VAR 0 2
69273: ARRAY
69274: PUSH
69275: LD_VAR 0 3
69279: DIFF
69280: PPUSH
69281: CALL_OW 1
69285: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69286: LD_VAR 0 3
69290: PPUSH
69291: LD_INT 0
69293: PPUSH
69294: CALL_OW 109
// continue ;
69298: GO 69195
// end ; if IsInUnit ( j ) then
69300: LD_VAR 0 3
69304: PPUSH
69305: CALL_OW 310
69309: IFFALSE 69320
// ComExitBuilding ( j ) ;
69311: LD_VAR 0 3
69315: PPUSH
69316: CALL_OW 122
// wait ( 3 ) ;
69320: LD_INT 3
69322: PPUSH
69323: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69327: LD_VAR 0 3
69331: PPUSH
69332: CALL_OW 314
69336: IFFALSE 69374
69338: PUSH
69339: LD_VAR 0 6
69343: PPUSH
69344: LD_VAR 0 7
69348: PUSH
69349: LD_INT 2
69351: ARRAY
69352: PPUSH
69353: LD_VAR 0 7
69357: PUSH
69358: LD_INT 3
69360: ARRAY
69361: PPUSH
69362: LD_INT 30
69364: PPUSH
69365: CALL 17559 0 4
69369: PUSH
69370: LD_INT 4
69372: ARRAY
69373: AND
69374: IFFALSE 69392
// ComStandNearbyBuilding ( j , depot ) else
69376: LD_VAR 0 3
69380: PPUSH
69381: LD_VAR 0 9
69385: PPUSH
69386: CALL 12831 0 2
69390: GO 69419
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69392: LD_VAR 0 3
69396: PPUSH
69397: LD_VAR 0 7
69401: PUSH
69402: LD_INT 2
69404: ARRAY
69405: PPUSH
69406: LD_VAR 0 7
69410: PUSH
69411: LD_INT 3
69413: ARRAY
69414: PPUSH
69415: CALL_OW 117
// end ;
69419: GO 69195
69421: POP
69422: POP
// end ; end else
69423: GO 69965
// begin for j in cargo do
69425: LD_ADDR_VAR 0 3
69429: PUSH
69430: LD_VAR 0 8
69434: PUSH
69435: FOR_IN
69436: IFFALSE 69963
// begin if GetTag ( j ) <> 0 then
69438: LD_VAR 0 3
69442: PPUSH
69443: CALL_OW 110
69447: PUSH
69448: LD_INT 0
69450: NONEQUAL
69451: IFFALSE 69455
// continue ;
69453: GO 69435
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69455: LD_VAR 0 3
69459: PPUSH
69460: CALL_OW 256
69464: PUSH
69465: LD_INT 1000
69467: LESS
69468: IFFALSE 69493
69470: PUSH
69471: LD_VAR 0 3
69475: PPUSH
69476: LD_EXP 47
69480: PUSH
69481: LD_VAR 0 2
69485: ARRAY
69486: PPUSH
69487: CALL_OW 308
69491: NOT
69492: AND
69493: IFFALSE 69515
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69495: LD_VAR 0 3
69499: PPUSH
69500: LD_EXP 47
69504: PUSH
69505: LD_VAR 0 2
69509: ARRAY
69510: PPUSH
69511: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69515: LD_VAR 0 3
69519: PPUSH
69520: CALL_OW 256
69524: PUSH
69525: LD_INT 1000
69527: LESS
69528: IFFALSE 69552
69530: PUSH
69531: LD_VAR 0 3
69535: PPUSH
69536: LD_EXP 47
69540: PUSH
69541: LD_VAR 0 2
69545: ARRAY
69546: PPUSH
69547: CALL_OW 308
69551: AND
69552: IFFALSE 69556
// continue ;
69554: GO 69435
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69556: LD_VAR 0 3
69560: PPUSH
69561: CALL_OW 262
69565: PUSH
69566: LD_INT 2
69568: EQUAL
69569: IFFALSE 69586
69571: PUSH
69572: LD_VAR 0 3
69576: PPUSH
69577: CALL_OW 261
69581: PUSH
69582: LD_INT 15
69584: LESS
69585: AND
69586: IFFALSE 69590
// continue ;
69588: GO 69435
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69590: LD_VAR 0 3
69594: PPUSH
69595: CALL_OW 262
69599: PUSH
69600: LD_INT 1
69602: EQUAL
69603: IFFALSE 69620
69605: PUSH
69606: LD_VAR 0 3
69610: PPUSH
69611: CALL_OW 261
69615: PUSH
69616: LD_INT 10
69618: LESS
69619: AND
69620: IFFALSE 69900
// begin if not depot then
69622: LD_VAR 0 9
69626: NOT
69627: IFFALSE 69631
// continue ;
69629: GO 69435
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69631: LD_VAR 0 3
69635: PPUSH
69636: LD_VAR 0 9
69640: PPUSH
69641: LD_VAR 0 3
69645: PPUSH
69646: CALL_OW 74
69650: PPUSH
69651: CALL_OW 296
69655: PUSH
69656: LD_INT 6
69658: LESS
69659: IFFALSE 69675
// SetFuel ( j , 100 ) else
69661: LD_VAR 0 3
69665: PPUSH
69666: LD_INT 100
69668: PPUSH
69669: CALL_OW 240
69673: GO 69900
// if GetFuel ( j ) = 0 then
69675: LD_VAR 0 3
69679: PPUSH
69680: CALL_OW 261
69684: PUSH
69685: LD_INT 0
69687: EQUAL
69688: IFFALSE 69900
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69690: LD_ADDR_EXP 42
69694: PUSH
69695: LD_EXP 42
69699: PPUSH
69700: LD_VAR 0 2
69704: PPUSH
69705: LD_EXP 42
69709: PUSH
69710: LD_VAR 0 2
69714: ARRAY
69715: PUSH
69716: LD_VAR 0 3
69720: DIFF
69721: PPUSH
69722: CALL_OW 1
69726: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69727: LD_VAR 0 3
69731: PPUSH
69732: CALL_OW 263
69736: PUSH
69737: LD_INT 1
69739: EQUAL
69740: IFFALSE 69756
// ComExitVehicle ( IsInUnit ( j ) ) ;
69742: LD_VAR 0 3
69746: PPUSH
69747: CALL_OW 310
69751: PPUSH
69752: CALL_OW 121
// if GetControl ( j ) = control_remote then
69756: LD_VAR 0 3
69760: PPUSH
69761: CALL_OW 263
69765: PUSH
69766: LD_INT 2
69768: EQUAL
69769: IFFALSE 69780
// ComUnlink ( j ) ;
69771: LD_VAR 0 3
69775: PPUSH
69776: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69780: LD_ADDR_VAR 0 10
69784: PUSH
69785: LD_VAR 0 2
69789: PPUSH
69790: LD_INT 3
69792: PPUSH
69793: CALL 79694 0 2
69797: ST_TO_ADDR
// if fac then
69798: LD_VAR 0 10
69802: IFFALSE 69898
// begin for k in fac do
69804: LD_ADDR_VAR 0 4
69808: PUSH
69809: LD_VAR 0 10
69813: PUSH
69814: FOR_IN
69815: IFFALSE 69896
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69817: LD_ADDR_VAR 0 11
69821: PUSH
69822: LD_VAR 0 10
69826: PPUSH
69827: LD_VAR 0 3
69831: PPUSH
69832: CALL_OW 265
69836: PPUSH
69837: LD_VAR 0 3
69841: PPUSH
69842: CALL_OW 262
69846: PPUSH
69847: LD_VAR 0 3
69851: PPUSH
69852: CALL_OW 263
69856: PPUSH
69857: LD_VAR 0 3
69861: PPUSH
69862: CALL_OW 264
69866: PPUSH
69867: CALL 13729 0 5
69871: ST_TO_ADDR
// if components then
69872: LD_VAR 0 11
69876: IFFALSE 69894
// begin MC_InsertProduceList ( i , components ) ;
69878: LD_VAR 0 2
69882: PPUSH
69883: LD_VAR 0 11
69887: PPUSH
69888: CALL 79239 0 2
// break ;
69892: GO 69896
// end ; end ;
69894: GO 69814
69896: POP
69897: POP
// end ; continue ;
69898: GO 69435
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69900: LD_VAR 0 3
69904: PPUSH
69905: LD_INT 1
69907: PPUSH
69908: CALL_OW 289
69912: PUSH
69913: LD_INT 100
69915: LESS
69916: IFFALSE 69930
69918: PUSH
69919: LD_VAR 0 3
69923: PPUSH
69924: CALL_OW 314
69928: NOT
69929: AND
69930: IFFALSE 69959
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69932: LD_VAR 0 3
69936: PPUSH
69937: LD_VAR 0 7
69941: PUSH
69942: LD_INT 2
69944: ARRAY
69945: PPUSH
69946: LD_VAR 0 7
69950: PUSH
69951: LD_INT 3
69953: ARRAY
69954: PPUSH
69955: CALL_OW 117
// break ;
69959: GO 69963
// end ;
69961: GO 69435
69963: POP
69964: POP
// end ; end ;
69965: GO 68137
69967: POP
69968: POP
// end ;
69969: LD_VAR 0 1
69973: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69974: LD_INT 0
69976: PPUSH
69977: PPUSH
69978: PPUSH
69979: PPUSH
// if not mc_bases then
69980: LD_EXP 23
69984: NOT
69985: IFFALSE 69989
// exit ;
69987: GO 70154
// for i = 1 to mc_bases do
69989: LD_ADDR_VAR 0 2
69993: PUSH
69994: DOUBLE
69995: LD_INT 1
69997: DEC
69998: ST_TO_ADDR
69999: LD_EXP 23
70003: PUSH
70004: FOR_TO
70005: IFFALSE 70152
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70007: LD_ADDR_VAR 0 4
70011: PUSH
70012: LD_EXP 42
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: PUSH
70023: LD_EXP 45
70027: PUSH
70028: LD_VAR 0 2
70032: ARRAY
70033: UNION
70034: PPUSH
70035: LD_INT 33
70037: PUSH
70038: LD_INT 2
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PPUSH
70045: CALL_OW 72
70049: ST_TO_ADDR
// if tmp then
70050: LD_VAR 0 4
70054: IFFALSE 70150
// for j in tmp do
70056: LD_ADDR_VAR 0 3
70060: PUSH
70061: LD_VAR 0 4
70065: PUSH
70066: FOR_IN
70067: IFFALSE 70148
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70069: LD_VAR 0 3
70073: PPUSH
70074: CALL_OW 312
70078: NOT
70079: IFFALSE 70096
70081: PUSH
70082: LD_VAR 0 3
70086: PPUSH
70087: CALL_OW 256
70091: PUSH
70092: LD_INT 250
70094: GREATEREQUAL
70095: AND
70096: IFFALSE 70109
// Connect ( j ) else
70098: LD_VAR 0 3
70102: PPUSH
70103: CALL 19649 0 1
70107: GO 70146
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70109: LD_VAR 0 3
70113: PPUSH
70114: CALL_OW 256
70118: PUSH
70119: LD_INT 250
70121: LESS
70122: IFFALSE 70135
70124: PUSH
70125: LD_VAR 0 3
70129: PPUSH
70130: CALL_OW 312
70134: AND
70135: IFFALSE 70146
// ComUnlink ( j ) ;
70137: LD_VAR 0 3
70141: PPUSH
70142: CALL_OW 136
70146: GO 70066
70148: POP
70149: POP
// end ;
70150: GO 70004
70152: POP
70153: POP
// end ;
70154: LD_VAR 0 1
70158: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70159: LD_INT 0
70161: PPUSH
70162: PPUSH
70163: PPUSH
70164: PPUSH
70165: PPUSH
// if not mc_bases then
70166: LD_EXP 23
70170: NOT
70171: IFFALSE 70175
// exit ;
70173: GO 70624
// for i = 1 to mc_bases do
70175: LD_ADDR_VAR 0 2
70179: PUSH
70180: DOUBLE
70181: LD_INT 1
70183: DEC
70184: ST_TO_ADDR
70185: LD_EXP 23
70189: PUSH
70190: FOR_TO
70191: IFFALSE 70622
// begin if not mc_produce [ i ] then
70193: LD_EXP 44
70197: PUSH
70198: LD_VAR 0 2
70202: ARRAY
70203: NOT
70204: IFFALSE 70208
// continue ;
70206: GO 70190
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70208: LD_ADDR_VAR 0 5
70212: PUSH
70213: LD_EXP 23
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: PPUSH
70224: LD_INT 30
70226: PUSH
70227: LD_INT 3
70229: PUSH
70230: EMPTY
70231: LIST
70232: LIST
70233: PPUSH
70234: CALL_OW 72
70238: ST_TO_ADDR
// if not fac then
70239: LD_VAR 0 5
70243: NOT
70244: IFFALSE 70248
// continue ;
70246: GO 70190
// for j in fac do
70248: LD_ADDR_VAR 0 3
70252: PUSH
70253: LD_VAR 0 5
70257: PUSH
70258: FOR_IN
70259: IFFALSE 70618
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70261: LD_VAR 0 3
70265: PPUSH
70266: CALL_OW 461
70270: PUSH
70271: LD_INT 2
70273: NONEQUAL
70274: IFTRUE 70294
70276: PUSH
70277: LD_VAR 0 3
70281: PPUSH
70282: LD_INT 15
70284: PPUSH
70285: CALL 19268 0 2
70289: PUSH
70290: LD_INT 4
70292: ARRAY
70293: OR
70294: IFFALSE 70298
// continue ;
70296: GO 70258
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70298: LD_VAR 0 3
70302: PPUSH
70303: LD_EXP 44
70307: PUSH
70308: LD_VAR 0 2
70312: ARRAY
70313: PUSH
70314: LD_INT 1
70316: ARRAY
70317: PUSH
70318: LD_INT 1
70320: ARRAY
70321: PPUSH
70322: LD_EXP 44
70326: PUSH
70327: LD_VAR 0 2
70331: ARRAY
70332: PUSH
70333: LD_INT 1
70335: ARRAY
70336: PUSH
70337: LD_INT 2
70339: ARRAY
70340: PPUSH
70341: LD_EXP 44
70345: PUSH
70346: LD_VAR 0 2
70350: ARRAY
70351: PUSH
70352: LD_INT 1
70354: ARRAY
70355: PUSH
70356: LD_INT 3
70358: ARRAY
70359: PPUSH
70360: LD_EXP 44
70364: PUSH
70365: LD_VAR 0 2
70369: ARRAY
70370: PUSH
70371: LD_INT 1
70373: ARRAY
70374: PUSH
70375: LD_INT 4
70377: ARRAY
70378: PPUSH
70379: CALL_OW 448
70383: IFFALSE 70478
70385: PUSH
70386: LD_VAR 0 3
70390: PPUSH
70391: LD_EXP 44
70395: PUSH
70396: LD_VAR 0 2
70400: ARRAY
70401: PUSH
70402: LD_INT 1
70404: ARRAY
70405: PUSH
70406: LD_INT 1
70408: ARRAY
70409: PUSH
70410: LD_EXP 44
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PUSH
70421: LD_INT 1
70423: ARRAY
70424: PUSH
70425: LD_INT 2
70427: ARRAY
70428: PUSH
70429: LD_EXP 44
70433: PUSH
70434: LD_VAR 0 2
70438: ARRAY
70439: PUSH
70440: LD_INT 1
70442: ARRAY
70443: PUSH
70444: LD_INT 3
70446: ARRAY
70447: PUSH
70448: LD_EXP 44
70452: PUSH
70453: LD_VAR 0 2
70457: ARRAY
70458: PUSH
70459: LD_INT 1
70461: ARRAY
70462: PUSH
70463: LD_INT 4
70465: ARRAY
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: PPUSH
70473: CALL 23082 0 2
70477: AND
70478: IFFALSE 70616
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70480: LD_VAR 0 3
70484: PPUSH
70485: LD_EXP 44
70489: PUSH
70490: LD_VAR 0 2
70494: ARRAY
70495: PUSH
70496: LD_INT 1
70498: ARRAY
70499: PUSH
70500: LD_INT 1
70502: ARRAY
70503: PPUSH
70504: LD_EXP 44
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PUSH
70515: LD_INT 1
70517: ARRAY
70518: PUSH
70519: LD_INT 2
70521: ARRAY
70522: PPUSH
70523: LD_EXP 44
70527: PUSH
70528: LD_VAR 0 2
70532: ARRAY
70533: PUSH
70534: LD_INT 1
70536: ARRAY
70537: PUSH
70538: LD_INT 3
70540: ARRAY
70541: PPUSH
70542: LD_EXP 44
70546: PUSH
70547: LD_VAR 0 2
70551: ARRAY
70552: PUSH
70553: LD_INT 1
70555: ARRAY
70556: PUSH
70557: LD_INT 4
70559: ARRAY
70560: PPUSH
70561: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70565: LD_ADDR_VAR 0 4
70569: PUSH
70570: LD_EXP 44
70574: PUSH
70575: LD_VAR 0 2
70579: ARRAY
70580: PPUSH
70581: LD_INT 1
70583: PPUSH
70584: CALL_OW 3
70588: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70589: LD_ADDR_EXP 44
70593: PUSH
70594: LD_EXP 44
70598: PPUSH
70599: LD_VAR 0 2
70603: PPUSH
70604: LD_VAR 0 4
70608: PPUSH
70609: CALL_OW 1
70613: ST_TO_ADDR
// break ;
70614: GO 70618
// end ; end ;
70616: GO 70258
70618: POP
70619: POP
// end ;
70620: GO 70190
70622: POP
70623: POP
// end ;
70624: LD_VAR 0 1
70628: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70629: LD_INT 0
70631: PPUSH
70632: PPUSH
70633: PPUSH
// if not mc_bases then
70634: LD_EXP 23
70638: NOT
70639: IFFALSE 70643
// exit ;
70641: GO 70732
// for i = 1 to mc_bases do
70643: LD_ADDR_VAR 0 2
70647: PUSH
70648: DOUBLE
70649: LD_INT 1
70651: DEC
70652: ST_TO_ADDR
70653: LD_EXP 23
70657: PUSH
70658: FOR_TO
70659: IFFALSE 70730
// begin if mc_attack [ i ] then
70661: LD_EXP 43
70665: PUSH
70666: LD_VAR 0 2
70670: ARRAY
70671: IFFALSE 70728
// begin tmp := mc_attack [ i ] [ 1 ] ;
70673: LD_ADDR_VAR 0 3
70677: PUSH
70678: LD_EXP 43
70682: PUSH
70683: LD_VAR 0 2
70687: ARRAY
70688: PUSH
70689: LD_INT 1
70691: ARRAY
70692: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70693: LD_ADDR_EXP 43
70697: PUSH
70698: LD_EXP 43
70702: PPUSH
70703: LD_VAR 0 2
70707: PPUSH
70708: EMPTY
70709: PPUSH
70710: CALL_OW 1
70714: ST_TO_ADDR
// Attack ( tmp ) ;
70715: LD_VAR 0 3
70719: PPUSH
70720: CALL 85763 0 1
// exit ;
70724: POP
70725: POP
70726: GO 70732
// end ; end ;
70728: GO 70658
70730: POP
70731: POP
// end ;
70732: LD_VAR 0 1
70736: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70737: LD_INT 0
70739: PPUSH
70740: PPUSH
70741: PPUSH
70742: PPUSH
70743: PPUSH
70744: PPUSH
70745: PPUSH
// if not mc_bases then
70746: LD_EXP 23
70750: NOT
70751: IFFALSE 70755
// exit ;
70753: GO 71632
// for i = 1 to mc_bases do
70755: LD_ADDR_VAR 0 2
70759: PUSH
70760: DOUBLE
70761: LD_INT 1
70763: DEC
70764: ST_TO_ADDR
70765: LD_EXP 23
70769: PUSH
70770: FOR_TO
70771: IFFALSE 71630
// begin if not mc_bases [ i ] then
70773: LD_EXP 23
70777: PUSH
70778: LD_VAR 0 2
70782: ARRAY
70783: NOT
70784: IFFALSE 70788
// continue ;
70786: GO 70770
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70788: LD_ADDR_VAR 0 7
70792: PUSH
70793: LD_EXP 23
70797: PUSH
70798: LD_VAR 0 2
70802: ARRAY
70803: PUSH
70804: LD_INT 1
70806: ARRAY
70807: PPUSH
70808: CALL 13055 0 1
70812: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70813: LD_ADDR_EXP 46
70817: PUSH
70818: LD_EXP 46
70822: PPUSH
70823: LD_VAR 0 2
70827: PPUSH
70828: LD_EXP 23
70832: PUSH
70833: LD_VAR 0 2
70837: ARRAY
70838: PUSH
70839: LD_INT 1
70841: ARRAY
70842: PPUSH
70843: CALL_OW 255
70847: PPUSH
70848: LD_EXP 48
70852: PUSH
70853: LD_VAR 0 2
70857: ARRAY
70858: PPUSH
70859: CALL 13020 0 2
70863: PPUSH
70864: CALL_OW 1
70868: ST_TO_ADDR
// if not mc_scan [ i ] then
70869: LD_EXP 46
70873: PUSH
70874: LD_VAR 0 2
70878: ARRAY
70879: NOT
70880: IFFALSE 71064
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70882: LD_ADDR_EXP 66
70886: PUSH
70887: LD_EXP 66
70891: PPUSH
70892: LD_VAR 0 2
70896: PPUSH
70897: LD_INT 0
70899: PPUSH
70900: CALL_OW 1
70904: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70905: LD_ADDR_VAR 0 4
70909: PUSH
70910: LD_EXP 23
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: PPUSH
70921: LD_INT 2
70923: PUSH
70924: LD_INT 25
70926: PUSH
70927: LD_INT 5
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 25
70936: PUSH
70937: LD_INT 8
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: LD_INT 25
70946: PUSH
70947: LD_INT 9
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: LIST
70958: LIST
70959: PPUSH
70960: CALL_OW 72
70964: ST_TO_ADDR
// if not tmp then
70965: LD_VAR 0 4
70969: NOT
70970: IFFALSE 70974
// continue ;
70972: GO 70770
// for j in tmp do
70974: LD_ADDR_VAR 0 3
70978: PUSH
70979: LD_VAR 0 4
70983: PUSH
70984: FOR_IN
70985: IFFALSE 71062
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70987: LD_VAR 0 3
70991: PPUSH
70992: CALL_OW 310
70996: PPUSH
70997: CALL_OW 266
71001: PUSH
71002: LD_INT 5
71004: EQUAL
71005: IFFALSE 71022
71007: PUSH
71008: LD_VAR 0 3
71012: PPUSH
71013: CALL_OW 257
71017: PUSH
71018: LD_INT 1
71020: EQUAL
71021: AND
71022: IFFALSE 71036
71024: PUSH
71025: LD_VAR 0 3
71029: PPUSH
71030: CALL_OW 459
71034: NOT
71035: AND
71036: IFFALSE 71044
71038: PUSH
71039: LD_VAR 0 7
71043: AND
71044: IFFALSE 71060
// ComChangeProfession ( j , class ) ;
71046: LD_VAR 0 3
71050: PPUSH
71051: LD_VAR 0 7
71055: PPUSH
71056: CALL_OW 123
71060: GO 70984
71062: POP
71063: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71064: LD_EXP 46
71068: PUSH
71069: LD_VAR 0 2
71073: ARRAY
71074: IFFALSE 71089
71076: PUSH
71077: LD_EXP 66
71081: PUSH
71082: LD_VAR 0 2
71086: ARRAY
71087: NOT
71088: AND
71089: IFFALSE 71104
71091: PUSH
71092: LD_EXP 45
71096: PUSH
71097: LD_VAR 0 2
71101: ARRAY
71102: NOT
71103: AND
71104: IFFALSE 71255
71106: PUSH
71107: LD_EXP 23
71111: PUSH
71112: LD_VAR 0 2
71116: ARRAY
71117: PPUSH
71118: LD_INT 50
71120: PUSH
71121: EMPTY
71122: LIST
71123: PUSH
71124: LD_INT 2
71126: PUSH
71127: LD_INT 30
71129: PUSH
71130: LD_INT 32
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PUSH
71137: LD_INT 30
71139: PUSH
71140: LD_INT 33
71142: PUSH
71143: EMPTY
71144: LIST
71145: LIST
71146: PUSH
71147: LD_INT 30
71149: PUSH
71150: LD_INT 4
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 30
71159: PUSH
71160: LD_INT 5
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: EMPTY
71168: LIST
71169: LIST
71170: LIST
71171: LIST
71172: LIST
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PPUSH
71178: CALL_OW 72
71182: PUSH
71183: LD_INT 4
71185: LESS
71186: IFTRUE 71254
71188: PUSH
71189: LD_EXP 23
71193: PUSH
71194: LD_VAR 0 2
71198: ARRAY
71199: PPUSH
71200: LD_INT 3
71202: PUSH
71203: LD_INT 24
71205: PUSH
71206: LD_INT 1000
71208: PUSH
71209: EMPTY
71210: LIST
71211: LIST
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: PUSH
71217: LD_INT 2
71219: PUSH
71220: LD_INT 30
71222: PUSH
71223: LD_INT 0
71225: PUSH
71226: EMPTY
71227: LIST
71228: LIST
71229: PUSH
71230: LD_INT 30
71232: PUSH
71233: LD_INT 1
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: LIST
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PPUSH
71249: CALL_OW 72
71253: OR
71254: AND
71255: IFFALSE 71508
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71257: LD_ADDR_EXP 66
71261: PUSH
71262: LD_EXP 66
71266: PPUSH
71267: LD_VAR 0 2
71271: PPUSH
71272: LD_INT 1
71274: PPUSH
71275: CALL_OW 1
71279: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71280: LD_ADDR_VAR 0 4
71284: PUSH
71285: LD_EXP 23
71289: PUSH
71290: LD_VAR 0 2
71294: ARRAY
71295: PPUSH
71296: LD_INT 2
71298: PUSH
71299: LD_INT 25
71301: PUSH
71302: LD_INT 1
71304: PUSH
71305: EMPTY
71306: LIST
71307: LIST
71308: PUSH
71309: LD_INT 25
71311: PUSH
71312: LD_INT 5
71314: PUSH
71315: EMPTY
71316: LIST
71317: LIST
71318: PUSH
71319: LD_INT 25
71321: PUSH
71322: LD_INT 8
71324: PUSH
71325: EMPTY
71326: LIST
71327: LIST
71328: PUSH
71329: LD_INT 25
71331: PUSH
71332: LD_INT 9
71334: PUSH
71335: EMPTY
71336: LIST
71337: LIST
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: LIST
71343: LIST
71344: LIST
71345: PPUSH
71346: CALL_OW 72
71350: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71351: LD_ADDR_VAR 0 4
71355: PUSH
71356: LD_VAR 0 4
71360: PUSH
71361: LD_VAR 0 4
71365: PPUSH
71366: LD_INT 18
71368: PPUSH
71369: CALL 46892 0 2
71373: DIFF
71374: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71375: LD_VAR 0 4
71379: NOT
71380: IFFALSE 71428
71382: PUSH
71383: LD_EXP 23
71387: PUSH
71388: LD_VAR 0 2
71392: ARRAY
71393: PPUSH
71394: LD_INT 2
71396: PUSH
71397: LD_INT 30
71399: PUSH
71400: LD_INT 4
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PUSH
71407: LD_INT 30
71409: PUSH
71410: LD_INT 5
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: PUSH
71417: EMPTY
71418: LIST
71419: LIST
71420: LIST
71421: PPUSH
71422: CALL_OW 72
71426: NOT
71427: AND
71428: IFFALSE 71490
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71430: LD_ADDR_VAR 0 4
71434: PUSH
71435: LD_EXP 23
71439: PUSH
71440: LD_VAR 0 2
71444: ARRAY
71445: PPUSH
71446: LD_INT 2
71448: PUSH
71449: LD_INT 25
71451: PUSH
71452: LD_INT 2
71454: PUSH
71455: EMPTY
71456: LIST
71457: LIST
71458: PUSH
71459: LD_INT 25
71461: PUSH
71462: LD_INT 3
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 25
71471: PUSH
71472: LD_INT 4
71474: PUSH
71475: EMPTY
71476: LIST
71477: LIST
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: LIST
71483: LIST
71484: PPUSH
71485: CALL_OW 72
71489: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71490: LD_VAR 0 2
71494: PPUSH
71495: LD_VAR 0 4
71499: PPUSH
71500: CALL 90532 0 2
// exit ;
71504: POP
71505: POP
71506: GO 71632
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71508: LD_EXP 46
71512: PUSH
71513: LD_VAR 0 2
71517: ARRAY
71518: IFFALSE 71533
71520: PUSH
71521: LD_EXP 66
71525: PUSH
71526: LD_VAR 0 2
71530: ARRAY
71531: NOT
71532: AND
71533: IFFALSE 71547
71535: PUSH
71536: LD_EXP 45
71540: PUSH
71541: LD_VAR 0 2
71545: ARRAY
71546: AND
71547: IFFALSE 71628
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71549: LD_ADDR_EXP 66
71553: PUSH
71554: LD_EXP 66
71558: PPUSH
71559: LD_VAR 0 2
71563: PPUSH
71564: LD_INT 1
71566: PPUSH
71567: CALL_OW 1
71571: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71572: LD_ADDR_VAR 0 4
71576: PUSH
71577: LD_EXP 45
71581: PUSH
71582: LD_VAR 0 2
71586: ARRAY
71587: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71588: LD_ADDR_EXP 45
71592: PUSH
71593: LD_EXP 45
71597: PPUSH
71598: LD_VAR 0 2
71602: PPUSH
71603: EMPTY
71604: PPUSH
71605: CALL_OW 1
71609: ST_TO_ADDR
// Defend ( i , tmp ) ;
71610: LD_VAR 0 2
71614: PPUSH
71615: LD_VAR 0 4
71619: PPUSH
71620: CALL 91136 0 2
// exit ;
71624: POP
71625: POP
71626: GO 71632
// end ; end ;
71628: GO 70770
71630: POP
71631: POP
// end ;
71632: LD_VAR 0 1
71636: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71637: LD_INT 0
71639: PPUSH
71640: PPUSH
71641: PPUSH
71642: PPUSH
71643: PPUSH
71644: PPUSH
71645: PPUSH
71646: PPUSH
71647: PPUSH
71648: PPUSH
71649: PPUSH
// if not mc_bases then
71650: LD_EXP 23
71654: NOT
71655: IFFALSE 71659
// exit ;
71657: GO 72772
// for i = 1 to mc_bases do
71659: LD_ADDR_VAR 0 2
71663: PUSH
71664: DOUBLE
71665: LD_INT 1
71667: DEC
71668: ST_TO_ADDR
71669: LD_EXP 23
71673: PUSH
71674: FOR_TO
71675: IFFALSE 72770
// begin tmp := mc_lab [ i ] ;
71677: LD_ADDR_VAR 0 6
71681: PUSH
71682: LD_EXP 56
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: ST_TO_ADDR
// if not tmp then
71693: LD_VAR 0 6
71697: NOT
71698: IFFALSE 71702
// continue ;
71700: GO 71674
// idle_lab := 0 ;
71702: LD_ADDR_VAR 0 11
71706: PUSH
71707: LD_INT 0
71709: ST_TO_ADDR
// for j in tmp do
71710: LD_ADDR_VAR 0 3
71714: PUSH
71715: LD_VAR 0 6
71719: PUSH
71720: FOR_IN
71721: IFFALSE 72766
// begin researching := false ;
71723: LD_ADDR_VAR 0 10
71727: PUSH
71728: LD_INT 0
71730: ST_TO_ADDR
// side := GetSide ( j ) ;
71731: LD_ADDR_VAR 0 4
71735: PUSH
71736: LD_VAR 0 3
71740: PPUSH
71741: CALL_OW 255
71745: ST_TO_ADDR
// if not mc_tech [ side ] then
71746: LD_EXP 50
71750: PUSH
71751: LD_VAR 0 4
71755: ARRAY
71756: NOT
71757: IFFALSE 71761
// continue ;
71759: GO 71720
// if BuildingStatus ( j ) = bs_idle then
71761: LD_VAR 0 3
71765: PPUSH
71766: CALL_OW 461
71770: PUSH
71771: LD_INT 2
71773: EQUAL
71774: IFFALSE 71966
// begin if idle_lab and UnitsInside ( j ) < 6 then
71776: LD_VAR 0 11
71780: IFFALSE 71797
71782: PUSH
71783: LD_VAR 0 3
71787: PPUSH
71788: CALL_OW 313
71792: PUSH
71793: LD_INT 6
71795: LESS
71796: AND
71797: IFFALSE 71868
// begin tmp2 := UnitsInside ( idle_lab ) ;
71799: LD_ADDR_VAR 0 9
71803: PUSH
71804: LD_VAR 0 11
71808: PPUSH
71809: CALL_OW 313
71813: ST_TO_ADDR
// if tmp2 then
71814: LD_VAR 0 9
71818: IFFALSE 71860
// for x in tmp2 do
71820: LD_ADDR_VAR 0 7
71824: PUSH
71825: LD_VAR 0 9
71829: PUSH
71830: FOR_IN
71831: IFFALSE 71858
// begin ComExitBuilding ( x ) ;
71833: LD_VAR 0 7
71837: PPUSH
71838: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71842: LD_VAR 0 7
71846: PPUSH
71847: LD_VAR 0 3
71851: PPUSH
71852: CALL_OW 180
// end ;
71856: GO 71830
71858: POP
71859: POP
// idle_lab := 0 ;
71860: LD_ADDR_VAR 0 11
71864: PUSH
71865: LD_INT 0
71867: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71868: LD_ADDR_VAR 0 5
71872: PUSH
71873: LD_EXP 50
71877: PUSH
71878: LD_VAR 0 4
71882: ARRAY
71883: PUSH
71884: FOR_IN
71885: IFFALSE 71947
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71887: LD_VAR 0 3
71891: PPUSH
71892: LD_VAR 0 5
71896: PPUSH
71897: CALL_OW 430
71901: IFFALSE 71919
71903: PUSH
71904: LD_VAR 0 4
71908: PPUSH
71909: LD_VAR 0 5
71913: PPUSH
71914: CALL 12115 0 2
71918: AND
71919: IFFALSE 71945
// begin researching := true ;
71921: LD_ADDR_VAR 0 10
71925: PUSH
71926: LD_INT 1
71928: ST_TO_ADDR
// ComResearch ( j , t ) ;
71929: LD_VAR 0 3
71933: PPUSH
71934: LD_VAR 0 5
71938: PPUSH
71939: CALL_OW 124
// break ;
71943: GO 71947
// end ;
71945: GO 71884
71947: POP
71948: POP
// if not researching then
71949: LD_VAR 0 10
71953: NOT
71954: IFFALSE 71966
// idle_lab := j ;
71956: LD_ADDR_VAR 0 11
71960: PUSH
71961: LD_VAR 0 3
71965: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71966: LD_VAR 0 3
71970: PPUSH
71971: CALL_OW 461
71975: PUSH
71976: LD_INT 10
71978: EQUAL
71979: IFFALSE 72585
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71981: LD_EXP 52
71985: PUSH
71986: LD_VAR 0 2
71990: ARRAY
71991: NOT
71992: IFFALSE 72007
71994: PUSH
71995: LD_EXP 53
71999: PUSH
72000: LD_VAR 0 2
72004: ARRAY
72005: NOT
72006: AND
72007: IFFALSE 72025
72009: PUSH
72010: LD_EXP 50
72014: PUSH
72015: LD_VAR 0 4
72019: ARRAY
72020: PUSH
72021: LD_INT 1
72023: GREATER
72024: AND
72025: IFFALSE 72156
// begin ComCancel ( j ) ;
72027: LD_VAR 0 3
72031: PPUSH
72032: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72036: LD_ADDR_EXP 50
72040: PUSH
72041: LD_EXP 50
72045: PPUSH
72046: LD_VAR 0 4
72050: PPUSH
72051: LD_EXP 50
72055: PUSH
72056: LD_VAR 0 4
72060: ARRAY
72061: PPUSH
72062: LD_EXP 50
72066: PUSH
72067: LD_VAR 0 4
72071: ARRAY
72072: PUSH
72073: LD_INT 1
72075: MINUS
72076: PPUSH
72077: LD_EXP 50
72081: PUSH
72082: LD_VAR 0 4
72086: ARRAY
72087: PPUSH
72088: LD_INT 0
72090: PPUSH
72091: CALL 15697 0 4
72095: PPUSH
72096: CALL_OW 1
72100: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72101: LD_ADDR_EXP 50
72105: PUSH
72106: LD_EXP 50
72110: PPUSH
72111: LD_VAR 0 4
72115: PPUSH
72116: LD_EXP 50
72120: PUSH
72121: LD_VAR 0 4
72125: ARRAY
72126: PPUSH
72127: LD_EXP 50
72131: PUSH
72132: LD_VAR 0 4
72136: ARRAY
72137: PPUSH
72138: LD_INT 1
72140: PPUSH
72141: LD_INT 0
72143: PPUSH
72144: CALL 15697 0 4
72148: PPUSH
72149: CALL_OW 1
72153: ST_TO_ADDR
// continue ;
72154: GO 71720
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72156: LD_EXP 52
72160: PUSH
72161: LD_VAR 0 2
72165: ARRAY
72166: IFFALSE 72181
72168: PUSH
72169: LD_EXP 53
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: NOT
72180: AND
72181: IFFALSE 72308
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72183: LD_ADDR_EXP 53
72187: PUSH
72188: LD_EXP 53
72192: PPUSH
72193: LD_VAR 0 2
72197: PUSH
72198: LD_EXP 53
72202: PUSH
72203: LD_VAR 0 2
72207: ARRAY
72208: PUSH
72209: LD_INT 1
72211: PLUS
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PPUSH
72217: LD_EXP 52
72221: PUSH
72222: LD_VAR 0 2
72226: ARRAY
72227: PUSH
72228: LD_INT 1
72230: ARRAY
72231: PPUSH
72232: CALL 16289 0 3
72236: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72237: LD_EXP 52
72241: PUSH
72242: LD_VAR 0 2
72246: ARRAY
72247: PUSH
72248: LD_INT 1
72250: ARRAY
72251: PPUSH
72252: LD_INT 112
72254: PPUSH
72255: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72259: LD_ADDR_VAR 0 9
72263: PUSH
72264: LD_EXP 52
72268: PUSH
72269: LD_VAR 0 2
72273: ARRAY
72274: PPUSH
72275: LD_INT 1
72277: PPUSH
72278: CALL_OW 3
72282: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72283: LD_ADDR_EXP 52
72287: PUSH
72288: LD_EXP 52
72292: PPUSH
72293: LD_VAR 0 2
72297: PPUSH
72298: LD_VAR 0 9
72302: PPUSH
72303: CALL_OW 1
72307: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72308: LD_EXP 52
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: IFFALSE 72332
72320: PUSH
72321: LD_EXP 53
72325: PUSH
72326: LD_VAR 0 2
72330: ARRAY
72331: AND
72332: IFFALSE 72356
72334: PUSH
72335: LD_EXP 53
72339: PUSH
72340: LD_VAR 0 2
72344: ARRAY
72345: PUSH
72346: LD_INT 1
72348: ARRAY
72349: PPUSH
72350: CALL_OW 310
72354: NOT
72355: AND
72356: IFFALSE 72373
72358: PUSH
72359: LD_VAR 0 3
72363: PPUSH
72364: CALL_OW 313
72368: PUSH
72369: LD_INT 6
72371: EQUAL
72372: AND
72373: IFFALSE 72429
// begin tmp2 := UnitsInside ( j ) ;
72375: LD_ADDR_VAR 0 9
72379: PUSH
72380: LD_VAR 0 3
72384: PPUSH
72385: CALL_OW 313
72389: ST_TO_ADDR
// if tmp2 = 6 then
72390: LD_VAR 0 9
72394: PUSH
72395: LD_INT 6
72397: EQUAL
72398: IFFALSE 72429
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72400: LD_VAR 0 9
72404: PUSH
72405: LD_INT 1
72407: ARRAY
72408: PPUSH
72409: LD_INT 112
72411: PPUSH
72412: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72416: LD_VAR 0 9
72420: PUSH
72421: LD_INT 1
72423: ARRAY
72424: PPUSH
72425: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72429: LD_EXP 53
72433: PUSH
72434: LD_VAR 0 2
72438: ARRAY
72439: IFFALSE 72463
72441: PUSH
72442: LD_EXP 53
72446: PUSH
72447: LD_VAR 0 2
72451: ARRAY
72452: PUSH
72453: LD_INT 1
72455: ARRAY
72456: PPUSH
72457: CALL_OW 314
72461: NOT
72462: AND
72463: IFFALSE 72487
72465: PUSH
72466: LD_EXP 53
72470: PUSH
72471: LD_VAR 0 2
72475: ARRAY
72476: PUSH
72477: LD_INT 1
72479: ARRAY
72480: PPUSH
72481: CALL_OW 310
72485: NOT
72486: AND
72487: IFFALSE 72513
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72489: LD_EXP 53
72493: PUSH
72494: LD_VAR 0 2
72498: ARRAY
72499: PUSH
72500: LD_INT 1
72502: ARRAY
72503: PPUSH
72504: LD_VAR 0 3
72508: PPUSH
72509: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72513: LD_EXP 53
72517: PUSH
72518: LD_VAR 0 2
72522: ARRAY
72523: PUSH
72524: LD_INT 1
72526: ARRAY
72527: PPUSH
72528: CALL_OW 310
72532: IFFALSE 72564
72534: PUSH
72535: LD_EXP 53
72539: PUSH
72540: LD_VAR 0 2
72544: ARRAY
72545: PUSH
72546: LD_INT 1
72548: ARRAY
72549: PPUSH
72550: CALL_OW 310
72554: PPUSH
72555: CALL_OW 461
72559: PUSH
72560: LD_INT 3
72562: NONEQUAL
72563: AND
72564: IFFALSE 72585
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72566: LD_EXP 53
72570: PUSH
72571: LD_VAR 0 2
72575: ARRAY
72576: PUSH
72577: LD_INT 1
72579: ARRAY
72580: PPUSH
72581: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72585: LD_VAR 0 3
72589: PPUSH
72590: CALL_OW 461
72594: PUSH
72595: LD_INT 6
72597: EQUAL
72598: IFFALSE 72610
72600: PUSH
72601: LD_VAR 0 6
72605: PUSH
72606: LD_INT 1
72608: GREATER
72609: AND
72610: IFFALSE 72764
// begin sci := [ ] ;
72612: LD_ADDR_VAR 0 8
72616: PUSH
72617: EMPTY
72618: ST_TO_ADDR
// for x in ( tmp diff j ) do
72619: LD_ADDR_VAR 0 7
72623: PUSH
72624: LD_VAR 0 6
72628: PUSH
72629: LD_VAR 0 3
72633: DIFF
72634: PUSH
72635: FOR_IN
72636: IFFALSE 72688
// begin if sci = 6 then
72638: LD_VAR 0 8
72642: PUSH
72643: LD_INT 6
72645: EQUAL
72646: IFFALSE 72650
// break ;
72648: GO 72688
// if BuildingStatus ( x ) = bs_idle then
72650: LD_VAR 0 7
72654: PPUSH
72655: CALL_OW 461
72659: PUSH
72660: LD_INT 2
72662: EQUAL
72663: IFFALSE 72686
// sci := sci ^ UnitsInside ( x ) ;
72665: LD_ADDR_VAR 0 8
72669: PUSH
72670: LD_VAR 0 8
72674: PUSH
72675: LD_VAR 0 7
72679: PPUSH
72680: CALL_OW 313
72684: ADD
72685: ST_TO_ADDR
// end ;
72686: GO 72635
72688: POP
72689: POP
// if not sci then
72690: LD_VAR 0 8
72694: NOT
72695: IFFALSE 72699
// continue ;
72697: GO 71720
// for x in sci do
72699: LD_ADDR_VAR 0 7
72703: PUSH
72704: LD_VAR 0 8
72708: PUSH
72709: FOR_IN
72710: IFFALSE 72762
// if IsInUnit ( x ) and not HasTask ( x ) then
72712: LD_VAR 0 7
72716: PPUSH
72717: CALL_OW 310
72721: IFFALSE 72735
72723: PUSH
72724: LD_VAR 0 7
72728: PPUSH
72729: CALL_OW 314
72733: NOT
72734: AND
72735: IFFALSE 72760
// begin ComExitBuilding ( x ) ;
72737: LD_VAR 0 7
72741: PPUSH
72742: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72746: LD_VAR 0 7
72750: PPUSH
72751: LD_VAR 0 3
72755: PPUSH
72756: CALL_OW 180
// end ;
72760: GO 72709
72762: POP
72763: POP
// end ; end ;
72764: GO 71720
72766: POP
72767: POP
// end ;
72768: GO 71674
72770: POP
72771: POP
// end ;
72772: LD_VAR 0 1
72776: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72777: LD_INT 0
72779: PPUSH
72780: PPUSH
// if not mc_bases then
72781: LD_EXP 23
72785: NOT
72786: IFFALSE 72790
// exit ;
72788: GO 72873
// for i = 1 to mc_bases do
72790: LD_ADDR_VAR 0 2
72794: PUSH
72795: DOUBLE
72796: LD_INT 1
72798: DEC
72799: ST_TO_ADDR
72800: LD_EXP 23
72804: PUSH
72805: FOR_TO
72806: IFFALSE 72871
// if mc_mines [ i ] and mc_miners [ i ] then
72808: LD_EXP 36
72812: PUSH
72813: LD_VAR 0 2
72817: ARRAY
72818: IFFALSE 72832
72820: PUSH
72821: LD_EXP 37
72825: PUSH
72826: LD_VAR 0 2
72830: ARRAY
72831: AND
72832: IFFALSE 72869
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72834: LD_EXP 37
72838: PUSH
72839: LD_VAR 0 2
72843: ARRAY
72844: PUSH
72845: LD_INT 1
72847: ARRAY
72848: PPUSH
72849: CALL_OW 255
72853: PPUSH
72854: LD_EXP 36
72858: PUSH
72859: LD_VAR 0 2
72863: ARRAY
72864: PPUSH
72865: CALL 13208 0 2
72869: GO 72805
72871: POP
72872: POP
// end ;
72873: LD_VAR 0 1
72877: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72878: LD_INT 0
72880: PPUSH
72881: PPUSH
72882: PPUSH
72883: PPUSH
72884: PPUSH
72885: PPUSH
72886: PPUSH
72887: PPUSH
// if not mc_bases or not mc_parking then
72888: LD_EXP 23
72892: NOT
72893: IFTRUE 72902
72895: PUSH
72896: LD_EXP 47
72900: NOT
72901: OR
72902: IFFALSE 72906
// exit ;
72904: GO 73650
// for i = 1 to mc_bases do
72906: LD_ADDR_VAR 0 2
72910: PUSH
72911: DOUBLE
72912: LD_INT 1
72914: DEC
72915: ST_TO_ADDR
72916: LD_EXP 23
72920: PUSH
72921: FOR_TO
72922: IFFALSE 73648
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72924: LD_EXP 23
72928: PUSH
72929: LD_VAR 0 2
72933: ARRAY
72934: NOT
72935: IFTRUE 72950
72937: PUSH
72938: LD_EXP 47
72942: PUSH
72943: LD_VAR 0 2
72947: ARRAY
72948: NOT
72949: OR
72950: IFFALSE 72954
// continue ;
72952: GO 72921
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72954: LD_ADDR_VAR 0 5
72958: PUSH
72959: LD_EXP 23
72963: PUSH
72964: LD_VAR 0 2
72968: ARRAY
72969: PUSH
72970: LD_INT 1
72972: ARRAY
72973: PPUSH
72974: CALL_OW 255
72978: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72979: LD_ADDR_VAR 0 6
72983: PUSH
72984: LD_EXP 23
72988: PUSH
72989: LD_VAR 0 2
72993: ARRAY
72994: PPUSH
72995: LD_INT 30
72997: PUSH
72998: LD_INT 3
73000: PUSH
73001: EMPTY
73002: LIST
73003: LIST
73004: PPUSH
73005: CALL_OW 72
73009: ST_TO_ADDR
// if not fac then
73010: LD_VAR 0 6
73014: NOT
73015: IFFALSE 73066
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73017: LD_ADDR_VAR 0 6
73021: PUSH
73022: LD_EXP 23
73026: PUSH
73027: LD_VAR 0 2
73031: ARRAY
73032: PPUSH
73033: LD_INT 2
73035: PUSH
73036: LD_INT 30
73038: PUSH
73039: LD_INT 0
73041: PUSH
73042: EMPTY
73043: LIST
73044: LIST
73045: PUSH
73046: LD_INT 30
73048: PUSH
73049: LD_INT 1
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: LIST
73060: PPUSH
73061: CALL_OW 72
73065: ST_TO_ADDR
// if not fac then
73066: LD_VAR 0 6
73070: NOT
73071: IFFALSE 73075
// continue ;
73073: GO 72921
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73075: LD_ADDR_VAR 0 7
73079: PUSH
73080: LD_EXP 47
73084: PUSH
73085: LD_VAR 0 2
73089: ARRAY
73090: PPUSH
73091: LD_INT 22
73093: PUSH
73094: LD_VAR 0 5
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: PUSH
73103: LD_INT 21
73105: PUSH
73106: LD_INT 2
73108: PUSH
73109: EMPTY
73110: LIST
73111: LIST
73112: PUSH
73113: LD_INT 3
73115: PUSH
73116: LD_INT 60
73118: PUSH
73119: EMPTY
73120: LIST
73121: PUSH
73122: EMPTY
73123: LIST
73124: LIST
73125: PUSH
73126: LD_INT 3
73128: PUSH
73129: LD_INT 24
73131: PUSH
73132: LD_INT 1000
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: PUSH
73143: EMPTY
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: PPUSH
73149: CALL_OW 70
73153: ST_TO_ADDR
// for j in fac do
73154: LD_ADDR_VAR 0 3
73158: PUSH
73159: LD_VAR 0 6
73163: PUSH
73164: FOR_IN
73165: IFFALSE 73260
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73167: LD_ADDR_VAR 0 7
73171: PUSH
73172: LD_VAR 0 7
73176: PUSH
73177: LD_INT 22
73179: PUSH
73180: LD_VAR 0 5
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 91
73191: PUSH
73192: LD_VAR 0 3
73196: PUSH
73197: LD_INT 15
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 21
73207: PUSH
73208: LD_INT 2
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 3
73217: PUSH
73218: LD_INT 60
73220: PUSH
73221: EMPTY
73222: LIST
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 3
73230: PUSH
73231: LD_INT 24
73233: PUSH
73234: LD_INT 1000
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: LIST
73249: LIST
73250: LIST
73251: PPUSH
73252: CALL_OW 69
73256: UNION
73257: ST_TO_ADDR
73258: GO 73164
73260: POP
73261: POP
// if not vehs then
73262: LD_VAR 0 7
73266: NOT
73267: IFFALSE 73293
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73269: LD_ADDR_EXP 35
73273: PUSH
73274: LD_EXP 35
73278: PPUSH
73279: LD_VAR 0 2
73283: PPUSH
73284: EMPTY
73285: PPUSH
73286: CALL_OW 1
73290: ST_TO_ADDR
// continue ;
73291: GO 72921
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73293: LD_ADDR_VAR 0 8
73297: PUSH
73298: LD_EXP 23
73302: PUSH
73303: LD_VAR 0 2
73307: ARRAY
73308: PPUSH
73309: LD_INT 30
73311: PUSH
73312: LD_INT 3
73314: PUSH
73315: EMPTY
73316: LIST
73317: LIST
73318: PPUSH
73319: CALL_OW 72
73323: ST_TO_ADDR
// if tmp then
73324: LD_VAR 0 8
73328: IFFALSE 73431
// begin for j in tmp do
73330: LD_ADDR_VAR 0 3
73334: PUSH
73335: LD_VAR 0 8
73339: PUSH
73340: FOR_IN
73341: IFFALSE 73429
// for k in UnitsInside ( j ) do
73343: LD_ADDR_VAR 0 4
73347: PUSH
73348: LD_VAR 0 3
73352: PPUSH
73353: CALL_OW 313
73357: PUSH
73358: FOR_IN
73359: IFFALSE 73425
// if k then
73361: LD_VAR 0 4
73365: IFFALSE 73423
// if not k in mc_repair_vehicle [ i ] then
73367: LD_VAR 0 4
73371: PUSH
73372: LD_EXP 35
73376: PUSH
73377: LD_VAR 0 2
73381: ARRAY
73382: IN
73383: NOT
73384: IFFALSE 73423
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73386: LD_ADDR_EXP 35
73390: PUSH
73391: LD_EXP 35
73395: PPUSH
73396: LD_VAR 0 2
73400: PPUSH
73401: LD_EXP 35
73405: PUSH
73406: LD_VAR 0 2
73410: ARRAY
73411: PUSH
73412: LD_VAR 0 4
73416: UNION
73417: PPUSH
73418: CALL_OW 1
73422: ST_TO_ADDR
73423: GO 73358
73425: POP
73426: POP
73427: GO 73340
73429: POP
73430: POP
// end ; if not mc_repair_vehicle [ i ] then
73431: LD_EXP 35
73435: PUSH
73436: LD_VAR 0 2
73440: ARRAY
73441: NOT
73442: IFFALSE 73446
// continue ;
73444: GO 72921
// for j in mc_repair_vehicle [ i ] do
73446: LD_ADDR_VAR 0 3
73450: PUSH
73451: LD_EXP 35
73455: PUSH
73456: LD_VAR 0 2
73460: ARRAY
73461: PUSH
73462: FOR_IN
73463: IFFALSE 73644
// begin if GetClass ( j ) <> 3 then
73465: LD_VAR 0 3
73469: PPUSH
73470: CALL_OW 257
73474: PUSH
73475: LD_INT 3
73477: NONEQUAL
73478: IFFALSE 73519
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73480: LD_ADDR_EXP 35
73484: PUSH
73485: LD_EXP 35
73489: PPUSH
73490: LD_VAR 0 2
73494: PPUSH
73495: LD_EXP 35
73499: PUSH
73500: LD_VAR 0 2
73504: ARRAY
73505: PUSH
73506: LD_VAR 0 3
73510: DIFF
73511: PPUSH
73512: CALL_OW 1
73516: ST_TO_ADDR
// continue ;
73517: GO 73462
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73519: LD_VAR 0 3
73523: PPUSH
73524: CALL_OW 311
73528: NOT
73529: IFFALSE 73554
73531: PUSH
73532: LD_VAR 0 3
73536: PUSH
73537: LD_EXP 26
73541: PUSH
73542: LD_VAR 0 2
73546: ARRAY
73547: PUSH
73548: LD_INT 1
73550: ARRAY
73551: IN
73552: NOT
73553: AND
73554: IFFALSE 73579
73556: PUSH
73557: LD_VAR 0 3
73561: PUSH
73562: LD_EXP 26
73566: PUSH
73567: LD_VAR 0 2
73571: ARRAY
73572: PUSH
73573: LD_INT 2
73575: ARRAY
73576: IN
73577: NOT
73578: AND
73579: IFFALSE 73642
// begin if IsInUnit ( j ) then
73581: LD_VAR 0 3
73585: PPUSH
73586: CALL_OW 310
73590: IFFALSE 73603
// ComExitBuilding ( j ) else
73592: LD_VAR 0 3
73596: PPUSH
73597: CALL_OW 122
73601: GO 73642
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73603: LD_VAR 0 3
73607: PPUSH
73608: LD_VAR 0 7
73612: PUSH
73613: LD_INT 1
73615: ARRAY
73616: PPUSH
73617: CALL 51430 0 2
73621: NOT
73622: IFFALSE 73642
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73624: LD_VAR 0 3
73628: PPUSH
73629: LD_VAR 0 7
73633: PUSH
73634: LD_INT 1
73636: ARRAY
73637: PPUSH
73638: CALL_OW 129
// end ; end ;
73642: GO 73462
73644: POP
73645: POP
// end ;
73646: GO 72921
73648: POP
73649: POP
// end ;
73650: LD_VAR 0 1
73654: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73655: LD_INT 0
73657: PPUSH
73658: PPUSH
73659: PPUSH
73660: PPUSH
73661: PPUSH
73662: PPUSH
73663: PPUSH
73664: PPUSH
73665: PPUSH
73666: PPUSH
73667: PPUSH
// if not mc_bases then
73668: LD_EXP 23
73672: NOT
73673: IFFALSE 73677
// exit ;
73675: GO 74495
// for i = 1 to mc_bases do
73677: LD_ADDR_VAR 0 2
73681: PUSH
73682: DOUBLE
73683: LD_INT 1
73685: DEC
73686: ST_TO_ADDR
73687: LD_EXP 23
73691: PUSH
73692: FOR_TO
73693: IFFALSE 74493
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73695: LD_EXP 51
73699: PUSH
73700: LD_VAR 0 2
73704: ARRAY
73705: NOT
73706: IFTRUE 73724
73708: PUSH
73709: LD_EXP 26
73713: PUSH
73714: LD_VAR 0 2
73718: ARRAY
73719: PUSH
73720: LD_INT 1
73722: ARRAY
73723: OR
73724: IFTRUE 73742
73726: PUSH
73727: LD_EXP 26
73731: PUSH
73732: LD_VAR 0 2
73736: ARRAY
73737: PUSH
73738: LD_INT 2
73740: ARRAY
73741: OR
73742: IFTRUE 73765
73744: PUSH
73745: LD_EXP 49
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: PPUSH
73756: LD_INT 1
73758: PPUSH
73759: CALL_OW 325
73763: NOT
73764: OR
73765: IFTRUE 73779
73767: PUSH
73768: LD_EXP 46
73772: PUSH
73773: LD_VAR 0 2
73777: ARRAY
73778: OR
73779: IFFALSE 73783
// continue ;
73781: GO 73692
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73783: LD_ADDR_VAR 0 8
73787: PUSH
73788: LD_EXP 23
73792: PUSH
73793: LD_VAR 0 2
73797: ARRAY
73798: PPUSH
73799: LD_INT 25
73801: PUSH
73802: LD_INT 4
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PUSH
73809: LD_INT 50
73811: PUSH
73812: EMPTY
73813: LIST
73814: PUSH
73815: LD_INT 3
73817: PUSH
73818: LD_INT 60
73820: PUSH
73821: EMPTY
73822: LIST
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: PUSH
73828: EMPTY
73829: LIST
73830: LIST
73831: LIST
73832: PPUSH
73833: CALL_OW 72
73837: PUSH
73838: LD_EXP 27
73842: PUSH
73843: LD_VAR 0 2
73847: ARRAY
73848: DIFF
73849: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73850: LD_ADDR_VAR 0 9
73854: PUSH
73855: LD_EXP 23
73859: PUSH
73860: LD_VAR 0 2
73864: ARRAY
73865: PPUSH
73866: LD_INT 2
73868: PUSH
73869: LD_INT 30
73871: PUSH
73872: LD_INT 0
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 30
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: LIST
73893: PPUSH
73894: CALL_OW 72
73898: ST_TO_ADDR
// if not tmp or not dep then
73899: LD_VAR 0 8
73903: NOT
73904: IFTRUE 73913
73906: PUSH
73907: LD_VAR 0 9
73911: NOT
73912: OR
73913: IFFALSE 73917
// continue ;
73915: GO 73692
// side := GetSide ( tmp [ 1 ] ) ;
73917: LD_ADDR_VAR 0 11
73921: PUSH
73922: LD_VAR 0 8
73926: PUSH
73927: LD_INT 1
73929: ARRAY
73930: PPUSH
73931: CALL_OW 255
73935: ST_TO_ADDR
// dep := dep [ 1 ] ;
73936: LD_ADDR_VAR 0 9
73940: PUSH
73941: LD_VAR 0 9
73945: PUSH
73946: LD_INT 1
73948: ARRAY
73949: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73950: LD_ADDR_VAR 0 7
73954: PUSH
73955: LD_EXP 51
73959: PUSH
73960: LD_VAR 0 2
73964: ARRAY
73965: PPUSH
73966: LD_INT 22
73968: PUSH
73969: LD_INT 0
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 25
73978: PUSH
73979: LD_INT 12
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PPUSH
73990: CALL_OW 70
73994: PUSH
73995: LD_INT 22
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 25
74007: PUSH
74008: LD_INT 12
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 91
74017: PUSH
74018: LD_VAR 0 9
74022: PUSH
74023: LD_INT 20
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: LIST
74030: PUSH
74031: EMPTY
74032: LIST
74033: LIST
74034: LIST
74035: PPUSH
74036: CALL_OW 69
74040: UNION
74041: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74042: LD_ADDR_VAR 0 10
74046: PUSH
74047: LD_EXP 51
74051: PUSH
74052: LD_VAR 0 2
74056: ARRAY
74057: PPUSH
74058: LD_INT 81
74060: PUSH
74061: LD_VAR 0 11
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PPUSH
74070: CALL_OW 70
74074: ST_TO_ADDR
// if not apes or danger_at_area then
74075: LD_VAR 0 7
74079: NOT
74080: IFTRUE 74088
74082: PUSH
74083: LD_VAR 0 10
74087: OR
74088: IFFALSE 74138
// begin if mc_taming [ i ] then
74090: LD_EXP 54
74094: PUSH
74095: LD_VAR 0 2
74099: ARRAY
74100: IFFALSE 74136
// begin MC_Reset ( i , 121 ) ;
74102: LD_VAR 0 2
74106: PPUSH
74107: LD_INT 121
74109: PPUSH
74110: CALL 58870 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74114: LD_ADDR_EXP 54
74118: PUSH
74119: LD_EXP 54
74123: PPUSH
74124: LD_VAR 0 2
74128: PPUSH
74129: EMPTY
74130: PPUSH
74131: CALL_OW 1
74135: ST_TO_ADDR
// end ; continue ;
74136: GO 73692
// end ; for j in tmp do
74138: LD_ADDR_VAR 0 3
74142: PUSH
74143: LD_VAR 0 8
74147: PUSH
74148: FOR_IN
74149: IFFALSE 74489
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74151: LD_VAR 0 3
74155: PUSH
74156: LD_EXP 54
74160: PUSH
74161: LD_VAR 0 2
74165: ARRAY
74166: IN
74167: NOT
74168: IFFALSE 74186
74170: PUSH
74171: LD_EXP 54
74175: PUSH
74176: LD_VAR 0 2
74180: ARRAY
74181: PUSH
74182: LD_INT 3
74184: LESS
74185: AND
74186: IFFALSE 74244
// begin SetTag ( j , 121 ) ;
74188: LD_VAR 0 3
74192: PPUSH
74193: LD_INT 121
74195: PPUSH
74196: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74200: LD_ADDR_EXP 54
74204: PUSH
74205: LD_EXP 54
74209: PPUSH
74210: LD_VAR 0 2
74214: PUSH
74215: LD_EXP 54
74219: PUSH
74220: LD_VAR 0 2
74224: ARRAY
74225: PUSH
74226: LD_INT 1
74228: PLUS
74229: PUSH
74230: EMPTY
74231: LIST
74232: LIST
74233: PPUSH
74234: LD_VAR 0 3
74238: PPUSH
74239: CALL 16289 0 3
74243: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74244: LD_VAR 0 3
74248: PUSH
74249: LD_EXP 54
74253: PUSH
74254: LD_VAR 0 2
74258: ARRAY
74259: IN
74260: IFFALSE 74487
// begin if GetClass ( j ) <> 4 then
74262: LD_VAR 0 3
74266: PPUSH
74267: CALL_OW 257
74271: PUSH
74272: LD_INT 4
74274: NONEQUAL
74275: IFFALSE 74328
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74277: LD_ADDR_EXP 54
74281: PUSH
74282: LD_EXP 54
74286: PPUSH
74287: LD_VAR 0 2
74291: PPUSH
74292: LD_EXP 54
74296: PUSH
74297: LD_VAR 0 2
74301: ARRAY
74302: PUSH
74303: LD_VAR 0 3
74307: DIFF
74308: PPUSH
74309: CALL_OW 1
74313: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74314: LD_VAR 0 3
74318: PPUSH
74319: LD_INT 0
74321: PPUSH
74322: CALL_OW 109
// continue ;
74326: GO 74148
// end ; if IsInUnit ( j ) then
74328: LD_VAR 0 3
74332: PPUSH
74333: CALL_OW 310
74337: IFFALSE 74348
// ComExitBuilding ( j ) ;
74339: LD_VAR 0 3
74343: PPUSH
74344: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74348: LD_ADDR_VAR 0 6
74352: PUSH
74353: LD_VAR 0 7
74357: PPUSH
74358: LD_VAR 0 3
74362: PPUSH
74363: CALL_OW 74
74367: ST_TO_ADDR
// if not ape then
74368: LD_VAR 0 6
74372: NOT
74373: IFFALSE 74377
// break ;
74375: GO 74489
// x := GetX ( ape ) ;
74377: LD_ADDR_VAR 0 4
74381: PUSH
74382: LD_VAR 0 6
74386: PPUSH
74387: CALL_OW 250
74391: ST_TO_ADDR
// y := GetY ( ape ) ;
74392: LD_ADDR_VAR 0 5
74396: PUSH
74397: LD_VAR 0 6
74401: PPUSH
74402: CALL_OW 251
74406: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74407: LD_VAR 0 4
74411: PPUSH
74412: LD_VAR 0 5
74416: PPUSH
74417: CALL_OW 488
74421: NOT
74422: IFTRUE 74452
74424: PUSH
74425: LD_VAR 0 11
74429: PPUSH
74430: LD_VAR 0 4
74434: PPUSH
74435: LD_VAR 0 5
74439: PPUSH
74440: LD_INT 20
74442: PPUSH
74443: CALL 17559 0 4
74447: PUSH
74448: LD_INT 4
74450: ARRAY
74451: OR
74452: IFFALSE 74456
// break ;
74454: GO 74489
// if not HasTask ( j ) then
74456: LD_VAR 0 3
74460: PPUSH
74461: CALL_OW 314
74465: NOT
74466: IFFALSE 74487
// ComTameXY ( j , x , y ) ;
74468: LD_VAR 0 3
74472: PPUSH
74473: LD_VAR 0 4
74477: PPUSH
74478: LD_VAR 0 5
74482: PPUSH
74483: CALL_OW 131
// end ; end ;
74487: GO 74148
74489: POP
74490: POP
// end ;
74491: GO 73692
74493: POP
74494: POP
// end ;
74495: LD_VAR 0 1
74499: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74500: LD_INT 0
74502: PPUSH
74503: PPUSH
74504: PPUSH
74505: PPUSH
74506: PPUSH
74507: PPUSH
74508: PPUSH
74509: PPUSH
// if not mc_bases then
74510: LD_EXP 23
74514: NOT
74515: IFFALSE 74519
// exit ;
74517: GO 75151
// for i = 1 to mc_bases do
74519: LD_ADDR_VAR 0 2
74523: PUSH
74524: DOUBLE
74525: LD_INT 1
74527: DEC
74528: ST_TO_ADDR
74529: LD_EXP 23
74533: PUSH
74534: FOR_TO
74535: IFFALSE 75149
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74537: LD_EXP 52
74541: PUSH
74542: LD_VAR 0 2
74546: ARRAY
74547: NOT
74548: IFTRUE 74578
74550: PUSH
74551: LD_EXP 52
74555: PUSH
74556: LD_VAR 0 2
74560: ARRAY
74561: PPUSH
74562: LD_INT 25
74564: PUSH
74565: LD_INT 12
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PPUSH
74572: CALL_OW 72
74576: NOT
74577: OR
74578: IFFALSE 74582
// continue ;
74580: GO 74534
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74582: LD_ADDR_VAR 0 5
74586: PUSH
74587: LD_EXP 52
74591: PUSH
74592: LD_VAR 0 2
74596: ARRAY
74597: PUSH
74598: LD_INT 1
74600: ARRAY
74601: PPUSH
74602: CALL_OW 255
74606: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74607: LD_VAR 0 5
74611: PPUSH
74612: LD_INT 2
74614: PPUSH
74615: CALL_OW 325
74619: IFFALSE 74872
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74621: LD_ADDR_VAR 0 4
74625: PUSH
74626: LD_EXP 52
74630: PUSH
74631: LD_VAR 0 2
74635: ARRAY
74636: PPUSH
74637: LD_INT 25
74639: PUSH
74640: LD_INT 16
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PPUSH
74647: CALL_OW 72
74651: ST_TO_ADDR
// if tmp < 6 then
74652: LD_VAR 0 4
74656: PUSH
74657: LD_INT 6
74659: LESS
74660: IFFALSE 74872
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74662: LD_ADDR_VAR 0 6
74666: PUSH
74667: LD_EXP 23
74671: PUSH
74672: LD_VAR 0 2
74676: ARRAY
74677: PPUSH
74678: LD_INT 2
74680: PUSH
74681: LD_INT 30
74683: PUSH
74684: LD_INT 0
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 30
74693: PUSH
74694: LD_INT 1
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: EMPTY
74702: LIST
74703: LIST
74704: LIST
74705: PPUSH
74706: CALL_OW 72
74710: ST_TO_ADDR
// if depot then
74711: LD_VAR 0 6
74715: IFFALSE 74872
// begin selected := 0 ;
74717: LD_ADDR_VAR 0 7
74721: PUSH
74722: LD_INT 0
74724: ST_TO_ADDR
// for j in depot do
74725: LD_ADDR_VAR 0 3
74729: PUSH
74730: LD_VAR 0 6
74734: PUSH
74735: FOR_IN
74736: IFFALSE 74767
// begin if UnitsInside ( j ) < 6 then
74738: LD_VAR 0 3
74742: PPUSH
74743: CALL_OW 313
74747: PUSH
74748: LD_INT 6
74750: LESS
74751: IFFALSE 74765
// begin selected := j ;
74753: LD_ADDR_VAR 0 7
74757: PUSH
74758: LD_VAR 0 3
74762: ST_TO_ADDR
// break ;
74763: GO 74767
// end ; end ;
74765: GO 74735
74767: POP
74768: POP
// if selected then
74769: LD_VAR 0 7
74773: IFFALSE 74872
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74775: LD_ADDR_VAR 0 3
74779: PUSH
74780: LD_EXP 52
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: PPUSH
74791: LD_INT 25
74793: PUSH
74794: LD_INT 12
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PPUSH
74801: CALL_OW 72
74805: PUSH
74806: FOR_IN
74807: IFFALSE 74870
// if not HasTask ( j ) then
74809: LD_VAR 0 3
74813: PPUSH
74814: CALL_OW 314
74818: NOT
74819: IFFALSE 74868
// begin if not IsInUnit ( j ) then
74821: LD_VAR 0 3
74825: PPUSH
74826: CALL_OW 310
74830: NOT
74831: IFFALSE 74847
// ComEnterUnit ( j , selected ) ;
74833: LD_VAR 0 3
74837: PPUSH
74838: LD_VAR 0 7
74842: PPUSH
74843: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74847: LD_VAR 0 3
74851: PPUSH
74852: LD_INT 16
74854: PPUSH
74855: CALL_OW 183
// AddComExitBuilding ( j ) ;
74859: LD_VAR 0 3
74863: PPUSH
74864: CALL_OW 182
// end ;
74868: GO 74806
74870: POP
74871: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74872: LD_VAR 0 5
74876: PPUSH
74877: LD_INT 11
74879: PPUSH
74880: CALL_OW 325
74884: IFFALSE 75147
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74886: LD_ADDR_VAR 0 4
74890: PUSH
74891: LD_EXP 52
74895: PUSH
74896: LD_VAR 0 2
74900: ARRAY
74901: PPUSH
74902: LD_INT 25
74904: PUSH
74905: LD_INT 16
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PPUSH
74912: CALL_OW 72
74916: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74917: LD_VAR 0 4
74921: PUSH
74922: LD_INT 6
74924: GREATEREQUAL
74925: IFTRUE 74942
74927: PUSH
74928: LD_VAR 0 5
74932: PPUSH
74933: LD_INT 2
74935: PPUSH
74936: CALL_OW 325
74940: NOT
74941: OR
74942: IFFALSE 75147
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74944: LD_ADDR_VAR 0 8
74948: PUSH
74949: LD_EXP 23
74953: PUSH
74954: LD_VAR 0 2
74958: ARRAY
74959: PPUSH
74960: LD_INT 2
74962: PUSH
74963: LD_INT 30
74965: PUSH
74966: LD_INT 4
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 30
74975: PUSH
74976: LD_INT 5
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: LIST
74987: PPUSH
74988: CALL_OW 72
74992: ST_TO_ADDR
// if barracks then
74993: LD_VAR 0 8
74997: IFFALSE 75147
// begin selected := 0 ;
74999: LD_ADDR_VAR 0 7
75003: PUSH
75004: LD_INT 0
75006: ST_TO_ADDR
// for j in barracks do
75007: LD_ADDR_VAR 0 3
75011: PUSH
75012: LD_VAR 0 8
75016: PUSH
75017: FOR_IN
75018: IFFALSE 75049
// begin if UnitsInside ( j ) < 6 then
75020: LD_VAR 0 3
75024: PPUSH
75025: CALL_OW 313
75029: PUSH
75030: LD_INT 6
75032: LESS
75033: IFFALSE 75047
// begin selected := j ;
75035: LD_ADDR_VAR 0 7
75039: PUSH
75040: LD_VAR 0 3
75044: ST_TO_ADDR
// break ;
75045: GO 75049
// end ; end ;
75047: GO 75017
75049: POP
75050: POP
// if selected then
75051: LD_VAR 0 7
75055: IFFALSE 75147
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75057: LD_ADDR_VAR 0 3
75061: PUSH
75062: LD_EXP 52
75066: PUSH
75067: LD_VAR 0 2
75071: ARRAY
75072: PPUSH
75073: LD_INT 25
75075: PUSH
75076: LD_INT 12
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PPUSH
75083: CALL_OW 72
75087: PUSH
75088: FOR_IN
75089: IFFALSE 75145
// if not IsInUnit ( j ) and not HasTask ( j ) then
75091: LD_VAR 0 3
75095: PPUSH
75096: CALL_OW 310
75100: NOT
75101: IFFALSE 75115
75103: PUSH
75104: LD_VAR 0 3
75108: PPUSH
75109: CALL_OW 314
75113: NOT
75114: AND
75115: IFFALSE 75143
// begin ComEnterUnit ( j , selected ) ;
75117: LD_VAR 0 3
75121: PPUSH
75122: LD_VAR 0 7
75126: PPUSH
75127: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75131: LD_VAR 0 3
75135: PPUSH
75136: LD_INT 15
75138: PPUSH
75139: CALL_OW 183
// end ;
75143: GO 75088
75145: POP
75146: POP
// end ; end ; end ; end ; end ;
75147: GO 74534
75149: POP
75150: POP
// end ;
75151: LD_VAR 0 1
75155: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75156: LD_INT 0
75158: PPUSH
75159: PPUSH
75160: PPUSH
75161: PPUSH
// if not mc_bases then
75162: LD_EXP 23
75166: NOT
75167: IFFALSE 75171
// exit ;
75169: GO 75353
// for i = 1 to mc_bases do
75171: LD_ADDR_VAR 0 2
75175: PUSH
75176: DOUBLE
75177: LD_INT 1
75179: DEC
75180: ST_TO_ADDR
75181: LD_EXP 23
75185: PUSH
75186: FOR_TO
75187: IFFALSE 75351
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75189: LD_ADDR_VAR 0 4
75193: PUSH
75194: LD_EXP 23
75198: PUSH
75199: LD_VAR 0 2
75203: ARRAY
75204: PPUSH
75205: LD_INT 25
75207: PUSH
75208: LD_INT 9
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: PPUSH
75215: CALL_OW 72
75219: ST_TO_ADDR
// if not tmp then
75220: LD_VAR 0 4
75224: NOT
75225: IFFALSE 75229
// continue ;
75227: GO 75186
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75229: LD_EXP 49
75233: PUSH
75234: LD_VAR 0 2
75238: ARRAY
75239: PPUSH
75240: LD_INT 29
75242: PPUSH
75243: CALL_OW 325
75247: NOT
75248: IFFALSE 75271
75250: PUSH
75251: LD_EXP 49
75255: PUSH
75256: LD_VAR 0 2
75260: ARRAY
75261: PPUSH
75262: LD_INT 28
75264: PPUSH
75265: CALL_OW 325
75269: NOT
75270: AND
75271: IFFALSE 75275
// continue ;
75273: GO 75186
// for j in tmp do
75275: LD_ADDR_VAR 0 3
75279: PUSH
75280: LD_VAR 0 4
75284: PUSH
75285: FOR_IN
75286: IFFALSE 75347
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75288: LD_VAR 0 3
75292: PUSH
75293: LD_EXP 26
75297: PUSH
75298: LD_VAR 0 2
75302: ARRAY
75303: PUSH
75304: LD_INT 1
75306: ARRAY
75307: IN
75308: NOT
75309: IFFALSE 75334
75311: PUSH
75312: LD_VAR 0 3
75316: PUSH
75317: LD_EXP 26
75321: PUSH
75322: LD_VAR 0 2
75326: ARRAY
75327: PUSH
75328: LD_INT 2
75330: ARRAY
75331: IN
75332: NOT
75333: AND
75334: IFFALSE 75345
// ComSpaceTimeShoot ( j ) ;
75336: LD_VAR 0 3
75340: PPUSH
75341: CALL 12206 0 1
75345: GO 75285
75347: POP
75348: POP
// end ;
75349: GO 75186
75351: POP
75352: POP
// end ;
75353: LD_VAR 0 1
75357: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75358: LD_INT 0
75360: PPUSH
75361: PPUSH
75362: PPUSH
75363: PPUSH
75364: PPUSH
75365: PPUSH
75366: PPUSH
75367: PPUSH
75368: PPUSH
// if not mc_bases then
75369: LD_EXP 23
75373: NOT
75374: IFFALSE 75378
// exit ;
75376: GO 76010
// for i = 1 to mc_bases do
75378: LD_ADDR_VAR 0 2
75382: PUSH
75383: DOUBLE
75384: LD_INT 1
75386: DEC
75387: ST_TO_ADDR
75388: LD_EXP 23
75392: PUSH
75393: FOR_TO
75394: IFFALSE 76008
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75396: LD_EXP 58
75400: PUSH
75401: LD_VAR 0 2
75405: ARRAY
75406: NOT
75407: IFTRUE 75433
75409: PUSH
75410: LD_INT 38
75412: PPUSH
75413: LD_EXP 49
75417: PUSH
75418: LD_VAR 0 2
75422: ARRAY
75423: PPUSH
75424: CALL_OW 321
75428: PUSH
75429: LD_INT 2
75431: NONEQUAL
75432: OR
75433: IFFALSE 75437
// continue ;
75435: GO 75393
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75437: LD_ADDR_VAR 0 8
75441: PUSH
75442: LD_EXP 23
75446: PUSH
75447: LD_VAR 0 2
75451: ARRAY
75452: PPUSH
75453: LD_INT 30
75455: PUSH
75456: LD_INT 34
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: PPUSH
75463: CALL_OW 72
75467: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75468: LD_ADDR_VAR 0 9
75472: PUSH
75473: LD_EXP 23
75477: PUSH
75478: LD_VAR 0 2
75482: ARRAY
75483: PPUSH
75484: LD_INT 25
75486: PUSH
75487: LD_INT 4
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PPUSH
75494: CALL_OW 72
75498: PPUSH
75499: LD_INT 0
75501: PPUSH
75502: CALL 46892 0 2
75506: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75507: LD_VAR 0 9
75511: NOT
75512: IFTRUE 75521
75514: PUSH
75515: LD_VAR 0 8
75519: NOT
75520: OR
75521: IFTRUE 75543
75523: PUSH
75524: LD_EXP 23
75528: PUSH
75529: LD_VAR 0 2
75533: ARRAY
75534: PPUSH
75535: LD_INT 124
75537: PPUSH
75538: CALL 46892 0 2
75542: OR
75543: IFFALSE 75547
// continue ;
75545: GO 75393
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75547: LD_EXP 59
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: PUSH
75558: LD_EXP 58
75562: PUSH
75563: LD_VAR 0 2
75567: ARRAY
75568: LESS
75569: IFFALSE 75589
75571: PUSH
75572: LD_EXP 59
75576: PUSH
75577: LD_VAR 0 2
75581: ARRAY
75582: PUSH
75583: LD_VAR 0 8
75587: LESS
75588: AND
75589: IFFALSE 76006
// begin tmp := sci [ 1 ] ;
75591: LD_ADDR_VAR 0 7
75595: PUSH
75596: LD_VAR 0 9
75600: PUSH
75601: LD_INT 1
75603: ARRAY
75604: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75605: LD_VAR 0 7
75609: PPUSH
75610: LD_INT 124
75612: PPUSH
75613: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75617: LD_ADDR_VAR 0 3
75621: PUSH
75622: DOUBLE
75623: LD_EXP 58
75627: PUSH
75628: LD_VAR 0 2
75632: ARRAY
75633: INC
75634: ST_TO_ADDR
75635: LD_EXP 58
75639: PUSH
75640: LD_VAR 0 2
75644: ARRAY
75645: PUSH
75646: FOR_DOWNTO
75647: IFFALSE 75992
// begin if IsInUnit ( tmp ) then
75649: LD_VAR 0 7
75653: PPUSH
75654: CALL_OW 310
75658: IFFALSE 75669
// ComExitBuilding ( tmp ) ;
75660: LD_VAR 0 7
75664: PPUSH
75665: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75669: LD_INT 35
75671: PPUSH
75672: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75676: LD_VAR 0 7
75680: PPUSH
75681: CALL_OW 310
75685: NOT
75686: IFFALSE 75700
75688: PUSH
75689: LD_VAR 0 7
75693: PPUSH
75694: CALL_OW 314
75698: NOT
75699: AND
75700: IFFALSE 75669
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75702: LD_ADDR_VAR 0 6
75706: PUSH
75707: LD_VAR 0 7
75711: PPUSH
75712: CALL_OW 250
75716: PUSH
75717: LD_VAR 0 7
75721: PPUSH
75722: CALL_OW 251
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75731: LD_INT 35
75733: PPUSH
75734: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75738: LD_ADDR_VAR 0 4
75742: PUSH
75743: LD_EXP 58
75747: PUSH
75748: LD_VAR 0 2
75752: ARRAY
75753: PUSH
75754: LD_VAR 0 3
75758: ARRAY
75759: PUSH
75760: LD_INT 1
75762: ARRAY
75763: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75764: LD_ADDR_VAR 0 5
75768: PUSH
75769: LD_EXP 58
75773: PUSH
75774: LD_VAR 0 2
75778: ARRAY
75779: PUSH
75780: LD_VAR 0 3
75784: ARRAY
75785: PUSH
75786: LD_INT 2
75788: ARRAY
75789: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75790: LD_VAR 0 7
75794: PPUSH
75795: LD_INT 10
75797: PPUSH
75798: CALL 19268 0 2
75802: PUSH
75803: LD_INT 4
75805: ARRAY
75806: IFFALSE 75844
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75808: LD_VAR 0 7
75812: PPUSH
75813: LD_VAR 0 6
75817: PUSH
75818: LD_INT 1
75820: ARRAY
75821: PPUSH
75822: LD_VAR 0 6
75826: PUSH
75827: LD_INT 2
75829: ARRAY
75830: PPUSH
75831: CALL_OW 111
// wait ( 0 0$10 ) ;
75835: LD_INT 350
75837: PPUSH
75838: CALL_OW 67
// end else
75842: GO 75870
// begin ComMoveXY ( tmp , x , y ) ;
75844: LD_VAR 0 7
75848: PPUSH
75849: LD_VAR 0 4
75853: PPUSH
75854: LD_VAR 0 5
75858: PPUSH
75859: CALL_OW 111
// wait ( 0 0$3 ) ;
75863: LD_INT 105
75865: PPUSH
75866: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75870: LD_VAR 0 7
75874: PPUSH
75875: LD_VAR 0 4
75879: PPUSH
75880: LD_VAR 0 5
75884: PPUSH
75885: CALL_OW 307
75889: IFFALSE 75731
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75891: LD_VAR 0 7
75895: PPUSH
75896: LD_VAR 0 4
75900: PPUSH
75901: LD_VAR 0 5
75905: PPUSH
75906: LD_VAR 0 8
75910: PUSH
75911: LD_VAR 0 3
75915: ARRAY
75916: PPUSH
75917: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75921: LD_INT 35
75923: PPUSH
75924: CALL_OW 67
// until not HasTask ( tmp ) ;
75928: LD_VAR 0 7
75932: PPUSH
75933: CALL_OW 314
75937: NOT
75938: IFFALSE 75921
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75940: LD_ADDR_EXP 59
75944: PUSH
75945: LD_EXP 59
75949: PPUSH
75950: LD_VAR 0 2
75954: PUSH
75955: LD_EXP 59
75959: PUSH
75960: LD_VAR 0 2
75964: ARRAY
75965: PUSH
75966: LD_INT 1
75968: PLUS
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: PPUSH
75974: LD_VAR 0 8
75978: PUSH
75979: LD_VAR 0 3
75983: ARRAY
75984: PPUSH
75985: CALL 16289 0 3
75989: ST_TO_ADDR
// end ;
75990: GO 75646
75992: POP
75993: POP
// MC_Reset ( i , 124 ) ;
75994: LD_VAR 0 2
75998: PPUSH
75999: LD_INT 124
76001: PPUSH
76002: CALL 58870 0 2
// end ; end ;
76006: GO 75393
76008: POP
76009: POP
// end ;
76010: LD_VAR 0 1
76014: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76015: LD_INT 0
76017: PPUSH
76018: PPUSH
76019: PPUSH
// if not mc_bases then
76020: LD_EXP 23
76024: NOT
76025: IFFALSE 76029
// exit ;
76027: GO 76643
// for i = 1 to mc_bases do
76029: LD_ADDR_VAR 0 2
76033: PUSH
76034: DOUBLE
76035: LD_INT 1
76037: DEC
76038: ST_TO_ADDR
76039: LD_EXP 23
76043: PUSH
76044: FOR_TO
76045: IFFALSE 76641
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76047: LD_ADDR_VAR 0 3
76051: PUSH
76052: LD_EXP 23
76056: PUSH
76057: LD_VAR 0 2
76061: ARRAY
76062: PPUSH
76063: LD_INT 25
76065: PUSH
76066: LD_INT 4
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PPUSH
76073: CALL_OW 72
76077: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76078: LD_VAR 0 3
76082: NOT
76083: IFTRUE 76098
76085: PUSH
76086: LD_EXP 60
76090: PUSH
76091: LD_VAR 0 2
76095: ARRAY
76096: NOT
76097: OR
76098: IFTRUE 76146
76100: PUSH
76101: LD_EXP 23
76105: PUSH
76106: LD_VAR 0 2
76110: ARRAY
76111: PPUSH
76112: LD_INT 2
76114: PUSH
76115: LD_INT 30
76117: PUSH
76118: LD_INT 0
76120: PUSH
76121: EMPTY
76122: LIST
76123: LIST
76124: PUSH
76125: LD_INT 30
76127: PUSH
76128: LD_INT 1
76130: PUSH
76131: EMPTY
76132: LIST
76133: LIST
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: LIST
76139: PPUSH
76140: CALL_OW 72
76144: NOT
76145: OR
76146: IFFALSE 76196
// begin if mc_deposits_finder [ i ] then
76148: LD_EXP 61
76152: PUSH
76153: LD_VAR 0 2
76157: ARRAY
76158: IFFALSE 76194
// begin MC_Reset ( i , 125 ) ;
76160: LD_VAR 0 2
76164: PPUSH
76165: LD_INT 125
76167: PPUSH
76168: CALL 58870 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76172: LD_ADDR_EXP 61
76176: PUSH
76177: LD_EXP 61
76181: PPUSH
76182: LD_VAR 0 2
76186: PPUSH
76187: EMPTY
76188: PPUSH
76189: CALL_OW 1
76193: ST_TO_ADDR
// end ; continue ;
76194: GO 76044
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76196: LD_EXP 60
76200: PUSH
76201: LD_VAR 0 2
76205: ARRAY
76206: PUSH
76207: LD_INT 1
76209: ARRAY
76210: PUSH
76211: LD_INT 3
76213: ARRAY
76214: PUSH
76215: LD_INT 1
76217: EQUAL
76218: IFFALSE 76244
76220: PUSH
76221: LD_INT 20
76223: PPUSH
76224: LD_EXP 49
76228: PUSH
76229: LD_VAR 0 2
76233: ARRAY
76234: PPUSH
76235: CALL_OW 321
76239: PUSH
76240: LD_INT 2
76242: NONEQUAL
76243: AND
76244: IFFALSE 76294
// begin if mc_deposits_finder [ i ] then
76246: LD_EXP 61
76250: PUSH
76251: LD_VAR 0 2
76255: ARRAY
76256: IFFALSE 76292
// begin MC_Reset ( i , 125 ) ;
76258: LD_VAR 0 2
76262: PPUSH
76263: LD_INT 125
76265: PPUSH
76266: CALL 58870 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76270: LD_ADDR_EXP 61
76274: PUSH
76275: LD_EXP 61
76279: PPUSH
76280: LD_VAR 0 2
76284: PPUSH
76285: EMPTY
76286: PPUSH
76287: CALL_OW 1
76291: ST_TO_ADDR
// end ; continue ;
76292: GO 76044
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76294: LD_EXP 60
76298: PUSH
76299: LD_VAR 0 2
76303: ARRAY
76304: PUSH
76305: LD_INT 1
76307: ARRAY
76308: PUSH
76309: LD_INT 1
76311: ARRAY
76312: PPUSH
76313: LD_EXP 60
76317: PUSH
76318: LD_VAR 0 2
76322: ARRAY
76323: PUSH
76324: LD_INT 1
76326: ARRAY
76327: PUSH
76328: LD_INT 2
76330: ARRAY
76331: PPUSH
76332: LD_EXP 49
76336: PUSH
76337: LD_VAR 0 2
76341: ARRAY
76342: PPUSH
76343: CALL_OW 440
76347: IFFALSE 76390
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76349: LD_ADDR_EXP 60
76353: PUSH
76354: LD_EXP 60
76358: PPUSH
76359: LD_VAR 0 2
76363: PPUSH
76364: LD_EXP 60
76368: PUSH
76369: LD_VAR 0 2
76373: ARRAY
76374: PPUSH
76375: LD_INT 1
76377: PPUSH
76378: CALL_OW 3
76382: PPUSH
76383: CALL_OW 1
76387: ST_TO_ADDR
76388: GO 76639
// begin if not mc_deposits_finder [ i ] then
76390: LD_EXP 61
76394: PUSH
76395: LD_VAR 0 2
76399: ARRAY
76400: NOT
76401: IFFALSE 76453
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76403: LD_ADDR_EXP 61
76407: PUSH
76408: LD_EXP 61
76412: PPUSH
76413: LD_VAR 0 2
76417: PPUSH
76418: LD_VAR 0 3
76422: PUSH
76423: LD_INT 1
76425: ARRAY
76426: PUSH
76427: EMPTY
76428: LIST
76429: PPUSH
76430: CALL_OW 1
76434: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76435: LD_VAR 0 3
76439: PUSH
76440: LD_INT 1
76442: ARRAY
76443: PPUSH
76444: LD_INT 125
76446: PPUSH
76447: CALL_OW 109
// end else
76451: GO 76639
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76453: LD_EXP 61
76457: PUSH
76458: LD_VAR 0 2
76462: ARRAY
76463: PUSH
76464: LD_INT 1
76466: ARRAY
76467: PPUSH
76468: CALL_OW 310
76472: IFFALSE 76495
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76474: LD_EXP 61
76478: PUSH
76479: LD_VAR 0 2
76483: ARRAY
76484: PUSH
76485: LD_INT 1
76487: ARRAY
76488: PPUSH
76489: CALL_OW 122
76493: GO 76639
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76495: LD_EXP 61
76499: PUSH
76500: LD_VAR 0 2
76504: ARRAY
76505: PUSH
76506: LD_INT 1
76508: ARRAY
76509: PPUSH
76510: CALL_OW 314
76514: NOT
76515: IFFALSE 76580
76517: PUSH
76518: LD_EXP 61
76522: PUSH
76523: LD_VAR 0 2
76527: ARRAY
76528: PUSH
76529: LD_INT 1
76531: ARRAY
76532: PPUSH
76533: LD_EXP 60
76537: PUSH
76538: LD_VAR 0 2
76542: ARRAY
76543: PUSH
76544: LD_INT 1
76546: ARRAY
76547: PUSH
76548: LD_INT 1
76550: ARRAY
76551: PPUSH
76552: LD_EXP 60
76556: PUSH
76557: LD_VAR 0 2
76561: ARRAY
76562: PUSH
76563: LD_INT 1
76565: ARRAY
76566: PUSH
76567: LD_INT 2
76569: ARRAY
76570: PPUSH
76571: CALL_OW 297
76575: PUSH
76576: LD_INT 6
76578: GREATER
76579: AND
76580: IFFALSE 76639
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76582: LD_EXP 61
76586: PUSH
76587: LD_VAR 0 2
76591: ARRAY
76592: PUSH
76593: LD_INT 1
76595: ARRAY
76596: PPUSH
76597: LD_EXP 60
76601: PUSH
76602: LD_VAR 0 2
76606: ARRAY
76607: PUSH
76608: LD_INT 1
76610: ARRAY
76611: PUSH
76612: LD_INT 1
76614: ARRAY
76615: PPUSH
76616: LD_EXP 60
76620: PUSH
76621: LD_VAR 0 2
76625: ARRAY
76626: PUSH
76627: LD_INT 1
76629: ARRAY
76630: PUSH
76631: LD_INT 2
76633: ARRAY
76634: PPUSH
76635: CALL_OW 111
// end ; end ; end ;
76639: GO 76044
76641: POP
76642: POP
// end ;
76643: LD_VAR 0 1
76647: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76648: LD_INT 0
76650: PPUSH
76651: PPUSH
76652: PPUSH
76653: PPUSH
76654: PPUSH
76655: PPUSH
76656: PPUSH
76657: PPUSH
76658: PPUSH
76659: PPUSH
76660: PPUSH
// if not mc_bases then
76661: LD_EXP 23
76665: NOT
76666: IFFALSE 76670
// exit ;
76668: GO 77630
// for i = 1 to mc_bases do
76670: LD_ADDR_VAR 0 2
76674: PUSH
76675: DOUBLE
76676: LD_INT 1
76678: DEC
76679: ST_TO_ADDR
76680: LD_EXP 23
76684: PUSH
76685: FOR_TO
76686: IFFALSE 77628
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76688: LD_EXP 23
76692: PUSH
76693: LD_VAR 0 2
76697: ARRAY
76698: NOT
76699: IFTRUE 76713
76701: PUSH
76702: LD_EXP 46
76706: PUSH
76707: LD_VAR 0 2
76711: ARRAY
76712: OR
76713: IFFALSE 76717
// continue ;
76715: GO 76685
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76717: LD_ADDR_VAR 0 7
76721: PUSH
76722: LD_EXP 23
76726: PUSH
76727: LD_VAR 0 2
76731: ARRAY
76732: PUSH
76733: LD_INT 1
76735: ARRAY
76736: PPUSH
76737: CALL_OW 248
76741: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76742: LD_VAR 0 7
76746: PUSH
76747: LD_INT 3
76749: EQUAL
76750: IFTRUE 76792
76752: PUSH
76753: LD_EXP 42
76757: PUSH
76758: LD_VAR 0 2
76762: ARRAY
76763: PUSH
76764: LD_EXP 45
76768: PUSH
76769: LD_VAR 0 2
76773: ARRAY
76774: UNION
76775: PPUSH
76776: LD_INT 33
76778: PUSH
76779: LD_INT 2
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PPUSH
76786: CALL_OW 72
76790: NOT
76791: OR
76792: IFFALSE 76796
// continue ;
76794: GO 76685
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76796: LD_ADDR_VAR 0 9
76800: PUSH
76801: LD_EXP 23
76805: PUSH
76806: LD_VAR 0 2
76810: ARRAY
76811: PPUSH
76812: LD_INT 30
76814: PUSH
76815: LD_INT 36
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PPUSH
76822: CALL_OW 72
76826: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76827: LD_ADDR_VAR 0 10
76831: PUSH
76832: LD_EXP 42
76836: PUSH
76837: LD_VAR 0 2
76841: ARRAY
76842: PPUSH
76843: LD_INT 34
76845: PUSH
76846: LD_INT 31
76848: PUSH
76849: EMPTY
76850: LIST
76851: LIST
76852: PPUSH
76853: CALL_OW 72
76857: ST_TO_ADDR
// if not cts and not mcts then
76858: LD_VAR 0 9
76862: NOT
76863: IFFALSE 76872
76865: PUSH
76866: LD_VAR 0 10
76870: NOT
76871: AND
76872: IFFALSE 76876
// continue ;
76874: GO 76685
// x := cts ;
76876: LD_ADDR_VAR 0 11
76880: PUSH
76881: LD_VAR 0 9
76885: ST_TO_ADDR
// if not x then
76886: LD_VAR 0 11
76890: NOT
76891: IFFALSE 76903
// x := mcts ;
76893: LD_ADDR_VAR 0 11
76897: PUSH
76898: LD_VAR 0 10
76902: ST_TO_ADDR
// if not x then
76903: LD_VAR 0 11
76907: NOT
76908: IFFALSE 76912
// continue ;
76910: GO 76685
// if mc_remote_driver [ i ] then
76912: LD_EXP 63
76916: PUSH
76917: LD_VAR 0 2
76921: ARRAY
76922: IFFALSE 77321
// for j in mc_remote_driver [ i ] do
76924: LD_ADDR_VAR 0 3
76928: PUSH
76929: LD_EXP 63
76933: PUSH
76934: LD_VAR 0 2
76938: ARRAY
76939: PUSH
76940: FOR_IN
76941: IFFALSE 77319
// begin if GetClass ( j ) <> 3 then
76943: LD_VAR 0 3
76947: PPUSH
76948: CALL_OW 257
76952: PUSH
76953: LD_INT 3
76955: NONEQUAL
76956: IFFALSE 77009
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76958: LD_ADDR_EXP 63
76962: PUSH
76963: LD_EXP 63
76967: PPUSH
76968: LD_VAR 0 2
76972: PPUSH
76973: LD_EXP 63
76977: PUSH
76978: LD_VAR 0 2
76982: ARRAY
76983: PUSH
76984: LD_VAR 0 3
76988: DIFF
76989: PPUSH
76990: CALL_OW 1
76994: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76995: LD_VAR 0 3
76999: PPUSH
77000: LD_INT 0
77002: PPUSH
77003: CALL_OW 109
// continue ;
77007: GO 76940
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
77009: LD_EXP 42
77013: PUSH
77014: LD_VAR 0 2
77018: ARRAY
77019: PPUSH
77020: LD_INT 34
77022: PUSH
77023: LD_INT 31
77025: PUSH
77026: EMPTY
77027: LIST
77028: LIST
77029: PUSH
77030: LD_INT 58
77032: PUSH
77033: EMPTY
77034: LIST
77035: PUSH
77036: EMPTY
77037: LIST
77038: LIST
77039: PPUSH
77040: CALL_OW 72
77044: IFFALSE 77058
77046: PUSH
77047: LD_VAR 0 3
77051: PPUSH
77052: CALL 46927 0 1
77056: NOT
77057: AND
77058: IFFALSE 77129
// begin if IsInUnit ( j ) then
77060: LD_VAR 0 3
77064: PPUSH
77065: CALL_OW 310
77069: IFFALSE 77080
// ComExitBuilding ( j ) ;
77071: LD_VAR 0 3
77075: PPUSH
77076: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77080: LD_VAR 0 3
77084: PPUSH
77085: LD_EXP 42
77089: PUSH
77090: LD_VAR 0 2
77094: ARRAY
77095: PPUSH
77096: LD_INT 34
77098: PUSH
77099: LD_INT 31
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 58
77108: PUSH
77109: EMPTY
77110: LIST
77111: PUSH
77112: EMPTY
77113: LIST
77114: LIST
77115: PPUSH
77116: CALL_OW 72
77120: PUSH
77121: LD_INT 1
77123: ARRAY
77124: PPUSH
77125: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77129: LD_VAR 0 3
77133: PPUSH
77134: CALL_OW 310
77138: NOT
77139: IFTRUE 77175
77141: PUSH
77142: LD_VAR 0 3
77146: PPUSH
77147: CALL_OW 310
77151: PPUSH
77152: CALL_OW 266
77156: PUSH
77157: LD_INT 36
77159: NONEQUAL
77160: IFFALSE 77174
77162: PUSH
77163: LD_VAR 0 3
77167: PPUSH
77168: CALL 46927 0 1
77172: NOT
77173: AND
77174: OR
77175: IFFALSE 77317
// begin if IsInUnit ( j ) then
77177: LD_VAR 0 3
77181: PPUSH
77182: CALL_OW 310
77186: IFFALSE 77197
// ComExitBuilding ( j ) ;
77188: LD_VAR 0 3
77192: PPUSH
77193: CALL_OW 122
// ct := 0 ;
77197: LD_ADDR_VAR 0 8
77201: PUSH
77202: LD_INT 0
77204: ST_TO_ADDR
// for k in x do
77205: LD_ADDR_VAR 0 4
77209: PUSH
77210: LD_VAR 0 11
77214: PUSH
77215: FOR_IN
77216: IFFALSE 77295
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77218: LD_VAR 0 4
77222: PPUSH
77223: CALL_OW 264
77227: PUSH
77228: LD_INT 31
77230: EQUAL
77231: IFFALSE 77245
77233: PUSH
77234: LD_VAR 0 4
77238: PPUSH
77239: CALL_OW 311
77243: NOT
77244: AND
77245: IFTRUE 77279
77247: PUSH
77248: LD_VAR 0 4
77252: PPUSH
77253: CALL_OW 266
77257: PUSH
77258: LD_INT 36
77260: EQUAL
77261: IFFALSE 77278
77263: PUSH
77264: LD_VAR 0 4
77268: PPUSH
77269: CALL_OW 313
77273: PUSH
77274: LD_INT 3
77276: LESS
77277: AND
77278: OR
77279: IFFALSE 77293
// begin ct := k ;
77281: LD_ADDR_VAR 0 8
77285: PUSH
77286: LD_VAR 0 4
77290: ST_TO_ADDR
// break ;
77291: GO 77295
// end ;
77293: GO 77215
77295: POP
77296: POP
// if ct then
77297: LD_VAR 0 8
77301: IFFALSE 77317
// ComEnterUnit ( j , ct ) ;
77303: LD_VAR 0 3
77307: PPUSH
77308: LD_VAR 0 8
77312: PPUSH
77313: CALL_OW 120
// end ; end ;
77317: GO 76940
77319: POP
77320: POP
// places := 0 ;
77321: LD_ADDR_VAR 0 5
77325: PUSH
77326: LD_INT 0
77328: ST_TO_ADDR
// for j = 1 to x do
77329: LD_ADDR_VAR 0 3
77333: PUSH
77334: DOUBLE
77335: LD_INT 1
77337: DEC
77338: ST_TO_ADDR
77339: LD_VAR 0 11
77343: PUSH
77344: FOR_TO
77345: IFFALSE 77421
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77347: LD_VAR 0 11
77351: PUSH
77352: LD_VAR 0 3
77356: ARRAY
77357: PPUSH
77358: CALL_OW 264
77362: PUSH
77363: LD_INT 31
77365: EQUAL
77366: IFFALSE 77384
// places := places + 1 else
77368: LD_ADDR_VAR 0 5
77372: PUSH
77373: LD_VAR 0 5
77377: PUSH
77378: LD_INT 1
77380: PLUS
77381: ST_TO_ADDR
77382: GO 77419
// if GetBType ( x [ j ] ) = b_control_tower then
77384: LD_VAR 0 11
77388: PUSH
77389: LD_VAR 0 3
77393: ARRAY
77394: PPUSH
77395: CALL_OW 266
77399: PUSH
77400: LD_INT 36
77402: EQUAL
77403: IFFALSE 77419
// places := places + 3 ;
77405: LD_ADDR_VAR 0 5
77409: PUSH
77410: LD_VAR 0 5
77414: PUSH
77415: LD_INT 3
77417: PLUS
77418: ST_TO_ADDR
77419: GO 77344
77421: POP
77422: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77423: LD_VAR 0 5
77427: PUSH
77428: LD_INT 0
77430: EQUAL
77431: IFTRUE 77451
77433: PUSH
77434: LD_VAR 0 5
77438: PUSH
77439: LD_EXP 63
77443: PUSH
77444: LD_VAR 0 2
77448: ARRAY
77449: LESSEQUAL
77450: OR
77451: IFFALSE 77455
// continue ;
77453: GO 76685
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77455: LD_ADDR_VAR 0 6
77459: PUSH
77460: LD_EXP 23
77464: PUSH
77465: LD_VAR 0 2
77469: ARRAY
77470: PPUSH
77471: LD_INT 25
77473: PUSH
77474: LD_INT 3
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PPUSH
77481: CALL_OW 72
77485: PUSH
77486: LD_EXP 63
77490: PUSH
77491: LD_VAR 0 2
77495: ARRAY
77496: DIFF
77497: PPUSH
77498: LD_INT 3
77500: PPUSH
77501: CALL 47827 0 2
77505: ST_TO_ADDR
// for j in tmp do
77506: LD_ADDR_VAR 0 3
77510: PUSH
77511: LD_VAR 0 6
77515: PUSH
77516: FOR_IN
77517: IFFALSE 77552
// if GetTag ( j ) > 0 then
77519: LD_VAR 0 3
77523: PPUSH
77524: CALL_OW 110
77528: PUSH
77529: LD_INT 0
77531: GREATER
77532: IFFALSE 77550
// tmp := tmp diff j ;
77534: LD_ADDR_VAR 0 6
77538: PUSH
77539: LD_VAR 0 6
77543: PUSH
77544: LD_VAR 0 3
77548: DIFF
77549: ST_TO_ADDR
77550: GO 77516
77552: POP
77553: POP
// if not tmp then
77554: LD_VAR 0 6
77558: NOT
77559: IFFALSE 77563
// continue ;
77561: GO 76685
// if places then
77563: LD_VAR 0 5
77567: IFFALSE 77626
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77569: LD_ADDR_EXP 63
77573: PUSH
77574: LD_EXP 63
77578: PPUSH
77579: LD_VAR 0 2
77583: PPUSH
77584: LD_EXP 63
77588: PUSH
77589: LD_VAR 0 2
77593: ARRAY
77594: PUSH
77595: LD_VAR 0 6
77599: PUSH
77600: LD_INT 1
77602: ARRAY
77603: UNION
77604: PPUSH
77605: CALL_OW 1
77609: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77610: LD_VAR 0 6
77614: PUSH
77615: LD_INT 1
77617: ARRAY
77618: PPUSH
77619: LD_INT 126
77621: PPUSH
77622: CALL_OW 109
// end ; end ;
77626: GO 76685
77628: POP
77629: POP
// end ;
77630: LD_VAR 0 1
77634: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77635: LD_INT 0
77637: PPUSH
77638: PPUSH
77639: PPUSH
77640: PPUSH
77641: PPUSH
77642: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77643: LD_VAR 0 1
77647: NOT
77648: IFTRUE 77657
77650: PUSH
77651: LD_VAR 0 2
77655: NOT
77656: OR
77657: IFTRUE 77666
77659: PUSH
77660: LD_VAR 0 3
77664: NOT
77665: OR
77666: IFTRUE 77714
77668: PUSH
77669: LD_VAR 0 4
77673: PUSH
77674: LD_INT 1
77676: PUSH
77677: LD_INT 2
77679: PUSH
77680: LD_INT 3
77682: PUSH
77683: LD_INT 4
77685: PUSH
77686: LD_INT 5
77688: PUSH
77689: LD_INT 8
77691: PUSH
77692: LD_INT 9
77694: PUSH
77695: LD_INT 15
77697: PUSH
77698: LD_INT 16
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: LIST
77705: LIST
77706: LIST
77707: LIST
77708: LIST
77709: LIST
77710: LIST
77711: IN
77712: NOT
77713: OR
77714: IFFALSE 77718
// exit ;
77716: GO 78578
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77718: LD_ADDR_VAR 0 2
77722: PUSH
77723: LD_VAR 0 2
77727: PPUSH
77728: LD_INT 21
77730: PUSH
77731: LD_INT 3
77733: PUSH
77734: EMPTY
77735: LIST
77736: LIST
77737: PUSH
77738: LD_INT 24
77740: PUSH
77741: LD_INT 250
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: PUSH
77748: EMPTY
77749: LIST
77750: LIST
77751: PPUSH
77752: CALL_OW 72
77756: ST_TO_ADDR
// case class of 1 , 15 :
77757: LD_VAR 0 4
77761: PUSH
77762: LD_INT 1
77764: DOUBLE
77765: EQUAL
77766: IFTRUE 77776
77768: LD_INT 15
77770: DOUBLE
77771: EQUAL
77772: IFTRUE 77776
77774: GO 77861
77776: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77777: LD_ADDR_VAR 0 8
77781: PUSH
77782: LD_VAR 0 2
77786: PPUSH
77787: LD_INT 2
77789: PUSH
77790: LD_INT 30
77792: PUSH
77793: LD_INT 32
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: PUSH
77800: LD_INT 30
77802: PUSH
77803: LD_INT 31
77805: PUSH
77806: EMPTY
77807: LIST
77808: LIST
77809: PUSH
77810: EMPTY
77811: LIST
77812: LIST
77813: LIST
77814: PPUSH
77815: CALL_OW 72
77819: PUSH
77820: LD_VAR 0 2
77824: PPUSH
77825: LD_INT 2
77827: PUSH
77828: LD_INT 30
77830: PUSH
77831: LD_INT 4
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 30
77840: PUSH
77841: LD_INT 5
77843: PUSH
77844: EMPTY
77845: LIST
77846: LIST
77847: PUSH
77848: EMPTY
77849: LIST
77850: LIST
77851: LIST
77852: PPUSH
77853: CALL_OW 72
77857: ADD
77858: ST_TO_ADDR
77859: GO 78107
77861: LD_INT 2
77863: DOUBLE
77864: EQUAL
77865: IFTRUE 77875
77867: LD_INT 16
77869: DOUBLE
77870: EQUAL
77871: IFTRUE 77875
77873: GO 77921
77875: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77876: LD_ADDR_VAR 0 8
77880: PUSH
77881: LD_VAR 0 2
77885: PPUSH
77886: LD_INT 2
77888: PUSH
77889: LD_INT 30
77891: PUSH
77892: LD_INT 0
77894: PUSH
77895: EMPTY
77896: LIST
77897: LIST
77898: PUSH
77899: LD_INT 30
77901: PUSH
77902: LD_INT 1
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: EMPTY
77910: LIST
77911: LIST
77912: LIST
77913: PPUSH
77914: CALL_OW 72
77918: ST_TO_ADDR
77919: GO 78107
77921: LD_INT 3
77923: DOUBLE
77924: EQUAL
77925: IFTRUE 77929
77927: GO 77975
77929: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77930: LD_ADDR_VAR 0 8
77934: PUSH
77935: LD_VAR 0 2
77939: PPUSH
77940: LD_INT 2
77942: PUSH
77943: LD_INT 30
77945: PUSH
77946: LD_INT 2
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: PUSH
77953: LD_INT 30
77955: PUSH
77956: LD_INT 3
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: LIST
77967: PPUSH
77968: CALL_OW 72
77972: ST_TO_ADDR
77973: GO 78107
77975: LD_INT 4
77977: DOUBLE
77978: EQUAL
77979: IFTRUE 77983
77981: GO 78040
77983: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77984: LD_ADDR_VAR 0 8
77988: PUSH
77989: LD_VAR 0 2
77993: PPUSH
77994: LD_INT 2
77996: PUSH
77997: LD_INT 30
77999: PUSH
78000: LD_INT 6
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: LD_INT 30
78009: PUSH
78010: LD_INT 7
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: LD_INT 30
78019: PUSH
78020: LD_INT 8
78022: PUSH
78023: EMPTY
78024: LIST
78025: LIST
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: LIST
78031: LIST
78032: PPUSH
78033: CALL_OW 72
78037: ST_TO_ADDR
78038: GO 78107
78040: LD_INT 5
78042: DOUBLE
78043: EQUAL
78044: IFTRUE 78060
78046: LD_INT 8
78048: DOUBLE
78049: EQUAL
78050: IFTRUE 78060
78052: LD_INT 9
78054: DOUBLE
78055: EQUAL
78056: IFTRUE 78060
78058: GO 78106
78060: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78061: LD_ADDR_VAR 0 8
78065: PUSH
78066: LD_VAR 0 2
78070: PPUSH
78071: LD_INT 2
78073: PUSH
78074: LD_INT 30
78076: PUSH
78077: LD_INT 4
78079: PUSH
78080: EMPTY
78081: LIST
78082: LIST
78083: PUSH
78084: LD_INT 30
78086: PUSH
78087: LD_INT 5
78089: PUSH
78090: EMPTY
78091: LIST
78092: LIST
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: LIST
78098: PPUSH
78099: CALL_OW 72
78103: ST_TO_ADDR
78104: GO 78107
78106: POP
// if not tmp then
78107: LD_VAR 0 8
78111: NOT
78112: IFFALSE 78116
// exit ;
78114: GO 78578
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78116: LD_VAR 0 4
78120: PUSH
78121: LD_INT 1
78123: PUSH
78124: LD_INT 15
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: IN
78131: IFFALSE 78145
78133: PUSH
78134: LD_EXP 32
78138: PUSH
78139: LD_VAR 0 1
78143: ARRAY
78144: AND
78145: IFFALSE 78301
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78147: LD_ADDR_VAR 0 9
78151: PUSH
78152: LD_EXP 32
78156: PUSH
78157: LD_VAR 0 1
78161: ARRAY
78162: PUSH
78163: LD_INT 1
78165: ARRAY
78166: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78167: LD_VAR 0 9
78171: PUSH
78172: LD_EXP 33
78176: PUSH
78177: LD_VAR 0 1
78181: ARRAY
78182: IN
78183: NOT
78184: IFFALSE 78299
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78186: LD_ADDR_EXP 33
78190: PUSH
78191: LD_EXP 33
78195: PPUSH
78196: LD_VAR 0 1
78200: PUSH
78201: LD_EXP 33
78205: PUSH
78206: LD_VAR 0 1
78210: ARRAY
78211: PUSH
78212: LD_INT 1
78214: PLUS
78215: PUSH
78216: EMPTY
78217: LIST
78218: LIST
78219: PPUSH
78220: LD_VAR 0 9
78224: PPUSH
78225: CALL 16289 0 3
78229: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78230: LD_ADDR_EXP 32
78234: PUSH
78235: LD_EXP 32
78239: PPUSH
78240: LD_VAR 0 1
78244: PPUSH
78245: LD_EXP 32
78249: PUSH
78250: LD_VAR 0 1
78254: ARRAY
78255: PUSH
78256: LD_VAR 0 9
78260: DIFF
78261: PPUSH
78262: CALL_OW 1
78266: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78267: LD_VAR 0 3
78271: PPUSH
78272: LD_EXP 33
78276: PUSH
78277: LD_VAR 0 1
78281: ARRAY
78282: PUSH
78283: LD_EXP 33
78287: PUSH
78288: LD_VAR 0 1
78292: ARRAY
78293: ARRAY
78294: PPUSH
78295: CALL_OW 120
// end ; exit ;
78299: GO 78578
// end ; if tmp > 1 then
78301: LD_VAR 0 8
78305: PUSH
78306: LD_INT 1
78308: GREATER
78309: IFFALSE 78413
// for i = 2 to tmp do
78311: LD_ADDR_VAR 0 6
78315: PUSH
78316: DOUBLE
78317: LD_INT 2
78319: DEC
78320: ST_TO_ADDR
78321: LD_VAR 0 8
78325: PUSH
78326: FOR_TO
78327: IFFALSE 78411
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78329: LD_VAR 0 8
78333: PUSH
78334: LD_VAR 0 6
78338: ARRAY
78339: PPUSH
78340: CALL_OW 461
78344: PUSH
78345: LD_INT 6
78347: EQUAL
78348: IFFALSE 78409
// begin x := tmp [ i ] ;
78350: LD_ADDR_VAR 0 9
78354: PUSH
78355: LD_VAR 0 8
78359: PUSH
78360: LD_VAR 0 6
78364: ARRAY
78365: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78366: LD_ADDR_VAR 0 8
78370: PUSH
78371: LD_VAR 0 8
78375: PPUSH
78376: LD_VAR 0 6
78380: PPUSH
78381: CALL_OW 3
78385: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78386: LD_ADDR_VAR 0 8
78390: PUSH
78391: LD_VAR 0 8
78395: PPUSH
78396: LD_INT 1
78398: PPUSH
78399: LD_VAR 0 9
78403: PPUSH
78404: CALL_OW 2
78408: ST_TO_ADDR
// end ;
78409: GO 78326
78411: POP
78412: POP
// for i in tmp do
78413: LD_ADDR_VAR 0 6
78417: PUSH
78418: LD_VAR 0 8
78422: PUSH
78423: FOR_IN
78424: IFFALSE 78451
// begin if IsNotFull ( i ) then
78426: LD_VAR 0 6
78430: PPUSH
78431: CALL 13453 0 1
78435: IFFALSE 78449
// begin j := i ;
78437: LD_ADDR_VAR 0 7
78441: PUSH
78442: LD_VAR 0 6
78446: ST_TO_ADDR
// break ;
78447: GO 78451
// end ; end ;
78449: GO 78423
78451: POP
78452: POP
// if j then
78453: LD_VAR 0 7
78457: IFFALSE 78475
// ComEnterUnit ( unit , j ) else
78459: LD_VAR 0 3
78463: PPUSH
78464: LD_VAR 0 7
78468: PPUSH
78469: CALL_OW 120
78473: GO 78578
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78475: LD_ADDR_VAR 0 10
78479: PUSH
78480: LD_VAR 0 2
78484: PPUSH
78485: LD_INT 2
78487: PUSH
78488: LD_INT 30
78490: PUSH
78491: LD_INT 0
78493: PUSH
78494: EMPTY
78495: LIST
78496: LIST
78497: PUSH
78498: LD_INT 30
78500: PUSH
78501: LD_INT 1
78503: PUSH
78504: EMPTY
78505: LIST
78506: LIST
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: LIST
78512: PPUSH
78513: CALL_OW 72
78517: ST_TO_ADDR
// if depot then
78518: LD_VAR 0 10
78522: IFFALSE 78578
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78524: LD_ADDR_VAR 0 10
78528: PUSH
78529: LD_VAR 0 10
78533: PPUSH
78534: LD_VAR 0 3
78538: PPUSH
78539: CALL_OW 74
78543: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78544: LD_VAR 0 3
78548: PPUSH
78549: LD_VAR 0 10
78553: PPUSH
78554: CALL_OW 296
78558: PUSH
78559: LD_INT 10
78561: GREATER
78562: IFFALSE 78578
// ComStandNearbyBuilding ( unit , depot ) ;
78564: LD_VAR 0 3
78568: PPUSH
78569: LD_VAR 0 10
78573: PPUSH
78574: CALL 12831 0 2
// end ; end ; end ;
78578: LD_VAR 0 5
78582: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78583: LD_INT 0
78585: PPUSH
78586: PPUSH
78587: PPUSH
78588: PPUSH
// if not mc_bases then
78589: LD_EXP 23
78593: NOT
78594: IFFALSE 78598
// exit ;
78596: GO 78849
// for i = 1 to mc_bases do
78598: LD_ADDR_VAR 0 2
78602: PUSH
78603: DOUBLE
78604: LD_INT 1
78606: DEC
78607: ST_TO_ADDR
78608: LD_EXP 23
78612: PUSH
78613: FOR_TO
78614: IFFALSE 78847
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78616: LD_ADDR_VAR 0 4
78620: PUSH
78621: LD_EXP 23
78625: PUSH
78626: LD_VAR 0 2
78630: ARRAY
78631: PPUSH
78632: LD_INT 21
78634: PUSH
78635: LD_INT 1
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PPUSH
78642: CALL_OW 72
78646: PUSH
78647: LD_EXP 52
78651: PUSH
78652: LD_VAR 0 2
78656: ARRAY
78657: UNION
78658: ST_TO_ADDR
// if not tmp then
78659: LD_VAR 0 4
78663: NOT
78664: IFFALSE 78668
// continue ;
78666: GO 78613
// for j in tmp do
78668: LD_ADDR_VAR 0 3
78672: PUSH
78673: LD_VAR 0 4
78677: PUSH
78678: FOR_IN
78679: IFFALSE 78843
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78681: LD_VAR 0 3
78685: PPUSH
78686: CALL_OW 110
78690: NOT
78691: IFFALSE 78705
78693: PUSH
78694: LD_VAR 0 3
78698: PPUSH
78699: CALL_OW 314
78703: NOT
78704: AND
78705: IFFALSE 78719
78707: PUSH
78708: LD_VAR 0 3
78712: PPUSH
78713: CALL_OW 311
78717: NOT
78718: AND
78719: IFFALSE 78733
78721: PUSH
78722: LD_VAR 0 3
78726: PPUSH
78727: CALL_OW 310
78731: NOT
78732: AND
78733: IFFALSE 78758
78735: PUSH
78736: LD_VAR 0 3
78740: PUSH
78741: LD_EXP 26
78745: PUSH
78746: LD_VAR 0 2
78750: ARRAY
78751: PUSH
78752: LD_INT 1
78754: ARRAY
78755: IN
78756: NOT
78757: AND
78758: IFFALSE 78783
78760: PUSH
78761: LD_VAR 0 3
78765: PUSH
78766: LD_EXP 26
78770: PUSH
78771: LD_VAR 0 2
78775: ARRAY
78776: PUSH
78777: LD_INT 2
78779: ARRAY
78780: IN
78781: NOT
78782: AND
78783: IFFALSE 78804
78785: PUSH
78786: LD_VAR 0 3
78790: PUSH
78791: LD_EXP 35
78795: PUSH
78796: LD_VAR 0 2
78800: ARRAY
78801: IN
78802: NOT
78803: AND
78804: IFFALSE 78841
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78806: LD_VAR 0 2
78810: PPUSH
78811: LD_EXP 23
78815: PUSH
78816: LD_VAR 0 2
78820: ARRAY
78821: PPUSH
78822: LD_VAR 0 3
78826: PPUSH
78827: LD_VAR 0 3
78831: PPUSH
78832: CALL_OW 257
78836: PPUSH
78837: CALL 77635 0 4
// end ;
78841: GO 78678
78843: POP
78844: POP
// end ;
78845: GO 78613
78847: POP
78848: POP
// end ;
78849: LD_VAR 0 1
78853: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
78854: LD_INT 0
78856: PPUSH
78857: PPUSH
78858: PPUSH
78859: PPUSH
78860: PPUSH
78861: PPUSH
// if not mc_bases [ base ] then
78862: LD_EXP 23
78866: PUSH
78867: LD_VAR 0 1
78871: ARRAY
78872: NOT
78873: IFFALSE 78877
// exit ;
78875: GO 79078
// tmp := [ ] ;
78877: LD_ADDR_VAR 0 6
78881: PUSH
78882: EMPTY
78883: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78884: LD_ADDR_VAR 0 7
78888: PUSH
78889: LD_VAR 0 3
78893: PPUSH
78894: LD_INT 0
78896: PPUSH
78897: CALL_OW 517
78901: ST_TO_ADDR
// if not list then
78902: LD_VAR 0 7
78906: NOT
78907: IFFALSE 78911
// exit ;
78909: GO 79078
// c := Count ( list [ 1 ] ) ;
78911: LD_ADDR_VAR 0 9
78915: PUSH
78916: LD_VAR 0 7
78920: PUSH
78921: LD_INT 1
78923: ARRAY
78924: PPUSH
78925: CALL 13371 0 1
78929: ST_TO_ADDR
// if amount > c then
78930: LD_VAR 0 2
78934: PUSH
78935: LD_VAR 0 9
78939: GREATER
78940: IFFALSE 78952
// amount := c ;
78942: LD_ADDR_VAR 0 2
78946: PUSH
78947: LD_VAR 0 9
78951: ST_TO_ADDR
// for i := 1 to amount do
78952: LD_ADDR_VAR 0 5
78956: PUSH
78957: DOUBLE
78958: LD_INT 1
78960: DEC
78961: ST_TO_ADDR
78962: LD_VAR 0 2
78966: PUSH
78967: FOR_TO
78968: IFFALSE 79026
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
78970: LD_ADDR_VAR 0 6
78974: PUSH
78975: LD_VAR 0 6
78979: PPUSH
78980: LD_VAR 0 5
78984: PPUSH
78985: LD_VAR 0 7
78989: PUSH
78990: LD_INT 1
78992: ARRAY
78993: PUSH
78994: LD_VAR 0 5
78998: ARRAY
78999: PUSH
79000: LD_VAR 0 7
79004: PUSH
79005: LD_INT 2
79007: ARRAY
79008: PUSH
79009: LD_VAR 0 5
79013: ARRAY
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: PPUSH
79019: CALL_OW 1
79023: ST_TO_ADDR
79024: GO 78967
79026: POP
79027: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79028: LD_ADDR_EXP 36
79032: PUSH
79033: LD_EXP 36
79037: PPUSH
79038: LD_VAR 0 1
79042: PPUSH
79043: LD_VAR 0 6
79047: PPUSH
79048: CALL_OW 1
79052: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79053: LD_ADDR_EXP 38
79057: PUSH
79058: LD_EXP 38
79062: PPUSH
79063: LD_VAR 0 1
79067: PPUSH
79068: LD_VAR 0 3
79072: PPUSH
79073: CALL_OW 1
79077: ST_TO_ADDR
// end ;
79078: LD_VAR 0 4
79082: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79083: LD_INT 0
79085: PPUSH
// if not mc_bases [ base ] then
79086: LD_EXP 23
79090: PUSH
79091: LD_VAR 0 1
79095: ARRAY
79096: NOT
79097: IFFALSE 79101
// exit ;
79099: GO 79126
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79101: LD_ADDR_EXP 28
79105: PUSH
79106: LD_EXP 28
79110: PPUSH
79111: LD_VAR 0 1
79115: PPUSH
79116: LD_VAR 0 2
79120: PPUSH
79121: CALL_OW 1
79125: ST_TO_ADDR
// end ;
79126: LD_VAR 0 3
79130: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79131: LD_INT 0
79133: PPUSH
// if not mc_bases [ base ] then
79134: LD_EXP 23
79138: PUSH
79139: LD_VAR 0 1
79143: ARRAY
79144: NOT
79145: IFFALSE 79149
// exit ;
79147: GO 79186
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79149: LD_ADDR_EXP 28
79153: PUSH
79154: LD_EXP 28
79158: PPUSH
79159: LD_VAR 0 1
79163: PPUSH
79164: LD_EXP 28
79168: PUSH
79169: LD_VAR 0 1
79173: ARRAY
79174: PUSH
79175: LD_VAR 0 2
79179: UNION
79180: PPUSH
79181: CALL_OW 1
79185: ST_TO_ADDR
// end ;
79186: LD_VAR 0 3
79190: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79191: LD_INT 0
79193: PPUSH
// if not mc_bases [ base ] then
79194: LD_EXP 23
79198: PUSH
79199: LD_VAR 0 1
79203: ARRAY
79204: NOT
79205: IFFALSE 79209
// exit ;
79207: GO 79234
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79209: LD_ADDR_EXP 44
79213: PUSH
79214: LD_EXP 44
79218: PPUSH
79219: LD_VAR 0 1
79223: PPUSH
79224: LD_VAR 0 2
79228: PPUSH
79229: CALL_OW 1
79233: ST_TO_ADDR
// end ;
79234: LD_VAR 0 3
79238: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79239: LD_INT 0
79241: PPUSH
// if not mc_bases [ base ] then
79242: LD_EXP 23
79246: PUSH
79247: LD_VAR 0 1
79251: ARRAY
79252: NOT
79253: IFFALSE 79257
// exit ;
79255: GO 79294
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79257: LD_ADDR_EXP 44
79261: PUSH
79262: LD_EXP 44
79266: PPUSH
79267: LD_VAR 0 1
79271: PPUSH
79272: LD_EXP 44
79276: PUSH
79277: LD_VAR 0 1
79281: ARRAY
79282: PUSH
79283: LD_VAR 0 2
79287: ADD
79288: PPUSH
79289: CALL_OW 1
79293: ST_TO_ADDR
// end ;
79294: LD_VAR 0 3
79298: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79299: LD_INT 0
79301: PPUSH
// if not mc_bases [ base ] then
79302: LD_EXP 23
79306: PUSH
79307: LD_VAR 0 1
79311: ARRAY
79312: NOT
79313: IFFALSE 79317
// exit ;
79315: GO 79371
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79317: LD_ADDR_EXP 45
79321: PUSH
79322: LD_EXP 45
79326: PPUSH
79327: LD_VAR 0 1
79331: PPUSH
79332: LD_VAR 0 2
79336: PPUSH
79337: CALL_OW 1
79341: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79342: LD_ADDR_EXP 34
79346: PUSH
79347: LD_EXP 34
79351: PPUSH
79352: LD_VAR 0 1
79356: PPUSH
79357: LD_VAR 0 2
79361: PUSH
79362: LD_INT 0
79364: PLUS
79365: PPUSH
79366: CALL_OW 1
79370: ST_TO_ADDR
// end ;
79371: LD_VAR 0 3
79375: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79376: LD_INT 0
79378: PPUSH
// if not mc_bases [ base ] then
79379: LD_EXP 23
79383: PUSH
79384: LD_VAR 0 1
79388: ARRAY
79389: NOT
79390: IFFALSE 79394
// exit ;
79392: GO 79419
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79394: LD_ADDR_EXP 34
79398: PUSH
79399: LD_EXP 34
79403: PPUSH
79404: LD_VAR 0 1
79408: PPUSH
79409: LD_VAR 0 2
79413: PPUSH
79414: CALL_OW 1
79418: ST_TO_ADDR
// end ;
79419: LD_VAR 0 3
79423: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79424: LD_INT 0
79426: PPUSH
79427: PPUSH
79428: PPUSH
79429: PPUSH
// if not mc_bases [ base ] then
79430: LD_EXP 23
79434: PUSH
79435: LD_VAR 0 1
79439: ARRAY
79440: NOT
79441: IFFALSE 79445
// exit ;
79443: GO 79510
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79445: LD_ADDR_EXP 43
79449: PUSH
79450: LD_EXP 43
79454: PPUSH
79455: LD_VAR 0 1
79459: PUSH
79460: LD_EXP 43
79464: PUSH
79465: LD_VAR 0 1
79469: ARRAY
79470: PUSH
79471: LD_INT 1
79473: PLUS
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PPUSH
79479: LD_VAR 0 1
79483: PUSH
79484: LD_VAR 0 2
79488: PUSH
79489: LD_VAR 0 3
79493: PUSH
79494: LD_VAR 0 4
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: LIST
79503: LIST
79504: PPUSH
79505: CALL 16289 0 3
79509: ST_TO_ADDR
// end ;
79510: LD_VAR 0 5
79514: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79515: LD_INT 0
79517: PPUSH
// if not mc_bases [ base ] then
79518: LD_EXP 23
79522: PUSH
79523: LD_VAR 0 1
79527: ARRAY
79528: NOT
79529: IFFALSE 79533
// exit ;
79531: GO 79558
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79533: LD_ADDR_EXP 60
79537: PUSH
79538: LD_EXP 60
79542: PPUSH
79543: LD_VAR 0 1
79547: PPUSH
79548: LD_VAR 0 2
79552: PPUSH
79553: CALL_OW 1
79557: ST_TO_ADDR
// end ;
79558: LD_VAR 0 3
79562: RET
// export function MC_GetMinesField ( base ) ; begin
79563: LD_INT 0
79565: PPUSH
// result := mc_mines [ base ] ;
79566: LD_ADDR_VAR 0 2
79570: PUSH
79571: LD_EXP 36
79575: PUSH
79576: LD_VAR 0 1
79580: ARRAY
79581: ST_TO_ADDR
// end ;
79582: LD_VAR 0 2
79586: RET
// export function MC_GetProduceList ( base ) ; begin
79587: LD_INT 0
79589: PPUSH
// result := mc_produce [ base ] ;
79590: LD_ADDR_VAR 0 2
79594: PUSH
79595: LD_EXP 44
79599: PUSH
79600: LD_VAR 0 1
79604: ARRAY
79605: ST_TO_ADDR
// end ;
79606: LD_VAR 0 2
79610: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79611: LD_INT 0
79613: PPUSH
79614: PPUSH
// if not mc_bases then
79615: LD_EXP 23
79619: NOT
79620: IFFALSE 79624
// exit ;
79622: GO 79689
// if mc_bases [ base ] then
79624: LD_EXP 23
79628: PUSH
79629: LD_VAR 0 1
79633: ARRAY
79634: IFFALSE 79689
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79636: LD_ADDR_VAR 0 3
79640: PUSH
79641: LD_EXP 23
79645: PUSH
79646: LD_VAR 0 1
79650: ARRAY
79651: PPUSH
79652: LD_INT 30
79654: PUSH
79655: LD_VAR 0 2
79659: PUSH
79660: EMPTY
79661: LIST
79662: LIST
79663: PPUSH
79664: CALL_OW 72
79668: ST_TO_ADDR
// if result then
79669: LD_VAR 0 3
79673: IFFALSE 79689
// result := result [ 1 ] ;
79675: LD_ADDR_VAR 0 3
79679: PUSH
79680: LD_VAR 0 3
79684: PUSH
79685: LD_INT 1
79687: ARRAY
79688: ST_TO_ADDR
// end ; end ;
79689: LD_VAR 0 3
79693: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79694: LD_INT 0
79696: PPUSH
79697: PPUSH
// if not mc_bases then
79698: LD_EXP 23
79702: NOT
79703: IFFALSE 79707
// exit ;
79705: GO 79752
// if mc_bases [ base ] then
79707: LD_EXP 23
79711: PUSH
79712: LD_VAR 0 1
79716: ARRAY
79717: IFFALSE 79752
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79719: LD_ADDR_VAR 0 3
79723: PUSH
79724: LD_EXP 23
79728: PUSH
79729: LD_VAR 0 1
79733: ARRAY
79734: PPUSH
79735: LD_INT 30
79737: PUSH
79738: LD_VAR 0 2
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PPUSH
79747: CALL_OW 72
79751: ST_TO_ADDR
// end ;
79752: LD_VAR 0 3
79756: RET
// export function MC_SetTame ( base , area ) ; begin
79757: LD_INT 0
79759: PPUSH
// if not mc_bases or not base then
79760: LD_EXP 23
79764: NOT
79765: IFTRUE 79774
79767: PUSH
79768: LD_VAR 0 1
79772: NOT
79773: OR
79774: IFFALSE 79778
// exit ;
79776: GO 79803
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79778: LD_ADDR_EXP 51
79782: PUSH
79783: LD_EXP 51
79787: PPUSH
79788: LD_VAR 0 1
79792: PPUSH
79793: LD_VAR 0 2
79797: PPUSH
79798: CALL_OW 1
79802: ST_TO_ADDR
// end ;
79803: LD_VAR 0 3
79807: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79808: LD_INT 0
79810: PPUSH
79811: PPUSH
// if not mc_bases or not base then
79812: LD_EXP 23
79816: NOT
79817: IFTRUE 79826
79819: PUSH
79820: LD_VAR 0 1
79824: NOT
79825: OR
79826: IFFALSE 79830
// exit ;
79828: GO 79932
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79830: LD_ADDR_VAR 0 4
79834: PUSH
79835: LD_EXP 23
79839: PUSH
79840: LD_VAR 0 1
79844: ARRAY
79845: PPUSH
79846: LD_INT 30
79848: PUSH
79849: LD_VAR 0 2
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PPUSH
79858: CALL_OW 72
79862: ST_TO_ADDR
// if not tmp then
79863: LD_VAR 0 4
79867: NOT
79868: IFFALSE 79872
// exit ;
79870: GO 79932
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79872: LD_ADDR_EXP 55
79876: PUSH
79877: LD_EXP 55
79881: PPUSH
79882: LD_VAR 0 1
79886: PPUSH
79887: LD_EXP 55
79891: PUSH
79892: LD_VAR 0 1
79896: ARRAY
79897: PPUSH
79898: LD_EXP 55
79902: PUSH
79903: LD_VAR 0 1
79907: ARRAY
79908: PUSH
79909: LD_INT 1
79911: PLUS
79912: PPUSH
79913: LD_VAR 0 4
79917: PUSH
79918: LD_INT 1
79920: ARRAY
79921: PPUSH
79922: CALL_OW 2
79926: PPUSH
79927: CALL_OW 1
79931: ST_TO_ADDR
// end ;
79932: LD_VAR 0 3
79936: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79937: LD_INT 0
79939: PPUSH
79940: PPUSH
// if not mc_bases or not base or not kinds then
79941: LD_EXP 23
79945: NOT
79946: IFTRUE 79955
79948: PUSH
79949: LD_VAR 0 1
79953: NOT
79954: OR
79955: IFTRUE 79964
79957: PUSH
79958: LD_VAR 0 2
79962: NOT
79963: OR
79964: IFFALSE 79968
// exit ;
79966: GO 80029
// for i in kinds do
79968: LD_ADDR_VAR 0 4
79972: PUSH
79973: LD_VAR 0 2
79977: PUSH
79978: FOR_IN
79979: IFFALSE 80027
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79981: LD_ADDR_EXP 57
79985: PUSH
79986: LD_EXP 57
79990: PPUSH
79991: LD_VAR 0 1
79995: PUSH
79996: LD_EXP 57
80000: PUSH
80001: LD_VAR 0 1
80005: ARRAY
80006: PUSH
80007: LD_INT 1
80009: PLUS
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PPUSH
80015: LD_VAR 0 4
80019: PPUSH
80020: CALL 16289 0 3
80024: ST_TO_ADDR
80025: GO 79978
80027: POP
80028: POP
// end ;
80029: LD_VAR 0 3
80033: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80034: LD_INT 0
80036: PPUSH
// if not mc_bases or not base or not areas then
80037: LD_EXP 23
80041: NOT
80042: IFTRUE 80051
80044: PUSH
80045: LD_VAR 0 1
80049: NOT
80050: OR
80051: IFTRUE 80060
80053: PUSH
80054: LD_VAR 0 2
80058: NOT
80059: OR
80060: IFFALSE 80064
// exit ;
80062: GO 80089
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80064: LD_ADDR_EXP 41
80068: PUSH
80069: LD_EXP 41
80073: PPUSH
80074: LD_VAR 0 1
80078: PPUSH
80079: LD_VAR 0 2
80083: PPUSH
80084: CALL_OW 1
80088: ST_TO_ADDR
// end ;
80089: LD_VAR 0 3
80093: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80094: LD_INT 0
80096: PPUSH
// if not mc_bases or not base or not teleports_exit then
80097: LD_EXP 23
80101: NOT
80102: IFTRUE 80111
80104: PUSH
80105: LD_VAR 0 1
80109: NOT
80110: OR
80111: IFTRUE 80120
80113: PUSH
80114: LD_VAR 0 2
80118: NOT
80119: OR
80120: IFFALSE 80124
// exit ;
80122: GO 80149
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80124: LD_ADDR_EXP 58
80128: PUSH
80129: LD_EXP 58
80133: PPUSH
80134: LD_VAR 0 1
80138: PPUSH
80139: LD_VAR 0 2
80143: PPUSH
80144: CALL_OW 1
80148: ST_TO_ADDR
// end ;
80149: LD_VAR 0 3
80153: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80154: LD_INT 0
80156: PPUSH
80157: PPUSH
80158: PPUSH
// if not mc_bases or not base or not ext_list then
80159: LD_EXP 23
80163: NOT
80164: IFTRUE 80173
80166: PUSH
80167: LD_VAR 0 1
80171: NOT
80172: OR
80173: IFTRUE 80182
80175: PUSH
80176: LD_VAR 0 5
80180: NOT
80181: OR
80182: IFFALSE 80186
// exit ;
80184: GO 80359
// tmp := GetFacExtXYD ( x , y , d ) ;
80186: LD_ADDR_VAR 0 8
80190: PUSH
80191: LD_VAR 0 2
80195: PPUSH
80196: LD_VAR 0 3
80200: PPUSH
80201: LD_VAR 0 4
80205: PPUSH
80206: CALL 46957 0 3
80210: ST_TO_ADDR
// if not tmp then
80211: LD_VAR 0 8
80215: NOT
80216: IFFALSE 80220
// exit ;
80218: GO 80359
// for i in tmp do
80220: LD_ADDR_VAR 0 7
80224: PUSH
80225: LD_VAR 0 8
80229: PUSH
80230: FOR_IN
80231: IFFALSE 80357
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80233: LD_ADDR_EXP 28
80237: PUSH
80238: LD_EXP 28
80242: PPUSH
80243: LD_VAR 0 1
80247: PPUSH
80248: LD_EXP 28
80252: PUSH
80253: LD_VAR 0 1
80257: ARRAY
80258: PPUSH
80259: LD_EXP 28
80263: PUSH
80264: LD_VAR 0 1
80268: ARRAY
80269: PUSH
80270: LD_INT 1
80272: PLUS
80273: PPUSH
80274: LD_VAR 0 5
80278: PUSH
80279: LD_INT 1
80281: ARRAY
80282: PUSH
80283: LD_VAR 0 7
80287: PUSH
80288: LD_INT 1
80290: ARRAY
80291: PUSH
80292: LD_VAR 0 7
80296: PUSH
80297: LD_INT 2
80299: ARRAY
80300: PUSH
80301: LD_VAR 0 7
80305: PUSH
80306: LD_INT 3
80308: ARRAY
80309: PUSH
80310: EMPTY
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: PPUSH
80316: CALL_OW 2
80320: PPUSH
80321: CALL_OW 1
80325: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80326: LD_ADDR_VAR 0 5
80330: PUSH
80331: LD_VAR 0 5
80335: PPUSH
80336: LD_INT 1
80338: PPUSH
80339: CALL_OW 3
80343: ST_TO_ADDR
// if not ext_list then
80344: LD_VAR 0 5
80348: NOT
80349: IFFALSE 80355
// exit ;
80351: POP
80352: POP
80353: GO 80359
// end ;
80355: GO 80230
80357: POP
80358: POP
// end ;
80359: LD_VAR 0 6
80363: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80364: LD_INT 0
80366: PPUSH
// if not mc_bases or not base or not weapon_list then
80367: LD_EXP 23
80371: NOT
80372: IFTRUE 80381
80374: PUSH
80375: LD_VAR 0 1
80379: NOT
80380: OR
80381: IFTRUE 80390
80383: PUSH
80384: LD_VAR 0 2
80388: NOT
80389: OR
80390: IFFALSE 80394
// exit ;
80392: GO 80419
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80394: LD_ADDR_EXP 62
80398: PUSH
80399: LD_EXP 62
80403: PPUSH
80404: LD_VAR 0 1
80408: PPUSH
80409: LD_VAR 0 2
80413: PPUSH
80414: CALL_OW 1
80418: ST_TO_ADDR
// end ;
80419: LD_VAR 0 3
80423: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80424: LD_INT 0
80426: PPUSH
// if not mc_bases or not base or not tech_list then
80427: LD_EXP 23
80431: NOT
80432: IFTRUE 80441
80434: PUSH
80435: LD_VAR 0 1
80439: NOT
80440: OR
80441: IFTRUE 80450
80443: PUSH
80444: LD_VAR 0 2
80448: NOT
80449: OR
80450: IFFALSE 80454
// exit ;
80452: GO 80479
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80454: LD_ADDR_EXP 50
80458: PUSH
80459: LD_EXP 50
80463: PPUSH
80464: LD_VAR 0 1
80468: PPUSH
80469: LD_VAR 0 2
80473: PPUSH
80474: CALL_OW 1
80478: ST_TO_ADDR
// end ;
80479: LD_VAR 0 3
80483: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80484: LD_INT 0
80486: PPUSH
// if not mc_bases or not parking_area or not base then
80487: LD_EXP 23
80491: NOT
80492: IFTRUE 80501
80494: PUSH
80495: LD_VAR 0 2
80499: NOT
80500: OR
80501: IFTRUE 80510
80503: PUSH
80504: LD_VAR 0 1
80508: NOT
80509: OR
80510: IFFALSE 80514
// exit ;
80512: GO 80539
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80514: LD_ADDR_EXP 47
80518: PUSH
80519: LD_EXP 47
80523: PPUSH
80524: LD_VAR 0 1
80528: PPUSH
80529: LD_VAR 0 2
80533: PPUSH
80534: CALL_OW 1
80538: ST_TO_ADDR
// end ;
80539: LD_VAR 0 3
80543: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80544: LD_INT 0
80546: PPUSH
// if not mc_bases or not base or not scan_area then
80547: LD_EXP 23
80551: NOT
80552: IFTRUE 80561
80554: PUSH
80555: LD_VAR 0 1
80559: NOT
80560: OR
80561: IFTRUE 80570
80563: PUSH
80564: LD_VAR 0 2
80568: NOT
80569: OR
80570: IFFALSE 80574
// exit ;
80572: GO 80599
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80574: LD_ADDR_EXP 48
80578: PUSH
80579: LD_EXP 48
80583: PPUSH
80584: LD_VAR 0 1
80588: PPUSH
80589: LD_VAR 0 2
80593: PPUSH
80594: CALL_OW 1
80598: ST_TO_ADDR
// end ;
80599: LD_VAR 0 3
80603: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80604: LD_INT 0
80606: PPUSH
80607: PPUSH
// if not mc_bases or not base then
80608: LD_EXP 23
80612: NOT
80613: IFTRUE 80622
80615: PUSH
80616: LD_VAR 0 1
80620: NOT
80621: OR
80622: IFFALSE 80626
// exit ;
80624: GO 80690
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80626: LD_ADDR_VAR 0 3
80630: PUSH
80631: LD_INT 1
80633: PUSH
80634: LD_INT 2
80636: PUSH
80637: LD_INT 3
80639: PUSH
80640: LD_INT 4
80642: PUSH
80643: LD_INT 11
80645: PUSH
80646: EMPTY
80647: LIST
80648: LIST
80649: LIST
80650: LIST
80651: LIST
80652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80653: LD_ADDR_EXP 50
80657: PUSH
80658: LD_EXP 50
80662: PPUSH
80663: LD_VAR 0 1
80667: PPUSH
80668: LD_EXP 50
80672: PUSH
80673: LD_VAR 0 1
80677: ARRAY
80678: PUSH
80679: LD_VAR 0 3
80683: DIFF
80684: PPUSH
80685: CALL_OW 1
80689: ST_TO_ADDR
// end ;
80690: LD_VAR 0 2
80694: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80695: LD_INT 0
80697: PPUSH
// result := mc_vehicles [ base ] ;
80698: LD_ADDR_VAR 0 3
80702: PUSH
80703: LD_EXP 42
80707: PUSH
80708: LD_VAR 0 1
80712: ARRAY
80713: ST_TO_ADDR
// if onlyCombat then
80714: LD_VAR 0 2
80718: IFFALSE 80890
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80720: LD_ADDR_VAR 0 3
80724: PUSH
80725: LD_VAR 0 3
80729: PUSH
80730: LD_VAR 0 3
80734: PPUSH
80735: LD_INT 2
80737: PUSH
80738: LD_INT 34
80740: PUSH
80741: LD_INT 12
80743: PUSH
80744: EMPTY
80745: LIST
80746: LIST
80747: PUSH
80748: LD_INT 34
80750: PUSH
80751: LD_INT 51
80753: PUSH
80754: EMPTY
80755: LIST
80756: LIST
80757: PUSH
80758: LD_INT 34
80760: PUSH
80761: LD_INT 89
80763: PUSH
80764: EMPTY
80765: LIST
80766: LIST
80767: PUSH
80768: LD_INT 34
80770: PUSH
80771: LD_INT 32
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 34
80780: PUSH
80781: LD_INT 13
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 34
80790: PUSH
80791: LD_INT 52
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 34
80800: PUSH
80801: LD_INT 88
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 34
80810: PUSH
80811: LD_INT 14
80813: PUSH
80814: EMPTY
80815: LIST
80816: LIST
80817: PUSH
80818: LD_INT 34
80820: PUSH
80821: LD_INT 53
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: PUSH
80828: LD_INT 34
80830: PUSH
80831: LD_INT 98
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 34
80840: PUSH
80841: LD_INT 31
80843: PUSH
80844: EMPTY
80845: LIST
80846: LIST
80847: PUSH
80848: LD_INT 34
80850: PUSH
80851: LD_INT 48
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 34
80860: PUSH
80861: LD_INT 8
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: LIST
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: LIST
80877: LIST
80878: LIST
80879: LIST
80880: LIST
80881: LIST
80882: LIST
80883: PPUSH
80884: CALL_OW 72
80888: DIFF
80889: ST_TO_ADDR
// end ; end_of_file
80890: LD_VAR 0 3
80894: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80895: LD_INT 0
80897: PPUSH
80898: PPUSH
80899: PPUSH
// if not mc_bases or not skirmish then
80900: LD_EXP 23
80904: NOT
80905: IFTRUE 80914
80907: PUSH
80908: LD_EXP 21
80912: NOT
80913: OR
80914: IFFALSE 80918
// exit ;
80916: GO 81083
// for i = 1 to mc_bases do
80918: LD_ADDR_VAR 0 4
80922: PUSH
80923: DOUBLE
80924: LD_INT 1
80926: DEC
80927: ST_TO_ADDR
80928: LD_EXP 23
80932: PUSH
80933: FOR_TO
80934: IFFALSE 81081
// begin if sci in mc_bases [ i ] then
80936: LD_VAR 0 2
80940: PUSH
80941: LD_EXP 23
80945: PUSH
80946: LD_VAR 0 4
80950: ARRAY
80951: IN
80952: IFFALSE 81079
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80954: LD_ADDR_EXP 52
80958: PUSH
80959: LD_EXP 52
80963: PPUSH
80964: LD_VAR 0 4
80968: PUSH
80969: LD_EXP 52
80973: PUSH
80974: LD_VAR 0 4
80978: ARRAY
80979: PUSH
80980: LD_INT 1
80982: PLUS
80983: PUSH
80984: EMPTY
80985: LIST
80986: LIST
80987: PPUSH
80988: LD_VAR 0 1
80992: PPUSH
80993: CALL 16289 0 3
80997: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80998: LD_ADDR_VAR 0 5
81002: PUSH
81003: LD_EXP 23
81007: PUSH
81008: LD_VAR 0 4
81012: ARRAY
81013: PPUSH
81014: LD_INT 2
81016: PUSH
81017: LD_INT 30
81019: PUSH
81020: LD_INT 0
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 30
81029: PUSH
81030: LD_INT 1
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: EMPTY
81038: LIST
81039: LIST
81040: LIST
81041: PPUSH
81042: CALL_OW 72
81046: PPUSH
81047: LD_VAR 0 1
81051: PPUSH
81052: CALL_OW 74
81056: ST_TO_ADDR
// if tmp then
81057: LD_VAR 0 5
81061: IFFALSE 81077
// ComStandNearbyBuilding ( ape , tmp ) ;
81063: LD_VAR 0 1
81067: PPUSH
81068: LD_VAR 0 5
81072: PPUSH
81073: CALL 12831 0 2
// break ;
81077: GO 81081
// end ; end ;
81079: GO 80933
81081: POP
81082: POP
// end ;
81083: LD_VAR 0 3
81087: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81088: LD_INT 0
81090: PPUSH
81091: PPUSH
81092: PPUSH
// if not mc_bases or not skirmish then
81093: LD_EXP 23
81097: NOT
81098: IFTRUE 81107
81100: PUSH
81101: LD_EXP 21
81105: NOT
81106: OR
81107: IFFALSE 81111
// exit ;
81109: GO 81200
// for i = 1 to mc_bases do
81111: LD_ADDR_VAR 0 4
81115: PUSH
81116: DOUBLE
81117: LD_INT 1
81119: DEC
81120: ST_TO_ADDR
81121: LD_EXP 23
81125: PUSH
81126: FOR_TO
81127: IFFALSE 81198
// begin if building in mc_busy_turret_list [ i ] then
81129: LD_VAR 0 1
81133: PUSH
81134: LD_EXP 33
81138: PUSH
81139: LD_VAR 0 4
81143: ARRAY
81144: IN
81145: IFFALSE 81196
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81147: LD_ADDR_VAR 0 5
81151: PUSH
81152: LD_EXP 33
81156: PUSH
81157: LD_VAR 0 4
81161: ARRAY
81162: PUSH
81163: LD_VAR 0 1
81167: DIFF
81168: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81169: LD_ADDR_EXP 33
81173: PUSH
81174: LD_EXP 33
81178: PPUSH
81179: LD_VAR 0 4
81183: PPUSH
81184: LD_VAR 0 5
81188: PPUSH
81189: CALL_OW 1
81193: ST_TO_ADDR
// break ;
81194: GO 81198
// end ; end ;
81196: GO 81126
81198: POP
81199: POP
// end ;
81200: LD_VAR 0 3
81204: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81205: LD_INT 0
81207: PPUSH
81208: PPUSH
81209: PPUSH
// if not mc_bases or not skirmish then
81210: LD_EXP 23
81214: NOT
81215: IFTRUE 81224
81217: PUSH
81218: LD_EXP 21
81222: NOT
81223: OR
81224: IFFALSE 81228
// exit ;
81226: GO 81427
// for i = 1 to mc_bases do
81228: LD_ADDR_VAR 0 5
81232: PUSH
81233: DOUBLE
81234: LD_INT 1
81236: DEC
81237: ST_TO_ADDR
81238: LD_EXP 23
81242: PUSH
81243: FOR_TO
81244: IFFALSE 81425
// if building in mc_bases [ i ] then
81246: LD_VAR 0 1
81250: PUSH
81251: LD_EXP 23
81255: PUSH
81256: LD_VAR 0 5
81260: ARRAY
81261: IN
81262: IFFALSE 81423
// begin tmp := mc_bases [ i ] diff building ;
81264: LD_ADDR_VAR 0 6
81268: PUSH
81269: LD_EXP 23
81273: PUSH
81274: LD_VAR 0 5
81278: ARRAY
81279: PUSH
81280: LD_VAR 0 1
81284: DIFF
81285: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81286: LD_ADDR_EXP 23
81290: PUSH
81291: LD_EXP 23
81295: PPUSH
81296: LD_VAR 0 5
81300: PPUSH
81301: LD_VAR 0 6
81305: PPUSH
81306: CALL_OW 1
81310: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81311: LD_VAR 0 1
81315: PUSH
81316: LD_EXP 31
81320: PUSH
81321: LD_VAR 0 5
81325: ARRAY
81326: IN
81327: IFFALSE 81366
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81329: LD_ADDR_EXP 31
81333: PUSH
81334: LD_EXP 31
81338: PPUSH
81339: LD_VAR 0 5
81343: PPUSH
81344: LD_EXP 31
81348: PUSH
81349: LD_VAR 0 5
81353: ARRAY
81354: PUSH
81355: LD_VAR 0 1
81359: DIFF
81360: PPUSH
81361: CALL_OW 1
81365: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81366: LD_VAR 0 1
81370: PUSH
81371: LD_EXP 32
81375: PUSH
81376: LD_VAR 0 5
81380: ARRAY
81381: IN
81382: IFFALSE 81421
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81384: LD_ADDR_EXP 32
81388: PUSH
81389: LD_EXP 32
81393: PPUSH
81394: LD_VAR 0 5
81398: PPUSH
81399: LD_EXP 32
81403: PUSH
81404: LD_VAR 0 5
81408: ARRAY
81409: PUSH
81410: LD_VAR 0 1
81414: DIFF
81415: PPUSH
81416: CALL_OW 1
81420: ST_TO_ADDR
// break ;
81421: GO 81425
// end ;
81423: GO 81243
81425: POP
81426: POP
// end ;
81427: LD_VAR 0 4
81431: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81432: LD_INT 0
81434: PPUSH
81435: PPUSH
81436: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81437: LD_EXP 23
81441: NOT
81442: IFTRUE 81451
81444: PUSH
81445: LD_EXP 21
81449: NOT
81450: OR
81451: IFTRUE 81466
81453: PUSH
81454: LD_VAR 0 3
81458: PUSH
81459: LD_EXP 49
81463: IN
81464: NOT
81465: OR
81466: IFFALSE 81470
// exit ;
81468: GO 81595
// for i = 1 to mc_vehicles do
81470: LD_ADDR_VAR 0 6
81474: PUSH
81475: DOUBLE
81476: LD_INT 1
81478: DEC
81479: ST_TO_ADDR
81480: LD_EXP 42
81484: PUSH
81485: FOR_TO
81486: IFFALSE 81593
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81488: LD_VAR 0 2
81492: PUSH
81493: LD_EXP 42
81497: PUSH
81498: LD_VAR 0 6
81502: ARRAY
81503: IN
81504: IFTRUE 81524
81506: PUSH
81507: LD_VAR 0 1
81511: PUSH
81512: LD_EXP 42
81516: PUSH
81517: LD_VAR 0 6
81521: ARRAY
81522: IN
81523: OR
81524: IFFALSE 81591
// begin tmp := mc_vehicles [ i ] diff old ;
81526: LD_ADDR_VAR 0 7
81530: PUSH
81531: LD_EXP 42
81535: PUSH
81536: LD_VAR 0 6
81540: ARRAY
81541: PUSH
81542: LD_VAR 0 2
81546: DIFF
81547: ST_TO_ADDR
// tmp := tmp diff new ;
81548: LD_ADDR_VAR 0 7
81552: PUSH
81553: LD_VAR 0 7
81557: PUSH
81558: LD_VAR 0 1
81562: DIFF
81563: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81564: LD_ADDR_EXP 42
81568: PUSH
81569: LD_EXP 42
81573: PPUSH
81574: LD_VAR 0 6
81578: PPUSH
81579: LD_VAR 0 7
81583: PPUSH
81584: CALL_OW 1
81588: ST_TO_ADDR
// break ;
81589: GO 81593
// end ;
81591: GO 81485
81593: POP
81594: POP
// end ;
81595: LD_VAR 0 5
81599: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81600: LD_INT 0
81602: PPUSH
81603: PPUSH
81604: PPUSH
81605: PPUSH
// if not mc_bases or not skirmish then
81606: LD_EXP 23
81610: NOT
81611: IFTRUE 81620
81613: PUSH
81614: LD_EXP 21
81618: NOT
81619: OR
81620: IFFALSE 81624
// exit ;
81622: GO 82046
// repeat wait ( 0 0$1 ) ;
81624: LD_INT 35
81626: PPUSH
81627: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
81631: LD_EXP 67
81635: NOT
81636: IFFALSE 81624
// mc_block_vehicle_constructed_thread := true ;
81638: LD_ADDR_EXP 67
81642: PUSH
81643: LD_INT 1
81645: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
81646: LD_ADDR_VAR 0 5
81650: PUSH
81651: LD_VAR 0 1
81655: PPUSH
81656: CALL_OW 255
81660: ST_TO_ADDR
// for i = 1 to mc_bases do
81661: LD_ADDR_VAR 0 4
81665: PUSH
81666: DOUBLE
81667: LD_INT 1
81669: DEC
81670: ST_TO_ADDR
81671: LD_EXP 23
81675: PUSH
81676: FOR_TO
81677: IFFALSE 82036
// begin if factory in mc_bases [ i ] then
81679: LD_VAR 0 2
81683: PUSH
81684: LD_EXP 23
81688: PUSH
81689: LD_VAR 0 4
81693: ARRAY
81694: IN
81695: IFFALSE 82034
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81697: LD_EXP 45
81701: PUSH
81702: LD_VAR 0 4
81706: ARRAY
81707: PUSH
81708: LD_EXP 34
81712: PUSH
81713: LD_VAR 0 4
81717: ARRAY
81718: LESS
81719: IFFALSE 81808
81721: PUSH
81722: LD_VAR 0 1
81726: PPUSH
81727: CALL_OW 264
81731: PUSH
81732: LD_INT 31
81734: PUSH
81735: LD_INT 32
81737: PUSH
81738: LD_INT 51
81740: PUSH
81741: LD_INT 89
81743: PUSH
81744: LD_INT 12
81746: PUSH
81747: LD_INT 30
81749: PUSH
81750: LD_INT 98
81752: PUSH
81753: LD_INT 11
81755: PUSH
81756: LD_INT 53
81758: PUSH
81759: LD_INT 14
81761: PUSH
81762: LD_INT 91
81764: PUSH
81765: LD_INT 29
81767: PUSH
81768: LD_INT 99
81770: PUSH
81771: LD_INT 13
81773: PUSH
81774: LD_INT 52
81776: PUSH
81777: LD_INT 88
81779: PUSH
81780: LD_INT 48
81782: PUSH
81783: LD_INT 8
81785: PUSH
81786: EMPTY
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: LIST
81794: LIST
81795: LIST
81796: LIST
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: LIST
81802: LIST
81803: LIST
81804: LIST
81805: IN
81806: NOT
81807: AND
81808: IFFALSE 81856
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81810: LD_ADDR_EXP 45
81814: PUSH
81815: LD_EXP 45
81819: PPUSH
81820: LD_VAR 0 4
81824: PUSH
81825: LD_EXP 45
81829: PUSH
81830: LD_VAR 0 4
81834: ARRAY
81835: PUSH
81836: LD_INT 1
81838: PLUS
81839: PUSH
81840: EMPTY
81841: LIST
81842: LIST
81843: PPUSH
81844: LD_VAR 0 1
81848: PPUSH
81849: CALL 16289 0 3
81853: ST_TO_ADDR
81854: GO 81900
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81856: LD_ADDR_EXP 42
81860: PUSH
81861: LD_EXP 42
81865: PPUSH
81866: LD_VAR 0 4
81870: PUSH
81871: LD_EXP 42
81875: PUSH
81876: LD_VAR 0 4
81880: ARRAY
81881: PUSH
81882: LD_INT 1
81884: PLUS
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PPUSH
81890: LD_VAR 0 1
81894: PPUSH
81895: CALL 16289 0 3
81899: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
81900: LD_ADDR_EXP 67
81904: PUSH
81905: LD_INT 0
81907: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81908: LD_VAR 0 1
81912: PPUSH
81913: CALL_OW 263
81917: PUSH
81918: LD_INT 2
81920: EQUAL
81921: IFFALSE 81950
// begin repeat wait ( 0 0$3 ) ;
81923: LD_INT 105
81925: PPUSH
81926: CALL_OW 67
// Connect ( vehicle ) ;
81930: LD_VAR 0 1
81934: PPUSH
81935: CALL 19649 0 1
// until IsControledBy ( vehicle ) ;
81939: LD_VAR 0 1
81943: PPUSH
81944: CALL_OW 312
81948: IFFALSE 81923
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81950: LD_VAR 0 1
81954: PPUSH
81955: LD_EXP 47
81959: PUSH
81960: LD_VAR 0 4
81964: ARRAY
81965: PPUSH
81966: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81970: LD_VAR 0 1
81974: PPUSH
81975: CALL_OW 263
81979: PUSH
81980: LD_INT 1
81982: NONEQUAL
81983: IFFALSE 81987
// break ;
81985: GO 82036
// repeat wait ( 0 0$1 ) ;
81987: LD_INT 35
81989: PPUSH
81990: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81994: LD_VAR 0 1
81998: PPUSH
81999: LD_EXP 47
82003: PUSH
82004: LD_VAR 0 4
82008: ARRAY
82009: PPUSH
82010: CALL_OW 308
82014: IFFALSE 81987
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82016: LD_VAR 0 1
82020: PPUSH
82021: CALL_OW 311
82025: PPUSH
82026: CALL_OW 121
// exit ;
82030: POP
82031: POP
82032: GO 82046
// end ; end ;
82034: GO 81676
82036: POP
82037: POP
// mc_block_vehicle_constructed_thread := false ;
82038: LD_ADDR_EXP 67
82042: PUSH
82043: LD_INT 0
82045: ST_TO_ADDR
// end ;
82046: LD_VAR 0 3
82050: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82051: LD_INT 0
82053: PPUSH
82054: PPUSH
82055: PPUSH
82056: PPUSH
// if not mc_bases or not skirmish then
82057: LD_EXP 23
82061: NOT
82062: IFTRUE 82071
82064: PUSH
82065: LD_EXP 21
82069: NOT
82070: OR
82071: IFFALSE 82075
// exit ;
82073: GO 82428
// repeat wait ( 0 0$1 ) ;
82075: LD_INT 35
82077: PPUSH
82078: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82082: LD_VAR 0 2
82086: PPUSH
82087: LD_VAR 0 3
82091: PPUSH
82092: CALL_OW 284
82096: IFFALSE 82075
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82098: LD_VAR 0 2
82102: PPUSH
82103: LD_VAR 0 3
82107: PPUSH
82108: CALL_OW 283
82112: PUSH
82113: LD_INT 4
82115: EQUAL
82116: IFFALSE 82120
// exit ;
82118: GO 82428
// for i = 1 to mc_bases do
82120: LD_ADDR_VAR 0 7
82124: PUSH
82125: DOUBLE
82126: LD_INT 1
82128: DEC
82129: ST_TO_ADDR
82130: LD_EXP 23
82134: PUSH
82135: FOR_TO
82136: IFFALSE 82426
// begin if mc_crates_area [ i ] then
82138: LD_EXP 41
82142: PUSH
82143: LD_VAR 0 7
82147: ARRAY
82148: IFFALSE 82259
// for j in mc_crates_area [ i ] do
82150: LD_ADDR_VAR 0 8
82154: PUSH
82155: LD_EXP 41
82159: PUSH
82160: LD_VAR 0 7
82164: ARRAY
82165: PUSH
82166: FOR_IN
82167: IFFALSE 82257
// if InArea ( x , y , j ) then
82169: LD_VAR 0 2
82173: PPUSH
82174: LD_VAR 0 3
82178: PPUSH
82179: LD_VAR 0 8
82183: PPUSH
82184: CALL_OW 309
82188: IFFALSE 82255
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82190: LD_ADDR_EXP 39
82194: PUSH
82195: LD_EXP 39
82199: PPUSH
82200: LD_VAR 0 7
82204: PUSH
82205: LD_EXP 39
82209: PUSH
82210: LD_VAR 0 7
82214: ARRAY
82215: PUSH
82216: LD_INT 1
82218: PLUS
82219: PUSH
82220: EMPTY
82221: LIST
82222: LIST
82223: PPUSH
82224: LD_VAR 0 4
82228: PUSH
82229: LD_VAR 0 2
82233: PUSH
82234: LD_VAR 0 3
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: LIST
82243: PPUSH
82244: CALL 16289 0 3
82248: ST_TO_ADDR
// exit ;
82249: POP
82250: POP
82251: POP
82252: POP
82253: GO 82428
// end ;
82255: GO 82166
82257: POP
82258: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82259: LD_ADDR_VAR 0 9
82263: PUSH
82264: LD_EXP 23
82268: PUSH
82269: LD_VAR 0 7
82273: ARRAY
82274: PPUSH
82275: LD_INT 2
82277: PUSH
82278: LD_INT 30
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 30
82290: PUSH
82291: LD_INT 1
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: EMPTY
82299: LIST
82300: LIST
82301: LIST
82302: PPUSH
82303: CALL_OW 72
82307: ST_TO_ADDR
// if not depot then
82308: LD_VAR 0 9
82312: NOT
82313: IFFALSE 82317
// continue ;
82315: GO 82135
// for j in depot do
82317: LD_ADDR_VAR 0 8
82321: PUSH
82322: LD_VAR 0 9
82326: PUSH
82327: FOR_IN
82328: IFFALSE 82422
// if GetDistUnitXY ( j , x , y ) < 30 then
82330: LD_VAR 0 8
82334: PPUSH
82335: LD_VAR 0 2
82339: PPUSH
82340: LD_VAR 0 3
82344: PPUSH
82345: CALL_OW 297
82349: PUSH
82350: LD_INT 30
82352: LESS
82353: IFFALSE 82420
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82355: LD_ADDR_EXP 39
82359: PUSH
82360: LD_EXP 39
82364: PPUSH
82365: LD_VAR 0 7
82369: PUSH
82370: LD_EXP 39
82374: PUSH
82375: LD_VAR 0 7
82379: ARRAY
82380: PUSH
82381: LD_INT 1
82383: PLUS
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PPUSH
82389: LD_VAR 0 4
82393: PUSH
82394: LD_VAR 0 2
82398: PUSH
82399: LD_VAR 0 3
82403: PUSH
82404: EMPTY
82405: LIST
82406: LIST
82407: LIST
82408: PPUSH
82409: CALL 16289 0 3
82413: ST_TO_ADDR
// exit ;
82414: POP
82415: POP
82416: POP
82417: POP
82418: GO 82428
// end ;
82420: GO 82327
82422: POP
82423: POP
// end ;
82424: GO 82135
82426: POP
82427: POP
// end ;
82428: LD_VAR 0 6
82432: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82433: LD_INT 0
82435: PPUSH
82436: PPUSH
82437: PPUSH
82438: PPUSH
// if not mc_bases or not skirmish then
82439: LD_EXP 23
82443: NOT
82444: IFTRUE 82453
82446: PUSH
82447: LD_EXP 21
82451: NOT
82452: OR
82453: IFFALSE 82457
// exit ;
82455: GO 82740
// side := GetSide ( lab ) ;
82457: LD_ADDR_VAR 0 4
82461: PUSH
82462: LD_VAR 0 2
82466: PPUSH
82467: CALL_OW 255
82471: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82472: LD_VAR 0 4
82476: PUSH
82477: LD_EXP 49
82481: IN
82482: NOT
82483: IFTRUE 82492
82485: PUSH
82486: LD_EXP 50
82490: NOT
82491: OR
82492: IFTRUE 82501
82494: PUSH
82495: LD_EXP 23
82499: NOT
82500: OR
82501: IFFALSE 82505
// exit ;
82503: GO 82740
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82505: LD_ADDR_EXP 50
82509: PUSH
82510: LD_EXP 50
82514: PPUSH
82515: LD_VAR 0 4
82519: PPUSH
82520: LD_EXP 50
82524: PUSH
82525: LD_VAR 0 4
82529: ARRAY
82530: PUSH
82531: LD_VAR 0 1
82535: DIFF
82536: PPUSH
82537: CALL_OW 1
82541: ST_TO_ADDR
// for i = 1 to mc_bases do
82542: LD_ADDR_VAR 0 5
82546: PUSH
82547: DOUBLE
82548: LD_INT 1
82550: DEC
82551: ST_TO_ADDR
82552: LD_EXP 23
82556: PUSH
82557: FOR_TO
82558: IFFALSE 82738
// begin if lab in mc_bases [ i ] then
82560: LD_VAR 0 2
82564: PUSH
82565: LD_EXP 23
82569: PUSH
82570: LD_VAR 0 5
82574: ARRAY
82575: IN
82576: IFFALSE 82736
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82578: LD_VAR 0 1
82582: PUSH
82583: LD_INT 11
82585: PUSH
82586: LD_INT 4
82588: PUSH
82589: LD_INT 3
82591: PUSH
82592: LD_INT 2
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: IN
82601: IFFALSE 82615
82603: PUSH
82604: LD_EXP 53
82608: PUSH
82609: LD_VAR 0 5
82613: ARRAY
82614: AND
82615: IFFALSE 82736
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82617: LD_ADDR_VAR 0 6
82621: PUSH
82622: LD_EXP 53
82626: PUSH
82627: LD_VAR 0 5
82631: ARRAY
82632: PUSH
82633: LD_INT 1
82635: ARRAY
82636: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82637: LD_ADDR_EXP 53
82641: PUSH
82642: LD_EXP 53
82646: PPUSH
82647: LD_VAR 0 5
82651: PPUSH
82652: EMPTY
82653: PPUSH
82654: CALL_OW 1
82658: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82659: LD_VAR 0 6
82663: PPUSH
82664: LD_INT 0
82666: PPUSH
82667: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82671: LD_VAR 0 6
82675: PPUSH
82676: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82680: LD_ADDR_EXP 52
82684: PUSH
82685: LD_EXP 52
82689: PPUSH
82690: LD_VAR 0 5
82694: PPUSH
82695: LD_EXP 52
82699: PUSH
82700: LD_VAR 0 5
82704: ARRAY
82705: PPUSH
82706: LD_INT 1
82708: PPUSH
82709: LD_VAR 0 6
82713: PPUSH
82714: CALL_OW 2
82718: PPUSH
82719: CALL_OW 1
82723: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82724: LD_VAR 0 5
82728: PPUSH
82729: LD_INT 112
82731: PPUSH
82732: CALL 58870 0 2
// end ; end ; end ;
82736: GO 82557
82738: POP
82739: POP
// end ;
82740: LD_VAR 0 3
82744: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82745: LD_INT 0
82747: PPUSH
82748: PPUSH
82749: PPUSH
82750: PPUSH
82751: PPUSH
82752: PPUSH
82753: PPUSH
82754: PPUSH
// if not mc_bases or not skirmish then
82755: LD_EXP 23
82759: NOT
82760: IFTRUE 82769
82762: PUSH
82763: LD_EXP 21
82767: NOT
82768: OR
82769: IFFALSE 82773
// exit ;
82771: GO 84158
// for i = 1 to mc_bases do
82773: LD_ADDR_VAR 0 3
82777: PUSH
82778: DOUBLE
82779: LD_INT 1
82781: DEC
82782: ST_TO_ADDR
82783: LD_EXP 23
82787: PUSH
82788: FOR_TO
82789: IFFALSE 84156
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82791: LD_VAR 0 1
82795: PUSH
82796: LD_EXP 23
82800: PUSH
82801: LD_VAR 0 3
82805: ARRAY
82806: IN
82807: IFTRUE 82827
82809: PUSH
82810: LD_VAR 0 1
82814: PUSH
82815: LD_EXP 30
82819: PUSH
82820: LD_VAR 0 3
82824: ARRAY
82825: IN
82826: OR
82827: IFTRUE 82847
82829: PUSH
82830: LD_VAR 0 1
82834: PUSH
82835: LD_EXP 45
82839: PUSH
82840: LD_VAR 0 3
82844: ARRAY
82845: IN
82846: OR
82847: IFTRUE 82867
82849: PUSH
82850: LD_VAR 0 1
82854: PUSH
82855: LD_EXP 42
82859: PUSH
82860: LD_VAR 0 3
82864: ARRAY
82865: IN
82866: OR
82867: IFTRUE 82887
82869: PUSH
82870: LD_VAR 0 1
82874: PUSH
82875: LD_EXP 52
82879: PUSH
82880: LD_VAR 0 3
82884: ARRAY
82885: IN
82886: OR
82887: IFTRUE 82907
82889: PUSH
82890: LD_VAR 0 1
82894: PUSH
82895: LD_EXP 53
82899: PUSH
82900: LD_VAR 0 3
82904: ARRAY
82905: IN
82906: OR
82907: IFFALSE 84154
// begin if un in mc_ape [ i ] then
82909: LD_VAR 0 1
82913: PUSH
82914: LD_EXP 52
82918: PUSH
82919: LD_VAR 0 3
82923: ARRAY
82924: IN
82925: IFFALSE 82964
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82927: LD_ADDR_EXP 52
82931: PUSH
82932: LD_EXP 52
82936: PPUSH
82937: LD_VAR 0 3
82941: PPUSH
82942: LD_EXP 52
82946: PUSH
82947: LD_VAR 0 3
82951: ARRAY
82952: PUSH
82953: LD_VAR 0 1
82957: DIFF
82958: PPUSH
82959: CALL_OW 1
82963: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82964: LD_VAR 0 1
82968: PUSH
82969: LD_EXP 53
82973: PUSH
82974: LD_VAR 0 3
82978: ARRAY
82979: IN
82980: IFFALSE 83004
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82982: LD_ADDR_EXP 53
82986: PUSH
82987: LD_EXP 53
82991: PPUSH
82992: LD_VAR 0 3
82996: PPUSH
82997: EMPTY
82998: PPUSH
82999: CALL_OW 1
83003: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
83004: LD_VAR 0 1
83008: PPUSH
83009: CALL_OW 247
83013: PUSH
83014: LD_INT 2
83016: EQUAL
83017: IFFALSE 83098
83019: PUSH
83020: LD_VAR 0 1
83024: PPUSH
83025: CALL_OW 110
83029: PUSH
83030: LD_INT 20
83032: EQUAL
83033: IFTRUE 83053
83035: PUSH
83036: LD_VAR 0 1
83040: PUSH
83041: LD_EXP 45
83045: PUSH
83046: LD_VAR 0 3
83050: ARRAY
83051: IN
83052: OR
83053: IFTRUE 83097
83055: PUSH
83056: LD_VAR 0 1
83060: PPUSH
83061: CALL_OW 264
83065: PUSH
83066: LD_INT 12
83068: PUSH
83069: LD_INT 51
83071: PUSH
83072: LD_INT 89
83074: PUSH
83075: LD_INT 32
83077: PUSH
83078: LD_INT 13
83080: PUSH
83081: LD_INT 52
83083: PUSH
83084: LD_INT 31
83086: PUSH
83087: EMPTY
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: IN
83096: OR
83097: AND
83098: IFFALSE 83406
// begin if un in mc_defender [ i ] then
83100: LD_VAR 0 1
83104: PUSH
83105: LD_EXP 45
83109: PUSH
83110: LD_VAR 0 3
83114: ARRAY
83115: IN
83116: IFFALSE 83155
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83118: LD_ADDR_EXP 45
83122: PUSH
83123: LD_EXP 45
83127: PPUSH
83128: LD_VAR 0 3
83132: PPUSH
83133: LD_EXP 45
83137: PUSH
83138: LD_VAR 0 3
83142: ARRAY
83143: PUSH
83144: LD_VAR 0 1
83148: DIFF
83149: PPUSH
83150: CALL_OW 1
83154: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83155: LD_ADDR_VAR 0 8
83159: PUSH
83160: LD_VAR 0 3
83164: PPUSH
83165: LD_INT 3
83167: PPUSH
83168: CALL 79694 0 2
83172: ST_TO_ADDR
// if fac then
83173: LD_VAR 0 8
83177: IFFALSE 83406
// begin for j in fac do
83179: LD_ADDR_VAR 0 4
83183: PUSH
83184: LD_VAR 0 8
83188: PUSH
83189: FOR_IN
83190: IFFALSE 83404
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83192: LD_ADDR_VAR 0 9
83196: PUSH
83197: LD_VAR 0 8
83201: PPUSH
83202: LD_VAR 0 1
83206: PPUSH
83207: CALL_OW 265
83211: PPUSH
83212: LD_VAR 0 1
83216: PPUSH
83217: CALL_OW 262
83221: PPUSH
83222: LD_VAR 0 1
83226: PPUSH
83227: CALL_OW 263
83231: PPUSH
83232: LD_VAR 0 1
83236: PPUSH
83237: CALL_OW 264
83241: PPUSH
83242: CALL 13729 0 5
83246: ST_TO_ADDR
// if components then
83247: LD_VAR 0 9
83251: IFFALSE 83402
// begin if GetWeapon ( un ) = ar_control_tower then
83253: LD_VAR 0 1
83257: PPUSH
83258: CALL_OW 264
83262: PUSH
83263: LD_INT 31
83265: EQUAL
83266: IFFALSE 83383
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83268: LD_VAR 0 1
83272: PPUSH
83273: CALL_OW 311
83277: PPUSH
83278: LD_INT 0
83280: PPUSH
83281: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83285: LD_ADDR_EXP 63
83289: PUSH
83290: LD_EXP 63
83294: PPUSH
83295: LD_VAR 0 3
83299: PPUSH
83300: LD_EXP 63
83304: PUSH
83305: LD_VAR 0 3
83309: ARRAY
83310: PUSH
83311: LD_VAR 0 1
83315: PPUSH
83316: CALL_OW 311
83320: DIFF
83321: PPUSH
83322: CALL_OW 1
83326: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83327: LD_ADDR_VAR 0 7
83331: PUSH
83332: LD_EXP 44
83336: PUSH
83337: LD_VAR 0 3
83341: ARRAY
83342: PPUSH
83343: LD_INT 1
83345: PPUSH
83346: LD_VAR 0 9
83350: PPUSH
83351: CALL_OW 2
83355: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83356: LD_ADDR_EXP 44
83360: PUSH
83361: LD_EXP 44
83365: PPUSH
83366: LD_VAR 0 3
83370: PPUSH
83371: LD_VAR 0 7
83375: PPUSH
83376: CALL_OW 1
83380: ST_TO_ADDR
// end else
83381: GO 83400
// MC_InsertProduceList ( i , [ components ] ) ;
83383: LD_VAR 0 3
83387: PPUSH
83388: LD_VAR 0 9
83392: PUSH
83393: EMPTY
83394: LIST
83395: PPUSH
83396: CALL 79239 0 2
// break ;
83400: GO 83404
// end ; end ;
83402: GO 83189
83404: POP
83405: POP
// end ; end ; if GetType ( un ) = unit_building then
83406: LD_VAR 0 1
83410: PPUSH
83411: CALL_OW 247
83415: PUSH
83416: LD_INT 3
83418: EQUAL
83419: IFFALSE 83822
// begin btype := GetBType ( un ) ;
83421: LD_ADDR_VAR 0 5
83425: PUSH
83426: LD_VAR 0 1
83430: PPUSH
83431: CALL_OW 266
83435: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83436: LD_VAR 0 5
83440: PUSH
83441: LD_INT 29
83443: PUSH
83444: LD_INT 30
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: IN
83451: IFFALSE 83524
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83453: LD_VAR 0 1
83457: PPUSH
83458: CALL_OW 250
83462: PPUSH
83463: LD_VAR 0 1
83467: PPUSH
83468: CALL_OW 251
83472: PPUSH
83473: LD_VAR 0 1
83477: PPUSH
83478: CALL_OW 255
83482: PPUSH
83483: CALL_OW 440
83487: NOT
83488: IFFALSE 83524
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83490: LD_VAR 0 1
83494: PPUSH
83495: CALL_OW 250
83499: PPUSH
83500: LD_VAR 0 1
83504: PPUSH
83505: CALL_OW 251
83509: PPUSH
83510: LD_VAR 0 1
83514: PPUSH
83515: CALL_OW 255
83519: PPUSH
83520: CALL_OW 441
// end ; if btype = b_warehouse then
83524: LD_VAR 0 5
83528: PUSH
83529: LD_INT 1
83531: EQUAL
83532: IFFALSE 83550
// begin btype := b_depot ;
83534: LD_ADDR_VAR 0 5
83538: PUSH
83539: LD_INT 0
83541: ST_TO_ADDR
// pos := 1 ;
83542: LD_ADDR_VAR 0 6
83546: PUSH
83547: LD_INT 1
83549: ST_TO_ADDR
// end ; if btype = b_factory then
83550: LD_VAR 0 5
83554: PUSH
83555: LD_INT 3
83557: EQUAL
83558: IFFALSE 83576
// begin btype := b_workshop ;
83560: LD_ADDR_VAR 0 5
83564: PUSH
83565: LD_INT 2
83567: ST_TO_ADDR
// pos := 1 ;
83568: LD_ADDR_VAR 0 6
83572: PUSH
83573: LD_INT 1
83575: ST_TO_ADDR
// end ; if btype = b_barracks then
83576: LD_VAR 0 5
83580: PUSH
83581: LD_INT 5
83583: EQUAL
83584: IFFALSE 83594
// btype := b_armoury ;
83586: LD_ADDR_VAR 0 5
83590: PUSH
83591: LD_INT 4
83593: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83594: LD_VAR 0 5
83598: PUSH
83599: LD_INT 7
83601: PUSH
83602: LD_INT 8
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: IN
83609: IFFALSE 83619
// btype := b_lab ;
83611: LD_ADDR_VAR 0 5
83615: PUSH
83616: LD_INT 6
83618: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83619: LD_ADDR_EXP 28
83623: PUSH
83624: LD_EXP 28
83628: PPUSH
83629: LD_VAR 0 3
83633: PUSH
83634: LD_EXP 28
83638: PUSH
83639: LD_VAR 0 3
83643: ARRAY
83644: PUSH
83645: LD_INT 1
83647: PLUS
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PPUSH
83653: LD_VAR 0 5
83657: PUSH
83658: LD_VAR 0 1
83662: PPUSH
83663: CALL_OW 250
83667: PUSH
83668: LD_VAR 0 1
83672: PPUSH
83673: CALL_OW 251
83677: PUSH
83678: LD_VAR 0 1
83682: PPUSH
83683: CALL_OW 254
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: LIST
83692: LIST
83693: PPUSH
83694: CALL 16289 0 3
83698: ST_TO_ADDR
// if pos = 1 then
83699: LD_VAR 0 6
83703: PUSH
83704: LD_INT 1
83706: EQUAL
83707: IFFALSE 83822
// begin tmp := mc_build_list [ i ] ;
83709: LD_ADDR_VAR 0 7
83713: PUSH
83714: LD_EXP 28
83718: PUSH
83719: LD_VAR 0 3
83723: ARRAY
83724: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83725: LD_VAR 0 7
83729: PPUSH
83730: LD_INT 2
83732: PUSH
83733: LD_INT 30
83735: PUSH
83736: LD_INT 0
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PUSH
83743: LD_INT 30
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: EMPTY
83754: LIST
83755: LIST
83756: LIST
83757: PPUSH
83758: CALL_OW 72
83762: IFFALSE 83772
// pos := 2 ;
83764: LD_ADDR_VAR 0 6
83768: PUSH
83769: LD_INT 2
83771: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83772: LD_ADDR_VAR 0 7
83776: PUSH
83777: LD_VAR 0 7
83781: PPUSH
83782: LD_VAR 0 6
83786: PPUSH
83787: LD_VAR 0 7
83791: PPUSH
83792: CALL 16615 0 3
83796: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83797: LD_ADDR_EXP 28
83801: PUSH
83802: LD_EXP 28
83806: PPUSH
83807: LD_VAR 0 3
83811: PPUSH
83812: LD_VAR 0 7
83816: PPUSH
83817: CALL_OW 1
83821: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83822: LD_VAR 0 1
83826: PUSH
83827: LD_EXP 23
83831: PUSH
83832: LD_VAR 0 3
83836: ARRAY
83837: IN
83838: IFFALSE 83877
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83840: LD_ADDR_EXP 23
83844: PUSH
83845: LD_EXP 23
83849: PPUSH
83850: LD_VAR 0 3
83854: PPUSH
83855: LD_EXP 23
83859: PUSH
83860: LD_VAR 0 3
83864: ARRAY
83865: PUSH
83866: LD_VAR 0 1
83870: DIFF
83871: PPUSH
83872: CALL_OW 1
83876: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83877: LD_VAR 0 1
83881: PUSH
83882: LD_EXP 30
83886: PUSH
83887: LD_VAR 0 3
83891: ARRAY
83892: IN
83893: IFFALSE 83932
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83895: LD_ADDR_EXP 30
83899: PUSH
83900: LD_EXP 30
83904: PPUSH
83905: LD_VAR 0 3
83909: PPUSH
83910: LD_EXP 30
83914: PUSH
83915: LD_VAR 0 3
83919: ARRAY
83920: PUSH
83921: LD_VAR 0 1
83925: DIFF
83926: PPUSH
83927: CALL_OW 1
83931: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83932: LD_VAR 0 1
83936: PUSH
83937: LD_EXP 42
83941: PUSH
83942: LD_VAR 0 3
83946: ARRAY
83947: IN
83948: IFFALSE 83987
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83950: LD_ADDR_EXP 42
83954: PUSH
83955: LD_EXP 42
83959: PPUSH
83960: LD_VAR 0 3
83964: PPUSH
83965: LD_EXP 42
83969: PUSH
83970: LD_VAR 0 3
83974: ARRAY
83975: PUSH
83976: LD_VAR 0 1
83980: DIFF
83981: PPUSH
83982: CALL_OW 1
83986: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83987: LD_VAR 0 1
83991: PUSH
83992: LD_EXP 45
83996: PUSH
83997: LD_VAR 0 3
84001: ARRAY
84002: IN
84003: IFFALSE 84042
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84005: LD_ADDR_EXP 45
84009: PUSH
84010: LD_EXP 45
84014: PPUSH
84015: LD_VAR 0 3
84019: PPUSH
84020: LD_EXP 45
84024: PUSH
84025: LD_VAR 0 3
84029: ARRAY
84030: PUSH
84031: LD_VAR 0 1
84035: DIFF
84036: PPUSH
84037: CALL_OW 1
84041: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84042: LD_VAR 0 1
84046: PUSH
84047: LD_EXP 32
84051: PUSH
84052: LD_VAR 0 3
84056: ARRAY
84057: IN
84058: IFFALSE 84097
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84060: LD_ADDR_EXP 32
84064: PUSH
84065: LD_EXP 32
84069: PPUSH
84070: LD_VAR 0 3
84074: PPUSH
84075: LD_EXP 32
84079: PUSH
84080: LD_VAR 0 3
84084: ARRAY
84085: PUSH
84086: LD_VAR 0 1
84090: DIFF
84091: PPUSH
84092: CALL_OW 1
84096: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84097: LD_VAR 0 1
84101: PUSH
84102: LD_EXP 31
84106: PUSH
84107: LD_VAR 0 3
84111: ARRAY
84112: IN
84113: IFFALSE 84152
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84115: LD_ADDR_EXP 31
84119: PUSH
84120: LD_EXP 31
84124: PPUSH
84125: LD_VAR 0 3
84129: PPUSH
84130: LD_EXP 31
84134: PUSH
84135: LD_VAR 0 3
84139: ARRAY
84140: PUSH
84141: LD_VAR 0 1
84145: DIFF
84146: PPUSH
84147: CALL_OW 1
84151: ST_TO_ADDR
// end ; break ;
84152: GO 84156
// end ;
84154: GO 82788
84156: POP
84157: POP
// end ;
84158: LD_VAR 0 2
84162: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84163: LD_INT 0
84165: PPUSH
84166: PPUSH
84167: PPUSH
// if not mc_bases or not skirmish then
84168: LD_EXP 23
84172: NOT
84173: IFTRUE 84182
84175: PUSH
84176: LD_EXP 21
84180: NOT
84181: OR
84182: IFFALSE 84186
// exit ;
84184: GO 84401
// for i = 1 to mc_bases do
84186: LD_ADDR_VAR 0 3
84190: PUSH
84191: DOUBLE
84192: LD_INT 1
84194: DEC
84195: ST_TO_ADDR
84196: LD_EXP 23
84200: PUSH
84201: FOR_TO
84202: IFFALSE 84399
// begin if building in mc_construct_list [ i ] then
84204: LD_VAR 0 1
84208: PUSH
84209: LD_EXP 30
84213: PUSH
84214: LD_VAR 0 3
84218: ARRAY
84219: IN
84220: IFFALSE 84397
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84222: LD_ADDR_EXP 30
84226: PUSH
84227: LD_EXP 30
84231: PPUSH
84232: LD_VAR 0 3
84236: PPUSH
84237: LD_EXP 30
84241: PUSH
84242: LD_VAR 0 3
84246: ARRAY
84247: PUSH
84248: LD_VAR 0 1
84252: DIFF
84253: PPUSH
84254: CALL_OW 1
84258: ST_TO_ADDR
// if building in mc_lab [ i ] then
84259: LD_VAR 0 1
84263: PUSH
84264: LD_EXP 56
84268: PUSH
84269: LD_VAR 0 3
84273: ARRAY
84274: IN
84275: IFFALSE 84330
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84277: LD_ADDR_EXP 57
84281: PUSH
84282: LD_EXP 57
84286: PPUSH
84287: LD_VAR 0 3
84291: PPUSH
84292: LD_EXP 57
84296: PUSH
84297: LD_VAR 0 3
84301: ARRAY
84302: PPUSH
84303: LD_INT 1
84305: PPUSH
84306: LD_EXP 57
84310: PUSH
84311: LD_VAR 0 3
84315: ARRAY
84316: PPUSH
84317: LD_INT 0
84319: PPUSH
84320: CALL 15697 0 4
84324: PPUSH
84325: CALL_OW 1
84329: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84330: LD_VAR 0 1
84334: PUSH
84335: LD_EXP 23
84339: PUSH
84340: LD_VAR 0 3
84344: ARRAY
84345: IN
84346: NOT
84347: IFFALSE 84393
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84349: LD_ADDR_EXP 23
84353: PUSH
84354: LD_EXP 23
84358: PPUSH
84359: LD_VAR 0 3
84363: PUSH
84364: LD_EXP 23
84368: PUSH
84369: LD_VAR 0 3
84373: ARRAY
84374: PUSH
84375: LD_INT 1
84377: PLUS
84378: PUSH
84379: EMPTY
84380: LIST
84381: LIST
84382: PPUSH
84383: LD_VAR 0 1
84387: PPUSH
84388: CALL 16289 0 3
84392: ST_TO_ADDR
// exit ;
84393: POP
84394: POP
84395: GO 84401
// end ; end ;
84397: GO 84201
84399: POP
84400: POP
// end ;
84401: LD_VAR 0 2
84405: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84406: LD_INT 0
84408: PPUSH
84409: PPUSH
84410: PPUSH
84411: PPUSH
84412: PPUSH
84413: PPUSH
84414: PPUSH
// if not mc_bases or not skirmish then
84415: LD_EXP 23
84419: NOT
84420: IFTRUE 84429
84422: PUSH
84423: LD_EXP 21
84427: NOT
84428: OR
84429: IFFALSE 84433
// exit ;
84431: GO 85094
// for i = 1 to mc_bases do
84433: LD_ADDR_VAR 0 3
84437: PUSH
84438: DOUBLE
84439: LD_INT 1
84441: DEC
84442: ST_TO_ADDR
84443: LD_EXP 23
84447: PUSH
84448: FOR_TO
84449: IFFALSE 85092
// begin if building in mc_construct_list [ i ] then
84451: LD_VAR 0 1
84455: PUSH
84456: LD_EXP 30
84460: PUSH
84461: LD_VAR 0 3
84465: ARRAY
84466: IN
84467: IFFALSE 85090
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84469: LD_ADDR_EXP 30
84473: PUSH
84474: LD_EXP 30
84478: PPUSH
84479: LD_VAR 0 3
84483: PPUSH
84484: LD_EXP 30
84488: PUSH
84489: LD_VAR 0 3
84493: ARRAY
84494: PUSH
84495: LD_VAR 0 1
84499: DIFF
84500: PPUSH
84501: CALL_OW 1
84505: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84506: LD_ADDR_EXP 23
84510: PUSH
84511: LD_EXP 23
84515: PPUSH
84516: LD_VAR 0 3
84520: PUSH
84521: LD_EXP 23
84525: PUSH
84526: LD_VAR 0 3
84530: ARRAY
84531: PUSH
84532: LD_INT 1
84534: PLUS
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PPUSH
84540: LD_VAR 0 1
84544: PPUSH
84545: CALL 16289 0 3
84549: ST_TO_ADDR
// btype := GetBType ( building ) ;
84550: LD_ADDR_VAR 0 5
84554: PUSH
84555: LD_VAR 0 1
84559: PPUSH
84560: CALL_OW 266
84564: ST_TO_ADDR
// side := GetSide ( building ) ;
84565: LD_ADDR_VAR 0 8
84569: PUSH
84570: LD_VAR 0 1
84574: PPUSH
84575: CALL_OW 255
84579: ST_TO_ADDR
// if btype = b_lab then
84580: LD_VAR 0 5
84584: PUSH
84585: LD_INT 6
84587: EQUAL
84588: IFFALSE 84638
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84590: LD_ADDR_EXP 56
84594: PUSH
84595: LD_EXP 56
84599: PPUSH
84600: LD_VAR 0 3
84604: PUSH
84605: LD_EXP 56
84609: PUSH
84610: LD_VAR 0 3
84614: ARRAY
84615: PUSH
84616: LD_INT 1
84618: PLUS
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PPUSH
84624: LD_VAR 0 1
84628: PPUSH
84629: CALL 16289 0 3
84633: ST_TO_ADDR
// exit ;
84634: POP
84635: POP
84636: GO 85094
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84638: LD_VAR 0 5
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: LD_INT 2
84648: PUSH
84649: LD_INT 4
84651: PUSH
84652: EMPTY
84653: LIST
84654: LIST
84655: LIST
84656: IN
84657: IFFALSE 84781
// begin if btype = b_armoury then
84659: LD_VAR 0 5
84663: PUSH
84664: LD_INT 4
84666: EQUAL
84667: IFFALSE 84677
// btype := b_barracks ;
84669: LD_ADDR_VAR 0 5
84673: PUSH
84674: LD_INT 5
84676: ST_TO_ADDR
// if btype = b_depot then
84677: LD_VAR 0 5
84681: PUSH
84682: LD_INT 0
84684: EQUAL
84685: IFFALSE 84695
// btype := b_warehouse ;
84687: LD_ADDR_VAR 0 5
84691: PUSH
84692: LD_INT 1
84694: ST_TO_ADDR
// if btype = b_workshop then
84695: LD_VAR 0 5
84699: PUSH
84700: LD_INT 2
84702: EQUAL
84703: IFFALSE 84713
// btype := b_factory ;
84705: LD_ADDR_VAR 0 5
84709: PUSH
84710: LD_INT 3
84712: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84713: LD_VAR 0 5
84717: PPUSH
84718: LD_VAR 0 8
84722: PPUSH
84723: CALL_OW 323
84727: PUSH
84728: LD_INT 1
84730: EQUAL
84731: IFFALSE 84777
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84733: LD_ADDR_EXP 55
84737: PUSH
84738: LD_EXP 55
84742: PPUSH
84743: LD_VAR 0 3
84747: PUSH
84748: LD_EXP 55
84752: PUSH
84753: LD_VAR 0 3
84757: ARRAY
84758: PUSH
84759: LD_INT 1
84761: PLUS
84762: PUSH
84763: EMPTY
84764: LIST
84765: LIST
84766: PPUSH
84767: LD_VAR 0 1
84771: PPUSH
84772: CALL 16289 0 3
84776: ST_TO_ADDR
// exit ;
84777: POP
84778: POP
84779: GO 85094
// end ; if btype in [ b_bunker , b_turret ] then
84781: LD_VAR 0 5
84785: PUSH
84786: LD_INT 32
84788: PUSH
84789: LD_INT 33
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: IN
84796: IFFALSE 85086
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84798: LD_ADDR_EXP 31
84802: PUSH
84803: LD_EXP 31
84807: PPUSH
84808: LD_VAR 0 3
84812: PUSH
84813: LD_EXP 31
84817: PUSH
84818: LD_VAR 0 3
84822: ARRAY
84823: PUSH
84824: LD_INT 1
84826: PLUS
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PPUSH
84832: LD_VAR 0 1
84836: PPUSH
84837: CALL 16289 0 3
84841: ST_TO_ADDR
// if btype = b_bunker then
84842: LD_VAR 0 5
84846: PUSH
84847: LD_INT 32
84849: EQUAL
84850: IFFALSE 85086
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84852: LD_ADDR_EXP 32
84856: PUSH
84857: LD_EXP 32
84861: PPUSH
84862: LD_VAR 0 3
84866: PUSH
84867: LD_EXP 32
84871: PUSH
84872: LD_VAR 0 3
84876: ARRAY
84877: PUSH
84878: LD_INT 1
84880: PLUS
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PPUSH
84886: LD_VAR 0 1
84890: PPUSH
84891: CALL 16289 0 3
84895: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84896: LD_ADDR_VAR 0 6
84900: PUSH
84901: LD_EXP 23
84905: PUSH
84906: LD_VAR 0 3
84910: ARRAY
84911: PPUSH
84912: LD_INT 25
84914: PUSH
84915: LD_INT 1
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: PUSH
84922: LD_INT 3
84924: PUSH
84925: LD_INT 54
84927: PUSH
84928: EMPTY
84929: LIST
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PPUSH
84939: CALL_OW 72
84943: ST_TO_ADDR
// if tmp then
84944: LD_VAR 0 6
84948: IFFALSE 84954
// exit ;
84950: POP
84951: POP
84952: GO 85094
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84954: LD_ADDR_VAR 0 6
84958: PUSH
84959: LD_EXP 23
84963: PUSH
84964: LD_VAR 0 3
84968: ARRAY
84969: PPUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 30
84975: PUSH
84976: LD_INT 4
84978: PUSH
84979: EMPTY
84980: LIST
84981: LIST
84982: PUSH
84983: LD_INT 30
84985: PUSH
84986: LD_INT 5
84988: PUSH
84989: EMPTY
84990: LIST
84991: LIST
84992: PUSH
84993: EMPTY
84994: LIST
84995: LIST
84996: LIST
84997: PPUSH
84998: CALL_OW 72
85002: ST_TO_ADDR
// if not tmp then
85003: LD_VAR 0 6
85007: NOT
85008: IFFALSE 85014
// exit ;
85010: POP
85011: POP
85012: GO 85094
// for j in tmp do
85014: LD_ADDR_VAR 0 4
85018: PUSH
85019: LD_VAR 0 6
85023: PUSH
85024: FOR_IN
85025: IFFALSE 85084
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85027: LD_ADDR_VAR 0 7
85031: PUSH
85032: LD_VAR 0 4
85036: PPUSH
85037: CALL_OW 313
85041: PPUSH
85042: LD_INT 25
85044: PUSH
85045: LD_INT 1
85047: PUSH
85048: EMPTY
85049: LIST
85050: LIST
85051: PPUSH
85052: CALL_OW 72
85056: ST_TO_ADDR
// if units then
85057: LD_VAR 0 7
85061: IFFALSE 85082
// begin ComExitBuilding ( units [ 1 ] ) ;
85063: LD_VAR 0 7
85067: PUSH
85068: LD_INT 1
85070: ARRAY
85071: PPUSH
85072: CALL_OW 122
// exit ;
85076: POP
85077: POP
85078: POP
85079: POP
85080: GO 85094
// end ; end ;
85082: GO 85024
85084: POP
85085: POP
// end ; end ; exit ;
85086: POP
85087: POP
85088: GO 85094
// end ; end ;
85090: GO 84448
85092: POP
85093: POP
// end ;
85094: LD_VAR 0 2
85098: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85099: LD_INT 0
85101: PPUSH
85102: PPUSH
85103: PPUSH
85104: PPUSH
85105: PPUSH
85106: PPUSH
85107: PPUSH
// if not mc_bases or not skirmish then
85108: LD_EXP 23
85112: NOT
85113: IFTRUE 85122
85115: PUSH
85116: LD_EXP 21
85120: NOT
85121: OR
85122: IFFALSE 85126
// exit ;
85124: GO 85391
// btype := GetBType ( building ) ;
85126: LD_ADDR_VAR 0 6
85130: PUSH
85131: LD_VAR 0 1
85135: PPUSH
85136: CALL_OW 266
85140: ST_TO_ADDR
// x := GetX ( building ) ;
85141: LD_ADDR_VAR 0 7
85145: PUSH
85146: LD_VAR 0 1
85150: PPUSH
85151: CALL_OW 250
85155: ST_TO_ADDR
// y := GetY ( building ) ;
85156: LD_ADDR_VAR 0 8
85160: PUSH
85161: LD_VAR 0 1
85165: PPUSH
85166: CALL_OW 251
85170: ST_TO_ADDR
// d := GetDir ( building ) ;
85171: LD_ADDR_VAR 0 9
85175: PUSH
85176: LD_VAR 0 1
85180: PPUSH
85181: CALL_OW 254
85185: ST_TO_ADDR
// for i = 1 to mc_bases do
85186: LD_ADDR_VAR 0 4
85190: PUSH
85191: DOUBLE
85192: LD_INT 1
85194: DEC
85195: ST_TO_ADDR
85196: LD_EXP 23
85200: PUSH
85201: FOR_TO
85202: IFFALSE 85389
// begin if not mc_build_list [ i ] then
85204: LD_EXP 28
85208: PUSH
85209: LD_VAR 0 4
85213: ARRAY
85214: NOT
85215: IFFALSE 85219
// continue ;
85217: GO 85201
// for j := 1 to mc_build_list [ i ] do
85219: LD_ADDR_VAR 0 5
85223: PUSH
85224: DOUBLE
85225: LD_INT 1
85227: DEC
85228: ST_TO_ADDR
85229: LD_EXP 28
85233: PUSH
85234: LD_VAR 0 4
85238: ARRAY
85239: PUSH
85240: FOR_TO
85241: IFFALSE 85385
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85243: LD_VAR 0 6
85247: PUSH
85248: LD_VAR 0 7
85252: PUSH
85253: LD_VAR 0 8
85257: PUSH
85258: LD_VAR 0 9
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: PPUSH
85269: LD_EXP 28
85273: PUSH
85274: LD_VAR 0 4
85278: ARRAY
85279: PUSH
85280: LD_VAR 0 5
85284: ARRAY
85285: PPUSH
85286: CALL 22896 0 2
85290: IFFALSE 85383
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85292: LD_ADDR_EXP 28
85296: PUSH
85297: LD_EXP 28
85301: PPUSH
85302: LD_VAR 0 4
85306: PPUSH
85307: LD_EXP 28
85311: PUSH
85312: LD_VAR 0 4
85316: ARRAY
85317: PPUSH
85318: LD_VAR 0 5
85322: PPUSH
85323: CALL_OW 3
85327: PPUSH
85328: CALL_OW 1
85332: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85333: LD_ADDR_EXP 30
85337: PUSH
85338: LD_EXP 30
85342: PPUSH
85343: LD_VAR 0 4
85347: PUSH
85348: LD_EXP 30
85352: PUSH
85353: LD_VAR 0 4
85357: ARRAY
85358: PUSH
85359: LD_INT 1
85361: PLUS
85362: PUSH
85363: EMPTY
85364: LIST
85365: LIST
85366: PPUSH
85367: LD_VAR 0 1
85371: PPUSH
85372: CALL 16289 0 3
85376: ST_TO_ADDR
// exit ;
85377: POP
85378: POP
85379: POP
85380: POP
85381: GO 85391
// end ;
85383: GO 85240
85385: POP
85386: POP
// end ;
85387: GO 85201
85389: POP
85390: POP
// end ;
85391: LD_VAR 0 3
85395: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85396: LD_INT 0
85398: PPUSH
85399: PPUSH
85400: PPUSH
// if not mc_bases or not skirmish then
85401: LD_EXP 23
85405: NOT
85406: IFTRUE 85415
85408: PUSH
85409: LD_EXP 21
85413: NOT
85414: OR
85415: IFFALSE 85419
// exit ;
85417: GO 85615
// for i = 1 to mc_bases do
85419: LD_ADDR_VAR 0 4
85423: PUSH
85424: DOUBLE
85425: LD_INT 1
85427: DEC
85428: ST_TO_ADDR
85429: LD_EXP 23
85433: PUSH
85434: FOR_TO
85435: IFFALSE 85524
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85437: LD_VAR 0 1
85441: PUSH
85442: LD_EXP 31
85446: PUSH
85447: LD_VAR 0 4
85451: ARRAY
85452: IN
85453: IFFALSE 85474
85455: PUSH
85456: LD_VAR 0 1
85460: PUSH
85461: LD_EXP 32
85465: PUSH
85466: LD_VAR 0 4
85470: ARRAY
85471: IN
85472: NOT
85473: AND
85474: IFFALSE 85522
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85476: LD_ADDR_EXP 32
85480: PUSH
85481: LD_EXP 32
85485: PPUSH
85486: LD_VAR 0 4
85490: PUSH
85491: LD_EXP 32
85495: PUSH
85496: LD_VAR 0 4
85500: ARRAY
85501: PUSH
85502: LD_INT 1
85504: PLUS
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PPUSH
85510: LD_VAR 0 1
85514: PPUSH
85515: CALL 16289 0 3
85519: ST_TO_ADDR
// break ;
85520: GO 85524
// end ; end ;
85522: GO 85434
85524: POP
85525: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85526: LD_VAR 0 1
85530: PPUSH
85531: CALL_OW 257
85535: PUSH
85536: LD_EXP 49
85540: IN
85541: IFFALSE 85558
85543: PUSH
85544: LD_VAR 0 1
85548: PPUSH
85549: CALL_OW 266
85553: PUSH
85554: LD_INT 5
85556: EQUAL
85557: AND
85558: IFFALSE 85575
85560: PUSH
85561: LD_VAR 0 2
85565: PPUSH
85566: CALL_OW 110
85570: PUSH
85571: LD_INT 18
85573: NONEQUAL
85574: AND
85575: IFFALSE 85615
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85577: LD_VAR 0 2
85581: PPUSH
85582: CALL_OW 257
85586: PUSH
85587: LD_INT 5
85589: PUSH
85590: LD_INT 8
85592: PUSH
85593: LD_INT 9
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: LIST
85600: IN
85601: IFFALSE 85615
// SetClass ( unit , 1 ) ;
85603: LD_VAR 0 2
85607: PPUSH
85608: LD_INT 1
85610: PPUSH
85611: CALL_OW 336
// end ;
85615: LD_VAR 0 3
85619: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85620: LD_INT 0
85622: PPUSH
85623: PPUSH
// if not mc_bases or not skirmish then
85624: LD_EXP 23
85628: NOT
85629: IFTRUE 85638
85631: PUSH
85632: LD_EXP 21
85636: NOT
85637: OR
85638: IFFALSE 85642
// exit ;
85640: GO 85758
// if GetLives ( abandoned_vehicle ) > 250 then
85642: LD_VAR 0 2
85646: PPUSH
85647: CALL_OW 256
85651: PUSH
85652: LD_INT 250
85654: GREATER
85655: IFFALSE 85659
// exit ;
85657: GO 85758
// for i = 1 to mc_bases do
85659: LD_ADDR_VAR 0 6
85663: PUSH
85664: DOUBLE
85665: LD_INT 1
85667: DEC
85668: ST_TO_ADDR
85669: LD_EXP 23
85673: PUSH
85674: FOR_TO
85675: IFFALSE 85756
// begin if driver in mc_bases [ i ] then
85677: LD_VAR 0 1
85681: PUSH
85682: LD_EXP 23
85686: PUSH
85687: LD_VAR 0 6
85691: ARRAY
85692: IN
85693: IFFALSE 85754
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85695: LD_VAR 0 1
85699: PPUSH
85700: LD_EXP 23
85704: PUSH
85705: LD_VAR 0 6
85709: ARRAY
85710: PPUSH
85711: LD_INT 2
85713: PUSH
85714: LD_INT 30
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: EMPTY
85721: LIST
85722: LIST
85723: PUSH
85724: LD_INT 30
85726: PUSH
85727: LD_INT 1
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: LIST
85738: PPUSH
85739: CALL_OW 72
85743: PUSH
85744: LD_INT 1
85746: ARRAY
85747: PPUSH
85748: CALL 50226 0 2
// break ;
85752: GO 85756
// end ; end ;
85754: GO 85674
85756: POP
85757: POP
// end ; end_of_file
85758: LD_VAR 0 5
85762: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85763: LD_INT 0
85765: PPUSH
85766: PPUSH
85767: PPUSH
85768: PPUSH
85769: PPUSH
85770: PPUSH
85771: PPUSH
85772: PPUSH
85773: PPUSH
85774: PPUSH
85775: PPUSH
85776: PPUSH
85777: PPUSH
85778: PPUSH
85779: PPUSH
85780: PPUSH
85781: PPUSH
85782: PPUSH
85783: PPUSH
85784: PPUSH
85785: PPUSH
85786: PPUSH
85787: PPUSH
85788: PPUSH
85789: PPUSH
85790: PPUSH
85791: PPUSH
85792: PPUSH
85793: PPUSH
85794: PPUSH
85795: PPUSH
85796: PPUSH
85797: PPUSH
85798: PPUSH
// if not list then
85799: LD_VAR 0 1
85803: NOT
85804: IFFALSE 85808
// exit ;
85806: GO 90527
// base := list [ 1 ] ;
85808: LD_ADDR_VAR 0 3
85812: PUSH
85813: LD_VAR 0 1
85817: PUSH
85818: LD_INT 1
85820: ARRAY
85821: ST_TO_ADDR
// group := list [ 2 ] ;
85822: LD_ADDR_VAR 0 4
85826: PUSH
85827: LD_VAR 0 1
85831: PUSH
85832: LD_INT 2
85834: ARRAY
85835: ST_TO_ADDR
// path := list [ 3 ] ;
85836: LD_ADDR_VAR 0 5
85840: PUSH
85841: LD_VAR 0 1
85845: PUSH
85846: LD_INT 3
85848: ARRAY
85849: ST_TO_ADDR
// flags := list [ 4 ] ;
85850: LD_ADDR_VAR 0 6
85854: PUSH
85855: LD_VAR 0 1
85859: PUSH
85860: LD_INT 4
85862: ARRAY
85863: ST_TO_ADDR
// mined := [ ] ;
85864: LD_ADDR_VAR 0 27
85868: PUSH
85869: EMPTY
85870: ST_TO_ADDR
// bombed := [ ] ;
85871: LD_ADDR_VAR 0 28
85875: PUSH
85876: EMPTY
85877: ST_TO_ADDR
// healers := [ ] ;
85878: LD_ADDR_VAR 0 31
85882: PUSH
85883: EMPTY
85884: ST_TO_ADDR
// to_heal := [ ] ;
85885: LD_ADDR_VAR 0 30
85889: PUSH
85890: EMPTY
85891: ST_TO_ADDR
// repairs := [ ] ;
85892: LD_ADDR_VAR 0 33
85896: PUSH
85897: EMPTY
85898: ST_TO_ADDR
// to_repair := [ ] ;
85899: LD_ADDR_VAR 0 32
85903: PUSH
85904: EMPTY
85905: ST_TO_ADDR
// if not group or not path then
85906: LD_VAR 0 4
85910: NOT
85911: IFTRUE 85920
85913: PUSH
85914: LD_VAR 0 5
85918: NOT
85919: OR
85920: IFFALSE 85924
// exit ;
85922: GO 90527
// side := GetSide ( group [ 1 ] ) ;
85924: LD_ADDR_VAR 0 35
85928: PUSH
85929: LD_VAR 0 4
85933: PUSH
85934: LD_INT 1
85936: ARRAY
85937: PPUSH
85938: CALL_OW 255
85942: ST_TO_ADDR
// if flags then
85943: LD_VAR 0 6
85947: IFFALSE 86091
// begin f_ignore_area := flags [ 1 ] ;
85949: LD_ADDR_VAR 0 17
85953: PUSH
85954: LD_VAR 0 6
85958: PUSH
85959: LD_INT 1
85961: ARRAY
85962: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
85963: LD_ADDR_VAR 0 18
85967: PUSH
85968: LD_VAR 0 6
85972: PUSH
85973: LD_INT 2
85975: ARRAY
85976: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
85977: LD_ADDR_VAR 0 19
85981: PUSH
85982: LD_VAR 0 6
85986: PUSH
85987: LD_INT 3
85989: ARRAY
85990: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
85991: LD_ADDR_VAR 0 20
85995: PUSH
85996: LD_VAR 0 6
86000: PUSH
86001: LD_INT 4
86003: ARRAY
86004: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
86005: LD_ADDR_VAR 0 21
86009: PUSH
86010: LD_VAR 0 6
86014: PUSH
86015: LD_INT 5
86017: ARRAY
86018: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
86019: LD_ADDR_VAR 0 22
86023: PUSH
86024: LD_VAR 0 6
86028: PUSH
86029: LD_INT 6
86031: ARRAY
86032: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
86033: LD_ADDR_VAR 0 23
86037: PUSH
86038: LD_VAR 0 6
86042: PUSH
86043: LD_INT 7
86045: ARRAY
86046: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86047: LD_ADDR_VAR 0 24
86051: PUSH
86052: LD_VAR 0 6
86056: PUSH
86057: LD_INT 8
86059: ARRAY
86060: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86061: LD_ADDR_VAR 0 25
86065: PUSH
86066: LD_VAR 0 6
86070: PUSH
86071: LD_INT 9
86073: ARRAY
86074: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86075: LD_ADDR_VAR 0 26
86079: PUSH
86080: LD_VAR 0 6
86084: PUSH
86085: LD_INT 10
86087: ARRAY
86088: ST_TO_ADDR
// end else
86089: GO 86171
// begin f_ignore_area := false ;
86091: LD_ADDR_VAR 0 17
86095: PUSH
86096: LD_INT 0
86098: ST_TO_ADDR
// f_capture := false ;
86099: LD_ADDR_VAR 0 18
86103: PUSH
86104: LD_INT 0
86106: ST_TO_ADDR
// f_ignore_civ := false ;
86107: LD_ADDR_VAR 0 19
86111: PUSH
86112: LD_INT 0
86114: ST_TO_ADDR
// f_murder := false ;
86115: LD_ADDR_VAR 0 20
86119: PUSH
86120: LD_INT 0
86122: ST_TO_ADDR
// f_mines := false ;
86123: LD_ADDR_VAR 0 21
86127: PUSH
86128: LD_INT 0
86130: ST_TO_ADDR
// f_repair := false ;
86131: LD_ADDR_VAR 0 22
86135: PUSH
86136: LD_INT 0
86138: ST_TO_ADDR
// f_heal := false ;
86139: LD_ADDR_VAR 0 23
86143: PUSH
86144: LD_INT 0
86146: ST_TO_ADDR
// f_spacetime := false ;
86147: LD_ADDR_VAR 0 24
86151: PUSH
86152: LD_INT 0
86154: ST_TO_ADDR
// f_attack_depot := false ;
86155: LD_ADDR_VAR 0 25
86159: PUSH
86160: LD_INT 0
86162: ST_TO_ADDR
// f_crawl := false ;
86163: LD_ADDR_VAR 0 26
86167: PUSH
86168: LD_INT 0
86170: ST_TO_ADDR
// end ; if f_heal then
86171: LD_VAR 0 23
86175: IFFALSE 86202
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86177: LD_ADDR_VAR 0 31
86181: PUSH
86182: LD_VAR 0 4
86186: PPUSH
86187: LD_INT 25
86189: PUSH
86190: LD_INT 4
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PPUSH
86197: CALL_OW 72
86201: ST_TO_ADDR
// if f_repair then
86202: LD_VAR 0 22
86206: IFFALSE 86233
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86208: LD_ADDR_VAR 0 33
86212: PUSH
86213: LD_VAR 0 4
86217: PPUSH
86218: LD_INT 25
86220: PUSH
86221: LD_INT 3
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PPUSH
86228: CALL_OW 72
86232: ST_TO_ADDR
// units_path := [ ] ;
86233: LD_ADDR_VAR 0 16
86237: PUSH
86238: EMPTY
86239: ST_TO_ADDR
// for i = 1 to group do
86240: LD_ADDR_VAR 0 7
86244: PUSH
86245: DOUBLE
86246: LD_INT 1
86248: DEC
86249: ST_TO_ADDR
86250: LD_VAR 0 4
86254: PUSH
86255: FOR_TO
86256: IFFALSE 86285
// units_path := Replace ( units_path , i , path ) ;
86258: LD_ADDR_VAR 0 16
86262: PUSH
86263: LD_VAR 0 16
86267: PPUSH
86268: LD_VAR 0 7
86272: PPUSH
86273: LD_VAR 0 5
86277: PPUSH
86278: CALL_OW 1
86282: ST_TO_ADDR
86283: GO 86255
86285: POP
86286: POP
// repeat for i = group downto 1 do
86287: LD_ADDR_VAR 0 7
86291: PUSH
86292: DOUBLE
86293: LD_VAR 0 4
86297: INC
86298: ST_TO_ADDR
86299: LD_INT 1
86301: PUSH
86302: FOR_DOWNTO
86303: IFFALSE 90479
// begin wait ( 5 ) ;
86305: LD_INT 5
86307: PPUSH
86308: CALL_OW 67
// tmp := [ ] ;
86312: LD_ADDR_VAR 0 14
86316: PUSH
86317: EMPTY
86318: ST_TO_ADDR
// attacking := false ;
86319: LD_ADDR_VAR 0 29
86323: PUSH
86324: LD_INT 0
86326: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86327: LD_VAR 0 4
86331: PUSH
86332: LD_VAR 0 7
86336: ARRAY
86337: PPUSH
86338: CALL_OW 301
86342: IFTRUE 86357
86344: PUSH
86345: LD_VAR 0 4
86349: PUSH
86350: LD_VAR 0 7
86354: ARRAY
86355: NOT
86356: OR
86357: IFFALSE 86466
// begin if GetType ( group [ i ] ) = unit_human then
86359: LD_VAR 0 4
86363: PUSH
86364: LD_VAR 0 7
86368: ARRAY
86369: PPUSH
86370: CALL_OW 247
86374: PUSH
86375: LD_INT 1
86377: EQUAL
86378: IFFALSE 86424
// begin to_heal := to_heal diff group [ i ] ;
86380: LD_ADDR_VAR 0 30
86384: PUSH
86385: LD_VAR 0 30
86389: PUSH
86390: LD_VAR 0 4
86394: PUSH
86395: LD_VAR 0 7
86399: ARRAY
86400: DIFF
86401: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86402: LD_ADDR_VAR 0 31
86406: PUSH
86407: LD_VAR 0 31
86411: PUSH
86412: LD_VAR 0 4
86416: PUSH
86417: LD_VAR 0 7
86421: ARRAY
86422: DIFF
86423: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86424: LD_ADDR_VAR 0 4
86428: PUSH
86429: LD_VAR 0 4
86433: PPUSH
86434: LD_VAR 0 7
86438: PPUSH
86439: CALL_OW 3
86443: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86444: LD_ADDR_VAR 0 16
86448: PUSH
86449: LD_VAR 0 16
86453: PPUSH
86454: LD_VAR 0 7
86458: PPUSH
86459: CALL_OW 3
86463: ST_TO_ADDR
// continue ;
86464: GO 86302
// end ; if f_repair then
86466: LD_VAR 0 22
86470: IFFALSE 86967
// begin if GetType ( group [ i ] ) = unit_vehicle then
86472: LD_VAR 0 4
86476: PUSH
86477: LD_VAR 0 7
86481: ARRAY
86482: PPUSH
86483: CALL_OW 247
86487: PUSH
86488: LD_INT 2
86490: EQUAL
86491: IFFALSE 86685
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86493: LD_VAR 0 4
86497: PUSH
86498: LD_VAR 0 7
86502: ARRAY
86503: PPUSH
86504: CALL_OW 256
86508: PUSH
86509: LD_INT 700
86511: LESS
86512: IFFALSE 86533
86514: PUSH
86515: LD_VAR 0 4
86519: PUSH
86520: LD_VAR 0 7
86524: ARRAY
86525: PUSH
86526: LD_VAR 0 32
86530: IN
86531: NOT
86532: AND
86533: IFFALSE 86557
// to_repair := to_repair union group [ i ] ;
86535: LD_ADDR_VAR 0 32
86539: PUSH
86540: LD_VAR 0 32
86544: PUSH
86545: LD_VAR 0 4
86549: PUSH
86550: LD_VAR 0 7
86554: ARRAY
86555: UNION
86556: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86557: LD_VAR 0 4
86561: PUSH
86562: LD_VAR 0 7
86566: ARRAY
86567: PPUSH
86568: CALL_OW 256
86572: PUSH
86573: LD_INT 1000
86575: EQUAL
86576: IFFALSE 86596
86578: PUSH
86579: LD_VAR 0 4
86583: PUSH
86584: LD_VAR 0 7
86588: ARRAY
86589: PUSH
86590: LD_VAR 0 32
86594: IN
86595: AND
86596: IFFALSE 86620
// to_repair := to_repair diff group [ i ] ;
86598: LD_ADDR_VAR 0 32
86602: PUSH
86603: LD_VAR 0 32
86607: PUSH
86608: LD_VAR 0 4
86612: PUSH
86613: LD_VAR 0 7
86617: ARRAY
86618: DIFF
86619: ST_TO_ADDR
// if group [ i ] in to_repair then
86620: LD_VAR 0 4
86624: PUSH
86625: LD_VAR 0 7
86629: ARRAY
86630: PUSH
86631: LD_VAR 0 32
86635: IN
86636: IFFALSE 86683
// begin if not IsInArea ( group [ i ] , f_repair ) then
86638: LD_VAR 0 4
86642: PUSH
86643: LD_VAR 0 7
86647: ARRAY
86648: PPUSH
86649: LD_VAR 0 22
86653: PPUSH
86654: CALL_OW 308
86658: NOT
86659: IFFALSE 86681
// ComMoveToArea ( group [ i ] , f_repair ) ;
86661: LD_VAR 0 4
86665: PUSH
86666: LD_VAR 0 7
86670: ARRAY
86671: PPUSH
86672: LD_VAR 0 22
86676: PPUSH
86677: CALL_OW 113
// continue ;
86681: GO 86302
// end ; end else
86683: GO 86967
// if group [ i ] in repairs then
86685: LD_VAR 0 4
86689: PUSH
86690: LD_VAR 0 7
86694: ARRAY
86695: PUSH
86696: LD_VAR 0 33
86700: IN
86701: IFFALSE 86967
// begin if IsInUnit ( group [ i ] ) then
86703: LD_VAR 0 4
86707: PUSH
86708: LD_VAR 0 7
86712: ARRAY
86713: PPUSH
86714: CALL_OW 310
86718: IFFALSE 86788
// begin z := IsInUnit ( group [ i ] ) ;
86720: LD_ADDR_VAR 0 13
86724: PUSH
86725: LD_VAR 0 4
86729: PUSH
86730: LD_VAR 0 7
86734: ARRAY
86735: PPUSH
86736: CALL_OW 310
86740: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86741: LD_VAR 0 13
86745: PUSH
86746: LD_VAR 0 32
86750: IN
86751: IFFALSE 86769
86753: PUSH
86754: LD_VAR 0 13
86758: PPUSH
86759: LD_VAR 0 22
86763: PPUSH
86764: CALL_OW 308
86768: AND
86769: IFFALSE 86786
// ComExitVehicle ( group [ i ] ) ;
86771: LD_VAR 0 4
86775: PUSH
86776: LD_VAR 0 7
86780: ARRAY
86781: PPUSH
86782: CALL_OW 121
// end else
86786: GO 86967
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86788: LD_ADDR_VAR 0 13
86792: PUSH
86793: LD_VAR 0 4
86797: PPUSH
86798: LD_INT 95
86800: PUSH
86801: LD_VAR 0 22
86805: PUSH
86806: EMPTY
86807: LIST
86808: LIST
86809: PUSH
86810: LD_INT 58
86812: PUSH
86813: EMPTY
86814: LIST
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PPUSH
86820: CALL_OW 72
86824: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86825: LD_VAR 0 4
86829: PUSH
86830: LD_VAR 0 7
86834: ARRAY
86835: PPUSH
86836: CALL_OW 314
86840: NOT
86841: IFFALSE 86965
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86843: LD_ADDR_VAR 0 10
86847: PUSH
86848: LD_VAR 0 13
86852: PPUSH
86853: LD_VAR 0 4
86857: PUSH
86858: LD_VAR 0 7
86862: ARRAY
86863: PPUSH
86864: CALL_OW 74
86868: ST_TO_ADDR
// if not x then
86869: LD_VAR 0 10
86873: NOT
86874: IFFALSE 86878
// continue ;
86876: GO 86302
// if GetLives ( x ) < 1000 then
86878: LD_VAR 0 10
86882: PPUSH
86883: CALL_OW 256
86887: PUSH
86888: LD_INT 1000
86890: LESS
86891: IFFALSE 86915
// ComRepairVehicle ( group [ i ] , x ) else
86893: LD_VAR 0 4
86897: PUSH
86898: LD_VAR 0 7
86902: ARRAY
86903: PPUSH
86904: LD_VAR 0 10
86908: PPUSH
86909: CALL_OW 129
86913: GO 86965
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
86915: LD_VAR 0 23
86919: IFFALSE 86942
86921: PUSH
86922: LD_VAR 0 4
86926: PUSH
86927: LD_VAR 0 7
86931: ARRAY
86932: PPUSH
86933: CALL_OW 256
86937: PUSH
86938: LD_INT 1000
86940: LESS
86941: AND
86942: NOT
86943: IFFALSE 86965
// ComEnterUnit ( group [ i ] , x ) ;
86945: LD_VAR 0 4
86949: PUSH
86950: LD_VAR 0 7
86954: ARRAY
86955: PPUSH
86956: LD_VAR 0 10
86960: PPUSH
86961: CALL_OW 120
// end ; continue ;
86965: GO 86302
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
86967: LD_VAR 0 23
86971: IFFALSE 86994
86973: PUSH
86974: LD_VAR 0 4
86978: PUSH
86979: LD_VAR 0 7
86983: ARRAY
86984: PPUSH
86985: CALL_OW 247
86989: PUSH
86990: LD_INT 1
86992: EQUAL
86993: AND
86994: IFFALSE 87478
// begin if group [ i ] in healers then
86996: LD_VAR 0 4
87000: PUSH
87001: LD_VAR 0 7
87005: ARRAY
87006: PUSH
87007: LD_VAR 0 31
87011: IN
87012: IFFALSE 87289
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
87014: LD_VAR 0 4
87018: PUSH
87019: LD_VAR 0 7
87023: ARRAY
87024: PPUSH
87025: LD_VAR 0 23
87029: PPUSH
87030: CALL_OW 308
87034: NOT
87035: IFFALSE 87055
87037: PUSH
87038: LD_VAR 0 4
87042: PUSH
87043: LD_VAR 0 7
87047: ARRAY
87048: PPUSH
87049: CALL_OW 314
87053: NOT
87054: AND
87055: IFFALSE 87079
// ComMoveToArea ( group [ i ] , f_heal ) else
87057: LD_VAR 0 4
87061: PUSH
87062: LD_VAR 0 7
87066: ARRAY
87067: PPUSH
87068: LD_VAR 0 23
87072: PPUSH
87073: CALL_OW 113
87077: GO 87287
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87079: LD_VAR 0 4
87083: PUSH
87084: LD_VAR 0 7
87088: ARRAY
87089: PPUSH
87090: CALL 46703 0 1
87094: PPUSH
87095: CALL_OW 256
87099: PUSH
87100: LD_INT 1000
87102: EQUAL
87103: IFFALSE 87122
// ComStop ( group [ i ] ) else
87105: LD_VAR 0 4
87109: PUSH
87110: LD_VAR 0 7
87114: ARRAY
87115: PPUSH
87116: CALL_OW 141
87120: GO 87287
// if not HasTask ( group [ i ] ) and to_heal then
87122: LD_VAR 0 4
87126: PUSH
87127: LD_VAR 0 7
87131: ARRAY
87132: PPUSH
87133: CALL_OW 314
87137: NOT
87138: IFFALSE 87146
87140: PUSH
87141: LD_VAR 0 30
87145: AND
87146: IFFALSE 87287
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87148: LD_ADDR_VAR 0 13
87152: PUSH
87153: LD_VAR 0 30
87157: PPUSH
87158: LD_INT 3
87160: PUSH
87161: LD_INT 54
87163: PUSH
87164: EMPTY
87165: LIST
87166: PUSH
87167: EMPTY
87168: LIST
87169: LIST
87170: PPUSH
87171: CALL_OW 72
87175: PPUSH
87176: LD_VAR 0 4
87180: PUSH
87181: LD_VAR 0 7
87185: ARRAY
87186: PPUSH
87187: CALL_OW 74
87191: ST_TO_ADDR
// if z then
87192: LD_VAR 0 13
87196: IFFALSE 87287
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87198: LD_INT 91
87200: PUSH
87201: LD_VAR 0 13
87205: PUSH
87206: LD_INT 10
87208: PUSH
87209: EMPTY
87210: LIST
87211: LIST
87212: LIST
87213: PUSH
87214: LD_INT 81
87216: PUSH
87217: LD_VAR 0 13
87221: PPUSH
87222: CALL_OW 255
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PPUSH
87235: CALL_OW 69
87239: PUSH
87240: LD_INT 0
87242: EQUAL
87243: IFFALSE 87267
// ComHeal ( group [ i ] , z ) else
87245: LD_VAR 0 4
87249: PUSH
87250: LD_VAR 0 7
87254: ARRAY
87255: PPUSH
87256: LD_VAR 0 13
87260: PPUSH
87261: CALL_OW 128
87265: GO 87287
// ComMoveToArea ( group [ i ] , f_heal ) ;
87267: LD_VAR 0 4
87271: PUSH
87272: LD_VAR 0 7
87276: ARRAY
87277: PPUSH
87278: LD_VAR 0 23
87282: PPUSH
87283: CALL_OW 113
// end ; continue ;
87287: GO 86302
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87289: LD_VAR 0 4
87293: PUSH
87294: LD_VAR 0 7
87298: ARRAY
87299: PPUSH
87300: CALL_OW 256
87304: PUSH
87305: LD_INT 700
87307: LESS
87308: IFFALSE 87329
87310: PUSH
87311: LD_VAR 0 4
87315: PUSH
87316: LD_VAR 0 7
87320: ARRAY
87321: PUSH
87322: LD_VAR 0 30
87326: IN
87327: NOT
87328: AND
87329: IFFALSE 87353
// to_heal := to_heal union group [ i ] ;
87331: LD_ADDR_VAR 0 30
87335: PUSH
87336: LD_VAR 0 30
87340: PUSH
87341: LD_VAR 0 4
87345: PUSH
87346: LD_VAR 0 7
87350: ARRAY
87351: UNION
87352: ST_TO_ADDR
// if group [ i ] in to_heal then
87353: LD_VAR 0 4
87357: PUSH
87358: LD_VAR 0 7
87362: ARRAY
87363: PUSH
87364: LD_VAR 0 30
87368: IN
87369: IFFALSE 87478
// begin if GetLives ( group [ i ] ) = 1000 then
87371: LD_VAR 0 4
87375: PUSH
87376: LD_VAR 0 7
87380: ARRAY
87381: PPUSH
87382: CALL_OW 256
87386: PUSH
87387: LD_INT 1000
87389: EQUAL
87390: IFFALSE 87416
// to_heal := to_heal diff group [ i ] else
87392: LD_ADDR_VAR 0 30
87396: PUSH
87397: LD_VAR 0 30
87401: PUSH
87402: LD_VAR 0 4
87406: PUSH
87407: LD_VAR 0 7
87411: ARRAY
87412: DIFF
87413: ST_TO_ADDR
87414: GO 87478
// begin if not IsInArea ( group [ i ] , to_heal ) then
87416: LD_VAR 0 4
87420: PUSH
87421: LD_VAR 0 7
87425: ARRAY
87426: PPUSH
87427: LD_VAR 0 30
87431: PPUSH
87432: CALL_OW 308
87436: NOT
87437: IFFALSE 87461
// ComMoveToArea ( group [ i ] , f_heal ) else
87439: LD_VAR 0 4
87443: PUSH
87444: LD_VAR 0 7
87448: ARRAY
87449: PPUSH
87450: LD_VAR 0 23
87454: PPUSH
87455: CALL_OW 113
87459: GO 87476
// ComHold ( group [ i ] ) ;
87461: LD_VAR 0 4
87465: PUSH
87466: LD_VAR 0 7
87470: ARRAY
87471: PPUSH
87472: CALL_OW 140
// continue ;
87476: GO 86302
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87478: LD_VAR 0 4
87482: PUSH
87483: LD_VAR 0 7
87487: ARRAY
87488: PPUSH
87489: LD_INT 10
87491: PPUSH
87492: CALL 44302 0 2
87496: NOT
87497: IFFALSE 87515
87499: PUSH
87500: LD_VAR 0 16
87504: PUSH
87505: LD_VAR 0 7
87509: ARRAY
87510: PUSH
87511: EMPTY
87512: EQUAL
87513: NOT
87514: AND
87515: IFFALSE 87781
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87517: LD_VAR 0 4
87521: PUSH
87522: LD_VAR 0 7
87526: ARRAY
87527: PPUSH
87528: CALL_OW 262
87532: PUSH
87533: LD_INT 1
87535: PUSH
87536: LD_INT 2
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: IN
87543: IFFALSE 87584
// if GetFuel ( group [ i ] ) < 10 then
87545: LD_VAR 0 4
87549: PUSH
87550: LD_VAR 0 7
87554: ARRAY
87555: PPUSH
87556: CALL_OW 261
87560: PUSH
87561: LD_INT 10
87563: LESS
87564: IFFALSE 87584
// SetFuel ( group [ i ] , 12 ) ;
87566: LD_VAR 0 4
87570: PUSH
87571: LD_VAR 0 7
87575: ARRAY
87576: PPUSH
87577: LD_INT 12
87579: PPUSH
87580: CALL_OW 240
// if units_path [ i ] then
87584: LD_VAR 0 16
87588: PUSH
87589: LD_VAR 0 7
87593: ARRAY
87594: IFFALSE 87779
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87596: LD_VAR 0 4
87600: PUSH
87601: LD_VAR 0 7
87605: ARRAY
87606: PPUSH
87607: LD_VAR 0 16
87611: PUSH
87612: LD_VAR 0 7
87616: ARRAY
87617: PUSH
87618: LD_INT 1
87620: ARRAY
87621: PUSH
87622: LD_INT 1
87624: ARRAY
87625: PPUSH
87626: LD_VAR 0 16
87630: PUSH
87631: LD_VAR 0 7
87635: ARRAY
87636: PUSH
87637: LD_INT 1
87639: ARRAY
87640: PUSH
87641: LD_INT 2
87643: ARRAY
87644: PPUSH
87645: CALL_OW 297
87649: PUSH
87650: LD_INT 6
87652: GREATER
87653: IFFALSE 87728
// begin if not HasTask ( group [ i ] ) then
87655: LD_VAR 0 4
87659: PUSH
87660: LD_VAR 0 7
87664: ARRAY
87665: PPUSH
87666: CALL_OW 314
87670: NOT
87671: IFFALSE 87726
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87673: LD_VAR 0 4
87677: PUSH
87678: LD_VAR 0 7
87682: ARRAY
87683: PPUSH
87684: LD_VAR 0 16
87688: PUSH
87689: LD_VAR 0 7
87693: ARRAY
87694: PUSH
87695: LD_INT 1
87697: ARRAY
87698: PUSH
87699: LD_INT 1
87701: ARRAY
87702: PPUSH
87703: LD_VAR 0 16
87707: PUSH
87708: LD_VAR 0 7
87712: ARRAY
87713: PUSH
87714: LD_INT 1
87716: ARRAY
87717: PUSH
87718: LD_INT 2
87720: ARRAY
87721: PPUSH
87722: CALL_OW 114
// end else
87726: GO 87779
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87728: LD_ADDR_VAR 0 15
87732: PUSH
87733: LD_VAR 0 16
87737: PUSH
87738: LD_VAR 0 7
87742: ARRAY
87743: PPUSH
87744: LD_INT 1
87746: PPUSH
87747: CALL_OW 3
87751: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87752: LD_ADDR_VAR 0 16
87756: PUSH
87757: LD_VAR 0 16
87761: PPUSH
87762: LD_VAR 0 7
87766: PPUSH
87767: LD_VAR 0 15
87771: PPUSH
87772: CALL_OW 1
87776: ST_TO_ADDR
// continue ;
87777: GO 86302
// end ; end ; end else
87779: GO 90477
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87781: LD_ADDR_VAR 0 14
87785: PUSH
87786: LD_INT 81
87788: PUSH
87789: LD_VAR 0 4
87793: PUSH
87794: LD_VAR 0 7
87798: ARRAY
87799: PPUSH
87800: CALL_OW 255
87804: PUSH
87805: EMPTY
87806: LIST
87807: LIST
87808: PPUSH
87809: CALL_OW 69
87813: ST_TO_ADDR
// if not tmp then
87814: LD_VAR 0 14
87818: NOT
87819: IFFALSE 87823
// continue ;
87821: GO 86302
// if f_ignore_area then
87823: LD_VAR 0 17
87827: IFFALSE 87915
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87829: LD_ADDR_VAR 0 15
87833: PUSH
87834: LD_VAR 0 14
87838: PPUSH
87839: LD_INT 3
87841: PUSH
87842: LD_INT 92
87844: PUSH
87845: LD_VAR 0 17
87849: PUSH
87850: LD_INT 1
87852: ARRAY
87853: PUSH
87854: LD_VAR 0 17
87858: PUSH
87859: LD_INT 2
87861: ARRAY
87862: PUSH
87863: LD_VAR 0 17
87867: PUSH
87868: LD_INT 3
87870: ARRAY
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: PUSH
87878: EMPTY
87879: LIST
87880: LIST
87881: PPUSH
87882: CALL_OW 72
87886: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87887: LD_VAR 0 14
87891: PUSH
87892: LD_VAR 0 15
87896: DIFF
87897: IFFALSE 87915
// tmp := tmp diff tmp2 ;
87899: LD_ADDR_VAR 0 14
87903: PUSH
87904: LD_VAR 0 14
87908: PUSH
87909: LD_VAR 0 15
87913: DIFF
87914: ST_TO_ADDR
// end ; if not f_murder then
87915: LD_VAR 0 20
87919: NOT
87920: IFFALSE 87978
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
87922: LD_ADDR_VAR 0 15
87926: PUSH
87927: LD_VAR 0 14
87931: PPUSH
87932: LD_INT 3
87934: PUSH
87935: LD_INT 50
87937: PUSH
87938: EMPTY
87939: LIST
87940: PUSH
87941: EMPTY
87942: LIST
87943: LIST
87944: PPUSH
87945: CALL_OW 72
87949: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87950: LD_VAR 0 14
87954: PUSH
87955: LD_VAR 0 15
87959: DIFF
87960: IFFALSE 87978
// tmp := tmp diff tmp2 ;
87962: LD_ADDR_VAR 0 14
87966: PUSH
87967: LD_VAR 0 14
87971: PUSH
87972: LD_VAR 0 15
87976: DIFF
87977: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
87978: LD_ADDR_VAR 0 14
87982: PUSH
87983: LD_VAR 0 4
87987: PUSH
87988: LD_VAR 0 7
87992: ARRAY
87993: PPUSH
87994: LD_VAR 0 14
87998: PPUSH
87999: LD_INT 1
88001: PPUSH
88002: LD_INT 1
88004: PPUSH
88005: CALL 16724 0 4
88009: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
88010: LD_VAR 0 4
88014: PUSH
88015: LD_VAR 0 7
88019: ARRAY
88020: PPUSH
88021: CALL_OW 257
88025: PUSH
88026: LD_INT 1
88028: EQUAL
88029: IFFALSE 88489
// begin if WantPlant ( group [ i ] ) then
88031: LD_VAR 0 4
88035: PUSH
88036: LD_VAR 0 7
88040: ARRAY
88041: PPUSH
88042: CALL 16225 0 1
88046: IFFALSE 88050
// continue ;
88048: GO 86302
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88050: LD_VAR 0 18
88054: IFFALSE 88074
88056: PUSH
88057: LD_VAR 0 4
88061: PUSH
88062: LD_VAR 0 7
88066: ARRAY
88067: PPUSH
88068: CALL_OW 310
88072: NOT
88073: AND
88074: IFFALSE 88117
88076: PUSH
88077: LD_VAR 0 14
88081: PUSH
88082: LD_INT 1
88084: ARRAY
88085: PUSH
88086: LD_VAR 0 14
88090: PPUSH
88091: LD_INT 21
88093: PUSH
88094: LD_INT 2
88096: PUSH
88097: EMPTY
88098: LIST
88099: LIST
88100: PUSH
88101: LD_INT 58
88103: PUSH
88104: EMPTY
88105: LIST
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PPUSH
88111: CALL_OW 72
88115: IN
88116: AND
88117: IFFALSE 88153
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88119: LD_VAR 0 4
88123: PUSH
88124: LD_VAR 0 7
88128: ARRAY
88129: PPUSH
88130: LD_VAR 0 14
88134: PUSH
88135: LD_INT 1
88137: ARRAY
88138: PPUSH
88139: CALL_OW 120
// attacking := true ;
88143: LD_ADDR_VAR 0 29
88147: PUSH
88148: LD_INT 1
88150: ST_TO_ADDR
// continue ;
88151: GO 86302
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88153: LD_VAR 0 26
88157: IFFALSE 88180
88159: PUSH
88160: LD_VAR 0 4
88164: PUSH
88165: LD_VAR 0 7
88169: ARRAY
88170: PPUSH
88171: CALL_OW 257
88175: PUSH
88176: LD_INT 1
88178: EQUAL
88179: AND
88180: IFFALSE 88203
88182: PUSH
88183: LD_VAR 0 4
88187: PUSH
88188: LD_VAR 0 7
88192: ARRAY
88193: PPUSH
88194: CALL_OW 256
88198: PUSH
88199: LD_INT 800
88201: LESS
88202: AND
88203: IFFALSE 88223
88205: PUSH
88206: LD_VAR 0 4
88210: PUSH
88211: LD_VAR 0 7
88215: ARRAY
88216: PPUSH
88217: CALL_OW 318
88221: NOT
88222: AND
88223: IFFALSE 88240
// ComCrawl ( group [ i ] ) ;
88225: LD_VAR 0 4
88229: PUSH
88230: LD_VAR 0 7
88234: ARRAY
88235: PPUSH
88236: CALL_OW 137
// if f_mines then
88240: LD_VAR 0 21
88244: IFFALSE 88489
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88246: LD_VAR 0 14
88250: PUSH
88251: LD_INT 1
88253: ARRAY
88254: PPUSH
88255: CALL_OW 247
88259: PUSH
88260: LD_INT 3
88262: EQUAL
88263: IFFALSE 88282
88265: PUSH
88266: LD_VAR 0 14
88270: PUSH
88271: LD_INT 1
88273: ARRAY
88274: PUSH
88275: LD_VAR 0 27
88279: IN
88280: NOT
88281: AND
88282: IFFALSE 88489
// begin x := GetX ( tmp [ 1 ] ) ;
88284: LD_ADDR_VAR 0 10
88288: PUSH
88289: LD_VAR 0 14
88293: PUSH
88294: LD_INT 1
88296: ARRAY
88297: PPUSH
88298: CALL_OW 250
88302: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88303: LD_ADDR_VAR 0 11
88307: PUSH
88308: LD_VAR 0 14
88312: PUSH
88313: LD_INT 1
88315: ARRAY
88316: PPUSH
88317: CALL_OW 251
88321: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88322: LD_ADDR_VAR 0 12
88326: PUSH
88327: LD_VAR 0 4
88331: PUSH
88332: LD_VAR 0 7
88336: ARRAY
88337: PPUSH
88338: CALL 44387 0 1
88342: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88343: LD_VAR 0 4
88347: PUSH
88348: LD_VAR 0 7
88352: ARRAY
88353: PPUSH
88354: LD_VAR 0 10
88358: PPUSH
88359: LD_VAR 0 11
88363: PPUSH
88364: LD_VAR 0 14
88368: PUSH
88369: LD_INT 1
88371: ARRAY
88372: PPUSH
88373: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88377: LD_VAR 0 4
88381: PUSH
88382: LD_VAR 0 7
88386: ARRAY
88387: PPUSH
88388: LD_VAR 0 10
88392: PPUSH
88393: LD_VAR 0 12
88397: PPUSH
88398: LD_INT 7
88400: PPUSH
88401: CALL_OW 272
88405: PPUSH
88406: LD_VAR 0 11
88410: PPUSH
88411: LD_VAR 0 12
88415: PPUSH
88416: LD_INT 7
88418: PPUSH
88419: CALL_OW 273
88423: PPUSH
88424: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88428: LD_VAR 0 4
88432: PUSH
88433: LD_VAR 0 7
88437: ARRAY
88438: PPUSH
88439: LD_INT 71
88441: PPUSH
88442: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88446: LD_ADDR_VAR 0 27
88450: PUSH
88451: LD_VAR 0 27
88455: PPUSH
88456: LD_VAR 0 27
88460: PUSH
88461: LD_INT 1
88463: PLUS
88464: PPUSH
88465: LD_VAR 0 14
88469: PUSH
88470: LD_INT 1
88472: ARRAY
88473: PPUSH
88474: CALL_OW 1
88478: ST_TO_ADDR
// attacking := true ;
88479: LD_ADDR_VAR 0 29
88483: PUSH
88484: LD_INT 1
88486: ST_TO_ADDR
// continue ;
88487: GO 86302
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88489: LD_VAR 0 4
88493: PUSH
88494: LD_VAR 0 7
88498: ARRAY
88499: PPUSH
88500: CALL_OW 257
88504: PUSH
88505: LD_INT 17
88507: EQUAL
88508: IFFALSE 88532
88510: PUSH
88511: LD_VAR 0 4
88515: PUSH
88516: LD_VAR 0 7
88520: ARRAY
88521: PPUSH
88522: CALL_OW 110
88526: PUSH
88527: LD_INT 71
88529: EQUAL
88530: NOT
88531: AND
88532: IFFALSE 88678
// begin attacking := false ;
88534: LD_ADDR_VAR 0 29
88538: PUSH
88539: LD_INT 0
88541: ST_TO_ADDR
// k := 5 ;
88542: LD_ADDR_VAR 0 9
88546: PUSH
88547: LD_INT 5
88549: ST_TO_ADDR
// if tmp < k then
88550: LD_VAR 0 14
88554: PUSH
88555: LD_VAR 0 9
88559: LESS
88560: IFFALSE 88572
// k := tmp ;
88562: LD_ADDR_VAR 0 9
88566: PUSH
88567: LD_VAR 0 14
88571: ST_TO_ADDR
// for j = 1 to k do
88572: LD_ADDR_VAR 0 8
88576: PUSH
88577: DOUBLE
88578: LD_INT 1
88580: DEC
88581: ST_TO_ADDR
88582: LD_VAR 0 9
88586: PUSH
88587: FOR_TO
88588: IFFALSE 88676
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88590: LD_VAR 0 14
88594: PUSH
88595: LD_VAR 0 8
88599: ARRAY
88600: PUSH
88601: LD_VAR 0 14
88605: PPUSH
88606: LD_INT 58
88608: PUSH
88609: EMPTY
88610: LIST
88611: PPUSH
88612: CALL_OW 72
88616: IN
88617: NOT
88618: IFFALSE 88674
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88620: LD_VAR 0 4
88624: PUSH
88625: LD_VAR 0 7
88629: ARRAY
88630: PPUSH
88631: LD_VAR 0 14
88635: PUSH
88636: LD_VAR 0 8
88640: ARRAY
88641: PPUSH
88642: CALL_OW 115
// attacking := true ;
88646: LD_ADDR_VAR 0 29
88650: PUSH
88651: LD_INT 1
88653: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88654: LD_VAR 0 4
88658: PUSH
88659: LD_VAR 0 7
88663: ARRAY
88664: PPUSH
88665: LD_INT 71
88667: PPUSH
88668: CALL_OW 109
// continue ;
88672: GO 88587
// end ; end ;
88674: GO 88587
88676: POP
88677: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88678: LD_VAR 0 4
88682: PUSH
88683: LD_VAR 0 7
88687: ARRAY
88688: PPUSH
88689: CALL_OW 257
88693: PUSH
88694: LD_INT 8
88696: EQUAL
88697: IFTRUE 88735
88699: PUSH
88700: LD_VAR 0 4
88704: PUSH
88705: LD_VAR 0 7
88709: ARRAY
88710: PPUSH
88711: CALL_OW 264
88715: PUSH
88716: LD_INT 28
88718: PUSH
88719: LD_INT 45
88721: PUSH
88722: LD_INT 7
88724: PUSH
88725: LD_INT 47
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: IN
88734: OR
88735: IFFALSE 88991
// begin attacking := false ;
88737: LD_ADDR_VAR 0 29
88741: PUSH
88742: LD_INT 0
88744: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88745: LD_VAR 0 14
88749: PUSH
88750: LD_INT 1
88752: ARRAY
88753: PPUSH
88754: CALL_OW 266
88758: PUSH
88759: LD_INT 32
88761: PUSH
88762: LD_INT 31
88764: PUSH
88765: LD_INT 33
88767: PUSH
88768: LD_INT 4
88770: PUSH
88771: LD_INT 5
88773: PUSH
88774: EMPTY
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: IN
88781: IFFALSE 88967
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88783: LD_ADDR_VAR 0 9
88787: PUSH
88788: LD_VAR 0 14
88792: PUSH
88793: LD_INT 1
88795: ARRAY
88796: PPUSH
88797: CALL_OW 266
88801: PPUSH
88802: LD_VAR 0 14
88806: PUSH
88807: LD_INT 1
88809: ARRAY
88810: PPUSH
88811: CALL_OW 250
88815: PPUSH
88816: LD_VAR 0 14
88820: PUSH
88821: LD_INT 1
88823: ARRAY
88824: PPUSH
88825: CALL_OW 251
88829: PPUSH
88830: LD_VAR 0 14
88834: PUSH
88835: LD_INT 1
88837: ARRAY
88838: PPUSH
88839: CALL_OW 254
88843: PPUSH
88844: LD_VAR 0 14
88848: PUSH
88849: LD_INT 1
88851: ARRAY
88852: PPUSH
88853: CALL_OW 248
88857: PPUSH
88858: LD_INT 0
88860: PPUSH
88861: CALL 25745 0 6
88865: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88866: LD_ADDR_VAR 0 8
88870: PUSH
88871: LD_VAR 0 4
88875: PUSH
88876: LD_VAR 0 7
88880: ARRAY
88881: PPUSH
88882: LD_VAR 0 9
88886: PPUSH
88887: CALL 44500 0 2
88891: ST_TO_ADDR
// if j then
88892: LD_VAR 0 8
88896: IFFALSE 88965
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88898: LD_VAR 0 8
88902: PUSH
88903: LD_INT 1
88905: ARRAY
88906: PPUSH
88907: LD_VAR 0 8
88911: PUSH
88912: LD_INT 2
88914: ARRAY
88915: PPUSH
88916: CALL_OW 488
88920: IFFALSE 88965
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88922: LD_VAR 0 4
88926: PUSH
88927: LD_VAR 0 7
88931: ARRAY
88932: PPUSH
88933: LD_VAR 0 8
88937: PUSH
88938: LD_INT 1
88940: ARRAY
88941: PPUSH
88942: LD_VAR 0 8
88946: PUSH
88947: LD_INT 2
88949: ARRAY
88950: PPUSH
88951: CALL_OW 116
// attacking := true ;
88955: LD_ADDR_VAR 0 29
88959: PUSH
88960: LD_INT 1
88962: ST_TO_ADDR
// continue ;
88963: GO 86302
// end ; end else
88965: GO 88991
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88967: LD_VAR 0 4
88971: PUSH
88972: LD_VAR 0 7
88976: ARRAY
88977: PPUSH
88978: LD_VAR 0 14
88982: PUSH
88983: LD_INT 1
88985: ARRAY
88986: PPUSH
88987: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
88991: LD_VAR 0 4
88995: PUSH
88996: LD_VAR 0 7
89000: ARRAY
89001: PPUSH
89002: CALL_OW 265
89006: PUSH
89007: LD_INT 11
89009: EQUAL
89010: IFFALSE 89288
// begin k := 10 ;
89012: LD_ADDR_VAR 0 9
89016: PUSH
89017: LD_INT 10
89019: ST_TO_ADDR
// x := 0 ;
89020: LD_ADDR_VAR 0 10
89024: PUSH
89025: LD_INT 0
89027: ST_TO_ADDR
// if tmp < k then
89028: LD_VAR 0 14
89032: PUSH
89033: LD_VAR 0 9
89037: LESS
89038: IFFALSE 89050
// k := tmp ;
89040: LD_ADDR_VAR 0 9
89044: PUSH
89045: LD_VAR 0 14
89049: ST_TO_ADDR
// for j = k downto 1 do
89050: LD_ADDR_VAR 0 8
89054: PUSH
89055: DOUBLE
89056: LD_VAR 0 9
89060: INC
89061: ST_TO_ADDR
89062: LD_INT 1
89064: PUSH
89065: FOR_DOWNTO
89066: IFFALSE 89141
// begin if GetType ( tmp [ j ] ) = unit_human then
89068: LD_VAR 0 14
89072: PUSH
89073: LD_VAR 0 8
89077: ARRAY
89078: PPUSH
89079: CALL_OW 247
89083: PUSH
89084: LD_INT 1
89086: EQUAL
89087: IFFALSE 89139
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89089: LD_VAR 0 4
89093: PUSH
89094: LD_VAR 0 7
89098: ARRAY
89099: PPUSH
89100: LD_VAR 0 14
89104: PUSH
89105: LD_VAR 0 8
89109: ARRAY
89110: PPUSH
89111: CALL 44758 0 2
// x := tmp [ j ] ;
89115: LD_ADDR_VAR 0 10
89119: PUSH
89120: LD_VAR 0 14
89124: PUSH
89125: LD_VAR 0 8
89129: ARRAY
89130: ST_TO_ADDR
// attacking := true ;
89131: LD_ADDR_VAR 0 29
89135: PUSH
89136: LD_INT 1
89138: ST_TO_ADDR
// end ; end ;
89139: GO 89065
89141: POP
89142: POP
// if not x then
89143: LD_VAR 0 10
89147: NOT
89148: IFFALSE 89288
// begin attacking := true ;
89150: LD_ADDR_VAR 0 29
89154: PUSH
89155: LD_INT 1
89157: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89158: LD_VAR 0 4
89162: PUSH
89163: LD_VAR 0 7
89167: ARRAY
89168: PPUSH
89169: CALL_OW 250
89173: PPUSH
89174: LD_VAR 0 4
89178: PUSH
89179: LD_VAR 0 7
89183: ARRAY
89184: PPUSH
89185: CALL_OW 251
89189: PPUSH
89190: CALL_OW 546
89194: PUSH
89195: LD_INT 2
89197: ARRAY
89198: PUSH
89199: LD_VAR 0 14
89203: PUSH
89204: LD_INT 1
89206: ARRAY
89207: PPUSH
89208: CALL_OW 250
89212: PPUSH
89213: LD_VAR 0 14
89217: PUSH
89218: LD_INT 1
89220: ARRAY
89221: PPUSH
89222: CALL_OW 251
89226: PPUSH
89227: CALL_OW 546
89231: PUSH
89232: LD_INT 2
89234: ARRAY
89235: EQUAL
89236: IFFALSE 89264
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89238: LD_VAR 0 4
89242: PUSH
89243: LD_VAR 0 7
89247: ARRAY
89248: PPUSH
89249: LD_VAR 0 14
89253: PUSH
89254: LD_INT 1
89256: ARRAY
89257: PPUSH
89258: CALL 44758 0 2
89262: GO 89288
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89264: LD_VAR 0 4
89268: PUSH
89269: LD_VAR 0 7
89273: ARRAY
89274: PPUSH
89275: LD_VAR 0 14
89279: PUSH
89280: LD_INT 1
89282: ARRAY
89283: PPUSH
89284: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89288: LD_VAR 0 4
89292: PUSH
89293: LD_VAR 0 7
89297: ARRAY
89298: PPUSH
89299: CALL_OW 264
89303: PUSH
89304: LD_INT 29
89306: EQUAL
89307: IFFALSE 89677
// begin if WantsToAttack ( group [ i ] ) in bombed then
89309: LD_VAR 0 4
89313: PUSH
89314: LD_VAR 0 7
89318: ARRAY
89319: PPUSH
89320: CALL_OW 319
89324: PUSH
89325: LD_VAR 0 28
89329: IN
89330: IFFALSE 89334
// continue ;
89332: GO 86302
// k := 8 ;
89334: LD_ADDR_VAR 0 9
89338: PUSH
89339: LD_INT 8
89341: ST_TO_ADDR
// x := 0 ;
89342: LD_ADDR_VAR 0 10
89346: PUSH
89347: LD_INT 0
89349: ST_TO_ADDR
// if tmp < k then
89350: LD_VAR 0 14
89354: PUSH
89355: LD_VAR 0 9
89359: LESS
89360: IFFALSE 89372
// k := tmp ;
89362: LD_ADDR_VAR 0 9
89366: PUSH
89367: LD_VAR 0 14
89371: ST_TO_ADDR
// for j = 1 to k do
89372: LD_ADDR_VAR 0 8
89376: PUSH
89377: DOUBLE
89378: LD_INT 1
89380: DEC
89381: ST_TO_ADDR
89382: LD_VAR 0 9
89386: PUSH
89387: FOR_TO
89388: IFFALSE 89522
// begin if GetType ( tmp [ j ] ) = unit_building then
89390: LD_VAR 0 14
89394: PUSH
89395: LD_VAR 0 8
89399: ARRAY
89400: PPUSH
89401: CALL_OW 247
89405: PUSH
89406: LD_INT 3
89408: EQUAL
89409: IFFALSE 89520
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89411: LD_VAR 0 14
89415: PUSH
89416: LD_VAR 0 8
89420: ARRAY
89421: PUSH
89422: LD_VAR 0 28
89426: IN
89427: NOT
89428: IFFALSE 89447
89430: PUSH
89431: LD_VAR 0 14
89435: PUSH
89436: LD_VAR 0 8
89440: ARRAY
89441: PPUSH
89442: CALL_OW 313
89446: AND
89447: IFFALSE 89520
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89449: LD_VAR 0 4
89453: PUSH
89454: LD_VAR 0 7
89458: ARRAY
89459: PPUSH
89460: LD_VAR 0 14
89464: PUSH
89465: LD_VAR 0 8
89469: ARRAY
89470: PPUSH
89471: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89475: LD_ADDR_VAR 0 28
89479: PUSH
89480: LD_VAR 0 28
89484: PPUSH
89485: LD_VAR 0 28
89489: PUSH
89490: LD_INT 1
89492: PLUS
89493: PPUSH
89494: LD_VAR 0 14
89498: PUSH
89499: LD_VAR 0 8
89503: ARRAY
89504: PPUSH
89505: CALL_OW 1
89509: ST_TO_ADDR
// attacking := true ;
89510: LD_ADDR_VAR 0 29
89514: PUSH
89515: LD_INT 1
89517: ST_TO_ADDR
// break ;
89518: GO 89522
// end ; end ;
89520: GO 89387
89522: POP
89523: POP
// if not attacking and f_attack_depot then
89524: LD_VAR 0 29
89528: NOT
89529: IFFALSE 89537
89531: PUSH
89532: LD_VAR 0 25
89536: AND
89537: IFFALSE 89632
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89539: LD_ADDR_VAR 0 13
89543: PUSH
89544: LD_VAR 0 14
89548: PPUSH
89549: LD_INT 2
89551: PUSH
89552: LD_INT 30
89554: PUSH
89555: LD_INT 0
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PUSH
89562: LD_INT 30
89564: PUSH
89565: LD_INT 1
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: LIST
89576: PPUSH
89577: CALL_OW 72
89581: ST_TO_ADDR
// if z then
89582: LD_VAR 0 13
89586: IFFALSE 89632
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89588: LD_VAR 0 4
89592: PUSH
89593: LD_VAR 0 7
89597: ARRAY
89598: PPUSH
89599: LD_VAR 0 13
89603: PPUSH
89604: LD_VAR 0 4
89608: PUSH
89609: LD_VAR 0 7
89613: ARRAY
89614: PPUSH
89615: CALL_OW 74
89619: PPUSH
89620: CALL_OW 115
// attacking := true ;
89624: LD_ADDR_VAR 0 29
89628: PUSH
89629: LD_INT 1
89631: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89632: LD_VAR 0 4
89636: PUSH
89637: LD_VAR 0 7
89641: ARRAY
89642: PPUSH
89643: CALL_OW 256
89647: PUSH
89648: LD_INT 500
89650: LESS
89651: IFFALSE 89677
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89653: LD_VAR 0 4
89657: PUSH
89658: LD_VAR 0 7
89662: ARRAY
89663: PPUSH
89664: LD_VAR 0 14
89668: PUSH
89669: LD_INT 1
89671: ARRAY
89672: PPUSH
89673: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89677: LD_VAR 0 4
89681: PUSH
89682: LD_VAR 0 7
89686: ARRAY
89687: PPUSH
89688: CALL_OW 264
89692: PUSH
89693: LD_INT 49
89695: EQUAL
89696: IFFALSE 89817
// begin if not HasTask ( group [ i ] ) then
89698: LD_VAR 0 4
89702: PUSH
89703: LD_VAR 0 7
89707: ARRAY
89708: PPUSH
89709: CALL_OW 314
89713: NOT
89714: IFFALSE 89817
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89716: LD_ADDR_VAR 0 9
89720: PUSH
89721: LD_INT 81
89723: PUSH
89724: LD_VAR 0 4
89728: PUSH
89729: LD_VAR 0 7
89733: ARRAY
89734: PPUSH
89735: CALL_OW 255
89739: PUSH
89740: EMPTY
89741: LIST
89742: LIST
89743: PPUSH
89744: CALL_OW 69
89748: PPUSH
89749: LD_VAR 0 4
89753: PUSH
89754: LD_VAR 0 7
89758: ARRAY
89759: PPUSH
89760: CALL_OW 74
89764: ST_TO_ADDR
// if k then
89765: LD_VAR 0 9
89769: IFFALSE 89817
// if GetDistUnits ( group [ i ] , k ) > 10 then
89771: LD_VAR 0 4
89775: PUSH
89776: LD_VAR 0 7
89780: ARRAY
89781: PPUSH
89782: LD_VAR 0 9
89786: PPUSH
89787: CALL_OW 296
89791: PUSH
89792: LD_INT 10
89794: GREATER
89795: IFFALSE 89817
// ComMoveUnit ( group [ i ] , k ) ;
89797: LD_VAR 0 4
89801: PUSH
89802: LD_VAR 0 7
89806: ARRAY
89807: PPUSH
89808: LD_VAR 0 9
89812: PPUSH
89813: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89817: LD_VAR 0 4
89821: PUSH
89822: LD_VAR 0 7
89826: ARRAY
89827: PPUSH
89828: CALL_OW 256
89832: PUSH
89833: LD_INT 250
89835: LESS
89836: IFFALSE 89880
89838: PUSH
89839: LD_VAR 0 4
89843: PUSH
89844: LD_VAR 0 7
89848: ARRAY
89849: PUSH
89850: LD_INT 21
89852: PUSH
89853: LD_INT 2
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: PUSH
89860: LD_INT 23
89862: PUSH
89863: LD_INT 2
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: PPUSH
89874: CALL_OW 69
89878: IN
89879: AND
89880: IFFALSE 90007
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89882: LD_ADDR_VAR 0 9
89886: PUSH
89887: LD_OWVAR 3
89891: PUSH
89892: LD_VAR 0 4
89896: PUSH
89897: LD_VAR 0 7
89901: ARRAY
89902: DIFF
89903: PPUSH
89904: LD_VAR 0 4
89908: PUSH
89909: LD_VAR 0 7
89913: ARRAY
89914: PPUSH
89915: CALL_OW 74
89919: ST_TO_ADDR
// if not k then
89920: LD_VAR 0 9
89924: NOT
89925: IFFALSE 89929
// continue ;
89927: GO 86302
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89929: LD_VAR 0 9
89933: PUSH
89934: LD_INT 81
89936: PUSH
89937: LD_VAR 0 4
89941: PUSH
89942: LD_VAR 0 7
89946: ARRAY
89947: PPUSH
89948: CALL_OW 255
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: PPUSH
89957: CALL_OW 69
89961: IN
89962: IFFALSE 89990
89964: PUSH
89965: LD_VAR 0 9
89969: PPUSH
89970: LD_VAR 0 4
89974: PUSH
89975: LD_VAR 0 7
89979: ARRAY
89980: PPUSH
89981: CALL_OW 296
89985: PUSH
89986: LD_INT 5
89988: LESS
89989: AND
89990: IFFALSE 90007
// ComAutodestruct ( group [ i ] ) ;
89992: LD_VAR 0 4
89996: PUSH
89997: LD_VAR 0 7
90001: ARRAY
90002: PPUSH
90003: CALL 44654 0 1
// end ; if f_attack_depot then
90007: LD_VAR 0 25
90011: IFFALSE 90123
// begin k := 6 ;
90013: LD_ADDR_VAR 0 9
90017: PUSH
90018: LD_INT 6
90020: ST_TO_ADDR
// if tmp < k then
90021: LD_VAR 0 14
90025: PUSH
90026: LD_VAR 0 9
90030: LESS
90031: IFFALSE 90043
// k := tmp ;
90033: LD_ADDR_VAR 0 9
90037: PUSH
90038: LD_VAR 0 14
90042: ST_TO_ADDR
// for j = 1 to k do
90043: LD_ADDR_VAR 0 8
90047: PUSH
90048: DOUBLE
90049: LD_INT 1
90051: DEC
90052: ST_TO_ADDR
90053: LD_VAR 0 9
90057: PUSH
90058: FOR_TO
90059: IFFALSE 90121
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90061: LD_VAR 0 8
90065: PPUSH
90066: CALL_OW 266
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: LD_INT 1
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: IN
90081: IFFALSE 90119
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90083: LD_VAR 0 4
90087: PUSH
90088: LD_VAR 0 7
90092: ARRAY
90093: PPUSH
90094: LD_VAR 0 14
90098: PUSH
90099: LD_VAR 0 8
90103: ARRAY
90104: PPUSH
90105: CALL_OW 115
// attacking := true ;
90109: LD_ADDR_VAR 0 29
90113: PUSH
90114: LD_INT 1
90116: ST_TO_ADDR
// break ;
90117: GO 90121
// end ;
90119: GO 90058
90121: POP
90122: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90123: LD_VAR 0 4
90127: PUSH
90128: LD_VAR 0 7
90132: ARRAY
90133: PPUSH
90134: CALL_OW 302
90138: IFFALSE 90147
90140: PUSH
90141: LD_VAR 0 29
90145: NOT
90146: AND
90147: IFFALSE 90477
// begin if GetTag ( group [ i ] ) = 71 then
90149: LD_VAR 0 4
90153: PUSH
90154: LD_VAR 0 7
90158: ARRAY
90159: PPUSH
90160: CALL_OW 110
90164: PUSH
90165: LD_INT 71
90167: EQUAL
90168: IFFALSE 90209
// begin if HasTask ( group [ i ] ) then
90170: LD_VAR 0 4
90174: PUSH
90175: LD_VAR 0 7
90179: ARRAY
90180: PPUSH
90181: CALL_OW 314
90185: IFFALSE 90191
// continue else
90187: GO 86302
90189: GO 90209
// SetTag ( group [ i ] , 0 ) ;
90191: LD_VAR 0 4
90195: PUSH
90196: LD_VAR 0 7
90200: ARRAY
90201: PPUSH
90202: LD_INT 0
90204: PPUSH
90205: CALL_OW 109
// end ; k := 8 ;
90209: LD_ADDR_VAR 0 9
90213: PUSH
90214: LD_INT 8
90216: ST_TO_ADDR
// x := 0 ;
90217: LD_ADDR_VAR 0 10
90221: PUSH
90222: LD_INT 0
90224: ST_TO_ADDR
// if tmp < k then
90225: LD_VAR 0 14
90229: PUSH
90230: LD_VAR 0 9
90234: LESS
90235: IFFALSE 90247
// k := tmp ;
90237: LD_ADDR_VAR 0 9
90241: PUSH
90242: LD_VAR 0 14
90246: ST_TO_ADDR
// for j = 1 to k do
90247: LD_ADDR_VAR 0 8
90251: PUSH
90252: DOUBLE
90253: LD_INT 1
90255: DEC
90256: ST_TO_ADDR
90257: LD_VAR 0 9
90261: PUSH
90262: FOR_TO
90263: IFFALSE 90369
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90265: LD_VAR 0 14
90269: PUSH
90270: LD_VAR 0 8
90274: ARRAY
90275: PPUSH
90276: CALL_OW 247
90280: PUSH
90281: LD_INT 1
90283: EQUAL
90284: IFFALSE 90347
90286: PUSH
90287: LD_VAR 0 14
90291: PUSH
90292: LD_VAR 0 8
90296: ARRAY
90297: PPUSH
90298: CALL_OW 256
90302: PUSH
90303: LD_INT 250
90305: LESS
90306: IFFALSE 90314
90308: PUSH
90309: LD_VAR 0 20
90313: AND
90314: IFTRUE 90346
90316: PUSH
90317: LD_VAR 0 20
90321: NOT
90322: IFFALSE 90345
90324: PUSH
90325: LD_VAR 0 14
90329: PUSH
90330: LD_VAR 0 8
90334: ARRAY
90335: PPUSH
90336: CALL_OW 256
90340: PUSH
90341: LD_INT 250
90343: GREATEREQUAL
90344: AND
90345: OR
90346: AND
90347: IFFALSE 90367
// begin x := tmp [ j ] ;
90349: LD_ADDR_VAR 0 10
90353: PUSH
90354: LD_VAR 0 14
90358: PUSH
90359: LD_VAR 0 8
90363: ARRAY
90364: ST_TO_ADDR
// break ;
90365: GO 90369
// end ;
90367: GO 90262
90369: POP
90370: POP
// if x then
90371: LD_VAR 0 10
90375: IFFALSE 90399
// ComAttackUnit ( group [ i ] , x ) else
90377: LD_VAR 0 4
90381: PUSH
90382: LD_VAR 0 7
90386: ARRAY
90387: PPUSH
90388: LD_VAR 0 10
90392: PPUSH
90393: CALL_OW 115
90397: GO 90423
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90399: LD_VAR 0 4
90403: PUSH
90404: LD_VAR 0 7
90408: ARRAY
90409: PPUSH
90410: LD_VAR 0 14
90414: PUSH
90415: LD_INT 1
90417: ARRAY
90418: PPUSH
90419: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90423: LD_VAR 0 4
90427: PUSH
90428: LD_VAR 0 7
90432: ARRAY
90433: PPUSH
90434: CALL_OW 314
90438: NOT
90439: IFFALSE 90477
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90441: LD_VAR 0 4
90445: PUSH
90446: LD_VAR 0 7
90450: ARRAY
90451: PPUSH
90452: LD_VAR 0 14
90456: PPUSH
90457: LD_VAR 0 4
90461: PUSH
90462: LD_VAR 0 7
90466: ARRAY
90467: PPUSH
90468: CALL_OW 74
90472: PPUSH
90473: CALL_OW 115
// end ; end ; end ;
90477: GO 86302
90479: POP
90480: POP
// wait ( 0 0$2 ) ;
90481: LD_INT 70
90483: PPUSH
90484: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90488: LD_VAR 0 4
90492: NOT
90493: IFTRUE 90504
90495: PUSH
90496: LD_VAR 0 4
90500: PUSH
90501: EMPTY
90502: EQUAL
90503: OR
90504: IFTRUE 90525
90506: PUSH
90507: LD_INT 81
90509: PUSH
90510: LD_VAR 0 35
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PPUSH
90519: CALL_OW 69
90523: NOT
90524: OR
90525: IFFALSE 86287
// end ;
90527: LD_VAR 0 2
90531: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
90532: LD_INT 0
90534: PPUSH
90535: PPUSH
90536: PPUSH
90537: PPUSH
90538: PPUSH
90539: PPUSH
// if not base or not mc_bases [ base ] or not solds then
90540: LD_VAR 0 1
90544: NOT
90545: IFTRUE 90560
90547: PUSH
90548: LD_EXP 23
90552: PUSH
90553: LD_VAR 0 1
90557: ARRAY
90558: NOT
90559: OR
90560: IFTRUE 90569
90562: PUSH
90563: LD_VAR 0 2
90567: NOT
90568: OR
90569: IFFALSE 90573
// exit ;
90571: GO 91131
// side := mc_sides [ base ] ;
90573: LD_ADDR_VAR 0 6
90577: PUSH
90578: LD_EXP 49
90582: PUSH
90583: LD_VAR 0 1
90587: ARRAY
90588: ST_TO_ADDR
// if not side then
90589: LD_VAR 0 6
90593: NOT
90594: IFFALSE 90598
// exit ;
90596: GO 91131
// for i in solds do
90598: LD_ADDR_VAR 0 7
90602: PUSH
90603: LD_VAR 0 2
90607: PUSH
90608: FOR_IN
90609: IFFALSE 90670
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
90611: LD_VAR 0 7
90615: PPUSH
90616: CALL_OW 310
90620: PPUSH
90621: CALL_OW 266
90625: PUSH
90626: LD_INT 32
90628: PUSH
90629: LD_INT 31
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: IN
90636: IFFALSE 90656
// solds := solds diff i else
90638: LD_ADDR_VAR 0 2
90642: PUSH
90643: LD_VAR 0 2
90647: PUSH
90648: LD_VAR 0 7
90652: DIFF
90653: ST_TO_ADDR
90654: GO 90668
// SetTag ( i , 18 ) ;
90656: LD_VAR 0 7
90660: PPUSH
90661: LD_INT 18
90663: PPUSH
90664: CALL_OW 109
90668: GO 90608
90670: POP
90671: POP
// if not solds then
90672: LD_VAR 0 2
90676: NOT
90677: IFFALSE 90681
// exit ;
90679: GO 91131
// repeat wait ( 0 0$2 ) ;
90681: LD_INT 70
90683: PPUSH
90684: CALL_OW 67
// enemy := mc_scan [ base ] ;
90688: LD_ADDR_VAR 0 4
90692: PUSH
90693: LD_EXP 46
90697: PUSH
90698: LD_VAR 0 1
90702: ARRAY
90703: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90704: LD_EXP 23
90708: PUSH
90709: LD_VAR 0 1
90713: ARRAY
90714: NOT
90715: IFTRUE 90732
90717: PUSH
90718: LD_EXP 23
90722: PUSH
90723: LD_VAR 0 1
90727: ARRAY
90728: PUSH
90729: EMPTY
90730: EQUAL
90731: OR
90732: IFFALSE 90769
// begin for i in solds do
90734: LD_ADDR_VAR 0 7
90738: PUSH
90739: LD_VAR 0 2
90743: PUSH
90744: FOR_IN
90745: IFFALSE 90758
// ComStop ( i ) ;
90747: LD_VAR 0 7
90751: PPUSH
90752: CALL_OW 141
90756: GO 90744
90758: POP
90759: POP
// solds := [ ] ;
90760: LD_ADDR_VAR 0 2
90764: PUSH
90765: EMPTY
90766: ST_TO_ADDR
// exit ;
90767: GO 91131
// end ; for i in solds do
90769: LD_ADDR_VAR 0 7
90773: PUSH
90774: LD_VAR 0 2
90778: PUSH
90779: FOR_IN
90780: IFFALSE 91101
// begin if IsInUnit ( i ) then
90782: LD_VAR 0 7
90786: PPUSH
90787: CALL_OW 310
90791: IFFALSE 90802
// ComExitBuilding ( i ) ;
90793: LD_VAR 0 7
90797: PPUSH
90798: CALL_OW 122
// if GetLives ( i ) > 500 then
90802: LD_VAR 0 7
90806: PPUSH
90807: CALL_OW 256
90811: PUSH
90812: LD_INT 500
90814: GREATER
90815: IFFALSE 90868
// begin e := NearestUnitToUnit ( enemy , i ) ;
90817: LD_ADDR_VAR 0 5
90821: PUSH
90822: LD_VAR 0 4
90826: PPUSH
90827: LD_VAR 0 7
90831: PPUSH
90832: CALL_OW 74
90836: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
90837: LD_VAR 0 7
90841: PPUSH
90842: LD_VAR 0 5
90846: PPUSH
90847: CALL_OW 250
90851: PPUSH
90852: LD_VAR 0 5
90856: PPUSH
90857: CALL_OW 251
90861: PPUSH
90862: CALL_OW 114
// end else
90866: GO 91099
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
90868: LD_VAR 0 7
90872: PPUSH
90873: LD_EXP 23
90877: PUSH
90878: LD_VAR 0 1
90882: ARRAY
90883: PPUSH
90884: LD_INT 2
90886: PUSH
90887: LD_INT 30
90889: PUSH
90890: LD_INT 0
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 30
90899: PUSH
90900: LD_INT 1
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 30
90909: PUSH
90910: LD_INT 6
90912: PUSH
90913: EMPTY
90914: LIST
90915: LIST
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: PPUSH
90923: CALL_OW 72
90927: PPUSH
90928: LD_VAR 0 7
90932: PPUSH
90933: CALL_OW 74
90937: PPUSH
90938: CALL_OW 296
90942: PUSH
90943: LD_INT 10
90945: GREATER
90946: IFFALSE 91099
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
90948: LD_ADDR_VAR 0 8
90952: PUSH
90953: LD_EXP 23
90957: PUSH
90958: LD_VAR 0 1
90962: ARRAY
90963: PPUSH
90964: LD_INT 2
90966: PUSH
90967: LD_INT 30
90969: PUSH
90970: LD_INT 0
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 30
90979: PUSH
90980: LD_INT 1
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 30
90989: PUSH
90990: LD_INT 6
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: PUSH
90997: EMPTY
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: PPUSH
91003: CALL_OW 72
91007: PPUSH
91008: LD_VAR 0 7
91012: PPUSH
91013: CALL_OW 74
91017: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
91018: LD_VAR 0 7
91022: PPUSH
91023: LD_VAR 0 8
91027: PPUSH
91028: CALL_OW 250
91032: PPUSH
91033: LD_INT 3
91035: PPUSH
91036: LD_INT 5
91038: PPUSH
91039: CALL_OW 272
91043: PPUSH
91044: LD_VAR 0 8
91048: PPUSH
91049: CALL_OW 251
91053: PPUSH
91054: LD_INT 3
91056: PPUSH
91057: LD_INT 5
91059: PPUSH
91060: CALL_OW 273
91064: PPUSH
91065: CALL_OW 111
// SetTag ( i , 0 ) ;
91069: LD_VAR 0 7
91073: PPUSH
91074: LD_INT 0
91076: PPUSH
91077: CALL_OW 109
// solds := solds diff i ;
91081: LD_ADDR_VAR 0 2
91085: PUSH
91086: LD_VAR 0 2
91090: PUSH
91091: LD_VAR 0 7
91095: DIFF
91096: ST_TO_ADDR
// continue ;
91097: GO 90779
// end ; end ;
91099: GO 90779
91101: POP
91102: POP
// until not solds or not enemy ;
91103: LD_VAR 0 2
91107: NOT
91108: IFTRUE 91117
91110: PUSH
91111: LD_VAR 0 4
91115: NOT
91116: OR
91117: IFFALSE 90681
// MC_Reset ( base , 18 ) ;
91119: LD_VAR 0 1
91123: PPUSH
91124: LD_INT 18
91126: PPUSH
91127: CALL 58870 0 2
// end ;
91131: LD_VAR 0 3
91135: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
91136: LD_INT 0
91138: PPUSH
91139: PPUSH
91140: PPUSH
91141: PPUSH
91142: PPUSH
91143: PPUSH
91144: PPUSH
91145: PPUSH
91146: PPUSH
91147: PPUSH
91148: PPUSH
91149: PPUSH
91150: PPUSH
91151: PPUSH
91152: PPUSH
91153: PPUSH
91154: PPUSH
91155: PPUSH
91156: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
91157: LD_ADDR_VAR 0 12
91161: PUSH
91162: LD_EXP 23
91166: PUSH
91167: LD_VAR 0 1
91171: ARRAY
91172: PPUSH
91173: LD_INT 25
91175: PUSH
91176: LD_INT 3
91178: PUSH
91179: EMPTY
91180: LIST
91181: LIST
91182: PPUSH
91183: CALL_OW 72
91187: ST_TO_ADDR
// if mc_remote_driver [ base ] then
91188: LD_EXP 63
91192: PUSH
91193: LD_VAR 0 1
91197: ARRAY
91198: IFFALSE 91222
// mechs := mechs diff mc_remote_driver [ base ] ;
91200: LD_ADDR_VAR 0 12
91204: PUSH
91205: LD_VAR 0 12
91209: PUSH
91210: LD_EXP 63
91214: PUSH
91215: LD_VAR 0 1
91219: ARRAY
91220: DIFF
91221: ST_TO_ADDR
// for i in mechs do
91222: LD_ADDR_VAR 0 4
91226: PUSH
91227: LD_VAR 0 12
91231: PUSH
91232: FOR_IN
91233: IFFALSE 91268
// if GetTag ( i ) > 0 then
91235: LD_VAR 0 4
91239: PPUSH
91240: CALL_OW 110
91244: PUSH
91245: LD_INT 0
91247: GREATER
91248: IFFALSE 91266
// mechs := mechs diff i ;
91250: LD_ADDR_VAR 0 12
91254: PUSH
91255: LD_VAR 0 12
91259: PUSH
91260: LD_VAR 0 4
91264: DIFF
91265: ST_TO_ADDR
91266: GO 91232
91268: POP
91269: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
91270: LD_ADDR_VAR 0 8
91274: PUSH
91275: LD_EXP 23
91279: PUSH
91280: LD_VAR 0 1
91284: ARRAY
91285: PPUSH
91286: LD_INT 2
91288: PUSH
91289: LD_INT 25
91291: PUSH
91292: LD_INT 1
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 25
91301: PUSH
91302: LD_INT 5
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 25
91311: PUSH
91312: LD_INT 8
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 25
91321: PUSH
91322: LD_INT 9
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: EMPTY
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: PPUSH
91336: CALL_OW 72
91340: ST_TO_ADDR
// if not defenders and not solds then
91341: LD_VAR 0 2
91345: NOT
91346: IFFALSE 91355
91348: PUSH
91349: LD_VAR 0 8
91353: NOT
91354: AND
91355: IFFALSE 91359
// exit ;
91357: GO 93181
// depot_under_attack := false ;
91359: LD_ADDR_VAR 0 16
91363: PUSH
91364: LD_INT 0
91366: ST_TO_ADDR
// sold_defenders := [ ] ;
91367: LD_ADDR_VAR 0 17
91371: PUSH
91372: EMPTY
91373: ST_TO_ADDR
// if mechs then
91374: LD_VAR 0 12
91378: IFFALSE 91533
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
91380: LD_ADDR_VAR 0 4
91384: PUSH
91385: LD_VAR 0 2
91389: PPUSH
91390: LD_INT 21
91392: PUSH
91393: LD_INT 2
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PPUSH
91400: CALL_OW 72
91404: PUSH
91405: FOR_IN
91406: IFFALSE 91531
// begin if GetTag ( i ) <> 20 then
91408: LD_VAR 0 4
91412: PPUSH
91413: CALL_OW 110
91417: PUSH
91418: LD_INT 20
91420: NONEQUAL
91421: IFFALSE 91435
// SetTag ( i , 20 ) ;
91423: LD_VAR 0 4
91427: PPUSH
91428: LD_INT 20
91430: PPUSH
91431: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
91435: LD_VAR 0 4
91439: PPUSH
91440: CALL_OW 263
91444: PUSH
91445: LD_INT 1
91447: EQUAL
91448: IFFALSE 91462
91450: PUSH
91451: LD_VAR 0 4
91455: PPUSH
91456: CALL_OW 311
91460: NOT
91461: AND
91462: IFFALSE 91529
// begin un := mechs [ 1 ] ;
91464: LD_ADDR_VAR 0 10
91468: PUSH
91469: LD_VAR 0 12
91473: PUSH
91474: LD_INT 1
91476: ARRAY
91477: ST_TO_ADDR
// ComExit ( un ) ;
91478: LD_VAR 0 10
91482: PPUSH
91483: CALL 49745 0 1
// AddComEnterUnit ( un , i ) ;
91487: LD_VAR 0 10
91491: PPUSH
91492: LD_VAR 0 4
91496: PPUSH
91497: CALL_OW 180
// SetTag ( un , 19 ) ;
91501: LD_VAR 0 10
91505: PPUSH
91506: LD_INT 19
91508: PPUSH
91509: CALL_OW 109
// mechs := mechs diff un ;
91513: LD_ADDR_VAR 0 12
91517: PUSH
91518: LD_VAR 0 12
91522: PUSH
91523: LD_VAR 0 10
91527: DIFF
91528: ST_TO_ADDR
// end ; end ;
91529: GO 91405
91531: POP
91532: POP
// if solds then
91533: LD_VAR 0 8
91537: IFFALSE 91596
// for i in solds do
91539: LD_ADDR_VAR 0 4
91543: PUSH
91544: LD_VAR 0 8
91548: PUSH
91549: FOR_IN
91550: IFFALSE 91594
// if not GetTag ( i ) then
91552: LD_VAR 0 4
91556: PPUSH
91557: CALL_OW 110
91561: NOT
91562: IFFALSE 91592
// begin defenders := defenders union i ;
91564: LD_ADDR_VAR 0 2
91568: PUSH
91569: LD_VAR 0 2
91573: PUSH
91574: LD_VAR 0 4
91578: UNION
91579: ST_TO_ADDR
// SetTag ( i , 18 ) ;
91580: LD_VAR 0 4
91584: PPUSH
91585: LD_INT 18
91587: PPUSH
91588: CALL_OW 109
// end ;
91592: GO 91549
91594: POP
91595: POP
// repeat wait ( 0 0$2 ) ;
91596: LD_INT 70
91598: PPUSH
91599: CALL_OW 67
// enemy := mc_scan [ base ] ;
91603: LD_ADDR_VAR 0 21
91607: PUSH
91608: LD_EXP 46
91612: PUSH
91613: LD_VAR 0 1
91617: ARRAY
91618: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
91619: LD_EXP 23
91623: PUSH
91624: LD_VAR 0 1
91628: ARRAY
91629: NOT
91630: IFTRUE 91647
91632: PUSH
91633: LD_EXP 23
91637: PUSH
91638: LD_VAR 0 1
91642: ARRAY
91643: PUSH
91644: EMPTY
91645: EQUAL
91646: OR
91647: IFFALSE 91684
// begin for i in defenders do
91649: LD_ADDR_VAR 0 4
91653: PUSH
91654: LD_VAR 0 2
91658: PUSH
91659: FOR_IN
91660: IFFALSE 91673
// ComStop ( i ) ;
91662: LD_VAR 0 4
91666: PPUSH
91667: CALL_OW 141
91671: GO 91659
91673: POP
91674: POP
// defenders := [ ] ;
91675: LD_ADDR_VAR 0 2
91679: PUSH
91680: EMPTY
91681: ST_TO_ADDR
// exit ;
91682: GO 93181
// end ; for i in defenders do
91684: LD_ADDR_VAR 0 4
91688: PUSH
91689: LD_VAR 0 2
91693: PUSH
91694: FOR_IN
91695: IFFALSE 92629
// begin e := NearestUnitToUnit ( enemy , i ) ;
91697: LD_ADDR_VAR 0 13
91701: PUSH
91702: LD_VAR 0 21
91706: PPUSH
91707: LD_VAR 0 4
91711: PPUSH
91712: CALL_OW 74
91716: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
91717: LD_ADDR_VAR 0 7
91721: PUSH
91722: LD_EXP 23
91726: PUSH
91727: LD_VAR 0 1
91731: ARRAY
91732: PPUSH
91733: LD_INT 2
91735: PUSH
91736: LD_INT 30
91738: PUSH
91739: LD_INT 0
91741: PUSH
91742: EMPTY
91743: LIST
91744: LIST
91745: PUSH
91746: LD_INT 30
91748: PUSH
91749: LD_INT 1
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: EMPTY
91757: LIST
91758: LIST
91759: LIST
91760: PPUSH
91761: CALL_OW 72
91765: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
91766: LD_ADDR_VAR 0 16
91770: PUSH
91771: LD_VAR 0 7
91775: NOT
91776: IFTRUE 91806
91778: PUSH
91779: LD_VAR 0 7
91783: PPUSH
91784: LD_INT 3
91786: PUSH
91787: LD_INT 24
91789: PUSH
91790: LD_INT 600
91792: PUSH
91793: EMPTY
91794: LIST
91795: LIST
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PPUSH
91801: CALL_OW 72
91805: OR
91806: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
91807: LD_VAR 0 4
91811: PPUSH
91812: CALL_OW 247
91816: PUSH
91817: LD_INT 2
91819: DOUBLE
91820: EQUAL
91821: IFTRUE 91825
91823: GO 92241
91825: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
91826: LD_VAR 0 4
91830: PPUSH
91831: CALL_OW 256
91835: PUSH
91836: LD_INT 1000
91838: EQUAL
91839: IFFALSE 91885
91841: PUSH
91842: LD_VAR 0 4
91846: PPUSH
91847: LD_VAR 0 13
91851: PPUSH
91852: CALL_OW 296
91856: PUSH
91857: LD_INT 40
91859: LESS
91860: IFTRUE 91884
91862: PUSH
91863: LD_VAR 0 13
91867: PPUSH
91868: LD_EXP 48
91872: PUSH
91873: LD_VAR 0 1
91877: ARRAY
91878: PPUSH
91879: CALL_OW 308
91883: OR
91884: AND
91885: IFFALSE 92011
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
91887: LD_VAR 0 4
91891: PPUSH
91892: CALL_OW 262
91896: PUSH
91897: LD_INT 1
91899: EQUAL
91900: IFFALSE 91917
91902: PUSH
91903: LD_VAR 0 4
91907: PPUSH
91908: CALL_OW 261
91912: PUSH
91913: LD_INT 30
91915: LESS
91916: AND
91917: IFFALSE 91925
91919: PUSH
91920: LD_VAR 0 7
91924: AND
91925: IFFALSE 91995
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
91927: LD_VAR 0 4
91931: PPUSH
91932: LD_VAR 0 7
91936: PPUSH
91937: LD_VAR 0 4
91941: PPUSH
91942: CALL_OW 74
91946: PPUSH
91947: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
91951: LD_VAR 0 4
91955: PPUSH
91956: LD_VAR 0 7
91960: PPUSH
91961: LD_VAR 0 4
91965: PPUSH
91966: CALL_OW 74
91970: PPUSH
91971: CALL_OW 296
91975: PUSH
91976: LD_INT 6
91978: LESS
91979: IFFALSE 91993
// SetFuel ( i , 100 ) ;
91981: LD_VAR 0 4
91985: PPUSH
91986: LD_INT 100
91988: PPUSH
91989: CALL_OW 240
// end else
91993: GO 92009
// ComAttackUnit ( i , e ) ;
91995: LD_VAR 0 4
91999: PPUSH
92000: LD_VAR 0 13
92004: PPUSH
92005: CALL_OW 115
// end else
92009: GO 92118
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
92011: LD_VAR 0 13
92015: PPUSH
92016: LD_EXP 48
92020: PUSH
92021: LD_VAR 0 1
92025: ARRAY
92026: PPUSH
92027: CALL_OW 308
92031: NOT
92032: IFFALSE 92054
92034: PUSH
92035: LD_VAR 0 4
92039: PPUSH
92040: LD_VAR 0 13
92044: PPUSH
92045: CALL_OW 296
92049: PUSH
92050: LD_INT 40
92052: GREATEREQUAL
92053: AND
92054: IFTRUE 92071
92056: PUSH
92057: LD_VAR 0 4
92061: PPUSH
92062: CALL_OW 256
92066: PUSH
92067: LD_INT 650
92069: LESSEQUAL
92070: OR
92071: IFFALSE 92096
92073: PUSH
92074: LD_VAR 0 4
92078: PPUSH
92079: LD_EXP 47
92083: PUSH
92084: LD_VAR 0 1
92088: ARRAY
92089: PPUSH
92090: CALL_OW 308
92094: NOT
92095: AND
92096: IFFALSE 92118
// ComMoveToArea ( i , mc_parking [ base ] ) ;
92098: LD_VAR 0 4
92102: PPUSH
92103: LD_EXP 47
92107: PUSH
92108: LD_VAR 0 1
92112: ARRAY
92113: PPUSH
92114: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
92118: LD_VAR 0 4
92122: PPUSH
92123: CALL_OW 256
92127: PUSH
92128: LD_INT 1000
92130: LESS
92131: IFFALSE 92148
92133: PUSH
92134: LD_VAR 0 4
92138: PPUSH
92139: CALL_OW 263
92143: PUSH
92144: LD_INT 1
92146: EQUAL
92147: AND
92148: IFFALSE 92161
92150: PUSH
92151: LD_VAR 0 4
92155: PPUSH
92156: CALL_OW 311
92160: AND
92161: IFFALSE 92185
92163: PUSH
92164: LD_VAR 0 4
92168: PPUSH
92169: LD_EXP 47
92173: PUSH
92174: LD_VAR 0 1
92178: ARRAY
92179: PPUSH
92180: CALL_OW 308
92184: AND
92185: IFFALSE 92239
// begin mech := IsDrivenBy ( i ) ;
92187: LD_ADDR_VAR 0 9
92191: PUSH
92192: LD_VAR 0 4
92196: PPUSH
92197: CALL_OW 311
92201: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
92202: LD_VAR 0 9
92206: PPUSH
92207: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
92211: LD_VAR 0 9
92215: PPUSH
92216: LD_VAR 0 4
92220: PPUSH
92221: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
92225: LD_VAR 0 9
92229: PPUSH
92230: LD_VAR 0 4
92234: PPUSH
92235: CALL_OW 180
// end ; end ; unit_human :
92239: GO 92600
92241: LD_INT 1
92243: DOUBLE
92244: EQUAL
92245: IFTRUE 92249
92247: GO 92599
92249: POP
// begin b := IsInUnit ( i ) ;
92250: LD_ADDR_VAR 0 18
92254: PUSH
92255: LD_VAR 0 4
92259: PPUSH
92260: CALL_OW 310
92264: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
92265: LD_ADDR_VAR 0 19
92269: PUSH
92270: LD_VAR 0 18
92274: NOT
92275: IFTRUE 92299
92277: PUSH
92278: LD_VAR 0 18
92282: PPUSH
92283: CALL_OW 266
92287: PUSH
92288: LD_INT 32
92290: PUSH
92291: LD_INT 31
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: IN
92298: OR
92299: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
92300: LD_VAR 0 18
92304: PPUSH
92305: CALL_OW 266
92309: PUSH
92310: LD_INT 5
92312: EQUAL
92313: IFFALSE 92345
92315: PUSH
92316: LD_VAR 0 4
92320: PPUSH
92321: CALL_OW 257
92325: PUSH
92326: LD_INT 1
92328: PUSH
92329: LD_INT 2
92331: PUSH
92332: LD_INT 3
92334: PUSH
92335: LD_INT 4
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: IN
92344: AND
92345: IFFALSE 92382
// begin class := AllowSpecClass ( i ) ;
92347: LD_ADDR_VAR 0 20
92351: PUSH
92352: LD_VAR 0 4
92356: PPUSH
92357: CALL 13055 0 1
92361: ST_TO_ADDR
// if class then
92362: LD_VAR 0 20
92366: IFFALSE 92382
// ComChangeProfession ( i , class ) ;
92368: LD_VAR 0 4
92372: PPUSH
92373: LD_VAR 0 20
92377: PPUSH
92378: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
92382: LD_VAR 0 16
92386: IFTRUE 92413
92388: PUSH
92389: LD_VAR 0 2
92393: PPUSH
92394: LD_INT 21
92396: PUSH
92397: LD_INT 2
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PPUSH
92404: CALL_OW 72
92408: PUSH
92409: LD_INT 1
92411: LESSEQUAL
92412: OR
92413: IFFALSE 92421
92415: PUSH
92416: LD_VAR 0 19
92420: AND
92421: IFFALSE 92436
92423: PUSH
92424: LD_VAR 0 4
92428: PUSH
92429: LD_VAR 0 17
92433: IN
92434: NOT
92435: AND
92436: IFFALSE 92531
// begin if b then
92438: LD_VAR 0 18
92442: IFFALSE 92493
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
92444: LD_VAR 0 18
92448: PPUSH
92449: LD_VAR 0 21
92453: PPUSH
92454: LD_VAR 0 18
92458: PPUSH
92459: CALL_OW 74
92463: PPUSH
92464: CALL_OW 296
92468: PUSH
92469: LD_INT 10
92471: LESS
92472: IFFALSE 92489
92474: PUSH
92475: LD_VAR 0 18
92479: PPUSH
92480: CALL_OW 461
92484: PUSH
92485: LD_INT 7
92487: NONEQUAL
92488: AND
92489: IFFALSE 92493
// continue ;
92491: GO 91694
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
92493: LD_ADDR_VAR 0 17
92497: PUSH
92498: LD_VAR 0 17
92502: PPUSH
92503: LD_VAR 0 17
92507: PUSH
92508: LD_INT 1
92510: PLUS
92511: PPUSH
92512: LD_VAR 0 4
92516: PPUSH
92517: CALL_OW 1
92521: ST_TO_ADDR
// ComExitBuilding ( i ) ;
92522: LD_VAR 0 4
92526: PPUSH
92527: CALL_OW 122
// end ; if sold_defenders then
92531: LD_VAR 0 17
92535: IFFALSE 92597
// if i in sold_defenders then
92537: LD_VAR 0 4
92541: PUSH
92542: LD_VAR 0 17
92546: IN
92547: IFFALSE 92597
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
92549: LD_VAR 0 4
92553: PPUSH
92554: CALL_OW 314
92558: NOT
92559: IFFALSE 92581
92561: PUSH
92562: LD_VAR 0 4
92566: PPUSH
92567: LD_VAR 0 13
92571: PPUSH
92572: CALL_OW 296
92576: PUSH
92577: LD_INT 30
92579: LESS
92580: AND
92581: IFFALSE 92597
// ComAttackUnit ( i , e ) ;
92583: LD_VAR 0 4
92587: PPUSH
92588: LD_VAR 0 13
92592: PPUSH
92593: CALL_OW 115
// end ; end ; end ;
92597: GO 92600
92599: POP
// if IsDead ( i ) then
92600: LD_VAR 0 4
92604: PPUSH
92605: CALL_OW 301
92609: IFFALSE 92627
// defenders := defenders diff i ;
92611: LD_ADDR_VAR 0 2
92615: PUSH
92616: LD_VAR 0 2
92620: PUSH
92621: LD_VAR 0 4
92625: DIFF
92626: ST_TO_ADDR
// end ;
92627: GO 91694
92629: POP
92630: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
92631: LD_VAR 0 21
92635: NOT
92636: IFTRUE 92645
92638: PUSH
92639: LD_VAR 0 2
92643: NOT
92644: OR
92645: IFTRUE 92660
92647: PUSH
92648: LD_EXP 23
92652: PUSH
92653: LD_VAR 0 1
92657: ARRAY
92658: NOT
92659: OR
92660: IFFALSE 91596
// MC_Reset ( base , 18 ) ;
92662: LD_VAR 0 1
92666: PPUSH
92667: LD_INT 18
92669: PPUSH
92670: CALL 58870 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
92674: LD_ADDR_VAR 0 2
92678: PUSH
92679: LD_VAR 0 2
92683: PUSH
92684: LD_VAR 0 2
92688: PPUSH
92689: LD_INT 2
92691: PUSH
92692: LD_INT 25
92694: PUSH
92695: LD_INT 1
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: PUSH
92702: LD_INT 25
92704: PUSH
92705: LD_INT 5
92707: PUSH
92708: EMPTY
92709: LIST
92710: LIST
92711: PUSH
92712: LD_INT 25
92714: PUSH
92715: LD_INT 8
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: PUSH
92722: LD_INT 25
92724: PUSH
92725: LD_INT 9
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: PPUSH
92739: CALL_OW 72
92743: DIFF
92744: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
92745: LD_VAR 0 21
92749: NOT
92750: IFFALSE 92773
92752: PUSH
92753: LD_VAR 0 2
92757: PPUSH
92758: LD_INT 21
92760: PUSH
92761: LD_INT 2
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PPUSH
92768: CALL_OW 72
92772: AND
92773: IFFALSE 93117
// begin tmp := FilterByTag ( defenders , 19 ) ;
92775: LD_ADDR_VAR 0 11
92779: PUSH
92780: LD_VAR 0 2
92784: PPUSH
92785: LD_INT 19
92787: PPUSH
92788: CALL 46892 0 2
92792: ST_TO_ADDR
// if tmp then
92793: LD_VAR 0 11
92797: IFFALSE 92867
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
92799: LD_ADDR_VAR 0 11
92803: PUSH
92804: LD_VAR 0 11
92808: PPUSH
92809: LD_INT 25
92811: PUSH
92812: LD_INT 3
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PPUSH
92819: CALL_OW 72
92823: ST_TO_ADDR
// if tmp then
92824: LD_VAR 0 11
92828: IFFALSE 92867
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
92830: LD_ADDR_EXP 35
92834: PUSH
92835: LD_EXP 35
92839: PPUSH
92840: LD_VAR 0 1
92844: PPUSH
92845: LD_EXP 35
92849: PUSH
92850: LD_VAR 0 1
92854: ARRAY
92855: PUSH
92856: LD_VAR 0 11
92860: UNION
92861: PPUSH
92862: CALL_OW 1
92866: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
92867: LD_VAR 0 1
92871: PPUSH
92872: LD_INT 19
92874: PPUSH
92875: CALL 58870 0 2
// repeat wait ( 0 0$1 ) ;
92879: LD_INT 35
92881: PPUSH
92882: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
92886: LD_EXP 23
92890: PUSH
92891: LD_VAR 0 1
92895: ARRAY
92896: NOT
92897: IFTRUE 92914
92899: PUSH
92900: LD_EXP 23
92904: PUSH
92905: LD_VAR 0 1
92909: ARRAY
92910: PUSH
92911: EMPTY
92912: EQUAL
92913: OR
92914: IFFALSE 92951
// begin for i in defenders do
92916: LD_ADDR_VAR 0 4
92920: PUSH
92921: LD_VAR 0 2
92925: PUSH
92926: FOR_IN
92927: IFFALSE 92940
// ComStop ( i ) ;
92929: LD_VAR 0 4
92933: PPUSH
92934: CALL_OW 141
92938: GO 92926
92940: POP
92941: POP
// defenders := [ ] ;
92942: LD_ADDR_VAR 0 2
92946: PUSH
92947: EMPTY
92948: ST_TO_ADDR
// exit ;
92949: GO 93181
// end ; for i in defenders do
92951: LD_ADDR_VAR 0 4
92955: PUSH
92956: LD_VAR 0 2
92960: PUSH
92961: FOR_IN
92962: IFFALSE 93051
// begin if not IsInArea ( i , mc_parking [ base ] ) then
92964: LD_VAR 0 4
92968: PPUSH
92969: LD_EXP 47
92973: PUSH
92974: LD_VAR 0 1
92978: ARRAY
92979: PPUSH
92980: CALL_OW 308
92984: NOT
92985: IFFALSE 93009
// ComMoveToArea ( i , mc_parking [ base ] ) else
92987: LD_VAR 0 4
92991: PPUSH
92992: LD_EXP 47
92996: PUSH
92997: LD_VAR 0 1
93001: ARRAY
93002: PPUSH
93003: CALL_OW 113
93007: GO 93049
// if GetControl ( i ) = control_manual then
93009: LD_VAR 0 4
93013: PPUSH
93014: CALL_OW 263
93018: PUSH
93019: LD_INT 1
93021: EQUAL
93022: IFFALSE 93049
// if IsDrivenBy ( i ) then
93024: LD_VAR 0 4
93028: PPUSH
93029: CALL_OW 311
93033: IFFALSE 93049
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
93035: LD_VAR 0 4
93039: PPUSH
93040: CALL_OW 311
93044: PPUSH
93045: CALL_OW 121
// end ;
93049: GO 92961
93051: POP
93052: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
93053: LD_VAR 0 2
93057: PPUSH
93058: LD_INT 95
93060: PUSH
93061: LD_EXP 47
93065: PUSH
93066: LD_VAR 0 1
93070: ARRAY
93071: PUSH
93072: EMPTY
93073: LIST
93074: LIST
93075: PPUSH
93076: CALL_OW 72
93080: PUSH
93081: LD_VAR 0 2
93085: EQUAL
93086: IFTRUE 93100
93088: PUSH
93089: LD_EXP 46
93093: PUSH
93094: LD_VAR 0 1
93098: ARRAY
93099: OR
93100: IFTRUE 93115
93102: PUSH
93103: LD_EXP 23
93107: PUSH
93108: LD_VAR 0 1
93112: ARRAY
93113: NOT
93114: OR
93115: IFFALSE 92879
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
93117: LD_ADDR_EXP 45
93121: PUSH
93122: LD_EXP 45
93126: PPUSH
93127: LD_VAR 0 1
93131: PPUSH
93132: LD_VAR 0 2
93136: PPUSH
93137: LD_INT 21
93139: PUSH
93140: LD_INT 2
93142: PUSH
93143: EMPTY
93144: LIST
93145: LIST
93146: PPUSH
93147: CALL_OW 72
93151: PPUSH
93152: CALL_OW 1
93156: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
93157: LD_VAR 0 1
93161: PPUSH
93162: LD_INT 19
93164: PPUSH
93165: CALL 58870 0 2
// MC_Reset ( base , 20 ) ;
93169: LD_VAR 0 1
93173: PPUSH
93174: LD_INT 20
93176: PPUSH
93177: CALL 58870 0 2
// end ; end_of_file
93181: LD_VAR 0 3
93185: RET
// export function SOS_UnitDestroyed ( un ) ; begin
93186: LD_INT 0
93188: PPUSH
// ComRadiation ( un ) ;
93189: LD_VAR 0 1
93193: PPUSH
93194: CALL 94356 0 1
// end ;
93198: LD_VAR 0 2
93202: RET
// export function SOS_UnitKamikazed ( un ) ; begin
93203: LD_INT 0
93205: PPUSH
// ComRadiation ( un ) ;
93206: LD_VAR 0 1
93210: PPUSH
93211: CALL 94356 0 1
// end ;
93215: LD_VAR 0 2
93219: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93220: LD_INT 0
93222: PPUSH
// end ;
93223: LD_VAR 0 4
93227: RET
// export function SOS_Command ( cmd ) ; begin
93228: LD_INT 0
93230: PPUSH
// end ;
93231: LD_VAR 0 2
93235: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
93236: LD_INT 0
93238: PPUSH
// end ;
93239: LD_VAR 0 6
93243: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
93244: LD_INT 0
93246: PPUSH
93247: PPUSH
93248: PPUSH
93249: PPUSH
93250: PPUSH
// if not vehicle or not factory then
93251: LD_VAR 0 1
93255: NOT
93256: IFTRUE 93265
93258: PUSH
93259: LD_VAR 0 2
93263: NOT
93264: OR
93265: IFFALSE 93269
// exit ;
93267: GO 93931
// weapon := GetWeapon ( vehicle ) ;
93269: LD_ADDR_VAR 0 7
93273: PUSH
93274: LD_VAR 0 1
93278: PPUSH
93279: CALL_OW 264
93283: ST_TO_ADDR
// if weapon = ar_miner then
93284: LD_VAR 0 7
93288: PUSH
93289: LD_INT 81
93291: EQUAL
93292: IFFALSE 93349
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
93294: LD_ADDR_EXP 75
93298: PUSH
93299: LD_EXP 75
93303: PPUSH
93304: LD_EXP 75
93308: PUSH
93309: LD_INT 1
93311: PLUS
93312: PPUSH
93313: LD_VAR 0 1
93317: PPUSH
93318: CALL_OW 1
93322: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
93323: LD_ADDR_EXP 76
93327: PUSH
93328: LD_EXP 76
93332: PPUSH
93333: LD_EXP 76
93337: PUSH
93338: LD_INT 1
93340: PLUS
93341: PPUSH
93342: EMPTY
93343: PPUSH
93344: CALL_OW 1
93348: ST_TO_ADDR
// end ; if not factoryWaypoints then
93349: LD_EXP 137
93353: NOT
93354: IFFALSE 93358
// exit ;
93356: GO 93931
// for i := 1 to Count ( factoryWaypoints ) do
93358: LD_ADDR_VAR 0 4
93362: PUSH
93363: DOUBLE
93364: LD_INT 1
93366: DEC
93367: ST_TO_ADDR
93368: LD_EXP 137
93372: PPUSH
93373: CALL 13371 0 1
93377: PUSH
93378: FOR_TO
93379: IFFALSE 93929
// if factoryWaypoints [ i ] [ 2 ] = factory then
93381: LD_EXP 137
93385: PUSH
93386: LD_VAR 0 4
93390: ARRAY
93391: PUSH
93392: LD_INT 2
93394: ARRAY
93395: PUSH
93396: LD_VAR 0 2
93400: EQUAL
93401: IFFALSE 93927
// begin if GetControl ( vehicle ) = control_manual then
93403: LD_VAR 0 1
93407: PPUSH
93408: CALL_OW 263
93412: PUSH
93413: LD_INT 1
93415: EQUAL
93416: IFFALSE 93780
// begin driver := IsDrivenBy ( vehicle ) ;
93418: LD_ADDR_VAR 0 5
93422: PUSH
93423: LD_VAR 0 1
93427: PPUSH
93428: CALL_OW 311
93432: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
93433: LD_VAR 0 5
93437: PUSH
93438: LD_EXP 138
93442: IN
93443: IFTRUE 93457
93445: PUSH
93446: LD_VAR 0 1
93450: PUSH
93451: LD_EXP 138
93455: IN
93456: OR
93457: IFFALSE 93463
// exit ;
93459: POP
93460: POP
93461: GO 93931
// if not HasTask ( driver ) then
93463: LD_VAR 0 5
93467: PPUSH
93468: CALL_OW 314
93472: NOT
93473: IFFALSE 93778
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
93475: LD_ADDR_EXP 138
93479: PUSH
93480: LD_EXP 138
93484: PPUSH
93485: LD_VAR 0 5
93489: PPUSH
93490: CALL 49347 0 2
93494: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
93495: LD_ADDR_EXP 138
93499: PUSH
93500: LD_EXP 138
93504: PPUSH
93505: LD_VAR 0 1
93509: PPUSH
93510: CALL 49347 0 2
93514: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93515: LD_ADDR_VAR 0 6
93519: PUSH
93520: LD_EXP 137
93524: PUSH
93525: LD_VAR 0 4
93529: ARRAY
93530: PUSH
93531: LD_INT 3
93533: ARRAY
93534: PPUSH
93535: LD_EXP 137
93539: PUSH
93540: LD_VAR 0 4
93544: ARRAY
93545: PUSH
93546: LD_INT 4
93548: ARRAY
93549: PPUSH
93550: CALL_OW 428
93554: ST_TO_ADDR
// if hex then
93555: LD_VAR 0 6
93559: IFFALSE 93577
// ComMoveUnit ( driver , hex ) else
93561: LD_VAR 0 5
93565: PPUSH
93566: LD_VAR 0 6
93570: PPUSH
93571: CALL_OW 112
93575: GO 93661
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
93577: LD_VAR 0 1
93581: PPUSH
93582: LD_EXP 137
93586: PUSH
93587: LD_VAR 0 4
93591: ARRAY
93592: PUSH
93593: LD_INT 3
93595: ARRAY
93596: PPUSH
93597: LD_EXP 137
93601: PUSH
93602: LD_VAR 0 4
93606: ARRAY
93607: PUSH
93608: LD_INT 4
93610: ARRAY
93611: PPUSH
93612: CALL_OW 297
93616: PUSH
93617: LD_INT 0
93619: GREATER
93620: IFFALSE 93661
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93622: LD_VAR 0 5
93626: PPUSH
93627: LD_EXP 137
93631: PUSH
93632: LD_VAR 0 4
93636: ARRAY
93637: PUSH
93638: LD_INT 3
93640: ARRAY
93641: PPUSH
93642: LD_EXP 137
93646: PUSH
93647: LD_VAR 0 4
93651: ARRAY
93652: PUSH
93653: LD_INT 4
93655: ARRAY
93656: PPUSH
93657: CALL_OW 111
// AddComExitVehicle ( driver ) ;
93661: LD_VAR 0 5
93665: PPUSH
93666: CALL_OW 181
// if Multiplayer then
93670: LD_OWVAR 4
93674: IFFALSE 93723
// begin repeat wait ( 10 ) ;
93676: LD_INT 10
93678: PPUSH
93679: CALL_OW 67
// until not IsInUnit ( driver ) ;
93683: LD_VAR 0 5
93687: PPUSH
93688: CALL_OW 310
93692: NOT
93693: IFFALSE 93676
// if not HasTask ( driver ) then
93695: LD_VAR 0 5
93699: PPUSH
93700: CALL_OW 314
93704: NOT
93705: IFFALSE 93721
// ComEnterUnit ( driver , factory ) ;
93707: LD_VAR 0 5
93711: PPUSH
93712: LD_VAR 0 2
93716: PPUSH
93717: CALL_OW 120
// end else
93721: GO 93737
// AddComEnterUnit ( driver , factory ) ;
93723: LD_VAR 0 5
93727: PPUSH
93728: LD_VAR 0 2
93732: PPUSH
93733: CALL_OW 180
// wait ( 0 0$1 ) ;
93737: LD_INT 35
93739: PPUSH
93740: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
93744: LD_ADDR_EXP 138
93748: PUSH
93749: LD_EXP 138
93753: PUSH
93754: LD_VAR 0 5
93758: DIFF
93759: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
93760: LD_ADDR_EXP 138
93764: PUSH
93765: LD_EXP 138
93769: PUSH
93770: LD_VAR 0 1
93774: DIFF
93775: ST_TO_ADDR
// break ;
93776: GO 93929
// end ; end else
93778: GO 93927
// if GetControl ( vehicle ) = control_remote then
93780: LD_VAR 0 1
93784: PPUSH
93785: CALL_OW 263
93789: PUSH
93790: LD_INT 2
93792: EQUAL
93793: IFFALSE 93879
// begin wait ( 0 0$2 ) ;
93795: LD_INT 70
93797: PPUSH
93798: CALL_OW 67
// repeat wait ( 10 ) ;
93802: LD_INT 10
93804: PPUSH
93805: CALL_OW 67
// Connect ( vehicle ) ;
93809: LD_VAR 0 1
93813: PPUSH
93814: CALL 19649 0 1
// until IsControledBy ( vehicle ) ;
93818: LD_VAR 0 1
93822: PPUSH
93823: CALL_OW 312
93827: IFFALSE 93802
// wait ( 10 ) ;
93829: LD_INT 10
93831: PPUSH
93832: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93836: LD_VAR 0 1
93840: PPUSH
93841: LD_EXP 137
93845: PUSH
93846: LD_VAR 0 4
93850: ARRAY
93851: PUSH
93852: LD_INT 3
93854: ARRAY
93855: PPUSH
93856: LD_EXP 137
93860: PUSH
93861: LD_VAR 0 4
93865: ARRAY
93866: PUSH
93867: LD_INT 4
93869: ARRAY
93870: PPUSH
93871: CALL_OW 111
// break ;
93875: GO 93929
// end else
93877: GO 93927
// begin wait ( 0 0$3 ) ;
93879: LD_INT 105
93881: PPUSH
93882: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93886: LD_VAR 0 1
93890: PPUSH
93891: LD_EXP 137
93895: PUSH
93896: LD_VAR 0 4
93900: ARRAY
93901: PUSH
93902: LD_INT 3
93904: ARRAY
93905: PPUSH
93906: LD_EXP 137
93910: PUSH
93911: LD_VAR 0 4
93915: ARRAY
93916: PUSH
93917: LD_INT 4
93919: ARRAY
93920: PPUSH
93921: CALL_OW 111
// break ;
93925: GO 93929
// end ; end ;
93927: GO 93378
93929: POP
93930: POP
// end ;
93931: LD_VAR 0 3
93935: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
93936: LD_INT 0
93938: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
93939: LD_VAR 0 1
93943: PUSH
93944: LD_INT 250
93946: EQUAL
93947: IFFALSE 93964
93949: PUSH
93950: LD_VAR 0 2
93954: PPUSH
93955: CALL_OW 264
93959: PUSH
93960: LD_INT 81
93962: EQUAL
93963: AND
93964: IFFALSE 93985
// MinerPlaceMine ( unit , x , y ) ;
93966: LD_VAR 0 2
93970: PPUSH
93971: LD_VAR 0 4
93975: PPUSH
93976: LD_VAR 0 5
93980: PPUSH
93981: CALL 97331 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
93985: LD_VAR 0 1
93989: PUSH
93990: LD_INT 251
93992: EQUAL
93993: IFFALSE 94010
93995: PUSH
93996: LD_VAR 0 2
94000: PPUSH
94001: CALL_OW 264
94005: PUSH
94006: LD_INT 81
94008: EQUAL
94009: AND
94010: IFFALSE 94031
// MinerDetonateMine ( unit , x , y ) ;
94012: LD_VAR 0 2
94016: PPUSH
94017: LD_VAR 0 4
94021: PPUSH
94022: LD_VAR 0 5
94026: PPUSH
94027: CALL 97738 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94031: LD_VAR 0 1
94035: PUSH
94036: LD_INT 252
94038: EQUAL
94039: IFFALSE 94056
94041: PUSH
94042: LD_VAR 0 2
94046: PPUSH
94047: CALL_OW 264
94051: PUSH
94052: LD_INT 81
94054: EQUAL
94055: AND
94056: IFFALSE 94077
// MinerCreateMinefield ( unit , x , y ) ;
94058: LD_VAR 0 2
94062: PPUSH
94063: LD_VAR 0 4
94067: PPUSH
94068: LD_VAR 0 5
94072: PPUSH
94073: CALL 97970 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
94077: LD_VAR 0 1
94081: PUSH
94082: LD_INT 253
94084: EQUAL
94085: IFFALSE 94102
94087: PUSH
94088: LD_VAR 0 2
94092: PPUSH
94093: CALL_OW 257
94097: PUSH
94098: LD_INT 5
94100: EQUAL
94101: AND
94102: IFFALSE 94123
// ComBinocular ( unit , x , y ) ;
94104: LD_VAR 0 2
94108: PPUSH
94109: LD_VAR 0 4
94113: PPUSH
94114: LD_VAR 0 5
94118: PPUSH
94119: CALL 98345 0 3
// if selectedUnit then
94123: LD_VAR 0 3
94127: IFFALSE 94187
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94129: LD_VAR 0 1
94133: PUSH
94134: LD_INT 254
94136: EQUAL
94137: IFFALSE 94154
94139: PUSH
94140: LD_VAR 0 2
94144: PPUSH
94145: CALL_OW 264
94149: PUSH
94150: LD_INT 99
94152: EQUAL
94153: AND
94154: IFFALSE 94171
94156: PUSH
94157: LD_VAR 0 3
94161: PPUSH
94162: CALL_OW 263
94166: PUSH
94167: LD_INT 3
94169: EQUAL
94170: AND
94171: IFFALSE 94187
// HackDestroyVehicle ( unit , selectedUnit ) ;
94173: LD_VAR 0 2
94177: PPUSH
94178: LD_VAR 0 3
94182: PPUSH
94183: CALL 96521 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94187: LD_VAR 0 1
94191: PUSH
94192: LD_INT 255
94194: EQUAL
94195: IFFALSE 94219
94197: PUSH
94198: LD_VAR 0 2
94202: PPUSH
94203: CALL_OW 264
94207: PUSH
94208: LD_INT 14
94210: PUSH
94211: LD_INT 53
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: IN
94218: AND
94219: IFFALSE 94237
94221: PUSH
94222: LD_VAR 0 4
94226: PPUSH
94227: LD_VAR 0 5
94231: PPUSH
94232: CALL_OW 488
94236: AND
94237: IFFALSE 94261
// CutTreeXYR ( unit , x , y , 12 ) ;
94239: LD_VAR 0 2
94243: PPUSH
94244: LD_VAR 0 4
94248: PPUSH
94249: LD_VAR 0 5
94253: PPUSH
94254: LD_INT 12
94256: PPUSH
94257: CALL 94452 0 4
// if cmd = 256 then
94261: LD_VAR 0 1
94265: PUSH
94266: LD_INT 256
94268: EQUAL
94269: IFFALSE 94290
// SetFactoryWaypoint ( unit , x , y ) ;
94271: LD_VAR 0 2
94275: PPUSH
94276: LD_VAR 0 4
94280: PPUSH
94281: LD_VAR 0 5
94285: PPUSH
94286: CALL 114454 0 3
// if cmd = 257 then
94290: LD_VAR 0 1
94294: PUSH
94295: LD_INT 257
94297: EQUAL
94298: IFFALSE 94319
// SetWarehouseGatheringPoint ( unit , x , y ) ;
94300: LD_VAR 0 2
94304: PPUSH
94305: LD_VAR 0 4
94309: PPUSH
94310: LD_VAR 0 5
94314: PPUSH
94315: CALL 114950 0 3
// if cmd = 258 then
94319: LD_VAR 0 1
94323: PUSH
94324: LD_INT 258
94326: EQUAL
94327: IFFALSE 94351
// BurnTreeXYR ( unit , x , y , 8 ) ;
94329: LD_VAR 0 2
94333: PPUSH
94334: LD_VAR 0 4
94338: PPUSH
94339: LD_VAR 0 5
94343: PPUSH
94344: LD_INT 8
94346: PPUSH
94347: CALL 94874 0 4
// end ;
94351: LD_VAR 0 6
94355: RET
// export function ComRadiation ( un ) ; var eff ; begin
94356: LD_INT 0
94358: PPUSH
94359: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
94360: LD_VAR 0 1
94364: PPUSH
94365: CALL_OW 264
94369: PUSH
94370: LD_INT 91
94372: NONEQUAL
94373: IFFALSE 94377
// exit ;
94375: GO 94447
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94377: LD_INT 68
94379: PPUSH
94380: LD_VAR 0 1
94384: PPUSH
94385: CALL_OW 255
94389: PPUSH
94390: CALL_OW 321
94394: PUSH
94395: LD_INT 2
94397: EQUAL
94398: IFFALSE 94410
// eff := 50 else
94400: LD_ADDR_VAR 0 3
94404: PUSH
94405: LD_INT 50
94407: ST_TO_ADDR
94408: GO 94418
// eff := 25 ;
94410: LD_ADDR_VAR 0 3
94414: PUSH
94415: LD_INT 25
94417: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94418: LD_VAR 0 1
94422: PPUSH
94423: CALL_OW 250
94427: PPUSH
94428: LD_VAR 0 1
94432: PPUSH
94433: CALL_OW 251
94437: PPUSH
94438: LD_VAR 0 3
94442: PPUSH
94443: CALL_OW 495
// end ;
94447: LD_VAR 0 2
94451: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94452: LD_INT 0
94454: PPUSH
94455: PPUSH
94456: PPUSH
94457: PPUSH
94458: PPUSH
94459: PPUSH
94460: PPUSH
94461: PPUSH
94462: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
94463: LD_VAR 0 1
94467: PPUSH
94468: CALL_OW 302
94472: NOT
94473: IFTRUE 94492
94475: PUSH
94476: LD_VAR 0 2
94480: PPUSH
94481: LD_VAR 0 3
94485: PPUSH
94486: CALL_OW 488
94490: NOT
94491: OR
94492: IFTRUE 94501
94494: PUSH
94495: LD_VAR 0 4
94499: NOT
94500: OR
94501: IFFALSE 94505
// exit ;
94503: GO 94869
// if Count ( GetTaskList ( bulldozer ) ) > 10 then
94505: LD_VAR 0 1
94509: PPUSH
94510: CALL_OW 437
94514: PPUSH
94515: CALL 13371 0 1
94519: PUSH
94520: LD_INT 10
94522: GREATER
94523: IFFALSE 94527
// exit ;
94525: GO 94869
// list := [ ] ;
94527: LD_ADDR_VAR 0 13
94531: PUSH
94532: EMPTY
94533: ST_TO_ADDR
// if x - r < 0 then
94534: LD_VAR 0 2
94538: PUSH
94539: LD_VAR 0 4
94543: MINUS
94544: PUSH
94545: LD_INT 0
94547: LESS
94548: IFFALSE 94560
// min_x := 0 else
94550: LD_ADDR_VAR 0 7
94554: PUSH
94555: LD_INT 0
94557: ST_TO_ADDR
94558: GO 94576
// min_x := x - r ;
94560: LD_ADDR_VAR 0 7
94564: PUSH
94565: LD_VAR 0 2
94569: PUSH
94570: LD_VAR 0 4
94574: MINUS
94575: ST_TO_ADDR
// if y - r < 0 then
94576: LD_VAR 0 3
94580: PUSH
94581: LD_VAR 0 4
94585: MINUS
94586: PUSH
94587: LD_INT 0
94589: LESS
94590: IFFALSE 94602
// min_y := 0 else
94592: LD_ADDR_VAR 0 8
94596: PUSH
94597: LD_INT 0
94599: ST_TO_ADDR
94600: GO 94618
// min_y := y - r ;
94602: LD_ADDR_VAR 0 8
94606: PUSH
94607: LD_VAR 0 3
94611: PUSH
94612: LD_VAR 0 4
94616: MINUS
94617: ST_TO_ADDR
// max_x := x + r ;
94618: LD_ADDR_VAR 0 9
94622: PUSH
94623: LD_VAR 0 2
94627: PUSH
94628: LD_VAR 0 4
94632: PLUS
94633: ST_TO_ADDR
// max_y := y + r ;
94634: LD_ADDR_VAR 0 10
94638: PUSH
94639: LD_VAR 0 3
94643: PUSH
94644: LD_VAR 0 4
94648: PLUS
94649: ST_TO_ADDR
// for _x = min_x to max_x do
94650: LD_ADDR_VAR 0 11
94654: PUSH
94655: DOUBLE
94656: LD_VAR 0 7
94660: DEC
94661: ST_TO_ADDR
94662: LD_VAR 0 9
94666: PUSH
94667: FOR_TO
94668: IFFALSE 94787
// for _y = min_y to max_y do
94670: LD_ADDR_VAR 0 12
94674: PUSH
94675: DOUBLE
94676: LD_VAR 0 8
94680: DEC
94681: ST_TO_ADDR
94682: LD_VAR 0 10
94686: PUSH
94687: FOR_TO
94688: IFFALSE 94783
// begin if not ValidHex ( _x , _y ) then
94690: LD_VAR 0 11
94694: PPUSH
94695: LD_VAR 0 12
94699: PPUSH
94700: CALL_OW 488
94704: NOT
94705: IFFALSE 94709
// continue ;
94707: GO 94687
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94709: LD_VAR 0 11
94713: PPUSH
94714: LD_VAR 0 12
94718: PPUSH
94719: CALL_OW 351
94723: IFFALSE 94741
94725: PUSH
94726: LD_VAR 0 11
94730: PPUSH
94731: LD_VAR 0 12
94735: PPUSH
94736: CALL_OW 554
94740: AND
94741: IFFALSE 94781
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94743: LD_ADDR_VAR 0 13
94747: PUSH
94748: LD_VAR 0 13
94752: PPUSH
94753: LD_VAR 0 13
94757: PUSH
94758: LD_INT 1
94760: PLUS
94761: PPUSH
94762: LD_VAR 0 11
94766: PUSH
94767: LD_VAR 0 12
94771: PUSH
94772: EMPTY
94773: LIST
94774: LIST
94775: PPUSH
94776: CALL_OW 2
94780: ST_TO_ADDR
// end ;
94781: GO 94687
94783: POP
94784: POP
94785: GO 94667
94787: POP
94788: POP
// if not list then
94789: LD_VAR 0 13
94793: NOT
94794: IFFALSE 94798
// exit ;
94796: GO 94869
// for i in list do
94798: LD_ADDR_VAR 0 6
94802: PUSH
94803: LD_VAR 0 13
94807: PUSH
94808: FOR_IN
94809: IFFALSE 94867
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94811: LD_VAR 0 1
94815: PPUSH
94816: LD_STRING M
94818: PUSH
94819: LD_VAR 0 6
94823: PUSH
94824: LD_INT 1
94826: ARRAY
94827: PUSH
94828: LD_VAR 0 6
94832: PUSH
94833: LD_INT 2
94835: ARRAY
94836: PUSH
94837: LD_INT 0
94839: PUSH
94840: LD_INT 0
94842: PUSH
94843: LD_INT 0
94845: PUSH
94846: LD_INT 0
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: PUSH
94858: EMPTY
94859: LIST
94860: PPUSH
94861: CALL_OW 447
94865: GO 94808
94867: POP
94868: POP
// end ;
94869: LD_VAR 0 5
94873: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
94874: LD_INT 0
94876: PPUSH
94877: PPUSH
94878: PPUSH
94879: PPUSH
94880: PPUSH
94881: PPUSH
94882: PPUSH
94883: PPUSH
94884: PPUSH
94885: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
94886: LD_VAR 0 1
94890: PPUSH
94891: CALL_OW 302
94895: NOT
94896: IFTRUE 94915
94898: PUSH
94899: LD_VAR 0 2
94903: PPUSH
94904: LD_VAR 0 3
94908: PPUSH
94909: CALL_OW 488
94913: NOT
94914: OR
94915: IFTRUE 94924
94917: PUSH
94918: LD_VAR 0 4
94922: NOT
94923: OR
94924: IFFALSE 94928
// exit ;
94926: GO 95467
// if Count ( GetTaskList ( flame ) ) > 10 then
94928: LD_VAR 0 1
94932: PPUSH
94933: CALL_OW 437
94937: PPUSH
94938: CALL 13371 0 1
94942: PUSH
94943: LD_INT 10
94945: GREATER
94946: IFFALSE 94950
// exit ;
94948: GO 95467
// list := [ ] ;
94950: LD_ADDR_VAR 0 13
94954: PUSH
94955: EMPTY
94956: ST_TO_ADDR
// if x - r < 0 then
94957: LD_VAR 0 2
94961: PUSH
94962: LD_VAR 0 4
94966: MINUS
94967: PUSH
94968: LD_INT 0
94970: LESS
94971: IFFALSE 94983
// min_x := 0 else
94973: LD_ADDR_VAR 0 7
94977: PUSH
94978: LD_INT 0
94980: ST_TO_ADDR
94981: GO 94999
// min_x := x - r ;
94983: LD_ADDR_VAR 0 7
94987: PUSH
94988: LD_VAR 0 2
94992: PUSH
94993: LD_VAR 0 4
94997: MINUS
94998: ST_TO_ADDR
// if y - r < 0 then
94999: LD_VAR 0 3
95003: PUSH
95004: LD_VAR 0 4
95008: MINUS
95009: PUSH
95010: LD_INT 0
95012: LESS
95013: IFFALSE 95025
// min_y := 0 else
95015: LD_ADDR_VAR 0 8
95019: PUSH
95020: LD_INT 0
95022: ST_TO_ADDR
95023: GO 95041
// min_y := y - r ;
95025: LD_ADDR_VAR 0 8
95029: PUSH
95030: LD_VAR 0 3
95034: PUSH
95035: LD_VAR 0 4
95039: MINUS
95040: ST_TO_ADDR
// max_x := x + r ;
95041: LD_ADDR_VAR 0 9
95045: PUSH
95046: LD_VAR 0 2
95050: PUSH
95051: LD_VAR 0 4
95055: PLUS
95056: ST_TO_ADDR
// max_y := y + r ;
95057: LD_ADDR_VAR 0 10
95061: PUSH
95062: LD_VAR 0 3
95066: PUSH
95067: LD_VAR 0 4
95071: PLUS
95072: ST_TO_ADDR
// for _x = min_x to max_x do
95073: LD_ADDR_VAR 0 11
95077: PUSH
95078: DOUBLE
95079: LD_VAR 0 7
95083: DEC
95084: ST_TO_ADDR
95085: LD_VAR 0 9
95089: PUSH
95090: FOR_TO
95091: IFFALSE 95210
// for _y = min_y to max_y do
95093: LD_ADDR_VAR 0 12
95097: PUSH
95098: DOUBLE
95099: LD_VAR 0 8
95103: DEC
95104: ST_TO_ADDR
95105: LD_VAR 0 10
95109: PUSH
95110: FOR_TO
95111: IFFALSE 95206
// begin if not ValidHex ( _x , _y ) then
95113: LD_VAR 0 11
95117: PPUSH
95118: LD_VAR 0 12
95122: PPUSH
95123: CALL_OW 488
95127: NOT
95128: IFFALSE 95132
// continue ;
95130: GO 95110
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95132: LD_VAR 0 11
95136: PPUSH
95137: LD_VAR 0 12
95141: PPUSH
95142: CALL_OW 351
95146: IFFALSE 95164
95148: PUSH
95149: LD_VAR 0 11
95153: PPUSH
95154: LD_VAR 0 12
95158: PPUSH
95159: CALL_OW 554
95163: AND
95164: IFFALSE 95204
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95166: LD_ADDR_VAR 0 13
95170: PUSH
95171: LD_VAR 0 13
95175: PPUSH
95176: LD_VAR 0 13
95180: PUSH
95181: LD_INT 1
95183: PLUS
95184: PPUSH
95185: LD_VAR 0 11
95189: PUSH
95190: LD_VAR 0 12
95194: PUSH
95195: EMPTY
95196: LIST
95197: LIST
95198: PPUSH
95199: CALL_OW 2
95203: ST_TO_ADDR
// end ;
95204: GO 95110
95206: POP
95207: POP
95208: GO 95090
95210: POP
95211: POP
// if not list then
95212: LD_VAR 0 13
95216: NOT
95217: IFFALSE 95221
// exit ;
95219: GO 95467
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
95221: LD_ADDR_VAR 0 13
95225: PUSH
95226: LD_VAR 0 1
95230: PPUSH
95231: LD_VAR 0 13
95235: PPUSH
95236: LD_INT 1
95238: PPUSH
95239: LD_INT 1
95241: PPUSH
95242: CALL 16777 0 4
95246: ST_TO_ADDR
// ComStop ( flame ) ;
95247: LD_VAR 0 1
95251: PPUSH
95252: CALL_OW 141
// for i in list do
95256: LD_ADDR_VAR 0 6
95260: PUSH
95261: LD_VAR 0 13
95265: PUSH
95266: FOR_IN
95267: IFFALSE 95298
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
95269: LD_VAR 0 1
95273: PPUSH
95274: LD_VAR 0 6
95278: PUSH
95279: LD_INT 1
95281: ARRAY
95282: PPUSH
95283: LD_VAR 0 6
95287: PUSH
95288: LD_INT 2
95290: ARRAY
95291: PPUSH
95292: CALL_OW 176
95296: GO 95266
95298: POP
95299: POP
// repeat wait ( 0 0$1 ) ;
95300: LD_INT 35
95302: PPUSH
95303: CALL_OW 67
// task := GetTaskList ( flame ) ;
95307: LD_ADDR_VAR 0 14
95311: PUSH
95312: LD_VAR 0 1
95316: PPUSH
95317: CALL_OW 437
95321: ST_TO_ADDR
// if not task then
95322: LD_VAR 0 14
95326: NOT
95327: IFFALSE 95331
// exit ;
95329: GO 95467
// if task [ 1 ] [ 1 ] <> | then
95331: LD_VAR 0 14
95335: PUSH
95336: LD_INT 1
95338: ARRAY
95339: PUSH
95340: LD_INT 1
95342: ARRAY
95343: PUSH
95344: LD_STRING |
95346: NONEQUAL
95347: IFFALSE 95351
// exit ;
95349: GO 95467
// _x := task [ 1 ] [ 2 ] ;
95351: LD_ADDR_VAR 0 11
95355: PUSH
95356: LD_VAR 0 14
95360: PUSH
95361: LD_INT 1
95363: ARRAY
95364: PUSH
95365: LD_INT 2
95367: ARRAY
95368: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
95369: LD_ADDR_VAR 0 12
95373: PUSH
95374: LD_VAR 0 14
95378: PUSH
95379: LD_INT 1
95381: ARRAY
95382: PUSH
95383: LD_INT 3
95385: ARRAY
95386: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
95387: LD_VAR 0 11
95391: PPUSH
95392: LD_VAR 0 12
95396: PPUSH
95397: CALL_OW 351
95401: NOT
95402: IFTRUE 95421
95404: PUSH
95405: LD_VAR 0 11
95409: PPUSH
95410: LD_VAR 0 12
95414: PPUSH
95415: CALL_OW 554
95419: NOT
95420: OR
95421: IFFALSE 95455
// begin task := Delete ( task , 1 ) ;
95423: LD_ADDR_VAR 0 14
95427: PUSH
95428: LD_VAR 0 14
95432: PPUSH
95433: LD_INT 1
95435: PPUSH
95436: CALL_OW 3
95440: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
95441: LD_VAR 0 1
95445: PPUSH
95446: LD_VAR 0 14
95450: PPUSH
95451: CALL_OW 446
// end ; until not HasTask ( flame ) ;
95455: LD_VAR 0 1
95459: PPUSH
95460: CALL_OW 314
95464: NOT
95465: IFFALSE 95300
// end ;
95467: LD_VAR 0 5
95471: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95472: LD_EXP 68
95476: NOT
95477: IFFALSE 95527
95479: GO 95481
95481: DISABLE
// begin initHack := true ;
95482: LD_ADDR_EXP 68
95486: PUSH
95487: LD_INT 1
95489: ST_TO_ADDR
// hackTanks := [ ] ;
95490: LD_ADDR_EXP 69
95494: PUSH
95495: EMPTY
95496: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95497: LD_ADDR_EXP 70
95501: PUSH
95502: EMPTY
95503: ST_TO_ADDR
// hackLimit := 3 ;
95504: LD_ADDR_EXP 71
95508: PUSH
95509: LD_INT 3
95511: ST_TO_ADDR
// hackDist := 12 ;
95512: LD_ADDR_EXP 72
95516: PUSH
95517: LD_INT 12
95519: ST_TO_ADDR
// hackCounter := [ ] ;
95520: LD_ADDR_EXP 73
95524: PUSH
95525: EMPTY
95526: ST_TO_ADDR
// end ;
95527: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95528: LD_EXP 68
95532: IFFALSE 95550
95534: PUSH
95535: LD_INT 34
95537: PUSH
95538: LD_INT 99
95540: PUSH
95541: EMPTY
95542: LIST
95543: LIST
95544: PPUSH
95545: CALL_OW 69
95549: AND
95550: IFFALSE 95803
95552: GO 95554
95554: DISABLE
95555: LD_INT 0
95557: PPUSH
95558: PPUSH
// begin enable ;
95559: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95560: LD_ADDR_VAR 0 1
95564: PUSH
95565: LD_INT 34
95567: PUSH
95568: LD_INT 99
95570: PUSH
95571: EMPTY
95572: LIST
95573: LIST
95574: PPUSH
95575: CALL_OW 69
95579: PUSH
95580: FOR_IN
95581: IFFALSE 95801
// begin if not i in hackTanks then
95583: LD_VAR 0 1
95587: PUSH
95588: LD_EXP 69
95592: IN
95593: NOT
95594: IFFALSE 95677
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95596: LD_ADDR_EXP 69
95600: PUSH
95601: LD_EXP 69
95605: PPUSH
95606: LD_EXP 69
95610: PUSH
95611: LD_INT 1
95613: PLUS
95614: PPUSH
95615: LD_VAR 0 1
95619: PPUSH
95620: CALL_OW 1
95624: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95625: LD_ADDR_EXP 70
95629: PUSH
95630: LD_EXP 70
95634: PPUSH
95635: LD_EXP 70
95639: PUSH
95640: LD_INT 1
95642: PLUS
95643: PPUSH
95644: EMPTY
95645: PPUSH
95646: CALL_OW 1
95650: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95651: LD_ADDR_EXP 73
95655: PUSH
95656: LD_EXP 73
95660: PPUSH
95661: LD_EXP 73
95665: PUSH
95666: LD_INT 1
95668: PLUS
95669: PPUSH
95670: EMPTY
95671: PPUSH
95672: CALL_OW 1
95676: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95677: LD_VAR 0 1
95681: PPUSH
95682: CALL_OW 302
95686: NOT
95687: IFFALSE 95700
// begin HackUnlinkAll ( i ) ;
95689: LD_VAR 0 1
95693: PPUSH
95694: CALL 95806 0 1
// continue ;
95698: GO 95580
// end ; HackCheckCapturedStatus ( i ) ;
95700: LD_VAR 0 1
95704: PPUSH
95705: CALL 96251 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95709: LD_ADDR_VAR 0 2
95713: PUSH
95714: LD_INT 81
95716: PUSH
95717: LD_VAR 0 1
95721: PPUSH
95722: CALL_OW 255
95726: PUSH
95727: EMPTY
95728: LIST
95729: LIST
95730: PUSH
95731: LD_INT 33
95733: PUSH
95734: LD_INT 3
95736: PUSH
95737: EMPTY
95738: LIST
95739: LIST
95740: PUSH
95741: LD_INT 91
95743: PUSH
95744: LD_VAR 0 1
95748: PUSH
95749: LD_EXP 72
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 50
95761: PUSH
95762: EMPTY
95763: LIST
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: PPUSH
95771: CALL_OW 69
95775: ST_TO_ADDR
// if not tmp then
95776: LD_VAR 0 2
95780: NOT
95781: IFFALSE 95785
// continue ;
95783: GO 95580
// HackLink ( i , tmp ) ;
95785: LD_VAR 0 1
95789: PPUSH
95790: LD_VAR 0 2
95794: PPUSH
95795: CALL 95942 0 2
// end ;
95799: GO 95580
95801: POP
95802: POP
// end ;
95803: PPOPN 2
95805: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95806: LD_INT 0
95808: PPUSH
95809: PPUSH
95810: PPUSH
// if not hack in hackTanks then
95811: LD_VAR 0 1
95815: PUSH
95816: LD_EXP 69
95820: IN
95821: NOT
95822: IFFALSE 95826
// exit ;
95824: GO 95937
// index := GetElementIndex ( hackTanks , hack ) ;
95826: LD_ADDR_VAR 0 4
95830: PUSH
95831: LD_EXP 69
95835: PPUSH
95836: LD_VAR 0 1
95840: PPUSH
95841: CALL 16072 0 2
95845: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95846: LD_EXP 70
95850: PUSH
95851: LD_VAR 0 4
95855: ARRAY
95856: IFFALSE 95937
// begin for i in hackTanksCaptured [ index ] do
95858: LD_ADDR_VAR 0 3
95862: PUSH
95863: LD_EXP 70
95867: PUSH
95868: LD_VAR 0 4
95872: ARRAY
95873: PUSH
95874: FOR_IN
95875: IFFALSE 95901
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95877: LD_VAR 0 3
95881: PUSH
95882: LD_INT 1
95884: ARRAY
95885: PPUSH
95886: LD_VAR 0 3
95890: PUSH
95891: LD_INT 2
95893: ARRAY
95894: PPUSH
95895: CALL_OW 235
95899: GO 95874
95901: POP
95902: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95903: LD_ADDR_EXP 70
95907: PUSH
95908: LD_EXP 70
95912: PPUSH
95913: LD_VAR 0 4
95917: PPUSH
95918: EMPTY
95919: PPUSH
95920: CALL_OW 1
95924: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95925: LD_VAR 0 1
95929: PPUSH
95930: LD_INT 0
95932: PPUSH
95933: CALL_OW 505
// end ; end ;
95937: LD_VAR 0 2
95941: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95942: LD_INT 0
95944: PPUSH
95945: PPUSH
95946: PPUSH
// if not hack in hackTanks or not vehicles then
95947: LD_VAR 0 1
95951: PUSH
95952: LD_EXP 69
95956: IN
95957: NOT
95958: IFTRUE 95967
95960: PUSH
95961: LD_VAR 0 2
95965: NOT
95966: OR
95967: IFFALSE 95971
// exit ;
95969: GO 96246
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
95971: LD_ADDR_VAR 0 2
95975: PUSH
95976: LD_VAR 0 1
95980: PPUSH
95981: LD_VAR 0 2
95985: PPUSH
95986: LD_INT 1
95988: PPUSH
95989: LD_INT 1
95991: PPUSH
95992: CALL 16724 0 4
95996: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
95997: LD_ADDR_VAR 0 5
96001: PUSH
96002: LD_EXP 69
96006: PPUSH
96007: LD_VAR 0 1
96011: PPUSH
96012: CALL 16072 0 2
96016: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96017: LD_EXP 70
96021: PUSH
96022: LD_VAR 0 5
96026: ARRAY
96027: PUSH
96028: LD_EXP 71
96032: LESS
96033: IFFALSE 96222
// begin for i := 1 to vehicles do
96035: LD_ADDR_VAR 0 4
96039: PUSH
96040: DOUBLE
96041: LD_INT 1
96043: DEC
96044: ST_TO_ADDR
96045: LD_VAR 0 2
96049: PUSH
96050: FOR_TO
96051: IFFALSE 96220
// begin if hackTanksCaptured [ index ] = hackLimit then
96053: LD_EXP 70
96057: PUSH
96058: LD_VAR 0 5
96062: ARRAY
96063: PUSH
96064: LD_EXP 71
96068: EQUAL
96069: IFFALSE 96073
// break ;
96071: GO 96220
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96073: LD_ADDR_EXP 73
96077: PUSH
96078: LD_EXP 73
96082: PPUSH
96083: LD_VAR 0 5
96087: PPUSH
96088: LD_EXP 73
96092: PUSH
96093: LD_VAR 0 5
96097: ARRAY
96098: PUSH
96099: LD_INT 1
96101: PLUS
96102: PPUSH
96103: CALL_OW 1
96107: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96108: LD_ADDR_EXP 70
96112: PUSH
96113: LD_EXP 70
96117: PPUSH
96118: LD_VAR 0 5
96122: PUSH
96123: LD_EXP 70
96127: PUSH
96128: LD_VAR 0 5
96132: ARRAY
96133: PUSH
96134: LD_INT 1
96136: PLUS
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: PPUSH
96142: LD_VAR 0 2
96146: PUSH
96147: LD_VAR 0 4
96151: ARRAY
96152: PUSH
96153: LD_VAR 0 2
96157: PUSH
96158: LD_VAR 0 4
96162: ARRAY
96163: PPUSH
96164: CALL_OW 255
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PPUSH
96173: CALL 16289 0 3
96177: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96178: LD_VAR 0 2
96182: PUSH
96183: LD_VAR 0 4
96187: ARRAY
96188: PPUSH
96189: LD_VAR 0 1
96193: PPUSH
96194: CALL_OW 255
96198: PPUSH
96199: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96203: LD_VAR 0 2
96207: PUSH
96208: LD_VAR 0 4
96212: ARRAY
96213: PPUSH
96214: CALL_OW 141
// end ;
96218: GO 96050
96220: POP
96221: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96222: LD_VAR 0 1
96226: PPUSH
96227: LD_EXP 70
96231: PUSH
96232: LD_VAR 0 5
96236: ARRAY
96237: PUSH
96238: LD_INT 0
96240: PLUS
96241: PPUSH
96242: CALL_OW 505
// end ;
96246: LD_VAR 0 3
96250: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96251: LD_INT 0
96253: PPUSH
96254: PPUSH
96255: PPUSH
96256: PPUSH
// if not hack in hackTanks then
96257: LD_VAR 0 1
96261: PUSH
96262: LD_EXP 69
96266: IN
96267: NOT
96268: IFFALSE 96272
// exit ;
96270: GO 96516
// index := GetElementIndex ( hackTanks , hack ) ;
96272: LD_ADDR_VAR 0 4
96276: PUSH
96277: LD_EXP 69
96281: PPUSH
96282: LD_VAR 0 1
96286: PPUSH
96287: CALL 16072 0 2
96291: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96292: LD_ADDR_VAR 0 3
96296: PUSH
96297: DOUBLE
96298: LD_EXP 70
96302: PUSH
96303: LD_VAR 0 4
96307: ARRAY
96308: INC
96309: ST_TO_ADDR
96310: LD_INT 1
96312: PUSH
96313: FOR_DOWNTO
96314: IFFALSE 96490
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96316: LD_ADDR_VAR 0 5
96320: PUSH
96321: LD_EXP 70
96325: PUSH
96326: LD_VAR 0 4
96330: ARRAY
96331: PUSH
96332: LD_VAR 0 3
96336: ARRAY
96337: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96338: LD_VAR 0 5
96342: PUSH
96343: LD_INT 1
96345: ARRAY
96346: PPUSH
96347: CALL_OW 302
96351: NOT
96352: IFTRUE 96380
96354: PUSH
96355: LD_VAR 0 5
96359: PUSH
96360: LD_INT 1
96362: ARRAY
96363: PPUSH
96364: CALL_OW 255
96368: PUSH
96369: LD_VAR 0 1
96373: PPUSH
96374: CALL_OW 255
96378: NONEQUAL
96379: OR
96380: IFFALSE 96488
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96382: LD_VAR 0 5
96386: PUSH
96387: LD_INT 1
96389: ARRAY
96390: PPUSH
96391: CALL_OW 305
96395: IFFALSE 96423
96397: PUSH
96398: LD_VAR 0 5
96402: PUSH
96403: LD_INT 1
96405: ARRAY
96406: PPUSH
96407: CALL_OW 255
96411: PUSH
96412: LD_VAR 0 1
96416: PPUSH
96417: CALL_OW 255
96421: EQUAL
96422: AND
96423: IFFALSE 96447
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96425: LD_VAR 0 5
96429: PUSH
96430: LD_INT 1
96432: ARRAY
96433: PPUSH
96434: LD_VAR 0 5
96438: PUSH
96439: LD_INT 2
96441: ARRAY
96442: PPUSH
96443: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96447: LD_ADDR_EXP 70
96451: PUSH
96452: LD_EXP 70
96456: PPUSH
96457: LD_VAR 0 4
96461: PPUSH
96462: LD_EXP 70
96466: PUSH
96467: LD_VAR 0 4
96471: ARRAY
96472: PPUSH
96473: LD_VAR 0 3
96477: PPUSH
96478: CALL_OW 3
96482: PPUSH
96483: CALL_OW 1
96487: ST_TO_ADDR
// end ; end ;
96488: GO 96313
96490: POP
96491: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96492: LD_VAR 0 1
96496: PPUSH
96497: LD_EXP 70
96501: PUSH
96502: LD_VAR 0 4
96506: ARRAY
96507: PUSH
96508: LD_INT 0
96510: PLUS
96511: PPUSH
96512: CALL_OW 505
// end ;
96516: LD_VAR 0 2
96520: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96521: LD_INT 0
96523: PPUSH
96524: PPUSH
96525: PPUSH
96526: PPUSH
// if not hack in hackTanks then
96527: LD_VAR 0 1
96531: PUSH
96532: LD_EXP 69
96536: IN
96537: NOT
96538: IFFALSE 96542
// exit ;
96540: GO 96627
// index := GetElementIndex ( hackTanks , hack ) ;
96542: LD_ADDR_VAR 0 5
96546: PUSH
96547: LD_EXP 69
96551: PPUSH
96552: LD_VAR 0 1
96556: PPUSH
96557: CALL 16072 0 2
96561: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96562: LD_ADDR_VAR 0 4
96566: PUSH
96567: DOUBLE
96568: LD_INT 1
96570: DEC
96571: ST_TO_ADDR
96572: LD_EXP 70
96576: PUSH
96577: LD_VAR 0 5
96581: ARRAY
96582: PUSH
96583: FOR_TO
96584: IFFALSE 96625
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96586: LD_EXP 70
96590: PUSH
96591: LD_VAR 0 5
96595: ARRAY
96596: PUSH
96597: LD_VAR 0 4
96601: ARRAY
96602: PUSH
96603: LD_INT 1
96605: ARRAY
96606: PUSH
96607: LD_VAR 0 2
96611: EQUAL
96612: IFFALSE 96623
// KillUnit ( vehicle ) ;
96614: LD_VAR 0 2
96618: PPUSH
96619: CALL_OW 66
96623: GO 96583
96625: POP
96626: POP
// end ;
96627: LD_VAR 0 3
96631: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
96632: LD_EXP 74
96636: NOT
96637: IFFALSE 96770
96639: GO 96641
96641: DISABLE
96642: LD_INT 0
96644: PPUSH
// begin initMiner := true ;
96645: LD_ADDR_EXP 74
96649: PUSH
96650: LD_INT 1
96652: ST_TO_ADDR
// minersList := [ ] ;
96653: LD_ADDR_EXP 75
96657: PUSH
96658: EMPTY
96659: ST_TO_ADDR
// minerMinesList := [ ] ;
96660: LD_ADDR_EXP 76
96664: PUSH
96665: EMPTY
96666: ST_TO_ADDR
// minesLimitPerVehicle := 10 ;
96667: LD_ADDR_EXP 77
96671: PUSH
96672: LD_INT 10
96674: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96675: LD_ADDR_VAR 0 1
96679: PUSH
96680: LD_INT 34
96682: PUSH
96683: LD_INT 81
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PPUSH
96690: CALL_OW 69
96694: PUSH
96695: FOR_IN
96696: IFFALSE 96768
// begin if not i in minersList then
96698: LD_VAR 0 1
96702: PUSH
96703: LD_EXP 75
96707: IN
96708: NOT
96709: IFFALSE 96766
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96711: LD_ADDR_EXP 75
96715: PUSH
96716: LD_EXP 75
96720: PPUSH
96721: LD_EXP 75
96725: PUSH
96726: LD_INT 1
96728: PLUS
96729: PPUSH
96730: LD_VAR 0 1
96734: PPUSH
96735: CALL_OW 1
96739: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96740: LD_ADDR_EXP 76
96744: PUSH
96745: LD_EXP 76
96749: PPUSH
96750: LD_EXP 76
96754: PUSH
96755: LD_INT 1
96757: PLUS
96758: PPUSH
96759: EMPTY
96760: PPUSH
96761: CALL_OW 1
96765: ST_TO_ADDR
// end end ;
96766: GO 96695
96768: POP
96769: POP
// end ;
96770: PPOPN 1
96772: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
96773: LD_EXP 74
96777: IFFALSE 96808
96779: PUSH
96780: LD_EXP 76
96784: PPUSH
96785: CALL 13371 0 1
96789: IFTRUE 96807
96791: PUSH
96792: LD_INT 34
96794: PUSH
96795: LD_INT 81
96797: PUSH
96798: EMPTY
96799: LIST
96800: LIST
96801: PPUSH
96802: CALL_OW 69
96806: OR
96807: AND
96808: IFFALSE 97328
96810: GO 96812
96812: DISABLE
96813: LD_INT 0
96815: PPUSH
96816: PPUSH
96817: PPUSH
96818: PPUSH
// begin enable ;
96819: ENABLE
// for i := minerMinesList downto 1 do
96820: LD_ADDR_VAR 0 1
96824: PUSH
96825: DOUBLE
96826: LD_EXP 76
96830: INC
96831: ST_TO_ADDR
96832: LD_INT 1
96834: PUSH
96835: FOR_DOWNTO
96836: IFFALSE 97326
// begin side := GetSide ( minersList [ i ] ) ;
96838: LD_ADDR_VAR 0 3
96842: PUSH
96843: LD_EXP 75
96847: PUSH
96848: LD_VAR 0 1
96852: ARRAY
96853: PPUSH
96854: CALL_OW 255
96858: ST_TO_ADDR
// if IsLive ( minersList [ i ] ) and side in [ your_side , 9 ] then
96859: LD_EXP 75
96863: PUSH
96864: LD_VAR 0 1
96868: ARRAY
96869: PPUSH
96870: CALL_OW 300
96874: IFFALSE 96895
96876: PUSH
96877: LD_VAR 0 3
96881: PUSH
96882: LD_OWVAR 2
96886: PUSH
96887: LD_INT 9
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: IN
96894: AND
96895: IFFALSE 96928
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
96897: LD_EXP 75
96901: PUSH
96902: LD_VAR 0 1
96906: ARRAY
96907: PPUSH
96908: LD_EXP 76
96912: PUSH
96913: LD_VAR 0 1
96917: ARRAY
96918: PPUSH
96919: CALL 13371 0 1
96923: PPUSH
96924: CALL_OW 505
// if not minerMinesList [ i ] then
96928: LD_EXP 76
96932: PUSH
96933: LD_VAR 0 1
96937: ARRAY
96938: NOT
96939: IFFALSE 96943
// continue ;
96941: GO 96835
// for j := minerMinesList [ i ] downto 1 do
96943: LD_ADDR_VAR 0 2
96947: PUSH
96948: DOUBLE
96949: LD_EXP 76
96953: PUSH
96954: LD_VAR 0 1
96958: ARRAY
96959: INC
96960: ST_TO_ADDR
96961: LD_INT 1
96963: PUSH
96964: FOR_DOWNTO
96965: IFFALSE 97322
// begin if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
96967: LD_EXP 75
96971: PUSH
96972: LD_VAR 0 1
96976: ARRAY
96977: PPUSH
96978: CALL_OW 301
96982: IFTRUE 97002
96984: PUSH
96985: LD_EXP 75
96989: PUSH
96990: LD_VAR 0 1
96994: ARRAY
96995: PPUSH
96996: CALL_OW 305
97000: NOT
97001: OR
97002: IFFALSE 97093
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97004: LD_EXP 76
97008: PUSH
97009: LD_VAR 0 1
97013: ARRAY
97014: PUSH
97015: LD_VAR 0 2
97019: ARRAY
97020: PUSH
97021: LD_INT 1
97023: ARRAY
97024: PPUSH
97025: LD_EXP 76
97029: PUSH
97030: LD_VAR 0 1
97034: ARRAY
97035: PUSH
97036: LD_VAR 0 2
97040: ARRAY
97041: PUSH
97042: LD_INT 2
97044: ARRAY
97045: PPUSH
97046: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97050: LD_ADDR_EXP 76
97054: PUSH
97055: LD_EXP 76
97059: PPUSH
97060: LD_VAR 0 1
97064: PPUSH
97065: LD_EXP 76
97069: PUSH
97070: LD_VAR 0 1
97074: ARRAY
97075: PPUSH
97076: LD_VAR 0 2
97080: PPUSH
97081: CALL_OW 3
97085: PPUSH
97086: CALL_OW 1
97090: ST_TO_ADDR
// continue ;
97091: GO 96964
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97093: LD_ADDR_VAR 0 4
97097: PUSH
97098: LD_EXP 76
97102: PUSH
97103: LD_VAR 0 1
97107: ARRAY
97108: PUSH
97109: LD_VAR 0 2
97113: ARRAY
97114: PUSH
97115: LD_INT 1
97117: ARRAY
97118: PPUSH
97119: LD_EXP 76
97123: PUSH
97124: LD_VAR 0 1
97128: ARRAY
97129: PUSH
97130: LD_VAR 0 2
97134: ARRAY
97135: PUSH
97136: LD_INT 2
97138: ARRAY
97139: PPUSH
97140: CALL_OW 428
97144: ST_TO_ADDR
// if not tmp then
97145: LD_VAR 0 4
97149: NOT
97150: IFFALSE 97154
// continue ;
97152: GO 96964
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97154: LD_VAR 0 4
97158: PUSH
97159: LD_INT 81
97161: PUSH
97162: LD_VAR 0 3
97166: PUSH
97167: EMPTY
97168: LIST
97169: LIST
97170: PPUSH
97171: CALL_OW 69
97175: IN
97176: IFFALSE 97226
97178: PUSH
97179: LD_EXP 76
97183: PUSH
97184: LD_VAR 0 1
97188: ARRAY
97189: PUSH
97190: LD_VAR 0 2
97194: ARRAY
97195: PUSH
97196: LD_INT 1
97198: ARRAY
97199: PPUSH
97200: LD_EXP 76
97204: PUSH
97205: LD_VAR 0 1
97209: ARRAY
97210: PUSH
97211: LD_VAR 0 2
97215: ARRAY
97216: PUSH
97217: LD_INT 2
97219: ARRAY
97220: PPUSH
97221: CALL_OW 458
97225: AND
97226: IFFALSE 97320
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97228: LD_EXP 76
97232: PUSH
97233: LD_VAR 0 1
97237: ARRAY
97238: PUSH
97239: LD_VAR 0 2
97243: ARRAY
97244: PUSH
97245: LD_INT 1
97247: ARRAY
97248: PPUSH
97249: LD_EXP 76
97253: PUSH
97254: LD_VAR 0 1
97258: ARRAY
97259: PUSH
97260: LD_VAR 0 2
97264: ARRAY
97265: PUSH
97266: LD_INT 2
97268: ARRAY
97269: PPUSH
97270: LD_VAR 0 3
97274: PPUSH
97275: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97279: LD_ADDR_EXP 76
97283: PUSH
97284: LD_EXP 76
97288: PPUSH
97289: LD_VAR 0 1
97293: PPUSH
97294: LD_EXP 76
97298: PUSH
97299: LD_VAR 0 1
97303: ARRAY
97304: PPUSH
97305: LD_VAR 0 2
97309: PPUSH
97310: CALL_OW 3
97314: PPUSH
97315: CALL_OW 1
97319: ST_TO_ADDR
// end ; end ;
97320: GO 96964
97322: POP
97323: POP
// end ;
97324: GO 96835
97326: POP
97327: POP
// end ;
97328: PPOPN 4
97330: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
97331: LD_INT 0
97333: PPUSH
97334: PPUSH
97335: PPUSH
97336: PPUSH
// result := false ;
97337: LD_ADDR_VAR 0 4
97341: PUSH
97342: LD_INT 0
97344: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97345: LD_VAR 0 1
97349: PPUSH
97350: CALL_OW 264
97354: PUSH
97355: LD_INT 81
97357: EQUAL
97358: NOT
97359: IFFALSE 97363
// exit ;
97361: GO 97733
// side := GetSide ( unit ) ;
97363: LD_ADDR_VAR 0 6
97367: PUSH
97368: LD_VAR 0 1
97372: PPUSH
97373: CALL_OW 255
97377: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
97378: LD_ADDR_VAR 0 5
97382: PUSH
97383: LD_EXP 75
97387: PPUSH
97388: LD_VAR 0 1
97392: PPUSH
97393: CALL 16072 0 2
97397: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97398: LD_EXP 76
97402: PUSH
97403: LD_VAR 0 5
97407: ARRAY
97408: PUSH
97409: LD_EXP 77
97413: GREATEREQUAL
97414: IFFALSE 97418
// exit ;
97416: GO 97733
// ComMoveXY ( unit , x , y ) ;
97418: LD_VAR 0 1
97422: PPUSH
97423: LD_VAR 0 2
97427: PPUSH
97428: LD_VAR 0 3
97432: PPUSH
97433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97437: LD_INT 35
97439: PPUSH
97440: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97444: LD_VAR 0 1
97448: PPUSH
97449: LD_VAR 0 2
97453: PPUSH
97454: LD_VAR 0 3
97458: PPUSH
97459: CALL 48128 0 3
97463: NOT
97464: IFFALSE 97477
97466: PUSH
97467: LD_VAR 0 1
97471: PPUSH
97472: CALL_OW 314
97476: AND
97477: IFFALSE 97481
// exit ;
97479: GO 97733
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97481: LD_VAR 0 2
97485: PPUSH
97486: LD_VAR 0 3
97490: PPUSH
97491: CALL_OW 428
97495: PUSH
97496: LD_VAR 0 1
97500: EQUAL
97501: IFFALSE 97515
97503: PUSH
97504: LD_VAR 0 1
97508: PPUSH
97509: CALL_OW 314
97513: NOT
97514: AND
97515: IFFALSE 97437
// if MineAtPos ( x , y ) then
97517: LD_VAR 0 2
97521: PPUSH
97522: LD_VAR 0 3
97526: PPUSH
97527: CALL_OW 458
97531: IFFALSE 97535
// exit ;
97533: GO 97733
// if your_side = side then
97535: LD_OWVAR 2
97539: PUSH
97540: LD_VAR 0 6
97544: EQUAL
97545: IFFALSE 97564
// PlaySoundXY ( x , y , PlantMine ) ;
97547: LD_VAR 0 2
97551: PPUSH
97552: LD_VAR 0 3
97556: PPUSH
97557: LD_STRING PlantMine
97559: PPUSH
97560: CALL_OW 366
// repeat wait ( 1 ) ;
97564: LD_INT 1
97566: PPUSH
97567: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
97571: LD_VAR 0 2
97575: PPUSH
97576: LD_VAR 0 3
97580: PPUSH
97581: LD_VAR 0 6
97585: PPUSH
97586: LD_INT 0
97588: PPUSH
97589: CALL_OW 454
97593: IFFALSE 97564
// if MineAtPos ( x , y ) then
97595: LD_VAR 0 2
97599: PPUSH
97600: LD_VAR 0 3
97604: PPUSH
97605: CALL_OW 458
97609: IFFALSE 97725
// begin for i in minerMinesList [ index ] do
97611: LD_ADDR_VAR 0 7
97615: PUSH
97616: LD_EXP 76
97620: PUSH
97621: LD_VAR 0 5
97625: ARRAY
97626: PUSH
97627: FOR_IN
97628: IFFALSE 97670
// if i [ 1 ] = x and i [ 2 ] = y then
97630: LD_VAR 0 7
97634: PUSH
97635: LD_INT 1
97637: ARRAY
97638: PUSH
97639: LD_VAR 0 2
97643: EQUAL
97644: IFFALSE 97662
97646: PUSH
97647: LD_VAR 0 7
97651: PUSH
97652: LD_INT 2
97654: ARRAY
97655: PUSH
97656: LD_VAR 0 3
97660: EQUAL
97661: AND
97662: IFFALSE 97668
// exit ;
97664: POP
97665: POP
97666: GO 97733
97668: GO 97627
97670: POP
97671: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97672: LD_ADDR_EXP 76
97676: PUSH
97677: LD_EXP 76
97681: PPUSH
97682: LD_VAR 0 5
97686: PUSH
97687: LD_EXP 76
97691: PUSH
97692: LD_VAR 0 5
97696: ARRAY
97697: PUSH
97698: LD_INT 1
97700: PLUS
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PPUSH
97706: LD_VAR 0 2
97710: PUSH
97711: LD_VAR 0 3
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PPUSH
97720: CALL 16289 0 3
97724: ST_TO_ADDR
// end ; result := true ;
97725: LD_ADDR_VAR 0 4
97729: PUSH
97730: LD_INT 1
97732: ST_TO_ADDR
// end ;
97733: LD_VAR 0 4
97737: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97738: LD_INT 0
97740: PPUSH
97741: PPUSH
97742: PPUSH
// if not unit in minersList then
97743: LD_VAR 0 1
97747: PUSH
97748: LD_EXP 75
97752: IN
97753: NOT
97754: IFFALSE 97758
// exit ;
97756: GO 97965
// index := GetElementIndex ( minersList , unit ) ;
97758: LD_ADDR_VAR 0 6
97762: PUSH
97763: LD_EXP 75
97767: PPUSH
97768: LD_VAR 0 1
97772: PPUSH
97773: CALL 16072 0 2
97777: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97778: LD_ADDR_VAR 0 5
97782: PUSH
97783: DOUBLE
97784: LD_EXP 76
97788: PUSH
97789: LD_VAR 0 6
97793: ARRAY
97794: INC
97795: ST_TO_ADDR
97796: LD_INT 1
97798: PUSH
97799: FOR_DOWNTO
97800: IFFALSE 97963
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97802: LD_EXP 76
97806: PUSH
97807: LD_VAR 0 6
97811: ARRAY
97812: PUSH
97813: LD_VAR 0 5
97817: ARRAY
97818: PUSH
97819: LD_INT 1
97821: ARRAY
97822: PPUSH
97823: LD_EXP 76
97827: PUSH
97828: LD_VAR 0 6
97832: ARRAY
97833: PUSH
97834: LD_VAR 0 5
97838: ARRAY
97839: PUSH
97840: LD_INT 2
97842: ARRAY
97843: PPUSH
97844: LD_VAR 0 2
97848: PPUSH
97849: LD_VAR 0 3
97853: PPUSH
97854: CALL_OW 298
97858: PUSH
97859: LD_INT 6
97861: LESS
97862: IFFALSE 97961
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97864: LD_EXP 76
97868: PUSH
97869: LD_VAR 0 6
97873: ARRAY
97874: PUSH
97875: LD_VAR 0 5
97879: ARRAY
97880: PUSH
97881: LD_INT 1
97883: ARRAY
97884: PPUSH
97885: LD_EXP 76
97889: PUSH
97890: LD_VAR 0 6
97894: ARRAY
97895: PUSH
97896: LD_VAR 0 5
97900: ARRAY
97901: PUSH
97902: LD_INT 2
97904: ARRAY
97905: PPUSH
97906: LD_VAR 0 1
97910: PPUSH
97911: CALL_OW 255
97915: PPUSH
97916: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97920: LD_ADDR_EXP 76
97924: PUSH
97925: LD_EXP 76
97929: PPUSH
97930: LD_VAR 0 6
97934: PPUSH
97935: LD_EXP 76
97939: PUSH
97940: LD_VAR 0 6
97944: ARRAY
97945: PPUSH
97946: LD_VAR 0 5
97950: PPUSH
97951: CALL_OW 3
97955: PPUSH
97956: CALL_OW 1
97960: ST_TO_ADDR
// end ; end ;
97961: GO 97799
97963: POP
97964: POP
// end ;
97965: LD_VAR 0 4
97969: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97970: LD_INT 0
97972: PPUSH
97973: PPUSH
97974: PPUSH
97975: PPUSH
97976: PPUSH
97977: PPUSH
97978: PPUSH
97979: PPUSH
97980: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97981: LD_VAR 0 1
97985: PPUSH
97986: CALL_OW 264
97990: PUSH
97991: LD_INT 81
97993: EQUAL
97994: NOT
97995: IFTRUE 98010
97997: PUSH
97998: LD_VAR 0 1
98002: PUSH
98003: LD_EXP 75
98007: IN
98008: NOT
98009: OR
98010: IFFALSE 98014
// exit ;
98012: GO 98340
// index := GetElementIndex ( minersList , unit ) ;
98014: LD_ADDR_VAR 0 6
98018: PUSH
98019: LD_EXP 75
98023: PPUSH
98024: LD_VAR 0 1
98028: PPUSH
98029: CALL 16072 0 2
98033: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98034: LD_ADDR_VAR 0 8
98038: PUSH
98039: LD_EXP 77
98043: PUSH
98044: LD_EXP 76
98048: PUSH
98049: LD_VAR 0 6
98053: ARRAY
98054: MINUS
98055: ST_TO_ADDR
// if not minesFreeAmount then
98056: LD_VAR 0 8
98060: NOT
98061: IFFALSE 98065
// exit ;
98063: GO 98340
// tmp := [ ] ;
98065: LD_ADDR_VAR 0 7
98069: PUSH
98070: EMPTY
98071: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98072: LD_ADDR_VAR 0 5
98076: PUSH
98077: DOUBLE
98078: LD_INT 1
98080: DEC
98081: ST_TO_ADDR
98082: LD_VAR 0 8
98086: PUSH
98087: FOR_TO
98088: IFFALSE 98287
// begin _d := rand ( 0 , 5 ) ;
98090: LD_ADDR_VAR 0 11
98094: PUSH
98095: LD_INT 0
98097: PPUSH
98098: LD_INT 5
98100: PPUSH
98101: CALL_OW 12
98105: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98106: LD_ADDR_VAR 0 12
98110: PUSH
98111: LD_INT 2
98113: PPUSH
98114: LD_INT 6
98116: PPUSH
98117: CALL_OW 12
98121: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98122: LD_ADDR_VAR 0 9
98126: PUSH
98127: LD_VAR 0 2
98131: PPUSH
98132: LD_VAR 0 11
98136: PPUSH
98137: LD_VAR 0 12
98141: PPUSH
98142: CALL_OW 272
98146: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98147: LD_ADDR_VAR 0 10
98151: PUSH
98152: LD_VAR 0 3
98156: PPUSH
98157: LD_VAR 0 11
98161: PPUSH
98162: LD_VAR 0 12
98166: PPUSH
98167: CALL_OW 273
98171: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98172: LD_VAR 0 9
98176: PPUSH
98177: LD_VAR 0 10
98181: PPUSH
98182: CALL_OW 488
98186: IFFALSE 98210
98188: PUSH
98189: LD_VAR 0 9
98193: PUSH
98194: LD_VAR 0 10
98198: PUSH
98199: EMPTY
98200: LIST
98201: LIST
98202: PUSH
98203: LD_VAR 0 7
98207: IN
98208: NOT
98209: AND
98210: IFFALSE 98229
98212: PUSH
98213: LD_VAR 0 9
98217: PPUSH
98218: LD_VAR 0 10
98222: PPUSH
98223: CALL_OW 458
98227: NOT
98228: AND
98229: IFFALSE 98271
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98231: LD_ADDR_VAR 0 7
98235: PUSH
98236: LD_VAR 0 7
98240: PPUSH
98241: LD_VAR 0 7
98245: PUSH
98246: LD_INT 1
98248: PLUS
98249: PPUSH
98250: LD_VAR 0 9
98254: PUSH
98255: LD_VAR 0 10
98259: PUSH
98260: EMPTY
98261: LIST
98262: LIST
98263: PPUSH
98264: CALL_OW 1
98268: ST_TO_ADDR
98269: GO 98285
// i := i - 1 ;
98271: LD_ADDR_VAR 0 5
98275: PUSH
98276: LD_VAR 0 5
98280: PUSH
98281: LD_INT 1
98283: MINUS
98284: ST_TO_ADDR
// end ;
98285: GO 98087
98287: POP
98288: POP
// for i in tmp do
98289: LD_ADDR_VAR 0 5
98293: PUSH
98294: LD_VAR 0 7
98298: PUSH
98299: FOR_IN
98300: IFFALSE 98338
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98302: LD_VAR 0 1
98306: PPUSH
98307: LD_VAR 0 5
98311: PUSH
98312: LD_INT 1
98314: ARRAY
98315: PPUSH
98316: LD_VAR 0 5
98320: PUSH
98321: LD_INT 2
98323: ARRAY
98324: PPUSH
98325: CALL 97331 0 3
98329: NOT
98330: IFFALSE 98336
// exit ;
98332: POP
98333: POP
98334: GO 98340
98336: GO 98299
98338: POP
98339: POP
// end ;
98340: LD_VAR 0 4
98344: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
98345: LD_INT 0
98347: PPUSH
98348: PPUSH
98349: PPUSH
98350: PPUSH
98351: PPUSH
98352: PPUSH
98353: PPUSH
98354: PPUSH
98355: PPUSH
// if GetClass ( unit ) <> class_sniper then
98356: LD_VAR 0 1
98360: PPUSH
98361: CALL_OW 257
98365: PUSH
98366: LD_INT 5
98368: NONEQUAL
98369: IFFALSE 98373
// exit ;
98371: GO 98843
// dist := 8 ;
98373: LD_ADDR_VAR 0 5
98377: PUSH
98378: LD_INT 8
98380: ST_TO_ADDR
// viewRange := 12 ;
98381: LD_ADDR_VAR 0 8
98385: PUSH
98386: LD_INT 12
98388: ST_TO_ADDR
// side := GetSide ( unit ) ;
98389: LD_ADDR_VAR 0 6
98393: PUSH
98394: LD_VAR 0 1
98398: PPUSH
98399: CALL_OW 255
98403: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98404: LD_INT 61
98406: PPUSH
98407: LD_VAR 0 6
98411: PPUSH
98412: CALL_OW 321
98416: PUSH
98417: LD_INT 2
98419: EQUAL
98420: IFFALSE 98430
// viewRange := 16 ;
98422: LD_ADDR_VAR 0 8
98426: PUSH
98427: LD_INT 16
98429: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98430: LD_VAR 0 1
98434: PPUSH
98435: LD_VAR 0 2
98439: PPUSH
98440: LD_VAR 0 3
98444: PPUSH
98445: CALL_OW 297
98449: PUSH
98450: LD_VAR 0 5
98454: GREATER
98455: IFFALSE 98534
// begin ComMoveXY ( unit , x , y ) ;
98457: LD_VAR 0 1
98461: PPUSH
98462: LD_VAR 0 2
98466: PPUSH
98467: LD_VAR 0 3
98471: PPUSH
98472: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98476: LD_INT 35
98478: PPUSH
98479: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98483: LD_VAR 0 1
98487: PPUSH
98488: LD_VAR 0 2
98492: PPUSH
98493: LD_VAR 0 3
98497: PPUSH
98498: CALL 48128 0 3
98502: NOT
98503: IFFALSE 98507
// exit ;
98505: GO 98843
// until GetDistUnitXY ( unit , x , y ) < dist ;
98507: LD_VAR 0 1
98511: PPUSH
98512: LD_VAR 0 2
98516: PPUSH
98517: LD_VAR 0 3
98521: PPUSH
98522: CALL_OW 297
98526: PUSH
98527: LD_VAR 0 5
98531: LESS
98532: IFFALSE 98476
// end ; ComTurnXY ( unit , x , y ) ;
98534: LD_VAR 0 1
98538: PPUSH
98539: LD_VAR 0 2
98543: PPUSH
98544: LD_VAR 0 3
98548: PPUSH
98549: CALL_OW 118
// repeat if Multiplayer then
98553: LD_OWVAR 4
98557: IFFALSE 98568
// wait ( 35 ) else
98559: LD_INT 35
98561: PPUSH
98562: CALL_OW 67
98566: GO 98575
// wait ( 5 ) ;
98568: LD_INT 5
98570: PPUSH
98571: CALL_OW 67
// _d := GetDir ( unit ) ;
98575: LD_ADDR_VAR 0 11
98579: PUSH
98580: LD_VAR 0 1
98584: PPUSH
98585: CALL_OW 254
98589: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
98590: LD_ADDR_VAR 0 7
98594: PUSH
98595: LD_VAR 0 1
98599: PPUSH
98600: CALL_OW 250
98604: PPUSH
98605: LD_VAR 0 1
98609: PPUSH
98610: CALL_OW 251
98614: PPUSH
98615: LD_VAR 0 2
98619: PPUSH
98620: LD_VAR 0 3
98624: PPUSH
98625: CALL 50764 0 4
98629: ST_TO_ADDR
// until dir = _d ;
98630: LD_VAR 0 7
98634: PUSH
98635: LD_VAR 0 11
98639: EQUAL
98640: IFFALSE 98553
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
98642: LD_ADDR_VAR 0 9
98646: PUSH
98647: LD_VAR 0 1
98651: PPUSH
98652: CALL_OW 250
98656: PPUSH
98657: LD_VAR 0 7
98661: PPUSH
98662: LD_VAR 0 5
98666: PPUSH
98667: CALL_OW 272
98671: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
98672: LD_ADDR_VAR 0 10
98676: PUSH
98677: LD_VAR 0 1
98681: PPUSH
98682: CALL_OW 251
98686: PPUSH
98687: LD_VAR 0 7
98691: PPUSH
98692: LD_VAR 0 5
98696: PPUSH
98697: CALL_OW 273
98701: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98702: LD_VAR 0 9
98706: PPUSH
98707: LD_VAR 0 10
98711: PPUSH
98712: CALL_OW 488
98716: NOT
98717: IFFALSE 98721
// exit ;
98719: GO 98843
// ComAnimCustom ( unit , 1 ) ;
98721: LD_VAR 0 1
98725: PPUSH
98726: LD_INT 1
98728: PPUSH
98729: CALL_OW 592
// p := 0 ;
98733: LD_ADDR_VAR 0 12
98737: PUSH
98738: LD_INT 0
98740: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98741: LD_VAR 0 9
98745: PPUSH
98746: LD_VAR 0 10
98750: PPUSH
98751: LD_VAR 0 6
98755: PPUSH
98756: LD_VAR 0 8
98760: PPUSH
98761: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
98765: LD_INT 35
98767: PPUSH
98768: CALL_OW 67
// p := Inc ( p ) ;
98772: LD_ADDR_VAR 0 12
98776: PUSH
98777: LD_VAR 0 12
98781: PPUSH
98782: CALL 50720 0 1
98786: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
98787: LD_VAR 0 12
98791: PUSH
98792: LD_INT 3
98794: EQUAL
98795: IFTRUE 98809
98797: PUSH
98798: LD_VAR 0 1
98802: PPUSH
98803: CALL_OW 302
98807: NOT
98808: OR
98809: IFTRUE 98822
98811: PUSH
98812: LD_VAR 0 1
98816: PPUSH
98817: CALL_OW 301
98821: OR
98822: IFFALSE 98765
// RemoveSeeing ( _x , _y , side ) ;
98824: LD_VAR 0 9
98828: PPUSH
98829: LD_VAR 0 10
98833: PPUSH
98834: LD_VAR 0 6
98838: PPUSH
98839: CALL_OW 331
// end ;
98843: LD_VAR 0 4
98847: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
98848: LD_INT 0
98850: PPUSH
98851: PPUSH
98852: PPUSH
98853: PPUSH
98854: PPUSH
98855: PPUSH
98856: PPUSH
98857: PPUSH
98858: PPUSH
98859: PPUSH
98860: PPUSH
// if not unit then
98861: LD_VAR 0 1
98865: NOT
98866: IFFALSE 98870
// exit ;
98868: GO 99141
// side := GetSide ( unit ) ;
98870: LD_ADDR_VAR 0 3
98874: PUSH
98875: LD_VAR 0 1
98879: PPUSH
98880: CALL_OW 255
98884: ST_TO_ADDR
// x := GetX ( unit ) ;
98885: LD_ADDR_VAR 0 5
98889: PUSH
98890: LD_VAR 0 1
98894: PPUSH
98895: CALL_OW 250
98899: ST_TO_ADDR
// y := GetY ( unit ) ;
98900: LD_ADDR_VAR 0 6
98904: PUSH
98905: LD_VAR 0 1
98909: PPUSH
98910: CALL_OW 251
98914: ST_TO_ADDR
// r := 8 ;
98915: LD_ADDR_VAR 0 4
98919: PUSH
98920: LD_INT 8
98922: ST_TO_ADDR
// if x - r < 0 then
98923: LD_VAR 0 5
98927: PUSH
98928: LD_VAR 0 4
98932: MINUS
98933: PUSH
98934: LD_INT 0
98936: LESS
98937: IFFALSE 98949
// min_x := 0 else
98939: LD_ADDR_VAR 0 7
98943: PUSH
98944: LD_INT 0
98946: ST_TO_ADDR
98947: GO 98965
// min_x := x - r ;
98949: LD_ADDR_VAR 0 7
98953: PUSH
98954: LD_VAR 0 5
98958: PUSH
98959: LD_VAR 0 4
98963: MINUS
98964: ST_TO_ADDR
// if y - r < 0 then
98965: LD_VAR 0 6
98969: PUSH
98970: LD_VAR 0 4
98974: MINUS
98975: PUSH
98976: LD_INT 0
98978: LESS
98979: IFFALSE 98991
// min_y := 0 else
98981: LD_ADDR_VAR 0 8
98985: PUSH
98986: LD_INT 0
98988: ST_TO_ADDR
98989: GO 99007
// min_y := y - r ;
98991: LD_ADDR_VAR 0 8
98995: PUSH
98996: LD_VAR 0 6
99000: PUSH
99001: LD_VAR 0 4
99005: MINUS
99006: ST_TO_ADDR
// max_x := x + r ;
99007: LD_ADDR_VAR 0 9
99011: PUSH
99012: LD_VAR 0 5
99016: PUSH
99017: LD_VAR 0 4
99021: PLUS
99022: ST_TO_ADDR
// max_y := y + r ;
99023: LD_ADDR_VAR 0 10
99027: PUSH
99028: LD_VAR 0 6
99032: PUSH
99033: LD_VAR 0 4
99037: PLUS
99038: ST_TO_ADDR
// for _x = min_x to max_x do
99039: LD_ADDR_VAR 0 11
99043: PUSH
99044: DOUBLE
99045: LD_VAR 0 7
99049: DEC
99050: ST_TO_ADDR
99051: LD_VAR 0 9
99055: PUSH
99056: FOR_TO
99057: IFFALSE 99139
// for _y = min_y to max_y do
99059: LD_ADDR_VAR 0 12
99063: PUSH
99064: DOUBLE
99065: LD_VAR 0 8
99069: DEC
99070: ST_TO_ADDR
99071: LD_VAR 0 10
99075: PUSH
99076: FOR_TO
99077: IFFALSE 99135
// begin if not ValidHex ( _x , _y ) then
99079: LD_VAR 0 11
99083: PPUSH
99084: LD_VAR 0 12
99088: PPUSH
99089: CALL_OW 488
99093: NOT
99094: IFFALSE 99098
// continue ;
99096: GO 99076
// if MineAtPos ( _x , _y ) then
99098: LD_VAR 0 11
99102: PPUSH
99103: LD_VAR 0 12
99107: PPUSH
99108: CALL_OW 458
99112: IFFALSE 99133
// ViewMineAtPos ( _x , _y , side ) ;
99114: LD_VAR 0 11
99118: PPUSH
99119: LD_VAR 0 12
99123: PPUSH
99124: LD_VAR 0 3
99128: PPUSH
99129: CALL_OW 457
// end ;
99133: GO 99076
99135: POP
99136: POP
99137: GO 99056
99139: POP
99140: POP
// end ;
99141: LD_VAR 0 2
99145: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer , side ; begin
99146: LD_INT 0
99148: PPUSH
99149: PPUSH
99150: PPUSH
99151: PPUSH
99152: PPUSH
99153: PPUSH
99154: PPUSH
// if not units then
99155: LD_VAR 0 1
99159: NOT
99160: IFFALSE 99164
// exit ;
99162: GO 99628
// scaners := [ ] ;
99164: LD_ADDR_VAR 0 6
99168: PUSH
99169: EMPTY
99170: ST_TO_ADDR
// for i in units do
99171: LD_ADDR_VAR 0 3
99175: PUSH
99176: LD_VAR 0 1
99180: PUSH
99181: FOR_IN
99182: IFFALSE 99339
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
99184: LD_VAR 0 3
99188: PPUSH
99189: CALL_OW 264
99193: PUSH
99194: LD_INT 11
99196: NONEQUAL
99197: IFTRUE 99211
99199: PUSH
99200: LD_VAR 0 3
99204: PPUSH
99205: CALL_OW 302
99209: NOT
99210: OR
99211: IFTRUE 99228
99213: PUSH
99214: LD_VAR 0 3
99218: PPUSH
99219: CALL_OW 110
99223: PUSH
99224: LD_INT 502
99226: EQUAL
99227: OR
99228: IFFALSE 99232
// continue ;
99230: GO 99181
// ComStop ( i ) ;
99232: LD_VAR 0 3
99236: PPUSH
99237: CALL_OW 141
// x := GetX ( i ) ;
99241: LD_ADDR_VAR 0 4
99245: PUSH
99246: LD_VAR 0 3
99250: PPUSH
99251: CALL_OW 250
99255: ST_TO_ADDR
// y := GetY ( i ) ;
99256: LD_ADDR_VAR 0 5
99260: PUSH
99261: LD_VAR 0 3
99265: PPUSH
99266: CALL_OW 251
99270: ST_TO_ADDR
// if GetSide ( i ) = your_side then
99271: LD_VAR 0 3
99275: PPUSH
99276: CALL_OW 255
99280: PUSH
99281: LD_OWVAR 2
99285: EQUAL
99286: IFFALSE 99305
// PlaySoundXY ( x , y , mineDetector ) ;
99288: LD_VAR 0 4
99292: PPUSH
99293: LD_VAR 0 5
99297: PPUSH
99298: LD_STRING mineDetector
99300: PPUSH
99301: CALL_OW 366
// scaners := Join ( scaners , i ) ;
99305: LD_ADDR_VAR 0 6
99309: PUSH
99310: LD_VAR 0 6
99314: PPUSH
99315: LD_VAR 0 3
99319: PPUSH
99320: CALL 49347 0 2
99324: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
99325: LD_VAR 0 3
99329: PPUSH
99330: LD_INT 502
99332: PPUSH
99333: CALL_OW 109
// end ;
99337: GO 99181
99339: POP
99340: POP
// if not scaners then
99341: LD_VAR 0 6
99345: NOT
99346: IFFALSE 99350
// exit ;
99348: GO 99628
// wait ( 3 ) ;
99350: LD_INT 3
99352: PPUSH
99353: CALL_OW 67
// timer := 6 ;
99357: LD_ADDR_VAR 0 7
99361: PUSH
99362: LD_INT 6
99364: ST_TO_ADDR
// repeat for i in scaners do
99365: LD_ADDR_VAR 0 3
99369: PUSH
99370: LD_VAR 0 6
99374: PUSH
99375: FOR_IN
99376: IFFALSE 99526
// begin side := GetSide ( i ) ;
99378: LD_ADDR_VAR 0 8
99382: PUSH
99383: LD_VAR 0 3
99387: PPUSH
99388: CALL_OW 255
99392: ST_TO_ADDR
// if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
99393: LD_VAR 0 3
99397: PPUSH
99398: CALL_OW 302
99402: NOT
99403: IFTRUE 99416
99405: PUSH
99406: LD_VAR 0 3
99410: PPUSH
99411: CALL_OW 314
99415: OR
99416: IFTRUE 99447
99418: PUSH
99419: LD_VAR 0 3
99423: PPUSH
99424: CALL_OW 263
99428: PUSH
99429: LD_INT 1
99431: EQUAL
99432: IFFALSE 99446
99434: PUSH
99435: LD_VAR 0 3
99439: PPUSH
99440: CALL_OW 311
99444: NOT
99445: AND
99446: OR
99447: IFFALSE 99491
// begin SetUnitDisplayNumber ( i , 0 ) ;
99449: LD_VAR 0 3
99453: PPUSH
99454: LD_INT 0
99456: PPUSH
99457: CALL_OW 505
// SetTag ( i , 0 ) ;
99461: LD_VAR 0 3
99465: PPUSH
99466: LD_INT 0
99468: PPUSH
99469: CALL_OW 109
// scaners := scaners diff i ;
99473: LD_ADDR_VAR 0 6
99477: PUSH
99478: LD_VAR 0 6
99482: PUSH
99483: LD_VAR 0 3
99487: DIFF
99488: ST_TO_ADDR
// continue ;
99489: GO 99375
// end ; if side in [ your_side , 9 ] then
99491: LD_VAR 0 8
99495: PUSH
99496: LD_OWVAR 2
99500: PUSH
99501: LD_INT 9
99503: PUSH
99504: EMPTY
99505: LIST
99506: LIST
99507: IN
99508: IFFALSE 99524
// SetUnitDisplayNumber ( i , timer ) ;
99510: LD_VAR 0 3
99514: PPUSH
99515: LD_VAR 0 7
99519: PPUSH
99520: CALL_OW 505
// end ;
99524: GO 99375
99526: POP
99527: POP
// if not scaners then
99528: LD_VAR 0 6
99532: NOT
99533: IFFALSE 99537
// exit ;
99535: GO 99628
// timer := Dec ( timer ) ;
99537: LD_ADDR_VAR 0 7
99541: PUSH
99542: LD_VAR 0 7
99546: PPUSH
99547: CALL 50742 0 1
99551: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99552: LD_INT 35
99554: PPUSH
99555: CALL_OW 67
// until timer = 0 ;
99559: LD_VAR 0 7
99563: PUSH
99564: LD_INT 0
99566: EQUAL
99567: IFFALSE 99365
// if not scaners then
99569: LD_VAR 0 6
99573: NOT
99574: IFFALSE 99578
// exit ;
99576: GO 99628
// for i in scaners do
99578: LD_ADDR_VAR 0 3
99582: PUSH
99583: LD_VAR 0 6
99587: PUSH
99588: FOR_IN
99589: IFFALSE 99626
// begin SetUnitDisplayNumber ( i , 0 ) ;
99591: LD_VAR 0 3
99595: PPUSH
99596: LD_INT 0
99598: PPUSH
99599: CALL_OW 505
// SetTag ( i , 0 ) ;
99603: LD_VAR 0 3
99607: PPUSH
99608: LD_INT 0
99610: PPUSH
99611: CALL_OW 109
// RevealDetectorMine ( i ) ;
99615: LD_VAR 0 3
99619: PPUSH
99620: CALL 98848 0 1
// end ;
99624: GO 99588
99626: POP
99627: POP
// end ;
99628: LD_VAR 0 2
99632: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
99633: LD_INT 0
99635: PPUSH
// if p1 = mine_detector_mode then
99636: LD_VAR 0 2
99640: PUSH
99641: LD_INT 103
99643: EQUAL
99644: IFFALSE 99655
// DetectMine ( units ) ;
99646: LD_VAR 0 1
99650: PPUSH
99651: CALL 99146 0 1
// end ; end_of_file end_of_file
99655: LD_VAR 0 7
99659: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
99660: LD_VAR 0 1
99664: PUSH
99665: LD_INT 200
99667: DOUBLE
99668: GREATEREQUAL
99669: IFFALSE 99677
99671: LD_INT 299
99673: DOUBLE
99674: LESSEQUAL
99675: IFTRUE 99679
99677: GO 99711
99679: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
99680: LD_VAR 0 1
99684: PPUSH
99685: LD_VAR 0 2
99689: PPUSH
99690: LD_VAR 0 3
99694: PPUSH
99695: LD_VAR 0 4
99699: PPUSH
99700: LD_VAR 0 5
99704: PPUSH
99705: CALL 93936 0 5
99709: GO 99788
99711: LD_INT 300
99713: DOUBLE
99714: GREATEREQUAL
99715: IFFALSE 99723
99717: LD_INT 399
99719: DOUBLE
99720: LESSEQUAL
99721: IFTRUE 99725
99723: GO 99787
99725: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
99726: LD_VAR 0 1
99730: PPUSH
99731: LD_VAR 0 2
99735: PPUSH
99736: LD_VAR 0 3
99740: PPUSH
99741: LD_VAR 0 4
99745: PPUSH
99746: LD_VAR 0 5
99750: PPUSH
99751: LD_VAR 0 6
99755: PPUSH
99756: LD_VAR 0 7
99760: PPUSH
99761: LD_VAR 0 8
99765: PPUSH
99766: LD_VAR 0 9
99770: PPUSH
99771: LD_VAR 0 10
99775: PPUSH
99776: LD_VAR 0 11
99780: PPUSH
99781: CALL 112462 0 11
99785: GO 99788
99787: POP
// end ;
99788: PPOPN 11
99790: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
99791: LD_VAR 0 1
99795: PPUSH
99796: LD_VAR 0 2
99800: PPUSH
99801: LD_VAR 0 3
99805: PPUSH
99806: LD_VAR 0 4
99810: PPUSH
99811: LD_VAR 0 5
99815: PPUSH
99816: CALL 93236 0 5
// end ; end_of_file
99820: PPOPN 5
99822: END
// export globalGameSaveCounter ; every 0 0$1 do
99823: GO 99825
99825: DISABLE
// begin enable ;
99826: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
99827: LD_STRING updateTimer(
99829: PUSH
99830: LD_OWVAR 1
99834: STR
99835: PUSH
99836: LD_STRING );
99838: STR
99839: PPUSH
99840: CALL_OW 559
// end ;
99844: END
// every 0 0$1 do
99845: GO 99847
99847: DISABLE
// begin globalGameSaveCounter := 0 ;
99848: LD_ADDR_EXP 78
99852: PUSH
99853: LD_INT 0
99855: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
99856: LD_STRING setGameSaveCounter(0)
99858: PPUSH
99859: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
99863: LD_STRING initStreamRollete();
99865: PPUSH
99866: CALL_OW 559
// InitStreamMode ;
99870: CALL 101222 0 0
// DefineStreamItems ( false ) ;
99874: LD_INT 0
99876: PPUSH
99877: CALL 101686 0 1
// end ;
99881: END
// export function SOS_MapStart ( ) ; begin
99882: LD_INT 0
99884: PPUSH
// if streamModeActive then
99885: LD_EXP 79
99889: IFFALSE 99898
// DefineStreamItems ( true ) ;
99891: LD_INT 1
99893: PPUSH
99894: CALL 101686 0 1
// ToLua ( LFC_UNITS_CUSTOM_ICON = {}; ) ;
99898: LD_STRING LFC_UNITS_CUSTOM_ICON = {};
99900: PPUSH
99901: CALL_OW 559
// UpdateLuaVariables ( ) ;
99905: CALL 99922 0 0
// UpdateFactoryWaypoints ( ) ;
99909: CALL 114808 0 0
// UpdateWarehouseGatheringPoints ( ) ;
99913: CALL 115060 0 0
// end ;
99917: LD_VAR 0 1
99921: RET
// function UpdateLuaVariables ( ) ; begin
99922: LD_INT 0
99924: PPUSH
// if globalGameSaveCounter then
99925: LD_EXP 78
99929: IFFALSE 99963
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
99931: LD_ADDR_EXP 78
99935: PUSH
99936: LD_EXP 78
99940: PPUSH
99941: CALL 50720 0 1
99945: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
99946: LD_STRING setGameSaveCounter(
99948: PUSH
99949: LD_EXP 78
99953: STR
99954: PUSH
99955: LD_STRING )
99957: STR
99958: PPUSH
99959: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
99963: LD_STRING setGameDifficulty(
99965: PUSH
99966: LD_OWVAR 67
99970: STR
99971: PUSH
99972: LD_STRING )
99974: STR
99975: PPUSH
99976: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
99980: LD_STRING displayDifficulty(
99982: PUSH
99983: LD_OWVAR 67
99987: STR
99988: PUSH
99989: LD_STRING )
99991: STR
99992: PPUSH
99993: CALL_OW 559
// end ;
99997: LD_VAR 0 1
100001: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100002: LD_INT 0
100004: PPUSH
// if p2 = stream_mode then
100005: LD_VAR 0 2
100009: PUSH
100010: LD_INT 100
100012: EQUAL
100013: IFFALSE 101016
// begin if not StreamModeActive then
100015: LD_EXP 79
100019: NOT
100020: IFFALSE 100030
// StreamModeActive := true ;
100022: LD_ADDR_EXP 79
100026: PUSH
100027: LD_INT 1
100029: ST_TO_ADDR
// if p3 = 0 then
100030: LD_VAR 0 3
100034: PUSH
100035: LD_INT 0
100037: EQUAL
100038: IFFALSE 100044
// InitStreamMode ;
100040: CALL 101222 0 0
// if p3 = 1 then
100044: LD_VAR 0 3
100048: PUSH
100049: LD_INT 1
100051: EQUAL
100052: IFFALSE 100062
// sRocket := true ;
100054: LD_ADDR_EXP 84
100058: PUSH
100059: LD_INT 1
100061: ST_TO_ADDR
// if p3 = 2 then
100062: LD_VAR 0 3
100066: PUSH
100067: LD_INT 2
100069: EQUAL
100070: IFFALSE 100080
// sSpeed := true ;
100072: LD_ADDR_EXP 83
100076: PUSH
100077: LD_INT 1
100079: ST_TO_ADDR
// if p3 = 3 then
100080: LD_VAR 0 3
100084: PUSH
100085: LD_INT 3
100087: EQUAL
100088: IFFALSE 100098
// sEngine := true ;
100090: LD_ADDR_EXP 85
100094: PUSH
100095: LD_INT 1
100097: ST_TO_ADDR
// if p3 = 4 then
100098: LD_VAR 0 3
100102: PUSH
100103: LD_INT 4
100105: EQUAL
100106: IFFALSE 100116
// sSpec := true ;
100108: LD_ADDR_EXP 82
100112: PUSH
100113: LD_INT 1
100115: ST_TO_ADDR
// if p3 = 5 then
100116: LD_VAR 0 3
100120: PUSH
100121: LD_INT 5
100123: EQUAL
100124: IFFALSE 100134
// sLevel := true ;
100126: LD_ADDR_EXP 86
100130: PUSH
100131: LD_INT 1
100133: ST_TO_ADDR
// if p3 = 6 then
100134: LD_VAR 0 3
100138: PUSH
100139: LD_INT 6
100141: EQUAL
100142: IFFALSE 100152
// sArmoury := true ;
100144: LD_ADDR_EXP 87
100148: PUSH
100149: LD_INT 1
100151: ST_TO_ADDR
// if p3 = 7 then
100152: LD_VAR 0 3
100156: PUSH
100157: LD_INT 7
100159: EQUAL
100160: IFFALSE 100170
// sRadar := true ;
100162: LD_ADDR_EXP 88
100166: PUSH
100167: LD_INT 1
100169: ST_TO_ADDR
// if p3 = 8 then
100170: LD_VAR 0 3
100174: PUSH
100175: LD_INT 8
100177: EQUAL
100178: IFFALSE 100188
// sBunker := true ;
100180: LD_ADDR_EXP 89
100184: PUSH
100185: LD_INT 1
100187: ST_TO_ADDR
// if p3 = 9 then
100188: LD_VAR 0 3
100192: PUSH
100193: LD_INT 9
100195: EQUAL
100196: IFFALSE 100206
// sHack := true ;
100198: LD_ADDR_EXP 90
100202: PUSH
100203: LD_INT 1
100205: ST_TO_ADDR
// if p3 = 10 then
100206: LD_VAR 0 3
100210: PUSH
100211: LD_INT 10
100213: EQUAL
100214: IFFALSE 100224
// sFire := true ;
100216: LD_ADDR_EXP 91
100220: PUSH
100221: LD_INT 1
100223: ST_TO_ADDR
// if p3 = 11 then
100224: LD_VAR 0 3
100228: PUSH
100229: LD_INT 11
100231: EQUAL
100232: IFFALSE 100242
// sRefresh := true ;
100234: LD_ADDR_EXP 92
100238: PUSH
100239: LD_INT 1
100241: ST_TO_ADDR
// if p3 = 12 then
100242: LD_VAR 0 3
100246: PUSH
100247: LD_INT 12
100249: EQUAL
100250: IFFALSE 100260
// sExp := true ;
100252: LD_ADDR_EXP 93
100256: PUSH
100257: LD_INT 1
100259: ST_TO_ADDR
// if p3 = 13 then
100260: LD_VAR 0 3
100264: PUSH
100265: LD_INT 13
100267: EQUAL
100268: IFFALSE 100278
// sDepot := true ;
100270: LD_ADDR_EXP 94
100274: PUSH
100275: LD_INT 1
100277: ST_TO_ADDR
// if p3 = 14 then
100278: LD_VAR 0 3
100282: PUSH
100283: LD_INT 14
100285: EQUAL
100286: IFFALSE 100296
// sFlag := true ;
100288: LD_ADDR_EXP 95
100292: PUSH
100293: LD_INT 1
100295: ST_TO_ADDR
// if p3 = 15 then
100296: LD_VAR 0 3
100300: PUSH
100301: LD_INT 15
100303: EQUAL
100304: IFFALSE 100314
// sKamikadze := true ;
100306: LD_ADDR_EXP 103
100310: PUSH
100311: LD_INT 1
100313: ST_TO_ADDR
// if p3 = 16 then
100314: LD_VAR 0 3
100318: PUSH
100319: LD_INT 16
100321: EQUAL
100322: IFFALSE 100332
// sTroll := true ;
100324: LD_ADDR_EXP 104
100328: PUSH
100329: LD_INT 1
100331: ST_TO_ADDR
// if p3 = 17 then
100332: LD_VAR 0 3
100336: PUSH
100337: LD_INT 17
100339: EQUAL
100340: IFFALSE 100350
// sSlow := true ;
100342: LD_ADDR_EXP 105
100346: PUSH
100347: LD_INT 1
100349: ST_TO_ADDR
// if p3 = 18 then
100350: LD_VAR 0 3
100354: PUSH
100355: LD_INT 18
100357: EQUAL
100358: IFFALSE 100368
// sLack := true ;
100360: LD_ADDR_EXP 106
100364: PUSH
100365: LD_INT 1
100367: ST_TO_ADDR
// if p3 = 19 then
100368: LD_VAR 0 3
100372: PUSH
100373: LD_INT 19
100375: EQUAL
100376: IFFALSE 100386
// sTank := true ;
100378: LD_ADDR_EXP 108
100382: PUSH
100383: LD_INT 1
100385: ST_TO_ADDR
// if p3 = 20 then
100386: LD_VAR 0 3
100390: PUSH
100391: LD_INT 20
100393: EQUAL
100394: IFFALSE 100404
// sRemote := true ;
100396: LD_ADDR_EXP 109
100400: PUSH
100401: LD_INT 1
100403: ST_TO_ADDR
// if p3 = 21 then
100404: LD_VAR 0 3
100408: PUSH
100409: LD_INT 21
100411: EQUAL
100412: IFFALSE 100422
// sPowell := true ;
100414: LD_ADDR_EXP 110
100418: PUSH
100419: LD_INT 1
100421: ST_TO_ADDR
// if p3 = 22 then
100422: LD_VAR 0 3
100426: PUSH
100427: LD_INT 22
100429: EQUAL
100430: IFFALSE 100440
// sTeleport := true ;
100432: LD_ADDR_EXP 113
100436: PUSH
100437: LD_INT 1
100439: ST_TO_ADDR
// if p3 = 23 then
100440: LD_VAR 0 3
100444: PUSH
100445: LD_INT 23
100447: EQUAL
100448: IFFALSE 100458
// sOilTower := true ;
100450: LD_ADDR_EXP 115
100454: PUSH
100455: LD_INT 1
100457: ST_TO_ADDR
// if p3 = 24 then
100458: LD_VAR 0 3
100462: PUSH
100463: LD_INT 24
100465: EQUAL
100466: IFFALSE 100476
// sShovel := true ;
100468: LD_ADDR_EXP 116
100472: PUSH
100473: LD_INT 1
100475: ST_TO_ADDR
// if p3 = 25 then
100476: LD_VAR 0 3
100480: PUSH
100481: LD_INT 25
100483: EQUAL
100484: IFFALSE 100494
// sSheik := true ;
100486: LD_ADDR_EXP 117
100490: PUSH
100491: LD_INT 1
100493: ST_TO_ADDR
// if p3 = 26 then
100494: LD_VAR 0 3
100498: PUSH
100499: LD_INT 26
100501: EQUAL
100502: IFFALSE 100512
// sEarthquake := true ;
100504: LD_ADDR_EXP 119
100508: PUSH
100509: LD_INT 1
100511: ST_TO_ADDR
// if p3 = 27 then
100512: LD_VAR 0 3
100516: PUSH
100517: LD_INT 27
100519: EQUAL
100520: IFFALSE 100530
// sAI := true ;
100522: LD_ADDR_EXP 120
100526: PUSH
100527: LD_INT 1
100529: ST_TO_ADDR
// if p3 = 28 then
100530: LD_VAR 0 3
100534: PUSH
100535: LD_INT 28
100537: EQUAL
100538: IFFALSE 100548
// sCargo := true ;
100540: LD_ADDR_EXP 123
100544: PUSH
100545: LD_INT 1
100547: ST_TO_ADDR
// if p3 = 29 then
100548: LD_VAR 0 3
100552: PUSH
100553: LD_INT 29
100555: EQUAL
100556: IFFALSE 100566
// sDLaser := true ;
100558: LD_ADDR_EXP 124
100562: PUSH
100563: LD_INT 1
100565: ST_TO_ADDR
// if p3 = 30 then
100566: LD_VAR 0 3
100570: PUSH
100571: LD_INT 30
100573: EQUAL
100574: IFFALSE 100584
// sExchange := true ;
100576: LD_ADDR_EXP 125
100580: PUSH
100581: LD_INT 1
100583: ST_TO_ADDR
// if p3 = 31 then
100584: LD_VAR 0 3
100588: PUSH
100589: LD_INT 31
100591: EQUAL
100592: IFFALSE 100602
// sFac := true ;
100594: LD_ADDR_EXP 126
100598: PUSH
100599: LD_INT 1
100601: ST_TO_ADDR
// if p3 = 32 then
100602: LD_VAR 0 3
100606: PUSH
100607: LD_INT 32
100609: EQUAL
100610: IFFALSE 100620
// sPower := true ;
100612: LD_ADDR_EXP 127
100616: PUSH
100617: LD_INT 1
100619: ST_TO_ADDR
// if p3 = 33 then
100620: LD_VAR 0 3
100624: PUSH
100625: LD_INT 33
100627: EQUAL
100628: IFFALSE 100638
// sRandom := true ;
100630: LD_ADDR_EXP 128
100634: PUSH
100635: LD_INT 1
100637: ST_TO_ADDR
// if p3 = 34 then
100638: LD_VAR 0 3
100642: PUSH
100643: LD_INT 34
100645: EQUAL
100646: IFFALSE 100656
// sShield := true ;
100648: LD_ADDR_EXP 129
100652: PUSH
100653: LD_INT 1
100655: ST_TO_ADDR
// if p3 = 35 then
100656: LD_VAR 0 3
100660: PUSH
100661: LD_INT 35
100663: EQUAL
100664: IFFALSE 100674
// sTime := true ;
100666: LD_ADDR_EXP 130
100670: PUSH
100671: LD_INT 1
100673: ST_TO_ADDR
// if p3 = 36 then
100674: LD_VAR 0 3
100678: PUSH
100679: LD_INT 36
100681: EQUAL
100682: IFFALSE 100692
// sTools := true ;
100684: LD_ADDR_EXP 131
100688: PUSH
100689: LD_INT 1
100691: ST_TO_ADDR
// if p3 = 101 then
100692: LD_VAR 0 3
100696: PUSH
100697: LD_INT 101
100699: EQUAL
100700: IFFALSE 100710
// sSold := true ;
100702: LD_ADDR_EXP 96
100706: PUSH
100707: LD_INT 1
100709: ST_TO_ADDR
// if p3 = 102 then
100710: LD_VAR 0 3
100714: PUSH
100715: LD_INT 102
100717: EQUAL
100718: IFFALSE 100728
// sDiff := true ;
100720: LD_ADDR_EXP 97
100724: PUSH
100725: LD_INT 1
100727: ST_TO_ADDR
// if p3 = 103 then
100728: LD_VAR 0 3
100732: PUSH
100733: LD_INT 103
100735: EQUAL
100736: IFFALSE 100746
// sFog := true ;
100738: LD_ADDR_EXP 100
100742: PUSH
100743: LD_INT 1
100745: ST_TO_ADDR
// if p3 = 104 then
100746: LD_VAR 0 3
100750: PUSH
100751: LD_INT 104
100753: EQUAL
100754: IFFALSE 100764
// sReset := true ;
100756: LD_ADDR_EXP 101
100760: PUSH
100761: LD_INT 1
100763: ST_TO_ADDR
// if p3 = 105 then
100764: LD_VAR 0 3
100768: PUSH
100769: LD_INT 105
100771: EQUAL
100772: IFFALSE 100782
// sSun := true ;
100774: LD_ADDR_EXP 102
100778: PUSH
100779: LD_INT 1
100781: ST_TO_ADDR
// if p3 = 106 then
100782: LD_VAR 0 3
100786: PUSH
100787: LD_INT 106
100789: EQUAL
100790: IFFALSE 100800
// sTiger := true ;
100792: LD_ADDR_EXP 98
100796: PUSH
100797: LD_INT 1
100799: ST_TO_ADDR
// if p3 = 107 then
100800: LD_VAR 0 3
100804: PUSH
100805: LD_INT 107
100807: EQUAL
100808: IFFALSE 100818
// sBomb := true ;
100810: LD_ADDR_EXP 99
100814: PUSH
100815: LD_INT 1
100817: ST_TO_ADDR
// if p3 = 108 then
100818: LD_VAR 0 3
100822: PUSH
100823: LD_INT 108
100825: EQUAL
100826: IFFALSE 100836
// sWound := true ;
100828: LD_ADDR_EXP 107
100832: PUSH
100833: LD_INT 1
100835: ST_TO_ADDR
// if p3 = 109 then
100836: LD_VAR 0 3
100840: PUSH
100841: LD_INT 109
100843: EQUAL
100844: IFFALSE 100854
// sBetray := true ;
100846: LD_ADDR_EXP 111
100850: PUSH
100851: LD_INT 1
100853: ST_TO_ADDR
// if p3 = 110 then
100854: LD_VAR 0 3
100858: PUSH
100859: LD_INT 110
100861: EQUAL
100862: IFFALSE 100872
// sContamin := true ;
100864: LD_ADDR_EXP 112
100868: PUSH
100869: LD_INT 1
100871: ST_TO_ADDR
// if p3 = 111 then
100872: LD_VAR 0 3
100876: PUSH
100877: LD_INT 111
100879: EQUAL
100880: IFFALSE 100890
// sOil := true ;
100882: LD_ADDR_EXP 114
100886: PUSH
100887: LD_INT 1
100889: ST_TO_ADDR
// if p3 = 112 then
100890: LD_VAR 0 3
100894: PUSH
100895: LD_INT 112
100897: EQUAL
100898: IFFALSE 100908
// sStu := true ;
100900: LD_ADDR_EXP 118
100904: PUSH
100905: LD_INT 1
100907: ST_TO_ADDR
// if p3 = 113 then
100908: LD_VAR 0 3
100912: PUSH
100913: LD_INT 113
100915: EQUAL
100916: IFFALSE 100926
// sBazooka := true ;
100918: LD_ADDR_EXP 121
100922: PUSH
100923: LD_INT 1
100925: ST_TO_ADDR
// if p3 = 114 then
100926: LD_VAR 0 3
100930: PUSH
100931: LD_INT 114
100933: EQUAL
100934: IFFALSE 100944
// sMortar := true ;
100936: LD_ADDR_EXP 122
100940: PUSH
100941: LD_INT 1
100943: ST_TO_ADDR
// if p3 = 115 then
100944: LD_VAR 0 3
100948: PUSH
100949: LD_INT 115
100951: EQUAL
100952: IFFALSE 100962
// sRanger := true ;
100954: LD_ADDR_EXP 132
100958: PUSH
100959: LD_INT 1
100961: ST_TO_ADDR
// if p3 = 116 then
100962: LD_VAR 0 3
100966: PUSH
100967: LD_INT 116
100969: EQUAL
100970: IFFALSE 100980
// sComputer := true ;
100972: LD_ADDR_EXP 133
100976: PUSH
100977: LD_INT 1
100979: ST_TO_ADDR
// if p3 = 117 then
100980: LD_VAR 0 3
100984: PUSH
100985: LD_INT 117
100987: EQUAL
100988: IFFALSE 100998
// s30 := true ;
100990: LD_ADDR_EXP 134
100994: PUSH
100995: LD_INT 1
100997: ST_TO_ADDR
// if p3 = 118 then
100998: LD_VAR 0 3
101002: PUSH
101003: LD_INT 118
101005: EQUAL
101006: IFFALSE 101016
// s60 := true ;
101008: LD_ADDR_EXP 135
101012: PUSH
101013: LD_INT 1
101015: ST_TO_ADDR
// end ; if p2 = hack_mode then
101016: LD_VAR 0 2
101020: PUSH
101021: LD_INT 101
101023: EQUAL
101024: IFFALSE 101152
// begin case p3 of 1 :
101026: LD_VAR 0 3
101030: PUSH
101031: LD_INT 1
101033: DOUBLE
101034: EQUAL
101035: IFTRUE 101039
101037: GO 101046
101039: POP
// hHackUnlimitedResources ; 2 :
101040: CALL 113415 0 0
101044: GO 101152
101046: LD_INT 2
101048: DOUBLE
101049: EQUAL
101050: IFTRUE 101054
101052: GO 101061
101054: POP
// hHackSetLevel10 ; 3 :
101055: CALL 113548 0 0
101059: GO 101152
101061: LD_INT 3
101063: DOUBLE
101064: EQUAL
101065: IFTRUE 101069
101067: GO 101076
101069: POP
// hHackSetLevel10YourUnits ; 4 :
101070: CALL 113633 0 0
101074: GO 101152
101076: LD_INT 4
101078: DOUBLE
101079: EQUAL
101080: IFTRUE 101084
101082: GO 101091
101084: POP
// hHackInvincible ; 5 :
101085: CALL 114081 0 0
101089: GO 101152
101091: LD_INT 5
101093: DOUBLE
101094: EQUAL
101095: IFTRUE 101099
101097: GO 101106
101099: POP
// hHackInvisible ; 6 :
101100: CALL 114192 0 0
101104: GO 101152
101106: LD_INT 6
101108: DOUBLE
101109: EQUAL
101110: IFTRUE 101114
101112: GO 101121
101114: POP
// hHackChangeYourSide ; 7 :
101115: CALL 114249 0 0
101119: GO 101152
101121: LD_INT 7
101123: DOUBLE
101124: EQUAL
101125: IFTRUE 101129
101127: GO 101136
101129: POP
// hHackChangeUnitSide ; 8 :
101130: CALL 114291 0 0
101134: GO 101152
101136: LD_INT 8
101138: DOUBLE
101139: EQUAL
101140: IFTRUE 101144
101142: GO 101151
101144: POP
// hHackFog ; end ;
101145: CALL 114392 0 0
101149: GO 101152
101151: POP
// end ; if p2 = game_save_mode then
101152: LD_VAR 0 2
101156: PUSH
101157: LD_INT 102
101159: EQUAL
101160: IFFALSE 101217
// begin if p3 = 1 then
101162: LD_VAR 0 3
101166: PUSH
101167: LD_INT 1
101169: EQUAL
101170: IFFALSE 101182
// globalGameSaveCounter := p4 ;
101172: LD_ADDR_EXP 78
101176: PUSH
101177: LD_VAR 0 4
101181: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
101182: LD_VAR 0 3
101186: PUSH
101187: LD_INT 2
101189: EQUAL
101190: IFFALSE 101198
101192: PUSH
101193: LD_EXP 78
101197: AND
101198: IFFALSE 101217
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
101200: LD_STRING setGameSaveCounter(
101202: PUSH
101203: LD_EXP 78
101207: STR
101208: PUSH
101209: LD_STRING )
101211: STR
101212: PPUSH
101213: CALL_OW 559
// end ; end ;
101217: LD_VAR 0 7
101221: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
101222: LD_INT 0
101224: PPUSH
// streamModeActive := false ;
101225: LD_ADDR_EXP 79
101229: PUSH
101230: LD_INT 0
101232: ST_TO_ADDR
// normalCounter := 36 ;
101233: LD_ADDR_EXP 80
101237: PUSH
101238: LD_INT 36
101240: ST_TO_ADDR
// hardcoreCounter := 18 ;
101241: LD_ADDR_EXP 81
101245: PUSH
101246: LD_INT 18
101248: ST_TO_ADDR
// sRocket := false ;
101249: LD_ADDR_EXP 84
101253: PUSH
101254: LD_INT 0
101256: ST_TO_ADDR
// sSpeed := false ;
101257: LD_ADDR_EXP 83
101261: PUSH
101262: LD_INT 0
101264: ST_TO_ADDR
// sEngine := false ;
101265: LD_ADDR_EXP 85
101269: PUSH
101270: LD_INT 0
101272: ST_TO_ADDR
// sSpec := false ;
101273: LD_ADDR_EXP 82
101277: PUSH
101278: LD_INT 0
101280: ST_TO_ADDR
// sLevel := false ;
101281: LD_ADDR_EXP 86
101285: PUSH
101286: LD_INT 0
101288: ST_TO_ADDR
// sArmoury := false ;
101289: LD_ADDR_EXP 87
101293: PUSH
101294: LD_INT 0
101296: ST_TO_ADDR
// sRadar := false ;
101297: LD_ADDR_EXP 88
101301: PUSH
101302: LD_INT 0
101304: ST_TO_ADDR
// sBunker := false ;
101305: LD_ADDR_EXP 89
101309: PUSH
101310: LD_INT 0
101312: ST_TO_ADDR
// sHack := false ;
101313: LD_ADDR_EXP 90
101317: PUSH
101318: LD_INT 0
101320: ST_TO_ADDR
// sFire := false ;
101321: LD_ADDR_EXP 91
101325: PUSH
101326: LD_INT 0
101328: ST_TO_ADDR
// sRefresh := false ;
101329: LD_ADDR_EXP 92
101333: PUSH
101334: LD_INT 0
101336: ST_TO_ADDR
// sExp := false ;
101337: LD_ADDR_EXP 93
101341: PUSH
101342: LD_INT 0
101344: ST_TO_ADDR
// sDepot := false ;
101345: LD_ADDR_EXP 94
101349: PUSH
101350: LD_INT 0
101352: ST_TO_ADDR
// sFlag := false ;
101353: LD_ADDR_EXP 95
101357: PUSH
101358: LD_INT 0
101360: ST_TO_ADDR
// sKamikadze := false ;
101361: LD_ADDR_EXP 103
101365: PUSH
101366: LD_INT 0
101368: ST_TO_ADDR
// sTroll := false ;
101369: LD_ADDR_EXP 104
101373: PUSH
101374: LD_INT 0
101376: ST_TO_ADDR
// sSlow := false ;
101377: LD_ADDR_EXP 105
101381: PUSH
101382: LD_INT 0
101384: ST_TO_ADDR
// sLack := false ;
101385: LD_ADDR_EXP 106
101389: PUSH
101390: LD_INT 0
101392: ST_TO_ADDR
// sTank := false ;
101393: LD_ADDR_EXP 108
101397: PUSH
101398: LD_INT 0
101400: ST_TO_ADDR
// sRemote := false ;
101401: LD_ADDR_EXP 109
101405: PUSH
101406: LD_INT 0
101408: ST_TO_ADDR
// sPowell := false ;
101409: LD_ADDR_EXP 110
101413: PUSH
101414: LD_INT 0
101416: ST_TO_ADDR
// sTeleport := false ;
101417: LD_ADDR_EXP 113
101421: PUSH
101422: LD_INT 0
101424: ST_TO_ADDR
// sOilTower := false ;
101425: LD_ADDR_EXP 115
101429: PUSH
101430: LD_INT 0
101432: ST_TO_ADDR
// sShovel := false ;
101433: LD_ADDR_EXP 116
101437: PUSH
101438: LD_INT 0
101440: ST_TO_ADDR
// sSheik := false ;
101441: LD_ADDR_EXP 117
101445: PUSH
101446: LD_INT 0
101448: ST_TO_ADDR
// sEarthquake := false ;
101449: LD_ADDR_EXP 119
101453: PUSH
101454: LD_INT 0
101456: ST_TO_ADDR
// sAI := false ;
101457: LD_ADDR_EXP 120
101461: PUSH
101462: LD_INT 0
101464: ST_TO_ADDR
// sCargo := false ;
101465: LD_ADDR_EXP 123
101469: PUSH
101470: LD_INT 0
101472: ST_TO_ADDR
// sDLaser := false ;
101473: LD_ADDR_EXP 124
101477: PUSH
101478: LD_INT 0
101480: ST_TO_ADDR
// sExchange := false ;
101481: LD_ADDR_EXP 125
101485: PUSH
101486: LD_INT 0
101488: ST_TO_ADDR
// sFac := false ;
101489: LD_ADDR_EXP 126
101493: PUSH
101494: LD_INT 0
101496: ST_TO_ADDR
// sPower := false ;
101497: LD_ADDR_EXP 127
101501: PUSH
101502: LD_INT 0
101504: ST_TO_ADDR
// sRandom := false ;
101505: LD_ADDR_EXP 128
101509: PUSH
101510: LD_INT 0
101512: ST_TO_ADDR
// sShield := false ;
101513: LD_ADDR_EXP 129
101517: PUSH
101518: LD_INT 0
101520: ST_TO_ADDR
// sTime := false ;
101521: LD_ADDR_EXP 130
101525: PUSH
101526: LD_INT 0
101528: ST_TO_ADDR
// sTools := false ;
101529: LD_ADDR_EXP 131
101533: PUSH
101534: LD_INT 0
101536: ST_TO_ADDR
// sSold := false ;
101537: LD_ADDR_EXP 96
101541: PUSH
101542: LD_INT 0
101544: ST_TO_ADDR
// sDiff := false ;
101545: LD_ADDR_EXP 97
101549: PUSH
101550: LD_INT 0
101552: ST_TO_ADDR
// sFog := false ;
101553: LD_ADDR_EXP 100
101557: PUSH
101558: LD_INT 0
101560: ST_TO_ADDR
// sReset := false ;
101561: LD_ADDR_EXP 101
101565: PUSH
101566: LD_INT 0
101568: ST_TO_ADDR
// sSun := false ;
101569: LD_ADDR_EXP 102
101573: PUSH
101574: LD_INT 0
101576: ST_TO_ADDR
// sTiger := false ;
101577: LD_ADDR_EXP 98
101581: PUSH
101582: LD_INT 0
101584: ST_TO_ADDR
// sBomb := false ;
101585: LD_ADDR_EXP 99
101589: PUSH
101590: LD_INT 0
101592: ST_TO_ADDR
// sWound := false ;
101593: LD_ADDR_EXP 107
101597: PUSH
101598: LD_INT 0
101600: ST_TO_ADDR
// sBetray := false ;
101601: LD_ADDR_EXP 111
101605: PUSH
101606: LD_INT 0
101608: ST_TO_ADDR
// sContamin := false ;
101609: LD_ADDR_EXP 112
101613: PUSH
101614: LD_INT 0
101616: ST_TO_ADDR
// sOil := false ;
101617: LD_ADDR_EXP 114
101621: PUSH
101622: LD_INT 0
101624: ST_TO_ADDR
// sStu := false ;
101625: LD_ADDR_EXP 118
101629: PUSH
101630: LD_INT 0
101632: ST_TO_ADDR
// sBazooka := false ;
101633: LD_ADDR_EXP 121
101637: PUSH
101638: LD_INT 0
101640: ST_TO_ADDR
// sMortar := false ;
101641: LD_ADDR_EXP 122
101645: PUSH
101646: LD_INT 0
101648: ST_TO_ADDR
// sRanger := false ;
101649: LD_ADDR_EXP 132
101653: PUSH
101654: LD_INT 0
101656: ST_TO_ADDR
// sComputer := false ;
101657: LD_ADDR_EXP 133
101661: PUSH
101662: LD_INT 0
101664: ST_TO_ADDR
// s30 := false ;
101665: LD_ADDR_EXP 134
101669: PUSH
101670: LD_INT 0
101672: ST_TO_ADDR
// s60 := false ;
101673: LD_ADDR_EXP 135
101677: PUSH
101678: LD_INT 0
101680: ST_TO_ADDR
// end ;
101681: LD_VAR 0 1
101685: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
101686: LD_INT 0
101688: PPUSH
101689: PPUSH
101690: PPUSH
101691: PPUSH
101692: PPUSH
101693: PPUSH
101694: PPUSH
// result := [ ] ;
101695: LD_ADDR_VAR 0 2
101699: PUSH
101700: EMPTY
101701: ST_TO_ADDR
// if campaign_id = 1 then
101702: LD_OWVAR 69
101706: PUSH
101707: LD_INT 1
101709: EQUAL
101710: IFFALSE 104876
// begin case mission_number of 1 :
101712: LD_OWVAR 70
101716: PUSH
101717: LD_INT 1
101719: DOUBLE
101720: EQUAL
101721: IFTRUE 101725
101723: GO 101801
101725: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
101726: LD_ADDR_VAR 0 2
101730: PUSH
101731: LD_INT 2
101733: PUSH
101734: LD_INT 4
101736: PUSH
101737: LD_INT 11
101739: PUSH
101740: LD_INT 12
101742: PUSH
101743: LD_INT 15
101745: PUSH
101746: LD_INT 16
101748: PUSH
101749: LD_INT 22
101751: PUSH
101752: LD_INT 23
101754: PUSH
101755: LD_INT 26
101757: PUSH
101758: EMPTY
101759: LIST
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: LIST
101765: LIST
101766: LIST
101767: LIST
101768: PUSH
101769: LD_INT 101
101771: PUSH
101772: LD_INT 102
101774: PUSH
101775: LD_INT 106
101777: PUSH
101778: LD_INT 116
101780: PUSH
101781: LD_INT 117
101783: PUSH
101784: LD_INT 118
101786: PUSH
101787: EMPTY
101788: LIST
101789: LIST
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: PUSH
101795: EMPTY
101796: LIST
101797: LIST
101798: ST_TO_ADDR
101799: GO 104874
101801: LD_INT 2
101803: DOUBLE
101804: EQUAL
101805: IFTRUE 101809
101807: GO 101893
101809: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
101810: LD_ADDR_VAR 0 2
101814: PUSH
101815: LD_INT 2
101817: PUSH
101818: LD_INT 4
101820: PUSH
101821: LD_INT 11
101823: PUSH
101824: LD_INT 12
101826: PUSH
101827: LD_INT 15
101829: PUSH
101830: LD_INT 16
101832: PUSH
101833: LD_INT 22
101835: PUSH
101836: LD_INT 23
101838: PUSH
101839: LD_INT 26
101841: PUSH
101842: EMPTY
101843: LIST
101844: LIST
101845: LIST
101846: LIST
101847: LIST
101848: LIST
101849: LIST
101850: LIST
101851: LIST
101852: PUSH
101853: LD_INT 101
101855: PUSH
101856: LD_INT 102
101858: PUSH
101859: LD_INT 105
101861: PUSH
101862: LD_INT 106
101864: PUSH
101865: LD_INT 108
101867: PUSH
101868: LD_INT 116
101870: PUSH
101871: LD_INT 117
101873: PUSH
101874: LD_INT 118
101876: PUSH
101877: EMPTY
101878: LIST
101879: LIST
101880: LIST
101881: LIST
101882: LIST
101883: LIST
101884: LIST
101885: LIST
101886: PUSH
101887: EMPTY
101888: LIST
101889: LIST
101890: ST_TO_ADDR
101891: GO 104874
101893: LD_INT 3
101895: DOUBLE
101896: EQUAL
101897: IFTRUE 101901
101899: GO 101989
101901: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
101902: LD_ADDR_VAR 0 2
101906: PUSH
101907: LD_INT 2
101909: PUSH
101910: LD_INT 4
101912: PUSH
101913: LD_INT 5
101915: PUSH
101916: LD_INT 11
101918: PUSH
101919: LD_INT 12
101921: PUSH
101922: LD_INT 15
101924: PUSH
101925: LD_INT 16
101927: PUSH
101928: LD_INT 22
101930: PUSH
101931: LD_INT 26
101933: PUSH
101934: LD_INT 36
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: LIST
101941: LIST
101942: LIST
101943: LIST
101944: LIST
101945: LIST
101946: LIST
101947: LIST
101948: PUSH
101949: LD_INT 101
101951: PUSH
101952: LD_INT 102
101954: PUSH
101955: LD_INT 105
101957: PUSH
101958: LD_INT 106
101960: PUSH
101961: LD_INT 108
101963: PUSH
101964: LD_INT 116
101966: PUSH
101967: LD_INT 117
101969: PUSH
101970: LD_INT 118
101972: PUSH
101973: EMPTY
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: PUSH
101983: EMPTY
101984: LIST
101985: LIST
101986: ST_TO_ADDR
101987: GO 104874
101989: LD_INT 4
101991: DOUBLE
101992: EQUAL
101993: IFTRUE 101997
101995: GO 102093
101997: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
101998: LD_ADDR_VAR 0 2
102002: PUSH
102003: LD_INT 2
102005: PUSH
102006: LD_INT 4
102008: PUSH
102009: LD_INT 5
102011: PUSH
102012: LD_INT 8
102014: PUSH
102015: LD_INT 11
102017: PUSH
102018: LD_INT 12
102020: PUSH
102021: LD_INT 15
102023: PUSH
102024: LD_INT 16
102026: PUSH
102027: LD_INT 22
102029: PUSH
102030: LD_INT 23
102032: PUSH
102033: LD_INT 26
102035: PUSH
102036: LD_INT 36
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: LIST
102043: LIST
102044: LIST
102045: LIST
102046: LIST
102047: LIST
102048: LIST
102049: LIST
102050: LIST
102051: LIST
102052: PUSH
102053: LD_INT 101
102055: PUSH
102056: LD_INT 102
102058: PUSH
102059: LD_INT 105
102061: PUSH
102062: LD_INT 106
102064: PUSH
102065: LD_INT 108
102067: PUSH
102068: LD_INT 116
102070: PUSH
102071: LD_INT 117
102073: PUSH
102074: LD_INT 118
102076: PUSH
102077: EMPTY
102078: LIST
102079: LIST
102080: LIST
102081: LIST
102082: LIST
102083: LIST
102084: LIST
102085: LIST
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: ST_TO_ADDR
102091: GO 104874
102093: LD_INT 5
102095: DOUBLE
102096: EQUAL
102097: IFTRUE 102101
102099: GO 102213
102101: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
102102: LD_ADDR_VAR 0 2
102106: PUSH
102107: LD_INT 2
102109: PUSH
102110: LD_INT 4
102112: PUSH
102113: LD_INT 5
102115: PUSH
102116: LD_INT 6
102118: PUSH
102119: LD_INT 8
102121: PUSH
102122: LD_INT 11
102124: PUSH
102125: LD_INT 12
102127: PUSH
102128: LD_INT 15
102130: PUSH
102131: LD_INT 16
102133: PUSH
102134: LD_INT 22
102136: PUSH
102137: LD_INT 23
102139: PUSH
102140: LD_INT 25
102142: PUSH
102143: LD_INT 26
102145: PUSH
102146: LD_INT 36
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: LIST
102155: LIST
102156: LIST
102157: LIST
102158: LIST
102159: LIST
102160: LIST
102161: LIST
102162: LIST
102163: LIST
102164: PUSH
102165: LD_INT 101
102167: PUSH
102168: LD_INT 102
102170: PUSH
102171: LD_INT 105
102173: PUSH
102174: LD_INT 106
102176: PUSH
102177: LD_INT 108
102179: PUSH
102180: LD_INT 109
102182: PUSH
102183: LD_INT 112
102185: PUSH
102186: LD_INT 116
102188: PUSH
102189: LD_INT 117
102191: PUSH
102192: LD_INT 118
102194: PUSH
102195: EMPTY
102196: LIST
102197: LIST
102198: LIST
102199: LIST
102200: LIST
102201: LIST
102202: LIST
102203: LIST
102204: LIST
102205: LIST
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: ST_TO_ADDR
102211: GO 104874
102213: LD_INT 6
102215: DOUBLE
102216: EQUAL
102217: IFTRUE 102221
102219: GO 102353
102221: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
102222: LD_ADDR_VAR 0 2
102226: PUSH
102227: LD_INT 2
102229: PUSH
102230: LD_INT 4
102232: PUSH
102233: LD_INT 5
102235: PUSH
102236: LD_INT 6
102238: PUSH
102239: LD_INT 8
102241: PUSH
102242: LD_INT 11
102244: PUSH
102245: LD_INT 12
102247: PUSH
102248: LD_INT 15
102250: PUSH
102251: LD_INT 16
102253: PUSH
102254: LD_INT 20
102256: PUSH
102257: LD_INT 21
102259: PUSH
102260: LD_INT 22
102262: PUSH
102263: LD_INT 23
102265: PUSH
102266: LD_INT 25
102268: PUSH
102269: LD_INT 26
102271: PUSH
102272: LD_INT 30
102274: PUSH
102275: LD_INT 31
102277: PUSH
102278: LD_INT 32
102280: PUSH
102281: LD_INT 36
102283: PUSH
102284: EMPTY
102285: LIST
102286: LIST
102287: LIST
102288: LIST
102289: LIST
102290: LIST
102291: LIST
102292: LIST
102293: LIST
102294: LIST
102295: LIST
102296: LIST
102297: LIST
102298: LIST
102299: LIST
102300: LIST
102301: LIST
102302: LIST
102303: LIST
102304: PUSH
102305: LD_INT 101
102307: PUSH
102308: LD_INT 102
102310: PUSH
102311: LD_INT 105
102313: PUSH
102314: LD_INT 106
102316: PUSH
102317: LD_INT 108
102319: PUSH
102320: LD_INT 109
102322: PUSH
102323: LD_INT 112
102325: PUSH
102326: LD_INT 116
102328: PUSH
102329: LD_INT 117
102331: PUSH
102332: LD_INT 118
102334: PUSH
102335: EMPTY
102336: LIST
102337: LIST
102338: LIST
102339: LIST
102340: LIST
102341: LIST
102342: LIST
102343: LIST
102344: LIST
102345: LIST
102346: PUSH
102347: EMPTY
102348: LIST
102349: LIST
102350: ST_TO_ADDR
102351: GO 104874
102353: LD_INT 7
102355: DOUBLE
102356: EQUAL
102357: IFTRUE 102361
102359: GO 102473
102361: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
102362: LD_ADDR_VAR 0 2
102366: PUSH
102367: LD_INT 2
102369: PUSH
102370: LD_INT 4
102372: PUSH
102373: LD_INT 5
102375: PUSH
102376: LD_INT 7
102378: PUSH
102379: LD_INT 11
102381: PUSH
102382: LD_INT 12
102384: PUSH
102385: LD_INT 15
102387: PUSH
102388: LD_INT 16
102390: PUSH
102391: LD_INT 20
102393: PUSH
102394: LD_INT 21
102396: PUSH
102397: LD_INT 22
102399: PUSH
102400: LD_INT 23
102402: PUSH
102403: LD_INT 25
102405: PUSH
102406: LD_INT 26
102408: PUSH
102409: EMPTY
102410: LIST
102411: LIST
102412: LIST
102413: LIST
102414: LIST
102415: LIST
102416: LIST
102417: LIST
102418: LIST
102419: LIST
102420: LIST
102421: LIST
102422: LIST
102423: LIST
102424: PUSH
102425: LD_INT 101
102427: PUSH
102428: LD_INT 102
102430: PUSH
102431: LD_INT 103
102433: PUSH
102434: LD_INT 105
102436: PUSH
102437: LD_INT 106
102439: PUSH
102440: LD_INT 108
102442: PUSH
102443: LD_INT 112
102445: PUSH
102446: LD_INT 116
102448: PUSH
102449: LD_INT 117
102451: PUSH
102452: LD_INT 118
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: LIST
102459: LIST
102460: LIST
102461: LIST
102462: LIST
102463: LIST
102464: LIST
102465: LIST
102466: PUSH
102467: EMPTY
102468: LIST
102469: LIST
102470: ST_TO_ADDR
102471: GO 104874
102473: LD_INT 8
102475: DOUBLE
102476: EQUAL
102477: IFTRUE 102481
102479: GO 102621
102481: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
102482: LD_ADDR_VAR 0 2
102486: PUSH
102487: LD_INT 2
102489: PUSH
102490: LD_INT 4
102492: PUSH
102493: LD_INT 5
102495: PUSH
102496: LD_INT 6
102498: PUSH
102499: LD_INT 7
102501: PUSH
102502: LD_INT 8
102504: PUSH
102505: LD_INT 11
102507: PUSH
102508: LD_INT 12
102510: PUSH
102511: LD_INT 15
102513: PUSH
102514: LD_INT 16
102516: PUSH
102517: LD_INT 20
102519: PUSH
102520: LD_INT 21
102522: PUSH
102523: LD_INT 22
102525: PUSH
102526: LD_INT 23
102528: PUSH
102529: LD_INT 25
102531: PUSH
102532: LD_INT 26
102534: PUSH
102535: LD_INT 30
102537: PUSH
102538: LD_INT 31
102540: PUSH
102541: LD_INT 32
102543: PUSH
102544: LD_INT 36
102546: PUSH
102547: EMPTY
102548: LIST
102549: LIST
102550: LIST
102551: LIST
102552: LIST
102553: LIST
102554: LIST
102555: LIST
102556: LIST
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: LIST
102564: LIST
102565: LIST
102566: LIST
102567: LIST
102568: PUSH
102569: LD_INT 101
102571: PUSH
102572: LD_INT 102
102574: PUSH
102575: LD_INT 103
102577: PUSH
102578: LD_INT 105
102580: PUSH
102581: LD_INT 106
102583: PUSH
102584: LD_INT 108
102586: PUSH
102587: LD_INT 109
102589: PUSH
102590: LD_INT 112
102592: PUSH
102593: LD_INT 116
102595: PUSH
102596: LD_INT 117
102598: PUSH
102599: LD_INT 118
102601: PUSH
102602: EMPTY
102603: LIST
102604: LIST
102605: LIST
102606: LIST
102607: LIST
102608: LIST
102609: LIST
102610: LIST
102611: LIST
102612: LIST
102613: LIST
102614: PUSH
102615: EMPTY
102616: LIST
102617: LIST
102618: ST_TO_ADDR
102619: GO 104874
102621: LD_INT 9
102623: DOUBLE
102624: EQUAL
102625: IFTRUE 102629
102627: GO 102777
102629: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
102630: LD_ADDR_VAR 0 2
102634: PUSH
102635: LD_INT 2
102637: PUSH
102638: LD_INT 4
102640: PUSH
102641: LD_INT 5
102643: PUSH
102644: LD_INT 6
102646: PUSH
102647: LD_INT 7
102649: PUSH
102650: LD_INT 8
102652: PUSH
102653: LD_INT 11
102655: PUSH
102656: LD_INT 12
102658: PUSH
102659: LD_INT 15
102661: PUSH
102662: LD_INT 16
102664: PUSH
102665: LD_INT 20
102667: PUSH
102668: LD_INT 21
102670: PUSH
102671: LD_INT 22
102673: PUSH
102674: LD_INT 23
102676: PUSH
102677: LD_INT 25
102679: PUSH
102680: LD_INT 26
102682: PUSH
102683: LD_INT 28
102685: PUSH
102686: LD_INT 30
102688: PUSH
102689: LD_INT 31
102691: PUSH
102692: LD_INT 32
102694: PUSH
102695: LD_INT 36
102697: PUSH
102698: EMPTY
102699: LIST
102700: LIST
102701: LIST
102702: LIST
102703: LIST
102704: LIST
102705: LIST
102706: LIST
102707: LIST
102708: LIST
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: LIST
102714: LIST
102715: LIST
102716: LIST
102717: LIST
102718: LIST
102719: LIST
102720: PUSH
102721: LD_INT 101
102723: PUSH
102724: LD_INT 102
102726: PUSH
102727: LD_INT 103
102729: PUSH
102730: LD_INT 105
102732: PUSH
102733: LD_INT 106
102735: PUSH
102736: LD_INT 108
102738: PUSH
102739: LD_INT 109
102741: PUSH
102742: LD_INT 112
102744: PUSH
102745: LD_INT 114
102747: PUSH
102748: LD_INT 116
102750: PUSH
102751: LD_INT 117
102753: PUSH
102754: LD_INT 118
102756: PUSH
102757: EMPTY
102758: LIST
102759: LIST
102760: LIST
102761: LIST
102762: LIST
102763: LIST
102764: LIST
102765: LIST
102766: LIST
102767: LIST
102768: LIST
102769: LIST
102770: PUSH
102771: EMPTY
102772: LIST
102773: LIST
102774: ST_TO_ADDR
102775: GO 104874
102777: LD_INT 10
102779: DOUBLE
102780: EQUAL
102781: IFTRUE 102785
102783: GO 102981
102785: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
102786: LD_ADDR_VAR 0 2
102790: PUSH
102791: LD_INT 2
102793: PUSH
102794: LD_INT 4
102796: PUSH
102797: LD_INT 5
102799: PUSH
102800: LD_INT 6
102802: PUSH
102803: LD_INT 7
102805: PUSH
102806: LD_INT 8
102808: PUSH
102809: LD_INT 9
102811: PUSH
102812: LD_INT 10
102814: PUSH
102815: LD_INT 11
102817: PUSH
102818: LD_INT 12
102820: PUSH
102821: LD_INT 13
102823: PUSH
102824: LD_INT 14
102826: PUSH
102827: LD_INT 15
102829: PUSH
102830: LD_INT 16
102832: PUSH
102833: LD_INT 17
102835: PUSH
102836: LD_INT 18
102838: PUSH
102839: LD_INT 19
102841: PUSH
102842: LD_INT 20
102844: PUSH
102845: LD_INT 21
102847: PUSH
102848: LD_INT 22
102850: PUSH
102851: LD_INT 23
102853: PUSH
102854: LD_INT 24
102856: PUSH
102857: LD_INT 25
102859: PUSH
102860: LD_INT 26
102862: PUSH
102863: LD_INT 28
102865: PUSH
102866: LD_INT 30
102868: PUSH
102869: LD_INT 31
102871: PUSH
102872: LD_INT 32
102874: PUSH
102875: LD_INT 36
102877: PUSH
102878: EMPTY
102879: LIST
102880: LIST
102881: LIST
102882: LIST
102883: LIST
102884: LIST
102885: LIST
102886: LIST
102887: LIST
102888: LIST
102889: LIST
102890: LIST
102891: LIST
102892: LIST
102893: LIST
102894: LIST
102895: LIST
102896: LIST
102897: LIST
102898: LIST
102899: LIST
102900: LIST
102901: LIST
102902: LIST
102903: LIST
102904: LIST
102905: LIST
102906: LIST
102907: LIST
102908: PUSH
102909: LD_INT 101
102911: PUSH
102912: LD_INT 102
102914: PUSH
102915: LD_INT 103
102917: PUSH
102918: LD_INT 104
102920: PUSH
102921: LD_INT 105
102923: PUSH
102924: LD_INT 106
102926: PUSH
102927: LD_INT 107
102929: PUSH
102930: LD_INT 108
102932: PUSH
102933: LD_INT 109
102935: PUSH
102936: LD_INT 110
102938: PUSH
102939: LD_INT 111
102941: PUSH
102942: LD_INT 112
102944: PUSH
102945: LD_INT 114
102947: PUSH
102948: LD_INT 116
102950: PUSH
102951: LD_INT 117
102953: PUSH
102954: LD_INT 118
102956: PUSH
102957: EMPTY
102958: LIST
102959: LIST
102960: LIST
102961: LIST
102962: LIST
102963: LIST
102964: LIST
102965: LIST
102966: LIST
102967: LIST
102968: LIST
102969: LIST
102970: LIST
102971: LIST
102972: LIST
102973: LIST
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: ST_TO_ADDR
102979: GO 104874
102981: LD_INT 11
102983: DOUBLE
102984: EQUAL
102985: IFTRUE 102989
102987: GO 103193
102989: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
102990: LD_ADDR_VAR 0 2
102994: PUSH
102995: LD_INT 2
102997: PUSH
102998: LD_INT 3
103000: PUSH
103001: LD_INT 4
103003: PUSH
103004: LD_INT 5
103006: PUSH
103007: LD_INT 6
103009: PUSH
103010: LD_INT 7
103012: PUSH
103013: LD_INT 8
103015: PUSH
103016: LD_INT 9
103018: PUSH
103019: LD_INT 10
103021: PUSH
103022: LD_INT 11
103024: PUSH
103025: LD_INT 12
103027: PUSH
103028: LD_INT 13
103030: PUSH
103031: LD_INT 14
103033: PUSH
103034: LD_INT 15
103036: PUSH
103037: LD_INT 16
103039: PUSH
103040: LD_INT 17
103042: PUSH
103043: LD_INT 18
103045: PUSH
103046: LD_INT 19
103048: PUSH
103049: LD_INT 20
103051: PUSH
103052: LD_INT 21
103054: PUSH
103055: LD_INT 22
103057: PUSH
103058: LD_INT 23
103060: PUSH
103061: LD_INT 24
103063: PUSH
103064: LD_INT 25
103066: PUSH
103067: LD_INT 26
103069: PUSH
103070: LD_INT 28
103072: PUSH
103073: LD_INT 30
103075: PUSH
103076: LD_INT 31
103078: PUSH
103079: LD_INT 32
103081: PUSH
103082: LD_INT 34
103084: PUSH
103085: LD_INT 36
103087: PUSH
103088: EMPTY
103089: LIST
103090: LIST
103091: LIST
103092: LIST
103093: LIST
103094: LIST
103095: LIST
103096: LIST
103097: LIST
103098: LIST
103099: LIST
103100: LIST
103101: LIST
103102: LIST
103103: LIST
103104: LIST
103105: LIST
103106: LIST
103107: LIST
103108: LIST
103109: LIST
103110: LIST
103111: LIST
103112: LIST
103113: LIST
103114: LIST
103115: LIST
103116: LIST
103117: LIST
103118: LIST
103119: LIST
103120: PUSH
103121: LD_INT 101
103123: PUSH
103124: LD_INT 102
103126: PUSH
103127: LD_INT 103
103129: PUSH
103130: LD_INT 104
103132: PUSH
103133: LD_INT 105
103135: PUSH
103136: LD_INT 106
103138: PUSH
103139: LD_INT 107
103141: PUSH
103142: LD_INT 108
103144: PUSH
103145: LD_INT 109
103147: PUSH
103148: LD_INT 110
103150: PUSH
103151: LD_INT 111
103153: PUSH
103154: LD_INT 112
103156: PUSH
103157: LD_INT 114
103159: PUSH
103160: LD_INT 116
103162: PUSH
103163: LD_INT 117
103165: PUSH
103166: LD_INT 118
103168: PUSH
103169: EMPTY
103170: LIST
103171: LIST
103172: LIST
103173: LIST
103174: LIST
103175: LIST
103176: LIST
103177: LIST
103178: LIST
103179: LIST
103180: LIST
103181: LIST
103182: LIST
103183: LIST
103184: LIST
103185: LIST
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: ST_TO_ADDR
103191: GO 104874
103193: LD_INT 12
103195: DOUBLE
103196: EQUAL
103197: IFTRUE 103201
103199: GO 103421
103201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
103202: LD_ADDR_VAR 0 2
103206: PUSH
103207: LD_INT 1
103209: PUSH
103210: LD_INT 2
103212: PUSH
103213: LD_INT 3
103215: PUSH
103216: LD_INT 4
103218: PUSH
103219: LD_INT 5
103221: PUSH
103222: LD_INT 6
103224: PUSH
103225: LD_INT 7
103227: PUSH
103228: LD_INT 8
103230: PUSH
103231: LD_INT 9
103233: PUSH
103234: LD_INT 10
103236: PUSH
103237: LD_INT 11
103239: PUSH
103240: LD_INT 12
103242: PUSH
103243: LD_INT 13
103245: PUSH
103246: LD_INT 14
103248: PUSH
103249: LD_INT 15
103251: PUSH
103252: LD_INT 16
103254: PUSH
103255: LD_INT 17
103257: PUSH
103258: LD_INT 18
103260: PUSH
103261: LD_INT 19
103263: PUSH
103264: LD_INT 20
103266: PUSH
103267: LD_INT 21
103269: PUSH
103270: LD_INT 22
103272: PUSH
103273: LD_INT 23
103275: PUSH
103276: LD_INT 24
103278: PUSH
103279: LD_INT 25
103281: PUSH
103282: LD_INT 26
103284: PUSH
103285: LD_INT 27
103287: PUSH
103288: LD_INT 28
103290: PUSH
103291: LD_INT 30
103293: PUSH
103294: LD_INT 31
103296: PUSH
103297: LD_INT 32
103299: PUSH
103300: LD_INT 33
103302: PUSH
103303: LD_INT 34
103305: PUSH
103306: LD_INT 36
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: LIST
103313: LIST
103314: LIST
103315: LIST
103316: LIST
103317: LIST
103318: LIST
103319: LIST
103320: LIST
103321: LIST
103322: LIST
103323: LIST
103324: LIST
103325: LIST
103326: LIST
103327: LIST
103328: LIST
103329: LIST
103330: LIST
103331: LIST
103332: LIST
103333: LIST
103334: LIST
103335: LIST
103336: LIST
103337: LIST
103338: LIST
103339: LIST
103340: LIST
103341: LIST
103342: LIST
103343: LIST
103344: PUSH
103345: LD_INT 101
103347: PUSH
103348: LD_INT 102
103350: PUSH
103351: LD_INT 103
103353: PUSH
103354: LD_INT 104
103356: PUSH
103357: LD_INT 105
103359: PUSH
103360: LD_INT 106
103362: PUSH
103363: LD_INT 107
103365: PUSH
103366: LD_INT 108
103368: PUSH
103369: LD_INT 109
103371: PUSH
103372: LD_INT 110
103374: PUSH
103375: LD_INT 111
103377: PUSH
103378: LD_INT 112
103380: PUSH
103381: LD_INT 113
103383: PUSH
103384: LD_INT 114
103386: PUSH
103387: LD_INT 116
103389: PUSH
103390: LD_INT 117
103392: PUSH
103393: LD_INT 118
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: LIST
103400: LIST
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: LIST
103407: LIST
103408: LIST
103409: LIST
103410: LIST
103411: LIST
103412: LIST
103413: LIST
103414: PUSH
103415: EMPTY
103416: LIST
103417: LIST
103418: ST_TO_ADDR
103419: GO 104874
103421: LD_INT 13
103423: DOUBLE
103424: EQUAL
103425: IFTRUE 103429
103427: GO 103637
103429: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
103430: LD_ADDR_VAR 0 2
103434: PUSH
103435: LD_INT 1
103437: PUSH
103438: LD_INT 2
103440: PUSH
103441: LD_INT 3
103443: PUSH
103444: LD_INT 4
103446: PUSH
103447: LD_INT 5
103449: PUSH
103450: LD_INT 8
103452: PUSH
103453: LD_INT 9
103455: PUSH
103456: LD_INT 10
103458: PUSH
103459: LD_INT 11
103461: PUSH
103462: LD_INT 12
103464: PUSH
103465: LD_INT 14
103467: PUSH
103468: LD_INT 15
103470: PUSH
103471: LD_INT 16
103473: PUSH
103474: LD_INT 17
103476: PUSH
103477: LD_INT 18
103479: PUSH
103480: LD_INT 19
103482: PUSH
103483: LD_INT 20
103485: PUSH
103486: LD_INT 21
103488: PUSH
103489: LD_INT 22
103491: PUSH
103492: LD_INT 23
103494: PUSH
103495: LD_INT 24
103497: PUSH
103498: LD_INT 25
103500: PUSH
103501: LD_INT 26
103503: PUSH
103504: LD_INT 27
103506: PUSH
103507: LD_INT 28
103509: PUSH
103510: LD_INT 30
103512: PUSH
103513: LD_INT 31
103515: PUSH
103516: LD_INT 32
103518: PUSH
103519: LD_INT 33
103521: PUSH
103522: LD_INT 34
103524: PUSH
103525: LD_INT 36
103527: PUSH
103528: EMPTY
103529: LIST
103530: LIST
103531: LIST
103532: LIST
103533: LIST
103534: LIST
103535: LIST
103536: LIST
103537: LIST
103538: LIST
103539: LIST
103540: LIST
103541: LIST
103542: LIST
103543: LIST
103544: LIST
103545: LIST
103546: LIST
103547: LIST
103548: LIST
103549: LIST
103550: LIST
103551: LIST
103552: LIST
103553: LIST
103554: LIST
103555: LIST
103556: LIST
103557: LIST
103558: LIST
103559: LIST
103560: PUSH
103561: LD_INT 101
103563: PUSH
103564: LD_INT 102
103566: PUSH
103567: LD_INT 103
103569: PUSH
103570: LD_INT 104
103572: PUSH
103573: LD_INT 105
103575: PUSH
103576: LD_INT 106
103578: PUSH
103579: LD_INT 107
103581: PUSH
103582: LD_INT 108
103584: PUSH
103585: LD_INT 109
103587: PUSH
103588: LD_INT 110
103590: PUSH
103591: LD_INT 111
103593: PUSH
103594: LD_INT 112
103596: PUSH
103597: LD_INT 113
103599: PUSH
103600: LD_INT 114
103602: PUSH
103603: LD_INT 116
103605: PUSH
103606: LD_INT 117
103608: PUSH
103609: LD_INT 118
103611: PUSH
103612: EMPTY
103613: LIST
103614: LIST
103615: LIST
103616: LIST
103617: LIST
103618: LIST
103619: LIST
103620: LIST
103621: LIST
103622: LIST
103623: LIST
103624: LIST
103625: LIST
103626: LIST
103627: LIST
103628: LIST
103629: LIST
103630: PUSH
103631: EMPTY
103632: LIST
103633: LIST
103634: ST_TO_ADDR
103635: GO 104874
103637: LD_INT 14
103639: DOUBLE
103640: EQUAL
103641: IFTRUE 103645
103643: GO 103869
103645: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
103646: LD_ADDR_VAR 0 2
103650: PUSH
103651: LD_INT 1
103653: PUSH
103654: LD_INT 2
103656: PUSH
103657: LD_INT 3
103659: PUSH
103660: LD_INT 4
103662: PUSH
103663: LD_INT 5
103665: PUSH
103666: LD_INT 6
103668: PUSH
103669: LD_INT 7
103671: PUSH
103672: LD_INT 8
103674: PUSH
103675: LD_INT 9
103677: PUSH
103678: LD_INT 10
103680: PUSH
103681: LD_INT 11
103683: PUSH
103684: LD_INT 12
103686: PUSH
103687: LD_INT 13
103689: PUSH
103690: LD_INT 14
103692: PUSH
103693: LD_INT 15
103695: PUSH
103696: LD_INT 16
103698: PUSH
103699: LD_INT 17
103701: PUSH
103702: LD_INT 18
103704: PUSH
103705: LD_INT 19
103707: PUSH
103708: LD_INT 20
103710: PUSH
103711: LD_INT 21
103713: PUSH
103714: LD_INT 22
103716: PUSH
103717: LD_INT 23
103719: PUSH
103720: LD_INT 24
103722: PUSH
103723: LD_INT 25
103725: PUSH
103726: LD_INT 26
103728: PUSH
103729: LD_INT 27
103731: PUSH
103732: LD_INT 28
103734: PUSH
103735: LD_INT 29
103737: PUSH
103738: LD_INT 30
103740: PUSH
103741: LD_INT 31
103743: PUSH
103744: LD_INT 32
103746: PUSH
103747: LD_INT 33
103749: PUSH
103750: LD_INT 34
103752: PUSH
103753: LD_INT 36
103755: PUSH
103756: EMPTY
103757: LIST
103758: LIST
103759: LIST
103760: LIST
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: LIST
103771: LIST
103772: LIST
103773: LIST
103774: LIST
103775: LIST
103776: LIST
103777: LIST
103778: LIST
103779: LIST
103780: LIST
103781: LIST
103782: LIST
103783: LIST
103784: LIST
103785: LIST
103786: LIST
103787: LIST
103788: LIST
103789: LIST
103790: LIST
103791: LIST
103792: PUSH
103793: LD_INT 101
103795: PUSH
103796: LD_INT 102
103798: PUSH
103799: LD_INT 103
103801: PUSH
103802: LD_INT 104
103804: PUSH
103805: LD_INT 105
103807: PUSH
103808: LD_INT 106
103810: PUSH
103811: LD_INT 107
103813: PUSH
103814: LD_INT 108
103816: PUSH
103817: LD_INT 109
103819: PUSH
103820: LD_INT 110
103822: PUSH
103823: LD_INT 111
103825: PUSH
103826: LD_INT 112
103828: PUSH
103829: LD_INT 113
103831: PUSH
103832: LD_INT 114
103834: PUSH
103835: LD_INT 116
103837: PUSH
103838: LD_INT 117
103840: PUSH
103841: LD_INT 118
103843: PUSH
103844: EMPTY
103845: LIST
103846: LIST
103847: LIST
103848: LIST
103849: LIST
103850: LIST
103851: LIST
103852: LIST
103853: LIST
103854: LIST
103855: LIST
103856: LIST
103857: LIST
103858: LIST
103859: LIST
103860: LIST
103861: LIST
103862: PUSH
103863: EMPTY
103864: LIST
103865: LIST
103866: ST_TO_ADDR
103867: GO 104874
103869: LD_INT 15
103871: DOUBLE
103872: EQUAL
103873: IFTRUE 103877
103875: GO 104101
103877: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
103878: LD_ADDR_VAR 0 2
103882: PUSH
103883: LD_INT 1
103885: PUSH
103886: LD_INT 2
103888: PUSH
103889: LD_INT 3
103891: PUSH
103892: LD_INT 4
103894: PUSH
103895: LD_INT 5
103897: PUSH
103898: LD_INT 6
103900: PUSH
103901: LD_INT 7
103903: PUSH
103904: LD_INT 8
103906: PUSH
103907: LD_INT 9
103909: PUSH
103910: LD_INT 10
103912: PUSH
103913: LD_INT 11
103915: PUSH
103916: LD_INT 12
103918: PUSH
103919: LD_INT 13
103921: PUSH
103922: LD_INT 14
103924: PUSH
103925: LD_INT 15
103927: PUSH
103928: LD_INT 16
103930: PUSH
103931: LD_INT 17
103933: PUSH
103934: LD_INT 18
103936: PUSH
103937: LD_INT 19
103939: PUSH
103940: LD_INT 20
103942: PUSH
103943: LD_INT 21
103945: PUSH
103946: LD_INT 22
103948: PUSH
103949: LD_INT 23
103951: PUSH
103952: LD_INT 24
103954: PUSH
103955: LD_INT 25
103957: PUSH
103958: LD_INT 26
103960: PUSH
103961: LD_INT 27
103963: PUSH
103964: LD_INT 28
103966: PUSH
103967: LD_INT 29
103969: PUSH
103970: LD_INT 30
103972: PUSH
103973: LD_INT 31
103975: PUSH
103976: LD_INT 32
103978: PUSH
103979: LD_INT 33
103981: PUSH
103982: LD_INT 34
103984: PUSH
103985: LD_INT 36
103987: PUSH
103988: EMPTY
103989: LIST
103990: LIST
103991: LIST
103992: LIST
103993: LIST
103994: LIST
103995: LIST
103996: LIST
103997: LIST
103998: LIST
103999: LIST
104000: LIST
104001: LIST
104002: LIST
104003: LIST
104004: LIST
104005: LIST
104006: LIST
104007: LIST
104008: LIST
104009: LIST
104010: LIST
104011: LIST
104012: LIST
104013: LIST
104014: LIST
104015: LIST
104016: LIST
104017: LIST
104018: LIST
104019: LIST
104020: LIST
104021: LIST
104022: LIST
104023: LIST
104024: PUSH
104025: LD_INT 101
104027: PUSH
104028: LD_INT 102
104030: PUSH
104031: LD_INT 103
104033: PUSH
104034: LD_INT 104
104036: PUSH
104037: LD_INT 105
104039: PUSH
104040: LD_INT 106
104042: PUSH
104043: LD_INT 107
104045: PUSH
104046: LD_INT 108
104048: PUSH
104049: LD_INT 109
104051: PUSH
104052: LD_INT 110
104054: PUSH
104055: LD_INT 111
104057: PUSH
104058: LD_INT 112
104060: PUSH
104061: LD_INT 113
104063: PUSH
104064: LD_INT 114
104066: PUSH
104067: LD_INT 116
104069: PUSH
104070: LD_INT 117
104072: PUSH
104073: LD_INT 118
104075: PUSH
104076: EMPTY
104077: LIST
104078: LIST
104079: LIST
104080: LIST
104081: LIST
104082: LIST
104083: LIST
104084: LIST
104085: LIST
104086: LIST
104087: LIST
104088: LIST
104089: LIST
104090: LIST
104091: LIST
104092: LIST
104093: LIST
104094: PUSH
104095: EMPTY
104096: LIST
104097: LIST
104098: ST_TO_ADDR
104099: GO 104874
104101: LD_INT 16
104103: DOUBLE
104104: EQUAL
104105: IFTRUE 104109
104107: GO 104245
104109: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
104110: LD_ADDR_VAR 0 2
104114: PUSH
104115: LD_INT 2
104117: PUSH
104118: LD_INT 4
104120: PUSH
104121: LD_INT 5
104123: PUSH
104124: LD_INT 7
104126: PUSH
104127: LD_INT 11
104129: PUSH
104130: LD_INT 12
104132: PUSH
104133: LD_INT 15
104135: PUSH
104136: LD_INT 16
104138: PUSH
104139: LD_INT 20
104141: PUSH
104142: LD_INT 21
104144: PUSH
104145: LD_INT 22
104147: PUSH
104148: LD_INT 23
104150: PUSH
104151: LD_INT 25
104153: PUSH
104154: LD_INT 26
104156: PUSH
104157: LD_INT 30
104159: PUSH
104160: LD_INT 31
104162: PUSH
104163: LD_INT 32
104165: PUSH
104166: LD_INT 33
104168: PUSH
104169: LD_INT 34
104171: PUSH
104172: EMPTY
104173: LIST
104174: LIST
104175: LIST
104176: LIST
104177: LIST
104178: LIST
104179: LIST
104180: LIST
104181: LIST
104182: LIST
104183: LIST
104184: LIST
104185: LIST
104186: LIST
104187: LIST
104188: LIST
104189: LIST
104190: LIST
104191: LIST
104192: PUSH
104193: LD_INT 101
104195: PUSH
104196: LD_INT 102
104198: PUSH
104199: LD_INT 103
104201: PUSH
104202: LD_INT 106
104204: PUSH
104205: LD_INT 108
104207: PUSH
104208: LD_INT 112
104210: PUSH
104211: LD_INT 113
104213: PUSH
104214: LD_INT 114
104216: PUSH
104217: LD_INT 116
104219: PUSH
104220: LD_INT 117
104222: PUSH
104223: LD_INT 118
104225: PUSH
104226: EMPTY
104227: LIST
104228: LIST
104229: LIST
104230: LIST
104231: LIST
104232: LIST
104233: LIST
104234: LIST
104235: LIST
104236: LIST
104237: LIST
104238: PUSH
104239: EMPTY
104240: LIST
104241: LIST
104242: ST_TO_ADDR
104243: GO 104874
104245: LD_INT 17
104247: DOUBLE
104248: EQUAL
104249: IFTRUE 104253
104251: GO 104477
104253: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
104254: LD_ADDR_VAR 0 2
104258: PUSH
104259: LD_INT 1
104261: PUSH
104262: LD_INT 2
104264: PUSH
104265: LD_INT 3
104267: PUSH
104268: LD_INT 4
104270: PUSH
104271: LD_INT 5
104273: PUSH
104274: LD_INT 6
104276: PUSH
104277: LD_INT 7
104279: PUSH
104280: LD_INT 8
104282: PUSH
104283: LD_INT 9
104285: PUSH
104286: LD_INT 10
104288: PUSH
104289: LD_INT 11
104291: PUSH
104292: LD_INT 12
104294: PUSH
104295: LD_INT 13
104297: PUSH
104298: LD_INT 14
104300: PUSH
104301: LD_INT 15
104303: PUSH
104304: LD_INT 16
104306: PUSH
104307: LD_INT 17
104309: PUSH
104310: LD_INT 18
104312: PUSH
104313: LD_INT 19
104315: PUSH
104316: LD_INT 20
104318: PUSH
104319: LD_INT 21
104321: PUSH
104322: LD_INT 22
104324: PUSH
104325: LD_INT 23
104327: PUSH
104328: LD_INT 24
104330: PUSH
104331: LD_INT 25
104333: PUSH
104334: LD_INT 26
104336: PUSH
104337: LD_INT 27
104339: PUSH
104340: LD_INT 28
104342: PUSH
104343: LD_INT 29
104345: PUSH
104346: LD_INT 30
104348: PUSH
104349: LD_INT 31
104351: PUSH
104352: LD_INT 32
104354: PUSH
104355: LD_INT 33
104357: PUSH
104358: LD_INT 34
104360: PUSH
104361: LD_INT 36
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: LIST
104368: LIST
104369: LIST
104370: LIST
104371: LIST
104372: LIST
104373: LIST
104374: LIST
104375: LIST
104376: LIST
104377: LIST
104378: LIST
104379: LIST
104380: LIST
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: LIST
104389: LIST
104390: LIST
104391: LIST
104392: LIST
104393: LIST
104394: LIST
104395: LIST
104396: LIST
104397: LIST
104398: LIST
104399: LIST
104400: PUSH
104401: LD_INT 101
104403: PUSH
104404: LD_INT 102
104406: PUSH
104407: LD_INT 103
104409: PUSH
104410: LD_INT 104
104412: PUSH
104413: LD_INT 105
104415: PUSH
104416: LD_INT 106
104418: PUSH
104419: LD_INT 107
104421: PUSH
104422: LD_INT 108
104424: PUSH
104425: LD_INT 109
104427: PUSH
104428: LD_INT 110
104430: PUSH
104431: LD_INT 111
104433: PUSH
104434: LD_INT 112
104436: PUSH
104437: LD_INT 113
104439: PUSH
104440: LD_INT 114
104442: PUSH
104443: LD_INT 116
104445: PUSH
104446: LD_INT 117
104448: PUSH
104449: LD_INT 118
104451: PUSH
104452: EMPTY
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: LIST
104462: LIST
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: LIST
104468: LIST
104469: LIST
104470: PUSH
104471: EMPTY
104472: LIST
104473: LIST
104474: ST_TO_ADDR
104475: GO 104874
104477: LD_INT 18
104479: DOUBLE
104480: EQUAL
104481: IFTRUE 104485
104483: GO 104633
104485: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
104486: LD_ADDR_VAR 0 2
104490: PUSH
104491: LD_INT 2
104493: PUSH
104494: LD_INT 4
104496: PUSH
104497: LD_INT 5
104499: PUSH
104500: LD_INT 7
104502: PUSH
104503: LD_INT 11
104505: PUSH
104506: LD_INT 12
104508: PUSH
104509: LD_INT 15
104511: PUSH
104512: LD_INT 16
104514: PUSH
104515: LD_INT 20
104517: PUSH
104518: LD_INT 21
104520: PUSH
104521: LD_INT 22
104523: PUSH
104524: LD_INT 23
104526: PUSH
104527: LD_INT 25
104529: PUSH
104530: LD_INT 26
104532: PUSH
104533: LD_INT 30
104535: PUSH
104536: LD_INT 31
104538: PUSH
104539: LD_INT 32
104541: PUSH
104542: LD_INT 33
104544: PUSH
104545: LD_INT 34
104547: PUSH
104548: LD_INT 35
104550: PUSH
104551: LD_INT 36
104553: PUSH
104554: EMPTY
104555: LIST
104556: LIST
104557: LIST
104558: LIST
104559: LIST
104560: LIST
104561: LIST
104562: LIST
104563: LIST
104564: LIST
104565: LIST
104566: LIST
104567: LIST
104568: LIST
104569: LIST
104570: LIST
104571: LIST
104572: LIST
104573: LIST
104574: LIST
104575: LIST
104576: PUSH
104577: LD_INT 101
104579: PUSH
104580: LD_INT 102
104582: PUSH
104583: LD_INT 103
104585: PUSH
104586: LD_INT 106
104588: PUSH
104589: LD_INT 108
104591: PUSH
104592: LD_INT 112
104594: PUSH
104595: LD_INT 113
104597: PUSH
104598: LD_INT 114
104600: PUSH
104601: LD_INT 115
104603: PUSH
104604: LD_INT 116
104606: PUSH
104607: LD_INT 117
104609: PUSH
104610: LD_INT 118
104612: PUSH
104613: EMPTY
104614: LIST
104615: LIST
104616: LIST
104617: LIST
104618: LIST
104619: LIST
104620: LIST
104621: LIST
104622: LIST
104623: LIST
104624: LIST
104625: LIST
104626: PUSH
104627: EMPTY
104628: LIST
104629: LIST
104630: ST_TO_ADDR
104631: GO 104874
104633: LD_INT 19
104635: DOUBLE
104636: EQUAL
104637: IFTRUE 104641
104639: GO 104873
104641: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
104642: LD_ADDR_VAR 0 2
104646: PUSH
104647: LD_INT 1
104649: PUSH
104650: LD_INT 2
104652: PUSH
104653: LD_INT 3
104655: PUSH
104656: LD_INT 4
104658: PUSH
104659: LD_INT 5
104661: PUSH
104662: LD_INT 6
104664: PUSH
104665: LD_INT 7
104667: PUSH
104668: LD_INT 8
104670: PUSH
104671: LD_INT 9
104673: PUSH
104674: LD_INT 10
104676: PUSH
104677: LD_INT 11
104679: PUSH
104680: LD_INT 12
104682: PUSH
104683: LD_INT 13
104685: PUSH
104686: LD_INT 14
104688: PUSH
104689: LD_INT 15
104691: PUSH
104692: LD_INT 16
104694: PUSH
104695: LD_INT 17
104697: PUSH
104698: LD_INT 18
104700: PUSH
104701: LD_INT 19
104703: PUSH
104704: LD_INT 20
104706: PUSH
104707: LD_INT 21
104709: PUSH
104710: LD_INT 22
104712: PUSH
104713: LD_INT 23
104715: PUSH
104716: LD_INT 24
104718: PUSH
104719: LD_INT 25
104721: PUSH
104722: LD_INT 26
104724: PUSH
104725: LD_INT 27
104727: PUSH
104728: LD_INT 28
104730: PUSH
104731: LD_INT 29
104733: PUSH
104734: LD_INT 30
104736: PUSH
104737: LD_INT 31
104739: PUSH
104740: LD_INT 32
104742: PUSH
104743: LD_INT 33
104745: PUSH
104746: LD_INT 34
104748: PUSH
104749: LD_INT 35
104751: PUSH
104752: LD_INT 36
104754: PUSH
104755: EMPTY
104756: LIST
104757: LIST
104758: LIST
104759: LIST
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: LIST
104779: LIST
104780: LIST
104781: LIST
104782: LIST
104783: LIST
104784: LIST
104785: LIST
104786: LIST
104787: LIST
104788: LIST
104789: LIST
104790: LIST
104791: LIST
104792: PUSH
104793: LD_INT 101
104795: PUSH
104796: LD_INT 102
104798: PUSH
104799: LD_INT 103
104801: PUSH
104802: LD_INT 104
104804: PUSH
104805: LD_INT 105
104807: PUSH
104808: LD_INT 106
104810: PUSH
104811: LD_INT 107
104813: PUSH
104814: LD_INT 108
104816: PUSH
104817: LD_INT 109
104819: PUSH
104820: LD_INT 110
104822: PUSH
104823: LD_INT 111
104825: PUSH
104826: LD_INT 112
104828: PUSH
104829: LD_INT 113
104831: PUSH
104832: LD_INT 114
104834: PUSH
104835: LD_INT 115
104837: PUSH
104838: LD_INT 116
104840: PUSH
104841: LD_INT 117
104843: PUSH
104844: LD_INT 118
104846: PUSH
104847: EMPTY
104848: LIST
104849: LIST
104850: LIST
104851: LIST
104852: LIST
104853: LIST
104854: LIST
104855: LIST
104856: LIST
104857: LIST
104858: LIST
104859: LIST
104860: LIST
104861: LIST
104862: LIST
104863: LIST
104864: LIST
104865: LIST
104866: PUSH
104867: EMPTY
104868: LIST
104869: LIST
104870: ST_TO_ADDR
104871: GO 104874
104873: POP
// end else
104874: GO 105105
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
104876: LD_ADDR_VAR 0 2
104880: PUSH
104881: LD_INT 1
104883: PUSH
104884: LD_INT 2
104886: PUSH
104887: LD_INT 3
104889: PUSH
104890: LD_INT 4
104892: PUSH
104893: LD_INT 5
104895: PUSH
104896: LD_INT 6
104898: PUSH
104899: LD_INT 7
104901: PUSH
104902: LD_INT 8
104904: PUSH
104905: LD_INT 9
104907: PUSH
104908: LD_INT 10
104910: PUSH
104911: LD_INT 11
104913: PUSH
104914: LD_INT 12
104916: PUSH
104917: LD_INT 13
104919: PUSH
104920: LD_INT 14
104922: PUSH
104923: LD_INT 15
104925: PUSH
104926: LD_INT 16
104928: PUSH
104929: LD_INT 17
104931: PUSH
104932: LD_INT 18
104934: PUSH
104935: LD_INT 19
104937: PUSH
104938: LD_INT 20
104940: PUSH
104941: LD_INT 21
104943: PUSH
104944: LD_INT 22
104946: PUSH
104947: LD_INT 23
104949: PUSH
104950: LD_INT 24
104952: PUSH
104953: LD_INT 25
104955: PUSH
104956: LD_INT 26
104958: PUSH
104959: LD_INT 27
104961: PUSH
104962: LD_INT 28
104964: PUSH
104965: LD_INT 29
104967: PUSH
104968: LD_INT 30
104970: PUSH
104971: LD_INT 31
104973: PUSH
104974: LD_INT 32
104976: PUSH
104977: LD_INT 33
104979: PUSH
104980: LD_INT 34
104982: PUSH
104983: LD_INT 35
104985: PUSH
104986: LD_INT 36
104988: PUSH
104989: EMPTY
104990: LIST
104991: LIST
104992: LIST
104993: LIST
104994: LIST
104995: LIST
104996: LIST
104997: LIST
104998: LIST
104999: LIST
105000: LIST
105001: LIST
105002: LIST
105003: LIST
105004: LIST
105005: LIST
105006: LIST
105007: LIST
105008: LIST
105009: LIST
105010: LIST
105011: LIST
105012: LIST
105013: LIST
105014: LIST
105015: LIST
105016: LIST
105017: LIST
105018: LIST
105019: LIST
105020: LIST
105021: LIST
105022: LIST
105023: LIST
105024: LIST
105025: LIST
105026: PUSH
105027: LD_INT 101
105029: PUSH
105030: LD_INT 102
105032: PUSH
105033: LD_INT 103
105035: PUSH
105036: LD_INT 104
105038: PUSH
105039: LD_INT 105
105041: PUSH
105042: LD_INT 106
105044: PUSH
105045: LD_INT 107
105047: PUSH
105048: LD_INT 108
105050: PUSH
105051: LD_INT 109
105053: PUSH
105054: LD_INT 110
105056: PUSH
105057: LD_INT 111
105059: PUSH
105060: LD_INT 112
105062: PUSH
105063: LD_INT 113
105065: PUSH
105066: LD_INT 114
105068: PUSH
105069: LD_INT 115
105071: PUSH
105072: LD_INT 116
105074: PUSH
105075: LD_INT 117
105077: PUSH
105078: LD_INT 118
105080: PUSH
105081: EMPTY
105082: LIST
105083: LIST
105084: LIST
105085: LIST
105086: LIST
105087: LIST
105088: LIST
105089: LIST
105090: LIST
105091: LIST
105092: LIST
105093: LIST
105094: LIST
105095: LIST
105096: LIST
105097: LIST
105098: LIST
105099: LIST
105100: PUSH
105101: EMPTY
105102: LIST
105103: LIST
105104: ST_TO_ADDR
// if result then
105105: LD_VAR 0 2
105109: IFFALSE 105895
// begin normal :=  ;
105111: LD_ADDR_VAR 0 5
105115: PUSH
105116: LD_STRING 
105118: ST_TO_ADDR
// hardcore :=  ;
105119: LD_ADDR_VAR 0 6
105123: PUSH
105124: LD_STRING 
105126: ST_TO_ADDR
// active :=  ;
105127: LD_ADDR_VAR 0 7
105131: PUSH
105132: LD_STRING 
105134: ST_TO_ADDR
// for i = 1 to normalCounter do
105135: LD_ADDR_VAR 0 8
105139: PUSH
105140: DOUBLE
105141: LD_INT 1
105143: DEC
105144: ST_TO_ADDR
105145: LD_EXP 80
105149: PUSH
105150: FOR_TO
105151: IFFALSE 105252
// begin tmp := 0 ;
105153: LD_ADDR_VAR 0 3
105157: PUSH
105158: LD_STRING 0
105160: ST_TO_ADDR
// if result [ 1 ] then
105161: LD_VAR 0 2
105165: PUSH
105166: LD_INT 1
105168: ARRAY
105169: IFFALSE 105234
// if result [ 1 ] [ 1 ] = i then
105171: LD_VAR 0 2
105175: PUSH
105176: LD_INT 1
105178: ARRAY
105179: PUSH
105180: LD_INT 1
105182: ARRAY
105183: PUSH
105184: LD_VAR 0 8
105188: EQUAL
105189: IFFALSE 105234
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
105191: LD_ADDR_VAR 0 2
105195: PUSH
105196: LD_VAR 0 2
105200: PPUSH
105201: LD_INT 1
105203: PPUSH
105204: LD_VAR 0 2
105208: PUSH
105209: LD_INT 1
105211: ARRAY
105212: PPUSH
105213: LD_INT 1
105215: PPUSH
105216: CALL_OW 3
105220: PPUSH
105221: CALL_OW 1
105225: ST_TO_ADDR
// tmp := 1 ;
105226: LD_ADDR_VAR 0 3
105230: PUSH
105231: LD_STRING 1
105233: ST_TO_ADDR
// end ; normal := normal & tmp ;
105234: LD_ADDR_VAR 0 5
105238: PUSH
105239: LD_VAR 0 5
105243: PUSH
105244: LD_VAR 0 3
105248: STR
105249: ST_TO_ADDR
// end ;
105250: GO 105150
105252: POP
105253: POP
// for i = 1 to hardcoreCounter do
105254: LD_ADDR_VAR 0 8
105258: PUSH
105259: DOUBLE
105260: LD_INT 1
105262: DEC
105263: ST_TO_ADDR
105264: LD_EXP 81
105268: PUSH
105269: FOR_TO
105270: IFFALSE 105375
// begin tmp := 0 ;
105272: LD_ADDR_VAR 0 3
105276: PUSH
105277: LD_STRING 0
105279: ST_TO_ADDR
// if result [ 2 ] then
105280: LD_VAR 0 2
105284: PUSH
105285: LD_INT 2
105287: ARRAY
105288: IFFALSE 105357
// if result [ 2 ] [ 1 ] = 100 + i then
105290: LD_VAR 0 2
105294: PUSH
105295: LD_INT 2
105297: ARRAY
105298: PUSH
105299: LD_INT 1
105301: ARRAY
105302: PUSH
105303: LD_INT 100
105305: PUSH
105306: LD_VAR 0 8
105310: PLUS
105311: EQUAL
105312: IFFALSE 105357
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
105314: LD_ADDR_VAR 0 2
105318: PUSH
105319: LD_VAR 0 2
105323: PPUSH
105324: LD_INT 2
105326: PPUSH
105327: LD_VAR 0 2
105331: PUSH
105332: LD_INT 2
105334: ARRAY
105335: PPUSH
105336: LD_INT 1
105338: PPUSH
105339: CALL_OW 3
105343: PPUSH
105344: CALL_OW 1
105348: ST_TO_ADDR
// tmp := 1 ;
105349: LD_ADDR_VAR 0 3
105353: PUSH
105354: LD_STRING 1
105356: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105357: LD_ADDR_VAR 0 6
105361: PUSH
105362: LD_VAR 0 6
105366: PUSH
105367: LD_VAR 0 3
105371: STR
105372: ST_TO_ADDR
// end ;
105373: GO 105269
105375: POP
105376: POP
// if isGameLoad then
105377: LD_VAR 0 1
105381: IFFALSE 105856
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
105383: LD_ADDR_VAR 0 4
105387: PUSH
105388: LD_EXP 84
105392: PUSH
105393: LD_EXP 83
105397: PUSH
105398: LD_EXP 85
105402: PUSH
105403: LD_EXP 82
105407: PUSH
105408: LD_EXP 86
105412: PUSH
105413: LD_EXP 87
105417: PUSH
105418: LD_EXP 88
105422: PUSH
105423: LD_EXP 89
105427: PUSH
105428: LD_EXP 90
105432: PUSH
105433: LD_EXP 91
105437: PUSH
105438: LD_EXP 92
105442: PUSH
105443: LD_EXP 93
105447: PUSH
105448: LD_EXP 94
105452: PUSH
105453: LD_EXP 95
105457: PUSH
105458: LD_EXP 103
105462: PUSH
105463: LD_EXP 104
105467: PUSH
105468: LD_EXP 105
105472: PUSH
105473: LD_EXP 106
105477: PUSH
105478: LD_EXP 108
105482: PUSH
105483: LD_EXP 109
105487: PUSH
105488: LD_EXP 110
105492: PUSH
105493: LD_EXP 113
105497: PUSH
105498: LD_EXP 115
105502: PUSH
105503: LD_EXP 116
105507: PUSH
105508: LD_EXP 117
105512: PUSH
105513: LD_EXP 119
105517: PUSH
105518: LD_EXP 120
105522: PUSH
105523: LD_EXP 123
105527: PUSH
105528: LD_EXP 124
105532: PUSH
105533: LD_EXP 125
105537: PUSH
105538: LD_EXP 126
105542: PUSH
105543: LD_EXP 127
105547: PUSH
105548: LD_EXP 128
105552: PUSH
105553: LD_EXP 129
105557: PUSH
105558: LD_EXP 130
105562: PUSH
105563: LD_EXP 131
105567: PUSH
105568: LD_EXP 96
105572: PUSH
105573: LD_EXP 97
105577: PUSH
105578: LD_EXP 100
105582: PUSH
105583: LD_EXP 101
105587: PUSH
105588: LD_EXP 102
105592: PUSH
105593: LD_EXP 98
105597: PUSH
105598: LD_EXP 99
105602: PUSH
105603: LD_EXP 107
105607: PUSH
105608: LD_EXP 111
105612: PUSH
105613: LD_EXP 112
105617: PUSH
105618: LD_EXP 114
105622: PUSH
105623: LD_EXP 118
105627: PUSH
105628: LD_EXP 121
105632: PUSH
105633: LD_EXP 122
105637: PUSH
105638: LD_EXP 132
105642: PUSH
105643: LD_EXP 133
105647: PUSH
105648: LD_EXP 134
105652: PUSH
105653: LD_EXP 135
105657: PUSH
105658: EMPTY
105659: LIST
105660: LIST
105661: LIST
105662: LIST
105663: LIST
105664: LIST
105665: LIST
105666: LIST
105667: LIST
105668: LIST
105669: LIST
105670: LIST
105671: LIST
105672: LIST
105673: LIST
105674: LIST
105675: LIST
105676: LIST
105677: LIST
105678: LIST
105679: LIST
105680: LIST
105681: LIST
105682: LIST
105683: LIST
105684: LIST
105685: LIST
105686: LIST
105687: LIST
105688: LIST
105689: LIST
105690: LIST
105691: LIST
105692: LIST
105693: LIST
105694: LIST
105695: LIST
105696: LIST
105697: LIST
105698: LIST
105699: LIST
105700: LIST
105701: LIST
105702: LIST
105703: LIST
105704: LIST
105705: LIST
105706: LIST
105707: LIST
105708: LIST
105709: LIST
105710: LIST
105711: LIST
105712: LIST
105713: ST_TO_ADDR
// tmp :=  ;
105714: LD_ADDR_VAR 0 3
105718: PUSH
105719: LD_STRING 
105721: ST_TO_ADDR
// for i = 1 to normalCounter do
105722: LD_ADDR_VAR 0 8
105726: PUSH
105727: DOUBLE
105728: LD_INT 1
105730: DEC
105731: ST_TO_ADDR
105732: LD_EXP 80
105736: PUSH
105737: FOR_TO
105738: IFFALSE 105774
// begin if flags [ i ] then
105740: LD_VAR 0 4
105744: PUSH
105745: LD_VAR 0 8
105749: ARRAY
105750: IFFALSE 105772
// tmp := tmp & i & ; ;
105752: LD_ADDR_VAR 0 3
105756: PUSH
105757: LD_VAR 0 3
105761: PUSH
105762: LD_VAR 0 8
105766: STR
105767: PUSH
105768: LD_STRING ;
105770: STR
105771: ST_TO_ADDR
// end ;
105772: GO 105737
105774: POP
105775: POP
// for i = 1 to hardcoreCounter do
105776: LD_ADDR_VAR 0 8
105780: PUSH
105781: DOUBLE
105782: LD_INT 1
105784: DEC
105785: ST_TO_ADDR
105786: LD_EXP 81
105790: PUSH
105791: FOR_TO
105792: IFFALSE 105838
// begin if flags [ normalCounter + i ] then
105794: LD_VAR 0 4
105798: PUSH
105799: LD_EXP 80
105803: PUSH
105804: LD_VAR 0 8
105808: PLUS
105809: ARRAY
105810: IFFALSE 105836
// tmp := tmp & ( 100 + i ) & ; ;
105812: LD_ADDR_VAR 0 3
105816: PUSH
105817: LD_VAR 0 3
105821: PUSH
105822: LD_INT 100
105824: PUSH
105825: LD_VAR 0 8
105829: PLUS
105830: STR
105831: PUSH
105832: LD_STRING ;
105834: STR
105835: ST_TO_ADDR
// end ;
105836: GO 105791
105838: POP
105839: POP
// if tmp then
105840: LD_VAR 0 3
105844: IFFALSE 105856
// active := tmp ;
105846: LD_ADDR_VAR 0 7
105850: PUSH
105851: LD_VAR 0 3
105855: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
105856: LD_STRING getStreamItemsFromMission("
105858: PUSH
105859: LD_VAR 0 5
105863: STR
105864: PUSH
105865: LD_STRING ","
105867: STR
105868: PUSH
105869: LD_VAR 0 6
105873: STR
105874: PUSH
105875: LD_STRING ","
105877: STR
105878: PUSH
105879: LD_VAR 0 7
105883: STR
105884: PUSH
105885: LD_STRING ")
105887: STR
105888: PPUSH
105889: CALL_OW 559
// end else
105893: GO 105902
// ToLua ( getStreamItemsFromMission("","","") ) ;
105895: LD_STRING getStreamItemsFromMission("","","")
105897: PPUSH
105898: CALL_OW 559
// end ;
105902: LD_VAR 0 2
105906: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
105907: LD_EXP 79
105911: IFFALSE 105919
105913: PUSH
105914: LD_EXP 84
105918: AND
105919: IFFALSE 106043
105921: GO 105923
105923: DISABLE
105924: LD_INT 0
105926: PPUSH
105927: PPUSH
// begin enable ;
105928: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
105929: LD_ADDR_VAR 0 2
105933: PUSH
105934: LD_INT 22
105936: PUSH
105937: LD_OWVAR 2
105941: PUSH
105942: EMPTY
105943: LIST
105944: LIST
105945: PUSH
105946: LD_INT 2
105948: PUSH
105949: LD_INT 34
105951: PUSH
105952: LD_INT 7
105954: PUSH
105955: EMPTY
105956: LIST
105957: LIST
105958: PUSH
105959: LD_INT 34
105961: PUSH
105962: LD_INT 45
105964: PUSH
105965: EMPTY
105966: LIST
105967: LIST
105968: PUSH
105969: LD_INT 34
105971: PUSH
105972: LD_INT 28
105974: PUSH
105975: EMPTY
105976: LIST
105977: LIST
105978: PUSH
105979: LD_INT 34
105981: PUSH
105982: LD_INT 47
105984: PUSH
105985: EMPTY
105986: LIST
105987: LIST
105988: PUSH
105989: EMPTY
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: LIST
105995: PUSH
105996: EMPTY
105997: LIST
105998: LIST
105999: PPUSH
106000: CALL_OW 69
106004: ST_TO_ADDR
// if not tmp then
106005: LD_VAR 0 2
106009: NOT
106010: IFFALSE 106014
// exit ;
106012: GO 106043
// for i in tmp do
106014: LD_ADDR_VAR 0 1
106018: PUSH
106019: LD_VAR 0 2
106023: PUSH
106024: FOR_IN
106025: IFFALSE 106041
// begin SetLives ( i , 0 ) ;
106027: LD_VAR 0 1
106031: PPUSH
106032: LD_INT 0
106034: PPUSH
106035: CALL_OW 234
// end ;
106039: GO 106024
106041: POP
106042: POP
// end ;
106043: PPOPN 2
106045: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
106046: LD_EXP 79
106050: IFFALSE 106058
106052: PUSH
106053: LD_EXP 85
106057: AND
106058: IFFALSE 106142
106060: GO 106062
106062: DISABLE
106063: LD_INT 0
106065: PPUSH
106066: PPUSH
// begin enable ;
106067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
106068: LD_ADDR_VAR 0 2
106072: PUSH
106073: LD_INT 22
106075: PUSH
106076: LD_OWVAR 2
106080: PUSH
106081: EMPTY
106082: LIST
106083: LIST
106084: PUSH
106085: LD_INT 32
106087: PUSH
106088: LD_INT 3
106090: PUSH
106091: EMPTY
106092: LIST
106093: LIST
106094: PUSH
106095: EMPTY
106096: LIST
106097: LIST
106098: PPUSH
106099: CALL_OW 69
106103: ST_TO_ADDR
// if not tmp then
106104: LD_VAR 0 2
106108: NOT
106109: IFFALSE 106113
// exit ;
106111: GO 106142
// for i in tmp do
106113: LD_ADDR_VAR 0 1
106117: PUSH
106118: LD_VAR 0 2
106122: PUSH
106123: FOR_IN
106124: IFFALSE 106140
// begin SetLives ( i , 0 ) ;
106126: LD_VAR 0 1
106130: PPUSH
106131: LD_INT 0
106133: PPUSH
106134: CALL_OW 234
// end ;
106138: GO 106123
106140: POP
106141: POP
// end ;
106142: PPOPN 2
106144: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
106145: LD_EXP 79
106149: IFFALSE 106157
106151: PUSH
106152: LD_EXP 82
106156: AND
106157: IFFALSE 106250
106159: GO 106161
106161: DISABLE
106162: LD_INT 0
106164: PPUSH
// begin enable ;
106165: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
106166: LD_ADDR_VAR 0 1
106170: PUSH
106171: LD_INT 22
106173: PUSH
106174: LD_OWVAR 2
106178: PUSH
106179: EMPTY
106180: LIST
106181: LIST
106182: PUSH
106183: LD_INT 2
106185: PUSH
106186: LD_INT 25
106188: PUSH
106189: LD_INT 5
106191: PUSH
106192: EMPTY
106193: LIST
106194: LIST
106195: PUSH
106196: LD_INT 25
106198: PUSH
106199: LD_INT 9
106201: PUSH
106202: EMPTY
106203: LIST
106204: LIST
106205: PUSH
106206: LD_INT 25
106208: PUSH
106209: LD_INT 8
106211: PUSH
106212: EMPTY
106213: LIST
106214: LIST
106215: PUSH
106216: EMPTY
106217: LIST
106218: LIST
106219: LIST
106220: LIST
106221: PUSH
106222: EMPTY
106223: LIST
106224: LIST
106225: PPUSH
106226: CALL_OW 69
106230: PUSH
106231: FOR_IN
106232: IFFALSE 106248
// begin SetClass ( i , 1 ) ;
106234: LD_VAR 0 1
106238: PPUSH
106239: LD_INT 1
106241: PPUSH
106242: CALL_OW 336
// end ;
106246: GO 106231
106248: POP
106249: POP
// end ;
106250: PPOPN 1
106252: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
106253: LD_EXP 79
106257: IFFALSE 106265
106259: PUSH
106260: LD_EXP 83
106264: AND
106265: IFFALSE 106277
106267: PUSH
106268: LD_OWVAR 65
106272: PUSH
106273: LD_INT 7
106275: LESS
106276: AND
106277: IFFALSE 106291
106279: GO 106281
106281: DISABLE
// begin enable ;
106282: ENABLE
// game_speed := 7 ;
106283: LD_ADDR_OWVAR 65
106287: PUSH
106288: LD_INT 7
106290: ST_TO_ADDR
// end ;
106291: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
106292: LD_EXP 79
106296: IFFALSE 106304
106298: PUSH
106299: LD_EXP 86
106303: AND
106304: IFFALSE 106506
106306: GO 106308
106308: DISABLE
106309: LD_INT 0
106311: PPUSH
106312: PPUSH
106313: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
106314: LD_ADDR_VAR 0 3
106318: PUSH
106319: LD_INT 81
106321: PUSH
106322: LD_OWVAR 2
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: PUSH
106331: LD_INT 21
106333: PUSH
106334: LD_INT 1
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: PUSH
106341: EMPTY
106342: LIST
106343: LIST
106344: PPUSH
106345: CALL_OW 69
106349: ST_TO_ADDR
// if not tmp then
106350: LD_VAR 0 3
106354: NOT
106355: IFFALSE 106359
// exit ;
106357: GO 106506
// if tmp > 5 then
106359: LD_VAR 0 3
106363: PUSH
106364: LD_INT 5
106366: GREATER
106367: IFFALSE 106379
// k := 5 else
106369: LD_ADDR_VAR 0 2
106373: PUSH
106374: LD_INT 5
106376: ST_TO_ADDR
106377: GO 106389
// k := tmp ;
106379: LD_ADDR_VAR 0 2
106383: PUSH
106384: LD_VAR 0 3
106388: ST_TO_ADDR
// for i := 1 to k do
106389: LD_ADDR_VAR 0 1
106393: PUSH
106394: DOUBLE
106395: LD_INT 1
106397: DEC
106398: ST_TO_ADDR
106399: LD_VAR 0 2
106403: PUSH
106404: FOR_TO
106405: IFFALSE 106504
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106407: LD_VAR 0 3
106411: PUSH
106412: LD_VAR 0 1
106416: ARRAY
106417: PPUSH
106418: LD_VAR 0 1
106422: PUSH
106423: LD_INT 4
106425: MOD
106426: PUSH
106427: LD_INT 1
106429: PLUS
106430: PPUSH
106431: CALL_OW 259
106435: PUSH
106436: LD_INT 10
106438: LESS
106439: IFFALSE 106502
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106441: LD_VAR 0 3
106445: PUSH
106446: LD_VAR 0 1
106450: ARRAY
106451: PPUSH
106452: LD_VAR 0 1
106456: PUSH
106457: LD_INT 4
106459: MOD
106460: PUSH
106461: LD_INT 1
106463: PLUS
106464: PPUSH
106465: LD_VAR 0 3
106469: PUSH
106470: LD_VAR 0 1
106474: ARRAY
106475: PPUSH
106476: LD_VAR 0 1
106480: PUSH
106481: LD_INT 4
106483: MOD
106484: PUSH
106485: LD_INT 1
106487: PLUS
106488: PPUSH
106489: CALL_OW 259
106493: PUSH
106494: LD_INT 1
106496: PLUS
106497: PPUSH
106498: CALL_OW 237
106502: GO 106404
106504: POP
106505: POP
// end ;
106506: PPOPN 3
106508: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106509: LD_EXP 79
106513: IFFALSE 106521
106515: PUSH
106516: LD_EXP 87
106520: AND
106521: IFFALSE 106541
106523: GO 106525
106525: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106526: LD_INT 4
106528: PPUSH
106529: LD_OWVAR 2
106533: PPUSH
106534: LD_INT 0
106536: PPUSH
106537: CALL_OW 324
106541: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106542: LD_EXP 79
106546: IFFALSE 106554
106548: PUSH
106549: LD_EXP 116
106553: AND
106554: IFFALSE 106574
106556: GO 106558
106558: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106559: LD_INT 19
106561: PPUSH
106562: LD_OWVAR 2
106566: PPUSH
106567: LD_INT 0
106569: PPUSH
106570: CALL_OW 324
106574: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106575: LD_EXP 79
106579: IFFALSE 106587
106581: PUSH
106582: LD_EXP 88
106586: AND
106587: IFFALSE 106689
106589: GO 106591
106591: DISABLE
106592: LD_INT 0
106594: PPUSH
106595: PPUSH
// begin enable ;
106596: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
106597: LD_ADDR_VAR 0 2
106601: PUSH
106602: LD_INT 22
106604: PUSH
106605: LD_OWVAR 2
106609: PUSH
106610: EMPTY
106611: LIST
106612: LIST
106613: PUSH
106614: LD_INT 2
106616: PUSH
106617: LD_INT 34
106619: PUSH
106620: LD_INT 11
106622: PUSH
106623: EMPTY
106624: LIST
106625: LIST
106626: PUSH
106627: LD_INT 34
106629: PUSH
106630: LD_INT 30
106632: PUSH
106633: EMPTY
106634: LIST
106635: LIST
106636: PUSH
106637: EMPTY
106638: LIST
106639: LIST
106640: LIST
106641: PUSH
106642: EMPTY
106643: LIST
106644: LIST
106645: PPUSH
106646: CALL_OW 69
106650: ST_TO_ADDR
// if not tmp then
106651: LD_VAR 0 2
106655: NOT
106656: IFFALSE 106660
// exit ;
106658: GO 106689
// for i in tmp do
106660: LD_ADDR_VAR 0 1
106664: PUSH
106665: LD_VAR 0 2
106669: PUSH
106670: FOR_IN
106671: IFFALSE 106687
// begin SetLives ( i , 0 ) ;
106673: LD_VAR 0 1
106677: PPUSH
106678: LD_INT 0
106680: PPUSH
106681: CALL_OW 234
// end ;
106685: GO 106670
106687: POP
106688: POP
// end ;
106689: PPOPN 2
106691: END
// every 0 0$1 trigger StreamModeActive and sBunker do
106692: LD_EXP 79
106696: IFFALSE 106704
106698: PUSH
106699: LD_EXP 89
106703: AND
106704: IFFALSE 106724
106706: GO 106708
106708: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
106709: LD_INT 32
106711: PPUSH
106712: LD_OWVAR 2
106716: PPUSH
106717: LD_INT 0
106719: PPUSH
106720: CALL_OW 324
106724: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
106725: LD_EXP 79
106729: IFFALSE 106737
106731: PUSH
106732: LD_EXP 90
106736: AND
106737: IFFALSE 106920
106739: GO 106741
106741: DISABLE
106742: LD_INT 0
106744: PPUSH
106745: PPUSH
106746: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
106747: LD_ADDR_VAR 0 2
106751: PUSH
106752: LD_INT 22
106754: PUSH
106755: LD_OWVAR 2
106759: PUSH
106760: EMPTY
106761: LIST
106762: LIST
106763: PUSH
106764: LD_INT 33
106766: PUSH
106767: LD_INT 3
106769: PUSH
106770: EMPTY
106771: LIST
106772: LIST
106773: PUSH
106774: EMPTY
106775: LIST
106776: LIST
106777: PPUSH
106778: CALL_OW 69
106782: ST_TO_ADDR
// if not tmp then
106783: LD_VAR 0 2
106787: NOT
106788: IFFALSE 106792
// exit ;
106790: GO 106920
// side := 0 ;
106792: LD_ADDR_VAR 0 3
106796: PUSH
106797: LD_INT 0
106799: ST_TO_ADDR
// for i := 1 to 8 do
106800: LD_ADDR_VAR 0 1
106804: PUSH
106805: DOUBLE
106806: LD_INT 1
106808: DEC
106809: ST_TO_ADDR
106810: LD_INT 8
106812: PUSH
106813: FOR_TO
106814: IFFALSE 106864
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
106816: LD_OWVAR 2
106820: PUSH
106821: LD_VAR 0 1
106825: NONEQUAL
106826: IFFALSE 106848
106828: PUSH
106829: LD_OWVAR 2
106833: PPUSH
106834: LD_VAR 0 1
106838: PPUSH
106839: CALL_OW 81
106843: PUSH
106844: LD_INT 2
106846: EQUAL
106847: AND
106848: IFFALSE 106862
// begin side := i ;
106850: LD_ADDR_VAR 0 3
106854: PUSH
106855: LD_VAR 0 1
106859: ST_TO_ADDR
// break ;
106860: GO 106864
// end ;
106862: GO 106813
106864: POP
106865: POP
// if not side then
106866: LD_VAR 0 3
106870: NOT
106871: IFFALSE 106875
// exit ;
106873: GO 106920
// for i := 1 to tmp do
106875: LD_ADDR_VAR 0 1
106879: PUSH
106880: DOUBLE
106881: LD_INT 1
106883: DEC
106884: ST_TO_ADDR
106885: LD_VAR 0 2
106889: PUSH
106890: FOR_TO
106891: IFFALSE 106918
// if Prob ( 60 ) then
106893: LD_INT 60
106895: PPUSH
106896: CALL_OW 13
106900: IFFALSE 106916
// SetSide ( i , side ) ;
106902: LD_VAR 0 1
106906: PPUSH
106907: LD_VAR 0 3
106911: PPUSH
106912: CALL_OW 235
106916: GO 106890
106918: POP
106919: POP
// end ;
106920: PPOPN 3
106922: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
106923: LD_EXP 79
106927: IFFALSE 106935
106929: PUSH
106930: LD_EXP 92
106934: AND
106935: IFFALSE 107054
106937: GO 106939
106939: DISABLE
106940: LD_INT 0
106942: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
106943: LD_ADDR_VAR 0 1
106947: PUSH
106948: LD_INT 22
106950: PUSH
106951: LD_OWVAR 2
106955: PUSH
106956: EMPTY
106957: LIST
106958: LIST
106959: PUSH
106960: LD_INT 21
106962: PUSH
106963: LD_INT 1
106965: PUSH
106966: EMPTY
106967: LIST
106968: LIST
106969: PUSH
106970: LD_INT 3
106972: PUSH
106973: LD_INT 23
106975: PUSH
106976: LD_INT 0
106978: PUSH
106979: EMPTY
106980: LIST
106981: LIST
106982: PUSH
106983: EMPTY
106984: LIST
106985: LIST
106986: PUSH
106987: EMPTY
106988: LIST
106989: LIST
106990: LIST
106991: PPUSH
106992: CALL_OW 69
106996: PUSH
106997: FOR_IN
106998: IFFALSE 107052
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
107000: LD_VAR 0 1
107004: PPUSH
107005: CALL_OW 257
107009: PUSH
107010: LD_INT 1
107012: PUSH
107013: LD_INT 2
107015: PUSH
107016: LD_INT 3
107018: PUSH
107019: LD_INT 4
107021: PUSH
107022: EMPTY
107023: LIST
107024: LIST
107025: LIST
107026: LIST
107027: IN
107028: IFFALSE 107050
// SetClass ( un , rand ( 1 , 4 ) ) ;
107030: LD_VAR 0 1
107034: PPUSH
107035: LD_INT 1
107037: PPUSH
107038: LD_INT 4
107040: PPUSH
107041: CALL_OW 12
107045: PPUSH
107046: CALL_OW 336
107050: GO 106997
107052: POP
107053: POP
// end ;
107054: PPOPN 1
107056: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
107057: LD_EXP 79
107061: IFFALSE 107069
107063: PUSH
107064: LD_EXP 91
107068: AND
107069: IFFALSE 107148
107071: GO 107073
107073: DISABLE
107074: LD_INT 0
107076: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107077: LD_ADDR_VAR 0 1
107081: PUSH
107082: LD_INT 22
107084: PUSH
107085: LD_OWVAR 2
107089: PUSH
107090: EMPTY
107091: LIST
107092: LIST
107093: PUSH
107094: LD_INT 21
107096: PUSH
107097: LD_INT 3
107099: PUSH
107100: EMPTY
107101: LIST
107102: LIST
107103: PUSH
107104: EMPTY
107105: LIST
107106: LIST
107107: PPUSH
107108: CALL_OW 69
107112: ST_TO_ADDR
// if not tmp then
107113: LD_VAR 0 1
107117: NOT
107118: IFFALSE 107122
// exit ;
107120: GO 107148
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
107122: LD_VAR 0 1
107126: PUSH
107127: LD_INT 1
107129: PPUSH
107130: LD_VAR 0 1
107134: PPUSH
107135: CALL_OW 12
107139: ARRAY
107140: PPUSH
107141: LD_INT 100
107143: PPUSH
107144: CALL_OW 234
// end ;
107148: PPOPN 1
107150: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
107151: LD_EXP 79
107155: IFFALSE 107163
107157: PUSH
107158: LD_EXP 93
107162: AND
107163: IFFALSE 107261
107165: GO 107167
107167: DISABLE
107168: LD_INT 0
107170: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
107171: LD_ADDR_VAR 0 1
107175: PUSH
107176: LD_INT 22
107178: PUSH
107179: LD_OWVAR 2
107183: PUSH
107184: EMPTY
107185: LIST
107186: LIST
107187: PUSH
107188: LD_INT 21
107190: PUSH
107191: LD_INT 1
107193: PUSH
107194: EMPTY
107195: LIST
107196: LIST
107197: PUSH
107198: EMPTY
107199: LIST
107200: LIST
107201: PPUSH
107202: CALL_OW 69
107206: ST_TO_ADDR
// if not tmp then
107207: LD_VAR 0 1
107211: NOT
107212: IFFALSE 107216
// exit ;
107214: GO 107261
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
107216: LD_VAR 0 1
107220: PUSH
107221: LD_INT 1
107223: PPUSH
107224: LD_VAR 0 1
107228: PPUSH
107229: CALL_OW 12
107233: ARRAY
107234: PPUSH
107235: LD_INT 1
107237: PPUSH
107238: LD_INT 4
107240: PPUSH
107241: CALL_OW 12
107245: PPUSH
107246: LD_INT 3000
107248: PPUSH
107249: LD_INT 9000
107251: PPUSH
107252: CALL_OW 12
107256: PPUSH
107257: CALL_OW 492
// end ;
107261: PPOPN 1
107263: END
// every 0 0$1 trigger StreamModeActive and sDepot do
107264: LD_EXP 79
107268: IFFALSE 107276
107270: PUSH
107271: LD_EXP 94
107275: AND
107276: IFFALSE 107296
107278: GO 107280
107280: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
107281: LD_INT 1
107283: PPUSH
107284: LD_OWVAR 2
107288: PPUSH
107289: LD_INT 0
107291: PPUSH
107292: CALL_OW 324
107296: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
107297: LD_EXP 79
107301: IFFALSE 107309
107303: PUSH
107304: LD_EXP 95
107308: AND
107309: IFFALSE 107392
107311: GO 107313
107313: DISABLE
107314: LD_INT 0
107316: PPUSH
107317: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
107318: LD_ADDR_VAR 0 2
107322: PUSH
107323: LD_INT 22
107325: PUSH
107326: LD_OWVAR 2
107330: PUSH
107331: EMPTY
107332: LIST
107333: LIST
107334: PUSH
107335: LD_INT 21
107337: PUSH
107338: LD_INT 3
107340: PUSH
107341: EMPTY
107342: LIST
107343: LIST
107344: PUSH
107345: EMPTY
107346: LIST
107347: LIST
107348: PPUSH
107349: CALL_OW 69
107353: ST_TO_ADDR
// if not tmp then
107354: LD_VAR 0 2
107358: NOT
107359: IFFALSE 107363
// exit ;
107361: GO 107392
// for i in tmp do
107363: LD_ADDR_VAR 0 1
107367: PUSH
107368: LD_VAR 0 2
107372: PUSH
107373: FOR_IN
107374: IFFALSE 107390
// SetBLevel ( i , 10 ) ;
107376: LD_VAR 0 1
107380: PPUSH
107381: LD_INT 10
107383: PPUSH
107384: CALL_OW 241
107388: GO 107373
107390: POP
107391: POP
// end ;
107392: PPOPN 2
107394: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107395: LD_EXP 79
107399: IFFALSE 107407
107401: PUSH
107402: LD_EXP 96
107406: AND
107407: IFFALSE 107518
107409: GO 107411
107411: DISABLE
107412: LD_INT 0
107414: PPUSH
107415: PPUSH
107416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107417: LD_ADDR_VAR 0 3
107421: PUSH
107422: LD_INT 22
107424: PUSH
107425: LD_OWVAR 2
107429: PUSH
107430: EMPTY
107431: LIST
107432: LIST
107433: PUSH
107434: LD_INT 25
107436: PUSH
107437: LD_INT 1
107439: PUSH
107440: EMPTY
107441: LIST
107442: LIST
107443: PUSH
107444: EMPTY
107445: LIST
107446: LIST
107447: PPUSH
107448: CALL_OW 69
107452: ST_TO_ADDR
// if not tmp then
107453: LD_VAR 0 3
107457: NOT
107458: IFFALSE 107462
// exit ;
107460: GO 107518
// un := tmp [ rand ( 1 , tmp ) ] ;
107462: LD_ADDR_VAR 0 2
107466: PUSH
107467: LD_VAR 0 3
107471: PUSH
107472: LD_INT 1
107474: PPUSH
107475: LD_VAR 0 3
107479: PPUSH
107480: CALL_OW 12
107484: ARRAY
107485: ST_TO_ADDR
// if Crawls ( un ) then
107486: LD_VAR 0 2
107490: PPUSH
107491: CALL_OW 318
107495: IFFALSE 107506
// ComWalk ( un ) ;
107497: LD_VAR 0 2
107501: PPUSH
107502: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107506: LD_VAR 0 2
107510: PPUSH
107511: LD_INT 5
107513: PPUSH
107514: CALL_OW 336
// end ;
107518: PPOPN 3
107520: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
107521: LD_EXP 79
107525: IFFALSE 107533
107527: PUSH
107528: LD_EXP 97
107532: AND
107533: IFFALSE 107545
107535: PUSH
107536: LD_OWVAR 67
107540: PUSH
107541: LD_INT 4
107543: LESS
107544: AND
107545: IFFALSE 107564
107547: GO 107549
107549: DISABLE
// begin Difficulty := Difficulty + 1 ;
107550: LD_ADDR_OWVAR 67
107554: PUSH
107555: LD_OWVAR 67
107559: PUSH
107560: LD_INT 1
107562: PLUS
107563: ST_TO_ADDR
// end ;
107564: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107565: LD_EXP 79
107569: IFFALSE 107577
107571: PUSH
107572: LD_EXP 98
107576: AND
107577: IFFALSE 107680
107579: GO 107581
107581: DISABLE
107582: LD_INT 0
107584: PPUSH
// begin for i := 1 to 5 do
107585: LD_ADDR_VAR 0 1
107589: PUSH
107590: DOUBLE
107591: LD_INT 1
107593: DEC
107594: ST_TO_ADDR
107595: LD_INT 5
107597: PUSH
107598: FOR_TO
107599: IFFALSE 107678
// begin uc_nation := nation_nature ;
107601: LD_ADDR_OWVAR 21
107605: PUSH
107606: LD_INT 0
107608: ST_TO_ADDR
// uc_side := 0 ;
107609: LD_ADDR_OWVAR 20
107613: PUSH
107614: LD_INT 0
107616: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107617: LD_ADDR_OWVAR 29
107621: PUSH
107622: LD_INT 12
107624: PUSH
107625: LD_INT 12
107627: PUSH
107628: EMPTY
107629: LIST
107630: LIST
107631: ST_TO_ADDR
// hc_agressivity := 20 ;
107632: LD_ADDR_OWVAR 35
107636: PUSH
107637: LD_INT 20
107639: ST_TO_ADDR
// hc_class := class_tiger ;
107640: LD_ADDR_OWVAR 28
107644: PUSH
107645: LD_INT 14
107647: ST_TO_ADDR
// hc_gallery :=  ;
107648: LD_ADDR_OWVAR 33
107652: PUSH
107653: LD_STRING 
107655: ST_TO_ADDR
// hc_name :=  ;
107656: LD_ADDR_OWVAR 26
107660: PUSH
107661: LD_STRING 
107663: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
107664: CALL_OW 44
107668: PPUSH
107669: LD_INT 0
107671: PPUSH
107672: CALL_OW 51
// end ;
107676: GO 107598
107678: POP
107679: POP
// end ;
107680: PPOPN 1
107682: END
// every 0 0$1 trigger StreamModeActive and sBomb do
107683: LD_EXP 79
107687: IFFALSE 107695
107689: PUSH
107690: LD_EXP 99
107694: AND
107695: IFFALSE 107704
107697: GO 107699
107699: DISABLE
// StreamSibBomb ;
107700: CALL 107705 0 0
107704: END
// export function StreamSibBomb ; var i , x , y ; begin
107705: LD_INT 0
107707: PPUSH
107708: PPUSH
107709: PPUSH
107710: PPUSH
// result := false ;
107711: LD_ADDR_VAR 0 1
107715: PUSH
107716: LD_INT 0
107718: ST_TO_ADDR
// for i := 1 to 16 do
107719: LD_ADDR_VAR 0 2
107723: PUSH
107724: DOUBLE
107725: LD_INT 1
107727: DEC
107728: ST_TO_ADDR
107729: LD_INT 16
107731: PUSH
107732: FOR_TO
107733: IFFALSE 107932
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107735: LD_ADDR_VAR 0 3
107739: PUSH
107740: LD_INT 10
107742: PUSH
107743: LD_INT 20
107745: PUSH
107746: LD_INT 30
107748: PUSH
107749: LD_INT 40
107751: PUSH
107752: LD_INT 50
107754: PUSH
107755: LD_INT 60
107757: PUSH
107758: LD_INT 70
107760: PUSH
107761: LD_INT 80
107763: PUSH
107764: LD_INT 90
107766: PUSH
107767: LD_INT 100
107769: PUSH
107770: LD_INT 110
107772: PUSH
107773: LD_INT 120
107775: PUSH
107776: LD_INT 130
107778: PUSH
107779: LD_INT 140
107781: PUSH
107782: LD_INT 150
107784: PUSH
107785: EMPTY
107786: LIST
107787: LIST
107788: LIST
107789: LIST
107790: LIST
107791: LIST
107792: LIST
107793: LIST
107794: LIST
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: LIST
107801: PUSH
107802: LD_INT 1
107804: PPUSH
107805: LD_INT 15
107807: PPUSH
107808: CALL_OW 12
107812: ARRAY
107813: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107814: LD_ADDR_VAR 0 4
107818: PUSH
107819: LD_INT 10
107821: PUSH
107822: LD_INT 20
107824: PUSH
107825: LD_INT 30
107827: PUSH
107828: LD_INT 40
107830: PUSH
107831: LD_INT 50
107833: PUSH
107834: LD_INT 60
107836: PUSH
107837: LD_INT 70
107839: PUSH
107840: LD_INT 80
107842: PUSH
107843: LD_INT 90
107845: PUSH
107846: LD_INT 100
107848: PUSH
107849: LD_INT 110
107851: PUSH
107852: LD_INT 120
107854: PUSH
107855: LD_INT 130
107857: PUSH
107858: LD_INT 140
107860: PUSH
107861: LD_INT 150
107863: PUSH
107864: EMPTY
107865: LIST
107866: LIST
107867: LIST
107868: LIST
107869: LIST
107870: LIST
107871: LIST
107872: LIST
107873: LIST
107874: LIST
107875: LIST
107876: LIST
107877: LIST
107878: LIST
107879: LIST
107880: PUSH
107881: LD_INT 1
107883: PPUSH
107884: LD_INT 15
107886: PPUSH
107887: CALL_OW 12
107891: ARRAY
107892: ST_TO_ADDR
// if ValidHex ( x , y ) then
107893: LD_VAR 0 3
107897: PPUSH
107898: LD_VAR 0 4
107902: PPUSH
107903: CALL_OW 488
107907: IFFALSE 107930
// begin result := [ x , y ] ;
107909: LD_ADDR_VAR 0 1
107913: PUSH
107914: LD_VAR 0 3
107918: PUSH
107919: LD_VAR 0 4
107923: PUSH
107924: EMPTY
107925: LIST
107926: LIST
107927: ST_TO_ADDR
// break ;
107928: GO 107932
// end ; end ;
107930: GO 107732
107932: POP
107933: POP
// if result then
107934: LD_VAR 0 1
107938: IFFALSE 107998
// begin ToLua ( playSibBomb() ) ;
107940: LD_STRING playSibBomb()
107942: PPUSH
107943: CALL_OW 559
// wait ( 0 0$14 ) ;
107947: LD_INT 490
107949: PPUSH
107950: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
107954: LD_VAR 0 1
107958: PUSH
107959: LD_INT 1
107961: ARRAY
107962: PPUSH
107963: LD_VAR 0 1
107967: PUSH
107968: LD_INT 2
107970: ARRAY
107971: PPUSH
107972: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
107976: LD_VAR 0 1
107980: PUSH
107981: LD_INT 1
107983: ARRAY
107984: PPUSH
107985: LD_VAR 0 1
107989: PUSH
107990: LD_INT 2
107992: ARRAY
107993: PPUSH
107994: CALL_OW 429
// end ; end ;
107998: LD_VAR 0 1
108002: RET
// every 0 0$1 trigger StreamModeActive and sReset do
108003: LD_EXP 79
108007: IFFALSE 108015
108009: PUSH
108010: LD_EXP 101
108014: AND
108015: IFFALSE 108027
108017: GO 108019
108019: DISABLE
// YouLost (  ) ;
108020: LD_STRING 
108022: PPUSH
108023: CALL_OW 104
108027: END
// every 0 0$1 trigger StreamModeActive and sFog do
108028: LD_EXP 79
108032: IFFALSE 108040
108034: PUSH
108035: LD_EXP 100
108039: AND
108040: IFFALSE 108054
108042: GO 108044
108044: DISABLE
// FogOff ( your_side ) ;
108045: LD_OWVAR 2
108049: PPUSH
108050: CALL_OW 344
108054: END
// every 0 0$1 trigger StreamModeActive and sSun do
108055: LD_EXP 79
108059: IFFALSE 108067
108061: PUSH
108062: LD_EXP 102
108066: AND
108067: IFFALSE 108095
108069: GO 108071
108071: DISABLE
// begin solar_recharge_percent := 0 ;
108072: LD_ADDR_OWVAR 79
108076: PUSH
108077: LD_INT 0
108079: ST_TO_ADDR
// wait ( 5 5$00 ) ;
108080: LD_INT 10500
108082: PPUSH
108083: CALL_OW 67
// solar_recharge_percent := 100 ;
108087: LD_ADDR_OWVAR 79
108091: PUSH
108092: LD_INT 100
108094: ST_TO_ADDR
// end ;
108095: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
108096: LD_EXP 79
108100: IFFALSE 108108
108102: PUSH
108103: LD_EXP 103
108107: AND
108108: IFFALSE 108347
108110: GO 108112
108112: DISABLE
108113: LD_INT 0
108115: PPUSH
108116: PPUSH
108117: PPUSH
// begin tmp := [ ] ;
108118: LD_ADDR_VAR 0 3
108122: PUSH
108123: EMPTY
108124: ST_TO_ADDR
// for i := 1 to 6 do
108125: LD_ADDR_VAR 0 1
108129: PUSH
108130: DOUBLE
108131: LD_INT 1
108133: DEC
108134: ST_TO_ADDR
108135: LD_INT 6
108137: PUSH
108138: FOR_TO
108139: IFFALSE 108244
// begin uc_nation := nation_nature ;
108141: LD_ADDR_OWVAR 21
108145: PUSH
108146: LD_INT 0
108148: ST_TO_ADDR
// uc_side := 0 ;
108149: LD_ADDR_OWVAR 20
108153: PUSH
108154: LD_INT 0
108156: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
108157: LD_ADDR_OWVAR 29
108161: PUSH
108162: LD_INT 12
108164: PUSH
108165: LD_INT 12
108167: PUSH
108168: EMPTY
108169: LIST
108170: LIST
108171: ST_TO_ADDR
// hc_agressivity := 20 ;
108172: LD_ADDR_OWVAR 35
108176: PUSH
108177: LD_INT 20
108179: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
108180: LD_ADDR_OWVAR 28
108184: PUSH
108185: LD_INT 17
108187: ST_TO_ADDR
// hc_gallery :=  ;
108188: LD_ADDR_OWVAR 33
108192: PUSH
108193: LD_STRING 
108195: ST_TO_ADDR
// hc_name :=  ;
108196: LD_ADDR_OWVAR 26
108200: PUSH
108201: LD_STRING 
108203: ST_TO_ADDR
// un := CreateHuman ;
108204: LD_ADDR_VAR 0 2
108208: PUSH
108209: CALL_OW 44
108213: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
108214: LD_VAR 0 2
108218: PPUSH
108219: LD_INT 1
108221: PPUSH
108222: CALL_OW 51
// tmp := tmp ^ un ;
108226: LD_ADDR_VAR 0 3
108230: PUSH
108231: LD_VAR 0 3
108235: PUSH
108236: LD_VAR 0 2
108240: ADD
108241: ST_TO_ADDR
// end ;
108242: GO 108138
108244: POP
108245: POP
// repeat wait ( 0 0$1 ) ;
108246: LD_INT 35
108248: PPUSH
108249: CALL_OW 67
// for un in tmp do
108253: LD_ADDR_VAR 0 2
108257: PUSH
108258: LD_VAR 0 3
108262: PUSH
108263: FOR_IN
108264: IFFALSE 108338
// begin if IsDead ( un ) then
108266: LD_VAR 0 2
108270: PPUSH
108271: CALL_OW 301
108275: IFFALSE 108295
// begin tmp := tmp diff un ;
108277: LD_ADDR_VAR 0 3
108281: PUSH
108282: LD_VAR 0 3
108286: PUSH
108287: LD_VAR 0 2
108291: DIFF
108292: ST_TO_ADDR
// continue ;
108293: GO 108263
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
108295: LD_VAR 0 2
108299: PPUSH
108300: LD_INT 3
108302: PUSH
108303: LD_INT 22
108305: PUSH
108306: LD_INT 0
108308: PUSH
108309: EMPTY
108310: LIST
108311: LIST
108312: PUSH
108313: EMPTY
108314: LIST
108315: LIST
108316: PPUSH
108317: CALL_OW 69
108321: PPUSH
108322: LD_VAR 0 2
108326: PPUSH
108327: CALL_OW 74
108331: PPUSH
108332: CALL_OW 115
// end ;
108336: GO 108263
108338: POP
108339: POP
// until not tmp ;
108340: LD_VAR 0 3
108344: NOT
108345: IFFALSE 108246
// end ;
108347: PPOPN 3
108349: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108350: LD_EXP 79
108354: IFFALSE 108362
108356: PUSH
108357: LD_EXP 104
108361: AND
108362: IFFALSE 108416
108364: GO 108366
108366: DISABLE
// begin ToLua ( displayTroll(); ) ;
108367: LD_STRING displayTroll();
108369: PPUSH
108370: CALL_OW 559
// wait ( 3 3$00 ) ;
108374: LD_INT 6300
108376: PPUSH
108377: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108381: LD_STRING hideTroll();
108383: PPUSH
108384: CALL_OW 559
// wait ( 1 1$00 ) ;
108388: LD_INT 2100
108390: PPUSH
108391: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108395: LD_STRING displayTroll();
108397: PPUSH
108398: CALL_OW 559
// wait ( 1 1$00 ) ;
108402: LD_INT 2100
108404: PPUSH
108405: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108409: LD_STRING hideTroll();
108411: PPUSH
108412: CALL_OW 559
// end ;
108416: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108417: LD_EXP 79
108421: IFFALSE 108429
108423: PUSH
108424: LD_EXP 105
108428: AND
108429: IFFALSE 108492
108431: GO 108433
108433: DISABLE
108434: LD_INT 0
108436: PPUSH
// begin p := 0 ;
108437: LD_ADDR_VAR 0 1
108441: PUSH
108442: LD_INT 0
108444: ST_TO_ADDR
// repeat game_speed := 1 ;
108445: LD_ADDR_OWVAR 65
108449: PUSH
108450: LD_INT 1
108452: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108453: LD_INT 35
108455: PPUSH
108456: CALL_OW 67
// p := p + 1 ;
108460: LD_ADDR_VAR 0 1
108464: PUSH
108465: LD_VAR 0 1
108469: PUSH
108470: LD_INT 1
108472: PLUS
108473: ST_TO_ADDR
// until p >= 60 ;
108474: LD_VAR 0 1
108478: PUSH
108479: LD_INT 60
108481: GREATEREQUAL
108482: IFFALSE 108445
// game_speed := 4 ;
108484: LD_ADDR_OWVAR 65
108488: PUSH
108489: LD_INT 4
108491: ST_TO_ADDR
// end ;
108492: PPOPN 1
108494: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108495: LD_EXP 79
108499: IFFALSE 108507
108501: PUSH
108502: LD_EXP 106
108506: AND
108507: IFFALSE 108653
108509: GO 108511
108511: DISABLE
108512: LD_INT 0
108514: PPUSH
108515: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108516: LD_ADDR_VAR 0 1
108520: PUSH
108521: LD_INT 22
108523: PUSH
108524: LD_OWVAR 2
108528: PUSH
108529: EMPTY
108530: LIST
108531: LIST
108532: PUSH
108533: LD_INT 2
108535: PUSH
108536: LD_INT 30
108538: PUSH
108539: LD_INT 0
108541: PUSH
108542: EMPTY
108543: LIST
108544: LIST
108545: PUSH
108546: LD_INT 30
108548: PUSH
108549: LD_INT 1
108551: PUSH
108552: EMPTY
108553: LIST
108554: LIST
108555: PUSH
108556: EMPTY
108557: LIST
108558: LIST
108559: LIST
108560: PUSH
108561: EMPTY
108562: LIST
108563: LIST
108564: PPUSH
108565: CALL_OW 69
108569: ST_TO_ADDR
// if not depot then
108570: LD_VAR 0 1
108574: NOT
108575: IFFALSE 108579
// exit ;
108577: GO 108653
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108579: LD_ADDR_VAR 0 2
108583: PUSH
108584: LD_VAR 0 1
108588: PUSH
108589: LD_INT 1
108591: PPUSH
108592: LD_VAR 0 1
108596: PPUSH
108597: CALL_OW 12
108601: ARRAY
108602: PPUSH
108603: CALL_OW 274
108607: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108608: LD_VAR 0 2
108612: PPUSH
108613: LD_INT 1
108615: PPUSH
108616: LD_INT 0
108618: PPUSH
108619: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108623: LD_VAR 0 2
108627: PPUSH
108628: LD_INT 2
108630: PPUSH
108631: LD_INT 0
108633: PPUSH
108634: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
108638: LD_VAR 0 2
108642: PPUSH
108643: LD_INT 3
108645: PPUSH
108646: LD_INT 0
108648: PPUSH
108649: CALL_OW 277
// end ;
108653: PPOPN 2
108655: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
108656: LD_EXP 79
108660: IFFALSE 108668
108662: PUSH
108663: LD_EXP 107
108667: AND
108668: IFFALSE 108765
108670: GO 108672
108672: DISABLE
108673: LD_INT 0
108675: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108676: LD_ADDR_VAR 0 1
108680: PUSH
108681: LD_INT 22
108683: PUSH
108684: LD_OWVAR 2
108688: PUSH
108689: EMPTY
108690: LIST
108691: LIST
108692: PUSH
108693: LD_INT 21
108695: PUSH
108696: LD_INT 1
108698: PUSH
108699: EMPTY
108700: LIST
108701: LIST
108702: PUSH
108703: LD_INT 3
108705: PUSH
108706: LD_INT 23
108708: PUSH
108709: LD_INT 0
108711: PUSH
108712: EMPTY
108713: LIST
108714: LIST
108715: PUSH
108716: EMPTY
108717: LIST
108718: LIST
108719: PUSH
108720: EMPTY
108721: LIST
108722: LIST
108723: LIST
108724: PPUSH
108725: CALL_OW 69
108729: ST_TO_ADDR
// if not tmp then
108730: LD_VAR 0 1
108734: NOT
108735: IFFALSE 108739
// exit ;
108737: GO 108765
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
108739: LD_VAR 0 1
108743: PUSH
108744: LD_INT 1
108746: PPUSH
108747: LD_VAR 0 1
108751: PPUSH
108752: CALL_OW 12
108756: ARRAY
108757: PPUSH
108758: LD_INT 200
108760: PPUSH
108761: CALL_OW 234
// end ;
108765: PPOPN 1
108767: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
108768: LD_EXP 79
108772: IFFALSE 108780
108774: PUSH
108775: LD_EXP 108
108779: AND
108780: IFFALSE 108859
108782: GO 108784
108784: DISABLE
108785: LD_INT 0
108787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
108788: LD_ADDR_VAR 0 1
108792: PUSH
108793: LD_INT 22
108795: PUSH
108796: LD_OWVAR 2
108800: PUSH
108801: EMPTY
108802: LIST
108803: LIST
108804: PUSH
108805: LD_INT 21
108807: PUSH
108808: LD_INT 2
108810: PUSH
108811: EMPTY
108812: LIST
108813: LIST
108814: PUSH
108815: EMPTY
108816: LIST
108817: LIST
108818: PPUSH
108819: CALL_OW 69
108823: ST_TO_ADDR
// if not tmp then
108824: LD_VAR 0 1
108828: NOT
108829: IFFALSE 108833
// exit ;
108831: GO 108859
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
108833: LD_VAR 0 1
108837: PUSH
108838: LD_INT 1
108840: PPUSH
108841: LD_VAR 0 1
108845: PPUSH
108846: CALL_OW 12
108850: ARRAY
108851: PPUSH
108852: LD_INT 60
108854: PPUSH
108855: CALL_OW 234
// end ;
108859: PPOPN 1
108861: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
108862: LD_EXP 79
108866: IFFALSE 108874
108868: PUSH
108869: LD_EXP 109
108873: AND
108874: IFFALSE 108973
108876: GO 108878
108878: DISABLE
108879: LD_INT 0
108881: PPUSH
108882: PPUSH
// begin enable ;
108883: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
108884: LD_ADDR_VAR 0 1
108888: PUSH
108889: LD_INT 22
108891: PUSH
108892: LD_OWVAR 2
108896: PUSH
108897: EMPTY
108898: LIST
108899: LIST
108900: PUSH
108901: LD_INT 61
108903: PUSH
108904: EMPTY
108905: LIST
108906: PUSH
108907: LD_INT 33
108909: PUSH
108910: LD_INT 2
108912: PUSH
108913: EMPTY
108914: LIST
108915: LIST
108916: PUSH
108917: EMPTY
108918: LIST
108919: LIST
108920: LIST
108921: PPUSH
108922: CALL_OW 69
108926: ST_TO_ADDR
// if not tmp then
108927: LD_VAR 0 1
108931: NOT
108932: IFFALSE 108936
// exit ;
108934: GO 108973
// for i in tmp do
108936: LD_ADDR_VAR 0 2
108940: PUSH
108941: LD_VAR 0 1
108945: PUSH
108946: FOR_IN
108947: IFFALSE 108971
// if IsControledBy ( i ) then
108949: LD_VAR 0 2
108953: PPUSH
108954: CALL_OW 312
108958: IFFALSE 108969
// ComUnlink ( i ) ;
108960: LD_VAR 0 2
108964: PPUSH
108965: CALL_OW 136
108969: GO 108946
108971: POP
108972: POP
// end ;
108973: PPOPN 2
108975: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
108976: LD_EXP 79
108980: IFFALSE 108988
108982: PUSH
108983: LD_EXP 110
108987: AND
108988: IFFALSE 109128
108990: GO 108992
108992: DISABLE
108993: LD_INT 0
108995: PPUSH
108996: PPUSH
// begin ToLua ( displayPowell(); ) ;
108997: LD_STRING displayPowell();
108999: PPUSH
109000: CALL_OW 559
// uc_side := 0 ;
109004: LD_ADDR_OWVAR 20
109008: PUSH
109009: LD_INT 0
109011: ST_TO_ADDR
// uc_nation := 2 ;
109012: LD_ADDR_OWVAR 21
109016: PUSH
109017: LD_INT 2
109019: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
109020: LD_ADDR_OWVAR 37
109024: PUSH
109025: LD_INT 14
109027: ST_TO_ADDR
// vc_engine := engine_siberite ;
109028: LD_ADDR_OWVAR 39
109032: PUSH
109033: LD_INT 3
109035: ST_TO_ADDR
// vc_control := control_apeman ;
109036: LD_ADDR_OWVAR 38
109040: PUSH
109041: LD_INT 5
109043: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
109044: LD_ADDR_OWVAR 40
109048: PUSH
109049: LD_INT 29
109051: ST_TO_ADDR
// un := CreateVehicle ;
109052: LD_ADDR_VAR 0 2
109056: PUSH
109057: CALL_OW 45
109061: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109062: LD_VAR 0 2
109066: PPUSH
109067: LD_INT 1
109069: PPUSH
109070: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109074: LD_INT 35
109076: PPUSH
109077: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109081: LD_VAR 0 2
109085: PPUSH
109086: LD_INT 22
109088: PUSH
109089: LD_OWVAR 2
109093: PUSH
109094: EMPTY
109095: LIST
109096: LIST
109097: PPUSH
109098: CALL_OW 69
109102: PPUSH
109103: LD_VAR 0 2
109107: PPUSH
109108: CALL_OW 74
109112: PPUSH
109113: CALL_OW 115
// until IsDead ( un ) ;
109117: LD_VAR 0 2
109121: PPUSH
109122: CALL_OW 301
109126: IFFALSE 109074
// end ;
109128: PPOPN 2
109130: END
// every 0 0$1 trigger StreamModeActive and sStu do
109131: LD_EXP 79
109135: IFFALSE 109143
109137: PUSH
109138: LD_EXP 118
109142: AND
109143: IFFALSE 109159
109145: GO 109147
109147: DISABLE
// begin ToLua ( displayStucuk(); ) ;
109148: LD_STRING displayStucuk();
109150: PPUSH
109151: CALL_OW 559
// ResetFog ;
109155: CALL_OW 335
// end ;
109159: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
109160: LD_EXP 79
109164: IFFALSE 109172
109166: PUSH
109167: LD_EXP 111
109171: AND
109172: IFFALSE 109313
109174: GO 109176
109176: DISABLE
109177: LD_INT 0
109179: PPUSH
109180: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109181: LD_ADDR_VAR 0 2
109185: PUSH
109186: LD_INT 22
109188: PUSH
109189: LD_OWVAR 2
109193: PUSH
109194: EMPTY
109195: LIST
109196: LIST
109197: PUSH
109198: LD_INT 21
109200: PUSH
109201: LD_INT 1
109203: PUSH
109204: EMPTY
109205: LIST
109206: LIST
109207: PUSH
109208: EMPTY
109209: LIST
109210: LIST
109211: PPUSH
109212: CALL_OW 69
109216: ST_TO_ADDR
// if not tmp then
109217: LD_VAR 0 2
109221: NOT
109222: IFFALSE 109226
// exit ;
109224: GO 109313
// un := tmp [ rand ( 1 , tmp ) ] ;
109226: LD_ADDR_VAR 0 1
109230: PUSH
109231: LD_VAR 0 2
109235: PUSH
109236: LD_INT 1
109238: PPUSH
109239: LD_VAR 0 2
109243: PPUSH
109244: CALL_OW 12
109248: ARRAY
109249: ST_TO_ADDR
// SetSide ( un , 0 ) ;
109250: LD_VAR 0 1
109254: PPUSH
109255: LD_INT 0
109257: PPUSH
109258: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
109262: LD_VAR 0 1
109266: PPUSH
109267: LD_OWVAR 3
109271: PUSH
109272: LD_VAR 0 1
109276: DIFF
109277: PPUSH
109278: LD_VAR 0 1
109282: PPUSH
109283: CALL_OW 74
109287: PPUSH
109288: CALL_OW 115
// wait ( 0 0$20 ) ;
109292: LD_INT 700
109294: PPUSH
109295: CALL_OW 67
// SetSide ( un , your_side ) ;
109299: LD_VAR 0 1
109303: PPUSH
109304: LD_OWVAR 2
109308: PPUSH
109309: CALL_OW 235
// end ;
109313: PPOPN 2
109315: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
109316: LD_EXP 79
109320: IFFALSE 109328
109322: PUSH
109323: LD_EXP 112
109327: AND
109328: IFFALSE 109434
109330: GO 109332
109332: DISABLE
109333: LD_INT 0
109335: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109336: LD_ADDR_VAR 0 1
109340: PUSH
109341: LD_INT 22
109343: PUSH
109344: LD_OWVAR 2
109348: PUSH
109349: EMPTY
109350: LIST
109351: LIST
109352: PUSH
109353: LD_INT 2
109355: PUSH
109356: LD_INT 30
109358: PUSH
109359: LD_INT 0
109361: PUSH
109362: EMPTY
109363: LIST
109364: LIST
109365: PUSH
109366: LD_INT 30
109368: PUSH
109369: LD_INT 1
109371: PUSH
109372: EMPTY
109373: LIST
109374: LIST
109375: PUSH
109376: EMPTY
109377: LIST
109378: LIST
109379: LIST
109380: PUSH
109381: EMPTY
109382: LIST
109383: LIST
109384: PPUSH
109385: CALL_OW 69
109389: ST_TO_ADDR
// if not depot then
109390: LD_VAR 0 1
109394: NOT
109395: IFFALSE 109399
// exit ;
109397: GO 109434
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109399: LD_VAR 0 1
109403: PUSH
109404: LD_INT 1
109406: ARRAY
109407: PPUSH
109408: CALL_OW 250
109412: PPUSH
109413: LD_VAR 0 1
109417: PUSH
109418: LD_INT 1
109420: ARRAY
109421: PPUSH
109422: CALL_OW 251
109426: PPUSH
109427: LD_INT 70
109429: PPUSH
109430: CALL_OW 495
// end ;
109434: PPOPN 1
109436: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109437: LD_EXP 79
109441: IFFALSE 109449
109443: PUSH
109444: LD_EXP 113
109448: AND
109449: IFFALSE 109660
109451: GO 109453
109453: DISABLE
109454: LD_INT 0
109456: PPUSH
109457: PPUSH
109458: PPUSH
109459: PPUSH
109460: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109461: LD_ADDR_VAR 0 5
109465: PUSH
109466: LD_INT 22
109468: PUSH
109469: LD_OWVAR 2
109473: PUSH
109474: EMPTY
109475: LIST
109476: LIST
109477: PUSH
109478: LD_INT 21
109480: PUSH
109481: LD_INT 1
109483: PUSH
109484: EMPTY
109485: LIST
109486: LIST
109487: PUSH
109488: EMPTY
109489: LIST
109490: LIST
109491: PPUSH
109492: CALL_OW 69
109496: ST_TO_ADDR
// if not tmp then
109497: LD_VAR 0 5
109501: NOT
109502: IFFALSE 109506
// exit ;
109504: GO 109660
// for i in tmp do
109506: LD_ADDR_VAR 0 1
109510: PUSH
109511: LD_VAR 0 5
109515: PUSH
109516: FOR_IN
109517: IFFALSE 109658
// begin d := rand ( 0 , 5 ) ;
109519: LD_ADDR_VAR 0 4
109523: PUSH
109524: LD_INT 0
109526: PPUSH
109527: LD_INT 5
109529: PPUSH
109530: CALL_OW 12
109534: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109535: LD_ADDR_VAR 0 2
109539: PUSH
109540: LD_VAR 0 1
109544: PPUSH
109545: CALL_OW 250
109549: PPUSH
109550: LD_VAR 0 4
109554: PPUSH
109555: LD_INT 3
109557: PPUSH
109558: LD_INT 12
109560: PPUSH
109561: CALL_OW 12
109565: PPUSH
109566: CALL_OW 272
109570: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109571: LD_ADDR_VAR 0 3
109575: PUSH
109576: LD_VAR 0 1
109580: PPUSH
109581: CALL_OW 251
109585: PPUSH
109586: LD_VAR 0 4
109590: PPUSH
109591: LD_INT 3
109593: PPUSH
109594: LD_INT 12
109596: PPUSH
109597: CALL_OW 12
109601: PPUSH
109602: CALL_OW 273
109606: ST_TO_ADDR
// if ValidHex ( x , y ) then
109607: LD_VAR 0 2
109611: PPUSH
109612: LD_VAR 0 3
109616: PPUSH
109617: CALL_OW 488
109621: IFFALSE 109656
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109623: LD_VAR 0 1
109627: PPUSH
109628: LD_VAR 0 2
109632: PPUSH
109633: LD_VAR 0 3
109637: PPUSH
109638: LD_INT 3
109640: PPUSH
109641: LD_INT 6
109643: PPUSH
109644: CALL_OW 12
109648: PPUSH
109649: LD_INT 1
109651: PPUSH
109652: CALL_OW 483
// end ;
109656: GO 109516
109658: POP
109659: POP
// end ;
109660: PPOPN 5
109662: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
109663: LD_EXP 79
109667: IFFALSE 109675
109669: PUSH
109670: LD_EXP 114
109674: AND
109675: IFFALSE 109769
109677: GO 109679
109679: DISABLE
109680: LD_INT 0
109682: PPUSH
109683: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
109684: LD_ADDR_VAR 0 2
109688: PUSH
109689: LD_INT 22
109691: PUSH
109692: LD_OWVAR 2
109696: PUSH
109697: EMPTY
109698: LIST
109699: LIST
109700: PUSH
109701: LD_INT 32
109703: PUSH
109704: LD_INT 1
109706: PUSH
109707: EMPTY
109708: LIST
109709: LIST
109710: PUSH
109711: LD_INT 21
109713: PUSH
109714: LD_INT 2
109716: PUSH
109717: EMPTY
109718: LIST
109719: LIST
109720: PUSH
109721: EMPTY
109722: LIST
109723: LIST
109724: LIST
109725: PPUSH
109726: CALL_OW 69
109730: ST_TO_ADDR
// if not tmp then
109731: LD_VAR 0 2
109735: NOT
109736: IFFALSE 109740
// exit ;
109738: GO 109769
// for i in tmp do
109740: LD_ADDR_VAR 0 1
109744: PUSH
109745: LD_VAR 0 2
109749: PUSH
109750: FOR_IN
109751: IFFALSE 109767
// SetFuel ( i , 0 ) ;
109753: LD_VAR 0 1
109757: PPUSH
109758: LD_INT 0
109760: PPUSH
109761: CALL_OW 240
109765: GO 109750
109767: POP
109768: POP
// end ;
109769: PPOPN 2
109771: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
109772: LD_EXP 79
109776: IFFALSE 109784
109778: PUSH
109779: LD_EXP 115
109783: AND
109784: IFFALSE 109850
109786: GO 109788
109788: DISABLE
109789: LD_INT 0
109791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
109792: LD_ADDR_VAR 0 1
109796: PUSH
109797: LD_INT 22
109799: PUSH
109800: LD_OWVAR 2
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: PUSH
109809: LD_INT 30
109811: PUSH
109812: LD_INT 29
109814: PUSH
109815: EMPTY
109816: LIST
109817: LIST
109818: PUSH
109819: EMPTY
109820: LIST
109821: LIST
109822: PPUSH
109823: CALL_OW 69
109827: ST_TO_ADDR
// if not tmp then
109828: LD_VAR 0 1
109832: NOT
109833: IFFALSE 109837
// exit ;
109835: GO 109850
// DestroyUnit ( tmp [ 1 ] ) ;
109837: LD_VAR 0 1
109841: PUSH
109842: LD_INT 1
109844: ARRAY
109845: PPUSH
109846: CALL_OW 65
// end ;
109850: PPOPN 1
109852: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
109853: LD_EXP 79
109857: IFFALSE 109865
109859: PUSH
109860: LD_EXP 117
109864: AND
109865: IFFALSE 109994
109867: GO 109869
109869: DISABLE
109870: LD_INT 0
109872: PPUSH
// begin uc_side := 0 ;
109873: LD_ADDR_OWVAR 20
109877: PUSH
109878: LD_INT 0
109880: ST_TO_ADDR
// uc_nation := nation_arabian ;
109881: LD_ADDR_OWVAR 21
109885: PUSH
109886: LD_INT 2
109888: ST_TO_ADDR
// hc_gallery :=  ;
109889: LD_ADDR_OWVAR 33
109893: PUSH
109894: LD_STRING 
109896: ST_TO_ADDR
// hc_name :=  ;
109897: LD_ADDR_OWVAR 26
109901: PUSH
109902: LD_STRING 
109904: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
109905: LD_INT 1
109907: PPUSH
109908: LD_INT 11
109910: PPUSH
109911: LD_INT 10
109913: PPUSH
109914: CALL_OW 380
// un := CreateHuman ;
109918: LD_ADDR_VAR 0 1
109922: PUSH
109923: CALL_OW 44
109927: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109928: LD_VAR 0 1
109932: PPUSH
109933: LD_INT 1
109935: PPUSH
109936: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109940: LD_INT 35
109942: PPUSH
109943: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109947: LD_VAR 0 1
109951: PPUSH
109952: LD_INT 22
109954: PUSH
109955: LD_OWVAR 2
109959: PUSH
109960: EMPTY
109961: LIST
109962: LIST
109963: PPUSH
109964: CALL_OW 69
109968: PPUSH
109969: LD_VAR 0 1
109973: PPUSH
109974: CALL_OW 74
109978: PPUSH
109979: CALL_OW 115
// until IsDead ( un ) ;
109983: LD_VAR 0 1
109987: PPUSH
109988: CALL_OW 301
109992: IFFALSE 109940
// end ;
109994: PPOPN 1
109996: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
109997: LD_EXP 79
110001: IFFALSE 110009
110003: PUSH
110004: LD_EXP 119
110008: AND
110009: IFFALSE 110021
110011: GO 110013
110013: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
110014: LD_STRING earthquake(getX(game), 0, 32)
110016: PPUSH
110017: CALL_OW 559
110021: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
110022: LD_EXP 79
110026: IFFALSE 110034
110028: PUSH
110029: LD_EXP 120
110033: AND
110034: IFFALSE 110125
110036: GO 110038
110038: DISABLE
110039: LD_INT 0
110041: PPUSH
// begin enable ;
110042: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
110043: LD_ADDR_VAR 0 1
110047: PUSH
110048: LD_INT 22
110050: PUSH
110051: LD_OWVAR 2
110055: PUSH
110056: EMPTY
110057: LIST
110058: LIST
110059: PUSH
110060: LD_INT 21
110062: PUSH
110063: LD_INT 2
110065: PUSH
110066: EMPTY
110067: LIST
110068: LIST
110069: PUSH
110070: LD_INT 33
110072: PUSH
110073: LD_INT 3
110075: PUSH
110076: EMPTY
110077: LIST
110078: LIST
110079: PUSH
110080: EMPTY
110081: LIST
110082: LIST
110083: LIST
110084: PPUSH
110085: CALL_OW 69
110089: ST_TO_ADDR
// if not tmp then
110090: LD_VAR 0 1
110094: NOT
110095: IFFALSE 110099
// exit ;
110097: GO 110125
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110099: LD_VAR 0 1
110103: PUSH
110104: LD_INT 1
110106: PPUSH
110107: LD_VAR 0 1
110111: PPUSH
110112: CALL_OW 12
110116: ARRAY
110117: PPUSH
110118: LD_INT 1
110120: PPUSH
110121: CALL_OW 234
// end ;
110125: PPOPN 1
110127: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
110128: LD_EXP 79
110132: IFFALSE 110140
110134: PUSH
110135: LD_EXP 121
110139: AND
110140: IFFALSE 110281
110142: GO 110144
110144: DISABLE
110145: LD_INT 0
110147: PPUSH
110148: PPUSH
110149: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110150: LD_ADDR_VAR 0 3
110154: PUSH
110155: LD_INT 22
110157: PUSH
110158: LD_OWVAR 2
110162: PUSH
110163: EMPTY
110164: LIST
110165: LIST
110166: PUSH
110167: LD_INT 25
110169: PUSH
110170: LD_INT 1
110172: PUSH
110173: EMPTY
110174: LIST
110175: LIST
110176: PUSH
110177: EMPTY
110178: LIST
110179: LIST
110180: PPUSH
110181: CALL_OW 69
110185: ST_TO_ADDR
// if not tmp then
110186: LD_VAR 0 3
110190: NOT
110191: IFFALSE 110195
// exit ;
110193: GO 110281
// un := tmp [ rand ( 1 , tmp ) ] ;
110195: LD_ADDR_VAR 0 2
110199: PUSH
110200: LD_VAR 0 3
110204: PUSH
110205: LD_INT 1
110207: PPUSH
110208: LD_VAR 0 3
110212: PPUSH
110213: CALL_OW 12
110217: ARRAY
110218: ST_TO_ADDR
// if Crawls ( un ) then
110219: LD_VAR 0 2
110223: PPUSH
110224: CALL_OW 318
110228: IFFALSE 110239
// ComWalk ( un ) ;
110230: LD_VAR 0 2
110234: PPUSH
110235: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
110239: LD_VAR 0 2
110243: PPUSH
110244: LD_INT 9
110246: PPUSH
110247: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
110251: LD_INT 28
110253: PPUSH
110254: LD_OWVAR 2
110258: PPUSH
110259: LD_INT 2
110261: PPUSH
110262: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
110266: LD_INT 29
110268: PPUSH
110269: LD_OWVAR 2
110273: PPUSH
110274: LD_INT 2
110276: PPUSH
110277: CALL_OW 322
// end ;
110281: PPOPN 3
110283: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
110284: LD_EXP 79
110288: IFFALSE 110296
110290: PUSH
110291: LD_EXP 122
110295: AND
110296: IFFALSE 110407
110298: GO 110300
110300: DISABLE
110301: LD_INT 0
110303: PPUSH
110304: PPUSH
110305: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110306: LD_ADDR_VAR 0 3
110310: PUSH
110311: LD_INT 22
110313: PUSH
110314: LD_OWVAR 2
110318: PUSH
110319: EMPTY
110320: LIST
110321: LIST
110322: PUSH
110323: LD_INT 25
110325: PUSH
110326: LD_INT 1
110328: PUSH
110329: EMPTY
110330: LIST
110331: LIST
110332: PUSH
110333: EMPTY
110334: LIST
110335: LIST
110336: PPUSH
110337: CALL_OW 69
110341: ST_TO_ADDR
// if not tmp then
110342: LD_VAR 0 3
110346: NOT
110347: IFFALSE 110351
// exit ;
110349: GO 110407
// un := tmp [ rand ( 1 , tmp ) ] ;
110351: LD_ADDR_VAR 0 2
110355: PUSH
110356: LD_VAR 0 3
110360: PUSH
110361: LD_INT 1
110363: PPUSH
110364: LD_VAR 0 3
110368: PPUSH
110369: CALL_OW 12
110373: ARRAY
110374: ST_TO_ADDR
// if Crawls ( un ) then
110375: LD_VAR 0 2
110379: PPUSH
110380: CALL_OW 318
110384: IFFALSE 110395
// ComWalk ( un ) ;
110386: LD_VAR 0 2
110390: PPUSH
110391: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110395: LD_VAR 0 2
110399: PPUSH
110400: LD_INT 8
110402: PPUSH
110403: CALL_OW 336
// end ;
110407: PPOPN 3
110409: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110410: LD_EXP 79
110414: IFFALSE 110422
110416: PUSH
110417: LD_EXP 123
110421: AND
110422: IFFALSE 110566
110424: GO 110426
110426: DISABLE
110427: LD_INT 0
110429: PPUSH
110430: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110431: LD_ADDR_VAR 0 2
110435: PUSH
110436: LD_INT 22
110438: PUSH
110439: LD_OWVAR 2
110443: PUSH
110444: EMPTY
110445: LIST
110446: LIST
110447: PUSH
110448: LD_INT 21
110450: PUSH
110451: LD_INT 2
110453: PUSH
110454: EMPTY
110455: LIST
110456: LIST
110457: PUSH
110458: LD_INT 2
110460: PUSH
110461: LD_INT 34
110463: PUSH
110464: LD_INT 12
110466: PUSH
110467: EMPTY
110468: LIST
110469: LIST
110470: PUSH
110471: LD_INT 34
110473: PUSH
110474: LD_INT 51
110476: PUSH
110477: EMPTY
110478: LIST
110479: LIST
110480: PUSH
110481: LD_INT 34
110483: PUSH
110484: LD_INT 32
110486: PUSH
110487: EMPTY
110488: LIST
110489: LIST
110490: PUSH
110491: EMPTY
110492: LIST
110493: LIST
110494: LIST
110495: LIST
110496: PUSH
110497: EMPTY
110498: LIST
110499: LIST
110500: LIST
110501: PPUSH
110502: CALL_OW 69
110506: ST_TO_ADDR
// if not tmp then
110507: LD_VAR 0 2
110511: NOT
110512: IFFALSE 110516
// exit ;
110514: GO 110566
// for i in tmp do
110516: LD_ADDR_VAR 0 1
110520: PUSH
110521: LD_VAR 0 2
110525: PUSH
110526: FOR_IN
110527: IFFALSE 110564
// if GetCargo ( i , mat_artifact ) = 0 then
110529: LD_VAR 0 1
110533: PPUSH
110534: LD_INT 4
110536: PPUSH
110537: CALL_OW 289
110541: PUSH
110542: LD_INT 0
110544: EQUAL
110545: IFFALSE 110562
// SetCargo ( i , mat_siberit , 100 ) ;
110547: LD_VAR 0 1
110551: PPUSH
110552: LD_INT 3
110554: PPUSH
110555: LD_INT 100
110557: PPUSH
110558: CALL_OW 290
110562: GO 110526
110564: POP
110565: POP
// end ;
110566: PPOPN 2
110568: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110569: LD_EXP 79
110573: IFFALSE 110581
110575: PUSH
110576: LD_EXP 124
110580: AND
110581: IFFALSE 110764
110583: GO 110585
110585: DISABLE
110586: LD_INT 0
110588: PPUSH
110589: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110590: LD_ADDR_VAR 0 2
110594: PUSH
110595: LD_INT 22
110597: PUSH
110598: LD_OWVAR 2
110602: PUSH
110603: EMPTY
110604: LIST
110605: LIST
110606: PPUSH
110607: CALL_OW 69
110611: ST_TO_ADDR
// if not tmp then
110612: LD_VAR 0 2
110616: NOT
110617: IFFALSE 110621
// exit ;
110619: GO 110764
// for i := 1 to 2 do
110621: LD_ADDR_VAR 0 1
110625: PUSH
110626: DOUBLE
110627: LD_INT 1
110629: DEC
110630: ST_TO_ADDR
110631: LD_INT 2
110633: PUSH
110634: FOR_TO
110635: IFFALSE 110762
// begin uc_side := your_side ;
110637: LD_ADDR_OWVAR 20
110641: PUSH
110642: LD_OWVAR 2
110646: ST_TO_ADDR
// uc_nation := nation_american ;
110647: LD_ADDR_OWVAR 21
110651: PUSH
110652: LD_INT 1
110654: ST_TO_ADDR
// vc_chassis := us_morphling ;
110655: LD_ADDR_OWVAR 37
110659: PUSH
110660: LD_INT 5
110662: ST_TO_ADDR
// vc_engine := engine_siberite ;
110663: LD_ADDR_OWVAR 39
110667: PUSH
110668: LD_INT 3
110670: ST_TO_ADDR
// vc_control := control_computer ;
110671: LD_ADDR_OWVAR 38
110675: PUSH
110676: LD_INT 3
110678: ST_TO_ADDR
// vc_weapon := us_double_laser ;
110679: LD_ADDR_OWVAR 40
110683: PUSH
110684: LD_INT 10
110686: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
110687: LD_VAR 0 2
110691: PUSH
110692: LD_INT 1
110694: ARRAY
110695: PPUSH
110696: CALL_OW 310
110700: NOT
110701: IFFALSE 110748
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
110703: CALL_OW 45
110707: PPUSH
110708: LD_VAR 0 2
110712: PUSH
110713: LD_INT 1
110715: ARRAY
110716: PPUSH
110717: CALL_OW 250
110721: PPUSH
110722: LD_VAR 0 2
110726: PUSH
110727: LD_INT 1
110729: ARRAY
110730: PPUSH
110731: CALL_OW 251
110735: PPUSH
110736: LD_INT 12
110738: PPUSH
110739: LD_INT 1
110741: PPUSH
110742: CALL_OW 50
110746: GO 110760
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
110748: CALL_OW 45
110752: PPUSH
110753: LD_INT 1
110755: PPUSH
110756: CALL_OW 51
// end ;
110760: GO 110634
110762: POP
110763: POP
// end ;
110764: PPOPN 2
110766: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
110767: LD_EXP 79
110771: IFFALSE 110779
110773: PUSH
110774: LD_EXP 125
110778: AND
110779: IFFALSE 111001
110781: GO 110783
110783: DISABLE
110784: LD_INT 0
110786: PPUSH
110787: PPUSH
110788: PPUSH
110789: PPUSH
110790: PPUSH
110791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110792: LD_ADDR_VAR 0 6
110796: PUSH
110797: LD_INT 22
110799: PUSH
110800: LD_OWVAR 2
110804: PUSH
110805: EMPTY
110806: LIST
110807: LIST
110808: PUSH
110809: LD_INT 21
110811: PUSH
110812: LD_INT 1
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: PUSH
110819: LD_INT 3
110821: PUSH
110822: LD_INT 23
110824: PUSH
110825: LD_INT 0
110827: PUSH
110828: EMPTY
110829: LIST
110830: LIST
110831: PUSH
110832: EMPTY
110833: LIST
110834: LIST
110835: PUSH
110836: EMPTY
110837: LIST
110838: LIST
110839: LIST
110840: PPUSH
110841: CALL_OW 69
110845: ST_TO_ADDR
// if not tmp then
110846: LD_VAR 0 6
110850: NOT
110851: IFFALSE 110855
// exit ;
110853: GO 111001
// s1 := rand ( 1 , 4 ) ;
110855: LD_ADDR_VAR 0 2
110859: PUSH
110860: LD_INT 1
110862: PPUSH
110863: LD_INT 4
110865: PPUSH
110866: CALL_OW 12
110870: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
110871: LD_ADDR_VAR 0 4
110875: PUSH
110876: LD_VAR 0 6
110880: PUSH
110881: LD_INT 1
110883: ARRAY
110884: PPUSH
110885: LD_VAR 0 2
110889: PPUSH
110890: CALL_OW 259
110894: ST_TO_ADDR
// if s1 = 1 then
110895: LD_VAR 0 2
110899: PUSH
110900: LD_INT 1
110902: EQUAL
110903: IFFALSE 110923
// s2 := rand ( 2 , 4 ) else
110905: LD_ADDR_VAR 0 3
110909: PUSH
110910: LD_INT 2
110912: PPUSH
110913: LD_INT 4
110915: PPUSH
110916: CALL_OW 12
110920: ST_TO_ADDR
110921: GO 110931
// s2 := 1 ;
110923: LD_ADDR_VAR 0 3
110927: PUSH
110928: LD_INT 1
110930: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
110931: LD_ADDR_VAR 0 5
110935: PUSH
110936: LD_VAR 0 6
110940: PUSH
110941: LD_INT 1
110943: ARRAY
110944: PPUSH
110945: LD_VAR 0 3
110949: PPUSH
110950: CALL_OW 259
110954: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
110955: LD_VAR 0 6
110959: PUSH
110960: LD_INT 1
110962: ARRAY
110963: PPUSH
110964: LD_VAR 0 2
110968: PPUSH
110969: LD_VAR 0 5
110973: PPUSH
110974: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
110978: LD_VAR 0 6
110982: PUSH
110983: LD_INT 1
110985: ARRAY
110986: PPUSH
110987: LD_VAR 0 3
110991: PPUSH
110992: LD_VAR 0 4
110996: PPUSH
110997: CALL_OW 237
// end ;
111001: PPOPN 6
111003: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
111004: LD_EXP 79
111008: IFFALSE 111016
111010: PUSH
111011: LD_EXP 126
111015: AND
111016: IFFALSE 111095
111018: GO 111020
111020: DISABLE
111021: LD_INT 0
111023: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
111024: LD_ADDR_VAR 0 1
111028: PUSH
111029: LD_INT 22
111031: PUSH
111032: LD_OWVAR 2
111036: PUSH
111037: EMPTY
111038: LIST
111039: LIST
111040: PUSH
111041: LD_INT 30
111043: PUSH
111044: LD_INT 3
111046: PUSH
111047: EMPTY
111048: LIST
111049: LIST
111050: PUSH
111051: EMPTY
111052: LIST
111053: LIST
111054: PPUSH
111055: CALL_OW 69
111059: ST_TO_ADDR
// if not tmp then
111060: LD_VAR 0 1
111064: NOT
111065: IFFALSE 111069
// exit ;
111067: GO 111095
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
111069: LD_VAR 0 1
111073: PUSH
111074: LD_INT 1
111076: PPUSH
111077: LD_VAR 0 1
111081: PPUSH
111082: CALL_OW 12
111086: ARRAY
111087: PPUSH
111088: LD_INT 1
111090: PPUSH
111091: CALL_OW 234
// end ;
111095: PPOPN 1
111097: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
111098: LD_EXP 79
111102: IFFALSE 111110
111104: PUSH
111105: LD_EXP 127
111109: AND
111110: IFFALSE 111222
111112: GO 111114
111114: DISABLE
111115: LD_INT 0
111117: PPUSH
111118: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
111119: LD_ADDR_VAR 0 2
111123: PUSH
111124: LD_INT 22
111126: PUSH
111127: LD_OWVAR 2
111131: PUSH
111132: EMPTY
111133: LIST
111134: LIST
111135: PUSH
111136: LD_INT 2
111138: PUSH
111139: LD_INT 30
111141: PUSH
111142: LD_INT 27
111144: PUSH
111145: EMPTY
111146: LIST
111147: LIST
111148: PUSH
111149: LD_INT 30
111151: PUSH
111152: LD_INT 26
111154: PUSH
111155: EMPTY
111156: LIST
111157: LIST
111158: PUSH
111159: LD_INT 30
111161: PUSH
111162: LD_INT 28
111164: PUSH
111165: EMPTY
111166: LIST
111167: LIST
111168: PUSH
111169: EMPTY
111170: LIST
111171: LIST
111172: LIST
111173: LIST
111174: PUSH
111175: EMPTY
111176: LIST
111177: LIST
111178: PPUSH
111179: CALL_OW 69
111183: ST_TO_ADDR
// if not tmp then
111184: LD_VAR 0 2
111188: NOT
111189: IFFALSE 111193
// exit ;
111191: GO 111222
// for i in tmp do
111193: LD_ADDR_VAR 0 1
111197: PUSH
111198: LD_VAR 0 2
111202: PUSH
111203: FOR_IN
111204: IFFALSE 111220
// SetLives ( i , 1 ) ;
111206: LD_VAR 0 1
111210: PPUSH
111211: LD_INT 1
111213: PPUSH
111214: CALL_OW 234
111218: GO 111203
111220: POP
111221: POP
// end ;
111222: PPOPN 2
111224: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
111225: LD_EXP 79
111229: IFFALSE 111237
111231: PUSH
111232: LD_EXP 128
111236: AND
111237: IFFALSE 111524
111239: GO 111241
111241: DISABLE
111242: LD_INT 0
111244: PPUSH
111245: PPUSH
111246: PPUSH
// begin i := rand ( 1 , 7 ) ;
111247: LD_ADDR_VAR 0 1
111251: PUSH
111252: LD_INT 1
111254: PPUSH
111255: LD_INT 7
111257: PPUSH
111258: CALL_OW 12
111262: ST_TO_ADDR
// case i of 1 :
111263: LD_VAR 0 1
111267: PUSH
111268: LD_INT 1
111270: DOUBLE
111271: EQUAL
111272: IFTRUE 111276
111274: GO 111286
111276: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
111277: LD_STRING earthquake(getX(game), 0, 32)
111279: PPUSH
111280: CALL_OW 559
111284: GO 111524
111286: LD_INT 2
111288: DOUBLE
111289: EQUAL
111290: IFTRUE 111294
111292: GO 111308
111294: POP
// begin ToLua ( displayStucuk(); ) ;
111295: LD_STRING displayStucuk();
111297: PPUSH
111298: CALL_OW 559
// ResetFog ;
111302: CALL_OW 335
// end ; 3 :
111306: GO 111524
111308: LD_INT 3
111310: DOUBLE
111311: EQUAL
111312: IFTRUE 111316
111314: GO 111420
111316: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
111317: LD_ADDR_VAR 0 2
111321: PUSH
111322: LD_INT 22
111324: PUSH
111325: LD_OWVAR 2
111329: PUSH
111330: EMPTY
111331: LIST
111332: LIST
111333: PUSH
111334: LD_INT 25
111336: PUSH
111337: LD_INT 1
111339: PUSH
111340: EMPTY
111341: LIST
111342: LIST
111343: PUSH
111344: EMPTY
111345: LIST
111346: LIST
111347: PPUSH
111348: CALL_OW 69
111352: ST_TO_ADDR
// if not tmp then
111353: LD_VAR 0 2
111357: NOT
111358: IFFALSE 111362
// exit ;
111360: GO 111524
// un := tmp [ rand ( 1 , tmp ) ] ;
111362: LD_ADDR_VAR 0 3
111366: PUSH
111367: LD_VAR 0 2
111371: PUSH
111372: LD_INT 1
111374: PPUSH
111375: LD_VAR 0 2
111379: PPUSH
111380: CALL_OW 12
111384: ARRAY
111385: ST_TO_ADDR
// if Crawls ( un ) then
111386: LD_VAR 0 3
111390: PPUSH
111391: CALL_OW 318
111395: IFFALSE 111406
// ComWalk ( un ) ;
111397: LD_VAR 0 3
111401: PPUSH
111402: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111406: LD_VAR 0 3
111410: PPUSH
111411: LD_INT 8
111413: PPUSH
111414: CALL_OW 336
// end ; 4 :
111418: GO 111524
111420: LD_INT 4
111422: DOUBLE
111423: EQUAL
111424: IFTRUE 111428
111426: GO 111502
111428: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111429: LD_ADDR_VAR 0 2
111433: PUSH
111434: LD_INT 22
111436: PUSH
111437: LD_OWVAR 2
111441: PUSH
111442: EMPTY
111443: LIST
111444: LIST
111445: PUSH
111446: LD_INT 30
111448: PUSH
111449: LD_INT 29
111451: PUSH
111452: EMPTY
111453: LIST
111454: LIST
111455: PUSH
111456: EMPTY
111457: LIST
111458: LIST
111459: PPUSH
111460: CALL_OW 69
111464: ST_TO_ADDR
// if not tmp then
111465: LD_VAR 0 2
111469: NOT
111470: IFFALSE 111474
// exit ;
111472: GO 111524
// CenterNowOnUnits ( tmp [ 1 ] ) ;
111474: LD_VAR 0 2
111478: PUSH
111479: LD_INT 1
111481: ARRAY
111482: PPUSH
111483: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
111487: LD_VAR 0 2
111491: PUSH
111492: LD_INT 1
111494: ARRAY
111495: PPUSH
111496: CALL_OW 65
// end ; 5 .. 7 :
111500: GO 111524
111502: LD_INT 5
111504: DOUBLE
111505: GREATEREQUAL
111506: IFFALSE 111514
111508: LD_INT 7
111510: DOUBLE
111511: LESSEQUAL
111512: IFTRUE 111516
111514: GO 111523
111516: POP
// StreamSibBomb ; end ;
111517: CALL 107705 0 0
111521: GO 111524
111523: POP
// end ;
111524: PPOPN 3
111526: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111527: LD_EXP 79
111531: IFFALSE 111539
111533: PUSH
111534: LD_EXP 129
111538: AND
111539: IFFALSE 111695
111541: GO 111543
111543: DISABLE
111544: LD_INT 0
111546: PPUSH
111547: PPUSH
111548: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111549: LD_ADDR_VAR 0 2
111553: PUSH
111554: LD_INT 81
111556: PUSH
111557: LD_OWVAR 2
111561: PUSH
111562: EMPTY
111563: LIST
111564: LIST
111565: PUSH
111566: LD_INT 2
111568: PUSH
111569: LD_INT 21
111571: PUSH
111572: LD_INT 1
111574: PUSH
111575: EMPTY
111576: LIST
111577: LIST
111578: PUSH
111579: LD_INT 21
111581: PUSH
111582: LD_INT 2
111584: PUSH
111585: EMPTY
111586: LIST
111587: LIST
111588: PUSH
111589: EMPTY
111590: LIST
111591: LIST
111592: LIST
111593: PUSH
111594: EMPTY
111595: LIST
111596: LIST
111597: PPUSH
111598: CALL_OW 69
111602: ST_TO_ADDR
// if not tmp then
111603: LD_VAR 0 2
111607: NOT
111608: IFFALSE 111612
// exit ;
111610: GO 111695
// p := 0 ;
111612: LD_ADDR_VAR 0 3
111616: PUSH
111617: LD_INT 0
111619: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111620: LD_INT 35
111622: PPUSH
111623: CALL_OW 67
// p := p + 1 ;
111627: LD_ADDR_VAR 0 3
111631: PUSH
111632: LD_VAR 0 3
111636: PUSH
111637: LD_INT 1
111639: PLUS
111640: ST_TO_ADDR
// for i in tmp do
111641: LD_ADDR_VAR 0 1
111645: PUSH
111646: LD_VAR 0 2
111650: PUSH
111651: FOR_IN
111652: IFFALSE 111683
// if GetLives ( i ) < 1000 then
111654: LD_VAR 0 1
111658: PPUSH
111659: CALL_OW 256
111663: PUSH
111664: LD_INT 1000
111666: LESS
111667: IFFALSE 111681
// SetLives ( i , 1000 ) ;
111669: LD_VAR 0 1
111673: PPUSH
111674: LD_INT 1000
111676: PPUSH
111677: CALL_OW 234
111681: GO 111651
111683: POP
111684: POP
// until p > 20 ;
111685: LD_VAR 0 3
111689: PUSH
111690: LD_INT 20
111692: GREATER
111693: IFFALSE 111620
// end ;
111695: PPOPN 3
111697: END
// every 0 0$1 trigger StreamModeActive and sTime do
111698: LD_EXP 79
111702: IFFALSE 111710
111704: PUSH
111705: LD_EXP 130
111709: AND
111710: IFFALSE 111745
111712: GO 111714
111714: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
111715: LD_INT 28
111717: PPUSH
111718: LD_OWVAR 2
111722: PPUSH
111723: LD_INT 2
111725: PPUSH
111726: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
111730: LD_INT 30
111732: PPUSH
111733: LD_OWVAR 2
111737: PPUSH
111738: LD_INT 2
111740: PPUSH
111741: CALL_OW 322
// end ;
111745: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
111746: LD_EXP 79
111750: IFFALSE 111758
111752: PUSH
111753: LD_EXP 131
111757: AND
111758: IFFALSE 111879
111760: GO 111762
111762: DISABLE
111763: LD_INT 0
111765: PPUSH
111766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111767: LD_ADDR_VAR 0 2
111771: PUSH
111772: LD_INT 22
111774: PUSH
111775: LD_OWVAR 2
111779: PUSH
111780: EMPTY
111781: LIST
111782: LIST
111783: PUSH
111784: LD_INT 21
111786: PUSH
111787: LD_INT 1
111789: PUSH
111790: EMPTY
111791: LIST
111792: LIST
111793: PUSH
111794: LD_INT 3
111796: PUSH
111797: LD_INT 23
111799: PUSH
111800: LD_INT 0
111802: PUSH
111803: EMPTY
111804: LIST
111805: LIST
111806: PUSH
111807: EMPTY
111808: LIST
111809: LIST
111810: PUSH
111811: EMPTY
111812: LIST
111813: LIST
111814: LIST
111815: PPUSH
111816: CALL_OW 69
111820: ST_TO_ADDR
// if not tmp then
111821: LD_VAR 0 2
111825: NOT
111826: IFFALSE 111830
// exit ;
111828: GO 111879
// for i in tmp do
111830: LD_ADDR_VAR 0 1
111834: PUSH
111835: LD_VAR 0 2
111839: PUSH
111840: FOR_IN
111841: IFFALSE 111877
// begin if Crawls ( i ) then
111843: LD_VAR 0 1
111847: PPUSH
111848: CALL_OW 318
111852: IFFALSE 111863
// ComWalk ( i ) ;
111854: LD_VAR 0 1
111858: PPUSH
111859: CALL_OW 138
// SetClass ( i , 2 ) ;
111863: LD_VAR 0 1
111867: PPUSH
111868: LD_INT 2
111870: PPUSH
111871: CALL_OW 336
// end ;
111875: GO 111840
111877: POP
111878: POP
// end ;
111879: PPOPN 2
111881: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
111882: LD_EXP 79
111886: IFFALSE 111894
111888: PUSH
111889: LD_EXP 132
111893: AND
111894: IFFALSE 112184
111896: GO 111898
111898: DISABLE
111899: LD_INT 0
111901: PPUSH
111902: PPUSH
111903: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
111904: LD_OWVAR 2
111908: PPUSH
111909: LD_INT 9
111911: PPUSH
111912: LD_INT 1
111914: PPUSH
111915: LD_INT 1
111917: PPUSH
111918: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
111922: LD_INT 9
111924: PPUSH
111925: LD_OWVAR 2
111929: PPUSH
111930: CALL_OW 343
// uc_side := 9 ;
111934: LD_ADDR_OWVAR 20
111938: PUSH
111939: LD_INT 9
111941: ST_TO_ADDR
// uc_nation := 2 ;
111942: LD_ADDR_OWVAR 21
111946: PUSH
111947: LD_INT 2
111949: ST_TO_ADDR
// hc_name := Dark Warrior ;
111950: LD_ADDR_OWVAR 26
111954: PUSH
111955: LD_STRING Dark Warrior
111957: ST_TO_ADDR
// hc_gallery :=  ;
111958: LD_ADDR_OWVAR 33
111962: PUSH
111963: LD_STRING 
111965: ST_TO_ADDR
// hc_noskilllimit := true ;
111966: LD_ADDR_OWVAR 76
111970: PUSH
111971: LD_INT 1
111973: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
111974: LD_ADDR_OWVAR 31
111978: PUSH
111979: LD_INT 30
111981: PUSH
111982: LD_INT 30
111984: PUSH
111985: LD_INT 30
111987: PUSH
111988: LD_INT 30
111990: PUSH
111991: EMPTY
111992: LIST
111993: LIST
111994: LIST
111995: LIST
111996: ST_TO_ADDR
// un := CreateHuman ;
111997: LD_ADDR_VAR 0 3
112001: PUSH
112002: CALL_OW 44
112006: ST_TO_ADDR
// hc_noskilllimit := false ;
112007: LD_ADDR_OWVAR 76
112011: PUSH
112012: LD_INT 0
112014: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
112015: LD_VAR 0 3
112019: PPUSH
112020: LD_INT 1
112022: PPUSH
112023: CALL_OW 51
// ToLua ( playRanger() ) ;
112027: LD_STRING playRanger()
112029: PPUSH
112030: CALL_OW 559
// p := 0 ;
112034: LD_ADDR_VAR 0 2
112038: PUSH
112039: LD_INT 0
112041: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
112042: LD_INT 35
112044: PPUSH
112045: CALL_OW 67
// p := p + 1 ;
112049: LD_ADDR_VAR 0 2
112053: PUSH
112054: LD_VAR 0 2
112058: PUSH
112059: LD_INT 1
112061: PLUS
112062: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
112063: LD_VAR 0 3
112067: PPUSH
112068: CALL_OW 256
112072: PUSH
112073: LD_INT 1000
112075: LESS
112076: IFFALSE 112090
// SetLives ( un , 1000 ) ;
112078: LD_VAR 0 3
112082: PPUSH
112083: LD_INT 1000
112085: PPUSH
112086: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
112090: LD_VAR 0 3
112094: PPUSH
112095: LD_INT 81
112097: PUSH
112098: LD_OWVAR 2
112102: PUSH
112103: EMPTY
112104: LIST
112105: LIST
112106: PUSH
112107: LD_INT 91
112109: PUSH
112110: LD_VAR 0 3
112114: PUSH
112115: LD_INT 30
112117: PUSH
112118: EMPTY
112119: LIST
112120: LIST
112121: LIST
112122: PUSH
112123: EMPTY
112124: LIST
112125: LIST
112126: PPUSH
112127: CALL_OW 69
112131: PPUSH
112132: LD_VAR 0 3
112136: PPUSH
112137: CALL_OW 74
112141: PPUSH
112142: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
112146: LD_VAR 0 2
112150: PUSH
112151: LD_INT 80
112153: GREATER
112154: IFTRUE 112167
112156: PUSH
112157: LD_VAR 0 3
112161: PPUSH
112162: CALL_OW 301
112166: OR
112167: IFFALSE 112042
// if un then
112169: LD_VAR 0 3
112173: IFFALSE 112184
// RemoveUnit ( un ) ;
112175: LD_VAR 0 3
112179: PPUSH
112180: CALL_OW 64
// end ;
112184: PPOPN 3
112186: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
112187: LD_EXP 133
112191: IFFALSE 112307
112193: GO 112195
112195: DISABLE
112196: LD_INT 0
112198: PPUSH
112199: PPUSH
112200: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
112201: LD_ADDR_VAR 0 2
112205: PUSH
112206: LD_INT 81
112208: PUSH
112209: LD_OWVAR 2
112213: PUSH
112214: EMPTY
112215: LIST
112216: LIST
112217: PUSH
112218: LD_INT 21
112220: PUSH
112221: LD_INT 1
112223: PUSH
112224: EMPTY
112225: LIST
112226: LIST
112227: PUSH
112228: EMPTY
112229: LIST
112230: LIST
112231: PPUSH
112232: CALL_OW 69
112236: ST_TO_ADDR
// ToLua ( playComputer() ) ;
112237: LD_STRING playComputer()
112239: PPUSH
112240: CALL_OW 559
// if not tmp then
112244: LD_VAR 0 2
112248: NOT
112249: IFFALSE 112253
// exit ;
112251: GO 112307
// for i in tmp do
112253: LD_ADDR_VAR 0 1
112257: PUSH
112258: LD_VAR 0 2
112262: PUSH
112263: FOR_IN
112264: IFFALSE 112305
// for j := 1 to 4 do
112266: LD_ADDR_VAR 0 3
112270: PUSH
112271: DOUBLE
112272: LD_INT 1
112274: DEC
112275: ST_TO_ADDR
112276: LD_INT 4
112278: PUSH
112279: FOR_TO
112280: IFFALSE 112301
// SetSkill ( i , j , 10 ) ;
112282: LD_VAR 0 1
112286: PPUSH
112287: LD_VAR 0 3
112291: PPUSH
112292: LD_INT 10
112294: PPUSH
112295: CALL_OW 237
112299: GO 112279
112301: POP
112302: POP
112303: GO 112263
112305: POP
112306: POP
// end ;
112307: PPOPN 3
112309: END
// every 0 0$1 trigger s30 do var i , tmp ;
112310: LD_EXP 134
112314: IFFALSE 112383
112316: GO 112318
112318: DISABLE
112319: LD_INT 0
112321: PPUSH
112322: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112323: LD_ADDR_VAR 0 2
112327: PUSH
112328: LD_INT 22
112330: PUSH
112331: LD_OWVAR 2
112335: PUSH
112336: EMPTY
112337: LIST
112338: LIST
112339: PPUSH
112340: CALL_OW 69
112344: ST_TO_ADDR
// if not tmp then
112345: LD_VAR 0 2
112349: NOT
112350: IFFALSE 112354
// exit ;
112352: GO 112383
// for i in tmp do
112354: LD_ADDR_VAR 0 1
112358: PUSH
112359: LD_VAR 0 2
112363: PUSH
112364: FOR_IN
112365: IFFALSE 112381
// SetLives ( i , 300 ) ;
112367: LD_VAR 0 1
112371: PPUSH
112372: LD_INT 300
112374: PPUSH
112375: CALL_OW 234
112379: GO 112364
112381: POP
112382: POP
// end ;
112383: PPOPN 2
112385: END
// every 0 0$1 trigger s60 do var i , tmp ;
112386: LD_EXP 135
112390: IFFALSE 112459
112392: GO 112394
112394: DISABLE
112395: LD_INT 0
112397: PPUSH
112398: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112399: LD_ADDR_VAR 0 2
112403: PUSH
112404: LD_INT 22
112406: PUSH
112407: LD_OWVAR 2
112411: PUSH
112412: EMPTY
112413: LIST
112414: LIST
112415: PPUSH
112416: CALL_OW 69
112420: ST_TO_ADDR
// if not tmp then
112421: LD_VAR 0 2
112425: NOT
112426: IFFALSE 112430
// exit ;
112428: GO 112459
// for i in tmp do
112430: LD_ADDR_VAR 0 1
112434: PUSH
112435: LD_VAR 0 2
112439: PUSH
112440: FOR_IN
112441: IFFALSE 112457
// SetLives ( i , 600 ) ;
112443: LD_VAR 0 1
112447: PPUSH
112448: LD_INT 600
112450: PPUSH
112451: CALL_OW 234
112455: GO 112440
112457: POP
112458: POP
// end ;
112459: PPOPN 2
112461: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112462: LD_INT 0
112464: PPUSH
// case cmd of 301 :
112465: LD_VAR 0 1
112469: PUSH
112470: LD_INT 301
112472: DOUBLE
112473: EQUAL
112474: IFTRUE 112478
112476: GO 112510
112478: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
112479: LD_VAR 0 6
112483: PPUSH
112484: LD_VAR 0 7
112488: PPUSH
112489: LD_VAR 0 8
112493: PPUSH
112494: LD_VAR 0 4
112498: PPUSH
112499: LD_VAR 0 5
112503: PPUSH
112504: CALL 113723 0 5
112508: GO 112631
112510: LD_INT 302
112512: DOUBLE
112513: EQUAL
112514: IFTRUE 112518
112516: GO 112555
112518: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
112519: LD_VAR 0 6
112523: PPUSH
112524: LD_VAR 0 7
112528: PPUSH
112529: LD_VAR 0 8
112533: PPUSH
112534: LD_VAR 0 9
112538: PPUSH
112539: LD_VAR 0 4
112543: PPUSH
112544: LD_VAR 0 5
112548: PPUSH
112549: CALL 113814 0 6
112553: GO 112631
112555: LD_INT 303
112557: DOUBLE
112558: EQUAL
112559: IFTRUE 112563
112561: GO 112600
112563: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
112564: LD_VAR 0 6
112568: PPUSH
112569: LD_VAR 0 7
112573: PPUSH
112574: LD_VAR 0 8
112578: PPUSH
112579: LD_VAR 0 9
112583: PPUSH
112584: LD_VAR 0 4
112588: PPUSH
112589: LD_VAR 0 5
112593: PPUSH
112594: CALL 112636 0 6
112598: GO 112631
112600: LD_INT 304
112602: DOUBLE
112603: EQUAL
112604: IFTRUE 112608
112606: GO 112630
112608: POP
// hHackTeleport ( unit , x , y ) ; end ;
112609: LD_VAR 0 2
112613: PPUSH
112614: LD_VAR 0 4
112618: PPUSH
112619: LD_VAR 0 5
112623: PPUSH
112624: CALL 114407 0 3
112628: GO 112631
112630: POP
// end ;
112631: LD_VAR 0 12
112635: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
112636: LD_INT 0
112638: PPUSH
112639: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
112640: LD_VAR 0 1
112644: PUSH
112645: LD_INT 1
112647: LESS
112648: IFTRUE 112660
112650: PUSH
112651: LD_VAR 0 1
112655: PUSH
112656: LD_INT 3
112658: GREATER
112659: OR
112660: IFTRUE 112678
112662: PUSH
112663: LD_VAR 0 5
112667: PPUSH
112668: LD_VAR 0 6
112672: PPUSH
112673: CALL_OW 428
112677: OR
112678: IFFALSE 112682
// exit ;
112680: GO 113410
// uc_side := your_side ;
112682: LD_ADDR_OWVAR 20
112686: PUSH
112687: LD_OWVAR 2
112691: ST_TO_ADDR
// uc_nation := nation ;
112692: LD_ADDR_OWVAR 21
112696: PUSH
112697: LD_VAR 0 1
112701: ST_TO_ADDR
// bc_level = 1 ;
112702: LD_ADDR_OWVAR 43
112706: PUSH
112707: LD_INT 1
112709: ST_TO_ADDR
// case btype of 1 :
112710: LD_VAR 0 2
112714: PUSH
112715: LD_INT 1
112717: DOUBLE
112718: EQUAL
112719: IFTRUE 112723
112721: GO 112734
112723: POP
// bc_type := b_depot ; 2 :
112724: LD_ADDR_OWVAR 42
112728: PUSH
112729: LD_INT 0
112731: ST_TO_ADDR
112732: GO 113354
112734: LD_INT 2
112736: DOUBLE
112737: EQUAL
112738: IFTRUE 112742
112740: GO 112753
112742: POP
// bc_type := b_warehouse ; 3 :
112743: LD_ADDR_OWVAR 42
112747: PUSH
112748: LD_INT 1
112750: ST_TO_ADDR
112751: GO 113354
112753: LD_INT 3
112755: DOUBLE
112756: EQUAL
112757: IFTRUE 112761
112759: GO 112772
112761: POP
// bc_type := b_lab ; 4 .. 9 :
112762: LD_ADDR_OWVAR 42
112766: PUSH
112767: LD_INT 6
112769: ST_TO_ADDR
112770: GO 113354
112772: LD_INT 4
112774: DOUBLE
112775: GREATEREQUAL
112776: IFFALSE 112784
112778: LD_INT 9
112780: DOUBLE
112781: LESSEQUAL
112782: IFTRUE 112786
112784: GO 112846
112786: POP
// begin bc_type := b_lab_half ;
112787: LD_ADDR_OWVAR 42
112791: PUSH
112792: LD_INT 7
112794: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
112795: LD_ADDR_OWVAR 44
112799: PUSH
112800: LD_INT 10
112802: PUSH
112803: LD_INT 11
112805: PUSH
112806: LD_INT 12
112808: PUSH
112809: LD_INT 15
112811: PUSH
112812: LD_INT 14
112814: PUSH
112815: LD_INT 13
112817: PUSH
112818: EMPTY
112819: LIST
112820: LIST
112821: LIST
112822: LIST
112823: LIST
112824: LIST
112825: PUSH
112826: LD_VAR 0 2
112830: PUSH
112831: LD_INT 3
112833: MINUS
112834: ARRAY
112835: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
112836: LD_ADDR_OWVAR 45
112840: PUSH
112841: LD_INT 9
112843: ST_TO_ADDR
// end ; 10 .. 13 :
112844: GO 113354
112846: LD_INT 10
112848: DOUBLE
112849: GREATEREQUAL
112850: IFFALSE 112858
112852: LD_INT 13
112854: DOUBLE
112855: LESSEQUAL
112856: IFTRUE 112860
112858: GO 112937
112860: POP
// begin bc_type := b_lab_full ;
112861: LD_ADDR_OWVAR 42
112865: PUSH
112866: LD_INT 8
112868: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
112869: LD_ADDR_OWVAR 44
112873: PUSH
112874: LD_INT 10
112876: PUSH
112877: LD_INT 12
112879: PUSH
112880: LD_INT 14
112882: PUSH
112883: LD_INT 13
112885: PUSH
112886: EMPTY
112887: LIST
112888: LIST
112889: LIST
112890: LIST
112891: PUSH
112892: LD_VAR 0 2
112896: PUSH
112897: LD_INT 9
112899: MINUS
112900: ARRAY
112901: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
112902: LD_ADDR_OWVAR 45
112906: PUSH
112907: LD_INT 11
112909: PUSH
112910: LD_INT 15
112912: PUSH
112913: LD_INT 12
112915: PUSH
112916: LD_INT 15
112918: PUSH
112919: EMPTY
112920: LIST
112921: LIST
112922: LIST
112923: LIST
112924: PUSH
112925: LD_VAR 0 2
112929: PUSH
112930: LD_INT 9
112932: MINUS
112933: ARRAY
112934: ST_TO_ADDR
// end ; 14 :
112935: GO 113354
112937: LD_INT 14
112939: DOUBLE
112940: EQUAL
112941: IFTRUE 112945
112943: GO 112956
112945: POP
// bc_type := b_workshop ; 15 :
112946: LD_ADDR_OWVAR 42
112950: PUSH
112951: LD_INT 2
112953: ST_TO_ADDR
112954: GO 113354
112956: LD_INT 15
112958: DOUBLE
112959: EQUAL
112960: IFTRUE 112964
112962: GO 112975
112964: POP
// bc_type := b_factory ; 16 :
112965: LD_ADDR_OWVAR 42
112969: PUSH
112970: LD_INT 3
112972: ST_TO_ADDR
112973: GO 113354
112975: LD_INT 16
112977: DOUBLE
112978: EQUAL
112979: IFTRUE 112983
112981: GO 112994
112983: POP
// bc_type := b_ext_gun ; 17 :
112984: LD_ADDR_OWVAR 42
112988: PUSH
112989: LD_INT 17
112991: ST_TO_ADDR
112992: GO 113354
112994: LD_INT 17
112996: DOUBLE
112997: EQUAL
112998: IFTRUE 113002
113000: GO 113030
113002: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
113003: LD_ADDR_OWVAR 42
113007: PUSH
113008: LD_INT 19
113010: PUSH
113011: LD_INT 23
113013: PUSH
113014: LD_INT 19
113016: PUSH
113017: EMPTY
113018: LIST
113019: LIST
113020: LIST
113021: PUSH
113022: LD_VAR 0 1
113026: ARRAY
113027: ST_TO_ADDR
113028: GO 113354
113030: LD_INT 18
113032: DOUBLE
113033: EQUAL
113034: IFTRUE 113038
113036: GO 113049
113038: POP
// bc_type := b_ext_radar ; 19 :
113039: LD_ADDR_OWVAR 42
113043: PUSH
113044: LD_INT 20
113046: ST_TO_ADDR
113047: GO 113354
113049: LD_INT 19
113051: DOUBLE
113052: EQUAL
113053: IFTRUE 113057
113055: GO 113068
113057: POP
// bc_type := b_ext_radio ; 20 :
113058: LD_ADDR_OWVAR 42
113062: PUSH
113063: LD_INT 22
113065: ST_TO_ADDR
113066: GO 113354
113068: LD_INT 20
113070: DOUBLE
113071: EQUAL
113072: IFTRUE 113076
113074: GO 113087
113076: POP
// bc_type := b_ext_siberium ; 21 :
113077: LD_ADDR_OWVAR 42
113081: PUSH
113082: LD_INT 21
113084: ST_TO_ADDR
113085: GO 113354
113087: LD_INT 21
113089: DOUBLE
113090: EQUAL
113091: IFTRUE 113095
113093: GO 113106
113095: POP
// bc_type := b_ext_computer ; 22 :
113096: LD_ADDR_OWVAR 42
113100: PUSH
113101: LD_INT 24
113103: ST_TO_ADDR
113104: GO 113354
113106: LD_INT 22
113108: DOUBLE
113109: EQUAL
113110: IFTRUE 113114
113112: GO 113125
113114: POP
// bc_type := b_ext_track ; 23 :
113115: LD_ADDR_OWVAR 42
113119: PUSH
113120: LD_INT 16
113122: ST_TO_ADDR
113123: GO 113354
113125: LD_INT 23
113127: DOUBLE
113128: EQUAL
113129: IFTRUE 113133
113131: GO 113144
113133: POP
// bc_type := b_ext_laser ; 24 :
113134: LD_ADDR_OWVAR 42
113138: PUSH
113139: LD_INT 25
113141: ST_TO_ADDR
113142: GO 113354
113144: LD_INT 24
113146: DOUBLE
113147: EQUAL
113148: IFTRUE 113152
113150: GO 113163
113152: POP
// bc_type := b_control_tower ; 25 :
113153: LD_ADDR_OWVAR 42
113157: PUSH
113158: LD_INT 36
113160: ST_TO_ADDR
113161: GO 113354
113163: LD_INT 25
113165: DOUBLE
113166: EQUAL
113167: IFTRUE 113171
113169: GO 113182
113171: POP
// bc_type := b_breastwork ; 26 :
113172: LD_ADDR_OWVAR 42
113176: PUSH
113177: LD_INT 31
113179: ST_TO_ADDR
113180: GO 113354
113182: LD_INT 26
113184: DOUBLE
113185: EQUAL
113186: IFTRUE 113190
113188: GO 113201
113190: POP
// bc_type := b_bunker ; 27 :
113191: LD_ADDR_OWVAR 42
113195: PUSH
113196: LD_INT 32
113198: ST_TO_ADDR
113199: GO 113354
113201: LD_INT 27
113203: DOUBLE
113204: EQUAL
113205: IFTRUE 113209
113207: GO 113220
113209: POP
// bc_type := b_turret ; 28 :
113210: LD_ADDR_OWVAR 42
113214: PUSH
113215: LD_INT 33
113217: ST_TO_ADDR
113218: GO 113354
113220: LD_INT 28
113222: DOUBLE
113223: EQUAL
113224: IFTRUE 113228
113226: GO 113239
113228: POP
// bc_type := b_armoury ; 29 :
113229: LD_ADDR_OWVAR 42
113233: PUSH
113234: LD_INT 4
113236: ST_TO_ADDR
113237: GO 113354
113239: LD_INT 29
113241: DOUBLE
113242: EQUAL
113243: IFTRUE 113247
113245: GO 113258
113247: POP
// bc_type := b_barracks ; 30 :
113248: LD_ADDR_OWVAR 42
113252: PUSH
113253: LD_INT 5
113255: ST_TO_ADDR
113256: GO 113354
113258: LD_INT 30
113260: DOUBLE
113261: EQUAL
113262: IFTRUE 113266
113264: GO 113277
113266: POP
// bc_type := b_solar_power ; 31 :
113267: LD_ADDR_OWVAR 42
113271: PUSH
113272: LD_INT 27
113274: ST_TO_ADDR
113275: GO 113354
113277: LD_INT 31
113279: DOUBLE
113280: EQUAL
113281: IFTRUE 113285
113283: GO 113296
113285: POP
// bc_type := b_oil_power ; 32 :
113286: LD_ADDR_OWVAR 42
113290: PUSH
113291: LD_INT 26
113293: ST_TO_ADDR
113294: GO 113354
113296: LD_INT 32
113298: DOUBLE
113299: EQUAL
113300: IFTRUE 113304
113302: GO 113315
113304: POP
// bc_type := b_siberite_power ; 33 :
113305: LD_ADDR_OWVAR 42
113309: PUSH
113310: LD_INT 28
113312: ST_TO_ADDR
113313: GO 113354
113315: LD_INT 33
113317: DOUBLE
113318: EQUAL
113319: IFTRUE 113323
113321: GO 113334
113323: POP
// bc_type := b_oil_mine ; 34 :
113324: LD_ADDR_OWVAR 42
113328: PUSH
113329: LD_INT 29
113331: ST_TO_ADDR
113332: GO 113354
113334: LD_INT 34
113336: DOUBLE
113337: EQUAL
113338: IFTRUE 113342
113340: GO 113353
113342: POP
// bc_type := b_siberite_mine ; end ;
113343: LD_ADDR_OWVAR 42
113347: PUSH
113348: LD_INT 30
113350: ST_TO_ADDR
113351: GO 113354
113353: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
113354: LD_ADDR_VAR 0 8
113358: PUSH
113359: LD_VAR 0 5
113363: PPUSH
113364: LD_VAR 0 6
113368: PPUSH
113369: LD_VAR 0 3
113373: PPUSH
113374: CALL_OW 47
113378: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
113379: LD_OWVAR 42
113383: PUSH
113384: LD_INT 32
113386: PUSH
113387: LD_INT 33
113389: PUSH
113390: EMPTY
113391: LIST
113392: LIST
113393: IN
113394: IFFALSE 113410
// PlaceWeaponTurret ( b , weapon ) ;
113396: LD_VAR 0 8
113400: PPUSH
113401: LD_VAR 0 4
113405: PPUSH
113406: CALL_OW 431
// end ;
113410: LD_VAR 0 7
113414: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
113415: LD_INT 0
113417: PPUSH
113418: PPUSH
113419: PPUSH
113420: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113421: LD_ADDR_VAR 0 4
113425: PUSH
113426: LD_INT 22
113428: PUSH
113429: LD_OWVAR 2
113433: PUSH
113434: EMPTY
113435: LIST
113436: LIST
113437: PUSH
113438: LD_INT 2
113440: PUSH
113441: LD_INT 30
113443: PUSH
113444: LD_INT 0
113446: PUSH
113447: EMPTY
113448: LIST
113449: LIST
113450: PUSH
113451: LD_INT 30
113453: PUSH
113454: LD_INT 1
113456: PUSH
113457: EMPTY
113458: LIST
113459: LIST
113460: PUSH
113461: EMPTY
113462: LIST
113463: LIST
113464: LIST
113465: PUSH
113466: EMPTY
113467: LIST
113468: LIST
113469: PPUSH
113470: CALL_OW 69
113474: ST_TO_ADDR
// if not tmp then
113475: LD_VAR 0 4
113479: NOT
113480: IFFALSE 113484
// exit ;
113482: GO 113543
// for i in tmp do
113484: LD_ADDR_VAR 0 2
113488: PUSH
113489: LD_VAR 0 4
113493: PUSH
113494: FOR_IN
113495: IFFALSE 113541
// for j = 1 to 3 do
113497: LD_ADDR_VAR 0 3
113501: PUSH
113502: DOUBLE
113503: LD_INT 1
113505: DEC
113506: ST_TO_ADDR
113507: LD_INT 3
113509: PUSH
113510: FOR_TO
113511: IFFALSE 113537
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
113513: LD_VAR 0 2
113517: PPUSH
113518: CALL_OW 274
113522: PPUSH
113523: LD_VAR 0 3
113527: PPUSH
113528: LD_INT 99999
113530: PPUSH
113531: CALL_OW 277
113535: GO 113510
113537: POP
113538: POP
113539: GO 113494
113541: POP
113542: POP
// end ;
113543: LD_VAR 0 1
113547: RET
// export function hHackSetLevel10 ; var i , j ; begin
113548: LD_INT 0
113550: PPUSH
113551: PPUSH
113552: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
113553: LD_ADDR_VAR 0 2
113557: PUSH
113558: LD_INT 21
113560: PUSH
113561: LD_INT 1
113563: PUSH
113564: EMPTY
113565: LIST
113566: LIST
113567: PPUSH
113568: CALL_OW 69
113572: PUSH
113573: FOR_IN
113574: IFFALSE 113626
// if IsSelected ( i ) then
113576: LD_VAR 0 2
113580: PPUSH
113581: CALL_OW 306
113585: IFFALSE 113624
// begin for j := 1 to 4 do
113587: LD_ADDR_VAR 0 3
113591: PUSH
113592: DOUBLE
113593: LD_INT 1
113595: DEC
113596: ST_TO_ADDR
113597: LD_INT 4
113599: PUSH
113600: FOR_TO
113601: IFFALSE 113622
// SetSkill ( i , j , 10 ) ;
113603: LD_VAR 0 2
113607: PPUSH
113608: LD_VAR 0 3
113612: PPUSH
113613: LD_INT 10
113615: PPUSH
113616: CALL_OW 237
113620: GO 113600
113622: POP
113623: POP
// end ;
113624: GO 113573
113626: POP
113627: POP
// end ;
113628: LD_VAR 0 1
113632: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
113633: LD_INT 0
113635: PPUSH
113636: PPUSH
113637: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
113638: LD_ADDR_VAR 0 2
113642: PUSH
113643: LD_INT 22
113645: PUSH
113646: LD_OWVAR 2
113650: PUSH
113651: EMPTY
113652: LIST
113653: LIST
113654: PUSH
113655: LD_INT 21
113657: PUSH
113658: LD_INT 1
113660: PUSH
113661: EMPTY
113662: LIST
113663: LIST
113664: PUSH
113665: EMPTY
113666: LIST
113667: LIST
113668: PPUSH
113669: CALL_OW 69
113673: PUSH
113674: FOR_IN
113675: IFFALSE 113716
// begin for j := 1 to 4 do
113677: LD_ADDR_VAR 0 3
113681: PUSH
113682: DOUBLE
113683: LD_INT 1
113685: DEC
113686: ST_TO_ADDR
113687: LD_INT 4
113689: PUSH
113690: FOR_TO
113691: IFFALSE 113712
// SetSkill ( i , j , 10 ) ;
113693: LD_VAR 0 2
113697: PPUSH
113698: LD_VAR 0 3
113702: PPUSH
113703: LD_INT 10
113705: PPUSH
113706: CALL_OW 237
113710: GO 113690
113712: POP
113713: POP
// end ;
113714: GO 113674
113716: POP
113717: POP
// end ;
113718: LD_VAR 0 1
113722: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
113723: LD_INT 0
113725: PPUSH
// uc_side := your_side ;
113726: LD_ADDR_OWVAR 20
113730: PUSH
113731: LD_OWVAR 2
113735: ST_TO_ADDR
// uc_nation := nation ;
113736: LD_ADDR_OWVAR 21
113740: PUSH
113741: LD_VAR 0 1
113745: ST_TO_ADDR
// InitHc ;
113746: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
113750: LD_INT 0
113752: PPUSH
113753: LD_VAR 0 2
113757: PPUSH
113758: LD_VAR 0 3
113762: PPUSH
113763: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
113767: LD_VAR 0 4
113771: PPUSH
113772: LD_VAR 0 5
113776: PPUSH
113777: CALL_OW 428
113781: PUSH
113782: LD_INT 0
113784: EQUAL
113785: IFFALSE 113809
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
113787: CALL_OW 44
113791: PPUSH
113792: LD_VAR 0 4
113796: PPUSH
113797: LD_VAR 0 5
113801: PPUSH
113802: LD_INT 1
113804: PPUSH
113805: CALL_OW 48
// end ;
113809: LD_VAR 0 6
113813: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
113814: LD_INT 0
113816: PPUSH
113817: PPUSH
// uc_side := your_side ;
113818: LD_ADDR_OWVAR 20
113822: PUSH
113823: LD_OWVAR 2
113827: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
113828: LD_VAR 0 1
113832: PUSH
113833: LD_INT 1
113835: PUSH
113836: LD_INT 2
113838: PUSH
113839: LD_INT 3
113841: PUSH
113842: LD_INT 4
113844: PUSH
113845: LD_INT 5
113847: PUSH
113848: EMPTY
113849: LIST
113850: LIST
113851: LIST
113852: LIST
113853: LIST
113854: IN
113855: IFFALSE 113867
// uc_nation := nation_american else
113857: LD_ADDR_OWVAR 21
113861: PUSH
113862: LD_INT 1
113864: ST_TO_ADDR
113865: GO 113910
// if chassis in [ 11 , 12 , 13 , 14 ] then
113867: LD_VAR 0 1
113871: PUSH
113872: LD_INT 11
113874: PUSH
113875: LD_INT 12
113877: PUSH
113878: LD_INT 13
113880: PUSH
113881: LD_INT 14
113883: PUSH
113884: EMPTY
113885: LIST
113886: LIST
113887: LIST
113888: LIST
113889: IN
113890: IFFALSE 113902
// uc_nation := nation_arabian else
113892: LD_ADDR_OWVAR 21
113896: PUSH
113897: LD_INT 2
113899: ST_TO_ADDR
113900: GO 113910
// uc_nation := nation_russian ;
113902: LD_ADDR_OWVAR 21
113906: PUSH
113907: LD_INT 3
113909: ST_TO_ADDR
// vc_chassis := chassis ;
113910: LD_ADDR_OWVAR 37
113914: PUSH
113915: LD_VAR 0 1
113919: ST_TO_ADDR
// vc_engine := engine ;
113920: LD_ADDR_OWVAR 39
113924: PUSH
113925: LD_VAR 0 2
113929: ST_TO_ADDR
// vc_control := control ;
113930: LD_ADDR_OWVAR 38
113934: PUSH
113935: LD_VAR 0 3
113939: ST_TO_ADDR
// vc_weapon := weapon ;
113940: LD_ADDR_OWVAR 40
113944: PUSH
113945: LD_VAR 0 4
113949: ST_TO_ADDR
// un := CreateVehicle ;
113950: LD_ADDR_VAR 0 8
113954: PUSH
113955: CALL_OW 45
113959: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
113960: LD_VAR 0 8
113964: PPUSH
113965: LD_INT 0
113967: PPUSH
113968: LD_INT 5
113970: PPUSH
113971: CALL_OW 12
113975: PPUSH
113976: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
113980: LD_VAR 0 8
113984: PPUSH
113985: LD_VAR 0 5
113989: PPUSH
113990: LD_VAR 0 6
113994: PPUSH
113995: LD_INT 1
113997: PPUSH
113998: CALL_OW 48
// end ;
114002: LD_VAR 0 7
114006: RET
// export hInvincible ; every 1 do
114007: GO 114009
114009: DISABLE
// hInvincible := [ ] ;
114010: LD_ADDR_EXP 136
114014: PUSH
114015: EMPTY
114016: ST_TO_ADDR
114017: END
// every 10 do var i ;
114018: GO 114020
114020: DISABLE
114021: LD_INT 0
114023: PPUSH
// begin enable ;
114024: ENABLE
// if not hInvincible then
114025: LD_EXP 136
114029: NOT
114030: IFFALSE 114034
// exit ;
114032: GO 114078
// for i in hInvincible do
114034: LD_ADDR_VAR 0 1
114038: PUSH
114039: LD_EXP 136
114043: PUSH
114044: FOR_IN
114045: IFFALSE 114076
// if GetLives ( i ) < 1000 then
114047: LD_VAR 0 1
114051: PPUSH
114052: CALL_OW 256
114056: PUSH
114057: LD_INT 1000
114059: LESS
114060: IFFALSE 114074
// SetLives ( i , 1000 ) ;
114062: LD_VAR 0 1
114066: PPUSH
114067: LD_INT 1000
114069: PPUSH
114070: CALL_OW 234
114074: GO 114044
114076: POP
114077: POP
// end ;
114078: PPOPN 1
114080: END
// export function hHackInvincible ; var i ; begin
114081: LD_INT 0
114083: PPUSH
114084: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
114085: LD_ADDR_VAR 0 2
114089: PUSH
114090: LD_INT 2
114092: PUSH
114093: LD_INT 21
114095: PUSH
114096: LD_INT 1
114098: PUSH
114099: EMPTY
114100: LIST
114101: LIST
114102: PUSH
114103: LD_INT 21
114105: PUSH
114106: LD_INT 2
114108: PUSH
114109: EMPTY
114110: LIST
114111: LIST
114112: PUSH
114113: EMPTY
114114: LIST
114115: LIST
114116: LIST
114117: PPUSH
114118: CALL_OW 69
114122: PUSH
114123: FOR_IN
114124: IFFALSE 114185
// if IsSelected ( i ) then
114126: LD_VAR 0 2
114130: PPUSH
114131: CALL_OW 306
114135: IFFALSE 114183
// begin if i in hInvincible then
114137: LD_VAR 0 2
114141: PUSH
114142: LD_EXP 136
114146: IN
114147: IFFALSE 114167
// hInvincible := hInvincible diff i else
114149: LD_ADDR_EXP 136
114153: PUSH
114154: LD_EXP 136
114158: PUSH
114159: LD_VAR 0 2
114163: DIFF
114164: ST_TO_ADDR
114165: GO 114183
// hInvincible := hInvincible union i ;
114167: LD_ADDR_EXP 136
114171: PUSH
114172: LD_EXP 136
114176: PUSH
114177: LD_VAR 0 2
114181: UNION
114182: ST_TO_ADDR
// end ;
114183: GO 114123
114185: POP
114186: POP
// end ;
114187: LD_VAR 0 1
114191: RET
// export function hHackInvisible ; var i , j ; begin
114192: LD_INT 0
114194: PPUSH
114195: PPUSH
114196: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
114197: LD_ADDR_VAR 0 2
114201: PUSH
114202: LD_INT 21
114204: PUSH
114205: LD_INT 1
114207: PUSH
114208: EMPTY
114209: LIST
114210: LIST
114211: PPUSH
114212: CALL_OW 69
114216: PUSH
114217: FOR_IN
114218: IFFALSE 114242
// if IsSelected ( i ) then
114220: LD_VAR 0 2
114224: PPUSH
114225: CALL_OW 306
114229: IFFALSE 114240
// ComForceInvisible ( i ) ;
114231: LD_VAR 0 2
114235: PPUSH
114236: CALL_OW 496
114240: GO 114217
114242: POP
114243: POP
// end ;
114244: LD_VAR 0 1
114248: RET
// export function hHackChangeYourSide ; begin
114249: LD_INT 0
114251: PPUSH
// if your_side = 8 then
114252: LD_OWVAR 2
114256: PUSH
114257: LD_INT 8
114259: EQUAL
114260: IFFALSE 114272
// your_side := 0 else
114262: LD_ADDR_OWVAR 2
114266: PUSH
114267: LD_INT 0
114269: ST_TO_ADDR
114270: GO 114286
// your_side := your_side + 1 ;
114272: LD_ADDR_OWVAR 2
114276: PUSH
114277: LD_OWVAR 2
114281: PUSH
114282: LD_INT 1
114284: PLUS
114285: ST_TO_ADDR
// end ;
114286: LD_VAR 0 1
114290: RET
// export function hHackChangeUnitSide ; var i , j ; begin
114291: LD_INT 0
114293: PPUSH
114294: PPUSH
114295: PPUSH
// for i in all_units do
114296: LD_ADDR_VAR 0 2
114300: PUSH
114301: LD_OWVAR 3
114305: PUSH
114306: FOR_IN
114307: IFFALSE 114385
// if IsSelected ( i ) then
114309: LD_VAR 0 2
114313: PPUSH
114314: CALL_OW 306
114318: IFFALSE 114383
// begin j := GetSide ( i ) ;
114320: LD_ADDR_VAR 0 3
114324: PUSH
114325: LD_VAR 0 2
114329: PPUSH
114330: CALL_OW 255
114334: ST_TO_ADDR
// if j = 8 then
114335: LD_VAR 0 3
114339: PUSH
114340: LD_INT 8
114342: EQUAL
114343: IFFALSE 114355
// j := 0 else
114345: LD_ADDR_VAR 0 3
114349: PUSH
114350: LD_INT 0
114352: ST_TO_ADDR
114353: GO 114369
// j := j + 1 ;
114355: LD_ADDR_VAR 0 3
114359: PUSH
114360: LD_VAR 0 3
114364: PUSH
114365: LD_INT 1
114367: PLUS
114368: ST_TO_ADDR
// SetSide ( i , j ) ;
114369: LD_VAR 0 2
114373: PPUSH
114374: LD_VAR 0 3
114378: PPUSH
114379: CALL_OW 235
// end ;
114383: GO 114306
114385: POP
114386: POP
// end ;
114387: LD_VAR 0 1
114391: RET
// export function hHackFog ; begin
114392: LD_INT 0
114394: PPUSH
// FogOff ( true ) ;
114395: LD_INT 1
114397: PPUSH
114398: CALL_OW 344
// end ;
114402: LD_VAR 0 1
114406: RET
// export function hHackTeleport ( unit , x , y ) ; begin
114407: LD_INT 0
114409: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
114410: LD_VAR 0 1
114414: PPUSH
114415: LD_VAR 0 2
114419: PPUSH
114420: LD_VAR 0 3
114424: PPUSH
114425: LD_INT 1
114427: PPUSH
114428: LD_INT 1
114430: PPUSH
114431: CALL_OW 483
// CenterOnXY ( x , y ) ;
114435: LD_VAR 0 2
114439: PPUSH
114440: LD_VAR 0 3
114444: PPUSH
114445: CALL_OW 84
// end ;
114449: LD_VAR 0 4
114453: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
114454: LD_INT 0
114456: PPUSH
114457: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
114458: LD_VAR 0 1
114462: NOT
114463: IFTRUE 114482
114465: PUSH
114466: LD_VAR 0 2
114470: PPUSH
114471: LD_VAR 0 3
114475: PPUSH
114476: CALL_OW 488
114480: NOT
114481: OR
114482: IFTRUE 114517
114484: PUSH
114485: LD_VAR 0 1
114489: PPUSH
114490: CALL_OW 266
114494: PUSH
114495: LD_INT 3
114497: NONEQUAL
114498: IFFALSE 114516
114500: PUSH
114501: LD_VAR 0 1
114505: PPUSH
114506: CALL_OW 247
114510: PUSH
114511: LD_INT 1
114513: EQUAL
114514: NOT
114515: AND
114516: OR
114517: IFFALSE 114521
// exit ;
114519: GO 114803
// if GetType ( factory ) = unit_human then
114521: LD_VAR 0 1
114525: PPUSH
114526: CALL_OW 247
114530: PUSH
114531: LD_INT 1
114533: EQUAL
114534: IFFALSE 114551
// factory := IsInUnit ( factory ) ;
114536: LD_ADDR_VAR 0 1
114540: PUSH
114541: LD_VAR 0 1
114545: PPUSH
114546: CALL_OW 310
114550: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
114551: LD_VAR 0 1
114555: PPUSH
114556: CALL_OW 266
114560: PUSH
114561: LD_INT 3
114563: NONEQUAL
114564: IFFALSE 114568
// exit ;
114566: GO 114803
// for i := 1 to Count ( factoryWaypoints ) do
114568: LD_ADDR_VAR 0 5
114572: PUSH
114573: DOUBLE
114574: LD_INT 1
114576: DEC
114577: ST_TO_ADDR
114578: LD_EXP 137
114582: PPUSH
114583: CALL 13371 0 1
114587: PUSH
114588: FOR_TO
114589: IFFALSE 114751
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
114591: LD_VAR 0 2
114595: PPUSH
114596: LD_VAR 0 3
114600: PPUSH
114601: CALL_OW 428
114605: PUSH
114606: LD_EXP 137
114610: PUSH
114611: LD_VAR 0 5
114615: ARRAY
114616: PUSH
114617: LD_INT 2
114619: ARRAY
114620: EQUAL
114621: IFFALSE 114653
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
114623: LD_ADDR_EXP 137
114627: PUSH
114628: LD_EXP 137
114632: PPUSH
114633: LD_VAR 0 5
114637: PPUSH
114638: CALL_OW 3
114642: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114643: CALL 114808 0 0
// exit ;
114647: POP
114648: POP
114649: GO 114803
// end else
114651: GO 114749
// if factory = factoryWaypoints [ i ] [ 2 ] then
114653: LD_VAR 0 1
114657: PUSH
114658: LD_EXP 137
114662: PUSH
114663: LD_VAR 0 5
114667: ARRAY
114668: PUSH
114669: LD_INT 2
114671: ARRAY
114672: EQUAL
114673: IFFALSE 114749
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
114675: LD_ADDR_EXP 137
114679: PUSH
114680: LD_EXP 137
114684: PPUSH
114685: LD_VAR 0 5
114689: PPUSH
114690: CALL_OW 3
114694: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
114695: LD_ADDR_EXP 137
114699: PUSH
114700: LD_EXP 137
114704: PPUSH
114705: LD_VAR 0 1
114709: PPUSH
114710: CALL_OW 255
114714: PUSH
114715: LD_VAR 0 1
114719: PUSH
114720: LD_VAR 0 2
114724: PUSH
114725: LD_VAR 0 3
114729: PUSH
114730: EMPTY
114731: LIST
114732: LIST
114733: LIST
114734: LIST
114735: PPUSH
114736: CALL 49347 0 2
114740: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114741: CALL 114808 0 0
// exit ;
114745: POP
114746: POP
114747: GO 114803
// end ; end ;
114749: GO 114588
114751: POP
114752: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
114753: LD_ADDR_EXP 137
114757: PUSH
114758: LD_EXP 137
114762: PPUSH
114763: LD_VAR 0 1
114767: PPUSH
114768: CALL_OW 255
114772: PUSH
114773: LD_VAR 0 1
114777: PUSH
114778: LD_VAR 0 2
114782: PUSH
114783: LD_VAR 0 3
114787: PUSH
114788: EMPTY
114789: LIST
114790: LIST
114791: LIST
114792: LIST
114793: PPUSH
114794: CALL 49347 0 2
114798: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114799: CALL 114808 0 0
// end ;
114803: LD_VAR 0 4
114807: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
114808: LD_INT 0
114810: PPUSH
114811: PPUSH
114812: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
114813: LD_STRING resetFactoryWaypoint();
114815: PPUSH
114816: CALL_OW 559
// if factoryWaypoints then
114820: LD_EXP 137
114824: IFFALSE 114945
// begin list := factoryWaypoints ;
114826: LD_ADDR_VAR 0 3
114830: PUSH
114831: LD_EXP 137
114835: ST_TO_ADDR
// for i := 1 to list do
114836: LD_ADDR_VAR 0 2
114840: PUSH
114841: DOUBLE
114842: LD_INT 1
114844: DEC
114845: ST_TO_ADDR
114846: LD_VAR 0 3
114850: PUSH
114851: FOR_TO
114852: IFFALSE 114943
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
114854: LD_STRING setFactoryWaypointXY(
114856: PUSH
114857: LD_VAR 0 3
114861: PUSH
114862: LD_VAR 0 2
114866: ARRAY
114867: PUSH
114868: LD_INT 1
114870: ARRAY
114871: STR
114872: PUSH
114873: LD_STRING ,
114875: STR
114876: PUSH
114877: LD_VAR 0 3
114881: PUSH
114882: LD_VAR 0 2
114886: ARRAY
114887: PUSH
114888: LD_INT 2
114890: ARRAY
114891: STR
114892: PUSH
114893: LD_STRING ,
114895: STR
114896: PUSH
114897: LD_VAR 0 3
114901: PUSH
114902: LD_VAR 0 2
114906: ARRAY
114907: PUSH
114908: LD_INT 3
114910: ARRAY
114911: STR
114912: PUSH
114913: LD_STRING ,
114915: STR
114916: PUSH
114917: LD_VAR 0 3
114921: PUSH
114922: LD_VAR 0 2
114926: ARRAY
114927: PUSH
114928: LD_INT 4
114930: ARRAY
114931: STR
114932: PUSH
114933: LD_STRING )
114935: STR
114936: PPUSH
114937: CALL_OW 559
114941: GO 114851
114943: POP
114944: POP
// end ; end ;
114945: LD_VAR 0 1
114949: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
114950: LD_INT 0
114952: PPUSH
// if HexInfo ( x , y ) = warehouse then
114953: LD_VAR 0 2
114957: PPUSH
114958: LD_VAR 0 3
114962: PPUSH
114963: CALL_OW 428
114967: PUSH
114968: LD_VAR 0 1
114972: EQUAL
114973: IFFALSE 115000
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
114975: LD_ADDR_EXP 139
114979: PUSH
114980: LD_EXP 139
114984: PPUSH
114985: LD_VAR 0 1
114989: PPUSH
114990: LD_INT 0
114992: PPUSH
114993: CALL_OW 1
114997: ST_TO_ADDR
114998: GO 115051
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
115000: LD_ADDR_EXP 139
115004: PUSH
115005: LD_EXP 139
115009: PPUSH
115010: LD_VAR 0 1
115014: PPUSH
115015: LD_VAR 0 1
115019: PPUSH
115020: CALL_OW 255
115024: PUSH
115025: LD_VAR 0 1
115029: PUSH
115030: LD_VAR 0 2
115034: PUSH
115035: LD_VAR 0 3
115039: PUSH
115040: EMPTY
115041: LIST
115042: LIST
115043: LIST
115044: LIST
115045: PPUSH
115046: CALL_OW 1
115050: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
115051: CALL 115060 0 0
// end ;
115055: LD_VAR 0 4
115059: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
115060: LD_INT 0
115062: PPUSH
115063: PPUSH
115064: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
115065: LD_STRING resetWarehouseGatheringPoints();
115067: PPUSH
115068: CALL_OW 559
// if warehouseGatheringPoints then
115072: LD_EXP 139
115076: IFFALSE 115202
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
115078: LD_ADDR_VAR 0 3
115082: PUSH
115083: LD_EXP 139
115087: PPUSH
115088: CALL 53281 0 1
115092: ST_TO_ADDR
// for i := 1 to list do
115093: LD_ADDR_VAR 0 2
115097: PUSH
115098: DOUBLE
115099: LD_INT 1
115101: DEC
115102: ST_TO_ADDR
115103: LD_VAR 0 3
115107: PUSH
115108: FOR_TO
115109: IFFALSE 115200
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
115111: LD_STRING setWarehouseGatheringPointXY(
115113: PUSH
115114: LD_VAR 0 3
115118: PUSH
115119: LD_VAR 0 2
115123: ARRAY
115124: PUSH
115125: LD_INT 1
115127: ARRAY
115128: STR
115129: PUSH
115130: LD_STRING ,
115132: STR
115133: PUSH
115134: LD_VAR 0 3
115138: PUSH
115139: LD_VAR 0 2
115143: ARRAY
115144: PUSH
115145: LD_INT 2
115147: ARRAY
115148: STR
115149: PUSH
115150: LD_STRING ,
115152: STR
115153: PUSH
115154: LD_VAR 0 3
115158: PUSH
115159: LD_VAR 0 2
115163: ARRAY
115164: PUSH
115165: LD_INT 3
115167: ARRAY
115168: STR
115169: PUSH
115170: LD_STRING ,
115172: STR
115173: PUSH
115174: LD_VAR 0 3
115178: PUSH
115179: LD_VAR 0 2
115183: ARRAY
115184: PUSH
115185: LD_INT 4
115187: ARRAY
115188: STR
115189: PUSH
115190: LD_STRING )
115192: STR
115193: PPUSH
115194: CALL_OW 559
115198: GO 115108
115200: POP
115201: POP
// end ; end ;
115202: LD_VAR 0 1
115206: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
115207: LD_EXP 139
115211: IFFALSE 115906
115213: GO 115215
115215: DISABLE
115216: LD_INT 0
115218: PPUSH
115219: PPUSH
115220: PPUSH
115221: PPUSH
115222: PPUSH
115223: PPUSH
115224: PPUSH
115225: PPUSH
115226: PPUSH
// begin enable ;
115227: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
115228: LD_ADDR_VAR 0 3
115232: PUSH
115233: LD_EXP 139
115237: PPUSH
115238: CALL 53281 0 1
115242: ST_TO_ADDR
// if not list then
115243: LD_VAR 0 3
115247: NOT
115248: IFFALSE 115252
// exit ;
115250: GO 115906
// for i := 1 to list do
115252: LD_ADDR_VAR 0 1
115256: PUSH
115257: DOUBLE
115258: LD_INT 1
115260: DEC
115261: ST_TO_ADDR
115262: LD_VAR 0 3
115266: PUSH
115267: FOR_TO
115268: IFFALSE 115904
// begin depot := list [ i ] [ 2 ] ;
115270: LD_ADDR_VAR 0 8
115274: PUSH
115275: LD_VAR 0 3
115279: PUSH
115280: LD_VAR 0 1
115284: ARRAY
115285: PUSH
115286: LD_INT 2
115288: ARRAY
115289: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
115290: LD_ADDR_VAR 0 5
115294: PUSH
115295: LD_VAR 0 3
115299: PUSH
115300: LD_VAR 0 1
115304: ARRAY
115305: PUSH
115306: LD_INT 1
115308: ARRAY
115309: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
115310: LD_VAR 0 8
115314: PPUSH
115315: CALL_OW 301
115319: IFTRUE 115338
115321: PUSH
115322: LD_VAR 0 5
115326: PUSH
115327: LD_VAR 0 8
115331: PPUSH
115332: CALL_OW 255
115336: NONEQUAL
115337: OR
115338: IFFALSE 115367
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
115340: LD_ADDR_EXP 139
115344: PUSH
115345: LD_EXP 139
115349: PPUSH
115350: LD_VAR 0 8
115354: PPUSH
115355: LD_INT 0
115357: PPUSH
115358: CALL_OW 1
115362: ST_TO_ADDR
// exit ;
115363: POP
115364: POP
115365: GO 115906
// end ; x := list [ i ] [ 3 ] ;
115367: LD_ADDR_VAR 0 6
115371: PUSH
115372: LD_VAR 0 3
115376: PUSH
115377: LD_VAR 0 1
115381: ARRAY
115382: PUSH
115383: LD_INT 3
115385: ARRAY
115386: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
115387: LD_ADDR_VAR 0 7
115391: PUSH
115392: LD_VAR 0 3
115396: PUSH
115397: LD_VAR 0 1
115401: ARRAY
115402: PUSH
115403: LD_INT 4
115405: ARRAY
115406: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
115407: LD_ADDR_VAR 0 9
115411: PUSH
115412: LD_VAR 0 6
115416: PPUSH
115417: LD_VAR 0 7
115421: PPUSH
115422: LD_INT 16
115424: PPUSH
115425: CALL 51855 0 3
115429: ST_TO_ADDR
// if not cratesNearbyPoint then
115430: LD_VAR 0 9
115434: NOT
115435: IFFALSE 115441
// exit ;
115437: POP
115438: POP
115439: GO 115906
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
115441: LD_ADDR_VAR 0 4
115445: PUSH
115446: LD_INT 22
115448: PUSH
115449: LD_VAR 0 5
115453: PUSH
115454: EMPTY
115455: LIST
115456: LIST
115457: PUSH
115458: LD_INT 3
115460: PUSH
115461: LD_INT 60
115463: PUSH
115464: EMPTY
115465: LIST
115466: PUSH
115467: EMPTY
115468: LIST
115469: LIST
115470: PUSH
115471: LD_INT 91
115473: PUSH
115474: LD_VAR 0 8
115478: PUSH
115479: LD_INT 6
115481: PUSH
115482: EMPTY
115483: LIST
115484: LIST
115485: LIST
115486: PUSH
115487: LD_INT 2
115489: PUSH
115490: LD_INT 25
115492: PUSH
115493: LD_INT 2
115495: PUSH
115496: EMPTY
115497: LIST
115498: LIST
115499: PUSH
115500: LD_INT 25
115502: PUSH
115503: LD_INT 16
115505: PUSH
115506: EMPTY
115507: LIST
115508: LIST
115509: PUSH
115510: EMPTY
115511: LIST
115512: LIST
115513: LIST
115514: PUSH
115515: EMPTY
115516: LIST
115517: LIST
115518: LIST
115519: LIST
115520: PPUSH
115521: CALL_OW 69
115525: PUSH
115526: LD_VAR 0 8
115530: PPUSH
115531: CALL_OW 313
115535: PPUSH
115536: LD_INT 3
115538: PUSH
115539: LD_INT 60
115541: PUSH
115542: EMPTY
115543: LIST
115544: PUSH
115545: EMPTY
115546: LIST
115547: LIST
115548: PUSH
115549: LD_INT 2
115551: PUSH
115552: LD_INT 25
115554: PUSH
115555: LD_INT 2
115557: PUSH
115558: EMPTY
115559: LIST
115560: LIST
115561: PUSH
115562: LD_INT 25
115564: PUSH
115565: LD_INT 16
115567: PUSH
115568: EMPTY
115569: LIST
115570: LIST
115571: PUSH
115572: EMPTY
115573: LIST
115574: LIST
115575: LIST
115576: PUSH
115577: EMPTY
115578: LIST
115579: LIST
115580: PPUSH
115581: CALL_OW 72
115585: UNION
115586: ST_TO_ADDR
// if tmp then
115587: LD_VAR 0 4
115591: IFFALSE 115671
// begin tmp := ShrinkArray ( tmp , 3 ) ;
115593: LD_ADDR_VAR 0 4
115597: PUSH
115598: LD_VAR 0 4
115602: PPUSH
115603: LD_INT 3
115605: PPUSH
115606: CALL 49662 0 2
115610: ST_TO_ADDR
// for j in tmp do
115611: LD_ADDR_VAR 0 2
115615: PUSH
115616: LD_VAR 0 4
115620: PUSH
115621: FOR_IN
115622: IFFALSE 115665
// begin if IsInUnit ( j ) then
115624: LD_VAR 0 2
115628: PPUSH
115629: CALL_OW 310
115633: IFFALSE 115644
// ComExit ( j ) ;
115635: LD_VAR 0 2
115639: PPUSH
115640: CALL 49745 0 1
// AddComCollect ( j , x , y ) ;
115644: LD_VAR 0 2
115648: PPUSH
115649: LD_VAR 0 6
115653: PPUSH
115654: LD_VAR 0 7
115658: PPUSH
115659: CALL_OW 177
// end ;
115663: GO 115621
115665: POP
115666: POP
// exit ;
115667: POP
115668: POP
115669: GO 115906
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
115671: LD_ADDR_VAR 0 4
115675: PUSH
115676: LD_INT 22
115678: PUSH
115679: LD_VAR 0 5
115683: PUSH
115684: EMPTY
115685: LIST
115686: LIST
115687: PUSH
115688: LD_INT 91
115690: PUSH
115691: LD_VAR 0 8
115695: PUSH
115696: LD_INT 8
115698: PUSH
115699: EMPTY
115700: LIST
115701: LIST
115702: LIST
115703: PUSH
115704: LD_INT 2
115706: PUSH
115707: LD_INT 34
115709: PUSH
115710: LD_INT 12
115712: PUSH
115713: EMPTY
115714: LIST
115715: LIST
115716: PUSH
115717: LD_INT 34
115719: PUSH
115720: LD_INT 51
115722: PUSH
115723: EMPTY
115724: LIST
115725: LIST
115726: PUSH
115727: LD_INT 34
115729: PUSH
115730: LD_INT 32
115732: PUSH
115733: EMPTY
115734: LIST
115735: LIST
115736: PUSH
115737: LD_INT 34
115739: PUSH
115740: LD_INT 89
115742: PUSH
115743: EMPTY
115744: LIST
115745: LIST
115746: PUSH
115747: EMPTY
115748: LIST
115749: LIST
115750: LIST
115751: LIST
115752: LIST
115753: PUSH
115754: EMPTY
115755: LIST
115756: LIST
115757: LIST
115758: PPUSH
115759: CALL_OW 69
115763: ST_TO_ADDR
// if tmp then
115764: LD_VAR 0 4
115768: IFFALSE 115902
// begin for j in tmp do
115770: LD_ADDR_VAR 0 2
115774: PUSH
115775: LD_VAR 0 4
115779: PUSH
115780: FOR_IN
115781: IFFALSE 115900
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
115783: LD_VAR 0 2
115787: PPUSH
115788: CALL_OW 262
115792: PUSH
115793: LD_INT 3
115795: EQUAL
115796: IFTRUE 115813
115798: PUSH
115799: LD_VAR 0 2
115803: PPUSH
115804: CALL_OW 261
115808: PUSH
115809: LD_INT 20
115811: GREATER
115812: OR
115813: IFFALSE 115827
115815: PUSH
115816: LD_VAR 0 2
115820: PPUSH
115821: CALL_OW 314
115825: NOT
115826: AND
115827: IFFALSE 115857
115829: PUSH
115830: LD_VAR 0 2
115834: PPUSH
115835: CALL_OW 263
115839: PUSH
115840: LD_INT 1
115842: NONEQUAL
115843: IFTRUE 115856
115845: PUSH
115846: LD_VAR 0 2
115850: PPUSH
115851: CALL_OW 311
115855: OR
115856: AND
115857: IFFALSE 115898
// begin ComCollect ( j , x , y ) ;
115859: LD_VAR 0 2
115863: PPUSH
115864: LD_VAR 0 6
115868: PPUSH
115869: LD_VAR 0 7
115873: PPUSH
115874: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
115878: LD_VAR 0 2
115882: PPUSH
115883: LD_VAR 0 8
115887: PPUSH
115888: CALL_OW 172
// exit ;
115892: POP
115893: POP
115894: POP
115895: POP
115896: GO 115906
// end ;
115898: GO 115780
115900: POP
115901: POP
// end ; end ;
115902: GO 115267
115904: POP
115905: POP
// end ; end_of_file
115906: PPOPN 9
115908: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115909: LD_VAR 0 1
115913: PPUSH
115914: LD_VAR 0 2
115918: PPUSH
115919: LD_VAR 0 3
115923: PPUSH
115924: LD_VAR 0 4
115928: PPUSH
115929: LD_VAR 0 5
115933: PPUSH
115934: LD_VAR 0 6
115938: PPUSH
115939: CALL 100002 0 6
// end ;
115943: PPOPN 6
115945: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115946: LD_INT 0
115948: PPUSH
// begin if not units then
115949: LD_VAR 0 1
115953: NOT
115954: IFFALSE 115958
// exit ;
115956: GO 115992
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
115958: LD_VAR 0 1
115962: PPUSH
115963: LD_VAR 0 2
115967: PPUSH
115968: LD_VAR 0 3
115972: PPUSH
115973: LD_VAR 0 4
115977: PPUSH
115978: LD_VAR 0 5
115982: PPUSH
115983: LD_VAR 0 6
115987: PPUSH
115988: CALL 99633 0 6
// end ;
115992: PPOPN 7
115994: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115995: CALL 99882 0 0
// end ;
115999: PPOPN 1
116001: END
