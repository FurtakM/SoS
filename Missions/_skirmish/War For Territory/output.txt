// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 206 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45130 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45130 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45130 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45130 0 9
// PrepareGensher ;
 185: CALL 3138 0 0
// PreparePopov ;
 189: CALL 6331 0 0
// PreparePowell ;
 193: CALL 585 0 0
// PrepareSikorski ;
 197: CALL 9005 0 0
// MC_Start ( ) ;
 201: CALL 54566 0 0
// end ;
 205: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 206: LD_INT 0
 208: PPUSH
// debug := 1 ;
 209: LD_ADDR_EXP 1
 213: PUSH
 214: LD_INT 1
 216: ST_TO_ADDR
// game := true ;
 217: LD_ADDR_EXP 2
 221: PUSH
 222: LD_INT 1
 224: ST_TO_ADDR
// staticMines := [ ] ;
 225: LD_ADDR_EXP 3
 229: PUSH
 230: EMPTY
 231: ST_TO_ADDR
// arDestroyed := false ;
 232: LD_ADDR_EXP 4
 236: PUSH
 237: LD_INT 0
 239: ST_TO_ADDR
// ruDestroyed := false ;
 240: LD_ADDR_EXP 5
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// powellInTrouble := false ;
 248: LD_ADDR_EXP 8
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// sikorskiInTrouble := false ;
 256: LD_ADDR_EXP 9
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// end ;
 264: LD_VAR 0 1
 268: RET
// export function CustomInitMacro ; begin
 269: LD_INT 0
 271: PPUSH
// InitMC_Gensher ( ) ;
 272: CALL 4258 0 0
// InitMC_Powell ( ) ;
 276: CALL 1493 0 0
// InitMC_Popov ( ) ;
 280: CALL 7475 0 0
// end ;
 284: LD_VAR 0 1
 288: RET
// every 0 0$10 do var cr , time , i ;
 289: GO 291
 291: DISABLE
 292: LD_INT 0
 294: PPUSH
 295: PPUSH
 296: PPUSH
// begin time := 0 0$20 ;
 297: LD_ADDR_VAR 0 2
 301: PUSH
 302: LD_INT 700
 304: ST_TO_ADDR
// repeat wait ( time ) ;
 305: LD_VAR 0 2
 309: PPUSH
 310: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 314: LD_ADDR_VAR 0 1
 318: PUSH
 319: LD_INT 1
 321: PPUSH
 322: LD_INT 5
 324: PPUSH
 325: CALL_OW 12
 329: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 330: LD_ADDR_VAR 0 3
 334: PUSH
 335: LD_INT 5
 337: PUSH
 338: LD_INT 8
 340: PUSH
 341: LD_INT 12
 343: PUSH
 344: LD_INT 13
 346: PUSH
 347: EMPTY
 348: LIST
 349: LIST
 350: LIST
 351: LIST
 352: PUSH
 353: FOR_IN
 354: IFFALSE 408
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 356: LD_VAR 0 3
 360: PPUSH
 361: LD_INT 1
 363: PPUSH
 364: CALL_OW 287
 368: PUSH
 369: LD_INT 40
 371: LESS
 372: IFFALSE 391
// CreateCratesArea ( cr , i , true ) ;
 374: LD_VAR 0 1
 378: PPUSH
 379: LD_VAR 0 3
 383: PPUSH
 384: LD_INT 1
 386: PPUSH
 387: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 391: LD_INT 175
 393: PPUSH
 394: LD_INT 525
 396: PPUSH
 397: CALL_OW 12
 401: PPUSH
 402: CALL_OW 67
// end ;
 406: GO 353
 408: POP
 409: POP
// time := time + 0 0$2 ;
 410: LD_ADDR_VAR 0 2
 414: PUSH
 415: LD_VAR 0 2
 419: PUSH
 420: LD_INT 70
 422: PLUS
 423: ST_TO_ADDR
// if time > 0 0$35 then
 424: LD_VAR 0 2
 428: PUSH
 429: LD_INT 1225
 431: GREATER
 432: IFFALSE 442
// time := 0 0$25 ;
 434: LD_ADDR_VAR 0 2
 438: PUSH
 439: LD_INT 875
 441: ST_TO_ADDR
// until not game ;
 442: LD_EXP 2
 446: NOT
 447: IFFALSE 305
// end ;
 449: PPOPN 3
 451: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 452: LD_INT 3
 454: PUSH
 455: LD_INT 22
 457: PUSH
 458: LD_INT 1
 460: PUSH
 461: EMPTY
 462: LIST
 463: LIST
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 1
 474: PUSH
 475: EMPTY
 476: LIST
 477: LIST
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PPUSH
 483: CALL_OW 69
 487: IFFALSE 582
 489: GO 491
 491: DISABLE
 492: LD_INT 0
 494: PPUSH
 495: PPUSH
// begin enable ;
 496: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 497: LD_ADDR_VAR 0 2
 501: PUSH
 502: LD_INT 3
 504: PUSH
 505: LD_INT 22
 507: PUSH
 508: LD_INT 1
 510: PUSH
 511: EMPTY
 512: LIST
 513: LIST
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 32
 521: PUSH
 522: LD_INT 1
 524: PUSH
 525: EMPTY
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL_OW 69
 537: ST_TO_ADDR
// for i in tmp do
 538: LD_ADDR_VAR 0 1
 542: PUSH
 543: LD_VAR 0 2
 547: PUSH
 548: FOR_IN
 549: IFFALSE 580
// if GetFuel ( i ) < 5 then
 551: LD_VAR 0 1
 555: PPUSH
 556: CALL_OW 261
 560: PUSH
 561: LD_INT 5
 563: LESS
 564: IFFALSE 578
// SetFuel ( i , 5 ) ;
 566: LD_VAR 0 1
 570: PPUSH
 571: LD_INT 5
 573: PPUSH
 574: CALL_OW 240
 578: GO 548
 580: POP
 581: POP
// end ; end_of_file
 582: PPOPN 2
 584: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 585: LD_INT 0
 587: PPUSH
 588: PPUSH
 589: PPUSH
 590: PPUSH
 591: PPUSH
// powell_side := 4 ;
 592: LD_ADDR_EXP 11
 596: PUSH
 597: LD_INT 4
 599: ST_TO_ADDR
// uc_side := powell_side ;
 600: LD_ADDR_OWVAR 20
 604: PUSH
 605: LD_EXP 11
 609: ST_TO_ADDR
// uc_nation := 1 ;
 610: LD_ADDR_OWVAR 21
 614: PUSH
 615: LD_INT 1
 617: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 618: LD_ADDR_EXP 10
 622: PUSH
 623: LD_STRING Powell
 625: PPUSH
 626: CALL_OW 25
 630: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 631: LD_EXP 10
 635: PPUSH
 636: LD_INT 1
 638: PPUSH
 639: LD_INT 7
 641: PPUSH
 642: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 646: LD_EXP 10
 650: PPUSH
 651: LD_INT 2
 653: PPUSH
 654: LD_INT 5
 656: PPUSH
 657: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 661: LD_EXP 10
 665: PPUSH
 666: LD_INT 3
 668: PPUSH
 669: LD_INT 6
 671: PPUSH
 672: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 676: LD_EXP 10
 680: PPUSH
 681: LD_INT 4
 683: PPUSH
 684: LD_INT 4
 686: PPUSH
 687: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 691: LD_EXP 10
 695: PPUSH
 696: LD_INT 4
 698: PPUSH
 699: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 703: LD_ADDR_VAR 0 3
 707: PUSH
 708: LD_INT 5
 710: PUSH
 711: LD_INT 178
 713: PUSH
 714: LD_INT 117
 716: PUSH
 717: LD_INT 2
 719: PUSH
 720: EMPTY
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PUSH
 726: LD_INT 29
 728: PUSH
 729: LD_INT 167
 731: PUSH
 732: LD_INT 102
 734: PUSH
 735: LD_INT 0
 737: PUSH
 738: EMPTY
 739: LIST
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_INT 6
 746: PUSH
 747: LD_INT 200
 749: PUSH
 750: LD_INT 111
 752: PUSH
 753: LD_INT 4
 755: PUSH
 756: LD_INT 10
 758: PUSH
 759: LD_INT 11
 761: PUSH
 762: EMPTY
 763: LIST
 764: LIST
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PUSH
 770: LD_INT 3
 772: PUSH
 773: LD_INT 201
 775: PUSH
 776: LD_INT 140
 778: PUSH
 779: LD_INT 4
 781: PUSH
 782: EMPTY
 783: LIST
 784: LIST
 785: LIST
 786: LIST
 787: PUSH
 788: LD_INT 27
 790: PUSH
 791: LD_INT 206
 793: PUSH
 794: LD_INT 124
 796: PUSH
 797: LD_INT 3
 799: PUSH
 800: EMPTY
 801: LIST
 802: LIST
 803: LIST
 804: LIST
 805: PUSH
 806: LD_INT 27
 808: PUSH
 809: LD_INT 209
 811: PUSH
 812: LD_INT 128
 814: PUSH
 815: LD_INT 3
 817: PUSH
 818: EMPTY
 819: LIST
 820: LIST
 821: LIST
 822: LIST
 823: PUSH
 824: LD_INT 27
 826: PUSH
 827: LD_INT 211
 829: PUSH
 830: LD_INT 132
 832: PUSH
 833: LD_INT 3
 835: PUSH
 836: EMPTY
 837: LIST
 838: LIST
 839: LIST
 840: LIST
 841: PUSH
 842: LD_INT 30
 844: PUSH
 845: LD_INT 173
 847: PUSH
 848: LD_INT 83
 850: PUSH
 851: LD_INT 3
 853: PUSH
 854: EMPTY
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PUSH
 860: LD_INT 6
 862: PUSH
 863: LD_INT 186
 865: PUSH
 866: LD_INT 103
 868: PUSH
 869: LD_INT 2
 871: PUSH
 872: LD_INT 12
 874: PUSH
 875: LD_INT 15
 877: PUSH
 878: EMPTY
 879: LIST
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: LIST
 885: PUSH
 886: LD_INT 33
 888: PUSH
 889: LD_INT 173
 891: PUSH
 892: LD_INT 99
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 6
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_INT 32
 910: PUSH
 911: LD_INT 174
 913: PUSH
 914: LD_INT 102
 916: PUSH
 917: LD_INT 2
 919: PUSH
 920: LD_INT 6
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: LIST
 927: LIST
 928: LIST
 929: PUSH
 930: LD_INT 32
 932: PUSH
 933: LD_INT 178
 935: PUSH
 936: LD_INT 100
 938: PUSH
 939: LD_INT 2
 941: PUSH
 942: LD_INT 6
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: PUSH
 952: LD_INT 33
 954: PUSH
 955: LD_INT 174
 957: PUSH
 958: LD_INT 108
 960: PUSH
 961: LD_INT 1
 963: PUSH
 964: LD_INT 7
 966: PUSH
 967: EMPTY
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 33
 976: PUSH
 977: LD_INT 182
 979: PUSH
 980: LD_INT 122
 982: PUSH
 983: LD_INT 1
 985: PUSH
 986: LD_INT 7
 988: PUSH
 989: EMPTY
 990: LIST
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 36
 998: PUSH
 999: LD_INT 194
1001: PUSH
1002: LD_INT 124
1004: PUSH
1005: LD_INT 5
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 33
1016: PUSH
1017: LD_INT 184
1019: PUSH
1020: LD_INT 141
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 6
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: LD_INT 33
1038: PUSH
1039: LD_INT 183
1041: PUSH
1042: LD_INT 131
1044: PUSH
1045: LD_INT 2
1047: PUSH
1048: LD_INT 11
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: PUSH
1058: LD_INT 33
1060: PUSH
1061: LD_INT 194
1063: PUSH
1064: LD_INT 146
1066: PUSH
1067: LD_INT 4
1069: PUSH
1070: LD_INT 7
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: LIST
1077: LIST
1078: LIST
1079: PUSH
1080: LD_INT 33
1082: PUSH
1083: LD_INT 190
1085: PUSH
1086: LD_INT 142
1088: PUSH
1089: LD_INT 4
1091: PUSH
1092: LD_INT 7
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: PUSH
1102: LD_INT 28
1104: PUSH
1105: LD_INT 204
1107: PUSH
1108: LD_INT 133
1110: PUSH
1111: LD_INT 3
1113: PUSH
1114: EMPTY
1115: LIST
1116: LIST
1117: LIST
1118: LIST
1119: PUSH
1120: LD_INT 27
1122: PUSH
1123: LD_INT 201
1125: PUSH
1126: LD_INT 133
1128: PUSH
1129: LD_INT 3
1131: PUSH
1132: EMPTY
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PUSH
1138: LD_INT 28
1140: PUSH
1141: LD_INT 199
1143: PUSH
1144: LD_INT 119
1146: PUSH
1147: LD_INT 5
1149: PUSH
1150: EMPTY
1151: LIST
1152: LIST
1153: LIST
1154: LIST
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: ST_TO_ADDR
// for i in list do
1180: LD_ADDR_VAR 0 2
1184: PUSH
1185: LD_VAR 0 3
1189: PUSH
1190: FOR_IN
1191: IFFALSE 1355
// begin uc_side := 4 ;
1193: LD_ADDR_OWVAR 20
1197: PUSH
1198: LD_INT 4
1200: ST_TO_ADDR
// uc_nation := 1 ;
1201: LD_ADDR_OWVAR 21
1205: PUSH
1206: LD_INT 1
1208: ST_TO_ADDR
// InitBc ;
1209: CALL_OW 21
// bc_type := i [ 1 ] ;
1213: LD_ADDR_OWVAR 42
1217: PUSH
1218: LD_VAR 0 2
1222: PUSH
1223: LD_INT 1
1225: ARRAY
1226: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1227: LD_VAR 0 2
1231: PUSH
1232: LD_INT 1
1234: ARRAY
1235: PUSH
1236: LD_INT 6
1238: EQUAL
1239: IFFALSE 1277
// begin bc_type := b_lab_full ;
1241: LD_ADDR_OWVAR 42
1245: PUSH
1246: LD_INT 8
1248: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1249: LD_ADDR_OWVAR 44
1253: PUSH
1254: LD_VAR 0 2
1258: PUSH
1259: LD_INT 5
1261: ARRAY
1262: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1263: LD_ADDR_OWVAR 45
1267: PUSH
1268: LD_VAR 0 2
1272: PUSH
1273: LD_INT 6
1275: ARRAY
1276: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1277: LD_ADDR_VAR 0 4
1281: PUSH
1282: LD_VAR 0 2
1286: PUSH
1287: LD_INT 2
1289: ARRAY
1290: PPUSH
1291: LD_VAR 0 2
1295: PUSH
1296: LD_INT 3
1298: ARRAY
1299: PPUSH
1300: LD_VAR 0 2
1304: PUSH
1305: LD_INT 4
1307: ARRAY
1308: PPUSH
1309: CALL_OW 47
1313: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1314: LD_VAR 0 2
1318: PUSH
1319: LD_INT 1
1321: ARRAY
1322: PUSH
1323: LD_INT 33
1325: PUSH
1326: LD_INT 32
1328: PUSH
1329: EMPTY
1330: LIST
1331: LIST
1332: IN
1333: IFFALSE 1353
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1335: LD_VAR 0 4
1339: PPUSH
1340: LD_VAR 0 2
1344: PUSH
1345: LD_INT 5
1347: ARRAY
1348: PPUSH
1349: CALL_OW 431
// end ;
1353: GO 1190
1355: POP
1356: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1357: LD_ADDR_VAR 0 5
1361: PUSH
1362: LD_INT 4
1364: PPUSH
1365: LD_INT 1
1367: PPUSH
1368: LD_STRING 
1370: PPUSH
1371: LD_INT 8
1373: PUSH
1374: LD_INT 7
1376: PUSH
1377: LD_INT 6
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: LIST
1384: PUSH
1385: LD_OWVAR 67
1389: ARRAY
1390: PPUSH
1391: LD_INT 5500
1393: PUSH
1394: LD_INT 500
1396: PUSH
1397: LD_INT 0
1399: PUSH
1400: EMPTY
1401: LIST
1402: LIST
1403: LIST
1404: PPUSH
1405: LD_INT 6
1407: PUSH
1408: LD_INT 6
1410: PUSH
1411: LD_INT 6
1413: PUSH
1414: LD_INT 6
1416: PUSH
1417: EMPTY
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: PPUSH
1423: CALL 19432 0 6
1427: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1428: LD_ADDR_EXP 23
1432: PUSH
1433: LD_EXP 23
1437: PPUSH
1438: LD_INT 1
1440: PPUSH
1441: LD_VAR 0 5
1445: PUSH
1446: LD_INT 22
1448: PUSH
1449: LD_INT 4
1451: PUSH
1452: EMPTY
1453: LIST
1454: LIST
1455: PUSH
1456: LD_INT 21
1458: PUSH
1459: LD_INT 3
1461: PUSH
1462: EMPTY
1463: LIST
1464: LIST
1465: PUSH
1466: EMPTY
1467: LIST
1468: LIST
1469: PPUSH
1470: CALL_OW 69
1474: UNION
1475: PPUSH
1476: CALL_OW 1
1480: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1481: LD_ADDR_EXP 12
1485: PUSH
1486: EMPTY
1487: ST_TO_ADDR
// end ;
1488: LD_VAR 0 1
1492: RET
// export function InitMC_Powell ( ) ; begin
1493: LD_INT 0
1495: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1496: LD_INT 1
1498: PPUSH
1499: LD_INT 1
1501: PPUSH
1502: CALL 77943 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1506: LD_INT 1
1508: PPUSH
1509: LD_INT 6
1511: PPUSH
1512: CALL 77887 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1516: LD_INT 1
1518: PPUSH
1519: LD_INT 167
1521: PUSH
1522: LD_INT 102
1524: PUSH
1525: LD_INT 0
1527: PUSH
1528: EMPTY
1529: LIST
1530: LIST
1531: LIST
1532: PUSH
1533: LD_INT 173
1535: PUSH
1536: LD_INT 83
1538: PUSH
1539: LD_INT 1
1541: PUSH
1542: EMPTY
1543: LIST
1544: LIST
1545: LIST
1546: PUSH
1547: LD_INT 171
1549: PUSH
1550: LD_INT 141
1552: PUSH
1553: LD_INT 0
1555: PUSH
1556: EMPTY
1557: LIST
1558: LIST
1559: LIST
1560: PUSH
1561: LD_INT 178
1563: PUSH
1564: LD_INT 148
1566: PUSH
1567: LD_INT 1
1569: PUSH
1570: EMPTY
1571: LIST
1572: LIST
1573: LIST
1574: PUSH
1575: EMPTY
1576: LIST
1577: LIST
1578: LIST
1579: LIST
1580: PPUSH
1581: CALL 76946 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1585: LD_INT 1
1587: PPUSH
1588: LD_INT 11
1590: PUSH
1591: LD_INT 6
1593: PUSH
1594: LD_INT 7
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: PPUSH
1602: CALL 77775 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1606: LD_INT 1
1608: PPUSH
1609: LD_INT 5
1611: PPUSH
1612: CALL 77457 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1616: LD_INT 1
1618: PPUSH
1619: LD_INT 4
1621: PPUSH
1622: CALL 77188 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1626: LD_INT 1
1628: PPUSH
1629: LD_INT 4
1631: PPUSH
1632: CALL 76807 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1636: LD_INT 1
1638: PPUSH
1639: LD_INT 3
1641: PUSH
1642: LD_INT 1
1644: PUSH
1645: LD_INT 2
1647: PUSH
1648: LD_INT 5
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 4
1659: PUSH
1660: LD_INT 1
1662: PUSH
1663: LD_INT 2
1665: PUSH
1666: LD_INT 6
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: PUSH
1675: LD_INT 4
1677: PUSH
1678: LD_INT 1
1680: PUSH
1681: LD_INT 2
1683: PUSH
1684: LD_INT 7
1686: PUSH
1687: EMPTY
1688: LIST
1689: LIST
1690: LIST
1691: LIST
1692: PUSH
1693: LD_INT 4
1695: PUSH
1696: LD_INT 1
1698: PUSH
1699: LD_INT 2
1701: PUSH
1702: LD_INT 6
1704: PUSH
1705: EMPTY
1706: LIST
1707: LIST
1708: LIST
1709: LIST
1710: PUSH
1711: EMPTY
1712: LIST
1713: LIST
1714: LIST
1715: LIST
1716: PPUSH
1717: CALL 76622 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1721: LD_INT 1
1723: PPUSH
1724: LD_INT 201
1726: PPUSH
1727: LD_INT 140
1729: PPUSH
1730: LD_INT 4
1732: PPUSH
1733: LD_INT 19
1735: PUSH
1736: LD_INT 16
1738: PUSH
1739: LD_INT 17
1741: PUSH
1742: LD_INT 18
1744: PUSH
1745: LD_INT 22
1747: PUSH
1748: EMPTY
1749: LIST
1750: LIST
1751: LIST
1752: LIST
1753: LIST
1754: PPUSH
1755: CALL 77569 0 5
// end ;
1759: LD_VAR 0 1
1763: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1764: LD_INT 4
1766: PPUSH
1767: CALL_OW 302
1771: IFFALSE 2431
1773: GO 1775
1775: DISABLE
1776: LD_INT 0
1778: PPUSH
1779: PPUSH
1780: PPUSH
1781: PPUSH
1782: PPUSH
// begin enable ;
1783: ENABLE
// base := 1 ;
1784: LD_ADDR_VAR 0 2
1788: PUSH
1789: LD_INT 1
1791: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1792: LD_ADDR_VAR 0 3
1796: PUSH
1797: LD_INT 4
1799: PUSH
1800: LD_INT 1
1802: PUSH
1803: LD_INT 2
1805: PUSH
1806: LD_INT 6
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: LIST
1814: PUSH
1815: LD_INT 4
1817: PUSH
1818: LD_INT 1
1820: PUSH
1821: LD_INT 2
1823: PUSH
1824: LD_INT 6
1826: PUSH
1827: EMPTY
1828: LIST
1829: LIST
1830: LIST
1831: LIST
1832: PUSH
1833: LD_INT 3
1835: PUSH
1836: LD_INT 1
1838: PUSH
1839: LD_INT 2
1841: PUSH
1842: LD_INT 7
1844: PUSH
1845: EMPTY
1846: LIST
1847: LIST
1848: LIST
1849: LIST
1850: PUSH
1851: LD_INT 3
1853: PUSH
1854: LD_INT 1
1856: PUSH
1857: LD_INT 2
1859: PUSH
1860: LD_INT 7
1862: PUSH
1863: EMPTY
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: PUSH
1869: EMPTY
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1875: LD_ADDR_VAR 0 5
1879: PUSH
1880: LD_VAR 0 5
1884: PUSH
1885: LD_OWVAR 1
1889: PUSH
1890: LD_INT 21000
1892: DIV
1893: PLUS
1894: ST_TO_ADDR
// if amount > 8 then
1895: LD_VAR 0 5
1899: PUSH
1900: LD_INT 8
1902: GREATER
1903: IFFALSE 1913
// amount := 8 ;
1905: LD_ADDR_VAR 0 5
1909: PUSH
1910: LD_INT 8
1912: ST_TO_ADDR
// for i = 1 to amount do
1913: LD_ADDR_VAR 0 1
1917: PUSH
1918: DOUBLE
1919: LD_INT 1
1921: DEC
1922: ST_TO_ADDR
1923: LD_VAR 0 5
1927: PUSH
1928: FOR_TO
1929: IFFALSE 2013
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1931: LD_ADDR_VAR 0 3
1935: PUSH
1936: LD_VAR 0 3
1940: PPUSH
1941: LD_VAR 0 3
1945: PUSH
1946: LD_INT 1
1948: PLUS
1949: PPUSH
1950: LD_INT 3
1952: PUSH
1953: LD_INT 4
1955: PUSH
1956: EMPTY
1957: LIST
1958: LIST
1959: PUSH
1960: LD_INT 1
1962: PPUSH
1963: LD_INT 2
1965: PPUSH
1966: CALL_OW 12
1970: ARRAY
1971: PUSH
1972: LD_INT 1
1974: PUSH
1975: LD_INT 2
1977: PUSH
1978: LD_INT 7
1980: PUSH
1981: LD_INT 5
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: PUSH
1988: LD_INT 1
1990: PPUSH
1991: LD_INT 2
1993: PPUSH
1994: CALL_OW 12
1998: ARRAY
1999: PUSH
2000: EMPTY
2001: LIST
2002: LIST
2003: LIST
2004: LIST
2005: PPUSH
2006: CALL_OW 2
2010: ST_TO_ADDR
2011: GO 1928
2013: POP
2014: POP
// MC_InsertProduceList ( base , tmp ) ;
2015: LD_VAR 0 2
2019: PPUSH
2020: LD_VAR 0 3
2024: PPUSH
2025: CALL 76670 0 2
// repeat wait ( 0 0$1 ) ;
2029: LD_INT 35
2031: PPUSH
2032: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2036: LD_VAR 0 2
2040: PPUSH
2041: LD_INT 1
2043: PPUSH
2044: CALL 78088 0 2
2048: PUSH
2049: LD_VAR 0 5
2053: GREATEREQUAL
2054: IFFALSE 2029
// wait ( 0 0$30 ) ;
2056: LD_INT 1050
2058: PPUSH
2059: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2063: LD_ADDR_VAR 0 4
2067: PUSH
2068: LD_EXP 42
2072: PUSH
2073: LD_VAR 0 2
2077: ARRAY
2078: PUSH
2079: LD_EXP 42
2083: PUSH
2084: LD_VAR 0 2
2088: ARRAY
2089: PPUSH
2090: LD_INT 2
2092: PUSH
2093: LD_INT 34
2095: PUSH
2096: LD_INT 12
2098: PUSH
2099: EMPTY
2100: LIST
2101: LIST
2102: PUSH
2103: LD_INT 34
2105: PUSH
2106: LD_INT 13
2108: PUSH
2109: EMPTY
2110: LIST
2111: LIST
2112: PUSH
2113: LD_INT 34
2115: PUSH
2116: LD_INT 14
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: PUSH
2123: EMPTY
2124: LIST
2125: LIST
2126: LIST
2127: LIST
2128: PPUSH
2129: CALL_OW 72
2133: DIFF
2134: ST_TO_ADDR
// if not attackers then
2135: LD_VAR 0 4
2139: NOT
2140: IFFALSE 2144
// exit ;
2142: GO 2431
// DialogPowellsAttack ;
2144: CALL 9543 0 0
// powellAttackGroup := attackers ;
2148: LD_ADDR_EXP 12
2152: PUSH
2153: LD_VAR 0 4
2157: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2158: LD_ADDR_EXP 42
2162: PUSH
2163: LD_EXP 42
2167: PPUSH
2168: LD_VAR 0 2
2172: PPUSH
2173: LD_EXP 42
2177: PUSH
2178: LD_VAR 0 2
2182: ARRAY
2183: PUSH
2184: LD_VAR 0 4
2188: DIFF
2189: PPUSH
2190: CALL_OW 1
2194: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2195: LD_EXP 9
2199: PUSH
2200: LD_INT 16
2202: PPUSH
2203: LD_INT 81
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: EMPTY
2210: LIST
2211: LIST
2212: PPUSH
2213: CALL_OW 70
2217: AND
2218: IFFALSE 2237
// ComAgressiveMove ( attackers , 135 , 21 ) else
2220: LD_VAR 0 4
2224: PPUSH
2225: LD_INT 135
2227: PPUSH
2228: LD_INT 21
2230: PPUSH
2231: CALL_OW 114
2235: GO 2252
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2237: LD_VAR 0 4
2241: PPUSH
2242: LD_INT 146
2244: PPUSH
2245: LD_INT 103
2247: PPUSH
2248: CALL_OW 114
// wait ( 0 0$5 ) ;
2252: LD_INT 175
2254: PPUSH
2255: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2259: LD_INT 35
2261: PPUSH
2262: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2266: LD_VAR 0 4
2270: PPUSH
2271: LD_INT 60
2273: PUSH
2274: EMPTY
2275: LIST
2276: PPUSH
2277: CALL_OW 72
2281: NOT
2282: IFFALSE 2259
// if FilterAllUnits ( [ f_side , 3 ] ) then
2284: LD_INT 22
2286: PUSH
2287: LD_INT 3
2289: PUSH
2290: EMPTY
2291: LIST
2292: LIST
2293: PPUSH
2294: CALL_OW 69
2298: IFFALSE 2317
// ComAgressiveMove ( attackers , 102 , 116 ) else
2300: LD_VAR 0 4
2304: PPUSH
2305: LD_INT 102
2307: PPUSH
2308: LD_INT 116
2310: PPUSH
2311: CALL_OW 114
2315: GO 2332
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2317: LD_VAR 0 4
2321: PPUSH
2322: LD_INT 66
2324: PPUSH
2325: LD_INT 41
2327: PPUSH
2328: CALL_OW 114
// wait ( 0 0$10 ) ;
2332: LD_INT 350
2334: PPUSH
2335: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2339: LD_INT 35
2341: PPUSH
2342: CALL_OW 67
// for i in attackers do
2346: LD_ADDR_VAR 0 1
2350: PUSH
2351: LD_VAR 0 4
2355: PUSH
2356: FOR_IN
2357: IFFALSE 2407
// if not HasTask ( i ) then
2359: LD_VAR 0 1
2363: PPUSH
2364: CALL_OW 314
2368: NOT
2369: IFFALSE 2405
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2371: LD_VAR 0 1
2375: PPUSH
2376: LD_INT 81
2378: PUSH
2379: LD_INT 4
2381: PUSH
2382: EMPTY
2383: LIST
2384: LIST
2385: PPUSH
2386: CALL_OW 69
2390: PPUSH
2391: LD_VAR 0 1
2395: PPUSH
2396: CALL_OW 74
2400: PPUSH
2401: CALL_OW 115
2405: GO 2356
2407: POP
2408: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2409: LD_VAR 0 4
2413: PPUSH
2414: LD_INT 50
2416: PUSH
2417: EMPTY
2418: LIST
2419: PPUSH
2420: CALL_OW 72
2424: NOT
2425: IFFALSE 2339
// DialogPowellsAttackFailed ;
2427: CALL 9808 0 0
// end ;
2431: PPOPN 5
2433: END
// every 0 0$2 do var vehicles , mechs , i ;
2434: GO 2436
2436: DISABLE
2437: LD_INT 0
2439: PPUSH
2440: PPUSH
2441: PPUSH
// begin enable ;
2442: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2443: LD_ADDR_VAR 0 1
2447: PUSH
2448: LD_INT 22
2450: PUSH
2451: LD_INT 1
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: PUSH
2458: LD_INT 21
2460: PUSH
2461: LD_INT 2
2463: PUSH
2464: EMPTY
2465: LIST
2466: LIST
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 24
2473: PUSH
2474: LD_INT 1000
2476: PUSH
2477: EMPTY
2478: LIST
2479: LIST
2480: PUSH
2481: EMPTY
2482: LIST
2483: LIST
2484: PUSH
2485: LD_INT 92
2487: PUSH
2488: LD_INT 191
2490: PUSH
2491: LD_INT 140
2493: PUSH
2494: LD_INT 10
2496: PUSH
2497: EMPTY
2498: LIST
2499: LIST
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: LIST
2507: LIST
2508: PPUSH
2509: CALL_OW 69
2513: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2514: LD_ADDR_VAR 0 2
2518: PUSH
2519: LD_INT 22
2521: PUSH
2522: LD_INT 4
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: PUSH
2529: LD_INT 25
2531: PUSH
2532: LD_INT 3
2534: PUSH
2535: EMPTY
2536: LIST
2537: LIST
2538: PUSH
2539: EMPTY
2540: LIST
2541: LIST
2542: PPUSH
2543: CALL_OW 69
2547: ST_TO_ADDR
// if not mechs then
2548: LD_VAR 0 2
2552: NOT
2553: IFFALSE 2557
// exit ;
2555: GO 2731
// if mc_remote_driver [ 1 ] then
2557: LD_EXP 63
2561: PUSH
2562: LD_INT 1
2564: ARRAY
2565: IFFALSE 2587
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2567: LD_ADDR_VAR 0 2
2571: PUSH
2572: LD_VAR 0 2
2576: PUSH
2577: LD_EXP 63
2581: PUSH
2582: LD_INT 1
2584: ARRAY
2585: DIFF
2586: ST_TO_ADDR
// if not mechs then
2587: LD_VAR 0 2
2591: NOT
2592: IFFALSE 2596
// exit ;
2594: GO 2731
// if vehicles then
2596: LD_VAR 0 1
2600: IFFALSE 2688
// begin for i in mechs do
2602: LD_ADDR_VAR 0 3
2606: PUSH
2607: LD_VAR 0 2
2611: PUSH
2612: FOR_IN
2613: IFFALSE 2684
// begin if GetTag ( i ) <> 120 then
2615: LD_VAR 0 3
2619: PPUSH
2620: CALL_OW 110
2624: PUSH
2625: LD_INT 120
2627: NONEQUAL
2628: IFFALSE 2642
// SetTag ( i , 120 ) ;
2630: LD_VAR 0 3
2634: PPUSH
2635: LD_INT 120
2637: PPUSH
2638: CALL_OW 109
// if IsInUnit ( i ) then
2642: LD_VAR 0 3
2646: PPUSH
2647: CALL_OW 310
2651: IFFALSE 2664
// ComExitBuilding ( i ) else
2653: LD_VAR 0 3
2657: PPUSH
2658: CALL_OW 122
2662: GO 2682
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2664: LD_VAR 0 3
2668: PPUSH
2669: LD_VAR 0 1
2673: PUSH
2674: LD_INT 1
2676: ARRAY
2677: PPUSH
2678: CALL_OW 129
// end ;
2682: GO 2612
2684: POP
2685: POP
// end else
2686: GO 2731
// if FilterByTag ( mechs , 120 ) then
2688: LD_VAR 0 2
2692: PPUSH
2693: LD_INT 120
2695: PPUSH
2696: CALL 46022 0 2
2700: IFFALSE 2731
// begin for i in mechs do
2702: LD_ADDR_VAR 0 3
2706: PUSH
2707: LD_VAR 0 2
2711: PUSH
2712: FOR_IN
2713: IFFALSE 2729
// begin SetTag ( i , 0 ) ;
2715: LD_VAR 0 3
2719: PPUSH
2720: LD_INT 0
2722: PPUSH
2723: CALL_OW 109
// end ;
2727: GO 2712
2729: POP
2730: POP
// end ; end ;
2731: PPOPN 3
2733: END
// every 0 0$2 do var people , sci , i ;
2734: GO 2736
2736: DISABLE
2737: LD_INT 0
2739: PPUSH
2740: PPUSH
2741: PPUSH
// begin enable ;
2742: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2743: LD_ADDR_VAR 0 1
2747: PUSH
2748: LD_INT 22
2750: PUSH
2751: LD_INT 1
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: PUSH
2758: LD_INT 21
2760: PUSH
2761: LD_INT 1
2763: PUSH
2764: EMPTY
2765: LIST
2766: LIST
2767: PUSH
2768: LD_INT 3
2770: PUSH
2771: LD_INT 24
2773: PUSH
2774: LD_INT 1000
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: PUSH
2785: LD_INT 92
2787: PUSH
2788: LD_INT 188
2790: PUSH
2791: LD_INT 112
2793: PUSH
2794: LD_INT 10
2796: PUSH
2797: EMPTY
2798: LIST
2799: LIST
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: LIST
2807: LIST
2808: PPUSH
2809: CALL_OW 69
2813: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2814: LD_ADDR_VAR 0 2
2818: PUSH
2819: LD_INT 22
2821: PUSH
2822: LD_INT 4
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: PUSH
2829: LD_INT 25
2831: PUSH
2832: LD_INT 4
2834: PUSH
2835: EMPTY
2836: LIST
2837: LIST
2838: PUSH
2839: EMPTY
2840: LIST
2841: LIST
2842: PPUSH
2843: CALL_OW 69
2847: ST_TO_ADDR
// if not sci then
2848: LD_VAR 0 2
2852: NOT
2853: IFFALSE 2857
// exit ;
2855: GO 2992
// if people then
2857: LD_VAR 0 1
2861: IFFALSE 2949
// begin for i in sci do
2863: LD_ADDR_VAR 0 3
2867: PUSH
2868: LD_VAR 0 2
2872: PUSH
2873: FOR_IN
2874: IFFALSE 2945
// begin if GetTag ( i ) <> 102 then
2876: LD_VAR 0 3
2880: PPUSH
2881: CALL_OW 110
2885: PUSH
2886: LD_INT 102
2888: NONEQUAL
2889: IFFALSE 2903
// SetTag ( i , 102 ) ;
2891: LD_VAR 0 3
2895: PPUSH
2896: LD_INT 102
2898: PPUSH
2899: CALL_OW 109
// if IsInUnit ( i ) then
2903: LD_VAR 0 3
2907: PPUSH
2908: CALL_OW 310
2912: IFFALSE 2925
// ComExitBuilding ( i ) else
2914: LD_VAR 0 3
2918: PPUSH
2919: CALL_OW 122
2923: GO 2943
// ComHeal ( i , people [ 1 ] ) ;
2925: LD_VAR 0 3
2929: PPUSH
2930: LD_VAR 0 1
2934: PUSH
2935: LD_INT 1
2937: ARRAY
2938: PPUSH
2939: CALL_OW 128
// end ;
2943: GO 2873
2945: POP
2946: POP
// end else
2947: GO 2992
// if FilterByTag ( sci , 102 ) then
2949: LD_VAR 0 2
2953: PPUSH
2954: LD_INT 102
2956: PPUSH
2957: CALL 46022 0 2
2961: IFFALSE 2992
// begin for i in sci do
2963: LD_ADDR_VAR 0 3
2967: PUSH
2968: LD_VAR 0 2
2972: PUSH
2973: FOR_IN
2974: IFFALSE 2990
// begin SetTag ( i , 0 ) ;
2976: LD_VAR 0 3
2980: PPUSH
2981: LD_INT 0
2983: PPUSH
2984: CALL_OW 109
// end ;
2988: GO 2973
2990: POP
2991: POP
// end ; end ;
2992: PPOPN 3
2994: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
2995: LD_INT 22
2997: PUSH
2998: LD_INT 4
3000: PUSH
3001: EMPTY
3002: LIST
3003: LIST
3004: PUSH
3005: LD_INT 33
3007: PUSH
3008: LD_INT 2
3010: PUSH
3011: EMPTY
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 50
3017: PUSH
3018: EMPTY
3019: LIST
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 61
3026: PUSH
3027: EMPTY
3028: LIST
3029: PUSH
3030: EMPTY
3031: LIST
3032: LIST
3033: PUSH
3034: EMPTY
3035: LIST
3036: LIST
3037: LIST
3038: LIST
3039: PPUSH
3040: CALL_OW 69
3044: IFFALSE 3135
3046: GO 3048
3048: DISABLE
3049: LD_INT 0
3051: PPUSH
3052: PPUSH
// begin enable ;
3053: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3054: LD_ADDR_VAR 0 2
3058: PUSH
3059: LD_INT 22
3061: PUSH
3062: LD_INT 4
3064: PUSH
3065: EMPTY
3066: LIST
3067: LIST
3068: PUSH
3069: LD_INT 33
3071: PUSH
3072: LD_INT 2
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: PUSH
3079: LD_INT 50
3081: PUSH
3082: EMPTY
3083: LIST
3084: PUSH
3085: LD_INT 3
3087: PUSH
3088: LD_INT 61
3090: PUSH
3091: EMPTY
3092: LIST
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: PUSH
3098: EMPTY
3099: LIST
3100: LIST
3101: LIST
3102: LIST
3103: PPUSH
3104: CALL_OW 69
3108: ST_TO_ADDR
// for i in tmp do
3109: LD_ADDR_VAR 0 1
3113: PUSH
3114: LD_VAR 0 2
3118: PUSH
3119: FOR_IN
3120: IFFALSE 3133
// Connect ( i ) ;
3122: LD_VAR 0 1
3126: PPUSH
3127: CALL 19079 0 1
3131: GO 3119
3133: POP
3134: POP
// end ; end_of_file
3135: PPOPN 2
3137: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3138: LD_INT 0
3140: PPUSH
3141: PPUSH
3142: PPUSH
3143: PPUSH
3144: PPUSH
3145: PPUSH
// gensher_side := 2 ;
3146: LD_ADDR_EXP 14
3150: PUSH
3151: LD_INT 2
3153: ST_TO_ADDR
// uc_side := gensher_side ;
3154: LD_ADDR_OWVAR 20
3158: PUSH
3159: LD_EXP 14
3163: ST_TO_ADDR
// uc_nation := 2 ;
3164: LD_ADDR_OWVAR 21
3168: PUSH
3169: LD_INT 2
3171: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3172: LD_ADDR_VAR 0 6
3176: PUSH
3177: LD_INT 5
3179: PUSH
3180: LD_INT 42
3182: PUSH
3183: LD_INT 29
3185: PUSH
3186: LD_INT 5
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 5
3197: PUSH
3198: LD_INT 36
3200: PUSH
3201: LD_INT 40
3203: PUSH
3204: LD_INT 5
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 6
3215: PUSH
3216: LD_INT 13
3218: PUSH
3219: LD_INT 18
3221: PUSH
3222: LD_INT 1
3224: PUSH
3225: LD_INT 10
3227: PUSH
3228: LD_INT 15
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: LIST
3238: PUSH
3239: LD_INT 27
3241: PUSH
3242: LD_INT 17
3244: PUSH
3245: LD_INT 3
3247: PUSH
3248: LD_INT 0
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: LIST
3255: LIST
3256: PUSH
3257: LD_INT 29
3259: PUSH
3260: LD_INT 56
3262: PUSH
3263: LD_INT 23
3265: PUSH
3266: LD_INT 0
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_INT 3
3277: PUSH
3278: LD_INT 11
3280: PUSH
3281: LD_INT 7
3283: PUSH
3284: LD_INT 2
3286: PUSH
3287: EMPTY
3288: LIST
3289: LIST
3290: LIST
3291: LIST
3292: PUSH
3293: LD_INT 27
3295: PUSH
3296: LD_INT 20
3298: PUSH
3299: LD_INT 3
3301: PUSH
3302: LD_INT 0
3304: PUSH
3305: EMPTY
3306: LIST
3307: LIST
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 27
3313: PUSH
3314: LD_INT 23
3316: PUSH
3317: LD_INT 3
3319: PUSH
3320: LD_INT 0
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: PUSH
3329: LD_INT 27
3331: PUSH
3332: LD_INT 26
3334: PUSH
3335: LD_INT 3
3337: PUSH
3338: LD_INT 0
3340: PUSH
3341: EMPTY
3342: LIST
3343: LIST
3344: LIST
3345: LIST
3346: PUSH
3347: LD_INT 6
3349: PUSH
3350: LD_INT 17
3352: PUSH
3353: LD_INT 27
3355: PUSH
3356: LD_INT 1
3358: PUSH
3359: LD_INT 13
3361: PUSH
3362: LD_INT 11
3364: PUSH
3365: EMPTY
3366: LIST
3367: LIST
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: PUSH
3373: LD_INT 32
3375: PUSH
3376: LD_INT 27
3378: PUSH
3379: LD_INT 44
3381: PUSH
3382: LD_INT 5
3384: PUSH
3385: LD_INT 27
3387: PUSH
3388: EMPTY
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 41
3400: PUSH
3401: LD_INT 41
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 45
3422: PUSH
3423: LD_INT 24
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 28
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 48
3444: PUSH
3445: LD_INT 19
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 41
3466: PUSH
3467: LD_INT 3
3469: PUSH
3470: LD_INT 4
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 5
3485: PUSH
3486: LD_INT 44
3488: PUSH
3489: LD_INT 9
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: EMPTY
3496: LIST
3497: LIST
3498: LIST
3499: LIST
3500: PUSH
3501: LD_INT 30
3503: PUSH
3504: LD_INT 52
3506: PUSH
3507: LD_INT 40
3509: PUSH
3510: LD_INT 3
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: LIST
3517: LIST
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: LIST
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: LIST
3528: LIST
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: LIST
3535: LIST
3536: LIST
3537: ST_TO_ADDR
// for i in list do
3538: LD_ADDR_VAR 0 2
3542: PUSH
3543: LD_VAR 0 6
3547: PUSH
3548: FOR_IN
3549: IFFALSE 3713
// begin uc_side := 2 ;
3551: LD_ADDR_OWVAR 20
3555: PUSH
3556: LD_INT 2
3558: ST_TO_ADDR
// uc_nation := 2 ;
3559: LD_ADDR_OWVAR 21
3563: PUSH
3564: LD_INT 2
3566: ST_TO_ADDR
// InitBc ;
3567: CALL_OW 21
// bc_type := i [ 1 ] ;
3571: LD_ADDR_OWVAR 42
3575: PUSH
3576: LD_VAR 0 2
3580: PUSH
3581: LD_INT 1
3583: ARRAY
3584: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3585: LD_VAR 0 2
3589: PUSH
3590: LD_INT 1
3592: ARRAY
3593: PUSH
3594: LD_INT 6
3596: EQUAL
3597: IFFALSE 3635
// begin bc_type := b_lab_full ;
3599: LD_ADDR_OWVAR 42
3603: PUSH
3604: LD_INT 8
3606: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3607: LD_ADDR_OWVAR 44
3611: PUSH
3612: LD_VAR 0 2
3616: PUSH
3617: LD_INT 5
3619: ARRAY
3620: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3621: LD_ADDR_OWVAR 45
3625: PUSH
3626: LD_VAR 0 2
3630: PUSH
3631: LD_INT 6
3633: ARRAY
3634: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3635: LD_ADDR_VAR 0 3
3639: PUSH
3640: LD_VAR 0 2
3644: PUSH
3645: LD_INT 2
3647: ARRAY
3648: PPUSH
3649: LD_VAR 0 2
3653: PUSH
3654: LD_INT 3
3656: ARRAY
3657: PPUSH
3658: LD_VAR 0 2
3662: PUSH
3663: LD_INT 4
3665: ARRAY
3666: PPUSH
3667: CALL_OW 47
3671: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3672: LD_VAR 0 2
3676: PUSH
3677: LD_INT 1
3679: ARRAY
3680: PUSH
3681: LD_INT 33
3683: PUSH
3684: LD_INT 32
3686: PUSH
3687: EMPTY
3688: LIST
3689: LIST
3690: IN
3691: IFFALSE 3711
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3693: LD_VAR 0 3
3697: PPUSH
3698: LD_VAR 0 2
3702: PUSH
3703: LD_INT 5
3705: ARRAY
3706: PPUSH
3707: CALL_OW 431
// end ;
3711: GO 3548
3713: POP
3714: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3715: LD_ADDR_VAR 0 4
3719: PUSH
3720: LD_INT 7
3722: PPUSH
3723: LD_INT 2
3725: PPUSH
3726: LD_STRING 
3728: PPUSH
3729: LD_INT 8
3731: PUSH
3732: LD_INT 7
3734: PUSH
3735: LD_INT 6
3737: PUSH
3738: EMPTY
3739: LIST
3740: LIST
3741: LIST
3742: PUSH
3743: LD_OWVAR 67
3747: ARRAY
3748: PPUSH
3749: LD_INT 11500
3751: PUSH
3752: LD_INT 1100
3754: PUSH
3755: LD_INT 60
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: LIST
3762: PPUSH
3763: LD_INT 6
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: LD_INT 6
3771: PUSH
3772: LD_INT 6
3774: PUSH
3775: EMPTY
3776: LIST
3777: LIST
3778: LIST
3779: LIST
3780: PPUSH
3781: CALL 19432 0 6
3785: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3786: LD_ADDR_EXP 23
3790: PUSH
3791: LD_EXP 23
3795: PPUSH
3796: LD_INT 2
3798: PPUSH
3799: LD_VAR 0 4
3803: PUSH
3804: LD_INT 22
3806: PUSH
3807: LD_INT 2
3809: PUSH
3810: EMPTY
3811: LIST
3812: LIST
3813: PUSH
3814: LD_INT 21
3816: PUSH
3817: LD_INT 3
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PUSH
3824: EMPTY
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 69
3832: UNION
3833: PPUSH
3834: CALL_OW 1
3838: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3839: LD_ADDR_VAR 0 4
3843: PUSH
3844: LD_INT 22
3846: PUSH
3847: LD_INT 2
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: PUSH
3854: LD_INT 30
3856: PUSH
3857: LD_INT 31
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PUSH
3864: EMPTY
3865: LIST
3866: LIST
3867: PPUSH
3868: CALL_OW 69
3872: ST_TO_ADDR
// for i in tmp do
3873: LD_ADDR_VAR 0 2
3877: PUSH
3878: LD_VAR 0 4
3882: PUSH
3883: FOR_IN
3884: IFFALSE 3954
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3886: LD_INT 0
3888: PPUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 4
3894: PUSH
3895: LD_INT 3
3897: PUSH
3898: LD_INT 3
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: LIST
3905: PUSH
3906: LD_OWVAR 67
3910: ARRAY
3911: PPUSH
3912: CALL_OW 380
// un := CreateHuman ;
3916: LD_ADDR_VAR 0 5
3920: PUSH
3921: CALL_OW 44
3925: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3926: LD_VAR 0 5
3930: PPUSH
3931: LD_INT 1
3933: PPUSH
3934: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3938: LD_VAR 0 5
3942: PPUSH
3943: LD_VAR 0 2
3947: PPUSH
3948: CALL_OW 52
// end ;
3952: GO 3883
3954: POP
3955: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3956: LD_ADDR_VAR 0 4
3960: PUSH
3961: LD_INT 15
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 517
3971: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
3972: LD_ADDR_VAR 0 2
3976: PUSH
3977: DOUBLE
3978: LD_INT 1
3980: DEC
3981: ST_TO_ADDR
3982: LD_VAR 0 4
3986: PUSH
3987: LD_INT 1
3989: ARRAY
3990: PUSH
3991: FOR_TO
3992: IFFALSE 4094
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
3994: LD_VAR 0 4
3998: PUSH
3999: LD_INT 1
4001: ARRAY
4002: PUSH
4003: LD_VAR 0 2
4007: ARRAY
4008: PPUSH
4009: LD_VAR 0 4
4013: PUSH
4014: LD_INT 2
4016: ARRAY
4017: PUSH
4018: LD_VAR 0 2
4022: ARRAY
4023: PPUSH
4024: LD_INT 2
4026: PPUSH
4027: LD_INT 0
4029: PPUSH
4030: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4034: LD_ADDR_EXP 3
4038: PUSH
4039: LD_EXP 3
4043: PPUSH
4044: LD_EXP 3
4048: PUSH
4049: LD_INT 1
4051: PLUS
4052: PPUSH
4053: LD_VAR 0 4
4057: PUSH
4058: LD_INT 1
4060: ARRAY
4061: PUSH
4062: LD_VAR 0 2
4066: ARRAY
4067: PUSH
4068: LD_VAR 0 4
4072: PUSH
4073: LD_INT 2
4075: ARRAY
4076: PUSH
4077: LD_VAR 0 2
4081: ARRAY
4082: PUSH
4083: EMPTY
4084: LIST
4085: LIST
4086: PPUSH
4087: CALL_OW 2
4091: ST_TO_ADDR
// end ;
4092: GO 3991
4094: POP
4095: POP
// if Difficulty > 1 then
4096: LD_OWVAR 67
4100: PUSH
4101: LD_INT 1
4103: GREATER
4104: IFFALSE 4246
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_INT 19
4113: PPUSH
4114: LD_INT 0
4116: PPUSH
4117: CALL_OW 517
4121: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4122: LD_ADDR_VAR 0 2
4126: PUSH
4127: DOUBLE
4128: LD_INT 1
4130: DEC
4131: ST_TO_ADDR
4132: LD_VAR 0 4
4136: PUSH
4137: LD_INT 1
4139: ARRAY
4140: PUSH
4141: FOR_TO
4142: IFFALSE 4244
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4144: LD_VAR 0 4
4148: PUSH
4149: LD_INT 1
4151: ARRAY
4152: PUSH
4153: LD_VAR 0 2
4157: ARRAY
4158: PPUSH
4159: LD_VAR 0 4
4163: PUSH
4164: LD_INT 2
4166: ARRAY
4167: PUSH
4168: LD_VAR 0 2
4172: ARRAY
4173: PPUSH
4174: LD_INT 2
4176: PPUSH
4177: LD_INT 0
4179: PPUSH
4180: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4184: LD_ADDR_EXP 3
4188: PUSH
4189: LD_EXP 3
4193: PPUSH
4194: LD_EXP 3
4198: PUSH
4199: LD_INT 1
4201: PLUS
4202: PPUSH
4203: LD_VAR 0 4
4207: PUSH
4208: LD_INT 1
4210: ARRAY
4211: PUSH
4212: LD_VAR 0 2
4216: ARRAY
4217: PUSH
4218: LD_VAR 0 4
4222: PUSH
4223: LD_INT 2
4225: ARRAY
4226: PUSH
4227: LD_VAR 0 2
4231: ARRAY
4232: PUSH
4233: EMPTY
4234: LIST
4235: LIST
4236: PPUSH
4237: CALL_OW 2
4241: ST_TO_ADDR
// end ;
4242: GO 4141
4244: POP
4245: POP
// end ; gensherAttackGroup := [ ] ;
4246: LD_ADDR_EXP 15
4250: PUSH
4251: EMPTY
4252: ST_TO_ADDR
// end ;
4253: LD_VAR 0 1
4257: RET
// export function InitMC_Gensher ( ) ; begin
4258: LD_INT 0
4260: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4261: LD_INT 2
4263: PPUSH
4264: LD_INT 2
4266: PPUSH
4267: CALL 77943 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4271: LD_INT 2
4273: PPUSH
4274: LD_INT 9
4276: PPUSH
4277: CALL 77887 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4281: LD_INT 2
4283: PPUSH
4284: LD_INT 56
4286: PUSH
4287: LD_INT 23
4289: PUSH
4290: LD_INT 0
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: PUSH
4298: LD_INT 52
4300: PUSH
4301: LD_INT 40
4303: PUSH
4304: LD_INT 1
4306: PUSH
4307: EMPTY
4308: LIST
4309: LIST
4310: LIST
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PPUSH
4316: CALL 76946 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4320: LD_INT 2
4322: PPUSH
4323: LD_INT 27
4325: PUSH
4326: LD_INT 28
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: PPUSH
4333: CALL 77775 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4337: LD_INT 2
4339: PPUSH
4340: LD_INT 8
4342: PPUSH
4343: CALL 77457 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4347: LD_INT 2
4349: PPUSH
4350: LD_INT 7
4352: PPUSH
4353: CALL 77188 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4357: LD_INT 2
4359: PPUSH
4360: LD_INT 4
4362: PPUSH
4363: CALL 76807 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4367: LD_INT 2
4369: PPUSH
4370: LD_INT 13
4372: PUSH
4373: LD_INT 2
4375: PUSH
4376: LD_INT 1
4378: PUSH
4379: LD_INT 31
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: LIST
4386: LIST
4387: PUSH
4388: LD_INT 13
4390: PUSH
4391: LD_INT 2
4393: PUSH
4394: LD_INT 1
4396: PUSH
4397: LD_INT 31
4399: PUSH
4400: EMPTY
4401: LIST
4402: LIST
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 14
4408: PUSH
4409: LD_INT 1
4411: PUSH
4412: LD_INT 2
4414: PUSH
4415: LD_INT 27
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 14
4426: PUSH
4427: LD_INT 1
4429: PUSH
4430: LD_INT 2
4432: PUSH
4433: LD_INT 27
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 26
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL 76622 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4490: LD_INT 2
4492: PPUSH
4493: LD_INT 11
4495: PPUSH
4496: LD_INT 7
4498: PPUSH
4499: LD_INT 2
4501: PPUSH
4502: LD_INT 23
4504: PUSH
4505: LD_INT 16
4507: PUSH
4508: LD_INT 17
4510: PUSH
4511: LD_INT 18
4513: PUSH
4514: LD_INT 22
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: LIST
4521: LIST
4522: LIST
4523: PPUSH
4524: CALL 77569 0 5
// end ;
4528: LD_VAR 0 1
4532: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4533: LD_EXP 3
4537: PUSH
4538: LD_INT 15
4540: PPUSH
4541: LD_INT 81
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PPUSH
4551: CALL_OW 70
4555: AND
4556: IFFALSE 4769
4558: GO 4560
4560: DISABLE
4561: LD_INT 0
4563: PPUSH
4564: PPUSH
4565: PPUSH
4566: PPUSH
4567: PPUSH
// begin enable ;
4568: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4569: LD_ADDR_VAR 0 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: ST_TO_ADDR
// if not tmp then
4592: LD_VAR 0 3
4596: NOT
4597: IFFALSE 4601
// exit ;
4599: GO 4769
// for i in tmp do
4601: LD_ADDR_VAR 0 1
4605: PUSH
4606: LD_VAR 0 3
4610: PUSH
4611: FOR_IN
4612: IFFALSE 4767
// begin x := GetX ( i ) ;
4614: LD_ADDR_VAR 0 4
4618: PUSH
4619: LD_VAR 0 1
4623: PPUSH
4624: CALL_OW 250
4628: ST_TO_ADDR
// y := GetY ( i ) ;
4629: LD_ADDR_VAR 0 5
4633: PUSH
4634: LD_VAR 0 1
4638: PPUSH
4639: CALL_OW 251
4643: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4644: LD_VAR 0 4
4648: PPUSH
4649: LD_VAR 0 5
4653: PPUSH
4654: CALL_OW 458
4658: IFFALSE 4765
// begin LaunchMineAtPos ( x , y , 2 ) ;
4660: LD_VAR 0 4
4664: PPUSH
4665: LD_VAR 0 5
4669: PPUSH
4670: LD_INT 2
4672: PPUSH
4673: CALL_OW 456
// for j = 1 to staticMines do
4677: LD_ADDR_VAR 0 2
4681: PUSH
4682: DOUBLE
4683: LD_INT 1
4685: DEC
4686: ST_TO_ADDR
4687: LD_EXP 3
4691: PUSH
4692: FOR_TO
4693: IFFALSE 4763
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4695: LD_EXP 3
4699: PUSH
4700: LD_VAR 0 2
4704: ARRAY
4705: PUSH
4706: LD_INT 1
4708: ARRAY
4709: PUSH
4710: LD_VAR 0 4
4714: EQUAL
4715: PUSH
4716: LD_EXP 3
4720: PUSH
4721: LD_VAR 0 2
4725: ARRAY
4726: PUSH
4727: LD_INT 2
4729: ARRAY
4730: PUSH
4731: LD_VAR 0 5
4735: EQUAL
4736: AND
4737: IFFALSE 4761
// begin staticMines := Delete ( staticMines , j ) ;
4739: LD_ADDR_EXP 3
4743: PUSH
4744: LD_EXP 3
4748: PPUSH
4749: LD_VAR 0 2
4753: PPUSH
4754: CALL_OW 3
4758: ST_TO_ADDR
// break ;
4759: GO 4763
// end ;
4761: GO 4692
4763: POP
4764: POP
// end ; end ;
4765: GO 4611
4767: POP
4768: POP
// end ;
4769: PPOPN 5
4771: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4772: LD_INT 7
4774: PPUSH
4775: CALL_OW 302
4779: PUSH
4780: LD_EXP 4
4784: NOT
4785: AND
4786: IFFALSE 5386
4788: GO 4790
4790: DISABLE
4791: LD_INT 0
4793: PPUSH
4794: PPUSH
4795: PPUSH
4796: PPUSH
4797: PPUSH
// begin enable ;
4798: ENABLE
// base := 2 ;
4799: LD_ADDR_VAR 0 2
4803: PUSH
4804: LD_INT 2
4806: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4807: LD_ADDR_VAR 0 3
4811: PUSH
4812: LD_INT 14
4814: PUSH
4815: LD_INT 1
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: LD_INT 27
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: LIST
4828: LIST
4829: PUSH
4830: LD_INT 14
4832: PUSH
4833: LD_INT 1
4835: PUSH
4836: LD_INT 2
4838: PUSH
4839: LD_INT 27
4841: PUSH
4842: EMPTY
4843: LIST
4844: LIST
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 92
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 26
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: EMPTY
4885: LIST
4886: LIST
4887: LIST
4888: LIST
4889: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4890: LD_ADDR_VAR 0 5
4894: PUSH
4895: LD_VAR 0 5
4899: PUSH
4900: LD_OWVAR 1
4904: PUSH
4905: LD_INT 21000
4907: DIV
4908: PLUS
4909: ST_TO_ADDR
// if amount > 8 then
4910: LD_VAR 0 5
4914: PUSH
4915: LD_INT 8
4917: GREATER
4918: IFFALSE 4928
// amount := 8 ;
4920: LD_ADDR_VAR 0 5
4924: PUSH
4925: LD_INT 8
4927: ST_TO_ADDR
// for i = 1 to amount do
4928: LD_ADDR_VAR 0 1
4932: PUSH
4933: DOUBLE
4934: LD_INT 1
4936: DEC
4937: ST_TO_ADDR
4938: LD_VAR 0 5
4942: PUSH
4943: FOR_TO
4944: IFFALSE 5032
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4946: LD_ADDR_VAR 0 3
4950: PUSH
4951: LD_VAR 0 3
4955: PPUSH
4956: LD_VAR 0 3
4960: PUSH
4961: LD_INT 1
4963: PLUS
4964: PPUSH
4965: LD_INT 14
4967: PUSH
4968: LD_INT 13
4970: PUSH
4971: EMPTY
4972: LIST
4973: LIST
4974: PUSH
4975: LD_INT 1
4977: PPUSH
4978: LD_INT 2
4980: PPUSH
4981: CALL_OW 12
4985: ARRAY
4986: PUSH
4987: LD_INT 1
4989: PUSH
4990: LD_INT 2
4992: PUSH
4993: LD_INT 28
4995: PUSH
4996: LD_INT 25
4998: PUSH
4999: LD_INT 27
5001: PUSH
5002: EMPTY
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: LD_INT 1
5009: PPUSH
5010: LD_INT 3
5012: PPUSH
5013: CALL_OW 12
5017: ARRAY
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: LIST
5023: LIST
5024: PPUSH
5025: CALL_OW 2
5029: ST_TO_ADDR
5030: GO 4943
5032: POP
5033: POP
// MC_InsertProduceList ( base , tmp ) ;
5034: LD_VAR 0 2
5038: PPUSH
5039: LD_VAR 0 3
5043: PPUSH
5044: CALL 76670 0 2
// repeat wait ( 0 0$1 ) ;
5048: LD_INT 35
5050: PPUSH
5051: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5055: LD_VAR 0 2
5059: PPUSH
5060: LD_INT 1
5062: PPUSH
5063: CALL 78088 0 2
5067: PUSH
5068: LD_VAR 0 5
5072: GREATEREQUAL
5073: IFFALSE 5048
// wait ( 0 0$30 ) ;
5075: LD_INT 1050
5077: PPUSH
5078: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5082: LD_ADDR_VAR 0 4
5086: PUSH
5087: LD_EXP 42
5091: PUSH
5092: LD_VAR 0 2
5096: ARRAY
5097: PUSH
5098: LD_EXP 42
5102: PUSH
5103: LD_VAR 0 2
5107: ARRAY
5108: PPUSH
5109: LD_INT 2
5111: PUSH
5112: LD_INT 34
5114: PUSH
5115: LD_INT 31
5117: PUSH
5118: EMPTY
5119: LIST
5120: LIST
5121: PUSH
5122: LD_INT 34
5124: PUSH
5125: LD_INT 32
5127: PUSH
5128: EMPTY
5129: LIST
5130: LIST
5131: PUSH
5132: LD_INT 34
5134: PUSH
5135: LD_INT 88
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: PPUSH
5148: CALL_OW 72
5152: DIFF
5153: ST_TO_ADDR
// if not attackers then
5154: LD_VAR 0 4
5158: NOT
5159: IFFALSE 5163
// exit ;
5161: GO 5386
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5163: LD_ADDR_EXP 42
5167: PUSH
5168: LD_EXP 42
5172: PPUSH
5173: LD_VAR 0 2
5177: PPUSH
5178: LD_EXP 42
5182: PUSH
5183: LD_VAR 0 2
5187: ARRAY
5188: PUSH
5189: LD_VAR 0 4
5193: DIFF
5194: PPUSH
5195: CALL_OW 1
5199: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5200: LD_VAR 0 4
5204: PPUSH
5205: LD_INT 107
5207: PPUSH
5208: LD_INT 74
5210: PPUSH
5211: CALL_OW 114
// wait ( 0 0$5 ) ;
5215: LD_INT 175
5217: PPUSH
5218: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5222: LD_INT 35
5224: PPUSH
5225: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5229: LD_VAR 0 4
5233: PPUSH
5234: LD_INT 60
5236: PUSH
5237: EMPTY
5238: LIST
5239: PPUSH
5240: CALL_OW 72
5244: NOT
5245: IFFALSE 5222
// if rand ( 0 , 1 ) then
5247: LD_INT 0
5249: PPUSH
5250: LD_INT 1
5252: PPUSH
5253: CALL_OW 12
5257: IFFALSE 5276
// ComAgressiveMove ( attackers , 155 , 108 ) else
5259: LD_VAR 0 4
5263: PPUSH
5264: LD_INT 155
5266: PPUSH
5267: LD_INT 108
5269: PPUSH
5270: CALL_OW 114
5274: GO 5291
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5276: LD_VAR 0 4
5280: PPUSH
5281: LD_INT 149
5283: PPUSH
5284: LD_INT 55
5286: PPUSH
5287: CALL_OW 114
// wait ( 0 0$10 ) ;
5291: LD_INT 350
5293: PPUSH
5294: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5298: LD_INT 35
5300: PPUSH
5301: CALL_OW 67
// for i in attackers do
5305: LD_ADDR_VAR 0 1
5309: PUSH
5310: LD_VAR 0 4
5314: PUSH
5315: FOR_IN
5316: IFFALSE 5366
// if not HasTask ( i ) then
5318: LD_VAR 0 1
5322: PPUSH
5323: CALL_OW 314
5327: NOT
5328: IFFALSE 5364
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5330: LD_VAR 0 1
5334: PPUSH
5335: LD_INT 81
5337: PUSH
5338: LD_INT 2
5340: PUSH
5341: EMPTY
5342: LIST
5343: LIST
5344: PPUSH
5345: CALL_OW 69
5349: PPUSH
5350: LD_VAR 0 1
5354: PPUSH
5355: CALL_OW 74
5359: PPUSH
5360: CALL_OW 115
5364: GO 5315
5366: POP
5367: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5368: LD_VAR 0 4
5372: PPUSH
5373: LD_INT 50
5375: PUSH
5376: EMPTY
5377: LIST
5378: PPUSH
5379: CALL_OW 72
5383: NOT
5384: IFFALSE 5298
// end ;
5386: PPOPN 5
5388: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5389: LD_EXP 4
5393: NOT
5394: PUSH
5395: LD_OWVAR 1
5399: PUSH
5400: LD_INT 191100
5402: LESS
5403: AND
5404: IFFALSE 6076
5406: GO 5408
5408: DISABLE
5409: LD_INT 0
5411: PPUSH
5412: PPUSH
5413: PPUSH
// begin enable ;
5414: ENABLE
// tmp := [ ] ;
5415: LD_ADDR_VAR 0 3
5419: PUSH
5420: EMPTY
5421: ST_TO_ADDR
// if tick < 35 35$00 then
5422: LD_OWVAR 1
5426: PUSH
5427: LD_INT 73500
5429: LESS
5430: IFFALSE 5628
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5432: LD_ADDR_VAR 0 1
5436: PUSH
5437: DOUBLE
5438: LD_INT 1
5440: DEC
5441: ST_TO_ADDR
5442: LD_INT 4
5444: PUSH
5445: LD_INT 5
5447: PUSH
5448: LD_INT 5
5450: PUSH
5451: EMPTY
5452: LIST
5453: LIST
5454: LIST
5455: PUSH
5456: LD_OWVAR 67
5460: ARRAY
5461: PUSH
5462: FOR_TO
5463: IFFALSE 5624
// begin uc_side := 2 ;
5465: LD_ADDR_OWVAR 20
5469: PUSH
5470: LD_INT 2
5472: ST_TO_ADDR
// uc_nation := 2 ;
5473: LD_ADDR_OWVAR 21
5477: PUSH
5478: LD_INT 2
5480: ST_TO_ADDR
// InitHC_All ( ) ;
5481: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5485: LD_INT 0
5487: PPUSH
5488: LD_INT 1
5490: PPUSH
5491: LD_INT 5
5493: PUSH
5494: LD_INT 6
5496: PUSH
5497: LD_INT 7
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: PUSH
5505: LD_OWVAR 67
5509: ARRAY
5510: PPUSH
5511: CALL_OW 380
// un := CreateHuman ;
5515: LD_ADDR_VAR 0 2
5519: PUSH
5520: CALL_OW 44
5524: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5525: LD_VAR 0 2
5529: PPUSH
5530: LD_INT 17
5532: PPUSH
5533: LD_INT 0
5535: PPUSH
5536: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_INT 1
5547: PUSH
5548: LD_INT 8
5550: PUSH
5551: EMPTY
5552: LIST
5553: LIST
5554: PUSH
5555: LD_INT 1
5557: PPUSH
5558: LD_INT 2
5560: PPUSH
5561: CALL_OW 12
5565: ARRAY
5566: PPUSH
5567: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5571: LD_VAR 0 2
5575: PPUSH
5576: LD_INT 111
5578: PPUSH
5579: LD_INT 34
5581: PPUSH
5582: CALL_OW 114
// wait ( 0 0$2 ) ;
5586: LD_INT 70
5588: PPUSH
5589: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5593: LD_ADDR_VAR 0 3
5597: PUSH
5598: LD_VAR 0 3
5602: PPUSH
5603: LD_VAR 0 3
5607: PUSH
5608: LD_INT 1
5610: PLUS
5611: PPUSH
5612: LD_VAR 0 2
5616: PPUSH
5617: CALL_OW 1
5621: ST_TO_ADDR
// end ;
5622: GO 5462
5624: POP
5625: POP
// end else
5626: GO 5769
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5628: LD_ADDR_VAR 0 1
5632: PUSH
5633: DOUBLE
5634: LD_INT 1
5636: DEC
5637: ST_TO_ADDR
5638: LD_INT 4
5640: PUSH
5641: LD_INT 5
5643: PUSH
5644: LD_INT 5
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_OWVAR 67
5656: ARRAY
5657: PUSH
5658: FOR_TO
5659: IFFALSE 5767
// begin uc_side := 2 ;
5661: LD_ADDR_OWVAR 20
5665: PUSH
5666: LD_INT 2
5668: ST_TO_ADDR
// uc_nation := 0 ;
5669: LD_ADDR_OWVAR 21
5673: PUSH
5674: LD_INT 0
5676: ST_TO_ADDR
// InitHC_All ( ) ;
5677: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5681: LD_ADDR_OWVAR 28
5685: PUSH
5686: LD_INT 17
5688: ST_TO_ADDR
// un := CreateHuman ;
5689: LD_ADDR_VAR 0 2
5693: PUSH
5694: CALL_OW 44
5698: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5699: LD_VAR 0 2
5703: PPUSH
5704: LD_INT 17
5706: PPUSH
5707: LD_INT 0
5709: PPUSH
5710: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5714: LD_VAR 0 2
5718: PPUSH
5719: LD_INT 110
5721: PPUSH
5722: LD_INT 33
5724: PPUSH
5725: CALL_OW 114
// wait ( 0 0$2 ) ;
5729: LD_INT 70
5731: PPUSH
5732: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5736: LD_ADDR_VAR 0 3
5740: PUSH
5741: LD_VAR 0 3
5745: PPUSH
5746: LD_VAR 0 3
5750: PUSH
5751: LD_INT 1
5753: PLUS
5754: PPUSH
5755: LD_VAR 0 2
5759: PPUSH
5760: CALL_OW 1
5764: ST_TO_ADDR
// end ;
5765: GO 5658
5767: POP
5768: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5769: LD_ADDR_VAR 0 1
5773: PUSH
5774: DOUBLE
5775: LD_INT 1
5777: DEC
5778: ST_TO_ADDR
5779: LD_INT 3
5781: PUSH
5782: LD_INT 4
5784: PUSH
5785: LD_INT 5
5787: PUSH
5788: EMPTY
5789: LIST
5790: LIST
5791: LIST
5792: PUSH
5793: LD_OWVAR 67
5797: ARRAY
5798: PUSH
5799: FOR_TO
5800: IFFALSE 5965
// begin uc_side := 2 ;
5802: LD_ADDR_OWVAR 20
5806: PUSH
5807: LD_INT 2
5809: ST_TO_ADDR
// uc_nation := 2 ;
5810: LD_ADDR_OWVAR 21
5814: PUSH
5815: LD_INT 2
5817: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5818: LD_INT 14
5820: PPUSH
5821: LD_INT 3
5823: PPUSH
5824: LD_INT 5
5826: PPUSH
5827: LD_INT 29
5829: PUSH
5830: LD_INT 28
5832: PUSH
5833: LD_INT 27
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: LIST
5840: PUSH
5841: LD_INT 1
5843: PPUSH
5844: LD_INT 3
5846: PPUSH
5847: CALL_OW 12
5851: ARRAY
5852: PPUSH
5853: LD_INT 90
5855: PPUSH
5856: CALL 15988 0 5
// un := CreateVehicle ;
5860: LD_ADDR_VAR 0 2
5864: PUSH
5865: CALL_OW 45
5869: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5870: LD_VAR 0 2
5874: PPUSH
5875: LD_INT 2
5877: PPUSH
5878: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5882: LD_VAR 0 2
5886: PPUSH
5887: LD_INT 17
5889: PPUSH
5890: LD_INT 0
5892: PPUSH
5893: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5897: LD_VAR 0 2
5901: PPUSH
5902: LD_INT 66
5904: PPUSH
5905: LD_INT 23
5907: PPUSH
5908: CALL_OW 111
// wait ( 0 0$3 ) ;
5912: LD_INT 105
5914: PPUSH
5915: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5919: LD_VAR 0 2
5923: PPUSH
5924: LD_INT 147
5926: PPUSH
5927: LD_INT 103
5929: PPUSH
5930: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5934: LD_ADDR_VAR 0 3
5938: PUSH
5939: LD_VAR 0 3
5943: PPUSH
5944: LD_VAR 0 3
5948: PUSH
5949: LD_INT 1
5951: PLUS
5952: PPUSH
5953: LD_VAR 0 2
5957: PPUSH
5958: CALL_OW 1
5962: ST_TO_ADDR
// end ;
5963: GO 5799
5965: POP
5966: POP
// if not tmp then
5967: LD_VAR 0 3
5971: NOT
5972: IFFALSE 5976
// exit ;
5974: GO 6076
// wait ( 0 0$5 ) ;
5976: LD_INT 175
5978: PPUSH
5979: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
5983: LD_INT 70
5985: PPUSH
5986: CALL_OW 67
// for i in tmp do
5990: LD_ADDR_VAR 0 1
5994: PUSH
5995: LD_VAR 0 3
5999: PUSH
6000: FOR_IN
6001: IFFALSE 6067
// begin if not IsOk ( i ) then
6003: LD_VAR 0 1
6007: PPUSH
6008: CALL_OW 302
6012: NOT
6013: IFFALSE 6031
// tmp := tmp diff i ;
6015: LD_ADDR_VAR 0 3
6019: PUSH
6020: LD_VAR 0 3
6024: PUSH
6025: LD_VAR 0 1
6029: DIFF
6030: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6031: LD_VAR 0 1
6035: PPUSH
6036: LD_INT 81
6038: PUSH
6039: LD_INT 2
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: PPUSH
6046: CALL_OW 69
6050: PPUSH
6051: LD_VAR 0 1
6055: PPUSH
6056: CALL_OW 74
6060: PPUSH
6061: CALL_OW 115
// end ;
6065: GO 6000
6067: POP
6068: POP
// until not tmp ;
6069: LD_VAR 0 3
6073: NOT
6074: IFFALSE 5983
// end ;
6076: PPOPN 3
6078: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6079: LD_OWVAR 67
6083: PUSH
6084: LD_INT 1
6086: GREATER
6087: IFFALSE 6185
6089: GO 6091
6091: DISABLE
6092: LD_INT 0
6094: PPUSH
// begin uc_side := 2 ;
6095: LD_ADDR_OWVAR 20
6099: PUSH
6100: LD_INT 2
6102: ST_TO_ADDR
// uc_nation := 2 ;
6103: LD_ADDR_OWVAR 21
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6111: LD_INT 0
6113: PPUSH
6114: LD_INT 4
6116: PPUSH
6117: LD_INT 6
6119: PPUSH
6120: CALL_OW 380
// un := CreateHuman ;
6124: LD_ADDR_VAR 0 1
6128: PUSH
6129: CALL_OW 44
6133: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6134: LD_VAR 0 1
6138: PPUSH
6139: LD_INT 88
6141: PPUSH
6142: LD_INT 1
6144: PPUSH
6145: LD_INT 2
6147: PPUSH
6148: LD_INT 0
6150: PPUSH
6151: CALL 50581 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6155: LD_VAR 0 1
6159: PPUSH
6160: LD_INT 130
6162: PPUSH
6163: LD_INT 35
6165: PPUSH
6166: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6170: LD_VAR 0 1
6174: PPUSH
6175: LD_INT 132
6177: PPUSH
6178: LD_INT 39
6180: PPUSH
6181: CALL_OW 218
// end ;
6185: PPOPN 1
6187: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6188: LD_INT 22
6190: PUSH
6191: LD_INT 2
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: LD_INT 33
6200: PUSH
6201: LD_INT 2
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: PUSH
6208: LD_INT 50
6210: PUSH
6211: EMPTY
6212: LIST
6213: PUSH
6214: LD_INT 3
6216: PUSH
6217: LD_INT 61
6219: PUSH
6220: EMPTY
6221: LIST
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PPUSH
6233: CALL_OW 69
6237: IFFALSE 6328
6239: GO 6241
6241: DISABLE
6242: LD_INT 0
6244: PPUSH
6245: PPUSH
// begin enable ;
6246: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6247: LD_ADDR_VAR 0 2
6251: PUSH
6252: LD_INT 22
6254: PUSH
6255: LD_INT 2
6257: PUSH
6258: EMPTY
6259: LIST
6260: LIST
6261: PUSH
6262: LD_INT 33
6264: PUSH
6265: LD_INT 2
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: PUSH
6272: LD_INT 50
6274: PUSH
6275: EMPTY
6276: LIST
6277: PUSH
6278: LD_INT 3
6280: PUSH
6281: LD_INT 61
6283: PUSH
6284: EMPTY
6285: LIST
6286: PUSH
6287: EMPTY
6288: LIST
6289: LIST
6290: PUSH
6291: EMPTY
6292: LIST
6293: LIST
6294: LIST
6295: LIST
6296: PPUSH
6297: CALL_OW 69
6301: ST_TO_ADDR
// for i in tmp do
6302: LD_ADDR_VAR 0 1
6306: PUSH
6307: LD_VAR 0 2
6311: PUSH
6312: FOR_IN
6313: IFFALSE 6326
// Connect ( i ) ;
6315: LD_VAR 0 1
6319: PPUSH
6320: CALL 19079 0 1
6324: GO 6312
6326: POP
6327: POP
// end ; end_of_file
6328: PPOPN 2
6330: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6331: LD_INT 0
6333: PPUSH
6334: PPUSH
6335: PPUSH
6336: PPUSH
6337: PPUSH
6338: PPUSH
// popov_side := 3 ;
6339: LD_ADDR_EXP 17
6343: PUSH
6344: LD_INT 3
6346: ST_TO_ADDR
// uc_side := popov_side ;
6347: LD_ADDR_OWVAR 20
6351: PUSH
6352: LD_EXP 17
6356: ST_TO_ADDR
// uc_nation := 3 ;
6357: LD_ADDR_OWVAR 21
6361: PUSH
6362: LD_INT 3
6364: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6365: LD_ADDR_VAR 0 6
6369: PUSH
6370: LD_INT 5
6372: PUSH
6373: LD_INT 103
6375: PUSH
6376: LD_INT 147
6378: PUSH
6379: LD_INT 3
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: LIST
6386: LIST
6387: PUSH
6388: LD_INT 5
6390: PUSH
6391: LD_INT 70
6393: PUSH
6394: LD_INT 117
6396: PUSH
6397: LD_INT 3
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: LIST
6405: PUSH
6406: LD_INT 6
6408: PUSH
6409: LD_INT 76
6411: PUSH
6412: LD_INT 145
6414: PUSH
6415: LD_INT 1
6417: PUSH
6418: LD_INT 10
6420: PUSH
6421: LD_INT 11
6423: PUSH
6424: EMPTY
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 26
6434: PUSH
6435: LD_INT 87
6437: PUSH
6438: LD_INT 144
6440: PUSH
6441: LD_INT 0
6443: PUSH
6444: EMPTY
6445: LIST
6446: LIST
6447: LIST
6448: LIST
6449: PUSH
6450: LD_INT 29
6452: PUSH
6453: LD_INT 86
6455: PUSH
6456: LD_INT 118
6458: PUSH
6459: LD_INT 0
6461: PUSH
6462: EMPTY
6463: LIST
6464: LIST
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 29
6470: PUSH
6471: LD_INT 98
6473: PUSH
6474: LD_INT 121
6476: PUSH
6477: LD_INT 0
6479: PUSH
6480: EMPTY
6481: LIST
6482: LIST
6483: LIST
6484: LIST
6485: PUSH
6486: LD_INT 26
6488: PUSH
6489: LD_INT 87
6491: PUSH
6492: LD_INT 147
6494: PUSH
6495: LD_INT 1
6497: PUSH
6498: EMPTY
6499: LIST
6500: LIST
6501: LIST
6502: LIST
6503: PUSH
6504: LD_INT 30
6506: PUSH
6507: LD_INT 123
6509: PUSH
6510: LD_INT 151
6512: PUSH
6513: LD_INT 1
6515: PUSH
6516: EMPTY
6517: LIST
6518: LIST
6519: LIST
6520: LIST
6521: PUSH
6522: LD_INT 3
6524: PUSH
6525: LD_INT 94
6527: PUSH
6528: LD_INT 161
6530: PUSH
6531: LD_INT 0
6533: PUSH
6534: EMPTY
6535: LIST
6536: LIST
6537: LIST
6538: LIST
6539: PUSH
6540: LD_INT 6
6542: PUSH
6543: LD_INT 81
6545: PUSH
6546: LD_INT 155
6548: PUSH
6549: LD_INT 1
6551: PUSH
6552: LD_INT 12
6554: PUSH
6555: LD_INT 14
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: LIST
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 26
6568: PUSH
6569: LD_INT 96
6571: PUSH
6572: LD_INT 152
6574: PUSH
6575: LD_INT 0
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_INT 26
6586: PUSH
6587: LD_INT 96
6589: PUSH
6590: LD_INT 149
6592: PUSH
6593: LD_INT 3
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: LIST
6600: LIST
6601: PUSH
6602: LD_INT 32
6604: PUSH
6605: LD_INT 109
6607: PUSH
6608: LD_INT 142
6610: PUSH
6611: LD_INT 3
6613: PUSH
6614: LD_INT 46
6616: PUSH
6617: EMPTY
6618: LIST
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 32
6626: PUSH
6627: LD_INT 112
6629: PUSH
6630: LD_INT 148
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: LD_INT 46
6638: PUSH
6639: EMPTY
6640: LIST
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 33
6648: PUSH
6649: LD_INT 120
6651: PUSH
6652: LD_INT 159
6654: PUSH
6655: LD_INT 4
6657: PUSH
6658: LD_INT 45
6660: PUSH
6661: EMPTY
6662: LIST
6663: LIST
6664: LIST
6665: LIST
6666: LIST
6667: PUSH
6668: LD_INT 33
6670: PUSH
6671: LD_INT 122
6673: PUSH
6674: LD_INT 163
6676: PUSH
6677: LD_INT 4
6679: PUSH
6680: LD_INT 45
6682: PUSH
6683: EMPTY
6684: LIST
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 33
6692: PUSH
6693: LD_INT 123
6695: PUSH
6696: LD_INT 167
6698: PUSH
6699: LD_INT 4
6701: PUSH
6702: LD_INT 45
6704: PUSH
6705: EMPTY
6706: LIST
6707: LIST
6708: LIST
6709: LIST
6710: LIST
6711: PUSH
6712: LD_INT 33
6714: PUSH
6715: LD_INT 59
6717: PUSH
6718: LD_INT 111
6720: PUSH
6721: LD_INT 3
6723: PUSH
6724: LD_INT 45
6726: PUSH
6727: EMPTY
6728: LIST
6729: LIST
6730: LIST
6731: LIST
6732: LIST
6733: PUSH
6734: LD_INT 33
6736: PUSH
6737: LD_INT 65
6739: PUSH
6740: LD_INT 111
6742: PUSH
6743: LD_INT 3
6745: PUSH
6746: LD_INT 46
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: LIST
6753: LIST
6754: LIST
6755: PUSH
6756: LD_INT 33
6758: PUSH
6759: LD_INT 76
6761: PUSH
6762: LD_INT 117
6764: PUSH
6765: LD_INT 3
6767: PUSH
6768: LD_INT 45
6770: PUSH
6771: EMPTY
6772: LIST
6773: LIST
6774: LIST
6775: LIST
6776: LIST
6777: PUSH
6778: LD_INT 33
6780: PUSH
6781: LD_INT 80
6783: PUSH
6784: LD_INT 119
6786: PUSH
6787: LD_INT 3
6789: PUSH
6790: LD_INT 46
6792: PUSH
6793: EMPTY
6794: LIST
6795: LIST
6796: LIST
6797: LIST
6798: LIST
6799: PUSH
6800: LD_INT 33
6802: PUSH
6803: LD_INT 87
6805: PUSH
6806: LD_INT 125
6808: PUSH
6809: LD_INT 3
6811: PUSH
6812: LD_INT 45
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: LIST
6821: PUSH
6822: LD_INT 5
6824: PUSH
6825: LD_INT 92
6827: PUSH
6828: LD_INT 129
6830: PUSH
6831: LD_INT 3
6833: PUSH
6834: EMPTY
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 28
6842: PUSH
6843: LD_INT 85
6845: PUSH
6846: LD_INT 165
6848: PUSH
6849: LD_INT 0
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: LIST
6856: LIST
6857: PUSH
6858: LD_INT 28
6860: PUSH
6861: LD_INT 83
6863: PUSH
6864: LD_INT 161
6866: PUSH
6867: LD_INT 4
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: LIST
6874: LIST
6875: PUSH
6876: LD_INT 28
6878: PUSH
6879: LD_INT 91
6881: PUSH
6882: LD_INT 166
6884: PUSH
6885: LD_INT 3
6887: PUSH
6888: EMPTY
6889: LIST
6890: LIST
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 28
6896: PUSH
6897: LD_INT 102
6899: PUSH
6900: LD_INT 166
6902: PUSH
6903: LD_INT 2
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: LIST
6920: LIST
6921: LIST
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: LIST
6928: LIST
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: LIST
6937: LIST
6938: LIST
6939: LIST
6940: ST_TO_ADDR
// for i in list do
6941: LD_ADDR_VAR 0 2
6945: PUSH
6946: LD_VAR 0 6
6950: PUSH
6951: FOR_IN
6952: IFFALSE 7116
// begin uc_side := 3 ;
6954: LD_ADDR_OWVAR 20
6958: PUSH
6959: LD_INT 3
6961: ST_TO_ADDR
// uc_nation := 3 ;
6962: LD_ADDR_OWVAR 21
6966: PUSH
6967: LD_INT 3
6969: ST_TO_ADDR
// InitBc ;
6970: CALL_OW 21
// bc_type := i [ 1 ] ;
6974: LD_ADDR_OWVAR 42
6978: PUSH
6979: LD_VAR 0 2
6983: PUSH
6984: LD_INT 1
6986: ARRAY
6987: ST_TO_ADDR
// if i [ 1 ] = b_lab then
6988: LD_VAR 0 2
6992: PUSH
6993: LD_INT 1
6995: ARRAY
6996: PUSH
6997: LD_INT 6
6999: EQUAL
7000: IFFALSE 7038
// begin bc_type := b_lab_full ;
7002: LD_ADDR_OWVAR 42
7006: PUSH
7007: LD_INT 8
7009: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7010: LD_ADDR_OWVAR 44
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 5
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7024: LD_ADDR_OWVAR 45
7028: PUSH
7029: LD_VAR 0 2
7033: PUSH
7034: LD_INT 6
7036: ARRAY
7037: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7038: LD_ADDR_VAR 0 5
7042: PUSH
7043: LD_VAR 0 2
7047: PUSH
7048: LD_INT 2
7050: ARRAY
7051: PPUSH
7052: LD_VAR 0 2
7056: PUSH
7057: LD_INT 3
7059: ARRAY
7060: PPUSH
7061: LD_VAR 0 2
7065: PUSH
7066: LD_INT 4
7068: ARRAY
7069: PPUSH
7070: CALL_OW 47
7074: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7075: LD_VAR 0 2
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PUSH
7084: LD_INT 33
7086: PUSH
7087: LD_INT 32
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: IN
7094: IFFALSE 7114
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_VAR 0 2
7105: PUSH
7106: LD_INT 5
7108: ARRAY
7109: PPUSH
7110: CALL_OW 431
// end ;
7114: GO 6951
7116: POP
7117: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7118: LD_ADDR_VAR 0 4
7122: PUSH
7123: LD_INT 9
7125: PPUSH
7126: LD_INT 3
7128: PPUSH
7129: LD_STRING 
7131: PPUSH
7132: LD_INT 8
7134: PUSH
7135: LD_INT 7
7137: PUSH
7138: LD_INT 6
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: LD_OWVAR 67
7150: ARRAY
7151: PPUSH
7152: LD_INT 11500
7154: PUSH
7155: LD_INT 1100
7157: PUSH
7158: LD_INT 60
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PPUSH
7166: LD_INT 6
7168: PUSH
7169: LD_INT 6
7171: PUSH
7172: LD_INT 6
7174: PUSH
7175: LD_INT 6
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL 19432 0 6
7188: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7189: LD_ADDR_EXP 23
7193: PUSH
7194: LD_EXP 23
7198: PPUSH
7199: LD_INT 3
7201: PPUSH
7202: LD_VAR 0 4
7206: PUSH
7207: LD_INT 22
7209: PUSH
7210: LD_INT 3
7212: PUSH
7213: EMPTY
7214: LIST
7215: LIST
7216: PUSH
7217: LD_INT 21
7219: PUSH
7220: LD_INT 3
7222: PUSH
7223: EMPTY
7224: LIST
7225: LIST
7226: PUSH
7227: EMPTY
7228: LIST
7229: LIST
7230: PPUSH
7231: CALL_OW 69
7235: UNION
7236: PPUSH
7237: CALL_OW 1
7241: ST_TO_ADDR
// extraPopovForces := [ ] ;
7242: LD_ADDR_EXP 18
7246: PUSH
7247: EMPTY
7248: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7249: LD_ADDR_VAR 0 2
7253: PUSH
7254: DOUBLE
7255: LD_INT 1
7257: DEC
7258: ST_TO_ADDR
7259: LD_INT 8
7261: PUSH
7262: LD_INT 9
7264: PUSH
7265: LD_INT 10
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: PUSH
7273: LD_OWVAR 67
7277: ARRAY
7278: PUSH
7279: FOR_TO
7280: IFFALSE 7409
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7282: LD_INT 0
7284: PPUSH
7285: LD_INT 1
7287: PPUSH
7288: LD_INT 4
7290: PUSH
7291: LD_INT 5
7293: PUSH
7294: LD_INT 6
7296: PUSH
7297: EMPTY
7298: LIST
7299: LIST
7300: LIST
7301: PUSH
7302: LD_OWVAR 67
7306: ARRAY
7307: PPUSH
7308: CALL_OW 380
// un := CreateHuman ;
7312: LD_ADDR_VAR 0 3
7316: PUSH
7317: CALL_OW 44
7321: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7322: LD_INT 0
7324: PPUSH
7325: LD_INT 1
7327: PPUSH
7328: CALL_OW 12
7332: IFFALSE 7357
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7334: LD_VAR 0 3
7338: PPUSH
7339: LD_INT 131
7341: PPUSH
7342: LD_INT 110
7344: PPUSH
7345: LD_INT 8
7347: PPUSH
7348: LD_INT 0
7350: PPUSH
7351: CALL_OW 50
7355: GO 7378
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7357: LD_VAR 0 3
7361: PPUSH
7362: LD_INT 100
7364: PPUSH
7365: LD_INT 99
7367: PPUSH
7368: LD_INT 8
7370: PPUSH
7371: LD_INT 0
7373: PPUSH
7374: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7378: LD_ADDR_EXP 18
7382: PUSH
7383: LD_EXP 18
7387: PPUSH
7388: LD_EXP 18
7392: PUSH
7393: LD_INT 1
7395: PLUS
7396: PPUSH
7397: LD_VAR 0 3
7401: PPUSH
7402: CALL_OW 1
7406: ST_TO_ADDR
// end ;
7407: GO 7279
7409: POP
7410: POP
// PrepareSoldier ( false , 6 ) ;
7411: LD_INT 0
7413: PPUSH
7414: LD_INT 6
7416: PPUSH
7417: CALL_OW 381
// un := CreateHuman ;
7421: LD_ADDR_VAR 0 3
7425: PUSH
7426: CALL_OW 44
7430: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7431: LD_VAR 0 3
7435: PPUSH
7436: LD_INT 1
7438: PPUSH
7439: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7443: LD_VAR 0 3
7447: PPUSH
7448: LD_INT 150
7450: PPUSH
7451: LD_INT 158
7453: PPUSH
7454: CALL_OW 428
7458: PPUSH
7459: CALL_OW 52
// popovAttackGroup := [ ] ;
7463: LD_ADDR_EXP 19
7467: PUSH
7468: EMPTY
7469: ST_TO_ADDR
// end ;
7470: LD_VAR 0 1
7474: RET
// export function InitMC_Popov ( ) ; begin
7475: LD_INT 0
7477: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7478: LD_INT 3
7480: PPUSH
7481: LD_INT 3
7483: PPUSH
7484: CALL 77943 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7488: LD_INT 3
7490: PPUSH
7491: LD_INT 10
7493: PPUSH
7494: CALL 77887 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7498: LD_INT 3
7500: PPUSH
7501: LD_INT 86
7503: PUSH
7504: LD_INT 118
7506: PUSH
7507: LD_INT 0
7509: PUSH
7510: EMPTY
7511: LIST
7512: LIST
7513: LIST
7514: PUSH
7515: LD_INT 123
7517: PUSH
7518: LD_INT 151
7520: PUSH
7521: LD_INT 1
7523: PUSH
7524: EMPTY
7525: LIST
7526: LIST
7527: LIST
7528: PUSH
7529: LD_INT 98
7531: PUSH
7532: LD_INT 121
7534: PUSH
7535: LD_INT 0
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: LIST
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: LIST
7547: PPUSH
7548: CALL 76946 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 46
7557: PUSH
7558: LD_INT 45
7560: PUSH
7561: EMPTY
7562: LIST
7563: LIST
7564: PPUSH
7565: CALL 77775 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7569: LD_INT 3
7571: PPUSH
7572: LD_INT 12
7574: PPUSH
7575: CALL 77457 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7579: LD_INT 3
7581: PPUSH
7582: LD_INT 11
7584: PPUSH
7585: CALL 77188 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7589: LD_INT 3
7591: PPUSH
7592: LD_INT 4
7594: PPUSH
7595: CALL 76807 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7599: LD_INT 3
7601: PPUSH
7602: LD_INT 23
7604: PUSH
7605: LD_INT 1
7607: PUSH
7608: LD_INT 3
7610: PUSH
7611: LD_INT 44
7613: PUSH
7614: EMPTY
7615: LIST
7616: LIST
7617: LIST
7618: LIST
7619: PUSH
7620: LD_INT 23
7622: PUSH
7623: LD_INT 1
7625: PUSH
7626: LD_INT 3
7628: PUSH
7629: LD_INT 45
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: PUSH
7638: LD_INT 21
7640: PUSH
7641: LD_INT 1
7643: PUSH
7644: LD_INT 3
7646: PUSH
7647: LD_INT 44
7649: PUSH
7650: EMPTY
7651: LIST
7652: LIST
7653: LIST
7654: LIST
7655: PUSH
7656: LD_INT 21
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 45
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: PPUSH
7680: CALL 76622 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7684: LD_INT 3
7686: PPUSH
7687: LD_INT 94
7689: PPUSH
7690: LD_INT 161
7692: PPUSH
7693: LD_INT 0
7695: PPUSH
7696: LD_INT 19
7698: PUSH
7699: LD_INT 17
7701: PUSH
7702: LD_INT 18
7704: PUSH
7705: LD_INT 24
7707: PUSH
7708: LD_INT 21
7710: PUSH
7711: EMPTY
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: PPUSH
7718: CALL 77569 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7722: LD_INT 3
7724: PPUSH
7725: LD_INT 21
7727: PUSH
7728: LD_INT 1
7730: PUSH
7731: LD_INT 3
7733: PUSH
7734: LD_INT 51
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: LIST
7741: LIST
7742: PUSH
7743: EMPTY
7744: LIST
7745: PPUSH
7746: CALL 76670 0 2
// end ;
7750: LD_VAR 0 1
7754: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7755: LD_EXP 18
7759: PUSH
7760: LD_EXP 5
7764: NOT
7765: AND
7766: IFFALSE 7826
7768: GO 7770
7770: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7771: LD_EXP 18
7775: PPUSH
7776: LD_INT 106
7778: PPUSH
7779: LD_INT 137
7781: PPUSH
7782: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7786: LD_ADDR_EXP 23
7790: PUSH
7791: LD_EXP 23
7795: PPUSH
7796: LD_INT 3
7798: PPUSH
7799: LD_EXP 23
7803: PUSH
7804: LD_INT 3
7806: ARRAY
7807: PUSH
7808: LD_EXP 18
7812: UNION
7813: PPUSH
7814: CALL_OW 1
7818: ST_TO_ADDR
// extraPopovForces := [ ] ;
7819: LD_ADDR_EXP 18
7823: PUSH
7824: EMPTY
7825: ST_TO_ADDR
// end ;
7826: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7827: LD_INT 9
7829: PPUSH
7830: CALL_OW 302
7834: PUSH
7835: LD_EXP 5
7839: NOT
7840: AND
7841: IFFALSE 8407
7843: GO 7845
7845: DISABLE
7846: LD_INT 0
7848: PPUSH
7849: PPUSH
7850: PPUSH
7851: PPUSH
7852: PPUSH
// begin enable ;
7853: ENABLE
// base := 3 ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_INT 3
7861: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7862: LD_ADDR_VAR 0 3
7866: PUSH
7867: LD_INT 22
7869: PUSH
7870: LD_INT 1
7872: PUSH
7873: LD_INT 3
7875: PUSH
7876: LD_INT 44
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: LIST
7883: LIST
7884: PUSH
7885: LD_INT 24
7887: PUSH
7888: LD_INT 1
7890: PUSH
7891: LD_INT 3
7893: PUSH
7894: LD_INT 46
7896: PUSH
7897: EMPTY
7898: LIST
7899: LIST
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 24
7905: PUSH
7906: LD_INT 1
7908: PUSH
7909: LD_INT 3
7911: PUSH
7912: LD_INT 46
7914: PUSH
7915: EMPTY
7916: LIST
7917: LIST
7918: LIST
7919: LIST
7920: PUSH
7921: LD_INT 24
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 46
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: EMPTY
7940: LIST
7941: LIST
7942: LIST
7943: LIST
7944: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7945: LD_ADDR_VAR 0 5
7949: PUSH
7950: LD_VAR 0 5
7954: PUSH
7955: LD_OWVAR 1
7959: PUSH
7960: LD_INT 21000
7962: DIV
7963: PLUS
7964: ST_TO_ADDR
// if amount > 8 then
7965: LD_VAR 0 5
7969: PUSH
7970: LD_INT 8
7972: GREATER
7973: IFFALSE 7983
// amount := 8 ;
7975: LD_ADDR_VAR 0 5
7979: PUSH
7980: LD_INT 8
7982: ST_TO_ADDR
// for i = 1 to amount do
7983: LD_ADDR_VAR 0 1
7987: PUSH
7988: DOUBLE
7989: LD_INT 1
7991: DEC
7992: ST_TO_ADDR
7993: LD_VAR 0 5
7997: PUSH
7998: FOR_TO
7999: IFFALSE 8064
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_VAR 0 3
8010: PPUSH
8011: LD_VAR 0 3
8015: PUSH
8016: LD_INT 1
8018: PLUS
8019: PPUSH
8020: LD_INT 24
8022: PUSH
8023: LD_INT 1
8025: PUSH
8026: LD_INT 3
8028: PUSH
8029: LD_INT 46
8031: PUSH
8032: LD_INT 45
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: PUSH
8039: LD_INT 1
8041: PPUSH
8042: LD_INT 2
8044: PPUSH
8045: CALL_OW 12
8049: ARRAY
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: LIST
8055: LIST
8056: PPUSH
8057: CALL_OW 2
8061: ST_TO_ADDR
8062: GO 7998
8064: POP
8065: POP
// MC_InsertProduceList ( base , tmp ) ;
8066: LD_VAR 0 2
8070: PPUSH
8071: LD_VAR 0 3
8075: PPUSH
8076: CALL 76670 0 2
// repeat wait ( 0 0$1 ) ;
8080: LD_INT 35
8082: PPUSH
8083: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8087: LD_VAR 0 2
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: CALL 78088 0 2
8099: PUSH
8100: LD_VAR 0 5
8104: GREATEREQUAL
8105: IFFALSE 8080
// wait ( 0 0$30 ) ;
8107: LD_INT 1050
8109: PPUSH
8110: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8114: LD_ADDR_VAR 0 4
8118: PUSH
8119: LD_EXP 42
8123: PUSH
8124: LD_VAR 0 2
8128: ARRAY
8129: PUSH
8130: LD_EXP 42
8134: PUSH
8135: LD_VAR 0 2
8139: ARRAY
8140: PPUSH
8141: LD_INT 2
8143: PUSH
8144: LD_INT 34
8146: PUSH
8147: LD_INT 51
8149: PUSH
8150: EMPTY
8151: LIST
8152: LIST
8153: PUSH
8154: LD_INT 34
8156: PUSH
8157: LD_INT 52
8159: PUSH
8160: EMPTY
8161: LIST
8162: LIST
8163: PUSH
8164: EMPTY
8165: LIST
8166: LIST
8167: LIST
8168: PPUSH
8169: CALL_OW 72
8173: DIFF
8174: ST_TO_ADDR
// if not attackers then
8175: LD_VAR 0 4
8179: NOT
8180: IFFALSE 8184
// exit ;
8182: GO 8407
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8184: LD_ADDR_EXP 42
8188: PUSH
8189: LD_EXP 42
8193: PPUSH
8194: LD_VAR 0 2
8198: PPUSH
8199: LD_EXP 42
8203: PUSH
8204: LD_VAR 0 2
8208: ARRAY
8209: PUSH
8210: LD_VAR 0 4
8214: DIFF
8215: PPUSH
8216: CALL_OW 1
8220: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8221: LD_VAR 0 4
8225: PPUSH
8226: LD_INT 107
8228: PPUSH
8229: LD_INT 74
8231: PPUSH
8232: CALL_OW 114
// wait ( 0 0$5 ) ;
8236: LD_INT 175
8238: PPUSH
8239: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8243: LD_INT 35
8245: PPUSH
8246: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8250: LD_VAR 0 4
8254: PPUSH
8255: LD_INT 60
8257: PUSH
8258: EMPTY
8259: LIST
8260: PPUSH
8261: CALL_OW 72
8265: NOT
8266: IFFALSE 8243
// if rand ( 0 , 1 ) then
8268: LD_INT 0
8270: PPUSH
8271: LD_INT 1
8273: PPUSH
8274: CALL_OW 12
8278: IFFALSE 8297
// ComAgressiveMove ( attackers , 155 , 108 ) else
8280: LD_VAR 0 4
8284: PPUSH
8285: LD_INT 155
8287: PPUSH
8288: LD_INT 108
8290: PPUSH
8291: CALL_OW 114
8295: GO 8312
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8297: LD_VAR 0 4
8301: PPUSH
8302: LD_INT 149
8304: PPUSH
8305: LD_INT 55
8307: PPUSH
8308: CALL_OW 114
// wait ( 0 0$10 ) ;
8312: LD_INT 350
8314: PPUSH
8315: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8319: LD_INT 35
8321: PPUSH
8322: CALL_OW 67
// for i in attackers do
8326: LD_ADDR_VAR 0 1
8330: PUSH
8331: LD_VAR 0 4
8335: PUSH
8336: FOR_IN
8337: IFFALSE 8387
// if not HasTask ( i ) then
8339: LD_VAR 0 1
8343: PPUSH
8344: CALL_OW 314
8348: NOT
8349: IFFALSE 8385
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8351: LD_VAR 0 1
8355: PPUSH
8356: LD_INT 81
8358: PUSH
8359: LD_INT 3
8361: PUSH
8362: EMPTY
8363: LIST
8364: LIST
8365: PPUSH
8366: CALL_OW 69
8370: PPUSH
8371: LD_VAR 0 1
8375: PPUSH
8376: CALL_OW 74
8380: PPUSH
8381: CALL_OW 115
8385: GO 8336
8387: POP
8388: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8389: LD_VAR 0 4
8393: PPUSH
8394: LD_INT 50
8396: PUSH
8397: EMPTY
8398: LIST
8399: PPUSH
8400: CALL_OW 72
8404: NOT
8405: IFFALSE 8319
// end ;
8407: PPOPN 5
8409: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8410: LD_EXP 5
8414: NOT
8415: IFFALSE 9002
8417: GO 8419
8419: DISABLE
8420: LD_INT 0
8422: PPUSH
8423: PPUSH
8424: PPUSH
8425: PPUSH
// begin enable ;
8426: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8427: LD_OWVAR 67
8431: PUSH
8432: LD_INT 1
8434: EQUAL
8435: PUSH
8436: LD_OWVAR 1
8440: PUSH
8441: LD_INT 63000
8443: LESS
8444: AND
8445: IFFALSE 8449
// exit ;
8447: GO 9002
// tmp := [ ] ;
8449: LD_ADDR_VAR 0 3
8453: PUSH
8454: EMPTY
8455: ST_TO_ADDR
// if tick < 45 45$00 then
8456: LD_OWVAR 1
8460: PUSH
8461: LD_INT 94500
8463: LESS
8464: IFFALSE 8641
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8466: LD_ADDR_VAR 0 1
8470: PUSH
8471: DOUBLE
8472: LD_INT 1
8474: DEC
8475: ST_TO_ADDR
8476: LD_INT 2
8478: PUSH
8479: LD_INT 3
8481: PUSH
8482: LD_INT 4
8484: PUSH
8485: EMPTY
8486: LIST
8487: LIST
8488: LIST
8489: PUSH
8490: LD_OWVAR 67
8494: ARRAY
8495: PUSH
8496: FOR_TO
8497: IFFALSE 8639
// begin uc_side := 3 ;
8499: LD_ADDR_OWVAR 20
8503: PUSH
8504: LD_INT 3
8506: ST_TO_ADDR
// uc_nation := 3 ;
8507: LD_ADDR_OWVAR 21
8511: PUSH
8512: LD_INT 3
8514: ST_TO_ADDR
// InitHC_All ( ) ;
8515: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8519: LD_INT 0
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 5
8527: PUSH
8528: LD_INT 6
8530: PUSH
8531: LD_INT 7
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: PPUSH
8545: CALL_OW 380
// un := CreateHuman ;
8549: LD_ADDR_VAR 0 2
8553: PUSH
8554: CALL_OW 44
8558: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8559: LD_VAR 0 2
8563: PPUSH
8564: LD_INT 18
8566: PPUSH
8567: LD_INT 0
8569: PPUSH
8570: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8574: LD_VAR 0 2
8578: PPUSH
8579: LD_INT 9
8581: PPUSH
8582: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8586: LD_VAR 0 2
8590: PPUSH
8591: LD_INT 147
8593: PPUSH
8594: LD_INT 161
8596: PPUSH
8597: CALL_OW 111
// wait ( 0 0$2 ) ;
8601: LD_INT 70
8603: PPUSH
8604: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8608: LD_ADDR_VAR 0 3
8612: PUSH
8613: LD_VAR 0 3
8617: PPUSH
8618: LD_VAR 0 3
8622: PUSH
8623: LD_INT 1
8625: PLUS
8626: PPUSH
8627: LD_VAR 0 2
8631: PPUSH
8632: CALL_OW 1
8636: ST_TO_ADDR
// end ;
8637: GO 8496
8639: POP
8640: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8641: LD_ADDR_VAR 0 4
8645: PUSH
8646: LD_INT 3
8648: PUSH
8649: LD_INT 4
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PUSH
8660: LD_OWVAR 67
8664: ARRAY
8665: PUSH
8666: LD_OWVAR 1
8670: PUSH
8671: LD_INT 21000
8673: DIV
8674: PLUS
8675: ST_TO_ADDR
// if amount > 15 then
8676: LD_VAR 0 4
8680: PUSH
8681: LD_INT 15
8683: GREATER
8684: IFFALSE 8694
// amount := 15 ;
8686: LD_ADDR_VAR 0 4
8690: PUSH
8691: LD_INT 15
8693: ST_TO_ADDR
// for i := 1 to amount do
8694: LD_ADDR_VAR 0 1
8698: PUSH
8699: DOUBLE
8700: LD_INT 1
8702: DEC
8703: ST_TO_ADDR
8704: LD_VAR 0 4
8708: PUSH
8709: FOR_TO
8710: IFFALSE 8856
// begin uc_side := 3 ;
8712: LD_ADDR_OWVAR 20
8716: PUSH
8717: LD_INT 3
8719: ST_TO_ADDR
// uc_nation := 3 ;
8720: LD_ADDR_OWVAR 21
8724: PUSH
8725: LD_INT 3
8727: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8728: LD_INT 24
8730: PPUSH
8731: LD_INT 1
8733: PPUSH
8734: LD_INT 3
8736: PPUSH
8737: LD_INT 46
8739: PUSH
8740: LD_INT 45
8742: PUSH
8743: LD_INT 44
8745: PUSH
8746: LD_INT 43
8748: PUSH
8749: LD_INT 42
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: LIST
8756: LIST
8757: LIST
8758: PUSH
8759: LD_INT 1
8761: PPUSH
8762: LD_INT 5
8764: PPUSH
8765: CALL_OW 12
8769: ARRAY
8770: PPUSH
8771: LD_INT 90
8773: PPUSH
8774: CALL 15988 0 5
// un := CreateVehicle ;
8778: LD_ADDR_VAR 0 2
8782: PUSH
8783: CALL_OW 45
8787: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8788: LD_VAR 0 2
8792: PPUSH
8793: LD_INT 18
8795: PPUSH
8796: LD_INT 0
8798: PPUSH
8799: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8803: LD_VAR 0 2
8807: PPUSH
8808: LD_INT 147
8810: PPUSH
8811: LD_INT 161
8813: PPUSH
8814: CALL_OW 111
// wait ( 0 0$3 ) ;
8818: LD_INT 105
8820: PPUSH
8821: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8825: LD_ADDR_VAR 0 3
8829: PUSH
8830: LD_VAR 0 3
8834: PPUSH
8835: LD_VAR 0 3
8839: PUSH
8840: LD_INT 1
8842: PLUS
8843: PPUSH
8844: LD_VAR 0 2
8848: PPUSH
8849: CALL_OW 1
8853: ST_TO_ADDR
// end ;
8854: GO 8709
8856: POP
8857: POP
// if not tmp then
8858: LD_VAR 0 3
8862: NOT
8863: IFFALSE 8867
// exit ;
8865: GO 9002
// wait ( 0 0$5 ) ;
8867: LD_INT 175
8869: PPUSH
8870: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8874: LD_INT 70
8876: PPUSH
8877: CALL_OW 67
// for i in tmp do
8881: LD_ADDR_VAR 0 1
8885: PUSH
8886: LD_VAR 0 3
8890: PUSH
8891: FOR_IN
8892: IFFALSE 8993
// begin if not IsOk ( i ) or IsDead ( i ) then
8894: LD_VAR 0 1
8898: PPUSH
8899: CALL_OW 302
8903: NOT
8904: PUSH
8905: LD_VAR 0 1
8909: PPUSH
8910: CALL_OW 301
8914: OR
8915: IFFALSE 8933
// tmp := tmp diff i ;
8917: LD_ADDR_VAR 0 3
8921: PUSH
8922: LD_VAR 0 3
8926: PUSH
8927: LD_VAR 0 1
8931: DIFF
8932: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8933: LD_VAR 0 1
8937: PPUSH
8938: CALL_OW 257
8942: PUSH
8943: LD_INT 9
8945: EQUAL
8946: IFFALSE 8957
// ComSpaceTimeShoot ( i ) ;
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL 11920 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8957: LD_VAR 0 1
8961: PPUSH
8962: LD_INT 81
8964: PUSH
8965: LD_INT 3
8967: PUSH
8968: EMPTY
8969: LIST
8970: LIST
8971: PPUSH
8972: CALL_OW 69
8976: PPUSH
8977: LD_VAR 0 1
8981: PPUSH
8982: CALL_OW 74
8986: PPUSH
8987: CALL_OW 115
// end ;
8991: GO 8891
8993: POP
8994: POP
// until not tmp ;
8995: LD_VAR 0 3
8999: NOT
9000: IFFALSE 8874
// end ; end_of_file
9002: PPOPN 4
9004: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9005: LD_INT 0
9007: PPUSH
9008: PPUSH
9009: PPUSH
9010: PPUSH
// uc_side := 1 ;
9011: LD_ADDR_OWVAR 20
9015: PUSH
9016: LD_INT 1
9018: ST_TO_ADDR
// uc_nation := 1 ;
9019: LD_ADDR_OWVAR 21
9023: PUSH
9024: LD_INT 1
9026: ST_TO_ADDR
// hc_importance := 100 ;
9027: LD_ADDR_OWVAR 32
9031: PUSH
9032: LD_INT 100
9034: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9035: LD_ADDR_OWVAR 26
9039: PUSH
9040: LD_STRING Jeremy Sikorski
9042: ST_TO_ADDR
// hc_gallery := us ;
9043: LD_ADDR_OWVAR 33
9047: PUSH
9048: LD_STRING us
9050: ST_TO_ADDR
// hc_face_number := 19 ;
9051: LD_ADDR_OWVAR 34
9055: PUSH
9056: LD_INT 19
9058: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9059: LD_INT 1
9061: PPUSH
9062: LD_INT 1
9064: PPUSH
9065: LD_INT 4
9067: PUSH
9068: LD_INT 4
9070: PUSH
9071: LD_INT 3
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: LIST
9078: PUSH
9079: LD_OWVAR 67
9083: ARRAY
9084: PPUSH
9085: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9089: LD_ADDR_OWVAR 29
9093: PUSH
9094: LD_INT 10
9096: PUSH
9097: LD_INT 12
9099: PUSH
9100: EMPTY
9101: LIST
9102: LIST
9103: ST_TO_ADDR
// Sikorski := CreateHuman ;
9104: LD_ADDR_EXP 20
9108: PUSH
9109: CALL_OW 44
9113: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9114: LD_EXP 20
9118: PPUSH
9119: LD_INT 133
9121: PPUSH
9122: LD_INT 19
9124: PPUSH
9125: LD_INT 2
9127: PPUSH
9128: LD_INT 0
9130: PPUSH
9131: CALL_OW 50
// InitHc_All ( ) ;
9135: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9139: LD_ADDR_VAR 0 2
9143: PUSH
9144: DOUBLE
9145: LD_INT 1
9147: DEC
9148: ST_TO_ADDR
9149: LD_INT 4
9151: PUSH
9152: LD_INT 3
9154: PUSH
9155: LD_INT 3
9157: PUSH
9158: EMPTY
9159: LIST
9160: LIST
9161: LIST
9162: PUSH
9163: LD_OWVAR 67
9167: ARRAY
9168: PUSH
9169: FOR_TO
9170: IFFALSE 9286
// for j := 1 to 4 do
9172: LD_ADDR_VAR 0 3
9176: PUSH
9177: DOUBLE
9178: LD_INT 1
9180: DEC
9181: ST_TO_ADDR
9182: LD_INT 4
9184: PUSH
9185: FOR_TO
9186: IFFALSE 9282
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9188: LD_INT 0
9190: PPUSH
9191: LD_VAR 0 3
9195: PPUSH
9196: LD_INT 5
9198: PUSH
9199: LD_INT 4
9201: PUSH
9202: LD_INT 3
9204: PUSH
9205: EMPTY
9206: LIST
9207: LIST
9208: LIST
9209: PUSH
9210: LD_OWVAR 67
9214: ARRAY
9215: PPUSH
9216: CALL_OW 380
// un := CreateHuman ;
9220: LD_ADDR_VAR 0 4
9224: PUSH
9225: CALL_OW 44
9229: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9230: LD_VAR 0 4
9234: PPUSH
9235: LD_INT 0
9237: PPUSH
9238: LD_INT 5
9240: PPUSH
9241: CALL_OW 12
9245: PPUSH
9246: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9250: LD_VAR 0 4
9254: PPUSH
9255: LD_INT 133
9257: PPUSH
9258: LD_INT 19
9260: PPUSH
9261: LD_INT 6
9263: PPUSH
9264: LD_INT 0
9266: PPUSH
9267: CALL_OW 50
// ComHold ( un ) ;
9271: LD_VAR 0 4
9275: PPUSH
9276: CALL_OW 140
// end ;
9280: GO 9185
9282: POP
9283: POP
9284: GO 9169
9286: POP
9287: POP
// vc_chassis := us_heavy_tracked ;
9288: LD_ADDR_OWVAR 37
9292: PUSH
9293: LD_INT 4
9295: ST_TO_ADDR
// vc_engine := engine_combustion ;
9296: LD_ADDR_OWVAR 39
9300: PUSH
9301: LD_INT 1
9303: ST_TO_ADDR
// vc_control := control_manual ;
9304: LD_ADDR_OWVAR 38
9308: PUSH
9309: LD_INT 1
9311: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9312: LD_ADDR_OWVAR 40
9316: PUSH
9317: LD_INT 14
9319: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9320: LD_ADDR_OWVAR 41
9324: PUSH
9325: LD_INT 60
9327: ST_TO_ADDR
// un := CreateVehicle ;
9328: LD_ADDR_VAR 0 4
9332: PUSH
9333: CALL_OW 45
9337: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9338: LD_VAR 0 4
9342: PPUSH
9343: LD_INT 2
9345: PPUSH
9346: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9350: LD_VAR 0 4
9354: PPUSH
9355: LD_INT 128
9357: PPUSH
9358: LD_INT 12
9360: PPUSH
9361: LD_INT 0
9363: PPUSH
9364: CALL_OW 48
// for i := 1 to 3 do
9368: LD_ADDR_VAR 0 2
9372: PUSH
9373: DOUBLE
9374: LD_INT 1
9376: DEC
9377: ST_TO_ADDR
9378: LD_INT 3
9380: PUSH
9381: FOR_TO
9382: IFFALSE 9405
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9384: LD_INT 5
9386: PPUSH
9387: LD_INT 133
9389: PPUSH
9390: LD_INT 19
9392: PPUSH
9393: LD_INT 3
9395: PPUSH
9396: LD_INT 0
9398: PPUSH
9399: CALL_OW 56
9403: GO 9381
9405: POP
9406: POP
// end ; end_of_file
9407: LD_VAR 0 1
9411: RET
// export function Action ; begin
9412: LD_INT 0
9414: PPUSH
// InGameOn ;
9415: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9419: LD_INT 133
9421: PPUSH
9422: LD_INT 19
9424: PPUSH
9425: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9429: LD_EXP 20
9433: PPUSH
9434: LD_STRING WT-DS-1
9436: PPUSH
9437: CALL_OW 88
// InGameOff ;
9441: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9445: LD_STRING DestroyEnemy
9447: PPUSH
9448: CALL_OW 337
// wait ( 0 0$20 ) ;
9452: LD_INT 700
9454: PPUSH
9455: CALL_OW 67
// DialogueOn ;
9459: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9463: LD_INT 100
9465: PPUSH
9466: LD_INT 37
9468: PPUSH
9469: LD_INT 1
9471: PPUSH
9472: LD_INT 30
9474: NEG
9475: PPUSH
9476: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9480: LD_INT 100
9482: PPUSH
9483: LD_INT 37
9485: PPUSH
9486: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9490: LD_EXP 10
9494: PPUSH
9495: LD_STRING WT-PL-1
9497: PPUSH
9498: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9502: LD_EXP 20
9506: PPUSH
9507: LD_STRING WT-DS-2
9509: PPUSH
9510: CALL_OW 88
// DialogueOff ;
9514: CALL_OW 7
// wait ( 0 0$2 ) ;
9518: LD_INT 70
9520: PPUSH
9521: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9525: LD_INT 100
9527: PPUSH
9528: LD_INT 37
9530: PPUSH
9531: LD_INT 1
9533: PPUSH
9534: CALL_OW 331
// end ;
9538: LD_VAR 0 1
9542: RET
// export function DialogPowellsAttack ; begin
9543: LD_INT 0
9545: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9546: LD_EXP 10
9550: PPUSH
9551: LD_STRING WT-PL-8
9553: PPUSH
9554: CALL_OW 94
// end ;
9558: LD_VAR 0 1
9562: RET
// export function DialogContaminateSib ( x , y ) ; begin
9563: LD_INT 0
9565: PPUSH
// DialogueOn ;
9566: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9570: LD_VAR 0 1
9574: PPUSH
9575: LD_VAR 0 2
9579: PPUSH
9580: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9584: LD_EXP 20
9588: PPUSH
9589: LD_STRING WT-DS-3
9591: PPUSH
9592: CALL_OW 88
// DialogueOff ;
9596: CALL_OW 7
// end ;
9600: LD_VAR 0 3
9604: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9605: LD_EXP 8
9609: NOT
9610: PUSH
9611: LD_INT 1
9613: PPUSH
9614: LD_INT 81
9616: PUSH
9617: LD_INT 4
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PPUSH
9624: CALL_OW 70
9628: PUSH
9629: LD_INT 3
9631: GREATER
9632: AND
9633: IFFALSE 9705
9635: GO 9637
9637: DISABLE
// begin powellInTrouble := true ;
9638: LD_ADDR_EXP 8
9642: PUSH
9643: LD_INT 1
9645: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9646: LD_EXP 20
9650: PPUSH
9651: LD_STRING WT-DS-6
9653: PPUSH
9654: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9658: LD_INT 1
9660: PPUSH
9661: LD_INT 22
9663: PUSH
9664: LD_INT 1
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: PPUSH
9671: CALL_OW 70
9675: NOT
9676: IFFALSE 9690
// SayRadio ( Powell , WT-PL-6 ) ;
9678: LD_EXP 10
9682: PPUSH
9683: LD_STRING WT-PL-6
9685: PPUSH
9686: CALL_OW 94
// wait ( 1 1$30 ) ;
9690: LD_INT 3150
9692: PPUSH
9693: CALL_OW 67
// powellInTrouble := false ;
9697: LD_ADDR_EXP 8
9701: PUSH
9702: LD_INT 0
9704: ST_TO_ADDR
// end ;
9705: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9706: LD_EXP 9
9710: NOT
9711: PUSH
9712: LD_INT 16
9714: PPUSH
9715: LD_INT 81
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: PUSH
9730: LD_INT 6
9732: GREATER
9733: AND
9734: IFFALSE 9807
9736: GO 9738
9738: DISABLE
// begin sikorskiInTrouble := true ;
9739: LD_ADDR_EXP 9
9743: PUSH
9744: LD_INT 1
9746: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9747: LD_EXP 20
9751: PPUSH
9752: LD_STRING WT-DS-7
9754: PPUSH
9755: CALL_OW 88
// if not powellAttackGroup then
9759: LD_EXP 12
9763: NOT
9764: IFFALSE 9780
// SayRadio ( Powell , WT-PL-7n ) else
9766: LD_EXP 10
9770: PPUSH
9771: LD_STRING WT-PL-7n
9773: PPUSH
9774: CALL_OW 94
9778: GO 9792
// SayRadio ( Powell , WT-PL-7y ) ;
9780: LD_EXP 10
9784: PPUSH
9785: LD_STRING WT-PL-7y
9787: PPUSH
9788: CALL_OW 94
// wait ( 1 1$30 ) ;
9792: LD_INT 3150
9794: PPUSH
9795: CALL_OW 67
// sikorskiInTrouble := false ;
9799: LD_ADDR_EXP 9
9803: PUSH
9804: LD_INT 0
9806: ST_TO_ADDR
// end ;
9807: END
// export function DialogPowellsAttackFailed ; begin
9808: LD_INT 0
9810: PPUSH
// if not ruDestroyed then
9811: LD_EXP 5
9815: NOT
9816: IFFALSE 9832
// SayRadio ( Powell , WT-PL-9 ) else
9818: LD_EXP 10
9822: PPUSH
9823: LD_STRING WT-PL-9
9825: PPUSH
9826: CALL_OW 94
9830: GO 9844
// SayRadio ( Powell , WT-PL-10 ) ;
9832: LD_EXP 10
9836: PPUSH
9837: LD_STRING WT-PL-10
9839: PPUSH
9840: CALL_OW 94
// end ;
9844: LD_VAR 0 1
9848: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9849: LD_INT 22
9851: PUSH
9852: LD_INT 2
9854: PUSH
9855: EMPTY
9856: LIST
9857: LIST
9858: PUSH
9859: LD_INT 21
9861: PUSH
9862: LD_INT 1
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PUSH
9869: EMPTY
9870: LIST
9871: LIST
9872: PPUSH
9873: CALL_OW 69
9877: PUSH
9878: LD_INT 0
9880: EQUAL
9881: IFFALSE 9925
9883: GO 9885
9885: DISABLE
// begin arDestroyed := true ;
9886: LD_ADDR_EXP 4
9890: PUSH
9891: LD_INT 1
9893: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9894: LD_INT 2
9896: PPUSH
9897: CALL 52643 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9901: LD_EXP 20
9905: PPUSH
9906: LD_STRING WT-DS-4
9908: PPUSH
9909: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9913: LD_EXP 10
9917: PPUSH
9918: LD_STRING WT-PL-4
9920: PPUSH
9921: CALL_OW 94
// end ;
9925: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9926: LD_INT 22
9928: PUSH
9929: LD_INT 3
9931: PUSH
9932: EMPTY
9933: LIST
9934: LIST
9935: PUSH
9936: LD_INT 21
9938: PUSH
9939: LD_INT 1
9941: PUSH
9942: EMPTY
9943: LIST
9944: LIST
9945: PUSH
9946: EMPTY
9947: LIST
9948: LIST
9949: PPUSH
9950: CALL_OW 69
9954: PUSH
9955: LD_INT 0
9957: EQUAL
9958: IFFALSE 10002
9960: GO 9962
9962: DISABLE
// begin ruDestroyed := true ;
9963: LD_ADDR_EXP 5
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// MC_Kill ( 3 ) ;
9971: LD_INT 3
9973: PPUSH
9974: CALL 52643 0 1
// Say ( Sikorski , WT-DS-5 ) ;
9978: LD_EXP 20
9982: PPUSH
9983: LD_STRING WT-DS-5
9985: PPUSH
9986: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
9990: LD_EXP 10
9994: PPUSH
9995: LD_STRING WT-PL-5
9997: PPUSH
9998: CALL_OW 94
// end ;
10002: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10003: LD_EXP 5
10007: PUSH
10008: LD_EXP 4
10012: AND
10013: IFFALSE 10186
10015: GO 10017
10017: DISABLE
// begin wait ( 0 0$3 ) ;
10018: LD_INT 105
10020: PPUSH
10021: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10025: LD_OWVAR 1
10029: PUSH
10030: LD_INT 126000
10032: PUSH
10033: LD_INT 105000
10035: PUSH
10036: LD_INT 94500
10038: PUSH
10039: EMPTY
10040: LIST
10041: LIST
10042: LIST
10043: PUSH
10044: LD_OWVAR 67
10048: ARRAY
10049: GREATEREQUAL
10050: IFFALSE 10065
// AddMedal ( WoT-med-1 , - 1 ) else
10052: LD_STRING WoT-med-1
10054: PPUSH
10055: LD_INT 1
10057: NEG
10058: PPUSH
10059: CALL_OW 101
10063: GO 10075
// AddMedal ( WoT-med-1 , 1 ) ;
10065: LD_STRING WoT-med-1
10067: PPUSH
10068: LD_INT 1
10070: PPUSH
10071: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10075: LD_EXP 6
10079: PUSH
10080: LD_INT 4
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 2
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: PUSH
10094: LD_OWVAR 67
10098: ARRAY
10099: GREATEREQUAL
10100: IFFALSE 10115
// AddMedal ( WoT-med-2 , - 1 ) else
10102: LD_STRING WoT-med-2
10104: PPUSH
10105: LD_INT 1
10107: NEG
10108: PPUSH
10109: CALL_OW 101
10113: GO 10125
// AddMedal ( WoT-med-2 , 1 ) ;
10115: LD_STRING WoT-med-2
10117: PPUSH
10118: LD_INT 1
10120: PPUSH
10121: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10125: LD_EXP 7
10129: PUSH
10130: LD_INT 8
10132: PUSH
10133: LD_INT 6
10135: PUSH
10136: LD_INT 5
10138: PUSH
10139: EMPTY
10140: LIST
10141: LIST
10142: LIST
10143: PUSH
10144: LD_OWVAR 67
10148: ARRAY
10149: GREATEREQUAL
10150: IFFALSE 10165
// AddMedal ( WoT-med-3 , - 1 ) else
10152: LD_STRING WoT-med-3
10154: PPUSH
10155: LD_INT 1
10157: NEG
10158: PPUSH
10159: CALL_OW 101
10163: GO 10175
// AddMedal ( WoT-med-3 , 1 ) ;
10165: LD_STRING WoT-med-3
10167: PPUSH
10168: LD_INT 1
10170: PPUSH
10171: CALL_OW 101
// GiveMedals ( MAIN ) ;
10175: LD_STRING MAIN
10177: PPUSH
10178: CALL_OW 102
// YouWin ;
10182: CALL_OW 103
// end ; end_of_file
10186: END
// export function CustomEvent ( event ) ; begin
10187: LD_INT 0
10189: PPUSH
// end ;
10190: LD_VAR 0 2
10194: RET
// on Command ( com ) do var i , j , temp ;
10195: LD_INT 0
10197: PPUSH
10198: PPUSH
10199: PPUSH
// begin if com = 60 then
10200: LD_VAR 0 1
10204: PUSH
10205: LD_INT 60
10207: EQUAL
10208: IFFALSE 10387
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10210: LD_ADDR_VAR 0 2
10214: PUSH
10215: LD_INT 22
10217: PUSH
10218: LD_INT 1
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 2
10227: PUSH
10228: LD_INT 21
10230: PUSH
10231: LD_INT 1
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 34
10240: PUSH
10241: LD_INT 12
10243: PUSH
10244: EMPTY
10245: LIST
10246: LIST
10247: PUSH
10248: EMPTY
10249: LIST
10250: LIST
10251: LIST
10252: PUSH
10253: EMPTY
10254: LIST
10255: LIST
10256: PPUSH
10257: CALL_OW 69
10261: PUSH
10262: FOR_IN
10263: IFFALSE 10385
// begin if GetTaskList ( i ) > 0 then
10265: LD_VAR 0 2
10269: PPUSH
10270: CALL_OW 437
10274: PUSH
10275: LD_INT 0
10277: GREATER
10278: IFFALSE 10383
// for j = 1 to GetTaskList ( i ) do
10280: LD_ADDR_VAR 0 3
10284: PUSH
10285: DOUBLE
10286: LD_INT 1
10288: DEC
10289: ST_TO_ADDR
10290: LD_VAR 0 2
10294: PPUSH
10295: CALL_OW 437
10299: PUSH
10300: FOR_TO
10301: IFFALSE 10381
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10303: LD_ADDR_VAR 0 4
10307: PUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL_OW 437
10317: PUSH
10318: LD_VAR 0 3
10322: ARRAY
10323: PUSH
10324: LD_INT 4
10326: ARRAY
10327: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10328: LD_VAR 0 4
10332: PPUSH
10333: CALL_OW 255
10337: PUSH
10338: LD_INT 4
10340: EQUAL
10341: PUSH
10342: LD_VAR 0 2
10346: PPUSH
10347: CALL_OW 437
10351: PUSH
10352: LD_VAR 0 3
10356: ARRAY
10357: PUSH
10358: LD_INT 1
10360: ARRAY
10361: PUSH
10362: LD_STRING <
10364: EQUAL
10365: AND
10366: IFFALSE 10379
// SetTaskList ( i , [ ] ) ;
10368: LD_VAR 0 2
10372: PPUSH
10373: EMPTY
10374: PPUSH
10375: CALL_OW 446
// end ;
10379: GO 10300
10381: POP
10382: POP
// end ;
10383: GO 10262
10385: POP
10386: POP
// end ; end ;
10387: PPOPN 4
10389: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10390: LD_VAR 0 2
10394: PPUSH
10395: LD_VAR 0 3
10399: PPUSH
10400: CALL_OW 428
10404: PPUSH
10405: CALL_OW 255
10409: PUSH
10410: LD_INT 1
10412: EQUAL
10413: PUSH
10414: LD_VAR 0 2
10418: PUSH
10419: LD_INT 132
10421: EQUAL
10422: PUSH
10423: LD_VAR 0 3
10427: PUSH
10428: LD_INT 39
10430: EQUAL
10431: AND
10432: OR
10433: IFFALSE 10449
// DialogContaminateSib ( x , y ) ;
10435: LD_VAR 0 2
10439: PPUSH
10440: LD_VAR 0 3
10444: PPUSH
10445: CALL 9563 0 2
// end ;
10449: PPOPN 3
10451: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10452: LD_VAR 0 1
10456: PPUSH
10457: CALL 90359 0 1
// MCE_UnitDestroyed ( un ) ;
10461: LD_VAR 0 1
10465: PPUSH
10466: CALL 80074 0 1
// if un = Powell then
10470: LD_VAR 0 1
10474: PUSH
10475: LD_EXP 10
10479: EQUAL
10480: IFFALSE 10489
// YouLost ( Powell ) ;
10482: LD_STRING Powell
10484: PPUSH
10485: CALL_OW 104
// if un = Sikorski then
10489: LD_VAR 0 1
10493: PUSH
10494: LD_EXP 20
10498: EQUAL
10499: IFFALSE 10508
// YouLost ( Sikorski ) ;
10501: LD_STRING Sikorski
10503: PPUSH
10504: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10508: LD_VAR 0 1
10512: PUSH
10513: LD_INT 22
10515: PUSH
10516: LD_INT 1
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: PUSH
10523: LD_INT 21
10525: PUSH
10526: LD_INT 1
10528: PUSH
10529: EMPTY
10530: LIST
10531: LIST
10532: PUSH
10533: EMPTY
10534: LIST
10535: LIST
10536: PPUSH
10537: CALL_OW 69
10541: IN
10542: IFFALSE 10558
// loseCounter := loseCounter + 1 ;
10544: LD_ADDR_EXP 6
10548: PUSH
10549: LD_EXP 6
10553: PUSH
10554: LD_INT 1
10556: PLUS
10557: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10558: LD_VAR 0 1
10562: PUSH
10563: LD_INT 22
10565: PUSH
10566: LD_INT 4
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: PUSH
10573: LD_INT 21
10575: PUSH
10576: LD_INT 1
10578: PUSH
10579: EMPTY
10580: LIST
10581: LIST
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PPUSH
10587: CALL_OW 69
10591: IN
10592: IFFALSE 10608
// powellLoseCounter := powellLoseCounter + 1 ;
10594: LD_ADDR_EXP 7
10598: PUSH
10599: LD_EXP 7
10603: PUSH
10604: LD_INT 1
10606: PLUS
10607: ST_TO_ADDR
// if un in powellAttackGroup then
10608: LD_VAR 0 1
10612: PUSH
10613: LD_EXP 12
10617: IN
10618: IFFALSE 10636
// powellAttackGroup := powellAttackGroup diff un ;
10620: LD_ADDR_EXP 12
10624: PUSH
10625: LD_EXP 12
10629: PUSH
10630: LD_VAR 0 1
10634: DIFF
10635: ST_TO_ADDR
// if un in gensherAttackGroup then
10636: LD_VAR 0 1
10640: PUSH
10641: LD_EXP 15
10645: IN
10646: IFFALSE 10664
// gensherAttackGroup := gensherAttackGroup diff un ;
10648: LD_ADDR_EXP 15
10652: PUSH
10653: LD_EXP 15
10657: PUSH
10658: LD_VAR 0 1
10662: DIFF
10663: ST_TO_ADDR
// if un in popovAttackGroup then
10664: LD_VAR 0 1
10668: PUSH
10669: LD_EXP 19
10673: IN
10674: IFFALSE 10692
// popovAttackGroup := popovAttackGroup diff un ;
10676: LD_ADDR_EXP 19
10680: PUSH
10681: LD_EXP 19
10685: PUSH
10686: LD_VAR 0 1
10690: DIFF
10691: ST_TO_ADDR
// end ;
10692: PPOPN 1
10694: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10695: LD_VAR 0 1
10699: PPUSH
10700: LD_VAR 0 2
10704: PPUSH
10705: CALL 82406 0 2
// end ;
10709: PPOPN 2
10711: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL 81474 0 1
// end ;
10721: PPOPN 1
10723: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10724: LD_VAR 0 1
10728: PPUSH
10729: CALL 81715 0 1
// end ;
10733: PPOPN 1
10735: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10736: LD_VAR 0 1
10740: PPUSH
10741: LD_VAR 0 2
10745: PPUSH
10746: CALL 79770 0 2
// end ;
10750: PPOPN 2
10752: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10753: LD_VAR 0 1
10757: PPUSH
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_VAR 0 3
10767: PPUSH
10768: LD_VAR 0 4
10772: PPUSH
10773: LD_VAR 0 5
10777: PPUSH
10778: CALL 79390 0 5
// end ;
10782: PPOPN 5
10784: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10785: LD_VAR 0 1
10789: PPUSH
10790: LD_VAR 0 2
10794: PPUSH
10795: CALL 90479 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10799: LD_VAR 0 1
10803: PPUSH
10804: LD_VAR 0 2
10808: PPUSH
10809: CALL 78981 0 2
// end ;
10813: PPOPN 2
10815: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10816: LD_VAR 0 1
10820: PPUSH
10821: LD_VAR 0 2
10825: PPUSH
10826: LD_VAR 0 3
10830: PPUSH
10831: LD_VAR 0 4
10835: PPUSH
10836: CALL 78819 0 4
// end ;
10840: PPOPN 4
10842: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10843: LD_VAR 0 1
10847: PPUSH
10848: LD_VAR 0 2
10852: PPUSH
10853: LD_VAR 0 3
10857: PPUSH
10858: CALL 78594 0 3
// end ;
10862: PPOPN 3
10864: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10865: LD_VAR 0 1
10869: PPUSH
10870: LD_VAR 0 2
10874: PPUSH
10875: CALL 78479 0 2
// end ;
10879: PPOPN 2
10881: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10882: LD_VAR 0 1
10886: PPUSH
10887: LD_VAR 0 2
10891: PPUSH
10892: CALL 82701 0 2
// end ;
10896: PPOPN 2
10898: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10899: LD_VAR 0 1
10903: PPUSH
10904: LD_VAR 0 2
10908: PPUSH
10909: LD_VAR 0 3
10913: PPUSH
10914: LD_VAR 0 4
10918: PPUSH
10919: CALL 82917 0 4
// end ;
10923: PPOPN 4
10925: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10926: LD_VAR 0 1
10930: PPUSH
10931: LD_VAR 0 2
10935: PPUSH
10936: CALL 78288 0 2
// end ;
10940: PPOPN 2
10942: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10943: LD_VAR 0 1
10947: PUSH
10948: LD_INT 1
10950: EQUAL
10951: PUSH
10952: LD_VAR 0 2
10956: PUSH
10957: LD_INT 4
10959: EQUAL
10960: AND
10961: IFFALSE 10970
// YouLost ( FriendlyFire ) ;
10963: LD_STRING FriendlyFire
10965: PPUSH
10966: CALL_OW 104
// end ; end_of_file
10970: PPOPN 2
10972: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
10973: LD_INT 0
10975: PPUSH
10976: PPUSH
// if exist_mode then
10977: LD_VAR 0 2
10981: IFFALSE 11006
// unit := CreateCharacter ( prefix & ident ) else
10983: LD_ADDR_VAR 0 5
10987: PUSH
10988: LD_VAR 0 3
10992: PUSH
10993: LD_VAR 0 1
10997: STR
10998: PPUSH
10999: CALL_OW 34
11003: ST_TO_ADDR
11004: GO 11021
// unit := NewCharacter ( ident ) ;
11006: LD_ADDR_VAR 0 5
11010: PUSH
11011: LD_VAR 0 1
11015: PPUSH
11016: CALL_OW 25
11020: ST_TO_ADDR
// result := unit ;
11021: LD_ADDR_VAR 0 4
11025: PUSH
11026: LD_VAR 0 5
11030: ST_TO_ADDR
// end ;
11031: LD_VAR 0 4
11035: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11036: LD_INT 0
11038: PPUSH
11039: PPUSH
// if not side or not nation then
11040: LD_VAR 0 1
11044: NOT
11045: PUSH
11046: LD_VAR 0 2
11050: NOT
11051: OR
11052: IFFALSE 11056
// exit ;
11054: GO 11824
// case nation of nation_american :
11056: LD_VAR 0 2
11060: PUSH
11061: LD_INT 1
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11283
11069: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11070: LD_ADDR_VAR 0 4
11074: PUSH
11075: LD_INT 35
11077: PUSH
11078: LD_INT 45
11080: PUSH
11081: LD_INT 46
11083: PUSH
11084: LD_INT 47
11086: PUSH
11087: LD_INT 82
11089: PUSH
11090: LD_INT 83
11092: PUSH
11093: LD_INT 84
11095: PUSH
11096: LD_INT 85
11098: PUSH
11099: LD_INT 86
11101: PUSH
11102: LD_INT 1
11104: PUSH
11105: LD_INT 2
11107: PUSH
11108: LD_INT 6
11110: PUSH
11111: LD_INT 15
11113: PUSH
11114: LD_INT 16
11116: PUSH
11117: LD_INT 7
11119: PUSH
11120: LD_INT 12
11122: PUSH
11123: LD_INT 13
11125: PUSH
11126: LD_INT 10
11128: PUSH
11129: LD_INT 14
11131: PUSH
11132: LD_INT 20
11134: PUSH
11135: LD_INT 21
11137: PUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 25
11143: PUSH
11144: LD_INT 32
11146: PUSH
11147: LD_INT 27
11149: PUSH
11150: LD_INT 36
11152: PUSH
11153: LD_INT 69
11155: PUSH
11156: LD_INT 39
11158: PUSH
11159: LD_INT 34
11161: PUSH
11162: LD_INT 40
11164: PUSH
11165: LD_INT 48
11167: PUSH
11168: LD_INT 49
11170: PUSH
11171: LD_INT 50
11173: PUSH
11174: LD_INT 51
11176: PUSH
11177: LD_INT 52
11179: PUSH
11180: LD_INT 53
11182: PUSH
11183: LD_INT 54
11185: PUSH
11186: LD_INT 55
11188: PUSH
11189: LD_INT 56
11191: PUSH
11192: LD_INT 57
11194: PUSH
11195: LD_INT 58
11197: PUSH
11198: LD_INT 59
11200: PUSH
11201: LD_INT 60
11203: PUSH
11204: LD_INT 61
11206: PUSH
11207: LD_INT 62
11209: PUSH
11210: LD_INT 80
11212: PUSH
11213: LD_INT 82
11215: PUSH
11216: LD_INT 83
11218: PUSH
11219: LD_INT 84
11221: PUSH
11222: LD_INT 85
11224: PUSH
11225: LD_INT 86
11227: PUSH
11228: EMPTY
11229: LIST
11230: LIST
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: LIST
11240: LIST
11241: LIST
11242: LIST
11243: LIST
11244: LIST
11245: LIST
11246: LIST
11247: LIST
11248: LIST
11249: LIST
11250: LIST
11251: LIST
11252: LIST
11253: LIST
11254: LIST
11255: LIST
11256: LIST
11257: LIST
11258: LIST
11259: LIST
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: ST_TO_ADDR
11281: GO 11748
11283: LD_INT 2
11285: DOUBLE
11286: EQUAL
11287: IFTRUE 11291
11289: GO 11517
11291: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11292: LD_ADDR_VAR 0 4
11296: PUSH
11297: LD_INT 35
11299: PUSH
11300: LD_INT 45
11302: PUSH
11303: LD_INT 46
11305: PUSH
11306: LD_INT 47
11308: PUSH
11309: LD_INT 82
11311: PUSH
11312: LD_INT 83
11314: PUSH
11315: LD_INT 84
11317: PUSH
11318: LD_INT 85
11320: PUSH
11321: LD_INT 87
11323: PUSH
11324: LD_INT 70
11326: PUSH
11327: LD_INT 1
11329: PUSH
11330: LD_INT 11
11332: PUSH
11333: LD_INT 3
11335: PUSH
11336: LD_INT 4
11338: PUSH
11339: LD_INT 5
11341: PUSH
11342: LD_INT 6
11344: PUSH
11345: LD_INT 15
11347: PUSH
11348: LD_INT 18
11350: PUSH
11351: LD_INT 7
11353: PUSH
11354: LD_INT 17
11356: PUSH
11357: LD_INT 8
11359: PUSH
11360: LD_INT 20
11362: PUSH
11363: LD_INT 21
11365: PUSH
11366: LD_INT 22
11368: PUSH
11369: LD_INT 72
11371: PUSH
11372: LD_INT 26
11374: PUSH
11375: LD_INT 69
11377: PUSH
11378: LD_INT 39
11380: PUSH
11381: LD_INT 40
11383: PUSH
11384: LD_INT 41
11386: PUSH
11387: LD_INT 42
11389: PUSH
11390: LD_INT 43
11392: PUSH
11393: LD_INT 48
11395: PUSH
11396: LD_INT 49
11398: PUSH
11399: LD_INT 50
11401: PUSH
11402: LD_INT 51
11404: PUSH
11405: LD_INT 52
11407: PUSH
11408: LD_INT 53
11410: PUSH
11411: LD_INT 54
11413: PUSH
11414: LD_INT 55
11416: PUSH
11417: LD_INT 56
11419: PUSH
11420: LD_INT 60
11422: PUSH
11423: LD_INT 61
11425: PUSH
11426: LD_INT 62
11428: PUSH
11429: LD_INT 66
11431: PUSH
11432: LD_INT 67
11434: PUSH
11435: LD_INT 68
11437: PUSH
11438: LD_INT 81
11440: PUSH
11441: LD_INT 82
11443: PUSH
11444: LD_INT 83
11446: PUSH
11447: LD_INT 84
11449: PUSH
11450: LD_INT 85
11452: PUSH
11453: LD_INT 87
11455: PUSH
11456: LD_INT 88
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: LIST
11463: LIST
11464: LIST
11465: LIST
11466: LIST
11467: LIST
11468: LIST
11469: LIST
11470: LIST
11471: LIST
11472: LIST
11473: LIST
11474: LIST
11475: LIST
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: LIST
11481: LIST
11482: LIST
11483: LIST
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: ST_TO_ADDR
11515: GO 11748
11517: LD_INT 3
11519: DOUBLE
11520: EQUAL
11521: IFTRUE 11525
11523: GO 11747
11525: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11526: LD_ADDR_VAR 0 4
11530: PUSH
11531: LD_INT 46
11533: PUSH
11534: LD_INT 47
11536: PUSH
11537: LD_INT 1
11539: PUSH
11540: LD_INT 2
11542: PUSH
11543: LD_INT 82
11545: PUSH
11546: LD_INT 83
11548: PUSH
11549: LD_INT 84
11551: PUSH
11552: LD_INT 85
11554: PUSH
11555: LD_INT 86
11557: PUSH
11558: LD_INT 11
11560: PUSH
11561: LD_INT 9
11563: PUSH
11564: LD_INT 20
11566: PUSH
11567: LD_INT 19
11569: PUSH
11570: LD_INT 21
11572: PUSH
11573: LD_INT 24
11575: PUSH
11576: LD_INT 22
11578: PUSH
11579: LD_INT 25
11581: PUSH
11582: LD_INT 28
11584: PUSH
11585: LD_INT 29
11587: PUSH
11588: LD_INT 30
11590: PUSH
11591: LD_INT 31
11593: PUSH
11594: LD_INT 37
11596: PUSH
11597: LD_INT 38
11599: PUSH
11600: LD_INT 32
11602: PUSH
11603: LD_INT 27
11605: PUSH
11606: LD_INT 33
11608: PUSH
11609: LD_INT 69
11611: PUSH
11612: LD_INT 39
11614: PUSH
11615: LD_INT 34
11617: PUSH
11618: LD_INT 40
11620: PUSH
11621: LD_INT 71
11623: PUSH
11624: LD_INT 23
11626: PUSH
11627: LD_INT 44
11629: PUSH
11630: LD_INT 48
11632: PUSH
11633: LD_INT 49
11635: PUSH
11636: LD_INT 50
11638: PUSH
11639: LD_INT 51
11641: PUSH
11642: LD_INT 52
11644: PUSH
11645: LD_INT 53
11647: PUSH
11648: LD_INT 54
11650: PUSH
11651: LD_INT 55
11653: PUSH
11654: LD_INT 56
11656: PUSH
11657: LD_INT 57
11659: PUSH
11660: LD_INT 58
11662: PUSH
11663: LD_INT 59
11665: PUSH
11666: LD_INT 63
11668: PUSH
11669: LD_INT 64
11671: PUSH
11672: LD_INT 65
11674: PUSH
11675: LD_INT 82
11677: PUSH
11678: LD_INT 83
11680: PUSH
11681: LD_INT 84
11683: PUSH
11684: LD_INT 85
11686: PUSH
11687: LD_INT 86
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: LIST
11716: LIST
11717: LIST
11718: LIST
11719: LIST
11720: LIST
11721: LIST
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: ST_TO_ADDR
11745: GO 11748
11747: POP
// if state > - 1 and state < 3 then
11748: LD_VAR 0 3
11752: PUSH
11753: LD_INT 1
11755: NEG
11756: GREATER
11757: PUSH
11758: LD_VAR 0 3
11762: PUSH
11763: LD_INT 3
11765: LESS
11766: AND
11767: IFFALSE 11824
// for i in result do
11769: LD_ADDR_VAR 0 5
11773: PUSH
11774: LD_VAR 0 4
11778: PUSH
11779: FOR_IN
11780: IFFALSE 11822
// if GetTech ( i , side ) <> state then
11782: LD_VAR 0 5
11786: PPUSH
11787: LD_VAR 0 1
11791: PPUSH
11792: CALL_OW 321
11796: PUSH
11797: LD_VAR 0 3
11801: NONEQUAL
11802: IFFALSE 11820
// result := result diff i ;
11804: LD_ADDR_VAR 0 4
11808: PUSH
11809: LD_VAR 0 4
11813: PUSH
11814: LD_VAR 0 5
11818: DIFF
11819: ST_TO_ADDR
11820: GO 11779
11822: POP
11823: POP
// end ;
11824: LD_VAR 0 4
11828: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11829: LD_INT 0
11831: PPUSH
11832: PPUSH
11833: PPUSH
// result := true ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_INT 1
11841: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11842: LD_ADDR_VAR 0 5
11846: PUSH
11847: LD_VAR 0 2
11851: PPUSH
11852: CALL_OW 480
11856: ST_TO_ADDR
// if not tmp then
11857: LD_VAR 0 5
11861: NOT
11862: IFFALSE 11866
// exit ;
11864: GO 11915
// for i in tmp do
11866: LD_ADDR_VAR 0 4
11870: PUSH
11871: LD_VAR 0 5
11875: PUSH
11876: FOR_IN
11877: IFFALSE 11913
// if GetTech ( i , side ) <> state_researched then
11879: LD_VAR 0 4
11883: PPUSH
11884: LD_VAR 0 1
11888: PPUSH
11889: CALL_OW 321
11893: PUSH
11894: LD_INT 2
11896: NONEQUAL
11897: IFFALSE 11911
// begin result := false ;
11899: LD_ADDR_VAR 0 3
11903: PUSH
11904: LD_INT 0
11906: ST_TO_ADDR
// exit ;
11907: POP
11908: POP
11909: GO 11915
// end ;
11911: GO 11876
11913: POP
11914: POP
// end ;
11915: LD_VAR 0 3
11919: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11920: LD_INT 0
11922: PPUSH
11923: PPUSH
11924: PPUSH
11925: PPUSH
11926: PPUSH
11927: PPUSH
11928: PPUSH
11929: PPUSH
11930: PPUSH
11931: PPUSH
11932: PPUSH
11933: PPUSH
11934: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11935: LD_VAR 0 1
11939: NOT
11940: PUSH
11941: LD_VAR 0 1
11945: PPUSH
11946: CALL_OW 257
11950: PUSH
11951: LD_INT 9
11953: NONEQUAL
11954: OR
11955: IFFALSE 11959
// exit ;
11957: GO 12532
// side := GetSide ( unit ) ;
11959: LD_ADDR_VAR 0 9
11963: PUSH
11964: LD_VAR 0 1
11968: PPUSH
11969: CALL_OW 255
11973: ST_TO_ADDR
// tech_space := tech_spacanom ;
11974: LD_ADDR_VAR 0 12
11978: PUSH
11979: LD_INT 29
11981: ST_TO_ADDR
// tech_time := tech_taurad ;
11982: LD_ADDR_VAR 0 13
11986: PUSH
11987: LD_INT 28
11989: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
11990: LD_ADDR_VAR 0 11
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 310
12004: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12005: LD_VAR 0 11
12009: PPUSH
12010: CALL_OW 247
12014: PUSH
12015: LD_INT 2
12017: EQUAL
12018: IFFALSE 12022
// exit ;
12020: GO 12532
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12022: LD_ADDR_VAR 0 8
12026: PUSH
12027: LD_INT 81
12029: PUSH
12030: LD_VAR 0 9
12034: PUSH
12035: EMPTY
12036: LIST
12037: LIST
12038: PUSH
12039: LD_INT 3
12041: PUSH
12042: LD_INT 21
12044: PUSH
12045: LD_INT 3
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: EMPTY
12053: LIST
12054: LIST
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PPUSH
12060: CALL_OW 69
12064: ST_TO_ADDR
// if not tmp then
12065: LD_VAR 0 8
12069: NOT
12070: IFFALSE 12074
// exit ;
12072: GO 12532
// if in_unit then
12074: LD_VAR 0 11
12078: IFFALSE 12102
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12080: LD_ADDR_VAR 0 10
12084: PUSH
12085: LD_VAR 0 8
12089: PPUSH
12090: LD_VAR 0 11
12094: PPUSH
12095: CALL_OW 74
12099: ST_TO_ADDR
12100: GO 12122
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12102: LD_ADDR_VAR 0 10
12106: PUSH
12107: LD_VAR 0 8
12111: PPUSH
12112: LD_VAR 0 1
12116: PPUSH
12117: CALL_OW 74
12121: ST_TO_ADDR
// if not enemy then
12122: LD_VAR 0 10
12126: NOT
12127: IFFALSE 12131
// exit ;
12129: GO 12532
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12131: LD_VAR 0 11
12135: PUSH
12136: LD_VAR 0 11
12140: PPUSH
12141: LD_VAR 0 10
12145: PPUSH
12146: CALL_OW 296
12150: PUSH
12151: LD_INT 13
12153: GREATER
12154: AND
12155: PUSH
12156: LD_VAR 0 1
12160: PPUSH
12161: LD_VAR 0 10
12165: PPUSH
12166: CALL_OW 296
12170: PUSH
12171: LD_INT 12
12173: GREATER
12174: OR
12175: IFFALSE 12179
// exit ;
12177: GO 12532
// missile := [ 1 ] ;
12179: LD_ADDR_VAR 0 14
12183: PUSH
12184: LD_INT 1
12186: PUSH
12187: EMPTY
12188: LIST
12189: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12190: LD_VAR 0 9
12194: PPUSH
12195: LD_VAR 0 12
12199: PPUSH
12200: CALL_OW 325
12204: IFFALSE 12233
// missile := Replace ( missile , missile + 1 , 2 ) ;
12206: LD_ADDR_VAR 0 14
12210: PUSH
12211: LD_VAR 0 14
12215: PPUSH
12216: LD_VAR 0 14
12220: PUSH
12221: LD_INT 1
12223: PLUS
12224: PPUSH
12225: LD_INT 2
12227: PPUSH
12228: CALL_OW 1
12232: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12233: LD_VAR 0 9
12237: PPUSH
12238: LD_VAR 0 13
12242: PPUSH
12243: CALL_OW 325
12247: PUSH
12248: LD_VAR 0 10
12252: PPUSH
12253: CALL_OW 255
12257: PPUSH
12258: LD_VAR 0 13
12262: PPUSH
12263: CALL_OW 325
12267: NOT
12268: AND
12269: IFFALSE 12298
// missile := Replace ( missile , missile + 1 , 3 ) ;
12271: LD_ADDR_VAR 0 14
12275: PUSH
12276: LD_VAR 0 14
12280: PPUSH
12281: LD_VAR 0 14
12285: PUSH
12286: LD_INT 1
12288: PLUS
12289: PPUSH
12290: LD_INT 3
12292: PPUSH
12293: CALL_OW 1
12297: ST_TO_ADDR
// if missile < 2 then
12298: LD_VAR 0 14
12302: PUSH
12303: LD_INT 2
12305: LESS
12306: IFFALSE 12310
// exit ;
12308: GO 12532
// x := GetX ( enemy ) ;
12310: LD_ADDR_VAR 0 4
12314: PUSH
12315: LD_VAR 0 10
12319: PPUSH
12320: CALL_OW 250
12324: ST_TO_ADDR
// y := GetY ( enemy ) ;
12325: LD_ADDR_VAR 0 5
12329: PUSH
12330: LD_VAR 0 10
12334: PPUSH
12335: CALL_OW 251
12339: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12340: LD_ADDR_VAR 0 6
12344: PUSH
12345: LD_VAR 0 4
12349: PUSH
12350: LD_INT 1
12352: NEG
12353: PPUSH
12354: LD_INT 1
12356: PPUSH
12357: CALL_OW 12
12361: PLUS
12362: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12363: LD_ADDR_VAR 0 7
12367: PUSH
12368: LD_VAR 0 5
12372: PUSH
12373: LD_INT 1
12375: NEG
12376: PPUSH
12377: LD_INT 1
12379: PPUSH
12380: CALL_OW 12
12384: PLUS
12385: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12386: LD_VAR 0 6
12390: PPUSH
12391: LD_VAR 0 7
12395: PPUSH
12396: CALL_OW 488
12400: NOT
12401: IFFALSE 12423
// begin _x := x ;
12403: LD_ADDR_VAR 0 6
12407: PUSH
12408: LD_VAR 0 4
12412: ST_TO_ADDR
// _y := y ;
12413: LD_ADDR_VAR 0 7
12417: PUSH
12418: LD_VAR 0 5
12422: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12423: LD_ADDR_VAR 0 3
12427: PUSH
12428: LD_INT 1
12430: PPUSH
12431: LD_VAR 0 14
12435: PPUSH
12436: CALL_OW 12
12440: ST_TO_ADDR
// case i of 1 :
12441: LD_VAR 0 3
12445: PUSH
12446: LD_INT 1
12448: DOUBLE
12449: EQUAL
12450: IFTRUE 12454
12452: GO 12471
12454: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12455: LD_VAR 0 1
12459: PPUSH
12460: LD_VAR 0 10
12464: PPUSH
12465: CALL_OW 115
12469: GO 12532
12471: LD_INT 2
12473: DOUBLE
12474: EQUAL
12475: IFTRUE 12479
12477: GO 12501
12479: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12480: LD_VAR 0 1
12484: PPUSH
12485: LD_VAR 0 6
12489: PPUSH
12490: LD_VAR 0 7
12494: PPUSH
12495: CALL_OW 153
12499: GO 12532
12501: LD_INT 3
12503: DOUBLE
12504: EQUAL
12505: IFTRUE 12509
12507: GO 12531
12509: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12510: LD_VAR 0 1
12514: PPUSH
12515: LD_VAR 0 6
12519: PPUSH
12520: LD_VAR 0 7
12524: PPUSH
12525: CALL_OW 154
12529: GO 12532
12531: POP
// end ;
12532: LD_VAR 0 2
12536: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12537: LD_INT 0
12539: PPUSH
12540: PPUSH
12541: PPUSH
12542: PPUSH
12543: PPUSH
12544: PPUSH
// if not unit or not building then
12545: LD_VAR 0 1
12549: NOT
12550: PUSH
12551: LD_VAR 0 2
12555: NOT
12556: OR
12557: IFFALSE 12561
// exit ;
12559: GO 12719
// x := GetX ( building ) ;
12561: LD_ADDR_VAR 0 5
12565: PUSH
12566: LD_VAR 0 2
12570: PPUSH
12571: CALL_OW 250
12575: ST_TO_ADDR
// y := GetY ( building ) ;
12576: LD_ADDR_VAR 0 6
12580: PUSH
12581: LD_VAR 0 2
12585: PPUSH
12586: CALL_OW 251
12590: ST_TO_ADDR
// for i = 0 to 5 do
12591: LD_ADDR_VAR 0 4
12595: PUSH
12596: DOUBLE
12597: LD_INT 0
12599: DEC
12600: ST_TO_ADDR
12601: LD_INT 5
12603: PUSH
12604: FOR_TO
12605: IFFALSE 12717
// begin _x := ShiftX ( x , i , 3 ) ;
12607: LD_ADDR_VAR 0 7
12611: PUSH
12612: LD_VAR 0 5
12616: PPUSH
12617: LD_VAR 0 4
12621: PPUSH
12622: LD_INT 3
12624: PPUSH
12625: CALL_OW 272
12629: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12630: LD_ADDR_VAR 0 8
12634: PUSH
12635: LD_VAR 0 6
12639: PPUSH
12640: LD_VAR 0 4
12644: PPUSH
12645: LD_INT 3
12647: PPUSH
12648: CALL_OW 273
12652: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12653: LD_VAR 0 7
12657: PPUSH
12658: LD_VAR 0 8
12662: PPUSH
12663: CALL_OW 488
12667: NOT
12668: IFFALSE 12672
// continue ;
12670: GO 12604
// if HexInfo ( _x , _y ) = 0 then
12672: LD_VAR 0 7
12676: PPUSH
12677: LD_VAR 0 8
12681: PPUSH
12682: CALL_OW 428
12686: PUSH
12687: LD_INT 0
12689: EQUAL
12690: IFFALSE 12715
// begin ComMoveXY ( unit , _x , _y ) ;
12692: LD_VAR 0 1
12696: PPUSH
12697: LD_VAR 0 7
12701: PPUSH
12702: LD_VAR 0 8
12706: PPUSH
12707: CALL_OW 111
// exit ;
12711: POP
12712: POP
12713: GO 12719
// end ; end ;
12715: GO 12604
12717: POP
12718: POP
// end ;
12719: LD_VAR 0 3
12723: RET
// export function ScanBase ( side , base_area ) ; begin
12724: LD_INT 0
12726: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12727: LD_ADDR_VAR 0 3
12731: PUSH
12732: LD_VAR 0 2
12736: PPUSH
12737: LD_INT 81
12739: PUSH
12740: LD_VAR 0 1
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: PPUSH
12749: CALL_OW 70
12753: ST_TO_ADDR
// end ;
12754: LD_VAR 0 3
12758: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12759: LD_INT 0
12761: PPUSH
12762: PPUSH
12763: PPUSH
12764: PPUSH
// result := false ;
12765: LD_ADDR_VAR 0 2
12769: PUSH
12770: LD_INT 0
12772: ST_TO_ADDR
// side := GetSide ( unit ) ;
12773: LD_ADDR_VAR 0 3
12777: PUSH
12778: LD_VAR 0 1
12782: PPUSH
12783: CALL_OW 255
12787: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12788: LD_ADDR_VAR 0 4
12792: PUSH
12793: LD_VAR 0 1
12797: PPUSH
12798: CALL_OW 248
12802: ST_TO_ADDR
// case nat of 1 :
12803: LD_VAR 0 4
12807: PUSH
12808: LD_INT 1
12810: DOUBLE
12811: EQUAL
12812: IFTRUE 12816
12814: GO 12827
12816: POP
// tech := tech_lassight ; 2 :
12817: LD_ADDR_VAR 0 5
12821: PUSH
12822: LD_INT 12
12824: ST_TO_ADDR
12825: GO 12866
12827: LD_INT 2
12829: DOUBLE
12830: EQUAL
12831: IFTRUE 12835
12833: GO 12846
12835: POP
// tech := tech_mortar ; 3 :
12836: LD_ADDR_VAR 0 5
12840: PUSH
12841: LD_INT 41
12843: ST_TO_ADDR
12844: GO 12866
12846: LD_INT 3
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12865
12854: POP
// tech := tech_bazooka ; end ;
12855: LD_ADDR_VAR 0 5
12859: PUSH
12860: LD_INT 44
12862: ST_TO_ADDR
12863: GO 12866
12865: POP
// if Researched ( side , tech ) then
12866: LD_VAR 0 3
12870: PPUSH
12871: LD_VAR 0 5
12875: PPUSH
12876: CALL_OW 325
12880: IFFALSE 12907
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12882: LD_ADDR_VAR 0 2
12886: PUSH
12887: LD_INT 5
12889: PUSH
12890: LD_INT 8
12892: PUSH
12893: LD_INT 9
12895: PUSH
12896: EMPTY
12897: LIST
12898: LIST
12899: LIST
12900: PUSH
12901: LD_VAR 0 4
12905: ARRAY
12906: ST_TO_ADDR
// end ;
12907: LD_VAR 0 2
12911: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12912: LD_INT 0
12914: PPUSH
12915: PPUSH
12916: PPUSH
// if not mines then
12917: LD_VAR 0 2
12921: NOT
12922: IFFALSE 12926
// exit ;
12924: GO 13070
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12926: LD_ADDR_VAR 0 5
12930: PUSH
12931: LD_INT 81
12933: PUSH
12934: LD_VAR 0 1
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 3
12945: PUSH
12946: LD_INT 21
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: EMPTY
12953: LIST
12954: LIST
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PPUSH
12964: CALL_OW 69
12968: ST_TO_ADDR
// for i in mines do
12969: LD_ADDR_VAR 0 4
12973: PUSH
12974: LD_VAR 0 2
12978: PUSH
12979: FOR_IN
12980: IFFALSE 13068
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
12982: LD_VAR 0 4
12986: PUSH
12987: LD_INT 1
12989: ARRAY
12990: PPUSH
12991: LD_VAR 0 4
12995: PUSH
12996: LD_INT 2
12998: ARRAY
12999: PPUSH
13000: CALL_OW 458
13004: NOT
13005: IFFALSE 13009
// continue ;
13007: GO 12979
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13009: LD_VAR 0 4
13013: PUSH
13014: LD_INT 1
13016: ARRAY
13017: PPUSH
13018: LD_VAR 0 4
13022: PUSH
13023: LD_INT 2
13025: ARRAY
13026: PPUSH
13027: CALL_OW 428
13031: PUSH
13032: LD_VAR 0 5
13036: IN
13037: IFFALSE 13066
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13039: LD_VAR 0 4
13043: PUSH
13044: LD_INT 1
13046: ARRAY
13047: PPUSH
13048: LD_VAR 0 4
13052: PUSH
13053: LD_INT 2
13055: ARRAY
13056: PPUSH
13057: LD_VAR 0 1
13061: PPUSH
13062: CALL_OW 456
// end ;
13066: GO 12979
13068: POP
13069: POP
// end ;
13070: LD_VAR 0 3
13074: RET
// export function Count ( array ) ; var i ; begin
13075: LD_INT 0
13077: PPUSH
13078: PPUSH
// result := 0 ;
13079: LD_ADDR_VAR 0 2
13083: PUSH
13084: LD_INT 0
13086: ST_TO_ADDR
// for i in array do
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 1
13096: PUSH
13097: FOR_IN
13098: IFFALSE 13122
// if i then
13100: LD_VAR 0 3
13104: IFFALSE 13120
// result := result + 1 ;
13106: LD_ADDR_VAR 0 2
13110: PUSH
13111: LD_VAR 0 2
13115: PUSH
13116: LD_INT 1
13118: PLUS
13119: ST_TO_ADDR
13120: GO 13097
13122: POP
13123: POP
// end ;
13124: LD_VAR 0 2
13128: RET
// export function IsEmpty ( building ) ; begin
13129: LD_INT 0
13131: PPUSH
// if not building then
13132: LD_VAR 0 1
13136: NOT
13137: IFFALSE 13141
// exit ;
13139: GO 13184
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13141: LD_ADDR_VAR 0 2
13145: PUSH
13146: LD_VAR 0 1
13150: PUSH
13151: LD_INT 22
13153: PUSH
13154: LD_VAR 0 1
13158: PPUSH
13159: CALL_OW 255
13163: PUSH
13164: EMPTY
13165: LIST
13166: LIST
13167: PUSH
13168: LD_INT 58
13170: PUSH
13171: EMPTY
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: IN
13183: ST_TO_ADDR
// end ;
13184: LD_VAR 0 2
13188: RET
// export function IsNotFull ( building ) ; var places ; begin
13189: LD_INT 0
13191: PPUSH
13192: PPUSH
// if not building then
13193: LD_VAR 0 1
13197: NOT
13198: IFFALSE 13202
// exit ;
13200: GO 13373
// result := false ;
13202: LD_ADDR_VAR 0 2
13206: PUSH
13207: LD_INT 0
13209: ST_TO_ADDR
// places := 0 ;
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
13218: LD_VAR 0 1
13222: PPUSH
13223: CALL_OW 266
13227: PUSH
13228: LD_INT 0
13230: DOUBLE
13231: EQUAL
13232: IFTRUE 13290
13234: LD_INT 1
13236: DOUBLE
13237: EQUAL
13238: IFTRUE 13290
13240: LD_INT 6
13242: DOUBLE
13243: EQUAL
13244: IFTRUE 13290
13246: LD_INT 7
13248: DOUBLE
13249: EQUAL
13250: IFTRUE 13290
13252: LD_INT 8
13254: DOUBLE
13255: EQUAL
13256: IFTRUE 13290
13258: LD_INT 4
13260: DOUBLE
13261: EQUAL
13262: IFTRUE 13290
13264: LD_INT 5
13266: DOUBLE
13267: EQUAL
13268: IFTRUE 13290
13270: LD_INT 2
13272: DOUBLE
13273: EQUAL
13274: IFTRUE 13290
13276: LD_INT 3
13278: DOUBLE
13279: EQUAL
13280: IFTRUE 13290
13282: LD_INT 35
13284: DOUBLE
13285: EQUAL
13286: IFTRUE 13290
13288: GO 13301
13290: POP
// places := 6 ; b_bunker , b_breastwork :
13291: LD_ADDR_VAR 0 3
13295: PUSH
13296: LD_INT 6
13298: ST_TO_ADDR
13299: GO 13346
13301: LD_INT 32
13303: DOUBLE
13304: EQUAL
13305: IFTRUE 13315
13307: LD_INT 31
13309: DOUBLE
13310: EQUAL
13311: IFTRUE 13315
13313: GO 13326
13315: POP
// places := 1 ; b_control_tower :
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_INT 1
13323: ST_TO_ADDR
13324: GO 13346
13326: LD_INT 36
13328: DOUBLE
13329: EQUAL
13330: IFTRUE 13334
13332: GO 13345
13334: POP
// places := 3 ; end ;
13335: LD_ADDR_VAR 0 3
13339: PUSH
13340: LD_INT 3
13342: ST_TO_ADDR
13343: GO 13346
13345: POP
// if places then
13346: LD_VAR 0 3
13350: IFFALSE 13373
// result := UnitsInside ( building ) < places ;
13352: LD_ADDR_VAR 0 2
13356: PUSH
13357: LD_VAR 0 1
13361: PPUSH
13362: CALL_OW 313
13366: PUSH
13367: LD_VAR 0 3
13371: LESS
13372: ST_TO_ADDR
// end ;
13373: LD_VAR 0 2
13377: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13378: LD_INT 0
13380: PPUSH
13381: PPUSH
13382: PPUSH
13383: PPUSH
// tmp := [ ] ;
13384: LD_ADDR_VAR 0 3
13388: PUSH
13389: EMPTY
13390: ST_TO_ADDR
// list := [ ] ;
13391: LD_ADDR_VAR 0 5
13395: PUSH
13396: EMPTY
13397: ST_TO_ADDR
// for i = 16 to 25 do
13398: LD_ADDR_VAR 0 4
13402: PUSH
13403: DOUBLE
13404: LD_INT 16
13406: DEC
13407: ST_TO_ADDR
13408: LD_INT 25
13410: PUSH
13411: FOR_TO
13412: IFFALSE 13485
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13414: LD_ADDR_VAR 0 3
13418: PUSH
13419: LD_VAR 0 3
13423: PUSH
13424: LD_INT 22
13426: PUSH
13427: LD_VAR 0 1
13431: PPUSH
13432: CALL_OW 255
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 91
13443: PUSH
13444: LD_VAR 0 1
13448: PUSH
13449: LD_INT 6
13451: PUSH
13452: EMPTY
13453: LIST
13454: LIST
13455: LIST
13456: PUSH
13457: LD_INT 30
13459: PUSH
13460: LD_VAR 0 4
13464: PUSH
13465: EMPTY
13466: LIST
13467: LIST
13468: PUSH
13469: EMPTY
13470: LIST
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: PPUSH
13477: CALL_OW 69
13481: ADD
13482: ST_TO_ADDR
13483: GO 13411
13485: POP
13486: POP
// for i = 1 to tmp do
13487: LD_ADDR_VAR 0 4
13491: PUSH
13492: DOUBLE
13493: LD_INT 1
13495: DEC
13496: ST_TO_ADDR
13497: LD_VAR 0 3
13501: PUSH
13502: FOR_TO
13503: IFFALSE 13591
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13505: LD_ADDR_VAR 0 5
13509: PUSH
13510: LD_VAR 0 5
13514: PUSH
13515: LD_VAR 0 3
13519: PUSH
13520: LD_VAR 0 4
13524: ARRAY
13525: PPUSH
13526: CALL_OW 266
13530: PUSH
13531: LD_VAR 0 3
13535: PUSH
13536: LD_VAR 0 4
13540: ARRAY
13541: PPUSH
13542: CALL_OW 250
13546: PUSH
13547: LD_VAR 0 3
13551: PUSH
13552: LD_VAR 0 4
13556: ARRAY
13557: PPUSH
13558: CALL_OW 251
13562: PUSH
13563: LD_VAR 0 3
13567: PUSH
13568: LD_VAR 0 4
13572: ARRAY
13573: PPUSH
13574: CALL_OW 254
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: LIST
13583: LIST
13584: PUSH
13585: EMPTY
13586: LIST
13587: ADD
13588: ST_TO_ADDR
13589: GO 13502
13591: POP
13592: POP
// result := list ;
13593: LD_ADDR_VAR 0 2
13597: PUSH
13598: LD_VAR 0 5
13602: ST_TO_ADDR
// end ;
13603: LD_VAR 0 2
13607: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13608: LD_INT 0
13610: PPUSH
13611: PPUSH
13612: PPUSH
13613: PPUSH
13614: PPUSH
13615: PPUSH
13616: PPUSH
// if not factory then
13617: LD_VAR 0 1
13621: NOT
13622: IFFALSE 13626
// exit ;
13624: GO 14219
// if control = control_apeman then
13626: LD_VAR 0 4
13630: PUSH
13631: LD_INT 5
13633: EQUAL
13634: IFFALSE 13743
// begin tmp := UnitsInside ( factory ) ;
13636: LD_ADDR_VAR 0 8
13640: PUSH
13641: LD_VAR 0 1
13645: PPUSH
13646: CALL_OW 313
13650: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13651: LD_VAR 0 8
13655: PPUSH
13656: LD_INT 25
13658: PUSH
13659: LD_INT 12
13661: PUSH
13662: EMPTY
13663: LIST
13664: LIST
13665: PPUSH
13666: CALL_OW 72
13670: NOT
13671: IFFALSE 13681
// control := control_manual ;
13673: LD_ADDR_VAR 0 4
13677: PUSH
13678: LD_INT 1
13680: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13681: LD_ADDR_VAR 0 8
13685: PUSH
13686: LD_VAR 0 1
13690: PPUSH
13691: CALL 13378 0 1
13695: ST_TO_ADDR
// if tmp then
13696: LD_VAR 0 8
13700: IFFALSE 13743
// begin for i in tmp do
13702: LD_ADDR_VAR 0 7
13706: PUSH
13707: LD_VAR 0 8
13711: PUSH
13712: FOR_IN
13713: IFFALSE 13741
// if i [ 1 ] = b_ext_radio then
13715: LD_VAR 0 7
13719: PUSH
13720: LD_INT 1
13722: ARRAY
13723: PUSH
13724: LD_INT 22
13726: EQUAL
13727: IFFALSE 13739
// begin control := control_remote ;
13729: LD_ADDR_VAR 0 4
13733: PUSH
13734: LD_INT 2
13736: ST_TO_ADDR
// break ;
13737: GO 13741
// end ;
13739: GO 13712
13741: POP
13742: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13743: LD_VAR 0 1
13747: PPUSH
13748: LD_VAR 0 2
13752: PPUSH
13753: LD_VAR 0 3
13757: PPUSH
13758: LD_VAR 0 4
13762: PPUSH
13763: LD_VAR 0 5
13767: PPUSH
13768: CALL_OW 448
13772: IFFALSE 13807
// begin result := [ chassis , engine , control , weapon ] ;
13774: LD_ADDR_VAR 0 6
13778: PUSH
13779: LD_VAR 0 2
13783: PUSH
13784: LD_VAR 0 3
13788: PUSH
13789: LD_VAR 0 4
13793: PUSH
13794: LD_VAR 0 5
13798: PUSH
13799: EMPTY
13800: LIST
13801: LIST
13802: LIST
13803: LIST
13804: ST_TO_ADDR
// exit ;
13805: GO 14219
// end ; _chassis := AvailableChassisList ( factory ) ;
13807: LD_ADDR_VAR 0 9
13811: PUSH
13812: LD_VAR 0 1
13816: PPUSH
13817: CALL_OW 475
13821: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13822: LD_ADDR_VAR 0 11
13826: PUSH
13827: LD_VAR 0 1
13831: PPUSH
13832: CALL_OW 476
13836: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13837: LD_ADDR_VAR 0 12
13841: PUSH
13842: LD_VAR 0 1
13846: PPUSH
13847: CALL_OW 477
13851: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13852: LD_ADDR_VAR 0 10
13856: PUSH
13857: LD_VAR 0 1
13861: PPUSH
13862: CALL_OW 478
13866: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13867: LD_VAR 0 9
13871: NOT
13872: PUSH
13873: LD_VAR 0 11
13877: NOT
13878: OR
13879: PUSH
13880: LD_VAR 0 12
13884: NOT
13885: OR
13886: PUSH
13887: LD_VAR 0 10
13891: NOT
13892: OR
13893: IFFALSE 13928
// begin result := [ chassis , engine , control , weapon ] ;
13895: LD_ADDR_VAR 0 6
13899: PUSH
13900: LD_VAR 0 2
13904: PUSH
13905: LD_VAR 0 3
13909: PUSH
13910: LD_VAR 0 4
13914: PUSH
13915: LD_VAR 0 5
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: ST_TO_ADDR
// exit ;
13926: GO 14219
// end ; if not chassis in _chassis then
13928: LD_VAR 0 2
13932: PUSH
13933: LD_VAR 0 9
13937: IN
13938: NOT
13939: IFFALSE 13965
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13941: LD_ADDR_VAR 0 2
13945: PUSH
13946: LD_VAR 0 9
13950: PUSH
13951: LD_INT 1
13953: PPUSH
13954: LD_VAR 0 9
13958: PPUSH
13959: CALL_OW 12
13963: ARRAY
13964: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13965: LD_VAR 0 2
13969: PPUSH
13970: LD_VAR 0 3
13974: PPUSH
13975: CALL 14224 0 2
13979: NOT
13980: IFFALSE 14039
// repeat engine := _engine [ 1 ] ;
13982: LD_ADDR_VAR 0 3
13986: PUSH
13987: LD_VAR 0 11
13991: PUSH
13992: LD_INT 1
13994: ARRAY
13995: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13996: LD_ADDR_VAR 0 11
14000: PUSH
14001: LD_VAR 0 11
14005: PPUSH
14006: LD_INT 1
14008: PPUSH
14009: CALL_OW 3
14013: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14014: LD_VAR 0 2
14018: PPUSH
14019: LD_VAR 0 3
14023: PPUSH
14024: CALL 14224 0 2
14028: PUSH
14029: LD_VAR 0 11
14033: PUSH
14034: EMPTY
14035: EQUAL
14036: OR
14037: IFFALSE 13982
// if not control in _control then
14039: LD_VAR 0 4
14043: PUSH
14044: LD_VAR 0 12
14048: IN
14049: NOT
14050: IFFALSE 14076
// control := _control [ rand ( 1 , _control ) ] ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: LD_VAR 0 12
14061: PUSH
14062: LD_INT 1
14064: PPUSH
14065: LD_VAR 0 12
14069: PPUSH
14070: CALL_OW 12
14074: ARRAY
14075: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14076: LD_VAR 0 2
14080: PPUSH
14081: LD_VAR 0 5
14085: PPUSH
14086: CALL 14444 0 2
14090: NOT
14091: IFFALSE 14150
// repeat weapon := _weapon [ 1 ] ;
14093: LD_ADDR_VAR 0 5
14097: PUSH
14098: LD_VAR 0 10
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14107: LD_ADDR_VAR 0 10
14111: PUSH
14112: LD_VAR 0 10
14116: PPUSH
14117: LD_INT 1
14119: PPUSH
14120: CALL_OW 3
14124: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14125: LD_VAR 0 2
14129: PPUSH
14130: LD_VAR 0 5
14134: PPUSH
14135: CALL 14444 0 2
14139: PUSH
14140: LD_VAR 0 10
14144: PUSH
14145: EMPTY
14146: EQUAL
14147: OR
14148: IFFALSE 14093
// result := [ ] ;
14150: LD_ADDR_VAR 0 6
14154: PUSH
14155: EMPTY
14156: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14157: LD_VAR 0 1
14161: PPUSH
14162: LD_VAR 0 2
14166: PPUSH
14167: LD_VAR 0 3
14171: PPUSH
14172: LD_VAR 0 4
14176: PPUSH
14177: LD_VAR 0 5
14181: PPUSH
14182: CALL_OW 448
14186: IFFALSE 14219
// result := [ chassis , engine , control , weapon ] ;
14188: LD_ADDR_VAR 0 6
14192: PUSH
14193: LD_VAR 0 2
14197: PUSH
14198: LD_VAR 0 3
14202: PUSH
14203: LD_VAR 0 4
14207: PUSH
14208: LD_VAR 0 5
14212: PUSH
14213: EMPTY
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: ST_TO_ADDR
// end ;
14219: LD_VAR 0 6
14223: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14224: LD_INT 0
14226: PPUSH
// if not chassis or not engine then
14227: LD_VAR 0 1
14231: NOT
14232: PUSH
14233: LD_VAR 0 2
14237: NOT
14238: OR
14239: IFFALSE 14243
// exit ;
14241: GO 14439
// case engine of engine_solar :
14243: LD_VAR 0 2
14247: PUSH
14248: LD_INT 2
14250: DOUBLE
14251: EQUAL
14252: IFTRUE 14256
14254: GO 14294
14256: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14257: LD_ADDR_VAR 0 3
14261: PUSH
14262: LD_INT 11
14264: PUSH
14265: LD_INT 12
14267: PUSH
14268: LD_INT 13
14270: PUSH
14271: LD_INT 14
14273: PUSH
14274: LD_INT 1
14276: PUSH
14277: LD_INT 2
14279: PUSH
14280: LD_INT 3
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: LIST
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: ST_TO_ADDR
14292: GO 14423
14294: LD_INT 1
14296: DOUBLE
14297: EQUAL
14298: IFTRUE 14302
14300: GO 14364
14302: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14303: LD_ADDR_VAR 0 3
14307: PUSH
14308: LD_INT 11
14310: PUSH
14311: LD_INT 12
14313: PUSH
14314: LD_INT 13
14316: PUSH
14317: LD_INT 14
14319: PUSH
14320: LD_INT 1
14322: PUSH
14323: LD_INT 2
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: LD_INT 4
14331: PUSH
14332: LD_INT 5
14334: PUSH
14335: LD_INT 21
14337: PUSH
14338: LD_INT 23
14340: PUSH
14341: LD_INT 22
14343: PUSH
14344: LD_INT 24
14346: PUSH
14347: EMPTY
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: ST_TO_ADDR
14362: GO 14423
14364: LD_INT 3
14366: DOUBLE
14367: EQUAL
14368: IFTRUE 14372
14370: GO 14422
14372: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14373: LD_ADDR_VAR 0 3
14377: PUSH
14378: LD_INT 13
14380: PUSH
14381: LD_INT 14
14383: PUSH
14384: LD_INT 2
14386: PUSH
14387: LD_INT 3
14389: PUSH
14390: LD_INT 4
14392: PUSH
14393: LD_INT 5
14395: PUSH
14396: LD_INT 21
14398: PUSH
14399: LD_INT 22
14401: PUSH
14402: LD_INT 23
14404: PUSH
14405: LD_INT 24
14407: PUSH
14408: EMPTY
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 14423
14422: POP
// result := ( chassis in result ) ;
14423: LD_ADDR_VAR 0 3
14427: PUSH
14428: LD_VAR 0 1
14432: PUSH
14433: LD_VAR 0 3
14437: IN
14438: ST_TO_ADDR
// end ;
14439: LD_VAR 0 3
14443: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14444: LD_INT 0
14446: PPUSH
// if not chassis or not weapon then
14447: LD_VAR 0 1
14451: NOT
14452: PUSH
14453: LD_VAR 0 2
14457: NOT
14458: OR
14459: IFFALSE 14463
// exit ;
14461: GO 15523
// case weapon of us_machine_gun :
14463: LD_VAR 0 2
14467: PUSH
14468: LD_INT 2
14470: DOUBLE
14471: EQUAL
14472: IFTRUE 14476
14474: GO 14506
14476: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14477: LD_ADDR_VAR 0 3
14481: PUSH
14482: LD_INT 1
14484: PUSH
14485: LD_INT 2
14487: PUSH
14488: LD_INT 3
14490: PUSH
14491: LD_INT 4
14493: PUSH
14494: LD_INT 5
14496: PUSH
14497: EMPTY
14498: LIST
14499: LIST
14500: LIST
14501: LIST
14502: LIST
14503: ST_TO_ADDR
14504: GO 15507
14506: LD_INT 3
14508: DOUBLE
14509: EQUAL
14510: IFTRUE 14514
14512: GO 14544
14514: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14515: LD_ADDR_VAR 0 3
14519: PUSH
14520: LD_INT 1
14522: PUSH
14523: LD_INT 2
14525: PUSH
14526: LD_INT 3
14528: PUSH
14529: LD_INT 4
14531: PUSH
14532: LD_INT 5
14534: PUSH
14535: EMPTY
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: ST_TO_ADDR
14542: GO 15507
14544: LD_INT 11
14546: DOUBLE
14547: EQUAL
14548: IFTRUE 14552
14550: GO 14582
14552: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14553: LD_ADDR_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: PUSH
14561: LD_INT 2
14563: PUSH
14564: LD_INT 3
14566: PUSH
14567: LD_INT 4
14569: PUSH
14570: LD_INT 5
14572: PUSH
14573: EMPTY
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: ST_TO_ADDR
14580: GO 15507
14582: LD_INT 4
14584: DOUBLE
14585: EQUAL
14586: IFTRUE 14590
14588: GO 14616
14590: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14591: LD_ADDR_VAR 0 3
14595: PUSH
14596: LD_INT 2
14598: PUSH
14599: LD_INT 3
14601: PUSH
14602: LD_INT 4
14604: PUSH
14605: LD_INT 5
14607: PUSH
14608: EMPTY
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: ST_TO_ADDR
14614: GO 15507
14616: LD_INT 5
14618: DOUBLE
14619: EQUAL
14620: IFTRUE 14624
14622: GO 14650
14624: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14625: LD_ADDR_VAR 0 3
14629: PUSH
14630: LD_INT 2
14632: PUSH
14633: LD_INT 3
14635: PUSH
14636: LD_INT 4
14638: PUSH
14639: LD_INT 5
14641: PUSH
14642: EMPTY
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: ST_TO_ADDR
14648: GO 15507
14650: LD_INT 9
14652: DOUBLE
14653: EQUAL
14654: IFTRUE 14658
14656: GO 14684
14658: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14659: LD_ADDR_VAR 0 3
14663: PUSH
14664: LD_INT 2
14666: PUSH
14667: LD_INT 3
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: LD_INT 5
14675: PUSH
14676: EMPTY
14677: LIST
14678: LIST
14679: LIST
14680: LIST
14681: ST_TO_ADDR
14682: GO 15507
14684: LD_INT 7
14686: DOUBLE
14687: EQUAL
14688: IFTRUE 14692
14690: GO 14718
14692: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14693: LD_ADDR_VAR 0 3
14697: PUSH
14698: LD_INT 2
14700: PUSH
14701: LD_INT 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: LIST
14714: LIST
14715: ST_TO_ADDR
14716: GO 15507
14718: LD_INT 12
14720: DOUBLE
14721: EQUAL
14722: IFTRUE 14726
14724: GO 14752
14726: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14727: LD_ADDR_VAR 0 3
14731: PUSH
14732: LD_INT 2
14734: PUSH
14735: LD_INT 3
14737: PUSH
14738: LD_INT 4
14740: PUSH
14741: LD_INT 5
14743: PUSH
14744: EMPTY
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: ST_TO_ADDR
14750: GO 15507
14752: LD_INT 13
14754: DOUBLE
14755: EQUAL
14756: IFTRUE 14760
14758: GO 14786
14760: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14761: LD_ADDR_VAR 0 3
14765: PUSH
14766: LD_INT 2
14768: PUSH
14769: LD_INT 3
14771: PUSH
14772: LD_INT 4
14774: PUSH
14775: LD_INT 5
14777: PUSH
14778: EMPTY
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: ST_TO_ADDR
14784: GO 15507
14786: LD_INT 14
14788: DOUBLE
14789: EQUAL
14790: IFTRUE 14794
14792: GO 14812
14794: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14795: LD_ADDR_VAR 0 3
14799: PUSH
14800: LD_INT 4
14802: PUSH
14803: LD_INT 5
14805: PUSH
14806: EMPTY
14807: LIST
14808: LIST
14809: ST_TO_ADDR
14810: GO 15507
14812: LD_INT 6
14814: DOUBLE
14815: EQUAL
14816: IFTRUE 14820
14818: GO 14838
14820: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14821: LD_ADDR_VAR 0 3
14825: PUSH
14826: LD_INT 4
14828: PUSH
14829: LD_INT 5
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: ST_TO_ADDR
14836: GO 15507
14838: LD_INT 10
14840: DOUBLE
14841: EQUAL
14842: IFTRUE 14846
14844: GO 14864
14846: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14847: LD_ADDR_VAR 0 3
14851: PUSH
14852: LD_INT 4
14854: PUSH
14855: LD_INT 5
14857: PUSH
14858: EMPTY
14859: LIST
14860: LIST
14861: ST_TO_ADDR
14862: GO 15507
14864: LD_INT 22
14866: DOUBLE
14867: EQUAL
14868: IFTRUE 14872
14870: GO 14898
14872: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14873: LD_ADDR_VAR 0 3
14877: PUSH
14878: LD_INT 11
14880: PUSH
14881: LD_INT 12
14883: PUSH
14884: LD_INT 13
14886: PUSH
14887: LD_INT 14
14889: PUSH
14890: EMPTY
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: ST_TO_ADDR
14896: GO 15507
14898: LD_INT 23
14900: DOUBLE
14901: EQUAL
14902: IFTRUE 14906
14904: GO 14932
14906: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14907: LD_ADDR_VAR 0 3
14911: PUSH
14912: LD_INT 11
14914: PUSH
14915: LD_INT 12
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: LIST
14928: LIST
14929: ST_TO_ADDR
14930: GO 15507
14932: LD_INT 24
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15507
14966: LD_INT 30
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 15000
14974: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 11
14982: PUSH
14983: LD_INT 12
14985: PUSH
14986: LD_INT 13
14988: PUSH
14989: LD_INT 14
14991: PUSH
14992: EMPTY
14993: LIST
14994: LIST
14995: LIST
14996: LIST
14997: ST_TO_ADDR
14998: GO 15507
15000: LD_INT 25
15002: DOUBLE
15003: EQUAL
15004: IFTRUE 15008
15006: GO 15026
15008: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15009: LD_ADDR_VAR 0 3
15013: PUSH
15014: LD_INT 13
15016: PUSH
15017: LD_INT 14
15019: PUSH
15020: EMPTY
15021: LIST
15022: LIST
15023: ST_TO_ADDR
15024: GO 15507
15026: LD_INT 27
15028: DOUBLE
15029: EQUAL
15030: IFTRUE 15034
15032: GO 15052
15034: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15035: LD_ADDR_VAR 0 3
15039: PUSH
15040: LD_INT 13
15042: PUSH
15043: LD_INT 14
15045: PUSH
15046: EMPTY
15047: LIST
15048: LIST
15049: ST_TO_ADDR
15050: GO 15507
15052: LD_INT 92
15054: DOUBLE
15055: EQUAL
15056: IFTRUE 15060
15058: GO 15086
15060: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15061: LD_ADDR_VAR 0 3
15065: PUSH
15066: LD_INT 11
15068: PUSH
15069: LD_INT 12
15071: PUSH
15072: LD_INT 13
15074: PUSH
15075: LD_INT 14
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: ST_TO_ADDR
15084: GO 15507
15086: LD_INT 28
15088: DOUBLE
15089: EQUAL
15090: IFTRUE 15094
15092: GO 15112
15094: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15095: LD_ADDR_VAR 0 3
15099: PUSH
15100: LD_INT 13
15102: PUSH
15103: LD_INT 14
15105: PUSH
15106: EMPTY
15107: LIST
15108: LIST
15109: ST_TO_ADDR
15110: GO 15507
15112: LD_INT 29
15114: DOUBLE
15115: EQUAL
15116: IFTRUE 15120
15118: GO 15138
15120: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15121: LD_ADDR_VAR 0 3
15125: PUSH
15126: LD_INT 13
15128: PUSH
15129: LD_INT 14
15131: PUSH
15132: EMPTY
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15507
15138: LD_INT 31
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15164
15146: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 13
15154: PUSH
15155: LD_INT 14
15157: PUSH
15158: EMPTY
15159: LIST
15160: LIST
15161: ST_TO_ADDR
15162: GO 15507
15164: LD_INT 26
15166: DOUBLE
15167: EQUAL
15168: IFTRUE 15172
15170: GO 15190
15172: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15173: LD_ADDR_VAR 0 3
15177: PUSH
15178: LD_INT 13
15180: PUSH
15181: LD_INT 14
15183: PUSH
15184: EMPTY
15185: LIST
15186: LIST
15187: ST_TO_ADDR
15188: GO 15507
15190: LD_INT 42
15192: DOUBLE
15193: EQUAL
15194: IFTRUE 15198
15196: GO 15224
15198: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15199: LD_ADDR_VAR 0 3
15203: PUSH
15204: LD_INT 21
15206: PUSH
15207: LD_INT 22
15209: PUSH
15210: LD_INT 23
15212: PUSH
15213: LD_INT 24
15215: PUSH
15216: EMPTY
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: ST_TO_ADDR
15222: GO 15507
15224: LD_INT 43
15226: DOUBLE
15227: EQUAL
15228: IFTRUE 15232
15230: GO 15258
15232: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15233: LD_ADDR_VAR 0 3
15237: PUSH
15238: LD_INT 21
15240: PUSH
15241: LD_INT 22
15243: PUSH
15244: LD_INT 23
15246: PUSH
15247: LD_INT 24
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: LIST
15254: LIST
15255: ST_TO_ADDR
15256: GO 15507
15258: LD_INT 44
15260: DOUBLE
15261: EQUAL
15262: IFTRUE 15266
15264: GO 15292
15266: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15267: LD_ADDR_VAR 0 3
15271: PUSH
15272: LD_INT 21
15274: PUSH
15275: LD_INT 22
15277: PUSH
15278: LD_INT 23
15280: PUSH
15281: LD_INT 24
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: LIST
15288: LIST
15289: ST_TO_ADDR
15290: GO 15507
15292: LD_INT 45
15294: DOUBLE
15295: EQUAL
15296: IFTRUE 15300
15298: GO 15326
15300: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15301: LD_ADDR_VAR 0 3
15305: PUSH
15306: LD_INT 21
15308: PUSH
15309: LD_INT 22
15311: PUSH
15312: LD_INT 23
15314: PUSH
15315: LD_INT 24
15317: PUSH
15318: EMPTY
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: ST_TO_ADDR
15324: GO 15507
15326: LD_INT 49
15328: DOUBLE
15329: EQUAL
15330: IFTRUE 15334
15332: GO 15360
15334: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15335: LD_ADDR_VAR 0 3
15339: PUSH
15340: LD_INT 21
15342: PUSH
15343: LD_INT 22
15345: PUSH
15346: LD_INT 23
15348: PUSH
15349: LD_INT 24
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15507
15360: LD_INT 51
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15394
15368: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 21
15376: PUSH
15377: LD_INT 22
15379: PUSH
15380: LD_INT 23
15382: PUSH
15383: LD_INT 24
15385: PUSH
15386: EMPTY
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: ST_TO_ADDR
15392: GO 15507
15394: LD_INT 52
15396: DOUBLE
15397: EQUAL
15398: IFTRUE 15402
15400: GO 15428
15402: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15403: LD_ADDR_VAR 0 3
15407: PUSH
15408: LD_INT 21
15410: PUSH
15411: LD_INT 22
15413: PUSH
15414: LD_INT 23
15416: PUSH
15417: LD_INT 24
15419: PUSH
15420: EMPTY
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: ST_TO_ADDR
15426: GO 15507
15428: LD_INT 53
15430: DOUBLE
15431: EQUAL
15432: IFTRUE 15436
15434: GO 15454
15436: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15437: LD_ADDR_VAR 0 3
15441: PUSH
15442: LD_INT 23
15444: PUSH
15445: LD_INT 24
15447: PUSH
15448: EMPTY
15449: LIST
15450: LIST
15451: ST_TO_ADDR
15452: GO 15507
15454: LD_INT 46
15456: DOUBLE
15457: EQUAL
15458: IFTRUE 15462
15460: GO 15480
15462: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15463: LD_ADDR_VAR 0 3
15467: PUSH
15468: LD_INT 23
15470: PUSH
15471: LD_INT 24
15473: PUSH
15474: EMPTY
15475: LIST
15476: LIST
15477: ST_TO_ADDR
15478: GO 15507
15480: LD_INT 47
15482: DOUBLE
15483: EQUAL
15484: IFTRUE 15488
15486: GO 15506
15488: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15489: LD_ADDR_VAR 0 3
15493: PUSH
15494: LD_INT 23
15496: PUSH
15497: LD_INT 24
15499: PUSH
15500: EMPTY
15501: LIST
15502: LIST
15503: ST_TO_ADDR
15504: GO 15507
15506: POP
// result := ( chassis in result ) ;
15507: LD_ADDR_VAR 0 3
15511: PUSH
15512: LD_VAR 0 1
15516: PUSH
15517: LD_VAR 0 3
15521: IN
15522: ST_TO_ADDR
// end ;
15523: LD_VAR 0 3
15527: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15528: LD_INT 0
15530: PPUSH
15531: PPUSH
15532: PPUSH
15533: PPUSH
15534: PPUSH
15535: PPUSH
15536: PPUSH
// result := array ;
15537: LD_ADDR_VAR 0 5
15541: PUSH
15542: LD_VAR 0 1
15546: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15547: LD_VAR 0 1
15551: NOT
15552: PUSH
15553: LD_VAR 0 2
15557: NOT
15558: OR
15559: PUSH
15560: LD_VAR 0 3
15564: NOT
15565: OR
15566: PUSH
15567: LD_VAR 0 2
15571: PUSH
15572: LD_VAR 0 1
15576: GREATER
15577: OR
15578: PUSH
15579: LD_VAR 0 3
15583: PUSH
15584: LD_VAR 0 1
15588: GREATER
15589: OR
15590: IFFALSE 15594
// exit ;
15592: GO 15890
// if direction then
15594: LD_VAR 0 4
15598: IFFALSE 15662
// begin d := 1 ;
15600: LD_ADDR_VAR 0 9
15604: PUSH
15605: LD_INT 1
15607: ST_TO_ADDR
// if i_from > i_to then
15608: LD_VAR 0 2
15612: PUSH
15613: LD_VAR 0 3
15617: GREATER
15618: IFFALSE 15644
// length := ( array - i_from ) + i_to else
15620: LD_ADDR_VAR 0 11
15624: PUSH
15625: LD_VAR 0 1
15629: PUSH
15630: LD_VAR 0 2
15634: MINUS
15635: PUSH
15636: LD_VAR 0 3
15640: PLUS
15641: ST_TO_ADDR
15642: GO 15660
// length := i_to - i_from ;
15644: LD_ADDR_VAR 0 11
15648: PUSH
15649: LD_VAR 0 3
15653: PUSH
15654: LD_VAR 0 2
15658: MINUS
15659: ST_TO_ADDR
// end else
15660: GO 15723
// begin d := - 1 ;
15662: LD_ADDR_VAR 0 9
15666: PUSH
15667: LD_INT 1
15669: NEG
15670: ST_TO_ADDR
// if i_from > i_to then
15671: LD_VAR 0 2
15675: PUSH
15676: LD_VAR 0 3
15680: GREATER
15681: IFFALSE 15701
// length := i_from - i_to else
15683: LD_ADDR_VAR 0 11
15687: PUSH
15688: LD_VAR 0 2
15692: PUSH
15693: LD_VAR 0 3
15697: MINUS
15698: ST_TO_ADDR
15699: GO 15723
// length := ( array - i_to ) + i_from ;
15701: LD_ADDR_VAR 0 11
15705: PUSH
15706: LD_VAR 0 1
15710: PUSH
15711: LD_VAR 0 3
15715: MINUS
15716: PUSH
15717: LD_VAR 0 2
15721: PLUS
15722: ST_TO_ADDR
// end ; if not length then
15723: LD_VAR 0 11
15727: NOT
15728: IFFALSE 15732
// exit ;
15730: GO 15890
// tmp := array ;
15732: LD_ADDR_VAR 0 10
15736: PUSH
15737: LD_VAR 0 1
15741: ST_TO_ADDR
// for i = 1 to length do
15742: LD_ADDR_VAR 0 6
15746: PUSH
15747: DOUBLE
15748: LD_INT 1
15750: DEC
15751: ST_TO_ADDR
15752: LD_VAR 0 11
15756: PUSH
15757: FOR_TO
15758: IFFALSE 15878
// begin for j = 1 to array do
15760: LD_ADDR_VAR 0 7
15764: PUSH
15765: DOUBLE
15766: LD_INT 1
15768: DEC
15769: ST_TO_ADDR
15770: LD_VAR 0 1
15774: PUSH
15775: FOR_TO
15776: IFFALSE 15864
// begin k := j + d ;
15778: LD_ADDR_VAR 0 8
15782: PUSH
15783: LD_VAR 0 7
15787: PUSH
15788: LD_VAR 0 9
15792: PLUS
15793: ST_TO_ADDR
// if k > array then
15794: LD_VAR 0 8
15798: PUSH
15799: LD_VAR 0 1
15803: GREATER
15804: IFFALSE 15814
// k := 1 ;
15806: LD_ADDR_VAR 0 8
15810: PUSH
15811: LD_INT 1
15813: ST_TO_ADDR
// if not k then
15814: LD_VAR 0 8
15818: NOT
15819: IFFALSE 15831
// k := array ;
15821: LD_ADDR_VAR 0 8
15825: PUSH
15826: LD_VAR 0 1
15830: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15831: LD_ADDR_VAR 0 10
15835: PUSH
15836: LD_VAR 0 10
15840: PPUSH
15841: LD_VAR 0 8
15845: PPUSH
15846: LD_VAR 0 1
15850: PUSH
15851: LD_VAR 0 7
15855: ARRAY
15856: PPUSH
15857: CALL_OW 1
15861: ST_TO_ADDR
// end ;
15862: GO 15775
15864: POP
15865: POP
// array := tmp ;
15866: LD_ADDR_VAR 0 1
15870: PUSH
15871: LD_VAR 0 10
15875: ST_TO_ADDR
// end ;
15876: GO 15757
15878: POP
15879: POP
// result := array ;
15880: LD_ADDR_VAR 0 5
15884: PUSH
15885: LD_VAR 0 1
15889: ST_TO_ADDR
// end ;
15890: LD_VAR 0 5
15894: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15895: LD_INT 0
15897: PPUSH
15898: PPUSH
// result := 0 ;
15899: LD_ADDR_VAR 0 3
15903: PUSH
15904: LD_INT 0
15906: ST_TO_ADDR
// if not array or not value in array then
15907: LD_VAR 0 1
15911: NOT
15912: PUSH
15913: LD_VAR 0 2
15917: PUSH
15918: LD_VAR 0 1
15922: IN
15923: NOT
15924: OR
15925: IFFALSE 15929
// exit ;
15927: GO 15983
// for i = 1 to array do
15929: LD_ADDR_VAR 0 4
15933: PUSH
15934: DOUBLE
15935: LD_INT 1
15937: DEC
15938: ST_TO_ADDR
15939: LD_VAR 0 1
15943: PUSH
15944: FOR_TO
15945: IFFALSE 15981
// if value = array [ i ] then
15947: LD_VAR 0 2
15951: PUSH
15952: LD_VAR 0 1
15956: PUSH
15957: LD_VAR 0 4
15961: ARRAY
15962: EQUAL
15963: IFFALSE 15979
// begin result := i ;
15965: LD_ADDR_VAR 0 3
15969: PUSH
15970: LD_VAR 0 4
15974: ST_TO_ADDR
// exit ;
15975: POP
15976: POP
15977: GO 15983
// end ;
15979: GO 15944
15981: POP
15982: POP
// end ;
15983: LD_VAR 0 3
15987: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15988: LD_INT 0
15990: PPUSH
// vc_chassis := chassis ;
15991: LD_ADDR_OWVAR 37
15995: PUSH
15996: LD_VAR 0 1
16000: ST_TO_ADDR
// vc_engine := engine ;
16001: LD_ADDR_OWVAR 39
16005: PUSH
16006: LD_VAR 0 2
16010: ST_TO_ADDR
// vc_control := control ;
16011: LD_ADDR_OWVAR 38
16015: PUSH
16016: LD_VAR 0 3
16020: ST_TO_ADDR
// vc_weapon := weapon ;
16021: LD_ADDR_OWVAR 40
16025: PUSH
16026: LD_VAR 0 4
16030: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16031: LD_ADDR_OWVAR 41
16035: PUSH
16036: LD_VAR 0 5
16040: ST_TO_ADDR
// end ;
16041: LD_VAR 0 6
16045: RET
// export function WantPlant ( unit ) ; var task ; begin
16046: LD_INT 0
16048: PPUSH
16049: PPUSH
// result := false ;
16050: LD_ADDR_VAR 0 2
16054: PUSH
16055: LD_INT 0
16057: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16058: LD_ADDR_VAR 0 3
16062: PUSH
16063: LD_VAR 0 1
16067: PPUSH
16068: CALL_OW 437
16072: ST_TO_ADDR
// if task then
16073: LD_VAR 0 3
16077: IFFALSE 16105
// if task [ 1 ] [ 1 ] = p then
16079: LD_VAR 0 3
16083: PUSH
16084: LD_INT 1
16086: ARRAY
16087: PUSH
16088: LD_INT 1
16090: ARRAY
16091: PUSH
16092: LD_STRING p
16094: EQUAL
16095: IFFALSE 16105
// result := true ;
16097: LD_ADDR_VAR 0 2
16101: PUSH
16102: LD_INT 1
16104: ST_TO_ADDR
// end ;
16105: LD_VAR 0 2
16109: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16110: LD_INT 0
16112: PPUSH
16113: PPUSH
16114: PPUSH
16115: PPUSH
// if pos < 1 then
16116: LD_VAR 0 2
16120: PUSH
16121: LD_INT 1
16123: LESS
16124: IFFALSE 16128
// exit ;
16126: GO 16431
// if pos = 1 then
16128: LD_VAR 0 2
16132: PUSH
16133: LD_INT 1
16135: EQUAL
16136: IFFALSE 16169
// result := Replace ( arr , pos [ 1 ] , value ) else
16138: LD_ADDR_VAR 0 4
16142: PUSH
16143: LD_VAR 0 1
16147: PPUSH
16148: LD_VAR 0 2
16152: PUSH
16153: LD_INT 1
16155: ARRAY
16156: PPUSH
16157: LD_VAR 0 3
16161: PPUSH
16162: CALL_OW 1
16166: ST_TO_ADDR
16167: GO 16431
// begin tmp := arr ;
16169: LD_ADDR_VAR 0 6
16173: PUSH
16174: LD_VAR 0 1
16178: ST_TO_ADDR
// s_arr := [ tmp ] ;
16179: LD_ADDR_VAR 0 7
16183: PUSH
16184: LD_VAR 0 6
16188: PUSH
16189: EMPTY
16190: LIST
16191: ST_TO_ADDR
// for i = 1 to pos - 1 do
16192: LD_ADDR_VAR 0 5
16196: PUSH
16197: DOUBLE
16198: LD_INT 1
16200: DEC
16201: ST_TO_ADDR
16202: LD_VAR 0 2
16206: PUSH
16207: LD_INT 1
16209: MINUS
16210: PUSH
16211: FOR_TO
16212: IFFALSE 16257
// begin tmp := tmp [ pos [ i ] ] ;
16214: LD_ADDR_VAR 0 6
16218: PUSH
16219: LD_VAR 0 6
16223: PUSH
16224: LD_VAR 0 2
16228: PUSH
16229: LD_VAR 0 5
16233: ARRAY
16234: ARRAY
16235: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16236: LD_ADDR_VAR 0 7
16240: PUSH
16241: LD_VAR 0 7
16245: PUSH
16246: LD_VAR 0 6
16250: PUSH
16251: EMPTY
16252: LIST
16253: ADD
16254: ST_TO_ADDR
// end ;
16255: GO 16211
16257: POP
16258: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16259: LD_ADDR_VAR 0 6
16263: PUSH
16264: LD_VAR 0 6
16268: PPUSH
16269: LD_VAR 0 2
16273: PUSH
16274: LD_VAR 0 2
16278: ARRAY
16279: PPUSH
16280: LD_VAR 0 3
16284: PPUSH
16285: CALL_OW 1
16289: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16290: LD_ADDR_VAR 0 7
16294: PUSH
16295: LD_VAR 0 7
16299: PPUSH
16300: LD_VAR 0 7
16304: PPUSH
16305: LD_VAR 0 6
16309: PPUSH
16310: CALL_OW 1
16314: ST_TO_ADDR
// for i = s_arr downto 2 do
16315: LD_ADDR_VAR 0 5
16319: PUSH
16320: DOUBLE
16321: LD_VAR 0 7
16325: INC
16326: ST_TO_ADDR
16327: LD_INT 2
16329: PUSH
16330: FOR_DOWNTO
16331: IFFALSE 16415
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16333: LD_ADDR_VAR 0 6
16337: PUSH
16338: LD_VAR 0 7
16342: PUSH
16343: LD_VAR 0 5
16347: PUSH
16348: LD_INT 1
16350: MINUS
16351: ARRAY
16352: PPUSH
16353: LD_VAR 0 2
16357: PUSH
16358: LD_VAR 0 5
16362: PUSH
16363: LD_INT 1
16365: MINUS
16366: ARRAY
16367: PPUSH
16368: LD_VAR 0 7
16372: PUSH
16373: LD_VAR 0 5
16377: ARRAY
16378: PPUSH
16379: CALL_OW 1
16383: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16384: LD_ADDR_VAR 0 7
16388: PUSH
16389: LD_VAR 0 7
16393: PPUSH
16394: LD_VAR 0 5
16398: PUSH
16399: LD_INT 1
16401: MINUS
16402: PPUSH
16403: LD_VAR 0 6
16407: PPUSH
16408: CALL_OW 1
16412: ST_TO_ADDR
// end ;
16413: GO 16330
16415: POP
16416: POP
// result := s_arr [ 1 ] ;
16417: LD_ADDR_VAR 0 4
16421: PUSH
16422: LD_VAR 0 7
16426: PUSH
16427: LD_INT 1
16429: ARRAY
16430: ST_TO_ADDR
// end ; end ;
16431: LD_VAR 0 4
16435: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16436: LD_INT 0
16438: PPUSH
16439: PPUSH
// if not list then
16440: LD_VAR 0 1
16444: NOT
16445: IFFALSE 16449
// exit ;
16447: GO 16540
// i := list [ pos1 ] ;
16449: LD_ADDR_VAR 0 5
16453: PUSH
16454: LD_VAR 0 1
16458: PUSH
16459: LD_VAR 0 2
16463: ARRAY
16464: ST_TO_ADDR
// if not i then
16465: LD_VAR 0 5
16469: NOT
16470: IFFALSE 16474
// exit ;
16472: GO 16540
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16474: LD_ADDR_VAR 0 1
16478: PUSH
16479: LD_VAR 0 1
16483: PPUSH
16484: LD_VAR 0 2
16488: PPUSH
16489: LD_VAR 0 1
16493: PUSH
16494: LD_VAR 0 3
16498: ARRAY
16499: PPUSH
16500: CALL_OW 1
16504: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16505: LD_ADDR_VAR 0 1
16509: PUSH
16510: LD_VAR 0 1
16514: PPUSH
16515: LD_VAR 0 3
16519: PPUSH
16520: LD_VAR 0 5
16524: PPUSH
16525: CALL_OW 1
16529: ST_TO_ADDR
// result := list ;
16530: LD_ADDR_VAR 0 4
16534: PUSH
16535: LD_VAR 0 1
16539: ST_TO_ADDR
// end ;
16540: LD_VAR 0 4
16544: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16545: LD_INT 0
16547: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16548: LD_ADDR_VAR 0 5
16552: PUSH
16553: LD_VAR 0 1
16557: PPUSH
16558: CALL_OW 250
16562: PPUSH
16563: LD_VAR 0 1
16567: PPUSH
16568: CALL_OW 251
16572: PPUSH
16573: LD_VAR 0 2
16577: PPUSH
16578: LD_VAR 0 3
16582: PPUSH
16583: LD_VAR 0 4
16587: PPUSH
16588: CALL 16598 0 5
16592: ST_TO_ADDR
// end ;
16593: LD_VAR 0 5
16597: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16598: LD_INT 0
16600: PPUSH
16601: PPUSH
16602: PPUSH
16603: PPUSH
// if not list then
16604: LD_VAR 0 3
16608: NOT
16609: IFFALSE 16613
// exit ;
16611: GO 17001
// result := [ ] ;
16613: LD_ADDR_VAR 0 6
16617: PUSH
16618: EMPTY
16619: ST_TO_ADDR
// for i in list do
16620: LD_ADDR_VAR 0 7
16624: PUSH
16625: LD_VAR 0 3
16629: PUSH
16630: FOR_IN
16631: IFFALSE 16833
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16633: LD_ADDR_VAR 0 9
16637: PUSH
16638: LD_VAR 0 7
16642: PPUSH
16643: LD_VAR 0 1
16647: PPUSH
16648: LD_VAR 0 2
16652: PPUSH
16653: CALL_OW 297
16657: ST_TO_ADDR
// if not result then
16658: LD_VAR 0 6
16662: NOT
16663: IFFALSE 16689
// result := [ [ i , tmp ] ] else
16665: LD_ADDR_VAR 0 6
16669: PUSH
16670: LD_VAR 0 7
16674: PUSH
16675: LD_VAR 0 9
16679: PUSH
16680: EMPTY
16681: LIST
16682: LIST
16683: PUSH
16684: EMPTY
16685: LIST
16686: ST_TO_ADDR
16687: GO 16831
// begin if result [ result ] [ 2 ] < tmp then
16689: LD_VAR 0 6
16693: PUSH
16694: LD_VAR 0 6
16698: ARRAY
16699: PUSH
16700: LD_INT 2
16702: ARRAY
16703: PUSH
16704: LD_VAR 0 9
16708: LESS
16709: IFFALSE 16751
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16711: LD_ADDR_VAR 0 6
16715: PUSH
16716: LD_VAR 0 6
16720: PPUSH
16721: LD_VAR 0 6
16725: PUSH
16726: LD_INT 1
16728: PLUS
16729: PPUSH
16730: LD_VAR 0 7
16734: PUSH
16735: LD_VAR 0 9
16739: PUSH
16740: EMPTY
16741: LIST
16742: LIST
16743: PPUSH
16744: CALL_OW 2
16748: ST_TO_ADDR
16749: GO 16831
// for j = 1 to result do
16751: LD_ADDR_VAR 0 8
16755: PUSH
16756: DOUBLE
16757: LD_INT 1
16759: DEC
16760: ST_TO_ADDR
16761: LD_VAR 0 6
16765: PUSH
16766: FOR_TO
16767: IFFALSE 16829
// begin if tmp < result [ j ] [ 2 ] then
16769: LD_VAR 0 9
16773: PUSH
16774: LD_VAR 0 6
16778: PUSH
16779: LD_VAR 0 8
16783: ARRAY
16784: PUSH
16785: LD_INT 2
16787: ARRAY
16788: LESS
16789: IFFALSE 16827
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16791: LD_ADDR_VAR 0 6
16795: PUSH
16796: LD_VAR 0 6
16800: PPUSH
16801: LD_VAR 0 8
16805: PPUSH
16806: LD_VAR 0 7
16810: PUSH
16811: LD_VAR 0 9
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PPUSH
16820: CALL_OW 2
16824: ST_TO_ADDR
// break ;
16825: GO 16829
// end ; end ;
16827: GO 16766
16829: POP
16830: POP
// end ; end ;
16831: GO 16630
16833: POP
16834: POP
// if result and not asc then
16835: LD_VAR 0 6
16839: PUSH
16840: LD_VAR 0 4
16844: NOT
16845: AND
16846: IFFALSE 16921
// begin tmp := result ;
16848: LD_ADDR_VAR 0 9
16852: PUSH
16853: LD_VAR 0 6
16857: ST_TO_ADDR
// for i = tmp downto 1 do
16858: LD_ADDR_VAR 0 7
16862: PUSH
16863: DOUBLE
16864: LD_VAR 0 9
16868: INC
16869: ST_TO_ADDR
16870: LD_INT 1
16872: PUSH
16873: FOR_DOWNTO
16874: IFFALSE 16919
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16876: LD_ADDR_VAR 0 6
16880: PUSH
16881: LD_VAR 0 6
16885: PPUSH
16886: LD_VAR 0 9
16890: PUSH
16891: LD_VAR 0 7
16895: MINUS
16896: PUSH
16897: LD_INT 1
16899: PLUS
16900: PPUSH
16901: LD_VAR 0 9
16905: PUSH
16906: LD_VAR 0 7
16910: ARRAY
16911: PPUSH
16912: CALL_OW 1
16916: ST_TO_ADDR
16917: GO 16873
16919: POP
16920: POP
// end ; tmp := [ ] ;
16921: LD_ADDR_VAR 0 9
16925: PUSH
16926: EMPTY
16927: ST_TO_ADDR
// if mode then
16928: LD_VAR 0 5
16932: IFFALSE 17001
// begin for i = 1 to result do
16934: LD_ADDR_VAR 0 7
16938: PUSH
16939: DOUBLE
16940: LD_INT 1
16942: DEC
16943: ST_TO_ADDR
16944: LD_VAR 0 6
16948: PUSH
16949: FOR_TO
16950: IFFALSE 16989
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16952: LD_ADDR_VAR 0 9
16956: PUSH
16957: LD_VAR 0 9
16961: PPUSH
16962: LD_VAR 0 7
16966: PPUSH
16967: LD_VAR 0 6
16971: PUSH
16972: LD_VAR 0 7
16976: ARRAY
16977: PUSH
16978: LD_INT 1
16980: ARRAY
16981: PPUSH
16982: CALL_OW 1
16986: ST_TO_ADDR
16987: GO 16949
16989: POP
16990: POP
// result := tmp ;
16991: LD_ADDR_VAR 0 6
16995: PUSH
16996: LD_VAR 0 9
17000: ST_TO_ADDR
// end ; end ;
17001: LD_VAR 0 6
17005: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17006: LD_INT 0
17008: PPUSH
17009: PPUSH
17010: PPUSH
17011: PPUSH
17012: PPUSH
17013: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17014: LD_ADDR_VAR 0 5
17018: PUSH
17019: LD_INT 0
17021: PUSH
17022: LD_INT 0
17024: PUSH
17025: LD_INT 0
17027: PUSH
17028: EMPTY
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: ST_TO_ADDR
// if not x or not y then
17036: LD_VAR 0 2
17040: NOT
17041: PUSH
17042: LD_VAR 0 3
17046: NOT
17047: OR
17048: IFFALSE 17052
// exit ;
17050: GO 18702
// if not range then
17052: LD_VAR 0 4
17056: NOT
17057: IFFALSE 17067
// range := 10 ;
17059: LD_ADDR_VAR 0 4
17063: PUSH
17064: LD_INT 10
17066: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17067: LD_ADDR_VAR 0 8
17071: PUSH
17072: LD_INT 81
17074: PUSH
17075: LD_VAR 0 1
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PUSH
17084: LD_INT 92
17086: PUSH
17087: LD_VAR 0 2
17091: PUSH
17092: LD_VAR 0 3
17096: PUSH
17097: LD_VAR 0 4
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: PUSH
17108: LD_INT 3
17110: PUSH
17111: LD_INT 21
17113: PUSH
17114: LD_INT 3
17116: PUSH
17117: EMPTY
17118: LIST
17119: LIST
17120: PUSH
17121: EMPTY
17122: LIST
17123: LIST
17124: PUSH
17125: EMPTY
17126: LIST
17127: LIST
17128: LIST
17129: PPUSH
17130: CALL_OW 69
17134: ST_TO_ADDR
// if not tmp then
17135: LD_VAR 0 8
17139: NOT
17140: IFFALSE 17144
// exit ;
17142: GO 18702
// for i in tmp do
17144: LD_ADDR_VAR 0 6
17148: PUSH
17149: LD_VAR 0 8
17153: PUSH
17154: FOR_IN
17155: IFFALSE 18677
// begin points := [ 0 , 0 , 0 ] ;
17157: LD_ADDR_VAR 0 9
17161: PUSH
17162: LD_INT 0
17164: PUSH
17165: LD_INT 0
17167: PUSH
17168: LD_INT 0
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: LIST
17175: ST_TO_ADDR
// bpoints := 1 ;
17176: LD_ADDR_VAR 0 10
17180: PUSH
17181: LD_INT 1
17183: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17184: LD_VAR 0 6
17188: PPUSH
17189: CALL_OW 247
17193: PUSH
17194: LD_INT 1
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17202
17200: GO 17780
17202: POP
// begin if GetClass ( i ) = 1 then
17203: LD_VAR 0 6
17207: PPUSH
17208: CALL_OW 257
17212: PUSH
17213: LD_INT 1
17215: EQUAL
17216: IFFALSE 17237
// points := [ 10 , 5 , 3 ] ;
17218: LD_ADDR_VAR 0 9
17222: PUSH
17223: LD_INT 10
17225: PUSH
17226: LD_INT 5
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: LIST
17236: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17237: LD_VAR 0 6
17241: PPUSH
17242: CALL_OW 257
17246: PUSH
17247: LD_INT 2
17249: PUSH
17250: LD_INT 3
17252: PUSH
17253: LD_INT 4
17255: PUSH
17256: EMPTY
17257: LIST
17258: LIST
17259: LIST
17260: IN
17261: IFFALSE 17282
// points := [ 3 , 2 , 1 ] ;
17263: LD_ADDR_VAR 0 9
17267: PUSH
17268: LD_INT 3
17270: PUSH
17271: LD_INT 2
17273: PUSH
17274: LD_INT 1
17276: PUSH
17277: EMPTY
17278: LIST
17279: LIST
17280: LIST
17281: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17282: LD_VAR 0 6
17286: PPUSH
17287: CALL_OW 257
17291: PUSH
17292: LD_INT 5
17294: EQUAL
17295: IFFALSE 17316
// points := [ 130 , 5 , 2 ] ;
17297: LD_ADDR_VAR 0 9
17301: PUSH
17302: LD_INT 130
17304: PUSH
17305: LD_INT 5
17307: PUSH
17308: LD_INT 2
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17316: LD_VAR 0 6
17320: PPUSH
17321: CALL_OW 257
17325: PUSH
17326: LD_INT 8
17328: EQUAL
17329: IFFALSE 17350
// points := [ 35 , 35 , 30 ] ;
17331: LD_ADDR_VAR 0 9
17335: PUSH
17336: LD_INT 35
17338: PUSH
17339: LD_INT 35
17341: PUSH
17342: LD_INT 30
17344: PUSH
17345: EMPTY
17346: LIST
17347: LIST
17348: LIST
17349: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17350: LD_VAR 0 6
17354: PPUSH
17355: CALL_OW 257
17359: PUSH
17360: LD_INT 9
17362: EQUAL
17363: IFFALSE 17384
// points := [ 20 , 55 , 40 ] ;
17365: LD_ADDR_VAR 0 9
17369: PUSH
17370: LD_INT 20
17372: PUSH
17373: LD_INT 55
17375: PUSH
17376: LD_INT 40
17378: PUSH
17379: EMPTY
17380: LIST
17381: LIST
17382: LIST
17383: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17384: LD_VAR 0 6
17388: PPUSH
17389: CALL_OW 257
17393: PUSH
17394: LD_INT 12
17396: PUSH
17397: LD_INT 16
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: IN
17404: IFFALSE 17425
// points := [ 5 , 3 , 2 ] ;
17406: LD_ADDR_VAR 0 9
17410: PUSH
17411: LD_INT 5
17413: PUSH
17414: LD_INT 3
17416: PUSH
17417: LD_INT 2
17419: PUSH
17420: EMPTY
17421: LIST
17422: LIST
17423: LIST
17424: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17425: LD_VAR 0 6
17429: PPUSH
17430: CALL_OW 257
17434: PUSH
17435: LD_INT 17
17437: EQUAL
17438: IFFALSE 17459
// points := [ 100 , 50 , 75 ] ;
17440: LD_ADDR_VAR 0 9
17444: PUSH
17445: LD_INT 100
17447: PUSH
17448: LD_INT 50
17450: PUSH
17451: LD_INT 75
17453: PUSH
17454: EMPTY
17455: LIST
17456: LIST
17457: LIST
17458: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17459: LD_VAR 0 6
17463: PPUSH
17464: CALL_OW 257
17468: PUSH
17469: LD_INT 15
17471: EQUAL
17472: IFFALSE 17493
// points := [ 10 , 5 , 3 ] ;
17474: LD_ADDR_VAR 0 9
17478: PUSH
17479: LD_INT 10
17481: PUSH
17482: LD_INT 5
17484: PUSH
17485: LD_INT 3
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: LIST
17492: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17493: LD_VAR 0 6
17497: PPUSH
17498: CALL_OW 257
17502: PUSH
17503: LD_INT 14
17505: EQUAL
17506: IFFALSE 17527
// points := [ 10 , 0 , 0 ] ;
17508: LD_ADDR_VAR 0 9
17512: PUSH
17513: LD_INT 10
17515: PUSH
17516: LD_INT 0
17518: PUSH
17519: LD_INT 0
17521: PUSH
17522: EMPTY
17523: LIST
17524: LIST
17525: LIST
17526: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17527: LD_VAR 0 6
17531: PPUSH
17532: CALL_OW 257
17536: PUSH
17537: LD_INT 11
17539: EQUAL
17540: IFFALSE 17561
// points := [ 30 , 10 , 5 ] ;
17542: LD_ADDR_VAR 0 9
17546: PUSH
17547: LD_INT 30
17549: PUSH
17550: LD_INT 10
17552: PUSH
17553: LD_INT 5
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17561: LD_VAR 0 1
17565: PPUSH
17566: LD_INT 5
17568: PPUSH
17569: CALL_OW 321
17573: PUSH
17574: LD_INT 2
17576: EQUAL
17577: IFFALSE 17594
// bpoints := bpoints * 1.8 ;
17579: LD_ADDR_VAR 0 10
17583: PUSH
17584: LD_VAR 0 10
17588: PUSH
17589: LD_REAL  1.80000000000000E+0000
17592: MUL
17593: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17594: LD_VAR 0 6
17598: PPUSH
17599: CALL_OW 257
17603: PUSH
17604: LD_INT 1
17606: PUSH
17607: LD_INT 2
17609: PUSH
17610: LD_INT 3
17612: PUSH
17613: LD_INT 4
17615: PUSH
17616: EMPTY
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: IN
17622: PUSH
17623: LD_VAR 0 1
17627: PPUSH
17628: LD_INT 51
17630: PPUSH
17631: CALL_OW 321
17635: PUSH
17636: LD_INT 2
17638: EQUAL
17639: AND
17640: IFFALSE 17657
// bpoints := bpoints * 1.2 ;
17642: LD_ADDR_VAR 0 10
17646: PUSH
17647: LD_VAR 0 10
17651: PUSH
17652: LD_REAL  1.20000000000000E+0000
17655: MUL
17656: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17657: LD_VAR 0 6
17661: PPUSH
17662: CALL_OW 257
17666: PUSH
17667: LD_INT 5
17669: PUSH
17670: LD_INT 7
17672: PUSH
17673: LD_INT 9
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: LIST
17680: IN
17681: PUSH
17682: LD_VAR 0 1
17686: PPUSH
17687: LD_INT 52
17689: PPUSH
17690: CALL_OW 321
17694: PUSH
17695: LD_INT 2
17697: EQUAL
17698: AND
17699: IFFALSE 17716
// bpoints := bpoints * 1.5 ;
17701: LD_ADDR_VAR 0 10
17705: PUSH
17706: LD_VAR 0 10
17710: PUSH
17711: LD_REAL  1.50000000000000E+0000
17714: MUL
17715: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17716: LD_VAR 0 1
17720: PPUSH
17721: LD_INT 66
17723: PPUSH
17724: CALL_OW 321
17728: PUSH
17729: LD_INT 2
17731: EQUAL
17732: IFFALSE 17749
// bpoints := bpoints * 1.1 ;
17734: LD_ADDR_VAR 0 10
17738: PUSH
17739: LD_VAR 0 10
17743: PUSH
17744: LD_REAL  1.10000000000000E+0000
17747: MUL
17748: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17749: LD_ADDR_VAR 0 10
17753: PUSH
17754: LD_VAR 0 10
17758: PUSH
17759: LD_VAR 0 6
17763: PPUSH
17764: LD_INT 1
17766: PPUSH
17767: CALL_OW 259
17771: PUSH
17772: LD_REAL  1.15000000000000E+0000
17775: MUL
17776: MUL
17777: ST_TO_ADDR
// end ; unit_vehicle :
17778: GO 18606
17780: LD_INT 2
17782: DOUBLE
17783: EQUAL
17784: IFTRUE 17788
17786: GO 18594
17788: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17789: LD_VAR 0 6
17793: PPUSH
17794: CALL_OW 264
17798: PUSH
17799: LD_INT 2
17801: PUSH
17802: LD_INT 42
17804: PUSH
17805: LD_INT 24
17807: PUSH
17808: EMPTY
17809: LIST
17810: LIST
17811: LIST
17812: IN
17813: IFFALSE 17834
// points := [ 25 , 5 , 3 ] ;
17815: LD_ADDR_VAR 0 9
17819: PUSH
17820: LD_INT 25
17822: PUSH
17823: LD_INT 5
17825: PUSH
17826: LD_INT 3
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17834: LD_VAR 0 6
17838: PPUSH
17839: CALL_OW 264
17843: PUSH
17844: LD_INT 4
17846: PUSH
17847: LD_INT 43
17849: PUSH
17850: LD_INT 25
17852: PUSH
17853: EMPTY
17854: LIST
17855: LIST
17856: LIST
17857: IN
17858: IFFALSE 17879
// points := [ 40 , 15 , 5 ] ;
17860: LD_ADDR_VAR 0 9
17864: PUSH
17865: LD_INT 40
17867: PUSH
17868: LD_INT 15
17870: PUSH
17871: LD_INT 5
17873: PUSH
17874: EMPTY
17875: LIST
17876: LIST
17877: LIST
17878: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17879: LD_VAR 0 6
17883: PPUSH
17884: CALL_OW 264
17888: PUSH
17889: LD_INT 3
17891: PUSH
17892: LD_INT 23
17894: PUSH
17895: EMPTY
17896: LIST
17897: LIST
17898: IN
17899: IFFALSE 17920
// points := [ 7 , 25 , 8 ] ;
17901: LD_ADDR_VAR 0 9
17905: PUSH
17906: LD_INT 7
17908: PUSH
17909: LD_INT 25
17911: PUSH
17912: LD_INT 8
17914: PUSH
17915: EMPTY
17916: LIST
17917: LIST
17918: LIST
17919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17920: LD_VAR 0 6
17924: PPUSH
17925: CALL_OW 264
17929: PUSH
17930: LD_INT 5
17932: PUSH
17933: LD_INT 27
17935: PUSH
17936: LD_INT 44
17938: PUSH
17939: EMPTY
17940: LIST
17941: LIST
17942: LIST
17943: IN
17944: IFFALSE 17965
// points := [ 14 , 50 , 16 ] ;
17946: LD_ADDR_VAR 0 9
17950: PUSH
17951: LD_INT 14
17953: PUSH
17954: LD_INT 50
17956: PUSH
17957: LD_INT 16
17959: PUSH
17960: EMPTY
17961: LIST
17962: LIST
17963: LIST
17964: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17965: LD_VAR 0 6
17969: PPUSH
17970: CALL_OW 264
17974: PUSH
17975: LD_INT 6
17977: PUSH
17978: LD_INT 46
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: IN
17985: IFFALSE 18006
// points := [ 32 , 120 , 70 ] ;
17987: LD_ADDR_VAR 0 9
17991: PUSH
17992: LD_INT 32
17994: PUSH
17995: LD_INT 120
17997: PUSH
17998: LD_INT 70
18000: PUSH
18001: EMPTY
18002: LIST
18003: LIST
18004: LIST
18005: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18006: LD_VAR 0 6
18010: PPUSH
18011: CALL_OW 264
18015: PUSH
18016: LD_INT 7
18018: PUSH
18019: LD_INT 28
18021: PUSH
18022: LD_INT 45
18024: PUSH
18025: LD_INT 92
18027: PUSH
18028: EMPTY
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: IN
18034: IFFALSE 18055
// points := [ 35 , 20 , 45 ] ;
18036: LD_ADDR_VAR 0 9
18040: PUSH
18041: LD_INT 35
18043: PUSH
18044: LD_INT 20
18046: PUSH
18047: LD_INT 45
18049: PUSH
18050: EMPTY
18051: LIST
18052: LIST
18053: LIST
18054: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18055: LD_VAR 0 6
18059: PPUSH
18060: CALL_OW 264
18064: PUSH
18065: LD_INT 47
18067: PUSH
18068: EMPTY
18069: LIST
18070: IN
18071: IFFALSE 18092
// points := [ 67 , 45 , 75 ] ;
18073: LD_ADDR_VAR 0 9
18077: PUSH
18078: LD_INT 67
18080: PUSH
18081: LD_INT 45
18083: PUSH
18084: LD_INT 75
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18092: LD_VAR 0 6
18096: PPUSH
18097: CALL_OW 264
18101: PUSH
18102: LD_INT 26
18104: PUSH
18105: EMPTY
18106: LIST
18107: IN
18108: IFFALSE 18129
// points := [ 120 , 30 , 80 ] ;
18110: LD_ADDR_VAR 0 9
18114: PUSH
18115: LD_INT 120
18117: PUSH
18118: LD_INT 30
18120: PUSH
18121: LD_INT 80
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: LIST
18128: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18129: LD_VAR 0 6
18133: PPUSH
18134: CALL_OW 264
18138: PUSH
18139: LD_INT 22
18141: PUSH
18142: EMPTY
18143: LIST
18144: IN
18145: IFFALSE 18166
// points := [ 40 , 1 , 1 ] ;
18147: LD_ADDR_VAR 0 9
18151: PUSH
18152: LD_INT 40
18154: PUSH
18155: LD_INT 1
18157: PUSH
18158: LD_INT 1
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: LIST
18165: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18166: LD_VAR 0 6
18170: PPUSH
18171: CALL_OW 264
18175: PUSH
18176: LD_INT 29
18178: PUSH
18179: EMPTY
18180: LIST
18181: IN
18182: IFFALSE 18203
// points := [ 70 , 200 , 400 ] ;
18184: LD_ADDR_VAR 0 9
18188: PUSH
18189: LD_INT 70
18191: PUSH
18192: LD_INT 200
18194: PUSH
18195: LD_INT 400
18197: PUSH
18198: EMPTY
18199: LIST
18200: LIST
18201: LIST
18202: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18203: LD_VAR 0 6
18207: PPUSH
18208: CALL_OW 264
18212: PUSH
18213: LD_INT 14
18215: PUSH
18216: LD_INT 53
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: IN
18223: IFFALSE 18244
// points := [ 40 , 10 , 20 ] ;
18225: LD_ADDR_VAR 0 9
18229: PUSH
18230: LD_INT 40
18232: PUSH
18233: LD_INT 10
18235: PUSH
18236: LD_INT 20
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: LIST
18243: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18244: LD_VAR 0 6
18248: PPUSH
18249: CALL_OW 264
18253: PUSH
18254: LD_INT 9
18256: PUSH
18257: EMPTY
18258: LIST
18259: IN
18260: IFFALSE 18281
// points := [ 5 , 70 , 20 ] ;
18262: LD_ADDR_VAR 0 9
18266: PUSH
18267: LD_INT 5
18269: PUSH
18270: LD_INT 70
18272: PUSH
18273: LD_INT 20
18275: PUSH
18276: EMPTY
18277: LIST
18278: LIST
18279: LIST
18280: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18281: LD_VAR 0 6
18285: PPUSH
18286: CALL_OW 264
18290: PUSH
18291: LD_INT 10
18293: PUSH
18294: EMPTY
18295: LIST
18296: IN
18297: IFFALSE 18318
// points := [ 35 , 110 , 70 ] ;
18299: LD_ADDR_VAR 0 9
18303: PUSH
18304: LD_INT 35
18306: PUSH
18307: LD_INT 110
18309: PUSH
18310: LD_INT 70
18312: PUSH
18313: EMPTY
18314: LIST
18315: LIST
18316: LIST
18317: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18318: LD_VAR 0 6
18322: PPUSH
18323: CALL_OW 265
18327: PUSH
18328: LD_INT 25
18330: EQUAL
18331: IFFALSE 18352
// points := [ 80 , 65 , 100 ] ;
18333: LD_ADDR_VAR 0 9
18337: PUSH
18338: LD_INT 80
18340: PUSH
18341: LD_INT 65
18343: PUSH
18344: LD_INT 100
18346: PUSH
18347: EMPTY
18348: LIST
18349: LIST
18350: LIST
18351: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18352: LD_VAR 0 6
18356: PPUSH
18357: CALL_OW 263
18361: PUSH
18362: LD_INT 1
18364: EQUAL
18365: IFFALSE 18400
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18367: LD_ADDR_VAR 0 10
18371: PUSH
18372: LD_VAR 0 10
18376: PUSH
18377: LD_VAR 0 6
18381: PPUSH
18382: CALL_OW 311
18386: PPUSH
18387: LD_INT 3
18389: PPUSH
18390: CALL_OW 259
18394: PUSH
18395: LD_INT 4
18397: MUL
18398: MUL
18399: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18400: LD_VAR 0 6
18404: PPUSH
18405: CALL_OW 263
18409: PUSH
18410: LD_INT 2
18412: EQUAL
18413: IFFALSE 18464
// begin j := IsControledBy ( i ) ;
18415: LD_ADDR_VAR 0 7
18419: PUSH
18420: LD_VAR 0 6
18424: PPUSH
18425: CALL_OW 312
18429: ST_TO_ADDR
// if j then
18430: LD_VAR 0 7
18434: IFFALSE 18464
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18436: LD_ADDR_VAR 0 10
18440: PUSH
18441: LD_VAR 0 10
18445: PUSH
18446: LD_VAR 0 7
18450: PPUSH
18451: LD_INT 3
18453: PPUSH
18454: CALL_OW 259
18458: PUSH
18459: LD_INT 3
18461: MUL
18462: MUL
18463: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18464: LD_VAR 0 6
18468: PPUSH
18469: CALL_OW 264
18473: PUSH
18474: LD_INT 5
18476: PUSH
18477: LD_INT 6
18479: PUSH
18480: LD_INT 46
18482: PUSH
18483: LD_INT 44
18485: PUSH
18486: LD_INT 47
18488: PUSH
18489: LD_INT 45
18491: PUSH
18492: LD_INT 28
18494: PUSH
18495: LD_INT 7
18497: PUSH
18498: LD_INT 27
18500: PUSH
18501: LD_INT 29
18503: PUSH
18504: EMPTY
18505: LIST
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: LIST
18511: LIST
18512: LIST
18513: LIST
18514: LIST
18515: IN
18516: PUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: LD_INT 52
18524: PPUSH
18525: CALL_OW 321
18529: PUSH
18530: LD_INT 2
18532: EQUAL
18533: AND
18534: IFFALSE 18551
// bpoints := bpoints * 1.2 ;
18536: LD_ADDR_VAR 0 10
18540: PUSH
18541: LD_VAR 0 10
18545: PUSH
18546: LD_REAL  1.20000000000000E+0000
18549: MUL
18550: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18551: LD_VAR 0 6
18555: PPUSH
18556: CALL_OW 264
18560: PUSH
18561: LD_INT 6
18563: PUSH
18564: LD_INT 46
18566: PUSH
18567: LD_INT 47
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: LIST
18574: IN
18575: IFFALSE 18592
// bpoints := bpoints * 1.2 ;
18577: LD_ADDR_VAR 0 10
18581: PUSH
18582: LD_VAR 0 10
18586: PUSH
18587: LD_REAL  1.20000000000000E+0000
18590: MUL
18591: ST_TO_ADDR
// end ; unit_building :
18592: GO 18606
18594: LD_INT 3
18596: DOUBLE
18597: EQUAL
18598: IFTRUE 18602
18600: GO 18605
18602: POP
// ; end ;
18603: GO 18606
18605: POP
// for j = 1 to 3 do
18606: LD_ADDR_VAR 0 7
18610: PUSH
18611: DOUBLE
18612: LD_INT 1
18614: DEC
18615: ST_TO_ADDR
18616: LD_INT 3
18618: PUSH
18619: FOR_TO
18620: IFFALSE 18673
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18622: LD_ADDR_VAR 0 5
18626: PUSH
18627: LD_VAR 0 5
18631: PPUSH
18632: LD_VAR 0 7
18636: PPUSH
18637: LD_VAR 0 5
18641: PUSH
18642: LD_VAR 0 7
18646: ARRAY
18647: PUSH
18648: LD_VAR 0 9
18652: PUSH
18653: LD_VAR 0 7
18657: ARRAY
18658: PUSH
18659: LD_VAR 0 10
18663: MUL
18664: PLUS
18665: PPUSH
18666: CALL_OW 1
18670: ST_TO_ADDR
18671: GO 18619
18673: POP
18674: POP
// end ;
18675: GO 17154
18677: POP
18678: POP
// result := Replace ( result , 4 , tmp ) ;
18679: LD_ADDR_VAR 0 5
18683: PUSH
18684: LD_VAR 0 5
18688: PPUSH
18689: LD_INT 4
18691: PPUSH
18692: LD_VAR 0 8
18696: PPUSH
18697: CALL_OW 1
18701: ST_TO_ADDR
// end ;
18702: LD_VAR 0 5
18706: RET
// export function DangerAtRange ( unit , range ) ; begin
18707: LD_INT 0
18709: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18710: LD_ADDR_VAR 0 3
18714: PUSH
18715: LD_VAR 0 1
18719: PPUSH
18720: CALL_OW 255
18724: PPUSH
18725: LD_VAR 0 1
18729: PPUSH
18730: CALL_OW 250
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: CALL_OW 251
18744: PPUSH
18745: LD_VAR 0 2
18749: PPUSH
18750: CALL 17006 0 4
18754: ST_TO_ADDR
// end ;
18755: LD_VAR 0 3
18759: RET
// export function DangerInArea ( side , area ) ; begin
18760: LD_INT 0
18762: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18763: LD_ADDR_VAR 0 3
18767: PUSH
18768: LD_VAR 0 2
18772: PPUSH
18773: LD_INT 81
18775: PUSH
18776: LD_VAR 0 1
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: PPUSH
18785: CALL_OW 70
18789: ST_TO_ADDR
// end ;
18790: LD_VAR 0 3
18794: RET
// export function IsExtension ( b ) ; begin
18795: LD_INT 0
18797: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18798: LD_ADDR_VAR 0 2
18802: PUSH
18803: LD_VAR 0 1
18807: PUSH
18808: LD_INT 23
18810: PUSH
18811: LD_INT 20
18813: PUSH
18814: LD_INT 22
18816: PUSH
18817: LD_INT 17
18819: PUSH
18820: LD_INT 24
18822: PUSH
18823: LD_INT 21
18825: PUSH
18826: LD_INT 19
18828: PUSH
18829: LD_INT 16
18831: PUSH
18832: LD_INT 25
18834: PUSH
18835: LD_INT 18
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: LIST
18842: LIST
18843: LIST
18844: LIST
18845: LIST
18846: LIST
18847: LIST
18848: LIST
18849: IN
18850: ST_TO_ADDR
// end ;
18851: LD_VAR 0 2
18855: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18856: LD_INT 0
18858: PPUSH
18859: PPUSH
18860: PPUSH
// result := [ ] ;
18861: LD_ADDR_VAR 0 4
18865: PUSH
18866: EMPTY
18867: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18868: LD_ADDR_VAR 0 5
18872: PUSH
18873: LD_VAR 0 2
18877: PPUSH
18878: LD_INT 21
18880: PUSH
18881: LD_INT 3
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: PPUSH
18888: CALL_OW 70
18892: ST_TO_ADDR
// if not tmp then
18893: LD_VAR 0 5
18897: NOT
18898: IFFALSE 18902
// exit ;
18900: GO 18966
// if checkLink then
18902: LD_VAR 0 3
18906: IFFALSE 18956
// begin for i in tmp do
18908: LD_ADDR_VAR 0 6
18912: PUSH
18913: LD_VAR 0 5
18917: PUSH
18918: FOR_IN
18919: IFFALSE 18954
// if GetBase ( i ) <> base then
18921: LD_VAR 0 6
18925: PPUSH
18926: CALL_OW 274
18930: PUSH
18931: LD_VAR 0 1
18935: NONEQUAL
18936: IFFALSE 18952
// ComLinkToBase ( base , i ) ;
18938: LD_VAR 0 1
18942: PPUSH
18943: LD_VAR 0 6
18947: PPUSH
18948: CALL_OW 169
18952: GO 18918
18954: POP
18955: POP
// end ; result := tmp ;
18956: LD_ADDR_VAR 0 4
18960: PUSH
18961: LD_VAR 0 5
18965: ST_TO_ADDR
// end ;
18966: LD_VAR 0 4
18970: RET
// export function ComComplete ( units , b ) ; var i ; begin
18971: LD_INT 0
18973: PPUSH
18974: PPUSH
// if not units then
18975: LD_VAR 0 1
18979: NOT
18980: IFFALSE 18984
// exit ;
18982: GO 19074
// for i in units do
18984: LD_ADDR_VAR 0 4
18988: PUSH
18989: LD_VAR 0 1
18993: PUSH
18994: FOR_IN
18995: IFFALSE 19072
// if BuildingStatus ( b ) = bs_build then
18997: LD_VAR 0 2
19001: PPUSH
19002: CALL_OW 461
19006: PUSH
19007: LD_INT 1
19009: EQUAL
19010: IFFALSE 19070
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19012: LD_VAR 0 4
19016: PPUSH
19017: LD_STRING h
19019: PUSH
19020: LD_VAR 0 2
19024: PPUSH
19025: CALL_OW 250
19029: PUSH
19030: LD_VAR 0 2
19034: PPUSH
19035: CALL_OW 251
19039: PUSH
19040: LD_VAR 0 2
19044: PUSH
19045: LD_INT 0
19047: PUSH
19048: LD_INT 0
19050: PUSH
19051: LD_INT 0
19053: PUSH
19054: EMPTY
19055: LIST
19056: LIST
19057: LIST
19058: LIST
19059: LIST
19060: LIST
19061: LIST
19062: PUSH
19063: EMPTY
19064: LIST
19065: PPUSH
19066: CALL_OW 446
19070: GO 18994
19072: POP
19073: POP
// end ;
19074: LD_VAR 0 3
19078: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19079: LD_INT 0
19081: PPUSH
19082: PPUSH
19083: PPUSH
19084: PPUSH
19085: PPUSH
19086: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19087: LD_VAR 0 1
19091: NOT
19092: PUSH
19093: LD_VAR 0 1
19097: PPUSH
19098: CALL_OW 263
19102: PUSH
19103: LD_INT 2
19105: NONEQUAL
19106: OR
19107: IFFALSE 19111
// exit ;
19109: GO 19427
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19111: LD_ADDR_VAR 0 6
19115: PUSH
19116: LD_INT 22
19118: PUSH
19119: LD_VAR 0 1
19123: PPUSH
19124: CALL_OW 255
19128: PUSH
19129: EMPTY
19130: LIST
19131: LIST
19132: PUSH
19133: LD_INT 2
19135: PUSH
19136: LD_INT 30
19138: PUSH
19139: LD_INT 36
19141: PUSH
19142: EMPTY
19143: LIST
19144: LIST
19145: PUSH
19146: LD_INT 34
19148: PUSH
19149: LD_INT 31
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: PUSH
19156: EMPTY
19157: LIST
19158: LIST
19159: LIST
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PPUSH
19165: CALL_OW 69
19169: ST_TO_ADDR
// if not tmp then
19170: LD_VAR 0 6
19174: NOT
19175: IFFALSE 19179
// exit ;
19177: GO 19427
// result := [ ] ;
19179: LD_ADDR_VAR 0 2
19183: PUSH
19184: EMPTY
19185: ST_TO_ADDR
// for i in tmp do
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 6
19195: PUSH
19196: FOR_IN
19197: IFFALSE 19268
// begin t := UnitsInside ( i ) ;
19199: LD_ADDR_VAR 0 4
19203: PUSH
19204: LD_VAR 0 3
19208: PPUSH
19209: CALL_OW 313
19213: ST_TO_ADDR
// if t then
19214: LD_VAR 0 4
19218: IFFALSE 19266
// for j in t do
19220: LD_ADDR_VAR 0 7
19224: PUSH
19225: LD_VAR 0 4
19229: PUSH
19230: FOR_IN
19231: IFFALSE 19264
// result := Replace ( result , result + 1 , j ) ;
19233: LD_ADDR_VAR 0 2
19237: PUSH
19238: LD_VAR 0 2
19242: PPUSH
19243: LD_VAR 0 2
19247: PUSH
19248: LD_INT 1
19250: PLUS
19251: PPUSH
19252: LD_VAR 0 7
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
19262: GO 19230
19264: POP
19265: POP
// end ;
19266: GO 19196
19268: POP
19269: POP
// if not result then
19270: LD_VAR 0 2
19274: NOT
19275: IFFALSE 19279
// exit ;
19277: GO 19427
// mech := result [ 1 ] ;
19279: LD_ADDR_VAR 0 5
19283: PUSH
19284: LD_VAR 0 2
19288: PUSH
19289: LD_INT 1
19291: ARRAY
19292: ST_TO_ADDR
// if result > 1 then
19293: LD_VAR 0 2
19297: PUSH
19298: LD_INT 1
19300: GREATER
19301: IFFALSE 19413
// begin for i = 2 to result do
19303: LD_ADDR_VAR 0 3
19307: PUSH
19308: DOUBLE
19309: LD_INT 2
19311: DEC
19312: ST_TO_ADDR
19313: LD_VAR 0 2
19317: PUSH
19318: FOR_TO
19319: IFFALSE 19411
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19321: LD_ADDR_VAR 0 4
19325: PUSH
19326: LD_VAR 0 2
19330: PUSH
19331: LD_VAR 0 3
19335: ARRAY
19336: PPUSH
19337: LD_INT 3
19339: PPUSH
19340: CALL_OW 259
19344: PUSH
19345: LD_VAR 0 2
19349: PUSH
19350: LD_VAR 0 3
19354: ARRAY
19355: PPUSH
19356: CALL_OW 432
19360: MINUS
19361: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19362: LD_VAR 0 4
19366: PUSH
19367: LD_VAR 0 5
19371: PPUSH
19372: LD_INT 3
19374: PPUSH
19375: CALL_OW 259
19379: PUSH
19380: LD_VAR 0 5
19384: PPUSH
19385: CALL_OW 432
19389: MINUS
19390: GREATEREQUAL
19391: IFFALSE 19409
// mech := result [ i ] ;
19393: LD_ADDR_VAR 0 5
19397: PUSH
19398: LD_VAR 0 2
19402: PUSH
19403: LD_VAR 0 3
19407: ARRAY
19408: ST_TO_ADDR
// end ;
19409: GO 19318
19411: POP
19412: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19413: LD_VAR 0 1
19417: PPUSH
19418: LD_VAR 0 5
19422: PPUSH
19423: CALL_OW 135
// end ;
19427: LD_VAR 0 2
19431: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19432: LD_INT 0
19434: PPUSH
19435: PPUSH
19436: PPUSH
19437: PPUSH
19438: PPUSH
19439: PPUSH
19440: PPUSH
19441: PPUSH
19442: PPUSH
19443: PPUSH
19444: PPUSH
19445: PPUSH
19446: PPUSH
// result := [ ] ;
19447: LD_ADDR_VAR 0 7
19451: PUSH
19452: EMPTY
19453: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19454: LD_VAR 0 1
19458: PPUSH
19459: CALL_OW 266
19463: PUSH
19464: LD_INT 0
19466: PUSH
19467: LD_INT 1
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: IN
19474: NOT
19475: IFFALSE 19479
// exit ;
19477: GO 21113
// if name then
19479: LD_VAR 0 3
19483: IFFALSE 19499
// SetBName ( base_dep , name ) ;
19485: LD_VAR 0 1
19489: PPUSH
19490: LD_VAR 0 3
19494: PPUSH
19495: CALL_OW 500
// base := GetBase ( base_dep ) ;
19499: LD_ADDR_VAR 0 15
19503: PUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: CALL_OW 274
19513: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19514: LD_ADDR_VAR 0 16
19518: PUSH
19519: LD_VAR 0 1
19523: PPUSH
19524: CALL_OW 255
19528: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19529: LD_ADDR_VAR 0 17
19533: PUSH
19534: LD_VAR 0 1
19538: PPUSH
19539: CALL_OW 248
19543: ST_TO_ADDR
// if sources then
19544: LD_VAR 0 5
19548: IFFALSE 19595
// for i = 1 to 3 do
19550: LD_ADDR_VAR 0 8
19554: PUSH
19555: DOUBLE
19556: LD_INT 1
19558: DEC
19559: ST_TO_ADDR
19560: LD_INT 3
19562: PUSH
19563: FOR_TO
19564: IFFALSE 19593
// AddResourceType ( base , i , sources [ i ] ) ;
19566: LD_VAR 0 15
19570: PPUSH
19571: LD_VAR 0 8
19575: PPUSH
19576: LD_VAR 0 5
19580: PUSH
19581: LD_VAR 0 8
19585: ARRAY
19586: PPUSH
19587: CALL_OW 276
19591: GO 19563
19593: POP
19594: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19595: LD_ADDR_VAR 0 18
19599: PUSH
19600: LD_VAR 0 15
19604: PPUSH
19605: LD_VAR 0 2
19609: PPUSH
19610: LD_INT 1
19612: PPUSH
19613: CALL 18856 0 3
19617: ST_TO_ADDR
// InitHc ;
19618: CALL_OW 19
// InitUc ;
19622: CALL_OW 18
// uc_side := side ;
19626: LD_ADDR_OWVAR 20
19630: PUSH
19631: LD_VAR 0 16
19635: ST_TO_ADDR
// uc_nation := nation ;
19636: LD_ADDR_OWVAR 21
19640: PUSH
19641: LD_VAR 0 17
19645: ST_TO_ADDR
// if buildings then
19646: LD_VAR 0 18
19650: IFFALSE 20972
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19652: LD_ADDR_VAR 0 19
19656: PUSH
19657: LD_VAR 0 18
19661: PPUSH
19662: LD_INT 2
19664: PUSH
19665: LD_INT 30
19667: PUSH
19668: LD_INT 29
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: PUSH
19675: LD_INT 30
19677: PUSH
19678: LD_INT 30
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: PUSH
19685: EMPTY
19686: LIST
19687: LIST
19688: LIST
19689: PPUSH
19690: CALL_OW 72
19694: ST_TO_ADDR
// if tmp then
19695: LD_VAR 0 19
19699: IFFALSE 19747
// for i in tmp do
19701: LD_ADDR_VAR 0 8
19705: PUSH
19706: LD_VAR 0 19
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19745
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 250
19723: PPUSH
19724: LD_VAR 0 8
19728: PPUSH
19729: CALL_OW 251
19733: PPUSH
19734: LD_VAR 0 16
19738: PPUSH
19739: CALL_OW 441
19743: GO 19711
19745: POP
19746: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19747: LD_VAR 0 18
19751: PPUSH
19752: LD_INT 2
19754: PUSH
19755: LD_INT 30
19757: PUSH
19758: LD_INT 32
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: PUSH
19765: LD_INT 30
19767: PUSH
19768: LD_INT 33
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: PUSH
19775: EMPTY
19776: LIST
19777: LIST
19778: LIST
19779: PPUSH
19780: CALL_OW 72
19784: IFFALSE 19872
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19786: LD_ADDR_VAR 0 8
19790: PUSH
19791: LD_VAR 0 18
19795: PPUSH
19796: LD_INT 2
19798: PUSH
19799: LD_INT 30
19801: PUSH
19802: LD_INT 32
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: PUSH
19809: LD_INT 30
19811: PUSH
19812: LD_INT 33
19814: PUSH
19815: EMPTY
19816: LIST
19817: LIST
19818: PUSH
19819: EMPTY
19820: LIST
19821: LIST
19822: LIST
19823: PPUSH
19824: CALL_OW 72
19828: PUSH
19829: FOR_IN
19830: IFFALSE 19870
// begin if not GetBWeapon ( i ) then
19832: LD_VAR 0 8
19836: PPUSH
19837: CALL_OW 269
19841: NOT
19842: IFFALSE 19868
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19844: LD_VAR 0 8
19848: PPUSH
19849: LD_VAR 0 8
19853: PPUSH
19854: LD_VAR 0 2
19858: PPUSH
19859: CALL 21118 0 2
19863: PPUSH
19864: CALL_OW 431
// end ;
19868: GO 19829
19870: POP
19871: POP
// end ; for i = 1 to personel do
19872: LD_ADDR_VAR 0 8
19876: PUSH
19877: DOUBLE
19878: LD_INT 1
19880: DEC
19881: ST_TO_ADDR
19882: LD_VAR 0 6
19886: PUSH
19887: FOR_TO
19888: IFFALSE 20952
// begin if i > 4 then
19890: LD_VAR 0 8
19894: PUSH
19895: LD_INT 4
19897: GREATER
19898: IFFALSE 19902
// break ;
19900: GO 20952
// case i of 1 :
19902: LD_VAR 0 8
19906: PUSH
19907: LD_INT 1
19909: DOUBLE
19910: EQUAL
19911: IFTRUE 19915
19913: GO 19995
19915: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19916: LD_ADDR_VAR 0 12
19920: PUSH
19921: LD_VAR 0 18
19925: PPUSH
19926: LD_INT 22
19928: PUSH
19929: LD_VAR 0 16
19933: PUSH
19934: EMPTY
19935: LIST
19936: LIST
19937: PUSH
19938: LD_INT 58
19940: PUSH
19941: EMPTY
19942: LIST
19943: PUSH
19944: LD_INT 2
19946: PUSH
19947: LD_INT 30
19949: PUSH
19950: LD_INT 32
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: LD_INT 30
19959: PUSH
19960: LD_INT 4
19962: PUSH
19963: EMPTY
19964: LIST
19965: LIST
19966: PUSH
19967: LD_INT 30
19969: PUSH
19970: LD_INT 5
19972: PUSH
19973: EMPTY
19974: LIST
19975: LIST
19976: PUSH
19977: EMPTY
19978: LIST
19979: LIST
19980: LIST
19981: LIST
19982: PUSH
19983: EMPTY
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL_OW 72
19992: ST_TO_ADDR
19993: GO 20217
19995: LD_INT 2
19997: DOUBLE
19998: EQUAL
19999: IFTRUE 20003
20001: GO 20065
20003: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20004: LD_ADDR_VAR 0 12
20008: PUSH
20009: LD_VAR 0 18
20013: PPUSH
20014: LD_INT 22
20016: PUSH
20017: LD_VAR 0 16
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 2
20028: PUSH
20029: LD_INT 30
20031: PUSH
20032: LD_INT 0
20034: PUSH
20035: EMPTY
20036: LIST
20037: LIST
20038: PUSH
20039: LD_INT 30
20041: PUSH
20042: LD_INT 1
20044: PUSH
20045: EMPTY
20046: LIST
20047: LIST
20048: PUSH
20049: EMPTY
20050: LIST
20051: LIST
20052: LIST
20053: PUSH
20054: EMPTY
20055: LIST
20056: LIST
20057: PPUSH
20058: CALL_OW 72
20062: ST_TO_ADDR
20063: GO 20217
20065: LD_INT 3
20067: DOUBLE
20068: EQUAL
20069: IFTRUE 20073
20071: GO 20135
20073: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20074: LD_ADDR_VAR 0 12
20078: PUSH
20079: LD_VAR 0 18
20083: PPUSH
20084: LD_INT 22
20086: PUSH
20087: LD_VAR 0 16
20091: PUSH
20092: EMPTY
20093: LIST
20094: LIST
20095: PUSH
20096: LD_INT 2
20098: PUSH
20099: LD_INT 30
20101: PUSH
20102: LD_INT 2
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: LD_INT 30
20111: PUSH
20112: LD_INT 3
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: PUSH
20119: EMPTY
20120: LIST
20121: LIST
20122: LIST
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PPUSH
20128: CALL_OW 72
20132: ST_TO_ADDR
20133: GO 20217
20135: LD_INT 4
20137: DOUBLE
20138: EQUAL
20139: IFTRUE 20143
20141: GO 20216
20143: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20144: LD_ADDR_VAR 0 12
20148: PUSH
20149: LD_VAR 0 18
20153: PPUSH
20154: LD_INT 22
20156: PUSH
20157: LD_VAR 0 16
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: LD_INT 2
20168: PUSH
20169: LD_INT 30
20171: PUSH
20172: LD_INT 6
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: PUSH
20179: LD_INT 30
20181: PUSH
20182: LD_INT 7
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: LD_INT 30
20191: PUSH
20192: LD_INT 8
20194: PUSH
20195: EMPTY
20196: LIST
20197: LIST
20198: PUSH
20199: EMPTY
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: PUSH
20205: EMPTY
20206: LIST
20207: LIST
20208: PPUSH
20209: CALL_OW 72
20213: ST_TO_ADDR
20214: GO 20217
20216: POP
// if i = 1 then
20217: LD_VAR 0 8
20221: PUSH
20222: LD_INT 1
20224: EQUAL
20225: IFFALSE 20336
// begin tmp := [ ] ;
20227: LD_ADDR_VAR 0 19
20231: PUSH
20232: EMPTY
20233: ST_TO_ADDR
// for j in f do
20234: LD_ADDR_VAR 0 9
20238: PUSH
20239: LD_VAR 0 12
20243: PUSH
20244: FOR_IN
20245: IFFALSE 20318
// if GetBType ( j ) = b_bunker then
20247: LD_VAR 0 9
20251: PPUSH
20252: CALL_OW 266
20256: PUSH
20257: LD_INT 32
20259: EQUAL
20260: IFFALSE 20287
// tmp := Insert ( tmp , 1 , j ) else
20262: LD_ADDR_VAR 0 19
20266: PUSH
20267: LD_VAR 0 19
20271: PPUSH
20272: LD_INT 1
20274: PPUSH
20275: LD_VAR 0 9
20279: PPUSH
20280: CALL_OW 2
20284: ST_TO_ADDR
20285: GO 20316
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20287: LD_ADDR_VAR 0 19
20291: PUSH
20292: LD_VAR 0 19
20296: PPUSH
20297: LD_VAR 0 19
20301: PUSH
20302: LD_INT 1
20304: PLUS
20305: PPUSH
20306: LD_VAR 0 9
20310: PPUSH
20311: CALL_OW 2
20315: ST_TO_ADDR
20316: GO 20244
20318: POP
20319: POP
// if tmp then
20320: LD_VAR 0 19
20324: IFFALSE 20336
// f := tmp ;
20326: LD_ADDR_VAR 0 12
20330: PUSH
20331: LD_VAR 0 19
20335: ST_TO_ADDR
// end ; x := personel [ i ] ;
20336: LD_ADDR_VAR 0 13
20340: PUSH
20341: LD_VAR 0 6
20345: PUSH
20346: LD_VAR 0 8
20350: ARRAY
20351: ST_TO_ADDR
// if x = - 1 then
20352: LD_VAR 0 13
20356: PUSH
20357: LD_INT 1
20359: NEG
20360: EQUAL
20361: IFFALSE 20570
// begin for j in f do
20363: LD_ADDR_VAR 0 9
20367: PUSH
20368: LD_VAR 0 12
20372: PUSH
20373: FOR_IN
20374: IFFALSE 20566
// repeat InitHc ;
20376: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20380: LD_VAR 0 9
20384: PPUSH
20385: CALL_OW 266
20389: PUSH
20390: LD_INT 5
20392: EQUAL
20393: IFFALSE 20463
// begin if UnitsInside ( j ) < 3 then
20395: LD_VAR 0 9
20399: PPUSH
20400: CALL_OW 313
20404: PUSH
20405: LD_INT 3
20407: LESS
20408: IFFALSE 20444
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20410: LD_INT 0
20412: PPUSH
20413: LD_INT 5
20415: PUSH
20416: LD_INT 8
20418: PUSH
20419: LD_INT 9
20421: PUSH
20422: EMPTY
20423: LIST
20424: LIST
20425: LIST
20426: PUSH
20427: LD_VAR 0 17
20431: ARRAY
20432: PPUSH
20433: LD_VAR 0 4
20437: PPUSH
20438: CALL_OW 380
20442: GO 20461
// PrepareHuman ( false , i , skill ) ;
20444: LD_INT 0
20446: PPUSH
20447: LD_VAR 0 8
20451: PPUSH
20452: LD_VAR 0 4
20456: PPUSH
20457: CALL_OW 380
// end else
20461: GO 20480
// PrepareHuman ( false , i , skill ) ;
20463: LD_INT 0
20465: PPUSH
20466: LD_VAR 0 8
20470: PPUSH
20471: LD_VAR 0 4
20475: PPUSH
20476: CALL_OW 380
// un := CreateHuman ;
20480: LD_ADDR_VAR 0 14
20484: PUSH
20485: CALL_OW 44
20489: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20490: LD_ADDR_VAR 0 7
20494: PUSH
20495: LD_VAR 0 7
20499: PPUSH
20500: LD_INT 1
20502: PPUSH
20503: LD_VAR 0 14
20507: PPUSH
20508: CALL_OW 2
20512: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20513: LD_VAR 0 14
20517: PPUSH
20518: LD_VAR 0 9
20522: PPUSH
20523: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20527: LD_VAR 0 9
20531: PPUSH
20532: CALL_OW 313
20536: PUSH
20537: LD_INT 6
20539: EQUAL
20540: PUSH
20541: LD_VAR 0 9
20545: PPUSH
20546: CALL_OW 266
20550: PUSH
20551: LD_INT 32
20553: PUSH
20554: LD_INT 31
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: IN
20561: OR
20562: IFFALSE 20376
20564: GO 20373
20566: POP
20567: POP
// end else
20568: GO 20950
// for j = 1 to x do
20570: LD_ADDR_VAR 0 9
20574: PUSH
20575: DOUBLE
20576: LD_INT 1
20578: DEC
20579: ST_TO_ADDR
20580: LD_VAR 0 13
20584: PUSH
20585: FOR_TO
20586: IFFALSE 20948
// begin InitHc ;
20588: CALL_OW 19
// if not f then
20592: LD_VAR 0 12
20596: NOT
20597: IFFALSE 20686
// begin PrepareHuman ( false , i , skill ) ;
20599: LD_INT 0
20601: PPUSH
20602: LD_VAR 0 8
20606: PPUSH
20607: LD_VAR 0 4
20611: PPUSH
20612: CALL_OW 380
// un := CreateHuman ;
20616: LD_ADDR_VAR 0 14
20620: PUSH
20621: CALL_OW 44
20625: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20626: LD_ADDR_VAR 0 7
20630: PUSH
20631: LD_VAR 0 7
20635: PPUSH
20636: LD_INT 1
20638: PPUSH
20639: LD_VAR 0 14
20643: PPUSH
20644: CALL_OW 2
20648: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20649: LD_VAR 0 14
20653: PPUSH
20654: LD_VAR 0 1
20658: PPUSH
20659: CALL_OW 250
20663: PPUSH
20664: LD_VAR 0 1
20668: PPUSH
20669: CALL_OW 251
20673: PPUSH
20674: LD_INT 10
20676: PPUSH
20677: LD_INT 0
20679: PPUSH
20680: CALL_OW 50
// continue ;
20684: GO 20585
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20686: LD_VAR 0 12
20690: PUSH
20691: LD_INT 1
20693: ARRAY
20694: PPUSH
20695: CALL_OW 313
20699: PUSH
20700: LD_VAR 0 12
20704: PUSH
20705: LD_INT 1
20707: ARRAY
20708: PPUSH
20709: CALL_OW 266
20713: PUSH
20714: LD_INT 32
20716: PUSH
20717: LD_INT 31
20719: PUSH
20720: EMPTY
20721: LIST
20722: LIST
20723: IN
20724: AND
20725: PUSH
20726: LD_VAR 0 12
20730: PUSH
20731: LD_INT 1
20733: ARRAY
20734: PPUSH
20735: CALL_OW 313
20739: PUSH
20740: LD_INT 6
20742: EQUAL
20743: OR
20744: IFFALSE 20764
// f := Delete ( f , 1 ) ;
20746: LD_ADDR_VAR 0 12
20750: PUSH
20751: LD_VAR 0 12
20755: PPUSH
20756: LD_INT 1
20758: PPUSH
20759: CALL_OW 3
20763: ST_TO_ADDR
// if not f then
20764: LD_VAR 0 12
20768: NOT
20769: IFFALSE 20787
// begin x := x + 2 ;
20771: LD_ADDR_VAR 0 13
20775: PUSH
20776: LD_VAR 0 13
20780: PUSH
20781: LD_INT 2
20783: PLUS
20784: ST_TO_ADDR
// continue ;
20785: GO 20585
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20787: LD_VAR 0 12
20791: PUSH
20792: LD_INT 1
20794: ARRAY
20795: PPUSH
20796: CALL_OW 266
20800: PUSH
20801: LD_INT 5
20803: EQUAL
20804: IFFALSE 20878
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20806: LD_VAR 0 12
20810: PUSH
20811: LD_INT 1
20813: ARRAY
20814: PPUSH
20815: CALL_OW 313
20819: PUSH
20820: LD_INT 3
20822: LESS
20823: IFFALSE 20859
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20825: LD_INT 0
20827: PPUSH
20828: LD_INT 5
20830: PUSH
20831: LD_INT 8
20833: PUSH
20834: LD_INT 9
20836: PUSH
20837: EMPTY
20838: LIST
20839: LIST
20840: LIST
20841: PUSH
20842: LD_VAR 0 17
20846: ARRAY
20847: PPUSH
20848: LD_VAR 0 4
20852: PPUSH
20853: CALL_OW 380
20857: GO 20876
// PrepareHuman ( false , i , skill ) ;
20859: LD_INT 0
20861: PPUSH
20862: LD_VAR 0 8
20866: PPUSH
20867: LD_VAR 0 4
20871: PPUSH
20872: CALL_OW 380
// end else
20876: GO 20895
// PrepareHuman ( false , i , skill ) ;
20878: LD_INT 0
20880: PPUSH
20881: LD_VAR 0 8
20885: PPUSH
20886: LD_VAR 0 4
20890: PPUSH
20891: CALL_OW 380
// un := CreateHuman ;
20895: LD_ADDR_VAR 0 14
20899: PUSH
20900: CALL_OW 44
20904: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20905: LD_ADDR_VAR 0 7
20909: PUSH
20910: LD_VAR 0 7
20914: PPUSH
20915: LD_INT 1
20917: PPUSH
20918: LD_VAR 0 14
20922: PPUSH
20923: CALL_OW 2
20927: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20928: LD_VAR 0 14
20932: PPUSH
20933: LD_VAR 0 12
20937: PUSH
20938: LD_INT 1
20940: ARRAY
20941: PPUSH
20942: CALL_OW 52
// end ;
20946: GO 20585
20948: POP
20949: POP
// end ;
20950: GO 19887
20952: POP
20953: POP
// result := result ^ buildings ;
20954: LD_ADDR_VAR 0 7
20958: PUSH
20959: LD_VAR 0 7
20963: PUSH
20964: LD_VAR 0 18
20968: ADD
20969: ST_TO_ADDR
// end else
20970: GO 21113
// begin for i = 1 to personel do
20972: LD_ADDR_VAR 0 8
20976: PUSH
20977: DOUBLE
20978: LD_INT 1
20980: DEC
20981: ST_TO_ADDR
20982: LD_VAR 0 6
20986: PUSH
20987: FOR_TO
20988: IFFALSE 21111
// begin if i > 4 then
20990: LD_VAR 0 8
20994: PUSH
20995: LD_INT 4
20997: GREATER
20998: IFFALSE 21002
// break ;
21000: GO 21111
// x := personel [ i ] ;
21002: LD_ADDR_VAR 0 13
21006: PUSH
21007: LD_VAR 0 6
21011: PUSH
21012: LD_VAR 0 8
21016: ARRAY
21017: ST_TO_ADDR
// if x = - 1 then
21018: LD_VAR 0 13
21022: PUSH
21023: LD_INT 1
21025: NEG
21026: EQUAL
21027: IFFALSE 21031
// continue ;
21029: GO 20987
// PrepareHuman ( false , i , skill ) ;
21031: LD_INT 0
21033: PPUSH
21034: LD_VAR 0 8
21038: PPUSH
21039: LD_VAR 0 4
21043: PPUSH
21044: CALL_OW 380
// un := CreateHuman ;
21048: LD_ADDR_VAR 0 14
21052: PUSH
21053: CALL_OW 44
21057: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21058: LD_VAR 0 14
21062: PPUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 250
21072: PPUSH
21073: LD_VAR 0 1
21077: PPUSH
21078: CALL_OW 251
21082: PPUSH
21083: LD_INT 10
21085: PPUSH
21086: LD_INT 0
21088: PPUSH
21089: CALL_OW 50
// result := result ^ un ;
21093: LD_ADDR_VAR 0 7
21097: PUSH
21098: LD_VAR 0 7
21102: PUSH
21103: LD_VAR 0 14
21107: ADD
21108: ST_TO_ADDR
// end ;
21109: GO 20987
21111: POP
21112: POP
// end ; end ;
21113: LD_VAR 0 7
21117: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21118: LD_INT 0
21120: PPUSH
21121: PPUSH
21122: PPUSH
21123: PPUSH
21124: PPUSH
21125: PPUSH
21126: PPUSH
21127: PPUSH
21128: PPUSH
21129: PPUSH
21130: PPUSH
21131: PPUSH
21132: PPUSH
21133: PPUSH
21134: PPUSH
21135: PPUSH
// result := false ;
21136: LD_ADDR_VAR 0 3
21140: PUSH
21141: LD_INT 0
21143: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21144: LD_VAR 0 1
21148: NOT
21149: PUSH
21150: LD_VAR 0 1
21154: PPUSH
21155: CALL_OW 266
21159: PUSH
21160: LD_INT 32
21162: PUSH
21163: LD_INT 33
21165: PUSH
21166: EMPTY
21167: LIST
21168: LIST
21169: IN
21170: NOT
21171: OR
21172: IFFALSE 21176
// exit ;
21174: GO 22285
// nat := GetNation ( tower ) ;
21176: LD_ADDR_VAR 0 12
21180: PUSH
21181: LD_VAR 0 1
21185: PPUSH
21186: CALL_OW 248
21190: ST_TO_ADDR
// side := GetSide ( tower ) ;
21191: LD_ADDR_VAR 0 16
21195: PUSH
21196: LD_VAR 0 1
21200: PPUSH
21201: CALL_OW 255
21205: ST_TO_ADDR
// x := GetX ( tower ) ;
21206: LD_ADDR_VAR 0 10
21210: PUSH
21211: LD_VAR 0 1
21215: PPUSH
21216: CALL_OW 250
21220: ST_TO_ADDR
// y := GetY ( tower ) ;
21221: LD_ADDR_VAR 0 11
21225: PUSH
21226: LD_VAR 0 1
21230: PPUSH
21231: CALL_OW 251
21235: ST_TO_ADDR
// if not x or not y then
21236: LD_VAR 0 10
21240: NOT
21241: PUSH
21242: LD_VAR 0 11
21246: NOT
21247: OR
21248: IFFALSE 21252
// exit ;
21250: GO 22285
// weapon := 0 ;
21252: LD_ADDR_VAR 0 18
21256: PUSH
21257: LD_INT 0
21259: ST_TO_ADDR
// fac_list := [ ] ;
21260: LD_ADDR_VAR 0 17
21264: PUSH
21265: EMPTY
21266: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21267: LD_ADDR_VAR 0 6
21271: PUSH
21272: LD_VAR 0 1
21276: PPUSH
21277: CALL_OW 274
21281: PPUSH
21282: LD_VAR 0 2
21286: PPUSH
21287: LD_INT 0
21289: PPUSH
21290: CALL 18856 0 3
21294: PPUSH
21295: LD_INT 30
21297: PUSH
21298: LD_INT 3
21300: PUSH
21301: EMPTY
21302: LIST
21303: LIST
21304: PPUSH
21305: CALL_OW 72
21309: ST_TO_ADDR
// if not factories then
21310: LD_VAR 0 6
21314: NOT
21315: IFFALSE 21319
// exit ;
21317: GO 22285
// for i in factories do
21319: LD_ADDR_VAR 0 8
21323: PUSH
21324: LD_VAR 0 6
21328: PUSH
21329: FOR_IN
21330: IFFALSE 21355
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21332: LD_ADDR_VAR 0 17
21336: PUSH
21337: LD_VAR 0 17
21341: PUSH
21342: LD_VAR 0 8
21346: PPUSH
21347: CALL_OW 478
21351: UNION
21352: ST_TO_ADDR
21353: GO 21329
21355: POP
21356: POP
// if not fac_list then
21357: LD_VAR 0 17
21361: NOT
21362: IFFALSE 21366
// exit ;
21364: GO 22285
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: LD_INT 4
21373: PUSH
21374: LD_INT 5
21376: PUSH
21377: LD_INT 9
21379: PUSH
21380: LD_INT 10
21382: PUSH
21383: LD_INT 6
21385: PUSH
21386: LD_INT 7
21388: PUSH
21389: LD_INT 11
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: LIST
21398: LIST
21399: LIST
21400: PUSH
21401: LD_INT 27
21403: PUSH
21404: LD_INT 28
21406: PUSH
21407: LD_INT 26
21409: PUSH
21410: LD_INT 30
21412: PUSH
21413: EMPTY
21414: LIST
21415: LIST
21416: LIST
21417: LIST
21418: PUSH
21419: LD_INT 43
21421: PUSH
21422: LD_INT 44
21424: PUSH
21425: LD_INT 46
21427: PUSH
21428: LD_INT 45
21430: PUSH
21431: LD_INT 47
21433: PUSH
21434: LD_INT 49
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: PUSH
21445: EMPTY
21446: LIST
21447: LIST
21448: LIST
21449: PUSH
21450: LD_VAR 0 12
21454: ARRAY
21455: ST_TO_ADDR
// list := list isect fac_list ;
21456: LD_ADDR_VAR 0 5
21460: PUSH
21461: LD_VAR 0 5
21465: PUSH
21466: LD_VAR 0 17
21470: ISECT
21471: ST_TO_ADDR
// if not list then
21472: LD_VAR 0 5
21476: NOT
21477: IFFALSE 21481
// exit ;
21479: GO 22285
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21481: LD_VAR 0 12
21485: PUSH
21486: LD_INT 3
21488: EQUAL
21489: PUSH
21490: LD_INT 49
21492: PUSH
21493: LD_VAR 0 5
21497: IN
21498: AND
21499: PUSH
21500: LD_INT 31
21502: PPUSH
21503: LD_VAR 0 16
21507: PPUSH
21508: CALL_OW 321
21512: PUSH
21513: LD_INT 2
21515: EQUAL
21516: AND
21517: IFFALSE 21577
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21519: LD_INT 22
21521: PUSH
21522: LD_VAR 0 16
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: PUSH
21531: LD_INT 35
21533: PUSH
21534: LD_INT 49
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: PUSH
21541: LD_INT 91
21543: PUSH
21544: LD_VAR 0 1
21548: PUSH
21549: LD_INT 10
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: LIST
21556: PUSH
21557: EMPTY
21558: LIST
21559: LIST
21560: LIST
21561: PPUSH
21562: CALL_OW 69
21566: NOT
21567: IFFALSE 21577
// weapon := ru_time_lapser ;
21569: LD_ADDR_VAR 0 18
21573: PUSH
21574: LD_INT 49
21576: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21577: LD_VAR 0 12
21581: PUSH
21582: LD_INT 1
21584: PUSH
21585: LD_INT 2
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: IN
21592: PUSH
21593: LD_INT 11
21595: PUSH
21596: LD_VAR 0 5
21600: IN
21601: PUSH
21602: LD_INT 30
21604: PUSH
21605: LD_VAR 0 5
21609: IN
21610: OR
21611: AND
21612: PUSH
21613: LD_INT 6
21615: PPUSH
21616: LD_VAR 0 16
21620: PPUSH
21621: CALL_OW 321
21625: PUSH
21626: LD_INT 2
21628: EQUAL
21629: AND
21630: IFFALSE 21795
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21632: LD_INT 22
21634: PUSH
21635: LD_VAR 0 16
21639: PUSH
21640: EMPTY
21641: LIST
21642: LIST
21643: PUSH
21644: LD_INT 2
21646: PUSH
21647: LD_INT 35
21649: PUSH
21650: LD_INT 11
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: PUSH
21657: LD_INT 35
21659: PUSH
21660: LD_INT 30
21662: PUSH
21663: EMPTY
21664: LIST
21665: LIST
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: LIST
21671: PUSH
21672: LD_INT 91
21674: PUSH
21675: LD_VAR 0 1
21679: PUSH
21680: LD_INT 18
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: LIST
21687: PUSH
21688: EMPTY
21689: LIST
21690: LIST
21691: LIST
21692: PPUSH
21693: CALL_OW 69
21697: NOT
21698: PUSH
21699: LD_INT 22
21701: PUSH
21702: LD_VAR 0 16
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: PUSH
21711: LD_INT 2
21713: PUSH
21714: LD_INT 30
21716: PUSH
21717: LD_INT 32
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: PUSH
21724: LD_INT 30
21726: PUSH
21727: LD_INT 33
21729: PUSH
21730: EMPTY
21731: LIST
21732: LIST
21733: PUSH
21734: EMPTY
21735: LIST
21736: LIST
21737: LIST
21738: PUSH
21739: LD_INT 91
21741: PUSH
21742: LD_VAR 0 1
21746: PUSH
21747: LD_INT 12
21749: PUSH
21750: EMPTY
21751: LIST
21752: LIST
21753: LIST
21754: PUSH
21755: EMPTY
21756: LIST
21757: LIST
21758: LIST
21759: PUSH
21760: EMPTY
21761: LIST
21762: PPUSH
21763: CALL_OW 69
21767: PUSH
21768: LD_INT 2
21770: GREATER
21771: AND
21772: IFFALSE 21795
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21774: LD_ADDR_VAR 0 18
21778: PUSH
21779: LD_INT 11
21781: PUSH
21782: LD_INT 30
21784: PUSH
21785: EMPTY
21786: LIST
21787: LIST
21788: PUSH
21789: LD_VAR 0 12
21793: ARRAY
21794: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21795: LD_VAR 0 18
21799: NOT
21800: PUSH
21801: LD_INT 40
21803: PPUSH
21804: LD_VAR 0 16
21808: PPUSH
21809: CALL_OW 321
21813: PUSH
21814: LD_INT 2
21816: EQUAL
21817: AND
21818: PUSH
21819: LD_INT 7
21821: PUSH
21822: LD_VAR 0 5
21826: IN
21827: PUSH
21828: LD_INT 28
21830: PUSH
21831: LD_VAR 0 5
21835: IN
21836: OR
21837: PUSH
21838: LD_INT 45
21840: PUSH
21841: LD_VAR 0 5
21845: IN
21846: OR
21847: AND
21848: IFFALSE 22102
// begin hex := GetHexInfo ( x , y ) ;
21850: LD_ADDR_VAR 0 4
21854: PUSH
21855: LD_VAR 0 10
21859: PPUSH
21860: LD_VAR 0 11
21864: PPUSH
21865: CALL_OW 546
21869: ST_TO_ADDR
// if hex [ 1 ] then
21870: LD_VAR 0 4
21874: PUSH
21875: LD_INT 1
21877: ARRAY
21878: IFFALSE 21882
// exit ;
21880: GO 22285
// height := hex [ 2 ] ;
21882: LD_ADDR_VAR 0 15
21886: PUSH
21887: LD_VAR 0 4
21891: PUSH
21892: LD_INT 2
21894: ARRAY
21895: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21896: LD_ADDR_VAR 0 14
21900: PUSH
21901: LD_INT 0
21903: PUSH
21904: LD_INT 2
21906: PUSH
21907: LD_INT 3
21909: PUSH
21910: LD_INT 5
21912: PUSH
21913: EMPTY
21914: LIST
21915: LIST
21916: LIST
21917: LIST
21918: ST_TO_ADDR
// for i in tmp do
21919: LD_ADDR_VAR 0 8
21923: PUSH
21924: LD_VAR 0 14
21928: PUSH
21929: FOR_IN
21930: IFFALSE 22100
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21932: LD_ADDR_VAR 0 9
21936: PUSH
21937: LD_VAR 0 10
21941: PPUSH
21942: LD_VAR 0 8
21946: PPUSH
21947: LD_INT 5
21949: PPUSH
21950: CALL_OW 272
21954: PUSH
21955: LD_VAR 0 11
21959: PPUSH
21960: LD_VAR 0 8
21964: PPUSH
21965: LD_INT 5
21967: PPUSH
21968: CALL_OW 273
21972: PUSH
21973: EMPTY
21974: LIST
21975: LIST
21976: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21977: LD_VAR 0 9
21981: PUSH
21982: LD_INT 1
21984: ARRAY
21985: PPUSH
21986: LD_VAR 0 9
21990: PUSH
21991: LD_INT 2
21993: ARRAY
21994: PPUSH
21995: CALL_OW 488
21999: IFFALSE 22098
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22001: LD_ADDR_VAR 0 4
22005: PUSH
22006: LD_VAR 0 9
22010: PUSH
22011: LD_INT 1
22013: ARRAY
22014: PPUSH
22015: LD_VAR 0 9
22019: PUSH
22020: LD_INT 2
22022: ARRAY
22023: PPUSH
22024: CALL_OW 546
22028: ST_TO_ADDR
// if hex [ 1 ] then
22029: LD_VAR 0 4
22033: PUSH
22034: LD_INT 1
22036: ARRAY
22037: IFFALSE 22041
// continue ;
22039: GO 21929
// h := hex [ 2 ] ;
22041: LD_ADDR_VAR 0 13
22045: PUSH
22046: LD_VAR 0 4
22050: PUSH
22051: LD_INT 2
22053: ARRAY
22054: ST_TO_ADDR
// if h + 7 < height then
22055: LD_VAR 0 13
22059: PUSH
22060: LD_INT 7
22062: PLUS
22063: PUSH
22064: LD_VAR 0 15
22068: LESS
22069: IFFALSE 22098
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22071: LD_ADDR_VAR 0 18
22075: PUSH
22076: LD_INT 7
22078: PUSH
22079: LD_INT 28
22081: PUSH
22082: LD_INT 45
22084: PUSH
22085: EMPTY
22086: LIST
22087: LIST
22088: LIST
22089: PUSH
22090: LD_VAR 0 12
22094: ARRAY
22095: ST_TO_ADDR
// break ;
22096: GO 22100
// end ; end ; end ;
22098: GO 21929
22100: POP
22101: POP
// end ; if not weapon then
22102: LD_VAR 0 18
22106: NOT
22107: IFFALSE 22167
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22109: LD_ADDR_VAR 0 5
22113: PUSH
22114: LD_VAR 0 5
22118: PUSH
22119: LD_INT 11
22121: PUSH
22122: LD_INT 30
22124: PUSH
22125: LD_INT 49
22127: PUSH
22128: EMPTY
22129: LIST
22130: LIST
22131: LIST
22132: DIFF
22133: ST_TO_ADDR
// if not list then
22134: LD_VAR 0 5
22138: NOT
22139: IFFALSE 22143
// exit ;
22141: GO 22285
// weapon := list [ rand ( 1 , list ) ] ;
22143: LD_ADDR_VAR 0 18
22147: PUSH
22148: LD_VAR 0 5
22152: PUSH
22153: LD_INT 1
22155: PPUSH
22156: LD_VAR 0 5
22160: PPUSH
22161: CALL_OW 12
22165: ARRAY
22166: ST_TO_ADDR
// end ; if weapon then
22167: LD_VAR 0 18
22171: IFFALSE 22285
// begin tmp := CostOfWeapon ( weapon ) ;
22173: LD_ADDR_VAR 0 14
22177: PUSH
22178: LD_VAR 0 18
22182: PPUSH
22183: CALL_OW 451
22187: ST_TO_ADDR
// j := GetBase ( tower ) ;
22188: LD_ADDR_VAR 0 9
22192: PUSH
22193: LD_VAR 0 1
22197: PPUSH
22198: CALL_OW 274
22202: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22203: LD_VAR 0 9
22207: PPUSH
22208: LD_INT 1
22210: PPUSH
22211: CALL_OW 275
22215: PUSH
22216: LD_VAR 0 14
22220: PUSH
22221: LD_INT 1
22223: ARRAY
22224: GREATEREQUAL
22225: PUSH
22226: LD_VAR 0 9
22230: PPUSH
22231: LD_INT 2
22233: PPUSH
22234: CALL_OW 275
22238: PUSH
22239: LD_VAR 0 14
22243: PUSH
22244: LD_INT 2
22246: ARRAY
22247: GREATEREQUAL
22248: AND
22249: PUSH
22250: LD_VAR 0 9
22254: PPUSH
22255: LD_INT 3
22257: PPUSH
22258: CALL_OW 275
22262: PUSH
22263: LD_VAR 0 14
22267: PUSH
22268: LD_INT 3
22270: ARRAY
22271: GREATEREQUAL
22272: AND
22273: IFFALSE 22285
// result := weapon ;
22275: LD_ADDR_VAR 0 3
22279: PUSH
22280: LD_VAR 0 18
22284: ST_TO_ADDR
// end ; end ;
22285: LD_VAR 0 3
22289: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22290: LD_INT 0
22292: PPUSH
22293: PPUSH
// result := true ;
22294: LD_ADDR_VAR 0 3
22298: PUSH
22299: LD_INT 1
22301: ST_TO_ADDR
// if array1 = array2 then
22302: LD_VAR 0 1
22306: PUSH
22307: LD_VAR 0 2
22311: EQUAL
22312: IFFALSE 22372
// begin for i = 1 to array1 do
22314: LD_ADDR_VAR 0 4
22318: PUSH
22319: DOUBLE
22320: LD_INT 1
22322: DEC
22323: ST_TO_ADDR
22324: LD_VAR 0 1
22328: PUSH
22329: FOR_TO
22330: IFFALSE 22368
// if array1 [ i ] <> array2 [ i ] then
22332: LD_VAR 0 1
22336: PUSH
22337: LD_VAR 0 4
22341: ARRAY
22342: PUSH
22343: LD_VAR 0 2
22347: PUSH
22348: LD_VAR 0 4
22352: ARRAY
22353: NONEQUAL
22354: IFFALSE 22366
// begin result := false ;
22356: LD_ADDR_VAR 0 3
22360: PUSH
22361: LD_INT 0
22363: ST_TO_ADDR
// break ;
22364: GO 22368
// end ;
22366: GO 22329
22368: POP
22369: POP
// end else
22370: GO 22380
// result := false ;
22372: LD_ADDR_VAR 0 3
22376: PUSH
22377: LD_INT 0
22379: ST_TO_ADDR
// end ;
22380: LD_VAR 0 3
22384: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22385: LD_INT 0
22387: PPUSH
22388: PPUSH
// if not array1 or not array2 then
22389: LD_VAR 0 1
22393: NOT
22394: PUSH
22395: LD_VAR 0 2
22399: NOT
22400: OR
22401: IFFALSE 22405
// exit ;
22403: GO 22469
// result := true ;
22405: LD_ADDR_VAR 0 3
22409: PUSH
22410: LD_INT 1
22412: ST_TO_ADDR
// for i = 1 to array1 do
22413: LD_ADDR_VAR 0 4
22417: PUSH
22418: DOUBLE
22419: LD_INT 1
22421: DEC
22422: ST_TO_ADDR
22423: LD_VAR 0 1
22427: PUSH
22428: FOR_TO
22429: IFFALSE 22467
// if array1 [ i ] <> array2 [ i ] then
22431: LD_VAR 0 1
22435: PUSH
22436: LD_VAR 0 4
22440: ARRAY
22441: PUSH
22442: LD_VAR 0 2
22446: PUSH
22447: LD_VAR 0 4
22451: ARRAY
22452: NONEQUAL
22453: IFFALSE 22465
// begin result := false ;
22455: LD_ADDR_VAR 0 3
22459: PUSH
22460: LD_INT 0
22462: ST_TO_ADDR
// break ;
22463: GO 22467
// end ;
22465: GO 22428
22467: POP
22468: POP
// end ;
22469: LD_VAR 0 3
22473: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22474: LD_INT 0
22476: PPUSH
22477: PPUSH
22478: PPUSH
// pom := GetBase ( fac ) ;
22479: LD_ADDR_VAR 0 5
22483: PUSH
22484: LD_VAR 0 1
22488: PPUSH
22489: CALL_OW 274
22493: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22494: LD_ADDR_VAR 0 4
22498: PUSH
22499: LD_VAR 0 2
22503: PUSH
22504: LD_INT 1
22506: ARRAY
22507: PPUSH
22508: LD_VAR 0 2
22512: PUSH
22513: LD_INT 2
22515: ARRAY
22516: PPUSH
22517: LD_VAR 0 2
22521: PUSH
22522: LD_INT 3
22524: ARRAY
22525: PPUSH
22526: LD_VAR 0 2
22530: PUSH
22531: LD_INT 4
22533: ARRAY
22534: PPUSH
22535: CALL_OW 449
22539: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22540: LD_ADDR_VAR 0 3
22544: PUSH
22545: LD_VAR 0 5
22549: PPUSH
22550: LD_INT 1
22552: PPUSH
22553: CALL_OW 275
22557: PUSH
22558: LD_VAR 0 4
22562: PUSH
22563: LD_INT 1
22565: ARRAY
22566: GREATEREQUAL
22567: PUSH
22568: LD_VAR 0 5
22572: PPUSH
22573: LD_INT 2
22575: PPUSH
22576: CALL_OW 275
22580: PUSH
22581: LD_VAR 0 4
22585: PUSH
22586: LD_INT 2
22588: ARRAY
22589: GREATEREQUAL
22590: AND
22591: PUSH
22592: LD_VAR 0 5
22596: PPUSH
22597: LD_INT 3
22599: PPUSH
22600: CALL_OW 275
22604: PUSH
22605: LD_VAR 0 4
22609: PUSH
22610: LD_INT 3
22612: ARRAY
22613: GREATEREQUAL
22614: AND
22615: ST_TO_ADDR
// end ;
22616: LD_VAR 0 3
22620: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22621: LD_INT 0
22623: PPUSH
22624: PPUSH
22625: PPUSH
22626: PPUSH
// pom := GetBase ( building ) ;
22627: LD_ADDR_VAR 0 3
22631: PUSH
22632: LD_VAR 0 1
22636: PPUSH
22637: CALL_OW 274
22641: ST_TO_ADDR
// if not pom then
22642: LD_VAR 0 3
22646: NOT
22647: IFFALSE 22651
// exit ;
22649: GO 22821
// btype := GetBType ( building ) ;
22651: LD_ADDR_VAR 0 5
22655: PUSH
22656: LD_VAR 0 1
22660: PPUSH
22661: CALL_OW 266
22665: ST_TO_ADDR
// if btype = b_armoury then
22666: LD_VAR 0 5
22670: PUSH
22671: LD_INT 4
22673: EQUAL
22674: IFFALSE 22684
// btype := b_barracks ;
22676: LD_ADDR_VAR 0 5
22680: PUSH
22681: LD_INT 5
22683: ST_TO_ADDR
// if btype = b_depot then
22684: LD_VAR 0 5
22688: PUSH
22689: LD_INT 0
22691: EQUAL
22692: IFFALSE 22702
// btype := b_warehouse ;
22694: LD_ADDR_VAR 0 5
22698: PUSH
22699: LD_INT 1
22701: ST_TO_ADDR
// if btype = b_workshop then
22702: LD_VAR 0 5
22706: PUSH
22707: LD_INT 2
22709: EQUAL
22710: IFFALSE 22720
// btype := b_factory ;
22712: LD_ADDR_VAR 0 5
22716: PUSH
22717: LD_INT 3
22719: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22720: LD_ADDR_VAR 0 4
22724: PUSH
22725: LD_VAR 0 5
22729: PPUSH
22730: LD_VAR 0 1
22734: PPUSH
22735: CALL_OW 248
22739: PPUSH
22740: CALL_OW 450
22744: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22745: LD_ADDR_VAR 0 2
22749: PUSH
22750: LD_VAR 0 3
22754: PPUSH
22755: LD_INT 1
22757: PPUSH
22758: CALL_OW 275
22762: PUSH
22763: LD_VAR 0 4
22767: PUSH
22768: LD_INT 1
22770: ARRAY
22771: GREATEREQUAL
22772: PUSH
22773: LD_VAR 0 3
22777: PPUSH
22778: LD_INT 2
22780: PPUSH
22781: CALL_OW 275
22785: PUSH
22786: LD_VAR 0 4
22790: PUSH
22791: LD_INT 2
22793: ARRAY
22794: GREATEREQUAL
22795: AND
22796: PUSH
22797: LD_VAR 0 3
22801: PPUSH
22802: LD_INT 3
22804: PPUSH
22805: CALL_OW 275
22809: PUSH
22810: LD_VAR 0 4
22814: PUSH
22815: LD_INT 3
22817: ARRAY
22818: GREATEREQUAL
22819: AND
22820: ST_TO_ADDR
// end ;
22821: LD_VAR 0 2
22825: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22826: LD_INT 0
22828: PPUSH
22829: PPUSH
22830: PPUSH
// pom := GetBase ( building ) ;
22831: LD_ADDR_VAR 0 4
22835: PUSH
22836: LD_VAR 0 1
22840: PPUSH
22841: CALL_OW 274
22845: ST_TO_ADDR
// if not pom then
22846: LD_VAR 0 4
22850: NOT
22851: IFFALSE 22855
// exit ;
22853: GO 22956
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22855: LD_ADDR_VAR 0 5
22859: PUSH
22860: LD_VAR 0 2
22864: PPUSH
22865: LD_VAR 0 1
22869: PPUSH
22870: CALL_OW 248
22874: PPUSH
22875: CALL_OW 450
22879: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22880: LD_ADDR_VAR 0 3
22884: PUSH
22885: LD_VAR 0 4
22889: PPUSH
22890: LD_INT 1
22892: PPUSH
22893: CALL_OW 275
22897: PUSH
22898: LD_VAR 0 5
22902: PUSH
22903: LD_INT 1
22905: ARRAY
22906: GREATEREQUAL
22907: PUSH
22908: LD_VAR 0 4
22912: PPUSH
22913: LD_INT 2
22915: PPUSH
22916: CALL_OW 275
22920: PUSH
22921: LD_VAR 0 5
22925: PUSH
22926: LD_INT 2
22928: ARRAY
22929: GREATEREQUAL
22930: AND
22931: PUSH
22932: LD_VAR 0 4
22936: PPUSH
22937: LD_INT 3
22939: PPUSH
22940: CALL_OW 275
22944: PUSH
22945: LD_VAR 0 5
22949: PUSH
22950: LD_INT 3
22952: ARRAY
22953: GREATEREQUAL
22954: AND
22955: ST_TO_ADDR
// end ;
22956: LD_VAR 0 3
22960: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22961: LD_INT 0
22963: PPUSH
22964: PPUSH
22965: PPUSH
22966: PPUSH
22967: PPUSH
22968: PPUSH
22969: PPUSH
22970: PPUSH
22971: PPUSH
22972: PPUSH
22973: PPUSH
// result := false ;
22974: LD_ADDR_VAR 0 8
22978: PUSH
22979: LD_INT 0
22981: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22982: LD_VAR 0 5
22986: NOT
22987: PUSH
22988: LD_VAR 0 1
22992: NOT
22993: OR
22994: PUSH
22995: LD_VAR 0 2
22999: NOT
23000: OR
23001: PUSH
23002: LD_VAR 0 3
23006: NOT
23007: OR
23008: IFFALSE 23012
// exit ;
23010: GO 23826
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23012: LD_ADDR_VAR 0 14
23016: PUSH
23017: LD_VAR 0 1
23021: PPUSH
23022: LD_VAR 0 2
23026: PPUSH
23027: LD_VAR 0 3
23031: PPUSH
23032: LD_VAR 0 4
23036: PPUSH
23037: LD_VAR 0 5
23041: PUSH
23042: LD_INT 1
23044: ARRAY
23045: PPUSH
23046: CALL_OW 248
23050: PPUSH
23051: LD_INT 0
23053: PPUSH
23054: CALL 25059 0 6
23058: ST_TO_ADDR
// if not hexes then
23059: LD_VAR 0 14
23063: NOT
23064: IFFALSE 23068
// exit ;
23066: GO 23826
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23068: LD_ADDR_VAR 0 17
23072: PUSH
23073: LD_VAR 0 5
23077: PPUSH
23078: LD_INT 22
23080: PUSH
23081: LD_VAR 0 13
23085: PPUSH
23086: CALL_OW 255
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: PUSH
23095: LD_INT 2
23097: PUSH
23098: LD_INT 30
23100: PUSH
23101: LD_INT 0
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: LD_INT 30
23110: PUSH
23111: LD_INT 1
23113: PUSH
23114: EMPTY
23115: LIST
23116: LIST
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: LIST
23122: PUSH
23123: EMPTY
23124: LIST
23125: LIST
23126: PPUSH
23127: CALL_OW 72
23131: ST_TO_ADDR
// for i = 1 to hexes do
23132: LD_ADDR_VAR 0 9
23136: PUSH
23137: DOUBLE
23138: LD_INT 1
23140: DEC
23141: ST_TO_ADDR
23142: LD_VAR 0 14
23146: PUSH
23147: FOR_TO
23148: IFFALSE 23824
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23150: LD_ADDR_VAR 0 13
23154: PUSH
23155: LD_VAR 0 14
23159: PUSH
23160: LD_VAR 0 9
23164: ARRAY
23165: PUSH
23166: LD_INT 1
23168: ARRAY
23169: PPUSH
23170: LD_VAR 0 14
23174: PUSH
23175: LD_VAR 0 9
23179: ARRAY
23180: PUSH
23181: LD_INT 2
23183: ARRAY
23184: PPUSH
23185: CALL_OW 428
23189: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23190: LD_VAR 0 14
23194: PUSH
23195: LD_VAR 0 9
23199: ARRAY
23200: PUSH
23201: LD_INT 1
23203: ARRAY
23204: PPUSH
23205: LD_VAR 0 14
23209: PUSH
23210: LD_VAR 0 9
23214: ARRAY
23215: PUSH
23216: LD_INT 2
23218: ARRAY
23219: PPUSH
23220: CALL_OW 351
23224: PUSH
23225: LD_VAR 0 14
23229: PUSH
23230: LD_VAR 0 9
23234: ARRAY
23235: PUSH
23236: LD_INT 1
23238: ARRAY
23239: PPUSH
23240: LD_VAR 0 14
23244: PUSH
23245: LD_VAR 0 9
23249: ARRAY
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: CALL_OW 488
23259: NOT
23260: OR
23261: PUSH
23262: LD_VAR 0 13
23266: PPUSH
23267: CALL_OW 247
23271: PUSH
23272: LD_INT 3
23274: EQUAL
23275: OR
23276: IFFALSE 23282
// exit ;
23278: POP
23279: POP
23280: GO 23826
// if not tmp then
23282: LD_VAR 0 13
23286: NOT
23287: IFFALSE 23291
// continue ;
23289: GO 23147
// result := true ;
23291: LD_ADDR_VAR 0 8
23295: PUSH
23296: LD_INT 1
23298: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23299: LD_VAR 0 6
23303: PUSH
23304: LD_VAR 0 13
23308: PPUSH
23309: CALL_OW 247
23313: PUSH
23314: LD_INT 2
23316: EQUAL
23317: AND
23318: PUSH
23319: LD_VAR 0 13
23323: PPUSH
23324: CALL_OW 263
23328: PUSH
23329: LD_INT 1
23331: EQUAL
23332: AND
23333: IFFALSE 23497
// begin if IsDrivenBy ( tmp ) then
23335: LD_VAR 0 13
23339: PPUSH
23340: CALL_OW 311
23344: IFFALSE 23348
// continue ;
23346: GO 23147
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23348: LD_VAR 0 6
23352: PPUSH
23353: LD_INT 3
23355: PUSH
23356: LD_INT 60
23358: PUSH
23359: EMPTY
23360: LIST
23361: PUSH
23362: EMPTY
23363: LIST
23364: LIST
23365: PUSH
23366: LD_INT 3
23368: PUSH
23369: LD_INT 55
23371: PUSH
23372: EMPTY
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PPUSH
23383: CALL_OW 72
23387: IFFALSE 23495
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23389: LD_ADDR_VAR 0 18
23393: PUSH
23394: LD_VAR 0 6
23398: PPUSH
23399: LD_INT 3
23401: PUSH
23402: LD_INT 60
23404: PUSH
23405: EMPTY
23406: LIST
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: PUSH
23412: LD_INT 3
23414: PUSH
23415: LD_INT 55
23417: PUSH
23418: EMPTY
23419: LIST
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: PUSH
23425: EMPTY
23426: LIST
23427: LIST
23428: PPUSH
23429: CALL_OW 72
23433: PUSH
23434: LD_INT 1
23436: ARRAY
23437: ST_TO_ADDR
// if IsInUnit ( driver ) then
23438: LD_VAR 0 18
23442: PPUSH
23443: CALL_OW 310
23447: IFFALSE 23458
// ComExit ( driver ) ;
23449: LD_VAR 0 18
23453: PPUSH
23454: CALL 48839 0 1
// AddComEnterUnit ( driver , tmp ) ;
23458: LD_VAR 0 18
23462: PPUSH
23463: LD_VAR 0 13
23467: PPUSH
23468: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23472: LD_VAR 0 18
23476: PPUSH
23477: LD_VAR 0 7
23481: PPUSH
23482: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23486: LD_VAR 0 18
23490: PPUSH
23491: CALL_OW 181
// end ; continue ;
23495: GO 23147
// end ; if not cleaners or not tmp in cleaners then
23497: LD_VAR 0 6
23501: NOT
23502: PUSH
23503: LD_VAR 0 13
23507: PUSH
23508: LD_VAR 0 6
23512: IN
23513: NOT
23514: OR
23515: IFFALSE 23822
// begin if dep then
23517: LD_VAR 0 17
23521: IFFALSE 23657
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23523: LD_ADDR_VAR 0 16
23527: PUSH
23528: LD_VAR 0 17
23532: PUSH
23533: LD_INT 1
23535: ARRAY
23536: PPUSH
23537: CALL_OW 250
23541: PPUSH
23542: LD_VAR 0 17
23546: PUSH
23547: LD_INT 1
23549: ARRAY
23550: PPUSH
23551: CALL_OW 254
23555: PPUSH
23556: LD_INT 5
23558: PPUSH
23559: CALL_OW 272
23563: PUSH
23564: LD_VAR 0 17
23568: PUSH
23569: LD_INT 1
23571: ARRAY
23572: PPUSH
23573: CALL_OW 251
23577: PPUSH
23578: LD_VAR 0 17
23582: PUSH
23583: LD_INT 1
23585: ARRAY
23586: PPUSH
23587: CALL_OW 254
23591: PPUSH
23592: LD_INT 5
23594: PPUSH
23595: CALL_OW 273
23599: PUSH
23600: EMPTY
23601: LIST
23602: LIST
23603: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23604: LD_VAR 0 16
23608: PUSH
23609: LD_INT 1
23611: ARRAY
23612: PPUSH
23613: LD_VAR 0 16
23617: PUSH
23618: LD_INT 2
23620: ARRAY
23621: PPUSH
23622: CALL_OW 488
23626: IFFALSE 23657
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23628: LD_VAR 0 13
23632: PPUSH
23633: LD_VAR 0 16
23637: PUSH
23638: LD_INT 1
23640: ARRAY
23641: PPUSH
23642: LD_VAR 0 16
23646: PUSH
23647: LD_INT 2
23649: ARRAY
23650: PPUSH
23651: CALL_OW 111
// continue ;
23655: GO 23147
// end ; end ; r := GetDir ( tmp ) ;
23657: LD_ADDR_VAR 0 15
23661: PUSH
23662: LD_VAR 0 13
23666: PPUSH
23667: CALL_OW 254
23671: ST_TO_ADDR
// if r = 5 then
23672: LD_VAR 0 15
23676: PUSH
23677: LD_INT 5
23679: EQUAL
23680: IFFALSE 23690
// r := 0 ;
23682: LD_ADDR_VAR 0 15
23686: PUSH
23687: LD_INT 0
23689: ST_TO_ADDR
// for j = r to 5 do
23690: LD_ADDR_VAR 0 10
23694: PUSH
23695: DOUBLE
23696: LD_VAR 0 15
23700: DEC
23701: ST_TO_ADDR
23702: LD_INT 5
23704: PUSH
23705: FOR_TO
23706: IFFALSE 23820
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23708: LD_ADDR_VAR 0 11
23712: PUSH
23713: LD_VAR 0 13
23717: PPUSH
23718: CALL_OW 250
23722: PPUSH
23723: LD_VAR 0 10
23727: PPUSH
23728: LD_INT 2
23730: PPUSH
23731: CALL_OW 272
23735: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23736: LD_ADDR_VAR 0 12
23740: PUSH
23741: LD_VAR 0 13
23745: PPUSH
23746: CALL_OW 251
23750: PPUSH
23751: LD_VAR 0 10
23755: PPUSH
23756: LD_INT 2
23758: PPUSH
23759: CALL_OW 273
23763: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23764: LD_VAR 0 11
23768: PPUSH
23769: LD_VAR 0 12
23773: PPUSH
23774: CALL_OW 488
23778: PUSH
23779: LD_VAR 0 11
23783: PPUSH
23784: LD_VAR 0 12
23788: PPUSH
23789: CALL_OW 428
23793: NOT
23794: AND
23795: IFFALSE 23818
// begin ComMoveXY ( tmp , _x , _y ) ;
23797: LD_VAR 0 13
23801: PPUSH
23802: LD_VAR 0 11
23806: PPUSH
23807: LD_VAR 0 12
23811: PPUSH
23812: CALL_OW 111
// break ;
23816: GO 23820
// end ; end ;
23818: GO 23705
23820: POP
23821: POP
// end ; end ;
23822: GO 23147
23824: POP
23825: POP
// end ;
23826: LD_VAR 0 8
23830: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23831: LD_INT 0
23833: PPUSH
// result := true ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_INT 1
23841: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23842: LD_VAR 0 2
23846: PUSH
23847: LD_INT 24
23849: DOUBLE
23850: EQUAL
23851: IFTRUE 23861
23853: LD_INT 33
23855: DOUBLE
23856: EQUAL
23857: IFTRUE 23861
23859: GO 23886
23861: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23862: LD_ADDR_VAR 0 3
23866: PUSH
23867: LD_INT 32
23869: PPUSH
23870: LD_VAR 0 1
23874: PPUSH
23875: CALL_OW 321
23879: PUSH
23880: LD_INT 2
23882: EQUAL
23883: ST_TO_ADDR
23884: GO 24202
23886: LD_INT 20
23888: DOUBLE
23889: EQUAL
23890: IFTRUE 23894
23892: GO 23919
23894: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23895: LD_ADDR_VAR 0 3
23899: PUSH
23900: LD_INT 6
23902: PPUSH
23903: LD_VAR 0 1
23907: PPUSH
23908: CALL_OW 321
23912: PUSH
23913: LD_INT 2
23915: EQUAL
23916: ST_TO_ADDR
23917: GO 24202
23919: LD_INT 22
23921: DOUBLE
23922: EQUAL
23923: IFTRUE 23933
23925: LD_INT 36
23927: DOUBLE
23928: EQUAL
23929: IFTRUE 23933
23931: GO 23958
23933: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23934: LD_ADDR_VAR 0 3
23938: PUSH
23939: LD_INT 15
23941: PPUSH
23942: LD_VAR 0 1
23946: PPUSH
23947: CALL_OW 321
23951: PUSH
23952: LD_INT 2
23954: EQUAL
23955: ST_TO_ADDR
23956: GO 24202
23958: LD_INT 30
23960: DOUBLE
23961: EQUAL
23962: IFTRUE 23966
23964: GO 23991
23966: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23967: LD_ADDR_VAR 0 3
23971: PUSH
23972: LD_INT 20
23974: PPUSH
23975: LD_VAR 0 1
23979: PPUSH
23980: CALL_OW 321
23984: PUSH
23985: LD_INT 2
23987: EQUAL
23988: ST_TO_ADDR
23989: GO 24202
23991: LD_INT 28
23993: DOUBLE
23994: EQUAL
23995: IFTRUE 24005
23997: LD_INT 21
23999: DOUBLE
24000: EQUAL
24001: IFTRUE 24005
24003: GO 24030
24005: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24006: LD_ADDR_VAR 0 3
24010: PUSH
24011: LD_INT 21
24013: PPUSH
24014: LD_VAR 0 1
24018: PPUSH
24019: CALL_OW 321
24023: PUSH
24024: LD_INT 2
24026: EQUAL
24027: ST_TO_ADDR
24028: GO 24202
24030: LD_INT 16
24032: DOUBLE
24033: EQUAL
24034: IFTRUE 24038
24036: GO 24063
24038: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24039: LD_ADDR_VAR 0 3
24043: PUSH
24044: LD_INT 84
24046: PPUSH
24047: LD_VAR 0 1
24051: PPUSH
24052: CALL_OW 321
24056: PUSH
24057: LD_INT 2
24059: EQUAL
24060: ST_TO_ADDR
24061: GO 24202
24063: LD_INT 19
24065: DOUBLE
24066: EQUAL
24067: IFTRUE 24077
24069: LD_INT 23
24071: DOUBLE
24072: EQUAL
24073: IFTRUE 24077
24075: GO 24102
24077: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24078: LD_ADDR_VAR 0 3
24082: PUSH
24083: LD_INT 83
24085: PPUSH
24086: LD_VAR 0 1
24090: PPUSH
24091: CALL_OW 321
24095: PUSH
24096: LD_INT 2
24098: EQUAL
24099: ST_TO_ADDR
24100: GO 24202
24102: LD_INT 17
24104: DOUBLE
24105: EQUAL
24106: IFTRUE 24110
24108: GO 24135
24110: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24111: LD_ADDR_VAR 0 3
24115: PUSH
24116: LD_INT 39
24118: PPUSH
24119: LD_VAR 0 1
24123: PPUSH
24124: CALL_OW 321
24128: PUSH
24129: LD_INT 2
24131: EQUAL
24132: ST_TO_ADDR
24133: GO 24202
24135: LD_INT 18
24137: DOUBLE
24138: EQUAL
24139: IFTRUE 24143
24141: GO 24168
24143: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24144: LD_ADDR_VAR 0 3
24148: PUSH
24149: LD_INT 40
24151: PPUSH
24152: LD_VAR 0 1
24156: PPUSH
24157: CALL_OW 321
24161: PUSH
24162: LD_INT 2
24164: EQUAL
24165: ST_TO_ADDR
24166: GO 24202
24168: LD_INT 27
24170: DOUBLE
24171: EQUAL
24172: IFTRUE 24176
24174: GO 24201
24176: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24177: LD_ADDR_VAR 0 3
24181: PUSH
24182: LD_INT 35
24184: PPUSH
24185: LD_VAR 0 1
24189: PPUSH
24190: CALL_OW 321
24194: PUSH
24195: LD_INT 2
24197: EQUAL
24198: ST_TO_ADDR
24199: GO 24202
24201: POP
// end ;
24202: LD_VAR 0 3
24206: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24207: LD_INT 0
24209: PPUSH
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
// result := false ;
24220: LD_ADDR_VAR 0 6
24224: PUSH
24225: LD_INT 0
24227: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24228: LD_VAR 0 1
24232: NOT
24233: PUSH
24234: LD_VAR 0 1
24238: PPUSH
24239: CALL_OW 266
24243: PUSH
24244: LD_INT 0
24246: PUSH
24247: LD_INT 1
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: IN
24254: NOT
24255: OR
24256: PUSH
24257: LD_VAR 0 2
24261: NOT
24262: OR
24263: PUSH
24264: LD_VAR 0 5
24268: PUSH
24269: LD_INT 0
24271: PUSH
24272: LD_INT 1
24274: PUSH
24275: LD_INT 2
24277: PUSH
24278: LD_INT 3
24280: PUSH
24281: LD_INT 4
24283: PUSH
24284: LD_INT 5
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: LIST
24291: LIST
24292: LIST
24293: LIST
24294: IN
24295: NOT
24296: OR
24297: PUSH
24298: LD_VAR 0 3
24302: PPUSH
24303: LD_VAR 0 4
24307: PPUSH
24308: CALL_OW 488
24312: NOT
24313: OR
24314: IFFALSE 24318
// exit ;
24316: GO 25054
// side := GetSide ( depot ) ;
24318: LD_ADDR_VAR 0 9
24322: PUSH
24323: LD_VAR 0 1
24327: PPUSH
24328: CALL_OW 255
24332: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24333: LD_VAR 0 9
24337: PPUSH
24338: LD_VAR 0 2
24342: PPUSH
24343: CALL 23831 0 2
24347: NOT
24348: IFFALSE 24352
// exit ;
24350: GO 25054
// pom := GetBase ( depot ) ;
24352: LD_ADDR_VAR 0 10
24356: PUSH
24357: LD_VAR 0 1
24361: PPUSH
24362: CALL_OW 274
24366: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24367: LD_ADDR_VAR 0 11
24371: PUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: LD_VAR 0 1
24381: PPUSH
24382: CALL_OW 248
24386: PPUSH
24387: CALL_OW 450
24391: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24392: LD_VAR 0 10
24396: PPUSH
24397: LD_INT 1
24399: PPUSH
24400: CALL_OW 275
24404: PUSH
24405: LD_VAR 0 11
24409: PUSH
24410: LD_INT 1
24412: ARRAY
24413: GREATEREQUAL
24414: PUSH
24415: LD_VAR 0 10
24419: PPUSH
24420: LD_INT 2
24422: PPUSH
24423: CALL_OW 275
24427: PUSH
24428: LD_VAR 0 11
24432: PUSH
24433: LD_INT 2
24435: ARRAY
24436: GREATEREQUAL
24437: AND
24438: PUSH
24439: LD_VAR 0 10
24443: PPUSH
24444: LD_INT 3
24446: PPUSH
24447: CALL_OW 275
24451: PUSH
24452: LD_VAR 0 11
24456: PUSH
24457: LD_INT 3
24459: ARRAY
24460: GREATEREQUAL
24461: AND
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 25054
// if GetBType ( depot ) = b_depot then
24467: LD_VAR 0 1
24471: PPUSH
24472: CALL_OW 266
24476: PUSH
24477: LD_INT 0
24479: EQUAL
24480: IFFALSE 24492
// dist := 28 else
24482: LD_ADDR_VAR 0 14
24486: PUSH
24487: LD_INT 28
24489: ST_TO_ADDR
24490: GO 24500
// dist := 36 ;
24492: LD_ADDR_VAR 0 14
24496: PUSH
24497: LD_INT 36
24499: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24500: LD_VAR 0 1
24504: PPUSH
24505: LD_VAR 0 3
24509: PPUSH
24510: LD_VAR 0 4
24514: PPUSH
24515: CALL_OW 297
24519: PUSH
24520: LD_VAR 0 14
24524: GREATER
24525: IFFALSE 24529
// exit ;
24527: GO 25054
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24529: LD_ADDR_VAR 0 12
24533: PUSH
24534: LD_VAR 0 2
24538: PPUSH
24539: LD_VAR 0 3
24543: PPUSH
24544: LD_VAR 0 4
24548: PPUSH
24549: LD_VAR 0 5
24553: PPUSH
24554: LD_VAR 0 1
24558: PPUSH
24559: CALL_OW 248
24563: PPUSH
24564: LD_INT 0
24566: PPUSH
24567: CALL 25059 0 6
24571: ST_TO_ADDR
// if not hexes then
24572: LD_VAR 0 12
24576: NOT
24577: IFFALSE 24581
// exit ;
24579: GO 25054
// hex := GetHexInfo ( x , y ) ;
24581: LD_ADDR_VAR 0 15
24585: PUSH
24586: LD_VAR 0 3
24590: PPUSH
24591: LD_VAR 0 4
24595: PPUSH
24596: CALL_OW 546
24600: ST_TO_ADDR
// if hex [ 1 ] then
24601: LD_VAR 0 15
24605: PUSH
24606: LD_INT 1
24608: ARRAY
24609: IFFALSE 24613
// exit ;
24611: GO 25054
// height := hex [ 2 ] ;
24613: LD_ADDR_VAR 0 13
24617: PUSH
24618: LD_VAR 0 15
24622: PUSH
24623: LD_INT 2
24625: ARRAY
24626: ST_TO_ADDR
// for i = 1 to hexes do
24627: LD_ADDR_VAR 0 7
24631: PUSH
24632: DOUBLE
24633: LD_INT 1
24635: DEC
24636: ST_TO_ADDR
24637: LD_VAR 0 12
24641: PUSH
24642: FOR_TO
24643: IFFALSE 24973
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24645: LD_VAR 0 12
24649: PUSH
24650: LD_VAR 0 7
24654: ARRAY
24655: PUSH
24656: LD_INT 1
24658: ARRAY
24659: PPUSH
24660: LD_VAR 0 12
24664: PUSH
24665: LD_VAR 0 7
24669: ARRAY
24670: PUSH
24671: LD_INT 2
24673: ARRAY
24674: PPUSH
24675: CALL_OW 488
24679: NOT
24680: PUSH
24681: LD_VAR 0 12
24685: PUSH
24686: LD_VAR 0 7
24690: ARRAY
24691: PUSH
24692: LD_INT 1
24694: ARRAY
24695: PPUSH
24696: LD_VAR 0 12
24700: PUSH
24701: LD_VAR 0 7
24705: ARRAY
24706: PUSH
24707: LD_INT 2
24709: ARRAY
24710: PPUSH
24711: CALL_OW 428
24715: PUSH
24716: LD_INT 0
24718: GREATER
24719: OR
24720: PUSH
24721: LD_VAR 0 12
24725: PUSH
24726: LD_VAR 0 7
24730: ARRAY
24731: PUSH
24732: LD_INT 1
24734: ARRAY
24735: PPUSH
24736: LD_VAR 0 12
24740: PUSH
24741: LD_VAR 0 7
24745: ARRAY
24746: PUSH
24747: LD_INT 2
24749: ARRAY
24750: PPUSH
24751: CALL_OW 351
24755: OR
24756: IFFALSE 24762
// exit ;
24758: POP
24759: POP
24760: GO 25054
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24762: LD_ADDR_VAR 0 8
24766: PUSH
24767: LD_VAR 0 12
24771: PUSH
24772: LD_VAR 0 7
24776: ARRAY
24777: PUSH
24778: LD_INT 1
24780: ARRAY
24781: PPUSH
24782: LD_VAR 0 12
24786: PUSH
24787: LD_VAR 0 7
24791: ARRAY
24792: PUSH
24793: LD_INT 2
24795: ARRAY
24796: PPUSH
24797: CALL_OW 546
24801: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24802: LD_VAR 0 8
24806: PUSH
24807: LD_INT 1
24809: ARRAY
24810: PUSH
24811: LD_VAR 0 8
24815: PUSH
24816: LD_INT 2
24818: ARRAY
24819: PUSH
24820: LD_VAR 0 13
24824: PUSH
24825: LD_INT 2
24827: PLUS
24828: GREATER
24829: OR
24830: PUSH
24831: LD_VAR 0 8
24835: PUSH
24836: LD_INT 2
24838: ARRAY
24839: PUSH
24840: LD_VAR 0 13
24844: PUSH
24845: LD_INT 2
24847: MINUS
24848: LESS
24849: OR
24850: PUSH
24851: LD_VAR 0 8
24855: PUSH
24856: LD_INT 3
24858: ARRAY
24859: PUSH
24860: LD_INT 0
24862: PUSH
24863: LD_INT 8
24865: PUSH
24866: LD_INT 9
24868: PUSH
24869: LD_INT 10
24871: PUSH
24872: LD_INT 11
24874: PUSH
24875: LD_INT 12
24877: PUSH
24878: LD_INT 13
24880: PUSH
24881: LD_INT 16
24883: PUSH
24884: LD_INT 17
24886: PUSH
24887: LD_INT 18
24889: PUSH
24890: LD_INT 19
24892: PUSH
24893: LD_INT 20
24895: PUSH
24896: LD_INT 21
24898: PUSH
24899: EMPTY
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: LIST
24907: LIST
24908: LIST
24909: LIST
24910: LIST
24911: LIST
24912: LIST
24913: IN
24914: NOT
24915: OR
24916: PUSH
24917: LD_VAR 0 8
24921: PUSH
24922: LD_INT 5
24924: ARRAY
24925: NOT
24926: OR
24927: PUSH
24928: LD_VAR 0 8
24932: PUSH
24933: LD_INT 6
24935: ARRAY
24936: PUSH
24937: LD_INT 1
24939: PUSH
24940: LD_INT 2
24942: PUSH
24943: LD_INT 7
24945: PUSH
24946: LD_INT 9
24948: PUSH
24949: LD_INT 10
24951: PUSH
24952: LD_INT 11
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: LIST
24959: LIST
24960: LIST
24961: LIST
24962: IN
24963: NOT
24964: OR
24965: IFFALSE 24971
// exit ;
24967: POP
24968: POP
24969: GO 25054
// end ;
24971: GO 24642
24973: POP
24974: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24975: LD_VAR 0 9
24979: PPUSH
24980: LD_VAR 0 3
24984: PPUSH
24985: LD_VAR 0 4
24989: PPUSH
24990: LD_INT 20
24992: PPUSH
24993: CALL 17006 0 4
24997: PUSH
24998: LD_INT 4
25000: ARRAY
25001: IFFALSE 25005
// exit ;
25003: GO 25054
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25005: LD_VAR 0 2
25009: PUSH
25010: LD_INT 29
25012: PUSH
25013: LD_INT 30
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: IN
25020: PUSH
25021: LD_VAR 0 3
25025: PPUSH
25026: LD_VAR 0 4
25030: PPUSH
25031: LD_VAR 0 9
25035: PPUSH
25036: CALL_OW 440
25040: NOT
25041: AND
25042: IFFALSE 25046
// exit ;
25044: GO 25054
// result := true ;
25046: LD_ADDR_VAR 0 6
25050: PUSH
25051: LD_INT 1
25053: ST_TO_ADDR
// end ;
25054: LD_VAR 0 6
25058: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25059: LD_INT 0
25061: PPUSH
25062: PPUSH
25063: PPUSH
25064: PPUSH
25065: PPUSH
25066: PPUSH
25067: PPUSH
25068: PPUSH
25069: PPUSH
25070: PPUSH
25071: PPUSH
25072: PPUSH
25073: PPUSH
25074: PPUSH
25075: PPUSH
25076: PPUSH
25077: PPUSH
25078: PPUSH
25079: PPUSH
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
25092: PPUSH
25093: PPUSH
25094: PPUSH
25095: PPUSH
25096: PPUSH
25097: PPUSH
25098: PPUSH
25099: PPUSH
25100: PPUSH
25101: PPUSH
25102: PPUSH
25103: PPUSH
25104: PPUSH
25105: PPUSH
25106: PPUSH
25107: PPUSH
25108: PPUSH
25109: PPUSH
25110: PPUSH
25111: PPUSH
25112: PPUSH
25113: PPUSH
25114: PPUSH
25115: PPUSH
25116: PPUSH
25117: PPUSH
25118: PPUSH
// result = [ ] ;
25119: LD_ADDR_VAR 0 7
25123: PUSH
25124: EMPTY
25125: ST_TO_ADDR
// temp_list = [ ] ;
25126: LD_ADDR_VAR 0 9
25130: PUSH
25131: EMPTY
25132: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25133: LD_VAR 0 4
25137: PUSH
25138: LD_INT 0
25140: PUSH
25141: LD_INT 1
25143: PUSH
25144: LD_INT 2
25146: PUSH
25147: LD_INT 3
25149: PUSH
25150: LD_INT 4
25152: PUSH
25153: LD_INT 5
25155: PUSH
25156: EMPTY
25157: LIST
25158: LIST
25159: LIST
25160: LIST
25161: LIST
25162: LIST
25163: IN
25164: NOT
25165: PUSH
25166: LD_VAR 0 1
25170: PUSH
25171: LD_INT 0
25173: PUSH
25174: LD_INT 1
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: IN
25181: PUSH
25182: LD_VAR 0 5
25186: PUSH
25187: LD_INT 1
25189: PUSH
25190: LD_INT 2
25192: PUSH
25193: LD_INT 3
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: LIST
25200: IN
25201: NOT
25202: AND
25203: OR
25204: IFFALSE 25208
// exit ;
25206: GO 43599
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25208: LD_VAR 0 1
25212: PUSH
25213: LD_INT 6
25215: PUSH
25216: LD_INT 7
25218: PUSH
25219: LD_INT 8
25221: PUSH
25222: LD_INT 13
25224: PUSH
25225: LD_INT 12
25227: PUSH
25228: LD_INT 15
25230: PUSH
25231: LD_INT 11
25233: PUSH
25234: LD_INT 14
25236: PUSH
25237: LD_INT 10
25239: PUSH
25240: EMPTY
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: IN
25251: IFFALSE 25261
// btype = b_lab ;
25253: LD_ADDR_VAR 0 1
25257: PUSH
25258: LD_INT 6
25260: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25261: LD_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: PUSH
25269: LD_INT 1
25271: PUSH
25272: LD_INT 2
25274: PUSH
25275: EMPTY
25276: LIST
25277: LIST
25278: LIST
25279: IN
25280: NOT
25281: PUSH
25282: LD_VAR 0 1
25286: PUSH
25287: LD_INT 0
25289: PUSH
25290: LD_INT 1
25292: PUSH
25293: LD_INT 2
25295: PUSH
25296: LD_INT 3
25298: PUSH
25299: LD_INT 6
25301: PUSH
25302: LD_INT 36
25304: PUSH
25305: LD_INT 4
25307: PUSH
25308: LD_INT 5
25310: PUSH
25311: LD_INT 31
25313: PUSH
25314: LD_INT 32
25316: PUSH
25317: LD_INT 33
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: LIST
25324: LIST
25325: LIST
25326: LIST
25327: LIST
25328: LIST
25329: LIST
25330: LIST
25331: LIST
25332: IN
25333: NOT
25334: PUSH
25335: LD_VAR 0 6
25339: PUSH
25340: LD_INT 1
25342: EQUAL
25343: AND
25344: OR
25345: PUSH
25346: LD_VAR 0 1
25350: PUSH
25351: LD_INT 2
25353: PUSH
25354: LD_INT 3
25356: PUSH
25357: EMPTY
25358: LIST
25359: LIST
25360: IN
25361: NOT
25362: PUSH
25363: LD_VAR 0 6
25367: PUSH
25368: LD_INT 2
25370: EQUAL
25371: AND
25372: OR
25373: IFFALSE 25383
// mode = 0 ;
25375: LD_ADDR_VAR 0 6
25379: PUSH
25380: LD_INT 0
25382: ST_TO_ADDR
// case mode of 0 :
25383: LD_VAR 0 6
25387: PUSH
25388: LD_INT 0
25390: DOUBLE
25391: EQUAL
25392: IFTRUE 25396
25394: GO 36849
25396: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25397: LD_ADDR_VAR 0 11
25401: PUSH
25402: LD_INT 0
25404: PUSH
25405: LD_INT 0
25407: PUSH
25408: EMPTY
25409: LIST
25410: LIST
25411: PUSH
25412: LD_INT 0
25414: PUSH
25415: LD_INT 1
25417: NEG
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: LD_INT 1
25425: PUSH
25426: LD_INT 0
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 1
25435: PUSH
25436: LD_INT 1
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 0
25445: PUSH
25446: LD_INT 1
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: PUSH
25453: LD_INT 1
25455: NEG
25456: PUSH
25457: LD_INT 0
25459: PUSH
25460: EMPTY
25461: LIST
25462: LIST
25463: PUSH
25464: LD_INT 1
25466: NEG
25467: PUSH
25468: LD_INT 1
25470: NEG
25471: PUSH
25472: EMPTY
25473: LIST
25474: LIST
25475: PUSH
25476: LD_INT 1
25478: NEG
25479: PUSH
25480: LD_INT 2
25482: NEG
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PUSH
25488: LD_INT 0
25490: PUSH
25491: LD_INT 2
25493: NEG
25494: PUSH
25495: EMPTY
25496: LIST
25497: LIST
25498: PUSH
25499: LD_INT 1
25501: PUSH
25502: LD_INT 1
25504: NEG
25505: PUSH
25506: EMPTY
25507: LIST
25508: LIST
25509: PUSH
25510: LD_INT 1
25512: PUSH
25513: LD_INT 2
25515: PUSH
25516: EMPTY
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 0
25522: PUSH
25523: LD_INT 2
25525: PUSH
25526: EMPTY
25527: LIST
25528: LIST
25529: PUSH
25530: LD_INT 1
25532: NEG
25533: PUSH
25534: LD_INT 1
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: PUSH
25544: LD_INT 3
25546: PUSH
25547: EMPTY
25548: LIST
25549: LIST
25550: PUSH
25551: LD_INT 0
25553: PUSH
25554: LD_INT 3
25556: PUSH
25557: EMPTY
25558: LIST
25559: LIST
25560: PUSH
25561: LD_INT 1
25563: NEG
25564: PUSH
25565: LD_INT 2
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: LIST
25576: LIST
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25590: LD_ADDR_VAR 0 12
25594: PUSH
25595: LD_INT 0
25597: PUSH
25598: LD_INT 0
25600: PUSH
25601: EMPTY
25602: LIST
25603: LIST
25604: PUSH
25605: LD_INT 0
25607: PUSH
25608: LD_INT 1
25610: NEG
25611: PUSH
25612: EMPTY
25613: LIST
25614: LIST
25615: PUSH
25616: LD_INT 1
25618: PUSH
25619: LD_INT 0
25621: PUSH
25622: EMPTY
25623: LIST
25624: LIST
25625: PUSH
25626: LD_INT 1
25628: PUSH
25629: LD_INT 1
25631: PUSH
25632: EMPTY
25633: LIST
25634: LIST
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: LD_INT 1
25641: PUSH
25642: EMPTY
25643: LIST
25644: LIST
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: LD_INT 0
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: PUSH
25657: LD_INT 1
25659: NEG
25660: PUSH
25661: LD_INT 1
25663: NEG
25664: PUSH
25665: EMPTY
25666: LIST
25667: LIST
25668: PUSH
25669: LD_INT 1
25671: PUSH
25672: LD_INT 1
25674: NEG
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 2
25682: PUSH
25683: LD_INT 0
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 2
25692: PUSH
25693: LD_INT 1
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 1
25702: NEG
25703: PUSH
25704: LD_INT 1
25706: PUSH
25707: EMPTY
25708: LIST
25709: LIST
25710: PUSH
25711: LD_INT 2
25713: NEG
25714: PUSH
25715: LD_INT 0
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: NEG
25725: PUSH
25726: LD_INT 1
25728: NEG
25729: PUSH
25730: EMPTY
25731: LIST
25732: LIST
25733: PUSH
25734: LD_INT 2
25736: NEG
25737: PUSH
25738: LD_INT 1
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PUSH
25745: LD_INT 3
25747: NEG
25748: PUSH
25749: LD_INT 0
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 3
25758: NEG
25759: PUSH
25760: LD_INT 1
25762: NEG
25763: PUSH
25764: EMPTY
25765: LIST
25766: LIST
25767: PUSH
25768: EMPTY
25769: LIST
25770: LIST
25771: LIST
25772: LIST
25773: LIST
25774: LIST
25775: LIST
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: LIST
25781: LIST
25782: LIST
25783: LIST
25784: LIST
25785: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25786: LD_ADDR_VAR 0 13
25790: PUSH
25791: LD_INT 0
25793: PUSH
25794: LD_INT 0
25796: PUSH
25797: EMPTY
25798: LIST
25799: LIST
25800: PUSH
25801: LD_INT 0
25803: PUSH
25804: LD_INT 1
25806: NEG
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: PUSH
25812: LD_INT 1
25814: PUSH
25815: LD_INT 0
25817: PUSH
25818: EMPTY
25819: LIST
25820: LIST
25821: PUSH
25822: LD_INT 1
25824: PUSH
25825: LD_INT 1
25827: PUSH
25828: EMPTY
25829: LIST
25830: LIST
25831: PUSH
25832: LD_INT 0
25834: PUSH
25835: LD_INT 1
25837: PUSH
25838: EMPTY
25839: LIST
25840: LIST
25841: PUSH
25842: LD_INT 1
25844: NEG
25845: PUSH
25846: LD_INT 0
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: LD_INT 1
25855: NEG
25856: PUSH
25857: LD_INT 1
25859: NEG
25860: PUSH
25861: EMPTY
25862: LIST
25863: LIST
25864: PUSH
25865: LD_INT 1
25867: NEG
25868: PUSH
25869: LD_INT 2
25871: NEG
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 2
25879: PUSH
25880: LD_INT 1
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: PUSH
25887: LD_INT 2
25889: PUSH
25890: LD_INT 2
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 2
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 2
25909: NEG
25910: PUSH
25911: LD_INT 1
25913: NEG
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 2
25921: NEG
25922: PUSH
25923: LD_INT 2
25925: NEG
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: PUSH
25931: LD_INT 2
25933: NEG
25934: PUSH
25935: LD_INT 3
25937: NEG
25938: PUSH
25939: EMPTY
25940: LIST
25941: LIST
25942: PUSH
25943: LD_INT 3
25945: NEG
25946: PUSH
25947: LD_INT 2
25949: NEG
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: PUSH
25955: LD_INT 3
25957: NEG
25958: PUSH
25959: LD_INT 3
25961: NEG
25962: PUSH
25963: EMPTY
25964: LIST
25965: LIST
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: LIST
25971: LIST
25972: LIST
25973: LIST
25974: LIST
25975: LIST
25976: LIST
25977: LIST
25978: LIST
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25985: LD_ADDR_VAR 0 14
25989: PUSH
25990: LD_INT 0
25992: PUSH
25993: LD_INT 0
25995: PUSH
25996: EMPTY
25997: LIST
25998: LIST
25999: PUSH
26000: LD_INT 0
26002: PUSH
26003: LD_INT 1
26005: NEG
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: PUSH
26014: LD_INT 0
26016: PUSH
26017: EMPTY
26018: LIST
26019: LIST
26020: PUSH
26021: LD_INT 1
26023: PUSH
26024: LD_INT 1
26026: PUSH
26027: EMPTY
26028: LIST
26029: LIST
26030: PUSH
26031: LD_INT 0
26033: PUSH
26034: LD_INT 1
26036: PUSH
26037: EMPTY
26038: LIST
26039: LIST
26040: PUSH
26041: LD_INT 1
26043: NEG
26044: PUSH
26045: LD_INT 0
26047: PUSH
26048: EMPTY
26049: LIST
26050: LIST
26051: PUSH
26052: LD_INT 1
26054: NEG
26055: PUSH
26056: LD_INT 1
26058: NEG
26059: PUSH
26060: EMPTY
26061: LIST
26062: LIST
26063: PUSH
26064: LD_INT 1
26066: NEG
26067: PUSH
26068: LD_INT 2
26070: NEG
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 2
26081: NEG
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 1
26092: NEG
26093: PUSH
26094: EMPTY
26095: LIST
26096: LIST
26097: PUSH
26098: LD_INT 1
26100: PUSH
26101: LD_INT 2
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: PUSH
26108: LD_INT 0
26110: PUSH
26111: LD_INT 2
26113: PUSH
26114: EMPTY
26115: LIST
26116: LIST
26117: PUSH
26118: LD_INT 1
26120: NEG
26121: PUSH
26122: LD_INT 1
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: PUSH
26129: LD_INT 1
26131: NEG
26132: PUSH
26133: LD_INT 3
26135: NEG
26136: PUSH
26137: EMPTY
26138: LIST
26139: LIST
26140: PUSH
26141: LD_INT 0
26143: PUSH
26144: LD_INT 3
26146: NEG
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 1
26154: PUSH
26155: LD_INT 2
26157: NEG
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: LIST
26177: LIST
26178: LIST
26179: LIST
26180: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26181: LD_ADDR_VAR 0 15
26185: PUSH
26186: LD_INT 0
26188: PUSH
26189: LD_INT 0
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: LD_INT 1
26201: NEG
26202: PUSH
26203: EMPTY
26204: LIST
26205: LIST
26206: PUSH
26207: LD_INT 1
26209: PUSH
26210: LD_INT 0
26212: PUSH
26213: EMPTY
26214: LIST
26215: LIST
26216: PUSH
26217: LD_INT 1
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 0
26229: PUSH
26230: LD_INT 1
26232: PUSH
26233: EMPTY
26234: LIST
26235: LIST
26236: PUSH
26237: LD_INT 1
26239: NEG
26240: PUSH
26241: LD_INT 0
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PUSH
26248: LD_INT 1
26250: NEG
26251: PUSH
26252: LD_INT 1
26254: NEG
26255: PUSH
26256: EMPTY
26257: LIST
26258: LIST
26259: PUSH
26260: LD_INT 1
26262: PUSH
26263: LD_INT 1
26265: NEG
26266: PUSH
26267: EMPTY
26268: LIST
26269: LIST
26270: PUSH
26271: LD_INT 2
26273: PUSH
26274: LD_INT 0
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: PUSH
26281: LD_INT 2
26283: PUSH
26284: LD_INT 1
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: PUSH
26291: LD_INT 1
26293: NEG
26294: PUSH
26295: LD_INT 1
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: NEG
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: EMPTY
26310: LIST
26311: LIST
26312: PUSH
26313: LD_INT 2
26315: NEG
26316: PUSH
26317: LD_INT 1
26319: NEG
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: LD_INT 2
26327: PUSH
26328: LD_INT 1
26330: NEG
26331: PUSH
26332: EMPTY
26333: LIST
26334: LIST
26335: PUSH
26336: LD_INT 3
26338: PUSH
26339: LD_INT 0
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: PUSH
26346: LD_INT 3
26348: PUSH
26349: LD_INT 1
26351: PUSH
26352: EMPTY
26353: LIST
26354: LIST
26355: PUSH
26356: EMPTY
26357: LIST
26358: LIST
26359: LIST
26360: LIST
26361: LIST
26362: LIST
26363: LIST
26364: LIST
26365: LIST
26366: LIST
26367: LIST
26368: LIST
26369: LIST
26370: LIST
26371: LIST
26372: LIST
26373: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26374: LD_ADDR_VAR 0 16
26378: PUSH
26379: LD_INT 0
26381: PUSH
26382: LD_INT 0
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: PUSH
26389: LD_INT 0
26391: PUSH
26392: LD_INT 1
26394: NEG
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: LD_INT 1
26402: PUSH
26403: LD_INT 0
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: PUSH
26410: LD_INT 1
26412: PUSH
26413: LD_INT 1
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 0
26422: PUSH
26423: LD_INT 1
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: PUSH
26430: LD_INT 1
26432: NEG
26433: PUSH
26434: LD_INT 0
26436: PUSH
26437: EMPTY
26438: LIST
26439: LIST
26440: PUSH
26441: LD_INT 1
26443: NEG
26444: PUSH
26445: LD_INT 1
26447: NEG
26448: PUSH
26449: EMPTY
26450: LIST
26451: LIST
26452: PUSH
26453: LD_INT 1
26455: NEG
26456: PUSH
26457: LD_INT 2
26459: NEG
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 2
26467: PUSH
26468: LD_INT 1
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 2
26477: PUSH
26478: LD_INT 2
26480: PUSH
26481: EMPTY
26482: LIST
26483: LIST
26484: PUSH
26485: LD_INT 1
26487: PUSH
26488: LD_INT 2
26490: PUSH
26491: EMPTY
26492: LIST
26493: LIST
26494: PUSH
26495: LD_INT 2
26497: NEG
26498: PUSH
26499: LD_INT 1
26501: NEG
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_INT 2
26509: NEG
26510: PUSH
26511: LD_INT 2
26513: NEG
26514: PUSH
26515: EMPTY
26516: LIST
26517: LIST
26518: PUSH
26519: LD_INT 3
26521: PUSH
26522: LD_INT 2
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 3
26531: PUSH
26532: LD_INT 3
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 2
26541: PUSH
26542: LD_INT 3
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26567: LD_ADDR_VAR 0 17
26571: PUSH
26572: LD_INT 0
26574: PUSH
26575: LD_INT 0
26577: PUSH
26578: EMPTY
26579: LIST
26580: LIST
26581: PUSH
26582: LD_INT 0
26584: PUSH
26585: LD_INT 1
26587: NEG
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 1
26595: PUSH
26596: LD_INT 0
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 1
26605: PUSH
26606: LD_INT 1
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 0
26615: PUSH
26616: LD_INT 1
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 1
26625: NEG
26626: PUSH
26627: LD_INT 0
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 1
26636: NEG
26637: PUSH
26638: LD_INT 1
26640: NEG
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: LD_INT 1
26648: NEG
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: EMPTY
26655: LIST
26656: LIST
26657: PUSH
26658: LD_INT 0
26660: PUSH
26661: LD_INT 2
26663: NEG
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 1
26671: PUSH
26672: LD_INT 1
26674: NEG
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: PUSH
26680: LD_INT 2
26682: PUSH
26683: LD_INT 0
26685: PUSH
26686: EMPTY
26687: LIST
26688: LIST
26689: PUSH
26690: LD_INT 2
26692: PUSH
26693: LD_INT 1
26695: PUSH
26696: EMPTY
26697: LIST
26698: LIST
26699: PUSH
26700: LD_INT 2
26702: PUSH
26703: LD_INT 2
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PUSH
26710: LD_INT 1
26712: PUSH
26713: LD_INT 2
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: PUSH
26720: LD_INT 0
26722: PUSH
26723: LD_INT 2
26725: PUSH
26726: EMPTY
26727: LIST
26728: LIST
26729: PUSH
26730: LD_INT 1
26732: NEG
26733: PUSH
26734: LD_INT 1
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 2
26743: NEG
26744: PUSH
26745: LD_INT 0
26747: PUSH
26748: EMPTY
26749: LIST
26750: LIST
26751: PUSH
26752: LD_INT 2
26754: NEG
26755: PUSH
26756: LD_INT 1
26758: NEG
26759: PUSH
26760: EMPTY
26761: LIST
26762: LIST
26763: PUSH
26764: LD_INT 2
26766: NEG
26767: PUSH
26768: LD_INT 2
26770: NEG
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: LIST
26781: LIST
26782: LIST
26783: LIST
26784: LIST
26785: LIST
26786: LIST
26787: LIST
26788: LIST
26789: LIST
26790: LIST
26791: LIST
26792: LIST
26793: LIST
26794: LIST
26795: LIST
26796: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26797: LD_ADDR_VAR 0 18
26801: PUSH
26802: LD_INT 0
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: EMPTY
26809: LIST
26810: LIST
26811: PUSH
26812: LD_INT 0
26814: PUSH
26815: LD_INT 1
26817: NEG
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: LD_INT 1
26825: PUSH
26826: LD_INT 0
26828: PUSH
26829: EMPTY
26830: LIST
26831: LIST
26832: PUSH
26833: LD_INT 1
26835: PUSH
26836: LD_INT 1
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: PUSH
26843: LD_INT 0
26845: PUSH
26846: LD_INT 1
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: LD_INT 1
26855: NEG
26856: PUSH
26857: LD_INT 0
26859: PUSH
26860: EMPTY
26861: LIST
26862: LIST
26863: PUSH
26864: LD_INT 1
26866: NEG
26867: PUSH
26868: LD_INT 1
26870: NEG
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 1
26878: NEG
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: EMPTY
26885: LIST
26886: LIST
26887: PUSH
26888: LD_INT 0
26890: PUSH
26891: LD_INT 2
26893: NEG
26894: PUSH
26895: EMPTY
26896: LIST
26897: LIST
26898: PUSH
26899: LD_INT 1
26901: PUSH
26902: LD_INT 1
26904: NEG
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: PUSH
26910: LD_INT 2
26912: PUSH
26913: LD_INT 0
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 2
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: LD_INT 2
26932: PUSH
26933: LD_INT 2
26935: PUSH
26936: EMPTY
26937: LIST
26938: LIST
26939: PUSH
26940: LD_INT 1
26942: PUSH
26943: LD_INT 2
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 0
26952: PUSH
26953: LD_INT 2
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 1
26962: NEG
26963: PUSH
26964: LD_INT 1
26966: PUSH
26967: EMPTY
26968: LIST
26969: LIST
26970: PUSH
26971: LD_INT 2
26973: NEG
26974: PUSH
26975: LD_INT 0
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 2
26984: NEG
26985: PUSH
26986: LD_INT 1
26988: NEG
26989: PUSH
26990: EMPTY
26991: LIST
26992: LIST
26993: PUSH
26994: LD_INT 2
26996: NEG
26997: PUSH
26998: LD_INT 2
27000: NEG
27001: PUSH
27002: EMPTY
27003: LIST
27004: LIST
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: LIST
27010: LIST
27011: LIST
27012: LIST
27013: LIST
27014: LIST
27015: LIST
27016: LIST
27017: LIST
27018: LIST
27019: LIST
27020: LIST
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27027: LD_ADDR_VAR 0 19
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: LD_INT 0
27037: PUSH
27038: EMPTY
27039: LIST
27040: LIST
27041: PUSH
27042: LD_INT 0
27044: PUSH
27045: LD_INT 1
27047: NEG
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 1
27055: PUSH
27056: LD_INT 0
27058: PUSH
27059: EMPTY
27060: LIST
27061: LIST
27062: PUSH
27063: LD_INT 1
27065: PUSH
27066: LD_INT 1
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: PUSH
27073: LD_INT 0
27075: PUSH
27076: LD_INT 1
27078: PUSH
27079: EMPTY
27080: LIST
27081: LIST
27082: PUSH
27083: LD_INT 1
27085: NEG
27086: PUSH
27087: LD_INT 0
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 1
27100: NEG
27101: PUSH
27102: EMPTY
27103: LIST
27104: LIST
27105: PUSH
27106: LD_INT 1
27108: NEG
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 0
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 1
27131: PUSH
27132: LD_INT 1
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: LD_INT 2
27142: PUSH
27143: LD_INT 0
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: PUSH
27150: LD_INT 2
27152: PUSH
27153: LD_INT 1
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 2
27162: PUSH
27163: LD_INT 2
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: LD_INT 1
27172: PUSH
27173: LD_INT 2
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 0
27182: PUSH
27183: LD_INT 2
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 1
27192: NEG
27193: PUSH
27194: LD_INT 1
27196: PUSH
27197: EMPTY
27198: LIST
27199: LIST
27200: PUSH
27201: LD_INT 2
27203: NEG
27204: PUSH
27205: LD_INT 0
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: LD_INT 2
27214: NEG
27215: PUSH
27216: LD_INT 1
27218: NEG
27219: PUSH
27220: EMPTY
27221: LIST
27222: LIST
27223: PUSH
27224: LD_INT 2
27226: NEG
27227: PUSH
27228: LD_INT 2
27230: NEG
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: LIST
27240: LIST
27241: LIST
27242: LIST
27243: LIST
27244: LIST
27245: LIST
27246: LIST
27247: LIST
27248: LIST
27249: LIST
27250: LIST
27251: LIST
27252: LIST
27253: LIST
27254: LIST
27255: LIST
27256: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27257: LD_ADDR_VAR 0 20
27261: PUSH
27262: LD_INT 0
27264: PUSH
27265: LD_INT 0
27267: PUSH
27268: EMPTY
27269: LIST
27270: LIST
27271: PUSH
27272: LD_INT 0
27274: PUSH
27275: LD_INT 1
27277: NEG
27278: PUSH
27279: EMPTY
27280: LIST
27281: LIST
27282: PUSH
27283: LD_INT 1
27285: PUSH
27286: LD_INT 0
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PUSH
27293: LD_INT 1
27295: PUSH
27296: LD_INT 1
27298: PUSH
27299: EMPTY
27300: LIST
27301: LIST
27302: PUSH
27303: LD_INT 0
27305: PUSH
27306: LD_INT 1
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: PUSH
27313: LD_INT 1
27315: NEG
27316: PUSH
27317: LD_INT 0
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PUSH
27324: LD_INT 1
27326: NEG
27327: PUSH
27328: LD_INT 1
27330: NEG
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PUSH
27348: LD_INT 0
27350: PUSH
27351: LD_INT 2
27353: NEG
27354: PUSH
27355: EMPTY
27356: LIST
27357: LIST
27358: PUSH
27359: LD_INT 1
27361: PUSH
27362: LD_INT 1
27364: NEG
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 2
27372: PUSH
27373: LD_INT 0
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 2
27382: PUSH
27383: LD_INT 1
27385: PUSH
27386: EMPTY
27387: LIST
27388: LIST
27389: PUSH
27390: LD_INT 2
27392: PUSH
27393: LD_INT 2
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: PUSH
27400: LD_INT 1
27402: PUSH
27403: LD_INT 2
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: PUSH
27410: LD_INT 0
27412: PUSH
27413: LD_INT 2
27415: PUSH
27416: EMPTY
27417: LIST
27418: LIST
27419: PUSH
27420: LD_INT 1
27422: NEG
27423: PUSH
27424: LD_INT 1
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: LD_INT 2
27433: NEG
27434: PUSH
27435: LD_INT 0
27437: PUSH
27438: EMPTY
27439: LIST
27440: LIST
27441: PUSH
27442: LD_INT 2
27444: NEG
27445: PUSH
27446: LD_INT 1
27448: NEG
27449: PUSH
27450: EMPTY
27451: LIST
27452: LIST
27453: PUSH
27454: LD_INT 2
27456: NEG
27457: PUSH
27458: LD_INT 2
27460: NEG
27461: PUSH
27462: EMPTY
27463: LIST
27464: LIST
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: LIST
27472: LIST
27473: LIST
27474: LIST
27475: LIST
27476: LIST
27477: LIST
27478: LIST
27479: LIST
27480: LIST
27481: LIST
27482: LIST
27483: LIST
27484: LIST
27485: LIST
27486: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27487: LD_ADDR_VAR 0 21
27491: PUSH
27492: LD_INT 0
27494: PUSH
27495: LD_INT 0
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: LD_INT 0
27504: PUSH
27505: LD_INT 1
27507: NEG
27508: PUSH
27509: EMPTY
27510: LIST
27511: LIST
27512: PUSH
27513: LD_INT 1
27515: PUSH
27516: LD_INT 0
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 1
27525: PUSH
27526: LD_INT 1
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 0
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 1
27545: NEG
27546: PUSH
27547: LD_INT 0
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 1
27556: NEG
27557: PUSH
27558: LD_INT 1
27560: NEG
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: LD_INT 0
27580: PUSH
27581: LD_INT 2
27583: NEG
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 1
27591: PUSH
27592: LD_INT 1
27594: NEG
27595: PUSH
27596: EMPTY
27597: LIST
27598: LIST
27599: PUSH
27600: LD_INT 2
27602: PUSH
27603: LD_INT 0
27605: PUSH
27606: EMPTY
27607: LIST
27608: LIST
27609: PUSH
27610: LD_INT 2
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: EMPTY
27617: LIST
27618: LIST
27619: PUSH
27620: LD_INT 2
27622: PUSH
27623: LD_INT 2
27625: PUSH
27626: EMPTY
27627: LIST
27628: LIST
27629: PUSH
27630: LD_INT 1
27632: PUSH
27633: LD_INT 2
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PUSH
27640: LD_INT 0
27642: PUSH
27643: LD_INT 2
27645: PUSH
27646: EMPTY
27647: LIST
27648: LIST
27649: PUSH
27650: LD_INT 1
27652: NEG
27653: PUSH
27654: LD_INT 1
27656: PUSH
27657: EMPTY
27658: LIST
27659: LIST
27660: PUSH
27661: LD_INT 2
27663: NEG
27664: PUSH
27665: LD_INT 0
27667: PUSH
27668: EMPTY
27669: LIST
27670: LIST
27671: PUSH
27672: LD_INT 2
27674: NEG
27675: PUSH
27676: LD_INT 1
27678: NEG
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: PUSH
27684: LD_INT 2
27686: NEG
27687: PUSH
27688: LD_INT 2
27690: NEG
27691: PUSH
27692: EMPTY
27693: LIST
27694: LIST
27695: PUSH
27696: EMPTY
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: LIST
27702: LIST
27703: LIST
27704: LIST
27705: LIST
27706: LIST
27707: LIST
27708: LIST
27709: LIST
27710: LIST
27711: LIST
27712: LIST
27713: LIST
27714: LIST
27715: LIST
27716: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27717: LD_ADDR_VAR 0 22
27721: PUSH
27722: LD_INT 0
27724: PUSH
27725: LD_INT 0
27727: PUSH
27728: EMPTY
27729: LIST
27730: LIST
27731: PUSH
27732: LD_INT 0
27734: PUSH
27735: LD_INT 1
27737: NEG
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PUSH
27743: LD_INT 1
27745: PUSH
27746: LD_INT 0
27748: PUSH
27749: EMPTY
27750: LIST
27751: LIST
27752: PUSH
27753: LD_INT 1
27755: PUSH
27756: LD_INT 1
27758: PUSH
27759: EMPTY
27760: LIST
27761: LIST
27762: PUSH
27763: LD_INT 0
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 1
27775: NEG
27776: PUSH
27777: LD_INT 0
27779: PUSH
27780: EMPTY
27781: LIST
27782: LIST
27783: PUSH
27784: LD_INT 1
27786: NEG
27787: PUSH
27788: LD_INT 1
27790: NEG
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 1
27798: NEG
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: EMPTY
27805: LIST
27806: LIST
27807: PUSH
27808: LD_INT 0
27810: PUSH
27811: LD_INT 2
27813: NEG
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 1
27821: PUSH
27822: LD_INT 1
27824: NEG
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: PUSH
27830: LD_INT 2
27832: PUSH
27833: LD_INT 0
27835: PUSH
27836: EMPTY
27837: LIST
27838: LIST
27839: PUSH
27840: LD_INT 2
27842: PUSH
27843: LD_INT 1
27845: PUSH
27846: EMPTY
27847: LIST
27848: LIST
27849: PUSH
27850: LD_INT 2
27852: PUSH
27853: LD_INT 2
27855: PUSH
27856: EMPTY
27857: LIST
27858: LIST
27859: PUSH
27860: LD_INT 1
27862: PUSH
27863: LD_INT 2
27865: PUSH
27866: EMPTY
27867: LIST
27868: LIST
27869: PUSH
27870: LD_INT 0
27872: PUSH
27873: LD_INT 2
27875: PUSH
27876: EMPTY
27877: LIST
27878: LIST
27879: PUSH
27880: LD_INT 1
27882: NEG
27883: PUSH
27884: LD_INT 1
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: LD_INT 2
27893: NEG
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 2
27904: NEG
27905: PUSH
27906: LD_INT 1
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 2
27916: NEG
27917: PUSH
27918: LD_INT 2
27920: NEG
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: LIST
27933: LIST
27934: LIST
27935: LIST
27936: LIST
27937: LIST
27938: LIST
27939: LIST
27940: LIST
27941: LIST
27942: LIST
27943: LIST
27944: LIST
27945: LIST
27946: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27947: LD_ADDR_VAR 0 23
27951: PUSH
27952: LD_INT 0
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: EMPTY
27959: LIST
27960: LIST
27961: PUSH
27962: LD_INT 0
27964: PUSH
27965: LD_INT 1
27967: NEG
27968: PUSH
27969: EMPTY
27970: LIST
27971: LIST
27972: PUSH
27973: LD_INT 1
27975: PUSH
27976: LD_INT 0
27978: PUSH
27979: EMPTY
27980: LIST
27981: LIST
27982: PUSH
27983: LD_INT 1
27985: PUSH
27986: LD_INT 1
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: PUSH
27993: LD_INT 0
27995: PUSH
27996: LD_INT 1
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PUSH
28003: LD_INT 1
28005: NEG
28006: PUSH
28007: LD_INT 0
28009: PUSH
28010: EMPTY
28011: LIST
28012: LIST
28013: PUSH
28014: LD_INT 1
28016: NEG
28017: PUSH
28018: LD_INT 1
28020: NEG
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 1
28028: NEG
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 0
28040: PUSH
28041: LD_INT 2
28043: NEG
28044: PUSH
28045: EMPTY
28046: LIST
28047: LIST
28048: PUSH
28049: LD_INT 1
28051: PUSH
28052: LD_INT 1
28054: NEG
28055: PUSH
28056: EMPTY
28057: LIST
28058: LIST
28059: PUSH
28060: LD_INT 2
28062: PUSH
28063: LD_INT 0
28065: PUSH
28066: EMPTY
28067: LIST
28068: LIST
28069: PUSH
28070: LD_INT 2
28072: PUSH
28073: LD_INT 1
28075: PUSH
28076: EMPTY
28077: LIST
28078: LIST
28079: PUSH
28080: LD_INT 2
28082: PUSH
28083: LD_INT 2
28085: PUSH
28086: EMPTY
28087: LIST
28088: LIST
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: LD_INT 2
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: PUSH
28100: LD_INT 0
28102: PUSH
28103: LD_INT 2
28105: PUSH
28106: EMPTY
28107: LIST
28108: LIST
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: LD_INT 1
28116: PUSH
28117: EMPTY
28118: LIST
28119: LIST
28120: PUSH
28121: LD_INT 2
28123: NEG
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 2
28134: NEG
28135: PUSH
28136: LD_INT 1
28138: NEG
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 2
28146: NEG
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: EMPTY
28153: LIST
28154: LIST
28155: PUSH
28156: LD_INT 2
28158: NEG
28159: PUSH
28160: LD_INT 3
28162: NEG
28163: PUSH
28164: EMPTY
28165: LIST
28166: LIST
28167: PUSH
28168: LD_INT 1
28170: NEG
28171: PUSH
28172: LD_INT 3
28174: NEG
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: PUSH
28183: LD_INT 2
28185: NEG
28186: PUSH
28187: EMPTY
28188: LIST
28189: LIST
28190: PUSH
28191: LD_INT 2
28193: PUSH
28194: LD_INT 1
28196: NEG
28197: PUSH
28198: EMPTY
28199: LIST
28200: LIST
28201: PUSH
28202: EMPTY
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: LIST
28212: LIST
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: LIST
28218: LIST
28219: LIST
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28227: LD_ADDR_VAR 0 24
28231: PUSH
28232: LD_INT 0
28234: PUSH
28235: LD_INT 0
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 1
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 1
28255: PUSH
28256: LD_INT 0
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 1
28265: PUSH
28266: LD_INT 1
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 0
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: LD_INT 0
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 1
28296: NEG
28297: PUSH
28298: LD_INT 1
28300: NEG
28301: PUSH
28302: EMPTY
28303: LIST
28304: LIST
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: EMPTY
28315: LIST
28316: LIST
28317: PUSH
28318: LD_INT 0
28320: PUSH
28321: LD_INT 2
28323: NEG
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 1
28331: PUSH
28332: LD_INT 1
28334: NEG
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: LD_INT 2
28342: PUSH
28343: LD_INT 0
28345: PUSH
28346: EMPTY
28347: LIST
28348: LIST
28349: PUSH
28350: LD_INT 2
28352: PUSH
28353: LD_INT 1
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: LD_INT 2
28362: PUSH
28363: LD_INT 2
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 1
28372: PUSH
28373: LD_INT 2
28375: PUSH
28376: EMPTY
28377: LIST
28378: LIST
28379: PUSH
28380: LD_INT 0
28382: PUSH
28383: LD_INT 2
28385: PUSH
28386: EMPTY
28387: LIST
28388: LIST
28389: PUSH
28390: LD_INT 1
28392: NEG
28393: PUSH
28394: LD_INT 1
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: PUSH
28401: LD_INT 2
28403: NEG
28404: PUSH
28405: LD_INT 0
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: PUSH
28412: LD_INT 2
28414: NEG
28415: PUSH
28416: LD_INT 1
28418: NEG
28419: PUSH
28420: EMPTY
28421: LIST
28422: LIST
28423: PUSH
28424: LD_INT 2
28426: NEG
28427: PUSH
28428: LD_INT 2
28430: NEG
28431: PUSH
28432: EMPTY
28433: LIST
28434: LIST
28435: PUSH
28436: LD_INT 1
28438: PUSH
28439: LD_INT 2
28441: NEG
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 2
28449: PUSH
28450: LD_INT 1
28452: NEG
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: PUSH
28458: LD_INT 3
28460: PUSH
28461: LD_INT 1
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 3
28470: PUSH
28471: LD_INT 2
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: LIST
28489: LIST
28490: LIST
28491: LIST
28492: LIST
28493: LIST
28494: LIST
28495: LIST
28496: LIST
28497: LIST
28498: LIST
28499: LIST
28500: LIST
28501: LIST
28502: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28503: LD_ADDR_VAR 0 25
28507: PUSH
28508: LD_INT 0
28510: PUSH
28511: LD_INT 0
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 0
28520: PUSH
28521: LD_INT 1
28523: NEG
28524: PUSH
28525: EMPTY
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 1
28531: PUSH
28532: LD_INT 0
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 1
28541: PUSH
28542: LD_INT 1
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 0
28551: PUSH
28552: LD_INT 1
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 1
28561: NEG
28562: PUSH
28563: LD_INT 0
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 1
28572: NEG
28573: PUSH
28574: LD_INT 1
28576: NEG
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 1
28584: NEG
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 0
28596: PUSH
28597: LD_INT 2
28599: NEG
28600: PUSH
28601: EMPTY
28602: LIST
28603: LIST
28604: PUSH
28605: LD_INT 1
28607: PUSH
28608: LD_INT 1
28610: NEG
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: PUSH
28616: LD_INT 2
28618: PUSH
28619: LD_INT 0
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 2
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: PUSH
28636: LD_INT 2
28638: PUSH
28639: LD_INT 2
28641: PUSH
28642: EMPTY
28643: LIST
28644: LIST
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: LD_INT 2
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 0
28658: PUSH
28659: LD_INT 2
28661: PUSH
28662: EMPTY
28663: LIST
28664: LIST
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: PUSH
28670: LD_INT 1
28672: PUSH
28673: EMPTY
28674: LIST
28675: LIST
28676: PUSH
28677: LD_INT 2
28679: NEG
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 2
28690: NEG
28691: PUSH
28692: LD_INT 1
28694: NEG
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: NEG
28703: PUSH
28704: LD_INT 2
28706: NEG
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 3
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 3
28724: PUSH
28725: LD_INT 2
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 2
28734: PUSH
28735: LD_INT 3
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: PUSH
28745: LD_INT 3
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: LIST
28757: LIST
28758: LIST
28759: LIST
28760: LIST
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28777: LD_ADDR_VAR 0 26
28781: PUSH
28782: LD_INT 0
28784: PUSH
28785: LD_INT 0
28787: PUSH
28788: EMPTY
28789: LIST
28790: LIST
28791: PUSH
28792: LD_INT 0
28794: PUSH
28795: LD_INT 1
28797: NEG
28798: PUSH
28799: EMPTY
28800: LIST
28801: LIST
28802: PUSH
28803: LD_INT 1
28805: PUSH
28806: LD_INT 0
28808: PUSH
28809: EMPTY
28810: LIST
28811: LIST
28812: PUSH
28813: LD_INT 1
28815: PUSH
28816: LD_INT 1
28818: PUSH
28819: EMPTY
28820: LIST
28821: LIST
28822: PUSH
28823: LD_INT 0
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 1
28835: NEG
28836: PUSH
28837: LD_INT 0
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: LD_INT 1
28846: NEG
28847: PUSH
28848: LD_INT 1
28850: NEG
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: LD_INT 0
28870: PUSH
28871: LD_INT 2
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: PUSH
28882: LD_INT 1
28884: NEG
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: LD_INT 2
28892: PUSH
28893: LD_INT 0
28895: PUSH
28896: EMPTY
28897: LIST
28898: LIST
28899: PUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 1
28905: PUSH
28906: EMPTY
28907: LIST
28908: LIST
28909: PUSH
28910: LD_INT 2
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 1
28922: PUSH
28923: LD_INT 2
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 0
28932: PUSH
28933: LD_INT 2
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 1
28942: NEG
28943: PUSH
28944: LD_INT 1
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: PUSH
28951: LD_INT 2
28953: NEG
28954: PUSH
28955: LD_INT 0
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 2
28964: NEG
28965: PUSH
28966: LD_INT 1
28968: NEG
28969: PUSH
28970: EMPTY
28971: LIST
28972: LIST
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: LD_INT 2
28980: NEG
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PUSH
28986: LD_INT 2
28988: PUSH
28989: LD_INT 3
28991: PUSH
28992: EMPTY
28993: LIST
28994: LIST
28995: PUSH
28996: LD_INT 1
28998: PUSH
28999: LD_INT 3
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 2
29012: PUSH
29013: EMPTY
29014: LIST
29015: LIST
29016: PUSH
29017: LD_INT 2
29019: NEG
29020: PUSH
29021: LD_INT 1
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PUSH
29028: EMPTY
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: LIST
29037: LIST
29038: LIST
29039: LIST
29040: LIST
29041: LIST
29042: LIST
29043: LIST
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29053: LD_ADDR_VAR 0 27
29057: PUSH
29058: LD_INT 0
29060: PUSH
29061: LD_INT 0
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 0
29070: PUSH
29071: LD_INT 1
29073: NEG
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: LD_INT 0
29084: PUSH
29085: EMPTY
29086: LIST
29087: LIST
29088: PUSH
29089: LD_INT 1
29091: PUSH
29092: LD_INT 1
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 1
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: NEG
29112: PUSH
29113: LD_INT 0
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: NEG
29123: PUSH
29124: LD_INT 1
29126: NEG
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 1
29134: NEG
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: EMPTY
29141: LIST
29142: LIST
29143: PUSH
29144: LD_INT 0
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 1
29157: PUSH
29158: LD_INT 1
29160: NEG
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 2
29168: PUSH
29169: LD_INT 0
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 2
29178: PUSH
29179: LD_INT 1
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 2
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 2
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: LD_INT 1
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 2
29229: NEG
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 2
29240: NEG
29241: PUSH
29242: LD_INT 1
29244: NEG
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: PUSH
29250: LD_INT 2
29252: NEG
29253: PUSH
29254: LD_INT 2
29256: NEG
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: LD_INT 2
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: LD_INT 2
29275: NEG
29276: PUSH
29277: LD_INT 1
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 3
29286: NEG
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: EMPTY
29293: LIST
29294: LIST
29295: PUSH
29296: LD_INT 3
29298: NEG
29299: PUSH
29300: LD_INT 2
29302: NEG
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: LIST
29312: LIST
29313: LIST
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29333: LD_ADDR_VAR 0 28
29337: PUSH
29338: LD_INT 0
29340: PUSH
29341: LD_INT 0
29343: PUSH
29344: EMPTY
29345: LIST
29346: LIST
29347: PUSH
29348: LD_INT 0
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 1
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: LD_INT 1
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 1
29391: NEG
29392: PUSH
29393: LD_INT 0
29395: PUSH
29396: EMPTY
29397: LIST
29398: LIST
29399: PUSH
29400: LD_INT 1
29402: NEG
29403: PUSH
29404: LD_INT 1
29406: NEG
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: LD_INT 2
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: LD_INT 1
29440: NEG
29441: PUSH
29442: EMPTY
29443: LIST
29444: LIST
29445: PUSH
29446: LD_INT 2
29448: PUSH
29449: LD_INT 0
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 2
29458: PUSH
29459: LD_INT 1
29461: PUSH
29462: EMPTY
29463: LIST
29464: LIST
29465: PUSH
29466: LD_INT 2
29468: PUSH
29469: LD_INT 2
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: LD_INT 1
29478: PUSH
29479: LD_INT 2
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: LD_INT 2
29491: PUSH
29492: EMPTY
29493: LIST
29494: LIST
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: LD_INT 1
29502: PUSH
29503: EMPTY
29504: LIST
29505: LIST
29506: PUSH
29507: LD_INT 2
29509: NEG
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 2
29520: NEG
29521: PUSH
29522: LD_INT 1
29524: NEG
29525: PUSH
29526: EMPTY
29527: LIST
29528: LIST
29529: PUSH
29530: LD_INT 2
29532: NEG
29533: PUSH
29534: LD_INT 2
29536: NEG
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 2
29544: NEG
29545: PUSH
29546: LD_INT 3
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: LD_INT 3
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 3
29568: NEG
29569: PUSH
29570: LD_INT 1
29572: NEG
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 3
29580: NEG
29581: PUSH
29582: LD_INT 2
29584: NEG
29585: PUSH
29586: EMPTY
29587: LIST
29588: LIST
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: LIST
29594: LIST
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29615: LD_ADDR_VAR 0 29
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: LD_INT 0
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 1
29635: NEG
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 0
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 1
29673: NEG
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 1
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 1
29696: NEG
29697: PUSH
29698: LD_INT 2
29700: NEG
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 0
29708: PUSH
29709: LD_INT 2
29711: NEG
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 1
29719: PUSH
29720: LD_INT 1
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 2
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 2
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 1
29750: PUSH
29751: LD_INT 2
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 0
29760: PUSH
29761: LD_INT 2
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PUSH
29779: LD_INT 2
29781: NEG
29782: PUSH
29783: LD_INT 1
29785: NEG
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: LD_INT 2
29797: NEG
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: LD_INT 2
29805: NEG
29806: PUSH
29807: LD_INT 3
29809: NEG
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 2
29817: PUSH
29818: LD_INT 1
29820: NEG
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 3
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: PUSH
29839: LD_INT 3
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 3
29859: NEG
29860: PUSH
29861: LD_INT 2
29863: NEG
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: LIST
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29894: LD_ADDR_VAR 0 30
29898: PUSH
29899: LD_INT 0
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: PUSH
29909: LD_INT 0
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 1
29922: PUSH
29923: LD_INT 0
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 1
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 0
29942: PUSH
29943: LD_INT 1
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 1
29952: NEG
29953: PUSH
29954: LD_INT 0
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PUSH
29961: LD_INT 1
29963: NEG
29964: PUSH
29965: LD_INT 1
29967: NEG
29968: PUSH
29969: EMPTY
29970: LIST
29971: LIST
29972: PUSH
29973: LD_INT 1
29975: NEG
29976: PUSH
29977: LD_INT 2
29979: NEG
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: LD_INT 2
29990: NEG
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: LD_INT 1
29998: PUSH
29999: LD_INT 1
30001: NEG
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 2
30009: PUSH
30010: LD_INT 0
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 2
30019: PUSH
30020: LD_INT 1
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 2
30029: PUSH
30030: LD_INT 2
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: LD_INT 1
30039: PUSH
30040: LD_INT 2
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: NEG
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 2
30060: NEG
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: NEG
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: NEG
30084: PUSH
30085: LD_INT 3
30087: NEG
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: LD_INT 2
30098: NEG
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 3
30106: PUSH
30107: LD_INT 2
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 2
30116: PUSH
30117: LD_INT 3
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PUSH
30124: LD_INT 2
30126: NEG
30127: PUSH
30128: LD_INT 1
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 3
30137: NEG
30138: PUSH
30139: LD_INT 1
30141: NEG
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: LIST
30168: LIST
30169: LIST
30170: LIST
30171: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30172: LD_ADDR_VAR 0 31
30176: PUSH
30177: LD_INT 0
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: LD_INT 1
30192: NEG
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 1
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 0
30220: PUSH
30221: LD_INT 1
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 1
30230: NEG
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: LD_INT 1
30245: NEG
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 1
30253: NEG
30254: PUSH
30255: LD_INT 2
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 1
30268: NEG
30269: PUSH
30270: EMPTY
30271: LIST
30272: LIST
30273: PUSH
30274: LD_INT 2
30276: PUSH
30277: LD_INT 0
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 2
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 2
30296: PUSH
30297: LD_INT 2
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: LD_INT 2
30309: PUSH
30310: EMPTY
30311: LIST
30312: LIST
30313: PUSH
30314: LD_INT 0
30316: PUSH
30317: LD_INT 2
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: LD_INT 1
30326: NEG
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 2
30337: NEG
30338: PUSH
30339: LD_INT 1
30341: NEG
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: LD_INT 2
30353: NEG
30354: PUSH
30355: EMPTY
30356: LIST
30357: LIST
30358: PUSH
30359: LD_INT 2
30361: NEG
30362: PUSH
30363: LD_INT 3
30365: NEG
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 2
30373: PUSH
30374: LD_INT 1
30376: NEG
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 3
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 3
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 1
30404: NEG
30405: PUSH
30406: LD_INT 2
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 3
30415: NEG
30416: PUSH
30417: LD_INT 2
30419: NEG
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: LIST
30429: LIST
30430: LIST
30431: LIST
30432: LIST
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30450: LD_ADDR_VAR 0 32
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: NEG
30532: PUSH
30533: LD_INT 2
30535: NEG
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 2
30546: NEG
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: LD_INT 1
30557: NEG
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 2
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 2
30575: PUSH
30576: LD_INT 2
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: PUSH
30586: LD_INT 2
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: PUSH
30593: LD_INT 0
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: EMPTY
30600: LIST
30601: LIST
30602: PUSH
30603: LD_INT 1
30605: NEG
30606: PUSH
30607: LD_INT 1
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 2
30616: NEG
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 2
30627: NEG
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: NEG
30640: PUSH
30641: LD_INT 3
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 1
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 3
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 2
30672: PUSH
30673: LD_INT 3
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 3
30693: NEG
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30728: LD_ADDR_VAR 0 33
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: LD_INT 0
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: LD_INT 1
30748: NEG
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: LD_INT 1
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: LD_INT 1
30769: PUSH
30770: EMPTY
30771: LIST
30772: LIST
30773: PUSH
30774: LD_INT 0
30776: PUSH
30777: LD_INT 1
30779: PUSH
30780: EMPTY
30781: LIST
30782: LIST
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: LD_INT 2
30813: NEG
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 1
30821: PUSH
30822: LD_INT 1
30824: NEG
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: LD_INT 0
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 2
30842: PUSH
30843: LD_INT 1
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 0
30862: PUSH
30863: LD_INT 2
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: LD_INT 1
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: NEG
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 2
30894: NEG
30895: PUSH
30896: LD_INT 1
30898: NEG
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: LD_INT 2
30906: NEG
30907: PUSH
30908: LD_INT 2
30910: NEG
30911: PUSH
30912: EMPTY
30913: LIST
30914: LIST
30915: PUSH
30916: LD_INT 2
30918: NEG
30919: PUSH
30920: LD_INT 3
30922: NEG
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 2
30930: PUSH
30931: LD_INT 1
30933: NEG
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 3
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: PUSH
30952: LD_INT 3
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: LD_INT 1
30961: NEG
30962: PUSH
30963: LD_INT 2
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 3
30972: NEG
30973: PUSH
30974: LD_INT 2
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: LIST
30995: LIST
30996: LIST
30997: LIST
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31007: LD_ADDR_VAR 0 34
31011: PUSH
31012: LD_INT 0
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: PUSH
31036: LD_INT 0
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: PUSH
31046: LD_INT 1
31048: PUSH
31049: EMPTY
31050: LIST
31051: LIST
31052: PUSH
31053: LD_INT 0
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: EMPTY
31060: LIST
31061: LIST
31062: PUSH
31063: LD_INT 1
31065: NEG
31066: PUSH
31067: LD_INT 0
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: LD_INT 1
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 1
31088: NEG
31089: PUSH
31090: LD_INT 2
31092: NEG
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 0
31100: PUSH
31101: LD_INT 2
31103: NEG
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 1
31114: NEG
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 1
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 2
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: LD_INT 1
31198: NEG
31199: PUSH
31200: LD_INT 3
31202: NEG
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 1
31210: PUSH
31211: LD_INT 2
31213: NEG
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 3
31221: PUSH
31222: LD_INT 2
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 2
31231: PUSH
31232: LD_INT 3
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 2
31241: NEG
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 3
31252: NEG
31253: PUSH
31254: LD_INT 1
31256: NEG
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: LIST
31285: LIST
31286: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31287: LD_ADDR_VAR 0 35
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 0
31304: PUSH
31305: LD_INT 1
31307: NEG
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: LD_INT 1
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: LD_INT 1
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: LD_INT 0
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 1
31356: NEG
31357: PUSH
31358: LD_INT 1
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 2
31368: PUSH
31369: LD_INT 1
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 2
31378: NEG
31379: PUSH
31380: LD_INT 1
31382: NEG
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31399: LD_ADDR_VAR 0 36
31403: PUSH
31404: LD_INT 0
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 1
31419: NEG
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: PUSH
31428: LD_INT 0
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 1
31437: PUSH
31438: LD_INT 1
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 1
31457: NEG
31458: PUSH
31459: LD_INT 0
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 1
31480: NEG
31481: PUSH
31482: LD_INT 2
31484: NEG
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 1
31492: PUSH
31493: LD_INT 2
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31511: LD_ADDR_VAR 0 37
31515: PUSH
31516: LD_INT 0
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: LD_INT 1
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 1
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: NEG
31570: PUSH
31571: LD_INT 0
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: LD_INT 1
31584: NEG
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: NEG
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31623: LD_ADDR_VAR 0 38
31627: PUSH
31628: LD_INT 0
31630: PUSH
31631: LD_INT 0
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: LD_INT 1
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 1
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: LD_INT 1
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 0
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 1
31681: NEG
31682: PUSH
31683: LD_INT 0
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: LD_INT 1
31696: NEG
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 2
31704: PUSH
31705: LD_INT 1
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 2
31714: NEG
31715: PUSH
31716: LD_INT 1
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31735: LD_ADDR_VAR 0 39
31739: PUSH
31740: LD_INT 0
31742: PUSH
31743: LD_INT 0
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 0
31752: PUSH
31753: LD_INT 1
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: EMPTY
31768: LIST
31769: LIST
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: LD_INT 1
31776: PUSH
31777: EMPTY
31778: LIST
31779: LIST
31780: PUSH
31781: LD_INT 0
31783: PUSH
31784: LD_INT 1
31786: PUSH
31787: EMPTY
31788: LIST
31789: LIST
31790: PUSH
31791: LD_INT 1
31793: NEG
31794: PUSH
31795: LD_INT 0
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: NEG
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 1
31816: NEG
31817: PUSH
31818: LD_INT 2
31820: NEG
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: PUSH
31829: LD_INT 2
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31847: LD_ADDR_VAR 0 40
31851: PUSH
31852: LD_INT 0
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 0
31864: PUSH
31865: LD_INT 1
31867: NEG
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 1
31875: PUSH
31876: LD_INT 0
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 0
31895: PUSH
31896: LD_INT 1
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 1
31905: NEG
31906: PUSH
31907: LD_INT 0
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 1
31916: NEG
31917: PUSH
31918: LD_INT 1
31920: NEG
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: LD_INT 1
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 1
31939: NEG
31940: PUSH
31941: LD_INT 1
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31959: LD_ADDR_VAR 0 41
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: LD_INT 1
31979: NEG
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 1
31987: PUSH
31988: LD_INT 0
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: LD_INT 1
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: NEG
32018: PUSH
32019: LD_INT 0
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 2
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 2
32063: PUSH
32064: LD_INT 0
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 2
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: PUSH
32084: LD_INT 2
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: LD_INT 2
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 1
32103: NEG
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 2
32114: NEG
32115: PUSH
32116: LD_INT 0
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: PUSH
32123: LD_INT 2
32125: NEG
32126: PUSH
32127: LD_INT 1
32129: NEG
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: LD_INT 2
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 2
32149: NEG
32150: PUSH
32151: LD_INT 3
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: PUSH
32162: LD_INT 1
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 3
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: EMPTY
32177: LIST
32178: LIST
32179: PUSH
32180: LD_INT 3
32182: PUSH
32183: LD_INT 1
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 3
32192: PUSH
32193: LD_INT 2
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 3
32202: PUSH
32203: LD_INT 3
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 2
32212: PUSH
32213: LD_INT 3
32215: PUSH
32216: EMPTY
32217: LIST
32218: LIST
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 3
32233: NEG
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 3
32244: NEG
32245: PUSH
32246: LD_INT 1
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 3
32256: NEG
32257: PUSH
32258: LD_INT 2
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 3
32268: NEG
32269: PUSH
32270: LD_INT 3
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32309: LD_ADDR_VAR 0 42
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: LD_INT 1
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: LD_INT 1
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 2
32394: NEG
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 0
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: LD_INT 2
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 1
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 0
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: NEG
32465: PUSH
32466: LD_INT 1
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 2
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: NEG
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 2
32487: NEG
32488: PUSH
32489: LD_INT 2
32491: NEG
32492: PUSH
32493: EMPTY
32494: LIST
32495: LIST
32496: PUSH
32497: LD_INT 2
32499: NEG
32500: PUSH
32501: LD_INT 3
32503: NEG
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 1
32511: NEG
32512: PUSH
32513: LD_INT 3
32515: NEG
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 0
32523: PUSH
32524: LD_INT 3
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: LD_INT 2
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 3
32555: PUSH
32556: LD_INT 3
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 2
32565: PUSH
32566: LD_INT 3
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: PUSH
32576: LD_INT 3
32578: PUSH
32579: EMPTY
32580: LIST
32581: LIST
32582: PUSH
32583: LD_INT 0
32585: PUSH
32586: LD_INT 3
32588: PUSH
32589: EMPTY
32590: LIST
32591: LIST
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 3
32606: NEG
32607: PUSH
32608: LD_INT 2
32610: NEG
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 3
32618: NEG
32619: PUSH
32620: LD_INT 3
32622: NEG
32623: PUSH
32624: EMPTY
32625: LIST
32626: LIST
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: LIST
32632: LIST
32633: LIST
32634: LIST
32635: LIST
32636: LIST
32637: LIST
32638: LIST
32639: LIST
32640: LIST
32641: LIST
32642: LIST
32643: LIST
32644: LIST
32645: LIST
32646: LIST
32647: LIST
32648: LIST
32649: LIST
32650: LIST
32651: LIST
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32659: LD_ADDR_VAR 0 43
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: LD_INT 0
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 0
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 1
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: LD_INT 1
32697: PUSH
32698: LD_INT 1
32700: PUSH
32701: EMPTY
32702: LIST
32703: LIST
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: LD_INT 1
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 1
32717: NEG
32718: PUSH
32719: LD_INT 0
32721: PUSH
32722: EMPTY
32723: LIST
32724: LIST
32725: PUSH
32726: LD_INT 1
32728: NEG
32729: PUSH
32730: LD_INT 1
32732: NEG
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 2
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: LD_INT 2
32755: NEG
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 1
32763: PUSH
32764: LD_INT 1
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 2
32774: PUSH
32775: LD_INT 0
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 2
32784: PUSH
32785: LD_INT 1
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 1
32794: PUSH
32795: LD_INT 2
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: NEG
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 2
32825: NEG
32826: PUSH
32827: LD_INT 0
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: NEG
32837: PUSH
32838: LD_INT 1
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 1
32848: NEG
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 0
32860: PUSH
32861: LD_INT 3
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: LD_INT 2
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 2
32882: PUSH
32883: LD_INT 1
32885: NEG
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 3
32893: PUSH
32894: LD_INT 0
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 3
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: LD_INT 3
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 0
32923: PUSH
32924: LD_INT 3
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: NEG
32934: PUSH
32935: LD_INT 2
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 2
32944: NEG
32945: PUSH
32946: LD_INT 1
32948: PUSH
32949: EMPTY
32950: LIST
32951: LIST
32952: PUSH
32953: LD_INT 3
32955: NEG
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 3
32966: NEG
32967: PUSH
32968: LD_INT 1
32970: NEG
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33007: LD_ADDR_VAR 0 44
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: EMPTY
33019: LIST
33020: LIST
33021: PUSH
33022: LD_INT 0
33024: PUSH
33025: LD_INT 1
33027: NEG
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 1
33045: PUSH
33046: LD_INT 1
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 0
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 0
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 2
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 2
33111: PUSH
33112: LD_INT 0
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: LD_INT 2
33131: PUSH
33132: LD_INT 2
33134: PUSH
33135: EMPTY
33136: LIST
33137: LIST
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 1
33151: NEG
33152: PUSH
33153: LD_INT 1
33155: PUSH
33156: EMPTY
33157: LIST
33158: LIST
33159: PUSH
33160: LD_INT 2
33162: NEG
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 2
33173: NEG
33174: PUSH
33175: LD_INT 1
33177: NEG
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 2
33185: NEG
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 2
33197: NEG
33198: PUSH
33199: LD_INT 3
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 2
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 3
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 3
33230: PUSH
33231: LD_INT 1
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 3
33240: PUSH
33241: LD_INT 2
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 3
33250: PUSH
33251: LD_INT 3
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: LD_INT 3
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 2
33270: NEG
33271: PUSH
33272: LD_INT 1
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 3
33281: NEG
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: EMPTY
33287: LIST
33288: LIST
33289: PUSH
33290: LD_INT 3
33292: NEG
33293: PUSH
33294: LD_INT 1
33296: NEG
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 3
33304: NEG
33305: PUSH
33306: LD_INT 2
33308: NEG
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 3
33316: NEG
33317: PUSH
33318: LD_INT 3
33320: NEG
33321: PUSH
33322: EMPTY
33323: LIST
33324: LIST
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33357: LD_ADDR_VAR 0 45
33361: PUSH
33362: LD_INT 0
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: LD_INT 1
33377: NEG
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: NEG
33439: PUSH
33440: LD_INT 2
33442: NEG
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 2
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: LD_INT 1
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 1
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 0
33502: PUSH
33503: LD_INT 2
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 1
33512: NEG
33513: PUSH
33514: LD_INT 1
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 2
33523: NEG
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: LD_INT 2
33539: NEG
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 2
33547: NEG
33548: PUSH
33549: LD_INT 3
33551: NEG
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: NEG
33560: PUSH
33561: LD_INT 3
33563: NEG
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: LD_INT 3
33574: NEG
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: LD_INT 2
33585: NEG
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 3
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 3
33603: PUSH
33604: LD_INT 3
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 2
33613: PUSH
33614: LD_INT 3
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 1
33623: PUSH
33624: LD_INT 3
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 0
33633: PUSH
33634: LD_INT 3
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 1
33643: NEG
33644: PUSH
33645: LD_INT 2
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 3
33654: NEG
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: EMPTY
33661: LIST
33662: LIST
33663: PUSH
33664: LD_INT 3
33666: NEG
33667: PUSH
33668: LD_INT 3
33670: NEG
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33707: LD_ADDR_VAR 0 46
33711: PUSH
33712: LD_INT 0
33714: PUSH
33715: LD_INT 0
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 0
33724: PUSH
33725: LD_INT 1
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: LD_INT 1
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 1
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 1
33765: NEG
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: NEG
33789: PUSH
33790: LD_INT 2
33792: NEG
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: LD_INT 2
33803: NEG
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 2
33822: PUSH
33823: LD_INT 0
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: LD_INT 1
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 1
33842: PUSH
33843: LD_INT 2
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 2
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: NEG
33874: PUSH
33875: LD_INT 0
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 2
33884: NEG
33885: PUSH
33886: LD_INT 1
33888: NEG
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 1
33896: NEG
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 0
33908: PUSH
33909: LD_INT 3
33911: NEG
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: PUSH
33920: LD_INT 2
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 2
33930: PUSH
33931: LD_INT 1
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 3
33951: PUSH
33952: LD_INT 1
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 3
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 3
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: NEG
33993: PUSH
33994: LD_INT 1
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 3
34003: NEG
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 3
34014: NEG
34015: PUSH
34016: LD_INT 1
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: EMPTY
34025: LIST
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34055: LD_ADDR_VAR 0 47
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 0
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 0
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: LD_INT 0
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 1
34093: PUSH
34094: LD_INT 1
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 1
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 1
34113: NEG
34114: PUSH
34115: LD_INT 0
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: LD_INT 2
34151: NEG
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: LD_INT 1
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 2
34170: NEG
34171: PUSH
34172: LD_INT 1
34174: NEG
34175: PUSH
34176: EMPTY
34177: LIST
34178: LIST
34179: PUSH
34180: LD_INT 2
34182: NEG
34183: PUSH
34184: LD_INT 2
34186: NEG
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: LIST
34199: LIST
34200: LIST
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34206: LD_ADDR_VAR 0 48
34210: PUSH
34211: LD_INT 0
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 1
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 1
34244: PUSH
34245: LD_INT 1
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: LD_INT 1
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: LD_INT 0
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: LD_INT 1
34279: NEG
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 1
34287: NEG
34288: PUSH
34289: LD_INT 2
34291: NEG
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PUSH
34308: LD_INT 1
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 1
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34353: LD_ADDR_VAR 0 49
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: LD_INT 0
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 1
34381: PUSH
34382: LD_INT 0
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: NEG
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: LD_INT 1
34426: NEG
34427: PUSH
34428: EMPTY
34429: LIST
34430: LIST
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: LD_INT 1
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 2
34445: PUSH
34446: LD_INT 0
34448: PUSH
34449: EMPTY
34450: LIST
34451: LIST
34452: PUSH
34453: LD_INT 2
34455: PUSH
34456: LD_INT 1
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 2
34465: PUSH
34466: LD_INT 2
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: LIST
34487: LIST
34488: LIST
34489: LIST
34490: LIST
34491: LIST
34492: LIST
34493: LIST
34494: LIST
34495: LIST
34496: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34497: LD_ADDR_VAR 0 50
34501: PUSH
34502: LD_INT 0
34504: PUSH
34505: LD_INT 0
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 1
34525: PUSH
34526: LD_INT 0
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: LD_INT 1
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 0
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: EMPTY
34561: LIST
34562: LIST
34563: PUSH
34564: LD_INT 1
34566: NEG
34567: PUSH
34568: LD_INT 1
34570: NEG
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: LD_INT 2
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 2
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: LD_INT 1
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: LIST
34637: LIST
34638: LIST
34639: LIST
34640: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34641: LD_ADDR_VAR 0 51
34645: PUSH
34646: LD_INT 0
34648: PUSH
34649: LD_INT 0
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 0
34658: PUSH
34659: LD_INT 1
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: LD_INT 0
34672: PUSH
34673: EMPTY
34674: LIST
34675: LIST
34676: PUSH
34677: LD_INT 1
34679: PUSH
34680: LD_INT 1
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: LD_INT 0
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 1
34722: PUSH
34723: LD_INT 2
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 0
34732: PUSH
34733: LD_INT 2
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: NEG
34743: PUSH
34744: LD_INT 1
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: LD_INT 0
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 2
34764: NEG
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34788: LD_ADDR_VAR 0 52
34792: PUSH
34793: LD_INT 0
34795: PUSH
34796: LD_INT 0
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 0
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 1
34826: PUSH
34827: LD_INT 1
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 0
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 1
34846: NEG
34847: PUSH
34848: LD_INT 0
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 1
34857: NEG
34858: PUSH
34859: LD_INT 1
34861: NEG
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: LD_INT 2
34873: NEG
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: LD_INT 2
34892: NEG
34893: PUSH
34894: LD_INT 0
34896: PUSH
34897: EMPTY
34898: LIST
34899: LIST
34900: PUSH
34901: LD_INT 2
34903: NEG
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 2
34915: NEG
34916: PUSH
34917: LD_INT 2
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: LIST
34929: LIST
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34939: LD_ADDR_VAR 0 53
34943: PUSH
34944: LD_INT 0
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PUSH
34954: LD_INT 0
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 0
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 1
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 0
34987: PUSH
34988: LD_INT 1
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 1
34997: NEG
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 1
35008: NEG
35009: PUSH
35010: LD_INT 1
35012: NEG
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 2
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: LD_INT 0
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 2
35064: PUSH
35065: LD_INT 1
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 2
35074: PUSH
35075: LD_INT 2
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 1
35084: PUSH
35085: LD_INT 2
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: LD_INT 2
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: NEG
35105: PUSH
35106: LD_INT 1
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 2
35115: NEG
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: EMPTY
35121: LIST
35122: LIST
35123: PUSH
35124: LD_INT 2
35126: NEG
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 2
35138: NEG
35139: PUSH
35140: LD_INT 2
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: LIST
35161: LIST
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: LIST
35167: LIST
35168: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35169: LD_ADDR_VAR 0 54
35173: PUSH
35174: LD_INT 0
35176: PUSH
35177: LD_INT 0
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 0
35186: PUSH
35187: LD_INT 1
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 1
35207: PUSH
35208: LD_INT 1
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 1
35227: NEG
35228: PUSH
35229: LD_INT 0
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 1
35238: NEG
35239: PUSH
35240: LD_INT 1
35242: NEG
35243: PUSH
35244: EMPTY
35245: LIST
35246: LIST
35247: PUSH
35248: LD_INT 1
35250: NEG
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 0
35262: PUSH
35263: LD_INT 2
35265: NEG
35266: PUSH
35267: EMPTY
35268: LIST
35269: LIST
35270: PUSH
35271: LD_INT 1
35273: PUSH
35274: LD_INT 1
35276: NEG
35277: PUSH
35278: EMPTY
35279: LIST
35280: LIST
35281: PUSH
35282: LD_INT 2
35284: PUSH
35285: LD_INT 0
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 2
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 2
35304: PUSH
35305: LD_INT 2
35307: PUSH
35308: EMPTY
35309: LIST
35310: LIST
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: LD_INT 2
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 2
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 2
35368: NEG
35369: PUSH
35370: LD_INT 2
35372: NEG
35373: PUSH
35374: EMPTY
35375: LIST
35376: LIST
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: LIST
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35399: LD_ADDR_VAR 0 55
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 0
35492: PUSH
35493: LD_INT 2
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: LD_INT 0
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 2
35524: PUSH
35525: LD_INT 1
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: EMPTY
35539: LIST
35540: LIST
35541: PUSH
35542: LD_INT 1
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: LD_INT 1
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 2
35575: NEG
35576: PUSH
35577: LD_INT 0
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 2
35586: NEG
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 2
35598: NEG
35599: PUSH
35600: LD_INT 2
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: LIST
35612: LIST
35613: LIST
35614: LIST
35615: LIST
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35629: LD_ADDR_VAR 0 56
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 0
35646: PUSH
35647: LD_INT 1
35649: NEG
35650: PUSH
35651: EMPTY
35652: LIST
35653: LIST
35654: PUSH
35655: LD_INT 1
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: LD_INT 1
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: LD_INT 1
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: NEG
35688: PUSH
35689: LD_INT 0
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 1
35698: NEG
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 0
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: LD_INT 1
35736: NEG
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: LD_INT 2
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: LD_INT 2
35754: PUSH
35755: LD_INT 1
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 2
35764: PUSH
35765: LD_INT 2
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 0
35784: PUSH
35785: LD_INT 2
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 1
35794: NEG
35795: PUSH
35796: LD_INT 1
35798: PUSH
35799: EMPTY
35800: LIST
35801: LIST
35802: PUSH
35803: LD_INT 2
35805: NEG
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 2
35816: NEG
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 2
35828: NEG
35829: PUSH
35830: LD_INT 2
35832: NEG
35833: PUSH
35834: EMPTY
35835: LIST
35836: LIST
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: LIST
35842: LIST
35843: LIST
35844: LIST
35845: LIST
35846: LIST
35847: LIST
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35859: LD_ADDR_VAR 0 57
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 1
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 0
35890: PUSH
35891: EMPTY
35892: LIST
35893: LIST
35894: PUSH
35895: LD_INT 1
35897: PUSH
35898: LD_INT 1
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 0
35907: PUSH
35908: LD_INT 1
35910: PUSH
35911: EMPTY
35912: LIST
35913: LIST
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: LD_INT 0
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: NEG
35929: PUSH
35930: LD_INT 1
35932: NEG
35933: PUSH
35934: EMPTY
35935: LIST
35936: LIST
35937: PUSH
35938: LD_INT 1
35940: NEG
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: EMPTY
35947: LIST
35948: LIST
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: LD_INT 2
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 1
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: PUSH
35975: LD_INT 0
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 2
35984: PUSH
35985: LD_INT 1
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 2
35994: PUSH
35995: LD_INT 2
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 2
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 0
36014: PUSH
36015: LD_INT 2
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 2
36035: NEG
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 2
36046: NEG
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 2
36058: NEG
36059: PUSH
36060: LD_INT 2
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36089: LD_ADDR_VAR 0 58
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 1
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 2
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: LD_INT 1
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: PUSH
36225: LD_INT 2
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 2
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 2
36288: NEG
36289: PUSH
36290: LD_INT 2
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: LIST
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36319: LD_ADDR_VAR 0 59
36323: PUSH
36324: LD_INT 0
36326: PUSH
36327: LD_INT 0
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: LD_INT 1
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 1
36347: PUSH
36348: LD_INT 0
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: PUSH
36355: LD_INT 1
36357: PUSH
36358: LD_INT 1
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 0
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 1
36377: NEG
36378: PUSH
36379: LD_INT 0
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: PUSH
36386: LD_INT 1
36388: NEG
36389: PUSH
36390: LD_INT 1
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: LIST
36402: LIST
36403: LIST
36404: LIST
36405: LIST
36406: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36407: LD_ADDR_VAR 0 60
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: LD_INT 0
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 0
36424: PUSH
36425: LD_INT 1
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 1
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 1
36445: PUSH
36446: LD_INT 1
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: LD_INT 1
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 0
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 1
36476: NEG
36477: PUSH
36478: LD_INT 1
36480: NEG
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36495: LD_ADDR_VAR 0 61
36499: PUSH
36500: LD_INT 0
36502: PUSH
36503: LD_INT 0
36505: PUSH
36506: EMPTY
36507: LIST
36508: LIST
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: LD_INT 1
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 1
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 1
36533: PUSH
36534: LD_INT 1
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: LD_INT 1
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 1
36553: NEG
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: LIST
36580: LIST
36581: LIST
36582: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36583: LD_ADDR_VAR 0 62
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: LD_INT 0
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 0
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 1
36611: PUSH
36612: LD_INT 0
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 1
36621: PUSH
36622: LD_INT 1
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: PUSH
36629: LD_INT 0
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 1
36641: NEG
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36671: LD_ADDR_VAR 0 63
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 1
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36759: LD_ADDR_VAR 0 64
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: LD_INT 0
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 0
36776: PUSH
36777: LD_INT 1
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 1
36787: PUSH
36788: LD_INT 0
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 1
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: LD_INT 0
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 1
36828: NEG
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: ST_TO_ADDR
// end ; 1 :
36847: GO 42744
36849: LD_INT 1
36851: DOUBLE
36852: EQUAL
36853: IFTRUE 36857
36855: GO 39480
36857: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36858: LD_ADDR_VAR 0 11
36862: PUSH
36863: LD_INT 1
36865: NEG
36866: PUSH
36867: LD_INT 3
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 0
36877: PUSH
36878: LD_INT 3
36880: NEG
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 1
36888: PUSH
36889: LD_INT 2
36891: NEG
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: EMPTY
36898: LIST
36899: LIST
36900: LIST
36901: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36902: LD_ADDR_VAR 0 12
36906: PUSH
36907: LD_INT 2
36909: PUSH
36910: LD_INT 1
36912: NEG
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: LIST
36942: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36943: LD_ADDR_VAR 0 13
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: LD_INT 2
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: LD_INT 3
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 2
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: LIST
36982: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36983: LD_ADDR_VAR 0 14
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: LD_INT 3
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: LD_INT 3
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: NEG
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: LIST
37023: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37024: LD_ADDR_VAR 0 15
37028: PUSH
37029: LD_INT 2
37031: NEG
37032: PUSH
37033: LD_INT 1
37035: PUSH
37036: EMPTY
37037: LIST
37038: LIST
37039: PUSH
37040: LD_INT 3
37042: NEG
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 3
37053: NEG
37054: PUSH
37055: LD_INT 1
37057: NEG
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: LIST
37067: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37068: LD_ADDR_VAR 0 16
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: LD_INT 3
37079: NEG
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 3
37087: NEG
37088: PUSH
37089: LD_INT 2
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 3
37099: NEG
37100: PUSH
37101: LD_INT 3
37103: NEG
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: LIST
37113: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37114: LD_ADDR_VAR 0 17
37118: PUSH
37119: LD_INT 1
37121: NEG
37122: PUSH
37123: LD_INT 3
37125: NEG
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 0
37133: PUSH
37134: LD_INT 3
37136: NEG
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: LD_INT 2
37147: NEG
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: LIST
37157: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37158: LD_ADDR_VAR 0 18
37162: PUSH
37163: LD_INT 2
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 3
37176: PUSH
37177: LD_INT 0
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 3
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: LIST
37198: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37199: LD_ADDR_VAR 0 19
37203: PUSH
37204: LD_INT 3
37206: PUSH
37207: LD_INT 2
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 3
37216: PUSH
37217: LD_INT 3
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 2
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37239: LD_ADDR_VAR 0 20
37243: PUSH
37244: LD_INT 1
37246: PUSH
37247: LD_INT 3
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 3
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 1
37266: NEG
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: LIST
37279: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37280: LD_ADDR_VAR 0 21
37284: PUSH
37285: LD_INT 2
37287: NEG
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: EMPTY
37293: LIST
37294: LIST
37295: PUSH
37296: LD_INT 3
37298: NEG
37299: PUSH
37300: LD_INT 0
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 3
37309: NEG
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: LIST
37323: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37324: LD_ADDR_VAR 0 22
37328: PUSH
37329: LD_INT 2
37331: NEG
37332: PUSH
37333: LD_INT 3
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 3
37343: NEG
37344: PUSH
37345: LD_INT 2
37347: NEG
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 3
37355: NEG
37356: PUSH
37357: LD_INT 3
37359: NEG
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: LIST
37369: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37370: LD_ADDR_VAR 0 23
37374: PUSH
37375: LD_INT 0
37377: PUSH
37378: LD_INT 3
37380: NEG
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 1
37388: NEG
37389: PUSH
37390: LD_INT 4
37392: NEG
37393: PUSH
37394: EMPTY
37395: LIST
37396: LIST
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: LD_INT 3
37403: NEG
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: LIST
37413: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37414: LD_ADDR_VAR 0 24
37418: PUSH
37419: LD_INT 3
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 3
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 4
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: EMPTY
37451: LIST
37452: LIST
37453: LIST
37454: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37455: LD_ADDR_VAR 0 25
37459: PUSH
37460: LD_INT 3
37462: PUSH
37463: LD_INT 3
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 4
37472: PUSH
37473: LD_INT 3
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 3
37482: PUSH
37483: LD_INT 4
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37495: LD_ADDR_VAR 0 26
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 3
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 4
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: NEG
37523: PUSH
37524: LD_INT 3
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: LIST
37535: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37536: LD_ADDR_VAR 0 27
37540: PUSH
37541: LD_INT 3
37543: NEG
37544: PUSH
37545: LD_INT 0
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 3
37554: NEG
37555: PUSH
37556: LD_INT 1
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 4
37565: NEG
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: LIST
37579: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37580: LD_ADDR_VAR 0 28
37584: PUSH
37585: LD_INT 3
37587: NEG
37588: PUSH
37589: LD_INT 3
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 3
37599: NEG
37600: PUSH
37601: LD_INT 4
37603: NEG
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 4
37611: NEG
37612: PUSH
37613: LD_INT 3
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: LIST
37625: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37626: LD_ADDR_VAR 0 29
37630: PUSH
37631: LD_INT 1
37633: NEG
37634: PUSH
37635: LD_INT 3
37637: NEG
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 0
37645: PUSH
37646: LD_INT 3
37648: NEG
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: LD_INT 2
37659: NEG
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: NEG
37668: PUSH
37669: LD_INT 4
37671: NEG
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: LD_INT 4
37682: NEG
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: LD_INT 1
37690: PUSH
37691: LD_INT 3
37693: NEG
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 5
37705: NEG
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 5
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 4
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: LD_INT 6
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 0
37747: PUSH
37748: LD_INT 6
37750: NEG
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: LD_INT 5
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: LIST
37778: LIST
37779: LIST
37780: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37781: LD_ADDR_VAR 0 30
37785: PUSH
37786: LD_INT 2
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: PUSH
37797: LD_INT 3
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: LD_INT 1
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 3
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 4
37830: PUSH
37831: LD_INT 0
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 4
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 4
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 5
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 5
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 5
37881: PUSH
37882: LD_INT 1
37884: NEG
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 6
37892: PUSH
37893: LD_INT 0
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 6
37902: PUSH
37903: LD_INT 1
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: EMPTY
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37924: LD_ADDR_VAR 0 31
37928: PUSH
37929: LD_INT 3
37931: PUSH
37932: LD_INT 2
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 3
37941: PUSH
37942: LD_INT 3
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 2
37951: PUSH
37952: LD_INT 3
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 4
37961: PUSH
37962: LD_INT 3
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 4
37971: PUSH
37972: LD_INT 4
37974: PUSH
37975: EMPTY
37976: LIST
37977: LIST
37978: PUSH
37979: LD_INT 3
37981: PUSH
37982: LD_INT 4
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 5
37991: PUSH
37992: LD_INT 4
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 5
38001: PUSH
38002: LD_INT 5
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 4
38011: PUSH
38012: LD_INT 5
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 6
38021: PUSH
38022: LD_INT 5
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 6
38031: PUSH
38032: LD_INT 6
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 5
38041: PUSH
38042: LD_INT 6
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38063: LD_ADDR_VAR 0 32
38067: PUSH
38068: LD_INT 1
38070: PUSH
38071: LD_INT 3
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: LD_INT 0
38080: PUSH
38081: LD_INT 3
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 1
38090: NEG
38091: PUSH
38092: LD_INT 2
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 4
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: LD_INT 4
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 1
38121: NEG
38122: PUSH
38123: LD_INT 3
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: LD_INT 5
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: LD_INT 5
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 1
38152: NEG
38153: PUSH
38154: LD_INT 4
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: LD_INT 6
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 6
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 1
38183: NEG
38184: PUSH
38185: LD_INT 5
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: LIST
38202: LIST
38203: LIST
38204: LIST
38205: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38206: LD_ADDR_VAR 0 33
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 3
38224: NEG
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 3
38235: NEG
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 3
38247: NEG
38248: PUSH
38249: LD_INT 1
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 4
38258: NEG
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 4
38269: NEG
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 4
38281: NEG
38282: PUSH
38283: LD_INT 1
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 5
38292: NEG
38293: PUSH
38294: LD_INT 0
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 5
38303: NEG
38304: PUSH
38305: LD_INT 1
38307: NEG
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 5
38315: NEG
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 6
38326: NEG
38327: PUSH
38328: LD_INT 0
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 6
38337: NEG
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: LIST
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38361: LD_ADDR_VAR 0 34
38365: PUSH
38366: LD_INT 2
38368: NEG
38369: PUSH
38370: LD_INT 3
38372: NEG
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 3
38380: NEG
38381: PUSH
38382: LD_INT 2
38384: NEG
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 3
38392: NEG
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 3
38404: NEG
38405: PUSH
38406: LD_INT 4
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 4
38416: NEG
38417: PUSH
38418: LD_INT 3
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 4
38428: NEG
38429: PUSH
38430: LD_INT 4
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 4
38440: NEG
38441: PUSH
38442: LD_INT 5
38444: NEG
38445: PUSH
38446: EMPTY
38447: LIST
38448: LIST
38449: PUSH
38450: LD_INT 5
38452: NEG
38453: PUSH
38454: LD_INT 4
38456: NEG
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 5
38464: NEG
38465: PUSH
38466: LD_INT 5
38468: NEG
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 5
38476: NEG
38477: PUSH
38478: LD_INT 6
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 6
38488: NEG
38489: PUSH
38490: LD_INT 5
38492: NEG
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 6
38500: NEG
38501: PUSH
38502: LD_INT 6
38504: NEG
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38524: LD_ADDR_VAR 0 41
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 2
38534: NEG
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 1
38542: NEG
38543: PUSH
38544: LD_INT 3
38546: NEG
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: PUSH
38555: LD_INT 2
38557: NEG
38558: PUSH
38559: EMPTY
38560: LIST
38561: LIST
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: LIST
38567: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38568: LD_ADDR_VAR 0 42
38572: PUSH
38573: LD_INT 2
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 2
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 3
38596: PUSH
38597: LD_INT 1
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38609: LD_ADDR_VAR 0 43
38613: PUSH
38614: LD_INT 2
38616: PUSH
38617: LD_INT 2
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 3
38626: PUSH
38627: LD_INT 2
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 2
38636: PUSH
38637: LD_INT 3
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: LIST
38648: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38649: LD_ADDR_VAR 0 44
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: LD_INT 2
38659: PUSH
38660: EMPTY
38661: LIST
38662: LIST
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: LD_INT 3
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: NEG
38677: PUSH
38678: LD_INT 2
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: LIST
38689: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38690: LD_ADDR_VAR 0 45
38694: PUSH
38695: LD_INT 2
38697: NEG
38698: PUSH
38699: LD_INT 0
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: LD_INT 1
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 3
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: LIST
38733: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38734: LD_ADDR_VAR 0 46
38738: PUSH
38739: LD_INT 2
38741: NEG
38742: PUSH
38743: LD_INT 2
38745: NEG
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 2
38753: NEG
38754: PUSH
38755: LD_INT 3
38757: NEG
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 3
38765: NEG
38766: PUSH
38767: LD_INT 2
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: LIST
38779: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38780: LD_ADDR_VAR 0 47
38784: PUSH
38785: LD_INT 2
38787: NEG
38788: PUSH
38789: LD_INT 3
38791: NEG
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PUSH
38797: LD_INT 1
38799: NEG
38800: PUSH
38801: LD_INT 3
38803: NEG
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: EMPTY
38810: LIST
38811: LIST
38812: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38813: LD_ADDR_VAR 0 48
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: LD_INT 2
38823: NEG
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 2
38831: PUSH
38832: LD_INT 1
38834: NEG
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38844: LD_ADDR_VAR 0 49
38848: PUSH
38849: LD_INT 3
38851: PUSH
38852: LD_INT 1
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 3
38861: PUSH
38862: LD_INT 2
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38873: LD_ADDR_VAR 0 50
38877: PUSH
38878: LD_INT 2
38880: PUSH
38881: LD_INT 3
38883: PUSH
38884: EMPTY
38885: LIST
38886: LIST
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: LD_INT 3
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38902: LD_ADDR_VAR 0 51
38906: PUSH
38907: LD_INT 1
38909: NEG
38910: PUSH
38911: LD_INT 2
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: NEG
38921: PUSH
38922: LD_INT 1
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38933: LD_ADDR_VAR 0 52
38937: PUSH
38938: LD_INT 3
38940: NEG
38941: PUSH
38942: LD_INT 1
38944: NEG
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 3
38952: NEG
38953: PUSH
38954: LD_INT 2
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38966: LD_ADDR_VAR 0 53
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 3
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: LD_INT 3
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: PUSH
38997: LD_INT 2
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: LIST
39009: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39010: LD_ADDR_VAR 0 54
39014: PUSH
39015: LD_INT 2
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 3
39028: PUSH
39029: LD_INT 0
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 3
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: EMPTY
39043: LIST
39044: LIST
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: LIST
39050: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39051: LD_ADDR_VAR 0 55
39055: PUSH
39056: LD_INT 3
39058: PUSH
39059: LD_INT 2
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 3
39068: PUSH
39069: LD_INT 3
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 2
39078: PUSH
39079: LD_INT 3
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: LIST
39090: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39091: LD_ADDR_VAR 0 56
39095: PUSH
39096: LD_INT 1
39098: PUSH
39099: LD_INT 3
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 0
39108: PUSH
39109: LD_INT 3
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: LD_INT 2
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: LIST
39131: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39132: LD_ADDR_VAR 0 57
39136: PUSH
39137: LD_INT 2
39139: NEG
39140: PUSH
39141: LD_INT 1
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 3
39150: NEG
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 3
39161: NEG
39162: PUSH
39163: LD_INT 1
39165: NEG
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: LIST
39175: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39176: LD_ADDR_VAR 0 58
39180: PUSH
39181: LD_INT 2
39183: NEG
39184: PUSH
39185: LD_INT 3
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 3
39195: NEG
39196: PUSH
39197: LD_INT 2
39199: NEG
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: LD_INT 3
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: LIST
39221: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39222: LD_ADDR_VAR 0 59
39226: PUSH
39227: LD_INT 1
39229: NEG
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 2
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 1
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: LIST
39265: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39266: LD_ADDR_VAR 0 60
39270: PUSH
39271: LD_INT 1
39273: PUSH
39274: LD_INT 1
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: PUSH
39285: LD_INT 0
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 2
39294: PUSH
39295: LD_INT 1
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: LIST
39306: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39307: LD_ADDR_VAR 0 61
39311: PUSH
39312: LD_INT 2
39314: PUSH
39315: LD_INT 1
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 2
39324: PUSH
39325: LD_INT 2
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 2
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: LIST
39346: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39347: LD_ADDR_VAR 0 62
39351: PUSH
39352: LD_INT 1
39354: PUSH
39355: LD_INT 2
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 0
39364: PUSH
39365: LD_INT 2
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: LIST
39387: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39388: LD_ADDR_VAR 0 63
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: LD_INT 1
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: LD_INT 0
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: LIST
39431: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39432: LD_ADDR_VAR 0 64
39436: PUSH
39437: LD_INT 1
39439: NEG
39440: PUSH
39441: LD_INT 2
39443: NEG
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: LD_INT 1
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: LD_INT 2
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: LIST
39477: ST_TO_ADDR
// end ; 2 :
39478: GO 42744
39480: LD_INT 2
39482: DOUBLE
39483: EQUAL
39484: IFTRUE 39488
39486: GO 42743
39488: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39489: LD_ADDR_VAR 0 29
39493: PUSH
39494: LD_INT 4
39496: PUSH
39497: LD_INT 0
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 4
39506: PUSH
39507: LD_INT 1
39509: NEG
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 5
39517: PUSH
39518: LD_INT 0
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 5
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 4
39537: PUSH
39538: LD_INT 1
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 3
39547: PUSH
39548: LD_INT 0
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 3
39557: PUSH
39558: LD_INT 1
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 3
39568: PUSH
39569: LD_INT 2
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 5
39579: PUSH
39580: LD_INT 2
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 3
39589: PUSH
39590: LD_INT 3
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 3
39599: PUSH
39600: LD_INT 2
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 4
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: LD_INT 4
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 3
39629: PUSH
39630: LD_INT 4
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 2
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 2
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 4
39659: PUSH
39660: LD_INT 2
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: LD_INT 4
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 0
39679: PUSH
39680: LD_INT 4
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: LD_INT 3
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 1
39699: PUSH
39700: LD_INT 4
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: LD_INT 5
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 0
39719: PUSH
39720: LD_INT 5
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: LD_INT 4
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 1
39740: NEG
39741: PUSH
39742: LD_INT 3
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 2
39751: PUSH
39752: LD_INT 5
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 2
39761: NEG
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 3
39772: NEG
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: EMPTY
39778: LIST
39779: LIST
39780: PUSH
39781: LD_INT 3
39783: NEG
39784: PUSH
39785: LD_INT 1
39787: NEG
39788: PUSH
39789: EMPTY
39790: LIST
39791: LIST
39792: PUSH
39793: LD_INT 2
39795: NEG
39796: PUSH
39797: LD_INT 0
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 3
39817: NEG
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 4
39828: NEG
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 4
39839: NEG
39840: PUSH
39841: LD_INT 1
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 4
39851: NEG
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: EMPTY
39858: LIST
39859: LIST
39860: PUSH
39861: LD_INT 2
39863: NEG
39864: PUSH
39865: LD_INT 2
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 4
39874: NEG
39875: PUSH
39876: LD_INT 4
39878: NEG
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 4
39886: NEG
39887: PUSH
39888: LD_INT 5
39890: NEG
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 3
39898: NEG
39899: PUSH
39900: LD_INT 4
39902: NEG
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 3
39910: NEG
39911: PUSH
39912: LD_INT 3
39914: NEG
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 4
39922: NEG
39923: PUSH
39924: LD_INT 3
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 5
39934: NEG
39935: PUSH
39936: LD_INT 4
39938: NEG
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 5
39946: NEG
39947: PUSH
39948: LD_INT 5
39950: NEG
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 3
39958: NEG
39959: PUSH
39960: LD_INT 5
39962: NEG
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 5
39970: NEG
39971: PUSH
39972: LD_INT 3
39974: NEG
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40027: LD_ADDR_VAR 0 30
40031: PUSH
40032: LD_INT 4
40034: PUSH
40035: LD_INT 4
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 4
40044: PUSH
40045: LD_INT 3
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 5
40054: PUSH
40055: LD_INT 4
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 5
40064: PUSH
40065: LD_INT 5
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 4
40074: PUSH
40075: LD_INT 5
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 3
40084: PUSH
40085: LD_INT 4
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 3
40094: PUSH
40095: LD_INT 3
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 5
40104: PUSH
40105: LD_INT 3
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 3
40114: PUSH
40115: LD_INT 5
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: LD_INT 3
40127: PUSH
40128: EMPTY
40129: LIST
40130: LIST
40131: PUSH
40132: LD_INT 0
40134: PUSH
40135: LD_INT 2
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 3
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 1
40154: PUSH
40155: LD_INT 4
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 4
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: LD_INT 3
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 2
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 2
40196: PUSH
40197: LD_INT 4
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 2
40206: NEG
40207: PUSH
40208: LD_INT 2
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 4
40217: NEG
40218: PUSH
40219: LD_INT 0
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 4
40228: NEG
40229: PUSH
40230: LD_INT 1
40232: NEG
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 3
40240: NEG
40241: PUSH
40242: LD_INT 0
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 3
40251: NEG
40252: PUSH
40253: LD_INT 1
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: LD_INT 4
40262: NEG
40263: PUSH
40264: LD_INT 1
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 5
40273: NEG
40274: PUSH
40275: LD_INT 0
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: PUSH
40282: LD_INT 5
40284: NEG
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 5
40296: NEG
40297: PUSH
40298: LD_INT 2
40300: NEG
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 3
40308: NEG
40309: PUSH
40310: LD_INT 2
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 3
40319: NEG
40320: PUSH
40321: LD_INT 3
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 3
40331: NEG
40332: PUSH
40333: LD_INT 4
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 2
40343: NEG
40344: PUSH
40345: LD_INT 3
40347: NEG
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 2
40355: NEG
40356: PUSH
40357: LD_INT 2
40359: NEG
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: NEG
40368: PUSH
40369: LD_INT 2
40371: NEG
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 4
40379: NEG
40380: PUSH
40381: LD_INT 3
40383: NEG
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: PUSH
40389: LD_INT 4
40391: NEG
40392: PUSH
40393: LD_INT 4
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 4
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 4
40415: NEG
40416: PUSH
40417: LD_INT 2
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 0
40427: PUSH
40428: LD_INT 4
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 0
40438: PUSH
40439: LD_INT 5
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 1
40449: PUSH
40450: LD_INT 4
40452: NEG
40453: PUSH
40454: EMPTY
40455: LIST
40456: LIST
40457: PUSH
40458: LD_INT 1
40460: PUSH
40461: LD_INT 3
40463: NEG
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 0
40471: PUSH
40472: LD_INT 3
40474: NEG
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 1
40482: NEG
40483: PUSH
40484: LD_INT 4
40486: NEG
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: NEG
40495: PUSH
40496: LD_INT 5
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 2
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 2
40517: NEG
40518: PUSH
40519: LD_INT 5
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: EMPTY
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: LIST
40533: LIST
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: LIST
40561: LIST
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: LIST
40570: LIST
40571: LIST
40572: LIST
40573: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40574: LD_ADDR_VAR 0 31
40578: PUSH
40579: LD_INT 0
40581: PUSH
40582: LD_INT 4
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_INT 3
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: PUSH
40602: LD_INT 4
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: LD_INT 5
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 0
40621: PUSH
40622: LD_INT 5
40624: PUSH
40625: EMPTY
40626: LIST
40627: LIST
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: LD_INT 4
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 1
40642: NEG
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 2
40653: PUSH
40654: LD_INT 5
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 2
40663: NEG
40664: PUSH
40665: LD_INT 3
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 3
40674: NEG
40675: PUSH
40676: LD_INT 0
40678: PUSH
40679: EMPTY
40680: LIST
40681: LIST
40682: PUSH
40683: LD_INT 3
40685: NEG
40686: PUSH
40687: LD_INT 1
40689: NEG
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 2
40697: NEG
40698: PUSH
40699: LD_INT 0
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 2
40708: NEG
40709: PUSH
40710: LD_INT 1
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 3
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 4
40730: NEG
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 4
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 4
40753: NEG
40754: PUSH
40755: LD_INT 2
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 2
40765: NEG
40766: PUSH
40767: LD_INT 2
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 4
40776: NEG
40777: PUSH
40778: LD_INT 4
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 4
40788: NEG
40789: PUSH
40790: LD_INT 5
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 3
40800: NEG
40801: PUSH
40802: LD_INT 4
40804: NEG
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 3
40812: NEG
40813: PUSH
40814: LD_INT 3
40816: NEG
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 4
40824: NEG
40825: PUSH
40826: LD_INT 3
40828: NEG
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 5
40836: NEG
40837: PUSH
40838: LD_INT 4
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 5
40848: NEG
40849: PUSH
40850: LD_INT 5
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 3
40860: NEG
40861: PUSH
40862: LD_INT 5
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 5
40872: NEG
40873: PUSH
40874: LD_INT 3
40876: NEG
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: LD_INT 3
40887: NEG
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 0
40895: PUSH
40896: LD_INT 4
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: LD_INT 3
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 1
40917: PUSH
40918: LD_INT 2
40920: NEG
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 0
40928: PUSH
40929: LD_INT 2
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 3
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: NEG
40952: PUSH
40953: LD_INT 4
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 2
40963: PUSH
40964: LD_INT 2
40966: NEG
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 4
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 4
40986: PUSH
40987: LD_INT 0
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: LD_INT 4
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 5
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: LD_INT 5
41017: PUSH
41018: LD_INT 1
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 4
41027: PUSH
41028: LD_INT 1
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 3
41037: PUSH
41038: LD_INT 0
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: LD_INT 1
41050: NEG
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 3
41058: PUSH
41059: LD_INT 2
41061: NEG
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 5
41069: PUSH
41070: LD_INT 2
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: EMPTY
41078: LIST
41079: LIST
41080: LIST
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: LIST
41089: LIST
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: LIST
41121: LIST
41122: LIST
41123: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41124: LD_ADDR_VAR 0 32
41128: PUSH
41129: LD_INT 4
41131: NEG
41132: PUSH
41133: LD_INT 0
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: PUSH
41140: LD_INT 4
41142: NEG
41143: PUSH
41144: LD_INT 1
41146: NEG
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: NEG
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 3
41165: NEG
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 4
41176: NEG
41177: PUSH
41178: LD_INT 1
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 5
41187: NEG
41188: PUSH
41189: LD_INT 0
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 5
41198: NEG
41199: PUSH
41200: LD_INT 1
41202: NEG
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 5
41210: NEG
41211: PUSH
41212: LD_INT 2
41214: NEG
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: LD_INT 3
41222: NEG
41223: PUSH
41224: LD_INT 2
41226: PUSH
41227: EMPTY
41228: LIST
41229: LIST
41230: PUSH
41231: LD_INT 3
41233: NEG
41234: PUSH
41235: LD_INT 3
41237: NEG
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 3
41245: NEG
41246: PUSH
41247: LD_INT 4
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: NEG
41258: PUSH
41259: LD_INT 3
41261: NEG
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 2
41269: NEG
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: LD_INT 3
41281: NEG
41282: PUSH
41283: LD_INT 2
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 4
41293: NEG
41294: PUSH
41295: LD_INT 3
41297: NEG
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: PUSH
41303: LD_INT 4
41305: NEG
41306: PUSH
41307: LD_INT 4
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 4
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 4
41329: NEG
41330: PUSH
41331: LD_INT 2
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 0
41341: PUSH
41342: LD_INT 4
41344: NEG
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 0
41352: PUSH
41353: LD_INT 5
41355: NEG
41356: PUSH
41357: EMPTY
41358: LIST
41359: LIST
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: LD_INT 4
41366: NEG
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: PUSH
41375: LD_INT 3
41377: NEG
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 0
41385: PUSH
41386: LD_INT 3
41388: NEG
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 1
41396: NEG
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 1
41408: NEG
41409: PUSH
41410: LD_INT 5
41412: NEG
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 2
41420: PUSH
41421: LD_INT 3
41423: NEG
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 2
41431: NEG
41432: PUSH
41433: LD_INT 5
41435: NEG
41436: PUSH
41437: EMPTY
41438: LIST
41439: LIST
41440: PUSH
41441: LD_INT 3
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 3
41453: PUSH
41454: LD_INT 1
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 4
41464: PUSH
41465: LD_INT 0
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: LD_INT 4
41474: PUSH
41475: LD_INT 1
41477: PUSH
41478: EMPTY
41479: LIST
41480: LIST
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 1
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 2
41494: PUSH
41495: LD_INT 0
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 1
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 2
41515: PUSH
41516: LD_INT 2
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 4
41526: PUSH
41527: LD_INT 2
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 4
41536: PUSH
41537: LD_INT 4
41539: PUSH
41540: EMPTY
41541: LIST
41542: LIST
41543: PUSH
41544: LD_INT 4
41546: PUSH
41547: LD_INT 3
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 5
41556: PUSH
41557: LD_INT 4
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 5
41566: PUSH
41567: LD_INT 5
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: PUSH
41577: LD_INT 5
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 3
41586: PUSH
41587: LD_INT 4
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 3
41596: PUSH
41597: LD_INT 3
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 5
41606: PUSH
41607: LD_INT 3
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 3
41616: PUSH
41617: LD_INT 5
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: LIST
41646: LIST
41647: LIST
41648: LIST
41649: LIST
41650: LIST
41651: LIST
41652: LIST
41653: LIST
41654: LIST
41655: LIST
41656: LIST
41657: LIST
41658: LIST
41659: LIST
41660: LIST
41661: LIST
41662: LIST
41663: LIST
41664: LIST
41665: LIST
41666: LIST
41667: LIST
41668: LIST
41669: LIST
41670: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41671: LD_ADDR_VAR 0 33
41675: PUSH
41676: LD_INT 4
41678: NEG
41679: PUSH
41680: LD_INT 4
41682: NEG
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: LD_INT 4
41690: NEG
41691: PUSH
41692: LD_INT 5
41694: NEG
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 3
41702: NEG
41703: PUSH
41704: LD_INT 4
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 3
41714: NEG
41715: PUSH
41716: LD_INT 3
41718: NEG
41719: PUSH
41720: EMPTY
41721: LIST
41722: LIST
41723: PUSH
41724: LD_INT 4
41726: NEG
41727: PUSH
41728: LD_INT 3
41730: NEG
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 5
41738: NEG
41739: PUSH
41740: LD_INT 4
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 5
41750: NEG
41751: PUSH
41752: LD_INT 5
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: LD_INT 5
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 5
41774: NEG
41775: PUSH
41776: LD_INT 3
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 0
41786: PUSH
41787: LD_INT 3
41789: NEG
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: LD_INT 0
41797: PUSH
41798: LD_INT 4
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: LD_INT 3
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: LD_INT 2
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 0
41830: PUSH
41831: LD_INT 2
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 1
41841: NEG
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 4
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 2
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 2
41876: NEG
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 4
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 4
41898: PUSH
41899: LD_INT 1
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 5
41909: PUSH
41910: LD_INT 0
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 5
41919: PUSH
41920: LD_INT 1
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: LD_INT 4
41929: PUSH
41930: LD_INT 1
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: LD_INT 3
41939: PUSH
41940: LD_INT 0
41942: PUSH
41943: EMPTY
41944: LIST
41945: LIST
41946: PUSH
41947: LD_INT 3
41949: PUSH
41950: LD_INT 1
41952: NEG
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: LD_INT 2
41963: NEG
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 5
41971: PUSH
41972: LD_INT 2
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: LD_INT 3
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: LD_INT 2
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 4
42001: PUSH
42002: LD_INT 3
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: LD_INT 4
42014: PUSH
42015: EMPTY
42016: LIST
42017: LIST
42018: PUSH
42019: LD_INT 3
42021: PUSH
42022: LD_INT 4
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 2
42031: PUSH
42032: LD_INT 3
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 2
42041: PUSH
42042: LD_INT 2
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 4
42051: PUSH
42052: LD_INT 2
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 2
42061: PUSH
42062: LD_INT 4
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 0
42071: PUSH
42072: LD_INT 4
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 0
42081: PUSH
42082: LD_INT 3
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: LD_INT 1
42091: PUSH
42092: LD_INT 4
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: LD_INT 5
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 0
42111: PUSH
42112: LD_INT 5
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: NEG
42122: PUSH
42123: LD_INT 4
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 1
42132: NEG
42133: PUSH
42134: LD_INT 3
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 2
42143: PUSH
42144: LD_INT 5
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 2
42153: NEG
42154: PUSH
42155: LD_INT 3
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: LIST
42166: LIST
42167: LIST
42168: LIST
42169: LIST
42170: LIST
42171: LIST
42172: LIST
42173: LIST
42174: LIST
42175: LIST
42176: LIST
42177: LIST
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42209: LD_ADDR_VAR 0 34
42213: PUSH
42214: LD_INT 0
42216: PUSH
42217: LD_INT 4
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: LD_INT 5
42230: NEG
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: LD_INT 4
42241: NEG
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 1
42249: PUSH
42250: LD_INT 3
42252: NEG
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 0
42260: PUSH
42261: LD_INT 3
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 1
42271: NEG
42272: PUSH
42273: LD_INT 4
42275: NEG
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 1
42283: NEG
42284: PUSH
42285: LD_INT 5
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 3
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 2
42306: NEG
42307: PUSH
42308: LD_INT 5
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 3
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: EMPTY
42323: LIST
42324: LIST
42325: PUSH
42326: LD_INT 3
42328: PUSH
42329: LD_INT 1
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 4
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 4
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 3
42359: PUSH
42360: LD_INT 1
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: LD_INT 2
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: LD_INT 2
42379: PUSH
42380: LD_INT 1
42382: NEG
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 2
42390: PUSH
42391: LD_INT 2
42393: NEG
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 4
42401: PUSH
42402: LD_INT 2
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: LD_INT 4
42411: PUSH
42412: LD_INT 4
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 4
42421: PUSH
42422: LD_INT 3
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 5
42431: PUSH
42432: LD_INT 4
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 5
42441: PUSH
42442: LD_INT 5
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: LD_INT 4
42451: PUSH
42452: LD_INT 5
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: PUSH
42462: LD_INT 4
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 3
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: LD_INT 5
42481: PUSH
42482: LD_INT 3
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 3
42491: PUSH
42492: LD_INT 5
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 0
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 0
42511: PUSH
42512: LD_INT 2
42514: PUSH
42515: EMPTY
42516: LIST
42517: LIST
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: LD_INT 3
42524: PUSH
42525: EMPTY
42526: LIST
42527: LIST
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: LD_INT 4
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: LD_INT 0
42541: PUSH
42542: LD_INT 4
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: LD_INT 3
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 1
42562: NEG
42563: PUSH
42564: LD_INT 2
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 2
42573: PUSH
42574: LD_INT 4
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 2
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: LD_INT 4
42594: NEG
42595: PUSH
42596: LD_INT 0
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 4
42605: NEG
42606: PUSH
42607: LD_INT 1
42609: NEG
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 3
42617: NEG
42618: PUSH
42619: LD_INT 0
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 3
42628: NEG
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: PUSH
42637: LD_INT 4
42639: NEG
42640: PUSH
42641: LD_INT 1
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 5
42650: NEG
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 5
42661: NEG
42662: PUSH
42663: LD_INT 1
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 5
42673: NEG
42674: PUSH
42675: LD_INT 2
42677: NEG
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 3
42685: NEG
42686: PUSH
42687: LD_INT 2
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: LIST
42698: LIST
42699: LIST
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: LIST
42707: LIST
42708: LIST
42709: LIST
42710: LIST
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: LIST
42723: LIST
42724: LIST
42725: LIST
42726: LIST
42727: LIST
42728: LIST
42729: LIST
42730: LIST
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: ST_TO_ADDR
// end ; end ;
42741: GO 42744
42743: POP
// case btype of b_depot , b_warehouse :
42744: LD_VAR 0 1
42748: PUSH
42749: LD_INT 0
42751: DOUBLE
42752: EQUAL
42753: IFTRUE 42763
42755: LD_INT 1
42757: DOUBLE
42758: EQUAL
42759: IFTRUE 42763
42761: GO 42964
42763: POP
// case nation of nation_american :
42764: LD_VAR 0 5
42768: PUSH
42769: LD_INT 1
42771: DOUBLE
42772: EQUAL
42773: IFTRUE 42777
42775: GO 42833
42777: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42778: LD_ADDR_VAR 0 9
42782: PUSH
42783: LD_VAR 0 11
42787: PUSH
42788: LD_VAR 0 12
42792: PUSH
42793: LD_VAR 0 13
42797: PUSH
42798: LD_VAR 0 14
42802: PUSH
42803: LD_VAR 0 15
42807: PUSH
42808: LD_VAR 0 16
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: PUSH
42821: LD_VAR 0 4
42825: PUSH
42826: LD_INT 1
42828: PLUS
42829: ARRAY
42830: ST_TO_ADDR
42831: GO 42962
42833: LD_INT 2
42835: DOUBLE
42836: EQUAL
42837: IFTRUE 42841
42839: GO 42897
42841: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42842: LD_ADDR_VAR 0 9
42846: PUSH
42847: LD_VAR 0 17
42851: PUSH
42852: LD_VAR 0 18
42856: PUSH
42857: LD_VAR 0 19
42861: PUSH
42862: LD_VAR 0 20
42866: PUSH
42867: LD_VAR 0 21
42871: PUSH
42872: LD_VAR 0 22
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: PUSH
42885: LD_VAR 0 4
42889: PUSH
42890: LD_INT 1
42892: PLUS
42893: ARRAY
42894: ST_TO_ADDR
42895: GO 42962
42897: LD_INT 3
42899: DOUBLE
42900: EQUAL
42901: IFTRUE 42905
42903: GO 42961
42905: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42906: LD_ADDR_VAR 0 9
42910: PUSH
42911: LD_VAR 0 23
42915: PUSH
42916: LD_VAR 0 24
42920: PUSH
42921: LD_VAR 0 25
42925: PUSH
42926: LD_VAR 0 26
42930: PUSH
42931: LD_VAR 0 27
42935: PUSH
42936: LD_VAR 0 28
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: LIST
42945: LIST
42946: LIST
42947: LIST
42948: PUSH
42949: LD_VAR 0 4
42953: PUSH
42954: LD_INT 1
42956: PLUS
42957: ARRAY
42958: ST_TO_ADDR
42959: GO 42962
42961: POP
42962: GO 43517
42964: LD_INT 2
42966: DOUBLE
42967: EQUAL
42968: IFTRUE 42978
42970: LD_INT 3
42972: DOUBLE
42973: EQUAL
42974: IFTRUE 42978
42976: GO 43034
42978: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42979: LD_ADDR_VAR 0 9
42983: PUSH
42984: LD_VAR 0 29
42988: PUSH
42989: LD_VAR 0 30
42993: PUSH
42994: LD_VAR 0 31
42998: PUSH
42999: LD_VAR 0 32
43003: PUSH
43004: LD_VAR 0 33
43008: PUSH
43009: LD_VAR 0 34
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: PUSH
43022: LD_VAR 0 4
43026: PUSH
43027: LD_INT 1
43029: PLUS
43030: ARRAY
43031: ST_TO_ADDR
43032: GO 43517
43034: LD_INT 16
43036: DOUBLE
43037: EQUAL
43038: IFTRUE 43096
43040: LD_INT 17
43042: DOUBLE
43043: EQUAL
43044: IFTRUE 43096
43046: LD_INT 18
43048: DOUBLE
43049: EQUAL
43050: IFTRUE 43096
43052: LD_INT 19
43054: DOUBLE
43055: EQUAL
43056: IFTRUE 43096
43058: LD_INT 22
43060: DOUBLE
43061: EQUAL
43062: IFTRUE 43096
43064: LD_INT 20
43066: DOUBLE
43067: EQUAL
43068: IFTRUE 43096
43070: LD_INT 21
43072: DOUBLE
43073: EQUAL
43074: IFTRUE 43096
43076: LD_INT 23
43078: DOUBLE
43079: EQUAL
43080: IFTRUE 43096
43082: LD_INT 24
43084: DOUBLE
43085: EQUAL
43086: IFTRUE 43096
43088: LD_INT 25
43090: DOUBLE
43091: EQUAL
43092: IFTRUE 43096
43094: GO 43152
43096: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43097: LD_ADDR_VAR 0 9
43101: PUSH
43102: LD_VAR 0 35
43106: PUSH
43107: LD_VAR 0 36
43111: PUSH
43112: LD_VAR 0 37
43116: PUSH
43117: LD_VAR 0 38
43121: PUSH
43122: LD_VAR 0 39
43126: PUSH
43127: LD_VAR 0 40
43131: PUSH
43132: EMPTY
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: LIST
43138: LIST
43139: PUSH
43140: LD_VAR 0 4
43144: PUSH
43145: LD_INT 1
43147: PLUS
43148: ARRAY
43149: ST_TO_ADDR
43150: GO 43517
43152: LD_INT 6
43154: DOUBLE
43155: EQUAL
43156: IFTRUE 43208
43158: LD_INT 7
43160: DOUBLE
43161: EQUAL
43162: IFTRUE 43208
43164: LD_INT 8
43166: DOUBLE
43167: EQUAL
43168: IFTRUE 43208
43170: LD_INT 13
43172: DOUBLE
43173: EQUAL
43174: IFTRUE 43208
43176: LD_INT 12
43178: DOUBLE
43179: EQUAL
43180: IFTRUE 43208
43182: LD_INT 15
43184: DOUBLE
43185: EQUAL
43186: IFTRUE 43208
43188: LD_INT 11
43190: DOUBLE
43191: EQUAL
43192: IFTRUE 43208
43194: LD_INT 14
43196: DOUBLE
43197: EQUAL
43198: IFTRUE 43208
43200: LD_INT 10
43202: DOUBLE
43203: EQUAL
43204: IFTRUE 43208
43206: GO 43264
43208: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43209: LD_ADDR_VAR 0 9
43213: PUSH
43214: LD_VAR 0 41
43218: PUSH
43219: LD_VAR 0 42
43223: PUSH
43224: LD_VAR 0 43
43228: PUSH
43229: LD_VAR 0 44
43233: PUSH
43234: LD_VAR 0 45
43238: PUSH
43239: LD_VAR 0 46
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: LIST
43250: LIST
43251: PUSH
43252: LD_VAR 0 4
43256: PUSH
43257: LD_INT 1
43259: PLUS
43260: ARRAY
43261: ST_TO_ADDR
43262: GO 43517
43264: LD_INT 36
43266: DOUBLE
43267: EQUAL
43268: IFTRUE 43272
43270: GO 43328
43272: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43273: LD_ADDR_VAR 0 9
43277: PUSH
43278: LD_VAR 0 47
43282: PUSH
43283: LD_VAR 0 48
43287: PUSH
43288: LD_VAR 0 49
43292: PUSH
43293: LD_VAR 0 50
43297: PUSH
43298: LD_VAR 0 51
43302: PUSH
43303: LD_VAR 0 52
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: LIST
43313: LIST
43314: LIST
43315: PUSH
43316: LD_VAR 0 4
43320: PUSH
43321: LD_INT 1
43323: PLUS
43324: ARRAY
43325: ST_TO_ADDR
43326: GO 43517
43328: LD_INT 4
43330: DOUBLE
43331: EQUAL
43332: IFTRUE 43354
43334: LD_INT 5
43336: DOUBLE
43337: EQUAL
43338: IFTRUE 43354
43340: LD_INT 34
43342: DOUBLE
43343: EQUAL
43344: IFTRUE 43354
43346: LD_INT 37
43348: DOUBLE
43349: EQUAL
43350: IFTRUE 43354
43352: GO 43410
43354: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43355: LD_ADDR_VAR 0 9
43359: PUSH
43360: LD_VAR 0 53
43364: PUSH
43365: LD_VAR 0 54
43369: PUSH
43370: LD_VAR 0 55
43374: PUSH
43375: LD_VAR 0 56
43379: PUSH
43380: LD_VAR 0 57
43384: PUSH
43385: LD_VAR 0 58
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: PUSH
43398: LD_VAR 0 4
43402: PUSH
43403: LD_INT 1
43405: PLUS
43406: ARRAY
43407: ST_TO_ADDR
43408: GO 43517
43410: LD_INT 31
43412: DOUBLE
43413: EQUAL
43414: IFTRUE 43460
43416: LD_INT 32
43418: DOUBLE
43419: EQUAL
43420: IFTRUE 43460
43422: LD_INT 33
43424: DOUBLE
43425: EQUAL
43426: IFTRUE 43460
43428: LD_INT 27
43430: DOUBLE
43431: EQUAL
43432: IFTRUE 43460
43434: LD_INT 26
43436: DOUBLE
43437: EQUAL
43438: IFTRUE 43460
43440: LD_INT 28
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43460
43446: LD_INT 29
43448: DOUBLE
43449: EQUAL
43450: IFTRUE 43460
43452: LD_INT 30
43454: DOUBLE
43455: EQUAL
43456: IFTRUE 43460
43458: GO 43516
43460: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43461: LD_ADDR_VAR 0 9
43465: PUSH
43466: LD_VAR 0 59
43470: PUSH
43471: LD_VAR 0 60
43475: PUSH
43476: LD_VAR 0 61
43480: PUSH
43481: LD_VAR 0 62
43485: PUSH
43486: LD_VAR 0 63
43490: PUSH
43491: LD_VAR 0 64
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: LIST
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 4
43508: PUSH
43509: LD_INT 1
43511: PLUS
43512: ARRAY
43513: ST_TO_ADDR
43514: GO 43517
43516: POP
// temp_list2 = [ ] ;
43517: LD_ADDR_VAR 0 10
43521: PUSH
43522: EMPTY
43523: ST_TO_ADDR
// for i in temp_list do
43524: LD_ADDR_VAR 0 8
43528: PUSH
43529: LD_VAR 0 9
43533: PUSH
43534: FOR_IN
43535: IFFALSE 43587
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43537: LD_ADDR_VAR 0 10
43541: PUSH
43542: LD_VAR 0 10
43546: PUSH
43547: LD_VAR 0 8
43551: PUSH
43552: LD_INT 1
43554: ARRAY
43555: PUSH
43556: LD_VAR 0 2
43560: PLUS
43561: PUSH
43562: LD_VAR 0 8
43566: PUSH
43567: LD_INT 2
43569: ARRAY
43570: PUSH
43571: LD_VAR 0 3
43575: PLUS
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: EMPTY
43582: LIST
43583: ADD
43584: ST_TO_ADDR
43585: GO 43534
43587: POP
43588: POP
// result = temp_list2 ;
43589: LD_ADDR_VAR 0 7
43593: PUSH
43594: LD_VAR 0 10
43598: ST_TO_ADDR
// end ;
43599: LD_VAR 0 7
43603: RET
// export function EnemyInRange ( unit , dist ) ; begin
43604: LD_INT 0
43606: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43607: LD_ADDR_VAR 0 3
43611: PUSH
43612: LD_VAR 0 1
43616: PPUSH
43617: CALL_OW 255
43621: PPUSH
43622: LD_VAR 0 1
43626: PPUSH
43627: CALL_OW 250
43631: PPUSH
43632: LD_VAR 0 1
43636: PPUSH
43637: CALL_OW 251
43641: PPUSH
43642: LD_VAR 0 2
43646: PPUSH
43647: CALL 17006 0 4
43651: PUSH
43652: LD_INT 4
43654: ARRAY
43655: ST_TO_ADDR
// end ;
43656: LD_VAR 0 3
43660: RET
// export function PlayerSeeMe ( unit ) ; begin
43661: LD_INT 0
43663: PPUSH
// result := See ( your_side , unit ) ;
43664: LD_ADDR_VAR 0 2
43668: PUSH
43669: LD_OWVAR 2
43673: PPUSH
43674: LD_VAR 0 1
43678: PPUSH
43679: CALL_OW 292
43683: ST_TO_ADDR
// end ;
43684: LD_VAR 0 2
43688: RET
// export function ReverseDir ( unit ) ; begin
43689: LD_INT 0
43691: PPUSH
// if not unit then
43692: LD_VAR 0 1
43696: NOT
43697: IFFALSE 43701
// exit ;
43699: GO 43724
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43701: LD_ADDR_VAR 0 2
43705: PUSH
43706: LD_VAR 0 1
43710: PPUSH
43711: CALL_OW 254
43715: PUSH
43716: LD_INT 3
43718: PLUS
43719: PUSH
43720: LD_INT 6
43722: MOD
43723: ST_TO_ADDR
// end ;
43724: LD_VAR 0 2
43728: RET
// export function ReverseArray ( array ) ; var i ; begin
43729: LD_INT 0
43731: PPUSH
43732: PPUSH
// if not array then
43733: LD_VAR 0 1
43737: NOT
43738: IFFALSE 43742
// exit ;
43740: GO 43797
// result := [ ] ;
43742: LD_ADDR_VAR 0 2
43746: PUSH
43747: EMPTY
43748: ST_TO_ADDR
// for i := array downto 1 do
43749: LD_ADDR_VAR 0 3
43753: PUSH
43754: DOUBLE
43755: LD_VAR 0 1
43759: INC
43760: ST_TO_ADDR
43761: LD_INT 1
43763: PUSH
43764: FOR_DOWNTO
43765: IFFALSE 43795
// result := Join ( result , array [ i ] ) ;
43767: LD_ADDR_VAR 0 2
43771: PUSH
43772: LD_VAR 0 2
43776: PPUSH
43777: LD_VAR 0 1
43781: PUSH
43782: LD_VAR 0 3
43786: ARRAY
43787: PPUSH
43788: CALL 48441 0 2
43792: ST_TO_ADDR
43793: GO 43764
43795: POP
43796: POP
// end ;
43797: LD_VAR 0 2
43801: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
43802: LD_INT 0
43804: PPUSH
43805: PPUSH
43806: PPUSH
43807: PPUSH
43808: PPUSH
43809: PPUSH
// if not unit or not hexes then
43810: LD_VAR 0 1
43814: NOT
43815: PUSH
43816: LD_VAR 0 2
43820: NOT
43821: OR
43822: IFFALSE 43826
// exit ;
43824: GO 43949
// dist := 9999 ;
43826: LD_ADDR_VAR 0 5
43830: PUSH
43831: LD_INT 9999
43833: ST_TO_ADDR
// for i = 1 to hexes do
43834: LD_ADDR_VAR 0 4
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_VAR 0 2
43848: PUSH
43849: FOR_TO
43850: IFFALSE 43937
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43852: LD_ADDR_VAR 0 6
43856: PUSH
43857: LD_VAR 0 1
43861: PPUSH
43862: LD_VAR 0 2
43866: PUSH
43867: LD_VAR 0 4
43871: ARRAY
43872: PUSH
43873: LD_INT 1
43875: ARRAY
43876: PPUSH
43877: LD_VAR 0 2
43881: PUSH
43882: LD_VAR 0 4
43886: ARRAY
43887: PUSH
43888: LD_INT 2
43890: ARRAY
43891: PPUSH
43892: CALL_OW 297
43896: ST_TO_ADDR
// if tdist < dist then
43897: LD_VAR 0 6
43901: PUSH
43902: LD_VAR 0 5
43906: LESS
43907: IFFALSE 43935
// begin hex := hexes [ i ] ;
43909: LD_ADDR_VAR 0 8
43913: PUSH
43914: LD_VAR 0 2
43918: PUSH
43919: LD_VAR 0 4
43923: ARRAY
43924: ST_TO_ADDR
// dist := tdist ;
43925: LD_ADDR_VAR 0 5
43929: PUSH
43930: LD_VAR 0 6
43934: ST_TO_ADDR
// end ; end ;
43935: GO 43849
43937: POP
43938: POP
// result := hex ;
43939: LD_ADDR_VAR 0 3
43943: PUSH
43944: LD_VAR 0 8
43948: ST_TO_ADDR
// end ;
43949: LD_VAR 0 3
43953: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43954: LD_INT 0
43956: PPUSH
43957: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43958: LD_VAR 0 1
43962: NOT
43963: PUSH
43964: LD_VAR 0 1
43968: PUSH
43969: LD_INT 21
43971: PUSH
43972: LD_INT 2
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 23
43981: PUSH
43982: LD_INT 2
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: EMPTY
43990: LIST
43991: LIST
43992: PPUSH
43993: CALL_OW 69
43997: IN
43998: NOT
43999: OR
44000: IFFALSE 44004
// exit ;
44002: GO 44051
// for i = 1 to 3 do
44004: LD_ADDR_VAR 0 3
44008: PUSH
44009: DOUBLE
44010: LD_INT 1
44012: DEC
44013: ST_TO_ADDR
44014: LD_INT 3
44016: PUSH
44017: FOR_TO
44018: IFFALSE 44049
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44020: LD_VAR 0 1
44024: PPUSH
44025: CALL_OW 250
44029: PPUSH
44030: LD_VAR 0 1
44034: PPUSH
44035: CALL_OW 251
44039: PPUSH
44040: LD_INT 1
44042: PPUSH
44043: CALL_OW 453
44047: GO 44017
44049: POP
44050: POP
// end ;
44051: LD_VAR 0 2
44055: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44056: LD_INT 0
44058: PPUSH
44059: PPUSH
44060: PPUSH
44061: PPUSH
44062: PPUSH
44063: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
44064: LD_VAR 0 1
44068: NOT
44069: PUSH
44070: LD_VAR 0 2
44074: NOT
44075: OR
44076: PUSH
44077: LD_VAR 0 1
44081: PPUSH
44082: CALL_OW 314
44086: OR
44087: IFFALSE 44091
// exit ;
44089: GO 44558
// if GetLives ( i ) < 250 then
44091: LD_VAR 0 4
44095: PPUSH
44096: CALL_OW 256
44100: PUSH
44101: LD_INT 250
44103: LESS
44104: IFFALSE 44117
// begin ComAutodestruct ( i ) ;
44106: LD_VAR 0 4
44110: PPUSH
44111: CALL 43954 0 1
// exit ;
44115: GO 44558
// end ; x := GetX ( enemy_unit ) ;
44117: LD_ADDR_VAR 0 7
44121: PUSH
44122: LD_VAR 0 2
44126: PPUSH
44127: CALL_OW 250
44131: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44132: LD_ADDR_VAR 0 8
44136: PUSH
44137: LD_VAR 0 2
44141: PPUSH
44142: CALL_OW 251
44146: ST_TO_ADDR
// if not x or not y then
44147: LD_VAR 0 7
44151: NOT
44152: PUSH
44153: LD_VAR 0 8
44157: NOT
44158: OR
44159: IFFALSE 44163
// exit ;
44161: GO 44558
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44163: LD_ADDR_VAR 0 6
44167: PUSH
44168: LD_VAR 0 7
44172: PPUSH
44173: LD_INT 0
44175: PPUSH
44176: LD_INT 4
44178: PPUSH
44179: CALL_OW 272
44183: PUSH
44184: LD_VAR 0 8
44188: PPUSH
44189: LD_INT 0
44191: PPUSH
44192: LD_INT 4
44194: PPUSH
44195: CALL_OW 273
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_VAR 0 7
44208: PPUSH
44209: LD_INT 1
44211: PPUSH
44212: LD_INT 4
44214: PPUSH
44215: CALL_OW 272
44219: PUSH
44220: LD_VAR 0 8
44224: PPUSH
44225: LD_INT 1
44227: PPUSH
44228: LD_INT 4
44230: PPUSH
44231: CALL_OW 273
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_VAR 0 7
44244: PPUSH
44245: LD_INT 2
44247: PPUSH
44248: LD_INT 4
44250: PPUSH
44251: CALL_OW 272
44255: PUSH
44256: LD_VAR 0 8
44260: PPUSH
44261: LD_INT 2
44263: PPUSH
44264: LD_INT 4
44266: PPUSH
44267: CALL_OW 273
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_VAR 0 7
44280: PPUSH
44281: LD_INT 3
44283: PPUSH
44284: LD_INT 4
44286: PPUSH
44287: CALL_OW 272
44291: PUSH
44292: LD_VAR 0 8
44296: PPUSH
44297: LD_INT 3
44299: PPUSH
44300: LD_INT 4
44302: PPUSH
44303: CALL_OW 273
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_VAR 0 7
44316: PPUSH
44317: LD_INT 4
44319: PPUSH
44320: LD_INT 4
44322: PPUSH
44323: CALL_OW 272
44327: PUSH
44328: LD_VAR 0 8
44332: PPUSH
44333: LD_INT 4
44335: PPUSH
44336: LD_INT 4
44338: PPUSH
44339: CALL_OW 273
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_VAR 0 7
44352: PPUSH
44353: LD_INT 5
44355: PPUSH
44356: LD_INT 4
44358: PPUSH
44359: CALL_OW 272
44363: PUSH
44364: LD_VAR 0 8
44368: PPUSH
44369: LD_INT 5
44371: PPUSH
44372: LD_INT 4
44374: PPUSH
44375: CALL_OW 273
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: ST_TO_ADDR
// for i = tmp downto 1 do
44392: LD_ADDR_VAR 0 4
44396: PUSH
44397: DOUBLE
44398: LD_VAR 0 6
44402: INC
44403: ST_TO_ADDR
44404: LD_INT 1
44406: PUSH
44407: FOR_DOWNTO
44408: IFFALSE 44509
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44410: LD_VAR 0 6
44414: PUSH
44415: LD_VAR 0 4
44419: ARRAY
44420: PUSH
44421: LD_INT 1
44423: ARRAY
44424: PPUSH
44425: LD_VAR 0 6
44429: PUSH
44430: LD_VAR 0 4
44434: ARRAY
44435: PUSH
44436: LD_INT 2
44438: ARRAY
44439: PPUSH
44440: CALL_OW 488
44444: NOT
44445: PUSH
44446: LD_VAR 0 6
44450: PUSH
44451: LD_VAR 0 4
44455: ARRAY
44456: PUSH
44457: LD_INT 1
44459: ARRAY
44460: PPUSH
44461: LD_VAR 0 6
44465: PUSH
44466: LD_VAR 0 4
44470: ARRAY
44471: PUSH
44472: LD_INT 2
44474: ARRAY
44475: PPUSH
44476: CALL_OW 428
44480: PUSH
44481: LD_INT 0
44483: NONEQUAL
44484: OR
44485: IFFALSE 44507
// tmp := Delete ( tmp , i ) ;
44487: LD_ADDR_VAR 0 6
44491: PUSH
44492: LD_VAR 0 6
44496: PPUSH
44497: LD_VAR 0 4
44501: PPUSH
44502: CALL_OW 3
44506: ST_TO_ADDR
44507: GO 44407
44509: POP
44510: POP
// j := GetClosestHex ( unit , tmp ) ;
44511: LD_ADDR_VAR 0 5
44515: PUSH
44516: LD_VAR 0 1
44520: PPUSH
44521: LD_VAR 0 6
44525: PPUSH
44526: CALL 43802 0 2
44530: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44531: LD_VAR 0 1
44535: PPUSH
44536: LD_VAR 0 5
44540: PUSH
44541: LD_INT 1
44543: ARRAY
44544: PPUSH
44545: LD_VAR 0 5
44549: PUSH
44550: LD_INT 2
44552: ARRAY
44553: PPUSH
44554: CALL_OW 111
// end ;
44558: LD_VAR 0 3
44562: RET
// export function PrepareApemanSoldier ( ) ; begin
44563: LD_INT 0
44565: PPUSH
// uc_nation := 0 ;
44566: LD_ADDR_OWVAR 21
44570: PUSH
44571: LD_INT 0
44573: ST_TO_ADDR
// hc_sex := sex_male ;
44574: LD_ADDR_OWVAR 27
44578: PUSH
44579: LD_INT 1
44581: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
44582: LD_ADDR_OWVAR 28
44586: PUSH
44587: LD_INT 15
44589: ST_TO_ADDR
// hc_gallery :=  ;
44590: LD_ADDR_OWVAR 33
44594: PUSH
44595: LD_STRING 
44597: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44598: LD_ADDR_OWVAR 31
44602: PUSH
44603: LD_INT 0
44605: PPUSH
44606: LD_INT 3
44608: PPUSH
44609: CALL_OW 12
44613: PUSH
44614: LD_INT 0
44616: PPUSH
44617: LD_INT 3
44619: PPUSH
44620: CALL_OW 12
44624: PUSH
44625: LD_INT 0
44627: PUSH
44628: LD_INT 0
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: ST_TO_ADDR
// end ;
44637: LD_VAR 0 1
44641: RET
// export function PrepareApemanEngineer ( ) ; begin
44642: LD_INT 0
44644: PPUSH
// uc_nation := 0 ;
44645: LD_ADDR_OWVAR 21
44649: PUSH
44650: LD_INT 0
44652: ST_TO_ADDR
// hc_sex := sex_male ;
44653: LD_ADDR_OWVAR 27
44657: PUSH
44658: LD_INT 1
44660: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
44661: LD_ADDR_OWVAR 28
44665: PUSH
44666: LD_INT 16
44668: ST_TO_ADDR
// hc_gallery :=  ;
44669: LD_ADDR_OWVAR 33
44673: PUSH
44674: LD_STRING 
44676: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44677: LD_ADDR_OWVAR 31
44681: PUSH
44682: LD_INT 0
44684: PPUSH
44685: LD_INT 3
44687: PPUSH
44688: CALL_OW 12
44692: PUSH
44693: LD_INT 0
44695: PPUSH
44696: LD_INT 3
44698: PPUSH
44699: CALL_OW 12
44703: PUSH
44704: LD_INT 0
44706: PUSH
44707: LD_INT 0
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: LIST
44714: LIST
44715: ST_TO_ADDR
// end ;
44716: LD_VAR 0 1
44720: RET
// export function PrepareApeman ( agressivity ) ; begin
44721: LD_INT 0
44723: PPUSH
// uc_side := 0 ;
44724: LD_ADDR_OWVAR 20
44728: PUSH
44729: LD_INT 0
44731: ST_TO_ADDR
// uc_nation := 0 ;
44732: LD_ADDR_OWVAR 21
44736: PUSH
44737: LD_INT 0
44739: ST_TO_ADDR
// hc_sex := sex_male ;
44740: LD_ADDR_OWVAR 27
44744: PUSH
44745: LD_INT 1
44747: ST_TO_ADDR
// hc_class := class_apeman ;
44748: LD_ADDR_OWVAR 28
44752: PUSH
44753: LD_INT 12
44755: ST_TO_ADDR
// hc_gallery :=  ;
44756: LD_ADDR_OWVAR 33
44760: PUSH
44761: LD_STRING 
44763: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44764: LD_ADDR_OWVAR 35
44768: PUSH
44769: LD_VAR 0 1
44773: NEG
44774: PPUSH
44775: LD_VAR 0 1
44779: PPUSH
44780: CALL_OW 12
44784: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
44785: LD_ADDR_OWVAR 31
44789: PUSH
44790: LD_INT 0
44792: PPUSH
44793: LD_INT 3
44795: PPUSH
44796: CALL_OW 12
44800: PUSH
44801: LD_INT 0
44803: PPUSH
44804: LD_INT 3
44806: PPUSH
44807: CALL_OW 12
44811: PUSH
44812: LD_INT 0
44814: PUSH
44815: LD_INT 0
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: ST_TO_ADDR
// end ;
44824: LD_VAR 0 2
44828: RET
// export function PrepareTiger ( agressivity ) ; begin
44829: LD_INT 0
44831: PPUSH
// uc_side := 0 ;
44832: LD_ADDR_OWVAR 20
44836: PUSH
44837: LD_INT 0
44839: ST_TO_ADDR
// uc_nation := 0 ;
44840: LD_ADDR_OWVAR 21
44844: PUSH
44845: LD_INT 0
44847: ST_TO_ADDR
// hc_class := class_tiger ;
44848: LD_ADDR_OWVAR 28
44852: PUSH
44853: LD_INT 14
44855: ST_TO_ADDR
// hc_gallery :=  ;
44856: LD_ADDR_OWVAR 33
44860: PUSH
44861: LD_STRING 
44863: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
44864: LD_ADDR_OWVAR 35
44868: PUSH
44869: LD_VAR 0 1
44873: NEG
44874: PPUSH
44875: LD_VAR 0 1
44879: PPUSH
44880: CALL_OW 12
44884: ST_TO_ADDR
// end ;
44885: LD_VAR 0 2
44889: RET
// export function PrepareEnchidna ( ) ; begin
44890: LD_INT 0
44892: PPUSH
// uc_side := 0 ;
44893: LD_ADDR_OWVAR 20
44897: PUSH
44898: LD_INT 0
44900: ST_TO_ADDR
// uc_nation := 0 ;
44901: LD_ADDR_OWVAR 21
44905: PUSH
44906: LD_INT 0
44908: ST_TO_ADDR
// hc_class := class_baggie ;
44909: LD_ADDR_OWVAR 28
44913: PUSH
44914: LD_INT 13
44916: ST_TO_ADDR
// hc_gallery :=  ;
44917: LD_ADDR_OWVAR 33
44921: PUSH
44922: LD_STRING 
44924: ST_TO_ADDR
// end ;
44925: LD_VAR 0 1
44929: RET
// export function PrepareFrog ( ) ; begin
44930: LD_INT 0
44932: PPUSH
// uc_side := 0 ;
44933: LD_ADDR_OWVAR 20
44937: PUSH
44938: LD_INT 0
44940: ST_TO_ADDR
// uc_nation := 0 ;
44941: LD_ADDR_OWVAR 21
44945: PUSH
44946: LD_INT 0
44948: ST_TO_ADDR
// hc_class := class_frog ;
44949: LD_ADDR_OWVAR 28
44953: PUSH
44954: LD_INT 19
44956: ST_TO_ADDR
// hc_gallery :=  ;
44957: LD_ADDR_OWVAR 33
44961: PUSH
44962: LD_STRING 
44964: ST_TO_ADDR
// end ;
44965: LD_VAR 0 1
44969: RET
// export function PrepareFish ( ) ; begin
44970: LD_INT 0
44972: PPUSH
// uc_side := 0 ;
44973: LD_ADDR_OWVAR 20
44977: PUSH
44978: LD_INT 0
44980: ST_TO_ADDR
// uc_nation := 0 ;
44981: LD_ADDR_OWVAR 21
44985: PUSH
44986: LD_INT 0
44988: ST_TO_ADDR
// hc_class := class_fish ;
44989: LD_ADDR_OWVAR 28
44993: PUSH
44994: LD_INT 20
44996: ST_TO_ADDR
// hc_gallery :=  ;
44997: LD_ADDR_OWVAR 33
45001: PUSH
45002: LD_STRING 
45004: ST_TO_ADDR
// end ;
45005: LD_VAR 0 1
45009: RET
// export function PrepareBird ( ) ; begin
45010: LD_INT 0
45012: PPUSH
// uc_side := 0 ;
45013: LD_ADDR_OWVAR 20
45017: PUSH
45018: LD_INT 0
45020: ST_TO_ADDR
// uc_nation := 0 ;
45021: LD_ADDR_OWVAR 21
45025: PUSH
45026: LD_INT 0
45028: ST_TO_ADDR
// hc_class := class_phororhacos ;
45029: LD_ADDR_OWVAR 28
45033: PUSH
45034: LD_INT 18
45036: ST_TO_ADDR
// hc_gallery :=  ;
45037: LD_ADDR_OWVAR 33
45041: PUSH
45042: LD_STRING 
45044: ST_TO_ADDR
// end ;
45045: LD_VAR 0 1
45049: RET
// export function PrepareHorse ( ) ; begin
45050: LD_INT 0
45052: PPUSH
// uc_side := 0 ;
45053: LD_ADDR_OWVAR 20
45057: PUSH
45058: LD_INT 0
45060: ST_TO_ADDR
// uc_nation := 0 ;
45061: LD_ADDR_OWVAR 21
45065: PUSH
45066: LD_INT 0
45068: ST_TO_ADDR
// hc_class := class_horse ;
45069: LD_ADDR_OWVAR 28
45073: PUSH
45074: LD_INT 21
45076: ST_TO_ADDR
// hc_gallery :=  ;
45077: LD_ADDR_OWVAR 33
45081: PUSH
45082: LD_STRING 
45084: ST_TO_ADDR
// end ;
45085: LD_VAR 0 1
45089: RET
// export function PrepareMastodont ( ) ; begin
45090: LD_INT 0
45092: PPUSH
// uc_side := 0 ;
45093: LD_ADDR_OWVAR 20
45097: PUSH
45098: LD_INT 0
45100: ST_TO_ADDR
// uc_nation := 0 ;
45101: LD_ADDR_OWVAR 21
45105: PUSH
45106: LD_INT 0
45108: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45109: LD_ADDR_OWVAR 37
45113: PUSH
45114: LD_INT 31
45116: ST_TO_ADDR
// vc_control := control_rider ;
45117: LD_ADDR_OWVAR 38
45121: PUSH
45122: LD_INT 4
45124: ST_TO_ADDR
// end ;
45125: LD_VAR 0 1
45129: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45130: LD_INT 0
45132: PPUSH
45133: PPUSH
45134: PPUSH
// uc_side = 0 ;
45135: LD_ADDR_OWVAR 20
45139: PUSH
45140: LD_INT 0
45142: ST_TO_ADDR
// uc_nation = 0 ;
45143: LD_ADDR_OWVAR 21
45147: PUSH
45148: LD_INT 0
45150: ST_TO_ADDR
// InitHc_All ( ) ;
45151: CALL_OW 584
// InitVc ;
45155: CALL_OW 20
// if mastodonts then
45159: LD_VAR 0 6
45163: IFFALSE 45230
// for i = 1 to mastodonts do
45165: LD_ADDR_VAR 0 11
45169: PUSH
45170: DOUBLE
45171: LD_INT 1
45173: DEC
45174: ST_TO_ADDR
45175: LD_VAR 0 6
45179: PUSH
45180: FOR_TO
45181: IFFALSE 45228
// begin vc_chassis := 31 ;
45183: LD_ADDR_OWVAR 37
45187: PUSH
45188: LD_INT 31
45190: ST_TO_ADDR
// vc_control := control_rider ;
45191: LD_ADDR_OWVAR 38
45195: PUSH
45196: LD_INT 4
45198: ST_TO_ADDR
// animal := CreateVehicle ;
45199: LD_ADDR_VAR 0 12
45203: PUSH
45204: CALL_OW 45
45208: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45209: LD_VAR 0 12
45213: PPUSH
45214: LD_VAR 0 8
45218: PPUSH
45219: LD_INT 0
45221: PPUSH
45222: CALL 47358 0 3
// end ;
45226: GO 45180
45228: POP
45229: POP
// if horses then
45230: LD_VAR 0 5
45234: IFFALSE 45301
// for i = 1 to horses do
45236: LD_ADDR_VAR 0 11
45240: PUSH
45241: DOUBLE
45242: LD_INT 1
45244: DEC
45245: ST_TO_ADDR
45246: LD_VAR 0 5
45250: PUSH
45251: FOR_TO
45252: IFFALSE 45299
// begin hc_class := 21 ;
45254: LD_ADDR_OWVAR 28
45258: PUSH
45259: LD_INT 21
45261: ST_TO_ADDR
// hc_gallery :=  ;
45262: LD_ADDR_OWVAR 33
45266: PUSH
45267: LD_STRING 
45269: ST_TO_ADDR
// animal := CreateHuman ;
45270: LD_ADDR_VAR 0 12
45274: PUSH
45275: CALL_OW 44
45279: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45280: LD_VAR 0 12
45284: PPUSH
45285: LD_VAR 0 8
45289: PPUSH
45290: LD_INT 0
45292: PPUSH
45293: CALL 47358 0 3
// end ;
45297: GO 45251
45299: POP
45300: POP
// if birds then
45301: LD_VAR 0 1
45305: IFFALSE 45372
// for i = 1 to birds do
45307: LD_ADDR_VAR 0 11
45311: PUSH
45312: DOUBLE
45313: LD_INT 1
45315: DEC
45316: ST_TO_ADDR
45317: LD_VAR 0 1
45321: PUSH
45322: FOR_TO
45323: IFFALSE 45370
// begin hc_class = 18 ;
45325: LD_ADDR_OWVAR 28
45329: PUSH
45330: LD_INT 18
45332: ST_TO_ADDR
// hc_gallery =  ;
45333: LD_ADDR_OWVAR 33
45337: PUSH
45338: LD_STRING 
45340: ST_TO_ADDR
// animal := CreateHuman ;
45341: LD_ADDR_VAR 0 12
45345: PUSH
45346: CALL_OW 44
45350: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45351: LD_VAR 0 12
45355: PPUSH
45356: LD_VAR 0 8
45360: PPUSH
45361: LD_INT 0
45363: PPUSH
45364: CALL 47358 0 3
// end ;
45368: GO 45322
45370: POP
45371: POP
// if tigers then
45372: LD_VAR 0 2
45376: IFFALSE 45460
// for i = 1 to tigers do
45378: LD_ADDR_VAR 0 11
45382: PUSH
45383: DOUBLE
45384: LD_INT 1
45386: DEC
45387: ST_TO_ADDR
45388: LD_VAR 0 2
45392: PUSH
45393: FOR_TO
45394: IFFALSE 45458
// begin hc_class = class_tiger ;
45396: LD_ADDR_OWVAR 28
45400: PUSH
45401: LD_INT 14
45403: ST_TO_ADDR
// hc_gallery =  ;
45404: LD_ADDR_OWVAR 33
45408: PUSH
45409: LD_STRING 
45411: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
45412: LD_ADDR_OWVAR 35
45416: PUSH
45417: LD_INT 7
45419: NEG
45420: PPUSH
45421: LD_INT 7
45423: PPUSH
45424: CALL_OW 12
45428: ST_TO_ADDR
// animal := CreateHuman ;
45429: LD_ADDR_VAR 0 12
45433: PUSH
45434: CALL_OW 44
45438: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45439: LD_VAR 0 12
45443: PPUSH
45444: LD_VAR 0 8
45448: PPUSH
45449: LD_INT 0
45451: PPUSH
45452: CALL 47358 0 3
// end ;
45456: GO 45393
45458: POP
45459: POP
// if apemans then
45460: LD_VAR 0 3
45464: IFFALSE 45587
// for i = 1 to apemans do
45466: LD_ADDR_VAR 0 11
45470: PUSH
45471: DOUBLE
45472: LD_INT 1
45474: DEC
45475: ST_TO_ADDR
45476: LD_VAR 0 3
45480: PUSH
45481: FOR_TO
45482: IFFALSE 45585
// begin hc_class = class_apeman ;
45484: LD_ADDR_OWVAR 28
45488: PUSH
45489: LD_INT 12
45491: ST_TO_ADDR
// hc_gallery =  ;
45492: LD_ADDR_OWVAR 33
45496: PUSH
45497: LD_STRING 
45499: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
45500: LD_ADDR_OWVAR 35
45504: PUSH
45505: LD_INT 2
45507: NEG
45508: PPUSH
45509: LD_INT 2
45511: PPUSH
45512: CALL_OW 12
45516: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
45517: LD_ADDR_OWVAR 31
45521: PUSH
45522: LD_INT 1
45524: PPUSH
45525: LD_INT 3
45527: PPUSH
45528: CALL_OW 12
45532: PUSH
45533: LD_INT 1
45535: PPUSH
45536: LD_INT 3
45538: PPUSH
45539: CALL_OW 12
45543: PUSH
45544: LD_INT 0
45546: PUSH
45547: LD_INT 0
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: ST_TO_ADDR
// animal := CreateHuman ;
45556: LD_ADDR_VAR 0 12
45560: PUSH
45561: CALL_OW 44
45565: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45566: LD_VAR 0 12
45570: PPUSH
45571: LD_VAR 0 8
45575: PPUSH
45576: LD_INT 0
45578: PPUSH
45579: CALL 47358 0 3
// end ;
45583: GO 45481
45585: POP
45586: POP
// if enchidnas then
45587: LD_VAR 0 4
45591: IFFALSE 45658
// for i = 1 to enchidnas do
45593: LD_ADDR_VAR 0 11
45597: PUSH
45598: DOUBLE
45599: LD_INT 1
45601: DEC
45602: ST_TO_ADDR
45603: LD_VAR 0 4
45607: PUSH
45608: FOR_TO
45609: IFFALSE 45656
// begin hc_class = 13 ;
45611: LD_ADDR_OWVAR 28
45615: PUSH
45616: LD_INT 13
45618: ST_TO_ADDR
// hc_gallery =  ;
45619: LD_ADDR_OWVAR 33
45623: PUSH
45624: LD_STRING 
45626: ST_TO_ADDR
// animal := CreateHuman ;
45627: LD_ADDR_VAR 0 12
45631: PUSH
45632: CALL_OW 44
45636: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
45637: LD_VAR 0 12
45641: PPUSH
45642: LD_VAR 0 8
45646: PPUSH
45647: LD_INT 0
45649: PPUSH
45650: CALL 47358 0 3
// end ;
45654: GO 45608
45656: POP
45657: POP
// if fishes then
45658: LD_VAR 0 7
45662: IFFALSE 45729
// for i = 1 to fishes do
45664: LD_ADDR_VAR 0 11
45668: PUSH
45669: DOUBLE
45670: LD_INT 1
45672: DEC
45673: ST_TO_ADDR
45674: LD_VAR 0 7
45678: PUSH
45679: FOR_TO
45680: IFFALSE 45727
// begin hc_class = 20 ;
45682: LD_ADDR_OWVAR 28
45686: PUSH
45687: LD_INT 20
45689: ST_TO_ADDR
// hc_gallery =  ;
45690: LD_ADDR_OWVAR 33
45694: PUSH
45695: LD_STRING 
45697: ST_TO_ADDR
// animal := CreateHuman ;
45698: LD_ADDR_VAR 0 12
45702: PUSH
45703: CALL_OW 44
45707: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
45708: LD_VAR 0 12
45712: PPUSH
45713: LD_VAR 0 9
45717: PPUSH
45718: LD_INT 0
45720: PPUSH
45721: CALL 47358 0 3
// end ;
45725: GO 45679
45727: POP
45728: POP
// end ;
45729: LD_VAR 0 10
45733: RET
// export function WantHeal ( sci , unit ) ; begin
45734: LD_INT 0
45736: PPUSH
// if GetTaskList ( sci ) > 0 then
45737: LD_VAR 0 1
45741: PPUSH
45742: CALL_OW 437
45746: PUSH
45747: LD_INT 0
45749: GREATER
45750: IFFALSE 45820
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
45752: LD_VAR 0 1
45756: PPUSH
45757: CALL_OW 437
45761: PUSH
45762: LD_INT 1
45764: ARRAY
45765: PUSH
45766: LD_INT 1
45768: ARRAY
45769: PUSH
45770: LD_STRING l
45772: EQUAL
45773: PUSH
45774: LD_VAR 0 1
45778: PPUSH
45779: CALL_OW 437
45783: PUSH
45784: LD_INT 1
45786: ARRAY
45787: PUSH
45788: LD_INT 4
45790: ARRAY
45791: PUSH
45792: LD_VAR 0 2
45796: EQUAL
45797: AND
45798: IFFALSE 45810
// result := true else
45800: LD_ADDR_VAR 0 3
45804: PUSH
45805: LD_INT 1
45807: ST_TO_ADDR
45808: GO 45818
// result := false ;
45810: LD_ADDR_VAR 0 3
45814: PUSH
45815: LD_INT 0
45817: ST_TO_ADDR
// end else
45818: GO 45828
// result := false ;
45820: LD_ADDR_VAR 0 3
45824: PUSH
45825: LD_INT 0
45827: ST_TO_ADDR
// end ;
45828: LD_VAR 0 3
45832: RET
// export function HealTarget ( sci ) ; begin
45833: LD_INT 0
45835: PPUSH
// if not sci then
45836: LD_VAR 0 1
45840: NOT
45841: IFFALSE 45845
// exit ;
45843: GO 45910
// result := 0 ;
45845: LD_ADDR_VAR 0 2
45849: PUSH
45850: LD_INT 0
45852: ST_TO_ADDR
// if GetTaskList ( sci ) then
45853: LD_VAR 0 1
45857: PPUSH
45858: CALL_OW 437
45862: IFFALSE 45910
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45864: LD_VAR 0 1
45868: PPUSH
45869: CALL_OW 437
45873: PUSH
45874: LD_INT 1
45876: ARRAY
45877: PUSH
45878: LD_INT 1
45880: ARRAY
45881: PUSH
45882: LD_STRING l
45884: EQUAL
45885: IFFALSE 45910
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45887: LD_ADDR_VAR 0 2
45891: PUSH
45892: LD_VAR 0 1
45896: PPUSH
45897: CALL_OW 437
45901: PUSH
45902: LD_INT 1
45904: ARRAY
45905: PUSH
45906: LD_INT 4
45908: ARRAY
45909: ST_TO_ADDR
// end ;
45910: LD_VAR 0 2
45914: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45915: LD_INT 0
45917: PPUSH
45918: PPUSH
45919: PPUSH
45920: PPUSH
// if not base_units then
45921: LD_VAR 0 1
45925: NOT
45926: IFFALSE 45930
// exit ;
45928: GO 46017
// result := false ;
45930: LD_ADDR_VAR 0 2
45934: PUSH
45935: LD_INT 0
45937: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45938: LD_ADDR_VAR 0 5
45942: PUSH
45943: LD_VAR 0 1
45947: PPUSH
45948: LD_INT 21
45950: PUSH
45951: LD_INT 3
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PPUSH
45958: CALL_OW 72
45962: ST_TO_ADDR
// if not tmp then
45963: LD_VAR 0 5
45967: NOT
45968: IFFALSE 45972
// exit ;
45970: GO 46017
// for i in tmp do
45972: LD_ADDR_VAR 0 3
45976: PUSH
45977: LD_VAR 0 5
45981: PUSH
45982: FOR_IN
45983: IFFALSE 46015
// begin result := EnemyInRange ( i , 22 ) ;
45985: LD_ADDR_VAR 0 2
45989: PUSH
45990: LD_VAR 0 3
45994: PPUSH
45995: LD_INT 22
45997: PPUSH
45998: CALL 43604 0 2
46002: ST_TO_ADDR
// if result then
46003: LD_VAR 0 2
46007: IFFALSE 46013
// exit ;
46009: POP
46010: POP
46011: GO 46017
// end ;
46013: GO 45982
46015: POP
46016: POP
// end ;
46017: LD_VAR 0 2
46021: RET
// export function FilterByTag ( units , tag ) ; begin
46022: LD_INT 0
46024: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46025: LD_ADDR_VAR 0 3
46029: PUSH
46030: LD_VAR 0 1
46034: PPUSH
46035: LD_INT 120
46037: PUSH
46038: LD_VAR 0 2
46042: PUSH
46043: EMPTY
46044: LIST
46045: LIST
46046: PPUSH
46047: CALL_OW 72
46051: ST_TO_ADDR
// end ;
46052: LD_VAR 0 3
46056: RET
// export function IsDriver ( un ) ; begin
46057: LD_INT 0
46059: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46060: LD_ADDR_VAR 0 2
46064: PUSH
46065: LD_VAR 0 1
46069: PUSH
46070: LD_INT 55
46072: PUSH
46073: EMPTY
46074: LIST
46075: PPUSH
46076: CALL_OW 69
46080: IN
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 2
46086: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46087: LD_INT 0
46089: PPUSH
46090: PPUSH
// list := [ ] ;
46091: LD_ADDR_VAR 0 5
46095: PUSH
46096: EMPTY
46097: ST_TO_ADDR
// case d of 0 :
46098: LD_VAR 0 3
46102: PUSH
46103: LD_INT 0
46105: DOUBLE
46106: EQUAL
46107: IFTRUE 46111
46109: GO 46244
46111: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46112: LD_ADDR_VAR 0 5
46116: PUSH
46117: LD_VAR 0 1
46121: PUSH
46122: LD_INT 4
46124: MINUS
46125: PUSH
46126: LD_VAR 0 2
46130: PUSH
46131: LD_INT 4
46133: MINUS
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: LIST
46142: PUSH
46143: LD_VAR 0 1
46147: PUSH
46148: LD_INT 3
46150: MINUS
46151: PUSH
46152: LD_VAR 0 2
46156: PUSH
46157: LD_INT 1
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: LIST
46164: PUSH
46165: LD_VAR 0 1
46169: PUSH
46170: LD_INT 4
46172: PLUS
46173: PUSH
46174: LD_VAR 0 2
46178: PUSH
46179: LD_INT 4
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: LIST
46186: PUSH
46187: LD_VAR 0 1
46191: PUSH
46192: LD_INT 3
46194: PLUS
46195: PUSH
46196: LD_VAR 0 2
46200: PUSH
46201: LD_INT 3
46203: PLUS
46204: PUSH
46205: LD_INT 5
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: LIST
46212: PUSH
46213: LD_VAR 0 1
46217: PUSH
46218: LD_VAR 0 2
46222: PUSH
46223: LD_INT 4
46225: PLUS
46226: PUSH
46227: LD_INT 0
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: LIST
46234: PUSH
46235: EMPTY
46236: LIST
46237: LIST
46238: LIST
46239: LIST
46240: LIST
46241: ST_TO_ADDR
// end ; 1 :
46242: GO 46942
46244: LD_INT 1
46246: DOUBLE
46247: EQUAL
46248: IFTRUE 46252
46250: GO 46385
46252: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
46253: LD_ADDR_VAR 0 5
46257: PUSH
46258: LD_VAR 0 1
46262: PUSH
46263: LD_VAR 0 2
46267: PUSH
46268: LD_INT 4
46270: MINUS
46271: PUSH
46272: LD_INT 3
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: PUSH
46280: LD_VAR 0 1
46284: PUSH
46285: LD_INT 3
46287: MINUS
46288: PUSH
46289: LD_VAR 0 2
46293: PUSH
46294: LD_INT 3
46296: MINUS
46297: PUSH
46298: LD_INT 2
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: LIST
46305: PUSH
46306: LD_VAR 0 1
46310: PUSH
46311: LD_INT 4
46313: MINUS
46314: PUSH
46315: LD_VAR 0 2
46319: PUSH
46320: LD_INT 1
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: LIST
46327: PUSH
46328: LD_VAR 0 1
46332: PUSH
46333: LD_VAR 0 2
46337: PUSH
46338: LD_INT 3
46340: PLUS
46341: PUSH
46342: LD_INT 0
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: LIST
46349: PUSH
46350: LD_VAR 0 1
46354: PUSH
46355: LD_INT 4
46357: PLUS
46358: PUSH
46359: LD_VAR 0 2
46363: PUSH
46364: LD_INT 4
46366: PLUS
46367: PUSH
46368: LD_INT 5
46370: PUSH
46371: EMPTY
46372: LIST
46373: LIST
46374: LIST
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: ST_TO_ADDR
// end ; 2 :
46383: GO 46942
46385: LD_INT 2
46387: DOUBLE
46388: EQUAL
46389: IFTRUE 46393
46391: GO 46522
46393: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
46394: LD_ADDR_VAR 0 5
46398: PUSH
46399: LD_VAR 0 1
46403: PUSH
46404: LD_VAR 0 2
46408: PUSH
46409: LD_INT 3
46411: MINUS
46412: PUSH
46413: LD_INT 3
46415: PUSH
46416: EMPTY
46417: LIST
46418: LIST
46419: LIST
46420: PUSH
46421: LD_VAR 0 1
46425: PUSH
46426: LD_INT 4
46428: PLUS
46429: PUSH
46430: LD_VAR 0 2
46434: PUSH
46435: LD_INT 4
46437: PUSH
46438: EMPTY
46439: LIST
46440: LIST
46441: LIST
46442: PUSH
46443: LD_VAR 0 1
46447: PUSH
46448: LD_VAR 0 2
46452: PUSH
46453: LD_INT 4
46455: PLUS
46456: PUSH
46457: LD_INT 0
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: LIST
46464: PUSH
46465: LD_VAR 0 1
46469: PUSH
46470: LD_INT 3
46472: MINUS
46473: PUSH
46474: LD_VAR 0 2
46478: PUSH
46479: LD_INT 1
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: LIST
46486: PUSH
46487: LD_VAR 0 1
46491: PUSH
46492: LD_INT 4
46494: MINUS
46495: PUSH
46496: LD_VAR 0 2
46500: PUSH
46501: LD_INT 4
46503: MINUS
46504: PUSH
46505: LD_INT 2
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: LIST
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: LIST
46517: LIST
46518: LIST
46519: ST_TO_ADDR
// end ; 3 :
46520: GO 46942
46522: LD_INT 3
46524: DOUBLE
46525: EQUAL
46526: IFTRUE 46530
46528: GO 46663
46530: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
46531: LD_ADDR_VAR 0 5
46535: PUSH
46536: LD_VAR 0 1
46540: PUSH
46541: LD_INT 3
46543: PLUS
46544: PUSH
46545: LD_VAR 0 2
46549: PUSH
46550: LD_INT 4
46552: PUSH
46553: EMPTY
46554: LIST
46555: LIST
46556: LIST
46557: PUSH
46558: LD_VAR 0 1
46562: PUSH
46563: LD_INT 4
46565: PLUS
46566: PUSH
46567: LD_VAR 0 2
46571: PUSH
46572: LD_INT 4
46574: PLUS
46575: PUSH
46576: LD_INT 5
46578: PUSH
46579: EMPTY
46580: LIST
46581: LIST
46582: LIST
46583: PUSH
46584: LD_VAR 0 1
46588: PUSH
46589: LD_INT 4
46591: MINUS
46592: PUSH
46593: LD_VAR 0 2
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: EMPTY
46602: LIST
46603: LIST
46604: LIST
46605: PUSH
46606: LD_VAR 0 1
46610: PUSH
46611: LD_VAR 0 2
46615: PUSH
46616: LD_INT 4
46618: MINUS
46619: PUSH
46620: LD_INT 3
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: LIST
46627: PUSH
46628: LD_VAR 0 1
46632: PUSH
46633: LD_INT 3
46635: MINUS
46636: PUSH
46637: LD_VAR 0 2
46641: PUSH
46642: LD_INT 3
46644: MINUS
46645: PUSH
46646: LD_INT 2
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: LIST
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: ST_TO_ADDR
// end ; 4 :
46661: GO 46942
46663: LD_INT 4
46665: DOUBLE
46666: EQUAL
46667: IFTRUE 46671
46669: GO 46804
46671: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
46672: LD_ADDR_VAR 0 5
46676: PUSH
46677: LD_VAR 0 1
46681: PUSH
46682: LD_VAR 0 2
46686: PUSH
46687: LD_INT 4
46689: PLUS
46690: PUSH
46691: LD_INT 0
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: LIST
46698: PUSH
46699: LD_VAR 0 1
46703: PUSH
46704: LD_INT 3
46706: PLUS
46707: PUSH
46708: LD_VAR 0 2
46712: PUSH
46713: LD_INT 3
46715: PLUS
46716: PUSH
46717: LD_INT 5
46719: PUSH
46720: EMPTY
46721: LIST
46722: LIST
46723: LIST
46724: PUSH
46725: LD_VAR 0 1
46729: PUSH
46730: LD_INT 4
46732: PLUS
46733: PUSH
46734: LD_VAR 0 2
46738: PUSH
46739: LD_INT 4
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: PUSH
46747: LD_VAR 0 1
46751: PUSH
46752: LD_VAR 0 2
46756: PUSH
46757: LD_INT 3
46759: MINUS
46760: PUSH
46761: LD_INT 3
46763: PUSH
46764: EMPTY
46765: LIST
46766: LIST
46767: LIST
46768: PUSH
46769: LD_VAR 0 1
46773: PUSH
46774: LD_INT 4
46776: MINUS
46777: PUSH
46778: LD_VAR 0 2
46782: PUSH
46783: LD_INT 4
46785: MINUS
46786: PUSH
46787: LD_INT 2
46789: PUSH
46790: EMPTY
46791: LIST
46792: LIST
46793: LIST
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: LIST
46801: ST_TO_ADDR
// end ; 5 :
46802: GO 46942
46804: LD_INT 5
46806: DOUBLE
46807: EQUAL
46808: IFTRUE 46812
46810: GO 46941
46812: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46813: LD_ADDR_VAR 0 5
46817: PUSH
46818: LD_VAR 0 1
46822: PUSH
46823: LD_INT 4
46825: MINUS
46826: PUSH
46827: LD_VAR 0 2
46831: PUSH
46832: LD_INT 1
46834: PUSH
46835: EMPTY
46836: LIST
46837: LIST
46838: LIST
46839: PUSH
46840: LD_VAR 0 1
46844: PUSH
46845: LD_VAR 0 2
46849: PUSH
46850: LD_INT 4
46852: MINUS
46853: PUSH
46854: LD_INT 3
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: LIST
46861: PUSH
46862: LD_VAR 0 1
46866: PUSH
46867: LD_INT 4
46869: PLUS
46870: PUSH
46871: LD_VAR 0 2
46875: PUSH
46876: LD_INT 4
46878: PLUS
46879: PUSH
46880: LD_INT 5
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: LIST
46887: PUSH
46888: LD_VAR 0 1
46892: PUSH
46893: LD_INT 3
46895: PLUS
46896: PUSH
46897: LD_VAR 0 2
46901: PUSH
46902: LD_INT 4
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: LIST
46909: PUSH
46910: LD_VAR 0 1
46914: PUSH
46915: LD_VAR 0 2
46919: PUSH
46920: LD_INT 3
46922: PLUS
46923: PUSH
46924: LD_INT 0
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: LIST
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: ST_TO_ADDR
// end ; end ;
46939: GO 46942
46941: POP
// result := list ;
46942: LD_ADDR_VAR 0 4
46946: PUSH
46947: LD_VAR 0 5
46951: ST_TO_ADDR
// end ;
46952: LD_VAR 0 4
46956: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46957: LD_INT 0
46959: PPUSH
46960: PPUSH
46961: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46962: LD_VAR 0 1
46966: NOT
46967: PUSH
46968: LD_VAR 0 2
46972: PUSH
46973: LD_INT 1
46975: PUSH
46976: LD_INT 2
46978: PUSH
46979: LD_INT 3
46981: PUSH
46982: LD_INT 4
46984: PUSH
46985: EMPTY
46986: LIST
46987: LIST
46988: LIST
46989: LIST
46990: IN
46991: NOT
46992: OR
46993: IFFALSE 46997
// exit ;
46995: GO 47080
// tmp := [ ] ;
46997: LD_ADDR_VAR 0 5
47001: PUSH
47002: EMPTY
47003: ST_TO_ADDR
// for i in units do
47004: LD_ADDR_VAR 0 4
47008: PUSH
47009: LD_VAR 0 1
47013: PUSH
47014: FOR_IN
47015: IFFALSE 47049
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47017: LD_ADDR_VAR 0 5
47021: PUSH
47022: LD_VAR 0 5
47026: PPUSH
47027: LD_VAR 0 4
47031: PPUSH
47032: LD_VAR 0 2
47036: PPUSH
47037: CALL_OW 259
47041: PPUSH
47042: CALL 48441 0 2
47046: ST_TO_ADDR
47047: GO 47014
47049: POP
47050: POP
// if not tmp then
47051: LD_VAR 0 5
47055: NOT
47056: IFFALSE 47060
// exit ;
47058: GO 47080
// result := SortListByListDesc ( units , tmp ) ;
47060: LD_ADDR_VAR 0 3
47064: PUSH
47065: LD_VAR 0 1
47069: PPUSH
47070: LD_VAR 0 5
47074: PPUSH
47075: CALL_OW 77
47079: ST_TO_ADDR
// end ;
47080: LD_VAR 0 3
47084: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47085: LD_INT 0
47087: PPUSH
47088: PPUSH
47089: PPUSH
// result := false ;
47090: LD_ADDR_VAR 0 3
47094: PUSH
47095: LD_INT 0
47097: ST_TO_ADDR
// if not building then
47098: LD_VAR 0 2
47102: NOT
47103: IFFALSE 47107
// exit ;
47105: GO 47245
// x := GetX ( building ) ;
47107: LD_ADDR_VAR 0 4
47111: PUSH
47112: LD_VAR 0 2
47116: PPUSH
47117: CALL_OW 250
47121: ST_TO_ADDR
// y := GetY ( building ) ;
47122: LD_ADDR_VAR 0 5
47126: PUSH
47127: LD_VAR 0 2
47131: PPUSH
47132: CALL_OW 251
47136: ST_TO_ADDR
// if not x or not y then
47137: LD_VAR 0 4
47141: NOT
47142: PUSH
47143: LD_VAR 0 5
47147: NOT
47148: OR
47149: IFFALSE 47153
// exit ;
47151: GO 47245
// if GetTaskList ( unit ) then
47153: LD_VAR 0 1
47157: PPUSH
47158: CALL_OW 437
47162: IFFALSE 47245
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47164: LD_STRING e
47166: PUSH
47167: LD_VAR 0 1
47171: PPUSH
47172: CALL_OW 437
47176: PUSH
47177: LD_INT 1
47179: ARRAY
47180: PUSH
47181: LD_INT 1
47183: ARRAY
47184: EQUAL
47185: PUSH
47186: LD_VAR 0 4
47190: PUSH
47191: LD_VAR 0 1
47195: PPUSH
47196: CALL_OW 437
47200: PUSH
47201: LD_INT 1
47203: ARRAY
47204: PUSH
47205: LD_INT 2
47207: ARRAY
47208: EQUAL
47209: AND
47210: PUSH
47211: LD_VAR 0 5
47215: PUSH
47216: LD_VAR 0 1
47220: PPUSH
47221: CALL_OW 437
47225: PUSH
47226: LD_INT 1
47228: ARRAY
47229: PUSH
47230: LD_INT 3
47232: ARRAY
47233: EQUAL
47234: AND
47235: IFFALSE 47245
// result := true end ;
47237: LD_ADDR_VAR 0 3
47241: PUSH
47242: LD_INT 1
47244: ST_TO_ADDR
// end ;
47245: LD_VAR 0 3
47249: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
47250: LD_INT 0
47252: PPUSH
// result := false ;
47253: LD_ADDR_VAR 0 4
47257: PUSH
47258: LD_INT 0
47260: ST_TO_ADDR
// if GetTaskList ( unit ) then
47261: LD_VAR 0 1
47265: PPUSH
47266: CALL_OW 437
47270: IFFALSE 47353
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47272: LD_STRING M
47274: PUSH
47275: LD_VAR 0 1
47279: PPUSH
47280: CALL_OW 437
47284: PUSH
47285: LD_INT 1
47287: ARRAY
47288: PUSH
47289: LD_INT 1
47291: ARRAY
47292: EQUAL
47293: PUSH
47294: LD_VAR 0 2
47298: PUSH
47299: LD_VAR 0 1
47303: PPUSH
47304: CALL_OW 437
47308: PUSH
47309: LD_INT 1
47311: ARRAY
47312: PUSH
47313: LD_INT 2
47315: ARRAY
47316: EQUAL
47317: AND
47318: PUSH
47319: LD_VAR 0 3
47323: PUSH
47324: LD_VAR 0 1
47328: PPUSH
47329: CALL_OW 437
47333: PUSH
47334: LD_INT 1
47336: ARRAY
47337: PUSH
47338: LD_INT 3
47340: ARRAY
47341: EQUAL
47342: AND
47343: IFFALSE 47353
// result := true ;
47345: LD_ADDR_VAR 0 4
47349: PUSH
47350: LD_INT 1
47352: ST_TO_ADDR
// end ; end ;
47353: LD_VAR 0 4
47357: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
47358: LD_INT 0
47360: PPUSH
47361: PPUSH
47362: PPUSH
47363: PPUSH
// if not unit or not area then
47364: LD_VAR 0 1
47368: NOT
47369: PUSH
47370: LD_VAR 0 2
47374: NOT
47375: OR
47376: IFFALSE 47380
// exit ;
47378: GO 47544
// tmp := AreaToList ( area , i ) ;
47380: LD_ADDR_VAR 0 6
47384: PUSH
47385: LD_VAR 0 2
47389: PPUSH
47390: LD_VAR 0 5
47394: PPUSH
47395: CALL_OW 517
47399: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
47400: LD_ADDR_VAR 0 5
47404: PUSH
47405: DOUBLE
47406: LD_INT 1
47408: DEC
47409: ST_TO_ADDR
47410: LD_VAR 0 6
47414: PUSH
47415: LD_INT 1
47417: ARRAY
47418: PUSH
47419: FOR_TO
47420: IFFALSE 47542
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
47422: LD_ADDR_VAR 0 7
47426: PUSH
47427: LD_VAR 0 6
47431: PUSH
47432: LD_INT 1
47434: ARRAY
47435: PUSH
47436: LD_VAR 0 5
47440: ARRAY
47441: PUSH
47442: LD_VAR 0 6
47446: PUSH
47447: LD_INT 2
47449: ARRAY
47450: PUSH
47451: LD_VAR 0 5
47455: ARRAY
47456: PUSH
47457: EMPTY
47458: LIST
47459: LIST
47460: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
47461: LD_VAR 0 7
47465: PUSH
47466: LD_INT 1
47468: ARRAY
47469: PPUSH
47470: LD_VAR 0 7
47474: PUSH
47475: LD_INT 2
47477: ARRAY
47478: PPUSH
47479: CALL_OW 428
47483: PUSH
47484: LD_INT 0
47486: EQUAL
47487: IFFALSE 47540
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
47489: LD_VAR 0 1
47493: PPUSH
47494: LD_VAR 0 7
47498: PUSH
47499: LD_INT 1
47501: ARRAY
47502: PPUSH
47503: LD_VAR 0 7
47507: PUSH
47508: LD_INT 2
47510: ARRAY
47511: PPUSH
47512: LD_VAR 0 3
47516: PPUSH
47517: CALL_OW 48
// result := IsPlaced ( unit ) ;
47521: LD_ADDR_VAR 0 4
47525: PUSH
47526: LD_VAR 0 1
47530: PPUSH
47531: CALL_OW 305
47535: ST_TO_ADDR
// exit ;
47536: POP
47537: POP
47538: GO 47544
// end ; end ;
47540: GO 47419
47542: POP
47543: POP
// end ;
47544: LD_VAR 0 4
47548: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
47549: LD_INT 0
47551: PPUSH
47552: PPUSH
47553: PPUSH
// if not side or side > 8 then
47554: LD_VAR 0 1
47558: NOT
47559: PUSH
47560: LD_VAR 0 1
47564: PUSH
47565: LD_INT 8
47567: GREATER
47568: OR
47569: IFFALSE 47573
// exit ;
47571: GO 47760
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
47573: LD_ADDR_VAR 0 4
47577: PUSH
47578: LD_INT 22
47580: PUSH
47581: LD_VAR 0 1
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: LD_INT 21
47592: PUSH
47593: LD_INT 3
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: PPUSH
47604: CALL_OW 69
47608: ST_TO_ADDR
// if not tmp then
47609: LD_VAR 0 4
47613: NOT
47614: IFFALSE 47618
// exit ;
47616: GO 47760
// enable_addtolog := true ;
47618: LD_ADDR_OWVAR 81
47622: PUSH
47623: LD_INT 1
47625: ST_TO_ADDR
// AddToLog ( [ ) ;
47626: LD_STRING [
47628: PPUSH
47629: CALL_OW 561
// for i in tmp do
47633: LD_ADDR_VAR 0 3
47637: PUSH
47638: LD_VAR 0 4
47642: PUSH
47643: FOR_IN
47644: IFFALSE 47751
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
47646: LD_STRING [
47648: PUSH
47649: LD_VAR 0 3
47653: PPUSH
47654: CALL_OW 266
47658: STR
47659: PUSH
47660: LD_STRING , 
47662: STR
47663: PUSH
47664: LD_VAR 0 3
47668: PPUSH
47669: CALL_OW 250
47673: STR
47674: PUSH
47675: LD_STRING , 
47677: STR
47678: PUSH
47679: LD_VAR 0 3
47683: PPUSH
47684: CALL_OW 251
47688: STR
47689: PUSH
47690: LD_STRING , 
47692: STR
47693: PUSH
47694: LD_VAR 0 3
47698: PPUSH
47699: CALL_OW 254
47703: STR
47704: PUSH
47705: LD_STRING , 
47707: STR
47708: PUSH
47709: LD_VAR 0 3
47713: PPUSH
47714: LD_INT 1
47716: PPUSH
47717: CALL_OW 268
47721: STR
47722: PUSH
47723: LD_STRING , 
47725: STR
47726: PUSH
47727: LD_VAR 0 3
47731: PPUSH
47732: LD_INT 2
47734: PPUSH
47735: CALL_OW 268
47739: STR
47740: PUSH
47741: LD_STRING ],
47743: STR
47744: PPUSH
47745: CALL_OW 561
// end ;
47749: GO 47643
47751: POP
47752: POP
// AddToLog ( ]; ) ;
47753: LD_STRING ];
47755: PPUSH
47756: CALL_OW 561
// end ;
47760: LD_VAR 0 2
47764: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47765: LD_INT 0
47767: PPUSH
47768: PPUSH
47769: PPUSH
47770: PPUSH
47771: PPUSH
// if not area or not rate or not max then
47772: LD_VAR 0 1
47776: NOT
47777: PUSH
47778: LD_VAR 0 2
47782: NOT
47783: OR
47784: PUSH
47785: LD_VAR 0 4
47789: NOT
47790: OR
47791: IFFALSE 47795
// exit ;
47793: GO 47984
// while 1 do
47795: LD_INT 1
47797: IFFALSE 47984
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47799: LD_ADDR_VAR 0 9
47803: PUSH
47804: LD_VAR 0 1
47808: PPUSH
47809: LD_INT 1
47811: PPUSH
47812: CALL_OW 287
47816: PUSH
47817: LD_INT 10
47819: MUL
47820: ST_TO_ADDR
// r := rate / 10 ;
47821: LD_ADDR_VAR 0 7
47825: PUSH
47826: LD_VAR 0 2
47830: PUSH
47831: LD_INT 10
47833: DIVREAL
47834: ST_TO_ADDR
// time := 1 1$00 ;
47835: LD_ADDR_VAR 0 8
47839: PUSH
47840: LD_INT 2100
47842: ST_TO_ADDR
// if amount < min then
47843: LD_VAR 0 9
47847: PUSH
47848: LD_VAR 0 3
47852: LESS
47853: IFFALSE 47871
// r := r * 2 else
47855: LD_ADDR_VAR 0 7
47859: PUSH
47860: LD_VAR 0 7
47864: PUSH
47865: LD_INT 2
47867: MUL
47868: ST_TO_ADDR
47869: GO 47897
// if amount > max then
47871: LD_VAR 0 9
47875: PUSH
47876: LD_VAR 0 4
47880: GREATER
47881: IFFALSE 47897
// r := r / 2 ;
47883: LD_ADDR_VAR 0 7
47887: PUSH
47888: LD_VAR 0 7
47892: PUSH
47893: LD_INT 2
47895: DIVREAL
47896: ST_TO_ADDR
// time := time / r ;
47897: LD_ADDR_VAR 0 8
47901: PUSH
47902: LD_VAR 0 8
47906: PUSH
47907: LD_VAR 0 7
47911: DIVREAL
47912: ST_TO_ADDR
// if time < 0 then
47913: LD_VAR 0 8
47917: PUSH
47918: LD_INT 0
47920: LESS
47921: IFFALSE 47938
// time := time * - 1 ;
47923: LD_ADDR_VAR 0 8
47927: PUSH
47928: LD_VAR 0 8
47932: PUSH
47933: LD_INT 1
47935: NEG
47936: MUL
47937: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
47938: LD_VAR 0 8
47942: PUSH
47943: LD_INT 35
47945: PPUSH
47946: LD_INT 875
47948: PPUSH
47949: CALL_OW 12
47953: PLUS
47954: PPUSH
47955: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47959: LD_INT 1
47961: PPUSH
47962: LD_INT 5
47964: PPUSH
47965: CALL_OW 12
47969: PPUSH
47970: LD_VAR 0 1
47974: PPUSH
47975: LD_INT 1
47977: PPUSH
47978: CALL_OW 55
// end ;
47982: GO 47795
// end ;
47984: LD_VAR 0 5
47988: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47989: LD_INT 0
47991: PPUSH
47992: PPUSH
47993: PPUSH
47994: PPUSH
47995: PPUSH
47996: PPUSH
47997: PPUSH
47998: PPUSH
// if not turrets or not factories then
47999: LD_VAR 0 1
48003: NOT
48004: PUSH
48005: LD_VAR 0 2
48009: NOT
48010: OR
48011: IFFALSE 48015
// exit ;
48013: GO 48322
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48015: LD_ADDR_VAR 0 10
48019: PUSH
48020: LD_INT 5
48022: PUSH
48023: LD_INT 6
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: LD_INT 2
48032: PUSH
48033: LD_INT 4
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 3
48042: PUSH
48043: LD_INT 5
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: EMPTY
48051: LIST
48052: LIST
48053: LIST
48054: PUSH
48055: LD_INT 24
48057: PUSH
48058: LD_INT 25
48060: PUSH
48061: EMPTY
48062: LIST
48063: LIST
48064: PUSH
48065: LD_INT 23
48067: PUSH
48068: LD_INT 27
48070: PUSH
48071: EMPTY
48072: LIST
48073: LIST
48074: PUSH
48075: EMPTY
48076: LIST
48077: LIST
48078: PUSH
48079: LD_INT 42
48081: PUSH
48082: LD_INT 43
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: LD_INT 44
48091: PUSH
48092: LD_INT 46
48094: PUSH
48095: EMPTY
48096: LIST
48097: LIST
48098: PUSH
48099: LD_INT 45
48101: PUSH
48102: LD_INT 47
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: LIST
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: LIST
48118: ST_TO_ADDR
// result := [ ] ;
48119: LD_ADDR_VAR 0 3
48123: PUSH
48124: EMPTY
48125: ST_TO_ADDR
// for i in turrets do
48126: LD_ADDR_VAR 0 4
48130: PUSH
48131: LD_VAR 0 1
48135: PUSH
48136: FOR_IN
48137: IFFALSE 48320
// begin nat := GetNation ( i ) ;
48139: LD_ADDR_VAR 0 7
48143: PUSH
48144: LD_VAR 0 4
48148: PPUSH
48149: CALL_OW 248
48153: ST_TO_ADDR
// weapon := 0 ;
48154: LD_ADDR_VAR 0 8
48158: PUSH
48159: LD_INT 0
48161: ST_TO_ADDR
// if not nat then
48162: LD_VAR 0 7
48166: NOT
48167: IFFALSE 48171
// continue ;
48169: GO 48136
// for j in list [ nat ] do
48171: LD_ADDR_VAR 0 5
48175: PUSH
48176: LD_VAR 0 10
48180: PUSH
48181: LD_VAR 0 7
48185: ARRAY
48186: PUSH
48187: FOR_IN
48188: IFFALSE 48229
// if GetBWeapon ( i ) = j [ 1 ] then
48190: LD_VAR 0 4
48194: PPUSH
48195: CALL_OW 269
48199: PUSH
48200: LD_VAR 0 5
48204: PUSH
48205: LD_INT 1
48207: ARRAY
48208: EQUAL
48209: IFFALSE 48227
// begin weapon := j [ 2 ] ;
48211: LD_ADDR_VAR 0 8
48215: PUSH
48216: LD_VAR 0 5
48220: PUSH
48221: LD_INT 2
48223: ARRAY
48224: ST_TO_ADDR
// break ;
48225: GO 48229
// end ;
48227: GO 48187
48229: POP
48230: POP
// if not weapon then
48231: LD_VAR 0 8
48235: NOT
48236: IFFALSE 48240
// continue ;
48238: GO 48136
// for k in factories do
48240: LD_ADDR_VAR 0 6
48244: PUSH
48245: LD_VAR 0 2
48249: PUSH
48250: FOR_IN
48251: IFFALSE 48316
// begin weapons := AvailableWeaponList ( k ) ;
48253: LD_ADDR_VAR 0 9
48257: PUSH
48258: LD_VAR 0 6
48262: PPUSH
48263: CALL_OW 478
48267: ST_TO_ADDR
// if not weapons then
48268: LD_VAR 0 9
48272: NOT
48273: IFFALSE 48277
// continue ;
48275: GO 48250
// if weapon in weapons then
48277: LD_VAR 0 8
48281: PUSH
48282: LD_VAR 0 9
48286: IN
48287: IFFALSE 48314
// begin result := [ i , weapon ] ;
48289: LD_ADDR_VAR 0 3
48293: PUSH
48294: LD_VAR 0 4
48298: PUSH
48299: LD_VAR 0 8
48303: PUSH
48304: EMPTY
48305: LIST
48306: LIST
48307: ST_TO_ADDR
// exit ;
48308: POP
48309: POP
48310: POP
48311: POP
48312: GO 48322
// end ; end ;
48314: GO 48250
48316: POP
48317: POP
// end ;
48318: GO 48136
48320: POP
48321: POP
// end ;
48322: LD_VAR 0 3
48326: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
48327: LD_INT 0
48329: PPUSH
// if not side or side > 8 then
48330: LD_VAR 0 3
48334: NOT
48335: PUSH
48336: LD_VAR 0 3
48340: PUSH
48341: LD_INT 8
48343: GREATER
48344: OR
48345: IFFALSE 48349
// exit ;
48347: GO 48408
// if not range then
48349: LD_VAR 0 4
48353: NOT
48354: IFFALSE 48365
// range := - 12 ;
48356: LD_ADDR_VAR 0 4
48360: PUSH
48361: LD_INT 12
48363: NEG
48364: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
48365: LD_VAR 0 1
48369: PPUSH
48370: LD_VAR 0 2
48374: PPUSH
48375: LD_VAR 0 3
48379: PPUSH
48380: LD_VAR 0 4
48384: PPUSH
48385: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
48389: LD_VAR 0 1
48393: PPUSH
48394: LD_VAR 0 2
48398: PPUSH
48399: LD_VAR 0 3
48403: PPUSH
48404: CALL_OW 331
// end ;
48408: LD_VAR 0 5
48412: RET
// export function Video ( mode ) ; begin
48413: LD_INT 0
48415: PPUSH
// ingame_video = mode ;
48416: LD_ADDR_OWVAR 52
48420: PUSH
48421: LD_VAR 0 1
48425: ST_TO_ADDR
// interface_hidden = mode ;
48426: LD_ADDR_OWVAR 54
48430: PUSH
48431: LD_VAR 0 1
48435: ST_TO_ADDR
// end ;
48436: LD_VAR 0 2
48440: RET
// export function Join ( array , element ) ; begin
48441: LD_INT 0
48443: PPUSH
// result := Replace ( array , array + 1 , element ) ;
48444: LD_ADDR_VAR 0 3
48448: PUSH
48449: LD_VAR 0 1
48453: PPUSH
48454: LD_VAR 0 1
48458: PUSH
48459: LD_INT 1
48461: PLUS
48462: PPUSH
48463: LD_VAR 0 2
48467: PPUSH
48468: CALL_OW 1
48472: ST_TO_ADDR
// end ;
48473: LD_VAR 0 3
48477: RET
// export function JoinUnion ( array , element ) ; begin
48478: LD_INT 0
48480: PPUSH
// result := array union element ;
48481: LD_ADDR_VAR 0 3
48485: PUSH
48486: LD_VAR 0 1
48490: PUSH
48491: LD_VAR 0 2
48495: UNION
48496: ST_TO_ADDR
// end ;
48497: LD_VAR 0 3
48501: RET
// export function GetBehemoths ( side ) ; begin
48502: LD_INT 0
48504: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
48505: LD_ADDR_VAR 0 2
48509: PUSH
48510: LD_INT 22
48512: PUSH
48513: LD_VAR 0 1
48517: PUSH
48518: EMPTY
48519: LIST
48520: LIST
48521: PUSH
48522: LD_INT 31
48524: PUSH
48525: LD_INT 25
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: PPUSH
48536: CALL_OW 69
48540: ST_TO_ADDR
// end ;
48541: LD_VAR 0 2
48545: RET
// export function Shuffle ( array ) ; var i , index ; begin
48546: LD_INT 0
48548: PPUSH
48549: PPUSH
48550: PPUSH
// result := [ ] ;
48551: LD_ADDR_VAR 0 2
48555: PUSH
48556: EMPTY
48557: ST_TO_ADDR
// if not array then
48558: LD_VAR 0 1
48562: NOT
48563: IFFALSE 48567
// exit ;
48565: GO 48666
// Randomize ;
48567: CALL_OW 10
// for i = array downto 1 do
48571: LD_ADDR_VAR 0 3
48575: PUSH
48576: DOUBLE
48577: LD_VAR 0 1
48581: INC
48582: ST_TO_ADDR
48583: LD_INT 1
48585: PUSH
48586: FOR_DOWNTO
48587: IFFALSE 48664
// begin index := rand ( 1 , array ) ;
48589: LD_ADDR_VAR 0 4
48593: PUSH
48594: LD_INT 1
48596: PPUSH
48597: LD_VAR 0 1
48601: PPUSH
48602: CALL_OW 12
48606: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
48607: LD_ADDR_VAR 0 2
48611: PUSH
48612: LD_VAR 0 2
48616: PPUSH
48617: LD_VAR 0 2
48621: PUSH
48622: LD_INT 1
48624: PLUS
48625: PPUSH
48626: LD_VAR 0 1
48630: PUSH
48631: LD_VAR 0 4
48635: ARRAY
48636: PPUSH
48637: CALL_OW 2
48641: ST_TO_ADDR
// array := Delete ( array , index ) ;
48642: LD_ADDR_VAR 0 1
48646: PUSH
48647: LD_VAR 0 1
48651: PPUSH
48652: LD_VAR 0 4
48656: PPUSH
48657: CALL_OW 3
48661: ST_TO_ADDR
// end ;
48662: GO 48586
48664: POP
48665: POP
// end ;
48666: LD_VAR 0 2
48670: RET
// export function GetBaseMaterials ( base ) ; begin
48671: LD_INT 0
48673: PPUSH
// result := [ 0 , 0 , 0 ] ;
48674: LD_ADDR_VAR 0 2
48678: PUSH
48679: LD_INT 0
48681: PUSH
48682: LD_INT 0
48684: PUSH
48685: LD_INT 0
48687: PUSH
48688: EMPTY
48689: LIST
48690: LIST
48691: LIST
48692: ST_TO_ADDR
// if not base then
48693: LD_VAR 0 1
48697: NOT
48698: IFFALSE 48702
// exit ;
48700: GO 48751
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48702: LD_ADDR_VAR 0 2
48706: PUSH
48707: LD_VAR 0 1
48711: PPUSH
48712: LD_INT 1
48714: PPUSH
48715: CALL_OW 275
48719: PUSH
48720: LD_VAR 0 1
48724: PPUSH
48725: LD_INT 2
48727: PPUSH
48728: CALL_OW 275
48732: PUSH
48733: LD_VAR 0 1
48737: PPUSH
48738: LD_INT 3
48740: PPUSH
48741: CALL_OW 275
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: LIST
48750: ST_TO_ADDR
// end ;
48751: LD_VAR 0 2
48755: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48756: LD_INT 0
48758: PPUSH
48759: PPUSH
// result := array ;
48760: LD_ADDR_VAR 0 3
48764: PUSH
48765: LD_VAR 0 1
48769: ST_TO_ADDR
// if size >= result then
48770: LD_VAR 0 2
48774: PUSH
48775: LD_VAR 0 3
48779: GREATEREQUAL
48780: IFFALSE 48784
// exit ;
48782: GO 48834
// if size then
48784: LD_VAR 0 2
48788: IFFALSE 48834
// for i := array downto size do
48790: LD_ADDR_VAR 0 4
48794: PUSH
48795: DOUBLE
48796: LD_VAR 0 1
48800: INC
48801: ST_TO_ADDR
48802: LD_VAR 0 2
48806: PUSH
48807: FOR_DOWNTO
48808: IFFALSE 48832
// result := Delete ( result , result ) ;
48810: LD_ADDR_VAR 0 3
48814: PUSH
48815: LD_VAR 0 3
48819: PPUSH
48820: LD_VAR 0 3
48824: PPUSH
48825: CALL_OW 3
48829: ST_TO_ADDR
48830: GO 48807
48832: POP
48833: POP
// end ;
48834: LD_VAR 0 3
48838: RET
// export function ComExit ( unit ) ; var tmp ; begin
48839: LD_INT 0
48841: PPUSH
48842: PPUSH
// if not IsInUnit ( unit ) then
48843: LD_VAR 0 1
48847: PPUSH
48848: CALL_OW 310
48852: NOT
48853: IFFALSE 48857
// exit ;
48855: GO 48917
// tmp := IsInUnit ( unit ) ;
48857: LD_ADDR_VAR 0 3
48861: PUSH
48862: LD_VAR 0 1
48866: PPUSH
48867: CALL_OW 310
48871: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48872: LD_VAR 0 3
48876: PPUSH
48877: CALL_OW 247
48881: PUSH
48882: LD_INT 2
48884: EQUAL
48885: IFFALSE 48898
// ComExitVehicle ( unit ) else
48887: LD_VAR 0 1
48891: PPUSH
48892: CALL_OW 121
48896: GO 48907
// ComExitBuilding ( unit ) ;
48898: LD_VAR 0 1
48902: PPUSH
48903: CALL_OW 122
// result := tmp ;
48907: LD_ADDR_VAR 0 2
48911: PUSH
48912: LD_VAR 0 3
48916: ST_TO_ADDR
// end ;
48917: LD_VAR 0 2
48921: RET
// export function ComExitAll ( units ) ; var i ; begin
48922: LD_INT 0
48924: PPUSH
48925: PPUSH
// if not units then
48926: LD_VAR 0 1
48930: NOT
48931: IFFALSE 48935
// exit ;
48933: GO 48961
// for i in units do
48935: LD_ADDR_VAR 0 3
48939: PUSH
48940: LD_VAR 0 1
48944: PUSH
48945: FOR_IN
48946: IFFALSE 48959
// ComExit ( i ) ;
48948: LD_VAR 0 3
48952: PPUSH
48953: CALL 48839 0 1
48957: GO 48945
48959: POP
48960: POP
// end ;
48961: LD_VAR 0 2
48965: RET
// export function ResetHc ; begin
48966: LD_INT 0
48968: PPUSH
// InitHc ;
48969: CALL_OW 19
// hc_importance := 0 ;
48973: LD_ADDR_OWVAR 32
48977: PUSH
48978: LD_INT 0
48980: ST_TO_ADDR
// end ;
48981: LD_VAR 0 1
48985: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48986: LD_INT 0
48988: PPUSH
48989: PPUSH
48990: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48991: LD_ADDR_VAR 0 6
48995: PUSH
48996: LD_VAR 0 1
49000: PUSH
49001: LD_VAR 0 3
49005: PLUS
49006: PUSH
49007: LD_INT 2
49009: DIV
49010: ST_TO_ADDR
// if _x < 0 then
49011: LD_VAR 0 6
49015: PUSH
49016: LD_INT 0
49018: LESS
49019: IFFALSE 49036
// _x := _x * - 1 ;
49021: LD_ADDR_VAR 0 6
49025: PUSH
49026: LD_VAR 0 6
49030: PUSH
49031: LD_INT 1
49033: NEG
49034: MUL
49035: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49036: LD_ADDR_VAR 0 7
49040: PUSH
49041: LD_VAR 0 2
49045: PUSH
49046: LD_VAR 0 4
49050: PLUS
49051: PUSH
49052: LD_INT 2
49054: DIV
49055: ST_TO_ADDR
// if _y < 0 then
49056: LD_VAR 0 7
49060: PUSH
49061: LD_INT 0
49063: LESS
49064: IFFALSE 49081
// _y := _y * - 1 ;
49066: LD_ADDR_VAR 0 7
49070: PUSH
49071: LD_VAR 0 7
49075: PUSH
49076: LD_INT 1
49078: NEG
49079: MUL
49080: ST_TO_ADDR
// result := [ _x , _y ] ;
49081: LD_ADDR_VAR 0 5
49085: PUSH
49086: LD_VAR 0 6
49090: PUSH
49091: LD_VAR 0 7
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: ST_TO_ADDR
// end ;
49100: LD_VAR 0 5
49104: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
49109: PPUSH
49110: PPUSH
// task := GetTaskList ( unit ) ;
49111: LD_ADDR_VAR 0 7
49115: PUSH
49116: LD_VAR 0 1
49120: PPUSH
49121: CALL_OW 437
49125: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49126: LD_VAR 0 7
49130: NOT
49131: PUSH
49132: LD_VAR 0 1
49136: PPUSH
49137: LD_VAR 0 2
49141: PPUSH
49142: CALL_OW 308
49146: NOT
49147: AND
49148: IFFALSE 49152
// exit ;
49150: GO 49270
// if IsInArea ( unit , area ) then
49152: LD_VAR 0 1
49156: PPUSH
49157: LD_VAR 0 2
49161: PPUSH
49162: CALL_OW 308
49166: IFFALSE 49184
// begin ComMoveToArea ( unit , goAway ) ;
49168: LD_VAR 0 1
49172: PPUSH
49173: LD_VAR 0 3
49177: PPUSH
49178: CALL_OW 113
// exit ;
49182: GO 49270
// end ; if task [ 1 ] [ 1 ] <> M then
49184: LD_VAR 0 7
49188: PUSH
49189: LD_INT 1
49191: ARRAY
49192: PUSH
49193: LD_INT 1
49195: ARRAY
49196: PUSH
49197: LD_STRING M
49199: NONEQUAL
49200: IFFALSE 49204
// exit ;
49202: GO 49270
// x := task [ 1 ] [ 2 ] ;
49204: LD_ADDR_VAR 0 5
49208: PUSH
49209: LD_VAR 0 7
49213: PUSH
49214: LD_INT 1
49216: ARRAY
49217: PUSH
49218: LD_INT 2
49220: ARRAY
49221: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
49222: LD_ADDR_VAR 0 6
49226: PUSH
49227: LD_VAR 0 7
49231: PUSH
49232: LD_INT 1
49234: ARRAY
49235: PUSH
49236: LD_INT 3
49238: ARRAY
49239: ST_TO_ADDR
// if InArea ( x , y , area ) then
49240: LD_VAR 0 5
49244: PPUSH
49245: LD_VAR 0 6
49249: PPUSH
49250: LD_VAR 0 2
49254: PPUSH
49255: CALL_OW 309
49259: IFFALSE 49270
// ComStop ( unit ) ;
49261: LD_VAR 0 1
49265: PPUSH
49266: CALL_OW 141
// end ;
49270: LD_VAR 0 4
49274: RET
// export function Abs ( value ) ; begin
49275: LD_INT 0
49277: PPUSH
// result := value ;
49278: LD_ADDR_VAR 0 2
49282: PUSH
49283: LD_VAR 0 1
49287: ST_TO_ADDR
// if value < 0 then
49288: LD_VAR 0 1
49292: PUSH
49293: LD_INT 0
49295: LESS
49296: IFFALSE 49313
// result := value * - 1 ;
49298: LD_ADDR_VAR 0 2
49302: PUSH
49303: LD_VAR 0 1
49307: PUSH
49308: LD_INT 1
49310: NEG
49311: MUL
49312: ST_TO_ADDR
// end ;
49313: LD_VAR 0 2
49317: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
49318: LD_INT 0
49320: PPUSH
49321: PPUSH
49322: PPUSH
49323: PPUSH
49324: PPUSH
49325: PPUSH
49326: PPUSH
49327: PPUSH
// if not unit or not building then
49328: LD_VAR 0 1
49332: NOT
49333: PUSH
49334: LD_VAR 0 2
49338: NOT
49339: OR
49340: IFFALSE 49344
// exit ;
49342: GO 49570
// x := GetX ( building ) ;
49344: LD_ADDR_VAR 0 4
49348: PUSH
49349: LD_VAR 0 2
49353: PPUSH
49354: CALL_OW 250
49358: ST_TO_ADDR
// y := GetY ( building ) ;
49359: LD_ADDR_VAR 0 6
49363: PUSH
49364: LD_VAR 0 2
49368: PPUSH
49369: CALL_OW 251
49373: ST_TO_ADDR
// d := GetDir ( building ) ;
49374: LD_ADDR_VAR 0 8
49378: PUSH
49379: LD_VAR 0 2
49383: PPUSH
49384: CALL_OW 254
49388: ST_TO_ADDR
// r := 4 ;
49389: LD_ADDR_VAR 0 9
49393: PUSH
49394: LD_INT 4
49396: ST_TO_ADDR
// for i := 1 to 5 do
49397: LD_ADDR_VAR 0 10
49401: PUSH
49402: DOUBLE
49403: LD_INT 1
49405: DEC
49406: ST_TO_ADDR
49407: LD_INT 5
49409: PUSH
49410: FOR_TO
49411: IFFALSE 49568
// begin _x := ShiftX ( x , d , r + i ) ;
49413: LD_ADDR_VAR 0 5
49417: PUSH
49418: LD_VAR 0 4
49422: PPUSH
49423: LD_VAR 0 8
49427: PPUSH
49428: LD_VAR 0 9
49432: PUSH
49433: LD_VAR 0 10
49437: PLUS
49438: PPUSH
49439: CALL_OW 272
49443: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
49444: LD_ADDR_VAR 0 7
49448: PUSH
49449: LD_VAR 0 6
49453: PPUSH
49454: LD_VAR 0 8
49458: PPUSH
49459: LD_VAR 0 9
49463: PUSH
49464: LD_VAR 0 10
49468: PLUS
49469: PPUSH
49470: CALL_OW 273
49474: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
49475: LD_VAR 0 5
49479: PPUSH
49480: LD_VAR 0 7
49484: PPUSH
49485: CALL_OW 488
49489: PUSH
49490: LD_VAR 0 5
49494: PPUSH
49495: LD_VAR 0 7
49499: PPUSH
49500: CALL_OW 428
49504: PPUSH
49505: CALL_OW 247
49509: PUSH
49510: LD_INT 3
49512: PUSH
49513: LD_INT 2
49515: PUSH
49516: EMPTY
49517: LIST
49518: LIST
49519: IN
49520: NOT
49521: AND
49522: IFFALSE 49566
// begin ComMoveXY ( unit , _x , _y ) ;
49524: LD_VAR 0 1
49528: PPUSH
49529: LD_VAR 0 5
49533: PPUSH
49534: LD_VAR 0 7
49538: PPUSH
49539: CALL_OW 111
// result := [ _x , _y ] ;
49543: LD_ADDR_VAR 0 3
49547: PUSH
49548: LD_VAR 0 5
49552: PUSH
49553: LD_VAR 0 7
49557: PUSH
49558: EMPTY
49559: LIST
49560: LIST
49561: ST_TO_ADDR
// exit ;
49562: POP
49563: POP
49564: GO 49570
// end ; end ;
49566: GO 49410
49568: POP
49569: POP
// end ;
49570: LD_VAR 0 3
49574: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
49575: LD_INT 0
49577: PPUSH
49578: PPUSH
49579: PPUSH
// result := 0 ;
49580: LD_ADDR_VAR 0 3
49584: PUSH
49585: LD_INT 0
49587: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
49588: LD_VAR 0 1
49592: PUSH
49593: LD_INT 0
49595: LESS
49596: PUSH
49597: LD_VAR 0 1
49601: PUSH
49602: LD_INT 8
49604: GREATER
49605: OR
49606: PUSH
49607: LD_VAR 0 2
49611: PUSH
49612: LD_INT 0
49614: LESS
49615: OR
49616: PUSH
49617: LD_VAR 0 2
49621: PUSH
49622: LD_INT 8
49624: GREATER
49625: OR
49626: IFFALSE 49630
// exit ;
49628: GO 49705
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
49630: LD_ADDR_VAR 0 4
49634: PUSH
49635: LD_INT 22
49637: PUSH
49638: LD_VAR 0 2
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: PPUSH
49647: CALL_OW 69
49651: PUSH
49652: FOR_IN
49653: IFFALSE 49703
// begin un := UnitShoot ( i ) ;
49655: LD_ADDR_VAR 0 5
49659: PUSH
49660: LD_VAR 0 4
49664: PPUSH
49665: CALL_OW 504
49669: ST_TO_ADDR
// if GetSide ( un ) = side1 then
49670: LD_VAR 0 5
49674: PPUSH
49675: CALL_OW 255
49679: PUSH
49680: LD_VAR 0 1
49684: EQUAL
49685: IFFALSE 49701
// begin result := un ;
49687: LD_ADDR_VAR 0 3
49691: PUSH
49692: LD_VAR 0 5
49696: ST_TO_ADDR
// exit ;
49697: POP
49698: POP
49699: GO 49705
// end ; end ;
49701: GO 49652
49703: POP
49704: POP
// end ;
49705: LD_VAR 0 3
49709: RET
// export function GetCargoBay ( units ) ; begin
49710: LD_INT 0
49712: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49713: LD_ADDR_VAR 0 2
49717: PUSH
49718: LD_VAR 0 1
49722: PPUSH
49723: LD_INT 2
49725: PUSH
49726: LD_INT 34
49728: PUSH
49729: LD_INT 12
49731: PUSH
49732: EMPTY
49733: LIST
49734: LIST
49735: PUSH
49736: LD_INT 34
49738: PUSH
49739: LD_INT 51
49741: PUSH
49742: EMPTY
49743: LIST
49744: LIST
49745: PUSH
49746: LD_INT 34
49748: PUSH
49749: LD_INT 32
49751: PUSH
49752: EMPTY
49753: LIST
49754: LIST
49755: PUSH
49756: LD_INT 34
49758: PUSH
49759: LD_INT 89
49761: PUSH
49762: EMPTY
49763: LIST
49764: LIST
49765: PUSH
49766: EMPTY
49767: LIST
49768: LIST
49769: LIST
49770: LIST
49771: LIST
49772: PPUSH
49773: CALL_OW 72
49777: ST_TO_ADDR
// end ;
49778: LD_VAR 0 2
49782: RET
// export function Negate ( value ) ; begin
49783: LD_INT 0
49785: PPUSH
// result := not value ;
49786: LD_ADDR_VAR 0 2
49790: PUSH
49791: LD_VAR 0 1
49795: NOT
49796: ST_TO_ADDR
// end ;
49797: LD_VAR 0 2
49801: RET
// export function Inc ( value ) ; begin
49802: LD_INT 0
49804: PPUSH
// result := value + 1 ;
49805: LD_ADDR_VAR 0 2
49809: PUSH
49810: LD_VAR 0 1
49814: PUSH
49815: LD_INT 1
49817: PLUS
49818: ST_TO_ADDR
// end ;
49819: LD_VAR 0 2
49823: RET
// export function Dec ( value ) ; begin
49824: LD_INT 0
49826: PPUSH
// result := value - 1 ;
49827: LD_ADDR_VAR 0 2
49831: PUSH
49832: LD_VAR 0 1
49836: PUSH
49837: LD_INT 1
49839: MINUS
49840: ST_TO_ADDR
// end ;
49841: LD_VAR 0 2
49845: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
49846: LD_INT 0
49848: PPUSH
49849: PPUSH
49850: PPUSH
49851: PPUSH
49852: PPUSH
49853: PPUSH
49854: PPUSH
49855: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
49856: LD_VAR 0 1
49860: PPUSH
49861: LD_VAR 0 2
49865: PPUSH
49866: CALL_OW 488
49870: NOT
49871: PUSH
49872: LD_VAR 0 3
49876: PPUSH
49877: LD_VAR 0 4
49881: PPUSH
49882: CALL_OW 488
49886: NOT
49887: OR
49888: IFFALSE 49901
// begin result := - 1 ;
49890: LD_ADDR_VAR 0 5
49894: PUSH
49895: LD_INT 1
49897: NEG
49898: ST_TO_ADDR
// exit ;
49899: GO 50136
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
49901: LD_ADDR_VAR 0 12
49905: PUSH
49906: LD_VAR 0 1
49910: PPUSH
49911: LD_VAR 0 2
49915: PPUSH
49916: LD_VAR 0 3
49920: PPUSH
49921: LD_VAR 0 4
49925: PPUSH
49926: CALL 48986 0 4
49930: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
49931: LD_ADDR_VAR 0 11
49935: PUSH
49936: LD_VAR 0 1
49940: PPUSH
49941: LD_VAR 0 2
49945: PPUSH
49946: LD_VAR 0 12
49950: PUSH
49951: LD_INT 1
49953: ARRAY
49954: PPUSH
49955: LD_VAR 0 12
49959: PUSH
49960: LD_INT 2
49962: ARRAY
49963: PPUSH
49964: CALL_OW 298
49968: ST_TO_ADDR
// distance := 9999 ;
49969: LD_ADDR_VAR 0 10
49973: PUSH
49974: LD_INT 9999
49976: ST_TO_ADDR
// for i := 0 to 5 do
49977: LD_ADDR_VAR 0 6
49981: PUSH
49982: DOUBLE
49983: LD_INT 0
49985: DEC
49986: ST_TO_ADDR
49987: LD_INT 5
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50134
// begin _x := ShiftX ( x1 , i , centerDist ) ;
49993: LD_ADDR_VAR 0 7
49997: PUSH
49998: LD_VAR 0 1
50002: PPUSH
50003: LD_VAR 0 6
50007: PPUSH
50008: LD_VAR 0 11
50012: PPUSH
50013: CALL_OW 272
50017: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50018: LD_ADDR_VAR 0 8
50022: PUSH
50023: LD_VAR 0 2
50027: PPUSH
50028: LD_VAR 0 6
50032: PPUSH
50033: LD_VAR 0 11
50037: PPUSH
50038: CALL_OW 273
50042: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50043: LD_VAR 0 7
50047: PPUSH
50048: LD_VAR 0 8
50052: PPUSH
50053: CALL_OW 488
50057: NOT
50058: IFFALSE 50062
// continue ;
50060: GO 49990
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50062: LD_ADDR_VAR 0 9
50066: PUSH
50067: LD_VAR 0 12
50071: PUSH
50072: LD_INT 1
50074: ARRAY
50075: PPUSH
50076: LD_VAR 0 12
50080: PUSH
50081: LD_INT 2
50083: ARRAY
50084: PPUSH
50085: LD_VAR 0 7
50089: PPUSH
50090: LD_VAR 0 8
50094: PPUSH
50095: CALL_OW 298
50099: ST_TO_ADDR
// if tmp < distance then
50100: LD_VAR 0 9
50104: PUSH
50105: LD_VAR 0 10
50109: LESS
50110: IFFALSE 50132
// begin result := i ;
50112: LD_ADDR_VAR 0 5
50116: PUSH
50117: LD_VAR 0 6
50121: ST_TO_ADDR
// distance := tmp ;
50122: LD_ADDR_VAR 0 10
50126: PUSH
50127: LD_VAR 0 9
50131: ST_TO_ADDR
// end ; end ;
50132: GO 49990
50134: POP
50135: POP
// end ;
50136: LD_VAR 0 5
50140: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50141: LD_INT 0
50143: PPUSH
50144: PPUSH
// if not driver or not IsInUnit ( driver ) then
50145: LD_VAR 0 1
50149: NOT
50150: PUSH
50151: LD_VAR 0 1
50155: PPUSH
50156: CALL_OW 310
50160: NOT
50161: OR
50162: IFFALSE 50166
// exit ;
50164: GO 50256
// vehicle := IsInUnit ( driver ) ;
50166: LD_ADDR_VAR 0 3
50170: PUSH
50171: LD_VAR 0 1
50175: PPUSH
50176: CALL_OW 310
50180: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50181: LD_VAR 0 1
50185: PPUSH
50186: LD_STRING \
50188: PUSH
50189: LD_INT 0
50191: PUSH
50192: LD_INT 0
50194: PUSH
50195: LD_INT 0
50197: PUSH
50198: LD_INT 0
50200: PUSH
50201: LD_INT 0
50203: PUSH
50204: LD_INT 0
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: LIST
50215: PUSH
50216: LD_STRING E
50218: PUSH
50219: LD_INT 0
50221: PUSH
50222: LD_INT 0
50224: PUSH
50225: LD_VAR 0 3
50229: PUSH
50230: LD_INT 0
50232: PUSH
50233: LD_INT 0
50235: PUSH
50236: LD_INT 0
50238: PUSH
50239: EMPTY
50240: LIST
50241: LIST
50242: LIST
50243: LIST
50244: LIST
50245: LIST
50246: LIST
50247: PUSH
50248: EMPTY
50249: LIST
50250: LIST
50251: PPUSH
50252: CALL_OW 446
// end ;
50256: LD_VAR 0 2
50260: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
50261: LD_INT 0
50263: PPUSH
50264: PPUSH
// if not driver or not IsInUnit ( driver ) then
50265: LD_VAR 0 1
50269: NOT
50270: PUSH
50271: LD_VAR 0 1
50275: PPUSH
50276: CALL_OW 310
50280: NOT
50281: OR
50282: IFFALSE 50286
// exit ;
50284: GO 50376
// vehicle := IsInUnit ( driver ) ;
50286: LD_ADDR_VAR 0 3
50290: PUSH
50291: LD_VAR 0 1
50295: PPUSH
50296: CALL_OW 310
50300: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
50301: LD_VAR 0 1
50305: PPUSH
50306: LD_STRING \
50308: PUSH
50309: LD_INT 0
50311: PUSH
50312: LD_INT 0
50314: PUSH
50315: LD_INT 0
50317: PUSH
50318: LD_INT 0
50320: PUSH
50321: LD_INT 0
50323: PUSH
50324: LD_INT 0
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: LIST
50331: LIST
50332: LIST
50333: LIST
50334: LIST
50335: PUSH
50336: LD_STRING E
50338: PUSH
50339: LD_INT 0
50341: PUSH
50342: LD_INT 0
50344: PUSH
50345: LD_VAR 0 3
50349: PUSH
50350: LD_INT 0
50352: PUSH
50353: LD_INT 0
50355: PUSH
50356: LD_INT 0
50358: PUSH
50359: EMPTY
50360: LIST
50361: LIST
50362: LIST
50363: LIST
50364: LIST
50365: LIST
50366: LIST
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PPUSH
50372: CALL_OW 447
// end ;
50376: LD_VAR 0 2
50380: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
50381: LD_INT 0
50383: PPUSH
50384: PPUSH
50385: PPUSH
// tmp := [ ] ;
50386: LD_ADDR_VAR 0 5
50390: PUSH
50391: EMPTY
50392: ST_TO_ADDR
// for i in units do
50393: LD_ADDR_VAR 0 4
50397: PUSH
50398: LD_VAR 0 1
50402: PUSH
50403: FOR_IN
50404: IFFALSE 50442
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
50406: LD_ADDR_VAR 0 5
50410: PUSH
50411: LD_VAR 0 5
50415: PPUSH
50416: LD_VAR 0 5
50420: PUSH
50421: LD_INT 1
50423: PLUS
50424: PPUSH
50425: LD_VAR 0 4
50429: PPUSH
50430: CALL_OW 256
50434: PPUSH
50435: CALL_OW 2
50439: ST_TO_ADDR
50440: GO 50403
50442: POP
50443: POP
// if not tmp then
50444: LD_VAR 0 5
50448: NOT
50449: IFFALSE 50453
// exit ;
50451: GO 50501
// if asc then
50453: LD_VAR 0 2
50457: IFFALSE 50481
// result := SortListByListAsc ( units , tmp ) else
50459: LD_ADDR_VAR 0 3
50463: PUSH
50464: LD_VAR 0 1
50468: PPUSH
50469: LD_VAR 0 5
50473: PPUSH
50474: CALL_OW 76
50478: ST_TO_ADDR
50479: GO 50501
// result := SortListByListDesc ( units , tmp ) ;
50481: LD_ADDR_VAR 0 3
50485: PUSH
50486: LD_VAR 0 1
50490: PPUSH
50491: LD_VAR 0 5
50495: PPUSH
50496: CALL_OW 77
50500: ST_TO_ADDR
// end ;
50501: LD_VAR 0 3
50505: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
50506: LD_INT 0
50508: PPUSH
50509: PPUSH
// task := GetTaskList ( mech ) ;
50510: LD_ADDR_VAR 0 4
50514: PUSH
50515: LD_VAR 0 1
50519: PPUSH
50520: CALL_OW 437
50524: ST_TO_ADDR
// if not task then
50525: LD_VAR 0 4
50529: NOT
50530: IFFALSE 50534
// exit ;
50532: GO 50576
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
50534: LD_ADDR_VAR 0 3
50538: PUSH
50539: LD_VAR 0 4
50543: PUSH
50544: LD_INT 1
50546: ARRAY
50547: PUSH
50548: LD_INT 1
50550: ARRAY
50551: PUSH
50552: LD_STRING r
50554: EQUAL
50555: PUSH
50556: LD_VAR 0 4
50560: PUSH
50561: LD_INT 1
50563: ARRAY
50564: PUSH
50565: LD_INT 4
50567: ARRAY
50568: PUSH
50569: LD_VAR 0 2
50573: EQUAL
50574: AND
50575: ST_TO_ADDR
// end ;
50576: LD_VAR 0 3
50580: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
50581: LD_INT 0
50583: PPUSH
// SetDir ( unit , d ) ;
50584: LD_VAR 0 1
50588: PPUSH
50589: LD_VAR 0 4
50593: PPUSH
50594: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
50598: LD_VAR 0 1
50602: PPUSH
50603: LD_VAR 0 2
50607: PPUSH
50608: LD_VAR 0 3
50612: PPUSH
50613: LD_VAR 0 5
50617: PPUSH
50618: CALL_OW 48
// end ;
50622: LD_VAR 0 6
50626: RET
// export function ToNaturalNumber ( number ) ; begin
50627: LD_INT 0
50629: PPUSH
// result := number div 1 ;
50630: LD_ADDR_VAR 0 2
50634: PUSH
50635: LD_VAR 0 1
50639: PUSH
50640: LD_INT 1
50642: DIV
50643: ST_TO_ADDR
// if number < 0 then
50644: LD_VAR 0 1
50648: PUSH
50649: LD_INT 0
50651: LESS
50652: IFFALSE 50662
// result := 0 ;
50654: LD_ADDR_VAR 0 2
50658: PUSH
50659: LD_INT 0
50661: ST_TO_ADDR
// end ;
50662: LD_VAR 0 2
50666: RET
// export function SortByClass ( units , class ) ; var un ; begin
50667: LD_INT 0
50669: PPUSH
50670: PPUSH
// if not units or not class then
50671: LD_VAR 0 1
50675: NOT
50676: PUSH
50677: LD_VAR 0 2
50681: NOT
50682: OR
50683: IFFALSE 50687
// exit ;
50685: GO 50782
// result := [ ] ;
50687: LD_ADDR_VAR 0 3
50691: PUSH
50692: EMPTY
50693: ST_TO_ADDR
// for un in units do
50694: LD_ADDR_VAR 0 4
50698: PUSH
50699: LD_VAR 0 1
50703: PUSH
50704: FOR_IN
50705: IFFALSE 50780
// if GetClass ( un ) = class then
50707: LD_VAR 0 4
50711: PPUSH
50712: CALL_OW 257
50716: PUSH
50717: LD_VAR 0 2
50721: EQUAL
50722: IFFALSE 50749
// result := Insert ( result , 1 , un ) else
50724: LD_ADDR_VAR 0 3
50728: PUSH
50729: LD_VAR 0 3
50733: PPUSH
50734: LD_INT 1
50736: PPUSH
50737: LD_VAR 0 4
50741: PPUSH
50742: CALL_OW 2
50746: ST_TO_ADDR
50747: GO 50778
// result := Replace ( result , result + 1 , un ) ;
50749: LD_ADDR_VAR 0 3
50753: PUSH
50754: LD_VAR 0 3
50758: PPUSH
50759: LD_VAR 0 3
50763: PUSH
50764: LD_INT 1
50766: PLUS
50767: PPUSH
50768: LD_VAR 0 4
50772: PPUSH
50773: CALL_OW 1
50777: ST_TO_ADDR
50778: GO 50704
50780: POP
50781: POP
// end ;
50782: LD_VAR 0 3
50786: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
50787: LD_INT 0
50789: PPUSH
50790: PPUSH
50791: PPUSH
50792: PPUSH
50793: PPUSH
50794: PPUSH
50795: PPUSH
// result := [ ] ;
50796: LD_ADDR_VAR 0 4
50800: PUSH
50801: EMPTY
50802: ST_TO_ADDR
// if x - r < 0 then
50803: LD_VAR 0 1
50807: PUSH
50808: LD_VAR 0 3
50812: MINUS
50813: PUSH
50814: LD_INT 0
50816: LESS
50817: IFFALSE 50829
// min_x := 0 else
50819: LD_ADDR_VAR 0 8
50823: PUSH
50824: LD_INT 0
50826: ST_TO_ADDR
50827: GO 50845
// min_x := x - r ;
50829: LD_ADDR_VAR 0 8
50833: PUSH
50834: LD_VAR 0 1
50838: PUSH
50839: LD_VAR 0 3
50843: MINUS
50844: ST_TO_ADDR
// if y - r < 0 then
50845: LD_VAR 0 2
50849: PUSH
50850: LD_VAR 0 3
50854: MINUS
50855: PUSH
50856: LD_INT 0
50858: LESS
50859: IFFALSE 50871
// min_y := 0 else
50861: LD_ADDR_VAR 0 7
50865: PUSH
50866: LD_INT 0
50868: ST_TO_ADDR
50869: GO 50887
// min_y := y - r ;
50871: LD_ADDR_VAR 0 7
50875: PUSH
50876: LD_VAR 0 2
50880: PUSH
50881: LD_VAR 0 3
50885: MINUS
50886: ST_TO_ADDR
// max_x := x + r ;
50887: LD_ADDR_VAR 0 9
50891: PUSH
50892: LD_VAR 0 1
50896: PUSH
50897: LD_VAR 0 3
50901: PLUS
50902: ST_TO_ADDR
// max_y := y + r ;
50903: LD_ADDR_VAR 0 10
50907: PUSH
50908: LD_VAR 0 2
50912: PUSH
50913: LD_VAR 0 3
50917: PLUS
50918: ST_TO_ADDR
// for _x = min_x to max_x do
50919: LD_ADDR_VAR 0 5
50923: PUSH
50924: DOUBLE
50925: LD_VAR 0 8
50929: DEC
50930: ST_TO_ADDR
50931: LD_VAR 0 9
50935: PUSH
50936: FOR_TO
50937: IFFALSE 51038
// for _y = min_y to max_y do
50939: LD_ADDR_VAR 0 6
50943: PUSH
50944: DOUBLE
50945: LD_VAR 0 7
50949: DEC
50950: ST_TO_ADDR
50951: LD_VAR 0 10
50955: PUSH
50956: FOR_TO
50957: IFFALSE 51034
// begin if not ValidHex ( _x , _y ) then
50959: LD_VAR 0 5
50963: PPUSH
50964: LD_VAR 0 6
50968: PPUSH
50969: CALL_OW 488
50973: NOT
50974: IFFALSE 50978
// continue ;
50976: GO 50956
// if GetResourceTypeXY ( _x , _y ) then
50978: LD_VAR 0 5
50982: PPUSH
50983: LD_VAR 0 6
50987: PPUSH
50988: CALL_OW 283
50992: IFFALSE 51032
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50994: LD_ADDR_VAR 0 4
50998: PUSH
50999: LD_VAR 0 4
51003: PPUSH
51004: LD_VAR 0 4
51008: PUSH
51009: LD_INT 1
51011: PLUS
51012: PPUSH
51013: LD_VAR 0 5
51017: PUSH
51018: LD_VAR 0 6
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: PPUSH
51027: CALL_OW 1
51031: ST_TO_ADDR
// end ;
51032: GO 50956
51034: POP
51035: POP
51036: GO 50936
51038: POP
51039: POP
// end ;
51040: LD_VAR 0 4
51044: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
51045: LD_INT 0
51047: PPUSH
51048: PPUSH
51049: PPUSH
51050: PPUSH
51051: PPUSH
51052: PPUSH
51053: PPUSH
51054: PPUSH
// if not units then
51055: LD_VAR 0 1
51059: NOT
51060: IFFALSE 51064
// exit ;
51062: GO 51588
// result := UnitFilter ( units , [ f_ok ] ) ;
51064: LD_ADDR_VAR 0 3
51068: PUSH
51069: LD_VAR 0 1
51073: PPUSH
51074: LD_INT 50
51076: PUSH
51077: EMPTY
51078: LIST
51079: PPUSH
51080: CALL_OW 72
51084: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
51085: LD_ADDR_VAR 0 8
51089: PUSH
51090: LD_VAR 0 1
51094: PUSH
51095: LD_INT 1
51097: ARRAY
51098: PPUSH
51099: CALL_OW 255
51103: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
51104: LD_ADDR_VAR 0 10
51108: PUSH
51109: LD_INT 29
51111: PUSH
51112: LD_INT 91
51114: PUSH
51115: LD_INT 49
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: LIST
51122: ST_TO_ADDR
// if not result then
51123: LD_VAR 0 3
51127: NOT
51128: IFFALSE 51132
// exit ;
51130: GO 51588
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
51132: LD_ADDR_VAR 0 5
51136: PUSH
51137: LD_INT 81
51139: PUSH
51140: LD_VAR 0 8
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: PPUSH
51149: CALL_OW 69
51153: ST_TO_ADDR
// for i in result do
51154: LD_ADDR_VAR 0 4
51158: PUSH
51159: LD_VAR 0 3
51163: PUSH
51164: FOR_IN
51165: IFFALSE 51586
// begin tag := GetTag ( i ) + 1 ;
51167: LD_ADDR_VAR 0 9
51171: PUSH
51172: LD_VAR 0 4
51176: PPUSH
51177: CALL_OW 110
51181: PUSH
51182: LD_INT 1
51184: PLUS
51185: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
51186: LD_ADDR_VAR 0 7
51190: PUSH
51191: LD_VAR 0 4
51195: PPUSH
51196: CALL_OW 250
51200: PPUSH
51201: LD_VAR 0 4
51205: PPUSH
51206: CALL_OW 251
51210: PPUSH
51211: LD_INT 6
51213: PPUSH
51214: CALL 50787 0 3
51218: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
51219: LD_VAR 0 4
51223: PPUSH
51224: CALL_OW 247
51228: PUSH
51229: LD_INT 2
51231: EQUAL
51232: PUSH
51233: LD_VAR 0 7
51237: AND
51238: PUSH
51239: LD_VAR 0 4
51243: PPUSH
51244: CALL_OW 264
51248: PUSH
51249: LD_VAR 0 10
51253: IN
51254: NOT
51255: AND
51256: IFFALSE 51295
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
51258: LD_VAR 0 4
51262: PPUSH
51263: LD_VAR 0 7
51267: PUSH
51268: LD_INT 1
51270: ARRAY
51271: PUSH
51272: LD_INT 1
51274: ARRAY
51275: PPUSH
51276: LD_VAR 0 7
51280: PUSH
51281: LD_INT 1
51283: ARRAY
51284: PUSH
51285: LD_INT 2
51287: ARRAY
51288: PPUSH
51289: CALL_OW 116
51293: GO 51584
// if path > tag then
51295: LD_VAR 0 2
51299: PUSH
51300: LD_VAR 0 9
51304: GREATER
51305: IFFALSE 51513
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
51307: LD_ADDR_VAR 0 6
51311: PUSH
51312: LD_VAR 0 5
51316: PPUSH
51317: LD_INT 91
51319: PUSH
51320: LD_VAR 0 4
51324: PUSH
51325: LD_INT 8
51327: PUSH
51328: EMPTY
51329: LIST
51330: LIST
51331: LIST
51332: PPUSH
51333: CALL_OW 72
51337: ST_TO_ADDR
// if nearEnemy then
51338: LD_VAR 0 6
51342: IFFALSE 51411
// begin if GetWeapon ( i ) = ru_time_lapser then
51344: LD_VAR 0 4
51348: PPUSH
51349: CALL_OW 264
51353: PUSH
51354: LD_INT 49
51356: EQUAL
51357: IFFALSE 51385
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
51359: LD_VAR 0 4
51363: PPUSH
51364: LD_VAR 0 6
51368: PPUSH
51369: LD_VAR 0 4
51373: PPUSH
51374: CALL_OW 74
51378: PPUSH
51379: CALL_OW 112
51383: GO 51409
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
51385: LD_VAR 0 4
51389: PPUSH
51390: LD_VAR 0 6
51394: PPUSH
51395: LD_VAR 0 4
51399: PPUSH
51400: CALL_OW 74
51404: PPUSH
51405: CALL_OW 115
// end else
51409: GO 51511
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
51411: LD_VAR 0 4
51415: PPUSH
51416: LD_VAR 0 2
51420: PUSH
51421: LD_VAR 0 9
51425: ARRAY
51426: PUSH
51427: LD_INT 1
51429: ARRAY
51430: PPUSH
51431: LD_VAR 0 2
51435: PUSH
51436: LD_VAR 0 9
51440: ARRAY
51441: PUSH
51442: LD_INT 2
51444: ARRAY
51445: PPUSH
51446: CALL_OW 297
51450: PUSH
51451: LD_INT 6
51453: GREATER
51454: IFFALSE 51497
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
51456: LD_VAR 0 4
51460: PPUSH
51461: LD_VAR 0 2
51465: PUSH
51466: LD_VAR 0 9
51470: ARRAY
51471: PUSH
51472: LD_INT 1
51474: ARRAY
51475: PPUSH
51476: LD_VAR 0 2
51480: PUSH
51481: LD_VAR 0 9
51485: ARRAY
51486: PUSH
51487: LD_INT 2
51489: ARRAY
51490: PPUSH
51491: CALL_OW 114
51495: GO 51511
// SetTag ( i , tag ) ;
51497: LD_VAR 0 4
51501: PPUSH
51502: LD_VAR 0 9
51506: PPUSH
51507: CALL_OW 109
// end else
51511: GO 51584
// if enemy then
51513: LD_VAR 0 5
51517: IFFALSE 51584
// begin if GetWeapon ( i ) = ru_time_lapser then
51519: LD_VAR 0 4
51523: PPUSH
51524: CALL_OW 264
51528: PUSH
51529: LD_INT 49
51531: EQUAL
51532: IFFALSE 51560
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
51534: LD_VAR 0 4
51538: PPUSH
51539: LD_VAR 0 5
51543: PPUSH
51544: LD_VAR 0 4
51548: PPUSH
51549: CALL_OW 74
51553: PPUSH
51554: CALL_OW 112
51558: GO 51584
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
51560: LD_VAR 0 4
51564: PPUSH
51565: LD_VAR 0 5
51569: PPUSH
51570: LD_VAR 0 4
51574: PPUSH
51575: CALL_OW 74
51579: PPUSH
51580: CALL_OW 115
// end ; end ;
51584: GO 51164
51586: POP
51587: POP
// end ;
51588: LD_VAR 0 3
51592: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
51593: LD_INT 0
51595: PPUSH
51596: PPUSH
51597: PPUSH
// if not unit or IsInUnit ( unit ) then
51598: LD_VAR 0 1
51602: NOT
51603: PUSH
51604: LD_VAR 0 1
51608: PPUSH
51609: CALL_OW 310
51613: OR
51614: IFFALSE 51618
// exit ;
51616: GO 51709
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
51618: LD_ADDR_VAR 0 4
51622: PUSH
51623: LD_VAR 0 1
51627: PPUSH
51628: CALL_OW 250
51632: PPUSH
51633: LD_VAR 0 2
51637: PPUSH
51638: LD_INT 1
51640: PPUSH
51641: CALL_OW 272
51645: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
51646: LD_ADDR_VAR 0 5
51650: PUSH
51651: LD_VAR 0 1
51655: PPUSH
51656: CALL_OW 251
51660: PPUSH
51661: LD_VAR 0 2
51665: PPUSH
51666: LD_INT 1
51668: PPUSH
51669: CALL_OW 273
51673: ST_TO_ADDR
// if ValidHex ( x , y ) then
51674: LD_VAR 0 4
51678: PPUSH
51679: LD_VAR 0 5
51683: PPUSH
51684: CALL_OW 488
51688: IFFALSE 51709
// ComTurnXY ( unit , x , y ) ;
51690: LD_VAR 0 1
51694: PPUSH
51695: LD_VAR 0 4
51699: PPUSH
51700: LD_VAR 0 5
51704: PPUSH
51705: CALL_OW 118
// end ;
51709: LD_VAR 0 3
51713: RET
// export function SeeUnits ( side , units ) ; var i ; begin
51714: LD_INT 0
51716: PPUSH
51717: PPUSH
// result := false ;
51718: LD_ADDR_VAR 0 3
51722: PUSH
51723: LD_INT 0
51725: ST_TO_ADDR
// if not units then
51726: LD_VAR 0 2
51730: NOT
51731: IFFALSE 51735
// exit ;
51733: GO 51780
// for i in units do
51735: LD_ADDR_VAR 0 4
51739: PUSH
51740: LD_VAR 0 2
51744: PUSH
51745: FOR_IN
51746: IFFALSE 51778
// if See ( side , i ) then
51748: LD_VAR 0 1
51752: PPUSH
51753: LD_VAR 0 4
51757: PPUSH
51758: CALL_OW 292
51762: IFFALSE 51776
// begin result := true ;
51764: LD_ADDR_VAR 0 3
51768: PUSH
51769: LD_INT 1
51771: ST_TO_ADDR
// exit ;
51772: POP
51773: POP
51774: GO 51780
// end ;
51776: GO 51745
51778: POP
51779: POP
// end ;
51780: LD_VAR 0 3
51784: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
51785: LD_INT 0
51787: PPUSH
51788: PPUSH
51789: PPUSH
51790: PPUSH
// if not unit or not points then
51791: LD_VAR 0 1
51795: NOT
51796: PUSH
51797: LD_VAR 0 2
51801: NOT
51802: OR
51803: IFFALSE 51807
// exit ;
51805: GO 51897
// dist := 99999 ;
51807: LD_ADDR_VAR 0 5
51811: PUSH
51812: LD_INT 99999
51814: ST_TO_ADDR
// for i in points do
51815: LD_ADDR_VAR 0 4
51819: PUSH
51820: LD_VAR 0 2
51824: PUSH
51825: FOR_IN
51826: IFFALSE 51895
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
51828: LD_ADDR_VAR 0 6
51832: PUSH
51833: LD_VAR 0 1
51837: PPUSH
51838: LD_VAR 0 4
51842: PUSH
51843: LD_INT 1
51845: ARRAY
51846: PPUSH
51847: LD_VAR 0 4
51851: PUSH
51852: LD_INT 2
51854: ARRAY
51855: PPUSH
51856: CALL_OW 297
51860: ST_TO_ADDR
// if tmpDist < dist then
51861: LD_VAR 0 6
51865: PUSH
51866: LD_VAR 0 5
51870: LESS
51871: IFFALSE 51893
// begin result := i ;
51873: LD_ADDR_VAR 0 3
51877: PUSH
51878: LD_VAR 0 4
51882: ST_TO_ADDR
// dist := tmpDist ;
51883: LD_ADDR_VAR 0 5
51887: PUSH
51888: LD_VAR 0 6
51892: ST_TO_ADDR
// end ; end ;
51893: GO 51825
51895: POP
51896: POP
// end ;
51897: LD_VAR 0 3
51901: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
51902: LD_INT 0
51904: PPUSH
// uc_side := side ;
51905: LD_ADDR_OWVAR 20
51909: PUSH
51910: LD_VAR 0 1
51914: ST_TO_ADDR
// uc_nation := 3 ;
51915: LD_ADDR_OWVAR 21
51919: PUSH
51920: LD_INT 3
51922: ST_TO_ADDR
// vc_chassis := 25 ;
51923: LD_ADDR_OWVAR 37
51927: PUSH
51928: LD_INT 25
51930: ST_TO_ADDR
// vc_engine := engine_siberite ;
51931: LD_ADDR_OWVAR 39
51935: PUSH
51936: LD_INT 3
51938: ST_TO_ADDR
// vc_control := control_computer ;
51939: LD_ADDR_OWVAR 38
51943: PUSH
51944: LD_INT 3
51946: ST_TO_ADDR
// vc_weapon := 59 ;
51947: LD_ADDR_OWVAR 40
51951: PUSH
51952: LD_INT 59
51954: ST_TO_ADDR
// result := CreateVehicle ;
51955: LD_ADDR_VAR 0 5
51959: PUSH
51960: CALL_OW 45
51964: ST_TO_ADDR
// SetDir ( result , d ) ;
51965: LD_VAR 0 5
51969: PPUSH
51970: LD_VAR 0 4
51974: PPUSH
51975: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
51979: LD_VAR 0 5
51983: PPUSH
51984: LD_VAR 0 2
51988: PPUSH
51989: LD_VAR 0 3
51993: PPUSH
51994: LD_INT 0
51996: PPUSH
51997: CALL_OW 48
// end ;
52001: LD_VAR 0 5
52005: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
52006: LD_INT 0
52008: PPUSH
52009: PPUSH
52010: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
52011: LD_ADDR_VAR 0 2
52015: PUSH
52016: LD_INT 0
52018: PUSH
52019: LD_INT 0
52021: PUSH
52022: LD_INT 0
52024: PUSH
52025: LD_INT 0
52027: PUSH
52028: EMPTY
52029: LIST
52030: LIST
52031: LIST
52032: LIST
52033: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
52034: LD_VAR 0 1
52038: NOT
52039: PUSH
52040: LD_VAR 0 1
52044: PPUSH
52045: CALL_OW 264
52049: PUSH
52050: LD_INT 12
52052: PUSH
52053: LD_INT 51
52055: PUSH
52056: LD_INT 32
52058: PUSH
52059: LD_INT 89
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: LIST
52066: LIST
52067: IN
52068: NOT
52069: OR
52070: IFFALSE 52074
// exit ;
52072: GO 52172
// for i := 1 to 3 do
52074: LD_ADDR_VAR 0 3
52078: PUSH
52079: DOUBLE
52080: LD_INT 1
52082: DEC
52083: ST_TO_ADDR
52084: LD_INT 3
52086: PUSH
52087: FOR_TO
52088: IFFALSE 52170
// begin tmp := GetCargo ( cargo , i ) ;
52090: LD_ADDR_VAR 0 4
52094: PUSH
52095: LD_VAR 0 1
52099: PPUSH
52100: LD_VAR 0 3
52104: PPUSH
52105: CALL_OW 289
52109: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
52110: LD_ADDR_VAR 0 2
52114: PUSH
52115: LD_VAR 0 2
52119: PPUSH
52120: LD_VAR 0 3
52124: PPUSH
52125: LD_VAR 0 4
52129: PPUSH
52130: CALL_OW 1
52134: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
52135: LD_ADDR_VAR 0 2
52139: PUSH
52140: LD_VAR 0 2
52144: PPUSH
52145: LD_INT 4
52147: PPUSH
52148: LD_VAR 0 2
52152: PUSH
52153: LD_INT 4
52155: ARRAY
52156: PUSH
52157: LD_VAR 0 4
52161: PLUS
52162: PPUSH
52163: CALL_OW 1
52167: ST_TO_ADDR
// end ;
52168: GO 52087
52170: POP
52171: POP
// end ;
52172: LD_VAR 0 2
52176: RET
// export function Length ( array ) ; begin
52177: LD_INT 0
52179: PPUSH
// result := array + 0 ;
52180: LD_ADDR_VAR 0 2
52184: PUSH
52185: LD_VAR 0 1
52189: PUSH
52190: LD_INT 0
52192: PLUS
52193: ST_TO_ADDR
// end ;
52194: LD_VAR 0 2
52198: RET
// export function PrepareArray ( array ) ; begin
52199: LD_INT 0
52201: PPUSH
// result := array diff 0 ;
52202: LD_ADDR_VAR 0 2
52206: PUSH
52207: LD_VAR 0 1
52211: PUSH
52212: LD_INT 0
52214: DIFF
52215: ST_TO_ADDR
// if not result [ 1 ] then
52216: LD_VAR 0 2
52220: PUSH
52221: LD_INT 1
52223: ARRAY
52224: NOT
52225: IFFALSE 52245
// result := Delete ( result , 1 ) ;
52227: LD_ADDR_VAR 0 2
52231: PUSH
52232: LD_VAR 0 2
52236: PPUSH
52237: LD_INT 1
52239: PPUSH
52240: CALL_OW 3
52244: ST_TO_ADDR
// end ;
52245: LD_VAR 0 2
52249: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
52250: LD_INT 0
52252: PPUSH
52253: PPUSH
52254: PPUSH
52255: PPUSH
// sibRocketRange := 25 ;
52256: LD_ADDR_VAR 0 6
52260: PUSH
52261: LD_INT 25
52263: ST_TO_ADDR
// result := false ;
52264: LD_ADDR_VAR 0 4
52268: PUSH
52269: LD_INT 0
52271: ST_TO_ADDR
// for i := 0 to 5 do
52272: LD_ADDR_VAR 0 5
52276: PUSH
52277: DOUBLE
52278: LD_INT 0
52280: DEC
52281: ST_TO_ADDR
52282: LD_INT 5
52284: PUSH
52285: FOR_TO
52286: IFFALSE 52353
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
52288: LD_VAR 0 1
52292: PPUSH
52293: LD_VAR 0 5
52297: PPUSH
52298: LD_VAR 0 6
52302: PPUSH
52303: CALL_OW 272
52307: PPUSH
52308: LD_VAR 0 2
52312: PPUSH
52313: LD_VAR 0 5
52317: PPUSH
52318: LD_VAR 0 6
52322: PPUSH
52323: CALL_OW 273
52327: PPUSH
52328: LD_VAR 0 3
52332: PPUSH
52333: CALL_OW 309
52337: IFFALSE 52351
// begin result := true ;
52339: LD_ADDR_VAR 0 4
52343: PUSH
52344: LD_INT 1
52346: ST_TO_ADDR
// exit ;
52347: POP
52348: POP
52349: GO 52355
// end ;
52351: GO 52285
52353: POP
52354: POP
// end ;
52355: LD_VAR 0 4
52359: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
52360: LD_INT 0
52362: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
52363: LD_VAR 0 1
52367: PPUSH
52368: LD_VAR 0 2
52372: PPUSH
52373: LD_INT 0
52375: PPUSH
52376: LD_INT 0
52378: PPUSH
52379: LD_INT 1
52381: PPUSH
52382: LD_INT 0
52384: PPUSH
52385: CALL_OW 587
// end ; end_of_file
52389: LD_VAR 0 3
52393: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52394: LD_INT 0
52396: PPUSH
52397: PPUSH
// skirmish := false ;
52398: LD_ADDR_EXP 21
52402: PUSH
52403: LD_INT 0
52405: ST_TO_ADDR
// debug_mc := false ;
52406: LD_ADDR_EXP 22
52410: PUSH
52411: LD_INT 0
52413: ST_TO_ADDR
// mc_bases := [ ] ;
52414: LD_ADDR_EXP 23
52418: PUSH
52419: EMPTY
52420: ST_TO_ADDR
// mc_sides := [ ] ;
52421: LD_ADDR_EXP 49
52425: PUSH
52426: EMPTY
52427: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52428: LD_ADDR_EXP 24
52432: PUSH
52433: EMPTY
52434: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52435: LD_ADDR_EXP 25
52439: PUSH
52440: EMPTY
52441: ST_TO_ADDR
// mc_need_heal := [ ] ;
52442: LD_ADDR_EXP 26
52446: PUSH
52447: EMPTY
52448: ST_TO_ADDR
// mc_healers := [ ] ;
52449: LD_ADDR_EXP 27
52453: PUSH
52454: EMPTY
52455: ST_TO_ADDR
// mc_build_list := [ ] ;
52456: LD_ADDR_EXP 28
52460: PUSH
52461: EMPTY
52462: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52463: LD_ADDR_EXP 55
52467: PUSH
52468: EMPTY
52469: ST_TO_ADDR
// mc_builders := [ ] ;
52470: LD_ADDR_EXP 29
52474: PUSH
52475: EMPTY
52476: ST_TO_ADDR
// mc_construct_list := [ ] ;
52477: LD_ADDR_EXP 30
52481: PUSH
52482: EMPTY
52483: ST_TO_ADDR
// mc_turret_list := [ ] ;
52484: LD_ADDR_EXP 31
52488: PUSH
52489: EMPTY
52490: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52491: LD_ADDR_EXP 32
52495: PUSH
52496: EMPTY
52497: ST_TO_ADDR
// mc_miners := [ ] ;
52498: LD_ADDR_EXP 37
52502: PUSH
52503: EMPTY
52504: ST_TO_ADDR
// mc_mines := [ ] ;
52505: LD_ADDR_EXP 36
52509: PUSH
52510: EMPTY
52511: ST_TO_ADDR
// mc_minefields := [ ] ;
52512: LD_ADDR_EXP 38
52516: PUSH
52517: EMPTY
52518: ST_TO_ADDR
// mc_crates := [ ] ;
52519: LD_ADDR_EXP 39
52523: PUSH
52524: EMPTY
52525: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52526: LD_ADDR_EXP 40
52530: PUSH
52531: EMPTY
52532: ST_TO_ADDR
// mc_crates_area := [ ] ;
52533: LD_ADDR_EXP 41
52537: PUSH
52538: EMPTY
52539: ST_TO_ADDR
// mc_vehicles := [ ] ;
52540: LD_ADDR_EXP 42
52544: PUSH
52545: EMPTY
52546: ST_TO_ADDR
// mc_attack := [ ] ;
52547: LD_ADDR_EXP 43
52551: PUSH
52552: EMPTY
52553: ST_TO_ADDR
// mc_produce := [ ] ;
52554: LD_ADDR_EXP 44
52558: PUSH
52559: EMPTY
52560: ST_TO_ADDR
// mc_defender := [ ] ;
52561: LD_ADDR_EXP 45
52565: PUSH
52566: EMPTY
52567: ST_TO_ADDR
// mc_parking := [ ] ;
52568: LD_ADDR_EXP 47
52572: PUSH
52573: EMPTY
52574: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52575: LD_ADDR_EXP 33
52579: PUSH
52580: EMPTY
52581: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52582: LD_ADDR_EXP 35
52586: PUSH
52587: EMPTY
52588: ST_TO_ADDR
// mc_scan := [ ] ;
52589: LD_ADDR_EXP 46
52593: PUSH
52594: EMPTY
52595: ST_TO_ADDR
// mc_scan_area := [ ] ;
52596: LD_ADDR_EXP 48
52600: PUSH
52601: EMPTY
52602: ST_TO_ADDR
// mc_tech := [ ] ;
52603: LD_ADDR_EXP 50
52607: PUSH
52608: EMPTY
52609: ST_TO_ADDR
// mc_class := [ ] ;
52610: LD_ADDR_EXP 64
52614: PUSH
52615: EMPTY
52616: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52617: LD_ADDR_EXP 65
52621: PUSH
52622: EMPTY
52623: ST_TO_ADDR
// mc_is_defending := [ ] ;
52624: LD_ADDR_EXP 66
52628: PUSH
52629: EMPTY
52630: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
52631: LD_ADDR_EXP 57
52635: PUSH
52636: EMPTY
52637: ST_TO_ADDR
// end ;
52638: LD_VAR 0 1
52642: RET
// export function MC_Kill ( base ) ; begin
52643: LD_INT 0
52645: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52646: LD_ADDR_EXP 23
52650: PUSH
52651: LD_EXP 23
52655: PPUSH
52656: LD_VAR 0 1
52660: PPUSH
52661: EMPTY
52662: PPUSH
52663: CALL_OW 1
52667: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52668: LD_ADDR_EXP 24
52672: PUSH
52673: LD_EXP 24
52677: PPUSH
52678: LD_VAR 0 1
52682: PPUSH
52683: EMPTY
52684: PPUSH
52685: CALL_OW 1
52689: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52690: LD_ADDR_EXP 25
52694: PUSH
52695: LD_EXP 25
52699: PPUSH
52700: LD_VAR 0 1
52704: PPUSH
52705: EMPTY
52706: PPUSH
52707: CALL_OW 1
52711: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52712: LD_ADDR_EXP 26
52716: PUSH
52717: LD_EXP 26
52721: PPUSH
52722: LD_VAR 0 1
52726: PPUSH
52727: EMPTY
52728: PPUSH
52729: CALL_OW 1
52733: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52734: LD_ADDR_EXP 27
52738: PUSH
52739: LD_EXP 27
52743: PPUSH
52744: LD_VAR 0 1
52748: PPUSH
52749: EMPTY
52750: PPUSH
52751: CALL_OW 1
52755: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52756: LD_ADDR_EXP 28
52760: PUSH
52761: LD_EXP 28
52765: PPUSH
52766: LD_VAR 0 1
52770: PPUSH
52771: EMPTY
52772: PPUSH
52773: CALL_OW 1
52777: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52778: LD_ADDR_EXP 29
52782: PUSH
52783: LD_EXP 29
52787: PPUSH
52788: LD_VAR 0 1
52792: PPUSH
52793: EMPTY
52794: PPUSH
52795: CALL_OW 1
52799: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52800: LD_ADDR_EXP 30
52804: PUSH
52805: LD_EXP 30
52809: PPUSH
52810: LD_VAR 0 1
52814: PPUSH
52815: EMPTY
52816: PPUSH
52817: CALL_OW 1
52821: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52822: LD_ADDR_EXP 31
52826: PUSH
52827: LD_EXP 31
52831: PPUSH
52832: LD_VAR 0 1
52836: PPUSH
52837: EMPTY
52838: PPUSH
52839: CALL_OW 1
52843: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52844: LD_ADDR_EXP 32
52848: PUSH
52849: LD_EXP 32
52853: PPUSH
52854: LD_VAR 0 1
52858: PPUSH
52859: EMPTY
52860: PPUSH
52861: CALL_OW 1
52865: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52866: LD_ADDR_EXP 33
52870: PUSH
52871: LD_EXP 33
52875: PPUSH
52876: LD_VAR 0 1
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52888: LD_ADDR_EXP 34
52892: PUSH
52893: LD_EXP 34
52897: PPUSH
52898: LD_VAR 0 1
52902: PPUSH
52903: LD_INT 0
52905: PPUSH
52906: CALL_OW 1
52910: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52911: LD_ADDR_EXP 35
52915: PUSH
52916: LD_EXP 35
52920: PPUSH
52921: LD_VAR 0 1
52925: PPUSH
52926: EMPTY
52927: PPUSH
52928: CALL_OW 1
52932: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52933: LD_ADDR_EXP 36
52937: PUSH
52938: LD_EXP 36
52942: PPUSH
52943: LD_VAR 0 1
52947: PPUSH
52948: EMPTY
52949: PPUSH
52950: CALL_OW 1
52954: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52955: LD_ADDR_EXP 37
52959: PUSH
52960: LD_EXP 37
52964: PPUSH
52965: LD_VAR 0 1
52969: PPUSH
52970: EMPTY
52971: PPUSH
52972: CALL_OW 1
52976: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52977: LD_ADDR_EXP 38
52981: PUSH
52982: LD_EXP 38
52986: PPUSH
52987: LD_VAR 0 1
52991: PPUSH
52992: EMPTY
52993: PPUSH
52994: CALL_OW 1
52998: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52999: LD_ADDR_EXP 39
53003: PUSH
53004: LD_EXP 39
53008: PPUSH
53009: LD_VAR 0 1
53013: PPUSH
53014: EMPTY
53015: PPUSH
53016: CALL_OW 1
53020: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53021: LD_ADDR_EXP 40
53025: PUSH
53026: LD_EXP 40
53030: PPUSH
53031: LD_VAR 0 1
53035: PPUSH
53036: EMPTY
53037: PPUSH
53038: CALL_OW 1
53042: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53043: LD_ADDR_EXP 41
53047: PUSH
53048: LD_EXP 41
53052: PPUSH
53053: LD_VAR 0 1
53057: PPUSH
53058: EMPTY
53059: PPUSH
53060: CALL_OW 1
53064: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53065: LD_ADDR_EXP 42
53069: PUSH
53070: LD_EXP 42
53074: PPUSH
53075: LD_VAR 0 1
53079: PPUSH
53080: EMPTY
53081: PPUSH
53082: CALL_OW 1
53086: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53087: LD_ADDR_EXP 43
53091: PUSH
53092: LD_EXP 43
53096: PPUSH
53097: LD_VAR 0 1
53101: PPUSH
53102: EMPTY
53103: PPUSH
53104: CALL_OW 1
53108: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53109: LD_ADDR_EXP 44
53113: PUSH
53114: LD_EXP 44
53118: PPUSH
53119: LD_VAR 0 1
53123: PPUSH
53124: EMPTY
53125: PPUSH
53126: CALL_OW 1
53130: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53131: LD_ADDR_EXP 45
53135: PUSH
53136: LD_EXP 45
53140: PPUSH
53141: LD_VAR 0 1
53145: PPUSH
53146: EMPTY
53147: PPUSH
53148: CALL_OW 1
53152: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53153: LD_ADDR_EXP 46
53157: PUSH
53158: LD_EXP 46
53162: PPUSH
53163: LD_VAR 0 1
53167: PPUSH
53168: EMPTY
53169: PPUSH
53170: CALL_OW 1
53174: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53175: LD_ADDR_EXP 47
53179: PUSH
53180: LD_EXP 47
53184: PPUSH
53185: LD_VAR 0 1
53189: PPUSH
53190: EMPTY
53191: PPUSH
53192: CALL_OW 1
53196: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53197: LD_ADDR_EXP 48
53201: PUSH
53202: LD_EXP 48
53206: PPUSH
53207: LD_VAR 0 1
53211: PPUSH
53212: EMPTY
53213: PPUSH
53214: CALL_OW 1
53218: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53219: LD_ADDR_EXP 50
53223: PUSH
53224: LD_EXP 50
53228: PPUSH
53229: LD_VAR 0 1
53233: PPUSH
53234: EMPTY
53235: PPUSH
53236: CALL_OW 1
53240: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53241: LD_ADDR_EXP 52
53245: PUSH
53246: LD_EXP 52
53250: PPUSH
53251: LD_VAR 0 1
53255: PPUSH
53256: EMPTY
53257: PPUSH
53258: CALL_OW 1
53262: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53263: LD_ADDR_EXP 53
53267: PUSH
53268: LD_EXP 53
53272: PPUSH
53273: LD_VAR 0 1
53277: PPUSH
53278: EMPTY
53279: PPUSH
53280: CALL_OW 1
53284: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53285: LD_ADDR_EXP 54
53289: PUSH
53290: LD_EXP 54
53294: PPUSH
53295: LD_VAR 0 1
53299: PPUSH
53300: EMPTY
53301: PPUSH
53302: CALL_OW 1
53306: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53307: LD_ADDR_EXP 55
53311: PUSH
53312: LD_EXP 55
53316: PPUSH
53317: LD_VAR 0 1
53321: PPUSH
53322: EMPTY
53323: PPUSH
53324: CALL_OW 1
53328: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53329: LD_ADDR_EXP 56
53333: PUSH
53334: LD_EXP 56
53338: PPUSH
53339: LD_VAR 0 1
53343: PPUSH
53344: EMPTY
53345: PPUSH
53346: CALL_OW 1
53350: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53351: LD_ADDR_EXP 57
53355: PUSH
53356: LD_EXP 57
53360: PPUSH
53361: LD_VAR 0 1
53365: PPUSH
53366: EMPTY
53367: PPUSH
53368: CALL_OW 1
53372: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53373: LD_ADDR_EXP 58
53377: PUSH
53378: LD_EXP 58
53382: PPUSH
53383: LD_VAR 0 1
53387: PPUSH
53388: EMPTY
53389: PPUSH
53390: CALL_OW 1
53394: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53395: LD_ADDR_EXP 59
53399: PUSH
53400: LD_EXP 59
53404: PPUSH
53405: LD_VAR 0 1
53409: PPUSH
53410: EMPTY
53411: PPUSH
53412: CALL_OW 1
53416: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53417: LD_ADDR_EXP 60
53421: PUSH
53422: LD_EXP 60
53426: PPUSH
53427: LD_VAR 0 1
53431: PPUSH
53432: EMPTY
53433: PPUSH
53434: CALL_OW 1
53438: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53439: LD_ADDR_EXP 61
53443: PUSH
53444: LD_EXP 61
53448: PPUSH
53449: LD_VAR 0 1
53453: PPUSH
53454: EMPTY
53455: PPUSH
53456: CALL_OW 1
53460: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53461: LD_ADDR_EXP 62
53465: PUSH
53466: LD_EXP 62
53470: PPUSH
53471: LD_VAR 0 1
53475: PPUSH
53476: EMPTY
53477: PPUSH
53478: CALL_OW 1
53482: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53483: LD_ADDR_EXP 63
53487: PUSH
53488: LD_EXP 63
53492: PPUSH
53493: LD_VAR 0 1
53497: PPUSH
53498: EMPTY
53499: PPUSH
53500: CALL_OW 1
53504: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53505: LD_ADDR_EXP 64
53509: PUSH
53510: LD_EXP 64
53514: PPUSH
53515: LD_VAR 0 1
53519: PPUSH
53520: EMPTY
53521: PPUSH
53522: CALL_OW 1
53526: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53527: LD_ADDR_EXP 65
53531: PUSH
53532: LD_EXP 65
53536: PPUSH
53537: LD_VAR 0 1
53541: PPUSH
53542: LD_INT 0
53544: PPUSH
53545: CALL_OW 1
53549: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53550: LD_ADDR_EXP 66
53554: PUSH
53555: LD_EXP 66
53559: PPUSH
53560: LD_VAR 0 1
53564: PPUSH
53565: LD_INT 0
53567: PPUSH
53568: CALL_OW 1
53572: ST_TO_ADDR
// end ;
53573: LD_VAR 0 2
53577: RET
// export function MC_Add ( side , units ) ; var base ; begin
53578: LD_INT 0
53580: PPUSH
53581: PPUSH
// base := mc_bases + 1 ;
53582: LD_ADDR_VAR 0 4
53586: PUSH
53587: LD_EXP 23
53591: PUSH
53592: LD_INT 1
53594: PLUS
53595: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53596: LD_ADDR_EXP 49
53600: PUSH
53601: LD_EXP 49
53605: PPUSH
53606: LD_VAR 0 4
53610: PPUSH
53611: LD_VAR 0 1
53615: PPUSH
53616: CALL_OW 1
53620: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53621: LD_ADDR_EXP 23
53625: PUSH
53626: LD_EXP 23
53630: PPUSH
53631: LD_VAR 0 4
53635: PPUSH
53636: LD_VAR 0 2
53640: PPUSH
53641: CALL_OW 1
53645: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53646: LD_ADDR_EXP 24
53650: PUSH
53651: LD_EXP 24
53655: PPUSH
53656: LD_VAR 0 4
53660: PPUSH
53661: EMPTY
53662: PPUSH
53663: CALL_OW 1
53667: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53668: LD_ADDR_EXP 25
53672: PUSH
53673: LD_EXP 25
53677: PPUSH
53678: LD_VAR 0 4
53682: PPUSH
53683: EMPTY
53684: PPUSH
53685: CALL_OW 1
53689: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53690: LD_ADDR_EXP 26
53694: PUSH
53695: LD_EXP 26
53699: PPUSH
53700: LD_VAR 0 4
53704: PPUSH
53705: EMPTY
53706: PPUSH
53707: CALL_OW 1
53711: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53712: LD_ADDR_EXP 27
53716: PUSH
53717: LD_EXP 27
53721: PPUSH
53722: LD_VAR 0 4
53726: PPUSH
53727: EMPTY
53728: PPUSH
53729: CALL_OW 1
53733: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53734: LD_ADDR_EXP 28
53738: PUSH
53739: LD_EXP 28
53743: PPUSH
53744: LD_VAR 0 4
53748: PPUSH
53749: EMPTY
53750: PPUSH
53751: CALL_OW 1
53755: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53756: LD_ADDR_EXP 29
53760: PUSH
53761: LD_EXP 29
53765: PPUSH
53766: LD_VAR 0 4
53770: PPUSH
53771: EMPTY
53772: PPUSH
53773: CALL_OW 1
53777: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53778: LD_ADDR_EXP 30
53782: PUSH
53783: LD_EXP 30
53787: PPUSH
53788: LD_VAR 0 4
53792: PPUSH
53793: EMPTY
53794: PPUSH
53795: CALL_OW 1
53799: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53800: LD_ADDR_EXP 31
53804: PUSH
53805: LD_EXP 31
53809: PPUSH
53810: LD_VAR 0 4
53814: PPUSH
53815: EMPTY
53816: PPUSH
53817: CALL_OW 1
53821: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53822: LD_ADDR_EXP 32
53826: PUSH
53827: LD_EXP 32
53831: PPUSH
53832: LD_VAR 0 4
53836: PPUSH
53837: EMPTY
53838: PPUSH
53839: CALL_OW 1
53843: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53844: LD_ADDR_EXP 33
53848: PUSH
53849: LD_EXP 33
53853: PPUSH
53854: LD_VAR 0 4
53858: PPUSH
53859: EMPTY
53860: PPUSH
53861: CALL_OW 1
53865: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53866: LD_ADDR_EXP 34
53870: PUSH
53871: LD_EXP 34
53875: PPUSH
53876: LD_VAR 0 4
53880: PPUSH
53881: LD_INT 0
53883: PPUSH
53884: CALL_OW 1
53888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53889: LD_ADDR_EXP 35
53893: PUSH
53894: LD_EXP 35
53898: PPUSH
53899: LD_VAR 0 4
53903: PPUSH
53904: EMPTY
53905: PPUSH
53906: CALL_OW 1
53910: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53911: LD_ADDR_EXP 36
53915: PUSH
53916: LD_EXP 36
53920: PPUSH
53921: LD_VAR 0 4
53925: PPUSH
53926: EMPTY
53927: PPUSH
53928: CALL_OW 1
53932: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53933: LD_ADDR_EXP 37
53937: PUSH
53938: LD_EXP 37
53942: PPUSH
53943: LD_VAR 0 4
53947: PPUSH
53948: EMPTY
53949: PPUSH
53950: CALL_OW 1
53954: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53955: LD_ADDR_EXP 38
53959: PUSH
53960: LD_EXP 38
53964: PPUSH
53965: LD_VAR 0 4
53969: PPUSH
53970: EMPTY
53971: PPUSH
53972: CALL_OW 1
53976: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53977: LD_ADDR_EXP 39
53981: PUSH
53982: LD_EXP 39
53986: PPUSH
53987: LD_VAR 0 4
53991: PPUSH
53992: EMPTY
53993: PPUSH
53994: CALL_OW 1
53998: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53999: LD_ADDR_EXP 40
54003: PUSH
54004: LD_EXP 40
54008: PPUSH
54009: LD_VAR 0 4
54013: PPUSH
54014: EMPTY
54015: PPUSH
54016: CALL_OW 1
54020: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
54021: LD_ADDR_EXP 41
54025: PUSH
54026: LD_EXP 41
54030: PPUSH
54031: LD_VAR 0 4
54035: PPUSH
54036: EMPTY
54037: PPUSH
54038: CALL_OW 1
54042: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
54043: LD_ADDR_EXP 42
54047: PUSH
54048: LD_EXP 42
54052: PPUSH
54053: LD_VAR 0 4
54057: PPUSH
54058: EMPTY
54059: PPUSH
54060: CALL_OW 1
54064: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
54065: LD_ADDR_EXP 43
54069: PUSH
54070: LD_EXP 43
54074: PPUSH
54075: LD_VAR 0 4
54079: PPUSH
54080: EMPTY
54081: PPUSH
54082: CALL_OW 1
54086: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
54087: LD_ADDR_EXP 44
54091: PUSH
54092: LD_EXP 44
54096: PPUSH
54097: LD_VAR 0 4
54101: PPUSH
54102: EMPTY
54103: PPUSH
54104: CALL_OW 1
54108: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
54109: LD_ADDR_EXP 45
54113: PUSH
54114: LD_EXP 45
54118: PPUSH
54119: LD_VAR 0 4
54123: PPUSH
54124: EMPTY
54125: PPUSH
54126: CALL_OW 1
54130: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
54131: LD_ADDR_EXP 46
54135: PUSH
54136: LD_EXP 46
54140: PPUSH
54141: LD_VAR 0 4
54145: PPUSH
54146: EMPTY
54147: PPUSH
54148: CALL_OW 1
54152: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
54153: LD_ADDR_EXP 47
54157: PUSH
54158: LD_EXP 47
54162: PPUSH
54163: LD_VAR 0 4
54167: PPUSH
54168: EMPTY
54169: PPUSH
54170: CALL_OW 1
54174: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
54175: LD_ADDR_EXP 48
54179: PUSH
54180: LD_EXP 48
54184: PPUSH
54185: LD_VAR 0 4
54189: PPUSH
54190: EMPTY
54191: PPUSH
54192: CALL_OW 1
54196: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
54197: LD_ADDR_EXP 50
54201: PUSH
54202: LD_EXP 50
54206: PPUSH
54207: LD_VAR 0 4
54211: PPUSH
54212: EMPTY
54213: PPUSH
54214: CALL_OW 1
54218: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
54219: LD_ADDR_EXP 52
54223: PUSH
54224: LD_EXP 52
54228: PPUSH
54229: LD_VAR 0 4
54233: PPUSH
54234: EMPTY
54235: PPUSH
54236: CALL_OW 1
54240: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
54241: LD_ADDR_EXP 53
54245: PUSH
54246: LD_EXP 53
54250: PPUSH
54251: LD_VAR 0 4
54255: PPUSH
54256: EMPTY
54257: PPUSH
54258: CALL_OW 1
54262: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
54263: LD_ADDR_EXP 54
54267: PUSH
54268: LD_EXP 54
54272: PPUSH
54273: LD_VAR 0 4
54277: PPUSH
54278: EMPTY
54279: PPUSH
54280: CALL_OW 1
54284: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
54285: LD_ADDR_EXP 55
54289: PUSH
54290: LD_EXP 55
54294: PPUSH
54295: LD_VAR 0 4
54299: PPUSH
54300: EMPTY
54301: PPUSH
54302: CALL_OW 1
54306: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
54307: LD_ADDR_EXP 56
54311: PUSH
54312: LD_EXP 56
54316: PPUSH
54317: LD_VAR 0 4
54321: PPUSH
54322: EMPTY
54323: PPUSH
54324: CALL_OW 1
54328: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
54329: LD_ADDR_EXP 57
54333: PUSH
54334: LD_EXP 57
54338: PPUSH
54339: LD_VAR 0 4
54343: PPUSH
54344: EMPTY
54345: PPUSH
54346: CALL_OW 1
54350: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
54351: LD_ADDR_EXP 58
54355: PUSH
54356: LD_EXP 58
54360: PPUSH
54361: LD_VAR 0 4
54365: PPUSH
54366: EMPTY
54367: PPUSH
54368: CALL_OW 1
54372: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
54373: LD_ADDR_EXP 59
54377: PUSH
54378: LD_EXP 59
54382: PPUSH
54383: LD_VAR 0 4
54387: PPUSH
54388: EMPTY
54389: PPUSH
54390: CALL_OW 1
54394: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54395: LD_ADDR_EXP 60
54399: PUSH
54400: LD_EXP 60
54404: PPUSH
54405: LD_VAR 0 4
54409: PPUSH
54410: EMPTY
54411: PPUSH
54412: CALL_OW 1
54416: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54417: LD_ADDR_EXP 61
54421: PUSH
54422: LD_EXP 61
54426: PPUSH
54427: LD_VAR 0 4
54431: PPUSH
54432: EMPTY
54433: PPUSH
54434: CALL_OW 1
54438: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54439: LD_ADDR_EXP 62
54443: PUSH
54444: LD_EXP 62
54448: PPUSH
54449: LD_VAR 0 4
54453: PPUSH
54454: EMPTY
54455: PPUSH
54456: CALL_OW 1
54460: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54461: LD_ADDR_EXP 63
54465: PUSH
54466: LD_EXP 63
54470: PPUSH
54471: LD_VAR 0 4
54475: PPUSH
54476: EMPTY
54477: PPUSH
54478: CALL_OW 1
54482: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54483: LD_ADDR_EXP 64
54487: PUSH
54488: LD_EXP 64
54492: PPUSH
54493: LD_VAR 0 4
54497: PPUSH
54498: EMPTY
54499: PPUSH
54500: CALL_OW 1
54504: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54505: LD_ADDR_EXP 65
54509: PUSH
54510: LD_EXP 65
54514: PPUSH
54515: LD_VAR 0 4
54519: PPUSH
54520: LD_INT 0
54522: PPUSH
54523: CALL_OW 1
54527: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54528: LD_ADDR_EXP 66
54532: PUSH
54533: LD_EXP 66
54537: PPUSH
54538: LD_VAR 0 4
54542: PPUSH
54543: LD_INT 0
54545: PPUSH
54546: CALL_OW 1
54550: ST_TO_ADDR
// result := base ;
54551: LD_ADDR_VAR 0 3
54555: PUSH
54556: LD_VAR 0 4
54560: ST_TO_ADDR
// end ;
54561: LD_VAR 0 3
54565: RET
// export function MC_Start ( ) ; var i ; begin
54566: LD_INT 0
54568: PPUSH
54569: PPUSH
// for i = 1 to mc_bases do
54570: LD_ADDR_VAR 0 2
54574: PUSH
54575: DOUBLE
54576: LD_INT 1
54578: DEC
54579: ST_TO_ADDR
54580: LD_EXP 23
54584: PUSH
54585: FOR_TO
54586: IFFALSE 55686
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54588: LD_ADDR_EXP 23
54592: PUSH
54593: LD_EXP 23
54597: PPUSH
54598: LD_VAR 0 2
54602: PPUSH
54603: LD_EXP 23
54607: PUSH
54608: LD_VAR 0 2
54612: ARRAY
54613: PUSH
54614: LD_INT 0
54616: DIFF
54617: PPUSH
54618: CALL_OW 1
54622: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54623: LD_ADDR_EXP 24
54627: PUSH
54628: LD_EXP 24
54632: PPUSH
54633: LD_VAR 0 2
54637: PPUSH
54638: EMPTY
54639: PPUSH
54640: CALL_OW 1
54644: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54645: LD_ADDR_EXP 25
54649: PUSH
54650: LD_EXP 25
54654: PPUSH
54655: LD_VAR 0 2
54659: PPUSH
54660: EMPTY
54661: PPUSH
54662: CALL_OW 1
54666: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54667: LD_ADDR_EXP 26
54671: PUSH
54672: LD_EXP 26
54676: PPUSH
54677: LD_VAR 0 2
54681: PPUSH
54682: EMPTY
54683: PPUSH
54684: CALL_OW 1
54688: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54689: LD_ADDR_EXP 27
54693: PUSH
54694: LD_EXP 27
54698: PPUSH
54699: LD_VAR 0 2
54703: PPUSH
54704: EMPTY
54705: PUSH
54706: EMPTY
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: PPUSH
54712: CALL_OW 1
54716: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54717: LD_ADDR_EXP 28
54721: PUSH
54722: LD_EXP 28
54726: PPUSH
54727: LD_VAR 0 2
54731: PPUSH
54732: EMPTY
54733: PPUSH
54734: CALL_OW 1
54738: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54739: LD_ADDR_EXP 55
54743: PUSH
54744: LD_EXP 55
54748: PPUSH
54749: LD_VAR 0 2
54753: PPUSH
54754: EMPTY
54755: PPUSH
54756: CALL_OW 1
54760: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54761: LD_ADDR_EXP 29
54765: PUSH
54766: LD_EXP 29
54770: PPUSH
54771: LD_VAR 0 2
54775: PPUSH
54776: EMPTY
54777: PPUSH
54778: CALL_OW 1
54782: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54783: LD_ADDR_EXP 30
54787: PUSH
54788: LD_EXP 30
54792: PPUSH
54793: LD_VAR 0 2
54797: PPUSH
54798: EMPTY
54799: PPUSH
54800: CALL_OW 1
54804: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54805: LD_ADDR_EXP 31
54809: PUSH
54810: LD_EXP 31
54814: PPUSH
54815: LD_VAR 0 2
54819: PPUSH
54820: LD_EXP 23
54824: PUSH
54825: LD_VAR 0 2
54829: ARRAY
54830: PPUSH
54831: LD_INT 2
54833: PUSH
54834: LD_INT 30
54836: PUSH
54837: LD_INT 32
54839: PUSH
54840: EMPTY
54841: LIST
54842: LIST
54843: PUSH
54844: LD_INT 30
54846: PUSH
54847: LD_INT 33
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: PUSH
54854: EMPTY
54855: LIST
54856: LIST
54857: LIST
54858: PPUSH
54859: CALL_OW 72
54863: PPUSH
54864: CALL_OW 1
54868: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54869: LD_ADDR_EXP 32
54873: PUSH
54874: LD_EXP 32
54878: PPUSH
54879: LD_VAR 0 2
54883: PPUSH
54884: LD_EXP 23
54888: PUSH
54889: LD_VAR 0 2
54893: ARRAY
54894: PPUSH
54895: LD_INT 2
54897: PUSH
54898: LD_INT 30
54900: PUSH
54901: LD_INT 32
54903: PUSH
54904: EMPTY
54905: LIST
54906: LIST
54907: PUSH
54908: LD_INT 30
54910: PUSH
54911: LD_INT 31
54913: PUSH
54914: EMPTY
54915: LIST
54916: LIST
54917: PUSH
54918: EMPTY
54919: LIST
54920: LIST
54921: LIST
54922: PUSH
54923: LD_INT 58
54925: PUSH
54926: EMPTY
54927: LIST
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: PPUSH
54933: CALL_OW 72
54937: PPUSH
54938: CALL_OW 1
54942: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54943: LD_ADDR_EXP 33
54947: PUSH
54948: LD_EXP 33
54952: PPUSH
54953: LD_VAR 0 2
54957: PPUSH
54958: EMPTY
54959: PPUSH
54960: CALL_OW 1
54964: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54965: LD_ADDR_EXP 37
54969: PUSH
54970: LD_EXP 37
54974: PPUSH
54975: LD_VAR 0 2
54979: PPUSH
54980: EMPTY
54981: PPUSH
54982: CALL_OW 1
54986: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54987: LD_ADDR_EXP 36
54991: PUSH
54992: LD_EXP 36
54996: PPUSH
54997: LD_VAR 0 2
55001: PPUSH
55002: EMPTY
55003: PPUSH
55004: CALL_OW 1
55008: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
55009: LD_ADDR_EXP 38
55013: PUSH
55014: LD_EXP 38
55018: PPUSH
55019: LD_VAR 0 2
55023: PPUSH
55024: EMPTY
55025: PPUSH
55026: CALL_OW 1
55030: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
55031: LD_ADDR_EXP 39
55035: PUSH
55036: LD_EXP 39
55040: PPUSH
55041: LD_VAR 0 2
55045: PPUSH
55046: EMPTY
55047: PPUSH
55048: CALL_OW 1
55052: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55053: LD_ADDR_EXP 40
55057: PUSH
55058: LD_EXP 40
55062: PPUSH
55063: LD_VAR 0 2
55067: PPUSH
55068: EMPTY
55069: PPUSH
55070: CALL_OW 1
55074: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
55075: LD_ADDR_EXP 41
55079: PUSH
55080: LD_EXP 41
55084: PPUSH
55085: LD_VAR 0 2
55089: PPUSH
55090: EMPTY
55091: PPUSH
55092: CALL_OW 1
55096: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
55097: LD_ADDR_EXP 42
55101: PUSH
55102: LD_EXP 42
55106: PPUSH
55107: LD_VAR 0 2
55111: PPUSH
55112: EMPTY
55113: PPUSH
55114: CALL_OW 1
55118: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55119: LD_ADDR_EXP 43
55123: PUSH
55124: LD_EXP 43
55128: PPUSH
55129: LD_VAR 0 2
55133: PPUSH
55134: EMPTY
55135: PPUSH
55136: CALL_OW 1
55140: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
55141: LD_ADDR_EXP 44
55145: PUSH
55146: LD_EXP 44
55150: PPUSH
55151: LD_VAR 0 2
55155: PPUSH
55156: EMPTY
55157: PPUSH
55158: CALL_OW 1
55162: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
55163: LD_ADDR_EXP 45
55167: PUSH
55168: LD_EXP 45
55172: PPUSH
55173: LD_VAR 0 2
55177: PPUSH
55178: EMPTY
55179: PPUSH
55180: CALL_OW 1
55184: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
55185: LD_ADDR_EXP 34
55189: PUSH
55190: LD_EXP 34
55194: PPUSH
55195: LD_VAR 0 2
55199: PPUSH
55200: LD_INT 0
55202: PPUSH
55203: CALL_OW 1
55207: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
55208: LD_ADDR_EXP 47
55212: PUSH
55213: LD_EXP 47
55217: PPUSH
55218: LD_VAR 0 2
55222: PPUSH
55223: LD_INT 0
55225: PPUSH
55226: CALL_OW 1
55230: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
55231: LD_ADDR_EXP 35
55235: PUSH
55236: LD_EXP 35
55240: PPUSH
55241: LD_VAR 0 2
55245: PPUSH
55246: EMPTY
55247: PPUSH
55248: CALL_OW 1
55252: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
55253: LD_ADDR_EXP 46
55257: PUSH
55258: LD_EXP 46
55262: PPUSH
55263: LD_VAR 0 2
55267: PPUSH
55268: LD_INT 0
55270: PPUSH
55271: CALL_OW 1
55275: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
55276: LD_ADDR_EXP 48
55280: PUSH
55281: LD_EXP 48
55285: PPUSH
55286: LD_VAR 0 2
55290: PPUSH
55291: EMPTY
55292: PPUSH
55293: CALL_OW 1
55297: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
55298: LD_ADDR_EXP 51
55302: PUSH
55303: LD_EXP 51
55307: PPUSH
55308: LD_VAR 0 2
55312: PPUSH
55313: LD_INT 0
55315: PPUSH
55316: CALL_OW 1
55320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
55321: LD_ADDR_EXP 52
55325: PUSH
55326: LD_EXP 52
55330: PPUSH
55331: LD_VAR 0 2
55335: PPUSH
55336: EMPTY
55337: PPUSH
55338: CALL_OW 1
55342: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
55343: LD_ADDR_EXP 53
55347: PUSH
55348: LD_EXP 53
55352: PPUSH
55353: LD_VAR 0 2
55357: PPUSH
55358: EMPTY
55359: PPUSH
55360: CALL_OW 1
55364: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
55365: LD_ADDR_EXP 54
55369: PUSH
55370: LD_EXP 54
55374: PPUSH
55375: LD_VAR 0 2
55379: PPUSH
55380: EMPTY
55381: PPUSH
55382: CALL_OW 1
55386: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55387: LD_ADDR_EXP 56
55391: PUSH
55392: LD_EXP 56
55396: PPUSH
55397: LD_VAR 0 2
55401: PPUSH
55402: LD_EXP 23
55406: PUSH
55407: LD_VAR 0 2
55411: ARRAY
55412: PPUSH
55413: LD_INT 2
55415: PUSH
55416: LD_INT 30
55418: PUSH
55419: LD_INT 6
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PUSH
55426: LD_INT 30
55428: PUSH
55429: LD_INT 7
55431: PUSH
55432: EMPTY
55433: LIST
55434: LIST
55435: PUSH
55436: LD_INT 30
55438: PUSH
55439: LD_INT 8
55441: PUSH
55442: EMPTY
55443: LIST
55444: LIST
55445: PUSH
55446: EMPTY
55447: LIST
55448: LIST
55449: LIST
55450: LIST
55451: PPUSH
55452: CALL_OW 72
55456: PPUSH
55457: CALL_OW 1
55461: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55462: LD_ADDR_EXP 57
55466: PUSH
55467: LD_EXP 57
55471: PPUSH
55472: LD_VAR 0 2
55476: PPUSH
55477: EMPTY
55478: PPUSH
55479: CALL_OW 1
55483: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55484: LD_ADDR_EXP 58
55488: PUSH
55489: LD_EXP 58
55493: PPUSH
55494: LD_VAR 0 2
55498: PPUSH
55499: EMPTY
55500: PPUSH
55501: CALL_OW 1
55505: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55506: LD_ADDR_EXP 59
55510: PUSH
55511: LD_EXP 59
55515: PPUSH
55516: LD_VAR 0 2
55520: PPUSH
55521: EMPTY
55522: PPUSH
55523: CALL_OW 1
55527: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55528: LD_ADDR_EXP 60
55532: PUSH
55533: LD_EXP 60
55537: PPUSH
55538: LD_VAR 0 2
55542: PPUSH
55543: EMPTY
55544: PPUSH
55545: CALL_OW 1
55549: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55550: LD_ADDR_EXP 61
55554: PUSH
55555: LD_EXP 61
55559: PPUSH
55560: LD_VAR 0 2
55564: PPUSH
55565: EMPTY
55566: PPUSH
55567: CALL_OW 1
55571: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55572: LD_ADDR_EXP 62
55576: PUSH
55577: LD_EXP 62
55581: PPUSH
55582: LD_VAR 0 2
55586: PPUSH
55587: EMPTY
55588: PPUSH
55589: CALL_OW 1
55593: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55594: LD_ADDR_EXP 63
55598: PUSH
55599: LD_EXP 63
55603: PPUSH
55604: LD_VAR 0 2
55608: PPUSH
55609: EMPTY
55610: PPUSH
55611: CALL_OW 1
55615: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55616: LD_ADDR_EXP 64
55620: PUSH
55621: LD_EXP 64
55625: PPUSH
55626: LD_VAR 0 2
55630: PPUSH
55631: EMPTY
55632: PPUSH
55633: CALL_OW 1
55637: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55638: LD_ADDR_EXP 65
55642: PUSH
55643: LD_EXP 65
55647: PPUSH
55648: LD_VAR 0 2
55652: PPUSH
55653: LD_INT 0
55655: PPUSH
55656: CALL_OW 1
55660: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
55661: LD_ADDR_EXP 66
55665: PUSH
55666: LD_EXP 66
55670: PPUSH
55671: LD_VAR 0 2
55675: PPUSH
55676: LD_INT 0
55678: PPUSH
55679: CALL_OW 1
55683: ST_TO_ADDR
// end ;
55684: GO 54585
55686: POP
55687: POP
// MC_InitSides ( ) ;
55688: CALL 55974 0 0
// MC_InitResearch ( ) ;
55692: CALL 55713 0 0
// CustomInitMacro ( ) ;
55696: CALL 269 0 0
// skirmish := true ;
55700: LD_ADDR_EXP 21
55704: PUSH
55705: LD_INT 1
55707: ST_TO_ADDR
// end ;
55708: LD_VAR 0 1
55712: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55713: LD_INT 0
55715: PPUSH
55716: PPUSH
55717: PPUSH
55718: PPUSH
55719: PPUSH
55720: PPUSH
// if not mc_bases then
55721: LD_EXP 23
55725: NOT
55726: IFFALSE 55730
// exit ;
55728: GO 55969
// for i = 1 to 8 do
55730: LD_ADDR_VAR 0 2
55734: PUSH
55735: DOUBLE
55736: LD_INT 1
55738: DEC
55739: ST_TO_ADDR
55740: LD_INT 8
55742: PUSH
55743: FOR_TO
55744: IFFALSE 55770
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55746: LD_ADDR_EXP 50
55750: PUSH
55751: LD_EXP 50
55755: PPUSH
55756: LD_VAR 0 2
55760: PPUSH
55761: EMPTY
55762: PPUSH
55763: CALL_OW 1
55767: ST_TO_ADDR
55768: GO 55743
55770: POP
55771: POP
// tmp := [ ] ;
55772: LD_ADDR_VAR 0 5
55776: PUSH
55777: EMPTY
55778: ST_TO_ADDR
// for i = 1 to mc_sides do
55779: LD_ADDR_VAR 0 2
55783: PUSH
55784: DOUBLE
55785: LD_INT 1
55787: DEC
55788: ST_TO_ADDR
55789: LD_EXP 49
55793: PUSH
55794: FOR_TO
55795: IFFALSE 55853
// if not mc_sides [ i ] in tmp then
55797: LD_EXP 49
55801: PUSH
55802: LD_VAR 0 2
55806: ARRAY
55807: PUSH
55808: LD_VAR 0 5
55812: IN
55813: NOT
55814: IFFALSE 55851
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55816: LD_ADDR_VAR 0 5
55820: PUSH
55821: LD_VAR 0 5
55825: PPUSH
55826: LD_VAR 0 5
55830: PUSH
55831: LD_INT 1
55833: PLUS
55834: PPUSH
55835: LD_EXP 49
55839: PUSH
55840: LD_VAR 0 2
55844: ARRAY
55845: PPUSH
55846: CALL_OW 2
55850: ST_TO_ADDR
55851: GO 55794
55853: POP
55854: POP
// if not tmp then
55855: LD_VAR 0 5
55859: NOT
55860: IFFALSE 55864
// exit ;
55862: GO 55969
// for j in tmp do
55864: LD_ADDR_VAR 0 3
55868: PUSH
55869: LD_VAR 0 5
55873: PUSH
55874: FOR_IN
55875: IFFALSE 55967
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55877: LD_ADDR_VAR 0 6
55881: PUSH
55882: LD_INT 22
55884: PUSH
55885: LD_VAR 0 3
55889: PUSH
55890: EMPTY
55891: LIST
55892: LIST
55893: PPUSH
55894: CALL_OW 69
55898: ST_TO_ADDR
// if not un then
55899: LD_VAR 0 6
55903: NOT
55904: IFFALSE 55908
// continue ;
55906: GO 55874
// nation := GetNation ( un [ 1 ] ) ;
55908: LD_ADDR_VAR 0 4
55912: PUSH
55913: LD_VAR 0 6
55917: PUSH
55918: LD_INT 1
55920: ARRAY
55921: PPUSH
55922: CALL_OW 248
55926: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55927: LD_ADDR_EXP 50
55931: PUSH
55932: LD_EXP 50
55936: PPUSH
55937: LD_VAR 0 3
55941: PPUSH
55942: LD_VAR 0 3
55946: PPUSH
55947: LD_VAR 0 4
55951: PPUSH
55952: LD_INT 1
55954: PPUSH
55955: CALL 11036 0 3
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// end ;
55965: GO 55874
55967: POP
55968: POP
// end ;
55969: LD_VAR 0 1
55973: RET
// export function MC_InitSides ( ) ; var i ; begin
55974: LD_INT 0
55976: PPUSH
55977: PPUSH
// if not mc_bases then
55978: LD_EXP 23
55982: NOT
55983: IFFALSE 55987
// exit ;
55985: GO 56061
// for i = 1 to mc_bases do
55987: LD_ADDR_VAR 0 2
55991: PUSH
55992: DOUBLE
55993: LD_INT 1
55995: DEC
55996: ST_TO_ADDR
55997: LD_EXP 23
56001: PUSH
56002: FOR_TO
56003: IFFALSE 56059
// if mc_bases [ i ] then
56005: LD_EXP 23
56009: PUSH
56010: LD_VAR 0 2
56014: ARRAY
56015: IFFALSE 56057
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
56017: LD_ADDR_EXP 49
56021: PUSH
56022: LD_EXP 49
56026: PPUSH
56027: LD_VAR 0 2
56031: PPUSH
56032: LD_EXP 23
56036: PUSH
56037: LD_VAR 0 2
56041: ARRAY
56042: PUSH
56043: LD_INT 1
56045: ARRAY
56046: PPUSH
56047: CALL_OW 255
56051: PPUSH
56052: CALL_OW 1
56056: ST_TO_ADDR
56057: GO 56002
56059: POP
56060: POP
// end ;
56061: LD_VAR 0 1
56065: RET
// every 0 0$03 trigger skirmish do
56066: LD_EXP 21
56070: IFFALSE 56224
56072: GO 56074
56074: DISABLE
// begin enable ;
56075: ENABLE
// MC_CheckBuildings ( ) ;
56076: CALL 60722 0 0
// MC_CheckPeopleLife ( ) ;
56080: CALL 60883 0 0
// RaiseSailEvent ( 100 ) ;
56084: LD_INT 100
56086: PPUSH
56087: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
56091: LD_INT 103
56093: PPUSH
56094: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
56098: LD_INT 104
56100: PPUSH
56101: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
56105: LD_INT 105
56107: PPUSH
56108: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
56112: LD_INT 106
56114: PPUSH
56115: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
56119: LD_INT 107
56121: PPUSH
56122: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
56126: LD_INT 108
56128: PPUSH
56129: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
56133: LD_INT 109
56135: PPUSH
56136: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
56140: LD_INT 110
56142: PPUSH
56143: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
56147: LD_INT 111
56149: PPUSH
56150: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
56154: LD_INT 112
56156: PPUSH
56157: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
56161: LD_INT 113
56163: PPUSH
56164: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
56168: LD_INT 120
56170: PPUSH
56171: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
56175: LD_INT 121
56177: PPUSH
56178: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
56182: LD_INT 122
56184: PPUSH
56185: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
56189: LD_INT 123
56191: PPUSH
56192: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
56196: LD_INT 124
56198: PPUSH
56199: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
56203: LD_INT 125
56205: PPUSH
56206: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
56210: LD_INT 126
56212: PPUSH
56213: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
56217: LD_INT 200
56219: PPUSH
56220: CALL_OW 427
// end ;
56224: END
// on SailEvent ( event ) do begin if event < 100 then
56225: LD_VAR 0 1
56229: PUSH
56230: LD_INT 100
56232: LESS
56233: IFFALSE 56244
// CustomEvent ( event ) ;
56235: LD_VAR 0 1
56239: PPUSH
56240: CALL 10187 0 1
// if event = 100 then
56244: LD_VAR 0 1
56248: PUSH
56249: LD_INT 100
56251: EQUAL
56252: IFFALSE 56258
// MC_ClassManager ( ) ;
56254: CALL 56650 0 0
// if event = 101 then
56258: LD_VAR 0 1
56262: PUSH
56263: LD_INT 101
56265: EQUAL
56266: IFFALSE 56272
// MC_RepairBuildings ( ) ;
56268: CALL 61468 0 0
// if event = 102 then
56272: LD_VAR 0 1
56276: PUSH
56277: LD_INT 102
56279: EQUAL
56280: IFFALSE 56286
// MC_Heal ( ) ;
56282: CALL 62403 0 0
// if event = 103 then
56286: LD_VAR 0 1
56290: PUSH
56291: LD_INT 103
56293: EQUAL
56294: IFFALSE 56300
// MC_Build ( ) ;
56296: CALL 62825 0 0
// if event = 104 then
56300: LD_VAR 0 1
56304: PUSH
56305: LD_INT 104
56307: EQUAL
56308: IFFALSE 56314
// MC_TurretWeapon ( ) ;
56310: CALL 64459 0 0
// if event = 105 then
56314: LD_VAR 0 1
56318: PUSH
56319: LD_INT 105
56321: EQUAL
56322: IFFALSE 56328
// MC_BuildUpgrade ( ) ;
56324: CALL 64010 0 0
// if event = 106 then
56328: LD_VAR 0 1
56332: PUSH
56333: LD_INT 106
56335: EQUAL
56336: IFFALSE 56342
// MC_PlantMines ( ) ;
56338: CALL 64889 0 0
// if event = 107 then
56342: LD_VAR 0 1
56346: PUSH
56347: LD_INT 107
56349: EQUAL
56350: IFFALSE 56356
// MC_CollectCrates ( ) ;
56352: CALL 65680 0 0
// if event = 108 then
56356: LD_VAR 0 1
56360: PUSH
56361: LD_INT 108
56363: EQUAL
56364: IFFALSE 56370
// MC_LinkRemoteControl ( ) ;
56366: CALL 67530 0 0
// if event = 109 then
56370: LD_VAR 0 1
56374: PUSH
56375: LD_INT 109
56377: EQUAL
56378: IFFALSE 56384
// MC_ProduceVehicle ( ) ;
56380: CALL 67711 0 0
// if event = 110 then
56384: LD_VAR 0 1
56388: PUSH
56389: LD_INT 110
56391: EQUAL
56392: IFFALSE 56398
// MC_SendAttack ( ) ;
56394: CALL 68177 0 0
// if event = 111 then
56398: LD_VAR 0 1
56402: PUSH
56403: LD_INT 111
56405: EQUAL
56406: IFFALSE 56412
// MC_Defend ( ) ;
56408: CALL 68285 0 0
// if event = 112 then
56412: LD_VAR 0 1
56416: PUSH
56417: LD_INT 112
56419: EQUAL
56420: IFFALSE 56426
// MC_Research ( ) ;
56422: CALL 69165 0 0
// if event = 113 then
56426: LD_VAR 0 1
56430: PUSH
56431: LD_INT 113
56433: EQUAL
56434: IFFALSE 56440
// MC_MinesTrigger ( ) ;
56436: CALL 70279 0 0
// if event = 120 then
56440: LD_VAR 0 1
56444: PUSH
56445: LD_INT 120
56447: EQUAL
56448: IFFALSE 56454
// MC_RepairVehicle ( ) ;
56450: CALL 70378 0 0
// if event = 121 then
56454: LD_VAR 0 1
56458: PUSH
56459: LD_INT 121
56461: EQUAL
56462: IFFALSE 56468
// MC_TameApe ( ) ;
56464: CALL 71147 0 0
// if event = 122 then
56468: LD_VAR 0 1
56472: PUSH
56473: LD_INT 122
56475: EQUAL
56476: IFFALSE 56482
// MC_ChangeApeClass ( ) ;
56478: CALL 71976 0 0
// if event = 123 then
56482: LD_VAR 0 1
56486: PUSH
56487: LD_INT 123
56489: EQUAL
56490: IFFALSE 56496
// MC_Bazooka ( ) ;
56492: CALL 72626 0 0
// if event = 124 then
56496: LD_VAR 0 1
56500: PUSH
56501: LD_INT 124
56503: EQUAL
56504: IFFALSE 56510
// MC_TeleportExit ( ) ;
56506: CALL 72824 0 0
// if event = 125 then
56510: LD_VAR 0 1
56514: PUSH
56515: LD_INT 125
56517: EQUAL
56518: IFFALSE 56524
// MC_Deposits ( ) ;
56520: CALL 73471 0 0
// if event = 126 then
56524: LD_VAR 0 1
56528: PUSH
56529: LD_INT 126
56531: EQUAL
56532: IFFALSE 56538
// MC_RemoteDriver ( ) ;
56534: CALL 74096 0 0
// if event = 200 then
56538: LD_VAR 0 1
56542: PUSH
56543: LD_INT 200
56545: EQUAL
56546: IFFALSE 56552
// MC_Idle ( ) ;
56548: CALL 76045 0 0
// end ;
56552: PPOPN 1
56554: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56555: LD_INT 0
56557: PPUSH
56558: PPUSH
// if not mc_bases [ base ] or not tag then
56559: LD_EXP 23
56563: PUSH
56564: LD_VAR 0 1
56568: ARRAY
56569: NOT
56570: PUSH
56571: LD_VAR 0 2
56575: NOT
56576: OR
56577: IFFALSE 56581
// exit ;
56579: GO 56645
// for i in mc_bases [ base ] union mc_ape [ base ] do
56581: LD_ADDR_VAR 0 4
56585: PUSH
56586: LD_EXP 23
56590: PUSH
56591: LD_VAR 0 1
56595: ARRAY
56596: PUSH
56597: LD_EXP 52
56601: PUSH
56602: LD_VAR 0 1
56606: ARRAY
56607: UNION
56608: PUSH
56609: FOR_IN
56610: IFFALSE 56643
// if GetTag ( i ) = tag then
56612: LD_VAR 0 4
56616: PPUSH
56617: CALL_OW 110
56621: PUSH
56622: LD_VAR 0 2
56626: EQUAL
56627: IFFALSE 56641
// SetTag ( i , 0 ) ;
56629: LD_VAR 0 4
56633: PPUSH
56634: LD_INT 0
56636: PPUSH
56637: CALL_OW 109
56641: GO 56609
56643: POP
56644: POP
// end ;
56645: LD_VAR 0 3
56649: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56650: LD_INT 0
56652: PPUSH
56653: PPUSH
56654: PPUSH
56655: PPUSH
56656: PPUSH
56657: PPUSH
56658: PPUSH
56659: PPUSH
// if not mc_bases then
56660: LD_EXP 23
56664: NOT
56665: IFFALSE 56669
// exit ;
56667: GO 57127
// for i = 1 to mc_bases do
56669: LD_ADDR_VAR 0 2
56673: PUSH
56674: DOUBLE
56675: LD_INT 1
56677: DEC
56678: ST_TO_ADDR
56679: LD_EXP 23
56683: PUSH
56684: FOR_TO
56685: IFFALSE 57125
// begin tmp := MC_ClassCheckReq ( i ) ;
56687: LD_ADDR_VAR 0 4
56691: PUSH
56692: LD_VAR 0 2
56696: PPUSH
56697: CALL 57132 0 1
56701: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56702: LD_ADDR_EXP 64
56706: PUSH
56707: LD_EXP 64
56711: PPUSH
56712: LD_VAR 0 2
56716: PPUSH
56717: LD_VAR 0 4
56721: PPUSH
56722: CALL_OW 1
56726: ST_TO_ADDR
// if not tmp then
56727: LD_VAR 0 4
56731: NOT
56732: IFFALSE 56736
// continue ;
56734: GO 56684
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56736: LD_ADDR_VAR 0 6
56740: PUSH
56741: LD_EXP 23
56745: PUSH
56746: LD_VAR 0 2
56750: ARRAY
56751: PPUSH
56752: LD_INT 2
56754: PUSH
56755: LD_INT 30
56757: PUSH
56758: LD_INT 4
56760: PUSH
56761: EMPTY
56762: LIST
56763: LIST
56764: PUSH
56765: LD_INT 30
56767: PUSH
56768: LD_INT 5
56770: PUSH
56771: EMPTY
56772: LIST
56773: LIST
56774: PUSH
56775: EMPTY
56776: LIST
56777: LIST
56778: LIST
56779: PPUSH
56780: CALL_OW 72
56784: PUSH
56785: LD_EXP 23
56789: PUSH
56790: LD_VAR 0 2
56794: ARRAY
56795: PPUSH
56796: LD_INT 2
56798: PUSH
56799: LD_INT 30
56801: PUSH
56802: LD_INT 0
56804: PUSH
56805: EMPTY
56806: LIST
56807: LIST
56808: PUSH
56809: LD_INT 30
56811: PUSH
56812: LD_INT 1
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PUSH
56819: EMPTY
56820: LIST
56821: LIST
56822: LIST
56823: PPUSH
56824: CALL_OW 72
56828: PUSH
56829: LD_EXP 23
56833: PUSH
56834: LD_VAR 0 2
56838: ARRAY
56839: PPUSH
56840: LD_INT 30
56842: PUSH
56843: LD_INT 3
56845: PUSH
56846: EMPTY
56847: LIST
56848: LIST
56849: PPUSH
56850: CALL_OW 72
56854: PUSH
56855: LD_EXP 23
56859: PUSH
56860: LD_VAR 0 2
56864: ARRAY
56865: PPUSH
56866: LD_INT 2
56868: PUSH
56869: LD_INT 30
56871: PUSH
56872: LD_INT 6
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: PUSH
56879: LD_INT 30
56881: PUSH
56882: LD_INT 7
56884: PUSH
56885: EMPTY
56886: LIST
56887: LIST
56888: PUSH
56889: LD_INT 30
56891: PUSH
56892: LD_INT 8
56894: PUSH
56895: EMPTY
56896: LIST
56897: LIST
56898: PUSH
56899: EMPTY
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: PPUSH
56905: CALL_OW 72
56909: PUSH
56910: EMPTY
56911: LIST
56912: LIST
56913: LIST
56914: LIST
56915: ST_TO_ADDR
// for j = 1 to 4 do
56916: LD_ADDR_VAR 0 3
56920: PUSH
56921: DOUBLE
56922: LD_INT 1
56924: DEC
56925: ST_TO_ADDR
56926: LD_INT 4
56928: PUSH
56929: FOR_TO
56930: IFFALSE 57121
// begin if not tmp [ j ] then
56932: LD_VAR 0 4
56936: PUSH
56937: LD_VAR 0 3
56941: ARRAY
56942: NOT
56943: IFFALSE 56947
// continue ;
56945: GO 56929
// for p in tmp [ j ] do
56947: LD_ADDR_VAR 0 5
56951: PUSH
56952: LD_VAR 0 4
56956: PUSH
56957: LD_VAR 0 3
56961: ARRAY
56962: PUSH
56963: FOR_IN
56964: IFFALSE 57117
// begin if not b [ j ] then
56966: LD_VAR 0 6
56970: PUSH
56971: LD_VAR 0 3
56975: ARRAY
56976: NOT
56977: IFFALSE 56981
// break ;
56979: GO 57117
// e := 0 ;
56981: LD_ADDR_VAR 0 7
56985: PUSH
56986: LD_INT 0
56988: ST_TO_ADDR
// for k in b [ j ] do
56989: LD_ADDR_VAR 0 8
56993: PUSH
56994: LD_VAR 0 6
56998: PUSH
56999: LD_VAR 0 3
57003: ARRAY
57004: PUSH
57005: FOR_IN
57006: IFFALSE 57033
// if IsNotFull ( k ) then
57008: LD_VAR 0 8
57012: PPUSH
57013: CALL 13189 0 1
57017: IFFALSE 57031
// begin e := k ;
57019: LD_ADDR_VAR 0 7
57023: PUSH
57024: LD_VAR 0 8
57028: ST_TO_ADDR
// break ;
57029: GO 57033
// end ;
57031: GO 57005
57033: POP
57034: POP
// if e and not UnitGoingToBuilding ( p , e ) then
57035: LD_VAR 0 7
57039: PUSH
57040: LD_VAR 0 5
57044: PPUSH
57045: LD_VAR 0 7
57049: PPUSH
57050: CALL 47085 0 2
57054: NOT
57055: AND
57056: IFFALSE 57115
// begin if IsInUnit ( p ) then
57058: LD_VAR 0 5
57062: PPUSH
57063: CALL_OW 310
57067: IFFALSE 57078
// ComExitBuilding ( p ) ;
57069: LD_VAR 0 5
57073: PPUSH
57074: CALL_OW 122
// ComEnterUnit ( p , e ) ;
57078: LD_VAR 0 5
57082: PPUSH
57083: LD_VAR 0 7
57087: PPUSH
57088: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
57092: LD_VAR 0 5
57096: PPUSH
57097: LD_VAR 0 3
57101: PPUSH
57102: CALL_OW 183
// AddComExitBuilding ( p ) ;
57106: LD_VAR 0 5
57110: PPUSH
57111: CALL_OW 182
// end ; end ;
57115: GO 56963
57117: POP
57118: POP
// end ;
57119: GO 56929
57121: POP
57122: POP
// end ;
57123: GO 56684
57125: POP
57126: POP
// end ;
57127: LD_VAR 0 1
57131: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
57132: LD_INT 0
57134: PPUSH
57135: PPUSH
57136: PPUSH
57137: PPUSH
57138: PPUSH
57139: PPUSH
57140: PPUSH
57141: PPUSH
57142: PPUSH
57143: PPUSH
57144: PPUSH
57145: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57146: LD_VAR 0 1
57150: NOT
57151: PUSH
57152: LD_EXP 23
57156: PUSH
57157: LD_VAR 0 1
57161: ARRAY
57162: NOT
57163: OR
57164: PUSH
57165: LD_EXP 23
57169: PUSH
57170: LD_VAR 0 1
57174: ARRAY
57175: PPUSH
57176: LD_INT 2
57178: PUSH
57179: LD_INT 30
57181: PUSH
57182: LD_INT 0
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: PUSH
57189: LD_INT 30
57191: PUSH
57192: LD_INT 1
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: PUSH
57199: EMPTY
57200: LIST
57201: LIST
57202: LIST
57203: PPUSH
57204: CALL_OW 72
57208: NOT
57209: OR
57210: IFFALSE 57214
// exit ;
57212: GO 60717
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57214: LD_ADDR_VAR 0 4
57218: PUSH
57219: LD_EXP 23
57223: PUSH
57224: LD_VAR 0 1
57228: ARRAY
57229: PPUSH
57230: LD_INT 2
57232: PUSH
57233: LD_INT 25
57235: PUSH
57236: LD_INT 1
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: LD_INT 25
57245: PUSH
57246: LD_INT 2
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PUSH
57253: LD_INT 25
57255: PUSH
57256: LD_INT 3
57258: PUSH
57259: EMPTY
57260: LIST
57261: LIST
57262: PUSH
57263: LD_INT 25
57265: PUSH
57266: LD_INT 4
57268: PUSH
57269: EMPTY
57270: LIST
57271: LIST
57272: PUSH
57273: LD_INT 25
57275: PUSH
57276: LD_INT 5
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PUSH
57283: LD_INT 25
57285: PUSH
57286: LD_INT 8
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PUSH
57293: LD_INT 25
57295: PUSH
57296: LD_INT 9
57298: PUSH
57299: EMPTY
57300: LIST
57301: LIST
57302: PUSH
57303: EMPTY
57304: LIST
57305: LIST
57306: LIST
57307: LIST
57308: LIST
57309: LIST
57310: LIST
57311: LIST
57312: PPUSH
57313: CALL_OW 72
57317: ST_TO_ADDR
// if not tmp then
57318: LD_VAR 0 4
57322: NOT
57323: IFFALSE 57327
// exit ;
57325: GO 60717
// for i in tmp do
57327: LD_ADDR_VAR 0 3
57331: PUSH
57332: LD_VAR 0 4
57336: PUSH
57337: FOR_IN
57338: IFFALSE 57369
// if GetTag ( i ) then
57340: LD_VAR 0 3
57344: PPUSH
57345: CALL_OW 110
57349: IFFALSE 57367
// tmp := tmp diff i ;
57351: LD_ADDR_VAR 0 4
57355: PUSH
57356: LD_VAR 0 4
57360: PUSH
57361: LD_VAR 0 3
57365: DIFF
57366: ST_TO_ADDR
57367: GO 57337
57369: POP
57370: POP
// if not tmp then
57371: LD_VAR 0 4
57375: NOT
57376: IFFALSE 57380
// exit ;
57378: GO 60717
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57380: LD_ADDR_VAR 0 5
57384: PUSH
57385: LD_EXP 23
57389: PUSH
57390: LD_VAR 0 1
57394: ARRAY
57395: PPUSH
57396: LD_INT 2
57398: PUSH
57399: LD_INT 25
57401: PUSH
57402: LD_INT 1
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: PUSH
57409: LD_INT 25
57411: PUSH
57412: LD_INT 5
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: PUSH
57419: LD_INT 25
57421: PUSH
57422: LD_INT 8
57424: PUSH
57425: EMPTY
57426: LIST
57427: LIST
57428: PUSH
57429: LD_INT 25
57431: PUSH
57432: LD_INT 9
57434: PUSH
57435: EMPTY
57436: LIST
57437: LIST
57438: PUSH
57439: EMPTY
57440: LIST
57441: LIST
57442: LIST
57443: LIST
57444: LIST
57445: PPUSH
57446: CALL_OW 72
57450: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57451: LD_ADDR_VAR 0 6
57455: PUSH
57456: LD_EXP 23
57460: PUSH
57461: LD_VAR 0 1
57465: ARRAY
57466: PPUSH
57467: LD_INT 25
57469: PUSH
57470: LD_INT 2
57472: PUSH
57473: EMPTY
57474: LIST
57475: LIST
57476: PPUSH
57477: CALL_OW 72
57481: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57482: LD_ADDR_VAR 0 7
57486: PUSH
57487: LD_EXP 23
57491: PUSH
57492: LD_VAR 0 1
57496: ARRAY
57497: PPUSH
57498: LD_INT 25
57500: PUSH
57501: LD_INT 3
57503: PUSH
57504: EMPTY
57505: LIST
57506: LIST
57507: PPUSH
57508: CALL_OW 72
57512: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57513: LD_ADDR_VAR 0 8
57517: PUSH
57518: LD_EXP 23
57522: PUSH
57523: LD_VAR 0 1
57527: ARRAY
57528: PPUSH
57529: LD_INT 25
57531: PUSH
57532: LD_INT 4
57534: PUSH
57535: EMPTY
57536: LIST
57537: LIST
57538: PUSH
57539: LD_INT 24
57541: PUSH
57542: LD_INT 251
57544: PUSH
57545: EMPTY
57546: LIST
57547: LIST
57548: PUSH
57549: EMPTY
57550: LIST
57551: LIST
57552: PPUSH
57553: CALL_OW 72
57557: ST_TO_ADDR
// if mc_is_defending [ base ] then
57558: LD_EXP 66
57562: PUSH
57563: LD_VAR 0 1
57567: ARRAY
57568: IFFALSE 58029
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57570: LD_ADDR_EXP 65
57574: PUSH
57575: LD_EXP 65
57579: PPUSH
57580: LD_VAR 0 1
57584: PPUSH
57585: LD_INT 4
57587: PPUSH
57588: CALL_OW 1
57592: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57593: LD_ADDR_VAR 0 12
57597: PUSH
57598: LD_EXP 23
57602: PUSH
57603: LD_VAR 0 1
57607: ARRAY
57608: PPUSH
57609: LD_INT 2
57611: PUSH
57612: LD_INT 30
57614: PUSH
57615: LD_INT 4
57617: PUSH
57618: EMPTY
57619: LIST
57620: LIST
57621: PUSH
57622: LD_INT 30
57624: PUSH
57625: LD_INT 5
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: LIST
57636: PPUSH
57637: CALL_OW 72
57641: ST_TO_ADDR
// if not b then
57642: LD_VAR 0 12
57646: NOT
57647: IFFALSE 57651
// exit ;
57649: GO 60717
// p := [ ] ;
57651: LD_ADDR_VAR 0 11
57655: PUSH
57656: EMPTY
57657: ST_TO_ADDR
// if sci >= 2 then
57658: LD_VAR 0 8
57662: PUSH
57663: LD_INT 2
57665: GREATEREQUAL
57666: IFFALSE 57697
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57668: LD_ADDR_VAR 0 8
57672: PUSH
57673: LD_VAR 0 8
57677: PUSH
57678: LD_INT 1
57680: ARRAY
57681: PUSH
57682: LD_VAR 0 8
57686: PUSH
57687: LD_INT 2
57689: ARRAY
57690: PUSH
57691: EMPTY
57692: LIST
57693: LIST
57694: ST_TO_ADDR
57695: GO 57758
// if sci = 1 then
57697: LD_VAR 0 8
57701: PUSH
57702: LD_INT 1
57704: EQUAL
57705: IFFALSE 57726
// sci := [ sci [ 1 ] ] else
57707: LD_ADDR_VAR 0 8
57711: PUSH
57712: LD_VAR 0 8
57716: PUSH
57717: LD_INT 1
57719: ARRAY
57720: PUSH
57721: EMPTY
57722: LIST
57723: ST_TO_ADDR
57724: GO 57758
// if sci = 0 then
57726: LD_VAR 0 8
57730: PUSH
57731: LD_INT 0
57733: EQUAL
57734: IFFALSE 57758
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57736: LD_ADDR_VAR 0 11
57740: PUSH
57741: LD_VAR 0 4
57745: PPUSH
57746: LD_INT 4
57748: PPUSH
57749: CALL 46957 0 2
57753: PUSH
57754: LD_INT 1
57756: ARRAY
57757: ST_TO_ADDR
// if eng > 4 then
57758: LD_VAR 0 6
57762: PUSH
57763: LD_INT 4
57765: GREATER
57766: IFFALSE 57812
// for i = eng downto 4 do
57768: LD_ADDR_VAR 0 3
57772: PUSH
57773: DOUBLE
57774: LD_VAR 0 6
57778: INC
57779: ST_TO_ADDR
57780: LD_INT 4
57782: PUSH
57783: FOR_DOWNTO
57784: IFFALSE 57810
// eng := eng diff eng [ i ] ;
57786: LD_ADDR_VAR 0 6
57790: PUSH
57791: LD_VAR 0 6
57795: PUSH
57796: LD_VAR 0 6
57800: PUSH
57801: LD_VAR 0 3
57805: ARRAY
57806: DIFF
57807: ST_TO_ADDR
57808: GO 57783
57810: POP
57811: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57812: LD_ADDR_VAR 0 4
57816: PUSH
57817: LD_VAR 0 4
57821: PUSH
57822: LD_VAR 0 5
57826: PUSH
57827: LD_VAR 0 6
57831: UNION
57832: PUSH
57833: LD_VAR 0 7
57837: UNION
57838: PUSH
57839: LD_VAR 0 8
57843: UNION
57844: DIFF
57845: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57846: LD_ADDR_VAR 0 13
57850: PUSH
57851: LD_EXP 23
57855: PUSH
57856: LD_VAR 0 1
57860: ARRAY
57861: PPUSH
57862: LD_INT 2
57864: PUSH
57865: LD_INT 30
57867: PUSH
57868: LD_INT 32
57870: PUSH
57871: EMPTY
57872: LIST
57873: LIST
57874: PUSH
57875: LD_INT 30
57877: PUSH
57878: LD_INT 31
57880: PUSH
57881: EMPTY
57882: LIST
57883: LIST
57884: PUSH
57885: EMPTY
57886: LIST
57887: LIST
57888: LIST
57889: PPUSH
57890: CALL_OW 72
57894: PUSH
57895: LD_EXP 23
57899: PUSH
57900: LD_VAR 0 1
57904: ARRAY
57905: PPUSH
57906: LD_INT 2
57908: PUSH
57909: LD_INT 30
57911: PUSH
57912: LD_INT 4
57914: PUSH
57915: EMPTY
57916: LIST
57917: LIST
57918: PUSH
57919: LD_INT 30
57921: PUSH
57922: LD_INT 5
57924: PUSH
57925: EMPTY
57926: LIST
57927: LIST
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: LIST
57933: PPUSH
57934: CALL_OW 72
57938: PUSH
57939: LD_INT 6
57941: MUL
57942: PLUS
57943: ST_TO_ADDR
// if bcount < tmp then
57944: LD_VAR 0 13
57948: PUSH
57949: LD_VAR 0 4
57953: LESS
57954: IFFALSE 58000
// for i = tmp downto bcount do
57956: LD_ADDR_VAR 0 3
57960: PUSH
57961: DOUBLE
57962: LD_VAR 0 4
57966: INC
57967: ST_TO_ADDR
57968: LD_VAR 0 13
57972: PUSH
57973: FOR_DOWNTO
57974: IFFALSE 57998
// tmp := Delete ( tmp , tmp ) ;
57976: LD_ADDR_VAR 0 4
57980: PUSH
57981: LD_VAR 0 4
57985: PPUSH
57986: LD_VAR 0 4
57990: PPUSH
57991: CALL_OW 3
57995: ST_TO_ADDR
57996: GO 57973
57998: POP
57999: POP
// result := [ tmp , 0 , 0 , p ] ;
58000: LD_ADDR_VAR 0 2
58004: PUSH
58005: LD_VAR 0 4
58009: PUSH
58010: LD_INT 0
58012: PUSH
58013: LD_INT 0
58015: PUSH
58016: LD_VAR 0 11
58020: PUSH
58021: EMPTY
58022: LIST
58023: LIST
58024: LIST
58025: LIST
58026: ST_TO_ADDR
// exit ;
58027: GO 60717
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58029: LD_EXP 23
58033: PUSH
58034: LD_VAR 0 1
58038: ARRAY
58039: PPUSH
58040: LD_INT 2
58042: PUSH
58043: LD_INT 30
58045: PUSH
58046: LD_INT 6
58048: PUSH
58049: EMPTY
58050: LIST
58051: LIST
58052: PUSH
58053: LD_INT 30
58055: PUSH
58056: LD_INT 7
58058: PUSH
58059: EMPTY
58060: LIST
58061: LIST
58062: PUSH
58063: LD_INT 30
58065: PUSH
58066: LD_INT 8
58068: PUSH
58069: EMPTY
58070: LIST
58071: LIST
58072: PUSH
58073: EMPTY
58074: LIST
58075: LIST
58076: LIST
58077: LIST
58078: PPUSH
58079: CALL_OW 72
58083: NOT
58084: PUSH
58085: LD_EXP 23
58089: PUSH
58090: LD_VAR 0 1
58094: ARRAY
58095: PPUSH
58096: LD_INT 30
58098: PUSH
58099: LD_INT 3
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PPUSH
58106: CALL_OW 72
58110: NOT
58111: AND
58112: IFFALSE 58184
// begin if eng = tmp then
58114: LD_VAR 0 6
58118: PUSH
58119: LD_VAR 0 4
58123: EQUAL
58124: IFFALSE 58128
// exit ;
58126: GO 60717
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
58128: LD_ADDR_EXP 65
58132: PUSH
58133: LD_EXP 65
58137: PPUSH
58138: LD_VAR 0 1
58142: PPUSH
58143: LD_INT 1
58145: PPUSH
58146: CALL_OW 1
58150: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
58151: LD_ADDR_VAR 0 2
58155: PUSH
58156: LD_INT 0
58158: PUSH
58159: LD_VAR 0 4
58163: PUSH
58164: LD_VAR 0 6
58168: DIFF
58169: PUSH
58170: LD_INT 0
58172: PUSH
58173: LD_INT 0
58175: PUSH
58176: EMPTY
58177: LIST
58178: LIST
58179: LIST
58180: LIST
58181: ST_TO_ADDR
// exit ;
58182: GO 60717
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58184: LD_EXP 50
58188: PUSH
58189: LD_EXP 49
58193: PUSH
58194: LD_VAR 0 1
58198: ARRAY
58199: ARRAY
58200: PUSH
58201: LD_EXP 23
58205: PUSH
58206: LD_VAR 0 1
58210: ARRAY
58211: PPUSH
58212: LD_INT 2
58214: PUSH
58215: LD_INT 30
58217: PUSH
58218: LD_INT 6
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: LD_INT 30
58227: PUSH
58228: LD_INT 7
58230: PUSH
58231: EMPTY
58232: LIST
58233: LIST
58234: PUSH
58235: LD_INT 30
58237: PUSH
58238: LD_INT 8
58240: PUSH
58241: EMPTY
58242: LIST
58243: LIST
58244: PUSH
58245: EMPTY
58246: LIST
58247: LIST
58248: LIST
58249: LIST
58250: PPUSH
58251: CALL_OW 72
58255: AND
58256: PUSH
58257: LD_EXP 23
58261: PUSH
58262: LD_VAR 0 1
58266: ARRAY
58267: PPUSH
58268: LD_INT 30
58270: PUSH
58271: LD_INT 3
58273: PUSH
58274: EMPTY
58275: LIST
58276: LIST
58277: PPUSH
58278: CALL_OW 72
58282: NOT
58283: AND
58284: IFFALSE 58498
// begin if sci >= 6 then
58286: LD_VAR 0 8
58290: PUSH
58291: LD_INT 6
58293: GREATEREQUAL
58294: IFFALSE 58298
// exit ;
58296: GO 60717
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
58298: LD_ADDR_EXP 65
58302: PUSH
58303: LD_EXP 65
58307: PPUSH
58308: LD_VAR 0 1
58312: PPUSH
58313: LD_INT 2
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
58321: LD_ADDR_VAR 0 9
58325: PUSH
58326: LD_VAR 0 4
58330: PUSH
58331: LD_VAR 0 8
58335: DIFF
58336: PPUSH
58337: LD_INT 4
58339: PPUSH
58340: CALL 46957 0 2
58344: ST_TO_ADDR
// p := [ ] ;
58345: LD_ADDR_VAR 0 11
58349: PUSH
58350: EMPTY
58351: ST_TO_ADDR
// if sci < 6 and sort > 6 then
58352: LD_VAR 0 8
58356: PUSH
58357: LD_INT 6
58359: LESS
58360: PUSH
58361: LD_VAR 0 9
58365: PUSH
58366: LD_INT 6
58368: GREATER
58369: AND
58370: IFFALSE 58451
// begin for i = 1 to 6 - sci do
58372: LD_ADDR_VAR 0 3
58376: PUSH
58377: DOUBLE
58378: LD_INT 1
58380: DEC
58381: ST_TO_ADDR
58382: LD_INT 6
58384: PUSH
58385: LD_VAR 0 8
58389: MINUS
58390: PUSH
58391: FOR_TO
58392: IFFALSE 58447
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
58394: LD_ADDR_VAR 0 11
58398: PUSH
58399: LD_VAR 0 11
58403: PPUSH
58404: LD_VAR 0 11
58408: PUSH
58409: LD_INT 1
58411: PLUS
58412: PPUSH
58413: LD_VAR 0 9
58417: PUSH
58418: LD_INT 1
58420: ARRAY
58421: PPUSH
58422: CALL_OW 2
58426: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58427: LD_ADDR_VAR 0 9
58431: PUSH
58432: LD_VAR 0 9
58436: PPUSH
58437: LD_INT 1
58439: PPUSH
58440: CALL_OW 3
58444: ST_TO_ADDR
// end ;
58445: GO 58391
58447: POP
58448: POP
// end else
58449: GO 58471
// if sort then
58451: LD_VAR 0 9
58455: IFFALSE 58471
// p := sort [ 1 ] ;
58457: LD_ADDR_VAR 0 11
58461: PUSH
58462: LD_VAR 0 9
58466: PUSH
58467: LD_INT 1
58469: ARRAY
58470: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58471: LD_ADDR_VAR 0 2
58475: PUSH
58476: LD_INT 0
58478: PUSH
58479: LD_INT 0
58481: PUSH
58482: LD_INT 0
58484: PUSH
58485: LD_VAR 0 11
58489: PUSH
58490: EMPTY
58491: LIST
58492: LIST
58493: LIST
58494: LIST
58495: ST_TO_ADDR
// exit ;
58496: GO 60717
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58498: LD_EXP 50
58502: PUSH
58503: LD_EXP 49
58507: PUSH
58508: LD_VAR 0 1
58512: ARRAY
58513: ARRAY
58514: PUSH
58515: LD_EXP 23
58519: PUSH
58520: LD_VAR 0 1
58524: ARRAY
58525: PPUSH
58526: LD_INT 2
58528: PUSH
58529: LD_INT 30
58531: PUSH
58532: LD_INT 6
58534: PUSH
58535: EMPTY
58536: LIST
58537: LIST
58538: PUSH
58539: LD_INT 30
58541: PUSH
58542: LD_INT 7
58544: PUSH
58545: EMPTY
58546: LIST
58547: LIST
58548: PUSH
58549: LD_INT 30
58551: PUSH
58552: LD_INT 8
58554: PUSH
58555: EMPTY
58556: LIST
58557: LIST
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: LIST
58563: LIST
58564: PPUSH
58565: CALL_OW 72
58569: AND
58570: PUSH
58571: LD_EXP 23
58575: PUSH
58576: LD_VAR 0 1
58580: ARRAY
58581: PPUSH
58582: LD_INT 30
58584: PUSH
58585: LD_INT 3
58587: PUSH
58588: EMPTY
58589: LIST
58590: LIST
58591: PPUSH
58592: CALL_OW 72
58596: AND
58597: IFFALSE 59331
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58599: LD_ADDR_EXP 65
58603: PUSH
58604: LD_EXP 65
58608: PPUSH
58609: LD_VAR 0 1
58613: PPUSH
58614: LD_INT 3
58616: PPUSH
58617: CALL_OW 1
58621: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58622: LD_ADDR_VAR 0 2
58626: PUSH
58627: LD_INT 0
58629: PUSH
58630: LD_INT 0
58632: PUSH
58633: LD_INT 0
58635: PUSH
58636: LD_INT 0
58638: PUSH
58639: EMPTY
58640: LIST
58641: LIST
58642: LIST
58643: LIST
58644: ST_TO_ADDR
// if not eng then
58645: LD_VAR 0 6
58649: NOT
58650: IFFALSE 58713
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58652: LD_ADDR_VAR 0 11
58656: PUSH
58657: LD_VAR 0 4
58661: PPUSH
58662: LD_INT 2
58664: PPUSH
58665: CALL 46957 0 2
58669: PUSH
58670: LD_INT 1
58672: ARRAY
58673: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58674: LD_ADDR_VAR 0 2
58678: PUSH
58679: LD_VAR 0 2
58683: PPUSH
58684: LD_INT 2
58686: PPUSH
58687: LD_VAR 0 11
58691: PPUSH
58692: CALL_OW 1
58696: ST_TO_ADDR
// tmp := tmp diff p ;
58697: LD_ADDR_VAR 0 4
58701: PUSH
58702: LD_VAR 0 4
58706: PUSH
58707: LD_VAR 0 11
58711: DIFF
58712: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58713: LD_VAR 0 4
58717: PUSH
58718: LD_VAR 0 8
58722: PUSH
58723: LD_INT 6
58725: LESS
58726: AND
58727: IFFALSE 58915
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58729: LD_ADDR_VAR 0 9
58733: PUSH
58734: LD_VAR 0 4
58738: PUSH
58739: LD_VAR 0 8
58743: PUSH
58744: LD_VAR 0 7
58748: UNION
58749: DIFF
58750: PPUSH
58751: LD_INT 4
58753: PPUSH
58754: CALL 46957 0 2
58758: ST_TO_ADDR
// p := [ ] ;
58759: LD_ADDR_VAR 0 11
58763: PUSH
58764: EMPTY
58765: ST_TO_ADDR
// if sort then
58766: LD_VAR 0 9
58770: IFFALSE 58886
// for i = 1 to 6 - sci do
58772: LD_ADDR_VAR 0 3
58776: PUSH
58777: DOUBLE
58778: LD_INT 1
58780: DEC
58781: ST_TO_ADDR
58782: LD_INT 6
58784: PUSH
58785: LD_VAR 0 8
58789: MINUS
58790: PUSH
58791: FOR_TO
58792: IFFALSE 58884
// begin if i = sort then
58794: LD_VAR 0 3
58798: PUSH
58799: LD_VAR 0 9
58803: EQUAL
58804: IFFALSE 58808
// break ;
58806: GO 58884
// if GetClass ( i ) = 4 then
58808: LD_VAR 0 3
58812: PPUSH
58813: CALL_OW 257
58817: PUSH
58818: LD_INT 4
58820: EQUAL
58821: IFFALSE 58825
// continue ;
58823: GO 58791
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58825: LD_ADDR_VAR 0 11
58829: PUSH
58830: LD_VAR 0 11
58834: PPUSH
58835: LD_VAR 0 11
58839: PUSH
58840: LD_INT 1
58842: PLUS
58843: PPUSH
58844: LD_VAR 0 9
58848: PUSH
58849: LD_VAR 0 3
58853: ARRAY
58854: PPUSH
58855: CALL_OW 2
58859: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58860: LD_ADDR_VAR 0 4
58864: PUSH
58865: LD_VAR 0 4
58869: PUSH
58870: LD_VAR 0 9
58874: PUSH
58875: LD_VAR 0 3
58879: ARRAY
58880: DIFF
58881: ST_TO_ADDR
// end ;
58882: GO 58791
58884: POP
58885: POP
// if p then
58886: LD_VAR 0 11
58890: IFFALSE 58915
// result := Replace ( result , 4 , p ) ;
58892: LD_ADDR_VAR 0 2
58896: PUSH
58897: LD_VAR 0 2
58901: PPUSH
58902: LD_INT 4
58904: PPUSH
58905: LD_VAR 0 11
58909: PPUSH
58910: CALL_OW 1
58914: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58915: LD_VAR 0 4
58919: PUSH
58920: LD_VAR 0 7
58924: PUSH
58925: LD_INT 6
58927: LESS
58928: AND
58929: IFFALSE 59117
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58931: LD_ADDR_VAR 0 9
58935: PUSH
58936: LD_VAR 0 4
58940: PUSH
58941: LD_VAR 0 8
58945: PUSH
58946: LD_VAR 0 7
58950: UNION
58951: DIFF
58952: PPUSH
58953: LD_INT 3
58955: PPUSH
58956: CALL 46957 0 2
58960: ST_TO_ADDR
// p := [ ] ;
58961: LD_ADDR_VAR 0 11
58965: PUSH
58966: EMPTY
58967: ST_TO_ADDR
// if sort then
58968: LD_VAR 0 9
58972: IFFALSE 59088
// for i = 1 to 6 - mech do
58974: LD_ADDR_VAR 0 3
58978: PUSH
58979: DOUBLE
58980: LD_INT 1
58982: DEC
58983: ST_TO_ADDR
58984: LD_INT 6
58986: PUSH
58987: LD_VAR 0 7
58991: MINUS
58992: PUSH
58993: FOR_TO
58994: IFFALSE 59086
// begin if i = sort then
58996: LD_VAR 0 3
59000: PUSH
59001: LD_VAR 0 9
59005: EQUAL
59006: IFFALSE 59010
// break ;
59008: GO 59086
// if GetClass ( i ) = 3 then
59010: LD_VAR 0 3
59014: PPUSH
59015: CALL_OW 257
59019: PUSH
59020: LD_INT 3
59022: EQUAL
59023: IFFALSE 59027
// continue ;
59025: GO 58993
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59027: LD_ADDR_VAR 0 11
59031: PUSH
59032: LD_VAR 0 11
59036: PPUSH
59037: LD_VAR 0 11
59041: PUSH
59042: LD_INT 1
59044: PLUS
59045: PPUSH
59046: LD_VAR 0 9
59050: PUSH
59051: LD_VAR 0 3
59055: ARRAY
59056: PPUSH
59057: CALL_OW 2
59061: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59062: LD_ADDR_VAR 0 4
59066: PUSH
59067: LD_VAR 0 4
59071: PUSH
59072: LD_VAR 0 9
59076: PUSH
59077: LD_VAR 0 3
59081: ARRAY
59082: DIFF
59083: ST_TO_ADDR
// end ;
59084: GO 58993
59086: POP
59087: POP
// if p then
59088: LD_VAR 0 11
59092: IFFALSE 59117
// result := Replace ( result , 3 , p ) ;
59094: LD_ADDR_VAR 0 2
59098: PUSH
59099: LD_VAR 0 2
59103: PPUSH
59104: LD_INT 3
59106: PPUSH
59107: LD_VAR 0 11
59111: PPUSH
59112: CALL_OW 1
59116: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
59117: LD_VAR 0 4
59121: PUSH
59122: LD_INT 6
59124: GREATER
59125: PUSH
59126: LD_VAR 0 6
59130: PUSH
59131: LD_INT 6
59133: LESS
59134: AND
59135: IFFALSE 59329
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59137: LD_ADDR_VAR 0 9
59141: PUSH
59142: LD_VAR 0 4
59146: PUSH
59147: LD_VAR 0 8
59151: PUSH
59152: LD_VAR 0 7
59156: UNION
59157: PUSH
59158: LD_VAR 0 6
59162: UNION
59163: DIFF
59164: PPUSH
59165: LD_INT 2
59167: PPUSH
59168: CALL 46957 0 2
59172: ST_TO_ADDR
// p := [ ] ;
59173: LD_ADDR_VAR 0 11
59177: PUSH
59178: EMPTY
59179: ST_TO_ADDR
// if sort then
59180: LD_VAR 0 9
59184: IFFALSE 59300
// for i = 1 to 6 - eng do
59186: LD_ADDR_VAR 0 3
59190: PUSH
59191: DOUBLE
59192: LD_INT 1
59194: DEC
59195: ST_TO_ADDR
59196: LD_INT 6
59198: PUSH
59199: LD_VAR 0 6
59203: MINUS
59204: PUSH
59205: FOR_TO
59206: IFFALSE 59298
// begin if i = sort then
59208: LD_VAR 0 3
59212: PUSH
59213: LD_VAR 0 9
59217: EQUAL
59218: IFFALSE 59222
// break ;
59220: GO 59298
// if GetClass ( i ) = 2 then
59222: LD_VAR 0 3
59226: PPUSH
59227: CALL_OW 257
59231: PUSH
59232: LD_INT 2
59234: EQUAL
59235: IFFALSE 59239
// continue ;
59237: GO 59205
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59239: LD_ADDR_VAR 0 11
59243: PUSH
59244: LD_VAR 0 11
59248: PPUSH
59249: LD_VAR 0 11
59253: PUSH
59254: LD_INT 1
59256: PLUS
59257: PPUSH
59258: LD_VAR 0 9
59262: PUSH
59263: LD_VAR 0 3
59267: ARRAY
59268: PPUSH
59269: CALL_OW 2
59273: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59274: LD_ADDR_VAR 0 4
59278: PUSH
59279: LD_VAR 0 4
59283: PUSH
59284: LD_VAR 0 9
59288: PUSH
59289: LD_VAR 0 3
59293: ARRAY
59294: DIFF
59295: ST_TO_ADDR
// end ;
59296: GO 59205
59298: POP
59299: POP
// if p then
59300: LD_VAR 0 11
59304: IFFALSE 59329
// result := Replace ( result , 2 , p ) ;
59306: LD_ADDR_VAR 0 2
59310: PUSH
59311: LD_VAR 0 2
59315: PPUSH
59316: LD_INT 2
59318: PPUSH
59319: LD_VAR 0 11
59323: PPUSH
59324: CALL_OW 1
59328: ST_TO_ADDR
// end ; exit ;
59329: GO 60717
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
59331: LD_EXP 50
59335: PUSH
59336: LD_EXP 49
59340: PUSH
59341: LD_VAR 0 1
59345: ARRAY
59346: ARRAY
59347: NOT
59348: PUSH
59349: LD_EXP 23
59353: PUSH
59354: LD_VAR 0 1
59358: ARRAY
59359: PPUSH
59360: LD_INT 30
59362: PUSH
59363: LD_INT 3
59365: PUSH
59366: EMPTY
59367: LIST
59368: LIST
59369: PPUSH
59370: CALL_OW 72
59374: AND
59375: PUSH
59376: LD_EXP 28
59380: PUSH
59381: LD_VAR 0 1
59385: ARRAY
59386: AND
59387: IFFALSE 59995
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
59389: LD_ADDR_EXP 65
59393: PUSH
59394: LD_EXP 65
59398: PPUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: LD_INT 5
59406: PPUSH
59407: CALL_OW 1
59411: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59412: LD_ADDR_VAR 0 2
59416: PUSH
59417: LD_INT 0
59419: PUSH
59420: LD_INT 0
59422: PUSH
59423: LD_INT 0
59425: PUSH
59426: LD_INT 0
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: LIST
59433: LIST
59434: ST_TO_ADDR
// if sci > 1 then
59435: LD_VAR 0 8
59439: PUSH
59440: LD_INT 1
59442: GREATER
59443: IFFALSE 59471
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59445: LD_ADDR_VAR 0 4
59449: PUSH
59450: LD_VAR 0 4
59454: PUSH
59455: LD_VAR 0 8
59459: PUSH
59460: LD_VAR 0 8
59464: PUSH
59465: LD_INT 1
59467: ARRAY
59468: DIFF
59469: DIFF
59470: ST_TO_ADDR
// if tmp and not sci then
59471: LD_VAR 0 4
59475: PUSH
59476: LD_VAR 0 8
59480: NOT
59481: AND
59482: IFFALSE 59551
// begin sort := SortBySkill ( tmp , 4 ) ;
59484: LD_ADDR_VAR 0 9
59488: PUSH
59489: LD_VAR 0 4
59493: PPUSH
59494: LD_INT 4
59496: PPUSH
59497: CALL 46957 0 2
59501: ST_TO_ADDR
// if sort then
59502: LD_VAR 0 9
59506: IFFALSE 59522
// p := sort [ 1 ] ;
59508: LD_ADDR_VAR 0 11
59512: PUSH
59513: LD_VAR 0 9
59517: PUSH
59518: LD_INT 1
59520: ARRAY
59521: ST_TO_ADDR
// if p then
59522: LD_VAR 0 11
59526: IFFALSE 59551
// result := Replace ( result , 4 , p ) ;
59528: LD_ADDR_VAR 0 2
59532: PUSH
59533: LD_VAR 0 2
59537: PPUSH
59538: LD_INT 4
59540: PPUSH
59541: LD_VAR 0 11
59545: PPUSH
59546: CALL_OW 1
59550: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59551: LD_ADDR_VAR 0 4
59555: PUSH
59556: LD_VAR 0 4
59560: PUSH
59561: LD_VAR 0 7
59565: DIFF
59566: ST_TO_ADDR
// if tmp and mech < 6 then
59567: LD_VAR 0 4
59571: PUSH
59572: LD_VAR 0 7
59576: PUSH
59577: LD_INT 6
59579: LESS
59580: AND
59581: IFFALSE 59769
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59583: LD_ADDR_VAR 0 9
59587: PUSH
59588: LD_VAR 0 4
59592: PUSH
59593: LD_VAR 0 8
59597: PUSH
59598: LD_VAR 0 7
59602: UNION
59603: DIFF
59604: PPUSH
59605: LD_INT 3
59607: PPUSH
59608: CALL 46957 0 2
59612: ST_TO_ADDR
// p := [ ] ;
59613: LD_ADDR_VAR 0 11
59617: PUSH
59618: EMPTY
59619: ST_TO_ADDR
// if sort then
59620: LD_VAR 0 9
59624: IFFALSE 59740
// for i = 1 to 6 - mech do
59626: LD_ADDR_VAR 0 3
59630: PUSH
59631: DOUBLE
59632: LD_INT 1
59634: DEC
59635: ST_TO_ADDR
59636: LD_INT 6
59638: PUSH
59639: LD_VAR 0 7
59643: MINUS
59644: PUSH
59645: FOR_TO
59646: IFFALSE 59738
// begin if i = sort then
59648: LD_VAR 0 3
59652: PUSH
59653: LD_VAR 0 9
59657: EQUAL
59658: IFFALSE 59662
// break ;
59660: GO 59738
// if GetClass ( i ) = 3 then
59662: LD_VAR 0 3
59666: PPUSH
59667: CALL_OW 257
59671: PUSH
59672: LD_INT 3
59674: EQUAL
59675: IFFALSE 59679
// continue ;
59677: GO 59645
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59679: LD_ADDR_VAR 0 11
59683: PUSH
59684: LD_VAR 0 11
59688: PPUSH
59689: LD_VAR 0 11
59693: PUSH
59694: LD_INT 1
59696: PLUS
59697: PPUSH
59698: LD_VAR 0 9
59702: PUSH
59703: LD_VAR 0 3
59707: ARRAY
59708: PPUSH
59709: CALL_OW 2
59713: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59714: LD_ADDR_VAR 0 4
59718: PUSH
59719: LD_VAR 0 4
59723: PUSH
59724: LD_VAR 0 9
59728: PUSH
59729: LD_VAR 0 3
59733: ARRAY
59734: DIFF
59735: ST_TO_ADDR
// end ;
59736: GO 59645
59738: POP
59739: POP
// if p then
59740: LD_VAR 0 11
59744: IFFALSE 59769
// result := Replace ( result , 3 , p ) ;
59746: LD_ADDR_VAR 0 2
59750: PUSH
59751: LD_VAR 0 2
59755: PPUSH
59756: LD_INT 3
59758: PPUSH
59759: LD_VAR 0 11
59763: PPUSH
59764: CALL_OW 1
59768: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59769: LD_ADDR_VAR 0 4
59773: PUSH
59774: LD_VAR 0 4
59778: PUSH
59779: LD_VAR 0 6
59783: DIFF
59784: ST_TO_ADDR
// if tmp and eng < 6 then
59785: LD_VAR 0 4
59789: PUSH
59790: LD_VAR 0 6
59794: PUSH
59795: LD_INT 6
59797: LESS
59798: AND
59799: IFFALSE 59993
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59801: LD_ADDR_VAR 0 9
59805: PUSH
59806: LD_VAR 0 4
59810: PUSH
59811: LD_VAR 0 8
59815: PUSH
59816: LD_VAR 0 7
59820: UNION
59821: PUSH
59822: LD_VAR 0 6
59826: UNION
59827: DIFF
59828: PPUSH
59829: LD_INT 2
59831: PPUSH
59832: CALL 46957 0 2
59836: ST_TO_ADDR
// p := [ ] ;
59837: LD_ADDR_VAR 0 11
59841: PUSH
59842: EMPTY
59843: ST_TO_ADDR
// if sort then
59844: LD_VAR 0 9
59848: IFFALSE 59964
// for i = 1 to 6 - eng do
59850: LD_ADDR_VAR 0 3
59854: PUSH
59855: DOUBLE
59856: LD_INT 1
59858: DEC
59859: ST_TO_ADDR
59860: LD_INT 6
59862: PUSH
59863: LD_VAR 0 6
59867: MINUS
59868: PUSH
59869: FOR_TO
59870: IFFALSE 59962
// begin if i = sort then
59872: LD_VAR 0 3
59876: PUSH
59877: LD_VAR 0 9
59881: EQUAL
59882: IFFALSE 59886
// break ;
59884: GO 59962
// if GetClass ( i ) = 2 then
59886: LD_VAR 0 3
59890: PPUSH
59891: CALL_OW 257
59895: PUSH
59896: LD_INT 2
59898: EQUAL
59899: IFFALSE 59903
// continue ;
59901: GO 59869
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59903: LD_ADDR_VAR 0 11
59907: PUSH
59908: LD_VAR 0 11
59912: PPUSH
59913: LD_VAR 0 11
59917: PUSH
59918: LD_INT 1
59920: PLUS
59921: PPUSH
59922: LD_VAR 0 9
59926: PUSH
59927: LD_VAR 0 3
59931: ARRAY
59932: PPUSH
59933: CALL_OW 2
59937: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59938: LD_ADDR_VAR 0 4
59942: PUSH
59943: LD_VAR 0 4
59947: PUSH
59948: LD_VAR 0 9
59952: PUSH
59953: LD_VAR 0 3
59957: ARRAY
59958: DIFF
59959: ST_TO_ADDR
// end ;
59960: GO 59869
59962: POP
59963: POP
// if p then
59964: LD_VAR 0 11
59968: IFFALSE 59993
// result := Replace ( result , 2 , p ) ;
59970: LD_ADDR_VAR 0 2
59974: PUSH
59975: LD_VAR 0 2
59979: PPUSH
59980: LD_INT 2
59982: PPUSH
59983: LD_VAR 0 11
59987: PPUSH
59988: CALL_OW 1
59992: ST_TO_ADDR
// end ; exit ;
59993: GO 60717
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59995: LD_EXP 50
59999: PUSH
60000: LD_EXP 49
60004: PUSH
60005: LD_VAR 0 1
60009: ARRAY
60010: ARRAY
60011: NOT
60012: PUSH
60013: LD_EXP 23
60017: PUSH
60018: LD_VAR 0 1
60022: ARRAY
60023: PPUSH
60024: LD_INT 30
60026: PUSH
60027: LD_INT 3
60029: PUSH
60030: EMPTY
60031: LIST
60032: LIST
60033: PPUSH
60034: CALL_OW 72
60038: AND
60039: PUSH
60040: LD_EXP 28
60044: PUSH
60045: LD_VAR 0 1
60049: ARRAY
60050: NOT
60051: AND
60052: IFFALSE 60717
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
60054: LD_ADDR_EXP 65
60058: PUSH
60059: LD_EXP 65
60063: PPUSH
60064: LD_VAR 0 1
60068: PPUSH
60069: LD_INT 6
60071: PPUSH
60072: CALL_OW 1
60076: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60077: LD_ADDR_VAR 0 2
60081: PUSH
60082: LD_INT 0
60084: PUSH
60085: LD_INT 0
60087: PUSH
60088: LD_INT 0
60090: PUSH
60091: LD_INT 0
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: LIST
60098: LIST
60099: ST_TO_ADDR
// if sci >= 1 then
60100: LD_VAR 0 8
60104: PUSH
60105: LD_INT 1
60107: GREATEREQUAL
60108: IFFALSE 60130
// tmp := tmp diff sci [ 1 ] ;
60110: LD_ADDR_VAR 0 4
60114: PUSH
60115: LD_VAR 0 4
60119: PUSH
60120: LD_VAR 0 8
60124: PUSH
60125: LD_INT 1
60127: ARRAY
60128: DIFF
60129: ST_TO_ADDR
// if tmp and not sci then
60130: LD_VAR 0 4
60134: PUSH
60135: LD_VAR 0 8
60139: NOT
60140: AND
60141: IFFALSE 60210
// begin sort := SortBySkill ( tmp , 4 ) ;
60143: LD_ADDR_VAR 0 9
60147: PUSH
60148: LD_VAR 0 4
60152: PPUSH
60153: LD_INT 4
60155: PPUSH
60156: CALL 46957 0 2
60160: ST_TO_ADDR
// if sort then
60161: LD_VAR 0 9
60165: IFFALSE 60181
// p := sort [ 1 ] ;
60167: LD_ADDR_VAR 0 11
60171: PUSH
60172: LD_VAR 0 9
60176: PUSH
60177: LD_INT 1
60179: ARRAY
60180: ST_TO_ADDR
// if p then
60181: LD_VAR 0 11
60185: IFFALSE 60210
// result := Replace ( result , 4 , p ) ;
60187: LD_ADDR_VAR 0 2
60191: PUSH
60192: LD_VAR 0 2
60196: PPUSH
60197: LD_INT 4
60199: PPUSH
60200: LD_VAR 0 11
60204: PPUSH
60205: CALL_OW 1
60209: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
60210: LD_ADDR_VAR 0 4
60214: PUSH
60215: LD_VAR 0 4
60219: PUSH
60220: LD_VAR 0 7
60224: DIFF
60225: ST_TO_ADDR
// if tmp and mech < 6 then
60226: LD_VAR 0 4
60230: PUSH
60231: LD_VAR 0 7
60235: PUSH
60236: LD_INT 6
60238: LESS
60239: AND
60240: IFFALSE 60422
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
60242: LD_ADDR_VAR 0 9
60246: PUSH
60247: LD_VAR 0 4
60251: PUSH
60252: LD_VAR 0 7
60256: DIFF
60257: PPUSH
60258: LD_INT 3
60260: PPUSH
60261: CALL 46957 0 2
60265: ST_TO_ADDR
// p := [ ] ;
60266: LD_ADDR_VAR 0 11
60270: PUSH
60271: EMPTY
60272: ST_TO_ADDR
// if sort then
60273: LD_VAR 0 9
60277: IFFALSE 60393
// for i = 1 to 6 - mech do
60279: LD_ADDR_VAR 0 3
60283: PUSH
60284: DOUBLE
60285: LD_INT 1
60287: DEC
60288: ST_TO_ADDR
60289: LD_INT 6
60291: PUSH
60292: LD_VAR 0 7
60296: MINUS
60297: PUSH
60298: FOR_TO
60299: IFFALSE 60391
// begin if i = sort then
60301: LD_VAR 0 3
60305: PUSH
60306: LD_VAR 0 9
60310: EQUAL
60311: IFFALSE 60315
// break ;
60313: GO 60391
// if GetClass ( i ) = 3 then
60315: LD_VAR 0 3
60319: PPUSH
60320: CALL_OW 257
60324: PUSH
60325: LD_INT 3
60327: EQUAL
60328: IFFALSE 60332
// continue ;
60330: GO 60298
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60332: LD_ADDR_VAR 0 11
60336: PUSH
60337: LD_VAR 0 11
60341: PPUSH
60342: LD_VAR 0 11
60346: PUSH
60347: LD_INT 1
60349: PLUS
60350: PPUSH
60351: LD_VAR 0 9
60355: PUSH
60356: LD_VAR 0 3
60360: ARRAY
60361: PPUSH
60362: CALL_OW 2
60366: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60367: LD_ADDR_VAR 0 4
60371: PUSH
60372: LD_VAR 0 4
60376: PUSH
60377: LD_VAR 0 9
60381: PUSH
60382: LD_VAR 0 3
60386: ARRAY
60387: DIFF
60388: ST_TO_ADDR
// end ;
60389: GO 60298
60391: POP
60392: POP
// if p then
60393: LD_VAR 0 11
60397: IFFALSE 60422
// result := Replace ( result , 3 , p ) ;
60399: LD_ADDR_VAR 0 2
60403: PUSH
60404: LD_VAR 0 2
60408: PPUSH
60409: LD_INT 3
60411: PPUSH
60412: LD_VAR 0 11
60416: PPUSH
60417: CALL_OW 1
60421: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60422: LD_ADDR_VAR 0 4
60426: PUSH
60427: LD_VAR 0 4
60431: PUSH
60432: LD_VAR 0 6
60436: DIFF
60437: ST_TO_ADDR
// if tmp and eng < 4 then
60438: LD_VAR 0 4
60442: PUSH
60443: LD_VAR 0 6
60447: PUSH
60448: LD_INT 4
60450: LESS
60451: AND
60452: IFFALSE 60642
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60454: LD_ADDR_VAR 0 9
60458: PUSH
60459: LD_VAR 0 4
60463: PUSH
60464: LD_VAR 0 7
60468: PUSH
60469: LD_VAR 0 6
60473: UNION
60474: DIFF
60475: PPUSH
60476: LD_INT 2
60478: PPUSH
60479: CALL 46957 0 2
60483: ST_TO_ADDR
// p := [ ] ;
60484: LD_ADDR_VAR 0 11
60488: PUSH
60489: EMPTY
60490: ST_TO_ADDR
// if sort then
60491: LD_VAR 0 9
60495: IFFALSE 60611
// for i = 1 to 4 - eng do
60497: LD_ADDR_VAR 0 3
60501: PUSH
60502: DOUBLE
60503: LD_INT 1
60505: DEC
60506: ST_TO_ADDR
60507: LD_INT 4
60509: PUSH
60510: LD_VAR 0 6
60514: MINUS
60515: PUSH
60516: FOR_TO
60517: IFFALSE 60609
// begin if i = sort then
60519: LD_VAR 0 3
60523: PUSH
60524: LD_VAR 0 9
60528: EQUAL
60529: IFFALSE 60533
// break ;
60531: GO 60609
// if GetClass ( i ) = 2 then
60533: LD_VAR 0 3
60537: PPUSH
60538: CALL_OW 257
60542: PUSH
60543: LD_INT 2
60545: EQUAL
60546: IFFALSE 60550
// continue ;
60548: GO 60516
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60550: LD_ADDR_VAR 0 11
60554: PUSH
60555: LD_VAR 0 11
60559: PPUSH
60560: LD_VAR 0 11
60564: PUSH
60565: LD_INT 1
60567: PLUS
60568: PPUSH
60569: LD_VAR 0 9
60573: PUSH
60574: LD_VAR 0 3
60578: ARRAY
60579: PPUSH
60580: CALL_OW 2
60584: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60585: LD_ADDR_VAR 0 4
60589: PUSH
60590: LD_VAR 0 4
60594: PUSH
60595: LD_VAR 0 9
60599: PUSH
60600: LD_VAR 0 3
60604: ARRAY
60605: DIFF
60606: ST_TO_ADDR
// end ;
60607: GO 60516
60609: POP
60610: POP
// if p then
60611: LD_VAR 0 11
60615: IFFALSE 60640
// result := Replace ( result , 2 , p ) ;
60617: LD_ADDR_VAR 0 2
60621: PUSH
60622: LD_VAR 0 2
60626: PPUSH
60627: LD_INT 2
60629: PPUSH
60630: LD_VAR 0 11
60634: PPUSH
60635: CALL_OW 1
60639: ST_TO_ADDR
// end else
60640: GO 60686
// for i = eng downto 5 do
60642: LD_ADDR_VAR 0 3
60646: PUSH
60647: DOUBLE
60648: LD_VAR 0 6
60652: INC
60653: ST_TO_ADDR
60654: LD_INT 5
60656: PUSH
60657: FOR_DOWNTO
60658: IFFALSE 60684
// tmp := tmp union eng [ i ] ;
60660: LD_ADDR_VAR 0 4
60664: PUSH
60665: LD_VAR 0 4
60669: PUSH
60670: LD_VAR 0 6
60674: PUSH
60675: LD_VAR 0 3
60679: ARRAY
60680: UNION
60681: ST_TO_ADDR
60682: GO 60657
60684: POP
60685: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60686: LD_ADDR_VAR 0 2
60690: PUSH
60691: LD_VAR 0 2
60695: PPUSH
60696: LD_INT 1
60698: PPUSH
60699: LD_VAR 0 4
60703: PUSH
60704: LD_VAR 0 5
60708: DIFF
60709: PPUSH
60710: CALL_OW 1
60714: ST_TO_ADDR
// exit ;
60715: GO 60717
// end ; end ;
60717: LD_VAR 0 2
60721: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60722: LD_INT 0
60724: PPUSH
60725: PPUSH
60726: PPUSH
// if not mc_bases then
60727: LD_EXP 23
60731: NOT
60732: IFFALSE 60736
// exit ;
60734: GO 60878
// for i = 1 to mc_bases do
60736: LD_ADDR_VAR 0 2
60740: PUSH
60741: DOUBLE
60742: LD_INT 1
60744: DEC
60745: ST_TO_ADDR
60746: LD_EXP 23
60750: PUSH
60751: FOR_TO
60752: IFFALSE 60869
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60754: LD_ADDR_VAR 0 3
60758: PUSH
60759: LD_EXP 23
60763: PUSH
60764: LD_VAR 0 2
60768: ARRAY
60769: PPUSH
60770: LD_INT 21
60772: PUSH
60773: LD_INT 3
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: PUSH
60780: LD_INT 3
60782: PUSH
60783: LD_INT 2
60785: PUSH
60786: LD_INT 30
60788: PUSH
60789: LD_INT 29
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: PUSH
60796: LD_INT 30
60798: PUSH
60799: LD_INT 30
60801: PUSH
60802: EMPTY
60803: LIST
60804: LIST
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: LIST
60810: PUSH
60811: EMPTY
60812: LIST
60813: LIST
60814: PUSH
60815: LD_INT 3
60817: PUSH
60818: LD_INT 24
60820: PUSH
60821: LD_INT 1000
60823: PUSH
60824: EMPTY
60825: LIST
60826: LIST
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: EMPTY
60833: LIST
60834: LIST
60835: LIST
60836: PPUSH
60837: CALL_OW 72
60841: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60842: LD_ADDR_EXP 24
60846: PUSH
60847: LD_EXP 24
60851: PPUSH
60852: LD_VAR 0 2
60856: PPUSH
60857: LD_VAR 0 3
60861: PPUSH
60862: CALL_OW 1
60866: ST_TO_ADDR
// end ;
60867: GO 60751
60869: POP
60870: POP
// RaiseSailEvent ( 101 ) ;
60871: LD_INT 101
60873: PPUSH
60874: CALL_OW 427
// end ;
60878: LD_VAR 0 1
60882: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60883: LD_INT 0
60885: PPUSH
60886: PPUSH
60887: PPUSH
60888: PPUSH
60889: PPUSH
60890: PPUSH
60891: PPUSH
// if not mc_bases then
60892: LD_EXP 23
60896: NOT
60897: IFFALSE 60901
// exit ;
60899: GO 61463
// for i = 1 to mc_bases do
60901: LD_ADDR_VAR 0 2
60905: PUSH
60906: DOUBLE
60907: LD_INT 1
60909: DEC
60910: ST_TO_ADDR
60911: LD_EXP 23
60915: PUSH
60916: FOR_TO
60917: IFFALSE 61454
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60919: LD_ADDR_VAR 0 5
60923: PUSH
60924: LD_EXP 23
60928: PUSH
60929: LD_VAR 0 2
60933: ARRAY
60934: PUSH
60935: LD_EXP 52
60939: PUSH
60940: LD_VAR 0 2
60944: ARRAY
60945: UNION
60946: PPUSH
60947: LD_INT 21
60949: PUSH
60950: LD_INT 1
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: PUSH
60957: LD_INT 1
60959: PUSH
60960: LD_INT 3
60962: PUSH
60963: LD_INT 54
60965: PUSH
60966: EMPTY
60967: LIST
60968: PUSH
60969: EMPTY
60970: LIST
60971: LIST
60972: PUSH
60973: LD_INT 3
60975: PUSH
60976: LD_INT 24
60978: PUSH
60979: LD_INT 1000
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: PUSH
60986: EMPTY
60987: LIST
60988: LIST
60989: PUSH
60990: EMPTY
60991: LIST
60992: LIST
60993: LIST
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PPUSH
60999: CALL_OW 72
61003: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
61004: LD_ADDR_VAR 0 6
61008: PUSH
61009: LD_EXP 23
61013: PUSH
61014: LD_VAR 0 2
61018: ARRAY
61019: PPUSH
61020: LD_INT 21
61022: PUSH
61023: LD_INT 1
61025: PUSH
61026: EMPTY
61027: LIST
61028: LIST
61029: PUSH
61030: LD_INT 1
61032: PUSH
61033: LD_INT 3
61035: PUSH
61036: LD_INT 54
61038: PUSH
61039: EMPTY
61040: LIST
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: LD_INT 3
61048: PUSH
61049: LD_INT 24
61051: PUSH
61052: LD_INT 250
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: EMPTY
61060: LIST
61061: LIST
61062: PUSH
61063: EMPTY
61064: LIST
61065: LIST
61066: LIST
61067: PUSH
61068: EMPTY
61069: LIST
61070: LIST
61071: PPUSH
61072: CALL_OW 72
61076: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
61077: LD_ADDR_VAR 0 7
61081: PUSH
61082: LD_VAR 0 5
61086: PUSH
61087: LD_VAR 0 6
61091: DIFF
61092: ST_TO_ADDR
// if not need_heal_1 then
61093: LD_VAR 0 6
61097: NOT
61098: IFFALSE 61131
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
61100: LD_ADDR_EXP 26
61104: PUSH
61105: LD_EXP 26
61109: PPUSH
61110: LD_VAR 0 2
61114: PUSH
61115: LD_INT 1
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: PPUSH
61122: EMPTY
61123: PPUSH
61124: CALL 16110 0 3
61128: ST_TO_ADDR
61129: GO 61201
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
61131: LD_ADDR_EXP 26
61135: PUSH
61136: LD_EXP 26
61140: PPUSH
61141: LD_VAR 0 2
61145: PUSH
61146: LD_INT 1
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PPUSH
61153: LD_EXP 26
61157: PUSH
61158: LD_VAR 0 2
61162: ARRAY
61163: PUSH
61164: LD_INT 1
61166: ARRAY
61167: PPUSH
61168: LD_INT 3
61170: PUSH
61171: LD_INT 24
61173: PUSH
61174: LD_INT 1000
61176: PUSH
61177: EMPTY
61178: LIST
61179: LIST
61180: PUSH
61181: EMPTY
61182: LIST
61183: LIST
61184: PPUSH
61185: CALL_OW 72
61189: PUSH
61190: LD_VAR 0 6
61194: UNION
61195: PPUSH
61196: CALL 16110 0 3
61200: ST_TO_ADDR
// if not need_heal_2 then
61201: LD_VAR 0 7
61205: NOT
61206: IFFALSE 61239
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
61208: LD_ADDR_EXP 26
61212: PUSH
61213: LD_EXP 26
61217: PPUSH
61218: LD_VAR 0 2
61222: PUSH
61223: LD_INT 2
61225: PUSH
61226: EMPTY
61227: LIST
61228: LIST
61229: PPUSH
61230: EMPTY
61231: PPUSH
61232: CALL 16110 0 3
61236: ST_TO_ADDR
61237: GO 61271
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
61239: LD_ADDR_EXP 26
61243: PUSH
61244: LD_EXP 26
61248: PPUSH
61249: LD_VAR 0 2
61253: PUSH
61254: LD_INT 2
61256: PUSH
61257: EMPTY
61258: LIST
61259: LIST
61260: PPUSH
61261: LD_VAR 0 7
61265: PPUSH
61266: CALL 16110 0 3
61270: ST_TO_ADDR
// if need_heal_2 then
61271: LD_VAR 0 7
61275: IFFALSE 61436
// for j in need_heal_2 do
61277: LD_ADDR_VAR 0 3
61281: PUSH
61282: LD_VAR 0 7
61286: PUSH
61287: FOR_IN
61288: IFFALSE 61434
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61290: LD_ADDR_VAR 0 5
61294: PUSH
61295: LD_EXP 23
61299: PUSH
61300: LD_VAR 0 2
61304: ARRAY
61305: PPUSH
61306: LD_INT 2
61308: PUSH
61309: LD_INT 30
61311: PUSH
61312: LD_INT 6
61314: PUSH
61315: EMPTY
61316: LIST
61317: LIST
61318: PUSH
61319: LD_INT 30
61321: PUSH
61322: LD_INT 7
61324: PUSH
61325: EMPTY
61326: LIST
61327: LIST
61328: PUSH
61329: LD_INT 30
61331: PUSH
61332: LD_INT 8
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: PUSH
61339: LD_INT 30
61341: PUSH
61342: LD_INT 0
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PUSH
61349: LD_INT 30
61351: PUSH
61352: LD_INT 1
61354: PUSH
61355: EMPTY
61356: LIST
61357: LIST
61358: PUSH
61359: EMPTY
61360: LIST
61361: LIST
61362: LIST
61363: LIST
61364: LIST
61365: LIST
61366: PPUSH
61367: CALL_OW 72
61371: ST_TO_ADDR
// if tmp then
61372: LD_VAR 0 5
61376: IFFALSE 61432
// begin k := NearestUnitToUnit ( tmp , j ) ;
61378: LD_ADDR_VAR 0 4
61382: PUSH
61383: LD_VAR 0 5
61387: PPUSH
61388: LD_VAR 0 3
61392: PPUSH
61393: CALL_OW 74
61397: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
61398: LD_VAR 0 3
61402: PPUSH
61403: LD_VAR 0 4
61407: PPUSH
61408: CALL_OW 296
61412: PUSH
61413: LD_INT 5
61415: GREATER
61416: IFFALSE 61432
// ComMoveToNearbyEntrance ( j , k ) ;
61418: LD_VAR 0 3
61422: PPUSH
61423: LD_VAR 0 4
61427: PPUSH
61428: CALL 49318 0 2
// end ; end ;
61432: GO 61287
61434: POP
61435: POP
// if not need_heal_1 and not need_heal_2 then
61436: LD_VAR 0 6
61440: NOT
61441: PUSH
61442: LD_VAR 0 7
61446: NOT
61447: AND
61448: IFFALSE 61452
// continue ;
61450: GO 60916
// end ;
61452: GO 60916
61454: POP
61455: POP
// RaiseSailEvent ( 102 ) ;
61456: LD_INT 102
61458: PPUSH
61459: CALL_OW 427
// end ;
61463: LD_VAR 0 1
61467: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61468: LD_INT 0
61470: PPUSH
61471: PPUSH
61472: PPUSH
61473: PPUSH
61474: PPUSH
61475: PPUSH
61476: PPUSH
61477: PPUSH
// if not mc_bases then
61478: LD_EXP 23
61482: NOT
61483: IFFALSE 61487
// exit ;
61485: GO 62398
// for i = 1 to mc_bases do
61487: LD_ADDR_VAR 0 2
61491: PUSH
61492: DOUBLE
61493: LD_INT 1
61495: DEC
61496: ST_TO_ADDR
61497: LD_EXP 23
61501: PUSH
61502: FOR_TO
61503: IFFALSE 62396
// begin if not mc_building_need_repair [ i ] then
61505: LD_EXP 24
61509: PUSH
61510: LD_VAR 0 2
61514: ARRAY
61515: NOT
61516: IFFALSE 61701
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61518: LD_ADDR_VAR 0 6
61522: PUSH
61523: LD_EXP 42
61527: PUSH
61528: LD_VAR 0 2
61532: ARRAY
61533: PPUSH
61534: LD_INT 3
61536: PUSH
61537: LD_INT 24
61539: PUSH
61540: LD_INT 1000
61542: PUSH
61543: EMPTY
61544: LIST
61545: LIST
61546: PUSH
61547: EMPTY
61548: LIST
61549: LIST
61550: PUSH
61551: LD_INT 2
61553: PUSH
61554: LD_INT 34
61556: PUSH
61557: LD_INT 13
61559: PUSH
61560: EMPTY
61561: LIST
61562: LIST
61563: PUSH
61564: LD_INT 34
61566: PUSH
61567: LD_INT 52
61569: PUSH
61570: EMPTY
61571: LIST
61572: LIST
61573: PUSH
61574: LD_INT 34
61576: PUSH
61577: LD_INT 88
61579: PUSH
61580: EMPTY
61581: LIST
61582: LIST
61583: PUSH
61584: EMPTY
61585: LIST
61586: LIST
61587: LIST
61588: LIST
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: PPUSH
61594: CALL_OW 72
61598: ST_TO_ADDR
// if cranes then
61599: LD_VAR 0 6
61603: IFFALSE 61665
// for j in cranes do
61605: LD_ADDR_VAR 0 3
61609: PUSH
61610: LD_VAR 0 6
61614: PUSH
61615: FOR_IN
61616: IFFALSE 61663
// if not IsInArea ( j , mc_parking [ i ] ) then
61618: LD_VAR 0 3
61622: PPUSH
61623: LD_EXP 47
61627: PUSH
61628: LD_VAR 0 2
61632: ARRAY
61633: PPUSH
61634: CALL_OW 308
61638: NOT
61639: IFFALSE 61661
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61641: LD_VAR 0 3
61645: PPUSH
61646: LD_EXP 47
61650: PUSH
61651: LD_VAR 0 2
61655: ARRAY
61656: PPUSH
61657: CALL_OW 113
61661: GO 61615
61663: POP
61664: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61665: LD_ADDR_EXP 25
61669: PUSH
61670: LD_EXP 25
61674: PPUSH
61675: LD_VAR 0 2
61679: PPUSH
61680: EMPTY
61681: PPUSH
61682: CALL_OW 1
61686: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61687: LD_VAR 0 2
61691: PPUSH
61692: LD_INT 101
61694: PPUSH
61695: CALL 56555 0 2
// continue ;
61699: GO 61502
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61701: LD_ADDR_EXP 29
61705: PUSH
61706: LD_EXP 29
61710: PPUSH
61711: LD_VAR 0 2
61715: PPUSH
61716: EMPTY
61717: PPUSH
61718: CALL_OW 1
61722: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61723: LD_VAR 0 2
61727: PPUSH
61728: LD_INT 103
61730: PPUSH
61731: CALL 56555 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
61735: LD_ADDR_VAR 0 5
61739: PUSH
61740: LD_EXP 23
61744: PUSH
61745: LD_VAR 0 2
61749: ARRAY
61750: PUSH
61751: LD_EXP 52
61755: PUSH
61756: LD_VAR 0 2
61760: ARRAY
61761: UNION
61762: PPUSH
61763: LD_INT 2
61765: PUSH
61766: LD_INT 25
61768: PUSH
61769: LD_INT 2
61771: PUSH
61772: EMPTY
61773: LIST
61774: LIST
61775: PUSH
61776: LD_INT 25
61778: PUSH
61779: LD_INT 16
61781: PUSH
61782: EMPTY
61783: LIST
61784: LIST
61785: PUSH
61786: EMPTY
61787: LIST
61788: LIST
61789: LIST
61790: PUSH
61791: EMPTY
61792: LIST
61793: PPUSH
61794: CALL_OW 72
61798: ST_TO_ADDR
// if mc_need_heal [ i ] then
61799: LD_EXP 26
61803: PUSH
61804: LD_VAR 0 2
61808: ARRAY
61809: IFFALSE 61853
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61811: LD_ADDR_VAR 0 5
61815: PUSH
61816: LD_VAR 0 5
61820: PUSH
61821: LD_EXP 26
61825: PUSH
61826: LD_VAR 0 2
61830: ARRAY
61831: PUSH
61832: LD_INT 1
61834: ARRAY
61835: PUSH
61836: LD_EXP 26
61840: PUSH
61841: LD_VAR 0 2
61845: ARRAY
61846: PUSH
61847: LD_INT 2
61849: ARRAY
61850: UNION
61851: DIFF
61852: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61853: LD_ADDR_VAR 0 6
61857: PUSH
61858: LD_EXP 42
61862: PUSH
61863: LD_VAR 0 2
61867: ARRAY
61868: PPUSH
61869: LD_INT 2
61871: PUSH
61872: LD_INT 34
61874: PUSH
61875: LD_INT 13
61877: PUSH
61878: EMPTY
61879: LIST
61880: LIST
61881: PUSH
61882: LD_INT 34
61884: PUSH
61885: LD_INT 52
61887: PUSH
61888: EMPTY
61889: LIST
61890: LIST
61891: PUSH
61892: LD_INT 34
61894: PUSH
61895: LD_INT 88
61897: PUSH
61898: EMPTY
61899: LIST
61900: LIST
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: LIST
61906: LIST
61907: PPUSH
61908: CALL_OW 72
61912: ST_TO_ADDR
// if cranes then
61913: LD_VAR 0 6
61917: IFFALSE 62085
// begin for j in cranes do
61919: LD_ADDR_VAR 0 3
61923: PUSH
61924: LD_VAR 0 6
61928: PUSH
61929: FOR_IN
61930: IFFALSE 62083
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61932: LD_VAR 0 3
61936: PPUSH
61937: CALL_OW 256
61941: PUSH
61942: LD_INT 1000
61944: EQUAL
61945: PUSH
61946: LD_VAR 0 3
61950: PPUSH
61951: CALL_OW 314
61955: NOT
61956: AND
61957: IFFALSE 62023
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
61959: LD_ADDR_VAR 0 8
61963: PUSH
61964: LD_EXP 24
61968: PUSH
61969: LD_VAR 0 2
61973: ARRAY
61974: PPUSH
61975: LD_VAR 0 3
61979: PPUSH
61980: CALL_OW 74
61984: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61985: LD_VAR 0 8
61989: PPUSH
61990: LD_INT 16
61992: PPUSH
61993: CALL 18707 0 2
61997: PUSH
61998: LD_INT 4
62000: ARRAY
62001: PUSH
62002: LD_INT 10
62004: LESS
62005: IFFALSE 62021
// ComRepairBuilding ( j , to_repair ) ;
62007: LD_VAR 0 3
62011: PPUSH
62012: LD_VAR 0 8
62016: PPUSH
62017: CALL_OW 130
// end else
62021: GO 62081
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
62023: LD_VAR 0 3
62027: PPUSH
62028: CALL_OW 256
62032: PUSH
62033: LD_INT 500
62035: LESS
62036: PUSH
62037: LD_VAR 0 3
62041: PPUSH
62042: LD_EXP 47
62046: PUSH
62047: LD_VAR 0 2
62051: ARRAY
62052: PPUSH
62053: CALL_OW 308
62057: NOT
62058: AND
62059: IFFALSE 62081
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62061: LD_VAR 0 3
62065: PPUSH
62066: LD_EXP 47
62070: PUSH
62071: LD_VAR 0 2
62075: ARRAY
62076: PPUSH
62077: CALL_OW 113
// end ;
62081: GO 61929
62083: POP
62084: POP
// end ; if tmp > 3 then
62085: LD_VAR 0 5
62089: PUSH
62090: LD_INT 3
62092: GREATER
62093: IFFALSE 62113
// tmp := ShrinkArray ( tmp , 4 ) ;
62095: LD_ADDR_VAR 0 5
62099: PUSH
62100: LD_VAR 0 5
62104: PPUSH
62105: LD_INT 4
62107: PPUSH
62108: CALL 48756 0 2
62112: ST_TO_ADDR
// if not tmp then
62113: LD_VAR 0 5
62117: NOT
62118: IFFALSE 62122
// continue ;
62120: GO 61502
// for j in tmp do
62122: LD_ADDR_VAR 0 3
62126: PUSH
62127: LD_VAR 0 5
62131: PUSH
62132: FOR_IN
62133: IFFALSE 62392
// begin if IsInUnit ( j ) then
62135: LD_VAR 0 3
62139: PPUSH
62140: CALL_OW 310
62144: IFFALSE 62155
// ComExitBuilding ( j ) ;
62146: LD_VAR 0 3
62150: PPUSH
62151: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
62155: LD_VAR 0 3
62159: PUSH
62160: LD_EXP 25
62164: PUSH
62165: LD_VAR 0 2
62169: ARRAY
62170: IN
62171: NOT
62172: IFFALSE 62230
// begin SetTag ( j , 101 ) ;
62174: LD_VAR 0 3
62178: PPUSH
62179: LD_INT 101
62181: PPUSH
62182: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
62186: LD_ADDR_EXP 25
62190: PUSH
62191: LD_EXP 25
62195: PPUSH
62196: LD_VAR 0 2
62200: PUSH
62201: LD_EXP 25
62205: PUSH
62206: LD_VAR 0 2
62210: ARRAY
62211: PUSH
62212: LD_INT 1
62214: PLUS
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: PPUSH
62220: LD_VAR 0 3
62224: PPUSH
62225: CALL 16110 0 3
62229: ST_TO_ADDR
// end ; wait ( 1 ) ;
62230: LD_INT 1
62232: PPUSH
62233: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
62237: LD_ADDR_VAR 0 7
62241: PUSH
62242: LD_EXP 24
62246: PUSH
62247: LD_VAR 0 2
62251: ARRAY
62252: ST_TO_ADDR
// if mc_scan [ i ] then
62253: LD_EXP 46
62257: PUSH
62258: LD_VAR 0 2
62262: ARRAY
62263: IFFALSE 62325
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
62265: LD_ADDR_VAR 0 7
62269: PUSH
62270: LD_EXP 24
62274: PUSH
62275: LD_VAR 0 2
62279: ARRAY
62280: PPUSH
62281: LD_INT 3
62283: PUSH
62284: LD_INT 30
62286: PUSH
62287: LD_INT 32
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 30
62296: PUSH
62297: LD_INT 33
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: LD_INT 30
62306: PUSH
62307: LD_INT 31
62309: PUSH
62310: EMPTY
62311: LIST
62312: LIST
62313: PUSH
62314: EMPTY
62315: LIST
62316: LIST
62317: LIST
62318: LIST
62319: PPUSH
62320: CALL_OW 72
62324: ST_TO_ADDR
// if not to_repair_tmp then
62325: LD_VAR 0 7
62329: NOT
62330: IFFALSE 62334
// continue ;
62332: GO 62132
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
62334: LD_ADDR_VAR 0 8
62338: PUSH
62339: LD_VAR 0 7
62343: PPUSH
62344: LD_VAR 0 3
62348: PPUSH
62349: CALL_OW 74
62353: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
62354: LD_VAR 0 8
62358: PPUSH
62359: LD_INT 16
62361: PPUSH
62362: CALL 18707 0 2
62366: PUSH
62367: LD_INT 4
62369: ARRAY
62370: PUSH
62371: LD_INT 14
62373: LESS
62374: IFFALSE 62390
// ComRepairBuilding ( j , to_repair ) ;
62376: LD_VAR 0 3
62380: PPUSH
62381: LD_VAR 0 8
62385: PPUSH
62386: CALL_OW 130
// end ;
62390: GO 62132
62392: POP
62393: POP
// end ;
62394: GO 61502
62396: POP
62397: POP
// end ;
62398: LD_VAR 0 1
62402: RET
// export function MC_Heal ; var i , j , tmp ; begin
62403: LD_INT 0
62405: PPUSH
62406: PPUSH
62407: PPUSH
62408: PPUSH
// if not mc_bases then
62409: LD_EXP 23
62413: NOT
62414: IFFALSE 62418
// exit ;
62416: GO 62820
// for i = 1 to mc_bases do
62418: LD_ADDR_VAR 0 2
62422: PUSH
62423: DOUBLE
62424: LD_INT 1
62426: DEC
62427: ST_TO_ADDR
62428: LD_EXP 23
62432: PUSH
62433: FOR_TO
62434: IFFALSE 62818
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
62436: LD_EXP 26
62440: PUSH
62441: LD_VAR 0 2
62445: ARRAY
62446: PUSH
62447: LD_INT 1
62449: ARRAY
62450: NOT
62451: PUSH
62452: LD_EXP 26
62456: PUSH
62457: LD_VAR 0 2
62461: ARRAY
62462: PUSH
62463: LD_INT 2
62465: ARRAY
62466: NOT
62467: AND
62468: IFFALSE 62506
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
62470: LD_ADDR_EXP 27
62474: PUSH
62475: LD_EXP 27
62479: PPUSH
62480: LD_VAR 0 2
62484: PPUSH
62485: EMPTY
62486: PPUSH
62487: CALL_OW 1
62491: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
62492: LD_VAR 0 2
62496: PPUSH
62497: LD_INT 102
62499: PPUSH
62500: CALL 56555 0 2
// continue ;
62504: GO 62433
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62506: LD_ADDR_VAR 0 4
62510: PUSH
62511: LD_EXP 23
62515: PUSH
62516: LD_VAR 0 2
62520: ARRAY
62521: PPUSH
62522: LD_INT 25
62524: PUSH
62525: LD_INT 4
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PPUSH
62532: CALL_OW 72
62536: ST_TO_ADDR
// if not tmp then
62537: LD_VAR 0 4
62541: NOT
62542: IFFALSE 62546
// continue ;
62544: GO 62433
// if mc_taming [ i ] then
62546: LD_EXP 54
62550: PUSH
62551: LD_VAR 0 2
62555: ARRAY
62556: IFFALSE 62580
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62558: LD_ADDR_EXP 54
62562: PUSH
62563: LD_EXP 54
62567: PPUSH
62568: LD_VAR 0 2
62572: PPUSH
62573: EMPTY
62574: PPUSH
62575: CALL_OW 1
62579: ST_TO_ADDR
// for j in tmp do
62580: LD_ADDR_VAR 0 3
62584: PUSH
62585: LD_VAR 0 4
62589: PUSH
62590: FOR_IN
62591: IFFALSE 62814
// begin if IsInUnit ( j ) then
62593: LD_VAR 0 3
62597: PPUSH
62598: CALL_OW 310
62602: IFFALSE 62613
// ComExitBuilding ( j ) ;
62604: LD_VAR 0 3
62608: PPUSH
62609: CALL_OW 122
// if not j in mc_healers [ i ] then
62613: LD_VAR 0 3
62617: PUSH
62618: LD_EXP 27
62622: PUSH
62623: LD_VAR 0 2
62627: ARRAY
62628: IN
62629: NOT
62630: IFFALSE 62676
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62632: LD_ADDR_EXP 27
62636: PUSH
62637: LD_EXP 27
62641: PPUSH
62642: LD_VAR 0 2
62646: PUSH
62647: LD_EXP 27
62651: PUSH
62652: LD_VAR 0 2
62656: ARRAY
62657: PUSH
62658: LD_INT 1
62660: PLUS
62661: PUSH
62662: EMPTY
62663: LIST
62664: LIST
62665: PPUSH
62666: LD_VAR 0 3
62670: PPUSH
62671: CALL 16110 0 3
62675: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62676: LD_VAR 0 3
62680: PPUSH
62681: CALL_OW 110
62685: PUSH
62686: LD_INT 102
62688: NONEQUAL
62689: IFFALSE 62703
// SetTag ( j , 102 ) ;
62691: LD_VAR 0 3
62695: PPUSH
62696: LD_INT 102
62698: PPUSH
62699: CALL_OW 109
// Wait ( 3 ) ;
62703: LD_INT 3
62705: PPUSH
62706: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62710: LD_EXP 26
62714: PUSH
62715: LD_VAR 0 2
62719: ARRAY
62720: PUSH
62721: LD_INT 1
62723: ARRAY
62724: IFFALSE 62756
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62726: LD_VAR 0 3
62730: PPUSH
62731: LD_EXP 26
62735: PUSH
62736: LD_VAR 0 2
62740: ARRAY
62741: PUSH
62742: LD_INT 1
62744: ARRAY
62745: PUSH
62746: LD_INT 1
62748: ARRAY
62749: PPUSH
62750: CALL_OW 128
62754: GO 62812
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62756: LD_VAR 0 3
62760: PPUSH
62761: CALL_OW 314
62765: NOT
62766: PUSH
62767: LD_EXP 26
62771: PUSH
62772: LD_VAR 0 2
62776: ARRAY
62777: PUSH
62778: LD_INT 2
62780: ARRAY
62781: AND
62782: IFFALSE 62812
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62784: LD_VAR 0 3
62788: PPUSH
62789: LD_EXP 26
62793: PUSH
62794: LD_VAR 0 2
62798: ARRAY
62799: PUSH
62800: LD_INT 2
62802: ARRAY
62803: PUSH
62804: LD_INT 1
62806: ARRAY
62807: PPUSH
62808: CALL_OW 128
// end ;
62812: GO 62590
62814: POP
62815: POP
// end ;
62816: GO 62433
62818: POP
62819: POP
// end ;
62820: LD_VAR 0 1
62824: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
62825: LD_INT 0
62827: PPUSH
62828: PPUSH
62829: PPUSH
62830: PPUSH
62831: PPUSH
62832: PPUSH
// if not mc_bases then
62833: LD_EXP 23
62837: NOT
62838: IFFALSE 62842
// exit ;
62840: GO 64005
// for i = 1 to mc_bases do
62842: LD_ADDR_VAR 0 2
62846: PUSH
62847: DOUBLE
62848: LD_INT 1
62850: DEC
62851: ST_TO_ADDR
62852: LD_EXP 23
62856: PUSH
62857: FOR_TO
62858: IFFALSE 64003
// begin if mc_scan [ i ] then
62860: LD_EXP 46
62864: PUSH
62865: LD_VAR 0 2
62869: ARRAY
62870: IFFALSE 62874
// continue ;
62872: GO 62857
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62874: LD_EXP 28
62878: PUSH
62879: LD_VAR 0 2
62883: ARRAY
62884: NOT
62885: PUSH
62886: LD_EXP 30
62890: PUSH
62891: LD_VAR 0 2
62895: ARRAY
62896: NOT
62897: AND
62898: PUSH
62899: LD_EXP 29
62903: PUSH
62904: LD_VAR 0 2
62908: ARRAY
62909: AND
62910: IFFALSE 62948
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62912: LD_ADDR_EXP 29
62916: PUSH
62917: LD_EXP 29
62921: PPUSH
62922: LD_VAR 0 2
62926: PPUSH
62927: EMPTY
62928: PPUSH
62929: CALL_OW 1
62933: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62934: LD_VAR 0 2
62938: PPUSH
62939: LD_INT 103
62941: PPUSH
62942: CALL 56555 0 2
// continue ;
62946: GO 62857
// end ; if mc_construct_list [ i ] then
62948: LD_EXP 30
62952: PUSH
62953: LD_VAR 0 2
62957: ARRAY
62958: IFFALSE 63178
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62960: LD_ADDR_VAR 0 5
62964: PUSH
62965: LD_EXP 23
62969: PUSH
62970: LD_VAR 0 2
62974: ARRAY
62975: PPUSH
62976: LD_INT 25
62978: PUSH
62979: LD_INT 2
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PPUSH
62986: CALL_OW 72
62990: PUSH
62991: LD_EXP 25
62995: PUSH
62996: LD_VAR 0 2
63000: ARRAY
63001: DIFF
63002: ST_TO_ADDR
// if not tmp then
63003: LD_VAR 0 5
63007: NOT
63008: IFFALSE 63012
// continue ;
63010: GO 62857
// for j in tmp do
63012: LD_ADDR_VAR 0 3
63016: PUSH
63017: LD_VAR 0 5
63021: PUSH
63022: FOR_IN
63023: IFFALSE 63174
// begin if not mc_builders [ i ] then
63025: LD_EXP 29
63029: PUSH
63030: LD_VAR 0 2
63034: ARRAY
63035: NOT
63036: IFFALSE 63094
// begin SetTag ( j , 103 ) ;
63038: LD_VAR 0 3
63042: PPUSH
63043: LD_INT 103
63045: PPUSH
63046: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63050: LD_ADDR_EXP 29
63054: PUSH
63055: LD_EXP 29
63059: PPUSH
63060: LD_VAR 0 2
63064: PUSH
63065: LD_EXP 29
63069: PUSH
63070: LD_VAR 0 2
63074: ARRAY
63075: PUSH
63076: LD_INT 1
63078: PLUS
63079: PUSH
63080: EMPTY
63081: LIST
63082: LIST
63083: PPUSH
63084: LD_VAR 0 3
63088: PPUSH
63089: CALL 16110 0 3
63093: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63094: LD_VAR 0 3
63098: PPUSH
63099: CALL_OW 310
63103: IFFALSE 63114
// ComExitBuilding ( j ) ;
63105: LD_VAR 0 3
63109: PPUSH
63110: CALL_OW 122
// wait ( 3 ) ;
63114: LD_INT 3
63116: PPUSH
63117: CALL_OW 67
// if not mc_construct_list [ i ] then
63121: LD_EXP 30
63125: PUSH
63126: LD_VAR 0 2
63130: ARRAY
63131: NOT
63132: IFFALSE 63136
// break ;
63134: GO 63174
// if not HasTask ( j ) then
63136: LD_VAR 0 3
63140: PPUSH
63141: CALL_OW 314
63145: NOT
63146: IFFALSE 63172
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
63148: LD_VAR 0 3
63152: PPUSH
63153: LD_EXP 30
63157: PUSH
63158: LD_VAR 0 2
63162: ARRAY
63163: PUSH
63164: LD_INT 1
63166: ARRAY
63167: PPUSH
63168: CALL 18971 0 2
// end ;
63172: GO 63022
63174: POP
63175: POP
// end else
63176: GO 64001
// if mc_build_list [ i ] then
63178: LD_EXP 28
63182: PUSH
63183: LD_VAR 0 2
63187: ARRAY
63188: IFFALSE 64001
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
63190: LD_EXP 28
63194: PUSH
63195: LD_VAR 0 2
63199: ARRAY
63200: PUSH
63201: LD_INT 1
63203: ARRAY
63204: PUSH
63205: LD_INT 1
63207: ARRAY
63208: PPUSH
63209: CALL 18795 0 1
63213: PUSH
63214: LD_EXP 23
63218: PUSH
63219: LD_VAR 0 2
63223: ARRAY
63224: PPUSH
63225: LD_INT 2
63227: PUSH
63228: LD_INT 30
63230: PUSH
63231: LD_INT 2
63233: PUSH
63234: EMPTY
63235: LIST
63236: LIST
63237: PUSH
63238: LD_INT 30
63240: PUSH
63241: LD_INT 3
63243: PUSH
63244: EMPTY
63245: LIST
63246: LIST
63247: PUSH
63248: EMPTY
63249: LIST
63250: LIST
63251: LIST
63252: PPUSH
63253: CALL_OW 72
63257: NOT
63258: AND
63259: IFFALSE 63364
// begin for j = 1 to mc_build_list [ i ] do
63261: LD_ADDR_VAR 0 3
63265: PUSH
63266: DOUBLE
63267: LD_INT 1
63269: DEC
63270: ST_TO_ADDR
63271: LD_EXP 28
63275: PUSH
63276: LD_VAR 0 2
63280: ARRAY
63281: PUSH
63282: FOR_TO
63283: IFFALSE 63362
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
63285: LD_EXP 28
63289: PUSH
63290: LD_VAR 0 2
63294: ARRAY
63295: PUSH
63296: LD_VAR 0 3
63300: ARRAY
63301: PUSH
63302: LD_INT 1
63304: ARRAY
63305: PUSH
63306: LD_INT 2
63308: EQUAL
63309: IFFALSE 63360
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
63311: LD_ADDR_EXP 28
63315: PUSH
63316: LD_EXP 28
63320: PPUSH
63321: LD_VAR 0 2
63325: PPUSH
63326: LD_EXP 28
63330: PUSH
63331: LD_VAR 0 2
63335: ARRAY
63336: PPUSH
63337: LD_VAR 0 3
63341: PPUSH
63342: LD_INT 1
63344: PPUSH
63345: LD_INT 0
63347: PPUSH
63348: CALL 15528 0 4
63352: PPUSH
63353: CALL_OW 1
63357: ST_TO_ADDR
// break ;
63358: GO 63362
// end ;
63360: GO 63282
63362: POP
63363: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63364: LD_ADDR_VAR 0 6
63368: PUSH
63369: LD_EXP 23
63373: PUSH
63374: LD_VAR 0 2
63378: ARRAY
63379: PPUSH
63380: LD_INT 2
63382: PUSH
63383: LD_INT 30
63385: PUSH
63386: LD_INT 0
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: PUSH
63393: LD_INT 30
63395: PUSH
63396: LD_INT 1
63398: PUSH
63399: EMPTY
63400: LIST
63401: LIST
63402: PUSH
63403: EMPTY
63404: LIST
63405: LIST
63406: LIST
63407: PPUSH
63408: CALL_OW 72
63412: ST_TO_ADDR
// for k := 1 to depot do
63413: LD_ADDR_VAR 0 4
63417: PUSH
63418: DOUBLE
63419: LD_INT 1
63421: DEC
63422: ST_TO_ADDR
63423: LD_VAR 0 6
63427: PUSH
63428: FOR_TO
63429: IFFALSE 63999
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
63431: LD_EXP 28
63435: PUSH
63436: LD_VAR 0 2
63440: ARRAY
63441: PUSH
63442: LD_INT 1
63444: ARRAY
63445: PUSH
63446: LD_INT 1
63448: ARRAY
63449: PUSH
63450: LD_INT 0
63452: EQUAL
63453: PUSH
63454: LD_VAR 0 6
63458: PUSH
63459: LD_VAR 0 4
63463: ARRAY
63464: PPUSH
63465: LD_EXP 28
63469: PUSH
63470: LD_VAR 0 2
63474: ARRAY
63475: PUSH
63476: LD_INT 1
63478: ARRAY
63479: PUSH
63480: LD_INT 1
63482: ARRAY
63483: PPUSH
63484: LD_EXP 28
63488: PUSH
63489: LD_VAR 0 2
63493: ARRAY
63494: PUSH
63495: LD_INT 1
63497: ARRAY
63498: PUSH
63499: LD_INT 2
63501: ARRAY
63502: PPUSH
63503: LD_EXP 28
63507: PUSH
63508: LD_VAR 0 2
63512: ARRAY
63513: PUSH
63514: LD_INT 1
63516: ARRAY
63517: PUSH
63518: LD_INT 3
63520: ARRAY
63521: PPUSH
63522: LD_EXP 28
63526: PUSH
63527: LD_VAR 0 2
63531: ARRAY
63532: PUSH
63533: LD_INT 1
63535: ARRAY
63536: PUSH
63537: LD_INT 4
63539: ARRAY
63540: PPUSH
63541: CALL 24207 0 5
63545: OR
63546: IFFALSE 63827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63548: LD_ADDR_VAR 0 5
63552: PUSH
63553: LD_EXP 23
63557: PUSH
63558: LD_VAR 0 2
63562: ARRAY
63563: PPUSH
63564: LD_INT 25
63566: PUSH
63567: LD_INT 2
63569: PUSH
63570: EMPTY
63571: LIST
63572: LIST
63573: PPUSH
63574: CALL_OW 72
63578: PUSH
63579: LD_EXP 25
63583: PUSH
63584: LD_VAR 0 2
63588: ARRAY
63589: DIFF
63590: ST_TO_ADDR
// if not tmp then
63591: LD_VAR 0 5
63595: NOT
63596: IFFALSE 63600
// continue ;
63598: GO 63428
// for j in tmp do
63600: LD_ADDR_VAR 0 3
63604: PUSH
63605: LD_VAR 0 5
63609: PUSH
63610: FOR_IN
63611: IFFALSE 63823
// begin if not mc_builders [ i ] then
63613: LD_EXP 29
63617: PUSH
63618: LD_VAR 0 2
63622: ARRAY
63623: NOT
63624: IFFALSE 63682
// begin SetTag ( j , 103 ) ;
63626: LD_VAR 0 3
63630: PPUSH
63631: LD_INT 103
63633: PPUSH
63634: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63638: LD_ADDR_EXP 29
63642: PUSH
63643: LD_EXP 29
63647: PPUSH
63648: LD_VAR 0 2
63652: PUSH
63653: LD_EXP 29
63657: PUSH
63658: LD_VAR 0 2
63662: ARRAY
63663: PUSH
63664: LD_INT 1
63666: PLUS
63667: PUSH
63668: EMPTY
63669: LIST
63670: LIST
63671: PPUSH
63672: LD_VAR 0 3
63676: PPUSH
63677: CALL 16110 0 3
63681: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63682: LD_VAR 0 3
63686: PPUSH
63687: CALL_OW 310
63691: IFFALSE 63702
// ComExitBuilding ( j ) ;
63693: LD_VAR 0 3
63697: PPUSH
63698: CALL_OW 122
// wait ( 3 ) ;
63702: LD_INT 3
63704: PPUSH
63705: CALL_OW 67
// if not mc_build_list [ i ] then
63709: LD_EXP 28
63713: PUSH
63714: LD_VAR 0 2
63718: ARRAY
63719: NOT
63720: IFFALSE 63724
// break ;
63722: GO 63823
// if not HasTask ( j ) then
63724: LD_VAR 0 3
63728: PPUSH
63729: CALL_OW 314
63733: NOT
63734: IFFALSE 63821
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63736: LD_VAR 0 3
63740: PPUSH
63741: LD_EXP 28
63745: PUSH
63746: LD_VAR 0 2
63750: ARRAY
63751: PUSH
63752: LD_INT 1
63754: ARRAY
63755: PUSH
63756: LD_INT 1
63758: ARRAY
63759: PPUSH
63760: LD_EXP 28
63764: PUSH
63765: LD_VAR 0 2
63769: ARRAY
63770: PUSH
63771: LD_INT 1
63773: ARRAY
63774: PUSH
63775: LD_INT 2
63777: ARRAY
63778: PPUSH
63779: LD_EXP 28
63783: PUSH
63784: LD_VAR 0 2
63788: ARRAY
63789: PUSH
63790: LD_INT 1
63792: ARRAY
63793: PUSH
63794: LD_INT 3
63796: ARRAY
63797: PPUSH
63798: LD_EXP 28
63802: PUSH
63803: LD_VAR 0 2
63807: ARRAY
63808: PUSH
63809: LD_INT 1
63811: ARRAY
63812: PUSH
63813: LD_INT 4
63815: ARRAY
63816: PPUSH
63817: CALL_OW 145
// end ;
63821: GO 63610
63823: POP
63824: POP
// end else
63825: GO 63997
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63827: LD_EXP 23
63831: PUSH
63832: LD_VAR 0 2
63836: ARRAY
63837: PPUSH
63838: LD_EXP 28
63842: PUSH
63843: LD_VAR 0 2
63847: ARRAY
63848: PUSH
63849: LD_INT 1
63851: ARRAY
63852: PUSH
63853: LD_INT 1
63855: ARRAY
63856: PPUSH
63857: LD_EXP 28
63861: PUSH
63862: LD_VAR 0 2
63866: ARRAY
63867: PUSH
63868: LD_INT 1
63870: ARRAY
63871: PUSH
63872: LD_INT 2
63874: ARRAY
63875: PPUSH
63876: LD_EXP 28
63880: PUSH
63881: LD_VAR 0 2
63885: ARRAY
63886: PUSH
63887: LD_INT 1
63889: ARRAY
63890: PUSH
63891: LD_INT 3
63893: ARRAY
63894: PPUSH
63895: LD_EXP 28
63899: PUSH
63900: LD_VAR 0 2
63904: ARRAY
63905: PUSH
63906: LD_INT 1
63908: ARRAY
63909: PUSH
63910: LD_INT 4
63912: ARRAY
63913: PPUSH
63914: LD_EXP 23
63918: PUSH
63919: LD_VAR 0 2
63923: ARRAY
63924: PPUSH
63925: LD_INT 21
63927: PUSH
63928: LD_INT 3
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: PPUSH
63935: CALL_OW 72
63939: PPUSH
63940: EMPTY
63941: PPUSH
63942: CALL 22961 0 7
63946: NOT
63947: IFFALSE 63997
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63949: LD_ADDR_EXP 28
63953: PUSH
63954: LD_EXP 28
63958: PPUSH
63959: LD_VAR 0 2
63963: PPUSH
63964: LD_EXP 28
63968: PUSH
63969: LD_VAR 0 2
63973: ARRAY
63974: PPUSH
63975: LD_INT 1
63977: PPUSH
63978: LD_INT 1
63980: NEG
63981: PPUSH
63982: LD_INT 0
63984: PPUSH
63985: CALL 15528 0 4
63989: PPUSH
63990: CALL_OW 1
63994: ST_TO_ADDR
// continue ;
63995: GO 63428
// end ; end ;
63997: GO 63428
63999: POP
64000: POP
// end ; end ;
64001: GO 62857
64003: POP
64004: POP
// end ;
64005: LD_VAR 0 1
64009: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
64010: LD_INT 0
64012: PPUSH
64013: PPUSH
64014: PPUSH
64015: PPUSH
64016: PPUSH
64017: PPUSH
// if not mc_bases then
64018: LD_EXP 23
64022: NOT
64023: IFFALSE 64027
// exit ;
64025: GO 64454
// for i = 1 to mc_bases do
64027: LD_ADDR_VAR 0 2
64031: PUSH
64032: DOUBLE
64033: LD_INT 1
64035: DEC
64036: ST_TO_ADDR
64037: LD_EXP 23
64041: PUSH
64042: FOR_TO
64043: IFFALSE 64452
// begin tmp := mc_build_upgrade [ i ] ;
64045: LD_ADDR_VAR 0 4
64049: PUSH
64050: LD_EXP 55
64054: PUSH
64055: LD_VAR 0 2
64059: ARRAY
64060: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
64061: LD_ADDR_VAR 0 6
64065: PUSH
64066: LD_EXP 56
64070: PUSH
64071: LD_VAR 0 2
64075: ARRAY
64076: PPUSH
64077: LD_INT 2
64079: PUSH
64080: LD_INT 30
64082: PUSH
64083: LD_INT 6
64085: PUSH
64086: EMPTY
64087: LIST
64088: LIST
64089: PUSH
64090: LD_INT 30
64092: PUSH
64093: LD_INT 7
64095: PUSH
64096: EMPTY
64097: LIST
64098: LIST
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: LIST
64104: PPUSH
64105: CALL_OW 72
64109: ST_TO_ADDR
// if not tmp and not lab then
64110: LD_VAR 0 4
64114: NOT
64115: PUSH
64116: LD_VAR 0 6
64120: NOT
64121: AND
64122: IFFALSE 64126
// continue ;
64124: GO 64042
// if tmp then
64126: LD_VAR 0 4
64130: IFFALSE 64250
// for j in tmp do
64132: LD_ADDR_VAR 0 3
64136: PUSH
64137: LD_VAR 0 4
64141: PUSH
64142: FOR_IN
64143: IFFALSE 64248
// begin if UpgradeCost ( j ) then
64145: LD_VAR 0 3
64149: PPUSH
64150: CALL 22621 0 1
64154: IFFALSE 64246
// begin ComUpgrade ( j ) ;
64156: LD_VAR 0 3
64160: PPUSH
64161: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
64165: LD_ADDR_EXP 55
64169: PUSH
64170: LD_EXP 55
64174: PPUSH
64175: LD_VAR 0 2
64179: PPUSH
64180: LD_EXP 55
64184: PUSH
64185: LD_VAR 0 2
64189: ARRAY
64190: PUSH
64191: LD_VAR 0 3
64195: DIFF
64196: PPUSH
64197: CALL_OW 1
64201: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64202: LD_ADDR_EXP 30
64206: PUSH
64207: LD_EXP 30
64211: PPUSH
64212: LD_VAR 0 2
64216: PUSH
64217: LD_EXP 30
64221: PUSH
64222: LD_VAR 0 2
64226: ARRAY
64227: PUSH
64228: LD_INT 1
64230: PLUS
64231: PUSH
64232: EMPTY
64233: LIST
64234: LIST
64235: PPUSH
64236: LD_VAR 0 3
64240: PPUSH
64241: CALL 16110 0 3
64245: ST_TO_ADDR
// end ; end ;
64246: GO 64142
64248: POP
64249: POP
// if not lab or not mc_lab_upgrade [ i ] then
64250: LD_VAR 0 6
64254: NOT
64255: PUSH
64256: LD_EXP 57
64260: PUSH
64261: LD_VAR 0 2
64265: ARRAY
64266: NOT
64267: OR
64268: IFFALSE 64272
// continue ;
64270: GO 64042
// for j in lab do
64272: LD_ADDR_VAR 0 3
64276: PUSH
64277: LD_VAR 0 6
64281: PUSH
64282: FOR_IN
64283: IFFALSE 64448
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
64285: LD_VAR 0 3
64289: PPUSH
64290: CALL_OW 266
64294: PUSH
64295: LD_INT 6
64297: PUSH
64298: LD_INT 7
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: IN
64305: PUSH
64306: LD_VAR 0 3
64310: PPUSH
64311: CALL_OW 461
64315: PUSH
64316: LD_INT 1
64318: NONEQUAL
64319: AND
64320: IFFALSE 64446
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
64322: LD_VAR 0 3
64326: PPUSH
64327: LD_EXP 57
64331: PUSH
64332: LD_VAR 0 2
64336: ARRAY
64337: PUSH
64338: LD_INT 1
64340: ARRAY
64341: PPUSH
64342: CALL 22826 0 2
64346: IFFALSE 64446
// begin ComCancel ( j ) ;
64348: LD_VAR 0 3
64352: PPUSH
64353: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
64357: LD_VAR 0 3
64361: PPUSH
64362: LD_EXP 57
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: PUSH
64373: LD_INT 1
64375: ARRAY
64376: PPUSH
64377: CALL_OW 207
// if not j in mc_construct_list [ i ] then
64381: LD_VAR 0 3
64385: PUSH
64386: LD_EXP 30
64390: PUSH
64391: LD_VAR 0 2
64395: ARRAY
64396: IN
64397: NOT
64398: IFFALSE 64444
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
64400: LD_ADDR_EXP 30
64404: PUSH
64405: LD_EXP 30
64409: PPUSH
64410: LD_VAR 0 2
64414: PUSH
64415: LD_EXP 30
64419: PUSH
64420: LD_VAR 0 2
64424: ARRAY
64425: PUSH
64426: LD_INT 1
64428: PLUS
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PPUSH
64434: LD_VAR 0 3
64438: PPUSH
64439: CALL 16110 0 3
64443: ST_TO_ADDR
// break ;
64444: GO 64448
// end ; end ; end ;
64446: GO 64282
64448: POP
64449: POP
// end ;
64450: GO 64042
64452: POP
64453: POP
// end ;
64454: LD_VAR 0 1
64458: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
64459: LD_INT 0
64461: PPUSH
64462: PPUSH
64463: PPUSH
64464: PPUSH
64465: PPUSH
64466: PPUSH
64467: PPUSH
64468: PPUSH
64469: PPUSH
// if not mc_bases then
64470: LD_EXP 23
64474: NOT
64475: IFFALSE 64479
// exit ;
64477: GO 64884
// for i = 1 to mc_bases do
64479: LD_ADDR_VAR 0 2
64483: PUSH
64484: DOUBLE
64485: LD_INT 1
64487: DEC
64488: ST_TO_ADDR
64489: LD_EXP 23
64493: PUSH
64494: FOR_TO
64495: IFFALSE 64882
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64497: LD_EXP 31
64501: PUSH
64502: LD_VAR 0 2
64506: ARRAY
64507: NOT
64508: PUSH
64509: LD_EXP 23
64513: PUSH
64514: LD_VAR 0 2
64518: ARRAY
64519: PPUSH
64520: LD_INT 30
64522: PUSH
64523: LD_INT 3
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PPUSH
64530: CALL_OW 72
64534: NOT
64535: OR
64536: IFFALSE 64540
// continue ;
64538: GO 64494
// busy := false ;
64540: LD_ADDR_VAR 0 8
64544: PUSH
64545: LD_INT 0
64547: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64548: LD_ADDR_VAR 0 4
64552: PUSH
64553: LD_EXP 23
64557: PUSH
64558: LD_VAR 0 2
64562: ARRAY
64563: PPUSH
64564: LD_INT 30
64566: PUSH
64567: LD_INT 3
64569: PUSH
64570: EMPTY
64571: LIST
64572: LIST
64573: PPUSH
64574: CALL_OW 72
64578: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64579: LD_ADDR_VAR 0 6
64583: PUSH
64584: LD_EXP 31
64588: PUSH
64589: LD_VAR 0 2
64593: ARRAY
64594: PPUSH
64595: LD_INT 2
64597: PUSH
64598: LD_INT 30
64600: PUSH
64601: LD_INT 32
64603: PUSH
64604: EMPTY
64605: LIST
64606: LIST
64607: PUSH
64608: LD_INT 30
64610: PUSH
64611: LD_INT 33
64613: PUSH
64614: EMPTY
64615: LIST
64616: LIST
64617: PUSH
64618: EMPTY
64619: LIST
64620: LIST
64621: LIST
64622: PPUSH
64623: CALL_OW 72
64627: ST_TO_ADDR
// if not t then
64628: LD_VAR 0 6
64632: NOT
64633: IFFALSE 64637
// continue ;
64635: GO 64494
// for j in tmp do
64637: LD_ADDR_VAR 0 3
64641: PUSH
64642: LD_VAR 0 4
64646: PUSH
64647: FOR_IN
64648: IFFALSE 64678
// if not BuildingStatus ( j ) = bs_idle then
64650: LD_VAR 0 3
64654: PPUSH
64655: CALL_OW 461
64659: PUSH
64660: LD_INT 2
64662: EQUAL
64663: NOT
64664: IFFALSE 64676
// begin busy := true ;
64666: LD_ADDR_VAR 0 8
64670: PUSH
64671: LD_INT 1
64673: ST_TO_ADDR
// break ;
64674: GO 64678
// end ;
64676: GO 64647
64678: POP
64679: POP
// if busy then
64680: LD_VAR 0 8
64684: IFFALSE 64688
// continue ;
64686: GO 64494
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64688: LD_ADDR_VAR 0 7
64692: PUSH
64693: LD_VAR 0 6
64697: PPUSH
64698: LD_INT 35
64700: PUSH
64701: LD_INT 0
64703: PUSH
64704: EMPTY
64705: LIST
64706: LIST
64707: PPUSH
64708: CALL_OW 72
64712: ST_TO_ADDR
// if tw then
64713: LD_VAR 0 7
64717: IFFALSE 64794
// begin tw := tw [ 1 ] ;
64719: LD_ADDR_VAR 0 7
64723: PUSH
64724: LD_VAR 0 7
64728: PUSH
64729: LD_INT 1
64731: ARRAY
64732: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64733: LD_ADDR_VAR 0 9
64737: PUSH
64738: LD_VAR 0 7
64742: PPUSH
64743: LD_EXP 48
64747: PUSH
64748: LD_VAR 0 2
64752: ARRAY
64753: PPUSH
64754: CALL 21118 0 2
64758: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64759: LD_EXP 62
64763: PUSH
64764: LD_VAR 0 2
64768: ARRAY
64769: IFFALSE 64792
// if not weapon in mc_allowed_tower_weapons [ i ] then
64771: LD_VAR 0 9
64775: PUSH
64776: LD_EXP 62
64780: PUSH
64781: LD_VAR 0 2
64785: ARRAY
64786: IN
64787: NOT
64788: IFFALSE 64792
// continue ;
64790: GO 64494
// end else
64792: GO 64857
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64794: LD_ADDR_VAR 0 5
64798: PUSH
64799: LD_EXP 31
64803: PUSH
64804: LD_VAR 0 2
64808: ARRAY
64809: PPUSH
64810: LD_VAR 0 4
64814: PPUSH
64815: CALL 47989 0 2
64819: ST_TO_ADDR
// if not tmp2 then
64820: LD_VAR 0 5
64824: NOT
64825: IFFALSE 64829
// continue ;
64827: GO 64494
// tw := tmp2 [ 1 ] ;
64829: LD_ADDR_VAR 0 7
64833: PUSH
64834: LD_VAR 0 5
64838: PUSH
64839: LD_INT 1
64841: ARRAY
64842: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64843: LD_ADDR_VAR 0 9
64847: PUSH
64848: LD_VAR 0 5
64852: PUSH
64853: LD_INT 2
64855: ARRAY
64856: ST_TO_ADDR
// end ; if not weapon then
64857: LD_VAR 0 9
64861: NOT
64862: IFFALSE 64866
// continue ;
64864: GO 64494
// ComPlaceWeapon ( tw , weapon ) ;
64866: LD_VAR 0 7
64870: PPUSH
64871: LD_VAR 0 9
64875: PPUSH
64876: CALL_OW 148
// end ;
64880: GO 64494
64882: POP
64883: POP
// end ;
64884: LD_VAR 0 1
64888: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64889: LD_INT 0
64891: PPUSH
64892: PPUSH
64893: PPUSH
64894: PPUSH
64895: PPUSH
64896: PPUSH
64897: PPUSH
// if not mc_bases then
64898: LD_EXP 23
64902: NOT
64903: IFFALSE 64907
// exit ;
64905: GO 65675
// for i = 1 to mc_bases do
64907: LD_ADDR_VAR 0 2
64911: PUSH
64912: DOUBLE
64913: LD_INT 1
64915: DEC
64916: ST_TO_ADDR
64917: LD_EXP 23
64921: PUSH
64922: FOR_TO
64923: IFFALSE 65673
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64925: LD_EXP 36
64929: PUSH
64930: LD_VAR 0 2
64934: ARRAY
64935: NOT
64936: PUSH
64937: LD_EXP 36
64941: PUSH
64942: LD_VAR 0 2
64946: ARRAY
64947: PUSH
64948: LD_EXP 37
64952: PUSH
64953: LD_VAR 0 2
64957: ARRAY
64958: EQUAL
64959: OR
64960: PUSH
64961: LD_EXP 46
64965: PUSH
64966: LD_VAR 0 2
64970: ARRAY
64971: OR
64972: IFFALSE 64976
// continue ;
64974: GO 64922
// if mc_miners [ i ] then
64976: LD_EXP 37
64980: PUSH
64981: LD_VAR 0 2
64985: ARRAY
64986: IFFALSE 65360
// begin for j = mc_miners [ i ] downto 1 do
64988: LD_ADDR_VAR 0 3
64992: PUSH
64993: DOUBLE
64994: LD_EXP 37
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: INC
65005: ST_TO_ADDR
65006: LD_INT 1
65008: PUSH
65009: FOR_DOWNTO
65010: IFFALSE 65358
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
65012: LD_EXP 37
65016: PUSH
65017: LD_VAR 0 2
65021: ARRAY
65022: PUSH
65023: LD_VAR 0 3
65027: ARRAY
65028: PPUSH
65029: CALL_OW 301
65033: PUSH
65034: LD_EXP 37
65038: PUSH
65039: LD_VAR 0 2
65043: ARRAY
65044: PUSH
65045: LD_VAR 0 3
65049: ARRAY
65050: PPUSH
65051: CALL_OW 257
65055: PUSH
65056: LD_INT 1
65058: NONEQUAL
65059: OR
65060: IFFALSE 65123
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
65062: LD_ADDR_VAR 0 5
65066: PUSH
65067: LD_EXP 37
65071: PUSH
65072: LD_VAR 0 2
65076: ARRAY
65077: PUSH
65078: LD_EXP 37
65082: PUSH
65083: LD_VAR 0 2
65087: ARRAY
65088: PUSH
65089: LD_VAR 0 3
65093: ARRAY
65094: DIFF
65095: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
65096: LD_ADDR_EXP 37
65100: PUSH
65101: LD_EXP 37
65105: PPUSH
65106: LD_VAR 0 2
65110: PPUSH
65111: LD_VAR 0 5
65115: PPUSH
65116: CALL_OW 1
65120: ST_TO_ADDR
// continue ;
65121: GO 65009
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
65123: LD_EXP 37
65127: PUSH
65128: LD_VAR 0 2
65132: ARRAY
65133: PUSH
65134: LD_VAR 0 3
65138: ARRAY
65139: PPUSH
65140: CALL_OW 257
65144: PUSH
65145: LD_INT 1
65147: EQUAL
65148: PUSH
65149: LD_EXP 37
65153: PUSH
65154: LD_VAR 0 2
65158: ARRAY
65159: PUSH
65160: LD_VAR 0 3
65164: ARRAY
65165: PPUSH
65166: CALL_OW 459
65170: NOT
65171: AND
65172: PUSH
65173: LD_EXP 37
65177: PUSH
65178: LD_VAR 0 2
65182: ARRAY
65183: PUSH
65184: LD_VAR 0 3
65188: ARRAY
65189: PPUSH
65190: CALL_OW 314
65194: NOT
65195: AND
65196: IFFALSE 65356
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
65198: LD_EXP 37
65202: PUSH
65203: LD_VAR 0 2
65207: ARRAY
65208: PUSH
65209: LD_VAR 0 3
65213: ARRAY
65214: PPUSH
65215: CALL_OW 310
65219: IFFALSE 65242
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
65221: LD_EXP 37
65225: PUSH
65226: LD_VAR 0 2
65230: ARRAY
65231: PUSH
65232: LD_VAR 0 3
65236: ARRAY
65237: PPUSH
65238: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
65242: LD_EXP 37
65246: PUSH
65247: LD_VAR 0 2
65251: ARRAY
65252: PUSH
65253: LD_VAR 0 3
65257: ARRAY
65258: PPUSH
65259: CALL_OW 314
65263: NOT
65264: IFFALSE 65356
// begin r := rand ( 1 , mc_mines [ i ] ) ;
65266: LD_ADDR_VAR 0 7
65270: PUSH
65271: LD_INT 1
65273: PPUSH
65274: LD_EXP 36
65278: PUSH
65279: LD_VAR 0 2
65283: ARRAY
65284: PPUSH
65285: CALL_OW 12
65289: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
65290: LD_EXP 37
65294: PUSH
65295: LD_VAR 0 2
65299: ARRAY
65300: PUSH
65301: LD_VAR 0 3
65305: ARRAY
65306: PPUSH
65307: LD_EXP 36
65311: PUSH
65312: LD_VAR 0 2
65316: ARRAY
65317: PUSH
65318: LD_VAR 0 7
65322: ARRAY
65323: PUSH
65324: LD_INT 1
65326: ARRAY
65327: PPUSH
65328: LD_EXP 36
65332: PUSH
65333: LD_VAR 0 2
65337: ARRAY
65338: PUSH
65339: LD_VAR 0 7
65343: ARRAY
65344: PUSH
65345: LD_INT 2
65347: ARRAY
65348: PPUSH
65349: LD_INT 0
65351: PPUSH
65352: CALL_OW 193
// end ; end ; end ;
65356: GO 65009
65358: POP
65359: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
65360: LD_ADDR_VAR 0 5
65364: PUSH
65365: LD_EXP 23
65369: PUSH
65370: LD_VAR 0 2
65374: ARRAY
65375: PPUSH
65376: LD_INT 2
65378: PUSH
65379: LD_INT 30
65381: PUSH
65382: LD_INT 4
65384: PUSH
65385: EMPTY
65386: LIST
65387: LIST
65388: PUSH
65389: LD_INT 30
65391: PUSH
65392: LD_INT 5
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: PUSH
65399: LD_INT 30
65401: PUSH
65402: LD_INT 32
65404: PUSH
65405: EMPTY
65406: LIST
65407: LIST
65408: PUSH
65409: EMPTY
65410: LIST
65411: LIST
65412: LIST
65413: LIST
65414: PPUSH
65415: CALL_OW 72
65419: ST_TO_ADDR
// if not tmp then
65420: LD_VAR 0 5
65424: NOT
65425: IFFALSE 65429
// continue ;
65427: GO 64922
// list := [ ] ;
65429: LD_ADDR_VAR 0 6
65433: PUSH
65434: EMPTY
65435: ST_TO_ADDR
// for j in tmp do
65436: LD_ADDR_VAR 0 3
65440: PUSH
65441: LD_VAR 0 5
65445: PUSH
65446: FOR_IN
65447: IFFALSE 65516
// begin for k in UnitsInside ( j ) do
65449: LD_ADDR_VAR 0 4
65453: PUSH
65454: LD_VAR 0 3
65458: PPUSH
65459: CALL_OW 313
65463: PUSH
65464: FOR_IN
65465: IFFALSE 65512
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
65467: LD_VAR 0 4
65471: PPUSH
65472: CALL_OW 257
65476: PUSH
65477: LD_INT 1
65479: EQUAL
65480: PUSH
65481: LD_VAR 0 4
65485: PPUSH
65486: CALL_OW 459
65490: NOT
65491: AND
65492: IFFALSE 65510
// list := list ^ k ;
65494: LD_ADDR_VAR 0 6
65498: PUSH
65499: LD_VAR 0 6
65503: PUSH
65504: LD_VAR 0 4
65508: ADD
65509: ST_TO_ADDR
65510: GO 65464
65512: POP
65513: POP
// end ;
65514: GO 65446
65516: POP
65517: POP
// list := list diff mc_miners [ i ] ;
65518: LD_ADDR_VAR 0 6
65522: PUSH
65523: LD_VAR 0 6
65527: PUSH
65528: LD_EXP 37
65532: PUSH
65533: LD_VAR 0 2
65537: ARRAY
65538: DIFF
65539: ST_TO_ADDR
// if not list then
65540: LD_VAR 0 6
65544: NOT
65545: IFFALSE 65549
// continue ;
65547: GO 64922
// k := mc_mines [ i ] - mc_miners [ i ] ;
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: LD_EXP 36
65558: PUSH
65559: LD_VAR 0 2
65563: ARRAY
65564: PUSH
65565: LD_EXP 37
65569: PUSH
65570: LD_VAR 0 2
65574: ARRAY
65575: MINUS
65576: ST_TO_ADDR
// if k > list then
65577: LD_VAR 0 4
65581: PUSH
65582: LD_VAR 0 6
65586: GREATER
65587: IFFALSE 65599
// k := list ;
65589: LD_ADDR_VAR 0 4
65593: PUSH
65594: LD_VAR 0 6
65598: ST_TO_ADDR
// for j = 1 to k do
65599: LD_ADDR_VAR 0 3
65603: PUSH
65604: DOUBLE
65605: LD_INT 1
65607: DEC
65608: ST_TO_ADDR
65609: LD_VAR 0 4
65613: PUSH
65614: FOR_TO
65615: IFFALSE 65669
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65617: LD_ADDR_EXP 37
65621: PUSH
65622: LD_EXP 37
65626: PPUSH
65627: LD_VAR 0 2
65631: PUSH
65632: LD_EXP 37
65636: PUSH
65637: LD_VAR 0 2
65641: ARRAY
65642: PUSH
65643: LD_INT 1
65645: PLUS
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PPUSH
65651: LD_VAR 0 6
65655: PUSH
65656: LD_VAR 0 3
65660: ARRAY
65661: PPUSH
65662: CALL 16110 0 3
65666: ST_TO_ADDR
65667: GO 65614
65669: POP
65670: POP
// end ;
65671: GO 64922
65673: POP
65674: POP
// end ;
65675: LD_VAR 0 1
65679: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
65680: LD_INT 0
65682: PPUSH
65683: PPUSH
65684: PPUSH
65685: PPUSH
65686: PPUSH
65687: PPUSH
65688: PPUSH
65689: PPUSH
65690: PPUSH
65691: PPUSH
65692: PPUSH
// if not mc_bases then
65693: LD_EXP 23
65697: NOT
65698: IFFALSE 65702
// exit ;
65700: GO 67525
// for i = 1 to mc_bases do
65702: LD_ADDR_VAR 0 2
65706: PUSH
65707: DOUBLE
65708: LD_INT 1
65710: DEC
65711: ST_TO_ADDR
65712: LD_EXP 23
65716: PUSH
65717: FOR_TO
65718: IFFALSE 67523
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65720: LD_EXP 23
65724: PUSH
65725: LD_VAR 0 2
65729: ARRAY
65730: NOT
65731: PUSH
65732: LD_EXP 30
65736: PUSH
65737: LD_VAR 0 2
65741: ARRAY
65742: OR
65743: IFFALSE 65747
// continue ;
65745: GO 65717
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65747: LD_EXP 39
65751: PUSH
65752: LD_VAR 0 2
65756: ARRAY
65757: NOT
65758: PUSH
65759: LD_EXP 40
65763: PUSH
65764: LD_VAR 0 2
65768: ARRAY
65769: AND
65770: IFFALSE 65808
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65772: LD_ADDR_EXP 40
65776: PUSH
65777: LD_EXP 40
65781: PPUSH
65782: LD_VAR 0 2
65786: PPUSH
65787: EMPTY
65788: PPUSH
65789: CALL_OW 1
65793: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65794: LD_VAR 0 2
65798: PPUSH
65799: LD_INT 107
65801: PPUSH
65802: CALL 56555 0 2
// continue ;
65806: GO 65717
// end ; target := [ ] ;
65808: LD_ADDR_VAR 0 7
65812: PUSH
65813: EMPTY
65814: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65815: LD_ADDR_VAR 0 6
65819: PUSH
65820: LD_EXP 23
65824: PUSH
65825: LD_VAR 0 2
65829: ARRAY
65830: PUSH
65831: LD_INT 1
65833: ARRAY
65834: PPUSH
65835: CALL_OW 255
65839: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65840: LD_ADDR_VAR 0 9
65844: PUSH
65845: LD_EXP 23
65849: PUSH
65850: LD_VAR 0 2
65854: ARRAY
65855: PPUSH
65856: LD_INT 2
65858: PUSH
65859: LD_INT 30
65861: PUSH
65862: LD_INT 0
65864: PUSH
65865: EMPTY
65866: LIST
65867: LIST
65868: PUSH
65869: LD_INT 30
65871: PUSH
65872: LD_INT 1
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: PUSH
65879: EMPTY
65880: LIST
65881: LIST
65882: LIST
65883: PPUSH
65884: CALL_OW 72
65888: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65889: LD_ADDR_VAR 0 3
65893: PUSH
65894: DOUBLE
65895: LD_EXP 39
65899: PUSH
65900: LD_VAR 0 2
65904: ARRAY
65905: INC
65906: ST_TO_ADDR
65907: LD_INT 1
65909: PUSH
65910: FOR_DOWNTO
65911: IFFALSE 66156
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65913: LD_EXP 39
65917: PUSH
65918: LD_VAR 0 2
65922: ARRAY
65923: PUSH
65924: LD_VAR 0 3
65928: ARRAY
65929: PUSH
65930: LD_INT 2
65932: ARRAY
65933: PPUSH
65934: LD_EXP 39
65938: PUSH
65939: LD_VAR 0 2
65943: ARRAY
65944: PUSH
65945: LD_VAR 0 3
65949: ARRAY
65950: PUSH
65951: LD_INT 3
65953: ARRAY
65954: PPUSH
65955: CALL_OW 488
65959: PUSH
65960: LD_EXP 39
65964: PUSH
65965: LD_VAR 0 2
65969: ARRAY
65970: PUSH
65971: LD_VAR 0 3
65975: ARRAY
65976: PUSH
65977: LD_INT 2
65979: ARRAY
65980: PPUSH
65981: LD_EXP 39
65985: PUSH
65986: LD_VAR 0 2
65990: ARRAY
65991: PUSH
65992: LD_VAR 0 3
65996: ARRAY
65997: PUSH
65998: LD_INT 3
66000: ARRAY
66001: PPUSH
66002: CALL_OW 284
66006: PUSH
66007: LD_INT 0
66009: EQUAL
66010: AND
66011: IFFALSE 66066
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
66013: LD_ADDR_VAR 0 5
66017: PUSH
66018: LD_EXP 39
66022: PUSH
66023: LD_VAR 0 2
66027: ARRAY
66028: PPUSH
66029: LD_VAR 0 3
66033: PPUSH
66034: CALL_OW 3
66038: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
66039: LD_ADDR_EXP 39
66043: PUSH
66044: LD_EXP 39
66048: PPUSH
66049: LD_VAR 0 2
66053: PPUSH
66054: LD_VAR 0 5
66058: PPUSH
66059: CALL_OW 1
66063: ST_TO_ADDR
// continue ;
66064: GO 65910
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
66066: LD_VAR 0 6
66070: PPUSH
66071: LD_EXP 39
66075: PUSH
66076: LD_VAR 0 2
66080: ARRAY
66081: PUSH
66082: LD_VAR 0 3
66086: ARRAY
66087: PUSH
66088: LD_INT 2
66090: ARRAY
66091: PPUSH
66092: LD_EXP 39
66096: PUSH
66097: LD_VAR 0 2
66101: ARRAY
66102: PUSH
66103: LD_VAR 0 3
66107: ARRAY
66108: PUSH
66109: LD_INT 3
66111: ARRAY
66112: PPUSH
66113: LD_INT 30
66115: PPUSH
66116: CALL 17006 0 4
66120: PUSH
66121: LD_INT 4
66123: ARRAY
66124: PUSH
66125: LD_INT 0
66127: EQUAL
66128: IFFALSE 66154
// begin target := mc_crates [ i ] [ j ] ;
66130: LD_ADDR_VAR 0 7
66134: PUSH
66135: LD_EXP 39
66139: PUSH
66140: LD_VAR 0 2
66144: ARRAY
66145: PUSH
66146: LD_VAR 0 3
66150: ARRAY
66151: ST_TO_ADDR
// break ;
66152: GO 66156
// end ; end ;
66154: GO 65910
66156: POP
66157: POP
// if not target then
66158: LD_VAR 0 7
66162: NOT
66163: IFFALSE 66167
// continue ;
66165: GO 65717
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
66167: LD_ADDR_VAR 0 8
66171: PUSH
66172: LD_EXP 42
66176: PUSH
66177: LD_VAR 0 2
66181: ARRAY
66182: PPUSH
66183: LD_INT 2
66185: PUSH
66186: LD_INT 3
66188: PUSH
66189: LD_INT 58
66191: PUSH
66192: EMPTY
66193: LIST
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 61
66201: PUSH
66202: EMPTY
66203: LIST
66204: PUSH
66205: LD_INT 33
66207: PUSH
66208: LD_INT 5
66210: PUSH
66211: EMPTY
66212: LIST
66213: LIST
66214: PUSH
66215: LD_INT 33
66217: PUSH
66218: LD_INT 3
66220: PUSH
66221: EMPTY
66222: LIST
66223: LIST
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: LIST
66229: LIST
66230: LIST
66231: PUSH
66232: LD_INT 2
66234: PUSH
66235: LD_INT 34
66237: PUSH
66238: LD_INT 32
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 34
66247: PUSH
66248: LD_INT 51
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: LD_INT 34
66257: PUSH
66258: LD_INT 12
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: LIST
66269: LIST
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PPUSH
66275: CALL_OW 72
66279: ST_TO_ADDR
// if not cargo then
66280: LD_VAR 0 8
66284: NOT
66285: IFFALSE 66991
// begin if mc_crates_collector [ i ] < 5 then
66287: LD_EXP 40
66291: PUSH
66292: LD_VAR 0 2
66296: ARRAY
66297: PUSH
66298: LD_INT 5
66300: LESS
66301: IFFALSE 66667
// begin if mc_ape [ i ] then
66303: LD_EXP 52
66307: PUSH
66308: LD_VAR 0 2
66312: ARRAY
66313: IFFALSE 66360
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
66315: LD_ADDR_VAR 0 5
66319: PUSH
66320: LD_EXP 52
66324: PUSH
66325: LD_VAR 0 2
66329: ARRAY
66330: PPUSH
66331: LD_INT 25
66333: PUSH
66334: LD_INT 16
66336: PUSH
66337: EMPTY
66338: LIST
66339: LIST
66340: PUSH
66341: LD_INT 24
66343: PUSH
66344: LD_INT 750
66346: PUSH
66347: EMPTY
66348: LIST
66349: LIST
66350: PUSH
66351: EMPTY
66352: LIST
66353: LIST
66354: PPUSH
66355: CALL_OW 72
66359: ST_TO_ADDR
// if not tmp then
66360: LD_VAR 0 5
66364: NOT
66365: IFFALSE 66412
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
66367: LD_ADDR_VAR 0 5
66371: PUSH
66372: LD_EXP 23
66376: PUSH
66377: LD_VAR 0 2
66381: ARRAY
66382: PPUSH
66383: LD_INT 25
66385: PUSH
66386: LD_INT 2
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: LD_INT 24
66395: PUSH
66396: LD_INT 750
66398: PUSH
66399: EMPTY
66400: LIST
66401: LIST
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PPUSH
66407: CALL_OW 72
66411: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
66412: LD_EXP 52
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PUSH
66423: LD_EXP 23
66427: PUSH
66428: LD_VAR 0 2
66432: ARRAY
66433: PPUSH
66434: LD_INT 25
66436: PUSH
66437: LD_INT 2
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 24
66446: PUSH
66447: LD_INT 750
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PPUSH
66458: CALL_OW 72
66462: AND
66463: PUSH
66464: LD_VAR 0 5
66468: PUSH
66469: LD_INT 5
66471: LESS
66472: AND
66473: IFFALSE 66555
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
66475: LD_ADDR_VAR 0 3
66479: PUSH
66480: LD_EXP 23
66484: PUSH
66485: LD_VAR 0 2
66489: ARRAY
66490: PPUSH
66491: LD_INT 25
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: EMPTY
66498: LIST
66499: LIST
66500: PUSH
66501: LD_INT 24
66503: PUSH
66504: LD_INT 750
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PPUSH
66515: CALL_OW 72
66519: PUSH
66520: FOR_IN
66521: IFFALSE 66553
// begin tmp := tmp union j ;
66523: LD_ADDR_VAR 0 5
66527: PUSH
66528: LD_VAR 0 5
66532: PUSH
66533: LD_VAR 0 3
66537: UNION
66538: ST_TO_ADDR
// if tmp >= 5 then
66539: LD_VAR 0 5
66543: PUSH
66544: LD_INT 5
66546: GREATEREQUAL
66547: IFFALSE 66551
// break ;
66549: GO 66553
// end ;
66551: GO 66520
66553: POP
66554: POP
// end ; if not tmp then
66555: LD_VAR 0 5
66559: NOT
66560: IFFALSE 66564
// continue ;
66562: GO 65717
// for j in tmp do
66564: LD_ADDR_VAR 0 3
66568: PUSH
66569: LD_VAR 0 5
66573: PUSH
66574: FOR_IN
66575: IFFALSE 66665
// if not GetTag ( j ) then
66577: LD_VAR 0 3
66581: PPUSH
66582: CALL_OW 110
66586: NOT
66587: IFFALSE 66663
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66589: LD_ADDR_EXP 40
66593: PUSH
66594: LD_EXP 40
66598: PPUSH
66599: LD_VAR 0 2
66603: PUSH
66604: LD_EXP 40
66608: PUSH
66609: LD_VAR 0 2
66613: ARRAY
66614: PUSH
66615: LD_INT 1
66617: PLUS
66618: PUSH
66619: EMPTY
66620: LIST
66621: LIST
66622: PPUSH
66623: LD_VAR 0 3
66627: PPUSH
66628: CALL 16110 0 3
66632: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66633: LD_VAR 0 3
66637: PPUSH
66638: LD_INT 107
66640: PPUSH
66641: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66645: LD_EXP 40
66649: PUSH
66650: LD_VAR 0 2
66654: ARRAY
66655: PUSH
66656: LD_INT 5
66658: GREATEREQUAL
66659: IFFALSE 66663
// break ;
66661: GO 66665
// end ;
66663: GO 66574
66665: POP
66666: POP
// end ; if mc_crates_collector [ i ] and target then
66667: LD_EXP 40
66671: PUSH
66672: LD_VAR 0 2
66676: ARRAY
66677: PUSH
66678: LD_VAR 0 7
66682: AND
66683: IFFALSE 66989
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66685: LD_EXP 40
66689: PUSH
66690: LD_VAR 0 2
66694: ARRAY
66695: PUSH
66696: LD_VAR 0 7
66700: PUSH
66701: LD_INT 1
66703: ARRAY
66704: LESS
66705: IFFALSE 66725
// tmp := mc_crates_collector [ i ] else
66707: LD_ADDR_VAR 0 5
66711: PUSH
66712: LD_EXP 40
66716: PUSH
66717: LD_VAR 0 2
66721: ARRAY
66722: ST_TO_ADDR
66723: GO 66739
// tmp := target [ 1 ] ;
66725: LD_ADDR_VAR 0 5
66729: PUSH
66730: LD_VAR 0 7
66734: PUSH
66735: LD_INT 1
66737: ARRAY
66738: ST_TO_ADDR
// k := 0 ;
66739: LD_ADDR_VAR 0 4
66743: PUSH
66744: LD_INT 0
66746: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66747: LD_ADDR_VAR 0 3
66751: PUSH
66752: LD_EXP 40
66756: PUSH
66757: LD_VAR 0 2
66761: ARRAY
66762: PUSH
66763: FOR_IN
66764: IFFALSE 66987
// begin k := k + 1 ;
66766: LD_ADDR_VAR 0 4
66770: PUSH
66771: LD_VAR 0 4
66775: PUSH
66776: LD_INT 1
66778: PLUS
66779: ST_TO_ADDR
// if k > tmp then
66780: LD_VAR 0 4
66784: PUSH
66785: LD_VAR 0 5
66789: GREATER
66790: IFFALSE 66794
// break ;
66792: GO 66987
// if not GetClass ( j ) in [ 2 , 16 ] then
66794: LD_VAR 0 3
66798: PPUSH
66799: CALL_OW 257
66803: PUSH
66804: LD_INT 2
66806: PUSH
66807: LD_INT 16
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: IN
66814: NOT
66815: IFFALSE 66868
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66817: LD_ADDR_EXP 40
66821: PUSH
66822: LD_EXP 40
66826: PPUSH
66827: LD_VAR 0 2
66831: PPUSH
66832: LD_EXP 40
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: PUSH
66843: LD_VAR 0 3
66847: DIFF
66848: PPUSH
66849: CALL_OW 1
66853: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66854: LD_VAR 0 3
66858: PPUSH
66859: LD_INT 0
66861: PPUSH
66862: CALL_OW 109
// continue ;
66866: GO 66763
// end ; if IsInUnit ( j ) then
66868: LD_VAR 0 3
66872: PPUSH
66873: CALL_OW 310
66877: IFFALSE 66888
// ComExitBuilding ( j ) ;
66879: LD_VAR 0 3
66883: PPUSH
66884: CALL_OW 122
// wait ( 3 ) ;
66888: LD_INT 3
66890: PPUSH
66891: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
66895: LD_VAR 0 3
66899: PPUSH
66900: CALL_OW 314
66904: PUSH
66905: LD_VAR 0 6
66909: PPUSH
66910: LD_VAR 0 7
66914: PUSH
66915: LD_INT 2
66917: ARRAY
66918: PPUSH
66919: LD_VAR 0 7
66923: PUSH
66924: LD_INT 3
66926: ARRAY
66927: PPUSH
66928: LD_INT 30
66930: PPUSH
66931: CALL 17006 0 4
66935: PUSH
66936: LD_INT 4
66938: ARRAY
66939: AND
66940: IFFALSE 66958
// ComStandNearbyBuilding ( j , depot ) else
66942: LD_VAR 0 3
66946: PPUSH
66947: LD_VAR 0 9
66951: PPUSH
66952: CALL 12537 0 2
66956: GO 66985
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66958: LD_VAR 0 3
66962: PPUSH
66963: LD_VAR 0 7
66967: PUSH
66968: LD_INT 2
66970: ARRAY
66971: PPUSH
66972: LD_VAR 0 7
66976: PUSH
66977: LD_INT 3
66979: ARRAY
66980: PPUSH
66981: CALL_OW 117
// end ;
66985: GO 66763
66987: POP
66988: POP
// end ; end else
66989: GO 67521
// begin for j in cargo do
66991: LD_ADDR_VAR 0 3
66995: PUSH
66996: LD_VAR 0 8
67000: PUSH
67001: FOR_IN
67002: IFFALSE 67519
// begin if GetTag ( j ) <> 0 then
67004: LD_VAR 0 3
67008: PPUSH
67009: CALL_OW 110
67013: PUSH
67014: LD_INT 0
67016: NONEQUAL
67017: IFFALSE 67021
// continue ;
67019: GO 67001
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
67021: LD_VAR 0 3
67025: PPUSH
67026: CALL_OW 256
67030: PUSH
67031: LD_INT 1000
67033: LESS
67034: PUSH
67035: LD_VAR 0 3
67039: PPUSH
67040: LD_EXP 47
67044: PUSH
67045: LD_VAR 0 2
67049: ARRAY
67050: PPUSH
67051: CALL_OW 308
67055: NOT
67056: AND
67057: IFFALSE 67079
// ComMoveToArea ( j , mc_parking [ i ] ) ;
67059: LD_VAR 0 3
67063: PPUSH
67064: LD_EXP 47
67068: PUSH
67069: LD_VAR 0 2
67073: ARRAY
67074: PPUSH
67075: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
67079: LD_VAR 0 3
67083: PPUSH
67084: CALL_OW 256
67088: PUSH
67089: LD_INT 1000
67091: LESS
67092: PUSH
67093: LD_VAR 0 3
67097: PPUSH
67098: LD_EXP 47
67102: PUSH
67103: LD_VAR 0 2
67107: ARRAY
67108: PPUSH
67109: CALL_OW 308
67113: AND
67114: IFFALSE 67118
// continue ;
67116: GO 67001
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
67118: LD_VAR 0 3
67122: PPUSH
67123: CALL_OW 262
67127: PUSH
67128: LD_INT 2
67130: EQUAL
67131: PUSH
67132: LD_VAR 0 3
67136: PPUSH
67137: CALL_OW 261
67141: PUSH
67142: LD_INT 15
67144: LESS
67145: AND
67146: IFFALSE 67150
// continue ;
67148: GO 67001
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
67150: LD_VAR 0 3
67154: PPUSH
67155: CALL_OW 262
67159: PUSH
67160: LD_INT 1
67162: EQUAL
67163: PUSH
67164: LD_VAR 0 3
67168: PPUSH
67169: CALL_OW 261
67173: PUSH
67174: LD_INT 10
67176: LESS
67177: AND
67178: IFFALSE 67458
// begin if not depot then
67180: LD_VAR 0 9
67184: NOT
67185: IFFALSE 67189
// continue ;
67187: GO 67001
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
67189: LD_VAR 0 3
67193: PPUSH
67194: LD_VAR 0 9
67198: PPUSH
67199: LD_VAR 0 3
67203: PPUSH
67204: CALL_OW 74
67208: PPUSH
67209: CALL_OW 296
67213: PUSH
67214: LD_INT 6
67216: LESS
67217: IFFALSE 67233
// SetFuel ( j , 100 ) else
67219: LD_VAR 0 3
67223: PPUSH
67224: LD_INT 100
67226: PPUSH
67227: CALL_OW 240
67231: GO 67458
// if GetFuel ( j ) = 0 then
67233: LD_VAR 0 3
67237: PPUSH
67238: CALL_OW 261
67242: PUSH
67243: LD_INT 0
67245: EQUAL
67246: IFFALSE 67458
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
67248: LD_ADDR_EXP 42
67252: PUSH
67253: LD_EXP 42
67257: PPUSH
67258: LD_VAR 0 2
67262: PPUSH
67263: LD_EXP 42
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: PUSH
67274: LD_VAR 0 3
67278: DIFF
67279: PPUSH
67280: CALL_OW 1
67284: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
67285: LD_VAR 0 3
67289: PPUSH
67290: CALL_OW 263
67294: PUSH
67295: LD_INT 1
67297: EQUAL
67298: IFFALSE 67314
// ComExitVehicle ( IsInUnit ( j ) ) ;
67300: LD_VAR 0 3
67304: PPUSH
67305: CALL_OW 310
67309: PPUSH
67310: CALL_OW 121
// if GetControl ( j ) = control_remote then
67314: LD_VAR 0 3
67318: PPUSH
67319: CALL_OW 263
67323: PUSH
67324: LD_INT 2
67326: EQUAL
67327: IFFALSE 67338
// ComUnlink ( j ) ;
67329: LD_VAR 0 3
67333: PPUSH
67334: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
67338: LD_ADDR_VAR 0 10
67342: PUSH
67343: LD_VAR 0 2
67347: PPUSH
67348: LD_INT 3
67350: PPUSH
67351: CALL 77125 0 2
67355: ST_TO_ADDR
// if fac then
67356: LD_VAR 0 10
67360: IFFALSE 67456
// begin for k in fac do
67362: LD_ADDR_VAR 0 4
67366: PUSH
67367: LD_VAR 0 10
67371: PUSH
67372: FOR_IN
67373: IFFALSE 67454
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
67375: LD_ADDR_VAR 0 11
67379: PUSH
67380: LD_VAR 0 10
67384: PPUSH
67385: LD_VAR 0 3
67389: PPUSH
67390: CALL_OW 265
67394: PPUSH
67395: LD_VAR 0 3
67399: PPUSH
67400: CALL_OW 262
67404: PPUSH
67405: LD_VAR 0 3
67409: PPUSH
67410: CALL_OW 263
67414: PPUSH
67415: LD_VAR 0 3
67419: PPUSH
67420: CALL_OW 264
67424: PPUSH
67425: CALL 13608 0 5
67429: ST_TO_ADDR
// if components then
67430: LD_VAR 0 11
67434: IFFALSE 67452
// begin MC_InsertProduceList ( i , components ) ;
67436: LD_VAR 0 2
67440: PPUSH
67441: LD_VAR 0 11
67445: PPUSH
67446: CALL 76670 0 2
// break ;
67450: GO 67454
// end ; end ;
67452: GO 67372
67454: POP
67455: POP
// end ; continue ;
67456: GO 67001
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
67458: LD_VAR 0 3
67462: PPUSH
67463: LD_INT 1
67465: PPUSH
67466: CALL_OW 289
67470: PUSH
67471: LD_INT 100
67473: LESS
67474: PUSH
67475: LD_VAR 0 3
67479: PPUSH
67480: CALL_OW 314
67484: NOT
67485: AND
67486: IFFALSE 67515
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
67488: LD_VAR 0 3
67492: PPUSH
67493: LD_VAR 0 7
67497: PUSH
67498: LD_INT 2
67500: ARRAY
67501: PPUSH
67502: LD_VAR 0 7
67506: PUSH
67507: LD_INT 3
67509: ARRAY
67510: PPUSH
67511: CALL_OW 117
// break ;
67515: GO 67519
// end ;
67517: GO 67001
67519: POP
67520: POP
// end ; end ;
67521: GO 65717
67523: POP
67524: POP
// end ;
67525: LD_VAR 0 1
67529: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
67530: LD_INT 0
67532: PPUSH
67533: PPUSH
67534: PPUSH
67535: PPUSH
// if not mc_bases then
67536: LD_EXP 23
67540: NOT
67541: IFFALSE 67545
// exit ;
67543: GO 67706
// for i = 1 to mc_bases do
67545: LD_ADDR_VAR 0 2
67549: PUSH
67550: DOUBLE
67551: LD_INT 1
67553: DEC
67554: ST_TO_ADDR
67555: LD_EXP 23
67559: PUSH
67560: FOR_TO
67561: IFFALSE 67704
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67563: LD_ADDR_VAR 0 4
67567: PUSH
67568: LD_EXP 42
67572: PUSH
67573: LD_VAR 0 2
67577: ARRAY
67578: PUSH
67579: LD_EXP 45
67583: PUSH
67584: LD_VAR 0 2
67588: ARRAY
67589: UNION
67590: PPUSH
67591: LD_INT 33
67593: PUSH
67594: LD_INT 2
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: PPUSH
67601: CALL_OW 72
67605: ST_TO_ADDR
// if tmp then
67606: LD_VAR 0 4
67610: IFFALSE 67702
// for j in tmp do
67612: LD_ADDR_VAR 0 3
67616: PUSH
67617: LD_VAR 0 4
67621: PUSH
67622: FOR_IN
67623: IFFALSE 67700
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67625: LD_VAR 0 3
67629: PPUSH
67630: CALL_OW 312
67634: NOT
67635: PUSH
67636: LD_VAR 0 3
67640: PPUSH
67641: CALL_OW 256
67645: PUSH
67646: LD_INT 250
67648: GREATEREQUAL
67649: AND
67650: IFFALSE 67663
// Connect ( j ) else
67652: LD_VAR 0 3
67656: PPUSH
67657: CALL 19079 0 1
67661: GO 67698
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67663: LD_VAR 0 3
67667: PPUSH
67668: CALL_OW 256
67672: PUSH
67673: LD_INT 250
67675: LESS
67676: PUSH
67677: LD_VAR 0 3
67681: PPUSH
67682: CALL_OW 312
67686: AND
67687: IFFALSE 67698
// ComUnlink ( j ) ;
67689: LD_VAR 0 3
67693: PPUSH
67694: CALL_OW 136
67698: GO 67622
67700: POP
67701: POP
// end ;
67702: GO 67560
67704: POP
67705: POP
// end ;
67706: LD_VAR 0 1
67710: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67711: LD_INT 0
67713: PPUSH
67714: PPUSH
67715: PPUSH
67716: PPUSH
67717: PPUSH
// if not mc_bases then
67718: LD_EXP 23
67722: NOT
67723: IFFALSE 67727
// exit ;
67725: GO 68172
// for i = 1 to mc_bases do
67727: LD_ADDR_VAR 0 2
67731: PUSH
67732: DOUBLE
67733: LD_INT 1
67735: DEC
67736: ST_TO_ADDR
67737: LD_EXP 23
67741: PUSH
67742: FOR_TO
67743: IFFALSE 68170
// begin if not mc_produce [ i ] then
67745: LD_EXP 44
67749: PUSH
67750: LD_VAR 0 2
67754: ARRAY
67755: NOT
67756: IFFALSE 67760
// continue ;
67758: GO 67742
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67760: LD_ADDR_VAR 0 5
67764: PUSH
67765: LD_EXP 23
67769: PUSH
67770: LD_VAR 0 2
67774: ARRAY
67775: PPUSH
67776: LD_INT 30
67778: PUSH
67779: LD_INT 3
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PPUSH
67786: CALL_OW 72
67790: ST_TO_ADDR
// if not fac then
67791: LD_VAR 0 5
67795: NOT
67796: IFFALSE 67800
// continue ;
67798: GO 67742
// for j in fac do
67800: LD_ADDR_VAR 0 3
67804: PUSH
67805: LD_VAR 0 5
67809: PUSH
67810: FOR_IN
67811: IFFALSE 68166
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67813: LD_VAR 0 3
67817: PPUSH
67818: CALL_OW 461
67822: PUSH
67823: LD_INT 2
67825: NONEQUAL
67826: PUSH
67827: LD_VAR 0 3
67831: PPUSH
67832: LD_INT 15
67834: PPUSH
67835: CALL 18707 0 2
67839: PUSH
67840: LD_INT 4
67842: ARRAY
67843: OR
67844: IFFALSE 67848
// continue ;
67846: GO 67810
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67848: LD_VAR 0 3
67852: PPUSH
67853: LD_EXP 44
67857: PUSH
67858: LD_VAR 0 2
67862: ARRAY
67863: PUSH
67864: LD_INT 1
67866: ARRAY
67867: PUSH
67868: LD_INT 1
67870: ARRAY
67871: PPUSH
67872: LD_EXP 44
67876: PUSH
67877: LD_VAR 0 2
67881: ARRAY
67882: PUSH
67883: LD_INT 1
67885: ARRAY
67886: PUSH
67887: LD_INT 2
67889: ARRAY
67890: PPUSH
67891: LD_EXP 44
67895: PUSH
67896: LD_VAR 0 2
67900: ARRAY
67901: PUSH
67902: LD_INT 1
67904: ARRAY
67905: PUSH
67906: LD_INT 3
67908: ARRAY
67909: PPUSH
67910: LD_EXP 44
67914: PUSH
67915: LD_VAR 0 2
67919: ARRAY
67920: PUSH
67921: LD_INT 1
67923: ARRAY
67924: PUSH
67925: LD_INT 4
67927: ARRAY
67928: PPUSH
67929: CALL_OW 448
67933: PUSH
67934: LD_VAR 0 3
67938: PPUSH
67939: LD_EXP 44
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: PUSH
67950: LD_INT 1
67952: ARRAY
67953: PUSH
67954: LD_INT 1
67956: ARRAY
67957: PUSH
67958: LD_EXP 44
67962: PUSH
67963: LD_VAR 0 2
67967: ARRAY
67968: PUSH
67969: LD_INT 1
67971: ARRAY
67972: PUSH
67973: LD_INT 2
67975: ARRAY
67976: PUSH
67977: LD_EXP 44
67981: PUSH
67982: LD_VAR 0 2
67986: ARRAY
67987: PUSH
67988: LD_INT 1
67990: ARRAY
67991: PUSH
67992: LD_INT 3
67994: ARRAY
67995: PUSH
67996: LD_EXP 44
68000: PUSH
68001: LD_VAR 0 2
68005: ARRAY
68006: PUSH
68007: LD_INT 1
68009: ARRAY
68010: PUSH
68011: LD_INT 4
68013: ARRAY
68014: PUSH
68015: EMPTY
68016: LIST
68017: LIST
68018: LIST
68019: LIST
68020: PPUSH
68021: CALL 22474 0 2
68025: AND
68026: IFFALSE 68164
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
68028: LD_VAR 0 3
68032: PPUSH
68033: LD_EXP 44
68037: PUSH
68038: LD_VAR 0 2
68042: ARRAY
68043: PUSH
68044: LD_INT 1
68046: ARRAY
68047: PUSH
68048: LD_INT 1
68050: ARRAY
68051: PPUSH
68052: LD_EXP 44
68056: PUSH
68057: LD_VAR 0 2
68061: ARRAY
68062: PUSH
68063: LD_INT 1
68065: ARRAY
68066: PUSH
68067: LD_INT 2
68069: ARRAY
68070: PPUSH
68071: LD_EXP 44
68075: PUSH
68076: LD_VAR 0 2
68080: ARRAY
68081: PUSH
68082: LD_INT 1
68084: ARRAY
68085: PUSH
68086: LD_INT 3
68088: ARRAY
68089: PPUSH
68090: LD_EXP 44
68094: PUSH
68095: LD_VAR 0 2
68099: ARRAY
68100: PUSH
68101: LD_INT 1
68103: ARRAY
68104: PUSH
68105: LD_INT 4
68107: ARRAY
68108: PPUSH
68109: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
68113: LD_ADDR_VAR 0 4
68117: PUSH
68118: LD_EXP 44
68122: PUSH
68123: LD_VAR 0 2
68127: ARRAY
68128: PPUSH
68129: LD_INT 1
68131: PPUSH
68132: CALL_OW 3
68136: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68137: LD_ADDR_EXP 44
68141: PUSH
68142: LD_EXP 44
68146: PPUSH
68147: LD_VAR 0 2
68151: PPUSH
68152: LD_VAR 0 4
68156: PPUSH
68157: CALL_OW 1
68161: ST_TO_ADDR
// break ;
68162: GO 68166
// end ; end ;
68164: GO 67810
68166: POP
68167: POP
// end ;
68168: GO 67742
68170: POP
68171: POP
// end ;
68172: LD_VAR 0 1
68176: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
68177: LD_INT 0
68179: PPUSH
68180: PPUSH
68181: PPUSH
// if not mc_bases then
68182: LD_EXP 23
68186: NOT
68187: IFFALSE 68191
// exit ;
68189: GO 68280
// for i = 1 to mc_bases do
68191: LD_ADDR_VAR 0 2
68195: PUSH
68196: DOUBLE
68197: LD_INT 1
68199: DEC
68200: ST_TO_ADDR
68201: LD_EXP 23
68205: PUSH
68206: FOR_TO
68207: IFFALSE 68278
// begin if mc_attack [ i ] then
68209: LD_EXP 43
68213: PUSH
68214: LD_VAR 0 2
68218: ARRAY
68219: IFFALSE 68276
// begin tmp := mc_attack [ i ] [ 1 ] ;
68221: LD_ADDR_VAR 0 3
68225: PUSH
68226: LD_EXP 43
68230: PUSH
68231: LD_VAR 0 2
68235: ARRAY
68236: PUSH
68237: LD_INT 1
68239: ARRAY
68240: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
68241: LD_ADDR_EXP 43
68245: PUSH
68246: LD_EXP 43
68250: PPUSH
68251: LD_VAR 0 2
68255: PPUSH
68256: EMPTY
68257: PPUSH
68258: CALL_OW 1
68262: ST_TO_ADDR
// Attack ( tmp ) ;
68263: LD_VAR 0 3
68267: PPUSH
68268: CALL 83058 0 1
// exit ;
68272: POP
68273: POP
68274: GO 68280
// end ; end ;
68276: GO 68206
68278: POP
68279: POP
// end ;
68280: LD_VAR 0 1
68284: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
68285: LD_INT 0
68287: PPUSH
68288: PPUSH
68289: PPUSH
68290: PPUSH
68291: PPUSH
68292: PPUSH
68293: PPUSH
// if not mc_bases then
68294: LD_EXP 23
68298: NOT
68299: IFFALSE 68303
// exit ;
68301: GO 69160
// for i = 1 to mc_bases do
68303: LD_ADDR_VAR 0 2
68307: PUSH
68308: DOUBLE
68309: LD_INT 1
68311: DEC
68312: ST_TO_ADDR
68313: LD_EXP 23
68317: PUSH
68318: FOR_TO
68319: IFFALSE 69158
// begin if not mc_bases [ i ] then
68321: LD_EXP 23
68325: PUSH
68326: LD_VAR 0 2
68330: ARRAY
68331: NOT
68332: IFFALSE 68336
// continue ;
68334: GO 68318
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
68336: LD_ADDR_VAR 0 7
68340: PUSH
68341: LD_EXP 23
68345: PUSH
68346: LD_VAR 0 2
68350: ARRAY
68351: PUSH
68352: LD_INT 1
68354: ARRAY
68355: PPUSH
68356: CALL 12759 0 1
68360: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
68361: LD_ADDR_EXP 46
68365: PUSH
68366: LD_EXP 46
68370: PPUSH
68371: LD_VAR 0 2
68375: PPUSH
68376: LD_EXP 23
68380: PUSH
68381: LD_VAR 0 2
68385: ARRAY
68386: PUSH
68387: LD_INT 1
68389: ARRAY
68390: PPUSH
68391: CALL_OW 255
68395: PPUSH
68396: LD_EXP 48
68400: PUSH
68401: LD_VAR 0 2
68405: ARRAY
68406: PPUSH
68407: CALL 12724 0 2
68411: PPUSH
68412: CALL_OW 1
68416: ST_TO_ADDR
// if not mc_scan [ i ] then
68417: LD_EXP 46
68421: PUSH
68422: LD_VAR 0 2
68426: ARRAY
68427: NOT
68428: IFFALSE 68606
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68430: LD_ADDR_EXP 66
68434: PUSH
68435: LD_EXP 66
68439: PPUSH
68440: LD_VAR 0 2
68444: PPUSH
68445: LD_INT 0
68447: PPUSH
68448: CALL_OW 1
68452: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68453: LD_ADDR_VAR 0 4
68457: PUSH
68458: LD_EXP 23
68462: PUSH
68463: LD_VAR 0 2
68467: ARRAY
68468: PPUSH
68469: LD_INT 2
68471: PUSH
68472: LD_INT 25
68474: PUSH
68475: LD_INT 5
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 25
68484: PUSH
68485: LD_INT 8
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 25
68494: PUSH
68495: LD_INT 9
68497: PUSH
68498: EMPTY
68499: LIST
68500: LIST
68501: PUSH
68502: EMPTY
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: PPUSH
68508: CALL_OW 72
68512: ST_TO_ADDR
// if not tmp then
68513: LD_VAR 0 4
68517: NOT
68518: IFFALSE 68522
// continue ;
68520: GO 68318
// for j in tmp do
68522: LD_ADDR_VAR 0 3
68526: PUSH
68527: LD_VAR 0 4
68531: PUSH
68532: FOR_IN
68533: IFFALSE 68604
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
68535: LD_VAR 0 3
68539: PPUSH
68540: CALL_OW 310
68544: PPUSH
68545: CALL_OW 266
68549: PUSH
68550: LD_INT 5
68552: EQUAL
68553: PUSH
68554: LD_VAR 0 3
68558: PPUSH
68559: CALL_OW 257
68563: PUSH
68564: LD_INT 1
68566: EQUAL
68567: AND
68568: PUSH
68569: LD_VAR 0 3
68573: PPUSH
68574: CALL_OW 459
68578: NOT
68579: AND
68580: PUSH
68581: LD_VAR 0 7
68585: AND
68586: IFFALSE 68602
// ComChangeProfession ( j , class ) ;
68588: LD_VAR 0 3
68592: PPUSH
68593: LD_VAR 0 7
68597: PPUSH
68598: CALL_OW 123
68602: GO 68532
68604: POP
68605: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
68606: LD_EXP 46
68610: PUSH
68611: LD_VAR 0 2
68615: ARRAY
68616: PUSH
68617: LD_EXP 66
68621: PUSH
68622: LD_VAR 0 2
68626: ARRAY
68627: NOT
68628: AND
68629: PUSH
68630: LD_EXP 45
68634: PUSH
68635: LD_VAR 0 2
68639: ARRAY
68640: NOT
68641: AND
68642: PUSH
68643: LD_EXP 23
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PPUSH
68654: LD_INT 50
68656: PUSH
68657: EMPTY
68658: LIST
68659: PUSH
68660: LD_INT 2
68662: PUSH
68663: LD_INT 30
68665: PUSH
68666: LD_INT 32
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 30
68675: PUSH
68676: LD_INT 33
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 30
68685: PUSH
68686: LD_INT 4
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: PUSH
68693: LD_INT 30
68695: PUSH
68696: LD_INT 5
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: PPUSH
68714: CALL_OW 72
68718: PUSH
68719: LD_INT 4
68721: LESS
68722: PUSH
68723: LD_EXP 23
68727: PUSH
68728: LD_VAR 0 2
68732: ARRAY
68733: PPUSH
68734: LD_INT 3
68736: PUSH
68737: LD_INT 24
68739: PUSH
68740: LD_INT 1000
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: PUSH
68751: LD_INT 2
68753: PUSH
68754: LD_INT 30
68756: PUSH
68757: LD_INT 0
68759: PUSH
68760: EMPTY
68761: LIST
68762: LIST
68763: PUSH
68764: LD_INT 30
68766: PUSH
68767: LD_INT 1
68769: PUSH
68770: EMPTY
68771: LIST
68772: LIST
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PPUSH
68783: CALL_OW 72
68787: OR
68788: AND
68789: IFFALSE 69040
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68791: LD_ADDR_EXP 66
68795: PUSH
68796: LD_EXP 66
68800: PPUSH
68801: LD_VAR 0 2
68805: PPUSH
68806: LD_INT 1
68808: PPUSH
68809: CALL_OW 1
68813: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68814: LD_ADDR_VAR 0 4
68818: PUSH
68819: LD_EXP 23
68823: PUSH
68824: LD_VAR 0 2
68828: ARRAY
68829: PPUSH
68830: LD_INT 2
68832: PUSH
68833: LD_INT 25
68835: PUSH
68836: LD_INT 1
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PUSH
68843: LD_INT 25
68845: PUSH
68846: LD_INT 5
68848: PUSH
68849: EMPTY
68850: LIST
68851: LIST
68852: PUSH
68853: LD_INT 25
68855: PUSH
68856: LD_INT 8
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 25
68865: PUSH
68866: LD_INT 9
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: PPUSH
68880: CALL_OW 72
68884: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68885: LD_ADDR_VAR 0 4
68889: PUSH
68890: LD_VAR 0 4
68894: PUSH
68895: LD_VAR 0 4
68899: PPUSH
68900: LD_INT 18
68902: PPUSH
68903: CALL 46022 0 2
68907: DIFF
68908: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68909: LD_VAR 0 4
68913: NOT
68914: PUSH
68915: LD_EXP 23
68919: PUSH
68920: LD_VAR 0 2
68924: ARRAY
68925: PPUSH
68926: LD_INT 2
68928: PUSH
68929: LD_INT 30
68931: PUSH
68932: LD_INT 4
68934: PUSH
68935: EMPTY
68936: LIST
68937: LIST
68938: PUSH
68939: LD_INT 30
68941: PUSH
68942: LD_INT 5
68944: PUSH
68945: EMPTY
68946: LIST
68947: LIST
68948: PUSH
68949: EMPTY
68950: LIST
68951: LIST
68952: LIST
68953: PPUSH
68954: CALL_OW 72
68958: NOT
68959: AND
68960: IFFALSE 69022
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
68962: LD_ADDR_VAR 0 4
68966: PUSH
68967: LD_EXP 23
68971: PUSH
68972: LD_VAR 0 2
68976: ARRAY
68977: PPUSH
68978: LD_INT 2
68980: PUSH
68981: LD_INT 25
68983: PUSH
68984: LD_INT 2
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 25
68993: PUSH
68994: LD_INT 3
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: LD_INT 25
69003: PUSH
69004: LD_INT 4
69006: PUSH
69007: EMPTY
69008: LIST
69009: LIST
69010: PUSH
69011: EMPTY
69012: LIST
69013: LIST
69014: LIST
69015: LIST
69016: PPUSH
69017: CALL_OW 72
69021: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
69022: LD_VAR 0 2
69026: PPUSH
69027: LD_VAR 0 4
69031: PPUSH
69032: CALL 87767 0 2
// exit ;
69036: POP
69037: POP
69038: GO 69160
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
69040: LD_EXP 46
69044: PUSH
69045: LD_VAR 0 2
69049: ARRAY
69050: PUSH
69051: LD_EXP 66
69055: PUSH
69056: LD_VAR 0 2
69060: ARRAY
69061: NOT
69062: AND
69063: PUSH
69064: LD_EXP 45
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: AND
69075: IFFALSE 69156
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
69077: LD_ADDR_EXP 66
69081: PUSH
69082: LD_EXP 66
69086: PPUSH
69087: LD_VAR 0 2
69091: PPUSH
69092: LD_INT 1
69094: PPUSH
69095: CALL_OW 1
69099: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
69100: LD_ADDR_VAR 0 4
69104: PUSH
69105: LD_EXP 45
69109: PUSH
69110: LD_VAR 0 2
69114: ARRAY
69115: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
69116: LD_ADDR_EXP 45
69120: PUSH
69121: LD_EXP 45
69125: PPUSH
69126: LD_VAR 0 2
69130: PPUSH
69131: EMPTY
69132: PPUSH
69133: CALL_OW 1
69137: ST_TO_ADDR
// Defend ( i , tmp ) ;
69138: LD_VAR 0 2
69142: PPUSH
69143: LD_VAR 0 4
69147: PPUSH
69148: CALL 88363 0 2
// exit ;
69152: POP
69153: POP
69154: GO 69160
// end ; end ;
69156: GO 68318
69158: POP
69159: POP
// end ;
69160: LD_VAR 0 1
69164: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
69165: LD_INT 0
69167: PPUSH
69168: PPUSH
69169: PPUSH
69170: PPUSH
69171: PPUSH
69172: PPUSH
69173: PPUSH
69174: PPUSH
69175: PPUSH
69176: PPUSH
69177: PPUSH
// if not mc_bases then
69178: LD_EXP 23
69182: NOT
69183: IFFALSE 69187
// exit ;
69185: GO 70274
// for i = 1 to mc_bases do
69187: LD_ADDR_VAR 0 2
69191: PUSH
69192: DOUBLE
69193: LD_INT 1
69195: DEC
69196: ST_TO_ADDR
69197: LD_EXP 23
69201: PUSH
69202: FOR_TO
69203: IFFALSE 70272
// begin tmp := mc_lab [ i ] ;
69205: LD_ADDR_VAR 0 6
69209: PUSH
69210: LD_EXP 56
69214: PUSH
69215: LD_VAR 0 2
69219: ARRAY
69220: ST_TO_ADDR
// if not tmp then
69221: LD_VAR 0 6
69225: NOT
69226: IFFALSE 69230
// continue ;
69228: GO 69202
// idle_lab := 0 ;
69230: LD_ADDR_VAR 0 11
69234: PUSH
69235: LD_INT 0
69237: ST_TO_ADDR
// for j in tmp do
69238: LD_ADDR_VAR 0 3
69242: PUSH
69243: LD_VAR 0 6
69247: PUSH
69248: FOR_IN
69249: IFFALSE 70268
// begin researching := false ;
69251: LD_ADDR_VAR 0 10
69255: PUSH
69256: LD_INT 0
69258: ST_TO_ADDR
// side := GetSide ( j ) ;
69259: LD_ADDR_VAR 0 4
69263: PUSH
69264: LD_VAR 0 3
69268: PPUSH
69269: CALL_OW 255
69273: ST_TO_ADDR
// if not mc_tech [ side ] then
69274: LD_EXP 50
69278: PUSH
69279: LD_VAR 0 4
69283: ARRAY
69284: NOT
69285: IFFALSE 69289
// continue ;
69287: GO 69248
// if BuildingStatus ( j ) = bs_idle then
69289: LD_VAR 0 3
69293: PPUSH
69294: CALL_OW 461
69298: PUSH
69299: LD_INT 2
69301: EQUAL
69302: IFFALSE 69490
// begin if idle_lab and UnitsInside ( j ) < 6 then
69304: LD_VAR 0 11
69308: PUSH
69309: LD_VAR 0 3
69313: PPUSH
69314: CALL_OW 313
69318: PUSH
69319: LD_INT 6
69321: LESS
69322: AND
69323: IFFALSE 69394
// begin tmp2 := UnitsInside ( idle_lab ) ;
69325: LD_ADDR_VAR 0 9
69329: PUSH
69330: LD_VAR 0 11
69334: PPUSH
69335: CALL_OW 313
69339: ST_TO_ADDR
// if tmp2 then
69340: LD_VAR 0 9
69344: IFFALSE 69386
// for x in tmp2 do
69346: LD_ADDR_VAR 0 7
69350: PUSH
69351: LD_VAR 0 9
69355: PUSH
69356: FOR_IN
69357: IFFALSE 69384
// begin ComExitBuilding ( x ) ;
69359: LD_VAR 0 7
69363: PPUSH
69364: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69368: LD_VAR 0 7
69372: PPUSH
69373: LD_VAR 0 3
69377: PPUSH
69378: CALL_OW 180
// end ;
69382: GO 69356
69384: POP
69385: POP
// idle_lab := 0 ;
69386: LD_ADDR_VAR 0 11
69390: PUSH
69391: LD_INT 0
69393: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
69394: LD_ADDR_VAR 0 5
69398: PUSH
69399: LD_EXP 50
69403: PUSH
69404: LD_VAR 0 4
69408: ARRAY
69409: PUSH
69410: FOR_IN
69411: IFFALSE 69471
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
69413: LD_VAR 0 3
69417: PPUSH
69418: LD_VAR 0 5
69422: PPUSH
69423: CALL_OW 430
69427: PUSH
69428: LD_VAR 0 4
69432: PPUSH
69433: LD_VAR 0 5
69437: PPUSH
69438: CALL 11829 0 2
69442: AND
69443: IFFALSE 69469
// begin researching := true ;
69445: LD_ADDR_VAR 0 10
69449: PUSH
69450: LD_INT 1
69452: ST_TO_ADDR
// ComResearch ( j , t ) ;
69453: LD_VAR 0 3
69457: PPUSH
69458: LD_VAR 0 5
69462: PPUSH
69463: CALL_OW 124
// break ;
69467: GO 69471
// end ;
69469: GO 69410
69471: POP
69472: POP
// if not researching then
69473: LD_VAR 0 10
69477: NOT
69478: IFFALSE 69490
// idle_lab := j ;
69480: LD_ADDR_VAR 0 11
69484: PUSH
69485: LD_VAR 0 3
69489: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
69490: LD_VAR 0 3
69494: PPUSH
69495: CALL_OW 461
69499: PUSH
69500: LD_INT 10
69502: EQUAL
69503: IFFALSE 70091
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
69505: LD_EXP 52
69509: PUSH
69510: LD_VAR 0 2
69514: ARRAY
69515: NOT
69516: PUSH
69517: LD_EXP 53
69521: PUSH
69522: LD_VAR 0 2
69526: ARRAY
69527: NOT
69528: AND
69529: PUSH
69530: LD_EXP 50
69534: PUSH
69535: LD_VAR 0 4
69539: ARRAY
69540: PUSH
69541: LD_INT 1
69543: GREATER
69544: AND
69545: IFFALSE 69676
// begin ComCancel ( j ) ;
69547: LD_VAR 0 3
69551: PPUSH
69552: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
69556: LD_ADDR_EXP 50
69560: PUSH
69561: LD_EXP 50
69565: PPUSH
69566: LD_VAR 0 4
69570: PPUSH
69571: LD_EXP 50
69575: PUSH
69576: LD_VAR 0 4
69580: ARRAY
69581: PPUSH
69582: LD_EXP 50
69586: PUSH
69587: LD_VAR 0 4
69591: ARRAY
69592: PUSH
69593: LD_INT 1
69595: MINUS
69596: PPUSH
69597: LD_EXP 50
69601: PUSH
69602: LD_VAR 0 4
69606: ARRAY
69607: PPUSH
69608: LD_INT 0
69610: PPUSH
69611: CALL 15528 0 4
69615: PPUSH
69616: CALL_OW 1
69620: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
69621: LD_ADDR_EXP 50
69625: PUSH
69626: LD_EXP 50
69630: PPUSH
69631: LD_VAR 0 4
69635: PPUSH
69636: LD_EXP 50
69640: PUSH
69641: LD_VAR 0 4
69645: ARRAY
69646: PPUSH
69647: LD_EXP 50
69651: PUSH
69652: LD_VAR 0 4
69656: ARRAY
69657: PPUSH
69658: LD_INT 1
69660: PPUSH
69661: LD_INT 0
69663: PPUSH
69664: CALL 15528 0 4
69668: PPUSH
69669: CALL_OW 1
69673: ST_TO_ADDR
// continue ;
69674: GO 69248
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
69676: LD_EXP 52
69680: PUSH
69681: LD_VAR 0 2
69685: ARRAY
69686: PUSH
69687: LD_EXP 53
69691: PUSH
69692: LD_VAR 0 2
69696: ARRAY
69697: NOT
69698: AND
69699: IFFALSE 69826
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
69701: LD_ADDR_EXP 53
69705: PUSH
69706: LD_EXP 53
69710: PPUSH
69711: LD_VAR 0 2
69715: PUSH
69716: LD_EXP 53
69720: PUSH
69721: LD_VAR 0 2
69725: ARRAY
69726: PUSH
69727: LD_INT 1
69729: PLUS
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PPUSH
69735: LD_EXP 52
69739: PUSH
69740: LD_VAR 0 2
69744: ARRAY
69745: PUSH
69746: LD_INT 1
69748: ARRAY
69749: PPUSH
69750: CALL 16110 0 3
69754: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69755: LD_EXP 52
69759: PUSH
69760: LD_VAR 0 2
69764: ARRAY
69765: PUSH
69766: LD_INT 1
69768: ARRAY
69769: PPUSH
69770: LD_INT 112
69772: PPUSH
69773: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69777: LD_ADDR_VAR 0 9
69781: PUSH
69782: LD_EXP 52
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PPUSH
69793: LD_INT 1
69795: PPUSH
69796: CALL_OW 3
69800: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69801: LD_ADDR_EXP 52
69805: PUSH
69806: LD_EXP 52
69810: PPUSH
69811: LD_VAR 0 2
69815: PPUSH
69816: LD_VAR 0 9
69820: PPUSH
69821: CALL_OW 1
69825: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69826: LD_EXP 52
69830: PUSH
69831: LD_VAR 0 2
69835: ARRAY
69836: PUSH
69837: LD_EXP 53
69841: PUSH
69842: LD_VAR 0 2
69846: ARRAY
69847: AND
69848: PUSH
69849: LD_EXP 53
69853: PUSH
69854: LD_VAR 0 2
69858: ARRAY
69859: PUSH
69860: LD_INT 1
69862: ARRAY
69863: PPUSH
69864: CALL_OW 310
69868: NOT
69869: AND
69870: PUSH
69871: LD_VAR 0 3
69875: PPUSH
69876: CALL_OW 313
69880: PUSH
69881: LD_INT 6
69883: EQUAL
69884: AND
69885: IFFALSE 69941
// begin tmp2 := UnitsInside ( j ) ;
69887: LD_ADDR_VAR 0 9
69891: PUSH
69892: LD_VAR 0 3
69896: PPUSH
69897: CALL_OW 313
69901: ST_TO_ADDR
// if tmp2 = 6 then
69902: LD_VAR 0 9
69906: PUSH
69907: LD_INT 6
69909: EQUAL
69910: IFFALSE 69941
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69912: LD_VAR 0 9
69916: PUSH
69917: LD_INT 1
69919: ARRAY
69920: PPUSH
69921: LD_INT 112
69923: PPUSH
69924: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69928: LD_VAR 0 9
69932: PUSH
69933: LD_INT 1
69935: ARRAY
69936: PPUSH
69937: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69941: LD_EXP 53
69945: PUSH
69946: LD_VAR 0 2
69950: ARRAY
69951: PUSH
69952: LD_EXP 53
69956: PUSH
69957: LD_VAR 0 2
69961: ARRAY
69962: PUSH
69963: LD_INT 1
69965: ARRAY
69966: PPUSH
69967: CALL_OW 314
69971: NOT
69972: AND
69973: PUSH
69974: LD_EXP 53
69978: PUSH
69979: LD_VAR 0 2
69983: ARRAY
69984: PUSH
69985: LD_INT 1
69987: ARRAY
69988: PPUSH
69989: CALL_OW 310
69993: NOT
69994: AND
69995: IFFALSE 70021
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69997: LD_EXP 53
70001: PUSH
70002: LD_VAR 0 2
70006: ARRAY
70007: PUSH
70008: LD_INT 1
70010: ARRAY
70011: PPUSH
70012: LD_VAR 0 3
70016: PPUSH
70017: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
70021: LD_EXP 53
70025: PUSH
70026: LD_VAR 0 2
70030: ARRAY
70031: PUSH
70032: LD_INT 1
70034: ARRAY
70035: PPUSH
70036: CALL_OW 310
70040: PUSH
70041: LD_EXP 53
70045: PUSH
70046: LD_VAR 0 2
70050: ARRAY
70051: PUSH
70052: LD_INT 1
70054: ARRAY
70055: PPUSH
70056: CALL_OW 310
70060: PPUSH
70061: CALL_OW 461
70065: PUSH
70066: LD_INT 3
70068: NONEQUAL
70069: AND
70070: IFFALSE 70091
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
70072: LD_EXP 53
70076: PUSH
70077: LD_VAR 0 2
70081: ARRAY
70082: PUSH
70083: LD_INT 1
70085: ARRAY
70086: PPUSH
70087: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
70091: LD_VAR 0 3
70095: PPUSH
70096: CALL_OW 461
70100: PUSH
70101: LD_INT 6
70103: EQUAL
70104: PUSH
70105: LD_VAR 0 6
70109: PUSH
70110: LD_INT 1
70112: GREATER
70113: AND
70114: IFFALSE 70266
// begin sci := [ ] ;
70116: LD_ADDR_VAR 0 8
70120: PUSH
70121: EMPTY
70122: ST_TO_ADDR
// for x in ( tmp diff j ) do
70123: LD_ADDR_VAR 0 7
70127: PUSH
70128: LD_VAR 0 6
70132: PUSH
70133: LD_VAR 0 3
70137: DIFF
70138: PUSH
70139: FOR_IN
70140: IFFALSE 70192
// begin if sci = 6 then
70142: LD_VAR 0 8
70146: PUSH
70147: LD_INT 6
70149: EQUAL
70150: IFFALSE 70154
// break ;
70152: GO 70192
// if BuildingStatus ( x ) = bs_idle then
70154: LD_VAR 0 7
70158: PPUSH
70159: CALL_OW 461
70163: PUSH
70164: LD_INT 2
70166: EQUAL
70167: IFFALSE 70190
// sci := sci ^ UnitsInside ( x ) ;
70169: LD_ADDR_VAR 0 8
70173: PUSH
70174: LD_VAR 0 8
70178: PUSH
70179: LD_VAR 0 7
70183: PPUSH
70184: CALL_OW 313
70188: ADD
70189: ST_TO_ADDR
// end ;
70190: GO 70139
70192: POP
70193: POP
// if not sci then
70194: LD_VAR 0 8
70198: NOT
70199: IFFALSE 70203
// continue ;
70201: GO 69248
// for x in sci do
70203: LD_ADDR_VAR 0 7
70207: PUSH
70208: LD_VAR 0 8
70212: PUSH
70213: FOR_IN
70214: IFFALSE 70264
// if IsInUnit ( x ) and not HasTask ( x ) then
70216: LD_VAR 0 7
70220: PPUSH
70221: CALL_OW 310
70225: PUSH
70226: LD_VAR 0 7
70230: PPUSH
70231: CALL_OW 314
70235: NOT
70236: AND
70237: IFFALSE 70262
// begin ComExitBuilding ( x ) ;
70239: LD_VAR 0 7
70243: PPUSH
70244: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70248: LD_VAR 0 7
70252: PPUSH
70253: LD_VAR 0 3
70257: PPUSH
70258: CALL_OW 180
// end ;
70262: GO 70213
70264: POP
70265: POP
// end ; end ;
70266: GO 69248
70268: POP
70269: POP
// end ;
70270: GO 69202
70272: POP
70273: POP
// end ;
70274: LD_VAR 0 1
70278: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
70279: LD_INT 0
70281: PPUSH
70282: PPUSH
// if not mc_bases then
70283: LD_EXP 23
70287: NOT
70288: IFFALSE 70292
// exit ;
70290: GO 70373
// for i = 1 to mc_bases do
70292: LD_ADDR_VAR 0 2
70296: PUSH
70297: DOUBLE
70298: LD_INT 1
70300: DEC
70301: ST_TO_ADDR
70302: LD_EXP 23
70306: PUSH
70307: FOR_TO
70308: IFFALSE 70371
// if mc_mines [ i ] and mc_miners [ i ] then
70310: LD_EXP 36
70314: PUSH
70315: LD_VAR 0 2
70319: ARRAY
70320: PUSH
70321: LD_EXP 37
70325: PUSH
70326: LD_VAR 0 2
70330: ARRAY
70331: AND
70332: IFFALSE 70369
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
70334: LD_EXP 37
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: PPUSH
70349: CALL_OW 255
70353: PPUSH
70354: LD_EXP 36
70358: PUSH
70359: LD_VAR 0 2
70363: ARRAY
70364: PPUSH
70365: CALL 12912 0 2
70369: GO 70307
70371: POP
70372: POP
// end ;
70373: LD_VAR 0 1
70377: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
70378: LD_INT 0
70380: PPUSH
70381: PPUSH
70382: PPUSH
70383: PPUSH
70384: PPUSH
70385: PPUSH
70386: PPUSH
70387: PPUSH
// if not mc_bases or not mc_parking then
70388: LD_EXP 23
70392: NOT
70393: PUSH
70394: LD_EXP 47
70398: NOT
70399: OR
70400: IFFALSE 70404
// exit ;
70402: GO 71142
// for i = 1 to mc_bases do
70404: LD_ADDR_VAR 0 2
70408: PUSH
70409: DOUBLE
70410: LD_INT 1
70412: DEC
70413: ST_TO_ADDR
70414: LD_EXP 23
70418: PUSH
70419: FOR_TO
70420: IFFALSE 71140
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
70422: LD_EXP 23
70426: PUSH
70427: LD_VAR 0 2
70431: ARRAY
70432: NOT
70433: PUSH
70434: LD_EXP 47
70438: PUSH
70439: LD_VAR 0 2
70443: ARRAY
70444: NOT
70445: OR
70446: IFFALSE 70450
// continue ;
70448: GO 70419
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70450: LD_ADDR_VAR 0 5
70454: PUSH
70455: LD_EXP 23
70459: PUSH
70460: LD_VAR 0 2
70464: ARRAY
70465: PUSH
70466: LD_INT 1
70468: ARRAY
70469: PPUSH
70470: CALL_OW 255
70474: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70475: LD_ADDR_VAR 0 6
70479: PUSH
70480: LD_EXP 23
70484: PUSH
70485: LD_VAR 0 2
70489: ARRAY
70490: PPUSH
70491: LD_INT 30
70493: PUSH
70494: LD_INT 3
70496: PUSH
70497: EMPTY
70498: LIST
70499: LIST
70500: PPUSH
70501: CALL_OW 72
70505: ST_TO_ADDR
// if not fac then
70506: LD_VAR 0 6
70510: NOT
70511: IFFALSE 70562
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70513: LD_ADDR_VAR 0 6
70517: PUSH
70518: LD_EXP 23
70522: PUSH
70523: LD_VAR 0 2
70527: ARRAY
70528: PPUSH
70529: LD_INT 2
70531: PUSH
70532: LD_INT 30
70534: PUSH
70535: LD_INT 0
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PUSH
70542: LD_INT 30
70544: PUSH
70545: LD_INT 1
70547: PUSH
70548: EMPTY
70549: LIST
70550: LIST
70551: PUSH
70552: EMPTY
70553: LIST
70554: LIST
70555: LIST
70556: PPUSH
70557: CALL_OW 72
70561: ST_TO_ADDR
// if not fac then
70562: LD_VAR 0 6
70566: NOT
70567: IFFALSE 70571
// continue ;
70569: GO 70419
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70571: LD_ADDR_VAR 0 7
70575: PUSH
70576: LD_EXP 47
70580: PUSH
70581: LD_VAR 0 2
70585: ARRAY
70586: PPUSH
70587: LD_INT 22
70589: PUSH
70590: LD_VAR 0 5
70594: PUSH
70595: EMPTY
70596: LIST
70597: LIST
70598: PUSH
70599: LD_INT 21
70601: PUSH
70602: LD_INT 2
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: PUSH
70609: LD_INT 3
70611: PUSH
70612: LD_INT 60
70614: PUSH
70615: EMPTY
70616: LIST
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: PUSH
70622: LD_INT 3
70624: PUSH
70625: LD_INT 24
70627: PUSH
70628: LD_INT 1000
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: PPUSH
70645: CALL_OW 70
70649: ST_TO_ADDR
// for j in fac do
70650: LD_ADDR_VAR 0 3
70654: PUSH
70655: LD_VAR 0 6
70659: PUSH
70660: FOR_IN
70661: IFFALSE 70756
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
70663: LD_ADDR_VAR 0 7
70667: PUSH
70668: LD_VAR 0 7
70672: PUSH
70673: LD_INT 22
70675: PUSH
70676: LD_VAR 0 5
70680: PUSH
70681: EMPTY
70682: LIST
70683: LIST
70684: PUSH
70685: LD_INT 91
70687: PUSH
70688: LD_VAR 0 3
70692: PUSH
70693: LD_INT 15
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 21
70703: PUSH
70704: LD_INT 2
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 3
70713: PUSH
70714: LD_INT 60
70716: PUSH
70717: EMPTY
70718: LIST
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 3
70726: PUSH
70727: LD_INT 24
70729: PUSH
70730: LD_INT 1000
70732: PUSH
70733: EMPTY
70734: LIST
70735: LIST
70736: PUSH
70737: EMPTY
70738: LIST
70739: LIST
70740: PUSH
70741: EMPTY
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: PPUSH
70748: CALL_OW 69
70752: UNION
70753: ST_TO_ADDR
70754: GO 70660
70756: POP
70757: POP
// if not vehs then
70758: LD_VAR 0 7
70762: NOT
70763: IFFALSE 70789
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70765: LD_ADDR_EXP 35
70769: PUSH
70770: LD_EXP 35
70774: PPUSH
70775: LD_VAR 0 2
70779: PPUSH
70780: EMPTY
70781: PPUSH
70782: CALL_OW 1
70786: ST_TO_ADDR
// continue ;
70787: GO 70419
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70789: LD_ADDR_VAR 0 8
70793: PUSH
70794: LD_EXP 23
70798: PUSH
70799: LD_VAR 0 2
70803: ARRAY
70804: PPUSH
70805: LD_INT 30
70807: PUSH
70808: LD_INT 3
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PPUSH
70815: CALL_OW 72
70819: ST_TO_ADDR
// if tmp then
70820: LD_VAR 0 8
70824: IFFALSE 70927
// begin for j in tmp do
70826: LD_ADDR_VAR 0 3
70830: PUSH
70831: LD_VAR 0 8
70835: PUSH
70836: FOR_IN
70837: IFFALSE 70925
// for k in UnitsInside ( j ) do
70839: LD_ADDR_VAR 0 4
70843: PUSH
70844: LD_VAR 0 3
70848: PPUSH
70849: CALL_OW 313
70853: PUSH
70854: FOR_IN
70855: IFFALSE 70921
// if k then
70857: LD_VAR 0 4
70861: IFFALSE 70919
// if not k in mc_repair_vehicle [ i ] then
70863: LD_VAR 0 4
70867: PUSH
70868: LD_EXP 35
70872: PUSH
70873: LD_VAR 0 2
70877: ARRAY
70878: IN
70879: NOT
70880: IFFALSE 70919
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70882: LD_ADDR_EXP 35
70886: PUSH
70887: LD_EXP 35
70891: PPUSH
70892: LD_VAR 0 2
70896: PPUSH
70897: LD_EXP 35
70901: PUSH
70902: LD_VAR 0 2
70906: ARRAY
70907: PUSH
70908: LD_VAR 0 4
70912: UNION
70913: PPUSH
70914: CALL_OW 1
70918: ST_TO_ADDR
70919: GO 70854
70921: POP
70922: POP
70923: GO 70836
70925: POP
70926: POP
// end ; if not mc_repair_vehicle [ i ] then
70927: LD_EXP 35
70931: PUSH
70932: LD_VAR 0 2
70936: ARRAY
70937: NOT
70938: IFFALSE 70942
// continue ;
70940: GO 70419
// for j in mc_repair_vehicle [ i ] do
70942: LD_ADDR_VAR 0 3
70946: PUSH
70947: LD_EXP 35
70951: PUSH
70952: LD_VAR 0 2
70956: ARRAY
70957: PUSH
70958: FOR_IN
70959: IFFALSE 71136
// begin if GetClass ( j ) <> 3 then
70961: LD_VAR 0 3
70965: PPUSH
70966: CALL_OW 257
70970: PUSH
70971: LD_INT 3
70973: NONEQUAL
70974: IFFALSE 71015
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70976: LD_ADDR_EXP 35
70980: PUSH
70981: LD_EXP 35
70985: PPUSH
70986: LD_VAR 0 2
70990: PPUSH
70991: LD_EXP 35
70995: PUSH
70996: LD_VAR 0 2
71000: ARRAY
71001: PUSH
71002: LD_VAR 0 3
71006: DIFF
71007: PPUSH
71008: CALL_OW 1
71012: ST_TO_ADDR
// continue ;
71013: GO 70958
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71015: LD_VAR 0 3
71019: PPUSH
71020: CALL_OW 311
71024: NOT
71025: PUSH
71026: LD_VAR 0 3
71030: PUSH
71031: LD_EXP 26
71035: PUSH
71036: LD_VAR 0 2
71040: ARRAY
71041: PUSH
71042: LD_INT 1
71044: ARRAY
71045: IN
71046: NOT
71047: AND
71048: PUSH
71049: LD_VAR 0 3
71053: PUSH
71054: LD_EXP 26
71058: PUSH
71059: LD_VAR 0 2
71063: ARRAY
71064: PUSH
71065: LD_INT 2
71067: ARRAY
71068: IN
71069: NOT
71070: AND
71071: IFFALSE 71134
// begin if IsInUnit ( j ) then
71073: LD_VAR 0 3
71077: PPUSH
71078: CALL_OW 310
71082: IFFALSE 71095
// ComExitBuilding ( j ) else
71084: LD_VAR 0 3
71088: PPUSH
71089: CALL_OW 122
71093: GO 71134
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
71095: LD_VAR 0 3
71099: PPUSH
71100: LD_VAR 0 7
71104: PUSH
71105: LD_INT 1
71107: ARRAY
71108: PPUSH
71109: CALL 50506 0 2
71113: NOT
71114: IFFALSE 71134
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
71116: LD_VAR 0 3
71120: PPUSH
71121: LD_VAR 0 7
71125: PUSH
71126: LD_INT 1
71128: ARRAY
71129: PPUSH
71130: CALL_OW 129
// end ; end ;
71134: GO 70958
71136: POP
71137: POP
// end ;
71138: GO 70419
71140: POP
71141: POP
// end ;
71142: LD_VAR 0 1
71146: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
71147: LD_INT 0
71149: PPUSH
71150: PPUSH
71151: PPUSH
71152: PPUSH
71153: PPUSH
71154: PPUSH
71155: PPUSH
71156: PPUSH
71157: PPUSH
71158: PPUSH
71159: PPUSH
// if not mc_bases then
71160: LD_EXP 23
71164: NOT
71165: IFFALSE 71169
// exit ;
71167: GO 71971
// for i = 1 to mc_bases do
71169: LD_ADDR_VAR 0 2
71173: PUSH
71174: DOUBLE
71175: LD_INT 1
71177: DEC
71178: ST_TO_ADDR
71179: LD_EXP 23
71183: PUSH
71184: FOR_TO
71185: IFFALSE 71969
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
71187: LD_EXP 51
71191: PUSH
71192: LD_VAR 0 2
71196: ARRAY
71197: NOT
71198: PUSH
71199: LD_EXP 26
71203: PUSH
71204: LD_VAR 0 2
71208: ARRAY
71209: PUSH
71210: LD_INT 1
71212: ARRAY
71213: OR
71214: PUSH
71215: LD_EXP 26
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: PUSH
71226: LD_INT 2
71228: ARRAY
71229: OR
71230: PUSH
71231: LD_EXP 49
71235: PUSH
71236: LD_VAR 0 2
71240: ARRAY
71241: PPUSH
71242: LD_INT 1
71244: PPUSH
71245: CALL_OW 325
71249: NOT
71250: OR
71251: PUSH
71252: LD_EXP 46
71256: PUSH
71257: LD_VAR 0 2
71261: ARRAY
71262: OR
71263: IFFALSE 71267
// continue ;
71265: GO 71184
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
71267: LD_ADDR_VAR 0 8
71271: PUSH
71272: LD_EXP 23
71276: PUSH
71277: LD_VAR 0 2
71281: ARRAY
71282: PPUSH
71283: LD_INT 25
71285: PUSH
71286: LD_INT 4
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 50
71295: PUSH
71296: EMPTY
71297: LIST
71298: PUSH
71299: LD_INT 3
71301: PUSH
71302: LD_INT 60
71304: PUSH
71305: EMPTY
71306: LIST
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: LIST
71316: PPUSH
71317: CALL_OW 72
71321: PUSH
71322: LD_EXP 27
71326: PUSH
71327: LD_VAR 0 2
71331: ARRAY
71332: DIFF
71333: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71334: LD_ADDR_VAR 0 9
71338: PUSH
71339: LD_EXP 23
71343: PUSH
71344: LD_VAR 0 2
71348: ARRAY
71349: PPUSH
71350: LD_INT 2
71352: PUSH
71353: LD_INT 30
71355: PUSH
71356: LD_INT 0
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 30
71365: PUSH
71366: LD_INT 1
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: LIST
71377: PPUSH
71378: CALL_OW 72
71382: ST_TO_ADDR
// if not tmp or not dep then
71383: LD_VAR 0 8
71387: NOT
71388: PUSH
71389: LD_VAR 0 9
71393: NOT
71394: OR
71395: IFFALSE 71399
// continue ;
71397: GO 71184
// side := GetSide ( tmp [ 1 ] ) ;
71399: LD_ADDR_VAR 0 11
71403: PUSH
71404: LD_VAR 0 8
71408: PUSH
71409: LD_INT 1
71411: ARRAY
71412: PPUSH
71413: CALL_OW 255
71417: ST_TO_ADDR
// dep := dep [ 1 ] ;
71418: LD_ADDR_VAR 0 9
71422: PUSH
71423: LD_VAR 0 9
71427: PUSH
71428: LD_INT 1
71430: ARRAY
71431: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
71432: LD_ADDR_VAR 0 7
71436: PUSH
71437: LD_EXP 51
71441: PUSH
71442: LD_VAR 0 2
71446: ARRAY
71447: PPUSH
71448: LD_INT 22
71450: PUSH
71451: LD_INT 0
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: PUSH
71458: LD_INT 25
71460: PUSH
71461: LD_INT 12
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PPUSH
71472: CALL_OW 70
71476: PUSH
71477: LD_INT 22
71479: PUSH
71480: LD_INT 0
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 25
71489: PUSH
71490: LD_INT 12
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 91
71499: PUSH
71500: LD_VAR 0 9
71504: PUSH
71505: LD_INT 20
71507: PUSH
71508: EMPTY
71509: LIST
71510: LIST
71511: LIST
71512: PUSH
71513: EMPTY
71514: LIST
71515: LIST
71516: LIST
71517: PPUSH
71518: CALL_OW 69
71522: UNION
71523: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
71524: LD_ADDR_VAR 0 10
71528: PUSH
71529: LD_EXP 51
71533: PUSH
71534: LD_VAR 0 2
71538: ARRAY
71539: PPUSH
71540: LD_INT 81
71542: PUSH
71543: LD_VAR 0 11
71547: PUSH
71548: EMPTY
71549: LIST
71550: LIST
71551: PPUSH
71552: CALL_OW 70
71556: ST_TO_ADDR
// if not apes or danger_at_area then
71557: LD_VAR 0 7
71561: NOT
71562: PUSH
71563: LD_VAR 0 10
71567: OR
71568: IFFALSE 71618
// begin if mc_taming [ i ] then
71570: LD_EXP 54
71574: PUSH
71575: LD_VAR 0 2
71579: ARRAY
71580: IFFALSE 71616
// begin MC_Reset ( i , 121 ) ;
71582: LD_VAR 0 2
71586: PPUSH
71587: LD_INT 121
71589: PPUSH
71590: CALL 56555 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71594: LD_ADDR_EXP 54
71598: PUSH
71599: LD_EXP 54
71603: PPUSH
71604: LD_VAR 0 2
71608: PPUSH
71609: EMPTY
71610: PPUSH
71611: CALL_OW 1
71615: ST_TO_ADDR
// end ; continue ;
71616: GO 71184
// end ; for j in tmp do
71618: LD_ADDR_VAR 0 3
71622: PUSH
71623: LD_VAR 0 8
71627: PUSH
71628: FOR_IN
71629: IFFALSE 71965
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
71631: LD_VAR 0 3
71635: PUSH
71636: LD_EXP 54
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: IN
71647: NOT
71648: PUSH
71649: LD_EXP 54
71653: PUSH
71654: LD_VAR 0 2
71658: ARRAY
71659: PUSH
71660: LD_INT 3
71662: LESS
71663: AND
71664: IFFALSE 71722
// begin SetTag ( j , 121 ) ;
71666: LD_VAR 0 3
71670: PPUSH
71671: LD_INT 121
71673: PPUSH
71674: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
71678: LD_ADDR_EXP 54
71682: PUSH
71683: LD_EXP 54
71687: PPUSH
71688: LD_VAR 0 2
71692: PUSH
71693: LD_EXP 54
71697: PUSH
71698: LD_VAR 0 2
71702: ARRAY
71703: PUSH
71704: LD_INT 1
71706: PLUS
71707: PUSH
71708: EMPTY
71709: LIST
71710: LIST
71711: PPUSH
71712: LD_VAR 0 3
71716: PPUSH
71717: CALL 16110 0 3
71721: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
71722: LD_VAR 0 3
71726: PUSH
71727: LD_EXP 54
71731: PUSH
71732: LD_VAR 0 2
71736: ARRAY
71737: IN
71738: IFFALSE 71963
// begin if GetClass ( j ) <> 4 then
71740: LD_VAR 0 3
71744: PPUSH
71745: CALL_OW 257
71749: PUSH
71750: LD_INT 4
71752: NONEQUAL
71753: IFFALSE 71806
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
71755: LD_ADDR_EXP 54
71759: PUSH
71760: LD_EXP 54
71764: PPUSH
71765: LD_VAR 0 2
71769: PPUSH
71770: LD_EXP 54
71774: PUSH
71775: LD_VAR 0 2
71779: ARRAY
71780: PUSH
71781: LD_VAR 0 3
71785: DIFF
71786: PPUSH
71787: CALL_OW 1
71791: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71792: LD_VAR 0 3
71796: PPUSH
71797: LD_INT 0
71799: PPUSH
71800: CALL_OW 109
// continue ;
71804: GO 71628
// end ; if IsInUnit ( j ) then
71806: LD_VAR 0 3
71810: PPUSH
71811: CALL_OW 310
71815: IFFALSE 71826
// ComExitBuilding ( j ) ;
71817: LD_VAR 0 3
71821: PPUSH
71822: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71826: LD_ADDR_VAR 0 6
71830: PUSH
71831: LD_VAR 0 7
71835: PPUSH
71836: LD_VAR 0 3
71840: PPUSH
71841: CALL_OW 74
71845: ST_TO_ADDR
// if not ape then
71846: LD_VAR 0 6
71850: NOT
71851: IFFALSE 71855
// break ;
71853: GO 71965
// x := GetX ( ape ) ;
71855: LD_ADDR_VAR 0 4
71859: PUSH
71860: LD_VAR 0 6
71864: PPUSH
71865: CALL_OW 250
71869: ST_TO_ADDR
// y := GetY ( ape ) ;
71870: LD_ADDR_VAR 0 5
71874: PUSH
71875: LD_VAR 0 6
71879: PPUSH
71880: CALL_OW 251
71884: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71885: LD_VAR 0 4
71889: PPUSH
71890: LD_VAR 0 5
71894: PPUSH
71895: CALL_OW 488
71899: NOT
71900: PUSH
71901: LD_VAR 0 11
71905: PPUSH
71906: LD_VAR 0 4
71910: PPUSH
71911: LD_VAR 0 5
71915: PPUSH
71916: LD_INT 20
71918: PPUSH
71919: CALL 17006 0 4
71923: PUSH
71924: LD_INT 4
71926: ARRAY
71927: OR
71928: IFFALSE 71932
// break ;
71930: GO 71965
// if not HasTask ( j ) then
71932: LD_VAR 0 3
71936: PPUSH
71937: CALL_OW 314
71941: NOT
71942: IFFALSE 71963
// ComTameXY ( j , x , y ) ;
71944: LD_VAR 0 3
71948: PPUSH
71949: LD_VAR 0 4
71953: PPUSH
71954: LD_VAR 0 5
71958: PPUSH
71959: CALL_OW 131
// end ; end ;
71963: GO 71628
71965: POP
71966: POP
// end ;
71967: GO 71184
71969: POP
71970: POP
// end ;
71971: LD_VAR 0 1
71975: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71976: LD_INT 0
71978: PPUSH
71979: PPUSH
71980: PPUSH
71981: PPUSH
71982: PPUSH
71983: PPUSH
71984: PPUSH
71985: PPUSH
// if not mc_bases then
71986: LD_EXP 23
71990: NOT
71991: IFFALSE 71995
// exit ;
71993: GO 72621
// for i = 1 to mc_bases do
71995: LD_ADDR_VAR 0 2
71999: PUSH
72000: DOUBLE
72001: LD_INT 1
72003: DEC
72004: ST_TO_ADDR
72005: LD_EXP 23
72009: PUSH
72010: FOR_TO
72011: IFFALSE 72619
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72013: LD_EXP 52
72017: PUSH
72018: LD_VAR 0 2
72022: ARRAY
72023: NOT
72024: PUSH
72025: LD_EXP 52
72029: PUSH
72030: LD_VAR 0 2
72034: ARRAY
72035: PPUSH
72036: LD_INT 25
72038: PUSH
72039: LD_INT 12
72041: PUSH
72042: EMPTY
72043: LIST
72044: LIST
72045: PPUSH
72046: CALL_OW 72
72050: NOT
72051: OR
72052: IFFALSE 72056
// continue ;
72054: GO 72010
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72056: LD_ADDR_VAR 0 5
72060: PUSH
72061: LD_EXP 52
72065: PUSH
72066: LD_VAR 0 2
72070: ARRAY
72071: PUSH
72072: LD_INT 1
72074: ARRAY
72075: PPUSH
72076: CALL_OW 255
72080: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
72081: LD_VAR 0 5
72085: PPUSH
72086: LD_INT 2
72088: PPUSH
72089: CALL_OW 325
72093: IFFALSE 72346
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72095: LD_ADDR_VAR 0 4
72099: PUSH
72100: LD_EXP 52
72104: PUSH
72105: LD_VAR 0 2
72109: ARRAY
72110: PPUSH
72111: LD_INT 25
72113: PUSH
72114: LD_INT 16
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PPUSH
72121: CALL_OW 72
72125: ST_TO_ADDR
// if tmp < 6 then
72126: LD_VAR 0 4
72130: PUSH
72131: LD_INT 6
72133: LESS
72134: IFFALSE 72346
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72136: LD_ADDR_VAR 0 6
72140: PUSH
72141: LD_EXP 23
72145: PUSH
72146: LD_VAR 0 2
72150: ARRAY
72151: PPUSH
72152: LD_INT 2
72154: PUSH
72155: LD_INT 30
72157: PUSH
72158: LD_INT 0
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: PUSH
72165: LD_INT 30
72167: PUSH
72168: LD_INT 1
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: EMPTY
72176: LIST
72177: LIST
72178: LIST
72179: PPUSH
72180: CALL_OW 72
72184: ST_TO_ADDR
// if depot then
72185: LD_VAR 0 6
72189: IFFALSE 72346
// begin selected := 0 ;
72191: LD_ADDR_VAR 0 7
72195: PUSH
72196: LD_INT 0
72198: ST_TO_ADDR
// for j in depot do
72199: LD_ADDR_VAR 0 3
72203: PUSH
72204: LD_VAR 0 6
72208: PUSH
72209: FOR_IN
72210: IFFALSE 72241
// begin if UnitsInside ( j ) < 6 then
72212: LD_VAR 0 3
72216: PPUSH
72217: CALL_OW 313
72221: PUSH
72222: LD_INT 6
72224: LESS
72225: IFFALSE 72239
// begin selected := j ;
72227: LD_ADDR_VAR 0 7
72231: PUSH
72232: LD_VAR 0 3
72236: ST_TO_ADDR
// break ;
72237: GO 72241
// end ; end ;
72239: GO 72209
72241: POP
72242: POP
// if selected then
72243: LD_VAR 0 7
72247: IFFALSE 72346
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72249: LD_ADDR_VAR 0 3
72253: PUSH
72254: LD_EXP 52
72258: PUSH
72259: LD_VAR 0 2
72263: ARRAY
72264: PPUSH
72265: LD_INT 25
72267: PUSH
72268: LD_INT 12
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PPUSH
72275: CALL_OW 72
72279: PUSH
72280: FOR_IN
72281: IFFALSE 72344
// if not HasTask ( j ) then
72283: LD_VAR 0 3
72287: PPUSH
72288: CALL_OW 314
72292: NOT
72293: IFFALSE 72342
// begin if not IsInUnit ( j ) then
72295: LD_VAR 0 3
72299: PPUSH
72300: CALL_OW 310
72304: NOT
72305: IFFALSE 72321
// ComEnterUnit ( j , selected ) ;
72307: LD_VAR 0 3
72311: PPUSH
72312: LD_VAR 0 7
72316: PPUSH
72317: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
72321: LD_VAR 0 3
72325: PPUSH
72326: LD_INT 16
72328: PPUSH
72329: CALL_OW 183
// AddComExitBuilding ( j ) ;
72333: LD_VAR 0 3
72337: PPUSH
72338: CALL_OW 182
// end ;
72342: GO 72280
72344: POP
72345: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
72346: LD_VAR 0 5
72350: PPUSH
72351: LD_INT 11
72353: PPUSH
72354: CALL_OW 325
72358: IFFALSE 72617
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
72360: LD_ADDR_VAR 0 4
72364: PUSH
72365: LD_EXP 52
72369: PUSH
72370: LD_VAR 0 2
72374: ARRAY
72375: PPUSH
72376: LD_INT 25
72378: PUSH
72379: LD_INT 16
72381: PUSH
72382: EMPTY
72383: LIST
72384: LIST
72385: PPUSH
72386: CALL_OW 72
72390: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
72391: LD_VAR 0 4
72395: PUSH
72396: LD_INT 6
72398: GREATEREQUAL
72399: PUSH
72400: LD_VAR 0 5
72404: PPUSH
72405: LD_INT 2
72407: PPUSH
72408: CALL_OW 325
72412: NOT
72413: OR
72414: IFFALSE 72617
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
72416: LD_ADDR_VAR 0 8
72420: PUSH
72421: LD_EXP 23
72425: PUSH
72426: LD_VAR 0 2
72430: ARRAY
72431: PPUSH
72432: LD_INT 2
72434: PUSH
72435: LD_INT 30
72437: PUSH
72438: LD_INT 4
72440: PUSH
72441: EMPTY
72442: LIST
72443: LIST
72444: PUSH
72445: LD_INT 30
72447: PUSH
72448: LD_INT 5
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: LIST
72459: PPUSH
72460: CALL_OW 72
72464: ST_TO_ADDR
// if barracks then
72465: LD_VAR 0 8
72469: IFFALSE 72617
// begin selected := 0 ;
72471: LD_ADDR_VAR 0 7
72475: PUSH
72476: LD_INT 0
72478: ST_TO_ADDR
// for j in barracks do
72479: LD_ADDR_VAR 0 3
72483: PUSH
72484: LD_VAR 0 8
72488: PUSH
72489: FOR_IN
72490: IFFALSE 72521
// begin if UnitsInside ( j ) < 6 then
72492: LD_VAR 0 3
72496: PPUSH
72497: CALL_OW 313
72501: PUSH
72502: LD_INT 6
72504: LESS
72505: IFFALSE 72519
// begin selected := j ;
72507: LD_ADDR_VAR 0 7
72511: PUSH
72512: LD_VAR 0 3
72516: ST_TO_ADDR
// break ;
72517: GO 72521
// end ; end ;
72519: GO 72489
72521: POP
72522: POP
// if selected then
72523: LD_VAR 0 7
72527: IFFALSE 72617
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
72529: LD_ADDR_VAR 0 3
72533: PUSH
72534: LD_EXP 52
72538: PUSH
72539: LD_VAR 0 2
72543: ARRAY
72544: PPUSH
72545: LD_INT 25
72547: PUSH
72548: LD_INT 12
72550: PUSH
72551: EMPTY
72552: LIST
72553: LIST
72554: PPUSH
72555: CALL_OW 72
72559: PUSH
72560: FOR_IN
72561: IFFALSE 72615
// if not IsInUnit ( j ) and not HasTask ( j ) then
72563: LD_VAR 0 3
72567: PPUSH
72568: CALL_OW 310
72572: NOT
72573: PUSH
72574: LD_VAR 0 3
72578: PPUSH
72579: CALL_OW 314
72583: NOT
72584: AND
72585: IFFALSE 72613
// begin ComEnterUnit ( j , selected ) ;
72587: LD_VAR 0 3
72591: PPUSH
72592: LD_VAR 0 7
72596: PPUSH
72597: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
72601: LD_VAR 0 3
72605: PPUSH
72606: LD_INT 15
72608: PPUSH
72609: CALL_OW 183
// end ;
72613: GO 72560
72615: POP
72616: POP
// end ; end ; end ; end ; end ;
72617: GO 72010
72619: POP
72620: POP
// end ;
72621: LD_VAR 0 1
72625: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
72626: LD_INT 0
72628: PPUSH
72629: PPUSH
72630: PPUSH
72631: PPUSH
// if not mc_bases then
72632: LD_EXP 23
72636: NOT
72637: IFFALSE 72641
// exit ;
72639: GO 72819
// for i = 1 to mc_bases do
72641: LD_ADDR_VAR 0 2
72645: PUSH
72646: DOUBLE
72647: LD_INT 1
72649: DEC
72650: ST_TO_ADDR
72651: LD_EXP 23
72655: PUSH
72656: FOR_TO
72657: IFFALSE 72817
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
72659: LD_ADDR_VAR 0 4
72663: PUSH
72664: LD_EXP 23
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: PPUSH
72675: LD_INT 25
72677: PUSH
72678: LD_INT 9
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PPUSH
72685: CALL_OW 72
72689: ST_TO_ADDR
// if not tmp then
72690: LD_VAR 0 4
72694: NOT
72695: IFFALSE 72699
// continue ;
72697: GO 72656
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
72699: LD_EXP 49
72703: PUSH
72704: LD_VAR 0 2
72708: ARRAY
72709: PPUSH
72710: LD_INT 29
72712: PPUSH
72713: CALL_OW 325
72717: NOT
72718: PUSH
72719: LD_EXP 49
72723: PUSH
72724: LD_VAR 0 2
72728: ARRAY
72729: PPUSH
72730: LD_INT 28
72732: PPUSH
72733: CALL_OW 325
72737: NOT
72738: AND
72739: IFFALSE 72743
// continue ;
72741: GO 72656
// for j in tmp do
72743: LD_ADDR_VAR 0 3
72747: PUSH
72748: LD_VAR 0 4
72752: PUSH
72753: FOR_IN
72754: IFFALSE 72813
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72756: LD_VAR 0 3
72760: PUSH
72761: LD_EXP 26
72765: PUSH
72766: LD_VAR 0 2
72770: ARRAY
72771: PUSH
72772: LD_INT 1
72774: ARRAY
72775: IN
72776: NOT
72777: PUSH
72778: LD_VAR 0 3
72782: PUSH
72783: LD_EXP 26
72787: PUSH
72788: LD_VAR 0 2
72792: ARRAY
72793: PUSH
72794: LD_INT 2
72796: ARRAY
72797: IN
72798: NOT
72799: AND
72800: IFFALSE 72811
// ComSpaceTimeShoot ( j ) ;
72802: LD_VAR 0 3
72806: PPUSH
72807: CALL 11920 0 1
72811: GO 72753
72813: POP
72814: POP
// end ;
72815: GO 72656
72817: POP
72818: POP
// end ;
72819: LD_VAR 0 1
72823: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72824: LD_INT 0
72826: PPUSH
72827: PPUSH
72828: PPUSH
72829: PPUSH
72830: PPUSH
72831: PPUSH
72832: PPUSH
72833: PPUSH
72834: PPUSH
// if not mc_bases then
72835: LD_EXP 23
72839: NOT
72840: IFFALSE 72844
// exit ;
72842: GO 73466
// for i = 1 to mc_bases do
72844: LD_ADDR_VAR 0 2
72848: PUSH
72849: DOUBLE
72850: LD_INT 1
72852: DEC
72853: ST_TO_ADDR
72854: LD_EXP 23
72858: PUSH
72859: FOR_TO
72860: IFFALSE 73464
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72862: LD_EXP 58
72866: PUSH
72867: LD_VAR 0 2
72871: ARRAY
72872: NOT
72873: PUSH
72874: LD_INT 38
72876: PPUSH
72877: LD_EXP 49
72881: PUSH
72882: LD_VAR 0 2
72886: ARRAY
72887: PPUSH
72888: CALL_OW 321
72892: PUSH
72893: LD_INT 2
72895: NONEQUAL
72896: OR
72897: IFFALSE 72901
// continue ;
72899: GO 72859
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72901: LD_ADDR_VAR 0 8
72905: PUSH
72906: LD_EXP 23
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: PPUSH
72917: LD_INT 30
72919: PUSH
72920: LD_INT 34
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PPUSH
72927: CALL_OW 72
72931: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72932: LD_ADDR_VAR 0 9
72936: PUSH
72937: LD_EXP 23
72941: PUSH
72942: LD_VAR 0 2
72946: ARRAY
72947: PPUSH
72948: LD_INT 25
72950: PUSH
72951: LD_INT 4
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PPUSH
72958: CALL_OW 72
72962: PPUSH
72963: LD_INT 0
72965: PPUSH
72966: CALL 46022 0 2
72970: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72971: LD_VAR 0 9
72975: NOT
72976: PUSH
72977: LD_VAR 0 8
72981: NOT
72982: OR
72983: PUSH
72984: LD_EXP 23
72988: PUSH
72989: LD_VAR 0 2
72993: ARRAY
72994: PPUSH
72995: LD_INT 124
72997: PPUSH
72998: CALL 46022 0 2
73002: OR
73003: IFFALSE 73007
// continue ;
73005: GO 72859
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73007: LD_EXP 59
73011: PUSH
73012: LD_VAR 0 2
73016: ARRAY
73017: PUSH
73018: LD_EXP 58
73022: PUSH
73023: LD_VAR 0 2
73027: ARRAY
73028: LESS
73029: PUSH
73030: LD_EXP 59
73034: PUSH
73035: LD_VAR 0 2
73039: ARRAY
73040: PUSH
73041: LD_VAR 0 8
73045: LESS
73046: AND
73047: IFFALSE 73462
// begin tmp := sci [ 1 ] ;
73049: LD_ADDR_VAR 0 7
73053: PUSH
73054: LD_VAR 0 9
73058: PUSH
73059: LD_INT 1
73061: ARRAY
73062: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
73063: LD_VAR 0 7
73067: PPUSH
73068: LD_INT 124
73070: PPUSH
73071: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
73075: LD_ADDR_VAR 0 3
73079: PUSH
73080: DOUBLE
73081: LD_EXP 58
73085: PUSH
73086: LD_VAR 0 2
73090: ARRAY
73091: INC
73092: ST_TO_ADDR
73093: LD_EXP 58
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PUSH
73104: FOR_DOWNTO
73105: IFFALSE 73448
// begin if IsInUnit ( tmp ) then
73107: LD_VAR 0 7
73111: PPUSH
73112: CALL_OW 310
73116: IFFALSE 73127
// ComExitBuilding ( tmp ) ;
73118: LD_VAR 0 7
73122: PPUSH
73123: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
73127: LD_INT 35
73129: PPUSH
73130: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
73134: LD_VAR 0 7
73138: PPUSH
73139: CALL_OW 310
73143: NOT
73144: PUSH
73145: LD_VAR 0 7
73149: PPUSH
73150: CALL_OW 314
73154: NOT
73155: AND
73156: IFFALSE 73127
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
73158: LD_ADDR_VAR 0 6
73162: PUSH
73163: LD_VAR 0 7
73167: PPUSH
73168: CALL_OW 250
73172: PUSH
73173: LD_VAR 0 7
73177: PPUSH
73178: CALL_OW 251
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
73187: LD_INT 35
73189: PPUSH
73190: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
73194: LD_ADDR_VAR 0 4
73198: PUSH
73199: LD_EXP 58
73203: PUSH
73204: LD_VAR 0 2
73208: ARRAY
73209: PUSH
73210: LD_VAR 0 3
73214: ARRAY
73215: PUSH
73216: LD_INT 1
73218: ARRAY
73219: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
73220: LD_ADDR_VAR 0 5
73224: PUSH
73225: LD_EXP 58
73229: PUSH
73230: LD_VAR 0 2
73234: ARRAY
73235: PUSH
73236: LD_VAR 0 3
73240: ARRAY
73241: PUSH
73242: LD_INT 2
73244: ARRAY
73245: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
73246: LD_VAR 0 7
73250: PPUSH
73251: LD_INT 10
73253: PPUSH
73254: CALL 18707 0 2
73258: PUSH
73259: LD_INT 4
73261: ARRAY
73262: IFFALSE 73300
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
73264: LD_VAR 0 7
73268: PPUSH
73269: LD_VAR 0 6
73273: PUSH
73274: LD_INT 1
73276: ARRAY
73277: PPUSH
73278: LD_VAR 0 6
73282: PUSH
73283: LD_INT 2
73285: ARRAY
73286: PPUSH
73287: CALL_OW 111
// wait ( 0 0$10 ) ;
73291: LD_INT 350
73293: PPUSH
73294: CALL_OW 67
// end else
73298: GO 73326
// begin ComMoveXY ( tmp , x , y ) ;
73300: LD_VAR 0 7
73304: PPUSH
73305: LD_VAR 0 4
73309: PPUSH
73310: LD_VAR 0 5
73314: PPUSH
73315: CALL_OW 111
// wait ( 0 0$3 ) ;
73319: LD_INT 105
73321: PPUSH
73322: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
73326: LD_VAR 0 7
73330: PPUSH
73331: LD_VAR 0 4
73335: PPUSH
73336: LD_VAR 0 5
73340: PPUSH
73341: CALL_OW 307
73345: IFFALSE 73187
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
73347: LD_VAR 0 7
73351: PPUSH
73352: LD_VAR 0 4
73356: PPUSH
73357: LD_VAR 0 5
73361: PPUSH
73362: LD_VAR 0 8
73366: PUSH
73367: LD_VAR 0 3
73371: ARRAY
73372: PPUSH
73373: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
73377: LD_INT 35
73379: PPUSH
73380: CALL_OW 67
// until not HasTask ( tmp ) ;
73384: LD_VAR 0 7
73388: PPUSH
73389: CALL_OW 314
73393: NOT
73394: IFFALSE 73377
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
73396: LD_ADDR_EXP 59
73400: PUSH
73401: LD_EXP 59
73405: PPUSH
73406: LD_VAR 0 2
73410: PUSH
73411: LD_EXP 59
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PUSH
73422: LD_INT 1
73424: PLUS
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PPUSH
73430: LD_VAR 0 8
73434: PUSH
73435: LD_VAR 0 3
73439: ARRAY
73440: PPUSH
73441: CALL 16110 0 3
73445: ST_TO_ADDR
// end ;
73446: GO 73104
73448: POP
73449: POP
// MC_Reset ( i , 124 ) ;
73450: LD_VAR 0 2
73454: PPUSH
73455: LD_INT 124
73457: PPUSH
73458: CALL 56555 0 2
// end ; end ;
73462: GO 72859
73464: POP
73465: POP
// end ;
73466: LD_VAR 0 1
73470: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
73471: LD_INT 0
73473: PPUSH
73474: PPUSH
73475: PPUSH
// if not mc_bases then
73476: LD_EXP 23
73480: NOT
73481: IFFALSE 73485
// exit ;
73483: GO 74091
// for i = 1 to mc_bases do
73485: LD_ADDR_VAR 0 2
73489: PUSH
73490: DOUBLE
73491: LD_INT 1
73493: DEC
73494: ST_TO_ADDR
73495: LD_EXP 23
73499: PUSH
73500: FOR_TO
73501: IFFALSE 74089
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
73503: LD_ADDR_VAR 0 3
73507: PUSH
73508: LD_EXP 23
73512: PUSH
73513: LD_VAR 0 2
73517: ARRAY
73518: PPUSH
73519: LD_INT 25
73521: PUSH
73522: LD_INT 4
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: PPUSH
73529: CALL_OW 72
73533: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
73534: LD_VAR 0 3
73538: NOT
73539: PUSH
73540: LD_EXP 60
73544: PUSH
73545: LD_VAR 0 2
73549: ARRAY
73550: NOT
73551: OR
73552: PUSH
73553: LD_EXP 23
73557: PUSH
73558: LD_VAR 0 2
73562: ARRAY
73563: PPUSH
73564: LD_INT 2
73566: PUSH
73567: LD_INT 30
73569: PUSH
73570: LD_INT 0
73572: PUSH
73573: EMPTY
73574: LIST
73575: LIST
73576: PUSH
73577: LD_INT 30
73579: PUSH
73580: LD_INT 1
73582: PUSH
73583: EMPTY
73584: LIST
73585: LIST
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: LIST
73591: PPUSH
73592: CALL_OW 72
73596: NOT
73597: OR
73598: IFFALSE 73648
// begin if mc_deposits_finder [ i ] then
73600: LD_EXP 61
73604: PUSH
73605: LD_VAR 0 2
73609: ARRAY
73610: IFFALSE 73646
// begin MC_Reset ( i , 125 ) ;
73612: LD_VAR 0 2
73616: PPUSH
73617: LD_INT 125
73619: PPUSH
73620: CALL 56555 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73624: LD_ADDR_EXP 61
73628: PUSH
73629: LD_EXP 61
73633: PPUSH
73634: LD_VAR 0 2
73638: PPUSH
73639: EMPTY
73640: PPUSH
73641: CALL_OW 1
73645: ST_TO_ADDR
// end ; continue ;
73646: GO 73500
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
73648: LD_EXP 60
73652: PUSH
73653: LD_VAR 0 2
73657: ARRAY
73658: PUSH
73659: LD_INT 1
73661: ARRAY
73662: PUSH
73663: LD_INT 3
73665: ARRAY
73666: PUSH
73667: LD_INT 1
73669: EQUAL
73670: PUSH
73671: LD_INT 20
73673: PPUSH
73674: LD_EXP 49
73678: PUSH
73679: LD_VAR 0 2
73683: ARRAY
73684: PPUSH
73685: CALL_OW 321
73689: PUSH
73690: LD_INT 2
73692: NONEQUAL
73693: AND
73694: IFFALSE 73744
// begin if mc_deposits_finder [ i ] then
73696: LD_EXP 61
73700: PUSH
73701: LD_VAR 0 2
73705: ARRAY
73706: IFFALSE 73742
// begin MC_Reset ( i , 125 ) ;
73708: LD_VAR 0 2
73712: PPUSH
73713: LD_INT 125
73715: PPUSH
73716: CALL 56555 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
73720: LD_ADDR_EXP 61
73724: PUSH
73725: LD_EXP 61
73729: PPUSH
73730: LD_VAR 0 2
73734: PPUSH
73735: EMPTY
73736: PPUSH
73737: CALL_OW 1
73741: ST_TO_ADDR
// end ; continue ;
73742: GO 73500
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
73744: LD_EXP 60
73748: PUSH
73749: LD_VAR 0 2
73753: ARRAY
73754: PUSH
73755: LD_INT 1
73757: ARRAY
73758: PUSH
73759: LD_INT 1
73761: ARRAY
73762: PPUSH
73763: LD_EXP 60
73767: PUSH
73768: LD_VAR 0 2
73772: ARRAY
73773: PUSH
73774: LD_INT 1
73776: ARRAY
73777: PUSH
73778: LD_INT 2
73780: ARRAY
73781: PPUSH
73782: LD_EXP 49
73786: PUSH
73787: LD_VAR 0 2
73791: ARRAY
73792: PPUSH
73793: CALL_OW 440
73797: IFFALSE 73840
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73799: LD_ADDR_EXP 60
73803: PUSH
73804: LD_EXP 60
73808: PPUSH
73809: LD_VAR 0 2
73813: PPUSH
73814: LD_EXP 60
73818: PUSH
73819: LD_VAR 0 2
73823: ARRAY
73824: PPUSH
73825: LD_INT 1
73827: PPUSH
73828: CALL_OW 3
73832: PPUSH
73833: CALL_OW 1
73837: ST_TO_ADDR
73838: GO 74087
// begin if not mc_deposits_finder [ i ] then
73840: LD_EXP 61
73844: PUSH
73845: LD_VAR 0 2
73849: ARRAY
73850: NOT
73851: IFFALSE 73903
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73853: LD_ADDR_EXP 61
73857: PUSH
73858: LD_EXP 61
73862: PPUSH
73863: LD_VAR 0 2
73867: PPUSH
73868: LD_VAR 0 3
73872: PUSH
73873: LD_INT 1
73875: ARRAY
73876: PUSH
73877: EMPTY
73878: LIST
73879: PPUSH
73880: CALL_OW 1
73884: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73885: LD_VAR 0 3
73889: PUSH
73890: LD_INT 1
73892: ARRAY
73893: PPUSH
73894: LD_INT 125
73896: PPUSH
73897: CALL_OW 109
// end else
73901: GO 74087
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73903: LD_EXP 61
73907: PUSH
73908: LD_VAR 0 2
73912: ARRAY
73913: PUSH
73914: LD_INT 1
73916: ARRAY
73917: PPUSH
73918: CALL_OW 310
73922: IFFALSE 73945
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73924: LD_EXP 61
73928: PUSH
73929: LD_VAR 0 2
73933: ARRAY
73934: PUSH
73935: LD_INT 1
73937: ARRAY
73938: PPUSH
73939: CALL_OW 122
73943: GO 74087
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73945: LD_EXP 61
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PUSH
73956: LD_INT 1
73958: ARRAY
73959: PPUSH
73960: CALL_OW 314
73964: NOT
73965: PUSH
73966: LD_EXP 61
73970: PUSH
73971: LD_VAR 0 2
73975: ARRAY
73976: PUSH
73977: LD_INT 1
73979: ARRAY
73980: PPUSH
73981: LD_EXP 60
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: PUSH
73992: LD_INT 1
73994: ARRAY
73995: PUSH
73996: LD_INT 1
73998: ARRAY
73999: PPUSH
74000: LD_EXP 60
74004: PUSH
74005: LD_VAR 0 2
74009: ARRAY
74010: PUSH
74011: LD_INT 1
74013: ARRAY
74014: PUSH
74015: LD_INT 2
74017: ARRAY
74018: PPUSH
74019: CALL_OW 297
74023: PUSH
74024: LD_INT 6
74026: GREATER
74027: AND
74028: IFFALSE 74087
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74030: LD_EXP 61
74034: PUSH
74035: LD_VAR 0 2
74039: ARRAY
74040: PUSH
74041: LD_INT 1
74043: ARRAY
74044: PPUSH
74045: LD_EXP 60
74049: PUSH
74050: LD_VAR 0 2
74054: ARRAY
74055: PUSH
74056: LD_INT 1
74058: ARRAY
74059: PUSH
74060: LD_INT 1
74062: ARRAY
74063: PPUSH
74064: LD_EXP 60
74068: PUSH
74069: LD_VAR 0 2
74073: ARRAY
74074: PUSH
74075: LD_INT 1
74077: ARRAY
74078: PUSH
74079: LD_INT 2
74081: ARRAY
74082: PPUSH
74083: CALL_OW 111
// end ; end ; end ;
74087: GO 73500
74089: POP
74090: POP
// end ;
74091: LD_VAR 0 1
74095: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
74096: LD_INT 0
74098: PPUSH
74099: PPUSH
74100: PPUSH
74101: PPUSH
74102: PPUSH
74103: PPUSH
74104: PPUSH
74105: PPUSH
74106: PPUSH
74107: PPUSH
74108: PPUSH
// if not mc_bases then
74109: LD_EXP 23
74113: NOT
74114: IFFALSE 74118
// exit ;
74116: GO 75058
// for i = 1 to mc_bases do
74118: LD_ADDR_VAR 0 2
74122: PUSH
74123: DOUBLE
74124: LD_INT 1
74126: DEC
74127: ST_TO_ADDR
74128: LD_EXP 23
74132: PUSH
74133: FOR_TO
74134: IFFALSE 75056
// begin if not mc_bases [ i ] or mc_scan [ i ] then
74136: LD_EXP 23
74140: PUSH
74141: LD_VAR 0 2
74145: ARRAY
74146: NOT
74147: PUSH
74148: LD_EXP 46
74152: PUSH
74153: LD_VAR 0 2
74157: ARRAY
74158: OR
74159: IFFALSE 74163
// continue ;
74161: GO 74133
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
74163: LD_ADDR_VAR 0 7
74167: PUSH
74168: LD_EXP 23
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: PUSH
74179: LD_INT 1
74181: ARRAY
74182: PPUSH
74183: CALL_OW 248
74187: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
74188: LD_VAR 0 7
74192: PUSH
74193: LD_INT 3
74195: EQUAL
74196: PUSH
74197: LD_EXP 42
74201: PUSH
74202: LD_VAR 0 2
74206: ARRAY
74207: PUSH
74208: LD_EXP 45
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: UNION
74219: PPUSH
74220: LD_INT 33
74222: PUSH
74223: LD_INT 2
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PPUSH
74230: CALL_OW 72
74234: NOT
74235: OR
74236: IFFALSE 74240
// continue ;
74238: GO 74133
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
74240: LD_ADDR_VAR 0 9
74244: PUSH
74245: LD_EXP 23
74249: PUSH
74250: LD_VAR 0 2
74254: ARRAY
74255: PPUSH
74256: LD_INT 30
74258: PUSH
74259: LD_INT 36
74261: PUSH
74262: EMPTY
74263: LIST
74264: LIST
74265: PPUSH
74266: CALL_OW 72
74270: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
74271: LD_ADDR_VAR 0 10
74275: PUSH
74276: LD_EXP 42
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PPUSH
74287: LD_INT 34
74289: PUSH
74290: LD_INT 31
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PPUSH
74297: CALL_OW 72
74301: ST_TO_ADDR
// if not cts and not mcts then
74302: LD_VAR 0 9
74306: NOT
74307: PUSH
74308: LD_VAR 0 10
74312: NOT
74313: AND
74314: IFFALSE 74318
// continue ;
74316: GO 74133
// x := cts ;
74318: LD_ADDR_VAR 0 11
74322: PUSH
74323: LD_VAR 0 9
74327: ST_TO_ADDR
// if not x then
74328: LD_VAR 0 11
74332: NOT
74333: IFFALSE 74345
// x := mcts ;
74335: LD_ADDR_VAR 0 11
74339: PUSH
74340: LD_VAR 0 10
74344: ST_TO_ADDR
// if not x then
74345: LD_VAR 0 11
74349: NOT
74350: IFFALSE 74354
// continue ;
74352: GO 74133
// if mc_remote_driver [ i ] then
74354: LD_EXP 63
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: IFFALSE 74751
// for j in mc_remote_driver [ i ] do
74366: LD_ADDR_VAR 0 3
74370: PUSH
74371: LD_EXP 63
74375: PUSH
74376: LD_VAR 0 2
74380: ARRAY
74381: PUSH
74382: FOR_IN
74383: IFFALSE 74749
// begin if GetClass ( j ) <> 3 then
74385: LD_VAR 0 3
74389: PPUSH
74390: CALL_OW 257
74394: PUSH
74395: LD_INT 3
74397: NONEQUAL
74398: IFFALSE 74451
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
74400: LD_ADDR_EXP 63
74404: PUSH
74405: LD_EXP 63
74409: PPUSH
74410: LD_VAR 0 2
74414: PPUSH
74415: LD_EXP 63
74419: PUSH
74420: LD_VAR 0 2
74424: ARRAY
74425: PUSH
74426: LD_VAR 0 3
74430: DIFF
74431: PPUSH
74432: CALL_OW 1
74436: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74437: LD_VAR 0 3
74441: PPUSH
74442: LD_INT 0
74444: PPUSH
74445: CALL_OW 109
// continue ;
74449: GO 74382
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
74451: LD_EXP 42
74455: PUSH
74456: LD_VAR 0 2
74460: ARRAY
74461: PPUSH
74462: LD_INT 34
74464: PUSH
74465: LD_INT 31
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: LD_INT 58
74474: PUSH
74475: EMPTY
74476: LIST
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: PPUSH
74482: CALL_OW 72
74486: PUSH
74487: LD_VAR 0 3
74491: PPUSH
74492: CALL 46057 0 1
74496: NOT
74497: AND
74498: IFFALSE 74569
// begin if IsInUnit ( j ) then
74500: LD_VAR 0 3
74504: PPUSH
74505: CALL_OW 310
74509: IFFALSE 74520
// ComExitBuilding ( j ) ;
74511: LD_VAR 0 3
74515: PPUSH
74516: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
74520: LD_VAR 0 3
74524: PPUSH
74525: LD_EXP 42
74529: PUSH
74530: LD_VAR 0 2
74534: ARRAY
74535: PPUSH
74536: LD_INT 34
74538: PUSH
74539: LD_INT 31
74541: PUSH
74542: EMPTY
74543: LIST
74544: LIST
74545: PUSH
74546: LD_INT 58
74548: PUSH
74549: EMPTY
74550: LIST
74551: PUSH
74552: EMPTY
74553: LIST
74554: LIST
74555: PPUSH
74556: CALL_OW 72
74560: PUSH
74561: LD_INT 1
74563: ARRAY
74564: PPUSH
74565: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
74569: LD_VAR 0 3
74573: PPUSH
74574: CALL_OW 310
74578: NOT
74579: PUSH
74580: LD_VAR 0 3
74584: PPUSH
74585: CALL_OW 310
74589: PPUSH
74590: CALL_OW 266
74594: PUSH
74595: LD_INT 36
74597: NONEQUAL
74598: PUSH
74599: LD_VAR 0 3
74603: PPUSH
74604: CALL 46057 0 1
74608: NOT
74609: AND
74610: OR
74611: IFFALSE 74747
// begin if IsInUnit ( j ) then
74613: LD_VAR 0 3
74617: PPUSH
74618: CALL_OW 310
74622: IFFALSE 74633
// ComExitBuilding ( j ) ;
74624: LD_VAR 0 3
74628: PPUSH
74629: CALL_OW 122
// ct := 0 ;
74633: LD_ADDR_VAR 0 8
74637: PUSH
74638: LD_INT 0
74640: ST_TO_ADDR
// for k in x do
74641: LD_ADDR_VAR 0 4
74645: PUSH
74646: LD_VAR 0 11
74650: PUSH
74651: FOR_IN
74652: IFFALSE 74725
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
74654: LD_VAR 0 4
74658: PPUSH
74659: CALL_OW 264
74663: PUSH
74664: LD_INT 31
74666: EQUAL
74667: PUSH
74668: LD_VAR 0 4
74672: PPUSH
74673: CALL_OW 311
74677: NOT
74678: AND
74679: PUSH
74680: LD_VAR 0 4
74684: PPUSH
74685: CALL_OW 266
74689: PUSH
74690: LD_INT 36
74692: EQUAL
74693: PUSH
74694: LD_VAR 0 4
74698: PPUSH
74699: CALL_OW 313
74703: PUSH
74704: LD_INT 3
74706: LESS
74707: AND
74708: OR
74709: IFFALSE 74723
// begin ct := k ;
74711: LD_ADDR_VAR 0 8
74715: PUSH
74716: LD_VAR 0 4
74720: ST_TO_ADDR
// break ;
74721: GO 74725
// end ;
74723: GO 74651
74725: POP
74726: POP
// if ct then
74727: LD_VAR 0 8
74731: IFFALSE 74747
// ComEnterUnit ( j , ct ) ;
74733: LD_VAR 0 3
74737: PPUSH
74738: LD_VAR 0 8
74742: PPUSH
74743: CALL_OW 120
// end ; end ;
74747: GO 74382
74749: POP
74750: POP
// places := 0 ;
74751: LD_ADDR_VAR 0 5
74755: PUSH
74756: LD_INT 0
74758: ST_TO_ADDR
// for j = 1 to x do
74759: LD_ADDR_VAR 0 3
74763: PUSH
74764: DOUBLE
74765: LD_INT 1
74767: DEC
74768: ST_TO_ADDR
74769: LD_VAR 0 11
74773: PUSH
74774: FOR_TO
74775: IFFALSE 74851
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74777: LD_VAR 0 11
74781: PUSH
74782: LD_VAR 0 3
74786: ARRAY
74787: PPUSH
74788: CALL_OW 264
74792: PUSH
74793: LD_INT 31
74795: EQUAL
74796: IFFALSE 74814
// places := places + 1 else
74798: LD_ADDR_VAR 0 5
74802: PUSH
74803: LD_VAR 0 5
74807: PUSH
74808: LD_INT 1
74810: PLUS
74811: ST_TO_ADDR
74812: GO 74849
// if GetBType ( x [ j ] ) = b_control_tower then
74814: LD_VAR 0 11
74818: PUSH
74819: LD_VAR 0 3
74823: ARRAY
74824: PPUSH
74825: CALL_OW 266
74829: PUSH
74830: LD_INT 36
74832: EQUAL
74833: IFFALSE 74849
// places := places + 3 ;
74835: LD_ADDR_VAR 0 5
74839: PUSH
74840: LD_VAR 0 5
74844: PUSH
74845: LD_INT 3
74847: PLUS
74848: ST_TO_ADDR
74849: GO 74774
74851: POP
74852: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74853: LD_VAR 0 5
74857: PUSH
74858: LD_INT 0
74860: EQUAL
74861: PUSH
74862: LD_VAR 0 5
74866: PUSH
74867: LD_EXP 63
74871: PUSH
74872: LD_VAR 0 2
74876: ARRAY
74877: LESSEQUAL
74878: OR
74879: IFFALSE 74883
// continue ;
74881: GO 74133
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74883: LD_ADDR_VAR 0 6
74887: PUSH
74888: LD_EXP 23
74892: PUSH
74893: LD_VAR 0 2
74897: ARRAY
74898: PPUSH
74899: LD_INT 25
74901: PUSH
74902: LD_INT 3
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PPUSH
74909: CALL_OW 72
74913: PUSH
74914: LD_EXP 63
74918: PUSH
74919: LD_VAR 0 2
74923: ARRAY
74924: DIFF
74925: PPUSH
74926: LD_INT 3
74928: PPUSH
74929: CALL 46957 0 2
74933: ST_TO_ADDR
// for j in tmp do
74934: LD_ADDR_VAR 0 3
74938: PUSH
74939: LD_VAR 0 6
74943: PUSH
74944: FOR_IN
74945: IFFALSE 74980
// if GetTag ( j ) > 0 then
74947: LD_VAR 0 3
74951: PPUSH
74952: CALL_OW 110
74956: PUSH
74957: LD_INT 0
74959: GREATER
74960: IFFALSE 74978
// tmp := tmp diff j ;
74962: LD_ADDR_VAR 0 6
74966: PUSH
74967: LD_VAR 0 6
74971: PUSH
74972: LD_VAR 0 3
74976: DIFF
74977: ST_TO_ADDR
74978: GO 74944
74980: POP
74981: POP
// if not tmp then
74982: LD_VAR 0 6
74986: NOT
74987: IFFALSE 74991
// continue ;
74989: GO 74133
// if places then
74991: LD_VAR 0 5
74995: IFFALSE 75054
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74997: LD_ADDR_EXP 63
75001: PUSH
75002: LD_EXP 63
75006: PPUSH
75007: LD_VAR 0 2
75011: PPUSH
75012: LD_EXP 63
75016: PUSH
75017: LD_VAR 0 2
75021: ARRAY
75022: PUSH
75023: LD_VAR 0 6
75027: PUSH
75028: LD_INT 1
75030: ARRAY
75031: UNION
75032: PPUSH
75033: CALL_OW 1
75037: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75038: LD_VAR 0 6
75042: PUSH
75043: LD_INT 1
75045: ARRAY
75046: PPUSH
75047: LD_INT 126
75049: PPUSH
75050: CALL_OW 109
// end ; end ;
75054: GO 74133
75056: POP
75057: POP
// end ;
75058: LD_VAR 0 1
75062: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75063: LD_INT 0
75065: PPUSH
75066: PPUSH
75067: PPUSH
75068: PPUSH
75069: PPUSH
75070: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75071: LD_VAR 0 1
75075: NOT
75076: PUSH
75077: LD_VAR 0 2
75081: NOT
75082: OR
75083: PUSH
75084: LD_VAR 0 3
75088: NOT
75089: OR
75090: PUSH
75091: LD_VAR 0 4
75095: PUSH
75096: LD_INT 1
75098: PUSH
75099: LD_INT 2
75101: PUSH
75102: LD_INT 3
75104: PUSH
75105: LD_INT 4
75107: PUSH
75108: LD_INT 5
75110: PUSH
75111: LD_INT 8
75113: PUSH
75114: LD_INT 9
75116: PUSH
75117: LD_INT 15
75119: PUSH
75120: LD_INT 16
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: IN
75134: NOT
75135: OR
75136: IFFALSE 75140
// exit ;
75138: GO 76040
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75140: LD_ADDR_VAR 0 2
75144: PUSH
75145: LD_VAR 0 2
75149: PPUSH
75150: LD_INT 21
75152: PUSH
75153: LD_INT 3
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 24
75162: PUSH
75163: LD_INT 250
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: PPUSH
75174: CALL_OW 72
75178: ST_TO_ADDR
// case class of 1 , 15 :
75179: LD_VAR 0 4
75183: PUSH
75184: LD_INT 1
75186: DOUBLE
75187: EQUAL
75188: IFTRUE 75198
75190: LD_INT 15
75192: DOUBLE
75193: EQUAL
75194: IFTRUE 75198
75196: GO 75283
75198: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75199: LD_ADDR_VAR 0 8
75203: PUSH
75204: LD_VAR 0 2
75208: PPUSH
75209: LD_INT 2
75211: PUSH
75212: LD_INT 30
75214: PUSH
75215: LD_INT 32
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 30
75224: PUSH
75225: LD_INT 31
75227: PUSH
75228: EMPTY
75229: LIST
75230: LIST
75231: PUSH
75232: EMPTY
75233: LIST
75234: LIST
75235: LIST
75236: PPUSH
75237: CALL_OW 72
75241: PUSH
75242: LD_VAR 0 2
75246: PPUSH
75247: LD_INT 2
75249: PUSH
75250: LD_INT 30
75252: PUSH
75253: LD_INT 4
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 30
75262: PUSH
75263: LD_INT 5
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: LIST
75274: PPUSH
75275: CALL_OW 72
75279: ADD
75280: ST_TO_ADDR
75281: GO 75529
75283: LD_INT 2
75285: DOUBLE
75286: EQUAL
75287: IFTRUE 75297
75289: LD_INT 16
75291: DOUBLE
75292: EQUAL
75293: IFTRUE 75297
75295: GO 75343
75297: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
75298: LD_ADDR_VAR 0 8
75302: PUSH
75303: LD_VAR 0 2
75307: PPUSH
75308: LD_INT 2
75310: PUSH
75311: LD_INT 30
75313: PUSH
75314: LD_INT 0
75316: PUSH
75317: EMPTY
75318: LIST
75319: LIST
75320: PUSH
75321: LD_INT 30
75323: PUSH
75324: LD_INT 1
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: LIST
75335: PPUSH
75336: CALL_OW 72
75340: ST_TO_ADDR
75341: GO 75529
75343: LD_INT 3
75345: DOUBLE
75346: EQUAL
75347: IFTRUE 75351
75349: GO 75397
75351: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
75352: LD_ADDR_VAR 0 8
75356: PUSH
75357: LD_VAR 0 2
75361: PPUSH
75362: LD_INT 2
75364: PUSH
75365: LD_INT 30
75367: PUSH
75368: LD_INT 2
75370: PUSH
75371: EMPTY
75372: LIST
75373: LIST
75374: PUSH
75375: LD_INT 30
75377: PUSH
75378: LD_INT 3
75380: PUSH
75381: EMPTY
75382: LIST
75383: LIST
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: LIST
75389: PPUSH
75390: CALL_OW 72
75394: ST_TO_ADDR
75395: GO 75529
75397: LD_INT 4
75399: DOUBLE
75400: EQUAL
75401: IFTRUE 75405
75403: GO 75462
75405: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
75406: LD_ADDR_VAR 0 8
75410: PUSH
75411: LD_VAR 0 2
75415: PPUSH
75416: LD_INT 2
75418: PUSH
75419: LD_INT 30
75421: PUSH
75422: LD_INT 6
75424: PUSH
75425: EMPTY
75426: LIST
75427: LIST
75428: PUSH
75429: LD_INT 30
75431: PUSH
75432: LD_INT 7
75434: PUSH
75435: EMPTY
75436: LIST
75437: LIST
75438: PUSH
75439: LD_INT 30
75441: PUSH
75442: LD_INT 8
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: PPUSH
75455: CALL_OW 72
75459: ST_TO_ADDR
75460: GO 75529
75462: LD_INT 5
75464: DOUBLE
75465: EQUAL
75466: IFTRUE 75482
75468: LD_INT 8
75470: DOUBLE
75471: EQUAL
75472: IFTRUE 75482
75474: LD_INT 9
75476: DOUBLE
75477: EQUAL
75478: IFTRUE 75482
75480: GO 75528
75482: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
75483: LD_ADDR_VAR 0 8
75487: PUSH
75488: LD_VAR 0 2
75492: PPUSH
75493: LD_INT 2
75495: PUSH
75496: LD_INT 30
75498: PUSH
75499: LD_INT 4
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 30
75508: PUSH
75509: LD_INT 5
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: LIST
75520: PPUSH
75521: CALL_OW 72
75525: ST_TO_ADDR
75526: GO 75529
75528: POP
// if not tmp then
75529: LD_VAR 0 8
75533: NOT
75534: IFFALSE 75538
// exit ;
75536: GO 76040
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
75538: LD_VAR 0 4
75542: PUSH
75543: LD_INT 1
75545: PUSH
75546: LD_INT 15
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: IN
75553: PUSH
75554: LD_EXP 32
75558: PUSH
75559: LD_VAR 0 1
75563: ARRAY
75564: AND
75565: IFFALSE 75721
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
75567: LD_ADDR_VAR 0 9
75571: PUSH
75572: LD_EXP 32
75576: PUSH
75577: LD_VAR 0 1
75581: ARRAY
75582: PUSH
75583: LD_INT 1
75585: ARRAY
75586: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
75587: LD_VAR 0 9
75591: PUSH
75592: LD_EXP 33
75596: PUSH
75597: LD_VAR 0 1
75601: ARRAY
75602: IN
75603: NOT
75604: IFFALSE 75719
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
75606: LD_ADDR_EXP 33
75610: PUSH
75611: LD_EXP 33
75615: PPUSH
75616: LD_VAR 0 1
75620: PUSH
75621: LD_EXP 33
75625: PUSH
75626: LD_VAR 0 1
75630: ARRAY
75631: PUSH
75632: LD_INT 1
75634: PLUS
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PPUSH
75640: LD_VAR 0 9
75644: PPUSH
75645: CALL 16110 0 3
75649: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
75650: LD_ADDR_EXP 32
75654: PUSH
75655: LD_EXP 32
75659: PPUSH
75660: LD_VAR 0 1
75664: PPUSH
75665: LD_EXP 32
75669: PUSH
75670: LD_VAR 0 1
75674: ARRAY
75675: PUSH
75676: LD_VAR 0 9
75680: DIFF
75681: PPUSH
75682: CALL_OW 1
75686: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
75687: LD_VAR 0 3
75691: PPUSH
75692: LD_EXP 33
75696: PUSH
75697: LD_VAR 0 1
75701: ARRAY
75702: PUSH
75703: LD_EXP 33
75707: PUSH
75708: LD_VAR 0 1
75712: ARRAY
75713: ARRAY
75714: PPUSH
75715: CALL_OW 120
// end ; exit ;
75719: GO 76040
// end ; if tmp > 1 then
75721: LD_VAR 0 8
75725: PUSH
75726: LD_INT 1
75728: GREATER
75729: IFFALSE 75833
// for i = 2 to tmp do
75731: LD_ADDR_VAR 0 6
75735: PUSH
75736: DOUBLE
75737: LD_INT 2
75739: DEC
75740: ST_TO_ADDR
75741: LD_VAR 0 8
75745: PUSH
75746: FOR_TO
75747: IFFALSE 75831
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
75749: LD_VAR 0 8
75753: PUSH
75754: LD_VAR 0 6
75758: ARRAY
75759: PPUSH
75760: CALL_OW 461
75764: PUSH
75765: LD_INT 6
75767: EQUAL
75768: IFFALSE 75829
// begin x := tmp [ i ] ;
75770: LD_ADDR_VAR 0 9
75774: PUSH
75775: LD_VAR 0 8
75779: PUSH
75780: LD_VAR 0 6
75784: ARRAY
75785: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75786: LD_ADDR_VAR 0 8
75790: PUSH
75791: LD_VAR 0 8
75795: PPUSH
75796: LD_VAR 0 6
75800: PPUSH
75801: CALL_OW 3
75805: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75806: LD_ADDR_VAR 0 8
75810: PUSH
75811: LD_VAR 0 8
75815: PPUSH
75816: LD_INT 1
75818: PPUSH
75819: LD_VAR 0 9
75823: PPUSH
75824: CALL_OW 2
75828: ST_TO_ADDR
// end ;
75829: GO 75746
75831: POP
75832: POP
// for i in tmp do
75833: LD_ADDR_VAR 0 6
75837: PUSH
75838: LD_VAR 0 8
75842: PUSH
75843: FOR_IN
75844: IFFALSE 75913
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75846: LD_VAR 0 6
75850: PPUSH
75851: CALL_OW 313
75855: PUSH
75856: LD_INT 6
75858: LESS
75859: PUSH
75860: LD_VAR 0 6
75864: PPUSH
75865: CALL_OW 266
75869: PUSH
75870: LD_INT 31
75872: PUSH
75873: LD_INT 32
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: IN
75880: NOT
75881: AND
75882: PUSH
75883: LD_VAR 0 6
75887: PPUSH
75888: CALL_OW 313
75892: PUSH
75893: LD_INT 0
75895: EQUAL
75896: OR
75897: IFFALSE 75911
// begin j := i ;
75899: LD_ADDR_VAR 0 7
75903: PUSH
75904: LD_VAR 0 6
75908: ST_TO_ADDR
// break ;
75909: GO 75913
// end ; end ;
75911: GO 75843
75913: POP
75914: POP
// if j then
75915: LD_VAR 0 7
75919: IFFALSE 75937
// ComEnterUnit ( unit , j ) else
75921: LD_VAR 0 3
75925: PPUSH
75926: LD_VAR 0 7
75930: PPUSH
75931: CALL_OW 120
75935: GO 76040
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75937: LD_ADDR_VAR 0 10
75941: PUSH
75942: LD_VAR 0 2
75946: PPUSH
75947: LD_INT 2
75949: PUSH
75950: LD_INT 30
75952: PUSH
75953: LD_INT 0
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 30
75962: PUSH
75963: LD_INT 1
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: EMPTY
75971: LIST
75972: LIST
75973: LIST
75974: PPUSH
75975: CALL_OW 72
75979: ST_TO_ADDR
// if depot then
75980: LD_VAR 0 10
75984: IFFALSE 76040
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75986: LD_ADDR_VAR 0 10
75990: PUSH
75991: LD_VAR 0 10
75995: PPUSH
75996: LD_VAR 0 3
76000: PPUSH
76001: CALL_OW 74
76005: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76006: LD_VAR 0 3
76010: PPUSH
76011: LD_VAR 0 10
76015: PPUSH
76016: CALL_OW 296
76020: PUSH
76021: LD_INT 10
76023: GREATER
76024: IFFALSE 76040
// ComStandNearbyBuilding ( unit , depot ) ;
76026: LD_VAR 0 3
76030: PPUSH
76031: LD_VAR 0 10
76035: PPUSH
76036: CALL 12537 0 2
// end ; end ; end ;
76040: LD_VAR 0 5
76044: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76045: LD_INT 0
76047: PPUSH
76048: PPUSH
76049: PPUSH
76050: PPUSH
// if not mc_bases then
76051: LD_EXP 23
76055: NOT
76056: IFFALSE 76060
// exit ;
76058: GO 76299
// for i = 1 to mc_bases do
76060: LD_ADDR_VAR 0 2
76064: PUSH
76065: DOUBLE
76066: LD_INT 1
76068: DEC
76069: ST_TO_ADDR
76070: LD_EXP 23
76074: PUSH
76075: FOR_TO
76076: IFFALSE 76297
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76078: LD_ADDR_VAR 0 4
76082: PUSH
76083: LD_EXP 23
76087: PUSH
76088: LD_VAR 0 2
76092: ARRAY
76093: PPUSH
76094: LD_INT 21
76096: PUSH
76097: LD_INT 1
76099: PUSH
76100: EMPTY
76101: LIST
76102: LIST
76103: PPUSH
76104: CALL_OW 72
76108: PUSH
76109: LD_EXP 52
76113: PUSH
76114: LD_VAR 0 2
76118: ARRAY
76119: UNION
76120: ST_TO_ADDR
// if not tmp then
76121: LD_VAR 0 4
76125: NOT
76126: IFFALSE 76130
// continue ;
76128: GO 76075
// for j in tmp do
76130: LD_ADDR_VAR 0 3
76134: PUSH
76135: LD_VAR 0 4
76139: PUSH
76140: FOR_IN
76141: IFFALSE 76293
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76143: LD_VAR 0 3
76147: PPUSH
76148: CALL_OW 110
76152: NOT
76153: PUSH
76154: LD_VAR 0 3
76158: PPUSH
76159: CALL_OW 314
76163: NOT
76164: AND
76165: PUSH
76166: LD_VAR 0 3
76170: PPUSH
76171: CALL_OW 311
76175: NOT
76176: AND
76177: PUSH
76178: LD_VAR 0 3
76182: PPUSH
76183: CALL_OW 310
76187: NOT
76188: AND
76189: PUSH
76190: LD_VAR 0 3
76194: PUSH
76195: LD_EXP 26
76199: PUSH
76200: LD_VAR 0 2
76204: ARRAY
76205: PUSH
76206: LD_INT 1
76208: ARRAY
76209: IN
76210: NOT
76211: AND
76212: PUSH
76213: LD_VAR 0 3
76217: PUSH
76218: LD_EXP 26
76222: PUSH
76223: LD_VAR 0 2
76227: ARRAY
76228: PUSH
76229: LD_INT 2
76231: ARRAY
76232: IN
76233: NOT
76234: AND
76235: PUSH
76236: LD_VAR 0 3
76240: PUSH
76241: LD_EXP 35
76245: PUSH
76246: LD_VAR 0 2
76250: ARRAY
76251: IN
76252: NOT
76253: AND
76254: IFFALSE 76291
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76256: LD_VAR 0 2
76260: PPUSH
76261: LD_EXP 23
76265: PUSH
76266: LD_VAR 0 2
76270: ARRAY
76271: PPUSH
76272: LD_VAR 0 3
76276: PPUSH
76277: LD_VAR 0 3
76281: PPUSH
76282: CALL_OW 257
76286: PPUSH
76287: CALL 75063 0 4
// end ;
76291: GO 76140
76293: POP
76294: POP
// end ;
76295: GO 76075
76297: POP
76298: POP
// end ;
76299: LD_VAR 0 1
76303: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
76304: LD_INT 0
76306: PPUSH
76307: PPUSH
76308: PPUSH
76309: PPUSH
76310: PPUSH
76311: PPUSH
// if not mc_bases [ base ] then
76312: LD_EXP 23
76316: PUSH
76317: LD_VAR 0 1
76321: ARRAY
76322: NOT
76323: IFFALSE 76327
// exit ;
76325: GO 76509
// tmp := [ ] ;
76327: LD_ADDR_VAR 0 6
76331: PUSH
76332: EMPTY
76333: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
76334: LD_ADDR_VAR 0 7
76338: PUSH
76339: LD_VAR 0 3
76343: PPUSH
76344: LD_INT 0
76346: PPUSH
76347: CALL_OW 517
76351: ST_TO_ADDR
// if not list then
76352: LD_VAR 0 7
76356: NOT
76357: IFFALSE 76361
// exit ;
76359: GO 76509
// for i = 1 to amount do
76361: LD_ADDR_VAR 0 5
76365: PUSH
76366: DOUBLE
76367: LD_INT 1
76369: DEC
76370: ST_TO_ADDR
76371: LD_VAR 0 2
76375: PUSH
76376: FOR_TO
76377: IFFALSE 76457
// begin x := rand ( 1 , list [ 1 ] ) ;
76379: LD_ADDR_VAR 0 8
76383: PUSH
76384: LD_INT 1
76386: PPUSH
76387: LD_VAR 0 7
76391: PUSH
76392: LD_INT 1
76394: ARRAY
76395: PPUSH
76396: CALL_OW 12
76400: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
76401: LD_ADDR_VAR 0 6
76405: PUSH
76406: LD_VAR 0 6
76410: PPUSH
76411: LD_VAR 0 5
76415: PPUSH
76416: LD_VAR 0 7
76420: PUSH
76421: LD_INT 1
76423: ARRAY
76424: PUSH
76425: LD_VAR 0 8
76429: ARRAY
76430: PUSH
76431: LD_VAR 0 7
76435: PUSH
76436: LD_INT 2
76438: ARRAY
76439: PUSH
76440: LD_VAR 0 8
76444: ARRAY
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: PPUSH
76450: CALL_OW 1
76454: ST_TO_ADDR
// end ;
76455: GO 76376
76457: POP
76458: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
76459: LD_ADDR_EXP 36
76463: PUSH
76464: LD_EXP 36
76468: PPUSH
76469: LD_VAR 0 1
76473: PPUSH
76474: LD_VAR 0 6
76478: PPUSH
76479: CALL_OW 1
76483: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
76484: LD_ADDR_EXP 38
76488: PUSH
76489: LD_EXP 38
76493: PPUSH
76494: LD_VAR 0 1
76498: PPUSH
76499: LD_VAR 0 3
76503: PPUSH
76504: CALL_OW 1
76508: ST_TO_ADDR
// end ;
76509: LD_VAR 0 4
76513: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
76514: LD_INT 0
76516: PPUSH
// if not mc_bases [ base ] then
76517: LD_EXP 23
76521: PUSH
76522: LD_VAR 0 1
76526: ARRAY
76527: NOT
76528: IFFALSE 76532
// exit ;
76530: GO 76557
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
76532: LD_ADDR_EXP 28
76536: PUSH
76537: LD_EXP 28
76541: PPUSH
76542: LD_VAR 0 1
76546: PPUSH
76547: LD_VAR 0 2
76551: PPUSH
76552: CALL_OW 1
76556: ST_TO_ADDR
// end ;
76557: LD_VAR 0 3
76561: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
76562: LD_INT 0
76564: PPUSH
// if not mc_bases [ base ] then
76565: LD_EXP 23
76569: PUSH
76570: LD_VAR 0 1
76574: ARRAY
76575: NOT
76576: IFFALSE 76580
// exit ;
76578: GO 76617
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
76580: LD_ADDR_EXP 28
76584: PUSH
76585: LD_EXP 28
76589: PPUSH
76590: LD_VAR 0 1
76594: PPUSH
76595: LD_EXP 28
76599: PUSH
76600: LD_VAR 0 1
76604: ARRAY
76605: PUSH
76606: LD_VAR 0 2
76610: UNION
76611: PPUSH
76612: CALL_OW 1
76616: ST_TO_ADDR
// end ;
76617: LD_VAR 0 3
76621: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
76622: LD_INT 0
76624: PPUSH
// if not mc_bases [ base ] then
76625: LD_EXP 23
76629: PUSH
76630: LD_VAR 0 1
76634: ARRAY
76635: NOT
76636: IFFALSE 76640
// exit ;
76638: GO 76665
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
76640: LD_ADDR_EXP 44
76644: PUSH
76645: LD_EXP 44
76649: PPUSH
76650: LD_VAR 0 1
76654: PPUSH
76655: LD_VAR 0 2
76659: PPUSH
76660: CALL_OW 1
76664: ST_TO_ADDR
// end ;
76665: LD_VAR 0 3
76669: RET
// export function MC_InsertProduceList ( base , components ) ; begin
76670: LD_INT 0
76672: PPUSH
// if not mc_bases [ base ] then
76673: LD_EXP 23
76677: PUSH
76678: LD_VAR 0 1
76682: ARRAY
76683: NOT
76684: IFFALSE 76688
// exit ;
76686: GO 76725
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
76688: LD_ADDR_EXP 44
76692: PUSH
76693: LD_EXP 44
76697: PPUSH
76698: LD_VAR 0 1
76702: PPUSH
76703: LD_EXP 44
76707: PUSH
76708: LD_VAR 0 1
76712: ARRAY
76713: PUSH
76714: LD_VAR 0 2
76718: ADD
76719: PPUSH
76720: CALL_OW 1
76724: ST_TO_ADDR
// end ;
76725: LD_VAR 0 3
76729: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
76730: LD_INT 0
76732: PPUSH
// if not mc_bases [ base ] then
76733: LD_EXP 23
76737: PUSH
76738: LD_VAR 0 1
76742: ARRAY
76743: NOT
76744: IFFALSE 76748
// exit ;
76746: GO 76802
// mc_defender := Replace ( mc_defender , base , deflist ) ;
76748: LD_ADDR_EXP 45
76752: PUSH
76753: LD_EXP 45
76757: PPUSH
76758: LD_VAR 0 1
76762: PPUSH
76763: LD_VAR 0 2
76767: PPUSH
76768: CALL_OW 1
76772: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76773: LD_ADDR_EXP 34
76777: PUSH
76778: LD_EXP 34
76782: PPUSH
76783: LD_VAR 0 1
76787: PPUSH
76788: LD_VAR 0 2
76792: PUSH
76793: LD_INT 0
76795: PLUS
76796: PPUSH
76797: CALL_OW 1
76801: ST_TO_ADDR
// end ;
76802: LD_VAR 0 3
76806: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76807: LD_INT 0
76809: PPUSH
// if not mc_bases [ base ] then
76810: LD_EXP 23
76814: PUSH
76815: LD_VAR 0 1
76819: ARRAY
76820: NOT
76821: IFFALSE 76825
// exit ;
76823: GO 76850
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76825: LD_ADDR_EXP 34
76829: PUSH
76830: LD_EXP 34
76834: PPUSH
76835: LD_VAR 0 1
76839: PPUSH
76840: LD_VAR 0 2
76844: PPUSH
76845: CALL_OW 1
76849: ST_TO_ADDR
// end ;
76850: LD_VAR 0 3
76854: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76855: LD_INT 0
76857: PPUSH
76858: PPUSH
76859: PPUSH
76860: PPUSH
// if not mc_bases [ base ] then
76861: LD_EXP 23
76865: PUSH
76866: LD_VAR 0 1
76870: ARRAY
76871: NOT
76872: IFFALSE 76876
// exit ;
76874: GO 76941
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76876: LD_ADDR_EXP 43
76880: PUSH
76881: LD_EXP 43
76885: PPUSH
76886: LD_VAR 0 1
76890: PUSH
76891: LD_EXP 43
76895: PUSH
76896: LD_VAR 0 1
76900: ARRAY
76901: PUSH
76902: LD_INT 1
76904: PLUS
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PPUSH
76910: LD_VAR 0 1
76914: PUSH
76915: LD_VAR 0 2
76919: PUSH
76920: LD_VAR 0 3
76924: PUSH
76925: LD_VAR 0 4
76929: PUSH
76930: EMPTY
76931: LIST
76932: LIST
76933: LIST
76934: LIST
76935: PPUSH
76936: CALL 16110 0 3
76940: ST_TO_ADDR
// end ;
76941: LD_VAR 0 5
76945: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76946: LD_INT 0
76948: PPUSH
// if not mc_bases [ base ] then
76949: LD_EXP 23
76953: PUSH
76954: LD_VAR 0 1
76958: ARRAY
76959: NOT
76960: IFFALSE 76964
// exit ;
76962: GO 76989
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76964: LD_ADDR_EXP 60
76968: PUSH
76969: LD_EXP 60
76973: PPUSH
76974: LD_VAR 0 1
76978: PPUSH
76979: LD_VAR 0 2
76983: PPUSH
76984: CALL_OW 1
76988: ST_TO_ADDR
// end ;
76989: LD_VAR 0 3
76993: RET
// export function MC_GetMinesField ( base ) ; begin
76994: LD_INT 0
76996: PPUSH
// result := mc_mines [ base ] ;
76997: LD_ADDR_VAR 0 2
77001: PUSH
77002: LD_EXP 36
77006: PUSH
77007: LD_VAR 0 1
77011: ARRAY
77012: ST_TO_ADDR
// end ;
77013: LD_VAR 0 2
77017: RET
// export function MC_GetProduceList ( base ) ; begin
77018: LD_INT 0
77020: PPUSH
// result := mc_produce [ base ] ;
77021: LD_ADDR_VAR 0 2
77025: PUSH
77026: LD_EXP 44
77030: PUSH
77031: LD_VAR 0 1
77035: ARRAY
77036: ST_TO_ADDR
// end ;
77037: LD_VAR 0 2
77041: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77042: LD_INT 0
77044: PPUSH
77045: PPUSH
// if not mc_bases then
77046: LD_EXP 23
77050: NOT
77051: IFFALSE 77055
// exit ;
77053: GO 77120
// if mc_bases [ base ] then
77055: LD_EXP 23
77059: PUSH
77060: LD_VAR 0 1
77064: ARRAY
77065: IFFALSE 77120
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77067: LD_ADDR_VAR 0 3
77071: PUSH
77072: LD_EXP 23
77076: PUSH
77077: LD_VAR 0 1
77081: ARRAY
77082: PPUSH
77083: LD_INT 30
77085: PUSH
77086: LD_VAR 0 2
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PPUSH
77095: CALL_OW 72
77099: ST_TO_ADDR
// if result then
77100: LD_VAR 0 3
77104: IFFALSE 77120
// result := result [ 1 ] ;
77106: LD_ADDR_VAR 0 3
77110: PUSH
77111: LD_VAR 0 3
77115: PUSH
77116: LD_INT 1
77118: ARRAY
77119: ST_TO_ADDR
// end ; end ;
77120: LD_VAR 0 3
77124: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
77125: LD_INT 0
77127: PPUSH
77128: PPUSH
// if not mc_bases then
77129: LD_EXP 23
77133: NOT
77134: IFFALSE 77138
// exit ;
77136: GO 77183
// if mc_bases [ base ] then
77138: LD_EXP 23
77142: PUSH
77143: LD_VAR 0 1
77147: ARRAY
77148: IFFALSE 77183
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77150: LD_ADDR_VAR 0 3
77154: PUSH
77155: LD_EXP 23
77159: PUSH
77160: LD_VAR 0 1
77164: ARRAY
77165: PPUSH
77166: LD_INT 30
77168: PUSH
77169: LD_VAR 0 2
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PPUSH
77178: CALL_OW 72
77182: ST_TO_ADDR
// end ;
77183: LD_VAR 0 3
77187: RET
// export function MC_SetTame ( base , area ) ; begin
77188: LD_INT 0
77190: PPUSH
// if not mc_bases or not base then
77191: LD_EXP 23
77195: NOT
77196: PUSH
77197: LD_VAR 0 1
77201: NOT
77202: OR
77203: IFFALSE 77207
// exit ;
77205: GO 77232
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77207: LD_ADDR_EXP 51
77211: PUSH
77212: LD_EXP 51
77216: PPUSH
77217: LD_VAR 0 1
77221: PPUSH
77222: LD_VAR 0 2
77226: PPUSH
77227: CALL_OW 1
77231: ST_TO_ADDR
// end ;
77232: LD_VAR 0 3
77236: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77237: LD_INT 0
77239: PPUSH
77240: PPUSH
// if not mc_bases or not base then
77241: LD_EXP 23
77245: NOT
77246: PUSH
77247: LD_VAR 0 1
77251: NOT
77252: OR
77253: IFFALSE 77257
// exit ;
77255: GO 77359
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77257: LD_ADDR_VAR 0 4
77261: PUSH
77262: LD_EXP 23
77266: PUSH
77267: LD_VAR 0 1
77271: ARRAY
77272: PPUSH
77273: LD_INT 30
77275: PUSH
77276: LD_VAR 0 2
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PPUSH
77285: CALL_OW 72
77289: ST_TO_ADDR
// if not tmp then
77290: LD_VAR 0 4
77294: NOT
77295: IFFALSE 77299
// exit ;
77297: GO 77359
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
77299: LD_ADDR_EXP 55
77303: PUSH
77304: LD_EXP 55
77308: PPUSH
77309: LD_VAR 0 1
77313: PPUSH
77314: LD_EXP 55
77318: PUSH
77319: LD_VAR 0 1
77323: ARRAY
77324: PPUSH
77325: LD_EXP 55
77329: PUSH
77330: LD_VAR 0 1
77334: ARRAY
77335: PUSH
77336: LD_INT 1
77338: PLUS
77339: PPUSH
77340: LD_VAR 0 4
77344: PUSH
77345: LD_INT 1
77347: ARRAY
77348: PPUSH
77349: CALL_OW 2
77353: PPUSH
77354: CALL_OW 1
77358: ST_TO_ADDR
// end ;
77359: LD_VAR 0 3
77363: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
77364: LD_INT 0
77366: PPUSH
77367: PPUSH
// if not mc_bases or not base or not kinds then
77368: LD_EXP 23
77372: NOT
77373: PUSH
77374: LD_VAR 0 1
77378: NOT
77379: OR
77380: PUSH
77381: LD_VAR 0 2
77385: NOT
77386: OR
77387: IFFALSE 77391
// exit ;
77389: GO 77452
// for i in kinds do
77391: LD_ADDR_VAR 0 4
77395: PUSH
77396: LD_VAR 0 2
77400: PUSH
77401: FOR_IN
77402: IFFALSE 77450
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
77404: LD_ADDR_EXP 57
77408: PUSH
77409: LD_EXP 57
77413: PPUSH
77414: LD_VAR 0 1
77418: PUSH
77419: LD_EXP 57
77423: PUSH
77424: LD_VAR 0 1
77428: ARRAY
77429: PUSH
77430: LD_INT 1
77432: PLUS
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PPUSH
77438: LD_VAR 0 4
77442: PPUSH
77443: CALL 16110 0 3
77447: ST_TO_ADDR
77448: GO 77401
77450: POP
77451: POP
// end ;
77452: LD_VAR 0 3
77456: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
77457: LD_INT 0
77459: PPUSH
// if not mc_bases or not base or not areas then
77460: LD_EXP 23
77464: NOT
77465: PUSH
77466: LD_VAR 0 1
77470: NOT
77471: OR
77472: PUSH
77473: LD_VAR 0 2
77477: NOT
77478: OR
77479: IFFALSE 77483
// exit ;
77481: GO 77508
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
77483: LD_ADDR_EXP 41
77487: PUSH
77488: LD_EXP 41
77492: PPUSH
77493: LD_VAR 0 1
77497: PPUSH
77498: LD_VAR 0 2
77502: PPUSH
77503: CALL_OW 1
77507: ST_TO_ADDR
// end ;
77508: LD_VAR 0 3
77512: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
77513: LD_INT 0
77515: PPUSH
// if not mc_bases or not base or not teleports_exit then
77516: LD_EXP 23
77520: NOT
77521: PUSH
77522: LD_VAR 0 1
77526: NOT
77527: OR
77528: PUSH
77529: LD_VAR 0 2
77533: NOT
77534: OR
77535: IFFALSE 77539
// exit ;
77537: GO 77564
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
77539: LD_ADDR_EXP 58
77543: PUSH
77544: LD_EXP 58
77548: PPUSH
77549: LD_VAR 0 1
77553: PPUSH
77554: LD_VAR 0 2
77558: PPUSH
77559: CALL_OW 1
77563: ST_TO_ADDR
// end ;
77564: LD_VAR 0 3
77568: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
77569: LD_INT 0
77571: PPUSH
77572: PPUSH
77573: PPUSH
// if not mc_bases or not base or not ext_list then
77574: LD_EXP 23
77578: NOT
77579: PUSH
77580: LD_VAR 0 1
77584: NOT
77585: OR
77586: PUSH
77587: LD_VAR 0 5
77591: NOT
77592: OR
77593: IFFALSE 77597
// exit ;
77595: GO 77770
// tmp := GetFacExtXYD ( x , y , d ) ;
77597: LD_ADDR_VAR 0 8
77601: PUSH
77602: LD_VAR 0 2
77606: PPUSH
77607: LD_VAR 0 3
77611: PPUSH
77612: LD_VAR 0 4
77616: PPUSH
77617: CALL 46087 0 3
77621: ST_TO_ADDR
// if not tmp then
77622: LD_VAR 0 8
77626: NOT
77627: IFFALSE 77631
// exit ;
77629: GO 77770
// for i in tmp do
77631: LD_ADDR_VAR 0 7
77635: PUSH
77636: LD_VAR 0 8
77640: PUSH
77641: FOR_IN
77642: IFFALSE 77768
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
77644: LD_ADDR_EXP 28
77648: PUSH
77649: LD_EXP 28
77653: PPUSH
77654: LD_VAR 0 1
77658: PPUSH
77659: LD_EXP 28
77663: PUSH
77664: LD_VAR 0 1
77668: ARRAY
77669: PPUSH
77670: LD_EXP 28
77674: PUSH
77675: LD_VAR 0 1
77679: ARRAY
77680: PUSH
77681: LD_INT 1
77683: PLUS
77684: PPUSH
77685: LD_VAR 0 5
77689: PUSH
77690: LD_INT 1
77692: ARRAY
77693: PUSH
77694: LD_VAR 0 7
77698: PUSH
77699: LD_INT 1
77701: ARRAY
77702: PUSH
77703: LD_VAR 0 7
77707: PUSH
77708: LD_INT 2
77710: ARRAY
77711: PUSH
77712: LD_VAR 0 7
77716: PUSH
77717: LD_INT 3
77719: ARRAY
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: PPUSH
77727: CALL_OW 2
77731: PPUSH
77732: CALL_OW 1
77736: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
77737: LD_ADDR_VAR 0 5
77741: PUSH
77742: LD_VAR 0 5
77746: PPUSH
77747: LD_INT 1
77749: PPUSH
77750: CALL_OW 3
77754: ST_TO_ADDR
// if not ext_list then
77755: LD_VAR 0 5
77759: NOT
77760: IFFALSE 77766
// exit ;
77762: POP
77763: POP
77764: GO 77770
// end ;
77766: GO 77641
77768: POP
77769: POP
// end ;
77770: LD_VAR 0 6
77774: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77775: LD_INT 0
77777: PPUSH
// if not mc_bases or not base or not weapon_list then
77778: LD_EXP 23
77782: NOT
77783: PUSH
77784: LD_VAR 0 1
77788: NOT
77789: OR
77790: PUSH
77791: LD_VAR 0 2
77795: NOT
77796: OR
77797: IFFALSE 77801
// exit ;
77799: GO 77826
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77801: LD_ADDR_EXP 62
77805: PUSH
77806: LD_EXP 62
77810: PPUSH
77811: LD_VAR 0 1
77815: PPUSH
77816: LD_VAR 0 2
77820: PPUSH
77821: CALL_OW 1
77825: ST_TO_ADDR
// end ;
77826: LD_VAR 0 3
77830: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77831: LD_INT 0
77833: PPUSH
// if not mc_bases or not base or not tech_list then
77834: LD_EXP 23
77838: NOT
77839: PUSH
77840: LD_VAR 0 1
77844: NOT
77845: OR
77846: PUSH
77847: LD_VAR 0 2
77851: NOT
77852: OR
77853: IFFALSE 77857
// exit ;
77855: GO 77882
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77857: LD_ADDR_EXP 50
77861: PUSH
77862: LD_EXP 50
77866: PPUSH
77867: LD_VAR 0 1
77871: PPUSH
77872: LD_VAR 0 2
77876: PPUSH
77877: CALL_OW 1
77881: ST_TO_ADDR
// end ;
77882: LD_VAR 0 3
77886: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77887: LD_INT 0
77889: PPUSH
// if not mc_bases or not parking_area or not base then
77890: LD_EXP 23
77894: NOT
77895: PUSH
77896: LD_VAR 0 2
77900: NOT
77901: OR
77902: PUSH
77903: LD_VAR 0 1
77907: NOT
77908: OR
77909: IFFALSE 77913
// exit ;
77911: GO 77938
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77913: LD_ADDR_EXP 47
77917: PUSH
77918: LD_EXP 47
77922: PPUSH
77923: LD_VAR 0 1
77927: PPUSH
77928: LD_VAR 0 2
77932: PPUSH
77933: CALL_OW 1
77937: ST_TO_ADDR
// end ;
77938: LD_VAR 0 3
77942: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77943: LD_INT 0
77945: PPUSH
// if not mc_bases or not base or not scan_area then
77946: LD_EXP 23
77950: NOT
77951: PUSH
77952: LD_VAR 0 1
77956: NOT
77957: OR
77958: PUSH
77959: LD_VAR 0 2
77963: NOT
77964: OR
77965: IFFALSE 77969
// exit ;
77967: GO 77994
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77969: LD_ADDR_EXP 48
77973: PUSH
77974: LD_EXP 48
77978: PPUSH
77979: LD_VAR 0 1
77983: PPUSH
77984: LD_VAR 0 2
77988: PPUSH
77989: CALL_OW 1
77993: ST_TO_ADDR
// end ;
77994: LD_VAR 0 3
77998: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77999: LD_INT 0
78001: PPUSH
78002: PPUSH
// if not mc_bases or not base then
78003: LD_EXP 23
78007: NOT
78008: PUSH
78009: LD_VAR 0 1
78013: NOT
78014: OR
78015: IFFALSE 78019
// exit ;
78017: GO 78083
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78019: LD_ADDR_VAR 0 3
78023: PUSH
78024: LD_INT 1
78026: PUSH
78027: LD_INT 2
78029: PUSH
78030: LD_INT 3
78032: PUSH
78033: LD_INT 4
78035: PUSH
78036: LD_INT 11
78038: PUSH
78039: EMPTY
78040: LIST
78041: LIST
78042: LIST
78043: LIST
78044: LIST
78045: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78046: LD_ADDR_EXP 50
78050: PUSH
78051: LD_EXP 50
78055: PPUSH
78056: LD_VAR 0 1
78060: PPUSH
78061: LD_EXP 50
78065: PUSH
78066: LD_VAR 0 1
78070: ARRAY
78071: PUSH
78072: LD_VAR 0 3
78076: DIFF
78077: PPUSH
78078: CALL_OW 1
78082: ST_TO_ADDR
// end ;
78083: LD_VAR 0 2
78087: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
78088: LD_INT 0
78090: PPUSH
// result := mc_vehicles [ base ] ;
78091: LD_ADDR_VAR 0 3
78095: PUSH
78096: LD_EXP 42
78100: PUSH
78101: LD_VAR 0 1
78105: ARRAY
78106: ST_TO_ADDR
// if onlyCombat then
78107: LD_VAR 0 2
78111: IFFALSE 78283
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
78113: LD_ADDR_VAR 0 3
78117: PUSH
78118: LD_VAR 0 3
78122: PUSH
78123: LD_VAR 0 3
78127: PPUSH
78128: LD_INT 2
78130: PUSH
78131: LD_INT 34
78133: PUSH
78134: LD_INT 12
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: LD_INT 34
78143: PUSH
78144: LD_INT 51
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 34
78153: PUSH
78154: LD_INT 89
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 34
78163: PUSH
78164: LD_INT 32
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 34
78173: PUSH
78174: LD_INT 13
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PUSH
78181: LD_INT 34
78183: PUSH
78184: LD_INT 52
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PUSH
78191: LD_INT 34
78193: PUSH
78194: LD_INT 88
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 34
78203: PUSH
78204: LD_INT 14
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 34
78213: PUSH
78214: LD_INT 53
78216: PUSH
78217: EMPTY
78218: LIST
78219: LIST
78220: PUSH
78221: LD_INT 34
78223: PUSH
78224: LD_INT 98
78226: PUSH
78227: EMPTY
78228: LIST
78229: LIST
78230: PUSH
78231: LD_INT 34
78233: PUSH
78234: LD_INT 31
78236: PUSH
78237: EMPTY
78238: LIST
78239: LIST
78240: PUSH
78241: LD_INT 34
78243: PUSH
78244: LD_INT 48
78246: PUSH
78247: EMPTY
78248: LIST
78249: LIST
78250: PUSH
78251: LD_INT 34
78253: PUSH
78254: LD_INT 8
78256: PUSH
78257: EMPTY
78258: LIST
78259: LIST
78260: PUSH
78261: EMPTY
78262: LIST
78263: LIST
78264: LIST
78265: LIST
78266: LIST
78267: LIST
78268: LIST
78269: LIST
78270: LIST
78271: LIST
78272: LIST
78273: LIST
78274: LIST
78275: LIST
78276: PPUSH
78277: CALL_OW 72
78281: DIFF
78282: ST_TO_ADDR
// end ; end_of_file
78283: LD_VAR 0 3
78287: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78288: LD_INT 0
78290: PPUSH
78291: PPUSH
78292: PPUSH
// if not mc_bases or not skirmish then
78293: LD_EXP 23
78297: NOT
78298: PUSH
78299: LD_EXP 21
78303: NOT
78304: OR
78305: IFFALSE 78309
// exit ;
78307: GO 78474
// for i = 1 to mc_bases do
78309: LD_ADDR_VAR 0 4
78313: PUSH
78314: DOUBLE
78315: LD_INT 1
78317: DEC
78318: ST_TO_ADDR
78319: LD_EXP 23
78323: PUSH
78324: FOR_TO
78325: IFFALSE 78472
// begin if sci in mc_bases [ i ] then
78327: LD_VAR 0 2
78331: PUSH
78332: LD_EXP 23
78336: PUSH
78337: LD_VAR 0 4
78341: ARRAY
78342: IN
78343: IFFALSE 78470
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78345: LD_ADDR_EXP 52
78349: PUSH
78350: LD_EXP 52
78354: PPUSH
78355: LD_VAR 0 4
78359: PUSH
78360: LD_EXP 52
78364: PUSH
78365: LD_VAR 0 4
78369: ARRAY
78370: PUSH
78371: LD_INT 1
78373: PLUS
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PPUSH
78379: LD_VAR 0 1
78383: PPUSH
78384: CALL 16110 0 3
78388: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78389: LD_ADDR_VAR 0 5
78393: PUSH
78394: LD_EXP 23
78398: PUSH
78399: LD_VAR 0 4
78403: ARRAY
78404: PPUSH
78405: LD_INT 2
78407: PUSH
78408: LD_INT 30
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 30
78420: PUSH
78421: LD_INT 1
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: LIST
78432: PPUSH
78433: CALL_OW 72
78437: PPUSH
78438: LD_VAR 0 1
78442: PPUSH
78443: CALL_OW 74
78447: ST_TO_ADDR
// if tmp then
78448: LD_VAR 0 5
78452: IFFALSE 78468
// ComStandNearbyBuilding ( ape , tmp ) ;
78454: LD_VAR 0 1
78458: PPUSH
78459: LD_VAR 0 5
78463: PPUSH
78464: CALL 12537 0 2
// break ;
78468: GO 78472
// end ; end ;
78470: GO 78324
78472: POP
78473: POP
// end ;
78474: LD_VAR 0 3
78478: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78479: LD_INT 0
78481: PPUSH
78482: PPUSH
78483: PPUSH
// if not mc_bases or not skirmish then
78484: LD_EXP 23
78488: NOT
78489: PUSH
78490: LD_EXP 21
78494: NOT
78495: OR
78496: IFFALSE 78500
// exit ;
78498: GO 78589
// for i = 1 to mc_bases do
78500: LD_ADDR_VAR 0 4
78504: PUSH
78505: DOUBLE
78506: LD_INT 1
78508: DEC
78509: ST_TO_ADDR
78510: LD_EXP 23
78514: PUSH
78515: FOR_TO
78516: IFFALSE 78587
// begin if building in mc_busy_turret_list [ i ] then
78518: LD_VAR 0 1
78522: PUSH
78523: LD_EXP 33
78527: PUSH
78528: LD_VAR 0 4
78532: ARRAY
78533: IN
78534: IFFALSE 78585
// begin tmp := mc_busy_turret_list [ i ] diff building ;
78536: LD_ADDR_VAR 0 5
78540: PUSH
78541: LD_EXP 33
78545: PUSH
78546: LD_VAR 0 4
78550: ARRAY
78551: PUSH
78552: LD_VAR 0 1
78556: DIFF
78557: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
78558: LD_ADDR_EXP 33
78562: PUSH
78563: LD_EXP 33
78567: PPUSH
78568: LD_VAR 0 4
78572: PPUSH
78573: LD_VAR 0 5
78577: PPUSH
78578: CALL_OW 1
78582: ST_TO_ADDR
// break ;
78583: GO 78587
// end ; end ;
78585: GO 78515
78587: POP
78588: POP
// end ;
78589: LD_VAR 0 3
78593: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
78594: LD_INT 0
78596: PPUSH
78597: PPUSH
78598: PPUSH
// if not mc_bases or not skirmish then
78599: LD_EXP 23
78603: NOT
78604: PUSH
78605: LD_EXP 21
78609: NOT
78610: OR
78611: IFFALSE 78615
// exit ;
78613: GO 78814
// for i = 1 to mc_bases do
78615: LD_ADDR_VAR 0 5
78619: PUSH
78620: DOUBLE
78621: LD_INT 1
78623: DEC
78624: ST_TO_ADDR
78625: LD_EXP 23
78629: PUSH
78630: FOR_TO
78631: IFFALSE 78812
// if building in mc_bases [ i ] then
78633: LD_VAR 0 1
78637: PUSH
78638: LD_EXP 23
78642: PUSH
78643: LD_VAR 0 5
78647: ARRAY
78648: IN
78649: IFFALSE 78810
// begin tmp := mc_bases [ i ] diff building ;
78651: LD_ADDR_VAR 0 6
78655: PUSH
78656: LD_EXP 23
78660: PUSH
78661: LD_VAR 0 5
78665: ARRAY
78666: PUSH
78667: LD_VAR 0 1
78671: DIFF
78672: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
78673: LD_ADDR_EXP 23
78677: PUSH
78678: LD_EXP 23
78682: PPUSH
78683: LD_VAR 0 5
78687: PPUSH
78688: LD_VAR 0 6
78692: PPUSH
78693: CALL_OW 1
78697: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
78698: LD_VAR 0 1
78702: PUSH
78703: LD_EXP 31
78707: PUSH
78708: LD_VAR 0 5
78712: ARRAY
78713: IN
78714: IFFALSE 78753
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
78716: LD_ADDR_EXP 31
78720: PUSH
78721: LD_EXP 31
78725: PPUSH
78726: LD_VAR 0 5
78730: PPUSH
78731: LD_EXP 31
78735: PUSH
78736: LD_VAR 0 5
78740: ARRAY
78741: PUSH
78742: LD_VAR 0 1
78746: DIFF
78747: PPUSH
78748: CALL_OW 1
78752: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78753: LD_VAR 0 1
78757: PUSH
78758: LD_EXP 32
78762: PUSH
78763: LD_VAR 0 5
78767: ARRAY
78768: IN
78769: IFFALSE 78808
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78771: LD_ADDR_EXP 32
78775: PUSH
78776: LD_EXP 32
78780: PPUSH
78781: LD_VAR 0 5
78785: PPUSH
78786: LD_EXP 32
78790: PUSH
78791: LD_VAR 0 5
78795: ARRAY
78796: PUSH
78797: LD_VAR 0 1
78801: DIFF
78802: PPUSH
78803: CALL_OW 1
78807: ST_TO_ADDR
// break ;
78808: GO 78812
// end ;
78810: GO 78630
78812: POP
78813: POP
// end ;
78814: LD_VAR 0 4
78818: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78819: LD_INT 0
78821: PPUSH
78822: PPUSH
78823: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78824: LD_EXP 23
78828: NOT
78829: PUSH
78830: LD_EXP 21
78834: NOT
78835: OR
78836: PUSH
78837: LD_VAR 0 3
78841: PUSH
78842: LD_EXP 49
78846: IN
78847: NOT
78848: OR
78849: IFFALSE 78853
// exit ;
78851: GO 78976
// for i = 1 to mc_vehicles do
78853: LD_ADDR_VAR 0 6
78857: PUSH
78858: DOUBLE
78859: LD_INT 1
78861: DEC
78862: ST_TO_ADDR
78863: LD_EXP 42
78867: PUSH
78868: FOR_TO
78869: IFFALSE 78974
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78871: LD_VAR 0 2
78875: PUSH
78876: LD_EXP 42
78880: PUSH
78881: LD_VAR 0 6
78885: ARRAY
78886: IN
78887: PUSH
78888: LD_VAR 0 1
78892: PUSH
78893: LD_EXP 42
78897: PUSH
78898: LD_VAR 0 6
78902: ARRAY
78903: IN
78904: OR
78905: IFFALSE 78972
// begin tmp := mc_vehicles [ i ] diff old ;
78907: LD_ADDR_VAR 0 7
78911: PUSH
78912: LD_EXP 42
78916: PUSH
78917: LD_VAR 0 6
78921: ARRAY
78922: PUSH
78923: LD_VAR 0 2
78927: DIFF
78928: ST_TO_ADDR
// tmp := tmp diff new ;
78929: LD_ADDR_VAR 0 7
78933: PUSH
78934: LD_VAR 0 7
78938: PUSH
78939: LD_VAR 0 1
78943: DIFF
78944: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78945: LD_ADDR_EXP 42
78949: PUSH
78950: LD_EXP 42
78954: PPUSH
78955: LD_VAR 0 6
78959: PPUSH
78960: LD_VAR 0 7
78964: PPUSH
78965: CALL_OW 1
78969: ST_TO_ADDR
// break ;
78970: GO 78974
// end ;
78972: GO 78868
78974: POP
78975: POP
// end ;
78976: LD_VAR 0 5
78980: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78981: LD_INT 0
78983: PPUSH
78984: PPUSH
78985: PPUSH
78986: PPUSH
// if not mc_bases or not skirmish then
78987: LD_EXP 23
78991: NOT
78992: PUSH
78993: LD_EXP 21
78997: NOT
78998: OR
78999: IFFALSE 79003
// exit ;
79001: GO 79385
// side := GetSide ( vehicle ) ;
79003: LD_ADDR_VAR 0 5
79007: PUSH
79008: LD_VAR 0 1
79012: PPUSH
79013: CALL_OW 255
79017: ST_TO_ADDR
// for i = 1 to mc_bases do
79018: LD_ADDR_VAR 0 4
79022: PUSH
79023: DOUBLE
79024: LD_INT 1
79026: DEC
79027: ST_TO_ADDR
79028: LD_EXP 23
79032: PUSH
79033: FOR_TO
79034: IFFALSE 79383
// begin if factory in mc_bases [ i ] then
79036: LD_VAR 0 2
79040: PUSH
79041: LD_EXP 23
79045: PUSH
79046: LD_VAR 0 4
79050: ARRAY
79051: IN
79052: IFFALSE 79381
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
79054: LD_EXP 45
79058: PUSH
79059: LD_VAR 0 4
79063: ARRAY
79064: PUSH
79065: LD_EXP 34
79069: PUSH
79070: LD_VAR 0 4
79074: ARRAY
79075: LESS
79076: PUSH
79077: LD_VAR 0 1
79081: PPUSH
79082: CALL_OW 264
79086: PUSH
79087: LD_INT 31
79089: PUSH
79090: LD_INT 32
79092: PUSH
79093: LD_INT 51
79095: PUSH
79096: LD_INT 89
79098: PUSH
79099: LD_INT 12
79101: PUSH
79102: LD_INT 30
79104: PUSH
79105: LD_INT 98
79107: PUSH
79108: LD_INT 11
79110: PUSH
79111: LD_INT 53
79113: PUSH
79114: LD_INT 14
79116: PUSH
79117: LD_INT 91
79119: PUSH
79120: LD_INT 29
79122: PUSH
79123: LD_INT 99
79125: PUSH
79126: LD_INT 13
79128: PUSH
79129: LD_INT 52
79131: PUSH
79132: LD_INT 88
79134: PUSH
79135: LD_INT 48
79137: PUSH
79138: LD_INT 8
79140: PUSH
79141: EMPTY
79142: LIST
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: LIST
79151: LIST
79152: LIST
79153: LIST
79154: LIST
79155: LIST
79156: LIST
79157: LIST
79158: LIST
79159: LIST
79160: IN
79161: NOT
79162: AND
79163: IFFALSE 79211
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
79165: LD_ADDR_EXP 45
79169: PUSH
79170: LD_EXP 45
79174: PPUSH
79175: LD_VAR 0 4
79179: PUSH
79180: LD_EXP 45
79184: PUSH
79185: LD_VAR 0 4
79189: ARRAY
79190: PUSH
79191: LD_INT 1
79193: PLUS
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PPUSH
79199: LD_VAR 0 1
79203: PPUSH
79204: CALL 16110 0 3
79208: ST_TO_ADDR
79209: GO 79255
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79211: LD_ADDR_EXP 42
79215: PUSH
79216: LD_EXP 42
79220: PPUSH
79221: LD_VAR 0 4
79225: PUSH
79226: LD_EXP 42
79230: PUSH
79231: LD_VAR 0 4
79235: ARRAY
79236: PUSH
79237: LD_INT 1
79239: PLUS
79240: PUSH
79241: EMPTY
79242: LIST
79243: LIST
79244: PPUSH
79245: LD_VAR 0 1
79249: PPUSH
79250: CALL 16110 0 3
79254: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
79255: LD_VAR 0 1
79259: PPUSH
79260: CALL_OW 263
79264: PUSH
79265: LD_INT 2
79267: EQUAL
79268: IFFALSE 79297
// begin repeat wait ( 0 0$3 ) ;
79270: LD_INT 105
79272: PPUSH
79273: CALL_OW 67
// Connect ( vehicle ) ;
79277: LD_VAR 0 1
79281: PPUSH
79282: CALL 19079 0 1
// until IsControledBy ( vehicle ) ;
79286: LD_VAR 0 1
79290: PPUSH
79291: CALL_OW 312
79295: IFFALSE 79270
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79297: LD_VAR 0 1
79301: PPUSH
79302: LD_EXP 47
79306: PUSH
79307: LD_VAR 0 4
79311: ARRAY
79312: PPUSH
79313: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79317: LD_VAR 0 1
79321: PPUSH
79322: CALL_OW 263
79326: PUSH
79327: LD_INT 1
79329: NONEQUAL
79330: IFFALSE 79334
// break ;
79332: GO 79383
// repeat wait ( 0 0$1 ) ;
79334: LD_INT 35
79336: PPUSH
79337: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79341: LD_VAR 0 1
79345: PPUSH
79346: LD_EXP 47
79350: PUSH
79351: LD_VAR 0 4
79355: ARRAY
79356: PPUSH
79357: CALL_OW 308
79361: IFFALSE 79334
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79363: LD_VAR 0 1
79367: PPUSH
79368: CALL_OW 311
79372: PPUSH
79373: CALL_OW 121
// exit ;
79377: POP
79378: POP
79379: GO 79385
// end ; end ;
79381: GO 79033
79383: POP
79384: POP
// end ;
79385: LD_VAR 0 3
79389: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79390: LD_INT 0
79392: PPUSH
79393: PPUSH
79394: PPUSH
79395: PPUSH
// if not mc_bases or not skirmish then
79396: LD_EXP 23
79400: NOT
79401: PUSH
79402: LD_EXP 21
79406: NOT
79407: OR
79408: IFFALSE 79412
// exit ;
79410: GO 79765
// repeat wait ( 0 0$1 ) ;
79412: LD_INT 35
79414: PPUSH
79415: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79419: LD_VAR 0 2
79423: PPUSH
79424: LD_VAR 0 3
79428: PPUSH
79429: CALL_OW 284
79433: IFFALSE 79412
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79435: LD_VAR 0 2
79439: PPUSH
79440: LD_VAR 0 3
79444: PPUSH
79445: CALL_OW 283
79449: PUSH
79450: LD_INT 4
79452: EQUAL
79453: IFFALSE 79457
// exit ;
79455: GO 79765
// for i = 1 to mc_bases do
79457: LD_ADDR_VAR 0 7
79461: PUSH
79462: DOUBLE
79463: LD_INT 1
79465: DEC
79466: ST_TO_ADDR
79467: LD_EXP 23
79471: PUSH
79472: FOR_TO
79473: IFFALSE 79763
// begin if mc_crates_area [ i ] then
79475: LD_EXP 41
79479: PUSH
79480: LD_VAR 0 7
79484: ARRAY
79485: IFFALSE 79596
// for j in mc_crates_area [ i ] do
79487: LD_ADDR_VAR 0 8
79491: PUSH
79492: LD_EXP 41
79496: PUSH
79497: LD_VAR 0 7
79501: ARRAY
79502: PUSH
79503: FOR_IN
79504: IFFALSE 79594
// if InArea ( x , y , j ) then
79506: LD_VAR 0 2
79510: PPUSH
79511: LD_VAR 0 3
79515: PPUSH
79516: LD_VAR 0 8
79520: PPUSH
79521: CALL_OW 309
79525: IFFALSE 79592
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79527: LD_ADDR_EXP 39
79531: PUSH
79532: LD_EXP 39
79536: PPUSH
79537: LD_VAR 0 7
79541: PUSH
79542: LD_EXP 39
79546: PUSH
79547: LD_VAR 0 7
79551: ARRAY
79552: PUSH
79553: LD_INT 1
79555: PLUS
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PPUSH
79561: LD_VAR 0 4
79565: PUSH
79566: LD_VAR 0 2
79570: PUSH
79571: LD_VAR 0 3
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: LIST
79580: PPUSH
79581: CALL 16110 0 3
79585: ST_TO_ADDR
// exit ;
79586: POP
79587: POP
79588: POP
79589: POP
79590: GO 79765
// end ;
79592: GO 79503
79594: POP
79595: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79596: LD_ADDR_VAR 0 9
79600: PUSH
79601: LD_EXP 23
79605: PUSH
79606: LD_VAR 0 7
79610: ARRAY
79611: PPUSH
79612: LD_INT 2
79614: PUSH
79615: LD_INT 30
79617: PUSH
79618: LD_INT 0
79620: PUSH
79621: EMPTY
79622: LIST
79623: LIST
79624: PUSH
79625: LD_INT 30
79627: PUSH
79628: LD_INT 1
79630: PUSH
79631: EMPTY
79632: LIST
79633: LIST
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: LIST
79639: PPUSH
79640: CALL_OW 72
79644: ST_TO_ADDR
// if not depot then
79645: LD_VAR 0 9
79649: NOT
79650: IFFALSE 79654
// continue ;
79652: GO 79472
// for j in depot do
79654: LD_ADDR_VAR 0 8
79658: PUSH
79659: LD_VAR 0 9
79663: PUSH
79664: FOR_IN
79665: IFFALSE 79759
// if GetDistUnitXY ( j , x , y ) < 30 then
79667: LD_VAR 0 8
79671: PPUSH
79672: LD_VAR 0 2
79676: PPUSH
79677: LD_VAR 0 3
79681: PPUSH
79682: CALL_OW 297
79686: PUSH
79687: LD_INT 30
79689: LESS
79690: IFFALSE 79757
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
79692: LD_ADDR_EXP 39
79696: PUSH
79697: LD_EXP 39
79701: PPUSH
79702: LD_VAR 0 7
79706: PUSH
79707: LD_EXP 39
79711: PUSH
79712: LD_VAR 0 7
79716: ARRAY
79717: PUSH
79718: LD_INT 1
79720: PLUS
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PPUSH
79726: LD_VAR 0 4
79730: PUSH
79731: LD_VAR 0 2
79735: PUSH
79736: LD_VAR 0 3
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: LIST
79745: PPUSH
79746: CALL 16110 0 3
79750: ST_TO_ADDR
// exit ;
79751: POP
79752: POP
79753: POP
79754: POP
79755: GO 79765
// end ;
79757: GO 79664
79759: POP
79760: POP
// end ;
79761: GO 79472
79763: POP
79764: POP
// end ;
79765: LD_VAR 0 6
79769: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79770: LD_INT 0
79772: PPUSH
79773: PPUSH
79774: PPUSH
79775: PPUSH
// if not mc_bases or not skirmish then
79776: LD_EXP 23
79780: NOT
79781: PUSH
79782: LD_EXP 21
79786: NOT
79787: OR
79788: IFFALSE 79792
// exit ;
79790: GO 80069
// side := GetSide ( lab ) ;
79792: LD_ADDR_VAR 0 4
79796: PUSH
79797: LD_VAR 0 2
79801: PPUSH
79802: CALL_OW 255
79806: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79807: LD_VAR 0 4
79811: PUSH
79812: LD_EXP 49
79816: IN
79817: NOT
79818: PUSH
79819: LD_EXP 50
79823: NOT
79824: OR
79825: PUSH
79826: LD_EXP 23
79830: NOT
79831: OR
79832: IFFALSE 79836
// exit ;
79834: GO 80069
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79836: LD_ADDR_EXP 50
79840: PUSH
79841: LD_EXP 50
79845: PPUSH
79846: LD_VAR 0 4
79850: PPUSH
79851: LD_EXP 50
79855: PUSH
79856: LD_VAR 0 4
79860: ARRAY
79861: PUSH
79862: LD_VAR 0 1
79866: DIFF
79867: PPUSH
79868: CALL_OW 1
79872: ST_TO_ADDR
// for i = 1 to mc_bases do
79873: LD_ADDR_VAR 0 5
79877: PUSH
79878: DOUBLE
79879: LD_INT 1
79881: DEC
79882: ST_TO_ADDR
79883: LD_EXP 23
79887: PUSH
79888: FOR_TO
79889: IFFALSE 80067
// begin if lab in mc_bases [ i ] then
79891: LD_VAR 0 2
79895: PUSH
79896: LD_EXP 23
79900: PUSH
79901: LD_VAR 0 5
79905: ARRAY
79906: IN
79907: IFFALSE 80065
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79909: LD_VAR 0 1
79913: PUSH
79914: LD_INT 11
79916: PUSH
79917: LD_INT 4
79919: PUSH
79920: LD_INT 3
79922: PUSH
79923: LD_INT 2
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: IN
79932: PUSH
79933: LD_EXP 53
79937: PUSH
79938: LD_VAR 0 5
79942: ARRAY
79943: AND
79944: IFFALSE 80065
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79946: LD_ADDR_VAR 0 6
79950: PUSH
79951: LD_EXP 53
79955: PUSH
79956: LD_VAR 0 5
79960: ARRAY
79961: PUSH
79962: LD_INT 1
79964: ARRAY
79965: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79966: LD_ADDR_EXP 53
79970: PUSH
79971: LD_EXP 53
79975: PPUSH
79976: LD_VAR 0 5
79980: PPUSH
79981: EMPTY
79982: PPUSH
79983: CALL_OW 1
79987: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79988: LD_VAR 0 6
79992: PPUSH
79993: LD_INT 0
79995: PPUSH
79996: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80000: LD_VAR 0 6
80004: PPUSH
80005: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80009: LD_ADDR_EXP 52
80013: PUSH
80014: LD_EXP 52
80018: PPUSH
80019: LD_VAR 0 5
80023: PPUSH
80024: LD_EXP 52
80028: PUSH
80029: LD_VAR 0 5
80033: ARRAY
80034: PPUSH
80035: LD_INT 1
80037: PPUSH
80038: LD_VAR 0 6
80042: PPUSH
80043: CALL_OW 2
80047: PPUSH
80048: CALL_OW 1
80052: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80053: LD_VAR 0 5
80057: PPUSH
80058: LD_INT 112
80060: PPUSH
80061: CALL 56555 0 2
// end ; end ; end ;
80065: GO 79888
80067: POP
80068: POP
// end ;
80069: LD_VAR 0 3
80073: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80074: LD_INT 0
80076: PPUSH
80077: PPUSH
80078: PPUSH
80079: PPUSH
80080: PPUSH
80081: PPUSH
80082: PPUSH
80083: PPUSH
// if not mc_bases or not skirmish then
80084: LD_EXP 23
80088: NOT
80089: PUSH
80090: LD_EXP 21
80094: NOT
80095: OR
80096: IFFALSE 80100
// exit ;
80098: GO 81469
// for i = 1 to mc_bases do
80100: LD_ADDR_VAR 0 3
80104: PUSH
80105: DOUBLE
80106: LD_INT 1
80108: DEC
80109: ST_TO_ADDR
80110: LD_EXP 23
80114: PUSH
80115: FOR_TO
80116: IFFALSE 81467
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80118: LD_VAR 0 1
80122: PUSH
80123: LD_EXP 23
80127: PUSH
80128: LD_VAR 0 3
80132: ARRAY
80133: IN
80134: PUSH
80135: LD_VAR 0 1
80139: PUSH
80140: LD_EXP 30
80144: PUSH
80145: LD_VAR 0 3
80149: ARRAY
80150: IN
80151: OR
80152: PUSH
80153: LD_VAR 0 1
80157: PUSH
80158: LD_EXP 45
80162: PUSH
80163: LD_VAR 0 3
80167: ARRAY
80168: IN
80169: OR
80170: PUSH
80171: LD_VAR 0 1
80175: PUSH
80176: LD_EXP 42
80180: PUSH
80181: LD_VAR 0 3
80185: ARRAY
80186: IN
80187: OR
80188: PUSH
80189: LD_VAR 0 1
80193: PUSH
80194: LD_EXP 52
80198: PUSH
80199: LD_VAR 0 3
80203: ARRAY
80204: IN
80205: OR
80206: PUSH
80207: LD_VAR 0 1
80211: PUSH
80212: LD_EXP 53
80216: PUSH
80217: LD_VAR 0 3
80221: ARRAY
80222: IN
80223: OR
80224: IFFALSE 81465
// begin if un in mc_ape [ i ] then
80226: LD_VAR 0 1
80230: PUSH
80231: LD_EXP 52
80235: PUSH
80236: LD_VAR 0 3
80240: ARRAY
80241: IN
80242: IFFALSE 80281
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80244: LD_ADDR_EXP 52
80248: PUSH
80249: LD_EXP 52
80253: PPUSH
80254: LD_VAR 0 3
80258: PPUSH
80259: LD_EXP 52
80263: PUSH
80264: LD_VAR 0 3
80268: ARRAY
80269: PUSH
80270: LD_VAR 0 1
80274: DIFF
80275: PPUSH
80276: CALL_OW 1
80280: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80281: LD_VAR 0 1
80285: PUSH
80286: LD_EXP 53
80290: PUSH
80291: LD_VAR 0 3
80295: ARRAY
80296: IN
80297: IFFALSE 80321
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80299: LD_ADDR_EXP 53
80303: PUSH
80304: LD_EXP 53
80308: PPUSH
80309: LD_VAR 0 3
80313: PPUSH
80314: EMPTY
80315: PPUSH
80316: CALL_OW 1
80320: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
80321: LD_VAR 0 1
80325: PPUSH
80326: CALL_OW 247
80330: PUSH
80331: LD_INT 2
80333: EQUAL
80334: PUSH
80335: LD_VAR 0 1
80339: PPUSH
80340: CALL_OW 110
80344: PUSH
80345: LD_INT 20
80347: EQUAL
80348: PUSH
80349: LD_VAR 0 1
80353: PUSH
80354: LD_EXP 45
80358: PUSH
80359: LD_VAR 0 3
80363: ARRAY
80364: IN
80365: OR
80366: PUSH
80367: LD_VAR 0 1
80371: PPUSH
80372: CALL_OW 264
80376: PUSH
80377: LD_INT 12
80379: PUSH
80380: LD_INT 51
80382: PUSH
80383: LD_INT 89
80385: PUSH
80386: LD_INT 32
80388: PUSH
80389: LD_INT 13
80391: PUSH
80392: LD_INT 52
80394: PUSH
80395: LD_INT 31
80397: PUSH
80398: EMPTY
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: IN
80407: OR
80408: AND
80409: IFFALSE 80717
// begin if un in mc_defender [ i ] then
80411: LD_VAR 0 1
80415: PUSH
80416: LD_EXP 45
80420: PUSH
80421: LD_VAR 0 3
80425: ARRAY
80426: IN
80427: IFFALSE 80466
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80429: LD_ADDR_EXP 45
80433: PUSH
80434: LD_EXP 45
80438: PPUSH
80439: LD_VAR 0 3
80443: PPUSH
80444: LD_EXP 45
80448: PUSH
80449: LD_VAR 0 3
80453: ARRAY
80454: PUSH
80455: LD_VAR 0 1
80459: DIFF
80460: PPUSH
80461: CALL_OW 1
80465: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
80466: LD_ADDR_VAR 0 8
80470: PUSH
80471: LD_VAR 0 3
80475: PPUSH
80476: LD_INT 3
80478: PPUSH
80479: CALL 77125 0 2
80483: ST_TO_ADDR
// if fac then
80484: LD_VAR 0 8
80488: IFFALSE 80717
// begin for j in fac do
80490: LD_ADDR_VAR 0 4
80494: PUSH
80495: LD_VAR 0 8
80499: PUSH
80500: FOR_IN
80501: IFFALSE 80715
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80503: LD_ADDR_VAR 0 9
80507: PUSH
80508: LD_VAR 0 8
80512: PPUSH
80513: LD_VAR 0 1
80517: PPUSH
80518: CALL_OW 265
80522: PPUSH
80523: LD_VAR 0 1
80527: PPUSH
80528: CALL_OW 262
80532: PPUSH
80533: LD_VAR 0 1
80537: PPUSH
80538: CALL_OW 263
80542: PPUSH
80543: LD_VAR 0 1
80547: PPUSH
80548: CALL_OW 264
80552: PPUSH
80553: CALL 13608 0 5
80557: ST_TO_ADDR
// if components then
80558: LD_VAR 0 9
80562: IFFALSE 80713
// begin if GetWeapon ( un ) = ar_control_tower then
80564: LD_VAR 0 1
80568: PPUSH
80569: CALL_OW 264
80573: PUSH
80574: LD_INT 31
80576: EQUAL
80577: IFFALSE 80694
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
80579: LD_VAR 0 1
80583: PPUSH
80584: CALL_OW 311
80588: PPUSH
80589: LD_INT 0
80591: PPUSH
80592: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
80596: LD_ADDR_EXP 63
80600: PUSH
80601: LD_EXP 63
80605: PPUSH
80606: LD_VAR 0 3
80610: PPUSH
80611: LD_EXP 63
80615: PUSH
80616: LD_VAR 0 3
80620: ARRAY
80621: PUSH
80622: LD_VAR 0 1
80626: PPUSH
80627: CALL_OW 311
80631: DIFF
80632: PPUSH
80633: CALL_OW 1
80637: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
80638: LD_ADDR_VAR 0 7
80642: PUSH
80643: LD_EXP 44
80647: PUSH
80648: LD_VAR 0 3
80652: ARRAY
80653: PPUSH
80654: LD_INT 1
80656: PPUSH
80657: LD_VAR 0 9
80661: PPUSH
80662: CALL_OW 2
80666: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
80667: LD_ADDR_EXP 44
80671: PUSH
80672: LD_EXP 44
80676: PPUSH
80677: LD_VAR 0 3
80681: PPUSH
80682: LD_VAR 0 7
80686: PPUSH
80687: CALL_OW 1
80691: ST_TO_ADDR
// end else
80692: GO 80711
// MC_InsertProduceList ( i , [ components ] ) ;
80694: LD_VAR 0 3
80698: PPUSH
80699: LD_VAR 0 9
80703: PUSH
80704: EMPTY
80705: LIST
80706: PPUSH
80707: CALL 76670 0 2
// break ;
80711: GO 80715
// end ; end ;
80713: GO 80500
80715: POP
80716: POP
// end ; end ; if GetType ( un ) = unit_building then
80717: LD_VAR 0 1
80721: PPUSH
80722: CALL_OW 247
80726: PUSH
80727: LD_INT 3
80729: EQUAL
80730: IFFALSE 81133
// begin btype := GetBType ( un ) ;
80732: LD_ADDR_VAR 0 5
80736: PUSH
80737: LD_VAR 0 1
80741: PPUSH
80742: CALL_OW 266
80746: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
80747: LD_VAR 0 5
80751: PUSH
80752: LD_INT 29
80754: PUSH
80755: LD_INT 30
80757: PUSH
80758: EMPTY
80759: LIST
80760: LIST
80761: IN
80762: IFFALSE 80835
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80764: LD_VAR 0 1
80768: PPUSH
80769: CALL_OW 250
80773: PPUSH
80774: LD_VAR 0 1
80778: PPUSH
80779: CALL_OW 251
80783: PPUSH
80784: LD_VAR 0 1
80788: PPUSH
80789: CALL_OW 255
80793: PPUSH
80794: CALL_OW 440
80798: NOT
80799: IFFALSE 80835
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80801: LD_VAR 0 1
80805: PPUSH
80806: CALL_OW 250
80810: PPUSH
80811: LD_VAR 0 1
80815: PPUSH
80816: CALL_OW 251
80820: PPUSH
80821: LD_VAR 0 1
80825: PPUSH
80826: CALL_OW 255
80830: PPUSH
80831: CALL_OW 441
// end ; if btype = b_warehouse then
80835: LD_VAR 0 5
80839: PUSH
80840: LD_INT 1
80842: EQUAL
80843: IFFALSE 80861
// begin btype := b_depot ;
80845: LD_ADDR_VAR 0 5
80849: PUSH
80850: LD_INT 0
80852: ST_TO_ADDR
// pos := 1 ;
80853: LD_ADDR_VAR 0 6
80857: PUSH
80858: LD_INT 1
80860: ST_TO_ADDR
// end ; if btype = b_factory then
80861: LD_VAR 0 5
80865: PUSH
80866: LD_INT 3
80868: EQUAL
80869: IFFALSE 80887
// begin btype := b_workshop ;
80871: LD_ADDR_VAR 0 5
80875: PUSH
80876: LD_INT 2
80878: ST_TO_ADDR
// pos := 1 ;
80879: LD_ADDR_VAR 0 6
80883: PUSH
80884: LD_INT 1
80886: ST_TO_ADDR
// end ; if btype = b_barracks then
80887: LD_VAR 0 5
80891: PUSH
80892: LD_INT 5
80894: EQUAL
80895: IFFALSE 80905
// btype := b_armoury ;
80897: LD_ADDR_VAR 0 5
80901: PUSH
80902: LD_INT 4
80904: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80905: LD_VAR 0 5
80909: PUSH
80910: LD_INT 7
80912: PUSH
80913: LD_INT 8
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: IN
80920: IFFALSE 80930
// btype := b_lab ;
80922: LD_ADDR_VAR 0 5
80926: PUSH
80927: LD_INT 6
80929: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80930: LD_ADDR_EXP 28
80934: PUSH
80935: LD_EXP 28
80939: PPUSH
80940: LD_VAR 0 3
80944: PUSH
80945: LD_EXP 28
80949: PUSH
80950: LD_VAR 0 3
80954: ARRAY
80955: PUSH
80956: LD_INT 1
80958: PLUS
80959: PUSH
80960: EMPTY
80961: LIST
80962: LIST
80963: PPUSH
80964: LD_VAR 0 5
80968: PUSH
80969: LD_VAR 0 1
80973: PPUSH
80974: CALL_OW 250
80978: PUSH
80979: LD_VAR 0 1
80983: PPUSH
80984: CALL_OW 251
80988: PUSH
80989: LD_VAR 0 1
80993: PPUSH
80994: CALL_OW 254
80998: PUSH
80999: EMPTY
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: PPUSH
81005: CALL 16110 0 3
81009: ST_TO_ADDR
// if pos = 1 then
81010: LD_VAR 0 6
81014: PUSH
81015: LD_INT 1
81017: EQUAL
81018: IFFALSE 81133
// begin tmp := mc_build_list [ i ] ;
81020: LD_ADDR_VAR 0 7
81024: PUSH
81025: LD_EXP 28
81029: PUSH
81030: LD_VAR 0 3
81034: ARRAY
81035: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81036: LD_VAR 0 7
81040: PPUSH
81041: LD_INT 2
81043: PUSH
81044: LD_INT 30
81046: PUSH
81047: LD_INT 0
81049: PUSH
81050: EMPTY
81051: LIST
81052: LIST
81053: PUSH
81054: LD_INT 30
81056: PUSH
81057: LD_INT 1
81059: PUSH
81060: EMPTY
81061: LIST
81062: LIST
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: LIST
81068: PPUSH
81069: CALL_OW 72
81073: IFFALSE 81083
// pos := 2 ;
81075: LD_ADDR_VAR 0 6
81079: PUSH
81080: LD_INT 2
81082: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81083: LD_ADDR_VAR 0 7
81087: PUSH
81088: LD_VAR 0 7
81092: PPUSH
81093: LD_VAR 0 6
81097: PPUSH
81098: LD_VAR 0 7
81102: PPUSH
81103: CALL 16436 0 3
81107: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81108: LD_ADDR_EXP 28
81112: PUSH
81113: LD_EXP 28
81117: PPUSH
81118: LD_VAR 0 3
81122: PPUSH
81123: LD_VAR 0 7
81127: PPUSH
81128: CALL_OW 1
81132: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81133: LD_VAR 0 1
81137: PUSH
81138: LD_EXP 23
81142: PUSH
81143: LD_VAR 0 3
81147: ARRAY
81148: IN
81149: IFFALSE 81188
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81151: LD_ADDR_EXP 23
81155: PUSH
81156: LD_EXP 23
81160: PPUSH
81161: LD_VAR 0 3
81165: PPUSH
81166: LD_EXP 23
81170: PUSH
81171: LD_VAR 0 3
81175: ARRAY
81176: PUSH
81177: LD_VAR 0 1
81181: DIFF
81182: PPUSH
81183: CALL_OW 1
81187: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81188: LD_VAR 0 1
81192: PUSH
81193: LD_EXP 30
81197: PUSH
81198: LD_VAR 0 3
81202: ARRAY
81203: IN
81204: IFFALSE 81243
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81206: LD_ADDR_EXP 30
81210: PUSH
81211: LD_EXP 30
81215: PPUSH
81216: LD_VAR 0 3
81220: PPUSH
81221: LD_EXP 30
81225: PUSH
81226: LD_VAR 0 3
81230: ARRAY
81231: PUSH
81232: LD_VAR 0 1
81236: DIFF
81237: PPUSH
81238: CALL_OW 1
81242: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81243: LD_VAR 0 1
81247: PUSH
81248: LD_EXP 42
81252: PUSH
81253: LD_VAR 0 3
81257: ARRAY
81258: IN
81259: IFFALSE 81298
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81261: LD_ADDR_EXP 42
81265: PUSH
81266: LD_EXP 42
81270: PPUSH
81271: LD_VAR 0 3
81275: PPUSH
81276: LD_EXP 42
81280: PUSH
81281: LD_VAR 0 3
81285: ARRAY
81286: PUSH
81287: LD_VAR 0 1
81291: DIFF
81292: PPUSH
81293: CALL_OW 1
81297: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
81298: LD_VAR 0 1
81302: PUSH
81303: LD_EXP 45
81307: PUSH
81308: LD_VAR 0 3
81312: ARRAY
81313: IN
81314: IFFALSE 81353
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
81316: LD_ADDR_EXP 45
81320: PUSH
81321: LD_EXP 45
81325: PPUSH
81326: LD_VAR 0 3
81330: PPUSH
81331: LD_EXP 45
81335: PUSH
81336: LD_VAR 0 3
81340: ARRAY
81341: PUSH
81342: LD_VAR 0 1
81346: DIFF
81347: PPUSH
81348: CALL_OW 1
81352: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81353: LD_VAR 0 1
81357: PUSH
81358: LD_EXP 32
81362: PUSH
81363: LD_VAR 0 3
81367: ARRAY
81368: IN
81369: IFFALSE 81408
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81371: LD_ADDR_EXP 32
81375: PUSH
81376: LD_EXP 32
81380: PPUSH
81381: LD_VAR 0 3
81385: PPUSH
81386: LD_EXP 32
81390: PUSH
81391: LD_VAR 0 3
81395: ARRAY
81396: PUSH
81397: LD_VAR 0 1
81401: DIFF
81402: PPUSH
81403: CALL_OW 1
81407: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81408: LD_VAR 0 1
81412: PUSH
81413: LD_EXP 31
81417: PUSH
81418: LD_VAR 0 3
81422: ARRAY
81423: IN
81424: IFFALSE 81463
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81426: LD_ADDR_EXP 31
81430: PUSH
81431: LD_EXP 31
81435: PPUSH
81436: LD_VAR 0 3
81440: PPUSH
81441: LD_EXP 31
81445: PUSH
81446: LD_VAR 0 3
81450: ARRAY
81451: PUSH
81452: LD_VAR 0 1
81456: DIFF
81457: PPUSH
81458: CALL_OW 1
81462: ST_TO_ADDR
// end ; break ;
81463: GO 81467
// end ;
81465: GO 80115
81467: POP
81468: POP
// end ;
81469: LD_VAR 0 2
81473: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81474: LD_INT 0
81476: PPUSH
81477: PPUSH
81478: PPUSH
// if not mc_bases or not skirmish then
81479: LD_EXP 23
81483: NOT
81484: PUSH
81485: LD_EXP 21
81489: NOT
81490: OR
81491: IFFALSE 81495
// exit ;
81493: GO 81710
// for i = 1 to mc_bases do
81495: LD_ADDR_VAR 0 3
81499: PUSH
81500: DOUBLE
81501: LD_INT 1
81503: DEC
81504: ST_TO_ADDR
81505: LD_EXP 23
81509: PUSH
81510: FOR_TO
81511: IFFALSE 81708
// begin if building in mc_construct_list [ i ] then
81513: LD_VAR 0 1
81517: PUSH
81518: LD_EXP 30
81522: PUSH
81523: LD_VAR 0 3
81527: ARRAY
81528: IN
81529: IFFALSE 81706
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81531: LD_ADDR_EXP 30
81535: PUSH
81536: LD_EXP 30
81540: PPUSH
81541: LD_VAR 0 3
81545: PPUSH
81546: LD_EXP 30
81550: PUSH
81551: LD_VAR 0 3
81555: ARRAY
81556: PUSH
81557: LD_VAR 0 1
81561: DIFF
81562: PPUSH
81563: CALL_OW 1
81567: ST_TO_ADDR
// if building in mc_lab [ i ] then
81568: LD_VAR 0 1
81572: PUSH
81573: LD_EXP 56
81577: PUSH
81578: LD_VAR 0 3
81582: ARRAY
81583: IN
81584: IFFALSE 81639
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81586: LD_ADDR_EXP 57
81590: PUSH
81591: LD_EXP 57
81595: PPUSH
81596: LD_VAR 0 3
81600: PPUSH
81601: LD_EXP 57
81605: PUSH
81606: LD_VAR 0 3
81610: ARRAY
81611: PPUSH
81612: LD_INT 1
81614: PPUSH
81615: LD_EXP 57
81619: PUSH
81620: LD_VAR 0 3
81624: ARRAY
81625: PPUSH
81626: LD_INT 0
81628: PPUSH
81629: CALL 15528 0 4
81633: PPUSH
81634: CALL_OW 1
81638: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81639: LD_VAR 0 1
81643: PUSH
81644: LD_EXP 23
81648: PUSH
81649: LD_VAR 0 3
81653: ARRAY
81654: IN
81655: NOT
81656: IFFALSE 81702
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81658: LD_ADDR_EXP 23
81662: PUSH
81663: LD_EXP 23
81667: PPUSH
81668: LD_VAR 0 3
81672: PUSH
81673: LD_EXP 23
81677: PUSH
81678: LD_VAR 0 3
81682: ARRAY
81683: PUSH
81684: LD_INT 1
81686: PLUS
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PPUSH
81692: LD_VAR 0 1
81696: PPUSH
81697: CALL 16110 0 3
81701: ST_TO_ADDR
// exit ;
81702: POP
81703: POP
81704: GO 81710
// end ; end ;
81706: GO 81510
81708: POP
81709: POP
// end ;
81710: LD_VAR 0 2
81714: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81715: LD_INT 0
81717: PPUSH
81718: PPUSH
81719: PPUSH
81720: PPUSH
81721: PPUSH
81722: PPUSH
81723: PPUSH
// if not mc_bases or not skirmish then
81724: LD_EXP 23
81728: NOT
81729: PUSH
81730: LD_EXP 21
81734: NOT
81735: OR
81736: IFFALSE 81740
// exit ;
81738: GO 82401
// for i = 1 to mc_bases do
81740: LD_ADDR_VAR 0 3
81744: PUSH
81745: DOUBLE
81746: LD_INT 1
81748: DEC
81749: ST_TO_ADDR
81750: LD_EXP 23
81754: PUSH
81755: FOR_TO
81756: IFFALSE 82399
// begin if building in mc_construct_list [ i ] then
81758: LD_VAR 0 1
81762: PUSH
81763: LD_EXP 30
81767: PUSH
81768: LD_VAR 0 3
81772: ARRAY
81773: IN
81774: IFFALSE 82397
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81776: LD_ADDR_EXP 30
81780: PUSH
81781: LD_EXP 30
81785: PPUSH
81786: LD_VAR 0 3
81790: PPUSH
81791: LD_EXP 30
81795: PUSH
81796: LD_VAR 0 3
81800: ARRAY
81801: PUSH
81802: LD_VAR 0 1
81806: DIFF
81807: PPUSH
81808: CALL_OW 1
81812: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81813: LD_ADDR_EXP 23
81817: PUSH
81818: LD_EXP 23
81822: PPUSH
81823: LD_VAR 0 3
81827: PUSH
81828: LD_EXP 23
81832: PUSH
81833: LD_VAR 0 3
81837: ARRAY
81838: PUSH
81839: LD_INT 1
81841: PLUS
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PPUSH
81847: LD_VAR 0 1
81851: PPUSH
81852: CALL 16110 0 3
81856: ST_TO_ADDR
// btype := GetBType ( building ) ;
81857: LD_ADDR_VAR 0 5
81861: PUSH
81862: LD_VAR 0 1
81866: PPUSH
81867: CALL_OW 266
81871: ST_TO_ADDR
// side := GetSide ( building ) ;
81872: LD_ADDR_VAR 0 8
81876: PUSH
81877: LD_VAR 0 1
81881: PPUSH
81882: CALL_OW 255
81886: ST_TO_ADDR
// if btype = b_lab then
81887: LD_VAR 0 5
81891: PUSH
81892: LD_INT 6
81894: EQUAL
81895: IFFALSE 81945
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81897: LD_ADDR_EXP 56
81901: PUSH
81902: LD_EXP 56
81906: PPUSH
81907: LD_VAR 0 3
81911: PUSH
81912: LD_EXP 56
81916: PUSH
81917: LD_VAR 0 3
81921: ARRAY
81922: PUSH
81923: LD_INT 1
81925: PLUS
81926: PUSH
81927: EMPTY
81928: LIST
81929: LIST
81930: PPUSH
81931: LD_VAR 0 1
81935: PPUSH
81936: CALL 16110 0 3
81940: ST_TO_ADDR
// exit ;
81941: POP
81942: POP
81943: GO 82401
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81945: LD_VAR 0 5
81949: PUSH
81950: LD_INT 0
81952: PUSH
81953: LD_INT 2
81955: PUSH
81956: LD_INT 4
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: LIST
81963: IN
81964: IFFALSE 82088
// begin if btype = b_armoury then
81966: LD_VAR 0 5
81970: PUSH
81971: LD_INT 4
81973: EQUAL
81974: IFFALSE 81984
// btype := b_barracks ;
81976: LD_ADDR_VAR 0 5
81980: PUSH
81981: LD_INT 5
81983: ST_TO_ADDR
// if btype = b_depot then
81984: LD_VAR 0 5
81988: PUSH
81989: LD_INT 0
81991: EQUAL
81992: IFFALSE 82002
// btype := b_warehouse ;
81994: LD_ADDR_VAR 0 5
81998: PUSH
81999: LD_INT 1
82001: ST_TO_ADDR
// if btype = b_workshop then
82002: LD_VAR 0 5
82006: PUSH
82007: LD_INT 2
82009: EQUAL
82010: IFFALSE 82020
// btype := b_factory ;
82012: LD_ADDR_VAR 0 5
82016: PUSH
82017: LD_INT 3
82019: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82020: LD_VAR 0 5
82024: PPUSH
82025: LD_VAR 0 8
82029: PPUSH
82030: CALL_OW 323
82034: PUSH
82035: LD_INT 1
82037: EQUAL
82038: IFFALSE 82084
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82040: LD_ADDR_EXP 55
82044: PUSH
82045: LD_EXP 55
82049: PPUSH
82050: LD_VAR 0 3
82054: PUSH
82055: LD_EXP 55
82059: PUSH
82060: LD_VAR 0 3
82064: ARRAY
82065: PUSH
82066: LD_INT 1
82068: PLUS
82069: PUSH
82070: EMPTY
82071: LIST
82072: LIST
82073: PPUSH
82074: LD_VAR 0 1
82078: PPUSH
82079: CALL 16110 0 3
82083: ST_TO_ADDR
// exit ;
82084: POP
82085: POP
82086: GO 82401
// end ; if btype in [ b_bunker , b_turret ] then
82088: LD_VAR 0 5
82092: PUSH
82093: LD_INT 32
82095: PUSH
82096: LD_INT 33
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: IN
82103: IFFALSE 82393
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82105: LD_ADDR_EXP 31
82109: PUSH
82110: LD_EXP 31
82114: PPUSH
82115: LD_VAR 0 3
82119: PUSH
82120: LD_EXP 31
82124: PUSH
82125: LD_VAR 0 3
82129: ARRAY
82130: PUSH
82131: LD_INT 1
82133: PLUS
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PPUSH
82139: LD_VAR 0 1
82143: PPUSH
82144: CALL 16110 0 3
82148: ST_TO_ADDR
// if btype = b_bunker then
82149: LD_VAR 0 5
82153: PUSH
82154: LD_INT 32
82156: EQUAL
82157: IFFALSE 82393
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82159: LD_ADDR_EXP 32
82163: PUSH
82164: LD_EXP 32
82168: PPUSH
82169: LD_VAR 0 3
82173: PUSH
82174: LD_EXP 32
82178: PUSH
82179: LD_VAR 0 3
82183: ARRAY
82184: PUSH
82185: LD_INT 1
82187: PLUS
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PPUSH
82193: LD_VAR 0 1
82197: PPUSH
82198: CALL 16110 0 3
82202: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82203: LD_ADDR_VAR 0 6
82207: PUSH
82208: LD_EXP 23
82212: PUSH
82213: LD_VAR 0 3
82217: ARRAY
82218: PPUSH
82219: LD_INT 25
82221: PUSH
82222: LD_INT 1
82224: PUSH
82225: EMPTY
82226: LIST
82227: LIST
82228: PUSH
82229: LD_INT 3
82231: PUSH
82232: LD_INT 54
82234: PUSH
82235: EMPTY
82236: LIST
82237: PUSH
82238: EMPTY
82239: LIST
82240: LIST
82241: PUSH
82242: EMPTY
82243: LIST
82244: LIST
82245: PPUSH
82246: CALL_OW 72
82250: ST_TO_ADDR
// if tmp then
82251: LD_VAR 0 6
82255: IFFALSE 82261
// exit ;
82257: POP
82258: POP
82259: GO 82401
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82261: LD_ADDR_VAR 0 6
82265: PUSH
82266: LD_EXP 23
82270: PUSH
82271: LD_VAR 0 3
82275: ARRAY
82276: PPUSH
82277: LD_INT 2
82279: PUSH
82280: LD_INT 30
82282: PUSH
82283: LD_INT 4
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 30
82292: PUSH
82293: LD_INT 5
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: LIST
82304: PPUSH
82305: CALL_OW 72
82309: ST_TO_ADDR
// if not tmp then
82310: LD_VAR 0 6
82314: NOT
82315: IFFALSE 82321
// exit ;
82317: POP
82318: POP
82319: GO 82401
// for j in tmp do
82321: LD_ADDR_VAR 0 4
82325: PUSH
82326: LD_VAR 0 6
82330: PUSH
82331: FOR_IN
82332: IFFALSE 82391
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82334: LD_ADDR_VAR 0 7
82338: PUSH
82339: LD_VAR 0 4
82343: PPUSH
82344: CALL_OW 313
82348: PPUSH
82349: LD_INT 25
82351: PUSH
82352: LD_INT 1
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PPUSH
82359: CALL_OW 72
82363: ST_TO_ADDR
// if units then
82364: LD_VAR 0 7
82368: IFFALSE 82389
// begin ComExitBuilding ( units [ 1 ] ) ;
82370: LD_VAR 0 7
82374: PUSH
82375: LD_INT 1
82377: ARRAY
82378: PPUSH
82379: CALL_OW 122
// exit ;
82383: POP
82384: POP
82385: POP
82386: POP
82387: GO 82401
// end ; end ;
82389: GO 82331
82391: POP
82392: POP
// end ; end ; exit ;
82393: POP
82394: POP
82395: GO 82401
// end ; end ;
82397: GO 81755
82399: POP
82400: POP
// end ;
82401: LD_VAR 0 2
82405: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82406: LD_INT 0
82408: PPUSH
82409: PPUSH
82410: PPUSH
82411: PPUSH
82412: PPUSH
82413: PPUSH
82414: PPUSH
// if not mc_bases or not skirmish then
82415: LD_EXP 23
82419: NOT
82420: PUSH
82421: LD_EXP 21
82425: NOT
82426: OR
82427: IFFALSE 82431
// exit ;
82429: GO 82696
// btype := GetBType ( building ) ;
82431: LD_ADDR_VAR 0 6
82435: PUSH
82436: LD_VAR 0 1
82440: PPUSH
82441: CALL_OW 266
82445: ST_TO_ADDR
// x := GetX ( building ) ;
82446: LD_ADDR_VAR 0 7
82450: PUSH
82451: LD_VAR 0 1
82455: PPUSH
82456: CALL_OW 250
82460: ST_TO_ADDR
// y := GetY ( building ) ;
82461: LD_ADDR_VAR 0 8
82465: PUSH
82466: LD_VAR 0 1
82470: PPUSH
82471: CALL_OW 251
82475: ST_TO_ADDR
// d := GetDir ( building ) ;
82476: LD_ADDR_VAR 0 9
82480: PUSH
82481: LD_VAR 0 1
82485: PPUSH
82486: CALL_OW 254
82490: ST_TO_ADDR
// for i = 1 to mc_bases do
82491: LD_ADDR_VAR 0 4
82495: PUSH
82496: DOUBLE
82497: LD_INT 1
82499: DEC
82500: ST_TO_ADDR
82501: LD_EXP 23
82505: PUSH
82506: FOR_TO
82507: IFFALSE 82694
// begin if not mc_build_list [ i ] then
82509: LD_EXP 28
82513: PUSH
82514: LD_VAR 0 4
82518: ARRAY
82519: NOT
82520: IFFALSE 82524
// continue ;
82522: GO 82506
// for j := 1 to mc_build_list [ i ] do
82524: LD_ADDR_VAR 0 5
82528: PUSH
82529: DOUBLE
82530: LD_INT 1
82532: DEC
82533: ST_TO_ADDR
82534: LD_EXP 28
82538: PUSH
82539: LD_VAR 0 4
82543: ARRAY
82544: PUSH
82545: FOR_TO
82546: IFFALSE 82690
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
82548: LD_VAR 0 6
82552: PUSH
82553: LD_VAR 0 7
82557: PUSH
82558: LD_VAR 0 8
82562: PUSH
82563: LD_VAR 0 9
82567: PUSH
82568: EMPTY
82569: LIST
82570: LIST
82571: LIST
82572: LIST
82573: PPUSH
82574: LD_EXP 28
82578: PUSH
82579: LD_VAR 0 4
82583: ARRAY
82584: PUSH
82585: LD_VAR 0 5
82589: ARRAY
82590: PPUSH
82591: CALL 22290 0 2
82595: IFFALSE 82688
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
82597: LD_ADDR_EXP 28
82601: PUSH
82602: LD_EXP 28
82606: PPUSH
82607: LD_VAR 0 4
82611: PPUSH
82612: LD_EXP 28
82616: PUSH
82617: LD_VAR 0 4
82621: ARRAY
82622: PPUSH
82623: LD_VAR 0 5
82627: PPUSH
82628: CALL_OW 3
82632: PPUSH
82633: CALL_OW 1
82637: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82638: LD_ADDR_EXP 30
82642: PUSH
82643: LD_EXP 30
82647: PPUSH
82648: LD_VAR 0 4
82652: PUSH
82653: LD_EXP 30
82657: PUSH
82658: LD_VAR 0 4
82662: ARRAY
82663: PUSH
82664: LD_INT 1
82666: PLUS
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PPUSH
82672: LD_VAR 0 1
82676: PPUSH
82677: CALL 16110 0 3
82681: ST_TO_ADDR
// exit ;
82682: POP
82683: POP
82684: POP
82685: POP
82686: GO 82696
// end ;
82688: GO 82545
82690: POP
82691: POP
// end ;
82692: GO 82506
82694: POP
82695: POP
// end ;
82696: LD_VAR 0 3
82700: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82701: LD_INT 0
82703: PPUSH
82704: PPUSH
82705: PPUSH
// if not mc_bases or not skirmish then
82706: LD_EXP 23
82710: NOT
82711: PUSH
82712: LD_EXP 21
82716: NOT
82717: OR
82718: IFFALSE 82722
// exit ;
82720: GO 82912
// for i = 1 to mc_bases do
82722: LD_ADDR_VAR 0 4
82726: PUSH
82727: DOUBLE
82728: LD_INT 1
82730: DEC
82731: ST_TO_ADDR
82732: LD_EXP 23
82736: PUSH
82737: FOR_TO
82738: IFFALSE 82825
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82740: LD_VAR 0 1
82744: PUSH
82745: LD_EXP 31
82749: PUSH
82750: LD_VAR 0 4
82754: ARRAY
82755: IN
82756: PUSH
82757: LD_VAR 0 1
82761: PUSH
82762: LD_EXP 32
82766: PUSH
82767: LD_VAR 0 4
82771: ARRAY
82772: IN
82773: NOT
82774: AND
82775: IFFALSE 82823
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82777: LD_ADDR_EXP 32
82781: PUSH
82782: LD_EXP 32
82786: PPUSH
82787: LD_VAR 0 4
82791: PUSH
82792: LD_EXP 32
82796: PUSH
82797: LD_VAR 0 4
82801: ARRAY
82802: PUSH
82803: LD_INT 1
82805: PLUS
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: PPUSH
82811: LD_VAR 0 1
82815: PPUSH
82816: CALL 16110 0 3
82820: ST_TO_ADDR
// break ;
82821: GO 82825
// end ; end ;
82823: GO 82737
82825: POP
82826: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82827: LD_VAR 0 1
82831: PPUSH
82832: CALL_OW 257
82836: PUSH
82837: LD_EXP 49
82841: IN
82842: PUSH
82843: LD_VAR 0 1
82847: PPUSH
82848: CALL_OW 266
82852: PUSH
82853: LD_INT 5
82855: EQUAL
82856: AND
82857: PUSH
82858: LD_VAR 0 2
82862: PPUSH
82863: CALL_OW 110
82867: PUSH
82868: LD_INT 18
82870: NONEQUAL
82871: AND
82872: IFFALSE 82912
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82874: LD_VAR 0 2
82878: PPUSH
82879: CALL_OW 257
82883: PUSH
82884: LD_INT 5
82886: PUSH
82887: LD_INT 8
82889: PUSH
82890: LD_INT 9
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: LIST
82897: IN
82898: IFFALSE 82912
// SetClass ( unit , 1 ) ;
82900: LD_VAR 0 2
82904: PPUSH
82905: LD_INT 1
82907: PPUSH
82908: CALL_OW 336
// end ;
82912: LD_VAR 0 3
82916: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82917: LD_INT 0
82919: PPUSH
82920: PPUSH
// if not mc_bases or not skirmish then
82921: LD_EXP 23
82925: NOT
82926: PUSH
82927: LD_EXP 21
82931: NOT
82932: OR
82933: IFFALSE 82937
// exit ;
82935: GO 83053
// if GetLives ( abandoned_vehicle ) > 250 then
82937: LD_VAR 0 2
82941: PPUSH
82942: CALL_OW 256
82946: PUSH
82947: LD_INT 250
82949: GREATER
82950: IFFALSE 82954
// exit ;
82952: GO 83053
// for i = 1 to mc_bases do
82954: LD_ADDR_VAR 0 6
82958: PUSH
82959: DOUBLE
82960: LD_INT 1
82962: DEC
82963: ST_TO_ADDR
82964: LD_EXP 23
82968: PUSH
82969: FOR_TO
82970: IFFALSE 83051
// begin if driver in mc_bases [ i ] then
82972: LD_VAR 0 1
82976: PUSH
82977: LD_EXP 23
82981: PUSH
82982: LD_VAR 0 6
82986: ARRAY
82987: IN
82988: IFFALSE 83049
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82990: LD_VAR 0 1
82994: PPUSH
82995: LD_EXP 23
82999: PUSH
83000: LD_VAR 0 6
83004: ARRAY
83005: PPUSH
83006: LD_INT 2
83008: PUSH
83009: LD_INT 30
83011: PUSH
83012: LD_INT 0
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 30
83021: PUSH
83022: LD_INT 1
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: LIST
83033: PPUSH
83034: CALL_OW 72
83038: PUSH
83039: LD_INT 1
83041: ARRAY
83042: PPUSH
83043: CALL 49318 0 2
// break ;
83047: GO 83051
// end ; end ;
83049: GO 82969
83051: POP
83052: POP
// end ; end_of_file
83053: LD_VAR 0 5
83057: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
83058: LD_INT 0
83060: PPUSH
83061: PPUSH
83062: PPUSH
83063: PPUSH
83064: PPUSH
83065: PPUSH
83066: PPUSH
83067: PPUSH
83068: PPUSH
83069: PPUSH
83070: PPUSH
83071: PPUSH
83072: PPUSH
83073: PPUSH
83074: PPUSH
83075: PPUSH
83076: PPUSH
83077: PPUSH
83078: PPUSH
83079: PPUSH
83080: PPUSH
83081: PPUSH
83082: PPUSH
83083: PPUSH
83084: PPUSH
83085: PPUSH
83086: PPUSH
83087: PPUSH
83088: PPUSH
83089: PPUSH
83090: PPUSH
83091: PPUSH
83092: PPUSH
83093: PPUSH
// if not list then
83094: LD_VAR 0 1
83098: NOT
83099: IFFALSE 83103
// exit ;
83101: GO 87762
// base := list [ 1 ] ;
83103: LD_ADDR_VAR 0 3
83107: PUSH
83108: LD_VAR 0 1
83112: PUSH
83113: LD_INT 1
83115: ARRAY
83116: ST_TO_ADDR
// group := list [ 2 ] ;
83117: LD_ADDR_VAR 0 4
83121: PUSH
83122: LD_VAR 0 1
83126: PUSH
83127: LD_INT 2
83129: ARRAY
83130: ST_TO_ADDR
// path := list [ 3 ] ;
83131: LD_ADDR_VAR 0 5
83135: PUSH
83136: LD_VAR 0 1
83140: PUSH
83141: LD_INT 3
83143: ARRAY
83144: ST_TO_ADDR
// flags := list [ 4 ] ;
83145: LD_ADDR_VAR 0 6
83149: PUSH
83150: LD_VAR 0 1
83154: PUSH
83155: LD_INT 4
83157: ARRAY
83158: ST_TO_ADDR
// mined := [ ] ;
83159: LD_ADDR_VAR 0 27
83163: PUSH
83164: EMPTY
83165: ST_TO_ADDR
// bombed := [ ] ;
83166: LD_ADDR_VAR 0 28
83170: PUSH
83171: EMPTY
83172: ST_TO_ADDR
// healers := [ ] ;
83173: LD_ADDR_VAR 0 31
83177: PUSH
83178: EMPTY
83179: ST_TO_ADDR
// to_heal := [ ] ;
83180: LD_ADDR_VAR 0 30
83184: PUSH
83185: EMPTY
83186: ST_TO_ADDR
// repairs := [ ] ;
83187: LD_ADDR_VAR 0 33
83191: PUSH
83192: EMPTY
83193: ST_TO_ADDR
// to_repair := [ ] ;
83194: LD_ADDR_VAR 0 32
83198: PUSH
83199: EMPTY
83200: ST_TO_ADDR
// if not group or not path then
83201: LD_VAR 0 4
83205: NOT
83206: PUSH
83207: LD_VAR 0 5
83211: NOT
83212: OR
83213: IFFALSE 83217
// exit ;
83215: GO 87762
// side := GetSide ( group [ 1 ] ) ;
83217: LD_ADDR_VAR 0 35
83221: PUSH
83222: LD_VAR 0 4
83226: PUSH
83227: LD_INT 1
83229: ARRAY
83230: PPUSH
83231: CALL_OW 255
83235: ST_TO_ADDR
// if flags then
83236: LD_VAR 0 6
83240: IFFALSE 83384
// begin f_ignore_area := flags [ 1 ] ;
83242: LD_ADDR_VAR 0 17
83246: PUSH
83247: LD_VAR 0 6
83251: PUSH
83252: LD_INT 1
83254: ARRAY
83255: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
83256: LD_ADDR_VAR 0 18
83260: PUSH
83261: LD_VAR 0 6
83265: PUSH
83266: LD_INT 2
83268: ARRAY
83269: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
83270: LD_ADDR_VAR 0 19
83274: PUSH
83275: LD_VAR 0 6
83279: PUSH
83280: LD_INT 3
83282: ARRAY
83283: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
83284: LD_ADDR_VAR 0 20
83288: PUSH
83289: LD_VAR 0 6
83293: PUSH
83294: LD_INT 4
83296: ARRAY
83297: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
83298: LD_ADDR_VAR 0 21
83302: PUSH
83303: LD_VAR 0 6
83307: PUSH
83308: LD_INT 5
83310: ARRAY
83311: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
83312: LD_ADDR_VAR 0 22
83316: PUSH
83317: LD_VAR 0 6
83321: PUSH
83322: LD_INT 6
83324: ARRAY
83325: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
83326: LD_ADDR_VAR 0 23
83330: PUSH
83331: LD_VAR 0 6
83335: PUSH
83336: LD_INT 7
83338: ARRAY
83339: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
83340: LD_ADDR_VAR 0 24
83344: PUSH
83345: LD_VAR 0 6
83349: PUSH
83350: LD_INT 8
83352: ARRAY
83353: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
83354: LD_ADDR_VAR 0 25
83358: PUSH
83359: LD_VAR 0 6
83363: PUSH
83364: LD_INT 9
83366: ARRAY
83367: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
83368: LD_ADDR_VAR 0 26
83372: PUSH
83373: LD_VAR 0 6
83377: PUSH
83378: LD_INT 10
83380: ARRAY
83381: ST_TO_ADDR
// end else
83382: GO 83464
// begin f_ignore_area := false ;
83384: LD_ADDR_VAR 0 17
83388: PUSH
83389: LD_INT 0
83391: ST_TO_ADDR
// f_capture := false ;
83392: LD_ADDR_VAR 0 18
83396: PUSH
83397: LD_INT 0
83399: ST_TO_ADDR
// f_ignore_civ := false ;
83400: LD_ADDR_VAR 0 19
83404: PUSH
83405: LD_INT 0
83407: ST_TO_ADDR
// f_murder := false ;
83408: LD_ADDR_VAR 0 20
83412: PUSH
83413: LD_INT 0
83415: ST_TO_ADDR
// f_mines := false ;
83416: LD_ADDR_VAR 0 21
83420: PUSH
83421: LD_INT 0
83423: ST_TO_ADDR
// f_repair := false ;
83424: LD_ADDR_VAR 0 22
83428: PUSH
83429: LD_INT 0
83431: ST_TO_ADDR
// f_heal := false ;
83432: LD_ADDR_VAR 0 23
83436: PUSH
83437: LD_INT 0
83439: ST_TO_ADDR
// f_spacetime := false ;
83440: LD_ADDR_VAR 0 24
83444: PUSH
83445: LD_INT 0
83447: ST_TO_ADDR
// f_attack_depot := false ;
83448: LD_ADDR_VAR 0 25
83452: PUSH
83453: LD_INT 0
83455: ST_TO_ADDR
// f_crawl := false ;
83456: LD_ADDR_VAR 0 26
83460: PUSH
83461: LD_INT 0
83463: ST_TO_ADDR
// end ; if f_heal then
83464: LD_VAR 0 23
83468: IFFALSE 83495
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
83470: LD_ADDR_VAR 0 31
83474: PUSH
83475: LD_VAR 0 4
83479: PPUSH
83480: LD_INT 25
83482: PUSH
83483: LD_INT 4
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: PPUSH
83490: CALL_OW 72
83494: ST_TO_ADDR
// if f_repair then
83495: LD_VAR 0 22
83499: IFFALSE 83526
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
83501: LD_ADDR_VAR 0 33
83505: PUSH
83506: LD_VAR 0 4
83510: PPUSH
83511: LD_INT 25
83513: PUSH
83514: LD_INT 3
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: PPUSH
83521: CALL_OW 72
83525: ST_TO_ADDR
// units_path := [ ] ;
83526: LD_ADDR_VAR 0 16
83530: PUSH
83531: EMPTY
83532: ST_TO_ADDR
// for i = 1 to group do
83533: LD_ADDR_VAR 0 7
83537: PUSH
83538: DOUBLE
83539: LD_INT 1
83541: DEC
83542: ST_TO_ADDR
83543: LD_VAR 0 4
83547: PUSH
83548: FOR_TO
83549: IFFALSE 83578
// units_path := Replace ( units_path , i , path ) ;
83551: LD_ADDR_VAR 0 16
83555: PUSH
83556: LD_VAR 0 16
83560: PPUSH
83561: LD_VAR 0 7
83565: PPUSH
83566: LD_VAR 0 5
83570: PPUSH
83571: CALL_OW 1
83575: ST_TO_ADDR
83576: GO 83548
83578: POP
83579: POP
// repeat for i = group downto 1 do
83580: LD_ADDR_VAR 0 7
83584: PUSH
83585: DOUBLE
83586: LD_VAR 0 4
83590: INC
83591: ST_TO_ADDR
83592: LD_INT 1
83594: PUSH
83595: FOR_DOWNTO
83596: IFFALSE 87718
// begin wait ( 5 ) ;
83598: LD_INT 5
83600: PPUSH
83601: CALL_OW 67
// tmp := [ ] ;
83605: LD_ADDR_VAR 0 14
83609: PUSH
83610: EMPTY
83611: ST_TO_ADDR
// attacking := false ;
83612: LD_ADDR_VAR 0 29
83616: PUSH
83617: LD_INT 0
83619: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
83620: LD_VAR 0 4
83624: PUSH
83625: LD_VAR 0 7
83629: ARRAY
83630: PPUSH
83631: CALL_OW 301
83635: PUSH
83636: LD_VAR 0 4
83640: PUSH
83641: LD_VAR 0 7
83645: ARRAY
83646: NOT
83647: OR
83648: IFFALSE 83757
// begin if GetType ( group [ i ] ) = unit_human then
83650: LD_VAR 0 4
83654: PUSH
83655: LD_VAR 0 7
83659: ARRAY
83660: PPUSH
83661: CALL_OW 247
83665: PUSH
83666: LD_INT 1
83668: EQUAL
83669: IFFALSE 83715
// begin to_heal := to_heal diff group [ i ] ;
83671: LD_ADDR_VAR 0 30
83675: PUSH
83676: LD_VAR 0 30
83680: PUSH
83681: LD_VAR 0 4
83685: PUSH
83686: LD_VAR 0 7
83690: ARRAY
83691: DIFF
83692: ST_TO_ADDR
// healers := healers diff group [ i ] ;
83693: LD_ADDR_VAR 0 31
83697: PUSH
83698: LD_VAR 0 31
83702: PUSH
83703: LD_VAR 0 4
83707: PUSH
83708: LD_VAR 0 7
83712: ARRAY
83713: DIFF
83714: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
83715: LD_ADDR_VAR 0 4
83719: PUSH
83720: LD_VAR 0 4
83724: PPUSH
83725: LD_VAR 0 7
83729: PPUSH
83730: CALL_OW 3
83734: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
83735: LD_ADDR_VAR 0 16
83739: PUSH
83740: LD_VAR 0 16
83744: PPUSH
83745: LD_VAR 0 7
83749: PPUSH
83750: CALL_OW 3
83754: ST_TO_ADDR
// continue ;
83755: GO 83595
// end ; if f_repair then
83757: LD_VAR 0 22
83761: IFFALSE 84250
// begin if GetType ( group [ i ] ) = unit_vehicle then
83763: LD_VAR 0 4
83767: PUSH
83768: LD_VAR 0 7
83772: ARRAY
83773: PPUSH
83774: CALL_OW 247
83778: PUSH
83779: LD_INT 2
83781: EQUAL
83782: IFFALSE 83972
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
83784: LD_VAR 0 4
83788: PUSH
83789: LD_VAR 0 7
83793: ARRAY
83794: PPUSH
83795: CALL_OW 256
83799: PUSH
83800: LD_INT 700
83802: LESS
83803: PUSH
83804: LD_VAR 0 4
83808: PUSH
83809: LD_VAR 0 7
83813: ARRAY
83814: PUSH
83815: LD_VAR 0 32
83819: IN
83820: NOT
83821: AND
83822: IFFALSE 83846
// to_repair := to_repair union group [ i ] ;
83824: LD_ADDR_VAR 0 32
83828: PUSH
83829: LD_VAR 0 32
83833: PUSH
83834: LD_VAR 0 4
83838: PUSH
83839: LD_VAR 0 7
83843: ARRAY
83844: UNION
83845: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
83846: LD_VAR 0 4
83850: PUSH
83851: LD_VAR 0 7
83855: ARRAY
83856: PPUSH
83857: CALL_OW 256
83861: PUSH
83862: LD_INT 1000
83864: EQUAL
83865: PUSH
83866: LD_VAR 0 4
83870: PUSH
83871: LD_VAR 0 7
83875: ARRAY
83876: PUSH
83877: LD_VAR 0 32
83881: IN
83882: AND
83883: IFFALSE 83907
// to_repair := to_repair diff group [ i ] ;
83885: LD_ADDR_VAR 0 32
83889: PUSH
83890: LD_VAR 0 32
83894: PUSH
83895: LD_VAR 0 4
83899: PUSH
83900: LD_VAR 0 7
83904: ARRAY
83905: DIFF
83906: ST_TO_ADDR
// if group [ i ] in to_repair then
83907: LD_VAR 0 4
83911: PUSH
83912: LD_VAR 0 7
83916: ARRAY
83917: PUSH
83918: LD_VAR 0 32
83922: IN
83923: IFFALSE 83970
// begin if not IsInArea ( group [ i ] , f_repair ) then
83925: LD_VAR 0 4
83929: PUSH
83930: LD_VAR 0 7
83934: ARRAY
83935: PPUSH
83936: LD_VAR 0 22
83940: PPUSH
83941: CALL_OW 308
83945: NOT
83946: IFFALSE 83968
// ComMoveToArea ( group [ i ] , f_repair ) ;
83948: LD_VAR 0 4
83952: PUSH
83953: LD_VAR 0 7
83957: ARRAY
83958: PPUSH
83959: LD_VAR 0 22
83963: PPUSH
83964: CALL_OW 113
// continue ;
83968: GO 83595
// end ; end else
83970: GO 84250
// if group [ i ] in repairs then
83972: LD_VAR 0 4
83976: PUSH
83977: LD_VAR 0 7
83981: ARRAY
83982: PUSH
83983: LD_VAR 0 33
83987: IN
83988: IFFALSE 84250
// begin if IsInUnit ( group [ i ] ) then
83990: LD_VAR 0 4
83994: PUSH
83995: LD_VAR 0 7
83999: ARRAY
84000: PPUSH
84001: CALL_OW 310
84005: IFFALSE 84073
// begin z := IsInUnit ( group [ i ] ) ;
84007: LD_ADDR_VAR 0 13
84011: PUSH
84012: LD_VAR 0 4
84016: PUSH
84017: LD_VAR 0 7
84021: ARRAY
84022: PPUSH
84023: CALL_OW 310
84027: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
84028: LD_VAR 0 13
84032: PUSH
84033: LD_VAR 0 32
84037: IN
84038: PUSH
84039: LD_VAR 0 13
84043: PPUSH
84044: LD_VAR 0 22
84048: PPUSH
84049: CALL_OW 308
84053: AND
84054: IFFALSE 84071
// ComExitVehicle ( group [ i ] ) ;
84056: LD_VAR 0 4
84060: PUSH
84061: LD_VAR 0 7
84065: ARRAY
84066: PPUSH
84067: CALL_OW 121
// end else
84071: GO 84250
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
84073: LD_ADDR_VAR 0 13
84077: PUSH
84078: LD_VAR 0 4
84082: PPUSH
84083: LD_INT 95
84085: PUSH
84086: LD_VAR 0 22
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: PUSH
84095: LD_INT 58
84097: PUSH
84098: EMPTY
84099: LIST
84100: PUSH
84101: EMPTY
84102: LIST
84103: LIST
84104: PPUSH
84105: CALL_OW 72
84109: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
84110: LD_VAR 0 4
84114: PUSH
84115: LD_VAR 0 7
84119: ARRAY
84120: PPUSH
84121: CALL_OW 314
84125: NOT
84126: IFFALSE 84248
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
84128: LD_ADDR_VAR 0 10
84132: PUSH
84133: LD_VAR 0 13
84137: PPUSH
84138: LD_VAR 0 4
84142: PUSH
84143: LD_VAR 0 7
84147: ARRAY
84148: PPUSH
84149: CALL_OW 74
84153: ST_TO_ADDR
// if not x then
84154: LD_VAR 0 10
84158: NOT
84159: IFFALSE 84163
// continue ;
84161: GO 83595
// if GetLives ( x ) < 1000 then
84163: LD_VAR 0 10
84167: PPUSH
84168: CALL_OW 256
84172: PUSH
84173: LD_INT 1000
84175: LESS
84176: IFFALSE 84200
// ComRepairVehicle ( group [ i ] , x ) else
84178: LD_VAR 0 4
84182: PUSH
84183: LD_VAR 0 7
84187: ARRAY
84188: PPUSH
84189: LD_VAR 0 10
84193: PPUSH
84194: CALL_OW 129
84198: GO 84248
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
84200: LD_VAR 0 23
84204: PUSH
84205: LD_VAR 0 4
84209: PUSH
84210: LD_VAR 0 7
84214: ARRAY
84215: PPUSH
84216: CALL_OW 256
84220: PUSH
84221: LD_INT 1000
84223: LESS
84224: AND
84225: NOT
84226: IFFALSE 84248
// ComEnterUnit ( group [ i ] , x ) ;
84228: LD_VAR 0 4
84232: PUSH
84233: LD_VAR 0 7
84237: ARRAY
84238: PPUSH
84239: LD_VAR 0 10
84243: PPUSH
84244: CALL_OW 120
// end ; continue ;
84248: GO 83595
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
84250: LD_VAR 0 23
84254: PUSH
84255: LD_VAR 0 4
84259: PUSH
84260: LD_VAR 0 7
84264: ARRAY
84265: PPUSH
84266: CALL_OW 247
84270: PUSH
84271: LD_INT 1
84273: EQUAL
84274: AND
84275: IFFALSE 84753
// begin if group [ i ] in healers then
84277: LD_VAR 0 4
84281: PUSH
84282: LD_VAR 0 7
84286: ARRAY
84287: PUSH
84288: LD_VAR 0 31
84292: IN
84293: IFFALSE 84566
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
84295: LD_VAR 0 4
84299: PUSH
84300: LD_VAR 0 7
84304: ARRAY
84305: PPUSH
84306: LD_VAR 0 23
84310: PPUSH
84311: CALL_OW 308
84315: NOT
84316: PUSH
84317: LD_VAR 0 4
84321: PUSH
84322: LD_VAR 0 7
84326: ARRAY
84327: PPUSH
84328: CALL_OW 314
84332: NOT
84333: AND
84334: IFFALSE 84358
// ComMoveToArea ( group [ i ] , f_heal ) else
84336: LD_VAR 0 4
84340: PUSH
84341: LD_VAR 0 7
84345: ARRAY
84346: PPUSH
84347: LD_VAR 0 23
84351: PPUSH
84352: CALL_OW 113
84356: GO 84564
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
84358: LD_VAR 0 4
84362: PUSH
84363: LD_VAR 0 7
84367: ARRAY
84368: PPUSH
84369: CALL 45833 0 1
84373: PPUSH
84374: CALL_OW 256
84378: PUSH
84379: LD_INT 1000
84381: EQUAL
84382: IFFALSE 84401
// ComStop ( group [ i ] ) else
84384: LD_VAR 0 4
84388: PUSH
84389: LD_VAR 0 7
84393: ARRAY
84394: PPUSH
84395: CALL_OW 141
84399: GO 84564
// if not HasTask ( group [ i ] ) and to_heal then
84401: LD_VAR 0 4
84405: PUSH
84406: LD_VAR 0 7
84410: ARRAY
84411: PPUSH
84412: CALL_OW 314
84416: NOT
84417: PUSH
84418: LD_VAR 0 30
84422: AND
84423: IFFALSE 84564
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
84425: LD_ADDR_VAR 0 13
84429: PUSH
84430: LD_VAR 0 30
84434: PPUSH
84435: LD_INT 3
84437: PUSH
84438: LD_INT 54
84440: PUSH
84441: EMPTY
84442: LIST
84443: PUSH
84444: EMPTY
84445: LIST
84446: LIST
84447: PPUSH
84448: CALL_OW 72
84452: PPUSH
84453: LD_VAR 0 4
84457: PUSH
84458: LD_VAR 0 7
84462: ARRAY
84463: PPUSH
84464: CALL_OW 74
84468: ST_TO_ADDR
// if z then
84469: LD_VAR 0 13
84473: IFFALSE 84564
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
84475: LD_INT 91
84477: PUSH
84478: LD_VAR 0 13
84482: PUSH
84483: LD_INT 10
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 81
84493: PUSH
84494: LD_VAR 0 13
84498: PPUSH
84499: CALL_OW 255
84503: PUSH
84504: EMPTY
84505: LIST
84506: LIST
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PPUSH
84512: CALL_OW 69
84516: PUSH
84517: LD_INT 0
84519: EQUAL
84520: IFFALSE 84544
// ComHeal ( group [ i ] , z ) else
84522: LD_VAR 0 4
84526: PUSH
84527: LD_VAR 0 7
84531: ARRAY
84532: PPUSH
84533: LD_VAR 0 13
84537: PPUSH
84538: CALL_OW 128
84542: GO 84564
// ComMoveToArea ( group [ i ] , f_heal ) ;
84544: LD_VAR 0 4
84548: PUSH
84549: LD_VAR 0 7
84553: ARRAY
84554: PPUSH
84555: LD_VAR 0 23
84559: PPUSH
84560: CALL_OW 113
// end ; continue ;
84564: GO 83595
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
84566: LD_VAR 0 4
84570: PUSH
84571: LD_VAR 0 7
84575: ARRAY
84576: PPUSH
84577: CALL_OW 256
84581: PUSH
84582: LD_INT 700
84584: LESS
84585: PUSH
84586: LD_VAR 0 4
84590: PUSH
84591: LD_VAR 0 7
84595: ARRAY
84596: PUSH
84597: LD_VAR 0 30
84601: IN
84602: NOT
84603: AND
84604: IFFALSE 84628
// to_heal := to_heal union group [ i ] ;
84606: LD_ADDR_VAR 0 30
84610: PUSH
84611: LD_VAR 0 30
84615: PUSH
84616: LD_VAR 0 4
84620: PUSH
84621: LD_VAR 0 7
84625: ARRAY
84626: UNION
84627: ST_TO_ADDR
// if group [ i ] in to_heal then
84628: LD_VAR 0 4
84632: PUSH
84633: LD_VAR 0 7
84637: ARRAY
84638: PUSH
84639: LD_VAR 0 30
84643: IN
84644: IFFALSE 84753
// begin if GetLives ( group [ i ] ) = 1000 then
84646: LD_VAR 0 4
84650: PUSH
84651: LD_VAR 0 7
84655: ARRAY
84656: PPUSH
84657: CALL_OW 256
84661: PUSH
84662: LD_INT 1000
84664: EQUAL
84665: IFFALSE 84691
// to_heal := to_heal diff group [ i ] else
84667: LD_ADDR_VAR 0 30
84671: PUSH
84672: LD_VAR 0 30
84676: PUSH
84677: LD_VAR 0 4
84681: PUSH
84682: LD_VAR 0 7
84686: ARRAY
84687: DIFF
84688: ST_TO_ADDR
84689: GO 84753
// begin if not IsInArea ( group [ i ] , to_heal ) then
84691: LD_VAR 0 4
84695: PUSH
84696: LD_VAR 0 7
84700: ARRAY
84701: PPUSH
84702: LD_VAR 0 30
84706: PPUSH
84707: CALL_OW 308
84711: NOT
84712: IFFALSE 84736
// ComMoveToArea ( group [ i ] , f_heal ) else
84714: LD_VAR 0 4
84718: PUSH
84719: LD_VAR 0 7
84723: ARRAY
84724: PPUSH
84725: LD_VAR 0 23
84729: PPUSH
84730: CALL_OW 113
84734: GO 84751
// ComHold ( group [ i ] ) ;
84736: LD_VAR 0 4
84740: PUSH
84741: LD_VAR 0 7
84745: ARRAY
84746: PPUSH
84747: CALL_OW 140
// continue ;
84751: GO 83595
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
84753: LD_VAR 0 4
84757: PUSH
84758: LD_VAR 0 7
84762: ARRAY
84763: PPUSH
84764: LD_INT 10
84766: PPUSH
84767: CALL 43604 0 2
84771: NOT
84772: PUSH
84773: LD_VAR 0 16
84777: PUSH
84778: LD_VAR 0 7
84782: ARRAY
84783: PUSH
84784: EMPTY
84785: EQUAL
84786: NOT
84787: AND
84788: IFFALSE 85054
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
84790: LD_VAR 0 4
84794: PUSH
84795: LD_VAR 0 7
84799: ARRAY
84800: PPUSH
84801: CALL_OW 262
84805: PUSH
84806: LD_INT 1
84808: PUSH
84809: LD_INT 2
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: IN
84816: IFFALSE 84857
// if GetFuel ( group [ i ] ) < 10 then
84818: LD_VAR 0 4
84822: PUSH
84823: LD_VAR 0 7
84827: ARRAY
84828: PPUSH
84829: CALL_OW 261
84833: PUSH
84834: LD_INT 10
84836: LESS
84837: IFFALSE 84857
// SetFuel ( group [ i ] , 12 ) ;
84839: LD_VAR 0 4
84843: PUSH
84844: LD_VAR 0 7
84848: ARRAY
84849: PPUSH
84850: LD_INT 12
84852: PPUSH
84853: CALL_OW 240
// if units_path [ i ] then
84857: LD_VAR 0 16
84861: PUSH
84862: LD_VAR 0 7
84866: ARRAY
84867: IFFALSE 85052
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
84869: LD_VAR 0 4
84873: PUSH
84874: LD_VAR 0 7
84878: ARRAY
84879: PPUSH
84880: LD_VAR 0 16
84884: PUSH
84885: LD_VAR 0 7
84889: ARRAY
84890: PUSH
84891: LD_INT 1
84893: ARRAY
84894: PUSH
84895: LD_INT 1
84897: ARRAY
84898: PPUSH
84899: LD_VAR 0 16
84903: PUSH
84904: LD_VAR 0 7
84908: ARRAY
84909: PUSH
84910: LD_INT 1
84912: ARRAY
84913: PUSH
84914: LD_INT 2
84916: ARRAY
84917: PPUSH
84918: CALL_OW 297
84922: PUSH
84923: LD_INT 6
84925: GREATER
84926: IFFALSE 85001
// begin if not HasTask ( group [ i ] ) then
84928: LD_VAR 0 4
84932: PUSH
84933: LD_VAR 0 7
84937: ARRAY
84938: PPUSH
84939: CALL_OW 314
84943: NOT
84944: IFFALSE 84999
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
84946: LD_VAR 0 4
84950: PUSH
84951: LD_VAR 0 7
84955: ARRAY
84956: PPUSH
84957: LD_VAR 0 16
84961: PUSH
84962: LD_VAR 0 7
84966: ARRAY
84967: PUSH
84968: LD_INT 1
84970: ARRAY
84971: PUSH
84972: LD_INT 1
84974: ARRAY
84975: PPUSH
84976: LD_VAR 0 16
84980: PUSH
84981: LD_VAR 0 7
84985: ARRAY
84986: PUSH
84987: LD_INT 1
84989: ARRAY
84990: PUSH
84991: LD_INT 2
84993: ARRAY
84994: PPUSH
84995: CALL_OW 114
// end else
84999: GO 85052
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
85001: LD_ADDR_VAR 0 15
85005: PUSH
85006: LD_VAR 0 16
85010: PUSH
85011: LD_VAR 0 7
85015: ARRAY
85016: PPUSH
85017: LD_INT 1
85019: PPUSH
85020: CALL_OW 3
85024: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
85025: LD_ADDR_VAR 0 16
85029: PUSH
85030: LD_VAR 0 16
85034: PPUSH
85035: LD_VAR 0 7
85039: PPUSH
85040: LD_VAR 0 15
85044: PPUSH
85045: CALL_OW 1
85049: ST_TO_ADDR
// continue ;
85050: GO 83595
// end ; end ; end else
85052: GO 87716
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
85054: LD_ADDR_VAR 0 14
85058: PUSH
85059: LD_INT 81
85061: PUSH
85062: LD_VAR 0 4
85066: PUSH
85067: LD_VAR 0 7
85071: ARRAY
85072: PPUSH
85073: CALL_OW 255
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: PPUSH
85082: CALL_OW 69
85086: ST_TO_ADDR
// if not tmp then
85087: LD_VAR 0 14
85091: NOT
85092: IFFALSE 85096
// continue ;
85094: GO 83595
// if f_ignore_area then
85096: LD_VAR 0 17
85100: IFFALSE 85188
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
85102: LD_ADDR_VAR 0 15
85106: PUSH
85107: LD_VAR 0 14
85111: PPUSH
85112: LD_INT 3
85114: PUSH
85115: LD_INT 92
85117: PUSH
85118: LD_VAR 0 17
85122: PUSH
85123: LD_INT 1
85125: ARRAY
85126: PUSH
85127: LD_VAR 0 17
85131: PUSH
85132: LD_INT 2
85134: ARRAY
85135: PUSH
85136: LD_VAR 0 17
85140: PUSH
85141: LD_INT 3
85143: ARRAY
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: PUSH
85151: EMPTY
85152: LIST
85153: LIST
85154: PPUSH
85155: CALL_OW 72
85159: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85160: LD_VAR 0 14
85164: PUSH
85165: LD_VAR 0 15
85169: DIFF
85170: IFFALSE 85188
// tmp := tmp diff tmp2 ;
85172: LD_ADDR_VAR 0 14
85176: PUSH
85177: LD_VAR 0 14
85181: PUSH
85182: LD_VAR 0 15
85186: DIFF
85187: ST_TO_ADDR
// end ; if not f_murder then
85188: LD_VAR 0 20
85192: NOT
85193: IFFALSE 85251
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
85195: LD_ADDR_VAR 0 15
85199: PUSH
85200: LD_VAR 0 14
85204: PPUSH
85205: LD_INT 3
85207: PUSH
85208: LD_INT 50
85210: PUSH
85211: EMPTY
85212: LIST
85213: PUSH
85214: EMPTY
85215: LIST
85216: LIST
85217: PPUSH
85218: CALL_OW 72
85222: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
85223: LD_VAR 0 14
85227: PUSH
85228: LD_VAR 0 15
85232: DIFF
85233: IFFALSE 85251
// tmp := tmp diff tmp2 ;
85235: LD_ADDR_VAR 0 14
85239: PUSH
85240: LD_VAR 0 14
85244: PUSH
85245: LD_VAR 0 15
85249: DIFF
85250: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
85251: LD_ADDR_VAR 0 14
85255: PUSH
85256: LD_VAR 0 4
85260: PUSH
85261: LD_VAR 0 7
85265: ARRAY
85266: PPUSH
85267: LD_VAR 0 14
85271: PPUSH
85272: LD_INT 1
85274: PPUSH
85275: LD_INT 1
85277: PPUSH
85278: CALL 16545 0 4
85282: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
85283: LD_VAR 0 4
85287: PUSH
85288: LD_VAR 0 7
85292: ARRAY
85293: PPUSH
85294: CALL_OW 257
85298: PUSH
85299: LD_INT 1
85301: EQUAL
85302: IFFALSE 85750
// begin if WantPlant ( group [ i ] ) then
85304: LD_VAR 0 4
85308: PUSH
85309: LD_VAR 0 7
85313: ARRAY
85314: PPUSH
85315: CALL 16046 0 1
85319: IFFALSE 85323
// continue ;
85321: GO 83595
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
85323: LD_VAR 0 18
85327: PUSH
85328: LD_VAR 0 4
85332: PUSH
85333: LD_VAR 0 7
85337: ARRAY
85338: PPUSH
85339: CALL_OW 310
85343: NOT
85344: AND
85345: PUSH
85346: LD_VAR 0 14
85350: PUSH
85351: LD_INT 1
85353: ARRAY
85354: PUSH
85355: LD_VAR 0 14
85359: PPUSH
85360: LD_INT 21
85362: PUSH
85363: LD_INT 2
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 58
85372: PUSH
85373: EMPTY
85374: LIST
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PPUSH
85380: CALL_OW 72
85384: IN
85385: AND
85386: IFFALSE 85422
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
85388: LD_VAR 0 4
85392: PUSH
85393: LD_VAR 0 7
85397: ARRAY
85398: PPUSH
85399: LD_VAR 0 14
85403: PUSH
85404: LD_INT 1
85406: ARRAY
85407: PPUSH
85408: CALL_OW 120
// attacking := true ;
85412: LD_ADDR_VAR 0 29
85416: PUSH
85417: LD_INT 1
85419: ST_TO_ADDR
// continue ;
85420: GO 83595
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
85422: LD_VAR 0 26
85426: PUSH
85427: LD_VAR 0 4
85431: PUSH
85432: LD_VAR 0 7
85436: ARRAY
85437: PPUSH
85438: CALL_OW 257
85442: PUSH
85443: LD_INT 1
85445: EQUAL
85446: AND
85447: PUSH
85448: LD_VAR 0 4
85452: PUSH
85453: LD_VAR 0 7
85457: ARRAY
85458: PPUSH
85459: CALL_OW 256
85463: PUSH
85464: LD_INT 800
85466: LESS
85467: AND
85468: PUSH
85469: LD_VAR 0 4
85473: PUSH
85474: LD_VAR 0 7
85478: ARRAY
85479: PPUSH
85480: CALL_OW 318
85484: NOT
85485: AND
85486: IFFALSE 85503
// ComCrawl ( group [ i ] ) ;
85488: LD_VAR 0 4
85492: PUSH
85493: LD_VAR 0 7
85497: ARRAY
85498: PPUSH
85499: CALL_OW 137
// if f_mines then
85503: LD_VAR 0 21
85507: IFFALSE 85750
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
85509: LD_VAR 0 14
85513: PUSH
85514: LD_INT 1
85516: ARRAY
85517: PPUSH
85518: CALL_OW 247
85522: PUSH
85523: LD_INT 3
85525: EQUAL
85526: PUSH
85527: LD_VAR 0 14
85531: PUSH
85532: LD_INT 1
85534: ARRAY
85535: PUSH
85536: LD_VAR 0 27
85540: IN
85541: NOT
85542: AND
85543: IFFALSE 85750
// begin x := GetX ( tmp [ 1 ] ) ;
85545: LD_ADDR_VAR 0 10
85549: PUSH
85550: LD_VAR 0 14
85554: PUSH
85555: LD_INT 1
85557: ARRAY
85558: PPUSH
85559: CALL_OW 250
85563: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
85564: LD_ADDR_VAR 0 11
85568: PUSH
85569: LD_VAR 0 14
85573: PUSH
85574: LD_INT 1
85576: ARRAY
85577: PPUSH
85578: CALL_OW 251
85582: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
85583: LD_ADDR_VAR 0 12
85587: PUSH
85588: LD_VAR 0 4
85592: PUSH
85593: LD_VAR 0 7
85597: ARRAY
85598: PPUSH
85599: CALL 43689 0 1
85603: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
85604: LD_VAR 0 4
85608: PUSH
85609: LD_VAR 0 7
85613: ARRAY
85614: PPUSH
85615: LD_VAR 0 10
85619: PPUSH
85620: LD_VAR 0 11
85624: PPUSH
85625: LD_VAR 0 14
85629: PUSH
85630: LD_INT 1
85632: ARRAY
85633: PPUSH
85634: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
85638: LD_VAR 0 4
85642: PUSH
85643: LD_VAR 0 7
85647: ARRAY
85648: PPUSH
85649: LD_VAR 0 10
85653: PPUSH
85654: LD_VAR 0 12
85658: PPUSH
85659: LD_INT 7
85661: PPUSH
85662: CALL_OW 272
85666: PPUSH
85667: LD_VAR 0 11
85671: PPUSH
85672: LD_VAR 0 12
85676: PPUSH
85677: LD_INT 7
85679: PPUSH
85680: CALL_OW 273
85684: PPUSH
85685: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
85689: LD_VAR 0 4
85693: PUSH
85694: LD_VAR 0 7
85698: ARRAY
85699: PPUSH
85700: LD_INT 71
85702: PPUSH
85703: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
85707: LD_ADDR_VAR 0 27
85711: PUSH
85712: LD_VAR 0 27
85716: PPUSH
85717: LD_VAR 0 27
85721: PUSH
85722: LD_INT 1
85724: PLUS
85725: PPUSH
85726: LD_VAR 0 14
85730: PUSH
85731: LD_INT 1
85733: ARRAY
85734: PPUSH
85735: CALL_OW 1
85739: ST_TO_ADDR
// attacking := true ;
85740: LD_ADDR_VAR 0 29
85744: PUSH
85745: LD_INT 1
85747: ST_TO_ADDR
// continue ;
85748: GO 83595
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
85750: LD_VAR 0 4
85754: PUSH
85755: LD_VAR 0 7
85759: ARRAY
85760: PPUSH
85761: CALL_OW 257
85765: PUSH
85766: LD_INT 17
85768: EQUAL
85769: PUSH
85770: LD_VAR 0 4
85774: PUSH
85775: LD_VAR 0 7
85779: ARRAY
85780: PPUSH
85781: CALL_OW 110
85785: PUSH
85786: LD_INT 71
85788: EQUAL
85789: NOT
85790: AND
85791: IFFALSE 85937
// begin attacking := false ;
85793: LD_ADDR_VAR 0 29
85797: PUSH
85798: LD_INT 0
85800: ST_TO_ADDR
// k := 5 ;
85801: LD_ADDR_VAR 0 9
85805: PUSH
85806: LD_INT 5
85808: ST_TO_ADDR
// if tmp < k then
85809: LD_VAR 0 14
85813: PUSH
85814: LD_VAR 0 9
85818: LESS
85819: IFFALSE 85831
// k := tmp ;
85821: LD_ADDR_VAR 0 9
85825: PUSH
85826: LD_VAR 0 14
85830: ST_TO_ADDR
// for j = 1 to k do
85831: LD_ADDR_VAR 0 8
85835: PUSH
85836: DOUBLE
85837: LD_INT 1
85839: DEC
85840: ST_TO_ADDR
85841: LD_VAR 0 9
85845: PUSH
85846: FOR_TO
85847: IFFALSE 85935
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
85849: LD_VAR 0 14
85853: PUSH
85854: LD_VAR 0 8
85858: ARRAY
85859: PUSH
85860: LD_VAR 0 14
85864: PPUSH
85865: LD_INT 58
85867: PUSH
85868: EMPTY
85869: LIST
85870: PPUSH
85871: CALL_OW 72
85875: IN
85876: NOT
85877: IFFALSE 85933
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85879: LD_VAR 0 4
85883: PUSH
85884: LD_VAR 0 7
85888: ARRAY
85889: PPUSH
85890: LD_VAR 0 14
85894: PUSH
85895: LD_VAR 0 8
85899: ARRAY
85900: PPUSH
85901: CALL_OW 115
// attacking := true ;
85905: LD_ADDR_VAR 0 29
85909: PUSH
85910: LD_INT 1
85912: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
85913: LD_VAR 0 4
85917: PUSH
85918: LD_VAR 0 7
85922: ARRAY
85923: PPUSH
85924: LD_INT 71
85926: PPUSH
85927: CALL_OW 109
// continue ;
85931: GO 85846
// end ; end ;
85933: GO 85846
85935: POP
85936: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
85937: LD_VAR 0 4
85941: PUSH
85942: LD_VAR 0 7
85946: ARRAY
85947: PPUSH
85948: CALL_OW 257
85952: PUSH
85953: LD_INT 8
85955: EQUAL
85956: PUSH
85957: LD_VAR 0 4
85961: PUSH
85962: LD_VAR 0 7
85966: ARRAY
85967: PPUSH
85968: CALL_OW 264
85972: PUSH
85973: LD_INT 28
85975: PUSH
85976: LD_INT 45
85978: PUSH
85979: LD_INT 7
85981: PUSH
85982: LD_INT 47
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: LIST
85989: LIST
85990: IN
85991: OR
85992: IFFALSE 86248
// begin attacking := false ;
85994: LD_ADDR_VAR 0 29
85998: PUSH
85999: LD_INT 0
86001: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
86002: LD_VAR 0 14
86006: PUSH
86007: LD_INT 1
86009: ARRAY
86010: PPUSH
86011: CALL_OW 266
86015: PUSH
86016: LD_INT 32
86018: PUSH
86019: LD_INT 31
86021: PUSH
86022: LD_INT 33
86024: PUSH
86025: LD_INT 4
86027: PUSH
86028: LD_INT 5
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: IN
86038: IFFALSE 86224
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
86040: LD_ADDR_VAR 0 9
86044: PUSH
86045: LD_VAR 0 14
86049: PUSH
86050: LD_INT 1
86052: ARRAY
86053: PPUSH
86054: CALL_OW 266
86058: PPUSH
86059: LD_VAR 0 14
86063: PUSH
86064: LD_INT 1
86066: ARRAY
86067: PPUSH
86068: CALL_OW 250
86072: PPUSH
86073: LD_VAR 0 14
86077: PUSH
86078: LD_INT 1
86080: ARRAY
86081: PPUSH
86082: CALL_OW 251
86086: PPUSH
86087: LD_VAR 0 14
86091: PUSH
86092: LD_INT 1
86094: ARRAY
86095: PPUSH
86096: CALL_OW 254
86100: PPUSH
86101: LD_VAR 0 14
86105: PUSH
86106: LD_INT 1
86108: ARRAY
86109: PPUSH
86110: CALL_OW 248
86114: PPUSH
86115: LD_INT 0
86117: PPUSH
86118: CALL 25059 0 6
86122: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
86123: LD_ADDR_VAR 0 8
86127: PUSH
86128: LD_VAR 0 4
86132: PUSH
86133: LD_VAR 0 7
86137: ARRAY
86138: PPUSH
86139: LD_VAR 0 9
86143: PPUSH
86144: CALL 43802 0 2
86148: ST_TO_ADDR
// if j then
86149: LD_VAR 0 8
86153: IFFALSE 86222
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
86155: LD_VAR 0 8
86159: PUSH
86160: LD_INT 1
86162: ARRAY
86163: PPUSH
86164: LD_VAR 0 8
86168: PUSH
86169: LD_INT 2
86171: ARRAY
86172: PPUSH
86173: CALL_OW 488
86177: IFFALSE 86222
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
86179: LD_VAR 0 4
86183: PUSH
86184: LD_VAR 0 7
86188: ARRAY
86189: PPUSH
86190: LD_VAR 0 8
86194: PUSH
86195: LD_INT 1
86197: ARRAY
86198: PPUSH
86199: LD_VAR 0 8
86203: PUSH
86204: LD_INT 2
86206: ARRAY
86207: PPUSH
86208: CALL_OW 116
// attacking := true ;
86212: LD_ADDR_VAR 0 29
86216: PUSH
86217: LD_INT 1
86219: ST_TO_ADDR
// continue ;
86220: GO 83595
// end ; end else
86222: GO 86248
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86224: LD_VAR 0 4
86228: PUSH
86229: LD_VAR 0 7
86233: ARRAY
86234: PPUSH
86235: LD_VAR 0 14
86239: PUSH
86240: LD_INT 1
86242: ARRAY
86243: PPUSH
86244: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
86248: LD_VAR 0 4
86252: PUSH
86253: LD_VAR 0 7
86257: ARRAY
86258: PPUSH
86259: CALL_OW 265
86263: PUSH
86264: LD_INT 11
86266: EQUAL
86267: IFFALSE 86545
// begin k := 10 ;
86269: LD_ADDR_VAR 0 9
86273: PUSH
86274: LD_INT 10
86276: ST_TO_ADDR
// x := 0 ;
86277: LD_ADDR_VAR 0 10
86281: PUSH
86282: LD_INT 0
86284: ST_TO_ADDR
// if tmp < k then
86285: LD_VAR 0 14
86289: PUSH
86290: LD_VAR 0 9
86294: LESS
86295: IFFALSE 86307
// k := tmp ;
86297: LD_ADDR_VAR 0 9
86301: PUSH
86302: LD_VAR 0 14
86306: ST_TO_ADDR
// for j = k downto 1 do
86307: LD_ADDR_VAR 0 8
86311: PUSH
86312: DOUBLE
86313: LD_VAR 0 9
86317: INC
86318: ST_TO_ADDR
86319: LD_INT 1
86321: PUSH
86322: FOR_DOWNTO
86323: IFFALSE 86398
// begin if GetType ( tmp [ j ] ) = unit_human then
86325: LD_VAR 0 14
86329: PUSH
86330: LD_VAR 0 8
86334: ARRAY
86335: PPUSH
86336: CALL_OW 247
86340: PUSH
86341: LD_INT 1
86343: EQUAL
86344: IFFALSE 86396
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
86346: LD_VAR 0 4
86350: PUSH
86351: LD_VAR 0 7
86355: ARRAY
86356: PPUSH
86357: LD_VAR 0 14
86361: PUSH
86362: LD_VAR 0 8
86366: ARRAY
86367: PPUSH
86368: CALL 44056 0 2
// x := tmp [ j ] ;
86372: LD_ADDR_VAR 0 10
86376: PUSH
86377: LD_VAR 0 14
86381: PUSH
86382: LD_VAR 0 8
86386: ARRAY
86387: ST_TO_ADDR
// attacking := true ;
86388: LD_ADDR_VAR 0 29
86392: PUSH
86393: LD_INT 1
86395: ST_TO_ADDR
// end ; end ;
86396: GO 86322
86398: POP
86399: POP
// if not x then
86400: LD_VAR 0 10
86404: NOT
86405: IFFALSE 86545
// begin attacking := true ;
86407: LD_ADDR_VAR 0 29
86411: PUSH
86412: LD_INT 1
86414: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
86415: LD_VAR 0 4
86419: PUSH
86420: LD_VAR 0 7
86424: ARRAY
86425: PPUSH
86426: CALL_OW 250
86430: PPUSH
86431: LD_VAR 0 4
86435: PUSH
86436: LD_VAR 0 7
86440: ARRAY
86441: PPUSH
86442: CALL_OW 251
86446: PPUSH
86447: CALL_OW 546
86451: PUSH
86452: LD_INT 2
86454: ARRAY
86455: PUSH
86456: LD_VAR 0 14
86460: PUSH
86461: LD_INT 1
86463: ARRAY
86464: PPUSH
86465: CALL_OW 250
86469: PPUSH
86470: LD_VAR 0 14
86474: PUSH
86475: LD_INT 1
86477: ARRAY
86478: PPUSH
86479: CALL_OW 251
86483: PPUSH
86484: CALL_OW 546
86488: PUSH
86489: LD_INT 2
86491: ARRAY
86492: EQUAL
86493: IFFALSE 86521
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
86495: LD_VAR 0 4
86499: PUSH
86500: LD_VAR 0 7
86504: ARRAY
86505: PPUSH
86506: LD_VAR 0 14
86510: PUSH
86511: LD_INT 1
86513: ARRAY
86514: PPUSH
86515: CALL 44056 0 2
86519: GO 86545
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86521: LD_VAR 0 4
86525: PUSH
86526: LD_VAR 0 7
86530: ARRAY
86531: PPUSH
86532: LD_VAR 0 14
86536: PUSH
86537: LD_INT 1
86539: ARRAY
86540: PPUSH
86541: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
86545: LD_VAR 0 4
86549: PUSH
86550: LD_VAR 0 7
86554: ARRAY
86555: PPUSH
86556: CALL_OW 264
86560: PUSH
86561: LD_INT 29
86563: EQUAL
86564: IFFALSE 86930
// begin if WantsToAttack ( group [ i ] ) in bombed then
86566: LD_VAR 0 4
86570: PUSH
86571: LD_VAR 0 7
86575: ARRAY
86576: PPUSH
86577: CALL_OW 319
86581: PUSH
86582: LD_VAR 0 28
86586: IN
86587: IFFALSE 86591
// continue ;
86589: GO 83595
// k := 8 ;
86591: LD_ADDR_VAR 0 9
86595: PUSH
86596: LD_INT 8
86598: ST_TO_ADDR
// x := 0 ;
86599: LD_ADDR_VAR 0 10
86603: PUSH
86604: LD_INT 0
86606: ST_TO_ADDR
// if tmp < k then
86607: LD_VAR 0 14
86611: PUSH
86612: LD_VAR 0 9
86616: LESS
86617: IFFALSE 86629
// k := tmp ;
86619: LD_ADDR_VAR 0 9
86623: PUSH
86624: LD_VAR 0 14
86628: ST_TO_ADDR
// for j = 1 to k do
86629: LD_ADDR_VAR 0 8
86633: PUSH
86634: DOUBLE
86635: LD_INT 1
86637: DEC
86638: ST_TO_ADDR
86639: LD_VAR 0 9
86643: PUSH
86644: FOR_TO
86645: IFFALSE 86777
// begin if GetType ( tmp [ j ] ) = unit_building then
86647: LD_VAR 0 14
86651: PUSH
86652: LD_VAR 0 8
86656: ARRAY
86657: PPUSH
86658: CALL_OW 247
86662: PUSH
86663: LD_INT 3
86665: EQUAL
86666: IFFALSE 86775
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
86668: LD_VAR 0 14
86672: PUSH
86673: LD_VAR 0 8
86677: ARRAY
86678: PUSH
86679: LD_VAR 0 28
86683: IN
86684: NOT
86685: PUSH
86686: LD_VAR 0 14
86690: PUSH
86691: LD_VAR 0 8
86695: ARRAY
86696: PPUSH
86697: CALL_OW 313
86701: AND
86702: IFFALSE 86775
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
86704: LD_VAR 0 4
86708: PUSH
86709: LD_VAR 0 7
86713: ARRAY
86714: PPUSH
86715: LD_VAR 0 14
86719: PUSH
86720: LD_VAR 0 8
86724: ARRAY
86725: PPUSH
86726: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
86730: LD_ADDR_VAR 0 28
86734: PUSH
86735: LD_VAR 0 28
86739: PPUSH
86740: LD_VAR 0 28
86744: PUSH
86745: LD_INT 1
86747: PLUS
86748: PPUSH
86749: LD_VAR 0 14
86753: PUSH
86754: LD_VAR 0 8
86758: ARRAY
86759: PPUSH
86760: CALL_OW 1
86764: ST_TO_ADDR
// attacking := true ;
86765: LD_ADDR_VAR 0 29
86769: PUSH
86770: LD_INT 1
86772: ST_TO_ADDR
// break ;
86773: GO 86777
// end ; end ;
86775: GO 86644
86777: POP
86778: POP
// if not attacking and f_attack_depot then
86779: LD_VAR 0 29
86783: NOT
86784: PUSH
86785: LD_VAR 0 25
86789: AND
86790: IFFALSE 86885
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
86792: LD_ADDR_VAR 0 13
86796: PUSH
86797: LD_VAR 0 14
86801: PPUSH
86802: LD_INT 2
86804: PUSH
86805: LD_INT 30
86807: PUSH
86808: LD_INT 0
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 30
86817: PUSH
86818: LD_INT 1
86820: PUSH
86821: EMPTY
86822: LIST
86823: LIST
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: LIST
86829: PPUSH
86830: CALL_OW 72
86834: ST_TO_ADDR
// if z then
86835: LD_VAR 0 13
86839: IFFALSE 86885
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
86841: LD_VAR 0 4
86845: PUSH
86846: LD_VAR 0 7
86850: ARRAY
86851: PPUSH
86852: LD_VAR 0 13
86856: PPUSH
86857: LD_VAR 0 4
86861: PUSH
86862: LD_VAR 0 7
86866: ARRAY
86867: PPUSH
86868: CALL_OW 74
86872: PPUSH
86873: CALL_OW 115
// attacking := true ;
86877: LD_ADDR_VAR 0 29
86881: PUSH
86882: LD_INT 1
86884: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
86885: LD_VAR 0 4
86889: PUSH
86890: LD_VAR 0 7
86894: ARRAY
86895: PPUSH
86896: CALL_OW 256
86900: PUSH
86901: LD_INT 500
86903: LESS
86904: IFFALSE 86930
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
86906: LD_VAR 0 4
86910: PUSH
86911: LD_VAR 0 7
86915: ARRAY
86916: PPUSH
86917: LD_VAR 0 14
86921: PUSH
86922: LD_INT 1
86924: ARRAY
86925: PPUSH
86926: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
86930: LD_VAR 0 4
86934: PUSH
86935: LD_VAR 0 7
86939: ARRAY
86940: PPUSH
86941: CALL_OW 264
86945: PUSH
86946: LD_INT 49
86948: EQUAL
86949: IFFALSE 87070
// begin if not HasTask ( group [ i ] ) then
86951: LD_VAR 0 4
86955: PUSH
86956: LD_VAR 0 7
86960: ARRAY
86961: PPUSH
86962: CALL_OW 314
86966: NOT
86967: IFFALSE 87070
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
86969: LD_ADDR_VAR 0 9
86973: PUSH
86974: LD_INT 81
86976: PUSH
86977: LD_VAR 0 4
86981: PUSH
86982: LD_VAR 0 7
86986: ARRAY
86987: PPUSH
86988: CALL_OW 255
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PPUSH
86997: CALL_OW 69
87001: PPUSH
87002: LD_VAR 0 4
87006: PUSH
87007: LD_VAR 0 7
87011: ARRAY
87012: PPUSH
87013: CALL_OW 74
87017: ST_TO_ADDR
// if k then
87018: LD_VAR 0 9
87022: IFFALSE 87070
// if GetDistUnits ( group [ i ] , k ) > 10 then
87024: LD_VAR 0 4
87028: PUSH
87029: LD_VAR 0 7
87033: ARRAY
87034: PPUSH
87035: LD_VAR 0 9
87039: PPUSH
87040: CALL_OW 296
87044: PUSH
87045: LD_INT 10
87047: GREATER
87048: IFFALSE 87070
// ComMoveUnit ( group [ i ] , k ) ;
87050: LD_VAR 0 4
87054: PUSH
87055: LD_VAR 0 7
87059: ARRAY
87060: PPUSH
87061: LD_VAR 0 9
87065: PPUSH
87066: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
87070: LD_VAR 0 4
87074: PUSH
87075: LD_VAR 0 7
87079: ARRAY
87080: PPUSH
87081: CALL_OW 256
87085: PUSH
87086: LD_INT 250
87088: LESS
87089: PUSH
87090: LD_VAR 0 4
87094: PUSH
87095: LD_VAR 0 7
87099: ARRAY
87100: PUSH
87101: LD_INT 21
87103: PUSH
87104: LD_INT 2
87106: PUSH
87107: EMPTY
87108: LIST
87109: LIST
87110: PUSH
87111: LD_INT 23
87113: PUSH
87114: LD_INT 2
87116: PUSH
87117: EMPTY
87118: LIST
87119: LIST
87120: PUSH
87121: EMPTY
87122: LIST
87123: LIST
87124: PPUSH
87125: CALL_OW 69
87129: IN
87130: AND
87131: IFFALSE 87256
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
87133: LD_ADDR_VAR 0 9
87137: PUSH
87138: LD_OWVAR 3
87142: PUSH
87143: LD_VAR 0 4
87147: PUSH
87148: LD_VAR 0 7
87152: ARRAY
87153: DIFF
87154: PPUSH
87155: LD_VAR 0 4
87159: PUSH
87160: LD_VAR 0 7
87164: ARRAY
87165: PPUSH
87166: CALL_OW 74
87170: ST_TO_ADDR
// if not k then
87171: LD_VAR 0 9
87175: NOT
87176: IFFALSE 87180
// continue ;
87178: GO 83595
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
87180: LD_VAR 0 9
87184: PUSH
87185: LD_INT 81
87187: PUSH
87188: LD_VAR 0 4
87192: PUSH
87193: LD_VAR 0 7
87197: ARRAY
87198: PPUSH
87199: CALL_OW 255
87203: PUSH
87204: EMPTY
87205: LIST
87206: LIST
87207: PPUSH
87208: CALL_OW 69
87212: IN
87213: PUSH
87214: LD_VAR 0 9
87218: PPUSH
87219: LD_VAR 0 4
87223: PUSH
87224: LD_VAR 0 7
87228: ARRAY
87229: PPUSH
87230: CALL_OW 296
87234: PUSH
87235: LD_INT 5
87237: LESS
87238: AND
87239: IFFALSE 87256
// ComAutodestruct ( group [ i ] ) ;
87241: LD_VAR 0 4
87245: PUSH
87246: LD_VAR 0 7
87250: ARRAY
87251: PPUSH
87252: CALL 43954 0 1
// end ; if f_attack_depot then
87256: LD_VAR 0 25
87260: IFFALSE 87372
// begin k := 6 ;
87262: LD_ADDR_VAR 0 9
87266: PUSH
87267: LD_INT 6
87269: ST_TO_ADDR
// if tmp < k then
87270: LD_VAR 0 14
87274: PUSH
87275: LD_VAR 0 9
87279: LESS
87280: IFFALSE 87292
// k := tmp ;
87282: LD_ADDR_VAR 0 9
87286: PUSH
87287: LD_VAR 0 14
87291: ST_TO_ADDR
// for j = 1 to k do
87292: LD_ADDR_VAR 0 8
87296: PUSH
87297: DOUBLE
87298: LD_INT 1
87300: DEC
87301: ST_TO_ADDR
87302: LD_VAR 0 9
87306: PUSH
87307: FOR_TO
87308: IFFALSE 87370
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
87310: LD_VAR 0 8
87314: PPUSH
87315: CALL_OW 266
87319: PUSH
87320: LD_INT 0
87322: PUSH
87323: LD_INT 1
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: IN
87330: IFFALSE 87368
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
87332: LD_VAR 0 4
87336: PUSH
87337: LD_VAR 0 7
87341: ARRAY
87342: PPUSH
87343: LD_VAR 0 14
87347: PUSH
87348: LD_VAR 0 8
87352: ARRAY
87353: PPUSH
87354: CALL_OW 115
// attacking := true ;
87358: LD_ADDR_VAR 0 29
87362: PUSH
87363: LD_INT 1
87365: ST_TO_ADDR
// break ;
87366: GO 87370
// end ;
87368: GO 87307
87370: POP
87371: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
87372: LD_VAR 0 4
87376: PUSH
87377: LD_VAR 0 7
87381: ARRAY
87382: PPUSH
87383: CALL_OW 302
87387: PUSH
87388: LD_VAR 0 29
87392: NOT
87393: AND
87394: IFFALSE 87716
// begin if GetTag ( group [ i ] ) = 71 then
87396: LD_VAR 0 4
87400: PUSH
87401: LD_VAR 0 7
87405: ARRAY
87406: PPUSH
87407: CALL_OW 110
87411: PUSH
87412: LD_INT 71
87414: EQUAL
87415: IFFALSE 87456
// begin if HasTask ( group [ i ] ) then
87417: LD_VAR 0 4
87421: PUSH
87422: LD_VAR 0 7
87426: ARRAY
87427: PPUSH
87428: CALL_OW 314
87432: IFFALSE 87438
// continue else
87434: GO 83595
87436: GO 87456
// SetTag ( group [ i ] , 0 ) ;
87438: LD_VAR 0 4
87442: PUSH
87443: LD_VAR 0 7
87447: ARRAY
87448: PPUSH
87449: LD_INT 0
87451: PPUSH
87452: CALL_OW 109
// end ; k := 8 ;
87456: LD_ADDR_VAR 0 9
87460: PUSH
87461: LD_INT 8
87463: ST_TO_ADDR
// x := 0 ;
87464: LD_ADDR_VAR 0 10
87468: PUSH
87469: LD_INT 0
87471: ST_TO_ADDR
// if tmp < k then
87472: LD_VAR 0 14
87476: PUSH
87477: LD_VAR 0 9
87481: LESS
87482: IFFALSE 87494
// k := tmp ;
87484: LD_ADDR_VAR 0 9
87488: PUSH
87489: LD_VAR 0 14
87493: ST_TO_ADDR
// for j = 1 to k do
87494: LD_ADDR_VAR 0 8
87498: PUSH
87499: DOUBLE
87500: LD_INT 1
87502: DEC
87503: ST_TO_ADDR
87504: LD_VAR 0 9
87508: PUSH
87509: FOR_TO
87510: IFFALSE 87608
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
87512: LD_VAR 0 14
87516: PUSH
87517: LD_VAR 0 8
87521: ARRAY
87522: PPUSH
87523: CALL_OW 247
87527: PUSH
87528: LD_INT 1
87530: EQUAL
87531: PUSH
87532: LD_VAR 0 14
87536: PUSH
87537: LD_VAR 0 8
87541: ARRAY
87542: PPUSH
87543: CALL_OW 256
87547: PUSH
87548: LD_INT 250
87550: LESS
87551: PUSH
87552: LD_VAR 0 20
87556: AND
87557: PUSH
87558: LD_VAR 0 20
87562: NOT
87563: PUSH
87564: LD_VAR 0 14
87568: PUSH
87569: LD_VAR 0 8
87573: ARRAY
87574: PPUSH
87575: CALL_OW 256
87579: PUSH
87580: LD_INT 250
87582: GREATEREQUAL
87583: AND
87584: OR
87585: AND
87586: IFFALSE 87606
// begin x := tmp [ j ] ;
87588: LD_ADDR_VAR 0 10
87592: PUSH
87593: LD_VAR 0 14
87597: PUSH
87598: LD_VAR 0 8
87602: ARRAY
87603: ST_TO_ADDR
// break ;
87604: GO 87608
// end ;
87606: GO 87509
87608: POP
87609: POP
// if x then
87610: LD_VAR 0 10
87614: IFFALSE 87638
// ComAttackUnit ( group [ i ] , x ) else
87616: LD_VAR 0 4
87620: PUSH
87621: LD_VAR 0 7
87625: ARRAY
87626: PPUSH
87627: LD_VAR 0 10
87631: PPUSH
87632: CALL_OW 115
87636: GO 87662
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
87638: LD_VAR 0 4
87642: PUSH
87643: LD_VAR 0 7
87647: ARRAY
87648: PPUSH
87649: LD_VAR 0 14
87653: PUSH
87654: LD_INT 1
87656: ARRAY
87657: PPUSH
87658: CALL_OW 115
// if not HasTask ( group [ i ] ) then
87662: LD_VAR 0 4
87666: PUSH
87667: LD_VAR 0 7
87671: ARRAY
87672: PPUSH
87673: CALL_OW 314
87677: NOT
87678: IFFALSE 87716
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
87680: LD_VAR 0 4
87684: PUSH
87685: LD_VAR 0 7
87689: ARRAY
87690: PPUSH
87691: LD_VAR 0 14
87695: PPUSH
87696: LD_VAR 0 4
87700: PUSH
87701: LD_VAR 0 7
87705: ARRAY
87706: PPUSH
87707: CALL_OW 74
87711: PPUSH
87712: CALL_OW 115
// end ; end ; end ;
87716: GO 83595
87718: POP
87719: POP
// wait ( 0 0$2 ) ;
87720: LD_INT 70
87722: PPUSH
87723: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
87727: LD_VAR 0 4
87731: NOT
87732: PUSH
87733: LD_VAR 0 4
87737: PUSH
87738: EMPTY
87739: EQUAL
87740: OR
87741: PUSH
87742: LD_INT 81
87744: PUSH
87745: LD_VAR 0 35
87749: PUSH
87750: EMPTY
87751: LIST
87752: LIST
87753: PPUSH
87754: CALL_OW 69
87758: NOT
87759: OR
87760: IFFALSE 83580
// end ;
87762: LD_VAR 0 2
87766: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
87767: LD_INT 0
87769: PPUSH
87770: PPUSH
87771: PPUSH
87772: PPUSH
87773: PPUSH
87774: PPUSH
// if not base or not mc_bases [ base ] or not solds then
87775: LD_VAR 0 1
87779: NOT
87780: PUSH
87781: LD_EXP 23
87785: PUSH
87786: LD_VAR 0 1
87790: ARRAY
87791: NOT
87792: OR
87793: PUSH
87794: LD_VAR 0 2
87798: NOT
87799: OR
87800: IFFALSE 87804
// exit ;
87802: GO 88358
// side := mc_sides [ base ] ;
87804: LD_ADDR_VAR 0 6
87808: PUSH
87809: LD_EXP 49
87813: PUSH
87814: LD_VAR 0 1
87818: ARRAY
87819: ST_TO_ADDR
// if not side then
87820: LD_VAR 0 6
87824: NOT
87825: IFFALSE 87829
// exit ;
87827: GO 88358
// for i in solds do
87829: LD_ADDR_VAR 0 7
87833: PUSH
87834: LD_VAR 0 2
87838: PUSH
87839: FOR_IN
87840: IFFALSE 87901
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
87842: LD_VAR 0 7
87846: PPUSH
87847: CALL_OW 310
87851: PPUSH
87852: CALL_OW 266
87856: PUSH
87857: LD_INT 32
87859: PUSH
87860: LD_INT 31
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: IN
87867: IFFALSE 87887
// solds := solds diff i else
87869: LD_ADDR_VAR 0 2
87873: PUSH
87874: LD_VAR 0 2
87878: PUSH
87879: LD_VAR 0 7
87883: DIFF
87884: ST_TO_ADDR
87885: GO 87899
// SetTag ( i , 18 ) ;
87887: LD_VAR 0 7
87891: PPUSH
87892: LD_INT 18
87894: PPUSH
87895: CALL_OW 109
87899: GO 87839
87901: POP
87902: POP
// if not solds then
87903: LD_VAR 0 2
87907: NOT
87908: IFFALSE 87912
// exit ;
87910: GO 88358
// repeat wait ( 0 0$2 ) ;
87912: LD_INT 70
87914: PPUSH
87915: CALL_OW 67
// enemy := mc_scan [ base ] ;
87919: LD_ADDR_VAR 0 4
87923: PUSH
87924: LD_EXP 46
87928: PUSH
87929: LD_VAR 0 1
87933: ARRAY
87934: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87935: LD_EXP 23
87939: PUSH
87940: LD_VAR 0 1
87944: ARRAY
87945: NOT
87946: PUSH
87947: LD_EXP 23
87951: PUSH
87952: LD_VAR 0 1
87956: ARRAY
87957: PUSH
87958: EMPTY
87959: EQUAL
87960: OR
87961: IFFALSE 87998
// begin for i in solds do
87963: LD_ADDR_VAR 0 7
87967: PUSH
87968: LD_VAR 0 2
87972: PUSH
87973: FOR_IN
87974: IFFALSE 87987
// ComStop ( i ) ;
87976: LD_VAR 0 7
87980: PPUSH
87981: CALL_OW 141
87985: GO 87973
87987: POP
87988: POP
// solds := [ ] ;
87989: LD_ADDR_VAR 0 2
87993: PUSH
87994: EMPTY
87995: ST_TO_ADDR
// exit ;
87996: GO 88358
// end ; for i in solds do
87998: LD_ADDR_VAR 0 7
88002: PUSH
88003: LD_VAR 0 2
88007: PUSH
88008: FOR_IN
88009: IFFALSE 88330
// begin if IsInUnit ( i ) then
88011: LD_VAR 0 7
88015: PPUSH
88016: CALL_OW 310
88020: IFFALSE 88031
// ComExitBuilding ( i ) ;
88022: LD_VAR 0 7
88026: PPUSH
88027: CALL_OW 122
// if GetLives ( i ) > 500 then
88031: LD_VAR 0 7
88035: PPUSH
88036: CALL_OW 256
88040: PUSH
88041: LD_INT 500
88043: GREATER
88044: IFFALSE 88097
// begin e := NearestUnitToUnit ( enemy , i ) ;
88046: LD_ADDR_VAR 0 5
88050: PUSH
88051: LD_VAR 0 4
88055: PPUSH
88056: LD_VAR 0 7
88060: PPUSH
88061: CALL_OW 74
88065: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
88066: LD_VAR 0 7
88070: PPUSH
88071: LD_VAR 0 5
88075: PPUSH
88076: CALL_OW 250
88080: PPUSH
88081: LD_VAR 0 5
88085: PPUSH
88086: CALL_OW 251
88090: PPUSH
88091: CALL_OW 114
// end else
88095: GO 88328
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
88097: LD_VAR 0 7
88101: PPUSH
88102: LD_EXP 23
88106: PUSH
88107: LD_VAR 0 1
88111: ARRAY
88112: PPUSH
88113: LD_INT 2
88115: PUSH
88116: LD_INT 30
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 30
88128: PUSH
88129: LD_INT 1
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: LD_INT 30
88138: PUSH
88139: LD_INT 6
88141: PUSH
88142: EMPTY
88143: LIST
88144: LIST
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: PPUSH
88152: CALL_OW 72
88156: PPUSH
88157: LD_VAR 0 7
88161: PPUSH
88162: CALL_OW 74
88166: PPUSH
88167: CALL_OW 296
88171: PUSH
88172: LD_INT 10
88174: GREATER
88175: IFFALSE 88328
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
88177: LD_ADDR_VAR 0 8
88181: PUSH
88182: LD_EXP 23
88186: PUSH
88187: LD_VAR 0 1
88191: ARRAY
88192: PPUSH
88193: LD_INT 2
88195: PUSH
88196: LD_INT 30
88198: PUSH
88199: LD_INT 0
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 30
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 30
88218: PUSH
88219: LD_INT 6
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: PPUSH
88232: CALL_OW 72
88236: PPUSH
88237: LD_VAR 0 7
88241: PPUSH
88242: CALL_OW 74
88246: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
88247: LD_VAR 0 7
88251: PPUSH
88252: LD_VAR 0 8
88256: PPUSH
88257: CALL_OW 250
88261: PPUSH
88262: LD_INT 3
88264: PPUSH
88265: LD_INT 5
88267: PPUSH
88268: CALL_OW 272
88272: PPUSH
88273: LD_VAR 0 8
88277: PPUSH
88278: CALL_OW 251
88282: PPUSH
88283: LD_INT 3
88285: PPUSH
88286: LD_INT 5
88288: PPUSH
88289: CALL_OW 273
88293: PPUSH
88294: CALL_OW 111
// SetTag ( i , 0 ) ;
88298: LD_VAR 0 7
88302: PPUSH
88303: LD_INT 0
88305: PPUSH
88306: CALL_OW 109
// solds := solds diff i ;
88310: LD_ADDR_VAR 0 2
88314: PUSH
88315: LD_VAR 0 2
88319: PUSH
88320: LD_VAR 0 7
88324: DIFF
88325: ST_TO_ADDR
// continue ;
88326: GO 88008
// end ; end ;
88328: GO 88008
88330: POP
88331: POP
// until not solds or not enemy ;
88332: LD_VAR 0 2
88336: NOT
88337: PUSH
88338: LD_VAR 0 4
88342: NOT
88343: OR
88344: IFFALSE 87912
// MC_Reset ( base , 18 ) ;
88346: LD_VAR 0 1
88350: PPUSH
88351: LD_INT 18
88353: PPUSH
88354: CALL 56555 0 2
// end ;
88358: LD_VAR 0 3
88362: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
88363: LD_INT 0
88365: PPUSH
88366: PPUSH
88367: PPUSH
88368: PPUSH
88369: PPUSH
88370: PPUSH
88371: PPUSH
88372: PPUSH
88373: PPUSH
88374: PPUSH
88375: PPUSH
88376: PPUSH
88377: PPUSH
88378: PPUSH
88379: PPUSH
88380: PPUSH
88381: PPUSH
88382: PPUSH
88383: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
88384: LD_ADDR_VAR 0 12
88388: PUSH
88389: LD_EXP 23
88393: PUSH
88394: LD_VAR 0 1
88398: ARRAY
88399: PPUSH
88400: LD_INT 25
88402: PUSH
88403: LD_INT 3
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PPUSH
88410: CALL_OW 72
88414: ST_TO_ADDR
// if mc_remote_driver [ base ] then
88415: LD_EXP 63
88419: PUSH
88420: LD_VAR 0 1
88424: ARRAY
88425: IFFALSE 88449
// mechs := mechs diff mc_remote_driver [ base ] ;
88427: LD_ADDR_VAR 0 12
88431: PUSH
88432: LD_VAR 0 12
88436: PUSH
88437: LD_EXP 63
88441: PUSH
88442: LD_VAR 0 1
88446: ARRAY
88447: DIFF
88448: ST_TO_ADDR
// for i in mechs do
88449: LD_ADDR_VAR 0 4
88453: PUSH
88454: LD_VAR 0 12
88458: PUSH
88459: FOR_IN
88460: IFFALSE 88495
// if GetTag ( i ) > 0 then
88462: LD_VAR 0 4
88466: PPUSH
88467: CALL_OW 110
88471: PUSH
88472: LD_INT 0
88474: GREATER
88475: IFFALSE 88493
// mechs := mechs diff i ;
88477: LD_ADDR_VAR 0 12
88481: PUSH
88482: LD_VAR 0 12
88486: PUSH
88487: LD_VAR 0 4
88491: DIFF
88492: ST_TO_ADDR
88493: GO 88459
88495: POP
88496: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88497: LD_ADDR_VAR 0 8
88501: PUSH
88502: LD_EXP 23
88506: PUSH
88507: LD_VAR 0 1
88511: ARRAY
88512: PPUSH
88513: LD_INT 2
88515: PUSH
88516: LD_INT 25
88518: PUSH
88519: LD_INT 1
88521: PUSH
88522: EMPTY
88523: LIST
88524: LIST
88525: PUSH
88526: LD_INT 25
88528: PUSH
88529: LD_INT 5
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: PUSH
88536: LD_INT 25
88538: PUSH
88539: LD_INT 8
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: PUSH
88546: LD_INT 25
88548: PUSH
88549: LD_INT 9
88551: PUSH
88552: EMPTY
88553: LIST
88554: LIST
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: PPUSH
88563: CALL_OW 72
88567: ST_TO_ADDR
// if not defenders and not solds then
88568: LD_VAR 0 2
88572: NOT
88573: PUSH
88574: LD_VAR 0 8
88578: NOT
88579: AND
88580: IFFALSE 88584
// exit ;
88582: GO 90354
// depot_under_attack := false ;
88584: LD_ADDR_VAR 0 16
88588: PUSH
88589: LD_INT 0
88591: ST_TO_ADDR
// sold_defenders := [ ] ;
88592: LD_ADDR_VAR 0 17
88596: PUSH
88597: EMPTY
88598: ST_TO_ADDR
// if mechs then
88599: LD_VAR 0 12
88603: IFFALSE 88756
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
88605: LD_ADDR_VAR 0 4
88609: PUSH
88610: LD_VAR 0 2
88614: PPUSH
88615: LD_INT 21
88617: PUSH
88618: LD_INT 2
88620: PUSH
88621: EMPTY
88622: LIST
88623: LIST
88624: PPUSH
88625: CALL_OW 72
88629: PUSH
88630: FOR_IN
88631: IFFALSE 88754
// begin if GetTag ( i ) <> 20 then
88633: LD_VAR 0 4
88637: PPUSH
88638: CALL_OW 110
88642: PUSH
88643: LD_INT 20
88645: NONEQUAL
88646: IFFALSE 88660
// SetTag ( i , 20 ) ;
88648: LD_VAR 0 4
88652: PPUSH
88653: LD_INT 20
88655: PPUSH
88656: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
88660: LD_VAR 0 4
88664: PPUSH
88665: CALL_OW 263
88669: PUSH
88670: LD_INT 1
88672: EQUAL
88673: PUSH
88674: LD_VAR 0 4
88678: PPUSH
88679: CALL_OW 311
88683: NOT
88684: AND
88685: IFFALSE 88752
// begin un := mechs [ 1 ] ;
88687: LD_ADDR_VAR 0 10
88691: PUSH
88692: LD_VAR 0 12
88696: PUSH
88697: LD_INT 1
88699: ARRAY
88700: ST_TO_ADDR
// ComExit ( un ) ;
88701: LD_VAR 0 10
88705: PPUSH
88706: CALL 48839 0 1
// AddComEnterUnit ( un , i ) ;
88710: LD_VAR 0 10
88714: PPUSH
88715: LD_VAR 0 4
88719: PPUSH
88720: CALL_OW 180
// SetTag ( un , 19 ) ;
88724: LD_VAR 0 10
88728: PPUSH
88729: LD_INT 19
88731: PPUSH
88732: CALL_OW 109
// mechs := mechs diff un ;
88736: LD_ADDR_VAR 0 12
88740: PUSH
88741: LD_VAR 0 12
88745: PUSH
88746: LD_VAR 0 10
88750: DIFF
88751: ST_TO_ADDR
// end ; end ;
88752: GO 88630
88754: POP
88755: POP
// if solds then
88756: LD_VAR 0 8
88760: IFFALSE 88819
// for i in solds do
88762: LD_ADDR_VAR 0 4
88766: PUSH
88767: LD_VAR 0 8
88771: PUSH
88772: FOR_IN
88773: IFFALSE 88817
// if not GetTag ( i ) then
88775: LD_VAR 0 4
88779: PPUSH
88780: CALL_OW 110
88784: NOT
88785: IFFALSE 88815
// begin defenders := defenders union i ;
88787: LD_ADDR_VAR 0 2
88791: PUSH
88792: LD_VAR 0 2
88796: PUSH
88797: LD_VAR 0 4
88801: UNION
88802: ST_TO_ADDR
// SetTag ( i , 18 ) ;
88803: LD_VAR 0 4
88807: PPUSH
88808: LD_INT 18
88810: PPUSH
88811: CALL_OW 109
// end ;
88815: GO 88772
88817: POP
88818: POP
// repeat wait ( 0 0$2 ) ;
88819: LD_INT 70
88821: PPUSH
88822: CALL_OW 67
// enemy := mc_scan [ base ] ;
88826: LD_ADDR_VAR 0 21
88830: PUSH
88831: LD_EXP 46
88835: PUSH
88836: LD_VAR 0 1
88840: ARRAY
88841: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88842: LD_EXP 23
88846: PUSH
88847: LD_VAR 0 1
88851: ARRAY
88852: NOT
88853: PUSH
88854: LD_EXP 23
88858: PUSH
88859: LD_VAR 0 1
88863: ARRAY
88864: PUSH
88865: EMPTY
88866: EQUAL
88867: OR
88868: IFFALSE 88905
// begin for i in defenders do
88870: LD_ADDR_VAR 0 4
88874: PUSH
88875: LD_VAR 0 2
88879: PUSH
88880: FOR_IN
88881: IFFALSE 88894
// ComStop ( i ) ;
88883: LD_VAR 0 4
88887: PPUSH
88888: CALL_OW 141
88892: GO 88880
88894: POP
88895: POP
// defenders := [ ] ;
88896: LD_ADDR_VAR 0 2
88900: PUSH
88901: EMPTY
88902: ST_TO_ADDR
// exit ;
88903: GO 90354
// end ; for i in defenders do
88905: LD_ADDR_VAR 0 4
88909: PUSH
88910: LD_VAR 0 2
88914: PUSH
88915: FOR_IN
88916: IFFALSE 89814
// begin e := NearestUnitToUnit ( enemy , i ) ;
88918: LD_ADDR_VAR 0 13
88922: PUSH
88923: LD_VAR 0 21
88927: PPUSH
88928: LD_VAR 0 4
88932: PPUSH
88933: CALL_OW 74
88937: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88938: LD_ADDR_VAR 0 7
88942: PUSH
88943: LD_EXP 23
88947: PUSH
88948: LD_VAR 0 1
88952: ARRAY
88953: PPUSH
88954: LD_INT 2
88956: PUSH
88957: LD_INT 30
88959: PUSH
88960: LD_INT 0
88962: PUSH
88963: EMPTY
88964: LIST
88965: LIST
88966: PUSH
88967: LD_INT 30
88969: PUSH
88970: LD_INT 1
88972: PUSH
88973: EMPTY
88974: LIST
88975: LIST
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: LIST
88981: PPUSH
88982: CALL_OW 72
88986: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
88987: LD_ADDR_VAR 0 16
88991: PUSH
88992: LD_VAR 0 7
88996: NOT
88997: PUSH
88998: LD_VAR 0 7
89002: PPUSH
89003: LD_INT 3
89005: PUSH
89006: LD_INT 24
89008: PUSH
89009: LD_INT 600
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PPUSH
89020: CALL_OW 72
89024: OR
89025: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
89026: LD_VAR 0 4
89030: PPUSH
89031: CALL_OW 247
89035: PUSH
89036: LD_INT 2
89038: DOUBLE
89039: EQUAL
89040: IFTRUE 89044
89042: GO 89440
89044: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
89045: LD_VAR 0 4
89049: PPUSH
89050: CALL_OW 256
89054: PUSH
89055: LD_INT 1000
89057: EQUAL
89058: PUSH
89059: LD_VAR 0 4
89063: PPUSH
89064: LD_VAR 0 13
89068: PPUSH
89069: CALL_OW 296
89073: PUSH
89074: LD_INT 40
89076: LESS
89077: PUSH
89078: LD_VAR 0 13
89082: PPUSH
89083: LD_EXP 48
89087: PUSH
89088: LD_VAR 0 1
89092: ARRAY
89093: PPUSH
89094: CALL_OW 308
89098: OR
89099: AND
89100: IFFALSE 89222
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
89102: LD_VAR 0 4
89106: PPUSH
89107: CALL_OW 262
89111: PUSH
89112: LD_INT 1
89114: EQUAL
89115: PUSH
89116: LD_VAR 0 4
89120: PPUSH
89121: CALL_OW 261
89125: PUSH
89126: LD_INT 30
89128: LESS
89129: AND
89130: PUSH
89131: LD_VAR 0 7
89135: AND
89136: IFFALSE 89206
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
89138: LD_VAR 0 4
89142: PPUSH
89143: LD_VAR 0 7
89147: PPUSH
89148: LD_VAR 0 4
89152: PPUSH
89153: CALL_OW 74
89157: PPUSH
89158: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
89162: LD_VAR 0 4
89166: PPUSH
89167: LD_VAR 0 7
89171: PPUSH
89172: LD_VAR 0 4
89176: PPUSH
89177: CALL_OW 74
89181: PPUSH
89182: CALL_OW 296
89186: PUSH
89187: LD_INT 6
89189: LESS
89190: IFFALSE 89204
// SetFuel ( i , 100 ) ;
89192: LD_VAR 0 4
89196: PPUSH
89197: LD_INT 100
89199: PPUSH
89200: CALL_OW 240
// end else
89204: GO 89220
// ComAttackUnit ( i , e ) ;
89206: LD_VAR 0 4
89210: PPUSH
89211: LD_VAR 0 13
89215: PPUSH
89216: CALL_OW 115
// end else
89220: GO 89323
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
89222: LD_VAR 0 13
89226: PPUSH
89227: LD_EXP 48
89231: PUSH
89232: LD_VAR 0 1
89236: ARRAY
89237: PPUSH
89238: CALL_OW 308
89242: NOT
89243: PUSH
89244: LD_VAR 0 4
89248: PPUSH
89249: LD_VAR 0 13
89253: PPUSH
89254: CALL_OW 296
89258: PUSH
89259: LD_INT 40
89261: GREATEREQUAL
89262: AND
89263: PUSH
89264: LD_VAR 0 4
89268: PPUSH
89269: CALL_OW 256
89273: PUSH
89274: LD_INT 650
89276: LESSEQUAL
89277: OR
89278: PUSH
89279: LD_VAR 0 4
89283: PPUSH
89284: LD_EXP 47
89288: PUSH
89289: LD_VAR 0 1
89293: ARRAY
89294: PPUSH
89295: CALL_OW 308
89299: NOT
89300: AND
89301: IFFALSE 89323
// ComMoveToArea ( i , mc_parking [ base ] ) ;
89303: LD_VAR 0 4
89307: PPUSH
89308: LD_EXP 47
89312: PUSH
89313: LD_VAR 0 1
89317: ARRAY
89318: PPUSH
89319: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
89323: LD_VAR 0 4
89327: PPUSH
89328: CALL_OW 256
89332: PUSH
89333: LD_INT 1000
89335: LESS
89336: PUSH
89337: LD_VAR 0 4
89341: PPUSH
89342: CALL_OW 263
89346: PUSH
89347: LD_INT 1
89349: EQUAL
89350: AND
89351: PUSH
89352: LD_VAR 0 4
89356: PPUSH
89357: CALL_OW 311
89361: AND
89362: PUSH
89363: LD_VAR 0 4
89367: PPUSH
89368: LD_EXP 47
89372: PUSH
89373: LD_VAR 0 1
89377: ARRAY
89378: PPUSH
89379: CALL_OW 308
89383: AND
89384: IFFALSE 89438
// begin mech := IsDrivenBy ( i ) ;
89386: LD_ADDR_VAR 0 9
89390: PUSH
89391: LD_VAR 0 4
89395: PPUSH
89396: CALL_OW 311
89400: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
89401: LD_VAR 0 9
89405: PPUSH
89406: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
89410: LD_VAR 0 9
89414: PPUSH
89415: LD_VAR 0 4
89419: PPUSH
89420: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
89424: LD_VAR 0 9
89428: PPUSH
89429: LD_VAR 0 4
89433: PPUSH
89434: CALL_OW 180
// end ; end ; unit_human :
89438: GO 89785
89440: LD_INT 1
89442: DOUBLE
89443: EQUAL
89444: IFTRUE 89448
89446: GO 89784
89448: POP
// begin b := IsInUnit ( i ) ;
89449: LD_ADDR_VAR 0 18
89453: PUSH
89454: LD_VAR 0 4
89458: PPUSH
89459: CALL_OW 310
89463: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
89464: LD_ADDR_VAR 0 19
89468: PUSH
89469: LD_VAR 0 18
89473: NOT
89474: PUSH
89475: LD_VAR 0 18
89479: PPUSH
89480: CALL_OW 266
89484: PUSH
89485: LD_INT 32
89487: PUSH
89488: LD_INT 31
89490: PUSH
89491: EMPTY
89492: LIST
89493: LIST
89494: IN
89495: OR
89496: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
89497: LD_VAR 0 18
89501: PPUSH
89502: CALL_OW 266
89506: PUSH
89507: LD_INT 5
89509: EQUAL
89510: PUSH
89511: LD_VAR 0 4
89515: PPUSH
89516: CALL_OW 257
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: LD_INT 2
89526: PUSH
89527: LD_INT 3
89529: PUSH
89530: LD_INT 4
89532: PUSH
89533: EMPTY
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: IN
89539: AND
89540: IFFALSE 89577
// begin class := AllowSpecClass ( i ) ;
89542: LD_ADDR_VAR 0 20
89546: PUSH
89547: LD_VAR 0 4
89551: PPUSH
89552: CALL 12759 0 1
89556: ST_TO_ADDR
// if class then
89557: LD_VAR 0 20
89561: IFFALSE 89577
// ComChangeProfession ( i , class ) ;
89563: LD_VAR 0 4
89567: PPUSH
89568: LD_VAR 0 20
89572: PPUSH
89573: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
89577: LD_VAR 0 16
89581: PUSH
89582: LD_VAR 0 2
89586: PPUSH
89587: LD_INT 21
89589: PUSH
89590: LD_INT 2
89592: PUSH
89593: EMPTY
89594: LIST
89595: LIST
89596: PPUSH
89597: CALL_OW 72
89601: PUSH
89602: LD_INT 1
89604: LESSEQUAL
89605: OR
89606: PUSH
89607: LD_VAR 0 19
89611: AND
89612: PUSH
89613: LD_VAR 0 4
89617: PUSH
89618: LD_VAR 0 17
89622: IN
89623: NOT
89624: AND
89625: IFFALSE 89718
// begin if b then
89627: LD_VAR 0 18
89631: IFFALSE 89680
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
89633: LD_VAR 0 18
89637: PPUSH
89638: LD_VAR 0 21
89642: PPUSH
89643: LD_VAR 0 18
89647: PPUSH
89648: CALL_OW 74
89652: PPUSH
89653: CALL_OW 296
89657: PUSH
89658: LD_INT 10
89660: LESS
89661: PUSH
89662: LD_VAR 0 18
89666: PPUSH
89667: CALL_OW 461
89671: PUSH
89672: LD_INT 7
89674: NONEQUAL
89675: AND
89676: IFFALSE 89680
// continue ;
89678: GO 88915
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
89680: LD_ADDR_VAR 0 17
89684: PUSH
89685: LD_VAR 0 17
89689: PPUSH
89690: LD_VAR 0 17
89694: PUSH
89695: LD_INT 1
89697: PLUS
89698: PPUSH
89699: LD_VAR 0 4
89703: PPUSH
89704: CALL_OW 1
89708: ST_TO_ADDR
// ComExitBuilding ( i ) ;
89709: LD_VAR 0 4
89713: PPUSH
89714: CALL_OW 122
// end ; if sold_defenders then
89718: LD_VAR 0 17
89722: IFFALSE 89782
// if i in sold_defenders then
89724: LD_VAR 0 4
89728: PUSH
89729: LD_VAR 0 17
89733: IN
89734: IFFALSE 89782
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
89736: LD_VAR 0 4
89740: PPUSH
89741: CALL_OW 314
89745: NOT
89746: PUSH
89747: LD_VAR 0 4
89751: PPUSH
89752: LD_VAR 0 13
89756: PPUSH
89757: CALL_OW 296
89761: PUSH
89762: LD_INT 30
89764: LESS
89765: AND
89766: IFFALSE 89782
// ComAttackUnit ( i , e ) ;
89768: LD_VAR 0 4
89772: PPUSH
89773: LD_VAR 0 13
89777: PPUSH
89778: CALL_OW 115
// end ; end ; end ;
89782: GO 89785
89784: POP
// if IsDead ( i ) then
89785: LD_VAR 0 4
89789: PPUSH
89790: CALL_OW 301
89794: IFFALSE 89812
// defenders := defenders diff i ;
89796: LD_ADDR_VAR 0 2
89800: PUSH
89801: LD_VAR 0 2
89805: PUSH
89806: LD_VAR 0 4
89810: DIFF
89811: ST_TO_ADDR
// end ;
89812: GO 88915
89814: POP
89815: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
89816: LD_VAR 0 21
89820: NOT
89821: PUSH
89822: LD_VAR 0 2
89826: NOT
89827: OR
89828: PUSH
89829: LD_EXP 23
89833: PUSH
89834: LD_VAR 0 1
89838: ARRAY
89839: NOT
89840: OR
89841: IFFALSE 88819
// MC_Reset ( base , 18 ) ;
89843: LD_VAR 0 1
89847: PPUSH
89848: LD_INT 18
89850: PPUSH
89851: CALL 56555 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
89855: LD_ADDR_VAR 0 2
89859: PUSH
89860: LD_VAR 0 2
89864: PUSH
89865: LD_VAR 0 2
89869: PPUSH
89870: LD_INT 2
89872: PUSH
89873: LD_INT 25
89875: PUSH
89876: LD_INT 1
89878: PUSH
89879: EMPTY
89880: LIST
89881: LIST
89882: PUSH
89883: LD_INT 25
89885: PUSH
89886: LD_INT 5
89888: PUSH
89889: EMPTY
89890: LIST
89891: LIST
89892: PUSH
89893: LD_INT 25
89895: PUSH
89896: LD_INT 8
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 25
89905: PUSH
89906: LD_INT 9
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PUSH
89913: EMPTY
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: PPUSH
89920: CALL_OW 72
89924: DIFF
89925: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
89926: LD_VAR 0 21
89930: NOT
89931: PUSH
89932: LD_VAR 0 2
89936: PPUSH
89937: LD_INT 21
89939: PUSH
89940: LD_INT 2
89942: PUSH
89943: EMPTY
89944: LIST
89945: LIST
89946: PPUSH
89947: CALL_OW 72
89951: AND
89952: IFFALSE 90290
// begin tmp := FilterByTag ( defenders , 19 ) ;
89954: LD_ADDR_VAR 0 11
89958: PUSH
89959: LD_VAR 0 2
89963: PPUSH
89964: LD_INT 19
89966: PPUSH
89967: CALL 46022 0 2
89971: ST_TO_ADDR
// if tmp then
89972: LD_VAR 0 11
89976: IFFALSE 90046
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
89978: LD_ADDR_VAR 0 11
89982: PUSH
89983: LD_VAR 0 11
89987: PPUSH
89988: LD_INT 25
89990: PUSH
89991: LD_INT 3
89993: PUSH
89994: EMPTY
89995: LIST
89996: LIST
89997: PPUSH
89998: CALL_OW 72
90002: ST_TO_ADDR
// if tmp then
90003: LD_VAR 0 11
90007: IFFALSE 90046
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
90009: LD_ADDR_EXP 35
90013: PUSH
90014: LD_EXP 35
90018: PPUSH
90019: LD_VAR 0 1
90023: PPUSH
90024: LD_EXP 35
90028: PUSH
90029: LD_VAR 0 1
90033: ARRAY
90034: PUSH
90035: LD_VAR 0 11
90039: UNION
90040: PPUSH
90041: CALL_OW 1
90045: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
90046: LD_VAR 0 1
90050: PPUSH
90051: LD_INT 19
90053: PPUSH
90054: CALL 56555 0 2
// repeat wait ( 0 0$1 ) ;
90058: LD_INT 35
90060: PPUSH
90061: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90065: LD_EXP 23
90069: PUSH
90070: LD_VAR 0 1
90074: ARRAY
90075: NOT
90076: PUSH
90077: LD_EXP 23
90081: PUSH
90082: LD_VAR 0 1
90086: ARRAY
90087: PUSH
90088: EMPTY
90089: EQUAL
90090: OR
90091: IFFALSE 90128
// begin for i in defenders do
90093: LD_ADDR_VAR 0 4
90097: PUSH
90098: LD_VAR 0 2
90102: PUSH
90103: FOR_IN
90104: IFFALSE 90117
// ComStop ( i ) ;
90106: LD_VAR 0 4
90110: PPUSH
90111: CALL_OW 141
90115: GO 90103
90117: POP
90118: POP
// defenders := [ ] ;
90119: LD_ADDR_VAR 0 2
90123: PUSH
90124: EMPTY
90125: ST_TO_ADDR
// exit ;
90126: GO 90354
// end ; for i in defenders do
90128: LD_ADDR_VAR 0 4
90132: PUSH
90133: LD_VAR 0 2
90137: PUSH
90138: FOR_IN
90139: IFFALSE 90228
// begin if not IsInArea ( i , mc_parking [ base ] ) then
90141: LD_VAR 0 4
90145: PPUSH
90146: LD_EXP 47
90150: PUSH
90151: LD_VAR 0 1
90155: ARRAY
90156: PPUSH
90157: CALL_OW 308
90161: NOT
90162: IFFALSE 90186
// ComMoveToArea ( i , mc_parking [ base ] ) else
90164: LD_VAR 0 4
90168: PPUSH
90169: LD_EXP 47
90173: PUSH
90174: LD_VAR 0 1
90178: ARRAY
90179: PPUSH
90180: CALL_OW 113
90184: GO 90226
// if GetControl ( i ) = control_manual then
90186: LD_VAR 0 4
90190: PPUSH
90191: CALL_OW 263
90195: PUSH
90196: LD_INT 1
90198: EQUAL
90199: IFFALSE 90226
// if IsDrivenBy ( i ) then
90201: LD_VAR 0 4
90205: PPUSH
90206: CALL_OW 311
90210: IFFALSE 90226
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
90212: LD_VAR 0 4
90216: PPUSH
90217: CALL_OW 311
90221: PPUSH
90222: CALL_OW 121
// end ;
90226: GO 90138
90228: POP
90229: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
90230: LD_VAR 0 2
90234: PPUSH
90235: LD_INT 95
90237: PUSH
90238: LD_EXP 47
90242: PUSH
90243: LD_VAR 0 1
90247: ARRAY
90248: PUSH
90249: EMPTY
90250: LIST
90251: LIST
90252: PPUSH
90253: CALL_OW 72
90257: PUSH
90258: LD_VAR 0 2
90262: EQUAL
90263: PUSH
90264: LD_EXP 46
90268: PUSH
90269: LD_VAR 0 1
90273: ARRAY
90274: OR
90275: PUSH
90276: LD_EXP 23
90280: PUSH
90281: LD_VAR 0 1
90285: ARRAY
90286: NOT
90287: OR
90288: IFFALSE 90058
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
90290: LD_ADDR_EXP 45
90294: PUSH
90295: LD_EXP 45
90299: PPUSH
90300: LD_VAR 0 1
90304: PPUSH
90305: LD_VAR 0 2
90309: PPUSH
90310: LD_INT 21
90312: PUSH
90313: LD_INT 2
90315: PUSH
90316: EMPTY
90317: LIST
90318: LIST
90319: PPUSH
90320: CALL_OW 72
90324: PPUSH
90325: CALL_OW 1
90329: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
90330: LD_VAR 0 1
90334: PPUSH
90335: LD_INT 19
90337: PPUSH
90338: CALL 56555 0 2
// MC_Reset ( base , 20 ) ;
90342: LD_VAR 0 1
90346: PPUSH
90347: LD_INT 20
90349: PPUSH
90350: CALL 56555 0 2
// end ; end_of_file
90354: LD_VAR 0 3
90358: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
90359: LD_INT 0
90361: PPUSH
90362: PPUSH
90363: PPUSH
90364: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
90365: LD_VAR 0 1
90369: PPUSH
90370: CALL_OW 264
90374: PUSH
90375: LD_INT 91
90377: EQUAL
90378: IFFALSE 90450
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
90380: LD_INT 68
90382: PPUSH
90383: LD_VAR 0 1
90387: PPUSH
90388: CALL_OW 255
90392: PPUSH
90393: CALL_OW 321
90397: PUSH
90398: LD_INT 2
90400: EQUAL
90401: IFFALSE 90413
// eff := 70 else
90403: LD_ADDR_VAR 0 4
90407: PUSH
90408: LD_INT 70
90410: ST_TO_ADDR
90411: GO 90421
// eff := 30 ;
90413: LD_ADDR_VAR 0 4
90417: PUSH
90418: LD_INT 30
90420: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
90421: LD_VAR 0 1
90425: PPUSH
90426: CALL_OW 250
90430: PPUSH
90431: LD_VAR 0 1
90435: PPUSH
90436: CALL_OW 251
90440: PPUSH
90441: LD_VAR 0 4
90445: PPUSH
90446: CALL_OW 495
// end ; end ;
90450: LD_VAR 0 2
90454: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
90455: LD_INT 0
90457: PPUSH
// end ;
90458: LD_VAR 0 4
90462: RET
// export function SOS_Command ( cmd ) ; begin
90463: LD_INT 0
90465: PPUSH
// end ;
90466: LD_VAR 0 2
90470: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
90471: LD_INT 0
90473: PPUSH
// end ;
90474: LD_VAR 0 6
90478: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
90479: LD_INT 0
90481: PPUSH
90482: PPUSH
// if not vehicle or not factory then
90483: LD_VAR 0 1
90487: NOT
90488: PUSH
90489: LD_VAR 0 2
90493: NOT
90494: OR
90495: IFFALSE 90499
// exit ;
90497: GO 90730
// if factoryWaypoints >= factory then
90499: LD_EXP 136
90503: PUSH
90504: LD_VAR 0 2
90508: GREATEREQUAL
90509: IFFALSE 90730
// if factoryWaypoints [ factory ] then
90511: LD_EXP 136
90515: PUSH
90516: LD_VAR 0 2
90520: ARRAY
90521: IFFALSE 90730
// begin if GetControl ( vehicle ) = control_manual then
90523: LD_VAR 0 1
90527: PPUSH
90528: CALL_OW 263
90532: PUSH
90533: LD_INT 1
90535: EQUAL
90536: IFFALSE 90617
// begin driver := IsDrivenBy ( vehicle ) ;
90538: LD_ADDR_VAR 0 4
90542: PUSH
90543: LD_VAR 0 1
90547: PPUSH
90548: CALL_OW 311
90552: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90553: LD_VAR 0 4
90557: PPUSH
90558: LD_EXP 136
90562: PUSH
90563: LD_VAR 0 2
90567: ARRAY
90568: PUSH
90569: LD_INT 3
90571: ARRAY
90572: PPUSH
90573: LD_EXP 136
90577: PUSH
90578: LD_VAR 0 2
90582: ARRAY
90583: PUSH
90584: LD_INT 4
90586: ARRAY
90587: PPUSH
90588: CALL_OW 171
// AddComExitVehicle ( driver ) ;
90592: LD_VAR 0 4
90596: PPUSH
90597: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
90601: LD_VAR 0 4
90605: PPUSH
90606: LD_VAR 0 2
90610: PPUSH
90611: CALL_OW 180
// end else
90615: GO 90730
// if GetControl ( vehicle ) = control_remote then
90617: LD_VAR 0 1
90621: PPUSH
90622: CALL_OW 263
90626: PUSH
90627: LD_INT 2
90629: EQUAL
90630: IFFALSE 90691
// begin wait ( 0 0$2 ) ;
90632: LD_INT 70
90634: PPUSH
90635: CALL_OW 67
// if Connect ( vehicle ) then
90639: LD_VAR 0 1
90643: PPUSH
90644: CALL 19079 0 1
90648: IFFALSE 90689
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90650: LD_VAR 0 1
90654: PPUSH
90655: LD_EXP 136
90659: PUSH
90660: LD_VAR 0 2
90664: ARRAY
90665: PUSH
90666: LD_INT 3
90668: ARRAY
90669: PPUSH
90670: LD_EXP 136
90674: PUSH
90675: LD_VAR 0 2
90679: ARRAY
90680: PUSH
90681: LD_INT 4
90683: ARRAY
90684: PPUSH
90685: CALL_OW 171
// end else
90689: GO 90730
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
90691: LD_VAR 0 1
90695: PPUSH
90696: LD_EXP 136
90700: PUSH
90701: LD_VAR 0 2
90705: ARRAY
90706: PUSH
90707: LD_INT 3
90709: ARRAY
90710: PPUSH
90711: LD_EXP 136
90715: PUSH
90716: LD_VAR 0 2
90720: ARRAY
90721: PUSH
90722: LD_INT 4
90724: ARRAY
90725: PPUSH
90726: CALL_OW 171
// end ; end ;
90730: LD_VAR 0 3
90734: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
90735: LD_INT 0
90737: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
90738: LD_VAR 0 1
90742: PUSH
90743: LD_INT 250
90745: EQUAL
90746: PUSH
90747: LD_VAR 0 2
90751: PPUSH
90752: CALL_OW 264
90756: PUSH
90757: LD_INT 81
90759: EQUAL
90760: AND
90761: IFFALSE 90782
// MinerPlaceMine ( unit , x , y ) ;
90763: LD_VAR 0 2
90767: PPUSH
90768: LD_VAR 0 4
90772: PPUSH
90773: LD_VAR 0 5
90777: PPUSH
90778: CALL 93167 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
90782: LD_VAR 0 1
90786: PUSH
90787: LD_INT 251
90789: EQUAL
90790: PUSH
90791: LD_VAR 0 2
90795: PPUSH
90796: CALL_OW 264
90800: PUSH
90801: LD_INT 81
90803: EQUAL
90804: AND
90805: IFFALSE 90826
// MinerDetonateMine ( unit , x , y ) ;
90807: LD_VAR 0 2
90811: PPUSH
90812: LD_VAR 0 4
90816: PPUSH
90817: LD_VAR 0 5
90821: PPUSH
90822: CALL 93442 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
90826: LD_VAR 0 1
90830: PUSH
90831: LD_INT 252
90833: EQUAL
90834: PUSH
90835: LD_VAR 0 2
90839: PPUSH
90840: CALL_OW 264
90844: PUSH
90845: LD_INT 81
90847: EQUAL
90848: AND
90849: IFFALSE 90870
// MinerCreateMinefield ( unit , x , y ) ;
90851: LD_VAR 0 2
90855: PPUSH
90856: LD_VAR 0 4
90860: PPUSH
90861: LD_VAR 0 5
90865: PPUSH
90866: CALL 93859 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
90870: LD_VAR 0 1
90874: PUSH
90875: LD_INT 253
90877: EQUAL
90878: PUSH
90879: LD_VAR 0 2
90883: PPUSH
90884: CALL_OW 257
90888: PUSH
90889: LD_INT 5
90891: EQUAL
90892: AND
90893: IFFALSE 90914
// ComBinocular ( unit , x , y ) ;
90895: LD_VAR 0 2
90899: PPUSH
90900: LD_VAR 0 4
90904: PPUSH
90905: LD_VAR 0 5
90909: PPUSH
90910: CALL 94228 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
90914: LD_VAR 0 1
90918: PUSH
90919: LD_INT 254
90921: EQUAL
90922: PUSH
90923: LD_VAR 0 2
90927: PPUSH
90928: CALL_OW 264
90932: PUSH
90933: LD_INT 99
90935: EQUAL
90936: AND
90937: PUSH
90938: LD_VAR 0 3
90942: PPUSH
90943: CALL_OW 263
90947: PUSH
90948: LD_INT 3
90950: EQUAL
90951: AND
90952: IFFALSE 90968
// HackDestroyVehicle ( unit , selectedUnit ) ;
90954: LD_VAR 0 2
90958: PPUSH
90959: LD_VAR 0 3
90963: PPUSH
90964: CALL 92531 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
90968: LD_VAR 0 1
90972: PUSH
90973: LD_INT 255
90975: EQUAL
90976: PUSH
90977: LD_VAR 0 2
90981: PPUSH
90982: CALL_OW 264
90986: PUSH
90987: LD_INT 14
90989: PUSH
90990: LD_INT 53
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: IN
90997: AND
90998: PUSH
90999: LD_VAR 0 4
91003: PPUSH
91004: LD_VAR 0 5
91008: PPUSH
91009: CALL_OW 488
91013: AND
91014: IFFALSE 91038
// CutTreeXYR ( unit , x , y , 12 ) ;
91016: LD_VAR 0 2
91020: PPUSH
91021: LD_VAR 0 4
91025: PPUSH
91026: LD_VAR 0 5
91030: PPUSH
91031: LD_INT 12
91033: PPUSH
91034: CALL 91101 0 4
// if cmd = 256 then
91038: LD_VAR 0 1
91042: PUSH
91043: LD_INT 256
91045: EQUAL
91046: IFFALSE 91067
// SetFactoryWaypoint ( unit , x , y ) ;
91048: LD_VAR 0 2
91052: PPUSH
91053: LD_VAR 0 4
91057: PPUSH
91058: LD_VAR 0 5
91062: PPUSH
91063: CALL 109299 0 3
// if cmd = 257 then
91067: LD_VAR 0 1
91071: PUSH
91072: LD_INT 257
91074: EQUAL
91075: IFFALSE 91096
// SetWarehouseGatheringPoint ( unit , x , y ) ;
91077: LD_VAR 0 2
91081: PPUSH
91082: LD_VAR 0 4
91086: PPUSH
91087: LD_VAR 0 5
91091: PPUSH
91092: CALL 109661 0 3
// end ;
91096: LD_VAR 0 6
91100: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91101: LD_INT 0
91103: PPUSH
91104: PPUSH
91105: PPUSH
91106: PPUSH
91107: PPUSH
91108: PPUSH
91109: PPUSH
91110: PPUSH
91111: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91112: LD_VAR 0 1
91116: NOT
91117: PUSH
91118: LD_VAR 0 2
91122: PPUSH
91123: LD_VAR 0 3
91127: PPUSH
91128: CALL_OW 488
91132: NOT
91133: OR
91134: PUSH
91135: LD_VAR 0 4
91139: NOT
91140: OR
91141: IFFALSE 91145
// exit ;
91143: GO 91485
// list := [ ] ;
91145: LD_ADDR_VAR 0 13
91149: PUSH
91150: EMPTY
91151: ST_TO_ADDR
// if x - r < 0 then
91152: LD_VAR 0 2
91156: PUSH
91157: LD_VAR 0 4
91161: MINUS
91162: PUSH
91163: LD_INT 0
91165: LESS
91166: IFFALSE 91178
// min_x := 0 else
91168: LD_ADDR_VAR 0 7
91172: PUSH
91173: LD_INT 0
91175: ST_TO_ADDR
91176: GO 91194
// min_x := x - r ;
91178: LD_ADDR_VAR 0 7
91182: PUSH
91183: LD_VAR 0 2
91187: PUSH
91188: LD_VAR 0 4
91192: MINUS
91193: ST_TO_ADDR
// if y - r < 0 then
91194: LD_VAR 0 3
91198: PUSH
91199: LD_VAR 0 4
91203: MINUS
91204: PUSH
91205: LD_INT 0
91207: LESS
91208: IFFALSE 91220
// min_y := 0 else
91210: LD_ADDR_VAR 0 8
91214: PUSH
91215: LD_INT 0
91217: ST_TO_ADDR
91218: GO 91236
// min_y := y - r ;
91220: LD_ADDR_VAR 0 8
91224: PUSH
91225: LD_VAR 0 3
91229: PUSH
91230: LD_VAR 0 4
91234: MINUS
91235: ST_TO_ADDR
// max_x := x + r ;
91236: LD_ADDR_VAR 0 9
91240: PUSH
91241: LD_VAR 0 2
91245: PUSH
91246: LD_VAR 0 4
91250: PLUS
91251: ST_TO_ADDR
// max_y := y + r ;
91252: LD_ADDR_VAR 0 10
91256: PUSH
91257: LD_VAR 0 3
91261: PUSH
91262: LD_VAR 0 4
91266: PLUS
91267: ST_TO_ADDR
// for _x = min_x to max_x do
91268: LD_ADDR_VAR 0 11
91272: PUSH
91273: DOUBLE
91274: LD_VAR 0 7
91278: DEC
91279: ST_TO_ADDR
91280: LD_VAR 0 9
91284: PUSH
91285: FOR_TO
91286: IFFALSE 91403
// for _y = min_y to max_y do
91288: LD_ADDR_VAR 0 12
91292: PUSH
91293: DOUBLE
91294: LD_VAR 0 8
91298: DEC
91299: ST_TO_ADDR
91300: LD_VAR 0 10
91304: PUSH
91305: FOR_TO
91306: IFFALSE 91399
// begin if not ValidHex ( _x , _y ) then
91308: LD_VAR 0 11
91312: PPUSH
91313: LD_VAR 0 12
91317: PPUSH
91318: CALL_OW 488
91322: NOT
91323: IFFALSE 91327
// continue ;
91325: GO 91305
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
91327: LD_VAR 0 11
91331: PPUSH
91332: LD_VAR 0 12
91336: PPUSH
91337: CALL_OW 351
91341: PUSH
91342: LD_VAR 0 11
91346: PPUSH
91347: LD_VAR 0 12
91351: PPUSH
91352: CALL_OW 554
91356: AND
91357: IFFALSE 91397
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
91359: LD_ADDR_VAR 0 13
91363: PUSH
91364: LD_VAR 0 13
91368: PPUSH
91369: LD_VAR 0 13
91373: PUSH
91374: LD_INT 1
91376: PLUS
91377: PPUSH
91378: LD_VAR 0 11
91382: PUSH
91383: LD_VAR 0 12
91387: PUSH
91388: EMPTY
91389: LIST
91390: LIST
91391: PPUSH
91392: CALL_OW 2
91396: ST_TO_ADDR
// end ;
91397: GO 91305
91399: POP
91400: POP
91401: GO 91285
91403: POP
91404: POP
// if not list then
91405: LD_VAR 0 13
91409: NOT
91410: IFFALSE 91414
// exit ;
91412: GO 91485
// for i in list do
91414: LD_ADDR_VAR 0 6
91418: PUSH
91419: LD_VAR 0 13
91423: PUSH
91424: FOR_IN
91425: IFFALSE 91483
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
91427: LD_VAR 0 1
91431: PPUSH
91432: LD_STRING M
91434: PUSH
91435: LD_VAR 0 6
91439: PUSH
91440: LD_INT 1
91442: ARRAY
91443: PUSH
91444: LD_VAR 0 6
91448: PUSH
91449: LD_INT 2
91451: ARRAY
91452: PUSH
91453: LD_INT 0
91455: PUSH
91456: LD_INT 0
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: LD_INT 0
91464: PUSH
91465: EMPTY
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: PUSH
91474: EMPTY
91475: LIST
91476: PPUSH
91477: CALL_OW 447
91481: GO 91424
91483: POP
91484: POP
// end ;
91485: LD_VAR 0 5
91489: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
91490: LD_EXP 67
91494: NOT
91495: IFFALSE 91545
91497: GO 91499
91499: DISABLE
// begin initHack := true ;
91500: LD_ADDR_EXP 67
91504: PUSH
91505: LD_INT 1
91507: ST_TO_ADDR
// hackTanks := [ ] ;
91508: LD_ADDR_EXP 68
91512: PUSH
91513: EMPTY
91514: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
91515: LD_ADDR_EXP 69
91519: PUSH
91520: EMPTY
91521: ST_TO_ADDR
// hackLimit := 3 ;
91522: LD_ADDR_EXP 70
91526: PUSH
91527: LD_INT 3
91529: ST_TO_ADDR
// hackDist := 12 ;
91530: LD_ADDR_EXP 71
91534: PUSH
91535: LD_INT 12
91537: ST_TO_ADDR
// hackCounter := [ ] ;
91538: LD_ADDR_EXP 72
91542: PUSH
91543: EMPTY
91544: ST_TO_ADDR
// end ;
91545: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
91546: LD_EXP 67
91550: PUSH
91551: LD_INT 34
91553: PUSH
91554: LD_INT 99
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PPUSH
91561: CALL_OW 69
91565: AND
91566: IFFALSE 91819
91568: GO 91570
91570: DISABLE
91571: LD_INT 0
91573: PPUSH
91574: PPUSH
// begin enable ;
91575: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
91576: LD_ADDR_VAR 0 1
91580: PUSH
91581: LD_INT 34
91583: PUSH
91584: LD_INT 99
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PPUSH
91591: CALL_OW 69
91595: PUSH
91596: FOR_IN
91597: IFFALSE 91817
// begin if not i in hackTanks then
91599: LD_VAR 0 1
91603: PUSH
91604: LD_EXP 68
91608: IN
91609: NOT
91610: IFFALSE 91693
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
91612: LD_ADDR_EXP 68
91616: PUSH
91617: LD_EXP 68
91621: PPUSH
91622: LD_EXP 68
91626: PUSH
91627: LD_INT 1
91629: PLUS
91630: PPUSH
91631: LD_VAR 0 1
91635: PPUSH
91636: CALL_OW 1
91640: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
91641: LD_ADDR_EXP 69
91645: PUSH
91646: LD_EXP 69
91650: PPUSH
91651: LD_EXP 69
91655: PUSH
91656: LD_INT 1
91658: PLUS
91659: PPUSH
91660: EMPTY
91661: PPUSH
91662: CALL_OW 1
91666: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
91667: LD_ADDR_EXP 72
91671: PUSH
91672: LD_EXP 72
91676: PPUSH
91677: LD_EXP 72
91681: PUSH
91682: LD_INT 1
91684: PLUS
91685: PPUSH
91686: EMPTY
91687: PPUSH
91688: CALL_OW 1
91692: ST_TO_ADDR
// end ; if not IsOk ( i ) then
91693: LD_VAR 0 1
91697: PPUSH
91698: CALL_OW 302
91702: NOT
91703: IFFALSE 91716
// begin HackUnlinkAll ( i ) ;
91705: LD_VAR 0 1
91709: PPUSH
91710: CALL 91822 0 1
// continue ;
91714: GO 91596
// end ; HackCheckCapturedStatus ( i ) ;
91716: LD_VAR 0 1
91720: PPUSH
91721: CALL 92265 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
91725: LD_ADDR_VAR 0 2
91729: PUSH
91730: LD_INT 81
91732: PUSH
91733: LD_VAR 0 1
91737: PPUSH
91738: CALL_OW 255
91742: PUSH
91743: EMPTY
91744: LIST
91745: LIST
91746: PUSH
91747: LD_INT 33
91749: PUSH
91750: LD_INT 3
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PUSH
91757: LD_INT 91
91759: PUSH
91760: LD_VAR 0 1
91764: PUSH
91765: LD_EXP 71
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 50
91777: PUSH
91778: EMPTY
91779: LIST
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: PPUSH
91787: CALL_OW 69
91791: ST_TO_ADDR
// if not tmp then
91792: LD_VAR 0 2
91796: NOT
91797: IFFALSE 91801
// continue ;
91799: GO 91596
// HackLink ( i , tmp ) ;
91801: LD_VAR 0 1
91805: PPUSH
91806: LD_VAR 0 2
91810: PPUSH
91811: CALL 91958 0 2
// end ;
91815: GO 91596
91817: POP
91818: POP
// end ;
91819: PPOPN 2
91821: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
91822: LD_INT 0
91824: PPUSH
91825: PPUSH
91826: PPUSH
// if not hack in hackTanks then
91827: LD_VAR 0 1
91831: PUSH
91832: LD_EXP 68
91836: IN
91837: NOT
91838: IFFALSE 91842
// exit ;
91840: GO 91953
// index := GetElementIndex ( hackTanks , hack ) ;
91842: LD_ADDR_VAR 0 4
91846: PUSH
91847: LD_EXP 68
91851: PPUSH
91852: LD_VAR 0 1
91856: PPUSH
91857: CALL 15895 0 2
91861: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
91862: LD_EXP 69
91866: PUSH
91867: LD_VAR 0 4
91871: ARRAY
91872: IFFALSE 91953
// begin for i in hackTanksCaptured [ index ] do
91874: LD_ADDR_VAR 0 3
91878: PUSH
91879: LD_EXP 69
91883: PUSH
91884: LD_VAR 0 4
91888: ARRAY
91889: PUSH
91890: FOR_IN
91891: IFFALSE 91917
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
91893: LD_VAR 0 3
91897: PUSH
91898: LD_INT 1
91900: ARRAY
91901: PPUSH
91902: LD_VAR 0 3
91906: PUSH
91907: LD_INT 2
91909: ARRAY
91910: PPUSH
91911: CALL_OW 235
91915: GO 91890
91917: POP
91918: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
91919: LD_ADDR_EXP 69
91923: PUSH
91924: LD_EXP 69
91928: PPUSH
91929: LD_VAR 0 4
91933: PPUSH
91934: EMPTY
91935: PPUSH
91936: CALL_OW 1
91940: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
91941: LD_VAR 0 1
91945: PPUSH
91946: LD_INT 0
91948: PPUSH
91949: CALL_OW 505
// end ; end ;
91953: LD_VAR 0 2
91957: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
91958: LD_INT 0
91960: PPUSH
91961: PPUSH
91962: PPUSH
// if not hack in hackTanks or not vehicles then
91963: LD_VAR 0 1
91967: PUSH
91968: LD_EXP 68
91972: IN
91973: NOT
91974: PUSH
91975: LD_VAR 0 2
91979: NOT
91980: OR
91981: IFFALSE 91985
// exit ;
91983: GO 92260
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
91985: LD_ADDR_VAR 0 2
91989: PUSH
91990: LD_VAR 0 1
91994: PPUSH
91995: LD_VAR 0 2
91999: PPUSH
92000: LD_INT 1
92002: PPUSH
92003: LD_INT 1
92005: PPUSH
92006: CALL 16545 0 4
92010: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
92011: LD_ADDR_VAR 0 5
92015: PUSH
92016: LD_EXP 68
92020: PPUSH
92021: LD_VAR 0 1
92025: PPUSH
92026: CALL 15895 0 2
92030: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
92031: LD_EXP 69
92035: PUSH
92036: LD_VAR 0 5
92040: ARRAY
92041: PUSH
92042: LD_EXP 70
92046: LESS
92047: IFFALSE 92236
// begin for i := 1 to vehicles do
92049: LD_ADDR_VAR 0 4
92053: PUSH
92054: DOUBLE
92055: LD_INT 1
92057: DEC
92058: ST_TO_ADDR
92059: LD_VAR 0 2
92063: PUSH
92064: FOR_TO
92065: IFFALSE 92234
// begin if hackTanksCaptured [ index ] = hackLimit then
92067: LD_EXP 69
92071: PUSH
92072: LD_VAR 0 5
92076: ARRAY
92077: PUSH
92078: LD_EXP 70
92082: EQUAL
92083: IFFALSE 92087
// break ;
92085: GO 92234
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
92087: LD_ADDR_EXP 72
92091: PUSH
92092: LD_EXP 72
92096: PPUSH
92097: LD_VAR 0 5
92101: PPUSH
92102: LD_EXP 72
92106: PUSH
92107: LD_VAR 0 5
92111: ARRAY
92112: PUSH
92113: LD_INT 1
92115: PLUS
92116: PPUSH
92117: CALL_OW 1
92121: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
92122: LD_ADDR_EXP 69
92126: PUSH
92127: LD_EXP 69
92131: PPUSH
92132: LD_VAR 0 5
92136: PUSH
92137: LD_EXP 69
92141: PUSH
92142: LD_VAR 0 5
92146: ARRAY
92147: PUSH
92148: LD_INT 1
92150: PLUS
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: PPUSH
92156: LD_VAR 0 2
92160: PUSH
92161: LD_VAR 0 4
92165: ARRAY
92166: PUSH
92167: LD_VAR 0 2
92171: PUSH
92172: LD_VAR 0 4
92176: ARRAY
92177: PPUSH
92178: CALL_OW 255
92182: PUSH
92183: EMPTY
92184: LIST
92185: LIST
92186: PPUSH
92187: CALL 16110 0 3
92191: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
92192: LD_VAR 0 2
92196: PUSH
92197: LD_VAR 0 4
92201: ARRAY
92202: PPUSH
92203: LD_VAR 0 1
92207: PPUSH
92208: CALL_OW 255
92212: PPUSH
92213: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
92217: LD_VAR 0 2
92221: PUSH
92222: LD_VAR 0 4
92226: ARRAY
92227: PPUSH
92228: CALL_OW 141
// end ;
92232: GO 92064
92234: POP
92235: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92236: LD_VAR 0 1
92240: PPUSH
92241: LD_EXP 69
92245: PUSH
92246: LD_VAR 0 5
92250: ARRAY
92251: PUSH
92252: LD_INT 0
92254: PLUS
92255: PPUSH
92256: CALL_OW 505
// end ;
92260: LD_VAR 0 3
92264: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
92265: LD_INT 0
92267: PPUSH
92268: PPUSH
92269: PPUSH
92270: PPUSH
// if not hack in hackTanks then
92271: LD_VAR 0 1
92275: PUSH
92276: LD_EXP 68
92280: IN
92281: NOT
92282: IFFALSE 92286
// exit ;
92284: GO 92526
// index := GetElementIndex ( hackTanks , hack ) ;
92286: LD_ADDR_VAR 0 4
92290: PUSH
92291: LD_EXP 68
92295: PPUSH
92296: LD_VAR 0 1
92300: PPUSH
92301: CALL 15895 0 2
92305: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
92306: LD_ADDR_VAR 0 3
92310: PUSH
92311: DOUBLE
92312: LD_EXP 69
92316: PUSH
92317: LD_VAR 0 4
92321: ARRAY
92322: INC
92323: ST_TO_ADDR
92324: LD_INT 1
92326: PUSH
92327: FOR_DOWNTO
92328: IFFALSE 92500
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
92330: LD_ADDR_VAR 0 5
92334: PUSH
92335: LD_EXP 69
92339: PUSH
92340: LD_VAR 0 4
92344: ARRAY
92345: PUSH
92346: LD_VAR 0 3
92350: ARRAY
92351: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
92352: LD_VAR 0 5
92356: PUSH
92357: LD_INT 1
92359: ARRAY
92360: PPUSH
92361: CALL_OW 302
92365: NOT
92366: PUSH
92367: LD_VAR 0 5
92371: PUSH
92372: LD_INT 1
92374: ARRAY
92375: PPUSH
92376: CALL_OW 255
92380: PUSH
92381: LD_VAR 0 1
92385: PPUSH
92386: CALL_OW 255
92390: NONEQUAL
92391: OR
92392: IFFALSE 92498
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
92394: LD_VAR 0 5
92398: PUSH
92399: LD_INT 1
92401: ARRAY
92402: PPUSH
92403: CALL_OW 305
92407: PUSH
92408: LD_VAR 0 5
92412: PUSH
92413: LD_INT 1
92415: ARRAY
92416: PPUSH
92417: CALL_OW 255
92421: PUSH
92422: LD_VAR 0 1
92426: PPUSH
92427: CALL_OW 255
92431: EQUAL
92432: AND
92433: IFFALSE 92457
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
92435: LD_VAR 0 5
92439: PUSH
92440: LD_INT 1
92442: ARRAY
92443: PPUSH
92444: LD_VAR 0 5
92448: PUSH
92449: LD_INT 2
92451: ARRAY
92452: PPUSH
92453: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
92457: LD_ADDR_EXP 69
92461: PUSH
92462: LD_EXP 69
92466: PPUSH
92467: LD_VAR 0 4
92471: PPUSH
92472: LD_EXP 69
92476: PUSH
92477: LD_VAR 0 4
92481: ARRAY
92482: PPUSH
92483: LD_VAR 0 3
92487: PPUSH
92488: CALL_OW 3
92492: PPUSH
92493: CALL_OW 1
92497: ST_TO_ADDR
// end ; end ;
92498: GO 92327
92500: POP
92501: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
92502: LD_VAR 0 1
92506: PPUSH
92507: LD_EXP 69
92511: PUSH
92512: LD_VAR 0 4
92516: ARRAY
92517: PUSH
92518: LD_INT 0
92520: PLUS
92521: PPUSH
92522: CALL_OW 505
// end ;
92526: LD_VAR 0 2
92530: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
92531: LD_INT 0
92533: PPUSH
92534: PPUSH
92535: PPUSH
92536: PPUSH
// if not hack in hackTanks then
92537: LD_VAR 0 1
92541: PUSH
92542: LD_EXP 68
92546: IN
92547: NOT
92548: IFFALSE 92552
// exit ;
92550: GO 92637
// index := GetElementIndex ( hackTanks , hack ) ;
92552: LD_ADDR_VAR 0 5
92556: PUSH
92557: LD_EXP 68
92561: PPUSH
92562: LD_VAR 0 1
92566: PPUSH
92567: CALL 15895 0 2
92571: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
92572: LD_ADDR_VAR 0 4
92576: PUSH
92577: DOUBLE
92578: LD_INT 1
92580: DEC
92581: ST_TO_ADDR
92582: LD_EXP 69
92586: PUSH
92587: LD_VAR 0 5
92591: ARRAY
92592: PUSH
92593: FOR_TO
92594: IFFALSE 92635
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
92596: LD_EXP 69
92600: PUSH
92601: LD_VAR 0 5
92605: ARRAY
92606: PUSH
92607: LD_VAR 0 4
92611: ARRAY
92612: PUSH
92613: LD_INT 1
92615: ARRAY
92616: PUSH
92617: LD_VAR 0 2
92621: EQUAL
92622: IFFALSE 92633
// KillUnit ( vehicle ) ;
92624: LD_VAR 0 2
92628: PPUSH
92629: CALL_OW 66
92633: GO 92593
92635: POP
92636: POP
// end ;
92637: LD_VAR 0 3
92641: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
92642: LD_EXP 73
92646: NOT
92647: IFFALSE 92682
92649: GO 92651
92651: DISABLE
// begin initMiner := true ;
92652: LD_ADDR_EXP 73
92656: PUSH
92657: LD_INT 1
92659: ST_TO_ADDR
// minersList := [ ] ;
92660: LD_ADDR_EXP 74
92664: PUSH
92665: EMPTY
92666: ST_TO_ADDR
// minerMinesList := [ ] ;
92667: LD_ADDR_EXP 75
92671: PUSH
92672: EMPTY
92673: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
92674: LD_ADDR_EXP 76
92678: PUSH
92679: LD_INT 5
92681: ST_TO_ADDR
// end ;
92682: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
92683: LD_EXP 73
92687: PUSH
92688: LD_INT 34
92690: PUSH
92691: LD_INT 81
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PPUSH
92698: CALL_OW 69
92702: AND
92703: IFFALSE 93164
92705: GO 92707
92707: DISABLE
92708: LD_INT 0
92710: PPUSH
92711: PPUSH
92712: PPUSH
92713: PPUSH
// begin enable ;
92714: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
92715: LD_ADDR_VAR 0 1
92719: PUSH
92720: LD_INT 34
92722: PUSH
92723: LD_INT 81
92725: PUSH
92726: EMPTY
92727: LIST
92728: LIST
92729: PPUSH
92730: CALL_OW 69
92734: PUSH
92735: FOR_IN
92736: IFFALSE 92808
// begin if not i in minersList then
92738: LD_VAR 0 1
92742: PUSH
92743: LD_EXP 74
92747: IN
92748: NOT
92749: IFFALSE 92806
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
92751: LD_ADDR_EXP 74
92755: PUSH
92756: LD_EXP 74
92760: PPUSH
92761: LD_EXP 74
92765: PUSH
92766: LD_INT 1
92768: PLUS
92769: PPUSH
92770: LD_VAR 0 1
92774: PPUSH
92775: CALL_OW 1
92779: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
92780: LD_ADDR_EXP 75
92784: PUSH
92785: LD_EXP 75
92789: PPUSH
92790: LD_EXP 75
92794: PUSH
92795: LD_INT 1
92797: PLUS
92798: PPUSH
92799: EMPTY
92800: PPUSH
92801: CALL_OW 1
92805: ST_TO_ADDR
// end end ;
92806: GO 92735
92808: POP
92809: POP
// for i := minerMinesList downto 1 do
92810: LD_ADDR_VAR 0 1
92814: PUSH
92815: DOUBLE
92816: LD_EXP 75
92820: INC
92821: ST_TO_ADDR
92822: LD_INT 1
92824: PUSH
92825: FOR_DOWNTO
92826: IFFALSE 93162
// begin if IsLive ( minersList [ i ] ) then
92828: LD_EXP 74
92832: PUSH
92833: LD_VAR 0 1
92837: ARRAY
92838: PPUSH
92839: CALL_OW 300
92843: IFFALSE 92871
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
92845: LD_EXP 74
92849: PUSH
92850: LD_VAR 0 1
92854: ARRAY
92855: PPUSH
92856: LD_EXP 75
92860: PUSH
92861: LD_VAR 0 1
92865: ARRAY
92866: PPUSH
92867: CALL_OW 505
// if not minerMinesList [ i ] then
92871: LD_EXP 75
92875: PUSH
92876: LD_VAR 0 1
92880: ARRAY
92881: NOT
92882: IFFALSE 92886
// continue ;
92884: GO 92825
// for j := minerMinesList [ i ] downto 1 do
92886: LD_ADDR_VAR 0 2
92890: PUSH
92891: DOUBLE
92892: LD_EXP 75
92896: PUSH
92897: LD_VAR 0 1
92901: ARRAY
92902: INC
92903: ST_TO_ADDR
92904: LD_INT 1
92906: PUSH
92907: FOR_DOWNTO
92908: IFFALSE 93158
// begin side := GetSide ( minersList [ i ] ) ;
92910: LD_ADDR_VAR 0 3
92914: PUSH
92915: LD_EXP 74
92919: PUSH
92920: LD_VAR 0 1
92924: ARRAY
92925: PPUSH
92926: CALL_OW 255
92930: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
92931: LD_ADDR_VAR 0 4
92935: PUSH
92936: LD_EXP 75
92940: PUSH
92941: LD_VAR 0 1
92945: ARRAY
92946: PUSH
92947: LD_VAR 0 2
92951: ARRAY
92952: PUSH
92953: LD_INT 1
92955: ARRAY
92956: PPUSH
92957: LD_EXP 75
92961: PUSH
92962: LD_VAR 0 1
92966: ARRAY
92967: PUSH
92968: LD_VAR 0 2
92972: ARRAY
92973: PUSH
92974: LD_INT 2
92976: ARRAY
92977: PPUSH
92978: CALL_OW 428
92982: ST_TO_ADDR
// if not tmp then
92983: LD_VAR 0 4
92987: NOT
92988: IFFALSE 92992
// continue ;
92990: GO 92907
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
92992: LD_VAR 0 4
92996: PUSH
92997: LD_INT 81
92999: PUSH
93000: LD_VAR 0 3
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PPUSH
93009: CALL_OW 69
93013: IN
93014: PUSH
93015: LD_EXP 75
93019: PUSH
93020: LD_VAR 0 1
93024: ARRAY
93025: PUSH
93026: LD_VAR 0 2
93030: ARRAY
93031: PUSH
93032: LD_INT 1
93034: ARRAY
93035: PPUSH
93036: LD_EXP 75
93040: PUSH
93041: LD_VAR 0 1
93045: ARRAY
93046: PUSH
93047: LD_VAR 0 2
93051: ARRAY
93052: PUSH
93053: LD_INT 2
93055: ARRAY
93056: PPUSH
93057: CALL_OW 458
93061: AND
93062: IFFALSE 93156
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
93064: LD_EXP 75
93068: PUSH
93069: LD_VAR 0 1
93073: ARRAY
93074: PUSH
93075: LD_VAR 0 2
93079: ARRAY
93080: PUSH
93081: LD_INT 1
93083: ARRAY
93084: PPUSH
93085: LD_EXP 75
93089: PUSH
93090: LD_VAR 0 1
93094: ARRAY
93095: PUSH
93096: LD_VAR 0 2
93100: ARRAY
93101: PUSH
93102: LD_INT 2
93104: ARRAY
93105: PPUSH
93106: LD_VAR 0 3
93110: PPUSH
93111: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
93115: LD_ADDR_EXP 75
93119: PUSH
93120: LD_EXP 75
93124: PPUSH
93125: LD_VAR 0 1
93129: PPUSH
93130: LD_EXP 75
93134: PUSH
93135: LD_VAR 0 1
93139: ARRAY
93140: PPUSH
93141: LD_VAR 0 2
93145: PPUSH
93146: CALL_OW 3
93150: PPUSH
93151: CALL_OW 1
93155: ST_TO_ADDR
// end ; end ;
93156: GO 92907
93158: POP
93159: POP
// end ;
93160: GO 92825
93162: POP
93163: POP
// end ;
93164: PPOPN 4
93166: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
93167: LD_INT 0
93169: PPUSH
93170: PPUSH
// result := false ;
93171: LD_ADDR_VAR 0 4
93175: PUSH
93176: LD_INT 0
93178: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
93179: LD_VAR 0 1
93183: PPUSH
93184: CALL_OW 264
93188: PUSH
93189: LD_INT 81
93191: EQUAL
93192: NOT
93193: IFFALSE 93197
// exit ;
93195: GO 93437
// index := GetElementIndex ( minersList , unit ) ;
93197: LD_ADDR_VAR 0 5
93201: PUSH
93202: LD_EXP 74
93206: PPUSH
93207: LD_VAR 0 1
93211: PPUSH
93212: CALL 15895 0 2
93216: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
93217: LD_EXP 75
93221: PUSH
93222: LD_VAR 0 5
93226: ARRAY
93227: PUSH
93228: LD_EXP 76
93232: GREATEREQUAL
93233: IFFALSE 93237
// exit ;
93235: GO 93437
// ComMoveXY ( unit , x , y ) ;
93237: LD_VAR 0 1
93241: PPUSH
93242: LD_VAR 0 2
93246: PPUSH
93247: LD_VAR 0 3
93251: PPUSH
93252: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
93256: LD_INT 35
93258: PPUSH
93259: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
93263: LD_VAR 0 1
93267: PPUSH
93268: LD_VAR 0 2
93272: PPUSH
93273: LD_VAR 0 3
93277: PPUSH
93278: CALL 47250 0 3
93282: NOT
93283: PUSH
93284: LD_VAR 0 1
93288: PPUSH
93289: CALL_OW 314
93293: AND
93294: IFFALSE 93298
// exit ;
93296: GO 93437
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
93298: LD_VAR 0 2
93302: PPUSH
93303: LD_VAR 0 3
93307: PPUSH
93308: CALL_OW 428
93312: PUSH
93313: LD_VAR 0 1
93317: EQUAL
93318: PUSH
93319: LD_VAR 0 1
93323: PPUSH
93324: CALL_OW 314
93328: NOT
93329: AND
93330: IFFALSE 93256
// PlaySoundXY ( x , y , PlantMine ) ;
93332: LD_VAR 0 2
93336: PPUSH
93337: LD_VAR 0 3
93341: PPUSH
93342: LD_STRING PlantMine
93344: PPUSH
93345: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
93349: LD_VAR 0 2
93353: PPUSH
93354: LD_VAR 0 3
93358: PPUSH
93359: LD_VAR 0 1
93363: PPUSH
93364: CALL_OW 255
93368: PPUSH
93369: LD_INT 0
93371: PPUSH
93372: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
93376: LD_ADDR_EXP 75
93380: PUSH
93381: LD_EXP 75
93385: PPUSH
93386: LD_VAR 0 5
93390: PUSH
93391: LD_EXP 75
93395: PUSH
93396: LD_VAR 0 5
93400: ARRAY
93401: PUSH
93402: LD_INT 1
93404: PLUS
93405: PUSH
93406: EMPTY
93407: LIST
93408: LIST
93409: PPUSH
93410: LD_VAR 0 2
93414: PUSH
93415: LD_VAR 0 3
93419: PUSH
93420: EMPTY
93421: LIST
93422: LIST
93423: PPUSH
93424: CALL 16110 0 3
93428: ST_TO_ADDR
// result := true ;
93429: LD_ADDR_VAR 0 4
93433: PUSH
93434: LD_INT 1
93436: ST_TO_ADDR
// end ;
93437: LD_VAR 0 4
93441: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
93442: LD_INT 0
93444: PPUSH
93445: PPUSH
93446: PPUSH
// if not unit in minersList then
93447: LD_VAR 0 1
93451: PUSH
93452: LD_EXP 74
93456: IN
93457: NOT
93458: IFFALSE 93462
// exit ;
93460: GO 93854
// index := GetElementIndex ( minersList , unit ) ;
93462: LD_ADDR_VAR 0 6
93466: PUSH
93467: LD_EXP 74
93471: PPUSH
93472: LD_VAR 0 1
93476: PPUSH
93477: CALL 15895 0 2
93481: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
93482: LD_ADDR_VAR 0 5
93486: PUSH
93487: DOUBLE
93488: LD_EXP 75
93492: PUSH
93493: LD_VAR 0 6
93497: ARRAY
93498: INC
93499: ST_TO_ADDR
93500: LD_INT 1
93502: PUSH
93503: FOR_DOWNTO
93504: IFFALSE 93665
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
93506: LD_EXP 75
93510: PUSH
93511: LD_VAR 0 6
93515: ARRAY
93516: PUSH
93517: LD_VAR 0 5
93521: ARRAY
93522: PUSH
93523: LD_INT 1
93525: ARRAY
93526: PUSH
93527: LD_VAR 0 2
93531: EQUAL
93532: PUSH
93533: LD_EXP 75
93537: PUSH
93538: LD_VAR 0 6
93542: ARRAY
93543: PUSH
93544: LD_VAR 0 5
93548: ARRAY
93549: PUSH
93550: LD_INT 2
93552: ARRAY
93553: PUSH
93554: LD_VAR 0 3
93558: EQUAL
93559: AND
93560: IFFALSE 93663
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93562: LD_EXP 75
93566: PUSH
93567: LD_VAR 0 6
93571: ARRAY
93572: PUSH
93573: LD_VAR 0 5
93577: ARRAY
93578: PUSH
93579: LD_INT 1
93581: ARRAY
93582: PPUSH
93583: LD_EXP 75
93587: PUSH
93588: LD_VAR 0 6
93592: ARRAY
93593: PUSH
93594: LD_VAR 0 5
93598: ARRAY
93599: PUSH
93600: LD_INT 2
93602: ARRAY
93603: PPUSH
93604: LD_VAR 0 1
93608: PPUSH
93609: CALL_OW 255
93613: PPUSH
93614: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93618: LD_ADDR_EXP 75
93622: PUSH
93623: LD_EXP 75
93627: PPUSH
93628: LD_VAR 0 6
93632: PPUSH
93633: LD_EXP 75
93637: PUSH
93638: LD_VAR 0 6
93642: ARRAY
93643: PPUSH
93644: LD_VAR 0 5
93648: PPUSH
93649: CALL_OW 3
93653: PPUSH
93654: CALL_OW 1
93658: ST_TO_ADDR
// exit ;
93659: POP
93660: POP
93661: GO 93854
// end ; end ;
93663: GO 93503
93665: POP
93666: POP
// for i := minerMinesList [ index ] downto 1 do
93667: LD_ADDR_VAR 0 5
93671: PUSH
93672: DOUBLE
93673: LD_EXP 75
93677: PUSH
93678: LD_VAR 0 6
93682: ARRAY
93683: INC
93684: ST_TO_ADDR
93685: LD_INT 1
93687: PUSH
93688: FOR_DOWNTO
93689: IFFALSE 93852
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
93691: LD_EXP 75
93695: PUSH
93696: LD_VAR 0 6
93700: ARRAY
93701: PUSH
93702: LD_VAR 0 5
93706: ARRAY
93707: PUSH
93708: LD_INT 1
93710: ARRAY
93711: PPUSH
93712: LD_EXP 75
93716: PUSH
93717: LD_VAR 0 6
93721: ARRAY
93722: PUSH
93723: LD_VAR 0 5
93727: ARRAY
93728: PUSH
93729: LD_INT 2
93731: ARRAY
93732: PPUSH
93733: LD_VAR 0 2
93737: PPUSH
93738: LD_VAR 0 3
93742: PPUSH
93743: CALL_OW 298
93747: PUSH
93748: LD_INT 6
93750: LESS
93751: IFFALSE 93850
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
93753: LD_EXP 75
93757: PUSH
93758: LD_VAR 0 6
93762: ARRAY
93763: PUSH
93764: LD_VAR 0 5
93768: ARRAY
93769: PUSH
93770: LD_INT 1
93772: ARRAY
93773: PPUSH
93774: LD_EXP 75
93778: PUSH
93779: LD_VAR 0 6
93783: ARRAY
93784: PUSH
93785: LD_VAR 0 5
93789: ARRAY
93790: PUSH
93791: LD_INT 2
93793: ARRAY
93794: PPUSH
93795: LD_VAR 0 1
93799: PPUSH
93800: CALL_OW 255
93804: PPUSH
93805: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
93809: LD_ADDR_EXP 75
93813: PUSH
93814: LD_EXP 75
93818: PPUSH
93819: LD_VAR 0 6
93823: PPUSH
93824: LD_EXP 75
93828: PUSH
93829: LD_VAR 0 6
93833: ARRAY
93834: PPUSH
93835: LD_VAR 0 5
93839: PPUSH
93840: CALL_OW 3
93844: PPUSH
93845: CALL_OW 1
93849: ST_TO_ADDR
// end ; end ;
93850: GO 93688
93852: POP
93853: POP
// end ;
93854: LD_VAR 0 4
93858: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
93859: LD_INT 0
93861: PPUSH
93862: PPUSH
93863: PPUSH
93864: PPUSH
93865: PPUSH
93866: PPUSH
93867: PPUSH
93868: PPUSH
93869: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
93870: LD_VAR 0 1
93874: PPUSH
93875: CALL_OW 264
93879: PUSH
93880: LD_INT 81
93882: EQUAL
93883: NOT
93884: PUSH
93885: LD_VAR 0 1
93889: PUSH
93890: LD_EXP 74
93894: IN
93895: NOT
93896: OR
93897: IFFALSE 93901
// exit ;
93899: GO 94223
// index := GetElementIndex ( minersList , unit ) ;
93901: LD_ADDR_VAR 0 6
93905: PUSH
93906: LD_EXP 74
93910: PPUSH
93911: LD_VAR 0 1
93915: PPUSH
93916: CALL 15895 0 2
93920: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
93921: LD_ADDR_VAR 0 8
93925: PUSH
93926: LD_EXP 76
93930: PUSH
93931: LD_EXP 75
93935: PUSH
93936: LD_VAR 0 6
93940: ARRAY
93941: MINUS
93942: ST_TO_ADDR
// if not minesFreeAmount then
93943: LD_VAR 0 8
93947: NOT
93948: IFFALSE 93952
// exit ;
93950: GO 94223
// tmp := [ ] ;
93952: LD_ADDR_VAR 0 7
93956: PUSH
93957: EMPTY
93958: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
93959: LD_ADDR_VAR 0 5
93963: PUSH
93964: DOUBLE
93965: LD_INT 1
93967: DEC
93968: ST_TO_ADDR
93969: LD_VAR 0 8
93973: PUSH
93974: FOR_TO
93975: IFFALSE 94170
// begin _d := rand ( 0 , 5 ) ;
93977: LD_ADDR_VAR 0 11
93981: PUSH
93982: LD_INT 0
93984: PPUSH
93985: LD_INT 5
93987: PPUSH
93988: CALL_OW 12
93992: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
93993: LD_ADDR_VAR 0 12
93997: PUSH
93998: LD_INT 2
94000: PPUSH
94001: LD_INT 6
94003: PPUSH
94004: CALL_OW 12
94008: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
94009: LD_ADDR_VAR 0 9
94013: PUSH
94014: LD_VAR 0 2
94018: PPUSH
94019: LD_VAR 0 11
94023: PPUSH
94024: LD_VAR 0 12
94028: PPUSH
94029: CALL_OW 272
94033: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
94034: LD_ADDR_VAR 0 10
94038: PUSH
94039: LD_VAR 0 3
94043: PPUSH
94044: LD_VAR 0 11
94048: PPUSH
94049: LD_VAR 0 12
94053: PPUSH
94054: CALL_OW 273
94058: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
94059: LD_VAR 0 9
94063: PPUSH
94064: LD_VAR 0 10
94068: PPUSH
94069: CALL_OW 488
94073: PUSH
94074: LD_VAR 0 9
94078: PUSH
94079: LD_VAR 0 10
94083: PUSH
94084: EMPTY
94085: LIST
94086: LIST
94087: PUSH
94088: LD_VAR 0 7
94092: IN
94093: NOT
94094: AND
94095: PUSH
94096: LD_VAR 0 9
94100: PPUSH
94101: LD_VAR 0 10
94105: PPUSH
94106: CALL_OW 458
94110: NOT
94111: AND
94112: IFFALSE 94154
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
94114: LD_ADDR_VAR 0 7
94118: PUSH
94119: LD_VAR 0 7
94123: PPUSH
94124: LD_VAR 0 7
94128: PUSH
94129: LD_INT 1
94131: PLUS
94132: PPUSH
94133: LD_VAR 0 9
94137: PUSH
94138: LD_VAR 0 10
94142: PUSH
94143: EMPTY
94144: LIST
94145: LIST
94146: PPUSH
94147: CALL_OW 1
94151: ST_TO_ADDR
94152: GO 94168
// i := i - 1 ;
94154: LD_ADDR_VAR 0 5
94158: PUSH
94159: LD_VAR 0 5
94163: PUSH
94164: LD_INT 1
94166: MINUS
94167: ST_TO_ADDR
// end ;
94168: GO 93974
94170: POP
94171: POP
// for i in tmp do
94172: LD_ADDR_VAR 0 5
94176: PUSH
94177: LD_VAR 0 7
94181: PUSH
94182: FOR_IN
94183: IFFALSE 94221
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
94185: LD_VAR 0 1
94189: PPUSH
94190: LD_VAR 0 5
94194: PUSH
94195: LD_INT 1
94197: ARRAY
94198: PPUSH
94199: LD_VAR 0 5
94203: PUSH
94204: LD_INT 2
94206: ARRAY
94207: PPUSH
94208: CALL 93167 0 3
94212: NOT
94213: IFFALSE 94219
// exit ;
94215: POP
94216: POP
94217: GO 94223
94219: GO 94182
94221: POP
94222: POP
// end ;
94223: LD_VAR 0 4
94227: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
94228: LD_INT 0
94230: PPUSH
94231: PPUSH
94232: PPUSH
94233: PPUSH
94234: PPUSH
94235: PPUSH
94236: PPUSH
// if not GetClass ( unit ) = class_sniper then
94237: LD_VAR 0 1
94241: PPUSH
94242: CALL_OW 257
94246: PUSH
94247: LD_INT 5
94249: EQUAL
94250: NOT
94251: IFFALSE 94255
// exit ;
94253: GO 94643
// dist := 8 ;
94255: LD_ADDR_VAR 0 5
94259: PUSH
94260: LD_INT 8
94262: ST_TO_ADDR
// viewRange := 12 ;
94263: LD_ADDR_VAR 0 7
94267: PUSH
94268: LD_INT 12
94270: ST_TO_ADDR
// side := GetSide ( unit ) ;
94271: LD_ADDR_VAR 0 6
94275: PUSH
94276: LD_VAR 0 1
94280: PPUSH
94281: CALL_OW 255
94285: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
94286: LD_INT 61
94288: PPUSH
94289: LD_VAR 0 6
94293: PPUSH
94294: CALL_OW 321
94298: PUSH
94299: LD_INT 2
94301: EQUAL
94302: IFFALSE 94312
// viewRange := 16 ;
94304: LD_ADDR_VAR 0 7
94308: PUSH
94309: LD_INT 16
94311: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
94312: LD_VAR 0 1
94316: PPUSH
94317: LD_VAR 0 2
94321: PPUSH
94322: LD_VAR 0 3
94326: PPUSH
94327: CALL_OW 297
94331: PUSH
94332: LD_VAR 0 5
94336: GREATER
94337: IFFALSE 94416
// begin ComMoveXY ( unit , x , y ) ;
94339: LD_VAR 0 1
94343: PPUSH
94344: LD_VAR 0 2
94348: PPUSH
94349: LD_VAR 0 3
94353: PPUSH
94354: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
94358: LD_INT 35
94360: PPUSH
94361: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
94365: LD_VAR 0 1
94369: PPUSH
94370: LD_VAR 0 2
94374: PPUSH
94375: LD_VAR 0 3
94379: PPUSH
94380: CALL 47250 0 3
94384: NOT
94385: IFFALSE 94389
// exit ;
94387: GO 94643
// until GetDistUnitXY ( unit , x , y ) < dist ;
94389: LD_VAR 0 1
94393: PPUSH
94394: LD_VAR 0 2
94398: PPUSH
94399: LD_VAR 0 3
94403: PPUSH
94404: CALL_OW 297
94408: PUSH
94409: LD_VAR 0 5
94413: LESS
94414: IFFALSE 94358
// end ; ComTurnXY ( unit , x , y ) ;
94416: LD_VAR 0 1
94420: PPUSH
94421: LD_VAR 0 2
94425: PPUSH
94426: LD_VAR 0 3
94430: PPUSH
94431: CALL_OW 118
// wait ( 5 ) ;
94435: LD_INT 5
94437: PPUSH
94438: CALL_OW 67
// _d := GetDir ( unit ) ;
94442: LD_ADDR_VAR 0 10
94446: PUSH
94447: LD_VAR 0 1
94451: PPUSH
94452: CALL_OW 254
94456: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
94457: LD_ADDR_VAR 0 8
94461: PUSH
94462: LD_VAR 0 1
94466: PPUSH
94467: CALL_OW 250
94471: PPUSH
94472: LD_VAR 0 10
94476: PPUSH
94477: LD_VAR 0 5
94481: PPUSH
94482: CALL_OW 272
94486: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
94487: LD_ADDR_VAR 0 9
94491: PUSH
94492: LD_VAR 0 1
94496: PPUSH
94497: CALL_OW 251
94501: PPUSH
94502: LD_VAR 0 10
94506: PPUSH
94507: LD_VAR 0 5
94511: PPUSH
94512: CALL_OW 273
94516: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
94517: LD_VAR 0 8
94521: PPUSH
94522: LD_VAR 0 9
94526: PPUSH
94527: CALL_OW 488
94531: NOT
94532: IFFALSE 94536
// exit ;
94534: GO 94643
// ComAnimCustom ( unit , 1 ) ;
94536: LD_VAR 0 1
94540: PPUSH
94541: LD_INT 1
94543: PPUSH
94544: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
94548: LD_VAR 0 8
94552: PPUSH
94553: LD_VAR 0 9
94557: PPUSH
94558: LD_VAR 0 6
94562: PPUSH
94563: LD_VAR 0 7
94567: PPUSH
94568: CALL_OW 330
// repeat wait ( 1 ) ;
94572: LD_INT 1
94574: PPUSH
94575: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
94579: LD_VAR 0 1
94583: PPUSH
94584: CALL_OW 316
94588: PUSH
94589: LD_VAR 0 1
94593: PPUSH
94594: CALL_OW 314
94598: OR
94599: PUSH
94600: LD_VAR 0 1
94604: PPUSH
94605: CALL_OW 302
94609: NOT
94610: OR
94611: PUSH
94612: LD_VAR 0 1
94616: PPUSH
94617: CALL_OW 301
94621: OR
94622: IFFALSE 94572
// RemoveSeeing ( _x , _y , side ) ;
94624: LD_VAR 0 8
94628: PPUSH
94629: LD_VAR 0 9
94633: PPUSH
94634: LD_VAR 0 6
94638: PPUSH
94639: CALL_OW 331
// end ; end_of_file end_of_file
94643: LD_VAR 0 4
94647: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
94648: LD_VAR 0 1
94652: PUSH
94653: LD_INT 200
94655: DOUBLE
94656: GREATEREQUAL
94657: IFFALSE 94665
94659: LD_INT 299
94661: DOUBLE
94662: LESSEQUAL
94663: IFTRUE 94667
94665: GO 94699
94667: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
94668: LD_VAR 0 1
94672: PPUSH
94673: LD_VAR 0 2
94677: PPUSH
94678: LD_VAR 0 3
94682: PPUSH
94683: LD_VAR 0 4
94687: PPUSH
94688: LD_VAR 0 5
94692: PPUSH
94693: CALL 90735 0 5
94697: GO 94776
94699: LD_INT 300
94701: DOUBLE
94702: GREATEREQUAL
94703: IFFALSE 94711
94705: LD_INT 399
94707: DOUBLE
94708: LESSEQUAL
94709: IFTRUE 94713
94711: GO 94775
94713: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
94714: LD_VAR 0 1
94718: PPUSH
94719: LD_VAR 0 2
94723: PPUSH
94724: LD_VAR 0 3
94728: PPUSH
94729: LD_VAR 0 4
94733: PPUSH
94734: LD_VAR 0 5
94738: PPUSH
94739: LD_VAR 0 6
94743: PPUSH
94744: LD_VAR 0 7
94748: PPUSH
94749: LD_VAR 0 8
94753: PPUSH
94754: LD_VAR 0 9
94758: PPUSH
94759: LD_VAR 0 10
94763: PPUSH
94764: LD_VAR 0 11
94768: PPUSH
94769: CALL 107319 0 11
94773: GO 94776
94775: POP
// end ;
94776: PPOPN 11
94778: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
94779: LD_VAR 0 1
94783: PPUSH
94784: LD_VAR 0 2
94788: PPUSH
94789: LD_VAR 0 3
94793: PPUSH
94794: LD_VAR 0 4
94798: PPUSH
94799: LD_VAR 0 5
94803: PPUSH
94804: CALL 90471 0 5
// end ; end_of_file
94808: PPOPN 5
94810: END
// every 0 0$1 do
94811: GO 94813
94813: DISABLE
// begin enable ;
94814: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
94815: LD_STRING updateTimer(
94817: PUSH
94818: LD_OWVAR 1
94822: STR
94823: PUSH
94824: LD_STRING );
94826: STR
94827: PPUSH
94828: CALL_OW 559
// end ;
94832: END
// export function SOS_MapStart ( ) ; begin
94833: LD_INT 0
94835: PPUSH
// if streamModeActive then
94836: LD_EXP 78
94840: IFFALSE 94849
// DefineStreamItems ( true ) ;
94842: LD_INT 1
94844: PPUSH
94845: CALL 96653 0 1
// UpdateLuaVariables ( ) ;
94849: CALL 94866 0 0
// UpdateFactoryWaypoints ( ) ;
94853: CALL 109514 0 0
// UpdateWarehouseGatheringPoints ( ) ;
94857: CALL 109771 0 0
// end ;
94861: LD_VAR 0 1
94865: RET
// export globalGameSaveCounter ; function UpdateLuaVariables ( ) ; begin
94866: LD_INT 0
94868: PPUSH
// if not globalGameSaveCounter then
94869: LD_EXP 77
94873: NOT
94874: IFFALSE 94885
// ToLua ( setGameSaveCounter(0) ) else
94876: LD_STRING setGameSaveCounter(0)
94878: PPUSH
94879: CALL_OW 559
94883: GO 94917
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
94885: LD_ADDR_EXP 77
94889: PUSH
94890: LD_EXP 77
94894: PPUSH
94895: CALL 49802 0 1
94899: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
94900: LD_STRING setGameSaveCounter(
94902: PUSH
94903: LD_EXP 77
94907: STR
94908: PUSH
94909: LD_STRING )
94911: STR
94912: PPUSH
94913: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
94917: LD_STRING setGameDifficulty(
94919: PUSH
94920: LD_OWVAR 67
94924: STR
94925: PUSH
94926: LD_STRING )
94928: STR
94929: PPUSH
94930: CALL_OW 559
// end ;
94934: LD_VAR 0 1
94938: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
94939: LD_INT 0
94941: PPUSH
// if p2 = stream_mode then
94942: LD_VAR 0 2
94946: PUSH
94947: LD_INT 100
94949: EQUAL
94950: IFFALSE 95953
// begin if not StreamModeActive then
94952: LD_EXP 78
94956: NOT
94957: IFFALSE 94967
// StreamModeActive := true ;
94959: LD_ADDR_EXP 78
94963: PUSH
94964: LD_INT 1
94966: ST_TO_ADDR
// if p3 = 0 then
94967: LD_VAR 0 3
94971: PUSH
94972: LD_INT 0
94974: EQUAL
94975: IFFALSE 94981
// InitStreamMode ;
94977: CALL 96189 0 0
// if p3 = 1 then
94981: LD_VAR 0 3
94985: PUSH
94986: LD_INT 1
94988: EQUAL
94989: IFFALSE 94999
// sRocket := true ;
94991: LD_ADDR_EXP 83
94995: PUSH
94996: LD_INT 1
94998: ST_TO_ADDR
// if p3 = 2 then
94999: LD_VAR 0 3
95003: PUSH
95004: LD_INT 2
95006: EQUAL
95007: IFFALSE 95017
// sSpeed := true ;
95009: LD_ADDR_EXP 82
95013: PUSH
95014: LD_INT 1
95016: ST_TO_ADDR
// if p3 = 3 then
95017: LD_VAR 0 3
95021: PUSH
95022: LD_INT 3
95024: EQUAL
95025: IFFALSE 95035
// sEngine := true ;
95027: LD_ADDR_EXP 84
95031: PUSH
95032: LD_INT 1
95034: ST_TO_ADDR
// if p3 = 4 then
95035: LD_VAR 0 3
95039: PUSH
95040: LD_INT 4
95042: EQUAL
95043: IFFALSE 95053
// sSpec := true ;
95045: LD_ADDR_EXP 81
95049: PUSH
95050: LD_INT 1
95052: ST_TO_ADDR
// if p3 = 5 then
95053: LD_VAR 0 3
95057: PUSH
95058: LD_INT 5
95060: EQUAL
95061: IFFALSE 95071
// sLevel := true ;
95063: LD_ADDR_EXP 85
95067: PUSH
95068: LD_INT 1
95070: ST_TO_ADDR
// if p3 = 6 then
95071: LD_VAR 0 3
95075: PUSH
95076: LD_INT 6
95078: EQUAL
95079: IFFALSE 95089
// sArmoury := true ;
95081: LD_ADDR_EXP 86
95085: PUSH
95086: LD_INT 1
95088: ST_TO_ADDR
// if p3 = 7 then
95089: LD_VAR 0 3
95093: PUSH
95094: LD_INT 7
95096: EQUAL
95097: IFFALSE 95107
// sRadar := true ;
95099: LD_ADDR_EXP 87
95103: PUSH
95104: LD_INT 1
95106: ST_TO_ADDR
// if p3 = 8 then
95107: LD_VAR 0 3
95111: PUSH
95112: LD_INT 8
95114: EQUAL
95115: IFFALSE 95125
// sBunker := true ;
95117: LD_ADDR_EXP 88
95121: PUSH
95122: LD_INT 1
95124: ST_TO_ADDR
// if p3 = 9 then
95125: LD_VAR 0 3
95129: PUSH
95130: LD_INT 9
95132: EQUAL
95133: IFFALSE 95143
// sHack := true ;
95135: LD_ADDR_EXP 89
95139: PUSH
95140: LD_INT 1
95142: ST_TO_ADDR
// if p3 = 10 then
95143: LD_VAR 0 3
95147: PUSH
95148: LD_INT 10
95150: EQUAL
95151: IFFALSE 95161
// sFire := true ;
95153: LD_ADDR_EXP 90
95157: PUSH
95158: LD_INT 1
95160: ST_TO_ADDR
// if p3 = 11 then
95161: LD_VAR 0 3
95165: PUSH
95166: LD_INT 11
95168: EQUAL
95169: IFFALSE 95179
// sRefresh := true ;
95171: LD_ADDR_EXP 91
95175: PUSH
95176: LD_INT 1
95178: ST_TO_ADDR
// if p3 = 12 then
95179: LD_VAR 0 3
95183: PUSH
95184: LD_INT 12
95186: EQUAL
95187: IFFALSE 95197
// sExp := true ;
95189: LD_ADDR_EXP 92
95193: PUSH
95194: LD_INT 1
95196: ST_TO_ADDR
// if p3 = 13 then
95197: LD_VAR 0 3
95201: PUSH
95202: LD_INT 13
95204: EQUAL
95205: IFFALSE 95215
// sDepot := true ;
95207: LD_ADDR_EXP 93
95211: PUSH
95212: LD_INT 1
95214: ST_TO_ADDR
// if p3 = 14 then
95215: LD_VAR 0 3
95219: PUSH
95220: LD_INT 14
95222: EQUAL
95223: IFFALSE 95233
// sFlag := true ;
95225: LD_ADDR_EXP 94
95229: PUSH
95230: LD_INT 1
95232: ST_TO_ADDR
// if p3 = 15 then
95233: LD_VAR 0 3
95237: PUSH
95238: LD_INT 15
95240: EQUAL
95241: IFFALSE 95251
// sKamikadze := true ;
95243: LD_ADDR_EXP 102
95247: PUSH
95248: LD_INT 1
95250: ST_TO_ADDR
// if p3 = 16 then
95251: LD_VAR 0 3
95255: PUSH
95256: LD_INT 16
95258: EQUAL
95259: IFFALSE 95269
// sTroll := true ;
95261: LD_ADDR_EXP 103
95265: PUSH
95266: LD_INT 1
95268: ST_TO_ADDR
// if p3 = 17 then
95269: LD_VAR 0 3
95273: PUSH
95274: LD_INT 17
95276: EQUAL
95277: IFFALSE 95287
// sSlow := true ;
95279: LD_ADDR_EXP 104
95283: PUSH
95284: LD_INT 1
95286: ST_TO_ADDR
// if p3 = 18 then
95287: LD_VAR 0 3
95291: PUSH
95292: LD_INT 18
95294: EQUAL
95295: IFFALSE 95305
// sLack := true ;
95297: LD_ADDR_EXP 105
95301: PUSH
95302: LD_INT 1
95304: ST_TO_ADDR
// if p3 = 19 then
95305: LD_VAR 0 3
95309: PUSH
95310: LD_INT 19
95312: EQUAL
95313: IFFALSE 95323
// sTank := true ;
95315: LD_ADDR_EXP 107
95319: PUSH
95320: LD_INT 1
95322: ST_TO_ADDR
// if p3 = 20 then
95323: LD_VAR 0 3
95327: PUSH
95328: LD_INT 20
95330: EQUAL
95331: IFFALSE 95341
// sRemote := true ;
95333: LD_ADDR_EXP 108
95337: PUSH
95338: LD_INT 1
95340: ST_TO_ADDR
// if p3 = 21 then
95341: LD_VAR 0 3
95345: PUSH
95346: LD_INT 21
95348: EQUAL
95349: IFFALSE 95359
// sPowell := true ;
95351: LD_ADDR_EXP 109
95355: PUSH
95356: LD_INT 1
95358: ST_TO_ADDR
// if p3 = 22 then
95359: LD_VAR 0 3
95363: PUSH
95364: LD_INT 22
95366: EQUAL
95367: IFFALSE 95377
// sTeleport := true ;
95369: LD_ADDR_EXP 112
95373: PUSH
95374: LD_INT 1
95376: ST_TO_ADDR
// if p3 = 23 then
95377: LD_VAR 0 3
95381: PUSH
95382: LD_INT 23
95384: EQUAL
95385: IFFALSE 95395
// sOilTower := true ;
95387: LD_ADDR_EXP 114
95391: PUSH
95392: LD_INT 1
95394: ST_TO_ADDR
// if p3 = 24 then
95395: LD_VAR 0 3
95399: PUSH
95400: LD_INT 24
95402: EQUAL
95403: IFFALSE 95413
// sShovel := true ;
95405: LD_ADDR_EXP 115
95409: PUSH
95410: LD_INT 1
95412: ST_TO_ADDR
// if p3 = 25 then
95413: LD_VAR 0 3
95417: PUSH
95418: LD_INT 25
95420: EQUAL
95421: IFFALSE 95431
// sSheik := true ;
95423: LD_ADDR_EXP 116
95427: PUSH
95428: LD_INT 1
95430: ST_TO_ADDR
// if p3 = 26 then
95431: LD_VAR 0 3
95435: PUSH
95436: LD_INT 26
95438: EQUAL
95439: IFFALSE 95449
// sEarthquake := true ;
95441: LD_ADDR_EXP 118
95445: PUSH
95446: LD_INT 1
95448: ST_TO_ADDR
// if p3 = 27 then
95449: LD_VAR 0 3
95453: PUSH
95454: LD_INT 27
95456: EQUAL
95457: IFFALSE 95467
// sAI := true ;
95459: LD_ADDR_EXP 119
95463: PUSH
95464: LD_INT 1
95466: ST_TO_ADDR
// if p3 = 28 then
95467: LD_VAR 0 3
95471: PUSH
95472: LD_INT 28
95474: EQUAL
95475: IFFALSE 95485
// sCargo := true ;
95477: LD_ADDR_EXP 122
95481: PUSH
95482: LD_INT 1
95484: ST_TO_ADDR
// if p3 = 29 then
95485: LD_VAR 0 3
95489: PUSH
95490: LD_INT 29
95492: EQUAL
95493: IFFALSE 95503
// sDLaser := true ;
95495: LD_ADDR_EXP 123
95499: PUSH
95500: LD_INT 1
95502: ST_TO_ADDR
// if p3 = 30 then
95503: LD_VAR 0 3
95507: PUSH
95508: LD_INT 30
95510: EQUAL
95511: IFFALSE 95521
// sExchange := true ;
95513: LD_ADDR_EXP 124
95517: PUSH
95518: LD_INT 1
95520: ST_TO_ADDR
// if p3 = 31 then
95521: LD_VAR 0 3
95525: PUSH
95526: LD_INT 31
95528: EQUAL
95529: IFFALSE 95539
// sFac := true ;
95531: LD_ADDR_EXP 125
95535: PUSH
95536: LD_INT 1
95538: ST_TO_ADDR
// if p3 = 32 then
95539: LD_VAR 0 3
95543: PUSH
95544: LD_INT 32
95546: EQUAL
95547: IFFALSE 95557
// sPower := true ;
95549: LD_ADDR_EXP 126
95553: PUSH
95554: LD_INT 1
95556: ST_TO_ADDR
// if p3 = 33 then
95557: LD_VAR 0 3
95561: PUSH
95562: LD_INT 33
95564: EQUAL
95565: IFFALSE 95575
// sRandom := true ;
95567: LD_ADDR_EXP 127
95571: PUSH
95572: LD_INT 1
95574: ST_TO_ADDR
// if p3 = 34 then
95575: LD_VAR 0 3
95579: PUSH
95580: LD_INT 34
95582: EQUAL
95583: IFFALSE 95593
// sShield := true ;
95585: LD_ADDR_EXP 128
95589: PUSH
95590: LD_INT 1
95592: ST_TO_ADDR
// if p3 = 35 then
95593: LD_VAR 0 3
95597: PUSH
95598: LD_INT 35
95600: EQUAL
95601: IFFALSE 95611
// sTime := true ;
95603: LD_ADDR_EXP 129
95607: PUSH
95608: LD_INT 1
95610: ST_TO_ADDR
// if p3 = 36 then
95611: LD_VAR 0 3
95615: PUSH
95616: LD_INT 36
95618: EQUAL
95619: IFFALSE 95629
// sTools := true ;
95621: LD_ADDR_EXP 130
95625: PUSH
95626: LD_INT 1
95628: ST_TO_ADDR
// if p3 = 101 then
95629: LD_VAR 0 3
95633: PUSH
95634: LD_INT 101
95636: EQUAL
95637: IFFALSE 95647
// sSold := true ;
95639: LD_ADDR_EXP 95
95643: PUSH
95644: LD_INT 1
95646: ST_TO_ADDR
// if p3 = 102 then
95647: LD_VAR 0 3
95651: PUSH
95652: LD_INT 102
95654: EQUAL
95655: IFFALSE 95665
// sDiff := true ;
95657: LD_ADDR_EXP 96
95661: PUSH
95662: LD_INT 1
95664: ST_TO_ADDR
// if p3 = 103 then
95665: LD_VAR 0 3
95669: PUSH
95670: LD_INT 103
95672: EQUAL
95673: IFFALSE 95683
// sFog := true ;
95675: LD_ADDR_EXP 99
95679: PUSH
95680: LD_INT 1
95682: ST_TO_ADDR
// if p3 = 104 then
95683: LD_VAR 0 3
95687: PUSH
95688: LD_INT 104
95690: EQUAL
95691: IFFALSE 95701
// sReset := true ;
95693: LD_ADDR_EXP 100
95697: PUSH
95698: LD_INT 1
95700: ST_TO_ADDR
// if p3 = 105 then
95701: LD_VAR 0 3
95705: PUSH
95706: LD_INT 105
95708: EQUAL
95709: IFFALSE 95719
// sSun := true ;
95711: LD_ADDR_EXP 101
95715: PUSH
95716: LD_INT 1
95718: ST_TO_ADDR
// if p3 = 106 then
95719: LD_VAR 0 3
95723: PUSH
95724: LD_INT 106
95726: EQUAL
95727: IFFALSE 95737
// sTiger := true ;
95729: LD_ADDR_EXP 97
95733: PUSH
95734: LD_INT 1
95736: ST_TO_ADDR
// if p3 = 107 then
95737: LD_VAR 0 3
95741: PUSH
95742: LD_INT 107
95744: EQUAL
95745: IFFALSE 95755
// sBomb := true ;
95747: LD_ADDR_EXP 98
95751: PUSH
95752: LD_INT 1
95754: ST_TO_ADDR
// if p3 = 108 then
95755: LD_VAR 0 3
95759: PUSH
95760: LD_INT 108
95762: EQUAL
95763: IFFALSE 95773
// sWound := true ;
95765: LD_ADDR_EXP 106
95769: PUSH
95770: LD_INT 1
95772: ST_TO_ADDR
// if p3 = 109 then
95773: LD_VAR 0 3
95777: PUSH
95778: LD_INT 109
95780: EQUAL
95781: IFFALSE 95791
// sBetray := true ;
95783: LD_ADDR_EXP 110
95787: PUSH
95788: LD_INT 1
95790: ST_TO_ADDR
// if p3 = 110 then
95791: LD_VAR 0 3
95795: PUSH
95796: LD_INT 110
95798: EQUAL
95799: IFFALSE 95809
// sContamin := true ;
95801: LD_ADDR_EXP 111
95805: PUSH
95806: LD_INT 1
95808: ST_TO_ADDR
// if p3 = 111 then
95809: LD_VAR 0 3
95813: PUSH
95814: LD_INT 111
95816: EQUAL
95817: IFFALSE 95827
// sOil := true ;
95819: LD_ADDR_EXP 113
95823: PUSH
95824: LD_INT 1
95826: ST_TO_ADDR
// if p3 = 112 then
95827: LD_VAR 0 3
95831: PUSH
95832: LD_INT 112
95834: EQUAL
95835: IFFALSE 95845
// sStu := true ;
95837: LD_ADDR_EXP 117
95841: PUSH
95842: LD_INT 1
95844: ST_TO_ADDR
// if p3 = 113 then
95845: LD_VAR 0 3
95849: PUSH
95850: LD_INT 113
95852: EQUAL
95853: IFFALSE 95863
// sBazooka := true ;
95855: LD_ADDR_EXP 120
95859: PUSH
95860: LD_INT 1
95862: ST_TO_ADDR
// if p3 = 114 then
95863: LD_VAR 0 3
95867: PUSH
95868: LD_INT 114
95870: EQUAL
95871: IFFALSE 95881
// sMortar := true ;
95873: LD_ADDR_EXP 121
95877: PUSH
95878: LD_INT 1
95880: ST_TO_ADDR
// if p3 = 115 then
95881: LD_VAR 0 3
95885: PUSH
95886: LD_INT 115
95888: EQUAL
95889: IFFALSE 95899
// sRanger := true ;
95891: LD_ADDR_EXP 131
95895: PUSH
95896: LD_INT 1
95898: ST_TO_ADDR
// if p3 = 116 then
95899: LD_VAR 0 3
95903: PUSH
95904: LD_INT 116
95906: EQUAL
95907: IFFALSE 95917
// sComputer := true ;
95909: LD_ADDR_EXP 132
95913: PUSH
95914: LD_INT 1
95916: ST_TO_ADDR
// if p3 = 117 then
95917: LD_VAR 0 3
95921: PUSH
95922: LD_INT 117
95924: EQUAL
95925: IFFALSE 95935
// s30 := true ;
95927: LD_ADDR_EXP 133
95931: PUSH
95932: LD_INT 1
95934: ST_TO_ADDR
// if p3 = 118 then
95935: LD_VAR 0 3
95939: PUSH
95940: LD_INT 118
95942: EQUAL
95943: IFFALSE 95953
// s60 := true ;
95945: LD_ADDR_EXP 134
95949: PUSH
95950: LD_INT 1
95952: ST_TO_ADDR
// end ; if p2 = hack_mode then
95953: LD_VAR 0 2
95957: PUSH
95958: LD_INT 101
95960: EQUAL
95961: IFFALSE 96089
// begin case p3 of 1 :
95963: LD_VAR 0 3
95967: PUSH
95968: LD_INT 1
95970: DOUBLE
95971: EQUAL
95972: IFTRUE 95976
95974: GO 95983
95976: POP
// hHackUnlimitedResources ; 2 :
95977: CALL 108260 0 0
95981: GO 96089
95983: LD_INT 2
95985: DOUBLE
95986: EQUAL
95987: IFTRUE 95991
95989: GO 95998
95991: POP
// hHackSetLevel10 ; 3 :
95992: CALL 108393 0 0
95996: GO 96089
95998: LD_INT 3
96000: DOUBLE
96001: EQUAL
96002: IFTRUE 96006
96004: GO 96013
96006: POP
// hHackSetLevel10YourUnits ; 4 :
96007: CALL 108478 0 0
96011: GO 96089
96013: LD_INT 4
96015: DOUBLE
96016: EQUAL
96017: IFTRUE 96021
96019: GO 96028
96021: POP
// hHackInvincible ; 5 :
96022: CALL 108926 0 0
96026: GO 96089
96028: LD_INT 5
96030: DOUBLE
96031: EQUAL
96032: IFTRUE 96036
96034: GO 96043
96036: POP
// hHackInvisible ; 6 :
96037: CALL 109037 0 0
96041: GO 96089
96043: LD_INT 6
96045: DOUBLE
96046: EQUAL
96047: IFTRUE 96051
96049: GO 96058
96051: POP
// hHackChangeYourSide ; 7 :
96052: CALL 109094 0 0
96056: GO 96089
96058: LD_INT 7
96060: DOUBLE
96061: EQUAL
96062: IFTRUE 96066
96064: GO 96073
96066: POP
// hHackChangeUnitSide ; 8 :
96067: CALL 109136 0 0
96071: GO 96089
96073: LD_INT 8
96075: DOUBLE
96076: EQUAL
96077: IFTRUE 96081
96079: GO 96088
96081: POP
// hHackFog ; end ;
96082: CALL 109237 0 0
96086: GO 96089
96088: POP
// end ; if p2 = game_save_mode then
96089: LD_VAR 0 2
96093: PUSH
96094: LD_INT 102
96096: EQUAL
96097: IFFALSE 96162
// begin if p3 = 1 then
96099: LD_VAR 0 3
96103: PUSH
96104: LD_INT 1
96106: EQUAL
96107: IFFALSE 96119
// globalGameSaveCounter := p4 ;
96109: LD_ADDR_EXP 77
96113: PUSH
96114: LD_VAR 0 4
96118: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
96119: LD_VAR 0 3
96123: PUSH
96124: LD_INT 2
96126: EQUAL
96127: PUSH
96128: LD_EXP 77
96132: AND
96133: IFFALSE 96152
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
96135: LD_STRING setGameSaveCounter(
96137: PUSH
96138: LD_EXP 77
96142: STR
96143: PUSH
96144: LD_STRING )
96146: STR
96147: PPUSH
96148: CALL_OW 559
// display_strings := globalGameSaveCounter ;
96152: LD_ADDR_OWVAR 47
96156: PUSH
96157: LD_EXP 77
96161: ST_TO_ADDR
// end ; end ;
96162: LD_VAR 0 7
96166: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
96167: GO 96169
96169: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
96170: LD_STRING initStreamRollete();
96172: PPUSH
96173: CALL_OW 559
// InitStreamMode ;
96177: CALL 96189 0 0
// DefineStreamItems ( false ) ;
96181: LD_INT 0
96183: PPUSH
96184: CALL 96653 0 1
// end ;
96188: END
// function InitStreamMode ; begin
96189: LD_INT 0
96191: PPUSH
// streamModeActive := false ;
96192: LD_ADDR_EXP 78
96196: PUSH
96197: LD_INT 0
96199: ST_TO_ADDR
// normalCounter := 36 ;
96200: LD_ADDR_EXP 79
96204: PUSH
96205: LD_INT 36
96207: ST_TO_ADDR
// hardcoreCounter := 18 ;
96208: LD_ADDR_EXP 80
96212: PUSH
96213: LD_INT 18
96215: ST_TO_ADDR
// sRocket := false ;
96216: LD_ADDR_EXP 83
96220: PUSH
96221: LD_INT 0
96223: ST_TO_ADDR
// sSpeed := false ;
96224: LD_ADDR_EXP 82
96228: PUSH
96229: LD_INT 0
96231: ST_TO_ADDR
// sEngine := false ;
96232: LD_ADDR_EXP 84
96236: PUSH
96237: LD_INT 0
96239: ST_TO_ADDR
// sSpec := false ;
96240: LD_ADDR_EXP 81
96244: PUSH
96245: LD_INT 0
96247: ST_TO_ADDR
// sLevel := false ;
96248: LD_ADDR_EXP 85
96252: PUSH
96253: LD_INT 0
96255: ST_TO_ADDR
// sArmoury := false ;
96256: LD_ADDR_EXP 86
96260: PUSH
96261: LD_INT 0
96263: ST_TO_ADDR
// sRadar := false ;
96264: LD_ADDR_EXP 87
96268: PUSH
96269: LD_INT 0
96271: ST_TO_ADDR
// sBunker := false ;
96272: LD_ADDR_EXP 88
96276: PUSH
96277: LD_INT 0
96279: ST_TO_ADDR
// sHack := false ;
96280: LD_ADDR_EXP 89
96284: PUSH
96285: LD_INT 0
96287: ST_TO_ADDR
// sFire := false ;
96288: LD_ADDR_EXP 90
96292: PUSH
96293: LD_INT 0
96295: ST_TO_ADDR
// sRefresh := false ;
96296: LD_ADDR_EXP 91
96300: PUSH
96301: LD_INT 0
96303: ST_TO_ADDR
// sExp := false ;
96304: LD_ADDR_EXP 92
96308: PUSH
96309: LD_INT 0
96311: ST_TO_ADDR
// sDepot := false ;
96312: LD_ADDR_EXP 93
96316: PUSH
96317: LD_INT 0
96319: ST_TO_ADDR
// sFlag := false ;
96320: LD_ADDR_EXP 94
96324: PUSH
96325: LD_INT 0
96327: ST_TO_ADDR
// sKamikadze := false ;
96328: LD_ADDR_EXP 102
96332: PUSH
96333: LD_INT 0
96335: ST_TO_ADDR
// sTroll := false ;
96336: LD_ADDR_EXP 103
96340: PUSH
96341: LD_INT 0
96343: ST_TO_ADDR
// sSlow := false ;
96344: LD_ADDR_EXP 104
96348: PUSH
96349: LD_INT 0
96351: ST_TO_ADDR
// sLack := false ;
96352: LD_ADDR_EXP 105
96356: PUSH
96357: LD_INT 0
96359: ST_TO_ADDR
// sTank := false ;
96360: LD_ADDR_EXP 107
96364: PUSH
96365: LD_INT 0
96367: ST_TO_ADDR
// sRemote := false ;
96368: LD_ADDR_EXP 108
96372: PUSH
96373: LD_INT 0
96375: ST_TO_ADDR
// sPowell := false ;
96376: LD_ADDR_EXP 109
96380: PUSH
96381: LD_INT 0
96383: ST_TO_ADDR
// sTeleport := false ;
96384: LD_ADDR_EXP 112
96388: PUSH
96389: LD_INT 0
96391: ST_TO_ADDR
// sOilTower := false ;
96392: LD_ADDR_EXP 114
96396: PUSH
96397: LD_INT 0
96399: ST_TO_ADDR
// sShovel := false ;
96400: LD_ADDR_EXP 115
96404: PUSH
96405: LD_INT 0
96407: ST_TO_ADDR
// sSheik := false ;
96408: LD_ADDR_EXP 116
96412: PUSH
96413: LD_INT 0
96415: ST_TO_ADDR
// sEarthquake := false ;
96416: LD_ADDR_EXP 118
96420: PUSH
96421: LD_INT 0
96423: ST_TO_ADDR
// sAI := false ;
96424: LD_ADDR_EXP 119
96428: PUSH
96429: LD_INT 0
96431: ST_TO_ADDR
// sCargo := false ;
96432: LD_ADDR_EXP 122
96436: PUSH
96437: LD_INT 0
96439: ST_TO_ADDR
// sDLaser := false ;
96440: LD_ADDR_EXP 123
96444: PUSH
96445: LD_INT 0
96447: ST_TO_ADDR
// sExchange := false ;
96448: LD_ADDR_EXP 124
96452: PUSH
96453: LD_INT 0
96455: ST_TO_ADDR
// sFac := false ;
96456: LD_ADDR_EXP 125
96460: PUSH
96461: LD_INT 0
96463: ST_TO_ADDR
// sPower := false ;
96464: LD_ADDR_EXP 126
96468: PUSH
96469: LD_INT 0
96471: ST_TO_ADDR
// sRandom := false ;
96472: LD_ADDR_EXP 127
96476: PUSH
96477: LD_INT 0
96479: ST_TO_ADDR
// sShield := false ;
96480: LD_ADDR_EXP 128
96484: PUSH
96485: LD_INT 0
96487: ST_TO_ADDR
// sTime := false ;
96488: LD_ADDR_EXP 129
96492: PUSH
96493: LD_INT 0
96495: ST_TO_ADDR
// sTools := false ;
96496: LD_ADDR_EXP 130
96500: PUSH
96501: LD_INT 0
96503: ST_TO_ADDR
// sSold := false ;
96504: LD_ADDR_EXP 95
96508: PUSH
96509: LD_INT 0
96511: ST_TO_ADDR
// sDiff := false ;
96512: LD_ADDR_EXP 96
96516: PUSH
96517: LD_INT 0
96519: ST_TO_ADDR
// sFog := false ;
96520: LD_ADDR_EXP 99
96524: PUSH
96525: LD_INT 0
96527: ST_TO_ADDR
// sReset := false ;
96528: LD_ADDR_EXP 100
96532: PUSH
96533: LD_INT 0
96535: ST_TO_ADDR
// sSun := false ;
96536: LD_ADDR_EXP 101
96540: PUSH
96541: LD_INT 0
96543: ST_TO_ADDR
// sTiger := false ;
96544: LD_ADDR_EXP 97
96548: PUSH
96549: LD_INT 0
96551: ST_TO_ADDR
// sBomb := false ;
96552: LD_ADDR_EXP 98
96556: PUSH
96557: LD_INT 0
96559: ST_TO_ADDR
// sWound := false ;
96560: LD_ADDR_EXP 106
96564: PUSH
96565: LD_INT 0
96567: ST_TO_ADDR
// sBetray := false ;
96568: LD_ADDR_EXP 110
96572: PUSH
96573: LD_INT 0
96575: ST_TO_ADDR
// sContamin := false ;
96576: LD_ADDR_EXP 111
96580: PUSH
96581: LD_INT 0
96583: ST_TO_ADDR
// sOil := false ;
96584: LD_ADDR_EXP 113
96588: PUSH
96589: LD_INT 0
96591: ST_TO_ADDR
// sStu := false ;
96592: LD_ADDR_EXP 117
96596: PUSH
96597: LD_INT 0
96599: ST_TO_ADDR
// sBazooka := false ;
96600: LD_ADDR_EXP 120
96604: PUSH
96605: LD_INT 0
96607: ST_TO_ADDR
// sMortar := false ;
96608: LD_ADDR_EXP 121
96612: PUSH
96613: LD_INT 0
96615: ST_TO_ADDR
// sRanger := false ;
96616: LD_ADDR_EXP 131
96620: PUSH
96621: LD_INT 0
96623: ST_TO_ADDR
// sComputer := false ;
96624: LD_ADDR_EXP 132
96628: PUSH
96629: LD_INT 0
96631: ST_TO_ADDR
// s30 := false ;
96632: LD_ADDR_EXP 133
96636: PUSH
96637: LD_INT 0
96639: ST_TO_ADDR
// s60 := false ;
96640: LD_ADDR_EXP 134
96644: PUSH
96645: LD_INT 0
96647: ST_TO_ADDR
// end ;
96648: LD_VAR 0 1
96652: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
96653: LD_INT 0
96655: PPUSH
96656: PPUSH
96657: PPUSH
96658: PPUSH
96659: PPUSH
96660: PPUSH
96661: PPUSH
// result := [ ] ;
96662: LD_ADDR_VAR 0 2
96666: PUSH
96667: EMPTY
96668: ST_TO_ADDR
// if campaign_id = 1 then
96669: LD_OWVAR 69
96673: PUSH
96674: LD_INT 1
96676: EQUAL
96677: IFFALSE 99843
// begin case mission_number of 1 :
96679: LD_OWVAR 70
96683: PUSH
96684: LD_INT 1
96686: DOUBLE
96687: EQUAL
96688: IFTRUE 96692
96690: GO 96768
96692: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
96693: LD_ADDR_VAR 0 2
96697: PUSH
96698: LD_INT 2
96700: PUSH
96701: LD_INT 4
96703: PUSH
96704: LD_INT 11
96706: PUSH
96707: LD_INT 12
96709: PUSH
96710: LD_INT 15
96712: PUSH
96713: LD_INT 16
96715: PUSH
96716: LD_INT 22
96718: PUSH
96719: LD_INT 23
96721: PUSH
96722: LD_INT 26
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 101
96738: PUSH
96739: LD_INT 102
96741: PUSH
96742: LD_INT 106
96744: PUSH
96745: LD_INT 116
96747: PUSH
96748: LD_INT 117
96750: PUSH
96751: LD_INT 118
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: ST_TO_ADDR
96766: GO 99841
96768: LD_INT 2
96770: DOUBLE
96771: EQUAL
96772: IFTRUE 96776
96774: GO 96860
96776: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
96777: LD_ADDR_VAR 0 2
96781: PUSH
96782: LD_INT 2
96784: PUSH
96785: LD_INT 4
96787: PUSH
96788: LD_INT 11
96790: PUSH
96791: LD_INT 12
96793: PUSH
96794: LD_INT 15
96796: PUSH
96797: LD_INT 16
96799: PUSH
96800: LD_INT 22
96802: PUSH
96803: LD_INT 23
96805: PUSH
96806: LD_INT 26
96808: PUSH
96809: EMPTY
96810: LIST
96811: LIST
96812: LIST
96813: LIST
96814: LIST
96815: LIST
96816: LIST
96817: LIST
96818: LIST
96819: PUSH
96820: LD_INT 101
96822: PUSH
96823: LD_INT 102
96825: PUSH
96826: LD_INT 105
96828: PUSH
96829: LD_INT 106
96831: PUSH
96832: LD_INT 108
96834: PUSH
96835: LD_INT 116
96837: PUSH
96838: LD_INT 117
96840: PUSH
96841: LD_INT 118
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: LIST
96848: LIST
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: ST_TO_ADDR
96858: GO 99841
96860: LD_INT 3
96862: DOUBLE
96863: EQUAL
96864: IFTRUE 96868
96866: GO 96956
96868: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
96869: LD_ADDR_VAR 0 2
96873: PUSH
96874: LD_INT 2
96876: PUSH
96877: LD_INT 4
96879: PUSH
96880: LD_INT 5
96882: PUSH
96883: LD_INT 11
96885: PUSH
96886: LD_INT 12
96888: PUSH
96889: LD_INT 15
96891: PUSH
96892: LD_INT 16
96894: PUSH
96895: LD_INT 22
96897: PUSH
96898: LD_INT 26
96900: PUSH
96901: LD_INT 36
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 101
96918: PUSH
96919: LD_INT 102
96921: PUSH
96922: LD_INT 105
96924: PUSH
96925: LD_INT 106
96927: PUSH
96928: LD_INT 108
96930: PUSH
96931: LD_INT 116
96933: PUSH
96934: LD_INT 117
96936: PUSH
96937: LD_INT 118
96939: PUSH
96940: EMPTY
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: PUSH
96950: EMPTY
96951: LIST
96952: LIST
96953: ST_TO_ADDR
96954: GO 99841
96956: LD_INT 4
96958: DOUBLE
96959: EQUAL
96960: IFTRUE 96964
96962: GO 97060
96964: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
96965: LD_ADDR_VAR 0 2
96969: PUSH
96970: LD_INT 2
96972: PUSH
96973: LD_INT 4
96975: PUSH
96976: LD_INT 5
96978: PUSH
96979: LD_INT 8
96981: PUSH
96982: LD_INT 11
96984: PUSH
96985: LD_INT 12
96987: PUSH
96988: LD_INT 15
96990: PUSH
96991: LD_INT 16
96993: PUSH
96994: LD_INT 22
96996: PUSH
96997: LD_INT 23
96999: PUSH
97000: LD_INT 26
97002: PUSH
97003: LD_INT 36
97005: PUSH
97006: EMPTY
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: PUSH
97020: LD_INT 101
97022: PUSH
97023: LD_INT 102
97025: PUSH
97026: LD_INT 105
97028: PUSH
97029: LD_INT 106
97031: PUSH
97032: LD_INT 108
97034: PUSH
97035: LD_INT 116
97037: PUSH
97038: LD_INT 117
97040: PUSH
97041: LD_INT 118
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: LIST
97050: LIST
97051: LIST
97052: LIST
97053: PUSH
97054: EMPTY
97055: LIST
97056: LIST
97057: ST_TO_ADDR
97058: GO 99841
97060: LD_INT 5
97062: DOUBLE
97063: EQUAL
97064: IFTRUE 97068
97066: GO 97180
97068: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
97069: LD_ADDR_VAR 0 2
97073: PUSH
97074: LD_INT 2
97076: PUSH
97077: LD_INT 4
97079: PUSH
97080: LD_INT 5
97082: PUSH
97083: LD_INT 6
97085: PUSH
97086: LD_INT 8
97088: PUSH
97089: LD_INT 11
97091: PUSH
97092: LD_INT 12
97094: PUSH
97095: LD_INT 15
97097: PUSH
97098: LD_INT 16
97100: PUSH
97101: LD_INT 22
97103: PUSH
97104: LD_INT 23
97106: PUSH
97107: LD_INT 25
97109: PUSH
97110: LD_INT 26
97112: PUSH
97113: LD_INT 36
97115: PUSH
97116: EMPTY
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: PUSH
97132: LD_INT 101
97134: PUSH
97135: LD_INT 102
97137: PUSH
97138: LD_INT 105
97140: PUSH
97141: LD_INT 106
97143: PUSH
97144: LD_INT 108
97146: PUSH
97147: LD_INT 109
97149: PUSH
97150: LD_INT 112
97152: PUSH
97153: LD_INT 116
97155: PUSH
97156: LD_INT 117
97158: PUSH
97159: LD_INT 118
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: LIST
97173: PUSH
97174: EMPTY
97175: LIST
97176: LIST
97177: ST_TO_ADDR
97178: GO 99841
97180: LD_INT 6
97182: DOUBLE
97183: EQUAL
97184: IFTRUE 97188
97186: GO 97320
97188: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
97189: LD_ADDR_VAR 0 2
97193: PUSH
97194: LD_INT 2
97196: PUSH
97197: LD_INT 4
97199: PUSH
97200: LD_INT 5
97202: PUSH
97203: LD_INT 6
97205: PUSH
97206: LD_INT 8
97208: PUSH
97209: LD_INT 11
97211: PUSH
97212: LD_INT 12
97214: PUSH
97215: LD_INT 15
97217: PUSH
97218: LD_INT 16
97220: PUSH
97221: LD_INT 20
97223: PUSH
97224: LD_INT 21
97226: PUSH
97227: LD_INT 22
97229: PUSH
97230: LD_INT 23
97232: PUSH
97233: LD_INT 25
97235: PUSH
97236: LD_INT 26
97238: PUSH
97239: LD_INT 30
97241: PUSH
97242: LD_INT 31
97244: PUSH
97245: LD_INT 32
97247: PUSH
97248: LD_INT 36
97250: PUSH
97251: EMPTY
97252: LIST
97253: LIST
97254: LIST
97255: LIST
97256: LIST
97257: LIST
97258: LIST
97259: LIST
97260: LIST
97261: LIST
97262: LIST
97263: LIST
97264: LIST
97265: LIST
97266: LIST
97267: LIST
97268: LIST
97269: LIST
97270: LIST
97271: PUSH
97272: LD_INT 101
97274: PUSH
97275: LD_INT 102
97277: PUSH
97278: LD_INT 105
97280: PUSH
97281: LD_INT 106
97283: PUSH
97284: LD_INT 108
97286: PUSH
97287: LD_INT 109
97289: PUSH
97290: LD_INT 112
97292: PUSH
97293: LD_INT 116
97295: PUSH
97296: LD_INT 117
97298: PUSH
97299: LD_INT 118
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: LIST
97306: LIST
97307: LIST
97308: LIST
97309: LIST
97310: LIST
97311: LIST
97312: LIST
97313: PUSH
97314: EMPTY
97315: LIST
97316: LIST
97317: ST_TO_ADDR
97318: GO 99841
97320: LD_INT 7
97322: DOUBLE
97323: EQUAL
97324: IFTRUE 97328
97326: GO 97440
97328: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
97329: LD_ADDR_VAR 0 2
97333: PUSH
97334: LD_INT 2
97336: PUSH
97337: LD_INT 4
97339: PUSH
97340: LD_INT 5
97342: PUSH
97343: LD_INT 7
97345: PUSH
97346: LD_INT 11
97348: PUSH
97349: LD_INT 12
97351: PUSH
97352: LD_INT 15
97354: PUSH
97355: LD_INT 16
97357: PUSH
97358: LD_INT 20
97360: PUSH
97361: LD_INT 21
97363: PUSH
97364: LD_INT 22
97366: PUSH
97367: LD_INT 23
97369: PUSH
97370: LD_INT 25
97372: PUSH
97373: LD_INT 26
97375: PUSH
97376: EMPTY
97377: LIST
97378: LIST
97379: LIST
97380: LIST
97381: LIST
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: PUSH
97392: LD_INT 101
97394: PUSH
97395: LD_INT 102
97397: PUSH
97398: LD_INT 103
97400: PUSH
97401: LD_INT 105
97403: PUSH
97404: LD_INT 106
97406: PUSH
97407: LD_INT 108
97409: PUSH
97410: LD_INT 112
97412: PUSH
97413: LD_INT 116
97415: PUSH
97416: LD_INT 117
97418: PUSH
97419: LD_INT 118
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: LIST
97426: LIST
97427: LIST
97428: LIST
97429: LIST
97430: LIST
97431: LIST
97432: LIST
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: ST_TO_ADDR
97438: GO 99841
97440: LD_INT 8
97442: DOUBLE
97443: EQUAL
97444: IFTRUE 97448
97446: GO 97588
97448: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
97449: LD_ADDR_VAR 0 2
97453: PUSH
97454: LD_INT 2
97456: PUSH
97457: LD_INT 4
97459: PUSH
97460: LD_INT 5
97462: PUSH
97463: LD_INT 6
97465: PUSH
97466: LD_INT 7
97468: PUSH
97469: LD_INT 8
97471: PUSH
97472: LD_INT 11
97474: PUSH
97475: LD_INT 12
97477: PUSH
97478: LD_INT 15
97480: PUSH
97481: LD_INT 16
97483: PUSH
97484: LD_INT 20
97486: PUSH
97487: LD_INT 21
97489: PUSH
97490: LD_INT 22
97492: PUSH
97493: LD_INT 23
97495: PUSH
97496: LD_INT 25
97498: PUSH
97499: LD_INT 26
97501: PUSH
97502: LD_INT 30
97504: PUSH
97505: LD_INT 31
97507: PUSH
97508: LD_INT 32
97510: PUSH
97511: LD_INT 36
97513: PUSH
97514: EMPTY
97515: LIST
97516: LIST
97517: LIST
97518: LIST
97519: LIST
97520: LIST
97521: LIST
97522: LIST
97523: LIST
97524: LIST
97525: LIST
97526: LIST
97527: LIST
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: PUSH
97536: LD_INT 101
97538: PUSH
97539: LD_INT 102
97541: PUSH
97542: LD_INT 103
97544: PUSH
97545: LD_INT 105
97547: PUSH
97548: LD_INT 106
97550: PUSH
97551: LD_INT 108
97553: PUSH
97554: LD_INT 109
97556: PUSH
97557: LD_INT 112
97559: PUSH
97560: LD_INT 116
97562: PUSH
97563: LD_INT 117
97565: PUSH
97566: LD_INT 118
97568: PUSH
97569: EMPTY
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: PUSH
97582: EMPTY
97583: LIST
97584: LIST
97585: ST_TO_ADDR
97586: GO 99841
97588: LD_INT 9
97590: DOUBLE
97591: EQUAL
97592: IFTRUE 97596
97594: GO 97744
97596: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
97597: LD_ADDR_VAR 0 2
97601: PUSH
97602: LD_INT 2
97604: PUSH
97605: LD_INT 4
97607: PUSH
97608: LD_INT 5
97610: PUSH
97611: LD_INT 6
97613: PUSH
97614: LD_INT 7
97616: PUSH
97617: LD_INT 8
97619: PUSH
97620: LD_INT 11
97622: PUSH
97623: LD_INT 12
97625: PUSH
97626: LD_INT 15
97628: PUSH
97629: LD_INT 16
97631: PUSH
97632: LD_INT 20
97634: PUSH
97635: LD_INT 21
97637: PUSH
97638: LD_INT 22
97640: PUSH
97641: LD_INT 23
97643: PUSH
97644: LD_INT 25
97646: PUSH
97647: LD_INT 26
97649: PUSH
97650: LD_INT 28
97652: PUSH
97653: LD_INT 30
97655: PUSH
97656: LD_INT 31
97658: PUSH
97659: LD_INT 32
97661: PUSH
97662: LD_INT 36
97664: PUSH
97665: EMPTY
97666: LIST
97667: LIST
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: LIST
97673: LIST
97674: LIST
97675: LIST
97676: LIST
97677: LIST
97678: LIST
97679: LIST
97680: LIST
97681: LIST
97682: LIST
97683: LIST
97684: LIST
97685: LIST
97686: LIST
97687: PUSH
97688: LD_INT 101
97690: PUSH
97691: LD_INT 102
97693: PUSH
97694: LD_INT 103
97696: PUSH
97697: LD_INT 105
97699: PUSH
97700: LD_INT 106
97702: PUSH
97703: LD_INT 108
97705: PUSH
97706: LD_INT 109
97708: PUSH
97709: LD_INT 112
97711: PUSH
97712: LD_INT 114
97714: PUSH
97715: LD_INT 116
97717: PUSH
97718: LD_INT 117
97720: PUSH
97721: LD_INT 118
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: PUSH
97738: EMPTY
97739: LIST
97740: LIST
97741: ST_TO_ADDR
97742: GO 99841
97744: LD_INT 10
97746: DOUBLE
97747: EQUAL
97748: IFTRUE 97752
97750: GO 97948
97752: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
97753: LD_ADDR_VAR 0 2
97757: PUSH
97758: LD_INT 2
97760: PUSH
97761: LD_INT 4
97763: PUSH
97764: LD_INT 5
97766: PUSH
97767: LD_INT 6
97769: PUSH
97770: LD_INT 7
97772: PUSH
97773: LD_INT 8
97775: PUSH
97776: LD_INT 9
97778: PUSH
97779: LD_INT 10
97781: PUSH
97782: LD_INT 11
97784: PUSH
97785: LD_INT 12
97787: PUSH
97788: LD_INT 13
97790: PUSH
97791: LD_INT 14
97793: PUSH
97794: LD_INT 15
97796: PUSH
97797: LD_INT 16
97799: PUSH
97800: LD_INT 17
97802: PUSH
97803: LD_INT 18
97805: PUSH
97806: LD_INT 19
97808: PUSH
97809: LD_INT 20
97811: PUSH
97812: LD_INT 21
97814: PUSH
97815: LD_INT 22
97817: PUSH
97818: LD_INT 23
97820: PUSH
97821: LD_INT 24
97823: PUSH
97824: LD_INT 25
97826: PUSH
97827: LD_INT 26
97829: PUSH
97830: LD_INT 28
97832: PUSH
97833: LD_INT 30
97835: PUSH
97836: LD_INT 31
97838: PUSH
97839: LD_INT 32
97841: PUSH
97842: LD_INT 36
97844: PUSH
97845: EMPTY
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: PUSH
97876: LD_INT 101
97878: PUSH
97879: LD_INT 102
97881: PUSH
97882: LD_INT 103
97884: PUSH
97885: LD_INT 104
97887: PUSH
97888: LD_INT 105
97890: PUSH
97891: LD_INT 106
97893: PUSH
97894: LD_INT 107
97896: PUSH
97897: LD_INT 108
97899: PUSH
97900: LD_INT 109
97902: PUSH
97903: LD_INT 110
97905: PUSH
97906: LD_INT 111
97908: PUSH
97909: LD_INT 112
97911: PUSH
97912: LD_INT 114
97914: PUSH
97915: LD_INT 116
97917: PUSH
97918: LD_INT 117
97920: PUSH
97921: LD_INT 118
97923: PUSH
97924: EMPTY
97925: LIST
97926: LIST
97927: LIST
97928: LIST
97929: LIST
97930: LIST
97931: LIST
97932: LIST
97933: LIST
97934: LIST
97935: LIST
97936: LIST
97937: LIST
97938: LIST
97939: LIST
97940: LIST
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: ST_TO_ADDR
97946: GO 99841
97948: LD_INT 11
97950: DOUBLE
97951: EQUAL
97952: IFTRUE 97956
97954: GO 98160
97956: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
97957: LD_ADDR_VAR 0 2
97961: PUSH
97962: LD_INT 2
97964: PUSH
97965: LD_INT 3
97967: PUSH
97968: LD_INT 4
97970: PUSH
97971: LD_INT 5
97973: PUSH
97974: LD_INT 6
97976: PUSH
97977: LD_INT 7
97979: PUSH
97980: LD_INT 8
97982: PUSH
97983: LD_INT 9
97985: PUSH
97986: LD_INT 10
97988: PUSH
97989: LD_INT 11
97991: PUSH
97992: LD_INT 12
97994: PUSH
97995: LD_INT 13
97997: PUSH
97998: LD_INT 14
98000: PUSH
98001: LD_INT 15
98003: PUSH
98004: LD_INT 16
98006: PUSH
98007: LD_INT 17
98009: PUSH
98010: LD_INT 18
98012: PUSH
98013: LD_INT 19
98015: PUSH
98016: LD_INT 20
98018: PUSH
98019: LD_INT 21
98021: PUSH
98022: LD_INT 22
98024: PUSH
98025: LD_INT 23
98027: PUSH
98028: LD_INT 24
98030: PUSH
98031: LD_INT 25
98033: PUSH
98034: LD_INT 26
98036: PUSH
98037: LD_INT 28
98039: PUSH
98040: LD_INT 30
98042: PUSH
98043: LD_INT 31
98045: PUSH
98046: LD_INT 32
98048: PUSH
98049: LD_INT 34
98051: PUSH
98052: LD_INT 36
98054: PUSH
98055: EMPTY
98056: LIST
98057: LIST
98058: LIST
98059: LIST
98060: LIST
98061: LIST
98062: LIST
98063: LIST
98064: LIST
98065: LIST
98066: LIST
98067: LIST
98068: LIST
98069: LIST
98070: LIST
98071: LIST
98072: LIST
98073: LIST
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: LIST
98087: PUSH
98088: LD_INT 101
98090: PUSH
98091: LD_INT 102
98093: PUSH
98094: LD_INT 103
98096: PUSH
98097: LD_INT 104
98099: PUSH
98100: LD_INT 105
98102: PUSH
98103: LD_INT 106
98105: PUSH
98106: LD_INT 107
98108: PUSH
98109: LD_INT 108
98111: PUSH
98112: LD_INT 109
98114: PUSH
98115: LD_INT 110
98117: PUSH
98118: LD_INT 111
98120: PUSH
98121: LD_INT 112
98123: PUSH
98124: LD_INT 114
98126: PUSH
98127: LD_INT 116
98129: PUSH
98130: LD_INT 117
98132: PUSH
98133: LD_INT 118
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: LIST
98140: LIST
98141: LIST
98142: LIST
98143: LIST
98144: LIST
98145: LIST
98146: LIST
98147: LIST
98148: LIST
98149: LIST
98150: LIST
98151: LIST
98152: LIST
98153: PUSH
98154: EMPTY
98155: LIST
98156: LIST
98157: ST_TO_ADDR
98158: GO 99841
98160: LD_INT 12
98162: DOUBLE
98163: EQUAL
98164: IFTRUE 98168
98166: GO 98388
98168: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
98169: LD_ADDR_VAR 0 2
98173: PUSH
98174: LD_INT 1
98176: PUSH
98177: LD_INT 2
98179: PUSH
98180: LD_INT 3
98182: PUSH
98183: LD_INT 4
98185: PUSH
98186: LD_INT 5
98188: PUSH
98189: LD_INT 6
98191: PUSH
98192: LD_INT 7
98194: PUSH
98195: LD_INT 8
98197: PUSH
98198: LD_INT 9
98200: PUSH
98201: LD_INT 10
98203: PUSH
98204: LD_INT 11
98206: PUSH
98207: LD_INT 12
98209: PUSH
98210: LD_INT 13
98212: PUSH
98213: LD_INT 14
98215: PUSH
98216: LD_INT 15
98218: PUSH
98219: LD_INT 16
98221: PUSH
98222: LD_INT 17
98224: PUSH
98225: LD_INT 18
98227: PUSH
98228: LD_INT 19
98230: PUSH
98231: LD_INT 20
98233: PUSH
98234: LD_INT 21
98236: PUSH
98237: LD_INT 22
98239: PUSH
98240: LD_INT 23
98242: PUSH
98243: LD_INT 24
98245: PUSH
98246: LD_INT 25
98248: PUSH
98249: LD_INT 26
98251: PUSH
98252: LD_INT 27
98254: PUSH
98255: LD_INT 28
98257: PUSH
98258: LD_INT 30
98260: PUSH
98261: LD_INT 31
98263: PUSH
98264: LD_INT 32
98266: PUSH
98267: LD_INT 33
98269: PUSH
98270: LD_INT 34
98272: PUSH
98273: LD_INT 36
98275: PUSH
98276: EMPTY
98277: LIST
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: LIST
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: PUSH
98312: LD_INT 101
98314: PUSH
98315: LD_INT 102
98317: PUSH
98318: LD_INT 103
98320: PUSH
98321: LD_INT 104
98323: PUSH
98324: LD_INT 105
98326: PUSH
98327: LD_INT 106
98329: PUSH
98330: LD_INT 107
98332: PUSH
98333: LD_INT 108
98335: PUSH
98336: LD_INT 109
98338: PUSH
98339: LD_INT 110
98341: PUSH
98342: LD_INT 111
98344: PUSH
98345: LD_INT 112
98347: PUSH
98348: LD_INT 113
98350: PUSH
98351: LD_INT 114
98353: PUSH
98354: LD_INT 116
98356: PUSH
98357: LD_INT 117
98359: PUSH
98360: LD_INT 118
98362: PUSH
98363: EMPTY
98364: LIST
98365: LIST
98366: LIST
98367: LIST
98368: LIST
98369: LIST
98370: LIST
98371: LIST
98372: LIST
98373: LIST
98374: LIST
98375: LIST
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: LIST
98381: PUSH
98382: EMPTY
98383: LIST
98384: LIST
98385: ST_TO_ADDR
98386: GO 99841
98388: LD_INT 13
98390: DOUBLE
98391: EQUAL
98392: IFTRUE 98396
98394: GO 98604
98396: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
98397: LD_ADDR_VAR 0 2
98401: PUSH
98402: LD_INT 1
98404: PUSH
98405: LD_INT 2
98407: PUSH
98408: LD_INT 3
98410: PUSH
98411: LD_INT 4
98413: PUSH
98414: LD_INT 5
98416: PUSH
98417: LD_INT 8
98419: PUSH
98420: LD_INT 9
98422: PUSH
98423: LD_INT 10
98425: PUSH
98426: LD_INT 11
98428: PUSH
98429: LD_INT 12
98431: PUSH
98432: LD_INT 14
98434: PUSH
98435: LD_INT 15
98437: PUSH
98438: LD_INT 16
98440: PUSH
98441: LD_INT 17
98443: PUSH
98444: LD_INT 18
98446: PUSH
98447: LD_INT 19
98449: PUSH
98450: LD_INT 20
98452: PUSH
98453: LD_INT 21
98455: PUSH
98456: LD_INT 22
98458: PUSH
98459: LD_INT 23
98461: PUSH
98462: LD_INT 24
98464: PUSH
98465: LD_INT 25
98467: PUSH
98468: LD_INT 26
98470: PUSH
98471: LD_INT 27
98473: PUSH
98474: LD_INT 28
98476: PUSH
98477: LD_INT 30
98479: PUSH
98480: LD_INT 31
98482: PUSH
98483: LD_INT 32
98485: PUSH
98486: LD_INT 33
98488: PUSH
98489: LD_INT 34
98491: PUSH
98492: LD_INT 36
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: LIST
98499: LIST
98500: LIST
98501: LIST
98502: LIST
98503: LIST
98504: LIST
98505: LIST
98506: LIST
98507: LIST
98508: LIST
98509: LIST
98510: LIST
98511: LIST
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: LIST
98519: LIST
98520: LIST
98521: LIST
98522: LIST
98523: LIST
98524: LIST
98525: LIST
98526: LIST
98527: PUSH
98528: LD_INT 101
98530: PUSH
98531: LD_INT 102
98533: PUSH
98534: LD_INT 103
98536: PUSH
98537: LD_INT 104
98539: PUSH
98540: LD_INT 105
98542: PUSH
98543: LD_INT 106
98545: PUSH
98546: LD_INT 107
98548: PUSH
98549: LD_INT 108
98551: PUSH
98552: LD_INT 109
98554: PUSH
98555: LD_INT 110
98557: PUSH
98558: LD_INT 111
98560: PUSH
98561: LD_INT 112
98563: PUSH
98564: LD_INT 113
98566: PUSH
98567: LD_INT 114
98569: PUSH
98570: LD_INT 116
98572: PUSH
98573: LD_INT 117
98575: PUSH
98576: LD_INT 118
98578: PUSH
98579: EMPTY
98580: LIST
98581: LIST
98582: LIST
98583: LIST
98584: LIST
98585: LIST
98586: LIST
98587: LIST
98588: LIST
98589: LIST
98590: LIST
98591: LIST
98592: LIST
98593: LIST
98594: LIST
98595: LIST
98596: LIST
98597: PUSH
98598: EMPTY
98599: LIST
98600: LIST
98601: ST_TO_ADDR
98602: GO 99841
98604: LD_INT 14
98606: DOUBLE
98607: EQUAL
98608: IFTRUE 98612
98610: GO 98836
98612: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
98613: LD_ADDR_VAR 0 2
98617: PUSH
98618: LD_INT 1
98620: PUSH
98621: LD_INT 2
98623: PUSH
98624: LD_INT 3
98626: PUSH
98627: LD_INT 4
98629: PUSH
98630: LD_INT 5
98632: PUSH
98633: LD_INT 6
98635: PUSH
98636: LD_INT 7
98638: PUSH
98639: LD_INT 8
98641: PUSH
98642: LD_INT 9
98644: PUSH
98645: LD_INT 10
98647: PUSH
98648: LD_INT 11
98650: PUSH
98651: LD_INT 12
98653: PUSH
98654: LD_INT 13
98656: PUSH
98657: LD_INT 14
98659: PUSH
98660: LD_INT 15
98662: PUSH
98663: LD_INT 16
98665: PUSH
98666: LD_INT 17
98668: PUSH
98669: LD_INT 18
98671: PUSH
98672: LD_INT 19
98674: PUSH
98675: LD_INT 20
98677: PUSH
98678: LD_INT 21
98680: PUSH
98681: LD_INT 22
98683: PUSH
98684: LD_INT 23
98686: PUSH
98687: LD_INT 24
98689: PUSH
98690: LD_INT 25
98692: PUSH
98693: LD_INT 26
98695: PUSH
98696: LD_INT 27
98698: PUSH
98699: LD_INT 28
98701: PUSH
98702: LD_INT 29
98704: PUSH
98705: LD_INT 30
98707: PUSH
98708: LD_INT 31
98710: PUSH
98711: LD_INT 32
98713: PUSH
98714: LD_INT 33
98716: PUSH
98717: LD_INT 34
98719: PUSH
98720: LD_INT 36
98722: PUSH
98723: EMPTY
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: LIST
98730: LIST
98731: LIST
98732: LIST
98733: LIST
98734: LIST
98735: LIST
98736: LIST
98737: LIST
98738: LIST
98739: LIST
98740: LIST
98741: LIST
98742: LIST
98743: LIST
98744: LIST
98745: LIST
98746: LIST
98747: LIST
98748: LIST
98749: LIST
98750: LIST
98751: LIST
98752: LIST
98753: LIST
98754: LIST
98755: LIST
98756: LIST
98757: LIST
98758: LIST
98759: PUSH
98760: LD_INT 101
98762: PUSH
98763: LD_INT 102
98765: PUSH
98766: LD_INT 103
98768: PUSH
98769: LD_INT 104
98771: PUSH
98772: LD_INT 105
98774: PUSH
98775: LD_INT 106
98777: PUSH
98778: LD_INT 107
98780: PUSH
98781: LD_INT 108
98783: PUSH
98784: LD_INT 109
98786: PUSH
98787: LD_INT 110
98789: PUSH
98790: LD_INT 111
98792: PUSH
98793: LD_INT 112
98795: PUSH
98796: LD_INT 113
98798: PUSH
98799: LD_INT 114
98801: PUSH
98802: LD_INT 116
98804: PUSH
98805: LD_INT 117
98807: PUSH
98808: LD_INT 118
98810: PUSH
98811: EMPTY
98812: LIST
98813: LIST
98814: LIST
98815: LIST
98816: LIST
98817: LIST
98818: LIST
98819: LIST
98820: LIST
98821: LIST
98822: LIST
98823: LIST
98824: LIST
98825: LIST
98826: LIST
98827: LIST
98828: LIST
98829: PUSH
98830: EMPTY
98831: LIST
98832: LIST
98833: ST_TO_ADDR
98834: GO 99841
98836: LD_INT 15
98838: DOUBLE
98839: EQUAL
98840: IFTRUE 98844
98842: GO 99068
98844: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
98845: LD_ADDR_VAR 0 2
98849: PUSH
98850: LD_INT 1
98852: PUSH
98853: LD_INT 2
98855: PUSH
98856: LD_INT 3
98858: PUSH
98859: LD_INT 4
98861: PUSH
98862: LD_INT 5
98864: PUSH
98865: LD_INT 6
98867: PUSH
98868: LD_INT 7
98870: PUSH
98871: LD_INT 8
98873: PUSH
98874: LD_INT 9
98876: PUSH
98877: LD_INT 10
98879: PUSH
98880: LD_INT 11
98882: PUSH
98883: LD_INT 12
98885: PUSH
98886: LD_INT 13
98888: PUSH
98889: LD_INT 14
98891: PUSH
98892: LD_INT 15
98894: PUSH
98895: LD_INT 16
98897: PUSH
98898: LD_INT 17
98900: PUSH
98901: LD_INT 18
98903: PUSH
98904: LD_INT 19
98906: PUSH
98907: LD_INT 20
98909: PUSH
98910: LD_INT 21
98912: PUSH
98913: LD_INT 22
98915: PUSH
98916: LD_INT 23
98918: PUSH
98919: LD_INT 24
98921: PUSH
98922: LD_INT 25
98924: PUSH
98925: LD_INT 26
98927: PUSH
98928: LD_INT 27
98930: PUSH
98931: LD_INT 28
98933: PUSH
98934: LD_INT 29
98936: PUSH
98937: LD_INT 30
98939: PUSH
98940: LD_INT 31
98942: PUSH
98943: LD_INT 32
98945: PUSH
98946: LD_INT 33
98948: PUSH
98949: LD_INT 34
98951: PUSH
98952: LD_INT 36
98954: PUSH
98955: EMPTY
98956: LIST
98957: LIST
98958: LIST
98959: LIST
98960: LIST
98961: LIST
98962: LIST
98963: LIST
98964: LIST
98965: LIST
98966: LIST
98967: LIST
98968: LIST
98969: LIST
98970: LIST
98971: LIST
98972: LIST
98973: LIST
98974: LIST
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: LIST
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: LIST
98986: LIST
98987: LIST
98988: LIST
98989: LIST
98990: LIST
98991: PUSH
98992: LD_INT 101
98994: PUSH
98995: LD_INT 102
98997: PUSH
98998: LD_INT 103
99000: PUSH
99001: LD_INT 104
99003: PUSH
99004: LD_INT 105
99006: PUSH
99007: LD_INT 106
99009: PUSH
99010: LD_INT 107
99012: PUSH
99013: LD_INT 108
99015: PUSH
99016: LD_INT 109
99018: PUSH
99019: LD_INT 110
99021: PUSH
99022: LD_INT 111
99024: PUSH
99025: LD_INT 112
99027: PUSH
99028: LD_INT 113
99030: PUSH
99031: LD_INT 114
99033: PUSH
99034: LD_INT 116
99036: PUSH
99037: LD_INT 117
99039: PUSH
99040: LD_INT 118
99042: PUSH
99043: EMPTY
99044: LIST
99045: LIST
99046: LIST
99047: LIST
99048: LIST
99049: LIST
99050: LIST
99051: LIST
99052: LIST
99053: LIST
99054: LIST
99055: LIST
99056: LIST
99057: LIST
99058: LIST
99059: LIST
99060: LIST
99061: PUSH
99062: EMPTY
99063: LIST
99064: LIST
99065: ST_TO_ADDR
99066: GO 99841
99068: LD_INT 16
99070: DOUBLE
99071: EQUAL
99072: IFTRUE 99076
99074: GO 99212
99076: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
99077: LD_ADDR_VAR 0 2
99081: PUSH
99082: LD_INT 2
99084: PUSH
99085: LD_INT 4
99087: PUSH
99088: LD_INT 5
99090: PUSH
99091: LD_INT 7
99093: PUSH
99094: LD_INT 11
99096: PUSH
99097: LD_INT 12
99099: PUSH
99100: LD_INT 15
99102: PUSH
99103: LD_INT 16
99105: PUSH
99106: LD_INT 20
99108: PUSH
99109: LD_INT 21
99111: PUSH
99112: LD_INT 22
99114: PUSH
99115: LD_INT 23
99117: PUSH
99118: LD_INT 25
99120: PUSH
99121: LD_INT 26
99123: PUSH
99124: LD_INT 30
99126: PUSH
99127: LD_INT 31
99129: PUSH
99130: LD_INT 32
99132: PUSH
99133: LD_INT 33
99135: PUSH
99136: LD_INT 34
99138: PUSH
99139: EMPTY
99140: LIST
99141: LIST
99142: LIST
99143: LIST
99144: LIST
99145: LIST
99146: LIST
99147: LIST
99148: LIST
99149: LIST
99150: LIST
99151: LIST
99152: LIST
99153: LIST
99154: LIST
99155: LIST
99156: LIST
99157: LIST
99158: LIST
99159: PUSH
99160: LD_INT 101
99162: PUSH
99163: LD_INT 102
99165: PUSH
99166: LD_INT 103
99168: PUSH
99169: LD_INT 106
99171: PUSH
99172: LD_INT 108
99174: PUSH
99175: LD_INT 112
99177: PUSH
99178: LD_INT 113
99180: PUSH
99181: LD_INT 114
99183: PUSH
99184: LD_INT 116
99186: PUSH
99187: LD_INT 117
99189: PUSH
99190: LD_INT 118
99192: PUSH
99193: EMPTY
99194: LIST
99195: LIST
99196: LIST
99197: LIST
99198: LIST
99199: LIST
99200: LIST
99201: LIST
99202: LIST
99203: LIST
99204: LIST
99205: PUSH
99206: EMPTY
99207: LIST
99208: LIST
99209: ST_TO_ADDR
99210: GO 99841
99212: LD_INT 17
99214: DOUBLE
99215: EQUAL
99216: IFTRUE 99220
99218: GO 99444
99220: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
99221: LD_ADDR_VAR 0 2
99225: PUSH
99226: LD_INT 1
99228: PUSH
99229: LD_INT 2
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: LD_INT 4
99237: PUSH
99238: LD_INT 5
99240: PUSH
99241: LD_INT 6
99243: PUSH
99244: LD_INT 7
99246: PUSH
99247: LD_INT 8
99249: PUSH
99250: LD_INT 9
99252: PUSH
99253: LD_INT 10
99255: PUSH
99256: LD_INT 11
99258: PUSH
99259: LD_INT 12
99261: PUSH
99262: LD_INT 13
99264: PUSH
99265: LD_INT 14
99267: PUSH
99268: LD_INT 15
99270: PUSH
99271: LD_INT 16
99273: PUSH
99274: LD_INT 17
99276: PUSH
99277: LD_INT 18
99279: PUSH
99280: LD_INT 19
99282: PUSH
99283: LD_INT 20
99285: PUSH
99286: LD_INT 21
99288: PUSH
99289: LD_INT 22
99291: PUSH
99292: LD_INT 23
99294: PUSH
99295: LD_INT 24
99297: PUSH
99298: LD_INT 25
99300: PUSH
99301: LD_INT 26
99303: PUSH
99304: LD_INT 27
99306: PUSH
99307: LD_INT 28
99309: PUSH
99310: LD_INT 29
99312: PUSH
99313: LD_INT 30
99315: PUSH
99316: LD_INT 31
99318: PUSH
99319: LD_INT 32
99321: PUSH
99322: LD_INT 33
99324: PUSH
99325: LD_INT 34
99327: PUSH
99328: LD_INT 36
99330: PUSH
99331: EMPTY
99332: LIST
99333: LIST
99334: LIST
99335: LIST
99336: LIST
99337: LIST
99338: LIST
99339: LIST
99340: LIST
99341: LIST
99342: LIST
99343: LIST
99344: LIST
99345: LIST
99346: LIST
99347: LIST
99348: LIST
99349: LIST
99350: LIST
99351: LIST
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: LIST
99357: LIST
99358: LIST
99359: LIST
99360: LIST
99361: LIST
99362: LIST
99363: LIST
99364: LIST
99365: LIST
99366: LIST
99367: PUSH
99368: LD_INT 101
99370: PUSH
99371: LD_INT 102
99373: PUSH
99374: LD_INT 103
99376: PUSH
99377: LD_INT 104
99379: PUSH
99380: LD_INT 105
99382: PUSH
99383: LD_INT 106
99385: PUSH
99386: LD_INT 107
99388: PUSH
99389: LD_INT 108
99391: PUSH
99392: LD_INT 109
99394: PUSH
99395: LD_INT 110
99397: PUSH
99398: LD_INT 111
99400: PUSH
99401: LD_INT 112
99403: PUSH
99404: LD_INT 113
99406: PUSH
99407: LD_INT 114
99409: PUSH
99410: LD_INT 116
99412: PUSH
99413: LD_INT 117
99415: PUSH
99416: LD_INT 118
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: LIST
99423: LIST
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: LIST
99430: LIST
99431: LIST
99432: LIST
99433: LIST
99434: LIST
99435: LIST
99436: LIST
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: ST_TO_ADDR
99442: GO 99841
99444: LD_INT 18
99446: DOUBLE
99447: EQUAL
99448: IFTRUE 99452
99450: GO 99600
99452: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
99453: LD_ADDR_VAR 0 2
99457: PUSH
99458: LD_INT 2
99460: PUSH
99461: LD_INT 4
99463: PUSH
99464: LD_INT 5
99466: PUSH
99467: LD_INT 7
99469: PUSH
99470: LD_INT 11
99472: PUSH
99473: LD_INT 12
99475: PUSH
99476: LD_INT 15
99478: PUSH
99479: LD_INT 16
99481: PUSH
99482: LD_INT 20
99484: PUSH
99485: LD_INT 21
99487: PUSH
99488: LD_INT 22
99490: PUSH
99491: LD_INT 23
99493: PUSH
99494: LD_INT 25
99496: PUSH
99497: LD_INT 26
99499: PUSH
99500: LD_INT 30
99502: PUSH
99503: LD_INT 31
99505: PUSH
99506: LD_INT 32
99508: PUSH
99509: LD_INT 33
99511: PUSH
99512: LD_INT 34
99514: PUSH
99515: LD_INT 35
99517: PUSH
99518: LD_INT 36
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: LIST
99525: LIST
99526: LIST
99527: LIST
99528: LIST
99529: LIST
99530: LIST
99531: LIST
99532: LIST
99533: LIST
99534: LIST
99535: LIST
99536: LIST
99537: LIST
99538: LIST
99539: LIST
99540: LIST
99541: LIST
99542: LIST
99543: PUSH
99544: LD_INT 101
99546: PUSH
99547: LD_INT 102
99549: PUSH
99550: LD_INT 103
99552: PUSH
99553: LD_INT 106
99555: PUSH
99556: LD_INT 108
99558: PUSH
99559: LD_INT 112
99561: PUSH
99562: LD_INT 113
99564: PUSH
99565: LD_INT 114
99567: PUSH
99568: LD_INT 115
99570: PUSH
99571: LD_INT 116
99573: PUSH
99574: LD_INT 117
99576: PUSH
99577: LD_INT 118
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: LIST
99584: LIST
99585: LIST
99586: LIST
99587: LIST
99588: LIST
99589: LIST
99590: LIST
99591: LIST
99592: LIST
99593: PUSH
99594: EMPTY
99595: LIST
99596: LIST
99597: ST_TO_ADDR
99598: GO 99841
99600: LD_INT 19
99602: DOUBLE
99603: EQUAL
99604: IFTRUE 99608
99606: GO 99840
99608: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
99609: LD_ADDR_VAR 0 2
99613: PUSH
99614: LD_INT 1
99616: PUSH
99617: LD_INT 2
99619: PUSH
99620: LD_INT 3
99622: PUSH
99623: LD_INT 4
99625: PUSH
99626: LD_INT 5
99628: PUSH
99629: LD_INT 6
99631: PUSH
99632: LD_INT 7
99634: PUSH
99635: LD_INT 8
99637: PUSH
99638: LD_INT 9
99640: PUSH
99641: LD_INT 10
99643: PUSH
99644: LD_INT 11
99646: PUSH
99647: LD_INT 12
99649: PUSH
99650: LD_INT 13
99652: PUSH
99653: LD_INT 14
99655: PUSH
99656: LD_INT 15
99658: PUSH
99659: LD_INT 16
99661: PUSH
99662: LD_INT 17
99664: PUSH
99665: LD_INT 18
99667: PUSH
99668: LD_INT 19
99670: PUSH
99671: LD_INT 20
99673: PUSH
99674: LD_INT 21
99676: PUSH
99677: LD_INT 22
99679: PUSH
99680: LD_INT 23
99682: PUSH
99683: LD_INT 24
99685: PUSH
99686: LD_INT 25
99688: PUSH
99689: LD_INT 26
99691: PUSH
99692: LD_INT 27
99694: PUSH
99695: LD_INT 28
99697: PUSH
99698: LD_INT 29
99700: PUSH
99701: LD_INT 30
99703: PUSH
99704: LD_INT 31
99706: PUSH
99707: LD_INT 32
99709: PUSH
99710: LD_INT 33
99712: PUSH
99713: LD_INT 34
99715: PUSH
99716: LD_INT 35
99718: PUSH
99719: LD_INT 36
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: LIST
99726: LIST
99727: LIST
99728: LIST
99729: LIST
99730: LIST
99731: LIST
99732: LIST
99733: LIST
99734: LIST
99735: LIST
99736: LIST
99737: LIST
99738: LIST
99739: LIST
99740: LIST
99741: LIST
99742: LIST
99743: LIST
99744: LIST
99745: LIST
99746: LIST
99747: LIST
99748: LIST
99749: LIST
99750: LIST
99751: LIST
99752: LIST
99753: LIST
99754: LIST
99755: LIST
99756: LIST
99757: LIST
99758: LIST
99759: PUSH
99760: LD_INT 101
99762: PUSH
99763: LD_INT 102
99765: PUSH
99766: LD_INT 103
99768: PUSH
99769: LD_INT 104
99771: PUSH
99772: LD_INT 105
99774: PUSH
99775: LD_INT 106
99777: PUSH
99778: LD_INT 107
99780: PUSH
99781: LD_INT 108
99783: PUSH
99784: LD_INT 109
99786: PUSH
99787: LD_INT 110
99789: PUSH
99790: LD_INT 111
99792: PUSH
99793: LD_INT 112
99795: PUSH
99796: LD_INT 113
99798: PUSH
99799: LD_INT 114
99801: PUSH
99802: LD_INT 115
99804: PUSH
99805: LD_INT 116
99807: PUSH
99808: LD_INT 117
99810: PUSH
99811: LD_INT 118
99813: PUSH
99814: EMPTY
99815: LIST
99816: LIST
99817: LIST
99818: LIST
99819: LIST
99820: LIST
99821: LIST
99822: LIST
99823: LIST
99824: LIST
99825: LIST
99826: LIST
99827: LIST
99828: LIST
99829: LIST
99830: LIST
99831: LIST
99832: LIST
99833: PUSH
99834: EMPTY
99835: LIST
99836: LIST
99837: ST_TO_ADDR
99838: GO 99841
99840: POP
// end else
99841: GO 100072
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
99843: LD_ADDR_VAR 0 2
99847: PUSH
99848: LD_INT 1
99850: PUSH
99851: LD_INT 2
99853: PUSH
99854: LD_INT 3
99856: PUSH
99857: LD_INT 4
99859: PUSH
99860: LD_INT 5
99862: PUSH
99863: LD_INT 6
99865: PUSH
99866: LD_INT 7
99868: PUSH
99869: LD_INT 8
99871: PUSH
99872: LD_INT 9
99874: PUSH
99875: LD_INT 10
99877: PUSH
99878: LD_INT 11
99880: PUSH
99881: LD_INT 12
99883: PUSH
99884: LD_INT 13
99886: PUSH
99887: LD_INT 14
99889: PUSH
99890: LD_INT 15
99892: PUSH
99893: LD_INT 16
99895: PUSH
99896: LD_INT 17
99898: PUSH
99899: LD_INT 18
99901: PUSH
99902: LD_INT 19
99904: PUSH
99905: LD_INT 20
99907: PUSH
99908: LD_INT 21
99910: PUSH
99911: LD_INT 22
99913: PUSH
99914: LD_INT 23
99916: PUSH
99917: LD_INT 24
99919: PUSH
99920: LD_INT 25
99922: PUSH
99923: LD_INT 26
99925: PUSH
99926: LD_INT 27
99928: PUSH
99929: LD_INT 28
99931: PUSH
99932: LD_INT 29
99934: PUSH
99935: LD_INT 30
99937: PUSH
99938: LD_INT 31
99940: PUSH
99941: LD_INT 32
99943: PUSH
99944: LD_INT 33
99946: PUSH
99947: LD_INT 34
99949: PUSH
99950: LD_INT 35
99952: PUSH
99953: LD_INT 36
99955: PUSH
99956: EMPTY
99957: LIST
99958: LIST
99959: LIST
99960: LIST
99961: LIST
99962: LIST
99963: LIST
99964: LIST
99965: LIST
99966: LIST
99967: LIST
99968: LIST
99969: LIST
99970: LIST
99971: LIST
99972: LIST
99973: LIST
99974: LIST
99975: LIST
99976: LIST
99977: LIST
99978: LIST
99979: LIST
99980: LIST
99981: LIST
99982: LIST
99983: LIST
99984: LIST
99985: LIST
99986: LIST
99987: LIST
99988: LIST
99989: LIST
99990: LIST
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 101
99996: PUSH
99997: LD_INT 102
99999: PUSH
100000: LD_INT 103
100002: PUSH
100003: LD_INT 104
100005: PUSH
100006: LD_INT 105
100008: PUSH
100009: LD_INT 106
100011: PUSH
100012: LD_INT 107
100014: PUSH
100015: LD_INT 108
100017: PUSH
100018: LD_INT 109
100020: PUSH
100021: LD_INT 110
100023: PUSH
100024: LD_INT 111
100026: PUSH
100027: LD_INT 112
100029: PUSH
100030: LD_INT 113
100032: PUSH
100033: LD_INT 114
100035: PUSH
100036: LD_INT 115
100038: PUSH
100039: LD_INT 116
100041: PUSH
100042: LD_INT 117
100044: PUSH
100045: LD_INT 118
100047: PUSH
100048: EMPTY
100049: LIST
100050: LIST
100051: LIST
100052: LIST
100053: LIST
100054: LIST
100055: LIST
100056: LIST
100057: LIST
100058: LIST
100059: LIST
100060: LIST
100061: LIST
100062: LIST
100063: LIST
100064: LIST
100065: LIST
100066: LIST
100067: PUSH
100068: EMPTY
100069: LIST
100070: LIST
100071: ST_TO_ADDR
// if result then
100072: LD_VAR 0 2
100076: IFFALSE 100862
// begin normal :=  ;
100078: LD_ADDR_VAR 0 5
100082: PUSH
100083: LD_STRING 
100085: ST_TO_ADDR
// hardcore :=  ;
100086: LD_ADDR_VAR 0 6
100090: PUSH
100091: LD_STRING 
100093: ST_TO_ADDR
// active :=  ;
100094: LD_ADDR_VAR 0 7
100098: PUSH
100099: LD_STRING 
100101: ST_TO_ADDR
// for i = 1 to normalCounter do
100102: LD_ADDR_VAR 0 8
100106: PUSH
100107: DOUBLE
100108: LD_INT 1
100110: DEC
100111: ST_TO_ADDR
100112: LD_EXP 79
100116: PUSH
100117: FOR_TO
100118: IFFALSE 100219
// begin tmp := 0 ;
100120: LD_ADDR_VAR 0 3
100124: PUSH
100125: LD_STRING 0
100127: ST_TO_ADDR
// if result [ 1 ] then
100128: LD_VAR 0 2
100132: PUSH
100133: LD_INT 1
100135: ARRAY
100136: IFFALSE 100201
// if result [ 1 ] [ 1 ] = i then
100138: LD_VAR 0 2
100142: PUSH
100143: LD_INT 1
100145: ARRAY
100146: PUSH
100147: LD_INT 1
100149: ARRAY
100150: PUSH
100151: LD_VAR 0 8
100155: EQUAL
100156: IFFALSE 100201
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
100158: LD_ADDR_VAR 0 2
100162: PUSH
100163: LD_VAR 0 2
100167: PPUSH
100168: LD_INT 1
100170: PPUSH
100171: LD_VAR 0 2
100175: PUSH
100176: LD_INT 1
100178: ARRAY
100179: PPUSH
100180: LD_INT 1
100182: PPUSH
100183: CALL_OW 3
100187: PPUSH
100188: CALL_OW 1
100192: ST_TO_ADDR
// tmp := 1 ;
100193: LD_ADDR_VAR 0 3
100197: PUSH
100198: LD_STRING 1
100200: ST_TO_ADDR
// end ; normal := normal & tmp ;
100201: LD_ADDR_VAR 0 5
100205: PUSH
100206: LD_VAR 0 5
100210: PUSH
100211: LD_VAR 0 3
100215: STR
100216: ST_TO_ADDR
// end ;
100217: GO 100117
100219: POP
100220: POP
// for i = 1 to hardcoreCounter do
100221: LD_ADDR_VAR 0 8
100225: PUSH
100226: DOUBLE
100227: LD_INT 1
100229: DEC
100230: ST_TO_ADDR
100231: LD_EXP 80
100235: PUSH
100236: FOR_TO
100237: IFFALSE 100342
// begin tmp := 0 ;
100239: LD_ADDR_VAR 0 3
100243: PUSH
100244: LD_STRING 0
100246: ST_TO_ADDR
// if result [ 2 ] then
100247: LD_VAR 0 2
100251: PUSH
100252: LD_INT 2
100254: ARRAY
100255: IFFALSE 100324
// if result [ 2 ] [ 1 ] = 100 + i then
100257: LD_VAR 0 2
100261: PUSH
100262: LD_INT 2
100264: ARRAY
100265: PUSH
100266: LD_INT 1
100268: ARRAY
100269: PUSH
100270: LD_INT 100
100272: PUSH
100273: LD_VAR 0 8
100277: PLUS
100278: EQUAL
100279: IFFALSE 100324
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
100281: LD_ADDR_VAR 0 2
100285: PUSH
100286: LD_VAR 0 2
100290: PPUSH
100291: LD_INT 2
100293: PPUSH
100294: LD_VAR 0 2
100298: PUSH
100299: LD_INT 2
100301: ARRAY
100302: PPUSH
100303: LD_INT 1
100305: PPUSH
100306: CALL_OW 3
100310: PPUSH
100311: CALL_OW 1
100315: ST_TO_ADDR
// tmp := 1 ;
100316: LD_ADDR_VAR 0 3
100320: PUSH
100321: LD_STRING 1
100323: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
100324: LD_ADDR_VAR 0 6
100328: PUSH
100329: LD_VAR 0 6
100333: PUSH
100334: LD_VAR 0 3
100338: STR
100339: ST_TO_ADDR
// end ;
100340: GO 100236
100342: POP
100343: POP
// if isGameLoad then
100344: LD_VAR 0 1
100348: IFFALSE 100823
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
100350: LD_ADDR_VAR 0 4
100354: PUSH
100355: LD_EXP 83
100359: PUSH
100360: LD_EXP 82
100364: PUSH
100365: LD_EXP 84
100369: PUSH
100370: LD_EXP 81
100374: PUSH
100375: LD_EXP 85
100379: PUSH
100380: LD_EXP 86
100384: PUSH
100385: LD_EXP 87
100389: PUSH
100390: LD_EXP 88
100394: PUSH
100395: LD_EXP 89
100399: PUSH
100400: LD_EXP 90
100404: PUSH
100405: LD_EXP 91
100409: PUSH
100410: LD_EXP 92
100414: PUSH
100415: LD_EXP 93
100419: PUSH
100420: LD_EXP 94
100424: PUSH
100425: LD_EXP 102
100429: PUSH
100430: LD_EXP 103
100434: PUSH
100435: LD_EXP 104
100439: PUSH
100440: LD_EXP 105
100444: PUSH
100445: LD_EXP 107
100449: PUSH
100450: LD_EXP 108
100454: PUSH
100455: LD_EXP 109
100459: PUSH
100460: LD_EXP 112
100464: PUSH
100465: LD_EXP 114
100469: PUSH
100470: LD_EXP 115
100474: PUSH
100475: LD_EXP 116
100479: PUSH
100480: LD_EXP 118
100484: PUSH
100485: LD_EXP 119
100489: PUSH
100490: LD_EXP 122
100494: PUSH
100495: LD_EXP 123
100499: PUSH
100500: LD_EXP 124
100504: PUSH
100505: LD_EXP 125
100509: PUSH
100510: LD_EXP 126
100514: PUSH
100515: LD_EXP 127
100519: PUSH
100520: LD_EXP 128
100524: PUSH
100525: LD_EXP 129
100529: PUSH
100530: LD_EXP 130
100534: PUSH
100535: LD_EXP 95
100539: PUSH
100540: LD_EXP 96
100544: PUSH
100545: LD_EXP 99
100549: PUSH
100550: LD_EXP 100
100554: PUSH
100555: LD_EXP 101
100559: PUSH
100560: LD_EXP 97
100564: PUSH
100565: LD_EXP 98
100569: PUSH
100570: LD_EXP 106
100574: PUSH
100575: LD_EXP 110
100579: PUSH
100580: LD_EXP 111
100584: PUSH
100585: LD_EXP 113
100589: PUSH
100590: LD_EXP 117
100594: PUSH
100595: LD_EXP 120
100599: PUSH
100600: LD_EXP 121
100604: PUSH
100605: LD_EXP 131
100609: PUSH
100610: LD_EXP 132
100614: PUSH
100615: LD_EXP 133
100619: PUSH
100620: LD_EXP 134
100624: PUSH
100625: EMPTY
100626: LIST
100627: LIST
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: LIST
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: LIST
100640: LIST
100641: LIST
100642: LIST
100643: LIST
100644: LIST
100645: LIST
100646: LIST
100647: LIST
100648: LIST
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: LIST
100655: LIST
100656: LIST
100657: LIST
100658: LIST
100659: LIST
100660: LIST
100661: LIST
100662: LIST
100663: LIST
100664: LIST
100665: LIST
100666: LIST
100667: LIST
100668: LIST
100669: LIST
100670: LIST
100671: LIST
100672: LIST
100673: LIST
100674: LIST
100675: LIST
100676: LIST
100677: LIST
100678: LIST
100679: LIST
100680: ST_TO_ADDR
// tmp :=  ;
100681: LD_ADDR_VAR 0 3
100685: PUSH
100686: LD_STRING 
100688: ST_TO_ADDR
// for i = 1 to normalCounter do
100689: LD_ADDR_VAR 0 8
100693: PUSH
100694: DOUBLE
100695: LD_INT 1
100697: DEC
100698: ST_TO_ADDR
100699: LD_EXP 79
100703: PUSH
100704: FOR_TO
100705: IFFALSE 100741
// begin if flags [ i ] then
100707: LD_VAR 0 4
100711: PUSH
100712: LD_VAR 0 8
100716: ARRAY
100717: IFFALSE 100739
// tmp := tmp & i & ; ;
100719: LD_ADDR_VAR 0 3
100723: PUSH
100724: LD_VAR 0 3
100728: PUSH
100729: LD_VAR 0 8
100733: STR
100734: PUSH
100735: LD_STRING ;
100737: STR
100738: ST_TO_ADDR
// end ;
100739: GO 100704
100741: POP
100742: POP
// for i = 1 to hardcoreCounter do
100743: LD_ADDR_VAR 0 8
100747: PUSH
100748: DOUBLE
100749: LD_INT 1
100751: DEC
100752: ST_TO_ADDR
100753: LD_EXP 80
100757: PUSH
100758: FOR_TO
100759: IFFALSE 100805
// begin if flags [ normalCounter + i ] then
100761: LD_VAR 0 4
100765: PUSH
100766: LD_EXP 79
100770: PUSH
100771: LD_VAR 0 8
100775: PLUS
100776: ARRAY
100777: IFFALSE 100803
// tmp := tmp & ( 100 + i ) & ; ;
100779: LD_ADDR_VAR 0 3
100783: PUSH
100784: LD_VAR 0 3
100788: PUSH
100789: LD_INT 100
100791: PUSH
100792: LD_VAR 0 8
100796: PLUS
100797: STR
100798: PUSH
100799: LD_STRING ;
100801: STR
100802: ST_TO_ADDR
// end ;
100803: GO 100758
100805: POP
100806: POP
// if tmp then
100807: LD_VAR 0 3
100811: IFFALSE 100823
// active := tmp ;
100813: LD_ADDR_VAR 0 7
100817: PUSH
100818: LD_VAR 0 3
100822: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
100823: LD_STRING getStreamItemsFromMission("
100825: PUSH
100826: LD_VAR 0 5
100830: STR
100831: PUSH
100832: LD_STRING ","
100834: STR
100835: PUSH
100836: LD_VAR 0 6
100840: STR
100841: PUSH
100842: LD_STRING ","
100844: STR
100845: PUSH
100846: LD_VAR 0 7
100850: STR
100851: PUSH
100852: LD_STRING ")
100854: STR
100855: PPUSH
100856: CALL_OW 559
// end else
100860: GO 100869
// ToLua ( getStreamItemsFromMission("","","") ) ;
100862: LD_STRING getStreamItemsFromMission("","","")
100864: PPUSH
100865: CALL_OW 559
// end ;
100869: LD_VAR 0 2
100873: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
100874: LD_EXP 78
100878: PUSH
100879: LD_EXP 83
100883: AND
100884: IFFALSE 101008
100886: GO 100888
100888: DISABLE
100889: LD_INT 0
100891: PPUSH
100892: PPUSH
// begin enable ;
100893: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
100894: LD_ADDR_VAR 0 2
100898: PUSH
100899: LD_INT 22
100901: PUSH
100902: LD_OWVAR 2
100906: PUSH
100907: EMPTY
100908: LIST
100909: LIST
100910: PUSH
100911: LD_INT 2
100913: PUSH
100914: LD_INT 34
100916: PUSH
100917: LD_INT 7
100919: PUSH
100920: EMPTY
100921: LIST
100922: LIST
100923: PUSH
100924: LD_INT 34
100926: PUSH
100927: LD_INT 45
100929: PUSH
100930: EMPTY
100931: LIST
100932: LIST
100933: PUSH
100934: LD_INT 34
100936: PUSH
100937: LD_INT 28
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: PUSH
100944: LD_INT 34
100946: PUSH
100947: LD_INT 47
100949: PUSH
100950: EMPTY
100951: LIST
100952: LIST
100953: PUSH
100954: EMPTY
100955: LIST
100956: LIST
100957: LIST
100958: LIST
100959: LIST
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: PPUSH
100965: CALL_OW 69
100969: ST_TO_ADDR
// if not tmp then
100970: LD_VAR 0 2
100974: NOT
100975: IFFALSE 100979
// exit ;
100977: GO 101008
// for i in tmp do
100979: LD_ADDR_VAR 0 1
100983: PUSH
100984: LD_VAR 0 2
100988: PUSH
100989: FOR_IN
100990: IFFALSE 101006
// begin SetLives ( i , 0 ) ;
100992: LD_VAR 0 1
100996: PPUSH
100997: LD_INT 0
100999: PPUSH
101000: CALL_OW 234
// end ;
101004: GO 100989
101006: POP
101007: POP
// end ;
101008: PPOPN 2
101010: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
101011: LD_EXP 78
101015: PUSH
101016: LD_EXP 84
101020: AND
101021: IFFALSE 101105
101023: GO 101025
101025: DISABLE
101026: LD_INT 0
101028: PPUSH
101029: PPUSH
// begin enable ;
101030: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
101031: LD_ADDR_VAR 0 2
101035: PUSH
101036: LD_INT 22
101038: PUSH
101039: LD_OWVAR 2
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: PUSH
101048: LD_INT 32
101050: PUSH
101051: LD_INT 3
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: PUSH
101058: EMPTY
101059: LIST
101060: LIST
101061: PPUSH
101062: CALL_OW 69
101066: ST_TO_ADDR
// if not tmp then
101067: LD_VAR 0 2
101071: NOT
101072: IFFALSE 101076
// exit ;
101074: GO 101105
// for i in tmp do
101076: LD_ADDR_VAR 0 1
101080: PUSH
101081: LD_VAR 0 2
101085: PUSH
101086: FOR_IN
101087: IFFALSE 101103
// begin SetLives ( i , 0 ) ;
101089: LD_VAR 0 1
101093: PPUSH
101094: LD_INT 0
101096: PPUSH
101097: CALL_OW 234
// end ;
101101: GO 101086
101103: POP
101104: POP
// end ;
101105: PPOPN 2
101107: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
101108: LD_EXP 78
101112: PUSH
101113: LD_EXP 81
101117: AND
101118: IFFALSE 101211
101120: GO 101122
101122: DISABLE
101123: LD_INT 0
101125: PPUSH
// begin enable ;
101126: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
101127: LD_ADDR_VAR 0 1
101131: PUSH
101132: LD_INT 22
101134: PUSH
101135: LD_OWVAR 2
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: PUSH
101144: LD_INT 2
101146: PUSH
101147: LD_INT 25
101149: PUSH
101150: LD_INT 5
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: PUSH
101157: LD_INT 25
101159: PUSH
101160: LD_INT 9
101162: PUSH
101163: EMPTY
101164: LIST
101165: LIST
101166: PUSH
101167: LD_INT 25
101169: PUSH
101170: LD_INT 8
101172: PUSH
101173: EMPTY
101174: LIST
101175: LIST
101176: PUSH
101177: EMPTY
101178: LIST
101179: LIST
101180: LIST
101181: LIST
101182: PUSH
101183: EMPTY
101184: LIST
101185: LIST
101186: PPUSH
101187: CALL_OW 69
101191: PUSH
101192: FOR_IN
101193: IFFALSE 101209
// begin SetClass ( i , 1 ) ;
101195: LD_VAR 0 1
101199: PPUSH
101200: LD_INT 1
101202: PPUSH
101203: CALL_OW 336
// end ;
101207: GO 101192
101209: POP
101210: POP
// end ;
101211: PPOPN 1
101213: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
101214: LD_EXP 78
101218: PUSH
101219: LD_EXP 82
101223: AND
101224: PUSH
101225: LD_OWVAR 65
101229: PUSH
101230: LD_INT 7
101232: LESS
101233: AND
101234: IFFALSE 101248
101236: GO 101238
101238: DISABLE
// begin enable ;
101239: ENABLE
// game_speed := 7 ;
101240: LD_ADDR_OWVAR 65
101244: PUSH
101245: LD_INT 7
101247: ST_TO_ADDR
// end ;
101248: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
101249: LD_EXP 78
101253: PUSH
101254: LD_EXP 85
101258: AND
101259: IFFALSE 101461
101261: GO 101263
101263: DISABLE
101264: LD_INT 0
101266: PPUSH
101267: PPUSH
101268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
101269: LD_ADDR_VAR 0 3
101273: PUSH
101274: LD_INT 81
101276: PUSH
101277: LD_OWVAR 2
101281: PUSH
101282: EMPTY
101283: LIST
101284: LIST
101285: PUSH
101286: LD_INT 21
101288: PUSH
101289: LD_INT 1
101291: PUSH
101292: EMPTY
101293: LIST
101294: LIST
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PPUSH
101300: CALL_OW 69
101304: ST_TO_ADDR
// if not tmp then
101305: LD_VAR 0 3
101309: NOT
101310: IFFALSE 101314
// exit ;
101312: GO 101461
// if tmp > 5 then
101314: LD_VAR 0 3
101318: PUSH
101319: LD_INT 5
101321: GREATER
101322: IFFALSE 101334
// k := 5 else
101324: LD_ADDR_VAR 0 2
101328: PUSH
101329: LD_INT 5
101331: ST_TO_ADDR
101332: GO 101344
// k := tmp ;
101334: LD_ADDR_VAR 0 2
101338: PUSH
101339: LD_VAR 0 3
101343: ST_TO_ADDR
// for i := 1 to k do
101344: LD_ADDR_VAR 0 1
101348: PUSH
101349: DOUBLE
101350: LD_INT 1
101352: DEC
101353: ST_TO_ADDR
101354: LD_VAR 0 2
101358: PUSH
101359: FOR_TO
101360: IFFALSE 101459
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
101362: LD_VAR 0 3
101366: PUSH
101367: LD_VAR 0 1
101371: ARRAY
101372: PPUSH
101373: LD_VAR 0 1
101377: PUSH
101378: LD_INT 4
101380: MOD
101381: PUSH
101382: LD_INT 1
101384: PLUS
101385: PPUSH
101386: CALL_OW 259
101390: PUSH
101391: LD_INT 10
101393: LESS
101394: IFFALSE 101457
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
101396: LD_VAR 0 3
101400: PUSH
101401: LD_VAR 0 1
101405: ARRAY
101406: PPUSH
101407: LD_VAR 0 1
101411: PUSH
101412: LD_INT 4
101414: MOD
101415: PUSH
101416: LD_INT 1
101418: PLUS
101419: PPUSH
101420: LD_VAR 0 3
101424: PUSH
101425: LD_VAR 0 1
101429: ARRAY
101430: PPUSH
101431: LD_VAR 0 1
101435: PUSH
101436: LD_INT 4
101438: MOD
101439: PUSH
101440: LD_INT 1
101442: PLUS
101443: PPUSH
101444: CALL_OW 259
101448: PUSH
101449: LD_INT 1
101451: PLUS
101452: PPUSH
101453: CALL_OW 237
101457: GO 101359
101459: POP
101460: POP
// end ;
101461: PPOPN 3
101463: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
101464: LD_EXP 78
101468: PUSH
101469: LD_EXP 86
101473: AND
101474: IFFALSE 101494
101476: GO 101478
101478: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
101479: LD_INT 4
101481: PPUSH
101482: LD_OWVAR 2
101486: PPUSH
101487: LD_INT 0
101489: PPUSH
101490: CALL_OW 324
101494: END
// every 0 0$1 trigger StreamModeActive and sShovel do
101495: LD_EXP 78
101499: PUSH
101500: LD_EXP 115
101504: AND
101505: IFFALSE 101525
101507: GO 101509
101509: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
101510: LD_INT 19
101512: PPUSH
101513: LD_OWVAR 2
101517: PPUSH
101518: LD_INT 0
101520: PPUSH
101521: CALL_OW 324
101525: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
101526: LD_EXP 78
101530: PUSH
101531: LD_EXP 87
101535: AND
101536: IFFALSE 101638
101538: GO 101540
101540: DISABLE
101541: LD_INT 0
101543: PPUSH
101544: PPUSH
// begin enable ;
101545: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
101546: LD_ADDR_VAR 0 2
101550: PUSH
101551: LD_INT 22
101553: PUSH
101554: LD_OWVAR 2
101558: PUSH
101559: EMPTY
101560: LIST
101561: LIST
101562: PUSH
101563: LD_INT 2
101565: PUSH
101566: LD_INT 34
101568: PUSH
101569: LD_INT 11
101571: PUSH
101572: EMPTY
101573: LIST
101574: LIST
101575: PUSH
101576: LD_INT 34
101578: PUSH
101579: LD_INT 30
101581: PUSH
101582: EMPTY
101583: LIST
101584: LIST
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: LIST
101590: PUSH
101591: EMPTY
101592: LIST
101593: LIST
101594: PPUSH
101595: CALL_OW 69
101599: ST_TO_ADDR
// if not tmp then
101600: LD_VAR 0 2
101604: NOT
101605: IFFALSE 101609
// exit ;
101607: GO 101638
// for i in tmp do
101609: LD_ADDR_VAR 0 1
101613: PUSH
101614: LD_VAR 0 2
101618: PUSH
101619: FOR_IN
101620: IFFALSE 101636
// begin SetLives ( i , 0 ) ;
101622: LD_VAR 0 1
101626: PPUSH
101627: LD_INT 0
101629: PPUSH
101630: CALL_OW 234
// end ;
101634: GO 101619
101636: POP
101637: POP
// end ;
101638: PPOPN 2
101640: END
// every 0 0$1 trigger StreamModeActive and sBunker do
101641: LD_EXP 78
101645: PUSH
101646: LD_EXP 88
101650: AND
101651: IFFALSE 101671
101653: GO 101655
101655: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
101656: LD_INT 32
101658: PPUSH
101659: LD_OWVAR 2
101663: PPUSH
101664: LD_INT 0
101666: PPUSH
101667: CALL_OW 324
101671: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
101672: LD_EXP 78
101676: PUSH
101677: LD_EXP 89
101681: AND
101682: IFFALSE 101863
101684: GO 101686
101686: DISABLE
101687: LD_INT 0
101689: PPUSH
101690: PPUSH
101691: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
101692: LD_ADDR_VAR 0 2
101696: PUSH
101697: LD_INT 22
101699: PUSH
101700: LD_OWVAR 2
101704: PUSH
101705: EMPTY
101706: LIST
101707: LIST
101708: PUSH
101709: LD_INT 33
101711: PUSH
101712: LD_INT 3
101714: PUSH
101715: EMPTY
101716: LIST
101717: LIST
101718: PUSH
101719: EMPTY
101720: LIST
101721: LIST
101722: PPUSH
101723: CALL_OW 69
101727: ST_TO_ADDR
// if not tmp then
101728: LD_VAR 0 2
101732: NOT
101733: IFFALSE 101737
// exit ;
101735: GO 101863
// side := 0 ;
101737: LD_ADDR_VAR 0 3
101741: PUSH
101742: LD_INT 0
101744: ST_TO_ADDR
// for i := 1 to 8 do
101745: LD_ADDR_VAR 0 1
101749: PUSH
101750: DOUBLE
101751: LD_INT 1
101753: DEC
101754: ST_TO_ADDR
101755: LD_INT 8
101757: PUSH
101758: FOR_TO
101759: IFFALSE 101807
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
101761: LD_OWVAR 2
101765: PUSH
101766: LD_VAR 0 1
101770: NONEQUAL
101771: PUSH
101772: LD_OWVAR 2
101776: PPUSH
101777: LD_VAR 0 1
101781: PPUSH
101782: CALL_OW 81
101786: PUSH
101787: LD_INT 2
101789: EQUAL
101790: AND
101791: IFFALSE 101805
// begin side := i ;
101793: LD_ADDR_VAR 0 3
101797: PUSH
101798: LD_VAR 0 1
101802: ST_TO_ADDR
// break ;
101803: GO 101807
// end ;
101805: GO 101758
101807: POP
101808: POP
// if not side then
101809: LD_VAR 0 3
101813: NOT
101814: IFFALSE 101818
// exit ;
101816: GO 101863
// for i := 1 to tmp do
101818: LD_ADDR_VAR 0 1
101822: PUSH
101823: DOUBLE
101824: LD_INT 1
101826: DEC
101827: ST_TO_ADDR
101828: LD_VAR 0 2
101832: PUSH
101833: FOR_TO
101834: IFFALSE 101861
// if Prob ( 60 ) then
101836: LD_INT 60
101838: PPUSH
101839: CALL_OW 13
101843: IFFALSE 101859
// SetSide ( i , side ) ;
101845: LD_VAR 0 1
101849: PPUSH
101850: LD_VAR 0 3
101854: PPUSH
101855: CALL_OW 235
101859: GO 101833
101861: POP
101862: POP
// end ;
101863: PPOPN 3
101865: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
101866: LD_EXP 78
101870: PUSH
101871: LD_EXP 91
101875: AND
101876: IFFALSE 101995
101878: GO 101880
101880: DISABLE
101881: LD_INT 0
101883: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
101884: LD_ADDR_VAR 0 1
101888: PUSH
101889: LD_INT 22
101891: PUSH
101892: LD_OWVAR 2
101896: PUSH
101897: EMPTY
101898: LIST
101899: LIST
101900: PUSH
101901: LD_INT 21
101903: PUSH
101904: LD_INT 1
101906: PUSH
101907: EMPTY
101908: LIST
101909: LIST
101910: PUSH
101911: LD_INT 3
101913: PUSH
101914: LD_INT 23
101916: PUSH
101917: LD_INT 0
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: PUSH
101924: EMPTY
101925: LIST
101926: LIST
101927: PUSH
101928: EMPTY
101929: LIST
101930: LIST
101931: LIST
101932: PPUSH
101933: CALL_OW 69
101937: PUSH
101938: FOR_IN
101939: IFFALSE 101993
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
101941: LD_VAR 0 1
101945: PPUSH
101946: CALL_OW 257
101950: PUSH
101951: LD_INT 1
101953: PUSH
101954: LD_INT 2
101956: PUSH
101957: LD_INT 3
101959: PUSH
101960: LD_INT 4
101962: PUSH
101963: EMPTY
101964: LIST
101965: LIST
101966: LIST
101967: LIST
101968: IN
101969: IFFALSE 101991
// SetClass ( un , rand ( 1 , 4 ) ) ;
101971: LD_VAR 0 1
101975: PPUSH
101976: LD_INT 1
101978: PPUSH
101979: LD_INT 4
101981: PPUSH
101982: CALL_OW 12
101986: PPUSH
101987: CALL_OW 336
101991: GO 101938
101993: POP
101994: POP
// end ;
101995: PPOPN 1
101997: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
101998: LD_EXP 78
102002: PUSH
102003: LD_EXP 90
102007: AND
102008: IFFALSE 102087
102010: GO 102012
102012: DISABLE
102013: LD_INT 0
102015: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102016: LD_ADDR_VAR 0 1
102020: PUSH
102021: LD_INT 22
102023: PUSH
102024: LD_OWVAR 2
102028: PUSH
102029: EMPTY
102030: LIST
102031: LIST
102032: PUSH
102033: LD_INT 21
102035: PUSH
102036: LD_INT 3
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: PUSH
102043: EMPTY
102044: LIST
102045: LIST
102046: PPUSH
102047: CALL_OW 69
102051: ST_TO_ADDR
// if not tmp then
102052: LD_VAR 0 1
102056: NOT
102057: IFFALSE 102061
// exit ;
102059: GO 102087
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
102061: LD_VAR 0 1
102065: PUSH
102066: LD_INT 1
102068: PPUSH
102069: LD_VAR 0 1
102073: PPUSH
102074: CALL_OW 12
102078: ARRAY
102079: PPUSH
102080: LD_INT 100
102082: PPUSH
102083: CALL_OW 234
// end ;
102087: PPOPN 1
102089: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
102090: LD_EXP 78
102094: PUSH
102095: LD_EXP 92
102099: AND
102100: IFFALSE 102198
102102: GO 102104
102104: DISABLE
102105: LD_INT 0
102107: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
102108: LD_ADDR_VAR 0 1
102112: PUSH
102113: LD_INT 22
102115: PUSH
102116: LD_OWVAR 2
102120: PUSH
102121: EMPTY
102122: LIST
102123: LIST
102124: PUSH
102125: LD_INT 21
102127: PUSH
102128: LD_INT 1
102130: PUSH
102131: EMPTY
102132: LIST
102133: LIST
102134: PUSH
102135: EMPTY
102136: LIST
102137: LIST
102138: PPUSH
102139: CALL_OW 69
102143: ST_TO_ADDR
// if not tmp then
102144: LD_VAR 0 1
102148: NOT
102149: IFFALSE 102153
// exit ;
102151: GO 102198
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
102153: LD_VAR 0 1
102157: PUSH
102158: LD_INT 1
102160: PPUSH
102161: LD_VAR 0 1
102165: PPUSH
102166: CALL_OW 12
102170: ARRAY
102171: PPUSH
102172: LD_INT 1
102174: PPUSH
102175: LD_INT 4
102177: PPUSH
102178: CALL_OW 12
102182: PPUSH
102183: LD_INT 3000
102185: PPUSH
102186: LD_INT 9000
102188: PPUSH
102189: CALL_OW 12
102193: PPUSH
102194: CALL_OW 492
// end ;
102198: PPOPN 1
102200: END
// every 0 0$1 trigger StreamModeActive and sDepot do
102201: LD_EXP 78
102205: PUSH
102206: LD_EXP 93
102210: AND
102211: IFFALSE 102231
102213: GO 102215
102215: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
102216: LD_INT 1
102218: PPUSH
102219: LD_OWVAR 2
102223: PPUSH
102224: LD_INT 0
102226: PPUSH
102227: CALL_OW 324
102231: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
102232: LD_EXP 78
102236: PUSH
102237: LD_EXP 94
102241: AND
102242: IFFALSE 102325
102244: GO 102246
102246: DISABLE
102247: LD_INT 0
102249: PPUSH
102250: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
102251: LD_ADDR_VAR 0 2
102255: PUSH
102256: LD_INT 22
102258: PUSH
102259: LD_OWVAR 2
102263: PUSH
102264: EMPTY
102265: LIST
102266: LIST
102267: PUSH
102268: LD_INT 21
102270: PUSH
102271: LD_INT 3
102273: PUSH
102274: EMPTY
102275: LIST
102276: LIST
102277: PUSH
102278: EMPTY
102279: LIST
102280: LIST
102281: PPUSH
102282: CALL_OW 69
102286: ST_TO_ADDR
// if not tmp then
102287: LD_VAR 0 2
102291: NOT
102292: IFFALSE 102296
// exit ;
102294: GO 102325
// for i in tmp do
102296: LD_ADDR_VAR 0 1
102300: PUSH
102301: LD_VAR 0 2
102305: PUSH
102306: FOR_IN
102307: IFFALSE 102323
// SetBLevel ( i , 10 ) ;
102309: LD_VAR 0 1
102313: PPUSH
102314: LD_INT 10
102316: PPUSH
102317: CALL_OW 241
102321: GO 102306
102323: POP
102324: POP
// end ;
102325: PPOPN 2
102327: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
102328: LD_EXP 78
102332: PUSH
102333: LD_EXP 95
102337: AND
102338: IFFALSE 102449
102340: GO 102342
102342: DISABLE
102343: LD_INT 0
102345: PPUSH
102346: PPUSH
102347: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102348: LD_ADDR_VAR 0 3
102352: PUSH
102353: LD_INT 22
102355: PUSH
102356: LD_OWVAR 2
102360: PUSH
102361: EMPTY
102362: LIST
102363: LIST
102364: PUSH
102365: LD_INT 25
102367: PUSH
102368: LD_INT 1
102370: PUSH
102371: EMPTY
102372: LIST
102373: LIST
102374: PUSH
102375: EMPTY
102376: LIST
102377: LIST
102378: PPUSH
102379: CALL_OW 69
102383: ST_TO_ADDR
// if not tmp then
102384: LD_VAR 0 3
102388: NOT
102389: IFFALSE 102393
// exit ;
102391: GO 102449
// un := tmp [ rand ( 1 , tmp ) ] ;
102393: LD_ADDR_VAR 0 2
102397: PUSH
102398: LD_VAR 0 3
102402: PUSH
102403: LD_INT 1
102405: PPUSH
102406: LD_VAR 0 3
102410: PPUSH
102411: CALL_OW 12
102415: ARRAY
102416: ST_TO_ADDR
// if Crawls ( un ) then
102417: LD_VAR 0 2
102421: PPUSH
102422: CALL_OW 318
102426: IFFALSE 102437
// ComWalk ( un ) ;
102428: LD_VAR 0 2
102432: PPUSH
102433: CALL_OW 138
// SetClass ( un , class_sniper ) ;
102437: LD_VAR 0 2
102441: PPUSH
102442: LD_INT 5
102444: PPUSH
102445: CALL_OW 336
// end ;
102449: PPOPN 3
102451: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
102452: LD_EXP 78
102456: PUSH
102457: LD_EXP 96
102461: AND
102462: PUSH
102463: LD_OWVAR 67
102467: PUSH
102468: LD_INT 4
102470: LESS
102471: AND
102472: IFFALSE 102491
102474: GO 102476
102476: DISABLE
// begin Difficulty := Difficulty + 1 ;
102477: LD_ADDR_OWVAR 67
102481: PUSH
102482: LD_OWVAR 67
102486: PUSH
102487: LD_INT 1
102489: PLUS
102490: ST_TO_ADDR
// end ;
102491: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
102492: LD_EXP 78
102496: PUSH
102497: LD_EXP 97
102501: AND
102502: IFFALSE 102605
102504: GO 102506
102506: DISABLE
102507: LD_INT 0
102509: PPUSH
// begin for i := 1 to 5 do
102510: LD_ADDR_VAR 0 1
102514: PUSH
102515: DOUBLE
102516: LD_INT 1
102518: DEC
102519: ST_TO_ADDR
102520: LD_INT 5
102522: PUSH
102523: FOR_TO
102524: IFFALSE 102603
// begin uc_nation := nation_nature ;
102526: LD_ADDR_OWVAR 21
102530: PUSH
102531: LD_INT 0
102533: ST_TO_ADDR
// uc_side := 0 ;
102534: LD_ADDR_OWVAR 20
102538: PUSH
102539: LD_INT 0
102541: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
102542: LD_ADDR_OWVAR 29
102546: PUSH
102547: LD_INT 12
102549: PUSH
102550: LD_INT 12
102552: PUSH
102553: EMPTY
102554: LIST
102555: LIST
102556: ST_TO_ADDR
// hc_agressivity := 20 ;
102557: LD_ADDR_OWVAR 35
102561: PUSH
102562: LD_INT 20
102564: ST_TO_ADDR
// hc_class := class_tiger ;
102565: LD_ADDR_OWVAR 28
102569: PUSH
102570: LD_INT 14
102572: ST_TO_ADDR
// hc_gallery :=  ;
102573: LD_ADDR_OWVAR 33
102577: PUSH
102578: LD_STRING 
102580: ST_TO_ADDR
// hc_name :=  ;
102581: LD_ADDR_OWVAR 26
102585: PUSH
102586: LD_STRING 
102588: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
102589: CALL_OW 44
102593: PPUSH
102594: LD_INT 0
102596: PPUSH
102597: CALL_OW 51
// end ;
102601: GO 102523
102603: POP
102604: POP
// end ;
102605: PPOPN 1
102607: END
// every 0 0$1 trigger StreamModeActive and sBomb do
102608: LD_EXP 78
102612: PUSH
102613: LD_EXP 98
102617: AND
102618: IFFALSE 102627
102620: GO 102622
102622: DISABLE
// StreamSibBomb ;
102623: CALL 102628 0 0
102627: END
// export function StreamSibBomb ; var i , x , y ; begin
102628: LD_INT 0
102630: PPUSH
102631: PPUSH
102632: PPUSH
102633: PPUSH
// result := false ;
102634: LD_ADDR_VAR 0 1
102638: PUSH
102639: LD_INT 0
102641: ST_TO_ADDR
// for i := 1 to 16 do
102642: LD_ADDR_VAR 0 2
102646: PUSH
102647: DOUBLE
102648: LD_INT 1
102650: DEC
102651: ST_TO_ADDR
102652: LD_INT 16
102654: PUSH
102655: FOR_TO
102656: IFFALSE 102855
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102658: LD_ADDR_VAR 0 3
102662: PUSH
102663: LD_INT 10
102665: PUSH
102666: LD_INT 20
102668: PUSH
102669: LD_INT 30
102671: PUSH
102672: LD_INT 40
102674: PUSH
102675: LD_INT 50
102677: PUSH
102678: LD_INT 60
102680: PUSH
102681: LD_INT 70
102683: PUSH
102684: LD_INT 80
102686: PUSH
102687: LD_INT 90
102689: PUSH
102690: LD_INT 100
102692: PUSH
102693: LD_INT 110
102695: PUSH
102696: LD_INT 120
102698: PUSH
102699: LD_INT 130
102701: PUSH
102702: LD_INT 140
102704: PUSH
102705: LD_INT 150
102707: PUSH
102708: EMPTY
102709: LIST
102710: LIST
102711: LIST
102712: LIST
102713: LIST
102714: LIST
102715: LIST
102716: LIST
102717: LIST
102718: LIST
102719: LIST
102720: LIST
102721: LIST
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 1
102727: PPUSH
102728: LD_INT 15
102730: PPUSH
102731: CALL_OW 12
102735: ARRAY
102736: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
102737: LD_ADDR_VAR 0 4
102741: PUSH
102742: LD_INT 10
102744: PUSH
102745: LD_INT 20
102747: PUSH
102748: LD_INT 30
102750: PUSH
102751: LD_INT 40
102753: PUSH
102754: LD_INT 50
102756: PUSH
102757: LD_INT 60
102759: PUSH
102760: LD_INT 70
102762: PUSH
102763: LD_INT 80
102765: PUSH
102766: LD_INT 90
102768: PUSH
102769: LD_INT 100
102771: PUSH
102772: LD_INT 110
102774: PUSH
102775: LD_INT 120
102777: PUSH
102778: LD_INT 130
102780: PUSH
102781: LD_INT 140
102783: PUSH
102784: LD_INT 150
102786: PUSH
102787: EMPTY
102788: LIST
102789: LIST
102790: LIST
102791: LIST
102792: LIST
102793: LIST
102794: LIST
102795: LIST
102796: LIST
102797: LIST
102798: LIST
102799: LIST
102800: LIST
102801: LIST
102802: LIST
102803: PUSH
102804: LD_INT 1
102806: PPUSH
102807: LD_INT 15
102809: PPUSH
102810: CALL_OW 12
102814: ARRAY
102815: ST_TO_ADDR
// if ValidHex ( x , y ) then
102816: LD_VAR 0 3
102820: PPUSH
102821: LD_VAR 0 4
102825: PPUSH
102826: CALL_OW 488
102830: IFFALSE 102853
// begin result := [ x , y ] ;
102832: LD_ADDR_VAR 0 1
102836: PUSH
102837: LD_VAR 0 3
102841: PUSH
102842: LD_VAR 0 4
102846: PUSH
102847: EMPTY
102848: LIST
102849: LIST
102850: ST_TO_ADDR
// break ;
102851: GO 102855
// end ; end ;
102853: GO 102655
102855: POP
102856: POP
// if result then
102857: LD_VAR 0 1
102861: IFFALSE 102921
// begin ToLua ( playSibBomb() ) ;
102863: LD_STRING playSibBomb()
102865: PPUSH
102866: CALL_OW 559
// wait ( 0 0$14 ) ;
102870: LD_INT 490
102872: PPUSH
102873: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
102877: LD_VAR 0 1
102881: PUSH
102882: LD_INT 1
102884: ARRAY
102885: PPUSH
102886: LD_VAR 0 1
102890: PUSH
102891: LD_INT 2
102893: ARRAY
102894: PPUSH
102895: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
102899: LD_VAR 0 1
102903: PUSH
102904: LD_INT 1
102906: ARRAY
102907: PPUSH
102908: LD_VAR 0 1
102912: PUSH
102913: LD_INT 2
102915: ARRAY
102916: PPUSH
102917: CALL_OW 429
// end ; end ;
102921: LD_VAR 0 1
102925: RET
// every 0 0$1 trigger StreamModeActive and sReset do
102926: LD_EXP 78
102930: PUSH
102931: LD_EXP 100
102935: AND
102936: IFFALSE 102948
102938: GO 102940
102940: DISABLE
// YouLost (  ) ;
102941: LD_STRING 
102943: PPUSH
102944: CALL_OW 104
102948: END
// every 0 0$1 trigger StreamModeActive and sFog do
102949: LD_EXP 78
102953: PUSH
102954: LD_EXP 99
102958: AND
102959: IFFALSE 102973
102961: GO 102963
102963: DISABLE
// FogOff ( your_side ) ;
102964: LD_OWVAR 2
102968: PPUSH
102969: CALL_OW 344
102973: END
// every 0 0$1 trigger StreamModeActive and sSun do
102974: LD_EXP 78
102978: PUSH
102979: LD_EXP 101
102983: AND
102984: IFFALSE 103012
102986: GO 102988
102988: DISABLE
// begin solar_recharge_percent := 0 ;
102989: LD_ADDR_OWVAR 79
102993: PUSH
102994: LD_INT 0
102996: ST_TO_ADDR
// wait ( 5 5$00 ) ;
102997: LD_INT 10500
102999: PPUSH
103000: CALL_OW 67
// solar_recharge_percent := 100 ;
103004: LD_ADDR_OWVAR 79
103008: PUSH
103009: LD_INT 100
103011: ST_TO_ADDR
// end ;
103012: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
103013: LD_EXP 78
103017: PUSH
103018: LD_EXP 102
103022: AND
103023: IFFALSE 103262
103025: GO 103027
103027: DISABLE
103028: LD_INT 0
103030: PPUSH
103031: PPUSH
103032: PPUSH
// begin tmp := [ ] ;
103033: LD_ADDR_VAR 0 3
103037: PUSH
103038: EMPTY
103039: ST_TO_ADDR
// for i := 1 to 6 do
103040: LD_ADDR_VAR 0 1
103044: PUSH
103045: DOUBLE
103046: LD_INT 1
103048: DEC
103049: ST_TO_ADDR
103050: LD_INT 6
103052: PUSH
103053: FOR_TO
103054: IFFALSE 103159
// begin uc_nation := nation_nature ;
103056: LD_ADDR_OWVAR 21
103060: PUSH
103061: LD_INT 0
103063: ST_TO_ADDR
// uc_side := 0 ;
103064: LD_ADDR_OWVAR 20
103068: PUSH
103069: LD_INT 0
103071: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
103072: LD_ADDR_OWVAR 29
103076: PUSH
103077: LD_INT 12
103079: PUSH
103080: LD_INT 12
103082: PUSH
103083: EMPTY
103084: LIST
103085: LIST
103086: ST_TO_ADDR
// hc_agressivity := 20 ;
103087: LD_ADDR_OWVAR 35
103091: PUSH
103092: LD_INT 20
103094: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
103095: LD_ADDR_OWVAR 28
103099: PUSH
103100: LD_INT 17
103102: ST_TO_ADDR
// hc_gallery :=  ;
103103: LD_ADDR_OWVAR 33
103107: PUSH
103108: LD_STRING 
103110: ST_TO_ADDR
// hc_name :=  ;
103111: LD_ADDR_OWVAR 26
103115: PUSH
103116: LD_STRING 
103118: ST_TO_ADDR
// un := CreateHuman ;
103119: LD_ADDR_VAR 0 2
103123: PUSH
103124: CALL_OW 44
103128: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
103129: LD_VAR 0 2
103133: PPUSH
103134: LD_INT 1
103136: PPUSH
103137: CALL_OW 51
// tmp := tmp ^ un ;
103141: LD_ADDR_VAR 0 3
103145: PUSH
103146: LD_VAR 0 3
103150: PUSH
103151: LD_VAR 0 2
103155: ADD
103156: ST_TO_ADDR
// end ;
103157: GO 103053
103159: POP
103160: POP
// repeat wait ( 0 0$1 ) ;
103161: LD_INT 35
103163: PPUSH
103164: CALL_OW 67
// for un in tmp do
103168: LD_ADDR_VAR 0 2
103172: PUSH
103173: LD_VAR 0 3
103177: PUSH
103178: FOR_IN
103179: IFFALSE 103253
// begin if IsDead ( un ) then
103181: LD_VAR 0 2
103185: PPUSH
103186: CALL_OW 301
103190: IFFALSE 103210
// begin tmp := tmp diff un ;
103192: LD_ADDR_VAR 0 3
103196: PUSH
103197: LD_VAR 0 3
103201: PUSH
103202: LD_VAR 0 2
103206: DIFF
103207: ST_TO_ADDR
// continue ;
103208: GO 103178
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
103210: LD_VAR 0 2
103214: PPUSH
103215: LD_INT 3
103217: PUSH
103218: LD_INT 22
103220: PUSH
103221: LD_INT 0
103223: PUSH
103224: EMPTY
103225: LIST
103226: LIST
103227: PUSH
103228: EMPTY
103229: LIST
103230: LIST
103231: PPUSH
103232: CALL_OW 69
103236: PPUSH
103237: LD_VAR 0 2
103241: PPUSH
103242: CALL_OW 74
103246: PPUSH
103247: CALL_OW 115
// end ;
103251: GO 103178
103253: POP
103254: POP
// until not tmp ;
103255: LD_VAR 0 3
103259: NOT
103260: IFFALSE 103161
// end ;
103262: PPOPN 3
103264: END
// every 0 0$1 trigger StreamModeActive and sTroll do
103265: LD_EXP 78
103269: PUSH
103270: LD_EXP 103
103274: AND
103275: IFFALSE 103329
103277: GO 103279
103279: DISABLE
// begin ToLua ( displayTroll(); ) ;
103280: LD_STRING displayTroll();
103282: PPUSH
103283: CALL_OW 559
// wait ( 3 3$00 ) ;
103287: LD_INT 6300
103289: PPUSH
103290: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103294: LD_STRING hideTroll();
103296: PPUSH
103297: CALL_OW 559
// wait ( 1 1$00 ) ;
103301: LD_INT 2100
103303: PPUSH
103304: CALL_OW 67
// ToLua ( displayTroll(); ) ;
103308: LD_STRING displayTroll();
103310: PPUSH
103311: CALL_OW 559
// wait ( 1 1$00 ) ;
103315: LD_INT 2100
103317: PPUSH
103318: CALL_OW 67
// ToLua ( hideTroll(); ) ;
103322: LD_STRING hideTroll();
103324: PPUSH
103325: CALL_OW 559
// end ;
103329: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
103330: LD_EXP 78
103334: PUSH
103335: LD_EXP 104
103339: AND
103340: IFFALSE 103403
103342: GO 103344
103344: DISABLE
103345: LD_INT 0
103347: PPUSH
// begin p := 0 ;
103348: LD_ADDR_VAR 0 1
103352: PUSH
103353: LD_INT 0
103355: ST_TO_ADDR
// repeat game_speed := 1 ;
103356: LD_ADDR_OWVAR 65
103360: PUSH
103361: LD_INT 1
103363: ST_TO_ADDR
// wait ( 0 0$1 ) ;
103364: LD_INT 35
103366: PPUSH
103367: CALL_OW 67
// p := p + 1 ;
103371: LD_ADDR_VAR 0 1
103375: PUSH
103376: LD_VAR 0 1
103380: PUSH
103381: LD_INT 1
103383: PLUS
103384: ST_TO_ADDR
// until p >= 60 ;
103385: LD_VAR 0 1
103389: PUSH
103390: LD_INT 60
103392: GREATEREQUAL
103393: IFFALSE 103356
// game_speed := 4 ;
103395: LD_ADDR_OWVAR 65
103399: PUSH
103400: LD_INT 4
103402: ST_TO_ADDR
// end ;
103403: PPOPN 1
103405: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
103406: LD_EXP 78
103410: PUSH
103411: LD_EXP 105
103415: AND
103416: IFFALSE 103562
103418: GO 103420
103420: DISABLE
103421: LD_INT 0
103423: PPUSH
103424: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103425: LD_ADDR_VAR 0 1
103429: PUSH
103430: LD_INT 22
103432: PUSH
103433: LD_OWVAR 2
103437: PUSH
103438: EMPTY
103439: LIST
103440: LIST
103441: PUSH
103442: LD_INT 2
103444: PUSH
103445: LD_INT 30
103447: PUSH
103448: LD_INT 0
103450: PUSH
103451: EMPTY
103452: LIST
103453: LIST
103454: PUSH
103455: LD_INT 30
103457: PUSH
103458: LD_INT 1
103460: PUSH
103461: EMPTY
103462: LIST
103463: LIST
103464: PUSH
103465: EMPTY
103466: LIST
103467: LIST
103468: LIST
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: PPUSH
103474: CALL_OW 69
103478: ST_TO_ADDR
// if not depot then
103479: LD_VAR 0 1
103483: NOT
103484: IFFALSE 103488
// exit ;
103486: GO 103562
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
103488: LD_ADDR_VAR 0 2
103492: PUSH
103493: LD_VAR 0 1
103497: PUSH
103498: LD_INT 1
103500: PPUSH
103501: LD_VAR 0 1
103505: PPUSH
103506: CALL_OW 12
103510: ARRAY
103511: PPUSH
103512: CALL_OW 274
103516: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
103517: LD_VAR 0 2
103521: PPUSH
103522: LD_INT 1
103524: PPUSH
103525: LD_INT 0
103527: PPUSH
103528: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
103532: LD_VAR 0 2
103536: PPUSH
103537: LD_INT 2
103539: PPUSH
103540: LD_INT 0
103542: PPUSH
103543: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
103547: LD_VAR 0 2
103551: PPUSH
103552: LD_INT 3
103554: PPUSH
103555: LD_INT 0
103557: PPUSH
103558: CALL_OW 277
// end ;
103562: PPOPN 2
103564: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
103565: LD_EXP 78
103569: PUSH
103570: LD_EXP 106
103574: AND
103575: IFFALSE 103672
103577: GO 103579
103579: DISABLE
103580: LD_INT 0
103582: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103583: LD_ADDR_VAR 0 1
103587: PUSH
103588: LD_INT 22
103590: PUSH
103591: LD_OWVAR 2
103595: PUSH
103596: EMPTY
103597: LIST
103598: LIST
103599: PUSH
103600: LD_INT 21
103602: PUSH
103603: LD_INT 1
103605: PUSH
103606: EMPTY
103607: LIST
103608: LIST
103609: PUSH
103610: LD_INT 3
103612: PUSH
103613: LD_INT 23
103615: PUSH
103616: LD_INT 0
103618: PUSH
103619: EMPTY
103620: LIST
103621: LIST
103622: PUSH
103623: EMPTY
103624: LIST
103625: LIST
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: LIST
103631: PPUSH
103632: CALL_OW 69
103636: ST_TO_ADDR
// if not tmp then
103637: LD_VAR 0 1
103641: NOT
103642: IFFALSE 103646
// exit ;
103644: GO 103672
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
103646: LD_VAR 0 1
103650: PUSH
103651: LD_INT 1
103653: PPUSH
103654: LD_VAR 0 1
103658: PPUSH
103659: CALL_OW 12
103663: ARRAY
103664: PPUSH
103665: LD_INT 200
103667: PPUSH
103668: CALL_OW 234
// end ;
103672: PPOPN 1
103674: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
103675: LD_EXP 78
103679: PUSH
103680: LD_EXP 107
103684: AND
103685: IFFALSE 103764
103687: GO 103689
103689: DISABLE
103690: LD_INT 0
103692: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
103693: LD_ADDR_VAR 0 1
103697: PUSH
103698: LD_INT 22
103700: PUSH
103701: LD_OWVAR 2
103705: PUSH
103706: EMPTY
103707: LIST
103708: LIST
103709: PUSH
103710: LD_INT 21
103712: PUSH
103713: LD_INT 2
103715: PUSH
103716: EMPTY
103717: LIST
103718: LIST
103719: PUSH
103720: EMPTY
103721: LIST
103722: LIST
103723: PPUSH
103724: CALL_OW 69
103728: ST_TO_ADDR
// if not tmp then
103729: LD_VAR 0 1
103733: NOT
103734: IFFALSE 103738
// exit ;
103736: GO 103764
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
103738: LD_VAR 0 1
103742: PUSH
103743: LD_INT 1
103745: PPUSH
103746: LD_VAR 0 1
103750: PPUSH
103751: CALL_OW 12
103755: ARRAY
103756: PPUSH
103757: LD_INT 60
103759: PPUSH
103760: CALL_OW 234
// end ;
103764: PPOPN 1
103766: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
103767: LD_EXP 78
103771: PUSH
103772: LD_EXP 108
103776: AND
103777: IFFALSE 103876
103779: GO 103781
103781: DISABLE
103782: LD_INT 0
103784: PPUSH
103785: PPUSH
// begin enable ;
103786: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
103787: LD_ADDR_VAR 0 1
103791: PUSH
103792: LD_INT 22
103794: PUSH
103795: LD_OWVAR 2
103799: PUSH
103800: EMPTY
103801: LIST
103802: LIST
103803: PUSH
103804: LD_INT 61
103806: PUSH
103807: EMPTY
103808: LIST
103809: PUSH
103810: LD_INT 33
103812: PUSH
103813: LD_INT 2
103815: PUSH
103816: EMPTY
103817: LIST
103818: LIST
103819: PUSH
103820: EMPTY
103821: LIST
103822: LIST
103823: LIST
103824: PPUSH
103825: CALL_OW 69
103829: ST_TO_ADDR
// if not tmp then
103830: LD_VAR 0 1
103834: NOT
103835: IFFALSE 103839
// exit ;
103837: GO 103876
// for i in tmp do
103839: LD_ADDR_VAR 0 2
103843: PUSH
103844: LD_VAR 0 1
103848: PUSH
103849: FOR_IN
103850: IFFALSE 103874
// if IsControledBy ( i ) then
103852: LD_VAR 0 2
103856: PPUSH
103857: CALL_OW 312
103861: IFFALSE 103872
// ComUnlink ( i ) ;
103863: LD_VAR 0 2
103867: PPUSH
103868: CALL_OW 136
103872: GO 103849
103874: POP
103875: POP
// end ;
103876: PPOPN 2
103878: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
103879: LD_EXP 78
103883: PUSH
103884: LD_EXP 109
103888: AND
103889: IFFALSE 104029
103891: GO 103893
103893: DISABLE
103894: LD_INT 0
103896: PPUSH
103897: PPUSH
// begin ToLua ( displayPowell(); ) ;
103898: LD_STRING displayPowell();
103900: PPUSH
103901: CALL_OW 559
// uc_side := 0 ;
103905: LD_ADDR_OWVAR 20
103909: PUSH
103910: LD_INT 0
103912: ST_TO_ADDR
// uc_nation := 2 ;
103913: LD_ADDR_OWVAR 21
103917: PUSH
103918: LD_INT 2
103920: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
103921: LD_ADDR_OWVAR 37
103925: PUSH
103926: LD_INT 14
103928: ST_TO_ADDR
// vc_engine := engine_siberite ;
103929: LD_ADDR_OWVAR 39
103933: PUSH
103934: LD_INT 3
103936: ST_TO_ADDR
// vc_control := control_apeman ;
103937: LD_ADDR_OWVAR 38
103941: PUSH
103942: LD_INT 5
103944: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
103945: LD_ADDR_OWVAR 40
103949: PUSH
103950: LD_INT 29
103952: ST_TO_ADDR
// un := CreateVehicle ;
103953: LD_ADDR_VAR 0 2
103957: PUSH
103958: CALL_OW 45
103962: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
103963: LD_VAR 0 2
103967: PPUSH
103968: LD_INT 1
103970: PPUSH
103971: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
103975: LD_INT 35
103977: PPUSH
103978: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
103982: LD_VAR 0 2
103986: PPUSH
103987: LD_INT 22
103989: PUSH
103990: LD_OWVAR 2
103994: PUSH
103995: EMPTY
103996: LIST
103997: LIST
103998: PPUSH
103999: CALL_OW 69
104003: PPUSH
104004: LD_VAR 0 2
104008: PPUSH
104009: CALL_OW 74
104013: PPUSH
104014: CALL_OW 115
// until IsDead ( un ) ;
104018: LD_VAR 0 2
104022: PPUSH
104023: CALL_OW 301
104027: IFFALSE 103975
// end ;
104029: PPOPN 2
104031: END
// every 0 0$1 trigger StreamModeActive and sStu do
104032: LD_EXP 78
104036: PUSH
104037: LD_EXP 117
104041: AND
104042: IFFALSE 104058
104044: GO 104046
104046: DISABLE
// begin ToLua ( displayStucuk(); ) ;
104047: LD_STRING displayStucuk();
104049: PPUSH
104050: CALL_OW 559
// ResetFog ;
104054: CALL_OW 335
// end ;
104058: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
104059: LD_EXP 78
104063: PUSH
104064: LD_EXP 110
104068: AND
104069: IFFALSE 104210
104071: GO 104073
104073: DISABLE
104074: LD_INT 0
104076: PPUSH
104077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104078: LD_ADDR_VAR 0 2
104082: PUSH
104083: LD_INT 22
104085: PUSH
104086: LD_OWVAR 2
104090: PUSH
104091: EMPTY
104092: LIST
104093: LIST
104094: PUSH
104095: LD_INT 21
104097: PUSH
104098: LD_INT 1
104100: PUSH
104101: EMPTY
104102: LIST
104103: LIST
104104: PUSH
104105: EMPTY
104106: LIST
104107: LIST
104108: PPUSH
104109: CALL_OW 69
104113: ST_TO_ADDR
// if not tmp then
104114: LD_VAR 0 2
104118: NOT
104119: IFFALSE 104123
// exit ;
104121: GO 104210
// un := tmp [ rand ( 1 , tmp ) ] ;
104123: LD_ADDR_VAR 0 1
104127: PUSH
104128: LD_VAR 0 2
104132: PUSH
104133: LD_INT 1
104135: PPUSH
104136: LD_VAR 0 2
104140: PPUSH
104141: CALL_OW 12
104145: ARRAY
104146: ST_TO_ADDR
// SetSide ( un , 0 ) ;
104147: LD_VAR 0 1
104151: PPUSH
104152: LD_INT 0
104154: PPUSH
104155: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
104159: LD_VAR 0 1
104163: PPUSH
104164: LD_OWVAR 3
104168: PUSH
104169: LD_VAR 0 1
104173: DIFF
104174: PPUSH
104175: LD_VAR 0 1
104179: PPUSH
104180: CALL_OW 74
104184: PPUSH
104185: CALL_OW 115
// wait ( 0 0$20 ) ;
104189: LD_INT 700
104191: PPUSH
104192: CALL_OW 67
// SetSide ( un , your_side ) ;
104196: LD_VAR 0 1
104200: PPUSH
104201: LD_OWVAR 2
104205: PPUSH
104206: CALL_OW 235
// end ;
104210: PPOPN 2
104212: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
104213: LD_EXP 78
104217: PUSH
104218: LD_EXP 111
104222: AND
104223: IFFALSE 104329
104225: GO 104227
104227: DISABLE
104228: LD_INT 0
104230: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104231: LD_ADDR_VAR 0 1
104235: PUSH
104236: LD_INT 22
104238: PUSH
104239: LD_OWVAR 2
104243: PUSH
104244: EMPTY
104245: LIST
104246: LIST
104247: PUSH
104248: LD_INT 2
104250: PUSH
104251: LD_INT 30
104253: PUSH
104254: LD_INT 0
104256: PUSH
104257: EMPTY
104258: LIST
104259: LIST
104260: PUSH
104261: LD_INT 30
104263: PUSH
104264: LD_INT 1
104266: PUSH
104267: EMPTY
104268: LIST
104269: LIST
104270: PUSH
104271: EMPTY
104272: LIST
104273: LIST
104274: LIST
104275: PUSH
104276: EMPTY
104277: LIST
104278: LIST
104279: PPUSH
104280: CALL_OW 69
104284: ST_TO_ADDR
// if not depot then
104285: LD_VAR 0 1
104289: NOT
104290: IFFALSE 104294
// exit ;
104292: GO 104329
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
104294: LD_VAR 0 1
104298: PUSH
104299: LD_INT 1
104301: ARRAY
104302: PPUSH
104303: CALL_OW 250
104307: PPUSH
104308: LD_VAR 0 1
104312: PUSH
104313: LD_INT 1
104315: ARRAY
104316: PPUSH
104317: CALL_OW 251
104321: PPUSH
104322: LD_INT 70
104324: PPUSH
104325: CALL_OW 495
// end ;
104329: PPOPN 1
104331: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
104332: LD_EXP 78
104336: PUSH
104337: LD_EXP 112
104341: AND
104342: IFFALSE 104553
104344: GO 104346
104346: DISABLE
104347: LD_INT 0
104349: PPUSH
104350: PPUSH
104351: PPUSH
104352: PPUSH
104353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
104354: LD_ADDR_VAR 0 5
104358: PUSH
104359: LD_INT 22
104361: PUSH
104362: LD_OWVAR 2
104366: PUSH
104367: EMPTY
104368: LIST
104369: LIST
104370: PUSH
104371: LD_INT 21
104373: PUSH
104374: LD_INT 1
104376: PUSH
104377: EMPTY
104378: LIST
104379: LIST
104380: PUSH
104381: EMPTY
104382: LIST
104383: LIST
104384: PPUSH
104385: CALL_OW 69
104389: ST_TO_ADDR
// if not tmp then
104390: LD_VAR 0 5
104394: NOT
104395: IFFALSE 104399
// exit ;
104397: GO 104553
// for i in tmp do
104399: LD_ADDR_VAR 0 1
104403: PUSH
104404: LD_VAR 0 5
104408: PUSH
104409: FOR_IN
104410: IFFALSE 104551
// begin d := rand ( 0 , 5 ) ;
104412: LD_ADDR_VAR 0 4
104416: PUSH
104417: LD_INT 0
104419: PPUSH
104420: LD_INT 5
104422: PPUSH
104423: CALL_OW 12
104427: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
104428: LD_ADDR_VAR 0 2
104432: PUSH
104433: LD_VAR 0 1
104437: PPUSH
104438: CALL_OW 250
104442: PPUSH
104443: LD_VAR 0 4
104447: PPUSH
104448: LD_INT 3
104450: PPUSH
104451: LD_INT 12
104453: PPUSH
104454: CALL_OW 12
104458: PPUSH
104459: CALL_OW 272
104463: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
104464: LD_ADDR_VAR 0 3
104468: PUSH
104469: LD_VAR 0 1
104473: PPUSH
104474: CALL_OW 251
104478: PPUSH
104479: LD_VAR 0 4
104483: PPUSH
104484: LD_INT 3
104486: PPUSH
104487: LD_INT 12
104489: PPUSH
104490: CALL_OW 12
104494: PPUSH
104495: CALL_OW 273
104499: ST_TO_ADDR
// if ValidHex ( x , y ) then
104500: LD_VAR 0 2
104504: PPUSH
104505: LD_VAR 0 3
104509: PPUSH
104510: CALL_OW 488
104514: IFFALSE 104549
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
104516: LD_VAR 0 1
104520: PPUSH
104521: LD_VAR 0 2
104525: PPUSH
104526: LD_VAR 0 3
104530: PPUSH
104531: LD_INT 3
104533: PPUSH
104534: LD_INT 6
104536: PPUSH
104537: CALL_OW 12
104541: PPUSH
104542: LD_INT 1
104544: PPUSH
104545: CALL_OW 483
// end ;
104549: GO 104409
104551: POP
104552: POP
// end ;
104553: PPOPN 5
104555: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
104556: LD_EXP 78
104560: PUSH
104561: LD_EXP 113
104565: AND
104566: IFFALSE 104660
104568: GO 104570
104570: DISABLE
104571: LD_INT 0
104573: PPUSH
104574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
104575: LD_ADDR_VAR 0 2
104579: PUSH
104580: LD_INT 22
104582: PUSH
104583: LD_OWVAR 2
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: PUSH
104592: LD_INT 32
104594: PUSH
104595: LD_INT 1
104597: PUSH
104598: EMPTY
104599: LIST
104600: LIST
104601: PUSH
104602: LD_INT 21
104604: PUSH
104605: LD_INT 2
104607: PUSH
104608: EMPTY
104609: LIST
104610: LIST
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: LIST
104616: PPUSH
104617: CALL_OW 69
104621: ST_TO_ADDR
// if not tmp then
104622: LD_VAR 0 2
104626: NOT
104627: IFFALSE 104631
// exit ;
104629: GO 104660
// for i in tmp do
104631: LD_ADDR_VAR 0 1
104635: PUSH
104636: LD_VAR 0 2
104640: PUSH
104641: FOR_IN
104642: IFFALSE 104658
// SetFuel ( i , 0 ) ;
104644: LD_VAR 0 1
104648: PPUSH
104649: LD_INT 0
104651: PPUSH
104652: CALL_OW 240
104656: GO 104641
104658: POP
104659: POP
// end ;
104660: PPOPN 2
104662: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
104663: LD_EXP 78
104667: PUSH
104668: LD_EXP 114
104672: AND
104673: IFFALSE 104739
104675: GO 104677
104677: DISABLE
104678: LD_INT 0
104680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
104681: LD_ADDR_VAR 0 1
104685: PUSH
104686: LD_INT 22
104688: PUSH
104689: LD_OWVAR 2
104693: PUSH
104694: EMPTY
104695: LIST
104696: LIST
104697: PUSH
104698: LD_INT 30
104700: PUSH
104701: LD_INT 29
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: PUSH
104708: EMPTY
104709: LIST
104710: LIST
104711: PPUSH
104712: CALL_OW 69
104716: ST_TO_ADDR
// if not tmp then
104717: LD_VAR 0 1
104721: NOT
104722: IFFALSE 104726
// exit ;
104724: GO 104739
// DestroyUnit ( tmp [ 1 ] ) ;
104726: LD_VAR 0 1
104730: PUSH
104731: LD_INT 1
104733: ARRAY
104734: PPUSH
104735: CALL_OW 65
// end ;
104739: PPOPN 1
104741: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
104742: LD_EXP 78
104746: PUSH
104747: LD_EXP 116
104751: AND
104752: IFFALSE 104881
104754: GO 104756
104756: DISABLE
104757: LD_INT 0
104759: PPUSH
// begin uc_side := 0 ;
104760: LD_ADDR_OWVAR 20
104764: PUSH
104765: LD_INT 0
104767: ST_TO_ADDR
// uc_nation := nation_arabian ;
104768: LD_ADDR_OWVAR 21
104772: PUSH
104773: LD_INT 2
104775: ST_TO_ADDR
// hc_gallery :=  ;
104776: LD_ADDR_OWVAR 33
104780: PUSH
104781: LD_STRING 
104783: ST_TO_ADDR
// hc_name :=  ;
104784: LD_ADDR_OWVAR 26
104788: PUSH
104789: LD_STRING 
104791: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
104792: LD_INT 1
104794: PPUSH
104795: LD_INT 11
104797: PPUSH
104798: LD_INT 10
104800: PPUSH
104801: CALL_OW 380
// un := CreateHuman ;
104805: LD_ADDR_VAR 0 1
104809: PUSH
104810: CALL_OW 44
104814: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104815: LD_VAR 0 1
104819: PPUSH
104820: LD_INT 1
104822: PPUSH
104823: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
104827: LD_INT 35
104829: PPUSH
104830: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
104834: LD_VAR 0 1
104838: PPUSH
104839: LD_INT 22
104841: PUSH
104842: LD_OWVAR 2
104846: PUSH
104847: EMPTY
104848: LIST
104849: LIST
104850: PPUSH
104851: CALL_OW 69
104855: PPUSH
104856: LD_VAR 0 1
104860: PPUSH
104861: CALL_OW 74
104865: PPUSH
104866: CALL_OW 115
// until IsDead ( un ) ;
104870: LD_VAR 0 1
104874: PPUSH
104875: CALL_OW 301
104879: IFFALSE 104827
// end ;
104881: PPOPN 1
104883: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
104884: LD_EXP 78
104888: PUSH
104889: LD_EXP 118
104893: AND
104894: IFFALSE 104906
104896: GO 104898
104898: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
104899: LD_STRING earthquake(getX(game), 0, 32)
104901: PPUSH
104902: CALL_OW 559
104906: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
104907: LD_EXP 78
104911: PUSH
104912: LD_EXP 119
104916: AND
104917: IFFALSE 105008
104919: GO 104921
104921: DISABLE
104922: LD_INT 0
104924: PPUSH
// begin enable ;
104925: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
104926: LD_ADDR_VAR 0 1
104930: PUSH
104931: LD_INT 22
104933: PUSH
104934: LD_OWVAR 2
104938: PUSH
104939: EMPTY
104940: LIST
104941: LIST
104942: PUSH
104943: LD_INT 21
104945: PUSH
104946: LD_INT 2
104948: PUSH
104949: EMPTY
104950: LIST
104951: LIST
104952: PUSH
104953: LD_INT 33
104955: PUSH
104956: LD_INT 3
104958: PUSH
104959: EMPTY
104960: LIST
104961: LIST
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: LIST
104967: PPUSH
104968: CALL_OW 69
104972: ST_TO_ADDR
// if not tmp then
104973: LD_VAR 0 1
104977: NOT
104978: IFFALSE 104982
// exit ;
104980: GO 105008
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
104982: LD_VAR 0 1
104986: PUSH
104987: LD_INT 1
104989: PPUSH
104990: LD_VAR 0 1
104994: PPUSH
104995: CALL_OW 12
104999: ARRAY
105000: PPUSH
105001: LD_INT 1
105003: PPUSH
105004: CALL_OW 234
// end ;
105008: PPOPN 1
105010: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
105011: LD_EXP 78
105015: PUSH
105016: LD_EXP 120
105020: AND
105021: IFFALSE 105162
105023: GO 105025
105025: DISABLE
105026: LD_INT 0
105028: PPUSH
105029: PPUSH
105030: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105031: LD_ADDR_VAR 0 3
105035: PUSH
105036: LD_INT 22
105038: PUSH
105039: LD_OWVAR 2
105043: PUSH
105044: EMPTY
105045: LIST
105046: LIST
105047: PUSH
105048: LD_INT 25
105050: PUSH
105051: LD_INT 1
105053: PUSH
105054: EMPTY
105055: LIST
105056: LIST
105057: PUSH
105058: EMPTY
105059: LIST
105060: LIST
105061: PPUSH
105062: CALL_OW 69
105066: ST_TO_ADDR
// if not tmp then
105067: LD_VAR 0 3
105071: NOT
105072: IFFALSE 105076
// exit ;
105074: GO 105162
// un := tmp [ rand ( 1 , tmp ) ] ;
105076: LD_ADDR_VAR 0 2
105080: PUSH
105081: LD_VAR 0 3
105085: PUSH
105086: LD_INT 1
105088: PPUSH
105089: LD_VAR 0 3
105093: PPUSH
105094: CALL_OW 12
105098: ARRAY
105099: ST_TO_ADDR
// if Crawls ( un ) then
105100: LD_VAR 0 2
105104: PPUSH
105105: CALL_OW 318
105109: IFFALSE 105120
// ComWalk ( un ) ;
105111: LD_VAR 0 2
105115: PPUSH
105116: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
105120: LD_VAR 0 2
105124: PPUSH
105125: LD_INT 9
105127: PPUSH
105128: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
105132: LD_INT 28
105134: PPUSH
105135: LD_OWVAR 2
105139: PPUSH
105140: LD_INT 2
105142: PPUSH
105143: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
105147: LD_INT 29
105149: PPUSH
105150: LD_OWVAR 2
105154: PPUSH
105155: LD_INT 2
105157: PPUSH
105158: CALL_OW 322
// end ;
105162: PPOPN 3
105164: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
105165: LD_EXP 78
105169: PUSH
105170: LD_EXP 121
105174: AND
105175: IFFALSE 105286
105177: GO 105179
105179: DISABLE
105180: LD_INT 0
105182: PPUSH
105183: PPUSH
105184: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
105185: LD_ADDR_VAR 0 3
105189: PUSH
105190: LD_INT 22
105192: PUSH
105193: LD_OWVAR 2
105197: PUSH
105198: EMPTY
105199: LIST
105200: LIST
105201: PUSH
105202: LD_INT 25
105204: PUSH
105205: LD_INT 1
105207: PUSH
105208: EMPTY
105209: LIST
105210: LIST
105211: PUSH
105212: EMPTY
105213: LIST
105214: LIST
105215: PPUSH
105216: CALL_OW 69
105220: ST_TO_ADDR
// if not tmp then
105221: LD_VAR 0 3
105225: NOT
105226: IFFALSE 105230
// exit ;
105228: GO 105286
// un := tmp [ rand ( 1 , tmp ) ] ;
105230: LD_ADDR_VAR 0 2
105234: PUSH
105235: LD_VAR 0 3
105239: PUSH
105240: LD_INT 1
105242: PPUSH
105243: LD_VAR 0 3
105247: PPUSH
105248: CALL_OW 12
105252: ARRAY
105253: ST_TO_ADDR
// if Crawls ( un ) then
105254: LD_VAR 0 2
105258: PPUSH
105259: CALL_OW 318
105263: IFFALSE 105274
// ComWalk ( un ) ;
105265: LD_VAR 0 2
105269: PPUSH
105270: CALL_OW 138
// SetClass ( un , class_mortar ) ;
105274: LD_VAR 0 2
105278: PPUSH
105279: LD_INT 8
105281: PPUSH
105282: CALL_OW 336
// end ;
105286: PPOPN 3
105288: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
105289: LD_EXP 78
105293: PUSH
105294: LD_EXP 122
105298: AND
105299: IFFALSE 105443
105301: GO 105303
105303: DISABLE
105304: LD_INT 0
105306: PPUSH
105307: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
105308: LD_ADDR_VAR 0 2
105312: PUSH
105313: LD_INT 22
105315: PUSH
105316: LD_OWVAR 2
105320: PUSH
105321: EMPTY
105322: LIST
105323: LIST
105324: PUSH
105325: LD_INT 21
105327: PUSH
105328: LD_INT 2
105330: PUSH
105331: EMPTY
105332: LIST
105333: LIST
105334: PUSH
105335: LD_INT 2
105337: PUSH
105338: LD_INT 34
105340: PUSH
105341: LD_INT 12
105343: PUSH
105344: EMPTY
105345: LIST
105346: LIST
105347: PUSH
105348: LD_INT 34
105350: PUSH
105351: LD_INT 51
105353: PUSH
105354: EMPTY
105355: LIST
105356: LIST
105357: PUSH
105358: LD_INT 34
105360: PUSH
105361: LD_INT 32
105363: PUSH
105364: EMPTY
105365: LIST
105366: LIST
105367: PUSH
105368: EMPTY
105369: LIST
105370: LIST
105371: LIST
105372: LIST
105373: PUSH
105374: EMPTY
105375: LIST
105376: LIST
105377: LIST
105378: PPUSH
105379: CALL_OW 69
105383: ST_TO_ADDR
// if not tmp then
105384: LD_VAR 0 2
105388: NOT
105389: IFFALSE 105393
// exit ;
105391: GO 105443
// for i in tmp do
105393: LD_ADDR_VAR 0 1
105397: PUSH
105398: LD_VAR 0 2
105402: PUSH
105403: FOR_IN
105404: IFFALSE 105441
// if GetCargo ( i , mat_artifact ) = 0 then
105406: LD_VAR 0 1
105410: PPUSH
105411: LD_INT 4
105413: PPUSH
105414: CALL_OW 289
105418: PUSH
105419: LD_INT 0
105421: EQUAL
105422: IFFALSE 105439
// SetCargo ( i , mat_siberit , 100 ) ;
105424: LD_VAR 0 1
105428: PPUSH
105429: LD_INT 3
105431: PPUSH
105432: LD_INT 100
105434: PPUSH
105435: CALL_OW 290
105439: GO 105403
105441: POP
105442: POP
// end ;
105443: PPOPN 2
105445: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
105446: LD_EXP 78
105450: PUSH
105451: LD_EXP 123
105455: AND
105456: IFFALSE 105639
105458: GO 105460
105460: DISABLE
105461: LD_INT 0
105463: PPUSH
105464: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
105465: LD_ADDR_VAR 0 2
105469: PUSH
105470: LD_INT 22
105472: PUSH
105473: LD_OWVAR 2
105477: PUSH
105478: EMPTY
105479: LIST
105480: LIST
105481: PPUSH
105482: CALL_OW 69
105486: ST_TO_ADDR
// if not tmp then
105487: LD_VAR 0 2
105491: NOT
105492: IFFALSE 105496
// exit ;
105494: GO 105639
// for i := 1 to 2 do
105496: LD_ADDR_VAR 0 1
105500: PUSH
105501: DOUBLE
105502: LD_INT 1
105504: DEC
105505: ST_TO_ADDR
105506: LD_INT 2
105508: PUSH
105509: FOR_TO
105510: IFFALSE 105637
// begin uc_side := your_side ;
105512: LD_ADDR_OWVAR 20
105516: PUSH
105517: LD_OWVAR 2
105521: ST_TO_ADDR
// uc_nation := nation_american ;
105522: LD_ADDR_OWVAR 21
105526: PUSH
105527: LD_INT 1
105529: ST_TO_ADDR
// vc_chassis := us_morphling ;
105530: LD_ADDR_OWVAR 37
105534: PUSH
105535: LD_INT 5
105537: ST_TO_ADDR
// vc_engine := engine_siberite ;
105538: LD_ADDR_OWVAR 39
105542: PUSH
105543: LD_INT 3
105545: ST_TO_ADDR
// vc_control := control_computer ;
105546: LD_ADDR_OWVAR 38
105550: PUSH
105551: LD_INT 3
105553: ST_TO_ADDR
// vc_weapon := us_double_laser ;
105554: LD_ADDR_OWVAR 40
105558: PUSH
105559: LD_INT 10
105561: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
105562: LD_VAR 0 2
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: CALL_OW 310
105575: NOT
105576: IFFALSE 105623
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
105578: CALL_OW 45
105582: PPUSH
105583: LD_VAR 0 2
105587: PUSH
105588: LD_INT 1
105590: ARRAY
105591: PPUSH
105592: CALL_OW 250
105596: PPUSH
105597: LD_VAR 0 2
105601: PUSH
105602: LD_INT 1
105604: ARRAY
105605: PPUSH
105606: CALL_OW 251
105610: PPUSH
105611: LD_INT 12
105613: PPUSH
105614: LD_INT 1
105616: PPUSH
105617: CALL_OW 50
105621: GO 105635
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
105623: CALL_OW 45
105627: PPUSH
105628: LD_INT 1
105630: PPUSH
105631: CALL_OW 51
// end ;
105635: GO 105509
105637: POP
105638: POP
// end ;
105639: PPOPN 2
105641: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
105642: LD_EXP 78
105646: PUSH
105647: LD_EXP 124
105651: AND
105652: IFFALSE 105874
105654: GO 105656
105656: DISABLE
105657: LD_INT 0
105659: PPUSH
105660: PPUSH
105661: PPUSH
105662: PPUSH
105663: PPUSH
105664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
105665: LD_ADDR_VAR 0 6
105669: PUSH
105670: LD_INT 22
105672: PUSH
105673: LD_OWVAR 2
105677: PUSH
105678: EMPTY
105679: LIST
105680: LIST
105681: PUSH
105682: LD_INT 21
105684: PUSH
105685: LD_INT 1
105687: PUSH
105688: EMPTY
105689: LIST
105690: LIST
105691: PUSH
105692: LD_INT 3
105694: PUSH
105695: LD_INT 23
105697: PUSH
105698: LD_INT 0
105700: PUSH
105701: EMPTY
105702: LIST
105703: LIST
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: PUSH
105709: EMPTY
105710: LIST
105711: LIST
105712: LIST
105713: PPUSH
105714: CALL_OW 69
105718: ST_TO_ADDR
// if not tmp then
105719: LD_VAR 0 6
105723: NOT
105724: IFFALSE 105728
// exit ;
105726: GO 105874
// s1 := rand ( 1 , 4 ) ;
105728: LD_ADDR_VAR 0 2
105732: PUSH
105733: LD_INT 1
105735: PPUSH
105736: LD_INT 4
105738: PPUSH
105739: CALL_OW 12
105743: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
105744: LD_ADDR_VAR 0 4
105748: PUSH
105749: LD_VAR 0 6
105753: PUSH
105754: LD_INT 1
105756: ARRAY
105757: PPUSH
105758: LD_VAR 0 2
105762: PPUSH
105763: CALL_OW 259
105767: ST_TO_ADDR
// if s1 = 1 then
105768: LD_VAR 0 2
105772: PUSH
105773: LD_INT 1
105775: EQUAL
105776: IFFALSE 105796
// s2 := rand ( 2 , 4 ) else
105778: LD_ADDR_VAR 0 3
105782: PUSH
105783: LD_INT 2
105785: PPUSH
105786: LD_INT 4
105788: PPUSH
105789: CALL_OW 12
105793: ST_TO_ADDR
105794: GO 105804
// s2 := 1 ;
105796: LD_ADDR_VAR 0 3
105800: PUSH
105801: LD_INT 1
105803: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
105804: LD_ADDR_VAR 0 5
105808: PUSH
105809: LD_VAR 0 6
105813: PUSH
105814: LD_INT 1
105816: ARRAY
105817: PPUSH
105818: LD_VAR 0 3
105822: PPUSH
105823: CALL_OW 259
105827: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
105828: LD_VAR 0 6
105832: PUSH
105833: LD_INT 1
105835: ARRAY
105836: PPUSH
105837: LD_VAR 0 2
105841: PPUSH
105842: LD_VAR 0 5
105846: PPUSH
105847: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
105851: LD_VAR 0 6
105855: PUSH
105856: LD_INT 1
105858: ARRAY
105859: PPUSH
105860: LD_VAR 0 3
105864: PPUSH
105865: LD_VAR 0 4
105869: PPUSH
105870: CALL_OW 237
// end ;
105874: PPOPN 6
105876: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
105877: LD_EXP 78
105881: PUSH
105882: LD_EXP 125
105886: AND
105887: IFFALSE 105966
105889: GO 105891
105891: DISABLE
105892: LD_INT 0
105894: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
105895: LD_ADDR_VAR 0 1
105899: PUSH
105900: LD_INT 22
105902: PUSH
105903: LD_OWVAR 2
105907: PUSH
105908: EMPTY
105909: LIST
105910: LIST
105911: PUSH
105912: LD_INT 30
105914: PUSH
105915: LD_INT 3
105917: PUSH
105918: EMPTY
105919: LIST
105920: LIST
105921: PUSH
105922: EMPTY
105923: LIST
105924: LIST
105925: PPUSH
105926: CALL_OW 69
105930: ST_TO_ADDR
// if not tmp then
105931: LD_VAR 0 1
105935: NOT
105936: IFFALSE 105940
// exit ;
105938: GO 105966
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
105940: LD_VAR 0 1
105944: PUSH
105945: LD_INT 1
105947: PPUSH
105948: LD_VAR 0 1
105952: PPUSH
105953: CALL_OW 12
105957: ARRAY
105958: PPUSH
105959: LD_INT 1
105961: PPUSH
105962: CALL_OW 234
// end ;
105966: PPOPN 1
105968: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
105969: LD_EXP 78
105973: PUSH
105974: LD_EXP 126
105978: AND
105979: IFFALSE 106091
105981: GO 105983
105983: DISABLE
105984: LD_INT 0
105986: PPUSH
105987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
105988: LD_ADDR_VAR 0 2
105992: PUSH
105993: LD_INT 22
105995: PUSH
105996: LD_OWVAR 2
106000: PUSH
106001: EMPTY
106002: LIST
106003: LIST
106004: PUSH
106005: LD_INT 2
106007: PUSH
106008: LD_INT 30
106010: PUSH
106011: LD_INT 27
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: PUSH
106018: LD_INT 30
106020: PUSH
106021: LD_INT 26
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: PUSH
106028: LD_INT 30
106030: PUSH
106031: LD_INT 28
106033: PUSH
106034: EMPTY
106035: LIST
106036: LIST
106037: PUSH
106038: EMPTY
106039: LIST
106040: LIST
106041: LIST
106042: LIST
106043: PUSH
106044: EMPTY
106045: LIST
106046: LIST
106047: PPUSH
106048: CALL_OW 69
106052: ST_TO_ADDR
// if not tmp then
106053: LD_VAR 0 2
106057: NOT
106058: IFFALSE 106062
// exit ;
106060: GO 106091
// for i in tmp do
106062: LD_ADDR_VAR 0 1
106066: PUSH
106067: LD_VAR 0 2
106071: PUSH
106072: FOR_IN
106073: IFFALSE 106089
// SetLives ( i , 1 ) ;
106075: LD_VAR 0 1
106079: PPUSH
106080: LD_INT 1
106082: PPUSH
106083: CALL_OW 234
106087: GO 106072
106089: POP
106090: POP
// end ;
106091: PPOPN 2
106093: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
106094: LD_EXP 78
106098: PUSH
106099: LD_EXP 127
106103: AND
106104: IFFALSE 106391
106106: GO 106108
106108: DISABLE
106109: LD_INT 0
106111: PPUSH
106112: PPUSH
106113: PPUSH
// begin i := rand ( 1 , 7 ) ;
106114: LD_ADDR_VAR 0 1
106118: PUSH
106119: LD_INT 1
106121: PPUSH
106122: LD_INT 7
106124: PPUSH
106125: CALL_OW 12
106129: ST_TO_ADDR
// case i of 1 :
106130: LD_VAR 0 1
106134: PUSH
106135: LD_INT 1
106137: DOUBLE
106138: EQUAL
106139: IFTRUE 106143
106141: GO 106153
106143: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
106144: LD_STRING earthquake(getX(game), 0, 32)
106146: PPUSH
106147: CALL_OW 559
106151: GO 106391
106153: LD_INT 2
106155: DOUBLE
106156: EQUAL
106157: IFTRUE 106161
106159: GO 106175
106161: POP
// begin ToLua ( displayStucuk(); ) ;
106162: LD_STRING displayStucuk();
106164: PPUSH
106165: CALL_OW 559
// ResetFog ;
106169: CALL_OW 335
// end ; 3 :
106173: GO 106391
106175: LD_INT 3
106177: DOUBLE
106178: EQUAL
106179: IFTRUE 106183
106181: GO 106287
106183: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
106184: LD_ADDR_VAR 0 2
106188: PUSH
106189: LD_INT 22
106191: PUSH
106192: LD_OWVAR 2
106196: PUSH
106197: EMPTY
106198: LIST
106199: LIST
106200: PUSH
106201: LD_INT 25
106203: PUSH
106204: LD_INT 1
106206: PUSH
106207: EMPTY
106208: LIST
106209: LIST
106210: PUSH
106211: EMPTY
106212: LIST
106213: LIST
106214: PPUSH
106215: CALL_OW 69
106219: ST_TO_ADDR
// if not tmp then
106220: LD_VAR 0 2
106224: NOT
106225: IFFALSE 106229
// exit ;
106227: GO 106391
// un := tmp [ rand ( 1 , tmp ) ] ;
106229: LD_ADDR_VAR 0 3
106233: PUSH
106234: LD_VAR 0 2
106238: PUSH
106239: LD_INT 1
106241: PPUSH
106242: LD_VAR 0 2
106246: PPUSH
106247: CALL_OW 12
106251: ARRAY
106252: ST_TO_ADDR
// if Crawls ( un ) then
106253: LD_VAR 0 3
106257: PPUSH
106258: CALL_OW 318
106262: IFFALSE 106273
// ComWalk ( un ) ;
106264: LD_VAR 0 3
106268: PPUSH
106269: CALL_OW 138
// SetClass ( un , class_mortar ) ;
106273: LD_VAR 0 3
106277: PPUSH
106278: LD_INT 8
106280: PPUSH
106281: CALL_OW 336
// end ; 4 :
106285: GO 106391
106287: LD_INT 4
106289: DOUBLE
106290: EQUAL
106291: IFTRUE 106295
106293: GO 106369
106295: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
106296: LD_ADDR_VAR 0 2
106300: PUSH
106301: LD_INT 22
106303: PUSH
106304: LD_OWVAR 2
106308: PUSH
106309: EMPTY
106310: LIST
106311: LIST
106312: PUSH
106313: LD_INT 30
106315: PUSH
106316: LD_INT 29
106318: PUSH
106319: EMPTY
106320: LIST
106321: LIST
106322: PUSH
106323: EMPTY
106324: LIST
106325: LIST
106326: PPUSH
106327: CALL_OW 69
106331: ST_TO_ADDR
// if not tmp then
106332: LD_VAR 0 2
106336: NOT
106337: IFFALSE 106341
// exit ;
106339: GO 106391
// CenterNowOnUnits ( tmp [ 1 ] ) ;
106341: LD_VAR 0 2
106345: PUSH
106346: LD_INT 1
106348: ARRAY
106349: PPUSH
106350: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
106354: LD_VAR 0 2
106358: PUSH
106359: LD_INT 1
106361: ARRAY
106362: PPUSH
106363: CALL_OW 65
// end ; 5 .. 7 :
106367: GO 106391
106369: LD_INT 5
106371: DOUBLE
106372: GREATEREQUAL
106373: IFFALSE 106381
106375: LD_INT 7
106377: DOUBLE
106378: LESSEQUAL
106379: IFTRUE 106383
106381: GO 106390
106383: POP
// StreamSibBomb ; end ;
106384: CALL 102628 0 0
106388: GO 106391
106390: POP
// end ;
106391: PPOPN 3
106393: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
106394: LD_EXP 78
106398: PUSH
106399: LD_EXP 128
106403: AND
106404: IFFALSE 106560
106406: GO 106408
106408: DISABLE
106409: LD_INT 0
106411: PPUSH
106412: PPUSH
106413: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
106414: LD_ADDR_VAR 0 2
106418: PUSH
106419: LD_INT 81
106421: PUSH
106422: LD_OWVAR 2
106426: PUSH
106427: EMPTY
106428: LIST
106429: LIST
106430: PUSH
106431: LD_INT 2
106433: PUSH
106434: LD_INT 21
106436: PUSH
106437: LD_INT 1
106439: PUSH
106440: EMPTY
106441: LIST
106442: LIST
106443: PUSH
106444: LD_INT 21
106446: PUSH
106447: LD_INT 2
106449: PUSH
106450: EMPTY
106451: LIST
106452: LIST
106453: PUSH
106454: EMPTY
106455: LIST
106456: LIST
106457: LIST
106458: PUSH
106459: EMPTY
106460: LIST
106461: LIST
106462: PPUSH
106463: CALL_OW 69
106467: ST_TO_ADDR
// if not tmp then
106468: LD_VAR 0 2
106472: NOT
106473: IFFALSE 106477
// exit ;
106475: GO 106560
// p := 0 ;
106477: LD_ADDR_VAR 0 3
106481: PUSH
106482: LD_INT 0
106484: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106485: LD_INT 35
106487: PPUSH
106488: CALL_OW 67
// p := p + 1 ;
106492: LD_ADDR_VAR 0 3
106496: PUSH
106497: LD_VAR 0 3
106501: PUSH
106502: LD_INT 1
106504: PLUS
106505: ST_TO_ADDR
// for i in tmp do
106506: LD_ADDR_VAR 0 1
106510: PUSH
106511: LD_VAR 0 2
106515: PUSH
106516: FOR_IN
106517: IFFALSE 106548
// if GetLives ( i ) < 1000 then
106519: LD_VAR 0 1
106523: PPUSH
106524: CALL_OW 256
106528: PUSH
106529: LD_INT 1000
106531: LESS
106532: IFFALSE 106546
// SetLives ( i , 1000 ) ;
106534: LD_VAR 0 1
106538: PPUSH
106539: LD_INT 1000
106541: PPUSH
106542: CALL_OW 234
106546: GO 106516
106548: POP
106549: POP
// until p > 20 ;
106550: LD_VAR 0 3
106554: PUSH
106555: LD_INT 20
106557: GREATER
106558: IFFALSE 106485
// end ;
106560: PPOPN 3
106562: END
// every 0 0$1 trigger StreamModeActive and sTime do
106563: LD_EXP 78
106567: PUSH
106568: LD_EXP 129
106572: AND
106573: IFFALSE 106608
106575: GO 106577
106577: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
106578: LD_INT 28
106580: PPUSH
106581: LD_OWVAR 2
106585: PPUSH
106586: LD_INT 2
106588: PPUSH
106589: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
106593: LD_INT 30
106595: PPUSH
106596: LD_OWVAR 2
106600: PPUSH
106601: LD_INT 2
106603: PPUSH
106604: CALL_OW 322
// end ;
106608: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
106609: LD_EXP 78
106613: PUSH
106614: LD_EXP 130
106618: AND
106619: IFFALSE 106740
106621: GO 106623
106623: DISABLE
106624: LD_INT 0
106626: PPUSH
106627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
106628: LD_ADDR_VAR 0 2
106632: PUSH
106633: LD_INT 22
106635: PUSH
106636: LD_OWVAR 2
106640: PUSH
106641: EMPTY
106642: LIST
106643: LIST
106644: PUSH
106645: LD_INT 21
106647: PUSH
106648: LD_INT 1
106650: PUSH
106651: EMPTY
106652: LIST
106653: LIST
106654: PUSH
106655: LD_INT 3
106657: PUSH
106658: LD_INT 23
106660: PUSH
106661: LD_INT 0
106663: PUSH
106664: EMPTY
106665: LIST
106666: LIST
106667: PUSH
106668: EMPTY
106669: LIST
106670: LIST
106671: PUSH
106672: EMPTY
106673: LIST
106674: LIST
106675: LIST
106676: PPUSH
106677: CALL_OW 69
106681: ST_TO_ADDR
// if not tmp then
106682: LD_VAR 0 2
106686: NOT
106687: IFFALSE 106691
// exit ;
106689: GO 106740
// for i in tmp do
106691: LD_ADDR_VAR 0 1
106695: PUSH
106696: LD_VAR 0 2
106700: PUSH
106701: FOR_IN
106702: IFFALSE 106738
// begin if Crawls ( i ) then
106704: LD_VAR 0 1
106708: PPUSH
106709: CALL_OW 318
106713: IFFALSE 106724
// ComWalk ( i ) ;
106715: LD_VAR 0 1
106719: PPUSH
106720: CALL_OW 138
// SetClass ( i , 2 ) ;
106724: LD_VAR 0 1
106728: PPUSH
106729: LD_INT 2
106731: PPUSH
106732: CALL_OW 336
// end ;
106736: GO 106701
106738: POP
106739: POP
// end ;
106740: PPOPN 2
106742: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
106743: LD_EXP 78
106747: PUSH
106748: LD_EXP 131
106752: AND
106753: IFFALSE 107041
106755: GO 106757
106757: DISABLE
106758: LD_INT 0
106760: PPUSH
106761: PPUSH
106762: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
106763: LD_OWVAR 2
106767: PPUSH
106768: LD_INT 9
106770: PPUSH
106771: LD_INT 1
106773: PPUSH
106774: LD_INT 1
106776: PPUSH
106777: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
106781: LD_INT 9
106783: PPUSH
106784: LD_OWVAR 2
106788: PPUSH
106789: CALL_OW 343
// uc_side := 9 ;
106793: LD_ADDR_OWVAR 20
106797: PUSH
106798: LD_INT 9
106800: ST_TO_ADDR
// uc_nation := 2 ;
106801: LD_ADDR_OWVAR 21
106805: PUSH
106806: LD_INT 2
106808: ST_TO_ADDR
// hc_name := Dark Warrior ;
106809: LD_ADDR_OWVAR 26
106813: PUSH
106814: LD_STRING Dark Warrior
106816: ST_TO_ADDR
// hc_gallery :=  ;
106817: LD_ADDR_OWVAR 33
106821: PUSH
106822: LD_STRING 
106824: ST_TO_ADDR
// hc_noskilllimit := true ;
106825: LD_ADDR_OWVAR 76
106829: PUSH
106830: LD_INT 1
106832: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
106833: LD_ADDR_OWVAR 31
106837: PUSH
106838: LD_INT 30
106840: PUSH
106841: LD_INT 30
106843: PUSH
106844: LD_INT 30
106846: PUSH
106847: LD_INT 30
106849: PUSH
106850: EMPTY
106851: LIST
106852: LIST
106853: LIST
106854: LIST
106855: ST_TO_ADDR
// un := CreateHuman ;
106856: LD_ADDR_VAR 0 3
106860: PUSH
106861: CALL_OW 44
106865: ST_TO_ADDR
// hc_noskilllimit := false ;
106866: LD_ADDR_OWVAR 76
106870: PUSH
106871: LD_INT 0
106873: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
106874: LD_VAR 0 3
106878: PPUSH
106879: LD_INT 1
106881: PPUSH
106882: CALL_OW 51
// ToLua ( playRanger() ) ;
106886: LD_STRING playRanger()
106888: PPUSH
106889: CALL_OW 559
// p := 0 ;
106893: LD_ADDR_VAR 0 2
106897: PUSH
106898: LD_INT 0
106900: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
106901: LD_INT 35
106903: PPUSH
106904: CALL_OW 67
// p := p + 1 ;
106908: LD_ADDR_VAR 0 2
106912: PUSH
106913: LD_VAR 0 2
106917: PUSH
106918: LD_INT 1
106920: PLUS
106921: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
106922: LD_VAR 0 3
106926: PPUSH
106927: CALL_OW 256
106931: PUSH
106932: LD_INT 1000
106934: LESS
106935: IFFALSE 106949
// SetLives ( un , 1000 ) ;
106937: LD_VAR 0 3
106941: PPUSH
106942: LD_INT 1000
106944: PPUSH
106945: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
106949: LD_VAR 0 3
106953: PPUSH
106954: LD_INT 81
106956: PUSH
106957: LD_OWVAR 2
106961: PUSH
106962: EMPTY
106963: LIST
106964: LIST
106965: PUSH
106966: LD_INT 91
106968: PUSH
106969: LD_VAR 0 3
106973: PUSH
106974: LD_INT 30
106976: PUSH
106977: EMPTY
106978: LIST
106979: LIST
106980: LIST
106981: PUSH
106982: EMPTY
106983: LIST
106984: LIST
106985: PPUSH
106986: CALL_OW 69
106990: PPUSH
106991: LD_VAR 0 3
106995: PPUSH
106996: CALL_OW 74
107000: PPUSH
107001: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
107005: LD_VAR 0 2
107009: PUSH
107010: LD_INT 80
107012: GREATER
107013: PUSH
107014: LD_VAR 0 3
107018: PPUSH
107019: CALL_OW 301
107023: OR
107024: IFFALSE 106901
// if un then
107026: LD_VAR 0 3
107030: IFFALSE 107041
// RemoveUnit ( un ) ;
107032: LD_VAR 0 3
107036: PPUSH
107037: CALL_OW 64
// end ;
107041: PPOPN 3
107043: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
107044: LD_EXP 132
107048: IFFALSE 107164
107050: GO 107052
107052: DISABLE
107053: LD_INT 0
107055: PPUSH
107056: PPUSH
107057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
107058: LD_ADDR_VAR 0 2
107062: PUSH
107063: LD_INT 81
107065: PUSH
107066: LD_OWVAR 2
107070: PUSH
107071: EMPTY
107072: LIST
107073: LIST
107074: PUSH
107075: LD_INT 21
107077: PUSH
107078: LD_INT 1
107080: PUSH
107081: EMPTY
107082: LIST
107083: LIST
107084: PUSH
107085: EMPTY
107086: LIST
107087: LIST
107088: PPUSH
107089: CALL_OW 69
107093: ST_TO_ADDR
// ToLua ( playComputer() ) ;
107094: LD_STRING playComputer()
107096: PPUSH
107097: CALL_OW 559
// if not tmp then
107101: LD_VAR 0 2
107105: NOT
107106: IFFALSE 107110
// exit ;
107108: GO 107164
// for i in tmp do
107110: LD_ADDR_VAR 0 1
107114: PUSH
107115: LD_VAR 0 2
107119: PUSH
107120: FOR_IN
107121: IFFALSE 107162
// for j := 1 to 4 do
107123: LD_ADDR_VAR 0 3
107127: PUSH
107128: DOUBLE
107129: LD_INT 1
107131: DEC
107132: ST_TO_ADDR
107133: LD_INT 4
107135: PUSH
107136: FOR_TO
107137: IFFALSE 107158
// SetSkill ( i , j , 10 ) ;
107139: LD_VAR 0 1
107143: PPUSH
107144: LD_VAR 0 3
107148: PPUSH
107149: LD_INT 10
107151: PPUSH
107152: CALL_OW 237
107156: GO 107136
107158: POP
107159: POP
107160: GO 107120
107162: POP
107163: POP
// end ;
107164: PPOPN 3
107166: END
// every 0 0$1 trigger s30 do var i , tmp ;
107167: LD_EXP 133
107171: IFFALSE 107240
107173: GO 107175
107175: DISABLE
107176: LD_INT 0
107178: PPUSH
107179: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107180: LD_ADDR_VAR 0 2
107184: PUSH
107185: LD_INT 22
107187: PUSH
107188: LD_OWVAR 2
107192: PUSH
107193: EMPTY
107194: LIST
107195: LIST
107196: PPUSH
107197: CALL_OW 69
107201: ST_TO_ADDR
// if not tmp then
107202: LD_VAR 0 2
107206: NOT
107207: IFFALSE 107211
// exit ;
107209: GO 107240
// for i in tmp do
107211: LD_ADDR_VAR 0 1
107215: PUSH
107216: LD_VAR 0 2
107220: PUSH
107221: FOR_IN
107222: IFFALSE 107238
// SetLives ( i , 300 ) ;
107224: LD_VAR 0 1
107228: PPUSH
107229: LD_INT 300
107231: PPUSH
107232: CALL_OW 234
107236: GO 107221
107238: POP
107239: POP
// end ;
107240: PPOPN 2
107242: END
// every 0 0$1 trigger s60 do var i , tmp ;
107243: LD_EXP 134
107247: IFFALSE 107316
107249: GO 107251
107251: DISABLE
107252: LD_INT 0
107254: PPUSH
107255: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
107256: LD_ADDR_VAR 0 2
107260: PUSH
107261: LD_INT 22
107263: PUSH
107264: LD_OWVAR 2
107268: PUSH
107269: EMPTY
107270: LIST
107271: LIST
107272: PPUSH
107273: CALL_OW 69
107277: ST_TO_ADDR
// if not tmp then
107278: LD_VAR 0 2
107282: NOT
107283: IFFALSE 107287
// exit ;
107285: GO 107316
// for i in tmp do
107287: LD_ADDR_VAR 0 1
107291: PUSH
107292: LD_VAR 0 2
107296: PUSH
107297: FOR_IN
107298: IFFALSE 107314
// SetLives ( i , 600 ) ;
107300: LD_VAR 0 1
107304: PPUSH
107305: LD_INT 600
107307: PPUSH
107308: CALL_OW 234
107312: GO 107297
107314: POP
107315: POP
// end ;
107316: PPOPN 2
107318: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
107319: LD_INT 0
107321: PPUSH
// case cmd of 301 :
107322: LD_VAR 0 1
107326: PUSH
107327: LD_INT 301
107329: DOUBLE
107330: EQUAL
107331: IFTRUE 107335
107333: GO 107367
107335: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
107336: LD_VAR 0 6
107340: PPUSH
107341: LD_VAR 0 7
107345: PPUSH
107346: LD_VAR 0 8
107350: PPUSH
107351: LD_VAR 0 4
107355: PPUSH
107356: LD_VAR 0 5
107360: PPUSH
107361: CALL 108568 0 5
107365: GO 107488
107367: LD_INT 302
107369: DOUBLE
107370: EQUAL
107371: IFTRUE 107375
107373: GO 107412
107375: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
107376: LD_VAR 0 6
107380: PPUSH
107381: LD_VAR 0 7
107385: PPUSH
107386: LD_VAR 0 8
107390: PPUSH
107391: LD_VAR 0 9
107395: PPUSH
107396: LD_VAR 0 4
107400: PPUSH
107401: LD_VAR 0 5
107405: PPUSH
107406: CALL 108659 0 6
107410: GO 107488
107412: LD_INT 303
107414: DOUBLE
107415: EQUAL
107416: IFTRUE 107420
107418: GO 107457
107420: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
107421: LD_VAR 0 6
107425: PPUSH
107426: LD_VAR 0 7
107430: PPUSH
107431: LD_VAR 0 8
107435: PPUSH
107436: LD_VAR 0 9
107440: PPUSH
107441: LD_VAR 0 4
107445: PPUSH
107446: LD_VAR 0 5
107450: PPUSH
107451: CALL 107493 0 6
107455: GO 107488
107457: LD_INT 304
107459: DOUBLE
107460: EQUAL
107461: IFTRUE 107465
107463: GO 107487
107465: POP
// hHackTeleport ( unit , x , y ) ; end ;
107466: LD_VAR 0 2
107470: PPUSH
107471: LD_VAR 0 4
107475: PPUSH
107476: LD_VAR 0 5
107480: PPUSH
107481: CALL 109252 0 3
107485: GO 107488
107487: POP
// end ;
107488: LD_VAR 0 12
107492: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
107493: LD_INT 0
107495: PPUSH
107496: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
107497: LD_VAR 0 1
107501: PUSH
107502: LD_INT 1
107504: LESS
107505: PUSH
107506: LD_VAR 0 1
107510: PUSH
107511: LD_INT 3
107513: GREATER
107514: OR
107515: PUSH
107516: LD_VAR 0 5
107520: PPUSH
107521: LD_VAR 0 6
107525: PPUSH
107526: CALL_OW 428
107530: OR
107531: IFFALSE 107535
// exit ;
107533: GO 108255
// uc_side := your_side ;
107535: LD_ADDR_OWVAR 20
107539: PUSH
107540: LD_OWVAR 2
107544: ST_TO_ADDR
// uc_nation := nation ;
107545: LD_ADDR_OWVAR 21
107549: PUSH
107550: LD_VAR 0 1
107554: ST_TO_ADDR
// bc_level = 1 ;
107555: LD_ADDR_OWVAR 43
107559: PUSH
107560: LD_INT 1
107562: ST_TO_ADDR
// case btype of 1 :
107563: LD_VAR 0 2
107567: PUSH
107568: LD_INT 1
107570: DOUBLE
107571: EQUAL
107572: IFTRUE 107576
107574: GO 107587
107576: POP
// bc_type := b_depot ; 2 :
107577: LD_ADDR_OWVAR 42
107581: PUSH
107582: LD_INT 0
107584: ST_TO_ADDR
107585: GO 108199
107587: LD_INT 2
107589: DOUBLE
107590: EQUAL
107591: IFTRUE 107595
107593: GO 107606
107595: POP
// bc_type := b_warehouse ; 3 :
107596: LD_ADDR_OWVAR 42
107600: PUSH
107601: LD_INT 1
107603: ST_TO_ADDR
107604: GO 108199
107606: LD_INT 3
107608: DOUBLE
107609: EQUAL
107610: IFTRUE 107614
107612: GO 107625
107614: POP
// bc_type := b_lab ; 4 .. 9 :
107615: LD_ADDR_OWVAR 42
107619: PUSH
107620: LD_INT 6
107622: ST_TO_ADDR
107623: GO 108199
107625: LD_INT 4
107627: DOUBLE
107628: GREATEREQUAL
107629: IFFALSE 107637
107631: LD_INT 9
107633: DOUBLE
107634: LESSEQUAL
107635: IFTRUE 107639
107637: GO 107691
107639: POP
// begin bc_type := b_lab_half ;
107640: LD_ADDR_OWVAR 42
107644: PUSH
107645: LD_INT 7
107647: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
107648: LD_ADDR_OWVAR 44
107652: PUSH
107653: LD_INT 10
107655: PUSH
107656: LD_INT 11
107658: PUSH
107659: LD_INT 12
107661: PUSH
107662: LD_INT 15
107664: PUSH
107665: LD_INT 14
107667: PUSH
107668: LD_INT 13
107670: PUSH
107671: EMPTY
107672: LIST
107673: LIST
107674: LIST
107675: LIST
107676: LIST
107677: LIST
107678: PUSH
107679: LD_VAR 0 2
107683: PUSH
107684: LD_INT 3
107686: MINUS
107687: ARRAY
107688: ST_TO_ADDR
// end ; 10 .. 13 :
107689: GO 108199
107691: LD_INT 10
107693: DOUBLE
107694: GREATEREQUAL
107695: IFFALSE 107703
107697: LD_INT 13
107699: DOUBLE
107700: LESSEQUAL
107701: IFTRUE 107705
107703: GO 107782
107705: POP
// begin bc_type := b_lab_full ;
107706: LD_ADDR_OWVAR 42
107710: PUSH
107711: LD_INT 8
107713: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
107714: LD_ADDR_OWVAR 44
107718: PUSH
107719: LD_INT 10
107721: PUSH
107722: LD_INT 12
107724: PUSH
107725: LD_INT 14
107727: PUSH
107728: LD_INT 13
107730: PUSH
107731: EMPTY
107732: LIST
107733: LIST
107734: LIST
107735: LIST
107736: PUSH
107737: LD_VAR 0 2
107741: PUSH
107742: LD_INT 9
107744: MINUS
107745: ARRAY
107746: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
107747: LD_ADDR_OWVAR 45
107751: PUSH
107752: LD_INT 11
107754: PUSH
107755: LD_INT 15
107757: PUSH
107758: LD_INT 12
107760: PUSH
107761: LD_INT 15
107763: PUSH
107764: EMPTY
107765: LIST
107766: LIST
107767: LIST
107768: LIST
107769: PUSH
107770: LD_VAR 0 2
107774: PUSH
107775: LD_INT 9
107777: MINUS
107778: ARRAY
107779: ST_TO_ADDR
// end ; 14 :
107780: GO 108199
107782: LD_INT 14
107784: DOUBLE
107785: EQUAL
107786: IFTRUE 107790
107788: GO 107801
107790: POP
// bc_type := b_workshop ; 15 :
107791: LD_ADDR_OWVAR 42
107795: PUSH
107796: LD_INT 2
107798: ST_TO_ADDR
107799: GO 108199
107801: LD_INT 15
107803: DOUBLE
107804: EQUAL
107805: IFTRUE 107809
107807: GO 107820
107809: POP
// bc_type := b_factory ; 16 :
107810: LD_ADDR_OWVAR 42
107814: PUSH
107815: LD_INT 3
107817: ST_TO_ADDR
107818: GO 108199
107820: LD_INT 16
107822: DOUBLE
107823: EQUAL
107824: IFTRUE 107828
107826: GO 107839
107828: POP
// bc_type := b_ext_gun ; 17 :
107829: LD_ADDR_OWVAR 42
107833: PUSH
107834: LD_INT 17
107836: ST_TO_ADDR
107837: GO 108199
107839: LD_INT 17
107841: DOUBLE
107842: EQUAL
107843: IFTRUE 107847
107845: GO 107875
107847: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
107848: LD_ADDR_OWVAR 42
107852: PUSH
107853: LD_INT 19
107855: PUSH
107856: LD_INT 23
107858: PUSH
107859: LD_INT 19
107861: PUSH
107862: EMPTY
107863: LIST
107864: LIST
107865: LIST
107866: PUSH
107867: LD_VAR 0 1
107871: ARRAY
107872: ST_TO_ADDR
107873: GO 108199
107875: LD_INT 18
107877: DOUBLE
107878: EQUAL
107879: IFTRUE 107883
107881: GO 107894
107883: POP
// bc_type := b_ext_radar ; 19 :
107884: LD_ADDR_OWVAR 42
107888: PUSH
107889: LD_INT 20
107891: ST_TO_ADDR
107892: GO 108199
107894: LD_INT 19
107896: DOUBLE
107897: EQUAL
107898: IFTRUE 107902
107900: GO 107913
107902: POP
// bc_type := b_ext_radio ; 20 :
107903: LD_ADDR_OWVAR 42
107907: PUSH
107908: LD_INT 22
107910: ST_TO_ADDR
107911: GO 108199
107913: LD_INT 20
107915: DOUBLE
107916: EQUAL
107917: IFTRUE 107921
107919: GO 107932
107921: POP
// bc_type := b_ext_siberium ; 21 :
107922: LD_ADDR_OWVAR 42
107926: PUSH
107927: LD_INT 21
107929: ST_TO_ADDR
107930: GO 108199
107932: LD_INT 21
107934: DOUBLE
107935: EQUAL
107936: IFTRUE 107940
107938: GO 107951
107940: POP
// bc_type := b_ext_computer ; 22 :
107941: LD_ADDR_OWVAR 42
107945: PUSH
107946: LD_INT 24
107948: ST_TO_ADDR
107949: GO 108199
107951: LD_INT 22
107953: DOUBLE
107954: EQUAL
107955: IFTRUE 107959
107957: GO 107970
107959: POP
// bc_type := b_ext_track ; 23 :
107960: LD_ADDR_OWVAR 42
107964: PUSH
107965: LD_INT 16
107967: ST_TO_ADDR
107968: GO 108199
107970: LD_INT 23
107972: DOUBLE
107973: EQUAL
107974: IFTRUE 107978
107976: GO 107989
107978: POP
// bc_type := b_ext_laser ; 24 :
107979: LD_ADDR_OWVAR 42
107983: PUSH
107984: LD_INT 25
107986: ST_TO_ADDR
107987: GO 108199
107989: LD_INT 24
107991: DOUBLE
107992: EQUAL
107993: IFTRUE 107997
107995: GO 108008
107997: POP
// bc_type := b_control_tower ; 25 :
107998: LD_ADDR_OWVAR 42
108002: PUSH
108003: LD_INT 36
108005: ST_TO_ADDR
108006: GO 108199
108008: LD_INT 25
108010: DOUBLE
108011: EQUAL
108012: IFTRUE 108016
108014: GO 108027
108016: POP
// bc_type := b_breastwork ; 26 :
108017: LD_ADDR_OWVAR 42
108021: PUSH
108022: LD_INT 31
108024: ST_TO_ADDR
108025: GO 108199
108027: LD_INT 26
108029: DOUBLE
108030: EQUAL
108031: IFTRUE 108035
108033: GO 108046
108035: POP
// bc_type := b_bunker ; 27 :
108036: LD_ADDR_OWVAR 42
108040: PUSH
108041: LD_INT 32
108043: ST_TO_ADDR
108044: GO 108199
108046: LD_INT 27
108048: DOUBLE
108049: EQUAL
108050: IFTRUE 108054
108052: GO 108065
108054: POP
// bc_type := b_turret ; 28 :
108055: LD_ADDR_OWVAR 42
108059: PUSH
108060: LD_INT 33
108062: ST_TO_ADDR
108063: GO 108199
108065: LD_INT 28
108067: DOUBLE
108068: EQUAL
108069: IFTRUE 108073
108071: GO 108084
108073: POP
// bc_type := b_armoury ; 29 :
108074: LD_ADDR_OWVAR 42
108078: PUSH
108079: LD_INT 4
108081: ST_TO_ADDR
108082: GO 108199
108084: LD_INT 29
108086: DOUBLE
108087: EQUAL
108088: IFTRUE 108092
108090: GO 108103
108092: POP
// bc_type := b_barracks ; 30 :
108093: LD_ADDR_OWVAR 42
108097: PUSH
108098: LD_INT 5
108100: ST_TO_ADDR
108101: GO 108199
108103: LD_INT 30
108105: DOUBLE
108106: EQUAL
108107: IFTRUE 108111
108109: GO 108122
108111: POP
// bc_type := b_solar_power ; 31 :
108112: LD_ADDR_OWVAR 42
108116: PUSH
108117: LD_INT 27
108119: ST_TO_ADDR
108120: GO 108199
108122: LD_INT 31
108124: DOUBLE
108125: EQUAL
108126: IFTRUE 108130
108128: GO 108141
108130: POP
// bc_type := b_oil_power ; 32 :
108131: LD_ADDR_OWVAR 42
108135: PUSH
108136: LD_INT 26
108138: ST_TO_ADDR
108139: GO 108199
108141: LD_INT 32
108143: DOUBLE
108144: EQUAL
108145: IFTRUE 108149
108147: GO 108160
108149: POP
// bc_type := b_siberite_power ; 33 :
108150: LD_ADDR_OWVAR 42
108154: PUSH
108155: LD_INT 28
108157: ST_TO_ADDR
108158: GO 108199
108160: LD_INT 33
108162: DOUBLE
108163: EQUAL
108164: IFTRUE 108168
108166: GO 108179
108168: POP
// bc_type := b_oil_mine ; 34 :
108169: LD_ADDR_OWVAR 42
108173: PUSH
108174: LD_INT 29
108176: ST_TO_ADDR
108177: GO 108199
108179: LD_INT 34
108181: DOUBLE
108182: EQUAL
108183: IFTRUE 108187
108185: GO 108198
108187: POP
// bc_type := b_siberite_mine ; end ;
108188: LD_ADDR_OWVAR 42
108192: PUSH
108193: LD_INT 30
108195: ST_TO_ADDR
108196: GO 108199
108198: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
108199: LD_ADDR_VAR 0 8
108203: PUSH
108204: LD_VAR 0 5
108208: PPUSH
108209: LD_VAR 0 6
108213: PPUSH
108214: LD_VAR 0 3
108218: PPUSH
108219: CALL_OW 47
108223: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
108224: LD_OWVAR 42
108228: PUSH
108229: LD_INT 32
108231: PUSH
108232: LD_INT 33
108234: PUSH
108235: EMPTY
108236: LIST
108237: LIST
108238: IN
108239: IFFALSE 108255
// PlaceWeaponTurret ( b , weapon ) ;
108241: LD_VAR 0 8
108245: PPUSH
108246: LD_VAR 0 4
108250: PPUSH
108251: CALL_OW 431
// end ;
108255: LD_VAR 0 7
108259: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
108260: LD_INT 0
108262: PPUSH
108263: PPUSH
108264: PPUSH
108265: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108266: LD_ADDR_VAR 0 4
108270: PUSH
108271: LD_INT 22
108273: PUSH
108274: LD_OWVAR 2
108278: PUSH
108279: EMPTY
108280: LIST
108281: LIST
108282: PUSH
108283: LD_INT 2
108285: PUSH
108286: LD_INT 30
108288: PUSH
108289: LD_INT 0
108291: PUSH
108292: EMPTY
108293: LIST
108294: LIST
108295: PUSH
108296: LD_INT 30
108298: PUSH
108299: LD_INT 1
108301: PUSH
108302: EMPTY
108303: LIST
108304: LIST
108305: PUSH
108306: EMPTY
108307: LIST
108308: LIST
108309: LIST
108310: PUSH
108311: EMPTY
108312: LIST
108313: LIST
108314: PPUSH
108315: CALL_OW 69
108319: ST_TO_ADDR
// if not tmp then
108320: LD_VAR 0 4
108324: NOT
108325: IFFALSE 108329
// exit ;
108327: GO 108388
// for i in tmp do
108329: LD_ADDR_VAR 0 2
108333: PUSH
108334: LD_VAR 0 4
108338: PUSH
108339: FOR_IN
108340: IFFALSE 108386
// for j = 1 to 3 do
108342: LD_ADDR_VAR 0 3
108346: PUSH
108347: DOUBLE
108348: LD_INT 1
108350: DEC
108351: ST_TO_ADDR
108352: LD_INT 3
108354: PUSH
108355: FOR_TO
108356: IFFALSE 108382
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
108358: LD_VAR 0 2
108362: PPUSH
108363: CALL_OW 274
108367: PPUSH
108368: LD_VAR 0 3
108372: PPUSH
108373: LD_INT 99999
108375: PPUSH
108376: CALL_OW 277
108380: GO 108355
108382: POP
108383: POP
108384: GO 108339
108386: POP
108387: POP
// end ;
108388: LD_VAR 0 1
108392: RET
// export function hHackSetLevel10 ; var i , j ; begin
108393: LD_INT 0
108395: PPUSH
108396: PPUSH
108397: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
108398: LD_ADDR_VAR 0 2
108402: PUSH
108403: LD_INT 21
108405: PUSH
108406: LD_INT 1
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: PPUSH
108413: CALL_OW 69
108417: PUSH
108418: FOR_IN
108419: IFFALSE 108471
// if IsSelected ( i ) then
108421: LD_VAR 0 2
108425: PPUSH
108426: CALL_OW 306
108430: IFFALSE 108469
// begin for j := 1 to 4 do
108432: LD_ADDR_VAR 0 3
108436: PUSH
108437: DOUBLE
108438: LD_INT 1
108440: DEC
108441: ST_TO_ADDR
108442: LD_INT 4
108444: PUSH
108445: FOR_TO
108446: IFFALSE 108467
// SetSkill ( i , j , 10 ) ;
108448: LD_VAR 0 2
108452: PPUSH
108453: LD_VAR 0 3
108457: PPUSH
108458: LD_INT 10
108460: PPUSH
108461: CALL_OW 237
108465: GO 108445
108467: POP
108468: POP
// end ;
108469: GO 108418
108471: POP
108472: POP
// end ;
108473: LD_VAR 0 1
108477: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
108478: LD_INT 0
108480: PPUSH
108481: PPUSH
108482: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
108483: LD_ADDR_VAR 0 2
108487: PUSH
108488: LD_INT 22
108490: PUSH
108491: LD_OWVAR 2
108495: PUSH
108496: EMPTY
108497: LIST
108498: LIST
108499: PUSH
108500: LD_INT 21
108502: PUSH
108503: LD_INT 1
108505: PUSH
108506: EMPTY
108507: LIST
108508: LIST
108509: PUSH
108510: EMPTY
108511: LIST
108512: LIST
108513: PPUSH
108514: CALL_OW 69
108518: PUSH
108519: FOR_IN
108520: IFFALSE 108561
// begin for j := 1 to 4 do
108522: LD_ADDR_VAR 0 3
108526: PUSH
108527: DOUBLE
108528: LD_INT 1
108530: DEC
108531: ST_TO_ADDR
108532: LD_INT 4
108534: PUSH
108535: FOR_TO
108536: IFFALSE 108557
// SetSkill ( i , j , 10 ) ;
108538: LD_VAR 0 2
108542: PPUSH
108543: LD_VAR 0 3
108547: PPUSH
108548: LD_INT 10
108550: PPUSH
108551: CALL_OW 237
108555: GO 108535
108557: POP
108558: POP
// end ;
108559: GO 108519
108561: POP
108562: POP
// end ;
108563: LD_VAR 0 1
108567: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
108568: LD_INT 0
108570: PPUSH
// uc_side := your_side ;
108571: LD_ADDR_OWVAR 20
108575: PUSH
108576: LD_OWVAR 2
108580: ST_TO_ADDR
// uc_nation := nation ;
108581: LD_ADDR_OWVAR 21
108585: PUSH
108586: LD_VAR 0 1
108590: ST_TO_ADDR
// InitHc ;
108591: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
108595: LD_INT 0
108597: PPUSH
108598: LD_VAR 0 2
108602: PPUSH
108603: LD_VAR 0 3
108607: PPUSH
108608: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
108612: LD_VAR 0 4
108616: PPUSH
108617: LD_VAR 0 5
108621: PPUSH
108622: CALL_OW 428
108626: PUSH
108627: LD_INT 0
108629: EQUAL
108630: IFFALSE 108654
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
108632: CALL_OW 44
108636: PPUSH
108637: LD_VAR 0 4
108641: PPUSH
108642: LD_VAR 0 5
108646: PPUSH
108647: LD_INT 1
108649: PPUSH
108650: CALL_OW 48
// end ;
108654: LD_VAR 0 6
108658: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
108659: LD_INT 0
108661: PPUSH
108662: PPUSH
// uc_side := your_side ;
108663: LD_ADDR_OWVAR 20
108667: PUSH
108668: LD_OWVAR 2
108672: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
108673: LD_VAR 0 1
108677: PUSH
108678: LD_INT 1
108680: PUSH
108681: LD_INT 2
108683: PUSH
108684: LD_INT 3
108686: PUSH
108687: LD_INT 4
108689: PUSH
108690: LD_INT 5
108692: PUSH
108693: EMPTY
108694: LIST
108695: LIST
108696: LIST
108697: LIST
108698: LIST
108699: IN
108700: IFFALSE 108712
// uc_nation := nation_american else
108702: LD_ADDR_OWVAR 21
108706: PUSH
108707: LD_INT 1
108709: ST_TO_ADDR
108710: GO 108755
// if chassis in [ 11 , 12 , 13 , 14 ] then
108712: LD_VAR 0 1
108716: PUSH
108717: LD_INT 11
108719: PUSH
108720: LD_INT 12
108722: PUSH
108723: LD_INT 13
108725: PUSH
108726: LD_INT 14
108728: PUSH
108729: EMPTY
108730: LIST
108731: LIST
108732: LIST
108733: LIST
108734: IN
108735: IFFALSE 108747
// uc_nation := nation_arabian else
108737: LD_ADDR_OWVAR 21
108741: PUSH
108742: LD_INT 2
108744: ST_TO_ADDR
108745: GO 108755
// uc_nation := nation_russian ;
108747: LD_ADDR_OWVAR 21
108751: PUSH
108752: LD_INT 3
108754: ST_TO_ADDR
// vc_chassis := chassis ;
108755: LD_ADDR_OWVAR 37
108759: PUSH
108760: LD_VAR 0 1
108764: ST_TO_ADDR
// vc_engine := engine ;
108765: LD_ADDR_OWVAR 39
108769: PUSH
108770: LD_VAR 0 2
108774: ST_TO_ADDR
// vc_control := control ;
108775: LD_ADDR_OWVAR 38
108779: PUSH
108780: LD_VAR 0 3
108784: ST_TO_ADDR
// vc_weapon := weapon ;
108785: LD_ADDR_OWVAR 40
108789: PUSH
108790: LD_VAR 0 4
108794: ST_TO_ADDR
// un := CreateVehicle ;
108795: LD_ADDR_VAR 0 8
108799: PUSH
108800: CALL_OW 45
108804: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
108805: LD_VAR 0 8
108809: PPUSH
108810: LD_INT 0
108812: PPUSH
108813: LD_INT 5
108815: PPUSH
108816: CALL_OW 12
108820: PPUSH
108821: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
108825: LD_VAR 0 8
108829: PPUSH
108830: LD_VAR 0 5
108834: PPUSH
108835: LD_VAR 0 6
108839: PPUSH
108840: LD_INT 1
108842: PPUSH
108843: CALL_OW 48
// end ;
108847: LD_VAR 0 7
108851: RET
// export hInvincible ; every 1 do
108852: GO 108854
108854: DISABLE
// hInvincible := [ ] ;
108855: LD_ADDR_EXP 135
108859: PUSH
108860: EMPTY
108861: ST_TO_ADDR
108862: END
// every 10 do var i ;
108863: GO 108865
108865: DISABLE
108866: LD_INT 0
108868: PPUSH
// begin enable ;
108869: ENABLE
// if not hInvincible then
108870: LD_EXP 135
108874: NOT
108875: IFFALSE 108879
// exit ;
108877: GO 108923
// for i in hInvincible do
108879: LD_ADDR_VAR 0 1
108883: PUSH
108884: LD_EXP 135
108888: PUSH
108889: FOR_IN
108890: IFFALSE 108921
// if GetLives ( i ) < 1000 then
108892: LD_VAR 0 1
108896: PPUSH
108897: CALL_OW 256
108901: PUSH
108902: LD_INT 1000
108904: LESS
108905: IFFALSE 108919
// SetLives ( i , 1000 ) ;
108907: LD_VAR 0 1
108911: PPUSH
108912: LD_INT 1000
108914: PPUSH
108915: CALL_OW 234
108919: GO 108889
108921: POP
108922: POP
// end ;
108923: PPOPN 1
108925: END
// export function hHackInvincible ; var i ; begin
108926: LD_INT 0
108928: PPUSH
108929: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
108930: LD_ADDR_VAR 0 2
108934: PUSH
108935: LD_INT 2
108937: PUSH
108938: LD_INT 21
108940: PUSH
108941: LD_INT 1
108943: PUSH
108944: EMPTY
108945: LIST
108946: LIST
108947: PUSH
108948: LD_INT 21
108950: PUSH
108951: LD_INT 2
108953: PUSH
108954: EMPTY
108955: LIST
108956: LIST
108957: PUSH
108958: EMPTY
108959: LIST
108960: LIST
108961: LIST
108962: PPUSH
108963: CALL_OW 69
108967: PUSH
108968: FOR_IN
108969: IFFALSE 109030
// if IsSelected ( i ) then
108971: LD_VAR 0 2
108975: PPUSH
108976: CALL_OW 306
108980: IFFALSE 109028
// begin if i in hInvincible then
108982: LD_VAR 0 2
108986: PUSH
108987: LD_EXP 135
108991: IN
108992: IFFALSE 109012
// hInvincible := hInvincible diff i else
108994: LD_ADDR_EXP 135
108998: PUSH
108999: LD_EXP 135
109003: PUSH
109004: LD_VAR 0 2
109008: DIFF
109009: ST_TO_ADDR
109010: GO 109028
// hInvincible := hInvincible union i ;
109012: LD_ADDR_EXP 135
109016: PUSH
109017: LD_EXP 135
109021: PUSH
109022: LD_VAR 0 2
109026: UNION
109027: ST_TO_ADDR
// end ;
109028: GO 108968
109030: POP
109031: POP
// end ;
109032: LD_VAR 0 1
109036: RET
// export function hHackInvisible ; var i , j ; begin
109037: LD_INT 0
109039: PPUSH
109040: PPUSH
109041: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
109042: LD_ADDR_VAR 0 2
109046: PUSH
109047: LD_INT 21
109049: PUSH
109050: LD_INT 1
109052: PUSH
109053: EMPTY
109054: LIST
109055: LIST
109056: PPUSH
109057: CALL_OW 69
109061: PUSH
109062: FOR_IN
109063: IFFALSE 109087
// if IsSelected ( i ) then
109065: LD_VAR 0 2
109069: PPUSH
109070: CALL_OW 306
109074: IFFALSE 109085
// ComForceInvisible ( i ) ;
109076: LD_VAR 0 2
109080: PPUSH
109081: CALL_OW 496
109085: GO 109062
109087: POP
109088: POP
// end ;
109089: LD_VAR 0 1
109093: RET
// export function hHackChangeYourSide ; begin
109094: LD_INT 0
109096: PPUSH
// if your_side = 8 then
109097: LD_OWVAR 2
109101: PUSH
109102: LD_INT 8
109104: EQUAL
109105: IFFALSE 109117
// your_side := 0 else
109107: LD_ADDR_OWVAR 2
109111: PUSH
109112: LD_INT 0
109114: ST_TO_ADDR
109115: GO 109131
// your_side := your_side + 1 ;
109117: LD_ADDR_OWVAR 2
109121: PUSH
109122: LD_OWVAR 2
109126: PUSH
109127: LD_INT 1
109129: PLUS
109130: ST_TO_ADDR
// end ;
109131: LD_VAR 0 1
109135: RET
// export function hHackChangeUnitSide ; var i , j ; begin
109136: LD_INT 0
109138: PPUSH
109139: PPUSH
109140: PPUSH
// for i in all_units do
109141: LD_ADDR_VAR 0 2
109145: PUSH
109146: LD_OWVAR 3
109150: PUSH
109151: FOR_IN
109152: IFFALSE 109230
// if IsSelected ( i ) then
109154: LD_VAR 0 2
109158: PPUSH
109159: CALL_OW 306
109163: IFFALSE 109228
// begin j := GetSide ( i ) ;
109165: LD_ADDR_VAR 0 3
109169: PUSH
109170: LD_VAR 0 2
109174: PPUSH
109175: CALL_OW 255
109179: ST_TO_ADDR
// if j = 8 then
109180: LD_VAR 0 3
109184: PUSH
109185: LD_INT 8
109187: EQUAL
109188: IFFALSE 109200
// j := 0 else
109190: LD_ADDR_VAR 0 3
109194: PUSH
109195: LD_INT 0
109197: ST_TO_ADDR
109198: GO 109214
// j := j + 1 ;
109200: LD_ADDR_VAR 0 3
109204: PUSH
109205: LD_VAR 0 3
109209: PUSH
109210: LD_INT 1
109212: PLUS
109213: ST_TO_ADDR
// SetSide ( i , j ) ;
109214: LD_VAR 0 2
109218: PPUSH
109219: LD_VAR 0 3
109223: PPUSH
109224: CALL_OW 235
// end ;
109228: GO 109151
109230: POP
109231: POP
// end ;
109232: LD_VAR 0 1
109236: RET
// export function hHackFog ; begin
109237: LD_INT 0
109239: PPUSH
// FogOff ( true ) ;
109240: LD_INT 1
109242: PPUSH
109243: CALL_OW 344
// end ;
109247: LD_VAR 0 1
109251: RET
// export function hHackTeleport ( unit , x , y ) ; begin
109252: LD_INT 0
109254: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
109255: LD_VAR 0 1
109259: PPUSH
109260: LD_VAR 0 2
109264: PPUSH
109265: LD_VAR 0 3
109269: PPUSH
109270: LD_INT 1
109272: PPUSH
109273: LD_INT 1
109275: PPUSH
109276: CALL_OW 483
// CenterOnXY ( x , y ) ;
109280: LD_VAR 0 2
109284: PPUSH
109285: LD_VAR 0 3
109289: PPUSH
109290: CALL_OW 84
// end ;
109294: LD_VAR 0 4
109298: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
109299: LD_INT 0
109301: PPUSH
109302: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
109303: LD_VAR 0 1
109307: NOT
109308: PUSH
109309: LD_VAR 0 2
109313: PPUSH
109314: LD_VAR 0 3
109318: PPUSH
109319: CALL_OW 488
109323: NOT
109324: OR
109325: PUSH
109326: LD_VAR 0 1
109330: PPUSH
109331: CALL_OW 266
109335: PUSH
109336: LD_INT 3
109338: NONEQUAL
109339: PUSH
109340: LD_VAR 0 1
109344: PPUSH
109345: CALL_OW 247
109349: PUSH
109350: LD_INT 1
109352: EQUAL
109353: NOT
109354: AND
109355: OR
109356: IFFALSE 109360
// exit ;
109358: GO 109509
// if GetType ( factory ) = unit_human then
109360: LD_VAR 0 1
109364: PPUSH
109365: CALL_OW 247
109369: PUSH
109370: LD_INT 1
109372: EQUAL
109373: IFFALSE 109390
// factory := IsInUnit ( factory ) ;
109375: LD_ADDR_VAR 0 1
109379: PUSH
109380: LD_VAR 0 1
109384: PPUSH
109385: CALL_OW 310
109389: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
109390: LD_VAR 0 1
109394: PPUSH
109395: CALL_OW 266
109399: PUSH
109400: LD_INT 3
109402: NONEQUAL
109403: IFFALSE 109407
// exit ;
109405: GO 109509
// if HexInfo ( x , y ) = factory then
109407: LD_VAR 0 2
109411: PPUSH
109412: LD_VAR 0 3
109416: PPUSH
109417: CALL_OW 428
109421: PUSH
109422: LD_VAR 0 1
109426: EQUAL
109427: IFFALSE 109454
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
109429: LD_ADDR_EXP 136
109433: PUSH
109434: LD_EXP 136
109438: PPUSH
109439: LD_VAR 0 1
109443: PPUSH
109444: LD_INT 0
109446: PPUSH
109447: CALL_OW 1
109451: ST_TO_ADDR
109452: GO 109505
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
109454: LD_ADDR_EXP 136
109458: PUSH
109459: LD_EXP 136
109463: PPUSH
109464: LD_VAR 0 1
109468: PPUSH
109469: LD_VAR 0 1
109473: PPUSH
109474: CALL_OW 255
109478: PUSH
109479: LD_VAR 0 1
109483: PUSH
109484: LD_VAR 0 2
109488: PUSH
109489: LD_VAR 0 3
109493: PUSH
109494: EMPTY
109495: LIST
109496: LIST
109497: LIST
109498: LIST
109499: PPUSH
109500: CALL_OW 1
109504: ST_TO_ADDR
// UpdateFactoryWaypoints ;
109505: CALL 109514 0 0
// end ;
109509: LD_VAR 0 4
109513: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
109514: LD_INT 0
109516: PPUSH
109517: PPUSH
109518: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
109519: LD_STRING resetFactoryWaypoint();
109521: PPUSH
109522: CALL_OW 559
// if factoryWaypoints then
109526: LD_EXP 136
109530: IFFALSE 109656
// begin list := PrepareArray ( factoryWaypoints ) ;
109532: LD_ADDR_VAR 0 3
109536: PUSH
109537: LD_EXP 136
109541: PPUSH
109542: CALL 52199 0 1
109546: ST_TO_ADDR
// for i := 1 to list do
109547: LD_ADDR_VAR 0 2
109551: PUSH
109552: DOUBLE
109553: LD_INT 1
109555: DEC
109556: ST_TO_ADDR
109557: LD_VAR 0 3
109561: PUSH
109562: FOR_TO
109563: IFFALSE 109654
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109565: LD_STRING setFactoryWaypointXY(
109567: PUSH
109568: LD_VAR 0 3
109572: PUSH
109573: LD_VAR 0 2
109577: ARRAY
109578: PUSH
109579: LD_INT 1
109581: ARRAY
109582: STR
109583: PUSH
109584: LD_STRING ,
109586: STR
109587: PUSH
109588: LD_VAR 0 3
109592: PUSH
109593: LD_VAR 0 2
109597: ARRAY
109598: PUSH
109599: LD_INT 2
109601: ARRAY
109602: STR
109603: PUSH
109604: LD_STRING ,
109606: STR
109607: PUSH
109608: LD_VAR 0 3
109612: PUSH
109613: LD_VAR 0 2
109617: ARRAY
109618: PUSH
109619: LD_INT 3
109621: ARRAY
109622: STR
109623: PUSH
109624: LD_STRING ,
109626: STR
109627: PUSH
109628: LD_VAR 0 3
109632: PUSH
109633: LD_VAR 0 2
109637: ARRAY
109638: PUSH
109639: LD_INT 4
109641: ARRAY
109642: STR
109643: PUSH
109644: LD_STRING )
109646: STR
109647: PPUSH
109648: CALL_OW 559
109652: GO 109562
109654: POP
109655: POP
// end ; end ;
109656: LD_VAR 0 1
109660: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
109661: LD_INT 0
109663: PPUSH
// if HexInfo ( x , y ) = warehouse then
109664: LD_VAR 0 2
109668: PPUSH
109669: LD_VAR 0 3
109673: PPUSH
109674: CALL_OW 428
109678: PUSH
109679: LD_VAR 0 1
109683: EQUAL
109684: IFFALSE 109711
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
109686: LD_ADDR_EXP 137
109690: PUSH
109691: LD_EXP 137
109695: PPUSH
109696: LD_VAR 0 1
109700: PPUSH
109701: LD_INT 0
109703: PPUSH
109704: CALL_OW 1
109708: ST_TO_ADDR
109709: GO 109762
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
109711: LD_ADDR_EXP 137
109715: PUSH
109716: LD_EXP 137
109720: PPUSH
109721: LD_VAR 0 1
109725: PPUSH
109726: LD_VAR 0 1
109730: PPUSH
109731: CALL_OW 255
109735: PUSH
109736: LD_VAR 0 1
109740: PUSH
109741: LD_VAR 0 2
109745: PUSH
109746: LD_VAR 0 3
109750: PUSH
109751: EMPTY
109752: LIST
109753: LIST
109754: LIST
109755: LIST
109756: PPUSH
109757: CALL_OW 1
109761: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
109762: CALL 109771 0 0
// end ;
109766: LD_VAR 0 4
109770: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
109771: LD_INT 0
109773: PPUSH
109774: PPUSH
109775: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
109776: LD_STRING resetWarehouseGatheringPoints();
109778: PPUSH
109779: CALL_OW 559
// if warehouseGatheringPoints then
109783: LD_EXP 137
109787: IFFALSE 109913
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
109789: LD_ADDR_VAR 0 3
109793: PUSH
109794: LD_EXP 137
109798: PPUSH
109799: CALL 52199 0 1
109803: ST_TO_ADDR
// for i := 1 to list do
109804: LD_ADDR_VAR 0 2
109808: PUSH
109809: DOUBLE
109810: LD_INT 1
109812: DEC
109813: ST_TO_ADDR
109814: LD_VAR 0 3
109818: PUSH
109819: FOR_TO
109820: IFFALSE 109911
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
109822: LD_STRING setWarehouseGatheringPointXY(
109824: PUSH
109825: LD_VAR 0 3
109829: PUSH
109830: LD_VAR 0 2
109834: ARRAY
109835: PUSH
109836: LD_INT 1
109838: ARRAY
109839: STR
109840: PUSH
109841: LD_STRING ,
109843: STR
109844: PUSH
109845: LD_VAR 0 3
109849: PUSH
109850: LD_VAR 0 2
109854: ARRAY
109855: PUSH
109856: LD_INT 2
109858: ARRAY
109859: STR
109860: PUSH
109861: LD_STRING ,
109863: STR
109864: PUSH
109865: LD_VAR 0 3
109869: PUSH
109870: LD_VAR 0 2
109874: ARRAY
109875: PUSH
109876: LD_INT 3
109878: ARRAY
109879: STR
109880: PUSH
109881: LD_STRING ,
109883: STR
109884: PUSH
109885: LD_VAR 0 3
109889: PUSH
109890: LD_VAR 0 2
109894: ARRAY
109895: PUSH
109896: LD_INT 4
109898: ARRAY
109899: STR
109900: PUSH
109901: LD_STRING )
109903: STR
109904: PPUSH
109905: CALL_OW 559
109909: GO 109819
109911: POP
109912: POP
// end ; end ;
109913: LD_VAR 0 1
109917: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
109918: LD_EXP 137
109922: IFFALSE 110607
109924: GO 109926
109926: DISABLE
109927: LD_INT 0
109929: PPUSH
109930: PPUSH
109931: PPUSH
109932: PPUSH
109933: PPUSH
109934: PPUSH
109935: PPUSH
109936: PPUSH
109937: PPUSH
// begin enable ;
109938: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
109939: LD_ADDR_VAR 0 3
109943: PUSH
109944: LD_EXP 137
109948: PPUSH
109949: CALL 52199 0 1
109953: ST_TO_ADDR
// if not list then
109954: LD_VAR 0 3
109958: NOT
109959: IFFALSE 109963
// exit ;
109961: GO 110607
// for i := 1 to list do
109963: LD_ADDR_VAR 0 1
109967: PUSH
109968: DOUBLE
109969: LD_INT 1
109971: DEC
109972: ST_TO_ADDR
109973: LD_VAR 0 3
109977: PUSH
109978: FOR_TO
109979: IFFALSE 110605
// begin depot := list [ i ] [ 2 ] ;
109981: LD_ADDR_VAR 0 8
109985: PUSH
109986: LD_VAR 0 3
109990: PUSH
109991: LD_VAR 0 1
109995: ARRAY
109996: PUSH
109997: LD_INT 2
109999: ARRAY
110000: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
110001: LD_ADDR_VAR 0 5
110005: PUSH
110006: LD_VAR 0 3
110010: PUSH
110011: LD_VAR 0 1
110015: ARRAY
110016: PUSH
110017: LD_INT 1
110019: ARRAY
110020: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
110021: LD_VAR 0 8
110025: PPUSH
110026: CALL_OW 301
110030: PUSH
110031: LD_VAR 0 5
110035: PUSH
110036: LD_VAR 0 8
110040: PPUSH
110041: CALL_OW 255
110045: NONEQUAL
110046: OR
110047: IFFALSE 110076
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
110049: LD_ADDR_EXP 137
110053: PUSH
110054: LD_EXP 137
110058: PPUSH
110059: LD_VAR 0 8
110063: PPUSH
110064: LD_INT 0
110066: PPUSH
110067: CALL_OW 1
110071: ST_TO_ADDR
// exit ;
110072: POP
110073: POP
110074: GO 110607
// end ; x := list [ i ] [ 3 ] ;
110076: LD_ADDR_VAR 0 6
110080: PUSH
110081: LD_VAR 0 3
110085: PUSH
110086: LD_VAR 0 1
110090: ARRAY
110091: PUSH
110092: LD_INT 3
110094: ARRAY
110095: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
110096: LD_ADDR_VAR 0 7
110100: PUSH
110101: LD_VAR 0 3
110105: PUSH
110106: LD_VAR 0 1
110110: ARRAY
110111: PUSH
110112: LD_INT 4
110114: ARRAY
110115: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
110116: LD_ADDR_VAR 0 9
110120: PUSH
110121: LD_VAR 0 6
110125: PPUSH
110126: LD_VAR 0 7
110130: PPUSH
110131: LD_INT 16
110133: PPUSH
110134: CALL 50787 0 3
110138: ST_TO_ADDR
// if not cratesNearbyPoint then
110139: LD_VAR 0 9
110143: NOT
110144: IFFALSE 110150
// exit ;
110146: POP
110147: POP
110148: GO 110607
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
110150: LD_ADDR_VAR 0 4
110154: PUSH
110155: LD_INT 22
110157: PUSH
110158: LD_VAR 0 5
110162: PUSH
110163: EMPTY
110164: LIST
110165: LIST
110166: PUSH
110167: LD_INT 3
110169: PUSH
110170: LD_INT 60
110172: PUSH
110173: EMPTY
110174: LIST
110175: PUSH
110176: EMPTY
110177: LIST
110178: LIST
110179: PUSH
110180: LD_INT 91
110182: PUSH
110183: LD_VAR 0 8
110187: PUSH
110188: LD_INT 6
110190: PUSH
110191: EMPTY
110192: LIST
110193: LIST
110194: LIST
110195: PUSH
110196: LD_INT 2
110198: PUSH
110199: LD_INT 25
110201: PUSH
110202: LD_INT 2
110204: PUSH
110205: EMPTY
110206: LIST
110207: LIST
110208: PUSH
110209: LD_INT 25
110211: PUSH
110212: LD_INT 16
110214: PUSH
110215: EMPTY
110216: LIST
110217: LIST
110218: PUSH
110219: EMPTY
110220: LIST
110221: LIST
110222: LIST
110223: PUSH
110224: EMPTY
110225: LIST
110226: LIST
110227: LIST
110228: LIST
110229: PPUSH
110230: CALL_OW 69
110234: PUSH
110235: LD_VAR 0 8
110239: PPUSH
110240: CALL_OW 313
110244: PPUSH
110245: LD_INT 3
110247: PUSH
110248: LD_INT 60
110250: PUSH
110251: EMPTY
110252: LIST
110253: PUSH
110254: EMPTY
110255: LIST
110256: LIST
110257: PUSH
110258: LD_INT 2
110260: PUSH
110261: LD_INT 25
110263: PUSH
110264: LD_INT 2
110266: PUSH
110267: EMPTY
110268: LIST
110269: LIST
110270: PUSH
110271: LD_INT 25
110273: PUSH
110274: LD_INT 16
110276: PUSH
110277: EMPTY
110278: LIST
110279: LIST
110280: PUSH
110281: EMPTY
110282: LIST
110283: LIST
110284: LIST
110285: PUSH
110286: EMPTY
110287: LIST
110288: LIST
110289: PPUSH
110290: CALL_OW 72
110294: UNION
110295: ST_TO_ADDR
// if tmp then
110296: LD_VAR 0 4
110300: IFFALSE 110380
// begin tmp := ShrinkArray ( tmp , 3 ) ;
110302: LD_ADDR_VAR 0 4
110306: PUSH
110307: LD_VAR 0 4
110311: PPUSH
110312: LD_INT 3
110314: PPUSH
110315: CALL 48756 0 2
110319: ST_TO_ADDR
// for j in tmp do
110320: LD_ADDR_VAR 0 2
110324: PUSH
110325: LD_VAR 0 4
110329: PUSH
110330: FOR_IN
110331: IFFALSE 110374
// begin if IsInUnit ( j ) then
110333: LD_VAR 0 2
110337: PPUSH
110338: CALL_OW 310
110342: IFFALSE 110353
// ComExit ( j ) ;
110344: LD_VAR 0 2
110348: PPUSH
110349: CALL 48839 0 1
// AddComCollect ( j , x , y ) ;
110353: LD_VAR 0 2
110357: PPUSH
110358: LD_VAR 0 6
110362: PPUSH
110363: LD_VAR 0 7
110367: PPUSH
110368: CALL_OW 177
// end ;
110372: GO 110330
110374: POP
110375: POP
// exit ;
110376: POP
110377: POP
110378: GO 110607
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
110380: LD_ADDR_VAR 0 4
110384: PUSH
110385: LD_INT 22
110387: PUSH
110388: LD_VAR 0 5
110392: PUSH
110393: EMPTY
110394: LIST
110395: LIST
110396: PUSH
110397: LD_INT 91
110399: PUSH
110400: LD_VAR 0 8
110404: PUSH
110405: LD_INT 8
110407: PUSH
110408: EMPTY
110409: LIST
110410: LIST
110411: LIST
110412: PUSH
110413: LD_INT 2
110415: PUSH
110416: LD_INT 34
110418: PUSH
110419: LD_INT 12
110421: PUSH
110422: EMPTY
110423: LIST
110424: LIST
110425: PUSH
110426: LD_INT 34
110428: PUSH
110429: LD_INT 51
110431: PUSH
110432: EMPTY
110433: LIST
110434: LIST
110435: PUSH
110436: LD_INT 34
110438: PUSH
110439: LD_INT 32
110441: PUSH
110442: EMPTY
110443: LIST
110444: LIST
110445: PUSH
110446: LD_INT 34
110448: PUSH
110449: LD_INT 89
110451: PUSH
110452: EMPTY
110453: LIST
110454: LIST
110455: PUSH
110456: EMPTY
110457: LIST
110458: LIST
110459: LIST
110460: LIST
110461: LIST
110462: PUSH
110463: EMPTY
110464: LIST
110465: LIST
110466: LIST
110467: PPUSH
110468: CALL_OW 69
110472: ST_TO_ADDR
// if tmp then
110473: LD_VAR 0 4
110477: IFFALSE 110603
// begin for j in tmp do
110479: LD_ADDR_VAR 0 2
110483: PUSH
110484: LD_VAR 0 4
110488: PUSH
110489: FOR_IN
110490: IFFALSE 110601
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
110492: LD_VAR 0 2
110496: PPUSH
110497: CALL_OW 262
110501: PUSH
110502: LD_INT 3
110504: EQUAL
110505: PUSH
110506: LD_VAR 0 2
110510: PPUSH
110511: CALL_OW 261
110515: PUSH
110516: LD_INT 20
110518: GREATER
110519: OR
110520: PUSH
110521: LD_VAR 0 2
110525: PPUSH
110526: CALL_OW 314
110530: NOT
110531: AND
110532: PUSH
110533: LD_VAR 0 2
110537: PPUSH
110538: CALL_OW 263
110542: PUSH
110543: LD_INT 1
110545: NONEQUAL
110546: PUSH
110547: LD_VAR 0 2
110551: PPUSH
110552: CALL_OW 311
110556: OR
110557: AND
110558: IFFALSE 110599
// begin ComCollect ( j , x , y ) ;
110560: LD_VAR 0 2
110564: PPUSH
110565: LD_VAR 0 6
110569: PPUSH
110570: LD_VAR 0 7
110574: PPUSH
110575: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
110579: LD_VAR 0 2
110583: PPUSH
110584: LD_VAR 0 8
110588: PPUSH
110589: CALL_OW 172
// exit ;
110593: POP
110594: POP
110595: POP
110596: POP
110597: GO 110607
// end ;
110599: GO 110489
110601: POP
110602: POP
// end ; end ;
110603: GO 109978
110605: POP
110606: POP
// end ; end_of_file
110607: PPOPN 9
110609: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110610: LD_VAR 0 1
110614: PPUSH
110615: LD_VAR 0 2
110619: PPUSH
110620: LD_VAR 0 3
110624: PPUSH
110625: LD_VAR 0 4
110629: PPUSH
110630: LD_VAR 0 5
110634: PPUSH
110635: LD_VAR 0 6
110639: PPUSH
110640: CALL 94939 0 6
// end ;
110644: PPOPN 6
110646: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
110647: LD_INT 0
110649: PPUSH
// begin if not units then
110650: LD_VAR 0 1
110654: NOT
110655: IFFALSE 110659
// exit ;
110657: GO 110659
// end ;
110659: PPOPN 7
110661: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
110662: CALL 94833 0 0
// end ;
110666: PPOPN 1
110668: END
