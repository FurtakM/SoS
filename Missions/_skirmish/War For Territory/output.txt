// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 81185 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 3
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 44367 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 44367 0 9
// PrepareGensher ;
 189: CALL 3160 0 0
// PreparePopov ;
 193: CALL 6371 0 0
// PreparePowell ;
 197: CALL 593 0 0
// PrepareSikorski ;
 201: CALL 9059 0 0
// MC_Start ( ) ;
 205: CALL 52724 0 0
// Action ;
 209: CALL 9466 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 4294 0 0
// InitMC_Powell ( ) ;
 284: CALL 1515 0 0
// InitMC_Popov ( ) ;
 288: CALL 7529 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$20 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 700
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 40
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 525
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 0 0$35 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 1225
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ;
 457: PPOPN 3
 459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 460: LD_INT 3
 462: PUSH
 463: LD_INT 22
 465: PUSH
 466: LD_INT 1
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: PUSH
 477: LD_INT 32
 479: PUSH
 480: LD_INT 1
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: PPUSH
 491: CALL_OW 69
 495: IFFALSE 590
 497: GO 499
 499: DISABLE
 500: LD_INT 0
 502: PPUSH
 503: PPUSH
// begin enable ;
 504: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 505: LD_ADDR_VAR 0 2
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: LD_INT 22
 515: PUSH
 516: LD_INT 1
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: PUSH
 527: LD_INT 32
 529: PUSH
 530: LD_INT 1
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PUSH
 537: EMPTY
 538: LIST
 539: LIST
 540: PPUSH
 541: CALL_OW 69
 545: ST_TO_ADDR
// for i in tmp do
 546: LD_ADDR_VAR 0 1
 550: PUSH
 551: LD_VAR 0 2
 555: PUSH
 556: FOR_IN
 557: IFFALSE 588
// if GetFuel ( i ) < 5 then
 559: LD_VAR 0 1
 563: PPUSH
 564: CALL_OW 261
 568: PUSH
 569: LD_INT 5
 571: LESS
 572: IFFALSE 586
// SetFuel ( i , 5 ) ;
 574: LD_VAR 0 1
 578: PPUSH
 579: LD_INT 5
 581: PPUSH
 582: CALL_OW 240
 586: GO 556
 588: POP
 589: POP
// end ; end_of_file
 590: PPOPN 2
 592: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 593: LD_INT 0
 595: PPUSH
 596: PPUSH
 597: PPUSH
 598: PPUSH
 599: PPUSH
// powell_side := 4 ;
 600: LD_ADDR_EXP 11
 604: PUSH
 605: LD_INT 4
 607: ST_TO_ADDR
// uc_side := powell_side ;
 608: LD_ADDR_OWVAR 20
 612: PUSH
 613: LD_EXP 11
 617: ST_TO_ADDR
// uc_nation := 1 ;
 618: LD_ADDR_OWVAR 21
 622: PUSH
 623: LD_INT 1
 625: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 626: LD_ADDR_EXP 10
 630: PUSH
 631: LD_STRING Powell
 633: PPUSH
 634: CALL_OW 25
 638: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 639: LD_EXP 10
 643: PPUSH
 644: LD_INT 1
 646: PPUSH
 647: LD_INT 7
 649: PPUSH
 650: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 654: LD_EXP 10
 658: PPUSH
 659: LD_INT 2
 661: PPUSH
 662: LD_INT 5
 664: PPUSH
 665: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 669: LD_EXP 10
 673: PPUSH
 674: LD_INT 3
 676: PPUSH
 677: LD_INT 6
 679: PPUSH
 680: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 684: LD_EXP 10
 688: PPUSH
 689: LD_INT 4
 691: PPUSH
 692: LD_INT 4
 694: PPUSH
 695: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 699: LD_EXP 10
 703: PPUSH
 704: LD_INT 4
 706: PPUSH
 707: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 711: LD_ADDR_VAR 0 3
 715: PUSH
 716: LD_INT 5
 718: PUSH
 719: LD_INT 178
 721: PUSH
 722: LD_INT 117
 724: PUSH
 725: LD_INT 2
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_INT 29
 736: PUSH
 737: LD_INT 167
 739: PUSH
 740: LD_INT 102
 742: PUSH
 743: LD_INT 0
 745: PUSH
 746: EMPTY
 747: LIST
 748: LIST
 749: LIST
 750: LIST
 751: PUSH
 752: LD_INT 6
 754: PUSH
 755: LD_INT 200
 757: PUSH
 758: LD_INT 111
 760: PUSH
 761: LD_INT 4
 763: PUSH
 764: LD_INT 10
 766: PUSH
 767: LD_INT 11
 769: PUSH
 770: EMPTY
 771: LIST
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 201
 783: PUSH
 784: LD_INT 140
 786: PUSH
 787: LD_INT 4
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: PUSH
 796: LD_INT 27
 798: PUSH
 799: LD_INT 206
 801: PUSH
 802: LD_INT 124
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: EMPTY
 809: LIST
 810: LIST
 811: LIST
 812: LIST
 813: PUSH
 814: LD_INT 27
 816: PUSH
 817: LD_INT 209
 819: PUSH
 820: LD_INT 128
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: PUSH
 832: LD_INT 27
 834: PUSH
 835: LD_INT 211
 837: PUSH
 838: LD_INT 132
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: EMPTY
 845: LIST
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_INT 30
 852: PUSH
 853: LD_INT 173
 855: PUSH
 856: LD_INT 83
 858: PUSH
 859: LD_INT 3
 861: PUSH
 862: EMPTY
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: PUSH
 868: LD_INT 6
 870: PUSH
 871: LD_INT 186
 873: PUSH
 874: LD_INT 103
 876: PUSH
 877: LD_INT 2
 879: PUSH
 880: LD_INT 12
 882: PUSH
 883: LD_INT 15
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: LIST
 892: LIST
 893: PUSH
 894: LD_INT 33
 896: PUSH
 897: LD_INT 173
 899: PUSH
 900: LD_INT 99
 902: PUSH
 903: LD_INT 2
 905: PUSH
 906: LD_INT 6
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_INT 32
 918: PUSH
 919: LD_INT 174
 921: PUSH
 922: LD_INT 102
 924: PUSH
 925: LD_INT 2
 927: PUSH
 928: LD_INT 6
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: LIST
 935: LIST
 936: LIST
 937: PUSH
 938: LD_INT 32
 940: PUSH
 941: LD_INT 178
 943: PUSH
 944: LD_INT 100
 946: PUSH
 947: LD_INT 2
 949: PUSH
 950: LD_INT 6
 952: PUSH
 953: EMPTY
 954: LIST
 955: LIST
 956: LIST
 957: LIST
 958: LIST
 959: PUSH
 960: LD_INT 33
 962: PUSH
 963: LD_INT 174
 965: PUSH
 966: LD_INT 108
 968: PUSH
 969: LD_INT 1
 971: PUSH
 972: LD_INT 7
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 33
 984: PUSH
 985: LD_INT 182
 987: PUSH
 988: LD_INT 122
 990: PUSH
 991: LD_INT 1
 993: PUSH
 994: LD_INT 7
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: LIST
1003: PUSH
1004: LD_INT 36
1006: PUSH
1007: LD_INT 194
1009: PUSH
1010: LD_INT 124
1012: PUSH
1013: LD_INT 5
1015: PUSH
1016: EMPTY
1017: LIST
1018: LIST
1019: LIST
1020: LIST
1021: PUSH
1022: LD_INT 33
1024: PUSH
1025: LD_INT 184
1027: PUSH
1028: LD_INT 141
1030: PUSH
1031: LD_INT 1
1033: PUSH
1034: LD_INT 6
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: PUSH
1044: LD_INT 33
1046: PUSH
1047: LD_INT 183
1049: PUSH
1050: LD_INT 131
1052: PUSH
1053: LD_INT 2
1055: PUSH
1056: LD_INT 11
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: LIST
1065: PUSH
1066: LD_INT 33
1068: PUSH
1069: LD_INT 194
1071: PUSH
1072: LD_INT 146
1074: PUSH
1075: LD_INT 4
1077: PUSH
1078: LD_INT 7
1080: PUSH
1081: EMPTY
1082: LIST
1083: LIST
1084: LIST
1085: LIST
1086: LIST
1087: PUSH
1088: LD_INT 33
1090: PUSH
1091: LD_INT 190
1093: PUSH
1094: LD_INT 142
1096: PUSH
1097: LD_INT 4
1099: PUSH
1100: LD_INT 7
1102: PUSH
1103: EMPTY
1104: LIST
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 28
1112: PUSH
1113: LD_INT 204
1115: PUSH
1116: LD_INT 133
1118: PUSH
1119: LD_INT 3
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 201
1133: PUSH
1134: LD_INT 133
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 28
1148: PUSH
1149: LD_INT 199
1151: PUSH
1152: LD_INT 119
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: LIST
1187: ST_TO_ADDR
// for i in list do
1188: LD_ADDR_VAR 0 2
1192: PUSH
1193: LD_VAR 0 3
1197: PUSH
1198: FOR_IN
1199: IFFALSE 1377
// begin uc_side := 4 ;
1201: LD_ADDR_OWVAR 20
1205: PUSH
1206: LD_INT 4
1208: ST_TO_ADDR
// uc_nation := 1 ;
1209: LD_ADDR_OWVAR 21
1213: PUSH
1214: LD_INT 1
1216: ST_TO_ADDR
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// bc_kind1 := - 1 ;
1231: LD_ADDR_OWVAR 44
1235: PUSH
1236: LD_INT 1
1238: NEG
1239: ST_TO_ADDR
// bc_kind2 := - 1 ;
1240: LD_ADDR_OWVAR 45
1244: PUSH
1245: LD_INT 1
1247: NEG
1248: ST_TO_ADDR
// if i [ 1 ] = b_lab then
1249: LD_VAR 0 2
1253: PUSH
1254: LD_INT 1
1256: ARRAY
1257: PUSH
1258: LD_INT 6
1260: EQUAL
1261: IFFALSE 1299
// begin bc_type := b_lab_full ;
1263: LD_ADDR_OWVAR 42
1267: PUSH
1268: LD_INT 8
1270: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1271: LD_ADDR_OWVAR 44
1275: PUSH
1276: LD_VAR 0 2
1280: PUSH
1281: LD_INT 5
1283: ARRAY
1284: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1285: LD_ADDR_OWVAR 45
1289: PUSH
1290: LD_VAR 0 2
1294: PUSH
1295: LD_INT 6
1297: ARRAY
1298: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1299: LD_ADDR_VAR 0 4
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 2
1311: ARRAY
1312: PPUSH
1313: LD_VAR 0 2
1317: PUSH
1318: LD_INT 3
1320: ARRAY
1321: PPUSH
1322: LD_VAR 0 2
1326: PUSH
1327: LD_INT 4
1329: ARRAY
1330: PPUSH
1331: CALL_OW 47
1335: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1336: LD_VAR 0 2
1340: PUSH
1341: LD_INT 1
1343: ARRAY
1344: PUSH
1345: LD_INT 33
1347: PUSH
1348: LD_INT 32
1350: PUSH
1351: EMPTY
1352: LIST
1353: LIST
1354: IN
1355: IFFALSE 1375
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1357: LD_VAR 0 4
1361: PPUSH
1362: LD_VAR 0 2
1366: PUSH
1367: LD_INT 5
1369: ARRAY
1370: PPUSH
1371: CALL_OW 431
// end ;
1375: GO 1198
1377: POP
1378: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1379: LD_ADDR_VAR 0 5
1383: PUSH
1384: LD_INT 4
1386: PPUSH
1387: LD_INT 1
1389: PPUSH
1390: LD_STRING 
1392: PPUSH
1393: LD_INT 8
1395: PUSH
1396: LD_INT 7
1398: PUSH
1399: LD_INT 6
1401: PUSH
1402: EMPTY
1403: LIST
1404: LIST
1405: LIST
1406: PUSH
1407: LD_OWVAR 67
1411: ARRAY
1412: PPUSH
1413: LD_INT 5500
1415: PUSH
1416: LD_INT 500
1418: PUSH
1419: LD_INT 0
1421: PUSH
1422: EMPTY
1423: LIST
1424: LIST
1425: LIST
1426: PPUSH
1427: LD_INT 6
1429: PUSH
1430: LD_INT 6
1432: PUSH
1433: LD_INT 6
1435: PUSH
1436: LD_INT 6
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 19314 0 6
1449: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1450: LD_ADDR_EXP 23
1454: PUSH
1455: LD_EXP 23
1459: PPUSH
1460: LD_INT 1
1462: PPUSH
1463: LD_VAR 0 5
1467: PUSH
1468: LD_INT 22
1470: PUSH
1471: LD_INT 4
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: PUSH
1478: LD_INT 21
1480: PUSH
1481: LD_INT 3
1483: PUSH
1484: EMPTY
1485: LIST
1486: LIST
1487: PUSH
1488: EMPTY
1489: LIST
1490: LIST
1491: PPUSH
1492: CALL_OW 69
1496: UNION
1497: PPUSH
1498: CALL_OW 1
1502: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1503: LD_ADDR_EXP 12
1507: PUSH
1508: EMPTY
1509: ST_TO_ADDR
// end ;
1510: LD_VAR 0 1
1514: RET
// export function InitMC_Powell ( ) ; begin
1515: LD_INT 0
1517: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1518: LD_INT 1
1520: PPUSH
1521: LD_INT 1
1523: PPUSH
1524: CALL 76052 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1528: LD_INT 1
1530: PPUSH
1531: LD_INT 6
1533: PPUSH
1534: CALL 75996 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1538: LD_INT 1
1540: PPUSH
1541: LD_INT 167
1543: PUSH
1544: LD_INT 102
1546: PUSH
1547: LD_INT 0
1549: PUSH
1550: EMPTY
1551: LIST
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 173
1557: PUSH
1558: LD_INT 83
1560: PUSH
1561: LD_INT 1
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: LIST
1568: PUSH
1569: LD_INT 171
1571: PUSH
1572: LD_INT 141
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 178
1585: PUSH
1586: LD_INT 148
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: EMPTY
1598: LIST
1599: LIST
1600: LIST
1601: LIST
1602: PPUSH
1603: CALL 75055 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1607: LD_INT 1
1609: PPUSH
1610: LD_INT 11
1612: PUSH
1613: LD_INT 6
1615: PUSH
1616: LD_INT 7
1618: PUSH
1619: EMPTY
1620: LIST
1621: LIST
1622: LIST
1623: PPUSH
1624: CALL 75884 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1628: LD_INT 1
1630: PPUSH
1631: LD_INT 5
1633: PPUSH
1634: CALL 75566 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1638: LD_INT 1
1640: PPUSH
1641: LD_INT 4
1643: PPUSH
1644: CALL 75297 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1648: LD_INT 1
1650: PPUSH
1651: LD_INT 4
1653: PPUSH
1654: CALL 74916 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1658: LD_INT 1
1660: PPUSH
1661: LD_INT 3
1663: PUSH
1664: LD_INT 1
1666: PUSH
1667: LD_INT 2
1669: PUSH
1670: LD_INT 5
1672: PUSH
1673: EMPTY
1674: LIST
1675: LIST
1676: LIST
1677: LIST
1678: PUSH
1679: LD_INT 4
1681: PUSH
1682: LD_INT 1
1684: PUSH
1685: LD_INT 2
1687: PUSH
1688: LD_INT 6
1690: PUSH
1691: EMPTY
1692: LIST
1693: LIST
1694: LIST
1695: LIST
1696: PUSH
1697: LD_INT 4
1699: PUSH
1700: LD_INT 1
1702: PUSH
1703: LD_INT 2
1705: PUSH
1706: LD_INT 7
1708: PUSH
1709: EMPTY
1710: LIST
1711: LIST
1712: LIST
1713: LIST
1714: PUSH
1715: LD_INT 4
1717: PUSH
1718: LD_INT 1
1720: PUSH
1721: LD_INT 2
1723: PUSH
1724: LD_INT 6
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: LIST
1731: LIST
1732: PUSH
1733: EMPTY
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PPUSH
1739: CALL 74731 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1743: LD_INT 1
1745: PPUSH
1746: LD_INT 201
1748: PPUSH
1749: LD_INT 140
1751: PPUSH
1752: LD_INT 4
1754: PPUSH
1755: LD_INT 19
1757: PUSH
1758: LD_INT 16
1760: PUSH
1761: LD_INT 17
1763: PUSH
1764: LD_INT 18
1766: PUSH
1767: LD_INT 22
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: LIST
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 75678 0 5
// end ;
1781: LD_VAR 0 1
1785: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1786: LD_INT 4
1788: PPUSH
1789: CALL_OW 302
1793: IFFALSE 2453
1795: GO 1797
1797: DISABLE
1798: LD_INT 0
1800: PPUSH
1801: PPUSH
1802: PPUSH
1803: PPUSH
1804: PPUSH
// begin enable ;
1805: ENABLE
// base := 1 ;
1806: LD_ADDR_VAR 0 2
1810: PUSH
1811: LD_INT 1
1813: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1814: LD_ADDR_VAR 0 3
1818: PUSH
1819: LD_INT 4
1821: PUSH
1822: LD_INT 1
1824: PUSH
1825: LD_INT 2
1827: PUSH
1828: LD_INT 6
1830: PUSH
1831: EMPTY
1832: LIST
1833: LIST
1834: LIST
1835: LIST
1836: PUSH
1837: LD_INT 4
1839: PUSH
1840: LD_INT 1
1842: PUSH
1843: LD_INT 2
1845: PUSH
1846: LD_INT 6
1848: PUSH
1849: EMPTY
1850: LIST
1851: LIST
1852: LIST
1853: LIST
1854: PUSH
1855: LD_INT 3
1857: PUSH
1858: LD_INT 1
1860: PUSH
1861: LD_INT 2
1863: PUSH
1864: LD_INT 7
1866: PUSH
1867: EMPTY
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: PUSH
1873: LD_INT 3
1875: PUSH
1876: LD_INT 1
1878: PUSH
1879: LD_INT 2
1881: PUSH
1882: LD_INT 7
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: PUSH
1891: EMPTY
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1897: LD_ADDR_VAR 0 5
1901: PUSH
1902: LD_VAR 0 5
1906: PUSH
1907: LD_OWVAR 1
1911: PUSH
1912: LD_INT 21000
1914: DIV
1915: PLUS
1916: ST_TO_ADDR
// if amount > 8 then
1917: LD_VAR 0 5
1921: PUSH
1922: LD_INT 8
1924: GREATER
1925: IFFALSE 1935
// amount := 8 ;
1927: LD_ADDR_VAR 0 5
1931: PUSH
1932: LD_INT 8
1934: ST_TO_ADDR
// for i = 1 to amount do
1935: LD_ADDR_VAR 0 1
1939: PUSH
1940: DOUBLE
1941: LD_INT 1
1943: DEC
1944: ST_TO_ADDR
1945: LD_VAR 0 5
1949: PUSH
1950: FOR_TO
1951: IFFALSE 2035
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: LD_VAR 0 3
1962: PPUSH
1963: LD_VAR 0 3
1967: PUSH
1968: LD_INT 1
1970: PLUS
1971: PPUSH
1972: LD_INT 3
1974: PUSH
1975: LD_INT 4
1977: PUSH
1978: EMPTY
1979: LIST
1980: LIST
1981: PUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 2
1987: PPUSH
1988: CALL_OW 12
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 2
1999: PUSH
2000: LD_INT 7
2002: PUSH
2003: LD_INT 5
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PPUSH
2028: CALL_OW 2
2032: ST_TO_ADDR
2033: GO 1950
2035: POP
2036: POP
// MC_InsertProduceList ( base , tmp ) ;
2037: LD_VAR 0 2
2041: PPUSH
2042: LD_VAR 0 3
2046: PPUSH
2047: CALL 74779 0 2
// repeat wait ( 0 0$1 ) ;
2051: LD_INT 35
2053: PPUSH
2054: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_INT 1
2065: PPUSH
2066: CALL 76197 0 2
2070: PUSH
2071: LD_VAR 0 5
2075: GREATEREQUAL
2076: IFFALSE 2051
// wait ( 0 0$30 ) ;
2078: LD_INT 1050
2080: PPUSH
2081: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2085: LD_ADDR_VAR 0 4
2089: PUSH
2090: LD_EXP 42
2094: PUSH
2095: LD_VAR 0 2
2099: ARRAY
2100: PUSH
2101: LD_EXP 42
2105: PUSH
2106: LD_VAR 0 2
2110: ARRAY
2111: PPUSH
2112: LD_INT 2
2114: PUSH
2115: LD_INT 34
2117: PUSH
2118: LD_INT 12
2120: PUSH
2121: EMPTY
2122: LIST
2123: LIST
2124: PUSH
2125: LD_INT 34
2127: PUSH
2128: LD_INT 13
2130: PUSH
2131: EMPTY
2132: LIST
2133: LIST
2134: PUSH
2135: LD_INT 34
2137: PUSH
2138: LD_INT 14
2140: PUSH
2141: EMPTY
2142: LIST
2143: LIST
2144: PUSH
2145: EMPTY
2146: LIST
2147: LIST
2148: LIST
2149: LIST
2150: PPUSH
2151: CALL_OW 72
2155: DIFF
2156: ST_TO_ADDR
// if not attackers then
2157: LD_VAR 0 4
2161: NOT
2162: IFFALSE 2166
// exit ;
2164: GO 2453
// DialogPowellsAttack ;
2166: CALL 9597 0 0
// powellAttackGroup := attackers ;
2170: LD_ADDR_EXP 12
2174: PUSH
2175: LD_VAR 0 4
2179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2180: LD_ADDR_EXP 42
2184: PUSH
2185: LD_EXP 42
2189: PPUSH
2190: LD_VAR 0 2
2194: PPUSH
2195: LD_EXP 42
2199: PUSH
2200: LD_VAR 0 2
2204: ARRAY
2205: PUSH
2206: LD_VAR 0 4
2210: DIFF
2211: PPUSH
2212: CALL_OW 1
2216: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2217: LD_EXP 9
2221: PUSH
2222: LD_INT 16
2224: PPUSH
2225: LD_INT 81
2227: PUSH
2228: LD_INT 4
2230: PUSH
2231: EMPTY
2232: LIST
2233: LIST
2234: PPUSH
2235: CALL_OW 70
2239: AND
2240: IFFALSE 2259
// ComAgressiveMove ( attackers , 135 , 21 ) else
2242: LD_VAR 0 4
2246: PPUSH
2247: LD_INT 135
2249: PPUSH
2250: LD_INT 21
2252: PPUSH
2253: CALL_OW 114
2257: GO 2274
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2259: LD_VAR 0 4
2263: PPUSH
2264: LD_INT 146
2266: PPUSH
2267: LD_INT 103
2269: PPUSH
2270: CALL_OW 114
// wait ( 0 0$5 ) ;
2274: LD_INT 175
2276: PPUSH
2277: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2281: LD_INT 35
2283: PPUSH
2284: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2288: LD_VAR 0 4
2292: PPUSH
2293: LD_INT 60
2295: PUSH
2296: EMPTY
2297: LIST
2298: PPUSH
2299: CALL_OW 72
2303: NOT
2304: IFFALSE 2281
// if FilterAllUnits ( [ f_side , 3 ] ) then
2306: LD_INT 22
2308: PUSH
2309: LD_INT 3
2311: PUSH
2312: EMPTY
2313: LIST
2314: LIST
2315: PPUSH
2316: CALL_OW 69
2320: IFFALSE 2339
// ComAgressiveMove ( attackers , 102 , 116 ) else
2322: LD_VAR 0 4
2326: PPUSH
2327: LD_INT 102
2329: PPUSH
2330: LD_INT 116
2332: PPUSH
2333: CALL_OW 114
2337: GO 2354
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2339: LD_VAR 0 4
2343: PPUSH
2344: LD_INT 66
2346: PPUSH
2347: LD_INT 41
2349: PPUSH
2350: CALL_OW 114
// wait ( 0 0$10 ) ;
2354: LD_INT 350
2356: PPUSH
2357: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2361: LD_INT 35
2363: PPUSH
2364: CALL_OW 67
// for i in attackers do
2368: LD_ADDR_VAR 0 1
2372: PUSH
2373: LD_VAR 0 4
2377: PUSH
2378: FOR_IN
2379: IFFALSE 2429
// if not HasTask ( i ) then
2381: LD_VAR 0 1
2385: PPUSH
2386: CALL_OW 314
2390: NOT
2391: IFFALSE 2427
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2393: LD_VAR 0 1
2397: PPUSH
2398: LD_INT 81
2400: PUSH
2401: LD_INT 4
2403: PUSH
2404: EMPTY
2405: LIST
2406: LIST
2407: PPUSH
2408: CALL_OW 69
2412: PPUSH
2413: LD_VAR 0 1
2417: PPUSH
2418: CALL_OW 74
2422: PPUSH
2423: CALL_OW 115
2427: GO 2378
2429: POP
2430: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2431: LD_VAR 0 4
2435: PPUSH
2436: LD_INT 50
2438: PUSH
2439: EMPTY
2440: LIST
2441: PPUSH
2442: CALL_OW 72
2446: NOT
2447: IFFALSE 2361
// DialogPowellsAttackFailed ;
2449: CALL 9862 0 0
// end ;
2453: PPOPN 5
2455: END
// every 0 0$2 do var vehicles , mechs , i ;
2456: GO 2458
2458: DISABLE
2459: LD_INT 0
2461: PPUSH
2462: PPUSH
2463: PPUSH
// begin enable ;
2464: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2465: LD_ADDR_VAR 0 1
2469: PUSH
2470: LD_INT 22
2472: PUSH
2473: LD_INT 1
2475: PUSH
2476: EMPTY
2477: LIST
2478: LIST
2479: PUSH
2480: LD_INT 21
2482: PUSH
2483: LD_INT 2
2485: PUSH
2486: EMPTY
2487: LIST
2488: LIST
2489: PUSH
2490: LD_INT 3
2492: PUSH
2493: LD_INT 24
2495: PUSH
2496: LD_INT 1000
2498: PUSH
2499: EMPTY
2500: LIST
2501: LIST
2502: PUSH
2503: EMPTY
2504: LIST
2505: LIST
2506: PUSH
2507: LD_INT 92
2509: PUSH
2510: LD_INT 191
2512: PUSH
2513: LD_INT 140
2515: PUSH
2516: LD_INT 10
2518: PUSH
2519: EMPTY
2520: LIST
2521: LIST
2522: LIST
2523: LIST
2524: PUSH
2525: EMPTY
2526: LIST
2527: LIST
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 69
2535: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2536: LD_ADDR_VAR 0 2
2540: PUSH
2541: LD_INT 22
2543: PUSH
2544: LD_INT 4
2546: PUSH
2547: EMPTY
2548: LIST
2549: LIST
2550: PUSH
2551: LD_INT 25
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: EMPTY
2558: LIST
2559: LIST
2560: PUSH
2561: EMPTY
2562: LIST
2563: LIST
2564: PPUSH
2565: CALL_OW 69
2569: ST_TO_ADDR
// if not mechs then
2570: LD_VAR 0 2
2574: NOT
2575: IFFALSE 2579
// exit ;
2577: GO 2753
// if mc_remote_driver [ 1 ] then
2579: LD_EXP 63
2583: PUSH
2584: LD_INT 1
2586: ARRAY
2587: IFFALSE 2609
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2589: LD_ADDR_VAR 0 2
2593: PUSH
2594: LD_VAR 0 2
2598: PUSH
2599: LD_EXP 63
2603: PUSH
2604: LD_INT 1
2606: ARRAY
2607: DIFF
2608: ST_TO_ADDR
// if not mechs then
2609: LD_VAR 0 2
2613: NOT
2614: IFFALSE 2618
// exit ;
2616: GO 2753
// if vehicles then
2618: LD_VAR 0 1
2622: IFFALSE 2710
// begin for i in mechs do
2624: LD_ADDR_VAR 0 3
2628: PUSH
2629: LD_VAR 0 2
2633: PUSH
2634: FOR_IN
2635: IFFALSE 2706
// begin if GetTag ( i ) <> 120 then
2637: LD_VAR 0 3
2641: PPUSH
2642: CALL_OW 110
2646: PUSH
2647: LD_INT 120
2649: NONEQUAL
2650: IFFALSE 2664
// SetTag ( i , 120 ) ;
2652: LD_VAR 0 3
2656: PPUSH
2657: LD_INT 120
2659: PPUSH
2660: CALL_OW 109
// if IsInUnit ( i ) then
2664: LD_VAR 0 3
2668: PPUSH
2669: CALL_OW 310
2673: IFFALSE 2686
// ComExitBuilding ( i ) else
2675: LD_VAR 0 3
2679: PPUSH
2680: CALL_OW 122
2684: GO 2704
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2686: LD_VAR 0 3
2690: PPUSH
2691: LD_VAR 0 1
2695: PUSH
2696: LD_INT 1
2698: ARRAY
2699: PPUSH
2700: CALL_OW 129
// end ;
2704: GO 2634
2706: POP
2707: POP
// end else
2708: GO 2753
// if FilterByTag ( mechs , 120 ) then
2710: LD_VAR 0 2
2714: PPUSH
2715: LD_INT 120
2717: PPUSH
2718: CALL 45259 0 2
2722: IFFALSE 2753
// begin for i in mechs do
2724: LD_ADDR_VAR 0 3
2728: PUSH
2729: LD_VAR 0 2
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2751
// begin SetTag ( i , 0 ) ;
2737: LD_VAR 0 3
2741: PPUSH
2742: LD_INT 0
2744: PPUSH
2745: CALL_OW 109
// end ;
2749: GO 2734
2751: POP
2752: POP
// end ; end ;
2753: PPOPN 3
2755: END
// every 0 0$2 do var people , sci , i ;
2756: GO 2758
2758: DISABLE
2759: LD_INT 0
2761: PPUSH
2762: PPUSH
2763: PPUSH
// begin enable ;
2764: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2765: LD_ADDR_VAR 0 1
2769: PUSH
2770: LD_INT 22
2772: PUSH
2773: LD_INT 1
2775: PUSH
2776: EMPTY
2777: LIST
2778: LIST
2779: PUSH
2780: LD_INT 21
2782: PUSH
2783: LD_INT 1
2785: PUSH
2786: EMPTY
2787: LIST
2788: LIST
2789: PUSH
2790: LD_INT 3
2792: PUSH
2793: LD_INT 24
2795: PUSH
2796: LD_INT 1000
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: PUSH
2803: EMPTY
2804: LIST
2805: LIST
2806: PUSH
2807: LD_INT 92
2809: PUSH
2810: LD_INT 188
2812: PUSH
2813: LD_INT 112
2815: PUSH
2816: LD_INT 10
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PUSH
2825: EMPTY
2826: LIST
2827: LIST
2828: LIST
2829: LIST
2830: PPUSH
2831: CALL_OW 69
2835: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2836: LD_ADDR_VAR 0 2
2840: PUSH
2841: LD_INT 22
2843: PUSH
2844: LD_INT 4
2846: PUSH
2847: EMPTY
2848: LIST
2849: LIST
2850: PUSH
2851: LD_INT 25
2853: PUSH
2854: LD_INT 4
2856: PUSH
2857: EMPTY
2858: LIST
2859: LIST
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 69
2869: ST_TO_ADDR
// if not sci then
2870: LD_VAR 0 2
2874: NOT
2875: IFFALSE 2879
// exit ;
2877: GO 3014
// if people then
2879: LD_VAR 0 1
2883: IFFALSE 2971
// begin for i in sci do
2885: LD_ADDR_VAR 0 3
2889: PUSH
2890: LD_VAR 0 2
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2967
// begin if GetTag ( i ) <> 102 then
2898: LD_VAR 0 3
2902: PPUSH
2903: CALL_OW 110
2907: PUSH
2908: LD_INT 102
2910: NONEQUAL
2911: IFFALSE 2925
// SetTag ( i , 102 ) ;
2913: LD_VAR 0 3
2917: PPUSH
2918: LD_INT 102
2920: PPUSH
2921: CALL_OW 109
// if IsInUnit ( i ) then
2925: LD_VAR 0 3
2929: PPUSH
2930: CALL_OW 310
2934: IFFALSE 2947
// ComExitBuilding ( i ) else
2936: LD_VAR 0 3
2940: PPUSH
2941: CALL_OW 122
2945: GO 2965
// ComHeal ( i , people [ 1 ] ) ;
2947: LD_VAR 0 3
2951: PPUSH
2952: LD_VAR 0 1
2956: PUSH
2957: LD_INT 1
2959: ARRAY
2960: PPUSH
2961: CALL_OW 128
// end ;
2965: GO 2895
2967: POP
2968: POP
// end else
2969: GO 3014
// if FilterByTag ( sci , 102 ) then
2971: LD_VAR 0 2
2975: PPUSH
2976: LD_INT 102
2978: PPUSH
2979: CALL 45259 0 2
2983: IFFALSE 3014
// begin for i in sci do
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 2
2994: PUSH
2995: FOR_IN
2996: IFFALSE 3012
// begin SetTag ( i , 0 ) ;
2998: LD_VAR 0 3
3002: PPUSH
3003: LD_INT 0
3005: PPUSH
3006: CALL_OW 109
// end ;
3010: GO 2995
3012: POP
3013: POP
// end ; end ;
3014: PPOPN 3
3016: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3017: LD_INT 22
3019: PUSH
3020: LD_INT 4
3022: PUSH
3023: EMPTY
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 33
3029: PUSH
3030: LD_INT 2
3032: PUSH
3033: EMPTY
3034: LIST
3035: LIST
3036: PUSH
3037: LD_INT 50
3039: PUSH
3040: EMPTY
3041: LIST
3042: PUSH
3043: LD_INT 3
3045: PUSH
3046: LD_INT 61
3048: PUSH
3049: EMPTY
3050: LIST
3051: PUSH
3052: EMPTY
3053: LIST
3054: LIST
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PPUSH
3062: CALL_OW 69
3066: IFFALSE 3157
3068: GO 3070
3070: DISABLE
3071: LD_INT 0
3073: PPUSH
3074: PPUSH
// begin enable ;
3075: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3076: LD_ADDR_VAR 0 2
3080: PUSH
3081: LD_INT 22
3083: PUSH
3084: LD_INT 4
3086: PUSH
3087: EMPTY
3088: LIST
3089: LIST
3090: PUSH
3091: LD_INT 33
3093: PUSH
3094: LD_INT 2
3096: PUSH
3097: EMPTY
3098: LIST
3099: LIST
3100: PUSH
3101: LD_INT 50
3103: PUSH
3104: EMPTY
3105: LIST
3106: PUSH
3107: LD_INT 3
3109: PUSH
3110: LD_INT 61
3112: PUSH
3113: EMPTY
3114: LIST
3115: PUSH
3116: EMPTY
3117: LIST
3118: LIST
3119: PUSH
3120: EMPTY
3121: LIST
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: CALL_OW 69
3130: ST_TO_ADDR
// for i in tmp do
3131: LD_ADDR_VAR 0 1
3135: PUSH
3136: LD_VAR 0 2
3140: PUSH
3141: FOR_IN
3142: IFFALSE 3155
// Connect ( i ) ;
3144: LD_VAR 0 1
3148: PPUSH
3149: CALL 18961 0 1
3153: GO 3141
3155: POP
3156: POP
// end ; end_of_file
3157: PPOPN 2
3159: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3160: LD_INT 0
3162: PPUSH
3163: PPUSH
3164: PPUSH
3165: PPUSH
3166: PPUSH
3167: PPUSH
// gensher_side := 2 ;
3168: LD_ADDR_EXP 14
3172: PUSH
3173: LD_INT 2
3175: ST_TO_ADDR
// uc_side := gensher_side ;
3176: LD_ADDR_OWVAR 20
3180: PUSH
3181: LD_EXP 14
3185: ST_TO_ADDR
// uc_nation := 2 ;
3186: LD_ADDR_OWVAR 21
3190: PUSH
3191: LD_INT 2
3193: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3194: LD_ADDR_VAR 0 6
3198: PUSH
3199: LD_INT 5
3201: PUSH
3202: LD_INT 42
3204: PUSH
3205: LD_INT 29
3207: PUSH
3208: LD_INT 5
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 5
3219: PUSH
3220: LD_INT 36
3222: PUSH
3223: LD_INT 40
3225: PUSH
3226: LD_INT 5
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 13
3240: PUSH
3241: LD_INT 18
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: LD_INT 10
3249: PUSH
3250: LD_INT 15
3252: PUSH
3253: EMPTY
3254: LIST
3255: LIST
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 27
3263: PUSH
3264: LD_INT 17
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 0
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PUSH
3279: LD_INT 29
3281: PUSH
3282: LD_INT 56
3284: PUSH
3285: LD_INT 23
3287: PUSH
3288: LD_INT 0
3290: PUSH
3291: EMPTY
3292: LIST
3293: LIST
3294: LIST
3295: LIST
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 11
3302: PUSH
3303: LD_INT 7
3305: PUSH
3306: LD_INT 2
3308: PUSH
3309: EMPTY
3310: LIST
3311: LIST
3312: LIST
3313: LIST
3314: PUSH
3315: LD_INT 27
3317: PUSH
3318: LD_INT 20
3320: PUSH
3321: LD_INT 3
3323: PUSH
3324: LD_INT 0
3326: PUSH
3327: EMPTY
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: PUSH
3333: LD_INT 27
3335: PUSH
3336: LD_INT 23
3338: PUSH
3339: LD_INT 3
3341: PUSH
3342: LD_INT 0
3344: PUSH
3345: EMPTY
3346: LIST
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 27
3353: PUSH
3354: LD_INT 26
3356: PUSH
3357: LD_INT 3
3359: PUSH
3360: LD_INT 0
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PUSH
3369: LD_INT 6
3371: PUSH
3372: LD_INT 17
3374: PUSH
3375: LD_INT 27
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 13
3383: PUSH
3384: LD_INT 11
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: PUSH
3395: LD_INT 32
3397: PUSH
3398: LD_INT 27
3400: PUSH
3401: LD_INT 44
3403: PUSH
3404: LD_INT 5
3406: PUSH
3407: LD_INT 27
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: PUSH
3417: LD_INT 32
3419: PUSH
3420: LD_INT 41
3422: PUSH
3423: LD_INT 41
3425: PUSH
3426: LD_INT 5
3428: PUSH
3429: LD_INT 27
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: LIST
3438: PUSH
3439: LD_INT 32
3441: PUSH
3442: LD_INT 45
3444: PUSH
3445: LD_INT 24
3447: PUSH
3448: LD_INT 5
3450: PUSH
3451: LD_INT 28
3453: PUSH
3454: EMPTY
3455: LIST
3456: LIST
3457: LIST
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 32
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: LD_INT 19
3469: PUSH
3470: LD_INT 5
3472: PUSH
3473: LD_INT 28
3475: PUSH
3476: EMPTY
3477: LIST
3478: LIST
3479: LIST
3480: LIST
3481: LIST
3482: PUSH
3483: LD_INT 32
3485: PUSH
3486: LD_INT 41
3488: PUSH
3489: LD_INT 3
3491: PUSH
3492: LD_INT 4
3494: PUSH
3495: LD_INT 28
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 5
3507: PUSH
3508: LD_INT 44
3510: PUSH
3511: LD_INT 9
3513: PUSH
3514: LD_INT 4
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 30
3525: PUSH
3526: LD_INT 52
3528: PUSH
3529: LD_INT 40
3531: PUSH
3532: LD_INT 3
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: EMPTY
3542: LIST
3543: LIST
3544: LIST
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: LIST
3553: LIST
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: LIST
3559: ST_TO_ADDR
// for i in list do
3560: LD_ADDR_VAR 0 2
3564: PUSH
3565: LD_VAR 0 6
3569: PUSH
3570: FOR_IN
3571: IFFALSE 3749
// begin uc_side := 2 ;
3573: LD_ADDR_OWVAR 20
3577: PUSH
3578: LD_INT 2
3580: ST_TO_ADDR
// uc_nation := 2 ;
3581: LD_ADDR_OWVAR 21
3585: PUSH
3586: LD_INT 2
3588: ST_TO_ADDR
// bc_type := i [ 1 ] ;
3589: LD_ADDR_OWVAR 42
3593: PUSH
3594: LD_VAR 0 2
3598: PUSH
3599: LD_INT 1
3601: ARRAY
3602: ST_TO_ADDR
// bc_kind1 := - 1 ;
3603: LD_ADDR_OWVAR 44
3607: PUSH
3608: LD_INT 1
3610: NEG
3611: ST_TO_ADDR
// bc_kind2 := - 1 ;
3612: LD_ADDR_OWVAR 45
3616: PUSH
3617: LD_INT 1
3619: NEG
3620: ST_TO_ADDR
// if i [ 1 ] = b_lab then
3621: LD_VAR 0 2
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: PUSH
3630: LD_INT 6
3632: EQUAL
3633: IFFALSE 3671
// begin bc_type := b_lab_full ;
3635: LD_ADDR_OWVAR 42
3639: PUSH
3640: LD_INT 8
3642: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3643: LD_ADDR_OWVAR 44
3647: PUSH
3648: LD_VAR 0 2
3652: PUSH
3653: LD_INT 5
3655: ARRAY
3656: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3657: LD_ADDR_OWVAR 45
3661: PUSH
3662: LD_VAR 0 2
3666: PUSH
3667: LD_INT 6
3669: ARRAY
3670: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3671: LD_ADDR_VAR 0 3
3675: PUSH
3676: LD_VAR 0 2
3680: PUSH
3681: LD_INT 2
3683: ARRAY
3684: PPUSH
3685: LD_VAR 0 2
3689: PUSH
3690: LD_INT 3
3692: ARRAY
3693: PPUSH
3694: LD_VAR 0 2
3698: PUSH
3699: LD_INT 4
3701: ARRAY
3702: PPUSH
3703: CALL_OW 47
3707: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 1
3715: ARRAY
3716: PUSH
3717: LD_INT 33
3719: PUSH
3720: LD_INT 32
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: IN
3727: IFFALSE 3747
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3729: LD_VAR 0 3
3733: PPUSH
3734: LD_VAR 0 2
3738: PUSH
3739: LD_INT 5
3741: ARRAY
3742: PPUSH
3743: CALL_OW 431
// end ;
3747: GO 3570
3749: POP
3750: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3751: LD_ADDR_VAR 0 4
3755: PUSH
3756: LD_INT 7
3758: PPUSH
3759: LD_INT 2
3761: PPUSH
3762: LD_STRING 
3764: PPUSH
3765: LD_INT 8
3767: PUSH
3768: LD_INT 7
3770: PUSH
3771: LD_INT 6
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: LD_INT 11500
3787: PUSH
3788: LD_INT 1100
3790: PUSH
3791: LD_INT 60
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: LIST
3798: PPUSH
3799: LD_INT 6
3801: PUSH
3802: LD_INT 6
3804: PUSH
3805: LD_INT 6
3807: PUSH
3808: LD_INT 6
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: LIST
3815: LIST
3816: PPUSH
3817: CALL 19314 0 6
3821: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3822: LD_ADDR_EXP 23
3826: PUSH
3827: LD_EXP 23
3831: PPUSH
3832: LD_INT 2
3834: PPUSH
3835: LD_VAR 0 4
3839: PUSH
3840: LD_INT 22
3842: PUSH
3843: LD_INT 2
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: PUSH
3850: LD_INT 21
3852: PUSH
3853: LD_INT 3
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: PPUSH
3864: CALL_OW 69
3868: UNION
3869: PPUSH
3870: CALL_OW 1
3874: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3875: LD_ADDR_VAR 0 4
3879: PUSH
3880: LD_INT 22
3882: PUSH
3883: LD_INT 2
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_INT 30
3892: PUSH
3893: LD_INT 31
3895: PUSH
3896: EMPTY
3897: LIST
3898: LIST
3899: PUSH
3900: EMPTY
3901: LIST
3902: LIST
3903: PPUSH
3904: CALL_OW 69
3908: ST_TO_ADDR
// for i in tmp do
3909: LD_ADDR_VAR 0 2
3913: PUSH
3914: LD_VAR 0 4
3918: PUSH
3919: FOR_IN
3920: IFFALSE 3990
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3922: LD_INT 0
3924: PPUSH
3925: LD_INT 1
3927: PPUSH
3928: LD_INT 4
3930: PUSH
3931: LD_INT 3
3933: PUSH
3934: LD_INT 3
3936: PUSH
3937: EMPTY
3938: LIST
3939: LIST
3940: LIST
3941: PUSH
3942: LD_OWVAR 67
3946: ARRAY
3947: PPUSH
3948: CALL_OW 380
// un := CreateHuman ;
3952: LD_ADDR_VAR 0 5
3956: PUSH
3957: CALL_OW 44
3961: ST_TO_ADDR
// SetDir ( un , 1 ) ;
3962: LD_VAR 0 5
3966: PPUSH
3967: LD_INT 1
3969: PPUSH
3970: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3974: LD_VAR 0 5
3978: PPUSH
3979: LD_VAR 0 2
3983: PPUSH
3984: CALL_OW 52
// end ;
3988: GO 3919
3990: POP
3991: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
3992: LD_ADDR_VAR 0 4
3996: PUSH
3997: LD_INT 15
3999: PPUSH
4000: LD_INT 0
4002: PPUSH
4003: CALL_OW 517
4007: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4008: LD_ADDR_VAR 0 2
4012: PUSH
4013: DOUBLE
4014: LD_INT 1
4016: DEC
4017: ST_TO_ADDR
4018: LD_VAR 0 4
4022: PUSH
4023: LD_INT 1
4025: ARRAY
4026: PUSH
4027: FOR_TO
4028: IFFALSE 4130
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4030: LD_VAR 0 4
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PUSH
4039: LD_VAR 0 2
4043: ARRAY
4044: PPUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PUSH
4054: LD_VAR 0 2
4058: ARRAY
4059: PPUSH
4060: LD_INT 2
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4070: LD_ADDR_EXP 3
4074: PUSH
4075: LD_EXP 3
4079: PPUSH
4080: LD_EXP 3
4084: PUSH
4085: LD_INT 1
4087: PLUS
4088: PPUSH
4089: LD_VAR 0 4
4093: PUSH
4094: LD_INT 1
4096: ARRAY
4097: PUSH
4098: LD_VAR 0 2
4102: ARRAY
4103: PUSH
4104: LD_VAR 0 4
4108: PUSH
4109: LD_INT 2
4111: ARRAY
4112: PUSH
4113: LD_VAR 0 2
4117: ARRAY
4118: PUSH
4119: EMPTY
4120: LIST
4121: LIST
4122: PPUSH
4123: CALL_OW 2
4127: ST_TO_ADDR
// end ;
4128: GO 4027
4130: POP
4131: POP
// if Difficulty > 1 then
4132: LD_OWVAR 67
4136: PUSH
4137: LD_INT 1
4139: GREATER
4140: IFFALSE 4282
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4142: LD_ADDR_VAR 0 4
4146: PUSH
4147: LD_INT 19
4149: PPUSH
4150: LD_INT 0
4152: PPUSH
4153: CALL_OW 517
4157: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4158: LD_ADDR_VAR 0 2
4162: PUSH
4163: DOUBLE
4164: LD_INT 1
4166: DEC
4167: ST_TO_ADDR
4168: LD_VAR 0 4
4172: PUSH
4173: LD_INT 1
4175: ARRAY
4176: PUSH
4177: FOR_TO
4178: IFFALSE 4280
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4180: LD_VAR 0 4
4184: PUSH
4185: LD_INT 1
4187: ARRAY
4188: PUSH
4189: LD_VAR 0 2
4193: ARRAY
4194: PPUSH
4195: LD_VAR 0 4
4199: PUSH
4200: LD_INT 2
4202: ARRAY
4203: PUSH
4204: LD_VAR 0 2
4208: ARRAY
4209: PPUSH
4210: LD_INT 2
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4220: LD_ADDR_EXP 3
4224: PUSH
4225: LD_EXP 3
4229: PPUSH
4230: LD_EXP 3
4234: PUSH
4235: LD_INT 1
4237: PLUS
4238: PPUSH
4239: LD_VAR 0 4
4243: PUSH
4244: LD_INT 1
4246: ARRAY
4247: PUSH
4248: LD_VAR 0 2
4252: ARRAY
4253: PUSH
4254: LD_VAR 0 4
4258: PUSH
4259: LD_INT 2
4261: ARRAY
4262: PUSH
4263: LD_VAR 0 2
4267: ARRAY
4268: PUSH
4269: EMPTY
4270: LIST
4271: LIST
4272: PPUSH
4273: CALL_OW 2
4277: ST_TO_ADDR
// end ;
4278: GO 4177
4280: POP
4281: POP
// end ; gensherAttackGroup := [ ] ;
4282: LD_ADDR_EXP 15
4286: PUSH
4287: EMPTY
4288: ST_TO_ADDR
// end ;
4289: LD_VAR 0 1
4293: RET
// export function InitMC_Gensher ( ) ; begin
4294: LD_INT 0
4296: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4297: LD_INT 2
4299: PPUSH
4300: LD_INT 2
4302: PPUSH
4303: CALL 76052 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4307: LD_INT 2
4309: PPUSH
4310: LD_INT 9
4312: PPUSH
4313: CALL 75996 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4317: LD_INT 2
4319: PPUSH
4320: LD_INT 56
4322: PUSH
4323: LD_INT 23
4325: PUSH
4326: LD_INT 0
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: PUSH
4334: LD_INT 52
4336: PUSH
4337: LD_INT 40
4339: PUSH
4340: LD_INT 1
4342: PUSH
4343: EMPTY
4344: LIST
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PPUSH
4352: CALL 75055 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4356: LD_INT 2
4358: PPUSH
4359: LD_INT 27
4361: PUSH
4362: LD_INT 28
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PPUSH
4369: CALL 75884 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4373: LD_INT 2
4375: PPUSH
4376: LD_INT 8
4378: PPUSH
4379: CALL 75566 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4383: LD_INT 2
4385: PPUSH
4386: LD_INT 7
4388: PPUSH
4389: CALL 75297 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4393: LD_INT 2
4395: PPUSH
4396: LD_INT 4
4398: PPUSH
4399: CALL 74916 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4403: LD_INT 2
4405: PPUSH
4406: LD_INT 13
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 1
4414: PUSH
4415: LD_INT 31
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: LD_INT 13
4426: PUSH
4427: LD_INT 2
4429: PUSH
4430: LD_INT 1
4432: PUSH
4433: LD_INT 31
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 14
4444: PUSH
4445: LD_INT 1
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: LD_INT 27
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 14
4462: PUSH
4463: LD_INT 1
4465: PUSH
4466: LD_INT 2
4468: PUSH
4469: LD_INT 27
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 14
4480: PUSH
4481: LD_INT 1
4483: PUSH
4484: LD_INT 2
4486: PUSH
4487: LD_INT 28
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 14
4498: PUSH
4499: LD_INT 1
4501: PUSH
4502: LD_INT 2
4504: PUSH
4505: LD_INT 26
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: PUSH
4514: EMPTY
4515: LIST
4516: LIST
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PPUSH
4522: CALL 74731 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4526: LD_INT 2
4528: PPUSH
4529: LD_INT 11
4531: PPUSH
4532: LD_INT 7
4534: PPUSH
4535: LD_INT 2
4537: PPUSH
4538: LD_INT 23
4540: PUSH
4541: LD_INT 16
4543: PUSH
4544: LD_INT 17
4546: PUSH
4547: LD_INT 18
4549: PUSH
4550: LD_INT 22
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: LIST
4557: LIST
4558: LIST
4559: PPUSH
4560: CALL 75678 0 5
// end ;
4564: LD_VAR 0 1
4568: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4569: LD_EXP 3
4573: PUSH
4574: LD_INT 15
4576: PPUSH
4577: LD_INT 81
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PPUSH
4587: CALL_OW 70
4591: AND
4592: IFFALSE 4805
4594: GO 4596
4596: DISABLE
4597: LD_INT 0
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
// begin enable ;
4604: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4605: LD_ADDR_VAR 0 3
4609: PUSH
4610: LD_INT 15
4612: PPUSH
4613: LD_INT 81
4615: PUSH
4616: LD_INT 2
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 70
4627: ST_TO_ADDR
// if not tmp then
4628: LD_VAR 0 3
4632: NOT
4633: IFFALSE 4637
// exit ;
4635: GO 4805
// for i in tmp do
4637: LD_ADDR_VAR 0 1
4641: PUSH
4642: LD_VAR 0 3
4646: PUSH
4647: FOR_IN
4648: IFFALSE 4803
// begin x := GetX ( i ) ;
4650: LD_ADDR_VAR 0 4
4654: PUSH
4655: LD_VAR 0 1
4659: PPUSH
4660: CALL_OW 250
4664: ST_TO_ADDR
// y := GetY ( i ) ;
4665: LD_ADDR_VAR 0 5
4669: PUSH
4670: LD_VAR 0 1
4674: PPUSH
4675: CALL_OW 251
4679: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4680: LD_VAR 0 4
4684: PPUSH
4685: LD_VAR 0 5
4689: PPUSH
4690: CALL_OW 458
4694: IFFALSE 4801
// begin LaunchMineAtPos ( x , y , 2 ) ;
4696: LD_VAR 0 4
4700: PPUSH
4701: LD_VAR 0 5
4705: PPUSH
4706: LD_INT 2
4708: PPUSH
4709: CALL_OW 456
// for j = 1 to staticMines do
4713: LD_ADDR_VAR 0 2
4717: PUSH
4718: DOUBLE
4719: LD_INT 1
4721: DEC
4722: ST_TO_ADDR
4723: LD_EXP 3
4727: PUSH
4728: FOR_TO
4729: IFFALSE 4799
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4731: LD_EXP 3
4735: PUSH
4736: LD_VAR 0 2
4740: ARRAY
4741: PUSH
4742: LD_INT 1
4744: ARRAY
4745: PUSH
4746: LD_VAR 0 4
4750: EQUAL
4751: PUSH
4752: LD_EXP 3
4756: PUSH
4757: LD_VAR 0 2
4761: ARRAY
4762: PUSH
4763: LD_INT 2
4765: ARRAY
4766: PUSH
4767: LD_VAR 0 5
4771: EQUAL
4772: AND
4773: IFFALSE 4797
// begin staticMines := Delete ( staticMines , j ) ;
4775: LD_ADDR_EXP 3
4779: PUSH
4780: LD_EXP 3
4784: PPUSH
4785: LD_VAR 0 2
4789: PPUSH
4790: CALL_OW 3
4794: ST_TO_ADDR
// break ;
4795: GO 4799
// end ;
4797: GO 4728
4799: POP
4800: POP
// end ; end ;
4801: GO 4647
4803: POP
4804: POP
// end ;
4805: PPOPN 5
4807: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4808: LD_INT 7
4810: PPUSH
4811: CALL_OW 302
4815: PUSH
4816: LD_EXP 4
4820: NOT
4821: AND
4822: IFFALSE 5426
4824: GO 4826
4826: DISABLE
4827: LD_INT 0
4829: PPUSH
4830: PPUSH
4831: PPUSH
4832: PPUSH
4833: PPUSH
// begin enable ;
4834: ENABLE
// base := 2 ;
4835: LD_ADDR_VAR 0 2
4839: PUSH
4840: LD_INT 2
4842: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4843: LD_ADDR_VAR 0 3
4847: PUSH
4848: LD_INT 14
4850: PUSH
4851: LD_INT 1
4853: PUSH
4854: LD_INT 2
4856: PUSH
4857: LD_INT 27
4859: PUSH
4860: EMPTY
4861: LIST
4862: LIST
4863: LIST
4864: LIST
4865: PUSH
4866: LD_INT 14
4868: PUSH
4869: LD_INT 1
4871: PUSH
4872: LD_INT 2
4874: PUSH
4875: LD_INT 27
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 14
4886: PUSH
4887: LD_INT 1
4889: PUSH
4890: LD_INT 2
4892: PUSH
4893: LD_EXP 72
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 14
4906: PUSH
4907: LD_INT 1
4909: PUSH
4910: LD_INT 2
4912: PUSH
4913: LD_INT 26
4915: PUSH
4916: EMPTY
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: PUSH
4922: EMPTY
4923: LIST
4924: LIST
4925: LIST
4926: LIST
4927: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4928: LD_ADDR_VAR 0 5
4932: PUSH
4933: LD_VAR 0 5
4937: PUSH
4938: LD_OWVAR 1
4942: PUSH
4943: LD_INT 21000
4945: DIV
4946: PLUS
4947: ST_TO_ADDR
// if amount > 8 then
4948: LD_VAR 0 5
4952: PUSH
4953: LD_INT 8
4955: GREATER
4956: IFFALSE 4966
// amount := 8 ;
4958: LD_ADDR_VAR 0 5
4962: PUSH
4963: LD_INT 8
4965: ST_TO_ADDR
// for i = 1 to amount do
4966: LD_ADDR_VAR 0 1
4970: PUSH
4971: DOUBLE
4972: LD_INT 1
4974: DEC
4975: ST_TO_ADDR
4976: LD_VAR 0 5
4980: PUSH
4981: FOR_TO
4982: IFFALSE 5070
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
4984: LD_ADDR_VAR 0 3
4988: PUSH
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_VAR 0 3
4998: PUSH
4999: LD_INT 1
5001: PLUS
5002: PPUSH
5003: LD_INT 14
5005: PUSH
5006: LD_INT 13
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 1
5015: PPUSH
5016: LD_INT 2
5018: PPUSH
5019: CALL_OW 12
5023: ARRAY
5024: PUSH
5025: LD_INT 1
5027: PUSH
5028: LD_INT 2
5030: PUSH
5031: LD_INT 28
5033: PUSH
5034: LD_INT 25
5036: PUSH
5037: LD_INT 27
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_INT 1
5047: PPUSH
5048: LD_INT 3
5050: PPUSH
5051: CALL_OW 12
5055: ARRAY
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: LIST
5061: LIST
5062: PPUSH
5063: CALL_OW 2
5067: ST_TO_ADDR
5068: GO 4981
5070: POP
5071: POP
// MC_InsertProduceList ( base , tmp ) ;
5072: LD_VAR 0 2
5076: PPUSH
5077: LD_VAR 0 3
5081: PPUSH
5082: CALL 74779 0 2
// repeat wait ( 0 0$1 ) ;
5086: LD_INT 35
5088: PPUSH
5089: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5093: LD_VAR 0 2
5097: PPUSH
5098: LD_INT 1
5100: PPUSH
5101: CALL 76197 0 2
5105: PUSH
5106: LD_VAR 0 5
5110: GREATEREQUAL
5111: IFFALSE 5086
// wait ( 0 0$30 ) ;
5113: LD_INT 1050
5115: PPUSH
5116: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5120: LD_ADDR_VAR 0 4
5124: PUSH
5125: LD_EXP 42
5129: PUSH
5130: LD_VAR 0 2
5134: ARRAY
5135: PUSH
5136: LD_EXP 42
5140: PUSH
5141: LD_VAR 0 2
5145: ARRAY
5146: PPUSH
5147: LD_INT 2
5149: PUSH
5150: LD_INT 34
5152: PUSH
5153: LD_INT 31
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: PUSH
5160: LD_INT 34
5162: PUSH
5163: LD_INT 32
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 34
5172: PUSH
5173: LD_EXP 73
5177: PUSH
5178: EMPTY
5179: LIST
5180: LIST
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: LIST
5186: LIST
5187: PPUSH
5188: CALL_OW 72
5192: DIFF
5193: ST_TO_ADDR
// if not attackers then
5194: LD_VAR 0 4
5198: NOT
5199: IFFALSE 5203
// exit ;
5201: GO 5426
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5203: LD_ADDR_EXP 42
5207: PUSH
5208: LD_EXP 42
5212: PPUSH
5213: LD_VAR 0 2
5217: PPUSH
5218: LD_EXP 42
5222: PUSH
5223: LD_VAR 0 2
5227: ARRAY
5228: PUSH
5229: LD_VAR 0 4
5233: DIFF
5234: PPUSH
5235: CALL_OW 1
5239: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5240: LD_VAR 0 4
5244: PPUSH
5245: LD_INT 107
5247: PPUSH
5248: LD_INT 74
5250: PPUSH
5251: CALL_OW 114
// wait ( 0 0$5 ) ;
5255: LD_INT 175
5257: PPUSH
5258: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5262: LD_INT 35
5264: PPUSH
5265: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5269: LD_VAR 0 4
5273: PPUSH
5274: LD_INT 60
5276: PUSH
5277: EMPTY
5278: LIST
5279: PPUSH
5280: CALL_OW 72
5284: NOT
5285: IFFALSE 5262
// if rand ( 0 , 1 ) then
5287: LD_INT 0
5289: PPUSH
5290: LD_INT 1
5292: PPUSH
5293: CALL_OW 12
5297: IFFALSE 5316
// ComAgressiveMove ( attackers , 155 , 108 ) else
5299: LD_VAR 0 4
5303: PPUSH
5304: LD_INT 155
5306: PPUSH
5307: LD_INT 108
5309: PPUSH
5310: CALL_OW 114
5314: GO 5331
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5316: LD_VAR 0 4
5320: PPUSH
5321: LD_INT 149
5323: PPUSH
5324: LD_INT 55
5326: PPUSH
5327: CALL_OW 114
// wait ( 0 0$10 ) ;
5331: LD_INT 350
5333: PPUSH
5334: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5338: LD_INT 35
5340: PPUSH
5341: CALL_OW 67
// for i in attackers do
5345: LD_ADDR_VAR 0 1
5349: PUSH
5350: LD_VAR 0 4
5354: PUSH
5355: FOR_IN
5356: IFFALSE 5406
// if not HasTask ( i ) then
5358: LD_VAR 0 1
5362: PPUSH
5363: CALL_OW 314
5367: NOT
5368: IFFALSE 5404
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5370: LD_VAR 0 1
5374: PPUSH
5375: LD_INT 81
5377: PUSH
5378: LD_INT 2
5380: PUSH
5381: EMPTY
5382: LIST
5383: LIST
5384: PPUSH
5385: CALL_OW 69
5389: PPUSH
5390: LD_VAR 0 1
5394: PPUSH
5395: CALL_OW 74
5399: PPUSH
5400: CALL_OW 115
5404: GO 5355
5406: POP
5407: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5408: LD_VAR 0 4
5412: PPUSH
5413: LD_INT 50
5415: PUSH
5416: EMPTY
5417: LIST
5418: PPUSH
5419: CALL_OW 72
5423: NOT
5424: IFFALSE 5338
// end ;
5426: PPOPN 5
5428: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5429: LD_EXP 4
5433: NOT
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 191100
5442: LESS
5443: AND
5444: IFFALSE 6116
5446: GO 5448
5448: DISABLE
5449: LD_INT 0
5451: PPUSH
5452: PPUSH
5453: PPUSH
// begin enable ;
5454: ENABLE
// tmp := [ ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: EMPTY
5461: ST_TO_ADDR
// if tick < 35 35$00 then
5462: LD_OWVAR 1
5466: PUSH
5467: LD_INT 73500
5469: LESS
5470: IFFALSE 5668
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5472: LD_ADDR_VAR 0 1
5476: PUSH
5477: DOUBLE
5478: LD_INT 1
5480: DEC
5481: ST_TO_ADDR
5482: LD_INT 4
5484: PUSH
5485: LD_INT 5
5487: PUSH
5488: LD_INT 5
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_OWVAR 67
5500: ARRAY
5501: PUSH
5502: FOR_TO
5503: IFFALSE 5664
// begin uc_side := 2 ;
5505: LD_ADDR_OWVAR 20
5509: PUSH
5510: LD_INT 2
5512: ST_TO_ADDR
// uc_nation := 2 ;
5513: LD_ADDR_OWVAR 21
5517: PUSH
5518: LD_INT 2
5520: ST_TO_ADDR
// InitHC_All ( ) ;
5521: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5525: LD_INT 0
5527: PPUSH
5528: LD_INT 1
5530: PPUSH
5531: LD_INT 5
5533: PUSH
5534: LD_INT 6
5536: PUSH
5537: LD_INT 7
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: PUSH
5545: LD_OWVAR 67
5549: ARRAY
5550: PPUSH
5551: CALL_OW 380
// un := CreateHuman ;
5555: LD_ADDR_VAR 0 2
5559: PUSH
5560: CALL_OW 44
5564: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5565: LD_VAR 0 2
5569: PPUSH
5570: LD_INT 17
5572: PPUSH
5573: LD_INT 0
5575: PPUSH
5576: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5580: LD_VAR 0 2
5584: PPUSH
5585: LD_INT 1
5587: PUSH
5588: LD_INT 8
5590: PUSH
5591: EMPTY
5592: LIST
5593: LIST
5594: PUSH
5595: LD_INT 1
5597: PPUSH
5598: LD_INT 2
5600: PPUSH
5601: CALL_OW 12
5605: ARRAY
5606: PPUSH
5607: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5611: LD_VAR 0 2
5615: PPUSH
5616: LD_INT 111
5618: PPUSH
5619: LD_INT 34
5621: PPUSH
5622: CALL_OW 114
// wait ( 0 0$2 ) ;
5626: LD_INT 70
5628: PPUSH
5629: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5633: LD_ADDR_VAR 0 3
5637: PUSH
5638: LD_VAR 0 3
5642: PPUSH
5643: LD_VAR 0 3
5647: PUSH
5648: LD_INT 1
5650: PLUS
5651: PPUSH
5652: LD_VAR 0 2
5656: PPUSH
5657: CALL_OW 1
5661: ST_TO_ADDR
// end ;
5662: GO 5502
5664: POP
5665: POP
// end else
5666: GO 5809
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5668: LD_ADDR_VAR 0 1
5672: PUSH
5673: DOUBLE
5674: LD_INT 1
5676: DEC
5677: ST_TO_ADDR
5678: LD_INT 4
5680: PUSH
5681: LD_INT 5
5683: PUSH
5684: LD_INT 5
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_OWVAR 67
5696: ARRAY
5697: PUSH
5698: FOR_TO
5699: IFFALSE 5807
// begin uc_side := 2 ;
5701: LD_ADDR_OWVAR 20
5705: PUSH
5706: LD_INT 2
5708: ST_TO_ADDR
// uc_nation := 0 ;
5709: LD_ADDR_OWVAR 21
5713: PUSH
5714: LD_INT 0
5716: ST_TO_ADDR
// InitHC_All ( ) ;
5717: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5721: LD_ADDR_OWVAR 28
5725: PUSH
5726: LD_INT 17
5728: ST_TO_ADDR
// un := CreateHuman ;
5729: LD_ADDR_VAR 0 2
5733: PUSH
5734: CALL_OW 44
5738: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5739: LD_VAR 0 2
5743: PPUSH
5744: LD_INT 17
5746: PPUSH
5747: LD_INT 0
5749: PPUSH
5750: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5754: LD_VAR 0 2
5758: PPUSH
5759: LD_INT 110
5761: PPUSH
5762: LD_INT 33
5764: PPUSH
5765: CALL_OW 114
// wait ( 0 0$2 ) ;
5769: LD_INT 70
5771: PPUSH
5772: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5776: LD_ADDR_VAR 0 3
5780: PUSH
5781: LD_VAR 0 3
5785: PPUSH
5786: LD_VAR 0 3
5790: PUSH
5791: LD_INT 1
5793: PLUS
5794: PPUSH
5795: LD_VAR 0 2
5799: PPUSH
5800: CALL_OW 1
5804: ST_TO_ADDR
// end ;
5805: GO 5698
5807: POP
5808: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5809: LD_ADDR_VAR 0 1
5813: PUSH
5814: DOUBLE
5815: LD_INT 1
5817: DEC
5818: ST_TO_ADDR
5819: LD_INT 3
5821: PUSH
5822: LD_INT 4
5824: PUSH
5825: LD_INT 5
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_OWVAR 67
5837: ARRAY
5838: PUSH
5839: FOR_TO
5840: IFFALSE 6005
// begin uc_side := 2 ;
5842: LD_ADDR_OWVAR 20
5846: PUSH
5847: LD_INT 2
5849: ST_TO_ADDR
// uc_nation := 2 ;
5850: LD_ADDR_OWVAR 21
5854: PUSH
5855: LD_INT 2
5857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5858: LD_INT 14
5860: PPUSH
5861: LD_INT 3
5863: PPUSH
5864: LD_INT 5
5866: PPUSH
5867: LD_INT 29
5869: PUSH
5870: LD_INT 28
5872: PUSH
5873: LD_INT 27
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: LIST
5880: PUSH
5881: LD_INT 1
5883: PPUSH
5884: LD_INT 3
5886: PPUSH
5887: CALL_OW 12
5891: ARRAY
5892: PPUSH
5893: LD_INT 90
5895: PPUSH
5896: CALL 15868 0 5
// un := CreateVehicle ;
5900: LD_ADDR_VAR 0 2
5904: PUSH
5905: CALL_OW 45
5909: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5910: LD_VAR 0 2
5914: PPUSH
5915: LD_INT 2
5917: PPUSH
5918: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5922: LD_VAR 0 2
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_INT 0
5932: PPUSH
5933: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
5937: LD_VAR 0 2
5941: PPUSH
5942: LD_INT 66
5944: PPUSH
5945: LD_INT 23
5947: PPUSH
5948: CALL_OW 111
// wait ( 0 0$3 ) ;
5952: LD_INT 105
5954: PPUSH
5955: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
5959: LD_VAR 0 2
5963: PPUSH
5964: LD_INT 147
5966: PPUSH
5967: LD_INT 103
5969: PPUSH
5970: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5974: LD_ADDR_VAR 0 3
5978: PUSH
5979: LD_VAR 0 3
5983: PPUSH
5984: LD_VAR 0 3
5988: PUSH
5989: LD_INT 1
5991: PLUS
5992: PPUSH
5993: LD_VAR 0 2
5997: PPUSH
5998: CALL_OW 1
6002: ST_TO_ADDR
// end ;
6003: GO 5839
6005: POP
6006: POP
// if not tmp then
6007: LD_VAR 0 3
6011: NOT
6012: IFFALSE 6016
// exit ;
6014: GO 6116
// wait ( 0 0$5 ) ;
6016: LD_INT 175
6018: PPUSH
6019: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6023: LD_INT 70
6025: PPUSH
6026: CALL_OW 67
// for i in tmp do
6030: LD_ADDR_VAR 0 1
6034: PUSH
6035: LD_VAR 0 3
6039: PUSH
6040: FOR_IN
6041: IFFALSE 6107
// begin if not IsOk ( i ) then
6043: LD_VAR 0 1
6047: PPUSH
6048: CALL_OW 302
6052: NOT
6053: IFFALSE 6071
// tmp := tmp diff i ;
6055: LD_ADDR_VAR 0 3
6059: PUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_VAR 0 1
6069: DIFF
6070: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6071: LD_VAR 0 1
6075: PPUSH
6076: LD_INT 81
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: PPUSH
6086: CALL_OW 69
6090: PPUSH
6091: LD_VAR 0 1
6095: PPUSH
6096: CALL_OW 74
6100: PPUSH
6101: CALL_OW 115
// end ;
6105: GO 6040
6107: POP
6108: POP
// until not tmp ;
6109: LD_VAR 0 3
6113: NOT
6114: IFFALSE 6023
// end ;
6116: PPOPN 3
6118: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6119: LD_OWVAR 67
6123: PUSH
6124: LD_INT 1
6126: GREATER
6127: IFFALSE 6225
6129: GO 6131
6131: DISABLE
6132: LD_INT 0
6134: PPUSH
// begin uc_side := 2 ;
6135: LD_ADDR_OWVAR 20
6139: PUSH
6140: LD_INT 2
6142: ST_TO_ADDR
// uc_nation := 2 ;
6143: LD_ADDR_OWVAR 21
6147: PUSH
6148: LD_INT 2
6150: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6151: LD_INT 0
6153: PPUSH
6154: LD_INT 4
6156: PPUSH
6157: LD_INT 6
6159: PPUSH
6160: CALL_OW 380
// un := CreateHuman ;
6164: LD_ADDR_VAR 0 1
6168: PUSH
6169: CALL_OW 44
6173: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6174: LD_VAR 0 1
6178: PPUSH
6179: LD_INT 88
6181: PPUSH
6182: LD_INT 1
6184: PPUSH
6185: LD_INT 2
6187: PPUSH
6188: LD_INT 0
6190: PPUSH
6191: CALL 49672 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6195: LD_VAR 0 1
6199: PPUSH
6200: LD_INT 130
6202: PPUSH
6203: LD_INT 35
6205: PPUSH
6206: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6210: LD_VAR 0 1
6214: PPUSH
6215: LD_INT 132
6217: PPUSH
6218: LD_INT 39
6220: PPUSH
6221: CALL_OW 218
// end ;
6225: PPOPN 1
6227: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6228: LD_INT 22
6230: PUSH
6231: LD_INT 2
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PUSH
6238: LD_INT 33
6240: PUSH
6241: LD_INT 2
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PUSH
6248: LD_INT 50
6250: PUSH
6251: EMPTY
6252: LIST
6253: PUSH
6254: LD_INT 3
6256: PUSH
6257: LD_INT 61
6259: PUSH
6260: EMPTY
6261: LIST
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PUSH
6267: EMPTY
6268: LIST
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 69
6277: IFFALSE 6368
6279: GO 6281
6281: DISABLE
6282: LD_INT 0
6284: PPUSH
6285: PPUSH
// begin enable ;
6286: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6287: LD_ADDR_VAR 0 2
6291: PUSH
6292: LD_INT 22
6294: PUSH
6295: LD_INT 2
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 33
6304: PUSH
6305: LD_INT 2
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: LD_INT 50
6314: PUSH
6315: EMPTY
6316: LIST
6317: PUSH
6318: LD_INT 3
6320: PUSH
6321: LD_INT 61
6323: PUSH
6324: EMPTY
6325: LIST
6326: PUSH
6327: EMPTY
6328: LIST
6329: LIST
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PPUSH
6337: CALL_OW 69
6341: ST_TO_ADDR
// for i in tmp do
6342: LD_ADDR_VAR 0 1
6346: PUSH
6347: LD_VAR 0 2
6351: PUSH
6352: FOR_IN
6353: IFFALSE 6366
// Connect ( i ) ;
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL 18961 0 1
6364: GO 6352
6366: POP
6367: POP
// end ; end_of_file
6368: PPOPN 2
6370: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6371: LD_INT 0
6373: PPUSH
6374: PPUSH
6375: PPUSH
6376: PPUSH
6377: PPUSH
6378: PPUSH
// popov_side := 3 ;
6379: LD_ADDR_EXP 17
6383: PUSH
6384: LD_INT 3
6386: ST_TO_ADDR
// uc_side := popov_side ;
6387: LD_ADDR_OWVAR 20
6391: PUSH
6392: LD_EXP 17
6396: ST_TO_ADDR
// uc_nation := 3 ;
6397: LD_ADDR_OWVAR 21
6401: PUSH
6402: LD_INT 3
6404: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6405: LD_ADDR_VAR 0 6
6409: PUSH
6410: LD_INT 5
6412: PUSH
6413: LD_INT 103
6415: PUSH
6416: LD_INT 147
6418: PUSH
6419: LD_INT 3
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: PUSH
6428: LD_INT 5
6430: PUSH
6431: LD_INT 70
6433: PUSH
6434: LD_INT 117
6436: PUSH
6437: LD_INT 3
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: LD_INT 76
6451: PUSH
6452: LD_INT 145
6454: PUSH
6455: LD_INT 1
6457: PUSH
6458: LD_INT 10
6460: PUSH
6461: LD_INT 11
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 26
6474: PUSH
6475: LD_INT 87
6477: PUSH
6478: LD_INT 144
6480: PUSH
6481: LD_INT 0
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 29
6492: PUSH
6493: LD_INT 86
6495: PUSH
6496: LD_INT 118
6498: PUSH
6499: LD_INT 0
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 29
6510: PUSH
6511: LD_INT 98
6513: PUSH
6514: LD_INT 121
6516: PUSH
6517: LD_INT 0
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: LD_INT 26
6528: PUSH
6529: LD_INT 87
6531: PUSH
6532: LD_INT 147
6534: PUSH
6535: LD_INT 1
6537: PUSH
6538: EMPTY
6539: LIST
6540: LIST
6541: LIST
6542: LIST
6543: PUSH
6544: LD_INT 30
6546: PUSH
6547: LD_INT 123
6549: PUSH
6550: LD_INT 151
6552: PUSH
6553: LD_INT 1
6555: PUSH
6556: EMPTY
6557: LIST
6558: LIST
6559: LIST
6560: LIST
6561: PUSH
6562: LD_INT 3
6564: PUSH
6565: LD_INT 94
6567: PUSH
6568: LD_INT 161
6570: PUSH
6571: LD_INT 0
6573: PUSH
6574: EMPTY
6575: LIST
6576: LIST
6577: LIST
6578: LIST
6579: PUSH
6580: LD_INT 6
6582: PUSH
6583: LD_INT 81
6585: PUSH
6586: LD_INT 155
6588: PUSH
6589: LD_INT 1
6591: PUSH
6592: LD_INT 12
6594: PUSH
6595: LD_INT 14
6597: PUSH
6598: EMPTY
6599: LIST
6600: LIST
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 26
6608: PUSH
6609: LD_INT 96
6611: PUSH
6612: LD_INT 152
6614: PUSH
6615: LD_INT 0
6617: PUSH
6618: EMPTY
6619: LIST
6620: LIST
6621: LIST
6622: LIST
6623: PUSH
6624: LD_INT 26
6626: PUSH
6627: LD_INT 96
6629: PUSH
6630: LD_INT 149
6632: PUSH
6633: LD_INT 3
6635: PUSH
6636: EMPTY
6637: LIST
6638: LIST
6639: LIST
6640: LIST
6641: PUSH
6642: LD_INT 32
6644: PUSH
6645: LD_INT 109
6647: PUSH
6648: LD_INT 142
6650: PUSH
6651: LD_INT 3
6653: PUSH
6654: LD_INT 46
6656: PUSH
6657: EMPTY
6658: LIST
6659: LIST
6660: LIST
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 32
6666: PUSH
6667: LD_INT 112
6669: PUSH
6670: LD_INT 148
6672: PUSH
6673: LD_INT 3
6675: PUSH
6676: LD_INT 46
6678: PUSH
6679: EMPTY
6680: LIST
6681: LIST
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_INT 33
6688: PUSH
6689: LD_INT 120
6691: PUSH
6692: LD_INT 159
6694: PUSH
6695: LD_INT 4
6697: PUSH
6698: LD_INT 45
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 33
6710: PUSH
6711: LD_INT 122
6713: PUSH
6714: LD_INT 163
6716: PUSH
6717: LD_INT 4
6719: PUSH
6720: LD_INT 45
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 33
6732: PUSH
6733: LD_INT 123
6735: PUSH
6736: LD_INT 167
6738: PUSH
6739: LD_INT 4
6741: PUSH
6742: LD_INT 45
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 59
6757: PUSH
6758: LD_INT 111
6760: PUSH
6761: LD_INT 3
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 65
6779: PUSH
6780: LD_INT 111
6782: PUSH
6783: LD_INT 3
6785: PUSH
6786: LD_INT 46
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 76
6801: PUSH
6802: LD_INT 117
6804: PUSH
6805: LD_INT 3
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 80
6823: PUSH
6824: LD_INT 119
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 46
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 87
6845: PUSH
6846: LD_INT 125
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 45
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 5
6864: PUSH
6865: LD_INT 92
6867: PUSH
6868: LD_INT 129
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: LIST
6878: LIST
6879: PUSH
6880: LD_INT 28
6882: PUSH
6883: LD_INT 85
6885: PUSH
6886: LD_INT 165
6888: PUSH
6889: LD_INT 0
6891: PUSH
6892: EMPTY
6893: LIST
6894: LIST
6895: LIST
6896: LIST
6897: PUSH
6898: LD_INT 28
6900: PUSH
6901: LD_INT 83
6903: PUSH
6904: LD_INT 161
6906: PUSH
6907: LD_INT 4
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: LIST
6914: LIST
6915: PUSH
6916: LD_INT 28
6918: PUSH
6919: LD_INT 91
6921: PUSH
6922: LD_INT 166
6924: PUSH
6925: LD_INT 3
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: LIST
6932: LIST
6933: PUSH
6934: LD_INT 28
6936: PUSH
6937: LD_INT 102
6939: PUSH
6940: LD_INT 166
6942: PUSH
6943: LD_INT 2
6945: PUSH
6946: EMPTY
6947: LIST
6948: LIST
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: LIST
6956: LIST
6957: LIST
6958: LIST
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: LIST
6964: LIST
6965: LIST
6966: LIST
6967: LIST
6968: LIST
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: LIST
6974: LIST
6975: LIST
6976: LIST
6977: LIST
6978: LIST
6979: LIST
6980: ST_TO_ADDR
// for i in list do
6981: LD_ADDR_VAR 0 2
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7170
// begin uc_side := 3 ;
6994: LD_ADDR_OWVAR 20
6998: PUSH
6999: LD_INT 3
7001: ST_TO_ADDR
// uc_nation := 3 ;
7002: LD_ADDR_OWVAR 21
7006: PUSH
7007: LD_INT 3
7009: ST_TO_ADDR
// bc_type := i [ 1 ] ;
7010: LD_ADDR_OWVAR 42
7014: PUSH
7015: LD_VAR 0 2
7019: PUSH
7020: LD_INT 1
7022: ARRAY
7023: ST_TO_ADDR
// bc_kind1 := - 1 ;
7024: LD_ADDR_OWVAR 44
7028: PUSH
7029: LD_INT 1
7031: NEG
7032: ST_TO_ADDR
// bc_kind2 := - 1 ;
7033: LD_ADDR_OWVAR 45
7037: PUSH
7038: LD_INT 1
7040: NEG
7041: ST_TO_ADDR
// if i [ 1 ] = b_lab then
7042: LD_VAR 0 2
7046: PUSH
7047: LD_INT 1
7049: ARRAY
7050: PUSH
7051: LD_INT 6
7053: EQUAL
7054: IFFALSE 7092
// begin bc_type := b_lab_full ;
7056: LD_ADDR_OWVAR 42
7060: PUSH
7061: LD_INT 8
7063: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7064: LD_ADDR_OWVAR 44
7068: PUSH
7069: LD_VAR 0 2
7073: PUSH
7074: LD_INT 5
7076: ARRAY
7077: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7078: LD_ADDR_OWVAR 45
7082: PUSH
7083: LD_VAR 0 2
7087: PUSH
7088: LD_INT 6
7090: ARRAY
7091: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7092: LD_ADDR_VAR 0 5
7096: PUSH
7097: LD_VAR 0 2
7101: PUSH
7102: LD_INT 2
7104: ARRAY
7105: PPUSH
7106: LD_VAR 0 2
7110: PUSH
7111: LD_INT 3
7113: ARRAY
7114: PPUSH
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 4
7122: ARRAY
7123: PPUSH
7124: CALL_OW 47
7128: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7129: LD_VAR 0 2
7133: PUSH
7134: LD_INT 1
7136: ARRAY
7137: PUSH
7138: LD_INT 33
7140: PUSH
7141: LD_INT 32
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: IN
7148: IFFALSE 7168
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7150: LD_VAR 0 5
7154: PPUSH
7155: LD_VAR 0 2
7159: PUSH
7160: LD_INT 5
7162: ARRAY
7163: PPUSH
7164: CALL_OW 431
// end ;
7168: GO 6991
7170: POP
7171: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7172: LD_ADDR_VAR 0 4
7176: PUSH
7177: LD_INT 9
7179: PPUSH
7180: LD_INT 3
7182: PPUSH
7183: LD_STRING 
7185: PPUSH
7186: LD_INT 8
7188: PUSH
7189: LD_INT 7
7191: PUSH
7192: LD_INT 6
7194: PUSH
7195: EMPTY
7196: LIST
7197: LIST
7198: LIST
7199: PUSH
7200: LD_OWVAR 67
7204: ARRAY
7205: PPUSH
7206: LD_INT 11500
7208: PUSH
7209: LD_INT 1100
7211: PUSH
7212: LD_INT 60
7214: PUSH
7215: EMPTY
7216: LIST
7217: LIST
7218: LIST
7219: PPUSH
7220: LD_INT 6
7222: PUSH
7223: LD_INT 6
7225: PUSH
7226: LD_INT 6
7228: PUSH
7229: LD_INT 6
7231: PUSH
7232: EMPTY
7233: LIST
7234: LIST
7235: LIST
7236: LIST
7237: PPUSH
7238: CALL 19314 0 6
7242: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7243: LD_ADDR_EXP 23
7247: PUSH
7248: LD_EXP 23
7252: PPUSH
7253: LD_INT 3
7255: PPUSH
7256: LD_VAR 0 4
7260: PUSH
7261: LD_INT 22
7263: PUSH
7264: LD_INT 3
7266: PUSH
7267: EMPTY
7268: LIST
7269: LIST
7270: PUSH
7271: LD_INT 21
7273: PUSH
7274: LD_INT 3
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: PUSH
7281: EMPTY
7282: LIST
7283: LIST
7284: PPUSH
7285: CALL_OW 69
7289: UNION
7290: PPUSH
7291: CALL_OW 1
7295: ST_TO_ADDR
// extraPopovForces := [ ] ;
7296: LD_ADDR_EXP 18
7300: PUSH
7301: EMPTY
7302: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7303: LD_ADDR_VAR 0 2
7307: PUSH
7308: DOUBLE
7309: LD_INT 1
7311: DEC
7312: ST_TO_ADDR
7313: LD_INT 8
7315: PUSH
7316: LD_INT 9
7318: PUSH
7319: LD_INT 10
7321: PUSH
7322: EMPTY
7323: LIST
7324: LIST
7325: LIST
7326: PUSH
7327: LD_OWVAR 67
7331: ARRAY
7332: PUSH
7333: FOR_TO
7334: IFFALSE 7463
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7336: LD_INT 0
7338: PPUSH
7339: LD_INT 1
7341: PPUSH
7342: LD_INT 4
7344: PUSH
7345: LD_INT 5
7347: PUSH
7348: LD_INT 6
7350: PUSH
7351: EMPTY
7352: LIST
7353: LIST
7354: LIST
7355: PUSH
7356: LD_OWVAR 67
7360: ARRAY
7361: PPUSH
7362: CALL_OW 380
// un := CreateHuman ;
7366: LD_ADDR_VAR 0 3
7370: PUSH
7371: CALL_OW 44
7375: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7376: LD_INT 0
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 12
7386: IFFALSE 7411
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7388: LD_VAR 0 3
7392: PPUSH
7393: LD_INT 131
7395: PPUSH
7396: LD_INT 110
7398: PPUSH
7399: LD_INT 8
7401: PPUSH
7402: LD_INT 0
7404: PPUSH
7405: CALL_OW 50
7409: GO 7432
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7411: LD_VAR 0 3
7415: PPUSH
7416: LD_INT 100
7418: PPUSH
7419: LD_INT 99
7421: PPUSH
7422: LD_INT 8
7424: PPUSH
7425: LD_INT 0
7427: PPUSH
7428: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7432: LD_ADDR_EXP 18
7436: PUSH
7437: LD_EXP 18
7441: PPUSH
7442: LD_EXP 18
7446: PUSH
7447: LD_INT 1
7449: PLUS
7450: PPUSH
7451: LD_VAR 0 3
7455: PPUSH
7456: CALL_OW 1
7460: ST_TO_ADDR
// end ;
7461: GO 7333
7463: POP
7464: POP
// PrepareSoldier ( false , 6 ) ;
7465: LD_INT 0
7467: PPUSH
7468: LD_INT 6
7470: PPUSH
7471: CALL_OW 381
// un := CreateHuman ;
7475: LD_ADDR_VAR 0 3
7479: PUSH
7480: CALL_OW 44
7484: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7485: LD_VAR 0 3
7489: PPUSH
7490: LD_INT 1
7492: PPUSH
7493: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7497: LD_VAR 0 3
7501: PPUSH
7502: LD_INT 150
7504: PPUSH
7505: LD_INT 158
7507: PPUSH
7508: CALL_OW 428
7512: PPUSH
7513: CALL_OW 52
// popovAttackGroup := [ ] ;
7517: LD_ADDR_EXP 19
7521: PUSH
7522: EMPTY
7523: ST_TO_ADDR
// end ;
7524: LD_VAR 0 1
7528: RET
// export function InitMC_Popov ( ) ; begin
7529: LD_INT 0
7531: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7532: LD_INT 3
7534: PPUSH
7535: LD_INT 3
7537: PPUSH
7538: CALL 76052 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7542: LD_INT 3
7544: PPUSH
7545: LD_INT 10
7547: PPUSH
7548: CALL 75996 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7552: LD_INT 3
7554: PPUSH
7555: LD_INT 86
7557: PUSH
7558: LD_INT 118
7560: PUSH
7561: LD_INT 0
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: PUSH
7569: LD_INT 123
7571: PUSH
7572: LD_INT 151
7574: PUSH
7575: LD_INT 1
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 98
7585: PUSH
7586: LD_INT 121
7588: PUSH
7589: LD_INT 0
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: LIST
7596: PUSH
7597: EMPTY
7598: LIST
7599: LIST
7600: LIST
7601: PPUSH
7602: CALL 75055 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7606: LD_INT 3
7608: PPUSH
7609: LD_INT 46
7611: PUSH
7612: LD_INT 45
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PPUSH
7619: CALL 75884 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7623: LD_INT 3
7625: PPUSH
7626: LD_INT 12
7628: PPUSH
7629: CALL 75566 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7633: LD_INT 3
7635: PPUSH
7636: LD_INT 11
7638: PPUSH
7639: CALL 75297 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7643: LD_INT 3
7645: PPUSH
7646: LD_INT 4
7648: PPUSH
7649: CALL 74916 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7653: LD_INT 3
7655: PPUSH
7656: LD_INT 23
7658: PUSH
7659: LD_INT 1
7661: PUSH
7662: LD_INT 3
7664: PUSH
7665: LD_INT 44
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: LIST
7673: PUSH
7674: LD_INT 23
7676: PUSH
7677: LD_INT 1
7679: PUSH
7680: LD_INT 3
7682: PUSH
7683: LD_INT 45
7685: PUSH
7686: EMPTY
7687: LIST
7688: LIST
7689: LIST
7690: LIST
7691: PUSH
7692: LD_INT 21
7694: PUSH
7695: LD_INT 1
7697: PUSH
7698: LD_INT 3
7700: PUSH
7701: LD_INT 44
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: PUSH
7710: LD_INT 21
7712: PUSH
7713: LD_INT 1
7715: PUSH
7716: LD_INT 3
7718: PUSH
7719: LD_INT 45
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: PPUSH
7734: CALL 74731 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7738: LD_INT 3
7740: PPUSH
7741: LD_INT 94
7743: PPUSH
7744: LD_INT 161
7746: PPUSH
7747: LD_INT 0
7749: PPUSH
7750: LD_INT 19
7752: PUSH
7753: LD_INT 17
7755: PUSH
7756: LD_INT 18
7758: PUSH
7759: LD_INT 24
7761: PUSH
7762: LD_INT 21
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PPUSH
7772: CALL 75678 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7776: LD_INT 3
7778: PPUSH
7779: LD_INT 21
7781: PUSH
7782: LD_INT 1
7784: PUSH
7785: LD_INT 3
7787: PUSH
7788: LD_INT 51
7790: PUSH
7791: EMPTY
7792: LIST
7793: LIST
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: PPUSH
7800: CALL 74779 0 2
// end ;
7804: LD_VAR 0 1
7808: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7809: LD_EXP 18
7813: PUSH
7814: LD_EXP 5
7818: NOT
7819: AND
7820: IFFALSE 7880
7822: GO 7824
7824: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7825: LD_EXP 18
7829: PPUSH
7830: LD_INT 106
7832: PPUSH
7833: LD_INT 137
7835: PPUSH
7836: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7840: LD_ADDR_EXP 23
7844: PUSH
7845: LD_EXP 23
7849: PPUSH
7850: LD_INT 3
7852: PPUSH
7853: LD_EXP 23
7857: PUSH
7858: LD_INT 3
7860: ARRAY
7861: PUSH
7862: LD_EXP 18
7866: UNION
7867: PPUSH
7868: CALL_OW 1
7872: ST_TO_ADDR
// extraPopovForces := [ ] ;
7873: LD_ADDR_EXP 18
7877: PUSH
7878: EMPTY
7879: ST_TO_ADDR
// end ;
7880: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7881: LD_INT 9
7883: PPUSH
7884: CALL_OW 302
7888: PUSH
7889: LD_EXP 5
7893: NOT
7894: AND
7895: IFFALSE 8461
7897: GO 7899
7899: DISABLE
7900: LD_INT 0
7902: PPUSH
7903: PPUSH
7904: PPUSH
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// base := 3 ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
7916: LD_ADDR_VAR 0 3
7920: PUSH
7921: LD_INT 22
7923: PUSH
7924: LD_INT 1
7926: PUSH
7927: LD_INT 3
7929: PUSH
7930: LD_INT 44
7932: PUSH
7933: EMPTY
7934: LIST
7935: LIST
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 24
7941: PUSH
7942: LD_INT 1
7944: PUSH
7945: LD_INT 3
7947: PUSH
7948: LD_INT 46
7950: PUSH
7951: EMPTY
7952: LIST
7953: LIST
7954: LIST
7955: LIST
7956: PUSH
7957: LD_INT 24
7959: PUSH
7960: LD_INT 1
7962: PUSH
7963: LD_INT 3
7965: PUSH
7966: LD_INT 46
7968: PUSH
7969: EMPTY
7970: LIST
7971: LIST
7972: LIST
7973: LIST
7974: PUSH
7975: LD_INT 24
7977: PUSH
7978: LD_INT 1
7980: PUSH
7981: LD_INT 3
7983: PUSH
7984: LD_INT 46
7986: PUSH
7987: EMPTY
7988: LIST
7989: LIST
7990: LIST
7991: LIST
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
7999: LD_ADDR_VAR 0 5
8003: PUSH
8004: LD_VAR 0 5
8008: PUSH
8009: LD_OWVAR 1
8013: PUSH
8014: LD_INT 21000
8016: DIV
8017: PLUS
8018: ST_TO_ADDR
// if amount > 8 then
8019: LD_VAR 0 5
8023: PUSH
8024: LD_INT 8
8026: GREATER
8027: IFFALSE 8037
// amount := 8 ;
8029: LD_ADDR_VAR 0 5
8033: PUSH
8034: LD_INT 8
8036: ST_TO_ADDR
// for i = 1 to amount do
8037: LD_ADDR_VAR 0 1
8041: PUSH
8042: DOUBLE
8043: LD_INT 1
8045: DEC
8046: ST_TO_ADDR
8047: LD_VAR 0 5
8051: PUSH
8052: FOR_TO
8053: IFFALSE 8118
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8055: LD_ADDR_VAR 0 3
8059: PUSH
8060: LD_VAR 0 3
8064: PPUSH
8065: LD_VAR 0 3
8069: PUSH
8070: LD_INT 1
8072: PLUS
8073: PPUSH
8074: LD_INT 24
8076: PUSH
8077: LD_INT 1
8079: PUSH
8080: LD_INT 3
8082: PUSH
8083: LD_INT 46
8085: PUSH
8086: LD_INT 45
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: PUSH
8093: LD_INT 1
8095: PPUSH
8096: LD_INT 2
8098: PPUSH
8099: CALL_OW 12
8103: ARRAY
8104: PUSH
8105: EMPTY
8106: LIST
8107: LIST
8108: LIST
8109: LIST
8110: PPUSH
8111: CALL_OW 2
8115: ST_TO_ADDR
8116: GO 8052
8118: POP
8119: POP
// MC_InsertProduceList ( base , tmp ) ;
8120: LD_VAR 0 2
8124: PPUSH
8125: LD_VAR 0 3
8129: PPUSH
8130: CALL 74779 0 2
// repeat wait ( 0 0$1 ) ;
8134: LD_INT 35
8136: PPUSH
8137: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8141: LD_VAR 0 2
8145: PPUSH
8146: LD_INT 1
8148: PPUSH
8149: CALL 76197 0 2
8153: PUSH
8154: LD_VAR 0 5
8158: GREATEREQUAL
8159: IFFALSE 8134
// wait ( 0 0$30 ) ;
8161: LD_INT 1050
8163: PPUSH
8164: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8168: LD_ADDR_VAR 0 4
8172: PUSH
8173: LD_EXP 42
8177: PUSH
8178: LD_VAR 0 2
8182: ARRAY
8183: PUSH
8184: LD_EXP 42
8188: PUSH
8189: LD_VAR 0 2
8193: ARRAY
8194: PPUSH
8195: LD_INT 2
8197: PUSH
8198: LD_INT 34
8200: PUSH
8201: LD_INT 51
8203: PUSH
8204: EMPTY
8205: LIST
8206: LIST
8207: PUSH
8208: LD_INT 34
8210: PUSH
8211: LD_INT 52
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PPUSH
8223: CALL_OW 72
8227: DIFF
8228: ST_TO_ADDR
// if not attackers then
8229: LD_VAR 0 4
8233: NOT
8234: IFFALSE 8238
// exit ;
8236: GO 8461
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8238: LD_ADDR_EXP 42
8242: PUSH
8243: LD_EXP 42
8247: PPUSH
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_EXP 42
8257: PUSH
8258: LD_VAR 0 2
8262: ARRAY
8263: PUSH
8264: LD_VAR 0 4
8268: DIFF
8269: PPUSH
8270: CALL_OW 1
8274: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8275: LD_VAR 0 4
8279: PPUSH
8280: LD_INT 107
8282: PPUSH
8283: LD_INT 74
8285: PPUSH
8286: CALL_OW 114
// wait ( 0 0$5 ) ;
8290: LD_INT 175
8292: PPUSH
8293: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8304: LD_VAR 0 4
8308: PPUSH
8309: LD_INT 60
8311: PUSH
8312: EMPTY
8313: LIST
8314: PPUSH
8315: CALL_OW 72
8319: NOT
8320: IFFALSE 8297
// if rand ( 0 , 1 ) then
8322: LD_INT 0
8324: PPUSH
8325: LD_INT 1
8327: PPUSH
8328: CALL_OW 12
8332: IFFALSE 8351
// ComAgressiveMove ( attackers , 155 , 108 ) else
8334: LD_VAR 0 4
8338: PPUSH
8339: LD_INT 155
8341: PPUSH
8342: LD_INT 108
8344: PPUSH
8345: CALL_OW 114
8349: GO 8366
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8351: LD_VAR 0 4
8355: PPUSH
8356: LD_INT 149
8358: PPUSH
8359: LD_INT 55
8361: PPUSH
8362: CALL_OW 114
// wait ( 0 0$10 ) ;
8366: LD_INT 350
8368: PPUSH
8369: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8373: LD_INT 35
8375: PPUSH
8376: CALL_OW 67
// for i in attackers do
8380: LD_ADDR_VAR 0 1
8384: PUSH
8385: LD_VAR 0 4
8389: PUSH
8390: FOR_IN
8391: IFFALSE 8441
// if not HasTask ( i ) then
8393: LD_VAR 0 1
8397: PPUSH
8398: CALL_OW 314
8402: NOT
8403: IFFALSE 8439
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_INT 81
8412: PUSH
8413: LD_INT 3
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PPUSH
8420: CALL_OW 69
8424: PPUSH
8425: LD_VAR 0 1
8429: PPUSH
8430: CALL_OW 74
8434: PPUSH
8435: CALL_OW 115
8439: GO 8390
8441: POP
8442: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8443: LD_VAR 0 4
8447: PPUSH
8448: LD_INT 50
8450: PUSH
8451: EMPTY
8452: LIST
8453: PPUSH
8454: CALL_OW 72
8458: NOT
8459: IFFALSE 8373
// end ;
8461: PPOPN 5
8463: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8464: LD_EXP 5
8468: NOT
8469: IFFALSE 9056
8471: GO 8473
8473: DISABLE
8474: LD_INT 0
8476: PPUSH
8477: PPUSH
8478: PPUSH
8479: PPUSH
// begin enable ;
8480: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8481: LD_OWVAR 67
8485: PUSH
8486: LD_INT 1
8488: EQUAL
8489: PUSH
8490: LD_OWVAR 1
8494: PUSH
8495: LD_INT 63000
8497: LESS
8498: AND
8499: IFFALSE 8503
// exit ;
8501: GO 9056
// tmp := [ ] ;
8503: LD_ADDR_VAR 0 3
8507: PUSH
8508: EMPTY
8509: ST_TO_ADDR
// if tick < 45 45$00 then
8510: LD_OWVAR 1
8514: PUSH
8515: LD_INT 94500
8517: LESS
8518: IFFALSE 8695
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8520: LD_ADDR_VAR 0 1
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_INT 2
8532: PUSH
8533: LD_INT 3
8535: PUSH
8536: LD_INT 4
8538: PUSH
8539: EMPTY
8540: LIST
8541: LIST
8542: LIST
8543: PUSH
8544: LD_OWVAR 67
8548: ARRAY
8549: PUSH
8550: FOR_TO
8551: IFFALSE 8693
// begin uc_side := 3 ;
8553: LD_ADDR_OWVAR 20
8557: PUSH
8558: LD_INT 3
8560: ST_TO_ADDR
// uc_nation := 3 ;
8561: LD_ADDR_OWVAR 21
8565: PUSH
8566: LD_INT 3
8568: ST_TO_ADDR
// InitHC_All ( ) ;
8569: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8573: LD_INT 0
8575: PPUSH
8576: LD_INT 1
8578: PPUSH
8579: LD_INT 5
8581: PUSH
8582: LD_INT 6
8584: PUSH
8585: LD_INT 7
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PUSH
8593: LD_OWVAR 67
8597: ARRAY
8598: PPUSH
8599: CALL_OW 380
// un := CreateHuman ;
8603: LD_ADDR_VAR 0 2
8607: PUSH
8608: CALL_OW 44
8612: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8613: LD_VAR 0 2
8617: PPUSH
8618: LD_INT 18
8620: PPUSH
8621: LD_INT 0
8623: PPUSH
8624: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8628: LD_VAR 0 2
8632: PPUSH
8633: LD_INT 9
8635: PPUSH
8636: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8640: LD_VAR 0 2
8644: PPUSH
8645: LD_INT 147
8647: PPUSH
8648: LD_INT 161
8650: PPUSH
8651: CALL_OW 111
// wait ( 0 0$2 ) ;
8655: LD_INT 70
8657: PPUSH
8658: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8662: LD_ADDR_VAR 0 3
8666: PUSH
8667: LD_VAR 0 3
8671: PPUSH
8672: LD_VAR 0 3
8676: PUSH
8677: LD_INT 1
8679: PLUS
8680: PPUSH
8681: LD_VAR 0 2
8685: PPUSH
8686: CALL_OW 1
8690: ST_TO_ADDR
// end ;
8691: GO 8550
8693: POP
8694: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8695: LD_ADDR_VAR 0 4
8699: PUSH
8700: LD_INT 3
8702: PUSH
8703: LD_INT 4
8705: PUSH
8706: LD_INT 5
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: LIST
8713: PUSH
8714: LD_OWVAR 67
8718: ARRAY
8719: PUSH
8720: LD_OWVAR 1
8724: PUSH
8725: LD_INT 21000
8727: DIV
8728: PLUS
8729: ST_TO_ADDR
// if amount > 15 then
8730: LD_VAR 0 4
8734: PUSH
8735: LD_INT 15
8737: GREATER
8738: IFFALSE 8748
// amount := 15 ;
8740: LD_ADDR_VAR 0 4
8744: PUSH
8745: LD_INT 15
8747: ST_TO_ADDR
// for i := 1 to amount do
8748: LD_ADDR_VAR 0 1
8752: PUSH
8753: DOUBLE
8754: LD_INT 1
8756: DEC
8757: ST_TO_ADDR
8758: LD_VAR 0 4
8762: PUSH
8763: FOR_TO
8764: IFFALSE 8910
// begin uc_side := 3 ;
8766: LD_ADDR_OWVAR 20
8770: PUSH
8771: LD_INT 3
8773: ST_TO_ADDR
// uc_nation := 3 ;
8774: LD_ADDR_OWVAR 21
8778: PUSH
8779: LD_INT 3
8781: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8782: LD_INT 24
8784: PPUSH
8785: LD_INT 1
8787: PPUSH
8788: LD_INT 3
8790: PPUSH
8791: LD_INT 46
8793: PUSH
8794: LD_INT 45
8796: PUSH
8797: LD_INT 44
8799: PUSH
8800: LD_INT 43
8802: PUSH
8803: LD_INT 42
8805: PUSH
8806: EMPTY
8807: LIST
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 5
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: PPUSH
8825: LD_INT 90
8827: PPUSH
8828: CALL 15868 0 5
// un := CreateVehicle ;
8832: LD_ADDR_VAR 0 2
8836: PUSH
8837: CALL_OW 45
8841: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8842: LD_VAR 0 2
8846: PPUSH
8847: LD_INT 18
8849: PPUSH
8850: LD_INT 0
8852: PPUSH
8853: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8857: LD_VAR 0 2
8861: PPUSH
8862: LD_INT 147
8864: PPUSH
8865: LD_INT 161
8867: PPUSH
8868: CALL_OW 111
// wait ( 0 0$3 ) ;
8872: LD_INT 105
8874: PPUSH
8875: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8879: LD_ADDR_VAR 0 3
8883: PUSH
8884: LD_VAR 0 3
8888: PPUSH
8889: LD_VAR 0 3
8893: PUSH
8894: LD_INT 1
8896: PLUS
8897: PPUSH
8898: LD_VAR 0 2
8902: PPUSH
8903: CALL_OW 1
8907: ST_TO_ADDR
// end ;
8908: GO 8763
8910: POP
8911: POP
// if not tmp then
8912: LD_VAR 0 3
8916: NOT
8917: IFFALSE 8921
// exit ;
8919: GO 9056
// wait ( 0 0$5 ) ;
8921: LD_INT 175
8923: PPUSH
8924: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
8928: LD_INT 70
8930: PPUSH
8931: CALL_OW 67
// for i in tmp do
8935: LD_ADDR_VAR 0 1
8939: PUSH
8940: LD_VAR 0 3
8944: PUSH
8945: FOR_IN
8946: IFFALSE 9047
// begin if not IsOk ( i ) or IsDead ( i ) then
8948: LD_VAR 0 1
8952: PPUSH
8953: CALL_OW 302
8957: NOT
8958: PUSH
8959: LD_VAR 0 1
8963: PPUSH
8964: CALL_OW 301
8968: OR
8969: IFFALSE 8987
// tmp := tmp diff i ;
8971: LD_ADDR_VAR 0 3
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_VAR 0 1
8985: DIFF
8986: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
8987: LD_VAR 0 1
8991: PPUSH
8992: CALL_OW 257
8996: PUSH
8997: LD_INT 9
8999: EQUAL
9000: IFFALSE 9011
// ComSpaceTimeShoot ( i ) ;
9002: LD_VAR 0 1
9006: PPUSH
9007: CALL 11951 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9011: LD_VAR 0 1
9015: PPUSH
9016: LD_INT 81
9018: PUSH
9019: LD_INT 3
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: PPUSH
9026: CALL_OW 69
9030: PPUSH
9031: LD_VAR 0 1
9035: PPUSH
9036: CALL_OW 74
9040: PPUSH
9041: CALL_OW 115
// end ;
9045: GO 8945
9047: POP
9048: POP
// until not tmp ;
9049: LD_VAR 0 3
9053: NOT
9054: IFFALSE 8928
// end ; end_of_file
9056: PPOPN 4
9058: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
// uc_side := 1 ;
9065: LD_ADDR_OWVAR 20
9069: PUSH
9070: LD_INT 1
9072: ST_TO_ADDR
// uc_nation := 1 ;
9073: LD_ADDR_OWVAR 21
9077: PUSH
9078: LD_INT 1
9080: ST_TO_ADDR
// hc_importance := 100 ;
9081: LD_ADDR_OWVAR 32
9085: PUSH
9086: LD_INT 100
9088: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9089: LD_ADDR_OWVAR 26
9093: PUSH
9094: LD_STRING Jeremy Sikorski
9096: ST_TO_ADDR
// hc_gallery := us ;
9097: LD_ADDR_OWVAR 33
9101: PUSH
9102: LD_STRING us
9104: ST_TO_ADDR
// hc_face_number := 19 ;
9105: LD_ADDR_OWVAR 34
9109: PUSH
9110: LD_INT 19
9112: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9113: LD_INT 1
9115: PPUSH
9116: LD_INT 1
9118: PPUSH
9119: LD_INT 4
9121: PUSH
9122: LD_INT 4
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: LIST
9132: PUSH
9133: LD_OWVAR 67
9137: ARRAY
9138: PPUSH
9139: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9143: LD_ADDR_OWVAR 29
9147: PUSH
9148: LD_INT 10
9150: PUSH
9151: LD_INT 12
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: ST_TO_ADDR
// Sikorski := CreateHuman ;
9158: LD_ADDR_EXP 20
9162: PUSH
9163: CALL_OW 44
9167: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9168: LD_EXP 20
9172: PPUSH
9173: LD_INT 133
9175: PPUSH
9176: LD_INT 19
9178: PPUSH
9179: LD_INT 2
9181: PPUSH
9182: LD_INT 0
9184: PPUSH
9185: CALL_OW 50
// InitHc_All ( ) ;
9189: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9193: LD_ADDR_VAR 0 2
9197: PUSH
9198: DOUBLE
9199: LD_INT 1
9201: DEC
9202: ST_TO_ADDR
9203: LD_INT 4
9205: PUSH
9206: LD_INT 3
9208: PUSH
9209: LD_INT 3
9211: PUSH
9212: EMPTY
9213: LIST
9214: LIST
9215: LIST
9216: PUSH
9217: LD_OWVAR 67
9221: ARRAY
9222: PUSH
9223: FOR_TO
9224: IFFALSE 9340
// for j := 1 to 4 do
9226: LD_ADDR_VAR 0 3
9230: PUSH
9231: DOUBLE
9232: LD_INT 1
9234: DEC
9235: ST_TO_ADDR
9236: LD_INT 4
9238: PUSH
9239: FOR_TO
9240: IFFALSE 9336
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9242: LD_INT 0
9244: PPUSH
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 5
9252: PUSH
9253: LD_INT 4
9255: PUSH
9256: LD_INT 3
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PUSH
9264: LD_OWVAR 67
9268: ARRAY
9269: PPUSH
9270: CALL_OW 380
// un := CreateHuman ;
9274: LD_ADDR_VAR 0 4
9278: PUSH
9279: CALL_OW 44
9283: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9284: LD_VAR 0 4
9288: PPUSH
9289: LD_INT 0
9291: PPUSH
9292: LD_INT 5
9294: PPUSH
9295: CALL_OW 12
9299: PPUSH
9300: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9304: LD_VAR 0 4
9308: PPUSH
9309: LD_INT 133
9311: PPUSH
9312: LD_INT 19
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 0
9320: PPUSH
9321: CALL_OW 50
// ComHold ( un ) ;
9325: LD_VAR 0 4
9329: PPUSH
9330: CALL_OW 140
// end ;
9334: GO 9239
9336: POP
9337: POP
9338: GO 9223
9340: POP
9341: POP
// vc_chassis := us_heavy_tracked ;
9342: LD_ADDR_OWVAR 37
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// vc_engine := engine_combustion ;
9350: LD_ADDR_OWVAR 39
9354: PUSH
9355: LD_INT 1
9357: ST_TO_ADDR
// vc_control := control_manual ;
9358: LD_ADDR_OWVAR 38
9362: PUSH
9363: LD_INT 1
9365: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9366: LD_ADDR_OWVAR 40
9370: PUSH
9371: LD_INT 14
9373: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9374: LD_ADDR_OWVAR 41
9378: PUSH
9379: LD_INT 60
9381: ST_TO_ADDR
// un := CreateVehicle ;
9382: LD_ADDR_VAR 0 4
9386: PUSH
9387: CALL_OW 45
9391: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9392: LD_VAR 0 4
9396: PPUSH
9397: LD_INT 2
9399: PPUSH
9400: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9404: LD_VAR 0 4
9408: PPUSH
9409: LD_INT 128
9411: PPUSH
9412: LD_INT 12
9414: PPUSH
9415: LD_INT 0
9417: PPUSH
9418: CALL_OW 48
// for i := 1 to 3 do
9422: LD_ADDR_VAR 0 2
9426: PUSH
9427: DOUBLE
9428: LD_INT 1
9430: DEC
9431: ST_TO_ADDR
9432: LD_INT 3
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9459
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9438: LD_INT 5
9440: PPUSH
9441: LD_INT 133
9443: PPUSH
9444: LD_INT 19
9446: PPUSH
9447: LD_INT 3
9449: PPUSH
9450: LD_INT 0
9452: PPUSH
9453: CALL_OW 56
9457: GO 9435
9459: POP
9460: POP
// end ; end_of_file
9461: LD_VAR 0 1
9465: RET
// export function Action ; begin
9466: LD_INT 0
9468: PPUSH
// InGameOn ;
9469: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9473: LD_INT 133
9475: PPUSH
9476: LD_INT 19
9478: PPUSH
9479: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9483: LD_EXP 20
9487: PPUSH
9488: LD_STRING WT-DS-1
9490: PPUSH
9491: CALL_OW 88
// InGameOff ;
9495: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9499: LD_STRING DestroyEnemy
9501: PPUSH
9502: CALL_OW 337
// wait ( 0 0$20 ) ;
9506: LD_INT 700
9508: PPUSH
9509: CALL_OW 67
// DialogueOn ;
9513: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9517: LD_INT 100
9519: PPUSH
9520: LD_INT 37
9522: PPUSH
9523: LD_INT 1
9525: PPUSH
9526: LD_INT 30
9528: NEG
9529: PPUSH
9530: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9534: LD_INT 100
9536: PPUSH
9537: LD_INT 37
9539: PPUSH
9540: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9544: LD_EXP 10
9548: PPUSH
9549: LD_STRING WT-PL-1
9551: PPUSH
9552: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9556: LD_EXP 20
9560: PPUSH
9561: LD_STRING WT-DS-2
9563: PPUSH
9564: CALL_OW 88
// DialogueOff ;
9568: CALL_OW 7
// wait ( 0 0$2 ) ;
9572: LD_INT 70
9574: PPUSH
9575: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9579: LD_INT 100
9581: PPUSH
9582: LD_INT 37
9584: PPUSH
9585: LD_INT 1
9587: PPUSH
9588: CALL_OW 331
// end ;
9592: LD_VAR 0 1
9596: RET
// export function DialogPowellsAttack ; begin
9597: LD_INT 0
9599: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9600: LD_EXP 10
9604: PPUSH
9605: LD_STRING WT-PL-8
9607: PPUSH
9608: CALL_OW 94
// end ;
9612: LD_VAR 0 1
9616: RET
// export function DialogContaminateSib ( x , y ) ; begin
9617: LD_INT 0
9619: PPUSH
// DialogueOn ;
9620: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9624: LD_VAR 0 1
9628: PPUSH
9629: LD_VAR 0 2
9633: PPUSH
9634: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9638: LD_EXP 20
9642: PPUSH
9643: LD_STRING WT-DS-3
9645: PPUSH
9646: CALL_OW 88
// DialogueOff ;
9650: CALL_OW 7
// end ;
9654: LD_VAR 0 3
9658: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9659: LD_EXP 8
9663: NOT
9664: PUSH
9665: LD_INT 1
9667: PPUSH
9668: LD_INT 81
9670: PUSH
9671: LD_INT 4
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: PPUSH
9678: CALL_OW 70
9682: PUSH
9683: LD_INT 3
9685: GREATER
9686: AND
9687: IFFALSE 9759
9689: GO 9691
9691: DISABLE
// begin powellInTrouble := true ;
9692: LD_ADDR_EXP 8
9696: PUSH
9697: LD_INT 1
9699: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9700: LD_EXP 20
9704: PPUSH
9705: LD_STRING WT-DS-6
9707: PPUSH
9708: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9712: LD_INT 1
9714: PPUSH
9715: LD_INT 22
9717: PUSH
9718: LD_INT 1
9720: PUSH
9721: EMPTY
9722: LIST
9723: LIST
9724: PPUSH
9725: CALL_OW 70
9729: NOT
9730: IFFALSE 9744
// SayRadio ( Powell , WT-PL-6 ) ;
9732: LD_EXP 10
9736: PPUSH
9737: LD_STRING WT-PL-6
9739: PPUSH
9740: CALL_OW 94
// wait ( 1 1$30 ) ;
9744: LD_INT 3150
9746: PPUSH
9747: CALL_OW 67
// powellInTrouble := false ;
9751: LD_ADDR_EXP 8
9755: PUSH
9756: LD_INT 0
9758: ST_TO_ADDR
// end ;
9759: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9760: LD_EXP 9
9764: NOT
9765: PUSH
9766: LD_INT 16
9768: PPUSH
9769: LD_INT 81
9771: PUSH
9772: LD_INT 1
9774: PUSH
9775: EMPTY
9776: LIST
9777: LIST
9778: PPUSH
9779: CALL_OW 70
9783: PUSH
9784: LD_INT 6
9786: GREATER
9787: AND
9788: IFFALSE 9861
9790: GO 9792
9792: DISABLE
// begin sikorskiInTrouble := true ;
9793: LD_ADDR_EXP 9
9797: PUSH
9798: LD_INT 1
9800: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9801: LD_EXP 20
9805: PPUSH
9806: LD_STRING WT-DS-7
9808: PPUSH
9809: CALL_OW 88
// if not powellAttackGroup then
9813: LD_EXP 12
9817: NOT
9818: IFFALSE 9834
// SayRadio ( Powell , WT-PL-7n ) else
9820: LD_EXP 10
9824: PPUSH
9825: LD_STRING WT-PL-7n
9827: PPUSH
9828: CALL_OW 94
9832: GO 9846
// SayRadio ( Powell , WT-PL-7y ) ;
9834: LD_EXP 10
9838: PPUSH
9839: LD_STRING WT-PL-7y
9841: PPUSH
9842: CALL_OW 94
// wait ( 1 1$30 ) ;
9846: LD_INT 3150
9848: PPUSH
9849: CALL_OW 67
// sikorskiInTrouble := false ;
9853: LD_ADDR_EXP 9
9857: PUSH
9858: LD_INT 0
9860: ST_TO_ADDR
// end ;
9861: END
// export function DialogPowellsAttackFailed ; begin
9862: LD_INT 0
9864: PPUSH
// if not ruDestroyed then
9865: LD_EXP 5
9869: NOT
9870: IFFALSE 9886
// SayRadio ( Powell , WT-PL-9 ) else
9872: LD_EXP 10
9876: PPUSH
9877: LD_STRING WT-PL-9
9879: PPUSH
9880: CALL_OW 94
9884: GO 9898
// SayRadio ( Powell , WT-PL-10 ) ;
9886: LD_EXP 10
9890: PPUSH
9891: LD_STRING WT-PL-10
9893: PPUSH
9894: CALL_OW 94
// end ;
9898: LD_VAR 0 1
9902: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
9903: LD_INT 22
9905: PUSH
9906: LD_INT 2
9908: PUSH
9909: EMPTY
9910: LIST
9911: LIST
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 1
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: EMPTY
9924: LIST
9925: LIST
9926: PPUSH
9927: CALL_OW 69
9931: PUSH
9932: LD_INT 0
9934: EQUAL
9935: IFFALSE 9979
9937: GO 9939
9939: DISABLE
// begin arDestroyed := true ;
9940: LD_ADDR_EXP 4
9944: PUSH
9945: LD_INT 1
9947: ST_TO_ADDR
// MC_Kill ( 2 ) ;
9948: LD_INT 2
9950: PPUSH
9951: CALL 50801 0 1
// Say ( Sikorski , WT-DS-4 ) ;
9955: LD_EXP 20
9959: PPUSH
9960: LD_STRING WT-DS-4
9962: PPUSH
9963: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
9967: LD_EXP 10
9971: PPUSH
9972: LD_STRING WT-PL-4
9974: PPUSH
9975: CALL_OW 94
// end ;
9979: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
9980: LD_INT 22
9982: PUSH
9983: LD_INT 3
9985: PUSH
9986: EMPTY
9987: LIST
9988: LIST
9989: PUSH
9990: LD_INT 21
9992: PUSH
9993: LD_INT 1
9995: PUSH
9996: EMPTY
9997: LIST
9998: LIST
9999: PUSH
10000: EMPTY
10001: LIST
10002: LIST
10003: PPUSH
10004: CALL_OW 69
10008: PUSH
10009: LD_INT 0
10011: EQUAL
10012: IFFALSE 10056
10014: GO 10016
10016: DISABLE
// begin ruDestroyed := true ;
10017: LD_ADDR_EXP 5
10021: PUSH
10022: LD_INT 1
10024: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10025: LD_INT 3
10027: PPUSH
10028: CALL 50801 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10032: LD_EXP 20
10036: PPUSH
10037: LD_STRING WT-DS-5
10039: PPUSH
10040: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10044: LD_EXP 10
10048: PPUSH
10049: LD_STRING WT-PL-5
10051: PPUSH
10052: CALL_OW 94
// end ;
10056: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10057: LD_EXP 5
10061: PUSH
10062: LD_EXP 4
10066: AND
10067: IFFALSE 10240
10069: GO 10071
10071: DISABLE
// begin wait ( 0 0$3 ) ;
10072: LD_INT 105
10074: PPUSH
10075: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10079: LD_OWVAR 1
10083: PUSH
10084: LD_INT 126000
10086: PUSH
10087: LD_INT 105000
10089: PUSH
10090: LD_INT 94500
10092: PUSH
10093: EMPTY
10094: LIST
10095: LIST
10096: LIST
10097: PUSH
10098: LD_OWVAR 67
10102: ARRAY
10103: GREATEREQUAL
10104: IFFALSE 10119
// AddMedal ( WoT-med-1 , - 1 ) else
10106: LD_STRING WoT-med-1
10108: PPUSH
10109: LD_INT 1
10111: NEG
10112: PPUSH
10113: CALL_OW 101
10117: GO 10129
// AddMedal ( WoT-med-1 , 1 ) ;
10119: LD_STRING WoT-med-1
10121: PPUSH
10122: LD_INT 1
10124: PPUSH
10125: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10129: LD_EXP 6
10133: PUSH
10134: LD_INT 4
10136: PUSH
10137: LD_INT 3
10139: PUSH
10140: LD_INT 2
10142: PUSH
10143: EMPTY
10144: LIST
10145: LIST
10146: LIST
10147: PUSH
10148: LD_OWVAR 67
10152: ARRAY
10153: GREATEREQUAL
10154: IFFALSE 10169
// AddMedal ( WoT-med-2 , - 1 ) else
10156: LD_STRING WoT-med-2
10158: PPUSH
10159: LD_INT 1
10161: NEG
10162: PPUSH
10163: CALL_OW 101
10167: GO 10179
// AddMedal ( WoT-med-2 , 1 ) ;
10169: LD_STRING WoT-med-2
10171: PPUSH
10172: LD_INT 1
10174: PPUSH
10175: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10179: LD_EXP 7
10183: PUSH
10184: LD_INT 8
10186: PUSH
10187: LD_INT 6
10189: PUSH
10190: LD_INT 5
10192: PUSH
10193: EMPTY
10194: LIST
10195: LIST
10196: LIST
10197: PUSH
10198: LD_OWVAR 67
10202: ARRAY
10203: GREATEREQUAL
10204: IFFALSE 10219
// AddMedal ( WoT-med-3 , - 1 ) else
10206: LD_STRING WoT-med-3
10208: PPUSH
10209: LD_INT 1
10211: NEG
10212: PPUSH
10213: CALL_OW 101
10217: GO 10229
// AddMedal ( WoT-med-3 , 1 ) ;
10219: LD_STRING WoT-med-3
10221: PPUSH
10222: LD_INT 1
10224: PPUSH
10225: CALL_OW 101
// GiveMedals ( MAIN ) ;
10229: LD_STRING MAIN
10231: PPUSH
10232: CALL_OW 102
// YouWin ;
10236: CALL_OW 103
// end ; end_of_file
10240: END
// export function CustomEvent ( event ) ; begin
10241: LD_INT 0
10243: PPUSH
// end ;
10244: LD_VAR 0 2
10248: RET
// on Command ( com ) do var i , j , temp ;
10249: LD_INT 0
10251: PPUSH
10252: PPUSH
10253: PPUSH
// begin if com = 60 then
10254: LD_VAR 0 1
10258: PUSH
10259: LD_INT 60
10261: EQUAL
10262: IFFALSE 10441
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10264: LD_ADDR_VAR 0 2
10268: PUSH
10269: LD_INT 22
10271: PUSH
10272: LD_INT 1
10274: PUSH
10275: EMPTY
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 2
10281: PUSH
10282: LD_INT 21
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: LIST
10291: PUSH
10292: LD_INT 34
10294: PUSH
10295: LD_INT 12
10297: PUSH
10298: EMPTY
10299: LIST
10300: LIST
10301: PUSH
10302: EMPTY
10303: LIST
10304: LIST
10305: LIST
10306: PUSH
10307: EMPTY
10308: LIST
10309: LIST
10310: PPUSH
10311: CALL_OW 69
10315: PUSH
10316: FOR_IN
10317: IFFALSE 10439
// begin if GetTaskList ( i ) > 0 then
10319: LD_VAR 0 2
10323: PPUSH
10324: CALL_OW 437
10328: PUSH
10329: LD_INT 0
10331: GREATER
10332: IFFALSE 10437
// for j = 1 to GetTaskList ( i ) do
10334: LD_ADDR_VAR 0 3
10338: PUSH
10339: DOUBLE
10340: LD_INT 1
10342: DEC
10343: ST_TO_ADDR
10344: LD_VAR 0 2
10348: PPUSH
10349: CALL_OW 437
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10435
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10357: LD_ADDR_VAR 0 4
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: CALL_OW 437
10371: PUSH
10372: LD_VAR 0 3
10376: ARRAY
10377: PUSH
10378: LD_INT 4
10380: ARRAY
10381: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10382: LD_VAR 0 4
10386: PPUSH
10387: CALL_OW 255
10391: PUSH
10392: LD_INT 4
10394: EQUAL
10395: PUSH
10396: LD_VAR 0 2
10400: PPUSH
10401: CALL_OW 437
10405: PUSH
10406: LD_VAR 0 3
10410: ARRAY
10411: PUSH
10412: LD_INT 1
10414: ARRAY
10415: PUSH
10416: LD_STRING <
10418: EQUAL
10419: AND
10420: IFFALSE 10433
// SetTaskList ( i , [ ] ) ;
10422: LD_VAR 0 2
10426: PPUSH
10427: EMPTY
10428: PPUSH
10429: CALL_OW 446
// end ;
10433: GO 10354
10435: POP
10436: POP
// end ;
10437: GO 10316
10439: POP
10440: POP
// end ; end ;
10441: PPOPN 4
10443: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10444: LD_VAR 0 2
10448: PPUSH
10449: LD_VAR 0 3
10453: PPUSH
10454: CALL_OW 428
10458: PPUSH
10459: CALL_OW 255
10463: PUSH
10464: LD_INT 1
10466: EQUAL
10467: PUSH
10468: LD_VAR 0 2
10472: PUSH
10473: LD_INT 132
10475: EQUAL
10476: PUSH
10477: LD_VAR 0 3
10481: PUSH
10482: LD_INT 39
10484: EQUAL
10485: AND
10486: OR
10487: IFFALSE 10503
// DialogContaminateSib ( x , y ) ;
10489: LD_VAR 0 2
10493: PPUSH
10494: LD_VAR 0 3
10498: PPUSH
10499: CALL 9617 0 2
// end ;
10503: PPOPN 3
10505: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
10506: LD_VAR 0 1
10510: PPUSH
10511: CALL 78199 0 1
// if un = Powell then
10515: LD_VAR 0 1
10519: PUSH
10520: LD_EXP 10
10524: EQUAL
10525: IFFALSE 10534
// YouLost ( Powell ) ;
10527: LD_STRING Powell
10529: PPUSH
10530: CALL_OW 104
// if un = Sikorski then
10534: LD_VAR 0 1
10538: PUSH
10539: LD_EXP 20
10543: EQUAL
10544: IFFALSE 10553
// YouLost ( Sikorski ) ;
10546: LD_STRING Sikorski
10548: PPUSH
10549: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10553: LD_VAR 0 1
10557: PUSH
10558: LD_INT 22
10560: PUSH
10561: LD_INT 1
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: PUSH
10568: LD_INT 21
10570: PUSH
10571: LD_INT 1
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PUSH
10578: EMPTY
10579: LIST
10580: LIST
10581: PPUSH
10582: CALL_OW 69
10586: IN
10587: IFFALSE 10603
// loseCounter := loseCounter + 1 ;
10589: LD_ADDR_EXP 6
10593: PUSH
10594: LD_EXP 6
10598: PUSH
10599: LD_INT 1
10601: PLUS
10602: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10603: LD_VAR 0 1
10607: PUSH
10608: LD_INT 22
10610: PUSH
10611: LD_INT 4
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: LD_INT 21
10620: PUSH
10621: LD_INT 1
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PPUSH
10632: CALL_OW 69
10636: IN
10637: IFFALSE 10653
// powellLoseCounter := powellLoseCounter + 1 ;
10639: LD_ADDR_EXP 7
10643: PUSH
10644: LD_EXP 7
10648: PUSH
10649: LD_INT 1
10651: PLUS
10652: ST_TO_ADDR
// if un in powellAttackGroup then
10653: LD_VAR 0 1
10657: PUSH
10658: LD_EXP 12
10662: IN
10663: IFFALSE 10681
// powellAttackGroup := powellAttackGroup diff un ;
10665: LD_ADDR_EXP 12
10669: PUSH
10670: LD_EXP 12
10674: PUSH
10675: LD_VAR 0 1
10679: DIFF
10680: ST_TO_ADDR
// if un in gensherAttackGroup then
10681: LD_VAR 0 1
10685: PUSH
10686: LD_EXP 15
10690: IN
10691: IFFALSE 10709
// gensherAttackGroup := gensherAttackGroup diff un ;
10693: LD_ADDR_EXP 15
10697: PUSH
10698: LD_EXP 15
10702: PUSH
10703: LD_VAR 0 1
10707: DIFF
10708: ST_TO_ADDR
// if un in popovAttackGroup then
10709: LD_VAR 0 1
10713: PUSH
10714: LD_EXP 19
10718: IN
10719: IFFALSE 10737
// popovAttackGroup := popovAttackGroup diff un ;
10721: LD_ADDR_EXP 19
10725: PUSH
10726: LD_EXP 19
10730: PUSH
10731: LD_VAR 0 1
10735: DIFF
10736: ST_TO_ADDR
// end ;
10737: PPOPN 1
10739: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_VAR 0 2
10749: PPUSH
10750: CALL 80533 0 2
// end ;
10754: PPOPN 2
10756: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10757: LD_VAR 0 1
10761: PPUSH
10762: CALL 79601 0 1
// end ;
10766: PPOPN 1
10768: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10769: LD_VAR 0 1
10773: PPUSH
10774: CALL 79842 0 1
// end ;
10778: PPOPN 1
10780: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10781: LD_VAR 0 1
10785: PPUSH
10786: LD_VAR 0 2
10790: PPUSH
10791: CALL 77895 0 2
// end ;
10795: PPOPN 2
10797: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10798: LD_VAR 0 1
10802: PPUSH
10803: LD_VAR 0 2
10807: PPUSH
10808: LD_VAR 0 3
10812: PPUSH
10813: LD_VAR 0 4
10817: PPUSH
10818: LD_VAR 0 5
10822: PPUSH
10823: CALL 77515 0 5
// end ;
10827: PPOPN 5
10829: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
10830: LD_VAR 0 1
10834: PPUSH
10835: LD_VAR 0 2
10839: PPUSH
10840: CALL 77096 0 2
// end ;
10844: PPOPN 2
10846: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10847: LD_VAR 0 1
10851: PPUSH
10852: LD_VAR 0 2
10856: PPUSH
10857: LD_VAR 0 3
10861: PPUSH
10862: LD_VAR 0 4
10866: PPUSH
10867: CALL 76934 0 4
// end ;
10871: PPOPN 4
10873: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
10874: LD_VAR 0 1
10878: PPUSH
10879: LD_VAR 0 2
10883: PPUSH
10884: LD_VAR 0 3
10888: PPUSH
10889: CALL 76709 0 3
// end ;
10893: PPOPN 3
10895: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: LD_VAR 0 2
10905: PPUSH
10906: CALL 76594 0 2
// end ;
10910: PPOPN 2
10912: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
10913: LD_VAR 0 1
10917: PPUSH
10918: LD_VAR 0 2
10922: PPUSH
10923: CALL 80828 0 2
// end ;
10927: PPOPN 2
10929: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
10930: LD_VAR 0 1
10934: PPUSH
10935: LD_VAR 0 2
10939: PPUSH
10940: LD_VAR 0 3
10944: PPUSH
10945: LD_VAR 0 4
10949: PPUSH
10950: CALL 81044 0 4
// end ;
10954: PPOPN 4
10956: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 76403 0 2
// end ;
10971: PPOPN 2
10973: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
10974: LD_VAR 0 1
10978: PUSH
10979: LD_INT 1
10981: EQUAL
10982: PUSH
10983: LD_VAR 0 2
10987: PUSH
10988: LD_INT 4
10990: EQUAL
10991: AND
10992: IFFALSE 11001
// YouLost ( FriendlyFire ) ;
10994: LD_STRING FriendlyFire
10996: PPUSH
10997: CALL_OW 104
// end ; end_of_file
11001: PPOPN 2
11003: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11004: LD_INT 0
11006: PPUSH
11007: PPUSH
// if exist_mode then
11008: LD_VAR 0 2
11012: IFFALSE 11037
// unit := CreateCharacter ( prefix & ident ) else
11014: LD_ADDR_VAR 0 5
11018: PUSH
11019: LD_VAR 0 3
11023: PUSH
11024: LD_VAR 0 1
11028: STR
11029: PPUSH
11030: CALL_OW 34
11034: ST_TO_ADDR
11035: GO 11052
// unit := NewCharacter ( ident ) ;
11037: LD_ADDR_VAR 0 5
11041: PUSH
11042: LD_VAR 0 1
11046: PPUSH
11047: CALL_OW 25
11051: ST_TO_ADDR
// result := unit ;
11052: LD_ADDR_VAR 0 4
11056: PUSH
11057: LD_VAR 0 5
11061: ST_TO_ADDR
// end ;
11062: LD_VAR 0 4
11066: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11067: LD_INT 0
11069: PPUSH
11070: PPUSH
// if not side or not nation then
11071: LD_VAR 0 1
11075: NOT
11076: PUSH
11077: LD_VAR 0 2
11081: NOT
11082: OR
11083: IFFALSE 11087
// exit ;
11085: GO 11855
// case nation of nation_american :
11087: LD_VAR 0 2
11091: PUSH
11092: LD_INT 1
11094: DOUBLE
11095: EQUAL
11096: IFTRUE 11100
11098: GO 11314
11100: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
11101: LD_ADDR_VAR 0 4
11105: PUSH
11106: LD_INT 35
11108: PUSH
11109: LD_INT 45
11111: PUSH
11112: LD_INT 46
11114: PUSH
11115: LD_INT 47
11117: PUSH
11118: LD_INT 82
11120: PUSH
11121: LD_INT 83
11123: PUSH
11124: LD_INT 84
11126: PUSH
11127: LD_INT 85
11129: PUSH
11130: LD_INT 86
11132: PUSH
11133: LD_INT 1
11135: PUSH
11136: LD_INT 2
11138: PUSH
11139: LD_INT 6
11141: PUSH
11142: LD_INT 15
11144: PUSH
11145: LD_INT 16
11147: PUSH
11148: LD_INT 7
11150: PUSH
11151: LD_INT 12
11153: PUSH
11154: LD_INT 13
11156: PUSH
11157: LD_INT 10
11159: PUSH
11160: LD_INT 14
11162: PUSH
11163: LD_INT 20
11165: PUSH
11166: LD_INT 21
11168: PUSH
11169: LD_INT 22
11171: PUSH
11172: LD_INT 25
11174: PUSH
11175: LD_INT 32
11177: PUSH
11178: LD_INT 27
11180: PUSH
11181: LD_INT 36
11183: PUSH
11184: LD_INT 69
11186: PUSH
11187: LD_INT 39
11189: PUSH
11190: LD_INT 34
11192: PUSH
11193: LD_INT 40
11195: PUSH
11196: LD_INT 48
11198: PUSH
11199: LD_INT 49
11201: PUSH
11202: LD_INT 50
11204: PUSH
11205: LD_INT 51
11207: PUSH
11208: LD_INT 52
11210: PUSH
11211: LD_INT 53
11213: PUSH
11214: LD_INT 54
11216: PUSH
11217: LD_INT 55
11219: PUSH
11220: LD_INT 56
11222: PUSH
11223: LD_INT 57
11225: PUSH
11226: LD_INT 58
11228: PUSH
11229: LD_INT 59
11231: PUSH
11232: LD_INT 60
11234: PUSH
11235: LD_INT 61
11237: PUSH
11238: LD_INT 62
11240: PUSH
11241: LD_INT 80
11243: PUSH
11244: LD_INT 82
11246: PUSH
11247: LD_INT 83
11249: PUSH
11250: LD_INT 84
11252: PUSH
11253: LD_INT 85
11255: PUSH
11256: LD_INT 86
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: LIST
11263: LIST
11264: LIST
11265: LIST
11266: LIST
11267: LIST
11268: LIST
11269: LIST
11270: LIST
11271: LIST
11272: LIST
11273: LIST
11274: LIST
11275: LIST
11276: LIST
11277: LIST
11278: LIST
11279: LIST
11280: LIST
11281: LIST
11282: LIST
11283: LIST
11284: LIST
11285: LIST
11286: LIST
11287: LIST
11288: LIST
11289: LIST
11290: LIST
11291: LIST
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: LIST
11311: ST_TO_ADDR
11312: GO 11779
11314: LD_INT 2
11316: DOUBLE
11317: EQUAL
11318: IFTRUE 11322
11320: GO 11548
11322: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
11323: LD_ADDR_VAR 0 4
11327: PUSH
11328: LD_INT 35
11330: PUSH
11331: LD_INT 45
11333: PUSH
11334: LD_INT 46
11336: PUSH
11337: LD_INT 47
11339: PUSH
11340: LD_INT 82
11342: PUSH
11343: LD_INT 83
11345: PUSH
11346: LD_INT 84
11348: PUSH
11349: LD_INT 85
11351: PUSH
11352: LD_INT 87
11354: PUSH
11355: LD_INT 70
11357: PUSH
11358: LD_INT 1
11360: PUSH
11361: LD_INT 11
11363: PUSH
11364: LD_INT 3
11366: PUSH
11367: LD_INT 4
11369: PUSH
11370: LD_INT 5
11372: PUSH
11373: LD_INT 6
11375: PUSH
11376: LD_INT 15
11378: PUSH
11379: LD_INT 18
11381: PUSH
11382: LD_INT 7
11384: PUSH
11385: LD_INT 17
11387: PUSH
11388: LD_INT 8
11390: PUSH
11391: LD_INT 20
11393: PUSH
11394: LD_INT 21
11396: PUSH
11397: LD_INT 22
11399: PUSH
11400: LD_INT 72
11402: PUSH
11403: LD_INT 26
11405: PUSH
11406: LD_INT 69
11408: PUSH
11409: LD_INT 39
11411: PUSH
11412: LD_INT 40
11414: PUSH
11415: LD_INT 41
11417: PUSH
11418: LD_INT 42
11420: PUSH
11421: LD_INT 43
11423: PUSH
11424: LD_INT 48
11426: PUSH
11427: LD_INT 49
11429: PUSH
11430: LD_INT 50
11432: PUSH
11433: LD_INT 51
11435: PUSH
11436: LD_INT 52
11438: PUSH
11439: LD_INT 53
11441: PUSH
11442: LD_INT 54
11444: PUSH
11445: LD_INT 55
11447: PUSH
11448: LD_INT 56
11450: PUSH
11451: LD_INT 60
11453: PUSH
11454: LD_INT 61
11456: PUSH
11457: LD_INT 62
11459: PUSH
11460: LD_INT 66
11462: PUSH
11463: LD_INT 67
11465: PUSH
11466: LD_INT 68
11468: PUSH
11469: LD_INT 81
11471: PUSH
11472: LD_INT 82
11474: PUSH
11475: LD_INT 83
11477: PUSH
11478: LD_INT 84
11480: PUSH
11481: LD_INT 85
11483: PUSH
11484: LD_INT 87
11486: PUSH
11487: LD_INT 88
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: ST_TO_ADDR
11546: GO 11779
11548: LD_INT 3
11550: DOUBLE
11551: EQUAL
11552: IFTRUE 11556
11554: GO 11778
11556: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
11557: LD_ADDR_VAR 0 4
11561: PUSH
11562: LD_INT 46
11564: PUSH
11565: LD_INT 47
11567: PUSH
11568: LD_INT 1
11570: PUSH
11571: LD_INT 2
11573: PUSH
11574: LD_INT 82
11576: PUSH
11577: LD_INT 83
11579: PUSH
11580: LD_INT 84
11582: PUSH
11583: LD_INT 85
11585: PUSH
11586: LD_INT 86
11588: PUSH
11589: LD_INT 11
11591: PUSH
11592: LD_INT 9
11594: PUSH
11595: LD_INT 20
11597: PUSH
11598: LD_INT 19
11600: PUSH
11601: LD_INT 21
11603: PUSH
11604: LD_INT 24
11606: PUSH
11607: LD_INT 22
11609: PUSH
11610: LD_INT 25
11612: PUSH
11613: LD_INT 28
11615: PUSH
11616: LD_INT 29
11618: PUSH
11619: LD_INT 30
11621: PUSH
11622: LD_INT 31
11624: PUSH
11625: LD_INT 37
11627: PUSH
11628: LD_INT 38
11630: PUSH
11631: LD_INT 32
11633: PUSH
11634: LD_INT 27
11636: PUSH
11637: LD_INT 33
11639: PUSH
11640: LD_INT 69
11642: PUSH
11643: LD_INT 39
11645: PUSH
11646: LD_INT 34
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 71
11654: PUSH
11655: LD_INT 23
11657: PUSH
11658: LD_INT 44
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 57
11690: PUSH
11691: LD_INT 58
11693: PUSH
11694: LD_INT 59
11696: PUSH
11697: LD_INT 63
11699: PUSH
11700: LD_INT 64
11702: PUSH
11703: LD_INT 65
11705: PUSH
11706: LD_INT 82
11708: PUSH
11709: LD_INT 83
11711: PUSH
11712: LD_INT 84
11714: PUSH
11715: LD_INT 85
11717: PUSH
11718: LD_INT 86
11720: PUSH
11721: EMPTY
11722: LIST
11723: LIST
11724: LIST
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: LIST
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: ST_TO_ADDR
11776: GO 11779
11778: POP
// if state > - 1 and state < 3 then
11779: LD_VAR 0 3
11783: PUSH
11784: LD_INT 1
11786: NEG
11787: GREATER
11788: PUSH
11789: LD_VAR 0 3
11793: PUSH
11794: LD_INT 3
11796: LESS
11797: AND
11798: IFFALSE 11855
// for i in result do
11800: LD_ADDR_VAR 0 5
11804: PUSH
11805: LD_VAR 0 4
11809: PUSH
11810: FOR_IN
11811: IFFALSE 11853
// if GetTech ( i , side ) <> state then
11813: LD_VAR 0 5
11817: PPUSH
11818: LD_VAR 0 1
11822: PPUSH
11823: CALL_OW 321
11827: PUSH
11828: LD_VAR 0 3
11832: NONEQUAL
11833: IFFALSE 11851
// result := result diff i ;
11835: LD_ADDR_VAR 0 4
11839: PUSH
11840: LD_VAR 0 4
11844: PUSH
11845: LD_VAR 0 5
11849: DIFF
11850: ST_TO_ADDR
11851: GO 11810
11853: POP
11854: POP
// end ;
11855: LD_VAR 0 4
11859: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
11860: LD_INT 0
11862: PPUSH
11863: PPUSH
11864: PPUSH
// result := true ;
11865: LD_ADDR_VAR 0 3
11869: PUSH
11870: LD_INT 1
11872: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
11873: LD_ADDR_VAR 0 5
11877: PUSH
11878: LD_VAR 0 2
11882: PPUSH
11883: CALL_OW 480
11887: ST_TO_ADDR
// if not tmp then
11888: LD_VAR 0 5
11892: NOT
11893: IFFALSE 11897
// exit ;
11895: GO 11946
// for i in tmp do
11897: LD_ADDR_VAR 0 4
11901: PUSH
11902: LD_VAR 0 5
11906: PUSH
11907: FOR_IN
11908: IFFALSE 11944
// if GetTech ( i , side ) <> state_researched then
11910: LD_VAR 0 4
11914: PPUSH
11915: LD_VAR 0 1
11919: PPUSH
11920: CALL_OW 321
11924: PUSH
11925: LD_INT 2
11927: NONEQUAL
11928: IFFALSE 11942
// begin result := false ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_INT 0
11937: ST_TO_ADDR
// exit ;
11938: POP
11939: POP
11940: GO 11946
// end ;
11942: GO 11907
11944: POP
11945: POP
// end ;
11946: LD_VAR 0 3
11950: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
11951: LD_INT 0
11953: PPUSH
11954: PPUSH
11955: PPUSH
11956: PPUSH
11957: PPUSH
11958: PPUSH
11959: PPUSH
11960: PPUSH
11961: PPUSH
11962: PPUSH
11963: PPUSH
11964: PPUSH
11965: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
11966: LD_VAR 0 1
11970: NOT
11971: PUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 257
11981: PUSH
11982: LD_INT 9
11984: NONEQUAL
11985: OR
11986: IFFALSE 11990
// exit ;
11988: GO 12563
// side := GetSide ( unit ) ;
11990: LD_ADDR_VAR 0 9
11994: PUSH
11995: LD_VAR 0 1
11999: PPUSH
12000: CALL_OW 255
12004: ST_TO_ADDR
// tech_space := tech_spacanom ;
12005: LD_ADDR_VAR 0 12
12009: PUSH
12010: LD_INT 29
12012: ST_TO_ADDR
// tech_time := tech_taurad ;
12013: LD_ADDR_VAR 0 13
12017: PUSH
12018: LD_INT 28
12020: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12021: LD_ADDR_VAR 0 11
12025: PUSH
12026: LD_VAR 0 1
12030: PPUSH
12031: CALL_OW 310
12035: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12036: LD_VAR 0 11
12040: PPUSH
12041: CALL_OW 247
12045: PUSH
12046: LD_INT 2
12048: EQUAL
12049: IFFALSE 12053
// exit ;
12051: GO 12563
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12053: LD_ADDR_VAR 0 8
12057: PUSH
12058: LD_INT 81
12060: PUSH
12061: LD_VAR 0 9
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 3
12072: PUSH
12073: LD_INT 21
12075: PUSH
12076: LD_INT 3
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: EMPTY
12084: LIST
12085: LIST
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PPUSH
12091: CALL_OW 69
12095: ST_TO_ADDR
// if not tmp then
12096: LD_VAR 0 8
12100: NOT
12101: IFFALSE 12105
// exit ;
12103: GO 12563
// if in_unit then
12105: LD_VAR 0 11
12109: IFFALSE 12133
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12111: LD_ADDR_VAR 0 10
12115: PUSH
12116: LD_VAR 0 8
12120: PPUSH
12121: LD_VAR 0 11
12125: PPUSH
12126: CALL_OW 74
12130: ST_TO_ADDR
12131: GO 12153
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12133: LD_ADDR_VAR 0 10
12137: PUSH
12138: LD_VAR 0 8
12142: PPUSH
12143: LD_VAR 0 1
12147: PPUSH
12148: CALL_OW 74
12152: ST_TO_ADDR
// if not enemy then
12153: LD_VAR 0 10
12157: NOT
12158: IFFALSE 12162
// exit ;
12160: GO 12563
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12162: LD_VAR 0 11
12166: PUSH
12167: LD_VAR 0 11
12171: PPUSH
12172: LD_VAR 0 10
12176: PPUSH
12177: CALL_OW 296
12181: PUSH
12182: LD_INT 13
12184: GREATER
12185: AND
12186: PUSH
12187: LD_VAR 0 1
12191: PPUSH
12192: LD_VAR 0 10
12196: PPUSH
12197: CALL_OW 296
12201: PUSH
12202: LD_INT 12
12204: GREATER
12205: OR
12206: IFFALSE 12210
// exit ;
12208: GO 12563
// missile := [ 1 ] ;
12210: LD_ADDR_VAR 0 14
12214: PUSH
12215: LD_INT 1
12217: PUSH
12218: EMPTY
12219: LIST
12220: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12221: LD_VAR 0 9
12225: PPUSH
12226: LD_VAR 0 12
12230: PPUSH
12231: CALL_OW 325
12235: IFFALSE 12264
// missile := Insert ( missile , missile + 1 , 2 ) ;
12237: LD_ADDR_VAR 0 14
12241: PUSH
12242: LD_VAR 0 14
12246: PPUSH
12247: LD_VAR 0 14
12251: PUSH
12252: LD_INT 1
12254: PLUS
12255: PPUSH
12256: LD_INT 2
12258: PPUSH
12259: CALL_OW 2
12263: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12264: LD_VAR 0 9
12268: PPUSH
12269: LD_VAR 0 13
12273: PPUSH
12274: CALL_OW 325
12278: PUSH
12279: LD_VAR 0 10
12283: PPUSH
12284: CALL_OW 255
12288: PPUSH
12289: LD_VAR 0 13
12293: PPUSH
12294: CALL_OW 325
12298: NOT
12299: AND
12300: IFFALSE 12329
// missile := Insert ( missile , missile + 1 , 3 ) ;
12302: LD_ADDR_VAR 0 14
12306: PUSH
12307: LD_VAR 0 14
12311: PPUSH
12312: LD_VAR 0 14
12316: PUSH
12317: LD_INT 1
12319: PLUS
12320: PPUSH
12321: LD_INT 3
12323: PPUSH
12324: CALL_OW 2
12328: ST_TO_ADDR
// if missile < 2 then
12329: LD_VAR 0 14
12333: PUSH
12334: LD_INT 2
12336: LESS
12337: IFFALSE 12341
// exit ;
12339: GO 12563
// x := GetX ( enemy ) ;
12341: LD_ADDR_VAR 0 4
12345: PUSH
12346: LD_VAR 0 10
12350: PPUSH
12351: CALL_OW 250
12355: ST_TO_ADDR
// y := GetY ( enemy ) ;
12356: LD_ADDR_VAR 0 5
12360: PUSH
12361: LD_VAR 0 10
12365: PPUSH
12366: CALL_OW 251
12370: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12371: LD_ADDR_VAR 0 6
12375: PUSH
12376: LD_VAR 0 4
12380: PUSH
12381: LD_INT 1
12383: NEG
12384: PPUSH
12385: LD_INT 1
12387: PPUSH
12388: CALL_OW 12
12392: PLUS
12393: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12394: LD_ADDR_VAR 0 7
12398: PUSH
12399: LD_VAR 0 5
12403: PUSH
12404: LD_INT 1
12406: NEG
12407: PPUSH
12408: LD_INT 1
12410: PPUSH
12411: CALL_OW 12
12415: PLUS
12416: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12417: LD_VAR 0 6
12421: PPUSH
12422: LD_VAR 0 7
12426: PPUSH
12427: CALL_OW 488
12431: NOT
12432: IFFALSE 12454
// begin _x := x ;
12434: LD_ADDR_VAR 0 6
12438: PUSH
12439: LD_VAR 0 4
12443: ST_TO_ADDR
// _y := y ;
12444: LD_ADDR_VAR 0 7
12448: PUSH
12449: LD_VAR 0 5
12453: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12454: LD_ADDR_VAR 0 3
12458: PUSH
12459: LD_INT 1
12461: PPUSH
12462: LD_VAR 0 14
12466: PPUSH
12467: CALL_OW 12
12471: ST_TO_ADDR
// case i of 1 :
12472: LD_VAR 0 3
12476: PUSH
12477: LD_INT 1
12479: DOUBLE
12480: EQUAL
12481: IFTRUE 12485
12483: GO 12502
12485: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12486: LD_VAR 0 1
12490: PPUSH
12491: LD_VAR 0 10
12495: PPUSH
12496: CALL_OW 115
12500: GO 12563
12502: LD_INT 2
12504: DOUBLE
12505: EQUAL
12506: IFTRUE 12510
12508: GO 12532
12510: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12511: LD_VAR 0 1
12515: PPUSH
12516: LD_VAR 0 6
12520: PPUSH
12521: LD_VAR 0 7
12525: PPUSH
12526: CALL_OW 153
12530: GO 12563
12532: LD_INT 3
12534: DOUBLE
12535: EQUAL
12536: IFTRUE 12540
12538: GO 12562
12540: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12541: LD_VAR 0 1
12545: PPUSH
12546: LD_VAR 0 6
12550: PPUSH
12551: LD_VAR 0 7
12555: PPUSH
12556: CALL_OW 154
12560: GO 12563
12562: POP
// end ;
12563: LD_VAR 0 2
12567: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12568: LD_INT 0
12570: PPUSH
12571: PPUSH
12572: PPUSH
12573: PPUSH
12574: PPUSH
12575: PPUSH
// if not unit or not building then
12576: LD_VAR 0 1
12580: NOT
12581: PUSH
12582: LD_VAR 0 2
12586: NOT
12587: OR
12588: IFFALSE 12592
// exit ;
12590: GO 12750
// x := GetX ( building ) ;
12592: LD_ADDR_VAR 0 5
12596: PUSH
12597: LD_VAR 0 2
12601: PPUSH
12602: CALL_OW 250
12606: ST_TO_ADDR
// y := GetY ( building ) ;
12607: LD_ADDR_VAR 0 6
12611: PUSH
12612: LD_VAR 0 2
12616: PPUSH
12617: CALL_OW 251
12621: ST_TO_ADDR
// for i = 0 to 5 do
12622: LD_ADDR_VAR 0 4
12626: PUSH
12627: DOUBLE
12628: LD_INT 0
12630: DEC
12631: ST_TO_ADDR
12632: LD_INT 5
12634: PUSH
12635: FOR_TO
12636: IFFALSE 12748
// begin _x := ShiftX ( x , i , 3 ) ;
12638: LD_ADDR_VAR 0 7
12642: PUSH
12643: LD_VAR 0 5
12647: PPUSH
12648: LD_VAR 0 4
12652: PPUSH
12653: LD_INT 3
12655: PPUSH
12656: CALL_OW 272
12660: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12661: LD_ADDR_VAR 0 8
12665: PUSH
12666: LD_VAR 0 6
12670: PPUSH
12671: LD_VAR 0 4
12675: PPUSH
12676: LD_INT 3
12678: PPUSH
12679: CALL_OW 273
12683: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12684: LD_VAR 0 7
12688: PPUSH
12689: LD_VAR 0 8
12693: PPUSH
12694: CALL_OW 488
12698: NOT
12699: IFFALSE 12703
// continue ;
12701: GO 12635
// if HexInfo ( _x , _y ) = 0 then
12703: LD_VAR 0 7
12707: PPUSH
12708: LD_VAR 0 8
12712: PPUSH
12713: CALL_OW 428
12717: PUSH
12718: LD_INT 0
12720: EQUAL
12721: IFFALSE 12746
// begin ComMoveXY ( unit , _x , _y ) ;
12723: LD_VAR 0 1
12727: PPUSH
12728: LD_VAR 0 7
12732: PPUSH
12733: LD_VAR 0 8
12737: PPUSH
12738: CALL_OW 111
// exit ;
12742: POP
12743: POP
12744: GO 12750
// end ; end ;
12746: GO 12635
12748: POP
12749: POP
// end ;
12750: LD_VAR 0 3
12754: RET
// export function ScanBase ( side , base_area ) ; begin
12755: LD_INT 0
12757: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
12758: LD_ADDR_VAR 0 3
12762: PUSH
12763: LD_VAR 0 2
12767: PPUSH
12768: LD_INT 81
12770: PUSH
12771: LD_VAR 0 1
12775: PUSH
12776: EMPTY
12777: LIST
12778: LIST
12779: PPUSH
12780: CALL_OW 70
12784: ST_TO_ADDR
// end ;
12785: LD_VAR 0 3
12789: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
12790: LD_INT 0
12792: PPUSH
12793: PPUSH
12794: PPUSH
12795: PPUSH
// result := false ;
12796: LD_ADDR_VAR 0 2
12800: PUSH
12801: LD_INT 0
12803: ST_TO_ADDR
// side := GetSide ( unit ) ;
12804: LD_ADDR_VAR 0 3
12808: PUSH
12809: LD_VAR 0 1
12813: PPUSH
12814: CALL_OW 255
12818: ST_TO_ADDR
// nat := GetNation ( unit ) ;
12819: LD_ADDR_VAR 0 4
12823: PUSH
12824: LD_VAR 0 1
12828: PPUSH
12829: CALL_OW 248
12833: ST_TO_ADDR
// case nat of 1 :
12834: LD_VAR 0 4
12838: PUSH
12839: LD_INT 1
12841: DOUBLE
12842: EQUAL
12843: IFTRUE 12847
12845: GO 12858
12847: POP
// tech := tech_lassight ; 2 :
12848: LD_ADDR_VAR 0 5
12852: PUSH
12853: LD_INT 12
12855: ST_TO_ADDR
12856: GO 12897
12858: LD_INT 2
12860: DOUBLE
12861: EQUAL
12862: IFTRUE 12866
12864: GO 12877
12866: POP
// tech := tech_mortar ; 3 :
12867: LD_ADDR_VAR 0 5
12871: PUSH
12872: LD_INT 41
12874: ST_TO_ADDR
12875: GO 12897
12877: LD_INT 3
12879: DOUBLE
12880: EQUAL
12881: IFTRUE 12885
12883: GO 12896
12885: POP
// tech := tech_bazooka ; end ;
12886: LD_ADDR_VAR 0 5
12890: PUSH
12891: LD_INT 44
12893: ST_TO_ADDR
12894: GO 12897
12896: POP
// if Researched ( side , tech ) then
12897: LD_VAR 0 3
12901: PPUSH
12902: LD_VAR 0 5
12906: PPUSH
12907: CALL_OW 325
12911: IFFALSE 12938
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
12913: LD_ADDR_VAR 0 2
12917: PUSH
12918: LD_INT 5
12920: PUSH
12921: LD_INT 8
12923: PUSH
12924: LD_INT 9
12926: PUSH
12927: EMPTY
12928: LIST
12929: LIST
12930: LIST
12931: PUSH
12932: LD_VAR 0 4
12936: ARRAY
12937: ST_TO_ADDR
// end ;
12938: LD_VAR 0 2
12942: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
12943: LD_INT 0
12945: PPUSH
12946: PPUSH
12947: PPUSH
// if not mines then
12948: LD_VAR 0 2
12952: NOT
12953: IFFALSE 12957
// exit ;
12955: GO 13101
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12957: LD_ADDR_VAR 0 5
12961: PUSH
12962: LD_INT 81
12964: PUSH
12965: LD_VAR 0 1
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 3
12976: PUSH
12977: LD_INT 21
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: EMPTY
12984: LIST
12985: LIST
12986: PUSH
12987: EMPTY
12988: LIST
12989: LIST
12990: PUSH
12991: EMPTY
12992: LIST
12993: LIST
12994: PPUSH
12995: CALL_OW 69
12999: ST_TO_ADDR
// for i in mines do
13000: LD_ADDR_VAR 0 4
13004: PUSH
13005: LD_VAR 0 2
13009: PUSH
13010: FOR_IN
13011: IFFALSE 13099
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13013: LD_VAR 0 4
13017: PUSH
13018: LD_INT 1
13020: ARRAY
13021: PPUSH
13022: LD_VAR 0 4
13026: PUSH
13027: LD_INT 2
13029: ARRAY
13030: PPUSH
13031: CALL_OW 458
13035: NOT
13036: IFFALSE 13040
// continue ;
13038: GO 13010
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13040: LD_VAR 0 4
13044: PUSH
13045: LD_INT 1
13047: ARRAY
13048: PPUSH
13049: LD_VAR 0 4
13053: PUSH
13054: LD_INT 2
13056: ARRAY
13057: PPUSH
13058: CALL_OW 428
13062: PUSH
13063: LD_VAR 0 5
13067: IN
13068: IFFALSE 13097
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13070: LD_VAR 0 4
13074: PUSH
13075: LD_INT 1
13077: ARRAY
13078: PPUSH
13079: LD_VAR 0 4
13083: PUSH
13084: LD_INT 2
13086: ARRAY
13087: PPUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 456
// end ;
13097: GO 13010
13099: POP
13100: POP
// end ;
13101: LD_VAR 0 3
13105: RET
// export function Count ( array ) ; var i ; begin
13106: LD_INT 0
13108: PPUSH
13109: PPUSH
// result := 0 ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 0
13117: ST_TO_ADDR
// for i in array do
13118: LD_ADDR_VAR 0 3
13122: PUSH
13123: LD_VAR 0 1
13127: PUSH
13128: FOR_IN
13129: IFFALSE 13153
// if i then
13131: LD_VAR 0 3
13135: IFFALSE 13151
// result := result + 1 ;
13137: LD_ADDR_VAR 0 2
13141: PUSH
13142: LD_VAR 0 2
13146: PUSH
13147: LD_INT 1
13149: PLUS
13150: ST_TO_ADDR
13151: GO 13128
13153: POP
13154: POP
// end ;
13155: LD_VAR 0 2
13159: RET
// export function IsEmpty ( building ) ; begin
13160: LD_INT 0
13162: PPUSH
// if not building then
13163: LD_VAR 0 1
13167: NOT
13168: IFFALSE 13172
// exit ;
13170: GO 13215
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13172: LD_ADDR_VAR 0 2
13176: PUSH
13177: LD_VAR 0 1
13181: PUSH
13182: LD_INT 22
13184: PUSH
13185: LD_VAR 0 1
13189: PPUSH
13190: CALL_OW 255
13194: PUSH
13195: EMPTY
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 58
13201: PUSH
13202: EMPTY
13203: LIST
13204: PUSH
13205: EMPTY
13206: LIST
13207: LIST
13208: PPUSH
13209: CALL_OW 69
13213: IN
13214: ST_TO_ADDR
// end ;
13215: LD_VAR 0 2
13219: RET
// export function IsNotFull ( building ) ; begin
13220: LD_INT 0
13222: PPUSH
// if not building then
13223: LD_VAR 0 1
13227: NOT
13228: IFFALSE 13232
// exit ;
13230: GO 13251
// result := UnitsInside ( building ) < 6 ;
13232: LD_ADDR_VAR 0 2
13236: PUSH
13237: LD_VAR 0 1
13241: PPUSH
13242: CALL_OW 313
13246: PUSH
13247: LD_INT 6
13249: LESS
13250: ST_TO_ADDR
// end ;
13251: LD_VAR 0 2
13255: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13256: LD_INT 0
13258: PPUSH
13259: PPUSH
13260: PPUSH
13261: PPUSH
// tmp := [ ] ;
13262: LD_ADDR_VAR 0 3
13266: PUSH
13267: EMPTY
13268: ST_TO_ADDR
// list := [ ] ;
13269: LD_ADDR_VAR 0 5
13273: PUSH
13274: EMPTY
13275: ST_TO_ADDR
// for i = 16 to 25 do
13276: LD_ADDR_VAR 0 4
13280: PUSH
13281: DOUBLE
13282: LD_INT 16
13284: DEC
13285: ST_TO_ADDR
13286: LD_INT 25
13288: PUSH
13289: FOR_TO
13290: IFFALSE 13363
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13292: LD_ADDR_VAR 0 3
13296: PUSH
13297: LD_VAR 0 3
13301: PUSH
13302: LD_INT 22
13304: PUSH
13305: LD_VAR 0 1
13309: PPUSH
13310: CALL_OW 255
13314: PUSH
13315: EMPTY
13316: LIST
13317: LIST
13318: PUSH
13319: LD_INT 91
13321: PUSH
13322: LD_VAR 0 1
13326: PUSH
13327: LD_INT 6
13329: PUSH
13330: EMPTY
13331: LIST
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 30
13337: PUSH
13338: LD_VAR 0 4
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: EMPTY
13348: LIST
13349: LIST
13350: LIST
13351: PUSH
13352: EMPTY
13353: LIST
13354: PPUSH
13355: CALL_OW 69
13359: ADD
13360: ST_TO_ADDR
13361: GO 13289
13363: POP
13364: POP
// for i = 1 to tmp do
13365: LD_ADDR_VAR 0 4
13369: PUSH
13370: DOUBLE
13371: LD_INT 1
13373: DEC
13374: ST_TO_ADDR
13375: LD_VAR 0 3
13379: PUSH
13380: FOR_TO
13381: IFFALSE 13469
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13383: LD_ADDR_VAR 0 5
13387: PUSH
13388: LD_VAR 0 5
13392: PUSH
13393: LD_VAR 0 3
13397: PUSH
13398: LD_VAR 0 4
13402: ARRAY
13403: PPUSH
13404: CALL_OW 266
13408: PUSH
13409: LD_VAR 0 3
13413: PUSH
13414: LD_VAR 0 4
13418: ARRAY
13419: PPUSH
13420: CALL_OW 250
13424: PUSH
13425: LD_VAR 0 3
13429: PUSH
13430: LD_VAR 0 4
13434: ARRAY
13435: PPUSH
13436: CALL_OW 251
13440: PUSH
13441: LD_VAR 0 3
13445: PUSH
13446: LD_VAR 0 4
13450: ARRAY
13451: PPUSH
13452: CALL_OW 254
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: LIST
13461: LIST
13462: PUSH
13463: EMPTY
13464: LIST
13465: ADD
13466: ST_TO_ADDR
13467: GO 13380
13469: POP
13470: POP
// result := list ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 5
13480: ST_TO_ADDR
// end ;
13481: LD_VAR 0 2
13485: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13486: LD_INT 0
13488: PPUSH
13489: PPUSH
13490: PPUSH
13491: PPUSH
13492: PPUSH
13493: PPUSH
13494: PPUSH
// if not factory then
13495: LD_VAR 0 1
13499: NOT
13500: IFFALSE 13504
// exit ;
13502: GO 14097
// if control = control_apeman then
13504: LD_VAR 0 4
13508: PUSH
13509: LD_INT 5
13511: EQUAL
13512: IFFALSE 13621
// begin tmp := UnitsInside ( factory ) ;
13514: LD_ADDR_VAR 0 8
13518: PUSH
13519: LD_VAR 0 1
13523: PPUSH
13524: CALL_OW 313
13528: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13529: LD_VAR 0 8
13533: PPUSH
13534: LD_INT 25
13536: PUSH
13537: LD_INT 12
13539: PUSH
13540: EMPTY
13541: LIST
13542: LIST
13543: PPUSH
13544: CALL_OW 72
13548: NOT
13549: IFFALSE 13559
// control := control_manual ;
13551: LD_ADDR_VAR 0 4
13555: PUSH
13556: LD_INT 1
13558: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13559: LD_ADDR_VAR 0 8
13563: PUSH
13564: LD_VAR 0 1
13568: PPUSH
13569: CALL 13256 0 1
13573: ST_TO_ADDR
// if tmp then
13574: LD_VAR 0 8
13578: IFFALSE 13621
// begin for i in tmp do
13580: LD_ADDR_VAR 0 7
13584: PUSH
13585: LD_VAR 0 8
13589: PUSH
13590: FOR_IN
13591: IFFALSE 13619
// if i [ 1 ] = b_ext_radio then
13593: LD_VAR 0 7
13597: PUSH
13598: LD_INT 1
13600: ARRAY
13601: PUSH
13602: LD_INT 22
13604: EQUAL
13605: IFFALSE 13617
// begin control := control_remote ;
13607: LD_ADDR_VAR 0 4
13611: PUSH
13612: LD_INT 2
13614: ST_TO_ADDR
// break ;
13615: GO 13619
// end ;
13617: GO 13590
13619: POP
13620: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13621: LD_VAR 0 1
13625: PPUSH
13626: LD_VAR 0 2
13630: PPUSH
13631: LD_VAR 0 3
13635: PPUSH
13636: LD_VAR 0 4
13640: PPUSH
13641: LD_VAR 0 5
13645: PPUSH
13646: CALL_OW 448
13650: IFFALSE 13685
// begin result := [ chassis , engine , control , weapon ] ;
13652: LD_ADDR_VAR 0 6
13656: PUSH
13657: LD_VAR 0 2
13661: PUSH
13662: LD_VAR 0 3
13666: PUSH
13667: LD_VAR 0 4
13671: PUSH
13672: LD_VAR 0 5
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: LIST
13681: LIST
13682: ST_TO_ADDR
// exit ;
13683: GO 14097
// end ; _chassis := AvailableChassisList ( factory ) ;
13685: LD_ADDR_VAR 0 9
13689: PUSH
13690: LD_VAR 0 1
13694: PPUSH
13695: CALL_OW 475
13699: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13700: LD_ADDR_VAR 0 11
13704: PUSH
13705: LD_VAR 0 1
13709: PPUSH
13710: CALL_OW 476
13714: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13715: LD_ADDR_VAR 0 12
13719: PUSH
13720: LD_VAR 0 1
13724: PPUSH
13725: CALL_OW 477
13729: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13730: LD_ADDR_VAR 0 10
13734: PUSH
13735: LD_VAR 0 1
13739: PPUSH
13740: CALL_OW 478
13744: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13745: LD_VAR 0 9
13749: NOT
13750: PUSH
13751: LD_VAR 0 11
13755: NOT
13756: OR
13757: PUSH
13758: LD_VAR 0 12
13762: NOT
13763: OR
13764: PUSH
13765: LD_VAR 0 10
13769: NOT
13770: OR
13771: IFFALSE 13806
// begin result := [ chassis , engine , control , weapon ] ;
13773: LD_ADDR_VAR 0 6
13777: PUSH
13778: LD_VAR 0 2
13782: PUSH
13783: LD_VAR 0 3
13787: PUSH
13788: LD_VAR 0 4
13792: PUSH
13793: LD_VAR 0 5
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: LIST
13802: LIST
13803: ST_TO_ADDR
// exit ;
13804: GO 14097
// end ; if not chassis in _chassis then
13806: LD_VAR 0 2
13810: PUSH
13811: LD_VAR 0 9
13815: IN
13816: NOT
13817: IFFALSE 13843
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
13819: LD_ADDR_VAR 0 2
13823: PUSH
13824: LD_VAR 0 9
13828: PUSH
13829: LD_INT 1
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 12
13841: ARRAY
13842: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
13843: LD_VAR 0 2
13847: PPUSH
13848: LD_VAR 0 3
13852: PPUSH
13853: CALL 14102 0 2
13857: NOT
13858: IFFALSE 13917
// repeat engine := _engine [ 1 ] ;
13860: LD_ADDR_VAR 0 3
13864: PUSH
13865: LD_VAR 0 11
13869: PUSH
13870: LD_INT 1
13872: ARRAY
13873: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
13874: LD_ADDR_VAR 0 11
13878: PUSH
13879: LD_VAR 0 11
13883: PPUSH
13884: LD_INT 1
13886: PPUSH
13887: CALL_OW 3
13891: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
13892: LD_VAR 0 2
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: CALL 14102 0 2
13906: PUSH
13907: LD_VAR 0 11
13911: PUSH
13912: EMPTY
13913: EQUAL
13914: OR
13915: IFFALSE 13860
// if not control in _control then
13917: LD_VAR 0 4
13921: PUSH
13922: LD_VAR 0 12
13926: IN
13927: NOT
13928: IFFALSE 13954
// control := _control [ rand ( 1 , _control ) ] ;
13930: LD_ADDR_VAR 0 4
13934: PUSH
13935: LD_VAR 0 12
13939: PUSH
13940: LD_INT 1
13942: PPUSH
13943: LD_VAR 0 12
13947: PPUSH
13948: CALL_OW 12
13952: ARRAY
13953: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
13954: LD_VAR 0 2
13958: PPUSH
13959: LD_VAR 0 5
13963: PPUSH
13964: CALL 14322 0 2
13968: NOT
13969: IFFALSE 14028
// repeat weapon := _weapon [ 1 ] ;
13971: LD_ADDR_VAR 0 5
13975: PUSH
13976: LD_VAR 0 10
13980: PUSH
13981: LD_INT 1
13983: ARRAY
13984: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
13985: LD_ADDR_VAR 0 10
13989: PUSH
13990: LD_VAR 0 10
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 3
14002: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14003: LD_VAR 0 2
14007: PPUSH
14008: LD_VAR 0 5
14012: PPUSH
14013: CALL 14322 0 2
14017: PUSH
14018: LD_VAR 0 10
14022: PUSH
14023: EMPTY
14024: EQUAL
14025: OR
14026: IFFALSE 13971
// result := [ ] ;
14028: LD_ADDR_VAR 0 6
14032: PUSH
14033: EMPTY
14034: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14035: LD_VAR 0 1
14039: PPUSH
14040: LD_VAR 0 2
14044: PPUSH
14045: LD_VAR 0 3
14049: PPUSH
14050: LD_VAR 0 4
14054: PPUSH
14055: LD_VAR 0 5
14059: PPUSH
14060: CALL_OW 448
14064: IFFALSE 14097
// result := [ chassis , engine , control , weapon ] ;
14066: LD_ADDR_VAR 0 6
14070: PUSH
14071: LD_VAR 0 2
14075: PUSH
14076: LD_VAR 0 3
14080: PUSH
14081: LD_VAR 0 4
14085: PUSH
14086: LD_VAR 0 5
14090: PUSH
14091: EMPTY
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: ST_TO_ADDR
// end ;
14097: LD_VAR 0 6
14101: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14102: LD_INT 0
14104: PPUSH
// if not chassis or not engine then
14105: LD_VAR 0 1
14109: NOT
14110: PUSH
14111: LD_VAR 0 2
14115: NOT
14116: OR
14117: IFFALSE 14121
// exit ;
14119: GO 14317
// case engine of engine_solar :
14121: LD_VAR 0 2
14125: PUSH
14126: LD_INT 2
14128: DOUBLE
14129: EQUAL
14130: IFTRUE 14134
14132: GO 14172
14134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14135: LD_ADDR_VAR 0 3
14139: PUSH
14140: LD_INT 11
14142: PUSH
14143: LD_INT 12
14145: PUSH
14146: LD_INT 13
14148: PUSH
14149: LD_INT 14
14151: PUSH
14152: LD_INT 1
14154: PUSH
14155: LD_INT 2
14157: PUSH
14158: LD_INT 3
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: ST_TO_ADDR
14170: GO 14301
14172: LD_INT 1
14174: DOUBLE
14175: EQUAL
14176: IFTRUE 14180
14178: GO 14242
14180: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14181: LD_ADDR_VAR 0 3
14185: PUSH
14186: LD_INT 11
14188: PUSH
14189: LD_INT 12
14191: PUSH
14192: LD_INT 13
14194: PUSH
14195: LD_INT 14
14197: PUSH
14198: LD_INT 1
14200: PUSH
14201: LD_INT 2
14203: PUSH
14204: LD_INT 3
14206: PUSH
14207: LD_INT 4
14209: PUSH
14210: LD_INT 5
14212: PUSH
14213: LD_INT 21
14215: PUSH
14216: LD_INT 23
14218: PUSH
14219: LD_INT 22
14221: PUSH
14222: LD_INT 24
14224: PUSH
14225: EMPTY
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: ST_TO_ADDR
14240: GO 14301
14242: LD_INT 3
14244: DOUBLE
14245: EQUAL
14246: IFTRUE 14250
14248: GO 14300
14250: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14251: LD_ADDR_VAR 0 3
14255: PUSH
14256: LD_INT 13
14258: PUSH
14259: LD_INT 14
14261: PUSH
14262: LD_INT 2
14264: PUSH
14265: LD_INT 3
14267: PUSH
14268: LD_INT 4
14270: PUSH
14271: LD_INT 5
14273: PUSH
14274: LD_INT 21
14276: PUSH
14277: LD_INT 22
14279: PUSH
14280: LD_INT 23
14282: PUSH
14283: LD_INT 24
14285: PUSH
14286: EMPTY
14287: LIST
14288: LIST
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: ST_TO_ADDR
14298: GO 14301
14300: POP
// result := ( chassis in result ) ;
14301: LD_ADDR_VAR 0 3
14305: PUSH
14306: LD_VAR 0 1
14310: PUSH
14311: LD_VAR 0 3
14315: IN
14316: ST_TO_ADDR
// end ;
14317: LD_VAR 0 3
14321: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14322: LD_INT 0
14324: PPUSH
// if not chassis or not weapon then
14325: LD_VAR 0 1
14329: NOT
14330: PUSH
14331: LD_VAR 0 2
14335: NOT
14336: OR
14337: IFFALSE 14341
// exit ;
14339: GO 15403
// case weapon of us_machine_gun :
14341: LD_VAR 0 2
14345: PUSH
14346: LD_INT 2
14348: DOUBLE
14349: EQUAL
14350: IFTRUE 14354
14352: GO 14384
14354: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14355: LD_ADDR_VAR 0 3
14359: PUSH
14360: LD_INT 1
14362: PUSH
14363: LD_INT 2
14365: PUSH
14366: LD_INT 3
14368: PUSH
14369: LD_INT 4
14371: PUSH
14372: LD_INT 5
14374: PUSH
14375: EMPTY
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 15387
14384: LD_INT 3
14386: DOUBLE
14387: EQUAL
14388: IFTRUE 14392
14390: GO 14422
14392: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14393: LD_ADDR_VAR 0 3
14397: PUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: LD_INT 3
14406: PUSH
14407: LD_INT 4
14409: PUSH
14410: LD_INT 5
14412: PUSH
14413: EMPTY
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: ST_TO_ADDR
14420: GO 15387
14422: LD_INT 11
14424: DOUBLE
14425: EQUAL
14426: IFTRUE 14430
14428: GO 14460
14430: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14431: LD_ADDR_VAR 0 3
14435: PUSH
14436: LD_INT 1
14438: PUSH
14439: LD_INT 2
14441: PUSH
14442: LD_INT 3
14444: PUSH
14445: LD_INT 4
14447: PUSH
14448: LD_INT 5
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: ST_TO_ADDR
14458: GO 15387
14460: LD_INT 4
14462: DOUBLE
14463: EQUAL
14464: IFTRUE 14468
14466: GO 14494
14468: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14469: LD_ADDR_VAR 0 3
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: LD_INT 3
14479: PUSH
14480: LD_INT 4
14482: PUSH
14483: LD_INT 5
14485: PUSH
14486: EMPTY
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: ST_TO_ADDR
14492: GO 15387
14494: LD_INT 5
14496: DOUBLE
14497: EQUAL
14498: IFTRUE 14502
14500: GO 14528
14502: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14503: LD_ADDR_VAR 0 3
14507: PUSH
14508: LD_INT 2
14510: PUSH
14511: LD_INT 3
14513: PUSH
14514: LD_INT 4
14516: PUSH
14517: LD_INT 5
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: ST_TO_ADDR
14526: GO 15387
14528: LD_INT 9
14530: DOUBLE
14531: EQUAL
14532: IFTRUE 14536
14534: GO 14562
14536: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14537: LD_ADDR_VAR 0 3
14541: PUSH
14542: LD_INT 2
14544: PUSH
14545: LD_INT 3
14547: PUSH
14548: LD_INT 4
14550: PUSH
14551: LD_INT 5
14553: PUSH
14554: EMPTY
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: ST_TO_ADDR
14560: GO 15387
14562: LD_INT 7
14564: DOUBLE
14565: EQUAL
14566: IFTRUE 14570
14568: GO 14596
14570: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14571: LD_ADDR_VAR 0 3
14575: PUSH
14576: LD_INT 2
14578: PUSH
14579: LD_INT 3
14581: PUSH
14582: LD_INT 4
14584: PUSH
14585: LD_INT 5
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: ST_TO_ADDR
14594: GO 15387
14596: LD_INT 12
14598: DOUBLE
14599: EQUAL
14600: IFTRUE 14604
14602: GO 14630
14604: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14605: LD_ADDR_VAR 0 3
14609: PUSH
14610: LD_INT 2
14612: PUSH
14613: LD_INT 3
14615: PUSH
14616: LD_INT 4
14618: PUSH
14619: LD_INT 5
14621: PUSH
14622: EMPTY
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: ST_TO_ADDR
14628: GO 15387
14630: LD_INT 13
14632: DOUBLE
14633: EQUAL
14634: IFTRUE 14638
14636: GO 14664
14638: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 2
14646: PUSH
14647: LD_INT 3
14649: PUSH
14650: LD_INT 4
14652: PUSH
14653: LD_INT 5
14655: PUSH
14656: EMPTY
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: ST_TO_ADDR
14662: GO 15387
14664: LD_INT 14
14666: DOUBLE
14667: EQUAL
14668: IFTRUE 14672
14670: GO 14690
14672: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14673: LD_ADDR_VAR 0 3
14677: PUSH
14678: LD_INT 4
14680: PUSH
14681: LD_INT 5
14683: PUSH
14684: EMPTY
14685: LIST
14686: LIST
14687: ST_TO_ADDR
14688: GO 15387
14690: LD_INT 6
14692: DOUBLE
14693: EQUAL
14694: IFTRUE 14698
14696: GO 14716
14698: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14699: LD_ADDR_VAR 0 3
14703: PUSH
14704: LD_INT 4
14706: PUSH
14707: LD_INT 5
14709: PUSH
14710: EMPTY
14711: LIST
14712: LIST
14713: ST_TO_ADDR
14714: GO 15387
14716: LD_INT 10
14718: DOUBLE
14719: EQUAL
14720: IFTRUE 14724
14722: GO 14742
14724: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14725: LD_ADDR_VAR 0 3
14729: PUSH
14730: LD_INT 4
14732: PUSH
14733: LD_INT 5
14735: PUSH
14736: EMPTY
14737: LIST
14738: LIST
14739: ST_TO_ADDR
14740: GO 15387
14742: LD_INT 22
14744: DOUBLE
14745: EQUAL
14746: IFTRUE 14750
14748: GO 14776
14750: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
14751: LD_ADDR_VAR 0 3
14755: PUSH
14756: LD_INT 11
14758: PUSH
14759: LD_INT 12
14761: PUSH
14762: LD_INT 13
14764: PUSH
14765: LD_INT 14
14767: PUSH
14768: EMPTY
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: ST_TO_ADDR
14774: GO 15387
14776: LD_INT 23
14778: DOUBLE
14779: EQUAL
14780: IFTRUE 14784
14782: GO 14810
14784: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
14785: LD_ADDR_VAR 0 3
14789: PUSH
14790: LD_INT 11
14792: PUSH
14793: LD_INT 12
14795: PUSH
14796: LD_INT 13
14798: PUSH
14799: LD_INT 14
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: ST_TO_ADDR
14808: GO 15387
14810: LD_INT 24
14812: DOUBLE
14813: EQUAL
14814: IFTRUE 14818
14816: GO 14844
14818: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
14819: LD_ADDR_VAR 0 3
14823: PUSH
14824: LD_INT 11
14826: PUSH
14827: LD_INT 12
14829: PUSH
14830: LD_INT 13
14832: PUSH
14833: LD_INT 14
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: ST_TO_ADDR
14842: GO 15387
14844: LD_INT 30
14846: DOUBLE
14847: EQUAL
14848: IFTRUE 14852
14850: GO 14878
14852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
14853: LD_ADDR_VAR 0 3
14857: PUSH
14858: LD_INT 11
14860: PUSH
14861: LD_INT 12
14863: PUSH
14864: LD_INT 13
14866: PUSH
14867: LD_INT 14
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: ST_TO_ADDR
14876: GO 15387
14878: LD_INT 25
14880: DOUBLE
14881: EQUAL
14882: IFTRUE 14886
14884: GO 14904
14886: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
14887: LD_ADDR_VAR 0 3
14891: PUSH
14892: LD_INT 13
14894: PUSH
14895: LD_INT 14
14897: PUSH
14898: EMPTY
14899: LIST
14900: LIST
14901: ST_TO_ADDR
14902: GO 15387
14904: LD_INT 27
14906: DOUBLE
14907: EQUAL
14908: IFTRUE 14912
14910: GO 14930
14912: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
14913: LD_ADDR_VAR 0 3
14917: PUSH
14918: LD_INT 13
14920: PUSH
14921: LD_INT 14
14923: PUSH
14924: EMPTY
14925: LIST
14926: LIST
14927: ST_TO_ADDR
14928: GO 15387
14930: LD_EXP 72
14934: DOUBLE
14935: EQUAL
14936: IFTRUE 14940
14938: GO 14966
14940: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
14941: LD_ADDR_VAR 0 3
14945: PUSH
14946: LD_INT 11
14948: PUSH
14949: LD_INT 12
14951: PUSH
14952: LD_INT 13
14954: PUSH
14955: LD_INT 14
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: ST_TO_ADDR
14964: GO 15387
14966: LD_INT 28
14968: DOUBLE
14969: EQUAL
14970: IFTRUE 14974
14972: GO 14992
14974: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
14975: LD_ADDR_VAR 0 3
14979: PUSH
14980: LD_INT 13
14982: PUSH
14983: LD_INT 14
14985: PUSH
14986: EMPTY
14987: LIST
14988: LIST
14989: ST_TO_ADDR
14990: GO 15387
14992: LD_INT 29
14994: DOUBLE
14995: EQUAL
14996: IFTRUE 15000
14998: GO 15018
15000: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15001: LD_ADDR_VAR 0 3
15005: PUSH
15006: LD_INT 13
15008: PUSH
15009: LD_INT 14
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: ST_TO_ADDR
15016: GO 15387
15018: LD_INT 31
15020: DOUBLE
15021: EQUAL
15022: IFTRUE 15026
15024: GO 15044
15026: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15027: LD_ADDR_VAR 0 3
15031: PUSH
15032: LD_INT 13
15034: PUSH
15035: LD_INT 14
15037: PUSH
15038: EMPTY
15039: LIST
15040: LIST
15041: ST_TO_ADDR
15042: GO 15387
15044: LD_INT 26
15046: DOUBLE
15047: EQUAL
15048: IFTRUE 15052
15050: GO 15070
15052: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15053: LD_ADDR_VAR 0 3
15057: PUSH
15058: LD_INT 13
15060: PUSH
15061: LD_INT 14
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: ST_TO_ADDR
15068: GO 15387
15070: LD_INT 42
15072: DOUBLE
15073: EQUAL
15074: IFTRUE 15078
15076: GO 15104
15078: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15079: LD_ADDR_VAR 0 3
15083: PUSH
15084: LD_INT 21
15086: PUSH
15087: LD_INT 22
15089: PUSH
15090: LD_INT 23
15092: PUSH
15093: LD_INT 24
15095: PUSH
15096: EMPTY
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: ST_TO_ADDR
15102: GO 15387
15104: LD_INT 43
15106: DOUBLE
15107: EQUAL
15108: IFTRUE 15112
15110: GO 15138
15112: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15113: LD_ADDR_VAR 0 3
15117: PUSH
15118: LD_INT 21
15120: PUSH
15121: LD_INT 22
15123: PUSH
15124: LD_INT 23
15126: PUSH
15127: LD_INT 24
15129: PUSH
15130: EMPTY
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: ST_TO_ADDR
15136: GO 15387
15138: LD_INT 44
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15172
15146: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15147: LD_ADDR_VAR 0 3
15151: PUSH
15152: LD_INT 21
15154: PUSH
15155: LD_INT 22
15157: PUSH
15158: LD_INT 23
15160: PUSH
15161: LD_INT 24
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: ST_TO_ADDR
15170: GO 15387
15172: LD_INT 45
15174: DOUBLE
15175: EQUAL
15176: IFTRUE 15180
15178: GO 15206
15180: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15181: LD_ADDR_VAR 0 3
15185: PUSH
15186: LD_INT 21
15188: PUSH
15189: LD_INT 22
15191: PUSH
15192: LD_INT 23
15194: PUSH
15195: LD_INT 24
15197: PUSH
15198: EMPTY
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: ST_TO_ADDR
15204: GO 15387
15206: LD_INT 49
15208: DOUBLE
15209: EQUAL
15210: IFTRUE 15214
15212: GO 15240
15214: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15215: LD_ADDR_VAR 0 3
15219: PUSH
15220: LD_INT 21
15222: PUSH
15223: LD_INT 22
15225: PUSH
15226: LD_INT 23
15228: PUSH
15229: LD_INT 24
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: ST_TO_ADDR
15238: GO 15387
15240: LD_INT 51
15242: DOUBLE
15243: EQUAL
15244: IFTRUE 15248
15246: GO 15274
15248: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15249: LD_ADDR_VAR 0 3
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 23
15262: PUSH
15263: LD_INT 24
15265: PUSH
15266: EMPTY
15267: LIST
15268: LIST
15269: LIST
15270: LIST
15271: ST_TO_ADDR
15272: GO 15387
15274: LD_INT 52
15276: DOUBLE
15277: EQUAL
15278: IFTRUE 15282
15280: GO 15308
15282: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15283: LD_ADDR_VAR 0 3
15287: PUSH
15288: LD_INT 21
15290: PUSH
15291: LD_INT 22
15293: PUSH
15294: LD_INT 23
15296: PUSH
15297: LD_INT 24
15299: PUSH
15300: EMPTY
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: ST_TO_ADDR
15306: GO 15387
15308: LD_INT 53
15310: DOUBLE
15311: EQUAL
15312: IFTRUE 15316
15314: GO 15334
15316: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15317: LD_ADDR_VAR 0 3
15321: PUSH
15322: LD_INT 23
15324: PUSH
15325: LD_INT 24
15327: PUSH
15328: EMPTY
15329: LIST
15330: LIST
15331: ST_TO_ADDR
15332: GO 15387
15334: LD_INT 46
15336: DOUBLE
15337: EQUAL
15338: IFTRUE 15342
15340: GO 15360
15342: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15343: LD_ADDR_VAR 0 3
15347: PUSH
15348: LD_INT 23
15350: PUSH
15351: LD_INT 24
15353: PUSH
15354: EMPTY
15355: LIST
15356: LIST
15357: ST_TO_ADDR
15358: GO 15387
15360: LD_INT 47
15362: DOUBLE
15363: EQUAL
15364: IFTRUE 15368
15366: GO 15386
15368: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15369: LD_ADDR_VAR 0 3
15373: PUSH
15374: LD_INT 23
15376: PUSH
15377: LD_INT 24
15379: PUSH
15380: EMPTY
15381: LIST
15382: LIST
15383: ST_TO_ADDR
15384: GO 15387
15386: POP
// result := ( chassis in result ) ;
15387: LD_ADDR_VAR 0 3
15391: PUSH
15392: LD_VAR 0 1
15396: PUSH
15397: LD_VAR 0 3
15401: IN
15402: ST_TO_ADDR
// end ;
15403: LD_VAR 0 3
15407: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15408: LD_INT 0
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
15414: PPUSH
15415: PPUSH
15416: PPUSH
// result := array ;
15417: LD_ADDR_VAR 0 5
15421: PUSH
15422: LD_VAR 0 1
15426: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15427: LD_VAR 0 1
15431: NOT
15432: PUSH
15433: LD_VAR 0 2
15437: NOT
15438: OR
15439: PUSH
15440: LD_VAR 0 3
15444: NOT
15445: OR
15446: PUSH
15447: LD_VAR 0 2
15451: PUSH
15452: LD_VAR 0 1
15456: GREATER
15457: OR
15458: PUSH
15459: LD_VAR 0 3
15463: PUSH
15464: LD_VAR 0 1
15468: GREATER
15469: OR
15470: IFFALSE 15474
// exit ;
15472: GO 15770
// if direction then
15474: LD_VAR 0 4
15478: IFFALSE 15542
// begin d := 1 ;
15480: LD_ADDR_VAR 0 9
15484: PUSH
15485: LD_INT 1
15487: ST_TO_ADDR
// if i_from > i_to then
15488: LD_VAR 0 2
15492: PUSH
15493: LD_VAR 0 3
15497: GREATER
15498: IFFALSE 15524
// length := ( array - i_from ) + i_to else
15500: LD_ADDR_VAR 0 11
15504: PUSH
15505: LD_VAR 0 1
15509: PUSH
15510: LD_VAR 0 2
15514: MINUS
15515: PUSH
15516: LD_VAR 0 3
15520: PLUS
15521: ST_TO_ADDR
15522: GO 15540
// length := i_to - i_from ;
15524: LD_ADDR_VAR 0 11
15528: PUSH
15529: LD_VAR 0 3
15533: PUSH
15534: LD_VAR 0 2
15538: MINUS
15539: ST_TO_ADDR
// end else
15540: GO 15603
// begin d := - 1 ;
15542: LD_ADDR_VAR 0 9
15546: PUSH
15547: LD_INT 1
15549: NEG
15550: ST_TO_ADDR
// if i_from > i_to then
15551: LD_VAR 0 2
15555: PUSH
15556: LD_VAR 0 3
15560: GREATER
15561: IFFALSE 15581
// length := i_from - i_to else
15563: LD_ADDR_VAR 0 11
15567: PUSH
15568: LD_VAR 0 2
15572: PUSH
15573: LD_VAR 0 3
15577: MINUS
15578: ST_TO_ADDR
15579: GO 15603
// length := ( array - i_to ) + i_from ;
15581: LD_ADDR_VAR 0 11
15585: PUSH
15586: LD_VAR 0 1
15590: PUSH
15591: LD_VAR 0 3
15595: MINUS
15596: PUSH
15597: LD_VAR 0 2
15601: PLUS
15602: ST_TO_ADDR
// end ; if not length then
15603: LD_VAR 0 11
15607: NOT
15608: IFFALSE 15612
// exit ;
15610: GO 15770
// tmp := array ;
15612: LD_ADDR_VAR 0 10
15616: PUSH
15617: LD_VAR 0 1
15621: ST_TO_ADDR
// for i = 1 to length do
15622: LD_ADDR_VAR 0 6
15626: PUSH
15627: DOUBLE
15628: LD_INT 1
15630: DEC
15631: ST_TO_ADDR
15632: LD_VAR 0 11
15636: PUSH
15637: FOR_TO
15638: IFFALSE 15758
// begin for j = 1 to array do
15640: LD_ADDR_VAR 0 7
15644: PUSH
15645: DOUBLE
15646: LD_INT 1
15648: DEC
15649: ST_TO_ADDR
15650: LD_VAR 0 1
15654: PUSH
15655: FOR_TO
15656: IFFALSE 15744
// begin k := j + d ;
15658: LD_ADDR_VAR 0 8
15662: PUSH
15663: LD_VAR 0 7
15667: PUSH
15668: LD_VAR 0 9
15672: PLUS
15673: ST_TO_ADDR
// if k > array then
15674: LD_VAR 0 8
15678: PUSH
15679: LD_VAR 0 1
15683: GREATER
15684: IFFALSE 15694
// k := 1 ;
15686: LD_ADDR_VAR 0 8
15690: PUSH
15691: LD_INT 1
15693: ST_TO_ADDR
// if not k then
15694: LD_VAR 0 8
15698: NOT
15699: IFFALSE 15711
// k := array ;
15701: LD_ADDR_VAR 0 8
15705: PUSH
15706: LD_VAR 0 1
15710: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15711: LD_ADDR_VAR 0 10
15715: PUSH
15716: LD_VAR 0 10
15720: PPUSH
15721: LD_VAR 0 8
15725: PPUSH
15726: LD_VAR 0 1
15730: PUSH
15731: LD_VAR 0 7
15735: ARRAY
15736: PPUSH
15737: CALL_OW 1
15741: ST_TO_ADDR
// end ;
15742: GO 15655
15744: POP
15745: POP
// array := tmp ;
15746: LD_ADDR_VAR 0 1
15750: PUSH
15751: LD_VAR 0 10
15755: ST_TO_ADDR
// end ;
15756: GO 15637
15758: POP
15759: POP
// result := array ;
15760: LD_ADDR_VAR 0 5
15764: PUSH
15765: LD_VAR 0 1
15769: ST_TO_ADDR
// end ;
15770: LD_VAR 0 5
15774: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
15775: LD_INT 0
15777: PPUSH
15778: PPUSH
// result := 0 ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 0
15786: ST_TO_ADDR
// if not array or not value in array then
15787: LD_VAR 0 1
15791: NOT
15792: PUSH
15793: LD_VAR 0 2
15797: PUSH
15798: LD_VAR 0 1
15802: IN
15803: NOT
15804: OR
15805: IFFALSE 15809
// exit ;
15807: GO 15863
// for i = 1 to array do
15809: LD_ADDR_VAR 0 4
15813: PUSH
15814: DOUBLE
15815: LD_INT 1
15817: DEC
15818: ST_TO_ADDR
15819: LD_VAR 0 1
15823: PUSH
15824: FOR_TO
15825: IFFALSE 15861
// if value = array [ i ] then
15827: LD_VAR 0 2
15831: PUSH
15832: LD_VAR 0 1
15836: PUSH
15837: LD_VAR 0 4
15841: ARRAY
15842: EQUAL
15843: IFFALSE 15859
// begin result := i ;
15845: LD_ADDR_VAR 0 3
15849: PUSH
15850: LD_VAR 0 4
15854: ST_TO_ADDR
// exit ;
15855: POP
15856: POP
15857: GO 15863
// end ;
15859: GO 15824
15861: POP
15862: POP
// end ;
15863: LD_VAR 0 3
15867: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
15868: LD_INT 0
15870: PPUSH
// vc_chassis := chassis ;
15871: LD_ADDR_OWVAR 37
15875: PUSH
15876: LD_VAR 0 1
15880: ST_TO_ADDR
// vc_engine := engine ;
15881: LD_ADDR_OWVAR 39
15885: PUSH
15886: LD_VAR 0 2
15890: ST_TO_ADDR
// vc_control := control ;
15891: LD_ADDR_OWVAR 38
15895: PUSH
15896: LD_VAR 0 3
15900: ST_TO_ADDR
// vc_weapon := weapon ;
15901: LD_ADDR_OWVAR 40
15905: PUSH
15906: LD_VAR 0 4
15910: ST_TO_ADDR
// vc_fuel_battery := fuel ;
15911: LD_ADDR_OWVAR 41
15915: PUSH
15916: LD_VAR 0 5
15920: ST_TO_ADDR
// end ;
15921: LD_VAR 0 6
15925: RET
// export function WantPlant ( unit ) ; var task ; begin
15926: LD_INT 0
15928: PPUSH
15929: PPUSH
// result := false ;
15930: LD_ADDR_VAR 0 2
15934: PUSH
15935: LD_INT 0
15937: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
15938: LD_ADDR_VAR 0 3
15942: PUSH
15943: LD_VAR 0 1
15947: PPUSH
15948: CALL_OW 437
15952: ST_TO_ADDR
// if task then
15953: LD_VAR 0 3
15957: IFFALSE 15985
// if task [ 1 ] [ 1 ] = p then
15959: LD_VAR 0 3
15963: PUSH
15964: LD_INT 1
15966: ARRAY
15967: PUSH
15968: LD_INT 1
15970: ARRAY
15971: PUSH
15972: LD_STRING p
15974: EQUAL
15975: IFFALSE 15985
// result := true ;
15977: LD_ADDR_VAR 0 2
15981: PUSH
15982: LD_INT 1
15984: ST_TO_ADDR
// end ;
15985: LD_VAR 0 2
15989: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
15990: LD_INT 0
15992: PPUSH
15993: PPUSH
15994: PPUSH
15995: PPUSH
// if pos < 1 then
15996: LD_VAR 0 2
16000: PUSH
16001: LD_INT 1
16003: LESS
16004: IFFALSE 16008
// exit ;
16006: GO 16311
// if pos = 1 then
16008: LD_VAR 0 2
16012: PUSH
16013: LD_INT 1
16015: EQUAL
16016: IFFALSE 16049
// result := Replace ( arr , pos [ 1 ] , value ) else
16018: LD_ADDR_VAR 0 4
16022: PUSH
16023: LD_VAR 0 1
16027: PPUSH
16028: LD_VAR 0 2
16032: PUSH
16033: LD_INT 1
16035: ARRAY
16036: PPUSH
16037: LD_VAR 0 3
16041: PPUSH
16042: CALL_OW 1
16046: ST_TO_ADDR
16047: GO 16311
// begin tmp := arr ;
16049: LD_ADDR_VAR 0 6
16053: PUSH
16054: LD_VAR 0 1
16058: ST_TO_ADDR
// s_arr := [ tmp ] ;
16059: LD_ADDR_VAR 0 7
16063: PUSH
16064: LD_VAR 0 6
16068: PUSH
16069: EMPTY
16070: LIST
16071: ST_TO_ADDR
// for i = 1 to pos - 1 do
16072: LD_ADDR_VAR 0 5
16076: PUSH
16077: DOUBLE
16078: LD_INT 1
16080: DEC
16081: ST_TO_ADDR
16082: LD_VAR 0 2
16086: PUSH
16087: LD_INT 1
16089: MINUS
16090: PUSH
16091: FOR_TO
16092: IFFALSE 16137
// begin tmp := tmp [ pos [ i ] ] ;
16094: LD_ADDR_VAR 0 6
16098: PUSH
16099: LD_VAR 0 6
16103: PUSH
16104: LD_VAR 0 2
16108: PUSH
16109: LD_VAR 0 5
16113: ARRAY
16114: ARRAY
16115: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16116: LD_ADDR_VAR 0 7
16120: PUSH
16121: LD_VAR 0 7
16125: PUSH
16126: LD_VAR 0 6
16130: PUSH
16131: EMPTY
16132: LIST
16133: ADD
16134: ST_TO_ADDR
// end ;
16135: GO 16091
16137: POP
16138: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16139: LD_ADDR_VAR 0 6
16143: PUSH
16144: LD_VAR 0 6
16148: PPUSH
16149: LD_VAR 0 2
16153: PUSH
16154: LD_VAR 0 2
16158: ARRAY
16159: PPUSH
16160: LD_VAR 0 3
16164: PPUSH
16165: CALL_OW 1
16169: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16170: LD_ADDR_VAR 0 7
16174: PUSH
16175: LD_VAR 0 7
16179: PPUSH
16180: LD_VAR 0 7
16184: PPUSH
16185: LD_VAR 0 6
16189: PPUSH
16190: CALL_OW 1
16194: ST_TO_ADDR
// for i = s_arr downto 2 do
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: DOUBLE
16201: LD_VAR 0 7
16205: INC
16206: ST_TO_ADDR
16207: LD_INT 2
16209: PUSH
16210: FOR_DOWNTO
16211: IFFALSE 16295
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16213: LD_ADDR_VAR 0 6
16217: PUSH
16218: LD_VAR 0 7
16222: PUSH
16223: LD_VAR 0 5
16227: PUSH
16228: LD_INT 1
16230: MINUS
16231: ARRAY
16232: PPUSH
16233: LD_VAR 0 2
16237: PUSH
16238: LD_VAR 0 5
16242: PUSH
16243: LD_INT 1
16245: MINUS
16246: ARRAY
16247: PPUSH
16248: LD_VAR 0 7
16252: PUSH
16253: LD_VAR 0 5
16257: ARRAY
16258: PPUSH
16259: CALL_OW 1
16263: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16264: LD_ADDR_VAR 0 7
16268: PUSH
16269: LD_VAR 0 7
16273: PPUSH
16274: LD_VAR 0 5
16278: PUSH
16279: LD_INT 1
16281: MINUS
16282: PPUSH
16283: LD_VAR 0 6
16287: PPUSH
16288: CALL_OW 1
16292: ST_TO_ADDR
// end ;
16293: GO 16210
16295: POP
16296: POP
// result := s_arr [ 1 ] ;
16297: LD_ADDR_VAR 0 4
16301: PUSH
16302: LD_VAR 0 7
16306: PUSH
16307: LD_INT 1
16309: ARRAY
16310: ST_TO_ADDR
// end ; end ;
16311: LD_VAR 0 4
16315: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16316: LD_INT 0
16318: PPUSH
16319: PPUSH
// if not list then
16320: LD_VAR 0 1
16324: NOT
16325: IFFALSE 16329
// exit ;
16327: GO 16420
// i := list [ pos1 ] ;
16329: LD_ADDR_VAR 0 5
16333: PUSH
16334: LD_VAR 0 1
16338: PUSH
16339: LD_VAR 0 2
16343: ARRAY
16344: ST_TO_ADDR
// if not i then
16345: LD_VAR 0 5
16349: NOT
16350: IFFALSE 16354
// exit ;
16352: GO 16420
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16354: LD_ADDR_VAR 0 1
16358: PUSH
16359: LD_VAR 0 1
16363: PPUSH
16364: LD_VAR 0 2
16368: PPUSH
16369: LD_VAR 0 1
16373: PUSH
16374: LD_VAR 0 3
16378: ARRAY
16379: PPUSH
16380: CALL_OW 1
16384: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16385: LD_ADDR_VAR 0 1
16389: PUSH
16390: LD_VAR 0 1
16394: PPUSH
16395: LD_VAR 0 3
16399: PPUSH
16400: LD_VAR 0 5
16404: PPUSH
16405: CALL_OW 1
16409: ST_TO_ADDR
// result := list ;
16410: LD_ADDR_VAR 0 4
16414: PUSH
16415: LD_VAR 0 1
16419: ST_TO_ADDR
// end ;
16420: LD_VAR 0 4
16424: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16425: LD_INT 0
16427: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16428: LD_ADDR_VAR 0 5
16432: PUSH
16433: LD_VAR 0 1
16437: PPUSH
16438: CALL_OW 250
16442: PPUSH
16443: LD_VAR 0 1
16447: PPUSH
16448: CALL_OW 251
16452: PPUSH
16453: LD_VAR 0 2
16457: PPUSH
16458: LD_VAR 0 3
16462: PPUSH
16463: LD_VAR 0 4
16467: PPUSH
16468: CALL 16478 0 5
16472: ST_TO_ADDR
// end ;
16473: LD_VAR 0 5
16477: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
16478: LD_INT 0
16480: PPUSH
16481: PPUSH
16482: PPUSH
16483: PPUSH
// if not list then
16484: LD_VAR 0 3
16488: NOT
16489: IFFALSE 16493
// exit ;
16491: GO 16881
// result := [ ] ;
16493: LD_ADDR_VAR 0 6
16497: PUSH
16498: EMPTY
16499: ST_TO_ADDR
// for i in list do
16500: LD_ADDR_VAR 0 7
16504: PUSH
16505: LD_VAR 0 3
16509: PUSH
16510: FOR_IN
16511: IFFALSE 16713
// begin tmp := GetDistUnitXY ( i , x , y ) ;
16513: LD_ADDR_VAR 0 9
16517: PUSH
16518: LD_VAR 0 7
16522: PPUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_VAR 0 2
16532: PPUSH
16533: CALL_OW 297
16537: ST_TO_ADDR
// if not result then
16538: LD_VAR 0 6
16542: NOT
16543: IFFALSE 16569
// result := [ [ i , tmp ] ] else
16545: LD_ADDR_VAR 0 6
16549: PUSH
16550: LD_VAR 0 7
16554: PUSH
16555: LD_VAR 0 9
16559: PUSH
16560: EMPTY
16561: LIST
16562: LIST
16563: PUSH
16564: EMPTY
16565: LIST
16566: ST_TO_ADDR
16567: GO 16711
// begin if result [ result ] [ 2 ] < tmp then
16569: LD_VAR 0 6
16573: PUSH
16574: LD_VAR 0 6
16578: ARRAY
16579: PUSH
16580: LD_INT 2
16582: ARRAY
16583: PUSH
16584: LD_VAR 0 9
16588: LESS
16589: IFFALSE 16631
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
16591: LD_ADDR_VAR 0 6
16595: PUSH
16596: LD_VAR 0 6
16600: PPUSH
16601: LD_VAR 0 6
16605: PUSH
16606: LD_INT 1
16608: PLUS
16609: PPUSH
16610: LD_VAR 0 7
16614: PUSH
16615: LD_VAR 0 9
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PPUSH
16624: CALL_OW 2
16628: ST_TO_ADDR
16629: GO 16711
// for j = 1 to result do
16631: LD_ADDR_VAR 0 8
16635: PUSH
16636: DOUBLE
16637: LD_INT 1
16639: DEC
16640: ST_TO_ADDR
16641: LD_VAR 0 6
16645: PUSH
16646: FOR_TO
16647: IFFALSE 16709
// begin if tmp < result [ j ] [ 2 ] then
16649: LD_VAR 0 9
16653: PUSH
16654: LD_VAR 0 6
16658: PUSH
16659: LD_VAR 0 8
16663: ARRAY
16664: PUSH
16665: LD_INT 2
16667: ARRAY
16668: LESS
16669: IFFALSE 16707
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16671: LD_ADDR_VAR 0 6
16675: PUSH
16676: LD_VAR 0 6
16680: PPUSH
16681: LD_VAR 0 8
16685: PPUSH
16686: LD_VAR 0 7
16690: PUSH
16691: LD_VAR 0 9
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PPUSH
16700: CALL_OW 2
16704: ST_TO_ADDR
// break ;
16705: GO 16709
// end ; end ;
16707: GO 16646
16709: POP
16710: POP
// end ; end ;
16711: GO 16510
16713: POP
16714: POP
// if result and not asc then
16715: LD_VAR 0 6
16719: PUSH
16720: LD_VAR 0 4
16724: NOT
16725: AND
16726: IFFALSE 16801
// begin tmp := result ;
16728: LD_ADDR_VAR 0 9
16732: PUSH
16733: LD_VAR 0 6
16737: ST_TO_ADDR
// for i = tmp downto 1 do
16738: LD_ADDR_VAR 0 7
16742: PUSH
16743: DOUBLE
16744: LD_VAR 0 9
16748: INC
16749: ST_TO_ADDR
16750: LD_INT 1
16752: PUSH
16753: FOR_DOWNTO
16754: IFFALSE 16799
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
16756: LD_ADDR_VAR 0 6
16760: PUSH
16761: LD_VAR 0 6
16765: PPUSH
16766: LD_VAR 0 9
16770: PUSH
16771: LD_VAR 0 7
16775: MINUS
16776: PUSH
16777: LD_INT 1
16779: PLUS
16780: PPUSH
16781: LD_VAR 0 9
16785: PUSH
16786: LD_VAR 0 7
16790: ARRAY
16791: PPUSH
16792: CALL_OW 1
16796: ST_TO_ADDR
16797: GO 16753
16799: POP
16800: POP
// end ; tmp := [ ] ;
16801: LD_ADDR_VAR 0 9
16805: PUSH
16806: EMPTY
16807: ST_TO_ADDR
// if mode then
16808: LD_VAR 0 5
16812: IFFALSE 16881
// begin for i = 1 to result do
16814: LD_ADDR_VAR 0 7
16818: PUSH
16819: DOUBLE
16820: LD_INT 1
16822: DEC
16823: ST_TO_ADDR
16824: LD_VAR 0 6
16828: PUSH
16829: FOR_TO
16830: IFFALSE 16869
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
16832: LD_ADDR_VAR 0 9
16836: PUSH
16837: LD_VAR 0 9
16841: PPUSH
16842: LD_VAR 0 7
16846: PPUSH
16847: LD_VAR 0 6
16851: PUSH
16852: LD_VAR 0 7
16856: ARRAY
16857: PUSH
16858: LD_INT 1
16860: ARRAY
16861: PPUSH
16862: CALL_OW 1
16866: ST_TO_ADDR
16867: GO 16829
16869: POP
16870: POP
// result := tmp ;
16871: LD_ADDR_VAR 0 6
16875: PUSH
16876: LD_VAR 0 9
16880: ST_TO_ADDR
// end ; end ;
16881: LD_VAR 0 6
16885: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
16886: LD_INT 0
16888: PPUSH
16889: PPUSH
16890: PPUSH
16891: PPUSH
16892: PPUSH
16893: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
16894: LD_ADDR_VAR 0 5
16898: PUSH
16899: LD_INT 0
16901: PUSH
16902: LD_INT 0
16904: PUSH
16905: LD_INT 0
16907: PUSH
16908: EMPTY
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: ST_TO_ADDR
// if not x or not y then
16916: LD_VAR 0 2
16920: NOT
16921: PUSH
16922: LD_VAR 0 3
16926: NOT
16927: OR
16928: IFFALSE 16932
// exit ;
16930: GO 18584
// if not range then
16932: LD_VAR 0 4
16936: NOT
16937: IFFALSE 16947
// range := 10 ;
16939: LD_ADDR_VAR 0 4
16943: PUSH
16944: LD_INT 10
16946: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16947: LD_ADDR_VAR 0 8
16951: PUSH
16952: LD_INT 81
16954: PUSH
16955: LD_VAR 0 1
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PUSH
16964: LD_INT 92
16966: PUSH
16967: LD_VAR 0 2
16971: PUSH
16972: LD_VAR 0 3
16976: PUSH
16977: LD_VAR 0 4
16981: PUSH
16982: EMPTY
16983: LIST
16984: LIST
16985: LIST
16986: LIST
16987: PUSH
16988: LD_INT 3
16990: PUSH
16991: LD_INT 21
16993: PUSH
16994: LD_INT 3
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: PUSH
17001: EMPTY
17002: LIST
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: PPUSH
17010: CALL_OW 69
17014: ST_TO_ADDR
// if not tmp then
17015: LD_VAR 0 8
17019: NOT
17020: IFFALSE 17024
// exit ;
17022: GO 18584
// for i in tmp do
17024: LD_ADDR_VAR 0 6
17028: PUSH
17029: LD_VAR 0 8
17033: PUSH
17034: FOR_IN
17035: IFFALSE 18559
// begin points := [ 0 , 0 , 0 ] ;
17037: LD_ADDR_VAR 0 9
17041: PUSH
17042: LD_INT 0
17044: PUSH
17045: LD_INT 0
17047: PUSH
17048: LD_INT 0
17050: PUSH
17051: EMPTY
17052: LIST
17053: LIST
17054: LIST
17055: ST_TO_ADDR
// bpoints := 1 ;
17056: LD_ADDR_VAR 0 10
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17064: LD_VAR 0 6
17068: PPUSH
17069: CALL_OW 247
17073: PUSH
17074: LD_INT 1
17076: DOUBLE
17077: EQUAL
17078: IFTRUE 17082
17080: GO 17660
17082: POP
// begin if GetClass ( i ) = 1 then
17083: LD_VAR 0 6
17087: PPUSH
17088: CALL_OW 257
17092: PUSH
17093: LD_INT 1
17095: EQUAL
17096: IFFALSE 17117
// points := [ 10 , 5 , 3 ] ;
17098: LD_ADDR_VAR 0 9
17102: PUSH
17103: LD_INT 10
17105: PUSH
17106: LD_INT 5
17108: PUSH
17109: LD_INT 3
17111: PUSH
17112: EMPTY
17113: LIST
17114: LIST
17115: LIST
17116: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17117: LD_VAR 0 6
17121: PPUSH
17122: CALL_OW 257
17126: PUSH
17127: LD_INT 2
17129: PUSH
17130: LD_INT 3
17132: PUSH
17133: LD_INT 4
17135: PUSH
17136: EMPTY
17137: LIST
17138: LIST
17139: LIST
17140: IN
17141: IFFALSE 17162
// points := [ 3 , 2 , 1 ] ;
17143: LD_ADDR_VAR 0 9
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 2
17153: PUSH
17154: LD_INT 1
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17162: LD_VAR 0 6
17166: PPUSH
17167: CALL_OW 257
17171: PUSH
17172: LD_INT 5
17174: EQUAL
17175: IFFALSE 17196
// points := [ 130 , 5 , 2 ] ;
17177: LD_ADDR_VAR 0 9
17181: PUSH
17182: LD_INT 130
17184: PUSH
17185: LD_INT 5
17187: PUSH
17188: LD_INT 2
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: LIST
17195: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17196: LD_VAR 0 6
17200: PPUSH
17201: CALL_OW 257
17205: PUSH
17206: LD_INT 8
17208: EQUAL
17209: IFFALSE 17230
// points := [ 35 , 35 , 30 ] ;
17211: LD_ADDR_VAR 0 9
17215: PUSH
17216: LD_INT 35
17218: PUSH
17219: LD_INT 35
17221: PUSH
17222: LD_INT 30
17224: PUSH
17225: EMPTY
17226: LIST
17227: LIST
17228: LIST
17229: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17230: LD_VAR 0 6
17234: PPUSH
17235: CALL_OW 257
17239: PUSH
17240: LD_INT 9
17242: EQUAL
17243: IFFALSE 17264
// points := [ 20 , 55 , 40 ] ;
17245: LD_ADDR_VAR 0 9
17249: PUSH
17250: LD_INT 20
17252: PUSH
17253: LD_INT 55
17255: PUSH
17256: LD_INT 40
17258: PUSH
17259: EMPTY
17260: LIST
17261: LIST
17262: LIST
17263: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17264: LD_VAR 0 6
17268: PPUSH
17269: CALL_OW 257
17273: PUSH
17274: LD_INT 12
17276: PUSH
17277: LD_INT 16
17279: PUSH
17280: EMPTY
17281: LIST
17282: LIST
17283: IN
17284: IFFALSE 17305
// points := [ 5 , 3 , 2 ] ;
17286: LD_ADDR_VAR 0 9
17290: PUSH
17291: LD_INT 5
17293: PUSH
17294: LD_INT 3
17296: PUSH
17297: LD_INT 2
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: LIST
17304: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17305: LD_VAR 0 6
17309: PPUSH
17310: CALL_OW 257
17314: PUSH
17315: LD_INT 17
17317: EQUAL
17318: IFFALSE 17339
// points := [ 100 , 50 , 75 ] ;
17320: LD_ADDR_VAR 0 9
17324: PUSH
17325: LD_INT 100
17327: PUSH
17328: LD_INT 50
17330: PUSH
17331: LD_INT 75
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: LIST
17338: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17339: LD_VAR 0 6
17343: PPUSH
17344: CALL_OW 257
17348: PUSH
17349: LD_INT 15
17351: EQUAL
17352: IFFALSE 17373
// points := [ 10 , 5 , 3 ] ;
17354: LD_ADDR_VAR 0 9
17358: PUSH
17359: LD_INT 10
17361: PUSH
17362: LD_INT 5
17364: PUSH
17365: LD_INT 3
17367: PUSH
17368: EMPTY
17369: LIST
17370: LIST
17371: LIST
17372: ST_TO_ADDR
// if GetClass ( i ) = 14 then
17373: LD_VAR 0 6
17377: PPUSH
17378: CALL_OW 257
17382: PUSH
17383: LD_INT 14
17385: EQUAL
17386: IFFALSE 17407
// points := [ 10 , 0 , 0 ] ;
17388: LD_ADDR_VAR 0 9
17392: PUSH
17393: LD_INT 10
17395: PUSH
17396: LD_INT 0
17398: PUSH
17399: LD_INT 0
17401: PUSH
17402: EMPTY
17403: LIST
17404: LIST
17405: LIST
17406: ST_TO_ADDR
// if GetClass ( i ) = 11 then
17407: LD_VAR 0 6
17411: PPUSH
17412: CALL_OW 257
17416: PUSH
17417: LD_INT 11
17419: EQUAL
17420: IFFALSE 17441
// points := [ 30 , 10 , 5 ] ;
17422: LD_ADDR_VAR 0 9
17426: PUSH
17427: LD_INT 30
17429: PUSH
17430: LD_INT 10
17432: PUSH
17433: LD_INT 5
17435: PUSH
17436: EMPTY
17437: LIST
17438: LIST
17439: LIST
17440: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
17441: LD_VAR 0 1
17445: PPUSH
17446: LD_INT 5
17448: PPUSH
17449: CALL_OW 321
17453: PUSH
17454: LD_INT 2
17456: EQUAL
17457: IFFALSE 17474
// bpoints := bpoints * 1.8 ;
17459: LD_ADDR_VAR 0 10
17463: PUSH
17464: LD_VAR 0 10
17468: PUSH
17469: LD_REAL  1.80000000000000E+0000
17472: MUL
17473: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
17474: LD_VAR 0 6
17478: PPUSH
17479: CALL_OW 257
17483: PUSH
17484: LD_INT 1
17486: PUSH
17487: LD_INT 2
17489: PUSH
17490: LD_INT 3
17492: PUSH
17493: LD_INT 4
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: IN
17502: PUSH
17503: LD_VAR 0 1
17507: PPUSH
17508: LD_INT 51
17510: PPUSH
17511: CALL_OW 321
17515: PUSH
17516: LD_INT 2
17518: EQUAL
17519: AND
17520: IFFALSE 17537
// bpoints := bpoints * 1.2 ;
17522: LD_ADDR_VAR 0 10
17526: PUSH
17527: LD_VAR 0 10
17531: PUSH
17532: LD_REAL  1.20000000000000E+0000
17535: MUL
17536: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
17537: LD_VAR 0 6
17541: PPUSH
17542: CALL_OW 257
17546: PUSH
17547: LD_INT 5
17549: PUSH
17550: LD_INT 7
17552: PUSH
17553: LD_INT 9
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: LIST
17560: IN
17561: PUSH
17562: LD_VAR 0 1
17566: PPUSH
17567: LD_INT 52
17569: PPUSH
17570: CALL_OW 321
17574: PUSH
17575: LD_INT 2
17577: EQUAL
17578: AND
17579: IFFALSE 17596
// bpoints := bpoints * 1.5 ;
17581: LD_ADDR_VAR 0 10
17585: PUSH
17586: LD_VAR 0 10
17590: PUSH
17591: LD_REAL  1.50000000000000E+0000
17594: MUL
17595: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
17596: LD_VAR 0 1
17600: PPUSH
17601: LD_INT 66
17603: PPUSH
17604: CALL_OW 321
17608: PUSH
17609: LD_INT 2
17611: EQUAL
17612: IFFALSE 17629
// bpoints := bpoints * 1.1 ;
17614: LD_ADDR_VAR 0 10
17618: PUSH
17619: LD_VAR 0 10
17623: PUSH
17624: LD_REAL  1.10000000000000E+0000
17627: MUL
17628: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
17629: LD_ADDR_VAR 0 10
17633: PUSH
17634: LD_VAR 0 10
17638: PUSH
17639: LD_VAR 0 6
17643: PPUSH
17644: LD_INT 1
17646: PPUSH
17647: CALL_OW 259
17651: PUSH
17652: LD_REAL  1.15000000000000E+0000
17655: MUL
17656: MUL
17657: ST_TO_ADDR
// end ; unit_vehicle :
17658: GO 18488
17660: LD_INT 2
17662: DOUBLE
17663: EQUAL
17664: IFTRUE 17668
17666: GO 18476
17668: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
17669: LD_VAR 0 6
17673: PPUSH
17674: CALL_OW 264
17678: PUSH
17679: LD_INT 2
17681: PUSH
17682: LD_INT 42
17684: PUSH
17685: LD_INT 24
17687: PUSH
17688: EMPTY
17689: LIST
17690: LIST
17691: LIST
17692: IN
17693: IFFALSE 17714
// points := [ 25 , 5 , 3 ] ;
17695: LD_ADDR_VAR 0 9
17699: PUSH
17700: LD_INT 25
17702: PUSH
17703: LD_INT 5
17705: PUSH
17706: LD_INT 3
17708: PUSH
17709: EMPTY
17710: LIST
17711: LIST
17712: LIST
17713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
17714: LD_VAR 0 6
17718: PPUSH
17719: CALL_OW 264
17723: PUSH
17724: LD_INT 4
17726: PUSH
17727: LD_INT 43
17729: PUSH
17730: LD_INT 25
17732: PUSH
17733: EMPTY
17734: LIST
17735: LIST
17736: LIST
17737: IN
17738: IFFALSE 17759
// points := [ 40 , 15 , 5 ] ;
17740: LD_ADDR_VAR 0 9
17744: PUSH
17745: LD_INT 40
17747: PUSH
17748: LD_INT 15
17750: PUSH
17751: LD_INT 5
17753: PUSH
17754: EMPTY
17755: LIST
17756: LIST
17757: LIST
17758: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
17759: LD_VAR 0 6
17763: PPUSH
17764: CALL_OW 264
17768: PUSH
17769: LD_INT 3
17771: PUSH
17772: LD_INT 23
17774: PUSH
17775: EMPTY
17776: LIST
17777: LIST
17778: IN
17779: IFFALSE 17800
// points := [ 7 , 25 , 8 ] ;
17781: LD_ADDR_VAR 0 9
17785: PUSH
17786: LD_INT 7
17788: PUSH
17789: LD_INT 25
17791: PUSH
17792: LD_INT 8
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
17800: LD_VAR 0 6
17804: PPUSH
17805: CALL_OW 264
17809: PUSH
17810: LD_INT 5
17812: PUSH
17813: LD_INT 27
17815: PUSH
17816: LD_INT 44
17818: PUSH
17819: EMPTY
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: IFFALSE 17845
// points := [ 14 , 50 , 16 ] ;
17826: LD_ADDR_VAR 0 9
17830: PUSH
17831: LD_INT 14
17833: PUSH
17834: LD_INT 50
17836: PUSH
17837: LD_INT 16
17839: PUSH
17840: EMPTY
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
17845: LD_VAR 0 6
17849: PPUSH
17850: CALL_OW 264
17854: PUSH
17855: LD_INT 6
17857: PUSH
17858: LD_INT 46
17860: PUSH
17861: EMPTY
17862: LIST
17863: LIST
17864: IN
17865: IFFALSE 17886
// points := [ 32 , 120 , 70 ] ;
17867: LD_ADDR_VAR 0 9
17871: PUSH
17872: LD_INT 32
17874: PUSH
17875: LD_INT 120
17877: PUSH
17878: LD_INT 70
17880: PUSH
17881: EMPTY
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
17886: LD_VAR 0 6
17890: PPUSH
17891: CALL_OW 264
17895: PUSH
17896: LD_INT 7
17898: PUSH
17899: LD_INT 28
17901: PUSH
17902: LD_INT 45
17904: PUSH
17905: LD_EXP 72
17909: PUSH
17910: EMPTY
17911: LIST
17912: LIST
17913: LIST
17914: LIST
17915: IN
17916: IFFALSE 17937
// points := [ 35 , 20 , 45 ] ;
17918: LD_ADDR_VAR 0 9
17922: PUSH
17923: LD_INT 35
17925: PUSH
17926: LD_INT 20
17928: PUSH
17929: LD_INT 45
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
17937: LD_VAR 0 6
17941: PPUSH
17942: CALL_OW 264
17946: PUSH
17947: LD_INT 47
17949: PUSH
17950: EMPTY
17951: LIST
17952: IN
17953: IFFALSE 17974
// points := [ 67 , 45 , 75 ] ;
17955: LD_ADDR_VAR 0 9
17959: PUSH
17960: LD_INT 67
17962: PUSH
17963: LD_INT 45
17965: PUSH
17966: LD_INT 75
17968: PUSH
17969: EMPTY
17970: LIST
17971: LIST
17972: LIST
17973: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
17974: LD_VAR 0 6
17978: PPUSH
17979: CALL_OW 264
17983: PUSH
17984: LD_INT 26
17986: PUSH
17987: EMPTY
17988: LIST
17989: IN
17990: IFFALSE 18011
// points := [ 120 , 30 , 80 ] ;
17992: LD_ADDR_VAR 0 9
17996: PUSH
17997: LD_INT 120
17999: PUSH
18000: LD_INT 30
18002: PUSH
18003: LD_INT 80
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18011: LD_VAR 0 6
18015: PPUSH
18016: CALL_OW 264
18020: PUSH
18021: LD_INT 22
18023: PUSH
18024: EMPTY
18025: LIST
18026: IN
18027: IFFALSE 18048
// points := [ 40 , 1 , 1 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 40
18036: PUSH
18037: LD_INT 1
18039: PUSH
18040: LD_INT 1
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 264
18057: PUSH
18058: LD_INT 29
18060: PUSH
18061: EMPTY
18062: LIST
18063: IN
18064: IFFALSE 18085
// points := [ 70 , 200 , 400 ] ;
18066: LD_ADDR_VAR 0 9
18070: PUSH
18071: LD_INT 70
18073: PUSH
18074: LD_INT 200
18076: PUSH
18077: LD_INT 400
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: LIST
18084: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18085: LD_VAR 0 6
18089: PPUSH
18090: CALL_OW 264
18094: PUSH
18095: LD_INT 14
18097: PUSH
18098: LD_INT 53
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: IN
18105: IFFALSE 18126
// points := [ 40 , 10 , 20 ] ;
18107: LD_ADDR_VAR 0 9
18111: PUSH
18112: LD_INT 40
18114: PUSH
18115: LD_INT 10
18117: PUSH
18118: LD_INT 20
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18126: LD_VAR 0 6
18130: PPUSH
18131: CALL_OW 264
18135: PUSH
18136: LD_INT 9
18138: PUSH
18139: EMPTY
18140: LIST
18141: IN
18142: IFFALSE 18163
// points := [ 5 , 70 , 20 ] ;
18144: LD_ADDR_VAR 0 9
18148: PUSH
18149: LD_INT 5
18151: PUSH
18152: LD_INT 70
18154: PUSH
18155: LD_INT 20
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: LIST
18162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18163: LD_VAR 0 6
18167: PPUSH
18168: CALL_OW 264
18172: PUSH
18173: LD_INT 10
18175: PUSH
18176: EMPTY
18177: LIST
18178: IN
18179: IFFALSE 18200
// points := [ 35 , 110 , 70 ] ;
18181: LD_ADDR_VAR 0 9
18185: PUSH
18186: LD_INT 35
18188: PUSH
18189: LD_INT 110
18191: PUSH
18192: LD_INT 70
18194: PUSH
18195: EMPTY
18196: LIST
18197: LIST
18198: LIST
18199: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18200: LD_VAR 0 6
18204: PPUSH
18205: CALL_OW 265
18209: PUSH
18210: LD_INT 25
18212: EQUAL
18213: IFFALSE 18234
// points := [ 80 , 65 , 100 ] ;
18215: LD_ADDR_VAR 0 9
18219: PUSH
18220: LD_INT 80
18222: PUSH
18223: LD_INT 65
18225: PUSH
18226: LD_INT 100
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: LIST
18233: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18234: LD_VAR 0 6
18238: PPUSH
18239: CALL_OW 263
18243: PUSH
18244: LD_INT 1
18246: EQUAL
18247: IFFALSE 18282
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18249: LD_ADDR_VAR 0 10
18253: PUSH
18254: LD_VAR 0 10
18258: PUSH
18259: LD_VAR 0 6
18263: PPUSH
18264: CALL_OW 311
18268: PPUSH
18269: LD_INT 3
18271: PPUSH
18272: CALL_OW 259
18276: PUSH
18277: LD_INT 4
18279: MUL
18280: MUL
18281: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18282: LD_VAR 0 6
18286: PPUSH
18287: CALL_OW 263
18291: PUSH
18292: LD_INT 2
18294: EQUAL
18295: IFFALSE 18346
// begin j := IsControledBy ( i ) ;
18297: LD_ADDR_VAR 0 7
18301: PUSH
18302: LD_VAR 0 6
18306: PPUSH
18307: CALL_OW 312
18311: ST_TO_ADDR
// if j then
18312: LD_VAR 0 7
18316: IFFALSE 18346
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18318: LD_ADDR_VAR 0 10
18322: PUSH
18323: LD_VAR 0 10
18327: PUSH
18328: LD_VAR 0 7
18332: PPUSH
18333: LD_INT 3
18335: PPUSH
18336: CALL_OW 259
18340: PUSH
18341: LD_INT 3
18343: MUL
18344: MUL
18345: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18346: LD_VAR 0 6
18350: PPUSH
18351: CALL_OW 264
18355: PUSH
18356: LD_INT 5
18358: PUSH
18359: LD_INT 6
18361: PUSH
18362: LD_INT 46
18364: PUSH
18365: LD_INT 44
18367: PUSH
18368: LD_INT 47
18370: PUSH
18371: LD_INT 45
18373: PUSH
18374: LD_INT 28
18376: PUSH
18377: LD_INT 7
18379: PUSH
18380: LD_INT 27
18382: PUSH
18383: LD_INT 29
18385: PUSH
18386: EMPTY
18387: LIST
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: LIST
18395: LIST
18396: LIST
18397: IN
18398: PUSH
18399: LD_VAR 0 1
18403: PPUSH
18404: LD_INT 52
18406: PPUSH
18407: CALL_OW 321
18411: PUSH
18412: LD_INT 2
18414: EQUAL
18415: AND
18416: IFFALSE 18433
// bpoints := bpoints * 1.2 ;
18418: LD_ADDR_VAR 0 10
18422: PUSH
18423: LD_VAR 0 10
18427: PUSH
18428: LD_REAL  1.20000000000000E+0000
18431: MUL
18432: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
18433: LD_VAR 0 6
18437: PPUSH
18438: CALL_OW 264
18442: PUSH
18443: LD_INT 6
18445: PUSH
18446: LD_INT 46
18448: PUSH
18449: LD_INT 47
18451: PUSH
18452: EMPTY
18453: LIST
18454: LIST
18455: LIST
18456: IN
18457: IFFALSE 18474
// bpoints := bpoints * 1.2 ;
18459: LD_ADDR_VAR 0 10
18463: PUSH
18464: LD_VAR 0 10
18468: PUSH
18469: LD_REAL  1.20000000000000E+0000
18472: MUL
18473: ST_TO_ADDR
// end ; unit_building :
18474: GO 18488
18476: LD_INT 3
18478: DOUBLE
18479: EQUAL
18480: IFTRUE 18484
18482: GO 18487
18484: POP
// ; end ;
18485: GO 18488
18487: POP
// for j = 1 to 3 do
18488: LD_ADDR_VAR 0 7
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 3
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18555
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
18504: LD_ADDR_VAR 0 5
18508: PUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: LD_VAR 0 7
18518: PPUSH
18519: LD_VAR 0 5
18523: PUSH
18524: LD_VAR 0 7
18528: ARRAY
18529: PUSH
18530: LD_VAR 0 9
18534: PUSH
18535: LD_VAR 0 7
18539: ARRAY
18540: PUSH
18541: LD_VAR 0 10
18545: MUL
18546: PLUS
18547: PPUSH
18548: CALL_OW 1
18552: ST_TO_ADDR
18553: GO 18501
18555: POP
18556: POP
// end ;
18557: GO 17034
18559: POP
18560: POP
// result := Replace ( result , 4 , tmp ) ;
18561: LD_ADDR_VAR 0 5
18565: PUSH
18566: LD_VAR 0 5
18570: PPUSH
18571: LD_INT 4
18573: PPUSH
18574: LD_VAR 0 8
18578: PPUSH
18579: CALL_OW 1
18583: ST_TO_ADDR
// end ;
18584: LD_VAR 0 5
18588: RET
// export function DangerAtRange ( unit , range ) ; begin
18589: LD_INT 0
18591: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
18592: LD_ADDR_VAR 0 3
18596: PUSH
18597: LD_VAR 0 1
18601: PPUSH
18602: CALL_OW 255
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL_OW 250
18616: PPUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL_OW 251
18626: PPUSH
18627: LD_VAR 0 2
18631: PPUSH
18632: CALL 16886 0 4
18636: ST_TO_ADDR
// end ;
18637: LD_VAR 0 3
18641: RET
// export function DangerInArea ( side , area ) ; begin
18642: LD_INT 0
18644: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
18645: LD_ADDR_VAR 0 3
18649: PUSH
18650: LD_VAR 0 2
18654: PPUSH
18655: LD_INT 81
18657: PUSH
18658: LD_VAR 0 1
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: PPUSH
18667: CALL_OW 70
18671: ST_TO_ADDR
// end ;
18672: LD_VAR 0 3
18676: RET
// export function IsExtension ( b ) ; begin
18677: LD_INT 0
18679: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
18680: LD_ADDR_VAR 0 2
18684: PUSH
18685: LD_VAR 0 1
18689: PUSH
18690: LD_INT 23
18692: PUSH
18693: LD_INT 20
18695: PUSH
18696: LD_INT 22
18698: PUSH
18699: LD_INT 17
18701: PUSH
18702: LD_INT 24
18704: PUSH
18705: LD_INT 21
18707: PUSH
18708: LD_INT 19
18710: PUSH
18711: LD_INT 16
18713: PUSH
18714: LD_INT 25
18716: PUSH
18717: LD_INT 18
18719: PUSH
18720: EMPTY
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: IN
18732: ST_TO_ADDR
// end ;
18733: LD_VAR 0 2
18737: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
18738: LD_INT 0
18740: PPUSH
18741: PPUSH
18742: PPUSH
// result := [ ] ;
18743: LD_ADDR_VAR 0 4
18747: PUSH
18748: EMPTY
18749: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
18750: LD_ADDR_VAR 0 5
18754: PUSH
18755: LD_VAR 0 2
18759: PPUSH
18760: LD_INT 21
18762: PUSH
18763: LD_INT 3
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PPUSH
18770: CALL_OW 70
18774: ST_TO_ADDR
// if not tmp then
18775: LD_VAR 0 5
18779: NOT
18780: IFFALSE 18784
// exit ;
18782: GO 18848
// if checkLink then
18784: LD_VAR 0 3
18788: IFFALSE 18838
// begin for i in tmp do
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: LD_VAR 0 5
18799: PUSH
18800: FOR_IN
18801: IFFALSE 18836
// if GetBase ( i ) <> base then
18803: LD_VAR 0 6
18807: PPUSH
18808: CALL_OW 274
18812: PUSH
18813: LD_VAR 0 1
18817: NONEQUAL
18818: IFFALSE 18834
// ComLinkToBase ( base , i ) ;
18820: LD_VAR 0 1
18824: PPUSH
18825: LD_VAR 0 6
18829: PPUSH
18830: CALL_OW 169
18834: GO 18800
18836: POP
18837: POP
// end ; result := tmp ;
18838: LD_ADDR_VAR 0 4
18842: PUSH
18843: LD_VAR 0 5
18847: ST_TO_ADDR
// end ;
18848: LD_VAR 0 4
18852: RET
// export function ComComplete ( units , b ) ; var i ; begin
18853: LD_INT 0
18855: PPUSH
18856: PPUSH
// if not units then
18857: LD_VAR 0 1
18861: NOT
18862: IFFALSE 18866
// exit ;
18864: GO 18956
// for i in units do
18866: LD_ADDR_VAR 0 4
18870: PUSH
18871: LD_VAR 0 1
18875: PUSH
18876: FOR_IN
18877: IFFALSE 18954
// if BuildingStatus ( b ) = bs_build then
18879: LD_VAR 0 2
18883: PPUSH
18884: CALL_OW 461
18888: PUSH
18889: LD_INT 1
18891: EQUAL
18892: IFFALSE 18952
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
18894: LD_VAR 0 4
18898: PPUSH
18899: LD_STRING h
18901: PUSH
18902: LD_VAR 0 2
18906: PPUSH
18907: CALL_OW 250
18911: PUSH
18912: LD_VAR 0 2
18916: PPUSH
18917: CALL_OW 251
18921: PUSH
18922: LD_VAR 0 2
18926: PUSH
18927: LD_INT 0
18929: PUSH
18930: LD_INT 0
18932: PUSH
18933: LD_INT 0
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: PUSH
18945: EMPTY
18946: LIST
18947: PPUSH
18948: CALL_OW 446
18952: GO 18876
18954: POP
18955: POP
// end ;
18956: LD_VAR 0 3
18960: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
18961: LD_INT 0
18963: PPUSH
18964: PPUSH
18965: PPUSH
18966: PPUSH
18967: PPUSH
18968: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
18969: LD_VAR 0 1
18973: NOT
18974: PUSH
18975: LD_VAR 0 1
18979: PPUSH
18980: CALL_OW 263
18984: PUSH
18985: LD_INT 2
18987: NONEQUAL
18988: OR
18989: IFFALSE 18993
// exit ;
18991: GO 19309
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
18993: LD_ADDR_VAR 0 6
18997: PUSH
18998: LD_INT 22
19000: PUSH
19001: LD_VAR 0 1
19005: PPUSH
19006: CALL_OW 255
19010: PUSH
19011: EMPTY
19012: LIST
19013: LIST
19014: PUSH
19015: LD_INT 2
19017: PUSH
19018: LD_INT 30
19020: PUSH
19021: LD_INT 36
19023: PUSH
19024: EMPTY
19025: LIST
19026: LIST
19027: PUSH
19028: LD_INT 34
19030: PUSH
19031: LD_INT 31
19033: PUSH
19034: EMPTY
19035: LIST
19036: LIST
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: PPUSH
19047: CALL_OW 69
19051: ST_TO_ADDR
// if not tmp then
19052: LD_VAR 0 6
19056: NOT
19057: IFFALSE 19061
// exit ;
19059: GO 19309
// result := [ ] ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: EMPTY
19067: ST_TO_ADDR
// for i in tmp do
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_VAR 0 6
19077: PUSH
19078: FOR_IN
19079: IFFALSE 19150
// begin t := UnitsInside ( i ) ;
19081: LD_ADDR_VAR 0 4
19085: PUSH
19086: LD_VAR 0 3
19090: PPUSH
19091: CALL_OW 313
19095: ST_TO_ADDR
// if t then
19096: LD_VAR 0 4
19100: IFFALSE 19148
// for j in t do
19102: LD_ADDR_VAR 0 7
19106: PUSH
19107: LD_VAR 0 4
19111: PUSH
19112: FOR_IN
19113: IFFALSE 19146
// result := Replace ( result , result + 1 , j ) ;
19115: LD_ADDR_VAR 0 2
19119: PUSH
19120: LD_VAR 0 2
19124: PPUSH
19125: LD_VAR 0 2
19129: PUSH
19130: LD_INT 1
19132: PLUS
19133: PPUSH
19134: LD_VAR 0 7
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
19144: GO 19112
19146: POP
19147: POP
// end ;
19148: GO 19078
19150: POP
19151: POP
// if not result then
19152: LD_VAR 0 2
19156: NOT
19157: IFFALSE 19161
// exit ;
19159: GO 19309
// mech := result [ 1 ] ;
19161: LD_ADDR_VAR 0 5
19165: PUSH
19166: LD_VAR 0 2
19170: PUSH
19171: LD_INT 1
19173: ARRAY
19174: ST_TO_ADDR
// if result > 1 then
19175: LD_VAR 0 2
19179: PUSH
19180: LD_INT 1
19182: GREATER
19183: IFFALSE 19295
// begin for i = 2 to result do
19185: LD_ADDR_VAR 0 3
19189: PUSH
19190: DOUBLE
19191: LD_INT 2
19193: DEC
19194: ST_TO_ADDR
19195: LD_VAR 0 2
19199: PUSH
19200: FOR_TO
19201: IFFALSE 19293
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19203: LD_ADDR_VAR 0 4
19207: PUSH
19208: LD_VAR 0 2
19212: PUSH
19213: LD_VAR 0 3
19217: ARRAY
19218: PPUSH
19219: LD_INT 3
19221: PPUSH
19222: CALL_OW 259
19226: PUSH
19227: LD_VAR 0 2
19231: PUSH
19232: LD_VAR 0 3
19236: ARRAY
19237: PPUSH
19238: CALL_OW 432
19242: MINUS
19243: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19244: LD_VAR 0 4
19248: PUSH
19249: LD_VAR 0 5
19253: PPUSH
19254: LD_INT 3
19256: PPUSH
19257: CALL_OW 259
19261: PUSH
19262: LD_VAR 0 5
19266: PPUSH
19267: CALL_OW 432
19271: MINUS
19272: GREATEREQUAL
19273: IFFALSE 19291
// mech := result [ i ] ;
19275: LD_ADDR_VAR 0 5
19279: PUSH
19280: LD_VAR 0 2
19284: PUSH
19285: LD_VAR 0 3
19289: ARRAY
19290: ST_TO_ADDR
// end ;
19291: GO 19200
19293: POP
19294: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19295: LD_VAR 0 1
19299: PPUSH
19300: LD_VAR 0 5
19304: PPUSH
19305: CALL_OW 135
// end ;
19309: LD_VAR 0 2
19313: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19314: LD_INT 0
19316: PPUSH
19317: PPUSH
19318: PPUSH
19319: PPUSH
19320: PPUSH
19321: PPUSH
19322: PPUSH
19323: PPUSH
19324: PPUSH
19325: PPUSH
19326: PPUSH
19327: PPUSH
19328: PPUSH
// result := [ ] ;
19329: LD_ADDR_VAR 0 7
19333: PUSH
19334: EMPTY
19335: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19336: LD_VAR 0 1
19340: PPUSH
19341: CALL_OW 266
19345: PUSH
19346: LD_INT 0
19348: PUSH
19349: LD_INT 1
19351: PUSH
19352: EMPTY
19353: LIST
19354: LIST
19355: IN
19356: NOT
19357: IFFALSE 19361
// exit ;
19359: GO 20995
// if name then
19361: LD_VAR 0 3
19365: IFFALSE 19381
// SetBName ( base_dep , name ) ;
19367: LD_VAR 0 1
19371: PPUSH
19372: LD_VAR 0 3
19376: PPUSH
19377: CALL_OW 500
// base := GetBase ( base_dep ) ;
19381: LD_ADDR_VAR 0 15
19385: PUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: CALL_OW 274
19395: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
19396: LD_ADDR_VAR 0 16
19400: PUSH
19401: LD_VAR 0 1
19405: PPUSH
19406: CALL_OW 255
19410: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
19411: LD_ADDR_VAR 0 17
19415: PUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: CALL_OW 248
19425: ST_TO_ADDR
// if sources then
19426: LD_VAR 0 5
19430: IFFALSE 19477
// for i = 1 to 3 do
19432: LD_ADDR_VAR 0 8
19436: PUSH
19437: DOUBLE
19438: LD_INT 1
19440: DEC
19441: ST_TO_ADDR
19442: LD_INT 3
19444: PUSH
19445: FOR_TO
19446: IFFALSE 19475
// AddResourceType ( base , i , sources [ i ] ) ;
19448: LD_VAR 0 15
19452: PPUSH
19453: LD_VAR 0 8
19457: PPUSH
19458: LD_VAR 0 5
19462: PUSH
19463: LD_VAR 0 8
19467: ARRAY
19468: PPUSH
19469: CALL_OW 276
19473: GO 19445
19475: POP
19476: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
19477: LD_ADDR_VAR 0 18
19481: PUSH
19482: LD_VAR 0 15
19486: PPUSH
19487: LD_VAR 0 2
19491: PPUSH
19492: LD_INT 1
19494: PPUSH
19495: CALL 18738 0 3
19499: ST_TO_ADDR
// InitHc ;
19500: CALL_OW 19
// InitUc ;
19504: CALL_OW 18
// uc_side := side ;
19508: LD_ADDR_OWVAR 20
19512: PUSH
19513: LD_VAR 0 16
19517: ST_TO_ADDR
// uc_nation := nation ;
19518: LD_ADDR_OWVAR 21
19522: PUSH
19523: LD_VAR 0 17
19527: ST_TO_ADDR
// if buildings then
19528: LD_VAR 0 18
19532: IFFALSE 20854
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
19534: LD_ADDR_VAR 0 19
19538: PUSH
19539: LD_VAR 0 18
19543: PPUSH
19544: LD_INT 2
19546: PUSH
19547: LD_INT 30
19549: PUSH
19550: LD_INT 29
19552: PUSH
19553: EMPTY
19554: LIST
19555: LIST
19556: PUSH
19557: LD_INT 30
19559: PUSH
19560: LD_INT 30
19562: PUSH
19563: EMPTY
19564: LIST
19565: LIST
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: LIST
19571: PPUSH
19572: CALL_OW 72
19576: ST_TO_ADDR
// if tmp then
19577: LD_VAR 0 19
19581: IFFALSE 19629
// for i in tmp do
19583: LD_ADDR_VAR 0 8
19587: PUSH
19588: LD_VAR 0 19
19592: PUSH
19593: FOR_IN
19594: IFFALSE 19627
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
19596: LD_VAR 0 8
19600: PPUSH
19601: CALL_OW 250
19605: PPUSH
19606: LD_VAR 0 8
19610: PPUSH
19611: CALL_OW 251
19615: PPUSH
19616: LD_VAR 0 16
19620: PPUSH
19621: CALL_OW 441
19625: GO 19593
19627: POP
19628: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
19629: LD_VAR 0 18
19633: PPUSH
19634: LD_INT 2
19636: PUSH
19637: LD_INT 30
19639: PUSH
19640: LD_INT 32
19642: PUSH
19643: EMPTY
19644: LIST
19645: LIST
19646: PUSH
19647: LD_INT 30
19649: PUSH
19650: LD_INT 33
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: PUSH
19657: EMPTY
19658: LIST
19659: LIST
19660: LIST
19661: PPUSH
19662: CALL_OW 72
19666: IFFALSE 19754
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
19668: LD_ADDR_VAR 0 8
19672: PUSH
19673: LD_VAR 0 18
19677: PPUSH
19678: LD_INT 2
19680: PUSH
19681: LD_INT 30
19683: PUSH
19684: LD_INT 32
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: PUSH
19691: LD_INT 30
19693: PUSH
19694: LD_INT 33
19696: PUSH
19697: EMPTY
19698: LIST
19699: LIST
19700: PUSH
19701: EMPTY
19702: LIST
19703: LIST
19704: LIST
19705: PPUSH
19706: CALL_OW 72
19710: PUSH
19711: FOR_IN
19712: IFFALSE 19752
// begin if not GetBWeapon ( i ) then
19714: LD_VAR 0 8
19718: PPUSH
19719: CALL_OW 269
19723: NOT
19724: IFFALSE 19750
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
19726: LD_VAR 0 8
19730: PPUSH
19731: LD_VAR 0 8
19735: PPUSH
19736: LD_VAR 0 2
19740: PPUSH
19741: CALL 21000 0 2
19745: PPUSH
19746: CALL_OW 431
// end ;
19750: GO 19711
19752: POP
19753: POP
// end ; for i = 1 to personel do
19754: LD_ADDR_VAR 0 8
19758: PUSH
19759: DOUBLE
19760: LD_INT 1
19762: DEC
19763: ST_TO_ADDR
19764: LD_VAR 0 6
19768: PUSH
19769: FOR_TO
19770: IFFALSE 20834
// begin if i > 4 then
19772: LD_VAR 0 8
19776: PUSH
19777: LD_INT 4
19779: GREATER
19780: IFFALSE 19784
// break ;
19782: GO 20834
// case i of 1 :
19784: LD_VAR 0 8
19788: PUSH
19789: LD_INT 1
19791: DOUBLE
19792: EQUAL
19793: IFTRUE 19797
19795: GO 19877
19797: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
19798: LD_ADDR_VAR 0 12
19802: PUSH
19803: LD_VAR 0 18
19807: PPUSH
19808: LD_INT 22
19810: PUSH
19811: LD_VAR 0 16
19815: PUSH
19816: EMPTY
19817: LIST
19818: LIST
19819: PUSH
19820: LD_INT 58
19822: PUSH
19823: EMPTY
19824: LIST
19825: PUSH
19826: LD_INT 2
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_INT 32
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: PUSH
19839: LD_INT 30
19841: PUSH
19842: LD_INT 4
19844: PUSH
19845: EMPTY
19846: LIST
19847: LIST
19848: PUSH
19849: LD_INT 30
19851: PUSH
19852: LD_INT 5
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: PUSH
19859: EMPTY
19860: LIST
19861: LIST
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: LIST
19869: PPUSH
19870: CALL_OW 72
19874: ST_TO_ADDR
19875: GO 20099
19877: LD_INT 2
19879: DOUBLE
19880: EQUAL
19881: IFTRUE 19885
19883: GO 19947
19885: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
19886: LD_ADDR_VAR 0 12
19890: PUSH
19891: LD_VAR 0 18
19895: PPUSH
19896: LD_INT 22
19898: PUSH
19899: LD_VAR 0 16
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 2
19910: PUSH
19911: LD_INT 30
19913: PUSH
19914: LD_INT 0
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: PUSH
19921: LD_INT 30
19923: PUSH
19924: LD_INT 1
19926: PUSH
19927: EMPTY
19928: LIST
19929: LIST
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: PPUSH
19940: CALL_OW 72
19944: ST_TO_ADDR
19945: GO 20099
19947: LD_INT 3
19949: DOUBLE
19950: EQUAL
19951: IFTRUE 19955
19953: GO 20017
19955: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
19956: LD_ADDR_VAR 0 12
19960: PUSH
19961: LD_VAR 0 18
19965: PPUSH
19966: LD_INT 22
19968: PUSH
19969: LD_VAR 0 16
19973: PUSH
19974: EMPTY
19975: LIST
19976: LIST
19977: PUSH
19978: LD_INT 2
19980: PUSH
19981: LD_INT 30
19983: PUSH
19984: LD_INT 2
19986: PUSH
19987: EMPTY
19988: LIST
19989: LIST
19990: PUSH
19991: LD_INT 30
19993: PUSH
19994: LD_INT 3
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: EMPTY
20002: LIST
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: ST_TO_ADDR
20015: GO 20099
20017: LD_INT 4
20019: DOUBLE
20020: EQUAL
20021: IFTRUE 20025
20023: GO 20098
20025: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20026: LD_ADDR_VAR 0 12
20030: PUSH
20031: LD_VAR 0 18
20035: PPUSH
20036: LD_INT 22
20038: PUSH
20039: LD_VAR 0 16
20043: PUSH
20044: EMPTY
20045: LIST
20046: LIST
20047: PUSH
20048: LD_INT 2
20050: PUSH
20051: LD_INT 30
20053: PUSH
20054: LD_INT 6
20056: PUSH
20057: EMPTY
20058: LIST
20059: LIST
20060: PUSH
20061: LD_INT 30
20063: PUSH
20064: LD_INT 7
20066: PUSH
20067: EMPTY
20068: LIST
20069: LIST
20070: PUSH
20071: LD_INT 30
20073: PUSH
20074: LD_INT 8
20076: PUSH
20077: EMPTY
20078: LIST
20079: LIST
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: PUSH
20087: EMPTY
20088: LIST
20089: LIST
20090: PPUSH
20091: CALL_OW 72
20095: ST_TO_ADDR
20096: GO 20099
20098: POP
// if i = 1 then
20099: LD_VAR 0 8
20103: PUSH
20104: LD_INT 1
20106: EQUAL
20107: IFFALSE 20218
// begin tmp := [ ] ;
20109: LD_ADDR_VAR 0 19
20113: PUSH
20114: EMPTY
20115: ST_TO_ADDR
// for j in f do
20116: LD_ADDR_VAR 0 9
20120: PUSH
20121: LD_VAR 0 12
20125: PUSH
20126: FOR_IN
20127: IFFALSE 20200
// if GetBType ( j ) = b_bunker then
20129: LD_VAR 0 9
20133: PPUSH
20134: CALL_OW 266
20138: PUSH
20139: LD_INT 32
20141: EQUAL
20142: IFFALSE 20169
// tmp := Insert ( tmp , 1 , j ) else
20144: LD_ADDR_VAR 0 19
20148: PUSH
20149: LD_VAR 0 19
20153: PPUSH
20154: LD_INT 1
20156: PPUSH
20157: LD_VAR 0 9
20161: PPUSH
20162: CALL_OW 2
20166: ST_TO_ADDR
20167: GO 20198
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20169: LD_ADDR_VAR 0 19
20173: PUSH
20174: LD_VAR 0 19
20178: PPUSH
20179: LD_VAR 0 19
20183: PUSH
20184: LD_INT 1
20186: PLUS
20187: PPUSH
20188: LD_VAR 0 9
20192: PPUSH
20193: CALL_OW 2
20197: ST_TO_ADDR
20198: GO 20126
20200: POP
20201: POP
// if tmp then
20202: LD_VAR 0 19
20206: IFFALSE 20218
// f := tmp ;
20208: LD_ADDR_VAR 0 12
20212: PUSH
20213: LD_VAR 0 19
20217: ST_TO_ADDR
// end ; x := personel [ i ] ;
20218: LD_ADDR_VAR 0 13
20222: PUSH
20223: LD_VAR 0 6
20227: PUSH
20228: LD_VAR 0 8
20232: ARRAY
20233: ST_TO_ADDR
// if x = - 1 then
20234: LD_VAR 0 13
20238: PUSH
20239: LD_INT 1
20241: NEG
20242: EQUAL
20243: IFFALSE 20452
// begin for j in f do
20245: LD_ADDR_VAR 0 9
20249: PUSH
20250: LD_VAR 0 12
20254: PUSH
20255: FOR_IN
20256: IFFALSE 20448
// repeat InitHc ;
20258: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20262: LD_VAR 0 9
20266: PPUSH
20267: CALL_OW 266
20271: PUSH
20272: LD_INT 5
20274: EQUAL
20275: IFFALSE 20345
// begin if UnitsInside ( j ) < 3 then
20277: LD_VAR 0 9
20281: PPUSH
20282: CALL_OW 313
20286: PUSH
20287: LD_INT 3
20289: LESS
20290: IFFALSE 20326
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20292: LD_INT 0
20294: PPUSH
20295: LD_INT 5
20297: PUSH
20298: LD_INT 8
20300: PUSH
20301: LD_INT 9
20303: PUSH
20304: EMPTY
20305: LIST
20306: LIST
20307: LIST
20308: PUSH
20309: LD_VAR 0 17
20313: ARRAY
20314: PPUSH
20315: LD_VAR 0 4
20319: PPUSH
20320: CALL_OW 380
20324: GO 20343
// PrepareHuman ( false , i , skill ) ;
20326: LD_INT 0
20328: PPUSH
20329: LD_VAR 0 8
20333: PPUSH
20334: LD_VAR 0 4
20338: PPUSH
20339: CALL_OW 380
// end else
20343: GO 20362
// PrepareHuman ( false , i , skill ) ;
20345: LD_INT 0
20347: PPUSH
20348: LD_VAR 0 8
20352: PPUSH
20353: LD_VAR 0 4
20357: PPUSH
20358: CALL_OW 380
// un := CreateHuman ;
20362: LD_ADDR_VAR 0 14
20366: PUSH
20367: CALL_OW 44
20371: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20372: LD_ADDR_VAR 0 7
20376: PUSH
20377: LD_VAR 0 7
20381: PPUSH
20382: LD_INT 1
20384: PPUSH
20385: LD_VAR 0 14
20389: PPUSH
20390: CALL_OW 2
20394: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
20395: LD_VAR 0 14
20399: PPUSH
20400: LD_VAR 0 9
20404: PPUSH
20405: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
20409: LD_VAR 0 9
20413: PPUSH
20414: CALL_OW 313
20418: PUSH
20419: LD_INT 6
20421: EQUAL
20422: PUSH
20423: LD_VAR 0 9
20427: PPUSH
20428: CALL_OW 266
20432: PUSH
20433: LD_INT 32
20435: PUSH
20436: LD_INT 31
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: IN
20443: OR
20444: IFFALSE 20258
20446: GO 20255
20448: POP
20449: POP
// end else
20450: GO 20832
// for j = 1 to x do
20452: LD_ADDR_VAR 0 9
20456: PUSH
20457: DOUBLE
20458: LD_INT 1
20460: DEC
20461: ST_TO_ADDR
20462: LD_VAR 0 13
20466: PUSH
20467: FOR_TO
20468: IFFALSE 20830
// begin InitHc ;
20470: CALL_OW 19
// if not f then
20474: LD_VAR 0 12
20478: NOT
20479: IFFALSE 20568
// begin PrepareHuman ( false , i , skill ) ;
20481: LD_INT 0
20483: PPUSH
20484: LD_VAR 0 8
20488: PPUSH
20489: LD_VAR 0 4
20493: PPUSH
20494: CALL_OW 380
// un := CreateHuman ;
20498: LD_ADDR_VAR 0 14
20502: PUSH
20503: CALL_OW 44
20507: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20508: LD_ADDR_VAR 0 7
20512: PUSH
20513: LD_VAR 0 7
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: LD_VAR 0 14
20525: PPUSH
20526: CALL_OW 2
20530: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20531: LD_VAR 0 14
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: CALL_OW 250
20545: PPUSH
20546: LD_VAR 0 1
20550: PPUSH
20551: CALL_OW 251
20555: PPUSH
20556: LD_INT 10
20558: PPUSH
20559: LD_INT 0
20561: PPUSH
20562: CALL_OW 50
// continue ;
20566: GO 20467
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
20568: LD_VAR 0 12
20572: PUSH
20573: LD_INT 1
20575: ARRAY
20576: PPUSH
20577: CALL_OW 313
20581: PUSH
20582: LD_VAR 0 12
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: PPUSH
20591: CALL_OW 266
20595: PUSH
20596: LD_INT 32
20598: PUSH
20599: LD_INT 31
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: IN
20606: AND
20607: PUSH
20608: LD_VAR 0 12
20612: PUSH
20613: LD_INT 1
20615: ARRAY
20616: PPUSH
20617: CALL_OW 313
20621: PUSH
20622: LD_INT 6
20624: EQUAL
20625: OR
20626: IFFALSE 20646
// f := Delete ( f , 1 ) ;
20628: LD_ADDR_VAR 0 12
20632: PUSH
20633: LD_VAR 0 12
20637: PPUSH
20638: LD_INT 1
20640: PPUSH
20641: CALL_OW 3
20645: ST_TO_ADDR
// if not f then
20646: LD_VAR 0 12
20650: NOT
20651: IFFALSE 20669
// begin x := x + 2 ;
20653: LD_ADDR_VAR 0 13
20657: PUSH
20658: LD_VAR 0 13
20662: PUSH
20663: LD_INT 2
20665: PLUS
20666: ST_TO_ADDR
// continue ;
20667: GO 20467
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
20669: LD_VAR 0 12
20673: PUSH
20674: LD_INT 1
20676: ARRAY
20677: PPUSH
20678: CALL_OW 266
20682: PUSH
20683: LD_INT 5
20685: EQUAL
20686: IFFALSE 20760
// begin if UnitsInside ( f [ 1 ] ) < 3 then
20688: LD_VAR 0 12
20692: PUSH
20693: LD_INT 1
20695: ARRAY
20696: PPUSH
20697: CALL_OW 313
20701: PUSH
20702: LD_INT 3
20704: LESS
20705: IFFALSE 20741
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20707: LD_INT 0
20709: PPUSH
20710: LD_INT 5
20712: PUSH
20713: LD_INT 8
20715: PUSH
20716: LD_INT 9
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: PUSH
20724: LD_VAR 0 17
20728: ARRAY
20729: PPUSH
20730: LD_VAR 0 4
20734: PPUSH
20735: CALL_OW 380
20739: GO 20758
// PrepareHuman ( false , i , skill ) ;
20741: LD_INT 0
20743: PPUSH
20744: LD_VAR 0 8
20748: PPUSH
20749: LD_VAR 0 4
20753: PPUSH
20754: CALL_OW 380
// end else
20758: GO 20777
// PrepareHuman ( false , i , skill ) ;
20760: LD_INT 0
20762: PPUSH
20763: LD_VAR 0 8
20767: PPUSH
20768: LD_VAR 0 4
20772: PPUSH
20773: CALL_OW 380
// un := CreateHuman ;
20777: LD_ADDR_VAR 0 14
20781: PUSH
20782: CALL_OW 44
20786: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
20787: LD_ADDR_VAR 0 7
20791: PUSH
20792: LD_VAR 0 7
20796: PPUSH
20797: LD_INT 1
20799: PPUSH
20800: LD_VAR 0 14
20804: PPUSH
20805: CALL_OW 2
20809: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
20810: LD_VAR 0 14
20814: PPUSH
20815: LD_VAR 0 12
20819: PUSH
20820: LD_INT 1
20822: ARRAY
20823: PPUSH
20824: CALL_OW 52
// end ;
20828: GO 20467
20830: POP
20831: POP
// end ;
20832: GO 19769
20834: POP
20835: POP
// result := result ^ buildings ;
20836: LD_ADDR_VAR 0 7
20840: PUSH
20841: LD_VAR 0 7
20845: PUSH
20846: LD_VAR 0 18
20850: ADD
20851: ST_TO_ADDR
// end else
20852: GO 20995
// begin for i = 1 to personel do
20854: LD_ADDR_VAR 0 8
20858: PUSH
20859: DOUBLE
20860: LD_INT 1
20862: DEC
20863: ST_TO_ADDR
20864: LD_VAR 0 6
20868: PUSH
20869: FOR_TO
20870: IFFALSE 20993
// begin if i > 4 then
20872: LD_VAR 0 8
20876: PUSH
20877: LD_INT 4
20879: GREATER
20880: IFFALSE 20884
// break ;
20882: GO 20993
// x := personel [ i ] ;
20884: LD_ADDR_VAR 0 13
20888: PUSH
20889: LD_VAR 0 6
20893: PUSH
20894: LD_VAR 0 8
20898: ARRAY
20899: ST_TO_ADDR
// if x = - 1 then
20900: LD_VAR 0 13
20904: PUSH
20905: LD_INT 1
20907: NEG
20908: EQUAL
20909: IFFALSE 20913
// continue ;
20911: GO 20869
// PrepareHuman ( false , i , skill ) ;
20913: LD_INT 0
20915: PPUSH
20916: LD_VAR 0 8
20920: PPUSH
20921: LD_VAR 0 4
20925: PPUSH
20926: CALL_OW 380
// un := CreateHuman ;
20930: LD_ADDR_VAR 0 14
20934: PUSH
20935: CALL_OW 44
20939: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
20940: LD_VAR 0 14
20944: PPUSH
20945: LD_VAR 0 1
20949: PPUSH
20950: CALL_OW 250
20954: PPUSH
20955: LD_VAR 0 1
20959: PPUSH
20960: CALL_OW 251
20964: PPUSH
20965: LD_INT 10
20967: PPUSH
20968: LD_INT 0
20970: PPUSH
20971: CALL_OW 50
// result := result ^ un ;
20975: LD_ADDR_VAR 0 7
20979: PUSH
20980: LD_VAR 0 7
20984: PUSH
20985: LD_VAR 0 14
20989: ADD
20990: ST_TO_ADDR
// end ;
20991: GO 20869
20993: POP
20994: POP
// end ; end ;
20995: LD_VAR 0 7
20999: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21000: LD_INT 0
21002: PPUSH
21003: PPUSH
21004: PPUSH
21005: PPUSH
21006: PPUSH
21007: PPUSH
21008: PPUSH
21009: PPUSH
21010: PPUSH
21011: PPUSH
21012: PPUSH
21013: PPUSH
21014: PPUSH
21015: PPUSH
21016: PPUSH
21017: PPUSH
// result := false ;
21018: LD_ADDR_VAR 0 3
21022: PUSH
21023: LD_INT 0
21025: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21026: LD_VAR 0 1
21030: NOT
21031: PUSH
21032: LD_VAR 0 1
21036: PPUSH
21037: CALL_OW 266
21041: PUSH
21042: LD_INT 32
21044: PUSH
21045: LD_INT 33
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: NOT
21053: OR
21054: IFFALSE 21058
// exit ;
21056: GO 22167
// nat := GetNation ( tower ) ;
21058: LD_ADDR_VAR 0 12
21062: PUSH
21063: LD_VAR 0 1
21067: PPUSH
21068: CALL_OW 248
21072: ST_TO_ADDR
// side := GetSide ( tower ) ;
21073: LD_ADDR_VAR 0 16
21077: PUSH
21078: LD_VAR 0 1
21082: PPUSH
21083: CALL_OW 255
21087: ST_TO_ADDR
// x := GetX ( tower ) ;
21088: LD_ADDR_VAR 0 10
21092: PUSH
21093: LD_VAR 0 1
21097: PPUSH
21098: CALL_OW 250
21102: ST_TO_ADDR
// y := GetY ( tower ) ;
21103: LD_ADDR_VAR 0 11
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 251
21117: ST_TO_ADDR
// if not x or not y then
21118: LD_VAR 0 10
21122: NOT
21123: PUSH
21124: LD_VAR 0 11
21128: NOT
21129: OR
21130: IFFALSE 21134
// exit ;
21132: GO 22167
// weapon := 0 ;
21134: LD_ADDR_VAR 0 18
21138: PUSH
21139: LD_INT 0
21141: ST_TO_ADDR
// fac_list := [ ] ;
21142: LD_ADDR_VAR 0 17
21146: PUSH
21147: EMPTY
21148: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21149: LD_ADDR_VAR 0 6
21153: PUSH
21154: LD_VAR 0 1
21158: PPUSH
21159: CALL_OW 274
21163: PPUSH
21164: LD_VAR 0 2
21168: PPUSH
21169: LD_INT 0
21171: PPUSH
21172: CALL 18738 0 3
21176: PPUSH
21177: LD_INT 30
21179: PUSH
21180: LD_INT 3
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PPUSH
21187: CALL_OW 72
21191: ST_TO_ADDR
// if not factories then
21192: LD_VAR 0 6
21196: NOT
21197: IFFALSE 21201
// exit ;
21199: GO 22167
// for i in factories do
21201: LD_ADDR_VAR 0 8
21205: PUSH
21206: LD_VAR 0 6
21210: PUSH
21211: FOR_IN
21212: IFFALSE 21237
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21214: LD_ADDR_VAR 0 17
21218: PUSH
21219: LD_VAR 0 17
21223: PUSH
21224: LD_VAR 0 8
21228: PPUSH
21229: CALL_OW 478
21233: UNION
21234: ST_TO_ADDR
21235: GO 21211
21237: POP
21238: POP
// if not fac_list then
21239: LD_VAR 0 17
21243: NOT
21244: IFFALSE 21248
// exit ;
21246: GO 22167
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21248: LD_ADDR_VAR 0 5
21252: PUSH
21253: LD_INT 4
21255: PUSH
21256: LD_INT 5
21258: PUSH
21259: LD_INT 9
21261: PUSH
21262: LD_INT 10
21264: PUSH
21265: LD_INT 6
21267: PUSH
21268: LD_INT 7
21270: PUSH
21271: LD_INT 11
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: LIST
21282: PUSH
21283: LD_INT 27
21285: PUSH
21286: LD_INT 28
21288: PUSH
21289: LD_INT 26
21291: PUSH
21292: LD_INT 30
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: LIST
21299: LIST
21300: PUSH
21301: LD_INT 43
21303: PUSH
21304: LD_INT 44
21306: PUSH
21307: LD_INT 46
21309: PUSH
21310: LD_INT 45
21312: PUSH
21313: LD_INT 47
21315: PUSH
21316: LD_INT 49
21318: PUSH
21319: EMPTY
21320: LIST
21321: LIST
21322: LIST
21323: LIST
21324: LIST
21325: LIST
21326: PUSH
21327: EMPTY
21328: LIST
21329: LIST
21330: LIST
21331: PUSH
21332: LD_VAR 0 12
21336: ARRAY
21337: ST_TO_ADDR
// list := list isect fac_list ;
21338: LD_ADDR_VAR 0 5
21342: PUSH
21343: LD_VAR 0 5
21347: PUSH
21348: LD_VAR 0 17
21352: ISECT
21353: ST_TO_ADDR
// if not list then
21354: LD_VAR 0 5
21358: NOT
21359: IFFALSE 21363
// exit ;
21361: GO 22167
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
21363: LD_VAR 0 12
21367: PUSH
21368: LD_INT 3
21370: EQUAL
21371: PUSH
21372: LD_INT 49
21374: PUSH
21375: LD_VAR 0 5
21379: IN
21380: AND
21381: PUSH
21382: LD_INT 31
21384: PPUSH
21385: LD_VAR 0 16
21389: PPUSH
21390: CALL_OW 321
21394: PUSH
21395: LD_INT 2
21397: EQUAL
21398: AND
21399: IFFALSE 21459
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
21401: LD_INT 22
21403: PUSH
21404: LD_VAR 0 16
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PUSH
21413: LD_INT 35
21415: PUSH
21416: LD_INT 49
21418: PUSH
21419: EMPTY
21420: LIST
21421: LIST
21422: PUSH
21423: LD_INT 91
21425: PUSH
21426: LD_VAR 0 1
21430: PUSH
21431: LD_INT 10
21433: PUSH
21434: EMPTY
21435: LIST
21436: LIST
21437: LIST
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: LIST
21443: PPUSH
21444: CALL_OW 69
21448: NOT
21449: IFFALSE 21459
// weapon := ru_time_lapser ;
21451: LD_ADDR_VAR 0 18
21455: PUSH
21456: LD_INT 49
21458: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
21459: LD_VAR 0 12
21463: PUSH
21464: LD_INT 1
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: IN
21474: PUSH
21475: LD_INT 11
21477: PUSH
21478: LD_VAR 0 5
21482: IN
21483: PUSH
21484: LD_INT 30
21486: PUSH
21487: LD_VAR 0 5
21491: IN
21492: OR
21493: AND
21494: PUSH
21495: LD_INT 6
21497: PPUSH
21498: LD_VAR 0 16
21502: PPUSH
21503: CALL_OW 321
21507: PUSH
21508: LD_INT 2
21510: EQUAL
21511: AND
21512: IFFALSE 21677
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
21514: LD_INT 22
21516: PUSH
21517: LD_VAR 0 16
21521: PUSH
21522: EMPTY
21523: LIST
21524: LIST
21525: PUSH
21526: LD_INT 2
21528: PUSH
21529: LD_INT 35
21531: PUSH
21532: LD_INT 11
21534: PUSH
21535: EMPTY
21536: LIST
21537: LIST
21538: PUSH
21539: LD_INT 35
21541: PUSH
21542: LD_INT 30
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: LIST
21553: PUSH
21554: LD_INT 91
21556: PUSH
21557: LD_VAR 0 1
21561: PUSH
21562: LD_INT 18
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: LIST
21574: PPUSH
21575: CALL_OW 69
21579: NOT
21580: PUSH
21581: LD_INT 22
21583: PUSH
21584: LD_VAR 0 16
21588: PUSH
21589: EMPTY
21590: LIST
21591: LIST
21592: PUSH
21593: LD_INT 2
21595: PUSH
21596: LD_INT 30
21598: PUSH
21599: LD_INT 32
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: PUSH
21606: LD_INT 30
21608: PUSH
21609: LD_INT 33
21611: PUSH
21612: EMPTY
21613: LIST
21614: LIST
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: LIST
21620: PUSH
21621: LD_INT 91
21623: PUSH
21624: LD_VAR 0 1
21628: PUSH
21629: LD_INT 12
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: LIST
21636: PUSH
21637: EMPTY
21638: LIST
21639: LIST
21640: LIST
21641: PUSH
21642: EMPTY
21643: LIST
21644: PPUSH
21645: CALL_OW 69
21649: PUSH
21650: LD_INT 2
21652: GREATER
21653: AND
21654: IFFALSE 21677
// weapon := [ us_radar , ar_radar ] [ nat ] ;
21656: LD_ADDR_VAR 0 18
21660: PUSH
21661: LD_INT 11
21663: PUSH
21664: LD_INT 30
21666: PUSH
21667: EMPTY
21668: LIST
21669: LIST
21670: PUSH
21671: LD_VAR 0 12
21675: ARRAY
21676: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
21677: LD_VAR 0 18
21681: NOT
21682: PUSH
21683: LD_INT 40
21685: PPUSH
21686: LD_VAR 0 16
21690: PPUSH
21691: CALL_OW 321
21695: PUSH
21696: LD_INT 2
21698: EQUAL
21699: AND
21700: PUSH
21701: LD_INT 7
21703: PUSH
21704: LD_VAR 0 5
21708: IN
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_VAR 0 5
21717: IN
21718: OR
21719: PUSH
21720: LD_INT 45
21722: PUSH
21723: LD_VAR 0 5
21727: IN
21728: OR
21729: AND
21730: IFFALSE 21984
// begin hex := GetHexInfo ( x , y ) ;
21732: LD_ADDR_VAR 0 4
21736: PUSH
21737: LD_VAR 0 10
21741: PPUSH
21742: LD_VAR 0 11
21746: PPUSH
21747: CALL_OW 546
21751: ST_TO_ADDR
// if hex [ 1 ] then
21752: LD_VAR 0 4
21756: PUSH
21757: LD_INT 1
21759: ARRAY
21760: IFFALSE 21764
// exit ;
21762: GO 22167
// height := hex [ 2 ] ;
21764: LD_ADDR_VAR 0 15
21768: PUSH
21769: LD_VAR 0 4
21773: PUSH
21774: LD_INT 2
21776: ARRAY
21777: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
21778: LD_ADDR_VAR 0 14
21782: PUSH
21783: LD_INT 0
21785: PUSH
21786: LD_INT 2
21788: PUSH
21789: LD_INT 3
21791: PUSH
21792: LD_INT 5
21794: PUSH
21795: EMPTY
21796: LIST
21797: LIST
21798: LIST
21799: LIST
21800: ST_TO_ADDR
// for i in tmp do
21801: LD_ADDR_VAR 0 8
21805: PUSH
21806: LD_VAR 0 14
21810: PUSH
21811: FOR_IN
21812: IFFALSE 21982
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
21814: LD_ADDR_VAR 0 9
21818: PUSH
21819: LD_VAR 0 10
21823: PPUSH
21824: LD_VAR 0 8
21828: PPUSH
21829: LD_INT 5
21831: PPUSH
21832: CALL_OW 272
21836: PUSH
21837: LD_VAR 0 11
21841: PPUSH
21842: LD_VAR 0 8
21846: PPUSH
21847: LD_INT 5
21849: PPUSH
21850: CALL_OW 273
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
21859: LD_VAR 0 9
21863: PUSH
21864: LD_INT 1
21866: ARRAY
21867: PPUSH
21868: LD_VAR 0 9
21872: PUSH
21873: LD_INT 2
21875: ARRAY
21876: PPUSH
21877: CALL_OW 488
21881: IFFALSE 21980
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
21883: LD_ADDR_VAR 0 4
21887: PUSH
21888: LD_VAR 0 9
21892: PUSH
21893: LD_INT 1
21895: ARRAY
21896: PPUSH
21897: LD_VAR 0 9
21901: PUSH
21902: LD_INT 2
21904: ARRAY
21905: PPUSH
21906: CALL_OW 546
21910: ST_TO_ADDR
// if hex [ 1 ] then
21911: LD_VAR 0 4
21915: PUSH
21916: LD_INT 1
21918: ARRAY
21919: IFFALSE 21923
// continue ;
21921: GO 21811
// h := hex [ 2 ] ;
21923: LD_ADDR_VAR 0 13
21927: PUSH
21928: LD_VAR 0 4
21932: PUSH
21933: LD_INT 2
21935: ARRAY
21936: ST_TO_ADDR
// if h + 7 < height then
21937: LD_VAR 0 13
21941: PUSH
21942: LD_INT 7
21944: PLUS
21945: PUSH
21946: LD_VAR 0 15
21950: LESS
21951: IFFALSE 21980
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
21953: LD_ADDR_VAR 0 18
21957: PUSH
21958: LD_INT 7
21960: PUSH
21961: LD_INT 28
21963: PUSH
21964: LD_INT 45
21966: PUSH
21967: EMPTY
21968: LIST
21969: LIST
21970: LIST
21971: PUSH
21972: LD_VAR 0 12
21976: ARRAY
21977: ST_TO_ADDR
// break ;
21978: GO 21982
// end ; end ; end ;
21980: GO 21811
21982: POP
21983: POP
// end ; if not weapon then
21984: LD_VAR 0 18
21988: NOT
21989: IFFALSE 22049
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
21991: LD_ADDR_VAR 0 5
21995: PUSH
21996: LD_VAR 0 5
22000: PUSH
22001: LD_INT 11
22003: PUSH
22004: LD_INT 30
22006: PUSH
22007: LD_INT 49
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: DIFF
22015: ST_TO_ADDR
// if not list then
22016: LD_VAR 0 5
22020: NOT
22021: IFFALSE 22025
// exit ;
22023: GO 22167
// weapon := list [ rand ( 1 , list ) ] ;
22025: LD_ADDR_VAR 0 18
22029: PUSH
22030: LD_VAR 0 5
22034: PUSH
22035: LD_INT 1
22037: PPUSH
22038: LD_VAR 0 5
22042: PPUSH
22043: CALL_OW 12
22047: ARRAY
22048: ST_TO_ADDR
// end ; if weapon then
22049: LD_VAR 0 18
22053: IFFALSE 22167
// begin tmp := CostOfWeapon ( weapon ) ;
22055: LD_ADDR_VAR 0 14
22059: PUSH
22060: LD_VAR 0 18
22064: PPUSH
22065: CALL_OW 451
22069: ST_TO_ADDR
// j := GetBase ( tower ) ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_VAR 0 1
22079: PPUSH
22080: CALL_OW 274
22084: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22085: LD_VAR 0 9
22089: PPUSH
22090: LD_INT 1
22092: PPUSH
22093: CALL_OW 275
22097: PUSH
22098: LD_VAR 0 14
22102: PUSH
22103: LD_INT 1
22105: ARRAY
22106: GREATEREQUAL
22107: PUSH
22108: LD_VAR 0 9
22112: PPUSH
22113: LD_INT 2
22115: PPUSH
22116: CALL_OW 275
22120: PUSH
22121: LD_VAR 0 14
22125: PUSH
22126: LD_INT 2
22128: ARRAY
22129: GREATEREQUAL
22130: AND
22131: PUSH
22132: LD_VAR 0 9
22136: PPUSH
22137: LD_INT 3
22139: PPUSH
22140: CALL_OW 275
22144: PUSH
22145: LD_VAR 0 14
22149: PUSH
22150: LD_INT 3
22152: ARRAY
22153: GREATEREQUAL
22154: AND
22155: IFFALSE 22167
// result := weapon ;
22157: LD_ADDR_VAR 0 3
22161: PUSH
22162: LD_VAR 0 18
22166: ST_TO_ADDR
// end ; end ;
22167: LD_VAR 0 3
22171: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22172: LD_INT 0
22174: PPUSH
22175: PPUSH
// result := true ;
22176: LD_ADDR_VAR 0 3
22180: PUSH
22181: LD_INT 1
22183: ST_TO_ADDR
// if array1 = array2 then
22184: LD_VAR 0 1
22188: PUSH
22189: LD_VAR 0 2
22193: EQUAL
22194: IFFALSE 22254
// begin for i = 1 to array1 do
22196: LD_ADDR_VAR 0 4
22200: PUSH
22201: DOUBLE
22202: LD_INT 1
22204: DEC
22205: ST_TO_ADDR
22206: LD_VAR 0 1
22210: PUSH
22211: FOR_TO
22212: IFFALSE 22250
// if array1 [ i ] <> array2 [ i ] then
22214: LD_VAR 0 1
22218: PUSH
22219: LD_VAR 0 4
22223: ARRAY
22224: PUSH
22225: LD_VAR 0 2
22229: PUSH
22230: LD_VAR 0 4
22234: ARRAY
22235: NONEQUAL
22236: IFFALSE 22248
// begin result := false ;
22238: LD_ADDR_VAR 0 3
22242: PUSH
22243: LD_INT 0
22245: ST_TO_ADDR
// break ;
22246: GO 22250
// end ;
22248: GO 22211
22250: POP
22251: POP
// end else
22252: GO 22262
// result := false ;
22254: LD_ADDR_VAR 0 3
22258: PUSH
22259: LD_INT 0
22261: ST_TO_ADDR
// end ;
22262: LD_VAR 0 3
22266: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22267: LD_INT 0
22269: PPUSH
22270: PPUSH
// if not array1 or not array2 then
22271: LD_VAR 0 1
22275: NOT
22276: PUSH
22277: LD_VAR 0 2
22281: NOT
22282: OR
22283: IFFALSE 22287
// exit ;
22285: GO 22351
// result := true ;
22287: LD_ADDR_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ST_TO_ADDR
// for i = 1 to array1 do
22295: LD_ADDR_VAR 0 4
22299: PUSH
22300: DOUBLE
22301: LD_INT 1
22303: DEC
22304: ST_TO_ADDR
22305: LD_VAR 0 1
22309: PUSH
22310: FOR_TO
22311: IFFALSE 22349
// if array1 [ i ] <> array2 [ i ] then
22313: LD_VAR 0 1
22317: PUSH
22318: LD_VAR 0 4
22322: ARRAY
22323: PUSH
22324: LD_VAR 0 2
22328: PUSH
22329: LD_VAR 0 4
22333: ARRAY
22334: NONEQUAL
22335: IFFALSE 22347
// begin result := false ;
22337: LD_ADDR_VAR 0 3
22341: PUSH
22342: LD_INT 0
22344: ST_TO_ADDR
// break ;
22345: GO 22349
// end ;
22347: GO 22310
22349: POP
22350: POP
// end ;
22351: LD_VAR 0 3
22355: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
22356: LD_INT 0
22358: PPUSH
22359: PPUSH
22360: PPUSH
// pom := GetBase ( fac ) ;
22361: LD_ADDR_VAR 0 5
22365: PUSH
22366: LD_VAR 0 1
22370: PPUSH
22371: CALL_OW 274
22375: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
22376: LD_ADDR_VAR 0 4
22380: PUSH
22381: LD_VAR 0 2
22385: PUSH
22386: LD_INT 1
22388: ARRAY
22389: PPUSH
22390: LD_VAR 0 2
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PPUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_INT 3
22406: ARRAY
22407: PPUSH
22408: LD_VAR 0 2
22412: PUSH
22413: LD_INT 4
22415: ARRAY
22416: PPUSH
22417: CALL_OW 449
22421: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22422: LD_ADDR_VAR 0 3
22426: PUSH
22427: LD_VAR 0 5
22431: PPUSH
22432: LD_INT 1
22434: PPUSH
22435: CALL_OW 275
22439: PUSH
22440: LD_VAR 0 4
22444: PUSH
22445: LD_INT 1
22447: ARRAY
22448: GREATEREQUAL
22449: PUSH
22450: LD_VAR 0 5
22454: PPUSH
22455: LD_INT 2
22457: PPUSH
22458: CALL_OW 275
22462: PUSH
22463: LD_VAR 0 4
22467: PUSH
22468: LD_INT 2
22470: ARRAY
22471: GREATEREQUAL
22472: AND
22473: PUSH
22474: LD_VAR 0 5
22478: PPUSH
22479: LD_INT 3
22481: PPUSH
22482: CALL_OW 275
22486: PUSH
22487: LD_VAR 0 4
22491: PUSH
22492: LD_INT 3
22494: ARRAY
22495: GREATEREQUAL
22496: AND
22497: ST_TO_ADDR
// end ;
22498: LD_VAR 0 3
22502: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
22503: LD_INT 0
22505: PPUSH
22506: PPUSH
22507: PPUSH
22508: PPUSH
// pom := GetBase ( building ) ;
22509: LD_ADDR_VAR 0 3
22513: PUSH
22514: LD_VAR 0 1
22518: PPUSH
22519: CALL_OW 274
22523: ST_TO_ADDR
// if not pom then
22524: LD_VAR 0 3
22528: NOT
22529: IFFALSE 22533
// exit ;
22531: GO 22703
// btype := GetBType ( building ) ;
22533: LD_ADDR_VAR 0 5
22537: PUSH
22538: LD_VAR 0 1
22542: PPUSH
22543: CALL_OW 266
22547: ST_TO_ADDR
// if btype = b_armoury then
22548: LD_VAR 0 5
22552: PUSH
22553: LD_INT 4
22555: EQUAL
22556: IFFALSE 22566
// btype := b_barracks ;
22558: LD_ADDR_VAR 0 5
22562: PUSH
22563: LD_INT 5
22565: ST_TO_ADDR
// if btype = b_depot then
22566: LD_VAR 0 5
22570: PUSH
22571: LD_INT 0
22573: EQUAL
22574: IFFALSE 22584
// btype := b_warehouse ;
22576: LD_ADDR_VAR 0 5
22580: PUSH
22581: LD_INT 1
22583: ST_TO_ADDR
// if btype = b_workshop then
22584: LD_VAR 0 5
22588: PUSH
22589: LD_INT 2
22591: EQUAL
22592: IFFALSE 22602
// btype := b_factory ;
22594: LD_ADDR_VAR 0 5
22598: PUSH
22599: LD_INT 3
22601: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22602: LD_ADDR_VAR 0 4
22606: PUSH
22607: LD_VAR 0 5
22611: PPUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 248
22621: PPUSH
22622: CALL_OW 450
22626: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22627: LD_ADDR_VAR 0 2
22631: PUSH
22632: LD_VAR 0 3
22636: PPUSH
22637: LD_INT 1
22639: PPUSH
22640: CALL_OW 275
22644: PUSH
22645: LD_VAR 0 4
22649: PUSH
22650: LD_INT 1
22652: ARRAY
22653: GREATEREQUAL
22654: PUSH
22655: LD_VAR 0 3
22659: PPUSH
22660: LD_INT 2
22662: PPUSH
22663: CALL_OW 275
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_INT 2
22675: ARRAY
22676: GREATEREQUAL
22677: AND
22678: PUSH
22679: LD_VAR 0 3
22683: PPUSH
22684: LD_INT 3
22686: PPUSH
22687: CALL_OW 275
22691: PUSH
22692: LD_VAR 0 4
22696: PUSH
22697: LD_INT 3
22699: ARRAY
22700: GREATEREQUAL
22701: AND
22702: ST_TO_ADDR
// end ;
22703: LD_VAR 0 2
22707: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
22708: LD_INT 0
22710: PPUSH
22711: PPUSH
22712: PPUSH
// pom := GetBase ( building ) ;
22713: LD_ADDR_VAR 0 4
22717: PUSH
22718: LD_VAR 0 1
22722: PPUSH
22723: CALL_OW 274
22727: ST_TO_ADDR
// if not pom then
22728: LD_VAR 0 4
22732: NOT
22733: IFFALSE 22737
// exit ;
22735: GO 22838
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
22737: LD_ADDR_VAR 0 5
22741: PUSH
22742: LD_VAR 0 2
22746: PPUSH
22747: LD_VAR 0 1
22751: PPUSH
22752: CALL_OW 248
22756: PPUSH
22757: CALL_OW 450
22761: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
22762: LD_ADDR_VAR 0 3
22766: PUSH
22767: LD_VAR 0 4
22771: PPUSH
22772: LD_INT 1
22774: PPUSH
22775: CALL_OW 275
22779: PUSH
22780: LD_VAR 0 5
22784: PUSH
22785: LD_INT 1
22787: ARRAY
22788: GREATEREQUAL
22789: PUSH
22790: LD_VAR 0 4
22794: PPUSH
22795: LD_INT 2
22797: PPUSH
22798: CALL_OW 275
22802: PUSH
22803: LD_VAR 0 5
22807: PUSH
22808: LD_INT 2
22810: ARRAY
22811: GREATEREQUAL
22812: AND
22813: PUSH
22814: LD_VAR 0 4
22818: PPUSH
22819: LD_INT 3
22821: PPUSH
22822: CALL_OW 275
22826: PUSH
22827: LD_VAR 0 5
22831: PUSH
22832: LD_INT 3
22834: ARRAY
22835: GREATEREQUAL
22836: AND
22837: ST_TO_ADDR
// end ;
22838: LD_VAR 0 3
22842: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
22843: LD_INT 0
22845: PPUSH
22846: PPUSH
22847: PPUSH
22848: PPUSH
22849: PPUSH
22850: PPUSH
22851: PPUSH
22852: PPUSH
22853: PPUSH
22854: PPUSH
22855: PPUSH
// result := false ;
22856: LD_ADDR_VAR 0 8
22860: PUSH
22861: LD_INT 0
22863: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
22864: LD_VAR 0 5
22868: NOT
22869: PUSH
22870: LD_VAR 0 1
22874: NOT
22875: OR
22876: PUSH
22877: LD_VAR 0 2
22881: NOT
22882: OR
22883: PUSH
22884: LD_VAR 0 3
22888: NOT
22889: OR
22890: IFFALSE 22894
// exit ;
22892: GO 23708
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
22894: LD_ADDR_VAR 0 14
22898: PUSH
22899: LD_VAR 0 1
22903: PPUSH
22904: LD_VAR 0 2
22908: PPUSH
22909: LD_VAR 0 3
22913: PPUSH
22914: LD_VAR 0 4
22918: PPUSH
22919: LD_VAR 0 5
22923: PUSH
22924: LD_INT 1
22926: ARRAY
22927: PPUSH
22928: CALL_OW 248
22932: PPUSH
22933: LD_INT 0
22935: PPUSH
22936: CALL 24945 0 6
22940: ST_TO_ADDR
// if not hexes then
22941: LD_VAR 0 14
22945: NOT
22946: IFFALSE 22950
// exit ;
22948: GO 23708
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
22950: LD_ADDR_VAR 0 17
22954: PUSH
22955: LD_VAR 0 5
22959: PPUSH
22960: LD_INT 22
22962: PUSH
22963: LD_VAR 0 13
22967: PPUSH
22968: CALL_OW 255
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: PUSH
22977: LD_INT 2
22979: PUSH
22980: LD_INT 30
22982: PUSH
22983: LD_INT 0
22985: PUSH
22986: EMPTY
22987: LIST
22988: LIST
22989: PUSH
22990: LD_INT 30
22992: PUSH
22993: LD_INT 1
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: LIST
23004: PUSH
23005: EMPTY
23006: LIST
23007: LIST
23008: PPUSH
23009: CALL_OW 72
23013: ST_TO_ADDR
// for i = 1 to hexes do
23014: LD_ADDR_VAR 0 9
23018: PUSH
23019: DOUBLE
23020: LD_INT 1
23022: DEC
23023: ST_TO_ADDR
23024: LD_VAR 0 14
23028: PUSH
23029: FOR_TO
23030: IFFALSE 23706
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23032: LD_ADDR_VAR 0 13
23036: PUSH
23037: LD_VAR 0 14
23041: PUSH
23042: LD_VAR 0 9
23046: ARRAY
23047: PUSH
23048: LD_INT 1
23050: ARRAY
23051: PPUSH
23052: LD_VAR 0 14
23056: PUSH
23057: LD_VAR 0 9
23061: ARRAY
23062: PUSH
23063: LD_INT 2
23065: ARRAY
23066: PPUSH
23067: CALL_OW 428
23071: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23072: LD_VAR 0 14
23076: PUSH
23077: LD_VAR 0 9
23081: ARRAY
23082: PUSH
23083: LD_INT 1
23085: ARRAY
23086: PPUSH
23087: LD_VAR 0 14
23091: PUSH
23092: LD_VAR 0 9
23096: ARRAY
23097: PUSH
23098: LD_INT 2
23100: ARRAY
23101: PPUSH
23102: CALL_OW 351
23106: PUSH
23107: LD_VAR 0 14
23111: PUSH
23112: LD_VAR 0 9
23116: ARRAY
23117: PUSH
23118: LD_INT 1
23120: ARRAY
23121: PPUSH
23122: LD_VAR 0 14
23126: PUSH
23127: LD_VAR 0 9
23131: ARRAY
23132: PUSH
23133: LD_INT 2
23135: ARRAY
23136: PPUSH
23137: CALL_OW 488
23141: NOT
23142: OR
23143: PUSH
23144: LD_VAR 0 13
23148: PPUSH
23149: CALL_OW 247
23153: PUSH
23154: LD_INT 3
23156: EQUAL
23157: OR
23158: IFFALSE 23164
// exit ;
23160: POP
23161: POP
23162: GO 23708
// if not tmp then
23164: LD_VAR 0 13
23168: NOT
23169: IFFALSE 23173
// continue ;
23171: GO 23029
// result := true ;
23173: LD_ADDR_VAR 0 8
23177: PUSH
23178: LD_INT 1
23180: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23181: LD_VAR 0 6
23185: PUSH
23186: LD_VAR 0 13
23190: PPUSH
23191: CALL_OW 247
23195: PUSH
23196: LD_INT 2
23198: EQUAL
23199: AND
23200: PUSH
23201: LD_VAR 0 13
23205: PPUSH
23206: CALL_OW 263
23210: PUSH
23211: LD_INT 1
23213: EQUAL
23214: AND
23215: IFFALSE 23379
// begin if IsDrivenBy ( tmp ) then
23217: LD_VAR 0 13
23221: PPUSH
23222: CALL_OW 311
23226: IFFALSE 23230
// continue ;
23228: GO 23029
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23230: LD_VAR 0 6
23234: PPUSH
23235: LD_INT 3
23237: PUSH
23238: LD_INT 60
23240: PUSH
23241: EMPTY
23242: LIST
23243: PUSH
23244: EMPTY
23245: LIST
23246: LIST
23247: PUSH
23248: LD_INT 3
23250: PUSH
23251: LD_INT 55
23253: PUSH
23254: EMPTY
23255: LIST
23256: PUSH
23257: EMPTY
23258: LIST
23259: LIST
23260: PUSH
23261: EMPTY
23262: LIST
23263: LIST
23264: PPUSH
23265: CALL_OW 72
23269: IFFALSE 23377
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23271: LD_ADDR_VAR 0 18
23275: PUSH
23276: LD_VAR 0 6
23280: PPUSH
23281: LD_INT 3
23283: PUSH
23284: LD_INT 60
23286: PUSH
23287: EMPTY
23288: LIST
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 3
23296: PUSH
23297: LD_INT 55
23299: PUSH
23300: EMPTY
23301: LIST
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: EMPTY
23308: LIST
23309: LIST
23310: PPUSH
23311: CALL_OW 72
23315: PUSH
23316: LD_INT 1
23318: ARRAY
23319: ST_TO_ADDR
// if IsInUnit ( driver ) then
23320: LD_VAR 0 18
23324: PPUSH
23325: CALL_OW 310
23329: IFFALSE 23340
// ComExit ( driver ) ;
23331: LD_VAR 0 18
23335: PPUSH
23336: CALL 48129 0 1
// AddComEnterUnit ( driver , tmp ) ;
23340: LD_VAR 0 18
23344: PPUSH
23345: LD_VAR 0 13
23349: PPUSH
23350: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
23354: LD_VAR 0 18
23358: PPUSH
23359: LD_VAR 0 7
23363: PPUSH
23364: CALL_OW 173
// AddComExitVehicle ( driver ) ;
23368: LD_VAR 0 18
23372: PPUSH
23373: CALL_OW 181
// end ; continue ;
23377: GO 23029
// end ; if not cleaners or not tmp in cleaners then
23379: LD_VAR 0 6
23383: NOT
23384: PUSH
23385: LD_VAR 0 13
23389: PUSH
23390: LD_VAR 0 6
23394: IN
23395: NOT
23396: OR
23397: IFFALSE 23704
// begin if dep then
23399: LD_VAR 0 17
23403: IFFALSE 23539
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
23405: LD_ADDR_VAR 0 16
23409: PUSH
23410: LD_VAR 0 17
23414: PUSH
23415: LD_INT 1
23417: ARRAY
23418: PPUSH
23419: CALL_OW 250
23423: PPUSH
23424: LD_VAR 0 17
23428: PUSH
23429: LD_INT 1
23431: ARRAY
23432: PPUSH
23433: CALL_OW 254
23437: PPUSH
23438: LD_INT 5
23440: PPUSH
23441: CALL_OW 272
23445: PUSH
23446: LD_VAR 0 17
23450: PUSH
23451: LD_INT 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 251
23459: PPUSH
23460: LD_VAR 0 17
23464: PUSH
23465: LD_INT 1
23467: ARRAY
23468: PPUSH
23469: CALL_OW 254
23473: PPUSH
23474: LD_INT 5
23476: PPUSH
23477: CALL_OW 273
23481: PUSH
23482: EMPTY
23483: LIST
23484: LIST
23485: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
23486: LD_VAR 0 16
23490: PUSH
23491: LD_INT 1
23493: ARRAY
23494: PPUSH
23495: LD_VAR 0 16
23499: PUSH
23500: LD_INT 2
23502: ARRAY
23503: PPUSH
23504: CALL_OW 488
23508: IFFALSE 23539
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
23510: LD_VAR 0 13
23514: PPUSH
23515: LD_VAR 0 16
23519: PUSH
23520: LD_INT 1
23522: ARRAY
23523: PPUSH
23524: LD_VAR 0 16
23528: PUSH
23529: LD_INT 2
23531: ARRAY
23532: PPUSH
23533: CALL_OW 111
// continue ;
23537: GO 23029
// end ; end ; r := GetDir ( tmp ) ;
23539: LD_ADDR_VAR 0 15
23543: PUSH
23544: LD_VAR 0 13
23548: PPUSH
23549: CALL_OW 254
23553: ST_TO_ADDR
// if r = 5 then
23554: LD_VAR 0 15
23558: PUSH
23559: LD_INT 5
23561: EQUAL
23562: IFFALSE 23572
// r := 0 ;
23564: LD_ADDR_VAR 0 15
23568: PUSH
23569: LD_INT 0
23571: ST_TO_ADDR
// for j = r to 5 do
23572: LD_ADDR_VAR 0 10
23576: PUSH
23577: DOUBLE
23578: LD_VAR 0 15
23582: DEC
23583: ST_TO_ADDR
23584: LD_INT 5
23586: PUSH
23587: FOR_TO
23588: IFFALSE 23702
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
23590: LD_ADDR_VAR 0 11
23594: PUSH
23595: LD_VAR 0 13
23599: PPUSH
23600: CALL_OW 250
23604: PPUSH
23605: LD_VAR 0 10
23609: PPUSH
23610: LD_INT 2
23612: PPUSH
23613: CALL_OW 272
23617: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_VAR 0 13
23627: PPUSH
23628: CALL_OW 251
23632: PPUSH
23633: LD_VAR 0 10
23637: PPUSH
23638: LD_INT 2
23640: PPUSH
23641: CALL_OW 273
23645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
23646: LD_VAR 0 11
23650: PPUSH
23651: LD_VAR 0 12
23655: PPUSH
23656: CALL_OW 488
23660: PUSH
23661: LD_VAR 0 11
23665: PPUSH
23666: LD_VAR 0 12
23670: PPUSH
23671: CALL_OW 428
23675: NOT
23676: AND
23677: IFFALSE 23700
// begin ComMoveXY ( tmp , _x , _y ) ;
23679: LD_VAR 0 13
23683: PPUSH
23684: LD_VAR 0 11
23688: PPUSH
23689: LD_VAR 0 12
23693: PPUSH
23694: CALL_OW 111
// break ;
23698: GO 23702
// end ; end ;
23700: GO 23587
23702: POP
23703: POP
// end ; end ;
23704: GO 23029
23706: POP
23707: POP
// end ;
23708: LD_VAR 0 8
23712: RET
// export function BuildingTechInvented ( side , btype ) ; begin
23713: LD_INT 0
23715: PPUSH
// result := true ;
23716: LD_ADDR_VAR 0 3
23720: PUSH
23721: LD_INT 1
23723: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
23724: LD_VAR 0 2
23728: PUSH
23729: LD_INT 24
23731: DOUBLE
23732: EQUAL
23733: IFTRUE 23743
23735: LD_INT 33
23737: DOUBLE
23738: EQUAL
23739: IFTRUE 23743
23741: GO 23768
23743: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
23744: LD_ADDR_VAR 0 3
23748: PUSH
23749: LD_INT 32
23751: PPUSH
23752: LD_VAR 0 1
23756: PPUSH
23757: CALL_OW 321
23761: PUSH
23762: LD_INT 2
23764: EQUAL
23765: ST_TO_ADDR
23766: GO 24088
23768: LD_INT 20
23770: DOUBLE
23771: EQUAL
23772: IFTRUE 23776
23774: GO 23801
23776: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
23777: LD_ADDR_VAR 0 3
23781: PUSH
23782: LD_INT 6
23784: PPUSH
23785: LD_VAR 0 1
23789: PPUSH
23790: CALL_OW 321
23794: PUSH
23795: LD_INT 2
23797: EQUAL
23798: ST_TO_ADDR
23799: GO 24088
23801: LD_INT 22
23803: DOUBLE
23804: EQUAL
23805: IFTRUE 23815
23807: LD_INT 36
23809: DOUBLE
23810: EQUAL
23811: IFTRUE 23815
23813: GO 23840
23815: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
23816: LD_ADDR_VAR 0 3
23820: PUSH
23821: LD_INT 15
23823: PPUSH
23824: LD_VAR 0 1
23828: PPUSH
23829: CALL_OW 321
23833: PUSH
23834: LD_INT 2
23836: EQUAL
23837: ST_TO_ADDR
23838: GO 24088
23840: LD_INT 30
23842: DOUBLE
23843: EQUAL
23844: IFTRUE 23848
23846: GO 23873
23848: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
23849: LD_ADDR_VAR 0 3
23853: PUSH
23854: LD_INT 20
23856: PPUSH
23857: LD_VAR 0 1
23861: PPUSH
23862: CALL_OW 321
23866: PUSH
23867: LD_INT 2
23869: EQUAL
23870: ST_TO_ADDR
23871: GO 24088
23873: LD_INT 28
23875: DOUBLE
23876: EQUAL
23877: IFTRUE 23887
23879: LD_INT 21
23881: DOUBLE
23882: EQUAL
23883: IFTRUE 23887
23885: GO 23912
23887: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
23888: LD_ADDR_VAR 0 3
23892: PUSH
23893: LD_INT 21
23895: PPUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 321
23905: PUSH
23906: LD_INT 2
23908: EQUAL
23909: ST_TO_ADDR
23910: GO 24088
23912: LD_INT 16
23914: DOUBLE
23915: EQUAL
23916: IFTRUE 23920
23918: GO 23947
23920: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
23921: LD_ADDR_VAR 0 3
23925: PUSH
23926: LD_EXP 79
23930: PPUSH
23931: LD_VAR 0 1
23935: PPUSH
23936: CALL_OW 321
23940: PUSH
23941: LD_INT 2
23943: EQUAL
23944: ST_TO_ADDR
23945: GO 24088
23947: LD_INT 19
23949: DOUBLE
23950: EQUAL
23951: IFTRUE 23961
23953: LD_INT 23
23955: DOUBLE
23956: EQUAL
23957: IFTRUE 23961
23959: GO 23988
23961: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
23962: LD_ADDR_VAR 0 3
23966: PUSH
23967: LD_EXP 78
23971: PPUSH
23972: LD_VAR 0 1
23976: PPUSH
23977: CALL_OW 321
23981: PUSH
23982: LD_INT 2
23984: EQUAL
23985: ST_TO_ADDR
23986: GO 24088
23988: LD_INT 17
23990: DOUBLE
23991: EQUAL
23992: IFTRUE 23996
23994: GO 24021
23996: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: LD_INT 39
24004: PPUSH
24005: LD_VAR 0 1
24009: PPUSH
24010: CALL_OW 321
24014: PUSH
24015: LD_INT 2
24017: EQUAL
24018: ST_TO_ADDR
24019: GO 24088
24021: LD_INT 18
24023: DOUBLE
24024: EQUAL
24025: IFTRUE 24029
24027: GO 24054
24029: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24030: LD_ADDR_VAR 0 3
24034: PUSH
24035: LD_INT 40
24037: PPUSH
24038: LD_VAR 0 1
24042: PPUSH
24043: CALL_OW 321
24047: PUSH
24048: LD_INT 2
24050: EQUAL
24051: ST_TO_ADDR
24052: GO 24088
24054: LD_INT 27
24056: DOUBLE
24057: EQUAL
24058: IFTRUE 24062
24060: GO 24087
24062: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24063: LD_ADDR_VAR 0 3
24067: PUSH
24068: LD_INT 35
24070: PPUSH
24071: LD_VAR 0 1
24075: PPUSH
24076: CALL_OW 321
24080: PUSH
24081: LD_INT 2
24083: EQUAL
24084: ST_TO_ADDR
24085: GO 24088
24087: POP
// end ;
24088: LD_VAR 0 3
24092: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24093: LD_INT 0
24095: PPUSH
24096: PPUSH
24097: PPUSH
24098: PPUSH
24099: PPUSH
24100: PPUSH
24101: PPUSH
24102: PPUSH
24103: PPUSH
24104: PPUSH
24105: PPUSH
// result := false ;
24106: LD_ADDR_VAR 0 6
24110: PUSH
24111: LD_INT 0
24113: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24114: LD_VAR 0 1
24118: NOT
24119: PUSH
24120: LD_VAR 0 1
24124: PPUSH
24125: CALL_OW 266
24129: PUSH
24130: LD_INT 0
24132: PUSH
24133: LD_INT 1
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: IN
24140: NOT
24141: OR
24142: PUSH
24143: LD_VAR 0 2
24147: NOT
24148: OR
24149: PUSH
24150: LD_VAR 0 5
24154: PUSH
24155: LD_INT 0
24157: PUSH
24158: LD_INT 1
24160: PUSH
24161: LD_INT 2
24163: PUSH
24164: LD_INT 3
24166: PUSH
24167: LD_INT 4
24169: PUSH
24170: LD_INT 5
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: LIST
24177: LIST
24178: LIST
24179: LIST
24180: IN
24181: NOT
24182: OR
24183: PUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: LD_VAR 0 4
24193: PPUSH
24194: CALL_OW 488
24198: NOT
24199: OR
24200: IFFALSE 24204
// exit ;
24202: GO 24940
// side := GetSide ( depot ) ;
24204: LD_ADDR_VAR 0 9
24208: PUSH
24209: LD_VAR 0 1
24213: PPUSH
24214: CALL_OW 255
24218: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24219: LD_VAR 0 9
24223: PPUSH
24224: LD_VAR 0 2
24228: PPUSH
24229: CALL 23713 0 2
24233: NOT
24234: IFFALSE 24238
// exit ;
24236: GO 24940
// pom := GetBase ( depot ) ;
24238: LD_ADDR_VAR 0 10
24242: PUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: CALL_OW 274
24252: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24253: LD_ADDR_VAR 0 11
24257: PUSH
24258: LD_VAR 0 2
24262: PPUSH
24263: LD_VAR 0 1
24267: PPUSH
24268: CALL_OW 248
24272: PPUSH
24273: CALL_OW 450
24277: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
24278: LD_VAR 0 10
24282: PPUSH
24283: LD_INT 1
24285: PPUSH
24286: CALL_OW 275
24290: PUSH
24291: LD_VAR 0 11
24295: PUSH
24296: LD_INT 1
24298: ARRAY
24299: GREATEREQUAL
24300: PUSH
24301: LD_VAR 0 10
24305: PPUSH
24306: LD_INT 2
24308: PPUSH
24309: CALL_OW 275
24313: PUSH
24314: LD_VAR 0 11
24318: PUSH
24319: LD_INT 2
24321: ARRAY
24322: GREATEREQUAL
24323: AND
24324: PUSH
24325: LD_VAR 0 10
24329: PPUSH
24330: LD_INT 3
24332: PPUSH
24333: CALL_OW 275
24337: PUSH
24338: LD_VAR 0 11
24342: PUSH
24343: LD_INT 3
24345: ARRAY
24346: GREATEREQUAL
24347: AND
24348: NOT
24349: IFFALSE 24353
// exit ;
24351: GO 24940
// if GetBType ( depot ) = b_depot then
24353: LD_VAR 0 1
24357: PPUSH
24358: CALL_OW 266
24362: PUSH
24363: LD_INT 0
24365: EQUAL
24366: IFFALSE 24378
// dist := 28 else
24368: LD_ADDR_VAR 0 14
24372: PUSH
24373: LD_INT 28
24375: ST_TO_ADDR
24376: GO 24386
// dist := 36 ;
24378: LD_ADDR_VAR 0 14
24382: PUSH
24383: LD_INT 36
24385: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
24386: LD_VAR 0 1
24390: PPUSH
24391: LD_VAR 0 3
24395: PPUSH
24396: LD_VAR 0 4
24400: PPUSH
24401: CALL_OW 297
24405: PUSH
24406: LD_VAR 0 14
24410: GREATER
24411: IFFALSE 24415
// exit ;
24413: GO 24940
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
24415: LD_ADDR_VAR 0 12
24419: PUSH
24420: LD_VAR 0 2
24424: PPUSH
24425: LD_VAR 0 3
24429: PPUSH
24430: LD_VAR 0 4
24434: PPUSH
24435: LD_VAR 0 5
24439: PPUSH
24440: LD_VAR 0 1
24444: PPUSH
24445: CALL_OW 248
24449: PPUSH
24450: LD_INT 0
24452: PPUSH
24453: CALL 24945 0 6
24457: ST_TO_ADDR
// if not hexes then
24458: LD_VAR 0 12
24462: NOT
24463: IFFALSE 24467
// exit ;
24465: GO 24940
// hex := GetHexInfo ( x , y ) ;
24467: LD_ADDR_VAR 0 15
24471: PUSH
24472: LD_VAR 0 3
24476: PPUSH
24477: LD_VAR 0 4
24481: PPUSH
24482: CALL_OW 546
24486: ST_TO_ADDR
// if hex [ 1 ] then
24487: LD_VAR 0 15
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: IFFALSE 24499
// exit ;
24497: GO 24940
// height := hex [ 2 ] ;
24499: LD_ADDR_VAR 0 13
24503: PUSH
24504: LD_VAR 0 15
24508: PUSH
24509: LD_INT 2
24511: ARRAY
24512: ST_TO_ADDR
// for i = 1 to hexes do
24513: LD_ADDR_VAR 0 7
24517: PUSH
24518: DOUBLE
24519: LD_INT 1
24521: DEC
24522: ST_TO_ADDR
24523: LD_VAR 0 12
24527: PUSH
24528: FOR_TO
24529: IFFALSE 24859
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
24531: LD_VAR 0 12
24535: PUSH
24536: LD_VAR 0 7
24540: ARRAY
24541: PUSH
24542: LD_INT 1
24544: ARRAY
24545: PPUSH
24546: LD_VAR 0 12
24550: PUSH
24551: LD_VAR 0 7
24555: ARRAY
24556: PUSH
24557: LD_INT 2
24559: ARRAY
24560: PPUSH
24561: CALL_OW 488
24565: NOT
24566: PUSH
24567: LD_VAR 0 12
24571: PUSH
24572: LD_VAR 0 7
24576: ARRAY
24577: PUSH
24578: LD_INT 1
24580: ARRAY
24581: PPUSH
24582: LD_VAR 0 12
24586: PUSH
24587: LD_VAR 0 7
24591: ARRAY
24592: PUSH
24593: LD_INT 2
24595: ARRAY
24596: PPUSH
24597: CALL_OW 428
24601: PUSH
24602: LD_INT 0
24604: GREATER
24605: OR
24606: PUSH
24607: LD_VAR 0 12
24611: PUSH
24612: LD_VAR 0 7
24616: ARRAY
24617: PUSH
24618: LD_INT 1
24620: ARRAY
24621: PPUSH
24622: LD_VAR 0 12
24626: PUSH
24627: LD_VAR 0 7
24631: ARRAY
24632: PUSH
24633: LD_INT 2
24635: ARRAY
24636: PPUSH
24637: CALL_OW 351
24641: OR
24642: IFFALSE 24648
// exit ;
24644: POP
24645: POP
24646: GO 24940
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
24648: LD_ADDR_VAR 0 8
24652: PUSH
24653: LD_VAR 0 12
24657: PUSH
24658: LD_VAR 0 7
24662: ARRAY
24663: PUSH
24664: LD_INT 1
24666: ARRAY
24667: PPUSH
24668: LD_VAR 0 12
24672: PUSH
24673: LD_VAR 0 7
24677: ARRAY
24678: PUSH
24679: LD_INT 2
24681: ARRAY
24682: PPUSH
24683: CALL_OW 546
24687: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
24688: LD_VAR 0 8
24692: PUSH
24693: LD_INT 1
24695: ARRAY
24696: PUSH
24697: LD_VAR 0 8
24701: PUSH
24702: LD_INT 2
24704: ARRAY
24705: PUSH
24706: LD_VAR 0 13
24710: PUSH
24711: LD_INT 2
24713: PLUS
24714: GREATER
24715: OR
24716: PUSH
24717: LD_VAR 0 8
24721: PUSH
24722: LD_INT 2
24724: ARRAY
24725: PUSH
24726: LD_VAR 0 13
24730: PUSH
24731: LD_INT 2
24733: MINUS
24734: LESS
24735: OR
24736: PUSH
24737: LD_VAR 0 8
24741: PUSH
24742: LD_INT 3
24744: ARRAY
24745: PUSH
24746: LD_INT 0
24748: PUSH
24749: LD_INT 8
24751: PUSH
24752: LD_INT 9
24754: PUSH
24755: LD_INT 10
24757: PUSH
24758: LD_INT 11
24760: PUSH
24761: LD_INT 12
24763: PUSH
24764: LD_INT 13
24766: PUSH
24767: LD_INT 16
24769: PUSH
24770: LD_INT 17
24772: PUSH
24773: LD_INT 18
24775: PUSH
24776: LD_INT 19
24778: PUSH
24779: LD_INT 20
24781: PUSH
24782: LD_INT 21
24784: PUSH
24785: EMPTY
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: LIST
24795: LIST
24796: LIST
24797: LIST
24798: LIST
24799: IN
24800: NOT
24801: OR
24802: PUSH
24803: LD_VAR 0 8
24807: PUSH
24808: LD_INT 5
24810: ARRAY
24811: NOT
24812: OR
24813: PUSH
24814: LD_VAR 0 8
24818: PUSH
24819: LD_INT 6
24821: ARRAY
24822: PUSH
24823: LD_INT 1
24825: PUSH
24826: LD_INT 2
24828: PUSH
24829: LD_INT 7
24831: PUSH
24832: LD_INT 9
24834: PUSH
24835: LD_INT 10
24837: PUSH
24838: LD_INT 11
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: LIST
24845: LIST
24846: LIST
24847: LIST
24848: IN
24849: NOT
24850: OR
24851: IFFALSE 24857
// exit ;
24853: POP
24854: POP
24855: GO 24940
// end ;
24857: GO 24528
24859: POP
24860: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
24861: LD_VAR 0 9
24865: PPUSH
24866: LD_VAR 0 3
24870: PPUSH
24871: LD_VAR 0 4
24875: PPUSH
24876: LD_INT 20
24878: PPUSH
24879: CALL 16886 0 4
24883: PUSH
24884: LD_INT 4
24886: ARRAY
24887: IFFALSE 24891
// exit ;
24889: GO 24940
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
24891: LD_VAR 0 2
24895: PUSH
24896: LD_INT 29
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: IN
24906: PUSH
24907: LD_VAR 0 3
24911: PPUSH
24912: LD_VAR 0 4
24916: PPUSH
24917: LD_VAR 0 9
24921: PPUSH
24922: CALL_OW 440
24926: NOT
24927: AND
24928: IFFALSE 24932
// exit ;
24930: GO 24940
// result := true ;
24932: LD_ADDR_VAR 0 6
24936: PUSH
24937: LD_INT 1
24939: ST_TO_ADDR
// end ;
24940: LD_VAR 0 6
24944: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
24945: LD_INT 0
24947: PPUSH
24948: PPUSH
24949: PPUSH
24950: PPUSH
24951: PPUSH
24952: PPUSH
24953: PPUSH
24954: PPUSH
24955: PPUSH
24956: PPUSH
24957: PPUSH
24958: PPUSH
24959: PPUSH
24960: PPUSH
24961: PPUSH
24962: PPUSH
24963: PPUSH
24964: PPUSH
24965: PPUSH
24966: PPUSH
24967: PPUSH
24968: PPUSH
24969: PPUSH
24970: PPUSH
24971: PPUSH
24972: PPUSH
24973: PPUSH
24974: PPUSH
24975: PPUSH
24976: PPUSH
24977: PPUSH
24978: PPUSH
24979: PPUSH
24980: PPUSH
24981: PPUSH
24982: PPUSH
24983: PPUSH
24984: PPUSH
24985: PPUSH
24986: PPUSH
24987: PPUSH
24988: PPUSH
24989: PPUSH
24990: PPUSH
24991: PPUSH
24992: PPUSH
24993: PPUSH
24994: PPUSH
24995: PPUSH
24996: PPUSH
24997: PPUSH
24998: PPUSH
24999: PPUSH
25000: PPUSH
25001: PPUSH
25002: PPUSH
25003: PPUSH
25004: PPUSH
// result = [ ] ;
25005: LD_ADDR_VAR 0 7
25009: PUSH
25010: EMPTY
25011: ST_TO_ADDR
// temp_list = [ ] ;
25012: LD_ADDR_VAR 0 9
25016: PUSH
25017: EMPTY
25018: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25019: LD_VAR 0 4
25023: PUSH
25024: LD_INT 0
25026: PUSH
25027: LD_INT 1
25029: PUSH
25030: LD_INT 2
25032: PUSH
25033: LD_INT 3
25035: PUSH
25036: LD_INT 4
25038: PUSH
25039: LD_INT 5
25041: PUSH
25042: EMPTY
25043: LIST
25044: LIST
25045: LIST
25046: LIST
25047: LIST
25048: LIST
25049: IN
25050: NOT
25051: PUSH
25052: LD_VAR 0 1
25056: PUSH
25057: LD_INT 0
25059: PUSH
25060: LD_INT 1
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: IN
25067: PUSH
25068: LD_VAR 0 5
25072: PUSH
25073: LD_INT 1
25075: PUSH
25076: LD_INT 2
25078: PUSH
25079: LD_INT 3
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: LIST
25086: IN
25087: NOT
25088: AND
25089: OR
25090: IFFALSE 25094
// exit ;
25092: GO 43485
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25094: LD_VAR 0 1
25098: PUSH
25099: LD_INT 6
25101: PUSH
25102: LD_INT 7
25104: PUSH
25105: LD_INT 8
25107: PUSH
25108: LD_INT 13
25110: PUSH
25111: LD_INT 12
25113: PUSH
25114: LD_INT 15
25116: PUSH
25117: LD_INT 11
25119: PUSH
25120: LD_INT 14
25122: PUSH
25123: LD_INT 10
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: LIST
25130: LIST
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: IN
25137: IFFALSE 25147
// btype = b_lab ;
25139: LD_ADDR_VAR 0 1
25143: PUSH
25144: LD_INT 6
25146: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25147: LD_VAR 0 6
25151: PUSH
25152: LD_INT 0
25154: PUSH
25155: LD_INT 1
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: EMPTY
25162: LIST
25163: LIST
25164: LIST
25165: IN
25166: NOT
25167: PUSH
25168: LD_VAR 0 1
25172: PUSH
25173: LD_INT 0
25175: PUSH
25176: LD_INT 1
25178: PUSH
25179: LD_INT 2
25181: PUSH
25182: LD_INT 3
25184: PUSH
25185: LD_INT 6
25187: PUSH
25188: LD_INT 36
25190: PUSH
25191: LD_INT 4
25193: PUSH
25194: LD_INT 5
25196: PUSH
25197: LD_INT 31
25199: PUSH
25200: LD_INT 32
25202: PUSH
25203: LD_INT 33
25205: PUSH
25206: EMPTY
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: LIST
25214: LIST
25215: LIST
25216: LIST
25217: LIST
25218: IN
25219: NOT
25220: PUSH
25221: LD_VAR 0 6
25225: PUSH
25226: LD_INT 1
25228: EQUAL
25229: AND
25230: OR
25231: PUSH
25232: LD_VAR 0 1
25236: PUSH
25237: LD_INT 2
25239: PUSH
25240: LD_INT 3
25242: PUSH
25243: EMPTY
25244: LIST
25245: LIST
25246: IN
25247: NOT
25248: PUSH
25249: LD_VAR 0 6
25253: PUSH
25254: LD_INT 2
25256: EQUAL
25257: AND
25258: OR
25259: IFFALSE 25269
// mode = 0 ;
25261: LD_ADDR_VAR 0 6
25265: PUSH
25266: LD_INT 0
25268: ST_TO_ADDR
// case mode of 0 :
25269: LD_VAR 0 6
25273: PUSH
25274: LD_INT 0
25276: DOUBLE
25277: EQUAL
25278: IFTRUE 25282
25280: GO 36735
25282: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
25283: LD_ADDR_VAR 0 11
25287: PUSH
25288: LD_INT 0
25290: PUSH
25291: LD_INT 0
25293: PUSH
25294: EMPTY
25295: LIST
25296: LIST
25297: PUSH
25298: LD_INT 0
25300: PUSH
25301: LD_INT 1
25303: NEG
25304: PUSH
25305: EMPTY
25306: LIST
25307: LIST
25308: PUSH
25309: LD_INT 1
25311: PUSH
25312: LD_INT 0
25314: PUSH
25315: EMPTY
25316: LIST
25317: LIST
25318: PUSH
25319: LD_INT 1
25321: PUSH
25322: LD_INT 1
25324: PUSH
25325: EMPTY
25326: LIST
25327: LIST
25328: PUSH
25329: LD_INT 0
25331: PUSH
25332: LD_INT 1
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 1
25341: NEG
25342: PUSH
25343: LD_INT 0
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 1
25352: NEG
25353: PUSH
25354: LD_INT 1
25356: NEG
25357: PUSH
25358: EMPTY
25359: LIST
25360: LIST
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: LD_INT 2
25368: NEG
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PUSH
25374: LD_INT 0
25376: PUSH
25377: LD_INT 2
25379: NEG
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: PUSH
25385: LD_INT 1
25387: PUSH
25388: LD_INT 1
25390: NEG
25391: PUSH
25392: EMPTY
25393: LIST
25394: LIST
25395: PUSH
25396: LD_INT 1
25398: PUSH
25399: LD_INT 2
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 0
25408: PUSH
25409: LD_INT 2
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: LD_INT 1
25418: NEG
25419: PUSH
25420: LD_INT 1
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: LD_INT 1
25429: PUSH
25430: LD_INT 3
25432: PUSH
25433: EMPTY
25434: LIST
25435: LIST
25436: PUSH
25437: LD_INT 0
25439: PUSH
25440: LD_INT 3
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: PUSH
25447: LD_INT 1
25449: NEG
25450: PUSH
25451: LD_INT 2
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: PUSH
25458: EMPTY
25459: LIST
25460: LIST
25461: LIST
25462: LIST
25463: LIST
25464: LIST
25465: LIST
25466: LIST
25467: LIST
25468: LIST
25469: LIST
25470: LIST
25471: LIST
25472: LIST
25473: LIST
25474: LIST
25475: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25476: LD_ADDR_VAR 0 12
25480: PUSH
25481: LD_INT 0
25483: PUSH
25484: LD_INT 0
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 0
25493: PUSH
25494: LD_INT 1
25496: NEG
25497: PUSH
25498: EMPTY
25499: LIST
25500: LIST
25501: PUSH
25502: LD_INT 1
25504: PUSH
25505: LD_INT 0
25507: PUSH
25508: EMPTY
25509: LIST
25510: LIST
25511: PUSH
25512: LD_INT 1
25514: PUSH
25515: LD_INT 1
25517: PUSH
25518: EMPTY
25519: LIST
25520: LIST
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 1
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: PUSH
25532: LD_INT 1
25534: NEG
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: EMPTY
25540: LIST
25541: LIST
25542: PUSH
25543: LD_INT 1
25545: NEG
25546: PUSH
25547: LD_INT 1
25549: NEG
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: PUSH
25555: LD_INT 1
25557: PUSH
25558: LD_INT 1
25560: NEG
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: PUSH
25566: LD_INT 2
25568: PUSH
25569: LD_INT 0
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: LD_INT 2
25578: PUSH
25579: LD_INT 1
25581: PUSH
25582: EMPTY
25583: LIST
25584: LIST
25585: PUSH
25586: LD_INT 1
25588: NEG
25589: PUSH
25590: LD_INT 1
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 2
25599: NEG
25600: PUSH
25601: LD_INT 0
25603: PUSH
25604: EMPTY
25605: LIST
25606: LIST
25607: PUSH
25608: LD_INT 2
25610: NEG
25611: PUSH
25612: LD_INT 1
25614: NEG
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PUSH
25620: LD_INT 2
25622: NEG
25623: PUSH
25624: LD_INT 1
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: PUSH
25631: LD_INT 3
25633: NEG
25634: PUSH
25635: LD_INT 0
25637: PUSH
25638: EMPTY
25639: LIST
25640: LIST
25641: PUSH
25642: LD_INT 3
25644: NEG
25645: PUSH
25646: LD_INT 1
25648: NEG
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: PUSH
25654: EMPTY
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25672: LD_ADDR_VAR 0 13
25676: PUSH
25677: LD_INT 0
25679: PUSH
25680: LD_INT 0
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: PUSH
25687: LD_INT 0
25689: PUSH
25690: LD_INT 1
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 1
25700: PUSH
25701: LD_INT 0
25703: PUSH
25704: EMPTY
25705: LIST
25706: LIST
25707: PUSH
25708: LD_INT 1
25710: PUSH
25711: LD_INT 1
25713: PUSH
25714: EMPTY
25715: LIST
25716: LIST
25717: PUSH
25718: LD_INT 0
25720: PUSH
25721: LD_INT 1
25723: PUSH
25724: EMPTY
25725: LIST
25726: LIST
25727: PUSH
25728: LD_INT 1
25730: NEG
25731: PUSH
25732: LD_INT 0
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: LD_INT 1
25741: NEG
25742: PUSH
25743: LD_INT 1
25745: NEG
25746: PUSH
25747: EMPTY
25748: LIST
25749: LIST
25750: PUSH
25751: LD_INT 1
25753: NEG
25754: PUSH
25755: LD_INT 2
25757: NEG
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 2
25765: PUSH
25766: LD_INT 1
25768: PUSH
25769: EMPTY
25770: LIST
25771: LIST
25772: PUSH
25773: LD_INT 2
25775: PUSH
25776: LD_INT 2
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 1
25785: PUSH
25786: LD_INT 2
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: NEG
25796: PUSH
25797: LD_INT 1
25799: NEG
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: LD_INT 2
25807: NEG
25808: PUSH
25809: LD_INT 2
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 2
25819: NEG
25820: PUSH
25821: LD_INT 3
25823: NEG
25824: PUSH
25825: EMPTY
25826: LIST
25827: LIST
25828: PUSH
25829: LD_INT 3
25831: NEG
25832: PUSH
25833: LD_INT 2
25835: NEG
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 3
25843: NEG
25844: PUSH
25845: LD_INT 3
25847: NEG
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: PUSH
25853: EMPTY
25854: LIST
25855: LIST
25856: LIST
25857: LIST
25858: LIST
25859: LIST
25860: LIST
25861: LIST
25862: LIST
25863: LIST
25864: LIST
25865: LIST
25866: LIST
25867: LIST
25868: LIST
25869: LIST
25870: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
25871: LD_ADDR_VAR 0 14
25875: PUSH
25876: LD_INT 0
25878: PUSH
25879: LD_INT 0
25881: PUSH
25882: EMPTY
25883: LIST
25884: LIST
25885: PUSH
25886: LD_INT 0
25888: PUSH
25889: LD_INT 1
25891: NEG
25892: PUSH
25893: EMPTY
25894: LIST
25895: LIST
25896: PUSH
25897: LD_INT 1
25899: PUSH
25900: LD_INT 0
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 1
25909: PUSH
25910: LD_INT 1
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 0
25919: PUSH
25920: LD_INT 1
25922: PUSH
25923: EMPTY
25924: LIST
25925: LIST
25926: PUSH
25927: LD_INT 1
25929: NEG
25930: PUSH
25931: LD_INT 0
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_INT 1
25940: NEG
25941: PUSH
25942: LD_INT 1
25944: NEG
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 1
25952: NEG
25953: PUSH
25954: LD_INT 2
25956: NEG
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: PUSH
25962: LD_INT 0
25964: PUSH
25965: LD_INT 2
25967: NEG
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 1
25975: PUSH
25976: LD_INT 1
25978: NEG
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: PUSH
25984: LD_INT 1
25986: PUSH
25987: LD_INT 2
25989: PUSH
25990: EMPTY
25991: LIST
25992: LIST
25993: PUSH
25994: LD_INT 0
25996: PUSH
25997: LD_INT 2
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: PUSH
26004: LD_INT 1
26006: NEG
26007: PUSH
26008: LD_INT 1
26010: PUSH
26011: EMPTY
26012: LIST
26013: LIST
26014: PUSH
26015: LD_INT 1
26017: NEG
26018: PUSH
26019: LD_INT 3
26021: NEG
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 0
26029: PUSH
26030: LD_INT 3
26032: NEG
26033: PUSH
26034: EMPTY
26035: LIST
26036: LIST
26037: PUSH
26038: LD_INT 1
26040: PUSH
26041: LD_INT 2
26043: NEG
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: PUSH
26049: EMPTY
26050: LIST
26051: LIST
26052: LIST
26053: LIST
26054: LIST
26055: LIST
26056: LIST
26057: LIST
26058: LIST
26059: LIST
26060: LIST
26061: LIST
26062: LIST
26063: LIST
26064: LIST
26065: LIST
26066: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26067: LD_ADDR_VAR 0 15
26071: PUSH
26072: LD_INT 0
26074: PUSH
26075: LD_INT 0
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 0
26084: PUSH
26085: LD_INT 1
26087: NEG
26088: PUSH
26089: EMPTY
26090: LIST
26091: LIST
26092: PUSH
26093: LD_INT 1
26095: PUSH
26096: LD_INT 0
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: PUSH
26103: LD_INT 1
26105: PUSH
26106: LD_INT 1
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 1
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: LD_INT 0
26129: PUSH
26130: EMPTY
26131: LIST
26132: LIST
26133: PUSH
26134: LD_INT 1
26136: NEG
26137: PUSH
26138: LD_INT 1
26140: NEG
26141: PUSH
26142: EMPTY
26143: LIST
26144: LIST
26145: PUSH
26146: LD_INT 1
26148: PUSH
26149: LD_INT 1
26151: NEG
26152: PUSH
26153: EMPTY
26154: LIST
26155: LIST
26156: PUSH
26157: LD_INT 2
26159: PUSH
26160: LD_INT 0
26162: PUSH
26163: EMPTY
26164: LIST
26165: LIST
26166: PUSH
26167: LD_INT 2
26169: PUSH
26170: LD_INT 1
26172: PUSH
26173: EMPTY
26174: LIST
26175: LIST
26176: PUSH
26177: LD_INT 1
26179: NEG
26180: PUSH
26181: LD_INT 1
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: NEG
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 2
26201: NEG
26202: PUSH
26203: LD_INT 1
26205: NEG
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: LD_INT 2
26213: PUSH
26214: LD_INT 1
26216: NEG
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: PUSH
26222: LD_INT 3
26224: PUSH
26225: LD_INT 0
26227: PUSH
26228: EMPTY
26229: LIST
26230: LIST
26231: PUSH
26232: LD_INT 3
26234: PUSH
26235: LD_INT 1
26237: PUSH
26238: EMPTY
26239: LIST
26240: LIST
26241: PUSH
26242: EMPTY
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: LIST
26254: LIST
26255: LIST
26256: LIST
26257: LIST
26258: LIST
26259: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
26260: LD_ADDR_VAR 0 16
26264: PUSH
26265: LD_INT 0
26267: PUSH
26268: LD_INT 0
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: LD_INT 1
26280: NEG
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 0
26291: PUSH
26292: EMPTY
26293: LIST
26294: LIST
26295: PUSH
26296: LD_INT 1
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 0
26308: PUSH
26309: LD_INT 1
26311: PUSH
26312: EMPTY
26313: LIST
26314: LIST
26315: PUSH
26316: LD_INT 1
26318: NEG
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 1
26329: NEG
26330: PUSH
26331: LD_INT 1
26333: NEG
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: LD_INT 1
26341: NEG
26342: PUSH
26343: LD_INT 2
26345: NEG
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 2
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 2
26363: PUSH
26364: LD_INT 2
26366: PUSH
26367: EMPTY
26368: LIST
26369: LIST
26370: PUSH
26371: LD_INT 1
26373: PUSH
26374: LD_INT 2
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: LD_INT 1
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 2
26395: NEG
26396: PUSH
26397: LD_INT 2
26399: NEG
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 3
26407: PUSH
26408: LD_INT 2
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 3
26417: PUSH
26418: LD_INT 3
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 2
26427: PUSH
26428: LD_INT 3
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: LIST
26452: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26453: LD_ADDR_VAR 0 17
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: LD_INT 0
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: LD_INT 0
26470: PUSH
26471: LD_INT 1
26473: NEG
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: PUSH
26479: LD_INT 1
26481: PUSH
26482: LD_INT 0
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: LD_INT 1
26494: PUSH
26495: EMPTY
26496: LIST
26497: LIST
26498: PUSH
26499: LD_INT 0
26501: PUSH
26502: LD_INT 1
26504: PUSH
26505: EMPTY
26506: LIST
26507: LIST
26508: PUSH
26509: LD_INT 1
26511: NEG
26512: PUSH
26513: LD_INT 0
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PUSH
26520: LD_INT 1
26522: NEG
26523: PUSH
26524: LD_INT 1
26526: NEG
26527: PUSH
26528: EMPTY
26529: LIST
26530: LIST
26531: PUSH
26532: LD_INT 1
26534: NEG
26535: PUSH
26536: LD_INT 2
26538: NEG
26539: PUSH
26540: EMPTY
26541: LIST
26542: LIST
26543: PUSH
26544: LD_INT 0
26546: PUSH
26547: LD_INT 2
26549: NEG
26550: PUSH
26551: EMPTY
26552: LIST
26553: LIST
26554: PUSH
26555: LD_INT 1
26557: PUSH
26558: LD_INT 1
26560: NEG
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: LD_INT 2
26568: PUSH
26569: LD_INT 0
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: LD_INT 2
26578: PUSH
26579: LD_INT 1
26581: PUSH
26582: EMPTY
26583: LIST
26584: LIST
26585: PUSH
26586: LD_INT 2
26588: PUSH
26589: LD_INT 2
26591: PUSH
26592: EMPTY
26593: LIST
26594: LIST
26595: PUSH
26596: LD_INT 1
26598: PUSH
26599: LD_INT 2
26601: PUSH
26602: EMPTY
26603: LIST
26604: LIST
26605: PUSH
26606: LD_INT 0
26608: PUSH
26609: LD_INT 2
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: PUSH
26616: LD_INT 1
26618: NEG
26619: PUSH
26620: LD_INT 1
26622: PUSH
26623: EMPTY
26624: LIST
26625: LIST
26626: PUSH
26627: LD_INT 2
26629: NEG
26630: PUSH
26631: LD_INT 0
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: LD_INT 2
26640: NEG
26641: PUSH
26642: LD_INT 1
26644: NEG
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: PUSH
26650: LD_INT 2
26652: NEG
26653: PUSH
26654: LD_INT 2
26656: NEG
26657: PUSH
26658: EMPTY
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: LIST
26666: LIST
26667: LIST
26668: LIST
26669: LIST
26670: LIST
26671: LIST
26672: LIST
26673: LIST
26674: LIST
26675: LIST
26676: LIST
26677: LIST
26678: LIST
26679: LIST
26680: LIST
26681: LIST
26682: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26683: LD_ADDR_VAR 0 18
26687: PUSH
26688: LD_INT 0
26690: PUSH
26691: LD_INT 0
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 0
26700: PUSH
26701: LD_INT 1
26703: NEG
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: LD_INT 0
26714: PUSH
26715: EMPTY
26716: LIST
26717: LIST
26718: PUSH
26719: LD_INT 1
26721: PUSH
26722: LD_INT 1
26724: PUSH
26725: EMPTY
26726: LIST
26727: LIST
26728: PUSH
26729: LD_INT 0
26731: PUSH
26732: LD_INT 1
26734: PUSH
26735: EMPTY
26736: LIST
26737: LIST
26738: PUSH
26739: LD_INT 1
26741: NEG
26742: PUSH
26743: LD_INT 0
26745: PUSH
26746: EMPTY
26747: LIST
26748: LIST
26749: PUSH
26750: LD_INT 1
26752: NEG
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: NEG
26765: PUSH
26766: LD_INT 2
26768: NEG
26769: PUSH
26770: EMPTY
26771: LIST
26772: LIST
26773: PUSH
26774: LD_INT 0
26776: PUSH
26777: LD_INT 2
26779: NEG
26780: PUSH
26781: EMPTY
26782: LIST
26783: LIST
26784: PUSH
26785: LD_INT 1
26787: PUSH
26788: LD_INT 1
26790: NEG
26791: PUSH
26792: EMPTY
26793: LIST
26794: LIST
26795: PUSH
26796: LD_INT 2
26798: PUSH
26799: LD_INT 0
26801: PUSH
26802: EMPTY
26803: LIST
26804: LIST
26805: PUSH
26806: LD_INT 2
26808: PUSH
26809: LD_INT 1
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 2
26818: PUSH
26819: LD_INT 2
26821: PUSH
26822: EMPTY
26823: LIST
26824: LIST
26825: PUSH
26826: LD_INT 1
26828: PUSH
26829: LD_INT 2
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 0
26838: PUSH
26839: LD_INT 2
26841: PUSH
26842: EMPTY
26843: LIST
26844: LIST
26845: PUSH
26846: LD_INT 1
26848: NEG
26849: PUSH
26850: LD_INT 1
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 2
26859: NEG
26860: PUSH
26861: LD_INT 0
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: LD_INT 1
26874: NEG
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 2
26882: NEG
26883: PUSH
26884: LD_INT 2
26886: NEG
26887: PUSH
26888: EMPTY
26889: LIST
26890: LIST
26891: PUSH
26892: EMPTY
26893: LIST
26894: LIST
26895: LIST
26896: LIST
26897: LIST
26898: LIST
26899: LIST
26900: LIST
26901: LIST
26902: LIST
26903: LIST
26904: LIST
26905: LIST
26906: LIST
26907: LIST
26908: LIST
26909: LIST
26910: LIST
26911: LIST
26912: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
26913: LD_ADDR_VAR 0 19
26917: PUSH
26918: LD_INT 0
26920: PUSH
26921: LD_INT 0
26923: PUSH
26924: EMPTY
26925: LIST
26926: LIST
26927: PUSH
26928: LD_INT 0
26930: PUSH
26931: LD_INT 1
26933: NEG
26934: PUSH
26935: EMPTY
26936: LIST
26937: LIST
26938: PUSH
26939: LD_INT 1
26941: PUSH
26942: LD_INT 0
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 1
26951: PUSH
26952: LD_INT 1
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: LD_INT 0
26961: PUSH
26962: LD_INT 1
26964: PUSH
26965: EMPTY
26966: LIST
26967: LIST
26968: PUSH
26969: LD_INT 1
26971: NEG
26972: PUSH
26973: LD_INT 0
26975: PUSH
26976: EMPTY
26977: LIST
26978: LIST
26979: PUSH
26980: LD_INT 1
26982: NEG
26983: PUSH
26984: LD_INT 1
26986: NEG
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: LD_INT 2
26998: NEG
26999: PUSH
27000: EMPTY
27001: LIST
27002: LIST
27003: PUSH
27004: LD_INT 0
27006: PUSH
27007: LD_INT 2
27009: NEG
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: LD_INT 1
27017: PUSH
27018: LD_INT 1
27020: NEG
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PUSH
27026: LD_INT 2
27028: PUSH
27029: LD_INT 0
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 2
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 2
27048: PUSH
27049: LD_INT 2
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 1
27058: PUSH
27059: LD_INT 2
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 0
27068: PUSH
27069: LD_INT 2
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PUSH
27076: LD_INT 1
27078: NEG
27079: PUSH
27080: LD_INT 1
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PUSH
27087: LD_INT 2
27089: NEG
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: EMPTY
27095: LIST
27096: LIST
27097: PUSH
27098: LD_INT 2
27100: NEG
27101: PUSH
27102: LD_INT 1
27104: NEG
27105: PUSH
27106: EMPTY
27107: LIST
27108: LIST
27109: PUSH
27110: LD_INT 2
27112: NEG
27113: PUSH
27114: LD_INT 2
27116: NEG
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: EMPTY
27123: LIST
27124: LIST
27125: LIST
27126: LIST
27127: LIST
27128: LIST
27129: LIST
27130: LIST
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: LIST
27136: LIST
27137: LIST
27138: LIST
27139: LIST
27140: LIST
27141: LIST
27142: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27143: LD_ADDR_VAR 0 20
27147: PUSH
27148: LD_INT 0
27150: PUSH
27151: LD_INT 0
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 0
27160: PUSH
27161: LD_INT 1
27163: NEG
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 1
27171: PUSH
27172: LD_INT 0
27174: PUSH
27175: EMPTY
27176: LIST
27177: LIST
27178: PUSH
27179: LD_INT 1
27181: PUSH
27182: LD_INT 1
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: PUSH
27189: LD_INT 0
27191: PUSH
27192: LD_INT 1
27194: PUSH
27195: EMPTY
27196: LIST
27197: LIST
27198: PUSH
27199: LD_INT 1
27201: NEG
27202: PUSH
27203: LD_INT 0
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 1
27216: NEG
27217: PUSH
27218: EMPTY
27219: LIST
27220: LIST
27221: PUSH
27222: LD_INT 1
27224: NEG
27225: PUSH
27226: LD_INT 2
27228: NEG
27229: PUSH
27230: EMPTY
27231: LIST
27232: LIST
27233: PUSH
27234: LD_INT 0
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 1
27247: PUSH
27248: LD_INT 1
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 2
27258: PUSH
27259: LD_INT 0
27261: PUSH
27262: EMPTY
27263: LIST
27264: LIST
27265: PUSH
27266: LD_INT 2
27268: PUSH
27269: LD_INT 1
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: PUSH
27276: LD_INT 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: LD_INT 1
27288: PUSH
27289: LD_INT 2
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 2
27301: PUSH
27302: EMPTY
27303: LIST
27304: LIST
27305: PUSH
27306: LD_INT 1
27308: NEG
27309: PUSH
27310: LD_INT 1
27312: PUSH
27313: EMPTY
27314: LIST
27315: LIST
27316: PUSH
27317: LD_INT 2
27319: NEG
27320: PUSH
27321: LD_INT 0
27323: PUSH
27324: EMPTY
27325: LIST
27326: LIST
27327: PUSH
27328: LD_INT 2
27330: NEG
27331: PUSH
27332: LD_INT 1
27334: NEG
27335: PUSH
27336: EMPTY
27337: LIST
27338: LIST
27339: PUSH
27340: LD_INT 2
27342: NEG
27343: PUSH
27344: LD_INT 2
27346: NEG
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: PUSH
27352: EMPTY
27353: LIST
27354: LIST
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: LIST
27360: LIST
27361: LIST
27362: LIST
27363: LIST
27364: LIST
27365: LIST
27366: LIST
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27373: LD_ADDR_VAR 0 21
27377: PUSH
27378: LD_INT 0
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: PUSH
27388: LD_INT 0
27390: PUSH
27391: LD_INT 1
27393: NEG
27394: PUSH
27395: EMPTY
27396: LIST
27397: LIST
27398: PUSH
27399: LD_INT 1
27401: PUSH
27402: LD_INT 0
27404: PUSH
27405: EMPTY
27406: LIST
27407: LIST
27408: PUSH
27409: LD_INT 1
27411: PUSH
27412: LD_INT 1
27414: PUSH
27415: EMPTY
27416: LIST
27417: LIST
27418: PUSH
27419: LD_INT 0
27421: PUSH
27422: LD_INT 1
27424: PUSH
27425: EMPTY
27426: LIST
27427: LIST
27428: PUSH
27429: LD_INT 1
27431: NEG
27432: PUSH
27433: LD_INT 0
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: LD_INT 1
27442: NEG
27443: PUSH
27444: LD_INT 1
27446: NEG
27447: PUSH
27448: EMPTY
27449: LIST
27450: LIST
27451: PUSH
27452: LD_INT 1
27454: NEG
27455: PUSH
27456: LD_INT 2
27458: NEG
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: LD_INT 0
27466: PUSH
27467: LD_INT 2
27469: NEG
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 1
27477: PUSH
27478: LD_INT 1
27480: NEG
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 2
27488: PUSH
27489: LD_INT 0
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: LD_INT 2
27498: PUSH
27499: LD_INT 1
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PUSH
27506: LD_INT 2
27508: PUSH
27509: LD_INT 2
27511: PUSH
27512: EMPTY
27513: LIST
27514: LIST
27515: PUSH
27516: LD_INT 1
27518: PUSH
27519: LD_INT 2
27521: PUSH
27522: EMPTY
27523: LIST
27524: LIST
27525: PUSH
27526: LD_INT 0
27528: PUSH
27529: LD_INT 2
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 1
27538: NEG
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 2
27549: NEG
27550: PUSH
27551: LD_INT 0
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: PUSH
27558: LD_INT 2
27560: NEG
27561: PUSH
27562: LD_INT 1
27564: NEG
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: PUSH
27570: LD_INT 2
27572: NEG
27573: PUSH
27574: LD_INT 2
27576: NEG
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: LIST
27590: LIST
27591: LIST
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: LIST
27599: LIST
27600: LIST
27601: LIST
27602: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27603: LD_ADDR_VAR 0 22
27607: PUSH
27608: LD_INT 0
27610: PUSH
27611: LD_INT 0
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: NEG
27624: PUSH
27625: EMPTY
27626: LIST
27627: LIST
27628: PUSH
27629: LD_INT 1
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: PUSH
27642: LD_INT 1
27644: PUSH
27645: EMPTY
27646: LIST
27647: LIST
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: LD_INT 1
27654: PUSH
27655: EMPTY
27656: LIST
27657: LIST
27658: PUSH
27659: LD_INT 1
27661: NEG
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: LD_INT 1
27672: NEG
27673: PUSH
27674: LD_INT 1
27676: NEG
27677: PUSH
27678: EMPTY
27679: LIST
27680: LIST
27681: PUSH
27682: LD_INT 1
27684: NEG
27685: PUSH
27686: LD_INT 2
27688: NEG
27689: PUSH
27690: EMPTY
27691: LIST
27692: LIST
27693: PUSH
27694: LD_INT 0
27696: PUSH
27697: LD_INT 2
27699: NEG
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 1
27710: NEG
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: PUSH
27716: LD_INT 2
27718: PUSH
27719: LD_INT 0
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: PUSH
27726: LD_INT 2
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 2
27738: PUSH
27739: LD_INT 2
27741: PUSH
27742: EMPTY
27743: LIST
27744: LIST
27745: PUSH
27746: LD_INT 1
27748: PUSH
27749: LD_INT 2
27751: PUSH
27752: EMPTY
27753: LIST
27754: LIST
27755: PUSH
27756: LD_INT 0
27758: PUSH
27759: LD_INT 2
27761: PUSH
27762: EMPTY
27763: LIST
27764: LIST
27765: PUSH
27766: LD_INT 1
27768: NEG
27769: PUSH
27770: LD_INT 1
27772: PUSH
27773: EMPTY
27774: LIST
27775: LIST
27776: PUSH
27777: LD_INT 2
27779: NEG
27780: PUSH
27781: LD_INT 0
27783: PUSH
27784: EMPTY
27785: LIST
27786: LIST
27787: PUSH
27788: LD_INT 2
27790: NEG
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: EMPTY
27797: LIST
27798: LIST
27799: PUSH
27800: LD_INT 2
27802: NEG
27803: PUSH
27804: LD_INT 2
27806: NEG
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: PUSH
27812: EMPTY
27813: LIST
27814: LIST
27815: LIST
27816: LIST
27817: LIST
27818: LIST
27819: LIST
27820: LIST
27821: LIST
27822: LIST
27823: LIST
27824: LIST
27825: LIST
27826: LIST
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
27833: LD_ADDR_VAR 0 23
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 0
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: PUSH
27848: LD_INT 0
27850: PUSH
27851: LD_INT 1
27853: NEG
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 0
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 1
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 0
27881: PUSH
27882: LD_INT 1
27884: PUSH
27885: EMPTY
27886: LIST
27887: LIST
27888: PUSH
27889: LD_INT 1
27891: NEG
27892: PUSH
27893: LD_INT 0
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: LD_INT 1
27902: NEG
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: PUSH
27912: LD_INT 1
27914: NEG
27915: PUSH
27916: LD_INT 2
27918: NEG
27919: PUSH
27920: EMPTY
27921: LIST
27922: LIST
27923: PUSH
27924: LD_INT 0
27926: PUSH
27927: LD_INT 2
27929: NEG
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PUSH
27935: LD_INT 1
27937: PUSH
27938: LD_INT 1
27940: NEG
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 2
27948: PUSH
27949: LD_INT 0
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 2
27958: PUSH
27959: LD_INT 1
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 2
27968: PUSH
27969: LD_INT 2
27971: PUSH
27972: EMPTY
27973: LIST
27974: LIST
27975: PUSH
27976: LD_INT 1
27978: PUSH
27979: LD_INT 2
27981: PUSH
27982: EMPTY
27983: LIST
27984: LIST
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 2
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: PUSH
27996: LD_INT 1
27998: NEG
27999: PUSH
28000: LD_INT 1
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: LD_INT 2
28009: NEG
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: PUSH
28018: LD_INT 2
28020: NEG
28021: PUSH
28022: LD_INT 1
28024: NEG
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 2
28032: NEG
28033: PUSH
28034: LD_INT 2
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 2
28044: NEG
28045: PUSH
28046: LD_INT 3
28048: NEG
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 1
28056: NEG
28057: PUSH
28058: LD_INT 3
28060: NEG
28061: PUSH
28062: EMPTY
28063: LIST
28064: LIST
28065: PUSH
28066: LD_INT 1
28068: PUSH
28069: LD_INT 2
28071: NEG
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: LD_INT 1
28082: NEG
28083: PUSH
28084: EMPTY
28085: LIST
28086: LIST
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: LIST
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28113: LD_ADDR_VAR 0 24
28117: PUSH
28118: LD_INT 0
28120: PUSH
28121: LD_INT 0
28123: PUSH
28124: EMPTY
28125: LIST
28126: LIST
28127: PUSH
28128: LD_INT 0
28130: PUSH
28131: LD_INT 1
28133: NEG
28134: PUSH
28135: EMPTY
28136: LIST
28137: LIST
28138: PUSH
28139: LD_INT 1
28141: PUSH
28142: LD_INT 0
28144: PUSH
28145: EMPTY
28146: LIST
28147: LIST
28148: PUSH
28149: LD_INT 1
28151: PUSH
28152: LD_INT 1
28154: PUSH
28155: EMPTY
28156: LIST
28157: LIST
28158: PUSH
28159: LD_INT 0
28161: PUSH
28162: LD_INT 1
28164: PUSH
28165: EMPTY
28166: LIST
28167: LIST
28168: PUSH
28169: LD_INT 1
28171: NEG
28172: PUSH
28173: LD_INT 0
28175: PUSH
28176: EMPTY
28177: LIST
28178: LIST
28179: PUSH
28180: LD_INT 1
28182: NEG
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: EMPTY
28189: LIST
28190: LIST
28191: PUSH
28192: LD_INT 1
28194: NEG
28195: PUSH
28196: LD_INT 2
28198: NEG
28199: PUSH
28200: EMPTY
28201: LIST
28202: LIST
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 2
28209: NEG
28210: PUSH
28211: EMPTY
28212: LIST
28213: LIST
28214: PUSH
28215: LD_INT 1
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: EMPTY
28223: LIST
28224: LIST
28225: PUSH
28226: LD_INT 2
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: EMPTY
28233: LIST
28234: LIST
28235: PUSH
28236: LD_INT 2
28238: PUSH
28239: LD_INT 1
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 2
28248: PUSH
28249: LD_INT 2
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: LD_INT 1
28258: PUSH
28259: LD_INT 2
28261: PUSH
28262: EMPTY
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: LD_INT 2
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: PUSH
28276: LD_INT 1
28278: NEG
28279: PUSH
28280: LD_INT 1
28282: PUSH
28283: EMPTY
28284: LIST
28285: LIST
28286: PUSH
28287: LD_INT 2
28289: NEG
28290: PUSH
28291: LD_INT 0
28293: PUSH
28294: EMPTY
28295: LIST
28296: LIST
28297: PUSH
28298: LD_INT 2
28300: NEG
28301: PUSH
28302: LD_INT 1
28304: NEG
28305: PUSH
28306: EMPTY
28307: LIST
28308: LIST
28309: PUSH
28310: LD_INT 2
28312: NEG
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: EMPTY
28319: LIST
28320: LIST
28321: PUSH
28322: LD_INT 1
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: LD_INT 1
28338: NEG
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 3
28346: PUSH
28347: LD_INT 1
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 3
28356: PUSH
28357: LD_INT 2
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: LIST
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
28389: LD_ADDR_VAR 0 25
28393: PUSH
28394: LD_INT 0
28396: PUSH
28397: LD_INT 0
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: PUSH
28404: LD_INT 0
28406: PUSH
28407: LD_INT 1
28409: NEG
28410: PUSH
28411: EMPTY
28412: LIST
28413: LIST
28414: PUSH
28415: LD_INT 1
28417: PUSH
28418: LD_INT 0
28420: PUSH
28421: EMPTY
28422: LIST
28423: LIST
28424: PUSH
28425: LD_INT 1
28427: PUSH
28428: LD_INT 1
28430: PUSH
28431: EMPTY
28432: LIST
28433: LIST
28434: PUSH
28435: LD_INT 0
28437: PUSH
28438: LD_INT 1
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PUSH
28445: LD_INT 1
28447: NEG
28448: PUSH
28449: LD_INT 0
28451: PUSH
28452: EMPTY
28453: LIST
28454: LIST
28455: PUSH
28456: LD_INT 1
28458: NEG
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: EMPTY
28465: LIST
28466: LIST
28467: PUSH
28468: LD_INT 1
28470: NEG
28471: PUSH
28472: LD_INT 2
28474: NEG
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 0
28482: PUSH
28483: LD_INT 2
28485: NEG
28486: PUSH
28487: EMPTY
28488: LIST
28489: LIST
28490: PUSH
28491: LD_INT 1
28493: PUSH
28494: LD_INT 1
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 2
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: EMPTY
28509: LIST
28510: LIST
28511: PUSH
28512: LD_INT 2
28514: PUSH
28515: LD_INT 1
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 2
28524: PUSH
28525: LD_INT 2
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 0
28544: PUSH
28545: LD_INT 2
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: LD_INT 1
28554: NEG
28555: PUSH
28556: LD_INT 1
28558: PUSH
28559: EMPTY
28560: LIST
28561: LIST
28562: PUSH
28563: LD_INT 2
28565: NEG
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: EMPTY
28571: LIST
28572: LIST
28573: PUSH
28574: LD_INT 2
28576: NEG
28577: PUSH
28578: LD_INT 1
28580: NEG
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: LD_INT 2
28588: NEG
28589: PUSH
28590: LD_INT 2
28592: NEG
28593: PUSH
28594: EMPTY
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 3
28600: PUSH
28601: LD_INT 1
28603: PUSH
28604: EMPTY
28605: LIST
28606: LIST
28607: PUSH
28608: LD_INT 3
28610: PUSH
28611: LD_INT 2
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: PUSH
28618: LD_INT 2
28620: PUSH
28621: LD_INT 3
28623: PUSH
28624: EMPTY
28625: LIST
28626: LIST
28627: PUSH
28628: LD_INT 1
28630: PUSH
28631: LD_INT 3
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: EMPTY
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: LIST
28660: LIST
28661: LIST
28662: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
28663: LD_ADDR_VAR 0 26
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: EMPTY
28686: LIST
28687: LIST
28688: PUSH
28689: LD_INT 1
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: PUSH
28702: LD_INT 1
28704: PUSH
28705: EMPTY
28706: LIST
28707: LIST
28708: PUSH
28709: LD_INT 0
28711: PUSH
28712: LD_INT 1
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: PUSH
28719: LD_INT 1
28721: NEG
28722: PUSH
28723: LD_INT 0
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 1
28732: NEG
28733: PUSH
28734: LD_INT 1
28736: NEG
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 2
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 0
28756: PUSH
28757: LD_INT 2
28759: NEG
28760: PUSH
28761: EMPTY
28762: LIST
28763: LIST
28764: PUSH
28765: LD_INT 1
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 0
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: LD_INT 2
28788: PUSH
28789: LD_INT 1
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 2
28798: PUSH
28799: LD_INT 2
28801: PUSH
28802: EMPTY
28803: LIST
28804: LIST
28805: PUSH
28806: LD_INT 1
28808: PUSH
28809: LD_INT 2
28811: PUSH
28812: EMPTY
28813: LIST
28814: LIST
28815: PUSH
28816: LD_INT 0
28818: PUSH
28819: LD_INT 2
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: NEG
28829: PUSH
28830: LD_INT 1
28832: PUSH
28833: EMPTY
28834: LIST
28835: LIST
28836: PUSH
28837: LD_INT 2
28839: NEG
28840: PUSH
28841: LD_INT 0
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: PUSH
28848: LD_INT 2
28850: NEG
28851: PUSH
28852: LD_INT 1
28854: NEG
28855: PUSH
28856: EMPTY
28857: LIST
28858: LIST
28859: PUSH
28860: LD_INT 2
28862: NEG
28863: PUSH
28864: LD_INT 2
28866: NEG
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PUSH
28872: LD_INT 2
28874: PUSH
28875: LD_INT 3
28877: PUSH
28878: EMPTY
28879: LIST
28880: LIST
28881: PUSH
28882: LD_INT 1
28884: PUSH
28885: LD_INT 3
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 2
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: PUSH
28903: LD_INT 2
28905: NEG
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: LIST
28926: LIST
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: LIST
28937: LIST
28938: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
28939: LD_ADDR_VAR 0 27
28943: PUSH
28944: LD_INT 0
28946: PUSH
28947: LD_INT 0
28949: PUSH
28950: EMPTY
28951: LIST
28952: LIST
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: LD_INT 0
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: LD_INT 1
28980: PUSH
28981: EMPTY
28982: LIST
28983: LIST
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: LD_INT 1
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: PUSH
28995: LD_INT 1
28997: NEG
28998: PUSH
28999: LD_INT 0
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: LD_INT 1
29008: NEG
29009: PUSH
29010: LD_INT 1
29012: NEG
29013: PUSH
29014: EMPTY
29015: LIST
29016: LIST
29017: PUSH
29018: LD_INT 1
29020: NEG
29021: PUSH
29022: LD_INT 2
29024: NEG
29025: PUSH
29026: EMPTY
29027: LIST
29028: LIST
29029: PUSH
29030: LD_INT 0
29032: PUSH
29033: LD_INT 2
29035: NEG
29036: PUSH
29037: EMPTY
29038: LIST
29039: LIST
29040: PUSH
29041: LD_INT 1
29043: PUSH
29044: LD_INT 1
29046: NEG
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 2
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: EMPTY
29059: LIST
29060: LIST
29061: PUSH
29062: LD_INT 2
29064: PUSH
29065: LD_INT 1
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 2
29074: PUSH
29075: LD_INT 2
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PUSH
29082: LD_INT 1
29084: PUSH
29085: LD_INT 2
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: PUSH
29092: LD_INT 0
29094: PUSH
29095: LD_INT 2
29097: PUSH
29098: EMPTY
29099: LIST
29100: LIST
29101: PUSH
29102: LD_INT 1
29104: NEG
29105: PUSH
29106: LD_INT 1
29108: PUSH
29109: EMPTY
29110: LIST
29111: LIST
29112: PUSH
29113: LD_INT 2
29115: NEG
29116: PUSH
29117: LD_INT 0
29119: PUSH
29120: EMPTY
29121: LIST
29122: LIST
29123: PUSH
29124: LD_INT 2
29126: NEG
29127: PUSH
29128: LD_INT 1
29130: NEG
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 2
29138: NEG
29139: PUSH
29140: LD_INT 2
29142: NEG
29143: PUSH
29144: EMPTY
29145: LIST
29146: LIST
29147: PUSH
29148: LD_INT 1
29150: NEG
29151: PUSH
29152: LD_INT 2
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: PUSH
29159: LD_INT 2
29161: NEG
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 3
29172: NEG
29173: PUSH
29174: LD_INT 1
29176: NEG
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 3
29184: NEG
29185: PUSH
29186: LD_INT 2
29188: NEG
29189: PUSH
29190: EMPTY
29191: LIST
29192: LIST
29193: PUSH
29194: EMPTY
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29219: LD_ADDR_VAR 0 28
29223: PUSH
29224: LD_INT 0
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: LD_INT 1
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: LD_INT 1
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: EMPTY
29252: LIST
29253: LIST
29254: PUSH
29255: LD_INT 1
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: LD_INT 0
29281: PUSH
29282: EMPTY
29283: LIST
29284: LIST
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: EMPTY
29295: LIST
29296: LIST
29297: PUSH
29298: LD_INT 1
29300: NEG
29301: PUSH
29302: LD_INT 2
29304: NEG
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: LD_INT 2
29315: NEG
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: PUSH
29321: LD_INT 1
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: LD_INT 0
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 2
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 2
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 2
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: NEG
29385: PUSH
29386: LD_INT 1
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 2
29395: NEG
29396: PUSH
29397: LD_INT 0
29399: PUSH
29400: EMPTY
29401: LIST
29402: LIST
29403: PUSH
29404: LD_INT 2
29406: NEG
29407: PUSH
29408: LD_INT 1
29410: NEG
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: LD_INT 2
29418: NEG
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: LD_INT 2
29430: NEG
29431: PUSH
29432: LD_INT 3
29434: NEG
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: NEG
29443: PUSH
29444: LD_INT 3
29446: NEG
29447: PUSH
29448: EMPTY
29449: LIST
29450: LIST
29451: PUSH
29452: LD_INT 3
29454: NEG
29455: PUSH
29456: LD_INT 1
29458: NEG
29459: PUSH
29460: EMPTY
29461: LIST
29462: LIST
29463: PUSH
29464: LD_INT 3
29466: NEG
29467: PUSH
29468: LD_INT 2
29470: NEG
29471: PUSH
29472: EMPTY
29473: LIST
29474: LIST
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
29501: LD_ADDR_VAR 0 29
29505: PUSH
29506: LD_INT 0
29508: PUSH
29509: LD_INT 0
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 1
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 0
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 1
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: LD_INT 1
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 0
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: LD_INT 1
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: LD_INT 2
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 0
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 1
29636: PUSH
29637: LD_INT 2
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 2
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: NEG
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 2
29667: NEG
29668: PUSH
29669: LD_INT 1
29671: NEG
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 2
29679: NEG
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: EMPTY
29686: LIST
29687: LIST
29688: PUSH
29689: LD_INT 2
29691: NEG
29692: PUSH
29693: LD_INT 3
29695: NEG
29696: PUSH
29697: EMPTY
29698: LIST
29699: LIST
29700: PUSH
29701: LD_INT 2
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 3
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: LD_INT 3
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: NEG
29735: PUSH
29736: LD_INT 2
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 3
29745: NEG
29746: PUSH
29747: LD_INT 2
29749: NEG
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: LIST
29759: LIST
29760: LIST
29761: LIST
29762: LIST
29763: LIST
29764: LIST
29765: LIST
29766: LIST
29767: LIST
29768: LIST
29769: LIST
29770: LIST
29771: LIST
29772: LIST
29773: LIST
29774: LIST
29775: LIST
29776: LIST
29777: LIST
29778: LIST
29779: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
29780: LD_ADDR_VAR 0 30
29784: PUSH
29785: LD_INT 0
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 0
29797: PUSH
29798: LD_INT 1
29800: NEG
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 1
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 1
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 0
29828: PUSH
29829: LD_INT 1
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 1
29838: NEG
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 1
29849: NEG
29850: PUSH
29851: LD_INT 1
29853: NEG
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 1
29861: NEG
29862: PUSH
29863: LD_INT 2
29865: NEG
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 0
29873: PUSH
29874: LD_INT 2
29876: NEG
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 1
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 2
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 2
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 2
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: LD_INT 1
29939: PUSH
29940: EMPTY
29941: LIST
29942: LIST
29943: PUSH
29944: LD_INT 2
29946: NEG
29947: PUSH
29948: LD_INT 0
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 2
29957: NEG
29958: PUSH
29959: LD_INT 1
29961: NEG
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 1
29969: NEG
29970: PUSH
29971: LD_INT 3
29973: NEG
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: LD_INT 2
29984: NEG
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 3
29992: PUSH
29993: LD_INT 2
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 3
30023: NEG
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30058: LD_ADDR_VAR 0 31
30062: PUSH
30063: LD_INT 0
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: EMPTY
30091: LIST
30092: LIST
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: LD_INT 0
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: NEG
30128: PUSH
30129: LD_INT 1
30131: NEG
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: LD_INT 2
30143: NEG
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 1
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 2
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: LD_INT 2
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 0
30202: PUSH
30203: LD_INT 2
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 2
30223: NEG
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 2
30247: NEG
30248: PUSH
30249: LD_INT 3
30251: NEG
30252: PUSH
30253: EMPTY
30254: LIST
30255: LIST
30256: PUSH
30257: LD_INT 2
30259: PUSH
30260: LD_INT 1
30262: NEG
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 3
30270: PUSH
30271: LD_INT 1
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: LD_INT 1
30280: PUSH
30281: LD_INT 3
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 3
30301: NEG
30302: PUSH
30303: LD_INT 2
30305: NEG
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: LIST
30315: LIST
30316: LIST
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30336: LD_ADDR_VAR 0 32
30340: PUSH
30341: LD_INT 0
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: LD_INT 1
30356: NEG
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: PUSH
30375: LD_INT 1
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: NEG
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 1
30409: NEG
30410: PUSH
30411: EMPTY
30412: LIST
30413: LIST
30414: PUSH
30415: LD_INT 1
30417: NEG
30418: PUSH
30419: LD_INT 2
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: PUSH
30452: LD_INT 1
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 2
30461: PUSH
30462: LD_INT 2
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: LD_INT 2
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 1
30491: NEG
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: LD_INT 0
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 3
30529: NEG
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 3
30548: PUSH
30549: LD_INT 2
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 2
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: LD_INT 1
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 3
30579: NEG
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: EMPTY
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30614: LD_ADDR_VAR 0 33
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 0
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 0
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 1
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 0
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: NEG
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 1
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 1
30695: NEG
30696: PUSH
30697: LD_INT 2
30699: NEG
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 1
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: EMPTY
30713: LIST
30714: LIST
30715: PUSH
30716: LD_INT 2
30718: PUSH
30719: LD_INT 0
30721: PUSH
30722: EMPTY
30723: LIST
30724: LIST
30725: PUSH
30726: LD_INT 2
30728: PUSH
30729: LD_INT 1
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 0
30748: PUSH
30749: LD_INT 2
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: LD_INT 2
30796: NEG
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 2
30804: NEG
30805: PUSH
30806: LD_INT 3
30808: NEG
30809: PUSH
30810: EMPTY
30811: LIST
30812: LIST
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: PUSH
30825: LD_INT 3
30827: PUSH
30828: LD_INT 1
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 3
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: NEG
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 3
30858: NEG
30859: PUSH
30860: LD_INT 2
30862: NEG
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: LIST
30872: LIST
30873: LIST
30874: LIST
30875: LIST
30876: LIST
30877: LIST
30878: LIST
30879: LIST
30880: LIST
30881: LIST
30882: LIST
30883: LIST
30884: LIST
30885: LIST
30886: LIST
30887: LIST
30888: LIST
30889: LIST
30890: LIST
30891: LIST
30892: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30893: LD_ADDR_VAR 0 34
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: LD_INT 0
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: NEG
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 1
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 1
30951: NEG
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 1
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: LD_INT 2
30989: NEG
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: PUSH
31009: LD_INT 1
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 2
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: LD_INT 2
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 1
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 0
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 2
31060: NEG
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: NEG
31085: PUSH
31086: LD_INT 3
31088: NEG
31089: PUSH
31090: EMPTY
31091: LIST
31092: LIST
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: LD_INT 2
31099: NEG
31100: PUSH
31101: EMPTY
31102: LIST
31103: LIST
31104: PUSH
31105: LD_INT 3
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: EMPTY
31112: LIST
31113: LIST
31114: PUSH
31115: LD_INT 2
31117: PUSH
31118: LD_INT 3
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: LD_INT 1
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: LD_INT 3
31138: NEG
31139: PUSH
31140: LD_INT 1
31142: NEG
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31173: LD_ADDR_VAR 0 35
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: PUSH
31255: LD_INT 1
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 2
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: LIST
31284: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31285: LD_ADDR_VAR 0 36
31289: PUSH
31290: LD_INT 0
31292: PUSH
31293: LD_INT 0
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: LD_INT 1
31305: NEG
31306: PUSH
31307: EMPTY
31308: LIST
31309: LIST
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: LD_INT 0
31316: PUSH
31317: EMPTY
31318: LIST
31319: LIST
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 0
31333: PUSH
31334: LD_INT 1
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 0
31347: PUSH
31348: EMPTY
31349: LIST
31350: LIST
31351: PUSH
31352: LD_INT 1
31354: NEG
31355: PUSH
31356: LD_INT 1
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: NEG
31367: PUSH
31368: LD_INT 2
31370: NEG
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 1
31378: PUSH
31379: LD_INT 2
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: EMPTY
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31397: LD_ADDR_VAR 0 37
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 0
31414: PUSH
31415: LD_INT 1
31417: NEG
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 0
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: LD_INT 1
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 1
31466: NEG
31467: PUSH
31468: LD_INT 1
31470: NEG
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: LD_INT 1
31481: NEG
31482: PUSH
31483: EMPTY
31484: LIST
31485: LIST
31486: PUSH
31487: LD_INT 1
31489: NEG
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: EMPTY
31495: LIST
31496: LIST
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31509: LD_ADDR_VAR 0 38
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 0
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 1
31529: NEG
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 0
31557: PUSH
31558: LD_INT 1
31560: PUSH
31561: EMPTY
31562: LIST
31563: LIST
31564: PUSH
31565: LD_INT 1
31567: NEG
31568: PUSH
31569: LD_INT 0
31571: PUSH
31572: EMPTY
31573: LIST
31574: LIST
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: LD_INT 1
31582: NEG
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: LD_INT 1
31604: NEG
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
31621: LD_ADDR_VAR 0 39
31625: PUSH
31626: LD_INT 0
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: EMPTY
31633: LIST
31634: LIST
31635: PUSH
31636: LD_INT 0
31638: PUSH
31639: LD_INT 1
31641: NEG
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 1
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 0
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 1
31694: NEG
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 2
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
31733: LD_ADDR_VAR 0 40
31737: PUSH
31738: LD_INT 0
31740: PUSH
31741: LD_INT 0
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 0
31750: PUSH
31751: LD_INT 1
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 0
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 1
31806: NEG
31807: PUSH
31808: EMPTY
31809: LIST
31810: LIST
31811: PUSH
31812: LD_INT 1
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 1
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31845: LD_ADDR_VAR 0 41
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 0
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 1
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: LD_INT 1
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 0
31893: PUSH
31894: LD_INT 1
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 1
31903: NEG
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: NEG
31927: PUSH
31928: LD_INT 2
31930: NEG
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: PUSH
31939: LD_INT 1
31941: NEG
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: PUSH
31950: LD_INT 0
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: PUSH
31957: LD_INT 2
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 1
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: NEG
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 2
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: NEG
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 2
32023: NEG
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: LD_INT 3
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 2
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 3
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 3
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 3
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 3
32088: PUSH
32089: LD_INT 3
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: LD_INT 3
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 3
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 3
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 3
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: NEG
32155: PUSH
32156: LD_INT 3
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32195: LD_ADDR_VAR 0 42
32199: PUSH
32200: LD_INT 0
32202: PUSH
32203: LD_INT 0
32205: PUSH
32206: EMPTY
32207: LIST
32208: LIST
32209: PUSH
32210: LD_INT 0
32212: PUSH
32213: LD_INT 1
32215: NEG
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 1
32223: PUSH
32224: LD_INT 0
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 1
32246: PUSH
32247: EMPTY
32248: LIST
32249: LIST
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: NEG
32277: PUSH
32278: LD_INT 2
32280: NEG
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: LD_INT 2
32291: NEG
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: PUSH
32300: LD_INT 1
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 2
32310: PUSH
32311: LD_INT 1
32313: PUSH
32314: EMPTY
32315: LIST
32316: LIST
32317: PUSH
32318: LD_INT 2
32320: PUSH
32321: LD_INT 2
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 2
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: LD_INT 2
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 1
32350: NEG
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: NEG
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: LD_INT 2
32377: NEG
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: LD_INT 2
32385: NEG
32386: PUSH
32387: LD_INT 3
32389: NEG
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: PUSH
32395: LD_INT 1
32397: NEG
32398: PUSH
32399: LD_INT 3
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 3
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 1
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: LD_INT 2
32451: PUSH
32452: LD_INT 3
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 1
32461: PUSH
32462: LD_INT 3
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 3
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 2
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 3
32492: NEG
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: EMPTY
32499: LIST
32500: LIST
32501: PUSH
32502: LD_INT 3
32504: NEG
32505: PUSH
32506: LD_INT 3
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: LIST
32530: LIST
32531: LIST
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32545: LD_ADDR_VAR 0 43
32549: PUSH
32550: LD_INT 0
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 1
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 0
32576: PUSH
32577: EMPTY
32578: LIST
32579: LIST
32580: PUSH
32581: LD_INT 1
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 1
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 0
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: LD_INT 2
32630: NEG
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 0
32638: PUSH
32639: LD_INT 2
32641: NEG
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: LD_INT 0
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 2
32670: PUSH
32671: LD_INT 1
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: LD_INT 2
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 0
32690: PUSH
32691: LD_INT 2
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: NEG
32712: PUSH
32713: LD_INT 0
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: NEG
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 3
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: NEG
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 2
32768: PUSH
32769: LD_INT 1
32771: NEG
32772: PUSH
32773: EMPTY
32774: LIST
32775: LIST
32776: PUSH
32777: LD_INT 3
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 3
32789: PUSH
32790: LD_INT 1
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 1
32799: PUSH
32800: LD_INT 3
32802: PUSH
32803: EMPTY
32804: LIST
32805: LIST
32806: PUSH
32807: LD_INT 0
32809: PUSH
32810: LD_INT 3
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: LD_INT 1
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 0
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: LD_INT 1
32856: NEG
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32893: LD_ADDR_VAR 0 44
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 1
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 2
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: LD_INT 2
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 2
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: EMPTY
33022: LIST
33023: LIST
33024: PUSH
33025: LD_INT 1
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: LD_INT 0
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 3
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 0
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 3
33116: PUSH
33117: LD_INT 1
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: LD_INT 2
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 3
33136: PUSH
33137: LD_INT 3
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 2
33146: PUSH
33147: LD_INT 3
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 2
33156: NEG
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 3
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: NEG
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: LD_INT 2
33194: NEG
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 3
33202: NEG
33203: PUSH
33204: LD_INT 3
33206: NEG
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: LIST
33242: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33243: LD_ADDR_VAR 0 45
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: LD_INT 0
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: LD_INT 1
33263: NEG
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 0
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 1
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 0
33291: PUSH
33292: LD_INT 1
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 1
33312: NEG
33313: PUSH
33314: LD_INT 1
33316: NEG
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 0
33336: PUSH
33337: LD_INT 2
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: EMPTY
33363: LIST
33364: LIST
33365: PUSH
33366: LD_INT 2
33368: PUSH
33369: LD_INT 2
33371: PUSH
33372: EMPTY
33373: LIST
33374: LIST
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: EMPTY
33404: LIST
33405: LIST
33406: PUSH
33407: LD_INT 2
33409: NEG
33410: PUSH
33411: LD_INT 1
33413: NEG
33414: PUSH
33415: EMPTY
33416: LIST
33417: LIST
33418: PUSH
33419: LD_INT 2
33421: NEG
33422: PUSH
33423: LD_INT 2
33425: NEG
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 2
33433: NEG
33434: PUSH
33435: LD_INT 3
33437: NEG
33438: PUSH
33439: EMPTY
33440: LIST
33441: LIST
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: LD_INT 3
33449: NEG
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 3
33460: NEG
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 3
33489: PUSH
33490: LD_INT 3
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 2
33499: PUSH
33500: LD_INT 3
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: LD_INT 3
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: LD_INT 3
33522: PUSH
33523: EMPTY
33524: LIST
33525: LIST
33526: PUSH
33527: LD_INT 1
33529: NEG
33530: PUSH
33531: LD_INT 2
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 3
33552: NEG
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33593: LD_ADDR_VAR 0 46
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: LD_INT 0
33603: PUSH
33604: EMPTY
33605: LIST
33606: LIST
33607: PUSH
33608: LD_INT 0
33610: PUSH
33611: LD_INT 1
33613: NEG
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: EMPTY
33626: LIST
33627: LIST
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: EMPTY
33636: LIST
33637: LIST
33638: PUSH
33639: LD_INT 0
33641: PUSH
33642: LD_INT 1
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 1
33651: NEG
33652: PUSH
33653: LD_INT 0
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: LD_INT 1
33666: NEG
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: NEG
33675: PUSH
33676: LD_INT 2
33678: NEG
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 0
33686: PUSH
33687: LD_INT 2
33689: NEG
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: PUSH
33695: LD_INT 1
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: EMPTY
33703: LIST
33704: LIST
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: LD_INT 0
33711: PUSH
33712: EMPTY
33713: LIST
33714: LIST
33715: PUSH
33716: LD_INT 2
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: EMPTY
33723: LIST
33724: LIST
33725: PUSH
33726: LD_INT 1
33728: PUSH
33729: LD_INT 2
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: LD_INT 2
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: LD_INT 1
33752: PUSH
33753: EMPTY
33754: LIST
33755: LIST
33756: PUSH
33757: LD_INT 2
33759: NEG
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 2
33770: NEG
33771: PUSH
33772: LD_INT 1
33774: NEG
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 3
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 0
33794: PUSH
33795: LD_INT 3
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 2
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 3
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: LD_INT 3
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 3
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 3
33889: NEG
33890: PUSH
33891: LD_INT 0
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 3
33900: NEG
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: LIST
33921: LIST
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33941: LD_ADDR_VAR 0 47
33945: PUSH
33946: LD_INT 0
33948: PUSH
33949: LD_INT 0
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 1
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 0
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: NEG
34000: PUSH
34001: LD_INT 0
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: LD_INT 1
34014: NEG
34015: PUSH
34016: EMPTY
34017: LIST
34018: LIST
34019: PUSH
34020: LD_INT 1
34022: NEG
34023: PUSH
34024: LD_INT 2
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 0
34034: PUSH
34035: LD_INT 2
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 1
34060: NEG
34061: PUSH
34062: EMPTY
34063: LIST
34064: LIST
34065: PUSH
34066: LD_INT 2
34068: NEG
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34092: LD_ADDR_VAR 0 48
34096: PUSH
34097: LD_INT 0
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 0
34109: PUSH
34110: LD_INT 1
34112: NEG
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 1
34120: PUSH
34121: LD_INT 0
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: EMPTY
34202: LIST
34203: LIST
34204: PUSH
34205: LD_INT 2
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
34239: LD_ADDR_VAR 0 49
34243: PUSH
34244: LD_INT 0
34246: PUSH
34247: LD_INT 0
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 0
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: LD_INT 0
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 1
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 1
34297: NEG
34298: PUSH
34299: LD_INT 0
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 1
34323: NEG
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 2
34331: PUSH
34332: LD_INT 0
34334: PUSH
34335: EMPTY
34336: LIST
34337: LIST
34338: PUSH
34339: LD_INT 2
34341: PUSH
34342: LD_INT 1
34344: PUSH
34345: EMPTY
34346: LIST
34347: LIST
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: LD_INT 2
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: PUSH
34362: LD_INT 2
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
34383: LD_ADDR_VAR 0 50
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: LD_INT 0
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 0
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: PUSH
34412: LD_INT 0
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 1
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 1
34441: NEG
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
34527: LD_ADDR_VAR 0 51
34531: PUSH
34532: LD_INT 0
34534: PUSH
34535: LD_INT 0
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 1
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: LD_INT 0
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 2
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 1
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: LD_INT 0
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 2
34650: NEG
34651: PUSH
34652: LD_INT 1
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34674: LD_ADDR_VAR 0 52
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: LD_INT 0
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34825: LD_ADDR_VAR 0 53
34829: PUSH
34830: LD_INT 0
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: EMPTY
34837: LIST
34838: LIST
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: EMPTY
34858: LIST
34859: LIST
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: LD_INT 1
34866: PUSH
34867: EMPTY
34868: LIST
34869: LIST
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: LD_INT 1
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: LD_INT 1
34898: NEG
34899: PUSH
34900: EMPTY
34901: LIST
34902: LIST
34903: PUSH
34904: LD_INT 1
34906: NEG
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 1
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: LD_INT 0
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 2
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: PUSH
34971: LD_INT 2
34973: PUSH
34974: EMPTY
34975: LIST
34976: LIST
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 2
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: LD_INT 1
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 2
35001: NEG
35002: PUSH
35003: LD_INT 0
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: NEG
35013: PUSH
35014: LD_INT 1
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 2
35024: NEG
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: LIST
35038: LIST
35039: LIST
35040: LIST
35041: LIST
35042: LIST
35043: LIST
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: LIST
35049: LIST
35050: LIST
35051: LIST
35052: LIST
35053: LIST
35054: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35055: LD_ADDR_VAR 0 54
35059: PUSH
35060: LD_INT 0
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 1
35083: PUSH
35084: LD_INT 0
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: PUSH
35091: LD_INT 1
35093: PUSH
35094: LD_INT 1
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: NEG
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: LD_INT 1
35128: NEG
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 0
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 2
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 2
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: PUSH
35191: LD_INT 2
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 2
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 2
35231: NEG
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: NEG
35243: PUSH
35244: LD_INT 1
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 2
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: LIST
35268: LIST
35269: LIST
35270: LIST
35271: LIST
35272: LIST
35273: LIST
35274: LIST
35275: LIST
35276: LIST
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35285: LD_ADDR_VAR 0 55
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: EMPTY
35297: LIST
35298: LIST
35299: PUSH
35300: LD_INT 0
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 0
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 1
35354: NEG
35355: PUSH
35356: LD_INT 1
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 0
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: PUSH
35390: LD_INT 1
35392: NEG
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 2
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 2
35410: PUSH
35411: LD_INT 1
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 2
35420: PUSH
35421: LD_INT 2
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 2
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 2
35461: NEG
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: EMPTY
35467: LIST
35468: LIST
35469: PUSH
35470: LD_INT 2
35472: NEG
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: LD_INT 2
35488: NEG
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: LIST
35498: LIST
35499: LIST
35500: LIST
35501: LIST
35502: LIST
35503: LIST
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35515: LD_ADDR_VAR 0 56
35519: PUSH
35520: LD_INT 0
35522: PUSH
35523: LD_INT 0
35525: PUSH
35526: EMPTY
35527: LIST
35528: LIST
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 1
35553: PUSH
35554: LD_INT 1
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 0
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: PUSH
35582: LD_INT 1
35584: NEG
35585: PUSH
35586: LD_INT 1
35588: NEG
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 2
35600: NEG
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 2
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 2
35640: PUSH
35641: LD_INT 1
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PUSH
35648: LD_INT 2
35650: PUSH
35651: LD_INT 2
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 1
35660: PUSH
35661: LD_INT 2
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 1
35680: NEG
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 2
35691: NEG
35692: PUSH
35693: LD_INT 0
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: NEG
35703: PUSH
35704: LD_INT 1
35706: NEG
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 2
35714: NEG
35715: PUSH
35716: LD_INT 2
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35745: LD_ADDR_VAR 0 57
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: EMPTY
35757: LIST
35758: LIST
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: LD_INT 0
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 1
35783: PUSH
35784: LD_INT 1
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: LD_INT 0
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 2
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: LD_INT 2
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 2
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 2
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: EMPTY
35875: LIST
35876: LIST
35877: PUSH
35878: LD_INT 2
35880: PUSH
35881: LD_INT 2
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 1
35890: PUSH
35891: LD_INT 2
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 1
35910: NEG
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 2
35921: NEG
35922: PUSH
35923: LD_INT 0
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 2
35932: NEG
35933: PUSH
35934: LD_INT 1
35936: NEG
35937: PUSH
35938: EMPTY
35939: LIST
35940: LIST
35941: PUSH
35942: LD_INT 2
35944: NEG
35945: PUSH
35946: LD_INT 2
35948: NEG
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35975: LD_ADDR_VAR 0 58
35979: PUSH
35980: LD_INT 0
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 1
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 1
36003: PUSH
36004: LD_INT 0
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: LD_INT 1
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: NEG
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 1
36048: NEG
36049: PUSH
36050: EMPTY
36051: LIST
36052: LIST
36053: PUSH
36054: LD_INT 1
36056: NEG
36057: PUSH
36058: LD_INT 2
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 2
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: NEG
36152: PUSH
36153: LD_INT 0
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 2
36162: NEG
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: PUSH
36172: LD_INT 2
36174: NEG
36175: PUSH
36176: LD_INT 2
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36205: LD_ADDR_VAR 0 59
36209: PUSH
36210: LD_INT 0
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 0
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 1
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: EMPTY
36248: LIST
36249: LIST
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_INT 1
36256: PUSH
36257: EMPTY
36258: LIST
36259: LIST
36260: PUSH
36261: LD_INT 1
36263: NEG
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36293: LD_ADDR_VAR 0 60
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36381: LD_ADDR_VAR 0 61
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: LD_INT 0
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: LD_INT 1
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 1
36409: PUSH
36410: LD_INT 0
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 1
36432: PUSH
36433: EMPTY
36434: LIST
36435: LIST
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: LD_INT 0
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: LD_INT 1
36454: NEG
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: EMPTY
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36469: LD_ADDR_VAR 0 62
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 1
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 1
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 0
36517: PUSH
36518: LD_INT 1
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 1
36527: NEG
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 1
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36557: LD_ADDR_VAR 0 63
36561: PUSH
36562: LD_INT 0
36564: PUSH
36565: LD_INT 0
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 1
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 1
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: LIST
36640: LIST
36641: LIST
36642: LIST
36643: LIST
36644: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36645: LD_ADDR_VAR 0 64
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 0
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 0
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 1
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 1
36703: NEG
36704: PUSH
36705: LD_INT 0
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: LD_INT 1
36718: NEG
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: LIST
36730: LIST
36731: LIST
36732: ST_TO_ADDR
// end ; 1 :
36733: GO 42630
36735: LD_INT 1
36737: DOUBLE
36738: EQUAL
36739: IFTRUE 36743
36741: GO 39366
36743: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36744: LD_ADDR_VAR 0 11
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 3
36755: NEG
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: LD_INT 3
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: PUSH
36775: LD_INT 2
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: LIST
36787: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36788: LD_ADDR_VAR 0 12
36792: PUSH
36793: LD_INT 2
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 3
36806: PUSH
36807: LD_INT 0
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 3
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: EMPTY
36825: LIST
36826: LIST
36827: LIST
36828: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
36829: LD_ADDR_VAR 0 13
36833: PUSH
36834: LD_INT 3
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 3
36846: PUSH
36847: LD_INT 3
36849: PUSH
36850: EMPTY
36851: LIST
36852: LIST
36853: PUSH
36854: LD_INT 2
36856: PUSH
36857: LD_INT 3
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: LIST
36868: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
36869: LD_ADDR_VAR 0 14
36873: PUSH
36874: LD_INT 1
36876: PUSH
36877: LD_INT 3
36879: PUSH
36880: EMPTY
36881: LIST
36882: LIST
36883: PUSH
36884: LD_INT 0
36886: PUSH
36887: LD_INT 3
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: NEG
36897: PUSH
36898: LD_INT 2
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: LIST
36909: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36910: LD_ADDR_VAR 0 15
36914: PUSH
36915: LD_INT 2
36917: NEG
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: EMPTY
36923: LIST
36924: LIST
36925: PUSH
36926: LD_INT 3
36928: NEG
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 3
36939: NEG
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: EMPTY
36950: LIST
36951: LIST
36952: LIST
36953: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36954: LD_ADDR_VAR 0 16
36958: PUSH
36959: LD_INT 2
36961: NEG
36962: PUSH
36963: LD_INT 3
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: NEG
36974: PUSH
36975: LD_INT 2
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: NEG
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: LIST
36999: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37000: LD_ADDR_VAR 0 17
37004: PUSH
37005: LD_INT 1
37007: NEG
37008: PUSH
37009: LD_INT 3
37011: NEG
37012: PUSH
37013: EMPTY
37014: LIST
37015: LIST
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: LD_INT 3
37022: NEG
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 1
37030: PUSH
37031: LD_INT 2
37033: NEG
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37044: LD_ADDR_VAR 0 18
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: LIST
37084: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37085: LD_ADDR_VAR 0 19
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 3
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: PUSH
37113: LD_INT 3
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: EMPTY
37121: LIST
37122: LIST
37123: LIST
37124: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37125: LD_ADDR_VAR 0 20
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: EMPTY
37137: LIST
37138: LIST
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37166: LD_ADDR_VAR 0 21
37170: PUSH
37171: LD_INT 2
37173: NEG
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 3
37184: NEG
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 3
37195: NEG
37196: PUSH
37197: LD_INT 1
37199: NEG
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: LIST
37209: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37210: LD_ADDR_VAR 0 22
37214: PUSH
37215: LD_INT 2
37217: NEG
37218: PUSH
37219: LD_INT 3
37221: NEG
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: NEG
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 23
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 3
37266: NEG
37267: PUSH
37268: EMPTY
37269: LIST
37270: LIST
37271: PUSH
37272: LD_INT 1
37274: NEG
37275: PUSH
37276: LD_INT 4
37278: NEG
37279: PUSH
37280: EMPTY
37281: LIST
37282: LIST
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: LD_INT 3
37289: NEG
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: LIST
37299: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
37300: LD_ADDR_VAR 0 24
37304: PUSH
37305: LD_INT 3
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 3
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 4
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: EMPTY
37333: LIST
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
37341: LD_ADDR_VAR 0 25
37345: PUSH
37346: LD_INT 3
37348: PUSH
37349: LD_INT 3
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 4
37358: PUSH
37359: LD_INT 3
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: PUSH
37369: LD_INT 4
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
37381: LD_ADDR_VAR 0 26
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: PUSH
37399: LD_INT 4
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: LD_INT 3
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: LIST
37421: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
37422: LD_ADDR_VAR 0 27
37426: PUSH
37427: LD_INT 3
37429: NEG
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 3
37440: NEG
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 4
37451: NEG
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: LIST
37465: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
37466: LD_ADDR_VAR 0 28
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: LD_INT 3
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 3
37485: NEG
37486: PUSH
37487: LD_INT 4
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 4
37497: NEG
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: LIST
37511: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
37512: LD_ADDR_VAR 0 29
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 4
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: LD_INT 4
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: PUSH
37577: LD_INT 3
37579: NEG
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: NEG
37588: PUSH
37589: LD_INT 5
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 0
37599: PUSH
37600: LD_INT 5
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 1
37610: PUSH
37611: LD_INT 4
37613: NEG
37614: PUSH
37615: EMPTY
37616: LIST
37617: LIST
37618: PUSH
37619: LD_INT 1
37621: NEG
37622: PUSH
37623: LD_INT 6
37625: NEG
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 6
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 5
37647: NEG
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
37667: LD_ADDR_VAR 0 30
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: LD_INT 1
37708: NEG
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: PUSH
37714: LD_INT 4
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 4
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 4
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 5
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 5
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 5
37767: PUSH
37768: LD_INT 1
37770: NEG
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: LD_INT 6
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 6
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
37810: LD_ADDR_VAR 0 31
37814: PUSH
37815: LD_INT 3
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 3
37827: PUSH
37828: LD_INT 3
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 4
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 4
37857: PUSH
37858: LD_INT 4
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: PUSH
37868: LD_INT 4
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: PUSH
37875: LD_INT 5
37877: PUSH
37878: LD_INT 4
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 5
37887: PUSH
37888: LD_INT 5
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 4
37897: PUSH
37898: LD_INT 5
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 6
37907: PUSH
37908: LD_INT 5
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 6
37917: PUSH
37918: LD_INT 6
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: PUSH
37928: LD_INT 6
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
37949: LD_ADDR_VAR 0 32
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: LD_INT 3
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 3
37969: PUSH
37970: EMPTY
37971: LIST
37972: LIST
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: LD_INT 2
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 4
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 4
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 3
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: PUSH
38019: LD_INT 5
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: LD_INT 5
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: NEG
38039: PUSH
38040: LD_INT 4
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: LD_INT 6
38052: PUSH
38053: EMPTY
38054: LIST
38055: LIST
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: LD_INT 6
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: NEG
38070: PUSH
38071: LD_INT 5
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: LIST
38089: LIST
38090: LIST
38091: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38092: LD_ADDR_VAR 0 33
38096: PUSH
38097: LD_INT 2
38099: NEG
38100: PUSH
38101: LD_INT 1
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 3
38110: NEG
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 3
38121: NEG
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 3
38133: NEG
38134: PUSH
38135: LD_INT 1
38137: PUSH
38138: EMPTY
38139: LIST
38140: LIST
38141: PUSH
38142: LD_INT 4
38144: NEG
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PUSH
38153: LD_INT 4
38155: NEG
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 4
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 5
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 5
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 5
38201: NEG
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 6
38212: NEG
38213: PUSH
38214: LD_INT 0
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 6
38223: NEG
38224: PUSH
38225: LD_INT 1
38227: NEG
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
38247: LD_ADDR_VAR 0 34
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 3
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 3
38266: NEG
38267: PUSH
38268: LD_INT 2
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 3
38278: NEG
38279: PUSH
38280: LD_INT 3
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 3
38290: NEG
38291: PUSH
38292: LD_INT 4
38294: NEG
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 4
38302: NEG
38303: PUSH
38304: LD_INT 3
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 4
38314: NEG
38315: PUSH
38316: LD_INT 4
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 4
38326: NEG
38327: PUSH
38328: LD_INT 5
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 5
38338: NEG
38339: PUSH
38340: LD_INT 4
38342: NEG
38343: PUSH
38344: EMPTY
38345: LIST
38346: LIST
38347: PUSH
38348: LD_INT 5
38350: NEG
38351: PUSH
38352: LD_INT 5
38354: NEG
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 5
38362: NEG
38363: PUSH
38364: LD_INT 6
38366: NEG
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 6
38374: NEG
38375: PUSH
38376: LD_INT 5
38378: NEG
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 6
38386: NEG
38387: PUSH
38388: LD_INT 6
38390: NEG
38391: PUSH
38392: EMPTY
38393: LIST
38394: LIST
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
38410: LD_ADDR_VAR 0 41
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: LD_INT 3
38432: NEG
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: LIST
38453: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
38454: LD_ADDR_VAR 0 42
38458: PUSH
38459: LD_INT 2
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: LD_INT 2
38471: PUSH
38472: LD_INT 1
38474: NEG
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
38495: LD_ADDR_VAR 0 43
38499: PUSH
38500: LD_INT 2
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 3
38512: PUSH
38513: LD_INT 2
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: PUSH
38523: LD_INT 3
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: LIST
38534: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
38535: LD_ADDR_VAR 0 44
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 3
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 1
38562: NEG
38563: PUSH
38564: LD_INT 2
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: LIST
38575: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
38576: LD_ADDR_VAR 0 45
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 3
38605: NEG
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: LIST
38619: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
38620: LD_ADDR_VAR 0 46
38624: PUSH
38625: LD_INT 2
38627: NEG
38628: PUSH
38629: LD_INT 2
38631: NEG
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 2
38639: NEG
38640: PUSH
38641: LD_INT 3
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 3
38651: NEG
38652: PUSH
38653: LD_INT 2
38655: NEG
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: LIST
38665: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
38666: LD_ADDR_VAR 0 47
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: LD_INT 3
38677: NEG
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: NEG
38686: PUSH
38687: LD_INT 3
38689: NEG
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: EMPTY
38696: LIST
38697: LIST
38698: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
38699: LD_ADDR_VAR 0 48
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 2
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 2
38717: PUSH
38718: LD_INT 1
38720: NEG
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
38730: LD_ADDR_VAR 0 49
38734: PUSH
38735: LD_INT 3
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 3
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
38759: LD_ADDR_VAR 0 50
38763: PUSH
38764: LD_INT 2
38766: PUSH
38767: LD_INT 3
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 3
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
38788: LD_ADDR_VAR 0 51
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: LD_INT 2
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 2
38806: NEG
38807: PUSH
38808: LD_INT 1
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
38819: LD_ADDR_VAR 0 52
38823: PUSH
38824: LD_INT 3
38826: NEG
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 3
38838: NEG
38839: PUSH
38840: LD_INT 2
38842: NEG
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
38852: LD_ADDR_VAR 0 53
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: LD_INT 3
38863: NEG
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 0
38871: PUSH
38872: LD_INT 3
38874: NEG
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: LD_INT 1
38882: PUSH
38883: LD_INT 2
38885: NEG
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: LIST
38895: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
38896: LD_ADDR_VAR 0 54
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 3
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 3
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: LIST
38936: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
38937: LD_ADDR_VAR 0 55
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: LD_INT 2
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 3
38954: PUSH
38955: LD_INT 3
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 3
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: LIST
38976: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
38977: LD_ADDR_VAR 0 56
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 3
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 3
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 2
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: EMPTY
39014: LIST
39015: LIST
39016: LIST
39017: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39018: LD_ADDR_VAR 0 57
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 3
39036: NEG
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 3
39047: NEG
39048: PUSH
39049: LD_INT 1
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: LIST
39061: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39062: LD_ADDR_VAR 0 58
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: LD_INT 3
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 3
39081: NEG
39082: PUSH
39083: LD_INT 2
39085: NEG
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 3
39093: NEG
39094: PUSH
39095: LD_INT 3
39097: NEG
39098: PUSH
39099: EMPTY
39100: LIST
39101: LIST
39102: PUSH
39103: EMPTY
39104: LIST
39105: LIST
39106: LIST
39107: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39108: LD_ADDR_VAR 0 59
39112: PUSH
39113: LD_INT 1
39115: NEG
39116: PUSH
39117: LD_INT 2
39119: NEG
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: LD_INT 2
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39152: LD_ADDR_VAR 0 60
39156: PUSH
39157: LD_INT 1
39159: PUSH
39160: LD_INT 1
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 2
39170: PUSH
39171: LD_INT 0
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: PUSH
39181: LD_INT 1
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: LIST
39192: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39193: LD_ADDR_VAR 0 61
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: LD_INT 1
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: LD_INT 2
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 1
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: LIST
39232: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
39233: LD_ADDR_VAR 0 62
39237: PUSH
39238: LD_INT 1
39240: PUSH
39241: LD_INT 2
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 0
39250: PUSH
39251: LD_INT 2
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: LD_INT 1
39264: PUSH
39265: EMPTY
39266: LIST
39267: LIST
39268: PUSH
39269: EMPTY
39270: LIST
39271: LIST
39272: LIST
39273: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39274: LD_ADDR_VAR 0 63
39278: PUSH
39279: LD_INT 1
39281: NEG
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 2
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: EMPTY
39314: LIST
39315: LIST
39316: LIST
39317: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39318: LD_ADDR_VAR 0 64
39322: PUSH
39323: LD_INT 1
39325: NEG
39326: PUSH
39327: LD_INT 2
39329: NEG
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: NEG
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: LIST
39363: ST_TO_ADDR
// end ; 2 :
39364: GO 42630
39366: LD_INT 2
39368: DOUBLE
39369: EQUAL
39370: IFTRUE 39374
39372: GO 42629
39374: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
39375: LD_ADDR_VAR 0 29
39379: PUSH
39380: LD_INT 4
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 4
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 5
39403: PUSH
39404: LD_INT 0
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 5
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 4
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 3
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 3
39443: PUSH
39444: LD_INT 1
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: EMPTY
39460: LIST
39461: LIST
39462: PUSH
39463: LD_INT 5
39465: PUSH
39466: LD_INT 2
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 3
39475: PUSH
39476: LD_INT 3
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 3
39485: PUSH
39486: LD_INT 2
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 4
39495: PUSH
39496: LD_INT 3
39498: PUSH
39499: EMPTY
39500: LIST
39501: LIST
39502: PUSH
39503: LD_INT 4
39505: PUSH
39506: LD_INT 4
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: LD_INT 4
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: LD_INT 3
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: PUSH
39536: LD_INT 2
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 4
39545: PUSH
39546: LD_INT 2
39548: PUSH
39549: EMPTY
39550: LIST
39551: LIST
39552: PUSH
39553: LD_INT 2
39555: PUSH
39556: LD_INT 4
39558: PUSH
39559: EMPTY
39560: LIST
39561: LIST
39562: PUSH
39563: LD_INT 0
39565: PUSH
39566: LD_INT 4
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 0
39575: PUSH
39576: LD_INT 3
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 4
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 5
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 5
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 4
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 3
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 2
39637: PUSH
39638: LD_INT 5
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 3
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 3
39658: NEG
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 3
39669: NEG
39670: PUSH
39671: LD_INT 1
39673: NEG
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: NEG
39682: PUSH
39683: LD_INT 0
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 2
39692: NEG
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 3
39703: NEG
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 4
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 4
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 4
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: NEG
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 4
39760: NEG
39761: PUSH
39762: LD_INT 4
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 4
39772: NEG
39773: PUSH
39774: LD_INT 5
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 3
39784: NEG
39785: PUSH
39786: LD_INT 4
39788: NEG
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 3
39796: NEG
39797: PUSH
39798: LD_INT 3
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 4
39808: NEG
39809: PUSH
39810: LD_INT 3
39812: NEG
39813: PUSH
39814: EMPTY
39815: LIST
39816: LIST
39817: PUSH
39818: LD_INT 5
39820: NEG
39821: PUSH
39822: LD_INT 4
39824: NEG
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 5
39832: NEG
39833: PUSH
39834: LD_INT 5
39836: NEG
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 3
39844: NEG
39845: PUSH
39846: LD_INT 5
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 5
39856: NEG
39857: PUSH
39858: LD_INT 3
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: EMPTY
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: LIST
39886: LIST
39887: LIST
39888: LIST
39889: LIST
39890: LIST
39891: LIST
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
39913: LD_ADDR_VAR 0 30
39917: PUSH
39918: LD_INT 4
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 4
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 5
39940: PUSH
39941: LD_INT 4
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 5
39950: PUSH
39951: LD_INT 5
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 4
39960: PUSH
39961: LD_INT 5
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 3
39970: PUSH
39971: LD_INT 4
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: PUSH
39981: LD_INT 3
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 5
39990: PUSH
39991: LD_INT 3
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 3
40000: PUSH
40001: LD_INT 5
40003: PUSH
40004: EMPTY
40005: LIST
40006: LIST
40007: PUSH
40008: LD_INT 0
40010: PUSH
40011: LD_INT 3
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: PUSH
40018: LD_INT 0
40020: PUSH
40021: LD_INT 2
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: LD_INT 1
40030: PUSH
40031: LD_INT 3
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: LD_INT 4
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: LD_INT 4
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: LD_INT 3
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 1
40071: NEG
40072: PUSH
40073: LD_INT 2
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: LD_INT 4
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 2
40092: NEG
40093: PUSH
40094: LD_INT 2
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 4
40103: NEG
40104: PUSH
40105: LD_INT 0
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 4
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 4
40148: NEG
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 5
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 5
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 5
40182: NEG
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 3
40194: NEG
40195: PUSH
40196: LD_INT 2
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 3
40205: NEG
40206: PUSH
40207: LD_INT 3
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 3
40217: NEG
40218: PUSH
40219: LD_INT 4
40221: NEG
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: NEG
40230: PUSH
40231: LD_INT 3
40233: NEG
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: NEG
40242: PUSH
40243: LD_INT 2
40245: NEG
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 3
40253: NEG
40254: PUSH
40255: LD_INT 2
40257: NEG
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 4
40265: NEG
40266: PUSH
40267: LD_INT 3
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 4
40277: NEG
40278: PUSH
40279: LD_INT 4
40281: NEG
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 2
40289: NEG
40290: PUSH
40291: LD_INT 4
40293: NEG
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: NEG
40302: PUSH
40303: LD_INT 2
40305: NEG
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 4
40316: NEG
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: LD_INT 5
40327: NEG
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: PUSH
40333: LD_INT 1
40335: PUSH
40336: LD_INT 4
40338: NEG
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 1
40346: PUSH
40347: LD_INT 3
40349: NEG
40350: PUSH
40351: EMPTY
40352: LIST
40353: LIST
40354: PUSH
40355: LD_INT 0
40357: PUSH
40358: LD_INT 3
40360: NEG
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: NEG
40369: PUSH
40370: LD_INT 4
40372: NEG
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: LD_INT 1
40380: NEG
40381: PUSH
40382: LD_INT 5
40384: NEG
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 2
40392: PUSH
40393: LD_INT 3
40395: NEG
40396: PUSH
40397: EMPTY
40398: LIST
40399: LIST
40400: PUSH
40401: LD_INT 2
40403: NEG
40404: PUSH
40405: LD_INT 5
40407: NEG
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: LIST
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: LIST
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
40460: LD_ADDR_VAR 0 31
40464: PUSH
40465: LD_INT 0
40467: PUSH
40468: LD_INT 4
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: LD_INT 0
40477: PUSH
40478: LD_INT 3
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: PUSH
40488: LD_INT 4
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 5
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 5
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 1
40517: NEG
40518: PUSH
40519: LD_INT 4
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: LD_INT 3
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 5
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: LD_INT 2
40549: NEG
40550: PUSH
40551: LD_INT 3
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: NEG
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 3
40571: NEG
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 2
40583: NEG
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: LD_INT 2
40594: NEG
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 3
40605: NEG
40606: PUSH
40607: LD_INT 1
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 4
40616: NEG
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 4
40627: NEG
40628: PUSH
40629: LD_INT 1
40631: NEG
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 4
40639: NEG
40640: PUSH
40641: LD_INT 2
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: LD_INT 2
40651: NEG
40652: PUSH
40653: LD_INT 2
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: LD_INT 4
40662: NEG
40663: PUSH
40664: LD_INT 4
40666: NEG
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: LD_INT 4
40674: NEG
40675: PUSH
40676: LD_INT 5
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 4
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 3
40702: NEG
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: NEG
40711: PUSH
40712: LD_INT 3
40714: NEG
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 5
40722: NEG
40723: PUSH
40724: LD_INT 4
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: LD_INT 5
40734: NEG
40735: PUSH
40736: LD_INT 5
40738: NEG
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 3
40746: NEG
40747: PUSH
40748: LD_INT 5
40750: NEG
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 5
40758: NEG
40759: PUSH
40760: LD_INT 3
40762: NEG
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 0
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: EMPTY
40776: LIST
40777: LIST
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: LD_INT 4
40784: NEG
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 1
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 1
40803: PUSH
40804: LD_INT 2
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 0
40814: PUSH
40815: LD_INT 2
40817: NEG
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 1
40837: NEG
40838: PUSH
40839: LD_INT 4
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: LD_INT 2
40852: NEG
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 2
40860: NEG
40861: PUSH
40862: LD_INT 4
40864: NEG
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 4
40872: PUSH
40873: LD_INT 0
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 5
40893: PUSH
40894: LD_INT 0
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: PUSH
40904: LD_INT 1
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 4
40913: PUSH
40914: LD_INT 1
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: LD_INT 0
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: LD_INT 1
40936: NEG
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 3
40944: PUSH
40945: LD_INT 2
40947: NEG
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 5
40955: PUSH
40956: LD_INT 2
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: EMPTY
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: LIST
40979: LIST
40980: LIST
40981: LIST
40982: LIST
40983: LIST
40984: LIST
40985: LIST
40986: LIST
40987: LIST
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41010: LD_ADDR_VAR 0 32
41014: PUSH
41015: LD_INT 4
41017: NEG
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 4
41028: NEG
41029: PUSH
41030: LD_INT 1
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: NEG
41052: PUSH
41053: LD_INT 1
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 4
41062: NEG
41063: PUSH
41064: LD_INT 1
41066: PUSH
41067: EMPTY
41068: LIST
41069: LIST
41070: PUSH
41071: LD_INT 5
41073: NEG
41074: PUSH
41075: LD_INT 0
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 5
41084: NEG
41085: PUSH
41086: LD_INT 1
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 5
41096: NEG
41097: PUSH
41098: LD_INT 2
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 3
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 3
41119: NEG
41120: PUSH
41121: LD_INT 3
41123: NEG
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 3
41131: NEG
41132: PUSH
41133: LD_INT 4
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 2
41143: NEG
41144: PUSH
41145: LD_INT 3
41147: NEG
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 2
41155: NEG
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: PUSH
41165: LD_INT 3
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 4
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 4
41191: NEG
41192: PUSH
41193: LD_INT 4
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 2
41203: NEG
41204: PUSH
41205: LD_INT 4
41207: NEG
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: LD_INT 4
41215: NEG
41216: PUSH
41217: LD_INT 2
41219: NEG
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 0
41227: PUSH
41228: LD_INT 4
41230: NEG
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 0
41238: PUSH
41239: LD_INT 5
41241: NEG
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: LD_INT 4
41252: NEG
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: PUSH
41258: LD_INT 1
41260: PUSH
41261: LD_INT 3
41263: NEG
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: PUSH
41269: LD_INT 0
41271: PUSH
41272: LD_INT 3
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: LD_INT 4
41286: NEG
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: LD_INT 5
41298: NEG
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: NEG
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 5
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: PUSH
41330: LD_INT 0
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 3
41339: PUSH
41340: LD_INT 1
41342: NEG
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: LD_INT 0
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 4
41360: PUSH
41361: LD_INT 1
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 3
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 0
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 2
41390: PUSH
41391: LD_INT 1
41393: NEG
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 2
41401: PUSH
41402: LD_INT 2
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: LD_INT 4
41412: PUSH
41413: LD_INT 2
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 4
41422: PUSH
41423: LD_INT 4
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 5
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 5
41452: PUSH
41453: LD_INT 5
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 4
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 3
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 3
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: LD_INT 5
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 3
41502: PUSH
41503: LD_INT 5
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: LIST
41514: LIST
41515: LIST
41516: LIST
41517: LIST
41518: LIST
41519: LIST
41520: LIST
41521: LIST
41522: LIST
41523: LIST
41524: LIST
41525: LIST
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: LIST
41531: LIST
41532: LIST
41533: LIST
41534: LIST
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: LIST
41556: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
41557: LD_ADDR_VAR 0 33
41561: PUSH
41562: LD_INT 4
41564: NEG
41565: PUSH
41566: LD_INT 4
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 4
41576: NEG
41577: PUSH
41578: LD_INT 5
41580: NEG
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 3
41588: NEG
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 3
41600: NEG
41601: PUSH
41602: LD_INT 3
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 4
41612: NEG
41613: PUSH
41614: LD_INT 3
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: LD_INT 5
41624: NEG
41625: PUSH
41626: LD_INT 4
41628: NEG
41629: PUSH
41630: EMPTY
41631: LIST
41632: LIST
41633: PUSH
41634: LD_INT 5
41636: NEG
41637: PUSH
41638: LD_INT 5
41640: NEG
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: NEG
41649: PUSH
41650: LD_INT 5
41652: NEG
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 0
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: PUSH
41706: LD_INT 2
41708: NEG
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 0
41716: PUSH
41717: LD_INT 2
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: LD_INT 3
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: LD_INT 4
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 2
41751: PUSH
41752: LD_INT 2
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 2
41762: NEG
41763: PUSH
41764: LD_INT 4
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 4
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 4
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 5
41795: PUSH
41796: LD_INT 0
41798: PUSH
41799: EMPTY
41800: LIST
41801: LIST
41802: PUSH
41803: LD_INT 5
41805: PUSH
41806: LD_INT 1
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 4
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 3
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: LD_INT 3
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: LD_INT 2
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 5
41857: PUSH
41858: LD_INT 2
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: LD_INT 3
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: LD_INT 2
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 4
41887: PUSH
41888: LD_INT 3
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 4
41897: PUSH
41898: LD_INT 4
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 3
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: LD_INT 2
41917: PUSH
41918: LD_INT 3
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 2
41927: PUSH
41928: LD_INT 2
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: LD_INT 2
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 2
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 0
41957: PUSH
41958: LD_INT 4
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 0
41967: PUSH
41968: LD_INT 3
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: PUSH
41988: LD_INT 5
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: LD_INT 5
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 1
42007: NEG
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 3
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 2
42029: PUSH
42030: LD_INT 5
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: PUSH
42037: LD_INT 2
42039: NEG
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: EMPTY
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: LIST
42058: LIST
42059: LIST
42060: LIST
42061: LIST
42062: LIST
42063: LIST
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: LIST
42090: LIST
42091: LIST
42092: LIST
42093: LIST
42094: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42095: LD_ADDR_VAR 0 34
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 0
42113: PUSH
42114: LD_INT 5
42116: NEG
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: PUSH
42122: LD_INT 1
42124: PUSH
42125: LD_INT 4
42127: NEG
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 3
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: LD_INT 3
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 1
42157: NEG
42158: PUSH
42159: LD_INT 4
42161: NEG
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 1
42169: NEG
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 2
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 2
42192: NEG
42193: PUSH
42194: LD_INT 5
42196: NEG
42197: PUSH
42198: EMPTY
42199: LIST
42200: LIST
42201: PUSH
42202: LD_INT 3
42204: PUSH
42205: LD_INT 0
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 1
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 4
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: LD_INT 4
42235: PUSH
42236: LD_INT 1
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 3
42245: PUSH
42246: LD_INT 1
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 2
42265: PUSH
42266: LD_INT 1
42268: NEG
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 2
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 4
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 4
42297: PUSH
42298: LD_INT 4
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 4
42307: PUSH
42308: LD_INT 3
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: PUSH
42315: LD_INT 5
42317: PUSH
42318: LD_INT 4
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 5
42327: PUSH
42328: LD_INT 5
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: PUSH
42338: LD_INT 5
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: LD_INT 3
42347: PUSH
42348: LD_INT 4
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 3
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 5
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 3
42377: PUSH
42378: LD_INT 5
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: LD_INT 3
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 0
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: LD_INT 3
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 1
42417: PUSH
42418: LD_INT 4
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 0
42427: PUSH
42428: LD_INT 4
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: NEG
42438: PUSH
42439: LD_INT 3
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 1
42448: NEG
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 2
42459: PUSH
42460: LD_INT 4
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 2
42469: NEG
42470: PUSH
42471: LD_INT 2
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 4
42480: NEG
42481: PUSH
42482: LD_INT 0
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 4
42491: NEG
42492: PUSH
42493: LD_INT 1
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 3
42503: NEG
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: LD_INT 1
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: NEG
42526: PUSH
42527: LD_INT 1
42529: PUSH
42530: EMPTY
42531: LIST
42532: LIST
42533: PUSH
42534: LD_INT 5
42536: NEG
42537: PUSH
42538: LD_INT 0
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 5
42547: NEG
42548: PUSH
42549: LD_INT 1
42551: NEG
42552: PUSH
42553: EMPTY
42554: LIST
42555: LIST
42556: PUSH
42557: LD_INT 5
42559: NEG
42560: PUSH
42561: LD_INT 2
42563: NEG
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: PUSH
42569: LD_INT 3
42571: NEG
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: LIST
42588: LIST
42589: LIST
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: LIST
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: LIST
42617: LIST
42618: LIST
42619: LIST
42620: LIST
42621: LIST
42622: LIST
42623: LIST
42624: LIST
42625: LIST
42626: ST_TO_ADDR
// end ; end ;
42627: GO 42630
42629: POP
// case btype of b_depot , b_warehouse :
42630: LD_VAR 0 1
42634: PUSH
42635: LD_INT 0
42637: DOUBLE
42638: EQUAL
42639: IFTRUE 42649
42641: LD_INT 1
42643: DOUBLE
42644: EQUAL
42645: IFTRUE 42649
42647: GO 42850
42649: POP
// case nation of nation_american :
42650: LD_VAR 0 5
42654: PUSH
42655: LD_INT 1
42657: DOUBLE
42658: EQUAL
42659: IFTRUE 42663
42661: GO 42719
42663: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
42664: LD_ADDR_VAR 0 9
42668: PUSH
42669: LD_VAR 0 11
42673: PUSH
42674: LD_VAR 0 12
42678: PUSH
42679: LD_VAR 0 13
42683: PUSH
42684: LD_VAR 0 14
42688: PUSH
42689: LD_VAR 0 15
42693: PUSH
42694: LD_VAR 0 16
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: LIST
42703: LIST
42704: LIST
42705: LIST
42706: PUSH
42707: LD_VAR 0 4
42711: PUSH
42712: LD_INT 1
42714: PLUS
42715: ARRAY
42716: ST_TO_ADDR
42717: GO 42848
42719: LD_INT 2
42721: DOUBLE
42722: EQUAL
42723: IFTRUE 42727
42725: GO 42783
42727: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
42728: LD_ADDR_VAR 0 9
42732: PUSH
42733: LD_VAR 0 17
42737: PUSH
42738: LD_VAR 0 18
42742: PUSH
42743: LD_VAR 0 19
42747: PUSH
42748: LD_VAR 0 20
42752: PUSH
42753: LD_VAR 0 21
42757: PUSH
42758: LD_VAR 0 22
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: PUSH
42771: LD_VAR 0 4
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: ARRAY
42780: ST_TO_ADDR
42781: GO 42848
42783: LD_INT 3
42785: DOUBLE
42786: EQUAL
42787: IFTRUE 42791
42789: GO 42847
42791: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
42792: LD_ADDR_VAR 0 9
42796: PUSH
42797: LD_VAR 0 23
42801: PUSH
42802: LD_VAR 0 24
42806: PUSH
42807: LD_VAR 0 25
42811: PUSH
42812: LD_VAR 0 26
42816: PUSH
42817: LD_VAR 0 27
42821: PUSH
42822: LD_VAR 0 28
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: PUSH
42835: LD_VAR 0 4
42839: PUSH
42840: LD_INT 1
42842: PLUS
42843: ARRAY
42844: ST_TO_ADDR
42845: GO 42848
42847: POP
42848: GO 43403
42850: LD_INT 2
42852: DOUBLE
42853: EQUAL
42854: IFTRUE 42864
42856: LD_INT 3
42858: DOUBLE
42859: EQUAL
42860: IFTRUE 42864
42862: GO 42920
42864: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
42865: LD_ADDR_VAR 0 9
42869: PUSH
42870: LD_VAR 0 29
42874: PUSH
42875: LD_VAR 0 30
42879: PUSH
42880: LD_VAR 0 31
42884: PUSH
42885: LD_VAR 0 32
42889: PUSH
42890: LD_VAR 0 33
42894: PUSH
42895: LD_VAR 0 34
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: LIST
42906: LIST
42907: PUSH
42908: LD_VAR 0 4
42912: PUSH
42913: LD_INT 1
42915: PLUS
42916: ARRAY
42917: ST_TO_ADDR
42918: GO 43403
42920: LD_INT 16
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42982
42926: LD_INT 17
42928: DOUBLE
42929: EQUAL
42930: IFTRUE 42982
42932: LD_INT 18
42934: DOUBLE
42935: EQUAL
42936: IFTRUE 42982
42938: LD_INT 19
42940: DOUBLE
42941: EQUAL
42942: IFTRUE 42982
42944: LD_INT 22
42946: DOUBLE
42947: EQUAL
42948: IFTRUE 42982
42950: LD_INT 20
42952: DOUBLE
42953: EQUAL
42954: IFTRUE 42982
42956: LD_INT 21
42958: DOUBLE
42959: EQUAL
42960: IFTRUE 42982
42962: LD_INT 23
42964: DOUBLE
42965: EQUAL
42966: IFTRUE 42982
42968: LD_INT 24
42970: DOUBLE
42971: EQUAL
42972: IFTRUE 42982
42974: LD_INT 25
42976: DOUBLE
42977: EQUAL
42978: IFTRUE 42982
42980: GO 43038
42982: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
42983: LD_ADDR_VAR 0 9
42987: PUSH
42988: LD_VAR 0 35
42992: PUSH
42993: LD_VAR 0 36
42997: PUSH
42998: LD_VAR 0 37
43002: PUSH
43003: LD_VAR 0 38
43007: PUSH
43008: LD_VAR 0 39
43012: PUSH
43013: LD_VAR 0 40
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: LIST
43025: PUSH
43026: LD_VAR 0 4
43030: PUSH
43031: LD_INT 1
43033: PLUS
43034: ARRAY
43035: ST_TO_ADDR
43036: GO 43403
43038: LD_INT 6
43040: DOUBLE
43041: EQUAL
43042: IFTRUE 43094
43044: LD_INT 7
43046: DOUBLE
43047: EQUAL
43048: IFTRUE 43094
43050: LD_INT 8
43052: DOUBLE
43053: EQUAL
43054: IFTRUE 43094
43056: LD_INT 13
43058: DOUBLE
43059: EQUAL
43060: IFTRUE 43094
43062: LD_INT 12
43064: DOUBLE
43065: EQUAL
43066: IFTRUE 43094
43068: LD_INT 15
43070: DOUBLE
43071: EQUAL
43072: IFTRUE 43094
43074: LD_INT 11
43076: DOUBLE
43077: EQUAL
43078: IFTRUE 43094
43080: LD_INT 14
43082: DOUBLE
43083: EQUAL
43084: IFTRUE 43094
43086: LD_INT 10
43088: DOUBLE
43089: EQUAL
43090: IFTRUE 43094
43092: GO 43150
43094: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43095: LD_ADDR_VAR 0 9
43099: PUSH
43100: LD_VAR 0 41
43104: PUSH
43105: LD_VAR 0 42
43109: PUSH
43110: LD_VAR 0 43
43114: PUSH
43115: LD_VAR 0 44
43119: PUSH
43120: LD_VAR 0 45
43124: PUSH
43125: LD_VAR 0 46
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: LIST
43134: LIST
43135: LIST
43136: LIST
43137: PUSH
43138: LD_VAR 0 4
43142: PUSH
43143: LD_INT 1
43145: PLUS
43146: ARRAY
43147: ST_TO_ADDR
43148: GO 43403
43150: LD_INT 36
43152: DOUBLE
43153: EQUAL
43154: IFTRUE 43158
43156: GO 43214
43158: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43159: LD_ADDR_VAR 0 9
43163: PUSH
43164: LD_VAR 0 47
43168: PUSH
43169: LD_VAR 0 48
43173: PUSH
43174: LD_VAR 0 49
43178: PUSH
43179: LD_VAR 0 50
43183: PUSH
43184: LD_VAR 0 51
43188: PUSH
43189: LD_VAR 0 52
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: LIST
43199: LIST
43200: LIST
43201: PUSH
43202: LD_VAR 0 4
43206: PUSH
43207: LD_INT 1
43209: PLUS
43210: ARRAY
43211: ST_TO_ADDR
43212: GO 43403
43214: LD_INT 4
43216: DOUBLE
43217: EQUAL
43218: IFTRUE 43240
43220: LD_INT 5
43222: DOUBLE
43223: EQUAL
43224: IFTRUE 43240
43226: LD_INT 34
43228: DOUBLE
43229: EQUAL
43230: IFTRUE 43240
43232: LD_INT 37
43234: DOUBLE
43235: EQUAL
43236: IFTRUE 43240
43238: GO 43296
43240: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
43241: LD_ADDR_VAR 0 9
43245: PUSH
43246: LD_VAR 0 53
43250: PUSH
43251: LD_VAR 0 54
43255: PUSH
43256: LD_VAR 0 55
43260: PUSH
43261: LD_VAR 0 56
43265: PUSH
43266: LD_VAR 0 57
43270: PUSH
43271: LD_VAR 0 58
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: PUSH
43284: LD_VAR 0 4
43288: PUSH
43289: LD_INT 1
43291: PLUS
43292: ARRAY
43293: ST_TO_ADDR
43294: GO 43403
43296: LD_INT 31
43298: DOUBLE
43299: EQUAL
43300: IFTRUE 43346
43302: LD_INT 32
43304: DOUBLE
43305: EQUAL
43306: IFTRUE 43346
43308: LD_INT 33
43310: DOUBLE
43311: EQUAL
43312: IFTRUE 43346
43314: LD_INT 27
43316: DOUBLE
43317: EQUAL
43318: IFTRUE 43346
43320: LD_INT 26
43322: DOUBLE
43323: EQUAL
43324: IFTRUE 43346
43326: LD_INT 28
43328: DOUBLE
43329: EQUAL
43330: IFTRUE 43346
43332: LD_INT 29
43334: DOUBLE
43335: EQUAL
43336: IFTRUE 43346
43338: LD_INT 30
43340: DOUBLE
43341: EQUAL
43342: IFTRUE 43346
43344: GO 43402
43346: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
43347: LD_ADDR_VAR 0 9
43351: PUSH
43352: LD_VAR 0 59
43356: PUSH
43357: LD_VAR 0 60
43361: PUSH
43362: LD_VAR 0 61
43366: PUSH
43367: LD_VAR 0 62
43371: PUSH
43372: LD_VAR 0 63
43376: PUSH
43377: LD_VAR 0 64
43381: PUSH
43382: EMPTY
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: PUSH
43390: LD_VAR 0 4
43394: PUSH
43395: LD_INT 1
43397: PLUS
43398: ARRAY
43399: ST_TO_ADDR
43400: GO 43403
43402: POP
// temp_list2 = [ ] ;
43403: LD_ADDR_VAR 0 10
43407: PUSH
43408: EMPTY
43409: ST_TO_ADDR
// for i in temp_list do
43410: LD_ADDR_VAR 0 8
43414: PUSH
43415: LD_VAR 0 9
43419: PUSH
43420: FOR_IN
43421: IFFALSE 43473
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
43423: LD_ADDR_VAR 0 10
43427: PUSH
43428: LD_VAR 0 10
43432: PUSH
43433: LD_VAR 0 8
43437: PUSH
43438: LD_INT 1
43440: ARRAY
43441: PUSH
43442: LD_VAR 0 2
43446: PLUS
43447: PUSH
43448: LD_VAR 0 8
43452: PUSH
43453: LD_INT 2
43455: ARRAY
43456: PUSH
43457: LD_VAR 0 3
43461: PLUS
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: EMPTY
43468: LIST
43469: ADD
43470: ST_TO_ADDR
43471: GO 43420
43473: POP
43474: POP
// result = temp_list2 ;
43475: LD_ADDR_VAR 0 7
43479: PUSH
43480: LD_VAR 0 10
43484: ST_TO_ADDR
// end ;
43485: LD_VAR 0 7
43489: RET
// export function EnemyInRange ( unit , dist ) ; begin
43490: LD_INT 0
43492: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
43493: LD_ADDR_VAR 0 3
43497: PUSH
43498: LD_VAR 0 1
43502: PPUSH
43503: CALL_OW 255
43507: PPUSH
43508: LD_VAR 0 1
43512: PPUSH
43513: CALL_OW 250
43517: PPUSH
43518: LD_VAR 0 1
43522: PPUSH
43523: CALL_OW 251
43527: PPUSH
43528: LD_VAR 0 2
43532: PPUSH
43533: CALL 16886 0 4
43537: PUSH
43538: LD_INT 4
43540: ARRAY
43541: ST_TO_ADDR
// end ;
43542: LD_VAR 0 3
43546: RET
// export function PlayerSeeMe ( unit ) ; begin
43547: LD_INT 0
43549: PPUSH
// result := See ( your_side , unit ) ;
43550: LD_ADDR_VAR 0 2
43554: PUSH
43555: LD_OWVAR 2
43559: PPUSH
43560: LD_VAR 0 1
43564: PPUSH
43565: CALL_OW 292
43569: ST_TO_ADDR
// end ;
43570: LD_VAR 0 2
43574: RET
// export function ReverseDir ( unit ) ; begin
43575: LD_INT 0
43577: PPUSH
// if not unit then
43578: LD_VAR 0 1
43582: NOT
43583: IFFALSE 43587
// exit ;
43585: GO 43610
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
43587: LD_ADDR_VAR 0 2
43591: PUSH
43592: LD_VAR 0 1
43596: PPUSH
43597: CALL_OW 254
43601: PUSH
43602: LD_INT 3
43604: PLUS
43605: PUSH
43606: LD_INT 6
43608: MOD
43609: ST_TO_ADDR
// end ;
43610: LD_VAR 0 2
43614: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
43615: LD_INT 0
43617: PPUSH
43618: PPUSH
43619: PPUSH
43620: PPUSH
43621: PPUSH
// if not hexes then
43622: LD_VAR 0 2
43626: NOT
43627: IFFALSE 43631
// exit ;
43629: GO 43779
// dist := 9999 ;
43631: LD_ADDR_VAR 0 5
43635: PUSH
43636: LD_INT 9999
43638: ST_TO_ADDR
// for i = 1 to hexes do
43639: LD_ADDR_VAR 0 4
43643: PUSH
43644: DOUBLE
43645: LD_INT 1
43647: DEC
43648: ST_TO_ADDR
43649: LD_VAR 0 2
43653: PUSH
43654: FOR_TO
43655: IFFALSE 43767
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
43657: LD_VAR 0 1
43661: PPUSH
43662: LD_VAR 0 2
43666: PUSH
43667: LD_VAR 0 4
43671: ARRAY
43672: PUSH
43673: LD_INT 1
43675: ARRAY
43676: PPUSH
43677: LD_VAR 0 2
43681: PUSH
43682: LD_VAR 0 4
43686: ARRAY
43687: PUSH
43688: LD_INT 2
43690: ARRAY
43691: PPUSH
43692: CALL_OW 297
43696: PUSH
43697: LD_VAR 0 5
43701: LESS
43702: IFFALSE 43765
// begin hex := hexes [ i ] ;
43704: LD_ADDR_VAR 0 7
43708: PUSH
43709: LD_VAR 0 2
43713: PUSH
43714: LD_VAR 0 4
43718: ARRAY
43719: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
43720: LD_ADDR_VAR 0 5
43724: PUSH
43725: LD_VAR 0 1
43729: PPUSH
43730: LD_VAR 0 2
43734: PUSH
43735: LD_VAR 0 4
43739: ARRAY
43740: PUSH
43741: LD_INT 1
43743: ARRAY
43744: PPUSH
43745: LD_VAR 0 2
43749: PUSH
43750: LD_VAR 0 4
43754: ARRAY
43755: PUSH
43756: LD_INT 2
43758: ARRAY
43759: PPUSH
43760: CALL_OW 297
43764: ST_TO_ADDR
// end ; end ;
43765: GO 43654
43767: POP
43768: POP
// result := hex ;
43769: LD_ADDR_VAR 0 3
43773: PUSH
43774: LD_VAR 0 7
43778: ST_TO_ADDR
// end ;
43779: LD_VAR 0 3
43783: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
43784: LD_INT 0
43786: PPUSH
43787: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
43788: LD_VAR 0 1
43792: NOT
43793: PUSH
43794: LD_VAR 0 1
43798: PUSH
43799: LD_INT 21
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 23
43811: PUSH
43812: LD_INT 2
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PPUSH
43823: CALL_OW 69
43827: IN
43828: NOT
43829: OR
43830: IFFALSE 43834
// exit ;
43832: GO 43881
// for i = 1 to 3 do
43834: LD_ADDR_VAR 0 3
43838: PUSH
43839: DOUBLE
43840: LD_INT 1
43842: DEC
43843: ST_TO_ADDR
43844: LD_INT 3
43846: PUSH
43847: FOR_TO
43848: IFFALSE 43879
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
43850: LD_VAR 0 1
43854: PPUSH
43855: CALL_OW 250
43859: PPUSH
43860: LD_VAR 0 1
43864: PPUSH
43865: CALL_OW 251
43869: PPUSH
43870: LD_INT 1
43872: PPUSH
43873: CALL_OW 453
43877: GO 43847
43879: POP
43880: POP
// end ;
43881: LD_VAR 0 2
43885: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
43886: LD_INT 0
43888: PPUSH
43889: PPUSH
43890: PPUSH
43891: PPUSH
43892: PPUSH
43893: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
43894: LD_VAR 0 1
43898: NOT
43899: PUSH
43900: LD_VAR 0 2
43904: NOT
43905: OR
43906: PUSH
43907: LD_VAR 0 1
43911: PPUSH
43912: CALL_OW 314
43916: OR
43917: IFFALSE 43921
// exit ;
43919: GO 44362
// x := GetX ( enemy_unit ) ;
43921: LD_ADDR_VAR 0 7
43925: PUSH
43926: LD_VAR 0 2
43930: PPUSH
43931: CALL_OW 250
43935: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
43936: LD_ADDR_VAR 0 8
43940: PUSH
43941: LD_VAR 0 2
43945: PPUSH
43946: CALL_OW 251
43950: ST_TO_ADDR
// if not x or not y then
43951: LD_VAR 0 7
43955: NOT
43956: PUSH
43957: LD_VAR 0 8
43961: NOT
43962: OR
43963: IFFALSE 43967
// exit ;
43965: GO 44362
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
43967: LD_ADDR_VAR 0 6
43971: PUSH
43972: LD_VAR 0 7
43976: PPUSH
43977: LD_INT 0
43979: PPUSH
43980: LD_INT 4
43982: PPUSH
43983: CALL_OW 272
43987: PUSH
43988: LD_VAR 0 8
43992: PPUSH
43993: LD_INT 0
43995: PPUSH
43996: LD_INT 4
43998: PPUSH
43999: CALL_OW 273
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_VAR 0 7
44012: PPUSH
44013: LD_INT 1
44015: PPUSH
44016: LD_INT 4
44018: PPUSH
44019: CALL_OW 272
44023: PUSH
44024: LD_VAR 0 8
44028: PPUSH
44029: LD_INT 1
44031: PPUSH
44032: LD_INT 4
44034: PPUSH
44035: CALL_OW 273
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_VAR 0 7
44048: PPUSH
44049: LD_INT 2
44051: PPUSH
44052: LD_INT 4
44054: PPUSH
44055: CALL_OW 272
44059: PUSH
44060: LD_VAR 0 8
44064: PPUSH
44065: LD_INT 2
44067: PPUSH
44068: LD_INT 4
44070: PPUSH
44071: CALL_OW 273
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_VAR 0 7
44084: PPUSH
44085: LD_INT 3
44087: PPUSH
44088: LD_INT 4
44090: PPUSH
44091: CALL_OW 272
44095: PUSH
44096: LD_VAR 0 8
44100: PPUSH
44101: LD_INT 3
44103: PPUSH
44104: LD_INT 4
44106: PPUSH
44107: CALL_OW 273
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: LD_VAR 0 7
44120: PPUSH
44121: LD_INT 4
44123: PPUSH
44124: LD_INT 4
44126: PPUSH
44127: CALL_OW 272
44131: PUSH
44132: LD_VAR 0 8
44136: PPUSH
44137: LD_INT 4
44139: PPUSH
44140: LD_INT 4
44142: PPUSH
44143: CALL_OW 273
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_VAR 0 7
44156: PPUSH
44157: LD_INT 5
44159: PPUSH
44160: LD_INT 4
44162: PPUSH
44163: CALL_OW 272
44167: PUSH
44168: LD_VAR 0 8
44172: PPUSH
44173: LD_INT 5
44175: PPUSH
44176: LD_INT 4
44178: PPUSH
44179: CALL_OW 273
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: LIST
44192: LIST
44193: LIST
44194: LIST
44195: ST_TO_ADDR
// for i = tmp downto 1 do
44196: LD_ADDR_VAR 0 4
44200: PUSH
44201: DOUBLE
44202: LD_VAR 0 6
44206: INC
44207: ST_TO_ADDR
44208: LD_INT 1
44210: PUSH
44211: FOR_DOWNTO
44212: IFFALSE 44313
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
44214: LD_VAR 0 6
44218: PUSH
44219: LD_VAR 0 4
44223: ARRAY
44224: PUSH
44225: LD_INT 1
44227: ARRAY
44228: PPUSH
44229: LD_VAR 0 6
44233: PUSH
44234: LD_VAR 0 4
44238: ARRAY
44239: PUSH
44240: LD_INT 2
44242: ARRAY
44243: PPUSH
44244: CALL_OW 488
44248: NOT
44249: PUSH
44250: LD_VAR 0 6
44254: PUSH
44255: LD_VAR 0 4
44259: ARRAY
44260: PUSH
44261: LD_INT 1
44263: ARRAY
44264: PPUSH
44265: LD_VAR 0 6
44269: PUSH
44270: LD_VAR 0 4
44274: ARRAY
44275: PUSH
44276: LD_INT 2
44278: ARRAY
44279: PPUSH
44280: CALL_OW 428
44284: PUSH
44285: LD_INT 0
44287: NONEQUAL
44288: OR
44289: IFFALSE 44311
// tmp := Delete ( tmp , i ) ;
44291: LD_ADDR_VAR 0 6
44295: PUSH
44296: LD_VAR 0 6
44300: PPUSH
44301: LD_VAR 0 4
44305: PPUSH
44306: CALL_OW 3
44310: ST_TO_ADDR
44311: GO 44211
44313: POP
44314: POP
// j := GetClosestHex ( unit , tmp ) ;
44315: LD_ADDR_VAR 0 5
44319: PUSH
44320: LD_VAR 0 1
44324: PPUSH
44325: LD_VAR 0 6
44329: PPUSH
44330: CALL 43615 0 2
44334: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
44335: LD_VAR 0 1
44339: PPUSH
44340: LD_VAR 0 5
44344: PUSH
44345: LD_INT 1
44347: ARRAY
44348: PPUSH
44349: LD_VAR 0 5
44353: PUSH
44354: LD_INT 2
44356: ARRAY
44357: PPUSH
44358: CALL_OW 111
// end ;
44362: LD_VAR 0 3
44366: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
44367: LD_INT 0
44369: PPUSH
44370: PPUSH
44371: PPUSH
// uc_side = 0 ;
44372: LD_ADDR_OWVAR 20
44376: PUSH
44377: LD_INT 0
44379: ST_TO_ADDR
// uc_nation = 0 ;
44380: LD_ADDR_OWVAR 21
44384: PUSH
44385: LD_INT 0
44387: ST_TO_ADDR
// InitHc_All ( ) ;
44388: CALL_OW 584
// InitVc ;
44392: CALL_OW 20
// if mastodonts then
44396: LD_VAR 0 6
44400: IFFALSE 44467
// for i = 1 to mastodonts do
44402: LD_ADDR_VAR 0 11
44406: PUSH
44407: DOUBLE
44408: LD_INT 1
44410: DEC
44411: ST_TO_ADDR
44412: LD_VAR 0 6
44416: PUSH
44417: FOR_TO
44418: IFFALSE 44465
// begin vc_chassis := 31 ;
44420: LD_ADDR_OWVAR 37
44424: PUSH
44425: LD_INT 31
44427: ST_TO_ADDR
// vc_control := control_rider ;
44428: LD_ADDR_OWVAR 38
44432: PUSH
44433: LD_INT 4
44435: ST_TO_ADDR
// animal := CreateVehicle ;
44436: LD_ADDR_VAR 0 12
44440: PUSH
44441: CALL_OW 45
44445: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44446: LD_VAR 0 12
44450: PPUSH
44451: LD_VAR 0 8
44455: PPUSH
44456: LD_INT 0
44458: PPUSH
44459: CALL 46655 0 3
// end ;
44463: GO 44417
44465: POP
44466: POP
// if horses then
44467: LD_VAR 0 5
44471: IFFALSE 44538
// for i = 1 to horses do
44473: LD_ADDR_VAR 0 11
44477: PUSH
44478: DOUBLE
44479: LD_INT 1
44481: DEC
44482: ST_TO_ADDR
44483: LD_VAR 0 5
44487: PUSH
44488: FOR_TO
44489: IFFALSE 44536
// begin hc_class := 21 ;
44491: LD_ADDR_OWVAR 28
44495: PUSH
44496: LD_INT 21
44498: ST_TO_ADDR
// hc_gallery :=  ;
44499: LD_ADDR_OWVAR 33
44503: PUSH
44504: LD_STRING 
44506: ST_TO_ADDR
// animal := CreateHuman ;
44507: LD_ADDR_VAR 0 12
44511: PUSH
44512: CALL_OW 44
44516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44517: LD_VAR 0 12
44521: PPUSH
44522: LD_VAR 0 8
44526: PPUSH
44527: LD_INT 0
44529: PPUSH
44530: CALL 46655 0 3
// end ;
44534: GO 44488
44536: POP
44537: POP
// if birds then
44538: LD_VAR 0 1
44542: IFFALSE 44609
// for i = 1 to birds do
44544: LD_ADDR_VAR 0 11
44548: PUSH
44549: DOUBLE
44550: LD_INT 1
44552: DEC
44553: ST_TO_ADDR
44554: LD_VAR 0 1
44558: PUSH
44559: FOR_TO
44560: IFFALSE 44607
// begin hc_class = 18 ;
44562: LD_ADDR_OWVAR 28
44566: PUSH
44567: LD_INT 18
44569: ST_TO_ADDR
// hc_gallery =  ;
44570: LD_ADDR_OWVAR 33
44574: PUSH
44575: LD_STRING 
44577: ST_TO_ADDR
// animal := CreateHuman ;
44578: LD_ADDR_VAR 0 12
44582: PUSH
44583: CALL_OW 44
44587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44588: LD_VAR 0 12
44592: PPUSH
44593: LD_VAR 0 8
44597: PPUSH
44598: LD_INT 0
44600: PPUSH
44601: CALL 46655 0 3
// end ;
44605: GO 44559
44607: POP
44608: POP
// if tigers then
44609: LD_VAR 0 2
44613: IFFALSE 44697
// for i = 1 to tigers do
44615: LD_ADDR_VAR 0 11
44619: PUSH
44620: DOUBLE
44621: LD_INT 1
44623: DEC
44624: ST_TO_ADDR
44625: LD_VAR 0 2
44629: PUSH
44630: FOR_TO
44631: IFFALSE 44695
// begin hc_class = class_tiger ;
44633: LD_ADDR_OWVAR 28
44637: PUSH
44638: LD_INT 14
44640: ST_TO_ADDR
// hc_gallery =  ;
44641: LD_ADDR_OWVAR 33
44645: PUSH
44646: LD_STRING 
44648: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
44649: LD_ADDR_OWVAR 35
44653: PUSH
44654: LD_INT 7
44656: NEG
44657: PPUSH
44658: LD_INT 7
44660: PPUSH
44661: CALL_OW 12
44665: ST_TO_ADDR
// animal := CreateHuman ;
44666: LD_ADDR_VAR 0 12
44670: PUSH
44671: CALL_OW 44
44675: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44676: LD_VAR 0 12
44680: PPUSH
44681: LD_VAR 0 8
44685: PPUSH
44686: LD_INT 0
44688: PPUSH
44689: CALL 46655 0 3
// end ;
44693: GO 44630
44695: POP
44696: POP
// if apemans then
44697: LD_VAR 0 3
44701: IFFALSE 44824
// for i = 1 to apemans do
44703: LD_ADDR_VAR 0 11
44707: PUSH
44708: DOUBLE
44709: LD_INT 1
44711: DEC
44712: ST_TO_ADDR
44713: LD_VAR 0 3
44717: PUSH
44718: FOR_TO
44719: IFFALSE 44822
// begin hc_class = class_apeman ;
44721: LD_ADDR_OWVAR 28
44725: PUSH
44726: LD_INT 12
44728: ST_TO_ADDR
// hc_gallery =  ;
44729: LD_ADDR_OWVAR 33
44733: PUSH
44734: LD_STRING 
44736: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
44737: LD_ADDR_OWVAR 35
44741: PUSH
44742: LD_INT 2
44744: NEG
44745: PPUSH
44746: LD_INT 2
44748: PPUSH
44749: CALL_OW 12
44753: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
44754: LD_ADDR_OWVAR 31
44758: PUSH
44759: LD_INT 1
44761: PPUSH
44762: LD_INT 3
44764: PPUSH
44765: CALL_OW 12
44769: PUSH
44770: LD_INT 1
44772: PPUSH
44773: LD_INT 3
44775: PPUSH
44776: CALL_OW 12
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 0
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: ST_TO_ADDR
// animal := CreateHuman ;
44793: LD_ADDR_VAR 0 12
44797: PUSH
44798: CALL_OW 44
44802: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44803: LD_VAR 0 12
44807: PPUSH
44808: LD_VAR 0 8
44812: PPUSH
44813: LD_INT 0
44815: PPUSH
44816: CALL 46655 0 3
// end ;
44820: GO 44718
44822: POP
44823: POP
// if enchidnas then
44824: LD_VAR 0 4
44828: IFFALSE 44895
// for i = 1 to enchidnas do
44830: LD_ADDR_VAR 0 11
44834: PUSH
44835: DOUBLE
44836: LD_INT 1
44838: DEC
44839: ST_TO_ADDR
44840: LD_VAR 0 4
44844: PUSH
44845: FOR_TO
44846: IFFALSE 44893
// begin hc_class = 13 ;
44848: LD_ADDR_OWVAR 28
44852: PUSH
44853: LD_INT 13
44855: ST_TO_ADDR
// hc_gallery =  ;
44856: LD_ADDR_OWVAR 33
44860: PUSH
44861: LD_STRING 
44863: ST_TO_ADDR
// animal := CreateHuman ;
44864: LD_ADDR_VAR 0 12
44868: PUSH
44869: CALL_OW 44
44873: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
44874: LD_VAR 0 12
44878: PPUSH
44879: LD_VAR 0 8
44883: PPUSH
44884: LD_INT 0
44886: PPUSH
44887: CALL 46655 0 3
// end ;
44891: GO 44845
44893: POP
44894: POP
// if fishes then
44895: LD_VAR 0 7
44899: IFFALSE 44966
// for i = 1 to fishes do
44901: LD_ADDR_VAR 0 11
44905: PUSH
44906: DOUBLE
44907: LD_INT 1
44909: DEC
44910: ST_TO_ADDR
44911: LD_VAR 0 7
44915: PUSH
44916: FOR_TO
44917: IFFALSE 44964
// begin hc_class = 20 ;
44919: LD_ADDR_OWVAR 28
44923: PUSH
44924: LD_INT 20
44926: ST_TO_ADDR
// hc_gallery =  ;
44927: LD_ADDR_OWVAR 33
44931: PUSH
44932: LD_STRING 
44934: ST_TO_ADDR
// animal := CreateHuman ;
44935: LD_ADDR_VAR 0 12
44939: PUSH
44940: CALL_OW 44
44944: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
44945: LD_VAR 0 12
44949: PPUSH
44950: LD_VAR 0 9
44954: PPUSH
44955: LD_INT 0
44957: PPUSH
44958: CALL 46655 0 3
// end ;
44962: GO 44916
44964: POP
44965: POP
// end ;
44966: LD_VAR 0 10
44970: RET
// export function WantHeal ( sci , unit ) ; begin
44971: LD_INT 0
44973: PPUSH
// if GetTaskList ( sci ) > 0 then
44974: LD_VAR 0 1
44978: PPUSH
44979: CALL_OW 437
44983: PUSH
44984: LD_INT 0
44986: GREATER
44987: IFFALSE 45057
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
44989: LD_VAR 0 1
44993: PPUSH
44994: CALL_OW 437
44998: PUSH
44999: LD_INT 1
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: PUSH
45007: LD_STRING l
45009: EQUAL
45010: PUSH
45011: LD_VAR 0 1
45015: PPUSH
45016: CALL_OW 437
45020: PUSH
45021: LD_INT 1
45023: ARRAY
45024: PUSH
45025: LD_INT 4
45027: ARRAY
45028: PUSH
45029: LD_VAR 0 2
45033: EQUAL
45034: AND
45035: IFFALSE 45047
// result := true else
45037: LD_ADDR_VAR 0 3
45041: PUSH
45042: LD_INT 1
45044: ST_TO_ADDR
45045: GO 45055
// result := false ;
45047: LD_ADDR_VAR 0 3
45051: PUSH
45052: LD_INT 0
45054: ST_TO_ADDR
// end else
45055: GO 45065
// result := false ;
45057: LD_ADDR_VAR 0 3
45061: PUSH
45062: LD_INT 0
45064: ST_TO_ADDR
// end ;
45065: LD_VAR 0 3
45069: RET
// export function HealTarget ( sci ) ; begin
45070: LD_INT 0
45072: PPUSH
// if not sci then
45073: LD_VAR 0 1
45077: NOT
45078: IFFALSE 45082
// exit ;
45080: GO 45147
// result := 0 ;
45082: LD_ADDR_VAR 0 2
45086: PUSH
45087: LD_INT 0
45089: ST_TO_ADDR
// if GetTaskList ( sci ) then
45090: LD_VAR 0 1
45094: PPUSH
45095: CALL_OW 437
45099: IFFALSE 45147
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
45101: LD_VAR 0 1
45105: PPUSH
45106: CALL_OW 437
45110: PUSH
45111: LD_INT 1
45113: ARRAY
45114: PUSH
45115: LD_INT 1
45117: ARRAY
45118: PUSH
45119: LD_STRING l
45121: EQUAL
45122: IFFALSE 45147
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
45124: LD_ADDR_VAR 0 2
45128: PUSH
45129: LD_VAR 0 1
45133: PPUSH
45134: CALL_OW 437
45138: PUSH
45139: LD_INT 1
45141: ARRAY
45142: PUSH
45143: LD_INT 4
45145: ARRAY
45146: ST_TO_ADDR
// end ;
45147: LD_VAR 0 2
45151: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
45152: LD_INT 0
45154: PPUSH
45155: PPUSH
45156: PPUSH
45157: PPUSH
// if not base_units then
45158: LD_VAR 0 1
45162: NOT
45163: IFFALSE 45167
// exit ;
45165: GO 45254
// result := false ;
45167: LD_ADDR_VAR 0 2
45171: PUSH
45172: LD_INT 0
45174: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
45175: LD_ADDR_VAR 0 5
45179: PUSH
45180: LD_VAR 0 1
45184: PPUSH
45185: LD_INT 21
45187: PUSH
45188: LD_INT 3
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PPUSH
45195: CALL_OW 72
45199: ST_TO_ADDR
// if not tmp then
45200: LD_VAR 0 5
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45254
// for i in tmp do
45209: LD_ADDR_VAR 0 3
45213: PUSH
45214: LD_VAR 0 5
45218: PUSH
45219: FOR_IN
45220: IFFALSE 45252
// begin result := EnemyInRange ( i , 22 ) ;
45222: LD_ADDR_VAR 0 2
45226: PUSH
45227: LD_VAR 0 3
45231: PPUSH
45232: LD_INT 22
45234: PPUSH
45235: CALL 43490 0 2
45239: ST_TO_ADDR
// if result then
45240: LD_VAR 0 2
45244: IFFALSE 45250
// exit ;
45246: POP
45247: POP
45248: GO 45254
// end ;
45250: GO 45219
45252: POP
45253: POP
// end ;
45254: LD_VAR 0 2
45258: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
45259: LD_INT 0
45261: PPUSH
45262: PPUSH
// if not units then
45263: LD_VAR 0 1
45267: NOT
45268: IFFALSE 45272
// exit ;
45270: GO 45342
// result := [ ] ;
45272: LD_ADDR_VAR 0 3
45276: PUSH
45277: EMPTY
45278: ST_TO_ADDR
// for i in units do
45279: LD_ADDR_VAR 0 4
45283: PUSH
45284: LD_VAR 0 1
45288: PUSH
45289: FOR_IN
45290: IFFALSE 45340
// if GetTag ( i ) = tag then
45292: LD_VAR 0 4
45296: PPUSH
45297: CALL_OW 110
45301: PUSH
45302: LD_VAR 0 2
45306: EQUAL
45307: IFFALSE 45338
// result := Replace ( result , result + 1 , i ) ;
45309: LD_ADDR_VAR 0 3
45313: PUSH
45314: LD_VAR 0 3
45318: PPUSH
45319: LD_VAR 0 3
45323: PUSH
45324: LD_INT 1
45326: PLUS
45327: PPUSH
45328: LD_VAR 0 4
45332: PPUSH
45333: CALL_OW 1
45337: ST_TO_ADDR
45338: GO 45289
45340: POP
45341: POP
// end ;
45342: LD_VAR 0 3
45346: RET
// export function IsDriver ( un ) ; begin
45347: LD_INT 0
45349: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
45350: LD_ADDR_VAR 0 2
45354: PUSH
45355: LD_VAR 0 1
45359: PUSH
45360: LD_INT 55
45362: PUSH
45363: EMPTY
45364: LIST
45365: PPUSH
45366: CALL_OW 69
45370: IN
45371: ST_TO_ADDR
// end ;
45372: LD_VAR 0 2
45376: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
45377: LD_INT 0
45379: PPUSH
45380: PPUSH
// list := [ ] ;
45381: LD_ADDR_VAR 0 5
45385: PUSH
45386: EMPTY
45387: ST_TO_ADDR
// case d of 0 :
45388: LD_VAR 0 3
45392: PUSH
45393: LD_INT 0
45395: DOUBLE
45396: EQUAL
45397: IFTRUE 45401
45399: GO 45534
45401: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
45402: LD_ADDR_VAR 0 5
45406: PUSH
45407: LD_VAR 0 1
45411: PUSH
45412: LD_INT 4
45414: MINUS
45415: PUSH
45416: LD_VAR 0 2
45420: PUSH
45421: LD_INT 4
45423: MINUS
45424: PUSH
45425: LD_INT 2
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: LIST
45432: PUSH
45433: LD_VAR 0 1
45437: PUSH
45438: LD_INT 3
45440: MINUS
45441: PUSH
45442: LD_VAR 0 2
45446: PUSH
45447: LD_INT 1
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: LIST
45454: PUSH
45455: LD_VAR 0 1
45459: PUSH
45460: LD_INT 4
45462: PLUS
45463: PUSH
45464: LD_VAR 0 2
45468: PUSH
45469: LD_INT 4
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: LIST
45476: PUSH
45477: LD_VAR 0 1
45481: PUSH
45482: LD_INT 3
45484: PLUS
45485: PUSH
45486: LD_VAR 0 2
45490: PUSH
45491: LD_INT 3
45493: PLUS
45494: PUSH
45495: LD_INT 5
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: LIST
45502: PUSH
45503: LD_VAR 0 1
45507: PUSH
45508: LD_VAR 0 2
45512: PUSH
45513: LD_INT 4
45515: PLUS
45516: PUSH
45517: LD_INT 0
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: ST_TO_ADDR
// end ; 1 :
45532: GO 46232
45534: LD_INT 1
45536: DOUBLE
45537: EQUAL
45538: IFTRUE 45542
45540: GO 45675
45542: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
45543: LD_ADDR_VAR 0 5
45547: PUSH
45548: LD_VAR 0 1
45552: PUSH
45553: LD_VAR 0 2
45557: PUSH
45558: LD_INT 4
45560: MINUS
45561: PUSH
45562: LD_INT 3
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: LIST
45569: PUSH
45570: LD_VAR 0 1
45574: PUSH
45575: LD_INT 3
45577: MINUS
45578: PUSH
45579: LD_VAR 0 2
45583: PUSH
45584: LD_INT 3
45586: MINUS
45587: PUSH
45588: LD_INT 2
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: LIST
45595: PUSH
45596: LD_VAR 0 1
45600: PUSH
45601: LD_INT 4
45603: MINUS
45604: PUSH
45605: LD_VAR 0 2
45609: PUSH
45610: LD_INT 1
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: LIST
45617: PUSH
45618: LD_VAR 0 1
45622: PUSH
45623: LD_VAR 0 2
45627: PUSH
45628: LD_INT 3
45630: PLUS
45631: PUSH
45632: LD_INT 0
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: LIST
45639: PUSH
45640: LD_VAR 0 1
45644: PUSH
45645: LD_INT 4
45647: PLUS
45648: PUSH
45649: LD_VAR 0 2
45653: PUSH
45654: LD_INT 4
45656: PLUS
45657: PUSH
45658: LD_INT 5
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: LIST
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: ST_TO_ADDR
// end ; 2 :
45673: GO 46232
45675: LD_INT 2
45677: DOUBLE
45678: EQUAL
45679: IFTRUE 45683
45681: GO 45812
45683: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
45684: LD_ADDR_VAR 0 5
45688: PUSH
45689: LD_VAR 0 1
45693: PUSH
45694: LD_VAR 0 2
45698: PUSH
45699: LD_INT 3
45701: MINUS
45702: PUSH
45703: LD_INT 3
45705: PUSH
45706: EMPTY
45707: LIST
45708: LIST
45709: LIST
45710: PUSH
45711: LD_VAR 0 1
45715: PUSH
45716: LD_INT 4
45718: PLUS
45719: PUSH
45720: LD_VAR 0 2
45724: PUSH
45725: LD_INT 4
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: LIST
45732: PUSH
45733: LD_VAR 0 1
45737: PUSH
45738: LD_VAR 0 2
45742: PUSH
45743: LD_INT 4
45745: PLUS
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: LIST
45754: PUSH
45755: LD_VAR 0 1
45759: PUSH
45760: LD_INT 3
45762: MINUS
45763: PUSH
45764: LD_VAR 0 2
45768: PUSH
45769: LD_INT 1
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_VAR 0 1
45781: PUSH
45782: LD_INT 4
45784: MINUS
45785: PUSH
45786: LD_VAR 0 2
45790: PUSH
45791: LD_INT 4
45793: MINUS
45794: PUSH
45795: LD_INT 2
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: LIST
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: LIST
45807: LIST
45808: LIST
45809: ST_TO_ADDR
// end ; 3 :
45810: GO 46232
45812: LD_INT 3
45814: DOUBLE
45815: EQUAL
45816: IFTRUE 45820
45818: GO 45953
45820: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
45821: LD_ADDR_VAR 0 5
45825: PUSH
45826: LD_VAR 0 1
45830: PUSH
45831: LD_INT 3
45833: PLUS
45834: PUSH
45835: LD_VAR 0 2
45839: PUSH
45840: LD_INT 4
45842: PUSH
45843: EMPTY
45844: LIST
45845: LIST
45846: LIST
45847: PUSH
45848: LD_VAR 0 1
45852: PUSH
45853: LD_INT 4
45855: PLUS
45856: PUSH
45857: LD_VAR 0 2
45861: PUSH
45862: LD_INT 4
45864: PLUS
45865: PUSH
45866: LD_INT 5
45868: PUSH
45869: EMPTY
45870: LIST
45871: LIST
45872: LIST
45873: PUSH
45874: LD_VAR 0 1
45878: PUSH
45879: LD_INT 4
45881: MINUS
45882: PUSH
45883: LD_VAR 0 2
45887: PUSH
45888: LD_INT 1
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: LIST
45895: PUSH
45896: LD_VAR 0 1
45900: PUSH
45901: LD_VAR 0 2
45905: PUSH
45906: LD_INT 4
45908: MINUS
45909: PUSH
45910: LD_INT 3
45912: PUSH
45913: EMPTY
45914: LIST
45915: LIST
45916: LIST
45917: PUSH
45918: LD_VAR 0 1
45922: PUSH
45923: LD_INT 3
45925: MINUS
45926: PUSH
45927: LD_VAR 0 2
45931: PUSH
45932: LD_INT 3
45934: MINUS
45935: PUSH
45936: LD_INT 2
45938: PUSH
45939: EMPTY
45940: LIST
45941: LIST
45942: LIST
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: ST_TO_ADDR
// end ; 4 :
45951: GO 46232
45953: LD_INT 4
45955: DOUBLE
45956: EQUAL
45957: IFTRUE 45961
45959: GO 46094
45961: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
45962: LD_ADDR_VAR 0 5
45966: PUSH
45967: LD_VAR 0 1
45971: PUSH
45972: LD_VAR 0 2
45976: PUSH
45977: LD_INT 4
45979: PLUS
45980: PUSH
45981: LD_INT 0
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: LIST
45988: PUSH
45989: LD_VAR 0 1
45993: PUSH
45994: LD_INT 3
45996: PLUS
45997: PUSH
45998: LD_VAR 0 2
46002: PUSH
46003: LD_INT 3
46005: PLUS
46006: PUSH
46007: LD_INT 5
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: LIST
46014: PUSH
46015: LD_VAR 0 1
46019: PUSH
46020: LD_INT 4
46022: PLUS
46023: PUSH
46024: LD_VAR 0 2
46028: PUSH
46029: LD_INT 4
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: LIST
46036: PUSH
46037: LD_VAR 0 1
46041: PUSH
46042: LD_VAR 0 2
46046: PUSH
46047: LD_INT 3
46049: MINUS
46050: PUSH
46051: LD_INT 3
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: LIST
46058: PUSH
46059: LD_VAR 0 1
46063: PUSH
46064: LD_INT 4
46066: MINUS
46067: PUSH
46068: LD_VAR 0 2
46072: PUSH
46073: LD_INT 4
46075: MINUS
46076: PUSH
46077: LD_INT 2
46079: PUSH
46080: EMPTY
46081: LIST
46082: LIST
46083: LIST
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: ST_TO_ADDR
// end ; 5 :
46092: GO 46232
46094: LD_INT 5
46096: DOUBLE
46097: EQUAL
46098: IFTRUE 46102
46100: GO 46231
46102: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
46103: LD_ADDR_VAR 0 5
46107: PUSH
46108: LD_VAR 0 1
46112: PUSH
46113: LD_INT 4
46115: MINUS
46116: PUSH
46117: LD_VAR 0 2
46121: PUSH
46122: LD_INT 1
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: LIST
46129: PUSH
46130: LD_VAR 0 1
46134: PUSH
46135: LD_VAR 0 2
46139: PUSH
46140: LD_INT 4
46142: MINUS
46143: PUSH
46144: LD_INT 3
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: LIST
46151: PUSH
46152: LD_VAR 0 1
46156: PUSH
46157: LD_INT 4
46159: PLUS
46160: PUSH
46161: LD_VAR 0 2
46165: PUSH
46166: LD_INT 4
46168: PLUS
46169: PUSH
46170: LD_INT 5
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: LIST
46177: PUSH
46178: LD_VAR 0 1
46182: PUSH
46183: LD_INT 3
46185: PLUS
46186: PUSH
46187: LD_VAR 0 2
46191: PUSH
46192: LD_INT 4
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: LIST
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_VAR 0 2
46209: PUSH
46210: LD_INT 3
46212: PLUS
46213: PUSH
46214: LD_INT 0
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: LIST
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: ST_TO_ADDR
// end ; end ;
46229: GO 46232
46231: POP
// result := list ;
46232: LD_ADDR_VAR 0 4
46236: PUSH
46237: LD_VAR 0 5
46241: ST_TO_ADDR
// end ;
46242: LD_VAR 0 4
46246: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
46247: LD_INT 0
46249: PPUSH
46250: PPUSH
46251: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
46252: LD_VAR 0 1
46256: NOT
46257: PUSH
46258: LD_VAR 0 2
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 3
46271: PUSH
46272: LD_INT 4
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: IN
46281: NOT
46282: OR
46283: IFFALSE 46287
// exit ;
46285: GO 46379
// tmp := [ ] ;
46287: LD_ADDR_VAR 0 5
46291: PUSH
46292: EMPTY
46293: ST_TO_ADDR
// for i in units do
46294: LD_ADDR_VAR 0 4
46298: PUSH
46299: LD_VAR 0 1
46303: PUSH
46304: FOR_IN
46305: IFFALSE 46348
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
46307: LD_ADDR_VAR 0 5
46311: PUSH
46312: LD_VAR 0 5
46316: PPUSH
46317: LD_VAR 0 5
46321: PUSH
46322: LD_INT 1
46324: PLUS
46325: PPUSH
46326: LD_VAR 0 4
46330: PPUSH
46331: LD_VAR 0 2
46335: PPUSH
46336: CALL_OW 259
46340: PPUSH
46341: CALL_OW 2
46345: ST_TO_ADDR
46346: GO 46304
46348: POP
46349: POP
// if not tmp then
46350: LD_VAR 0 5
46354: NOT
46355: IFFALSE 46359
// exit ;
46357: GO 46379
// result := SortListByListDesc ( units , tmp ) ;
46359: LD_ADDR_VAR 0 3
46363: PUSH
46364: LD_VAR 0 1
46368: PPUSH
46369: LD_VAR 0 5
46373: PPUSH
46374: CALL_OW 77
46378: ST_TO_ADDR
// end ;
46379: LD_VAR 0 3
46383: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
46384: LD_INT 0
46386: PPUSH
46387: PPUSH
46388: PPUSH
// result := false ;
46389: LD_ADDR_VAR 0 3
46393: PUSH
46394: LD_INT 0
46396: ST_TO_ADDR
// x := GetX ( building ) ;
46397: LD_ADDR_VAR 0 4
46401: PUSH
46402: LD_VAR 0 2
46406: PPUSH
46407: CALL_OW 250
46411: ST_TO_ADDR
// y := GetY ( building ) ;
46412: LD_ADDR_VAR 0 5
46416: PUSH
46417: LD_VAR 0 2
46421: PPUSH
46422: CALL_OW 251
46426: ST_TO_ADDR
// if not building or not x or not y then
46427: LD_VAR 0 2
46431: NOT
46432: PUSH
46433: LD_VAR 0 4
46437: NOT
46438: OR
46439: PUSH
46440: LD_VAR 0 5
46444: NOT
46445: OR
46446: IFFALSE 46450
// exit ;
46448: GO 46542
// if GetTaskList ( unit ) then
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 437
46459: IFFALSE 46542
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46461: LD_STRING e
46463: PUSH
46464: LD_VAR 0 1
46468: PPUSH
46469: CALL_OW 437
46473: PUSH
46474: LD_INT 1
46476: ARRAY
46477: PUSH
46478: LD_INT 1
46480: ARRAY
46481: EQUAL
46482: PUSH
46483: LD_VAR 0 4
46487: PUSH
46488: LD_VAR 0 1
46492: PPUSH
46493: CALL_OW 437
46497: PUSH
46498: LD_INT 1
46500: ARRAY
46501: PUSH
46502: LD_INT 2
46504: ARRAY
46505: EQUAL
46506: AND
46507: PUSH
46508: LD_VAR 0 5
46512: PUSH
46513: LD_VAR 0 1
46517: PPUSH
46518: CALL_OW 437
46522: PUSH
46523: LD_INT 1
46525: ARRAY
46526: PUSH
46527: LD_INT 3
46529: ARRAY
46530: EQUAL
46531: AND
46532: IFFALSE 46542
// result := true end ;
46534: LD_ADDR_VAR 0 3
46538: PUSH
46539: LD_INT 1
46541: ST_TO_ADDR
// end ;
46542: LD_VAR 0 3
46546: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
46547: LD_INT 0
46549: PPUSH
// result := false ;
46550: LD_ADDR_VAR 0 4
46554: PUSH
46555: LD_INT 0
46557: ST_TO_ADDR
// if GetTaskList ( unit ) then
46558: LD_VAR 0 1
46562: PPUSH
46563: CALL_OW 437
46567: IFFALSE 46650
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
46569: LD_STRING M
46571: PUSH
46572: LD_VAR 0 1
46576: PPUSH
46577: CALL_OW 437
46581: PUSH
46582: LD_INT 1
46584: ARRAY
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: EQUAL
46590: PUSH
46591: LD_VAR 0 2
46595: PUSH
46596: LD_VAR 0 1
46600: PPUSH
46601: CALL_OW 437
46605: PUSH
46606: LD_INT 1
46608: ARRAY
46609: PUSH
46610: LD_INT 2
46612: ARRAY
46613: EQUAL
46614: AND
46615: PUSH
46616: LD_VAR 0 3
46620: PUSH
46621: LD_VAR 0 1
46625: PPUSH
46626: CALL_OW 437
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: EQUAL
46639: AND
46640: IFFALSE 46650
// result := true ;
46642: LD_ADDR_VAR 0 4
46646: PUSH
46647: LD_INT 1
46649: ST_TO_ADDR
// end ; end ;
46650: LD_VAR 0 4
46654: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
46655: LD_INT 0
46657: PPUSH
46658: PPUSH
46659: PPUSH
46660: PPUSH
// if not unit or not area then
46661: LD_VAR 0 1
46665: NOT
46666: PUSH
46667: LD_VAR 0 2
46671: NOT
46672: OR
46673: IFFALSE 46677
// exit ;
46675: GO 46841
// tmp := AreaToList ( area , i ) ;
46677: LD_ADDR_VAR 0 6
46681: PUSH
46682: LD_VAR 0 2
46686: PPUSH
46687: LD_VAR 0 5
46691: PPUSH
46692: CALL_OW 517
46696: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
46697: LD_ADDR_VAR 0 5
46701: PUSH
46702: DOUBLE
46703: LD_INT 1
46705: DEC
46706: ST_TO_ADDR
46707: LD_VAR 0 6
46711: PUSH
46712: LD_INT 1
46714: ARRAY
46715: PUSH
46716: FOR_TO
46717: IFFALSE 46839
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
46719: LD_ADDR_VAR 0 7
46723: PUSH
46724: LD_VAR 0 6
46728: PUSH
46729: LD_INT 1
46731: ARRAY
46732: PUSH
46733: LD_VAR 0 5
46737: ARRAY
46738: PUSH
46739: LD_VAR 0 6
46743: PUSH
46744: LD_INT 2
46746: ARRAY
46747: PUSH
46748: LD_VAR 0 5
46752: ARRAY
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
46758: LD_VAR 0 7
46762: PUSH
46763: LD_INT 1
46765: ARRAY
46766: PPUSH
46767: LD_VAR 0 7
46771: PUSH
46772: LD_INT 2
46774: ARRAY
46775: PPUSH
46776: CALL_OW 428
46780: PUSH
46781: LD_INT 0
46783: EQUAL
46784: IFFALSE 46837
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
46786: LD_VAR 0 1
46790: PPUSH
46791: LD_VAR 0 7
46795: PUSH
46796: LD_INT 1
46798: ARRAY
46799: PPUSH
46800: LD_VAR 0 7
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: LD_VAR 0 3
46813: PPUSH
46814: CALL_OW 48
// result := IsPlaced ( unit ) ;
46818: LD_ADDR_VAR 0 4
46822: PUSH
46823: LD_VAR 0 1
46827: PPUSH
46828: CALL_OW 305
46832: ST_TO_ADDR
// exit ;
46833: POP
46834: POP
46835: GO 46841
// end ; end ;
46837: GO 46716
46839: POP
46840: POP
// end ;
46841: LD_VAR 0 4
46845: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
46846: LD_INT 0
46848: PPUSH
46849: PPUSH
46850: PPUSH
// if not side or side > 8 then
46851: LD_VAR 0 1
46855: NOT
46856: PUSH
46857: LD_VAR 0 1
46861: PUSH
46862: LD_INT 8
46864: GREATER
46865: OR
46866: IFFALSE 46870
// exit ;
46868: GO 47057
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
46870: LD_ADDR_VAR 0 4
46874: PUSH
46875: LD_INT 22
46877: PUSH
46878: LD_VAR 0 1
46882: PUSH
46883: EMPTY
46884: LIST
46885: LIST
46886: PUSH
46887: LD_INT 21
46889: PUSH
46890: LD_INT 3
46892: PUSH
46893: EMPTY
46894: LIST
46895: LIST
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PPUSH
46901: CALL_OW 69
46905: ST_TO_ADDR
// if not tmp then
46906: LD_VAR 0 4
46910: NOT
46911: IFFALSE 46915
// exit ;
46913: GO 47057
// enable_addtolog := true ;
46915: LD_ADDR_OWVAR 81
46919: PUSH
46920: LD_INT 1
46922: ST_TO_ADDR
// AddToLog ( [ ) ;
46923: LD_STRING [
46925: PPUSH
46926: CALL_OW 561
// for i in tmp do
46930: LD_ADDR_VAR 0 3
46934: PUSH
46935: LD_VAR 0 4
46939: PUSH
46940: FOR_IN
46941: IFFALSE 47048
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
46943: LD_STRING [
46945: PUSH
46946: LD_VAR 0 3
46950: PPUSH
46951: CALL_OW 266
46955: STR
46956: PUSH
46957: LD_STRING , 
46959: STR
46960: PUSH
46961: LD_VAR 0 3
46965: PPUSH
46966: CALL_OW 250
46970: STR
46971: PUSH
46972: LD_STRING , 
46974: STR
46975: PUSH
46976: LD_VAR 0 3
46980: PPUSH
46981: CALL_OW 251
46985: STR
46986: PUSH
46987: LD_STRING , 
46989: STR
46990: PUSH
46991: LD_VAR 0 3
46995: PPUSH
46996: CALL_OW 254
47000: STR
47001: PUSH
47002: LD_STRING , 
47004: STR
47005: PUSH
47006: LD_VAR 0 3
47010: PPUSH
47011: LD_INT 1
47013: PPUSH
47014: CALL_OW 268
47018: STR
47019: PUSH
47020: LD_STRING , 
47022: STR
47023: PUSH
47024: LD_VAR 0 3
47028: PPUSH
47029: LD_INT 2
47031: PPUSH
47032: CALL_OW 268
47036: STR
47037: PUSH
47038: LD_STRING ],
47040: STR
47041: PPUSH
47042: CALL_OW 561
// end ;
47046: GO 46940
47048: POP
47049: POP
// AddToLog ( ]; ) ;
47050: LD_STRING ];
47052: PPUSH
47053: CALL_OW 561
// end ;
47057: LD_VAR 0 2
47061: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
47062: LD_INT 0
47064: PPUSH
47065: PPUSH
47066: PPUSH
47067: PPUSH
47068: PPUSH
// if not area or not rate or not max then
47069: LD_VAR 0 1
47073: NOT
47074: PUSH
47075: LD_VAR 0 2
47079: NOT
47080: OR
47081: PUSH
47082: LD_VAR 0 4
47086: NOT
47087: OR
47088: IFFALSE 47092
// exit ;
47090: GO 47284
// while 1 do
47092: LD_INT 1
47094: IFFALSE 47284
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
47096: LD_ADDR_VAR 0 9
47100: PUSH
47101: LD_VAR 0 1
47105: PPUSH
47106: LD_INT 1
47108: PPUSH
47109: CALL_OW 287
47113: PUSH
47114: LD_INT 10
47116: MUL
47117: ST_TO_ADDR
// r := rate / 10 ;
47118: LD_ADDR_VAR 0 7
47122: PUSH
47123: LD_VAR 0 2
47127: PUSH
47128: LD_INT 10
47130: DIVREAL
47131: ST_TO_ADDR
// time := 1 1$00 ;
47132: LD_ADDR_VAR 0 8
47136: PUSH
47137: LD_INT 2100
47139: ST_TO_ADDR
// if amount < min then
47140: LD_VAR 0 9
47144: PUSH
47145: LD_VAR 0 3
47149: LESS
47150: IFFALSE 47168
// r := r * 2 else
47152: LD_ADDR_VAR 0 7
47156: PUSH
47157: LD_VAR 0 7
47161: PUSH
47162: LD_INT 2
47164: MUL
47165: ST_TO_ADDR
47166: GO 47194
// if amount > max then
47168: LD_VAR 0 9
47172: PUSH
47173: LD_VAR 0 4
47177: GREATER
47178: IFFALSE 47194
// r := r / 2 ;
47180: LD_ADDR_VAR 0 7
47184: PUSH
47185: LD_VAR 0 7
47189: PUSH
47190: LD_INT 2
47192: DIVREAL
47193: ST_TO_ADDR
// time := time / r ;
47194: LD_ADDR_VAR 0 8
47198: PUSH
47199: LD_VAR 0 8
47203: PUSH
47204: LD_VAR 0 7
47208: DIVREAL
47209: ST_TO_ADDR
// if time < 0 then
47210: LD_VAR 0 8
47214: PUSH
47215: LD_INT 0
47217: LESS
47218: IFFALSE 47235
// time := time * - 1 ;
47220: LD_ADDR_VAR 0 8
47224: PUSH
47225: LD_VAR 0 8
47229: PUSH
47230: LD_INT 1
47232: NEG
47233: MUL
47234: ST_TO_ADDR
// wait ( time ) ;
47235: LD_VAR 0 8
47239: PPUSH
47240: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
47244: LD_INT 35
47246: PPUSH
47247: LD_INT 875
47249: PPUSH
47250: CALL_OW 12
47254: PPUSH
47255: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
47259: LD_INT 1
47261: PPUSH
47262: LD_INT 5
47264: PPUSH
47265: CALL_OW 12
47269: PPUSH
47270: LD_VAR 0 1
47274: PPUSH
47275: LD_INT 1
47277: PPUSH
47278: CALL_OW 55
// end ;
47282: GO 47092
// end ;
47284: LD_VAR 0 5
47288: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
47289: LD_INT 0
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
47296: PPUSH
47297: PPUSH
47298: PPUSH
// if not turrets or not factories then
47299: LD_VAR 0 1
47303: NOT
47304: PUSH
47305: LD_VAR 0 2
47309: NOT
47310: OR
47311: IFFALSE 47315
// exit ;
47313: GO 47622
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
47315: LD_ADDR_VAR 0 10
47319: PUSH
47320: LD_INT 5
47322: PUSH
47323: LD_INT 6
47325: PUSH
47326: EMPTY
47327: LIST
47328: LIST
47329: PUSH
47330: LD_INT 2
47332: PUSH
47333: LD_INT 4
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 3
47342: PUSH
47343: LD_INT 5
47345: PUSH
47346: EMPTY
47347: LIST
47348: LIST
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 24
47357: PUSH
47358: LD_INT 25
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: LD_INT 23
47367: PUSH
47368: LD_INT 27
47370: PUSH
47371: EMPTY
47372: LIST
47373: LIST
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: LD_INT 42
47381: PUSH
47382: LD_INT 43
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: PUSH
47389: LD_INT 44
47391: PUSH
47392: LD_INT 46
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 45
47401: PUSH
47402: LD_INT 47
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: LIST
47413: PUSH
47414: EMPTY
47415: LIST
47416: LIST
47417: LIST
47418: ST_TO_ADDR
// result := [ ] ;
47419: LD_ADDR_VAR 0 3
47423: PUSH
47424: EMPTY
47425: ST_TO_ADDR
// for i in turrets do
47426: LD_ADDR_VAR 0 4
47430: PUSH
47431: LD_VAR 0 1
47435: PUSH
47436: FOR_IN
47437: IFFALSE 47620
// begin nat := GetNation ( i ) ;
47439: LD_ADDR_VAR 0 7
47443: PUSH
47444: LD_VAR 0 4
47448: PPUSH
47449: CALL_OW 248
47453: ST_TO_ADDR
// weapon := 0 ;
47454: LD_ADDR_VAR 0 8
47458: PUSH
47459: LD_INT 0
47461: ST_TO_ADDR
// if not nat then
47462: LD_VAR 0 7
47466: NOT
47467: IFFALSE 47471
// continue ;
47469: GO 47436
// for j in list [ nat ] do
47471: LD_ADDR_VAR 0 5
47475: PUSH
47476: LD_VAR 0 10
47480: PUSH
47481: LD_VAR 0 7
47485: ARRAY
47486: PUSH
47487: FOR_IN
47488: IFFALSE 47529
// if GetBWeapon ( i ) = j [ 1 ] then
47490: LD_VAR 0 4
47494: PPUSH
47495: CALL_OW 269
47499: PUSH
47500: LD_VAR 0 5
47504: PUSH
47505: LD_INT 1
47507: ARRAY
47508: EQUAL
47509: IFFALSE 47527
// begin weapon := j [ 2 ] ;
47511: LD_ADDR_VAR 0 8
47515: PUSH
47516: LD_VAR 0 5
47520: PUSH
47521: LD_INT 2
47523: ARRAY
47524: ST_TO_ADDR
// break ;
47525: GO 47529
// end ;
47527: GO 47487
47529: POP
47530: POP
// if not weapon then
47531: LD_VAR 0 8
47535: NOT
47536: IFFALSE 47540
// continue ;
47538: GO 47436
// for k in factories do
47540: LD_ADDR_VAR 0 6
47544: PUSH
47545: LD_VAR 0 2
47549: PUSH
47550: FOR_IN
47551: IFFALSE 47616
// begin weapons := AvailableWeaponList ( k ) ;
47553: LD_ADDR_VAR 0 9
47557: PUSH
47558: LD_VAR 0 6
47562: PPUSH
47563: CALL_OW 478
47567: ST_TO_ADDR
// if not weapons then
47568: LD_VAR 0 9
47572: NOT
47573: IFFALSE 47577
// continue ;
47575: GO 47550
// if weapon in weapons then
47577: LD_VAR 0 8
47581: PUSH
47582: LD_VAR 0 9
47586: IN
47587: IFFALSE 47614
// begin result := [ i , weapon ] ;
47589: LD_ADDR_VAR 0 3
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_VAR 0 8
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: ST_TO_ADDR
// exit ;
47608: POP
47609: POP
47610: POP
47611: POP
47612: GO 47622
// end ; end ;
47614: GO 47550
47616: POP
47617: POP
// end ;
47618: GO 47436
47620: POP
47621: POP
// end ;
47622: LD_VAR 0 3
47626: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
47627: LD_INT 0
47629: PPUSH
// if not side or side > 8 then
47630: LD_VAR 0 3
47634: NOT
47635: PUSH
47636: LD_VAR 0 3
47640: PUSH
47641: LD_INT 8
47643: GREATER
47644: OR
47645: IFFALSE 47649
// exit ;
47647: GO 47708
// if not range then
47649: LD_VAR 0 4
47653: NOT
47654: IFFALSE 47665
// range := - 12 ;
47656: LD_ADDR_VAR 0 4
47660: PUSH
47661: LD_INT 12
47663: NEG
47664: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
47665: LD_VAR 0 1
47669: PPUSH
47670: LD_VAR 0 2
47674: PPUSH
47675: LD_VAR 0 3
47679: PPUSH
47680: LD_VAR 0 4
47684: PPUSH
47685: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 2
47698: PPUSH
47699: LD_VAR 0 3
47703: PPUSH
47704: CALL_OW 331
// end ;
47708: LD_VAR 0 5
47712: RET
// export function Video ( mode ) ; begin
47713: LD_INT 0
47715: PPUSH
// ingame_video = mode ;
47716: LD_ADDR_OWVAR 52
47720: PUSH
47721: LD_VAR 0 1
47725: ST_TO_ADDR
// interface_hidden = mode ;
47726: LD_ADDR_OWVAR 54
47730: PUSH
47731: LD_VAR 0 1
47735: ST_TO_ADDR
// end ;
47736: LD_VAR 0 2
47740: RET
// export function Join ( array , element ) ; begin
47741: LD_INT 0
47743: PPUSH
// result := Replace ( array , array + 1 , element ) ;
47744: LD_ADDR_VAR 0 3
47748: PUSH
47749: LD_VAR 0 1
47753: PPUSH
47754: LD_VAR 0 1
47758: PUSH
47759: LD_INT 1
47761: PLUS
47762: PPUSH
47763: LD_VAR 0 2
47767: PPUSH
47768: CALL_OW 1
47772: ST_TO_ADDR
// end ;
47773: LD_VAR 0 3
47777: RET
// export function JoinUnion ( array , element ) ; begin
47778: LD_INT 0
47780: PPUSH
// result := array union element ;
47781: LD_ADDR_VAR 0 3
47785: PUSH
47786: LD_VAR 0 1
47790: PUSH
47791: LD_VAR 0 2
47795: UNION
47796: ST_TO_ADDR
// end ;
47797: LD_VAR 0 3
47801: RET
// export function GetBehemoths ( side ) ; begin
47802: LD_INT 0
47804: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
47805: LD_ADDR_VAR 0 2
47809: PUSH
47810: LD_INT 22
47812: PUSH
47813: LD_VAR 0 1
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 31
47824: PUSH
47825: LD_INT 25
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: ST_TO_ADDR
// end ;
47841: LD_VAR 0 2
47845: RET
// export function Shuffle ( array ) ; var i , index ; begin
47846: LD_INT 0
47848: PPUSH
47849: PPUSH
47850: PPUSH
// result := [ ] ;
47851: LD_ADDR_VAR 0 2
47855: PUSH
47856: EMPTY
47857: ST_TO_ADDR
// if not array then
47858: LD_VAR 0 1
47862: NOT
47863: IFFALSE 47867
// exit ;
47865: GO 47966
// Randomize ;
47867: CALL_OW 10
// for i = array downto 1 do
47871: LD_ADDR_VAR 0 3
47875: PUSH
47876: DOUBLE
47877: LD_VAR 0 1
47881: INC
47882: ST_TO_ADDR
47883: LD_INT 1
47885: PUSH
47886: FOR_DOWNTO
47887: IFFALSE 47964
// begin index := rand ( 1 , array ) ;
47889: LD_ADDR_VAR 0 4
47893: PUSH
47894: LD_INT 1
47896: PPUSH
47897: LD_VAR 0 1
47901: PPUSH
47902: CALL_OW 12
47906: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
47907: LD_ADDR_VAR 0 2
47911: PUSH
47912: LD_VAR 0 2
47916: PPUSH
47917: LD_VAR 0 2
47921: PUSH
47922: LD_INT 1
47924: PLUS
47925: PPUSH
47926: LD_VAR 0 1
47930: PUSH
47931: LD_VAR 0 4
47935: ARRAY
47936: PPUSH
47937: CALL_OW 2
47941: ST_TO_ADDR
// array := Delete ( array , index ) ;
47942: LD_ADDR_VAR 0 1
47946: PUSH
47947: LD_VAR 0 1
47951: PPUSH
47952: LD_VAR 0 4
47956: PPUSH
47957: CALL_OW 3
47961: ST_TO_ADDR
// end ;
47962: GO 47886
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 2
47970: RET
// export function GetBaseMaterials ( base ) ; begin
47971: LD_INT 0
47973: PPUSH
// result := [ 0 , 0 , 0 ] ;
47974: LD_ADDR_VAR 0 2
47978: PUSH
47979: LD_INT 0
47981: PUSH
47982: LD_INT 0
47984: PUSH
47985: LD_INT 0
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: LIST
47992: ST_TO_ADDR
// if not base then
47993: LD_VAR 0 1
47997: NOT
47998: IFFALSE 48002
// exit ;
48000: GO 48051
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
48002: LD_ADDR_VAR 0 2
48006: PUSH
48007: LD_VAR 0 1
48011: PPUSH
48012: LD_INT 1
48014: PPUSH
48015: CALL_OW 275
48019: PUSH
48020: LD_VAR 0 1
48024: PPUSH
48025: LD_INT 2
48027: PPUSH
48028: CALL_OW 275
48032: PUSH
48033: LD_VAR 0 1
48037: PPUSH
48038: LD_INT 3
48040: PPUSH
48041: CALL_OW 275
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: LIST
48050: ST_TO_ADDR
// end ;
48051: LD_VAR 0 2
48055: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
48056: LD_INT 0
48058: PPUSH
48059: PPUSH
// result := array ;
48060: LD_ADDR_VAR 0 3
48064: PUSH
48065: LD_VAR 0 1
48069: ST_TO_ADDR
// if size > 0 then
48070: LD_VAR 0 2
48074: PUSH
48075: LD_INT 0
48077: GREATER
48078: IFFALSE 48124
// for i := array downto size do
48080: LD_ADDR_VAR 0 4
48084: PUSH
48085: DOUBLE
48086: LD_VAR 0 1
48090: INC
48091: ST_TO_ADDR
48092: LD_VAR 0 2
48096: PUSH
48097: FOR_DOWNTO
48098: IFFALSE 48122
// result := Delete ( result , result ) ;
48100: LD_ADDR_VAR 0 3
48104: PUSH
48105: LD_VAR 0 3
48109: PPUSH
48110: LD_VAR 0 3
48114: PPUSH
48115: CALL_OW 3
48119: ST_TO_ADDR
48120: GO 48097
48122: POP
48123: POP
// end ;
48124: LD_VAR 0 3
48128: RET
// export function ComExit ( unit ) ; var tmp ; begin
48129: LD_INT 0
48131: PPUSH
48132: PPUSH
// if not IsInUnit ( unit ) then
48133: LD_VAR 0 1
48137: PPUSH
48138: CALL_OW 310
48142: NOT
48143: IFFALSE 48147
// exit ;
48145: GO 48207
// tmp := IsInUnit ( unit ) ;
48147: LD_ADDR_VAR 0 3
48151: PUSH
48152: LD_VAR 0 1
48156: PPUSH
48157: CALL_OW 310
48161: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
48162: LD_VAR 0 3
48166: PPUSH
48167: CALL_OW 247
48171: PUSH
48172: LD_INT 2
48174: EQUAL
48175: IFFALSE 48188
// ComExitVehicle ( unit ) else
48177: LD_VAR 0 1
48181: PPUSH
48182: CALL_OW 121
48186: GO 48197
// ComExitBuilding ( unit ) ;
48188: LD_VAR 0 1
48192: PPUSH
48193: CALL_OW 122
// result := tmp ;
48197: LD_ADDR_VAR 0 2
48201: PUSH
48202: LD_VAR 0 3
48206: ST_TO_ADDR
// end ;
48207: LD_VAR 0 2
48211: RET
// export function ComExitAll ( units ) ; var i ; begin
48212: LD_INT 0
48214: PPUSH
48215: PPUSH
// if not units then
48216: LD_VAR 0 1
48220: NOT
48221: IFFALSE 48225
// exit ;
48223: GO 48251
// for i in units do
48225: LD_ADDR_VAR 0 3
48229: PUSH
48230: LD_VAR 0 1
48234: PUSH
48235: FOR_IN
48236: IFFALSE 48249
// ComExit ( i ) ;
48238: LD_VAR 0 3
48242: PPUSH
48243: CALL 48129 0 1
48247: GO 48235
48249: POP
48250: POP
// end ;
48251: LD_VAR 0 2
48255: RET
// export function ResetHc ; begin
48256: LD_INT 0
48258: PPUSH
// InitHc ;
48259: CALL_OW 19
// hc_importance := 0 ;
48263: LD_ADDR_OWVAR 32
48267: PUSH
48268: LD_INT 0
48270: ST_TO_ADDR
// end ;
48271: LD_VAR 0 1
48275: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
48276: LD_INT 0
48278: PPUSH
48279: PPUSH
48280: PPUSH
// _x := ( x1 + x2 ) div 2 ;
48281: LD_ADDR_VAR 0 6
48285: PUSH
48286: LD_VAR 0 1
48290: PUSH
48291: LD_VAR 0 3
48295: PLUS
48296: PUSH
48297: LD_INT 2
48299: DIV
48300: ST_TO_ADDR
// if _x < 0 then
48301: LD_VAR 0 6
48305: PUSH
48306: LD_INT 0
48308: LESS
48309: IFFALSE 48326
// _x := _x * - 1 ;
48311: LD_ADDR_VAR 0 6
48315: PUSH
48316: LD_VAR 0 6
48320: PUSH
48321: LD_INT 1
48323: NEG
48324: MUL
48325: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
48326: LD_ADDR_VAR 0 7
48330: PUSH
48331: LD_VAR 0 2
48335: PUSH
48336: LD_VAR 0 4
48340: PLUS
48341: PUSH
48342: LD_INT 2
48344: DIV
48345: ST_TO_ADDR
// if _y < 0 then
48346: LD_VAR 0 7
48350: PUSH
48351: LD_INT 0
48353: LESS
48354: IFFALSE 48371
// _y := _y * - 1 ;
48356: LD_ADDR_VAR 0 7
48360: PUSH
48361: LD_VAR 0 7
48365: PUSH
48366: LD_INT 1
48368: NEG
48369: MUL
48370: ST_TO_ADDR
// result := [ _x , _y ] ;
48371: LD_ADDR_VAR 0 5
48375: PUSH
48376: LD_VAR 0 6
48380: PUSH
48381: LD_VAR 0 7
48385: PUSH
48386: EMPTY
48387: LIST
48388: LIST
48389: ST_TO_ADDR
// end ;
48390: LD_VAR 0 5
48394: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
48395: LD_INT 0
48397: PPUSH
48398: PPUSH
48399: PPUSH
48400: PPUSH
// task := GetTaskList ( unit ) ;
48401: LD_ADDR_VAR 0 7
48405: PUSH
48406: LD_VAR 0 1
48410: PPUSH
48411: CALL_OW 437
48415: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
48416: LD_VAR 0 7
48420: NOT
48421: PUSH
48422: LD_VAR 0 1
48426: PPUSH
48427: LD_VAR 0 2
48431: PPUSH
48432: CALL_OW 308
48436: NOT
48437: AND
48438: IFFALSE 48442
// exit ;
48440: GO 48560
// if IsInArea ( unit , area ) then
48442: LD_VAR 0 1
48446: PPUSH
48447: LD_VAR 0 2
48451: PPUSH
48452: CALL_OW 308
48456: IFFALSE 48474
// begin ComMoveToArea ( unit , goAway ) ;
48458: LD_VAR 0 1
48462: PPUSH
48463: LD_VAR 0 3
48467: PPUSH
48468: CALL_OW 113
// exit ;
48472: GO 48560
// end ; if task [ 1 ] [ 1 ] <> M then
48474: LD_VAR 0 7
48478: PUSH
48479: LD_INT 1
48481: ARRAY
48482: PUSH
48483: LD_INT 1
48485: ARRAY
48486: PUSH
48487: LD_STRING M
48489: NONEQUAL
48490: IFFALSE 48494
// exit ;
48492: GO 48560
// x := task [ 1 ] [ 2 ] ;
48494: LD_ADDR_VAR 0 5
48498: PUSH
48499: LD_VAR 0 7
48503: PUSH
48504: LD_INT 1
48506: ARRAY
48507: PUSH
48508: LD_INT 2
48510: ARRAY
48511: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
48512: LD_ADDR_VAR 0 6
48516: PUSH
48517: LD_VAR 0 7
48521: PUSH
48522: LD_INT 1
48524: ARRAY
48525: PUSH
48526: LD_INT 3
48528: ARRAY
48529: ST_TO_ADDR
// if InArea ( x , y , area ) then
48530: LD_VAR 0 5
48534: PPUSH
48535: LD_VAR 0 6
48539: PPUSH
48540: LD_VAR 0 2
48544: PPUSH
48545: CALL_OW 309
48549: IFFALSE 48560
// ComStop ( unit ) ;
48551: LD_VAR 0 1
48555: PPUSH
48556: CALL_OW 141
// end ;
48560: LD_VAR 0 4
48564: RET
// export function Abs ( value ) ; begin
48565: LD_INT 0
48567: PPUSH
// result := value ;
48568: LD_ADDR_VAR 0 2
48572: PUSH
48573: LD_VAR 0 1
48577: ST_TO_ADDR
// if value < 0 then
48578: LD_VAR 0 1
48582: PUSH
48583: LD_INT 0
48585: LESS
48586: IFFALSE 48603
// result := value * - 1 ;
48588: LD_ADDR_VAR 0 2
48592: PUSH
48593: LD_VAR 0 1
48597: PUSH
48598: LD_INT 1
48600: NEG
48601: MUL
48602: ST_TO_ADDR
// end ;
48603: LD_VAR 0 2
48607: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
48608: LD_INT 0
48610: PPUSH
48611: PPUSH
48612: PPUSH
48613: PPUSH
48614: PPUSH
48615: PPUSH
48616: PPUSH
48617: PPUSH
// if not unit or not building then
48618: LD_VAR 0 1
48622: NOT
48623: PUSH
48624: LD_VAR 0 2
48628: NOT
48629: OR
48630: IFFALSE 48634
// exit ;
48632: GO 48860
// x := GetX ( building ) ;
48634: LD_ADDR_VAR 0 4
48638: PUSH
48639: LD_VAR 0 2
48643: PPUSH
48644: CALL_OW 250
48648: ST_TO_ADDR
// y := GetY ( building ) ;
48649: LD_ADDR_VAR 0 6
48653: PUSH
48654: LD_VAR 0 2
48658: PPUSH
48659: CALL_OW 251
48663: ST_TO_ADDR
// d := GetDir ( building ) ;
48664: LD_ADDR_VAR 0 8
48668: PUSH
48669: LD_VAR 0 2
48673: PPUSH
48674: CALL_OW 254
48678: ST_TO_ADDR
// r := 4 ;
48679: LD_ADDR_VAR 0 9
48683: PUSH
48684: LD_INT 4
48686: ST_TO_ADDR
// for i := 1 to 5 do
48687: LD_ADDR_VAR 0 10
48691: PUSH
48692: DOUBLE
48693: LD_INT 1
48695: DEC
48696: ST_TO_ADDR
48697: LD_INT 5
48699: PUSH
48700: FOR_TO
48701: IFFALSE 48858
// begin _x := ShiftX ( x , d , r + i ) ;
48703: LD_ADDR_VAR 0 5
48707: PUSH
48708: LD_VAR 0 4
48712: PPUSH
48713: LD_VAR 0 8
48717: PPUSH
48718: LD_VAR 0 9
48722: PUSH
48723: LD_VAR 0 10
48727: PLUS
48728: PPUSH
48729: CALL_OW 272
48733: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
48734: LD_ADDR_VAR 0 7
48738: PUSH
48739: LD_VAR 0 6
48743: PPUSH
48744: LD_VAR 0 8
48748: PPUSH
48749: LD_VAR 0 9
48753: PUSH
48754: LD_VAR 0 10
48758: PLUS
48759: PPUSH
48760: CALL_OW 273
48764: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
48765: LD_VAR 0 5
48769: PPUSH
48770: LD_VAR 0 7
48774: PPUSH
48775: CALL_OW 488
48779: PUSH
48780: LD_VAR 0 5
48784: PPUSH
48785: LD_VAR 0 7
48789: PPUSH
48790: CALL_OW 428
48794: PPUSH
48795: CALL_OW 247
48799: PUSH
48800: LD_INT 3
48802: PUSH
48803: LD_INT 2
48805: PUSH
48806: EMPTY
48807: LIST
48808: LIST
48809: IN
48810: NOT
48811: AND
48812: IFFALSE 48856
// begin ComMoveXY ( unit , _x , _y ) ;
48814: LD_VAR 0 1
48818: PPUSH
48819: LD_VAR 0 5
48823: PPUSH
48824: LD_VAR 0 7
48828: PPUSH
48829: CALL_OW 111
// result := [ _x , _y ] ;
48833: LD_ADDR_VAR 0 3
48837: PUSH
48838: LD_VAR 0 5
48842: PUSH
48843: LD_VAR 0 7
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: ST_TO_ADDR
// exit ;
48852: POP
48853: POP
48854: GO 48860
// end ; end ;
48856: GO 48700
48858: POP
48859: POP
// end ;
48860: LD_VAR 0 3
48864: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
48865: LD_INT 0
48867: PPUSH
48868: PPUSH
48869: PPUSH
// result := 0 ;
48870: LD_ADDR_VAR 0 3
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
48878: LD_VAR 0 1
48882: PUSH
48883: LD_INT 0
48885: LESS
48886: PUSH
48887: LD_VAR 0 1
48891: PUSH
48892: LD_INT 8
48894: GREATER
48895: OR
48896: PUSH
48897: LD_VAR 0 2
48901: PUSH
48902: LD_INT 0
48904: LESS
48905: OR
48906: PUSH
48907: LD_VAR 0 2
48911: PUSH
48912: LD_INT 8
48914: GREATER
48915: OR
48916: IFFALSE 48920
// exit ;
48918: GO 48995
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
48920: LD_ADDR_VAR 0 4
48924: PUSH
48925: LD_INT 22
48927: PUSH
48928: LD_VAR 0 2
48932: PUSH
48933: EMPTY
48934: LIST
48935: LIST
48936: PPUSH
48937: CALL_OW 69
48941: PUSH
48942: FOR_IN
48943: IFFALSE 48993
// begin un := UnitShoot ( i ) ;
48945: LD_ADDR_VAR 0 5
48949: PUSH
48950: LD_VAR 0 4
48954: PPUSH
48955: CALL_OW 504
48959: ST_TO_ADDR
// if GetSide ( un ) = side1 then
48960: LD_VAR 0 5
48964: PPUSH
48965: CALL_OW 255
48969: PUSH
48970: LD_VAR 0 1
48974: EQUAL
48975: IFFALSE 48991
// begin result := un ;
48977: LD_ADDR_VAR 0 3
48981: PUSH
48982: LD_VAR 0 5
48986: ST_TO_ADDR
// exit ;
48987: POP
48988: POP
48989: GO 48995
// end ; end ;
48991: GO 48942
48993: POP
48994: POP
// end ;
48995: LD_VAR 0 3
48999: RET
// export function GetCargoBay ( units ) ; begin
49000: LD_INT 0
49002: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
49003: LD_ADDR_VAR 0 2
49007: PUSH
49008: LD_VAR 0 1
49012: PPUSH
49013: LD_INT 2
49015: PUSH
49016: LD_INT 34
49018: PUSH
49019: LD_INT 12
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: PUSH
49026: LD_INT 34
49028: PUSH
49029: LD_INT 51
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 34
49038: PUSH
49039: LD_INT 32
49041: PUSH
49042: EMPTY
49043: LIST
49044: LIST
49045: PUSH
49046: LD_INT 34
49048: PUSH
49049: LD_EXP 68
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: PPUSH
49065: CALL_OW 72
49069: ST_TO_ADDR
// end ;
49070: LD_VAR 0 2
49074: RET
// export function Negate ( value ) ; begin
49075: LD_INT 0
49077: PPUSH
// result := not value ;
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: LD_VAR 0 1
49087: NOT
49088: ST_TO_ADDR
// end ;
49089: LD_VAR 0 2
49093: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
49094: LD_INT 0
49096: PPUSH
// if x1 = x2 then
49097: LD_VAR 0 1
49101: PUSH
49102: LD_VAR 0 3
49106: EQUAL
49107: IFFALSE 49141
// begin if y1 > y2 then
49109: LD_VAR 0 2
49113: PUSH
49114: LD_VAR 0 4
49118: GREATER
49119: IFFALSE 49131
// result := 0 else
49121: LD_ADDR_VAR 0 5
49125: PUSH
49126: LD_INT 0
49128: ST_TO_ADDR
49129: GO 49139
// result := 3 ;
49131: LD_ADDR_VAR 0 5
49135: PUSH
49136: LD_INT 3
49138: ST_TO_ADDR
// exit ;
49139: GO 49227
// end ; if y1 = y2 then
49141: LD_VAR 0 2
49145: PUSH
49146: LD_VAR 0 4
49150: EQUAL
49151: IFFALSE 49185
// begin if x1 > x2 then
49153: LD_VAR 0 1
49157: PUSH
49158: LD_VAR 0 3
49162: GREATER
49163: IFFALSE 49175
// result := 1 else
49165: LD_ADDR_VAR 0 5
49169: PUSH
49170: LD_INT 1
49172: ST_TO_ADDR
49173: GO 49183
// result := 4 ;
49175: LD_ADDR_VAR 0 5
49179: PUSH
49180: LD_INT 4
49182: ST_TO_ADDR
// exit ;
49183: GO 49227
// end ; if x1 > x2 and y1 > y2 then
49185: LD_VAR 0 1
49189: PUSH
49190: LD_VAR 0 3
49194: GREATER
49195: PUSH
49196: LD_VAR 0 2
49200: PUSH
49201: LD_VAR 0 4
49205: GREATER
49206: AND
49207: IFFALSE 49219
// result := 2 else
49209: LD_ADDR_VAR 0 5
49213: PUSH
49214: LD_INT 2
49216: ST_TO_ADDR
49217: GO 49227
// result := 5 ;
49219: LD_ADDR_VAR 0 5
49223: PUSH
49224: LD_INT 5
49226: ST_TO_ADDR
// end ;
49227: LD_VAR 0 5
49231: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49232: LD_INT 0
49234: PPUSH
49235: PPUSH
// if not driver or not IsInUnit ( driver ) then
49236: LD_VAR 0 1
49240: NOT
49241: PUSH
49242: LD_VAR 0 1
49246: PPUSH
49247: CALL_OW 310
49251: NOT
49252: OR
49253: IFFALSE 49257
// exit ;
49255: GO 49347
// vehicle := IsInUnit ( driver ) ;
49257: LD_ADDR_VAR 0 3
49261: PUSH
49262: LD_VAR 0 1
49266: PPUSH
49267: CALL_OW 310
49271: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49272: LD_VAR 0 1
49276: PPUSH
49277: LD_STRING \
49279: PUSH
49280: LD_INT 0
49282: PUSH
49283: LD_INT 0
49285: PUSH
49286: LD_INT 0
49288: PUSH
49289: LD_INT 0
49291: PUSH
49292: LD_INT 0
49294: PUSH
49295: LD_INT 0
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: LIST
49302: LIST
49303: LIST
49304: LIST
49305: LIST
49306: PUSH
49307: LD_STRING E
49309: PUSH
49310: LD_INT 0
49312: PUSH
49313: LD_INT 0
49315: PUSH
49316: LD_VAR 0 3
49320: PUSH
49321: LD_INT 0
49323: PUSH
49324: LD_INT 0
49326: PUSH
49327: LD_INT 0
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: PPUSH
49343: CALL_OW 446
// end ;
49347: LD_VAR 0 2
49351: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
49352: LD_INT 0
49354: PPUSH
49355: PPUSH
// if not driver or not IsInUnit ( driver ) then
49356: LD_VAR 0 1
49360: NOT
49361: PUSH
49362: LD_VAR 0 1
49366: PPUSH
49367: CALL_OW 310
49371: NOT
49372: OR
49373: IFFALSE 49377
// exit ;
49375: GO 49467
// vehicle := IsInUnit ( driver ) ;
49377: LD_ADDR_VAR 0 3
49381: PUSH
49382: LD_VAR 0 1
49386: PPUSH
49387: CALL_OW 310
49391: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
49392: LD_VAR 0 1
49396: PPUSH
49397: LD_STRING \
49399: PUSH
49400: LD_INT 0
49402: PUSH
49403: LD_INT 0
49405: PUSH
49406: LD_INT 0
49408: PUSH
49409: LD_INT 0
49411: PUSH
49412: LD_INT 0
49414: PUSH
49415: LD_INT 0
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: LIST
49424: LIST
49425: LIST
49426: PUSH
49427: LD_STRING E
49429: PUSH
49430: LD_INT 0
49432: PUSH
49433: LD_INT 0
49435: PUSH
49436: LD_VAR 0 3
49440: PUSH
49441: LD_INT 0
49443: PUSH
49444: LD_INT 0
49446: PUSH
49447: LD_INT 0
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: PUSH
49459: EMPTY
49460: LIST
49461: LIST
49462: PPUSH
49463: CALL_OW 447
// end ;
49467: LD_VAR 0 2
49471: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
49472: LD_INT 0
49474: PPUSH
49475: PPUSH
49476: PPUSH
// tmp := [ ] ;
49477: LD_ADDR_VAR 0 5
49481: PUSH
49482: EMPTY
49483: ST_TO_ADDR
// for i in units do
49484: LD_ADDR_VAR 0 4
49488: PUSH
49489: LD_VAR 0 1
49493: PUSH
49494: FOR_IN
49495: IFFALSE 49533
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
49497: LD_ADDR_VAR 0 5
49501: PUSH
49502: LD_VAR 0 5
49506: PPUSH
49507: LD_VAR 0 5
49511: PUSH
49512: LD_INT 1
49514: PLUS
49515: PPUSH
49516: LD_VAR 0 4
49520: PPUSH
49521: CALL_OW 256
49525: PPUSH
49526: CALL_OW 2
49530: ST_TO_ADDR
49531: GO 49494
49533: POP
49534: POP
// if not tmp then
49535: LD_VAR 0 5
49539: NOT
49540: IFFALSE 49544
// exit ;
49542: GO 49592
// if asc then
49544: LD_VAR 0 2
49548: IFFALSE 49572
// result := SortListByListAsc ( units , tmp ) else
49550: LD_ADDR_VAR 0 3
49554: PUSH
49555: LD_VAR 0 1
49559: PPUSH
49560: LD_VAR 0 5
49564: PPUSH
49565: CALL_OW 76
49569: ST_TO_ADDR
49570: GO 49592
// result := SortListByListDesc ( units , tmp ) ;
49572: LD_ADDR_VAR 0 3
49576: PUSH
49577: LD_VAR 0 1
49581: PPUSH
49582: LD_VAR 0 5
49586: PPUSH
49587: CALL_OW 77
49591: ST_TO_ADDR
// end ;
49592: LD_VAR 0 3
49596: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
49597: LD_INT 0
49599: PPUSH
49600: PPUSH
// task := GetTaskList ( mech ) ;
49601: LD_ADDR_VAR 0 4
49605: PUSH
49606: LD_VAR 0 1
49610: PPUSH
49611: CALL_OW 437
49615: ST_TO_ADDR
// if not task then
49616: LD_VAR 0 4
49620: NOT
49621: IFFALSE 49625
// exit ;
49623: GO 49667
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
49625: LD_ADDR_VAR 0 3
49629: PUSH
49630: LD_VAR 0 4
49634: PUSH
49635: LD_INT 1
49637: ARRAY
49638: PUSH
49639: LD_INT 1
49641: ARRAY
49642: PUSH
49643: LD_STRING r
49645: EQUAL
49646: PUSH
49647: LD_VAR 0 4
49651: PUSH
49652: LD_INT 1
49654: ARRAY
49655: PUSH
49656: LD_INT 4
49658: ARRAY
49659: PUSH
49660: LD_VAR 0 2
49664: EQUAL
49665: AND
49666: ST_TO_ADDR
// end ;
49667: LD_VAR 0 3
49671: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
49672: LD_INT 0
49674: PPUSH
// SetDir ( unit , d ) ;
49675: LD_VAR 0 1
49679: PPUSH
49680: LD_VAR 0 4
49684: PPUSH
49685: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
49689: LD_VAR 0 1
49693: PPUSH
49694: LD_VAR 0 2
49698: PPUSH
49699: LD_VAR 0 3
49703: PPUSH
49704: LD_VAR 0 5
49708: PPUSH
49709: CALL_OW 48
// end ;
49713: LD_VAR 0 6
49717: RET
// export function ToNaturalNumber ( number ) ; begin
49718: LD_INT 0
49720: PPUSH
// result := number div 1 ;
49721: LD_ADDR_VAR 0 2
49725: PUSH
49726: LD_VAR 0 1
49730: PUSH
49731: LD_INT 1
49733: DIV
49734: ST_TO_ADDR
// if number < 0 then
49735: LD_VAR 0 1
49739: PUSH
49740: LD_INT 0
49742: LESS
49743: IFFALSE 49753
// result := 0 ;
49745: LD_ADDR_VAR 0 2
49749: PUSH
49750: LD_INT 0
49752: ST_TO_ADDR
// end ;
49753: LD_VAR 0 2
49757: RET
// export function SortByClass ( units , class ) ; var un ; begin
49758: LD_INT 0
49760: PPUSH
49761: PPUSH
// if not units or not class then
49762: LD_VAR 0 1
49766: NOT
49767: PUSH
49768: LD_VAR 0 2
49772: NOT
49773: OR
49774: IFFALSE 49778
// exit ;
49776: GO 49873
// result := [ ] ;
49778: LD_ADDR_VAR 0 3
49782: PUSH
49783: EMPTY
49784: ST_TO_ADDR
// for un in units do
49785: LD_ADDR_VAR 0 4
49789: PUSH
49790: LD_VAR 0 1
49794: PUSH
49795: FOR_IN
49796: IFFALSE 49871
// if GetClass ( un ) = class then
49798: LD_VAR 0 4
49802: PPUSH
49803: CALL_OW 257
49807: PUSH
49808: LD_VAR 0 2
49812: EQUAL
49813: IFFALSE 49840
// result := Insert ( result , 1 , un ) else
49815: LD_ADDR_VAR 0 3
49819: PUSH
49820: LD_VAR 0 3
49824: PPUSH
49825: LD_INT 1
49827: PPUSH
49828: LD_VAR 0 4
49832: PPUSH
49833: CALL_OW 2
49837: ST_TO_ADDR
49838: GO 49869
// result := Replace ( result , result + 1 , un ) ;
49840: LD_ADDR_VAR 0 3
49844: PUSH
49845: LD_VAR 0 3
49849: PPUSH
49850: LD_VAR 0 3
49854: PUSH
49855: LD_INT 1
49857: PLUS
49858: PPUSH
49859: LD_VAR 0 4
49863: PPUSH
49864: CALL_OW 1
49868: ST_TO_ADDR
49869: GO 49795
49871: POP
49872: POP
// end ;
49873: LD_VAR 0 3
49877: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
49878: LD_INT 0
49880: PPUSH
49881: PPUSH
49882: PPUSH
49883: PPUSH
49884: PPUSH
49885: PPUSH
49886: PPUSH
// result := [ ] ;
49887: LD_ADDR_VAR 0 4
49891: PUSH
49892: EMPTY
49893: ST_TO_ADDR
// if x - r < 0 then
49894: LD_VAR 0 1
49898: PUSH
49899: LD_VAR 0 3
49903: MINUS
49904: PUSH
49905: LD_INT 0
49907: LESS
49908: IFFALSE 49920
// min_x := 0 else
49910: LD_ADDR_VAR 0 8
49914: PUSH
49915: LD_INT 0
49917: ST_TO_ADDR
49918: GO 49936
// min_x := x - r ;
49920: LD_ADDR_VAR 0 8
49924: PUSH
49925: LD_VAR 0 1
49929: PUSH
49930: LD_VAR 0 3
49934: MINUS
49935: ST_TO_ADDR
// if y - r < 0 then
49936: LD_VAR 0 2
49940: PUSH
49941: LD_VAR 0 3
49945: MINUS
49946: PUSH
49947: LD_INT 0
49949: LESS
49950: IFFALSE 49962
// min_y := 0 else
49952: LD_ADDR_VAR 0 7
49956: PUSH
49957: LD_INT 0
49959: ST_TO_ADDR
49960: GO 49978
// min_y := y - r ;
49962: LD_ADDR_VAR 0 7
49966: PUSH
49967: LD_VAR 0 2
49971: PUSH
49972: LD_VAR 0 3
49976: MINUS
49977: ST_TO_ADDR
// max_x := x + r ;
49978: LD_ADDR_VAR 0 9
49982: PUSH
49983: LD_VAR 0 1
49987: PUSH
49988: LD_VAR 0 3
49992: PLUS
49993: ST_TO_ADDR
// max_y := y + r ;
49994: LD_ADDR_VAR 0 10
49998: PUSH
49999: LD_VAR 0 2
50003: PUSH
50004: LD_VAR 0 3
50008: PLUS
50009: ST_TO_ADDR
// for _x = min_x to max_x do
50010: LD_ADDR_VAR 0 5
50014: PUSH
50015: DOUBLE
50016: LD_VAR 0 8
50020: DEC
50021: ST_TO_ADDR
50022: LD_VAR 0 9
50026: PUSH
50027: FOR_TO
50028: IFFALSE 50129
// for _y = min_y to max_y do
50030: LD_ADDR_VAR 0 6
50034: PUSH
50035: DOUBLE
50036: LD_VAR 0 7
50040: DEC
50041: ST_TO_ADDR
50042: LD_VAR 0 10
50046: PUSH
50047: FOR_TO
50048: IFFALSE 50125
// begin if not ValidHex ( _x , _y ) then
50050: LD_VAR 0 5
50054: PPUSH
50055: LD_VAR 0 6
50059: PPUSH
50060: CALL_OW 488
50064: NOT
50065: IFFALSE 50069
// continue ;
50067: GO 50047
// if GetResourceTypeXY ( _x , _y ) then
50069: LD_VAR 0 5
50073: PPUSH
50074: LD_VAR 0 6
50078: PPUSH
50079: CALL_OW 283
50083: IFFALSE 50123
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
50085: LD_ADDR_VAR 0 4
50089: PUSH
50090: LD_VAR 0 4
50094: PPUSH
50095: LD_VAR 0 4
50099: PUSH
50100: LD_INT 1
50102: PLUS
50103: PPUSH
50104: LD_VAR 0 5
50108: PUSH
50109: LD_VAR 0 6
50113: PUSH
50114: EMPTY
50115: LIST
50116: LIST
50117: PPUSH
50118: CALL_OW 1
50122: ST_TO_ADDR
// end ;
50123: GO 50047
50125: POP
50126: POP
50127: GO 50027
50129: POP
50130: POP
// end ;
50131: LD_VAR 0 4
50135: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
50136: LD_INT 0
50138: PPUSH
50139: PPUSH
50140: PPUSH
50141: PPUSH
50142: PPUSH
50143: PPUSH
// if not units then
50144: LD_VAR 0 1
50148: NOT
50149: IFFALSE 50153
// exit ;
50151: GO 50554
// result := UnitFilter ( units , [ f_ok ] ) ;
50153: LD_ADDR_VAR 0 3
50157: PUSH
50158: LD_VAR 0 1
50162: PPUSH
50163: LD_INT 50
50165: PUSH
50166: EMPTY
50167: LIST
50168: PPUSH
50169: CALL_OW 72
50173: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
50174: LD_ADDR_VAR 0 7
50178: PUSH
50179: LD_VAR 0 1
50183: PUSH
50184: LD_INT 1
50186: ARRAY
50187: PPUSH
50188: CALL_OW 255
50192: ST_TO_ADDR
// if not result then
50193: LD_VAR 0 3
50197: NOT
50198: IFFALSE 50202
// exit ;
50200: GO 50554
// for i in result do
50202: LD_ADDR_VAR 0 4
50206: PUSH
50207: LD_VAR 0 3
50211: PUSH
50212: FOR_IN
50213: IFFALSE 50552
// begin tag := GetTag ( i ) + 1 ;
50215: LD_ADDR_VAR 0 8
50219: PUSH
50220: LD_VAR 0 4
50224: PPUSH
50225: CALL_OW 110
50229: PUSH
50230: LD_INT 1
50232: PLUS
50233: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
50234: LD_ADDR_VAR 0 6
50238: PUSH
50239: LD_VAR 0 4
50243: PPUSH
50244: CALL_OW 250
50248: PPUSH
50249: LD_VAR 0 4
50253: PPUSH
50254: CALL_OW 251
50258: PPUSH
50259: LD_INT 6
50261: PPUSH
50262: CALL 49878 0 3
50266: ST_TO_ADDR
// if cr then
50267: LD_VAR 0 6
50271: IFFALSE 50310
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
50273: LD_VAR 0 4
50277: PPUSH
50278: LD_VAR 0 6
50282: PUSH
50283: LD_INT 1
50285: ARRAY
50286: PUSH
50287: LD_INT 1
50289: ARRAY
50290: PPUSH
50291: LD_VAR 0 6
50295: PUSH
50296: LD_INT 1
50298: ARRAY
50299: PUSH
50300: LD_INT 2
50302: ARRAY
50303: PPUSH
50304: CALL_OW 116
50308: GO 50550
// if path > tag then
50310: LD_VAR 0 2
50314: PUSH
50315: LD_VAR 0 8
50319: GREATER
50320: IFFALSE 50498
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
50322: LD_ADDR_VAR 0 5
50326: PUSH
50327: LD_INT 81
50329: PUSH
50330: LD_VAR 0 7
50334: PUSH
50335: EMPTY
50336: LIST
50337: LIST
50338: PUSH
50339: LD_INT 91
50341: PUSH
50342: LD_VAR 0 4
50346: PUSH
50347: LD_INT 12
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: LIST
50354: PUSH
50355: EMPTY
50356: LIST
50357: LIST
50358: PPUSH
50359: CALL_OW 69
50363: ST_TO_ADDR
// if enemy then
50364: LD_VAR 0 5
50368: IFFALSE 50396
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
50370: LD_VAR 0 4
50374: PPUSH
50375: LD_VAR 0 5
50379: PPUSH
50380: LD_VAR 0 4
50384: PPUSH
50385: CALL_OW 74
50389: PPUSH
50390: CALL_OW 115
50394: GO 50496
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
50396: LD_VAR 0 4
50400: PPUSH
50401: LD_VAR 0 2
50405: PUSH
50406: LD_VAR 0 8
50410: ARRAY
50411: PUSH
50412: LD_INT 1
50414: ARRAY
50415: PPUSH
50416: LD_VAR 0 2
50420: PUSH
50421: LD_VAR 0 8
50425: ARRAY
50426: PUSH
50427: LD_INT 2
50429: ARRAY
50430: PPUSH
50431: CALL_OW 297
50435: PUSH
50436: LD_INT 6
50438: GREATER
50439: IFFALSE 50482
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
50441: LD_VAR 0 4
50445: PPUSH
50446: LD_VAR 0 2
50450: PUSH
50451: LD_VAR 0 8
50455: ARRAY
50456: PUSH
50457: LD_INT 1
50459: ARRAY
50460: PPUSH
50461: LD_VAR 0 2
50465: PUSH
50466: LD_VAR 0 8
50470: ARRAY
50471: PUSH
50472: LD_INT 2
50474: ARRAY
50475: PPUSH
50476: CALL_OW 114
50480: GO 50496
// SetTag ( i , tag ) ;
50482: LD_VAR 0 4
50486: PPUSH
50487: LD_VAR 0 8
50491: PPUSH
50492: CALL_OW 109
// end else
50496: GO 50550
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
50498: LD_ADDR_VAR 0 5
50502: PUSH
50503: LD_INT 81
50505: PUSH
50506: LD_VAR 0 7
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PPUSH
50515: CALL_OW 69
50519: ST_TO_ADDR
// if enemy then
50520: LD_VAR 0 5
50524: IFFALSE 50550
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
50526: LD_VAR 0 4
50530: PPUSH
50531: LD_VAR 0 5
50535: PPUSH
50536: LD_VAR 0 4
50540: PPUSH
50541: CALL_OW 74
50545: PPUSH
50546: CALL_OW 115
// end ; end ;
50550: GO 50212
50552: POP
50553: POP
// end ; end_of_file
50554: LD_VAR 0 3
50558: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
50559: LD_INT 0
50561: PPUSH
50562: PPUSH
// skirmish := false ;
50563: LD_ADDR_EXP 21
50567: PUSH
50568: LD_INT 0
50570: ST_TO_ADDR
// debug_mc := false ;
50571: LD_ADDR_EXP 22
50575: PUSH
50576: LD_INT 0
50578: ST_TO_ADDR
// mc_bases := [ ] ;
50579: LD_ADDR_EXP 23
50583: PUSH
50584: EMPTY
50585: ST_TO_ADDR
// mc_sides := [ ] ;
50586: LD_ADDR_EXP 49
50590: PUSH
50591: EMPTY
50592: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50593: LD_ADDR_EXP 24
50597: PUSH
50598: EMPTY
50599: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50600: LD_ADDR_EXP 25
50604: PUSH
50605: EMPTY
50606: ST_TO_ADDR
// mc_need_heal := [ ] ;
50607: LD_ADDR_EXP 26
50611: PUSH
50612: EMPTY
50613: ST_TO_ADDR
// mc_healers := [ ] ;
50614: LD_ADDR_EXP 27
50618: PUSH
50619: EMPTY
50620: ST_TO_ADDR
// mc_build_list := [ ] ;
50621: LD_ADDR_EXP 28
50625: PUSH
50626: EMPTY
50627: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50628: LD_ADDR_EXP 55
50632: PUSH
50633: EMPTY
50634: ST_TO_ADDR
// mc_builders := [ ] ;
50635: LD_ADDR_EXP 29
50639: PUSH
50640: EMPTY
50641: ST_TO_ADDR
// mc_construct_list := [ ] ;
50642: LD_ADDR_EXP 30
50646: PUSH
50647: EMPTY
50648: ST_TO_ADDR
// mc_turret_list := [ ] ;
50649: LD_ADDR_EXP 31
50653: PUSH
50654: EMPTY
50655: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50656: LD_ADDR_EXP 32
50660: PUSH
50661: EMPTY
50662: ST_TO_ADDR
// mc_miners := [ ] ;
50663: LD_ADDR_EXP 37
50667: PUSH
50668: EMPTY
50669: ST_TO_ADDR
// mc_mines := [ ] ;
50670: LD_ADDR_EXP 36
50674: PUSH
50675: EMPTY
50676: ST_TO_ADDR
// mc_minefields := [ ] ;
50677: LD_ADDR_EXP 38
50681: PUSH
50682: EMPTY
50683: ST_TO_ADDR
// mc_crates := [ ] ;
50684: LD_ADDR_EXP 39
50688: PUSH
50689: EMPTY
50690: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50691: LD_ADDR_EXP 40
50695: PUSH
50696: EMPTY
50697: ST_TO_ADDR
// mc_crates_area := [ ] ;
50698: LD_ADDR_EXP 41
50702: PUSH
50703: EMPTY
50704: ST_TO_ADDR
// mc_vehicles := [ ] ;
50705: LD_ADDR_EXP 42
50709: PUSH
50710: EMPTY
50711: ST_TO_ADDR
// mc_attack := [ ] ;
50712: LD_ADDR_EXP 43
50716: PUSH
50717: EMPTY
50718: ST_TO_ADDR
// mc_produce := [ ] ;
50719: LD_ADDR_EXP 44
50723: PUSH
50724: EMPTY
50725: ST_TO_ADDR
// mc_defender := [ ] ;
50726: LD_ADDR_EXP 45
50730: PUSH
50731: EMPTY
50732: ST_TO_ADDR
// mc_parking := [ ] ;
50733: LD_ADDR_EXP 47
50737: PUSH
50738: EMPTY
50739: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50740: LD_ADDR_EXP 33
50744: PUSH
50745: EMPTY
50746: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50747: LD_ADDR_EXP 35
50751: PUSH
50752: EMPTY
50753: ST_TO_ADDR
// mc_scan := [ ] ;
50754: LD_ADDR_EXP 46
50758: PUSH
50759: EMPTY
50760: ST_TO_ADDR
// mc_scan_area := [ ] ;
50761: LD_ADDR_EXP 48
50765: PUSH
50766: EMPTY
50767: ST_TO_ADDR
// mc_tech := [ ] ;
50768: LD_ADDR_EXP 50
50772: PUSH
50773: EMPTY
50774: ST_TO_ADDR
// mc_class := [ ] ;
50775: LD_ADDR_EXP 64
50779: PUSH
50780: EMPTY
50781: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50782: LD_ADDR_EXP 65
50786: PUSH
50787: EMPTY
50788: ST_TO_ADDR
// mc_is_defending := [ ] ;
50789: LD_ADDR_EXP 66
50793: PUSH
50794: EMPTY
50795: ST_TO_ADDR
// end ;
50796: LD_VAR 0 1
50800: RET
// export function MC_Kill ( base ) ; begin
50801: LD_INT 0
50803: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50804: LD_ADDR_EXP 23
50808: PUSH
50809: LD_EXP 23
50813: PPUSH
50814: LD_VAR 0 1
50818: PPUSH
50819: EMPTY
50820: PPUSH
50821: CALL_OW 1
50825: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50826: LD_ADDR_EXP 24
50830: PUSH
50831: LD_EXP 24
50835: PPUSH
50836: LD_VAR 0 1
50840: PPUSH
50841: EMPTY
50842: PPUSH
50843: CALL_OW 1
50847: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50848: LD_ADDR_EXP 25
50852: PUSH
50853: LD_EXP 25
50857: PPUSH
50858: LD_VAR 0 1
50862: PPUSH
50863: EMPTY
50864: PPUSH
50865: CALL_OW 1
50869: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50870: LD_ADDR_EXP 26
50874: PUSH
50875: LD_EXP 26
50879: PPUSH
50880: LD_VAR 0 1
50884: PPUSH
50885: EMPTY
50886: PPUSH
50887: CALL_OW 1
50891: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50892: LD_ADDR_EXP 27
50896: PUSH
50897: LD_EXP 27
50901: PPUSH
50902: LD_VAR 0 1
50906: PPUSH
50907: EMPTY
50908: PPUSH
50909: CALL_OW 1
50913: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50914: LD_ADDR_EXP 28
50918: PUSH
50919: LD_EXP 28
50923: PPUSH
50924: LD_VAR 0 1
50928: PPUSH
50929: EMPTY
50930: PPUSH
50931: CALL_OW 1
50935: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50936: LD_ADDR_EXP 29
50940: PUSH
50941: LD_EXP 29
50945: PPUSH
50946: LD_VAR 0 1
50950: PPUSH
50951: EMPTY
50952: PPUSH
50953: CALL_OW 1
50957: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50958: LD_ADDR_EXP 30
50962: PUSH
50963: LD_EXP 30
50967: PPUSH
50968: LD_VAR 0 1
50972: PPUSH
50973: EMPTY
50974: PPUSH
50975: CALL_OW 1
50979: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50980: LD_ADDR_EXP 31
50984: PUSH
50985: LD_EXP 31
50989: PPUSH
50990: LD_VAR 0 1
50994: PPUSH
50995: EMPTY
50996: PPUSH
50997: CALL_OW 1
51001: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51002: LD_ADDR_EXP 32
51006: PUSH
51007: LD_EXP 32
51011: PPUSH
51012: LD_VAR 0 1
51016: PPUSH
51017: EMPTY
51018: PPUSH
51019: CALL_OW 1
51023: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51024: LD_ADDR_EXP 33
51028: PUSH
51029: LD_EXP 33
51033: PPUSH
51034: LD_VAR 0 1
51038: PPUSH
51039: EMPTY
51040: PPUSH
51041: CALL_OW 1
51045: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51046: LD_ADDR_EXP 34
51050: PUSH
51051: LD_EXP 34
51055: PPUSH
51056: LD_VAR 0 1
51060: PPUSH
51061: LD_INT 0
51063: PPUSH
51064: CALL_OW 1
51068: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51069: LD_ADDR_EXP 35
51073: PUSH
51074: LD_EXP 35
51078: PPUSH
51079: LD_VAR 0 1
51083: PPUSH
51084: EMPTY
51085: PPUSH
51086: CALL_OW 1
51090: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51091: LD_ADDR_EXP 36
51095: PUSH
51096: LD_EXP 36
51100: PPUSH
51101: LD_VAR 0 1
51105: PPUSH
51106: EMPTY
51107: PPUSH
51108: CALL_OW 1
51112: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51113: LD_ADDR_EXP 37
51117: PUSH
51118: LD_EXP 37
51122: PPUSH
51123: LD_VAR 0 1
51127: PPUSH
51128: EMPTY
51129: PPUSH
51130: CALL_OW 1
51134: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51135: LD_ADDR_EXP 38
51139: PUSH
51140: LD_EXP 38
51144: PPUSH
51145: LD_VAR 0 1
51149: PPUSH
51150: EMPTY
51151: PPUSH
51152: CALL_OW 1
51156: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51157: LD_ADDR_EXP 39
51161: PUSH
51162: LD_EXP 39
51166: PPUSH
51167: LD_VAR 0 1
51171: PPUSH
51172: EMPTY
51173: PPUSH
51174: CALL_OW 1
51178: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51179: LD_ADDR_EXP 40
51183: PUSH
51184: LD_EXP 40
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: EMPTY
51195: PPUSH
51196: CALL_OW 1
51200: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51201: LD_ADDR_EXP 41
51205: PUSH
51206: LD_EXP 41
51210: PPUSH
51211: LD_VAR 0 1
51215: PPUSH
51216: EMPTY
51217: PPUSH
51218: CALL_OW 1
51222: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51223: LD_ADDR_EXP 42
51227: PUSH
51228: LD_EXP 42
51232: PPUSH
51233: LD_VAR 0 1
51237: PPUSH
51238: EMPTY
51239: PPUSH
51240: CALL_OW 1
51244: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51245: LD_ADDR_EXP 43
51249: PUSH
51250: LD_EXP 43
51254: PPUSH
51255: LD_VAR 0 1
51259: PPUSH
51260: EMPTY
51261: PPUSH
51262: CALL_OW 1
51266: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51267: LD_ADDR_EXP 44
51271: PUSH
51272: LD_EXP 44
51276: PPUSH
51277: LD_VAR 0 1
51281: PPUSH
51282: EMPTY
51283: PPUSH
51284: CALL_OW 1
51288: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51289: LD_ADDR_EXP 45
51293: PUSH
51294: LD_EXP 45
51298: PPUSH
51299: LD_VAR 0 1
51303: PPUSH
51304: EMPTY
51305: PPUSH
51306: CALL_OW 1
51310: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51311: LD_ADDR_EXP 46
51315: PUSH
51316: LD_EXP 46
51320: PPUSH
51321: LD_VAR 0 1
51325: PPUSH
51326: EMPTY
51327: PPUSH
51328: CALL_OW 1
51332: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51333: LD_ADDR_EXP 47
51337: PUSH
51338: LD_EXP 47
51342: PPUSH
51343: LD_VAR 0 1
51347: PPUSH
51348: EMPTY
51349: PPUSH
51350: CALL_OW 1
51354: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51355: LD_ADDR_EXP 48
51359: PUSH
51360: LD_EXP 48
51364: PPUSH
51365: LD_VAR 0 1
51369: PPUSH
51370: EMPTY
51371: PPUSH
51372: CALL_OW 1
51376: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51377: LD_ADDR_EXP 50
51381: PUSH
51382: LD_EXP 50
51386: PPUSH
51387: LD_VAR 0 1
51391: PPUSH
51392: EMPTY
51393: PPUSH
51394: CALL_OW 1
51398: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51399: LD_ADDR_EXP 52
51403: PUSH
51404: LD_EXP 52
51408: PPUSH
51409: LD_VAR 0 1
51413: PPUSH
51414: EMPTY
51415: PPUSH
51416: CALL_OW 1
51420: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51421: LD_ADDR_EXP 53
51425: PUSH
51426: LD_EXP 53
51430: PPUSH
51431: LD_VAR 0 1
51435: PPUSH
51436: EMPTY
51437: PPUSH
51438: CALL_OW 1
51442: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51443: LD_ADDR_EXP 54
51447: PUSH
51448: LD_EXP 54
51452: PPUSH
51453: LD_VAR 0 1
51457: PPUSH
51458: EMPTY
51459: PPUSH
51460: CALL_OW 1
51464: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51465: LD_ADDR_EXP 55
51469: PUSH
51470: LD_EXP 55
51474: PPUSH
51475: LD_VAR 0 1
51479: PPUSH
51480: EMPTY
51481: PPUSH
51482: CALL_OW 1
51486: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51487: LD_ADDR_EXP 56
51491: PUSH
51492: LD_EXP 56
51496: PPUSH
51497: LD_VAR 0 1
51501: PPUSH
51502: EMPTY
51503: PPUSH
51504: CALL_OW 1
51508: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51509: LD_ADDR_EXP 57
51513: PUSH
51514: LD_EXP 57
51518: PPUSH
51519: LD_VAR 0 1
51523: PPUSH
51524: EMPTY
51525: PPUSH
51526: CALL_OW 1
51530: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51531: LD_ADDR_EXP 58
51535: PUSH
51536: LD_EXP 58
51540: PPUSH
51541: LD_VAR 0 1
51545: PPUSH
51546: EMPTY
51547: PPUSH
51548: CALL_OW 1
51552: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51553: LD_ADDR_EXP 59
51557: PUSH
51558: LD_EXP 59
51562: PPUSH
51563: LD_VAR 0 1
51567: PPUSH
51568: EMPTY
51569: PPUSH
51570: CALL_OW 1
51574: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51575: LD_ADDR_EXP 60
51579: PUSH
51580: LD_EXP 60
51584: PPUSH
51585: LD_VAR 0 1
51589: PPUSH
51590: EMPTY
51591: PPUSH
51592: CALL_OW 1
51596: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51597: LD_ADDR_EXP 61
51601: PUSH
51602: LD_EXP 61
51606: PPUSH
51607: LD_VAR 0 1
51611: PPUSH
51612: EMPTY
51613: PPUSH
51614: CALL_OW 1
51618: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51619: LD_ADDR_EXP 62
51623: PUSH
51624: LD_EXP 62
51628: PPUSH
51629: LD_VAR 0 1
51633: PPUSH
51634: EMPTY
51635: PPUSH
51636: CALL_OW 1
51640: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51641: LD_ADDR_EXP 63
51645: PUSH
51646: LD_EXP 63
51650: PPUSH
51651: LD_VAR 0 1
51655: PPUSH
51656: EMPTY
51657: PPUSH
51658: CALL_OW 1
51662: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51663: LD_ADDR_EXP 64
51667: PUSH
51668: LD_EXP 64
51672: PPUSH
51673: LD_VAR 0 1
51677: PPUSH
51678: EMPTY
51679: PPUSH
51680: CALL_OW 1
51684: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51685: LD_ADDR_EXP 65
51689: PUSH
51690: LD_EXP 65
51694: PPUSH
51695: LD_VAR 0 1
51699: PPUSH
51700: LD_INT 0
51702: PPUSH
51703: CALL_OW 1
51707: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
51708: LD_ADDR_EXP 66
51712: PUSH
51713: LD_EXP 66
51717: PPUSH
51718: LD_VAR 0 1
51722: PPUSH
51723: LD_INT 0
51725: PPUSH
51726: CALL_OW 1
51730: ST_TO_ADDR
// end ;
51731: LD_VAR 0 2
51735: RET
// export function MC_Add ( side , units ) ; var base ; begin
51736: LD_INT 0
51738: PPUSH
51739: PPUSH
// base := mc_bases + 1 ;
51740: LD_ADDR_VAR 0 4
51744: PUSH
51745: LD_EXP 23
51749: PUSH
51750: LD_INT 1
51752: PLUS
51753: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51754: LD_ADDR_EXP 49
51758: PUSH
51759: LD_EXP 49
51763: PPUSH
51764: LD_VAR 0 4
51768: PPUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: CALL_OW 1
51778: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51779: LD_ADDR_EXP 23
51783: PUSH
51784: LD_EXP 23
51788: PPUSH
51789: LD_VAR 0 4
51793: PPUSH
51794: LD_VAR 0 2
51798: PPUSH
51799: CALL_OW 1
51803: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51804: LD_ADDR_EXP 24
51808: PUSH
51809: LD_EXP 24
51813: PPUSH
51814: LD_VAR 0 4
51818: PPUSH
51819: EMPTY
51820: PPUSH
51821: CALL_OW 1
51825: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51826: LD_ADDR_EXP 25
51830: PUSH
51831: LD_EXP 25
51835: PPUSH
51836: LD_VAR 0 4
51840: PPUSH
51841: EMPTY
51842: PPUSH
51843: CALL_OW 1
51847: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51848: LD_ADDR_EXP 26
51852: PUSH
51853: LD_EXP 26
51857: PPUSH
51858: LD_VAR 0 4
51862: PPUSH
51863: EMPTY
51864: PPUSH
51865: CALL_OW 1
51869: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51870: LD_ADDR_EXP 27
51874: PUSH
51875: LD_EXP 27
51879: PPUSH
51880: LD_VAR 0 4
51884: PPUSH
51885: EMPTY
51886: PPUSH
51887: CALL_OW 1
51891: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51892: LD_ADDR_EXP 28
51896: PUSH
51897: LD_EXP 28
51901: PPUSH
51902: LD_VAR 0 4
51906: PPUSH
51907: EMPTY
51908: PPUSH
51909: CALL_OW 1
51913: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51914: LD_ADDR_EXP 29
51918: PUSH
51919: LD_EXP 29
51923: PPUSH
51924: LD_VAR 0 4
51928: PPUSH
51929: EMPTY
51930: PPUSH
51931: CALL_OW 1
51935: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51936: LD_ADDR_EXP 30
51940: PUSH
51941: LD_EXP 30
51945: PPUSH
51946: LD_VAR 0 4
51950: PPUSH
51951: EMPTY
51952: PPUSH
51953: CALL_OW 1
51957: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51958: LD_ADDR_EXP 31
51962: PUSH
51963: LD_EXP 31
51967: PPUSH
51968: LD_VAR 0 4
51972: PPUSH
51973: EMPTY
51974: PPUSH
51975: CALL_OW 1
51979: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51980: LD_ADDR_EXP 32
51984: PUSH
51985: LD_EXP 32
51989: PPUSH
51990: LD_VAR 0 4
51994: PPUSH
51995: EMPTY
51996: PPUSH
51997: CALL_OW 1
52001: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52002: LD_ADDR_EXP 33
52006: PUSH
52007: LD_EXP 33
52011: PPUSH
52012: LD_VAR 0 4
52016: PPUSH
52017: EMPTY
52018: PPUSH
52019: CALL_OW 1
52023: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52024: LD_ADDR_EXP 34
52028: PUSH
52029: LD_EXP 34
52033: PPUSH
52034: LD_VAR 0 4
52038: PPUSH
52039: LD_INT 0
52041: PPUSH
52042: CALL_OW 1
52046: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52047: LD_ADDR_EXP 35
52051: PUSH
52052: LD_EXP 35
52056: PPUSH
52057: LD_VAR 0 4
52061: PPUSH
52062: EMPTY
52063: PPUSH
52064: CALL_OW 1
52068: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52069: LD_ADDR_EXP 36
52073: PUSH
52074: LD_EXP 36
52078: PPUSH
52079: LD_VAR 0 4
52083: PPUSH
52084: EMPTY
52085: PPUSH
52086: CALL_OW 1
52090: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52091: LD_ADDR_EXP 37
52095: PUSH
52096: LD_EXP 37
52100: PPUSH
52101: LD_VAR 0 4
52105: PPUSH
52106: EMPTY
52107: PPUSH
52108: CALL_OW 1
52112: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52113: LD_ADDR_EXP 38
52117: PUSH
52118: LD_EXP 38
52122: PPUSH
52123: LD_VAR 0 4
52127: PPUSH
52128: EMPTY
52129: PPUSH
52130: CALL_OW 1
52134: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52135: LD_ADDR_EXP 39
52139: PUSH
52140: LD_EXP 39
52144: PPUSH
52145: LD_VAR 0 4
52149: PPUSH
52150: EMPTY
52151: PPUSH
52152: CALL_OW 1
52156: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52157: LD_ADDR_EXP 40
52161: PUSH
52162: LD_EXP 40
52166: PPUSH
52167: LD_VAR 0 4
52171: PPUSH
52172: EMPTY
52173: PPUSH
52174: CALL_OW 1
52178: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52179: LD_ADDR_EXP 41
52183: PUSH
52184: LD_EXP 41
52188: PPUSH
52189: LD_VAR 0 4
52193: PPUSH
52194: EMPTY
52195: PPUSH
52196: CALL_OW 1
52200: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52201: LD_ADDR_EXP 42
52205: PUSH
52206: LD_EXP 42
52210: PPUSH
52211: LD_VAR 0 4
52215: PPUSH
52216: EMPTY
52217: PPUSH
52218: CALL_OW 1
52222: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52223: LD_ADDR_EXP 43
52227: PUSH
52228: LD_EXP 43
52232: PPUSH
52233: LD_VAR 0 4
52237: PPUSH
52238: EMPTY
52239: PPUSH
52240: CALL_OW 1
52244: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52245: LD_ADDR_EXP 44
52249: PUSH
52250: LD_EXP 44
52254: PPUSH
52255: LD_VAR 0 4
52259: PPUSH
52260: EMPTY
52261: PPUSH
52262: CALL_OW 1
52266: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52267: LD_ADDR_EXP 45
52271: PUSH
52272: LD_EXP 45
52276: PPUSH
52277: LD_VAR 0 4
52281: PPUSH
52282: EMPTY
52283: PPUSH
52284: CALL_OW 1
52288: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52289: LD_ADDR_EXP 46
52293: PUSH
52294: LD_EXP 46
52298: PPUSH
52299: LD_VAR 0 4
52303: PPUSH
52304: EMPTY
52305: PPUSH
52306: CALL_OW 1
52310: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52311: LD_ADDR_EXP 47
52315: PUSH
52316: LD_EXP 47
52320: PPUSH
52321: LD_VAR 0 4
52325: PPUSH
52326: EMPTY
52327: PPUSH
52328: CALL_OW 1
52332: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52333: LD_ADDR_EXP 48
52337: PUSH
52338: LD_EXP 48
52342: PPUSH
52343: LD_VAR 0 4
52347: PPUSH
52348: EMPTY
52349: PPUSH
52350: CALL_OW 1
52354: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52355: LD_ADDR_EXP 50
52359: PUSH
52360: LD_EXP 50
52364: PPUSH
52365: LD_VAR 0 4
52369: PPUSH
52370: EMPTY
52371: PPUSH
52372: CALL_OW 1
52376: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52377: LD_ADDR_EXP 52
52381: PUSH
52382: LD_EXP 52
52386: PPUSH
52387: LD_VAR 0 4
52391: PPUSH
52392: EMPTY
52393: PPUSH
52394: CALL_OW 1
52398: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52399: LD_ADDR_EXP 53
52403: PUSH
52404: LD_EXP 53
52408: PPUSH
52409: LD_VAR 0 4
52413: PPUSH
52414: EMPTY
52415: PPUSH
52416: CALL_OW 1
52420: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52421: LD_ADDR_EXP 54
52425: PUSH
52426: LD_EXP 54
52430: PPUSH
52431: LD_VAR 0 4
52435: PPUSH
52436: EMPTY
52437: PPUSH
52438: CALL_OW 1
52442: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52443: LD_ADDR_EXP 55
52447: PUSH
52448: LD_EXP 55
52452: PPUSH
52453: LD_VAR 0 4
52457: PPUSH
52458: EMPTY
52459: PPUSH
52460: CALL_OW 1
52464: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52465: LD_ADDR_EXP 56
52469: PUSH
52470: LD_EXP 56
52474: PPUSH
52475: LD_VAR 0 4
52479: PPUSH
52480: EMPTY
52481: PPUSH
52482: CALL_OW 1
52486: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52487: LD_ADDR_EXP 57
52491: PUSH
52492: LD_EXP 57
52496: PPUSH
52497: LD_VAR 0 4
52501: PPUSH
52502: EMPTY
52503: PPUSH
52504: CALL_OW 1
52508: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52509: LD_ADDR_EXP 58
52513: PUSH
52514: LD_EXP 58
52518: PPUSH
52519: LD_VAR 0 4
52523: PPUSH
52524: EMPTY
52525: PPUSH
52526: CALL_OW 1
52530: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52531: LD_ADDR_EXP 59
52535: PUSH
52536: LD_EXP 59
52540: PPUSH
52541: LD_VAR 0 4
52545: PPUSH
52546: EMPTY
52547: PPUSH
52548: CALL_OW 1
52552: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52553: LD_ADDR_EXP 60
52557: PUSH
52558: LD_EXP 60
52562: PPUSH
52563: LD_VAR 0 4
52567: PPUSH
52568: EMPTY
52569: PPUSH
52570: CALL_OW 1
52574: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52575: LD_ADDR_EXP 61
52579: PUSH
52580: LD_EXP 61
52584: PPUSH
52585: LD_VAR 0 4
52589: PPUSH
52590: EMPTY
52591: PPUSH
52592: CALL_OW 1
52596: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52597: LD_ADDR_EXP 62
52601: PUSH
52602: LD_EXP 62
52606: PPUSH
52607: LD_VAR 0 4
52611: PPUSH
52612: EMPTY
52613: PPUSH
52614: CALL_OW 1
52618: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52619: LD_ADDR_EXP 63
52623: PUSH
52624: LD_EXP 63
52628: PPUSH
52629: LD_VAR 0 4
52633: PPUSH
52634: EMPTY
52635: PPUSH
52636: CALL_OW 1
52640: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52641: LD_ADDR_EXP 64
52645: PUSH
52646: LD_EXP 64
52650: PPUSH
52651: LD_VAR 0 4
52655: PPUSH
52656: EMPTY
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52663: LD_ADDR_EXP 65
52667: PUSH
52668: LD_EXP 65
52672: PPUSH
52673: LD_VAR 0 4
52677: PPUSH
52678: LD_INT 0
52680: PPUSH
52681: CALL_OW 1
52685: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
52686: LD_ADDR_EXP 66
52690: PUSH
52691: LD_EXP 66
52695: PPUSH
52696: LD_VAR 0 4
52700: PPUSH
52701: LD_INT 0
52703: PPUSH
52704: CALL_OW 1
52708: ST_TO_ADDR
// result := base ;
52709: LD_ADDR_VAR 0 3
52713: PUSH
52714: LD_VAR 0 4
52718: ST_TO_ADDR
// end ;
52719: LD_VAR 0 3
52723: RET
// export function MC_Start ( ) ; var i ; begin
52724: LD_INT 0
52726: PPUSH
52727: PPUSH
// for i = 1 to mc_bases do
52728: LD_ADDR_VAR 0 2
52732: PUSH
52733: DOUBLE
52734: LD_INT 1
52736: DEC
52737: ST_TO_ADDR
52738: LD_EXP 23
52742: PUSH
52743: FOR_TO
52744: IFFALSE 53844
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52746: LD_ADDR_EXP 23
52750: PUSH
52751: LD_EXP 23
52755: PPUSH
52756: LD_VAR 0 2
52760: PPUSH
52761: LD_EXP 23
52765: PUSH
52766: LD_VAR 0 2
52770: ARRAY
52771: PUSH
52772: LD_INT 0
52774: DIFF
52775: PPUSH
52776: CALL_OW 1
52780: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52781: LD_ADDR_EXP 24
52785: PUSH
52786: LD_EXP 24
52790: PPUSH
52791: LD_VAR 0 2
52795: PPUSH
52796: EMPTY
52797: PPUSH
52798: CALL_OW 1
52802: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52803: LD_ADDR_EXP 25
52807: PUSH
52808: LD_EXP 25
52812: PPUSH
52813: LD_VAR 0 2
52817: PPUSH
52818: EMPTY
52819: PPUSH
52820: CALL_OW 1
52824: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52825: LD_ADDR_EXP 26
52829: PUSH
52830: LD_EXP 26
52834: PPUSH
52835: LD_VAR 0 2
52839: PPUSH
52840: EMPTY
52841: PPUSH
52842: CALL_OW 1
52846: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52847: LD_ADDR_EXP 27
52851: PUSH
52852: LD_EXP 27
52856: PPUSH
52857: LD_VAR 0 2
52861: PPUSH
52862: EMPTY
52863: PUSH
52864: EMPTY
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: PPUSH
52870: CALL_OW 1
52874: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52875: LD_ADDR_EXP 28
52879: PUSH
52880: LD_EXP 28
52884: PPUSH
52885: LD_VAR 0 2
52889: PPUSH
52890: EMPTY
52891: PPUSH
52892: CALL_OW 1
52896: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52897: LD_ADDR_EXP 55
52901: PUSH
52902: LD_EXP 55
52906: PPUSH
52907: LD_VAR 0 2
52911: PPUSH
52912: EMPTY
52913: PPUSH
52914: CALL_OW 1
52918: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52919: LD_ADDR_EXP 29
52923: PUSH
52924: LD_EXP 29
52928: PPUSH
52929: LD_VAR 0 2
52933: PPUSH
52934: EMPTY
52935: PPUSH
52936: CALL_OW 1
52940: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52941: LD_ADDR_EXP 30
52945: PUSH
52946: LD_EXP 30
52950: PPUSH
52951: LD_VAR 0 2
52955: PPUSH
52956: EMPTY
52957: PPUSH
52958: CALL_OW 1
52962: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52963: LD_ADDR_EXP 31
52967: PUSH
52968: LD_EXP 31
52972: PPUSH
52973: LD_VAR 0 2
52977: PPUSH
52978: LD_EXP 23
52982: PUSH
52983: LD_VAR 0 2
52987: ARRAY
52988: PPUSH
52989: LD_INT 2
52991: PUSH
52992: LD_INT 30
52994: PUSH
52995: LD_INT 32
52997: PUSH
52998: EMPTY
52999: LIST
53000: LIST
53001: PUSH
53002: LD_INT 30
53004: PUSH
53005: LD_INT 33
53007: PUSH
53008: EMPTY
53009: LIST
53010: LIST
53011: PUSH
53012: EMPTY
53013: LIST
53014: LIST
53015: LIST
53016: PPUSH
53017: CALL_OW 72
53021: PPUSH
53022: CALL_OW 1
53026: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53027: LD_ADDR_EXP 32
53031: PUSH
53032: LD_EXP 32
53036: PPUSH
53037: LD_VAR 0 2
53041: PPUSH
53042: LD_EXP 23
53046: PUSH
53047: LD_VAR 0 2
53051: ARRAY
53052: PPUSH
53053: LD_INT 2
53055: PUSH
53056: LD_INT 30
53058: PUSH
53059: LD_INT 32
53061: PUSH
53062: EMPTY
53063: LIST
53064: LIST
53065: PUSH
53066: LD_INT 30
53068: PUSH
53069: LD_INT 31
53071: PUSH
53072: EMPTY
53073: LIST
53074: LIST
53075: PUSH
53076: EMPTY
53077: LIST
53078: LIST
53079: LIST
53080: PUSH
53081: LD_INT 58
53083: PUSH
53084: EMPTY
53085: LIST
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: PPUSH
53091: CALL_OW 72
53095: PPUSH
53096: CALL_OW 1
53100: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53101: LD_ADDR_EXP 33
53105: PUSH
53106: LD_EXP 33
53110: PPUSH
53111: LD_VAR 0 2
53115: PPUSH
53116: EMPTY
53117: PPUSH
53118: CALL_OW 1
53122: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53123: LD_ADDR_EXP 37
53127: PUSH
53128: LD_EXP 37
53132: PPUSH
53133: LD_VAR 0 2
53137: PPUSH
53138: EMPTY
53139: PPUSH
53140: CALL_OW 1
53144: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53145: LD_ADDR_EXP 36
53149: PUSH
53150: LD_EXP 36
53154: PPUSH
53155: LD_VAR 0 2
53159: PPUSH
53160: EMPTY
53161: PPUSH
53162: CALL_OW 1
53166: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53167: LD_ADDR_EXP 38
53171: PUSH
53172: LD_EXP 38
53176: PPUSH
53177: LD_VAR 0 2
53181: PPUSH
53182: EMPTY
53183: PPUSH
53184: CALL_OW 1
53188: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53189: LD_ADDR_EXP 39
53193: PUSH
53194: LD_EXP 39
53198: PPUSH
53199: LD_VAR 0 2
53203: PPUSH
53204: EMPTY
53205: PPUSH
53206: CALL_OW 1
53210: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53211: LD_ADDR_EXP 40
53215: PUSH
53216: LD_EXP 40
53220: PPUSH
53221: LD_VAR 0 2
53225: PPUSH
53226: EMPTY
53227: PPUSH
53228: CALL_OW 1
53232: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53233: LD_ADDR_EXP 41
53237: PUSH
53238: LD_EXP 41
53242: PPUSH
53243: LD_VAR 0 2
53247: PPUSH
53248: EMPTY
53249: PPUSH
53250: CALL_OW 1
53254: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53255: LD_ADDR_EXP 42
53259: PUSH
53260: LD_EXP 42
53264: PPUSH
53265: LD_VAR 0 2
53269: PPUSH
53270: EMPTY
53271: PPUSH
53272: CALL_OW 1
53276: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53277: LD_ADDR_EXP 43
53281: PUSH
53282: LD_EXP 43
53286: PPUSH
53287: LD_VAR 0 2
53291: PPUSH
53292: EMPTY
53293: PPUSH
53294: CALL_OW 1
53298: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53299: LD_ADDR_EXP 44
53303: PUSH
53304: LD_EXP 44
53308: PPUSH
53309: LD_VAR 0 2
53313: PPUSH
53314: EMPTY
53315: PPUSH
53316: CALL_OW 1
53320: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53321: LD_ADDR_EXP 45
53325: PUSH
53326: LD_EXP 45
53330: PPUSH
53331: LD_VAR 0 2
53335: PPUSH
53336: EMPTY
53337: PPUSH
53338: CALL_OW 1
53342: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53343: LD_ADDR_EXP 34
53347: PUSH
53348: LD_EXP 34
53352: PPUSH
53353: LD_VAR 0 2
53357: PPUSH
53358: LD_INT 0
53360: PPUSH
53361: CALL_OW 1
53365: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53366: LD_ADDR_EXP 47
53370: PUSH
53371: LD_EXP 47
53375: PPUSH
53376: LD_VAR 0 2
53380: PPUSH
53381: LD_INT 0
53383: PPUSH
53384: CALL_OW 1
53388: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53389: LD_ADDR_EXP 35
53393: PUSH
53394: LD_EXP 35
53398: PPUSH
53399: LD_VAR 0 2
53403: PPUSH
53404: EMPTY
53405: PPUSH
53406: CALL_OW 1
53410: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53411: LD_ADDR_EXP 46
53415: PUSH
53416: LD_EXP 46
53420: PPUSH
53421: LD_VAR 0 2
53425: PPUSH
53426: LD_INT 0
53428: PPUSH
53429: CALL_OW 1
53433: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53434: LD_ADDR_EXP 48
53438: PUSH
53439: LD_EXP 48
53443: PPUSH
53444: LD_VAR 0 2
53448: PPUSH
53449: EMPTY
53450: PPUSH
53451: CALL_OW 1
53455: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53456: LD_ADDR_EXP 51
53460: PUSH
53461: LD_EXP 51
53465: PPUSH
53466: LD_VAR 0 2
53470: PPUSH
53471: LD_INT 0
53473: PPUSH
53474: CALL_OW 1
53478: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53479: LD_ADDR_EXP 52
53483: PUSH
53484: LD_EXP 52
53488: PPUSH
53489: LD_VAR 0 2
53493: PPUSH
53494: EMPTY
53495: PPUSH
53496: CALL_OW 1
53500: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53501: LD_ADDR_EXP 53
53505: PUSH
53506: LD_EXP 53
53510: PPUSH
53511: LD_VAR 0 2
53515: PPUSH
53516: EMPTY
53517: PPUSH
53518: CALL_OW 1
53522: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53523: LD_ADDR_EXP 54
53527: PUSH
53528: LD_EXP 54
53532: PPUSH
53533: LD_VAR 0 2
53537: PPUSH
53538: EMPTY
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53545: LD_ADDR_EXP 56
53549: PUSH
53550: LD_EXP 56
53554: PPUSH
53555: LD_VAR 0 2
53559: PPUSH
53560: LD_EXP 23
53564: PUSH
53565: LD_VAR 0 2
53569: ARRAY
53570: PPUSH
53571: LD_INT 2
53573: PUSH
53574: LD_INT 30
53576: PUSH
53577: LD_INT 6
53579: PUSH
53580: EMPTY
53581: LIST
53582: LIST
53583: PUSH
53584: LD_INT 30
53586: PUSH
53587: LD_INT 7
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: PUSH
53594: LD_INT 30
53596: PUSH
53597: LD_INT 8
53599: PUSH
53600: EMPTY
53601: LIST
53602: LIST
53603: PUSH
53604: EMPTY
53605: LIST
53606: LIST
53607: LIST
53608: LIST
53609: PPUSH
53610: CALL_OW 72
53614: PPUSH
53615: CALL_OW 1
53619: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53620: LD_ADDR_EXP 57
53624: PUSH
53625: LD_EXP 57
53629: PPUSH
53630: LD_VAR 0 2
53634: PPUSH
53635: EMPTY
53636: PPUSH
53637: CALL_OW 1
53641: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53642: LD_ADDR_EXP 58
53646: PUSH
53647: LD_EXP 58
53651: PPUSH
53652: LD_VAR 0 2
53656: PPUSH
53657: EMPTY
53658: PPUSH
53659: CALL_OW 1
53663: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53664: LD_ADDR_EXP 59
53668: PUSH
53669: LD_EXP 59
53673: PPUSH
53674: LD_VAR 0 2
53678: PPUSH
53679: EMPTY
53680: PPUSH
53681: CALL_OW 1
53685: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53686: LD_ADDR_EXP 60
53690: PUSH
53691: LD_EXP 60
53695: PPUSH
53696: LD_VAR 0 2
53700: PPUSH
53701: EMPTY
53702: PPUSH
53703: CALL_OW 1
53707: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53708: LD_ADDR_EXP 61
53712: PUSH
53713: LD_EXP 61
53717: PPUSH
53718: LD_VAR 0 2
53722: PPUSH
53723: EMPTY
53724: PPUSH
53725: CALL_OW 1
53729: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53730: LD_ADDR_EXP 62
53734: PUSH
53735: LD_EXP 62
53739: PPUSH
53740: LD_VAR 0 2
53744: PPUSH
53745: EMPTY
53746: PPUSH
53747: CALL_OW 1
53751: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53752: LD_ADDR_EXP 63
53756: PUSH
53757: LD_EXP 63
53761: PPUSH
53762: LD_VAR 0 2
53766: PPUSH
53767: EMPTY
53768: PPUSH
53769: CALL_OW 1
53773: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53774: LD_ADDR_EXP 64
53778: PUSH
53779: LD_EXP 64
53783: PPUSH
53784: LD_VAR 0 2
53788: PPUSH
53789: EMPTY
53790: PPUSH
53791: CALL_OW 1
53795: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53796: LD_ADDR_EXP 65
53800: PUSH
53801: LD_EXP 65
53805: PPUSH
53806: LD_VAR 0 2
53810: PPUSH
53811: LD_INT 0
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
53819: LD_ADDR_EXP 66
53823: PUSH
53824: LD_EXP 66
53828: PPUSH
53829: LD_VAR 0 2
53833: PPUSH
53834: LD_INT 0
53836: PPUSH
53837: CALL_OW 1
53841: ST_TO_ADDR
// end ;
53842: GO 52743
53844: POP
53845: POP
// MC_InitSides ( ) ;
53846: CALL 54132 0 0
// MC_InitResearch ( ) ;
53850: CALL 53871 0 0
// CustomInitMacro ( ) ;
53854: CALL 277 0 0
// skirmish := true ;
53858: LD_ADDR_EXP 21
53862: PUSH
53863: LD_INT 1
53865: ST_TO_ADDR
// end ;
53866: LD_VAR 0 1
53870: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53871: LD_INT 0
53873: PPUSH
53874: PPUSH
53875: PPUSH
53876: PPUSH
53877: PPUSH
53878: PPUSH
// if not mc_bases then
53879: LD_EXP 23
53883: NOT
53884: IFFALSE 53888
// exit ;
53886: GO 54127
// for i = 1 to 8 do
53888: LD_ADDR_VAR 0 2
53892: PUSH
53893: DOUBLE
53894: LD_INT 1
53896: DEC
53897: ST_TO_ADDR
53898: LD_INT 8
53900: PUSH
53901: FOR_TO
53902: IFFALSE 53928
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53904: LD_ADDR_EXP 50
53908: PUSH
53909: LD_EXP 50
53913: PPUSH
53914: LD_VAR 0 2
53918: PPUSH
53919: EMPTY
53920: PPUSH
53921: CALL_OW 1
53925: ST_TO_ADDR
53926: GO 53901
53928: POP
53929: POP
// tmp := [ ] ;
53930: LD_ADDR_VAR 0 5
53934: PUSH
53935: EMPTY
53936: ST_TO_ADDR
// for i = 1 to mc_sides do
53937: LD_ADDR_VAR 0 2
53941: PUSH
53942: DOUBLE
53943: LD_INT 1
53945: DEC
53946: ST_TO_ADDR
53947: LD_EXP 49
53951: PUSH
53952: FOR_TO
53953: IFFALSE 54011
// if not mc_sides [ i ] in tmp then
53955: LD_EXP 49
53959: PUSH
53960: LD_VAR 0 2
53964: ARRAY
53965: PUSH
53966: LD_VAR 0 5
53970: IN
53971: NOT
53972: IFFALSE 54009
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53974: LD_ADDR_VAR 0 5
53978: PUSH
53979: LD_VAR 0 5
53983: PPUSH
53984: LD_VAR 0 5
53988: PUSH
53989: LD_INT 1
53991: PLUS
53992: PPUSH
53993: LD_EXP 49
53997: PUSH
53998: LD_VAR 0 2
54002: ARRAY
54003: PPUSH
54004: CALL_OW 2
54008: ST_TO_ADDR
54009: GO 53952
54011: POP
54012: POP
// if not tmp then
54013: LD_VAR 0 5
54017: NOT
54018: IFFALSE 54022
// exit ;
54020: GO 54127
// for j in tmp do
54022: LD_ADDR_VAR 0 3
54026: PUSH
54027: LD_VAR 0 5
54031: PUSH
54032: FOR_IN
54033: IFFALSE 54125
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54035: LD_ADDR_VAR 0 6
54039: PUSH
54040: LD_INT 22
54042: PUSH
54043: LD_VAR 0 3
54047: PUSH
54048: EMPTY
54049: LIST
54050: LIST
54051: PPUSH
54052: CALL_OW 69
54056: ST_TO_ADDR
// if not un then
54057: LD_VAR 0 6
54061: NOT
54062: IFFALSE 54066
// continue ;
54064: GO 54032
// nation := GetNation ( un [ 1 ] ) ;
54066: LD_ADDR_VAR 0 4
54070: PUSH
54071: LD_VAR 0 6
54075: PUSH
54076: LD_INT 1
54078: ARRAY
54079: PPUSH
54080: CALL_OW 248
54084: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54085: LD_ADDR_EXP 50
54089: PUSH
54090: LD_EXP 50
54094: PPUSH
54095: LD_VAR 0 3
54099: PPUSH
54100: LD_VAR 0 3
54104: PPUSH
54105: LD_VAR 0 4
54109: PPUSH
54110: LD_INT 1
54112: PPUSH
54113: CALL 11067 0 3
54117: PPUSH
54118: CALL_OW 1
54122: ST_TO_ADDR
// end ;
54123: GO 54032
54125: POP
54126: POP
// end ;
54127: LD_VAR 0 1
54131: RET
// export function MC_InitSides ( ) ; var i ; begin
54132: LD_INT 0
54134: PPUSH
54135: PPUSH
// if not mc_bases then
54136: LD_EXP 23
54140: NOT
54141: IFFALSE 54145
// exit ;
54143: GO 54219
// for i = 1 to mc_bases do
54145: LD_ADDR_VAR 0 2
54149: PUSH
54150: DOUBLE
54151: LD_INT 1
54153: DEC
54154: ST_TO_ADDR
54155: LD_EXP 23
54159: PUSH
54160: FOR_TO
54161: IFFALSE 54217
// if mc_bases [ i ] then
54163: LD_EXP 23
54167: PUSH
54168: LD_VAR 0 2
54172: ARRAY
54173: IFFALSE 54215
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54175: LD_ADDR_EXP 49
54179: PUSH
54180: LD_EXP 49
54184: PPUSH
54185: LD_VAR 0 2
54189: PPUSH
54190: LD_EXP 23
54194: PUSH
54195: LD_VAR 0 2
54199: ARRAY
54200: PUSH
54201: LD_INT 1
54203: ARRAY
54204: PPUSH
54205: CALL_OW 255
54209: PPUSH
54210: CALL_OW 1
54214: ST_TO_ADDR
54215: GO 54160
54217: POP
54218: POP
// end ;
54219: LD_VAR 0 1
54223: RET
// every 0 0$03 trigger skirmish do
54224: LD_EXP 21
54228: IFFALSE 54382
54230: GO 54232
54232: DISABLE
// begin enable ;
54233: ENABLE
// MC_CheckBuildings ( ) ;
54234: CALL 58880 0 0
// MC_CheckPeopleLife ( ) ;
54238: CALL 59041 0 0
// RaiseSailEvent ( 100 ) ;
54242: LD_INT 100
54244: PPUSH
54245: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54249: LD_INT 103
54251: PPUSH
54252: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54256: LD_INT 104
54258: PPUSH
54259: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54263: LD_INT 105
54265: PPUSH
54266: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54270: LD_INT 106
54272: PPUSH
54273: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54277: LD_INT 107
54279: PPUSH
54280: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54284: LD_INT 108
54286: PPUSH
54287: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54291: LD_INT 109
54293: PPUSH
54294: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54298: LD_INT 110
54300: PPUSH
54301: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54305: LD_INT 111
54307: PPUSH
54308: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54312: LD_INT 112
54314: PPUSH
54315: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54319: LD_INT 113
54321: PPUSH
54322: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54326: LD_INT 120
54328: PPUSH
54329: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54333: LD_INT 121
54335: PPUSH
54336: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54340: LD_INT 122
54342: PPUSH
54343: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54347: LD_INT 123
54349: PPUSH
54350: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54354: LD_INT 124
54356: PPUSH
54357: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54361: LD_INT 125
54363: PPUSH
54364: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54368: LD_INT 126
54370: PPUSH
54371: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54375: LD_INT 200
54377: PPUSH
54378: CALL_OW 427
// end ;
54382: END
// on SailEvent ( event ) do begin if event < 100 then
54383: LD_VAR 0 1
54387: PUSH
54388: LD_INT 100
54390: LESS
54391: IFFALSE 54402
// CustomEvent ( event ) ;
54393: LD_VAR 0 1
54397: PPUSH
54398: CALL 10241 0 1
// if event = 100 then
54402: LD_VAR 0 1
54406: PUSH
54407: LD_INT 100
54409: EQUAL
54410: IFFALSE 54416
// MC_ClassManager ( ) ;
54412: CALL 54808 0 0
// if event = 101 then
54416: LD_VAR 0 1
54420: PUSH
54421: LD_INT 101
54423: EQUAL
54424: IFFALSE 54430
// MC_RepairBuildings ( ) ;
54426: CALL 59626 0 0
// if event = 102 then
54430: LD_VAR 0 1
54434: PUSH
54435: LD_INT 102
54437: EQUAL
54438: IFFALSE 54444
// MC_Heal ( ) ;
54440: CALL 60533 0 0
// if event = 103 then
54444: LD_VAR 0 1
54448: PUSH
54449: LD_INT 103
54451: EQUAL
54452: IFFALSE 54458
// MC_Build ( ) ;
54454: CALL 60955 0 0
// if event = 104 then
54458: LD_VAR 0 1
54462: PUSH
54463: LD_INT 104
54465: EQUAL
54466: IFFALSE 54472
// MC_TurretWeapon ( ) ;
54468: CALL 62596 0 0
// if event = 105 then
54472: LD_VAR 0 1
54476: PUSH
54477: LD_INT 105
54479: EQUAL
54480: IFFALSE 54486
// MC_BuildUpgrade ( ) ;
54482: CALL 62147 0 0
// if event = 106 then
54486: LD_VAR 0 1
54490: PUSH
54491: LD_INT 106
54493: EQUAL
54494: IFFALSE 54500
// MC_PlantMines ( ) ;
54496: CALL 63026 0 0
// if event = 107 then
54500: LD_VAR 0 1
54504: PUSH
54505: LD_INT 107
54507: EQUAL
54508: IFFALSE 54514
// MC_CollectCrates ( ) ;
54510: CALL 63817 0 0
// if event = 108 then
54514: LD_VAR 0 1
54518: PUSH
54519: LD_INT 108
54521: EQUAL
54522: IFFALSE 54528
// MC_LinkRemoteControl ( ) ;
54524: CALL 65667 0 0
// if event = 109 then
54528: LD_VAR 0 1
54532: PUSH
54533: LD_INT 109
54535: EQUAL
54536: IFFALSE 54542
// MC_ProduceVehicle ( ) ;
54538: CALL 65848 0 0
// if event = 110 then
54542: LD_VAR 0 1
54546: PUSH
54547: LD_INT 110
54549: EQUAL
54550: IFFALSE 54556
// MC_SendAttack ( ) ;
54552: CALL 66314 0 0
// if event = 111 then
54556: LD_VAR 0 1
54560: PUSH
54561: LD_INT 111
54563: EQUAL
54564: IFFALSE 54570
// MC_Defend ( ) ;
54566: CALL 66422 0 0
// if event = 112 then
54570: LD_VAR 0 1
54574: PUSH
54575: LD_INT 112
54577: EQUAL
54578: IFFALSE 54584
// MC_Research ( ) ;
54580: CALL 67302 0 0
// if event = 113 then
54584: LD_VAR 0 1
54588: PUSH
54589: LD_INT 113
54591: EQUAL
54592: IFFALSE 54598
// MC_MinesTrigger ( ) ;
54594: CALL 68416 0 0
// if event = 120 then
54598: LD_VAR 0 1
54602: PUSH
54603: LD_INT 120
54605: EQUAL
54606: IFFALSE 54612
// MC_RepairVehicle ( ) ;
54608: CALL 68515 0 0
// if event = 121 then
54612: LD_VAR 0 1
54616: PUSH
54617: LD_INT 121
54619: EQUAL
54620: IFFALSE 54626
// MC_TameApe ( ) ;
54622: CALL 69256 0 0
// if event = 122 then
54626: LD_VAR 0 1
54630: PUSH
54631: LD_INT 122
54633: EQUAL
54634: IFFALSE 54640
// MC_ChangeApeClass ( ) ;
54636: CALL 70085 0 0
// if event = 123 then
54640: LD_VAR 0 1
54644: PUSH
54645: LD_INT 123
54647: EQUAL
54648: IFFALSE 54654
// MC_Bazooka ( ) ;
54650: CALL 70735 0 0
// if event = 124 then
54654: LD_VAR 0 1
54658: PUSH
54659: LD_INT 124
54661: EQUAL
54662: IFFALSE 54668
// MC_TeleportExit ( ) ;
54664: CALL 70933 0 0
// if event = 125 then
54668: LD_VAR 0 1
54672: PUSH
54673: LD_INT 125
54675: EQUAL
54676: IFFALSE 54682
// MC_Deposits ( ) ;
54678: CALL 71580 0 0
// if event = 126 then
54682: LD_VAR 0 1
54686: PUSH
54687: LD_INT 126
54689: EQUAL
54690: IFFALSE 54696
// MC_RemoteDriver ( ) ;
54692: CALL 72205 0 0
// if event = 200 then
54696: LD_VAR 0 1
54700: PUSH
54701: LD_INT 200
54703: EQUAL
54704: IFFALSE 54710
// MC_Idle ( ) ;
54706: CALL 74154 0 0
// end ;
54710: PPOPN 1
54712: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54713: LD_INT 0
54715: PPUSH
54716: PPUSH
// if not mc_bases [ base ] or not tag then
54717: LD_EXP 23
54721: PUSH
54722: LD_VAR 0 1
54726: ARRAY
54727: NOT
54728: PUSH
54729: LD_VAR 0 2
54733: NOT
54734: OR
54735: IFFALSE 54739
// exit ;
54737: GO 54803
// for i in mc_bases [ base ] union mc_ape [ base ] do
54739: LD_ADDR_VAR 0 4
54743: PUSH
54744: LD_EXP 23
54748: PUSH
54749: LD_VAR 0 1
54753: ARRAY
54754: PUSH
54755: LD_EXP 52
54759: PUSH
54760: LD_VAR 0 1
54764: ARRAY
54765: UNION
54766: PUSH
54767: FOR_IN
54768: IFFALSE 54801
// if GetTag ( i ) = tag then
54770: LD_VAR 0 4
54774: PPUSH
54775: CALL_OW 110
54779: PUSH
54780: LD_VAR 0 2
54784: EQUAL
54785: IFFALSE 54799
// SetTag ( i , 0 ) ;
54787: LD_VAR 0 4
54791: PPUSH
54792: LD_INT 0
54794: PPUSH
54795: CALL_OW 109
54799: GO 54767
54801: POP
54802: POP
// end ;
54803: LD_VAR 0 3
54807: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54808: LD_INT 0
54810: PPUSH
54811: PPUSH
54812: PPUSH
54813: PPUSH
54814: PPUSH
54815: PPUSH
54816: PPUSH
54817: PPUSH
// if not mc_bases then
54818: LD_EXP 23
54822: NOT
54823: IFFALSE 54827
// exit ;
54825: GO 55285
// for i = 1 to mc_bases do
54827: LD_ADDR_VAR 0 2
54831: PUSH
54832: DOUBLE
54833: LD_INT 1
54835: DEC
54836: ST_TO_ADDR
54837: LD_EXP 23
54841: PUSH
54842: FOR_TO
54843: IFFALSE 55283
// begin tmp := MC_ClassCheckReq ( i ) ;
54845: LD_ADDR_VAR 0 4
54849: PUSH
54850: LD_VAR 0 2
54854: PPUSH
54855: CALL 55290 0 1
54859: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54860: LD_ADDR_EXP 64
54864: PUSH
54865: LD_EXP 64
54869: PPUSH
54870: LD_VAR 0 2
54874: PPUSH
54875: LD_VAR 0 4
54879: PPUSH
54880: CALL_OW 1
54884: ST_TO_ADDR
// if not tmp then
54885: LD_VAR 0 4
54889: NOT
54890: IFFALSE 54894
// continue ;
54892: GO 54842
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54894: LD_ADDR_VAR 0 6
54898: PUSH
54899: LD_EXP 23
54903: PUSH
54904: LD_VAR 0 2
54908: ARRAY
54909: PPUSH
54910: LD_INT 2
54912: PUSH
54913: LD_INT 30
54915: PUSH
54916: LD_INT 4
54918: PUSH
54919: EMPTY
54920: LIST
54921: LIST
54922: PUSH
54923: LD_INT 30
54925: PUSH
54926: LD_INT 5
54928: PUSH
54929: EMPTY
54930: LIST
54931: LIST
54932: PUSH
54933: EMPTY
54934: LIST
54935: LIST
54936: LIST
54937: PPUSH
54938: CALL_OW 72
54942: PUSH
54943: LD_EXP 23
54947: PUSH
54948: LD_VAR 0 2
54952: ARRAY
54953: PPUSH
54954: LD_INT 2
54956: PUSH
54957: LD_INT 30
54959: PUSH
54960: LD_INT 0
54962: PUSH
54963: EMPTY
54964: LIST
54965: LIST
54966: PUSH
54967: LD_INT 30
54969: PUSH
54970: LD_INT 1
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: PUSH
54977: EMPTY
54978: LIST
54979: LIST
54980: LIST
54981: PPUSH
54982: CALL_OW 72
54986: PUSH
54987: LD_EXP 23
54991: PUSH
54992: LD_VAR 0 2
54996: ARRAY
54997: PPUSH
54998: LD_INT 30
55000: PUSH
55001: LD_INT 3
55003: PUSH
55004: EMPTY
55005: LIST
55006: LIST
55007: PPUSH
55008: CALL_OW 72
55012: PUSH
55013: LD_EXP 23
55017: PUSH
55018: LD_VAR 0 2
55022: ARRAY
55023: PPUSH
55024: LD_INT 2
55026: PUSH
55027: LD_INT 30
55029: PUSH
55030: LD_INT 6
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: PUSH
55037: LD_INT 30
55039: PUSH
55040: LD_INT 7
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: PUSH
55047: LD_INT 30
55049: PUSH
55050: LD_INT 8
55052: PUSH
55053: EMPTY
55054: LIST
55055: LIST
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: LIST
55061: LIST
55062: PPUSH
55063: CALL_OW 72
55067: PUSH
55068: EMPTY
55069: LIST
55070: LIST
55071: LIST
55072: LIST
55073: ST_TO_ADDR
// for j = 1 to 4 do
55074: LD_ADDR_VAR 0 3
55078: PUSH
55079: DOUBLE
55080: LD_INT 1
55082: DEC
55083: ST_TO_ADDR
55084: LD_INT 4
55086: PUSH
55087: FOR_TO
55088: IFFALSE 55279
// begin if not tmp [ j ] then
55090: LD_VAR 0 4
55094: PUSH
55095: LD_VAR 0 3
55099: ARRAY
55100: NOT
55101: IFFALSE 55105
// continue ;
55103: GO 55087
// for p in tmp [ j ] do
55105: LD_ADDR_VAR 0 5
55109: PUSH
55110: LD_VAR 0 4
55114: PUSH
55115: LD_VAR 0 3
55119: ARRAY
55120: PUSH
55121: FOR_IN
55122: IFFALSE 55275
// begin if not b [ j ] then
55124: LD_VAR 0 6
55128: PUSH
55129: LD_VAR 0 3
55133: ARRAY
55134: NOT
55135: IFFALSE 55139
// break ;
55137: GO 55275
// e := 0 ;
55139: LD_ADDR_VAR 0 7
55143: PUSH
55144: LD_INT 0
55146: ST_TO_ADDR
// for k in b [ j ] do
55147: LD_ADDR_VAR 0 8
55151: PUSH
55152: LD_VAR 0 6
55156: PUSH
55157: LD_VAR 0 3
55161: ARRAY
55162: PUSH
55163: FOR_IN
55164: IFFALSE 55191
// if IsNotFull ( k ) then
55166: LD_VAR 0 8
55170: PPUSH
55171: CALL 13220 0 1
55175: IFFALSE 55189
// begin e := k ;
55177: LD_ADDR_VAR 0 7
55181: PUSH
55182: LD_VAR 0 8
55186: ST_TO_ADDR
// break ;
55187: GO 55191
// end ;
55189: GO 55163
55191: POP
55192: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55193: LD_VAR 0 7
55197: PUSH
55198: LD_VAR 0 5
55202: PPUSH
55203: LD_VAR 0 7
55207: PPUSH
55208: CALL 46384 0 2
55212: NOT
55213: AND
55214: IFFALSE 55273
// begin if IsInUnit ( p ) then
55216: LD_VAR 0 5
55220: PPUSH
55221: CALL_OW 310
55225: IFFALSE 55236
// ComExitBuilding ( p ) ;
55227: LD_VAR 0 5
55231: PPUSH
55232: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55236: LD_VAR 0 5
55240: PPUSH
55241: LD_VAR 0 7
55245: PPUSH
55246: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55250: LD_VAR 0 5
55254: PPUSH
55255: LD_VAR 0 3
55259: PPUSH
55260: CALL_OW 183
// AddComExitBuilding ( p ) ;
55264: LD_VAR 0 5
55268: PPUSH
55269: CALL_OW 182
// end ; end ;
55273: GO 55121
55275: POP
55276: POP
// end ;
55277: GO 55087
55279: POP
55280: POP
// end ;
55281: GO 54842
55283: POP
55284: POP
// end ;
55285: LD_VAR 0 1
55289: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55290: LD_INT 0
55292: PPUSH
55293: PPUSH
55294: PPUSH
55295: PPUSH
55296: PPUSH
55297: PPUSH
55298: PPUSH
55299: PPUSH
55300: PPUSH
55301: PPUSH
55302: PPUSH
55303: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55304: LD_VAR 0 1
55308: NOT
55309: PUSH
55310: LD_EXP 23
55314: PUSH
55315: LD_VAR 0 1
55319: ARRAY
55320: NOT
55321: OR
55322: PUSH
55323: LD_EXP 23
55327: PUSH
55328: LD_VAR 0 1
55332: ARRAY
55333: PPUSH
55334: LD_INT 2
55336: PUSH
55337: LD_INT 30
55339: PUSH
55340: LD_INT 0
55342: PUSH
55343: EMPTY
55344: LIST
55345: LIST
55346: PUSH
55347: LD_INT 30
55349: PUSH
55350: LD_INT 1
55352: PUSH
55353: EMPTY
55354: LIST
55355: LIST
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: LIST
55361: PPUSH
55362: CALL_OW 72
55366: NOT
55367: OR
55368: IFFALSE 55372
// exit ;
55370: GO 58875
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55372: LD_ADDR_VAR 0 4
55376: PUSH
55377: LD_EXP 23
55381: PUSH
55382: LD_VAR 0 1
55386: ARRAY
55387: PPUSH
55388: LD_INT 2
55390: PUSH
55391: LD_INT 25
55393: PUSH
55394: LD_INT 1
55396: PUSH
55397: EMPTY
55398: LIST
55399: LIST
55400: PUSH
55401: LD_INT 25
55403: PUSH
55404: LD_INT 2
55406: PUSH
55407: EMPTY
55408: LIST
55409: LIST
55410: PUSH
55411: LD_INT 25
55413: PUSH
55414: LD_INT 3
55416: PUSH
55417: EMPTY
55418: LIST
55419: LIST
55420: PUSH
55421: LD_INT 25
55423: PUSH
55424: LD_INT 4
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PUSH
55431: LD_INT 25
55433: PUSH
55434: LD_INT 5
55436: PUSH
55437: EMPTY
55438: LIST
55439: LIST
55440: PUSH
55441: LD_INT 25
55443: PUSH
55444: LD_INT 8
55446: PUSH
55447: EMPTY
55448: LIST
55449: LIST
55450: PUSH
55451: LD_INT 25
55453: PUSH
55454: LD_INT 9
55456: PUSH
55457: EMPTY
55458: LIST
55459: LIST
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: LIST
55465: LIST
55466: LIST
55467: LIST
55468: LIST
55469: LIST
55470: PPUSH
55471: CALL_OW 72
55475: ST_TO_ADDR
// if not tmp then
55476: LD_VAR 0 4
55480: NOT
55481: IFFALSE 55485
// exit ;
55483: GO 58875
// for i in tmp do
55485: LD_ADDR_VAR 0 3
55489: PUSH
55490: LD_VAR 0 4
55494: PUSH
55495: FOR_IN
55496: IFFALSE 55527
// if GetTag ( i ) then
55498: LD_VAR 0 3
55502: PPUSH
55503: CALL_OW 110
55507: IFFALSE 55525
// tmp := tmp diff i ;
55509: LD_ADDR_VAR 0 4
55513: PUSH
55514: LD_VAR 0 4
55518: PUSH
55519: LD_VAR 0 3
55523: DIFF
55524: ST_TO_ADDR
55525: GO 55495
55527: POP
55528: POP
// if not tmp then
55529: LD_VAR 0 4
55533: NOT
55534: IFFALSE 55538
// exit ;
55536: GO 58875
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55538: LD_ADDR_VAR 0 5
55542: PUSH
55543: LD_EXP 23
55547: PUSH
55548: LD_VAR 0 1
55552: ARRAY
55553: PPUSH
55554: LD_INT 2
55556: PUSH
55557: LD_INT 25
55559: PUSH
55560: LD_INT 1
55562: PUSH
55563: EMPTY
55564: LIST
55565: LIST
55566: PUSH
55567: LD_INT 25
55569: PUSH
55570: LD_INT 5
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: PUSH
55577: LD_INT 25
55579: PUSH
55580: LD_INT 8
55582: PUSH
55583: EMPTY
55584: LIST
55585: LIST
55586: PUSH
55587: LD_INT 25
55589: PUSH
55590: LD_INT 9
55592: PUSH
55593: EMPTY
55594: LIST
55595: LIST
55596: PUSH
55597: EMPTY
55598: LIST
55599: LIST
55600: LIST
55601: LIST
55602: LIST
55603: PPUSH
55604: CALL_OW 72
55608: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55609: LD_ADDR_VAR 0 6
55613: PUSH
55614: LD_EXP 23
55618: PUSH
55619: LD_VAR 0 1
55623: ARRAY
55624: PPUSH
55625: LD_INT 25
55627: PUSH
55628: LD_INT 2
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: PPUSH
55635: CALL_OW 72
55639: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55640: LD_ADDR_VAR 0 7
55644: PUSH
55645: LD_EXP 23
55649: PUSH
55650: LD_VAR 0 1
55654: ARRAY
55655: PPUSH
55656: LD_INT 25
55658: PUSH
55659: LD_INT 3
55661: PUSH
55662: EMPTY
55663: LIST
55664: LIST
55665: PPUSH
55666: CALL_OW 72
55670: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55671: LD_ADDR_VAR 0 8
55675: PUSH
55676: LD_EXP 23
55680: PUSH
55681: LD_VAR 0 1
55685: ARRAY
55686: PPUSH
55687: LD_INT 25
55689: PUSH
55690: LD_INT 4
55692: PUSH
55693: EMPTY
55694: LIST
55695: LIST
55696: PUSH
55697: LD_INT 24
55699: PUSH
55700: LD_INT 251
55702: PUSH
55703: EMPTY
55704: LIST
55705: LIST
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: PPUSH
55711: CALL_OW 72
55715: ST_TO_ADDR
// if mc_is_defending [ base ] then
55716: LD_EXP 66
55720: PUSH
55721: LD_VAR 0 1
55725: ARRAY
55726: IFFALSE 56187
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55728: LD_ADDR_EXP 65
55732: PUSH
55733: LD_EXP 65
55737: PPUSH
55738: LD_VAR 0 1
55742: PPUSH
55743: LD_INT 4
55745: PPUSH
55746: CALL_OW 1
55750: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55751: LD_ADDR_VAR 0 12
55755: PUSH
55756: LD_EXP 23
55760: PUSH
55761: LD_VAR 0 1
55765: ARRAY
55766: PPUSH
55767: LD_INT 2
55769: PUSH
55770: LD_INT 30
55772: PUSH
55773: LD_INT 4
55775: PUSH
55776: EMPTY
55777: LIST
55778: LIST
55779: PUSH
55780: LD_INT 30
55782: PUSH
55783: LD_INT 5
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: PUSH
55790: EMPTY
55791: LIST
55792: LIST
55793: LIST
55794: PPUSH
55795: CALL_OW 72
55799: ST_TO_ADDR
// if not b then
55800: LD_VAR 0 12
55804: NOT
55805: IFFALSE 55809
// exit ;
55807: GO 58875
// p := [ ] ;
55809: LD_ADDR_VAR 0 11
55813: PUSH
55814: EMPTY
55815: ST_TO_ADDR
// if sci >= 2 then
55816: LD_VAR 0 8
55820: PUSH
55821: LD_INT 2
55823: GREATEREQUAL
55824: IFFALSE 55855
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55826: LD_ADDR_VAR 0 8
55830: PUSH
55831: LD_VAR 0 8
55835: PUSH
55836: LD_INT 1
55838: ARRAY
55839: PUSH
55840: LD_VAR 0 8
55844: PUSH
55845: LD_INT 2
55847: ARRAY
55848: PUSH
55849: EMPTY
55850: LIST
55851: LIST
55852: ST_TO_ADDR
55853: GO 55916
// if sci = 1 then
55855: LD_VAR 0 8
55859: PUSH
55860: LD_INT 1
55862: EQUAL
55863: IFFALSE 55884
// sci := [ sci [ 1 ] ] else
55865: LD_ADDR_VAR 0 8
55869: PUSH
55870: LD_VAR 0 8
55874: PUSH
55875: LD_INT 1
55877: ARRAY
55878: PUSH
55879: EMPTY
55880: LIST
55881: ST_TO_ADDR
55882: GO 55916
// if sci = 0 then
55884: LD_VAR 0 8
55888: PUSH
55889: LD_INT 0
55891: EQUAL
55892: IFFALSE 55916
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55894: LD_ADDR_VAR 0 11
55898: PUSH
55899: LD_VAR 0 4
55903: PPUSH
55904: LD_INT 4
55906: PPUSH
55907: CALL 46247 0 2
55911: PUSH
55912: LD_INT 1
55914: ARRAY
55915: ST_TO_ADDR
// if eng > 4 then
55916: LD_VAR 0 6
55920: PUSH
55921: LD_INT 4
55923: GREATER
55924: IFFALSE 55970
// for i = eng downto 4 do
55926: LD_ADDR_VAR 0 3
55930: PUSH
55931: DOUBLE
55932: LD_VAR 0 6
55936: INC
55937: ST_TO_ADDR
55938: LD_INT 4
55940: PUSH
55941: FOR_DOWNTO
55942: IFFALSE 55968
// eng := eng diff eng [ i ] ;
55944: LD_ADDR_VAR 0 6
55948: PUSH
55949: LD_VAR 0 6
55953: PUSH
55954: LD_VAR 0 6
55958: PUSH
55959: LD_VAR 0 3
55963: ARRAY
55964: DIFF
55965: ST_TO_ADDR
55966: GO 55941
55968: POP
55969: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55970: LD_ADDR_VAR 0 4
55974: PUSH
55975: LD_VAR 0 4
55979: PUSH
55980: LD_VAR 0 5
55984: PUSH
55985: LD_VAR 0 6
55989: UNION
55990: PUSH
55991: LD_VAR 0 7
55995: UNION
55996: PUSH
55997: LD_VAR 0 8
56001: UNION
56002: DIFF
56003: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56004: LD_ADDR_VAR 0 13
56008: PUSH
56009: LD_EXP 23
56013: PUSH
56014: LD_VAR 0 1
56018: ARRAY
56019: PPUSH
56020: LD_INT 2
56022: PUSH
56023: LD_INT 30
56025: PUSH
56026: LD_INT 32
56028: PUSH
56029: EMPTY
56030: LIST
56031: LIST
56032: PUSH
56033: LD_INT 30
56035: PUSH
56036: LD_INT 31
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: PUSH
56043: EMPTY
56044: LIST
56045: LIST
56046: LIST
56047: PPUSH
56048: CALL_OW 72
56052: PUSH
56053: LD_EXP 23
56057: PUSH
56058: LD_VAR 0 1
56062: ARRAY
56063: PPUSH
56064: LD_INT 2
56066: PUSH
56067: LD_INT 30
56069: PUSH
56070: LD_INT 4
56072: PUSH
56073: EMPTY
56074: LIST
56075: LIST
56076: PUSH
56077: LD_INT 30
56079: PUSH
56080: LD_INT 5
56082: PUSH
56083: EMPTY
56084: LIST
56085: LIST
56086: PUSH
56087: EMPTY
56088: LIST
56089: LIST
56090: LIST
56091: PPUSH
56092: CALL_OW 72
56096: PUSH
56097: LD_INT 6
56099: MUL
56100: PLUS
56101: ST_TO_ADDR
// if bcount < tmp then
56102: LD_VAR 0 13
56106: PUSH
56107: LD_VAR 0 4
56111: LESS
56112: IFFALSE 56158
// for i = tmp downto bcount do
56114: LD_ADDR_VAR 0 3
56118: PUSH
56119: DOUBLE
56120: LD_VAR 0 4
56124: INC
56125: ST_TO_ADDR
56126: LD_VAR 0 13
56130: PUSH
56131: FOR_DOWNTO
56132: IFFALSE 56156
// tmp := Delete ( tmp , tmp ) ;
56134: LD_ADDR_VAR 0 4
56138: PUSH
56139: LD_VAR 0 4
56143: PPUSH
56144: LD_VAR 0 4
56148: PPUSH
56149: CALL_OW 3
56153: ST_TO_ADDR
56154: GO 56131
56156: POP
56157: POP
// result := [ tmp , 0 , 0 , p ] ;
56158: LD_ADDR_VAR 0 2
56162: PUSH
56163: LD_VAR 0 4
56167: PUSH
56168: LD_INT 0
56170: PUSH
56171: LD_INT 0
56173: PUSH
56174: LD_VAR 0 11
56178: PUSH
56179: EMPTY
56180: LIST
56181: LIST
56182: LIST
56183: LIST
56184: ST_TO_ADDR
// exit ;
56185: GO 58875
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56187: LD_EXP 23
56191: PUSH
56192: LD_VAR 0 1
56196: ARRAY
56197: PPUSH
56198: LD_INT 2
56200: PUSH
56201: LD_INT 30
56203: PUSH
56204: LD_INT 6
56206: PUSH
56207: EMPTY
56208: LIST
56209: LIST
56210: PUSH
56211: LD_INT 30
56213: PUSH
56214: LD_INT 7
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: PUSH
56221: LD_INT 30
56223: PUSH
56224: LD_INT 8
56226: PUSH
56227: EMPTY
56228: LIST
56229: LIST
56230: PUSH
56231: EMPTY
56232: LIST
56233: LIST
56234: LIST
56235: LIST
56236: PPUSH
56237: CALL_OW 72
56241: NOT
56242: PUSH
56243: LD_EXP 23
56247: PUSH
56248: LD_VAR 0 1
56252: ARRAY
56253: PPUSH
56254: LD_INT 30
56256: PUSH
56257: LD_INT 3
56259: PUSH
56260: EMPTY
56261: LIST
56262: LIST
56263: PPUSH
56264: CALL_OW 72
56268: NOT
56269: AND
56270: IFFALSE 56342
// begin if eng = tmp then
56272: LD_VAR 0 6
56276: PUSH
56277: LD_VAR 0 4
56281: EQUAL
56282: IFFALSE 56286
// exit ;
56284: GO 58875
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56286: LD_ADDR_EXP 65
56290: PUSH
56291: LD_EXP 65
56295: PPUSH
56296: LD_VAR 0 1
56300: PPUSH
56301: LD_INT 1
56303: PPUSH
56304: CALL_OW 1
56308: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56309: LD_ADDR_VAR 0 2
56313: PUSH
56314: LD_INT 0
56316: PUSH
56317: LD_VAR 0 4
56321: PUSH
56322: LD_VAR 0 6
56326: DIFF
56327: PUSH
56328: LD_INT 0
56330: PUSH
56331: LD_INT 0
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: LIST
56338: LIST
56339: ST_TO_ADDR
// exit ;
56340: GO 58875
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56342: LD_EXP 50
56346: PUSH
56347: LD_EXP 49
56351: PUSH
56352: LD_VAR 0 1
56356: ARRAY
56357: ARRAY
56358: PUSH
56359: LD_EXP 23
56363: PUSH
56364: LD_VAR 0 1
56368: ARRAY
56369: PPUSH
56370: LD_INT 2
56372: PUSH
56373: LD_INT 30
56375: PUSH
56376: LD_INT 6
56378: PUSH
56379: EMPTY
56380: LIST
56381: LIST
56382: PUSH
56383: LD_INT 30
56385: PUSH
56386: LD_INT 7
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PUSH
56393: LD_INT 30
56395: PUSH
56396: LD_INT 8
56398: PUSH
56399: EMPTY
56400: LIST
56401: LIST
56402: PUSH
56403: EMPTY
56404: LIST
56405: LIST
56406: LIST
56407: LIST
56408: PPUSH
56409: CALL_OW 72
56413: AND
56414: PUSH
56415: LD_EXP 23
56419: PUSH
56420: LD_VAR 0 1
56424: ARRAY
56425: PPUSH
56426: LD_INT 30
56428: PUSH
56429: LD_INT 3
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: PPUSH
56436: CALL_OW 72
56440: NOT
56441: AND
56442: IFFALSE 56656
// begin if sci >= 6 then
56444: LD_VAR 0 8
56448: PUSH
56449: LD_INT 6
56451: GREATEREQUAL
56452: IFFALSE 56456
// exit ;
56454: GO 58875
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56456: LD_ADDR_EXP 65
56460: PUSH
56461: LD_EXP 65
56465: PPUSH
56466: LD_VAR 0 1
56470: PPUSH
56471: LD_INT 2
56473: PPUSH
56474: CALL_OW 1
56478: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56479: LD_ADDR_VAR 0 9
56483: PUSH
56484: LD_VAR 0 4
56488: PUSH
56489: LD_VAR 0 8
56493: DIFF
56494: PPUSH
56495: LD_INT 4
56497: PPUSH
56498: CALL 46247 0 2
56502: ST_TO_ADDR
// p := [ ] ;
56503: LD_ADDR_VAR 0 11
56507: PUSH
56508: EMPTY
56509: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56510: LD_VAR 0 8
56514: PUSH
56515: LD_INT 6
56517: LESS
56518: PUSH
56519: LD_VAR 0 9
56523: PUSH
56524: LD_INT 6
56526: GREATER
56527: AND
56528: IFFALSE 56609
// begin for i = 1 to 6 - sci do
56530: LD_ADDR_VAR 0 3
56534: PUSH
56535: DOUBLE
56536: LD_INT 1
56538: DEC
56539: ST_TO_ADDR
56540: LD_INT 6
56542: PUSH
56543: LD_VAR 0 8
56547: MINUS
56548: PUSH
56549: FOR_TO
56550: IFFALSE 56605
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56552: LD_ADDR_VAR 0 11
56556: PUSH
56557: LD_VAR 0 11
56561: PPUSH
56562: LD_VAR 0 11
56566: PUSH
56567: LD_INT 1
56569: PLUS
56570: PPUSH
56571: LD_VAR 0 9
56575: PUSH
56576: LD_INT 1
56578: ARRAY
56579: PPUSH
56580: CALL_OW 2
56584: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56585: LD_ADDR_VAR 0 9
56589: PUSH
56590: LD_VAR 0 9
56594: PPUSH
56595: LD_INT 1
56597: PPUSH
56598: CALL_OW 3
56602: ST_TO_ADDR
// end ;
56603: GO 56549
56605: POP
56606: POP
// end else
56607: GO 56629
// if sort then
56609: LD_VAR 0 9
56613: IFFALSE 56629
// p := sort [ 1 ] ;
56615: LD_ADDR_VAR 0 11
56619: PUSH
56620: LD_VAR 0 9
56624: PUSH
56625: LD_INT 1
56627: ARRAY
56628: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56629: LD_ADDR_VAR 0 2
56633: PUSH
56634: LD_INT 0
56636: PUSH
56637: LD_INT 0
56639: PUSH
56640: LD_INT 0
56642: PUSH
56643: LD_VAR 0 11
56647: PUSH
56648: EMPTY
56649: LIST
56650: LIST
56651: LIST
56652: LIST
56653: ST_TO_ADDR
// exit ;
56654: GO 58875
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56656: LD_EXP 50
56660: PUSH
56661: LD_EXP 49
56665: PUSH
56666: LD_VAR 0 1
56670: ARRAY
56671: ARRAY
56672: PUSH
56673: LD_EXP 23
56677: PUSH
56678: LD_VAR 0 1
56682: ARRAY
56683: PPUSH
56684: LD_INT 2
56686: PUSH
56687: LD_INT 30
56689: PUSH
56690: LD_INT 6
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: PUSH
56697: LD_INT 30
56699: PUSH
56700: LD_INT 7
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PUSH
56707: LD_INT 30
56709: PUSH
56710: LD_INT 8
56712: PUSH
56713: EMPTY
56714: LIST
56715: LIST
56716: PUSH
56717: EMPTY
56718: LIST
56719: LIST
56720: LIST
56721: LIST
56722: PPUSH
56723: CALL_OW 72
56727: AND
56728: PUSH
56729: LD_EXP 23
56733: PUSH
56734: LD_VAR 0 1
56738: ARRAY
56739: PPUSH
56740: LD_INT 30
56742: PUSH
56743: LD_INT 3
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: PPUSH
56750: CALL_OW 72
56754: AND
56755: IFFALSE 57489
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56757: LD_ADDR_EXP 65
56761: PUSH
56762: LD_EXP 65
56766: PPUSH
56767: LD_VAR 0 1
56771: PPUSH
56772: LD_INT 3
56774: PPUSH
56775: CALL_OW 1
56779: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56780: LD_ADDR_VAR 0 2
56784: PUSH
56785: LD_INT 0
56787: PUSH
56788: LD_INT 0
56790: PUSH
56791: LD_INT 0
56793: PUSH
56794: LD_INT 0
56796: PUSH
56797: EMPTY
56798: LIST
56799: LIST
56800: LIST
56801: LIST
56802: ST_TO_ADDR
// if not eng then
56803: LD_VAR 0 6
56807: NOT
56808: IFFALSE 56871
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56810: LD_ADDR_VAR 0 11
56814: PUSH
56815: LD_VAR 0 4
56819: PPUSH
56820: LD_INT 2
56822: PPUSH
56823: CALL 46247 0 2
56827: PUSH
56828: LD_INT 1
56830: ARRAY
56831: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56832: LD_ADDR_VAR 0 2
56836: PUSH
56837: LD_VAR 0 2
56841: PPUSH
56842: LD_INT 2
56844: PPUSH
56845: LD_VAR 0 11
56849: PPUSH
56850: CALL_OW 1
56854: ST_TO_ADDR
// tmp := tmp diff p ;
56855: LD_ADDR_VAR 0 4
56859: PUSH
56860: LD_VAR 0 4
56864: PUSH
56865: LD_VAR 0 11
56869: DIFF
56870: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56871: LD_VAR 0 4
56875: PUSH
56876: LD_VAR 0 8
56880: PUSH
56881: LD_INT 6
56883: LESS
56884: AND
56885: IFFALSE 57073
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56887: LD_ADDR_VAR 0 9
56891: PUSH
56892: LD_VAR 0 4
56896: PUSH
56897: LD_VAR 0 8
56901: PUSH
56902: LD_VAR 0 7
56906: UNION
56907: DIFF
56908: PPUSH
56909: LD_INT 4
56911: PPUSH
56912: CALL 46247 0 2
56916: ST_TO_ADDR
// p := [ ] ;
56917: LD_ADDR_VAR 0 11
56921: PUSH
56922: EMPTY
56923: ST_TO_ADDR
// if sort then
56924: LD_VAR 0 9
56928: IFFALSE 57044
// for i = 1 to 6 - sci do
56930: LD_ADDR_VAR 0 3
56934: PUSH
56935: DOUBLE
56936: LD_INT 1
56938: DEC
56939: ST_TO_ADDR
56940: LD_INT 6
56942: PUSH
56943: LD_VAR 0 8
56947: MINUS
56948: PUSH
56949: FOR_TO
56950: IFFALSE 57042
// begin if i = sort then
56952: LD_VAR 0 3
56956: PUSH
56957: LD_VAR 0 9
56961: EQUAL
56962: IFFALSE 56966
// break ;
56964: GO 57042
// if GetClass ( i ) = 4 then
56966: LD_VAR 0 3
56970: PPUSH
56971: CALL_OW 257
56975: PUSH
56976: LD_INT 4
56978: EQUAL
56979: IFFALSE 56983
// continue ;
56981: GO 56949
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56983: LD_ADDR_VAR 0 11
56987: PUSH
56988: LD_VAR 0 11
56992: PPUSH
56993: LD_VAR 0 11
56997: PUSH
56998: LD_INT 1
57000: PLUS
57001: PPUSH
57002: LD_VAR 0 9
57006: PUSH
57007: LD_VAR 0 3
57011: ARRAY
57012: PPUSH
57013: CALL_OW 2
57017: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57018: LD_ADDR_VAR 0 4
57022: PUSH
57023: LD_VAR 0 4
57027: PUSH
57028: LD_VAR 0 9
57032: PUSH
57033: LD_VAR 0 3
57037: ARRAY
57038: DIFF
57039: ST_TO_ADDR
// end ;
57040: GO 56949
57042: POP
57043: POP
// if p then
57044: LD_VAR 0 11
57048: IFFALSE 57073
// result := Replace ( result , 4 , p ) ;
57050: LD_ADDR_VAR 0 2
57054: PUSH
57055: LD_VAR 0 2
57059: PPUSH
57060: LD_INT 4
57062: PPUSH
57063: LD_VAR 0 11
57067: PPUSH
57068: CALL_OW 1
57072: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57073: LD_VAR 0 4
57077: PUSH
57078: LD_VAR 0 7
57082: PUSH
57083: LD_INT 6
57085: LESS
57086: AND
57087: IFFALSE 57275
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57089: LD_ADDR_VAR 0 9
57093: PUSH
57094: LD_VAR 0 4
57098: PUSH
57099: LD_VAR 0 8
57103: PUSH
57104: LD_VAR 0 7
57108: UNION
57109: DIFF
57110: PPUSH
57111: LD_INT 3
57113: PPUSH
57114: CALL 46247 0 2
57118: ST_TO_ADDR
// p := [ ] ;
57119: LD_ADDR_VAR 0 11
57123: PUSH
57124: EMPTY
57125: ST_TO_ADDR
// if sort then
57126: LD_VAR 0 9
57130: IFFALSE 57246
// for i = 1 to 6 - mech do
57132: LD_ADDR_VAR 0 3
57136: PUSH
57137: DOUBLE
57138: LD_INT 1
57140: DEC
57141: ST_TO_ADDR
57142: LD_INT 6
57144: PUSH
57145: LD_VAR 0 7
57149: MINUS
57150: PUSH
57151: FOR_TO
57152: IFFALSE 57244
// begin if i = sort then
57154: LD_VAR 0 3
57158: PUSH
57159: LD_VAR 0 9
57163: EQUAL
57164: IFFALSE 57168
// break ;
57166: GO 57244
// if GetClass ( i ) = 3 then
57168: LD_VAR 0 3
57172: PPUSH
57173: CALL_OW 257
57177: PUSH
57178: LD_INT 3
57180: EQUAL
57181: IFFALSE 57185
// continue ;
57183: GO 57151
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57185: LD_ADDR_VAR 0 11
57189: PUSH
57190: LD_VAR 0 11
57194: PPUSH
57195: LD_VAR 0 11
57199: PUSH
57200: LD_INT 1
57202: PLUS
57203: PPUSH
57204: LD_VAR 0 9
57208: PUSH
57209: LD_VAR 0 3
57213: ARRAY
57214: PPUSH
57215: CALL_OW 2
57219: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57220: LD_ADDR_VAR 0 4
57224: PUSH
57225: LD_VAR 0 4
57229: PUSH
57230: LD_VAR 0 9
57234: PUSH
57235: LD_VAR 0 3
57239: ARRAY
57240: DIFF
57241: ST_TO_ADDR
// end ;
57242: GO 57151
57244: POP
57245: POP
// if p then
57246: LD_VAR 0 11
57250: IFFALSE 57275
// result := Replace ( result , 3 , p ) ;
57252: LD_ADDR_VAR 0 2
57256: PUSH
57257: LD_VAR 0 2
57261: PPUSH
57262: LD_INT 3
57264: PPUSH
57265: LD_VAR 0 11
57269: PPUSH
57270: CALL_OW 1
57274: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57275: LD_VAR 0 4
57279: PUSH
57280: LD_INT 6
57282: GREATER
57283: PUSH
57284: LD_VAR 0 6
57288: PUSH
57289: LD_INT 6
57291: LESS
57292: AND
57293: IFFALSE 57487
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57295: LD_ADDR_VAR 0 9
57299: PUSH
57300: LD_VAR 0 4
57304: PUSH
57305: LD_VAR 0 8
57309: PUSH
57310: LD_VAR 0 7
57314: UNION
57315: PUSH
57316: LD_VAR 0 6
57320: UNION
57321: DIFF
57322: PPUSH
57323: LD_INT 2
57325: PPUSH
57326: CALL 46247 0 2
57330: ST_TO_ADDR
// p := [ ] ;
57331: LD_ADDR_VAR 0 11
57335: PUSH
57336: EMPTY
57337: ST_TO_ADDR
// if sort then
57338: LD_VAR 0 9
57342: IFFALSE 57458
// for i = 1 to 6 - eng do
57344: LD_ADDR_VAR 0 3
57348: PUSH
57349: DOUBLE
57350: LD_INT 1
57352: DEC
57353: ST_TO_ADDR
57354: LD_INT 6
57356: PUSH
57357: LD_VAR 0 6
57361: MINUS
57362: PUSH
57363: FOR_TO
57364: IFFALSE 57456
// begin if i = sort then
57366: LD_VAR 0 3
57370: PUSH
57371: LD_VAR 0 9
57375: EQUAL
57376: IFFALSE 57380
// break ;
57378: GO 57456
// if GetClass ( i ) = 2 then
57380: LD_VAR 0 3
57384: PPUSH
57385: CALL_OW 257
57389: PUSH
57390: LD_INT 2
57392: EQUAL
57393: IFFALSE 57397
// continue ;
57395: GO 57363
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57397: LD_ADDR_VAR 0 11
57401: PUSH
57402: LD_VAR 0 11
57406: PPUSH
57407: LD_VAR 0 11
57411: PUSH
57412: LD_INT 1
57414: PLUS
57415: PPUSH
57416: LD_VAR 0 9
57420: PUSH
57421: LD_VAR 0 3
57425: ARRAY
57426: PPUSH
57427: CALL_OW 2
57431: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57432: LD_ADDR_VAR 0 4
57436: PUSH
57437: LD_VAR 0 4
57441: PUSH
57442: LD_VAR 0 9
57446: PUSH
57447: LD_VAR 0 3
57451: ARRAY
57452: DIFF
57453: ST_TO_ADDR
// end ;
57454: GO 57363
57456: POP
57457: POP
// if p then
57458: LD_VAR 0 11
57462: IFFALSE 57487
// result := Replace ( result , 2 , p ) ;
57464: LD_ADDR_VAR 0 2
57468: PUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: LD_INT 2
57476: PPUSH
57477: LD_VAR 0 11
57481: PPUSH
57482: CALL_OW 1
57486: ST_TO_ADDR
// end ; exit ;
57487: GO 58875
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57489: LD_EXP 50
57493: PUSH
57494: LD_EXP 49
57498: PUSH
57499: LD_VAR 0 1
57503: ARRAY
57504: ARRAY
57505: NOT
57506: PUSH
57507: LD_EXP 23
57511: PUSH
57512: LD_VAR 0 1
57516: ARRAY
57517: PPUSH
57518: LD_INT 30
57520: PUSH
57521: LD_INT 3
57523: PUSH
57524: EMPTY
57525: LIST
57526: LIST
57527: PPUSH
57528: CALL_OW 72
57532: AND
57533: PUSH
57534: LD_EXP 28
57538: PUSH
57539: LD_VAR 0 1
57543: ARRAY
57544: AND
57545: IFFALSE 58153
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57547: LD_ADDR_EXP 65
57551: PUSH
57552: LD_EXP 65
57556: PPUSH
57557: LD_VAR 0 1
57561: PPUSH
57562: LD_INT 5
57564: PPUSH
57565: CALL_OW 1
57569: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57570: LD_ADDR_VAR 0 2
57574: PUSH
57575: LD_INT 0
57577: PUSH
57578: LD_INT 0
57580: PUSH
57581: LD_INT 0
57583: PUSH
57584: LD_INT 0
57586: PUSH
57587: EMPTY
57588: LIST
57589: LIST
57590: LIST
57591: LIST
57592: ST_TO_ADDR
// if sci > 1 then
57593: LD_VAR 0 8
57597: PUSH
57598: LD_INT 1
57600: GREATER
57601: IFFALSE 57629
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57603: LD_ADDR_VAR 0 4
57607: PUSH
57608: LD_VAR 0 4
57612: PUSH
57613: LD_VAR 0 8
57617: PUSH
57618: LD_VAR 0 8
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: DIFF
57627: DIFF
57628: ST_TO_ADDR
// if tmp and not sci then
57629: LD_VAR 0 4
57633: PUSH
57634: LD_VAR 0 8
57638: NOT
57639: AND
57640: IFFALSE 57709
// begin sort := SortBySkill ( tmp , 4 ) ;
57642: LD_ADDR_VAR 0 9
57646: PUSH
57647: LD_VAR 0 4
57651: PPUSH
57652: LD_INT 4
57654: PPUSH
57655: CALL 46247 0 2
57659: ST_TO_ADDR
// if sort then
57660: LD_VAR 0 9
57664: IFFALSE 57680
// p := sort [ 1 ] ;
57666: LD_ADDR_VAR 0 11
57670: PUSH
57671: LD_VAR 0 9
57675: PUSH
57676: LD_INT 1
57678: ARRAY
57679: ST_TO_ADDR
// if p then
57680: LD_VAR 0 11
57684: IFFALSE 57709
// result := Replace ( result , 4 , p ) ;
57686: LD_ADDR_VAR 0 2
57690: PUSH
57691: LD_VAR 0 2
57695: PPUSH
57696: LD_INT 4
57698: PPUSH
57699: LD_VAR 0 11
57703: PPUSH
57704: CALL_OW 1
57708: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57709: LD_ADDR_VAR 0 4
57713: PUSH
57714: LD_VAR 0 4
57718: PUSH
57719: LD_VAR 0 7
57723: DIFF
57724: ST_TO_ADDR
// if tmp and mech < 6 then
57725: LD_VAR 0 4
57729: PUSH
57730: LD_VAR 0 7
57734: PUSH
57735: LD_INT 6
57737: LESS
57738: AND
57739: IFFALSE 57927
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57741: LD_ADDR_VAR 0 9
57745: PUSH
57746: LD_VAR 0 4
57750: PUSH
57751: LD_VAR 0 8
57755: PUSH
57756: LD_VAR 0 7
57760: UNION
57761: DIFF
57762: PPUSH
57763: LD_INT 3
57765: PPUSH
57766: CALL 46247 0 2
57770: ST_TO_ADDR
// p := [ ] ;
57771: LD_ADDR_VAR 0 11
57775: PUSH
57776: EMPTY
57777: ST_TO_ADDR
// if sort then
57778: LD_VAR 0 9
57782: IFFALSE 57898
// for i = 1 to 6 - mech do
57784: LD_ADDR_VAR 0 3
57788: PUSH
57789: DOUBLE
57790: LD_INT 1
57792: DEC
57793: ST_TO_ADDR
57794: LD_INT 6
57796: PUSH
57797: LD_VAR 0 7
57801: MINUS
57802: PUSH
57803: FOR_TO
57804: IFFALSE 57896
// begin if i = sort then
57806: LD_VAR 0 3
57810: PUSH
57811: LD_VAR 0 9
57815: EQUAL
57816: IFFALSE 57820
// break ;
57818: GO 57896
// if GetClass ( i ) = 3 then
57820: LD_VAR 0 3
57824: PPUSH
57825: CALL_OW 257
57829: PUSH
57830: LD_INT 3
57832: EQUAL
57833: IFFALSE 57837
// continue ;
57835: GO 57803
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57837: LD_ADDR_VAR 0 11
57841: PUSH
57842: LD_VAR 0 11
57846: PPUSH
57847: LD_VAR 0 11
57851: PUSH
57852: LD_INT 1
57854: PLUS
57855: PPUSH
57856: LD_VAR 0 9
57860: PUSH
57861: LD_VAR 0 3
57865: ARRAY
57866: PPUSH
57867: CALL_OW 2
57871: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57872: LD_ADDR_VAR 0 4
57876: PUSH
57877: LD_VAR 0 4
57881: PUSH
57882: LD_VAR 0 9
57886: PUSH
57887: LD_VAR 0 3
57891: ARRAY
57892: DIFF
57893: ST_TO_ADDR
// end ;
57894: GO 57803
57896: POP
57897: POP
// if p then
57898: LD_VAR 0 11
57902: IFFALSE 57927
// result := Replace ( result , 3 , p ) ;
57904: LD_ADDR_VAR 0 2
57908: PUSH
57909: LD_VAR 0 2
57913: PPUSH
57914: LD_INT 3
57916: PPUSH
57917: LD_VAR 0 11
57921: PPUSH
57922: CALL_OW 1
57926: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57927: LD_ADDR_VAR 0 4
57931: PUSH
57932: LD_VAR 0 4
57936: PUSH
57937: LD_VAR 0 6
57941: DIFF
57942: ST_TO_ADDR
// if tmp and eng < 6 then
57943: LD_VAR 0 4
57947: PUSH
57948: LD_VAR 0 6
57952: PUSH
57953: LD_INT 6
57955: LESS
57956: AND
57957: IFFALSE 58151
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57959: LD_ADDR_VAR 0 9
57963: PUSH
57964: LD_VAR 0 4
57968: PUSH
57969: LD_VAR 0 8
57973: PUSH
57974: LD_VAR 0 7
57978: UNION
57979: PUSH
57980: LD_VAR 0 6
57984: UNION
57985: DIFF
57986: PPUSH
57987: LD_INT 2
57989: PPUSH
57990: CALL 46247 0 2
57994: ST_TO_ADDR
// p := [ ] ;
57995: LD_ADDR_VAR 0 11
57999: PUSH
58000: EMPTY
58001: ST_TO_ADDR
// if sort then
58002: LD_VAR 0 9
58006: IFFALSE 58122
// for i = 1 to 6 - eng do
58008: LD_ADDR_VAR 0 3
58012: PUSH
58013: DOUBLE
58014: LD_INT 1
58016: DEC
58017: ST_TO_ADDR
58018: LD_INT 6
58020: PUSH
58021: LD_VAR 0 6
58025: MINUS
58026: PUSH
58027: FOR_TO
58028: IFFALSE 58120
// begin if i = sort then
58030: LD_VAR 0 3
58034: PUSH
58035: LD_VAR 0 9
58039: EQUAL
58040: IFFALSE 58044
// break ;
58042: GO 58120
// if GetClass ( i ) = 2 then
58044: LD_VAR 0 3
58048: PPUSH
58049: CALL_OW 257
58053: PUSH
58054: LD_INT 2
58056: EQUAL
58057: IFFALSE 58061
// continue ;
58059: GO 58027
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58061: LD_ADDR_VAR 0 11
58065: PUSH
58066: LD_VAR 0 11
58070: PPUSH
58071: LD_VAR 0 11
58075: PUSH
58076: LD_INT 1
58078: PLUS
58079: PPUSH
58080: LD_VAR 0 9
58084: PUSH
58085: LD_VAR 0 3
58089: ARRAY
58090: PPUSH
58091: CALL_OW 2
58095: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58096: LD_ADDR_VAR 0 4
58100: PUSH
58101: LD_VAR 0 4
58105: PUSH
58106: LD_VAR 0 9
58110: PUSH
58111: LD_VAR 0 3
58115: ARRAY
58116: DIFF
58117: ST_TO_ADDR
// end ;
58118: GO 58027
58120: POP
58121: POP
// if p then
58122: LD_VAR 0 11
58126: IFFALSE 58151
// result := Replace ( result , 2 , p ) ;
58128: LD_ADDR_VAR 0 2
58132: PUSH
58133: LD_VAR 0 2
58137: PPUSH
58138: LD_INT 2
58140: PPUSH
58141: LD_VAR 0 11
58145: PPUSH
58146: CALL_OW 1
58150: ST_TO_ADDR
// end ; exit ;
58151: GO 58875
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58153: LD_EXP 50
58157: PUSH
58158: LD_EXP 49
58162: PUSH
58163: LD_VAR 0 1
58167: ARRAY
58168: ARRAY
58169: NOT
58170: PUSH
58171: LD_EXP 23
58175: PUSH
58176: LD_VAR 0 1
58180: ARRAY
58181: PPUSH
58182: LD_INT 30
58184: PUSH
58185: LD_INT 3
58187: PUSH
58188: EMPTY
58189: LIST
58190: LIST
58191: PPUSH
58192: CALL_OW 72
58196: AND
58197: PUSH
58198: LD_EXP 28
58202: PUSH
58203: LD_VAR 0 1
58207: ARRAY
58208: NOT
58209: AND
58210: IFFALSE 58875
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58212: LD_ADDR_EXP 65
58216: PUSH
58217: LD_EXP 65
58221: PPUSH
58222: LD_VAR 0 1
58226: PPUSH
58227: LD_INT 6
58229: PPUSH
58230: CALL_OW 1
58234: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58235: LD_ADDR_VAR 0 2
58239: PUSH
58240: LD_INT 0
58242: PUSH
58243: LD_INT 0
58245: PUSH
58246: LD_INT 0
58248: PUSH
58249: LD_INT 0
58251: PUSH
58252: EMPTY
58253: LIST
58254: LIST
58255: LIST
58256: LIST
58257: ST_TO_ADDR
// if sci >= 1 then
58258: LD_VAR 0 8
58262: PUSH
58263: LD_INT 1
58265: GREATEREQUAL
58266: IFFALSE 58288
// tmp := tmp diff sci [ 1 ] ;
58268: LD_ADDR_VAR 0 4
58272: PUSH
58273: LD_VAR 0 4
58277: PUSH
58278: LD_VAR 0 8
58282: PUSH
58283: LD_INT 1
58285: ARRAY
58286: DIFF
58287: ST_TO_ADDR
// if tmp and not sci then
58288: LD_VAR 0 4
58292: PUSH
58293: LD_VAR 0 8
58297: NOT
58298: AND
58299: IFFALSE 58368
// begin sort := SortBySkill ( tmp , 4 ) ;
58301: LD_ADDR_VAR 0 9
58305: PUSH
58306: LD_VAR 0 4
58310: PPUSH
58311: LD_INT 4
58313: PPUSH
58314: CALL 46247 0 2
58318: ST_TO_ADDR
// if sort then
58319: LD_VAR 0 9
58323: IFFALSE 58339
// p := sort [ 1 ] ;
58325: LD_ADDR_VAR 0 11
58329: PUSH
58330: LD_VAR 0 9
58334: PUSH
58335: LD_INT 1
58337: ARRAY
58338: ST_TO_ADDR
// if p then
58339: LD_VAR 0 11
58343: IFFALSE 58368
// result := Replace ( result , 4 , p ) ;
58345: LD_ADDR_VAR 0 2
58349: PUSH
58350: LD_VAR 0 2
58354: PPUSH
58355: LD_INT 4
58357: PPUSH
58358: LD_VAR 0 11
58362: PPUSH
58363: CALL_OW 1
58367: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58368: LD_ADDR_VAR 0 4
58372: PUSH
58373: LD_VAR 0 4
58377: PUSH
58378: LD_VAR 0 7
58382: DIFF
58383: ST_TO_ADDR
// if tmp and mech < 6 then
58384: LD_VAR 0 4
58388: PUSH
58389: LD_VAR 0 7
58393: PUSH
58394: LD_INT 6
58396: LESS
58397: AND
58398: IFFALSE 58580
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58400: LD_ADDR_VAR 0 9
58404: PUSH
58405: LD_VAR 0 4
58409: PUSH
58410: LD_VAR 0 7
58414: DIFF
58415: PPUSH
58416: LD_INT 3
58418: PPUSH
58419: CALL 46247 0 2
58423: ST_TO_ADDR
// p := [ ] ;
58424: LD_ADDR_VAR 0 11
58428: PUSH
58429: EMPTY
58430: ST_TO_ADDR
// if sort then
58431: LD_VAR 0 9
58435: IFFALSE 58551
// for i = 1 to 6 - mech do
58437: LD_ADDR_VAR 0 3
58441: PUSH
58442: DOUBLE
58443: LD_INT 1
58445: DEC
58446: ST_TO_ADDR
58447: LD_INT 6
58449: PUSH
58450: LD_VAR 0 7
58454: MINUS
58455: PUSH
58456: FOR_TO
58457: IFFALSE 58549
// begin if i = sort then
58459: LD_VAR 0 3
58463: PUSH
58464: LD_VAR 0 9
58468: EQUAL
58469: IFFALSE 58473
// break ;
58471: GO 58549
// if GetClass ( i ) = 3 then
58473: LD_VAR 0 3
58477: PPUSH
58478: CALL_OW 257
58482: PUSH
58483: LD_INT 3
58485: EQUAL
58486: IFFALSE 58490
// continue ;
58488: GO 58456
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58490: LD_ADDR_VAR 0 11
58494: PUSH
58495: LD_VAR 0 11
58499: PPUSH
58500: LD_VAR 0 11
58504: PUSH
58505: LD_INT 1
58507: PLUS
58508: PPUSH
58509: LD_VAR 0 9
58513: PUSH
58514: LD_VAR 0 3
58518: ARRAY
58519: PPUSH
58520: CALL_OW 2
58524: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58525: LD_ADDR_VAR 0 4
58529: PUSH
58530: LD_VAR 0 4
58534: PUSH
58535: LD_VAR 0 9
58539: PUSH
58540: LD_VAR 0 3
58544: ARRAY
58545: DIFF
58546: ST_TO_ADDR
// end ;
58547: GO 58456
58549: POP
58550: POP
// if p then
58551: LD_VAR 0 11
58555: IFFALSE 58580
// result := Replace ( result , 3 , p ) ;
58557: LD_ADDR_VAR 0 2
58561: PUSH
58562: LD_VAR 0 2
58566: PPUSH
58567: LD_INT 3
58569: PPUSH
58570: LD_VAR 0 11
58574: PPUSH
58575: CALL_OW 1
58579: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58580: LD_ADDR_VAR 0 4
58584: PUSH
58585: LD_VAR 0 4
58589: PUSH
58590: LD_VAR 0 6
58594: DIFF
58595: ST_TO_ADDR
// if tmp and eng < 4 then
58596: LD_VAR 0 4
58600: PUSH
58601: LD_VAR 0 6
58605: PUSH
58606: LD_INT 4
58608: LESS
58609: AND
58610: IFFALSE 58800
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58612: LD_ADDR_VAR 0 9
58616: PUSH
58617: LD_VAR 0 4
58621: PUSH
58622: LD_VAR 0 7
58626: PUSH
58627: LD_VAR 0 6
58631: UNION
58632: DIFF
58633: PPUSH
58634: LD_INT 2
58636: PPUSH
58637: CALL 46247 0 2
58641: ST_TO_ADDR
// p := [ ] ;
58642: LD_ADDR_VAR 0 11
58646: PUSH
58647: EMPTY
58648: ST_TO_ADDR
// if sort then
58649: LD_VAR 0 9
58653: IFFALSE 58769
// for i = 1 to 4 - eng do
58655: LD_ADDR_VAR 0 3
58659: PUSH
58660: DOUBLE
58661: LD_INT 1
58663: DEC
58664: ST_TO_ADDR
58665: LD_INT 4
58667: PUSH
58668: LD_VAR 0 6
58672: MINUS
58673: PUSH
58674: FOR_TO
58675: IFFALSE 58767
// begin if i = sort then
58677: LD_VAR 0 3
58681: PUSH
58682: LD_VAR 0 9
58686: EQUAL
58687: IFFALSE 58691
// break ;
58689: GO 58767
// if GetClass ( i ) = 2 then
58691: LD_VAR 0 3
58695: PPUSH
58696: CALL_OW 257
58700: PUSH
58701: LD_INT 2
58703: EQUAL
58704: IFFALSE 58708
// continue ;
58706: GO 58674
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58708: LD_ADDR_VAR 0 11
58712: PUSH
58713: LD_VAR 0 11
58717: PPUSH
58718: LD_VAR 0 11
58722: PUSH
58723: LD_INT 1
58725: PLUS
58726: PPUSH
58727: LD_VAR 0 9
58731: PUSH
58732: LD_VAR 0 3
58736: ARRAY
58737: PPUSH
58738: CALL_OW 2
58742: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58743: LD_ADDR_VAR 0 4
58747: PUSH
58748: LD_VAR 0 4
58752: PUSH
58753: LD_VAR 0 9
58757: PUSH
58758: LD_VAR 0 3
58762: ARRAY
58763: DIFF
58764: ST_TO_ADDR
// end ;
58765: GO 58674
58767: POP
58768: POP
// if p then
58769: LD_VAR 0 11
58773: IFFALSE 58798
// result := Replace ( result , 2 , p ) ;
58775: LD_ADDR_VAR 0 2
58779: PUSH
58780: LD_VAR 0 2
58784: PPUSH
58785: LD_INT 2
58787: PPUSH
58788: LD_VAR 0 11
58792: PPUSH
58793: CALL_OW 1
58797: ST_TO_ADDR
// end else
58798: GO 58844
// for i = eng downto 5 do
58800: LD_ADDR_VAR 0 3
58804: PUSH
58805: DOUBLE
58806: LD_VAR 0 6
58810: INC
58811: ST_TO_ADDR
58812: LD_INT 5
58814: PUSH
58815: FOR_DOWNTO
58816: IFFALSE 58842
// tmp := tmp union eng [ i ] ;
58818: LD_ADDR_VAR 0 4
58822: PUSH
58823: LD_VAR 0 4
58827: PUSH
58828: LD_VAR 0 6
58832: PUSH
58833: LD_VAR 0 3
58837: ARRAY
58838: UNION
58839: ST_TO_ADDR
58840: GO 58815
58842: POP
58843: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58844: LD_ADDR_VAR 0 2
58848: PUSH
58849: LD_VAR 0 2
58853: PPUSH
58854: LD_INT 1
58856: PPUSH
58857: LD_VAR 0 4
58861: PUSH
58862: LD_VAR 0 5
58866: DIFF
58867: PPUSH
58868: CALL_OW 1
58872: ST_TO_ADDR
// exit ;
58873: GO 58875
// end ; end ;
58875: LD_VAR 0 2
58879: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58880: LD_INT 0
58882: PPUSH
58883: PPUSH
58884: PPUSH
// if not mc_bases then
58885: LD_EXP 23
58889: NOT
58890: IFFALSE 58894
// exit ;
58892: GO 59036
// for i = 1 to mc_bases do
58894: LD_ADDR_VAR 0 2
58898: PUSH
58899: DOUBLE
58900: LD_INT 1
58902: DEC
58903: ST_TO_ADDR
58904: LD_EXP 23
58908: PUSH
58909: FOR_TO
58910: IFFALSE 59027
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58912: LD_ADDR_VAR 0 3
58916: PUSH
58917: LD_EXP 23
58921: PUSH
58922: LD_VAR 0 2
58926: ARRAY
58927: PPUSH
58928: LD_INT 21
58930: PUSH
58931: LD_INT 3
58933: PUSH
58934: EMPTY
58935: LIST
58936: LIST
58937: PUSH
58938: LD_INT 3
58940: PUSH
58941: LD_INT 2
58943: PUSH
58944: LD_INT 30
58946: PUSH
58947: LD_INT 29
58949: PUSH
58950: EMPTY
58951: LIST
58952: LIST
58953: PUSH
58954: LD_INT 30
58956: PUSH
58957: LD_INT 30
58959: PUSH
58960: EMPTY
58961: LIST
58962: LIST
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: LIST
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PUSH
58973: LD_INT 3
58975: PUSH
58976: LD_INT 24
58978: PUSH
58979: LD_INT 1000
58981: PUSH
58982: EMPTY
58983: LIST
58984: LIST
58985: PUSH
58986: EMPTY
58987: LIST
58988: LIST
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: LIST
58994: PPUSH
58995: CALL_OW 72
58999: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59000: LD_ADDR_EXP 24
59004: PUSH
59005: LD_EXP 24
59009: PPUSH
59010: LD_VAR 0 2
59014: PPUSH
59015: LD_VAR 0 3
59019: PPUSH
59020: CALL_OW 1
59024: ST_TO_ADDR
// end ;
59025: GO 58909
59027: POP
59028: POP
// RaiseSailEvent ( 101 ) ;
59029: LD_INT 101
59031: PPUSH
59032: CALL_OW 427
// end ;
59036: LD_VAR 0 1
59040: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59041: LD_INT 0
59043: PPUSH
59044: PPUSH
59045: PPUSH
59046: PPUSH
59047: PPUSH
59048: PPUSH
59049: PPUSH
// if not mc_bases then
59050: LD_EXP 23
59054: NOT
59055: IFFALSE 59059
// exit ;
59057: GO 59621
// for i = 1 to mc_bases do
59059: LD_ADDR_VAR 0 2
59063: PUSH
59064: DOUBLE
59065: LD_INT 1
59067: DEC
59068: ST_TO_ADDR
59069: LD_EXP 23
59073: PUSH
59074: FOR_TO
59075: IFFALSE 59612
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
59077: LD_ADDR_VAR 0 5
59081: PUSH
59082: LD_EXP 23
59086: PUSH
59087: LD_VAR 0 2
59091: ARRAY
59092: PUSH
59093: LD_EXP 52
59097: PUSH
59098: LD_VAR 0 2
59102: ARRAY
59103: UNION
59104: PPUSH
59105: LD_INT 21
59107: PUSH
59108: LD_INT 1
59110: PUSH
59111: EMPTY
59112: LIST
59113: LIST
59114: PUSH
59115: LD_INT 1
59117: PUSH
59118: LD_INT 3
59120: PUSH
59121: LD_INT 54
59123: PUSH
59124: EMPTY
59125: LIST
59126: PUSH
59127: EMPTY
59128: LIST
59129: LIST
59130: PUSH
59131: LD_INT 3
59133: PUSH
59134: LD_INT 24
59136: PUSH
59137: LD_INT 1000
59139: PUSH
59140: EMPTY
59141: LIST
59142: LIST
59143: PUSH
59144: EMPTY
59145: LIST
59146: LIST
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: LIST
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PPUSH
59157: CALL_OW 72
59161: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59162: LD_ADDR_VAR 0 6
59166: PUSH
59167: LD_EXP 23
59171: PUSH
59172: LD_VAR 0 2
59176: ARRAY
59177: PPUSH
59178: LD_INT 21
59180: PUSH
59181: LD_INT 1
59183: PUSH
59184: EMPTY
59185: LIST
59186: LIST
59187: PUSH
59188: LD_INT 1
59190: PUSH
59191: LD_INT 3
59193: PUSH
59194: LD_INT 54
59196: PUSH
59197: EMPTY
59198: LIST
59199: PUSH
59200: EMPTY
59201: LIST
59202: LIST
59203: PUSH
59204: LD_INT 3
59206: PUSH
59207: LD_INT 24
59209: PUSH
59210: LD_INT 250
59212: PUSH
59213: EMPTY
59214: LIST
59215: LIST
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: PUSH
59221: EMPTY
59222: LIST
59223: LIST
59224: LIST
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PPUSH
59230: CALL_OW 72
59234: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59235: LD_ADDR_VAR 0 7
59239: PUSH
59240: LD_VAR 0 5
59244: PUSH
59245: LD_VAR 0 6
59249: DIFF
59250: ST_TO_ADDR
// if not need_heal_1 then
59251: LD_VAR 0 6
59255: NOT
59256: IFFALSE 59289
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59258: LD_ADDR_EXP 26
59262: PUSH
59263: LD_EXP 26
59267: PPUSH
59268: LD_VAR 0 2
59272: PUSH
59273: LD_INT 1
59275: PUSH
59276: EMPTY
59277: LIST
59278: LIST
59279: PPUSH
59280: EMPTY
59281: PPUSH
59282: CALL 15990 0 3
59286: ST_TO_ADDR
59287: GO 59359
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59289: LD_ADDR_EXP 26
59293: PUSH
59294: LD_EXP 26
59298: PPUSH
59299: LD_VAR 0 2
59303: PUSH
59304: LD_INT 1
59306: PUSH
59307: EMPTY
59308: LIST
59309: LIST
59310: PPUSH
59311: LD_EXP 26
59315: PUSH
59316: LD_VAR 0 2
59320: ARRAY
59321: PUSH
59322: LD_INT 1
59324: ARRAY
59325: PPUSH
59326: LD_INT 3
59328: PUSH
59329: LD_INT 24
59331: PUSH
59332: LD_INT 1000
59334: PUSH
59335: EMPTY
59336: LIST
59337: LIST
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: PPUSH
59343: CALL_OW 72
59347: PUSH
59348: LD_VAR 0 6
59352: UNION
59353: PPUSH
59354: CALL 15990 0 3
59358: ST_TO_ADDR
// if not need_heal_2 then
59359: LD_VAR 0 7
59363: NOT
59364: IFFALSE 59397
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59366: LD_ADDR_EXP 26
59370: PUSH
59371: LD_EXP 26
59375: PPUSH
59376: LD_VAR 0 2
59380: PUSH
59381: LD_INT 2
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PPUSH
59388: EMPTY
59389: PPUSH
59390: CALL 15990 0 3
59394: ST_TO_ADDR
59395: GO 59429
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59397: LD_ADDR_EXP 26
59401: PUSH
59402: LD_EXP 26
59406: PPUSH
59407: LD_VAR 0 2
59411: PUSH
59412: LD_INT 2
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PPUSH
59419: LD_VAR 0 7
59423: PPUSH
59424: CALL 15990 0 3
59428: ST_TO_ADDR
// if need_heal_2 then
59429: LD_VAR 0 7
59433: IFFALSE 59594
// for j in need_heal_2 do
59435: LD_ADDR_VAR 0 3
59439: PUSH
59440: LD_VAR 0 7
59444: PUSH
59445: FOR_IN
59446: IFFALSE 59592
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59448: LD_ADDR_VAR 0 5
59452: PUSH
59453: LD_EXP 23
59457: PUSH
59458: LD_VAR 0 2
59462: ARRAY
59463: PPUSH
59464: LD_INT 2
59466: PUSH
59467: LD_INT 30
59469: PUSH
59470: LD_INT 6
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: PUSH
59477: LD_INT 30
59479: PUSH
59480: LD_INT 7
59482: PUSH
59483: EMPTY
59484: LIST
59485: LIST
59486: PUSH
59487: LD_INT 30
59489: PUSH
59490: LD_INT 8
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 30
59499: PUSH
59500: LD_INT 0
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: LD_INT 30
59509: PUSH
59510: LD_INT 1
59512: PUSH
59513: EMPTY
59514: LIST
59515: LIST
59516: PUSH
59517: EMPTY
59518: LIST
59519: LIST
59520: LIST
59521: LIST
59522: LIST
59523: LIST
59524: PPUSH
59525: CALL_OW 72
59529: ST_TO_ADDR
// if tmp then
59530: LD_VAR 0 5
59534: IFFALSE 59590
// begin k := NearestUnitToUnit ( tmp , j ) ;
59536: LD_ADDR_VAR 0 4
59540: PUSH
59541: LD_VAR 0 5
59545: PPUSH
59546: LD_VAR 0 3
59550: PPUSH
59551: CALL_OW 74
59555: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59556: LD_VAR 0 3
59560: PPUSH
59561: LD_VAR 0 4
59565: PPUSH
59566: CALL_OW 296
59570: PUSH
59571: LD_INT 5
59573: GREATER
59574: IFFALSE 59590
// ComMoveToNearbyEntrance ( j , k ) ;
59576: LD_VAR 0 3
59580: PPUSH
59581: LD_VAR 0 4
59585: PPUSH
59586: CALL 48608 0 2
// end ; end ;
59590: GO 59445
59592: POP
59593: POP
// if not need_heal_1 and not need_heal_2 then
59594: LD_VAR 0 6
59598: NOT
59599: PUSH
59600: LD_VAR 0 7
59604: NOT
59605: AND
59606: IFFALSE 59610
// continue ;
59608: GO 59074
// end ;
59610: GO 59074
59612: POP
59613: POP
// RaiseSailEvent ( 102 ) ;
59614: LD_INT 102
59616: PPUSH
59617: CALL_OW 427
// end ;
59621: LD_VAR 0 1
59625: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59626: LD_INT 0
59628: PPUSH
59629: PPUSH
59630: PPUSH
59631: PPUSH
59632: PPUSH
59633: PPUSH
59634: PPUSH
59635: PPUSH
// if not mc_bases then
59636: LD_EXP 23
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 60528
// for i = 1 to mc_bases do
59645: LD_ADDR_VAR 0 2
59649: PUSH
59650: DOUBLE
59651: LD_INT 1
59653: DEC
59654: ST_TO_ADDR
59655: LD_EXP 23
59659: PUSH
59660: FOR_TO
59661: IFFALSE 60526
// begin if not mc_building_need_repair [ i ] then
59663: LD_EXP 24
59667: PUSH
59668: LD_VAR 0 2
59672: ARRAY
59673: NOT
59674: IFFALSE 59861
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
59676: LD_ADDR_VAR 0 6
59680: PUSH
59681: LD_EXP 42
59685: PUSH
59686: LD_VAR 0 2
59690: ARRAY
59691: PPUSH
59692: LD_INT 3
59694: PUSH
59695: LD_INT 24
59697: PUSH
59698: LD_INT 1000
59700: PUSH
59701: EMPTY
59702: LIST
59703: LIST
59704: PUSH
59705: EMPTY
59706: LIST
59707: LIST
59708: PUSH
59709: LD_INT 2
59711: PUSH
59712: LD_INT 34
59714: PUSH
59715: LD_INT 13
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: LD_INT 34
59724: PUSH
59725: LD_INT 52
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: PUSH
59732: LD_INT 34
59734: PUSH
59735: LD_EXP 73
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: LIST
59748: LIST
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PPUSH
59754: CALL_OW 72
59758: ST_TO_ADDR
// if cranes then
59759: LD_VAR 0 6
59763: IFFALSE 59825
// for j in cranes do
59765: LD_ADDR_VAR 0 3
59769: PUSH
59770: LD_VAR 0 6
59774: PUSH
59775: FOR_IN
59776: IFFALSE 59823
// if not IsInArea ( j , mc_parking [ i ] ) then
59778: LD_VAR 0 3
59782: PPUSH
59783: LD_EXP 47
59787: PUSH
59788: LD_VAR 0 2
59792: ARRAY
59793: PPUSH
59794: CALL_OW 308
59798: NOT
59799: IFFALSE 59821
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59801: LD_VAR 0 3
59805: PPUSH
59806: LD_EXP 47
59810: PUSH
59811: LD_VAR 0 2
59815: ARRAY
59816: PPUSH
59817: CALL_OW 113
59821: GO 59775
59823: POP
59824: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59825: LD_ADDR_EXP 25
59829: PUSH
59830: LD_EXP 25
59834: PPUSH
59835: LD_VAR 0 2
59839: PPUSH
59840: EMPTY
59841: PPUSH
59842: CALL_OW 1
59846: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59847: LD_VAR 0 2
59851: PPUSH
59852: LD_INT 101
59854: PPUSH
59855: CALL 54713 0 2
// continue ;
59859: GO 59660
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59861: LD_ADDR_EXP 29
59865: PUSH
59866: LD_EXP 29
59870: PPUSH
59871: LD_VAR 0 2
59875: PPUSH
59876: EMPTY
59877: PPUSH
59878: CALL_OW 1
59882: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59883: LD_VAR 0 2
59887: PPUSH
59888: LD_INT 103
59890: PPUSH
59891: CALL 54713 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
59895: LD_ADDR_VAR 0 5
59899: PUSH
59900: LD_EXP 23
59904: PUSH
59905: LD_VAR 0 2
59909: ARRAY
59910: PUSH
59911: LD_EXP 52
59915: PUSH
59916: LD_VAR 0 2
59920: ARRAY
59921: UNION
59922: PPUSH
59923: LD_INT 2
59925: PUSH
59926: LD_INT 25
59928: PUSH
59929: LD_INT 2
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PUSH
59936: LD_INT 25
59938: PUSH
59939: LD_INT 16
59941: PUSH
59942: EMPTY
59943: LIST
59944: LIST
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: LIST
59950: PUSH
59951: EMPTY
59952: LIST
59953: PPUSH
59954: CALL_OW 72
59958: ST_TO_ADDR
// if mc_need_heal [ i ] then
59959: LD_EXP 26
59963: PUSH
59964: LD_VAR 0 2
59968: ARRAY
59969: IFFALSE 60013
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59971: LD_ADDR_VAR 0 5
59975: PUSH
59976: LD_VAR 0 5
59980: PUSH
59981: LD_EXP 26
59985: PUSH
59986: LD_VAR 0 2
59990: ARRAY
59991: PUSH
59992: LD_INT 1
59994: ARRAY
59995: PUSH
59996: LD_EXP 26
60000: PUSH
60001: LD_VAR 0 2
60005: ARRAY
60006: PUSH
60007: LD_INT 2
60009: ARRAY
60010: UNION
60011: DIFF
60012: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60013: LD_ADDR_VAR 0 6
60017: PUSH
60018: LD_EXP 42
60022: PUSH
60023: LD_VAR 0 2
60027: ARRAY
60028: PPUSH
60029: LD_INT 2
60031: PUSH
60032: LD_INT 34
60034: PUSH
60035: LD_INT 13
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PUSH
60042: LD_INT 34
60044: PUSH
60045: LD_INT 52
60047: PUSH
60048: EMPTY
60049: LIST
60050: LIST
60051: PUSH
60052: LD_INT 34
60054: PUSH
60055: LD_EXP 73
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: PUSH
60064: EMPTY
60065: LIST
60066: LIST
60067: LIST
60068: LIST
60069: PPUSH
60070: CALL_OW 72
60074: ST_TO_ADDR
// if cranes then
60075: LD_VAR 0 6
60079: IFFALSE 60215
// begin for j in cranes do
60081: LD_ADDR_VAR 0 3
60085: PUSH
60086: LD_VAR 0 6
60090: PUSH
60091: FOR_IN
60092: IFFALSE 60213
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60094: LD_VAR 0 3
60098: PPUSH
60099: CALL_OW 256
60103: PUSH
60104: LD_INT 1000
60106: EQUAL
60107: PUSH
60108: LD_VAR 0 3
60112: PPUSH
60113: CALL_OW 314
60117: NOT
60118: AND
60119: IFFALSE 60153
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60121: LD_VAR 0 3
60125: PPUSH
60126: LD_EXP 24
60130: PUSH
60131: LD_VAR 0 2
60135: ARRAY
60136: PPUSH
60137: LD_VAR 0 3
60141: PPUSH
60142: CALL_OW 74
60146: PPUSH
60147: CALL_OW 130
60151: GO 60211
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60153: LD_VAR 0 3
60157: PPUSH
60158: CALL_OW 256
60162: PUSH
60163: LD_INT 500
60165: LESS
60166: PUSH
60167: LD_VAR 0 3
60171: PPUSH
60172: LD_EXP 47
60176: PUSH
60177: LD_VAR 0 2
60181: ARRAY
60182: PPUSH
60183: CALL_OW 308
60187: NOT
60188: AND
60189: IFFALSE 60211
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60191: LD_VAR 0 3
60195: PPUSH
60196: LD_EXP 47
60200: PUSH
60201: LD_VAR 0 2
60205: ARRAY
60206: PPUSH
60207: CALL_OW 113
// end ;
60211: GO 60091
60213: POP
60214: POP
// end ; if tmp > 3 then
60215: LD_VAR 0 5
60219: PUSH
60220: LD_INT 3
60222: GREATER
60223: IFFALSE 60243
// tmp := ShrinkArray ( tmp , 4 ) ;
60225: LD_ADDR_VAR 0 5
60229: PUSH
60230: LD_VAR 0 5
60234: PPUSH
60235: LD_INT 4
60237: PPUSH
60238: CALL 48056 0 2
60242: ST_TO_ADDR
// if not tmp then
60243: LD_VAR 0 5
60247: NOT
60248: IFFALSE 60252
// continue ;
60250: GO 59660
// for j in tmp do
60252: LD_ADDR_VAR 0 3
60256: PUSH
60257: LD_VAR 0 5
60261: PUSH
60262: FOR_IN
60263: IFFALSE 60522
// begin if IsInUnit ( j ) then
60265: LD_VAR 0 3
60269: PPUSH
60270: CALL_OW 310
60274: IFFALSE 60285
// ComExitBuilding ( j ) ;
60276: LD_VAR 0 3
60280: PPUSH
60281: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60285: LD_VAR 0 3
60289: PUSH
60290: LD_EXP 25
60294: PUSH
60295: LD_VAR 0 2
60299: ARRAY
60300: IN
60301: NOT
60302: IFFALSE 60360
// begin SetTag ( j , 101 ) ;
60304: LD_VAR 0 3
60308: PPUSH
60309: LD_INT 101
60311: PPUSH
60312: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60316: LD_ADDR_EXP 25
60320: PUSH
60321: LD_EXP 25
60325: PPUSH
60326: LD_VAR 0 2
60330: PUSH
60331: LD_EXP 25
60335: PUSH
60336: LD_VAR 0 2
60340: ARRAY
60341: PUSH
60342: LD_INT 1
60344: PLUS
60345: PUSH
60346: EMPTY
60347: LIST
60348: LIST
60349: PPUSH
60350: LD_VAR 0 3
60354: PPUSH
60355: CALL 15990 0 3
60359: ST_TO_ADDR
// end ; wait ( 1 ) ;
60360: LD_INT 1
60362: PPUSH
60363: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60367: LD_ADDR_VAR 0 7
60371: PUSH
60372: LD_EXP 24
60376: PUSH
60377: LD_VAR 0 2
60381: ARRAY
60382: ST_TO_ADDR
// if mc_scan [ i ] then
60383: LD_EXP 46
60387: PUSH
60388: LD_VAR 0 2
60392: ARRAY
60393: IFFALSE 60455
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60395: LD_ADDR_VAR 0 7
60399: PUSH
60400: LD_EXP 24
60404: PUSH
60405: LD_VAR 0 2
60409: ARRAY
60410: PPUSH
60411: LD_INT 3
60413: PUSH
60414: LD_INT 30
60416: PUSH
60417: LD_INT 32
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 30
60426: PUSH
60427: LD_INT 33
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PUSH
60434: LD_INT 30
60436: PUSH
60437: LD_INT 31
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: LIST
60448: LIST
60449: PPUSH
60450: CALL_OW 72
60454: ST_TO_ADDR
// if not to_repair_tmp then
60455: LD_VAR 0 7
60459: NOT
60460: IFFALSE 60464
// continue ;
60462: GO 60262
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60464: LD_ADDR_VAR 0 8
60468: PUSH
60469: LD_VAR 0 7
60473: PPUSH
60474: LD_VAR 0 3
60478: PPUSH
60479: CALL_OW 74
60483: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
60484: LD_VAR 0 8
60488: PPUSH
60489: LD_INT 16
60491: PPUSH
60492: CALL 18589 0 2
60496: PUSH
60497: LD_INT 4
60499: ARRAY
60500: PUSH
60501: LD_INT 10
60503: LESS
60504: IFFALSE 60520
// ComRepairBuilding ( j , to_repair ) ;
60506: LD_VAR 0 3
60510: PPUSH
60511: LD_VAR 0 8
60515: PPUSH
60516: CALL_OW 130
// end ;
60520: GO 60262
60522: POP
60523: POP
// end ;
60524: GO 59660
60526: POP
60527: POP
// end ;
60528: LD_VAR 0 1
60532: RET
// export function MC_Heal ; var i , j , tmp ; begin
60533: LD_INT 0
60535: PPUSH
60536: PPUSH
60537: PPUSH
60538: PPUSH
// if not mc_bases then
60539: LD_EXP 23
60543: NOT
60544: IFFALSE 60548
// exit ;
60546: GO 60950
// for i = 1 to mc_bases do
60548: LD_ADDR_VAR 0 2
60552: PUSH
60553: DOUBLE
60554: LD_INT 1
60556: DEC
60557: ST_TO_ADDR
60558: LD_EXP 23
60562: PUSH
60563: FOR_TO
60564: IFFALSE 60948
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60566: LD_EXP 26
60570: PUSH
60571: LD_VAR 0 2
60575: ARRAY
60576: PUSH
60577: LD_INT 1
60579: ARRAY
60580: NOT
60581: PUSH
60582: LD_EXP 26
60586: PUSH
60587: LD_VAR 0 2
60591: ARRAY
60592: PUSH
60593: LD_INT 2
60595: ARRAY
60596: NOT
60597: AND
60598: IFFALSE 60636
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60600: LD_ADDR_EXP 27
60604: PUSH
60605: LD_EXP 27
60609: PPUSH
60610: LD_VAR 0 2
60614: PPUSH
60615: EMPTY
60616: PPUSH
60617: CALL_OW 1
60621: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60622: LD_VAR 0 2
60626: PPUSH
60627: LD_INT 102
60629: PPUSH
60630: CALL 54713 0 2
// continue ;
60634: GO 60563
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60636: LD_ADDR_VAR 0 4
60640: PUSH
60641: LD_EXP 23
60645: PUSH
60646: LD_VAR 0 2
60650: ARRAY
60651: PPUSH
60652: LD_INT 25
60654: PUSH
60655: LD_INT 4
60657: PUSH
60658: EMPTY
60659: LIST
60660: LIST
60661: PPUSH
60662: CALL_OW 72
60666: ST_TO_ADDR
// if not tmp then
60667: LD_VAR 0 4
60671: NOT
60672: IFFALSE 60676
// continue ;
60674: GO 60563
// if mc_taming [ i ] then
60676: LD_EXP 54
60680: PUSH
60681: LD_VAR 0 2
60685: ARRAY
60686: IFFALSE 60710
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60688: LD_ADDR_EXP 54
60692: PUSH
60693: LD_EXP 54
60697: PPUSH
60698: LD_VAR 0 2
60702: PPUSH
60703: EMPTY
60704: PPUSH
60705: CALL_OW 1
60709: ST_TO_ADDR
// for j in tmp do
60710: LD_ADDR_VAR 0 3
60714: PUSH
60715: LD_VAR 0 4
60719: PUSH
60720: FOR_IN
60721: IFFALSE 60944
// begin if IsInUnit ( j ) then
60723: LD_VAR 0 3
60727: PPUSH
60728: CALL_OW 310
60732: IFFALSE 60743
// ComExitBuilding ( j ) ;
60734: LD_VAR 0 3
60738: PPUSH
60739: CALL_OW 122
// if not j in mc_healers [ i ] then
60743: LD_VAR 0 3
60747: PUSH
60748: LD_EXP 27
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: IN
60759: NOT
60760: IFFALSE 60806
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60762: LD_ADDR_EXP 27
60766: PUSH
60767: LD_EXP 27
60771: PPUSH
60772: LD_VAR 0 2
60776: PUSH
60777: LD_EXP 27
60781: PUSH
60782: LD_VAR 0 2
60786: ARRAY
60787: PUSH
60788: LD_INT 1
60790: PLUS
60791: PUSH
60792: EMPTY
60793: LIST
60794: LIST
60795: PPUSH
60796: LD_VAR 0 3
60800: PPUSH
60801: CALL 15990 0 3
60805: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60806: LD_VAR 0 3
60810: PPUSH
60811: CALL_OW 110
60815: PUSH
60816: LD_INT 102
60818: NONEQUAL
60819: IFFALSE 60833
// SetTag ( j , 102 ) ;
60821: LD_VAR 0 3
60825: PPUSH
60826: LD_INT 102
60828: PPUSH
60829: CALL_OW 109
// Wait ( 3 ) ;
60833: LD_INT 3
60835: PPUSH
60836: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60840: LD_EXP 26
60844: PUSH
60845: LD_VAR 0 2
60849: ARRAY
60850: PUSH
60851: LD_INT 1
60853: ARRAY
60854: IFFALSE 60886
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60856: LD_VAR 0 3
60860: PPUSH
60861: LD_EXP 26
60865: PUSH
60866: LD_VAR 0 2
60870: ARRAY
60871: PUSH
60872: LD_INT 1
60874: ARRAY
60875: PUSH
60876: LD_INT 1
60878: ARRAY
60879: PPUSH
60880: CALL_OW 128
60884: GO 60942
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60886: LD_VAR 0 3
60890: PPUSH
60891: CALL_OW 314
60895: NOT
60896: PUSH
60897: LD_EXP 26
60901: PUSH
60902: LD_VAR 0 2
60906: ARRAY
60907: PUSH
60908: LD_INT 2
60910: ARRAY
60911: AND
60912: IFFALSE 60942
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60914: LD_VAR 0 3
60918: PPUSH
60919: LD_EXP 26
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: PUSH
60930: LD_INT 2
60932: ARRAY
60933: PUSH
60934: LD_INT 1
60936: ARRAY
60937: PPUSH
60938: CALL_OW 128
// end ;
60942: GO 60720
60944: POP
60945: POP
// end ;
60946: GO 60563
60948: POP
60949: POP
// end ;
60950: LD_VAR 0 1
60954: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60955: LD_INT 0
60957: PPUSH
60958: PPUSH
60959: PPUSH
60960: PPUSH
60961: PPUSH
// if not mc_bases then
60962: LD_EXP 23
60966: NOT
60967: IFFALSE 60971
// exit ;
60969: GO 62142
// for i = 1 to mc_bases do
60971: LD_ADDR_VAR 0 2
60975: PUSH
60976: DOUBLE
60977: LD_INT 1
60979: DEC
60980: ST_TO_ADDR
60981: LD_EXP 23
60985: PUSH
60986: FOR_TO
60987: IFFALSE 62140
// begin if mc_scan [ i ] then
60989: LD_EXP 46
60993: PUSH
60994: LD_VAR 0 2
60998: ARRAY
60999: IFFALSE 61003
// continue ;
61001: GO 60986
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61003: LD_EXP 28
61007: PUSH
61008: LD_VAR 0 2
61012: ARRAY
61013: NOT
61014: PUSH
61015: LD_EXP 30
61019: PUSH
61020: LD_VAR 0 2
61024: ARRAY
61025: NOT
61026: AND
61027: PUSH
61028: LD_EXP 29
61032: PUSH
61033: LD_VAR 0 2
61037: ARRAY
61038: AND
61039: IFFALSE 61077
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61041: LD_ADDR_EXP 29
61045: PUSH
61046: LD_EXP 29
61050: PPUSH
61051: LD_VAR 0 2
61055: PPUSH
61056: EMPTY
61057: PPUSH
61058: CALL_OW 1
61062: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61063: LD_VAR 0 2
61067: PPUSH
61068: LD_INT 103
61070: PPUSH
61071: CALL 54713 0 2
// continue ;
61075: GO 60986
// end ; if mc_construct_list [ i ] then
61077: LD_EXP 30
61081: PUSH
61082: LD_VAR 0 2
61086: ARRAY
61087: IFFALSE 61307
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61089: LD_ADDR_VAR 0 4
61093: PUSH
61094: LD_EXP 23
61098: PUSH
61099: LD_VAR 0 2
61103: ARRAY
61104: PPUSH
61105: LD_INT 25
61107: PUSH
61108: LD_INT 2
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PPUSH
61115: CALL_OW 72
61119: PUSH
61120: LD_EXP 25
61124: PUSH
61125: LD_VAR 0 2
61129: ARRAY
61130: DIFF
61131: ST_TO_ADDR
// if not tmp then
61132: LD_VAR 0 4
61136: NOT
61137: IFFALSE 61141
// continue ;
61139: GO 60986
// for j in tmp do
61141: LD_ADDR_VAR 0 3
61145: PUSH
61146: LD_VAR 0 4
61150: PUSH
61151: FOR_IN
61152: IFFALSE 61303
// begin if not mc_builders [ i ] then
61154: LD_EXP 29
61158: PUSH
61159: LD_VAR 0 2
61163: ARRAY
61164: NOT
61165: IFFALSE 61223
// begin SetTag ( j , 103 ) ;
61167: LD_VAR 0 3
61171: PPUSH
61172: LD_INT 103
61174: PPUSH
61175: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61179: LD_ADDR_EXP 29
61183: PUSH
61184: LD_EXP 29
61188: PPUSH
61189: LD_VAR 0 2
61193: PUSH
61194: LD_EXP 29
61198: PUSH
61199: LD_VAR 0 2
61203: ARRAY
61204: PUSH
61205: LD_INT 1
61207: PLUS
61208: PUSH
61209: EMPTY
61210: LIST
61211: LIST
61212: PPUSH
61213: LD_VAR 0 3
61217: PPUSH
61218: CALL 15990 0 3
61222: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61223: LD_VAR 0 3
61227: PPUSH
61228: CALL_OW 310
61232: IFFALSE 61243
// ComExitBuilding ( j ) ;
61234: LD_VAR 0 3
61238: PPUSH
61239: CALL_OW 122
// wait ( 3 ) ;
61243: LD_INT 3
61245: PPUSH
61246: CALL_OW 67
// if not mc_construct_list [ i ] then
61250: LD_EXP 30
61254: PUSH
61255: LD_VAR 0 2
61259: ARRAY
61260: NOT
61261: IFFALSE 61265
// break ;
61263: GO 61303
// if not HasTask ( j ) then
61265: LD_VAR 0 3
61269: PPUSH
61270: CALL_OW 314
61274: NOT
61275: IFFALSE 61301
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61277: LD_VAR 0 3
61281: PPUSH
61282: LD_EXP 30
61286: PUSH
61287: LD_VAR 0 2
61291: ARRAY
61292: PUSH
61293: LD_INT 1
61295: ARRAY
61296: PPUSH
61297: CALL 18853 0 2
// end ;
61301: GO 61151
61303: POP
61304: POP
// end else
61305: GO 62138
// if mc_build_list [ i ] then
61307: LD_EXP 28
61311: PUSH
61312: LD_VAR 0 2
61316: ARRAY
61317: IFFALSE 62138
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61319: LD_ADDR_VAR 0 5
61323: PUSH
61324: LD_EXP 23
61328: PUSH
61329: LD_VAR 0 2
61333: ARRAY
61334: PPUSH
61335: LD_INT 2
61337: PUSH
61338: LD_INT 30
61340: PUSH
61341: LD_INT 0
61343: PUSH
61344: EMPTY
61345: LIST
61346: LIST
61347: PUSH
61348: LD_INT 30
61350: PUSH
61351: LD_INT 1
61353: PUSH
61354: EMPTY
61355: LIST
61356: LIST
61357: PUSH
61358: EMPTY
61359: LIST
61360: LIST
61361: LIST
61362: PPUSH
61363: CALL_OW 72
61367: ST_TO_ADDR
// if depot then
61368: LD_VAR 0 5
61372: IFFALSE 61390
// depot := depot [ 1 ] else
61374: LD_ADDR_VAR 0 5
61378: PUSH
61379: LD_VAR 0 5
61383: PUSH
61384: LD_INT 1
61386: ARRAY
61387: ST_TO_ADDR
61388: GO 61398
// depot := 0 ;
61390: LD_ADDR_VAR 0 5
61394: PUSH
61395: LD_INT 0
61397: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61398: LD_EXP 28
61402: PUSH
61403: LD_VAR 0 2
61407: ARRAY
61408: PUSH
61409: LD_INT 1
61411: ARRAY
61412: PUSH
61413: LD_INT 1
61415: ARRAY
61416: PPUSH
61417: CALL 18677 0 1
61421: PUSH
61422: LD_EXP 23
61426: PUSH
61427: LD_VAR 0 2
61431: ARRAY
61432: PPUSH
61433: LD_INT 2
61435: PUSH
61436: LD_INT 30
61438: PUSH
61439: LD_INT 2
61441: PUSH
61442: EMPTY
61443: LIST
61444: LIST
61445: PUSH
61446: LD_INT 30
61448: PUSH
61449: LD_INT 3
61451: PUSH
61452: EMPTY
61453: LIST
61454: LIST
61455: PUSH
61456: EMPTY
61457: LIST
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL_OW 72
61465: NOT
61466: AND
61467: IFFALSE 61572
// begin for j = 1 to mc_build_list [ i ] do
61469: LD_ADDR_VAR 0 3
61473: PUSH
61474: DOUBLE
61475: LD_INT 1
61477: DEC
61478: ST_TO_ADDR
61479: LD_EXP 28
61483: PUSH
61484: LD_VAR 0 2
61488: ARRAY
61489: PUSH
61490: FOR_TO
61491: IFFALSE 61570
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61493: LD_EXP 28
61497: PUSH
61498: LD_VAR 0 2
61502: ARRAY
61503: PUSH
61504: LD_VAR 0 3
61508: ARRAY
61509: PUSH
61510: LD_INT 1
61512: ARRAY
61513: PUSH
61514: LD_INT 2
61516: EQUAL
61517: IFFALSE 61568
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61519: LD_ADDR_EXP 28
61523: PUSH
61524: LD_EXP 28
61528: PPUSH
61529: LD_VAR 0 2
61533: PPUSH
61534: LD_EXP 28
61538: PUSH
61539: LD_VAR 0 2
61543: ARRAY
61544: PPUSH
61545: LD_VAR 0 3
61549: PPUSH
61550: LD_INT 1
61552: PPUSH
61553: LD_INT 0
61555: PPUSH
61556: CALL 15408 0 4
61560: PPUSH
61561: CALL_OW 1
61565: ST_TO_ADDR
// break ;
61566: GO 61570
// end ;
61568: GO 61490
61570: POP
61571: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61572: LD_EXP 28
61576: PUSH
61577: LD_VAR 0 2
61581: ARRAY
61582: PUSH
61583: LD_INT 1
61585: ARRAY
61586: PUSH
61587: LD_INT 1
61589: ARRAY
61590: PUSH
61591: LD_INT 0
61593: EQUAL
61594: PUSH
61595: LD_VAR 0 5
61599: PUSH
61600: LD_VAR 0 5
61604: PPUSH
61605: LD_EXP 28
61609: PUSH
61610: LD_VAR 0 2
61614: ARRAY
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PUSH
61620: LD_INT 1
61622: ARRAY
61623: PPUSH
61624: LD_EXP 28
61628: PUSH
61629: LD_VAR 0 2
61633: ARRAY
61634: PUSH
61635: LD_INT 1
61637: ARRAY
61638: PUSH
61639: LD_INT 2
61641: ARRAY
61642: PPUSH
61643: LD_EXP 28
61647: PUSH
61648: LD_VAR 0 2
61652: ARRAY
61653: PUSH
61654: LD_INT 1
61656: ARRAY
61657: PUSH
61658: LD_INT 3
61660: ARRAY
61661: PPUSH
61662: LD_EXP 28
61666: PUSH
61667: LD_VAR 0 2
61671: ARRAY
61672: PUSH
61673: LD_INT 1
61675: ARRAY
61676: PUSH
61677: LD_INT 4
61679: ARRAY
61680: PPUSH
61681: CALL 24093 0 5
61685: AND
61686: OR
61687: IFFALSE 61968
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61689: LD_ADDR_VAR 0 4
61693: PUSH
61694: LD_EXP 23
61698: PUSH
61699: LD_VAR 0 2
61703: ARRAY
61704: PPUSH
61705: LD_INT 25
61707: PUSH
61708: LD_INT 2
61710: PUSH
61711: EMPTY
61712: LIST
61713: LIST
61714: PPUSH
61715: CALL_OW 72
61719: PUSH
61720: LD_EXP 25
61724: PUSH
61725: LD_VAR 0 2
61729: ARRAY
61730: DIFF
61731: ST_TO_ADDR
// if not tmp then
61732: LD_VAR 0 4
61736: NOT
61737: IFFALSE 61741
// continue ;
61739: GO 60986
// for j in tmp do
61741: LD_ADDR_VAR 0 3
61745: PUSH
61746: LD_VAR 0 4
61750: PUSH
61751: FOR_IN
61752: IFFALSE 61964
// begin if not mc_builders [ i ] then
61754: LD_EXP 29
61758: PUSH
61759: LD_VAR 0 2
61763: ARRAY
61764: NOT
61765: IFFALSE 61823
// begin SetTag ( j , 103 ) ;
61767: LD_VAR 0 3
61771: PPUSH
61772: LD_INT 103
61774: PPUSH
61775: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61779: LD_ADDR_EXP 29
61783: PUSH
61784: LD_EXP 29
61788: PPUSH
61789: LD_VAR 0 2
61793: PUSH
61794: LD_EXP 29
61798: PUSH
61799: LD_VAR 0 2
61803: ARRAY
61804: PUSH
61805: LD_INT 1
61807: PLUS
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PPUSH
61813: LD_VAR 0 3
61817: PPUSH
61818: CALL 15990 0 3
61822: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61823: LD_VAR 0 3
61827: PPUSH
61828: CALL_OW 310
61832: IFFALSE 61843
// ComExitBuilding ( j ) ;
61834: LD_VAR 0 3
61838: PPUSH
61839: CALL_OW 122
// wait ( 3 ) ;
61843: LD_INT 3
61845: PPUSH
61846: CALL_OW 67
// if not mc_build_list [ i ] then
61850: LD_EXP 28
61854: PUSH
61855: LD_VAR 0 2
61859: ARRAY
61860: NOT
61861: IFFALSE 61865
// break ;
61863: GO 61964
// if not HasTask ( j ) then
61865: LD_VAR 0 3
61869: PPUSH
61870: CALL_OW 314
61874: NOT
61875: IFFALSE 61962
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61877: LD_VAR 0 3
61881: PPUSH
61882: LD_EXP 28
61886: PUSH
61887: LD_VAR 0 2
61891: ARRAY
61892: PUSH
61893: LD_INT 1
61895: ARRAY
61896: PUSH
61897: LD_INT 1
61899: ARRAY
61900: PPUSH
61901: LD_EXP 28
61905: PUSH
61906: LD_VAR 0 2
61910: ARRAY
61911: PUSH
61912: LD_INT 1
61914: ARRAY
61915: PUSH
61916: LD_INT 2
61918: ARRAY
61919: PPUSH
61920: LD_EXP 28
61924: PUSH
61925: LD_VAR 0 2
61929: ARRAY
61930: PUSH
61931: LD_INT 1
61933: ARRAY
61934: PUSH
61935: LD_INT 3
61937: ARRAY
61938: PPUSH
61939: LD_EXP 28
61943: PUSH
61944: LD_VAR 0 2
61948: ARRAY
61949: PUSH
61950: LD_INT 1
61952: ARRAY
61953: PUSH
61954: LD_INT 4
61956: ARRAY
61957: PPUSH
61958: CALL_OW 145
// end ;
61962: GO 61751
61964: POP
61965: POP
// end else
61966: GO 62138
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
61968: LD_EXP 23
61972: PUSH
61973: LD_VAR 0 2
61977: ARRAY
61978: PPUSH
61979: LD_EXP 28
61983: PUSH
61984: LD_VAR 0 2
61988: ARRAY
61989: PUSH
61990: LD_INT 1
61992: ARRAY
61993: PUSH
61994: LD_INT 1
61996: ARRAY
61997: PPUSH
61998: LD_EXP 28
62002: PUSH
62003: LD_VAR 0 2
62007: ARRAY
62008: PUSH
62009: LD_INT 1
62011: ARRAY
62012: PUSH
62013: LD_INT 2
62015: ARRAY
62016: PPUSH
62017: LD_EXP 28
62021: PUSH
62022: LD_VAR 0 2
62026: ARRAY
62027: PUSH
62028: LD_INT 1
62030: ARRAY
62031: PUSH
62032: LD_INT 3
62034: ARRAY
62035: PPUSH
62036: LD_EXP 28
62040: PUSH
62041: LD_VAR 0 2
62045: ARRAY
62046: PUSH
62047: LD_INT 1
62049: ARRAY
62050: PUSH
62051: LD_INT 4
62053: ARRAY
62054: PPUSH
62055: LD_EXP 23
62059: PUSH
62060: LD_VAR 0 2
62064: ARRAY
62065: PPUSH
62066: LD_INT 21
62068: PUSH
62069: LD_INT 3
62071: PUSH
62072: EMPTY
62073: LIST
62074: LIST
62075: PPUSH
62076: CALL_OW 72
62080: PPUSH
62081: EMPTY
62082: PPUSH
62083: CALL 22843 0 7
62087: NOT
62088: IFFALSE 62138
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62090: LD_ADDR_EXP 28
62094: PUSH
62095: LD_EXP 28
62099: PPUSH
62100: LD_VAR 0 2
62104: PPUSH
62105: LD_EXP 28
62109: PUSH
62110: LD_VAR 0 2
62114: ARRAY
62115: PPUSH
62116: LD_INT 1
62118: PPUSH
62119: LD_INT 1
62121: NEG
62122: PPUSH
62123: LD_INT 0
62125: PPUSH
62126: CALL 15408 0 4
62130: PPUSH
62131: CALL_OW 1
62135: ST_TO_ADDR
// continue ;
62136: GO 60986
// end ; end ; end ;
62138: GO 60986
62140: POP
62141: POP
// end ;
62142: LD_VAR 0 1
62146: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62147: LD_INT 0
62149: PPUSH
62150: PPUSH
62151: PPUSH
62152: PPUSH
62153: PPUSH
62154: PPUSH
// if not mc_bases then
62155: LD_EXP 23
62159: NOT
62160: IFFALSE 62164
// exit ;
62162: GO 62591
// for i = 1 to mc_bases do
62164: LD_ADDR_VAR 0 2
62168: PUSH
62169: DOUBLE
62170: LD_INT 1
62172: DEC
62173: ST_TO_ADDR
62174: LD_EXP 23
62178: PUSH
62179: FOR_TO
62180: IFFALSE 62589
// begin tmp := mc_build_upgrade [ i ] ;
62182: LD_ADDR_VAR 0 4
62186: PUSH
62187: LD_EXP 55
62191: PUSH
62192: LD_VAR 0 2
62196: ARRAY
62197: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62198: LD_ADDR_VAR 0 6
62202: PUSH
62203: LD_EXP 56
62207: PUSH
62208: LD_VAR 0 2
62212: ARRAY
62213: PPUSH
62214: LD_INT 2
62216: PUSH
62217: LD_INT 30
62219: PUSH
62220: LD_INT 6
62222: PUSH
62223: EMPTY
62224: LIST
62225: LIST
62226: PUSH
62227: LD_INT 30
62229: PUSH
62230: LD_INT 7
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: EMPTY
62238: LIST
62239: LIST
62240: LIST
62241: PPUSH
62242: CALL_OW 72
62246: ST_TO_ADDR
// if not tmp and not lab then
62247: LD_VAR 0 4
62251: NOT
62252: PUSH
62253: LD_VAR 0 6
62257: NOT
62258: AND
62259: IFFALSE 62263
// continue ;
62261: GO 62179
// if tmp then
62263: LD_VAR 0 4
62267: IFFALSE 62387
// for j in tmp do
62269: LD_ADDR_VAR 0 3
62273: PUSH
62274: LD_VAR 0 4
62278: PUSH
62279: FOR_IN
62280: IFFALSE 62385
// begin if UpgradeCost ( j ) then
62282: LD_VAR 0 3
62286: PPUSH
62287: CALL 22503 0 1
62291: IFFALSE 62383
// begin ComUpgrade ( j ) ;
62293: LD_VAR 0 3
62297: PPUSH
62298: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62302: LD_ADDR_EXP 55
62306: PUSH
62307: LD_EXP 55
62311: PPUSH
62312: LD_VAR 0 2
62316: PPUSH
62317: LD_EXP 55
62321: PUSH
62322: LD_VAR 0 2
62326: ARRAY
62327: PUSH
62328: LD_VAR 0 3
62332: DIFF
62333: PPUSH
62334: CALL_OW 1
62338: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62339: LD_ADDR_EXP 30
62343: PUSH
62344: LD_EXP 30
62348: PPUSH
62349: LD_VAR 0 2
62353: PUSH
62354: LD_EXP 30
62358: PUSH
62359: LD_VAR 0 2
62363: ARRAY
62364: PUSH
62365: LD_INT 1
62367: PLUS
62368: PUSH
62369: EMPTY
62370: LIST
62371: LIST
62372: PPUSH
62373: LD_VAR 0 3
62377: PPUSH
62378: CALL 15990 0 3
62382: ST_TO_ADDR
// end ; end ;
62383: GO 62279
62385: POP
62386: POP
// if not lab or not mc_lab_upgrade [ i ] then
62387: LD_VAR 0 6
62391: NOT
62392: PUSH
62393: LD_EXP 57
62397: PUSH
62398: LD_VAR 0 2
62402: ARRAY
62403: NOT
62404: OR
62405: IFFALSE 62409
// continue ;
62407: GO 62179
// for j in lab do
62409: LD_ADDR_VAR 0 3
62413: PUSH
62414: LD_VAR 0 6
62418: PUSH
62419: FOR_IN
62420: IFFALSE 62585
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62422: LD_VAR 0 3
62426: PPUSH
62427: CALL_OW 266
62431: PUSH
62432: LD_INT 6
62434: PUSH
62435: LD_INT 7
62437: PUSH
62438: EMPTY
62439: LIST
62440: LIST
62441: IN
62442: PUSH
62443: LD_VAR 0 3
62447: PPUSH
62448: CALL_OW 461
62452: PUSH
62453: LD_INT 1
62455: NONEQUAL
62456: AND
62457: IFFALSE 62583
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62459: LD_VAR 0 3
62463: PPUSH
62464: LD_EXP 57
62468: PUSH
62469: LD_VAR 0 2
62473: ARRAY
62474: PUSH
62475: LD_INT 1
62477: ARRAY
62478: PPUSH
62479: CALL 22708 0 2
62483: IFFALSE 62583
// begin ComCancel ( j ) ;
62485: LD_VAR 0 3
62489: PPUSH
62490: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62494: LD_VAR 0 3
62498: PPUSH
62499: LD_EXP 57
62503: PUSH
62504: LD_VAR 0 2
62508: ARRAY
62509: PUSH
62510: LD_INT 1
62512: ARRAY
62513: PPUSH
62514: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62518: LD_VAR 0 3
62522: PUSH
62523: LD_EXP 30
62527: PUSH
62528: LD_VAR 0 2
62532: ARRAY
62533: IN
62534: NOT
62535: IFFALSE 62581
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62537: LD_ADDR_EXP 30
62541: PUSH
62542: LD_EXP 30
62546: PPUSH
62547: LD_VAR 0 2
62551: PUSH
62552: LD_EXP 30
62556: PUSH
62557: LD_VAR 0 2
62561: ARRAY
62562: PUSH
62563: LD_INT 1
62565: PLUS
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: PPUSH
62571: LD_VAR 0 3
62575: PPUSH
62576: CALL 15990 0 3
62580: ST_TO_ADDR
// break ;
62581: GO 62585
// end ; end ; end ;
62583: GO 62419
62585: POP
62586: POP
// end ;
62587: GO 62179
62589: POP
62590: POP
// end ;
62591: LD_VAR 0 1
62595: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62596: LD_INT 0
62598: PPUSH
62599: PPUSH
62600: PPUSH
62601: PPUSH
62602: PPUSH
62603: PPUSH
62604: PPUSH
62605: PPUSH
62606: PPUSH
// if not mc_bases then
62607: LD_EXP 23
62611: NOT
62612: IFFALSE 62616
// exit ;
62614: GO 63021
// for i = 1 to mc_bases do
62616: LD_ADDR_VAR 0 2
62620: PUSH
62621: DOUBLE
62622: LD_INT 1
62624: DEC
62625: ST_TO_ADDR
62626: LD_EXP 23
62630: PUSH
62631: FOR_TO
62632: IFFALSE 63019
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62634: LD_EXP 31
62638: PUSH
62639: LD_VAR 0 2
62643: ARRAY
62644: NOT
62645: PUSH
62646: LD_EXP 23
62650: PUSH
62651: LD_VAR 0 2
62655: ARRAY
62656: PPUSH
62657: LD_INT 30
62659: PUSH
62660: LD_INT 3
62662: PUSH
62663: EMPTY
62664: LIST
62665: LIST
62666: PPUSH
62667: CALL_OW 72
62671: NOT
62672: OR
62673: IFFALSE 62677
// continue ;
62675: GO 62631
// busy := false ;
62677: LD_ADDR_VAR 0 8
62681: PUSH
62682: LD_INT 0
62684: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62685: LD_ADDR_VAR 0 4
62689: PUSH
62690: LD_EXP 23
62694: PUSH
62695: LD_VAR 0 2
62699: ARRAY
62700: PPUSH
62701: LD_INT 30
62703: PUSH
62704: LD_INT 3
62706: PUSH
62707: EMPTY
62708: LIST
62709: LIST
62710: PPUSH
62711: CALL_OW 72
62715: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62716: LD_ADDR_VAR 0 6
62720: PUSH
62721: LD_EXP 31
62725: PUSH
62726: LD_VAR 0 2
62730: ARRAY
62731: PPUSH
62732: LD_INT 2
62734: PUSH
62735: LD_INT 30
62737: PUSH
62738: LD_INT 32
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: LD_INT 30
62747: PUSH
62748: LD_INT 33
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: PUSH
62755: EMPTY
62756: LIST
62757: LIST
62758: LIST
62759: PPUSH
62760: CALL_OW 72
62764: ST_TO_ADDR
// if not t then
62765: LD_VAR 0 6
62769: NOT
62770: IFFALSE 62774
// continue ;
62772: GO 62631
// for j in tmp do
62774: LD_ADDR_VAR 0 3
62778: PUSH
62779: LD_VAR 0 4
62783: PUSH
62784: FOR_IN
62785: IFFALSE 62815
// if not BuildingStatus ( j ) = bs_idle then
62787: LD_VAR 0 3
62791: PPUSH
62792: CALL_OW 461
62796: PUSH
62797: LD_INT 2
62799: EQUAL
62800: NOT
62801: IFFALSE 62813
// begin busy := true ;
62803: LD_ADDR_VAR 0 8
62807: PUSH
62808: LD_INT 1
62810: ST_TO_ADDR
// break ;
62811: GO 62815
// end ;
62813: GO 62784
62815: POP
62816: POP
// if busy then
62817: LD_VAR 0 8
62821: IFFALSE 62825
// continue ;
62823: GO 62631
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62825: LD_ADDR_VAR 0 7
62829: PUSH
62830: LD_VAR 0 6
62834: PPUSH
62835: LD_INT 35
62837: PUSH
62838: LD_INT 0
62840: PUSH
62841: EMPTY
62842: LIST
62843: LIST
62844: PPUSH
62845: CALL_OW 72
62849: ST_TO_ADDR
// if tw then
62850: LD_VAR 0 7
62854: IFFALSE 62931
// begin tw := tw [ 1 ] ;
62856: LD_ADDR_VAR 0 7
62860: PUSH
62861: LD_VAR 0 7
62865: PUSH
62866: LD_INT 1
62868: ARRAY
62869: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62870: LD_ADDR_VAR 0 9
62874: PUSH
62875: LD_VAR 0 7
62879: PPUSH
62880: LD_EXP 48
62884: PUSH
62885: LD_VAR 0 2
62889: ARRAY
62890: PPUSH
62891: CALL 21000 0 2
62895: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62896: LD_EXP 62
62900: PUSH
62901: LD_VAR 0 2
62905: ARRAY
62906: IFFALSE 62929
// if not weapon in mc_allowed_tower_weapons [ i ] then
62908: LD_VAR 0 9
62912: PUSH
62913: LD_EXP 62
62917: PUSH
62918: LD_VAR 0 2
62922: ARRAY
62923: IN
62924: NOT
62925: IFFALSE 62929
// continue ;
62927: GO 62631
// end else
62929: GO 62994
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62931: LD_ADDR_VAR 0 5
62935: PUSH
62936: LD_EXP 31
62940: PUSH
62941: LD_VAR 0 2
62945: ARRAY
62946: PPUSH
62947: LD_VAR 0 4
62951: PPUSH
62952: CALL 47289 0 2
62956: ST_TO_ADDR
// if not tmp2 then
62957: LD_VAR 0 5
62961: NOT
62962: IFFALSE 62966
// continue ;
62964: GO 62631
// tw := tmp2 [ 1 ] ;
62966: LD_ADDR_VAR 0 7
62970: PUSH
62971: LD_VAR 0 5
62975: PUSH
62976: LD_INT 1
62978: ARRAY
62979: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62980: LD_ADDR_VAR 0 9
62984: PUSH
62985: LD_VAR 0 5
62989: PUSH
62990: LD_INT 2
62992: ARRAY
62993: ST_TO_ADDR
// end ; if not weapon then
62994: LD_VAR 0 9
62998: NOT
62999: IFFALSE 63003
// continue ;
63001: GO 62631
// ComPlaceWeapon ( tw , weapon ) ;
63003: LD_VAR 0 7
63007: PPUSH
63008: LD_VAR 0 9
63012: PPUSH
63013: CALL_OW 148
// end ;
63017: GO 62631
63019: POP
63020: POP
// end ;
63021: LD_VAR 0 1
63025: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
63026: LD_INT 0
63028: PPUSH
63029: PPUSH
63030: PPUSH
63031: PPUSH
63032: PPUSH
63033: PPUSH
63034: PPUSH
// if not mc_bases then
63035: LD_EXP 23
63039: NOT
63040: IFFALSE 63044
// exit ;
63042: GO 63812
// for i = 1 to mc_bases do
63044: LD_ADDR_VAR 0 2
63048: PUSH
63049: DOUBLE
63050: LD_INT 1
63052: DEC
63053: ST_TO_ADDR
63054: LD_EXP 23
63058: PUSH
63059: FOR_TO
63060: IFFALSE 63810
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63062: LD_EXP 36
63066: PUSH
63067: LD_VAR 0 2
63071: ARRAY
63072: NOT
63073: PUSH
63074: LD_EXP 36
63078: PUSH
63079: LD_VAR 0 2
63083: ARRAY
63084: PUSH
63085: LD_EXP 37
63089: PUSH
63090: LD_VAR 0 2
63094: ARRAY
63095: EQUAL
63096: OR
63097: PUSH
63098: LD_EXP 46
63102: PUSH
63103: LD_VAR 0 2
63107: ARRAY
63108: OR
63109: IFFALSE 63113
// continue ;
63111: GO 63059
// if mc_miners [ i ] then
63113: LD_EXP 37
63117: PUSH
63118: LD_VAR 0 2
63122: ARRAY
63123: IFFALSE 63497
// begin for j = mc_miners [ i ] downto 1 do
63125: LD_ADDR_VAR 0 3
63129: PUSH
63130: DOUBLE
63131: LD_EXP 37
63135: PUSH
63136: LD_VAR 0 2
63140: ARRAY
63141: INC
63142: ST_TO_ADDR
63143: LD_INT 1
63145: PUSH
63146: FOR_DOWNTO
63147: IFFALSE 63495
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63149: LD_EXP 37
63153: PUSH
63154: LD_VAR 0 2
63158: ARRAY
63159: PUSH
63160: LD_VAR 0 3
63164: ARRAY
63165: PPUSH
63166: CALL_OW 301
63170: PUSH
63171: LD_EXP 37
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: PUSH
63182: LD_VAR 0 3
63186: ARRAY
63187: PPUSH
63188: CALL_OW 257
63192: PUSH
63193: LD_INT 1
63195: NONEQUAL
63196: OR
63197: IFFALSE 63260
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63199: LD_ADDR_VAR 0 5
63203: PUSH
63204: LD_EXP 37
63208: PUSH
63209: LD_VAR 0 2
63213: ARRAY
63214: PUSH
63215: LD_EXP 37
63219: PUSH
63220: LD_VAR 0 2
63224: ARRAY
63225: PUSH
63226: LD_VAR 0 3
63230: ARRAY
63231: DIFF
63232: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63233: LD_ADDR_EXP 37
63237: PUSH
63238: LD_EXP 37
63242: PPUSH
63243: LD_VAR 0 2
63247: PPUSH
63248: LD_VAR 0 5
63252: PPUSH
63253: CALL_OW 1
63257: ST_TO_ADDR
// continue ;
63258: GO 63146
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63260: LD_EXP 37
63264: PUSH
63265: LD_VAR 0 2
63269: ARRAY
63270: PUSH
63271: LD_VAR 0 3
63275: ARRAY
63276: PPUSH
63277: CALL_OW 257
63281: PUSH
63282: LD_INT 1
63284: EQUAL
63285: PUSH
63286: LD_EXP 37
63290: PUSH
63291: LD_VAR 0 2
63295: ARRAY
63296: PUSH
63297: LD_VAR 0 3
63301: ARRAY
63302: PPUSH
63303: CALL_OW 459
63307: NOT
63308: AND
63309: PUSH
63310: LD_EXP 37
63314: PUSH
63315: LD_VAR 0 2
63319: ARRAY
63320: PUSH
63321: LD_VAR 0 3
63325: ARRAY
63326: PPUSH
63327: CALL_OW 314
63331: NOT
63332: AND
63333: IFFALSE 63493
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63335: LD_EXP 37
63339: PUSH
63340: LD_VAR 0 2
63344: ARRAY
63345: PUSH
63346: LD_VAR 0 3
63350: ARRAY
63351: PPUSH
63352: CALL_OW 310
63356: IFFALSE 63379
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63358: LD_EXP 37
63362: PUSH
63363: LD_VAR 0 2
63367: ARRAY
63368: PUSH
63369: LD_VAR 0 3
63373: ARRAY
63374: PPUSH
63375: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63379: LD_EXP 37
63383: PUSH
63384: LD_VAR 0 2
63388: ARRAY
63389: PUSH
63390: LD_VAR 0 3
63394: ARRAY
63395: PPUSH
63396: CALL_OW 314
63400: NOT
63401: IFFALSE 63493
// begin r := rand ( 1 , mc_mines [ i ] ) ;
63403: LD_ADDR_VAR 0 7
63407: PUSH
63408: LD_INT 1
63410: PPUSH
63411: LD_EXP 36
63415: PUSH
63416: LD_VAR 0 2
63420: ARRAY
63421: PPUSH
63422: CALL_OW 12
63426: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
63427: LD_EXP 37
63431: PUSH
63432: LD_VAR 0 2
63436: ARRAY
63437: PUSH
63438: LD_VAR 0 3
63442: ARRAY
63443: PPUSH
63444: LD_EXP 36
63448: PUSH
63449: LD_VAR 0 2
63453: ARRAY
63454: PUSH
63455: LD_VAR 0 7
63459: ARRAY
63460: PUSH
63461: LD_INT 1
63463: ARRAY
63464: PPUSH
63465: LD_EXP 36
63469: PUSH
63470: LD_VAR 0 2
63474: ARRAY
63475: PUSH
63476: LD_VAR 0 7
63480: ARRAY
63481: PUSH
63482: LD_INT 2
63484: ARRAY
63485: PPUSH
63486: LD_INT 0
63488: PPUSH
63489: CALL_OW 193
// end ; end ; end ;
63493: GO 63146
63495: POP
63496: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63497: LD_ADDR_VAR 0 5
63501: PUSH
63502: LD_EXP 23
63506: PUSH
63507: LD_VAR 0 2
63511: ARRAY
63512: PPUSH
63513: LD_INT 2
63515: PUSH
63516: LD_INT 30
63518: PUSH
63519: LD_INT 4
63521: PUSH
63522: EMPTY
63523: LIST
63524: LIST
63525: PUSH
63526: LD_INT 30
63528: PUSH
63529: LD_INT 5
63531: PUSH
63532: EMPTY
63533: LIST
63534: LIST
63535: PUSH
63536: LD_INT 30
63538: PUSH
63539: LD_INT 32
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: EMPTY
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: PPUSH
63552: CALL_OW 72
63556: ST_TO_ADDR
// if not tmp then
63557: LD_VAR 0 5
63561: NOT
63562: IFFALSE 63566
// continue ;
63564: GO 63059
// list := [ ] ;
63566: LD_ADDR_VAR 0 6
63570: PUSH
63571: EMPTY
63572: ST_TO_ADDR
// for j in tmp do
63573: LD_ADDR_VAR 0 3
63577: PUSH
63578: LD_VAR 0 5
63582: PUSH
63583: FOR_IN
63584: IFFALSE 63653
// begin for k in UnitsInside ( j ) do
63586: LD_ADDR_VAR 0 4
63590: PUSH
63591: LD_VAR 0 3
63595: PPUSH
63596: CALL_OW 313
63600: PUSH
63601: FOR_IN
63602: IFFALSE 63649
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63604: LD_VAR 0 4
63608: PPUSH
63609: CALL_OW 257
63613: PUSH
63614: LD_INT 1
63616: EQUAL
63617: PUSH
63618: LD_VAR 0 4
63622: PPUSH
63623: CALL_OW 459
63627: NOT
63628: AND
63629: IFFALSE 63647
// list := list ^ k ;
63631: LD_ADDR_VAR 0 6
63635: PUSH
63636: LD_VAR 0 6
63640: PUSH
63641: LD_VAR 0 4
63645: ADD
63646: ST_TO_ADDR
63647: GO 63601
63649: POP
63650: POP
// end ;
63651: GO 63583
63653: POP
63654: POP
// list := list diff mc_miners [ i ] ;
63655: LD_ADDR_VAR 0 6
63659: PUSH
63660: LD_VAR 0 6
63664: PUSH
63665: LD_EXP 37
63669: PUSH
63670: LD_VAR 0 2
63674: ARRAY
63675: DIFF
63676: ST_TO_ADDR
// if not list then
63677: LD_VAR 0 6
63681: NOT
63682: IFFALSE 63686
// continue ;
63684: GO 63059
// k := mc_mines [ i ] - mc_miners [ i ] ;
63686: LD_ADDR_VAR 0 4
63690: PUSH
63691: LD_EXP 36
63695: PUSH
63696: LD_VAR 0 2
63700: ARRAY
63701: PUSH
63702: LD_EXP 37
63706: PUSH
63707: LD_VAR 0 2
63711: ARRAY
63712: MINUS
63713: ST_TO_ADDR
// if k > list then
63714: LD_VAR 0 4
63718: PUSH
63719: LD_VAR 0 6
63723: GREATER
63724: IFFALSE 63736
// k := list ;
63726: LD_ADDR_VAR 0 4
63730: PUSH
63731: LD_VAR 0 6
63735: ST_TO_ADDR
// for j = 1 to k do
63736: LD_ADDR_VAR 0 3
63740: PUSH
63741: DOUBLE
63742: LD_INT 1
63744: DEC
63745: ST_TO_ADDR
63746: LD_VAR 0 4
63750: PUSH
63751: FOR_TO
63752: IFFALSE 63806
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63754: LD_ADDR_EXP 37
63758: PUSH
63759: LD_EXP 37
63763: PPUSH
63764: LD_VAR 0 2
63768: PUSH
63769: LD_EXP 37
63773: PUSH
63774: LD_VAR 0 2
63778: ARRAY
63779: PUSH
63780: LD_INT 1
63782: PLUS
63783: PUSH
63784: EMPTY
63785: LIST
63786: LIST
63787: PPUSH
63788: LD_VAR 0 6
63792: PUSH
63793: LD_VAR 0 3
63797: ARRAY
63798: PPUSH
63799: CALL 15990 0 3
63803: ST_TO_ADDR
63804: GO 63751
63806: POP
63807: POP
// end ;
63808: GO 63059
63810: POP
63811: POP
// end ;
63812: LD_VAR 0 1
63816: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
63817: LD_INT 0
63819: PPUSH
63820: PPUSH
63821: PPUSH
63822: PPUSH
63823: PPUSH
63824: PPUSH
63825: PPUSH
63826: PPUSH
63827: PPUSH
63828: PPUSH
63829: PPUSH
// if not mc_bases then
63830: LD_EXP 23
63834: NOT
63835: IFFALSE 63839
// exit ;
63837: GO 65662
// for i = 1 to mc_bases do
63839: LD_ADDR_VAR 0 2
63843: PUSH
63844: DOUBLE
63845: LD_INT 1
63847: DEC
63848: ST_TO_ADDR
63849: LD_EXP 23
63853: PUSH
63854: FOR_TO
63855: IFFALSE 65660
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63857: LD_EXP 23
63861: PUSH
63862: LD_VAR 0 2
63866: ARRAY
63867: NOT
63868: PUSH
63869: LD_EXP 30
63873: PUSH
63874: LD_VAR 0 2
63878: ARRAY
63879: OR
63880: IFFALSE 63884
// continue ;
63882: GO 63854
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63884: LD_EXP 39
63888: PUSH
63889: LD_VAR 0 2
63893: ARRAY
63894: NOT
63895: PUSH
63896: LD_EXP 40
63900: PUSH
63901: LD_VAR 0 2
63905: ARRAY
63906: AND
63907: IFFALSE 63945
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63909: LD_ADDR_EXP 40
63913: PUSH
63914: LD_EXP 40
63918: PPUSH
63919: LD_VAR 0 2
63923: PPUSH
63924: EMPTY
63925: PPUSH
63926: CALL_OW 1
63930: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63931: LD_VAR 0 2
63935: PPUSH
63936: LD_INT 107
63938: PPUSH
63939: CALL 54713 0 2
// continue ;
63943: GO 63854
// end ; target := [ ] ;
63945: LD_ADDR_VAR 0 7
63949: PUSH
63950: EMPTY
63951: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
63952: LD_ADDR_VAR 0 6
63956: PUSH
63957: LD_EXP 23
63961: PUSH
63962: LD_VAR 0 2
63966: ARRAY
63967: PUSH
63968: LD_INT 1
63970: ARRAY
63971: PPUSH
63972: CALL_OW 255
63976: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63977: LD_ADDR_VAR 0 9
63981: PUSH
63982: LD_EXP 23
63986: PUSH
63987: LD_VAR 0 2
63991: ARRAY
63992: PPUSH
63993: LD_INT 2
63995: PUSH
63996: LD_INT 30
63998: PUSH
63999: LD_INT 0
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 30
64008: PUSH
64009: LD_INT 1
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: EMPTY
64017: LIST
64018: LIST
64019: LIST
64020: PPUSH
64021: CALL_OW 72
64025: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64026: LD_ADDR_VAR 0 3
64030: PUSH
64031: DOUBLE
64032: LD_EXP 39
64036: PUSH
64037: LD_VAR 0 2
64041: ARRAY
64042: INC
64043: ST_TO_ADDR
64044: LD_INT 1
64046: PUSH
64047: FOR_DOWNTO
64048: IFFALSE 64293
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64050: LD_EXP 39
64054: PUSH
64055: LD_VAR 0 2
64059: ARRAY
64060: PUSH
64061: LD_VAR 0 3
64065: ARRAY
64066: PUSH
64067: LD_INT 2
64069: ARRAY
64070: PPUSH
64071: LD_EXP 39
64075: PUSH
64076: LD_VAR 0 2
64080: ARRAY
64081: PUSH
64082: LD_VAR 0 3
64086: ARRAY
64087: PUSH
64088: LD_INT 3
64090: ARRAY
64091: PPUSH
64092: CALL_OW 488
64096: PUSH
64097: LD_EXP 39
64101: PUSH
64102: LD_VAR 0 2
64106: ARRAY
64107: PUSH
64108: LD_VAR 0 3
64112: ARRAY
64113: PUSH
64114: LD_INT 2
64116: ARRAY
64117: PPUSH
64118: LD_EXP 39
64122: PUSH
64123: LD_VAR 0 2
64127: ARRAY
64128: PUSH
64129: LD_VAR 0 3
64133: ARRAY
64134: PUSH
64135: LD_INT 3
64137: ARRAY
64138: PPUSH
64139: CALL_OW 284
64143: PUSH
64144: LD_INT 0
64146: EQUAL
64147: AND
64148: IFFALSE 64203
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64150: LD_ADDR_VAR 0 5
64154: PUSH
64155: LD_EXP 39
64159: PUSH
64160: LD_VAR 0 2
64164: ARRAY
64165: PPUSH
64166: LD_VAR 0 3
64170: PPUSH
64171: CALL_OW 3
64175: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64176: LD_ADDR_EXP 39
64180: PUSH
64181: LD_EXP 39
64185: PPUSH
64186: LD_VAR 0 2
64190: PPUSH
64191: LD_VAR 0 5
64195: PPUSH
64196: CALL_OW 1
64200: ST_TO_ADDR
// continue ;
64201: GO 64047
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64203: LD_VAR 0 6
64207: PPUSH
64208: LD_EXP 39
64212: PUSH
64213: LD_VAR 0 2
64217: ARRAY
64218: PUSH
64219: LD_VAR 0 3
64223: ARRAY
64224: PUSH
64225: LD_INT 2
64227: ARRAY
64228: PPUSH
64229: LD_EXP 39
64233: PUSH
64234: LD_VAR 0 2
64238: ARRAY
64239: PUSH
64240: LD_VAR 0 3
64244: ARRAY
64245: PUSH
64246: LD_INT 3
64248: ARRAY
64249: PPUSH
64250: LD_INT 30
64252: PPUSH
64253: CALL 16886 0 4
64257: PUSH
64258: LD_INT 4
64260: ARRAY
64261: PUSH
64262: LD_INT 0
64264: EQUAL
64265: IFFALSE 64291
// begin target := mc_crates [ i ] [ j ] ;
64267: LD_ADDR_VAR 0 7
64271: PUSH
64272: LD_EXP 39
64276: PUSH
64277: LD_VAR 0 2
64281: ARRAY
64282: PUSH
64283: LD_VAR 0 3
64287: ARRAY
64288: ST_TO_ADDR
// break ;
64289: GO 64293
// end ; end ;
64291: GO 64047
64293: POP
64294: POP
// if not target then
64295: LD_VAR 0 7
64299: NOT
64300: IFFALSE 64304
// continue ;
64302: GO 63854
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64304: LD_ADDR_VAR 0 8
64308: PUSH
64309: LD_EXP 42
64313: PUSH
64314: LD_VAR 0 2
64318: ARRAY
64319: PPUSH
64320: LD_INT 2
64322: PUSH
64323: LD_INT 3
64325: PUSH
64326: LD_INT 58
64328: PUSH
64329: EMPTY
64330: LIST
64331: PUSH
64332: EMPTY
64333: LIST
64334: LIST
64335: PUSH
64336: LD_INT 61
64338: PUSH
64339: EMPTY
64340: LIST
64341: PUSH
64342: LD_INT 33
64344: PUSH
64345: LD_INT 5
64347: PUSH
64348: EMPTY
64349: LIST
64350: LIST
64351: PUSH
64352: LD_INT 33
64354: PUSH
64355: LD_INT 3
64357: PUSH
64358: EMPTY
64359: LIST
64360: LIST
64361: PUSH
64362: EMPTY
64363: LIST
64364: LIST
64365: LIST
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 2
64371: PUSH
64372: LD_INT 34
64374: PUSH
64375: LD_INT 32
64377: PUSH
64378: EMPTY
64379: LIST
64380: LIST
64381: PUSH
64382: LD_INT 34
64384: PUSH
64385: LD_INT 51
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 34
64394: PUSH
64395: LD_INT 12
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: PUSH
64408: EMPTY
64409: LIST
64410: LIST
64411: PPUSH
64412: CALL_OW 72
64416: ST_TO_ADDR
// if not cargo then
64417: LD_VAR 0 8
64421: NOT
64422: IFFALSE 65128
// begin if mc_crates_collector [ i ] < 5 then
64424: LD_EXP 40
64428: PUSH
64429: LD_VAR 0 2
64433: ARRAY
64434: PUSH
64435: LD_INT 5
64437: LESS
64438: IFFALSE 64804
// begin if mc_ape [ i ] then
64440: LD_EXP 52
64444: PUSH
64445: LD_VAR 0 2
64449: ARRAY
64450: IFFALSE 64497
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64452: LD_ADDR_VAR 0 5
64456: PUSH
64457: LD_EXP 52
64461: PUSH
64462: LD_VAR 0 2
64466: ARRAY
64467: PPUSH
64468: LD_INT 25
64470: PUSH
64471: LD_INT 16
64473: PUSH
64474: EMPTY
64475: LIST
64476: LIST
64477: PUSH
64478: LD_INT 24
64480: PUSH
64481: LD_INT 750
64483: PUSH
64484: EMPTY
64485: LIST
64486: LIST
64487: PUSH
64488: EMPTY
64489: LIST
64490: LIST
64491: PPUSH
64492: CALL_OW 72
64496: ST_TO_ADDR
// if not tmp then
64497: LD_VAR 0 5
64501: NOT
64502: IFFALSE 64549
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64504: LD_ADDR_VAR 0 5
64508: PUSH
64509: LD_EXP 23
64513: PUSH
64514: LD_VAR 0 2
64518: ARRAY
64519: PPUSH
64520: LD_INT 25
64522: PUSH
64523: LD_INT 2
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 24
64532: PUSH
64533: LD_INT 750
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: EMPTY
64541: LIST
64542: LIST
64543: PPUSH
64544: CALL_OW 72
64548: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64549: LD_EXP 52
64553: PUSH
64554: LD_VAR 0 2
64558: ARRAY
64559: PUSH
64560: LD_EXP 23
64564: PUSH
64565: LD_VAR 0 2
64569: ARRAY
64570: PPUSH
64571: LD_INT 25
64573: PUSH
64574: LD_INT 2
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 24
64583: PUSH
64584: LD_INT 750
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PPUSH
64595: CALL_OW 72
64599: AND
64600: PUSH
64601: LD_VAR 0 5
64605: PUSH
64606: LD_INT 5
64608: LESS
64609: AND
64610: IFFALSE 64692
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64612: LD_ADDR_VAR 0 3
64616: PUSH
64617: LD_EXP 23
64621: PUSH
64622: LD_VAR 0 2
64626: ARRAY
64627: PPUSH
64628: LD_INT 25
64630: PUSH
64631: LD_INT 2
64633: PUSH
64634: EMPTY
64635: LIST
64636: LIST
64637: PUSH
64638: LD_INT 24
64640: PUSH
64641: LD_INT 750
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: EMPTY
64649: LIST
64650: LIST
64651: PPUSH
64652: CALL_OW 72
64656: PUSH
64657: FOR_IN
64658: IFFALSE 64690
// begin tmp := tmp union j ;
64660: LD_ADDR_VAR 0 5
64664: PUSH
64665: LD_VAR 0 5
64669: PUSH
64670: LD_VAR 0 3
64674: UNION
64675: ST_TO_ADDR
// if tmp >= 5 then
64676: LD_VAR 0 5
64680: PUSH
64681: LD_INT 5
64683: GREATEREQUAL
64684: IFFALSE 64688
// break ;
64686: GO 64690
// end ;
64688: GO 64657
64690: POP
64691: POP
// end ; if not tmp then
64692: LD_VAR 0 5
64696: NOT
64697: IFFALSE 64701
// continue ;
64699: GO 63854
// for j in tmp do
64701: LD_ADDR_VAR 0 3
64705: PUSH
64706: LD_VAR 0 5
64710: PUSH
64711: FOR_IN
64712: IFFALSE 64802
// if not GetTag ( j ) then
64714: LD_VAR 0 3
64718: PPUSH
64719: CALL_OW 110
64723: NOT
64724: IFFALSE 64800
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64726: LD_ADDR_EXP 40
64730: PUSH
64731: LD_EXP 40
64735: PPUSH
64736: LD_VAR 0 2
64740: PUSH
64741: LD_EXP 40
64745: PUSH
64746: LD_VAR 0 2
64750: ARRAY
64751: PUSH
64752: LD_INT 1
64754: PLUS
64755: PUSH
64756: EMPTY
64757: LIST
64758: LIST
64759: PPUSH
64760: LD_VAR 0 3
64764: PPUSH
64765: CALL 15990 0 3
64769: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64770: LD_VAR 0 3
64774: PPUSH
64775: LD_INT 107
64777: PPUSH
64778: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64782: LD_EXP 40
64786: PUSH
64787: LD_VAR 0 2
64791: ARRAY
64792: PUSH
64793: LD_INT 5
64795: GREATEREQUAL
64796: IFFALSE 64800
// break ;
64798: GO 64802
// end ;
64800: GO 64711
64802: POP
64803: POP
// end ; if mc_crates_collector [ i ] and target then
64804: LD_EXP 40
64808: PUSH
64809: LD_VAR 0 2
64813: ARRAY
64814: PUSH
64815: LD_VAR 0 7
64819: AND
64820: IFFALSE 65126
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64822: LD_EXP 40
64826: PUSH
64827: LD_VAR 0 2
64831: ARRAY
64832: PUSH
64833: LD_VAR 0 7
64837: PUSH
64838: LD_INT 1
64840: ARRAY
64841: LESS
64842: IFFALSE 64862
// tmp := mc_crates_collector [ i ] else
64844: LD_ADDR_VAR 0 5
64848: PUSH
64849: LD_EXP 40
64853: PUSH
64854: LD_VAR 0 2
64858: ARRAY
64859: ST_TO_ADDR
64860: GO 64876
// tmp := target [ 1 ] ;
64862: LD_ADDR_VAR 0 5
64866: PUSH
64867: LD_VAR 0 7
64871: PUSH
64872: LD_INT 1
64874: ARRAY
64875: ST_TO_ADDR
// k := 0 ;
64876: LD_ADDR_VAR 0 4
64880: PUSH
64881: LD_INT 0
64883: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64884: LD_ADDR_VAR 0 3
64888: PUSH
64889: LD_EXP 40
64893: PUSH
64894: LD_VAR 0 2
64898: ARRAY
64899: PUSH
64900: FOR_IN
64901: IFFALSE 65124
// begin k := k + 1 ;
64903: LD_ADDR_VAR 0 4
64907: PUSH
64908: LD_VAR 0 4
64912: PUSH
64913: LD_INT 1
64915: PLUS
64916: ST_TO_ADDR
// if k > tmp then
64917: LD_VAR 0 4
64921: PUSH
64922: LD_VAR 0 5
64926: GREATER
64927: IFFALSE 64931
// break ;
64929: GO 65124
// if not GetClass ( j ) in [ 2 , 16 ] then
64931: LD_VAR 0 3
64935: PPUSH
64936: CALL_OW 257
64940: PUSH
64941: LD_INT 2
64943: PUSH
64944: LD_INT 16
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: IN
64951: NOT
64952: IFFALSE 65005
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64954: LD_ADDR_EXP 40
64958: PUSH
64959: LD_EXP 40
64963: PPUSH
64964: LD_VAR 0 2
64968: PPUSH
64969: LD_EXP 40
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PUSH
64980: LD_VAR 0 3
64984: DIFF
64985: PPUSH
64986: CALL_OW 1
64990: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64991: LD_VAR 0 3
64995: PPUSH
64996: LD_INT 0
64998: PPUSH
64999: CALL_OW 109
// continue ;
65003: GO 64900
// end ; if IsInUnit ( j ) then
65005: LD_VAR 0 3
65009: PPUSH
65010: CALL_OW 310
65014: IFFALSE 65025
// ComExitBuilding ( j ) ;
65016: LD_VAR 0 3
65020: PPUSH
65021: CALL_OW 122
// wait ( 3 ) ;
65025: LD_INT 3
65027: PPUSH
65028: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
65032: LD_VAR 0 3
65036: PPUSH
65037: CALL_OW 314
65041: PUSH
65042: LD_VAR 0 6
65046: PPUSH
65047: LD_VAR 0 7
65051: PUSH
65052: LD_INT 2
65054: ARRAY
65055: PPUSH
65056: LD_VAR 0 7
65060: PUSH
65061: LD_INT 3
65063: ARRAY
65064: PPUSH
65065: LD_INT 30
65067: PPUSH
65068: CALL 16886 0 4
65072: PUSH
65073: LD_INT 4
65075: ARRAY
65076: AND
65077: IFFALSE 65095
// ComStandNearbyBuilding ( j , depot ) else
65079: LD_VAR 0 3
65083: PPUSH
65084: LD_VAR 0 9
65088: PPUSH
65089: CALL 12568 0 2
65093: GO 65122
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65095: LD_VAR 0 3
65099: PPUSH
65100: LD_VAR 0 7
65104: PUSH
65105: LD_INT 2
65107: ARRAY
65108: PPUSH
65109: LD_VAR 0 7
65113: PUSH
65114: LD_INT 3
65116: ARRAY
65117: PPUSH
65118: CALL_OW 117
// end ;
65122: GO 64900
65124: POP
65125: POP
// end ; end else
65126: GO 65658
// begin for j in cargo do
65128: LD_ADDR_VAR 0 3
65132: PUSH
65133: LD_VAR 0 8
65137: PUSH
65138: FOR_IN
65139: IFFALSE 65656
// begin if GetTag ( j ) <> 0 then
65141: LD_VAR 0 3
65145: PPUSH
65146: CALL_OW 110
65150: PUSH
65151: LD_INT 0
65153: NONEQUAL
65154: IFFALSE 65158
// continue ;
65156: GO 65138
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65158: LD_VAR 0 3
65162: PPUSH
65163: CALL_OW 256
65167: PUSH
65168: LD_INT 1000
65170: LESS
65171: PUSH
65172: LD_VAR 0 3
65176: PPUSH
65177: LD_EXP 47
65181: PUSH
65182: LD_VAR 0 2
65186: ARRAY
65187: PPUSH
65188: CALL_OW 308
65192: NOT
65193: AND
65194: IFFALSE 65216
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65196: LD_VAR 0 3
65200: PPUSH
65201: LD_EXP 47
65205: PUSH
65206: LD_VAR 0 2
65210: ARRAY
65211: PPUSH
65212: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65216: LD_VAR 0 3
65220: PPUSH
65221: CALL_OW 256
65225: PUSH
65226: LD_INT 1000
65228: LESS
65229: PUSH
65230: LD_VAR 0 3
65234: PPUSH
65235: LD_EXP 47
65239: PUSH
65240: LD_VAR 0 2
65244: ARRAY
65245: PPUSH
65246: CALL_OW 308
65250: AND
65251: IFFALSE 65255
// continue ;
65253: GO 65138
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65255: LD_VAR 0 3
65259: PPUSH
65260: CALL_OW 262
65264: PUSH
65265: LD_INT 2
65267: EQUAL
65268: PUSH
65269: LD_VAR 0 3
65273: PPUSH
65274: CALL_OW 261
65278: PUSH
65279: LD_INT 15
65281: LESS
65282: AND
65283: IFFALSE 65287
// continue ;
65285: GO 65138
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65287: LD_VAR 0 3
65291: PPUSH
65292: CALL_OW 262
65296: PUSH
65297: LD_INT 1
65299: EQUAL
65300: PUSH
65301: LD_VAR 0 3
65305: PPUSH
65306: CALL_OW 261
65310: PUSH
65311: LD_INT 10
65313: LESS
65314: AND
65315: IFFALSE 65595
// begin if not depot then
65317: LD_VAR 0 9
65321: NOT
65322: IFFALSE 65326
// continue ;
65324: GO 65138
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65326: LD_VAR 0 3
65330: PPUSH
65331: LD_VAR 0 9
65335: PPUSH
65336: LD_VAR 0 3
65340: PPUSH
65341: CALL_OW 74
65345: PPUSH
65346: CALL_OW 296
65350: PUSH
65351: LD_INT 6
65353: LESS
65354: IFFALSE 65370
// SetFuel ( j , 100 ) else
65356: LD_VAR 0 3
65360: PPUSH
65361: LD_INT 100
65363: PPUSH
65364: CALL_OW 240
65368: GO 65595
// if GetFuel ( j ) = 0 then
65370: LD_VAR 0 3
65374: PPUSH
65375: CALL_OW 261
65379: PUSH
65380: LD_INT 0
65382: EQUAL
65383: IFFALSE 65595
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65385: LD_ADDR_EXP 42
65389: PUSH
65390: LD_EXP 42
65394: PPUSH
65395: LD_VAR 0 2
65399: PPUSH
65400: LD_EXP 42
65404: PUSH
65405: LD_VAR 0 2
65409: ARRAY
65410: PUSH
65411: LD_VAR 0 3
65415: DIFF
65416: PPUSH
65417: CALL_OW 1
65421: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65422: LD_VAR 0 3
65426: PPUSH
65427: CALL_OW 263
65431: PUSH
65432: LD_INT 1
65434: EQUAL
65435: IFFALSE 65451
// ComExitVehicle ( IsInUnit ( j ) ) ;
65437: LD_VAR 0 3
65441: PPUSH
65442: CALL_OW 310
65446: PPUSH
65447: CALL_OW 121
// if GetControl ( j ) = control_remote then
65451: LD_VAR 0 3
65455: PPUSH
65456: CALL_OW 263
65460: PUSH
65461: LD_INT 2
65463: EQUAL
65464: IFFALSE 65475
// ComUnlink ( j ) ;
65466: LD_VAR 0 3
65470: PPUSH
65471: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65475: LD_ADDR_VAR 0 10
65479: PUSH
65480: LD_VAR 0 2
65484: PPUSH
65485: LD_INT 3
65487: PPUSH
65488: CALL 75234 0 2
65492: ST_TO_ADDR
// if fac then
65493: LD_VAR 0 10
65497: IFFALSE 65593
// begin for k in fac do
65499: LD_ADDR_VAR 0 4
65503: PUSH
65504: LD_VAR 0 10
65508: PUSH
65509: FOR_IN
65510: IFFALSE 65591
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65512: LD_ADDR_VAR 0 11
65516: PUSH
65517: LD_VAR 0 10
65521: PPUSH
65522: LD_VAR 0 3
65526: PPUSH
65527: CALL_OW 265
65531: PPUSH
65532: LD_VAR 0 3
65536: PPUSH
65537: CALL_OW 262
65541: PPUSH
65542: LD_VAR 0 3
65546: PPUSH
65547: CALL_OW 263
65551: PPUSH
65552: LD_VAR 0 3
65556: PPUSH
65557: CALL_OW 264
65561: PPUSH
65562: CALL 13486 0 5
65566: ST_TO_ADDR
// if components then
65567: LD_VAR 0 11
65571: IFFALSE 65589
// begin MC_InsertProduceList ( i , components ) ;
65573: LD_VAR 0 2
65577: PPUSH
65578: LD_VAR 0 11
65582: PPUSH
65583: CALL 74779 0 2
// break ;
65587: GO 65591
// end ; end ;
65589: GO 65509
65591: POP
65592: POP
// end ; continue ;
65593: GO 65138
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65595: LD_VAR 0 3
65599: PPUSH
65600: LD_INT 1
65602: PPUSH
65603: CALL_OW 289
65607: PUSH
65608: LD_INT 100
65610: LESS
65611: PUSH
65612: LD_VAR 0 3
65616: PPUSH
65617: CALL_OW 314
65621: NOT
65622: AND
65623: IFFALSE 65652
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65625: LD_VAR 0 3
65629: PPUSH
65630: LD_VAR 0 7
65634: PUSH
65635: LD_INT 2
65637: ARRAY
65638: PPUSH
65639: LD_VAR 0 7
65643: PUSH
65644: LD_INT 3
65646: ARRAY
65647: PPUSH
65648: CALL_OW 117
// break ;
65652: GO 65656
// end ;
65654: GO 65138
65656: POP
65657: POP
// end ; end ;
65658: GO 63854
65660: POP
65661: POP
// end ;
65662: LD_VAR 0 1
65666: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65667: LD_INT 0
65669: PPUSH
65670: PPUSH
65671: PPUSH
65672: PPUSH
// if not mc_bases then
65673: LD_EXP 23
65677: NOT
65678: IFFALSE 65682
// exit ;
65680: GO 65843
// for i = 1 to mc_bases do
65682: LD_ADDR_VAR 0 2
65686: PUSH
65687: DOUBLE
65688: LD_INT 1
65690: DEC
65691: ST_TO_ADDR
65692: LD_EXP 23
65696: PUSH
65697: FOR_TO
65698: IFFALSE 65841
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65700: LD_ADDR_VAR 0 4
65704: PUSH
65705: LD_EXP 42
65709: PUSH
65710: LD_VAR 0 2
65714: ARRAY
65715: PUSH
65716: LD_EXP 45
65720: PUSH
65721: LD_VAR 0 2
65725: ARRAY
65726: UNION
65727: PPUSH
65728: LD_INT 33
65730: PUSH
65731: LD_INT 2
65733: PUSH
65734: EMPTY
65735: LIST
65736: LIST
65737: PPUSH
65738: CALL_OW 72
65742: ST_TO_ADDR
// if tmp then
65743: LD_VAR 0 4
65747: IFFALSE 65839
// for j in tmp do
65749: LD_ADDR_VAR 0 3
65753: PUSH
65754: LD_VAR 0 4
65758: PUSH
65759: FOR_IN
65760: IFFALSE 65837
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65762: LD_VAR 0 3
65766: PPUSH
65767: CALL_OW 312
65771: NOT
65772: PUSH
65773: LD_VAR 0 3
65777: PPUSH
65778: CALL_OW 256
65782: PUSH
65783: LD_INT 250
65785: GREATEREQUAL
65786: AND
65787: IFFALSE 65800
// Connect ( j ) else
65789: LD_VAR 0 3
65793: PPUSH
65794: CALL 18961 0 1
65798: GO 65835
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65800: LD_VAR 0 3
65804: PPUSH
65805: CALL_OW 256
65809: PUSH
65810: LD_INT 250
65812: LESS
65813: PUSH
65814: LD_VAR 0 3
65818: PPUSH
65819: CALL_OW 312
65823: AND
65824: IFFALSE 65835
// ComUnlink ( j ) ;
65826: LD_VAR 0 3
65830: PPUSH
65831: CALL_OW 136
65835: GO 65759
65837: POP
65838: POP
// end ;
65839: GO 65697
65841: POP
65842: POP
// end ;
65843: LD_VAR 0 1
65847: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65848: LD_INT 0
65850: PPUSH
65851: PPUSH
65852: PPUSH
65853: PPUSH
65854: PPUSH
// if not mc_bases then
65855: LD_EXP 23
65859: NOT
65860: IFFALSE 65864
// exit ;
65862: GO 66309
// for i = 1 to mc_bases do
65864: LD_ADDR_VAR 0 2
65868: PUSH
65869: DOUBLE
65870: LD_INT 1
65872: DEC
65873: ST_TO_ADDR
65874: LD_EXP 23
65878: PUSH
65879: FOR_TO
65880: IFFALSE 66307
// begin if not mc_produce [ i ] then
65882: LD_EXP 44
65886: PUSH
65887: LD_VAR 0 2
65891: ARRAY
65892: NOT
65893: IFFALSE 65897
// continue ;
65895: GO 65879
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65897: LD_ADDR_VAR 0 5
65901: PUSH
65902: LD_EXP 23
65906: PUSH
65907: LD_VAR 0 2
65911: ARRAY
65912: PPUSH
65913: LD_INT 30
65915: PUSH
65916: LD_INT 3
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PPUSH
65923: CALL_OW 72
65927: ST_TO_ADDR
// if not fac then
65928: LD_VAR 0 5
65932: NOT
65933: IFFALSE 65937
// continue ;
65935: GO 65879
// for j in fac do
65937: LD_ADDR_VAR 0 3
65941: PUSH
65942: LD_VAR 0 5
65946: PUSH
65947: FOR_IN
65948: IFFALSE 66303
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65950: LD_VAR 0 3
65954: PPUSH
65955: CALL_OW 461
65959: PUSH
65960: LD_INT 2
65962: NONEQUAL
65963: PUSH
65964: LD_VAR 0 3
65968: PPUSH
65969: LD_INT 15
65971: PPUSH
65972: CALL 18589 0 2
65976: PUSH
65977: LD_INT 4
65979: ARRAY
65980: OR
65981: IFFALSE 65985
// continue ;
65983: GO 65947
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65985: LD_VAR 0 3
65989: PPUSH
65990: LD_EXP 44
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: PUSH
66001: LD_INT 1
66003: ARRAY
66004: PUSH
66005: LD_INT 1
66007: ARRAY
66008: PPUSH
66009: LD_EXP 44
66013: PUSH
66014: LD_VAR 0 2
66018: ARRAY
66019: PUSH
66020: LD_INT 1
66022: ARRAY
66023: PUSH
66024: LD_INT 2
66026: ARRAY
66027: PPUSH
66028: LD_EXP 44
66032: PUSH
66033: LD_VAR 0 2
66037: ARRAY
66038: PUSH
66039: LD_INT 1
66041: ARRAY
66042: PUSH
66043: LD_INT 3
66045: ARRAY
66046: PPUSH
66047: LD_EXP 44
66051: PUSH
66052: LD_VAR 0 2
66056: ARRAY
66057: PUSH
66058: LD_INT 1
66060: ARRAY
66061: PUSH
66062: LD_INT 4
66064: ARRAY
66065: PPUSH
66066: CALL_OW 448
66070: PUSH
66071: LD_VAR 0 3
66075: PPUSH
66076: LD_EXP 44
66080: PUSH
66081: LD_VAR 0 2
66085: ARRAY
66086: PUSH
66087: LD_INT 1
66089: ARRAY
66090: PUSH
66091: LD_INT 1
66093: ARRAY
66094: PUSH
66095: LD_EXP 44
66099: PUSH
66100: LD_VAR 0 2
66104: ARRAY
66105: PUSH
66106: LD_INT 1
66108: ARRAY
66109: PUSH
66110: LD_INT 2
66112: ARRAY
66113: PUSH
66114: LD_EXP 44
66118: PUSH
66119: LD_VAR 0 2
66123: ARRAY
66124: PUSH
66125: LD_INT 1
66127: ARRAY
66128: PUSH
66129: LD_INT 3
66131: ARRAY
66132: PUSH
66133: LD_EXP 44
66137: PUSH
66138: LD_VAR 0 2
66142: ARRAY
66143: PUSH
66144: LD_INT 1
66146: ARRAY
66147: PUSH
66148: LD_INT 4
66150: ARRAY
66151: PUSH
66152: EMPTY
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: PPUSH
66158: CALL 22356 0 2
66162: AND
66163: IFFALSE 66301
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66165: LD_VAR 0 3
66169: PPUSH
66170: LD_EXP 44
66174: PUSH
66175: LD_VAR 0 2
66179: ARRAY
66180: PUSH
66181: LD_INT 1
66183: ARRAY
66184: PUSH
66185: LD_INT 1
66187: ARRAY
66188: PPUSH
66189: LD_EXP 44
66193: PUSH
66194: LD_VAR 0 2
66198: ARRAY
66199: PUSH
66200: LD_INT 1
66202: ARRAY
66203: PUSH
66204: LD_INT 2
66206: ARRAY
66207: PPUSH
66208: LD_EXP 44
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: PUSH
66219: LD_INT 1
66221: ARRAY
66222: PUSH
66223: LD_INT 3
66225: ARRAY
66226: PPUSH
66227: LD_EXP 44
66231: PUSH
66232: LD_VAR 0 2
66236: ARRAY
66237: PUSH
66238: LD_INT 1
66240: ARRAY
66241: PUSH
66242: LD_INT 4
66244: ARRAY
66245: PPUSH
66246: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66250: LD_ADDR_VAR 0 4
66254: PUSH
66255: LD_EXP 44
66259: PUSH
66260: LD_VAR 0 2
66264: ARRAY
66265: PPUSH
66266: LD_INT 1
66268: PPUSH
66269: CALL_OW 3
66273: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66274: LD_ADDR_EXP 44
66278: PUSH
66279: LD_EXP 44
66283: PPUSH
66284: LD_VAR 0 2
66288: PPUSH
66289: LD_VAR 0 4
66293: PPUSH
66294: CALL_OW 1
66298: ST_TO_ADDR
// break ;
66299: GO 66303
// end ; end ;
66301: GO 65947
66303: POP
66304: POP
// end ;
66305: GO 65879
66307: POP
66308: POP
// end ;
66309: LD_VAR 0 1
66313: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66314: LD_INT 0
66316: PPUSH
66317: PPUSH
66318: PPUSH
// if not mc_bases then
66319: LD_EXP 23
66323: NOT
66324: IFFALSE 66328
// exit ;
66326: GO 66417
// for i = 1 to mc_bases do
66328: LD_ADDR_VAR 0 2
66332: PUSH
66333: DOUBLE
66334: LD_INT 1
66336: DEC
66337: ST_TO_ADDR
66338: LD_EXP 23
66342: PUSH
66343: FOR_TO
66344: IFFALSE 66415
// begin if mc_attack [ i ] then
66346: LD_EXP 43
66350: PUSH
66351: LD_VAR 0 2
66355: ARRAY
66356: IFFALSE 66413
// begin tmp := mc_attack [ i ] [ 1 ] ;
66358: LD_ADDR_VAR 0 3
66362: PUSH
66363: LD_EXP 43
66367: PUSH
66368: LD_VAR 0 2
66372: ARRAY
66373: PUSH
66374: LD_INT 1
66376: ARRAY
66377: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66378: LD_ADDR_EXP 43
66382: PUSH
66383: LD_EXP 43
66387: PPUSH
66388: LD_VAR 0 2
66392: PPUSH
66393: EMPTY
66394: PPUSH
66395: CALL_OW 1
66399: ST_TO_ADDR
// Attack ( tmp ) ;
66400: LD_VAR 0 3
66404: PPUSH
66405: CALL 81353 0 1
// exit ;
66409: POP
66410: POP
66411: GO 66417
// end ; end ;
66413: GO 66343
66415: POP
66416: POP
// end ;
66417: LD_VAR 0 1
66421: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66422: LD_INT 0
66424: PPUSH
66425: PPUSH
66426: PPUSH
66427: PPUSH
66428: PPUSH
66429: PPUSH
66430: PPUSH
// if not mc_bases then
66431: LD_EXP 23
66435: NOT
66436: IFFALSE 66440
// exit ;
66438: GO 67297
// for i = 1 to mc_bases do
66440: LD_ADDR_VAR 0 2
66444: PUSH
66445: DOUBLE
66446: LD_INT 1
66448: DEC
66449: ST_TO_ADDR
66450: LD_EXP 23
66454: PUSH
66455: FOR_TO
66456: IFFALSE 67295
// begin if not mc_bases [ i ] then
66458: LD_EXP 23
66462: PUSH
66463: LD_VAR 0 2
66467: ARRAY
66468: NOT
66469: IFFALSE 66473
// continue ;
66471: GO 66455
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66473: LD_ADDR_VAR 0 7
66477: PUSH
66478: LD_EXP 23
66482: PUSH
66483: LD_VAR 0 2
66487: ARRAY
66488: PUSH
66489: LD_INT 1
66491: ARRAY
66492: PPUSH
66493: CALL 12790 0 1
66497: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66498: LD_ADDR_EXP 46
66502: PUSH
66503: LD_EXP 46
66507: PPUSH
66508: LD_VAR 0 2
66512: PPUSH
66513: LD_EXP 23
66517: PUSH
66518: LD_VAR 0 2
66522: ARRAY
66523: PUSH
66524: LD_INT 1
66526: ARRAY
66527: PPUSH
66528: CALL_OW 255
66532: PPUSH
66533: LD_EXP 48
66537: PUSH
66538: LD_VAR 0 2
66542: ARRAY
66543: PPUSH
66544: CALL 12755 0 2
66548: PPUSH
66549: CALL_OW 1
66553: ST_TO_ADDR
// if not mc_scan [ i ] then
66554: LD_EXP 46
66558: PUSH
66559: LD_VAR 0 2
66563: ARRAY
66564: NOT
66565: IFFALSE 66743
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
66567: LD_ADDR_EXP 66
66571: PUSH
66572: LD_EXP 66
66576: PPUSH
66577: LD_VAR 0 2
66581: PPUSH
66582: LD_INT 0
66584: PPUSH
66585: CALL_OW 1
66589: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66590: LD_ADDR_VAR 0 4
66594: PUSH
66595: LD_EXP 23
66599: PUSH
66600: LD_VAR 0 2
66604: ARRAY
66605: PPUSH
66606: LD_INT 2
66608: PUSH
66609: LD_INT 25
66611: PUSH
66612: LD_INT 5
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 25
66621: PUSH
66622: LD_INT 8
66624: PUSH
66625: EMPTY
66626: LIST
66627: LIST
66628: PUSH
66629: LD_INT 25
66631: PUSH
66632: LD_INT 9
66634: PUSH
66635: EMPTY
66636: LIST
66637: LIST
66638: PUSH
66639: EMPTY
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: PPUSH
66645: CALL_OW 72
66649: ST_TO_ADDR
// if not tmp then
66650: LD_VAR 0 4
66654: NOT
66655: IFFALSE 66659
// continue ;
66657: GO 66455
// for j in tmp do
66659: LD_ADDR_VAR 0 3
66663: PUSH
66664: LD_VAR 0 4
66668: PUSH
66669: FOR_IN
66670: IFFALSE 66741
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66672: LD_VAR 0 3
66676: PPUSH
66677: CALL_OW 310
66681: PPUSH
66682: CALL_OW 266
66686: PUSH
66687: LD_INT 5
66689: EQUAL
66690: PUSH
66691: LD_VAR 0 3
66695: PPUSH
66696: CALL_OW 257
66700: PUSH
66701: LD_INT 1
66703: EQUAL
66704: AND
66705: PUSH
66706: LD_VAR 0 3
66710: PPUSH
66711: CALL_OW 459
66715: NOT
66716: AND
66717: PUSH
66718: LD_VAR 0 7
66722: AND
66723: IFFALSE 66739
// ComChangeProfession ( j , class ) ;
66725: LD_VAR 0 3
66729: PPUSH
66730: LD_VAR 0 7
66734: PPUSH
66735: CALL_OW 123
66739: GO 66669
66741: POP
66742: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
66743: LD_EXP 46
66747: PUSH
66748: LD_VAR 0 2
66752: ARRAY
66753: PUSH
66754: LD_EXP 66
66758: PUSH
66759: LD_VAR 0 2
66763: ARRAY
66764: NOT
66765: AND
66766: PUSH
66767: LD_EXP 45
66771: PUSH
66772: LD_VAR 0 2
66776: ARRAY
66777: NOT
66778: AND
66779: PUSH
66780: LD_EXP 23
66784: PUSH
66785: LD_VAR 0 2
66789: ARRAY
66790: PPUSH
66791: LD_INT 50
66793: PUSH
66794: EMPTY
66795: LIST
66796: PUSH
66797: LD_INT 2
66799: PUSH
66800: LD_INT 30
66802: PUSH
66803: LD_INT 32
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 30
66812: PUSH
66813: LD_INT 33
66815: PUSH
66816: EMPTY
66817: LIST
66818: LIST
66819: PUSH
66820: LD_INT 30
66822: PUSH
66823: LD_INT 4
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 30
66832: PUSH
66833: LD_INT 5
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: EMPTY
66841: LIST
66842: LIST
66843: LIST
66844: LIST
66845: LIST
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PPUSH
66851: CALL_OW 72
66855: PUSH
66856: LD_INT 4
66858: LESS
66859: PUSH
66860: LD_EXP 23
66864: PUSH
66865: LD_VAR 0 2
66869: ARRAY
66870: PPUSH
66871: LD_INT 3
66873: PUSH
66874: LD_INT 24
66876: PUSH
66877: LD_INT 1000
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: EMPTY
66885: LIST
66886: LIST
66887: PUSH
66888: LD_INT 2
66890: PUSH
66891: LD_INT 30
66893: PUSH
66894: LD_INT 0
66896: PUSH
66897: EMPTY
66898: LIST
66899: LIST
66900: PUSH
66901: LD_INT 30
66903: PUSH
66904: LD_INT 1
66906: PUSH
66907: EMPTY
66908: LIST
66909: LIST
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: LIST
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: PPUSH
66920: CALL_OW 72
66924: OR
66925: AND
66926: IFFALSE 67177
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
66928: LD_ADDR_EXP 66
66932: PUSH
66933: LD_EXP 66
66937: PPUSH
66938: LD_VAR 0 2
66942: PPUSH
66943: LD_INT 1
66945: PPUSH
66946: CALL_OW 1
66950: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66951: LD_ADDR_VAR 0 4
66955: PUSH
66956: LD_EXP 23
66960: PUSH
66961: LD_VAR 0 2
66965: ARRAY
66966: PPUSH
66967: LD_INT 2
66969: PUSH
66970: LD_INT 25
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: EMPTY
66977: LIST
66978: LIST
66979: PUSH
66980: LD_INT 25
66982: PUSH
66983: LD_INT 5
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PUSH
66990: LD_INT 25
66992: PUSH
66993: LD_INT 8
66995: PUSH
66996: EMPTY
66997: LIST
66998: LIST
66999: PUSH
67000: LD_INT 25
67002: PUSH
67003: LD_INT 9
67005: PUSH
67006: EMPTY
67007: LIST
67008: LIST
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: LIST
67014: LIST
67015: LIST
67016: PPUSH
67017: CALL_OW 72
67021: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67022: LD_ADDR_VAR 0 4
67026: PUSH
67027: LD_VAR 0 4
67031: PUSH
67032: LD_VAR 0 4
67036: PPUSH
67037: LD_INT 18
67039: PPUSH
67040: CALL 45259 0 2
67044: DIFF
67045: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67046: LD_VAR 0 4
67050: NOT
67051: PUSH
67052: LD_EXP 23
67056: PUSH
67057: LD_VAR 0 2
67061: ARRAY
67062: PPUSH
67063: LD_INT 2
67065: PUSH
67066: LD_INT 30
67068: PUSH
67069: LD_INT 4
67071: PUSH
67072: EMPTY
67073: LIST
67074: LIST
67075: PUSH
67076: LD_INT 30
67078: PUSH
67079: LD_INT 5
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: LIST
67090: PPUSH
67091: CALL_OW 72
67095: NOT
67096: AND
67097: IFFALSE 67159
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
67099: LD_ADDR_VAR 0 4
67103: PUSH
67104: LD_EXP 23
67108: PUSH
67109: LD_VAR 0 2
67113: ARRAY
67114: PPUSH
67115: LD_INT 2
67117: PUSH
67118: LD_INT 25
67120: PUSH
67121: LD_INT 2
67123: PUSH
67124: EMPTY
67125: LIST
67126: LIST
67127: PUSH
67128: LD_INT 25
67130: PUSH
67131: LD_INT 3
67133: PUSH
67134: EMPTY
67135: LIST
67136: LIST
67137: PUSH
67138: LD_INT 25
67140: PUSH
67141: LD_INT 4
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: LIST
67152: LIST
67153: PPUSH
67154: CALL_OW 72
67158: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
67159: LD_VAR 0 2
67163: PPUSH
67164: LD_VAR 0 4
67168: PPUSH
67169: CALL 86062 0 2
// exit ;
67173: POP
67174: POP
67175: GO 67297
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
67177: LD_EXP 46
67181: PUSH
67182: LD_VAR 0 2
67186: ARRAY
67187: PUSH
67188: LD_EXP 66
67192: PUSH
67193: LD_VAR 0 2
67197: ARRAY
67198: NOT
67199: AND
67200: PUSH
67201: LD_EXP 45
67205: PUSH
67206: LD_VAR 0 2
67210: ARRAY
67211: AND
67212: IFFALSE 67293
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
67214: LD_ADDR_EXP 66
67218: PUSH
67219: LD_EXP 66
67223: PPUSH
67224: LD_VAR 0 2
67228: PPUSH
67229: LD_INT 1
67231: PPUSH
67232: CALL_OW 1
67236: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
67237: LD_ADDR_VAR 0 4
67241: PUSH
67242: LD_EXP 45
67246: PUSH
67247: LD_VAR 0 2
67251: ARRAY
67252: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
67253: LD_ADDR_EXP 45
67257: PUSH
67258: LD_EXP 45
67262: PPUSH
67263: LD_VAR 0 2
67267: PPUSH
67268: EMPTY
67269: PPUSH
67270: CALL_OW 1
67274: ST_TO_ADDR
// Defend ( i , tmp ) ;
67275: LD_VAR 0 2
67279: PPUSH
67280: LD_VAR 0 4
67284: PPUSH
67285: CALL 86658 0 2
// exit ;
67289: POP
67290: POP
67291: GO 67297
// end ; end ;
67293: GO 66455
67295: POP
67296: POP
// end ;
67297: LD_VAR 0 1
67301: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67302: LD_INT 0
67304: PPUSH
67305: PPUSH
67306: PPUSH
67307: PPUSH
67308: PPUSH
67309: PPUSH
67310: PPUSH
67311: PPUSH
67312: PPUSH
67313: PPUSH
67314: PPUSH
// if not mc_bases then
67315: LD_EXP 23
67319: NOT
67320: IFFALSE 67324
// exit ;
67322: GO 68411
// for i = 1 to mc_bases do
67324: LD_ADDR_VAR 0 2
67328: PUSH
67329: DOUBLE
67330: LD_INT 1
67332: DEC
67333: ST_TO_ADDR
67334: LD_EXP 23
67338: PUSH
67339: FOR_TO
67340: IFFALSE 68409
// begin tmp := mc_lab [ i ] ;
67342: LD_ADDR_VAR 0 6
67346: PUSH
67347: LD_EXP 56
67351: PUSH
67352: LD_VAR 0 2
67356: ARRAY
67357: ST_TO_ADDR
// if not tmp then
67358: LD_VAR 0 6
67362: NOT
67363: IFFALSE 67367
// continue ;
67365: GO 67339
// idle_lab := 0 ;
67367: LD_ADDR_VAR 0 11
67371: PUSH
67372: LD_INT 0
67374: ST_TO_ADDR
// for j in tmp do
67375: LD_ADDR_VAR 0 3
67379: PUSH
67380: LD_VAR 0 6
67384: PUSH
67385: FOR_IN
67386: IFFALSE 68405
// begin researching := false ;
67388: LD_ADDR_VAR 0 10
67392: PUSH
67393: LD_INT 0
67395: ST_TO_ADDR
// side := GetSide ( j ) ;
67396: LD_ADDR_VAR 0 4
67400: PUSH
67401: LD_VAR 0 3
67405: PPUSH
67406: CALL_OW 255
67410: ST_TO_ADDR
// if not mc_tech [ side ] then
67411: LD_EXP 50
67415: PUSH
67416: LD_VAR 0 4
67420: ARRAY
67421: NOT
67422: IFFALSE 67426
// continue ;
67424: GO 67385
// if BuildingStatus ( j ) = bs_idle then
67426: LD_VAR 0 3
67430: PPUSH
67431: CALL_OW 461
67435: PUSH
67436: LD_INT 2
67438: EQUAL
67439: IFFALSE 67627
// begin if idle_lab and UnitsInside ( j ) < 6 then
67441: LD_VAR 0 11
67445: PUSH
67446: LD_VAR 0 3
67450: PPUSH
67451: CALL_OW 313
67455: PUSH
67456: LD_INT 6
67458: LESS
67459: AND
67460: IFFALSE 67531
// begin tmp2 := UnitsInside ( idle_lab ) ;
67462: LD_ADDR_VAR 0 9
67466: PUSH
67467: LD_VAR 0 11
67471: PPUSH
67472: CALL_OW 313
67476: ST_TO_ADDR
// if tmp2 then
67477: LD_VAR 0 9
67481: IFFALSE 67523
// for x in tmp2 do
67483: LD_ADDR_VAR 0 7
67487: PUSH
67488: LD_VAR 0 9
67492: PUSH
67493: FOR_IN
67494: IFFALSE 67521
// begin ComExitBuilding ( x ) ;
67496: LD_VAR 0 7
67500: PPUSH
67501: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67505: LD_VAR 0 7
67509: PPUSH
67510: LD_VAR 0 3
67514: PPUSH
67515: CALL_OW 180
// end ;
67519: GO 67493
67521: POP
67522: POP
// idle_lab := 0 ;
67523: LD_ADDR_VAR 0 11
67527: PUSH
67528: LD_INT 0
67530: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67531: LD_ADDR_VAR 0 5
67535: PUSH
67536: LD_EXP 50
67540: PUSH
67541: LD_VAR 0 4
67545: ARRAY
67546: PUSH
67547: FOR_IN
67548: IFFALSE 67608
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67550: LD_VAR 0 3
67554: PPUSH
67555: LD_VAR 0 5
67559: PPUSH
67560: CALL_OW 430
67564: PUSH
67565: LD_VAR 0 4
67569: PPUSH
67570: LD_VAR 0 5
67574: PPUSH
67575: CALL 11860 0 2
67579: AND
67580: IFFALSE 67606
// begin researching := true ;
67582: LD_ADDR_VAR 0 10
67586: PUSH
67587: LD_INT 1
67589: ST_TO_ADDR
// ComResearch ( j , t ) ;
67590: LD_VAR 0 3
67594: PPUSH
67595: LD_VAR 0 5
67599: PPUSH
67600: CALL_OW 124
// break ;
67604: GO 67608
// end ;
67606: GO 67547
67608: POP
67609: POP
// if not researching then
67610: LD_VAR 0 10
67614: NOT
67615: IFFALSE 67627
// idle_lab := j ;
67617: LD_ADDR_VAR 0 11
67621: PUSH
67622: LD_VAR 0 3
67626: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67627: LD_VAR 0 3
67631: PPUSH
67632: CALL_OW 461
67636: PUSH
67637: LD_INT 10
67639: EQUAL
67640: IFFALSE 68228
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67642: LD_EXP 52
67646: PUSH
67647: LD_VAR 0 2
67651: ARRAY
67652: NOT
67653: PUSH
67654: LD_EXP 53
67658: PUSH
67659: LD_VAR 0 2
67663: ARRAY
67664: NOT
67665: AND
67666: PUSH
67667: LD_EXP 50
67671: PUSH
67672: LD_VAR 0 4
67676: ARRAY
67677: PUSH
67678: LD_INT 1
67680: GREATER
67681: AND
67682: IFFALSE 67813
// begin ComCancel ( j ) ;
67684: LD_VAR 0 3
67688: PPUSH
67689: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67693: LD_ADDR_EXP 50
67697: PUSH
67698: LD_EXP 50
67702: PPUSH
67703: LD_VAR 0 4
67707: PPUSH
67708: LD_EXP 50
67712: PUSH
67713: LD_VAR 0 4
67717: ARRAY
67718: PPUSH
67719: LD_EXP 50
67723: PUSH
67724: LD_VAR 0 4
67728: ARRAY
67729: PUSH
67730: LD_INT 1
67732: MINUS
67733: PPUSH
67734: LD_EXP 50
67738: PUSH
67739: LD_VAR 0 4
67743: ARRAY
67744: PPUSH
67745: LD_INT 0
67747: PPUSH
67748: CALL 15408 0 4
67752: PPUSH
67753: CALL_OW 1
67757: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67758: LD_ADDR_EXP 50
67762: PUSH
67763: LD_EXP 50
67767: PPUSH
67768: LD_VAR 0 4
67772: PPUSH
67773: LD_EXP 50
67777: PUSH
67778: LD_VAR 0 4
67782: ARRAY
67783: PPUSH
67784: LD_EXP 50
67788: PUSH
67789: LD_VAR 0 4
67793: ARRAY
67794: PPUSH
67795: LD_INT 1
67797: PPUSH
67798: LD_INT 0
67800: PPUSH
67801: CALL 15408 0 4
67805: PPUSH
67806: CALL_OW 1
67810: ST_TO_ADDR
// continue ;
67811: GO 67385
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67813: LD_EXP 52
67817: PUSH
67818: LD_VAR 0 2
67822: ARRAY
67823: PUSH
67824: LD_EXP 53
67828: PUSH
67829: LD_VAR 0 2
67833: ARRAY
67834: NOT
67835: AND
67836: IFFALSE 67963
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67838: LD_ADDR_EXP 53
67842: PUSH
67843: LD_EXP 53
67847: PPUSH
67848: LD_VAR 0 2
67852: PUSH
67853: LD_EXP 53
67857: PUSH
67858: LD_VAR 0 2
67862: ARRAY
67863: PUSH
67864: LD_INT 1
67866: PLUS
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PPUSH
67872: LD_EXP 52
67876: PUSH
67877: LD_VAR 0 2
67881: ARRAY
67882: PUSH
67883: LD_INT 1
67885: ARRAY
67886: PPUSH
67887: CALL 15990 0 3
67891: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67892: LD_EXP 52
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PUSH
67903: LD_INT 1
67905: ARRAY
67906: PPUSH
67907: LD_INT 112
67909: PPUSH
67910: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67914: LD_ADDR_VAR 0 9
67918: PUSH
67919: LD_EXP 52
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PPUSH
67930: LD_INT 1
67932: PPUSH
67933: CALL_OW 3
67937: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67938: LD_ADDR_EXP 52
67942: PUSH
67943: LD_EXP 52
67947: PPUSH
67948: LD_VAR 0 2
67952: PPUSH
67953: LD_VAR 0 9
67957: PPUSH
67958: CALL_OW 1
67962: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67963: LD_EXP 52
67967: PUSH
67968: LD_VAR 0 2
67972: ARRAY
67973: PUSH
67974: LD_EXP 53
67978: PUSH
67979: LD_VAR 0 2
67983: ARRAY
67984: AND
67985: PUSH
67986: LD_EXP 53
67990: PUSH
67991: LD_VAR 0 2
67995: ARRAY
67996: PUSH
67997: LD_INT 1
67999: ARRAY
68000: PPUSH
68001: CALL_OW 310
68005: NOT
68006: AND
68007: PUSH
68008: LD_VAR 0 3
68012: PPUSH
68013: CALL_OW 313
68017: PUSH
68018: LD_INT 6
68020: EQUAL
68021: AND
68022: IFFALSE 68078
// begin tmp2 := UnitsInside ( j ) ;
68024: LD_ADDR_VAR 0 9
68028: PUSH
68029: LD_VAR 0 3
68033: PPUSH
68034: CALL_OW 313
68038: ST_TO_ADDR
// if tmp2 = 6 then
68039: LD_VAR 0 9
68043: PUSH
68044: LD_INT 6
68046: EQUAL
68047: IFFALSE 68078
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68049: LD_VAR 0 9
68053: PUSH
68054: LD_INT 1
68056: ARRAY
68057: PPUSH
68058: LD_INT 112
68060: PPUSH
68061: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68065: LD_VAR 0 9
68069: PUSH
68070: LD_INT 1
68072: ARRAY
68073: PPUSH
68074: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68078: LD_EXP 53
68082: PUSH
68083: LD_VAR 0 2
68087: ARRAY
68088: PUSH
68089: LD_EXP 53
68093: PUSH
68094: LD_VAR 0 2
68098: ARRAY
68099: PUSH
68100: LD_INT 1
68102: ARRAY
68103: PPUSH
68104: CALL_OW 314
68108: NOT
68109: AND
68110: PUSH
68111: LD_EXP 53
68115: PUSH
68116: LD_VAR 0 2
68120: ARRAY
68121: PUSH
68122: LD_INT 1
68124: ARRAY
68125: PPUSH
68126: CALL_OW 310
68130: NOT
68131: AND
68132: IFFALSE 68158
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68134: LD_EXP 53
68138: PUSH
68139: LD_VAR 0 2
68143: ARRAY
68144: PUSH
68145: LD_INT 1
68147: ARRAY
68148: PPUSH
68149: LD_VAR 0 3
68153: PPUSH
68154: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68158: LD_EXP 53
68162: PUSH
68163: LD_VAR 0 2
68167: ARRAY
68168: PUSH
68169: LD_INT 1
68171: ARRAY
68172: PPUSH
68173: CALL_OW 310
68177: PUSH
68178: LD_EXP 53
68182: PUSH
68183: LD_VAR 0 2
68187: ARRAY
68188: PUSH
68189: LD_INT 1
68191: ARRAY
68192: PPUSH
68193: CALL_OW 310
68197: PPUSH
68198: CALL_OW 461
68202: PUSH
68203: LD_INT 3
68205: NONEQUAL
68206: AND
68207: IFFALSE 68228
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68209: LD_EXP 53
68213: PUSH
68214: LD_VAR 0 2
68218: ARRAY
68219: PUSH
68220: LD_INT 1
68222: ARRAY
68223: PPUSH
68224: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68228: LD_VAR 0 3
68232: PPUSH
68233: CALL_OW 461
68237: PUSH
68238: LD_INT 6
68240: EQUAL
68241: PUSH
68242: LD_VAR 0 6
68246: PUSH
68247: LD_INT 1
68249: GREATER
68250: AND
68251: IFFALSE 68403
// begin sci := [ ] ;
68253: LD_ADDR_VAR 0 8
68257: PUSH
68258: EMPTY
68259: ST_TO_ADDR
// for x in ( tmp diff j ) do
68260: LD_ADDR_VAR 0 7
68264: PUSH
68265: LD_VAR 0 6
68269: PUSH
68270: LD_VAR 0 3
68274: DIFF
68275: PUSH
68276: FOR_IN
68277: IFFALSE 68329
// begin if sci = 6 then
68279: LD_VAR 0 8
68283: PUSH
68284: LD_INT 6
68286: EQUAL
68287: IFFALSE 68291
// break ;
68289: GO 68329
// if BuildingStatus ( x ) = bs_idle then
68291: LD_VAR 0 7
68295: PPUSH
68296: CALL_OW 461
68300: PUSH
68301: LD_INT 2
68303: EQUAL
68304: IFFALSE 68327
// sci := sci ^ UnitsInside ( x ) ;
68306: LD_ADDR_VAR 0 8
68310: PUSH
68311: LD_VAR 0 8
68315: PUSH
68316: LD_VAR 0 7
68320: PPUSH
68321: CALL_OW 313
68325: ADD
68326: ST_TO_ADDR
// end ;
68327: GO 68276
68329: POP
68330: POP
// if not sci then
68331: LD_VAR 0 8
68335: NOT
68336: IFFALSE 68340
// continue ;
68338: GO 67385
// for x in sci do
68340: LD_ADDR_VAR 0 7
68344: PUSH
68345: LD_VAR 0 8
68349: PUSH
68350: FOR_IN
68351: IFFALSE 68401
// if IsInUnit ( x ) and not HasTask ( x ) then
68353: LD_VAR 0 7
68357: PPUSH
68358: CALL_OW 310
68362: PUSH
68363: LD_VAR 0 7
68367: PPUSH
68368: CALL_OW 314
68372: NOT
68373: AND
68374: IFFALSE 68399
// begin ComExitBuilding ( x ) ;
68376: LD_VAR 0 7
68380: PPUSH
68381: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68385: LD_VAR 0 7
68389: PPUSH
68390: LD_VAR 0 3
68394: PPUSH
68395: CALL_OW 180
// end ;
68399: GO 68350
68401: POP
68402: POP
// end ; end ;
68403: GO 67385
68405: POP
68406: POP
// end ;
68407: GO 67339
68409: POP
68410: POP
// end ;
68411: LD_VAR 0 1
68415: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68416: LD_INT 0
68418: PPUSH
68419: PPUSH
// if not mc_bases then
68420: LD_EXP 23
68424: NOT
68425: IFFALSE 68429
// exit ;
68427: GO 68510
// for i = 1 to mc_bases do
68429: LD_ADDR_VAR 0 2
68433: PUSH
68434: DOUBLE
68435: LD_INT 1
68437: DEC
68438: ST_TO_ADDR
68439: LD_EXP 23
68443: PUSH
68444: FOR_TO
68445: IFFALSE 68508
// if mc_mines [ i ] and mc_miners [ i ] then
68447: LD_EXP 36
68451: PUSH
68452: LD_VAR 0 2
68456: ARRAY
68457: PUSH
68458: LD_EXP 37
68462: PUSH
68463: LD_VAR 0 2
68467: ARRAY
68468: AND
68469: IFFALSE 68506
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68471: LD_EXP 37
68475: PUSH
68476: LD_VAR 0 2
68480: ARRAY
68481: PUSH
68482: LD_INT 1
68484: ARRAY
68485: PPUSH
68486: CALL_OW 255
68490: PPUSH
68491: LD_EXP 36
68495: PUSH
68496: LD_VAR 0 2
68500: ARRAY
68501: PPUSH
68502: CALL 12943 0 2
68506: GO 68444
68508: POP
68509: POP
// end ;
68510: LD_VAR 0 1
68514: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68515: LD_INT 0
68517: PPUSH
68518: PPUSH
68519: PPUSH
68520: PPUSH
68521: PPUSH
68522: PPUSH
68523: PPUSH
68524: PPUSH
// if not mc_bases or not mc_parking then
68525: LD_EXP 23
68529: NOT
68530: PUSH
68531: LD_EXP 47
68535: NOT
68536: OR
68537: IFFALSE 68541
// exit ;
68539: GO 69251
// for i = 1 to mc_bases do
68541: LD_ADDR_VAR 0 2
68545: PUSH
68546: DOUBLE
68547: LD_INT 1
68549: DEC
68550: ST_TO_ADDR
68551: LD_EXP 23
68555: PUSH
68556: FOR_TO
68557: IFFALSE 69249
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68559: LD_EXP 23
68563: PUSH
68564: LD_VAR 0 2
68568: ARRAY
68569: NOT
68570: PUSH
68571: LD_EXP 47
68575: PUSH
68576: LD_VAR 0 2
68580: ARRAY
68581: NOT
68582: OR
68583: IFFALSE 68587
// continue ;
68585: GO 68556
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68587: LD_ADDR_VAR 0 5
68591: PUSH
68592: LD_EXP 23
68596: PUSH
68597: LD_VAR 0 2
68601: ARRAY
68602: PUSH
68603: LD_INT 1
68605: ARRAY
68606: PPUSH
68607: CALL_OW 255
68611: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68612: LD_ADDR_VAR 0 6
68616: PUSH
68617: LD_EXP 23
68621: PUSH
68622: LD_VAR 0 2
68626: ARRAY
68627: PPUSH
68628: LD_INT 30
68630: PUSH
68631: LD_INT 3
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PPUSH
68638: CALL_OW 72
68642: ST_TO_ADDR
// if not fac then
68643: LD_VAR 0 6
68647: NOT
68648: IFFALSE 68699
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68650: LD_ADDR_VAR 0 6
68654: PUSH
68655: LD_EXP 23
68659: PUSH
68660: LD_VAR 0 2
68664: ARRAY
68665: PPUSH
68666: LD_INT 2
68668: PUSH
68669: LD_INT 30
68671: PUSH
68672: LD_INT 0
68674: PUSH
68675: EMPTY
68676: LIST
68677: LIST
68678: PUSH
68679: LD_INT 30
68681: PUSH
68682: LD_INT 1
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: PPUSH
68694: CALL_OW 72
68698: ST_TO_ADDR
// if not fac then
68699: LD_VAR 0 6
68703: NOT
68704: IFFALSE 68708
// continue ;
68706: GO 68556
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68708: LD_ADDR_VAR 0 7
68712: PUSH
68713: LD_EXP 47
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: PPUSH
68724: LD_INT 22
68726: PUSH
68727: LD_VAR 0 5
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 21
68738: PUSH
68739: LD_INT 2
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 3
68748: PUSH
68749: LD_INT 24
68751: PUSH
68752: LD_INT 1000
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: LIST
68767: PPUSH
68768: CALL_OW 70
68772: ST_TO_ADDR
// for j in fac do
68773: LD_ADDR_VAR 0 3
68777: PUSH
68778: LD_VAR 0 6
68782: PUSH
68783: FOR_IN
68784: IFFALSE 68865
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68786: LD_ADDR_VAR 0 7
68790: PUSH
68791: LD_VAR 0 7
68795: PUSH
68796: LD_INT 22
68798: PUSH
68799: LD_VAR 0 5
68803: PUSH
68804: EMPTY
68805: LIST
68806: LIST
68807: PUSH
68808: LD_INT 91
68810: PUSH
68811: LD_VAR 0 3
68815: PUSH
68816: LD_INT 15
68818: PUSH
68819: EMPTY
68820: LIST
68821: LIST
68822: LIST
68823: PUSH
68824: LD_INT 21
68826: PUSH
68827: LD_INT 2
68829: PUSH
68830: EMPTY
68831: LIST
68832: LIST
68833: PUSH
68834: LD_INT 3
68836: PUSH
68837: LD_INT 24
68839: PUSH
68840: LD_INT 1000
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: LIST
68855: LIST
68856: PPUSH
68857: CALL_OW 69
68861: UNION
68862: ST_TO_ADDR
68863: GO 68783
68865: POP
68866: POP
// if not vehs then
68867: LD_VAR 0 7
68871: NOT
68872: IFFALSE 68898
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68874: LD_ADDR_EXP 35
68878: PUSH
68879: LD_EXP 35
68883: PPUSH
68884: LD_VAR 0 2
68888: PPUSH
68889: EMPTY
68890: PPUSH
68891: CALL_OW 1
68895: ST_TO_ADDR
// continue ;
68896: GO 68556
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68898: LD_ADDR_VAR 0 8
68902: PUSH
68903: LD_EXP 23
68907: PUSH
68908: LD_VAR 0 2
68912: ARRAY
68913: PPUSH
68914: LD_INT 30
68916: PUSH
68917: LD_INT 3
68919: PUSH
68920: EMPTY
68921: LIST
68922: LIST
68923: PPUSH
68924: CALL_OW 72
68928: ST_TO_ADDR
// if tmp then
68929: LD_VAR 0 8
68933: IFFALSE 69036
// begin for j in tmp do
68935: LD_ADDR_VAR 0 3
68939: PUSH
68940: LD_VAR 0 8
68944: PUSH
68945: FOR_IN
68946: IFFALSE 69034
// for k in UnitsInside ( j ) do
68948: LD_ADDR_VAR 0 4
68952: PUSH
68953: LD_VAR 0 3
68957: PPUSH
68958: CALL_OW 313
68962: PUSH
68963: FOR_IN
68964: IFFALSE 69030
// if k then
68966: LD_VAR 0 4
68970: IFFALSE 69028
// if not k in mc_repair_vehicle [ i ] then
68972: LD_VAR 0 4
68976: PUSH
68977: LD_EXP 35
68981: PUSH
68982: LD_VAR 0 2
68986: ARRAY
68987: IN
68988: NOT
68989: IFFALSE 69028
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68991: LD_ADDR_EXP 35
68995: PUSH
68996: LD_EXP 35
69000: PPUSH
69001: LD_VAR 0 2
69005: PPUSH
69006: LD_EXP 35
69010: PUSH
69011: LD_VAR 0 2
69015: ARRAY
69016: PUSH
69017: LD_VAR 0 4
69021: UNION
69022: PPUSH
69023: CALL_OW 1
69027: ST_TO_ADDR
69028: GO 68963
69030: POP
69031: POP
69032: GO 68945
69034: POP
69035: POP
// end ; if not mc_repair_vehicle [ i ] then
69036: LD_EXP 35
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: NOT
69047: IFFALSE 69051
// continue ;
69049: GO 68556
// for j in mc_repair_vehicle [ i ] do
69051: LD_ADDR_VAR 0 3
69055: PUSH
69056: LD_EXP 35
69060: PUSH
69061: LD_VAR 0 2
69065: ARRAY
69066: PUSH
69067: FOR_IN
69068: IFFALSE 69245
// begin if GetClass ( j ) <> 3 then
69070: LD_VAR 0 3
69074: PPUSH
69075: CALL_OW 257
69079: PUSH
69080: LD_INT 3
69082: NONEQUAL
69083: IFFALSE 69124
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69085: LD_ADDR_EXP 35
69089: PUSH
69090: LD_EXP 35
69094: PPUSH
69095: LD_VAR 0 2
69099: PPUSH
69100: LD_EXP 35
69104: PUSH
69105: LD_VAR 0 2
69109: ARRAY
69110: PUSH
69111: LD_VAR 0 3
69115: DIFF
69116: PPUSH
69117: CALL_OW 1
69121: ST_TO_ADDR
// continue ;
69122: GO 69067
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69124: LD_VAR 0 3
69128: PPUSH
69129: CALL_OW 311
69133: NOT
69134: PUSH
69135: LD_VAR 0 3
69139: PUSH
69140: LD_EXP 26
69144: PUSH
69145: LD_VAR 0 2
69149: ARRAY
69150: PUSH
69151: LD_INT 1
69153: ARRAY
69154: IN
69155: NOT
69156: AND
69157: PUSH
69158: LD_VAR 0 3
69162: PUSH
69163: LD_EXP 26
69167: PUSH
69168: LD_VAR 0 2
69172: ARRAY
69173: PUSH
69174: LD_INT 2
69176: ARRAY
69177: IN
69178: NOT
69179: AND
69180: IFFALSE 69243
// begin if IsInUnit ( j ) then
69182: LD_VAR 0 3
69186: PPUSH
69187: CALL_OW 310
69191: IFFALSE 69204
// ComExitBuilding ( j ) else
69193: LD_VAR 0 3
69197: PPUSH
69198: CALL_OW 122
69202: GO 69243
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
69204: LD_VAR 0 3
69208: PPUSH
69209: LD_VAR 0 7
69213: PUSH
69214: LD_INT 1
69216: ARRAY
69217: PPUSH
69218: CALL 49597 0 2
69222: NOT
69223: IFFALSE 69243
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
69225: LD_VAR 0 3
69229: PPUSH
69230: LD_VAR 0 7
69234: PUSH
69235: LD_INT 1
69237: ARRAY
69238: PPUSH
69239: CALL_OW 129
// end ; end ;
69243: GO 69067
69245: POP
69246: POP
// end ;
69247: GO 68556
69249: POP
69250: POP
// end ;
69251: LD_VAR 0 1
69255: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69256: LD_INT 0
69258: PPUSH
69259: PPUSH
69260: PPUSH
69261: PPUSH
69262: PPUSH
69263: PPUSH
69264: PPUSH
69265: PPUSH
69266: PPUSH
69267: PPUSH
69268: PPUSH
// if not mc_bases then
69269: LD_EXP 23
69273: NOT
69274: IFFALSE 69278
// exit ;
69276: GO 70080
// for i = 1 to mc_bases do
69278: LD_ADDR_VAR 0 2
69282: PUSH
69283: DOUBLE
69284: LD_INT 1
69286: DEC
69287: ST_TO_ADDR
69288: LD_EXP 23
69292: PUSH
69293: FOR_TO
69294: IFFALSE 70078
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69296: LD_EXP 51
69300: PUSH
69301: LD_VAR 0 2
69305: ARRAY
69306: NOT
69307: PUSH
69308: LD_EXP 26
69312: PUSH
69313: LD_VAR 0 2
69317: ARRAY
69318: PUSH
69319: LD_INT 1
69321: ARRAY
69322: OR
69323: PUSH
69324: LD_EXP 26
69328: PUSH
69329: LD_VAR 0 2
69333: ARRAY
69334: PUSH
69335: LD_INT 2
69337: ARRAY
69338: OR
69339: PUSH
69340: LD_EXP 49
69344: PUSH
69345: LD_VAR 0 2
69349: ARRAY
69350: PPUSH
69351: LD_INT 1
69353: PPUSH
69354: CALL_OW 325
69358: NOT
69359: OR
69360: PUSH
69361: LD_EXP 46
69365: PUSH
69366: LD_VAR 0 2
69370: ARRAY
69371: OR
69372: IFFALSE 69376
// continue ;
69374: GO 69293
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69376: LD_ADDR_VAR 0 8
69380: PUSH
69381: LD_EXP 23
69385: PUSH
69386: LD_VAR 0 2
69390: ARRAY
69391: PPUSH
69392: LD_INT 25
69394: PUSH
69395: LD_INT 4
69397: PUSH
69398: EMPTY
69399: LIST
69400: LIST
69401: PUSH
69402: LD_INT 50
69404: PUSH
69405: EMPTY
69406: LIST
69407: PUSH
69408: LD_INT 3
69410: PUSH
69411: LD_INT 60
69413: PUSH
69414: EMPTY
69415: LIST
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: EMPTY
69422: LIST
69423: LIST
69424: LIST
69425: PPUSH
69426: CALL_OW 72
69430: PUSH
69431: LD_EXP 27
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: DIFF
69442: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69443: LD_ADDR_VAR 0 9
69447: PUSH
69448: LD_EXP 23
69452: PUSH
69453: LD_VAR 0 2
69457: ARRAY
69458: PPUSH
69459: LD_INT 2
69461: PUSH
69462: LD_INT 30
69464: PUSH
69465: LD_INT 0
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: LD_INT 30
69474: PUSH
69475: LD_INT 1
69477: PUSH
69478: EMPTY
69479: LIST
69480: LIST
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: LIST
69486: PPUSH
69487: CALL_OW 72
69491: ST_TO_ADDR
// if not tmp or not dep then
69492: LD_VAR 0 8
69496: NOT
69497: PUSH
69498: LD_VAR 0 9
69502: NOT
69503: OR
69504: IFFALSE 69508
// continue ;
69506: GO 69293
// side := GetSide ( tmp [ 1 ] ) ;
69508: LD_ADDR_VAR 0 11
69512: PUSH
69513: LD_VAR 0 8
69517: PUSH
69518: LD_INT 1
69520: ARRAY
69521: PPUSH
69522: CALL_OW 255
69526: ST_TO_ADDR
// dep := dep [ 1 ] ;
69527: LD_ADDR_VAR 0 9
69531: PUSH
69532: LD_VAR 0 9
69536: PUSH
69537: LD_INT 1
69539: ARRAY
69540: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69541: LD_ADDR_VAR 0 7
69545: PUSH
69546: LD_EXP 51
69550: PUSH
69551: LD_VAR 0 2
69555: ARRAY
69556: PPUSH
69557: LD_INT 22
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: EMPTY
69564: LIST
69565: LIST
69566: PUSH
69567: LD_INT 25
69569: PUSH
69570: LD_INT 12
69572: PUSH
69573: EMPTY
69574: LIST
69575: LIST
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PPUSH
69581: CALL_OW 70
69585: PUSH
69586: LD_INT 22
69588: PUSH
69589: LD_INT 0
69591: PUSH
69592: EMPTY
69593: LIST
69594: LIST
69595: PUSH
69596: LD_INT 25
69598: PUSH
69599: LD_INT 12
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: LD_INT 91
69608: PUSH
69609: LD_VAR 0 9
69613: PUSH
69614: LD_INT 20
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: LIST
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: LIST
69626: PPUSH
69627: CALL_OW 69
69631: UNION
69632: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69633: LD_ADDR_VAR 0 10
69637: PUSH
69638: LD_EXP 51
69642: PUSH
69643: LD_VAR 0 2
69647: ARRAY
69648: PPUSH
69649: LD_INT 81
69651: PUSH
69652: LD_VAR 0 11
69656: PUSH
69657: EMPTY
69658: LIST
69659: LIST
69660: PPUSH
69661: CALL_OW 70
69665: ST_TO_ADDR
// if not apes or danger_at_area then
69666: LD_VAR 0 7
69670: NOT
69671: PUSH
69672: LD_VAR 0 10
69676: OR
69677: IFFALSE 69727
// begin if mc_taming [ i ] then
69679: LD_EXP 54
69683: PUSH
69684: LD_VAR 0 2
69688: ARRAY
69689: IFFALSE 69725
// begin MC_Reset ( i , 121 ) ;
69691: LD_VAR 0 2
69695: PPUSH
69696: LD_INT 121
69698: PPUSH
69699: CALL 54713 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69703: LD_ADDR_EXP 54
69707: PUSH
69708: LD_EXP 54
69712: PPUSH
69713: LD_VAR 0 2
69717: PPUSH
69718: EMPTY
69719: PPUSH
69720: CALL_OW 1
69724: ST_TO_ADDR
// end ; continue ;
69725: GO 69293
// end ; for j in tmp do
69727: LD_ADDR_VAR 0 3
69731: PUSH
69732: LD_VAR 0 8
69736: PUSH
69737: FOR_IN
69738: IFFALSE 70074
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69740: LD_VAR 0 3
69744: PUSH
69745: LD_EXP 54
69749: PUSH
69750: LD_VAR 0 2
69754: ARRAY
69755: IN
69756: NOT
69757: PUSH
69758: LD_EXP 54
69762: PUSH
69763: LD_VAR 0 2
69767: ARRAY
69768: PUSH
69769: LD_INT 3
69771: LESS
69772: AND
69773: IFFALSE 69831
// begin SetTag ( j , 121 ) ;
69775: LD_VAR 0 3
69779: PPUSH
69780: LD_INT 121
69782: PPUSH
69783: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69787: LD_ADDR_EXP 54
69791: PUSH
69792: LD_EXP 54
69796: PPUSH
69797: LD_VAR 0 2
69801: PUSH
69802: LD_EXP 54
69806: PUSH
69807: LD_VAR 0 2
69811: ARRAY
69812: PUSH
69813: LD_INT 1
69815: PLUS
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PPUSH
69821: LD_VAR 0 3
69825: PPUSH
69826: CALL 15990 0 3
69830: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69831: LD_VAR 0 3
69835: PUSH
69836: LD_EXP 54
69840: PUSH
69841: LD_VAR 0 2
69845: ARRAY
69846: IN
69847: IFFALSE 70072
// begin if GetClass ( j ) <> 4 then
69849: LD_VAR 0 3
69853: PPUSH
69854: CALL_OW 257
69858: PUSH
69859: LD_INT 4
69861: NONEQUAL
69862: IFFALSE 69915
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69864: LD_ADDR_EXP 54
69868: PUSH
69869: LD_EXP 54
69873: PPUSH
69874: LD_VAR 0 2
69878: PPUSH
69879: LD_EXP 54
69883: PUSH
69884: LD_VAR 0 2
69888: ARRAY
69889: PUSH
69890: LD_VAR 0 3
69894: DIFF
69895: PPUSH
69896: CALL_OW 1
69900: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69901: LD_VAR 0 3
69905: PPUSH
69906: LD_INT 0
69908: PPUSH
69909: CALL_OW 109
// continue ;
69913: GO 69737
// end ; if IsInUnit ( j ) then
69915: LD_VAR 0 3
69919: PPUSH
69920: CALL_OW 310
69924: IFFALSE 69935
// ComExitBuilding ( j ) ;
69926: LD_VAR 0 3
69930: PPUSH
69931: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69935: LD_ADDR_VAR 0 6
69939: PUSH
69940: LD_VAR 0 7
69944: PPUSH
69945: LD_VAR 0 3
69949: PPUSH
69950: CALL_OW 74
69954: ST_TO_ADDR
// if not ape then
69955: LD_VAR 0 6
69959: NOT
69960: IFFALSE 69964
// break ;
69962: GO 70074
// x := GetX ( ape ) ;
69964: LD_ADDR_VAR 0 4
69968: PUSH
69969: LD_VAR 0 6
69973: PPUSH
69974: CALL_OW 250
69978: ST_TO_ADDR
// y := GetY ( ape ) ;
69979: LD_ADDR_VAR 0 5
69983: PUSH
69984: LD_VAR 0 6
69988: PPUSH
69989: CALL_OW 251
69993: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69994: LD_VAR 0 4
69998: PPUSH
69999: LD_VAR 0 5
70003: PPUSH
70004: CALL_OW 488
70008: NOT
70009: PUSH
70010: LD_VAR 0 11
70014: PPUSH
70015: LD_VAR 0 4
70019: PPUSH
70020: LD_VAR 0 5
70024: PPUSH
70025: LD_INT 20
70027: PPUSH
70028: CALL 16886 0 4
70032: PUSH
70033: LD_INT 4
70035: ARRAY
70036: OR
70037: IFFALSE 70041
// break ;
70039: GO 70074
// if not HasTask ( j ) then
70041: LD_VAR 0 3
70045: PPUSH
70046: CALL_OW 314
70050: NOT
70051: IFFALSE 70072
// ComTameXY ( j , x , y ) ;
70053: LD_VAR 0 3
70057: PPUSH
70058: LD_VAR 0 4
70062: PPUSH
70063: LD_VAR 0 5
70067: PPUSH
70068: CALL_OW 131
// end ; end ;
70072: GO 69737
70074: POP
70075: POP
// end ;
70076: GO 69293
70078: POP
70079: POP
// end ;
70080: LD_VAR 0 1
70084: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70085: LD_INT 0
70087: PPUSH
70088: PPUSH
70089: PPUSH
70090: PPUSH
70091: PPUSH
70092: PPUSH
70093: PPUSH
70094: PPUSH
// if not mc_bases then
70095: LD_EXP 23
70099: NOT
70100: IFFALSE 70104
// exit ;
70102: GO 70730
// for i = 1 to mc_bases do
70104: LD_ADDR_VAR 0 2
70108: PUSH
70109: DOUBLE
70110: LD_INT 1
70112: DEC
70113: ST_TO_ADDR
70114: LD_EXP 23
70118: PUSH
70119: FOR_TO
70120: IFFALSE 70728
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70122: LD_EXP 52
70126: PUSH
70127: LD_VAR 0 2
70131: ARRAY
70132: NOT
70133: PUSH
70134: LD_EXP 52
70138: PUSH
70139: LD_VAR 0 2
70143: ARRAY
70144: PPUSH
70145: LD_INT 25
70147: PUSH
70148: LD_INT 12
70150: PUSH
70151: EMPTY
70152: LIST
70153: LIST
70154: PPUSH
70155: CALL_OW 72
70159: NOT
70160: OR
70161: IFFALSE 70165
// continue ;
70163: GO 70119
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70165: LD_ADDR_VAR 0 5
70169: PUSH
70170: LD_EXP 52
70174: PUSH
70175: LD_VAR 0 2
70179: ARRAY
70180: PUSH
70181: LD_INT 1
70183: ARRAY
70184: PPUSH
70185: CALL_OW 255
70189: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70190: LD_VAR 0 5
70194: PPUSH
70195: LD_INT 2
70197: PPUSH
70198: CALL_OW 325
70202: IFFALSE 70455
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70204: LD_ADDR_VAR 0 4
70208: PUSH
70209: LD_EXP 52
70213: PUSH
70214: LD_VAR 0 2
70218: ARRAY
70219: PPUSH
70220: LD_INT 25
70222: PUSH
70223: LD_INT 16
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: PPUSH
70230: CALL_OW 72
70234: ST_TO_ADDR
// if tmp < 6 then
70235: LD_VAR 0 4
70239: PUSH
70240: LD_INT 6
70242: LESS
70243: IFFALSE 70455
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70245: LD_ADDR_VAR 0 6
70249: PUSH
70250: LD_EXP 23
70254: PUSH
70255: LD_VAR 0 2
70259: ARRAY
70260: PPUSH
70261: LD_INT 2
70263: PUSH
70264: LD_INT 30
70266: PUSH
70267: LD_INT 0
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: PUSH
70274: LD_INT 30
70276: PUSH
70277: LD_INT 1
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: LIST
70288: PPUSH
70289: CALL_OW 72
70293: ST_TO_ADDR
// if depot then
70294: LD_VAR 0 6
70298: IFFALSE 70455
// begin selected := 0 ;
70300: LD_ADDR_VAR 0 7
70304: PUSH
70305: LD_INT 0
70307: ST_TO_ADDR
// for j in depot do
70308: LD_ADDR_VAR 0 3
70312: PUSH
70313: LD_VAR 0 6
70317: PUSH
70318: FOR_IN
70319: IFFALSE 70350
// begin if UnitsInside ( j ) < 6 then
70321: LD_VAR 0 3
70325: PPUSH
70326: CALL_OW 313
70330: PUSH
70331: LD_INT 6
70333: LESS
70334: IFFALSE 70348
// begin selected := j ;
70336: LD_ADDR_VAR 0 7
70340: PUSH
70341: LD_VAR 0 3
70345: ST_TO_ADDR
// break ;
70346: GO 70350
// end ; end ;
70348: GO 70318
70350: POP
70351: POP
// if selected then
70352: LD_VAR 0 7
70356: IFFALSE 70455
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70358: LD_ADDR_VAR 0 3
70362: PUSH
70363: LD_EXP 52
70367: PUSH
70368: LD_VAR 0 2
70372: ARRAY
70373: PPUSH
70374: LD_INT 25
70376: PUSH
70377: LD_INT 12
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PPUSH
70384: CALL_OW 72
70388: PUSH
70389: FOR_IN
70390: IFFALSE 70453
// if not HasTask ( j ) then
70392: LD_VAR 0 3
70396: PPUSH
70397: CALL_OW 314
70401: NOT
70402: IFFALSE 70451
// begin if not IsInUnit ( j ) then
70404: LD_VAR 0 3
70408: PPUSH
70409: CALL_OW 310
70413: NOT
70414: IFFALSE 70430
// ComEnterUnit ( j , selected ) ;
70416: LD_VAR 0 3
70420: PPUSH
70421: LD_VAR 0 7
70425: PPUSH
70426: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70430: LD_VAR 0 3
70434: PPUSH
70435: LD_INT 16
70437: PPUSH
70438: CALL_OW 183
// AddComExitBuilding ( j ) ;
70442: LD_VAR 0 3
70446: PPUSH
70447: CALL_OW 182
// end ;
70451: GO 70389
70453: POP
70454: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70455: LD_VAR 0 5
70459: PPUSH
70460: LD_INT 11
70462: PPUSH
70463: CALL_OW 325
70467: IFFALSE 70726
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70469: LD_ADDR_VAR 0 4
70473: PUSH
70474: LD_EXP 52
70478: PUSH
70479: LD_VAR 0 2
70483: ARRAY
70484: PPUSH
70485: LD_INT 25
70487: PUSH
70488: LD_INT 16
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PPUSH
70495: CALL_OW 72
70499: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70500: LD_VAR 0 4
70504: PUSH
70505: LD_INT 6
70507: GREATEREQUAL
70508: PUSH
70509: LD_VAR 0 5
70513: PPUSH
70514: LD_INT 2
70516: PPUSH
70517: CALL_OW 325
70521: NOT
70522: OR
70523: IFFALSE 70726
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70525: LD_ADDR_VAR 0 8
70529: PUSH
70530: LD_EXP 23
70534: PUSH
70535: LD_VAR 0 2
70539: ARRAY
70540: PPUSH
70541: LD_INT 2
70543: PUSH
70544: LD_INT 30
70546: PUSH
70547: LD_INT 4
70549: PUSH
70550: EMPTY
70551: LIST
70552: LIST
70553: PUSH
70554: LD_INT 30
70556: PUSH
70557: LD_INT 5
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PUSH
70564: EMPTY
70565: LIST
70566: LIST
70567: LIST
70568: PPUSH
70569: CALL_OW 72
70573: ST_TO_ADDR
// if barracks then
70574: LD_VAR 0 8
70578: IFFALSE 70726
// begin selected := 0 ;
70580: LD_ADDR_VAR 0 7
70584: PUSH
70585: LD_INT 0
70587: ST_TO_ADDR
// for j in barracks do
70588: LD_ADDR_VAR 0 3
70592: PUSH
70593: LD_VAR 0 8
70597: PUSH
70598: FOR_IN
70599: IFFALSE 70630
// begin if UnitsInside ( j ) < 6 then
70601: LD_VAR 0 3
70605: PPUSH
70606: CALL_OW 313
70610: PUSH
70611: LD_INT 6
70613: LESS
70614: IFFALSE 70628
// begin selected := j ;
70616: LD_ADDR_VAR 0 7
70620: PUSH
70621: LD_VAR 0 3
70625: ST_TO_ADDR
// break ;
70626: GO 70630
// end ; end ;
70628: GO 70598
70630: POP
70631: POP
// if selected then
70632: LD_VAR 0 7
70636: IFFALSE 70726
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70638: LD_ADDR_VAR 0 3
70642: PUSH
70643: LD_EXP 52
70647: PUSH
70648: LD_VAR 0 2
70652: ARRAY
70653: PPUSH
70654: LD_INT 25
70656: PUSH
70657: LD_INT 12
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PPUSH
70664: CALL_OW 72
70668: PUSH
70669: FOR_IN
70670: IFFALSE 70724
// if not IsInUnit ( j ) and not HasTask ( j ) then
70672: LD_VAR 0 3
70676: PPUSH
70677: CALL_OW 310
70681: NOT
70682: PUSH
70683: LD_VAR 0 3
70687: PPUSH
70688: CALL_OW 314
70692: NOT
70693: AND
70694: IFFALSE 70722
// begin ComEnterUnit ( j , selected ) ;
70696: LD_VAR 0 3
70700: PPUSH
70701: LD_VAR 0 7
70705: PPUSH
70706: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70710: LD_VAR 0 3
70714: PPUSH
70715: LD_INT 15
70717: PPUSH
70718: CALL_OW 183
// end ;
70722: GO 70669
70724: POP
70725: POP
// end ; end ; end ; end ; end ;
70726: GO 70119
70728: POP
70729: POP
// end ;
70730: LD_VAR 0 1
70734: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70735: LD_INT 0
70737: PPUSH
70738: PPUSH
70739: PPUSH
70740: PPUSH
// if not mc_bases then
70741: LD_EXP 23
70745: NOT
70746: IFFALSE 70750
// exit ;
70748: GO 70928
// for i = 1 to mc_bases do
70750: LD_ADDR_VAR 0 2
70754: PUSH
70755: DOUBLE
70756: LD_INT 1
70758: DEC
70759: ST_TO_ADDR
70760: LD_EXP 23
70764: PUSH
70765: FOR_TO
70766: IFFALSE 70926
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70768: LD_ADDR_VAR 0 4
70772: PUSH
70773: LD_EXP 23
70777: PUSH
70778: LD_VAR 0 2
70782: ARRAY
70783: PPUSH
70784: LD_INT 25
70786: PUSH
70787: LD_INT 9
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PPUSH
70794: CALL_OW 72
70798: ST_TO_ADDR
// if not tmp then
70799: LD_VAR 0 4
70803: NOT
70804: IFFALSE 70808
// continue ;
70806: GO 70765
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70808: LD_EXP 49
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PPUSH
70819: LD_INT 29
70821: PPUSH
70822: CALL_OW 325
70826: NOT
70827: PUSH
70828: LD_EXP 49
70832: PUSH
70833: LD_VAR 0 2
70837: ARRAY
70838: PPUSH
70839: LD_INT 28
70841: PPUSH
70842: CALL_OW 325
70846: NOT
70847: AND
70848: IFFALSE 70852
// continue ;
70850: GO 70765
// for j in tmp do
70852: LD_ADDR_VAR 0 3
70856: PUSH
70857: LD_VAR 0 4
70861: PUSH
70862: FOR_IN
70863: IFFALSE 70922
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70865: LD_VAR 0 3
70869: PUSH
70870: LD_EXP 26
70874: PUSH
70875: LD_VAR 0 2
70879: ARRAY
70880: PUSH
70881: LD_INT 1
70883: ARRAY
70884: IN
70885: NOT
70886: PUSH
70887: LD_VAR 0 3
70891: PUSH
70892: LD_EXP 26
70896: PUSH
70897: LD_VAR 0 2
70901: ARRAY
70902: PUSH
70903: LD_INT 2
70905: ARRAY
70906: IN
70907: NOT
70908: AND
70909: IFFALSE 70920
// ComSpaceTimeShoot ( j ) ;
70911: LD_VAR 0 3
70915: PPUSH
70916: CALL 11951 0 1
70920: GO 70862
70922: POP
70923: POP
// end ;
70924: GO 70765
70926: POP
70927: POP
// end ;
70928: LD_VAR 0 1
70932: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70933: LD_INT 0
70935: PPUSH
70936: PPUSH
70937: PPUSH
70938: PPUSH
70939: PPUSH
70940: PPUSH
70941: PPUSH
70942: PPUSH
70943: PPUSH
// if not mc_bases then
70944: LD_EXP 23
70948: NOT
70949: IFFALSE 70953
// exit ;
70951: GO 71575
// for i = 1 to mc_bases do
70953: LD_ADDR_VAR 0 2
70957: PUSH
70958: DOUBLE
70959: LD_INT 1
70961: DEC
70962: ST_TO_ADDR
70963: LD_EXP 23
70967: PUSH
70968: FOR_TO
70969: IFFALSE 71573
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70971: LD_EXP 58
70975: PUSH
70976: LD_VAR 0 2
70980: ARRAY
70981: NOT
70982: PUSH
70983: LD_INT 38
70985: PPUSH
70986: LD_EXP 49
70990: PUSH
70991: LD_VAR 0 2
70995: ARRAY
70996: PPUSH
70997: CALL_OW 321
71001: PUSH
71002: LD_INT 2
71004: NONEQUAL
71005: OR
71006: IFFALSE 71010
// continue ;
71008: GO 70968
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71010: LD_ADDR_VAR 0 8
71014: PUSH
71015: LD_EXP 23
71019: PUSH
71020: LD_VAR 0 2
71024: ARRAY
71025: PPUSH
71026: LD_INT 30
71028: PUSH
71029: LD_INT 34
71031: PUSH
71032: EMPTY
71033: LIST
71034: LIST
71035: PPUSH
71036: CALL_OW 72
71040: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71041: LD_ADDR_VAR 0 9
71045: PUSH
71046: LD_EXP 23
71050: PUSH
71051: LD_VAR 0 2
71055: ARRAY
71056: PPUSH
71057: LD_INT 25
71059: PUSH
71060: LD_INT 4
71062: PUSH
71063: EMPTY
71064: LIST
71065: LIST
71066: PPUSH
71067: CALL_OW 72
71071: PPUSH
71072: LD_INT 0
71074: PPUSH
71075: CALL 45259 0 2
71079: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71080: LD_VAR 0 9
71084: NOT
71085: PUSH
71086: LD_VAR 0 8
71090: NOT
71091: OR
71092: PUSH
71093: LD_EXP 23
71097: PUSH
71098: LD_VAR 0 2
71102: ARRAY
71103: PPUSH
71104: LD_INT 124
71106: PPUSH
71107: CALL 45259 0 2
71111: OR
71112: IFFALSE 71116
// continue ;
71114: GO 70968
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71116: LD_EXP 59
71120: PUSH
71121: LD_VAR 0 2
71125: ARRAY
71126: PUSH
71127: LD_EXP 58
71131: PUSH
71132: LD_VAR 0 2
71136: ARRAY
71137: LESS
71138: PUSH
71139: LD_EXP 59
71143: PUSH
71144: LD_VAR 0 2
71148: ARRAY
71149: PUSH
71150: LD_VAR 0 8
71154: LESS
71155: AND
71156: IFFALSE 71571
// begin tmp := sci [ 1 ] ;
71158: LD_ADDR_VAR 0 7
71162: PUSH
71163: LD_VAR 0 9
71167: PUSH
71168: LD_INT 1
71170: ARRAY
71171: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71172: LD_VAR 0 7
71176: PPUSH
71177: LD_INT 124
71179: PPUSH
71180: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71184: LD_ADDR_VAR 0 3
71188: PUSH
71189: DOUBLE
71190: LD_EXP 58
71194: PUSH
71195: LD_VAR 0 2
71199: ARRAY
71200: INC
71201: ST_TO_ADDR
71202: LD_EXP 58
71206: PUSH
71207: LD_VAR 0 2
71211: ARRAY
71212: PUSH
71213: FOR_DOWNTO
71214: IFFALSE 71557
// begin if IsInUnit ( tmp ) then
71216: LD_VAR 0 7
71220: PPUSH
71221: CALL_OW 310
71225: IFFALSE 71236
// ComExitBuilding ( tmp ) ;
71227: LD_VAR 0 7
71231: PPUSH
71232: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71236: LD_INT 35
71238: PPUSH
71239: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71243: LD_VAR 0 7
71247: PPUSH
71248: CALL_OW 310
71252: NOT
71253: PUSH
71254: LD_VAR 0 7
71258: PPUSH
71259: CALL_OW 314
71263: NOT
71264: AND
71265: IFFALSE 71236
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71267: LD_ADDR_VAR 0 6
71271: PUSH
71272: LD_VAR 0 7
71276: PPUSH
71277: CALL_OW 250
71281: PUSH
71282: LD_VAR 0 7
71286: PPUSH
71287: CALL_OW 251
71291: PUSH
71292: EMPTY
71293: LIST
71294: LIST
71295: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71296: LD_INT 35
71298: PPUSH
71299: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71303: LD_ADDR_VAR 0 4
71307: PUSH
71308: LD_EXP 58
71312: PUSH
71313: LD_VAR 0 2
71317: ARRAY
71318: PUSH
71319: LD_VAR 0 3
71323: ARRAY
71324: PUSH
71325: LD_INT 1
71327: ARRAY
71328: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71329: LD_ADDR_VAR 0 5
71333: PUSH
71334: LD_EXP 58
71338: PUSH
71339: LD_VAR 0 2
71343: ARRAY
71344: PUSH
71345: LD_VAR 0 3
71349: ARRAY
71350: PUSH
71351: LD_INT 2
71353: ARRAY
71354: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71355: LD_VAR 0 7
71359: PPUSH
71360: LD_INT 10
71362: PPUSH
71363: CALL 18589 0 2
71367: PUSH
71368: LD_INT 4
71370: ARRAY
71371: IFFALSE 71409
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71373: LD_VAR 0 7
71377: PPUSH
71378: LD_VAR 0 6
71382: PUSH
71383: LD_INT 1
71385: ARRAY
71386: PPUSH
71387: LD_VAR 0 6
71391: PUSH
71392: LD_INT 2
71394: ARRAY
71395: PPUSH
71396: CALL_OW 111
// wait ( 0 0$10 ) ;
71400: LD_INT 350
71402: PPUSH
71403: CALL_OW 67
// end else
71407: GO 71435
// begin ComMoveXY ( tmp , x , y ) ;
71409: LD_VAR 0 7
71413: PPUSH
71414: LD_VAR 0 4
71418: PPUSH
71419: LD_VAR 0 5
71423: PPUSH
71424: CALL_OW 111
// wait ( 0 0$3 ) ;
71428: LD_INT 105
71430: PPUSH
71431: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71435: LD_VAR 0 7
71439: PPUSH
71440: LD_VAR 0 4
71444: PPUSH
71445: LD_VAR 0 5
71449: PPUSH
71450: CALL_OW 307
71454: IFFALSE 71296
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71456: LD_VAR 0 7
71460: PPUSH
71461: LD_VAR 0 4
71465: PPUSH
71466: LD_VAR 0 5
71470: PPUSH
71471: LD_VAR 0 8
71475: PUSH
71476: LD_VAR 0 3
71480: ARRAY
71481: PPUSH
71482: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71486: LD_INT 35
71488: PPUSH
71489: CALL_OW 67
// until not HasTask ( tmp ) ;
71493: LD_VAR 0 7
71497: PPUSH
71498: CALL_OW 314
71502: NOT
71503: IFFALSE 71486
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71505: LD_ADDR_EXP 59
71509: PUSH
71510: LD_EXP 59
71514: PPUSH
71515: LD_VAR 0 2
71519: PUSH
71520: LD_EXP 59
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: PUSH
71531: LD_INT 1
71533: PLUS
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PPUSH
71539: LD_VAR 0 8
71543: PUSH
71544: LD_VAR 0 3
71548: ARRAY
71549: PPUSH
71550: CALL 15990 0 3
71554: ST_TO_ADDR
// end ;
71555: GO 71213
71557: POP
71558: POP
// MC_Reset ( i , 124 ) ;
71559: LD_VAR 0 2
71563: PPUSH
71564: LD_INT 124
71566: PPUSH
71567: CALL 54713 0 2
// end ; end ;
71571: GO 70968
71573: POP
71574: POP
// end ;
71575: LD_VAR 0 1
71579: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71580: LD_INT 0
71582: PPUSH
71583: PPUSH
71584: PPUSH
// if not mc_bases then
71585: LD_EXP 23
71589: NOT
71590: IFFALSE 71594
// exit ;
71592: GO 72200
// for i = 1 to mc_bases do
71594: LD_ADDR_VAR 0 2
71598: PUSH
71599: DOUBLE
71600: LD_INT 1
71602: DEC
71603: ST_TO_ADDR
71604: LD_EXP 23
71608: PUSH
71609: FOR_TO
71610: IFFALSE 72198
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71612: LD_ADDR_VAR 0 3
71616: PUSH
71617: LD_EXP 23
71621: PUSH
71622: LD_VAR 0 2
71626: ARRAY
71627: PPUSH
71628: LD_INT 25
71630: PUSH
71631: LD_INT 4
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PPUSH
71638: CALL_OW 72
71642: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71643: LD_VAR 0 3
71647: NOT
71648: PUSH
71649: LD_EXP 60
71653: PUSH
71654: LD_VAR 0 2
71658: ARRAY
71659: NOT
71660: OR
71661: PUSH
71662: LD_EXP 23
71666: PUSH
71667: LD_VAR 0 2
71671: ARRAY
71672: PPUSH
71673: LD_INT 2
71675: PUSH
71676: LD_INT 30
71678: PUSH
71679: LD_INT 0
71681: PUSH
71682: EMPTY
71683: LIST
71684: LIST
71685: PUSH
71686: LD_INT 30
71688: PUSH
71689: LD_INT 1
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: LIST
71700: PPUSH
71701: CALL_OW 72
71705: NOT
71706: OR
71707: IFFALSE 71757
// begin if mc_deposits_finder [ i ] then
71709: LD_EXP 61
71713: PUSH
71714: LD_VAR 0 2
71718: ARRAY
71719: IFFALSE 71755
// begin MC_Reset ( i , 125 ) ;
71721: LD_VAR 0 2
71725: PPUSH
71726: LD_INT 125
71728: PPUSH
71729: CALL 54713 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71733: LD_ADDR_EXP 61
71737: PUSH
71738: LD_EXP 61
71742: PPUSH
71743: LD_VAR 0 2
71747: PPUSH
71748: EMPTY
71749: PPUSH
71750: CALL_OW 1
71754: ST_TO_ADDR
// end ; continue ;
71755: GO 71609
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71757: LD_EXP 60
71761: PUSH
71762: LD_VAR 0 2
71766: ARRAY
71767: PUSH
71768: LD_INT 1
71770: ARRAY
71771: PUSH
71772: LD_INT 3
71774: ARRAY
71775: PUSH
71776: LD_INT 1
71778: EQUAL
71779: PUSH
71780: LD_INT 20
71782: PPUSH
71783: LD_EXP 49
71787: PUSH
71788: LD_VAR 0 2
71792: ARRAY
71793: PPUSH
71794: CALL_OW 321
71798: PUSH
71799: LD_INT 2
71801: NONEQUAL
71802: AND
71803: IFFALSE 71853
// begin if mc_deposits_finder [ i ] then
71805: LD_EXP 61
71809: PUSH
71810: LD_VAR 0 2
71814: ARRAY
71815: IFFALSE 71851
// begin MC_Reset ( i , 125 ) ;
71817: LD_VAR 0 2
71821: PPUSH
71822: LD_INT 125
71824: PPUSH
71825: CALL 54713 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71829: LD_ADDR_EXP 61
71833: PUSH
71834: LD_EXP 61
71838: PPUSH
71839: LD_VAR 0 2
71843: PPUSH
71844: EMPTY
71845: PPUSH
71846: CALL_OW 1
71850: ST_TO_ADDR
// end ; continue ;
71851: GO 71609
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71853: LD_EXP 60
71857: PUSH
71858: LD_VAR 0 2
71862: ARRAY
71863: PUSH
71864: LD_INT 1
71866: ARRAY
71867: PUSH
71868: LD_INT 1
71870: ARRAY
71871: PPUSH
71872: LD_EXP 60
71876: PUSH
71877: LD_VAR 0 2
71881: ARRAY
71882: PUSH
71883: LD_INT 1
71885: ARRAY
71886: PUSH
71887: LD_INT 2
71889: ARRAY
71890: PPUSH
71891: LD_EXP 49
71895: PUSH
71896: LD_VAR 0 2
71900: ARRAY
71901: PPUSH
71902: CALL_OW 440
71906: IFFALSE 71949
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71908: LD_ADDR_EXP 60
71912: PUSH
71913: LD_EXP 60
71917: PPUSH
71918: LD_VAR 0 2
71922: PPUSH
71923: LD_EXP 60
71927: PUSH
71928: LD_VAR 0 2
71932: ARRAY
71933: PPUSH
71934: LD_INT 1
71936: PPUSH
71937: CALL_OW 3
71941: PPUSH
71942: CALL_OW 1
71946: ST_TO_ADDR
71947: GO 72196
// begin if not mc_deposits_finder [ i ] then
71949: LD_EXP 61
71953: PUSH
71954: LD_VAR 0 2
71958: ARRAY
71959: NOT
71960: IFFALSE 72012
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71962: LD_ADDR_EXP 61
71966: PUSH
71967: LD_EXP 61
71971: PPUSH
71972: LD_VAR 0 2
71976: PPUSH
71977: LD_VAR 0 3
71981: PUSH
71982: LD_INT 1
71984: ARRAY
71985: PUSH
71986: EMPTY
71987: LIST
71988: PPUSH
71989: CALL_OW 1
71993: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71994: LD_VAR 0 3
71998: PUSH
71999: LD_INT 1
72001: ARRAY
72002: PPUSH
72003: LD_INT 125
72005: PPUSH
72006: CALL_OW 109
// end else
72010: GO 72196
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72012: LD_EXP 61
72016: PUSH
72017: LD_VAR 0 2
72021: ARRAY
72022: PUSH
72023: LD_INT 1
72025: ARRAY
72026: PPUSH
72027: CALL_OW 310
72031: IFFALSE 72054
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72033: LD_EXP 61
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: PUSH
72044: LD_INT 1
72046: ARRAY
72047: PPUSH
72048: CALL_OW 122
72052: GO 72196
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72054: LD_EXP 61
72058: PUSH
72059: LD_VAR 0 2
72063: ARRAY
72064: PUSH
72065: LD_INT 1
72067: ARRAY
72068: PPUSH
72069: CALL_OW 314
72073: NOT
72074: PUSH
72075: LD_EXP 61
72079: PUSH
72080: LD_VAR 0 2
72084: ARRAY
72085: PUSH
72086: LD_INT 1
72088: ARRAY
72089: PPUSH
72090: LD_EXP 60
72094: PUSH
72095: LD_VAR 0 2
72099: ARRAY
72100: PUSH
72101: LD_INT 1
72103: ARRAY
72104: PUSH
72105: LD_INT 1
72107: ARRAY
72108: PPUSH
72109: LD_EXP 60
72113: PUSH
72114: LD_VAR 0 2
72118: ARRAY
72119: PUSH
72120: LD_INT 1
72122: ARRAY
72123: PUSH
72124: LD_INT 2
72126: ARRAY
72127: PPUSH
72128: CALL_OW 297
72132: PUSH
72133: LD_INT 6
72135: GREATER
72136: AND
72137: IFFALSE 72196
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72139: LD_EXP 61
72143: PUSH
72144: LD_VAR 0 2
72148: ARRAY
72149: PUSH
72150: LD_INT 1
72152: ARRAY
72153: PPUSH
72154: LD_EXP 60
72158: PUSH
72159: LD_VAR 0 2
72163: ARRAY
72164: PUSH
72165: LD_INT 1
72167: ARRAY
72168: PUSH
72169: LD_INT 1
72171: ARRAY
72172: PPUSH
72173: LD_EXP 60
72177: PUSH
72178: LD_VAR 0 2
72182: ARRAY
72183: PUSH
72184: LD_INT 1
72186: ARRAY
72187: PUSH
72188: LD_INT 2
72190: ARRAY
72191: PPUSH
72192: CALL_OW 111
// end ; end ; end ;
72196: GO 71609
72198: POP
72199: POP
// end ;
72200: LD_VAR 0 1
72204: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72205: LD_INT 0
72207: PPUSH
72208: PPUSH
72209: PPUSH
72210: PPUSH
72211: PPUSH
72212: PPUSH
72213: PPUSH
72214: PPUSH
72215: PPUSH
72216: PPUSH
72217: PPUSH
// if not mc_bases then
72218: LD_EXP 23
72222: NOT
72223: IFFALSE 72227
// exit ;
72225: GO 73167
// for i = 1 to mc_bases do
72227: LD_ADDR_VAR 0 2
72231: PUSH
72232: DOUBLE
72233: LD_INT 1
72235: DEC
72236: ST_TO_ADDR
72237: LD_EXP 23
72241: PUSH
72242: FOR_TO
72243: IFFALSE 73165
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72245: LD_EXP 23
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: NOT
72256: PUSH
72257: LD_EXP 46
72261: PUSH
72262: LD_VAR 0 2
72266: ARRAY
72267: OR
72268: IFFALSE 72272
// continue ;
72270: GO 72242
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72272: LD_ADDR_VAR 0 7
72276: PUSH
72277: LD_EXP 23
72281: PUSH
72282: LD_VAR 0 2
72286: ARRAY
72287: PUSH
72288: LD_INT 1
72290: ARRAY
72291: PPUSH
72292: CALL_OW 248
72296: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72297: LD_VAR 0 7
72301: PUSH
72302: LD_INT 3
72304: EQUAL
72305: PUSH
72306: LD_EXP 42
72310: PUSH
72311: LD_VAR 0 2
72315: ARRAY
72316: PUSH
72317: LD_EXP 45
72321: PUSH
72322: LD_VAR 0 2
72326: ARRAY
72327: UNION
72328: PPUSH
72329: LD_INT 33
72331: PUSH
72332: LD_INT 2
72334: PUSH
72335: EMPTY
72336: LIST
72337: LIST
72338: PPUSH
72339: CALL_OW 72
72343: NOT
72344: OR
72345: IFFALSE 72349
// continue ;
72347: GO 72242
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72349: LD_ADDR_VAR 0 9
72353: PUSH
72354: LD_EXP 23
72358: PUSH
72359: LD_VAR 0 2
72363: ARRAY
72364: PPUSH
72365: LD_INT 30
72367: PUSH
72368: LD_INT 36
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PPUSH
72375: CALL_OW 72
72379: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72380: LD_ADDR_VAR 0 10
72384: PUSH
72385: LD_EXP 42
72389: PUSH
72390: LD_VAR 0 2
72394: ARRAY
72395: PPUSH
72396: LD_INT 34
72398: PUSH
72399: LD_INT 31
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PPUSH
72406: CALL_OW 72
72410: ST_TO_ADDR
// if not cts and not mcts then
72411: LD_VAR 0 9
72415: NOT
72416: PUSH
72417: LD_VAR 0 10
72421: NOT
72422: AND
72423: IFFALSE 72427
// continue ;
72425: GO 72242
// x := cts ;
72427: LD_ADDR_VAR 0 11
72431: PUSH
72432: LD_VAR 0 9
72436: ST_TO_ADDR
// if not x then
72437: LD_VAR 0 11
72441: NOT
72442: IFFALSE 72454
// x := mcts ;
72444: LD_ADDR_VAR 0 11
72448: PUSH
72449: LD_VAR 0 10
72453: ST_TO_ADDR
// if not x then
72454: LD_VAR 0 11
72458: NOT
72459: IFFALSE 72463
// continue ;
72461: GO 72242
// if mc_remote_driver [ i ] then
72463: LD_EXP 63
72467: PUSH
72468: LD_VAR 0 2
72472: ARRAY
72473: IFFALSE 72860
// for j in mc_remote_driver [ i ] do
72475: LD_ADDR_VAR 0 3
72479: PUSH
72480: LD_EXP 63
72484: PUSH
72485: LD_VAR 0 2
72489: ARRAY
72490: PUSH
72491: FOR_IN
72492: IFFALSE 72858
// begin if GetClass ( j ) <> 3 then
72494: LD_VAR 0 3
72498: PPUSH
72499: CALL_OW 257
72503: PUSH
72504: LD_INT 3
72506: NONEQUAL
72507: IFFALSE 72560
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72509: LD_ADDR_EXP 63
72513: PUSH
72514: LD_EXP 63
72518: PPUSH
72519: LD_VAR 0 2
72523: PPUSH
72524: LD_EXP 63
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PUSH
72535: LD_VAR 0 3
72539: DIFF
72540: PPUSH
72541: CALL_OW 1
72545: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72546: LD_VAR 0 3
72550: PPUSH
72551: LD_INT 0
72553: PPUSH
72554: CALL_OW 109
// continue ;
72558: GO 72491
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72560: LD_EXP 42
72564: PUSH
72565: LD_VAR 0 2
72569: ARRAY
72570: PPUSH
72571: LD_INT 34
72573: PUSH
72574: LD_INT 31
72576: PUSH
72577: EMPTY
72578: LIST
72579: LIST
72580: PUSH
72581: LD_INT 58
72583: PUSH
72584: EMPTY
72585: LIST
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PPUSH
72591: CALL_OW 72
72595: PUSH
72596: LD_VAR 0 3
72600: PPUSH
72601: CALL 45347 0 1
72605: NOT
72606: AND
72607: IFFALSE 72678
// begin if IsInUnit ( j ) then
72609: LD_VAR 0 3
72613: PPUSH
72614: CALL_OW 310
72618: IFFALSE 72629
// ComExitBuilding ( j ) ;
72620: LD_VAR 0 3
72624: PPUSH
72625: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72629: LD_VAR 0 3
72633: PPUSH
72634: LD_EXP 42
72638: PUSH
72639: LD_VAR 0 2
72643: ARRAY
72644: PPUSH
72645: LD_INT 34
72647: PUSH
72648: LD_INT 31
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 58
72657: PUSH
72658: EMPTY
72659: LIST
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PPUSH
72665: CALL_OW 72
72669: PUSH
72670: LD_INT 1
72672: ARRAY
72673: PPUSH
72674: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72678: LD_VAR 0 3
72682: PPUSH
72683: CALL_OW 310
72687: NOT
72688: PUSH
72689: LD_VAR 0 3
72693: PPUSH
72694: CALL_OW 310
72698: PPUSH
72699: CALL_OW 266
72703: PUSH
72704: LD_INT 36
72706: NONEQUAL
72707: PUSH
72708: LD_VAR 0 3
72712: PPUSH
72713: CALL 45347 0 1
72717: NOT
72718: AND
72719: OR
72720: IFFALSE 72856
// begin if IsInUnit ( j ) then
72722: LD_VAR 0 3
72726: PPUSH
72727: CALL_OW 310
72731: IFFALSE 72742
// ComExitBuilding ( j ) ;
72733: LD_VAR 0 3
72737: PPUSH
72738: CALL_OW 122
// ct := 0 ;
72742: LD_ADDR_VAR 0 8
72746: PUSH
72747: LD_INT 0
72749: ST_TO_ADDR
// for k in x do
72750: LD_ADDR_VAR 0 4
72754: PUSH
72755: LD_VAR 0 11
72759: PUSH
72760: FOR_IN
72761: IFFALSE 72834
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72763: LD_VAR 0 4
72767: PPUSH
72768: CALL_OW 264
72772: PUSH
72773: LD_INT 31
72775: EQUAL
72776: PUSH
72777: LD_VAR 0 4
72781: PPUSH
72782: CALL_OW 311
72786: NOT
72787: AND
72788: PUSH
72789: LD_VAR 0 4
72793: PPUSH
72794: CALL_OW 266
72798: PUSH
72799: LD_INT 36
72801: EQUAL
72802: PUSH
72803: LD_VAR 0 4
72807: PPUSH
72808: CALL_OW 313
72812: PUSH
72813: LD_INT 3
72815: LESS
72816: AND
72817: OR
72818: IFFALSE 72832
// begin ct := k ;
72820: LD_ADDR_VAR 0 8
72824: PUSH
72825: LD_VAR 0 4
72829: ST_TO_ADDR
// break ;
72830: GO 72834
// end ;
72832: GO 72760
72834: POP
72835: POP
// if ct then
72836: LD_VAR 0 8
72840: IFFALSE 72856
// ComEnterUnit ( j , ct ) ;
72842: LD_VAR 0 3
72846: PPUSH
72847: LD_VAR 0 8
72851: PPUSH
72852: CALL_OW 120
// end ; end ;
72856: GO 72491
72858: POP
72859: POP
// places := 0 ;
72860: LD_ADDR_VAR 0 5
72864: PUSH
72865: LD_INT 0
72867: ST_TO_ADDR
// for j = 1 to x do
72868: LD_ADDR_VAR 0 3
72872: PUSH
72873: DOUBLE
72874: LD_INT 1
72876: DEC
72877: ST_TO_ADDR
72878: LD_VAR 0 11
72882: PUSH
72883: FOR_TO
72884: IFFALSE 72960
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72886: LD_VAR 0 11
72890: PUSH
72891: LD_VAR 0 3
72895: ARRAY
72896: PPUSH
72897: CALL_OW 264
72901: PUSH
72902: LD_INT 31
72904: EQUAL
72905: IFFALSE 72923
// places := places + 1 else
72907: LD_ADDR_VAR 0 5
72911: PUSH
72912: LD_VAR 0 5
72916: PUSH
72917: LD_INT 1
72919: PLUS
72920: ST_TO_ADDR
72921: GO 72958
// if GetBType ( x [ j ] ) = b_control_tower then
72923: LD_VAR 0 11
72927: PUSH
72928: LD_VAR 0 3
72932: ARRAY
72933: PPUSH
72934: CALL_OW 266
72938: PUSH
72939: LD_INT 36
72941: EQUAL
72942: IFFALSE 72958
// places := places + 3 ;
72944: LD_ADDR_VAR 0 5
72948: PUSH
72949: LD_VAR 0 5
72953: PUSH
72954: LD_INT 3
72956: PLUS
72957: ST_TO_ADDR
72958: GO 72883
72960: POP
72961: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72962: LD_VAR 0 5
72966: PUSH
72967: LD_INT 0
72969: EQUAL
72970: PUSH
72971: LD_VAR 0 5
72975: PUSH
72976: LD_EXP 63
72980: PUSH
72981: LD_VAR 0 2
72985: ARRAY
72986: LESSEQUAL
72987: OR
72988: IFFALSE 72992
// continue ;
72990: GO 72242
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72992: LD_ADDR_VAR 0 6
72996: PUSH
72997: LD_EXP 23
73001: PUSH
73002: LD_VAR 0 2
73006: ARRAY
73007: PPUSH
73008: LD_INT 25
73010: PUSH
73011: LD_INT 3
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: PPUSH
73018: CALL_OW 72
73022: PUSH
73023: LD_EXP 63
73027: PUSH
73028: LD_VAR 0 2
73032: ARRAY
73033: DIFF
73034: PPUSH
73035: LD_INT 3
73037: PPUSH
73038: CALL 46247 0 2
73042: ST_TO_ADDR
// for j in tmp do
73043: LD_ADDR_VAR 0 3
73047: PUSH
73048: LD_VAR 0 6
73052: PUSH
73053: FOR_IN
73054: IFFALSE 73089
// if GetTag ( j ) > 0 then
73056: LD_VAR 0 3
73060: PPUSH
73061: CALL_OW 110
73065: PUSH
73066: LD_INT 0
73068: GREATER
73069: IFFALSE 73087
// tmp := tmp diff j ;
73071: LD_ADDR_VAR 0 6
73075: PUSH
73076: LD_VAR 0 6
73080: PUSH
73081: LD_VAR 0 3
73085: DIFF
73086: ST_TO_ADDR
73087: GO 73053
73089: POP
73090: POP
// if not tmp then
73091: LD_VAR 0 6
73095: NOT
73096: IFFALSE 73100
// continue ;
73098: GO 72242
// if places then
73100: LD_VAR 0 5
73104: IFFALSE 73163
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73106: LD_ADDR_EXP 63
73110: PUSH
73111: LD_EXP 63
73115: PPUSH
73116: LD_VAR 0 2
73120: PPUSH
73121: LD_EXP 63
73125: PUSH
73126: LD_VAR 0 2
73130: ARRAY
73131: PUSH
73132: LD_VAR 0 6
73136: PUSH
73137: LD_INT 1
73139: ARRAY
73140: UNION
73141: PPUSH
73142: CALL_OW 1
73146: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73147: LD_VAR 0 6
73151: PUSH
73152: LD_INT 1
73154: ARRAY
73155: PPUSH
73156: LD_INT 126
73158: PPUSH
73159: CALL_OW 109
// end ; end ;
73163: GO 72242
73165: POP
73166: POP
// end ;
73167: LD_VAR 0 1
73171: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73172: LD_INT 0
73174: PPUSH
73175: PPUSH
73176: PPUSH
73177: PPUSH
73178: PPUSH
73179: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73180: LD_VAR 0 1
73184: NOT
73185: PUSH
73186: LD_VAR 0 2
73190: NOT
73191: OR
73192: PUSH
73193: LD_VAR 0 3
73197: NOT
73198: OR
73199: PUSH
73200: LD_VAR 0 4
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 2
73210: PUSH
73211: LD_INT 3
73213: PUSH
73214: LD_INT 4
73216: PUSH
73217: LD_INT 5
73219: PUSH
73220: LD_INT 8
73222: PUSH
73223: LD_INT 9
73225: PUSH
73226: LD_INT 15
73228: PUSH
73229: LD_INT 16
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: LIST
73240: LIST
73241: LIST
73242: IN
73243: NOT
73244: OR
73245: IFFALSE 73249
// exit ;
73247: GO 74149
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73249: LD_ADDR_VAR 0 2
73253: PUSH
73254: LD_VAR 0 2
73258: PPUSH
73259: LD_INT 21
73261: PUSH
73262: LD_INT 3
73264: PUSH
73265: EMPTY
73266: LIST
73267: LIST
73268: PUSH
73269: LD_INT 24
73271: PUSH
73272: LD_INT 250
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PPUSH
73283: CALL_OW 72
73287: ST_TO_ADDR
// case class of 1 , 15 :
73288: LD_VAR 0 4
73292: PUSH
73293: LD_INT 1
73295: DOUBLE
73296: EQUAL
73297: IFTRUE 73307
73299: LD_INT 15
73301: DOUBLE
73302: EQUAL
73303: IFTRUE 73307
73305: GO 73392
73307: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73308: LD_ADDR_VAR 0 8
73312: PUSH
73313: LD_VAR 0 2
73317: PPUSH
73318: LD_INT 2
73320: PUSH
73321: LD_INT 30
73323: PUSH
73324: LD_INT 32
73326: PUSH
73327: EMPTY
73328: LIST
73329: LIST
73330: PUSH
73331: LD_INT 30
73333: PUSH
73334: LD_INT 31
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: LIST
73345: PPUSH
73346: CALL_OW 72
73350: PUSH
73351: LD_VAR 0 2
73355: PPUSH
73356: LD_INT 2
73358: PUSH
73359: LD_INT 30
73361: PUSH
73362: LD_INT 4
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: PUSH
73369: LD_INT 30
73371: PUSH
73372: LD_INT 5
73374: PUSH
73375: EMPTY
73376: LIST
73377: LIST
73378: PUSH
73379: EMPTY
73380: LIST
73381: LIST
73382: LIST
73383: PPUSH
73384: CALL_OW 72
73388: ADD
73389: ST_TO_ADDR
73390: GO 73638
73392: LD_INT 2
73394: DOUBLE
73395: EQUAL
73396: IFTRUE 73406
73398: LD_INT 16
73400: DOUBLE
73401: EQUAL
73402: IFTRUE 73406
73404: GO 73452
73406: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73407: LD_ADDR_VAR 0 8
73411: PUSH
73412: LD_VAR 0 2
73416: PPUSH
73417: LD_INT 2
73419: PUSH
73420: LD_INT 30
73422: PUSH
73423: LD_INT 0
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 30
73432: PUSH
73433: LD_INT 1
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: EMPTY
73441: LIST
73442: LIST
73443: LIST
73444: PPUSH
73445: CALL_OW 72
73449: ST_TO_ADDR
73450: GO 73638
73452: LD_INT 3
73454: DOUBLE
73455: EQUAL
73456: IFTRUE 73460
73458: GO 73506
73460: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73461: LD_ADDR_VAR 0 8
73465: PUSH
73466: LD_VAR 0 2
73470: PPUSH
73471: LD_INT 2
73473: PUSH
73474: LD_INT 30
73476: PUSH
73477: LD_INT 2
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 30
73486: PUSH
73487: LD_INT 3
73489: PUSH
73490: EMPTY
73491: LIST
73492: LIST
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: LIST
73498: PPUSH
73499: CALL_OW 72
73503: ST_TO_ADDR
73504: GO 73638
73506: LD_INT 4
73508: DOUBLE
73509: EQUAL
73510: IFTRUE 73514
73512: GO 73571
73514: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73515: LD_ADDR_VAR 0 8
73519: PUSH
73520: LD_VAR 0 2
73524: PPUSH
73525: LD_INT 2
73527: PUSH
73528: LD_INT 30
73530: PUSH
73531: LD_INT 6
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 30
73540: PUSH
73541: LD_INT 7
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 30
73550: PUSH
73551: LD_INT 8
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: EMPTY
73559: LIST
73560: LIST
73561: LIST
73562: LIST
73563: PPUSH
73564: CALL_OW 72
73568: ST_TO_ADDR
73569: GO 73638
73571: LD_INT 5
73573: DOUBLE
73574: EQUAL
73575: IFTRUE 73591
73577: LD_INT 8
73579: DOUBLE
73580: EQUAL
73581: IFTRUE 73591
73583: LD_INT 9
73585: DOUBLE
73586: EQUAL
73587: IFTRUE 73591
73589: GO 73637
73591: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73592: LD_ADDR_VAR 0 8
73596: PUSH
73597: LD_VAR 0 2
73601: PPUSH
73602: LD_INT 2
73604: PUSH
73605: LD_INT 30
73607: PUSH
73608: LD_INT 4
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: PUSH
73615: LD_INT 30
73617: PUSH
73618: LD_INT 5
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: LIST
73629: PPUSH
73630: CALL_OW 72
73634: ST_TO_ADDR
73635: GO 73638
73637: POP
// if not tmp then
73638: LD_VAR 0 8
73642: NOT
73643: IFFALSE 73647
// exit ;
73645: GO 74149
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73647: LD_VAR 0 4
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: LD_INT 15
73657: PUSH
73658: EMPTY
73659: LIST
73660: LIST
73661: IN
73662: PUSH
73663: LD_EXP 32
73667: PUSH
73668: LD_VAR 0 1
73672: ARRAY
73673: AND
73674: IFFALSE 73830
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73676: LD_ADDR_VAR 0 9
73680: PUSH
73681: LD_EXP 32
73685: PUSH
73686: LD_VAR 0 1
73690: ARRAY
73691: PUSH
73692: LD_INT 1
73694: ARRAY
73695: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73696: LD_VAR 0 9
73700: PUSH
73701: LD_EXP 33
73705: PUSH
73706: LD_VAR 0 1
73710: ARRAY
73711: IN
73712: NOT
73713: IFFALSE 73828
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73715: LD_ADDR_EXP 33
73719: PUSH
73720: LD_EXP 33
73724: PPUSH
73725: LD_VAR 0 1
73729: PUSH
73730: LD_EXP 33
73734: PUSH
73735: LD_VAR 0 1
73739: ARRAY
73740: PUSH
73741: LD_INT 1
73743: PLUS
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PPUSH
73749: LD_VAR 0 9
73753: PPUSH
73754: CALL 15990 0 3
73758: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73759: LD_ADDR_EXP 32
73763: PUSH
73764: LD_EXP 32
73768: PPUSH
73769: LD_VAR 0 1
73773: PPUSH
73774: LD_EXP 32
73778: PUSH
73779: LD_VAR 0 1
73783: ARRAY
73784: PUSH
73785: LD_VAR 0 9
73789: DIFF
73790: PPUSH
73791: CALL_OW 1
73795: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73796: LD_VAR 0 3
73800: PPUSH
73801: LD_EXP 33
73805: PUSH
73806: LD_VAR 0 1
73810: ARRAY
73811: PUSH
73812: LD_EXP 33
73816: PUSH
73817: LD_VAR 0 1
73821: ARRAY
73822: ARRAY
73823: PPUSH
73824: CALL_OW 120
// end ; exit ;
73828: GO 74149
// end ; if tmp > 1 then
73830: LD_VAR 0 8
73834: PUSH
73835: LD_INT 1
73837: GREATER
73838: IFFALSE 73942
// for i = 2 to tmp do
73840: LD_ADDR_VAR 0 6
73844: PUSH
73845: DOUBLE
73846: LD_INT 2
73848: DEC
73849: ST_TO_ADDR
73850: LD_VAR 0 8
73854: PUSH
73855: FOR_TO
73856: IFFALSE 73940
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73858: LD_VAR 0 8
73862: PUSH
73863: LD_VAR 0 6
73867: ARRAY
73868: PPUSH
73869: CALL_OW 461
73873: PUSH
73874: LD_INT 6
73876: EQUAL
73877: IFFALSE 73938
// begin x := tmp [ i ] ;
73879: LD_ADDR_VAR 0 9
73883: PUSH
73884: LD_VAR 0 8
73888: PUSH
73889: LD_VAR 0 6
73893: ARRAY
73894: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73895: LD_ADDR_VAR 0 8
73899: PUSH
73900: LD_VAR 0 8
73904: PPUSH
73905: LD_VAR 0 6
73909: PPUSH
73910: CALL_OW 3
73914: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73915: LD_ADDR_VAR 0 8
73919: PUSH
73920: LD_VAR 0 8
73924: PPUSH
73925: LD_INT 1
73927: PPUSH
73928: LD_VAR 0 9
73932: PPUSH
73933: CALL_OW 2
73937: ST_TO_ADDR
// end ;
73938: GO 73855
73940: POP
73941: POP
// for i in tmp do
73942: LD_ADDR_VAR 0 6
73946: PUSH
73947: LD_VAR 0 8
73951: PUSH
73952: FOR_IN
73953: IFFALSE 74022
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73955: LD_VAR 0 6
73959: PPUSH
73960: CALL_OW 313
73964: PUSH
73965: LD_INT 6
73967: LESS
73968: PUSH
73969: LD_VAR 0 6
73973: PPUSH
73974: CALL_OW 266
73978: PUSH
73979: LD_INT 31
73981: PUSH
73982: LD_INT 32
73984: PUSH
73985: EMPTY
73986: LIST
73987: LIST
73988: IN
73989: NOT
73990: AND
73991: PUSH
73992: LD_VAR 0 6
73996: PPUSH
73997: CALL_OW 313
74001: PUSH
74002: LD_INT 0
74004: EQUAL
74005: OR
74006: IFFALSE 74020
// begin j := i ;
74008: LD_ADDR_VAR 0 7
74012: PUSH
74013: LD_VAR 0 6
74017: ST_TO_ADDR
// break ;
74018: GO 74022
// end ; end ;
74020: GO 73952
74022: POP
74023: POP
// if j then
74024: LD_VAR 0 7
74028: IFFALSE 74046
// ComEnterUnit ( unit , j ) else
74030: LD_VAR 0 3
74034: PPUSH
74035: LD_VAR 0 7
74039: PPUSH
74040: CALL_OW 120
74044: GO 74149
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74046: LD_ADDR_VAR 0 10
74050: PUSH
74051: LD_VAR 0 2
74055: PPUSH
74056: LD_INT 2
74058: PUSH
74059: LD_INT 30
74061: PUSH
74062: LD_INT 0
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 30
74071: PUSH
74072: LD_INT 1
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: EMPTY
74080: LIST
74081: LIST
74082: LIST
74083: PPUSH
74084: CALL_OW 72
74088: ST_TO_ADDR
// if depot then
74089: LD_VAR 0 10
74093: IFFALSE 74149
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74095: LD_ADDR_VAR 0 10
74099: PUSH
74100: LD_VAR 0 10
74104: PPUSH
74105: LD_VAR 0 3
74109: PPUSH
74110: CALL_OW 74
74114: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74115: LD_VAR 0 3
74119: PPUSH
74120: LD_VAR 0 10
74124: PPUSH
74125: CALL_OW 296
74129: PUSH
74130: LD_INT 10
74132: GREATER
74133: IFFALSE 74149
// ComStandNearbyBuilding ( unit , depot ) ;
74135: LD_VAR 0 3
74139: PPUSH
74140: LD_VAR 0 10
74144: PPUSH
74145: CALL 12568 0 2
// end ; end ; end ;
74149: LD_VAR 0 5
74153: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74154: LD_INT 0
74156: PPUSH
74157: PPUSH
74158: PPUSH
74159: PPUSH
// if not mc_bases then
74160: LD_EXP 23
74164: NOT
74165: IFFALSE 74169
// exit ;
74167: GO 74408
// for i = 1 to mc_bases do
74169: LD_ADDR_VAR 0 2
74173: PUSH
74174: DOUBLE
74175: LD_INT 1
74177: DEC
74178: ST_TO_ADDR
74179: LD_EXP 23
74183: PUSH
74184: FOR_TO
74185: IFFALSE 74406
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74187: LD_ADDR_VAR 0 4
74191: PUSH
74192: LD_EXP 23
74196: PUSH
74197: LD_VAR 0 2
74201: ARRAY
74202: PPUSH
74203: LD_INT 21
74205: PUSH
74206: LD_INT 1
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PPUSH
74213: CALL_OW 72
74217: PUSH
74218: LD_EXP 52
74222: PUSH
74223: LD_VAR 0 2
74227: ARRAY
74228: UNION
74229: ST_TO_ADDR
// if not tmp then
74230: LD_VAR 0 4
74234: NOT
74235: IFFALSE 74239
// continue ;
74237: GO 74184
// for j in tmp do
74239: LD_ADDR_VAR 0 3
74243: PUSH
74244: LD_VAR 0 4
74248: PUSH
74249: FOR_IN
74250: IFFALSE 74402
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74252: LD_VAR 0 3
74256: PPUSH
74257: CALL_OW 110
74261: NOT
74262: PUSH
74263: LD_VAR 0 3
74267: PPUSH
74268: CALL_OW 314
74272: NOT
74273: AND
74274: PUSH
74275: LD_VAR 0 3
74279: PPUSH
74280: CALL_OW 311
74284: NOT
74285: AND
74286: PUSH
74287: LD_VAR 0 3
74291: PPUSH
74292: CALL_OW 310
74296: NOT
74297: AND
74298: PUSH
74299: LD_VAR 0 3
74303: PUSH
74304: LD_EXP 26
74308: PUSH
74309: LD_VAR 0 2
74313: ARRAY
74314: PUSH
74315: LD_INT 1
74317: ARRAY
74318: IN
74319: NOT
74320: AND
74321: PUSH
74322: LD_VAR 0 3
74326: PUSH
74327: LD_EXP 26
74331: PUSH
74332: LD_VAR 0 2
74336: ARRAY
74337: PUSH
74338: LD_INT 2
74340: ARRAY
74341: IN
74342: NOT
74343: AND
74344: PUSH
74345: LD_VAR 0 3
74349: PUSH
74350: LD_EXP 35
74354: PUSH
74355: LD_VAR 0 2
74359: ARRAY
74360: IN
74361: NOT
74362: AND
74363: IFFALSE 74400
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74365: LD_VAR 0 2
74369: PPUSH
74370: LD_EXP 23
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: PPUSH
74381: LD_VAR 0 3
74385: PPUSH
74386: LD_VAR 0 3
74390: PPUSH
74391: CALL_OW 257
74395: PPUSH
74396: CALL 73172 0 4
// end ;
74400: GO 74249
74402: POP
74403: POP
// end ;
74404: GO 74184
74406: POP
74407: POP
// end ;
74408: LD_VAR 0 1
74412: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74413: LD_INT 0
74415: PPUSH
74416: PPUSH
74417: PPUSH
74418: PPUSH
74419: PPUSH
74420: PPUSH
// if not mc_bases [ base ] then
74421: LD_EXP 23
74425: PUSH
74426: LD_VAR 0 1
74430: ARRAY
74431: NOT
74432: IFFALSE 74436
// exit ;
74434: GO 74618
// tmp := [ ] ;
74436: LD_ADDR_VAR 0 6
74440: PUSH
74441: EMPTY
74442: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74443: LD_ADDR_VAR 0 7
74447: PUSH
74448: LD_VAR 0 3
74452: PPUSH
74453: LD_INT 0
74455: PPUSH
74456: CALL_OW 517
74460: ST_TO_ADDR
// if not list then
74461: LD_VAR 0 7
74465: NOT
74466: IFFALSE 74470
// exit ;
74468: GO 74618
// for i = 1 to amount do
74470: LD_ADDR_VAR 0 5
74474: PUSH
74475: DOUBLE
74476: LD_INT 1
74478: DEC
74479: ST_TO_ADDR
74480: LD_VAR 0 2
74484: PUSH
74485: FOR_TO
74486: IFFALSE 74566
// begin x := rand ( 1 , list [ 1 ] ) ;
74488: LD_ADDR_VAR 0 8
74492: PUSH
74493: LD_INT 1
74495: PPUSH
74496: LD_VAR 0 7
74500: PUSH
74501: LD_INT 1
74503: ARRAY
74504: PPUSH
74505: CALL_OW 12
74509: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74510: LD_ADDR_VAR 0 6
74514: PUSH
74515: LD_VAR 0 6
74519: PPUSH
74520: LD_VAR 0 5
74524: PPUSH
74525: LD_VAR 0 7
74529: PUSH
74530: LD_INT 1
74532: ARRAY
74533: PUSH
74534: LD_VAR 0 8
74538: ARRAY
74539: PUSH
74540: LD_VAR 0 7
74544: PUSH
74545: LD_INT 2
74547: ARRAY
74548: PUSH
74549: LD_VAR 0 8
74553: ARRAY
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PPUSH
74559: CALL_OW 1
74563: ST_TO_ADDR
// end ;
74564: GO 74485
74566: POP
74567: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74568: LD_ADDR_EXP 36
74572: PUSH
74573: LD_EXP 36
74577: PPUSH
74578: LD_VAR 0 1
74582: PPUSH
74583: LD_VAR 0 6
74587: PPUSH
74588: CALL_OW 1
74592: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74593: LD_ADDR_EXP 38
74597: PUSH
74598: LD_EXP 38
74602: PPUSH
74603: LD_VAR 0 1
74607: PPUSH
74608: LD_VAR 0 3
74612: PPUSH
74613: CALL_OW 1
74617: ST_TO_ADDR
// end ;
74618: LD_VAR 0 4
74622: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74623: LD_INT 0
74625: PPUSH
// if not mc_bases [ base ] then
74626: LD_EXP 23
74630: PUSH
74631: LD_VAR 0 1
74635: ARRAY
74636: NOT
74637: IFFALSE 74641
// exit ;
74639: GO 74666
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74641: LD_ADDR_EXP 28
74645: PUSH
74646: LD_EXP 28
74650: PPUSH
74651: LD_VAR 0 1
74655: PPUSH
74656: LD_VAR 0 2
74660: PPUSH
74661: CALL_OW 1
74665: ST_TO_ADDR
// end ;
74666: LD_VAR 0 3
74670: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74671: LD_INT 0
74673: PPUSH
// if not mc_bases [ base ] then
74674: LD_EXP 23
74678: PUSH
74679: LD_VAR 0 1
74683: ARRAY
74684: NOT
74685: IFFALSE 74689
// exit ;
74687: GO 74726
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74689: LD_ADDR_EXP 28
74693: PUSH
74694: LD_EXP 28
74698: PPUSH
74699: LD_VAR 0 1
74703: PPUSH
74704: LD_EXP 28
74708: PUSH
74709: LD_VAR 0 1
74713: ARRAY
74714: PUSH
74715: LD_VAR 0 2
74719: UNION
74720: PPUSH
74721: CALL_OW 1
74725: ST_TO_ADDR
// end ;
74726: LD_VAR 0 3
74730: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74731: LD_INT 0
74733: PPUSH
// if not mc_bases [ base ] then
74734: LD_EXP 23
74738: PUSH
74739: LD_VAR 0 1
74743: ARRAY
74744: NOT
74745: IFFALSE 74749
// exit ;
74747: GO 74774
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74749: LD_ADDR_EXP 44
74753: PUSH
74754: LD_EXP 44
74758: PPUSH
74759: LD_VAR 0 1
74763: PPUSH
74764: LD_VAR 0 2
74768: PPUSH
74769: CALL_OW 1
74773: ST_TO_ADDR
// end ;
74774: LD_VAR 0 3
74778: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74779: LD_INT 0
74781: PPUSH
// if not mc_bases [ base ] then
74782: LD_EXP 23
74786: PUSH
74787: LD_VAR 0 1
74791: ARRAY
74792: NOT
74793: IFFALSE 74797
// exit ;
74795: GO 74834
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74797: LD_ADDR_EXP 44
74801: PUSH
74802: LD_EXP 44
74806: PPUSH
74807: LD_VAR 0 1
74811: PPUSH
74812: LD_EXP 44
74816: PUSH
74817: LD_VAR 0 1
74821: ARRAY
74822: PUSH
74823: LD_VAR 0 2
74827: ADD
74828: PPUSH
74829: CALL_OW 1
74833: ST_TO_ADDR
// end ;
74834: LD_VAR 0 3
74838: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74839: LD_INT 0
74841: PPUSH
// if not mc_bases [ base ] then
74842: LD_EXP 23
74846: PUSH
74847: LD_VAR 0 1
74851: ARRAY
74852: NOT
74853: IFFALSE 74857
// exit ;
74855: GO 74911
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74857: LD_ADDR_EXP 45
74861: PUSH
74862: LD_EXP 45
74866: PPUSH
74867: LD_VAR 0 1
74871: PPUSH
74872: LD_VAR 0 2
74876: PPUSH
74877: CALL_OW 1
74881: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74882: LD_ADDR_EXP 34
74886: PUSH
74887: LD_EXP 34
74891: PPUSH
74892: LD_VAR 0 1
74896: PPUSH
74897: LD_VAR 0 2
74901: PUSH
74902: LD_INT 0
74904: PLUS
74905: PPUSH
74906: CALL_OW 1
74910: ST_TO_ADDR
// end ;
74911: LD_VAR 0 3
74915: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74916: LD_INT 0
74918: PPUSH
// if not mc_bases [ base ] then
74919: LD_EXP 23
74923: PUSH
74924: LD_VAR 0 1
74928: ARRAY
74929: NOT
74930: IFFALSE 74934
// exit ;
74932: GO 74959
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74934: LD_ADDR_EXP 34
74938: PUSH
74939: LD_EXP 34
74943: PPUSH
74944: LD_VAR 0 1
74948: PPUSH
74949: LD_VAR 0 2
74953: PPUSH
74954: CALL_OW 1
74958: ST_TO_ADDR
// end ;
74959: LD_VAR 0 3
74963: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74964: LD_INT 0
74966: PPUSH
74967: PPUSH
74968: PPUSH
74969: PPUSH
// if not mc_bases [ base ] then
74970: LD_EXP 23
74974: PUSH
74975: LD_VAR 0 1
74979: ARRAY
74980: NOT
74981: IFFALSE 74985
// exit ;
74983: GO 75050
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74985: LD_ADDR_EXP 43
74989: PUSH
74990: LD_EXP 43
74994: PPUSH
74995: LD_VAR 0 1
74999: PUSH
75000: LD_EXP 43
75004: PUSH
75005: LD_VAR 0 1
75009: ARRAY
75010: PUSH
75011: LD_INT 1
75013: PLUS
75014: PUSH
75015: EMPTY
75016: LIST
75017: LIST
75018: PPUSH
75019: LD_VAR 0 1
75023: PUSH
75024: LD_VAR 0 2
75028: PUSH
75029: LD_VAR 0 3
75033: PUSH
75034: LD_VAR 0 4
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: LIST
75043: LIST
75044: PPUSH
75045: CALL 15990 0 3
75049: ST_TO_ADDR
// end ;
75050: LD_VAR 0 5
75054: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75055: LD_INT 0
75057: PPUSH
// if not mc_bases [ base ] then
75058: LD_EXP 23
75062: PUSH
75063: LD_VAR 0 1
75067: ARRAY
75068: NOT
75069: IFFALSE 75073
// exit ;
75071: GO 75098
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75073: LD_ADDR_EXP 60
75077: PUSH
75078: LD_EXP 60
75082: PPUSH
75083: LD_VAR 0 1
75087: PPUSH
75088: LD_VAR 0 2
75092: PPUSH
75093: CALL_OW 1
75097: ST_TO_ADDR
// end ;
75098: LD_VAR 0 3
75102: RET
// export function MC_GetMinesField ( base ) ; begin
75103: LD_INT 0
75105: PPUSH
// result := mc_mines [ base ] ;
75106: LD_ADDR_VAR 0 2
75110: PUSH
75111: LD_EXP 36
75115: PUSH
75116: LD_VAR 0 1
75120: ARRAY
75121: ST_TO_ADDR
// end ;
75122: LD_VAR 0 2
75126: RET
// export function MC_GetProduceList ( base ) ; begin
75127: LD_INT 0
75129: PPUSH
// result := mc_produce [ base ] ;
75130: LD_ADDR_VAR 0 2
75134: PUSH
75135: LD_EXP 44
75139: PUSH
75140: LD_VAR 0 1
75144: ARRAY
75145: ST_TO_ADDR
// end ;
75146: LD_VAR 0 2
75150: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75151: LD_INT 0
75153: PPUSH
75154: PPUSH
// if not mc_bases then
75155: LD_EXP 23
75159: NOT
75160: IFFALSE 75164
// exit ;
75162: GO 75229
// if mc_bases [ base ] then
75164: LD_EXP 23
75168: PUSH
75169: LD_VAR 0 1
75173: ARRAY
75174: IFFALSE 75229
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75176: LD_ADDR_VAR 0 3
75180: PUSH
75181: LD_EXP 23
75185: PUSH
75186: LD_VAR 0 1
75190: ARRAY
75191: PPUSH
75192: LD_INT 30
75194: PUSH
75195: LD_VAR 0 2
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PPUSH
75204: CALL_OW 72
75208: ST_TO_ADDR
// if result then
75209: LD_VAR 0 3
75213: IFFALSE 75229
// result := result [ 1 ] ;
75215: LD_ADDR_VAR 0 3
75219: PUSH
75220: LD_VAR 0 3
75224: PUSH
75225: LD_INT 1
75227: ARRAY
75228: ST_TO_ADDR
// end ; end ;
75229: LD_VAR 0 3
75233: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75234: LD_INT 0
75236: PPUSH
75237: PPUSH
// if not mc_bases then
75238: LD_EXP 23
75242: NOT
75243: IFFALSE 75247
// exit ;
75245: GO 75292
// if mc_bases [ base ] then
75247: LD_EXP 23
75251: PUSH
75252: LD_VAR 0 1
75256: ARRAY
75257: IFFALSE 75292
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75259: LD_ADDR_VAR 0 3
75263: PUSH
75264: LD_EXP 23
75268: PUSH
75269: LD_VAR 0 1
75273: ARRAY
75274: PPUSH
75275: LD_INT 30
75277: PUSH
75278: LD_VAR 0 2
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PPUSH
75287: CALL_OW 72
75291: ST_TO_ADDR
// end ;
75292: LD_VAR 0 3
75296: RET
// export function MC_SetTame ( base , area ) ; begin
75297: LD_INT 0
75299: PPUSH
// if not mc_bases or not base then
75300: LD_EXP 23
75304: NOT
75305: PUSH
75306: LD_VAR 0 1
75310: NOT
75311: OR
75312: IFFALSE 75316
// exit ;
75314: GO 75341
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75316: LD_ADDR_EXP 51
75320: PUSH
75321: LD_EXP 51
75325: PPUSH
75326: LD_VAR 0 1
75330: PPUSH
75331: LD_VAR 0 2
75335: PPUSH
75336: CALL_OW 1
75340: ST_TO_ADDR
// end ;
75341: LD_VAR 0 3
75345: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75346: LD_INT 0
75348: PPUSH
75349: PPUSH
// if not mc_bases or not base then
75350: LD_EXP 23
75354: NOT
75355: PUSH
75356: LD_VAR 0 1
75360: NOT
75361: OR
75362: IFFALSE 75366
// exit ;
75364: GO 75468
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75366: LD_ADDR_VAR 0 4
75370: PUSH
75371: LD_EXP 23
75375: PUSH
75376: LD_VAR 0 1
75380: ARRAY
75381: PPUSH
75382: LD_INT 30
75384: PUSH
75385: LD_VAR 0 2
75389: PUSH
75390: EMPTY
75391: LIST
75392: LIST
75393: PPUSH
75394: CALL_OW 72
75398: ST_TO_ADDR
// if not tmp then
75399: LD_VAR 0 4
75403: NOT
75404: IFFALSE 75408
// exit ;
75406: GO 75468
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75408: LD_ADDR_EXP 55
75412: PUSH
75413: LD_EXP 55
75417: PPUSH
75418: LD_VAR 0 1
75422: PPUSH
75423: LD_EXP 55
75427: PUSH
75428: LD_VAR 0 1
75432: ARRAY
75433: PPUSH
75434: LD_EXP 55
75438: PUSH
75439: LD_VAR 0 1
75443: ARRAY
75444: PUSH
75445: LD_INT 1
75447: PLUS
75448: PPUSH
75449: LD_VAR 0 4
75453: PUSH
75454: LD_INT 1
75456: ARRAY
75457: PPUSH
75458: CALL_OW 2
75462: PPUSH
75463: CALL_OW 1
75467: ST_TO_ADDR
// end ;
75468: LD_VAR 0 3
75472: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75473: LD_INT 0
75475: PPUSH
75476: PPUSH
// if not mc_bases or not base or not kinds then
75477: LD_EXP 23
75481: NOT
75482: PUSH
75483: LD_VAR 0 1
75487: NOT
75488: OR
75489: PUSH
75490: LD_VAR 0 2
75494: NOT
75495: OR
75496: IFFALSE 75500
// exit ;
75498: GO 75561
// for i in kinds do
75500: LD_ADDR_VAR 0 4
75504: PUSH
75505: LD_VAR 0 2
75509: PUSH
75510: FOR_IN
75511: IFFALSE 75559
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75513: LD_ADDR_EXP 57
75517: PUSH
75518: LD_EXP 57
75522: PPUSH
75523: LD_VAR 0 1
75527: PUSH
75528: LD_EXP 57
75532: PUSH
75533: LD_VAR 0 1
75537: ARRAY
75538: PUSH
75539: LD_INT 1
75541: PLUS
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: PPUSH
75547: LD_VAR 0 4
75551: PPUSH
75552: CALL 15990 0 3
75556: ST_TO_ADDR
75557: GO 75510
75559: POP
75560: POP
// end ;
75561: LD_VAR 0 3
75565: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75566: LD_INT 0
75568: PPUSH
// if not mc_bases or not base or not areas then
75569: LD_EXP 23
75573: NOT
75574: PUSH
75575: LD_VAR 0 1
75579: NOT
75580: OR
75581: PUSH
75582: LD_VAR 0 2
75586: NOT
75587: OR
75588: IFFALSE 75592
// exit ;
75590: GO 75617
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75592: LD_ADDR_EXP 41
75596: PUSH
75597: LD_EXP 41
75601: PPUSH
75602: LD_VAR 0 1
75606: PPUSH
75607: LD_VAR 0 2
75611: PPUSH
75612: CALL_OW 1
75616: ST_TO_ADDR
// end ;
75617: LD_VAR 0 3
75621: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75622: LD_INT 0
75624: PPUSH
// if not mc_bases or not base or not teleports_exit then
75625: LD_EXP 23
75629: NOT
75630: PUSH
75631: LD_VAR 0 1
75635: NOT
75636: OR
75637: PUSH
75638: LD_VAR 0 2
75642: NOT
75643: OR
75644: IFFALSE 75648
// exit ;
75646: GO 75673
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75648: LD_ADDR_EXP 58
75652: PUSH
75653: LD_EXP 58
75657: PPUSH
75658: LD_VAR 0 1
75662: PPUSH
75663: LD_VAR 0 2
75667: PPUSH
75668: CALL_OW 1
75672: ST_TO_ADDR
// end ;
75673: LD_VAR 0 3
75677: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75678: LD_INT 0
75680: PPUSH
75681: PPUSH
75682: PPUSH
// if not mc_bases or not base or not ext_list then
75683: LD_EXP 23
75687: NOT
75688: PUSH
75689: LD_VAR 0 1
75693: NOT
75694: OR
75695: PUSH
75696: LD_VAR 0 5
75700: NOT
75701: OR
75702: IFFALSE 75706
// exit ;
75704: GO 75879
// tmp := GetFacExtXYD ( x , y , d ) ;
75706: LD_ADDR_VAR 0 8
75710: PUSH
75711: LD_VAR 0 2
75715: PPUSH
75716: LD_VAR 0 3
75720: PPUSH
75721: LD_VAR 0 4
75725: PPUSH
75726: CALL 45377 0 3
75730: ST_TO_ADDR
// if not tmp then
75731: LD_VAR 0 8
75735: NOT
75736: IFFALSE 75740
// exit ;
75738: GO 75879
// for i in tmp do
75740: LD_ADDR_VAR 0 7
75744: PUSH
75745: LD_VAR 0 8
75749: PUSH
75750: FOR_IN
75751: IFFALSE 75877
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75753: LD_ADDR_EXP 28
75757: PUSH
75758: LD_EXP 28
75762: PPUSH
75763: LD_VAR 0 1
75767: PPUSH
75768: LD_EXP 28
75772: PUSH
75773: LD_VAR 0 1
75777: ARRAY
75778: PPUSH
75779: LD_EXP 28
75783: PUSH
75784: LD_VAR 0 1
75788: ARRAY
75789: PUSH
75790: LD_INT 1
75792: PLUS
75793: PPUSH
75794: LD_VAR 0 5
75798: PUSH
75799: LD_INT 1
75801: ARRAY
75802: PUSH
75803: LD_VAR 0 7
75807: PUSH
75808: LD_INT 1
75810: ARRAY
75811: PUSH
75812: LD_VAR 0 7
75816: PUSH
75817: LD_INT 2
75819: ARRAY
75820: PUSH
75821: LD_VAR 0 7
75825: PUSH
75826: LD_INT 3
75828: ARRAY
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: LIST
75834: LIST
75835: PPUSH
75836: CALL_OW 2
75840: PPUSH
75841: CALL_OW 1
75845: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75846: LD_ADDR_VAR 0 5
75850: PUSH
75851: LD_VAR 0 5
75855: PPUSH
75856: LD_INT 1
75858: PPUSH
75859: CALL_OW 3
75863: ST_TO_ADDR
// if not ext_list then
75864: LD_VAR 0 5
75868: NOT
75869: IFFALSE 75875
// exit ;
75871: POP
75872: POP
75873: GO 75879
// end ;
75875: GO 75750
75877: POP
75878: POP
// end ;
75879: LD_VAR 0 6
75883: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75884: LD_INT 0
75886: PPUSH
// if not mc_bases or not base or not weapon_list then
75887: LD_EXP 23
75891: NOT
75892: PUSH
75893: LD_VAR 0 1
75897: NOT
75898: OR
75899: PUSH
75900: LD_VAR 0 2
75904: NOT
75905: OR
75906: IFFALSE 75910
// exit ;
75908: GO 75935
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75910: LD_ADDR_EXP 62
75914: PUSH
75915: LD_EXP 62
75919: PPUSH
75920: LD_VAR 0 1
75924: PPUSH
75925: LD_VAR 0 2
75929: PPUSH
75930: CALL_OW 1
75934: ST_TO_ADDR
// end ;
75935: LD_VAR 0 3
75939: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75940: LD_INT 0
75942: PPUSH
// if not mc_bases or not base or not tech_list then
75943: LD_EXP 23
75947: NOT
75948: PUSH
75949: LD_VAR 0 1
75953: NOT
75954: OR
75955: PUSH
75956: LD_VAR 0 2
75960: NOT
75961: OR
75962: IFFALSE 75966
// exit ;
75964: GO 75991
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75966: LD_ADDR_EXP 50
75970: PUSH
75971: LD_EXP 50
75975: PPUSH
75976: LD_VAR 0 1
75980: PPUSH
75981: LD_VAR 0 2
75985: PPUSH
75986: CALL_OW 1
75990: ST_TO_ADDR
// end ;
75991: LD_VAR 0 3
75995: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75996: LD_INT 0
75998: PPUSH
// if not mc_bases or not parking_area or not base then
75999: LD_EXP 23
76003: NOT
76004: PUSH
76005: LD_VAR 0 2
76009: NOT
76010: OR
76011: PUSH
76012: LD_VAR 0 1
76016: NOT
76017: OR
76018: IFFALSE 76022
// exit ;
76020: GO 76047
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76022: LD_ADDR_EXP 47
76026: PUSH
76027: LD_EXP 47
76031: PPUSH
76032: LD_VAR 0 1
76036: PPUSH
76037: LD_VAR 0 2
76041: PPUSH
76042: CALL_OW 1
76046: ST_TO_ADDR
// end ;
76047: LD_VAR 0 3
76051: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76052: LD_INT 0
76054: PPUSH
// if not mc_bases or not base or not scan_area then
76055: LD_EXP 23
76059: NOT
76060: PUSH
76061: LD_VAR 0 1
76065: NOT
76066: OR
76067: PUSH
76068: LD_VAR 0 2
76072: NOT
76073: OR
76074: IFFALSE 76078
// exit ;
76076: GO 76103
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76078: LD_ADDR_EXP 48
76082: PUSH
76083: LD_EXP 48
76087: PPUSH
76088: LD_VAR 0 1
76092: PPUSH
76093: LD_VAR 0 2
76097: PPUSH
76098: CALL_OW 1
76102: ST_TO_ADDR
// end ;
76103: LD_VAR 0 3
76107: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76108: LD_INT 0
76110: PPUSH
76111: PPUSH
// if not mc_bases or not base then
76112: LD_EXP 23
76116: NOT
76117: PUSH
76118: LD_VAR 0 1
76122: NOT
76123: OR
76124: IFFALSE 76128
// exit ;
76126: GO 76192
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76128: LD_ADDR_VAR 0 3
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 2
76138: PUSH
76139: LD_INT 3
76141: PUSH
76142: LD_INT 4
76144: PUSH
76145: LD_INT 11
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: LIST
76154: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76155: LD_ADDR_EXP 50
76159: PUSH
76160: LD_EXP 50
76164: PPUSH
76165: LD_VAR 0 1
76169: PPUSH
76170: LD_EXP 50
76174: PUSH
76175: LD_VAR 0 1
76179: ARRAY
76180: PUSH
76181: LD_VAR 0 3
76185: DIFF
76186: PPUSH
76187: CALL_OW 1
76191: ST_TO_ADDR
// end ;
76192: LD_VAR 0 2
76196: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76197: LD_INT 0
76199: PPUSH
// result := mc_vehicles [ base ] ;
76200: LD_ADDR_VAR 0 3
76204: PUSH
76205: LD_EXP 42
76209: PUSH
76210: LD_VAR 0 1
76214: ARRAY
76215: ST_TO_ADDR
// if onlyCombat then
76216: LD_VAR 0 2
76220: IFFALSE 76398
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76222: LD_ADDR_VAR 0 3
76226: PUSH
76227: LD_VAR 0 3
76231: PUSH
76232: LD_VAR 0 3
76236: PPUSH
76237: LD_INT 2
76239: PUSH
76240: LD_INT 34
76242: PUSH
76243: LD_INT 12
76245: PUSH
76246: EMPTY
76247: LIST
76248: LIST
76249: PUSH
76250: LD_INT 34
76252: PUSH
76253: LD_INT 51
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: PUSH
76260: LD_INT 34
76262: PUSH
76263: LD_EXP 68
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 34
76274: PUSH
76275: LD_INT 32
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 34
76284: PUSH
76285: LD_INT 13
76287: PUSH
76288: EMPTY
76289: LIST
76290: LIST
76291: PUSH
76292: LD_INT 34
76294: PUSH
76295: LD_INT 52
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: PUSH
76302: LD_INT 34
76304: PUSH
76305: LD_EXP 73
76309: PUSH
76310: EMPTY
76311: LIST
76312: LIST
76313: PUSH
76314: LD_INT 34
76316: PUSH
76317: LD_INT 14
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 34
76326: PUSH
76327: LD_INT 53
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 34
76336: PUSH
76337: LD_EXP 67
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 34
76348: PUSH
76349: LD_INT 31
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 34
76358: PUSH
76359: LD_INT 48
76361: PUSH
76362: EMPTY
76363: LIST
76364: LIST
76365: PUSH
76366: LD_INT 34
76368: PUSH
76369: LD_INT 8
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: LIST
76380: LIST
76381: LIST
76382: LIST
76383: LIST
76384: LIST
76385: LIST
76386: LIST
76387: LIST
76388: LIST
76389: LIST
76390: LIST
76391: PPUSH
76392: CALL_OW 72
76396: DIFF
76397: ST_TO_ADDR
// end ; end_of_file
76398: LD_VAR 0 3
76402: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76403: LD_INT 0
76405: PPUSH
76406: PPUSH
76407: PPUSH
// if not mc_bases or not skirmish then
76408: LD_EXP 23
76412: NOT
76413: PUSH
76414: LD_EXP 21
76418: NOT
76419: OR
76420: IFFALSE 76424
// exit ;
76422: GO 76589
// for i = 1 to mc_bases do
76424: LD_ADDR_VAR 0 4
76428: PUSH
76429: DOUBLE
76430: LD_INT 1
76432: DEC
76433: ST_TO_ADDR
76434: LD_EXP 23
76438: PUSH
76439: FOR_TO
76440: IFFALSE 76587
// begin if sci in mc_bases [ i ] then
76442: LD_VAR 0 2
76446: PUSH
76447: LD_EXP 23
76451: PUSH
76452: LD_VAR 0 4
76456: ARRAY
76457: IN
76458: IFFALSE 76585
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76460: LD_ADDR_EXP 52
76464: PUSH
76465: LD_EXP 52
76469: PPUSH
76470: LD_VAR 0 4
76474: PUSH
76475: LD_EXP 52
76479: PUSH
76480: LD_VAR 0 4
76484: ARRAY
76485: PUSH
76486: LD_INT 1
76488: PLUS
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PPUSH
76494: LD_VAR 0 1
76498: PPUSH
76499: CALL 15990 0 3
76503: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76504: LD_ADDR_VAR 0 5
76508: PUSH
76509: LD_EXP 23
76513: PUSH
76514: LD_VAR 0 4
76518: ARRAY
76519: PPUSH
76520: LD_INT 2
76522: PUSH
76523: LD_INT 30
76525: PUSH
76526: LD_INT 0
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 30
76535: PUSH
76536: LD_INT 1
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: LIST
76547: PPUSH
76548: CALL_OW 72
76552: PPUSH
76553: LD_VAR 0 1
76557: PPUSH
76558: CALL_OW 74
76562: ST_TO_ADDR
// if tmp then
76563: LD_VAR 0 5
76567: IFFALSE 76583
// ComStandNearbyBuilding ( ape , tmp ) ;
76569: LD_VAR 0 1
76573: PPUSH
76574: LD_VAR 0 5
76578: PPUSH
76579: CALL 12568 0 2
// break ;
76583: GO 76587
// end ; end ;
76585: GO 76439
76587: POP
76588: POP
// end ;
76589: LD_VAR 0 3
76593: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76594: LD_INT 0
76596: PPUSH
76597: PPUSH
76598: PPUSH
// if not mc_bases or not skirmish then
76599: LD_EXP 23
76603: NOT
76604: PUSH
76605: LD_EXP 21
76609: NOT
76610: OR
76611: IFFALSE 76615
// exit ;
76613: GO 76704
// for i = 1 to mc_bases do
76615: LD_ADDR_VAR 0 4
76619: PUSH
76620: DOUBLE
76621: LD_INT 1
76623: DEC
76624: ST_TO_ADDR
76625: LD_EXP 23
76629: PUSH
76630: FOR_TO
76631: IFFALSE 76702
// begin if building in mc_busy_turret_list [ i ] then
76633: LD_VAR 0 1
76637: PUSH
76638: LD_EXP 33
76642: PUSH
76643: LD_VAR 0 4
76647: ARRAY
76648: IN
76649: IFFALSE 76700
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76651: LD_ADDR_VAR 0 5
76655: PUSH
76656: LD_EXP 33
76660: PUSH
76661: LD_VAR 0 4
76665: ARRAY
76666: PUSH
76667: LD_VAR 0 1
76671: DIFF
76672: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76673: LD_ADDR_EXP 33
76677: PUSH
76678: LD_EXP 33
76682: PPUSH
76683: LD_VAR 0 4
76687: PPUSH
76688: LD_VAR 0 5
76692: PPUSH
76693: CALL_OW 1
76697: ST_TO_ADDR
// break ;
76698: GO 76702
// end ; end ;
76700: GO 76630
76702: POP
76703: POP
// end ;
76704: LD_VAR 0 3
76708: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76709: LD_INT 0
76711: PPUSH
76712: PPUSH
76713: PPUSH
// if not mc_bases or not skirmish then
76714: LD_EXP 23
76718: NOT
76719: PUSH
76720: LD_EXP 21
76724: NOT
76725: OR
76726: IFFALSE 76730
// exit ;
76728: GO 76929
// for i = 1 to mc_bases do
76730: LD_ADDR_VAR 0 5
76734: PUSH
76735: DOUBLE
76736: LD_INT 1
76738: DEC
76739: ST_TO_ADDR
76740: LD_EXP 23
76744: PUSH
76745: FOR_TO
76746: IFFALSE 76927
// if building in mc_bases [ i ] then
76748: LD_VAR 0 1
76752: PUSH
76753: LD_EXP 23
76757: PUSH
76758: LD_VAR 0 5
76762: ARRAY
76763: IN
76764: IFFALSE 76925
// begin tmp := mc_bases [ i ] diff building ;
76766: LD_ADDR_VAR 0 6
76770: PUSH
76771: LD_EXP 23
76775: PUSH
76776: LD_VAR 0 5
76780: ARRAY
76781: PUSH
76782: LD_VAR 0 1
76786: DIFF
76787: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76788: LD_ADDR_EXP 23
76792: PUSH
76793: LD_EXP 23
76797: PPUSH
76798: LD_VAR 0 5
76802: PPUSH
76803: LD_VAR 0 6
76807: PPUSH
76808: CALL_OW 1
76812: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76813: LD_VAR 0 1
76817: PUSH
76818: LD_EXP 31
76822: PUSH
76823: LD_VAR 0 5
76827: ARRAY
76828: IN
76829: IFFALSE 76868
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76831: LD_ADDR_EXP 31
76835: PUSH
76836: LD_EXP 31
76840: PPUSH
76841: LD_VAR 0 5
76845: PPUSH
76846: LD_EXP 31
76850: PUSH
76851: LD_VAR 0 5
76855: ARRAY
76856: PUSH
76857: LD_VAR 0 1
76861: DIFF
76862: PPUSH
76863: CALL_OW 1
76867: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76868: LD_VAR 0 1
76872: PUSH
76873: LD_EXP 32
76877: PUSH
76878: LD_VAR 0 5
76882: ARRAY
76883: IN
76884: IFFALSE 76923
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76886: LD_ADDR_EXP 32
76890: PUSH
76891: LD_EXP 32
76895: PPUSH
76896: LD_VAR 0 5
76900: PPUSH
76901: LD_EXP 32
76905: PUSH
76906: LD_VAR 0 5
76910: ARRAY
76911: PUSH
76912: LD_VAR 0 1
76916: DIFF
76917: PPUSH
76918: CALL_OW 1
76922: ST_TO_ADDR
// break ;
76923: GO 76927
// end ;
76925: GO 76745
76927: POP
76928: POP
// end ;
76929: LD_VAR 0 4
76933: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76934: LD_INT 0
76936: PPUSH
76937: PPUSH
76938: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76939: LD_EXP 23
76943: NOT
76944: PUSH
76945: LD_EXP 21
76949: NOT
76950: OR
76951: PUSH
76952: LD_VAR 0 3
76956: PUSH
76957: LD_EXP 49
76961: IN
76962: NOT
76963: OR
76964: IFFALSE 76968
// exit ;
76966: GO 77091
// for i = 1 to mc_vehicles do
76968: LD_ADDR_VAR 0 6
76972: PUSH
76973: DOUBLE
76974: LD_INT 1
76976: DEC
76977: ST_TO_ADDR
76978: LD_EXP 42
76982: PUSH
76983: FOR_TO
76984: IFFALSE 77089
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76986: LD_VAR 0 2
76990: PUSH
76991: LD_EXP 42
76995: PUSH
76996: LD_VAR 0 6
77000: ARRAY
77001: IN
77002: PUSH
77003: LD_VAR 0 1
77007: PUSH
77008: LD_EXP 42
77012: PUSH
77013: LD_VAR 0 6
77017: ARRAY
77018: IN
77019: OR
77020: IFFALSE 77087
// begin tmp := mc_vehicles [ i ] diff old ;
77022: LD_ADDR_VAR 0 7
77026: PUSH
77027: LD_EXP 42
77031: PUSH
77032: LD_VAR 0 6
77036: ARRAY
77037: PUSH
77038: LD_VAR 0 2
77042: DIFF
77043: ST_TO_ADDR
// tmp := tmp diff new ;
77044: LD_ADDR_VAR 0 7
77048: PUSH
77049: LD_VAR 0 7
77053: PUSH
77054: LD_VAR 0 1
77058: DIFF
77059: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77060: LD_ADDR_EXP 42
77064: PUSH
77065: LD_EXP 42
77069: PPUSH
77070: LD_VAR 0 6
77074: PPUSH
77075: LD_VAR 0 7
77079: PPUSH
77080: CALL_OW 1
77084: ST_TO_ADDR
// break ;
77085: GO 77089
// end ;
77087: GO 76983
77089: POP
77090: POP
// end ;
77091: LD_VAR 0 5
77095: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77096: LD_INT 0
77098: PPUSH
77099: PPUSH
77100: PPUSH
77101: PPUSH
// if not mc_bases or not skirmish then
77102: LD_EXP 23
77106: NOT
77107: PUSH
77108: LD_EXP 21
77112: NOT
77113: OR
77114: IFFALSE 77118
// exit ;
77116: GO 77510
// side := GetSide ( vehicle ) ;
77118: LD_ADDR_VAR 0 5
77122: PUSH
77123: LD_VAR 0 1
77127: PPUSH
77128: CALL_OW 255
77132: ST_TO_ADDR
// for i = 1 to mc_bases do
77133: LD_ADDR_VAR 0 4
77137: PUSH
77138: DOUBLE
77139: LD_INT 1
77141: DEC
77142: ST_TO_ADDR
77143: LD_EXP 23
77147: PUSH
77148: FOR_TO
77149: IFFALSE 77508
// begin if factory in mc_bases [ i ] then
77151: LD_VAR 0 2
77155: PUSH
77156: LD_EXP 23
77160: PUSH
77161: LD_VAR 0 4
77165: ARRAY
77166: IN
77167: IFFALSE 77506
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77169: LD_EXP 45
77173: PUSH
77174: LD_VAR 0 4
77178: ARRAY
77179: PUSH
77180: LD_EXP 34
77184: PUSH
77185: LD_VAR 0 4
77189: ARRAY
77190: LESS
77191: PUSH
77192: LD_VAR 0 1
77196: PPUSH
77197: CALL_OW 264
77201: PUSH
77202: LD_INT 31
77204: PUSH
77205: LD_INT 32
77207: PUSH
77208: LD_INT 51
77210: PUSH
77211: LD_EXP 68
77215: PUSH
77216: LD_INT 12
77218: PUSH
77219: LD_INT 30
77221: PUSH
77222: LD_EXP 67
77226: PUSH
77227: LD_INT 11
77229: PUSH
77230: LD_INT 53
77232: PUSH
77233: LD_INT 14
77235: PUSH
77236: LD_EXP 71
77240: PUSH
77241: LD_INT 29
77243: PUSH
77244: LD_EXP 69
77248: PUSH
77249: LD_INT 13
77251: PUSH
77252: LD_INT 52
77254: PUSH
77255: LD_EXP 73
77259: PUSH
77260: LD_INT 48
77262: PUSH
77263: LD_INT 8
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: LIST
77270: LIST
77271: LIST
77272: LIST
77273: LIST
77274: LIST
77275: LIST
77276: LIST
77277: LIST
77278: LIST
77279: LIST
77280: LIST
77281: LIST
77282: LIST
77283: LIST
77284: LIST
77285: IN
77286: NOT
77287: AND
77288: IFFALSE 77336
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77290: LD_ADDR_EXP 45
77294: PUSH
77295: LD_EXP 45
77299: PPUSH
77300: LD_VAR 0 4
77304: PUSH
77305: LD_EXP 45
77309: PUSH
77310: LD_VAR 0 4
77314: ARRAY
77315: PUSH
77316: LD_INT 1
77318: PLUS
77319: PUSH
77320: EMPTY
77321: LIST
77322: LIST
77323: PPUSH
77324: LD_VAR 0 1
77328: PPUSH
77329: CALL 15990 0 3
77333: ST_TO_ADDR
77334: GO 77380
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77336: LD_ADDR_EXP 42
77340: PUSH
77341: LD_EXP 42
77345: PPUSH
77346: LD_VAR 0 4
77350: PUSH
77351: LD_EXP 42
77355: PUSH
77356: LD_VAR 0 4
77360: ARRAY
77361: PUSH
77362: LD_INT 1
77364: PLUS
77365: PUSH
77366: EMPTY
77367: LIST
77368: LIST
77369: PPUSH
77370: LD_VAR 0 1
77374: PPUSH
77375: CALL 15990 0 3
77379: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77380: LD_VAR 0 1
77384: PPUSH
77385: CALL_OW 263
77389: PUSH
77390: LD_INT 2
77392: EQUAL
77393: IFFALSE 77422
// begin repeat wait ( 0 0$3 ) ;
77395: LD_INT 105
77397: PPUSH
77398: CALL_OW 67
// Connect ( vehicle ) ;
77402: LD_VAR 0 1
77406: PPUSH
77407: CALL 18961 0 1
// until IsControledBy ( vehicle ) ;
77411: LD_VAR 0 1
77415: PPUSH
77416: CALL_OW 312
77420: IFFALSE 77395
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77422: LD_VAR 0 1
77426: PPUSH
77427: LD_EXP 47
77431: PUSH
77432: LD_VAR 0 4
77436: ARRAY
77437: PPUSH
77438: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77442: LD_VAR 0 1
77446: PPUSH
77447: CALL_OW 263
77451: PUSH
77452: LD_INT 1
77454: NONEQUAL
77455: IFFALSE 77459
// break ;
77457: GO 77508
// repeat wait ( 0 0$1 ) ;
77459: LD_INT 35
77461: PPUSH
77462: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77466: LD_VAR 0 1
77470: PPUSH
77471: LD_EXP 47
77475: PUSH
77476: LD_VAR 0 4
77480: ARRAY
77481: PPUSH
77482: CALL_OW 308
77486: IFFALSE 77459
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77488: LD_VAR 0 1
77492: PPUSH
77493: CALL_OW 311
77497: PPUSH
77498: CALL_OW 121
// exit ;
77502: POP
77503: POP
77504: GO 77510
// end ; end ;
77506: GO 77148
77508: POP
77509: POP
// end ;
77510: LD_VAR 0 3
77514: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77515: LD_INT 0
77517: PPUSH
77518: PPUSH
77519: PPUSH
77520: PPUSH
// if not mc_bases or not skirmish then
77521: LD_EXP 23
77525: NOT
77526: PUSH
77527: LD_EXP 21
77531: NOT
77532: OR
77533: IFFALSE 77537
// exit ;
77535: GO 77890
// repeat wait ( 0 0$1 ) ;
77537: LD_INT 35
77539: PPUSH
77540: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77544: LD_VAR 0 2
77548: PPUSH
77549: LD_VAR 0 3
77553: PPUSH
77554: CALL_OW 284
77558: IFFALSE 77537
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77560: LD_VAR 0 2
77564: PPUSH
77565: LD_VAR 0 3
77569: PPUSH
77570: CALL_OW 283
77574: PUSH
77575: LD_INT 4
77577: EQUAL
77578: IFFALSE 77582
// exit ;
77580: GO 77890
// for i = 1 to mc_bases do
77582: LD_ADDR_VAR 0 7
77586: PUSH
77587: DOUBLE
77588: LD_INT 1
77590: DEC
77591: ST_TO_ADDR
77592: LD_EXP 23
77596: PUSH
77597: FOR_TO
77598: IFFALSE 77888
// begin if mc_crates_area [ i ] then
77600: LD_EXP 41
77604: PUSH
77605: LD_VAR 0 7
77609: ARRAY
77610: IFFALSE 77721
// for j in mc_crates_area [ i ] do
77612: LD_ADDR_VAR 0 8
77616: PUSH
77617: LD_EXP 41
77621: PUSH
77622: LD_VAR 0 7
77626: ARRAY
77627: PUSH
77628: FOR_IN
77629: IFFALSE 77719
// if InArea ( x , y , j ) then
77631: LD_VAR 0 2
77635: PPUSH
77636: LD_VAR 0 3
77640: PPUSH
77641: LD_VAR 0 8
77645: PPUSH
77646: CALL_OW 309
77650: IFFALSE 77717
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77652: LD_ADDR_EXP 39
77656: PUSH
77657: LD_EXP 39
77661: PPUSH
77662: LD_VAR 0 7
77666: PUSH
77667: LD_EXP 39
77671: PUSH
77672: LD_VAR 0 7
77676: ARRAY
77677: PUSH
77678: LD_INT 1
77680: PLUS
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PPUSH
77686: LD_VAR 0 4
77690: PUSH
77691: LD_VAR 0 2
77695: PUSH
77696: LD_VAR 0 3
77700: PUSH
77701: EMPTY
77702: LIST
77703: LIST
77704: LIST
77705: PPUSH
77706: CALL 15990 0 3
77710: ST_TO_ADDR
// exit ;
77711: POP
77712: POP
77713: POP
77714: POP
77715: GO 77890
// end ;
77717: GO 77628
77719: POP
77720: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77721: LD_ADDR_VAR 0 9
77725: PUSH
77726: LD_EXP 23
77730: PUSH
77731: LD_VAR 0 7
77735: ARRAY
77736: PPUSH
77737: LD_INT 2
77739: PUSH
77740: LD_INT 30
77742: PUSH
77743: LD_INT 0
77745: PUSH
77746: EMPTY
77747: LIST
77748: LIST
77749: PUSH
77750: LD_INT 30
77752: PUSH
77753: LD_INT 1
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PUSH
77760: EMPTY
77761: LIST
77762: LIST
77763: LIST
77764: PPUSH
77765: CALL_OW 72
77769: ST_TO_ADDR
// if not depot then
77770: LD_VAR 0 9
77774: NOT
77775: IFFALSE 77779
// continue ;
77777: GO 77597
// for j in depot do
77779: LD_ADDR_VAR 0 8
77783: PUSH
77784: LD_VAR 0 9
77788: PUSH
77789: FOR_IN
77790: IFFALSE 77884
// if GetDistUnitXY ( j , x , y ) < 30 then
77792: LD_VAR 0 8
77796: PPUSH
77797: LD_VAR 0 2
77801: PPUSH
77802: LD_VAR 0 3
77806: PPUSH
77807: CALL_OW 297
77811: PUSH
77812: LD_INT 30
77814: LESS
77815: IFFALSE 77882
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77817: LD_ADDR_EXP 39
77821: PUSH
77822: LD_EXP 39
77826: PPUSH
77827: LD_VAR 0 7
77831: PUSH
77832: LD_EXP 39
77836: PUSH
77837: LD_VAR 0 7
77841: ARRAY
77842: PUSH
77843: LD_INT 1
77845: PLUS
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PPUSH
77851: LD_VAR 0 4
77855: PUSH
77856: LD_VAR 0 2
77860: PUSH
77861: LD_VAR 0 3
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: LIST
77870: PPUSH
77871: CALL 15990 0 3
77875: ST_TO_ADDR
// exit ;
77876: POP
77877: POP
77878: POP
77879: POP
77880: GO 77890
// end ;
77882: GO 77789
77884: POP
77885: POP
// end ;
77886: GO 77597
77888: POP
77889: POP
// end ;
77890: LD_VAR 0 6
77894: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77895: LD_INT 0
77897: PPUSH
77898: PPUSH
77899: PPUSH
77900: PPUSH
// if not mc_bases or not skirmish then
77901: LD_EXP 23
77905: NOT
77906: PUSH
77907: LD_EXP 21
77911: NOT
77912: OR
77913: IFFALSE 77917
// exit ;
77915: GO 78194
// side := GetSide ( lab ) ;
77917: LD_ADDR_VAR 0 4
77921: PUSH
77922: LD_VAR 0 2
77926: PPUSH
77927: CALL_OW 255
77931: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77932: LD_VAR 0 4
77936: PUSH
77937: LD_EXP 49
77941: IN
77942: NOT
77943: PUSH
77944: LD_EXP 50
77948: NOT
77949: OR
77950: PUSH
77951: LD_EXP 23
77955: NOT
77956: OR
77957: IFFALSE 77961
// exit ;
77959: GO 78194
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77961: LD_ADDR_EXP 50
77965: PUSH
77966: LD_EXP 50
77970: PPUSH
77971: LD_VAR 0 4
77975: PPUSH
77976: LD_EXP 50
77980: PUSH
77981: LD_VAR 0 4
77985: ARRAY
77986: PUSH
77987: LD_VAR 0 1
77991: DIFF
77992: PPUSH
77993: CALL_OW 1
77997: ST_TO_ADDR
// for i = 1 to mc_bases do
77998: LD_ADDR_VAR 0 5
78002: PUSH
78003: DOUBLE
78004: LD_INT 1
78006: DEC
78007: ST_TO_ADDR
78008: LD_EXP 23
78012: PUSH
78013: FOR_TO
78014: IFFALSE 78192
// begin if lab in mc_bases [ i ] then
78016: LD_VAR 0 2
78020: PUSH
78021: LD_EXP 23
78025: PUSH
78026: LD_VAR 0 5
78030: ARRAY
78031: IN
78032: IFFALSE 78190
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78034: LD_VAR 0 1
78038: PUSH
78039: LD_INT 11
78041: PUSH
78042: LD_INT 4
78044: PUSH
78045: LD_INT 3
78047: PUSH
78048: LD_INT 2
78050: PUSH
78051: EMPTY
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: IN
78057: PUSH
78058: LD_EXP 53
78062: PUSH
78063: LD_VAR 0 5
78067: ARRAY
78068: AND
78069: IFFALSE 78190
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78071: LD_ADDR_VAR 0 6
78075: PUSH
78076: LD_EXP 53
78080: PUSH
78081: LD_VAR 0 5
78085: ARRAY
78086: PUSH
78087: LD_INT 1
78089: ARRAY
78090: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78091: LD_ADDR_EXP 53
78095: PUSH
78096: LD_EXP 53
78100: PPUSH
78101: LD_VAR 0 5
78105: PPUSH
78106: EMPTY
78107: PPUSH
78108: CALL_OW 1
78112: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78113: LD_VAR 0 6
78117: PPUSH
78118: LD_INT 0
78120: PPUSH
78121: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78125: LD_VAR 0 6
78129: PPUSH
78130: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78134: LD_ADDR_EXP 52
78138: PUSH
78139: LD_EXP 52
78143: PPUSH
78144: LD_VAR 0 5
78148: PPUSH
78149: LD_EXP 52
78153: PUSH
78154: LD_VAR 0 5
78158: ARRAY
78159: PPUSH
78160: LD_INT 1
78162: PPUSH
78163: LD_VAR 0 6
78167: PPUSH
78168: CALL_OW 2
78172: PPUSH
78173: CALL_OW 1
78177: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78178: LD_VAR 0 5
78182: PPUSH
78183: LD_INT 112
78185: PPUSH
78186: CALL 54713 0 2
// end ; end ; end ;
78190: GO 78013
78192: POP
78193: POP
// end ;
78194: LD_VAR 0 3
78198: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78199: LD_INT 0
78201: PPUSH
78202: PPUSH
78203: PPUSH
78204: PPUSH
78205: PPUSH
78206: PPUSH
78207: PPUSH
78208: PPUSH
// if not mc_bases or not skirmish then
78209: LD_EXP 23
78213: NOT
78214: PUSH
78215: LD_EXP 21
78219: NOT
78220: OR
78221: IFFALSE 78225
// exit ;
78223: GO 79596
// for i = 1 to mc_bases do
78225: LD_ADDR_VAR 0 3
78229: PUSH
78230: DOUBLE
78231: LD_INT 1
78233: DEC
78234: ST_TO_ADDR
78235: LD_EXP 23
78239: PUSH
78240: FOR_TO
78241: IFFALSE 79594
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78243: LD_VAR 0 1
78247: PUSH
78248: LD_EXP 23
78252: PUSH
78253: LD_VAR 0 3
78257: ARRAY
78258: IN
78259: PUSH
78260: LD_VAR 0 1
78264: PUSH
78265: LD_EXP 30
78269: PUSH
78270: LD_VAR 0 3
78274: ARRAY
78275: IN
78276: OR
78277: PUSH
78278: LD_VAR 0 1
78282: PUSH
78283: LD_EXP 45
78287: PUSH
78288: LD_VAR 0 3
78292: ARRAY
78293: IN
78294: OR
78295: PUSH
78296: LD_VAR 0 1
78300: PUSH
78301: LD_EXP 42
78305: PUSH
78306: LD_VAR 0 3
78310: ARRAY
78311: IN
78312: OR
78313: PUSH
78314: LD_VAR 0 1
78318: PUSH
78319: LD_EXP 52
78323: PUSH
78324: LD_VAR 0 3
78328: ARRAY
78329: IN
78330: OR
78331: PUSH
78332: LD_VAR 0 1
78336: PUSH
78337: LD_EXP 53
78341: PUSH
78342: LD_VAR 0 3
78346: ARRAY
78347: IN
78348: OR
78349: IFFALSE 79592
// begin if un in mc_ape [ i ] then
78351: LD_VAR 0 1
78355: PUSH
78356: LD_EXP 52
78360: PUSH
78361: LD_VAR 0 3
78365: ARRAY
78366: IN
78367: IFFALSE 78406
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78369: LD_ADDR_EXP 52
78373: PUSH
78374: LD_EXP 52
78378: PPUSH
78379: LD_VAR 0 3
78383: PPUSH
78384: LD_EXP 52
78388: PUSH
78389: LD_VAR 0 3
78393: ARRAY
78394: PUSH
78395: LD_VAR 0 1
78399: DIFF
78400: PPUSH
78401: CALL_OW 1
78405: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78406: LD_VAR 0 1
78410: PUSH
78411: LD_EXP 53
78415: PUSH
78416: LD_VAR 0 3
78420: ARRAY
78421: IN
78422: IFFALSE 78446
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78424: LD_ADDR_EXP 53
78428: PUSH
78429: LD_EXP 53
78433: PPUSH
78434: LD_VAR 0 3
78438: PPUSH
78439: EMPTY
78440: PPUSH
78441: CALL_OW 1
78445: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78446: LD_VAR 0 1
78450: PPUSH
78451: CALL_OW 247
78455: PUSH
78456: LD_INT 2
78458: EQUAL
78459: PUSH
78460: LD_VAR 0 1
78464: PPUSH
78465: CALL_OW 110
78469: PUSH
78470: LD_INT 20
78472: EQUAL
78473: PUSH
78474: LD_VAR 0 1
78478: PUSH
78479: LD_EXP 45
78483: PUSH
78484: LD_VAR 0 3
78488: ARRAY
78489: IN
78490: OR
78491: PUSH
78492: LD_VAR 0 1
78496: PPUSH
78497: CALL_OW 264
78501: PUSH
78502: LD_INT 12
78504: PUSH
78505: LD_INT 51
78507: PUSH
78508: LD_EXP 68
78512: PUSH
78513: LD_INT 32
78515: PUSH
78516: LD_INT 13
78518: PUSH
78519: LD_INT 52
78521: PUSH
78522: LD_INT 31
78524: PUSH
78525: EMPTY
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: IN
78534: OR
78535: AND
78536: IFFALSE 78844
// begin if un in mc_defender [ i ] then
78538: LD_VAR 0 1
78542: PUSH
78543: LD_EXP 45
78547: PUSH
78548: LD_VAR 0 3
78552: ARRAY
78553: IN
78554: IFFALSE 78593
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78556: LD_ADDR_EXP 45
78560: PUSH
78561: LD_EXP 45
78565: PPUSH
78566: LD_VAR 0 3
78570: PPUSH
78571: LD_EXP 45
78575: PUSH
78576: LD_VAR 0 3
78580: ARRAY
78581: PUSH
78582: LD_VAR 0 1
78586: DIFF
78587: PPUSH
78588: CALL_OW 1
78592: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78593: LD_ADDR_VAR 0 8
78597: PUSH
78598: LD_VAR 0 3
78602: PPUSH
78603: LD_INT 3
78605: PPUSH
78606: CALL 75234 0 2
78610: ST_TO_ADDR
// if fac then
78611: LD_VAR 0 8
78615: IFFALSE 78844
// begin for j in fac do
78617: LD_ADDR_VAR 0 4
78621: PUSH
78622: LD_VAR 0 8
78626: PUSH
78627: FOR_IN
78628: IFFALSE 78842
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78630: LD_ADDR_VAR 0 9
78634: PUSH
78635: LD_VAR 0 8
78639: PPUSH
78640: LD_VAR 0 1
78644: PPUSH
78645: CALL_OW 265
78649: PPUSH
78650: LD_VAR 0 1
78654: PPUSH
78655: CALL_OW 262
78659: PPUSH
78660: LD_VAR 0 1
78664: PPUSH
78665: CALL_OW 263
78669: PPUSH
78670: LD_VAR 0 1
78674: PPUSH
78675: CALL_OW 264
78679: PPUSH
78680: CALL 13486 0 5
78684: ST_TO_ADDR
// if components then
78685: LD_VAR 0 9
78689: IFFALSE 78840
// begin if GetWeapon ( un ) = ar_control_tower then
78691: LD_VAR 0 1
78695: PPUSH
78696: CALL_OW 264
78700: PUSH
78701: LD_INT 31
78703: EQUAL
78704: IFFALSE 78821
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78706: LD_VAR 0 1
78710: PPUSH
78711: CALL_OW 311
78715: PPUSH
78716: LD_INT 0
78718: PPUSH
78719: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78723: LD_ADDR_EXP 63
78727: PUSH
78728: LD_EXP 63
78732: PPUSH
78733: LD_VAR 0 3
78737: PPUSH
78738: LD_EXP 63
78742: PUSH
78743: LD_VAR 0 3
78747: ARRAY
78748: PUSH
78749: LD_VAR 0 1
78753: PPUSH
78754: CALL_OW 311
78758: DIFF
78759: PPUSH
78760: CALL_OW 1
78764: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78765: LD_ADDR_VAR 0 7
78769: PUSH
78770: LD_EXP 44
78774: PUSH
78775: LD_VAR 0 3
78779: ARRAY
78780: PPUSH
78781: LD_INT 1
78783: PPUSH
78784: LD_VAR 0 9
78788: PPUSH
78789: CALL_OW 2
78793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78794: LD_ADDR_EXP 44
78798: PUSH
78799: LD_EXP 44
78803: PPUSH
78804: LD_VAR 0 3
78808: PPUSH
78809: LD_VAR 0 7
78813: PPUSH
78814: CALL_OW 1
78818: ST_TO_ADDR
// end else
78819: GO 78838
// MC_InsertProduceList ( i , [ components ] ) ;
78821: LD_VAR 0 3
78825: PPUSH
78826: LD_VAR 0 9
78830: PUSH
78831: EMPTY
78832: LIST
78833: PPUSH
78834: CALL 74779 0 2
// break ;
78838: GO 78842
// end ; end ;
78840: GO 78627
78842: POP
78843: POP
// end ; end ; if GetType ( un ) = unit_building then
78844: LD_VAR 0 1
78848: PPUSH
78849: CALL_OW 247
78853: PUSH
78854: LD_INT 3
78856: EQUAL
78857: IFFALSE 79260
// begin btype := GetBType ( un ) ;
78859: LD_ADDR_VAR 0 5
78863: PUSH
78864: LD_VAR 0 1
78868: PPUSH
78869: CALL_OW 266
78873: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78874: LD_VAR 0 5
78878: PUSH
78879: LD_INT 29
78881: PUSH
78882: LD_INT 30
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: IN
78889: IFFALSE 78962
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78891: LD_VAR 0 1
78895: PPUSH
78896: CALL_OW 250
78900: PPUSH
78901: LD_VAR 0 1
78905: PPUSH
78906: CALL_OW 251
78910: PPUSH
78911: LD_VAR 0 1
78915: PPUSH
78916: CALL_OW 255
78920: PPUSH
78921: CALL_OW 440
78925: NOT
78926: IFFALSE 78962
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78928: LD_VAR 0 1
78932: PPUSH
78933: CALL_OW 250
78937: PPUSH
78938: LD_VAR 0 1
78942: PPUSH
78943: CALL_OW 251
78947: PPUSH
78948: LD_VAR 0 1
78952: PPUSH
78953: CALL_OW 255
78957: PPUSH
78958: CALL_OW 441
// end ; if btype = b_warehouse then
78962: LD_VAR 0 5
78966: PUSH
78967: LD_INT 1
78969: EQUAL
78970: IFFALSE 78988
// begin btype := b_depot ;
78972: LD_ADDR_VAR 0 5
78976: PUSH
78977: LD_INT 0
78979: ST_TO_ADDR
// pos := 1 ;
78980: LD_ADDR_VAR 0 6
78984: PUSH
78985: LD_INT 1
78987: ST_TO_ADDR
// end ; if btype = b_factory then
78988: LD_VAR 0 5
78992: PUSH
78993: LD_INT 3
78995: EQUAL
78996: IFFALSE 79014
// begin btype := b_workshop ;
78998: LD_ADDR_VAR 0 5
79002: PUSH
79003: LD_INT 2
79005: ST_TO_ADDR
// pos := 1 ;
79006: LD_ADDR_VAR 0 6
79010: PUSH
79011: LD_INT 1
79013: ST_TO_ADDR
// end ; if btype = b_barracks then
79014: LD_VAR 0 5
79018: PUSH
79019: LD_INT 5
79021: EQUAL
79022: IFFALSE 79032
// btype := b_armoury ;
79024: LD_ADDR_VAR 0 5
79028: PUSH
79029: LD_INT 4
79031: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79032: LD_VAR 0 5
79036: PUSH
79037: LD_INT 7
79039: PUSH
79040: LD_INT 8
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: IN
79047: IFFALSE 79057
// btype := b_lab ;
79049: LD_ADDR_VAR 0 5
79053: PUSH
79054: LD_INT 6
79056: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79057: LD_ADDR_EXP 28
79061: PUSH
79062: LD_EXP 28
79066: PPUSH
79067: LD_VAR 0 3
79071: PUSH
79072: LD_EXP 28
79076: PUSH
79077: LD_VAR 0 3
79081: ARRAY
79082: PUSH
79083: LD_INT 1
79085: PLUS
79086: PUSH
79087: EMPTY
79088: LIST
79089: LIST
79090: PPUSH
79091: LD_VAR 0 5
79095: PUSH
79096: LD_VAR 0 1
79100: PPUSH
79101: CALL_OW 250
79105: PUSH
79106: LD_VAR 0 1
79110: PPUSH
79111: CALL_OW 251
79115: PUSH
79116: LD_VAR 0 1
79120: PPUSH
79121: CALL_OW 254
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: PPUSH
79132: CALL 15990 0 3
79136: ST_TO_ADDR
// if pos = 1 then
79137: LD_VAR 0 6
79141: PUSH
79142: LD_INT 1
79144: EQUAL
79145: IFFALSE 79260
// begin tmp := mc_build_list [ i ] ;
79147: LD_ADDR_VAR 0 7
79151: PUSH
79152: LD_EXP 28
79156: PUSH
79157: LD_VAR 0 3
79161: ARRAY
79162: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79163: LD_VAR 0 7
79167: PPUSH
79168: LD_INT 2
79170: PUSH
79171: LD_INT 30
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 30
79183: PUSH
79184: LD_INT 1
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: PUSH
79191: EMPTY
79192: LIST
79193: LIST
79194: LIST
79195: PPUSH
79196: CALL_OW 72
79200: IFFALSE 79210
// pos := 2 ;
79202: LD_ADDR_VAR 0 6
79206: PUSH
79207: LD_INT 2
79209: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79210: LD_ADDR_VAR 0 7
79214: PUSH
79215: LD_VAR 0 7
79219: PPUSH
79220: LD_VAR 0 6
79224: PPUSH
79225: LD_VAR 0 7
79229: PPUSH
79230: CALL 16316 0 3
79234: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79235: LD_ADDR_EXP 28
79239: PUSH
79240: LD_EXP 28
79244: PPUSH
79245: LD_VAR 0 3
79249: PPUSH
79250: LD_VAR 0 7
79254: PPUSH
79255: CALL_OW 1
79259: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79260: LD_VAR 0 1
79264: PUSH
79265: LD_EXP 23
79269: PUSH
79270: LD_VAR 0 3
79274: ARRAY
79275: IN
79276: IFFALSE 79315
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79278: LD_ADDR_EXP 23
79282: PUSH
79283: LD_EXP 23
79287: PPUSH
79288: LD_VAR 0 3
79292: PPUSH
79293: LD_EXP 23
79297: PUSH
79298: LD_VAR 0 3
79302: ARRAY
79303: PUSH
79304: LD_VAR 0 1
79308: DIFF
79309: PPUSH
79310: CALL_OW 1
79314: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79315: LD_VAR 0 1
79319: PUSH
79320: LD_EXP 30
79324: PUSH
79325: LD_VAR 0 3
79329: ARRAY
79330: IN
79331: IFFALSE 79370
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79333: LD_ADDR_EXP 30
79337: PUSH
79338: LD_EXP 30
79342: PPUSH
79343: LD_VAR 0 3
79347: PPUSH
79348: LD_EXP 30
79352: PUSH
79353: LD_VAR 0 3
79357: ARRAY
79358: PUSH
79359: LD_VAR 0 1
79363: DIFF
79364: PPUSH
79365: CALL_OW 1
79369: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79370: LD_VAR 0 1
79374: PUSH
79375: LD_EXP 42
79379: PUSH
79380: LD_VAR 0 3
79384: ARRAY
79385: IN
79386: IFFALSE 79425
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79388: LD_ADDR_EXP 42
79392: PUSH
79393: LD_EXP 42
79397: PPUSH
79398: LD_VAR 0 3
79402: PPUSH
79403: LD_EXP 42
79407: PUSH
79408: LD_VAR 0 3
79412: ARRAY
79413: PUSH
79414: LD_VAR 0 1
79418: DIFF
79419: PPUSH
79420: CALL_OW 1
79424: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79425: LD_VAR 0 1
79429: PUSH
79430: LD_EXP 45
79434: PUSH
79435: LD_VAR 0 3
79439: ARRAY
79440: IN
79441: IFFALSE 79480
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79443: LD_ADDR_EXP 45
79447: PUSH
79448: LD_EXP 45
79452: PPUSH
79453: LD_VAR 0 3
79457: PPUSH
79458: LD_EXP 45
79462: PUSH
79463: LD_VAR 0 3
79467: ARRAY
79468: PUSH
79469: LD_VAR 0 1
79473: DIFF
79474: PPUSH
79475: CALL_OW 1
79479: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79480: LD_VAR 0 1
79484: PUSH
79485: LD_EXP 32
79489: PUSH
79490: LD_VAR 0 3
79494: ARRAY
79495: IN
79496: IFFALSE 79535
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79498: LD_ADDR_EXP 32
79502: PUSH
79503: LD_EXP 32
79507: PPUSH
79508: LD_VAR 0 3
79512: PPUSH
79513: LD_EXP 32
79517: PUSH
79518: LD_VAR 0 3
79522: ARRAY
79523: PUSH
79524: LD_VAR 0 1
79528: DIFF
79529: PPUSH
79530: CALL_OW 1
79534: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79535: LD_VAR 0 1
79539: PUSH
79540: LD_EXP 31
79544: PUSH
79545: LD_VAR 0 3
79549: ARRAY
79550: IN
79551: IFFALSE 79590
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79553: LD_ADDR_EXP 31
79557: PUSH
79558: LD_EXP 31
79562: PPUSH
79563: LD_VAR 0 3
79567: PPUSH
79568: LD_EXP 31
79572: PUSH
79573: LD_VAR 0 3
79577: ARRAY
79578: PUSH
79579: LD_VAR 0 1
79583: DIFF
79584: PPUSH
79585: CALL_OW 1
79589: ST_TO_ADDR
// end ; break ;
79590: GO 79594
// end ;
79592: GO 78240
79594: POP
79595: POP
// end ;
79596: LD_VAR 0 2
79600: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79601: LD_INT 0
79603: PPUSH
79604: PPUSH
79605: PPUSH
// if not mc_bases or not skirmish then
79606: LD_EXP 23
79610: NOT
79611: PUSH
79612: LD_EXP 21
79616: NOT
79617: OR
79618: IFFALSE 79622
// exit ;
79620: GO 79837
// for i = 1 to mc_bases do
79622: LD_ADDR_VAR 0 3
79626: PUSH
79627: DOUBLE
79628: LD_INT 1
79630: DEC
79631: ST_TO_ADDR
79632: LD_EXP 23
79636: PUSH
79637: FOR_TO
79638: IFFALSE 79835
// begin if building in mc_construct_list [ i ] then
79640: LD_VAR 0 1
79644: PUSH
79645: LD_EXP 30
79649: PUSH
79650: LD_VAR 0 3
79654: ARRAY
79655: IN
79656: IFFALSE 79833
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79658: LD_ADDR_EXP 30
79662: PUSH
79663: LD_EXP 30
79667: PPUSH
79668: LD_VAR 0 3
79672: PPUSH
79673: LD_EXP 30
79677: PUSH
79678: LD_VAR 0 3
79682: ARRAY
79683: PUSH
79684: LD_VAR 0 1
79688: DIFF
79689: PPUSH
79690: CALL_OW 1
79694: ST_TO_ADDR
// if building in mc_lab [ i ] then
79695: LD_VAR 0 1
79699: PUSH
79700: LD_EXP 56
79704: PUSH
79705: LD_VAR 0 3
79709: ARRAY
79710: IN
79711: IFFALSE 79766
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79713: LD_ADDR_EXP 57
79717: PUSH
79718: LD_EXP 57
79722: PPUSH
79723: LD_VAR 0 3
79727: PPUSH
79728: LD_EXP 57
79732: PUSH
79733: LD_VAR 0 3
79737: ARRAY
79738: PPUSH
79739: LD_INT 1
79741: PPUSH
79742: LD_EXP 57
79746: PUSH
79747: LD_VAR 0 3
79751: ARRAY
79752: PPUSH
79753: LD_INT 0
79755: PPUSH
79756: CALL 15408 0 4
79760: PPUSH
79761: CALL_OW 1
79765: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79766: LD_VAR 0 1
79770: PUSH
79771: LD_EXP 23
79775: PUSH
79776: LD_VAR 0 3
79780: ARRAY
79781: IN
79782: NOT
79783: IFFALSE 79829
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79785: LD_ADDR_EXP 23
79789: PUSH
79790: LD_EXP 23
79794: PPUSH
79795: LD_VAR 0 3
79799: PUSH
79800: LD_EXP 23
79804: PUSH
79805: LD_VAR 0 3
79809: ARRAY
79810: PUSH
79811: LD_INT 1
79813: PLUS
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PPUSH
79819: LD_VAR 0 1
79823: PPUSH
79824: CALL 15990 0 3
79828: ST_TO_ADDR
// exit ;
79829: POP
79830: POP
79831: GO 79837
// end ; end ;
79833: GO 79637
79835: POP
79836: POP
// end ;
79837: LD_VAR 0 2
79841: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79842: LD_INT 0
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
// if not mc_bases or not skirmish then
79851: LD_EXP 23
79855: NOT
79856: PUSH
79857: LD_EXP 21
79861: NOT
79862: OR
79863: IFFALSE 79867
// exit ;
79865: GO 80528
// for i = 1 to mc_bases do
79867: LD_ADDR_VAR 0 3
79871: PUSH
79872: DOUBLE
79873: LD_INT 1
79875: DEC
79876: ST_TO_ADDR
79877: LD_EXP 23
79881: PUSH
79882: FOR_TO
79883: IFFALSE 80526
// begin if building in mc_construct_list [ i ] then
79885: LD_VAR 0 1
79889: PUSH
79890: LD_EXP 30
79894: PUSH
79895: LD_VAR 0 3
79899: ARRAY
79900: IN
79901: IFFALSE 80524
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79903: LD_ADDR_EXP 30
79907: PUSH
79908: LD_EXP 30
79912: PPUSH
79913: LD_VAR 0 3
79917: PPUSH
79918: LD_EXP 30
79922: PUSH
79923: LD_VAR 0 3
79927: ARRAY
79928: PUSH
79929: LD_VAR 0 1
79933: DIFF
79934: PPUSH
79935: CALL_OW 1
79939: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79940: LD_ADDR_EXP 23
79944: PUSH
79945: LD_EXP 23
79949: PPUSH
79950: LD_VAR 0 3
79954: PUSH
79955: LD_EXP 23
79959: PUSH
79960: LD_VAR 0 3
79964: ARRAY
79965: PUSH
79966: LD_INT 1
79968: PLUS
79969: PUSH
79970: EMPTY
79971: LIST
79972: LIST
79973: PPUSH
79974: LD_VAR 0 1
79978: PPUSH
79979: CALL 15990 0 3
79983: ST_TO_ADDR
// btype := GetBType ( building ) ;
79984: LD_ADDR_VAR 0 5
79988: PUSH
79989: LD_VAR 0 1
79993: PPUSH
79994: CALL_OW 266
79998: ST_TO_ADDR
// side := GetSide ( building ) ;
79999: LD_ADDR_VAR 0 8
80003: PUSH
80004: LD_VAR 0 1
80008: PPUSH
80009: CALL_OW 255
80013: ST_TO_ADDR
// if btype = b_lab then
80014: LD_VAR 0 5
80018: PUSH
80019: LD_INT 6
80021: EQUAL
80022: IFFALSE 80072
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80024: LD_ADDR_EXP 56
80028: PUSH
80029: LD_EXP 56
80033: PPUSH
80034: LD_VAR 0 3
80038: PUSH
80039: LD_EXP 56
80043: PUSH
80044: LD_VAR 0 3
80048: ARRAY
80049: PUSH
80050: LD_INT 1
80052: PLUS
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PPUSH
80058: LD_VAR 0 1
80062: PPUSH
80063: CALL 15990 0 3
80067: ST_TO_ADDR
// exit ;
80068: POP
80069: POP
80070: GO 80528
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80072: LD_VAR 0 5
80076: PUSH
80077: LD_INT 0
80079: PUSH
80080: LD_INT 2
80082: PUSH
80083: LD_INT 4
80085: PUSH
80086: EMPTY
80087: LIST
80088: LIST
80089: LIST
80090: IN
80091: IFFALSE 80215
// begin if btype = b_armoury then
80093: LD_VAR 0 5
80097: PUSH
80098: LD_INT 4
80100: EQUAL
80101: IFFALSE 80111
// btype := b_barracks ;
80103: LD_ADDR_VAR 0 5
80107: PUSH
80108: LD_INT 5
80110: ST_TO_ADDR
// if btype = b_depot then
80111: LD_VAR 0 5
80115: PUSH
80116: LD_INT 0
80118: EQUAL
80119: IFFALSE 80129
// btype := b_warehouse ;
80121: LD_ADDR_VAR 0 5
80125: PUSH
80126: LD_INT 1
80128: ST_TO_ADDR
// if btype = b_workshop then
80129: LD_VAR 0 5
80133: PUSH
80134: LD_INT 2
80136: EQUAL
80137: IFFALSE 80147
// btype := b_factory ;
80139: LD_ADDR_VAR 0 5
80143: PUSH
80144: LD_INT 3
80146: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80147: LD_VAR 0 5
80151: PPUSH
80152: LD_VAR 0 8
80156: PPUSH
80157: CALL_OW 323
80161: PUSH
80162: LD_INT 1
80164: EQUAL
80165: IFFALSE 80211
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80167: LD_ADDR_EXP 55
80171: PUSH
80172: LD_EXP 55
80176: PPUSH
80177: LD_VAR 0 3
80181: PUSH
80182: LD_EXP 55
80186: PUSH
80187: LD_VAR 0 3
80191: ARRAY
80192: PUSH
80193: LD_INT 1
80195: PLUS
80196: PUSH
80197: EMPTY
80198: LIST
80199: LIST
80200: PPUSH
80201: LD_VAR 0 1
80205: PPUSH
80206: CALL 15990 0 3
80210: ST_TO_ADDR
// exit ;
80211: POP
80212: POP
80213: GO 80528
// end ; if btype in [ b_bunker , b_turret ] then
80215: LD_VAR 0 5
80219: PUSH
80220: LD_INT 32
80222: PUSH
80223: LD_INT 33
80225: PUSH
80226: EMPTY
80227: LIST
80228: LIST
80229: IN
80230: IFFALSE 80520
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80232: LD_ADDR_EXP 31
80236: PUSH
80237: LD_EXP 31
80241: PPUSH
80242: LD_VAR 0 3
80246: PUSH
80247: LD_EXP 31
80251: PUSH
80252: LD_VAR 0 3
80256: ARRAY
80257: PUSH
80258: LD_INT 1
80260: PLUS
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PPUSH
80266: LD_VAR 0 1
80270: PPUSH
80271: CALL 15990 0 3
80275: ST_TO_ADDR
// if btype = b_bunker then
80276: LD_VAR 0 5
80280: PUSH
80281: LD_INT 32
80283: EQUAL
80284: IFFALSE 80520
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80286: LD_ADDR_EXP 32
80290: PUSH
80291: LD_EXP 32
80295: PPUSH
80296: LD_VAR 0 3
80300: PUSH
80301: LD_EXP 32
80305: PUSH
80306: LD_VAR 0 3
80310: ARRAY
80311: PUSH
80312: LD_INT 1
80314: PLUS
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PPUSH
80320: LD_VAR 0 1
80324: PPUSH
80325: CALL 15990 0 3
80329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80330: LD_ADDR_VAR 0 6
80334: PUSH
80335: LD_EXP 23
80339: PUSH
80340: LD_VAR 0 3
80344: ARRAY
80345: PPUSH
80346: LD_INT 25
80348: PUSH
80349: LD_INT 1
80351: PUSH
80352: EMPTY
80353: LIST
80354: LIST
80355: PUSH
80356: LD_INT 3
80358: PUSH
80359: LD_INT 54
80361: PUSH
80362: EMPTY
80363: LIST
80364: PUSH
80365: EMPTY
80366: LIST
80367: LIST
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PPUSH
80373: CALL_OW 72
80377: ST_TO_ADDR
// if tmp then
80378: LD_VAR 0 6
80382: IFFALSE 80388
// exit ;
80384: POP
80385: POP
80386: GO 80528
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80388: LD_ADDR_VAR 0 6
80392: PUSH
80393: LD_EXP 23
80397: PUSH
80398: LD_VAR 0 3
80402: ARRAY
80403: PPUSH
80404: LD_INT 2
80406: PUSH
80407: LD_INT 30
80409: PUSH
80410: LD_INT 4
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: PUSH
80417: LD_INT 30
80419: PUSH
80420: LD_INT 5
80422: PUSH
80423: EMPTY
80424: LIST
80425: LIST
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: LIST
80431: PPUSH
80432: CALL_OW 72
80436: ST_TO_ADDR
// if not tmp then
80437: LD_VAR 0 6
80441: NOT
80442: IFFALSE 80448
// exit ;
80444: POP
80445: POP
80446: GO 80528
// for j in tmp do
80448: LD_ADDR_VAR 0 4
80452: PUSH
80453: LD_VAR 0 6
80457: PUSH
80458: FOR_IN
80459: IFFALSE 80518
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80461: LD_ADDR_VAR 0 7
80465: PUSH
80466: LD_VAR 0 4
80470: PPUSH
80471: CALL_OW 313
80475: PPUSH
80476: LD_INT 25
80478: PUSH
80479: LD_INT 1
80481: PUSH
80482: EMPTY
80483: LIST
80484: LIST
80485: PPUSH
80486: CALL_OW 72
80490: ST_TO_ADDR
// if units then
80491: LD_VAR 0 7
80495: IFFALSE 80516
// begin ComExitBuilding ( units [ 1 ] ) ;
80497: LD_VAR 0 7
80501: PUSH
80502: LD_INT 1
80504: ARRAY
80505: PPUSH
80506: CALL_OW 122
// exit ;
80510: POP
80511: POP
80512: POP
80513: POP
80514: GO 80528
// end ; end ;
80516: GO 80458
80518: POP
80519: POP
// end ; end ; exit ;
80520: POP
80521: POP
80522: GO 80528
// end ; end ;
80524: GO 79882
80526: POP
80527: POP
// end ;
80528: LD_VAR 0 2
80532: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80533: LD_INT 0
80535: PPUSH
80536: PPUSH
80537: PPUSH
80538: PPUSH
80539: PPUSH
80540: PPUSH
80541: PPUSH
// if not mc_bases or not skirmish then
80542: LD_EXP 23
80546: NOT
80547: PUSH
80548: LD_EXP 21
80552: NOT
80553: OR
80554: IFFALSE 80558
// exit ;
80556: GO 80823
// btype := GetBType ( building ) ;
80558: LD_ADDR_VAR 0 6
80562: PUSH
80563: LD_VAR 0 1
80567: PPUSH
80568: CALL_OW 266
80572: ST_TO_ADDR
// x := GetX ( building ) ;
80573: LD_ADDR_VAR 0 7
80577: PUSH
80578: LD_VAR 0 1
80582: PPUSH
80583: CALL_OW 250
80587: ST_TO_ADDR
// y := GetY ( building ) ;
80588: LD_ADDR_VAR 0 8
80592: PUSH
80593: LD_VAR 0 1
80597: PPUSH
80598: CALL_OW 251
80602: ST_TO_ADDR
// d := GetDir ( building ) ;
80603: LD_ADDR_VAR 0 9
80607: PUSH
80608: LD_VAR 0 1
80612: PPUSH
80613: CALL_OW 254
80617: ST_TO_ADDR
// for i = 1 to mc_bases do
80618: LD_ADDR_VAR 0 4
80622: PUSH
80623: DOUBLE
80624: LD_INT 1
80626: DEC
80627: ST_TO_ADDR
80628: LD_EXP 23
80632: PUSH
80633: FOR_TO
80634: IFFALSE 80821
// begin if not mc_build_list [ i ] then
80636: LD_EXP 28
80640: PUSH
80641: LD_VAR 0 4
80645: ARRAY
80646: NOT
80647: IFFALSE 80651
// continue ;
80649: GO 80633
// for j := 1 to mc_build_list [ i ] do
80651: LD_ADDR_VAR 0 5
80655: PUSH
80656: DOUBLE
80657: LD_INT 1
80659: DEC
80660: ST_TO_ADDR
80661: LD_EXP 28
80665: PUSH
80666: LD_VAR 0 4
80670: ARRAY
80671: PUSH
80672: FOR_TO
80673: IFFALSE 80817
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
80675: LD_VAR 0 6
80679: PUSH
80680: LD_VAR 0 7
80684: PUSH
80685: LD_VAR 0 8
80689: PUSH
80690: LD_VAR 0 9
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: PPUSH
80701: LD_EXP 28
80705: PUSH
80706: LD_VAR 0 4
80710: ARRAY
80711: PUSH
80712: LD_VAR 0 5
80716: ARRAY
80717: PPUSH
80718: CALL 22172 0 2
80722: IFFALSE 80815
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
80724: LD_ADDR_EXP 28
80728: PUSH
80729: LD_EXP 28
80733: PPUSH
80734: LD_VAR 0 4
80738: PPUSH
80739: LD_EXP 28
80743: PUSH
80744: LD_VAR 0 4
80748: ARRAY
80749: PPUSH
80750: LD_VAR 0 5
80754: PPUSH
80755: CALL_OW 3
80759: PPUSH
80760: CALL_OW 1
80764: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80765: LD_ADDR_EXP 30
80769: PUSH
80770: LD_EXP 30
80774: PPUSH
80775: LD_VAR 0 4
80779: PUSH
80780: LD_EXP 30
80784: PUSH
80785: LD_VAR 0 4
80789: ARRAY
80790: PUSH
80791: LD_INT 1
80793: PLUS
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PPUSH
80799: LD_VAR 0 1
80803: PPUSH
80804: CALL 15990 0 3
80808: ST_TO_ADDR
// exit ;
80809: POP
80810: POP
80811: POP
80812: POP
80813: GO 80823
// end ;
80815: GO 80672
80817: POP
80818: POP
// end ;
80819: GO 80633
80821: POP
80822: POP
// end ;
80823: LD_VAR 0 3
80827: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80828: LD_INT 0
80830: PPUSH
80831: PPUSH
80832: PPUSH
// if not mc_bases or not skirmish then
80833: LD_EXP 23
80837: NOT
80838: PUSH
80839: LD_EXP 21
80843: NOT
80844: OR
80845: IFFALSE 80849
// exit ;
80847: GO 81039
// for i = 1 to mc_bases do
80849: LD_ADDR_VAR 0 4
80853: PUSH
80854: DOUBLE
80855: LD_INT 1
80857: DEC
80858: ST_TO_ADDR
80859: LD_EXP 23
80863: PUSH
80864: FOR_TO
80865: IFFALSE 80952
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80867: LD_VAR 0 1
80871: PUSH
80872: LD_EXP 31
80876: PUSH
80877: LD_VAR 0 4
80881: ARRAY
80882: IN
80883: PUSH
80884: LD_VAR 0 1
80888: PUSH
80889: LD_EXP 32
80893: PUSH
80894: LD_VAR 0 4
80898: ARRAY
80899: IN
80900: NOT
80901: AND
80902: IFFALSE 80950
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80904: LD_ADDR_EXP 32
80908: PUSH
80909: LD_EXP 32
80913: PPUSH
80914: LD_VAR 0 4
80918: PUSH
80919: LD_EXP 32
80923: PUSH
80924: LD_VAR 0 4
80928: ARRAY
80929: PUSH
80930: LD_INT 1
80932: PLUS
80933: PUSH
80934: EMPTY
80935: LIST
80936: LIST
80937: PPUSH
80938: LD_VAR 0 1
80942: PPUSH
80943: CALL 15990 0 3
80947: ST_TO_ADDR
// break ;
80948: GO 80952
// end ; end ;
80950: GO 80864
80952: POP
80953: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80954: LD_VAR 0 1
80958: PPUSH
80959: CALL_OW 257
80963: PUSH
80964: LD_EXP 49
80968: IN
80969: PUSH
80970: LD_VAR 0 1
80974: PPUSH
80975: CALL_OW 266
80979: PUSH
80980: LD_INT 5
80982: EQUAL
80983: AND
80984: PUSH
80985: LD_VAR 0 2
80989: PPUSH
80990: CALL_OW 110
80994: PUSH
80995: LD_INT 18
80997: NONEQUAL
80998: AND
80999: IFFALSE 81039
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81001: LD_VAR 0 2
81005: PPUSH
81006: CALL_OW 257
81010: PUSH
81011: LD_INT 5
81013: PUSH
81014: LD_INT 8
81016: PUSH
81017: LD_INT 9
81019: PUSH
81020: EMPTY
81021: LIST
81022: LIST
81023: LIST
81024: IN
81025: IFFALSE 81039
// SetClass ( unit , 1 ) ;
81027: LD_VAR 0 2
81031: PPUSH
81032: LD_INT 1
81034: PPUSH
81035: CALL_OW 336
// end ;
81039: LD_VAR 0 3
81043: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81044: LD_INT 0
81046: PPUSH
81047: PPUSH
// if not mc_bases or not skirmish then
81048: LD_EXP 23
81052: NOT
81053: PUSH
81054: LD_EXP 21
81058: NOT
81059: OR
81060: IFFALSE 81064
// exit ;
81062: GO 81180
// if GetLives ( abandoned_vehicle ) > 250 then
81064: LD_VAR 0 2
81068: PPUSH
81069: CALL_OW 256
81073: PUSH
81074: LD_INT 250
81076: GREATER
81077: IFFALSE 81081
// exit ;
81079: GO 81180
// for i = 1 to mc_bases do
81081: LD_ADDR_VAR 0 6
81085: PUSH
81086: DOUBLE
81087: LD_INT 1
81089: DEC
81090: ST_TO_ADDR
81091: LD_EXP 23
81095: PUSH
81096: FOR_TO
81097: IFFALSE 81178
// begin if driver in mc_bases [ i ] then
81099: LD_VAR 0 1
81103: PUSH
81104: LD_EXP 23
81108: PUSH
81109: LD_VAR 0 6
81113: ARRAY
81114: IN
81115: IFFALSE 81176
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81117: LD_VAR 0 1
81121: PPUSH
81122: LD_EXP 23
81126: PUSH
81127: LD_VAR 0 6
81131: ARRAY
81132: PPUSH
81133: LD_INT 2
81135: PUSH
81136: LD_INT 30
81138: PUSH
81139: LD_INT 0
81141: PUSH
81142: EMPTY
81143: LIST
81144: LIST
81145: PUSH
81146: LD_INT 30
81148: PUSH
81149: LD_INT 1
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: EMPTY
81157: LIST
81158: LIST
81159: LIST
81160: PPUSH
81161: CALL_OW 72
81165: PUSH
81166: LD_INT 1
81168: ARRAY
81169: PPUSH
81170: CALL 48608 0 2
// break ;
81174: GO 81178
// end ; end ;
81176: GO 81096
81178: POP
81179: POP
// end ; end_of_file
81180: LD_VAR 0 5
81184: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
81185: LD_INT 0
81187: PPUSH
// ar_miner := 81 ;
81188: LD_ADDR_EXP 74
81192: PUSH
81193: LD_INT 81
81195: ST_TO_ADDR
// ar_crane := 88 ;
81196: LD_ADDR_EXP 73
81200: PUSH
81201: LD_INT 88
81203: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81204: LD_ADDR_EXP 68
81208: PUSH
81209: LD_INT 89
81211: ST_TO_ADDR
// us_hack := 99 ;
81212: LD_ADDR_EXP 69
81216: PUSH
81217: LD_INT 99
81219: ST_TO_ADDR
// us_artillery := 97 ;
81220: LD_ADDR_EXP 70
81224: PUSH
81225: LD_INT 97
81227: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81228: LD_ADDR_EXP 71
81232: PUSH
81233: LD_INT 91
81235: ST_TO_ADDR
// ar_mortar := 92 ;
81236: LD_ADDR_EXP 72
81240: PUSH
81241: LD_INT 92
81243: ST_TO_ADDR
// ru_radar := 98 ;
81244: LD_ADDR_EXP 67
81248: PUSH
81249: LD_INT 98
81251: ST_TO_ADDR
// tech_Artillery := 80 ;
81252: LD_ADDR_EXP 75
81256: PUSH
81257: LD_INT 80
81259: ST_TO_ADDR
// tech_RadMat := 81 ;
81260: LD_ADDR_EXP 76
81264: PUSH
81265: LD_INT 81
81267: ST_TO_ADDR
// tech_BasicTools := 82 ;
81268: LD_ADDR_EXP 77
81272: PUSH
81273: LD_INT 82
81275: ST_TO_ADDR
// tech_Cargo := 83 ;
81276: LD_ADDR_EXP 78
81280: PUSH
81281: LD_INT 83
81283: ST_TO_ADDR
// tech_Track := 84 ;
81284: LD_ADDR_EXP 79
81288: PUSH
81289: LD_INT 84
81291: ST_TO_ADDR
// tech_Crane := 85 ;
81292: LD_ADDR_EXP 80
81296: PUSH
81297: LD_INT 85
81299: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81300: LD_ADDR_EXP 81
81304: PUSH
81305: LD_INT 86
81307: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81308: LD_ADDR_EXP 82
81312: PUSH
81313: LD_INT 87
81315: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
81316: LD_ADDR_EXP 83
81320: PUSH
81321: LD_INT 88
81323: ST_TO_ADDR
// class_mastodont := 31 ;
81324: LD_ADDR_EXP 84
81328: PUSH
81329: LD_INT 31
81331: ST_TO_ADDR
// class_horse := 21 ;
81332: LD_ADDR_EXP 85
81336: PUSH
81337: LD_INT 21
81339: ST_TO_ADDR
// end ;
81340: LD_VAR 0 1
81344: RET
// every 1 do
81345: GO 81347
81347: DISABLE
// InitGlobalVariables ; end_of_file
81348: CALL 81185 0 0
81352: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
81353: LD_INT 0
81355: PPUSH
81356: PPUSH
81357: PPUSH
81358: PPUSH
81359: PPUSH
81360: PPUSH
81361: PPUSH
81362: PPUSH
81363: PPUSH
81364: PPUSH
81365: PPUSH
81366: PPUSH
81367: PPUSH
81368: PPUSH
81369: PPUSH
81370: PPUSH
81371: PPUSH
81372: PPUSH
81373: PPUSH
81374: PPUSH
81375: PPUSH
81376: PPUSH
81377: PPUSH
81378: PPUSH
81379: PPUSH
81380: PPUSH
81381: PPUSH
81382: PPUSH
81383: PPUSH
81384: PPUSH
81385: PPUSH
81386: PPUSH
81387: PPUSH
81388: PPUSH
// if not list then
81389: LD_VAR 0 1
81393: NOT
81394: IFFALSE 81398
// exit ;
81396: GO 86057
// base := list [ 1 ] ;
81398: LD_ADDR_VAR 0 3
81402: PUSH
81403: LD_VAR 0 1
81407: PUSH
81408: LD_INT 1
81410: ARRAY
81411: ST_TO_ADDR
// group := list [ 2 ] ;
81412: LD_ADDR_VAR 0 4
81416: PUSH
81417: LD_VAR 0 1
81421: PUSH
81422: LD_INT 2
81424: ARRAY
81425: ST_TO_ADDR
// path := list [ 3 ] ;
81426: LD_ADDR_VAR 0 5
81430: PUSH
81431: LD_VAR 0 1
81435: PUSH
81436: LD_INT 3
81438: ARRAY
81439: ST_TO_ADDR
// flags := list [ 4 ] ;
81440: LD_ADDR_VAR 0 6
81444: PUSH
81445: LD_VAR 0 1
81449: PUSH
81450: LD_INT 4
81452: ARRAY
81453: ST_TO_ADDR
// mined := [ ] ;
81454: LD_ADDR_VAR 0 27
81458: PUSH
81459: EMPTY
81460: ST_TO_ADDR
// bombed := [ ] ;
81461: LD_ADDR_VAR 0 28
81465: PUSH
81466: EMPTY
81467: ST_TO_ADDR
// healers := [ ] ;
81468: LD_ADDR_VAR 0 31
81472: PUSH
81473: EMPTY
81474: ST_TO_ADDR
// to_heal := [ ] ;
81475: LD_ADDR_VAR 0 30
81479: PUSH
81480: EMPTY
81481: ST_TO_ADDR
// repairs := [ ] ;
81482: LD_ADDR_VAR 0 33
81486: PUSH
81487: EMPTY
81488: ST_TO_ADDR
// to_repair := [ ] ;
81489: LD_ADDR_VAR 0 32
81493: PUSH
81494: EMPTY
81495: ST_TO_ADDR
// if not group or not path then
81496: LD_VAR 0 4
81500: NOT
81501: PUSH
81502: LD_VAR 0 5
81506: NOT
81507: OR
81508: IFFALSE 81512
// exit ;
81510: GO 86057
// side := GetSide ( group [ 1 ] ) ;
81512: LD_ADDR_VAR 0 35
81516: PUSH
81517: LD_VAR 0 4
81521: PUSH
81522: LD_INT 1
81524: ARRAY
81525: PPUSH
81526: CALL_OW 255
81530: ST_TO_ADDR
// if flags then
81531: LD_VAR 0 6
81535: IFFALSE 81679
// begin f_ignore_area := flags [ 1 ] ;
81537: LD_ADDR_VAR 0 17
81541: PUSH
81542: LD_VAR 0 6
81546: PUSH
81547: LD_INT 1
81549: ARRAY
81550: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
81551: LD_ADDR_VAR 0 18
81555: PUSH
81556: LD_VAR 0 6
81560: PUSH
81561: LD_INT 2
81563: ARRAY
81564: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
81565: LD_ADDR_VAR 0 19
81569: PUSH
81570: LD_VAR 0 6
81574: PUSH
81575: LD_INT 3
81577: ARRAY
81578: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
81579: LD_ADDR_VAR 0 20
81583: PUSH
81584: LD_VAR 0 6
81588: PUSH
81589: LD_INT 4
81591: ARRAY
81592: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
81593: LD_ADDR_VAR 0 21
81597: PUSH
81598: LD_VAR 0 6
81602: PUSH
81603: LD_INT 5
81605: ARRAY
81606: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
81607: LD_ADDR_VAR 0 22
81611: PUSH
81612: LD_VAR 0 6
81616: PUSH
81617: LD_INT 6
81619: ARRAY
81620: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
81621: LD_ADDR_VAR 0 23
81625: PUSH
81626: LD_VAR 0 6
81630: PUSH
81631: LD_INT 7
81633: ARRAY
81634: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
81635: LD_ADDR_VAR 0 24
81639: PUSH
81640: LD_VAR 0 6
81644: PUSH
81645: LD_INT 8
81647: ARRAY
81648: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
81649: LD_ADDR_VAR 0 25
81653: PUSH
81654: LD_VAR 0 6
81658: PUSH
81659: LD_INT 9
81661: ARRAY
81662: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
81663: LD_ADDR_VAR 0 26
81667: PUSH
81668: LD_VAR 0 6
81672: PUSH
81673: LD_INT 10
81675: ARRAY
81676: ST_TO_ADDR
// end else
81677: GO 81759
// begin f_ignore_area := false ;
81679: LD_ADDR_VAR 0 17
81683: PUSH
81684: LD_INT 0
81686: ST_TO_ADDR
// f_capture := false ;
81687: LD_ADDR_VAR 0 18
81691: PUSH
81692: LD_INT 0
81694: ST_TO_ADDR
// f_ignore_civ := false ;
81695: LD_ADDR_VAR 0 19
81699: PUSH
81700: LD_INT 0
81702: ST_TO_ADDR
// f_murder := false ;
81703: LD_ADDR_VAR 0 20
81707: PUSH
81708: LD_INT 0
81710: ST_TO_ADDR
// f_mines := false ;
81711: LD_ADDR_VAR 0 21
81715: PUSH
81716: LD_INT 0
81718: ST_TO_ADDR
// f_repair := false ;
81719: LD_ADDR_VAR 0 22
81723: PUSH
81724: LD_INT 0
81726: ST_TO_ADDR
// f_heal := false ;
81727: LD_ADDR_VAR 0 23
81731: PUSH
81732: LD_INT 0
81734: ST_TO_ADDR
// f_spacetime := false ;
81735: LD_ADDR_VAR 0 24
81739: PUSH
81740: LD_INT 0
81742: ST_TO_ADDR
// f_attack_depot := false ;
81743: LD_ADDR_VAR 0 25
81747: PUSH
81748: LD_INT 0
81750: ST_TO_ADDR
// f_crawl := false ;
81751: LD_ADDR_VAR 0 26
81755: PUSH
81756: LD_INT 0
81758: ST_TO_ADDR
// end ; if f_heal then
81759: LD_VAR 0 23
81763: IFFALSE 81790
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
81765: LD_ADDR_VAR 0 31
81769: PUSH
81770: LD_VAR 0 4
81774: PPUSH
81775: LD_INT 25
81777: PUSH
81778: LD_INT 4
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PPUSH
81785: CALL_OW 72
81789: ST_TO_ADDR
// if f_repair then
81790: LD_VAR 0 22
81794: IFFALSE 81821
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
81796: LD_ADDR_VAR 0 33
81800: PUSH
81801: LD_VAR 0 4
81805: PPUSH
81806: LD_INT 25
81808: PUSH
81809: LD_INT 3
81811: PUSH
81812: EMPTY
81813: LIST
81814: LIST
81815: PPUSH
81816: CALL_OW 72
81820: ST_TO_ADDR
// units_path := [ ] ;
81821: LD_ADDR_VAR 0 16
81825: PUSH
81826: EMPTY
81827: ST_TO_ADDR
// for i = 1 to group do
81828: LD_ADDR_VAR 0 7
81832: PUSH
81833: DOUBLE
81834: LD_INT 1
81836: DEC
81837: ST_TO_ADDR
81838: LD_VAR 0 4
81842: PUSH
81843: FOR_TO
81844: IFFALSE 81873
// units_path := Replace ( units_path , i , path ) ;
81846: LD_ADDR_VAR 0 16
81850: PUSH
81851: LD_VAR 0 16
81855: PPUSH
81856: LD_VAR 0 7
81860: PPUSH
81861: LD_VAR 0 5
81865: PPUSH
81866: CALL_OW 1
81870: ST_TO_ADDR
81871: GO 81843
81873: POP
81874: POP
// repeat for i = group downto 1 do
81875: LD_ADDR_VAR 0 7
81879: PUSH
81880: DOUBLE
81881: LD_VAR 0 4
81885: INC
81886: ST_TO_ADDR
81887: LD_INT 1
81889: PUSH
81890: FOR_DOWNTO
81891: IFFALSE 86013
// begin wait ( 5 ) ;
81893: LD_INT 5
81895: PPUSH
81896: CALL_OW 67
// tmp := [ ] ;
81900: LD_ADDR_VAR 0 14
81904: PUSH
81905: EMPTY
81906: ST_TO_ADDR
// attacking := false ;
81907: LD_ADDR_VAR 0 29
81911: PUSH
81912: LD_INT 0
81914: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
81915: LD_VAR 0 4
81919: PUSH
81920: LD_VAR 0 7
81924: ARRAY
81925: PPUSH
81926: CALL_OW 301
81930: PUSH
81931: LD_VAR 0 4
81935: PUSH
81936: LD_VAR 0 7
81940: ARRAY
81941: NOT
81942: OR
81943: IFFALSE 82052
// begin if GetType ( group [ i ] ) = unit_human then
81945: LD_VAR 0 4
81949: PUSH
81950: LD_VAR 0 7
81954: ARRAY
81955: PPUSH
81956: CALL_OW 247
81960: PUSH
81961: LD_INT 1
81963: EQUAL
81964: IFFALSE 82010
// begin to_heal := to_heal diff group [ i ] ;
81966: LD_ADDR_VAR 0 30
81970: PUSH
81971: LD_VAR 0 30
81975: PUSH
81976: LD_VAR 0 4
81980: PUSH
81981: LD_VAR 0 7
81985: ARRAY
81986: DIFF
81987: ST_TO_ADDR
// healers := healers diff group [ i ] ;
81988: LD_ADDR_VAR 0 31
81992: PUSH
81993: LD_VAR 0 31
81997: PUSH
81998: LD_VAR 0 4
82002: PUSH
82003: LD_VAR 0 7
82007: ARRAY
82008: DIFF
82009: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
82010: LD_ADDR_VAR 0 4
82014: PUSH
82015: LD_VAR 0 4
82019: PPUSH
82020: LD_VAR 0 7
82024: PPUSH
82025: CALL_OW 3
82029: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
82030: LD_ADDR_VAR 0 16
82034: PUSH
82035: LD_VAR 0 16
82039: PPUSH
82040: LD_VAR 0 7
82044: PPUSH
82045: CALL_OW 3
82049: ST_TO_ADDR
// continue ;
82050: GO 81890
// end ; if f_repair then
82052: LD_VAR 0 22
82056: IFFALSE 82545
// begin if GetType ( group [ i ] ) = unit_vehicle then
82058: LD_VAR 0 4
82062: PUSH
82063: LD_VAR 0 7
82067: ARRAY
82068: PPUSH
82069: CALL_OW 247
82073: PUSH
82074: LD_INT 2
82076: EQUAL
82077: IFFALSE 82267
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
82079: LD_VAR 0 4
82083: PUSH
82084: LD_VAR 0 7
82088: ARRAY
82089: PPUSH
82090: CALL_OW 256
82094: PUSH
82095: LD_INT 700
82097: LESS
82098: PUSH
82099: LD_VAR 0 4
82103: PUSH
82104: LD_VAR 0 7
82108: ARRAY
82109: PUSH
82110: LD_VAR 0 32
82114: IN
82115: NOT
82116: AND
82117: IFFALSE 82141
// to_repair := to_repair union group [ i ] ;
82119: LD_ADDR_VAR 0 32
82123: PUSH
82124: LD_VAR 0 32
82128: PUSH
82129: LD_VAR 0 4
82133: PUSH
82134: LD_VAR 0 7
82138: ARRAY
82139: UNION
82140: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
82141: LD_VAR 0 4
82145: PUSH
82146: LD_VAR 0 7
82150: ARRAY
82151: PPUSH
82152: CALL_OW 256
82156: PUSH
82157: LD_INT 1000
82159: EQUAL
82160: PUSH
82161: LD_VAR 0 4
82165: PUSH
82166: LD_VAR 0 7
82170: ARRAY
82171: PUSH
82172: LD_VAR 0 32
82176: IN
82177: AND
82178: IFFALSE 82202
// to_repair := to_repair diff group [ i ] ;
82180: LD_ADDR_VAR 0 32
82184: PUSH
82185: LD_VAR 0 32
82189: PUSH
82190: LD_VAR 0 4
82194: PUSH
82195: LD_VAR 0 7
82199: ARRAY
82200: DIFF
82201: ST_TO_ADDR
// if group [ i ] in to_repair then
82202: LD_VAR 0 4
82206: PUSH
82207: LD_VAR 0 7
82211: ARRAY
82212: PUSH
82213: LD_VAR 0 32
82217: IN
82218: IFFALSE 82265
// begin if not IsInArea ( group [ i ] , f_repair ) then
82220: LD_VAR 0 4
82224: PUSH
82225: LD_VAR 0 7
82229: ARRAY
82230: PPUSH
82231: LD_VAR 0 22
82235: PPUSH
82236: CALL_OW 308
82240: NOT
82241: IFFALSE 82263
// ComMoveToArea ( group [ i ] , f_repair ) ;
82243: LD_VAR 0 4
82247: PUSH
82248: LD_VAR 0 7
82252: ARRAY
82253: PPUSH
82254: LD_VAR 0 22
82258: PPUSH
82259: CALL_OW 113
// continue ;
82263: GO 81890
// end ; end else
82265: GO 82545
// if group [ i ] in repairs then
82267: LD_VAR 0 4
82271: PUSH
82272: LD_VAR 0 7
82276: ARRAY
82277: PUSH
82278: LD_VAR 0 33
82282: IN
82283: IFFALSE 82545
// begin if IsInUnit ( group [ i ] ) then
82285: LD_VAR 0 4
82289: PUSH
82290: LD_VAR 0 7
82294: ARRAY
82295: PPUSH
82296: CALL_OW 310
82300: IFFALSE 82368
// begin z := IsInUnit ( group [ i ] ) ;
82302: LD_ADDR_VAR 0 13
82306: PUSH
82307: LD_VAR 0 4
82311: PUSH
82312: LD_VAR 0 7
82316: ARRAY
82317: PPUSH
82318: CALL_OW 310
82322: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
82323: LD_VAR 0 13
82327: PUSH
82328: LD_VAR 0 32
82332: IN
82333: PUSH
82334: LD_VAR 0 13
82338: PPUSH
82339: LD_VAR 0 22
82343: PPUSH
82344: CALL_OW 308
82348: AND
82349: IFFALSE 82366
// ComExitVehicle ( group [ i ] ) ;
82351: LD_VAR 0 4
82355: PUSH
82356: LD_VAR 0 7
82360: ARRAY
82361: PPUSH
82362: CALL_OW 121
// end else
82366: GO 82545
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
82368: LD_ADDR_VAR 0 13
82372: PUSH
82373: LD_VAR 0 4
82377: PPUSH
82378: LD_INT 95
82380: PUSH
82381: LD_VAR 0 22
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 58
82392: PUSH
82393: EMPTY
82394: LIST
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PPUSH
82400: CALL_OW 72
82404: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
82405: LD_VAR 0 4
82409: PUSH
82410: LD_VAR 0 7
82414: ARRAY
82415: PPUSH
82416: CALL_OW 314
82420: NOT
82421: IFFALSE 82543
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
82423: LD_ADDR_VAR 0 10
82427: PUSH
82428: LD_VAR 0 13
82432: PPUSH
82433: LD_VAR 0 4
82437: PUSH
82438: LD_VAR 0 7
82442: ARRAY
82443: PPUSH
82444: CALL_OW 74
82448: ST_TO_ADDR
// if not x then
82449: LD_VAR 0 10
82453: NOT
82454: IFFALSE 82458
// continue ;
82456: GO 81890
// if GetLives ( x ) < 1000 then
82458: LD_VAR 0 10
82462: PPUSH
82463: CALL_OW 256
82467: PUSH
82468: LD_INT 1000
82470: LESS
82471: IFFALSE 82495
// ComRepairVehicle ( group [ i ] , x ) else
82473: LD_VAR 0 4
82477: PUSH
82478: LD_VAR 0 7
82482: ARRAY
82483: PPUSH
82484: LD_VAR 0 10
82488: PPUSH
82489: CALL_OW 129
82493: GO 82543
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
82495: LD_VAR 0 23
82499: PUSH
82500: LD_VAR 0 4
82504: PUSH
82505: LD_VAR 0 7
82509: ARRAY
82510: PPUSH
82511: CALL_OW 256
82515: PUSH
82516: LD_INT 1000
82518: LESS
82519: AND
82520: NOT
82521: IFFALSE 82543
// ComEnterUnit ( group [ i ] , x ) ;
82523: LD_VAR 0 4
82527: PUSH
82528: LD_VAR 0 7
82532: ARRAY
82533: PPUSH
82534: LD_VAR 0 10
82538: PPUSH
82539: CALL_OW 120
// end ; continue ;
82543: GO 81890
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
82545: LD_VAR 0 23
82549: PUSH
82550: LD_VAR 0 4
82554: PUSH
82555: LD_VAR 0 7
82559: ARRAY
82560: PPUSH
82561: CALL_OW 247
82565: PUSH
82566: LD_INT 1
82568: EQUAL
82569: AND
82570: IFFALSE 83048
// begin if group [ i ] in healers then
82572: LD_VAR 0 4
82576: PUSH
82577: LD_VAR 0 7
82581: ARRAY
82582: PUSH
82583: LD_VAR 0 31
82587: IN
82588: IFFALSE 82861
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
82590: LD_VAR 0 4
82594: PUSH
82595: LD_VAR 0 7
82599: ARRAY
82600: PPUSH
82601: LD_VAR 0 23
82605: PPUSH
82606: CALL_OW 308
82610: NOT
82611: PUSH
82612: LD_VAR 0 4
82616: PUSH
82617: LD_VAR 0 7
82621: ARRAY
82622: PPUSH
82623: CALL_OW 314
82627: NOT
82628: AND
82629: IFFALSE 82653
// ComMoveToArea ( group [ i ] , f_heal ) else
82631: LD_VAR 0 4
82635: PUSH
82636: LD_VAR 0 7
82640: ARRAY
82641: PPUSH
82642: LD_VAR 0 23
82646: PPUSH
82647: CALL_OW 113
82651: GO 82859
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
82653: LD_VAR 0 4
82657: PUSH
82658: LD_VAR 0 7
82662: ARRAY
82663: PPUSH
82664: CALL 45070 0 1
82668: PPUSH
82669: CALL_OW 256
82673: PUSH
82674: LD_INT 1000
82676: EQUAL
82677: IFFALSE 82696
// ComStop ( group [ i ] ) else
82679: LD_VAR 0 4
82683: PUSH
82684: LD_VAR 0 7
82688: ARRAY
82689: PPUSH
82690: CALL_OW 141
82694: GO 82859
// if not HasTask ( group [ i ] ) and to_heal then
82696: LD_VAR 0 4
82700: PUSH
82701: LD_VAR 0 7
82705: ARRAY
82706: PPUSH
82707: CALL_OW 314
82711: NOT
82712: PUSH
82713: LD_VAR 0 30
82717: AND
82718: IFFALSE 82859
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
82720: LD_ADDR_VAR 0 13
82724: PUSH
82725: LD_VAR 0 30
82729: PPUSH
82730: LD_INT 3
82732: PUSH
82733: LD_INT 54
82735: PUSH
82736: EMPTY
82737: LIST
82738: PUSH
82739: EMPTY
82740: LIST
82741: LIST
82742: PPUSH
82743: CALL_OW 72
82747: PPUSH
82748: LD_VAR 0 4
82752: PUSH
82753: LD_VAR 0 7
82757: ARRAY
82758: PPUSH
82759: CALL_OW 74
82763: ST_TO_ADDR
// if z then
82764: LD_VAR 0 13
82768: IFFALSE 82859
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
82770: LD_INT 91
82772: PUSH
82773: LD_VAR 0 13
82777: PUSH
82778: LD_INT 10
82780: PUSH
82781: EMPTY
82782: LIST
82783: LIST
82784: LIST
82785: PUSH
82786: LD_INT 81
82788: PUSH
82789: LD_VAR 0 13
82793: PPUSH
82794: CALL_OW 255
82798: PUSH
82799: EMPTY
82800: LIST
82801: LIST
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PPUSH
82807: CALL_OW 69
82811: PUSH
82812: LD_INT 0
82814: EQUAL
82815: IFFALSE 82839
// ComHeal ( group [ i ] , z ) else
82817: LD_VAR 0 4
82821: PUSH
82822: LD_VAR 0 7
82826: ARRAY
82827: PPUSH
82828: LD_VAR 0 13
82832: PPUSH
82833: CALL_OW 128
82837: GO 82859
// ComMoveToArea ( group [ i ] , f_heal ) ;
82839: LD_VAR 0 4
82843: PUSH
82844: LD_VAR 0 7
82848: ARRAY
82849: PPUSH
82850: LD_VAR 0 23
82854: PPUSH
82855: CALL_OW 113
// end ; continue ;
82859: GO 81890
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
82861: LD_VAR 0 4
82865: PUSH
82866: LD_VAR 0 7
82870: ARRAY
82871: PPUSH
82872: CALL_OW 256
82876: PUSH
82877: LD_INT 700
82879: LESS
82880: PUSH
82881: LD_VAR 0 4
82885: PUSH
82886: LD_VAR 0 7
82890: ARRAY
82891: PUSH
82892: LD_VAR 0 30
82896: IN
82897: NOT
82898: AND
82899: IFFALSE 82923
// to_heal := to_heal union group [ i ] ;
82901: LD_ADDR_VAR 0 30
82905: PUSH
82906: LD_VAR 0 30
82910: PUSH
82911: LD_VAR 0 4
82915: PUSH
82916: LD_VAR 0 7
82920: ARRAY
82921: UNION
82922: ST_TO_ADDR
// if group [ i ] in to_heal then
82923: LD_VAR 0 4
82927: PUSH
82928: LD_VAR 0 7
82932: ARRAY
82933: PUSH
82934: LD_VAR 0 30
82938: IN
82939: IFFALSE 83048
// begin if GetLives ( group [ i ] ) = 1000 then
82941: LD_VAR 0 4
82945: PUSH
82946: LD_VAR 0 7
82950: ARRAY
82951: PPUSH
82952: CALL_OW 256
82956: PUSH
82957: LD_INT 1000
82959: EQUAL
82960: IFFALSE 82986
// to_heal := to_heal diff group [ i ] else
82962: LD_ADDR_VAR 0 30
82966: PUSH
82967: LD_VAR 0 30
82971: PUSH
82972: LD_VAR 0 4
82976: PUSH
82977: LD_VAR 0 7
82981: ARRAY
82982: DIFF
82983: ST_TO_ADDR
82984: GO 83048
// begin if not IsInArea ( group [ i ] , to_heal ) then
82986: LD_VAR 0 4
82990: PUSH
82991: LD_VAR 0 7
82995: ARRAY
82996: PPUSH
82997: LD_VAR 0 30
83001: PPUSH
83002: CALL_OW 308
83006: NOT
83007: IFFALSE 83031
// ComMoveToArea ( group [ i ] , f_heal ) else
83009: LD_VAR 0 4
83013: PUSH
83014: LD_VAR 0 7
83018: ARRAY
83019: PPUSH
83020: LD_VAR 0 23
83024: PPUSH
83025: CALL_OW 113
83029: GO 83046
// ComHold ( group [ i ] ) ;
83031: LD_VAR 0 4
83035: PUSH
83036: LD_VAR 0 7
83040: ARRAY
83041: PPUSH
83042: CALL_OW 140
// continue ;
83046: GO 81890
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
83048: LD_VAR 0 4
83052: PUSH
83053: LD_VAR 0 7
83057: ARRAY
83058: PPUSH
83059: LD_INT 10
83061: PPUSH
83062: CALL 43490 0 2
83066: NOT
83067: PUSH
83068: LD_VAR 0 16
83072: PUSH
83073: LD_VAR 0 7
83077: ARRAY
83078: PUSH
83079: EMPTY
83080: EQUAL
83081: NOT
83082: AND
83083: IFFALSE 83349
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
83085: LD_VAR 0 4
83089: PUSH
83090: LD_VAR 0 7
83094: ARRAY
83095: PPUSH
83096: CALL_OW 262
83100: PUSH
83101: LD_INT 1
83103: PUSH
83104: LD_INT 2
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: IN
83111: IFFALSE 83152
// if GetFuel ( group [ i ] ) < 10 then
83113: LD_VAR 0 4
83117: PUSH
83118: LD_VAR 0 7
83122: ARRAY
83123: PPUSH
83124: CALL_OW 261
83128: PUSH
83129: LD_INT 10
83131: LESS
83132: IFFALSE 83152
// SetFuel ( group [ i ] , 12 ) ;
83134: LD_VAR 0 4
83138: PUSH
83139: LD_VAR 0 7
83143: ARRAY
83144: PPUSH
83145: LD_INT 12
83147: PPUSH
83148: CALL_OW 240
// if units_path [ i ] then
83152: LD_VAR 0 16
83156: PUSH
83157: LD_VAR 0 7
83161: ARRAY
83162: IFFALSE 83347
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
83164: LD_VAR 0 4
83168: PUSH
83169: LD_VAR 0 7
83173: ARRAY
83174: PPUSH
83175: LD_VAR 0 16
83179: PUSH
83180: LD_VAR 0 7
83184: ARRAY
83185: PUSH
83186: LD_INT 1
83188: ARRAY
83189: PUSH
83190: LD_INT 1
83192: ARRAY
83193: PPUSH
83194: LD_VAR 0 16
83198: PUSH
83199: LD_VAR 0 7
83203: ARRAY
83204: PUSH
83205: LD_INT 1
83207: ARRAY
83208: PUSH
83209: LD_INT 2
83211: ARRAY
83212: PPUSH
83213: CALL_OW 297
83217: PUSH
83218: LD_INT 6
83220: GREATER
83221: IFFALSE 83296
// begin if not HasTask ( group [ i ] ) then
83223: LD_VAR 0 4
83227: PUSH
83228: LD_VAR 0 7
83232: ARRAY
83233: PPUSH
83234: CALL_OW 314
83238: NOT
83239: IFFALSE 83294
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
83241: LD_VAR 0 4
83245: PUSH
83246: LD_VAR 0 7
83250: ARRAY
83251: PPUSH
83252: LD_VAR 0 16
83256: PUSH
83257: LD_VAR 0 7
83261: ARRAY
83262: PUSH
83263: LD_INT 1
83265: ARRAY
83266: PUSH
83267: LD_INT 1
83269: ARRAY
83270: PPUSH
83271: LD_VAR 0 16
83275: PUSH
83276: LD_VAR 0 7
83280: ARRAY
83281: PUSH
83282: LD_INT 1
83284: ARRAY
83285: PUSH
83286: LD_INT 2
83288: ARRAY
83289: PPUSH
83290: CALL_OW 114
// end else
83294: GO 83347
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
83296: LD_ADDR_VAR 0 15
83300: PUSH
83301: LD_VAR 0 16
83305: PUSH
83306: LD_VAR 0 7
83310: ARRAY
83311: PPUSH
83312: LD_INT 1
83314: PPUSH
83315: CALL_OW 3
83319: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
83320: LD_ADDR_VAR 0 16
83324: PUSH
83325: LD_VAR 0 16
83329: PPUSH
83330: LD_VAR 0 7
83334: PPUSH
83335: LD_VAR 0 15
83339: PPUSH
83340: CALL_OW 1
83344: ST_TO_ADDR
// continue ;
83345: GO 81890
// end ; end ; end else
83347: GO 86011
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
83349: LD_ADDR_VAR 0 14
83353: PUSH
83354: LD_INT 81
83356: PUSH
83357: LD_VAR 0 4
83361: PUSH
83362: LD_VAR 0 7
83366: ARRAY
83367: PPUSH
83368: CALL_OW 255
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PPUSH
83377: CALL_OW 69
83381: ST_TO_ADDR
// if not tmp then
83382: LD_VAR 0 14
83386: NOT
83387: IFFALSE 83391
// continue ;
83389: GO 81890
// if f_ignore_area then
83391: LD_VAR 0 17
83395: IFFALSE 83483
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
83397: LD_ADDR_VAR 0 15
83401: PUSH
83402: LD_VAR 0 14
83406: PPUSH
83407: LD_INT 3
83409: PUSH
83410: LD_INT 92
83412: PUSH
83413: LD_VAR 0 17
83417: PUSH
83418: LD_INT 1
83420: ARRAY
83421: PUSH
83422: LD_VAR 0 17
83426: PUSH
83427: LD_INT 2
83429: ARRAY
83430: PUSH
83431: LD_VAR 0 17
83435: PUSH
83436: LD_INT 3
83438: ARRAY
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PPUSH
83450: CALL_OW 72
83454: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83455: LD_VAR 0 14
83459: PUSH
83460: LD_VAR 0 15
83464: DIFF
83465: IFFALSE 83483
// tmp := tmp diff tmp2 ;
83467: LD_ADDR_VAR 0 14
83471: PUSH
83472: LD_VAR 0 14
83476: PUSH
83477: LD_VAR 0 15
83481: DIFF
83482: ST_TO_ADDR
// end ; if not f_murder then
83483: LD_VAR 0 20
83487: NOT
83488: IFFALSE 83546
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
83490: LD_ADDR_VAR 0 15
83494: PUSH
83495: LD_VAR 0 14
83499: PPUSH
83500: LD_INT 3
83502: PUSH
83503: LD_INT 50
83505: PUSH
83506: EMPTY
83507: LIST
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PPUSH
83513: CALL_OW 72
83517: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
83518: LD_VAR 0 14
83522: PUSH
83523: LD_VAR 0 15
83527: DIFF
83528: IFFALSE 83546
// tmp := tmp diff tmp2 ;
83530: LD_ADDR_VAR 0 14
83534: PUSH
83535: LD_VAR 0 14
83539: PUSH
83540: LD_VAR 0 15
83544: DIFF
83545: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
83546: LD_ADDR_VAR 0 14
83550: PUSH
83551: LD_VAR 0 4
83555: PUSH
83556: LD_VAR 0 7
83560: ARRAY
83561: PPUSH
83562: LD_VAR 0 14
83566: PPUSH
83567: LD_INT 1
83569: PPUSH
83570: LD_INT 1
83572: PPUSH
83573: CALL 16425 0 4
83577: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
83578: LD_VAR 0 4
83582: PUSH
83583: LD_VAR 0 7
83587: ARRAY
83588: PPUSH
83589: CALL_OW 257
83593: PUSH
83594: LD_INT 1
83596: EQUAL
83597: IFFALSE 84045
// begin if WantPlant ( group [ i ] ) then
83599: LD_VAR 0 4
83603: PUSH
83604: LD_VAR 0 7
83608: ARRAY
83609: PPUSH
83610: CALL 15926 0 1
83614: IFFALSE 83618
// continue ;
83616: GO 81890
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
83618: LD_VAR 0 18
83622: PUSH
83623: LD_VAR 0 4
83627: PUSH
83628: LD_VAR 0 7
83632: ARRAY
83633: PPUSH
83634: CALL_OW 310
83638: NOT
83639: AND
83640: PUSH
83641: LD_VAR 0 14
83645: PUSH
83646: LD_INT 1
83648: ARRAY
83649: PUSH
83650: LD_VAR 0 14
83654: PPUSH
83655: LD_INT 21
83657: PUSH
83658: LD_INT 2
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 58
83667: PUSH
83668: EMPTY
83669: LIST
83670: PUSH
83671: EMPTY
83672: LIST
83673: LIST
83674: PPUSH
83675: CALL_OW 72
83679: IN
83680: AND
83681: IFFALSE 83717
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
83683: LD_VAR 0 4
83687: PUSH
83688: LD_VAR 0 7
83692: ARRAY
83693: PPUSH
83694: LD_VAR 0 14
83698: PUSH
83699: LD_INT 1
83701: ARRAY
83702: PPUSH
83703: CALL_OW 120
// attacking := true ;
83707: LD_ADDR_VAR 0 29
83711: PUSH
83712: LD_INT 1
83714: ST_TO_ADDR
// continue ;
83715: GO 81890
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
83717: LD_VAR 0 26
83721: PUSH
83722: LD_VAR 0 4
83726: PUSH
83727: LD_VAR 0 7
83731: ARRAY
83732: PPUSH
83733: CALL_OW 257
83737: PUSH
83738: LD_INT 1
83740: EQUAL
83741: AND
83742: PUSH
83743: LD_VAR 0 4
83747: PUSH
83748: LD_VAR 0 7
83752: ARRAY
83753: PPUSH
83754: CALL_OW 256
83758: PUSH
83759: LD_INT 800
83761: LESS
83762: AND
83763: PUSH
83764: LD_VAR 0 4
83768: PUSH
83769: LD_VAR 0 7
83773: ARRAY
83774: PPUSH
83775: CALL_OW 318
83779: NOT
83780: AND
83781: IFFALSE 83798
// ComCrawl ( group [ i ] ) ;
83783: LD_VAR 0 4
83787: PUSH
83788: LD_VAR 0 7
83792: ARRAY
83793: PPUSH
83794: CALL_OW 137
// if f_mines then
83798: LD_VAR 0 21
83802: IFFALSE 84045
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
83804: LD_VAR 0 14
83808: PUSH
83809: LD_INT 1
83811: ARRAY
83812: PPUSH
83813: CALL_OW 247
83817: PUSH
83818: LD_INT 3
83820: EQUAL
83821: PUSH
83822: LD_VAR 0 14
83826: PUSH
83827: LD_INT 1
83829: ARRAY
83830: PUSH
83831: LD_VAR 0 27
83835: IN
83836: NOT
83837: AND
83838: IFFALSE 84045
// begin x := GetX ( tmp [ 1 ] ) ;
83840: LD_ADDR_VAR 0 10
83844: PUSH
83845: LD_VAR 0 14
83849: PUSH
83850: LD_INT 1
83852: ARRAY
83853: PPUSH
83854: CALL_OW 250
83858: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
83859: LD_ADDR_VAR 0 11
83863: PUSH
83864: LD_VAR 0 14
83868: PUSH
83869: LD_INT 1
83871: ARRAY
83872: PPUSH
83873: CALL_OW 251
83877: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
83878: LD_ADDR_VAR 0 12
83882: PUSH
83883: LD_VAR 0 4
83887: PUSH
83888: LD_VAR 0 7
83892: ARRAY
83893: PPUSH
83894: CALL 43575 0 1
83898: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
83899: LD_VAR 0 4
83903: PUSH
83904: LD_VAR 0 7
83908: ARRAY
83909: PPUSH
83910: LD_VAR 0 10
83914: PPUSH
83915: LD_VAR 0 11
83919: PPUSH
83920: LD_VAR 0 14
83924: PUSH
83925: LD_INT 1
83927: ARRAY
83928: PPUSH
83929: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
83933: LD_VAR 0 4
83937: PUSH
83938: LD_VAR 0 7
83942: ARRAY
83943: PPUSH
83944: LD_VAR 0 10
83948: PPUSH
83949: LD_VAR 0 12
83953: PPUSH
83954: LD_INT 7
83956: PPUSH
83957: CALL_OW 272
83961: PPUSH
83962: LD_VAR 0 11
83966: PPUSH
83967: LD_VAR 0 12
83971: PPUSH
83972: LD_INT 7
83974: PPUSH
83975: CALL_OW 273
83979: PPUSH
83980: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
83984: LD_VAR 0 4
83988: PUSH
83989: LD_VAR 0 7
83993: ARRAY
83994: PPUSH
83995: LD_INT 71
83997: PPUSH
83998: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
84002: LD_ADDR_VAR 0 27
84006: PUSH
84007: LD_VAR 0 27
84011: PPUSH
84012: LD_VAR 0 27
84016: PUSH
84017: LD_INT 1
84019: PLUS
84020: PPUSH
84021: LD_VAR 0 14
84025: PUSH
84026: LD_INT 1
84028: ARRAY
84029: PPUSH
84030: CALL_OW 1
84034: ST_TO_ADDR
// attacking := true ;
84035: LD_ADDR_VAR 0 29
84039: PUSH
84040: LD_INT 1
84042: ST_TO_ADDR
// continue ;
84043: GO 81890
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
84045: LD_VAR 0 4
84049: PUSH
84050: LD_VAR 0 7
84054: ARRAY
84055: PPUSH
84056: CALL_OW 257
84060: PUSH
84061: LD_INT 17
84063: EQUAL
84064: PUSH
84065: LD_VAR 0 4
84069: PUSH
84070: LD_VAR 0 7
84074: ARRAY
84075: PPUSH
84076: CALL_OW 110
84080: PUSH
84081: LD_INT 71
84083: EQUAL
84084: NOT
84085: AND
84086: IFFALSE 84232
// begin attacking := false ;
84088: LD_ADDR_VAR 0 29
84092: PUSH
84093: LD_INT 0
84095: ST_TO_ADDR
// k := 5 ;
84096: LD_ADDR_VAR 0 9
84100: PUSH
84101: LD_INT 5
84103: ST_TO_ADDR
// if tmp < k then
84104: LD_VAR 0 14
84108: PUSH
84109: LD_VAR 0 9
84113: LESS
84114: IFFALSE 84126
// k := tmp ;
84116: LD_ADDR_VAR 0 9
84120: PUSH
84121: LD_VAR 0 14
84125: ST_TO_ADDR
// for j = 1 to k do
84126: LD_ADDR_VAR 0 8
84130: PUSH
84131: DOUBLE
84132: LD_INT 1
84134: DEC
84135: ST_TO_ADDR
84136: LD_VAR 0 9
84140: PUSH
84141: FOR_TO
84142: IFFALSE 84230
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
84144: LD_VAR 0 14
84148: PUSH
84149: LD_VAR 0 8
84153: ARRAY
84154: PUSH
84155: LD_VAR 0 14
84159: PPUSH
84160: LD_INT 58
84162: PUSH
84163: EMPTY
84164: LIST
84165: PPUSH
84166: CALL_OW 72
84170: IN
84171: NOT
84172: IFFALSE 84228
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84174: LD_VAR 0 4
84178: PUSH
84179: LD_VAR 0 7
84183: ARRAY
84184: PPUSH
84185: LD_VAR 0 14
84189: PUSH
84190: LD_VAR 0 8
84194: ARRAY
84195: PPUSH
84196: CALL_OW 115
// attacking := true ;
84200: LD_ADDR_VAR 0 29
84204: PUSH
84205: LD_INT 1
84207: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
84208: LD_VAR 0 4
84212: PUSH
84213: LD_VAR 0 7
84217: ARRAY
84218: PPUSH
84219: LD_INT 71
84221: PPUSH
84222: CALL_OW 109
// continue ;
84226: GO 84141
// end ; end ;
84228: GO 84141
84230: POP
84231: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
84232: LD_VAR 0 4
84236: PUSH
84237: LD_VAR 0 7
84241: ARRAY
84242: PPUSH
84243: CALL_OW 257
84247: PUSH
84248: LD_INT 8
84250: EQUAL
84251: PUSH
84252: LD_VAR 0 4
84256: PUSH
84257: LD_VAR 0 7
84261: ARRAY
84262: PPUSH
84263: CALL_OW 264
84267: PUSH
84268: LD_INT 28
84270: PUSH
84271: LD_INT 45
84273: PUSH
84274: LD_INT 7
84276: PUSH
84277: LD_INT 47
84279: PUSH
84280: EMPTY
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: IN
84286: OR
84287: IFFALSE 84543
// begin attacking := false ;
84289: LD_ADDR_VAR 0 29
84293: PUSH
84294: LD_INT 0
84296: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
84297: LD_VAR 0 14
84301: PUSH
84302: LD_INT 1
84304: ARRAY
84305: PPUSH
84306: CALL_OW 266
84310: PUSH
84311: LD_INT 32
84313: PUSH
84314: LD_INT 31
84316: PUSH
84317: LD_INT 33
84319: PUSH
84320: LD_INT 4
84322: PUSH
84323: LD_INT 5
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: LIST
84330: LIST
84331: LIST
84332: IN
84333: IFFALSE 84519
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
84335: LD_ADDR_VAR 0 9
84339: PUSH
84340: LD_VAR 0 14
84344: PUSH
84345: LD_INT 1
84347: ARRAY
84348: PPUSH
84349: CALL_OW 266
84353: PPUSH
84354: LD_VAR 0 14
84358: PUSH
84359: LD_INT 1
84361: ARRAY
84362: PPUSH
84363: CALL_OW 250
84367: PPUSH
84368: LD_VAR 0 14
84372: PUSH
84373: LD_INT 1
84375: ARRAY
84376: PPUSH
84377: CALL_OW 251
84381: PPUSH
84382: LD_VAR 0 14
84386: PUSH
84387: LD_INT 1
84389: ARRAY
84390: PPUSH
84391: CALL_OW 254
84395: PPUSH
84396: LD_VAR 0 14
84400: PUSH
84401: LD_INT 1
84403: ARRAY
84404: PPUSH
84405: CALL_OW 248
84409: PPUSH
84410: LD_INT 0
84412: PPUSH
84413: CALL 24945 0 6
84417: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
84418: LD_ADDR_VAR 0 8
84422: PUSH
84423: LD_VAR 0 4
84427: PUSH
84428: LD_VAR 0 7
84432: ARRAY
84433: PPUSH
84434: LD_VAR 0 9
84438: PPUSH
84439: CALL 43615 0 2
84443: ST_TO_ADDR
// if j then
84444: LD_VAR 0 8
84448: IFFALSE 84517
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
84450: LD_VAR 0 8
84454: PUSH
84455: LD_INT 1
84457: ARRAY
84458: PPUSH
84459: LD_VAR 0 8
84463: PUSH
84464: LD_INT 2
84466: ARRAY
84467: PPUSH
84468: CALL_OW 488
84472: IFFALSE 84517
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
84474: LD_VAR 0 4
84478: PUSH
84479: LD_VAR 0 7
84483: ARRAY
84484: PPUSH
84485: LD_VAR 0 8
84489: PUSH
84490: LD_INT 1
84492: ARRAY
84493: PPUSH
84494: LD_VAR 0 8
84498: PUSH
84499: LD_INT 2
84501: ARRAY
84502: PPUSH
84503: CALL_OW 116
// attacking := true ;
84507: LD_ADDR_VAR 0 29
84511: PUSH
84512: LD_INT 1
84514: ST_TO_ADDR
// continue ;
84515: GO 81890
// end ; end else
84517: GO 84543
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84519: LD_VAR 0 4
84523: PUSH
84524: LD_VAR 0 7
84528: ARRAY
84529: PPUSH
84530: LD_VAR 0 14
84534: PUSH
84535: LD_INT 1
84537: ARRAY
84538: PPUSH
84539: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
84543: LD_VAR 0 4
84547: PUSH
84548: LD_VAR 0 7
84552: ARRAY
84553: PPUSH
84554: CALL_OW 265
84558: PUSH
84559: LD_INT 11
84561: EQUAL
84562: IFFALSE 84840
// begin k := 10 ;
84564: LD_ADDR_VAR 0 9
84568: PUSH
84569: LD_INT 10
84571: ST_TO_ADDR
// x := 0 ;
84572: LD_ADDR_VAR 0 10
84576: PUSH
84577: LD_INT 0
84579: ST_TO_ADDR
// if tmp < k then
84580: LD_VAR 0 14
84584: PUSH
84585: LD_VAR 0 9
84589: LESS
84590: IFFALSE 84602
// k := tmp ;
84592: LD_ADDR_VAR 0 9
84596: PUSH
84597: LD_VAR 0 14
84601: ST_TO_ADDR
// for j = k downto 1 do
84602: LD_ADDR_VAR 0 8
84606: PUSH
84607: DOUBLE
84608: LD_VAR 0 9
84612: INC
84613: ST_TO_ADDR
84614: LD_INT 1
84616: PUSH
84617: FOR_DOWNTO
84618: IFFALSE 84693
// begin if GetType ( tmp [ j ] ) = unit_human then
84620: LD_VAR 0 14
84624: PUSH
84625: LD_VAR 0 8
84629: ARRAY
84630: PPUSH
84631: CALL_OW 247
84635: PUSH
84636: LD_INT 1
84638: EQUAL
84639: IFFALSE 84691
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
84641: LD_VAR 0 4
84645: PUSH
84646: LD_VAR 0 7
84650: ARRAY
84651: PPUSH
84652: LD_VAR 0 14
84656: PUSH
84657: LD_VAR 0 8
84661: ARRAY
84662: PPUSH
84663: CALL 43886 0 2
// x := tmp [ j ] ;
84667: LD_ADDR_VAR 0 10
84671: PUSH
84672: LD_VAR 0 14
84676: PUSH
84677: LD_VAR 0 8
84681: ARRAY
84682: ST_TO_ADDR
// attacking := true ;
84683: LD_ADDR_VAR 0 29
84687: PUSH
84688: LD_INT 1
84690: ST_TO_ADDR
// end ; end ;
84691: GO 84617
84693: POP
84694: POP
// if not x then
84695: LD_VAR 0 10
84699: NOT
84700: IFFALSE 84840
// begin attacking := true ;
84702: LD_ADDR_VAR 0 29
84706: PUSH
84707: LD_INT 1
84709: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
84710: LD_VAR 0 4
84714: PUSH
84715: LD_VAR 0 7
84719: ARRAY
84720: PPUSH
84721: CALL_OW 250
84725: PPUSH
84726: LD_VAR 0 4
84730: PUSH
84731: LD_VAR 0 7
84735: ARRAY
84736: PPUSH
84737: CALL_OW 251
84741: PPUSH
84742: CALL_OW 546
84746: PUSH
84747: LD_INT 2
84749: ARRAY
84750: PUSH
84751: LD_VAR 0 14
84755: PUSH
84756: LD_INT 1
84758: ARRAY
84759: PPUSH
84760: CALL_OW 250
84764: PPUSH
84765: LD_VAR 0 14
84769: PUSH
84770: LD_INT 1
84772: ARRAY
84773: PPUSH
84774: CALL_OW 251
84778: PPUSH
84779: CALL_OW 546
84783: PUSH
84784: LD_INT 2
84786: ARRAY
84787: EQUAL
84788: IFFALSE 84816
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
84790: LD_VAR 0 4
84794: PUSH
84795: LD_VAR 0 7
84799: ARRAY
84800: PPUSH
84801: LD_VAR 0 14
84805: PUSH
84806: LD_INT 1
84808: ARRAY
84809: PPUSH
84810: CALL 43886 0 2
84814: GO 84840
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
84816: LD_VAR 0 4
84820: PUSH
84821: LD_VAR 0 7
84825: ARRAY
84826: PPUSH
84827: LD_VAR 0 14
84831: PUSH
84832: LD_INT 1
84834: ARRAY
84835: PPUSH
84836: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
84840: LD_VAR 0 4
84844: PUSH
84845: LD_VAR 0 7
84849: ARRAY
84850: PPUSH
84851: CALL_OW 264
84855: PUSH
84856: LD_INT 29
84858: EQUAL
84859: IFFALSE 85225
// begin if WantsToAttack ( group [ i ] ) in bombed then
84861: LD_VAR 0 4
84865: PUSH
84866: LD_VAR 0 7
84870: ARRAY
84871: PPUSH
84872: CALL_OW 319
84876: PUSH
84877: LD_VAR 0 28
84881: IN
84882: IFFALSE 84886
// continue ;
84884: GO 81890
// k := 8 ;
84886: LD_ADDR_VAR 0 9
84890: PUSH
84891: LD_INT 8
84893: ST_TO_ADDR
// x := 0 ;
84894: LD_ADDR_VAR 0 10
84898: PUSH
84899: LD_INT 0
84901: ST_TO_ADDR
// if tmp < k then
84902: LD_VAR 0 14
84906: PUSH
84907: LD_VAR 0 9
84911: LESS
84912: IFFALSE 84924
// k := tmp ;
84914: LD_ADDR_VAR 0 9
84918: PUSH
84919: LD_VAR 0 14
84923: ST_TO_ADDR
// for j = 1 to k do
84924: LD_ADDR_VAR 0 8
84928: PUSH
84929: DOUBLE
84930: LD_INT 1
84932: DEC
84933: ST_TO_ADDR
84934: LD_VAR 0 9
84938: PUSH
84939: FOR_TO
84940: IFFALSE 85072
// begin if GetType ( tmp [ j ] ) = unit_building then
84942: LD_VAR 0 14
84946: PUSH
84947: LD_VAR 0 8
84951: ARRAY
84952: PPUSH
84953: CALL_OW 247
84957: PUSH
84958: LD_INT 3
84960: EQUAL
84961: IFFALSE 85070
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
84963: LD_VAR 0 14
84967: PUSH
84968: LD_VAR 0 8
84972: ARRAY
84973: PUSH
84974: LD_VAR 0 28
84978: IN
84979: NOT
84980: PUSH
84981: LD_VAR 0 14
84985: PUSH
84986: LD_VAR 0 8
84990: ARRAY
84991: PPUSH
84992: CALL_OW 313
84996: AND
84997: IFFALSE 85070
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
84999: LD_VAR 0 4
85003: PUSH
85004: LD_VAR 0 7
85008: ARRAY
85009: PPUSH
85010: LD_VAR 0 14
85014: PUSH
85015: LD_VAR 0 8
85019: ARRAY
85020: PPUSH
85021: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
85025: LD_ADDR_VAR 0 28
85029: PUSH
85030: LD_VAR 0 28
85034: PPUSH
85035: LD_VAR 0 28
85039: PUSH
85040: LD_INT 1
85042: PLUS
85043: PPUSH
85044: LD_VAR 0 14
85048: PUSH
85049: LD_VAR 0 8
85053: ARRAY
85054: PPUSH
85055: CALL_OW 1
85059: ST_TO_ADDR
// attacking := true ;
85060: LD_ADDR_VAR 0 29
85064: PUSH
85065: LD_INT 1
85067: ST_TO_ADDR
// break ;
85068: GO 85072
// end ; end ;
85070: GO 84939
85072: POP
85073: POP
// if not attacking and f_attack_depot then
85074: LD_VAR 0 29
85078: NOT
85079: PUSH
85080: LD_VAR 0 25
85084: AND
85085: IFFALSE 85180
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
85087: LD_ADDR_VAR 0 13
85091: PUSH
85092: LD_VAR 0 14
85096: PPUSH
85097: LD_INT 2
85099: PUSH
85100: LD_INT 30
85102: PUSH
85103: LD_INT 0
85105: PUSH
85106: EMPTY
85107: LIST
85108: LIST
85109: PUSH
85110: LD_INT 30
85112: PUSH
85113: LD_INT 1
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: EMPTY
85121: LIST
85122: LIST
85123: LIST
85124: PPUSH
85125: CALL_OW 72
85129: ST_TO_ADDR
// if z then
85130: LD_VAR 0 13
85134: IFFALSE 85180
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
85136: LD_VAR 0 4
85140: PUSH
85141: LD_VAR 0 7
85145: ARRAY
85146: PPUSH
85147: LD_VAR 0 13
85151: PPUSH
85152: LD_VAR 0 4
85156: PUSH
85157: LD_VAR 0 7
85161: ARRAY
85162: PPUSH
85163: CALL_OW 74
85167: PPUSH
85168: CALL_OW 115
// attacking := true ;
85172: LD_ADDR_VAR 0 29
85176: PUSH
85177: LD_INT 1
85179: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
85180: LD_VAR 0 4
85184: PUSH
85185: LD_VAR 0 7
85189: ARRAY
85190: PPUSH
85191: CALL_OW 256
85195: PUSH
85196: LD_INT 500
85198: LESS
85199: IFFALSE 85225
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85201: LD_VAR 0 4
85205: PUSH
85206: LD_VAR 0 7
85210: ARRAY
85211: PPUSH
85212: LD_VAR 0 14
85216: PUSH
85217: LD_INT 1
85219: ARRAY
85220: PPUSH
85221: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
85225: LD_VAR 0 4
85229: PUSH
85230: LD_VAR 0 7
85234: ARRAY
85235: PPUSH
85236: CALL_OW 264
85240: PUSH
85241: LD_INT 49
85243: EQUAL
85244: IFFALSE 85365
// begin if not HasTask ( group [ i ] ) then
85246: LD_VAR 0 4
85250: PUSH
85251: LD_VAR 0 7
85255: ARRAY
85256: PPUSH
85257: CALL_OW 314
85261: NOT
85262: IFFALSE 85365
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
85264: LD_ADDR_VAR 0 9
85268: PUSH
85269: LD_INT 81
85271: PUSH
85272: LD_VAR 0 4
85276: PUSH
85277: LD_VAR 0 7
85281: ARRAY
85282: PPUSH
85283: CALL_OW 255
85287: PUSH
85288: EMPTY
85289: LIST
85290: LIST
85291: PPUSH
85292: CALL_OW 69
85296: PPUSH
85297: LD_VAR 0 4
85301: PUSH
85302: LD_VAR 0 7
85306: ARRAY
85307: PPUSH
85308: CALL_OW 74
85312: ST_TO_ADDR
// if k then
85313: LD_VAR 0 9
85317: IFFALSE 85365
// if GetDistUnits ( group [ i ] , k ) > 10 then
85319: LD_VAR 0 4
85323: PUSH
85324: LD_VAR 0 7
85328: ARRAY
85329: PPUSH
85330: LD_VAR 0 9
85334: PPUSH
85335: CALL_OW 296
85339: PUSH
85340: LD_INT 10
85342: GREATER
85343: IFFALSE 85365
// ComMoveUnit ( group [ i ] , k ) ;
85345: LD_VAR 0 4
85349: PUSH
85350: LD_VAR 0 7
85354: ARRAY
85355: PPUSH
85356: LD_VAR 0 9
85360: PPUSH
85361: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
85365: LD_VAR 0 4
85369: PUSH
85370: LD_VAR 0 7
85374: ARRAY
85375: PPUSH
85376: CALL_OW 256
85380: PUSH
85381: LD_INT 250
85383: LESS
85384: PUSH
85385: LD_VAR 0 4
85389: PUSH
85390: LD_VAR 0 7
85394: ARRAY
85395: PUSH
85396: LD_INT 21
85398: PUSH
85399: LD_INT 2
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 23
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PPUSH
85420: CALL_OW 69
85424: IN
85425: AND
85426: IFFALSE 85551
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
85428: LD_ADDR_VAR 0 9
85432: PUSH
85433: LD_OWVAR 3
85437: PUSH
85438: LD_VAR 0 4
85442: PUSH
85443: LD_VAR 0 7
85447: ARRAY
85448: DIFF
85449: PPUSH
85450: LD_VAR 0 4
85454: PUSH
85455: LD_VAR 0 7
85459: ARRAY
85460: PPUSH
85461: CALL_OW 74
85465: ST_TO_ADDR
// if not k then
85466: LD_VAR 0 9
85470: NOT
85471: IFFALSE 85475
// continue ;
85473: GO 81890
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
85475: LD_VAR 0 9
85479: PUSH
85480: LD_INT 81
85482: PUSH
85483: LD_VAR 0 4
85487: PUSH
85488: LD_VAR 0 7
85492: ARRAY
85493: PPUSH
85494: CALL_OW 255
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PPUSH
85503: CALL_OW 69
85507: IN
85508: PUSH
85509: LD_VAR 0 9
85513: PPUSH
85514: LD_VAR 0 4
85518: PUSH
85519: LD_VAR 0 7
85523: ARRAY
85524: PPUSH
85525: CALL_OW 296
85529: PUSH
85530: LD_INT 5
85532: LESS
85533: AND
85534: IFFALSE 85551
// ComAutodestruct ( group [ i ] ) ;
85536: LD_VAR 0 4
85540: PUSH
85541: LD_VAR 0 7
85545: ARRAY
85546: PPUSH
85547: CALL 43784 0 1
// end ; if f_attack_depot then
85551: LD_VAR 0 25
85555: IFFALSE 85667
// begin k := 6 ;
85557: LD_ADDR_VAR 0 9
85561: PUSH
85562: LD_INT 6
85564: ST_TO_ADDR
// if tmp < k then
85565: LD_VAR 0 14
85569: PUSH
85570: LD_VAR 0 9
85574: LESS
85575: IFFALSE 85587
// k := tmp ;
85577: LD_ADDR_VAR 0 9
85581: PUSH
85582: LD_VAR 0 14
85586: ST_TO_ADDR
// for j = 1 to k do
85587: LD_ADDR_VAR 0 8
85591: PUSH
85592: DOUBLE
85593: LD_INT 1
85595: DEC
85596: ST_TO_ADDR
85597: LD_VAR 0 9
85601: PUSH
85602: FOR_TO
85603: IFFALSE 85665
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
85605: LD_VAR 0 8
85609: PPUSH
85610: CALL_OW 266
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: LD_INT 1
85620: PUSH
85621: EMPTY
85622: LIST
85623: LIST
85624: IN
85625: IFFALSE 85663
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
85627: LD_VAR 0 4
85631: PUSH
85632: LD_VAR 0 7
85636: ARRAY
85637: PPUSH
85638: LD_VAR 0 14
85642: PUSH
85643: LD_VAR 0 8
85647: ARRAY
85648: PPUSH
85649: CALL_OW 115
// attacking := true ;
85653: LD_ADDR_VAR 0 29
85657: PUSH
85658: LD_INT 1
85660: ST_TO_ADDR
// break ;
85661: GO 85665
// end ;
85663: GO 85602
85665: POP
85666: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
85667: LD_VAR 0 4
85671: PUSH
85672: LD_VAR 0 7
85676: ARRAY
85677: PPUSH
85678: CALL_OW 302
85682: PUSH
85683: LD_VAR 0 29
85687: NOT
85688: AND
85689: IFFALSE 86011
// begin if GetTag ( group [ i ] ) = 71 then
85691: LD_VAR 0 4
85695: PUSH
85696: LD_VAR 0 7
85700: ARRAY
85701: PPUSH
85702: CALL_OW 110
85706: PUSH
85707: LD_INT 71
85709: EQUAL
85710: IFFALSE 85751
// begin if HasTask ( group [ i ] ) then
85712: LD_VAR 0 4
85716: PUSH
85717: LD_VAR 0 7
85721: ARRAY
85722: PPUSH
85723: CALL_OW 314
85727: IFFALSE 85733
// continue else
85729: GO 81890
85731: GO 85751
// SetTag ( group [ i ] , 0 ) ;
85733: LD_VAR 0 4
85737: PUSH
85738: LD_VAR 0 7
85742: ARRAY
85743: PPUSH
85744: LD_INT 0
85746: PPUSH
85747: CALL_OW 109
// end ; k := 8 ;
85751: LD_ADDR_VAR 0 9
85755: PUSH
85756: LD_INT 8
85758: ST_TO_ADDR
// x := 0 ;
85759: LD_ADDR_VAR 0 10
85763: PUSH
85764: LD_INT 0
85766: ST_TO_ADDR
// if tmp < k then
85767: LD_VAR 0 14
85771: PUSH
85772: LD_VAR 0 9
85776: LESS
85777: IFFALSE 85789
// k := tmp ;
85779: LD_ADDR_VAR 0 9
85783: PUSH
85784: LD_VAR 0 14
85788: ST_TO_ADDR
// for j = 1 to k do
85789: LD_ADDR_VAR 0 8
85793: PUSH
85794: DOUBLE
85795: LD_INT 1
85797: DEC
85798: ST_TO_ADDR
85799: LD_VAR 0 9
85803: PUSH
85804: FOR_TO
85805: IFFALSE 85903
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
85807: LD_VAR 0 14
85811: PUSH
85812: LD_VAR 0 8
85816: ARRAY
85817: PPUSH
85818: CALL_OW 247
85822: PUSH
85823: LD_INT 1
85825: EQUAL
85826: PUSH
85827: LD_VAR 0 14
85831: PUSH
85832: LD_VAR 0 8
85836: ARRAY
85837: PPUSH
85838: CALL_OW 256
85842: PUSH
85843: LD_INT 250
85845: LESS
85846: PUSH
85847: LD_VAR 0 20
85851: AND
85852: PUSH
85853: LD_VAR 0 20
85857: NOT
85858: PUSH
85859: LD_VAR 0 14
85863: PUSH
85864: LD_VAR 0 8
85868: ARRAY
85869: PPUSH
85870: CALL_OW 256
85874: PUSH
85875: LD_INT 250
85877: GREATEREQUAL
85878: AND
85879: OR
85880: AND
85881: IFFALSE 85901
// begin x := tmp [ j ] ;
85883: LD_ADDR_VAR 0 10
85887: PUSH
85888: LD_VAR 0 14
85892: PUSH
85893: LD_VAR 0 8
85897: ARRAY
85898: ST_TO_ADDR
// break ;
85899: GO 85903
// end ;
85901: GO 85804
85903: POP
85904: POP
// if x then
85905: LD_VAR 0 10
85909: IFFALSE 85933
// ComAttackUnit ( group [ i ] , x ) else
85911: LD_VAR 0 4
85915: PUSH
85916: LD_VAR 0 7
85920: ARRAY
85921: PPUSH
85922: LD_VAR 0 10
85926: PPUSH
85927: CALL_OW 115
85931: GO 85957
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
85933: LD_VAR 0 4
85937: PUSH
85938: LD_VAR 0 7
85942: ARRAY
85943: PPUSH
85944: LD_VAR 0 14
85948: PUSH
85949: LD_INT 1
85951: ARRAY
85952: PPUSH
85953: CALL_OW 115
// if not HasTask ( group [ i ] ) then
85957: LD_VAR 0 4
85961: PUSH
85962: LD_VAR 0 7
85966: ARRAY
85967: PPUSH
85968: CALL_OW 314
85972: NOT
85973: IFFALSE 86011
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
85975: LD_VAR 0 4
85979: PUSH
85980: LD_VAR 0 7
85984: ARRAY
85985: PPUSH
85986: LD_VAR 0 14
85990: PPUSH
85991: LD_VAR 0 4
85995: PUSH
85996: LD_VAR 0 7
86000: ARRAY
86001: PPUSH
86002: CALL_OW 74
86006: PPUSH
86007: CALL_OW 115
// end ; end ; end ;
86011: GO 81890
86013: POP
86014: POP
// wait ( 0 0$2 ) ;
86015: LD_INT 70
86017: PPUSH
86018: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
86022: LD_VAR 0 4
86026: NOT
86027: PUSH
86028: LD_VAR 0 4
86032: PUSH
86033: EMPTY
86034: EQUAL
86035: OR
86036: PUSH
86037: LD_INT 81
86039: PUSH
86040: LD_VAR 0 35
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PPUSH
86049: CALL_OW 69
86053: NOT
86054: OR
86055: IFFALSE 81875
// end ;
86057: LD_VAR 0 2
86061: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
86062: LD_INT 0
86064: PPUSH
86065: PPUSH
86066: PPUSH
86067: PPUSH
86068: PPUSH
86069: PPUSH
// if not base or not mc_bases [ base ] or not solds then
86070: LD_VAR 0 1
86074: NOT
86075: PUSH
86076: LD_EXP 23
86080: PUSH
86081: LD_VAR 0 1
86085: ARRAY
86086: NOT
86087: OR
86088: PUSH
86089: LD_VAR 0 2
86093: NOT
86094: OR
86095: IFFALSE 86099
// exit ;
86097: GO 86653
// side := mc_sides [ base ] ;
86099: LD_ADDR_VAR 0 6
86103: PUSH
86104: LD_EXP 49
86108: PUSH
86109: LD_VAR 0 1
86113: ARRAY
86114: ST_TO_ADDR
// if not side then
86115: LD_VAR 0 6
86119: NOT
86120: IFFALSE 86124
// exit ;
86122: GO 86653
// for i in solds do
86124: LD_ADDR_VAR 0 7
86128: PUSH
86129: LD_VAR 0 2
86133: PUSH
86134: FOR_IN
86135: IFFALSE 86196
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
86137: LD_VAR 0 7
86141: PPUSH
86142: CALL_OW 310
86146: PPUSH
86147: CALL_OW 266
86151: PUSH
86152: LD_INT 32
86154: PUSH
86155: LD_INT 31
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: IN
86162: IFFALSE 86182
// solds := solds diff i else
86164: LD_ADDR_VAR 0 2
86168: PUSH
86169: LD_VAR 0 2
86173: PUSH
86174: LD_VAR 0 7
86178: DIFF
86179: ST_TO_ADDR
86180: GO 86194
// SetTag ( i , 18 ) ;
86182: LD_VAR 0 7
86186: PPUSH
86187: LD_INT 18
86189: PPUSH
86190: CALL_OW 109
86194: GO 86134
86196: POP
86197: POP
// if not solds then
86198: LD_VAR 0 2
86202: NOT
86203: IFFALSE 86207
// exit ;
86205: GO 86653
// repeat wait ( 0 0$2 ) ;
86207: LD_INT 70
86209: PPUSH
86210: CALL_OW 67
// enemy := mc_scan [ base ] ;
86214: LD_ADDR_VAR 0 4
86218: PUSH
86219: LD_EXP 46
86223: PUSH
86224: LD_VAR 0 1
86228: ARRAY
86229: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
86230: LD_EXP 23
86234: PUSH
86235: LD_VAR 0 1
86239: ARRAY
86240: NOT
86241: PUSH
86242: LD_EXP 23
86246: PUSH
86247: LD_VAR 0 1
86251: ARRAY
86252: PUSH
86253: EMPTY
86254: EQUAL
86255: OR
86256: IFFALSE 86293
// begin for i in solds do
86258: LD_ADDR_VAR 0 7
86262: PUSH
86263: LD_VAR 0 2
86267: PUSH
86268: FOR_IN
86269: IFFALSE 86282
// ComStop ( i ) ;
86271: LD_VAR 0 7
86275: PPUSH
86276: CALL_OW 141
86280: GO 86268
86282: POP
86283: POP
// solds := [ ] ;
86284: LD_ADDR_VAR 0 2
86288: PUSH
86289: EMPTY
86290: ST_TO_ADDR
// exit ;
86291: GO 86653
// end ; for i in solds do
86293: LD_ADDR_VAR 0 7
86297: PUSH
86298: LD_VAR 0 2
86302: PUSH
86303: FOR_IN
86304: IFFALSE 86625
// begin if IsInUnit ( i ) then
86306: LD_VAR 0 7
86310: PPUSH
86311: CALL_OW 310
86315: IFFALSE 86326
// ComExitBuilding ( i ) ;
86317: LD_VAR 0 7
86321: PPUSH
86322: CALL_OW 122
// if GetLives ( i ) > 500 then
86326: LD_VAR 0 7
86330: PPUSH
86331: CALL_OW 256
86335: PUSH
86336: LD_INT 500
86338: GREATER
86339: IFFALSE 86392
// begin e := NearestUnitToUnit ( enemy , i ) ;
86341: LD_ADDR_VAR 0 5
86345: PUSH
86346: LD_VAR 0 4
86350: PPUSH
86351: LD_VAR 0 7
86355: PPUSH
86356: CALL_OW 74
86360: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
86361: LD_VAR 0 7
86365: PPUSH
86366: LD_VAR 0 5
86370: PPUSH
86371: CALL_OW 250
86375: PPUSH
86376: LD_VAR 0 5
86380: PPUSH
86381: CALL_OW 251
86385: PPUSH
86386: CALL_OW 114
// end else
86390: GO 86623
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
86392: LD_VAR 0 7
86396: PPUSH
86397: LD_EXP 23
86401: PUSH
86402: LD_VAR 0 1
86406: ARRAY
86407: PPUSH
86408: LD_INT 2
86410: PUSH
86411: LD_INT 30
86413: PUSH
86414: LD_INT 0
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 30
86423: PUSH
86424: LD_INT 1
86426: PUSH
86427: EMPTY
86428: LIST
86429: LIST
86430: PUSH
86431: LD_INT 30
86433: PUSH
86434: LD_INT 6
86436: PUSH
86437: EMPTY
86438: LIST
86439: LIST
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: LIST
86445: LIST
86446: PPUSH
86447: CALL_OW 72
86451: PPUSH
86452: LD_VAR 0 7
86456: PPUSH
86457: CALL_OW 74
86461: PPUSH
86462: CALL_OW 296
86466: PUSH
86467: LD_INT 10
86469: GREATER
86470: IFFALSE 86623
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
86472: LD_ADDR_VAR 0 8
86476: PUSH
86477: LD_EXP 23
86481: PUSH
86482: LD_VAR 0 1
86486: ARRAY
86487: PPUSH
86488: LD_INT 2
86490: PUSH
86491: LD_INT 30
86493: PUSH
86494: LD_INT 0
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 30
86503: PUSH
86504: LD_INT 1
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PUSH
86511: LD_INT 30
86513: PUSH
86514: LD_INT 6
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: PPUSH
86527: CALL_OW 72
86531: PPUSH
86532: LD_VAR 0 7
86536: PPUSH
86537: CALL_OW 74
86541: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
86542: LD_VAR 0 7
86546: PPUSH
86547: LD_VAR 0 8
86551: PPUSH
86552: CALL_OW 250
86556: PPUSH
86557: LD_INT 3
86559: PPUSH
86560: LD_INT 5
86562: PPUSH
86563: CALL_OW 272
86567: PPUSH
86568: LD_VAR 0 8
86572: PPUSH
86573: CALL_OW 251
86577: PPUSH
86578: LD_INT 3
86580: PPUSH
86581: LD_INT 5
86583: PPUSH
86584: CALL_OW 273
86588: PPUSH
86589: CALL_OW 111
// SetTag ( i , 0 ) ;
86593: LD_VAR 0 7
86597: PPUSH
86598: LD_INT 0
86600: PPUSH
86601: CALL_OW 109
// solds := solds diff i ;
86605: LD_ADDR_VAR 0 2
86609: PUSH
86610: LD_VAR 0 2
86614: PUSH
86615: LD_VAR 0 7
86619: DIFF
86620: ST_TO_ADDR
// continue ;
86621: GO 86303
// end ; end ;
86623: GO 86303
86625: POP
86626: POP
// until not solds or not enemy ;
86627: LD_VAR 0 2
86631: NOT
86632: PUSH
86633: LD_VAR 0 4
86637: NOT
86638: OR
86639: IFFALSE 86207
// MC_Reset ( base , 18 ) ;
86641: LD_VAR 0 1
86645: PPUSH
86646: LD_INT 18
86648: PPUSH
86649: CALL 54713 0 2
// end ;
86653: LD_VAR 0 3
86657: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
86658: LD_INT 0
86660: PPUSH
86661: PPUSH
86662: PPUSH
86663: PPUSH
86664: PPUSH
86665: PPUSH
86666: PPUSH
86667: PPUSH
86668: PPUSH
86669: PPUSH
86670: PPUSH
86671: PPUSH
86672: PPUSH
86673: PPUSH
86674: PPUSH
86675: PPUSH
86676: PPUSH
86677: PPUSH
86678: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
86679: LD_ADDR_VAR 0 12
86683: PUSH
86684: LD_EXP 23
86688: PUSH
86689: LD_VAR 0 1
86693: ARRAY
86694: PPUSH
86695: LD_INT 25
86697: PUSH
86698: LD_INT 3
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PPUSH
86705: CALL_OW 72
86709: ST_TO_ADDR
// if mc_remote_driver [ base ] then
86710: LD_EXP 63
86714: PUSH
86715: LD_VAR 0 1
86719: ARRAY
86720: IFFALSE 86744
// mechs := mechs diff mc_remote_driver [ base ] ;
86722: LD_ADDR_VAR 0 12
86726: PUSH
86727: LD_VAR 0 12
86731: PUSH
86732: LD_EXP 63
86736: PUSH
86737: LD_VAR 0 1
86741: ARRAY
86742: DIFF
86743: ST_TO_ADDR
// for i in mechs do
86744: LD_ADDR_VAR 0 4
86748: PUSH
86749: LD_VAR 0 12
86753: PUSH
86754: FOR_IN
86755: IFFALSE 86790
// if GetTag ( i ) > 0 then
86757: LD_VAR 0 4
86761: PPUSH
86762: CALL_OW 110
86766: PUSH
86767: LD_INT 0
86769: GREATER
86770: IFFALSE 86788
// mechs := mechs diff i ;
86772: LD_ADDR_VAR 0 12
86776: PUSH
86777: LD_VAR 0 12
86781: PUSH
86782: LD_VAR 0 4
86786: DIFF
86787: ST_TO_ADDR
86788: GO 86754
86790: POP
86791: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
86792: LD_ADDR_VAR 0 8
86796: PUSH
86797: LD_EXP 23
86801: PUSH
86802: LD_VAR 0 1
86806: ARRAY
86807: PPUSH
86808: LD_INT 2
86810: PUSH
86811: LD_INT 25
86813: PUSH
86814: LD_INT 1
86816: PUSH
86817: EMPTY
86818: LIST
86819: LIST
86820: PUSH
86821: LD_INT 25
86823: PUSH
86824: LD_INT 5
86826: PUSH
86827: EMPTY
86828: LIST
86829: LIST
86830: PUSH
86831: LD_INT 25
86833: PUSH
86834: LD_INT 8
86836: PUSH
86837: EMPTY
86838: LIST
86839: LIST
86840: PUSH
86841: LD_INT 25
86843: PUSH
86844: LD_INT 9
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: PUSH
86851: EMPTY
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: PPUSH
86858: CALL_OW 72
86862: ST_TO_ADDR
// if not defenders and not solds then
86863: LD_VAR 0 2
86867: NOT
86868: PUSH
86869: LD_VAR 0 8
86873: NOT
86874: AND
86875: IFFALSE 86879
// exit ;
86877: GO 88649
// depot_under_attack := false ;
86879: LD_ADDR_VAR 0 16
86883: PUSH
86884: LD_INT 0
86886: ST_TO_ADDR
// sold_defenders := [ ] ;
86887: LD_ADDR_VAR 0 17
86891: PUSH
86892: EMPTY
86893: ST_TO_ADDR
// if mechs then
86894: LD_VAR 0 12
86898: IFFALSE 87051
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
86900: LD_ADDR_VAR 0 4
86904: PUSH
86905: LD_VAR 0 2
86909: PPUSH
86910: LD_INT 21
86912: PUSH
86913: LD_INT 2
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PPUSH
86920: CALL_OW 72
86924: PUSH
86925: FOR_IN
86926: IFFALSE 87049
// begin if GetTag ( i ) <> 20 then
86928: LD_VAR 0 4
86932: PPUSH
86933: CALL_OW 110
86937: PUSH
86938: LD_INT 20
86940: NONEQUAL
86941: IFFALSE 86955
// SetTag ( i , 20 ) ;
86943: LD_VAR 0 4
86947: PPUSH
86948: LD_INT 20
86950: PPUSH
86951: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
86955: LD_VAR 0 4
86959: PPUSH
86960: CALL_OW 263
86964: PUSH
86965: LD_INT 1
86967: EQUAL
86968: PUSH
86969: LD_VAR 0 4
86973: PPUSH
86974: CALL_OW 311
86978: NOT
86979: AND
86980: IFFALSE 87047
// begin un := mechs [ 1 ] ;
86982: LD_ADDR_VAR 0 10
86986: PUSH
86987: LD_VAR 0 12
86991: PUSH
86992: LD_INT 1
86994: ARRAY
86995: ST_TO_ADDR
// ComExit ( un ) ;
86996: LD_VAR 0 10
87000: PPUSH
87001: CALL 48129 0 1
// AddComEnterUnit ( un , i ) ;
87005: LD_VAR 0 10
87009: PPUSH
87010: LD_VAR 0 4
87014: PPUSH
87015: CALL_OW 180
// SetTag ( un , 19 ) ;
87019: LD_VAR 0 10
87023: PPUSH
87024: LD_INT 19
87026: PPUSH
87027: CALL_OW 109
// mechs := mechs diff un ;
87031: LD_ADDR_VAR 0 12
87035: PUSH
87036: LD_VAR 0 12
87040: PUSH
87041: LD_VAR 0 10
87045: DIFF
87046: ST_TO_ADDR
// end ; end ;
87047: GO 86925
87049: POP
87050: POP
// if solds then
87051: LD_VAR 0 8
87055: IFFALSE 87114
// for i in solds do
87057: LD_ADDR_VAR 0 4
87061: PUSH
87062: LD_VAR 0 8
87066: PUSH
87067: FOR_IN
87068: IFFALSE 87112
// if not GetTag ( i ) then
87070: LD_VAR 0 4
87074: PPUSH
87075: CALL_OW 110
87079: NOT
87080: IFFALSE 87110
// begin defenders := defenders union i ;
87082: LD_ADDR_VAR 0 2
87086: PUSH
87087: LD_VAR 0 2
87091: PUSH
87092: LD_VAR 0 4
87096: UNION
87097: ST_TO_ADDR
// SetTag ( i , 18 ) ;
87098: LD_VAR 0 4
87102: PPUSH
87103: LD_INT 18
87105: PPUSH
87106: CALL_OW 109
// end ;
87110: GO 87067
87112: POP
87113: POP
// repeat wait ( 0 0$2 ) ;
87114: LD_INT 70
87116: PPUSH
87117: CALL_OW 67
// enemy := mc_scan [ base ] ;
87121: LD_ADDR_VAR 0 21
87125: PUSH
87126: LD_EXP 46
87130: PUSH
87131: LD_VAR 0 1
87135: ARRAY
87136: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
87137: LD_EXP 23
87141: PUSH
87142: LD_VAR 0 1
87146: ARRAY
87147: NOT
87148: PUSH
87149: LD_EXP 23
87153: PUSH
87154: LD_VAR 0 1
87158: ARRAY
87159: PUSH
87160: EMPTY
87161: EQUAL
87162: OR
87163: IFFALSE 87200
// begin for i in defenders do
87165: LD_ADDR_VAR 0 4
87169: PUSH
87170: LD_VAR 0 2
87174: PUSH
87175: FOR_IN
87176: IFFALSE 87189
// ComStop ( i ) ;
87178: LD_VAR 0 4
87182: PPUSH
87183: CALL_OW 141
87187: GO 87175
87189: POP
87190: POP
// defenders := [ ] ;
87191: LD_ADDR_VAR 0 2
87195: PUSH
87196: EMPTY
87197: ST_TO_ADDR
// exit ;
87198: GO 88649
// end ; for i in defenders do
87200: LD_ADDR_VAR 0 4
87204: PUSH
87205: LD_VAR 0 2
87209: PUSH
87210: FOR_IN
87211: IFFALSE 88109
// begin e := NearestUnitToUnit ( enemy , i ) ;
87213: LD_ADDR_VAR 0 13
87217: PUSH
87218: LD_VAR 0 21
87222: PPUSH
87223: LD_VAR 0 4
87227: PPUSH
87228: CALL_OW 74
87232: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87233: LD_ADDR_VAR 0 7
87237: PUSH
87238: LD_EXP 23
87242: PUSH
87243: LD_VAR 0 1
87247: ARRAY
87248: PPUSH
87249: LD_INT 2
87251: PUSH
87252: LD_INT 30
87254: PUSH
87255: LD_INT 0
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 30
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: LIST
87276: PPUSH
87277: CALL_OW 72
87281: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
87282: LD_ADDR_VAR 0 16
87286: PUSH
87287: LD_VAR 0 7
87291: NOT
87292: PUSH
87293: LD_VAR 0 7
87297: PPUSH
87298: LD_INT 3
87300: PUSH
87301: LD_INT 24
87303: PUSH
87304: LD_INT 600
87306: PUSH
87307: EMPTY
87308: LIST
87309: LIST
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: PPUSH
87315: CALL_OW 72
87319: OR
87320: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
87321: LD_VAR 0 4
87325: PPUSH
87326: CALL_OW 247
87330: PUSH
87331: LD_INT 2
87333: DOUBLE
87334: EQUAL
87335: IFTRUE 87339
87337: GO 87735
87339: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
87340: LD_VAR 0 4
87344: PPUSH
87345: CALL_OW 256
87349: PUSH
87350: LD_INT 1000
87352: EQUAL
87353: PUSH
87354: LD_VAR 0 4
87358: PPUSH
87359: LD_VAR 0 13
87363: PPUSH
87364: CALL_OW 296
87368: PUSH
87369: LD_INT 40
87371: LESS
87372: PUSH
87373: LD_VAR 0 13
87377: PPUSH
87378: LD_EXP 48
87382: PUSH
87383: LD_VAR 0 1
87387: ARRAY
87388: PPUSH
87389: CALL_OW 308
87393: OR
87394: AND
87395: IFFALSE 87517
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
87397: LD_VAR 0 4
87401: PPUSH
87402: CALL_OW 262
87406: PUSH
87407: LD_INT 1
87409: EQUAL
87410: PUSH
87411: LD_VAR 0 4
87415: PPUSH
87416: CALL_OW 261
87420: PUSH
87421: LD_INT 30
87423: LESS
87424: AND
87425: PUSH
87426: LD_VAR 0 7
87430: AND
87431: IFFALSE 87501
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
87433: LD_VAR 0 4
87437: PPUSH
87438: LD_VAR 0 7
87442: PPUSH
87443: LD_VAR 0 4
87447: PPUSH
87448: CALL_OW 74
87452: PPUSH
87453: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
87457: LD_VAR 0 4
87461: PPUSH
87462: LD_VAR 0 7
87466: PPUSH
87467: LD_VAR 0 4
87471: PPUSH
87472: CALL_OW 74
87476: PPUSH
87477: CALL_OW 296
87481: PUSH
87482: LD_INT 6
87484: LESS
87485: IFFALSE 87499
// SetFuel ( i , 100 ) ;
87487: LD_VAR 0 4
87491: PPUSH
87492: LD_INT 100
87494: PPUSH
87495: CALL_OW 240
// end else
87499: GO 87515
// ComAttackUnit ( i , e ) ;
87501: LD_VAR 0 4
87505: PPUSH
87506: LD_VAR 0 13
87510: PPUSH
87511: CALL_OW 115
// end else
87515: GO 87618
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
87517: LD_VAR 0 13
87521: PPUSH
87522: LD_EXP 48
87526: PUSH
87527: LD_VAR 0 1
87531: ARRAY
87532: PPUSH
87533: CALL_OW 308
87537: NOT
87538: PUSH
87539: LD_VAR 0 4
87543: PPUSH
87544: LD_VAR 0 13
87548: PPUSH
87549: CALL_OW 296
87553: PUSH
87554: LD_INT 40
87556: GREATEREQUAL
87557: AND
87558: PUSH
87559: LD_VAR 0 4
87563: PPUSH
87564: CALL_OW 256
87568: PUSH
87569: LD_INT 650
87571: LESSEQUAL
87572: OR
87573: PUSH
87574: LD_VAR 0 4
87578: PPUSH
87579: LD_EXP 47
87583: PUSH
87584: LD_VAR 0 1
87588: ARRAY
87589: PPUSH
87590: CALL_OW 308
87594: NOT
87595: AND
87596: IFFALSE 87618
// ComMoveToArea ( i , mc_parking [ base ] ) ;
87598: LD_VAR 0 4
87602: PPUSH
87603: LD_EXP 47
87607: PUSH
87608: LD_VAR 0 1
87612: ARRAY
87613: PPUSH
87614: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
87618: LD_VAR 0 4
87622: PPUSH
87623: CALL_OW 256
87627: PUSH
87628: LD_INT 1000
87630: LESS
87631: PUSH
87632: LD_VAR 0 4
87636: PPUSH
87637: CALL_OW 263
87641: PUSH
87642: LD_INT 1
87644: EQUAL
87645: AND
87646: PUSH
87647: LD_VAR 0 4
87651: PPUSH
87652: CALL_OW 311
87656: AND
87657: PUSH
87658: LD_VAR 0 4
87662: PPUSH
87663: LD_EXP 47
87667: PUSH
87668: LD_VAR 0 1
87672: ARRAY
87673: PPUSH
87674: CALL_OW 308
87678: AND
87679: IFFALSE 87733
// begin mech := IsDrivenBy ( i ) ;
87681: LD_ADDR_VAR 0 9
87685: PUSH
87686: LD_VAR 0 4
87690: PPUSH
87691: CALL_OW 311
87695: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
87696: LD_VAR 0 9
87700: PPUSH
87701: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
87705: LD_VAR 0 9
87709: PPUSH
87710: LD_VAR 0 4
87714: PPUSH
87715: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
87719: LD_VAR 0 9
87723: PPUSH
87724: LD_VAR 0 4
87728: PPUSH
87729: CALL_OW 180
// end ; end ; unit_human :
87733: GO 88080
87735: LD_INT 1
87737: DOUBLE
87738: EQUAL
87739: IFTRUE 87743
87741: GO 88079
87743: POP
// begin b := IsInUnit ( i ) ;
87744: LD_ADDR_VAR 0 18
87748: PUSH
87749: LD_VAR 0 4
87753: PPUSH
87754: CALL_OW 310
87758: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
87759: LD_ADDR_VAR 0 19
87763: PUSH
87764: LD_VAR 0 18
87768: NOT
87769: PUSH
87770: LD_VAR 0 18
87774: PPUSH
87775: CALL_OW 266
87779: PUSH
87780: LD_INT 32
87782: PUSH
87783: LD_INT 31
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: IN
87790: OR
87791: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
87792: LD_VAR 0 18
87796: PPUSH
87797: CALL_OW 266
87801: PUSH
87802: LD_INT 5
87804: EQUAL
87805: PUSH
87806: LD_VAR 0 4
87810: PPUSH
87811: CALL_OW 257
87815: PUSH
87816: LD_INT 1
87818: PUSH
87819: LD_INT 2
87821: PUSH
87822: LD_INT 3
87824: PUSH
87825: LD_INT 4
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: IN
87834: AND
87835: IFFALSE 87872
// begin class := AllowSpecClass ( i ) ;
87837: LD_ADDR_VAR 0 20
87841: PUSH
87842: LD_VAR 0 4
87846: PPUSH
87847: CALL 12790 0 1
87851: ST_TO_ADDR
// if class then
87852: LD_VAR 0 20
87856: IFFALSE 87872
// ComChangeProfession ( i , class ) ;
87858: LD_VAR 0 4
87862: PPUSH
87863: LD_VAR 0 20
87867: PPUSH
87868: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
87872: LD_VAR 0 16
87876: PUSH
87877: LD_VAR 0 2
87881: PPUSH
87882: LD_INT 21
87884: PUSH
87885: LD_INT 2
87887: PUSH
87888: EMPTY
87889: LIST
87890: LIST
87891: PPUSH
87892: CALL_OW 72
87896: PUSH
87897: LD_INT 1
87899: LESSEQUAL
87900: OR
87901: PUSH
87902: LD_VAR 0 19
87906: AND
87907: PUSH
87908: LD_VAR 0 4
87912: PUSH
87913: LD_VAR 0 17
87917: IN
87918: NOT
87919: AND
87920: IFFALSE 88013
// begin if b then
87922: LD_VAR 0 18
87926: IFFALSE 87975
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
87928: LD_VAR 0 18
87932: PPUSH
87933: LD_VAR 0 21
87937: PPUSH
87938: LD_VAR 0 18
87942: PPUSH
87943: CALL_OW 74
87947: PPUSH
87948: CALL_OW 296
87952: PUSH
87953: LD_INT 10
87955: LESS
87956: PUSH
87957: LD_VAR 0 18
87961: PPUSH
87962: CALL_OW 461
87966: PUSH
87967: LD_INT 7
87969: NONEQUAL
87970: AND
87971: IFFALSE 87975
// continue ;
87973: GO 87210
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
87975: LD_ADDR_VAR 0 17
87979: PUSH
87980: LD_VAR 0 17
87984: PPUSH
87985: LD_VAR 0 17
87989: PUSH
87990: LD_INT 1
87992: PLUS
87993: PPUSH
87994: LD_VAR 0 4
87998: PPUSH
87999: CALL_OW 1
88003: ST_TO_ADDR
// ComExitBuilding ( i ) ;
88004: LD_VAR 0 4
88008: PPUSH
88009: CALL_OW 122
// end ; if sold_defenders then
88013: LD_VAR 0 17
88017: IFFALSE 88077
// if i in sold_defenders then
88019: LD_VAR 0 4
88023: PUSH
88024: LD_VAR 0 17
88028: IN
88029: IFFALSE 88077
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
88031: LD_VAR 0 4
88035: PPUSH
88036: CALL_OW 314
88040: NOT
88041: PUSH
88042: LD_VAR 0 4
88046: PPUSH
88047: LD_VAR 0 13
88051: PPUSH
88052: CALL_OW 296
88056: PUSH
88057: LD_INT 30
88059: LESS
88060: AND
88061: IFFALSE 88077
// ComAttackUnit ( i , e ) ;
88063: LD_VAR 0 4
88067: PPUSH
88068: LD_VAR 0 13
88072: PPUSH
88073: CALL_OW 115
// end ; end ; end ;
88077: GO 88080
88079: POP
// if IsDead ( i ) then
88080: LD_VAR 0 4
88084: PPUSH
88085: CALL_OW 301
88089: IFFALSE 88107
// defenders := defenders diff i ;
88091: LD_ADDR_VAR 0 2
88095: PUSH
88096: LD_VAR 0 2
88100: PUSH
88101: LD_VAR 0 4
88105: DIFF
88106: ST_TO_ADDR
// end ;
88107: GO 87210
88109: POP
88110: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
88111: LD_VAR 0 21
88115: NOT
88116: PUSH
88117: LD_VAR 0 2
88121: NOT
88122: OR
88123: PUSH
88124: LD_EXP 23
88128: PUSH
88129: LD_VAR 0 1
88133: ARRAY
88134: NOT
88135: OR
88136: IFFALSE 87114
// MC_Reset ( base , 18 ) ;
88138: LD_VAR 0 1
88142: PPUSH
88143: LD_INT 18
88145: PPUSH
88146: CALL 54713 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
88150: LD_ADDR_VAR 0 2
88154: PUSH
88155: LD_VAR 0 2
88159: PUSH
88160: LD_VAR 0 2
88164: PPUSH
88165: LD_INT 2
88167: PUSH
88168: LD_INT 25
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: EMPTY
88175: LIST
88176: LIST
88177: PUSH
88178: LD_INT 25
88180: PUSH
88181: LD_INT 5
88183: PUSH
88184: EMPTY
88185: LIST
88186: LIST
88187: PUSH
88188: LD_INT 25
88190: PUSH
88191: LD_INT 8
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 25
88200: PUSH
88201: LD_INT 9
88203: PUSH
88204: EMPTY
88205: LIST
88206: LIST
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: PPUSH
88215: CALL_OW 72
88219: DIFF
88220: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
88221: LD_VAR 0 21
88225: NOT
88226: PUSH
88227: LD_VAR 0 2
88231: PPUSH
88232: LD_INT 21
88234: PUSH
88235: LD_INT 2
88237: PUSH
88238: EMPTY
88239: LIST
88240: LIST
88241: PPUSH
88242: CALL_OW 72
88246: AND
88247: IFFALSE 88585
// begin tmp := FilterByTag ( defenders , 19 ) ;
88249: LD_ADDR_VAR 0 11
88253: PUSH
88254: LD_VAR 0 2
88258: PPUSH
88259: LD_INT 19
88261: PPUSH
88262: CALL 45259 0 2
88266: ST_TO_ADDR
// if tmp then
88267: LD_VAR 0 11
88271: IFFALSE 88341
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
88273: LD_ADDR_VAR 0 11
88277: PUSH
88278: LD_VAR 0 11
88282: PPUSH
88283: LD_INT 25
88285: PUSH
88286: LD_INT 3
88288: PUSH
88289: EMPTY
88290: LIST
88291: LIST
88292: PPUSH
88293: CALL_OW 72
88297: ST_TO_ADDR
// if tmp then
88298: LD_VAR 0 11
88302: IFFALSE 88341
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
88304: LD_ADDR_EXP 35
88308: PUSH
88309: LD_EXP 35
88313: PPUSH
88314: LD_VAR 0 1
88318: PPUSH
88319: LD_EXP 35
88323: PUSH
88324: LD_VAR 0 1
88328: ARRAY
88329: PUSH
88330: LD_VAR 0 11
88334: UNION
88335: PPUSH
88336: CALL_OW 1
88340: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
88341: LD_VAR 0 1
88345: PPUSH
88346: LD_INT 19
88348: PPUSH
88349: CALL 54713 0 2
// repeat wait ( 0 0$1 ) ;
88353: LD_INT 35
88355: PPUSH
88356: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
88360: LD_EXP 23
88364: PUSH
88365: LD_VAR 0 1
88369: ARRAY
88370: NOT
88371: PUSH
88372: LD_EXP 23
88376: PUSH
88377: LD_VAR 0 1
88381: ARRAY
88382: PUSH
88383: EMPTY
88384: EQUAL
88385: OR
88386: IFFALSE 88423
// begin for i in defenders do
88388: LD_ADDR_VAR 0 4
88392: PUSH
88393: LD_VAR 0 2
88397: PUSH
88398: FOR_IN
88399: IFFALSE 88412
// ComStop ( i ) ;
88401: LD_VAR 0 4
88405: PPUSH
88406: CALL_OW 141
88410: GO 88398
88412: POP
88413: POP
// defenders := [ ] ;
88414: LD_ADDR_VAR 0 2
88418: PUSH
88419: EMPTY
88420: ST_TO_ADDR
// exit ;
88421: GO 88649
// end ; for i in defenders do
88423: LD_ADDR_VAR 0 4
88427: PUSH
88428: LD_VAR 0 2
88432: PUSH
88433: FOR_IN
88434: IFFALSE 88523
// begin if not IsInArea ( i , mc_parking [ base ] ) then
88436: LD_VAR 0 4
88440: PPUSH
88441: LD_EXP 47
88445: PUSH
88446: LD_VAR 0 1
88450: ARRAY
88451: PPUSH
88452: CALL_OW 308
88456: NOT
88457: IFFALSE 88481
// ComMoveToArea ( i , mc_parking [ base ] ) else
88459: LD_VAR 0 4
88463: PPUSH
88464: LD_EXP 47
88468: PUSH
88469: LD_VAR 0 1
88473: ARRAY
88474: PPUSH
88475: CALL_OW 113
88479: GO 88521
// if GetControl ( i ) = control_manual then
88481: LD_VAR 0 4
88485: PPUSH
88486: CALL_OW 263
88490: PUSH
88491: LD_INT 1
88493: EQUAL
88494: IFFALSE 88521
// if IsDrivenBy ( i ) then
88496: LD_VAR 0 4
88500: PPUSH
88501: CALL_OW 311
88505: IFFALSE 88521
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
88507: LD_VAR 0 4
88511: PPUSH
88512: CALL_OW 311
88516: PPUSH
88517: CALL_OW 121
// end ;
88521: GO 88433
88523: POP
88524: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
88525: LD_VAR 0 2
88529: PPUSH
88530: LD_INT 95
88532: PUSH
88533: LD_EXP 47
88537: PUSH
88538: LD_VAR 0 1
88542: ARRAY
88543: PUSH
88544: EMPTY
88545: LIST
88546: LIST
88547: PPUSH
88548: CALL_OW 72
88552: PUSH
88553: LD_VAR 0 2
88557: EQUAL
88558: PUSH
88559: LD_EXP 46
88563: PUSH
88564: LD_VAR 0 1
88568: ARRAY
88569: OR
88570: PUSH
88571: LD_EXP 23
88575: PUSH
88576: LD_VAR 0 1
88580: ARRAY
88581: NOT
88582: OR
88583: IFFALSE 88353
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
88585: LD_ADDR_EXP 45
88589: PUSH
88590: LD_EXP 45
88594: PPUSH
88595: LD_VAR 0 1
88599: PPUSH
88600: LD_VAR 0 2
88604: PPUSH
88605: LD_INT 21
88607: PUSH
88608: LD_INT 2
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: PPUSH
88615: CALL_OW 72
88619: PPUSH
88620: CALL_OW 1
88624: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
88625: LD_VAR 0 1
88629: PPUSH
88630: LD_INT 19
88632: PPUSH
88633: CALL 54713 0 2
// MC_Reset ( base , 20 ) ;
88637: LD_VAR 0 1
88641: PPUSH
88642: LD_INT 20
88644: PPUSH
88645: CALL 54713 0 2
// end ; end_of_file
88649: LD_VAR 0 3
88653: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
88654: LD_INT 0
88656: PPUSH
88657: PPUSH
88658: PPUSH
88659: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
88660: LD_VAR 0 1
88664: PPUSH
88665: CALL_OW 264
88669: PUSH
88670: LD_EXP 71
88674: EQUAL
88675: IFFALSE 88747
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
88677: LD_INT 68
88679: PPUSH
88680: LD_VAR 0 1
88684: PPUSH
88685: CALL_OW 255
88689: PPUSH
88690: CALL_OW 321
88694: PUSH
88695: LD_INT 2
88697: EQUAL
88698: IFFALSE 88710
// eff := 70 else
88700: LD_ADDR_VAR 0 4
88704: PUSH
88705: LD_INT 70
88707: ST_TO_ADDR
88708: GO 88718
// eff := 30 ;
88710: LD_ADDR_VAR 0 4
88714: PUSH
88715: LD_INT 30
88717: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
88718: LD_VAR 0 1
88722: PPUSH
88723: CALL_OW 250
88727: PPUSH
88728: LD_VAR 0 1
88732: PPUSH
88733: CALL_OW 251
88737: PPUSH
88738: LD_VAR 0 4
88742: PPUSH
88743: CALL_OW 495
// end ; end ;
88747: LD_VAR 0 2
88751: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
88752: LD_INT 0
88754: PPUSH
// end ;
88755: LD_VAR 0 4
88759: RET
// export function SOS_Command ( cmd ) ; begin
88760: LD_INT 0
88762: PPUSH
// end ;
88763: LD_VAR 0 2
88767: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
88768: LD_INT 0
88770: PPUSH
// end ;
88771: LD_VAR 0 6
88775: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
88776: LD_INT 0
88778: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
88779: LD_VAR 0 1
88783: PUSH
88784: LD_INT 250
88786: EQUAL
88787: PUSH
88788: LD_VAR 0 2
88792: PPUSH
88793: CALL_OW 264
88797: PUSH
88798: LD_EXP 74
88802: EQUAL
88803: AND
88804: IFFALSE 88825
// MinerPlaceMine ( unit , x , y ) ;
88806: LD_VAR 0 2
88810: PPUSH
88811: LD_VAR 0 4
88815: PPUSH
88816: LD_VAR 0 5
88820: PPUSH
88821: CALL 91174 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
88825: LD_VAR 0 1
88829: PUSH
88830: LD_INT 251
88832: EQUAL
88833: PUSH
88834: LD_VAR 0 2
88838: PPUSH
88839: CALL_OW 264
88843: PUSH
88844: LD_EXP 74
88848: EQUAL
88849: AND
88850: IFFALSE 88871
// MinerDetonateMine ( unit , x , y ) ;
88852: LD_VAR 0 2
88856: PPUSH
88857: LD_VAR 0 4
88861: PPUSH
88862: LD_VAR 0 5
88866: PPUSH
88867: CALL 91451 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
88871: LD_VAR 0 1
88875: PUSH
88876: LD_INT 252
88878: EQUAL
88879: PUSH
88880: LD_VAR 0 2
88884: PPUSH
88885: CALL_OW 264
88889: PUSH
88890: LD_EXP 74
88894: EQUAL
88895: AND
88896: IFFALSE 88917
// MinerCreateMinefield ( unit , x , y ) ;
88898: LD_VAR 0 2
88902: PPUSH
88903: LD_VAR 0 4
88907: PPUSH
88908: LD_VAR 0 5
88912: PPUSH
88913: CALL 91868 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
88917: LD_VAR 0 1
88921: PUSH
88922: LD_INT 253
88924: EQUAL
88925: PUSH
88926: LD_VAR 0 2
88930: PPUSH
88931: CALL_OW 257
88935: PUSH
88936: LD_INT 5
88938: EQUAL
88939: AND
88940: IFFALSE 88961
// ComBinocular ( unit , x , y ) ;
88942: LD_VAR 0 2
88946: PPUSH
88947: LD_VAR 0 4
88951: PPUSH
88952: LD_VAR 0 5
88956: PPUSH
88957: CALL 92239 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
88961: LD_VAR 0 1
88965: PUSH
88966: LD_INT 254
88968: EQUAL
88969: PUSH
88970: LD_VAR 0 2
88974: PPUSH
88975: CALL_OW 264
88979: PUSH
88980: LD_EXP 69
88984: EQUAL
88985: AND
88986: PUSH
88987: LD_VAR 0 3
88991: PPUSH
88992: CALL_OW 263
88996: PUSH
88997: LD_INT 3
88999: EQUAL
89000: AND
89001: IFFALSE 89017
// HackDestroyVehicle ( unit , selectedUnit ) ;
89003: LD_VAR 0 2
89007: PPUSH
89008: LD_VAR 0 3
89012: PPUSH
89013: CALL 90534 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
89017: LD_VAR 0 1
89021: PUSH
89022: LD_INT 255
89024: EQUAL
89025: PUSH
89026: LD_VAR 0 2
89030: PPUSH
89031: CALL_OW 264
89035: PUSH
89036: LD_INT 14
89038: PUSH
89039: LD_INT 53
89041: PUSH
89042: EMPTY
89043: LIST
89044: LIST
89045: IN
89046: AND
89047: PUSH
89048: LD_VAR 0 4
89052: PPUSH
89053: LD_VAR 0 5
89057: PPUSH
89058: CALL_OW 488
89062: AND
89063: IFFALSE 89087
// CutTreeXYR ( unit , x , y , 12 ) ;
89065: LD_VAR 0 2
89069: PPUSH
89070: LD_VAR 0 4
89074: PPUSH
89075: LD_VAR 0 5
89079: PPUSH
89080: LD_INT 12
89082: PPUSH
89083: CALL 89100 0 4
// end ;
89087: LD_VAR 0 6
89091: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
89092: LD_INT 0
89094: PPUSH
// end ;
89095: LD_VAR 0 4
89099: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
89100: LD_INT 0
89102: PPUSH
89103: PPUSH
89104: PPUSH
89105: PPUSH
89106: PPUSH
89107: PPUSH
89108: PPUSH
89109: PPUSH
89110: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
89111: LD_VAR 0 1
89115: NOT
89116: PUSH
89117: LD_VAR 0 2
89121: PPUSH
89122: LD_VAR 0 3
89126: PPUSH
89127: CALL_OW 488
89131: NOT
89132: OR
89133: PUSH
89134: LD_VAR 0 4
89138: NOT
89139: OR
89140: IFFALSE 89144
// exit ;
89142: GO 89484
// list := [ ] ;
89144: LD_ADDR_VAR 0 13
89148: PUSH
89149: EMPTY
89150: ST_TO_ADDR
// if x - r < 0 then
89151: LD_VAR 0 2
89155: PUSH
89156: LD_VAR 0 4
89160: MINUS
89161: PUSH
89162: LD_INT 0
89164: LESS
89165: IFFALSE 89177
// min_x := 0 else
89167: LD_ADDR_VAR 0 7
89171: PUSH
89172: LD_INT 0
89174: ST_TO_ADDR
89175: GO 89193
// min_x := x - r ;
89177: LD_ADDR_VAR 0 7
89181: PUSH
89182: LD_VAR 0 2
89186: PUSH
89187: LD_VAR 0 4
89191: MINUS
89192: ST_TO_ADDR
// if y - r < 0 then
89193: LD_VAR 0 3
89197: PUSH
89198: LD_VAR 0 4
89202: MINUS
89203: PUSH
89204: LD_INT 0
89206: LESS
89207: IFFALSE 89219
// min_y := 0 else
89209: LD_ADDR_VAR 0 8
89213: PUSH
89214: LD_INT 0
89216: ST_TO_ADDR
89217: GO 89235
// min_y := y - r ;
89219: LD_ADDR_VAR 0 8
89223: PUSH
89224: LD_VAR 0 3
89228: PUSH
89229: LD_VAR 0 4
89233: MINUS
89234: ST_TO_ADDR
// max_x := x + r ;
89235: LD_ADDR_VAR 0 9
89239: PUSH
89240: LD_VAR 0 2
89244: PUSH
89245: LD_VAR 0 4
89249: PLUS
89250: ST_TO_ADDR
// max_y := y + r ;
89251: LD_ADDR_VAR 0 10
89255: PUSH
89256: LD_VAR 0 3
89260: PUSH
89261: LD_VAR 0 4
89265: PLUS
89266: ST_TO_ADDR
// for _x = min_x to max_x do
89267: LD_ADDR_VAR 0 11
89271: PUSH
89272: DOUBLE
89273: LD_VAR 0 7
89277: DEC
89278: ST_TO_ADDR
89279: LD_VAR 0 9
89283: PUSH
89284: FOR_TO
89285: IFFALSE 89402
// for _y = min_y to max_y do
89287: LD_ADDR_VAR 0 12
89291: PUSH
89292: DOUBLE
89293: LD_VAR 0 8
89297: DEC
89298: ST_TO_ADDR
89299: LD_VAR 0 10
89303: PUSH
89304: FOR_TO
89305: IFFALSE 89398
// begin if not ValidHex ( _x , _y ) then
89307: LD_VAR 0 11
89311: PPUSH
89312: LD_VAR 0 12
89316: PPUSH
89317: CALL_OW 488
89321: NOT
89322: IFFALSE 89326
// continue ;
89324: GO 89304
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
89326: LD_VAR 0 11
89330: PPUSH
89331: LD_VAR 0 12
89335: PPUSH
89336: CALL_OW 351
89340: PUSH
89341: LD_VAR 0 11
89345: PPUSH
89346: LD_VAR 0 12
89350: PPUSH
89351: CALL_OW 554
89355: AND
89356: IFFALSE 89396
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
89358: LD_ADDR_VAR 0 13
89362: PUSH
89363: LD_VAR 0 13
89367: PPUSH
89368: LD_VAR 0 13
89372: PUSH
89373: LD_INT 1
89375: PLUS
89376: PPUSH
89377: LD_VAR 0 11
89381: PUSH
89382: LD_VAR 0 12
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PPUSH
89391: CALL_OW 2
89395: ST_TO_ADDR
// end ;
89396: GO 89304
89398: POP
89399: POP
89400: GO 89284
89402: POP
89403: POP
// if not list then
89404: LD_VAR 0 13
89408: NOT
89409: IFFALSE 89413
// exit ;
89411: GO 89484
// for i in list do
89413: LD_ADDR_VAR 0 6
89417: PUSH
89418: LD_VAR 0 13
89422: PUSH
89423: FOR_IN
89424: IFFALSE 89482
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
89426: LD_VAR 0 1
89430: PPUSH
89431: LD_STRING M
89433: PUSH
89434: LD_VAR 0 6
89438: PUSH
89439: LD_INT 1
89441: ARRAY
89442: PUSH
89443: LD_VAR 0 6
89447: PUSH
89448: LD_INT 2
89450: ARRAY
89451: PUSH
89452: LD_INT 0
89454: PUSH
89455: LD_INT 0
89457: PUSH
89458: LD_INT 0
89460: PUSH
89461: LD_INT 0
89463: PUSH
89464: EMPTY
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: PUSH
89473: EMPTY
89474: LIST
89475: PPUSH
89476: CALL_OW 447
89480: GO 89423
89482: POP
89483: POP
// end ;
89484: LD_VAR 0 5
89488: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
89489: LD_EXP 88
89493: NOT
89494: IFFALSE 89544
89496: GO 89498
89498: DISABLE
// begin initHack := true ;
89499: LD_ADDR_EXP 88
89503: PUSH
89504: LD_INT 1
89506: ST_TO_ADDR
// hackTanks := [ ] ;
89507: LD_ADDR_EXP 89
89511: PUSH
89512: EMPTY
89513: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
89514: LD_ADDR_EXP 90
89518: PUSH
89519: EMPTY
89520: ST_TO_ADDR
// hackLimit := 3 ;
89521: LD_ADDR_EXP 91
89525: PUSH
89526: LD_INT 3
89528: ST_TO_ADDR
// hackDist := 12 ;
89529: LD_ADDR_EXP 92
89533: PUSH
89534: LD_INT 12
89536: ST_TO_ADDR
// hackCounter := [ ] ;
89537: LD_ADDR_EXP 93
89541: PUSH
89542: EMPTY
89543: ST_TO_ADDR
// end ;
89544: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
89545: LD_EXP 88
89549: PUSH
89550: LD_INT 34
89552: PUSH
89553: LD_EXP 69
89557: PUSH
89558: EMPTY
89559: LIST
89560: LIST
89561: PPUSH
89562: CALL_OW 69
89566: AND
89567: IFFALSE 89822
89569: GO 89571
89571: DISABLE
89572: LD_INT 0
89574: PPUSH
89575: PPUSH
// begin enable ;
89576: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
89577: LD_ADDR_VAR 0 1
89581: PUSH
89582: LD_INT 34
89584: PUSH
89585: LD_EXP 69
89589: PUSH
89590: EMPTY
89591: LIST
89592: LIST
89593: PPUSH
89594: CALL_OW 69
89598: PUSH
89599: FOR_IN
89600: IFFALSE 89820
// begin if not i in hackTanks then
89602: LD_VAR 0 1
89606: PUSH
89607: LD_EXP 89
89611: IN
89612: NOT
89613: IFFALSE 89696
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
89615: LD_ADDR_EXP 89
89619: PUSH
89620: LD_EXP 89
89624: PPUSH
89625: LD_EXP 89
89629: PUSH
89630: LD_INT 1
89632: PLUS
89633: PPUSH
89634: LD_VAR 0 1
89638: PPUSH
89639: CALL_OW 1
89643: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
89644: LD_ADDR_EXP 90
89648: PUSH
89649: LD_EXP 90
89653: PPUSH
89654: LD_EXP 90
89658: PUSH
89659: LD_INT 1
89661: PLUS
89662: PPUSH
89663: EMPTY
89664: PPUSH
89665: CALL_OW 1
89669: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
89670: LD_ADDR_EXP 93
89674: PUSH
89675: LD_EXP 93
89679: PPUSH
89680: LD_EXP 93
89684: PUSH
89685: LD_INT 1
89687: PLUS
89688: PPUSH
89689: EMPTY
89690: PPUSH
89691: CALL_OW 1
89695: ST_TO_ADDR
// end ; if not IsOk ( i ) then
89696: LD_VAR 0 1
89700: PPUSH
89701: CALL_OW 302
89705: NOT
89706: IFFALSE 89719
// begin HackUnlinkAll ( i ) ;
89708: LD_VAR 0 1
89712: PPUSH
89713: CALL 89825 0 1
// continue ;
89717: GO 89599
// end ; HackCheckCapturedStatus ( i ) ;
89719: LD_VAR 0 1
89723: PPUSH
89724: CALL 90268 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
89728: LD_ADDR_VAR 0 2
89732: PUSH
89733: LD_INT 81
89735: PUSH
89736: LD_VAR 0 1
89740: PPUSH
89741: CALL_OW 255
89745: PUSH
89746: EMPTY
89747: LIST
89748: LIST
89749: PUSH
89750: LD_INT 33
89752: PUSH
89753: LD_INT 3
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PUSH
89760: LD_INT 91
89762: PUSH
89763: LD_VAR 0 1
89767: PUSH
89768: LD_EXP 92
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 50
89780: PUSH
89781: EMPTY
89782: LIST
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: PPUSH
89790: CALL_OW 69
89794: ST_TO_ADDR
// if not tmp then
89795: LD_VAR 0 2
89799: NOT
89800: IFFALSE 89804
// continue ;
89802: GO 89599
// HackLink ( i , tmp ) ;
89804: LD_VAR 0 1
89808: PPUSH
89809: LD_VAR 0 2
89813: PPUSH
89814: CALL 89961 0 2
// end ;
89818: GO 89599
89820: POP
89821: POP
// end ;
89822: PPOPN 2
89824: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
89825: LD_INT 0
89827: PPUSH
89828: PPUSH
89829: PPUSH
// if not hack in hackTanks then
89830: LD_VAR 0 1
89834: PUSH
89835: LD_EXP 89
89839: IN
89840: NOT
89841: IFFALSE 89845
// exit ;
89843: GO 89956
// index := GetElementIndex ( hackTanks , hack ) ;
89845: LD_ADDR_VAR 0 4
89849: PUSH
89850: LD_EXP 89
89854: PPUSH
89855: LD_VAR 0 1
89859: PPUSH
89860: CALL 15775 0 2
89864: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
89865: LD_EXP 90
89869: PUSH
89870: LD_VAR 0 4
89874: ARRAY
89875: IFFALSE 89956
// begin for i in hackTanksCaptured [ index ] do
89877: LD_ADDR_VAR 0 3
89881: PUSH
89882: LD_EXP 90
89886: PUSH
89887: LD_VAR 0 4
89891: ARRAY
89892: PUSH
89893: FOR_IN
89894: IFFALSE 89920
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
89896: LD_VAR 0 3
89900: PUSH
89901: LD_INT 1
89903: ARRAY
89904: PPUSH
89905: LD_VAR 0 3
89909: PUSH
89910: LD_INT 2
89912: ARRAY
89913: PPUSH
89914: CALL_OW 235
89918: GO 89893
89920: POP
89921: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
89922: LD_ADDR_EXP 90
89926: PUSH
89927: LD_EXP 90
89931: PPUSH
89932: LD_VAR 0 4
89936: PPUSH
89937: EMPTY
89938: PPUSH
89939: CALL_OW 1
89943: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
89944: LD_VAR 0 1
89948: PPUSH
89949: LD_INT 0
89951: PPUSH
89952: CALL_OW 505
// end ; end ;
89956: LD_VAR 0 2
89960: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
89961: LD_INT 0
89963: PPUSH
89964: PPUSH
89965: PPUSH
// if not hack in hackTanks or not vehicles then
89966: LD_VAR 0 1
89970: PUSH
89971: LD_EXP 89
89975: IN
89976: NOT
89977: PUSH
89978: LD_VAR 0 2
89982: NOT
89983: OR
89984: IFFALSE 89988
// exit ;
89986: GO 90263
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
89988: LD_ADDR_VAR 0 2
89992: PUSH
89993: LD_VAR 0 1
89997: PPUSH
89998: LD_VAR 0 2
90002: PPUSH
90003: LD_INT 1
90005: PPUSH
90006: LD_INT 1
90008: PPUSH
90009: CALL 16425 0 4
90013: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
90014: LD_ADDR_VAR 0 5
90018: PUSH
90019: LD_EXP 89
90023: PPUSH
90024: LD_VAR 0 1
90028: PPUSH
90029: CALL 15775 0 2
90033: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
90034: LD_EXP 90
90038: PUSH
90039: LD_VAR 0 5
90043: ARRAY
90044: PUSH
90045: LD_EXP 91
90049: LESS
90050: IFFALSE 90239
// begin for i := 1 to vehicles do
90052: LD_ADDR_VAR 0 4
90056: PUSH
90057: DOUBLE
90058: LD_INT 1
90060: DEC
90061: ST_TO_ADDR
90062: LD_VAR 0 2
90066: PUSH
90067: FOR_TO
90068: IFFALSE 90237
// begin if hackTanksCaptured [ index ] = hackLimit then
90070: LD_EXP 90
90074: PUSH
90075: LD_VAR 0 5
90079: ARRAY
90080: PUSH
90081: LD_EXP 91
90085: EQUAL
90086: IFFALSE 90090
// break ;
90088: GO 90237
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
90090: LD_ADDR_EXP 93
90094: PUSH
90095: LD_EXP 93
90099: PPUSH
90100: LD_VAR 0 5
90104: PPUSH
90105: LD_EXP 93
90109: PUSH
90110: LD_VAR 0 5
90114: ARRAY
90115: PUSH
90116: LD_INT 1
90118: PLUS
90119: PPUSH
90120: CALL_OW 1
90124: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
90125: LD_ADDR_EXP 90
90129: PUSH
90130: LD_EXP 90
90134: PPUSH
90135: LD_VAR 0 5
90139: PUSH
90140: LD_EXP 90
90144: PUSH
90145: LD_VAR 0 5
90149: ARRAY
90150: PUSH
90151: LD_INT 1
90153: PLUS
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PPUSH
90159: LD_VAR 0 2
90163: PUSH
90164: LD_VAR 0 4
90168: ARRAY
90169: PUSH
90170: LD_VAR 0 2
90174: PUSH
90175: LD_VAR 0 4
90179: ARRAY
90180: PPUSH
90181: CALL_OW 255
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PPUSH
90190: CALL 15990 0 3
90194: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
90195: LD_VAR 0 2
90199: PUSH
90200: LD_VAR 0 4
90204: ARRAY
90205: PPUSH
90206: LD_VAR 0 1
90210: PPUSH
90211: CALL_OW 255
90215: PPUSH
90216: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
90220: LD_VAR 0 2
90224: PUSH
90225: LD_VAR 0 4
90229: ARRAY
90230: PPUSH
90231: CALL_OW 141
// end ;
90235: GO 90067
90237: POP
90238: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90239: LD_VAR 0 1
90243: PPUSH
90244: LD_EXP 90
90248: PUSH
90249: LD_VAR 0 5
90253: ARRAY
90254: PUSH
90255: LD_INT 0
90257: PLUS
90258: PPUSH
90259: CALL_OW 505
// end ;
90263: LD_VAR 0 3
90267: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
90268: LD_INT 0
90270: PPUSH
90271: PPUSH
90272: PPUSH
90273: PPUSH
// if not hack in hackTanks then
90274: LD_VAR 0 1
90278: PUSH
90279: LD_EXP 89
90283: IN
90284: NOT
90285: IFFALSE 90289
// exit ;
90287: GO 90529
// index := GetElementIndex ( hackTanks , hack ) ;
90289: LD_ADDR_VAR 0 4
90293: PUSH
90294: LD_EXP 89
90298: PPUSH
90299: LD_VAR 0 1
90303: PPUSH
90304: CALL 15775 0 2
90308: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
90309: LD_ADDR_VAR 0 3
90313: PUSH
90314: DOUBLE
90315: LD_EXP 90
90319: PUSH
90320: LD_VAR 0 4
90324: ARRAY
90325: INC
90326: ST_TO_ADDR
90327: LD_INT 1
90329: PUSH
90330: FOR_DOWNTO
90331: IFFALSE 90503
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
90333: LD_ADDR_VAR 0 5
90337: PUSH
90338: LD_EXP 90
90342: PUSH
90343: LD_VAR 0 4
90347: ARRAY
90348: PUSH
90349: LD_VAR 0 3
90353: ARRAY
90354: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
90355: LD_VAR 0 5
90359: PUSH
90360: LD_INT 1
90362: ARRAY
90363: PPUSH
90364: CALL_OW 302
90368: NOT
90369: PUSH
90370: LD_VAR 0 5
90374: PUSH
90375: LD_INT 1
90377: ARRAY
90378: PPUSH
90379: CALL_OW 255
90383: PUSH
90384: LD_VAR 0 1
90388: PPUSH
90389: CALL_OW 255
90393: NONEQUAL
90394: OR
90395: IFFALSE 90501
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
90397: LD_VAR 0 5
90401: PUSH
90402: LD_INT 1
90404: ARRAY
90405: PPUSH
90406: CALL_OW 305
90410: PUSH
90411: LD_VAR 0 5
90415: PUSH
90416: LD_INT 1
90418: ARRAY
90419: PPUSH
90420: CALL_OW 255
90424: PUSH
90425: LD_VAR 0 1
90429: PPUSH
90430: CALL_OW 255
90434: EQUAL
90435: AND
90436: IFFALSE 90460
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
90438: LD_VAR 0 5
90442: PUSH
90443: LD_INT 1
90445: ARRAY
90446: PPUSH
90447: LD_VAR 0 5
90451: PUSH
90452: LD_INT 2
90454: ARRAY
90455: PPUSH
90456: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
90460: LD_ADDR_EXP 90
90464: PUSH
90465: LD_EXP 90
90469: PPUSH
90470: LD_VAR 0 4
90474: PPUSH
90475: LD_EXP 90
90479: PUSH
90480: LD_VAR 0 4
90484: ARRAY
90485: PPUSH
90486: LD_VAR 0 3
90490: PPUSH
90491: CALL_OW 3
90495: PPUSH
90496: CALL_OW 1
90500: ST_TO_ADDR
// end ; end ;
90501: GO 90330
90503: POP
90504: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
90505: LD_VAR 0 1
90509: PPUSH
90510: LD_EXP 90
90514: PUSH
90515: LD_VAR 0 4
90519: ARRAY
90520: PUSH
90521: LD_INT 0
90523: PLUS
90524: PPUSH
90525: CALL_OW 505
// end ;
90529: LD_VAR 0 2
90533: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
90534: LD_INT 0
90536: PPUSH
90537: PPUSH
90538: PPUSH
90539: PPUSH
// if not hack in hackTanks then
90540: LD_VAR 0 1
90544: PUSH
90545: LD_EXP 89
90549: IN
90550: NOT
90551: IFFALSE 90555
// exit ;
90553: GO 90640
// index := GetElementIndex ( hackTanks , hack ) ;
90555: LD_ADDR_VAR 0 5
90559: PUSH
90560: LD_EXP 89
90564: PPUSH
90565: LD_VAR 0 1
90569: PPUSH
90570: CALL 15775 0 2
90574: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
90575: LD_ADDR_VAR 0 4
90579: PUSH
90580: DOUBLE
90581: LD_INT 1
90583: DEC
90584: ST_TO_ADDR
90585: LD_EXP 90
90589: PUSH
90590: LD_VAR 0 5
90594: ARRAY
90595: PUSH
90596: FOR_TO
90597: IFFALSE 90638
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
90599: LD_EXP 90
90603: PUSH
90604: LD_VAR 0 5
90608: ARRAY
90609: PUSH
90610: LD_VAR 0 4
90614: ARRAY
90615: PUSH
90616: LD_INT 1
90618: ARRAY
90619: PUSH
90620: LD_VAR 0 2
90624: EQUAL
90625: IFFALSE 90636
// KillUnit ( vehicle ) ;
90627: LD_VAR 0 2
90631: PPUSH
90632: CALL_OW 66
90636: GO 90596
90638: POP
90639: POP
// end ;
90640: LD_VAR 0 3
90644: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
90645: LD_EXP 94
90649: NOT
90650: IFFALSE 90685
90652: GO 90654
90654: DISABLE
// begin initMiner := true ;
90655: LD_ADDR_EXP 94
90659: PUSH
90660: LD_INT 1
90662: ST_TO_ADDR
// minersList := [ ] ;
90663: LD_ADDR_EXP 95
90667: PUSH
90668: EMPTY
90669: ST_TO_ADDR
// minerMinesList := [ ] ;
90670: LD_ADDR_EXP 96
90674: PUSH
90675: EMPTY
90676: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
90677: LD_ADDR_EXP 97
90681: PUSH
90682: LD_INT 5
90684: ST_TO_ADDR
// end ;
90685: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
90686: LD_EXP 94
90690: PUSH
90691: LD_INT 34
90693: PUSH
90694: LD_EXP 74
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PPUSH
90703: CALL_OW 69
90707: AND
90708: IFFALSE 91171
90710: GO 90712
90712: DISABLE
90713: LD_INT 0
90715: PPUSH
90716: PPUSH
90717: PPUSH
90718: PPUSH
// begin enable ;
90719: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
90720: LD_ADDR_VAR 0 1
90724: PUSH
90725: LD_INT 34
90727: PUSH
90728: LD_EXP 74
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PPUSH
90737: CALL_OW 69
90741: PUSH
90742: FOR_IN
90743: IFFALSE 90815
// begin if not i in minersList then
90745: LD_VAR 0 1
90749: PUSH
90750: LD_EXP 95
90754: IN
90755: NOT
90756: IFFALSE 90813
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
90758: LD_ADDR_EXP 95
90762: PUSH
90763: LD_EXP 95
90767: PPUSH
90768: LD_EXP 95
90772: PUSH
90773: LD_INT 1
90775: PLUS
90776: PPUSH
90777: LD_VAR 0 1
90781: PPUSH
90782: CALL_OW 1
90786: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
90787: LD_ADDR_EXP 96
90791: PUSH
90792: LD_EXP 96
90796: PPUSH
90797: LD_EXP 96
90801: PUSH
90802: LD_INT 1
90804: PLUS
90805: PPUSH
90806: EMPTY
90807: PPUSH
90808: CALL_OW 1
90812: ST_TO_ADDR
// end end ;
90813: GO 90742
90815: POP
90816: POP
// for i := minerMinesList downto 1 do
90817: LD_ADDR_VAR 0 1
90821: PUSH
90822: DOUBLE
90823: LD_EXP 96
90827: INC
90828: ST_TO_ADDR
90829: LD_INT 1
90831: PUSH
90832: FOR_DOWNTO
90833: IFFALSE 91169
// begin if IsLive ( minersList [ i ] ) then
90835: LD_EXP 95
90839: PUSH
90840: LD_VAR 0 1
90844: ARRAY
90845: PPUSH
90846: CALL_OW 300
90850: IFFALSE 90878
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
90852: LD_EXP 95
90856: PUSH
90857: LD_VAR 0 1
90861: ARRAY
90862: PPUSH
90863: LD_EXP 96
90867: PUSH
90868: LD_VAR 0 1
90872: ARRAY
90873: PPUSH
90874: CALL_OW 505
// if not minerMinesList [ i ] then
90878: LD_EXP 96
90882: PUSH
90883: LD_VAR 0 1
90887: ARRAY
90888: NOT
90889: IFFALSE 90893
// continue ;
90891: GO 90832
// for j := minerMinesList [ i ] downto 1 do
90893: LD_ADDR_VAR 0 2
90897: PUSH
90898: DOUBLE
90899: LD_EXP 96
90903: PUSH
90904: LD_VAR 0 1
90908: ARRAY
90909: INC
90910: ST_TO_ADDR
90911: LD_INT 1
90913: PUSH
90914: FOR_DOWNTO
90915: IFFALSE 91165
// begin side := GetSide ( minersList [ i ] ) ;
90917: LD_ADDR_VAR 0 3
90921: PUSH
90922: LD_EXP 95
90926: PUSH
90927: LD_VAR 0 1
90931: ARRAY
90932: PPUSH
90933: CALL_OW 255
90937: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
90938: LD_ADDR_VAR 0 4
90942: PUSH
90943: LD_EXP 96
90947: PUSH
90948: LD_VAR 0 1
90952: ARRAY
90953: PUSH
90954: LD_VAR 0 2
90958: ARRAY
90959: PUSH
90960: LD_INT 1
90962: ARRAY
90963: PPUSH
90964: LD_EXP 96
90968: PUSH
90969: LD_VAR 0 1
90973: ARRAY
90974: PUSH
90975: LD_VAR 0 2
90979: ARRAY
90980: PUSH
90981: LD_INT 2
90983: ARRAY
90984: PPUSH
90985: CALL_OW 428
90989: ST_TO_ADDR
// if not tmp then
90990: LD_VAR 0 4
90994: NOT
90995: IFFALSE 90999
// continue ;
90997: GO 90914
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
90999: LD_VAR 0 4
91003: PUSH
91004: LD_INT 81
91006: PUSH
91007: LD_VAR 0 3
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PPUSH
91016: CALL_OW 69
91020: IN
91021: PUSH
91022: LD_EXP 96
91026: PUSH
91027: LD_VAR 0 1
91031: ARRAY
91032: PUSH
91033: LD_VAR 0 2
91037: ARRAY
91038: PUSH
91039: LD_INT 1
91041: ARRAY
91042: PPUSH
91043: LD_EXP 96
91047: PUSH
91048: LD_VAR 0 1
91052: ARRAY
91053: PUSH
91054: LD_VAR 0 2
91058: ARRAY
91059: PUSH
91060: LD_INT 2
91062: ARRAY
91063: PPUSH
91064: CALL_OW 458
91068: AND
91069: IFFALSE 91163
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
91071: LD_EXP 96
91075: PUSH
91076: LD_VAR 0 1
91080: ARRAY
91081: PUSH
91082: LD_VAR 0 2
91086: ARRAY
91087: PUSH
91088: LD_INT 1
91090: ARRAY
91091: PPUSH
91092: LD_EXP 96
91096: PUSH
91097: LD_VAR 0 1
91101: ARRAY
91102: PUSH
91103: LD_VAR 0 2
91107: ARRAY
91108: PUSH
91109: LD_INT 2
91111: ARRAY
91112: PPUSH
91113: LD_VAR 0 3
91117: PPUSH
91118: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
91122: LD_ADDR_EXP 96
91126: PUSH
91127: LD_EXP 96
91131: PPUSH
91132: LD_VAR 0 1
91136: PPUSH
91137: LD_EXP 96
91141: PUSH
91142: LD_VAR 0 1
91146: ARRAY
91147: PPUSH
91148: LD_VAR 0 2
91152: PPUSH
91153: CALL_OW 3
91157: PPUSH
91158: CALL_OW 1
91162: ST_TO_ADDR
// end ; end ;
91163: GO 90914
91165: POP
91166: POP
// end ;
91167: GO 90832
91169: POP
91170: POP
// end ;
91171: PPOPN 4
91173: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
91174: LD_INT 0
91176: PPUSH
91177: PPUSH
// result := false ;
91178: LD_ADDR_VAR 0 4
91182: PUSH
91183: LD_INT 0
91185: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
91186: LD_VAR 0 1
91190: PPUSH
91191: CALL_OW 264
91195: PUSH
91196: LD_EXP 74
91200: EQUAL
91201: NOT
91202: IFFALSE 91206
// exit ;
91204: GO 91446
// index := GetElementIndex ( minersList , unit ) ;
91206: LD_ADDR_VAR 0 5
91210: PUSH
91211: LD_EXP 95
91215: PPUSH
91216: LD_VAR 0 1
91220: PPUSH
91221: CALL 15775 0 2
91225: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
91226: LD_EXP 96
91230: PUSH
91231: LD_VAR 0 5
91235: ARRAY
91236: PUSH
91237: LD_EXP 97
91241: GREATEREQUAL
91242: IFFALSE 91246
// exit ;
91244: GO 91446
// ComMoveXY ( unit , x , y ) ;
91246: LD_VAR 0 1
91250: PPUSH
91251: LD_VAR 0 2
91255: PPUSH
91256: LD_VAR 0 3
91260: PPUSH
91261: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
91265: LD_INT 35
91267: PPUSH
91268: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
91272: LD_VAR 0 1
91276: PPUSH
91277: LD_VAR 0 2
91281: PPUSH
91282: LD_VAR 0 3
91286: PPUSH
91287: CALL 46547 0 3
91291: NOT
91292: PUSH
91293: LD_VAR 0 1
91297: PPUSH
91298: CALL_OW 314
91302: AND
91303: IFFALSE 91307
// exit ;
91305: GO 91446
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
91307: LD_VAR 0 2
91311: PPUSH
91312: LD_VAR 0 3
91316: PPUSH
91317: CALL_OW 428
91321: PUSH
91322: LD_VAR 0 1
91326: EQUAL
91327: PUSH
91328: LD_VAR 0 1
91332: PPUSH
91333: CALL_OW 314
91337: NOT
91338: AND
91339: IFFALSE 91265
// PlaySoundXY ( x , y , PlantMine ) ;
91341: LD_VAR 0 2
91345: PPUSH
91346: LD_VAR 0 3
91350: PPUSH
91351: LD_STRING PlantMine
91353: PPUSH
91354: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
91358: LD_VAR 0 2
91362: PPUSH
91363: LD_VAR 0 3
91367: PPUSH
91368: LD_VAR 0 1
91372: PPUSH
91373: CALL_OW 255
91377: PPUSH
91378: LD_INT 0
91380: PPUSH
91381: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
91385: LD_ADDR_EXP 96
91389: PUSH
91390: LD_EXP 96
91394: PPUSH
91395: LD_VAR 0 5
91399: PUSH
91400: LD_EXP 96
91404: PUSH
91405: LD_VAR 0 5
91409: ARRAY
91410: PUSH
91411: LD_INT 1
91413: PLUS
91414: PUSH
91415: EMPTY
91416: LIST
91417: LIST
91418: PPUSH
91419: LD_VAR 0 2
91423: PUSH
91424: LD_VAR 0 3
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: PPUSH
91433: CALL 15990 0 3
91437: ST_TO_ADDR
// result := true ;
91438: LD_ADDR_VAR 0 4
91442: PUSH
91443: LD_INT 1
91445: ST_TO_ADDR
// end ;
91446: LD_VAR 0 4
91450: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
91451: LD_INT 0
91453: PPUSH
91454: PPUSH
91455: PPUSH
// if not unit in minersList then
91456: LD_VAR 0 1
91460: PUSH
91461: LD_EXP 95
91465: IN
91466: NOT
91467: IFFALSE 91471
// exit ;
91469: GO 91863
// index := GetElementIndex ( minersList , unit ) ;
91471: LD_ADDR_VAR 0 6
91475: PUSH
91476: LD_EXP 95
91480: PPUSH
91481: LD_VAR 0 1
91485: PPUSH
91486: CALL 15775 0 2
91490: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
91491: LD_ADDR_VAR 0 5
91495: PUSH
91496: DOUBLE
91497: LD_EXP 96
91501: PUSH
91502: LD_VAR 0 6
91506: ARRAY
91507: INC
91508: ST_TO_ADDR
91509: LD_INT 1
91511: PUSH
91512: FOR_DOWNTO
91513: IFFALSE 91674
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
91515: LD_EXP 96
91519: PUSH
91520: LD_VAR 0 6
91524: ARRAY
91525: PUSH
91526: LD_VAR 0 5
91530: ARRAY
91531: PUSH
91532: LD_INT 1
91534: ARRAY
91535: PUSH
91536: LD_VAR 0 2
91540: EQUAL
91541: PUSH
91542: LD_EXP 96
91546: PUSH
91547: LD_VAR 0 6
91551: ARRAY
91552: PUSH
91553: LD_VAR 0 5
91557: ARRAY
91558: PUSH
91559: LD_INT 2
91561: ARRAY
91562: PUSH
91563: LD_VAR 0 3
91567: EQUAL
91568: AND
91569: IFFALSE 91672
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91571: LD_EXP 96
91575: PUSH
91576: LD_VAR 0 6
91580: ARRAY
91581: PUSH
91582: LD_VAR 0 5
91586: ARRAY
91587: PUSH
91588: LD_INT 1
91590: ARRAY
91591: PPUSH
91592: LD_EXP 96
91596: PUSH
91597: LD_VAR 0 6
91601: ARRAY
91602: PUSH
91603: LD_VAR 0 5
91607: ARRAY
91608: PUSH
91609: LD_INT 2
91611: ARRAY
91612: PPUSH
91613: LD_VAR 0 1
91617: PPUSH
91618: CALL_OW 255
91622: PPUSH
91623: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91627: LD_ADDR_EXP 96
91631: PUSH
91632: LD_EXP 96
91636: PPUSH
91637: LD_VAR 0 6
91641: PPUSH
91642: LD_EXP 96
91646: PUSH
91647: LD_VAR 0 6
91651: ARRAY
91652: PPUSH
91653: LD_VAR 0 5
91657: PPUSH
91658: CALL_OW 3
91662: PPUSH
91663: CALL_OW 1
91667: ST_TO_ADDR
// exit ;
91668: POP
91669: POP
91670: GO 91863
// end ; end ;
91672: GO 91512
91674: POP
91675: POP
// for i := minerMinesList [ index ] downto 1 do
91676: LD_ADDR_VAR 0 5
91680: PUSH
91681: DOUBLE
91682: LD_EXP 96
91686: PUSH
91687: LD_VAR 0 6
91691: ARRAY
91692: INC
91693: ST_TO_ADDR
91694: LD_INT 1
91696: PUSH
91697: FOR_DOWNTO
91698: IFFALSE 91861
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
91700: LD_EXP 96
91704: PUSH
91705: LD_VAR 0 6
91709: ARRAY
91710: PUSH
91711: LD_VAR 0 5
91715: ARRAY
91716: PUSH
91717: LD_INT 1
91719: ARRAY
91720: PPUSH
91721: LD_EXP 96
91725: PUSH
91726: LD_VAR 0 6
91730: ARRAY
91731: PUSH
91732: LD_VAR 0 5
91736: ARRAY
91737: PUSH
91738: LD_INT 2
91740: ARRAY
91741: PPUSH
91742: LD_VAR 0 2
91746: PPUSH
91747: LD_VAR 0 3
91751: PPUSH
91752: CALL_OW 298
91756: PUSH
91757: LD_INT 6
91759: LESS
91760: IFFALSE 91859
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
91762: LD_EXP 96
91766: PUSH
91767: LD_VAR 0 6
91771: ARRAY
91772: PUSH
91773: LD_VAR 0 5
91777: ARRAY
91778: PUSH
91779: LD_INT 1
91781: ARRAY
91782: PPUSH
91783: LD_EXP 96
91787: PUSH
91788: LD_VAR 0 6
91792: ARRAY
91793: PUSH
91794: LD_VAR 0 5
91798: ARRAY
91799: PUSH
91800: LD_INT 2
91802: ARRAY
91803: PPUSH
91804: LD_VAR 0 1
91808: PPUSH
91809: CALL_OW 255
91813: PPUSH
91814: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
91818: LD_ADDR_EXP 96
91822: PUSH
91823: LD_EXP 96
91827: PPUSH
91828: LD_VAR 0 6
91832: PPUSH
91833: LD_EXP 96
91837: PUSH
91838: LD_VAR 0 6
91842: ARRAY
91843: PPUSH
91844: LD_VAR 0 5
91848: PPUSH
91849: CALL_OW 3
91853: PPUSH
91854: CALL_OW 1
91858: ST_TO_ADDR
// end ; end ;
91859: GO 91697
91861: POP
91862: POP
// end ;
91863: LD_VAR 0 4
91867: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
91868: LD_INT 0
91870: PPUSH
91871: PPUSH
91872: PPUSH
91873: PPUSH
91874: PPUSH
91875: PPUSH
91876: PPUSH
91877: PPUSH
91878: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
91879: LD_VAR 0 1
91883: PPUSH
91884: CALL_OW 264
91888: PUSH
91889: LD_EXP 74
91893: EQUAL
91894: NOT
91895: PUSH
91896: LD_VAR 0 1
91900: PUSH
91901: LD_EXP 95
91905: IN
91906: NOT
91907: OR
91908: IFFALSE 91912
// exit ;
91910: GO 92234
// index := GetElementIndex ( minersList , unit ) ;
91912: LD_ADDR_VAR 0 6
91916: PUSH
91917: LD_EXP 95
91921: PPUSH
91922: LD_VAR 0 1
91926: PPUSH
91927: CALL 15775 0 2
91931: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
91932: LD_ADDR_VAR 0 8
91936: PUSH
91937: LD_EXP 97
91941: PUSH
91942: LD_EXP 96
91946: PUSH
91947: LD_VAR 0 6
91951: ARRAY
91952: MINUS
91953: ST_TO_ADDR
// if not minesFreeAmount then
91954: LD_VAR 0 8
91958: NOT
91959: IFFALSE 91963
// exit ;
91961: GO 92234
// tmp := [ ] ;
91963: LD_ADDR_VAR 0 7
91967: PUSH
91968: EMPTY
91969: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
91970: LD_ADDR_VAR 0 5
91974: PUSH
91975: DOUBLE
91976: LD_INT 1
91978: DEC
91979: ST_TO_ADDR
91980: LD_VAR 0 8
91984: PUSH
91985: FOR_TO
91986: IFFALSE 92181
// begin _d := rand ( 0 , 5 ) ;
91988: LD_ADDR_VAR 0 11
91992: PUSH
91993: LD_INT 0
91995: PPUSH
91996: LD_INT 5
91998: PPUSH
91999: CALL_OW 12
92003: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
92004: LD_ADDR_VAR 0 12
92008: PUSH
92009: LD_INT 2
92011: PPUSH
92012: LD_INT 6
92014: PPUSH
92015: CALL_OW 12
92019: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
92020: LD_ADDR_VAR 0 9
92024: PUSH
92025: LD_VAR 0 2
92029: PPUSH
92030: LD_VAR 0 11
92034: PPUSH
92035: LD_VAR 0 12
92039: PPUSH
92040: CALL_OW 272
92044: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
92045: LD_ADDR_VAR 0 10
92049: PUSH
92050: LD_VAR 0 3
92054: PPUSH
92055: LD_VAR 0 11
92059: PPUSH
92060: LD_VAR 0 12
92064: PPUSH
92065: CALL_OW 273
92069: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
92070: LD_VAR 0 9
92074: PPUSH
92075: LD_VAR 0 10
92079: PPUSH
92080: CALL_OW 488
92084: PUSH
92085: LD_VAR 0 9
92089: PUSH
92090: LD_VAR 0 10
92094: PUSH
92095: EMPTY
92096: LIST
92097: LIST
92098: PUSH
92099: LD_VAR 0 7
92103: IN
92104: NOT
92105: AND
92106: PUSH
92107: LD_VAR 0 9
92111: PPUSH
92112: LD_VAR 0 10
92116: PPUSH
92117: CALL_OW 458
92121: NOT
92122: AND
92123: IFFALSE 92165
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
92125: LD_ADDR_VAR 0 7
92129: PUSH
92130: LD_VAR 0 7
92134: PPUSH
92135: LD_VAR 0 7
92139: PUSH
92140: LD_INT 1
92142: PLUS
92143: PPUSH
92144: LD_VAR 0 9
92148: PUSH
92149: LD_VAR 0 10
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PPUSH
92158: CALL_OW 1
92162: ST_TO_ADDR
92163: GO 92179
// i := i - 1 ;
92165: LD_ADDR_VAR 0 5
92169: PUSH
92170: LD_VAR 0 5
92174: PUSH
92175: LD_INT 1
92177: MINUS
92178: ST_TO_ADDR
// end ;
92179: GO 91985
92181: POP
92182: POP
// for i in tmp do
92183: LD_ADDR_VAR 0 5
92187: PUSH
92188: LD_VAR 0 7
92192: PUSH
92193: FOR_IN
92194: IFFALSE 92232
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
92196: LD_VAR 0 1
92200: PPUSH
92201: LD_VAR 0 5
92205: PUSH
92206: LD_INT 1
92208: ARRAY
92209: PPUSH
92210: LD_VAR 0 5
92214: PUSH
92215: LD_INT 2
92217: ARRAY
92218: PPUSH
92219: CALL 91174 0 3
92223: NOT
92224: IFFALSE 92230
// exit ;
92226: POP
92227: POP
92228: GO 92234
92230: GO 92193
92232: POP
92233: POP
// end ;
92234: LD_VAR 0 4
92238: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
92239: LD_INT 0
92241: PPUSH
92242: PPUSH
92243: PPUSH
92244: PPUSH
92245: PPUSH
92246: PPUSH
92247: PPUSH
// if not GetClass ( unit ) = class_sniper then
92248: LD_VAR 0 1
92252: PPUSH
92253: CALL_OW 257
92257: PUSH
92258: LD_INT 5
92260: EQUAL
92261: NOT
92262: IFFALSE 92266
// exit ;
92264: GO 92654
// dist := 8 ;
92266: LD_ADDR_VAR 0 5
92270: PUSH
92271: LD_INT 8
92273: ST_TO_ADDR
// viewRange := 12 ;
92274: LD_ADDR_VAR 0 7
92278: PUSH
92279: LD_INT 12
92281: ST_TO_ADDR
// side := GetSide ( unit ) ;
92282: LD_ADDR_VAR 0 6
92286: PUSH
92287: LD_VAR 0 1
92291: PPUSH
92292: CALL_OW 255
92296: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
92297: LD_INT 61
92299: PPUSH
92300: LD_VAR 0 6
92304: PPUSH
92305: CALL_OW 321
92309: PUSH
92310: LD_INT 2
92312: EQUAL
92313: IFFALSE 92323
// viewRange := 16 ;
92315: LD_ADDR_VAR 0 7
92319: PUSH
92320: LD_INT 16
92322: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
92323: LD_VAR 0 1
92327: PPUSH
92328: LD_VAR 0 2
92332: PPUSH
92333: LD_VAR 0 3
92337: PPUSH
92338: CALL_OW 297
92342: PUSH
92343: LD_VAR 0 5
92347: GREATER
92348: IFFALSE 92427
// begin ComMoveXY ( unit , x , y ) ;
92350: LD_VAR 0 1
92354: PPUSH
92355: LD_VAR 0 2
92359: PPUSH
92360: LD_VAR 0 3
92364: PPUSH
92365: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
92369: LD_INT 35
92371: PPUSH
92372: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
92376: LD_VAR 0 1
92380: PPUSH
92381: LD_VAR 0 2
92385: PPUSH
92386: LD_VAR 0 3
92390: PPUSH
92391: CALL 46547 0 3
92395: NOT
92396: IFFALSE 92400
// exit ;
92398: GO 92654
// until GetDistUnitXY ( unit , x , y ) < dist ;
92400: LD_VAR 0 1
92404: PPUSH
92405: LD_VAR 0 2
92409: PPUSH
92410: LD_VAR 0 3
92414: PPUSH
92415: CALL_OW 297
92419: PUSH
92420: LD_VAR 0 5
92424: LESS
92425: IFFALSE 92369
// end ; ComTurnXY ( unit , x , y ) ;
92427: LD_VAR 0 1
92431: PPUSH
92432: LD_VAR 0 2
92436: PPUSH
92437: LD_VAR 0 3
92441: PPUSH
92442: CALL_OW 118
// wait ( 5 ) ;
92446: LD_INT 5
92448: PPUSH
92449: CALL_OW 67
// _d := GetDir ( unit ) ;
92453: LD_ADDR_VAR 0 10
92457: PUSH
92458: LD_VAR 0 1
92462: PPUSH
92463: CALL_OW 254
92467: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
92468: LD_ADDR_VAR 0 8
92472: PUSH
92473: LD_VAR 0 1
92477: PPUSH
92478: CALL_OW 250
92482: PPUSH
92483: LD_VAR 0 10
92487: PPUSH
92488: LD_VAR 0 5
92492: PPUSH
92493: CALL_OW 272
92497: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
92498: LD_ADDR_VAR 0 9
92502: PUSH
92503: LD_VAR 0 1
92507: PPUSH
92508: CALL_OW 251
92512: PPUSH
92513: LD_VAR 0 10
92517: PPUSH
92518: LD_VAR 0 5
92522: PPUSH
92523: CALL_OW 273
92527: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
92528: LD_VAR 0 8
92532: PPUSH
92533: LD_VAR 0 9
92537: PPUSH
92538: CALL_OW 488
92542: NOT
92543: IFFALSE 92547
// exit ;
92545: GO 92654
// ComAnimCustom ( unit , 1 ) ;
92547: LD_VAR 0 1
92551: PPUSH
92552: LD_INT 1
92554: PPUSH
92555: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
92559: LD_VAR 0 8
92563: PPUSH
92564: LD_VAR 0 9
92568: PPUSH
92569: LD_VAR 0 6
92573: PPUSH
92574: LD_VAR 0 7
92578: PPUSH
92579: CALL_OW 330
// repeat wait ( 1 ) ;
92583: LD_INT 1
92585: PPUSH
92586: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
92590: LD_VAR 0 1
92594: PPUSH
92595: CALL_OW 316
92599: PUSH
92600: LD_VAR 0 1
92604: PPUSH
92605: CALL_OW 314
92609: OR
92610: PUSH
92611: LD_VAR 0 1
92615: PPUSH
92616: CALL_OW 302
92620: NOT
92621: OR
92622: PUSH
92623: LD_VAR 0 1
92627: PPUSH
92628: CALL_OW 301
92632: OR
92633: IFFALSE 92583
// RemoveSeeing ( _x , _y , side ) ;
92635: LD_VAR 0 8
92639: PPUSH
92640: LD_VAR 0 9
92644: PPUSH
92645: LD_VAR 0 6
92649: PPUSH
92650: CALL_OW 331
// end ; end_of_file end_of_file
92654: LD_VAR 0 4
92658: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
92659: LD_VAR 0 1
92663: PUSH
92664: LD_INT 200
92666: DOUBLE
92667: GREATEREQUAL
92668: IFFALSE 92676
92670: LD_INT 299
92672: DOUBLE
92673: LESSEQUAL
92674: IFTRUE 92678
92676: GO 92710
92678: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
92679: LD_VAR 0 1
92683: PPUSH
92684: LD_VAR 0 2
92688: PPUSH
92689: LD_VAR 0 3
92693: PPUSH
92694: LD_VAR 0 4
92698: PPUSH
92699: LD_VAR 0 5
92703: PPUSH
92704: CALL 88776 0 5
92708: GO 92787
92710: LD_INT 300
92712: DOUBLE
92713: GREATEREQUAL
92714: IFFALSE 92722
92716: LD_INT 399
92718: DOUBLE
92719: LESSEQUAL
92720: IFTRUE 92724
92722: GO 92786
92724: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
92725: LD_VAR 0 1
92729: PPUSH
92730: LD_VAR 0 2
92734: PPUSH
92735: LD_VAR 0 3
92739: PPUSH
92740: LD_VAR 0 4
92744: PPUSH
92745: LD_VAR 0 5
92749: PPUSH
92750: LD_VAR 0 6
92754: PPUSH
92755: LD_VAR 0 7
92759: PPUSH
92760: LD_VAR 0 8
92764: PPUSH
92765: LD_VAR 0 9
92769: PPUSH
92770: LD_VAR 0 10
92774: PPUSH
92775: LD_VAR 0 11
92779: PPUSH
92780: CALL 104627 0 11
92784: GO 92787
92786: POP
// end ;
92787: PPOPN 11
92789: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
92790: LD_VAR 0 1
92794: PPUSH
92795: LD_VAR 0 2
92799: PPUSH
92800: LD_VAR 0 3
92804: PPUSH
92805: LD_VAR 0 4
92809: PPUSH
92810: LD_VAR 0 5
92814: PPUSH
92815: CALL 88768 0 5
// end ; end_of_file
92819: PPOPN 5
92821: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92822: LD_INT 0
92824: PPUSH
// if p2 = 100 then
92825: LD_VAR 0 2
92829: PUSH
92830: LD_INT 100
92832: EQUAL
92833: IFFALSE 93836
// begin if not StreamModeActive then
92835: LD_EXP 98
92839: NOT
92840: IFFALSE 92850
// StreamModeActive := true ;
92842: LD_ADDR_EXP 98
92846: PUSH
92847: LD_INT 1
92849: ST_TO_ADDR
// if p3 = 0 then
92850: LD_VAR 0 3
92854: PUSH
92855: LD_INT 0
92857: EQUAL
92858: IFFALSE 92864
// InitStreamMode ;
92860: CALL 93996 0 0
// if p3 = 1 then
92864: LD_VAR 0 3
92868: PUSH
92869: LD_INT 1
92871: EQUAL
92872: IFFALSE 92882
// sRocket := true ;
92874: LD_ADDR_EXP 103
92878: PUSH
92879: LD_INT 1
92881: ST_TO_ADDR
// if p3 = 2 then
92882: LD_VAR 0 3
92886: PUSH
92887: LD_INT 2
92889: EQUAL
92890: IFFALSE 92900
// sSpeed := true ;
92892: LD_ADDR_EXP 102
92896: PUSH
92897: LD_INT 1
92899: ST_TO_ADDR
// if p3 = 3 then
92900: LD_VAR 0 3
92904: PUSH
92905: LD_INT 3
92907: EQUAL
92908: IFFALSE 92918
// sEngine := true ;
92910: LD_ADDR_EXP 104
92914: PUSH
92915: LD_INT 1
92917: ST_TO_ADDR
// if p3 = 4 then
92918: LD_VAR 0 3
92922: PUSH
92923: LD_INT 4
92925: EQUAL
92926: IFFALSE 92936
// sSpec := true ;
92928: LD_ADDR_EXP 101
92932: PUSH
92933: LD_INT 1
92935: ST_TO_ADDR
// if p3 = 5 then
92936: LD_VAR 0 3
92940: PUSH
92941: LD_INT 5
92943: EQUAL
92944: IFFALSE 92954
// sLevel := true ;
92946: LD_ADDR_EXP 105
92950: PUSH
92951: LD_INT 1
92953: ST_TO_ADDR
// if p3 = 6 then
92954: LD_VAR 0 3
92958: PUSH
92959: LD_INT 6
92961: EQUAL
92962: IFFALSE 92972
// sArmoury := true ;
92964: LD_ADDR_EXP 106
92968: PUSH
92969: LD_INT 1
92971: ST_TO_ADDR
// if p3 = 7 then
92972: LD_VAR 0 3
92976: PUSH
92977: LD_INT 7
92979: EQUAL
92980: IFFALSE 92990
// sRadar := true ;
92982: LD_ADDR_EXP 107
92986: PUSH
92987: LD_INT 1
92989: ST_TO_ADDR
// if p3 = 8 then
92990: LD_VAR 0 3
92994: PUSH
92995: LD_INT 8
92997: EQUAL
92998: IFFALSE 93008
// sBunker := true ;
93000: LD_ADDR_EXP 108
93004: PUSH
93005: LD_INT 1
93007: ST_TO_ADDR
// if p3 = 9 then
93008: LD_VAR 0 3
93012: PUSH
93013: LD_INT 9
93015: EQUAL
93016: IFFALSE 93026
// sHack := true ;
93018: LD_ADDR_EXP 109
93022: PUSH
93023: LD_INT 1
93025: ST_TO_ADDR
// if p3 = 10 then
93026: LD_VAR 0 3
93030: PUSH
93031: LD_INT 10
93033: EQUAL
93034: IFFALSE 93044
// sFire := true ;
93036: LD_ADDR_EXP 110
93040: PUSH
93041: LD_INT 1
93043: ST_TO_ADDR
// if p3 = 11 then
93044: LD_VAR 0 3
93048: PUSH
93049: LD_INT 11
93051: EQUAL
93052: IFFALSE 93062
// sRefresh := true ;
93054: LD_ADDR_EXP 111
93058: PUSH
93059: LD_INT 1
93061: ST_TO_ADDR
// if p3 = 12 then
93062: LD_VAR 0 3
93066: PUSH
93067: LD_INT 12
93069: EQUAL
93070: IFFALSE 93080
// sExp := true ;
93072: LD_ADDR_EXP 112
93076: PUSH
93077: LD_INT 1
93079: ST_TO_ADDR
// if p3 = 13 then
93080: LD_VAR 0 3
93084: PUSH
93085: LD_INT 13
93087: EQUAL
93088: IFFALSE 93098
// sDepot := true ;
93090: LD_ADDR_EXP 113
93094: PUSH
93095: LD_INT 1
93097: ST_TO_ADDR
// if p3 = 14 then
93098: LD_VAR 0 3
93102: PUSH
93103: LD_INT 14
93105: EQUAL
93106: IFFALSE 93116
// sFlag := true ;
93108: LD_ADDR_EXP 114
93112: PUSH
93113: LD_INT 1
93115: ST_TO_ADDR
// if p3 = 15 then
93116: LD_VAR 0 3
93120: PUSH
93121: LD_INT 15
93123: EQUAL
93124: IFFALSE 93134
// sKamikadze := true ;
93126: LD_ADDR_EXP 122
93130: PUSH
93131: LD_INT 1
93133: ST_TO_ADDR
// if p3 = 16 then
93134: LD_VAR 0 3
93138: PUSH
93139: LD_INT 16
93141: EQUAL
93142: IFFALSE 93152
// sTroll := true ;
93144: LD_ADDR_EXP 123
93148: PUSH
93149: LD_INT 1
93151: ST_TO_ADDR
// if p3 = 17 then
93152: LD_VAR 0 3
93156: PUSH
93157: LD_INT 17
93159: EQUAL
93160: IFFALSE 93170
// sSlow := true ;
93162: LD_ADDR_EXP 124
93166: PUSH
93167: LD_INT 1
93169: ST_TO_ADDR
// if p3 = 18 then
93170: LD_VAR 0 3
93174: PUSH
93175: LD_INT 18
93177: EQUAL
93178: IFFALSE 93188
// sLack := true ;
93180: LD_ADDR_EXP 125
93184: PUSH
93185: LD_INT 1
93187: ST_TO_ADDR
// if p3 = 19 then
93188: LD_VAR 0 3
93192: PUSH
93193: LD_INT 19
93195: EQUAL
93196: IFFALSE 93206
// sTank := true ;
93198: LD_ADDR_EXP 127
93202: PUSH
93203: LD_INT 1
93205: ST_TO_ADDR
// if p3 = 20 then
93206: LD_VAR 0 3
93210: PUSH
93211: LD_INT 20
93213: EQUAL
93214: IFFALSE 93224
// sRemote := true ;
93216: LD_ADDR_EXP 128
93220: PUSH
93221: LD_INT 1
93223: ST_TO_ADDR
// if p3 = 21 then
93224: LD_VAR 0 3
93228: PUSH
93229: LD_INT 21
93231: EQUAL
93232: IFFALSE 93242
// sPowell := true ;
93234: LD_ADDR_EXP 129
93238: PUSH
93239: LD_INT 1
93241: ST_TO_ADDR
// if p3 = 22 then
93242: LD_VAR 0 3
93246: PUSH
93247: LD_INT 22
93249: EQUAL
93250: IFFALSE 93260
// sTeleport := true ;
93252: LD_ADDR_EXP 132
93256: PUSH
93257: LD_INT 1
93259: ST_TO_ADDR
// if p3 = 23 then
93260: LD_VAR 0 3
93264: PUSH
93265: LD_INT 23
93267: EQUAL
93268: IFFALSE 93278
// sOilTower := true ;
93270: LD_ADDR_EXP 134
93274: PUSH
93275: LD_INT 1
93277: ST_TO_ADDR
// if p3 = 24 then
93278: LD_VAR 0 3
93282: PUSH
93283: LD_INT 24
93285: EQUAL
93286: IFFALSE 93296
// sShovel := true ;
93288: LD_ADDR_EXP 135
93292: PUSH
93293: LD_INT 1
93295: ST_TO_ADDR
// if p3 = 25 then
93296: LD_VAR 0 3
93300: PUSH
93301: LD_INT 25
93303: EQUAL
93304: IFFALSE 93314
// sSheik := true ;
93306: LD_ADDR_EXP 136
93310: PUSH
93311: LD_INT 1
93313: ST_TO_ADDR
// if p3 = 26 then
93314: LD_VAR 0 3
93318: PUSH
93319: LD_INT 26
93321: EQUAL
93322: IFFALSE 93332
// sEarthquake := true ;
93324: LD_ADDR_EXP 138
93328: PUSH
93329: LD_INT 1
93331: ST_TO_ADDR
// if p3 = 27 then
93332: LD_VAR 0 3
93336: PUSH
93337: LD_INT 27
93339: EQUAL
93340: IFFALSE 93350
// sAI := true ;
93342: LD_ADDR_EXP 139
93346: PUSH
93347: LD_INT 1
93349: ST_TO_ADDR
// if p3 = 28 then
93350: LD_VAR 0 3
93354: PUSH
93355: LD_INT 28
93357: EQUAL
93358: IFFALSE 93368
// sCargo := true ;
93360: LD_ADDR_EXP 142
93364: PUSH
93365: LD_INT 1
93367: ST_TO_ADDR
// if p3 = 29 then
93368: LD_VAR 0 3
93372: PUSH
93373: LD_INT 29
93375: EQUAL
93376: IFFALSE 93386
// sDLaser := true ;
93378: LD_ADDR_EXP 143
93382: PUSH
93383: LD_INT 1
93385: ST_TO_ADDR
// if p3 = 30 then
93386: LD_VAR 0 3
93390: PUSH
93391: LD_INT 30
93393: EQUAL
93394: IFFALSE 93404
// sExchange := true ;
93396: LD_ADDR_EXP 144
93400: PUSH
93401: LD_INT 1
93403: ST_TO_ADDR
// if p3 = 31 then
93404: LD_VAR 0 3
93408: PUSH
93409: LD_INT 31
93411: EQUAL
93412: IFFALSE 93422
// sFac := true ;
93414: LD_ADDR_EXP 145
93418: PUSH
93419: LD_INT 1
93421: ST_TO_ADDR
// if p3 = 32 then
93422: LD_VAR 0 3
93426: PUSH
93427: LD_INT 32
93429: EQUAL
93430: IFFALSE 93440
// sPower := true ;
93432: LD_ADDR_EXP 146
93436: PUSH
93437: LD_INT 1
93439: ST_TO_ADDR
// if p3 = 33 then
93440: LD_VAR 0 3
93444: PUSH
93445: LD_INT 33
93447: EQUAL
93448: IFFALSE 93458
// sRandom := true ;
93450: LD_ADDR_EXP 147
93454: PUSH
93455: LD_INT 1
93457: ST_TO_ADDR
// if p3 = 34 then
93458: LD_VAR 0 3
93462: PUSH
93463: LD_INT 34
93465: EQUAL
93466: IFFALSE 93476
// sShield := true ;
93468: LD_ADDR_EXP 148
93472: PUSH
93473: LD_INT 1
93475: ST_TO_ADDR
// if p3 = 35 then
93476: LD_VAR 0 3
93480: PUSH
93481: LD_INT 35
93483: EQUAL
93484: IFFALSE 93494
// sTime := true ;
93486: LD_ADDR_EXP 149
93490: PUSH
93491: LD_INT 1
93493: ST_TO_ADDR
// if p3 = 36 then
93494: LD_VAR 0 3
93498: PUSH
93499: LD_INT 36
93501: EQUAL
93502: IFFALSE 93512
// sTools := true ;
93504: LD_ADDR_EXP 150
93508: PUSH
93509: LD_INT 1
93511: ST_TO_ADDR
// if p3 = 101 then
93512: LD_VAR 0 3
93516: PUSH
93517: LD_INT 101
93519: EQUAL
93520: IFFALSE 93530
// sSold := true ;
93522: LD_ADDR_EXP 115
93526: PUSH
93527: LD_INT 1
93529: ST_TO_ADDR
// if p3 = 102 then
93530: LD_VAR 0 3
93534: PUSH
93535: LD_INT 102
93537: EQUAL
93538: IFFALSE 93548
// sDiff := true ;
93540: LD_ADDR_EXP 116
93544: PUSH
93545: LD_INT 1
93547: ST_TO_ADDR
// if p3 = 103 then
93548: LD_VAR 0 3
93552: PUSH
93553: LD_INT 103
93555: EQUAL
93556: IFFALSE 93566
// sFog := true ;
93558: LD_ADDR_EXP 119
93562: PUSH
93563: LD_INT 1
93565: ST_TO_ADDR
// if p3 = 104 then
93566: LD_VAR 0 3
93570: PUSH
93571: LD_INT 104
93573: EQUAL
93574: IFFALSE 93584
// sReset := true ;
93576: LD_ADDR_EXP 120
93580: PUSH
93581: LD_INT 1
93583: ST_TO_ADDR
// if p3 = 105 then
93584: LD_VAR 0 3
93588: PUSH
93589: LD_INT 105
93591: EQUAL
93592: IFFALSE 93602
// sSun := true ;
93594: LD_ADDR_EXP 121
93598: PUSH
93599: LD_INT 1
93601: ST_TO_ADDR
// if p3 = 106 then
93602: LD_VAR 0 3
93606: PUSH
93607: LD_INT 106
93609: EQUAL
93610: IFFALSE 93620
// sTiger := true ;
93612: LD_ADDR_EXP 117
93616: PUSH
93617: LD_INT 1
93619: ST_TO_ADDR
// if p3 = 107 then
93620: LD_VAR 0 3
93624: PUSH
93625: LD_INT 107
93627: EQUAL
93628: IFFALSE 93638
// sBomb := true ;
93630: LD_ADDR_EXP 118
93634: PUSH
93635: LD_INT 1
93637: ST_TO_ADDR
// if p3 = 108 then
93638: LD_VAR 0 3
93642: PUSH
93643: LD_INT 108
93645: EQUAL
93646: IFFALSE 93656
// sWound := true ;
93648: LD_ADDR_EXP 126
93652: PUSH
93653: LD_INT 1
93655: ST_TO_ADDR
// if p3 = 109 then
93656: LD_VAR 0 3
93660: PUSH
93661: LD_INT 109
93663: EQUAL
93664: IFFALSE 93674
// sBetray := true ;
93666: LD_ADDR_EXP 130
93670: PUSH
93671: LD_INT 1
93673: ST_TO_ADDR
// if p3 = 110 then
93674: LD_VAR 0 3
93678: PUSH
93679: LD_INT 110
93681: EQUAL
93682: IFFALSE 93692
// sContamin := true ;
93684: LD_ADDR_EXP 131
93688: PUSH
93689: LD_INT 1
93691: ST_TO_ADDR
// if p3 = 111 then
93692: LD_VAR 0 3
93696: PUSH
93697: LD_INT 111
93699: EQUAL
93700: IFFALSE 93710
// sOil := true ;
93702: LD_ADDR_EXP 133
93706: PUSH
93707: LD_INT 1
93709: ST_TO_ADDR
// if p3 = 112 then
93710: LD_VAR 0 3
93714: PUSH
93715: LD_INT 112
93717: EQUAL
93718: IFFALSE 93728
// sStu := true ;
93720: LD_ADDR_EXP 137
93724: PUSH
93725: LD_INT 1
93727: ST_TO_ADDR
// if p3 = 113 then
93728: LD_VAR 0 3
93732: PUSH
93733: LD_INT 113
93735: EQUAL
93736: IFFALSE 93746
// sBazooka := true ;
93738: LD_ADDR_EXP 140
93742: PUSH
93743: LD_INT 1
93745: ST_TO_ADDR
// if p3 = 114 then
93746: LD_VAR 0 3
93750: PUSH
93751: LD_INT 114
93753: EQUAL
93754: IFFALSE 93764
// sMortar := true ;
93756: LD_ADDR_EXP 141
93760: PUSH
93761: LD_INT 1
93763: ST_TO_ADDR
// if p3 = 115 then
93764: LD_VAR 0 3
93768: PUSH
93769: LD_INT 115
93771: EQUAL
93772: IFFALSE 93782
// sRanger := true ;
93774: LD_ADDR_EXP 151
93778: PUSH
93779: LD_INT 1
93781: ST_TO_ADDR
// if p3 = 116 then
93782: LD_VAR 0 3
93786: PUSH
93787: LD_INT 116
93789: EQUAL
93790: IFFALSE 93800
// sComputer := true ;
93792: LD_ADDR_EXP 152
93796: PUSH
93797: LD_INT 1
93799: ST_TO_ADDR
// if p3 = 117 then
93800: LD_VAR 0 3
93804: PUSH
93805: LD_INT 117
93807: EQUAL
93808: IFFALSE 93818
// s30 := true ;
93810: LD_ADDR_EXP 153
93814: PUSH
93815: LD_INT 1
93817: ST_TO_ADDR
// if p3 = 118 then
93818: LD_VAR 0 3
93822: PUSH
93823: LD_INT 118
93825: EQUAL
93826: IFFALSE 93836
// s60 := true ;
93828: LD_ADDR_EXP 154
93832: PUSH
93833: LD_INT 1
93835: ST_TO_ADDR
// end ; if p2 = 101 then
93836: LD_VAR 0 2
93840: PUSH
93841: LD_INT 101
93843: EQUAL
93844: IFFALSE 93972
// begin case p3 of 1 :
93846: LD_VAR 0 3
93850: PUSH
93851: LD_INT 1
93853: DOUBLE
93854: EQUAL
93855: IFTRUE 93859
93857: GO 93866
93859: POP
// hHackUnlimitedResources ; 2 :
93860: CALL 105568 0 0
93864: GO 93972
93866: LD_INT 2
93868: DOUBLE
93869: EQUAL
93870: IFTRUE 93874
93872: GO 93881
93874: POP
// hHackSetLevel10 ; 3 :
93875: CALL 105701 0 0
93879: GO 93972
93881: LD_INT 3
93883: DOUBLE
93884: EQUAL
93885: IFTRUE 93889
93887: GO 93896
93889: POP
// hHackSetLevel10YourUnits ; 4 :
93890: CALL 105786 0 0
93894: GO 93972
93896: LD_INT 4
93898: DOUBLE
93899: EQUAL
93900: IFTRUE 93904
93902: GO 93911
93904: POP
// hHackInvincible ; 5 :
93905: CALL 106234 0 0
93909: GO 93972
93911: LD_INT 5
93913: DOUBLE
93914: EQUAL
93915: IFTRUE 93919
93917: GO 93926
93919: POP
// hHackInvisible ; 6 :
93920: CALL 106345 0 0
93924: GO 93972
93926: LD_INT 6
93928: DOUBLE
93929: EQUAL
93930: IFTRUE 93934
93932: GO 93941
93934: POP
// hHackChangeYourSide ; 7 :
93935: CALL 106402 0 0
93939: GO 93972
93941: LD_INT 7
93943: DOUBLE
93944: EQUAL
93945: IFTRUE 93949
93947: GO 93956
93949: POP
// hHackChangeUnitSide ; 8 :
93950: CALL 106444 0 0
93954: GO 93972
93956: LD_INT 8
93958: DOUBLE
93959: EQUAL
93960: IFTRUE 93964
93962: GO 93971
93964: POP
// hHackFog ; end ;
93965: CALL 106545 0 0
93969: GO 93972
93971: POP
// end ; end ;
93972: LD_VAR 0 7
93976: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
93977: GO 93979
93979: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
93980: LD_STRING initStreamRollete();
93982: PPUSH
93983: CALL_OW 559
// InitStreamMode ;
93987: CALL 93996 0 0
// DefineStreamItems ( ) ;
93991: CALL 94460 0 0
// end ;
93995: END
// function InitStreamMode ; begin
93996: LD_INT 0
93998: PPUSH
// streamModeActive := false ;
93999: LD_ADDR_EXP 98
94003: PUSH
94004: LD_INT 0
94006: ST_TO_ADDR
// normalCounter := 36 ;
94007: LD_ADDR_EXP 99
94011: PUSH
94012: LD_INT 36
94014: ST_TO_ADDR
// hardcoreCounter := 16 ;
94015: LD_ADDR_EXP 100
94019: PUSH
94020: LD_INT 16
94022: ST_TO_ADDR
// sRocket := false ;
94023: LD_ADDR_EXP 103
94027: PUSH
94028: LD_INT 0
94030: ST_TO_ADDR
// sSpeed := false ;
94031: LD_ADDR_EXP 102
94035: PUSH
94036: LD_INT 0
94038: ST_TO_ADDR
// sEngine := false ;
94039: LD_ADDR_EXP 104
94043: PUSH
94044: LD_INT 0
94046: ST_TO_ADDR
// sSpec := false ;
94047: LD_ADDR_EXP 101
94051: PUSH
94052: LD_INT 0
94054: ST_TO_ADDR
// sLevel := false ;
94055: LD_ADDR_EXP 105
94059: PUSH
94060: LD_INT 0
94062: ST_TO_ADDR
// sArmoury := false ;
94063: LD_ADDR_EXP 106
94067: PUSH
94068: LD_INT 0
94070: ST_TO_ADDR
// sRadar := false ;
94071: LD_ADDR_EXP 107
94075: PUSH
94076: LD_INT 0
94078: ST_TO_ADDR
// sBunker := false ;
94079: LD_ADDR_EXP 108
94083: PUSH
94084: LD_INT 0
94086: ST_TO_ADDR
// sHack := false ;
94087: LD_ADDR_EXP 109
94091: PUSH
94092: LD_INT 0
94094: ST_TO_ADDR
// sFire := false ;
94095: LD_ADDR_EXP 110
94099: PUSH
94100: LD_INT 0
94102: ST_TO_ADDR
// sRefresh := false ;
94103: LD_ADDR_EXP 111
94107: PUSH
94108: LD_INT 0
94110: ST_TO_ADDR
// sExp := false ;
94111: LD_ADDR_EXP 112
94115: PUSH
94116: LD_INT 0
94118: ST_TO_ADDR
// sDepot := false ;
94119: LD_ADDR_EXP 113
94123: PUSH
94124: LD_INT 0
94126: ST_TO_ADDR
// sFlag := false ;
94127: LD_ADDR_EXP 114
94131: PUSH
94132: LD_INT 0
94134: ST_TO_ADDR
// sKamikadze := false ;
94135: LD_ADDR_EXP 122
94139: PUSH
94140: LD_INT 0
94142: ST_TO_ADDR
// sTroll := false ;
94143: LD_ADDR_EXP 123
94147: PUSH
94148: LD_INT 0
94150: ST_TO_ADDR
// sSlow := false ;
94151: LD_ADDR_EXP 124
94155: PUSH
94156: LD_INT 0
94158: ST_TO_ADDR
// sLack := false ;
94159: LD_ADDR_EXP 125
94163: PUSH
94164: LD_INT 0
94166: ST_TO_ADDR
// sTank := false ;
94167: LD_ADDR_EXP 127
94171: PUSH
94172: LD_INT 0
94174: ST_TO_ADDR
// sRemote := false ;
94175: LD_ADDR_EXP 128
94179: PUSH
94180: LD_INT 0
94182: ST_TO_ADDR
// sPowell := false ;
94183: LD_ADDR_EXP 129
94187: PUSH
94188: LD_INT 0
94190: ST_TO_ADDR
// sTeleport := false ;
94191: LD_ADDR_EXP 132
94195: PUSH
94196: LD_INT 0
94198: ST_TO_ADDR
// sOilTower := false ;
94199: LD_ADDR_EXP 134
94203: PUSH
94204: LD_INT 0
94206: ST_TO_ADDR
// sShovel := false ;
94207: LD_ADDR_EXP 135
94211: PUSH
94212: LD_INT 0
94214: ST_TO_ADDR
// sSheik := false ;
94215: LD_ADDR_EXP 136
94219: PUSH
94220: LD_INT 0
94222: ST_TO_ADDR
// sEarthquake := false ;
94223: LD_ADDR_EXP 138
94227: PUSH
94228: LD_INT 0
94230: ST_TO_ADDR
// sAI := false ;
94231: LD_ADDR_EXP 139
94235: PUSH
94236: LD_INT 0
94238: ST_TO_ADDR
// sCargo := false ;
94239: LD_ADDR_EXP 142
94243: PUSH
94244: LD_INT 0
94246: ST_TO_ADDR
// sDLaser := false ;
94247: LD_ADDR_EXP 143
94251: PUSH
94252: LD_INT 0
94254: ST_TO_ADDR
// sExchange := false ;
94255: LD_ADDR_EXP 144
94259: PUSH
94260: LD_INT 0
94262: ST_TO_ADDR
// sFac := false ;
94263: LD_ADDR_EXP 145
94267: PUSH
94268: LD_INT 0
94270: ST_TO_ADDR
// sPower := false ;
94271: LD_ADDR_EXP 146
94275: PUSH
94276: LD_INT 0
94278: ST_TO_ADDR
// sRandom := false ;
94279: LD_ADDR_EXP 147
94283: PUSH
94284: LD_INT 0
94286: ST_TO_ADDR
// sShield := false ;
94287: LD_ADDR_EXP 148
94291: PUSH
94292: LD_INT 0
94294: ST_TO_ADDR
// sTime := false ;
94295: LD_ADDR_EXP 149
94299: PUSH
94300: LD_INT 0
94302: ST_TO_ADDR
// sTools := false ;
94303: LD_ADDR_EXP 150
94307: PUSH
94308: LD_INT 0
94310: ST_TO_ADDR
// sSold := false ;
94311: LD_ADDR_EXP 115
94315: PUSH
94316: LD_INT 0
94318: ST_TO_ADDR
// sDiff := false ;
94319: LD_ADDR_EXP 116
94323: PUSH
94324: LD_INT 0
94326: ST_TO_ADDR
// sFog := false ;
94327: LD_ADDR_EXP 119
94331: PUSH
94332: LD_INT 0
94334: ST_TO_ADDR
// sReset := false ;
94335: LD_ADDR_EXP 120
94339: PUSH
94340: LD_INT 0
94342: ST_TO_ADDR
// sSun := false ;
94343: LD_ADDR_EXP 121
94347: PUSH
94348: LD_INT 0
94350: ST_TO_ADDR
// sTiger := false ;
94351: LD_ADDR_EXP 117
94355: PUSH
94356: LD_INT 0
94358: ST_TO_ADDR
// sBomb := false ;
94359: LD_ADDR_EXP 118
94363: PUSH
94364: LD_INT 0
94366: ST_TO_ADDR
// sWound := false ;
94367: LD_ADDR_EXP 126
94371: PUSH
94372: LD_INT 0
94374: ST_TO_ADDR
// sBetray := false ;
94375: LD_ADDR_EXP 130
94379: PUSH
94380: LD_INT 0
94382: ST_TO_ADDR
// sContamin := false ;
94383: LD_ADDR_EXP 131
94387: PUSH
94388: LD_INT 0
94390: ST_TO_ADDR
// sOil := false ;
94391: LD_ADDR_EXP 133
94395: PUSH
94396: LD_INT 0
94398: ST_TO_ADDR
// sStu := false ;
94399: LD_ADDR_EXP 137
94403: PUSH
94404: LD_INT 0
94406: ST_TO_ADDR
// sBazooka := false ;
94407: LD_ADDR_EXP 140
94411: PUSH
94412: LD_INT 0
94414: ST_TO_ADDR
// sMortar := false ;
94415: LD_ADDR_EXP 141
94419: PUSH
94420: LD_INT 0
94422: ST_TO_ADDR
// sRanger := false ;
94423: LD_ADDR_EXP 151
94427: PUSH
94428: LD_INT 0
94430: ST_TO_ADDR
// sComputer := false ;
94431: LD_ADDR_EXP 152
94435: PUSH
94436: LD_INT 0
94438: ST_TO_ADDR
// s30 := false ;
94439: LD_ADDR_EXP 153
94443: PUSH
94444: LD_INT 0
94446: ST_TO_ADDR
// s60 := false ;
94447: LD_ADDR_EXP 154
94451: PUSH
94452: LD_INT 0
94454: ST_TO_ADDR
// end ;
94455: LD_VAR 0 1
94459: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
94460: LD_INT 0
94462: PPUSH
94463: PPUSH
94464: PPUSH
94465: PPUSH
94466: PPUSH
// result := [ ] ;
94467: LD_ADDR_VAR 0 1
94471: PUSH
94472: EMPTY
94473: ST_TO_ADDR
// if campaign_id = 1 then
94474: LD_OWVAR 69
94478: PUSH
94479: LD_INT 1
94481: EQUAL
94482: IFFALSE 97648
// begin case mission_number of 1 :
94484: LD_OWVAR 70
94488: PUSH
94489: LD_INT 1
94491: DOUBLE
94492: EQUAL
94493: IFTRUE 94497
94495: GO 94573
94497: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
94498: LD_ADDR_VAR 0 1
94502: PUSH
94503: LD_INT 2
94505: PUSH
94506: LD_INT 4
94508: PUSH
94509: LD_INT 11
94511: PUSH
94512: LD_INT 12
94514: PUSH
94515: LD_INT 15
94517: PUSH
94518: LD_INT 16
94520: PUSH
94521: LD_INT 22
94523: PUSH
94524: LD_INT 23
94526: PUSH
94527: LD_INT 26
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: PUSH
94541: LD_INT 101
94543: PUSH
94544: LD_INT 102
94546: PUSH
94547: LD_INT 106
94549: PUSH
94550: LD_INT 116
94552: PUSH
94553: LD_INT 117
94555: PUSH
94556: LD_INT 118
94558: PUSH
94559: EMPTY
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: ST_TO_ADDR
94571: GO 97646
94573: LD_INT 2
94575: DOUBLE
94576: EQUAL
94577: IFTRUE 94581
94579: GO 94665
94581: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94582: LD_ADDR_VAR 0 1
94586: PUSH
94587: LD_INT 2
94589: PUSH
94590: LD_INT 4
94592: PUSH
94593: LD_INT 11
94595: PUSH
94596: LD_INT 12
94598: PUSH
94599: LD_INT 15
94601: PUSH
94602: LD_INT 16
94604: PUSH
94605: LD_INT 22
94607: PUSH
94608: LD_INT 23
94610: PUSH
94611: LD_INT 26
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 101
94627: PUSH
94628: LD_INT 102
94630: PUSH
94631: LD_INT 105
94633: PUSH
94634: LD_INT 106
94636: PUSH
94637: LD_INT 108
94639: PUSH
94640: LD_INT 116
94642: PUSH
94643: LD_INT 117
94645: PUSH
94646: LD_INT 118
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: ST_TO_ADDR
94663: GO 97646
94665: LD_INT 3
94667: DOUBLE
94668: EQUAL
94669: IFTRUE 94673
94671: GO 94761
94673: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94674: LD_ADDR_VAR 0 1
94678: PUSH
94679: LD_INT 2
94681: PUSH
94682: LD_INT 4
94684: PUSH
94685: LD_INT 5
94687: PUSH
94688: LD_INT 11
94690: PUSH
94691: LD_INT 12
94693: PUSH
94694: LD_INT 15
94696: PUSH
94697: LD_INT 16
94699: PUSH
94700: LD_INT 22
94702: PUSH
94703: LD_INT 26
94705: PUSH
94706: LD_INT 36
94708: PUSH
94709: EMPTY
94710: LIST
94711: LIST
94712: LIST
94713: LIST
94714: LIST
94715: LIST
94716: LIST
94717: LIST
94718: LIST
94719: LIST
94720: PUSH
94721: LD_INT 101
94723: PUSH
94724: LD_INT 102
94726: PUSH
94727: LD_INT 105
94729: PUSH
94730: LD_INT 106
94732: PUSH
94733: LD_INT 108
94735: PUSH
94736: LD_INT 116
94738: PUSH
94739: LD_INT 117
94741: PUSH
94742: LD_INT 118
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: ST_TO_ADDR
94759: GO 97646
94761: LD_INT 4
94763: DOUBLE
94764: EQUAL
94765: IFTRUE 94769
94767: GO 94865
94769: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94770: LD_ADDR_VAR 0 1
94774: PUSH
94775: LD_INT 2
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: LD_INT 5
94783: PUSH
94784: LD_INT 8
94786: PUSH
94787: LD_INT 11
94789: PUSH
94790: LD_INT 12
94792: PUSH
94793: LD_INT 15
94795: PUSH
94796: LD_INT 16
94798: PUSH
94799: LD_INT 22
94801: PUSH
94802: LD_INT 23
94804: PUSH
94805: LD_INT 26
94807: PUSH
94808: LD_INT 36
94810: PUSH
94811: EMPTY
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 101
94827: PUSH
94828: LD_INT 102
94830: PUSH
94831: LD_INT 105
94833: PUSH
94834: LD_INT 106
94836: PUSH
94837: LD_INT 108
94839: PUSH
94840: LD_INT 116
94842: PUSH
94843: LD_INT 117
94845: PUSH
94846: LD_INT 118
94848: PUSH
94849: EMPTY
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: ST_TO_ADDR
94863: GO 97646
94865: LD_INT 5
94867: DOUBLE
94868: EQUAL
94869: IFTRUE 94873
94871: GO 94985
94873: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94874: LD_ADDR_VAR 0 1
94878: PUSH
94879: LD_INT 2
94881: PUSH
94882: LD_INT 4
94884: PUSH
94885: LD_INT 5
94887: PUSH
94888: LD_INT 6
94890: PUSH
94891: LD_INT 8
94893: PUSH
94894: LD_INT 11
94896: PUSH
94897: LD_INT 12
94899: PUSH
94900: LD_INT 15
94902: PUSH
94903: LD_INT 16
94905: PUSH
94906: LD_INT 22
94908: PUSH
94909: LD_INT 23
94911: PUSH
94912: LD_INT 25
94914: PUSH
94915: LD_INT 26
94917: PUSH
94918: LD_INT 36
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: PUSH
94937: LD_INT 101
94939: PUSH
94940: LD_INT 102
94942: PUSH
94943: LD_INT 105
94945: PUSH
94946: LD_INT 106
94948: PUSH
94949: LD_INT 108
94951: PUSH
94952: LD_INT 109
94954: PUSH
94955: LD_INT 112
94957: PUSH
94958: LD_INT 116
94960: PUSH
94961: LD_INT 117
94963: PUSH
94964: LD_INT 118
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: ST_TO_ADDR
94983: GO 97646
94985: LD_INT 6
94987: DOUBLE
94988: EQUAL
94989: IFTRUE 94993
94991: GO 95125
94993: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94994: LD_ADDR_VAR 0 1
94998: PUSH
94999: LD_INT 2
95001: PUSH
95002: LD_INT 4
95004: PUSH
95005: LD_INT 5
95007: PUSH
95008: LD_INT 6
95010: PUSH
95011: LD_INT 8
95013: PUSH
95014: LD_INT 11
95016: PUSH
95017: LD_INT 12
95019: PUSH
95020: LD_INT 15
95022: PUSH
95023: LD_INT 16
95025: PUSH
95026: LD_INT 20
95028: PUSH
95029: LD_INT 21
95031: PUSH
95032: LD_INT 22
95034: PUSH
95035: LD_INT 23
95037: PUSH
95038: LD_INT 25
95040: PUSH
95041: LD_INT 26
95043: PUSH
95044: LD_INT 30
95046: PUSH
95047: LD_INT 31
95049: PUSH
95050: LD_INT 32
95052: PUSH
95053: LD_INT 36
95055: PUSH
95056: EMPTY
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: PUSH
95077: LD_INT 101
95079: PUSH
95080: LD_INT 102
95082: PUSH
95083: LD_INT 105
95085: PUSH
95086: LD_INT 106
95088: PUSH
95089: LD_INT 108
95091: PUSH
95092: LD_INT 109
95094: PUSH
95095: LD_INT 112
95097: PUSH
95098: LD_INT 116
95100: PUSH
95101: LD_INT 117
95103: PUSH
95104: LD_INT 118
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: PUSH
95119: EMPTY
95120: LIST
95121: LIST
95122: ST_TO_ADDR
95123: GO 97646
95125: LD_INT 7
95127: DOUBLE
95128: EQUAL
95129: IFTRUE 95133
95131: GO 95245
95133: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
95134: LD_ADDR_VAR 0 1
95138: PUSH
95139: LD_INT 2
95141: PUSH
95142: LD_INT 4
95144: PUSH
95145: LD_INT 5
95147: PUSH
95148: LD_INT 7
95150: PUSH
95151: LD_INT 11
95153: PUSH
95154: LD_INT 12
95156: PUSH
95157: LD_INT 15
95159: PUSH
95160: LD_INT 16
95162: PUSH
95163: LD_INT 20
95165: PUSH
95166: LD_INT 21
95168: PUSH
95169: LD_INT 22
95171: PUSH
95172: LD_INT 23
95174: PUSH
95175: LD_INT 25
95177: PUSH
95178: LD_INT 26
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 101
95199: PUSH
95200: LD_INT 102
95202: PUSH
95203: LD_INT 103
95205: PUSH
95206: LD_INT 105
95208: PUSH
95209: LD_INT 106
95211: PUSH
95212: LD_INT 108
95214: PUSH
95215: LD_INT 112
95217: PUSH
95218: LD_INT 116
95220: PUSH
95221: LD_INT 117
95223: PUSH
95224: LD_INT 118
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: ST_TO_ADDR
95243: GO 97646
95245: LD_INT 8
95247: DOUBLE
95248: EQUAL
95249: IFTRUE 95253
95251: GO 95393
95253: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
95254: LD_ADDR_VAR 0 1
95258: PUSH
95259: LD_INT 2
95261: PUSH
95262: LD_INT 4
95264: PUSH
95265: LD_INT 5
95267: PUSH
95268: LD_INT 6
95270: PUSH
95271: LD_INT 7
95273: PUSH
95274: LD_INT 8
95276: PUSH
95277: LD_INT 11
95279: PUSH
95280: LD_INT 12
95282: PUSH
95283: LD_INT 15
95285: PUSH
95286: LD_INT 16
95288: PUSH
95289: LD_INT 20
95291: PUSH
95292: LD_INT 21
95294: PUSH
95295: LD_INT 22
95297: PUSH
95298: LD_INT 23
95300: PUSH
95301: LD_INT 25
95303: PUSH
95304: LD_INT 26
95306: PUSH
95307: LD_INT 30
95309: PUSH
95310: LD_INT 31
95312: PUSH
95313: LD_INT 32
95315: PUSH
95316: LD_INT 36
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: PUSH
95341: LD_INT 101
95343: PUSH
95344: LD_INT 102
95346: PUSH
95347: LD_INT 103
95349: PUSH
95350: LD_INT 105
95352: PUSH
95353: LD_INT 106
95355: PUSH
95356: LD_INT 108
95358: PUSH
95359: LD_INT 109
95361: PUSH
95362: LD_INT 112
95364: PUSH
95365: LD_INT 116
95367: PUSH
95368: LD_INT 117
95370: PUSH
95371: LD_INT 118
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: ST_TO_ADDR
95391: GO 97646
95393: LD_INT 9
95395: DOUBLE
95396: EQUAL
95397: IFTRUE 95401
95399: GO 95549
95401: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
95402: LD_ADDR_VAR 0 1
95406: PUSH
95407: LD_INT 2
95409: PUSH
95410: LD_INT 4
95412: PUSH
95413: LD_INT 5
95415: PUSH
95416: LD_INT 6
95418: PUSH
95419: LD_INT 7
95421: PUSH
95422: LD_INT 8
95424: PUSH
95425: LD_INT 11
95427: PUSH
95428: LD_INT 12
95430: PUSH
95431: LD_INT 15
95433: PUSH
95434: LD_INT 16
95436: PUSH
95437: LD_INT 20
95439: PUSH
95440: LD_INT 21
95442: PUSH
95443: LD_INT 22
95445: PUSH
95446: LD_INT 23
95448: PUSH
95449: LD_INT 25
95451: PUSH
95452: LD_INT 26
95454: PUSH
95455: LD_INT 28
95457: PUSH
95458: LD_INT 30
95460: PUSH
95461: LD_INT 31
95463: PUSH
95464: LD_INT 32
95466: PUSH
95467: LD_INT 36
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 101
95495: PUSH
95496: LD_INT 102
95498: PUSH
95499: LD_INT 103
95501: PUSH
95502: LD_INT 105
95504: PUSH
95505: LD_INT 106
95507: PUSH
95508: LD_INT 108
95510: PUSH
95511: LD_INT 109
95513: PUSH
95514: LD_INT 112
95516: PUSH
95517: LD_INT 114
95519: PUSH
95520: LD_INT 116
95522: PUSH
95523: LD_INT 117
95525: PUSH
95526: LD_INT 118
95528: PUSH
95529: EMPTY
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: ST_TO_ADDR
95547: GO 97646
95549: LD_INT 10
95551: DOUBLE
95552: EQUAL
95553: IFTRUE 95557
95555: GO 95753
95557: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
95558: LD_ADDR_VAR 0 1
95562: PUSH
95563: LD_INT 2
95565: PUSH
95566: LD_INT 4
95568: PUSH
95569: LD_INT 5
95571: PUSH
95572: LD_INT 6
95574: PUSH
95575: LD_INT 7
95577: PUSH
95578: LD_INT 8
95580: PUSH
95581: LD_INT 9
95583: PUSH
95584: LD_INT 10
95586: PUSH
95587: LD_INT 11
95589: PUSH
95590: LD_INT 12
95592: PUSH
95593: LD_INT 13
95595: PUSH
95596: LD_INT 14
95598: PUSH
95599: LD_INT 15
95601: PUSH
95602: LD_INT 16
95604: PUSH
95605: LD_INT 17
95607: PUSH
95608: LD_INT 18
95610: PUSH
95611: LD_INT 19
95613: PUSH
95614: LD_INT 20
95616: PUSH
95617: LD_INT 21
95619: PUSH
95620: LD_INT 22
95622: PUSH
95623: LD_INT 23
95625: PUSH
95626: LD_INT 24
95628: PUSH
95629: LD_INT 25
95631: PUSH
95632: LD_INT 26
95634: PUSH
95635: LD_INT 28
95637: PUSH
95638: LD_INT 30
95640: PUSH
95641: LD_INT 31
95643: PUSH
95644: LD_INT 32
95646: PUSH
95647: LD_INT 36
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: PUSH
95681: LD_INT 101
95683: PUSH
95684: LD_INT 102
95686: PUSH
95687: LD_INT 103
95689: PUSH
95690: LD_INT 104
95692: PUSH
95693: LD_INT 105
95695: PUSH
95696: LD_INT 106
95698: PUSH
95699: LD_INT 107
95701: PUSH
95702: LD_INT 108
95704: PUSH
95705: LD_INT 109
95707: PUSH
95708: LD_INT 110
95710: PUSH
95711: LD_INT 111
95713: PUSH
95714: LD_INT 112
95716: PUSH
95717: LD_INT 114
95719: PUSH
95720: LD_INT 116
95722: PUSH
95723: LD_INT 117
95725: PUSH
95726: LD_INT 118
95728: PUSH
95729: EMPTY
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: ST_TO_ADDR
95751: GO 97646
95753: LD_INT 11
95755: DOUBLE
95756: EQUAL
95757: IFTRUE 95761
95759: GO 95965
95761: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95762: LD_ADDR_VAR 0 1
95766: PUSH
95767: LD_INT 2
95769: PUSH
95770: LD_INT 3
95772: PUSH
95773: LD_INT 4
95775: PUSH
95776: LD_INT 5
95778: PUSH
95779: LD_INT 6
95781: PUSH
95782: LD_INT 7
95784: PUSH
95785: LD_INT 8
95787: PUSH
95788: LD_INT 9
95790: PUSH
95791: LD_INT 10
95793: PUSH
95794: LD_INT 11
95796: PUSH
95797: LD_INT 12
95799: PUSH
95800: LD_INT 13
95802: PUSH
95803: LD_INT 14
95805: PUSH
95806: LD_INT 15
95808: PUSH
95809: LD_INT 16
95811: PUSH
95812: LD_INT 17
95814: PUSH
95815: LD_INT 18
95817: PUSH
95818: LD_INT 19
95820: PUSH
95821: LD_INT 20
95823: PUSH
95824: LD_INT 21
95826: PUSH
95827: LD_INT 22
95829: PUSH
95830: LD_INT 23
95832: PUSH
95833: LD_INT 24
95835: PUSH
95836: LD_INT 25
95838: PUSH
95839: LD_INT 26
95841: PUSH
95842: LD_INT 28
95844: PUSH
95845: LD_INT 30
95847: PUSH
95848: LD_INT 31
95850: PUSH
95851: LD_INT 32
95853: PUSH
95854: LD_INT 34
95856: PUSH
95857: LD_INT 36
95859: PUSH
95860: EMPTY
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: PUSH
95893: LD_INT 101
95895: PUSH
95896: LD_INT 102
95898: PUSH
95899: LD_INT 103
95901: PUSH
95902: LD_INT 104
95904: PUSH
95905: LD_INT 105
95907: PUSH
95908: LD_INT 106
95910: PUSH
95911: LD_INT 107
95913: PUSH
95914: LD_INT 108
95916: PUSH
95917: LD_INT 109
95919: PUSH
95920: LD_INT 110
95922: PUSH
95923: LD_INT 111
95925: PUSH
95926: LD_INT 112
95928: PUSH
95929: LD_INT 114
95931: PUSH
95932: LD_INT 116
95934: PUSH
95935: LD_INT 117
95937: PUSH
95938: LD_INT 118
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: LIST
95956: LIST
95957: LIST
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: ST_TO_ADDR
95963: GO 97646
95965: LD_INT 12
95967: DOUBLE
95968: EQUAL
95969: IFTRUE 95973
95971: GO 96193
95973: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95974: LD_ADDR_VAR 0 1
95978: PUSH
95979: LD_INT 1
95981: PUSH
95982: LD_INT 2
95984: PUSH
95985: LD_INT 3
95987: PUSH
95988: LD_INT 4
95990: PUSH
95991: LD_INT 5
95993: PUSH
95994: LD_INT 6
95996: PUSH
95997: LD_INT 7
95999: PUSH
96000: LD_INT 8
96002: PUSH
96003: LD_INT 9
96005: PUSH
96006: LD_INT 10
96008: PUSH
96009: LD_INT 11
96011: PUSH
96012: LD_INT 12
96014: PUSH
96015: LD_INT 13
96017: PUSH
96018: LD_INT 14
96020: PUSH
96021: LD_INT 15
96023: PUSH
96024: LD_INT 16
96026: PUSH
96027: LD_INT 17
96029: PUSH
96030: LD_INT 18
96032: PUSH
96033: LD_INT 19
96035: PUSH
96036: LD_INT 20
96038: PUSH
96039: LD_INT 21
96041: PUSH
96042: LD_INT 22
96044: PUSH
96045: LD_INT 23
96047: PUSH
96048: LD_INT 24
96050: PUSH
96051: LD_INT 25
96053: PUSH
96054: LD_INT 26
96056: PUSH
96057: LD_INT 27
96059: PUSH
96060: LD_INT 28
96062: PUSH
96063: LD_INT 30
96065: PUSH
96066: LD_INT 31
96068: PUSH
96069: LD_INT 32
96071: PUSH
96072: LD_INT 33
96074: PUSH
96075: LD_INT 34
96077: PUSH
96078: LD_INT 36
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: LIST
96089: LIST
96090: LIST
96091: LIST
96092: LIST
96093: LIST
96094: LIST
96095: LIST
96096: LIST
96097: LIST
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 101
96119: PUSH
96120: LD_INT 102
96122: PUSH
96123: LD_INT 103
96125: PUSH
96126: LD_INT 104
96128: PUSH
96129: LD_INT 105
96131: PUSH
96132: LD_INT 106
96134: PUSH
96135: LD_INT 107
96137: PUSH
96138: LD_INT 108
96140: PUSH
96141: LD_INT 109
96143: PUSH
96144: LD_INT 110
96146: PUSH
96147: LD_INT 111
96149: PUSH
96150: LD_INT 112
96152: PUSH
96153: LD_INT 113
96155: PUSH
96156: LD_INT 114
96158: PUSH
96159: LD_INT 116
96161: PUSH
96162: LD_INT 117
96164: PUSH
96165: LD_INT 118
96167: PUSH
96168: EMPTY
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: LIST
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: ST_TO_ADDR
96191: GO 97646
96193: LD_INT 13
96195: DOUBLE
96196: EQUAL
96197: IFTRUE 96201
96199: GO 96409
96201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
96202: LD_ADDR_VAR 0 1
96206: PUSH
96207: LD_INT 1
96209: PUSH
96210: LD_INT 2
96212: PUSH
96213: LD_INT 3
96215: PUSH
96216: LD_INT 4
96218: PUSH
96219: LD_INT 5
96221: PUSH
96222: LD_INT 8
96224: PUSH
96225: LD_INT 9
96227: PUSH
96228: LD_INT 10
96230: PUSH
96231: LD_INT 11
96233: PUSH
96234: LD_INT 12
96236: PUSH
96237: LD_INT 14
96239: PUSH
96240: LD_INT 15
96242: PUSH
96243: LD_INT 16
96245: PUSH
96246: LD_INT 17
96248: PUSH
96249: LD_INT 18
96251: PUSH
96252: LD_INT 19
96254: PUSH
96255: LD_INT 20
96257: PUSH
96258: LD_INT 21
96260: PUSH
96261: LD_INT 22
96263: PUSH
96264: LD_INT 23
96266: PUSH
96267: LD_INT 24
96269: PUSH
96270: LD_INT 25
96272: PUSH
96273: LD_INT 26
96275: PUSH
96276: LD_INT 27
96278: PUSH
96279: LD_INT 28
96281: PUSH
96282: LD_INT 30
96284: PUSH
96285: LD_INT 31
96287: PUSH
96288: LD_INT 32
96290: PUSH
96291: LD_INT 33
96293: PUSH
96294: LD_INT 34
96296: PUSH
96297: LD_INT 36
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 101
96335: PUSH
96336: LD_INT 102
96338: PUSH
96339: LD_INT 103
96341: PUSH
96342: LD_INT 104
96344: PUSH
96345: LD_INT 105
96347: PUSH
96348: LD_INT 106
96350: PUSH
96351: LD_INT 107
96353: PUSH
96354: LD_INT 108
96356: PUSH
96357: LD_INT 109
96359: PUSH
96360: LD_INT 110
96362: PUSH
96363: LD_INT 111
96365: PUSH
96366: LD_INT 112
96368: PUSH
96369: LD_INT 113
96371: PUSH
96372: LD_INT 114
96374: PUSH
96375: LD_INT 116
96377: PUSH
96378: LD_INT 117
96380: PUSH
96381: LD_INT 118
96383: PUSH
96384: EMPTY
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: PUSH
96403: EMPTY
96404: LIST
96405: LIST
96406: ST_TO_ADDR
96407: GO 97646
96409: LD_INT 14
96411: DOUBLE
96412: EQUAL
96413: IFTRUE 96417
96415: GO 96641
96417: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
96418: LD_ADDR_VAR 0 1
96422: PUSH
96423: LD_INT 1
96425: PUSH
96426: LD_INT 2
96428: PUSH
96429: LD_INT 3
96431: PUSH
96432: LD_INT 4
96434: PUSH
96435: LD_INT 5
96437: PUSH
96438: LD_INT 6
96440: PUSH
96441: LD_INT 7
96443: PUSH
96444: LD_INT 8
96446: PUSH
96447: LD_INT 9
96449: PUSH
96450: LD_INT 10
96452: PUSH
96453: LD_INT 11
96455: PUSH
96456: LD_INT 12
96458: PUSH
96459: LD_INT 13
96461: PUSH
96462: LD_INT 14
96464: PUSH
96465: LD_INT 15
96467: PUSH
96468: LD_INT 16
96470: PUSH
96471: LD_INT 17
96473: PUSH
96474: LD_INT 18
96476: PUSH
96477: LD_INT 19
96479: PUSH
96480: LD_INT 20
96482: PUSH
96483: LD_INT 21
96485: PUSH
96486: LD_INT 22
96488: PUSH
96489: LD_INT 23
96491: PUSH
96492: LD_INT 24
96494: PUSH
96495: LD_INT 25
96497: PUSH
96498: LD_INT 26
96500: PUSH
96501: LD_INT 27
96503: PUSH
96504: LD_INT 28
96506: PUSH
96507: LD_INT 29
96509: PUSH
96510: LD_INT 30
96512: PUSH
96513: LD_INT 31
96515: PUSH
96516: LD_INT 32
96518: PUSH
96519: LD_INT 33
96521: PUSH
96522: LD_INT 34
96524: PUSH
96525: LD_INT 36
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: LIST
96541: LIST
96542: LIST
96543: LIST
96544: LIST
96545: LIST
96546: LIST
96547: LIST
96548: LIST
96549: LIST
96550: LIST
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: LIST
96558: LIST
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: PUSH
96565: LD_INT 101
96567: PUSH
96568: LD_INT 102
96570: PUSH
96571: LD_INT 103
96573: PUSH
96574: LD_INT 104
96576: PUSH
96577: LD_INT 105
96579: PUSH
96580: LD_INT 106
96582: PUSH
96583: LD_INT 107
96585: PUSH
96586: LD_INT 108
96588: PUSH
96589: LD_INT 109
96591: PUSH
96592: LD_INT 110
96594: PUSH
96595: LD_INT 111
96597: PUSH
96598: LD_INT 112
96600: PUSH
96601: LD_INT 113
96603: PUSH
96604: LD_INT 114
96606: PUSH
96607: LD_INT 116
96609: PUSH
96610: LD_INT 117
96612: PUSH
96613: LD_INT 118
96615: PUSH
96616: EMPTY
96617: LIST
96618: LIST
96619: LIST
96620: LIST
96621: LIST
96622: LIST
96623: LIST
96624: LIST
96625: LIST
96626: LIST
96627: LIST
96628: LIST
96629: LIST
96630: LIST
96631: LIST
96632: LIST
96633: LIST
96634: PUSH
96635: EMPTY
96636: LIST
96637: LIST
96638: ST_TO_ADDR
96639: GO 97646
96641: LD_INT 15
96643: DOUBLE
96644: EQUAL
96645: IFTRUE 96649
96647: GO 96873
96649: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96650: LD_ADDR_VAR 0 1
96654: PUSH
96655: LD_INT 1
96657: PUSH
96658: LD_INT 2
96660: PUSH
96661: LD_INT 3
96663: PUSH
96664: LD_INT 4
96666: PUSH
96667: LD_INT 5
96669: PUSH
96670: LD_INT 6
96672: PUSH
96673: LD_INT 7
96675: PUSH
96676: LD_INT 8
96678: PUSH
96679: LD_INT 9
96681: PUSH
96682: LD_INT 10
96684: PUSH
96685: LD_INT 11
96687: PUSH
96688: LD_INT 12
96690: PUSH
96691: LD_INT 13
96693: PUSH
96694: LD_INT 14
96696: PUSH
96697: LD_INT 15
96699: PUSH
96700: LD_INT 16
96702: PUSH
96703: LD_INT 17
96705: PUSH
96706: LD_INT 18
96708: PUSH
96709: LD_INT 19
96711: PUSH
96712: LD_INT 20
96714: PUSH
96715: LD_INT 21
96717: PUSH
96718: LD_INT 22
96720: PUSH
96721: LD_INT 23
96723: PUSH
96724: LD_INT 24
96726: PUSH
96727: LD_INT 25
96729: PUSH
96730: LD_INT 26
96732: PUSH
96733: LD_INT 27
96735: PUSH
96736: LD_INT 28
96738: PUSH
96739: LD_INT 29
96741: PUSH
96742: LD_INT 30
96744: PUSH
96745: LD_INT 31
96747: PUSH
96748: LD_INT 32
96750: PUSH
96751: LD_INT 33
96753: PUSH
96754: LD_INT 34
96756: PUSH
96757: LD_INT 36
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: LIST
96782: LIST
96783: LIST
96784: LIST
96785: LIST
96786: LIST
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 101
96799: PUSH
96800: LD_INT 102
96802: PUSH
96803: LD_INT 103
96805: PUSH
96806: LD_INT 104
96808: PUSH
96809: LD_INT 105
96811: PUSH
96812: LD_INT 106
96814: PUSH
96815: LD_INT 107
96817: PUSH
96818: LD_INT 108
96820: PUSH
96821: LD_INT 109
96823: PUSH
96824: LD_INT 110
96826: PUSH
96827: LD_INT 111
96829: PUSH
96830: LD_INT 112
96832: PUSH
96833: LD_INT 113
96835: PUSH
96836: LD_INT 114
96838: PUSH
96839: LD_INT 116
96841: PUSH
96842: LD_INT 117
96844: PUSH
96845: LD_INT 118
96847: PUSH
96848: EMPTY
96849: LIST
96850: LIST
96851: LIST
96852: LIST
96853: LIST
96854: LIST
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: LIST
96862: LIST
96863: LIST
96864: LIST
96865: LIST
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: ST_TO_ADDR
96871: GO 97646
96873: LD_INT 16
96875: DOUBLE
96876: EQUAL
96877: IFTRUE 96881
96879: GO 97017
96881: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96882: LD_ADDR_VAR 0 1
96886: PUSH
96887: LD_INT 2
96889: PUSH
96890: LD_INT 4
96892: PUSH
96893: LD_INT 5
96895: PUSH
96896: LD_INT 7
96898: PUSH
96899: LD_INT 11
96901: PUSH
96902: LD_INT 12
96904: PUSH
96905: LD_INT 15
96907: PUSH
96908: LD_INT 16
96910: PUSH
96911: LD_INT 20
96913: PUSH
96914: LD_INT 21
96916: PUSH
96917: LD_INT 22
96919: PUSH
96920: LD_INT 23
96922: PUSH
96923: LD_INT 25
96925: PUSH
96926: LD_INT 26
96928: PUSH
96929: LD_INT 30
96931: PUSH
96932: LD_INT 31
96934: PUSH
96935: LD_INT 32
96937: PUSH
96938: LD_INT 33
96940: PUSH
96941: LD_INT 34
96943: PUSH
96944: EMPTY
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: PUSH
96965: LD_INT 101
96967: PUSH
96968: LD_INT 102
96970: PUSH
96971: LD_INT 103
96973: PUSH
96974: LD_INT 106
96976: PUSH
96977: LD_INT 108
96979: PUSH
96980: LD_INT 112
96982: PUSH
96983: LD_INT 113
96985: PUSH
96986: LD_INT 114
96988: PUSH
96989: LD_INT 116
96991: PUSH
96992: LD_INT 117
96994: PUSH
96995: LD_INT 118
96997: PUSH
96998: EMPTY
96999: LIST
97000: LIST
97001: LIST
97002: LIST
97003: LIST
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: ST_TO_ADDR
97015: GO 97646
97017: LD_INT 17
97019: DOUBLE
97020: EQUAL
97021: IFTRUE 97025
97023: GO 97249
97025: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
97026: LD_ADDR_VAR 0 1
97030: PUSH
97031: LD_INT 1
97033: PUSH
97034: LD_INT 2
97036: PUSH
97037: LD_INT 3
97039: PUSH
97040: LD_INT 4
97042: PUSH
97043: LD_INT 5
97045: PUSH
97046: LD_INT 6
97048: PUSH
97049: LD_INT 7
97051: PUSH
97052: LD_INT 8
97054: PUSH
97055: LD_INT 9
97057: PUSH
97058: LD_INT 10
97060: PUSH
97061: LD_INT 11
97063: PUSH
97064: LD_INT 12
97066: PUSH
97067: LD_INT 13
97069: PUSH
97070: LD_INT 14
97072: PUSH
97073: LD_INT 15
97075: PUSH
97076: LD_INT 16
97078: PUSH
97079: LD_INT 17
97081: PUSH
97082: LD_INT 18
97084: PUSH
97085: LD_INT 19
97087: PUSH
97088: LD_INT 20
97090: PUSH
97091: LD_INT 21
97093: PUSH
97094: LD_INT 22
97096: PUSH
97097: LD_INT 23
97099: PUSH
97100: LD_INT 24
97102: PUSH
97103: LD_INT 25
97105: PUSH
97106: LD_INT 26
97108: PUSH
97109: LD_INT 27
97111: PUSH
97112: LD_INT 28
97114: PUSH
97115: LD_INT 29
97117: PUSH
97118: LD_INT 30
97120: PUSH
97121: LD_INT 31
97123: PUSH
97124: LD_INT 32
97126: PUSH
97127: LD_INT 33
97129: PUSH
97130: LD_INT 34
97132: PUSH
97133: LD_INT 36
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: LIST
97170: LIST
97171: LIST
97172: PUSH
97173: LD_INT 101
97175: PUSH
97176: LD_INT 102
97178: PUSH
97179: LD_INT 103
97181: PUSH
97182: LD_INT 104
97184: PUSH
97185: LD_INT 105
97187: PUSH
97188: LD_INT 106
97190: PUSH
97191: LD_INT 107
97193: PUSH
97194: LD_INT 108
97196: PUSH
97197: LD_INT 109
97199: PUSH
97200: LD_INT 110
97202: PUSH
97203: LD_INT 111
97205: PUSH
97206: LD_INT 112
97208: PUSH
97209: LD_INT 113
97211: PUSH
97212: LD_INT 114
97214: PUSH
97215: LD_INT 116
97217: PUSH
97218: LD_INT 117
97220: PUSH
97221: LD_INT 118
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: LIST
97241: LIST
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: ST_TO_ADDR
97247: GO 97646
97249: LD_INT 18
97251: DOUBLE
97252: EQUAL
97253: IFTRUE 97257
97255: GO 97405
97257: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
97258: LD_ADDR_VAR 0 1
97262: PUSH
97263: LD_INT 2
97265: PUSH
97266: LD_INT 4
97268: PUSH
97269: LD_INT 5
97271: PUSH
97272: LD_INT 7
97274: PUSH
97275: LD_INT 11
97277: PUSH
97278: LD_INT 12
97280: PUSH
97281: LD_INT 15
97283: PUSH
97284: LD_INT 16
97286: PUSH
97287: LD_INT 20
97289: PUSH
97290: LD_INT 21
97292: PUSH
97293: LD_INT 22
97295: PUSH
97296: LD_INT 23
97298: PUSH
97299: LD_INT 25
97301: PUSH
97302: LD_INT 26
97304: PUSH
97305: LD_INT 30
97307: PUSH
97308: LD_INT 31
97310: PUSH
97311: LD_INT 32
97313: PUSH
97314: LD_INT 33
97316: PUSH
97317: LD_INT 34
97319: PUSH
97320: LD_INT 35
97322: PUSH
97323: LD_INT 36
97325: PUSH
97326: EMPTY
97327: LIST
97328: LIST
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: LIST
97337: LIST
97338: LIST
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: LIST
97346: LIST
97347: LIST
97348: PUSH
97349: LD_INT 101
97351: PUSH
97352: LD_INT 102
97354: PUSH
97355: LD_INT 103
97357: PUSH
97358: LD_INT 106
97360: PUSH
97361: LD_INT 108
97363: PUSH
97364: LD_INT 112
97366: PUSH
97367: LD_INT 113
97369: PUSH
97370: LD_INT 114
97372: PUSH
97373: LD_INT 115
97375: PUSH
97376: LD_INT 116
97378: PUSH
97379: LD_INT 117
97381: PUSH
97382: LD_INT 118
97384: PUSH
97385: EMPTY
97386: LIST
97387: LIST
97388: LIST
97389: LIST
97390: LIST
97391: LIST
97392: LIST
97393: LIST
97394: LIST
97395: LIST
97396: LIST
97397: LIST
97398: PUSH
97399: EMPTY
97400: LIST
97401: LIST
97402: ST_TO_ADDR
97403: GO 97646
97405: LD_INT 19
97407: DOUBLE
97408: EQUAL
97409: IFTRUE 97413
97411: GO 97645
97413: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
97414: LD_ADDR_VAR 0 1
97418: PUSH
97419: LD_INT 1
97421: PUSH
97422: LD_INT 2
97424: PUSH
97425: LD_INT 3
97427: PUSH
97428: LD_INT 4
97430: PUSH
97431: LD_INT 5
97433: PUSH
97434: LD_INT 6
97436: PUSH
97437: LD_INT 7
97439: PUSH
97440: LD_INT 8
97442: PUSH
97443: LD_INT 9
97445: PUSH
97446: LD_INT 10
97448: PUSH
97449: LD_INT 11
97451: PUSH
97452: LD_INT 12
97454: PUSH
97455: LD_INT 13
97457: PUSH
97458: LD_INT 14
97460: PUSH
97461: LD_INT 15
97463: PUSH
97464: LD_INT 16
97466: PUSH
97467: LD_INT 17
97469: PUSH
97470: LD_INT 18
97472: PUSH
97473: LD_INT 19
97475: PUSH
97476: LD_INT 20
97478: PUSH
97479: LD_INT 21
97481: PUSH
97482: LD_INT 22
97484: PUSH
97485: LD_INT 23
97487: PUSH
97488: LD_INT 24
97490: PUSH
97491: LD_INT 25
97493: PUSH
97494: LD_INT 26
97496: PUSH
97497: LD_INT 27
97499: PUSH
97500: LD_INT 28
97502: PUSH
97503: LD_INT 29
97505: PUSH
97506: LD_INT 30
97508: PUSH
97509: LD_INT 31
97511: PUSH
97512: LD_INT 32
97514: PUSH
97515: LD_INT 33
97517: PUSH
97518: LD_INT 34
97520: PUSH
97521: LD_INT 35
97523: PUSH
97524: LD_INT 36
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: LIST
97537: LIST
97538: LIST
97539: LIST
97540: LIST
97541: LIST
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 101
97567: PUSH
97568: LD_INT 102
97570: PUSH
97571: LD_INT 103
97573: PUSH
97574: LD_INT 104
97576: PUSH
97577: LD_INT 105
97579: PUSH
97580: LD_INT 106
97582: PUSH
97583: LD_INT 107
97585: PUSH
97586: LD_INT 108
97588: PUSH
97589: LD_INT 109
97591: PUSH
97592: LD_INT 110
97594: PUSH
97595: LD_INT 111
97597: PUSH
97598: LD_INT 112
97600: PUSH
97601: LD_INT 113
97603: PUSH
97604: LD_INT 114
97606: PUSH
97607: LD_INT 115
97609: PUSH
97610: LD_INT 116
97612: PUSH
97613: LD_INT 117
97615: PUSH
97616: LD_INT 118
97618: PUSH
97619: EMPTY
97620: LIST
97621: LIST
97622: LIST
97623: LIST
97624: LIST
97625: LIST
97626: LIST
97627: LIST
97628: LIST
97629: LIST
97630: LIST
97631: LIST
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: LIST
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: ST_TO_ADDR
97643: GO 97646
97645: POP
// end else
97646: GO 97877
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97648: LD_ADDR_VAR 0 1
97652: PUSH
97653: LD_INT 1
97655: PUSH
97656: LD_INT 2
97658: PUSH
97659: LD_INT 3
97661: PUSH
97662: LD_INT 4
97664: PUSH
97665: LD_INT 5
97667: PUSH
97668: LD_INT 6
97670: PUSH
97671: LD_INT 7
97673: PUSH
97674: LD_INT 8
97676: PUSH
97677: LD_INT 9
97679: PUSH
97680: LD_INT 10
97682: PUSH
97683: LD_INT 11
97685: PUSH
97686: LD_INT 12
97688: PUSH
97689: LD_INT 13
97691: PUSH
97692: LD_INT 14
97694: PUSH
97695: LD_INT 15
97697: PUSH
97698: LD_INT 16
97700: PUSH
97701: LD_INT 17
97703: PUSH
97704: LD_INT 18
97706: PUSH
97707: LD_INT 19
97709: PUSH
97710: LD_INT 20
97712: PUSH
97713: LD_INT 21
97715: PUSH
97716: LD_INT 22
97718: PUSH
97719: LD_INT 23
97721: PUSH
97722: LD_INT 24
97724: PUSH
97725: LD_INT 25
97727: PUSH
97728: LD_INT 26
97730: PUSH
97731: LD_INT 27
97733: PUSH
97734: LD_INT 28
97736: PUSH
97737: LD_INT 29
97739: PUSH
97740: LD_INT 30
97742: PUSH
97743: LD_INT 31
97745: PUSH
97746: LD_INT 32
97748: PUSH
97749: LD_INT 33
97751: PUSH
97752: LD_INT 34
97754: PUSH
97755: LD_INT 35
97757: PUSH
97758: LD_INT 36
97760: PUSH
97761: EMPTY
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: PUSH
97799: LD_INT 101
97801: PUSH
97802: LD_INT 102
97804: PUSH
97805: LD_INT 103
97807: PUSH
97808: LD_INT 104
97810: PUSH
97811: LD_INT 105
97813: PUSH
97814: LD_INT 106
97816: PUSH
97817: LD_INT 107
97819: PUSH
97820: LD_INT 108
97822: PUSH
97823: LD_INT 109
97825: PUSH
97826: LD_INT 110
97828: PUSH
97829: LD_INT 111
97831: PUSH
97832: LD_INT 112
97834: PUSH
97835: LD_INT 113
97837: PUSH
97838: LD_INT 114
97840: PUSH
97841: LD_INT 115
97843: PUSH
97844: LD_INT 116
97846: PUSH
97847: LD_INT 117
97849: PUSH
97850: LD_INT 118
97852: PUSH
97853: EMPTY
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: LIST
97863: LIST
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: PUSH
97873: EMPTY
97874: LIST
97875: LIST
97876: ST_TO_ADDR
// if result then
97877: LD_VAR 0 1
97881: IFFALSE 98170
// begin normal :=  ;
97883: LD_ADDR_VAR 0 3
97887: PUSH
97888: LD_STRING 
97890: ST_TO_ADDR
// hardcore :=  ;
97891: LD_ADDR_VAR 0 4
97895: PUSH
97896: LD_STRING 
97898: ST_TO_ADDR
// for i = 1 to normalCounter do
97899: LD_ADDR_VAR 0 5
97903: PUSH
97904: DOUBLE
97905: LD_INT 1
97907: DEC
97908: ST_TO_ADDR
97909: LD_EXP 99
97913: PUSH
97914: FOR_TO
97915: IFFALSE 98016
// begin tmp := 0 ;
97917: LD_ADDR_VAR 0 2
97921: PUSH
97922: LD_STRING 0
97924: ST_TO_ADDR
// if result [ 1 ] then
97925: LD_VAR 0 1
97929: PUSH
97930: LD_INT 1
97932: ARRAY
97933: IFFALSE 97998
// if result [ 1 ] [ 1 ] = i then
97935: LD_VAR 0 1
97939: PUSH
97940: LD_INT 1
97942: ARRAY
97943: PUSH
97944: LD_INT 1
97946: ARRAY
97947: PUSH
97948: LD_VAR 0 5
97952: EQUAL
97953: IFFALSE 97998
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97955: LD_ADDR_VAR 0 1
97959: PUSH
97960: LD_VAR 0 1
97964: PPUSH
97965: LD_INT 1
97967: PPUSH
97968: LD_VAR 0 1
97972: PUSH
97973: LD_INT 1
97975: ARRAY
97976: PPUSH
97977: LD_INT 1
97979: PPUSH
97980: CALL_OW 3
97984: PPUSH
97985: CALL_OW 1
97989: ST_TO_ADDR
// tmp := 1 ;
97990: LD_ADDR_VAR 0 2
97994: PUSH
97995: LD_STRING 1
97997: ST_TO_ADDR
// end ; normal := normal & tmp ;
97998: LD_ADDR_VAR 0 3
98002: PUSH
98003: LD_VAR 0 3
98007: PUSH
98008: LD_VAR 0 2
98012: STR
98013: ST_TO_ADDR
// end ;
98014: GO 97914
98016: POP
98017: POP
// for i = 1 to hardcoreCounter do
98018: LD_ADDR_VAR 0 5
98022: PUSH
98023: DOUBLE
98024: LD_INT 1
98026: DEC
98027: ST_TO_ADDR
98028: LD_EXP 100
98032: PUSH
98033: FOR_TO
98034: IFFALSE 98139
// begin tmp := 0 ;
98036: LD_ADDR_VAR 0 2
98040: PUSH
98041: LD_STRING 0
98043: ST_TO_ADDR
// if result [ 2 ] then
98044: LD_VAR 0 1
98048: PUSH
98049: LD_INT 2
98051: ARRAY
98052: IFFALSE 98121
// if result [ 2 ] [ 1 ] = 100 + i then
98054: LD_VAR 0 1
98058: PUSH
98059: LD_INT 2
98061: ARRAY
98062: PUSH
98063: LD_INT 1
98065: ARRAY
98066: PUSH
98067: LD_INT 100
98069: PUSH
98070: LD_VAR 0 5
98074: PLUS
98075: EQUAL
98076: IFFALSE 98121
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
98078: LD_ADDR_VAR 0 1
98082: PUSH
98083: LD_VAR 0 1
98087: PPUSH
98088: LD_INT 2
98090: PPUSH
98091: LD_VAR 0 1
98095: PUSH
98096: LD_INT 2
98098: ARRAY
98099: PPUSH
98100: LD_INT 1
98102: PPUSH
98103: CALL_OW 3
98107: PPUSH
98108: CALL_OW 1
98112: ST_TO_ADDR
// tmp := 1 ;
98113: LD_ADDR_VAR 0 2
98117: PUSH
98118: LD_STRING 1
98120: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
98121: LD_ADDR_VAR 0 4
98125: PUSH
98126: LD_VAR 0 4
98130: PUSH
98131: LD_VAR 0 2
98135: STR
98136: ST_TO_ADDR
// end ;
98137: GO 98033
98139: POP
98140: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
98141: LD_STRING getStreamItemsFromMission("
98143: PUSH
98144: LD_VAR 0 3
98148: STR
98149: PUSH
98150: LD_STRING ","
98152: STR
98153: PUSH
98154: LD_VAR 0 4
98158: STR
98159: PUSH
98160: LD_STRING ")
98162: STR
98163: PPUSH
98164: CALL_OW 559
// end else
98168: GO 98177
// ToLua ( getStreamItemsFromMission("","") ) ;
98170: LD_STRING getStreamItemsFromMission("","")
98172: PPUSH
98173: CALL_OW 559
// end ;
98177: LD_VAR 0 1
98181: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98182: LD_EXP 98
98186: PUSH
98187: LD_EXP 103
98191: AND
98192: IFFALSE 98316
98194: GO 98196
98196: DISABLE
98197: LD_INT 0
98199: PPUSH
98200: PPUSH
// begin enable ;
98201: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98202: LD_ADDR_VAR 0 2
98206: PUSH
98207: LD_INT 22
98209: PUSH
98210: LD_OWVAR 2
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: LD_INT 2
98221: PUSH
98222: LD_INT 34
98224: PUSH
98225: LD_INT 7
98227: PUSH
98228: EMPTY
98229: LIST
98230: LIST
98231: PUSH
98232: LD_INT 34
98234: PUSH
98235: LD_INT 45
98237: PUSH
98238: EMPTY
98239: LIST
98240: LIST
98241: PUSH
98242: LD_INT 34
98244: PUSH
98245: LD_INT 28
98247: PUSH
98248: EMPTY
98249: LIST
98250: LIST
98251: PUSH
98252: LD_INT 34
98254: PUSH
98255: LD_INT 47
98257: PUSH
98258: EMPTY
98259: LIST
98260: LIST
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: PUSH
98269: EMPTY
98270: LIST
98271: LIST
98272: PPUSH
98273: CALL_OW 69
98277: ST_TO_ADDR
// if not tmp then
98278: LD_VAR 0 2
98282: NOT
98283: IFFALSE 98287
// exit ;
98285: GO 98316
// for i in tmp do
98287: LD_ADDR_VAR 0 1
98291: PUSH
98292: LD_VAR 0 2
98296: PUSH
98297: FOR_IN
98298: IFFALSE 98314
// begin SetLives ( i , 0 ) ;
98300: LD_VAR 0 1
98304: PPUSH
98305: LD_INT 0
98307: PPUSH
98308: CALL_OW 234
// end ;
98312: GO 98297
98314: POP
98315: POP
// end ;
98316: PPOPN 2
98318: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98319: LD_EXP 98
98323: PUSH
98324: LD_EXP 104
98328: AND
98329: IFFALSE 98413
98331: GO 98333
98333: DISABLE
98334: LD_INT 0
98336: PPUSH
98337: PPUSH
// begin enable ;
98338: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98339: LD_ADDR_VAR 0 2
98343: PUSH
98344: LD_INT 22
98346: PUSH
98347: LD_OWVAR 2
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: LD_INT 32
98358: PUSH
98359: LD_INT 3
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PUSH
98366: EMPTY
98367: LIST
98368: LIST
98369: PPUSH
98370: CALL_OW 69
98374: ST_TO_ADDR
// if not tmp then
98375: LD_VAR 0 2
98379: NOT
98380: IFFALSE 98384
// exit ;
98382: GO 98413
// for i in tmp do
98384: LD_ADDR_VAR 0 1
98388: PUSH
98389: LD_VAR 0 2
98393: PUSH
98394: FOR_IN
98395: IFFALSE 98411
// begin SetLives ( i , 0 ) ;
98397: LD_VAR 0 1
98401: PPUSH
98402: LD_INT 0
98404: PPUSH
98405: CALL_OW 234
// end ;
98409: GO 98394
98411: POP
98412: POP
// end ;
98413: PPOPN 2
98415: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98416: LD_EXP 98
98420: PUSH
98421: LD_EXP 101
98425: AND
98426: IFFALSE 98519
98428: GO 98430
98430: DISABLE
98431: LD_INT 0
98433: PPUSH
// begin enable ;
98434: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98435: LD_ADDR_VAR 0 1
98439: PUSH
98440: LD_INT 22
98442: PUSH
98443: LD_OWVAR 2
98447: PUSH
98448: EMPTY
98449: LIST
98450: LIST
98451: PUSH
98452: LD_INT 2
98454: PUSH
98455: LD_INT 25
98457: PUSH
98458: LD_INT 5
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: PUSH
98465: LD_INT 25
98467: PUSH
98468: LD_INT 9
98470: PUSH
98471: EMPTY
98472: LIST
98473: LIST
98474: PUSH
98475: LD_INT 25
98477: PUSH
98478: LD_INT 8
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PUSH
98485: EMPTY
98486: LIST
98487: LIST
98488: LIST
98489: LIST
98490: PUSH
98491: EMPTY
98492: LIST
98493: LIST
98494: PPUSH
98495: CALL_OW 69
98499: PUSH
98500: FOR_IN
98501: IFFALSE 98517
// begin SetClass ( i , 1 ) ;
98503: LD_VAR 0 1
98507: PPUSH
98508: LD_INT 1
98510: PPUSH
98511: CALL_OW 336
// end ;
98515: GO 98500
98517: POP
98518: POP
// end ;
98519: PPOPN 1
98521: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98522: LD_EXP 98
98526: PUSH
98527: LD_EXP 102
98531: AND
98532: PUSH
98533: LD_OWVAR 65
98537: PUSH
98538: LD_INT 7
98540: LESS
98541: AND
98542: IFFALSE 98556
98544: GO 98546
98546: DISABLE
// begin enable ;
98547: ENABLE
// game_speed := 7 ;
98548: LD_ADDR_OWVAR 65
98552: PUSH
98553: LD_INT 7
98555: ST_TO_ADDR
// end ;
98556: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98557: LD_EXP 98
98561: PUSH
98562: LD_EXP 105
98566: AND
98567: IFFALSE 98769
98569: GO 98571
98571: DISABLE
98572: LD_INT 0
98574: PPUSH
98575: PPUSH
98576: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98577: LD_ADDR_VAR 0 3
98581: PUSH
98582: LD_INT 81
98584: PUSH
98585: LD_OWVAR 2
98589: PUSH
98590: EMPTY
98591: LIST
98592: LIST
98593: PUSH
98594: LD_INT 21
98596: PUSH
98597: LD_INT 1
98599: PUSH
98600: EMPTY
98601: LIST
98602: LIST
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PPUSH
98608: CALL_OW 69
98612: ST_TO_ADDR
// if not tmp then
98613: LD_VAR 0 3
98617: NOT
98618: IFFALSE 98622
// exit ;
98620: GO 98769
// if tmp > 5 then
98622: LD_VAR 0 3
98626: PUSH
98627: LD_INT 5
98629: GREATER
98630: IFFALSE 98642
// k := 5 else
98632: LD_ADDR_VAR 0 2
98636: PUSH
98637: LD_INT 5
98639: ST_TO_ADDR
98640: GO 98652
// k := tmp ;
98642: LD_ADDR_VAR 0 2
98646: PUSH
98647: LD_VAR 0 3
98651: ST_TO_ADDR
// for i := 1 to k do
98652: LD_ADDR_VAR 0 1
98656: PUSH
98657: DOUBLE
98658: LD_INT 1
98660: DEC
98661: ST_TO_ADDR
98662: LD_VAR 0 2
98666: PUSH
98667: FOR_TO
98668: IFFALSE 98767
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98670: LD_VAR 0 3
98674: PUSH
98675: LD_VAR 0 1
98679: ARRAY
98680: PPUSH
98681: LD_VAR 0 1
98685: PUSH
98686: LD_INT 4
98688: MOD
98689: PUSH
98690: LD_INT 1
98692: PLUS
98693: PPUSH
98694: CALL_OW 259
98698: PUSH
98699: LD_INT 10
98701: LESS
98702: IFFALSE 98765
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98704: LD_VAR 0 3
98708: PUSH
98709: LD_VAR 0 1
98713: ARRAY
98714: PPUSH
98715: LD_VAR 0 1
98719: PUSH
98720: LD_INT 4
98722: MOD
98723: PUSH
98724: LD_INT 1
98726: PLUS
98727: PPUSH
98728: LD_VAR 0 3
98732: PUSH
98733: LD_VAR 0 1
98737: ARRAY
98738: PPUSH
98739: LD_VAR 0 1
98743: PUSH
98744: LD_INT 4
98746: MOD
98747: PUSH
98748: LD_INT 1
98750: PLUS
98751: PPUSH
98752: CALL_OW 259
98756: PUSH
98757: LD_INT 1
98759: PLUS
98760: PPUSH
98761: CALL_OW 237
98765: GO 98667
98767: POP
98768: POP
// end ;
98769: PPOPN 3
98771: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98772: LD_EXP 98
98776: PUSH
98777: LD_EXP 106
98781: AND
98782: IFFALSE 98802
98784: GO 98786
98786: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98787: LD_INT 4
98789: PPUSH
98790: LD_OWVAR 2
98794: PPUSH
98795: LD_INT 0
98797: PPUSH
98798: CALL_OW 324
98802: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98803: LD_EXP 98
98807: PUSH
98808: LD_EXP 135
98812: AND
98813: IFFALSE 98833
98815: GO 98817
98817: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98818: LD_INT 19
98820: PPUSH
98821: LD_OWVAR 2
98825: PPUSH
98826: LD_INT 0
98828: PPUSH
98829: CALL_OW 324
98833: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98834: LD_EXP 98
98838: PUSH
98839: LD_EXP 107
98843: AND
98844: IFFALSE 98946
98846: GO 98848
98848: DISABLE
98849: LD_INT 0
98851: PPUSH
98852: PPUSH
// begin enable ;
98853: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98854: LD_ADDR_VAR 0 2
98858: PUSH
98859: LD_INT 22
98861: PUSH
98862: LD_OWVAR 2
98866: PUSH
98867: EMPTY
98868: LIST
98869: LIST
98870: PUSH
98871: LD_INT 2
98873: PUSH
98874: LD_INT 34
98876: PUSH
98877: LD_INT 11
98879: PUSH
98880: EMPTY
98881: LIST
98882: LIST
98883: PUSH
98884: LD_INT 34
98886: PUSH
98887: LD_INT 30
98889: PUSH
98890: EMPTY
98891: LIST
98892: LIST
98893: PUSH
98894: EMPTY
98895: LIST
98896: LIST
98897: LIST
98898: PUSH
98899: EMPTY
98900: LIST
98901: LIST
98902: PPUSH
98903: CALL_OW 69
98907: ST_TO_ADDR
// if not tmp then
98908: LD_VAR 0 2
98912: NOT
98913: IFFALSE 98917
// exit ;
98915: GO 98946
// for i in tmp do
98917: LD_ADDR_VAR 0 1
98921: PUSH
98922: LD_VAR 0 2
98926: PUSH
98927: FOR_IN
98928: IFFALSE 98944
// begin SetLives ( i , 0 ) ;
98930: LD_VAR 0 1
98934: PPUSH
98935: LD_INT 0
98937: PPUSH
98938: CALL_OW 234
// end ;
98942: GO 98927
98944: POP
98945: POP
// end ;
98946: PPOPN 2
98948: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98949: LD_EXP 98
98953: PUSH
98954: LD_EXP 108
98958: AND
98959: IFFALSE 98979
98961: GO 98963
98963: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98964: LD_INT 32
98966: PPUSH
98967: LD_OWVAR 2
98971: PPUSH
98972: LD_INT 0
98974: PPUSH
98975: CALL_OW 324
98979: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98980: LD_EXP 98
98984: PUSH
98985: LD_EXP 109
98989: AND
98990: IFFALSE 99171
98992: GO 98994
98994: DISABLE
98995: LD_INT 0
98997: PPUSH
98998: PPUSH
98999: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
99000: LD_ADDR_VAR 0 2
99004: PUSH
99005: LD_INT 22
99007: PUSH
99008: LD_OWVAR 2
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: PUSH
99017: LD_INT 33
99019: PUSH
99020: LD_INT 3
99022: PUSH
99023: EMPTY
99024: LIST
99025: LIST
99026: PUSH
99027: EMPTY
99028: LIST
99029: LIST
99030: PPUSH
99031: CALL_OW 69
99035: ST_TO_ADDR
// if not tmp then
99036: LD_VAR 0 2
99040: NOT
99041: IFFALSE 99045
// exit ;
99043: GO 99171
// side := 0 ;
99045: LD_ADDR_VAR 0 3
99049: PUSH
99050: LD_INT 0
99052: ST_TO_ADDR
// for i := 1 to 8 do
99053: LD_ADDR_VAR 0 1
99057: PUSH
99058: DOUBLE
99059: LD_INT 1
99061: DEC
99062: ST_TO_ADDR
99063: LD_INT 8
99065: PUSH
99066: FOR_TO
99067: IFFALSE 99115
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99069: LD_OWVAR 2
99073: PUSH
99074: LD_VAR 0 1
99078: NONEQUAL
99079: PUSH
99080: LD_OWVAR 2
99084: PPUSH
99085: LD_VAR 0 1
99089: PPUSH
99090: CALL_OW 81
99094: PUSH
99095: LD_INT 2
99097: EQUAL
99098: AND
99099: IFFALSE 99113
// begin side := i ;
99101: LD_ADDR_VAR 0 3
99105: PUSH
99106: LD_VAR 0 1
99110: ST_TO_ADDR
// break ;
99111: GO 99115
// end ;
99113: GO 99066
99115: POP
99116: POP
// if not side then
99117: LD_VAR 0 3
99121: NOT
99122: IFFALSE 99126
// exit ;
99124: GO 99171
// for i := 1 to tmp do
99126: LD_ADDR_VAR 0 1
99130: PUSH
99131: DOUBLE
99132: LD_INT 1
99134: DEC
99135: ST_TO_ADDR
99136: LD_VAR 0 2
99140: PUSH
99141: FOR_TO
99142: IFFALSE 99169
// if Prob ( 60 ) then
99144: LD_INT 60
99146: PPUSH
99147: CALL_OW 13
99151: IFFALSE 99167
// SetSide ( i , side ) ;
99153: LD_VAR 0 1
99157: PPUSH
99158: LD_VAR 0 3
99162: PPUSH
99163: CALL_OW 235
99167: GO 99141
99169: POP
99170: POP
// end ;
99171: PPOPN 3
99173: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99174: LD_EXP 98
99178: PUSH
99179: LD_EXP 111
99183: AND
99184: IFFALSE 99303
99186: GO 99188
99188: DISABLE
99189: LD_INT 0
99191: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99192: LD_ADDR_VAR 0 1
99196: PUSH
99197: LD_INT 22
99199: PUSH
99200: LD_OWVAR 2
99204: PUSH
99205: EMPTY
99206: LIST
99207: LIST
99208: PUSH
99209: LD_INT 21
99211: PUSH
99212: LD_INT 1
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: LD_INT 3
99221: PUSH
99222: LD_INT 23
99224: PUSH
99225: LD_INT 0
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: LIST
99240: PPUSH
99241: CALL_OW 69
99245: PUSH
99246: FOR_IN
99247: IFFALSE 99301
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99249: LD_VAR 0 1
99253: PPUSH
99254: CALL_OW 257
99258: PUSH
99259: LD_INT 1
99261: PUSH
99262: LD_INT 2
99264: PUSH
99265: LD_INT 3
99267: PUSH
99268: LD_INT 4
99270: PUSH
99271: EMPTY
99272: LIST
99273: LIST
99274: LIST
99275: LIST
99276: IN
99277: IFFALSE 99299
// SetClass ( un , rand ( 1 , 4 ) ) ;
99279: LD_VAR 0 1
99283: PPUSH
99284: LD_INT 1
99286: PPUSH
99287: LD_INT 4
99289: PPUSH
99290: CALL_OW 12
99294: PPUSH
99295: CALL_OW 336
99299: GO 99246
99301: POP
99302: POP
// end ;
99303: PPOPN 1
99305: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99306: LD_EXP 98
99310: PUSH
99311: LD_EXP 110
99315: AND
99316: IFFALSE 99395
99318: GO 99320
99320: DISABLE
99321: LD_INT 0
99323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99324: LD_ADDR_VAR 0 1
99328: PUSH
99329: LD_INT 22
99331: PUSH
99332: LD_OWVAR 2
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: PUSH
99341: LD_INT 21
99343: PUSH
99344: LD_INT 3
99346: PUSH
99347: EMPTY
99348: LIST
99349: LIST
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: PPUSH
99355: CALL_OW 69
99359: ST_TO_ADDR
// if not tmp then
99360: LD_VAR 0 1
99364: NOT
99365: IFFALSE 99369
// exit ;
99367: GO 99395
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99369: LD_VAR 0 1
99373: PUSH
99374: LD_INT 1
99376: PPUSH
99377: LD_VAR 0 1
99381: PPUSH
99382: CALL_OW 12
99386: ARRAY
99387: PPUSH
99388: LD_INT 100
99390: PPUSH
99391: CALL_OW 234
// end ;
99395: PPOPN 1
99397: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99398: LD_EXP 98
99402: PUSH
99403: LD_EXP 112
99407: AND
99408: IFFALSE 99506
99410: GO 99412
99412: DISABLE
99413: LD_INT 0
99415: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99416: LD_ADDR_VAR 0 1
99420: PUSH
99421: LD_INT 22
99423: PUSH
99424: LD_OWVAR 2
99428: PUSH
99429: EMPTY
99430: LIST
99431: LIST
99432: PUSH
99433: LD_INT 21
99435: PUSH
99436: LD_INT 1
99438: PUSH
99439: EMPTY
99440: LIST
99441: LIST
99442: PUSH
99443: EMPTY
99444: LIST
99445: LIST
99446: PPUSH
99447: CALL_OW 69
99451: ST_TO_ADDR
// if not tmp then
99452: LD_VAR 0 1
99456: NOT
99457: IFFALSE 99461
// exit ;
99459: GO 99506
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99461: LD_VAR 0 1
99465: PUSH
99466: LD_INT 1
99468: PPUSH
99469: LD_VAR 0 1
99473: PPUSH
99474: CALL_OW 12
99478: ARRAY
99479: PPUSH
99480: LD_INT 1
99482: PPUSH
99483: LD_INT 4
99485: PPUSH
99486: CALL_OW 12
99490: PPUSH
99491: LD_INT 3000
99493: PPUSH
99494: LD_INT 9000
99496: PPUSH
99497: CALL_OW 12
99501: PPUSH
99502: CALL_OW 492
// end ;
99506: PPOPN 1
99508: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99509: LD_EXP 98
99513: PUSH
99514: LD_EXP 113
99518: AND
99519: IFFALSE 99539
99521: GO 99523
99523: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99524: LD_INT 1
99526: PPUSH
99527: LD_OWVAR 2
99531: PPUSH
99532: LD_INT 0
99534: PPUSH
99535: CALL_OW 324
99539: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99540: LD_EXP 98
99544: PUSH
99545: LD_EXP 114
99549: AND
99550: IFFALSE 99633
99552: GO 99554
99554: DISABLE
99555: LD_INT 0
99557: PPUSH
99558: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99559: LD_ADDR_VAR 0 2
99563: PUSH
99564: LD_INT 22
99566: PUSH
99567: LD_OWVAR 2
99571: PUSH
99572: EMPTY
99573: LIST
99574: LIST
99575: PUSH
99576: LD_INT 21
99578: PUSH
99579: LD_INT 3
99581: PUSH
99582: EMPTY
99583: LIST
99584: LIST
99585: PUSH
99586: EMPTY
99587: LIST
99588: LIST
99589: PPUSH
99590: CALL_OW 69
99594: ST_TO_ADDR
// if not tmp then
99595: LD_VAR 0 2
99599: NOT
99600: IFFALSE 99604
// exit ;
99602: GO 99633
// for i in tmp do
99604: LD_ADDR_VAR 0 1
99608: PUSH
99609: LD_VAR 0 2
99613: PUSH
99614: FOR_IN
99615: IFFALSE 99631
// SetBLevel ( i , 10 ) ;
99617: LD_VAR 0 1
99621: PPUSH
99622: LD_INT 10
99624: PPUSH
99625: CALL_OW 241
99629: GO 99614
99631: POP
99632: POP
// end ;
99633: PPOPN 2
99635: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99636: LD_EXP 98
99640: PUSH
99641: LD_EXP 115
99645: AND
99646: IFFALSE 99757
99648: GO 99650
99650: DISABLE
99651: LD_INT 0
99653: PPUSH
99654: PPUSH
99655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99656: LD_ADDR_VAR 0 3
99660: PUSH
99661: LD_INT 22
99663: PUSH
99664: LD_OWVAR 2
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: PUSH
99673: LD_INT 25
99675: PUSH
99676: LD_INT 1
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PPUSH
99687: CALL_OW 69
99691: ST_TO_ADDR
// if not tmp then
99692: LD_VAR 0 3
99696: NOT
99697: IFFALSE 99701
// exit ;
99699: GO 99757
// un := tmp [ rand ( 1 , tmp ) ] ;
99701: LD_ADDR_VAR 0 2
99705: PUSH
99706: LD_VAR 0 3
99710: PUSH
99711: LD_INT 1
99713: PPUSH
99714: LD_VAR 0 3
99718: PPUSH
99719: CALL_OW 12
99723: ARRAY
99724: ST_TO_ADDR
// if Crawls ( un ) then
99725: LD_VAR 0 2
99729: PPUSH
99730: CALL_OW 318
99734: IFFALSE 99745
// ComWalk ( un ) ;
99736: LD_VAR 0 2
99740: PPUSH
99741: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99745: LD_VAR 0 2
99749: PPUSH
99750: LD_INT 5
99752: PPUSH
99753: CALL_OW 336
// end ;
99757: PPOPN 3
99759: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99760: LD_EXP 98
99764: PUSH
99765: LD_EXP 116
99769: AND
99770: PUSH
99771: LD_OWVAR 67
99775: PUSH
99776: LD_INT 4
99778: LESS
99779: AND
99780: IFFALSE 99799
99782: GO 99784
99784: DISABLE
// begin Difficulty := Difficulty + 1 ;
99785: LD_ADDR_OWVAR 67
99789: PUSH
99790: LD_OWVAR 67
99794: PUSH
99795: LD_INT 1
99797: PLUS
99798: ST_TO_ADDR
// end ;
99799: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99800: LD_EXP 98
99804: PUSH
99805: LD_EXP 117
99809: AND
99810: IFFALSE 99913
99812: GO 99814
99814: DISABLE
99815: LD_INT 0
99817: PPUSH
// begin for i := 1 to 5 do
99818: LD_ADDR_VAR 0 1
99822: PUSH
99823: DOUBLE
99824: LD_INT 1
99826: DEC
99827: ST_TO_ADDR
99828: LD_INT 5
99830: PUSH
99831: FOR_TO
99832: IFFALSE 99911
// begin uc_nation := nation_nature ;
99834: LD_ADDR_OWVAR 21
99838: PUSH
99839: LD_INT 0
99841: ST_TO_ADDR
// uc_side := 0 ;
99842: LD_ADDR_OWVAR 20
99846: PUSH
99847: LD_INT 0
99849: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99850: LD_ADDR_OWVAR 29
99854: PUSH
99855: LD_INT 12
99857: PUSH
99858: LD_INT 12
99860: PUSH
99861: EMPTY
99862: LIST
99863: LIST
99864: ST_TO_ADDR
// hc_agressivity := 20 ;
99865: LD_ADDR_OWVAR 35
99869: PUSH
99870: LD_INT 20
99872: ST_TO_ADDR
// hc_class := class_tiger ;
99873: LD_ADDR_OWVAR 28
99877: PUSH
99878: LD_INT 14
99880: ST_TO_ADDR
// hc_gallery :=  ;
99881: LD_ADDR_OWVAR 33
99885: PUSH
99886: LD_STRING 
99888: ST_TO_ADDR
// hc_name :=  ;
99889: LD_ADDR_OWVAR 26
99893: PUSH
99894: LD_STRING 
99896: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99897: CALL_OW 44
99901: PPUSH
99902: LD_INT 0
99904: PPUSH
99905: CALL_OW 51
// end ;
99909: GO 99831
99911: POP
99912: POP
// end ;
99913: PPOPN 1
99915: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99916: LD_EXP 98
99920: PUSH
99921: LD_EXP 118
99925: AND
99926: IFFALSE 99935
99928: GO 99930
99930: DISABLE
// StreamSibBomb ;
99931: CALL 99936 0 0
99935: END
// export function StreamSibBomb ; var i , x , y ; begin
99936: LD_INT 0
99938: PPUSH
99939: PPUSH
99940: PPUSH
99941: PPUSH
// result := false ;
99942: LD_ADDR_VAR 0 1
99946: PUSH
99947: LD_INT 0
99949: ST_TO_ADDR
// for i := 1 to 16 do
99950: LD_ADDR_VAR 0 2
99954: PUSH
99955: DOUBLE
99956: LD_INT 1
99958: DEC
99959: ST_TO_ADDR
99960: LD_INT 16
99962: PUSH
99963: FOR_TO
99964: IFFALSE 100163
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99966: LD_ADDR_VAR 0 3
99970: PUSH
99971: LD_INT 10
99973: PUSH
99974: LD_INT 20
99976: PUSH
99977: LD_INT 30
99979: PUSH
99980: LD_INT 40
99982: PUSH
99983: LD_INT 50
99985: PUSH
99986: LD_INT 60
99988: PUSH
99989: LD_INT 70
99991: PUSH
99992: LD_INT 80
99994: PUSH
99995: LD_INT 90
99997: PUSH
99998: LD_INT 100
100000: PUSH
100001: LD_INT 110
100003: PUSH
100004: LD_INT 120
100006: PUSH
100007: LD_INT 130
100009: PUSH
100010: LD_INT 140
100012: PUSH
100013: LD_INT 150
100015: PUSH
100016: EMPTY
100017: LIST
100018: LIST
100019: LIST
100020: LIST
100021: LIST
100022: LIST
100023: LIST
100024: LIST
100025: LIST
100026: LIST
100027: LIST
100028: LIST
100029: LIST
100030: LIST
100031: LIST
100032: PUSH
100033: LD_INT 1
100035: PPUSH
100036: LD_INT 15
100038: PPUSH
100039: CALL_OW 12
100043: ARRAY
100044: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100045: LD_ADDR_VAR 0 4
100049: PUSH
100050: LD_INT 10
100052: PUSH
100053: LD_INT 20
100055: PUSH
100056: LD_INT 30
100058: PUSH
100059: LD_INT 40
100061: PUSH
100062: LD_INT 50
100064: PUSH
100065: LD_INT 60
100067: PUSH
100068: LD_INT 70
100070: PUSH
100071: LD_INT 80
100073: PUSH
100074: LD_INT 90
100076: PUSH
100077: LD_INT 100
100079: PUSH
100080: LD_INT 110
100082: PUSH
100083: LD_INT 120
100085: PUSH
100086: LD_INT 130
100088: PUSH
100089: LD_INT 140
100091: PUSH
100092: LD_INT 150
100094: PUSH
100095: EMPTY
100096: LIST
100097: LIST
100098: LIST
100099: LIST
100100: LIST
100101: LIST
100102: LIST
100103: LIST
100104: LIST
100105: LIST
100106: LIST
100107: LIST
100108: LIST
100109: LIST
100110: LIST
100111: PUSH
100112: LD_INT 1
100114: PPUSH
100115: LD_INT 15
100117: PPUSH
100118: CALL_OW 12
100122: ARRAY
100123: ST_TO_ADDR
// if ValidHex ( x , y ) then
100124: LD_VAR 0 3
100128: PPUSH
100129: LD_VAR 0 4
100133: PPUSH
100134: CALL_OW 488
100138: IFFALSE 100161
// begin result := [ x , y ] ;
100140: LD_ADDR_VAR 0 1
100144: PUSH
100145: LD_VAR 0 3
100149: PUSH
100150: LD_VAR 0 4
100154: PUSH
100155: EMPTY
100156: LIST
100157: LIST
100158: ST_TO_ADDR
// break ;
100159: GO 100163
// end ; end ;
100161: GO 99963
100163: POP
100164: POP
// if result then
100165: LD_VAR 0 1
100169: IFFALSE 100229
// begin ToLua ( playSibBomb() ) ;
100171: LD_STRING playSibBomb()
100173: PPUSH
100174: CALL_OW 559
// wait ( 0 0$14 ) ;
100178: LD_INT 490
100180: PPUSH
100181: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100185: LD_VAR 0 1
100189: PUSH
100190: LD_INT 1
100192: ARRAY
100193: PPUSH
100194: LD_VAR 0 1
100198: PUSH
100199: LD_INT 2
100201: ARRAY
100202: PPUSH
100203: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100207: LD_VAR 0 1
100211: PUSH
100212: LD_INT 1
100214: ARRAY
100215: PPUSH
100216: LD_VAR 0 1
100220: PUSH
100221: LD_INT 2
100223: ARRAY
100224: PPUSH
100225: CALL_OW 429
// end ; end ;
100229: LD_VAR 0 1
100233: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100234: LD_EXP 98
100238: PUSH
100239: LD_EXP 120
100243: AND
100244: IFFALSE 100256
100246: GO 100248
100248: DISABLE
// YouLost (  ) ;
100249: LD_STRING 
100251: PPUSH
100252: CALL_OW 104
100256: END
// every 0 0$1 trigger StreamModeActive and sFog do
100257: LD_EXP 98
100261: PUSH
100262: LD_EXP 119
100266: AND
100267: IFFALSE 100281
100269: GO 100271
100271: DISABLE
// FogOff ( your_side ) ;
100272: LD_OWVAR 2
100276: PPUSH
100277: CALL_OW 344
100281: END
// every 0 0$1 trigger StreamModeActive and sSun do
100282: LD_EXP 98
100286: PUSH
100287: LD_EXP 121
100291: AND
100292: IFFALSE 100320
100294: GO 100296
100296: DISABLE
// begin solar_recharge_percent := 0 ;
100297: LD_ADDR_OWVAR 79
100301: PUSH
100302: LD_INT 0
100304: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100305: LD_INT 10500
100307: PPUSH
100308: CALL_OW 67
// solar_recharge_percent := 100 ;
100312: LD_ADDR_OWVAR 79
100316: PUSH
100317: LD_INT 100
100319: ST_TO_ADDR
// end ;
100320: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100321: LD_EXP 98
100325: PUSH
100326: LD_EXP 122
100330: AND
100331: IFFALSE 100570
100333: GO 100335
100335: DISABLE
100336: LD_INT 0
100338: PPUSH
100339: PPUSH
100340: PPUSH
// begin tmp := [ ] ;
100341: LD_ADDR_VAR 0 3
100345: PUSH
100346: EMPTY
100347: ST_TO_ADDR
// for i := 1 to 6 do
100348: LD_ADDR_VAR 0 1
100352: PUSH
100353: DOUBLE
100354: LD_INT 1
100356: DEC
100357: ST_TO_ADDR
100358: LD_INT 6
100360: PUSH
100361: FOR_TO
100362: IFFALSE 100467
// begin uc_nation := nation_nature ;
100364: LD_ADDR_OWVAR 21
100368: PUSH
100369: LD_INT 0
100371: ST_TO_ADDR
// uc_side := 0 ;
100372: LD_ADDR_OWVAR 20
100376: PUSH
100377: LD_INT 0
100379: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100380: LD_ADDR_OWVAR 29
100384: PUSH
100385: LD_INT 12
100387: PUSH
100388: LD_INT 12
100390: PUSH
100391: EMPTY
100392: LIST
100393: LIST
100394: ST_TO_ADDR
// hc_agressivity := 20 ;
100395: LD_ADDR_OWVAR 35
100399: PUSH
100400: LD_INT 20
100402: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100403: LD_ADDR_OWVAR 28
100407: PUSH
100408: LD_INT 17
100410: ST_TO_ADDR
// hc_gallery :=  ;
100411: LD_ADDR_OWVAR 33
100415: PUSH
100416: LD_STRING 
100418: ST_TO_ADDR
// hc_name :=  ;
100419: LD_ADDR_OWVAR 26
100423: PUSH
100424: LD_STRING 
100426: ST_TO_ADDR
// un := CreateHuman ;
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: CALL_OW 44
100436: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100437: LD_VAR 0 2
100441: PPUSH
100442: LD_INT 1
100444: PPUSH
100445: CALL_OW 51
// tmp := tmp ^ un ;
100449: LD_ADDR_VAR 0 3
100453: PUSH
100454: LD_VAR 0 3
100458: PUSH
100459: LD_VAR 0 2
100463: ADD
100464: ST_TO_ADDR
// end ;
100465: GO 100361
100467: POP
100468: POP
// repeat wait ( 0 0$1 ) ;
100469: LD_INT 35
100471: PPUSH
100472: CALL_OW 67
// for un in tmp do
100476: LD_ADDR_VAR 0 2
100480: PUSH
100481: LD_VAR 0 3
100485: PUSH
100486: FOR_IN
100487: IFFALSE 100561
// begin if IsDead ( un ) then
100489: LD_VAR 0 2
100493: PPUSH
100494: CALL_OW 301
100498: IFFALSE 100518
// begin tmp := tmp diff un ;
100500: LD_ADDR_VAR 0 3
100504: PUSH
100505: LD_VAR 0 3
100509: PUSH
100510: LD_VAR 0 2
100514: DIFF
100515: ST_TO_ADDR
// continue ;
100516: GO 100486
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100518: LD_VAR 0 2
100522: PPUSH
100523: LD_INT 3
100525: PUSH
100526: LD_INT 22
100528: PUSH
100529: LD_INT 0
100531: PUSH
100532: EMPTY
100533: LIST
100534: LIST
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PPUSH
100540: CALL_OW 69
100544: PPUSH
100545: LD_VAR 0 2
100549: PPUSH
100550: CALL_OW 74
100554: PPUSH
100555: CALL_OW 115
// end ;
100559: GO 100486
100561: POP
100562: POP
// until not tmp ;
100563: LD_VAR 0 3
100567: NOT
100568: IFFALSE 100469
// end ;
100570: PPOPN 3
100572: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100573: LD_EXP 98
100577: PUSH
100578: LD_EXP 123
100582: AND
100583: IFFALSE 100637
100585: GO 100587
100587: DISABLE
// begin ToLua ( displayTroll(); ) ;
100588: LD_STRING displayTroll();
100590: PPUSH
100591: CALL_OW 559
// wait ( 3 3$00 ) ;
100595: LD_INT 6300
100597: PPUSH
100598: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100602: LD_STRING hideTroll();
100604: PPUSH
100605: CALL_OW 559
// wait ( 1 1$00 ) ;
100609: LD_INT 2100
100611: PPUSH
100612: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100616: LD_STRING displayTroll();
100618: PPUSH
100619: CALL_OW 559
// wait ( 1 1$00 ) ;
100623: LD_INT 2100
100625: PPUSH
100626: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100630: LD_STRING hideTroll();
100632: PPUSH
100633: CALL_OW 559
// end ;
100637: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100638: LD_EXP 98
100642: PUSH
100643: LD_EXP 124
100647: AND
100648: IFFALSE 100711
100650: GO 100652
100652: DISABLE
100653: LD_INT 0
100655: PPUSH
// begin p := 0 ;
100656: LD_ADDR_VAR 0 1
100660: PUSH
100661: LD_INT 0
100663: ST_TO_ADDR
// repeat game_speed := 1 ;
100664: LD_ADDR_OWVAR 65
100668: PUSH
100669: LD_INT 1
100671: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100672: LD_INT 35
100674: PPUSH
100675: CALL_OW 67
// p := p + 1 ;
100679: LD_ADDR_VAR 0 1
100683: PUSH
100684: LD_VAR 0 1
100688: PUSH
100689: LD_INT 1
100691: PLUS
100692: ST_TO_ADDR
// until p >= 60 ;
100693: LD_VAR 0 1
100697: PUSH
100698: LD_INT 60
100700: GREATEREQUAL
100701: IFFALSE 100664
// game_speed := 4 ;
100703: LD_ADDR_OWVAR 65
100707: PUSH
100708: LD_INT 4
100710: ST_TO_ADDR
// end ;
100711: PPOPN 1
100713: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100714: LD_EXP 98
100718: PUSH
100719: LD_EXP 125
100723: AND
100724: IFFALSE 100870
100726: GO 100728
100728: DISABLE
100729: LD_INT 0
100731: PPUSH
100732: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100733: LD_ADDR_VAR 0 1
100737: PUSH
100738: LD_INT 22
100740: PUSH
100741: LD_OWVAR 2
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 2
100752: PUSH
100753: LD_INT 30
100755: PUSH
100756: LD_INT 0
100758: PUSH
100759: EMPTY
100760: LIST
100761: LIST
100762: PUSH
100763: LD_INT 30
100765: PUSH
100766: LD_INT 1
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: PUSH
100773: EMPTY
100774: LIST
100775: LIST
100776: LIST
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PPUSH
100782: CALL_OW 69
100786: ST_TO_ADDR
// if not depot then
100787: LD_VAR 0 1
100791: NOT
100792: IFFALSE 100796
// exit ;
100794: GO 100870
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100796: LD_ADDR_VAR 0 2
100800: PUSH
100801: LD_VAR 0 1
100805: PUSH
100806: LD_INT 1
100808: PPUSH
100809: LD_VAR 0 1
100813: PPUSH
100814: CALL_OW 12
100818: ARRAY
100819: PPUSH
100820: CALL_OW 274
100824: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100825: LD_VAR 0 2
100829: PPUSH
100830: LD_INT 1
100832: PPUSH
100833: LD_INT 0
100835: PPUSH
100836: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100840: LD_VAR 0 2
100844: PPUSH
100845: LD_INT 2
100847: PPUSH
100848: LD_INT 0
100850: PPUSH
100851: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100855: LD_VAR 0 2
100859: PPUSH
100860: LD_INT 3
100862: PPUSH
100863: LD_INT 0
100865: PPUSH
100866: CALL_OW 277
// end ;
100870: PPOPN 2
100872: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100873: LD_EXP 98
100877: PUSH
100878: LD_EXP 126
100882: AND
100883: IFFALSE 100980
100885: GO 100887
100887: DISABLE
100888: LD_INT 0
100890: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100891: LD_ADDR_VAR 0 1
100895: PUSH
100896: LD_INT 22
100898: PUSH
100899: LD_OWVAR 2
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PUSH
100908: LD_INT 21
100910: PUSH
100911: LD_INT 1
100913: PUSH
100914: EMPTY
100915: LIST
100916: LIST
100917: PUSH
100918: LD_INT 3
100920: PUSH
100921: LD_INT 23
100923: PUSH
100924: LD_INT 0
100926: PUSH
100927: EMPTY
100928: LIST
100929: LIST
100930: PUSH
100931: EMPTY
100932: LIST
100933: LIST
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: LIST
100939: PPUSH
100940: CALL_OW 69
100944: ST_TO_ADDR
// if not tmp then
100945: LD_VAR 0 1
100949: NOT
100950: IFFALSE 100954
// exit ;
100952: GO 100980
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100954: LD_VAR 0 1
100958: PUSH
100959: LD_INT 1
100961: PPUSH
100962: LD_VAR 0 1
100966: PPUSH
100967: CALL_OW 12
100971: ARRAY
100972: PPUSH
100973: LD_INT 200
100975: PPUSH
100976: CALL_OW 234
// end ;
100980: PPOPN 1
100982: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100983: LD_EXP 98
100987: PUSH
100988: LD_EXP 127
100992: AND
100993: IFFALSE 101072
100995: GO 100997
100997: DISABLE
100998: LD_INT 0
101000: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
101001: LD_ADDR_VAR 0 1
101005: PUSH
101006: LD_INT 22
101008: PUSH
101009: LD_OWVAR 2
101013: PUSH
101014: EMPTY
101015: LIST
101016: LIST
101017: PUSH
101018: LD_INT 21
101020: PUSH
101021: LD_INT 2
101023: PUSH
101024: EMPTY
101025: LIST
101026: LIST
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PPUSH
101032: CALL_OW 69
101036: ST_TO_ADDR
// if not tmp then
101037: LD_VAR 0 1
101041: NOT
101042: IFFALSE 101046
// exit ;
101044: GO 101072
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101046: LD_VAR 0 1
101050: PUSH
101051: LD_INT 1
101053: PPUSH
101054: LD_VAR 0 1
101058: PPUSH
101059: CALL_OW 12
101063: ARRAY
101064: PPUSH
101065: LD_INT 60
101067: PPUSH
101068: CALL_OW 234
// end ;
101072: PPOPN 1
101074: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101075: LD_EXP 98
101079: PUSH
101080: LD_EXP 128
101084: AND
101085: IFFALSE 101184
101087: GO 101089
101089: DISABLE
101090: LD_INT 0
101092: PPUSH
101093: PPUSH
// begin enable ;
101094: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101095: LD_ADDR_VAR 0 1
101099: PUSH
101100: LD_INT 22
101102: PUSH
101103: LD_OWVAR 2
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: PUSH
101112: LD_INT 61
101114: PUSH
101115: EMPTY
101116: LIST
101117: PUSH
101118: LD_INT 33
101120: PUSH
101121: LD_INT 2
101123: PUSH
101124: EMPTY
101125: LIST
101126: LIST
101127: PUSH
101128: EMPTY
101129: LIST
101130: LIST
101131: LIST
101132: PPUSH
101133: CALL_OW 69
101137: ST_TO_ADDR
// if not tmp then
101138: LD_VAR 0 1
101142: NOT
101143: IFFALSE 101147
// exit ;
101145: GO 101184
// for i in tmp do
101147: LD_ADDR_VAR 0 2
101151: PUSH
101152: LD_VAR 0 1
101156: PUSH
101157: FOR_IN
101158: IFFALSE 101182
// if IsControledBy ( i ) then
101160: LD_VAR 0 2
101164: PPUSH
101165: CALL_OW 312
101169: IFFALSE 101180
// ComUnlink ( i ) ;
101171: LD_VAR 0 2
101175: PPUSH
101176: CALL_OW 136
101180: GO 101157
101182: POP
101183: POP
// end ;
101184: PPOPN 2
101186: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101187: LD_EXP 98
101191: PUSH
101192: LD_EXP 129
101196: AND
101197: IFFALSE 101337
101199: GO 101201
101201: DISABLE
101202: LD_INT 0
101204: PPUSH
101205: PPUSH
// begin ToLua ( displayPowell(); ) ;
101206: LD_STRING displayPowell();
101208: PPUSH
101209: CALL_OW 559
// uc_side := 0 ;
101213: LD_ADDR_OWVAR 20
101217: PUSH
101218: LD_INT 0
101220: ST_TO_ADDR
// uc_nation := 2 ;
101221: LD_ADDR_OWVAR 21
101225: PUSH
101226: LD_INT 2
101228: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101229: LD_ADDR_OWVAR 37
101233: PUSH
101234: LD_INT 14
101236: ST_TO_ADDR
// vc_engine := engine_siberite ;
101237: LD_ADDR_OWVAR 39
101241: PUSH
101242: LD_INT 3
101244: ST_TO_ADDR
// vc_control := control_apeman ;
101245: LD_ADDR_OWVAR 38
101249: PUSH
101250: LD_INT 5
101252: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101253: LD_ADDR_OWVAR 40
101257: PUSH
101258: LD_INT 29
101260: ST_TO_ADDR
// un := CreateVehicle ;
101261: LD_ADDR_VAR 0 2
101265: PUSH
101266: CALL_OW 45
101270: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101271: LD_VAR 0 2
101275: PPUSH
101276: LD_INT 1
101278: PPUSH
101279: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101283: LD_INT 35
101285: PPUSH
101286: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101290: LD_VAR 0 2
101294: PPUSH
101295: LD_INT 22
101297: PUSH
101298: LD_OWVAR 2
101302: PUSH
101303: EMPTY
101304: LIST
101305: LIST
101306: PPUSH
101307: CALL_OW 69
101311: PPUSH
101312: LD_VAR 0 2
101316: PPUSH
101317: CALL_OW 74
101321: PPUSH
101322: CALL_OW 115
// until IsDead ( un ) ;
101326: LD_VAR 0 2
101330: PPUSH
101331: CALL_OW 301
101335: IFFALSE 101283
// end ;
101337: PPOPN 2
101339: END
// every 0 0$1 trigger StreamModeActive and sStu do
101340: LD_EXP 98
101344: PUSH
101345: LD_EXP 137
101349: AND
101350: IFFALSE 101366
101352: GO 101354
101354: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101355: LD_STRING displayStucuk();
101357: PPUSH
101358: CALL_OW 559
// ResetFog ;
101362: CALL_OW 335
// end ;
101366: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101367: LD_EXP 98
101371: PUSH
101372: LD_EXP 130
101376: AND
101377: IFFALSE 101518
101379: GO 101381
101381: DISABLE
101382: LD_INT 0
101384: PPUSH
101385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101386: LD_ADDR_VAR 0 2
101390: PUSH
101391: LD_INT 22
101393: PUSH
101394: LD_OWVAR 2
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: PUSH
101403: LD_INT 21
101405: PUSH
101406: LD_INT 1
101408: PUSH
101409: EMPTY
101410: LIST
101411: LIST
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PPUSH
101417: CALL_OW 69
101421: ST_TO_ADDR
// if not tmp then
101422: LD_VAR 0 2
101426: NOT
101427: IFFALSE 101431
// exit ;
101429: GO 101518
// un := tmp [ rand ( 1 , tmp ) ] ;
101431: LD_ADDR_VAR 0 1
101435: PUSH
101436: LD_VAR 0 2
101440: PUSH
101441: LD_INT 1
101443: PPUSH
101444: LD_VAR 0 2
101448: PPUSH
101449: CALL_OW 12
101453: ARRAY
101454: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101455: LD_VAR 0 1
101459: PPUSH
101460: LD_INT 0
101462: PPUSH
101463: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101467: LD_VAR 0 1
101471: PPUSH
101472: LD_OWVAR 3
101476: PUSH
101477: LD_VAR 0 1
101481: DIFF
101482: PPUSH
101483: LD_VAR 0 1
101487: PPUSH
101488: CALL_OW 74
101492: PPUSH
101493: CALL_OW 115
// wait ( 0 0$20 ) ;
101497: LD_INT 700
101499: PPUSH
101500: CALL_OW 67
// SetSide ( un , your_side ) ;
101504: LD_VAR 0 1
101508: PPUSH
101509: LD_OWVAR 2
101513: PPUSH
101514: CALL_OW 235
// end ;
101518: PPOPN 2
101520: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101521: LD_EXP 98
101525: PUSH
101526: LD_EXP 131
101530: AND
101531: IFFALSE 101637
101533: GO 101535
101535: DISABLE
101536: LD_INT 0
101538: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101539: LD_ADDR_VAR 0 1
101543: PUSH
101544: LD_INT 22
101546: PUSH
101547: LD_OWVAR 2
101551: PUSH
101552: EMPTY
101553: LIST
101554: LIST
101555: PUSH
101556: LD_INT 2
101558: PUSH
101559: LD_INT 30
101561: PUSH
101562: LD_INT 0
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: PUSH
101569: LD_INT 30
101571: PUSH
101572: LD_INT 1
101574: PUSH
101575: EMPTY
101576: LIST
101577: LIST
101578: PUSH
101579: EMPTY
101580: LIST
101581: LIST
101582: LIST
101583: PUSH
101584: EMPTY
101585: LIST
101586: LIST
101587: PPUSH
101588: CALL_OW 69
101592: ST_TO_ADDR
// if not depot then
101593: LD_VAR 0 1
101597: NOT
101598: IFFALSE 101602
// exit ;
101600: GO 101637
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101602: LD_VAR 0 1
101606: PUSH
101607: LD_INT 1
101609: ARRAY
101610: PPUSH
101611: CALL_OW 250
101615: PPUSH
101616: LD_VAR 0 1
101620: PUSH
101621: LD_INT 1
101623: ARRAY
101624: PPUSH
101625: CALL_OW 251
101629: PPUSH
101630: LD_INT 70
101632: PPUSH
101633: CALL_OW 495
// end ;
101637: PPOPN 1
101639: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101640: LD_EXP 98
101644: PUSH
101645: LD_EXP 132
101649: AND
101650: IFFALSE 101861
101652: GO 101654
101654: DISABLE
101655: LD_INT 0
101657: PPUSH
101658: PPUSH
101659: PPUSH
101660: PPUSH
101661: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101662: LD_ADDR_VAR 0 5
101666: PUSH
101667: LD_INT 22
101669: PUSH
101670: LD_OWVAR 2
101674: PUSH
101675: EMPTY
101676: LIST
101677: LIST
101678: PUSH
101679: LD_INT 21
101681: PUSH
101682: LD_INT 1
101684: PUSH
101685: EMPTY
101686: LIST
101687: LIST
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PPUSH
101693: CALL_OW 69
101697: ST_TO_ADDR
// if not tmp then
101698: LD_VAR 0 5
101702: NOT
101703: IFFALSE 101707
// exit ;
101705: GO 101861
// for i in tmp do
101707: LD_ADDR_VAR 0 1
101711: PUSH
101712: LD_VAR 0 5
101716: PUSH
101717: FOR_IN
101718: IFFALSE 101859
// begin d := rand ( 0 , 5 ) ;
101720: LD_ADDR_VAR 0 4
101724: PUSH
101725: LD_INT 0
101727: PPUSH
101728: LD_INT 5
101730: PPUSH
101731: CALL_OW 12
101735: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101736: LD_ADDR_VAR 0 2
101740: PUSH
101741: LD_VAR 0 1
101745: PPUSH
101746: CALL_OW 250
101750: PPUSH
101751: LD_VAR 0 4
101755: PPUSH
101756: LD_INT 3
101758: PPUSH
101759: LD_INT 12
101761: PPUSH
101762: CALL_OW 12
101766: PPUSH
101767: CALL_OW 272
101771: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101772: LD_ADDR_VAR 0 3
101776: PUSH
101777: LD_VAR 0 1
101781: PPUSH
101782: CALL_OW 251
101786: PPUSH
101787: LD_VAR 0 4
101791: PPUSH
101792: LD_INT 3
101794: PPUSH
101795: LD_INT 12
101797: PPUSH
101798: CALL_OW 12
101802: PPUSH
101803: CALL_OW 273
101807: ST_TO_ADDR
// if ValidHex ( x , y ) then
101808: LD_VAR 0 2
101812: PPUSH
101813: LD_VAR 0 3
101817: PPUSH
101818: CALL_OW 488
101822: IFFALSE 101857
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101824: LD_VAR 0 1
101828: PPUSH
101829: LD_VAR 0 2
101833: PPUSH
101834: LD_VAR 0 3
101838: PPUSH
101839: LD_INT 3
101841: PPUSH
101842: LD_INT 6
101844: PPUSH
101845: CALL_OW 12
101849: PPUSH
101850: LD_INT 1
101852: PPUSH
101853: CALL_OW 483
// end ;
101857: GO 101717
101859: POP
101860: POP
// end ;
101861: PPOPN 5
101863: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101864: LD_EXP 98
101868: PUSH
101869: LD_EXP 133
101873: AND
101874: IFFALSE 101968
101876: GO 101878
101878: DISABLE
101879: LD_INT 0
101881: PPUSH
101882: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101883: LD_ADDR_VAR 0 2
101887: PUSH
101888: LD_INT 22
101890: PUSH
101891: LD_OWVAR 2
101895: PUSH
101896: EMPTY
101897: LIST
101898: LIST
101899: PUSH
101900: LD_INT 32
101902: PUSH
101903: LD_INT 1
101905: PUSH
101906: EMPTY
101907: LIST
101908: LIST
101909: PUSH
101910: LD_INT 21
101912: PUSH
101913: LD_INT 2
101915: PUSH
101916: EMPTY
101917: LIST
101918: LIST
101919: PUSH
101920: EMPTY
101921: LIST
101922: LIST
101923: LIST
101924: PPUSH
101925: CALL_OW 69
101929: ST_TO_ADDR
// if not tmp then
101930: LD_VAR 0 2
101934: NOT
101935: IFFALSE 101939
// exit ;
101937: GO 101968
// for i in tmp do
101939: LD_ADDR_VAR 0 1
101943: PUSH
101944: LD_VAR 0 2
101948: PUSH
101949: FOR_IN
101950: IFFALSE 101966
// SetFuel ( i , 0 ) ;
101952: LD_VAR 0 1
101956: PPUSH
101957: LD_INT 0
101959: PPUSH
101960: CALL_OW 240
101964: GO 101949
101966: POP
101967: POP
// end ;
101968: PPOPN 2
101970: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101971: LD_EXP 98
101975: PUSH
101976: LD_EXP 134
101980: AND
101981: IFFALSE 102047
101983: GO 101985
101985: DISABLE
101986: LD_INT 0
101988: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101989: LD_ADDR_VAR 0 1
101993: PUSH
101994: LD_INT 22
101996: PUSH
101997: LD_OWVAR 2
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PUSH
102006: LD_INT 30
102008: PUSH
102009: LD_INT 29
102011: PUSH
102012: EMPTY
102013: LIST
102014: LIST
102015: PUSH
102016: EMPTY
102017: LIST
102018: LIST
102019: PPUSH
102020: CALL_OW 69
102024: ST_TO_ADDR
// if not tmp then
102025: LD_VAR 0 1
102029: NOT
102030: IFFALSE 102034
// exit ;
102032: GO 102047
// DestroyUnit ( tmp [ 1 ] ) ;
102034: LD_VAR 0 1
102038: PUSH
102039: LD_INT 1
102041: ARRAY
102042: PPUSH
102043: CALL_OW 65
// end ;
102047: PPOPN 1
102049: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102050: LD_EXP 98
102054: PUSH
102055: LD_EXP 136
102059: AND
102060: IFFALSE 102189
102062: GO 102064
102064: DISABLE
102065: LD_INT 0
102067: PPUSH
// begin uc_side := 0 ;
102068: LD_ADDR_OWVAR 20
102072: PUSH
102073: LD_INT 0
102075: ST_TO_ADDR
// uc_nation := nation_arabian ;
102076: LD_ADDR_OWVAR 21
102080: PUSH
102081: LD_INT 2
102083: ST_TO_ADDR
// hc_gallery :=  ;
102084: LD_ADDR_OWVAR 33
102088: PUSH
102089: LD_STRING 
102091: ST_TO_ADDR
// hc_name :=  ;
102092: LD_ADDR_OWVAR 26
102096: PUSH
102097: LD_STRING 
102099: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102100: LD_INT 1
102102: PPUSH
102103: LD_INT 11
102105: PPUSH
102106: LD_INT 10
102108: PPUSH
102109: CALL_OW 380
// un := CreateHuman ;
102113: LD_ADDR_VAR 0 1
102117: PUSH
102118: CALL_OW 44
102122: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102123: LD_VAR 0 1
102127: PPUSH
102128: LD_INT 1
102130: PPUSH
102131: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102135: LD_INT 35
102137: PPUSH
102138: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102142: LD_VAR 0 1
102146: PPUSH
102147: LD_INT 22
102149: PUSH
102150: LD_OWVAR 2
102154: PUSH
102155: EMPTY
102156: LIST
102157: LIST
102158: PPUSH
102159: CALL_OW 69
102163: PPUSH
102164: LD_VAR 0 1
102168: PPUSH
102169: CALL_OW 74
102173: PPUSH
102174: CALL_OW 115
// until IsDead ( un ) ;
102178: LD_VAR 0 1
102182: PPUSH
102183: CALL_OW 301
102187: IFFALSE 102135
// end ;
102189: PPOPN 1
102191: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102192: LD_EXP 98
102196: PUSH
102197: LD_EXP 138
102201: AND
102202: IFFALSE 102214
102204: GO 102206
102206: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102207: LD_STRING earthquake(getX(game), 0, 32)
102209: PPUSH
102210: CALL_OW 559
102214: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102215: LD_EXP 98
102219: PUSH
102220: LD_EXP 139
102224: AND
102225: IFFALSE 102316
102227: GO 102229
102229: DISABLE
102230: LD_INT 0
102232: PPUSH
// begin enable ;
102233: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102234: LD_ADDR_VAR 0 1
102238: PUSH
102239: LD_INT 22
102241: PUSH
102242: LD_OWVAR 2
102246: PUSH
102247: EMPTY
102248: LIST
102249: LIST
102250: PUSH
102251: LD_INT 21
102253: PUSH
102254: LD_INT 2
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: PUSH
102261: LD_INT 33
102263: PUSH
102264: LD_INT 3
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: LIST
102275: PPUSH
102276: CALL_OW 69
102280: ST_TO_ADDR
// if not tmp then
102281: LD_VAR 0 1
102285: NOT
102286: IFFALSE 102290
// exit ;
102288: GO 102316
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102290: LD_VAR 0 1
102294: PUSH
102295: LD_INT 1
102297: PPUSH
102298: LD_VAR 0 1
102302: PPUSH
102303: CALL_OW 12
102307: ARRAY
102308: PPUSH
102309: LD_INT 1
102311: PPUSH
102312: CALL_OW 234
// end ;
102316: PPOPN 1
102318: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102319: LD_EXP 98
102323: PUSH
102324: LD_EXP 140
102328: AND
102329: IFFALSE 102470
102331: GO 102333
102333: DISABLE
102334: LD_INT 0
102336: PPUSH
102337: PPUSH
102338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102339: LD_ADDR_VAR 0 3
102343: PUSH
102344: LD_INT 22
102346: PUSH
102347: LD_OWVAR 2
102351: PUSH
102352: EMPTY
102353: LIST
102354: LIST
102355: PUSH
102356: LD_INT 25
102358: PUSH
102359: LD_INT 1
102361: PUSH
102362: EMPTY
102363: LIST
102364: LIST
102365: PUSH
102366: EMPTY
102367: LIST
102368: LIST
102369: PPUSH
102370: CALL_OW 69
102374: ST_TO_ADDR
// if not tmp then
102375: LD_VAR 0 3
102379: NOT
102380: IFFALSE 102384
// exit ;
102382: GO 102470
// un := tmp [ rand ( 1 , tmp ) ] ;
102384: LD_ADDR_VAR 0 2
102388: PUSH
102389: LD_VAR 0 3
102393: PUSH
102394: LD_INT 1
102396: PPUSH
102397: LD_VAR 0 3
102401: PPUSH
102402: CALL_OW 12
102406: ARRAY
102407: ST_TO_ADDR
// if Crawls ( un ) then
102408: LD_VAR 0 2
102412: PPUSH
102413: CALL_OW 318
102417: IFFALSE 102428
// ComWalk ( un ) ;
102419: LD_VAR 0 2
102423: PPUSH
102424: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102428: LD_VAR 0 2
102432: PPUSH
102433: LD_INT 9
102435: PPUSH
102436: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102440: LD_INT 28
102442: PPUSH
102443: LD_OWVAR 2
102447: PPUSH
102448: LD_INT 2
102450: PPUSH
102451: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102455: LD_INT 29
102457: PPUSH
102458: LD_OWVAR 2
102462: PPUSH
102463: LD_INT 2
102465: PPUSH
102466: CALL_OW 322
// end ;
102470: PPOPN 3
102472: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102473: LD_EXP 98
102477: PUSH
102478: LD_EXP 141
102482: AND
102483: IFFALSE 102594
102485: GO 102487
102487: DISABLE
102488: LD_INT 0
102490: PPUSH
102491: PPUSH
102492: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102493: LD_ADDR_VAR 0 3
102497: PUSH
102498: LD_INT 22
102500: PUSH
102501: LD_OWVAR 2
102505: PUSH
102506: EMPTY
102507: LIST
102508: LIST
102509: PUSH
102510: LD_INT 25
102512: PUSH
102513: LD_INT 1
102515: PUSH
102516: EMPTY
102517: LIST
102518: LIST
102519: PUSH
102520: EMPTY
102521: LIST
102522: LIST
102523: PPUSH
102524: CALL_OW 69
102528: ST_TO_ADDR
// if not tmp then
102529: LD_VAR 0 3
102533: NOT
102534: IFFALSE 102538
// exit ;
102536: GO 102594
// un := tmp [ rand ( 1 , tmp ) ] ;
102538: LD_ADDR_VAR 0 2
102542: PUSH
102543: LD_VAR 0 3
102547: PUSH
102548: LD_INT 1
102550: PPUSH
102551: LD_VAR 0 3
102555: PPUSH
102556: CALL_OW 12
102560: ARRAY
102561: ST_TO_ADDR
// if Crawls ( un ) then
102562: LD_VAR 0 2
102566: PPUSH
102567: CALL_OW 318
102571: IFFALSE 102582
// ComWalk ( un ) ;
102573: LD_VAR 0 2
102577: PPUSH
102578: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102582: LD_VAR 0 2
102586: PPUSH
102587: LD_INT 8
102589: PPUSH
102590: CALL_OW 336
// end ;
102594: PPOPN 3
102596: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102597: LD_EXP 98
102601: PUSH
102602: LD_EXP 142
102606: AND
102607: IFFALSE 102751
102609: GO 102611
102611: DISABLE
102612: LD_INT 0
102614: PPUSH
102615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102616: LD_ADDR_VAR 0 2
102620: PUSH
102621: LD_INT 22
102623: PUSH
102624: LD_OWVAR 2
102628: PUSH
102629: EMPTY
102630: LIST
102631: LIST
102632: PUSH
102633: LD_INT 21
102635: PUSH
102636: LD_INT 2
102638: PUSH
102639: EMPTY
102640: LIST
102641: LIST
102642: PUSH
102643: LD_INT 2
102645: PUSH
102646: LD_INT 34
102648: PUSH
102649: LD_INT 12
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: PUSH
102656: LD_INT 34
102658: PUSH
102659: LD_INT 51
102661: PUSH
102662: EMPTY
102663: LIST
102664: LIST
102665: PUSH
102666: LD_INT 34
102668: PUSH
102669: LD_INT 32
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: PUSH
102676: EMPTY
102677: LIST
102678: LIST
102679: LIST
102680: LIST
102681: PUSH
102682: EMPTY
102683: LIST
102684: LIST
102685: LIST
102686: PPUSH
102687: CALL_OW 69
102691: ST_TO_ADDR
// if not tmp then
102692: LD_VAR 0 2
102696: NOT
102697: IFFALSE 102701
// exit ;
102699: GO 102751
// for i in tmp do
102701: LD_ADDR_VAR 0 1
102705: PUSH
102706: LD_VAR 0 2
102710: PUSH
102711: FOR_IN
102712: IFFALSE 102749
// if GetCargo ( i , mat_artifact ) = 0 then
102714: LD_VAR 0 1
102718: PPUSH
102719: LD_INT 4
102721: PPUSH
102722: CALL_OW 289
102726: PUSH
102727: LD_INT 0
102729: EQUAL
102730: IFFALSE 102747
// SetCargo ( i , mat_siberit , 100 ) ;
102732: LD_VAR 0 1
102736: PPUSH
102737: LD_INT 3
102739: PPUSH
102740: LD_INT 100
102742: PPUSH
102743: CALL_OW 290
102747: GO 102711
102749: POP
102750: POP
// end ;
102751: PPOPN 2
102753: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102754: LD_EXP 98
102758: PUSH
102759: LD_EXP 143
102763: AND
102764: IFFALSE 102947
102766: GO 102768
102768: DISABLE
102769: LD_INT 0
102771: PPUSH
102772: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102773: LD_ADDR_VAR 0 2
102777: PUSH
102778: LD_INT 22
102780: PUSH
102781: LD_OWVAR 2
102785: PUSH
102786: EMPTY
102787: LIST
102788: LIST
102789: PPUSH
102790: CALL_OW 69
102794: ST_TO_ADDR
// if not tmp then
102795: LD_VAR 0 2
102799: NOT
102800: IFFALSE 102804
// exit ;
102802: GO 102947
// for i := 1 to 2 do
102804: LD_ADDR_VAR 0 1
102808: PUSH
102809: DOUBLE
102810: LD_INT 1
102812: DEC
102813: ST_TO_ADDR
102814: LD_INT 2
102816: PUSH
102817: FOR_TO
102818: IFFALSE 102945
// begin uc_side := your_side ;
102820: LD_ADDR_OWVAR 20
102824: PUSH
102825: LD_OWVAR 2
102829: ST_TO_ADDR
// uc_nation := nation_american ;
102830: LD_ADDR_OWVAR 21
102834: PUSH
102835: LD_INT 1
102837: ST_TO_ADDR
// vc_chassis := us_morphling ;
102838: LD_ADDR_OWVAR 37
102842: PUSH
102843: LD_INT 5
102845: ST_TO_ADDR
// vc_engine := engine_siberite ;
102846: LD_ADDR_OWVAR 39
102850: PUSH
102851: LD_INT 3
102853: ST_TO_ADDR
// vc_control := control_computer ;
102854: LD_ADDR_OWVAR 38
102858: PUSH
102859: LD_INT 3
102861: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102862: LD_ADDR_OWVAR 40
102866: PUSH
102867: LD_INT 10
102869: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102870: LD_VAR 0 2
102874: PUSH
102875: LD_INT 1
102877: ARRAY
102878: PPUSH
102879: CALL_OW 310
102883: NOT
102884: IFFALSE 102931
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102886: CALL_OW 45
102890: PPUSH
102891: LD_VAR 0 2
102895: PUSH
102896: LD_INT 1
102898: ARRAY
102899: PPUSH
102900: CALL_OW 250
102904: PPUSH
102905: LD_VAR 0 2
102909: PUSH
102910: LD_INT 1
102912: ARRAY
102913: PPUSH
102914: CALL_OW 251
102918: PPUSH
102919: LD_INT 12
102921: PPUSH
102922: LD_INT 1
102924: PPUSH
102925: CALL_OW 50
102929: GO 102943
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102931: CALL_OW 45
102935: PPUSH
102936: LD_INT 1
102938: PPUSH
102939: CALL_OW 51
// end ;
102943: GO 102817
102945: POP
102946: POP
// end ;
102947: PPOPN 2
102949: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102950: LD_EXP 98
102954: PUSH
102955: LD_EXP 144
102959: AND
102960: IFFALSE 103182
102962: GO 102964
102964: DISABLE
102965: LD_INT 0
102967: PPUSH
102968: PPUSH
102969: PPUSH
102970: PPUSH
102971: PPUSH
102972: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102973: LD_ADDR_VAR 0 6
102977: PUSH
102978: LD_INT 22
102980: PUSH
102981: LD_OWVAR 2
102985: PUSH
102986: EMPTY
102987: LIST
102988: LIST
102989: PUSH
102990: LD_INT 21
102992: PUSH
102993: LD_INT 1
102995: PUSH
102996: EMPTY
102997: LIST
102998: LIST
102999: PUSH
103000: LD_INT 3
103002: PUSH
103003: LD_INT 23
103005: PUSH
103006: LD_INT 0
103008: PUSH
103009: EMPTY
103010: LIST
103011: LIST
103012: PUSH
103013: EMPTY
103014: LIST
103015: LIST
103016: PUSH
103017: EMPTY
103018: LIST
103019: LIST
103020: LIST
103021: PPUSH
103022: CALL_OW 69
103026: ST_TO_ADDR
// if not tmp then
103027: LD_VAR 0 6
103031: NOT
103032: IFFALSE 103036
// exit ;
103034: GO 103182
// s1 := rand ( 1 , 4 ) ;
103036: LD_ADDR_VAR 0 2
103040: PUSH
103041: LD_INT 1
103043: PPUSH
103044: LD_INT 4
103046: PPUSH
103047: CALL_OW 12
103051: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103052: LD_ADDR_VAR 0 4
103056: PUSH
103057: LD_VAR 0 6
103061: PUSH
103062: LD_INT 1
103064: ARRAY
103065: PPUSH
103066: LD_VAR 0 2
103070: PPUSH
103071: CALL_OW 259
103075: ST_TO_ADDR
// if s1 = 1 then
103076: LD_VAR 0 2
103080: PUSH
103081: LD_INT 1
103083: EQUAL
103084: IFFALSE 103104
// s2 := rand ( 2 , 4 ) else
103086: LD_ADDR_VAR 0 3
103090: PUSH
103091: LD_INT 2
103093: PPUSH
103094: LD_INT 4
103096: PPUSH
103097: CALL_OW 12
103101: ST_TO_ADDR
103102: GO 103112
// s2 := 1 ;
103104: LD_ADDR_VAR 0 3
103108: PUSH
103109: LD_INT 1
103111: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103112: LD_ADDR_VAR 0 5
103116: PUSH
103117: LD_VAR 0 6
103121: PUSH
103122: LD_INT 1
103124: ARRAY
103125: PPUSH
103126: LD_VAR 0 3
103130: PPUSH
103131: CALL_OW 259
103135: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103136: LD_VAR 0 6
103140: PUSH
103141: LD_INT 1
103143: ARRAY
103144: PPUSH
103145: LD_VAR 0 2
103149: PPUSH
103150: LD_VAR 0 5
103154: PPUSH
103155: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103159: LD_VAR 0 6
103163: PUSH
103164: LD_INT 1
103166: ARRAY
103167: PPUSH
103168: LD_VAR 0 3
103172: PPUSH
103173: LD_VAR 0 4
103177: PPUSH
103178: CALL_OW 237
// end ;
103182: PPOPN 6
103184: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103185: LD_EXP 98
103189: PUSH
103190: LD_EXP 145
103194: AND
103195: IFFALSE 103274
103197: GO 103199
103199: DISABLE
103200: LD_INT 0
103202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103203: LD_ADDR_VAR 0 1
103207: PUSH
103208: LD_INT 22
103210: PUSH
103211: LD_OWVAR 2
103215: PUSH
103216: EMPTY
103217: LIST
103218: LIST
103219: PUSH
103220: LD_INT 30
103222: PUSH
103223: LD_INT 3
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: PUSH
103230: EMPTY
103231: LIST
103232: LIST
103233: PPUSH
103234: CALL_OW 69
103238: ST_TO_ADDR
// if not tmp then
103239: LD_VAR 0 1
103243: NOT
103244: IFFALSE 103248
// exit ;
103246: GO 103274
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103248: LD_VAR 0 1
103252: PUSH
103253: LD_INT 1
103255: PPUSH
103256: LD_VAR 0 1
103260: PPUSH
103261: CALL_OW 12
103265: ARRAY
103266: PPUSH
103267: LD_INT 1
103269: PPUSH
103270: CALL_OW 234
// end ;
103274: PPOPN 1
103276: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103277: LD_EXP 98
103281: PUSH
103282: LD_EXP 146
103286: AND
103287: IFFALSE 103399
103289: GO 103291
103291: DISABLE
103292: LD_INT 0
103294: PPUSH
103295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103296: LD_ADDR_VAR 0 2
103300: PUSH
103301: LD_INT 22
103303: PUSH
103304: LD_OWVAR 2
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: PUSH
103313: LD_INT 2
103315: PUSH
103316: LD_INT 30
103318: PUSH
103319: LD_INT 27
103321: PUSH
103322: EMPTY
103323: LIST
103324: LIST
103325: PUSH
103326: LD_INT 30
103328: PUSH
103329: LD_INT 26
103331: PUSH
103332: EMPTY
103333: LIST
103334: LIST
103335: PUSH
103336: LD_INT 30
103338: PUSH
103339: LD_INT 28
103341: PUSH
103342: EMPTY
103343: LIST
103344: LIST
103345: PUSH
103346: EMPTY
103347: LIST
103348: LIST
103349: LIST
103350: LIST
103351: PUSH
103352: EMPTY
103353: LIST
103354: LIST
103355: PPUSH
103356: CALL_OW 69
103360: ST_TO_ADDR
// if not tmp then
103361: LD_VAR 0 2
103365: NOT
103366: IFFALSE 103370
// exit ;
103368: GO 103399
// for i in tmp do
103370: LD_ADDR_VAR 0 1
103374: PUSH
103375: LD_VAR 0 2
103379: PUSH
103380: FOR_IN
103381: IFFALSE 103397
// SetLives ( i , 1 ) ;
103383: LD_VAR 0 1
103387: PPUSH
103388: LD_INT 1
103390: PPUSH
103391: CALL_OW 234
103395: GO 103380
103397: POP
103398: POP
// end ;
103399: PPOPN 2
103401: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103402: LD_EXP 98
103406: PUSH
103407: LD_EXP 147
103411: AND
103412: IFFALSE 103699
103414: GO 103416
103416: DISABLE
103417: LD_INT 0
103419: PPUSH
103420: PPUSH
103421: PPUSH
// begin i := rand ( 1 , 7 ) ;
103422: LD_ADDR_VAR 0 1
103426: PUSH
103427: LD_INT 1
103429: PPUSH
103430: LD_INT 7
103432: PPUSH
103433: CALL_OW 12
103437: ST_TO_ADDR
// case i of 1 :
103438: LD_VAR 0 1
103442: PUSH
103443: LD_INT 1
103445: DOUBLE
103446: EQUAL
103447: IFTRUE 103451
103449: GO 103461
103451: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103452: LD_STRING earthquake(getX(game), 0, 32)
103454: PPUSH
103455: CALL_OW 559
103459: GO 103699
103461: LD_INT 2
103463: DOUBLE
103464: EQUAL
103465: IFTRUE 103469
103467: GO 103483
103469: POP
// begin ToLua ( displayStucuk(); ) ;
103470: LD_STRING displayStucuk();
103472: PPUSH
103473: CALL_OW 559
// ResetFog ;
103477: CALL_OW 335
// end ; 3 :
103481: GO 103699
103483: LD_INT 3
103485: DOUBLE
103486: EQUAL
103487: IFTRUE 103491
103489: GO 103595
103491: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103492: LD_ADDR_VAR 0 2
103496: PUSH
103497: LD_INT 22
103499: PUSH
103500: LD_OWVAR 2
103504: PUSH
103505: EMPTY
103506: LIST
103507: LIST
103508: PUSH
103509: LD_INT 25
103511: PUSH
103512: LD_INT 1
103514: PUSH
103515: EMPTY
103516: LIST
103517: LIST
103518: PUSH
103519: EMPTY
103520: LIST
103521: LIST
103522: PPUSH
103523: CALL_OW 69
103527: ST_TO_ADDR
// if not tmp then
103528: LD_VAR 0 2
103532: NOT
103533: IFFALSE 103537
// exit ;
103535: GO 103699
// un := tmp [ rand ( 1 , tmp ) ] ;
103537: LD_ADDR_VAR 0 3
103541: PUSH
103542: LD_VAR 0 2
103546: PUSH
103547: LD_INT 1
103549: PPUSH
103550: LD_VAR 0 2
103554: PPUSH
103555: CALL_OW 12
103559: ARRAY
103560: ST_TO_ADDR
// if Crawls ( un ) then
103561: LD_VAR 0 3
103565: PPUSH
103566: CALL_OW 318
103570: IFFALSE 103581
// ComWalk ( un ) ;
103572: LD_VAR 0 3
103576: PPUSH
103577: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103581: LD_VAR 0 3
103585: PPUSH
103586: LD_INT 8
103588: PPUSH
103589: CALL_OW 336
// end ; 4 :
103593: GO 103699
103595: LD_INT 4
103597: DOUBLE
103598: EQUAL
103599: IFTRUE 103603
103601: GO 103677
103603: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103604: LD_ADDR_VAR 0 2
103608: PUSH
103609: LD_INT 22
103611: PUSH
103612: LD_OWVAR 2
103616: PUSH
103617: EMPTY
103618: LIST
103619: LIST
103620: PUSH
103621: LD_INT 30
103623: PUSH
103624: LD_INT 29
103626: PUSH
103627: EMPTY
103628: LIST
103629: LIST
103630: PUSH
103631: EMPTY
103632: LIST
103633: LIST
103634: PPUSH
103635: CALL_OW 69
103639: ST_TO_ADDR
// if not tmp then
103640: LD_VAR 0 2
103644: NOT
103645: IFFALSE 103649
// exit ;
103647: GO 103699
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103649: LD_VAR 0 2
103653: PUSH
103654: LD_INT 1
103656: ARRAY
103657: PPUSH
103658: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103662: LD_VAR 0 2
103666: PUSH
103667: LD_INT 1
103669: ARRAY
103670: PPUSH
103671: CALL_OW 65
// end ; 5 .. 7 :
103675: GO 103699
103677: LD_INT 5
103679: DOUBLE
103680: GREATEREQUAL
103681: IFFALSE 103689
103683: LD_INT 7
103685: DOUBLE
103686: LESSEQUAL
103687: IFTRUE 103691
103689: GO 103698
103691: POP
// StreamSibBomb ; end ;
103692: CALL 99936 0 0
103696: GO 103699
103698: POP
// end ;
103699: PPOPN 3
103701: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103702: LD_EXP 98
103706: PUSH
103707: LD_EXP 148
103711: AND
103712: IFFALSE 103868
103714: GO 103716
103716: DISABLE
103717: LD_INT 0
103719: PPUSH
103720: PPUSH
103721: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103722: LD_ADDR_VAR 0 2
103726: PUSH
103727: LD_INT 81
103729: PUSH
103730: LD_OWVAR 2
103734: PUSH
103735: EMPTY
103736: LIST
103737: LIST
103738: PUSH
103739: LD_INT 2
103741: PUSH
103742: LD_INT 21
103744: PUSH
103745: LD_INT 1
103747: PUSH
103748: EMPTY
103749: LIST
103750: LIST
103751: PUSH
103752: LD_INT 21
103754: PUSH
103755: LD_INT 2
103757: PUSH
103758: EMPTY
103759: LIST
103760: LIST
103761: PUSH
103762: EMPTY
103763: LIST
103764: LIST
103765: LIST
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PPUSH
103771: CALL_OW 69
103775: ST_TO_ADDR
// if not tmp then
103776: LD_VAR 0 2
103780: NOT
103781: IFFALSE 103785
// exit ;
103783: GO 103868
// p := 0 ;
103785: LD_ADDR_VAR 0 3
103789: PUSH
103790: LD_INT 0
103792: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103793: LD_INT 35
103795: PPUSH
103796: CALL_OW 67
// p := p + 1 ;
103800: LD_ADDR_VAR 0 3
103804: PUSH
103805: LD_VAR 0 3
103809: PUSH
103810: LD_INT 1
103812: PLUS
103813: ST_TO_ADDR
// for i in tmp do
103814: LD_ADDR_VAR 0 1
103818: PUSH
103819: LD_VAR 0 2
103823: PUSH
103824: FOR_IN
103825: IFFALSE 103856
// if GetLives ( i ) < 1000 then
103827: LD_VAR 0 1
103831: PPUSH
103832: CALL_OW 256
103836: PUSH
103837: LD_INT 1000
103839: LESS
103840: IFFALSE 103854
// SetLives ( i , 1000 ) ;
103842: LD_VAR 0 1
103846: PPUSH
103847: LD_INT 1000
103849: PPUSH
103850: CALL_OW 234
103854: GO 103824
103856: POP
103857: POP
// until p > 20 ;
103858: LD_VAR 0 3
103862: PUSH
103863: LD_INT 20
103865: GREATER
103866: IFFALSE 103793
// end ;
103868: PPOPN 3
103870: END
// every 0 0$1 trigger StreamModeActive and sTime do
103871: LD_EXP 98
103875: PUSH
103876: LD_EXP 149
103880: AND
103881: IFFALSE 103916
103883: GO 103885
103885: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103886: LD_INT 28
103888: PPUSH
103889: LD_OWVAR 2
103893: PPUSH
103894: LD_INT 2
103896: PPUSH
103897: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103901: LD_INT 30
103903: PPUSH
103904: LD_OWVAR 2
103908: PPUSH
103909: LD_INT 2
103911: PPUSH
103912: CALL_OW 322
// end ;
103916: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103917: LD_EXP 98
103921: PUSH
103922: LD_EXP 150
103926: AND
103927: IFFALSE 104048
103929: GO 103931
103931: DISABLE
103932: LD_INT 0
103934: PPUSH
103935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103936: LD_ADDR_VAR 0 2
103940: PUSH
103941: LD_INT 22
103943: PUSH
103944: LD_OWVAR 2
103948: PUSH
103949: EMPTY
103950: LIST
103951: LIST
103952: PUSH
103953: LD_INT 21
103955: PUSH
103956: LD_INT 1
103958: PUSH
103959: EMPTY
103960: LIST
103961: LIST
103962: PUSH
103963: LD_INT 3
103965: PUSH
103966: LD_INT 23
103968: PUSH
103969: LD_INT 0
103971: PUSH
103972: EMPTY
103973: LIST
103974: LIST
103975: PUSH
103976: EMPTY
103977: LIST
103978: LIST
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: LIST
103984: PPUSH
103985: CALL_OW 69
103989: ST_TO_ADDR
// if not tmp then
103990: LD_VAR 0 2
103994: NOT
103995: IFFALSE 103999
// exit ;
103997: GO 104048
// for i in tmp do
103999: LD_ADDR_VAR 0 1
104003: PUSH
104004: LD_VAR 0 2
104008: PUSH
104009: FOR_IN
104010: IFFALSE 104046
// begin if Crawls ( i ) then
104012: LD_VAR 0 1
104016: PPUSH
104017: CALL_OW 318
104021: IFFALSE 104032
// ComWalk ( i ) ;
104023: LD_VAR 0 1
104027: PPUSH
104028: CALL_OW 138
// SetClass ( i , 2 ) ;
104032: LD_VAR 0 1
104036: PPUSH
104037: LD_INT 2
104039: PPUSH
104040: CALL_OW 336
// end ;
104044: GO 104009
104046: POP
104047: POP
// end ;
104048: PPOPN 2
104050: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104051: LD_EXP 98
104055: PUSH
104056: LD_EXP 151
104060: AND
104061: IFFALSE 104349
104063: GO 104065
104065: DISABLE
104066: LD_INT 0
104068: PPUSH
104069: PPUSH
104070: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104071: LD_OWVAR 2
104075: PPUSH
104076: LD_INT 9
104078: PPUSH
104079: LD_INT 1
104081: PPUSH
104082: LD_INT 1
104084: PPUSH
104085: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104089: LD_INT 9
104091: PPUSH
104092: LD_OWVAR 2
104096: PPUSH
104097: CALL_OW 343
// uc_side := 9 ;
104101: LD_ADDR_OWVAR 20
104105: PUSH
104106: LD_INT 9
104108: ST_TO_ADDR
// uc_nation := 2 ;
104109: LD_ADDR_OWVAR 21
104113: PUSH
104114: LD_INT 2
104116: ST_TO_ADDR
// hc_name := Dark Warrior ;
104117: LD_ADDR_OWVAR 26
104121: PUSH
104122: LD_STRING Dark Warrior
104124: ST_TO_ADDR
// hc_gallery :=  ;
104125: LD_ADDR_OWVAR 33
104129: PUSH
104130: LD_STRING 
104132: ST_TO_ADDR
// hc_noskilllimit := true ;
104133: LD_ADDR_OWVAR 76
104137: PUSH
104138: LD_INT 1
104140: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104141: LD_ADDR_OWVAR 31
104145: PUSH
104146: LD_INT 30
104148: PUSH
104149: LD_INT 30
104151: PUSH
104152: LD_INT 30
104154: PUSH
104155: LD_INT 30
104157: PUSH
104158: EMPTY
104159: LIST
104160: LIST
104161: LIST
104162: LIST
104163: ST_TO_ADDR
// un := CreateHuman ;
104164: LD_ADDR_VAR 0 3
104168: PUSH
104169: CALL_OW 44
104173: ST_TO_ADDR
// hc_noskilllimit := false ;
104174: LD_ADDR_OWVAR 76
104178: PUSH
104179: LD_INT 0
104181: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104182: LD_VAR 0 3
104186: PPUSH
104187: LD_INT 1
104189: PPUSH
104190: CALL_OW 51
// ToLua ( playRanger() ) ;
104194: LD_STRING playRanger()
104196: PPUSH
104197: CALL_OW 559
// p := 0 ;
104201: LD_ADDR_VAR 0 2
104205: PUSH
104206: LD_INT 0
104208: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104209: LD_INT 35
104211: PPUSH
104212: CALL_OW 67
// p := p + 1 ;
104216: LD_ADDR_VAR 0 2
104220: PUSH
104221: LD_VAR 0 2
104225: PUSH
104226: LD_INT 1
104228: PLUS
104229: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104230: LD_VAR 0 3
104234: PPUSH
104235: CALL_OW 256
104239: PUSH
104240: LD_INT 1000
104242: LESS
104243: IFFALSE 104257
// SetLives ( un , 1000 ) ;
104245: LD_VAR 0 3
104249: PPUSH
104250: LD_INT 1000
104252: PPUSH
104253: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104257: LD_VAR 0 3
104261: PPUSH
104262: LD_INT 81
104264: PUSH
104265: LD_OWVAR 2
104269: PUSH
104270: EMPTY
104271: LIST
104272: LIST
104273: PUSH
104274: LD_INT 91
104276: PUSH
104277: LD_VAR 0 3
104281: PUSH
104282: LD_INT 30
104284: PUSH
104285: EMPTY
104286: LIST
104287: LIST
104288: LIST
104289: PUSH
104290: EMPTY
104291: LIST
104292: LIST
104293: PPUSH
104294: CALL_OW 69
104298: PPUSH
104299: LD_VAR 0 3
104303: PPUSH
104304: CALL_OW 74
104308: PPUSH
104309: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104313: LD_VAR 0 2
104317: PUSH
104318: LD_INT 80
104320: GREATER
104321: PUSH
104322: LD_VAR 0 3
104326: PPUSH
104327: CALL_OW 301
104331: OR
104332: IFFALSE 104209
// if un then
104334: LD_VAR 0 3
104338: IFFALSE 104349
// RemoveUnit ( un ) ;
104340: LD_VAR 0 3
104344: PPUSH
104345: CALL_OW 64
// end ;
104349: PPOPN 3
104351: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104352: LD_EXP 152
104356: IFFALSE 104472
104358: GO 104360
104360: DISABLE
104361: LD_INT 0
104363: PPUSH
104364: PPUSH
104365: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104366: LD_ADDR_VAR 0 2
104370: PUSH
104371: LD_INT 81
104373: PUSH
104374: LD_OWVAR 2
104378: PUSH
104379: EMPTY
104380: LIST
104381: LIST
104382: PUSH
104383: LD_INT 21
104385: PUSH
104386: LD_INT 1
104388: PUSH
104389: EMPTY
104390: LIST
104391: LIST
104392: PUSH
104393: EMPTY
104394: LIST
104395: LIST
104396: PPUSH
104397: CALL_OW 69
104401: ST_TO_ADDR
// if not tmp then
104402: LD_VAR 0 2
104406: NOT
104407: IFFALSE 104411
// exit ;
104409: GO 104472
// ToLua ( playComputer() ) ;
104411: LD_STRING playComputer()
104413: PPUSH
104414: CALL_OW 559
// for i in tmp do
104418: LD_ADDR_VAR 0 1
104422: PUSH
104423: LD_VAR 0 2
104427: PUSH
104428: FOR_IN
104429: IFFALSE 104470
// for j := 1 to 4 do
104431: LD_ADDR_VAR 0 3
104435: PUSH
104436: DOUBLE
104437: LD_INT 1
104439: DEC
104440: ST_TO_ADDR
104441: LD_INT 4
104443: PUSH
104444: FOR_TO
104445: IFFALSE 104466
// SetSkill ( i , j , 10 ) ;
104447: LD_VAR 0 1
104451: PPUSH
104452: LD_VAR 0 3
104456: PPUSH
104457: LD_INT 10
104459: PPUSH
104460: CALL_OW 237
104464: GO 104444
104466: POP
104467: POP
104468: GO 104428
104470: POP
104471: POP
// end ;
104472: PPOPN 3
104474: END
// every 0 0$1 trigger s30 do var i , tmp ;
104475: LD_EXP 153
104479: IFFALSE 104548
104481: GO 104483
104483: DISABLE
104484: LD_INT 0
104486: PPUSH
104487: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104488: LD_ADDR_VAR 0 2
104492: PUSH
104493: LD_INT 22
104495: PUSH
104496: LD_OWVAR 2
104500: PUSH
104501: EMPTY
104502: LIST
104503: LIST
104504: PPUSH
104505: CALL_OW 69
104509: ST_TO_ADDR
// if not tmp then
104510: LD_VAR 0 2
104514: NOT
104515: IFFALSE 104519
// exit ;
104517: GO 104548
// for i in tmp do
104519: LD_ADDR_VAR 0 1
104523: PUSH
104524: LD_VAR 0 2
104528: PUSH
104529: FOR_IN
104530: IFFALSE 104546
// SetLives ( i , 300 ) ;
104532: LD_VAR 0 1
104536: PPUSH
104537: LD_INT 300
104539: PPUSH
104540: CALL_OW 234
104544: GO 104529
104546: POP
104547: POP
// end ;
104548: PPOPN 2
104550: END
// every 0 0$1 trigger s60 do var i , tmp ;
104551: LD_EXP 154
104555: IFFALSE 104624
104557: GO 104559
104559: DISABLE
104560: LD_INT 0
104562: PPUSH
104563: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104564: LD_ADDR_VAR 0 2
104568: PUSH
104569: LD_INT 22
104571: PUSH
104572: LD_OWVAR 2
104576: PUSH
104577: EMPTY
104578: LIST
104579: LIST
104580: PPUSH
104581: CALL_OW 69
104585: ST_TO_ADDR
// if not tmp then
104586: LD_VAR 0 2
104590: NOT
104591: IFFALSE 104595
// exit ;
104593: GO 104624
// for i in tmp do
104595: LD_ADDR_VAR 0 1
104599: PUSH
104600: LD_VAR 0 2
104604: PUSH
104605: FOR_IN
104606: IFFALSE 104622
// SetLives ( i , 600 ) ;
104608: LD_VAR 0 1
104612: PPUSH
104613: LD_INT 600
104615: PPUSH
104616: CALL_OW 234
104620: GO 104605
104622: POP
104623: POP
// end ;
104624: PPOPN 2
104626: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104627: LD_INT 0
104629: PPUSH
// case cmd of 301 :
104630: LD_VAR 0 1
104634: PUSH
104635: LD_INT 301
104637: DOUBLE
104638: EQUAL
104639: IFTRUE 104643
104641: GO 104675
104643: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104644: LD_VAR 0 6
104648: PPUSH
104649: LD_VAR 0 7
104653: PPUSH
104654: LD_VAR 0 8
104658: PPUSH
104659: LD_VAR 0 4
104663: PPUSH
104664: LD_VAR 0 5
104668: PPUSH
104669: CALL 105876 0 5
104673: GO 104796
104675: LD_INT 302
104677: DOUBLE
104678: EQUAL
104679: IFTRUE 104683
104681: GO 104720
104683: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104684: LD_VAR 0 6
104688: PPUSH
104689: LD_VAR 0 7
104693: PPUSH
104694: LD_VAR 0 8
104698: PPUSH
104699: LD_VAR 0 9
104703: PPUSH
104704: LD_VAR 0 4
104708: PPUSH
104709: LD_VAR 0 5
104713: PPUSH
104714: CALL 105967 0 6
104718: GO 104796
104720: LD_INT 303
104722: DOUBLE
104723: EQUAL
104724: IFTRUE 104728
104726: GO 104765
104728: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104729: LD_VAR 0 6
104733: PPUSH
104734: LD_VAR 0 7
104738: PPUSH
104739: LD_VAR 0 8
104743: PPUSH
104744: LD_VAR 0 9
104748: PPUSH
104749: LD_VAR 0 4
104753: PPUSH
104754: LD_VAR 0 5
104758: PPUSH
104759: CALL 104801 0 6
104763: GO 104796
104765: LD_INT 304
104767: DOUBLE
104768: EQUAL
104769: IFTRUE 104773
104771: GO 104795
104773: POP
// hHackTeleport ( unit , x , y ) ; end ;
104774: LD_VAR 0 2
104778: PPUSH
104779: LD_VAR 0 4
104783: PPUSH
104784: LD_VAR 0 5
104788: PPUSH
104789: CALL 106560 0 3
104793: GO 104796
104795: POP
// end ;
104796: LD_VAR 0 12
104800: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104801: LD_INT 0
104803: PPUSH
104804: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104805: LD_VAR 0 1
104809: PUSH
104810: LD_INT 1
104812: LESS
104813: PUSH
104814: LD_VAR 0 1
104818: PUSH
104819: LD_INT 3
104821: GREATER
104822: OR
104823: PUSH
104824: LD_VAR 0 5
104828: PPUSH
104829: LD_VAR 0 6
104833: PPUSH
104834: CALL_OW 428
104838: OR
104839: IFFALSE 104843
// exit ;
104841: GO 105563
// uc_side := your_side ;
104843: LD_ADDR_OWVAR 20
104847: PUSH
104848: LD_OWVAR 2
104852: ST_TO_ADDR
// uc_nation := nation ;
104853: LD_ADDR_OWVAR 21
104857: PUSH
104858: LD_VAR 0 1
104862: ST_TO_ADDR
// bc_level = 1 ;
104863: LD_ADDR_OWVAR 43
104867: PUSH
104868: LD_INT 1
104870: ST_TO_ADDR
// case btype of 1 :
104871: LD_VAR 0 2
104875: PUSH
104876: LD_INT 1
104878: DOUBLE
104879: EQUAL
104880: IFTRUE 104884
104882: GO 104895
104884: POP
// bc_type := b_depot ; 2 :
104885: LD_ADDR_OWVAR 42
104889: PUSH
104890: LD_INT 0
104892: ST_TO_ADDR
104893: GO 105507
104895: LD_INT 2
104897: DOUBLE
104898: EQUAL
104899: IFTRUE 104903
104901: GO 104914
104903: POP
// bc_type := b_warehouse ; 3 :
104904: LD_ADDR_OWVAR 42
104908: PUSH
104909: LD_INT 1
104911: ST_TO_ADDR
104912: GO 105507
104914: LD_INT 3
104916: DOUBLE
104917: EQUAL
104918: IFTRUE 104922
104920: GO 104933
104922: POP
// bc_type := b_lab ; 4 .. 9 :
104923: LD_ADDR_OWVAR 42
104927: PUSH
104928: LD_INT 6
104930: ST_TO_ADDR
104931: GO 105507
104933: LD_INT 4
104935: DOUBLE
104936: GREATEREQUAL
104937: IFFALSE 104945
104939: LD_INT 9
104941: DOUBLE
104942: LESSEQUAL
104943: IFTRUE 104947
104945: GO 104999
104947: POP
// begin bc_type := b_lab_half ;
104948: LD_ADDR_OWVAR 42
104952: PUSH
104953: LD_INT 7
104955: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104956: LD_ADDR_OWVAR 44
104960: PUSH
104961: LD_INT 10
104963: PUSH
104964: LD_INT 11
104966: PUSH
104967: LD_INT 12
104969: PUSH
104970: LD_INT 15
104972: PUSH
104973: LD_INT 14
104975: PUSH
104976: LD_INT 13
104978: PUSH
104979: EMPTY
104980: LIST
104981: LIST
104982: LIST
104983: LIST
104984: LIST
104985: LIST
104986: PUSH
104987: LD_VAR 0 2
104991: PUSH
104992: LD_INT 3
104994: MINUS
104995: ARRAY
104996: ST_TO_ADDR
// end ; 10 .. 13 :
104997: GO 105507
104999: LD_INT 10
105001: DOUBLE
105002: GREATEREQUAL
105003: IFFALSE 105011
105005: LD_INT 13
105007: DOUBLE
105008: LESSEQUAL
105009: IFTRUE 105013
105011: GO 105090
105013: POP
// begin bc_type := b_lab_full ;
105014: LD_ADDR_OWVAR 42
105018: PUSH
105019: LD_INT 8
105021: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105022: LD_ADDR_OWVAR 44
105026: PUSH
105027: LD_INT 10
105029: PUSH
105030: LD_INT 12
105032: PUSH
105033: LD_INT 14
105035: PUSH
105036: LD_INT 13
105038: PUSH
105039: EMPTY
105040: LIST
105041: LIST
105042: LIST
105043: LIST
105044: PUSH
105045: LD_VAR 0 2
105049: PUSH
105050: LD_INT 9
105052: MINUS
105053: ARRAY
105054: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105055: LD_ADDR_OWVAR 45
105059: PUSH
105060: LD_INT 11
105062: PUSH
105063: LD_INT 15
105065: PUSH
105066: LD_INT 12
105068: PUSH
105069: LD_INT 15
105071: PUSH
105072: EMPTY
105073: LIST
105074: LIST
105075: LIST
105076: LIST
105077: PUSH
105078: LD_VAR 0 2
105082: PUSH
105083: LD_INT 9
105085: MINUS
105086: ARRAY
105087: ST_TO_ADDR
// end ; 14 :
105088: GO 105507
105090: LD_INT 14
105092: DOUBLE
105093: EQUAL
105094: IFTRUE 105098
105096: GO 105109
105098: POP
// bc_type := b_workshop ; 15 :
105099: LD_ADDR_OWVAR 42
105103: PUSH
105104: LD_INT 2
105106: ST_TO_ADDR
105107: GO 105507
105109: LD_INT 15
105111: DOUBLE
105112: EQUAL
105113: IFTRUE 105117
105115: GO 105128
105117: POP
// bc_type := b_factory ; 16 :
105118: LD_ADDR_OWVAR 42
105122: PUSH
105123: LD_INT 3
105125: ST_TO_ADDR
105126: GO 105507
105128: LD_INT 16
105130: DOUBLE
105131: EQUAL
105132: IFTRUE 105136
105134: GO 105147
105136: POP
// bc_type := b_ext_gun ; 17 :
105137: LD_ADDR_OWVAR 42
105141: PUSH
105142: LD_INT 17
105144: ST_TO_ADDR
105145: GO 105507
105147: LD_INT 17
105149: DOUBLE
105150: EQUAL
105151: IFTRUE 105155
105153: GO 105183
105155: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105156: LD_ADDR_OWVAR 42
105160: PUSH
105161: LD_INT 19
105163: PUSH
105164: LD_INT 23
105166: PUSH
105167: LD_INT 19
105169: PUSH
105170: EMPTY
105171: LIST
105172: LIST
105173: LIST
105174: PUSH
105175: LD_VAR 0 1
105179: ARRAY
105180: ST_TO_ADDR
105181: GO 105507
105183: LD_INT 18
105185: DOUBLE
105186: EQUAL
105187: IFTRUE 105191
105189: GO 105202
105191: POP
// bc_type := b_ext_radar ; 19 :
105192: LD_ADDR_OWVAR 42
105196: PUSH
105197: LD_INT 20
105199: ST_TO_ADDR
105200: GO 105507
105202: LD_INT 19
105204: DOUBLE
105205: EQUAL
105206: IFTRUE 105210
105208: GO 105221
105210: POP
// bc_type := b_ext_radio ; 20 :
105211: LD_ADDR_OWVAR 42
105215: PUSH
105216: LD_INT 22
105218: ST_TO_ADDR
105219: GO 105507
105221: LD_INT 20
105223: DOUBLE
105224: EQUAL
105225: IFTRUE 105229
105227: GO 105240
105229: POP
// bc_type := b_ext_siberium ; 21 :
105230: LD_ADDR_OWVAR 42
105234: PUSH
105235: LD_INT 21
105237: ST_TO_ADDR
105238: GO 105507
105240: LD_INT 21
105242: DOUBLE
105243: EQUAL
105244: IFTRUE 105248
105246: GO 105259
105248: POP
// bc_type := b_ext_computer ; 22 :
105249: LD_ADDR_OWVAR 42
105253: PUSH
105254: LD_INT 24
105256: ST_TO_ADDR
105257: GO 105507
105259: LD_INT 22
105261: DOUBLE
105262: EQUAL
105263: IFTRUE 105267
105265: GO 105278
105267: POP
// bc_type := b_ext_track ; 23 :
105268: LD_ADDR_OWVAR 42
105272: PUSH
105273: LD_INT 16
105275: ST_TO_ADDR
105276: GO 105507
105278: LD_INT 23
105280: DOUBLE
105281: EQUAL
105282: IFTRUE 105286
105284: GO 105297
105286: POP
// bc_type := b_ext_laser ; 24 :
105287: LD_ADDR_OWVAR 42
105291: PUSH
105292: LD_INT 25
105294: ST_TO_ADDR
105295: GO 105507
105297: LD_INT 24
105299: DOUBLE
105300: EQUAL
105301: IFTRUE 105305
105303: GO 105316
105305: POP
// bc_type := b_control_tower ; 25 :
105306: LD_ADDR_OWVAR 42
105310: PUSH
105311: LD_INT 36
105313: ST_TO_ADDR
105314: GO 105507
105316: LD_INT 25
105318: DOUBLE
105319: EQUAL
105320: IFTRUE 105324
105322: GO 105335
105324: POP
// bc_type := b_breastwork ; 26 :
105325: LD_ADDR_OWVAR 42
105329: PUSH
105330: LD_INT 31
105332: ST_TO_ADDR
105333: GO 105507
105335: LD_INT 26
105337: DOUBLE
105338: EQUAL
105339: IFTRUE 105343
105341: GO 105354
105343: POP
// bc_type := b_bunker ; 27 :
105344: LD_ADDR_OWVAR 42
105348: PUSH
105349: LD_INT 32
105351: ST_TO_ADDR
105352: GO 105507
105354: LD_INT 27
105356: DOUBLE
105357: EQUAL
105358: IFTRUE 105362
105360: GO 105373
105362: POP
// bc_type := b_turret ; 28 :
105363: LD_ADDR_OWVAR 42
105367: PUSH
105368: LD_INT 33
105370: ST_TO_ADDR
105371: GO 105507
105373: LD_INT 28
105375: DOUBLE
105376: EQUAL
105377: IFTRUE 105381
105379: GO 105392
105381: POP
// bc_type := b_armoury ; 29 :
105382: LD_ADDR_OWVAR 42
105386: PUSH
105387: LD_INT 4
105389: ST_TO_ADDR
105390: GO 105507
105392: LD_INT 29
105394: DOUBLE
105395: EQUAL
105396: IFTRUE 105400
105398: GO 105411
105400: POP
// bc_type := b_barracks ; 30 :
105401: LD_ADDR_OWVAR 42
105405: PUSH
105406: LD_INT 5
105408: ST_TO_ADDR
105409: GO 105507
105411: LD_INT 30
105413: DOUBLE
105414: EQUAL
105415: IFTRUE 105419
105417: GO 105430
105419: POP
// bc_type := b_solar_power ; 31 :
105420: LD_ADDR_OWVAR 42
105424: PUSH
105425: LD_INT 27
105427: ST_TO_ADDR
105428: GO 105507
105430: LD_INT 31
105432: DOUBLE
105433: EQUAL
105434: IFTRUE 105438
105436: GO 105449
105438: POP
// bc_type := b_oil_power ; 32 :
105439: LD_ADDR_OWVAR 42
105443: PUSH
105444: LD_INT 26
105446: ST_TO_ADDR
105447: GO 105507
105449: LD_INT 32
105451: DOUBLE
105452: EQUAL
105453: IFTRUE 105457
105455: GO 105468
105457: POP
// bc_type := b_siberite_power ; 33 :
105458: LD_ADDR_OWVAR 42
105462: PUSH
105463: LD_INT 28
105465: ST_TO_ADDR
105466: GO 105507
105468: LD_INT 33
105470: DOUBLE
105471: EQUAL
105472: IFTRUE 105476
105474: GO 105487
105476: POP
// bc_type := b_oil_mine ; 34 :
105477: LD_ADDR_OWVAR 42
105481: PUSH
105482: LD_INT 29
105484: ST_TO_ADDR
105485: GO 105507
105487: LD_INT 34
105489: DOUBLE
105490: EQUAL
105491: IFTRUE 105495
105493: GO 105506
105495: POP
// bc_type := b_siberite_mine ; end ;
105496: LD_ADDR_OWVAR 42
105500: PUSH
105501: LD_INT 30
105503: ST_TO_ADDR
105504: GO 105507
105506: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105507: LD_ADDR_VAR 0 8
105511: PUSH
105512: LD_VAR 0 5
105516: PPUSH
105517: LD_VAR 0 6
105521: PPUSH
105522: LD_VAR 0 3
105526: PPUSH
105527: CALL_OW 47
105531: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105532: LD_OWVAR 42
105536: PUSH
105537: LD_INT 32
105539: PUSH
105540: LD_INT 33
105542: PUSH
105543: EMPTY
105544: LIST
105545: LIST
105546: IN
105547: IFFALSE 105563
// PlaceWeaponTurret ( b , weapon ) ;
105549: LD_VAR 0 8
105553: PPUSH
105554: LD_VAR 0 4
105558: PPUSH
105559: CALL_OW 431
// end ;
105563: LD_VAR 0 7
105567: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105568: LD_INT 0
105570: PPUSH
105571: PPUSH
105572: PPUSH
105573: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105574: LD_ADDR_VAR 0 4
105578: PUSH
105579: LD_INT 22
105581: PUSH
105582: LD_OWVAR 2
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: PUSH
105591: LD_INT 2
105593: PUSH
105594: LD_INT 30
105596: PUSH
105597: LD_INT 0
105599: PUSH
105600: EMPTY
105601: LIST
105602: LIST
105603: PUSH
105604: LD_INT 30
105606: PUSH
105607: LD_INT 1
105609: PUSH
105610: EMPTY
105611: LIST
105612: LIST
105613: PUSH
105614: EMPTY
105615: LIST
105616: LIST
105617: LIST
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: PPUSH
105623: CALL_OW 69
105627: ST_TO_ADDR
// if not tmp then
105628: LD_VAR 0 4
105632: NOT
105633: IFFALSE 105637
// exit ;
105635: GO 105696
// for i in tmp do
105637: LD_ADDR_VAR 0 2
105641: PUSH
105642: LD_VAR 0 4
105646: PUSH
105647: FOR_IN
105648: IFFALSE 105694
// for j = 1 to 3 do
105650: LD_ADDR_VAR 0 3
105654: PUSH
105655: DOUBLE
105656: LD_INT 1
105658: DEC
105659: ST_TO_ADDR
105660: LD_INT 3
105662: PUSH
105663: FOR_TO
105664: IFFALSE 105690
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105666: LD_VAR 0 2
105670: PPUSH
105671: CALL_OW 274
105675: PPUSH
105676: LD_VAR 0 3
105680: PPUSH
105681: LD_INT 99999
105683: PPUSH
105684: CALL_OW 277
105688: GO 105663
105690: POP
105691: POP
105692: GO 105647
105694: POP
105695: POP
// end ;
105696: LD_VAR 0 1
105700: RET
// export function hHackSetLevel10 ; var i , j ; begin
105701: LD_INT 0
105703: PPUSH
105704: PPUSH
105705: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105706: LD_ADDR_VAR 0 2
105710: PUSH
105711: LD_INT 21
105713: PUSH
105714: LD_INT 1
105716: PUSH
105717: EMPTY
105718: LIST
105719: LIST
105720: PPUSH
105721: CALL_OW 69
105725: PUSH
105726: FOR_IN
105727: IFFALSE 105779
// if IsSelected ( i ) then
105729: LD_VAR 0 2
105733: PPUSH
105734: CALL_OW 306
105738: IFFALSE 105777
// begin for j := 1 to 4 do
105740: LD_ADDR_VAR 0 3
105744: PUSH
105745: DOUBLE
105746: LD_INT 1
105748: DEC
105749: ST_TO_ADDR
105750: LD_INT 4
105752: PUSH
105753: FOR_TO
105754: IFFALSE 105775
// SetSkill ( i , j , 10 ) ;
105756: LD_VAR 0 2
105760: PPUSH
105761: LD_VAR 0 3
105765: PPUSH
105766: LD_INT 10
105768: PPUSH
105769: CALL_OW 237
105773: GO 105753
105775: POP
105776: POP
// end ;
105777: GO 105726
105779: POP
105780: POP
// end ;
105781: LD_VAR 0 1
105785: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105786: LD_INT 0
105788: PPUSH
105789: PPUSH
105790: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105791: LD_ADDR_VAR 0 2
105795: PUSH
105796: LD_INT 22
105798: PUSH
105799: LD_OWVAR 2
105803: PUSH
105804: EMPTY
105805: LIST
105806: LIST
105807: PUSH
105808: LD_INT 21
105810: PUSH
105811: LD_INT 1
105813: PUSH
105814: EMPTY
105815: LIST
105816: LIST
105817: PUSH
105818: EMPTY
105819: LIST
105820: LIST
105821: PPUSH
105822: CALL_OW 69
105826: PUSH
105827: FOR_IN
105828: IFFALSE 105869
// begin for j := 1 to 4 do
105830: LD_ADDR_VAR 0 3
105834: PUSH
105835: DOUBLE
105836: LD_INT 1
105838: DEC
105839: ST_TO_ADDR
105840: LD_INT 4
105842: PUSH
105843: FOR_TO
105844: IFFALSE 105865
// SetSkill ( i , j , 10 ) ;
105846: LD_VAR 0 2
105850: PPUSH
105851: LD_VAR 0 3
105855: PPUSH
105856: LD_INT 10
105858: PPUSH
105859: CALL_OW 237
105863: GO 105843
105865: POP
105866: POP
// end ;
105867: GO 105827
105869: POP
105870: POP
// end ;
105871: LD_VAR 0 1
105875: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105876: LD_INT 0
105878: PPUSH
// uc_side := your_side ;
105879: LD_ADDR_OWVAR 20
105883: PUSH
105884: LD_OWVAR 2
105888: ST_TO_ADDR
// uc_nation := nation ;
105889: LD_ADDR_OWVAR 21
105893: PUSH
105894: LD_VAR 0 1
105898: ST_TO_ADDR
// InitHc ;
105899: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105903: LD_INT 0
105905: PPUSH
105906: LD_VAR 0 2
105910: PPUSH
105911: LD_VAR 0 3
105915: PPUSH
105916: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105920: LD_VAR 0 4
105924: PPUSH
105925: LD_VAR 0 5
105929: PPUSH
105930: CALL_OW 428
105934: PUSH
105935: LD_INT 0
105937: EQUAL
105938: IFFALSE 105962
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105940: CALL_OW 44
105944: PPUSH
105945: LD_VAR 0 4
105949: PPUSH
105950: LD_VAR 0 5
105954: PPUSH
105955: LD_INT 1
105957: PPUSH
105958: CALL_OW 48
// end ;
105962: LD_VAR 0 6
105966: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105967: LD_INT 0
105969: PPUSH
105970: PPUSH
// uc_side := your_side ;
105971: LD_ADDR_OWVAR 20
105975: PUSH
105976: LD_OWVAR 2
105980: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105981: LD_VAR 0 1
105985: PUSH
105986: LD_INT 1
105988: PUSH
105989: LD_INT 2
105991: PUSH
105992: LD_INT 3
105994: PUSH
105995: LD_INT 4
105997: PUSH
105998: LD_INT 5
106000: PUSH
106001: EMPTY
106002: LIST
106003: LIST
106004: LIST
106005: LIST
106006: LIST
106007: IN
106008: IFFALSE 106020
// uc_nation := nation_american else
106010: LD_ADDR_OWVAR 21
106014: PUSH
106015: LD_INT 1
106017: ST_TO_ADDR
106018: GO 106063
// if chassis in [ 11 , 12 , 13 , 14 ] then
106020: LD_VAR 0 1
106024: PUSH
106025: LD_INT 11
106027: PUSH
106028: LD_INT 12
106030: PUSH
106031: LD_INT 13
106033: PUSH
106034: LD_INT 14
106036: PUSH
106037: EMPTY
106038: LIST
106039: LIST
106040: LIST
106041: LIST
106042: IN
106043: IFFALSE 106055
// uc_nation := nation_arabian else
106045: LD_ADDR_OWVAR 21
106049: PUSH
106050: LD_INT 2
106052: ST_TO_ADDR
106053: GO 106063
// uc_nation := nation_russian ;
106055: LD_ADDR_OWVAR 21
106059: PUSH
106060: LD_INT 3
106062: ST_TO_ADDR
// vc_chassis := chassis ;
106063: LD_ADDR_OWVAR 37
106067: PUSH
106068: LD_VAR 0 1
106072: ST_TO_ADDR
// vc_engine := engine ;
106073: LD_ADDR_OWVAR 39
106077: PUSH
106078: LD_VAR 0 2
106082: ST_TO_ADDR
// vc_control := control ;
106083: LD_ADDR_OWVAR 38
106087: PUSH
106088: LD_VAR 0 3
106092: ST_TO_ADDR
// vc_weapon := weapon ;
106093: LD_ADDR_OWVAR 40
106097: PUSH
106098: LD_VAR 0 4
106102: ST_TO_ADDR
// un := CreateVehicle ;
106103: LD_ADDR_VAR 0 8
106107: PUSH
106108: CALL_OW 45
106112: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106113: LD_VAR 0 8
106117: PPUSH
106118: LD_INT 0
106120: PPUSH
106121: LD_INT 5
106123: PPUSH
106124: CALL_OW 12
106128: PPUSH
106129: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106133: LD_VAR 0 8
106137: PPUSH
106138: LD_VAR 0 5
106142: PPUSH
106143: LD_VAR 0 6
106147: PPUSH
106148: LD_INT 1
106150: PPUSH
106151: CALL_OW 48
// end ;
106155: LD_VAR 0 7
106159: RET
// export hInvincible ; every 1 do
106160: GO 106162
106162: DISABLE
// hInvincible := [ ] ;
106163: LD_ADDR_EXP 155
106167: PUSH
106168: EMPTY
106169: ST_TO_ADDR
106170: END
// every 10 do var i ;
106171: GO 106173
106173: DISABLE
106174: LD_INT 0
106176: PPUSH
// begin enable ;
106177: ENABLE
// if not hInvincible then
106178: LD_EXP 155
106182: NOT
106183: IFFALSE 106187
// exit ;
106185: GO 106231
// for i in hInvincible do
106187: LD_ADDR_VAR 0 1
106191: PUSH
106192: LD_EXP 155
106196: PUSH
106197: FOR_IN
106198: IFFALSE 106229
// if GetLives ( i ) < 1000 then
106200: LD_VAR 0 1
106204: PPUSH
106205: CALL_OW 256
106209: PUSH
106210: LD_INT 1000
106212: LESS
106213: IFFALSE 106227
// SetLives ( i , 1000 ) ;
106215: LD_VAR 0 1
106219: PPUSH
106220: LD_INT 1000
106222: PPUSH
106223: CALL_OW 234
106227: GO 106197
106229: POP
106230: POP
// end ;
106231: PPOPN 1
106233: END
// export function hHackInvincible ; var i ; begin
106234: LD_INT 0
106236: PPUSH
106237: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106238: LD_ADDR_VAR 0 2
106242: PUSH
106243: LD_INT 2
106245: PUSH
106246: LD_INT 21
106248: PUSH
106249: LD_INT 1
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: PUSH
106256: LD_INT 21
106258: PUSH
106259: LD_INT 2
106261: PUSH
106262: EMPTY
106263: LIST
106264: LIST
106265: PUSH
106266: EMPTY
106267: LIST
106268: LIST
106269: LIST
106270: PPUSH
106271: CALL_OW 69
106275: PUSH
106276: FOR_IN
106277: IFFALSE 106338
// if IsSelected ( i ) then
106279: LD_VAR 0 2
106283: PPUSH
106284: CALL_OW 306
106288: IFFALSE 106336
// begin if i in hInvincible then
106290: LD_VAR 0 2
106294: PUSH
106295: LD_EXP 155
106299: IN
106300: IFFALSE 106320
// hInvincible := hInvincible diff i else
106302: LD_ADDR_EXP 155
106306: PUSH
106307: LD_EXP 155
106311: PUSH
106312: LD_VAR 0 2
106316: DIFF
106317: ST_TO_ADDR
106318: GO 106336
// hInvincible := hInvincible union i ;
106320: LD_ADDR_EXP 155
106324: PUSH
106325: LD_EXP 155
106329: PUSH
106330: LD_VAR 0 2
106334: UNION
106335: ST_TO_ADDR
// end ;
106336: GO 106276
106338: POP
106339: POP
// end ;
106340: LD_VAR 0 1
106344: RET
// export function hHackInvisible ; var i , j ; begin
106345: LD_INT 0
106347: PPUSH
106348: PPUSH
106349: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106350: LD_ADDR_VAR 0 2
106354: PUSH
106355: LD_INT 21
106357: PUSH
106358: LD_INT 1
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: PPUSH
106365: CALL_OW 69
106369: PUSH
106370: FOR_IN
106371: IFFALSE 106395
// if IsSelected ( i ) then
106373: LD_VAR 0 2
106377: PPUSH
106378: CALL_OW 306
106382: IFFALSE 106393
// ComForceInvisible ( i ) ;
106384: LD_VAR 0 2
106388: PPUSH
106389: CALL_OW 496
106393: GO 106370
106395: POP
106396: POP
// end ;
106397: LD_VAR 0 1
106401: RET
// export function hHackChangeYourSide ; begin
106402: LD_INT 0
106404: PPUSH
// if your_side = 8 then
106405: LD_OWVAR 2
106409: PUSH
106410: LD_INT 8
106412: EQUAL
106413: IFFALSE 106425
// your_side := 0 else
106415: LD_ADDR_OWVAR 2
106419: PUSH
106420: LD_INT 0
106422: ST_TO_ADDR
106423: GO 106439
// your_side := your_side + 1 ;
106425: LD_ADDR_OWVAR 2
106429: PUSH
106430: LD_OWVAR 2
106434: PUSH
106435: LD_INT 1
106437: PLUS
106438: ST_TO_ADDR
// end ;
106439: LD_VAR 0 1
106443: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106444: LD_INT 0
106446: PPUSH
106447: PPUSH
106448: PPUSH
// for i in all_units do
106449: LD_ADDR_VAR 0 2
106453: PUSH
106454: LD_OWVAR 3
106458: PUSH
106459: FOR_IN
106460: IFFALSE 106538
// if IsSelected ( i ) then
106462: LD_VAR 0 2
106466: PPUSH
106467: CALL_OW 306
106471: IFFALSE 106536
// begin j := GetSide ( i ) ;
106473: LD_ADDR_VAR 0 3
106477: PUSH
106478: LD_VAR 0 2
106482: PPUSH
106483: CALL_OW 255
106487: ST_TO_ADDR
// if j = 8 then
106488: LD_VAR 0 3
106492: PUSH
106493: LD_INT 8
106495: EQUAL
106496: IFFALSE 106508
// j := 0 else
106498: LD_ADDR_VAR 0 3
106502: PUSH
106503: LD_INT 0
106505: ST_TO_ADDR
106506: GO 106522
// j := j + 1 ;
106508: LD_ADDR_VAR 0 3
106512: PUSH
106513: LD_VAR 0 3
106517: PUSH
106518: LD_INT 1
106520: PLUS
106521: ST_TO_ADDR
// SetSide ( i , j ) ;
106522: LD_VAR 0 2
106526: PPUSH
106527: LD_VAR 0 3
106531: PPUSH
106532: CALL_OW 235
// end ;
106536: GO 106459
106538: POP
106539: POP
// end ;
106540: LD_VAR 0 1
106544: RET
// export function hHackFog ; begin
106545: LD_INT 0
106547: PPUSH
// FogOff ( true ) ;
106548: LD_INT 1
106550: PPUSH
106551: CALL_OW 344
// end ;
106555: LD_VAR 0 1
106559: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106560: LD_INT 0
106562: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106563: LD_VAR 0 1
106567: PPUSH
106568: LD_VAR 0 2
106572: PPUSH
106573: LD_VAR 0 3
106577: PPUSH
106578: LD_INT 1
106580: PPUSH
106581: LD_INT 1
106583: PPUSH
106584: CALL_OW 483
// CenterOnXY ( x , y ) ;
106588: LD_VAR 0 2
106592: PPUSH
106593: LD_VAR 0 3
106597: PPUSH
106598: CALL_OW 84
// end ; end_of_file
106602: LD_VAR 0 4
106606: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
106607: LD_VAR 0 1
106611: PPUSH
106612: LD_VAR 0 2
106616: PPUSH
106617: LD_VAR 0 3
106621: PPUSH
106622: LD_VAR 0 4
106626: PPUSH
106627: LD_VAR 0 5
106631: PPUSH
106632: LD_VAR 0 6
106636: PPUSH
106637: CALL 92822 0 6
// end ;
106641: PPOPN 6
106643: END
