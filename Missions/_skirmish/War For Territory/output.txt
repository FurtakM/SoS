// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 180 0 0
// if debug then
   8: LD_EXP 1
  12: IFFALSE 21
// begin FogOff ( 1 ) ;
  14: LD_INT 1
  16: PPUSH
  17: CALL_OW 344
// end ; ChangeSideFog ( 4 , 1 ) ;
  21: LD_INT 4
  23: PPUSH
  24: LD_INT 1
  26: PPUSH
  27: CALL_OW 343
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 3
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: LD_INT 0
  45: PPUSH
  46: LD_INT 0
  48: PPUSH
  49: LD_INT 0
  51: PPUSH
  52: LD_INT 7
  54: PPUSH
  55: LD_INT 0
  57: PPUSH
  58: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 3
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 4
  85: PPUSH
  86: LD_INT 0
  88: PPUSH
  89: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
  93: LD_INT 0
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 3
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 11
 116: PPUSH
 117: LD_INT 0
 119: PPUSH
 120: CALL 37429 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 3
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 14
 147: PPUSH
 148: LD_INT 0
 150: PPUSH
 151: CALL 37429 0 9
// PrepareGensher ;
 155: CALL 1331 0 0
// PreparePopov ;
 159: CALL 2581 0 0
// PreparePowell ;
 163: CALL 394 0 0
// PrepareSikorski ;
 167: CALL 3705 0 0
// MC_Start ( ) ;
 171: CALL 44302 0 0
// Action ;
 175: CALL 4112 0 0
// end ;
 179: END
// export debug , game , staticMines ; function InitVariables ; begin
 180: LD_INT 0
 182: PPUSH
// debug := false ;
 183: LD_ADDR_EXP 1
 187: PUSH
 188: LD_INT 0
 190: ST_TO_ADDR
// game := true ;
 191: LD_ADDR_EXP 2
 195: PUSH
 196: LD_INT 1
 198: ST_TO_ADDR
// staticMines := [ ] ;
 199: LD_ADDR_EXP 3
 203: PUSH
 204: EMPTY
 205: ST_TO_ADDR
// end ;
 206: LD_VAR 0 1
 210: RET
// export function CustomInitMacro ; begin
 211: LD_INT 0
 213: PPUSH
// InitMC_Gensher ( ) ;
 214: CALL 1719 0 0
// InitMC_Powell ( ) ;
 218: CALL 609 0 0
// InitMC_Popov ( ) ;
 222: CALL 2907 0 0
// end ;
 226: LD_VAR 0 1
 230: RET
// every 0 0$10 do var cr , time , i ;
 231: GO 233
 233: DISABLE
 234: LD_INT 0
 236: PPUSH
 237: PPUSH
 238: PPUSH
// begin time := 0 0$30 ;
 239: LD_ADDR_VAR 0 2
 243: PUSH
 244: LD_INT 1050
 246: ST_TO_ADDR
// repeat wait ( time ) ;
 247: LD_VAR 0 2
 251: PPUSH
 252: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 256: LD_ADDR_VAR 0 1
 260: PUSH
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 5
 266: PPUSH
 267: CALL_OW 12
 271: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 272: LD_ADDR_VAR 0 3
 276: PUSH
 277: LD_INT 5
 279: PUSH
 280: LD_INT 8
 282: PUSH
 283: LD_INT 12
 285: PUSH
 286: LD_INT 13
 288: PUSH
 289: EMPTY
 290: LIST
 291: LIST
 292: LIST
 293: LIST
 294: PUSH
 295: FOR_IN
 296: IFFALSE 350
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 298: LD_VAR 0 3
 302: PPUSH
 303: LD_INT 1
 305: PPUSH
 306: CALL_OW 287
 310: PUSH
 311: LD_INT 20
 313: LESS
 314: IFFALSE 333
// CreateCratesArea ( cr , i , true ) ;
 316: LD_VAR 0 1
 320: PPUSH
 321: LD_VAR 0 3
 325: PPUSH
 326: LD_INT 1
 328: PPUSH
 329: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 333: LD_INT 175
 335: PPUSH
 336: LD_INT 700
 338: PPUSH
 339: CALL_OW 12
 343: PPUSH
 344: CALL_OW 67
// end ;
 348: GO 295
 350: POP
 351: POP
// time := time + 0 0$2 ;
 352: LD_ADDR_VAR 0 2
 356: PUSH
 357: LD_VAR 0 2
 361: PUSH
 362: LD_INT 70
 364: PLUS
 365: ST_TO_ADDR
// if time > 1 1$00 then
 366: LD_VAR 0 2
 370: PUSH
 371: LD_INT 2100
 373: GREATER
 374: IFFALSE 384
// time := 0 0$25 ;
 376: LD_ADDR_VAR 0 2
 380: PUSH
 381: LD_INT 875
 383: ST_TO_ADDR
// until not game ;
 384: LD_EXP 2
 388: NOT
 389: IFFALSE 247
// end ; end_of_file
 391: PPOPN 3
 393: END
// export Powell , powell_side ; export function PreparePowell ; var i , tmp ; begin
 394: LD_INT 0
 396: PPUSH
 397: PPUSH
 398: PPUSH
// powell_side := 4 ;
 399: LD_ADDR_EXP 5
 403: PUSH
 404: LD_INT 4
 406: ST_TO_ADDR
// uc_side := powell_side ;
 407: LD_ADDR_OWVAR 20
 411: PUSH
 412: LD_EXP 5
 416: ST_TO_ADDR
// uc_nation := 1 ;
 417: LD_ADDR_OWVAR 21
 421: PUSH
 422: LD_INT 1
 424: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 425: LD_ADDR_EXP 4
 429: PUSH
 430: LD_STRING Powell
 432: PPUSH
 433: CALL_OW 25
 437: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 438: LD_EXP 4
 442: PPUSH
 443: LD_INT 1
 445: PPUSH
 446: LD_INT 7
 448: PPUSH
 449: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 453: LD_EXP 4
 457: PPUSH
 458: LD_INT 2
 460: PPUSH
 461: LD_INT 5
 463: PPUSH
 464: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 468: LD_EXP 4
 472: PPUSH
 473: LD_INT 3
 475: PPUSH
 476: LD_INT 6
 478: PPUSH
 479: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 483: LD_EXP 4
 487: PPUSH
 488: LD_INT 4
 490: PPUSH
 491: LD_INT 4
 493: PPUSH
 494: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 498: LD_EXP 4
 502: PPUSH
 503: LD_INT 4
 505: PPUSH
 506: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1000 , 100 , 0 ] , [ 4 , 4 , 4 , 4 ] ) ;
 510: LD_ADDR_VAR 0 3
 514: PUSH
 515: LD_INT 4
 517: PPUSH
 518: LD_INT 1
 520: PPUSH
 521: LD_STRING 
 523: PPUSH
 524: LD_INT 8
 526: PUSH
 527: LD_INT 7
 529: PUSH
 530: LD_INT 6
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: LIST
 537: PUSH
 538: LD_OWVAR 67
 542: ARRAY
 543: PPUSH
 544: LD_INT 1000
 546: PUSH
 547: LD_INT 100
 549: PUSH
 550: LD_INT 0
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: PPUSH
 558: LD_INT 4
 560: PUSH
 561: LD_INT 4
 563: PUSH
 564: LD_INT 4
 566: PUSH
 567: LD_INT 4
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PPUSH
 576: CALL 12746 0 6
 580: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 581: LD_ADDR_EXP 14
 585: PUSH
 586: LD_EXP 14
 590: PPUSH
 591: LD_INT 1
 593: PPUSH
 594: LD_VAR 0 3
 598: PPUSH
 599: CALL_OW 1
 603: ST_TO_ADDR
// end ;
 604: LD_VAR 0 1
 608: RET
// export function InitMC_Powell ( ) ; begin
 609: LD_INT 0
 611: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 612: LD_INT 1
 614: PPUSH
 615: LD_INT 1
 617: PPUSH
 618: CALL 67306 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 622: LD_INT 1
 624: PPUSH
 625: LD_INT 6
 627: PPUSH
 628: CALL 67250 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 632: LD_INT 1
 634: PPUSH
 635: LD_INT 167
 637: PUSH
 638: LD_INT 102
 640: PUSH
 641: LD_INT 0
 643: PUSH
 644: EMPTY
 645: LIST
 646: LIST
 647: LIST
 648: PUSH
 649: LD_INT 173
 651: PUSH
 652: LD_INT 83
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: EMPTY
 659: LIST
 660: LIST
 661: LIST
 662: PUSH
 663: LD_INT 171
 665: PUSH
 666: LD_INT 141
 668: PUSH
 669: LD_INT 0
 671: PUSH
 672: EMPTY
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: LD_INT 178
 679: PUSH
 680: LD_INT 148
 682: PUSH
 683: LD_INT 1
 685: PUSH
 686: EMPTY
 687: LIST
 688: LIST
 689: LIST
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 66309 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher , us_laser , us_double_laser ] ) ;
 701: LD_INT 1
 703: PPUSH
 704: LD_INT 11
 706: PUSH
 707: LD_INT 6
 709: PUSH
 710: LD_INT 7
 712: PUSH
 713: LD_INT 9
 715: PUSH
 716: LD_INT 10
 718: PUSH
 719: EMPTY
 720: LIST
 721: LIST
 722: LIST
 723: LIST
 724: LIST
 725: PPUSH
 726: CALL 67138 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 730: LD_INT 1
 732: PPUSH
 733: LD_INT 5
 735: PPUSH
 736: CALL 66820 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 740: LD_INT 1
 742: PPUSH
 743: LD_INT 4
 745: PPUSH
 746: CALL 66551 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 750: LD_INT 1
 752: PPUSH
 753: LD_INT 4
 755: PPUSH
 756: CALL 66170 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_morphling , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 760: LD_INT 1
 762: PPUSH
 763: LD_INT 3
 765: PUSH
 766: LD_INT 1
 768: PUSH
 769: LD_INT 2
 771: PUSH
 772: LD_INT 5
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 4
 783: PUSH
 784: LD_INT 1
 786: PUSH
 787: LD_INT 2
 789: PUSH
 790: LD_INT 6
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 4
 801: PUSH
 802: LD_INT 1
 804: PUSH
 805: LD_INT 2
 807: PUSH
 808: LD_INT 7
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 4
 819: PUSH
 820: LD_INT 1
 822: PUSH
 823: LD_INT 2
 825: PUSH
 826: LD_INT 6
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 5
 837: PUSH
 838: LD_INT 1
 840: PUSH
 841: LD_INT 2
 843: PUSH
 844: LD_INT 6
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: PPUSH
 860: CALL 65985 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 197 , 144 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] ] ) ;
 864: LD_INT 1
 866: PPUSH
 867: LD_INT 6
 869: PUSH
 870: LD_INT 200
 872: PUSH
 873: LD_INT 111
 875: PUSH
 876: LD_INT 4
 878: PUSH
 879: EMPTY
 880: LIST
 881: LIST
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 29
 887: PUSH
 888: LD_INT 167
 890: PUSH
 891: LD_INT 102
 893: PUSH
 894: LD_INT 0
 896: PUSH
 897: EMPTY
 898: LIST
 899: LIST
 900: LIST
 901: LIST
 902: PUSH
 903: LD_INT 4
 905: PUSH
 906: LD_INT 178
 908: PUSH
 909: LD_INT 117
 911: PUSH
 912: LD_INT 2
 914: PUSH
 915: EMPTY
 916: LIST
 917: LIST
 918: LIST
 919: LIST
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 197
 926: PUSH
 927: LD_INT 144
 929: PUSH
 930: LD_INT 4
 932: PUSH
 933: EMPTY
 934: LIST
 935: LIST
 936: LIST
 937: LIST
 938: PUSH
 939: LD_INT 27
 941: PUSH
 942: LD_INT 206
 944: PUSH
 945: LD_INT 124
 947: PUSH
 948: LD_INT 3
 950: PUSH
 951: EMPTY
 952: LIST
 953: LIST
 954: LIST
 955: LIST
 956: PUSH
 957: LD_INT 27
 959: PUSH
 960: LD_INT 209
 962: PUSH
 963: LD_INT 128
 965: PUSH
 966: LD_INT 3
 968: PUSH
 969: EMPTY
 970: LIST
 971: LIST
 972: LIST
 973: LIST
 974: PUSH
 975: LD_INT 27
 977: PUSH
 978: LD_INT 211
 980: PUSH
 981: LD_INT 132
 983: PUSH
 984: LD_INT 3
 986: PUSH
 987: EMPTY
 988: LIST
 989: LIST
 990: LIST
 991: LIST
 992: PUSH
 993: LD_INT 30
 995: PUSH
 996: LD_INT 173
 998: PUSH
 999: LD_INT 83
1001: PUSH
1002: LD_INT 3
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: LIST
1009: LIST
1010: PUSH
1011: LD_INT 6
1013: PUSH
1014: LD_INT 186
1016: PUSH
1017: LD_INT 103
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: EMPTY
1024: LIST
1025: LIST
1026: LIST
1027: LIST
1028: PUSH
1029: LD_INT 33
1031: PUSH
1032: LD_INT 173
1034: PUSH
1035: LD_INT 99
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: EMPTY
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: PUSH
1047: LD_INT 32
1049: PUSH
1050: LD_INT 174
1052: PUSH
1053: LD_INT 102
1055: PUSH
1056: LD_INT 2
1058: PUSH
1059: EMPTY
1060: LIST
1061: LIST
1062: LIST
1063: LIST
1064: PUSH
1065: LD_INT 32
1067: PUSH
1068: LD_INT 178
1070: PUSH
1071: LD_INT 100
1073: PUSH
1074: LD_INT 2
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: LD_INT 33
1085: PUSH
1086: LD_INT 174
1088: PUSH
1089: LD_INT 108
1091: PUSH
1092: LD_INT 1
1094: PUSH
1095: EMPTY
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: PUSH
1101: LD_INT 33
1103: PUSH
1104: LD_INT 182
1106: PUSH
1107: LD_INT 122
1109: PUSH
1110: LD_INT 1
1112: PUSH
1113: EMPTY
1114: LIST
1115: LIST
1116: LIST
1117: LIST
1118: PUSH
1119: LD_INT 36
1121: PUSH
1122: LD_INT 194
1124: PUSH
1125: LD_INT 124
1127: PUSH
1128: LD_INT 5
1130: PUSH
1131: EMPTY
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: PUSH
1137: LD_INT 28
1139: PUSH
1140: LD_INT 204
1142: PUSH
1143: LD_INT 133
1145: PUSH
1146: LD_INT 3
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 27
1157: PUSH
1158: LD_INT 201
1160: PUSH
1161: LD_INT 133
1163: PUSH
1164: LD_INT 3
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 28
1175: PUSH
1176: LD_INT 199
1178: PUSH
1179: LD_INT 119
1181: PUSH
1182: LD_INT 5
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: LD_INT 33
1193: PUSH
1194: LD_INT 184
1196: PUSH
1197: LD_INT 141
1199: PUSH
1200: LD_INT 1
1202: PUSH
1203: EMPTY
1204: LIST
1205: LIST
1206: LIST
1207: LIST
1208: PUSH
1209: LD_INT 33
1211: PUSH
1212: LD_INT 183
1214: PUSH
1215: LD_INT 131
1217: PUSH
1218: LD_INT 2
1220: PUSH
1221: EMPTY
1222: LIST
1223: LIST
1224: LIST
1225: LIST
1226: PUSH
1227: EMPTY
1228: LIST
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: LIST
1241: LIST
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: LIST
1247: LIST
1248: PPUSH
1249: CALL 65877 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1253: LD_INT 1
1255: PPUSH
1256: LD_INT 10
1258: PUSH
1259: LD_INT 15
1261: PUSH
1262: LD_INT 12
1264: PUSH
1265: LD_INT 11
1267: PUSH
1268: EMPTY
1269: LIST
1270: LIST
1271: LIST
1272: LIST
1273: PPUSH
1274: CALL 66727 0 2
// MC_SetFactoryExtension ( 1 , 197 , 144 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1278: LD_INT 1
1280: PPUSH
1281: LD_INT 197
1283: PPUSH
1284: LD_INT 144
1286: PPUSH
1287: LD_INT 4
1289: PPUSH
1290: LD_INT 19
1292: PUSH
1293: LD_INT 16
1295: PUSH
1296: LD_INT 17
1298: PUSH
1299: LD_INT 18
1301: PUSH
1302: LD_INT 22
1304: PUSH
1305: EMPTY
1306: LIST
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PPUSH
1312: CALL 66932 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1316: LD_INT 1
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL 66600 0 2
// end ; end_of_file
1326: LD_VAR 0 1
1330: RET
// export Gensher , gensher_side ; export function PrepareGensher ; var i , tmp , un ; begin
1331: LD_INT 0
1333: PPUSH
1334: PPUSH
1335: PPUSH
1336: PPUSH
// gensher_side := 2 ;
1337: LD_ADDR_EXP 7
1341: PUSH
1342: LD_INT 2
1344: ST_TO_ADDR
// uc_side := gensher_side ;
1345: LD_ADDR_OWVAR 20
1349: PUSH
1350: LD_EXP 7
1354: ST_TO_ADDR
// uc_nation := 2 ;
1355: LD_ADDR_OWVAR 21
1359: PUSH
1360: LD_INT 2
1362: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
1363: LD_ADDR_VAR 0 3
1367: PUSH
1368: LD_INT 7
1370: PPUSH
1371: LD_INT 2
1373: PPUSH
1374: LD_STRING 
1376: PPUSH
1377: LD_INT 8
1379: PUSH
1380: LD_INT 7
1382: PUSH
1383: LD_INT 6
1385: PUSH
1386: EMPTY
1387: LIST
1388: LIST
1389: LIST
1390: PUSH
1391: LD_OWVAR 67
1395: ARRAY
1396: PPUSH
1397: LD_INT 1500
1399: PUSH
1400: LD_INT 300
1402: PUSH
1403: LD_INT 30
1405: PUSH
1406: EMPTY
1407: LIST
1408: LIST
1409: LIST
1410: PPUSH
1411: LD_INT 4
1413: PUSH
1414: LD_INT 4
1416: PUSH
1417: LD_INT 4
1419: PUSH
1420: LD_INT 4
1422: PUSH
1423: EMPTY
1424: LIST
1425: LIST
1426: LIST
1427: LIST
1428: PPUSH
1429: CALL 12746 0 6
1433: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
1434: LD_ADDR_EXP 14
1438: PUSH
1439: LD_EXP 14
1443: PPUSH
1444: LD_INT 2
1446: PPUSH
1447: LD_VAR 0 3
1451: PPUSH
1452: CALL_OW 1
1456: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
1457: LD_ADDR_VAR 0 3
1461: PUSH
1462: LD_INT 22
1464: PUSH
1465: LD_INT 2
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: PUSH
1472: LD_INT 30
1474: PUSH
1475: LD_INT 31
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: PPUSH
1486: CALL_OW 69
1490: ST_TO_ADDR
// for i in tmp do
1491: LD_ADDR_VAR 0 2
1495: PUSH
1496: LD_VAR 0 3
1500: PUSH
1501: FOR_IN
1502: IFFALSE 1572
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
1504: LD_INT 0
1506: PPUSH
1507: LD_INT 1
1509: PPUSH
1510: LD_INT 4
1512: PUSH
1513: LD_INT 3
1515: PUSH
1516: LD_INT 3
1518: PUSH
1519: EMPTY
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: LD_OWVAR 67
1528: ARRAY
1529: PPUSH
1530: CALL_OW 380
// un := CreateHuman ;
1534: LD_ADDR_VAR 0 4
1538: PUSH
1539: CALL_OW 44
1543: ST_TO_ADDR
// SetDir ( un , 1 ) ;
1544: LD_VAR 0 4
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
1556: LD_VAR 0 4
1560: PPUSH
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 52
// end ;
1570: GO 1501
1572: POP
1573: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
1574: LD_ADDR_VAR 0 3
1578: PUSH
1579: LD_INT 15
1581: PPUSH
1582: LD_INT 0
1584: PPUSH
1585: CALL_OW 517
1589: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: DOUBLE
1596: LD_INT 1
1598: DEC
1599: ST_TO_ADDR
1600: LD_VAR 0 3
1604: PUSH
1605: LD_INT 1
1607: ARRAY
1608: PUSH
1609: FOR_TO
1610: IFFALSE 1712
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
1612: LD_VAR 0 3
1616: PUSH
1617: LD_INT 1
1619: ARRAY
1620: PUSH
1621: LD_VAR 0 2
1625: ARRAY
1626: PPUSH
1627: LD_VAR 0 3
1631: PUSH
1632: LD_INT 2
1634: ARRAY
1635: PUSH
1636: LD_VAR 0 2
1640: ARRAY
1641: PPUSH
1642: LD_INT 2
1644: PPUSH
1645: LD_INT 0
1647: PPUSH
1648: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
1652: LD_ADDR_EXP 3
1656: PUSH
1657: LD_EXP 3
1661: PPUSH
1662: LD_EXP 3
1666: PUSH
1667: LD_INT 1
1669: PLUS
1670: PPUSH
1671: LD_VAR 0 3
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_VAR 0 2
1684: ARRAY
1685: PUSH
1686: LD_VAR 0 3
1690: PUSH
1691: LD_INT 2
1693: ARRAY
1694: PUSH
1695: LD_VAR 0 2
1699: ARRAY
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: PPUSH
1705: CALL_OW 2
1709: ST_TO_ADDR
// end ;
1710: GO 1609
1712: POP
1713: POP
// end ;
1714: LD_VAR 0 1
1718: RET
// export function InitMC_Gensher ( ) ; begin
1719: LD_INT 0
1721: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
1722: LD_INT 2
1724: PPUSH
1725: LD_INT 2
1727: PPUSH
1728: CALL 67306 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
1732: LD_INT 2
1734: PPUSH
1735: LD_INT 9
1737: PPUSH
1738: CALL 67250 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
1742: LD_INT 2
1744: PPUSH
1745: LD_INT 56
1747: PUSH
1748: LD_INT 23
1750: PUSH
1751: LD_INT 0
1753: PUSH
1754: EMPTY
1755: LIST
1756: LIST
1757: LIST
1758: PUSH
1759: LD_INT 52
1761: PUSH
1762: LD_INT 40
1764: PUSH
1765: LD_INT 1
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: LIST
1772: PUSH
1773: EMPTY
1774: LIST
1775: LIST
1776: PPUSH
1777: CALL 66309 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
1781: LD_INT 2
1783: PPUSH
1784: LD_INT 27
1786: PUSH
1787: LD_INT 28
1789: PUSH
1790: EMPTY
1791: LIST
1792: LIST
1793: PPUSH
1794: CALL 67138 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
1798: LD_INT 2
1800: PPUSH
1801: LD_INT 8
1803: PPUSH
1804: CALL 66820 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
1808: LD_INT 2
1810: PPUSH
1811: LD_INT 7
1813: PPUSH
1814: CALL 66551 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
1818: LD_INT 2
1820: PPUSH
1821: LD_INT 4
1823: PPUSH
1824: CALL 66170 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_flame_thrower ] ] ) ;
1828: LD_INT 2
1830: PPUSH
1831: LD_INT 13
1833: PUSH
1834: LD_INT 2
1836: PUSH
1837: LD_INT 1
1839: PUSH
1840: LD_INT 31
1842: PUSH
1843: EMPTY
1844: LIST
1845: LIST
1846: LIST
1847: LIST
1848: PUSH
1849: LD_INT 13
1851: PUSH
1852: LD_INT 2
1854: PUSH
1855: LD_INT 1
1857: PUSH
1858: LD_INT 31
1860: PUSH
1861: EMPTY
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: PUSH
1867: LD_INT 14
1869: PUSH
1870: LD_INT 1
1872: PUSH
1873: LD_INT 2
1875: PUSH
1876: LD_INT 27
1878: PUSH
1879: EMPTY
1880: LIST
1881: LIST
1882: LIST
1883: LIST
1884: PUSH
1885: LD_INT 14
1887: PUSH
1888: LD_INT 1
1890: PUSH
1891: LD_INT 2
1893: PUSH
1894: LD_INT 27
1896: PUSH
1897: EMPTY
1898: LIST
1899: LIST
1900: LIST
1901: LIST
1902: PUSH
1903: LD_INT 14
1905: PUSH
1906: LD_INT 1
1908: PUSH
1909: LD_INT 2
1911: PUSH
1912: LD_INT 28
1914: PUSH
1915: EMPTY
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: PUSH
1921: LD_INT 14
1923: PUSH
1924: LD_INT 1
1926: PUSH
1927: LD_INT 1
1929: PUSH
1930: LD_INT 26
1932: PUSH
1933: EMPTY
1934: LIST
1935: LIST
1936: LIST
1937: LIST
1938: PUSH
1939: EMPTY
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: PPUSH
1947: CALL 65985 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_lab , 17 , 27 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
1951: LD_INT 2
1953: PPUSH
1954: LD_INT 6
1956: PUSH
1957: LD_INT 13
1959: PUSH
1960: LD_INT 18
1962: PUSH
1963: LD_INT 1
1965: PUSH
1966: EMPTY
1967: LIST
1968: LIST
1969: LIST
1970: LIST
1971: PUSH
1972: LD_INT 6
1974: PUSH
1975: LD_INT 17
1977: PUSH
1978: LD_INT 27
1980: PUSH
1981: LD_INT 1
1983: PUSH
1984: EMPTY
1985: LIST
1986: LIST
1987: LIST
1988: LIST
1989: PUSH
1990: LD_INT 27
1992: PUSH
1993: LD_INT 17
1995: PUSH
1996: LD_INT 3
1998: PUSH
1999: LD_INT 0
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: PUSH
2008: LD_INT 29
2010: PUSH
2011: LD_INT 56
2013: PUSH
2014: LD_INT 23
2016: PUSH
2017: LD_INT 0
2019: PUSH
2020: EMPTY
2021: LIST
2022: LIST
2023: LIST
2024: LIST
2025: PUSH
2026: LD_INT 4
2028: PUSH
2029: LD_INT 42
2031: PUSH
2032: LD_INT 29
2034: PUSH
2035: LD_INT 5
2037: PUSH
2038: EMPTY
2039: LIST
2040: LIST
2041: LIST
2042: LIST
2043: PUSH
2044: LD_INT 2
2046: PUSH
2047: LD_INT 11
2049: PUSH
2050: LD_INT 7
2052: PUSH
2053: LD_INT 2
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: PUSH
2062: LD_INT 27
2064: PUSH
2065: LD_INT 20
2067: PUSH
2068: LD_INT 3
2070: PUSH
2071: LD_INT 0
2073: PUSH
2074: EMPTY
2075: LIST
2076: LIST
2077: LIST
2078: LIST
2079: PUSH
2080: LD_INT 27
2082: PUSH
2083: LD_INT 23
2085: PUSH
2086: LD_INT 3
2088: PUSH
2089: LD_INT 0
2091: PUSH
2092: EMPTY
2093: LIST
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_INT 27
2100: PUSH
2101: LD_INT 26
2103: PUSH
2104: LD_INT 3
2106: PUSH
2107: LD_INT 0
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: PUSH
2116: LD_INT 32
2118: PUSH
2119: LD_INT 27
2121: PUSH
2122: LD_INT 44
2124: PUSH
2125: LD_INT 5
2127: PUSH
2128: EMPTY
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: PUSH
2134: LD_INT 32
2136: PUSH
2137: LD_INT 41
2139: PUSH
2140: LD_INT 41
2142: PUSH
2143: LD_INT 5
2145: PUSH
2146: EMPTY
2147: LIST
2148: LIST
2149: LIST
2150: LIST
2151: PUSH
2152: LD_INT 32
2154: PUSH
2155: LD_INT 45
2157: PUSH
2158: LD_INT 24
2160: PUSH
2161: LD_INT 5
2163: PUSH
2164: EMPTY
2165: LIST
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_INT 32
2172: PUSH
2173: LD_INT 48
2175: PUSH
2176: LD_INT 19
2178: PUSH
2179: LD_INT 5
2181: PUSH
2182: EMPTY
2183: LIST
2184: LIST
2185: LIST
2186: LIST
2187: PUSH
2188: LD_INT 32
2190: PUSH
2191: LD_INT 41
2193: PUSH
2194: LD_INT 3
2196: PUSH
2197: LD_INT 4
2199: PUSH
2200: EMPTY
2201: LIST
2202: LIST
2203: LIST
2204: LIST
2205: PUSH
2206: LD_INT 4
2208: PUSH
2209: LD_INT 44
2211: PUSH
2212: LD_INT 9
2214: PUSH
2215: LD_INT 4
2217: PUSH
2218: EMPTY
2219: LIST
2220: LIST
2221: LIST
2222: LIST
2223: PUSH
2224: LD_INT 30
2226: PUSH
2227: LD_INT 52
2229: PUSH
2230: LD_INT 40
2232: PUSH
2233: LD_INT 3
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: LIST
2240: LIST
2241: PUSH
2242: EMPTY
2243: LIST
2244: LIST
2245: LIST
2246: LIST
2247: LIST
2248: LIST
2249: LIST
2250: LIST
2251: LIST
2252: LIST
2253: LIST
2254: LIST
2255: LIST
2256: LIST
2257: LIST
2258: LIST
2259: PPUSH
2260: CALL 65877 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
2264: LD_INT 2
2266: PPUSH
2267: LD_INT 10
2269: PUSH
2270: LD_INT 15
2272: PUSH
2273: LD_INT 13
2275: PUSH
2276: LD_INT 11
2278: PUSH
2279: EMPTY
2280: LIST
2281: LIST
2282: LIST
2283: LIST
2284: PPUSH
2285: CALL 66727 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
2289: LD_INT 2
2291: PPUSH
2292: LD_INT 11
2294: PPUSH
2295: LD_INT 7
2297: PPUSH
2298: LD_INT 2
2300: PPUSH
2301: LD_INT 23
2303: PUSH
2304: LD_INT 16
2306: PUSH
2307: LD_INT 17
2309: PUSH
2310: LD_INT 18
2312: PUSH
2313: LD_INT 22
2315: PUSH
2316: EMPTY
2317: LIST
2318: LIST
2319: LIST
2320: LIST
2321: LIST
2322: PPUSH
2323: CALL 66932 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
2327: LD_INT 2
2329: PPUSH
2330: LD_INT 0
2332: PPUSH
2333: CALL 66600 0 2
// end ;
2337: LD_VAR 0 1
2341: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
2342: LD_EXP 3
2346: PUSH
2347: LD_INT 15
2349: PPUSH
2350: LD_INT 81
2352: PUSH
2353: LD_INT 2
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: PPUSH
2360: CALL_OW 70
2364: AND
2365: IFFALSE 2578
2367: GO 2369
2369: DISABLE
2370: LD_INT 0
2372: PPUSH
2373: PPUSH
2374: PPUSH
2375: PPUSH
2376: PPUSH
// begin enable ;
2377: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
2378: LD_ADDR_VAR 0 3
2382: PUSH
2383: LD_INT 15
2385: PPUSH
2386: LD_INT 81
2388: PUSH
2389: LD_INT 2
2391: PUSH
2392: EMPTY
2393: LIST
2394: LIST
2395: PPUSH
2396: CALL_OW 70
2400: ST_TO_ADDR
// if not tmp then
2401: LD_VAR 0 3
2405: NOT
2406: IFFALSE 2410
// exit ;
2408: GO 2578
// for i in tmp do
2410: LD_ADDR_VAR 0 1
2414: PUSH
2415: LD_VAR 0 3
2419: PUSH
2420: FOR_IN
2421: IFFALSE 2576
// begin x := GetX ( i ) ;
2423: LD_ADDR_VAR 0 4
2427: PUSH
2428: LD_VAR 0 1
2432: PPUSH
2433: CALL_OW 250
2437: ST_TO_ADDR
// y := GetY ( i ) ;
2438: LD_ADDR_VAR 0 5
2442: PUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 251
2452: ST_TO_ADDR
// if MineAtPos ( x , y ) then
2453: LD_VAR 0 4
2457: PPUSH
2458: LD_VAR 0 5
2462: PPUSH
2463: CALL_OW 458
2467: IFFALSE 2574
// begin LaunchMineAtPos ( x , y , 2 ) ;
2469: LD_VAR 0 4
2473: PPUSH
2474: LD_VAR 0 5
2478: PPUSH
2479: LD_INT 2
2481: PPUSH
2482: CALL_OW 456
// for j = 1 to staticMines do
2486: LD_ADDR_VAR 0 2
2490: PUSH
2491: DOUBLE
2492: LD_INT 1
2494: DEC
2495: ST_TO_ADDR
2496: LD_EXP 3
2500: PUSH
2501: FOR_TO
2502: IFFALSE 2572
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
2504: LD_EXP 3
2508: PUSH
2509: LD_VAR 0 2
2513: ARRAY
2514: PUSH
2515: LD_INT 1
2517: ARRAY
2518: PUSH
2519: LD_VAR 0 4
2523: EQUAL
2524: PUSH
2525: LD_EXP 3
2529: PUSH
2530: LD_VAR 0 2
2534: ARRAY
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: PUSH
2540: LD_VAR 0 5
2544: EQUAL
2545: AND
2546: IFFALSE 2570
// begin staticMines := Delete ( staticMines , j ) ;
2548: LD_ADDR_EXP 3
2552: PUSH
2553: LD_EXP 3
2557: PPUSH
2558: LD_VAR 0 2
2562: PPUSH
2563: CALL_OW 3
2567: ST_TO_ADDR
// break ;
2568: GO 2572
// end ;
2570: GO 2501
2572: POP
2573: POP
// end ; end ;
2574: GO 2420
2576: POP
2577: POP
// end ; end_of_file
2578: PPOPN 5
2580: END
// export Popov , popov_side , extraPopovForces ; export function PreparePopov ; var i , un , tmp ; begin
2581: LD_INT 0
2583: PPUSH
2584: PPUSH
2585: PPUSH
2586: PPUSH
// popov_side := 3 ;
2587: LD_ADDR_EXP 9
2591: PUSH
2592: LD_INT 3
2594: ST_TO_ADDR
// uc_side := popov_side ;
2595: LD_ADDR_OWVAR 20
2599: PUSH
2600: LD_EXP 9
2604: ST_TO_ADDR
// uc_nation := 3 ;
2605: LD_ADDR_OWVAR 21
2609: PUSH
2610: LD_INT 3
2612: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 1500 , 300 , 30 ] , [ 4 , 4 , 4 , 4 ] ) ;
2613: LD_ADDR_VAR 0 4
2617: PUSH
2618: LD_INT 9
2620: PPUSH
2621: LD_INT 3
2623: PPUSH
2624: LD_STRING 
2626: PPUSH
2627: LD_INT 8
2629: PUSH
2630: LD_INT 7
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: PUSH
2641: LD_OWVAR 67
2645: ARRAY
2646: PPUSH
2647: LD_INT 1500
2649: PUSH
2650: LD_INT 300
2652: PUSH
2653: LD_INT 30
2655: PUSH
2656: EMPTY
2657: LIST
2658: LIST
2659: LIST
2660: PPUSH
2661: LD_INT 4
2663: PUSH
2664: LD_INT 4
2666: PUSH
2667: LD_INT 4
2669: PUSH
2670: LD_INT 4
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: LIST
2677: LIST
2678: PPUSH
2679: CALL 12746 0 6
2683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
2684: LD_ADDR_EXP 14
2688: PUSH
2689: LD_EXP 14
2693: PPUSH
2694: LD_INT 3
2696: PPUSH
2697: LD_VAR 0 4
2701: PPUSH
2702: CALL_OW 1
2706: ST_TO_ADDR
// extraPopovForces := [ ] ;
2707: LD_ADDR_EXP 10
2711: PUSH
2712: EMPTY
2713: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
2714: LD_ADDR_VAR 0 2
2718: PUSH
2719: DOUBLE
2720: LD_INT 1
2722: DEC
2723: ST_TO_ADDR
2724: LD_INT 4
2726: PUSH
2727: LD_INT 5
2729: PUSH
2730: LD_INT 6
2732: PUSH
2733: EMPTY
2734: LIST
2735: LIST
2736: LIST
2737: PUSH
2738: LD_OWVAR 67
2742: ARRAY
2743: PUSH
2744: FOR_TO
2745: IFFALSE 2848
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
2747: LD_INT 0
2749: PPUSH
2750: LD_INT 1
2752: PPUSH
2753: LD_INT 4
2755: PUSH
2756: LD_INT 5
2758: PUSH
2759: LD_INT 6
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: PUSH
2767: LD_OWVAR 67
2771: ARRAY
2772: PPUSH
2773: CALL_OW 380
// un := CreateHuman ;
2777: LD_ADDR_VAR 0 3
2781: PUSH
2782: CALL_OW 44
2786: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
2787: LD_VAR 0 3
2791: PPUSH
2792: LD_INT 131
2794: PPUSH
2795: LD_INT 110
2797: PPUSH
2798: LD_INT 8
2800: PPUSH
2801: LD_INT 0
2803: PPUSH
2804: CALL_OW 50
// ComHold ( un ) ;
2808: LD_VAR 0 3
2812: PPUSH
2813: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
2817: LD_ADDR_EXP 10
2821: PUSH
2822: LD_EXP 10
2826: PPUSH
2827: LD_EXP 10
2831: PUSH
2832: LD_INT 1
2834: PLUS
2835: PPUSH
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 1
2845: ST_TO_ADDR
// end ;
2846: GO 2744
2848: POP
2849: POP
// PrepareSoldier ( false , 6 ) ;
2850: LD_INT 0
2852: PPUSH
2853: LD_INT 6
2855: PPUSH
2856: CALL_OW 381
// un := CreateHuman ;
2860: LD_ADDR_VAR 0 3
2864: PUSH
2865: CALL_OW 44
2869: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2870: LD_VAR 0 3
2874: PPUSH
2875: LD_INT 1
2877: PPUSH
2878: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
2882: LD_VAR 0 3
2886: PPUSH
2887: LD_INT 150
2889: PPUSH
2890: LD_INT 158
2892: PPUSH
2893: CALL_OW 428
2897: PPUSH
2898: CALL_OW 52
// end ;
2902: LD_VAR 0 1
2906: RET
// export function InitMC_Popov ( ) ; begin
2907: LD_INT 0
2909: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
2910: LD_INT 3
2912: PPUSH
2913: LD_INT 3
2915: PPUSH
2916: CALL 67306 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
2920: LD_INT 3
2922: PPUSH
2923: LD_INT 10
2925: PPUSH
2926: CALL 67250 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 106 , 113 , 0 ] ] ) ;
2930: LD_INT 3
2932: PPUSH
2933: LD_INT 86
2935: PUSH
2936: LD_INT 118
2938: PUSH
2939: LD_INT 0
2941: PUSH
2942: EMPTY
2943: LIST
2944: LIST
2945: LIST
2946: PUSH
2947: LD_INT 123
2949: PUSH
2950: LD_INT 151
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: EMPTY
2957: LIST
2958: LIST
2959: LIST
2960: PUSH
2961: LD_INT 106
2963: PUSH
2964: LD_INT 113
2966: PUSH
2967: LD_INT 0
2969: PUSH
2970: EMPTY
2971: LIST
2972: LIST
2973: LIST
2974: PUSH
2975: EMPTY
2976: LIST
2977: LIST
2978: LIST
2979: PPUSH
2980: CALL 66309 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ) ;
2984: LD_INT 3
2986: PPUSH
2987: LD_INT 46
2989: PUSH
2990: LD_INT 45
2992: PUSH
2993: LD_INT 47
2995: PUSH
2996: LD_INT 49
2998: PUSH
2999: EMPTY
3000: LIST
3001: LIST
3002: LIST
3003: LIST
3004: PPUSH
3005: CALL 67138 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
3009: LD_INT 3
3011: PPUSH
3012: LD_INT 12
3014: PPUSH
3015: CALL 66820 0 2
// MC_SetTame ( 3 , popov_ape ) ;
3019: LD_INT 3
3021: PPUSH
3022: LD_INT 11
3024: PPUSH
3025: CALL 66551 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
3029: LD_INT 3
3031: PPUSH
3032: LD_INT 4
3034: PPUSH
3035: CALL 66170 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_manual , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gatling_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
3039: LD_INT 3
3041: PPUSH
3042: LD_INT 23
3044: PUSH
3045: LD_INT 1
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 44
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: PUSH
3060: LD_INT 23
3062: PUSH
3063: LD_INT 1
3065: PUSH
3066: LD_INT 3
3068: PUSH
3069: LD_INT 45
3071: PUSH
3072: EMPTY
3073: LIST
3074: LIST
3075: LIST
3076: LIST
3077: PUSH
3078: LD_INT 21
3080: PUSH
3081: LD_INT 1
3083: PUSH
3084: LD_INT 3
3086: PUSH
3087: LD_INT 43
3089: PUSH
3090: EMPTY
3091: LIST
3092: LIST
3093: LIST
3094: LIST
3095: PUSH
3096: LD_INT 21
3098: PUSH
3099: LD_INT 1
3101: PUSH
3102: LD_INT 3
3104: PUSH
3105: LD_INT 45
3107: PUSH
3108: EMPTY
3109: LIST
3110: LIST
3111: LIST
3112: LIST
3113: PUSH
3114: EMPTY
3115: LIST
3116: LIST
3117: LIST
3118: LIST
3119: PPUSH
3120: CALL 65985 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 106 , 113 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] , [ b_teleport , 91 , 147 , 3 ] ] ) ;
3124: LD_INT 3
3126: PPUSH
3127: LD_INT 6
3129: PUSH
3130: LD_INT 76
3132: PUSH
3133: LD_INT 145
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: EMPTY
3140: LIST
3141: LIST
3142: LIST
3143: LIST
3144: PUSH
3145: LD_INT 26
3147: PUSH
3148: LD_INT 87
3150: PUSH
3151: LD_INT 144
3153: PUSH
3154: LD_INT 0
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: PUSH
3163: LD_INT 29
3165: PUSH
3166: LD_INT 86
3168: PUSH
3169: LD_INT 118
3171: PUSH
3172: LD_INT 0
3174: PUSH
3175: EMPTY
3176: LIST
3177: LIST
3178: LIST
3179: LIST
3180: PUSH
3181: LD_INT 29
3183: PUSH
3184: LD_INT 106
3186: PUSH
3187: LD_INT 113
3189: PUSH
3190: LD_INT 0
3192: PUSH
3193: EMPTY
3194: LIST
3195: LIST
3196: LIST
3197: LIST
3198: PUSH
3199: LD_INT 26
3201: PUSH
3202: LD_INT 87
3204: PUSH
3205: LD_INT 147
3207: PUSH
3208: LD_INT 1
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: LIST
3215: LIST
3216: PUSH
3217: LD_INT 2
3219: PUSH
3220: LD_INT 94
3222: PUSH
3223: LD_INT 161
3225: PUSH
3226: LD_INT 0
3228: PUSH
3229: EMPTY
3230: LIST
3231: LIST
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 6
3237: PUSH
3238: LD_INT 81
3240: PUSH
3241: LD_INT 155
3243: PUSH
3244: LD_INT 1
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: LIST
3251: LIST
3252: PUSH
3253: LD_INT 4
3255: PUSH
3256: LD_INT 103
3258: PUSH
3259: LD_INT 147
3261: PUSH
3262: LD_INT 3
3264: PUSH
3265: EMPTY
3266: LIST
3267: LIST
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 26
3273: PUSH
3274: LD_INT 96
3276: PUSH
3277: LD_INT 152
3279: PUSH
3280: LD_INT 0
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: PUSH
3289: LD_INT 26
3291: PUSH
3292: LD_INT 96
3294: PUSH
3295: LD_INT 149
3297: PUSH
3298: LD_INT 3
3300: PUSH
3301: EMPTY
3302: LIST
3303: LIST
3304: LIST
3305: LIST
3306: PUSH
3307: LD_INT 32
3309: PUSH
3310: LD_INT 109
3312: PUSH
3313: LD_INT 142
3315: PUSH
3316: LD_INT 3
3318: PUSH
3319: EMPTY
3320: LIST
3321: LIST
3322: LIST
3323: LIST
3324: PUSH
3325: LD_INT 32
3327: PUSH
3328: LD_INT 112
3330: PUSH
3331: LD_INT 148
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 33
3345: PUSH
3346: LD_INT 120
3348: PUSH
3349: LD_INT 159
3351: PUSH
3352: LD_INT 4
3354: PUSH
3355: EMPTY
3356: LIST
3357: LIST
3358: LIST
3359: LIST
3360: PUSH
3361: LD_INT 33
3363: PUSH
3364: LD_INT 122
3366: PUSH
3367: LD_INT 163
3369: PUSH
3370: LD_INT 4
3372: PUSH
3373: EMPTY
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: PUSH
3379: LD_INT 33
3381: PUSH
3382: LD_INT 123
3384: PUSH
3385: LD_INT 167
3387: PUSH
3388: LD_INT 4
3390: PUSH
3391: EMPTY
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: PUSH
3397: LD_INT 33
3399: PUSH
3400: LD_INT 59
3402: PUSH
3403: LD_INT 111
3405: PUSH
3406: LD_INT 3
3408: PUSH
3409: EMPTY
3410: LIST
3411: LIST
3412: LIST
3413: LIST
3414: PUSH
3415: LD_INT 33
3417: PUSH
3418: LD_INT 65
3420: PUSH
3421: LD_INT 111
3423: PUSH
3424: LD_INT 3
3426: PUSH
3427: EMPTY
3428: LIST
3429: LIST
3430: LIST
3431: LIST
3432: PUSH
3433: LD_INT 33
3435: PUSH
3436: LD_INT 76
3438: PUSH
3439: LD_INT 117
3441: PUSH
3442: LD_INT 3
3444: PUSH
3445: EMPTY
3446: LIST
3447: LIST
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 33
3453: PUSH
3454: LD_INT 80
3456: PUSH
3457: LD_INT 119
3459: PUSH
3460: LD_INT 3
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 33
3471: PUSH
3472: LD_INT 87
3474: PUSH
3475: LD_INT 125
3477: PUSH
3478: LD_INT 3
3480: PUSH
3481: EMPTY
3482: LIST
3483: LIST
3484: LIST
3485: LIST
3486: PUSH
3487: LD_INT 4
3489: PUSH
3490: LD_INT 92
3492: PUSH
3493: LD_INT 129
3495: PUSH
3496: LD_INT 3
3498: PUSH
3499: EMPTY
3500: LIST
3501: LIST
3502: LIST
3503: LIST
3504: PUSH
3505: LD_INT 28
3507: PUSH
3508: LD_INT 85
3510: PUSH
3511: LD_INT 165
3513: PUSH
3514: LD_INT 0
3516: PUSH
3517: EMPTY
3518: LIST
3519: LIST
3520: LIST
3521: LIST
3522: PUSH
3523: LD_INT 28
3525: PUSH
3526: LD_INT 83
3528: PUSH
3529: LD_INT 161
3531: PUSH
3532: LD_INT 4
3534: PUSH
3535: EMPTY
3536: LIST
3537: LIST
3538: LIST
3539: LIST
3540: PUSH
3541: LD_INT 28
3543: PUSH
3544: LD_INT 91
3546: PUSH
3547: LD_INT 166
3549: PUSH
3550: LD_INT 3
3552: PUSH
3553: EMPTY
3554: LIST
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 28
3561: PUSH
3562: LD_INT 102
3564: PUSH
3565: LD_INT 166
3567: PUSH
3568: LD_INT 2
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PUSH
3577: LD_INT 34
3579: PUSH
3580: LD_INT 91
3582: PUSH
3583: LD_INT 147
3585: PUSH
3586: LD_INT 3
3588: PUSH
3589: EMPTY
3590: LIST
3591: LIST
3592: LIST
3593: LIST
3594: PUSH
3595: EMPTY
3596: LIST
3597: LIST
3598: LIST
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: LIST
3606: LIST
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: LIST
3614: LIST
3615: LIST
3616: LIST
3617: LIST
3618: LIST
3619: LIST
3620: LIST
3621: LIST
3622: PPUSH
3623: CALL 65877 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
3627: LD_INT 3
3629: PPUSH
3630: LD_INT 10
3632: PUSH
3633: LD_INT 12
3635: PUSH
3636: LD_INT 14
3638: PUSH
3639: LD_INT 11
3641: PUSH
3642: EMPTY
3643: LIST
3644: LIST
3645: LIST
3646: LIST
3647: PPUSH
3648: CALL 66727 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
3652: LD_INT 3
3654: PPUSH
3655: LD_INT 94
3657: PPUSH
3658: LD_INT 161
3660: PPUSH
3661: LD_INT 0
3663: PPUSH
3664: LD_INT 19
3666: PUSH
3667: LD_INT 17
3669: PUSH
3670: LD_INT 18
3672: PUSH
3673: LD_INT 24
3675: PUSH
3676: LD_INT 21
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 66932 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
3690: LD_INT 3
3692: PPUSH
3693: LD_INT 0
3695: PPUSH
3696: CALL 66600 0 2
// end ; end_of_file
3700: LD_VAR 0 1
3704: RET
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
3705: LD_INT 0
3707: PPUSH
3708: PPUSH
3709: PPUSH
3710: PPUSH
// uc_side := 1 ;
3711: LD_ADDR_OWVAR 20
3715: PUSH
3716: LD_INT 1
3718: ST_TO_ADDR
// uc_nation := 1 ;
3719: LD_ADDR_OWVAR 21
3723: PUSH
3724: LD_INT 1
3726: ST_TO_ADDR
// hc_importance := 100 ;
3727: LD_ADDR_OWVAR 32
3731: PUSH
3732: LD_INT 100
3734: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
3735: LD_ADDR_OWVAR 26
3739: PUSH
3740: LD_STRING Jeremy Sikorski
3742: ST_TO_ADDR
// hc_gallery := us ;
3743: LD_ADDR_OWVAR 33
3747: PUSH
3748: LD_STRING us
3750: ST_TO_ADDR
// hc_face_number := 19 ;
3751: LD_ADDR_OWVAR 34
3755: PUSH
3756: LD_INT 19
3758: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
3759: LD_INT 1
3761: PPUSH
3762: LD_INT 1
3764: PPUSH
3765: LD_INT 4
3767: PUSH
3768: LD_INT 4
3770: PUSH
3771: LD_INT 3
3773: PUSH
3774: EMPTY
3775: LIST
3776: LIST
3777: LIST
3778: PUSH
3779: LD_OWVAR 67
3783: ARRAY
3784: PPUSH
3785: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
3789: LD_ADDR_OWVAR 29
3793: PUSH
3794: LD_INT 10
3796: PUSH
3797: LD_INT 12
3799: PUSH
3800: EMPTY
3801: LIST
3802: LIST
3803: ST_TO_ADDR
// Sikorski := CreateHuman ;
3804: LD_ADDR_EXP 11
3808: PUSH
3809: CALL_OW 44
3813: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
3814: LD_EXP 11
3818: PPUSH
3819: LD_INT 133
3821: PPUSH
3822: LD_INT 19
3824: PPUSH
3825: LD_INT 2
3827: PPUSH
3828: LD_INT 0
3830: PPUSH
3831: CALL_OW 50
// InitHc_All ( ) ;
3835: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
3839: LD_ADDR_VAR 0 2
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_INT 4
3851: PUSH
3852: LD_INT 3
3854: PUSH
3855: LD_INT 3
3857: PUSH
3858: EMPTY
3859: LIST
3860: LIST
3861: LIST
3862: PUSH
3863: LD_OWVAR 67
3867: ARRAY
3868: PUSH
3869: FOR_TO
3870: IFFALSE 3986
// for j := 1 to 4 do
3872: LD_ADDR_VAR 0 3
3876: PUSH
3877: DOUBLE
3878: LD_INT 1
3880: DEC
3881: ST_TO_ADDR
3882: LD_INT 4
3884: PUSH
3885: FOR_TO
3886: IFFALSE 3982
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
3888: LD_INT 0
3890: PPUSH
3891: LD_VAR 0 3
3895: PPUSH
3896: LD_INT 5
3898: PUSH
3899: LD_INT 4
3901: PUSH
3902: LD_INT 3
3904: PUSH
3905: EMPTY
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_OWVAR 67
3914: ARRAY
3915: PPUSH
3916: CALL_OW 380
// un := CreateHuman ;
3920: LD_ADDR_VAR 0 4
3924: PUSH
3925: CALL_OW 44
3929: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3930: LD_VAR 0 4
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: LD_INT 5
3940: PPUSH
3941: CALL_OW 12
3945: PPUSH
3946: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
3950: LD_VAR 0 4
3954: PPUSH
3955: LD_INT 133
3957: PPUSH
3958: LD_INT 19
3960: PPUSH
3961: LD_INT 6
3963: PPUSH
3964: LD_INT 0
3966: PPUSH
3967: CALL_OW 50
// ComHold ( un ) ;
3971: LD_VAR 0 4
3975: PPUSH
3976: CALL_OW 140
// end ;
3980: GO 3885
3982: POP
3983: POP
3984: GO 3869
3986: POP
3987: POP
// vc_chassis := us_heavy_tracked ;
3988: LD_ADDR_OWVAR 37
3992: PUSH
3993: LD_INT 4
3995: ST_TO_ADDR
// vc_engine := engine_combustion ;
3996: LD_ADDR_OWVAR 39
4000: PUSH
4001: LD_INT 1
4003: ST_TO_ADDR
// vc_control := control_manual ;
4004: LD_ADDR_OWVAR 38
4008: PUSH
4009: LD_INT 1
4011: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
4012: LD_ADDR_OWVAR 40
4016: PUSH
4017: LD_INT 14
4019: ST_TO_ADDR
// vc_fuel_battery := 60 ;
4020: LD_ADDR_OWVAR 41
4024: PUSH
4025: LD_INT 60
4027: ST_TO_ADDR
// un := CreateVehicle ;
4028: LD_ADDR_VAR 0 4
4032: PUSH
4033: CALL_OW 45
4037: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4038: LD_VAR 0 4
4042: PPUSH
4043: LD_INT 2
4045: PPUSH
4046: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
4050: LD_VAR 0 4
4054: PPUSH
4055: LD_INT 128
4057: PPUSH
4058: LD_INT 12
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 48
// for i := 1 to 3 do
4068: LD_ADDR_VAR 0 2
4072: PUSH
4073: DOUBLE
4074: LD_INT 1
4076: DEC
4077: ST_TO_ADDR
4078: LD_INT 3
4080: PUSH
4081: FOR_TO
4082: IFFALSE 4105
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
4084: LD_INT 5
4086: PPUSH
4087: LD_INT 133
4089: PPUSH
4090: LD_INT 19
4092: PPUSH
4093: LD_INT 3
4095: PPUSH
4096: LD_INT 0
4098: PPUSH
4099: CALL_OW 56
4103: GO 4081
4105: POP
4106: POP
// end ; end_of_file
4107: LD_VAR 0 1
4111: RET
// export function Action ; begin
4112: LD_INT 0
4114: PPUSH
// wait ( 0 0$5 ) ;
4115: LD_INT 175
4117: PPUSH
4118: CALL_OW 67
// InGameOn ;
4122: CALL_OW 8
// wait ( 0 0$2 ) ;
4126: LD_INT 70
4128: PPUSH
4129: CALL_OW 67
// CenterNowOnXY ( 133 , 19 ) ;
4133: LD_INT 133
4135: PPUSH
4136: LD_INT 19
4138: PPUSH
4139: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
4143: LD_EXP 11
4147: PPUSH
4148: LD_STRING WT-DS-1
4150: PPUSH
4151: CALL_OW 88
// wait ( 0 0$5 ) ;
4155: LD_INT 175
4157: PPUSH
4158: CALL_OW 67
// InGameOff ;
4162: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
4166: LD_STRING DestroyEnemy
4168: PPUSH
4169: CALL_OW 337
// end ; end_of_file
4173: LD_VAR 0 1
4177: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
4178: LD_VAR 0 1
4182: PPUSH
4183: CALL 69444 0 1
// if un = Powell then
4187: LD_VAR 0 1
4191: PUSH
4192: LD_EXP 4
4196: EQUAL
4197: IFFALSE 4206
// YouLost ( Powell ) ;
4199: LD_STRING Powell
4201: PPUSH
4202: CALL_OW 104
// end ;
4206: PPOPN 1
4208: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
4209: LD_VAR 0 1
4213: PPUSH
4214: LD_VAR 0 2
4218: PPUSH
4219: CALL 71778 0 2
// end ;
4223: PPOPN 2
4225: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
4226: LD_VAR 0 1
4230: PPUSH
4231: CALL 70846 0 1
// end ;
4235: PPOPN 1
4237: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
4238: LD_VAR 0 1
4242: PPUSH
4243: CALL 71087 0 1
// end ;
4247: PPOPN 1
4249: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
4250: LD_VAR 0 1
4254: PPUSH
4255: LD_VAR 0 2
4259: PPUSH
4260: CALL 69140 0 2
// end ;
4264: PPOPN 2
4266: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
4267: LD_VAR 0 1
4271: PPUSH
4272: LD_VAR 0 2
4276: PPUSH
4277: LD_VAR 0 3
4281: PPUSH
4282: LD_VAR 0 4
4286: PPUSH
4287: LD_VAR 0 5
4291: PPUSH
4292: CALL 68760 0 5
// end ;
4296: PPOPN 5
4298: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
4299: LD_VAR 0 1
4303: PPUSH
4304: LD_VAR 0 2
4308: PPUSH
4309: CALL 68350 0 2
// end ;
4313: PPOPN 2
4315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
4316: LD_VAR 0 1
4320: PPUSH
4321: LD_VAR 0 2
4325: PPUSH
4326: LD_VAR 0 3
4330: PPUSH
4331: LD_VAR 0 4
4335: PPUSH
4336: CALL 68188 0 4
// end ;
4340: PPOPN 4
4342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
4343: LD_VAR 0 1
4347: PPUSH
4348: LD_VAR 0 2
4352: PPUSH
4353: LD_VAR 0 3
4357: PPUSH
4358: CALL 67963 0 3
// end ;
4362: PPOPN 3
4364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
4365: LD_VAR 0 1
4369: PPUSH
4370: LD_VAR 0 2
4374: PPUSH
4375: CALL 67848 0 2
// end ;
4379: PPOPN 2
4381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
4382: LD_VAR 0 1
4386: PPUSH
4387: LD_VAR 0 2
4391: PPUSH
4392: CALL 72039 0 2
// end ;
4396: PPOPN 2
4398: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
4399: LD_VAR 0 1
4403: PPUSH
4404: LD_VAR 0 2
4408: PPUSH
4409: LD_VAR 0 3
4413: PPUSH
4414: LD_VAR 0 4
4418: PPUSH
4419: CALL 72255 0 4
// end ;
4423: PPOPN 4
4425: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
4426: LD_VAR 0 1
4430: PPUSH
4431: LD_VAR 0 2
4435: PPUSH
4436: CALL 67657 0 2
// end ;
4440: PPOPN 2
4442: END
// export function CustomEvent ( event ) ; begin
4443: LD_INT 0
4445: PPUSH
// end ;
4446: LD_VAR 0 2
4450: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
4451: LD_VAR 0 1
4455: PUSH
4456: LD_INT 1
4458: EQUAL
4459: PUSH
4460: LD_VAR 0 2
4464: PUSH
4465: LD_INT 4
4467: EQUAL
4468: AND
4469: IFFALSE 4478
// YouLost ( FriendlyFire ) ;
4471: LD_STRING FriendlyFire
4473: PPUSH
4474: CALL_OW 104
// end ; end_of_file
4478: PPOPN 2
4480: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
4481: LD_INT 0
4483: PPUSH
4484: PPUSH
// if exist_mode then
4485: LD_VAR 0 2
4489: IFFALSE 4514
// unit := CreateCharacter ( prefix & ident ) else
4491: LD_ADDR_VAR 0 5
4495: PUSH
4496: LD_VAR 0 3
4500: PUSH
4501: LD_VAR 0 1
4505: STR
4506: PPUSH
4507: CALL_OW 34
4511: ST_TO_ADDR
4512: GO 4529
// unit := NewCharacter ( ident ) ;
4514: LD_ADDR_VAR 0 5
4518: PUSH
4519: LD_VAR 0 1
4523: PPUSH
4524: CALL_OW 25
4528: ST_TO_ADDR
// result := unit ;
4529: LD_ADDR_VAR 0 4
4533: PUSH
4534: LD_VAR 0 5
4538: ST_TO_ADDR
// end ;
4539: LD_VAR 0 4
4543: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
4544: LD_INT 0
4546: PPUSH
4547: PPUSH
// if not side or not nation then
4548: LD_VAR 0 1
4552: NOT
4553: PUSH
4554: LD_VAR 0 2
4558: NOT
4559: OR
4560: IFFALSE 4564
// exit ;
4562: GO 5328
// case nation of nation_american :
4564: LD_VAR 0 2
4568: PUSH
4569: LD_INT 1
4571: DOUBLE
4572: EQUAL
4573: IFTRUE 4577
4575: GO 4791
4577: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
4578: LD_ADDR_VAR 0 4
4582: PUSH
4583: LD_INT 35
4585: PUSH
4586: LD_INT 45
4588: PUSH
4589: LD_INT 46
4591: PUSH
4592: LD_INT 47
4594: PUSH
4595: LD_INT 82
4597: PUSH
4598: LD_INT 83
4600: PUSH
4601: LD_INT 84
4603: PUSH
4604: LD_INT 85
4606: PUSH
4607: LD_INT 86
4609: PUSH
4610: LD_INT 1
4612: PUSH
4613: LD_INT 2
4615: PUSH
4616: LD_INT 6
4618: PUSH
4619: LD_INT 15
4621: PUSH
4622: LD_INT 16
4624: PUSH
4625: LD_INT 7
4627: PUSH
4628: LD_INT 12
4630: PUSH
4631: LD_INT 13
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: LD_INT 14
4639: PUSH
4640: LD_INT 20
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 22
4648: PUSH
4649: LD_INT 25
4651: PUSH
4652: LD_INT 32
4654: PUSH
4655: LD_INT 27
4657: PUSH
4658: LD_INT 36
4660: PUSH
4661: LD_INT 69
4663: PUSH
4664: LD_INT 39
4666: PUSH
4667: LD_INT 34
4669: PUSH
4670: LD_INT 40
4672: PUSH
4673: LD_INT 48
4675: PUSH
4676: LD_INT 49
4678: PUSH
4679: LD_INT 50
4681: PUSH
4682: LD_INT 51
4684: PUSH
4685: LD_INT 52
4687: PUSH
4688: LD_INT 53
4690: PUSH
4691: LD_INT 54
4693: PUSH
4694: LD_INT 55
4696: PUSH
4697: LD_INT 56
4699: PUSH
4700: LD_INT 57
4702: PUSH
4703: LD_INT 58
4705: PUSH
4706: LD_INT 59
4708: PUSH
4709: LD_INT 60
4711: PUSH
4712: LD_INT 61
4714: PUSH
4715: LD_INT 62
4717: PUSH
4718: LD_INT 80
4720: PUSH
4721: LD_INT 82
4723: PUSH
4724: LD_INT 83
4726: PUSH
4727: LD_INT 84
4729: PUSH
4730: LD_INT 85
4732: PUSH
4733: LD_INT 86
4735: PUSH
4736: EMPTY
4737: LIST
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: LIST
4743: LIST
4744: LIST
4745: LIST
4746: LIST
4747: LIST
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: LIST
4759: LIST
4760: LIST
4761: LIST
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: LIST
4767: LIST
4768: LIST
4769: LIST
4770: LIST
4771: LIST
4772: LIST
4773: LIST
4774: LIST
4775: LIST
4776: LIST
4777: LIST
4778: LIST
4779: LIST
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: LIST
4785: LIST
4786: LIST
4787: LIST
4788: ST_TO_ADDR
4789: GO 5252
4791: LD_INT 2
4793: DOUBLE
4794: EQUAL
4795: IFTRUE 4799
4797: GO 5021
4799: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
4800: LD_ADDR_VAR 0 4
4804: PUSH
4805: LD_INT 35
4807: PUSH
4808: LD_INT 45
4810: PUSH
4811: LD_INT 46
4813: PUSH
4814: LD_INT 47
4816: PUSH
4817: LD_INT 82
4819: PUSH
4820: LD_INT 83
4822: PUSH
4823: LD_INT 84
4825: PUSH
4826: LD_INT 85
4828: PUSH
4829: LD_INT 87
4831: PUSH
4832: LD_INT 70
4834: PUSH
4835: LD_INT 1
4837: PUSH
4838: LD_INT 11
4840: PUSH
4841: LD_INT 3
4843: PUSH
4844: LD_INT 4
4846: PUSH
4847: LD_INT 5
4849: PUSH
4850: LD_INT 6
4852: PUSH
4853: LD_INT 15
4855: PUSH
4856: LD_INT 18
4858: PUSH
4859: LD_INT 7
4861: PUSH
4862: LD_INT 17
4864: PUSH
4865: LD_INT 8
4867: PUSH
4868: LD_INT 20
4870: PUSH
4871: LD_INT 21
4873: PUSH
4874: LD_INT 22
4876: PUSH
4877: LD_INT 72
4879: PUSH
4880: LD_INT 26
4882: PUSH
4883: LD_INT 69
4885: PUSH
4886: LD_INT 39
4888: PUSH
4889: LD_INT 40
4891: PUSH
4892: LD_INT 41
4894: PUSH
4895: LD_INT 42
4897: PUSH
4898: LD_INT 43
4900: PUSH
4901: LD_INT 48
4903: PUSH
4904: LD_INT 49
4906: PUSH
4907: LD_INT 50
4909: PUSH
4910: LD_INT 51
4912: PUSH
4913: LD_INT 52
4915: PUSH
4916: LD_INT 53
4918: PUSH
4919: LD_INT 54
4921: PUSH
4922: LD_INT 55
4924: PUSH
4925: LD_INT 56
4927: PUSH
4928: LD_INT 60
4930: PUSH
4931: LD_INT 61
4933: PUSH
4934: LD_INT 62
4936: PUSH
4937: LD_INT 66
4939: PUSH
4940: LD_INT 67
4942: PUSH
4943: LD_INT 68
4945: PUSH
4946: LD_INT 81
4948: PUSH
4949: LD_INT 82
4951: PUSH
4952: LD_INT 83
4954: PUSH
4955: LD_INT 84
4957: PUSH
4958: LD_INT 85
4960: PUSH
4961: LD_INT 87
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: LIST
4970: LIST
4971: LIST
4972: LIST
4973: LIST
4974: LIST
4975: LIST
4976: LIST
4977: LIST
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: LIST
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: LIST
4988: LIST
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: LIST
4994: LIST
4995: LIST
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: LIST
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: ST_TO_ADDR
5019: GO 5252
5021: LD_INT 3
5023: DOUBLE
5024: EQUAL
5025: IFTRUE 5029
5027: GO 5251
5029: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
5030: LD_ADDR_VAR 0 4
5034: PUSH
5035: LD_INT 46
5037: PUSH
5038: LD_INT 47
5040: PUSH
5041: LD_INT 1
5043: PUSH
5044: LD_INT 2
5046: PUSH
5047: LD_INT 82
5049: PUSH
5050: LD_INT 83
5052: PUSH
5053: LD_INT 84
5055: PUSH
5056: LD_INT 85
5058: PUSH
5059: LD_INT 86
5061: PUSH
5062: LD_INT 11
5064: PUSH
5065: LD_INT 9
5067: PUSH
5068: LD_INT 20
5070: PUSH
5071: LD_INT 19
5073: PUSH
5074: LD_INT 21
5076: PUSH
5077: LD_INT 24
5079: PUSH
5080: LD_INT 22
5082: PUSH
5083: LD_INT 25
5085: PUSH
5086: LD_INT 28
5088: PUSH
5089: LD_INT 29
5091: PUSH
5092: LD_INT 30
5094: PUSH
5095: LD_INT 31
5097: PUSH
5098: LD_INT 37
5100: PUSH
5101: LD_INT 38
5103: PUSH
5104: LD_INT 32
5106: PUSH
5107: LD_INT 27
5109: PUSH
5110: LD_INT 33
5112: PUSH
5113: LD_INT 69
5115: PUSH
5116: LD_INT 39
5118: PUSH
5119: LD_INT 34
5121: PUSH
5122: LD_INT 40
5124: PUSH
5125: LD_INT 71
5127: PUSH
5128: LD_INT 23
5130: PUSH
5131: LD_INT 44
5133: PUSH
5134: LD_INT 48
5136: PUSH
5137: LD_INT 49
5139: PUSH
5140: LD_INT 50
5142: PUSH
5143: LD_INT 51
5145: PUSH
5146: LD_INT 52
5148: PUSH
5149: LD_INT 53
5151: PUSH
5152: LD_INT 54
5154: PUSH
5155: LD_INT 55
5157: PUSH
5158: LD_INT 56
5160: PUSH
5161: LD_INT 57
5163: PUSH
5164: LD_INT 58
5166: PUSH
5167: LD_INT 59
5169: PUSH
5170: LD_INT 63
5172: PUSH
5173: LD_INT 64
5175: PUSH
5176: LD_INT 65
5178: PUSH
5179: LD_INT 82
5181: PUSH
5182: LD_INT 83
5184: PUSH
5185: LD_INT 84
5187: PUSH
5188: LD_INT 85
5190: PUSH
5191: LD_INT 86
5193: PUSH
5194: EMPTY
5195: LIST
5196: LIST
5197: LIST
5198: LIST
5199: LIST
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: LIST
5213: LIST
5214: LIST
5215: LIST
5216: LIST
5217: LIST
5218: LIST
5219: LIST
5220: LIST
5221: LIST
5222: LIST
5223: LIST
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: LIST
5236: LIST
5237: LIST
5238: LIST
5239: LIST
5240: LIST
5241: LIST
5242: LIST
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: LIST
5248: ST_TO_ADDR
5249: GO 5252
5251: POP
// if state > - 1 and state < 3 then
5252: LD_VAR 0 3
5256: PUSH
5257: LD_INT 1
5259: NEG
5260: GREATER
5261: PUSH
5262: LD_VAR 0 3
5266: PUSH
5267: LD_INT 3
5269: LESS
5270: AND
5271: IFFALSE 5328
// for i in result do
5273: LD_ADDR_VAR 0 5
5277: PUSH
5278: LD_VAR 0 4
5282: PUSH
5283: FOR_IN
5284: IFFALSE 5326
// if GetTech ( i , side ) <> state then
5286: LD_VAR 0 5
5290: PPUSH
5291: LD_VAR 0 1
5295: PPUSH
5296: CALL_OW 321
5300: PUSH
5301: LD_VAR 0 3
5305: NONEQUAL
5306: IFFALSE 5324
// result := result diff i ;
5308: LD_ADDR_VAR 0 4
5312: PUSH
5313: LD_VAR 0 4
5317: PUSH
5318: LD_VAR 0 5
5322: DIFF
5323: ST_TO_ADDR
5324: GO 5283
5326: POP
5327: POP
// end ;
5328: LD_VAR 0 4
5332: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
5333: LD_INT 0
5335: PPUSH
5336: PPUSH
5337: PPUSH
// result := true ;
5338: LD_ADDR_VAR 0 3
5342: PUSH
5343: LD_INT 1
5345: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
5346: LD_ADDR_VAR 0 5
5350: PUSH
5351: LD_VAR 0 2
5355: PPUSH
5356: CALL_OW 480
5360: ST_TO_ADDR
// if not tmp then
5361: LD_VAR 0 5
5365: NOT
5366: IFFALSE 5370
// exit ;
5368: GO 5419
// for i in tmp do
5370: LD_ADDR_VAR 0 4
5374: PUSH
5375: LD_VAR 0 5
5379: PUSH
5380: FOR_IN
5381: IFFALSE 5417
// if GetTech ( i , side ) <> state_researched then
5383: LD_VAR 0 4
5387: PPUSH
5388: LD_VAR 0 1
5392: PPUSH
5393: CALL_OW 321
5397: PUSH
5398: LD_INT 2
5400: NONEQUAL
5401: IFFALSE 5415
// begin result := false ;
5403: LD_ADDR_VAR 0 3
5407: PUSH
5408: LD_INT 0
5410: ST_TO_ADDR
// exit ;
5411: POP
5412: POP
5413: GO 5419
// end ;
5415: GO 5380
5417: POP
5418: POP
// end ;
5419: LD_VAR 0 3
5423: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
5424: LD_INT 0
5426: PPUSH
5427: PPUSH
5428: PPUSH
5429: PPUSH
5430: PPUSH
5431: PPUSH
5432: PPUSH
5433: PPUSH
5434: PPUSH
5435: PPUSH
5436: PPUSH
5437: PPUSH
5438: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
5439: LD_VAR 0 1
5443: NOT
5444: PUSH
5445: LD_VAR 0 1
5449: PPUSH
5450: CALL_OW 257
5454: PUSH
5455: LD_INT 9
5457: NONEQUAL
5458: OR
5459: IFFALSE 5463
// exit ;
5461: GO 6036
// side := GetSide ( unit ) ;
5463: LD_ADDR_VAR 0 9
5467: PUSH
5468: LD_VAR 0 1
5472: PPUSH
5473: CALL_OW 255
5477: ST_TO_ADDR
// tech_space := tech_spacanom ;
5478: LD_ADDR_VAR 0 12
5482: PUSH
5483: LD_INT 29
5485: ST_TO_ADDR
// tech_time := tech_taurad ;
5486: LD_ADDR_VAR 0 13
5490: PUSH
5491: LD_INT 28
5493: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
5494: LD_ADDR_VAR 0 11
5498: PUSH
5499: LD_VAR 0 1
5503: PPUSH
5504: CALL_OW 310
5508: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
5509: LD_VAR 0 11
5513: PPUSH
5514: CALL_OW 247
5518: PUSH
5519: LD_INT 2
5521: EQUAL
5522: IFFALSE 5526
// exit ;
5524: GO 6036
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
5526: LD_ADDR_VAR 0 8
5530: PUSH
5531: LD_INT 81
5533: PUSH
5534: LD_VAR 0 9
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: LD_INT 3
5545: PUSH
5546: LD_INT 21
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 69
5568: ST_TO_ADDR
// if not tmp then
5569: LD_VAR 0 8
5573: NOT
5574: IFFALSE 5578
// exit ;
5576: GO 6036
// if in_unit then
5578: LD_VAR 0 11
5582: IFFALSE 5606
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
5584: LD_ADDR_VAR 0 10
5588: PUSH
5589: LD_VAR 0 8
5593: PPUSH
5594: LD_VAR 0 11
5598: PPUSH
5599: CALL_OW 74
5603: ST_TO_ADDR
5604: GO 5626
// enemy := NearestUnitToUnit ( tmp , unit ) ;
5606: LD_ADDR_VAR 0 10
5610: PUSH
5611: LD_VAR 0 8
5615: PPUSH
5616: LD_VAR 0 1
5620: PPUSH
5621: CALL_OW 74
5625: ST_TO_ADDR
// if not enemy then
5626: LD_VAR 0 10
5630: NOT
5631: IFFALSE 5635
// exit ;
5633: GO 6036
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
5635: LD_VAR 0 11
5639: PUSH
5640: LD_VAR 0 11
5644: PPUSH
5645: LD_VAR 0 10
5649: PPUSH
5650: CALL_OW 296
5654: PUSH
5655: LD_INT 13
5657: GREATER
5658: AND
5659: PUSH
5660: LD_VAR 0 1
5664: PPUSH
5665: LD_VAR 0 10
5669: PPUSH
5670: CALL_OW 296
5674: PUSH
5675: LD_INT 12
5677: GREATER
5678: OR
5679: IFFALSE 5683
// exit ;
5681: GO 6036
// missile := [ 1 ] ;
5683: LD_ADDR_VAR 0 14
5687: PUSH
5688: LD_INT 1
5690: PUSH
5691: EMPTY
5692: LIST
5693: ST_TO_ADDR
// if Researched ( side , tech_space ) then
5694: LD_VAR 0 9
5698: PPUSH
5699: LD_VAR 0 12
5703: PPUSH
5704: CALL_OW 325
5708: IFFALSE 5737
// missile := Insert ( missile , missile + 1 , 2 ) ;
5710: LD_ADDR_VAR 0 14
5714: PUSH
5715: LD_VAR 0 14
5719: PPUSH
5720: LD_VAR 0 14
5724: PUSH
5725: LD_INT 1
5727: PLUS
5728: PPUSH
5729: LD_INT 2
5731: PPUSH
5732: CALL_OW 2
5736: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
5737: LD_VAR 0 9
5741: PPUSH
5742: LD_VAR 0 13
5746: PPUSH
5747: CALL_OW 325
5751: PUSH
5752: LD_VAR 0 10
5756: PPUSH
5757: CALL_OW 255
5761: PPUSH
5762: LD_VAR 0 13
5766: PPUSH
5767: CALL_OW 325
5771: NOT
5772: AND
5773: IFFALSE 5802
// missile := Insert ( missile , missile + 1 , 3 ) ;
5775: LD_ADDR_VAR 0 14
5779: PUSH
5780: LD_VAR 0 14
5784: PPUSH
5785: LD_VAR 0 14
5789: PUSH
5790: LD_INT 1
5792: PLUS
5793: PPUSH
5794: LD_INT 3
5796: PPUSH
5797: CALL_OW 2
5801: ST_TO_ADDR
// if missile < 2 then
5802: LD_VAR 0 14
5806: PUSH
5807: LD_INT 2
5809: LESS
5810: IFFALSE 5814
// exit ;
5812: GO 6036
// x := GetX ( enemy ) ;
5814: LD_ADDR_VAR 0 4
5818: PUSH
5819: LD_VAR 0 10
5823: PPUSH
5824: CALL_OW 250
5828: ST_TO_ADDR
// y := GetY ( enemy ) ;
5829: LD_ADDR_VAR 0 5
5833: PUSH
5834: LD_VAR 0 10
5838: PPUSH
5839: CALL_OW 251
5843: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
5844: LD_ADDR_VAR 0 6
5848: PUSH
5849: LD_VAR 0 4
5853: PUSH
5854: LD_INT 1
5856: NEG
5857: PPUSH
5858: LD_INT 1
5860: PPUSH
5861: CALL_OW 12
5865: PLUS
5866: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
5867: LD_ADDR_VAR 0 7
5871: PUSH
5872: LD_VAR 0 5
5876: PUSH
5877: LD_INT 1
5879: NEG
5880: PPUSH
5881: LD_INT 1
5883: PPUSH
5884: CALL_OW 12
5888: PLUS
5889: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
5890: LD_VAR 0 6
5894: PPUSH
5895: LD_VAR 0 7
5899: PPUSH
5900: CALL_OW 488
5904: NOT
5905: IFFALSE 5927
// begin _x := x ;
5907: LD_ADDR_VAR 0 6
5911: PUSH
5912: LD_VAR 0 4
5916: ST_TO_ADDR
// _y := y ;
5917: LD_ADDR_VAR 0 7
5921: PUSH
5922: LD_VAR 0 5
5926: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
5927: LD_ADDR_VAR 0 3
5931: PUSH
5932: LD_INT 1
5934: PPUSH
5935: LD_VAR 0 14
5939: PPUSH
5940: CALL_OW 12
5944: ST_TO_ADDR
// case i of 1 :
5945: LD_VAR 0 3
5949: PUSH
5950: LD_INT 1
5952: DOUBLE
5953: EQUAL
5954: IFTRUE 5958
5956: GO 5975
5958: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
5959: LD_VAR 0 1
5963: PPUSH
5964: LD_VAR 0 10
5968: PPUSH
5969: CALL_OW 115
5973: GO 6036
5975: LD_INT 2
5977: DOUBLE
5978: EQUAL
5979: IFTRUE 5983
5981: GO 6005
5983: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
5984: LD_VAR 0 1
5988: PPUSH
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_VAR 0 7
5998: PPUSH
5999: CALL_OW 153
6003: GO 6036
6005: LD_INT 3
6007: DOUBLE
6008: EQUAL
6009: IFTRUE 6013
6011: GO 6035
6013: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
6014: LD_VAR 0 1
6018: PPUSH
6019: LD_VAR 0 6
6023: PPUSH
6024: LD_VAR 0 7
6028: PPUSH
6029: CALL_OW 154
6033: GO 6036
6035: POP
// end ;
6036: LD_VAR 0 2
6040: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
6041: LD_INT 0
6043: PPUSH
6044: PPUSH
6045: PPUSH
6046: PPUSH
6047: PPUSH
6048: PPUSH
// if not unit or not building then
6049: LD_VAR 0 1
6053: NOT
6054: PUSH
6055: LD_VAR 0 2
6059: NOT
6060: OR
6061: IFFALSE 6065
// exit ;
6063: GO 6223
// x := GetX ( building ) ;
6065: LD_ADDR_VAR 0 5
6069: PUSH
6070: LD_VAR 0 2
6074: PPUSH
6075: CALL_OW 250
6079: ST_TO_ADDR
// y := GetY ( building ) ;
6080: LD_ADDR_VAR 0 6
6084: PUSH
6085: LD_VAR 0 2
6089: PPUSH
6090: CALL_OW 251
6094: ST_TO_ADDR
// for i = 0 to 5 do
6095: LD_ADDR_VAR 0 4
6099: PUSH
6100: DOUBLE
6101: LD_INT 0
6103: DEC
6104: ST_TO_ADDR
6105: LD_INT 5
6107: PUSH
6108: FOR_TO
6109: IFFALSE 6221
// begin _x := ShiftX ( x , i , 3 ) ;
6111: LD_ADDR_VAR 0 7
6115: PUSH
6116: LD_VAR 0 5
6120: PPUSH
6121: LD_VAR 0 4
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: CALL_OW 272
6133: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
6134: LD_ADDR_VAR 0 8
6138: PUSH
6139: LD_VAR 0 6
6143: PPUSH
6144: LD_VAR 0 4
6148: PPUSH
6149: LD_INT 3
6151: PPUSH
6152: CALL_OW 273
6156: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
6157: LD_VAR 0 7
6161: PPUSH
6162: LD_VAR 0 8
6166: PPUSH
6167: CALL_OW 488
6171: NOT
6172: IFFALSE 6176
// continue ;
6174: GO 6108
// if HexInfo ( _x , _y ) = 0 then
6176: LD_VAR 0 7
6180: PPUSH
6181: LD_VAR 0 8
6185: PPUSH
6186: CALL_OW 428
6190: PUSH
6191: LD_INT 0
6193: EQUAL
6194: IFFALSE 6219
// begin ComMoveXY ( unit , _x , _y ) ;
6196: LD_VAR 0 1
6200: PPUSH
6201: LD_VAR 0 7
6205: PPUSH
6206: LD_VAR 0 8
6210: PPUSH
6211: CALL_OW 111
// exit ;
6215: POP
6216: POP
6217: GO 6223
// end ; end ;
6219: GO 6108
6221: POP
6222: POP
// end ;
6223: LD_VAR 0 3
6227: RET
// export function ScanBase ( side , base_area ) ; begin
6228: LD_INT 0
6230: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
6231: LD_ADDR_VAR 0 3
6235: PUSH
6236: LD_VAR 0 2
6240: PPUSH
6241: LD_INT 81
6243: PUSH
6244: LD_VAR 0 1
6248: PUSH
6249: EMPTY
6250: LIST
6251: LIST
6252: PPUSH
6253: CALL_OW 70
6257: ST_TO_ADDR
// end ;
6258: LD_VAR 0 3
6262: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
6263: LD_INT 0
6265: PPUSH
6266: PPUSH
6267: PPUSH
6268: PPUSH
// result := false ;
6269: LD_ADDR_VAR 0 2
6273: PUSH
6274: LD_INT 0
6276: ST_TO_ADDR
// side := GetSide ( unit ) ;
6277: LD_ADDR_VAR 0 3
6281: PUSH
6282: LD_VAR 0 1
6286: PPUSH
6287: CALL_OW 255
6291: ST_TO_ADDR
// nat := GetNation ( unit ) ;
6292: LD_ADDR_VAR 0 4
6296: PUSH
6297: LD_VAR 0 1
6301: PPUSH
6302: CALL_OW 248
6306: ST_TO_ADDR
// case nat of 1 :
6307: LD_VAR 0 4
6311: PUSH
6312: LD_INT 1
6314: DOUBLE
6315: EQUAL
6316: IFTRUE 6320
6318: GO 6331
6320: POP
// tech := tech_lassight ; 2 :
6321: LD_ADDR_VAR 0 5
6325: PUSH
6326: LD_INT 12
6328: ST_TO_ADDR
6329: GO 6370
6331: LD_INT 2
6333: DOUBLE
6334: EQUAL
6335: IFTRUE 6339
6337: GO 6350
6339: POP
// tech := tech_mortar ; 3 :
6340: LD_ADDR_VAR 0 5
6344: PUSH
6345: LD_INT 41
6347: ST_TO_ADDR
6348: GO 6370
6350: LD_INT 3
6352: DOUBLE
6353: EQUAL
6354: IFTRUE 6358
6356: GO 6369
6358: POP
// tech := tech_bazooka ; end ;
6359: LD_ADDR_VAR 0 5
6363: PUSH
6364: LD_INT 44
6366: ST_TO_ADDR
6367: GO 6370
6369: POP
// if Researched ( side , tech ) then
6370: LD_VAR 0 3
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 325
6384: IFFALSE 6411
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
6386: LD_ADDR_VAR 0 2
6390: PUSH
6391: LD_INT 5
6393: PUSH
6394: LD_INT 8
6396: PUSH
6397: LD_INT 9
6399: PUSH
6400: EMPTY
6401: LIST
6402: LIST
6403: LIST
6404: PUSH
6405: LD_VAR 0 4
6409: ARRAY
6410: ST_TO_ADDR
// end ;
6411: LD_VAR 0 2
6415: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
6416: LD_INT 0
6418: PPUSH
6419: PPUSH
6420: PPUSH
// if not mines then
6421: LD_VAR 0 2
6425: NOT
6426: IFFALSE 6430
// exit ;
6428: GO 6574
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
6430: LD_ADDR_VAR 0 5
6434: PUSH
6435: LD_INT 81
6437: PUSH
6438: LD_VAR 0 1
6442: PUSH
6443: EMPTY
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 3
6449: PUSH
6450: LD_INT 21
6452: PUSH
6453: LD_INT 3
6455: PUSH
6456: EMPTY
6457: LIST
6458: LIST
6459: PUSH
6460: EMPTY
6461: LIST
6462: LIST
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PPUSH
6468: CALL_OW 69
6472: ST_TO_ADDR
// for i in mines do
6473: LD_ADDR_VAR 0 4
6477: PUSH
6478: LD_VAR 0 2
6482: PUSH
6483: FOR_IN
6484: IFFALSE 6572
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
6486: LD_VAR 0 4
6490: PUSH
6491: LD_INT 1
6493: ARRAY
6494: PPUSH
6495: LD_VAR 0 4
6499: PUSH
6500: LD_INT 2
6502: ARRAY
6503: PPUSH
6504: CALL_OW 458
6508: NOT
6509: IFFALSE 6513
// continue ;
6511: GO 6483
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
6513: LD_VAR 0 4
6517: PUSH
6518: LD_INT 1
6520: ARRAY
6521: PPUSH
6522: LD_VAR 0 4
6526: PUSH
6527: LD_INT 2
6529: ARRAY
6530: PPUSH
6531: CALL_OW 428
6535: PUSH
6536: LD_VAR 0 5
6540: IN
6541: IFFALSE 6570
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
6543: LD_VAR 0 4
6547: PUSH
6548: LD_INT 1
6550: ARRAY
6551: PPUSH
6552: LD_VAR 0 4
6556: PUSH
6557: LD_INT 2
6559: ARRAY
6560: PPUSH
6561: LD_VAR 0 1
6565: PPUSH
6566: CALL_OW 456
// end ;
6570: GO 6483
6572: POP
6573: POP
// end ;
6574: LD_VAR 0 3
6578: RET
// export function Count ( array ) ; var i ; begin
6579: LD_INT 0
6581: PPUSH
6582: PPUSH
// result := 0 ;
6583: LD_ADDR_VAR 0 2
6587: PUSH
6588: LD_INT 0
6590: ST_TO_ADDR
// for i in array do
6591: LD_ADDR_VAR 0 3
6595: PUSH
6596: LD_VAR 0 1
6600: PUSH
6601: FOR_IN
6602: IFFALSE 6626
// if i then
6604: LD_VAR 0 3
6608: IFFALSE 6624
// result := result + 1 ;
6610: LD_ADDR_VAR 0 2
6614: PUSH
6615: LD_VAR 0 2
6619: PUSH
6620: LD_INT 1
6622: PLUS
6623: ST_TO_ADDR
6624: GO 6601
6626: POP
6627: POP
// end ;
6628: LD_VAR 0 2
6632: RET
// export function IsEmpty ( building ) ; begin
6633: LD_INT 0
6635: PPUSH
// if not building then
6636: LD_VAR 0 1
6640: NOT
6641: IFFALSE 6645
// exit ;
6643: GO 6688
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
6645: LD_ADDR_VAR 0 2
6649: PUSH
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 22
6657: PUSH
6658: LD_VAR 0 1
6662: PPUSH
6663: CALL_OW 255
6667: PUSH
6668: EMPTY
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 58
6674: PUSH
6675: EMPTY
6676: LIST
6677: PUSH
6678: EMPTY
6679: LIST
6680: LIST
6681: PPUSH
6682: CALL_OW 69
6686: IN
6687: ST_TO_ADDR
// end ;
6688: LD_VAR 0 2
6692: RET
// export function IsNotFull ( building ) ; begin
6693: LD_INT 0
6695: PPUSH
// if not building then
6696: LD_VAR 0 1
6700: NOT
6701: IFFALSE 6705
// exit ;
6703: GO 6724
// result := UnitsInside ( building ) < 6 ;
6705: LD_ADDR_VAR 0 2
6709: PUSH
6710: LD_VAR 0 1
6714: PPUSH
6715: CALL_OW 313
6719: PUSH
6720: LD_INT 6
6722: LESS
6723: ST_TO_ADDR
// end ;
6724: LD_VAR 0 2
6728: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
6729: LD_INT 0
6731: PPUSH
6732: PPUSH
6733: PPUSH
6734: PPUSH
// tmp := [ ] ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: EMPTY
6741: ST_TO_ADDR
// list := [ ] ;
6742: LD_ADDR_VAR 0 5
6746: PUSH
6747: EMPTY
6748: ST_TO_ADDR
// for i = 16 to 25 do
6749: LD_ADDR_VAR 0 4
6753: PUSH
6754: DOUBLE
6755: LD_INT 16
6757: DEC
6758: ST_TO_ADDR
6759: LD_INT 25
6761: PUSH
6762: FOR_TO
6763: IFFALSE 6836
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
6765: LD_ADDR_VAR 0 3
6769: PUSH
6770: LD_VAR 0 3
6774: PUSH
6775: LD_INT 22
6777: PUSH
6778: LD_VAR 0 1
6782: PPUSH
6783: CALL_OW 255
6787: PUSH
6788: EMPTY
6789: LIST
6790: LIST
6791: PUSH
6792: LD_INT 91
6794: PUSH
6795: LD_VAR 0 1
6799: PUSH
6800: LD_INT 6
6802: PUSH
6803: EMPTY
6804: LIST
6805: LIST
6806: LIST
6807: PUSH
6808: LD_INT 30
6810: PUSH
6811: LD_VAR 0 4
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: EMPTY
6821: LIST
6822: LIST
6823: LIST
6824: PUSH
6825: EMPTY
6826: LIST
6827: PPUSH
6828: CALL_OW 69
6832: ADD
6833: ST_TO_ADDR
6834: GO 6762
6836: POP
6837: POP
// for i = 1 to tmp do
6838: LD_ADDR_VAR 0 4
6842: PUSH
6843: DOUBLE
6844: LD_INT 1
6846: DEC
6847: ST_TO_ADDR
6848: LD_VAR 0 3
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6942
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
6856: LD_ADDR_VAR 0 5
6860: PUSH
6861: LD_VAR 0 5
6865: PUSH
6866: LD_VAR 0 3
6870: PUSH
6871: LD_VAR 0 4
6875: ARRAY
6876: PPUSH
6877: CALL_OW 266
6881: PUSH
6882: LD_VAR 0 3
6886: PUSH
6887: LD_VAR 0 4
6891: ARRAY
6892: PPUSH
6893: CALL_OW 250
6897: PUSH
6898: LD_VAR 0 3
6902: PUSH
6903: LD_VAR 0 4
6907: ARRAY
6908: PPUSH
6909: CALL_OW 251
6913: PUSH
6914: LD_VAR 0 3
6918: PUSH
6919: LD_VAR 0 4
6923: ARRAY
6924: PPUSH
6925: CALL_OW 254
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: EMPTY
6937: LIST
6938: ADD
6939: ST_TO_ADDR
6940: GO 6853
6942: POP
6943: POP
// result := list ;
6944: LD_ADDR_VAR 0 2
6948: PUSH
6949: LD_VAR 0 5
6953: ST_TO_ADDR
// end ;
6954: LD_VAR 0 2
6958: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
6959: LD_INT 0
6961: PPUSH
6962: PPUSH
6963: PPUSH
6964: PPUSH
6965: PPUSH
6966: PPUSH
6967: PPUSH
// if not factory then
6968: LD_VAR 0 1
6972: NOT
6973: IFFALSE 6977
// exit ;
6975: GO 7570
// if control = control_apeman then
6977: LD_VAR 0 4
6981: PUSH
6982: LD_INT 5
6984: EQUAL
6985: IFFALSE 7094
// begin tmp := UnitsInside ( factory ) ;
6987: LD_ADDR_VAR 0 8
6991: PUSH
6992: LD_VAR 0 1
6996: PPUSH
6997: CALL_OW 313
7001: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
7002: LD_VAR 0 8
7006: PPUSH
7007: LD_INT 25
7009: PUSH
7010: LD_INT 12
7012: PUSH
7013: EMPTY
7014: LIST
7015: LIST
7016: PPUSH
7017: CALL_OW 72
7021: NOT
7022: IFFALSE 7032
// control := control_manual ;
7024: LD_ADDR_VAR 0 4
7028: PUSH
7029: LD_INT 1
7031: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
7032: LD_ADDR_VAR 0 8
7036: PUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL 6729 0 1
7046: ST_TO_ADDR
// if tmp then
7047: LD_VAR 0 8
7051: IFFALSE 7094
// begin for i in tmp do
7053: LD_ADDR_VAR 0 7
7057: PUSH
7058: LD_VAR 0 8
7062: PUSH
7063: FOR_IN
7064: IFFALSE 7092
// if i [ 1 ] = b_ext_radio then
7066: LD_VAR 0 7
7070: PUSH
7071: LD_INT 1
7073: ARRAY
7074: PUSH
7075: LD_INT 22
7077: EQUAL
7078: IFFALSE 7090
// begin control := control_remote ;
7080: LD_ADDR_VAR 0 4
7084: PUSH
7085: LD_INT 2
7087: ST_TO_ADDR
// break ;
7088: GO 7092
// end ;
7090: GO 7063
7092: POP
7093: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7094: LD_VAR 0 1
7098: PPUSH
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_VAR 0 4
7113: PPUSH
7114: LD_VAR 0 5
7118: PPUSH
7119: CALL_OW 448
7123: IFFALSE 7158
// begin result := [ chassis , engine , control , weapon ] ;
7125: LD_ADDR_VAR 0 6
7129: PUSH
7130: LD_VAR 0 2
7134: PUSH
7135: LD_VAR 0 3
7139: PUSH
7140: LD_VAR 0 4
7144: PUSH
7145: LD_VAR 0 5
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: LIST
7154: LIST
7155: ST_TO_ADDR
// exit ;
7156: GO 7570
// end ; _chassis := AvailableChassisList ( factory ) ;
7158: LD_ADDR_VAR 0 9
7162: PUSH
7163: LD_VAR 0 1
7167: PPUSH
7168: CALL_OW 475
7172: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
7173: LD_ADDR_VAR 0 11
7177: PUSH
7178: LD_VAR 0 1
7182: PPUSH
7183: CALL_OW 476
7187: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
7188: LD_ADDR_VAR 0 12
7192: PUSH
7193: LD_VAR 0 1
7197: PPUSH
7198: CALL_OW 477
7202: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
7203: LD_ADDR_VAR 0 10
7207: PUSH
7208: LD_VAR 0 1
7212: PPUSH
7213: CALL_OW 478
7217: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
7218: LD_VAR 0 9
7222: NOT
7223: PUSH
7224: LD_VAR 0 11
7228: NOT
7229: OR
7230: PUSH
7231: LD_VAR 0 12
7235: NOT
7236: OR
7237: PUSH
7238: LD_VAR 0 10
7242: NOT
7243: OR
7244: IFFALSE 7279
// begin result := [ chassis , engine , control , weapon ] ;
7246: LD_ADDR_VAR 0 6
7250: PUSH
7251: LD_VAR 0 2
7255: PUSH
7256: LD_VAR 0 3
7260: PUSH
7261: LD_VAR 0 4
7265: PUSH
7266: LD_VAR 0 5
7270: PUSH
7271: EMPTY
7272: LIST
7273: LIST
7274: LIST
7275: LIST
7276: ST_TO_ADDR
// exit ;
7277: GO 7570
// end ; if not chassis in _chassis then
7279: LD_VAR 0 2
7283: PUSH
7284: LD_VAR 0 9
7288: IN
7289: NOT
7290: IFFALSE 7316
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
7292: LD_ADDR_VAR 0 2
7296: PUSH
7297: LD_VAR 0 9
7301: PUSH
7302: LD_INT 1
7304: PPUSH
7305: LD_VAR 0 9
7309: PPUSH
7310: CALL_OW 12
7314: ARRAY
7315: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_VAR 0 3
7325: PPUSH
7326: CALL 7575 0 2
7330: NOT
7331: IFFALSE 7390
// repeat engine := _engine [ 1 ] ;
7333: LD_ADDR_VAR 0 3
7337: PUSH
7338: LD_VAR 0 11
7342: PUSH
7343: LD_INT 1
7345: ARRAY
7346: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
7347: LD_ADDR_VAR 0 11
7351: PUSH
7352: LD_VAR 0 11
7356: PPUSH
7357: LD_INT 1
7359: PPUSH
7360: CALL_OW 3
7364: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
7365: LD_VAR 0 2
7369: PPUSH
7370: LD_VAR 0 3
7374: PPUSH
7375: CALL 7575 0 2
7379: PUSH
7380: LD_VAR 0 11
7384: PUSH
7385: EMPTY
7386: EQUAL
7387: OR
7388: IFFALSE 7333
// if not control in _control then
7390: LD_VAR 0 4
7394: PUSH
7395: LD_VAR 0 12
7399: IN
7400: NOT
7401: IFFALSE 7427
// control := _control [ rand ( 1 , _control ) ] ;
7403: LD_ADDR_VAR 0 4
7407: PUSH
7408: LD_VAR 0 12
7412: PUSH
7413: LD_INT 1
7415: PPUSH
7416: LD_VAR 0 12
7420: PPUSH
7421: CALL_OW 12
7425: ARRAY
7426: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
7427: LD_VAR 0 2
7431: PPUSH
7432: LD_VAR 0 5
7436: PPUSH
7437: CALL 7795 0 2
7441: NOT
7442: IFFALSE 7501
// repeat weapon := _weapon [ 1 ] ;
7444: LD_ADDR_VAR 0 5
7448: PUSH
7449: LD_VAR 0 10
7453: PUSH
7454: LD_INT 1
7456: ARRAY
7457: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
7458: LD_ADDR_VAR 0 10
7462: PUSH
7463: LD_VAR 0 10
7467: PPUSH
7468: LD_INT 1
7470: PPUSH
7471: CALL_OW 3
7475: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
7476: LD_VAR 0 2
7480: PPUSH
7481: LD_VAR 0 5
7485: PPUSH
7486: CALL 7795 0 2
7490: PUSH
7491: LD_VAR 0 10
7495: PUSH
7496: EMPTY
7497: EQUAL
7498: OR
7499: IFFALSE 7444
// result := [ ] ;
7501: LD_ADDR_VAR 0 6
7505: PUSH
7506: EMPTY
7507: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
7508: LD_VAR 0 1
7512: PPUSH
7513: LD_VAR 0 2
7517: PPUSH
7518: LD_VAR 0 3
7522: PPUSH
7523: LD_VAR 0 4
7527: PPUSH
7528: LD_VAR 0 5
7532: PPUSH
7533: CALL_OW 448
7537: IFFALSE 7570
// result := [ chassis , engine , control , weapon ] ;
7539: LD_ADDR_VAR 0 6
7543: PUSH
7544: LD_VAR 0 2
7548: PUSH
7549: LD_VAR 0 3
7553: PUSH
7554: LD_VAR 0 4
7558: PUSH
7559: LD_VAR 0 5
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: LIST
7568: LIST
7569: ST_TO_ADDR
// end ;
7570: LD_VAR 0 6
7574: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
7575: LD_INT 0
7577: PPUSH
// if not chassis or not engine then
7578: LD_VAR 0 1
7582: NOT
7583: PUSH
7584: LD_VAR 0 2
7588: NOT
7589: OR
7590: IFFALSE 7594
// exit ;
7592: GO 7790
// case engine of engine_solar :
7594: LD_VAR 0 2
7598: PUSH
7599: LD_INT 2
7601: DOUBLE
7602: EQUAL
7603: IFTRUE 7607
7605: GO 7645
7607: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
7608: LD_ADDR_VAR 0 3
7612: PUSH
7613: LD_INT 11
7615: PUSH
7616: LD_INT 12
7618: PUSH
7619: LD_INT 13
7621: PUSH
7622: LD_INT 14
7624: PUSH
7625: LD_INT 1
7627: PUSH
7628: LD_INT 2
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: LIST
7642: ST_TO_ADDR
7643: GO 7774
7645: LD_INT 1
7647: DOUBLE
7648: EQUAL
7649: IFTRUE 7653
7651: GO 7715
7653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
7654: LD_ADDR_VAR 0 3
7658: PUSH
7659: LD_INT 11
7661: PUSH
7662: LD_INT 12
7664: PUSH
7665: LD_INT 13
7667: PUSH
7668: LD_INT 14
7670: PUSH
7671: LD_INT 1
7673: PUSH
7674: LD_INT 2
7676: PUSH
7677: LD_INT 3
7679: PUSH
7680: LD_INT 4
7682: PUSH
7683: LD_INT 5
7685: PUSH
7686: LD_INT 21
7688: PUSH
7689: LD_INT 23
7691: PUSH
7692: LD_INT 22
7694: PUSH
7695: LD_INT 24
7697: PUSH
7698: EMPTY
7699: LIST
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: LIST
7705: LIST
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: LIST
7711: LIST
7712: ST_TO_ADDR
7713: GO 7774
7715: LD_INT 3
7717: DOUBLE
7718: EQUAL
7719: IFTRUE 7723
7721: GO 7773
7723: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
7724: LD_ADDR_VAR 0 3
7728: PUSH
7729: LD_INT 13
7731: PUSH
7732: LD_INT 14
7734: PUSH
7735: LD_INT 2
7737: PUSH
7738: LD_INT 3
7740: PUSH
7741: LD_INT 4
7743: PUSH
7744: LD_INT 5
7746: PUSH
7747: LD_INT 21
7749: PUSH
7750: LD_INT 22
7752: PUSH
7753: LD_INT 23
7755: PUSH
7756: LD_INT 24
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: LIST
7763: LIST
7764: LIST
7765: LIST
7766: LIST
7767: LIST
7768: LIST
7769: LIST
7770: ST_TO_ADDR
7771: GO 7774
7773: POP
// result := ( chassis in result ) ;
7774: LD_ADDR_VAR 0 3
7778: PUSH
7779: LD_VAR 0 1
7783: PUSH
7784: LD_VAR 0 3
7788: IN
7789: ST_TO_ADDR
// end ;
7790: LD_VAR 0 3
7794: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
7795: LD_INT 0
7797: PPUSH
// if not chassis or not weapon then
7798: LD_VAR 0 1
7802: NOT
7803: PUSH
7804: LD_VAR 0 2
7808: NOT
7809: OR
7810: IFFALSE 7814
// exit ;
7812: GO 8840
// case weapon of us_machine_gun :
7814: LD_VAR 0 2
7818: PUSH
7819: LD_INT 2
7821: DOUBLE
7822: EQUAL
7823: IFTRUE 7827
7825: GO 7857
7827: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
7828: LD_ADDR_VAR 0 3
7832: PUSH
7833: LD_INT 1
7835: PUSH
7836: LD_INT 2
7838: PUSH
7839: LD_INT 3
7841: PUSH
7842: LD_INT 4
7844: PUSH
7845: LD_INT 5
7847: PUSH
7848: EMPTY
7849: LIST
7850: LIST
7851: LIST
7852: LIST
7853: LIST
7854: ST_TO_ADDR
7855: GO 8824
7857: LD_INT 3
7859: DOUBLE
7860: EQUAL
7861: IFTRUE 7865
7863: GO 7895
7865: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
7866: LD_ADDR_VAR 0 3
7870: PUSH
7871: LD_INT 1
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: LD_INT 3
7879: PUSH
7880: LD_INT 4
7882: PUSH
7883: LD_INT 5
7885: PUSH
7886: EMPTY
7887: LIST
7888: LIST
7889: LIST
7890: LIST
7891: LIST
7892: ST_TO_ADDR
7893: GO 8824
7895: LD_INT 11
7897: DOUBLE
7898: EQUAL
7899: IFTRUE 7903
7901: GO 7933
7903: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
7904: LD_ADDR_VAR 0 3
7908: PUSH
7909: LD_INT 1
7911: PUSH
7912: LD_INT 2
7914: PUSH
7915: LD_INT 3
7917: PUSH
7918: LD_INT 4
7920: PUSH
7921: LD_INT 5
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: LIST
7928: LIST
7929: LIST
7930: ST_TO_ADDR
7931: GO 8824
7933: LD_INT 4
7935: DOUBLE
7936: EQUAL
7937: IFTRUE 7941
7939: GO 7967
7941: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
7942: LD_ADDR_VAR 0 3
7946: PUSH
7947: LD_INT 2
7949: PUSH
7950: LD_INT 3
7952: PUSH
7953: LD_INT 4
7955: PUSH
7956: LD_INT 5
7958: PUSH
7959: EMPTY
7960: LIST
7961: LIST
7962: LIST
7963: LIST
7964: ST_TO_ADDR
7965: GO 8824
7967: LD_INT 5
7969: DOUBLE
7970: EQUAL
7971: IFTRUE 7975
7973: GO 8001
7975: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
7976: LD_ADDR_VAR 0 3
7980: PUSH
7981: LD_INT 2
7983: PUSH
7984: LD_INT 3
7986: PUSH
7987: LD_INT 4
7989: PUSH
7990: LD_INT 5
7992: PUSH
7993: EMPTY
7994: LIST
7995: LIST
7996: LIST
7997: LIST
7998: ST_TO_ADDR
7999: GO 8824
8001: LD_INT 9
8003: DOUBLE
8004: EQUAL
8005: IFTRUE 8009
8007: GO 8035
8009: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
8010: LD_ADDR_VAR 0 3
8014: PUSH
8015: LD_INT 2
8017: PUSH
8018: LD_INT 3
8020: PUSH
8021: LD_INT 4
8023: PUSH
8024: LD_INT 5
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: LIST
8031: LIST
8032: ST_TO_ADDR
8033: GO 8824
8035: LD_INT 7
8037: DOUBLE
8038: EQUAL
8039: IFTRUE 8043
8041: GO 8069
8043: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
8044: LD_ADDR_VAR 0 3
8048: PUSH
8049: LD_INT 2
8051: PUSH
8052: LD_INT 3
8054: PUSH
8055: LD_INT 4
8057: PUSH
8058: LD_INT 5
8060: PUSH
8061: EMPTY
8062: LIST
8063: LIST
8064: LIST
8065: LIST
8066: ST_TO_ADDR
8067: GO 8824
8069: LD_INT 12
8071: DOUBLE
8072: EQUAL
8073: IFTRUE 8077
8075: GO 8103
8077: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_INT 2
8085: PUSH
8086: LD_INT 3
8088: PUSH
8089: LD_INT 4
8091: PUSH
8092: LD_INT 5
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
8101: GO 8824
8103: LD_INT 13
8105: DOUBLE
8106: EQUAL
8107: IFTRUE 8111
8109: GO 8137
8111: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
8112: LD_ADDR_VAR 0 3
8116: PUSH
8117: LD_INT 2
8119: PUSH
8120: LD_INT 3
8122: PUSH
8123: LD_INT 4
8125: PUSH
8126: LD_INT 5
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: LIST
8134: ST_TO_ADDR
8135: GO 8824
8137: LD_INT 14
8139: DOUBLE
8140: EQUAL
8141: IFTRUE 8145
8143: GO 8163
8145: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
8146: LD_ADDR_VAR 0 3
8150: PUSH
8151: LD_INT 4
8153: PUSH
8154: LD_INT 5
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: ST_TO_ADDR
8161: GO 8824
8163: LD_INT 6
8165: DOUBLE
8166: EQUAL
8167: IFTRUE 8171
8169: GO 8189
8171: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
8172: LD_ADDR_VAR 0 3
8176: PUSH
8177: LD_INT 4
8179: PUSH
8180: LD_INT 5
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: ST_TO_ADDR
8187: GO 8824
8189: LD_INT 10
8191: DOUBLE
8192: EQUAL
8193: IFTRUE 8197
8195: GO 8215
8197: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
8198: LD_ADDR_VAR 0 3
8202: PUSH
8203: LD_INT 4
8205: PUSH
8206: LD_INT 5
8208: PUSH
8209: EMPTY
8210: LIST
8211: LIST
8212: ST_TO_ADDR
8213: GO 8824
8215: LD_INT 22
8217: DOUBLE
8218: EQUAL
8219: IFTRUE 8223
8221: GO 8249
8223: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
8224: LD_ADDR_VAR 0 3
8228: PUSH
8229: LD_INT 11
8231: PUSH
8232: LD_INT 12
8234: PUSH
8235: LD_INT 13
8237: PUSH
8238: LD_INT 14
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: LIST
8246: ST_TO_ADDR
8247: GO 8824
8249: LD_INT 23
8251: DOUBLE
8252: EQUAL
8253: IFTRUE 8257
8255: GO 8283
8257: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
8258: LD_ADDR_VAR 0 3
8262: PUSH
8263: LD_INT 11
8265: PUSH
8266: LD_INT 12
8268: PUSH
8269: LD_INT 13
8271: PUSH
8272: LD_INT 14
8274: PUSH
8275: EMPTY
8276: LIST
8277: LIST
8278: LIST
8279: LIST
8280: ST_TO_ADDR
8281: GO 8824
8283: LD_INT 24
8285: DOUBLE
8286: EQUAL
8287: IFTRUE 8291
8289: GO 8317
8291: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
8292: LD_ADDR_VAR 0 3
8296: PUSH
8297: LD_INT 11
8299: PUSH
8300: LD_INT 12
8302: PUSH
8303: LD_INT 13
8305: PUSH
8306: LD_INT 14
8308: PUSH
8309: EMPTY
8310: LIST
8311: LIST
8312: LIST
8313: LIST
8314: ST_TO_ADDR
8315: GO 8824
8317: LD_INT 30
8319: DOUBLE
8320: EQUAL
8321: IFTRUE 8325
8323: GO 8351
8325: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
8326: LD_ADDR_VAR 0 3
8330: PUSH
8331: LD_INT 11
8333: PUSH
8334: LD_INT 12
8336: PUSH
8337: LD_INT 13
8339: PUSH
8340: LD_INT 14
8342: PUSH
8343: EMPTY
8344: LIST
8345: LIST
8346: LIST
8347: LIST
8348: ST_TO_ADDR
8349: GO 8824
8351: LD_INT 25
8353: DOUBLE
8354: EQUAL
8355: IFTRUE 8359
8357: GO 8377
8359: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 13
8367: PUSH
8368: LD_INT 14
8370: PUSH
8371: EMPTY
8372: LIST
8373: LIST
8374: ST_TO_ADDR
8375: GO 8824
8377: LD_INT 27
8379: DOUBLE
8380: EQUAL
8381: IFTRUE 8385
8383: GO 8403
8385: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 13
8393: PUSH
8394: LD_INT 14
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: ST_TO_ADDR
8401: GO 8824
8403: LD_INT 28
8405: DOUBLE
8406: EQUAL
8407: IFTRUE 8411
8409: GO 8429
8411: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
8412: LD_ADDR_VAR 0 3
8416: PUSH
8417: LD_INT 13
8419: PUSH
8420: LD_INT 14
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: ST_TO_ADDR
8427: GO 8824
8429: LD_INT 29
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 8455
8437: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
8438: LD_ADDR_VAR 0 3
8442: PUSH
8443: LD_INT 13
8445: PUSH
8446: LD_INT 14
8448: PUSH
8449: EMPTY
8450: LIST
8451: LIST
8452: ST_TO_ADDR
8453: GO 8824
8455: LD_INT 31
8457: DOUBLE
8458: EQUAL
8459: IFTRUE 8463
8461: GO 8481
8463: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
8464: LD_ADDR_VAR 0 3
8468: PUSH
8469: LD_INT 13
8471: PUSH
8472: LD_INT 14
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: ST_TO_ADDR
8479: GO 8824
8481: LD_INT 26
8483: DOUBLE
8484: EQUAL
8485: IFTRUE 8489
8487: GO 8507
8489: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
8490: LD_ADDR_VAR 0 3
8494: PUSH
8495: LD_INT 13
8497: PUSH
8498: LD_INT 14
8500: PUSH
8501: EMPTY
8502: LIST
8503: LIST
8504: ST_TO_ADDR
8505: GO 8824
8507: LD_INT 42
8509: DOUBLE
8510: EQUAL
8511: IFTRUE 8515
8513: GO 8541
8515: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
8516: LD_ADDR_VAR 0 3
8520: PUSH
8521: LD_INT 21
8523: PUSH
8524: LD_INT 22
8526: PUSH
8527: LD_INT 23
8529: PUSH
8530: LD_INT 24
8532: PUSH
8533: EMPTY
8534: LIST
8535: LIST
8536: LIST
8537: LIST
8538: ST_TO_ADDR
8539: GO 8824
8541: LD_INT 43
8543: DOUBLE
8544: EQUAL
8545: IFTRUE 8549
8547: GO 8575
8549: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
8550: LD_ADDR_VAR 0 3
8554: PUSH
8555: LD_INT 21
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 23
8563: PUSH
8564: LD_INT 24
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: LIST
8571: LIST
8572: ST_TO_ADDR
8573: GO 8824
8575: LD_INT 44
8577: DOUBLE
8578: EQUAL
8579: IFTRUE 8583
8581: GO 8609
8583: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
8584: LD_ADDR_VAR 0 3
8588: PUSH
8589: LD_INT 21
8591: PUSH
8592: LD_INT 22
8594: PUSH
8595: LD_INT 23
8597: PUSH
8598: LD_INT 24
8600: PUSH
8601: EMPTY
8602: LIST
8603: LIST
8604: LIST
8605: LIST
8606: ST_TO_ADDR
8607: GO 8824
8609: LD_INT 45
8611: DOUBLE
8612: EQUAL
8613: IFTRUE 8617
8615: GO 8643
8617: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
8618: LD_ADDR_VAR 0 3
8622: PUSH
8623: LD_INT 21
8625: PUSH
8626: LD_INT 22
8628: PUSH
8629: LD_INT 23
8631: PUSH
8632: LD_INT 24
8634: PUSH
8635: EMPTY
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: ST_TO_ADDR
8641: GO 8824
8643: LD_INT 49
8645: DOUBLE
8646: EQUAL
8647: IFTRUE 8651
8649: GO 8677
8651: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
8652: LD_ADDR_VAR 0 3
8656: PUSH
8657: LD_INT 21
8659: PUSH
8660: LD_INT 22
8662: PUSH
8663: LD_INT 23
8665: PUSH
8666: LD_INT 24
8668: PUSH
8669: EMPTY
8670: LIST
8671: LIST
8672: LIST
8673: LIST
8674: ST_TO_ADDR
8675: GO 8824
8677: LD_INT 51
8679: DOUBLE
8680: EQUAL
8681: IFTRUE 8685
8683: GO 8711
8685: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
8686: LD_ADDR_VAR 0 3
8690: PUSH
8691: LD_INT 21
8693: PUSH
8694: LD_INT 22
8696: PUSH
8697: LD_INT 23
8699: PUSH
8700: LD_INT 24
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: LIST
8708: ST_TO_ADDR
8709: GO 8824
8711: LD_INT 52
8713: DOUBLE
8714: EQUAL
8715: IFTRUE 8719
8717: GO 8745
8719: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
8720: LD_ADDR_VAR 0 3
8724: PUSH
8725: LD_INT 21
8727: PUSH
8728: LD_INT 22
8730: PUSH
8731: LD_INT 23
8733: PUSH
8734: LD_INT 24
8736: PUSH
8737: EMPTY
8738: LIST
8739: LIST
8740: LIST
8741: LIST
8742: ST_TO_ADDR
8743: GO 8824
8745: LD_INT 53
8747: DOUBLE
8748: EQUAL
8749: IFTRUE 8753
8751: GO 8771
8753: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
8754: LD_ADDR_VAR 0 3
8758: PUSH
8759: LD_INT 23
8761: PUSH
8762: LD_INT 24
8764: PUSH
8765: EMPTY
8766: LIST
8767: LIST
8768: ST_TO_ADDR
8769: GO 8824
8771: LD_INT 46
8773: DOUBLE
8774: EQUAL
8775: IFTRUE 8779
8777: GO 8797
8779: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
8780: LD_ADDR_VAR 0 3
8784: PUSH
8785: LD_INT 23
8787: PUSH
8788: LD_INT 24
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: ST_TO_ADDR
8795: GO 8824
8797: LD_INT 47
8799: DOUBLE
8800: EQUAL
8801: IFTRUE 8805
8803: GO 8823
8805: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
8806: LD_ADDR_VAR 0 3
8810: PUSH
8811: LD_INT 23
8813: PUSH
8814: LD_INT 24
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: ST_TO_ADDR
8821: GO 8824
8823: POP
// result := ( chassis in result ) ;
8824: LD_ADDR_VAR 0 3
8828: PUSH
8829: LD_VAR 0 1
8833: PUSH
8834: LD_VAR 0 3
8838: IN
8839: ST_TO_ADDR
// end ;
8840: LD_VAR 0 3
8844: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
8845: LD_INT 0
8847: PPUSH
8848: PPUSH
8849: PPUSH
8850: PPUSH
8851: PPUSH
8852: PPUSH
8853: PPUSH
// result := array ;
8854: LD_ADDR_VAR 0 5
8858: PUSH
8859: LD_VAR 0 1
8863: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
8864: LD_VAR 0 1
8868: NOT
8869: PUSH
8870: LD_VAR 0 2
8874: NOT
8875: OR
8876: PUSH
8877: LD_VAR 0 3
8881: NOT
8882: OR
8883: PUSH
8884: LD_VAR 0 2
8888: PUSH
8889: LD_VAR 0 1
8893: GREATER
8894: OR
8895: PUSH
8896: LD_VAR 0 3
8900: PUSH
8901: LD_VAR 0 1
8905: GREATER
8906: OR
8907: IFFALSE 8911
// exit ;
8909: GO 9207
// if direction then
8911: LD_VAR 0 4
8915: IFFALSE 8979
// begin d := 1 ;
8917: LD_ADDR_VAR 0 9
8921: PUSH
8922: LD_INT 1
8924: ST_TO_ADDR
// if i_from > i_to then
8925: LD_VAR 0 2
8929: PUSH
8930: LD_VAR 0 3
8934: GREATER
8935: IFFALSE 8961
// length := ( array - i_from ) + i_to else
8937: LD_ADDR_VAR 0 11
8941: PUSH
8942: LD_VAR 0 1
8946: PUSH
8947: LD_VAR 0 2
8951: MINUS
8952: PUSH
8953: LD_VAR 0 3
8957: PLUS
8958: ST_TO_ADDR
8959: GO 8977
// length := i_to - i_from ;
8961: LD_ADDR_VAR 0 11
8965: PUSH
8966: LD_VAR 0 3
8970: PUSH
8971: LD_VAR 0 2
8975: MINUS
8976: ST_TO_ADDR
// end else
8977: GO 9040
// begin d := - 1 ;
8979: LD_ADDR_VAR 0 9
8983: PUSH
8984: LD_INT 1
8986: NEG
8987: ST_TO_ADDR
// if i_from > i_to then
8988: LD_VAR 0 2
8992: PUSH
8993: LD_VAR 0 3
8997: GREATER
8998: IFFALSE 9018
// length := i_from - i_to else
9000: LD_ADDR_VAR 0 11
9004: PUSH
9005: LD_VAR 0 2
9009: PUSH
9010: LD_VAR 0 3
9014: MINUS
9015: ST_TO_ADDR
9016: GO 9040
// length := ( array - i_to ) + i_from ;
9018: LD_ADDR_VAR 0 11
9022: PUSH
9023: LD_VAR 0 1
9027: PUSH
9028: LD_VAR 0 3
9032: MINUS
9033: PUSH
9034: LD_VAR 0 2
9038: PLUS
9039: ST_TO_ADDR
// end ; if not length then
9040: LD_VAR 0 11
9044: NOT
9045: IFFALSE 9049
// exit ;
9047: GO 9207
// tmp := array ;
9049: LD_ADDR_VAR 0 10
9053: PUSH
9054: LD_VAR 0 1
9058: ST_TO_ADDR
// for i = 1 to length do
9059: LD_ADDR_VAR 0 6
9063: PUSH
9064: DOUBLE
9065: LD_INT 1
9067: DEC
9068: ST_TO_ADDR
9069: LD_VAR 0 11
9073: PUSH
9074: FOR_TO
9075: IFFALSE 9195
// begin for j = 1 to array do
9077: LD_ADDR_VAR 0 7
9081: PUSH
9082: DOUBLE
9083: LD_INT 1
9085: DEC
9086: ST_TO_ADDR
9087: LD_VAR 0 1
9091: PUSH
9092: FOR_TO
9093: IFFALSE 9181
// begin k := j + d ;
9095: LD_ADDR_VAR 0 8
9099: PUSH
9100: LD_VAR 0 7
9104: PUSH
9105: LD_VAR 0 9
9109: PLUS
9110: ST_TO_ADDR
// if k > array then
9111: LD_VAR 0 8
9115: PUSH
9116: LD_VAR 0 1
9120: GREATER
9121: IFFALSE 9131
// k := 1 ;
9123: LD_ADDR_VAR 0 8
9127: PUSH
9128: LD_INT 1
9130: ST_TO_ADDR
// if not k then
9131: LD_VAR 0 8
9135: NOT
9136: IFFALSE 9148
// k := array ;
9138: LD_ADDR_VAR 0 8
9142: PUSH
9143: LD_VAR 0 1
9147: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
9148: LD_ADDR_VAR 0 10
9152: PUSH
9153: LD_VAR 0 10
9157: PPUSH
9158: LD_VAR 0 8
9162: PPUSH
9163: LD_VAR 0 1
9167: PUSH
9168: LD_VAR 0 7
9172: ARRAY
9173: PPUSH
9174: CALL_OW 1
9178: ST_TO_ADDR
// end ;
9179: GO 9092
9181: POP
9182: POP
// array := tmp ;
9183: LD_ADDR_VAR 0 1
9187: PUSH
9188: LD_VAR 0 10
9192: ST_TO_ADDR
// end ;
9193: GO 9074
9195: POP
9196: POP
// result := array ;
9197: LD_ADDR_VAR 0 5
9201: PUSH
9202: LD_VAR 0 1
9206: ST_TO_ADDR
// end ;
9207: LD_VAR 0 5
9211: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
9212: LD_INT 0
9214: PPUSH
9215: PPUSH
// result := 0 ;
9216: LD_ADDR_VAR 0 3
9220: PUSH
9221: LD_INT 0
9223: ST_TO_ADDR
// if not array or not value in array then
9224: LD_VAR 0 1
9228: NOT
9229: PUSH
9230: LD_VAR 0 2
9234: PUSH
9235: LD_VAR 0 1
9239: IN
9240: NOT
9241: OR
9242: IFFALSE 9246
// exit ;
9244: GO 9300
// for i = 1 to array do
9246: LD_ADDR_VAR 0 4
9250: PUSH
9251: DOUBLE
9252: LD_INT 1
9254: DEC
9255: ST_TO_ADDR
9256: LD_VAR 0 1
9260: PUSH
9261: FOR_TO
9262: IFFALSE 9298
// if value = array [ i ] then
9264: LD_VAR 0 2
9268: PUSH
9269: LD_VAR 0 1
9273: PUSH
9274: LD_VAR 0 4
9278: ARRAY
9279: EQUAL
9280: IFFALSE 9296
// begin result := i ;
9282: LD_ADDR_VAR 0 3
9286: PUSH
9287: LD_VAR 0 4
9291: ST_TO_ADDR
// exit ;
9292: POP
9293: POP
9294: GO 9300
// end ;
9296: GO 9261
9298: POP
9299: POP
// end ;
9300: LD_VAR 0 3
9304: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
9305: LD_INT 0
9307: PPUSH
// vc_chassis := chassis ;
9308: LD_ADDR_OWVAR 37
9312: PUSH
9313: LD_VAR 0 1
9317: ST_TO_ADDR
// vc_engine := engine ;
9318: LD_ADDR_OWVAR 39
9322: PUSH
9323: LD_VAR 0 2
9327: ST_TO_ADDR
// vc_control := control ;
9328: LD_ADDR_OWVAR 38
9332: PUSH
9333: LD_VAR 0 3
9337: ST_TO_ADDR
// vc_weapon := weapon ;
9338: LD_ADDR_OWVAR 40
9342: PUSH
9343: LD_VAR 0 4
9347: ST_TO_ADDR
// vc_fuel_battery := fuel ;
9348: LD_ADDR_OWVAR 41
9352: PUSH
9353: LD_VAR 0 5
9357: ST_TO_ADDR
// end ;
9358: LD_VAR 0 6
9362: RET
// export function WantPlant ( unit ) ; var task ; begin
9363: LD_INT 0
9365: PPUSH
9366: PPUSH
// result := false ;
9367: LD_ADDR_VAR 0 2
9371: PUSH
9372: LD_INT 0
9374: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
9375: LD_ADDR_VAR 0 3
9379: PUSH
9380: LD_VAR 0 1
9384: PPUSH
9385: CALL_OW 437
9389: ST_TO_ADDR
// if task then
9390: LD_VAR 0 3
9394: IFFALSE 9422
// if task [ 1 ] [ 1 ] = p then
9396: LD_VAR 0 3
9400: PUSH
9401: LD_INT 1
9403: ARRAY
9404: PUSH
9405: LD_INT 1
9407: ARRAY
9408: PUSH
9409: LD_STRING p
9411: EQUAL
9412: IFFALSE 9422
// result := true ;
9414: LD_ADDR_VAR 0 2
9418: PUSH
9419: LD_INT 1
9421: ST_TO_ADDR
// end ;
9422: LD_VAR 0 2
9426: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
9427: LD_INT 0
9429: PPUSH
9430: PPUSH
9431: PPUSH
9432: PPUSH
// if pos < 1 then
9433: LD_VAR 0 2
9437: PUSH
9438: LD_INT 1
9440: LESS
9441: IFFALSE 9445
// exit ;
9443: GO 9748
// if pos = 1 then
9445: LD_VAR 0 2
9449: PUSH
9450: LD_INT 1
9452: EQUAL
9453: IFFALSE 9486
// result := Replace ( arr , pos [ 1 ] , value ) else
9455: LD_ADDR_VAR 0 4
9459: PUSH
9460: LD_VAR 0 1
9464: PPUSH
9465: LD_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ARRAY
9473: PPUSH
9474: LD_VAR 0 3
9478: PPUSH
9479: CALL_OW 1
9483: ST_TO_ADDR
9484: GO 9748
// begin tmp := arr ;
9486: LD_ADDR_VAR 0 6
9490: PUSH
9491: LD_VAR 0 1
9495: ST_TO_ADDR
// s_arr := [ tmp ] ;
9496: LD_ADDR_VAR 0 7
9500: PUSH
9501: LD_VAR 0 6
9505: PUSH
9506: EMPTY
9507: LIST
9508: ST_TO_ADDR
// for i = 1 to pos - 1 do
9509: LD_ADDR_VAR 0 5
9513: PUSH
9514: DOUBLE
9515: LD_INT 1
9517: DEC
9518: ST_TO_ADDR
9519: LD_VAR 0 2
9523: PUSH
9524: LD_INT 1
9526: MINUS
9527: PUSH
9528: FOR_TO
9529: IFFALSE 9574
// begin tmp := tmp [ pos [ i ] ] ;
9531: LD_ADDR_VAR 0 6
9535: PUSH
9536: LD_VAR 0 6
9540: PUSH
9541: LD_VAR 0 2
9545: PUSH
9546: LD_VAR 0 5
9550: ARRAY
9551: ARRAY
9552: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
9553: LD_ADDR_VAR 0 7
9557: PUSH
9558: LD_VAR 0 7
9562: PUSH
9563: LD_VAR 0 6
9567: PUSH
9568: EMPTY
9569: LIST
9570: ADD
9571: ST_TO_ADDR
// end ;
9572: GO 9528
9574: POP
9575: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
9576: LD_ADDR_VAR 0 6
9580: PUSH
9581: LD_VAR 0 6
9585: PPUSH
9586: LD_VAR 0 2
9590: PUSH
9591: LD_VAR 0 2
9595: ARRAY
9596: PPUSH
9597: LD_VAR 0 3
9601: PPUSH
9602: CALL_OW 1
9606: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
9607: LD_ADDR_VAR 0 7
9611: PUSH
9612: LD_VAR 0 7
9616: PPUSH
9617: LD_VAR 0 7
9621: PPUSH
9622: LD_VAR 0 6
9626: PPUSH
9627: CALL_OW 1
9631: ST_TO_ADDR
// for i = s_arr downto 2 do
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: DOUBLE
9638: LD_VAR 0 7
9642: INC
9643: ST_TO_ADDR
9644: LD_INT 2
9646: PUSH
9647: FOR_DOWNTO
9648: IFFALSE 9732
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
9650: LD_ADDR_VAR 0 6
9654: PUSH
9655: LD_VAR 0 7
9659: PUSH
9660: LD_VAR 0 5
9664: PUSH
9665: LD_INT 1
9667: MINUS
9668: ARRAY
9669: PPUSH
9670: LD_VAR 0 2
9674: PUSH
9675: LD_VAR 0 5
9679: PUSH
9680: LD_INT 1
9682: MINUS
9683: ARRAY
9684: PPUSH
9685: LD_VAR 0 7
9689: PUSH
9690: LD_VAR 0 5
9694: ARRAY
9695: PPUSH
9696: CALL_OW 1
9700: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
9701: LD_ADDR_VAR 0 7
9705: PUSH
9706: LD_VAR 0 7
9710: PPUSH
9711: LD_VAR 0 5
9715: PUSH
9716: LD_INT 1
9718: MINUS
9719: PPUSH
9720: LD_VAR 0 6
9724: PPUSH
9725: CALL_OW 1
9729: ST_TO_ADDR
// end ;
9730: GO 9647
9732: POP
9733: POP
// result := s_arr [ 1 ] ;
9734: LD_ADDR_VAR 0 4
9738: PUSH
9739: LD_VAR 0 7
9743: PUSH
9744: LD_INT 1
9746: ARRAY
9747: ST_TO_ADDR
// end ; end ;
9748: LD_VAR 0 4
9752: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
9753: LD_INT 0
9755: PPUSH
9756: PPUSH
// if not list then
9757: LD_VAR 0 1
9761: NOT
9762: IFFALSE 9766
// exit ;
9764: GO 9857
// i := list [ pos1 ] ;
9766: LD_ADDR_VAR 0 5
9770: PUSH
9771: LD_VAR 0 1
9775: PUSH
9776: LD_VAR 0 2
9780: ARRAY
9781: ST_TO_ADDR
// if not i then
9782: LD_VAR 0 5
9786: NOT
9787: IFFALSE 9791
// exit ;
9789: GO 9857
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
9791: LD_ADDR_VAR 0 1
9795: PUSH
9796: LD_VAR 0 1
9800: PPUSH
9801: LD_VAR 0 2
9805: PPUSH
9806: LD_VAR 0 1
9810: PUSH
9811: LD_VAR 0 3
9815: ARRAY
9816: PPUSH
9817: CALL_OW 1
9821: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
9822: LD_ADDR_VAR 0 1
9826: PUSH
9827: LD_VAR 0 1
9831: PPUSH
9832: LD_VAR 0 3
9836: PPUSH
9837: LD_VAR 0 5
9841: PPUSH
9842: CALL_OW 1
9846: ST_TO_ADDR
// result := list ;
9847: LD_ADDR_VAR 0 4
9851: PUSH
9852: LD_VAR 0 1
9856: ST_TO_ADDR
// end ;
9857: LD_VAR 0 4
9861: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
9862: LD_INT 0
9864: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
9865: LD_ADDR_VAR 0 5
9869: PUSH
9870: LD_VAR 0 1
9874: PPUSH
9875: CALL_OW 250
9879: PPUSH
9880: LD_VAR 0 1
9884: PPUSH
9885: CALL_OW 251
9889: PPUSH
9890: LD_VAR 0 2
9894: PPUSH
9895: LD_VAR 0 3
9899: PPUSH
9900: LD_VAR 0 4
9904: PPUSH
9905: CALL 9915 0 5
9909: ST_TO_ADDR
// end ;
9910: LD_VAR 0 5
9914: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
9915: LD_INT 0
9917: PPUSH
9918: PPUSH
9919: PPUSH
9920: PPUSH
// if not list then
9921: LD_VAR 0 3
9925: NOT
9926: IFFALSE 9930
// exit ;
9928: GO 10318
// result := [ ] ;
9930: LD_ADDR_VAR 0 6
9934: PUSH
9935: EMPTY
9936: ST_TO_ADDR
// for i in list do
9937: LD_ADDR_VAR 0 7
9941: PUSH
9942: LD_VAR 0 3
9946: PUSH
9947: FOR_IN
9948: IFFALSE 10150
// begin tmp := GetDistUnitXY ( i , x , y ) ;
9950: LD_ADDR_VAR 0 9
9954: PUSH
9955: LD_VAR 0 7
9959: PPUSH
9960: LD_VAR 0 1
9964: PPUSH
9965: LD_VAR 0 2
9969: PPUSH
9970: CALL_OW 297
9974: ST_TO_ADDR
// if not result then
9975: LD_VAR 0 6
9979: NOT
9980: IFFALSE 10006
// result := [ [ i , tmp ] ] else
9982: LD_ADDR_VAR 0 6
9986: PUSH
9987: LD_VAR 0 7
9991: PUSH
9992: LD_VAR 0 9
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: ST_TO_ADDR
10004: GO 10148
// begin if result [ result ] [ 2 ] < tmp then
10006: LD_VAR 0 6
10010: PUSH
10011: LD_VAR 0 6
10015: ARRAY
10016: PUSH
10017: LD_INT 2
10019: ARRAY
10020: PUSH
10021: LD_VAR 0 9
10025: LESS
10026: IFFALSE 10068
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
10028: LD_ADDR_VAR 0 6
10032: PUSH
10033: LD_VAR 0 6
10037: PPUSH
10038: LD_VAR 0 6
10042: PUSH
10043: LD_INT 1
10045: PLUS
10046: PPUSH
10047: LD_VAR 0 7
10051: PUSH
10052: LD_VAR 0 9
10056: PUSH
10057: EMPTY
10058: LIST
10059: LIST
10060: PPUSH
10061: CALL_OW 2
10065: ST_TO_ADDR
10066: GO 10148
// for j = 1 to result do
10068: LD_ADDR_VAR 0 8
10072: PUSH
10073: DOUBLE
10074: LD_INT 1
10076: DEC
10077: ST_TO_ADDR
10078: LD_VAR 0 6
10082: PUSH
10083: FOR_TO
10084: IFFALSE 10146
// begin if tmp < result [ j ] [ 2 ] then
10086: LD_VAR 0 9
10090: PUSH
10091: LD_VAR 0 6
10095: PUSH
10096: LD_VAR 0 8
10100: ARRAY
10101: PUSH
10102: LD_INT 2
10104: ARRAY
10105: LESS
10106: IFFALSE 10144
// begin result := Insert ( result , j , [ i , tmp ] ) ;
10108: LD_ADDR_VAR 0 6
10112: PUSH
10113: LD_VAR 0 6
10117: PPUSH
10118: LD_VAR 0 8
10122: PPUSH
10123: LD_VAR 0 7
10127: PUSH
10128: LD_VAR 0 9
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: PPUSH
10137: CALL_OW 2
10141: ST_TO_ADDR
// break ;
10142: GO 10146
// end ; end ;
10144: GO 10083
10146: POP
10147: POP
// end ; end ;
10148: GO 9947
10150: POP
10151: POP
// if result and not asc then
10152: LD_VAR 0 6
10156: PUSH
10157: LD_VAR 0 4
10161: NOT
10162: AND
10163: IFFALSE 10238
// begin tmp := result ;
10165: LD_ADDR_VAR 0 9
10169: PUSH
10170: LD_VAR 0 6
10174: ST_TO_ADDR
// for i = tmp downto 1 do
10175: LD_ADDR_VAR 0 7
10179: PUSH
10180: DOUBLE
10181: LD_VAR 0 9
10185: INC
10186: ST_TO_ADDR
10187: LD_INT 1
10189: PUSH
10190: FOR_DOWNTO
10191: IFFALSE 10236
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
10193: LD_ADDR_VAR 0 6
10197: PUSH
10198: LD_VAR 0 6
10202: PPUSH
10203: LD_VAR 0 9
10207: PUSH
10208: LD_VAR 0 7
10212: MINUS
10213: PUSH
10214: LD_INT 1
10216: PLUS
10217: PPUSH
10218: LD_VAR 0 9
10222: PUSH
10223: LD_VAR 0 7
10227: ARRAY
10228: PPUSH
10229: CALL_OW 1
10233: ST_TO_ADDR
10234: GO 10190
10236: POP
10237: POP
// end ; tmp := [ ] ;
10238: LD_ADDR_VAR 0 9
10242: PUSH
10243: EMPTY
10244: ST_TO_ADDR
// if mode then
10245: LD_VAR 0 5
10249: IFFALSE 10318
// begin for i = 1 to result do
10251: LD_ADDR_VAR 0 7
10255: PUSH
10256: DOUBLE
10257: LD_INT 1
10259: DEC
10260: ST_TO_ADDR
10261: LD_VAR 0 6
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10306
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
10269: LD_ADDR_VAR 0 9
10273: PUSH
10274: LD_VAR 0 9
10278: PPUSH
10279: LD_VAR 0 7
10283: PPUSH
10284: LD_VAR 0 6
10288: PUSH
10289: LD_VAR 0 7
10293: ARRAY
10294: PUSH
10295: LD_INT 1
10297: ARRAY
10298: PPUSH
10299: CALL_OW 1
10303: ST_TO_ADDR
10304: GO 10266
10306: POP
10307: POP
// result := tmp ;
10308: LD_ADDR_VAR 0 6
10312: PUSH
10313: LD_VAR 0 9
10317: ST_TO_ADDR
// end ; end ;
10318: LD_VAR 0 6
10322: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
10323: LD_INT 0
10325: PPUSH
10326: PPUSH
10327: PPUSH
10328: PPUSH
10329: PPUSH
10330: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
10331: LD_ADDR_VAR 0 5
10335: PUSH
10336: LD_INT 0
10338: PUSH
10339: LD_INT 0
10341: PUSH
10342: LD_INT 0
10344: PUSH
10345: EMPTY
10346: PUSH
10347: EMPTY
10348: LIST
10349: LIST
10350: LIST
10351: LIST
10352: ST_TO_ADDR
// if not x or not y then
10353: LD_VAR 0 2
10357: NOT
10358: PUSH
10359: LD_VAR 0 3
10363: NOT
10364: OR
10365: IFFALSE 10369
// exit ;
10367: GO 12015
// if not range then
10369: LD_VAR 0 4
10373: NOT
10374: IFFALSE 10384
// range := 10 ;
10376: LD_ADDR_VAR 0 4
10380: PUSH
10381: LD_INT 10
10383: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10384: LD_ADDR_VAR 0 8
10388: PUSH
10389: LD_INT 81
10391: PUSH
10392: LD_VAR 0 1
10396: PUSH
10397: EMPTY
10398: LIST
10399: LIST
10400: PUSH
10401: LD_INT 92
10403: PUSH
10404: LD_VAR 0 2
10408: PUSH
10409: LD_VAR 0 3
10413: PUSH
10414: LD_VAR 0 4
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: LIST
10423: LIST
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 21
10430: PUSH
10431: LD_INT 3
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: PUSH
10438: EMPTY
10439: LIST
10440: LIST
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: LIST
10446: PPUSH
10447: CALL_OW 69
10451: ST_TO_ADDR
// if not tmp then
10452: LD_VAR 0 8
10456: NOT
10457: IFFALSE 10461
// exit ;
10459: GO 12015
// for i in tmp do
10461: LD_ADDR_VAR 0 6
10465: PUSH
10466: LD_VAR 0 8
10470: PUSH
10471: FOR_IN
10472: IFFALSE 11990
// begin points := [ 0 , 0 , 0 ] ;
10474: LD_ADDR_VAR 0 9
10478: PUSH
10479: LD_INT 0
10481: PUSH
10482: LD_INT 0
10484: PUSH
10485: LD_INT 0
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: ST_TO_ADDR
// bpoints := 1 ;
10493: LD_ADDR_VAR 0 10
10497: PUSH
10498: LD_INT 1
10500: ST_TO_ADDR
// case GetType ( i ) of unit_human :
10501: LD_VAR 0 6
10505: PPUSH
10506: CALL_OW 247
10510: PUSH
10511: LD_INT 1
10513: DOUBLE
10514: EQUAL
10515: IFTRUE 10519
10517: GO 11097
10519: POP
// begin if GetClass ( i ) = 1 then
10520: LD_VAR 0 6
10524: PPUSH
10525: CALL_OW 257
10529: PUSH
10530: LD_INT 1
10532: EQUAL
10533: IFFALSE 10554
// points := [ 10 , 5 , 3 ] ;
10535: LD_ADDR_VAR 0 9
10539: PUSH
10540: LD_INT 10
10542: PUSH
10543: LD_INT 5
10545: PUSH
10546: LD_INT 3
10548: PUSH
10549: EMPTY
10550: LIST
10551: LIST
10552: LIST
10553: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
10554: LD_VAR 0 6
10558: PPUSH
10559: CALL_OW 257
10563: PUSH
10564: LD_INT 2
10566: PUSH
10567: LD_INT 3
10569: PUSH
10570: LD_INT 4
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: LIST
10577: IN
10578: IFFALSE 10599
// points := [ 3 , 2 , 1 ] ;
10580: LD_ADDR_VAR 0 9
10584: PUSH
10585: LD_INT 3
10587: PUSH
10588: LD_INT 2
10590: PUSH
10591: LD_INT 1
10593: PUSH
10594: EMPTY
10595: LIST
10596: LIST
10597: LIST
10598: ST_TO_ADDR
// if GetClass ( i ) = 5 then
10599: LD_VAR 0 6
10603: PPUSH
10604: CALL_OW 257
10608: PUSH
10609: LD_INT 5
10611: EQUAL
10612: IFFALSE 10633
// points := [ 130 , 5 , 2 ] ;
10614: LD_ADDR_VAR 0 9
10618: PUSH
10619: LD_INT 130
10621: PUSH
10622: LD_INT 5
10624: PUSH
10625: LD_INT 2
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: LIST
10632: ST_TO_ADDR
// if GetClass ( i ) = 8 then
10633: LD_VAR 0 6
10637: PPUSH
10638: CALL_OW 257
10642: PUSH
10643: LD_INT 8
10645: EQUAL
10646: IFFALSE 10667
// points := [ 35 , 35 , 30 ] ;
10648: LD_ADDR_VAR 0 9
10652: PUSH
10653: LD_INT 35
10655: PUSH
10656: LD_INT 35
10658: PUSH
10659: LD_INT 30
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: LIST
10666: ST_TO_ADDR
// if GetClass ( i ) = 9 then
10667: LD_VAR 0 6
10671: PPUSH
10672: CALL_OW 257
10676: PUSH
10677: LD_INT 9
10679: EQUAL
10680: IFFALSE 10701
// points := [ 20 , 55 , 40 ] ;
10682: LD_ADDR_VAR 0 9
10686: PUSH
10687: LD_INT 20
10689: PUSH
10690: LD_INT 55
10692: PUSH
10693: LD_INT 40
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
10701: LD_VAR 0 6
10705: PPUSH
10706: CALL_OW 257
10710: PUSH
10711: LD_INT 12
10713: PUSH
10714: LD_INT 16
10716: PUSH
10717: EMPTY
10718: LIST
10719: LIST
10720: IN
10721: IFFALSE 10742
// points := [ 5 , 3 , 2 ] ;
10723: LD_ADDR_VAR 0 9
10727: PUSH
10728: LD_INT 5
10730: PUSH
10731: LD_INT 3
10733: PUSH
10734: LD_INT 2
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: LIST
10741: ST_TO_ADDR
// if GetClass ( i ) = 17 then
10742: LD_VAR 0 6
10746: PPUSH
10747: CALL_OW 257
10751: PUSH
10752: LD_INT 17
10754: EQUAL
10755: IFFALSE 10776
// points := [ 100 , 50 , 75 ] ;
10757: LD_ADDR_VAR 0 9
10761: PUSH
10762: LD_INT 100
10764: PUSH
10765: LD_INT 50
10767: PUSH
10768: LD_INT 75
10770: PUSH
10771: EMPTY
10772: LIST
10773: LIST
10774: LIST
10775: ST_TO_ADDR
// if GetClass ( i ) = 15 then
10776: LD_VAR 0 6
10780: PPUSH
10781: CALL_OW 257
10785: PUSH
10786: LD_INT 15
10788: EQUAL
10789: IFFALSE 10810
// points := [ 10 , 5 , 3 ] ;
10791: LD_ADDR_VAR 0 9
10795: PUSH
10796: LD_INT 10
10798: PUSH
10799: LD_INT 5
10801: PUSH
10802: LD_INT 3
10804: PUSH
10805: EMPTY
10806: LIST
10807: LIST
10808: LIST
10809: ST_TO_ADDR
// if GetClass ( i ) = 14 then
10810: LD_VAR 0 6
10814: PPUSH
10815: CALL_OW 257
10819: PUSH
10820: LD_INT 14
10822: EQUAL
10823: IFFALSE 10844
// points := [ 10 , 0 , 0 ] ;
10825: LD_ADDR_VAR 0 9
10829: PUSH
10830: LD_INT 10
10832: PUSH
10833: LD_INT 0
10835: PUSH
10836: LD_INT 0
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: LIST
10843: ST_TO_ADDR
// if GetClass ( i ) = 11 then
10844: LD_VAR 0 6
10848: PPUSH
10849: CALL_OW 257
10853: PUSH
10854: LD_INT 11
10856: EQUAL
10857: IFFALSE 10878
// points := [ 30 , 10 , 5 ] ;
10859: LD_ADDR_VAR 0 9
10863: PUSH
10864: LD_INT 30
10866: PUSH
10867: LD_INT 10
10869: PUSH
10870: LD_INT 5
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: LIST
10877: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
10878: LD_VAR 0 1
10882: PPUSH
10883: LD_INT 5
10885: PPUSH
10886: CALL_OW 321
10890: PUSH
10891: LD_INT 2
10893: EQUAL
10894: IFFALSE 10911
// bpoints := bpoints * 1.8 ;
10896: LD_ADDR_VAR 0 10
10900: PUSH
10901: LD_VAR 0 10
10905: PUSH
10906: LD_REAL  1.80000000000000E+0000
10909: MUL
10910: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
10911: LD_VAR 0 6
10915: PPUSH
10916: CALL_OW 257
10920: PUSH
10921: LD_INT 1
10923: PUSH
10924: LD_INT 2
10926: PUSH
10927: LD_INT 3
10929: PUSH
10930: LD_INT 4
10932: PUSH
10933: EMPTY
10934: LIST
10935: LIST
10936: LIST
10937: LIST
10938: IN
10939: PUSH
10940: LD_VAR 0 1
10944: PPUSH
10945: LD_INT 51
10947: PPUSH
10948: CALL_OW 321
10952: PUSH
10953: LD_INT 2
10955: EQUAL
10956: AND
10957: IFFALSE 10974
// bpoints := bpoints * 1.2 ;
10959: LD_ADDR_VAR 0 10
10963: PUSH
10964: LD_VAR 0 10
10968: PUSH
10969: LD_REAL  1.20000000000000E+0000
10972: MUL
10973: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
10974: LD_VAR 0 6
10978: PPUSH
10979: CALL_OW 257
10983: PUSH
10984: LD_INT 5
10986: PUSH
10987: LD_INT 7
10989: PUSH
10990: LD_INT 9
10992: PUSH
10993: EMPTY
10994: LIST
10995: LIST
10996: LIST
10997: IN
10998: PUSH
10999: LD_VAR 0 1
11003: PPUSH
11004: LD_INT 52
11006: PPUSH
11007: CALL_OW 321
11011: PUSH
11012: LD_INT 2
11014: EQUAL
11015: AND
11016: IFFALSE 11033
// bpoints := bpoints * 1.5 ;
11018: LD_ADDR_VAR 0 10
11022: PUSH
11023: LD_VAR 0 10
11027: PUSH
11028: LD_REAL  1.50000000000000E+0000
11031: MUL
11032: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
11033: LD_VAR 0 1
11037: PPUSH
11038: LD_INT 66
11040: PPUSH
11041: CALL_OW 321
11045: PUSH
11046: LD_INT 2
11048: EQUAL
11049: IFFALSE 11066
// bpoints := bpoints * 1.1 ;
11051: LD_ADDR_VAR 0 10
11055: PUSH
11056: LD_VAR 0 10
11060: PUSH
11061: LD_REAL  1.10000000000000E+0000
11064: MUL
11065: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
11066: LD_ADDR_VAR 0 10
11070: PUSH
11071: LD_VAR 0 10
11075: PUSH
11076: LD_VAR 0 6
11080: PPUSH
11081: LD_INT 1
11083: PPUSH
11084: CALL_OW 259
11088: PUSH
11089: LD_REAL  1.15000000000000E+0000
11092: MUL
11093: MUL
11094: ST_TO_ADDR
// end ; unit_vehicle :
11095: GO 11919
11097: LD_INT 2
11099: DOUBLE
11100: EQUAL
11101: IFTRUE 11105
11103: GO 11907
11105: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
11106: LD_VAR 0 6
11110: PPUSH
11111: CALL_OW 264
11115: PUSH
11116: LD_INT 2
11118: PUSH
11119: LD_INT 42
11121: PUSH
11122: LD_INT 24
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: IN
11130: IFFALSE 11151
// points := [ 25 , 5 , 3 ] ;
11132: LD_ADDR_VAR 0 9
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 5
11142: PUSH
11143: LD_INT 3
11145: PUSH
11146: EMPTY
11147: LIST
11148: LIST
11149: LIST
11150: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
11151: LD_VAR 0 6
11155: PPUSH
11156: CALL_OW 264
11160: PUSH
11161: LD_INT 4
11163: PUSH
11164: LD_INT 43
11166: PUSH
11167: LD_INT 25
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: IN
11175: IFFALSE 11196
// points := [ 40 , 15 , 5 ] ;
11177: LD_ADDR_VAR 0 9
11181: PUSH
11182: LD_INT 40
11184: PUSH
11185: LD_INT 15
11187: PUSH
11188: LD_INT 5
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: LIST
11195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
11196: LD_VAR 0 6
11200: PPUSH
11201: CALL_OW 264
11205: PUSH
11206: LD_INT 3
11208: PUSH
11209: LD_INT 23
11211: PUSH
11212: EMPTY
11213: LIST
11214: LIST
11215: IN
11216: IFFALSE 11237
// points := [ 7 , 25 , 8 ] ;
11218: LD_ADDR_VAR 0 9
11222: PUSH
11223: LD_INT 7
11225: PUSH
11226: LD_INT 25
11228: PUSH
11229: LD_INT 8
11231: PUSH
11232: EMPTY
11233: LIST
11234: LIST
11235: LIST
11236: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
11237: LD_VAR 0 6
11241: PPUSH
11242: CALL_OW 264
11246: PUSH
11247: LD_INT 5
11249: PUSH
11250: LD_INT 27
11252: PUSH
11253: LD_INT 44
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: LIST
11260: IN
11261: IFFALSE 11282
// points := [ 14 , 50 , 16 ] ;
11263: LD_ADDR_VAR 0 9
11267: PUSH
11268: LD_INT 14
11270: PUSH
11271: LD_INT 50
11273: PUSH
11274: LD_INT 16
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: LIST
11281: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
11282: LD_VAR 0 6
11286: PPUSH
11287: CALL_OW 264
11291: PUSH
11292: LD_INT 6
11294: PUSH
11295: LD_INT 46
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: IN
11302: IFFALSE 11323
// points := [ 32 , 120 , 70 ] ;
11304: LD_ADDR_VAR 0 9
11308: PUSH
11309: LD_INT 32
11311: PUSH
11312: LD_INT 120
11314: PUSH
11315: LD_INT 70
11317: PUSH
11318: EMPTY
11319: LIST
11320: LIST
11321: LIST
11322: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
11323: LD_VAR 0 6
11327: PPUSH
11328: CALL_OW 264
11332: PUSH
11333: LD_INT 7
11335: PUSH
11336: LD_INT 28
11338: PUSH
11339: LD_INT 45
11341: PUSH
11342: EMPTY
11343: LIST
11344: LIST
11345: LIST
11346: IN
11347: IFFALSE 11368
// points := [ 35 , 20 , 45 ] ;
11349: LD_ADDR_VAR 0 9
11353: PUSH
11354: LD_INT 35
11356: PUSH
11357: LD_INT 20
11359: PUSH
11360: LD_INT 45
11362: PUSH
11363: EMPTY
11364: LIST
11365: LIST
11366: LIST
11367: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
11368: LD_VAR 0 6
11372: PPUSH
11373: CALL_OW 264
11377: PUSH
11378: LD_INT 47
11380: PUSH
11381: EMPTY
11382: LIST
11383: IN
11384: IFFALSE 11405
// points := [ 67 , 45 , 75 ] ;
11386: LD_ADDR_VAR 0 9
11390: PUSH
11391: LD_INT 67
11393: PUSH
11394: LD_INT 45
11396: PUSH
11397: LD_INT 75
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
11405: LD_VAR 0 6
11409: PPUSH
11410: CALL_OW 264
11414: PUSH
11415: LD_INT 26
11417: PUSH
11418: EMPTY
11419: LIST
11420: IN
11421: IFFALSE 11442
// points := [ 120 , 30 , 80 ] ;
11423: LD_ADDR_VAR 0 9
11427: PUSH
11428: LD_INT 120
11430: PUSH
11431: LD_INT 30
11433: PUSH
11434: LD_INT 80
11436: PUSH
11437: EMPTY
11438: LIST
11439: LIST
11440: LIST
11441: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
11442: LD_VAR 0 6
11446: PPUSH
11447: CALL_OW 264
11451: PUSH
11452: LD_INT 22
11454: PUSH
11455: EMPTY
11456: LIST
11457: IN
11458: IFFALSE 11479
// points := [ 40 , 1 , 1 ] ;
11460: LD_ADDR_VAR 0 9
11464: PUSH
11465: LD_INT 40
11467: PUSH
11468: LD_INT 1
11470: PUSH
11471: LD_INT 1
11473: PUSH
11474: EMPTY
11475: LIST
11476: LIST
11477: LIST
11478: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
11479: LD_VAR 0 6
11483: PPUSH
11484: CALL_OW 264
11488: PUSH
11489: LD_INT 29
11491: PUSH
11492: EMPTY
11493: LIST
11494: IN
11495: IFFALSE 11516
// points := [ 70 , 200 , 400 ] ;
11497: LD_ADDR_VAR 0 9
11501: PUSH
11502: LD_INT 70
11504: PUSH
11505: LD_INT 200
11507: PUSH
11508: LD_INT 400
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: LIST
11515: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
11516: LD_VAR 0 6
11520: PPUSH
11521: CALL_OW 264
11525: PUSH
11526: LD_INT 14
11528: PUSH
11529: LD_INT 53
11531: PUSH
11532: EMPTY
11533: LIST
11534: LIST
11535: IN
11536: IFFALSE 11557
// points := [ 40 , 10 , 20 ] ;
11538: LD_ADDR_VAR 0 9
11542: PUSH
11543: LD_INT 40
11545: PUSH
11546: LD_INT 10
11548: PUSH
11549: LD_INT 20
11551: PUSH
11552: EMPTY
11553: LIST
11554: LIST
11555: LIST
11556: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
11557: LD_VAR 0 6
11561: PPUSH
11562: CALL_OW 264
11566: PUSH
11567: LD_INT 9
11569: PUSH
11570: EMPTY
11571: LIST
11572: IN
11573: IFFALSE 11594
// points := [ 5 , 70 , 20 ] ;
11575: LD_ADDR_VAR 0 9
11579: PUSH
11580: LD_INT 5
11582: PUSH
11583: LD_INT 70
11585: PUSH
11586: LD_INT 20
11588: PUSH
11589: EMPTY
11590: LIST
11591: LIST
11592: LIST
11593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
11594: LD_VAR 0 6
11598: PPUSH
11599: CALL_OW 264
11603: PUSH
11604: LD_INT 10
11606: PUSH
11607: EMPTY
11608: LIST
11609: IN
11610: IFFALSE 11631
// points := [ 35 , 110 , 70 ] ;
11612: LD_ADDR_VAR 0 9
11616: PUSH
11617: LD_INT 35
11619: PUSH
11620: LD_INT 110
11622: PUSH
11623: LD_INT 70
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: LIST
11630: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
11631: LD_VAR 0 6
11635: PPUSH
11636: CALL_OW 265
11640: PUSH
11641: LD_INT 25
11643: EQUAL
11644: IFFALSE 11665
// points := [ 80 , 65 , 100 ] ;
11646: LD_ADDR_VAR 0 9
11650: PUSH
11651: LD_INT 80
11653: PUSH
11654: LD_INT 65
11656: PUSH
11657: LD_INT 100
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
11665: LD_VAR 0 6
11669: PPUSH
11670: CALL_OW 263
11674: PUSH
11675: LD_INT 1
11677: EQUAL
11678: IFFALSE 11713
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
11680: LD_ADDR_VAR 0 10
11684: PUSH
11685: LD_VAR 0 10
11689: PUSH
11690: LD_VAR 0 6
11694: PPUSH
11695: CALL_OW 311
11699: PPUSH
11700: LD_INT 3
11702: PPUSH
11703: CALL_OW 259
11707: PUSH
11708: LD_INT 4
11710: MUL
11711: MUL
11712: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
11713: LD_VAR 0 6
11717: PPUSH
11718: CALL_OW 263
11722: PUSH
11723: LD_INT 2
11725: EQUAL
11726: IFFALSE 11777
// begin j := IsControledBy ( i ) ;
11728: LD_ADDR_VAR 0 7
11732: PUSH
11733: LD_VAR 0 6
11737: PPUSH
11738: CALL_OW 312
11742: ST_TO_ADDR
// if j then
11743: LD_VAR 0 7
11747: IFFALSE 11777
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
11749: LD_ADDR_VAR 0 10
11753: PUSH
11754: LD_VAR 0 10
11758: PUSH
11759: LD_VAR 0 7
11763: PPUSH
11764: LD_INT 3
11766: PPUSH
11767: CALL_OW 259
11771: PUSH
11772: LD_INT 3
11774: MUL
11775: MUL
11776: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
11777: LD_VAR 0 6
11781: PPUSH
11782: CALL_OW 264
11786: PUSH
11787: LD_INT 5
11789: PUSH
11790: LD_INT 6
11792: PUSH
11793: LD_INT 46
11795: PUSH
11796: LD_INT 44
11798: PUSH
11799: LD_INT 47
11801: PUSH
11802: LD_INT 45
11804: PUSH
11805: LD_INT 28
11807: PUSH
11808: LD_INT 7
11810: PUSH
11811: LD_INT 27
11813: PUSH
11814: LD_INT 29
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: IN
11829: PUSH
11830: LD_VAR 0 1
11834: PPUSH
11835: LD_INT 52
11837: PPUSH
11838: CALL_OW 321
11842: PUSH
11843: LD_INT 2
11845: EQUAL
11846: AND
11847: IFFALSE 11864
// bpoints := bpoints * 1.2 ;
11849: LD_ADDR_VAR 0 10
11853: PUSH
11854: LD_VAR 0 10
11858: PUSH
11859: LD_REAL  1.20000000000000E+0000
11862: MUL
11863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
11864: LD_VAR 0 6
11868: PPUSH
11869: CALL_OW 264
11873: PUSH
11874: LD_INT 6
11876: PUSH
11877: LD_INT 46
11879: PUSH
11880: LD_INT 47
11882: PUSH
11883: EMPTY
11884: LIST
11885: LIST
11886: LIST
11887: IN
11888: IFFALSE 11905
// bpoints := bpoints * 1.2 ;
11890: LD_ADDR_VAR 0 10
11894: PUSH
11895: LD_VAR 0 10
11899: PUSH
11900: LD_REAL  1.20000000000000E+0000
11903: MUL
11904: ST_TO_ADDR
// end ; unit_building :
11905: GO 11919
11907: LD_INT 3
11909: DOUBLE
11910: EQUAL
11911: IFTRUE 11915
11913: GO 11918
11915: POP
// ; end ;
11916: GO 11919
11918: POP
// for j = 1 to 3 do
11919: LD_ADDR_VAR 0 7
11923: PUSH
11924: DOUBLE
11925: LD_INT 1
11927: DEC
11928: ST_TO_ADDR
11929: LD_INT 3
11931: PUSH
11932: FOR_TO
11933: IFFALSE 11986
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
11935: LD_ADDR_VAR 0 5
11939: PUSH
11940: LD_VAR 0 5
11944: PPUSH
11945: LD_VAR 0 7
11949: PPUSH
11950: LD_VAR 0 5
11954: PUSH
11955: LD_VAR 0 7
11959: ARRAY
11960: PUSH
11961: LD_VAR 0 9
11965: PUSH
11966: LD_VAR 0 7
11970: ARRAY
11971: PUSH
11972: LD_VAR 0 10
11976: MUL
11977: PLUS
11978: PPUSH
11979: CALL_OW 1
11983: ST_TO_ADDR
11984: GO 11932
11986: POP
11987: POP
// end ;
11988: GO 10471
11990: POP
11991: POP
// result := Replace ( result , 4 , tmp ) ;
11992: LD_ADDR_VAR 0 5
11996: PUSH
11997: LD_VAR 0 5
12001: PPUSH
12002: LD_INT 4
12004: PPUSH
12005: LD_VAR 0 8
12009: PPUSH
12010: CALL_OW 1
12014: ST_TO_ADDR
// end ;
12015: LD_VAR 0 5
12019: RET
// export function DangerAtRange ( unit , range ) ; begin
12020: LD_INT 0
12022: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
12023: LD_ADDR_VAR 0 3
12027: PUSH
12028: LD_VAR 0 1
12032: PPUSH
12033: CALL_OW 255
12037: PPUSH
12038: LD_VAR 0 1
12042: PPUSH
12043: CALL_OW 250
12047: PPUSH
12048: LD_VAR 0 1
12052: PPUSH
12053: CALL_OW 251
12057: PPUSH
12058: LD_VAR 0 2
12062: PPUSH
12063: CALL 10323 0 4
12067: ST_TO_ADDR
// end ;
12068: LD_VAR 0 3
12072: RET
// export function DangerInArea ( side , area ) ; begin
12073: LD_INT 0
12075: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
12076: LD_ADDR_VAR 0 3
12080: PUSH
12081: LD_VAR 0 2
12085: PPUSH
12086: LD_INT 81
12088: PUSH
12089: LD_VAR 0 1
12093: PUSH
12094: EMPTY
12095: LIST
12096: LIST
12097: PPUSH
12098: CALL_OW 70
12102: ST_TO_ADDR
// end ;
12103: LD_VAR 0 3
12107: RET
// export function IsExtension ( b ) ; begin
12108: LD_INT 0
12110: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
12111: LD_ADDR_VAR 0 2
12115: PUSH
12116: LD_VAR 0 1
12120: PUSH
12121: LD_INT 23
12123: PUSH
12124: LD_INT 20
12126: PUSH
12127: LD_INT 22
12129: PUSH
12130: LD_INT 17
12132: PUSH
12133: LD_INT 24
12135: PUSH
12136: LD_INT 21
12138: PUSH
12139: LD_INT 19
12141: PUSH
12142: LD_INT 16
12144: PUSH
12145: LD_INT 25
12147: PUSH
12148: LD_INT 18
12150: PUSH
12151: EMPTY
12152: LIST
12153: LIST
12154: LIST
12155: LIST
12156: LIST
12157: LIST
12158: LIST
12159: LIST
12160: LIST
12161: LIST
12162: IN
12163: ST_TO_ADDR
// end ;
12164: LD_VAR 0 2
12168: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
12169: LD_INT 0
12171: PPUSH
12172: PPUSH
12173: PPUSH
// result := [ ] ;
12174: LD_ADDR_VAR 0 4
12178: PUSH
12179: EMPTY
12180: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
12181: LD_ADDR_VAR 0 5
12185: PUSH
12186: LD_VAR 0 2
12190: PPUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 70
12205: ST_TO_ADDR
// if not tmp then
12206: LD_VAR 0 5
12210: NOT
12211: IFFALSE 12215
// exit ;
12213: GO 12279
// if checkLink then
12215: LD_VAR 0 3
12219: IFFALSE 12269
// begin for i in tmp do
12221: LD_ADDR_VAR 0 6
12225: PUSH
12226: LD_VAR 0 5
12230: PUSH
12231: FOR_IN
12232: IFFALSE 12267
// if GetBase ( i ) <> base then
12234: LD_VAR 0 6
12238: PPUSH
12239: CALL_OW 274
12243: PUSH
12244: LD_VAR 0 1
12248: NONEQUAL
12249: IFFALSE 12265
// ComLinkToBase ( base , i ) ;
12251: LD_VAR 0 1
12255: PPUSH
12256: LD_VAR 0 6
12260: PPUSH
12261: CALL_OW 169
12265: GO 12231
12267: POP
12268: POP
// end ; result := tmp ;
12269: LD_ADDR_VAR 0 4
12273: PUSH
12274: LD_VAR 0 5
12278: ST_TO_ADDR
// end ;
12279: LD_VAR 0 4
12283: RET
// export function ComComplete ( units , b ) ; var i ; begin
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
// if not units then
12288: LD_VAR 0 1
12292: NOT
12293: IFFALSE 12297
// exit ;
12295: GO 12387
// for i in units do
12297: LD_ADDR_VAR 0 4
12301: PUSH
12302: LD_VAR 0 1
12306: PUSH
12307: FOR_IN
12308: IFFALSE 12385
// if BuildingStatus ( b ) = bs_build then
12310: LD_VAR 0 2
12314: PPUSH
12315: CALL_OW 461
12319: PUSH
12320: LD_INT 1
12322: EQUAL
12323: IFFALSE 12383
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
12325: LD_VAR 0 4
12329: PPUSH
12330: LD_STRING h
12332: PUSH
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 250
12342: PUSH
12343: LD_VAR 0 2
12347: PPUSH
12348: CALL_OW 251
12352: PUSH
12353: LD_VAR 0 2
12357: PUSH
12358: LD_INT 0
12360: PUSH
12361: LD_INT 0
12363: PUSH
12364: LD_INT 0
12366: PUSH
12367: EMPTY
12368: LIST
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: PUSH
12376: EMPTY
12377: LIST
12378: PPUSH
12379: CALL_OW 446
12383: GO 12307
12385: POP
12386: POP
// end ;
12387: LD_VAR 0 3
12391: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
12392: LD_INT 0
12394: PPUSH
12395: PPUSH
12396: PPUSH
12397: PPUSH
12398: PPUSH
12399: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
12400: LD_VAR 0 1
12404: NOT
12405: PUSH
12406: LD_VAR 0 1
12410: PPUSH
12411: CALL_OW 263
12415: PUSH
12416: LD_INT 2
12418: EQUAL
12419: NOT
12420: OR
12421: IFFALSE 12425
// exit ;
12423: GO 12741
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
12425: LD_ADDR_VAR 0 6
12429: PUSH
12430: LD_INT 22
12432: PUSH
12433: LD_VAR 0 1
12437: PPUSH
12438: CALL_OW 255
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 2
12449: PUSH
12450: LD_INT 30
12452: PUSH
12453: LD_INT 36
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 34
12462: PUSH
12463: LD_INT 31
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: EMPTY
12471: LIST
12472: LIST
12473: LIST
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: PPUSH
12479: CALL_OW 69
12483: ST_TO_ADDR
// if not tmp then
12484: LD_VAR 0 6
12488: NOT
12489: IFFALSE 12493
// exit ;
12491: GO 12741
// result := [ ] ;
12493: LD_ADDR_VAR 0 2
12497: PUSH
12498: EMPTY
12499: ST_TO_ADDR
// for i in tmp do
12500: LD_ADDR_VAR 0 3
12504: PUSH
12505: LD_VAR 0 6
12509: PUSH
12510: FOR_IN
12511: IFFALSE 12582
// begin t := UnitsInside ( i ) ;
12513: LD_ADDR_VAR 0 4
12517: PUSH
12518: LD_VAR 0 3
12522: PPUSH
12523: CALL_OW 313
12527: ST_TO_ADDR
// if t then
12528: LD_VAR 0 4
12532: IFFALSE 12580
// for j in t do
12534: LD_ADDR_VAR 0 7
12538: PUSH
12539: LD_VAR 0 4
12543: PUSH
12544: FOR_IN
12545: IFFALSE 12578
// result := Insert ( result , result + 1 , j ) ;
12547: LD_ADDR_VAR 0 2
12551: PUSH
12552: LD_VAR 0 2
12556: PPUSH
12557: LD_VAR 0 2
12561: PUSH
12562: LD_INT 1
12564: PLUS
12565: PPUSH
12566: LD_VAR 0 7
12570: PPUSH
12571: CALL_OW 2
12575: ST_TO_ADDR
12576: GO 12544
12578: POP
12579: POP
// end ;
12580: GO 12510
12582: POP
12583: POP
// if not result then
12584: LD_VAR 0 2
12588: NOT
12589: IFFALSE 12593
// exit ;
12591: GO 12741
// mech := result [ 1 ] ;
12593: LD_ADDR_VAR 0 5
12597: PUSH
12598: LD_VAR 0 2
12602: PUSH
12603: LD_INT 1
12605: ARRAY
12606: ST_TO_ADDR
// if result > 1 then
12607: LD_VAR 0 2
12611: PUSH
12612: LD_INT 1
12614: GREATER
12615: IFFALSE 12727
// for i = 2 to result do
12617: LD_ADDR_VAR 0 3
12621: PUSH
12622: DOUBLE
12623: LD_INT 2
12625: DEC
12626: ST_TO_ADDR
12627: LD_VAR 0 2
12631: PUSH
12632: FOR_TO
12633: IFFALSE 12725
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
12635: LD_ADDR_VAR 0 4
12639: PUSH
12640: LD_VAR 0 2
12644: PUSH
12645: LD_VAR 0 3
12649: ARRAY
12650: PPUSH
12651: LD_INT 3
12653: PPUSH
12654: CALL_OW 259
12658: PUSH
12659: LD_VAR 0 2
12663: PUSH
12664: LD_VAR 0 3
12668: ARRAY
12669: PPUSH
12670: CALL_OW 432
12674: MINUS
12675: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
12676: LD_VAR 0 4
12680: PUSH
12681: LD_VAR 0 5
12685: PPUSH
12686: LD_INT 3
12688: PPUSH
12689: CALL_OW 259
12693: PUSH
12694: LD_VAR 0 5
12698: PPUSH
12699: CALL_OW 432
12703: MINUS
12704: GREATEREQUAL
12705: IFFALSE 12723
// mech := result [ i ] ;
12707: LD_ADDR_VAR 0 5
12711: PUSH
12712: LD_VAR 0 2
12716: PUSH
12717: LD_VAR 0 3
12721: ARRAY
12722: ST_TO_ADDR
// end ;
12723: GO 12632
12725: POP
12726: POP
// ComLinkTo ( vehicle , mech ) ;
12727: LD_VAR 0 1
12731: PPUSH
12732: LD_VAR 0 5
12736: PPUSH
12737: CALL_OW 135
// end ;
12741: LD_VAR 0 2
12745: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
12746: LD_INT 0
12748: PPUSH
12749: PPUSH
12750: PPUSH
12751: PPUSH
12752: PPUSH
12753: PPUSH
12754: PPUSH
12755: PPUSH
12756: PPUSH
12757: PPUSH
12758: PPUSH
12759: PPUSH
12760: PPUSH
// result := [ ] ;
12761: LD_ADDR_VAR 0 7
12765: PUSH
12766: EMPTY
12767: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
12768: LD_VAR 0 1
12772: PPUSH
12773: CALL_OW 266
12777: PUSH
12778: LD_INT 0
12780: PUSH
12781: LD_INT 1
12783: PUSH
12784: EMPTY
12785: LIST
12786: LIST
12787: IN
12788: NOT
12789: IFFALSE 12793
// exit ;
12791: GO 14427
// if name then
12793: LD_VAR 0 3
12797: IFFALSE 12813
// SetBName ( base_dep , name ) ;
12799: LD_VAR 0 1
12803: PPUSH
12804: LD_VAR 0 3
12808: PPUSH
12809: CALL_OW 500
// base := GetBase ( base_dep ) ;
12813: LD_ADDR_VAR 0 15
12817: PUSH
12818: LD_VAR 0 1
12822: PPUSH
12823: CALL_OW 274
12827: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
12828: LD_ADDR_VAR 0 16
12832: PUSH
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 255
12842: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
12843: LD_ADDR_VAR 0 17
12847: PUSH
12848: LD_VAR 0 1
12852: PPUSH
12853: CALL_OW 248
12857: ST_TO_ADDR
// if sources then
12858: LD_VAR 0 5
12862: IFFALSE 12909
// for i = 1 to 3 do
12864: LD_ADDR_VAR 0 8
12868: PUSH
12869: DOUBLE
12870: LD_INT 1
12872: DEC
12873: ST_TO_ADDR
12874: LD_INT 3
12876: PUSH
12877: FOR_TO
12878: IFFALSE 12907
// AddResourceType ( base , i , sources [ i ] ) ;
12880: LD_VAR 0 15
12884: PPUSH
12885: LD_VAR 0 8
12889: PPUSH
12890: LD_VAR 0 5
12894: PUSH
12895: LD_VAR 0 8
12899: ARRAY
12900: PPUSH
12901: CALL_OW 276
12905: GO 12877
12907: POP
12908: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
12909: LD_ADDR_VAR 0 18
12913: PUSH
12914: LD_VAR 0 15
12918: PPUSH
12919: LD_VAR 0 2
12923: PPUSH
12924: LD_INT 1
12926: PPUSH
12927: CALL 12169 0 3
12931: ST_TO_ADDR
// InitHc ;
12932: CALL_OW 19
// InitUc ;
12936: CALL_OW 18
// uc_side := side ;
12940: LD_ADDR_OWVAR 20
12944: PUSH
12945: LD_VAR 0 16
12949: ST_TO_ADDR
// uc_nation := nation ;
12950: LD_ADDR_OWVAR 21
12954: PUSH
12955: LD_VAR 0 17
12959: ST_TO_ADDR
// if buildings then
12960: LD_VAR 0 18
12964: IFFALSE 14286
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
12966: LD_ADDR_VAR 0 19
12970: PUSH
12971: LD_VAR 0 18
12975: PPUSH
12976: LD_INT 2
12978: PUSH
12979: LD_INT 30
12981: PUSH
12982: LD_INT 29
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: PUSH
12989: LD_INT 30
12991: PUSH
12992: LD_INT 30
12994: PUSH
12995: EMPTY
12996: LIST
12997: LIST
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: LIST
13003: PPUSH
13004: CALL_OW 72
13008: ST_TO_ADDR
// if tmp then
13009: LD_VAR 0 19
13013: IFFALSE 13061
// for i in tmp do
13015: LD_ADDR_VAR 0 8
13019: PUSH
13020: LD_VAR 0 19
13024: PUSH
13025: FOR_IN
13026: IFFALSE 13059
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
13028: LD_VAR 0 8
13032: PPUSH
13033: CALL_OW 250
13037: PPUSH
13038: LD_VAR 0 8
13042: PPUSH
13043: CALL_OW 251
13047: PPUSH
13048: LD_VAR 0 16
13052: PPUSH
13053: CALL_OW 441
13057: GO 13025
13059: POP
13060: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
13061: LD_VAR 0 18
13065: PPUSH
13066: LD_INT 2
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 32
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: LD_INT 30
13081: PUSH
13082: LD_INT 33
13084: PUSH
13085: EMPTY
13086: LIST
13087: LIST
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: LIST
13093: PPUSH
13094: CALL_OW 72
13098: IFFALSE 13186
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
13100: LD_ADDR_VAR 0 8
13104: PUSH
13105: LD_VAR 0 18
13109: PPUSH
13110: LD_INT 2
13112: PUSH
13113: LD_INT 30
13115: PUSH
13116: LD_INT 32
13118: PUSH
13119: EMPTY
13120: LIST
13121: LIST
13122: PUSH
13123: LD_INT 30
13125: PUSH
13126: LD_INT 33
13128: PUSH
13129: EMPTY
13130: LIST
13131: LIST
13132: PUSH
13133: EMPTY
13134: LIST
13135: LIST
13136: LIST
13137: PPUSH
13138: CALL_OW 72
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13184
// begin if not GetBWeapon ( i ) then
13146: LD_VAR 0 8
13150: PPUSH
13151: CALL_OW 269
13155: NOT
13156: IFFALSE 13182
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
13158: LD_VAR 0 8
13162: PPUSH
13163: LD_VAR 0 8
13167: PPUSH
13168: LD_VAR 0 2
13172: PPUSH
13173: CALL 14432 0 2
13177: PPUSH
13178: CALL_OW 431
// end ;
13182: GO 13143
13184: POP
13185: POP
// end ; for i = 1 to personel do
13186: LD_ADDR_VAR 0 8
13190: PUSH
13191: DOUBLE
13192: LD_INT 1
13194: DEC
13195: ST_TO_ADDR
13196: LD_VAR 0 6
13200: PUSH
13201: FOR_TO
13202: IFFALSE 14266
// begin if i > 4 then
13204: LD_VAR 0 8
13208: PUSH
13209: LD_INT 4
13211: GREATER
13212: IFFALSE 13216
// break ;
13214: GO 14266
// case i of 1 :
13216: LD_VAR 0 8
13220: PUSH
13221: LD_INT 1
13223: DOUBLE
13224: EQUAL
13225: IFTRUE 13229
13227: GO 13309
13229: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
13230: LD_ADDR_VAR 0 12
13234: PUSH
13235: LD_VAR 0 18
13239: PPUSH
13240: LD_INT 22
13242: PUSH
13243: LD_VAR 0 16
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: LD_INT 58
13254: PUSH
13255: EMPTY
13256: LIST
13257: PUSH
13258: LD_INT 2
13260: PUSH
13261: LD_INT 30
13263: PUSH
13264: LD_INT 32
13266: PUSH
13267: EMPTY
13268: LIST
13269: LIST
13270: PUSH
13271: LD_INT 30
13273: PUSH
13274: LD_INT 4
13276: PUSH
13277: EMPTY
13278: LIST
13279: LIST
13280: PUSH
13281: LD_INT 30
13283: PUSH
13284: LD_INT 5
13286: PUSH
13287: EMPTY
13288: LIST
13289: LIST
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: EMPTY
13298: LIST
13299: LIST
13300: LIST
13301: PPUSH
13302: CALL_OW 72
13306: ST_TO_ADDR
13307: GO 13531
13309: LD_INT 2
13311: DOUBLE
13312: EQUAL
13313: IFTRUE 13317
13315: GO 13379
13317: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
13318: LD_ADDR_VAR 0 12
13322: PUSH
13323: LD_VAR 0 18
13327: PPUSH
13328: LD_INT 22
13330: PUSH
13331: LD_VAR 0 16
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: LD_INT 30
13345: PUSH
13346: LD_INT 0
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PUSH
13353: LD_INT 30
13355: PUSH
13356: LD_INT 1
13358: PUSH
13359: EMPTY
13360: LIST
13361: LIST
13362: PUSH
13363: EMPTY
13364: LIST
13365: LIST
13366: LIST
13367: PUSH
13368: EMPTY
13369: LIST
13370: LIST
13371: PPUSH
13372: CALL_OW 72
13376: ST_TO_ADDR
13377: GO 13531
13379: LD_INT 3
13381: DOUBLE
13382: EQUAL
13383: IFTRUE 13387
13385: GO 13449
13387: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
13388: LD_ADDR_VAR 0 12
13392: PUSH
13393: LD_VAR 0 18
13397: PPUSH
13398: LD_INT 22
13400: PUSH
13401: LD_VAR 0 16
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: LD_INT 2
13412: PUSH
13413: LD_INT 30
13415: PUSH
13416: LD_INT 2
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: PUSH
13423: LD_INT 30
13425: PUSH
13426: LD_INT 3
13428: PUSH
13429: EMPTY
13430: LIST
13431: LIST
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PPUSH
13442: CALL_OW 72
13446: ST_TO_ADDR
13447: GO 13531
13449: LD_INT 4
13451: DOUBLE
13452: EQUAL
13453: IFTRUE 13457
13455: GO 13530
13457: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
13458: LD_ADDR_VAR 0 12
13462: PUSH
13463: LD_VAR 0 18
13467: PPUSH
13468: LD_INT 22
13470: PUSH
13471: LD_VAR 0 16
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 2
13482: PUSH
13483: LD_INT 30
13485: PUSH
13486: LD_INT 6
13488: PUSH
13489: EMPTY
13490: LIST
13491: LIST
13492: PUSH
13493: LD_INT 30
13495: PUSH
13496: LD_INT 7
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: PUSH
13503: LD_INT 30
13505: PUSH
13506: LD_INT 8
13508: PUSH
13509: EMPTY
13510: LIST
13511: LIST
13512: PUSH
13513: EMPTY
13514: LIST
13515: LIST
13516: LIST
13517: LIST
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PPUSH
13523: CALL_OW 72
13527: ST_TO_ADDR
13528: GO 13531
13530: POP
// if i = 1 then
13531: LD_VAR 0 8
13535: PUSH
13536: LD_INT 1
13538: EQUAL
13539: IFFALSE 13650
// begin tmp := [ ] ;
13541: LD_ADDR_VAR 0 19
13545: PUSH
13546: EMPTY
13547: ST_TO_ADDR
// for j in f do
13548: LD_ADDR_VAR 0 9
13552: PUSH
13553: LD_VAR 0 12
13557: PUSH
13558: FOR_IN
13559: IFFALSE 13632
// if GetBType ( j ) = b_bunker then
13561: LD_VAR 0 9
13565: PPUSH
13566: CALL_OW 266
13570: PUSH
13571: LD_INT 32
13573: EQUAL
13574: IFFALSE 13601
// tmp := Insert ( tmp , 1 , j ) else
13576: LD_ADDR_VAR 0 19
13580: PUSH
13581: LD_VAR 0 19
13585: PPUSH
13586: LD_INT 1
13588: PPUSH
13589: LD_VAR 0 9
13593: PPUSH
13594: CALL_OW 2
13598: ST_TO_ADDR
13599: GO 13630
// tmp := Insert ( tmp , tmp + 1 , j ) ;
13601: LD_ADDR_VAR 0 19
13605: PUSH
13606: LD_VAR 0 19
13610: PPUSH
13611: LD_VAR 0 19
13615: PUSH
13616: LD_INT 1
13618: PLUS
13619: PPUSH
13620: LD_VAR 0 9
13624: PPUSH
13625: CALL_OW 2
13629: ST_TO_ADDR
13630: GO 13558
13632: POP
13633: POP
// if tmp then
13634: LD_VAR 0 19
13638: IFFALSE 13650
// f := tmp ;
13640: LD_ADDR_VAR 0 12
13644: PUSH
13645: LD_VAR 0 19
13649: ST_TO_ADDR
// end ; x := personel [ i ] ;
13650: LD_ADDR_VAR 0 13
13654: PUSH
13655: LD_VAR 0 6
13659: PUSH
13660: LD_VAR 0 8
13664: ARRAY
13665: ST_TO_ADDR
// if x = - 1 then
13666: LD_VAR 0 13
13670: PUSH
13671: LD_INT 1
13673: NEG
13674: EQUAL
13675: IFFALSE 13884
// begin for j in f do
13677: LD_ADDR_VAR 0 9
13681: PUSH
13682: LD_VAR 0 12
13686: PUSH
13687: FOR_IN
13688: IFFALSE 13880
// repeat InitHc ;
13690: CALL_OW 19
// if GetBType ( j ) = b_barracks then
13694: LD_VAR 0 9
13698: PPUSH
13699: CALL_OW 266
13703: PUSH
13704: LD_INT 5
13706: EQUAL
13707: IFFALSE 13777
// begin if UnitsInside ( j ) < 3 then
13709: LD_VAR 0 9
13713: PPUSH
13714: CALL_OW 313
13718: PUSH
13719: LD_INT 3
13721: LESS
13722: IFFALSE 13758
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
13724: LD_INT 0
13726: PPUSH
13727: LD_INT 5
13729: PUSH
13730: LD_INT 8
13732: PUSH
13733: LD_INT 9
13735: PUSH
13736: EMPTY
13737: LIST
13738: LIST
13739: LIST
13740: PUSH
13741: LD_VAR 0 17
13745: ARRAY
13746: PPUSH
13747: LD_VAR 0 4
13751: PPUSH
13752: CALL_OW 380
13756: GO 13775
// PrepareHuman ( false , i , skill ) ;
13758: LD_INT 0
13760: PPUSH
13761: LD_VAR 0 8
13765: PPUSH
13766: LD_VAR 0 4
13770: PPUSH
13771: CALL_OW 380
// end else
13775: GO 13794
// PrepareHuman ( false , i , skill ) ;
13777: LD_INT 0
13779: PPUSH
13780: LD_VAR 0 8
13784: PPUSH
13785: LD_VAR 0 4
13789: PPUSH
13790: CALL_OW 380
// un := CreateHuman ;
13794: LD_ADDR_VAR 0 14
13798: PUSH
13799: CALL_OW 44
13803: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13804: LD_ADDR_VAR 0 7
13808: PUSH
13809: LD_VAR 0 7
13813: PPUSH
13814: LD_INT 1
13816: PPUSH
13817: LD_VAR 0 14
13821: PPUSH
13822: CALL_OW 2
13826: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
13827: LD_VAR 0 14
13831: PPUSH
13832: LD_VAR 0 9
13836: PPUSH
13837: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
13841: LD_VAR 0 9
13845: PPUSH
13846: CALL_OW 313
13850: PUSH
13851: LD_INT 6
13853: EQUAL
13854: PUSH
13855: LD_VAR 0 9
13859: PPUSH
13860: CALL_OW 266
13864: PUSH
13865: LD_INT 32
13867: PUSH
13868: LD_INT 31
13870: PUSH
13871: EMPTY
13872: LIST
13873: LIST
13874: IN
13875: OR
13876: IFFALSE 13690
13878: GO 13687
13880: POP
13881: POP
// end else
13882: GO 14264
// for j = 1 to x do
13884: LD_ADDR_VAR 0 9
13888: PUSH
13889: DOUBLE
13890: LD_INT 1
13892: DEC
13893: ST_TO_ADDR
13894: LD_VAR 0 13
13898: PUSH
13899: FOR_TO
13900: IFFALSE 14262
// begin InitHc ;
13902: CALL_OW 19
// if not f then
13906: LD_VAR 0 12
13910: NOT
13911: IFFALSE 14000
// begin PrepareHuman ( false , i , skill ) ;
13913: LD_INT 0
13915: PPUSH
13916: LD_VAR 0 8
13920: PPUSH
13921: LD_VAR 0 4
13925: PPUSH
13926: CALL_OW 380
// un := CreateHuman ;
13930: LD_ADDR_VAR 0 14
13934: PUSH
13935: CALL_OW 44
13939: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
13940: LD_ADDR_VAR 0 7
13944: PUSH
13945: LD_VAR 0 7
13949: PPUSH
13950: LD_INT 1
13952: PPUSH
13953: LD_VAR 0 14
13957: PPUSH
13958: CALL_OW 2
13962: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
13963: LD_VAR 0 14
13967: PPUSH
13968: LD_VAR 0 1
13972: PPUSH
13973: CALL_OW 250
13977: PPUSH
13978: LD_VAR 0 1
13982: PPUSH
13983: CALL_OW 251
13987: PPUSH
13988: LD_INT 10
13990: PPUSH
13991: LD_INT 0
13993: PPUSH
13994: CALL_OW 50
// continue ;
13998: GO 13899
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
14000: LD_VAR 0 12
14004: PUSH
14005: LD_INT 1
14007: ARRAY
14008: PPUSH
14009: CALL_OW 313
14013: PUSH
14014: LD_VAR 0 12
14018: PUSH
14019: LD_INT 1
14021: ARRAY
14022: PPUSH
14023: CALL_OW 266
14027: PUSH
14028: LD_INT 32
14030: PUSH
14031: LD_INT 31
14033: PUSH
14034: EMPTY
14035: LIST
14036: LIST
14037: IN
14038: AND
14039: PUSH
14040: LD_VAR 0 12
14044: PUSH
14045: LD_INT 1
14047: ARRAY
14048: PPUSH
14049: CALL_OW 313
14053: PUSH
14054: LD_INT 6
14056: EQUAL
14057: OR
14058: IFFALSE 14078
// f := Delete ( f , 1 ) ;
14060: LD_ADDR_VAR 0 12
14064: PUSH
14065: LD_VAR 0 12
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 3
14077: ST_TO_ADDR
// if not f then
14078: LD_VAR 0 12
14082: NOT
14083: IFFALSE 14101
// begin x := x + 2 ;
14085: LD_ADDR_VAR 0 13
14089: PUSH
14090: LD_VAR 0 13
14094: PUSH
14095: LD_INT 2
14097: PLUS
14098: ST_TO_ADDR
// continue ;
14099: GO 13899
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
14101: LD_VAR 0 12
14105: PUSH
14106: LD_INT 1
14108: ARRAY
14109: PPUSH
14110: CALL_OW 266
14114: PUSH
14115: LD_INT 5
14117: EQUAL
14118: IFFALSE 14192
// begin if UnitsInside ( f [ 1 ] ) < 3 then
14120: LD_VAR 0 12
14124: PUSH
14125: LD_INT 1
14127: ARRAY
14128: PPUSH
14129: CALL_OW 313
14133: PUSH
14134: LD_INT 3
14136: LESS
14137: IFFALSE 14173
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
14139: LD_INT 0
14141: PPUSH
14142: LD_INT 5
14144: PUSH
14145: LD_INT 8
14147: PUSH
14148: LD_INT 9
14150: PUSH
14151: EMPTY
14152: LIST
14153: LIST
14154: LIST
14155: PUSH
14156: LD_VAR 0 17
14160: ARRAY
14161: PPUSH
14162: LD_VAR 0 4
14166: PPUSH
14167: CALL_OW 380
14171: GO 14190
// PrepareHuman ( false , i , skill ) ;
14173: LD_INT 0
14175: PPUSH
14176: LD_VAR 0 8
14180: PPUSH
14181: LD_VAR 0 4
14185: PPUSH
14186: CALL_OW 380
// end else
14190: GO 14209
// PrepareHuman ( false , i , skill ) ;
14192: LD_INT 0
14194: PPUSH
14195: LD_VAR 0 8
14199: PPUSH
14200: LD_VAR 0 4
14204: PPUSH
14205: CALL_OW 380
// un := CreateHuman ;
14209: LD_ADDR_VAR 0 14
14213: PUSH
14214: CALL_OW 44
14218: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
14219: LD_ADDR_VAR 0 7
14223: PUSH
14224: LD_VAR 0 7
14228: PPUSH
14229: LD_INT 1
14231: PPUSH
14232: LD_VAR 0 14
14236: PPUSH
14237: CALL_OW 2
14241: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
14242: LD_VAR 0 14
14246: PPUSH
14247: LD_VAR 0 12
14251: PUSH
14252: LD_INT 1
14254: ARRAY
14255: PPUSH
14256: CALL_OW 52
// end ;
14260: GO 13899
14262: POP
14263: POP
// end ;
14264: GO 13201
14266: POP
14267: POP
// result := result ^ buildings ;
14268: LD_ADDR_VAR 0 7
14272: PUSH
14273: LD_VAR 0 7
14277: PUSH
14278: LD_VAR 0 18
14282: ADD
14283: ST_TO_ADDR
// end else
14284: GO 14427
// begin for i = 1 to personel do
14286: LD_ADDR_VAR 0 8
14290: PUSH
14291: DOUBLE
14292: LD_INT 1
14294: DEC
14295: ST_TO_ADDR
14296: LD_VAR 0 6
14300: PUSH
14301: FOR_TO
14302: IFFALSE 14425
// begin if i > 4 then
14304: LD_VAR 0 8
14308: PUSH
14309: LD_INT 4
14311: GREATER
14312: IFFALSE 14316
// break ;
14314: GO 14425
// x := personel [ i ] ;
14316: LD_ADDR_VAR 0 13
14320: PUSH
14321: LD_VAR 0 6
14325: PUSH
14326: LD_VAR 0 8
14330: ARRAY
14331: ST_TO_ADDR
// if x = - 1 then
14332: LD_VAR 0 13
14336: PUSH
14337: LD_INT 1
14339: NEG
14340: EQUAL
14341: IFFALSE 14345
// continue ;
14343: GO 14301
// PrepareHuman ( false , i , skill ) ;
14345: LD_INT 0
14347: PPUSH
14348: LD_VAR 0 8
14352: PPUSH
14353: LD_VAR 0 4
14357: PPUSH
14358: CALL_OW 380
// un := CreateHuman ;
14362: LD_ADDR_VAR 0 14
14366: PUSH
14367: CALL_OW 44
14371: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
14372: LD_VAR 0 14
14376: PPUSH
14377: LD_VAR 0 1
14381: PPUSH
14382: CALL_OW 250
14386: PPUSH
14387: LD_VAR 0 1
14391: PPUSH
14392: CALL_OW 251
14396: PPUSH
14397: LD_INT 10
14399: PPUSH
14400: LD_INT 0
14402: PPUSH
14403: CALL_OW 50
// result := result ^ un ;
14407: LD_ADDR_VAR 0 7
14411: PUSH
14412: LD_VAR 0 7
14416: PUSH
14417: LD_VAR 0 14
14421: ADD
14422: ST_TO_ADDR
// end ;
14423: GO 14301
14425: POP
14426: POP
// end ; end ;
14427: LD_VAR 0 7
14431: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
14432: LD_INT 0
14434: PPUSH
14435: PPUSH
14436: PPUSH
14437: PPUSH
14438: PPUSH
14439: PPUSH
14440: PPUSH
14441: PPUSH
14442: PPUSH
14443: PPUSH
14444: PPUSH
14445: PPUSH
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
// result := false ;
14450: LD_ADDR_VAR 0 3
14454: PUSH
14455: LD_INT 0
14457: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
14458: LD_VAR 0 1
14462: NOT
14463: PUSH
14464: LD_VAR 0 1
14468: PPUSH
14469: CALL_OW 266
14473: PUSH
14474: LD_INT 32
14476: PUSH
14477: LD_INT 33
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: IN
14484: NOT
14485: OR
14486: IFFALSE 14490
// exit ;
14488: GO 15629
// nat := GetNation ( tower ) ;
14490: LD_ADDR_VAR 0 12
14494: PUSH
14495: LD_VAR 0 1
14499: PPUSH
14500: CALL_OW 248
14504: ST_TO_ADDR
// side := GetSide ( tower ) ;
14505: LD_ADDR_VAR 0 16
14509: PUSH
14510: LD_VAR 0 1
14514: PPUSH
14515: CALL_OW 255
14519: ST_TO_ADDR
// x := GetX ( tower ) ;
14520: LD_ADDR_VAR 0 10
14524: PUSH
14525: LD_VAR 0 1
14529: PPUSH
14530: CALL_OW 250
14534: ST_TO_ADDR
// y := GetY ( tower ) ;
14535: LD_ADDR_VAR 0 11
14539: PUSH
14540: LD_VAR 0 1
14544: PPUSH
14545: CALL_OW 251
14549: ST_TO_ADDR
// if not x or not y then
14550: LD_VAR 0 10
14554: NOT
14555: PUSH
14556: LD_VAR 0 11
14560: NOT
14561: OR
14562: IFFALSE 14566
// exit ;
14564: GO 15629
// weapon := 0 ;
14566: LD_ADDR_VAR 0 18
14570: PUSH
14571: LD_INT 0
14573: ST_TO_ADDR
// fac_list := [ ] ;
14574: LD_ADDR_VAR 0 17
14578: PUSH
14579: EMPTY
14580: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
14581: LD_ADDR_VAR 0 6
14585: PUSH
14586: LD_VAR 0 1
14590: PPUSH
14591: CALL_OW 274
14595: PPUSH
14596: LD_VAR 0 2
14600: PPUSH
14601: LD_INT 0
14603: PPUSH
14604: CALL 12169 0 3
14608: PPUSH
14609: LD_INT 30
14611: PUSH
14612: LD_INT 3
14614: PUSH
14615: EMPTY
14616: LIST
14617: LIST
14618: PPUSH
14619: CALL_OW 72
14623: ST_TO_ADDR
// if not factories then
14624: LD_VAR 0 6
14628: NOT
14629: IFFALSE 14633
// exit ;
14631: GO 15629
// for i in factories do
14633: LD_ADDR_VAR 0 8
14637: PUSH
14638: LD_VAR 0 6
14642: PUSH
14643: FOR_IN
14644: IFFALSE 14669
// fac_list := fac_list union AvailableWeaponList ( i ) ;
14646: LD_ADDR_VAR 0 17
14650: PUSH
14651: LD_VAR 0 17
14655: PUSH
14656: LD_VAR 0 8
14660: PPUSH
14661: CALL_OW 478
14665: UNION
14666: ST_TO_ADDR
14667: GO 14643
14669: POP
14670: POP
// if not fac_list then
14671: LD_VAR 0 17
14675: NOT
14676: IFFALSE 14680
// exit ;
14678: GO 15629
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
14680: LD_ADDR_VAR 0 5
14684: PUSH
14685: LD_INT 4
14687: PUSH
14688: LD_INT 5
14690: PUSH
14691: LD_INT 9
14693: PUSH
14694: LD_INT 10
14696: PUSH
14697: LD_INT 6
14699: PUSH
14700: LD_INT 7
14702: PUSH
14703: LD_INT 11
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: PUSH
14715: LD_INT 27
14717: PUSH
14718: LD_INT 28
14720: PUSH
14721: LD_INT 26
14723: PUSH
14724: LD_INT 30
14726: PUSH
14727: EMPTY
14728: LIST
14729: LIST
14730: LIST
14731: LIST
14732: PUSH
14733: LD_INT 43
14735: PUSH
14736: LD_INT 44
14738: PUSH
14739: LD_INT 46
14741: PUSH
14742: LD_INT 45
14744: PUSH
14745: LD_INT 47
14747: PUSH
14748: LD_INT 49
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: LIST
14763: PUSH
14764: LD_VAR 0 12
14768: ARRAY
14769: ST_TO_ADDR
// for i in list do
14770: LD_ADDR_VAR 0 8
14774: PUSH
14775: LD_VAR 0 5
14779: PUSH
14780: FOR_IN
14781: IFFALSE 14814
// if not i in fac_list then
14783: LD_VAR 0 8
14787: PUSH
14788: LD_VAR 0 17
14792: IN
14793: NOT
14794: IFFALSE 14812
// list := list diff i ;
14796: LD_ADDR_VAR 0 5
14800: PUSH
14801: LD_VAR 0 5
14805: PUSH
14806: LD_VAR 0 8
14810: DIFF
14811: ST_TO_ADDR
14812: GO 14780
14814: POP
14815: POP
// if not list then
14816: LD_VAR 0 5
14820: NOT
14821: IFFALSE 14825
// exit ;
14823: GO 15629
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
14825: LD_VAR 0 12
14829: PUSH
14830: LD_INT 3
14832: EQUAL
14833: PUSH
14834: LD_INT 49
14836: PUSH
14837: LD_VAR 0 5
14841: IN
14842: AND
14843: PUSH
14844: LD_INT 31
14846: PPUSH
14847: LD_VAR 0 16
14851: PPUSH
14852: CALL_OW 321
14856: PUSH
14857: LD_INT 2
14859: EQUAL
14860: AND
14861: IFFALSE 14921
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
14863: LD_INT 22
14865: PUSH
14866: LD_VAR 0 16
14870: PUSH
14871: EMPTY
14872: LIST
14873: LIST
14874: PUSH
14875: LD_INT 35
14877: PUSH
14878: LD_INT 49
14880: PUSH
14881: EMPTY
14882: LIST
14883: LIST
14884: PUSH
14885: LD_INT 91
14887: PUSH
14888: LD_VAR 0 1
14892: PUSH
14893: LD_INT 10
14895: PUSH
14896: EMPTY
14897: LIST
14898: LIST
14899: LIST
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: LIST
14905: PPUSH
14906: CALL_OW 69
14910: NOT
14911: IFFALSE 14921
// weapon := ru_time_lapser ;
14913: LD_ADDR_VAR 0 18
14917: PUSH
14918: LD_INT 49
14920: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
14921: LD_VAR 0 12
14925: PUSH
14926: LD_INT 1
14928: PUSH
14929: LD_INT 2
14931: PUSH
14932: EMPTY
14933: LIST
14934: LIST
14935: IN
14936: PUSH
14937: LD_INT 11
14939: PUSH
14940: LD_VAR 0 5
14944: IN
14945: PUSH
14946: LD_INT 30
14948: PUSH
14949: LD_VAR 0 5
14953: IN
14954: OR
14955: AND
14956: PUSH
14957: LD_INT 6
14959: PPUSH
14960: LD_VAR 0 16
14964: PPUSH
14965: CALL_OW 321
14969: PUSH
14970: LD_INT 2
14972: EQUAL
14973: AND
14974: IFFALSE 15139
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
14976: LD_INT 22
14978: PUSH
14979: LD_VAR 0 16
14983: PUSH
14984: EMPTY
14985: LIST
14986: LIST
14987: PUSH
14988: LD_INT 2
14990: PUSH
14991: LD_INT 35
14993: PUSH
14994: LD_INT 11
14996: PUSH
14997: EMPTY
14998: LIST
14999: LIST
15000: PUSH
15001: LD_INT 35
15003: PUSH
15004: LD_INT 30
15006: PUSH
15007: EMPTY
15008: LIST
15009: LIST
15010: PUSH
15011: EMPTY
15012: LIST
15013: LIST
15014: LIST
15015: PUSH
15016: LD_INT 91
15018: PUSH
15019: LD_VAR 0 1
15023: PUSH
15024: LD_INT 18
15026: PUSH
15027: EMPTY
15028: LIST
15029: LIST
15030: LIST
15031: PUSH
15032: EMPTY
15033: LIST
15034: LIST
15035: LIST
15036: PPUSH
15037: CALL_OW 69
15041: NOT
15042: PUSH
15043: LD_INT 22
15045: PUSH
15046: LD_VAR 0 16
15050: PUSH
15051: EMPTY
15052: LIST
15053: LIST
15054: PUSH
15055: LD_INT 2
15057: PUSH
15058: LD_INT 30
15060: PUSH
15061: LD_INT 32
15063: PUSH
15064: EMPTY
15065: LIST
15066: LIST
15067: PUSH
15068: LD_INT 30
15070: PUSH
15071: LD_INT 33
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: PUSH
15078: EMPTY
15079: LIST
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 91
15085: PUSH
15086: LD_VAR 0 1
15090: PUSH
15091: LD_INT 12
15093: PUSH
15094: EMPTY
15095: LIST
15096: LIST
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PUSH
15104: EMPTY
15105: LIST
15106: PPUSH
15107: CALL_OW 69
15111: PUSH
15112: LD_INT 2
15114: GREATER
15115: AND
15116: IFFALSE 15139
// weapon := [ us_radar , ar_radar ] [ nat ] ;
15118: LD_ADDR_VAR 0 18
15122: PUSH
15123: LD_INT 11
15125: PUSH
15126: LD_INT 30
15128: PUSH
15129: EMPTY
15130: LIST
15131: LIST
15132: PUSH
15133: LD_VAR 0 12
15137: ARRAY
15138: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
15139: LD_VAR 0 18
15143: NOT
15144: PUSH
15145: LD_INT 40
15147: PPUSH
15148: LD_VAR 0 16
15152: PPUSH
15153: CALL_OW 321
15157: PUSH
15158: LD_INT 2
15160: EQUAL
15161: AND
15162: PUSH
15163: LD_INT 7
15165: PUSH
15166: LD_VAR 0 5
15170: IN
15171: PUSH
15172: LD_INT 28
15174: PUSH
15175: LD_VAR 0 5
15179: IN
15180: OR
15181: PUSH
15182: LD_INT 45
15184: PUSH
15185: LD_VAR 0 5
15189: IN
15190: OR
15191: AND
15192: IFFALSE 15446
// begin hex := GetHexInfo ( x , y ) ;
15194: LD_ADDR_VAR 0 4
15198: PUSH
15199: LD_VAR 0 10
15203: PPUSH
15204: LD_VAR 0 11
15208: PPUSH
15209: CALL_OW 546
15213: ST_TO_ADDR
// if hex [ 1 ] then
15214: LD_VAR 0 4
15218: PUSH
15219: LD_INT 1
15221: ARRAY
15222: IFFALSE 15226
// exit ;
15224: GO 15629
// height := hex [ 2 ] ;
15226: LD_ADDR_VAR 0 15
15230: PUSH
15231: LD_VAR 0 4
15235: PUSH
15236: LD_INT 2
15238: ARRAY
15239: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
15240: LD_ADDR_VAR 0 14
15244: PUSH
15245: LD_INT 0
15247: PUSH
15248: LD_INT 2
15250: PUSH
15251: LD_INT 3
15253: PUSH
15254: LD_INT 5
15256: PUSH
15257: EMPTY
15258: LIST
15259: LIST
15260: LIST
15261: LIST
15262: ST_TO_ADDR
// for i in tmp do
15263: LD_ADDR_VAR 0 8
15267: PUSH
15268: LD_VAR 0 14
15272: PUSH
15273: FOR_IN
15274: IFFALSE 15444
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
15276: LD_ADDR_VAR 0 9
15280: PUSH
15281: LD_VAR 0 10
15285: PPUSH
15286: LD_VAR 0 8
15290: PPUSH
15291: LD_INT 5
15293: PPUSH
15294: CALL_OW 272
15298: PUSH
15299: LD_VAR 0 11
15303: PPUSH
15304: LD_VAR 0 8
15308: PPUSH
15309: LD_INT 5
15311: PPUSH
15312: CALL_OW 273
15316: PUSH
15317: EMPTY
15318: LIST
15319: LIST
15320: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
15321: LD_VAR 0 9
15325: PUSH
15326: LD_INT 1
15328: ARRAY
15329: PPUSH
15330: LD_VAR 0 9
15334: PUSH
15335: LD_INT 2
15337: ARRAY
15338: PPUSH
15339: CALL_OW 488
15343: IFFALSE 15442
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
15345: LD_ADDR_VAR 0 4
15349: PUSH
15350: LD_VAR 0 9
15354: PUSH
15355: LD_INT 1
15357: ARRAY
15358: PPUSH
15359: LD_VAR 0 9
15363: PUSH
15364: LD_INT 2
15366: ARRAY
15367: PPUSH
15368: CALL_OW 546
15372: ST_TO_ADDR
// if hex [ 1 ] then
15373: LD_VAR 0 4
15377: PUSH
15378: LD_INT 1
15380: ARRAY
15381: IFFALSE 15385
// continue ;
15383: GO 15273
// h := hex [ 2 ] ;
15385: LD_ADDR_VAR 0 13
15389: PUSH
15390: LD_VAR 0 4
15394: PUSH
15395: LD_INT 2
15397: ARRAY
15398: ST_TO_ADDR
// if h + 7 < height then
15399: LD_VAR 0 13
15403: PUSH
15404: LD_INT 7
15406: PLUS
15407: PUSH
15408: LD_VAR 0 15
15412: LESS
15413: IFFALSE 15442
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
15415: LD_ADDR_VAR 0 18
15419: PUSH
15420: LD_INT 7
15422: PUSH
15423: LD_INT 28
15425: PUSH
15426: LD_INT 45
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: LIST
15433: PUSH
15434: LD_VAR 0 12
15438: ARRAY
15439: ST_TO_ADDR
// break ;
15440: GO 15444
// end ; end ; end ;
15442: GO 15273
15444: POP
15445: POP
// end ; if not weapon then
15446: LD_VAR 0 18
15450: NOT
15451: IFFALSE 15511
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
15453: LD_ADDR_VAR 0 5
15457: PUSH
15458: LD_VAR 0 5
15462: PUSH
15463: LD_INT 11
15465: PUSH
15466: LD_INT 30
15468: PUSH
15469: LD_INT 49
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: LIST
15476: DIFF
15477: ST_TO_ADDR
// if not list then
15478: LD_VAR 0 5
15482: NOT
15483: IFFALSE 15487
// exit ;
15485: GO 15629
// weapon := list [ rand ( 1 , list ) ] ;
15487: LD_ADDR_VAR 0 18
15491: PUSH
15492: LD_VAR 0 5
15496: PUSH
15497: LD_INT 1
15499: PPUSH
15500: LD_VAR 0 5
15504: PPUSH
15505: CALL_OW 12
15509: ARRAY
15510: ST_TO_ADDR
// end ; if weapon then
15511: LD_VAR 0 18
15515: IFFALSE 15629
// begin tmp := CostOfWeapon ( weapon ) ;
15517: LD_ADDR_VAR 0 14
15521: PUSH
15522: LD_VAR 0 18
15526: PPUSH
15527: CALL_OW 451
15531: ST_TO_ADDR
// j := GetBase ( tower ) ;
15532: LD_ADDR_VAR 0 9
15536: PUSH
15537: LD_VAR 0 1
15541: PPUSH
15542: CALL_OW 274
15546: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
15547: LD_VAR 0 9
15551: PPUSH
15552: LD_INT 1
15554: PPUSH
15555: CALL_OW 275
15559: PUSH
15560: LD_VAR 0 14
15564: PUSH
15565: LD_INT 1
15567: ARRAY
15568: GREATEREQUAL
15569: PUSH
15570: LD_VAR 0 9
15574: PPUSH
15575: LD_INT 2
15577: PPUSH
15578: CALL_OW 275
15582: PUSH
15583: LD_VAR 0 14
15587: PUSH
15588: LD_INT 2
15590: ARRAY
15591: GREATEREQUAL
15592: AND
15593: PUSH
15594: LD_VAR 0 9
15598: PPUSH
15599: LD_INT 3
15601: PPUSH
15602: CALL_OW 275
15606: PUSH
15607: LD_VAR 0 14
15611: PUSH
15612: LD_INT 3
15614: ARRAY
15615: GREATEREQUAL
15616: AND
15617: IFFALSE 15629
// result := weapon ;
15619: LD_ADDR_VAR 0 3
15623: PUSH
15624: LD_VAR 0 18
15628: ST_TO_ADDR
// end ; end ;
15629: LD_VAR 0 3
15633: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
15634: LD_INT 0
15636: PPUSH
15637: PPUSH
// result := true ;
15638: LD_ADDR_VAR 0 3
15642: PUSH
15643: LD_INT 1
15645: ST_TO_ADDR
// if array1 = array2 then
15646: LD_VAR 0 1
15650: PUSH
15651: LD_VAR 0 2
15655: EQUAL
15656: IFFALSE 15716
// begin for i = 1 to array1 do
15658: LD_ADDR_VAR 0 4
15662: PUSH
15663: DOUBLE
15664: LD_INT 1
15666: DEC
15667: ST_TO_ADDR
15668: LD_VAR 0 1
15672: PUSH
15673: FOR_TO
15674: IFFALSE 15712
// if array1 [ i ] <> array2 [ i ] then
15676: LD_VAR 0 1
15680: PUSH
15681: LD_VAR 0 4
15685: ARRAY
15686: PUSH
15687: LD_VAR 0 2
15691: PUSH
15692: LD_VAR 0 4
15696: ARRAY
15697: NONEQUAL
15698: IFFALSE 15710
// begin result := false ;
15700: LD_ADDR_VAR 0 3
15704: PUSH
15705: LD_INT 0
15707: ST_TO_ADDR
// break ;
15708: GO 15712
// end ;
15710: GO 15673
15712: POP
15713: POP
// end else
15714: GO 15724
// result := false ;
15716: LD_ADDR_VAR 0 3
15720: PUSH
15721: LD_INT 0
15723: ST_TO_ADDR
// end ;
15724: LD_VAR 0 3
15728: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
15729: LD_INT 0
15731: PPUSH
15732: PPUSH
// if not array1 or not array2 then
15733: LD_VAR 0 1
15737: NOT
15738: PUSH
15739: LD_VAR 0 2
15743: NOT
15744: OR
15745: IFFALSE 15749
// exit ;
15747: GO 15813
// result := true ;
15749: LD_ADDR_VAR 0 3
15753: PUSH
15754: LD_INT 1
15756: ST_TO_ADDR
// for i = 1 to array1 do
15757: LD_ADDR_VAR 0 4
15761: PUSH
15762: DOUBLE
15763: LD_INT 1
15765: DEC
15766: ST_TO_ADDR
15767: LD_VAR 0 1
15771: PUSH
15772: FOR_TO
15773: IFFALSE 15811
// if array1 [ i ] <> array2 [ i ] then
15775: LD_VAR 0 1
15779: PUSH
15780: LD_VAR 0 4
15784: ARRAY
15785: PUSH
15786: LD_VAR 0 2
15790: PUSH
15791: LD_VAR 0 4
15795: ARRAY
15796: NONEQUAL
15797: IFFALSE 15809
// begin result := false ;
15799: LD_ADDR_VAR 0 3
15803: PUSH
15804: LD_INT 0
15806: ST_TO_ADDR
// break ;
15807: GO 15811
// end ;
15809: GO 15772
15811: POP
15812: POP
// end ;
15813: LD_VAR 0 3
15817: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
15818: LD_INT 0
15820: PPUSH
15821: PPUSH
15822: PPUSH
// pom := GetBase ( fac ) ;
15823: LD_ADDR_VAR 0 5
15827: PUSH
15828: LD_VAR 0 1
15832: PPUSH
15833: CALL_OW 274
15837: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
15838: LD_ADDR_VAR 0 4
15842: PUSH
15843: LD_VAR 0 2
15847: PUSH
15848: LD_INT 1
15850: ARRAY
15851: PPUSH
15852: LD_VAR 0 2
15856: PUSH
15857: LD_INT 2
15859: ARRAY
15860: PPUSH
15861: LD_VAR 0 2
15865: PUSH
15866: LD_INT 3
15868: ARRAY
15869: PPUSH
15870: LD_VAR 0 2
15874: PUSH
15875: LD_INT 4
15877: ARRAY
15878: PPUSH
15879: CALL_OW 449
15883: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
15884: LD_ADDR_VAR 0 3
15888: PUSH
15889: LD_VAR 0 5
15893: PPUSH
15894: LD_INT 1
15896: PPUSH
15897: CALL_OW 275
15901: PUSH
15902: LD_VAR 0 4
15906: PUSH
15907: LD_INT 1
15909: ARRAY
15910: GREATEREQUAL
15911: PUSH
15912: LD_VAR 0 5
15916: PPUSH
15917: LD_INT 2
15919: PPUSH
15920: CALL_OW 275
15924: PUSH
15925: LD_VAR 0 4
15929: PUSH
15930: LD_INT 2
15932: ARRAY
15933: GREATEREQUAL
15934: AND
15935: PUSH
15936: LD_VAR 0 5
15940: PPUSH
15941: LD_INT 3
15943: PPUSH
15944: CALL_OW 275
15948: PUSH
15949: LD_VAR 0 4
15953: PUSH
15954: LD_INT 3
15956: ARRAY
15957: GREATEREQUAL
15958: AND
15959: ST_TO_ADDR
// end ;
15960: LD_VAR 0 3
15964: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
15965: LD_INT 0
15967: PPUSH
15968: PPUSH
15969: PPUSH
15970: PPUSH
// pom := GetBase ( building ) ;
15971: LD_ADDR_VAR 0 3
15975: PUSH
15976: LD_VAR 0 1
15980: PPUSH
15981: CALL_OW 274
15985: ST_TO_ADDR
// if not pom then
15986: LD_VAR 0 3
15990: NOT
15991: IFFALSE 15995
// exit ;
15993: GO 16165
// btype := GetBType ( building ) ;
15995: LD_ADDR_VAR 0 5
15999: PUSH
16000: LD_VAR 0 1
16004: PPUSH
16005: CALL_OW 266
16009: ST_TO_ADDR
// if btype = b_armoury then
16010: LD_VAR 0 5
16014: PUSH
16015: LD_INT 4
16017: EQUAL
16018: IFFALSE 16028
// btype := b_barracks ;
16020: LD_ADDR_VAR 0 5
16024: PUSH
16025: LD_INT 5
16027: ST_TO_ADDR
// if btype = b_depot then
16028: LD_VAR 0 5
16032: PUSH
16033: LD_INT 0
16035: EQUAL
16036: IFFALSE 16046
// btype := b_warehouse ;
16038: LD_ADDR_VAR 0 5
16042: PUSH
16043: LD_INT 1
16045: ST_TO_ADDR
// if btype = b_workshop then
16046: LD_VAR 0 5
16050: PUSH
16051: LD_INT 2
16053: EQUAL
16054: IFFALSE 16064
// btype := b_factory ;
16056: LD_ADDR_VAR 0 5
16060: PUSH
16061: LD_INT 3
16063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16064: LD_ADDR_VAR 0 4
16068: PUSH
16069: LD_VAR 0 5
16073: PPUSH
16074: LD_VAR 0 1
16078: PPUSH
16079: CALL_OW 248
16083: PPUSH
16084: CALL_OW 450
16088: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16089: LD_ADDR_VAR 0 2
16093: PUSH
16094: LD_VAR 0 3
16098: PPUSH
16099: LD_INT 1
16101: PPUSH
16102: CALL_OW 275
16106: PUSH
16107: LD_VAR 0 4
16111: PUSH
16112: LD_INT 1
16114: ARRAY
16115: GREATEREQUAL
16116: PUSH
16117: LD_VAR 0 3
16121: PPUSH
16122: LD_INT 2
16124: PPUSH
16125: CALL_OW 275
16129: PUSH
16130: LD_VAR 0 4
16134: PUSH
16135: LD_INT 2
16137: ARRAY
16138: GREATEREQUAL
16139: AND
16140: PUSH
16141: LD_VAR 0 3
16145: PPUSH
16146: LD_INT 3
16148: PPUSH
16149: CALL_OW 275
16153: PUSH
16154: LD_VAR 0 4
16158: PUSH
16159: LD_INT 3
16161: ARRAY
16162: GREATEREQUAL
16163: AND
16164: ST_TO_ADDR
// end ;
16165: LD_VAR 0 2
16169: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
16170: LD_INT 0
16172: PPUSH
16173: PPUSH
16174: PPUSH
// pom := GetBase ( building ) ;
16175: LD_ADDR_VAR 0 4
16179: PUSH
16180: LD_VAR 0 1
16184: PPUSH
16185: CALL_OW 274
16189: ST_TO_ADDR
// if not pom then
16190: LD_VAR 0 4
16194: NOT
16195: IFFALSE 16199
// exit ;
16197: GO 16300
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
16199: LD_ADDR_VAR 0 5
16203: PUSH
16204: LD_VAR 0 2
16208: PPUSH
16209: LD_VAR 0 1
16213: PPUSH
16214: CALL_OW 248
16218: PPUSH
16219: CALL_OW 450
16223: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
16224: LD_ADDR_VAR 0 3
16228: PUSH
16229: LD_VAR 0 4
16233: PPUSH
16234: LD_INT 1
16236: PPUSH
16237: CALL_OW 275
16241: PUSH
16242: LD_VAR 0 5
16246: PUSH
16247: LD_INT 1
16249: ARRAY
16250: GREATEREQUAL
16251: PUSH
16252: LD_VAR 0 4
16256: PPUSH
16257: LD_INT 2
16259: PPUSH
16260: CALL_OW 275
16264: PUSH
16265: LD_VAR 0 5
16269: PUSH
16270: LD_INT 2
16272: ARRAY
16273: GREATEREQUAL
16274: AND
16275: PUSH
16276: LD_VAR 0 4
16280: PPUSH
16281: LD_INT 3
16283: PPUSH
16284: CALL_OW 275
16288: PUSH
16289: LD_VAR 0 5
16293: PUSH
16294: LD_INT 3
16296: ARRAY
16297: GREATEREQUAL
16298: AND
16299: ST_TO_ADDR
// end ;
16300: LD_VAR 0 3
16304: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
16305: LD_INT 0
16307: PPUSH
16308: PPUSH
16309: PPUSH
16310: PPUSH
16311: PPUSH
16312: PPUSH
16313: PPUSH
16314: PPUSH
16315: PPUSH
16316: PPUSH
16317: PPUSH
// result := false ;
16318: LD_ADDR_VAR 0 8
16322: PUSH
16323: LD_INT 0
16325: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
16326: LD_VAR 0 5
16330: NOT
16331: PUSH
16332: LD_VAR 0 1
16336: NOT
16337: OR
16338: PUSH
16339: LD_VAR 0 2
16343: NOT
16344: OR
16345: PUSH
16346: LD_VAR 0 3
16350: NOT
16351: OR
16352: IFFALSE 16356
// exit ;
16354: GO 17170
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
16356: LD_ADDR_VAR 0 14
16360: PUSH
16361: LD_VAR 0 1
16365: PPUSH
16366: LD_VAR 0 2
16370: PPUSH
16371: LD_VAR 0 3
16375: PPUSH
16376: LD_VAR 0 4
16380: PPUSH
16381: LD_VAR 0 5
16385: PUSH
16386: LD_INT 1
16388: ARRAY
16389: PPUSH
16390: CALL_OW 248
16394: PPUSH
16395: LD_INT 0
16397: PPUSH
16398: CALL 18007 0 6
16402: ST_TO_ADDR
// if not hexes then
16403: LD_VAR 0 14
16407: NOT
16408: IFFALSE 16412
// exit ;
16410: GO 17170
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
16412: LD_ADDR_VAR 0 17
16416: PUSH
16417: LD_VAR 0 5
16421: PPUSH
16422: LD_INT 22
16424: PUSH
16425: LD_VAR 0 13
16429: PPUSH
16430: CALL_OW 255
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PUSH
16439: LD_INT 2
16441: PUSH
16442: LD_INT 30
16444: PUSH
16445: LD_INT 0
16447: PUSH
16448: EMPTY
16449: LIST
16450: LIST
16451: PUSH
16452: LD_INT 30
16454: PUSH
16455: LD_INT 1
16457: PUSH
16458: EMPTY
16459: LIST
16460: LIST
16461: PUSH
16462: EMPTY
16463: LIST
16464: LIST
16465: LIST
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PPUSH
16471: CALL_OW 72
16475: ST_TO_ADDR
// for i = 1 to hexes do
16476: LD_ADDR_VAR 0 9
16480: PUSH
16481: DOUBLE
16482: LD_INT 1
16484: DEC
16485: ST_TO_ADDR
16486: LD_VAR 0 14
16490: PUSH
16491: FOR_TO
16492: IFFALSE 17168
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
16494: LD_ADDR_VAR 0 13
16498: PUSH
16499: LD_VAR 0 14
16503: PUSH
16504: LD_VAR 0 9
16508: ARRAY
16509: PUSH
16510: LD_INT 1
16512: ARRAY
16513: PPUSH
16514: LD_VAR 0 14
16518: PUSH
16519: LD_VAR 0 9
16523: ARRAY
16524: PUSH
16525: LD_INT 2
16527: ARRAY
16528: PPUSH
16529: CALL_OW 428
16533: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
16534: LD_VAR 0 14
16538: PUSH
16539: LD_VAR 0 9
16543: ARRAY
16544: PUSH
16545: LD_INT 1
16547: ARRAY
16548: PPUSH
16549: LD_VAR 0 14
16553: PUSH
16554: LD_VAR 0 9
16558: ARRAY
16559: PUSH
16560: LD_INT 2
16562: ARRAY
16563: PPUSH
16564: CALL_OW 351
16568: PUSH
16569: LD_VAR 0 14
16573: PUSH
16574: LD_VAR 0 9
16578: ARRAY
16579: PUSH
16580: LD_INT 1
16582: ARRAY
16583: PPUSH
16584: LD_VAR 0 14
16588: PUSH
16589: LD_VAR 0 9
16593: ARRAY
16594: PUSH
16595: LD_INT 2
16597: ARRAY
16598: PPUSH
16599: CALL_OW 488
16603: NOT
16604: OR
16605: PUSH
16606: LD_VAR 0 13
16610: PPUSH
16611: CALL_OW 247
16615: PUSH
16616: LD_INT 3
16618: EQUAL
16619: OR
16620: IFFALSE 16626
// exit ;
16622: POP
16623: POP
16624: GO 17170
// if not tmp then
16626: LD_VAR 0 13
16630: NOT
16631: IFFALSE 16635
// continue ;
16633: GO 16491
// result := true ;
16635: LD_ADDR_VAR 0 8
16639: PUSH
16640: LD_INT 1
16642: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
16643: LD_VAR 0 6
16647: PUSH
16648: LD_VAR 0 13
16652: PPUSH
16653: CALL_OW 247
16657: PUSH
16658: LD_INT 2
16660: EQUAL
16661: AND
16662: PUSH
16663: LD_VAR 0 13
16667: PPUSH
16668: CALL_OW 263
16672: PUSH
16673: LD_INT 1
16675: EQUAL
16676: AND
16677: IFFALSE 16841
// begin if IsDrivenBy ( tmp ) then
16679: LD_VAR 0 13
16683: PPUSH
16684: CALL_OW 311
16688: IFFALSE 16692
// continue ;
16690: GO 16491
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
16692: LD_VAR 0 6
16696: PPUSH
16697: LD_INT 3
16699: PUSH
16700: LD_INT 60
16702: PUSH
16703: EMPTY
16704: LIST
16705: PUSH
16706: EMPTY
16707: LIST
16708: LIST
16709: PUSH
16710: LD_INT 3
16712: PUSH
16713: LD_INT 55
16715: PUSH
16716: EMPTY
16717: LIST
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: PUSH
16723: EMPTY
16724: LIST
16725: LIST
16726: PPUSH
16727: CALL_OW 72
16731: IFFALSE 16839
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
16733: LD_ADDR_VAR 0 18
16737: PUSH
16738: LD_VAR 0 6
16742: PPUSH
16743: LD_INT 3
16745: PUSH
16746: LD_INT 60
16748: PUSH
16749: EMPTY
16750: LIST
16751: PUSH
16752: EMPTY
16753: LIST
16754: LIST
16755: PUSH
16756: LD_INT 3
16758: PUSH
16759: LD_INT 55
16761: PUSH
16762: EMPTY
16763: LIST
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PPUSH
16773: CALL_OW 72
16777: PUSH
16778: LD_INT 1
16780: ARRAY
16781: ST_TO_ADDR
// if IsInUnit ( driver ) then
16782: LD_VAR 0 18
16786: PPUSH
16787: CALL_OW 310
16791: IFFALSE 16802
// ComExit ( driver ) ;
16793: LD_VAR 0 18
16797: PPUSH
16798: CALL 41191 0 1
// AddComEnterUnit ( driver , tmp ) ;
16802: LD_VAR 0 18
16806: PPUSH
16807: LD_VAR 0 13
16811: PPUSH
16812: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
16816: LD_VAR 0 18
16820: PPUSH
16821: LD_VAR 0 7
16825: PPUSH
16826: CALL_OW 173
// AddComExitVehicle ( driver ) ;
16830: LD_VAR 0 18
16834: PPUSH
16835: CALL_OW 181
// end ; continue ;
16839: GO 16491
// end ; if not cleaners or not tmp in cleaners then
16841: LD_VAR 0 6
16845: NOT
16846: PUSH
16847: LD_VAR 0 13
16851: PUSH
16852: LD_VAR 0 6
16856: IN
16857: NOT
16858: OR
16859: IFFALSE 17166
// begin if dep then
16861: LD_VAR 0 17
16865: IFFALSE 17001
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
16867: LD_ADDR_VAR 0 16
16871: PUSH
16872: LD_VAR 0 17
16876: PUSH
16877: LD_INT 1
16879: ARRAY
16880: PPUSH
16881: CALL_OW 250
16885: PPUSH
16886: LD_VAR 0 17
16890: PUSH
16891: LD_INT 1
16893: ARRAY
16894: PPUSH
16895: CALL_OW 254
16899: PPUSH
16900: LD_INT 5
16902: PPUSH
16903: CALL_OW 272
16907: PUSH
16908: LD_VAR 0 17
16912: PUSH
16913: LD_INT 1
16915: ARRAY
16916: PPUSH
16917: CALL_OW 251
16921: PPUSH
16922: LD_VAR 0 17
16926: PUSH
16927: LD_INT 1
16929: ARRAY
16930: PPUSH
16931: CALL_OW 254
16935: PPUSH
16936: LD_INT 5
16938: PPUSH
16939: CALL_OW 273
16943: PUSH
16944: EMPTY
16945: LIST
16946: LIST
16947: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
16948: LD_VAR 0 16
16952: PUSH
16953: LD_INT 1
16955: ARRAY
16956: PPUSH
16957: LD_VAR 0 16
16961: PUSH
16962: LD_INT 2
16964: ARRAY
16965: PPUSH
16966: CALL_OW 488
16970: IFFALSE 17001
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
16972: LD_VAR 0 13
16976: PPUSH
16977: LD_VAR 0 16
16981: PUSH
16982: LD_INT 1
16984: ARRAY
16985: PPUSH
16986: LD_VAR 0 16
16990: PUSH
16991: LD_INT 2
16993: ARRAY
16994: PPUSH
16995: CALL_OW 111
// continue ;
16999: GO 16491
// end ; end ; r := GetDir ( tmp ) ;
17001: LD_ADDR_VAR 0 15
17005: PUSH
17006: LD_VAR 0 13
17010: PPUSH
17011: CALL_OW 254
17015: ST_TO_ADDR
// if r = 5 then
17016: LD_VAR 0 15
17020: PUSH
17021: LD_INT 5
17023: EQUAL
17024: IFFALSE 17034
// r := 0 ;
17026: LD_ADDR_VAR 0 15
17030: PUSH
17031: LD_INT 0
17033: ST_TO_ADDR
// for j = r to 5 do
17034: LD_ADDR_VAR 0 10
17038: PUSH
17039: DOUBLE
17040: LD_VAR 0 15
17044: DEC
17045: ST_TO_ADDR
17046: LD_INT 5
17048: PUSH
17049: FOR_TO
17050: IFFALSE 17164
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
17052: LD_ADDR_VAR 0 11
17056: PUSH
17057: LD_VAR 0 13
17061: PPUSH
17062: CALL_OW 250
17066: PPUSH
17067: LD_VAR 0 10
17071: PPUSH
17072: LD_INT 2
17074: PPUSH
17075: CALL_OW 272
17079: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
17080: LD_ADDR_VAR 0 12
17084: PUSH
17085: LD_VAR 0 13
17089: PPUSH
17090: CALL_OW 251
17094: PPUSH
17095: LD_VAR 0 10
17099: PPUSH
17100: LD_INT 2
17102: PPUSH
17103: CALL_OW 273
17107: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
17108: LD_VAR 0 11
17112: PPUSH
17113: LD_VAR 0 12
17117: PPUSH
17118: CALL_OW 488
17122: PUSH
17123: LD_VAR 0 11
17127: PPUSH
17128: LD_VAR 0 12
17132: PPUSH
17133: CALL_OW 428
17137: NOT
17138: AND
17139: IFFALSE 17162
// begin ComMoveXY ( tmp , _x , _y ) ;
17141: LD_VAR 0 13
17145: PPUSH
17146: LD_VAR 0 11
17150: PPUSH
17151: LD_VAR 0 12
17155: PPUSH
17156: CALL_OW 111
// break ;
17160: GO 17164
// end ; end ;
17162: GO 17049
17164: POP
17165: POP
// end ; end ;
17166: GO 16491
17168: POP
17169: POP
// end ;
17170: LD_VAR 0 8
17174: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
17175: LD_INT 0
17177: PPUSH
17178: PPUSH
17179: PPUSH
17180: PPUSH
17181: PPUSH
17182: PPUSH
17183: PPUSH
17184: PPUSH
17185: PPUSH
17186: PPUSH
// result := false ;
17187: LD_ADDR_VAR 0 6
17191: PUSH
17192: LD_INT 0
17194: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
17195: LD_VAR 0 1
17199: NOT
17200: PUSH
17201: LD_VAR 0 1
17205: PPUSH
17206: CALL_OW 266
17210: PUSH
17211: LD_INT 0
17213: PUSH
17214: LD_INT 1
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: IN
17221: NOT
17222: OR
17223: PUSH
17224: LD_VAR 0 2
17228: NOT
17229: OR
17230: PUSH
17231: LD_VAR 0 5
17235: PUSH
17236: LD_INT 0
17238: PUSH
17239: LD_INT 1
17241: PUSH
17242: LD_INT 2
17244: PUSH
17245: LD_INT 3
17247: PUSH
17248: LD_INT 4
17250: PUSH
17251: LD_INT 5
17253: PUSH
17254: EMPTY
17255: LIST
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: IN
17262: NOT
17263: OR
17264: PUSH
17265: LD_VAR 0 3
17269: PPUSH
17270: LD_VAR 0 4
17274: PPUSH
17275: CALL_OW 488
17279: NOT
17280: OR
17281: IFFALSE 17285
// exit ;
17283: GO 18002
// pom := GetBase ( depot ) ;
17285: LD_ADDR_VAR 0 10
17289: PUSH
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL_OW 274
17299: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
17300: LD_ADDR_VAR 0 11
17304: PUSH
17305: LD_VAR 0 2
17309: PPUSH
17310: LD_VAR 0 1
17314: PPUSH
17315: CALL_OW 248
17319: PPUSH
17320: CALL_OW 450
17324: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
17325: LD_VAR 0 10
17329: PPUSH
17330: LD_INT 1
17332: PPUSH
17333: CALL_OW 275
17337: PUSH
17338: LD_VAR 0 11
17342: PUSH
17343: LD_INT 1
17345: ARRAY
17346: GREATEREQUAL
17347: PUSH
17348: LD_VAR 0 10
17352: PPUSH
17353: LD_INT 2
17355: PPUSH
17356: CALL_OW 275
17360: PUSH
17361: LD_VAR 0 11
17365: PUSH
17366: LD_INT 2
17368: ARRAY
17369: GREATEREQUAL
17370: AND
17371: PUSH
17372: LD_VAR 0 10
17376: PPUSH
17377: LD_INT 3
17379: PPUSH
17380: CALL_OW 275
17384: PUSH
17385: LD_VAR 0 11
17389: PUSH
17390: LD_INT 3
17392: ARRAY
17393: GREATEREQUAL
17394: AND
17395: NOT
17396: IFFALSE 17400
// exit ;
17398: GO 18002
// if GetBType ( depot ) = b_depot then
17400: LD_VAR 0 1
17404: PPUSH
17405: CALL_OW 266
17409: PUSH
17410: LD_INT 0
17412: EQUAL
17413: IFFALSE 17425
// dist := 28 else
17415: LD_ADDR_VAR 0 14
17419: PUSH
17420: LD_INT 28
17422: ST_TO_ADDR
17423: GO 17433
// dist := 36 ;
17425: LD_ADDR_VAR 0 14
17429: PUSH
17430: LD_INT 36
17432: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
17433: LD_VAR 0 1
17437: PPUSH
17438: LD_VAR 0 3
17442: PPUSH
17443: LD_VAR 0 4
17447: PPUSH
17448: CALL_OW 297
17452: PUSH
17453: LD_VAR 0 14
17457: GREATER
17458: IFFALSE 17462
// exit ;
17460: GO 18002
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
17462: LD_ADDR_VAR 0 12
17466: PUSH
17467: LD_VAR 0 2
17471: PPUSH
17472: LD_VAR 0 3
17476: PPUSH
17477: LD_VAR 0 4
17481: PPUSH
17482: LD_VAR 0 5
17486: PPUSH
17487: LD_VAR 0 1
17491: PPUSH
17492: CALL_OW 248
17496: PPUSH
17497: LD_INT 0
17499: PPUSH
17500: CALL 18007 0 6
17504: ST_TO_ADDR
// if not hexes then
17505: LD_VAR 0 12
17509: NOT
17510: IFFALSE 17514
// exit ;
17512: GO 18002
// hex := GetHexInfo ( x , y ) ;
17514: LD_ADDR_VAR 0 15
17518: PUSH
17519: LD_VAR 0 3
17523: PPUSH
17524: LD_VAR 0 4
17528: PPUSH
17529: CALL_OW 546
17533: ST_TO_ADDR
// if hex [ 1 ] then
17534: LD_VAR 0 15
17538: PUSH
17539: LD_INT 1
17541: ARRAY
17542: IFFALSE 17546
// exit ;
17544: GO 18002
// height := hex [ 2 ] ;
17546: LD_ADDR_VAR 0 13
17550: PUSH
17551: LD_VAR 0 15
17555: PUSH
17556: LD_INT 2
17558: ARRAY
17559: ST_TO_ADDR
// for i = 1 to hexes do
17560: LD_ADDR_VAR 0 7
17564: PUSH
17565: DOUBLE
17566: LD_INT 1
17568: DEC
17569: ST_TO_ADDR
17570: LD_VAR 0 12
17574: PUSH
17575: FOR_TO
17576: IFFALSE 17906
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
17578: LD_VAR 0 12
17582: PUSH
17583: LD_VAR 0 7
17587: ARRAY
17588: PUSH
17589: LD_INT 1
17591: ARRAY
17592: PPUSH
17593: LD_VAR 0 12
17597: PUSH
17598: LD_VAR 0 7
17602: ARRAY
17603: PUSH
17604: LD_INT 2
17606: ARRAY
17607: PPUSH
17608: CALL_OW 488
17612: NOT
17613: PUSH
17614: LD_VAR 0 12
17618: PUSH
17619: LD_VAR 0 7
17623: ARRAY
17624: PUSH
17625: LD_INT 1
17627: ARRAY
17628: PPUSH
17629: LD_VAR 0 12
17633: PUSH
17634: LD_VAR 0 7
17638: ARRAY
17639: PUSH
17640: LD_INT 2
17642: ARRAY
17643: PPUSH
17644: CALL_OW 428
17648: PUSH
17649: LD_INT 0
17651: GREATER
17652: OR
17653: PUSH
17654: LD_VAR 0 12
17658: PUSH
17659: LD_VAR 0 7
17663: ARRAY
17664: PUSH
17665: LD_INT 1
17667: ARRAY
17668: PPUSH
17669: LD_VAR 0 12
17673: PUSH
17674: LD_VAR 0 7
17678: ARRAY
17679: PUSH
17680: LD_INT 2
17682: ARRAY
17683: PPUSH
17684: CALL_OW 351
17688: OR
17689: IFFALSE 17695
// exit ;
17691: POP
17692: POP
17693: GO 18002
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
17695: LD_ADDR_VAR 0 8
17699: PUSH
17700: LD_VAR 0 12
17704: PUSH
17705: LD_VAR 0 7
17709: ARRAY
17710: PUSH
17711: LD_INT 1
17713: ARRAY
17714: PPUSH
17715: LD_VAR 0 12
17719: PUSH
17720: LD_VAR 0 7
17724: ARRAY
17725: PUSH
17726: LD_INT 2
17728: ARRAY
17729: PPUSH
17730: CALL_OW 546
17734: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
17735: LD_VAR 0 8
17739: PUSH
17740: LD_INT 1
17742: ARRAY
17743: PUSH
17744: LD_VAR 0 8
17748: PUSH
17749: LD_INT 2
17751: ARRAY
17752: PUSH
17753: LD_VAR 0 13
17757: PUSH
17758: LD_INT 2
17760: PLUS
17761: GREATER
17762: OR
17763: PUSH
17764: LD_VAR 0 8
17768: PUSH
17769: LD_INT 2
17771: ARRAY
17772: PUSH
17773: LD_VAR 0 13
17777: PUSH
17778: LD_INT 2
17780: MINUS
17781: LESS
17782: OR
17783: PUSH
17784: LD_VAR 0 8
17788: PUSH
17789: LD_INT 3
17791: ARRAY
17792: PUSH
17793: LD_INT 0
17795: PUSH
17796: LD_INT 8
17798: PUSH
17799: LD_INT 9
17801: PUSH
17802: LD_INT 10
17804: PUSH
17805: LD_INT 11
17807: PUSH
17808: LD_INT 12
17810: PUSH
17811: LD_INT 13
17813: PUSH
17814: LD_INT 16
17816: PUSH
17817: LD_INT 17
17819: PUSH
17820: LD_INT 18
17822: PUSH
17823: LD_INT 19
17825: PUSH
17826: LD_INT 20
17828: PUSH
17829: LD_INT 21
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: LIST
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: IN
17847: NOT
17848: OR
17849: PUSH
17850: LD_VAR 0 8
17854: PUSH
17855: LD_INT 5
17857: ARRAY
17858: NOT
17859: OR
17860: PUSH
17861: LD_VAR 0 8
17865: PUSH
17866: LD_INT 6
17868: ARRAY
17869: PUSH
17870: LD_INT 1
17872: PUSH
17873: LD_INT 2
17875: PUSH
17876: LD_INT 7
17878: PUSH
17879: LD_INT 9
17881: PUSH
17882: LD_INT 10
17884: PUSH
17885: LD_INT 11
17887: PUSH
17888: EMPTY
17889: LIST
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: IN
17896: NOT
17897: OR
17898: IFFALSE 17904
// exit ;
17900: POP
17901: POP
17902: GO 18002
// end ;
17904: GO 17575
17906: POP
17907: POP
// side := GetSide ( depot ) ;
17908: LD_ADDR_VAR 0 9
17912: PUSH
17913: LD_VAR 0 1
17917: PPUSH
17918: CALL_OW 255
17922: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17923: LD_VAR 0 9
17927: PPUSH
17928: LD_VAR 0 3
17932: PPUSH
17933: LD_VAR 0 4
17937: PPUSH
17938: LD_INT 20
17940: PPUSH
17941: CALL 10323 0 4
17945: PUSH
17946: LD_INT 4
17948: ARRAY
17949: IFFALSE 17953
// exit ;
17951: GO 18002
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
17953: LD_VAR 0 2
17957: PUSH
17958: LD_INT 29
17960: PUSH
17961: LD_INT 30
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: IN
17968: PUSH
17969: LD_VAR 0 3
17973: PPUSH
17974: LD_VAR 0 4
17978: PPUSH
17979: LD_VAR 0 9
17983: PPUSH
17984: CALL_OW 440
17988: NOT
17989: AND
17990: IFFALSE 17994
// exit ;
17992: GO 18002
// result := true ;
17994: LD_ADDR_VAR 0 6
17998: PUSH
17999: LD_INT 1
18001: ST_TO_ADDR
// end ;
18002: LD_VAR 0 6
18006: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
18007: LD_INT 0
18009: PPUSH
18010: PPUSH
18011: PPUSH
18012: PPUSH
18013: PPUSH
18014: PPUSH
18015: PPUSH
18016: PPUSH
18017: PPUSH
18018: PPUSH
18019: PPUSH
18020: PPUSH
18021: PPUSH
18022: PPUSH
18023: PPUSH
18024: PPUSH
18025: PPUSH
18026: PPUSH
18027: PPUSH
18028: PPUSH
18029: PPUSH
18030: PPUSH
18031: PPUSH
18032: PPUSH
18033: PPUSH
18034: PPUSH
18035: PPUSH
18036: PPUSH
18037: PPUSH
18038: PPUSH
18039: PPUSH
18040: PPUSH
18041: PPUSH
18042: PPUSH
18043: PPUSH
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
18048: PPUSH
18049: PPUSH
18050: PPUSH
18051: PPUSH
18052: PPUSH
18053: PPUSH
18054: PPUSH
18055: PPUSH
18056: PPUSH
18057: PPUSH
18058: PPUSH
18059: PPUSH
18060: PPUSH
18061: PPUSH
18062: PPUSH
18063: PPUSH
18064: PPUSH
18065: PPUSH
18066: PPUSH
// result = [ ] ;
18067: LD_ADDR_VAR 0 7
18071: PUSH
18072: EMPTY
18073: ST_TO_ADDR
// temp_list = [ ] ;
18074: LD_ADDR_VAR 0 9
18078: PUSH
18079: EMPTY
18080: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
18081: LD_VAR 0 4
18085: PUSH
18086: LD_INT 0
18088: PUSH
18089: LD_INT 1
18091: PUSH
18092: LD_INT 2
18094: PUSH
18095: LD_INT 3
18097: PUSH
18098: LD_INT 4
18100: PUSH
18101: LD_INT 5
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: IN
18112: NOT
18113: PUSH
18114: LD_VAR 0 1
18118: PUSH
18119: LD_INT 0
18121: PUSH
18122: LD_INT 1
18124: PUSH
18125: EMPTY
18126: LIST
18127: LIST
18128: IN
18129: PUSH
18130: LD_VAR 0 5
18134: PUSH
18135: LD_INT 1
18137: PUSH
18138: LD_INT 2
18140: PUSH
18141: LD_INT 3
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: LIST
18148: IN
18149: NOT
18150: AND
18151: OR
18152: IFFALSE 18156
// exit ;
18154: GO 36547
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
18156: LD_VAR 0 1
18160: PUSH
18161: LD_INT 6
18163: PUSH
18164: LD_INT 7
18166: PUSH
18167: LD_INT 8
18169: PUSH
18170: LD_INT 13
18172: PUSH
18173: LD_INT 12
18175: PUSH
18176: LD_INT 15
18178: PUSH
18179: LD_INT 11
18181: PUSH
18182: LD_INT 14
18184: PUSH
18185: LD_INT 10
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: LIST
18192: LIST
18193: LIST
18194: LIST
18195: LIST
18196: LIST
18197: LIST
18198: IN
18199: IFFALSE 18209
// btype = b_lab ;
18201: LD_ADDR_VAR 0 1
18205: PUSH
18206: LD_INT 6
18208: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
18209: LD_VAR 0 6
18213: PUSH
18214: LD_INT 0
18216: PUSH
18217: LD_INT 1
18219: PUSH
18220: LD_INT 2
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: LIST
18227: IN
18228: NOT
18229: PUSH
18230: LD_VAR 0 1
18234: PUSH
18235: LD_INT 0
18237: PUSH
18238: LD_INT 1
18240: PUSH
18241: LD_INT 2
18243: PUSH
18244: LD_INT 3
18246: PUSH
18247: LD_INT 6
18249: PUSH
18250: LD_INT 36
18252: PUSH
18253: LD_INT 4
18255: PUSH
18256: LD_INT 5
18258: PUSH
18259: LD_INT 31
18261: PUSH
18262: LD_INT 32
18264: PUSH
18265: LD_INT 33
18267: PUSH
18268: EMPTY
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: IN
18281: NOT
18282: PUSH
18283: LD_VAR 0 6
18287: PUSH
18288: LD_INT 1
18290: EQUAL
18291: AND
18292: OR
18293: PUSH
18294: LD_VAR 0 1
18298: PUSH
18299: LD_INT 2
18301: PUSH
18302: LD_INT 3
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: IN
18309: NOT
18310: PUSH
18311: LD_VAR 0 6
18315: PUSH
18316: LD_INT 2
18318: EQUAL
18319: AND
18320: OR
18321: IFFALSE 18331
// mode = 0 ;
18323: LD_ADDR_VAR 0 6
18327: PUSH
18328: LD_INT 0
18330: ST_TO_ADDR
// case mode of 0 :
18331: LD_VAR 0 6
18335: PUSH
18336: LD_INT 0
18338: DOUBLE
18339: EQUAL
18340: IFTRUE 18344
18342: GO 29797
18344: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
18345: LD_ADDR_VAR 0 11
18349: PUSH
18350: LD_INT 0
18352: PUSH
18353: LD_INT 0
18355: PUSH
18356: EMPTY
18357: LIST
18358: LIST
18359: PUSH
18360: LD_INT 0
18362: PUSH
18363: LD_INT 1
18365: NEG
18366: PUSH
18367: EMPTY
18368: LIST
18369: LIST
18370: PUSH
18371: LD_INT 1
18373: PUSH
18374: LD_INT 0
18376: PUSH
18377: EMPTY
18378: LIST
18379: LIST
18380: PUSH
18381: LD_INT 1
18383: PUSH
18384: LD_INT 1
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: PUSH
18391: LD_INT 0
18393: PUSH
18394: LD_INT 1
18396: PUSH
18397: EMPTY
18398: LIST
18399: LIST
18400: PUSH
18401: LD_INT 1
18403: NEG
18404: PUSH
18405: LD_INT 0
18407: PUSH
18408: EMPTY
18409: LIST
18410: LIST
18411: PUSH
18412: LD_INT 1
18414: NEG
18415: PUSH
18416: LD_INT 1
18418: NEG
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: PUSH
18424: LD_INT 1
18426: NEG
18427: PUSH
18428: LD_INT 2
18430: NEG
18431: PUSH
18432: EMPTY
18433: LIST
18434: LIST
18435: PUSH
18436: LD_INT 0
18438: PUSH
18439: LD_INT 2
18441: NEG
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 1
18449: PUSH
18450: LD_INT 1
18452: NEG
18453: PUSH
18454: EMPTY
18455: LIST
18456: LIST
18457: PUSH
18458: LD_INT 1
18460: PUSH
18461: LD_INT 2
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: PUSH
18468: LD_INT 0
18470: PUSH
18471: LD_INT 2
18473: PUSH
18474: EMPTY
18475: LIST
18476: LIST
18477: PUSH
18478: LD_INT 1
18480: NEG
18481: PUSH
18482: LD_INT 1
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: PUSH
18489: LD_INT 1
18491: PUSH
18492: LD_INT 3
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: PUSH
18499: LD_INT 0
18501: PUSH
18502: LD_INT 3
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: PUSH
18509: LD_INT 1
18511: NEG
18512: PUSH
18513: LD_INT 2
18515: PUSH
18516: EMPTY
18517: LIST
18518: LIST
18519: PUSH
18520: EMPTY
18521: LIST
18522: LIST
18523: LIST
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: LIST
18536: LIST
18537: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
18538: LD_ADDR_VAR 0 12
18542: PUSH
18543: LD_INT 0
18545: PUSH
18546: LD_INT 0
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: PUSH
18553: LD_INT 0
18555: PUSH
18556: LD_INT 1
18558: NEG
18559: PUSH
18560: EMPTY
18561: LIST
18562: LIST
18563: PUSH
18564: LD_INT 1
18566: PUSH
18567: LD_INT 0
18569: PUSH
18570: EMPTY
18571: LIST
18572: LIST
18573: PUSH
18574: LD_INT 1
18576: PUSH
18577: LD_INT 1
18579: PUSH
18580: EMPTY
18581: LIST
18582: LIST
18583: PUSH
18584: LD_INT 0
18586: PUSH
18587: LD_INT 1
18589: PUSH
18590: EMPTY
18591: LIST
18592: LIST
18593: PUSH
18594: LD_INT 1
18596: NEG
18597: PUSH
18598: LD_INT 0
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: PUSH
18605: LD_INT 1
18607: NEG
18608: PUSH
18609: LD_INT 1
18611: NEG
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: PUSH
18617: LD_INT 1
18619: PUSH
18620: LD_INT 1
18622: NEG
18623: PUSH
18624: EMPTY
18625: LIST
18626: LIST
18627: PUSH
18628: LD_INT 2
18630: PUSH
18631: LD_INT 0
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: PUSH
18638: LD_INT 2
18640: PUSH
18641: LD_INT 1
18643: PUSH
18644: EMPTY
18645: LIST
18646: LIST
18647: PUSH
18648: LD_INT 1
18650: NEG
18651: PUSH
18652: LD_INT 1
18654: PUSH
18655: EMPTY
18656: LIST
18657: LIST
18658: PUSH
18659: LD_INT 2
18661: NEG
18662: PUSH
18663: LD_INT 0
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: LD_INT 2
18672: NEG
18673: PUSH
18674: LD_INT 1
18676: NEG
18677: PUSH
18678: EMPTY
18679: LIST
18680: LIST
18681: PUSH
18682: LD_INT 2
18684: NEG
18685: PUSH
18686: LD_INT 1
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: LD_INT 3
18695: NEG
18696: PUSH
18697: LD_INT 0
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: PUSH
18704: LD_INT 3
18706: NEG
18707: PUSH
18708: LD_INT 1
18710: NEG
18711: PUSH
18712: EMPTY
18713: LIST
18714: LIST
18715: PUSH
18716: EMPTY
18717: LIST
18718: LIST
18719: LIST
18720: LIST
18721: LIST
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: LIST
18728: LIST
18729: LIST
18730: LIST
18731: LIST
18732: LIST
18733: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
18734: LD_ADDR_VAR 0 13
18738: PUSH
18739: LD_INT 0
18741: PUSH
18742: LD_INT 0
18744: PUSH
18745: EMPTY
18746: LIST
18747: LIST
18748: PUSH
18749: LD_INT 0
18751: PUSH
18752: LD_INT 1
18754: NEG
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 1
18762: PUSH
18763: LD_INT 0
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: PUSH
18770: LD_INT 1
18772: PUSH
18773: LD_INT 1
18775: PUSH
18776: EMPTY
18777: LIST
18778: LIST
18779: PUSH
18780: LD_INT 0
18782: PUSH
18783: LD_INT 1
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: PUSH
18790: LD_INT 1
18792: NEG
18793: PUSH
18794: LD_INT 0
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: PUSH
18801: LD_INT 1
18803: NEG
18804: PUSH
18805: LD_INT 1
18807: NEG
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: PUSH
18813: LD_INT 1
18815: NEG
18816: PUSH
18817: LD_INT 2
18819: NEG
18820: PUSH
18821: EMPTY
18822: LIST
18823: LIST
18824: PUSH
18825: LD_INT 2
18827: PUSH
18828: LD_INT 1
18830: PUSH
18831: EMPTY
18832: LIST
18833: LIST
18834: PUSH
18835: LD_INT 2
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: EMPTY
18842: LIST
18843: LIST
18844: PUSH
18845: LD_INT 1
18847: PUSH
18848: LD_INT 2
18850: PUSH
18851: EMPTY
18852: LIST
18853: LIST
18854: PUSH
18855: LD_INT 2
18857: NEG
18858: PUSH
18859: LD_INT 1
18861: NEG
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: PUSH
18867: LD_INT 2
18869: NEG
18870: PUSH
18871: LD_INT 2
18873: NEG
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: PUSH
18879: LD_INT 2
18881: NEG
18882: PUSH
18883: LD_INT 3
18885: NEG
18886: PUSH
18887: EMPTY
18888: LIST
18889: LIST
18890: PUSH
18891: LD_INT 3
18893: NEG
18894: PUSH
18895: LD_INT 2
18897: NEG
18898: PUSH
18899: EMPTY
18900: LIST
18901: LIST
18902: PUSH
18903: LD_INT 3
18905: NEG
18906: PUSH
18907: LD_INT 3
18909: NEG
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: PUSH
18915: EMPTY
18916: LIST
18917: LIST
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: LIST
18925: LIST
18926: LIST
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
18933: LD_ADDR_VAR 0 14
18937: PUSH
18938: LD_INT 0
18940: PUSH
18941: LD_INT 0
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: PUSH
18948: LD_INT 0
18950: PUSH
18951: LD_INT 1
18953: NEG
18954: PUSH
18955: EMPTY
18956: LIST
18957: LIST
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: LD_INT 0
18964: PUSH
18965: EMPTY
18966: LIST
18967: LIST
18968: PUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 1
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PUSH
18979: LD_INT 0
18981: PUSH
18982: LD_INT 1
18984: PUSH
18985: EMPTY
18986: LIST
18987: LIST
18988: PUSH
18989: LD_INT 1
18991: NEG
18992: PUSH
18993: LD_INT 0
18995: PUSH
18996: EMPTY
18997: LIST
18998: LIST
18999: PUSH
19000: LD_INT 1
19002: NEG
19003: PUSH
19004: LD_INT 1
19006: NEG
19007: PUSH
19008: EMPTY
19009: LIST
19010: LIST
19011: PUSH
19012: LD_INT 1
19014: NEG
19015: PUSH
19016: LD_INT 2
19018: NEG
19019: PUSH
19020: EMPTY
19021: LIST
19022: LIST
19023: PUSH
19024: LD_INT 0
19026: PUSH
19027: LD_INT 2
19029: NEG
19030: PUSH
19031: EMPTY
19032: LIST
19033: LIST
19034: PUSH
19035: LD_INT 1
19037: PUSH
19038: LD_INT 1
19040: NEG
19041: PUSH
19042: EMPTY
19043: LIST
19044: LIST
19045: PUSH
19046: LD_INT 1
19048: PUSH
19049: LD_INT 2
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: PUSH
19056: LD_INT 0
19058: PUSH
19059: LD_INT 2
19061: PUSH
19062: EMPTY
19063: LIST
19064: LIST
19065: PUSH
19066: LD_INT 1
19068: NEG
19069: PUSH
19070: LD_INT 1
19072: PUSH
19073: EMPTY
19074: LIST
19075: LIST
19076: PUSH
19077: LD_INT 1
19079: NEG
19080: PUSH
19081: LD_INT 3
19083: NEG
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: PUSH
19089: LD_INT 0
19091: PUSH
19092: LD_INT 3
19094: NEG
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: LD_INT 1
19102: PUSH
19103: LD_INT 2
19105: NEG
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: LIST
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: LIST
19124: LIST
19125: LIST
19126: LIST
19127: LIST
19128: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
19129: LD_ADDR_VAR 0 15
19133: PUSH
19134: LD_INT 0
19136: PUSH
19137: LD_INT 0
19139: PUSH
19140: EMPTY
19141: LIST
19142: LIST
19143: PUSH
19144: LD_INT 0
19146: PUSH
19147: LD_INT 1
19149: NEG
19150: PUSH
19151: EMPTY
19152: LIST
19153: LIST
19154: PUSH
19155: LD_INT 1
19157: PUSH
19158: LD_INT 0
19160: PUSH
19161: EMPTY
19162: LIST
19163: LIST
19164: PUSH
19165: LD_INT 1
19167: PUSH
19168: LD_INT 1
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: PUSH
19175: LD_INT 0
19177: PUSH
19178: LD_INT 1
19180: PUSH
19181: EMPTY
19182: LIST
19183: LIST
19184: PUSH
19185: LD_INT 1
19187: NEG
19188: PUSH
19189: LD_INT 0
19191: PUSH
19192: EMPTY
19193: LIST
19194: LIST
19195: PUSH
19196: LD_INT 1
19198: NEG
19199: PUSH
19200: LD_INT 1
19202: NEG
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: PUSH
19208: LD_INT 1
19210: PUSH
19211: LD_INT 1
19213: NEG
19214: PUSH
19215: EMPTY
19216: LIST
19217: LIST
19218: PUSH
19219: LD_INT 2
19221: PUSH
19222: LD_INT 0
19224: PUSH
19225: EMPTY
19226: LIST
19227: LIST
19228: PUSH
19229: LD_INT 2
19231: PUSH
19232: LD_INT 1
19234: PUSH
19235: EMPTY
19236: LIST
19237: LIST
19238: PUSH
19239: LD_INT 1
19241: NEG
19242: PUSH
19243: LD_INT 1
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: PUSH
19250: LD_INT 2
19252: NEG
19253: PUSH
19254: LD_INT 0
19256: PUSH
19257: EMPTY
19258: LIST
19259: LIST
19260: PUSH
19261: LD_INT 2
19263: NEG
19264: PUSH
19265: LD_INT 1
19267: NEG
19268: PUSH
19269: EMPTY
19270: LIST
19271: LIST
19272: PUSH
19273: LD_INT 2
19275: PUSH
19276: LD_INT 1
19278: NEG
19279: PUSH
19280: EMPTY
19281: LIST
19282: LIST
19283: PUSH
19284: LD_INT 3
19286: PUSH
19287: LD_INT 0
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PUSH
19294: LD_INT 3
19296: PUSH
19297: LD_INT 1
19299: PUSH
19300: EMPTY
19301: LIST
19302: LIST
19303: PUSH
19304: EMPTY
19305: LIST
19306: LIST
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: LIST
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: LIST
19318: LIST
19319: LIST
19320: LIST
19321: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
19322: LD_ADDR_VAR 0 16
19326: PUSH
19327: LD_INT 0
19329: PUSH
19330: LD_INT 0
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: PUSH
19337: LD_INT 0
19339: PUSH
19340: LD_INT 1
19342: NEG
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: PUSH
19348: LD_INT 1
19350: PUSH
19351: LD_INT 0
19353: PUSH
19354: EMPTY
19355: LIST
19356: LIST
19357: PUSH
19358: LD_INT 1
19360: PUSH
19361: LD_INT 1
19363: PUSH
19364: EMPTY
19365: LIST
19366: LIST
19367: PUSH
19368: LD_INT 0
19370: PUSH
19371: LD_INT 1
19373: PUSH
19374: EMPTY
19375: LIST
19376: LIST
19377: PUSH
19378: LD_INT 1
19380: NEG
19381: PUSH
19382: LD_INT 0
19384: PUSH
19385: EMPTY
19386: LIST
19387: LIST
19388: PUSH
19389: LD_INT 1
19391: NEG
19392: PUSH
19393: LD_INT 1
19395: NEG
19396: PUSH
19397: EMPTY
19398: LIST
19399: LIST
19400: PUSH
19401: LD_INT 1
19403: NEG
19404: PUSH
19405: LD_INT 2
19407: NEG
19408: PUSH
19409: EMPTY
19410: LIST
19411: LIST
19412: PUSH
19413: LD_INT 2
19415: PUSH
19416: LD_INT 1
19418: PUSH
19419: EMPTY
19420: LIST
19421: LIST
19422: PUSH
19423: LD_INT 2
19425: PUSH
19426: LD_INT 2
19428: PUSH
19429: EMPTY
19430: LIST
19431: LIST
19432: PUSH
19433: LD_INT 1
19435: PUSH
19436: LD_INT 2
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: PUSH
19443: LD_INT 2
19445: NEG
19446: PUSH
19447: LD_INT 1
19449: NEG
19450: PUSH
19451: EMPTY
19452: LIST
19453: LIST
19454: PUSH
19455: LD_INT 2
19457: NEG
19458: PUSH
19459: LD_INT 2
19461: NEG
19462: PUSH
19463: EMPTY
19464: LIST
19465: LIST
19466: PUSH
19467: LD_INT 3
19469: PUSH
19470: LD_INT 2
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: PUSH
19477: LD_INT 3
19479: PUSH
19480: LD_INT 3
19482: PUSH
19483: EMPTY
19484: LIST
19485: LIST
19486: PUSH
19487: LD_INT 2
19489: PUSH
19490: LD_INT 3
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: LIST
19501: LIST
19502: LIST
19503: LIST
19504: LIST
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: LIST
19513: LIST
19514: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19515: LD_ADDR_VAR 0 17
19519: PUSH
19520: LD_INT 0
19522: PUSH
19523: LD_INT 0
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: PUSH
19530: LD_INT 0
19532: PUSH
19533: LD_INT 1
19535: NEG
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: PUSH
19541: LD_INT 1
19543: PUSH
19544: LD_INT 0
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: PUSH
19551: LD_INT 1
19553: PUSH
19554: LD_INT 1
19556: PUSH
19557: EMPTY
19558: LIST
19559: LIST
19560: PUSH
19561: LD_INT 0
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PUSH
19571: LD_INT 1
19573: NEG
19574: PUSH
19575: LD_INT 0
19577: PUSH
19578: EMPTY
19579: LIST
19580: LIST
19581: PUSH
19582: LD_INT 1
19584: NEG
19585: PUSH
19586: LD_INT 1
19588: NEG
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: PUSH
19594: LD_INT 1
19596: NEG
19597: PUSH
19598: LD_INT 2
19600: NEG
19601: PUSH
19602: EMPTY
19603: LIST
19604: LIST
19605: PUSH
19606: LD_INT 0
19608: PUSH
19609: LD_INT 2
19611: NEG
19612: PUSH
19613: EMPTY
19614: LIST
19615: LIST
19616: PUSH
19617: LD_INT 1
19619: PUSH
19620: LD_INT 1
19622: NEG
19623: PUSH
19624: EMPTY
19625: LIST
19626: LIST
19627: PUSH
19628: LD_INT 2
19630: PUSH
19631: LD_INT 0
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: PUSH
19638: LD_INT 2
19640: PUSH
19641: LD_INT 1
19643: PUSH
19644: EMPTY
19645: LIST
19646: LIST
19647: PUSH
19648: LD_INT 2
19650: PUSH
19651: LD_INT 2
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: PUSH
19658: LD_INT 1
19660: PUSH
19661: LD_INT 2
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: PUSH
19668: LD_INT 0
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: EMPTY
19675: LIST
19676: LIST
19677: PUSH
19678: LD_INT 1
19680: NEG
19681: PUSH
19682: LD_INT 1
19684: PUSH
19685: EMPTY
19686: LIST
19687: LIST
19688: PUSH
19689: LD_INT 2
19691: NEG
19692: PUSH
19693: LD_INT 0
19695: PUSH
19696: EMPTY
19697: LIST
19698: LIST
19699: PUSH
19700: LD_INT 2
19702: NEG
19703: PUSH
19704: LD_INT 1
19706: NEG
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: PUSH
19712: LD_INT 2
19714: NEG
19715: PUSH
19716: LD_INT 2
19718: NEG
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: PUSH
19724: EMPTY
19725: LIST
19726: LIST
19727: LIST
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: LIST
19733: LIST
19734: LIST
19735: LIST
19736: LIST
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19745: LD_ADDR_VAR 0 18
19749: PUSH
19750: LD_INT 0
19752: PUSH
19753: LD_INT 0
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: PUSH
19760: LD_INT 0
19762: PUSH
19763: LD_INT 1
19765: NEG
19766: PUSH
19767: EMPTY
19768: LIST
19769: LIST
19770: PUSH
19771: LD_INT 1
19773: PUSH
19774: LD_INT 0
19776: PUSH
19777: EMPTY
19778: LIST
19779: LIST
19780: PUSH
19781: LD_INT 1
19783: PUSH
19784: LD_INT 1
19786: PUSH
19787: EMPTY
19788: LIST
19789: LIST
19790: PUSH
19791: LD_INT 0
19793: PUSH
19794: LD_INT 1
19796: PUSH
19797: EMPTY
19798: LIST
19799: LIST
19800: PUSH
19801: LD_INT 1
19803: NEG
19804: PUSH
19805: LD_INT 0
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: LD_INT 1
19814: NEG
19815: PUSH
19816: LD_INT 1
19818: NEG
19819: PUSH
19820: EMPTY
19821: LIST
19822: LIST
19823: PUSH
19824: LD_INT 1
19826: NEG
19827: PUSH
19828: LD_INT 2
19830: NEG
19831: PUSH
19832: EMPTY
19833: LIST
19834: LIST
19835: PUSH
19836: LD_INT 0
19838: PUSH
19839: LD_INT 2
19841: NEG
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: PUSH
19847: LD_INT 1
19849: PUSH
19850: LD_INT 1
19852: NEG
19853: PUSH
19854: EMPTY
19855: LIST
19856: LIST
19857: PUSH
19858: LD_INT 2
19860: PUSH
19861: LD_INT 0
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: PUSH
19868: LD_INT 2
19870: PUSH
19871: LD_INT 1
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: PUSH
19878: LD_INT 2
19880: PUSH
19881: LD_INT 2
19883: PUSH
19884: EMPTY
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 1
19890: PUSH
19891: LD_INT 2
19893: PUSH
19894: EMPTY
19895: LIST
19896: LIST
19897: PUSH
19898: LD_INT 0
19900: PUSH
19901: LD_INT 2
19903: PUSH
19904: EMPTY
19905: LIST
19906: LIST
19907: PUSH
19908: LD_INT 1
19910: NEG
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: EMPTY
19916: LIST
19917: LIST
19918: PUSH
19919: LD_INT 2
19921: NEG
19922: PUSH
19923: LD_INT 0
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: PUSH
19930: LD_INT 2
19932: NEG
19933: PUSH
19934: LD_INT 1
19936: NEG
19937: PUSH
19938: EMPTY
19939: LIST
19940: LIST
19941: PUSH
19942: LD_INT 2
19944: NEG
19945: PUSH
19946: LD_INT 2
19948: NEG
19949: PUSH
19950: EMPTY
19951: LIST
19952: LIST
19953: PUSH
19954: EMPTY
19955: LIST
19956: LIST
19957: LIST
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: LIST
19963: LIST
19964: LIST
19965: LIST
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: LIST
19973: LIST
19974: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
19975: LD_ADDR_VAR 0 19
19979: PUSH
19980: LD_INT 0
19982: PUSH
19983: LD_INT 0
19985: PUSH
19986: EMPTY
19987: LIST
19988: LIST
19989: PUSH
19990: LD_INT 0
19992: PUSH
19993: LD_INT 1
19995: NEG
19996: PUSH
19997: EMPTY
19998: LIST
19999: LIST
20000: PUSH
20001: LD_INT 1
20003: PUSH
20004: LD_INT 0
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: PUSH
20011: LD_INT 1
20013: PUSH
20014: LD_INT 1
20016: PUSH
20017: EMPTY
20018: LIST
20019: LIST
20020: PUSH
20021: LD_INT 0
20023: PUSH
20024: LD_INT 1
20026: PUSH
20027: EMPTY
20028: LIST
20029: LIST
20030: PUSH
20031: LD_INT 1
20033: NEG
20034: PUSH
20035: LD_INT 0
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: LD_INT 1
20044: NEG
20045: PUSH
20046: LD_INT 1
20048: NEG
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: PUSH
20054: LD_INT 1
20056: NEG
20057: PUSH
20058: LD_INT 2
20060: NEG
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: PUSH
20066: LD_INT 0
20068: PUSH
20069: LD_INT 2
20071: NEG
20072: PUSH
20073: EMPTY
20074: LIST
20075: LIST
20076: PUSH
20077: LD_INT 1
20079: PUSH
20080: LD_INT 1
20082: NEG
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 0
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 2
20100: PUSH
20101: LD_INT 1
20103: PUSH
20104: EMPTY
20105: LIST
20106: LIST
20107: PUSH
20108: LD_INT 2
20110: PUSH
20111: LD_INT 2
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PUSH
20121: LD_INT 2
20123: PUSH
20124: EMPTY
20125: LIST
20126: LIST
20127: PUSH
20128: LD_INT 0
20130: PUSH
20131: LD_INT 2
20133: PUSH
20134: EMPTY
20135: LIST
20136: LIST
20137: PUSH
20138: LD_INT 1
20140: NEG
20141: PUSH
20142: LD_INT 1
20144: PUSH
20145: EMPTY
20146: LIST
20147: LIST
20148: PUSH
20149: LD_INT 2
20151: NEG
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 2
20162: NEG
20163: PUSH
20164: LD_INT 1
20166: NEG
20167: PUSH
20168: EMPTY
20169: LIST
20170: LIST
20171: PUSH
20172: LD_INT 2
20174: NEG
20175: PUSH
20176: LD_INT 2
20178: NEG
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: LIST
20191: LIST
20192: LIST
20193: LIST
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: LIST
20200: LIST
20201: LIST
20202: LIST
20203: LIST
20204: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20205: LD_ADDR_VAR 0 20
20209: PUSH
20210: LD_INT 0
20212: PUSH
20213: LD_INT 0
20215: PUSH
20216: EMPTY
20217: LIST
20218: LIST
20219: PUSH
20220: LD_INT 0
20222: PUSH
20223: LD_INT 1
20225: NEG
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: PUSH
20231: LD_INT 1
20233: PUSH
20234: LD_INT 0
20236: PUSH
20237: EMPTY
20238: LIST
20239: LIST
20240: PUSH
20241: LD_INT 1
20243: PUSH
20244: LD_INT 1
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: PUSH
20251: LD_INT 0
20253: PUSH
20254: LD_INT 1
20256: PUSH
20257: EMPTY
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 1
20263: NEG
20264: PUSH
20265: LD_INT 0
20267: PUSH
20268: EMPTY
20269: LIST
20270: LIST
20271: PUSH
20272: LD_INT 1
20274: NEG
20275: PUSH
20276: LD_INT 1
20278: NEG
20279: PUSH
20280: EMPTY
20281: LIST
20282: LIST
20283: PUSH
20284: LD_INT 1
20286: NEG
20287: PUSH
20288: LD_INT 2
20290: NEG
20291: PUSH
20292: EMPTY
20293: LIST
20294: LIST
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: LD_INT 2
20301: NEG
20302: PUSH
20303: EMPTY
20304: LIST
20305: LIST
20306: PUSH
20307: LD_INT 1
20309: PUSH
20310: LD_INT 1
20312: NEG
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: LD_INT 2
20320: PUSH
20321: LD_INT 0
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: PUSH
20328: LD_INT 2
20330: PUSH
20331: LD_INT 1
20333: PUSH
20334: EMPTY
20335: LIST
20336: LIST
20337: PUSH
20338: LD_INT 2
20340: PUSH
20341: LD_INT 2
20343: PUSH
20344: EMPTY
20345: LIST
20346: LIST
20347: PUSH
20348: LD_INT 1
20350: PUSH
20351: LD_INT 2
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 0
20360: PUSH
20361: LD_INT 2
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: PUSH
20368: LD_INT 1
20370: NEG
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PUSH
20379: LD_INT 2
20381: NEG
20382: PUSH
20383: LD_INT 0
20385: PUSH
20386: EMPTY
20387: LIST
20388: LIST
20389: PUSH
20390: LD_INT 2
20392: NEG
20393: PUSH
20394: LD_INT 1
20396: NEG
20397: PUSH
20398: EMPTY
20399: LIST
20400: LIST
20401: PUSH
20402: LD_INT 2
20404: NEG
20405: PUSH
20406: LD_INT 2
20408: NEG
20409: PUSH
20410: EMPTY
20411: LIST
20412: LIST
20413: PUSH
20414: EMPTY
20415: LIST
20416: LIST
20417: LIST
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: LIST
20423: LIST
20424: LIST
20425: LIST
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: LIST
20431: LIST
20432: LIST
20433: LIST
20434: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20435: LD_ADDR_VAR 0 21
20439: PUSH
20440: LD_INT 0
20442: PUSH
20443: LD_INT 0
20445: PUSH
20446: EMPTY
20447: LIST
20448: LIST
20449: PUSH
20450: LD_INT 0
20452: PUSH
20453: LD_INT 1
20455: NEG
20456: PUSH
20457: EMPTY
20458: LIST
20459: LIST
20460: PUSH
20461: LD_INT 1
20463: PUSH
20464: LD_INT 0
20466: PUSH
20467: EMPTY
20468: LIST
20469: LIST
20470: PUSH
20471: LD_INT 1
20473: PUSH
20474: LD_INT 1
20476: PUSH
20477: EMPTY
20478: LIST
20479: LIST
20480: PUSH
20481: LD_INT 0
20483: PUSH
20484: LD_INT 1
20486: PUSH
20487: EMPTY
20488: LIST
20489: LIST
20490: PUSH
20491: LD_INT 1
20493: NEG
20494: PUSH
20495: LD_INT 0
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PUSH
20502: LD_INT 1
20504: NEG
20505: PUSH
20506: LD_INT 1
20508: NEG
20509: PUSH
20510: EMPTY
20511: LIST
20512: LIST
20513: PUSH
20514: LD_INT 1
20516: NEG
20517: PUSH
20518: LD_INT 2
20520: NEG
20521: PUSH
20522: EMPTY
20523: LIST
20524: LIST
20525: PUSH
20526: LD_INT 0
20528: PUSH
20529: LD_INT 2
20531: NEG
20532: PUSH
20533: EMPTY
20534: LIST
20535: LIST
20536: PUSH
20537: LD_INT 1
20539: PUSH
20540: LD_INT 1
20542: NEG
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 0
20553: PUSH
20554: EMPTY
20555: LIST
20556: LIST
20557: PUSH
20558: LD_INT 2
20560: PUSH
20561: LD_INT 1
20563: PUSH
20564: EMPTY
20565: LIST
20566: LIST
20567: PUSH
20568: LD_INT 2
20570: PUSH
20571: LD_INT 2
20573: PUSH
20574: EMPTY
20575: LIST
20576: LIST
20577: PUSH
20578: LD_INT 1
20580: PUSH
20581: LD_INT 2
20583: PUSH
20584: EMPTY
20585: LIST
20586: LIST
20587: PUSH
20588: LD_INT 0
20590: PUSH
20591: LD_INT 2
20593: PUSH
20594: EMPTY
20595: LIST
20596: LIST
20597: PUSH
20598: LD_INT 1
20600: NEG
20601: PUSH
20602: LD_INT 1
20604: PUSH
20605: EMPTY
20606: LIST
20607: LIST
20608: PUSH
20609: LD_INT 2
20611: NEG
20612: PUSH
20613: LD_INT 0
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: PUSH
20620: LD_INT 2
20622: NEG
20623: PUSH
20624: LD_INT 1
20626: NEG
20627: PUSH
20628: EMPTY
20629: LIST
20630: LIST
20631: PUSH
20632: LD_INT 2
20634: NEG
20635: PUSH
20636: LD_INT 2
20638: NEG
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: LIST
20650: LIST
20651: LIST
20652: LIST
20653: LIST
20654: LIST
20655: LIST
20656: LIST
20657: LIST
20658: LIST
20659: LIST
20660: LIST
20661: LIST
20662: LIST
20663: LIST
20664: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
20665: LD_ADDR_VAR 0 22
20669: PUSH
20670: LD_INT 0
20672: PUSH
20673: LD_INT 0
20675: PUSH
20676: EMPTY
20677: LIST
20678: LIST
20679: PUSH
20680: LD_INT 0
20682: PUSH
20683: LD_INT 1
20685: NEG
20686: PUSH
20687: EMPTY
20688: LIST
20689: LIST
20690: PUSH
20691: LD_INT 1
20693: PUSH
20694: LD_INT 0
20696: PUSH
20697: EMPTY
20698: LIST
20699: LIST
20700: PUSH
20701: LD_INT 1
20703: PUSH
20704: LD_INT 1
20706: PUSH
20707: EMPTY
20708: LIST
20709: LIST
20710: PUSH
20711: LD_INT 0
20713: PUSH
20714: LD_INT 1
20716: PUSH
20717: EMPTY
20718: LIST
20719: LIST
20720: PUSH
20721: LD_INT 1
20723: NEG
20724: PUSH
20725: LD_INT 0
20727: PUSH
20728: EMPTY
20729: LIST
20730: LIST
20731: PUSH
20732: LD_INT 1
20734: NEG
20735: PUSH
20736: LD_INT 1
20738: NEG
20739: PUSH
20740: EMPTY
20741: LIST
20742: LIST
20743: PUSH
20744: LD_INT 1
20746: NEG
20747: PUSH
20748: LD_INT 2
20750: NEG
20751: PUSH
20752: EMPTY
20753: LIST
20754: LIST
20755: PUSH
20756: LD_INT 0
20758: PUSH
20759: LD_INT 2
20761: NEG
20762: PUSH
20763: EMPTY
20764: LIST
20765: LIST
20766: PUSH
20767: LD_INT 1
20769: PUSH
20770: LD_INT 1
20772: NEG
20773: PUSH
20774: EMPTY
20775: LIST
20776: LIST
20777: PUSH
20778: LD_INT 2
20780: PUSH
20781: LD_INT 0
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: PUSH
20788: LD_INT 2
20790: PUSH
20791: LD_INT 1
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: LD_INT 2
20800: PUSH
20801: LD_INT 2
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: PUSH
20808: LD_INT 1
20810: PUSH
20811: LD_INT 2
20813: PUSH
20814: EMPTY
20815: LIST
20816: LIST
20817: PUSH
20818: LD_INT 0
20820: PUSH
20821: LD_INT 2
20823: PUSH
20824: EMPTY
20825: LIST
20826: LIST
20827: PUSH
20828: LD_INT 1
20830: NEG
20831: PUSH
20832: LD_INT 1
20834: PUSH
20835: EMPTY
20836: LIST
20837: LIST
20838: PUSH
20839: LD_INT 2
20841: NEG
20842: PUSH
20843: LD_INT 0
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PUSH
20850: LD_INT 2
20852: NEG
20853: PUSH
20854: LD_INT 1
20856: NEG
20857: PUSH
20858: EMPTY
20859: LIST
20860: LIST
20861: PUSH
20862: LD_INT 2
20864: NEG
20865: PUSH
20866: LD_INT 2
20868: NEG
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: EMPTY
20875: LIST
20876: LIST
20877: LIST
20878: LIST
20879: LIST
20880: LIST
20881: LIST
20882: LIST
20883: LIST
20884: LIST
20885: LIST
20886: LIST
20887: LIST
20888: LIST
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: LIST
20894: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
20895: LD_ADDR_VAR 0 23
20899: PUSH
20900: LD_INT 0
20902: PUSH
20903: LD_INT 0
20905: PUSH
20906: EMPTY
20907: LIST
20908: LIST
20909: PUSH
20910: LD_INT 0
20912: PUSH
20913: LD_INT 1
20915: NEG
20916: PUSH
20917: EMPTY
20918: LIST
20919: LIST
20920: PUSH
20921: LD_INT 1
20923: PUSH
20924: LD_INT 0
20926: PUSH
20927: EMPTY
20928: LIST
20929: LIST
20930: PUSH
20931: LD_INT 1
20933: PUSH
20934: LD_INT 1
20936: PUSH
20937: EMPTY
20938: LIST
20939: LIST
20940: PUSH
20941: LD_INT 0
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: PUSH
20951: LD_INT 1
20953: NEG
20954: PUSH
20955: LD_INT 0
20957: PUSH
20958: EMPTY
20959: LIST
20960: LIST
20961: PUSH
20962: LD_INT 1
20964: NEG
20965: PUSH
20966: LD_INT 1
20968: NEG
20969: PUSH
20970: EMPTY
20971: LIST
20972: LIST
20973: PUSH
20974: LD_INT 1
20976: NEG
20977: PUSH
20978: LD_INT 2
20980: NEG
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: PUSH
20986: LD_INT 0
20988: PUSH
20989: LD_INT 2
20991: NEG
20992: PUSH
20993: EMPTY
20994: LIST
20995: LIST
20996: PUSH
20997: LD_INT 1
20999: PUSH
21000: LD_INT 1
21002: NEG
21003: PUSH
21004: EMPTY
21005: LIST
21006: LIST
21007: PUSH
21008: LD_INT 2
21010: PUSH
21011: LD_INT 0
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: LD_INT 2
21020: PUSH
21021: LD_INT 1
21023: PUSH
21024: EMPTY
21025: LIST
21026: LIST
21027: PUSH
21028: LD_INT 2
21030: PUSH
21031: LD_INT 2
21033: PUSH
21034: EMPTY
21035: LIST
21036: LIST
21037: PUSH
21038: LD_INT 1
21040: PUSH
21041: LD_INT 2
21043: PUSH
21044: EMPTY
21045: LIST
21046: LIST
21047: PUSH
21048: LD_INT 0
21050: PUSH
21051: LD_INT 2
21053: PUSH
21054: EMPTY
21055: LIST
21056: LIST
21057: PUSH
21058: LD_INT 1
21060: NEG
21061: PUSH
21062: LD_INT 1
21064: PUSH
21065: EMPTY
21066: LIST
21067: LIST
21068: PUSH
21069: LD_INT 2
21071: NEG
21072: PUSH
21073: LD_INT 0
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PUSH
21080: LD_INT 2
21082: NEG
21083: PUSH
21084: LD_INT 1
21086: NEG
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: PUSH
21092: LD_INT 2
21094: NEG
21095: PUSH
21096: LD_INT 2
21098: NEG
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: PUSH
21104: LD_INT 2
21106: NEG
21107: PUSH
21108: LD_INT 3
21110: NEG
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: PUSH
21116: LD_INT 1
21118: NEG
21119: PUSH
21120: LD_INT 3
21122: NEG
21123: PUSH
21124: EMPTY
21125: LIST
21126: LIST
21127: PUSH
21128: LD_INT 1
21130: PUSH
21131: LD_INT 2
21133: NEG
21134: PUSH
21135: EMPTY
21136: LIST
21137: LIST
21138: PUSH
21139: LD_INT 2
21141: PUSH
21142: LD_INT 1
21144: NEG
21145: PUSH
21146: EMPTY
21147: LIST
21148: LIST
21149: PUSH
21150: EMPTY
21151: LIST
21152: LIST
21153: LIST
21154: LIST
21155: LIST
21156: LIST
21157: LIST
21158: LIST
21159: LIST
21160: LIST
21161: LIST
21162: LIST
21163: LIST
21164: LIST
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: LIST
21170: LIST
21171: LIST
21172: LIST
21173: LIST
21174: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
21175: LD_ADDR_VAR 0 24
21179: PUSH
21180: LD_INT 0
21182: PUSH
21183: LD_INT 0
21185: PUSH
21186: EMPTY
21187: LIST
21188: LIST
21189: PUSH
21190: LD_INT 0
21192: PUSH
21193: LD_INT 1
21195: NEG
21196: PUSH
21197: EMPTY
21198: LIST
21199: LIST
21200: PUSH
21201: LD_INT 1
21203: PUSH
21204: LD_INT 0
21206: PUSH
21207: EMPTY
21208: LIST
21209: LIST
21210: PUSH
21211: LD_INT 1
21213: PUSH
21214: LD_INT 1
21216: PUSH
21217: EMPTY
21218: LIST
21219: LIST
21220: PUSH
21221: LD_INT 0
21223: PUSH
21224: LD_INT 1
21226: PUSH
21227: EMPTY
21228: LIST
21229: LIST
21230: PUSH
21231: LD_INT 1
21233: NEG
21234: PUSH
21235: LD_INT 0
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PUSH
21242: LD_INT 1
21244: NEG
21245: PUSH
21246: LD_INT 1
21248: NEG
21249: PUSH
21250: EMPTY
21251: LIST
21252: LIST
21253: PUSH
21254: LD_INT 1
21256: NEG
21257: PUSH
21258: LD_INT 2
21260: NEG
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: PUSH
21266: LD_INT 0
21268: PUSH
21269: LD_INT 2
21271: NEG
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: PUSH
21277: LD_INT 1
21279: PUSH
21280: LD_INT 1
21282: NEG
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: PUSH
21288: LD_INT 2
21290: PUSH
21291: LD_INT 0
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: LD_INT 2
21300: PUSH
21301: LD_INT 1
21303: PUSH
21304: EMPTY
21305: LIST
21306: LIST
21307: PUSH
21308: LD_INT 2
21310: PUSH
21311: LD_INT 2
21313: PUSH
21314: EMPTY
21315: LIST
21316: LIST
21317: PUSH
21318: LD_INT 1
21320: PUSH
21321: LD_INT 2
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: LD_INT 2
21333: PUSH
21334: EMPTY
21335: LIST
21336: LIST
21337: PUSH
21338: LD_INT 1
21340: NEG
21341: PUSH
21342: LD_INT 1
21344: PUSH
21345: EMPTY
21346: LIST
21347: LIST
21348: PUSH
21349: LD_INT 2
21351: NEG
21352: PUSH
21353: LD_INT 0
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: PUSH
21360: LD_INT 2
21362: NEG
21363: PUSH
21364: LD_INT 1
21366: NEG
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: PUSH
21372: LD_INT 2
21374: NEG
21375: PUSH
21376: LD_INT 2
21378: NEG
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: PUSH
21384: LD_INT 1
21386: PUSH
21387: LD_INT 2
21389: NEG
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: LD_INT 2
21397: PUSH
21398: LD_INT 1
21400: NEG
21401: PUSH
21402: EMPTY
21403: LIST
21404: LIST
21405: PUSH
21406: LD_INT 3
21408: PUSH
21409: LD_INT 1
21411: PUSH
21412: EMPTY
21413: LIST
21414: LIST
21415: PUSH
21416: LD_INT 3
21418: PUSH
21419: LD_INT 2
21421: PUSH
21422: EMPTY
21423: LIST
21424: LIST
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: LIST
21430: LIST
21431: LIST
21432: LIST
21433: LIST
21434: LIST
21435: LIST
21436: LIST
21437: LIST
21438: LIST
21439: LIST
21440: LIST
21441: LIST
21442: LIST
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: LIST
21448: LIST
21449: LIST
21450: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
21451: LD_ADDR_VAR 0 25
21455: PUSH
21456: LD_INT 0
21458: PUSH
21459: LD_INT 0
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: PUSH
21466: LD_INT 0
21468: PUSH
21469: LD_INT 1
21471: NEG
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: PUSH
21477: LD_INT 1
21479: PUSH
21480: LD_INT 0
21482: PUSH
21483: EMPTY
21484: LIST
21485: LIST
21486: PUSH
21487: LD_INT 1
21489: PUSH
21490: LD_INT 1
21492: PUSH
21493: EMPTY
21494: LIST
21495: LIST
21496: PUSH
21497: LD_INT 0
21499: PUSH
21500: LD_INT 1
21502: PUSH
21503: EMPTY
21504: LIST
21505: LIST
21506: PUSH
21507: LD_INT 1
21509: NEG
21510: PUSH
21511: LD_INT 0
21513: PUSH
21514: EMPTY
21515: LIST
21516: LIST
21517: PUSH
21518: LD_INT 1
21520: NEG
21521: PUSH
21522: LD_INT 1
21524: NEG
21525: PUSH
21526: EMPTY
21527: LIST
21528: LIST
21529: PUSH
21530: LD_INT 1
21532: NEG
21533: PUSH
21534: LD_INT 2
21536: NEG
21537: PUSH
21538: EMPTY
21539: LIST
21540: LIST
21541: PUSH
21542: LD_INT 0
21544: PUSH
21545: LD_INT 2
21547: NEG
21548: PUSH
21549: EMPTY
21550: LIST
21551: LIST
21552: PUSH
21553: LD_INT 1
21555: PUSH
21556: LD_INT 1
21558: NEG
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: PUSH
21564: LD_INT 2
21566: PUSH
21567: LD_INT 0
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: PUSH
21574: LD_INT 2
21576: PUSH
21577: LD_INT 1
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: PUSH
21584: LD_INT 2
21586: PUSH
21587: LD_INT 2
21589: PUSH
21590: EMPTY
21591: LIST
21592: LIST
21593: PUSH
21594: LD_INT 1
21596: PUSH
21597: LD_INT 2
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: PUSH
21604: LD_INT 0
21606: PUSH
21607: LD_INT 2
21609: PUSH
21610: EMPTY
21611: LIST
21612: LIST
21613: PUSH
21614: LD_INT 1
21616: NEG
21617: PUSH
21618: LD_INT 1
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 2
21627: NEG
21628: PUSH
21629: LD_INT 0
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: PUSH
21636: LD_INT 2
21638: NEG
21639: PUSH
21640: LD_INT 1
21642: NEG
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: LD_INT 2
21650: NEG
21651: PUSH
21652: LD_INT 2
21654: NEG
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: PUSH
21660: LD_INT 3
21662: PUSH
21663: LD_INT 1
21665: PUSH
21666: EMPTY
21667: LIST
21668: LIST
21669: PUSH
21670: LD_INT 3
21672: PUSH
21673: LD_INT 2
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: LD_INT 2
21682: PUSH
21683: LD_INT 3
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: PUSH
21690: LD_INT 1
21692: PUSH
21693: LD_INT 3
21695: PUSH
21696: EMPTY
21697: LIST
21698: LIST
21699: PUSH
21700: EMPTY
21701: LIST
21702: LIST
21703: LIST
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: LIST
21709: LIST
21710: LIST
21711: LIST
21712: LIST
21713: LIST
21714: LIST
21715: LIST
21716: LIST
21717: LIST
21718: LIST
21719: LIST
21720: LIST
21721: LIST
21722: LIST
21723: LIST
21724: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
21725: LD_ADDR_VAR 0 26
21729: PUSH
21730: LD_INT 0
21732: PUSH
21733: LD_INT 0
21735: PUSH
21736: EMPTY
21737: LIST
21738: LIST
21739: PUSH
21740: LD_INT 0
21742: PUSH
21743: LD_INT 1
21745: NEG
21746: PUSH
21747: EMPTY
21748: LIST
21749: LIST
21750: PUSH
21751: LD_INT 1
21753: PUSH
21754: LD_INT 0
21756: PUSH
21757: EMPTY
21758: LIST
21759: LIST
21760: PUSH
21761: LD_INT 1
21763: PUSH
21764: LD_INT 1
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: PUSH
21771: LD_INT 0
21773: PUSH
21774: LD_INT 1
21776: PUSH
21777: EMPTY
21778: LIST
21779: LIST
21780: PUSH
21781: LD_INT 1
21783: NEG
21784: PUSH
21785: LD_INT 0
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: PUSH
21792: LD_INT 1
21794: NEG
21795: PUSH
21796: LD_INT 1
21798: NEG
21799: PUSH
21800: EMPTY
21801: LIST
21802: LIST
21803: PUSH
21804: LD_INT 1
21806: NEG
21807: PUSH
21808: LD_INT 2
21810: NEG
21811: PUSH
21812: EMPTY
21813: LIST
21814: LIST
21815: PUSH
21816: LD_INT 0
21818: PUSH
21819: LD_INT 2
21821: NEG
21822: PUSH
21823: EMPTY
21824: LIST
21825: LIST
21826: PUSH
21827: LD_INT 1
21829: PUSH
21830: LD_INT 1
21832: NEG
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: PUSH
21838: LD_INT 2
21840: PUSH
21841: LD_INT 0
21843: PUSH
21844: EMPTY
21845: LIST
21846: LIST
21847: PUSH
21848: LD_INT 2
21850: PUSH
21851: LD_INT 1
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: PUSH
21858: LD_INT 2
21860: PUSH
21861: LD_INT 2
21863: PUSH
21864: EMPTY
21865: LIST
21866: LIST
21867: PUSH
21868: LD_INT 1
21870: PUSH
21871: LD_INT 2
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: PUSH
21878: LD_INT 0
21880: PUSH
21881: LD_INT 2
21883: PUSH
21884: EMPTY
21885: LIST
21886: LIST
21887: PUSH
21888: LD_INT 1
21890: NEG
21891: PUSH
21892: LD_INT 1
21894: PUSH
21895: EMPTY
21896: LIST
21897: LIST
21898: PUSH
21899: LD_INT 2
21901: NEG
21902: PUSH
21903: LD_INT 0
21905: PUSH
21906: EMPTY
21907: LIST
21908: LIST
21909: PUSH
21910: LD_INT 2
21912: NEG
21913: PUSH
21914: LD_INT 1
21916: NEG
21917: PUSH
21918: EMPTY
21919: LIST
21920: LIST
21921: PUSH
21922: LD_INT 2
21924: NEG
21925: PUSH
21926: LD_INT 2
21928: NEG
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PUSH
21934: LD_INT 2
21936: PUSH
21937: LD_INT 3
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: PUSH
21944: LD_INT 1
21946: PUSH
21947: LD_INT 3
21949: PUSH
21950: EMPTY
21951: LIST
21952: LIST
21953: PUSH
21954: LD_INT 1
21956: NEG
21957: PUSH
21958: LD_INT 2
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: LD_INT 2
21967: NEG
21968: PUSH
21969: LD_INT 1
21971: PUSH
21972: EMPTY
21973: LIST
21974: LIST
21975: PUSH
21976: EMPTY
21977: LIST
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: LIST
21983: LIST
21984: LIST
21985: LIST
21986: LIST
21987: LIST
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: LIST
21997: LIST
21998: LIST
21999: LIST
22000: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
22001: LD_ADDR_VAR 0 27
22005: PUSH
22006: LD_INT 0
22008: PUSH
22009: LD_INT 0
22011: PUSH
22012: EMPTY
22013: LIST
22014: LIST
22015: PUSH
22016: LD_INT 0
22018: PUSH
22019: LD_INT 1
22021: NEG
22022: PUSH
22023: EMPTY
22024: LIST
22025: LIST
22026: PUSH
22027: LD_INT 1
22029: PUSH
22030: LD_INT 0
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: PUSH
22037: LD_INT 1
22039: PUSH
22040: LD_INT 1
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: PUSH
22047: LD_INT 0
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: EMPTY
22054: LIST
22055: LIST
22056: PUSH
22057: LD_INT 1
22059: NEG
22060: PUSH
22061: LD_INT 0
22063: PUSH
22064: EMPTY
22065: LIST
22066: LIST
22067: PUSH
22068: LD_INT 1
22070: NEG
22071: PUSH
22072: LD_INT 1
22074: NEG
22075: PUSH
22076: EMPTY
22077: LIST
22078: LIST
22079: PUSH
22080: LD_INT 1
22082: NEG
22083: PUSH
22084: LD_INT 2
22086: NEG
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: PUSH
22092: LD_INT 0
22094: PUSH
22095: LD_INT 2
22097: NEG
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: PUSH
22103: LD_INT 1
22105: PUSH
22106: LD_INT 1
22108: NEG
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PUSH
22114: LD_INT 2
22116: PUSH
22117: LD_INT 0
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: PUSH
22124: LD_INT 2
22126: PUSH
22127: LD_INT 1
22129: PUSH
22130: EMPTY
22131: LIST
22132: LIST
22133: PUSH
22134: LD_INT 2
22136: PUSH
22137: LD_INT 2
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: PUSH
22144: LD_INT 1
22146: PUSH
22147: LD_INT 2
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: PUSH
22154: LD_INT 0
22156: PUSH
22157: LD_INT 2
22159: PUSH
22160: EMPTY
22161: LIST
22162: LIST
22163: PUSH
22164: LD_INT 1
22166: NEG
22167: PUSH
22168: LD_INT 1
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: PUSH
22175: LD_INT 2
22177: NEG
22178: PUSH
22179: LD_INT 0
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: PUSH
22186: LD_INT 2
22188: NEG
22189: PUSH
22190: LD_INT 1
22192: NEG
22193: PUSH
22194: EMPTY
22195: LIST
22196: LIST
22197: PUSH
22198: LD_INT 2
22200: NEG
22201: PUSH
22202: LD_INT 2
22204: NEG
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: LD_INT 1
22212: NEG
22213: PUSH
22214: LD_INT 2
22216: PUSH
22217: EMPTY
22218: LIST
22219: LIST
22220: PUSH
22221: LD_INT 2
22223: NEG
22224: PUSH
22225: LD_INT 1
22227: PUSH
22228: EMPTY
22229: LIST
22230: LIST
22231: PUSH
22232: LD_INT 3
22234: NEG
22235: PUSH
22236: LD_INT 1
22238: NEG
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: PUSH
22244: LD_INT 3
22246: NEG
22247: PUSH
22248: LD_INT 2
22250: NEG
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: PUSH
22256: EMPTY
22257: LIST
22258: LIST
22259: LIST
22260: LIST
22261: LIST
22262: LIST
22263: LIST
22264: LIST
22265: LIST
22266: LIST
22267: LIST
22268: LIST
22269: LIST
22270: LIST
22271: LIST
22272: LIST
22273: LIST
22274: LIST
22275: LIST
22276: LIST
22277: LIST
22278: LIST
22279: LIST
22280: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
22281: LD_ADDR_VAR 0 28
22285: PUSH
22286: LD_INT 0
22288: PUSH
22289: LD_INT 0
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: PUSH
22296: LD_INT 0
22298: PUSH
22299: LD_INT 1
22301: NEG
22302: PUSH
22303: EMPTY
22304: LIST
22305: LIST
22306: PUSH
22307: LD_INT 1
22309: PUSH
22310: LD_INT 0
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: PUSH
22317: LD_INT 1
22319: PUSH
22320: LD_INT 1
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 0
22329: PUSH
22330: LD_INT 1
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 1
22339: NEG
22340: PUSH
22341: LD_INT 0
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: PUSH
22348: LD_INT 1
22350: NEG
22351: PUSH
22352: LD_INT 1
22354: NEG
22355: PUSH
22356: EMPTY
22357: LIST
22358: LIST
22359: PUSH
22360: LD_INT 1
22362: NEG
22363: PUSH
22364: LD_INT 2
22366: NEG
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: PUSH
22372: LD_INT 0
22374: PUSH
22375: LD_INT 2
22377: NEG
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: PUSH
22383: LD_INT 1
22385: PUSH
22386: LD_INT 1
22388: NEG
22389: PUSH
22390: EMPTY
22391: LIST
22392: LIST
22393: PUSH
22394: LD_INT 2
22396: PUSH
22397: LD_INT 0
22399: PUSH
22400: EMPTY
22401: LIST
22402: LIST
22403: PUSH
22404: LD_INT 2
22406: PUSH
22407: LD_INT 1
22409: PUSH
22410: EMPTY
22411: LIST
22412: LIST
22413: PUSH
22414: LD_INT 2
22416: PUSH
22417: LD_INT 2
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: PUSH
22424: LD_INT 1
22426: PUSH
22427: LD_INT 2
22429: PUSH
22430: EMPTY
22431: LIST
22432: LIST
22433: PUSH
22434: LD_INT 0
22436: PUSH
22437: LD_INT 2
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PUSH
22444: LD_INT 1
22446: NEG
22447: PUSH
22448: LD_INT 1
22450: PUSH
22451: EMPTY
22452: LIST
22453: LIST
22454: PUSH
22455: LD_INT 2
22457: NEG
22458: PUSH
22459: LD_INT 0
22461: PUSH
22462: EMPTY
22463: LIST
22464: LIST
22465: PUSH
22466: LD_INT 2
22468: NEG
22469: PUSH
22470: LD_INT 1
22472: NEG
22473: PUSH
22474: EMPTY
22475: LIST
22476: LIST
22477: PUSH
22478: LD_INT 2
22480: NEG
22481: PUSH
22482: LD_INT 2
22484: NEG
22485: PUSH
22486: EMPTY
22487: LIST
22488: LIST
22489: PUSH
22490: LD_INT 2
22492: NEG
22493: PUSH
22494: LD_INT 3
22496: NEG
22497: PUSH
22498: EMPTY
22499: LIST
22500: LIST
22501: PUSH
22502: LD_INT 1
22504: NEG
22505: PUSH
22506: LD_INT 3
22508: NEG
22509: PUSH
22510: EMPTY
22511: LIST
22512: LIST
22513: PUSH
22514: LD_INT 3
22516: NEG
22517: PUSH
22518: LD_INT 1
22520: NEG
22521: PUSH
22522: EMPTY
22523: LIST
22524: LIST
22525: PUSH
22526: LD_INT 3
22528: NEG
22529: PUSH
22530: LD_INT 2
22532: NEG
22533: PUSH
22534: EMPTY
22535: LIST
22536: LIST
22537: PUSH
22538: EMPTY
22539: LIST
22540: LIST
22541: LIST
22542: LIST
22543: LIST
22544: LIST
22545: LIST
22546: LIST
22547: LIST
22548: LIST
22549: LIST
22550: LIST
22551: LIST
22552: LIST
22553: LIST
22554: LIST
22555: LIST
22556: LIST
22557: LIST
22558: LIST
22559: LIST
22560: LIST
22561: LIST
22562: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
22563: LD_ADDR_VAR 0 29
22567: PUSH
22568: LD_INT 0
22570: PUSH
22571: LD_INT 0
22573: PUSH
22574: EMPTY
22575: LIST
22576: LIST
22577: PUSH
22578: LD_INT 0
22580: PUSH
22581: LD_INT 1
22583: NEG
22584: PUSH
22585: EMPTY
22586: LIST
22587: LIST
22588: PUSH
22589: LD_INT 1
22591: PUSH
22592: LD_INT 0
22594: PUSH
22595: EMPTY
22596: LIST
22597: LIST
22598: PUSH
22599: LD_INT 1
22601: PUSH
22602: LD_INT 1
22604: PUSH
22605: EMPTY
22606: LIST
22607: LIST
22608: PUSH
22609: LD_INT 0
22611: PUSH
22612: LD_INT 1
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: PUSH
22619: LD_INT 1
22621: NEG
22622: PUSH
22623: LD_INT 0
22625: PUSH
22626: EMPTY
22627: LIST
22628: LIST
22629: PUSH
22630: LD_INT 1
22632: NEG
22633: PUSH
22634: LD_INT 1
22636: NEG
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: PUSH
22642: LD_INT 1
22644: NEG
22645: PUSH
22646: LD_INT 2
22648: NEG
22649: PUSH
22650: EMPTY
22651: LIST
22652: LIST
22653: PUSH
22654: LD_INT 0
22656: PUSH
22657: LD_INT 2
22659: NEG
22660: PUSH
22661: EMPTY
22662: LIST
22663: LIST
22664: PUSH
22665: LD_INT 1
22667: PUSH
22668: LD_INT 1
22670: NEG
22671: PUSH
22672: EMPTY
22673: LIST
22674: LIST
22675: PUSH
22676: LD_INT 2
22678: PUSH
22679: LD_INT 0
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: PUSH
22686: LD_INT 2
22688: PUSH
22689: LD_INT 1
22691: PUSH
22692: EMPTY
22693: LIST
22694: LIST
22695: PUSH
22696: LD_INT 1
22698: PUSH
22699: LD_INT 2
22701: PUSH
22702: EMPTY
22703: LIST
22704: LIST
22705: PUSH
22706: LD_INT 0
22708: PUSH
22709: LD_INT 2
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: PUSH
22716: LD_INT 1
22718: NEG
22719: PUSH
22720: LD_INT 1
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: PUSH
22727: LD_INT 2
22729: NEG
22730: PUSH
22731: LD_INT 1
22733: NEG
22734: PUSH
22735: EMPTY
22736: LIST
22737: LIST
22738: PUSH
22739: LD_INT 2
22741: NEG
22742: PUSH
22743: LD_INT 2
22745: NEG
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: LD_INT 2
22753: NEG
22754: PUSH
22755: LD_INT 3
22757: NEG
22758: PUSH
22759: EMPTY
22760: LIST
22761: LIST
22762: PUSH
22763: LD_INT 2
22765: PUSH
22766: LD_INT 1
22768: NEG
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: PUSH
22774: LD_INT 3
22776: PUSH
22777: LD_INT 1
22779: PUSH
22780: EMPTY
22781: LIST
22782: LIST
22783: PUSH
22784: LD_INT 1
22786: PUSH
22787: LD_INT 3
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: PUSH
22794: LD_INT 1
22796: NEG
22797: PUSH
22798: LD_INT 2
22800: PUSH
22801: EMPTY
22802: LIST
22803: LIST
22804: PUSH
22805: LD_INT 3
22807: NEG
22808: PUSH
22809: LD_INT 2
22811: NEG
22812: PUSH
22813: EMPTY
22814: LIST
22815: LIST
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: LIST
22823: LIST
22824: LIST
22825: LIST
22826: LIST
22827: LIST
22828: LIST
22829: LIST
22830: LIST
22831: LIST
22832: LIST
22833: LIST
22834: LIST
22835: LIST
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: LIST
22841: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
22842: LD_ADDR_VAR 0 30
22846: PUSH
22847: LD_INT 0
22849: PUSH
22850: LD_INT 0
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 0
22859: PUSH
22860: LD_INT 1
22862: NEG
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: PUSH
22868: LD_INT 1
22870: PUSH
22871: LD_INT 0
22873: PUSH
22874: EMPTY
22875: LIST
22876: LIST
22877: PUSH
22878: LD_INT 1
22880: PUSH
22881: LD_INT 1
22883: PUSH
22884: EMPTY
22885: LIST
22886: LIST
22887: PUSH
22888: LD_INT 0
22890: PUSH
22891: LD_INT 1
22893: PUSH
22894: EMPTY
22895: LIST
22896: LIST
22897: PUSH
22898: LD_INT 1
22900: NEG
22901: PUSH
22902: LD_INT 0
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: LD_INT 1
22911: NEG
22912: PUSH
22913: LD_INT 1
22915: NEG
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PUSH
22921: LD_INT 1
22923: NEG
22924: PUSH
22925: LD_INT 2
22927: NEG
22928: PUSH
22929: EMPTY
22930: LIST
22931: LIST
22932: PUSH
22933: LD_INT 0
22935: PUSH
22936: LD_INT 2
22938: NEG
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: LD_INT 1
22946: PUSH
22947: LD_INT 1
22949: NEG
22950: PUSH
22951: EMPTY
22952: LIST
22953: LIST
22954: PUSH
22955: LD_INT 2
22957: PUSH
22958: LD_INT 0
22960: PUSH
22961: EMPTY
22962: LIST
22963: LIST
22964: PUSH
22965: LD_INT 2
22967: PUSH
22968: LD_INT 1
22970: PUSH
22971: EMPTY
22972: LIST
22973: LIST
22974: PUSH
22975: LD_INT 2
22977: PUSH
22978: LD_INT 2
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: PUSH
22985: LD_INT 1
22987: PUSH
22988: LD_INT 2
22990: PUSH
22991: EMPTY
22992: LIST
22993: LIST
22994: PUSH
22995: LD_INT 1
22997: NEG
22998: PUSH
22999: LD_INT 1
23001: PUSH
23002: EMPTY
23003: LIST
23004: LIST
23005: PUSH
23006: LD_INT 2
23008: NEG
23009: PUSH
23010: LD_INT 0
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: PUSH
23017: LD_INT 2
23019: NEG
23020: PUSH
23021: LD_INT 1
23023: NEG
23024: PUSH
23025: EMPTY
23026: LIST
23027: LIST
23028: PUSH
23029: LD_INT 1
23031: NEG
23032: PUSH
23033: LD_INT 3
23035: NEG
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: PUSH
23041: LD_INT 1
23043: PUSH
23044: LD_INT 2
23046: NEG
23047: PUSH
23048: EMPTY
23049: LIST
23050: LIST
23051: PUSH
23052: LD_INT 3
23054: PUSH
23055: LD_INT 2
23057: PUSH
23058: EMPTY
23059: LIST
23060: LIST
23061: PUSH
23062: LD_INT 2
23064: PUSH
23065: LD_INT 3
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PUSH
23072: LD_INT 2
23074: NEG
23075: PUSH
23076: LD_INT 1
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: LD_INT 3
23085: NEG
23086: PUSH
23087: LD_INT 1
23089: NEG
23090: PUSH
23091: EMPTY
23092: LIST
23093: LIST
23094: PUSH
23095: EMPTY
23096: LIST
23097: LIST
23098: LIST
23099: LIST
23100: LIST
23101: LIST
23102: LIST
23103: LIST
23104: LIST
23105: LIST
23106: LIST
23107: LIST
23108: LIST
23109: LIST
23110: LIST
23111: LIST
23112: LIST
23113: LIST
23114: LIST
23115: LIST
23116: LIST
23117: LIST
23118: LIST
23119: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23120: LD_ADDR_VAR 0 31
23124: PUSH
23125: LD_INT 0
23127: PUSH
23128: LD_INT 0
23130: PUSH
23131: EMPTY
23132: LIST
23133: LIST
23134: PUSH
23135: LD_INT 0
23137: PUSH
23138: LD_INT 1
23140: NEG
23141: PUSH
23142: EMPTY
23143: LIST
23144: LIST
23145: PUSH
23146: LD_INT 1
23148: PUSH
23149: LD_INT 0
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: PUSH
23156: LD_INT 1
23158: PUSH
23159: LD_INT 1
23161: PUSH
23162: EMPTY
23163: LIST
23164: LIST
23165: PUSH
23166: LD_INT 0
23168: PUSH
23169: LD_INT 1
23171: PUSH
23172: EMPTY
23173: LIST
23174: LIST
23175: PUSH
23176: LD_INT 1
23178: NEG
23179: PUSH
23180: LD_INT 0
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: LD_INT 1
23189: NEG
23190: PUSH
23191: LD_INT 1
23193: NEG
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 1
23201: NEG
23202: PUSH
23203: LD_INT 2
23205: NEG
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: LD_INT 1
23213: PUSH
23214: LD_INT 1
23216: NEG
23217: PUSH
23218: EMPTY
23219: LIST
23220: LIST
23221: PUSH
23222: LD_INT 2
23224: PUSH
23225: LD_INT 0
23227: PUSH
23228: EMPTY
23229: LIST
23230: LIST
23231: PUSH
23232: LD_INT 2
23234: PUSH
23235: LD_INT 1
23237: PUSH
23238: EMPTY
23239: LIST
23240: LIST
23241: PUSH
23242: LD_INT 2
23244: PUSH
23245: LD_INT 2
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PUSH
23252: LD_INT 1
23254: PUSH
23255: LD_INT 2
23257: PUSH
23258: EMPTY
23259: LIST
23260: LIST
23261: PUSH
23262: LD_INT 0
23264: PUSH
23265: LD_INT 2
23267: PUSH
23268: EMPTY
23269: LIST
23270: LIST
23271: PUSH
23272: LD_INT 1
23274: NEG
23275: PUSH
23276: LD_INT 1
23278: PUSH
23279: EMPTY
23280: LIST
23281: LIST
23282: PUSH
23283: LD_INT 2
23285: NEG
23286: PUSH
23287: LD_INT 1
23289: NEG
23290: PUSH
23291: EMPTY
23292: LIST
23293: LIST
23294: PUSH
23295: LD_INT 2
23297: NEG
23298: PUSH
23299: LD_INT 2
23301: NEG
23302: PUSH
23303: EMPTY
23304: LIST
23305: LIST
23306: PUSH
23307: LD_INT 2
23309: NEG
23310: PUSH
23311: LD_INT 3
23313: NEG
23314: PUSH
23315: EMPTY
23316: LIST
23317: LIST
23318: PUSH
23319: LD_INT 2
23321: PUSH
23322: LD_INT 1
23324: NEG
23325: PUSH
23326: EMPTY
23327: LIST
23328: LIST
23329: PUSH
23330: LD_INT 3
23332: PUSH
23333: LD_INT 1
23335: PUSH
23336: EMPTY
23337: LIST
23338: LIST
23339: PUSH
23340: LD_INT 1
23342: PUSH
23343: LD_INT 3
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 1
23352: NEG
23353: PUSH
23354: LD_INT 2
23356: PUSH
23357: EMPTY
23358: LIST
23359: LIST
23360: PUSH
23361: LD_INT 3
23363: NEG
23364: PUSH
23365: LD_INT 2
23367: NEG
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: LIST
23377: LIST
23378: LIST
23379: LIST
23380: LIST
23381: LIST
23382: LIST
23383: LIST
23384: LIST
23385: LIST
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23398: LD_ADDR_VAR 0 32
23402: PUSH
23403: LD_INT 0
23405: PUSH
23406: LD_INT 0
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: PUSH
23413: LD_INT 0
23415: PUSH
23416: LD_INT 1
23418: NEG
23419: PUSH
23420: EMPTY
23421: LIST
23422: LIST
23423: PUSH
23424: LD_INT 1
23426: PUSH
23427: LD_INT 0
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 1
23436: PUSH
23437: LD_INT 1
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 0
23446: PUSH
23447: LD_INT 1
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 1
23456: NEG
23457: PUSH
23458: LD_INT 0
23460: PUSH
23461: EMPTY
23462: LIST
23463: LIST
23464: PUSH
23465: LD_INT 1
23467: NEG
23468: PUSH
23469: LD_INT 1
23471: NEG
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 1
23479: NEG
23480: PUSH
23481: LD_INT 2
23483: NEG
23484: PUSH
23485: EMPTY
23486: LIST
23487: LIST
23488: PUSH
23489: LD_INT 0
23491: PUSH
23492: LD_INT 2
23494: NEG
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: LD_INT 1
23502: PUSH
23503: LD_INT 1
23505: NEG
23506: PUSH
23507: EMPTY
23508: LIST
23509: LIST
23510: PUSH
23511: LD_INT 2
23513: PUSH
23514: LD_INT 1
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: LD_INT 2
23523: PUSH
23524: LD_INT 2
23526: PUSH
23527: EMPTY
23528: LIST
23529: LIST
23530: PUSH
23531: LD_INT 1
23533: PUSH
23534: LD_INT 2
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PUSH
23541: LD_INT 0
23543: PUSH
23544: LD_INT 2
23546: PUSH
23547: EMPTY
23548: LIST
23549: LIST
23550: PUSH
23551: LD_INT 1
23553: NEG
23554: PUSH
23555: LD_INT 1
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 2
23564: NEG
23565: PUSH
23566: LD_INT 0
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PUSH
23573: LD_INT 2
23575: NEG
23576: PUSH
23577: LD_INT 1
23579: NEG
23580: PUSH
23581: EMPTY
23582: LIST
23583: LIST
23584: PUSH
23585: LD_INT 1
23587: NEG
23588: PUSH
23589: LD_INT 3
23591: NEG
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: PUSH
23597: LD_INT 1
23599: PUSH
23600: LD_INT 2
23602: NEG
23603: PUSH
23604: EMPTY
23605: LIST
23606: LIST
23607: PUSH
23608: LD_INT 3
23610: PUSH
23611: LD_INT 2
23613: PUSH
23614: EMPTY
23615: LIST
23616: LIST
23617: PUSH
23618: LD_INT 2
23620: PUSH
23621: LD_INT 3
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: PUSH
23628: LD_INT 2
23630: NEG
23631: PUSH
23632: LD_INT 1
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: LD_INT 3
23641: NEG
23642: PUSH
23643: LD_INT 1
23645: NEG
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: PUSH
23651: EMPTY
23652: LIST
23653: LIST
23654: LIST
23655: LIST
23656: LIST
23657: LIST
23658: LIST
23659: LIST
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: LIST
23665: LIST
23666: LIST
23667: LIST
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
23676: LD_ADDR_VAR 0 33
23680: PUSH
23681: LD_INT 0
23683: PUSH
23684: LD_INT 0
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: PUSH
23691: LD_INT 0
23693: PUSH
23694: LD_INT 1
23696: NEG
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: LD_INT 1
23704: PUSH
23705: LD_INT 0
23707: PUSH
23708: EMPTY
23709: LIST
23710: LIST
23711: PUSH
23712: LD_INT 1
23714: PUSH
23715: LD_INT 1
23717: PUSH
23718: EMPTY
23719: LIST
23720: LIST
23721: PUSH
23722: LD_INT 0
23724: PUSH
23725: LD_INT 1
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: LD_INT 1
23734: NEG
23735: PUSH
23736: LD_INT 0
23738: PUSH
23739: EMPTY
23740: LIST
23741: LIST
23742: PUSH
23743: LD_INT 1
23745: NEG
23746: PUSH
23747: LD_INT 1
23749: NEG
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PUSH
23755: LD_INT 1
23757: NEG
23758: PUSH
23759: LD_INT 2
23761: NEG
23762: PUSH
23763: EMPTY
23764: LIST
23765: LIST
23766: PUSH
23767: LD_INT 1
23769: PUSH
23770: LD_INT 1
23772: NEG
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PUSH
23778: LD_INT 2
23780: PUSH
23781: LD_INT 0
23783: PUSH
23784: EMPTY
23785: LIST
23786: LIST
23787: PUSH
23788: LD_INT 2
23790: PUSH
23791: LD_INT 1
23793: PUSH
23794: EMPTY
23795: LIST
23796: LIST
23797: PUSH
23798: LD_INT 1
23800: PUSH
23801: LD_INT 2
23803: PUSH
23804: EMPTY
23805: LIST
23806: LIST
23807: PUSH
23808: LD_INT 0
23810: PUSH
23811: LD_INT 2
23813: PUSH
23814: EMPTY
23815: LIST
23816: LIST
23817: PUSH
23818: LD_INT 1
23820: NEG
23821: PUSH
23822: LD_INT 1
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 2
23831: NEG
23832: PUSH
23833: LD_INT 0
23835: PUSH
23836: EMPTY
23837: LIST
23838: LIST
23839: PUSH
23840: LD_INT 2
23842: NEG
23843: PUSH
23844: LD_INT 1
23846: NEG
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 2
23854: NEG
23855: PUSH
23856: LD_INT 2
23858: NEG
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 2
23866: NEG
23867: PUSH
23868: LD_INT 3
23870: NEG
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: LD_INT 2
23878: PUSH
23879: LD_INT 1
23881: NEG
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 3
23889: PUSH
23890: LD_INT 1
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: LD_INT 1
23899: PUSH
23900: LD_INT 3
23902: PUSH
23903: EMPTY
23904: LIST
23905: LIST
23906: PUSH
23907: LD_INT 1
23909: NEG
23910: PUSH
23911: LD_INT 2
23913: PUSH
23914: EMPTY
23915: LIST
23916: LIST
23917: PUSH
23918: LD_INT 3
23920: NEG
23921: PUSH
23922: LD_INT 2
23924: NEG
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: LIST
23944: LIST
23945: LIST
23946: LIST
23947: LIST
23948: LIST
23949: LIST
23950: LIST
23951: LIST
23952: LIST
23953: LIST
23954: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
23955: LD_ADDR_VAR 0 34
23959: PUSH
23960: LD_INT 0
23962: PUSH
23963: LD_INT 0
23965: PUSH
23966: EMPTY
23967: LIST
23968: LIST
23969: PUSH
23970: LD_INT 0
23972: PUSH
23973: LD_INT 1
23975: NEG
23976: PUSH
23977: EMPTY
23978: LIST
23979: LIST
23980: PUSH
23981: LD_INT 1
23983: PUSH
23984: LD_INT 0
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 1
23993: PUSH
23994: LD_INT 1
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: PUSH
24001: LD_INT 0
24003: PUSH
24004: LD_INT 1
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: PUSH
24011: LD_INT 1
24013: NEG
24014: PUSH
24015: LD_INT 0
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: LD_INT 1
24024: NEG
24025: PUSH
24026: LD_INT 1
24028: NEG
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PUSH
24034: LD_INT 1
24036: NEG
24037: PUSH
24038: LD_INT 2
24040: NEG
24041: PUSH
24042: EMPTY
24043: LIST
24044: LIST
24045: PUSH
24046: LD_INT 0
24048: PUSH
24049: LD_INT 2
24051: NEG
24052: PUSH
24053: EMPTY
24054: LIST
24055: LIST
24056: PUSH
24057: LD_INT 1
24059: PUSH
24060: LD_INT 1
24062: NEG
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PUSH
24068: LD_INT 2
24070: PUSH
24071: LD_INT 1
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 2
24080: PUSH
24081: LD_INT 2
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 1
24090: PUSH
24091: LD_INT 2
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: LD_INT 1
24100: NEG
24101: PUSH
24102: LD_INT 1
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 2
24111: NEG
24112: PUSH
24113: LD_INT 0
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: LD_INT 2
24122: NEG
24123: PUSH
24124: LD_INT 1
24126: NEG
24127: PUSH
24128: EMPTY
24129: LIST
24130: LIST
24131: PUSH
24132: LD_INT 2
24134: NEG
24135: PUSH
24136: LD_INT 2
24138: NEG
24139: PUSH
24140: EMPTY
24141: LIST
24142: LIST
24143: PUSH
24144: LD_INT 1
24146: NEG
24147: PUSH
24148: LD_INT 3
24150: NEG
24151: PUSH
24152: EMPTY
24153: LIST
24154: LIST
24155: PUSH
24156: LD_INT 1
24158: PUSH
24159: LD_INT 2
24161: NEG
24162: PUSH
24163: EMPTY
24164: LIST
24165: LIST
24166: PUSH
24167: LD_INT 3
24169: PUSH
24170: LD_INT 2
24172: PUSH
24173: EMPTY
24174: LIST
24175: LIST
24176: PUSH
24177: LD_INT 2
24179: PUSH
24180: LD_INT 3
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: LD_INT 2
24189: NEG
24190: PUSH
24191: LD_INT 1
24193: PUSH
24194: EMPTY
24195: LIST
24196: LIST
24197: PUSH
24198: LD_INT 3
24200: NEG
24201: PUSH
24202: LD_INT 1
24204: NEG
24205: PUSH
24206: EMPTY
24207: LIST
24208: LIST
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: LIST
24214: LIST
24215: LIST
24216: LIST
24217: LIST
24218: LIST
24219: LIST
24220: LIST
24221: LIST
24222: LIST
24223: LIST
24224: LIST
24225: LIST
24226: LIST
24227: LIST
24228: LIST
24229: LIST
24230: LIST
24231: LIST
24232: LIST
24233: LIST
24234: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24235: LD_ADDR_VAR 0 35
24239: PUSH
24240: LD_INT 0
24242: PUSH
24243: LD_INT 0
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 0
24252: PUSH
24253: LD_INT 1
24255: NEG
24256: PUSH
24257: EMPTY
24258: LIST
24259: LIST
24260: PUSH
24261: LD_INT 1
24263: PUSH
24264: LD_INT 0
24266: PUSH
24267: EMPTY
24268: LIST
24269: LIST
24270: PUSH
24271: LD_INT 1
24273: PUSH
24274: LD_INT 1
24276: PUSH
24277: EMPTY
24278: LIST
24279: LIST
24280: PUSH
24281: LD_INT 0
24283: PUSH
24284: LD_INT 1
24286: PUSH
24287: EMPTY
24288: LIST
24289: LIST
24290: PUSH
24291: LD_INT 1
24293: NEG
24294: PUSH
24295: LD_INT 0
24297: PUSH
24298: EMPTY
24299: LIST
24300: LIST
24301: PUSH
24302: LD_INT 1
24304: NEG
24305: PUSH
24306: LD_INT 1
24308: NEG
24309: PUSH
24310: EMPTY
24311: LIST
24312: LIST
24313: PUSH
24314: LD_INT 2
24316: PUSH
24317: LD_INT 1
24319: PUSH
24320: EMPTY
24321: LIST
24322: LIST
24323: PUSH
24324: LD_INT 2
24326: NEG
24327: PUSH
24328: LD_INT 1
24330: NEG
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: LIST
24345: LIST
24346: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24347: LD_ADDR_VAR 0 36
24351: PUSH
24352: LD_INT 0
24354: PUSH
24355: LD_INT 0
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 0
24364: PUSH
24365: LD_INT 1
24367: NEG
24368: PUSH
24369: EMPTY
24370: LIST
24371: LIST
24372: PUSH
24373: LD_INT 1
24375: PUSH
24376: LD_INT 0
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PUSH
24383: LD_INT 1
24385: PUSH
24386: LD_INT 1
24388: PUSH
24389: EMPTY
24390: LIST
24391: LIST
24392: PUSH
24393: LD_INT 0
24395: PUSH
24396: LD_INT 1
24398: PUSH
24399: EMPTY
24400: LIST
24401: LIST
24402: PUSH
24403: LD_INT 1
24405: NEG
24406: PUSH
24407: LD_INT 0
24409: PUSH
24410: EMPTY
24411: LIST
24412: LIST
24413: PUSH
24414: LD_INT 1
24416: NEG
24417: PUSH
24418: LD_INT 1
24420: NEG
24421: PUSH
24422: EMPTY
24423: LIST
24424: LIST
24425: PUSH
24426: LD_INT 1
24428: NEG
24429: PUSH
24430: LD_INT 2
24432: NEG
24433: PUSH
24434: EMPTY
24435: LIST
24436: LIST
24437: PUSH
24438: LD_INT 1
24440: PUSH
24441: LD_INT 2
24443: PUSH
24444: EMPTY
24445: LIST
24446: LIST
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: LIST
24452: LIST
24453: LIST
24454: LIST
24455: LIST
24456: LIST
24457: LIST
24458: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24459: LD_ADDR_VAR 0 37
24463: PUSH
24464: LD_INT 0
24466: PUSH
24467: LD_INT 0
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 0
24476: PUSH
24477: LD_INT 1
24479: NEG
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: PUSH
24485: LD_INT 1
24487: PUSH
24488: LD_INT 0
24490: PUSH
24491: EMPTY
24492: LIST
24493: LIST
24494: PUSH
24495: LD_INT 1
24497: PUSH
24498: LD_INT 1
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: PUSH
24505: LD_INT 0
24507: PUSH
24508: LD_INT 1
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 1
24517: NEG
24518: PUSH
24519: LD_INT 0
24521: PUSH
24522: EMPTY
24523: LIST
24524: LIST
24525: PUSH
24526: LD_INT 1
24528: NEG
24529: PUSH
24530: LD_INT 1
24532: NEG
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: PUSH
24538: LD_INT 1
24540: PUSH
24541: LD_INT 1
24543: NEG
24544: PUSH
24545: EMPTY
24546: LIST
24547: LIST
24548: PUSH
24549: LD_INT 1
24551: NEG
24552: PUSH
24553: LD_INT 1
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: LIST
24567: LIST
24568: LIST
24569: LIST
24570: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
24571: LD_ADDR_VAR 0 38
24575: PUSH
24576: LD_INT 0
24578: PUSH
24579: LD_INT 0
24581: PUSH
24582: EMPTY
24583: LIST
24584: LIST
24585: PUSH
24586: LD_INT 0
24588: PUSH
24589: LD_INT 1
24591: NEG
24592: PUSH
24593: EMPTY
24594: LIST
24595: LIST
24596: PUSH
24597: LD_INT 1
24599: PUSH
24600: LD_INT 0
24602: PUSH
24603: EMPTY
24604: LIST
24605: LIST
24606: PUSH
24607: LD_INT 1
24609: PUSH
24610: LD_INT 1
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PUSH
24617: LD_INT 0
24619: PUSH
24620: LD_INT 1
24622: PUSH
24623: EMPTY
24624: LIST
24625: LIST
24626: PUSH
24627: LD_INT 1
24629: NEG
24630: PUSH
24631: LD_INT 0
24633: PUSH
24634: EMPTY
24635: LIST
24636: LIST
24637: PUSH
24638: LD_INT 1
24640: NEG
24641: PUSH
24642: LD_INT 1
24644: NEG
24645: PUSH
24646: EMPTY
24647: LIST
24648: LIST
24649: PUSH
24650: LD_INT 2
24652: PUSH
24653: LD_INT 1
24655: PUSH
24656: EMPTY
24657: LIST
24658: LIST
24659: PUSH
24660: LD_INT 2
24662: NEG
24663: PUSH
24664: LD_INT 1
24666: NEG
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: PUSH
24672: EMPTY
24673: LIST
24674: LIST
24675: LIST
24676: LIST
24677: LIST
24678: LIST
24679: LIST
24680: LIST
24681: LIST
24682: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
24683: LD_ADDR_VAR 0 39
24687: PUSH
24688: LD_INT 0
24690: PUSH
24691: LD_INT 0
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: PUSH
24698: LD_INT 0
24700: PUSH
24701: LD_INT 1
24703: NEG
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 1
24711: PUSH
24712: LD_INT 0
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: PUSH
24719: LD_INT 1
24721: PUSH
24722: LD_INT 1
24724: PUSH
24725: EMPTY
24726: LIST
24727: LIST
24728: PUSH
24729: LD_INT 0
24731: PUSH
24732: LD_INT 1
24734: PUSH
24735: EMPTY
24736: LIST
24737: LIST
24738: PUSH
24739: LD_INT 1
24741: NEG
24742: PUSH
24743: LD_INT 0
24745: PUSH
24746: EMPTY
24747: LIST
24748: LIST
24749: PUSH
24750: LD_INT 1
24752: NEG
24753: PUSH
24754: LD_INT 1
24756: NEG
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PUSH
24762: LD_INT 1
24764: NEG
24765: PUSH
24766: LD_INT 2
24768: NEG
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 1
24776: PUSH
24777: LD_INT 2
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: LIST
24789: LIST
24790: LIST
24791: LIST
24792: LIST
24793: LIST
24794: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
24795: LD_ADDR_VAR 0 40
24799: PUSH
24800: LD_INT 0
24802: PUSH
24803: LD_INT 0
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 0
24812: PUSH
24813: LD_INT 1
24815: NEG
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: LD_INT 0
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: PUSH
24831: LD_INT 1
24833: PUSH
24834: LD_INT 1
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 0
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: LD_INT 1
24853: NEG
24854: PUSH
24855: LD_INT 0
24857: PUSH
24858: EMPTY
24859: LIST
24860: LIST
24861: PUSH
24862: LD_INT 1
24864: NEG
24865: PUSH
24866: LD_INT 1
24868: NEG
24869: PUSH
24870: EMPTY
24871: LIST
24872: LIST
24873: PUSH
24874: LD_INT 1
24876: PUSH
24877: LD_INT 1
24879: NEG
24880: PUSH
24881: EMPTY
24882: LIST
24883: LIST
24884: PUSH
24885: LD_INT 1
24887: NEG
24888: PUSH
24889: LD_INT 1
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: LIST
24900: LIST
24901: LIST
24902: LIST
24903: LIST
24904: LIST
24905: LIST
24906: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
24907: LD_ADDR_VAR 0 41
24911: PUSH
24912: LD_INT 0
24914: PUSH
24915: LD_INT 0
24917: PUSH
24918: EMPTY
24919: LIST
24920: LIST
24921: PUSH
24922: LD_INT 0
24924: PUSH
24925: LD_INT 1
24927: NEG
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: LD_INT 1
24935: PUSH
24936: LD_INT 0
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PUSH
24943: LD_INT 1
24945: PUSH
24946: LD_INT 1
24948: PUSH
24949: EMPTY
24950: LIST
24951: LIST
24952: PUSH
24953: LD_INT 0
24955: PUSH
24956: LD_INT 1
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PUSH
24963: LD_INT 1
24965: NEG
24966: PUSH
24967: LD_INT 0
24969: PUSH
24970: EMPTY
24971: LIST
24972: LIST
24973: PUSH
24974: LD_INT 1
24976: NEG
24977: PUSH
24978: LD_INT 1
24980: NEG
24981: PUSH
24982: EMPTY
24983: LIST
24984: LIST
24985: PUSH
24986: LD_INT 1
24988: NEG
24989: PUSH
24990: LD_INT 2
24992: NEG
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PUSH
24998: LD_INT 1
25000: PUSH
25001: LD_INT 1
25003: NEG
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 2
25011: PUSH
25012: LD_INT 0
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: LD_INT 2
25021: PUSH
25022: LD_INT 1
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: LD_INT 2
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PUSH
25039: LD_INT 1
25041: PUSH
25042: LD_INT 2
25044: PUSH
25045: EMPTY
25046: LIST
25047: LIST
25048: PUSH
25049: LD_INT 1
25051: NEG
25052: PUSH
25053: LD_INT 1
25055: PUSH
25056: EMPTY
25057: LIST
25058: LIST
25059: PUSH
25060: LD_INT 2
25062: NEG
25063: PUSH
25064: LD_INT 0
25066: PUSH
25067: EMPTY
25068: LIST
25069: LIST
25070: PUSH
25071: LD_INT 2
25073: NEG
25074: PUSH
25075: LD_INT 1
25077: NEG
25078: PUSH
25079: EMPTY
25080: LIST
25081: LIST
25082: PUSH
25083: LD_INT 2
25085: NEG
25086: PUSH
25087: LD_INT 2
25089: NEG
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 2
25097: NEG
25098: PUSH
25099: LD_INT 3
25101: NEG
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: LD_INT 2
25109: PUSH
25110: LD_INT 1
25112: NEG
25113: PUSH
25114: EMPTY
25115: LIST
25116: LIST
25117: PUSH
25118: LD_INT 3
25120: PUSH
25121: LD_INT 0
25123: PUSH
25124: EMPTY
25125: LIST
25126: LIST
25127: PUSH
25128: LD_INT 3
25130: PUSH
25131: LD_INT 1
25133: PUSH
25134: EMPTY
25135: LIST
25136: LIST
25137: PUSH
25138: LD_INT 3
25140: PUSH
25141: LD_INT 2
25143: PUSH
25144: EMPTY
25145: LIST
25146: LIST
25147: PUSH
25148: LD_INT 3
25150: PUSH
25151: LD_INT 3
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 2
25160: PUSH
25161: LD_INT 3
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 2
25170: NEG
25171: PUSH
25172: LD_INT 1
25174: PUSH
25175: EMPTY
25176: LIST
25177: LIST
25178: PUSH
25179: LD_INT 3
25181: NEG
25182: PUSH
25183: LD_INT 0
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: PUSH
25190: LD_INT 3
25192: NEG
25193: PUSH
25194: LD_INT 1
25196: NEG
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: PUSH
25202: LD_INT 3
25204: NEG
25205: PUSH
25206: LD_INT 2
25208: NEG
25209: PUSH
25210: EMPTY
25211: LIST
25212: LIST
25213: PUSH
25214: LD_INT 3
25216: NEG
25217: PUSH
25218: LD_INT 3
25220: NEG
25221: PUSH
25222: EMPTY
25223: LIST
25224: LIST
25225: PUSH
25226: EMPTY
25227: LIST
25228: LIST
25229: LIST
25230: LIST
25231: LIST
25232: LIST
25233: LIST
25234: LIST
25235: LIST
25236: LIST
25237: LIST
25238: LIST
25239: LIST
25240: LIST
25241: LIST
25242: LIST
25243: LIST
25244: LIST
25245: LIST
25246: LIST
25247: LIST
25248: LIST
25249: LIST
25250: LIST
25251: LIST
25252: LIST
25253: LIST
25254: LIST
25255: LIST
25256: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25257: LD_ADDR_VAR 0 42
25261: PUSH
25262: LD_INT 0
25264: PUSH
25265: LD_INT 0
25267: PUSH
25268: EMPTY
25269: LIST
25270: LIST
25271: PUSH
25272: LD_INT 0
25274: PUSH
25275: LD_INT 1
25277: NEG
25278: PUSH
25279: EMPTY
25280: LIST
25281: LIST
25282: PUSH
25283: LD_INT 1
25285: PUSH
25286: LD_INT 0
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 1
25295: PUSH
25296: LD_INT 1
25298: PUSH
25299: EMPTY
25300: LIST
25301: LIST
25302: PUSH
25303: LD_INT 0
25305: PUSH
25306: LD_INT 1
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: PUSH
25313: LD_INT 1
25315: NEG
25316: PUSH
25317: LD_INT 0
25319: PUSH
25320: EMPTY
25321: LIST
25322: LIST
25323: PUSH
25324: LD_INT 1
25326: NEG
25327: PUSH
25328: LD_INT 1
25330: NEG
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: PUSH
25336: LD_INT 1
25338: NEG
25339: PUSH
25340: LD_INT 2
25342: NEG
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: LD_INT 0
25350: PUSH
25351: LD_INT 2
25353: NEG
25354: PUSH
25355: EMPTY
25356: LIST
25357: LIST
25358: PUSH
25359: LD_INT 1
25361: PUSH
25362: LD_INT 1
25364: NEG
25365: PUSH
25366: EMPTY
25367: LIST
25368: LIST
25369: PUSH
25370: LD_INT 2
25372: PUSH
25373: LD_INT 1
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: PUSH
25380: LD_INT 2
25382: PUSH
25383: LD_INT 2
25385: PUSH
25386: EMPTY
25387: LIST
25388: LIST
25389: PUSH
25390: LD_INT 1
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: PUSH
25400: LD_INT 0
25402: PUSH
25403: LD_INT 2
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: PUSH
25410: LD_INT 1
25412: NEG
25413: PUSH
25414: LD_INT 1
25416: PUSH
25417: EMPTY
25418: LIST
25419: LIST
25420: PUSH
25421: LD_INT 2
25423: NEG
25424: PUSH
25425: LD_INT 1
25427: NEG
25428: PUSH
25429: EMPTY
25430: LIST
25431: LIST
25432: PUSH
25433: LD_INT 2
25435: NEG
25436: PUSH
25437: LD_INT 2
25439: NEG
25440: PUSH
25441: EMPTY
25442: LIST
25443: LIST
25444: PUSH
25445: LD_INT 2
25447: NEG
25448: PUSH
25449: LD_INT 3
25451: NEG
25452: PUSH
25453: EMPTY
25454: LIST
25455: LIST
25456: PUSH
25457: LD_INT 1
25459: NEG
25460: PUSH
25461: LD_INT 3
25463: NEG
25464: PUSH
25465: EMPTY
25466: LIST
25467: LIST
25468: PUSH
25469: LD_INT 0
25471: PUSH
25472: LD_INT 3
25474: NEG
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PUSH
25480: LD_INT 1
25482: PUSH
25483: LD_INT 2
25485: NEG
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 3
25493: PUSH
25494: LD_INT 2
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 3
25503: PUSH
25504: LD_INT 3
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: PUSH
25511: LD_INT 2
25513: PUSH
25514: LD_INT 3
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: PUSH
25521: LD_INT 1
25523: PUSH
25524: LD_INT 3
25526: PUSH
25527: EMPTY
25528: LIST
25529: LIST
25530: PUSH
25531: LD_INT 0
25533: PUSH
25534: LD_INT 3
25536: PUSH
25537: EMPTY
25538: LIST
25539: LIST
25540: PUSH
25541: LD_INT 1
25543: NEG
25544: PUSH
25545: LD_INT 2
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 3
25554: NEG
25555: PUSH
25556: LD_INT 2
25558: NEG
25559: PUSH
25560: EMPTY
25561: LIST
25562: LIST
25563: PUSH
25564: LD_INT 3
25566: NEG
25567: PUSH
25568: LD_INT 3
25570: NEG
25571: PUSH
25572: EMPTY
25573: LIST
25574: LIST
25575: PUSH
25576: EMPTY
25577: LIST
25578: LIST
25579: LIST
25580: LIST
25581: LIST
25582: LIST
25583: LIST
25584: LIST
25585: LIST
25586: LIST
25587: LIST
25588: LIST
25589: LIST
25590: LIST
25591: LIST
25592: LIST
25593: LIST
25594: LIST
25595: LIST
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: LIST
25601: LIST
25602: LIST
25603: LIST
25604: LIST
25605: LIST
25606: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
25607: LD_ADDR_VAR 0 43
25611: PUSH
25612: LD_INT 0
25614: PUSH
25615: LD_INT 0
25617: PUSH
25618: EMPTY
25619: LIST
25620: LIST
25621: PUSH
25622: LD_INT 0
25624: PUSH
25625: LD_INT 1
25627: NEG
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: PUSH
25633: LD_INT 1
25635: PUSH
25636: LD_INT 0
25638: PUSH
25639: EMPTY
25640: LIST
25641: LIST
25642: PUSH
25643: LD_INT 1
25645: PUSH
25646: LD_INT 1
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: LD_INT 0
25655: PUSH
25656: LD_INT 1
25658: PUSH
25659: EMPTY
25660: LIST
25661: LIST
25662: PUSH
25663: LD_INT 1
25665: NEG
25666: PUSH
25667: LD_INT 0
25669: PUSH
25670: EMPTY
25671: LIST
25672: LIST
25673: PUSH
25674: LD_INT 1
25676: NEG
25677: PUSH
25678: LD_INT 1
25680: NEG
25681: PUSH
25682: EMPTY
25683: LIST
25684: LIST
25685: PUSH
25686: LD_INT 1
25688: NEG
25689: PUSH
25690: LD_INT 2
25692: NEG
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: PUSH
25698: LD_INT 0
25700: PUSH
25701: LD_INT 2
25703: NEG
25704: PUSH
25705: EMPTY
25706: LIST
25707: LIST
25708: PUSH
25709: LD_INT 1
25711: PUSH
25712: LD_INT 1
25714: NEG
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 2
25722: PUSH
25723: LD_INT 0
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 2
25732: PUSH
25733: LD_INT 1
25735: PUSH
25736: EMPTY
25737: LIST
25738: LIST
25739: PUSH
25740: LD_INT 1
25742: PUSH
25743: LD_INT 2
25745: PUSH
25746: EMPTY
25747: LIST
25748: LIST
25749: PUSH
25750: LD_INT 0
25752: PUSH
25753: LD_INT 2
25755: PUSH
25756: EMPTY
25757: LIST
25758: LIST
25759: PUSH
25760: LD_INT 1
25762: NEG
25763: PUSH
25764: LD_INT 1
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: PUSH
25771: LD_INT 2
25773: NEG
25774: PUSH
25775: LD_INT 0
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: PUSH
25782: LD_INT 2
25784: NEG
25785: PUSH
25786: LD_INT 1
25788: NEG
25789: PUSH
25790: EMPTY
25791: LIST
25792: LIST
25793: PUSH
25794: LD_INT 1
25796: NEG
25797: PUSH
25798: LD_INT 3
25800: NEG
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 0
25808: PUSH
25809: LD_INT 3
25811: NEG
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: PUSH
25820: LD_INT 2
25822: NEG
25823: PUSH
25824: EMPTY
25825: LIST
25826: LIST
25827: PUSH
25828: LD_INT 2
25830: PUSH
25831: LD_INT 1
25833: NEG
25834: PUSH
25835: EMPTY
25836: LIST
25837: LIST
25838: PUSH
25839: LD_INT 3
25841: PUSH
25842: LD_INT 0
25844: PUSH
25845: EMPTY
25846: LIST
25847: LIST
25848: PUSH
25849: LD_INT 3
25851: PUSH
25852: LD_INT 1
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: LD_INT 1
25861: PUSH
25862: LD_INT 3
25864: PUSH
25865: EMPTY
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 0
25871: PUSH
25872: LD_INT 3
25874: PUSH
25875: EMPTY
25876: LIST
25877: LIST
25878: PUSH
25879: LD_INT 1
25881: NEG
25882: PUSH
25883: LD_INT 2
25885: PUSH
25886: EMPTY
25887: LIST
25888: LIST
25889: PUSH
25890: LD_INT 2
25892: NEG
25893: PUSH
25894: LD_INT 1
25896: PUSH
25897: EMPTY
25898: LIST
25899: LIST
25900: PUSH
25901: LD_INT 3
25903: NEG
25904: PUSH
25905: LD_INT 0
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: PUSH
25912: LD_INT 3
25914: NEG
25915: PUSH
25916: LD_INT 1
25918: NEG
25919: PUSH
25920: EMPTY
25921: LIST
25922: LIST
25923: PUSH
25924: EMPTY
25925: LIST
25926: LIST
25927: LIST
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: LIST
25933: LIST
25934: LIST
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: LIST
25940: LIST
25941: LIST
25942: LIST
25943: LIST
25944: LIST
25945: LIST
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: LIST
25951: LIST
25952: LIST
25953: LIST
25954: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
25955: LD_ADDR_VAR 0 44
25959: PUSH
25960: LD_INT 0
25962: PUSH
25963: LD_INT 0
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: PUSH
25970: LD_INT 0
25972: PUSH
25973: LD_INT 1
25975: NEG
25976: PUSH
25977: EMPTY
25978: LIST
25979: LIST
25980: PUSH
25981: LD_INT 1
25983: PUSH
25984: LD_INT 0
25986: PUSH
25987: EMPTY
25988: LIST
25989: LIST
25990: PUSH
25991: LD_INT 1
25993: PUSH
25994: LD_INT 1
25996: PUSH
25997: EMPTY
25998: LIST
25999: LIST
26000: PUSH
26001: LD_INT 0
26003: PUSH
26004: LD_INT 1
26006: PUSH
26007: EMPTY
26008: LIST
26009: LIST
26010: PUSH
26011: LD_INT 1
26013: NEG
26014: PUSH
26015: LD_INT 0
26017: PUSH
26018: EMPTY
26019: LIST
26020: LIST
26021: PUSH
26022: LD_INT 1
26024: NEG
26025: PUSH
26026: LD_INT 1
26028: NEG
26029: PUSH
26030: EMPTY
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 1
26036: NEG
26037: PUSH
26038: LD_INT 2
26040: NEG
26041: PUSH
26042: EMPTY
26043: LIST
26044: LIST
26045: PUSH
26046: LD_INT 1
26048: PUSH
26049: LD_INT 1
26051: NEG
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 2
26059: PUSH
26060: LD_INT 0
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 2
26069: PUSH
26070: LD_INT 1
26072: PUSH
26073: EMPTY
26074: LIST
26075: LIST
26076: PUSH
26077: LD_INT 2
26079: PUSH
26080: LD_INT 2
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 2
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 1
26099: NEG
26100: PUSH
26101: LD_INT 1
26103: PUSH
26104: EMPTY
26105: LIST
26106: LIST
26107: PUSH
26108: LD_INT 2
26110: NEG
26111: PUSH
26112: LD_INT 0
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: PUSH
26119: LD_INT 2
26121: NEG
26122: PUSH
26123: LD_INT 1
26125: NEG
26126: PUSH
26127: EMPTY
26128: LIST
26129: LIST
26130: PUSH
26131: LD_INT 2
26133: NEG
26134: PUSH
26135: LD_INT 2
26137: NEG
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 2
26145: NEG
26146: PUSH
26147: LD_INT 3
26149: NEG
26150: PUSH
26151: EMPTY
26152: LIST
26153: LIST
26154: PUSH
26155: LD_INT 2
26157: PUSH
26158: LD_INT 1
26160: NEG
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: LD_INT 3
26168: PUSH
26169: LD_INT 0
26171: PUSH
26172: EMPTY
26173: LIST
26174: LIST
26175: PUSH
26176: LD_INT 3
26178: PUSH
26179: LD_INT 1
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: PUSH
26186: LD_INT 3
26188: PUSH
26189: LD_INT 2
26191: PUSH
26192: EMPTY
26193: LIST
26194: LIST
26195: PUSH
26196: LD_INT 3
26198: PUSH
26199: LD_INT 3
26201: PUSH
26202: EMPTY
26203: LIST
26204: LIST
26205: PUSH
26206: LD_INT 2
26208: PUSH
26209: LD_INT 3
26211: PUSH
26212: EMPTY
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 2
26218: NEG
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: EMPTY
26224: LIST
26225: LIST
26226: PUSH
26227: LD_INT 3
26229: NEG
26230: PUSH
26231: LD_INT 0
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: PUSH
26238: LD_INT 3
26240: NEG
26241: PUSH
26242: LD_INT 1
26244: NEG
26245: PUSH
26246: EMPTY
26247: LIST
26248: LIST
26249: PUSH
26250: LD_INT 3
26252: NEG
26253: PUSH
26254: LD_INT 2
26256: NEG
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 3
26264: NEG
26265: PUSH
26266: LD_INT 3
26268: NEG
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: LIST
26281: LIST
26282: LIST
26283: LIST
26284: LIST
26285: LIST
26286: LIST
26287: LIST
26288: LIST
26289: LIST
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: LIST
26295: LIST
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: LIST
26304: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26305: LD_ADDR_VAR 0 45
26309: PUSH
26310: LD_INT 0
26312: PUSH
26313: LD_INT 0
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: PUSH
26320: LD_INT 0
26322: PUSH
26323: LD_INT 1
26325: NEG
26326: PUSH
26327: EMPTY
26328: LIST
26329: LIST
26330: PUSH
26331: LD_INT 1
26333: PUSH
26334: LD_INT 0
26336: PUSH
26337: EMPTY
26338: LIST
26339: LIST
26340: PUSH
26341: LD_INT 1
26343: PUSH
26344: LD_INT 1
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PUSH
26351: LD_INT 0
26353: PUSH
26354: LD_INT 1
26356: PUSH
26357: EMPTY
26358: LIST
26359: LIST
26360: PUSH
26361: LD_INT 1
26363: NEG
26364: PUSH
26365: LD_INT 0
26367: PUSH
26368: EMPTY
26369: LIST
26370: LIST
26371: PUSH
26372: LD_INT 1
26374: NEG
26375: PUSH
26376: LD_INT 1
26378: NEG
26379: PUSH
26380: EMPTY
26381: LIST
26382: LIST
26383: PUSH
26384: LD_INT 1
26386: NEG
26387: PUSH
26388: LD_INT 2
26390: NEG
26391: PUSH
26392: EMPTY
26393: LIST
26394: LIST
26395: PUSH
26396: LD_INT 0
26398: PUSH
26399: LD_INT 2
26401: NEG
26402: PUSH
26403: EMPTY
26404: LIST
26405: LIST
26406: PUSH
26407: LD_INT 1
26409: PUSH
26410: LD_INT 1
26412: NEG
26413: PUSH
26414: EMPTY
26415: LIST
26416: LIST
26417: PUSH
26418: LD_INT 2
26420: PUSH
26421: LD_INT 1
26423: PUSH
26424: EMPTY
26425: LIST
26426: LIST
26427: PUSH
26428: LD_INT 2
26430: PUSH
26431: LD_INT 2
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: LD_INT 1
26440: PUSH
26441: LD_INT 2
26443: PUSH
26444: EMPTY
26445: LIST
26446: LIST
26447: PUSH
26448: LD_INT 0
26450: PUSH
26451: LD_INT 2
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: LD_INT 1
26460: NEG
26461: PUSH
26462: LD_INT 1
26464: PUSH
26465: EMPTY
26466: LIST
26467: LIST
26468: PUSH
26469: LD_INT 2
26471: NEG
26472: PUSH
26473: LD_INT 1
26475: NEG
26476: PUSH
26477: EMPTY
26478: LIST
26479: LIST
26480: PUSH
26481: LD_INT 2
26483: NEG
26484: PUSH
26485: LD_INT 2
26487: NEG
26488: PUSH
26489: EMPTY
26490: LIST
26491: LIST
26492: PUSH
26493: LD_INT 2
26495: NEG
26496: PUSH
26497: LD_INT 3
26499: NEG
26500: PUSH
26501: EMPTY
26502: LIST
26503: LIST
26504: PUSH
26505: LD_INT 1
26507: NEG
26508: PUSH
26509: LD_INT 3
26511: NEG
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 0
26519: PUSH
26520: LD_INT 3
26522: NEG
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: PUSH
26528: LD_INT 1
26530: PUSH
26531: LD_INT 2
26533: NEG
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 3
26541: PUSH
26542: LD_INT 2
26544: PUSH
26545: EMPTY
26546: LIST
26547: LIST
26548: PUSH
26549: LD_INT 3
26551: PUSH
26552: LD_INT 3
26554: PUSH
26555: EMPTY
26556: LIST
26557: LIST
26558: PUSH
26559: LD_INT 2
26561: PUSH
26562: LD_INT 3
26564: PUSH
26565: EMPTY
26566: LIST
26567: LIST
26568: PUSH
26569: LD_INT 1
26571: PUSH
26572: LD_INT 3
26574: PUSH
26575: EMPTY
26576: LIST
26577: LIST
26578: PUSH
26579: LD_INT 0
26581: PUSH
26582: LD_INT 3
26584: PUSH
26585: EMPTY
26586: LIST
26587: LIST
26588: PUSH
26589: LD_INT 1
26591: NEG
26592: PUSH
26593: LD_INT 2
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PUSH
26600: LD_INT 3
26602: NEG
26603: PUSH
26604: LD_INT 2
26606: NEG
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: LD_INT 3
26614: NEG
26615: PUSH
26616: LD_INT 3
26618: NEG
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: LIST
26628: LIST
26629: LIST
26630: LIST
26631: LIST
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: LIST
26653: LIST
26654: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26655: LD_ADDR_VAR 0 46
26659: PUSH
26660: LD_INT 0
26662: PUSH
26663: LD_INT 0
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 0
26672: PUSH
26673: LD_INT 1
26675: NEG
26676: PUSH
26677: EMPTY
26678: LIST
26679: LIST
26680: PUSH
26681: LD_INT 1
26683: PUSH
26684: LD_INT 0
26686: PUSH
26687: EMPTY
26688: LIST
26689: LIST
26690: PUSH
26691: LD_INT 1
26693: PUSH
26694: LD_INT 1
26696: PUSH
26697: EMPTY
26698: LIST
26699: LIST
26700: PUSH
26701: LD_INT 0
26703: PUSH
26704: LD_INT 1
26706: PUSH
26707: EMPTY
26708: LIST
26709: LIST
26710: PUSH
26711: LD_INT 1
26713: NEG
26714: PUSH
26715: LD_INT 0
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_INT 1
26724: NEG
26725: PUSH
26726: LD_INT 1
26728: NEG
26729: PUSH
26730: EMPTY
26731: LIST
26732: LIST
26733: PUSH
26734: LD_INT 1
26736: NEG
26737: PUSH
26738: LD_INT 2
26740: NEG
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 0
26748: PUSH
26749: LD_INT 2
26751: NEG
26752: PUSH
26753: EMPTY
26754: LIST
26755: LIST
26756: PUSH
26757: LD_INT 1
26759: PUSH
26760: LD_INT 1
26762: NEG
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: PUSH
26768: LD_INT 2
26770: PUSH
26771: LD_INT 0
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: LD_INT 2
26780: PUSH
26781: LD_INT 1
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 1
26790: PUSH
26791: LD_INT 2
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PUSH
26798: LD_INT 0
26800: PUSH
26801: LD_INT 2
26803: PUSH
26804: EMPTY
26805: LIST
26806: LIST
26807: PUSH
26808: LD_INT 1
26810: NEG
26811: PUSH
26812: LD_INT 1
26814: PUSH
26815: EMPTY
26816: LIST
26817: LIST
26818: PUSH
26819: LD_INT 2
26821: NEG
26822: PUSH
26823: LD_INT 0
26825: PUSH
26826: EMPTY
26827: LIST
26828: LIST
26829: PUSH
26830: LD_INT 2
26832: NEG
26833: PUSH
26834: LD_INT 1
26836: NEG
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: PUSH
26842: LD_INT 1
26844: NEG
26845: PUSH
26846: LD_INT 3
26848: NEG
26849: PUSH
26850: EMPTY
26851: LIST
26852: LIST
26853: PUSH
26854: LD_INT 0
26856: PUSH
26857: LD_INT 3
26859: NEG
26860: PUSH
26861: EMPTY
26862: LIST
26863: LIST
26864: PUSH
26865: LD_INT 1
26867: PUSH
26868: LD_INT 2
26870: NEG
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 2
26878: PUSH
26879: LD_INT 1
26881: NEG
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 3
26889: PUSH
26890: LD_INT 0
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 3
26899: PUSH
26900: LD_INT 1
26902: PUSH
26903: EMPTY
26904: LIST
26905: LIST
26906: PUSH
26907: LD_INT 1
26909: PUSH
26910: LD_INT 3
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PUSH
26917: LD_INT 0
26919: PUSH
26920: LD_INT 3
26922: PUSH
26923: EMPTY
26924: LIST
26925: LIST
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: LD_INT 2
26933: PUSH
26934: EMPTY
26935: LIST
26936: LIST
26937: PUSH
26938: LD_INT 2
26940: NEG
26941: PUSH
26942: LD_INT 1
26944: PUSH
26945: EMPTY
26946: LIST
26947: LIST
26948: PUSH
26949: LD_INT 3
26951: NEG
26952: PUSH
26953: LD_INT 0
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 3
26962: NEG
26963: PUSH
26964: LD_INT 1
26966: NEG
26967: PUSH
26968: EMPTY
26969: LIST
26970: LIST
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: LIST
26976: LIST
26977: LIST
26978: LIST
26979: LIST
26980: LIST
26981: LIST
26982: LIST
26983: LIST
26984: LIST
26985: LIST
26986: LIST
26987: LIST
26988: LIST
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: LIST
26994: LIST
26995: LIST
26996: LIST
26997: LIST
26998: LIST
26999: LIST
27000: LIST
27001: LIST
27002: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27003: LD_ADDR_VAR 0 47
27007: PUSH
27008: LD_INT 0
27010: PUSH
27011: LD_INT 0
27013: PUSH
27014: EMPTY
27015: LIST
27016: LIST
27017: PUSH
27018: LD_INT 0
27020: PUSH
27021: LD_INT 1
27023: NEG
27024: PUSH
27025: EMPTY
27026: LIST
27027: LIST
27028: PUSH
27029: LD_INT 1
27031: PUSH
27032: LD_INT 0
27034: PUSH
27035: EMPTY
27036: LIST
27037: LIST
27038: PUSH
27039: LD_INT 1
27041: PUSH
27042: LD_INT 1
27044: PUSH
27045: EMPTY
27046: LIST
27047: LIST
27048: PUSH
27049: LD_INT 0
27051: PUSH
27052: LD_INT 1
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 1
27061: NEG
27062: PUSH
27063: LD_INT 0
27065: PUSH
27066: EMPTY
27067: LIST
27068: LIST
27069: PUSH
27070: LD_INT 1
27072: NEG
27073: PUSH
27074: LD_INT 1
27076: NEG
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: PUSH
27082: LD_INT 1
27084: NEG
27085: PUSH
27086: LD_INT 2
27088: NEG
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 0
27096: PUSH
27097: LD_INT 2
27099: NEG
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: PUSH
27108: LD_INT 1
27110: NEG
27111: PUSH
27112: EMPTY
27113: LIST
27114: LIST
27115: PUSH
27116: LD_INT 2
27118: NEG
27119: PUSH
27120: LD_INT 1
27122: NEG
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 2
27130: NEG
27131: PUSH
27132: LD_INT 2
27134: NEG
27135: PUSH
27136: EMPTY
27137: LIST
27138: LIST
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: LIST
27146: LIST
27147: LIST
27148: LIST
27149: LIST
27150: LIST
27151: LIST
27152: LIST
27153: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
27154: LD_ADDR_VAR 0 48
27158: PUSH
27159: LD_INT 0
27161: PUSH
27162: LD_INT 0
27164: PUSH
27165: EMPTY
27166: LIST
27167: LIST
27168: PUSH
27169: LD_INT 0
27171: PUSH
27172: LD_INT 1
27174: NEG
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: LD_INT 1
27182: PUSH
27183: LD_INT 0
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 1
27192: PUSH
27193: LD_INT 1
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: LD_INT 0
27202: PUSH
27203: LD_INT 1
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PUSH
27210: LD_INT 1
27212: NEG
27213: PUSH
27214: LD_INT 0
27216: PUSH
27217: EMPTY
27218: LIST
27219: LIST
27220: PUSH
27221: LD_INT 1
27223: NEG
27224: PUSH
27225: LD_INT 1
27227: NEG
27228: PUSH
27229: EMPTY
27230: LIST
27231: LIST
27232: PUSH
27233: LD_INT 1
27235: NEG
27236: PUSH
27237: LD_INT 2
27239: NEG
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: PUSH
27245: LD_INT 0
27247: PUSH
27248: LD_INT 2
27250: NEG
27251: PUSH
27252: EMPTY
27253: LIST
27254: LIST
27255: PUSH
27256: LD_INT 1
27258: PUSH
27259: LD_INT 1
27261: NEG
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PUSH
27267: LD_INT 2
27269: PUSH
27270: LD_INT 0
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 2
27279: PUSH
27280: LD_INT 1
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: EMPTY
27288: LIST
27289: LIST
27290: LIST
27291: LIST
27292: LIST
27293: LIST
27294: LIST
27295: LIST
27296: LIST
27297: LIST
27298: LIST
27299: LIST
27300: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
27301: LD_ADDR_VAR 0 49
27305: PUSH
27306: LD_INT 0
27308: PUSH
27309: LD_INT 0
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 0
27318: PUSH
27319: LD_INT 1
27321: NEG
27322: PUSH
27323: EMPTY
27324: LIST
27325: LIST
27326: PUSH
27327: LD_INT 1
27329: PUSH
27330: LD_INT 0
27332: PUSH
27333: EMPTY
27334: LIST
27335: LIST
27336: PUSH
27337: LD_INT 1
27339: PUSH
27340: LD_INT 1
27342: PUSH
27343: EMPTY
27344: LIST
27345: LIST
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: LD_INT 1
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 1
27359: NEG
27360: PUSH
27361: LD_INT 0
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 1
27370: NEG
27371: PUSH
27372: LD_INT 1
27374: NEG
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: LD_INT 1
27382: PUSH
27383: LD_INT 1
27385: NEG
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: LD_INT 2
27393: PUSH
27394: LD_INT 0
27396: PUSH
27397: EMPTY
27398: LIST
27399: LIST
27400: PUSH
27401: LD_INT 2
27403: PUSH
27404: LD_INT 1
27406: PUSH
27407: EMPTY
27408: LIST
27409: LIST
27410: PUSH
27411: LD_INT 2
27413: PUSH
27414: LD_INT 2
27416: PUSH
27417: EMPTY
27418: LIST
27419: LIST
27420: PUSH
27421: LD_INT 1
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: PUSH
27431: EMPTY
27432: LIST
27433: LIST
27434: LIST
27435: LIST
27436: LIST
27437: LIST
27438: LIST
27439: LIST
27440: LIST
27441: LIST
27442: LIST
27443: LIST
27444: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
27445: LD_ADDR_VAR 0 50
27449: PUSH
27450: LD_INT 0
27452: PUSH
27453: LD_INT 0
27455: PUSH
27456: EMPTY
27457: LIST
27458: LIST
27459: PUSH
27460: LD_INT 0
27462: PUSH
27463: LD_INT 1
27465: NEG
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: PUSH
27471: LD_INT 1
27473: PUSH
27474: LD_INT 0
27476: PUSH
27477: EMPTY
27478: LIST
27479: LIST
27480: PUSH
27481: LD_INT 1
27483: PUSH
27484: LD_INT 1
27486: PUSH
27487: EMPTY
27488: LIST
27489: LIST
27490: PUSH
27491: LD_INT 0
27493: PUSH
27494: LD_INT 1
27496: PUSH
27497: EMPTY
27498: LIST
27499: LIST
27500: PUSH
27501: LD_INT 1
27503: NEG
27504: PUSH
27505: LD_INT 0
27507: PUSH
27508: EMPTY
27509: LIST
27510: LIST
27511: PUSH
27512: LD_INT 1
27514: NEG
27515: PUSH
27516: LD_INT 1
27518: NEG
27519: PUSH
27520: EMPTY
27521: LIST
27522: LIST
27523: PUSH
27524: LD_INT 2
27526: PUSH
27527: LD_INT 1
27529: PUSH
27530: EMPTY
27531: LIST
27532: LIST
27533: PUSH
27534: LD_INT 2
27536: PUSH
27537: LD_INT 2
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: PUSH
27544: LD_INT 1
27546: PUSH
27547: LD_INT 2
27549: PUSH
27550: EMPTY
27551: LIST
27552: LIST
27553: PUSH
27554: LD_INT 0
27556: PUSH
27557: LD_INT 2
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: PUSH
27564: LD_INT 1
27566: NEG
27567: PUSH
27568: LD_INT 1
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PUSH
27575: EMPTY
27576: LIST
27577: LIST
27578: LIST
27579: LIST
27580: LIST
27581: LIST
27582: LIST
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
27589: LD_ADDR_VAR 0 51
27593: PUSH
27594: LD_INT 0
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: PUSH
27604: LD_INT 0
27606: PUSH
27607: LD_INT 1
27609: NEG
27610: PUSH
27611: EMPTY
27612: LIST
27613: LIST
27614: PUSH
27615: LD_INT 1
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: EMPTY
27622: LIST
27623: LIST
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 0
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: EMPTY
27642: LIST
27643: LIST
27644: PUSH
27645: LD_INT 1
27647: NEG
27648: PUSH
27649: LD_INT 0
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 1
27658: NEG
27659: PUSH
27660: LD_INT 1
27662: NEG
27663: PUSH
27664: EMPTY
27665: LIST
27666: LIST
27667: PUSH
27668: LD_INT 1
27670: PUSH
27671: LD_INT 2
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PUSH
27678: LD_INT 0
27680: PUSH
27681: LD_INT 2
27683: PUSH
27684: EMPTY
27685: LIST
27686: LIST
27687: PUSH
27688: LD_INT 1
27690: NEG
27691: PUSH
27692: LD_INT 1
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PUSH
27699: LD_INT 2
27701: NEG
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: EMPTY
27707: LIST
27708: LIST
27709: PUSH
27710: LD_INT 2
27712: NEG
27713: PUSH
27714: LD_INT 1
27716: NEG
27717: PUSH
27718: EMPTY
27719: LIST
27720: LIST
27721: PUSH
27722: EMPTY
27723: LIST
27724: LIST
27725: LIST
27726: LIST
27727: LIST
27728: LIST
27729: LIST
27730: LIST
27731: LIST
27732: LIST
27733: LIST
27734: LIST
27735: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27736: LD_ADDR_VAR 0 52
27740: PUSH
27741: LD_INT 0
27743: PUSH
27744: LD_INT 0
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PUSH
27751: LD_INT 0
27753: PUSH
27754: LD_INT 1
27756: NEG
27757: PUSH
27758: EMPTY
27759: LIST
27760: LIST
27761: PUSH
27762: LD_INT 1
27764: PUSH
27765: LD_INT 0
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: PUSH
27772: LD_INT 1
27774: PUSH
27775: LD_INT 1
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 0
27784: PUSH
27785: LD_INT 1
27787: PUSH
27788: EMPTY
27789: LIST
27790: LIST
27791: PUSH
27792: LD_INT 1
27794: NEG
27795: PUSH
27796: LD_INT 0
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: NEG
27806: PUSH
27807: LD_INT 1
27809: NEG
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: PUSH
27815: LD_INT 1
27817: NEG
27818: PUSH
27819: LD_INT 2
27821: NEG
27822: PUSH
27823: EMPTY
27824: LIST
27825: LIST
27826: PUSH
27827: LD_INT 1
27829: NEG
27830: PUSH
27831: LD_INT 1
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 2
27840: NEG
27841: PUSH
27842: LD_INT 0
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 2
27851: NEG
27852: PUSH
27853: LD_INT 1
27855: NEG
27856: PUSH
27857: EMPTY
27858: LIST
27859: LIST
27860: PUSH
27861: LD_INT 2
27863: NEG
27864: PUSH
27865: LD_INT 2
27867: NEG
27868: PUSH
27869: EMPTY
27870: LIST
27871: LIST
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: LIST
27877: LIST
27878: LIST
27879: LIST
27880: LIST
27881: LIST
27882: LIST
27883: LIST
27884: LIST
27885: LIST
27886: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27887: LD_ADDR_VAR 0 53
27891: PUSH
27892: LD_INT 0
27894: PUSH
27895: LD_INT 0
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 0
27904: PUSH
27905: LD_INT 1
27907: NEG
27908: PUSH
27909: EMPTY
27910: LIST
27911: LIST
27912: PUSH
27913: LD_INT 1
27915: PUSH
27916: LD_INT 0
27918: PUSH
27919: EMPTY
27920: LIST
27921: LIST
27922: PUSH
27923: LD_INT 1
27925: PUSH
27926: LD_INT 1
27928: PUSH
27929: EMPTY
27930: LIST
27931: LIST
27932: PUSH
27933: LD_INT 0
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: EMPTY
27940: LIST
27941: LIST
27942: PUSH
27943: LD_INT 1
27945: NEG
27946: PUSH
27947: LD_INT 0
27949: PUSH
27950: EMPTY
27951: LIST
27952: LIST
27953: PUSH
27954: LD_INT 1
27956: NEG
27957: PUSH
27958: LD_INT 1
27960: NEG
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: PUSH
27966: LD_INT 1
27968: NEG
27969: PUSH
27970: LD_INT 2
27972: NEG
27973: PUSH
27974: EMPTY
27975: LIST
27976: LIST
27977: PUSH
27978: LD_INT 0
27980: PUSH
27981: LD_INT 2
27983: NEG
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 1
27991: PUSH
27992: LD_INT 1
27994: NEG
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 2
28002: PUSH
28003: LD_INT 0
28005: PUSH
28006: EMPTY
28007: LIST
28008: LIST
28009: PUSH
28010: LD_INT 2
28012: PUSH
28013: LD_INT 1
28015: PUSH
28016: EMPTY
28017: LIST
28018: LIST
28019: PUSH
28020: LD_INT 2
28022: PUSH
28023: LD_INT 2
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: PUSH
28030: LD_INT 1
28032: PUSH
28033: LD_INT 2
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: PUSH
28040: LD_INT 0
28042: PUSH
28043: LD_INT 2
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 1
28052: NEG
28053: PUSH
28054: LD_INT 1
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 2
28063: NEG
28064: PUSH
28065: LD_INT 0
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 2
28074: NEG
28075: PUSH
28076: LD_INT 1
28078: NEG
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 2
28086: NEG
28087: PUSH
28088: LD_INT 2
28090: NEG
28091: PUSH
28092: EMPTY
28093: LIST
28094: LIST
28095: PUSH
28096: EMPTY
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: LIST
28113: LIST
28114: LIST
28115: LIST
28116: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28117: LD_ADDR_VAR 0 54
28121: PUSH
28122: LD_INT 0
28124: PUSH
28125: LD_INT 0
28127: PUSH
28128: EMPTY
28129: LIST
28130: LIST
28131: PUSH
28132: LD_INT 0
28134: PUSH
28135: LD_INT 1
28137: NEG
28138: PUSH
28139: EMPTY
28140: LIST
28141: LIST
28142: PUSH
28143: LD_INT 1
28145: PUSH
28146: LD_INT 0
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: PUSH
28153: LD_INT 1
28155: PUSH
28156: LD_INT 1
28158: PUSH
28159: EMPTY
28160: LIST
28161: LIST
28162: PUSH
28163: LD_INT 0
28165: PUSH
28166: LD_INT 1
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: LD_INT 1
28175: NEG
28176: PUSH
28177: LD_INT 0
28179: PUSH
28180: EMPTY
28181: LIST
28182: LIST
28183: PUSH
28184: LD_INT 1
28186: NEG
28187: PUSH
28188: LD_INT 1
28190: NEG
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 1
28198: NEG
28199: PUSH
28200: LD_INT 2
28202: NEG
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 0
28210: PUSH
28211: LD_INT 2
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: LD_INT 1
28221: PUSH
28222: LD_INT 1
28224: NEG
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 2
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 2
28242: PUSH
28243: LD_INT 1
28245: PUSH
28246: EMPTY
28247: LIST
28248: LIST
28249: PUSH
28250: LD_INT 2
28252: PUSH
28253: LD_INT 2
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PUSH
28260: LD_INT 1
28262: PUSH
28263: LD_INT 2
28265: PUSH
28266: EMPTY
28267: LIST
28268: LIST
28269: PUSH
28270: LD_INT 0
28272: PUSH
28273: LD_INT 2
28275: PUSH
28276: EMPTY
28277: LIST
28278: LIST
28279: PUSH
28280: LD_INT 1
28282: NEG
28283: PUSH
28284: LD_INT 1
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 2
28293: NEG
28294: PUSH
28295: LD_INT 0
28297: PUSH
28298: EMPTY
28299: LIST
28300: LIST
28301: PUSH
28302: LD_INT 2
28304: NEG
28305: PUSH
28306: LD_INT 1
28308: NEG
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 2
28316: NEG
28317: PUSH
28318: LD_INT 2
28320: NEG
28321: PUSH
28322: EMPTY
28323: LIST
28324: LIST
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: LIST
28345: LIST
28346: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28347: LD_ADDR_VAR 0 55
28351: PUSH
28352: LD_INT 0
28354: PUSH
28355: LD_INT 0
28357: PUSH
28358: EMPTY
28359: LIST
28360: LIST
28361: PUSH
28362: LD_INT 0
28364: PUSH
28365: LD_INT 1
28367: NEG
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PUSH
28373: LD_INT 1
28375: PUSH
28376: LD_INT 0
28378: PUSH
28379: EMPTY
28380: LIST
28381: LIST
28382: PUSH
28383: LD_INT 1
28385: PUSH
28386: LD_INT 1
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: LD_INT 0
28395: PUSH
28396: LD_INT 1
28398: PUSH
28399: EMPTY
28400: LIST
28401: LIST
28402: PUSH
28403: LD_INT 1
28405: NEG
28406: PUSH
28407: LD_INT 0
28409: PUSH
28410: EMPTY
28411: LIST
28412: LIST
28413: PUSH
28414: LD_INT 1
28416: NEG
28417: PUSH
28418: LD_INT 1
28420: NEG
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 1
28428: NEG
28429: PUSH
28430: LD_INT 2
28432: NEG
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: PUSH
28438: LD_INT 0
28440: PUSH
28441: LD_INT 2
28443: NEG
28444: PUSH
28445: EMPTY
28446: LIST
28447: LIST
28448: PUSH
28449: LD_INT 1
28451: PUSH
28452: LD_INT 1
28454: NEG
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 2
28462: PUSH
28463: LD_INT 0
28465: PUSH
28466: EMPTY
28467: LIST
28468: LIST
28469: PUSH
28470: LD_INT 2
28472: PUSH
28473: LD_INT 1
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: PUSH
28480: LD_INT 2
28482: PUSH
28483: LD_INT 2
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: EMPTY
28497: LIST
28498: LIST
28499: PUSH
28500: LD_INT 0
28502: PUSH
28503: LD_INT 2
28505: PUSH
28506: EMPTY
28507: LIST
28508: LIST
28509: PUSH
28510: LD_INT 1
28512: NEG
28513: PUSH
28514: LD_INT 1
28516: PUSH
28517: EMPTY
28518: LIST
28519: LIST
28520: PUSH
28521: LD_INT 2
28523: NEG
28524: PUSH
28525: LD_INT 0
28527: PUSH
28528: EMPTY
28529: LIST
28530: LIST
28531: PUSH
28532: LD_INT 2
28534: NEG
28535: PUSH
28536: LD_INT 1
28538: NEG
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 2
28546: NEG
28547: PUSH
28548: LD_INT 2
28550: NEG
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: LIST
28564: LIST
28565: LIST
28566: LIST
28567: LIST
28568: LIST
28569: LIST
28570: LIST
28571: LIST
28572: LIST
28573: LIST
28574: LIST
28575: LIST
28576: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28577: LD_ADDR_VAR 0 56
28581: PUSH
28582: LD_INT 0
28584: PUSH
28585: LD_INT 0
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 1
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 0
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: PUSH
28613: LD_INT 1
28615: PUSH
28616: LD_INT 1
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 0
28625: PUSH
28626: LD_INT 1
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: NEG
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: EMPTY
28641: LIST
28642: LIST
28643: PUSH
28644: LD_INT 1
28646: NEG
28647: PUSH
28648: LD_INT 1
28650: NEG
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: PUSH
28656: LD_INT 1
28658: NEG
28659: PUSH
28660: LD_INT 2
28662: NEG
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 0
28670: PUSH
28671: LD_INT 2
28673: NEG
28674: PUSH
28675: EMPTY
28676: LIST
28677: LIST
28678: PUSH
28679: LD_INT 1
28681: PUSH
28682: LD_INT 1
28684: NEG
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 2
28692: PUSH
28693: LD_INT 0
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 2
28702: PUSH
28703: LD_INT 1
28705: PUSH
28706: EMPTY
28707: LIST
28708: LIST
28709: PUSH
28710: LD_INT 2
28712: PUSH
28713: LD_INT 2
28715: PUSH
28716: EMPTY
28717: LIST
28718: LIST
28719: PUSH
28720: LD_INT 1
28722: PUSH
28723: LD_INT 2
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: PUSH
28730: LD_INT 0
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: LD_INT 1
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: NEG
28754: PUSH
28755: LD_INT 0
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 2
28764: NEG
28765: PUSH
28766: LD_INT 1
28768: NEG
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 2
28776: NEG
28777: PUSH
28778: LD_INT 2
28780: NEG
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: PUSH
28786: EMPTY
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28807: LD_ADDR_VAR 0 57
28811: PUSH
28812: LD_INT 0
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: PUSH
28822: LD_INT 0
28824: PUSH
28825: LD_INT 1
28827: NEG
28828: PUSH
28829: EMPTY
28830: LIST
28831: LIST
28832: PUSH
28833: LD_INT 1
28835: PUSH
28836: LD_INT 0
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: LD_INT 1
28845: PUSH
28846: LD_INT 1
28848: PUSH
28849: EMPTY
28850: LIST
28851: LIST
28852: PUSH
28853: LD_INT 0
28855: PUSH
28856: LD_INT 1
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: NEG
28866: PUSH
28867: LD_INT 0
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 1
28876: NEG
28877: PUSH
28878: LD_INT 1
28880: NEG
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: LD_INT 2
28892: NEG
28893: PUSH
28894: EMPTY
28895: LIST
28896: LIST
28897: PUSH
28898: LD_INT 0
28900: PUSH
28901: LD_INT 2
28903: NEG
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PUSH
28909: LD_INT 1
28911: PUSH
28912: LD_INT 1
28914: NEG
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 2
28922: PUSH
28923: LD_INT 0
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: LD_INT 2
28932: PUSH
28933: LD_INT 1
28935: PUSH
28936: EMPTY
28937: LIST
28938: LIST
28939: PUSH
28940: LD_INT 2
28942: PUSH
28943: LD_INT 2
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 2
28983: NEG
28984: PUSH
28985: LD_INT 0
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: PUSH
28992: LD_INT 2
28994: NEG
28995: PUSH
28996: LD_INT 1
28998: NEG
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: NEG
29007: PUSH
29008: LD_INT 2
29010: NEG
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: LIST
29034: LIST
29035: LIST
29036: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29037: LD_ADDR_VAR 0 58
29041: PUSH
29042: LD_INT 0
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: EMPTY
29049: LIST
29050: LIST
29051: PUSH
29052: LD_INT 0
29054: PUSH
29055: LD_INT 1
29057: NEG
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: LD_INT 0
29068: PUSH
29069: EMPTY
29070: LIST
29071: LIST
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: LD_INT 1
29078: PUSH
29079: EMPTY
29080: LIST
29081: LIST
29082: PUSH
29083: LD_INT 0
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: EMPTY
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 1
29095: NEG
29096: PUSH
29097: LD_INT 0
29099: PUSH
29100: EMPTY
29101: LIST
29102: LIST
29103: PUSH
29104: LD_INT 1
29106: NEG
29107: PUSH
29108: LD_INT 1
29110: NEG
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 1
29118: NEG
29119: PUSH
29120: LD_INT 2
29122: NEG
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: LD_INT 0
29130: PUSH
29131: LD_INT 2
29133: NEG
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 1
29141: PUSH
29142: LD_INT 1
29144: NEG
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 2
29152: PUSH
29153: LD_INT 0
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 2
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 2
29172: PUSH
29173: LD_INT 2
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 1
29182: PUSH
29183: LD_INT 2
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 0
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: LD_INT 1
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PUSH
29211: LD_INT 2
29213: NEG
29214: PUSH
29215: LD_INT 0
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 2
29224: NEG
29225: PUSH
29226: LD_INT 1
29228: NEG
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 2
29236: NEG
29237: PUSH
29238: LD_INT 2
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: EMPTY
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29267: LD_ADDR_VAR 0 59
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 0
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 0
29284: PUSH
29285: LD_INT 1
29287: NEG
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: LD_INT 0
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 1
29305: PUSH
29306: LD_INT 1
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 0
29315: PUSH
29316: LD_INT 1
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 1
29325: NEG
29326: PUSH
29327: LD_INT 0
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: LD_INT 1
29340: NEG
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29355: LD_ADDR_VAR 0 60
29359: PUSH
29360: LD_INT 0
29362: PUSH
29363: LD_INT 0
29365: PUSH
29366: EMPTY
29367: LIST
29368: LIST
29369: PUSH
29370: LD_INT 0
29372: PUSH
29373: LD_INT 1
29375: NEG
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 1
29383: PUSH
29384: LD_INT 0
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 1
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 1
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: NEG
29414: PUSH
29415: LD_INT 0
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 1
29424: NEG
29425: PUSH
29426: LD_INT 1
29428: NEG
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: EMPTY
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29443: LD_ADDR_VAR 0 61
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 0
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 1
29463: NEG
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: LD_INT 1
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 1
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 0
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 0
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: PUSH
29510: LD_INT 1
29512: NEG
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: LIST
29526: LIST
29527: LIST
29528: LIST
29529: LIST
29530: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29531: LD_ADDR_VAR 0 62
29535: PUSH
29536: LD_INT 0
29538: PUSH
29539: LD_INT 0
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 0
29548: PUSH
29549: LD_INT 1
29551: NEG
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: PUSH
29560: LD_INT 0
29562: PUSH
29563: EMPTY
29564: LIST
29565: LIST
29566: PUSH
29567: LD_INT 1
29569: PUSH
29570: LD_INT 1
29572: PUSH
29573: EMPTY
29574: LIST
29575: LIST
29576: PUSH
29577: LD_INT 0
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 1
29589: NEG
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29619: LD_ADDR_VAR 0 63
29623: PUSH
29624: LD_INT 0
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: LD_INT 0
29636: PUSH
29637: LD_INT 1
29639: NEG
29640: PUSH
29641: EMPTY
29642: LIST
29643: LIST
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 1
29657: PUSH
29658: LD_INT 1
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 0
29667: PUSH
29668: LD_INT 1
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: NEG
29678: PUSH
29679: LD_INT 0
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: LD_INT 1
29692: NEG
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: EMPTY
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
29707: LD_ADDR_VAR 0 64
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: LD_INT 0
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: LD_INT 1
29727: NEG
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 1
29735: PUSH
29736: LD_INT 0
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 0
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: NEG
29766: PUSH
29767: LD_INT 0
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 1
29776: NEG
29777: PUSH
29778: LD_INT 1
29780: NEG
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: ST_TO_ADDR
// end ; 1 :
29795: GO 35692
29797: LD_INT 1
29799: DOUBLE
29800: EQUAL
29801: IFTRUE 29805
29803: GO 32428
29805: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29806: LD_ADDR_VAR 0 11
29810: PUSH
29811: LD_INT 1
29813: NEG
29814: PUSH
29815: LD_INT 3
29817: NEG
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: LD_INT 0
29825: PUSH
29826: LD_INT 3
29828: NEG
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: LD_INT 2
29839: NEG
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: LIST
29849: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29850: LD_ADDR_VAR 0 12
29854: PUSH
29855: LD_INT 2
29857: PUSH
29858: LD_INT 1
29860: NEG
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 3
29868: PUSH
29869: LD_INT 0
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 3
29878: PUSH
29879: LD_INT 1
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: LIST
29890: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29891: LD_ADDR_VAR 0 13
29895: PUSH
29896: LD_INT 3
29898: PUSH
29899: LD_INT 2
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 3
29908: PUSH
29909: LD_INT 3
29911: PUSH
29912: EMPTY
29913: LIST
29914: LIST
29915: PUSH
29916: LD_INT 2
29918: PUSH
29919: LD_INT 3
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: LIST
29930: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29931: LD_ADDR_VAR 0 14
29935: PUSH
29936: LD_INT 1
29938: PUSH
29939: LD_INT 3
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: LD_INT 3
29951: PUSH
29952: EMPTY
29953: LIST
29954: LIST
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: LD_INT 2
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: LIST
29971: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29972: LD_ADDR_VAR 0 15
29976: PUSH
29977: LD_INT 2
29979: NEG
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 3
29990: NEG
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 3
30001: NEG
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30016: LD_ADDR_VAR 0 16
30020: PUSH
30021: LD_INT 2
30023: NEG
30024: PUSH
30025: LD_INT 3
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 3
30035: NEG
30036: PUSH
30037: LD_INT 2
30039: NEG
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: LD_INT 3
30047: NEG
30048: PUSH
30049: LD_INT 3
30051: NEG
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: LIST
30061: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30062: LD_ADDR_VAR 0 17
30066: PUSH
30067: LD_INT 1
30069: NEG
30070: PUSH
30071: LD_INT 3
30073: NEG
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: LD_INT 3
30084: NEG
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: LD_INT 2
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: EMPTY
30102: LIST
30103: LIST
30104: LIST
30105: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30106: LD_ADDR_VAR 0 18
30110: PUSH
30111: LD_INT 2
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 3
30124: PUSH
30125: LD_INT 0
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 3
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: EMPTY
30143: LIST
30144: LIST
30145: LIST
30146: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30147: LD_ADDR_VAR 0 19
30151: PUSH
30152: LD_INT 3
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 3
30164: PUSH
30165: LD_INT 3
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: LD_INT 3
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: LIST
30186: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
30187: LD_ADDR_VAR 0 20
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: LD_INT 3
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 0
30204: PUSH
30205: LD_INT 3
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: LD_INT 2
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: LIST
30227: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30228: LD_ADDR_VAR 0 21
30232: PUSH
30233: LD_INT 2
30235: NEG
30236: PUSH
30237: LD_INT 1
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 3
30246: NEG
30247: PUSH
30248: LD_INT 0
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 3
30257: NEG
30258: PUSH
30259: LD_INT 1
30261: NEG
30262: PUSH
30263: EMPTY
30264: LIST
30265: LIST
30266: PUSH
30267: EMPTY
30268: LIST
30269: LIST
30270: LIST
30271: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30272: LD_ADDR_VAR 0 22
30276: PUSH
30277: LD_INT 2
30279: NEG
30280: PUSH
30281: LD_INT 3
30283: NEG
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 3
30291: NEG
30292: PUSH
30293: LD_INT 2
30295: NEG
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 3
30303: NEG
30304: PUSH
30305: LD_INT 3
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: LIST
30317: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
30318: LD_ADDR_VAR 0 23
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: LD_INT 3
30328: NEG
30329: PUSH
30330: EMPTY
30331: LIST
30332: LIST
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: LD_INT 4
30340: NEG
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: PUSH
30349: LD_INT 3
30351: NEG
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
30362: LD_ADDR_VAR 0 24
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: LD_INT 0
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 3
30379: PUSH
30380: LD_INT 1
30382: NEG
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 4
30390: PUSH
30391: LD_INT 1
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: LIST
30402: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
30403: LD_ADDR_VAR 0 25
30407: PUSH
30408: LD_INT 3
30410: PUSH
30411: LD_INT 3
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 4
30420: PUSH
30421: LD_INT 3
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 3
30430: PUSH
30431: LD_INT 4
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: LIST
30442: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
30443: LD_ADDR_VAR 0 26
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: LD_INT 3
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: LD_INT 4
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: LD_INT 3
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: EMPTY
30480: LIST
30481: LIST
30482: LIST
30483: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
30484: LD_ADDR_VAR 0 27
30488: PUSH
30489: LD_INT 3
30491: NEG
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 3
30502: NEG
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 4
30513: NEG
30514: PUSH
30515: LD_INT 1
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: EMPTY
30524: LIST
30525: LIST
30526: LIST
30527: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
30528: LD_ADDR_VAR 0 28
30532: PUSH
30533: LD_INT 3
30535: NEG
30536: PUSH
30537: LD_INT 3
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 3
30547: NEG
30548: PUSH
30549: LD_INT 4
30551: NEG
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 4
30559: NEG
30560: PUSH
30561: LD_INT 3
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: LIST
30573: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
30574: LD_ADDR_VAR 0 29
30578: PUSH
30579: LD_INT 1
30581: NEG
30582: PUSH
30583: LD_INT 3
30585: NEG
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 0
30593: PUSH
30594: LD_INT 3
30596: NEG
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: PUSH
30605: LD_INT 2
30607: NEG
30608: PUSH
30609: EMPTY
30610: LIST
30611: LIST
30612: PUSH
30613: LD_INT 1
30615: NEG
30616: PUSH
30617: LD_INT 4
30619: NEG
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 0
30627: PUSH
30628: LD_INT 4
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 1
30638: PUSH
30639: LD_INT 3
30641: NEG
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: NEG
30650: PUSH
30651: LD_INT 5
30653: NEG
30654: PUSH
30655: EMPTY
30656: LIST
30657: LIST
30658: PUSH
30659: LD_INT 0
30661: PUSH
30662: LD_INT 5
30664: NEG
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: LD_INT 4
30675: NEG
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 1
30683: NEG
30684: PUSH
30685: LD_INT 6
30687: NEG
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 6
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 5
30709: NEG
30710: PUSH
30711: EMPTY
30712: LIST
30713: LIST
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
30729: LD_ADDR_VAR 0 30
30733: PUSH
30734: LD_INT 2
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 3
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 3
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 3
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 4
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 4
30788: PUSH
30789: LD_INT 1
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 4
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 5
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 5
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 5
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 6
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 6
30850: PUSH
30851: LD_INT 1
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: LIST
30869: LIST
30870: LIST
30871: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
30872: LD_ADDR_VAR 0 31
30876: PUSH
30877: LD_INT 3
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 3
30889: PUSH
30890: LD_INT 3
30892: PUSH
30893: EMPTY
30894: LIST
30895: LIST
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: LD_INT 3
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: PUSH
30907: LD_INT 4
30909: PUSH
30910: LD_INT 3
30912: PUSH
30913: EMPTY
30914: LIST
30915: LIST
30916: PUSH
30917: LD_INT 4
30919: PUSH
30920: LD_INT 4
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 3
30929: PUSH
30930: LD_INT 4
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 5
30939: PUSH
30940: LD_INT 4
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 5
30949: PUSH
30950: LD_INT 5
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 4
30959: PUSH
30960: LD_INT 5
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 6
30969: PUSH
30970: LD_INT 5
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 6
30979: PUSH
30980: LD_INT 6
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 5
30989: PUSH
30990: LD_INT 6
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: LIST
31001: LIST
31002: LIST
31003: LIST
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: LIST
31009: LIST
31010: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
31011: LD_ADDR_VAR 0 32
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: LD_INT 3
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: LD_INT 3
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 1
31049: PUSH
31050: LD_INT 4
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 0
31059: PUSH
31060: LD_INT 4
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 1
31069: NEG
31070: PUSH
31071: LD_INT 3
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: LD_INT 5
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 0
31090: PUSH
31091: LD_INT 5
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: NEG
31101: PUSH
31102: LD_INT 4
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 1
31111: PUSH
31112: LD_INT 6
31114: PUSH
31115: EMPTY
31116: LIST
31117: LIST
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: LD_INT 6
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 1
31131: NEG
31132: PUSH
31133: LD_INT 5
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: EMPTY
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
31154: LD_ADDR_VAR 0 33
31158: PUSH
31159: LD_INT 2
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 3
31172: NEG
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: EMPTY
31178: LIST
31179: LIST
31180: PUSH
31181: LD_INT 3
31183: NEG
31184: PUSH
31185: LD_INT 1
31187: NEG
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 3
31195: NEG
31196: PUSH
31197: LD_INT 1
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: LD_INT 4
31206: NEG
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 4
31217: NEG
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 4
31229: NEG
31230: PUSH
31231: LD_INT 1
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 5
31240: NEG
31241: PUSH
31242: LD_INT 0
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 5
31251: NEG
31252: PUSH
31253: LD_INT 1
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 5
31263: NEG
31264: PUSH
31265: LD_INT 1
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 6
31274: NEG
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: LD_INT 6
31285: NEG
31286: PUSH
31287: LD_INT 1
31289: NEG
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
31309: LD_ADDR_VAR 0 34
31313: PUSH
31314: LD_INT 2
31316: NEG
31317: PUSH
31318: LD_INT 3
31320: NEG
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 3
31328: NEG
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 3
31340: NEG
31341: PUSH
31342: LD_INT 3
31344: NEG
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 3
31352: NEG
31353: PUSH
31354: LD_INT 4
31356: NEG
31357: PUSH
31358: EMPTY
31359: LIST
31360: LIST
31361: PUSH
31362: LD_INT 4
31364: NEG
31365: PUSH
31366: LD_INT 3
31368: NEG
31369: PUSH
31370: EMPTY
31371: LIST
31372: LIST
31373: PUSH
31374: LD_INT 4
31376: NEG
31377: PUSH
31378: LD_INT 4
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 4
31388: NEG
31389: PUSH
31390: LD_INT 5
31392: NEG
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 5
31400: NEG
31401: PUSH
31402: LD_INT 4
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 5
31412: NEG
31413: PUSH
31414: LD_INT 5
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 5
31424: NEG
31425: PUSH
31426: LD_INT 6
31428: NEG
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: PUSH
31434: LD_INT 6
31436: NEG
31437: PUSH
31438: LD_INT 5
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 6
31448: NEG
31449: PUSH
31450: LD_INT 6
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
31472: LD_ADDR_VAR 0 41
31476: PUSH
31477: LD_INT 0
31479: PUSH
31480: LD_INT 2
31482: NEG
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: LD_INT 3
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 1
31502: PUSH
31503: LD_INT 2
31505: NEG
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: LIST
31515: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
31516: LD_ADDR_VAR 0 42
31520: PUSH
31521: LD_INT 2
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 2
31533: PUSH
31534: LD_INT 1
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 3
31544: PUSH
31545: LD_INT 1
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: LIST
31556: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
31557: LD_ADDR_VAR 0 43
31561: PUSH
31562: LD_INT 2
31564: PUSH
31565: LD_INT 2
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 3
31574: PUSH
31575: LD_INT 2
31577: PUSH
31578: EMPTY
31579: LIST
31580: LIST
31581: PUSH
31582: LD_INT 2
31584: PUSH
31585: LD_INT 3
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: LIST
31596: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
31597: LD_ADDR_VAR 0 44
31601: PUSH
31602: LD_INT 0
31604: PUSH
31605: LD_INT 2
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 1
31614: PUSH
31615: LD_INT 3
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: NEG
31625: PUSH
31626: LD_INT 2
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: LIST
31637: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31638: LD_ADDR_VAR 0 45
31642: PUSH
31643: LD_INT 2
31645: NEG
31646: PUSH
31647: LD_INT 0
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 2
31656: NEG
31657: PUSH
31658: LD_INT 1
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 3
31667: NEG
31668: PUSH
31669: LD_INT 1
31671: NEG
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: LIST
31681: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
31682: LD_ADDR_VAR 0 46
31686: PUSH
31687: LD_INT 2
31689: NEG
31690: PUSH
31691: LD_INT 2
31693: NEG
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 3
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 3
31713: NEG
31714: PUSH
31715: LD_INT 2
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
31728: LD_ADDR_VAR 0 47
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: LD_INT 3
31739: NEG
31740: PUSH
31741: EMPTY
31742: LIST
31743: LIST
31744: PUSH
31745: LD_INT 1
31747: NEG
31748: PUSH
31749: LD_INT 3
31751: NEG
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31761: LD_ADDR_VAR 0 48
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 2
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 1
31782: NEG
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
31792: LD_ADDR_VAR 0 49
31796: PUSH
31797: LD_INT 3
31799: PUSH
31800: LD_INT 1
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 3
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: EMPTY
31818: LIST
31819: LIST
31820: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
31821: LD_ADDR_VAR 0 50
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: LD_INT 3
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 1
31838: PUSH
31839: LD_INT 3
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31850: LD_ADDR_VAR 0 51
31854: PUSH
31855: LD_INT 1
31857: NEG
31858: PUSH
31859: LD_INT 2
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 2
31868: NEG
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31881: LD_ADDR_VAR 0 52
31885: PUSH
31886: LD_INT 3
31888: NEG
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 3
31900: NEG
31901: PUSH
31902: LD_INT 2
31904: NEG
31905: PUSH
31906: EMPTY
31907: LIST
31908: LIST
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
31914: LD_ADDR_VAR 0 53
31918: PUSH
31919: LD_INT 1
31921: NEG
31922: PUSH
31923: LD_INT 3
31925: NEG
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: LD_INT 0
31933: PUSH
31934: LD_INT 3
31936: NEG
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 1
31944: PUSH
31945: LD_INT 2
31947: NEG
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: LIST
31957: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
31958: LD_ADDR_VAR 0 54
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: LD_INT 1
31968: NEG
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 3
31976: PUSH
31977: LD_INT 0
31979: PUSH
31980: EMPTY
31981: LIST
31982: LIST
31983: PUSH
31984: LD_INT 3
31986: PUSH
31987: LD_INT 1
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: LIST
31998: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
31999: LD_ADDR_VAR 0 55
32003: PUSH
32004: LD_INT 3
32006: PUSH
32007: LD_INT 2
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 3
32016: PUSH
32017: LD_INT 3
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 2
32026: PUSH
32027: LD_INT 3
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: LIST
32038: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32039: LD_ADDR_VAR 0 56
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: LD_INT 3
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 0
32056: PUSH
32057: LD_INT 3
32059: PUSH
32060: EMPTY
32061: LIST
32062: LIST
32063: PUSH
32064: LD_INT 1
32066: NEG
32067: PUSH
32068: LD_INT 2
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: LIST
32079: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32080: LD_ADDR_VAR 0 57
32084: PUSH
32085: LD_INT 2
32087: NEG
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 3
32098: NEG
32099: PUSH
32100: LD_INT 0
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 3
32109: NEG
32110: PUSH
32111: LD_INT 1
32113: NEG
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: LIST
32123: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32124: LD_ADDR_VAR 0 58
32128: PUSH
32129: LD_INT 2
32131: NEG
32132: PUSH
32133: LD_INT 3
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 3
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 3
32155: NEG
32156: PUSH
32157: LD_INT 3
32159: NEG
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: EMPTY
32166: LIST
32167: LIST
32168: LIST
32169: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
32170: LD_ADDR_VAR 0 59
32174: PUSH
32175: LD_INT 1
32177: NEG
32178: PUSH
32179: LD_INT 2
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: LD_INT 2
32192: NEG
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: LD_INT 1
32203: NEG
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: LIST
32213: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32214: LD_ADDR_VAR 0 60
32218: PUSH
32219: LD_INT 1
32221: PUSH
32222: LD_INT 1
32224: NEG
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 2
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: EMPTY
32247: LIST
32248: LIST
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: LIST
32254: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32255: LD_ADDR_VAR 0 61
32259: PUSH
32260: LD_INT 2
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: PUSH
32270: LD_INT 2
32272: PUSH
32273: LD_INT 2
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: LD_INT 2
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: LIST
32294: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32295: LD_ADDR_VAR 0 62
32299: PUSH
32300: LD_INT 1
32302: PUSH
32303: LD_INT 2
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 0
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 1
32322: NEG
32323: PUSH
32324: LD_INT 1
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: LIST
32335: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32336: LD_ADDR_VAR 0 63
32340: PUSH
32341: LD_INT 1
32343: NEG
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 2
32354: NEG
32355: PUSH
32356: LD_INT 0
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: NEG
32366: PUSH
32367: LD_INT 1
32369: NEG
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: LIST
32379: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32380: LD_ADDR_VAR 0 64
32384: PUSH
32385: LD_INT 1
32387: NEG
32388: PUSH
32389: LD_INT 2
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 2
32411: NEG
32412: PUSH
32413: LD_INT 2
32415: NEG
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: LIST
32425: ST_TO_ADDR
// end ; 2 :
32426: GO 35692
32428: LD_INT 2
32430: DOUBLE
32431: EQUAL
32432: IFTRUE 32436
32434: GO 35691
32436: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
32437: LD_ADDR_VAR 0 29
32441: PUSH
32442: LD_INT 4
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 4
32454: PUSH
32455: LD_INT 1
32457: NEG
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 5
32465: PUSH
32466: LD_INT 0
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 5
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 4
32485: PUSH
32486: LD_INT 1
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 3
32495: PUSH
32496: LD_INT 0
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 3
32505: PUSH
32506: LD_INT 1
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 3
32516: PUSH
32517: LD_INT 2
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 5
32527: PUSH
32528: LD_INT 2
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 3
32537: PUSH
32538: LD_INT 3
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 3
32547: PUSH
32548: LD_INT 2
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 4
32557: PUSH
32558: LD_INT 3
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 4
32567: PUSH
32568: LD_INT 4
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 3
32577: PUSH
32578: LD_INT 4
32580: PUSH
32581: EMPTY
32582: LIST
32583: LIST
32584: PUSH
32585: LD_INT 2
32587: PUSH
32588: LD_INT 3
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 2
32597: PUSH
32598: LD_INT 2
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 4
32607: PUSH
32608: LD_INT 2
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 2
32617: PUSH
32618: LD_INT 4
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 0
32627: PUSH
32628: LD_INT 4
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: LD_INT 3
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 4
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: PUSH
32658: LD_INT 5
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 5
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 4
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 3
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 2
32699: PUSH
32700: LD_INT 5
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 2
32709: NEG
32710: PUSH
32711: LD_INT 3
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 3
32720: NEG
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 3
32731: NEG
32732: PUSH
32733: LD_INT 1
32735: NEG
32736: PUSH
32737: EMPTY
32738: LIST
32739: LIST
32740: PUSH
32741: LD_INT 2
32743: NEG
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 2
32754: NEG
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 3
32765: NEG
32766: PUSH
32767: LD_INT 1
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 4
32776: NEG
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 4
32787: NEG
32788: PUSH
32789: LD_INT 1
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 4
32799: NEG
32800: PUSH
32801: LD_INT 2
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: LD_INT 2
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 4
32822: NEG
32823: PUSH
32824: LD_INT 4
32826: NEG
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 4
32834: NEG
32835: PUSH
32836: LD_INT 5
32838: NEG
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 3
32846: NEG
32847: PUSH
32848: LD_INT 4
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 3
32858: NEG
32859: PUSH
32860: LD_INT 3
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 4
32870: NEG
32871: PUSH
32872: LD_INT 3
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 5
32882: NEG
32883: PUSH
32884: LD_INT 4
32886: NEG
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 5
32894: NEG
32895: PUSH
32896: LD_INT 5
32898: NEG
32899: PUSH
32900: EMPTY
32901: LIST
32902: LIST
32903: PUSH
32904: LD_INT 3
32906: NEG
32907: PUSH
32908: LD_INT 5
32910: NEG
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 5
32918: NEG
32919: PUSH
32920: LD_INT 3
32922: NEG
32923: PUSH
32924: EMPTY
32925: LIST
32926: LIST
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
32975: LD_ADDR_VAR 0 30
32979: PUSH
32980: LD_INT 4
32982: PUSH
32983: LD_INT 4
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 4
32992: PUSH
32993: LD_INT 3
32995: PUSH
32996: EMPTY
32997: LIST
32998: LIST
32999: PUSH
33000: LD_INT 5
33002: PUSH
33003: LD_INT 4
33005: PUSH
33006: EMPTY
33007: LIST
33008: LIST
33009: PUSH
33010: LD_INT 5
33012: PUSH
33013: LD_INT 5
33015: PUSH
33016: EMPTY
33017: LIST
33018: LIST
33019: PUSH
33020: LD_INT 4
33022: PUSH
33023: LD_INT 5
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: LD_INT 3
33032: PUSH
33033: LD_INT 4
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 3
33042: PUSH
33043: LD_INT 3
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 5
33052: PUSH
33053: LD_INT 3
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PUSH
33060: LD_INT 3
33062: PUSH
33063: LD_INT 5
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: LD_INT 3
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 0
33082: PUSH
33083: LD_INT 2
33085: PUSH
33086: EMPTY
33087: LIST
33088: LIST
33089: PUSH
33090: LD_INT 1
33092: PUSH
33093: LD_INT 3
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: LD_INT 4
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: LD_INT 4
33115: PUSH
33116: EMPTY
33117: LIST
33118: LIST
33119: PUSH
33120: LD_INT 1
33122: NEG
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: LD_INT 4
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 2
33154: NEG
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 4
33165: NEG
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 4
33176: NEG
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 3
33188: NEG
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 3
33199: NEG
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 4
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 5
33221: NEG
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 5
33232: NEG
33233: PUSH
33234: LD_INT 1
33236: NEG
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 5
33244: NEG
33245: PUSH
33246: LD_INT 2
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 3
33256: NEG
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 3
33267: NEG
33268: PUSH
33269: LD_INT 3
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 3
33279: NEG
33280: PUSH
33281: LD_INT 4
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: NEG
33292: PUSH
33293: LD_INT 3
33295: NEG
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: LD_INT 2
33307: NEG
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 3
33315: NEG
33316: PUSH
33317: LD_INT 2
33319: NEG
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 4
33327: NEG
33328: PUSH
33329: LD_INT 3
33331: NEG
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 4
33339: NEG
33340: PUSH
33341: LD_INT 4
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: LD_INT 4
33355: NEG
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 4
33363: NEG
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: LD_INT 4
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 5
33389: NEG
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 4
33400: NEG
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: LD_INT 3
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: LD_INT 3
33422: NEG
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: LD_INT 4
33434: NEG
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: NEG
33443: PUSH
33444: LD_INT 5
33446: NEG
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 2
33454: PUSH
33455: LD_INT 3
33457: NEG
33458: PUSH
33459: EMPTY
33460: LIST
33461: LIST
33462: PUSH
33463: LD_INT 2
33465: NEG
33466: PUSH
33467: LD_INT 5
33469: NEG
33470: PUSH
33471: EMPTY
33472: LIST
33473: LIST
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: LIST
33482: LIST
33483: LIST
33484: LIST
33485: LIST
33486: LIST
33487: LIST
33488: LIST
33489: LIST
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
33522: LD_ADDR_VAR 0 31
33526: PUSH
33527: LD_INT 0
33529: PUSH
33530: LD_INT 4
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 0
33539: PUSH
33540: LD_INT 3
33542: PUSH
33543: EMPTY
33544: LIST
33545: LIST
33546: PUSH
33547: LD_INT 1
33549: PUSH
33550: LD_INT 4
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: LD_INT 5
33562: PUSH
33563: EMPTY
33564: LIST
33565: LIST
33566: PUSH
33567: LD_INT 0
33569: PUSH
33570: LD_INT 5
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: LD_INT 4
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 1
33590: NEG
33591: PUSH
33592: LD_INT 3
33594: PUSH
33595: EMPTY
33596: LIST
33597: LIST
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: LD_INT 5
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: NEG
33612: PUSH
33613: LD_INT 3
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 3
33622: NEG
33623: PUSH
33624: LD_INT 0
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 3
33633: NEG
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 2
33645: NEG
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 2
33656: NEG
33657: PUSH
33658: LD_INT 1
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 3
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 4
33678: NEG
33679: PUSH
33680: LD_INT 0
33682: PUSH
33683: EMPTY
33684: LIST
33685: LIST
33686: PUSH
33687: LD_INT 4
33689: NEG
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 4
33701: NEG
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: LD_INT 2
33713: NEG
33714: PUSH
33715: LD_INT 2
33717: PUSH
33718: EMPTY
33719: LIST
33720: LIST
33721: PUSH
33722: LD_INT 4
33724: NEG
33725: PUSH
33726: LD_INT 4
33728: NEG
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 4
33736: NEG
33737: PUSH
33738: LD_INT 5
33740: NEG
33741: PUSH
33742: EMPTY
33743: LIST
33744: LIST
33745: PUSH
33746: LD_INT 3
33748: NEG
33749: PUSH
33750: LD_INT 4
33752: NEG
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 3
33760: NEG
33761: PUSH
33762: LD_INT 3
33764: NEG
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 4
33772: NEG
33773: PUSH
33774: LD_INT 3
33776: NEG
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 5
33784: NEG
33785: PUSH
33786: LD_INT 4
33788: NEG
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 5
33796: NEG
33797: PUSH
33798: LD_INT 5
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 3
33808: NEG
33809: PUSH
33810: LD_INT 5
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 5
33820: NEG
33821: PUSH
33822: LD_INT 3
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 3
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 0
33843: PUSH
33844: LD_INT 4
33846: NEG
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: PUSH
33855: LD_INT 3
33857: NEG
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 1
33865: PUSH
33866: LD_INT 2
33868: NEG
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 2
33879: NEG
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 1
33887: NEG
33888: PUSH
33889: LD_INT 3
33891: NEG
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 1
33899: NEG
33900: PUSH
33901: LD_INT 4
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 2
33911: PUSH
33912: LD_INT 2
33914: NEG
33915: PUSH
33916: EMPTY
33917: LIST
33918: LIST
33919: PUSH
33920: LD_INT 2
33922: NEG
33923: PUSH
33924: LD_INT 4
33926: NEG
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 4
33934: PUSH
33935: LD_INT 0
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 4
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: LD_INT 5
33955: PUSH
33956: LD_INT 0
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 5
33965: PUSH
33966: LD_INT 1
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 4
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 3
33985: PUSH
33986: LD_INT 0
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 3
33995: PUSH
33996: LD_INT 1
33998: NEG
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 3
34006: PUSH
34007: LD_INT 2
34009: NEG
34010: PUSH
34011: EMPTY
34012: LIST
34013: LIST
34014: PUSH
34015: LD_INT 5
34017: PUSH
34018: LD_INT 2
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
34072: LD_ADDR_VAR 0 32
34076: PUSH
34077: LD_INT 4
34079: NEG
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 4
34090: NEG
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 3
34102: NEG
34103: PUSH
34104: LD_INT 0
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 3
34113: NEG
34114: PUSH
34115: LD_INT 1
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 4
34124: NEG
34125: PUSH
34126: LD_INT 1
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 5
34135: NEG
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 5
34146: NEG
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 5
34158: NEG
34159: PUSH
34160: LD_INT 2
34162: NEG
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 3
34170: NEG
34171: PUSH
34172: LD_INT 2
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 3
34181: NEG
34182: PUSH
34183: LD_INT 3
34185: NEG
34186: PUSH
34187: EMPTY
34188: LIST
34189: LIST
34190: PUSH
34191: LD_INT 3
34193: NEG
34194: PUSH
34195: LD_INT 4
34197: NEG
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 2
34205: NEG
34206: PUSH
34207: LD_INT 3
34209: NEG
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 3
34229: NEG
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 4
34241: NEG
34242: PUSH
34243: LD_INT 3
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 4
34253: NEG
34254: PUSH
34255: LD_INT 4
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 2
34265: NEG
34266: PUSH
34267: LD_INT 4
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 4
34277: NEG
34278: PUSH
34279: LD_INT 2
34281: NEG
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: LD_INT 4
34292: NEG
34293: PUSH
34294: EMPTY
34295: LIST
34296: LIST
34297: PUSH
34298: LD_INT 0
34300: PUSH
34301: LD_INT 5
34303: NEG
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 4
34314: NEG
34315: PUSH
34316: EMPTY
34317: LIST
34318: LIST
34319: PUSH
34320: LD_INT 1
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 3
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 1
34344: NEG
34345: PUSH
34346: LD_INT 4
34348: NEG
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 5
34360: NEG
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: LD_INT 3
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: LD_INT 5
34383: NEG
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 3
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 3
34401: PUSH
34402: LD_INT 1
34404: NEG
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 4
34412: PUSH
34413: LD_INT 0
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 4
34422: PUSH
34423: LD_INT 1
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: PUSH
34430: LD_INT 3
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 2
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 2
34452: PUSH
34453: LD_INT 1
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 2
34463: PUSH
34464: LD_INT 2
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 4
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 4
34484: PUSH
34485: LD_INT 4
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 4
34494: PUSH
34495: LD_INT 3
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 5
34504: PUSH
34505: LD_INT 4
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 5
34514: PUSH
34515: LD_INT 5
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 4
34524: PUSH
34525: LD_INT 5
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 3
34534: PUSH
34535: LD_INT 4
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 3
34544: PUSH
34545: LD_INT 3
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 5
34554: PUSH
34555: LD_INT 3
34557: PUSH
34558: EMPTY
34559: LIST
34560: LIST
34561: PUSH
34562: LD_INT 3
34564: PUSH
34565: LD_INT 5
34567: PUSH
34568: EMPTY
34569: LIST
34570: LIST
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: LIST
34576: LIST
34577: LIST
34578: LIST
34579: LIST
34580: LIST
34581: LIST
34582: LIST
34583: LIST
34584: LIST
34585: LIST
34586: LIST
34587: LIST
34588: LIST
34589: LIST
34590: LIST
34591: LIST
34592: LIST
34593: LIST
34594: LIST
34595: LIST
34596: LIST
34597: LIST
34598: LIST
34599: LIST
34600: LIST
34601: LIST
34602: LIST
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
34619: LD_ADDR_VAR 0 33
34623: PUSH
34624: LD_INT 4
34626: NEG
34627: PUSH
34628: LD_INT 4
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 4
34638: NEG
34639: PUSH
34640: LD_INT 5
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 3
34650: NEG
34651: PUSH
34652: LD_INT 4
34654: NEG
34655: PUSH
34656: EMPTY
34657: LIST
34658: LIST
34659: PUSH
34660: LD_INT 3
34662: NEG
34663: PUSH
34664: LD_INT 3
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 4
34674: NEG
34675: PUSH
34676: LD_INT 3
34678: NEG
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 5
34686: NEG
34687: PUSH
34688: LD_INT 4
34690: NEG
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 5
34698: NEG
34699: PUSH
34700: LD_INT 5
34702: NEG
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 3
34710: NEG
34711: PUSH
34712: LD_INT 5
34714: NEG
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 5
34722: NEG
34723: PUSH
34724: LD_INT 3
34726: NEG
34727: PUSH
34728: EMPTY
34729: LIST
34730: LIST
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 3
34737: NEG
34738: PUSH
34739: EMPTY
34740: LIST
34741: LIST
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: LD_INT 4
34748: NEG
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 3
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: LD_INT 2
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: LD_INT 2
34781: NEG
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 1
34789: NEG
34790: PUSH
34791: LD_INT 3
34793: NEG
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: PUSH
34799: LD_INT 1
34801: NEG
34802: PUSH
34803: LD_INT 4
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 2
34813: PUSH
34814: LD_INT 2
34816: NEG
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 2
34824: NEG
34825: PUSH
34826: LD_INT 4
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 4
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 4
34846: PUSH
34847: LD_INT 1
34849: NEG
34850: PUSH
34851: EMPTY
34852: LIST
34853: LIST
34854: PUSH
34855: LD_INT 5
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 5
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 4
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 3
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 3
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 3
34908: PUSH
34909: LD_INT 2
34911: NEG
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 5
34919: PUSH
34920: LD_INT 2
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 3
34929: PUSH
34930: LD_INT 3
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 3
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 4
34949: PUSH
34950: LD_INT 3
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 4
34959: PUSH
34960: LD_INT 4
34962: PUSH
34963: EMPTY
34964: LIST
34965: LIST
34966: PUSH
34967: LD_INT 3
34969: PUSH
34970: LD_INT 4
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 2
34979: PUSH
34980: LD_INT 3
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: LD_INT 2
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 4
34999: PUSH
35000: LD_INT 2
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: PUSH
35010: LD_INT 4
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 0
35019: PUSH
35020: LD_INT 4
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: LD_INT 3
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: PUSH
35040: LD_INT 4
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 1
35049: PUSH
35050: LD_INT 5
35052: PUSH
35053: EMPTY
35054: LIST
35055: LIST
35056: PUSH
35057: LD_INT 0
35059: PUSH
35060: LD_INT 5
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 1
35069: NEG
35070: PUSH
35071: LD_INT 4
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 1
35080: NEG
35081: PUSH
35082: LD_INT 3
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 2
35091: PUSH
35092: LD_INT 5
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 2
35101: NEG
35102: PUSH
35103: LD_INT 3
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: LIST
35142: LIST
35143: LIST
35144: LIST
35145: LIST
35146: LIST
35147: LIST
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
35157: LD_ADDR_VAR 0 34
35161: PUSH
35162: LD_INT 0
35164: PUSH
35165: LD_INT 4
35167: NEG
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 0
35175: PUSH
35176: LD_INT 5
35178: NEG
35179: PUSH
35180: EMPTY
35181: LIST
35182: LIST
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: LD_INT 4
35189: NEG
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: PUSH
35195: LD_INT 1
35197: PUSH
35198: LD_INT 3
35200: NEG
35201: PUSH
35202: EMPTY
35203: LIST
35204: LIST
35205: PUSH
35206: LD_INT 0
35208: PUSH
35209: LD_INT 3
35211: NEG
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: LD_INT 4
35223: NEG
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: NEG
35232: PUSH
35233: LD_INT 5
35235: NEG
35236: PUSH
35237: EMPTY
35238: LIST
35239: LIST
35240: PUSH
35241: LD_INT 2
35243: PUSH
35244: LD_INT 3
35246: NEG
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 2
35254: NEG
35255: PUSH
35256: LD_INT 5
35258: NEG
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 3
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 3
35276: PUSH
35277: LD_INT 1
35279: NEG
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 4
35287: PUSH
35288: LD_INT 0
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 4
35297: PUSH
35298: LD_INT 1
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 3
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 2
35317: PUSH
35318: LD_INT 0
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: LD_INT 1
35330: NEG
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: LD_INT 2
35341: NEG
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 4
35349: PUSH
35350: LD_INT 2
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 4
35359: PUSH
35360: LD_INT 4
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 4
35369: PUSH
35370: LD_INT 3
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 5
35379: PUSH
35380: LD_INT 4
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 5
35389: PUSH
35390: LD_INT 5
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 4
35399: PUSH
35400: LD_INT 5
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: LD_INT 3
35409: PUSH
35410: LD_INT 4
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 3
35419: PUSH
35420: LD_INT 3
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 5
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: PUSH
35440: LD_INT 5
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 0
35449: PUSH
35450: LD_INT 3
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 2
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 3
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: PUSH
35480: LD_INT 4
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 4
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 3
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: LD_INT 4
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 2
35531: NEG
35532: PUSH
35533: LD_INT 2
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 4
35542: NEG
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 4
35553: NEG
35554: PUSH
35555: LD_INT 1
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 3
35565: NEG
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 3
35576: NEG
35577: PUSH
35578: LD_INT 1
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 4
35587: NEG
35588: PUSH
35589: LD_INT 1
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 5
35598: NEG
35599: PUSH
35600: LD_INT 0
35602: PUSH
35603: EMPTY
35604: LIST
35605: LIST
35606: PUSH
35607: LD_INT 5
35609: NEG
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 5
35621: NEG
35622: PUSH
35623: LD_INT 2
35625: NEG
35626: PUSH
35627: EMPTY
35628: LIST
35629: LIST
35630: PUSH
35631: LD_INT 3
35633: NEG
35634: PUSH
35635: LD_INT 2
35637: PUSH
35638: EMPTY
35639: LIST
35640: LIST
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: ST_TO_ADDR
// end ; end ;
35689: GO 35692
35691: POP
// case btype of b_depot , b_warehouse :
35692: LD_VAR 0 1
35696: PUSH
35697: LD_INT 0
35699: DOUBLE
35700: EQUAL
35701: IFTRUE 35711
35703: LD_INT 1
35705: DOUBLE
35706: EQUAL
35707: IFTRUE 35711
35709: GO 35912
35711: POP
// case nation of nation_american :
35712: LD_VAR 0 5
35716: PUSH
35717: LD_INT 1
35719: DOUBLE
35720: EQUAL
35721: IFTRUE 35725
35723: GO 35781
35725: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
35726: LD_ADDR_VAR 0 9
35730: PUSH
35731: LD_VAR 0 11
35735: PUSH
35736: LD_VAR 0 12
35740: PUSH
35741: LD_VAR 0 13
35745: PUSH
35746: LD_VAR 0 14
35750: PUSH
35751: LD_VAR 0 15
35755: PUSH
35756: LD_VAR 0 16
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: PUSH
35769: LD_VAR 0 4
35773: PUSH
35774: LD_INT 1
35776: PLUS
35777: ARRAY
35778: ST_TO_ADDR
35779: GO 35910
35781: LD_INT 2
35783: DOUBLE
35784: EQUAL
35785: IFTRUE 35789
35787: GO 35845
35789: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
35790: LD_ADDR_VAR 0 9
35794: PUSH
35795: LD_VAR 0 17
35799: PUSH
35800: LD_VAR 0 18
35804: PUSH
35805: LD_VAR 0 19
35809: PUSH
35810: LD_VAR 0 20
35814: PUSH
35815: LD_VAR 0 21
35819: PUSH
35820: LD_VAR 0 22
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: PUSH
35833: LD_VAR 0 4
35837: PUSH
35838: LD_INT 1
35840: PLUS
35841: ARRAY
35842: ST_TO_ADDR
35843: GO 35910
35845: LD_INT 3
35847: DOUBLE
35848: EQUAL
35849: IFTRUE 35853
35851: GO 35909
35853: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
35854: LD_ADDR_VAR 0 9
35858: PUSH
35859: LD_VAR 0 23
35863: PUSH
35864: LD_VAR 0 24
35868: PUSH
35869: LD_VAR 0 25
35873: PUSH
35874: LD_VAR 0 26
35878: PUSH
35879: LD_VAR 0 27
35883: PUSH
35884: LD_VAR 0 28
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: PUSH
35897: LD_VAR 0 4
35901: PUSH
35902: LD_INT 1
35904: PLUS
35905: ARRAY
35906: ST_TO_ADDR
35907: GO 35910
35909: POP
35910: GO 36465
35912: LD_INT 2
35914: DOUBLE
35915: EQUAL
35916: IFTRUE 35926
35918: LD_INT 3
35920: DOUBLE
35921: EQUAL
35922: IFTRUE 35926
35924: GO 35982
35926: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
35927: LD_ADDR_VAR 0 9
35931: PUSH
35932: LD_VAR 0 29
35936: PUSH
35937: LD_VAR 0 30
35941: PUSH
35942: LD_VAR 0 31
35946: PUSH
35947: LD_VAR 0 32
35951: PUSH
35952: LD_VAR 0 33
35956: PUSH
35957: LD_VAR 0 34
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: PUSH
35970: LD_VAR 0 4
35974: PUSH
35975: LD_INT 1
35977: PLUS
35978: ARRAY
35979: ST_TO_ADDR
35980: GO 36465
35982: LD_INT 16
35984: DOUBLE
35985: EQUAL
35986: IFTRUE 36044
35988: LD_INT 17
35990: DOUBLE
35991: EQUAL
35992: IFTRUE 36044
35994: LD_INT 18
35996: DOUBLE
35997: EQUAL
35998: IFTRUE 36044
36000: LD_INT 19
36002: DOUBLE
36003: EQUAL
36004: IFTRUE 36044
36006: LD_INT 22
36008: DOUBLE
36009: EQUAL
36010: IFTRUE 36044
36012: LD_INT 20
36014: DOUBLE
36015: EQUAL
36016: IFTRUE 36044
36018: LD_INT 21
36020: DOUBLE
36021: EQUAL
36022: IFTRUE 36044
36024: LD_INT 23
36026: DOUBLE
36027: EQUAL
36028: IFTRUE 36044
36030: LD_INT 24
36032: DOUBLE
36033: EQUAL
36034: IFTRUE 36044
36036: LD_INT 25
36038: DOUBLE
36039: EQUAL
36040: IFTRUE 36044
36042: GO 36100
36044: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
36045: LD_ADDR_VAR 0 9
36049: PUSH
36050: LD_VAR 0 35
36054: PUSH
36055: LD_VAR 0 36
36059: PUSH
36060: LD_VAR 0 37
36064: PUSH
36065: LD_VAR 0 38
36069: PUSH
36070: LD_VAR 0 39
36074: PUSH
36075: LD_VAR 0 40
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: PUSH
36088: LD_VAR 0 4
36092: PUSH
36093: LD_INT 1
36095: PLUS
36096: ARRAY
36097: ST_TO_ADDR
36098: GO 36465
36100: LD_INT 6
36102: DOUBLE
36103: EQUAL
36104: IFTRUE 36156
36106: LD_INT 7
36108: DOUBLE
36109: EQUAL
36110: IFTRUE 36156
36112: LD_INT 8
36114: DOUBLE
36115: EQUAL
36116: IFTRUE 36156
36118: LD_INT 13
36120: DOUBLE
36121: EQUAL
36122: IFTRUE 36156
36124: LD_INT 12
36126: DOUBLE
36127: EQUAL
36128: IFTRUE 36156
36130: LD_INT 15
36132: DOUBLE
36133: EQUAL
36134: IFTRUE 36156
36136: LD_INT 11
36138: DOUBLE
36139: EQUAL
36140: IFTRUE 36156
36142: LD_INT 14
36144: DOUBLE
36145: EQUAL
36146: IFTRUE 36156
36148: LD_INT 10
36150: DOUBLE
36151: EQUAL
36152: IFTRUE 36156
36154: GO 36212
36156: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
36157: LD_ADDR_VAR 0 9
36161: PUSH
36162: LD_VAR 0 41
36166: PUSH
36167: LD_VAR 0 42
36171: PUSH
36172: LD_VAR 0 43
36176: PUSH
36177: LD_VAR 0 44
36181: PUSH
36182: LD_VAR 0 45
36186: PUSH
36187: LD_VAR 0 46
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: PUSH
36200: LD_VAR 0 4
36204: PUSH
36205: LD_INT 1
36207: PLUS
36208: ARRAY
36209: ST_TO_ADDR
36210: GO 36465
36212: LD_INT 36
36214: DOUBLE
36215: EQUAL
36216: IFTRUE 36220
36218: GO 36276
36220: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
36221: LD_ADDR_VAR 0 9
36225: PUSH
36226: LD_VAR 0 47
36230: PUSH
36231: LD_VAR 0 48
36235: PUSH
36236: LD_VAR 0 49
36240: PUSH
36241: LD_VAR 0 50
36245: PUSH
36246: LD_VAR 0 51
36250: PUSH
36251: LD_VAR 0 52
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: PUSH
36264: LD_VAR 0 4
36268: PUSH
36269: LD_INT 1
36271: PLUS
36272: ARRAY
36273: ST_TO_ADDR
36274: GO 36465
36276: LD_INT 4
36278: DOUBLE
36279: EQUAL
36280: IFTRUE 36302
36282: LD_INT 5
36284: DOUBLE
36285: EQUAL
36286: IFTRUE 36302
36288: LD_INT 34
36290: DOUBLE
36291: EQUAL
36292: IFTRUE 36302
36294: LD_INT 37
36296: DOUBLE
36297: EQUAL
36298: IFTRUE 36302
36300: GO 36358
36302: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
36303: LD_ADDR_VAR 0 9
36307: PUSH
36308: LD_VAR 0 53
36312: PUSH
36313: LD_VAR 0 54
36317: PUSH
36318: LD_VAR 0 55
36322: PUSH
36323: LD_VAR 0 56
36327: PUSH
36328: LD_VAR 0 57
36332: PUSH
36333: LD_VAR 0 58
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: PUSH
36346: LD_VAR 0 4
36350: PUSH
36351: LD_INT 1
36353: PLUS
36354: ARRAY
36355: ST_TO_ADDR
36356: GO 36465
36358: LD_INT 31
36360: DOUBLE
36361: EQUAL
36362: IFTRUE 36408
36364: LD_INT 32
36366: DOUBLE
36367: EQUAL
36368: IFTRUE 36408
36370: LD_INT 33
36372: DOUBLE
36373: EQUAL
36374: IFTRUE 36408
36376: LD_INT 27
36378: DOUBLE
36379: EQUAL
36380: IFTRUE 36408
36382: LD_INT 26
36384: DOUBLE
36385: EQUAL
36386: IFTRUE 36408
36388: LD_INT 28
36390: DOUBLE
36391: EQUAL
36392: IFTRUE 36408
36394: LD_INT 29
36396: DOUBLE
36397: EQUAL
36398: IFTRUE 36408
36400: LD_INT 30
36402: DOUBLE
36403: EQUAL
36404: IFTRUE 36408
36406: GO 36464
36408: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
36409: LD_ADDR_VAR 0 9
36413: PUSH
36414: LD_VAR 0 59
36418: PUSH
36419: LD_VAR 0 60
36423: PUSH
36424: LD_VAR 0 61
36428: PUSH
36429: LD_VAR 0 62
36433: PUSH
36434: LD_VAR 0 63
36438: PUSH
36439: LD_VAR 0 64
36443: PUSH
36444: EMPTY
36445: LIST
36446: LIST
36447: LIST
36448: LIST
36449: LIST
36450: LIST
36451: PUSH
36452: LD_VAR 0 4
36456: PUSH
36457: LD_INT 1
36459: PLUS
36460: ARRAY
36461: ST_TO_ADDR
36462: GO 36465
36464: POP
// temp_list2 = [ ] ;
36465: LD_ADDR_VAR 0 10
36469: PUSH
36470: EMPTY
36471: ST_TO_ADDR
// for i in temp_list do
36472: LD_ADDR_VAR 0 8
36476: PUSH
36477: LD_VAR 0 9
36481: PUSH
36482: FOR_IN
36483: IFFALSE 36535
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
36485: LD_ADDR_VAR 0 10
36489: PUSH
36490: LD_VAR 0 10
36494: PUSH
36495: LD_VAR 0 8
36499: PUSH
36500: LD_INT 1
36502: ARRAY
36503: PUSH
36504: LD_VAR 0 2
36508: PLUS
36509: PUSH
36510: LD_VAR 0 8
36514: PUSH
36515: LD_INT 2
36517: ARRAY
36518: PUSH
36519: LD_VAR 0 3
36523: PLUS
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: EMPTY
36530: LIST
36531: ADD
36532: ST_TO_ADDR
36533: GO 36482
36535: POP
36536: POP
// result = temp_list2 ;
36537: LD_ADDR_VAR 0 7
36541: PUSH
36542: LD_VAR 0 10
36546: ST_TO_ADDR
// end ;
36547: LD_VAR 0 7
36551: RET
// export function EnemyInRange ( unit , dist ) ; begin
36552: LD_INT 0
36554: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
36555: LD_ADDR_VAR 0 3
36559: PUSH
36560: LD_VAR 0 1
36564: PPUSH
36565: CALL_OW 255
36569: PPUSH
36570: LD_VAR 0 1
36574: PPUSH
36575: CALL_OW 250
36579: PPUSH
36580: LD_VAR 0 1
36584: PPUSH
36585: CALL_OW 251
36589: PPUSH
36590: LD_VAR 0 2
36594: PPUSH
36595: CALL 10323 0 4
36599: PUSH
36600: LD_INT 4
36602: ARRAY
36603: ST_TO_ADDR
// end ;
36604: LD_VAR 0 3
36608: RET
// export function PlayerSeeMe ( unit ) ; begin
36609: LD_INT 0
36611: PPUSH
// result := See ( your_side , unit ) ;
36612: LD_ADDR_VAR 0 2
36616: PUSH
36617: LD_OWVAR 2
36621: PPUSH
36622: LD_VAR 0 1
36626: PPUSH
36627: CALL_OW 292
36631: ST_TO_ADDR
// end ;
36632: LD_VAR 0 2
36636: RET
// export function ReverseDir ( unit ) ; begin
36637: LD_INT 0
36639: PPUSH
// if not unit then
36640: LD_VAR 0 1
36644: NOT
36645: IFFALSE 36649
// exit ;
36647: GO 36672
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
36649: LD_ADDR_VAR 0 2
36653: PUSH
36654: LD_VAR 0 1
36658: PPUSH
36659: CALL_OW 254
36663: PUSH
36664: LD_INT 3
36666: PLUS
36667: PUSH
36668: LD_INT 6
36670: MOD
36671: ST_TO_ADDR
// end ;
36672: LD_VAR 0 2
36676: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
36677: LD_INT 0
36679: PPUSH
36680: PPUSH
36681: PPUSH
36682: PPUSH
36683: PPUSH
// if not hexes then
36684: LD_VAR 0 2
36688: NOT
36689: IFFALSE 36693
// exit ;
36691: GO 36841
// dist := 9999 ;
36693: LD_ADDR_VAR 0 5
36697: PUSH
36698: LD_INT 9999
36700: ST_TO_ADDR
// for i = 1 to hexes do
36701: LD_ADDR_VAR 0 4
36705: PUSH
36706: DOUBLE
36707: LD_INT 1
36709: DEC
36710: ST_TO_ADDR
36711: LD_VAR 0 2
36715: PUSH
36716: FOR_TO
36717: IFFALSE 36829
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
36719: LD_VAR 0 1
36723: PPUSH
36724: LD_VAR 0 2
36728: PUSH
36729: LD_VAR 0 4
36733: ARRAY
36734: PUSH
36735: LD_INT 1
36737: ARRAY
36738: PPUSH
36739: LD_VAR 0 2
36743: PUSH
36744: LD_VAR 0 4
36748: ARRAY
36749: PUSH
36750: LD_INT 2
36752: ARRAY
36753: PPUSH
36754: CALL_OW 297
36758: PUSH
36759: LD_VAR 0 5
36763: LESS
36764: IFFALSE 36827
// begin hex := hexes [ i ] ;
36766: LD_ADDR_VAR 0 7
36770: PUSH
36771: LD_VAR 0 2
36775: PUSH
36776: LD_VAR 0 4
36780: ARRAY
36781: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
36782: LD_ADDR_VAR 0 5
36786: PUSH
36787: LD_VAR 0 1
36791: PPUSH
36792: LD_VAR 0 2
36796: PUSH
36797: LD_VAR 0 4
36801: ARRAY
36802: PUSH
36803: LD_INT 1
36805: ARRAY
36806: PPUSH
36807: LD_VAR 0 2
36811: PUSH
36812: LD_VAR 0 4
36816: ARRAY
36817: PUSH
36818: LD_INT 2
36820: ARRAY
36821: PPUSH
36822: CALL_OW 297
36826: ST_TO_ADDR
// end ; end ;
36827: GO 36716
36829: POP
36830: POP
// result := hex ;
36831: LD_ADDR_VAR 0 3
36835: PUSH
36836: LD_VAR 0 7
36840: ST_TO_ADDR
// end ;
36841: LD_VAR 0 3
36845: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
36846: LD_INT 0
36848: PPUSH
36849: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
36850: LD_VAR 0 1
36854: NOT
36855: PUSH
36856: LD_VAR 0 1
36860: PUSH
36861: LD_INT 21
36863: PUSH
36864: LD_INT 2
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 23
36873: PUSH
36874: LD_INT 2
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PPUSH
36885: CALL_OW 69
36889: IN
36890: NOT
36891: OR
36892: IFFALSE 36896
// exit ;
36894: GO 36943
// for i = 1 to 3 do
36896: LD_ADDR_VAR 0 3
36900: PUSH
36901: DOUBLE
36902: LD_INT 1
36904: DEC
36905: ST_TO_ADDR
36906: LD_INT 3
36908: PUSH
36909: FOR_TO
36910: IFFALSE 36941
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
36912: LD_VAR 0 1
36916: PPUSH
36917: CALL_OW 250
36921: PPUSH
36922: LD_VAR 0 1
36926: PPUSH
36927: CALL_OW 251
36931: PPUSH
36932: LD_INT 1
36934: PPUSH
36935: CALL_OW 453
36939: GO 36909
36941: POP
36942: POP
// end ;
36943: LD_VAR 0 2
36947: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
36948: LD_INT 0
36950: PPUSH
36951: PPUSH
36952: PPUSH
36953: PPUSH
36954: PPUSH
36955: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
36956: LD_VAR 0 1
36960: NOT
36961: PUSH
36962: LD_VAR 0 2
36966: NOT
36967: OR
36968: PUSH
36969: LD_VAR 0 1
36973: PPUSH
36974: CALL_OW 314
36978: OR
36979: IFFALSE 36983
// exit ;
36981: GO 37424
// x := GetX ( enemy_unit ) ;
36983: LD_ADDR_VAR 0 7
36987: PUSH
36988: LD_VAR 0 2
36992: PPUSH
36993: CALL_OW 250
36997: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
36998: LD_ADDR_VAR 0 8
37002: PUSH
37003: LD_VAR 0 2
37007: PPUSH
37008: CALL_OW 251
37012: ST_TO_ADDR
// if not x or not y then
37013: LD_VAR 0 7
37017: NOT
37018: PUSH
37019: LD_VAR 0 8
37023: NOT
37024: OR
37025: IFFALSE 37029
// exit ;
37027: GO 37424
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
37029: LD_ADDR_VAR 0 6
37033: PUSH
37034: LD_VAR 0 7
37038: PPUSH
37039: LD_INT 0
37041: PPUSH
37042: LD_INT 4
37044: PPUSH
37045: CALL_OW 272
37049: PUSH
37050: LD_VAR 0 8
37054: PPUSH
37055: LD_INT 0
37057: PPUSH
37058: LD_INT 4
37060: PPUSH
37061: CALL_OW 273
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_VAR 0 7
37074: PPUSH
37075: LD_INT 1
37077: PPUSH
37078: LD_INT 4
37080: PPUSH
37081: CALL_OW 272
37085: PUSH
37086: LD_VAR 0 8
37090: PPUSH
37091: LD_INT 1
37093: PPUSH
37094: LD_INT 4
37096: PPUSH
37097: CALL_OW 273
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_VAR 0 7
37110: PPUSH
37111: LD_INT 2
37113: PPUSH
37114: LD_INT 4
37116: PPUSH
37117: CALL_OW 272
37121: PUSH
37122: LD_VAR 0 8
37126: PPUSH
37127: LD_INT 2
37129: PPUSH
37130: LD_INT 4
37132: PPUSH
37133: CALL_OW 273
37137: PUSH
37138: EMPTY
37139: LIST
37140: LIST
37141: PUSH
37142: LD_VAR 0 7
37146: PPUSH
37147: LD_INT 3
37149: PPUSH
37150: LD_INT 4
37152: PPUSH
37153: CALL_OW 272
37157: PUSH
37158: LD_VAR 0 8
37162: PPUSH
37163: LD_INT 3
37165: PPUSH
37166: LD_INT 4
37168: PPUSH
37169: CALL_OW 273
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_VAR 0 7
37182: PPUSH
37183: LD_INT 4
37185: PPUSH
37186: LD_INT 4
37188: PPUSH
37189: CALL_OW 272
37193: PUSH
37194: LD_VAR 0 8
37198: PPUSH
37199: LD_INT 4
37201: PPUSH
37202: LD_INT 4
37204: PPUSH
37205: CALL_OW 273
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_VAR 0 7
37218: PPUSH
37219: LD_INT 5
37221: PPUSH
37222: LD_INT 4
37224: PPUSH
37225: CALL_OW 272
37229: PUSH
37230: LD_VAR 0 8
37234: PPUSH
37235: LD_INT 5
37237: PPUSH
37238: LD_INT 4
37240: PPUSH
37241: CALL_OW 273
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: LIST
37256: LIST
37257: ST_TO_ADDR
// for i = tmp downto 1 do
37258: LD_ADDR_VAR 0 4
37262: PUSH
37263: DOUBLE
37264: LD_VAR 0 6
37268: INC
37269: ST_TO_ADDR
37270: LD_INT 1
37272: PUSH
37273: FOR_DOWNTO
37274: IFFALSE 37375
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
37276: LD_VAR 0 6
37280: PUSH
37281: LD_VAR 0 4
37285: ARRAY
37286: PUSH
37287: LD_INT 1
37289: ARRAY
37290: PPUSH
37291: LD_VAR 0 6
37295: PUSH
37296: LD_VAR 0 4
37300: ARRAY
37301: PUSH
37302: LD_INT 2
37304: ARRAY
37305: PPUSH
37306: CALL_OW 488
37310: NOT
37311: PUSH
37312: LD_VAR 0 6
37316: PUSH
37317: LD_VAR 0 4
37321: ARRAY
37322: PUSH
37323: LD_INT 1
37325: ARRAY
37326: PPUSH
37327: LD_VAR 0 6
37331: PUSH
37332: LD_VAR 0 4
37336: ARRAY
37337: PUSH
37338: LD_INT 2
37340: ARRAY
37341: PPUSH
37342: CALL_OW 428
37346: PUSH
37347: LD_INT 0
37349: NONEQUAL
37350: OR
37351: IFFALSE 37373
// tmp := Delete ( tmp , i ) ;
37353: LD_ADDR_VAR 0 6
37357: PUSH
37358: LD_VAR 0 6
37362: PPUSH
37363: LD_VAR 0 4
37367: PPUSH
37368: CALL_OW 3
37372: ST_TO_ADDR
37373: GO 37273
37375: POP
37376: POP
// j := GetClosestHex ( unit , tmp ) ;
37377: LD_ADDR_VAR 0 5
37381: PUSH
37382: LD_VAR 0 1
37386: PPUSH
37387: LD_VAR 0 6
37391: PPUSH
37392: CALL 36677 0 2
37396: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
37397: LD_VAR 0 1
37401: PPUSH
37402: LD_VAR 0 5
37406: PUSH
37407: LD_INT 1
37409: ARRAY
37410: PPUSH
37411: LD_VAR 0 5
37415: PUSH
37416: LD_INT 2
37418: ARRAY
37419: PPUSH
37420: CALL_OW 111
// end ;
37424: LD_VAR 0 3
37428: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
37429: LD_INT 0
37431: PPUSH
37432: PPUSH
37433: PPUSH
// uc_side = 0 ;
37434: LD_ADDR_OWVAR 20
37438: PUSH
37439: LD_INT 0
37441: ST_TO_ADDR
// uc_nation = 0 ;
37442: LD_ADDR_OWVAR 21
37446: PUSH
37447: LD_INT 0
37449: ST_TO_ADDR
// InitHc_All ( ) ;
37450: CALL_OW 584
// InitVc ;
37454: CALL_OW 20
// if mastodonts then
37458: LD_VAR 0 6
37462: IFFALSE 37529
// for i = 1 to mastodonts do
37464: LD_ADDR_VAR 0 11
37468: PUSH
37469: DOUBLE
37470: LD_INT 1
37472: DEC
37473: ST_TO_ADDR
37474: LD_VAR 0 6
37478: PUSH
37479: FOR_TO
37480: IFFALSE 37527
// begin vc_chassis := 31 ;
37482: LD_ADDR_OWVAR 37
37486: PUSH
37487: LD_INT 31
37489: ST_TO_ADDR
// vc_control := control_rider ;
37490: LD_ADDR_OWVAR 38
37494: PUSH
37495: LD_INT 4
37497: ST_TO_ADDR
// animal := CreateVehicle ;
37498: LD_ADDR_VAR 0 12
37502: PUSH
37503: CALL_OW 45
37507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37508: LD_VAR 0 12
37512: PPUSH
37513: LD_VAR 0 8
37517: PPUSH
37518: LD_INT 0
37520: PPUSH
37521: CALL 39717 0 3
// end ;
37525: GO 37479
37527: POP
37528: POP
// if horses then
37529: LD_VAR 0 5
37533: IFFALSE 37600
// for i = 1 to horses do
37535: LD_ADDR_VAR 0 11
37539: PUSH
37540: DOUBLE
37541: LD_INT 1
37543: DEC
37544: ST_TO_ADDR
37545: LD_VAR 0 5
37549: PUSH
37550: FOR_TO
37551: IFFALSE 37598
// begin hc_class := 21 ;
37553: LD_ADDR_OWVAR 28
37557: PUSH
37558: LD_INT 21
37560: ST_TO_ADDR
// hc_gallery :=  ;
37561: LD_ADDR_OWVAR 33
37565: PUSH
37566: LD_STRING 
37568: ST_TO_ADDR
// animal := CreateHuman ;
37569: LD_ADDR_VAR 0 12
37573: PUSH
37574: CALL_OW 44
37578: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37579: LD_VAR 0 12
37583: PPUSH
37584: LD_VAR 0 8
37588: PPUSH
37589: LD_INT 0
37591: PPUSH
37592: CALL 39717 0 3
// end ;
37596: GO 37550
37598: POP
37599: POP
// if birds then
37600: LD_VAR 0 1
37604: IFFALSE 37671
// for i = 1 to birds do
37606: LD_ADDR_VAR 0 11
37610: PUSH
37611: DOUBLE
37612: LD_INT 1
37614: DEC
37615: ST_TO_ADDR
37616: LD_VAR 0 1
37620: PUSH
37621: FOR_TO
37622: IFFALSE 37669
// begin hc_class = 18 ;
37624: LD_ADDR_OWVAR 28
37628: PUSH
37629: LD_INT 18
37631: ST_TO_ADDR
// hc_gallery =  ;
37632: LD_ADDR_OWVAR 33
37636: PUSH
37637: LD_STRING 
37639: ST_TO_ADDR
// animal := CreateHuman ;
37640: LD_ADDR_VAR 0 12
37644: PUSH
37645: CALL_OW 44
37649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37650: LD_VAR 0 12
37654: PPUSH
37655: LD_VAR 0 8
37659: PPUSH
37660: LD_INT 0
37662: PPUSH
37663: CALL 39717 0 3
// end ;
37667: GO 37621
37669: POP
37670: POP
// if tigers then
37671: LD_VAR 0 2
37675: IFFALSE 37759
// for i = 1 to tigers do
37677: LD_ADDR_VAR 0 11
37681: PUSH
37682: DOUBLE
37683: LD_INT 1
37685: DEC
37686: ST_TO_ADDR
37687: LD_VAR 0 2
37691: PUSH
37692: FOR_TO
37693: IFFALSE 37757
// begin hc_class = class_tiger ;
37695: LD_ADDR_OWVAR 28
37699: PUSH
37700: LD_INT 14
37702: ST_TO_ADDR
// hc_gallery =  ;
37703: LD_ADDR_OWVAR 33
37707: PUSH
37708: LD_STRING 
37710: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
37711: LD_ADDR_OWVAR 35
37715: PUSH
37716: LD_INT 7
37718: NEG
37719: PPUSH
37720: LD_INT 7
37722: PPUSH
37723: CALL_OW 12
37727: ST_TO_ADDR
// animal := CreateHuman ;
37728: LD_ADDR_VAR 0 12
37732: PUSH
37733: CALL_OW 44
37737: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37738: LD_VAR 0 12
37742: PPUSH
37743: LD_VAR 0 8
37747: PPUSH
37748: LD_INT 0
37750: PPUSH
37751: CALL 39717 0 3
// end ;
37755: GO 37692
37757: POP
37758: POP
// if apemans then
37759: LD_VAR 0 3
37763: IFFALSE 37886
// for i = 1 to apemans do
37765: LD_ADDR_VAR 0 11
37769: PUSH
37770: DOUBLE
37771: LD_INT 1
37773: DEC
37774: ST_TO_ADDR
37775: LD_VAR 0 3
37779: PUSH
37780: FOR_TO
37781: IFFALSE 37884
// begin hc_class = class_apeman ;
37783: LD_ADDR_OWVAR 28
37787: PUSH
37788: LD_INT 12
37790: ST_TO_ADDR
// hc_gallery =  ;
37791: LD_ADDR_OWVAR 33
37795: PUSH
37796: LD_STRING 
37798: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
37799: LD_ADDR_OWVAR 35
37803: PUSH
37804: LD_INT 5
37806: NEG
37807: PPUSH
37808: LD_INT 5
37810: PPUSH
37811: CALL_OW 12
37815: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
37816: LD_ADDR_OWVAR 31
37820: PUSH
37821: LD_INT 1
37823: PPUSH
37824: LD_INT 3
37826: PPUSH
37827: CALL_OW 12
37831: PUSH
37832: LD_INT 1
37834: PPUSH
37835: LD_INT 3
37837: PPUSH
37838: CALL_OW 12
37842: PUSH
37843: LD_INT 0
37845: PUSH
37846: LD_INT 0
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: LIST
37853: LIST
37854: ST_TO_ADDR
// animal := CreateHuman ;
37855: LD_ADDR_VAR 0 12
37859: PUSH
37860: CALL_OW 44
37864: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37865: LD_VAR 0 12
37869: PPUSH
37870: LD_VAR 0 8
37874: PPUSH
37875: LD_INT 0
37877: PPUSH
37878: CALL 39717 0 3
// end ;
37882: GO 37780
37884: POP
37885: POP
// if enchidnas then
37886: LD_VAR 0 4
37890: IFFALSE 37957
// for i = 1 to enchidnas do
37892: LD_ADDR_VAR 0 11
37896: PUSH
37897: DOUBLE
37898: LD_INT 1
37900: DEC
37901: ST_TO_ADDR
37902: LD_VAR 0 4
37906: PUSH
37907: FOR_TO
37908: IFFALSE 37955
// begin hc_class = 13 ;
37910: LD_ADDR_OWVAR 28
37914: PUSH
37915: LD_INT 13
37917: ST_TO_ADDR
// hc_gallery =  ;
37918: LD_ADDR_OWVAR 33
37922: PUSH
37923: LD_STRING 
37925: ST_TO_ADDR
// animal := CreateHuman ;
37926: LD_ADDR_VAR 0 12
37930: PUSH
37931: CALL_OW 44
37935: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
37936: LD_VAR 0 12
37940: PPUSH
37941: LD_VAR 0 8
37945: PPUSH
37946: LD_INT 0
37948: PPUSH
37949: CALL 39717 0 3
// end ;
37953: GO 37907
37955: POP
37956: POP
// if fishes then
37957: LD_VAR 0 7
37961: IFFALSE 38028
// for i = 1 to fishes do
37963: LD_ADDR_VAR 0 11
37967: PUSH
37968: DOUBLE
37969: LD_INT 1
37971: DEC
37972: ST_TO_ADDR
37973: LD_VAR 0 7
37977: PUSH
37978: FOR_TO
37979: IFFALSE 38026
// begin hc_class = 20 ;
37981: LD_ADDR_OWVAR 28
37985: PUSH
37986: LD_INT 20
37988: ST_TO_ADDR
// hc_gallery =  ;
37989: LD_ADDR_OWVAR 33
37993: PUSH
37994: LD_STRING 
37996: ST_TO_ADDR
// animal := CreateHuman ;
37997: LD_ADDR_VAR 0 12
38001: PUSH
38002: CALL_OW 44
38006: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
38007: LD_VAR 0 12
38011: PPUSH
38012: LD_VAR 0 9
38016: PPUSH
38017: LD_INT 0
38019: PPUSH
38020: CALL 39717 0 3
// end ;
38024: GO 37978
38026: POP
38027: POP
// end ;
38028: LD_VAR 0 10
38032: RET
// export function WantHeal ( sci , unit ) ; begin
38033: LD_INT 0
38035: PPUSH
// if GetTaskList ( sci ) > 0 then
38036: LD_VAR 0 1
38040: PPUSH
38041: CALL_OW 437
38045: PUSH
38046: LD_INT 0
38048: GREATER
38049: IFFALSE 38119
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
38051: LD_VAR 0 1
38055: PPUSH
38056: CALL_OW 437
38060: PUSH
38061: LD_INT 1
38063: ARRAY
38064: PUSH
38065: LD_INT 1
38067: ARRAY
38068: PUSH
38069: LD_STRING l
38071: EQUAL
38072: PUSH
38073: LD_VAR 0 1
38077: PPUSH
38078: CALL_OW 437
38082: PUSH
38083: LD_INT 1
38085: ARRAY
38086: PUSH
38087: LD_INT 4
38089: ARRAY
38090: PUSH
38091: LD_VAR 0 2
38095: EQUAL
38096: AND
38097: IFFALSE 38109
// result := true else
38099: LD_ADDR_VAR 0 3
38103: PUSH
38104: LD_INT 1
38106: ST_TO_ADDR
38107: GO 38117
// result := false ;
38109: LD_ADDR_VAR 0 3
38113: PUSH
38114: LD_INT 0
38116: ST_TO_ADDR
// end else
38117: GO 38127
// result := false ;
38119: LD_ADDR_VAR 0 3
38123: PUSH
38124: LD_INT 0
38126: ST_TO_ADDR
// end ;
38127: LD_VAR 0 3
38131: RET
// export function HealTarget ( sci ) ; begin
38132: LD_INT 0
38134: PPUSH
// if not sci then
38135: LD_VAR 0 1
38139: NOT
38140: IFFALSE 38144
// exit ;
38142: GO 38209
// result := 0 ;
38144: LD_ADDR_VAR 0 2
38148: PUSH
38149: LD_INT 0
38151: ST_TO_ADDR
// if GetTaskList ( sci ) then
38152: LD_VAR 0 1
38156: PPUSH
38157: CALL_OW 437
38161: IFFALSE 38209
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
38163: LD_VAR 0 1
38167: PPUSH
38168: CALL_OW 437
38172: PUSH
38173: LD_INT 1
38175: ARRAY
38176: PUSH
38177: LD_INT 1
38179: ARRAY
38180: PUSH
38181: LD_STRING l
38183: EQUAL
38184: IFFALSE 38209
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
38186: LD_ADDR_VAR 0 2
38190: PUSH
38191: LD_VAR 0 1
38195: PPUSH
38196: CALL_OW 437
38200: PUSH
38201: LD_INT 1
38203: ARRAY
38204: PUSH
38205: LD_INT 4
38207: ARRAY
38208: ST_TO_ADDR
// end ;
38209: LD_VAR 0 2
38213: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
38214: LD_INT 0
38216: PPUSH
38217: PPUSH
38218: PPUSH
38219: PPUSH
// if not base_units then
38220: LD_VAR 0 1
38224: NOT
38225: IFFALSE 38229
// exit ;
38227: GO 38316
// result := false ;
38229: LD_ADDR_VAR 0 2
38233: PUSH
38234: LD_INT 0
38236: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
38237: LD_ADDR_VAR 0 5
38241: PUSH
38242: LD_VAR 0 1
38246: PPUSH
38247: LD_INT 21
38249: PUSH
38250: LD_INT 3
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PPUSH
38257: CALL_OW 72
38261: ST_TO_ADDR
// if not tmp then
38262: LD_VAR 0 5
38266: NOT
38267: IFFALSE 38271
// exit ;
38269: GO 38316
// for i in tmp do
38271: LD_ADDR_VAR 0 3
38275: PUSH
38276: LD_VAR 0 5
38280: PUSH
38281: FOR_IN
38282: IFFALSE 38314
// begin result := EnemyInRange ( i , 22 ) ;
38284: LD_ADDR_VAR 0 2
38288: PUSH
38289: LD_VAR 0 3
38293: PPUSH
38294: LD_INT 22
38296: PPUSH
38297: CALL 36552 0 2
38301: ST_TO_ADDR
// if result then
38302: LD_VAR 0 2
38306: IFFALSE 38312
// exit ;
38308: POP
38309: POP
38310: GO 38316
// end ;
38312: GO 38281
38314: POP
38315: POP
// end ;
38316: LD_VAR 0 2
38320: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
38321: LD_INT 0
38323: PPUSH
38324: PPUSH
// if not units then
38325: LD_VAR 0 1
38329: NOT
38330: IFFALSE 38334
// exit ;
38332: GO 38404
// result := [ ] ;
38334: LD_ADDR_VAR 0 3
38338: PUSH
38339: EMPTY
38340: ST_TO_ADDR
// for i in units do
38341: LD_ADDR_VAR 0 4
38345: PUSH
38346: LD_VAR 0 1
38350: PUSH
38351: FOR_IN
38352: IFFALSE 38402
// if GetTag ( i ) = tag then
38354: LD_VAR 0 4
38358: PPUSH
38359: CALL_OW 110
38363: PUSH
38364: LD_VAR 0 2
38368: EQUAL
38369: IFFALSE 38400
// result := Insert ( result , result + 1 , i ) ;
38371: LD_ADDR_VAR 0 3
38375: PUSH
38376: LD_VAR 0 3
38380: PPUSH
38381: LD_VAR 0 3
38385: PUSH
38386: LD_INT 1
38388: PLUS
38389: PPUSH
38390: LD_VAR 0 4
38394: PPUSH
38395: CALL_OW 2
38399: ST_TO_ADDR
38400: GO 38351
38402: POP
38403: POP
// end ;
38404: LD_VAR 0 3
38408: RET
// export function IsDriver ( un ) ; begin
38409: LD_INT 0
38411: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
38412: LD_ADDR_VAR 0 2
38416: PUSH
38417: LD_VAR 0 1
38421: PUSH
38422: LD_INT 55
38424: PUSH
38425: EMPTY
38426: LIST
38427: PPUSH
38428: CALL_OW 69
38432: IN
38433: ST_TO_ADDR
// end ;
38434: LD_VAR 0 2
38438: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
38439: LD_INT 0
38441: PPUSH
38442: PPUSH
// list := [ ] ;
38443: LD_ADDR_VAR 0 5
38447: PUSH
38448: EMPTY
38449: ST_TO_ADDR
// case d of 0 :
38450: LD_VAR 0 3
38454: PUSH
38455: LD_INT 0
38457: DOUBLE
38458: EQUAL
38459: IFTRUE 38463
38461: GO 38596
38463: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
38464: LD_ADDR_VAR 0 5
38468: PUSH
38469: LD_VAR 0 1
38473: PUSH
38474: LD_INT 4
38476: MINUS
38477: PUSH
38478: LD_VAR 0 2
38482: PUSH
38483: LD_INT 4
38485: MINUS
38486: PUSH
38487: LD_INT 2
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: LIST
38494: PUSH
38495: LD_VAR 0 1
38499: PUSH
38500: LD_INT 3
38502: MINUS
38503: PUSH
38504: LD_VAR 0 2
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: LIST
38516: PUSH
38517: LD_VAR 0 1
38521: PUSH
38522: LD_INT 4
38524: PLUS
38525: PUSH
38526: LD_VAR 0 2
38530: PUSH
38531: LD_INT 4
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: PUSH
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 3
38546: PLUS
38547: PUSH
38548: LD_VAR 0 2
38552: PUSH
38553: LD_INT 3
38555: PLUS
38556: PUSH
38557: LD_INT 5
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: LIST
38564: PUSH
38565: LD_VAR 0 1
38569: PUSH
38570: LD_VAR 0 2
38574: PUSH
38575: LD_INT 4
38577: PLUS
38578: PUSH
38579: LD_INT 0
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: LIST
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: ST_TO_ADDR
// end ; 1 :
38594: GO 39294
38596: LD_INT 1
38598: DOUBLE
38599: EQUAL
38600: IFTRUE 38604
38602: GO 38737
38604: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
38605: LD_ADDR_VAR 0 5
38609: PUSH
38610: LD_VAR 0 1
38614: PUSH
38615: LD_VAR 0 2
38619: PUSH
38620: LD_INT 4
38622: MINUS
38623: PUSH
38624: LD_INT 3
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: LIST
38631: PUSH
38632: LD_VAR 0 1
38636: PUSH
38637: LD_INT 3
38639: MINUS
38640: PUSH
38641: LD_VAR 0 2
38645: PUSH
38646: LD_INT 3
38648: MINUS
38649: PUSH
38650: LD_INT 2
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: LIST
38657: PUSH
38658: LD_VAR 0 1
38662: PUSH
38663: LD_INT 4
38665: MINUS
38666: PUSH
38667: LD_VAR 0 2
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: LIST
38679: PUSH
38680: LD_VAR 0 1
38684: PUSH
38685: LD_VAR 0 2
38689: PUSH
38690: LD_INT 3
38692: PLUS
38693: PUSH
38694: LD_INT 0
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: LIST
38701: PUSH
38702: LD_VAR 0 1
38706: PUSH
38707: LD_INT 4
38709: PLUS
38710: PUSH
38711: LD_VAR 0 2
38715: PUSH
38716: LD_INT 4
38718: PLUS
38719: PUSH
38720: LD_INT 5
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: LIST
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: ST_TO_ADDR
// end ; 2 :
38735: GO 39294
38737: LD_INT 2
38739: DOUBLE
38740: EQUAL
38741: IFTRUE 38745
38743: GO 38874
38745: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
38746: LD_ADDR_VAR 0 5
38750: PUSH
38751: LD_VAR 0 1
38755: PUSH
38756: LD_VAR 0 2
38760: PUSH
38761: LD_INT 3
38763: MINUS
38764: PUSH
38765: LD_INT 3
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: LIST
38772: PUSH
38773: LD_VAR 0 1
38777: PUSH
38778: LD_INT 4
38780: PLUS
38781: PUSH
38782: LD_VAR 0 2
38786: PUSH
38787: LD_INT 4
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: LIST
38794: PUSH
38795: LD_VAR 0 1
38799: PUSH
38800: LD_VAR 0 2
38804: PUSH
38805: LD_INT 4
38807: PLUS
38808: PUSH
38809: LD_INT 0
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: LIST
38816: PUSH
38817: LD_VAR 0 1
38821: PUSH
38822: LD_INT 3
38824: MINUS
38825: PUSH
38826: LD_VAR 0 2
38830: PUSH
38831: LD_INT 1
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: LIST
38838: PUSH
38839: LD_VAR 0 1
38843: PUSH
38844: LD_INT 4
38846: MINUS
38847: PUSH
38848: LD_VAR 0 2
38852: PUSH
38853: LD_INT 4
38855: MINUS
38856: PUSH
38857: LD_INT 2
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: LIST
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: ST_TO_ADDR
// end ; 3 :
38872: GO 39294
38874: LD_INT 3
38876: DOUBLE
38877: EQUAL
38878: IFTRUE 38882
38880: GO 39015
38882: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
38883: LD_ADDR_VAR 0 5
38887: PUSH
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 3
38895: PLUS
38896: PUSH
38897: LD_VAR 0 2
38901: PUSH
38902: LD_INT 4
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: LIST
38909: PUSH
38910: LD_VAR 0 1
38914: PUSH
38915: LD_INT 4
38917: PLUS
38918: PUSH
38919: LD_VAR 0 2
38923: PUSH
38924: LD_INT 4
38926: PLUS
38927: PUSH
38928: LD_INT 5
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: LIST
38935: PUSH
38936: LD_VAR 0 1
38940: PUSH
38941: LD_INT 4
38943: MINUS
38944: PUSH
38945: LD_VAR 0 2
38949: PUSH
38950: LD_INT 1
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: LIST
38957: PUSH
38958: LD_VAR 0 1
38962: PUSH
38963: LD_VAR 0 2
38967: PUSH
38968: LD_INT 4
38970: MINUS
38971: PUSH
38972: LD_INT 3
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: LIST
38979: PUSH
38980: LD_VAR 0 1
38984: PUSH
38985: LD_INT 3
38987: MINUS
38988: PUSH
38989: LD_VAR 0 2
38993: PUSH
38994: LD_INT 3
38996: MINUS
38997: PUSH
38998: LD_INT 2
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: LIST
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: LIST
39010: LIST
39011: LIST
39012: ST_TO_ADDR
// end ; 4 :
39013: GO 39294
39015: LD_INT 4
39017: DOUBLE
39018: EQUAL
39019: IFTRUE 39023
39021: GO 39156
39023: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
39024: LD_ADDR_VAR 0 5
39028: PUSH
39029: LD_VAR 0 1
39033: PUSH
39034: LD_VAR 0 2
39038: PUSH
39039: LD_INT 4
39041: PLUS
39042: PUSH
39043: LD_INT 0
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: LIST
39050: PUSH
39051: LD_VAR 0 1
39055: PUSH
39056: LD_INT 3
39058: PLUS
39059: PUSH
39060: LD_VAR 0 2
39064: PUSH
39065: LD_INT 3
39067: PLUS
39068: PUSH
39069: LD_INT 5
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: LIST
39076: PUSH
39077: LD_VAR 0 1
39081: PUSH
39082: LD_INT 4
39084: PLUS
39085: PUSH
39086: LD_VAR 0 2
39090: PUSH
39091: LD_INT 4
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: LIST
39098: PUSH
39099: LD_VAR 0 1
39103: PUSH
39104: LD_VAR 0 2
39108: PUSH
39109: LD_INT 3
39111: MINUS
39112: PUSH
39113: LD_INT 3
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: LIST
39120: PUSH
39121: LD_VAR 0 1
39125: PUSH
39126: LD_INT 4
39128: MINUS
39129: PUSH
39130: LD_VAR 0 2
39134: PUSH
39135: LD_INT 4
39137: MINUS
39138: PUSH
39139: LD_INT 2
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: LIST
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: LIST
39151: LIST
39152: LIST
39153: ST_TO_ADDR
// end ; 5 :
39154: GO 39294
39156: LD_INT 5
39158: DOUBLE
39159: EQUAL
39160: IFTRUE 39164
39162: GO 39293
39164: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
39165: LD_ADDR_VAR 0 5
39169: PUSH
39170: LD_VAR 0 1
39174: PUSH
39175: LD_INT 4
39177: MINUS
39178: PUSH
39179: LD_VAR 0 2
39183: PUSH
39184: LD_INT 1
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: LIST
39191: PUSH
39192: LD_VAR 0 1
39196: PUSH
39197: LD_VAR 0 2
39201: PUSH
39202: LD_INT 4
39204: MINUS
39205: PUSH
39206: LD_INT 3
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: LIST
39213: PUSH
39214: LD_VAR 0 1
39218: PUSH
39219: LD_INT 4
39221: PLUS
39222: PUSH
39223: LD_VAR 0 2
39227: PUSH
39228: LD_INT 4
39230: PLUS
39231: PUSH
39232: LD_INT 5
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: LIST
39239: PUSH
39240: LD_VAR 0 1
39244: PUSH
39245: LD_INT 3
39247: PLUS
39248: PUSH
39249: LD_VAR 0 2
39253: PUSH
39254: LD_INT 4
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: LIST
39261: PUSH
39262: LD_VAR 0 1
39266: PUSH
39267: LD_VAR 0 2
39271: PUSH
39272: LD_INT 3
39274: PLUS
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: LIST
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: ST_TO_ADDR
// end ; end ;
39291: GO 39294
39293: POP
// result := list ;
39294: LD_ADDR_VAR 0 4
39298: PUSH
39299: LD_VAR 0 5
39303: ST_TO_ADDR
// end ;
39304: LD_VAR 0 4
39308: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
39309: LD_INT 0
39311: PPUSH
39312: PPUSH
39313: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
39314: LD_VAR 0 1
39318: NOT
39319: PUSH
39320: LD_VAR 0 2
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 2
39330: PUSH
39331: LD_INT 3
39333: PUSH
39334: LD_INT 4
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: IN
39343: NOT
39344: OR
39345: IFFALSE 39349
// exit ;
39347: GO 39441
// tmp := [ ] ;
39349: LD_ADDR_VAR 0 5
39353: PUSH
39354: EMPTY
39355: ST_TO_ADDR
// for i in units do
39356: LD_ADDR_VAR 0 4
39360: PUSH
39361: LD_VAR 0 1
39365: PUSH
39366: FOR_IN
39367: IFFALSE 39410
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
39369: LD_ADDR_VAR 0 5
39373: PUSH
39374: LD_VAR 0 5
39378: PPUSH
39379: LD_VAR 0 5
39383: PUSH
39384: LD_INT 1
39386: PLUS
39387: PPUSH
39388: LD_VAR 0 4
39392: PPUSH
39393: LD_VAR 0 2
39397: PPUSH
39398: CALL_OW 259
39402: PPUSH
39403: CALL_OW 2
39407: ST_TO_ADDR
39408: GO 39366
39410: POP
39411: POP
// if not tmp then
39412: LD_VAR 0 5
39416: NOT
39417: IFFALSE 39421
// exit ;
39419: GO 39441
// result := SortListByListDesc ( units , tmp ) ;
39421: LD_ADDR_VAR 0 3
39425: PUSH
39426: LD_VAR 0 1
39430: PPUSH
39431: LD_VAR 0 5
39435: PPUSH
39436: CALL_OW 77
39440: ST_TO_ADDR
// end ;
39441: LD_VAR 0 3
39445: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
39446: LD_INT 0
39448: PPUSH
39449: PPUSH
39450: PPUSH
// result := false ;
39451: LD_ADDR_VAR 0 3
39455: PUSH
39456: LD_INT 0
39458: ST_TO_ADDR
// x := GetX ( building ) ;
39459: LD_ADDR_VAR 0 4
39463: PUSH
39464: LD_VAR 0 2
39468: PPUSH
39469: CALL_OW 250
39473: ST_TO_ADDR
// y := GetY ( building ) ;
39474: LD_ADDR_VAR 0 5
39478: PUSH
39479: LD_VAR 0 2
39483: PPUSH
39484: CALL_OW 251
39488: ST_TO_ADDR
// if not building or not x or not y then
39489: LD_VAR 0 2
39493: NOT
39494: PUSH
39495: LD_VAR 0 4
39499: NOT
39500: OR
39501: PUSH
39502: LD_VAR 0 5
39506: NOT
39507: OR
39508: IFFALSE 39512
// exit ;
39510: GO 39604
// if GetTaskList ( unit ) then
39512: LD_VAR 0 1
39516: PPUSH
39517: CALL_OW 437
39521: IFFALSE 39604
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39523: LD_STRING e
39525: PUSH
39526: LD_VAR 0 1
39530: PPUSH
39531: CALL_OW 437
39535: PUSH
39536: LD_INT 1
39538: ARRAY
39539: PUSH
39540: LD_INT 1
39542: ARRAY
39543: EQUAL
39544: PUSH
39545: LD_VAR 0 4
39549: PUSH
39550: LD_VAR 0 1
39554: PPUSH
39555: CALL_OW 437
39559: PUSH
39560: LD_INT 1
39562: ARRAY
39563: PUSH
39564: LD_INT 2
39566: ARRAY
39567: EQUAL
39568: AND
39569: PUSH
39570: LD_VAR 0 5
39574: PUSH
39575: LD_VAR 0 1
39579: PPUSH
39580: CALL_OW 437
39584: PUSH
39585: LD_INT 1
39587: ARRAY
39588: PUSH
39589: LD_INT 3
39591: ARRAY
39592: EQUAL
39593: AND
39594: IFFALSE 39604
// result := true end ;
39596: LD_ADDR_VAR 0 3
39600: PUSH
39601: LD_INT 1
39603: ST_TO_ADDR
// end ;
39604: LD_VAR 0 3
39608: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
39609: LD_INT 0
39611: PPUSH
// result := false ;
39612: LD_ADDR_VAR 0 4
39616: PUSH
39617: LD_INT 0
39619: ST_TO_ADDR
// if GetTaskList ( unit ) then
39620: LD_VAR 0 1
39624: PPUSH
39625: CALL_OW 437
39629: IFFALSE 39712
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
39631: LD_STRING M
39633: PUSH
39634: LD_VAR 0 1
39638: PPUSH
39639: CALL_OW 437
39643: PUSH
39644: LD_INT 1
39646: ARRAY
39647: PUSH
39648: LD_INT 1
39650: ARRAY
39651: EQUAL
39652: PUSH
39653: LD_VAR 0 2
39657: PUSH
39658: LD_VAR 0 1
39662: PPUSH
39663: CALL_OW 437
39667: PUSH
39668: LD_INT 1
39670: ARRAY
39671: PUSH
39672: LD_INT 2
39674: ARRAY
39675: EQUAL
39676: AND
39677: PUSH
39678: LD_VAR 0 3
39682: PUSH
39683: LD_VAR 0 1
39687: PPUSH
39688: CALL_OW 437
39692: PUSH
39693: LD_INT 1
39695: ARRAY
39696: PUSH
39697: LD_INT 3
39699: ARRAY
39700: EQUAL
39701: AND
39702: IFFALSE 39712
// result := true ;
39704: LD_ADDR_VAR 0 4
39708: PUSH
39709: LD_INT 1
39711: ST_TO_ADDR
// end ; end ;
39712: LD_VAR 0 4
39716: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
39717: LD_INT 0
39719: PPUSH
39720: PPUSH
39721: PPUSH
39722: PPUSH
// if not unit or not area then
39723: LD_VAR 0 1
39727: NOT
39728: PUSH
39729: LD_VAR 0 2
39733: NOT
39734: OR
39735: IFFALSE 39739
// exit ;
39737: GO 39903
// tmp := AreaToList ( area , i ) ;
39739: LD_ADDR_VAR 0 6
39743: PUSH
39744: LD_VAR 0 2
39748: PPUSH
39749: LD_VAR 0 5
39753: PPUSH
39754: CALL_OW 517
39758: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
39759: LD_ADDR_VAR 0 5
39763: PUSH
39764: DOUBLE
39765: LD_INT 1
39767: DEC
39768: ST_TO_ADDR
39769: LD_VAR 0 6
39773: PUSH
39774: LD_INT 1
39776: ARRAY
39777: PUSH
39778: FOR_TO
39779: IFFALSE 39901
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
39781: LD_ADDR_VAR 0 7
39785: PUSH
39786: LD_VAR 0 6
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PUSH
39795: LD_VAR 0 5
39799: ARRAY
39800: PUSH
39801: LD_VAR 0 6
39805: PUSH
39806: LD_INT 2
39808: ARRAY
39809: PUSH
39810: LD_VAR 0 5
39814: ARRAY
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
39820: LD_VAR 0 7
39824: PUSH
39825: LD_INT 1
39827: ARRAY
39828: PPUSH
39829: LD_VAR 0 7
39833: PUSH
39834: LD_INT 2
39836: ARRAY
39837: PPUSH
39838: CALL_OW 428
39842: PUSH
39843: LD_INT 0
39845: EQUAL
39846: IFFALSE 39899
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
39848: LD_VAR 0 1
39852: PPUSH
39853: LD_VAR 0 7
39857: PUSH
39858: LD_INT 1
39860: ARRAY
39861: PPUSH
39862: LD_VAR 0 7
39866: PUSH
39867: LD_INT 2
39869: ARRAY
39870: PPUSH
39871: LD_VAR 0 3
39875: PPUSH
39876: CALL_OW 48
// result := IsPlaced ( unit ) ;
39880: LD_ADDR_VAR 0 4
39884: PUSH
39885: LD_VAR 0 1
39889: PPUSH
39890: CALL_OW 305
39894: ST_TO_ADDR
// exit ;
39895: POP
39896: POP
39897: GO 39903
// end ; end ;
39899: GO 39778
39901: POP
39902: POP
// end ;
39903: LD_VAR 0 4
39907: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
39908: LD_INT 0
39910: PPUSH
39911: PPUSH
39912: PPUSH
// if not side or side > 8 then
39913: LD_VAR 0 1
39917: NOT
39918: PUSH
39919: LD_VAR 0 1
39923: PUSH
39924: LD_INT 8
39926: GREATER
39927: OR
39928: IFFALSE 39932
// exit ;
39930: GO 40119
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
39932: LD_ADDR_VAR 0 4
39936: PUSH
39937: LD_INT 22
39939: PUSH
39940: LD_VAR 0 1
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 21
39951: PUSH
39952: LD_INT 3
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: EMPTY
39960: LIST
39961: LIST
39962: PPUSH
39963: CALL_OW 69
39967: ST_TO_ADDR
// if not tmp then
39968: LD_VAR 0 4
39972: NOT
39973: IFFALSE 39977
// exit ;
39975: GO 40119
// enable_addtolog := true ;
39977: LD_ADDR_OWVAR 81
39981: PUSH
39982: LD_INT 1
39984: ST_TO_ADDR
// AddToLog ( [ ) ;
39985: LD_STRING [
39987: PPUSH
39988: CALL_OW 561
// for i in tmp do
39992: LD_ADDR_VAR 0 3
39996: PUSH
39997: LD_VAR 0 4
40001: PUSH
40002: FOR_IN
40003: IFFALSE 40110
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
40005: LD_STRING [
40007: PUSH
40008: LD_VAR 0 3
40012: PPUSH
40013: CALL_OW 266
40017: STR
40018: PUSH
40019: LD_STRING , 
40021: STR
40022: PUSH
40023: LD_VAR 0 3
40027: PPUSH
40028: CALL_OW 250
40032: STR
40033: PUSH
40034: LD_STRING , 
40036: STR
40037: PUSH
40038: LD_VAR 0 3
40042: PPUSH
40043: CALL_OW 251
40047: STR
40048: PUSH
40049: LD_STRING , 
40051: STR
40052: PUSH
40053: LD_VAR 0 3
40057: PPUSH
40058: CALL_OW 254
40062: STR
40063: PUSH
40064: LD_STRING , 
40066: STR
40067: PUSH
40068: LD_VAR 0 3
40072: PPUSH
40073: LD_INT 1
40075: PPUSH
40076: CALL_OW 268
40080: STR
40081: PUSH
40082: LD_STRING , 
40084: STR
40085: PUSH
40086: LD_VAR 0 3
40090: PPUSH
40091: LD_INT 2
40093: PPUSH
40094: CALL_OW 268
40098: STR
40099: PUSH
40100: LD_STRING ],
40102: STR
40103: PPUSH
40104: CALL_OW 561
// end ;
40108: GO 40002
40110: POP
40111: POP
// AddToLog ( ]; ) ;
40112: LD_STRING ];
40114: PPUSH
40115: CALL_OW 561
// end ;
40119: LD_VAR 0 2
40123: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
40124: LD_INT 0
40126: PPUSH
40127: PPUSH
40128: PPUSH
40129: PPUSH
40130: PPUSH
// if not area or not rate or not max then
40131: LD_VAR 0 1
40135: NOT
40136: PUSH
40137: LD_VAR 0 2
40141: NOT
40142: OR
40143: PUSH
40144: LD_VAR 0 4
40148: NOT
40149: OR
40150: IFFALSE 40154
// exit ;
40152: GO 40346
// while 1 do
40154: LD_INT 1
40156: IFFALSE 40346
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
40158: LD_ADDR_VAR 0 9
40162: PUSH
40163: LD_VAR 0 1
40167: PPUSH
40168: LD_INT 1
40170: PPUSH
40171: CALL_OW 287
40175: PUSH
40176: LD_INT 10
40178: MUL
40179: ST_TO_ADDR
// r := rate / 10 ;
40180: LD_ADDR_VAR 0 7
40184: PUSH
40185: LD_VAR 0 2
40189: PUSH
40190: LD_INT 10
40192: DIVREAL
40193: ST_TO_ADDR
// time := 1 1$00 ;
40194: LD_ADDR_VAR 0 8
40198: PUSH
40199: LD_INT 2100
40201: ST_TO_ADDR
// if amount < min then
40202: LD_VAR 0 9
40206: PUSH
40207: LD_VAR 0 3
40211: LESS
40212: IFFALSE 40230
// r := r * 2 else
40214: LD_ADDR_VAR 0 7
40218: PUSH
40219: LD_VAR 0 7
40223: PUSH
40224: LD_INT 2
40226: MUL
40227: ST_TO_ADDR
40228: GO 40256
// if amount > max then
40230: LD_VAR 0 9
40234: PUSH
40235: LD_VAR 0 4
40239: GREATER
40240: IFFALSE 40256
// r := r / 2 ;
40242: LD_ADDR_VAR 0 7
40246: PUSH
40247: LD_VAR 0 7
40251: PUSH
40252: LD_INT 2
40254: DIVREAL
40255: ST_TO_ADDR
// time := time / r ;
40256: LD_ADDR_VAR 0 8
40260: PUSH
40261: LD_VAR 0 8
40265: PUSH
40266: LD_VAR 0 7
40270: DIVREAL
40271: ST_TO_ADDR
// if time < 0 then
40272: LD_VAR 0 8
40276: PUSH
40277: LD_INT 0
40279: LESS
40280: IFFALSE 40297
// time := time * - 1 ;
40282: LD_ADDR_VAR 0 8
40286: PUSH
40287: LD_VAR 0 8
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: MUL
40296: ST_TO_ADDR
// wait ( time ) ;
40297: LD_VAR 0 8
40301: PPUSH
40302: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
40306: LD_INT 35
40308: PPUSH
40309: LD_INT 875
40311: PPUSH
40312: CALL_OW 12
40316: PPUSH
40317: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
40321: LD_INT 1
40323: PPUSH
40324: LD_INT 5
40326: PPUSH
40327: CALL_OW 12
40331: PPUSH
40332: LD_VAR 0 1
40336: PPUSH
40337: LD_INT 1
40339: PPUSH
40340: CALL_OW 55
// end ;
40344: GO 40154
// end ;
40346: LD_VAR 0 5
40350: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
40351: LD_INT 0
40353: PPUSH
40354: PPUSH
40355: PPUSH
40356: PPUSH
40357: PPUSH
40358: PPUSH
40359: PPUSH
40360: PPUSH
// if not turrets or not factories then
40361: LD_VAR 0 1
40365: NOT
40366: PUSH
40367: LD_VAR 0 2
40371: NOT
40372: OR
40373: IFFALSE 40377
// exit ;
40375: GO 40684
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
40377: LD_ADDR_VAR 0 10
40381: PUSH
40382: LD_INT 5
40384: PUSH
40385: LD_INT 6
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 2
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 3
40404: PUSH
40405: LD_INT 5
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: LIST
40416: PUSH
40417: LD_INT 24
40419: PUSH
40420: LD_INT 25
40422: PUSH
40423: EMPTY
40424: LIST
40425: LIST
40426: PUSH
40427: LD_INT 23
40429: PUSH
40430: LD_INT 27
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 42
40443: PUSH
40444: LD_INT 43
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 44
40453: PUSH
40454: LD_INT 46
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 45
40463: PUSH
40464: LD_INT 47
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: LIST
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: LIST
40480: ST_TO_ADDR
// result := [ ] ;
40481: LD_ADDR_VAR 0 3
40485: PUSH
40486: EMPTY
40487: ST_TO_ADDR
// for i in turrets do
40488: LD_ADDR_VAR 0 4
40492: PUSH
40493: LD_VAR 0 1
40497: PUSH
40498: FOR_IN
40499: IFFALSE 40682
// begin nat := GetNation ( i ) ;
40501: LD_ADDR_VAR 0 7
40505: PUSH
40506: LD_VAR 0 4
40510: PPUSH
40511: CALL_OW 248
40515: ST_TO_ADDR
// weapon := 0 ;
40516: LD_ADDR_VAR 0 8
40520: PUSH
40521: LD_INT 0
40523: ST_TO_ADDR
// if not nat then
40524: LD_VAR 0 7
40528: NOT
40529: IFFALSE 40533
// continue ;
40531: GO 40498
// for j in list [ nat ] do
40533: LD_ADDR_VAR 0 5
40537: PUSH
40538: LD_VAR 0 10
40542: PUSH
40543: LD_VAR 0 7
40547: ARRAY
40548: PUSH
40549: FOR_IN
40550: IFFALSE 40591
// if GetBWeapon ( i ) = j [ 1 ] then
40552: LD_VAR 0 4
40556: PPUSH
40557: CALL_OW 269
40561: PUSH
40562: LD_VAR 0 5
40566: PUSH
40567: LD_INT 1
40569: ARRAY
40570: EQUAL
40571: IFFALSE 40589
// begin weapon := j [ 2 ] ;
40573: LD_ADDR_VAR 0 8
40577: PUSH
40578: LD_VAR 0 5
40582: PUSH
40583: LD_INT 2
40585: ARRAY
40586: ST_TO_ADDR
// break ;
40587: GO 40591
// end ;
40589: GO 40549
40591: POP
40592: POP
// if not weapon then
40593: LD_VAR 0 8
40597: NOT
40598: IFFALSE 40602
// continue ;
40600: GO 40498
// for k in factories do
40602: LD_ADDR_VAR 0 6
40606: PUSH
40607: LD_VAR 0 2
40611: PUSH
40612: FOR_IN
40613: IFFALSE 40678
// begin weapons := AvailableWeaponList ( k ) ;
40615: LD_ADDR_VAR 0 9
40619: PUSH
40620: LD_VAR 0 6
40624: PPUSH
40625: CALL_OW 478
40629: ST_TO_ADDR
// if not weapons then
40630: LD_VAR 0 9
40634: NOT
40635: IFFALSE 40639
// continue ;
40637: GO 40612
// if weapon in weapons then
40639: LD_VAR 0 8
40643: PUSH
40644: LD_VAR 0 9
40648: IN
40649: IFFALSE 40676
// begin result := [ i , weapon ] ;
40651: LD_ADDR_VAR 0 3
40655: PUSH
40656: LD_VAR 0 4
40660: PUSH
40661: LD_VAR 0 8
40665: PUSH
40666: EMPTY
40667: LIST
40668: LIST
40669: ST_TO_ADDR
// exit ;
40670: POP
40671: POP
40672: POP
40673: POP
40674: GO 40684
// end ; end ;
40676: GO 40612
40678: POP
40679: POP
// end ;
40680: GO 40498
40682: POP
40683: POP
// end ;
40684: LD_VAR 0 3
40688: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
40689: LD_INT 0
40691: PPUSH
// if not side or side > 8 then
40692: LD_VAR 0 3
40696: NOT
40697: PUSH
40698: LD_VAR 0 3
40702: PUSH
40703: LD_INT 8
40705: GREATER
40706: OR
40707: IFFALSE 40711
// exit ;
40709: GO 40770
// if not range then
40711: LD_VAR 0 4
40715: NOT
40716: IFFALSE 40727
// range := - 12 ;
40718: LD_ADDR_VAR 0 4
40722: PUSH
40723: LD_INT 12
40725: NEG
40726: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
40727: LD_VAR 0 1
40731: PPUSH
40732: LD_VAR 0 2
40736: PPUSH
40737: LD_VAR 0 3
40741: PPUSH
40742: LD_VAR 0 4
40746: PPUSH
40747: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
40751: LD_VAR 0 1
40755: PPUSH
40756: LD_VAR 0 2
40760: PPUSH
40761: LD_VAR 0 3
40765: PPUSH
40766: CALL_OW 331
// end ;
40770: LD_VAR 0 5
40774: RET
// export function Video ( mode ) ; begin
40775: LD_INT 0
40777: PPUSH
// ingame_video = mode ;
40778: LD_ADDR_OWVAR 52
40782: PUSH
40783: LD_VAR 0 1
40787: ST_TO_ADDR
// interface_hidden = mode ;
40788: LD_ADDR_OWVAR 54
40792: PUSH
40793: LD_VAR 0 1
40797: ST_TO_ADDR
// end ;
40798: LD_VAR 0 2
40802: RET
// export function Join ( array , element ) ; begin
40803: LD_INT 0
40805: PPUSH
// result := Replace ( array , array + 1 , element ) ;
40806: LD_ADDR_VAR 0 3
40810: PUSH
40811: LD_VAR 0 1
40815: PPUSH
40816: LD_VAR 0 1
40820: PUSH
40821: LD_INT 1
40823: PLUS
40824: PPUSH
40825: LD_VAR 0 2
40829: PPUSH
40830: CALL_OW 1
40834: ST_TO_ADDR
// end ;
40835: LD_VAR 0 3
40839: RET
// export function JoinUnion ( array , element ) ; begin
40840: LD_INT 0
40842: PPUSH
// result := array union element ;
40843: LD_ADDR_VAR 0 3
40847: PUSH
40848: LD_VAR 0 1
40852: PUSH
40853: LD_VAR 0 2
40857: UNION
40858: ST_TO_ADDR
// end ;
40859: LD_VAR 0 3
40863: RET
// export function GetBehemoths ( side ) ; begin
40864: LD_INT 0
40866: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
40867: LD_ADDR_VAR 0 2
40871: PUSH
40872: LD_INT 22
40874: PUSH
40875: LD_VAR 0 1
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 31
40886: PUSH
40887: LD_INT 25
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PPUSH
40898: CALL_OW 69
40902: ST_TO_ADDR
// end ;
40903: LD_VAR 0 2
40907: RET
// export function Shuffle ( array ) ; var i , index ; begin
40908: LD_INT 0
40910: PPUSH
40911: PPUSH
40912: PPUSH
// result := [ ] ;
40913: LD_ADDR_VAR 0 2
40917: PUSH
40918: EMPTY
40919: ST_TO_ADDR
// if not array then
40920: LD_VAR 0 1
40924: NOT
40925: IFFALSE 40929
// exit ;
40927: GO 41028
// Randomize ;
40929: CALL_OW 10
// for i = array downto 1 do
40933: LD_ADDR_VAR 0 3
40937: PUSH
40938: DOUBLE
40939: LD_VAR 0 1
40943: INC
40944: ST_TO_ADDR
40945: LD_INT 1
40947: PUSH
40948: FOR_DOWNTO
40949: IFFALSE 41026
// begin index := rand ( 1 , array ) ;
40951: LD_ADDR_VAR 0 4
40955: PUSH
40956: LD_INT 1
40958: PPUSH
40959: LD_VAR 0 1
40963: PPUSH
40964: CALL_OW 12
40968: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
40969: LD_ADDR_VAR 0 2
40973: PUSH
40974: LD_VAR 0 2
40978: PPUSH
40979: LD_VAR 0 2
40983: PUSH
40984: LD_INT 1
40986: PLUS
40987: PPUSH
40988: LD_VAR 0 1
40992: PUSH
40993: LD_VAR 0 4
40997: ARRAY
40998: PPUSH
40999: CALL_OW 2
41003: ST_TO_ADDR
// array := Delete ( array , index ) ;
41004: LD_ADDR_VAR 0 1
41008: PUSH
41009: LD_VAR 0 1
41013: PPUSH
41014: LD_VAR 0 4
41018: PPUSH
41019: CALL_OW 3
41023: ST_TO_ADDR
// end ;
41024: GO 40948
41026: POP
41027: POP
// end ;
41028: LD_VAR 0 2
41032: RET
// export function GetBaseMaterials ( base ) ; begin
41033: LD_INT 0
41035: PPUSH
// result := [ 0 , 0 , 0 ] ;
41036: LD_ADDR_VAR 0 2
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: LD_INT 0
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: LIST
41054: ST_TO_ADDR
// if not base then
41055: LD_VAR 0 1
41059: NOT
41060: IFFALSE 41064
// exit ;
41062: GO 41113
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
41064: LD_ADDR_VAR 0 2
41068: PUSH
41069: LD_VAR 0 1
41073: PPUSH
41074: LD_INT 1
41076: PPUSH
41077: CALL_OW 275
41081: PUSH
41082: LD_VAR 0 1
41086: PPUSH
41087: LD_INT 2
41089: PPUSH
41090: CALL_OW 275
41094: PUSH
41095: LD_VAR 0 1
41099: PPUSH
41100: LD_INT 3
41102: PPUSH
41103: CALL_OW 275
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: LIST
41112: ST_TO_ADDR
// end ;
41113: LD_VAR 0 2
41117: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
41118: LD_INT 0
41120: PPUSH
41121: PPUSH
// result := array ;
41122: LD_ADDR_VAR 0 3
41126: PUSH
41127: LD_VAR 0 1
41131: ST_TO_ADDR
// if size > 0 then
41132: LD_VAR 0 2
41136: PUSH
41137: LD_INT 0
41139: GREATER
41140: IFFALSE 41186
// for i := array downto size do
41142: LD_ADDR_VAR 0 4
41146: PUSH
41147: DOUBLE
41148: LD_VAR 0 1
41152: INC
41153: ST_TO_ADDR
41154: LD_VAR 0 2
41158: PUSH
41159: FOR_DOWNTO
41160: IFFALSE 41184
// result := Delete ( result , result ) ;
41162: LD_ADDR_VAR 0 3
41166: PUSH
41167: LD_VAR 0 3
41171: PPUSH
41172: LD_VAR 0 3
41176: PPUSH
41177: CALL_OW 3
41181: ST_TO_ADDR
41182: GO 41159
41184: POP
41185: POP
// end ;
41186: LD_VAR 0 3
41190: RET
// export function ComExit ( unit ) ; var tmp ; begin
41191: LD_INT 0
41193: PPUSH
41194: PPUSH
// if not IsInUnit ( unit ) then
41195: LD_VAR 0 1
41199: PPUSH
41200: CALL_OW 310
41204: NOT
41205: IFFALSE 41209
// exit ;
41207: GO 41269
// tmp := IsInUnit ( unit ) ;
41209: LD_ADDR_VAR 0 3
41213: PUSH
41214: LD_VAR 0 1
41218: PPUSH
41219: CALL_OW 310
41223: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
41224: LD_VAR 0 3
41228: PPUSH
41229: CALL_OW 247
41233: PUSH
41234: LD_INT 2
41236: EQUAL
41237: IFFALSE 41250
// ComExitVehicle ( unit ) else
41239: LD_VAR 0 1
41243: PPUSH
41244: CALL_OW 121
41248: GO 41259
// ComExitBuilding ( unit ) ;
41250: LD_VAR 0 1
41254: PPUSH
41255: CALL_OW 122
// result := tmp ;
41259: LD_ADDR_VAR 0 2
41263: PUSH
41264: LD_VAR 0 3
41268: ST_TO_ADDR
// end ;
41269: LD_VAR 0 2
41273: RET
// export function ComExitAll ( units ) ; var i ; begin
41274: LD_INT 0
41276: PPUSH
41277: PPUSH
// if not units then
41278: LD_VAR 0 1
41282: NOT
41283: IFFALSE 41287
// exit ;
41285: GO 41313
// for i in units do
41287: LD_ADDR_VAR 0 3
41291: PUSH
41292: LD_VAR 0 1
41296: PUSH
41297: FOR_IN
41298: IFFALSE 41311
// ComExit ( i ) ;
41300: LD_VAR 0 3
41304: PPUSH
41305: CALL 41191 0 1
41309: GO 41297
41311: POP
41312: POP
// end ;
41313: LD_VAR 0 2
41317: RET
// export function ResetHc ; begin
41318: LD_INT 0
41320: PPUSH
// InitHc ;
41321: CALL_OW 19
// hc_importance := 0 ;
41325: LD_ADDR_OWVAR 32
41329: PUSH
41330: LD_INT 0
41332: ST_TO_ADDR
// end ;
41333: LD_VAR 0 1
41337: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
41338: LD_INT 0
41340: PPUSH
41341: PPUSH
41342: PPUSH
// _x := ( x1 + x2 ) div 2 ;
41343: LD_ADDR_VAR 0 6
41347: PUSH
41348: LD_VAR 0 1
41352: PUSH
41353: LD_VAR 0 3
41357: PLUS
41358: PUSH
41359: LD_INT 2
41361: DIV
41362: ST_TO_ADDR
// if _x < 0 then
41363: LD_VAR 0 6
41367: PUSH
41368: LD_INT 0
41370: LESS
41371: IFFALSE 41388
// _x := _x * - 1 ;
41373: LD_ADDR_VAR 0 6
41377: PUSH
41378: LD_VAR 0 6
41382: PUSH
41383: LD_INT 1
41385: NEG
41386: MUL
41387: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
41388: LD_ADDR_VAR 0 7
41392: PUSH
41393: LD_VAR 0 2
41397: PUSH
41398: LD_VAR 0 4
41402: PLUS
41403: PUSH
41404: LD_INT 2
41406: DIV
41407: ST_TO_ADDR
// if _y < 0 then
41408: LD_VAR 0 7
41412: PUSH
41413: LD_INT 0
41415: LESS
41416: IFFALSE 41433
// _y := _y * - 1 ;
41418: LD_ADDR_VAR 0 7
41422: PUSH
41423: LD_VAR 0 7
41427: PUSH
41428: LD_INT 1
41430: NEG
41431: MUL
41432: ST_TO_ADDR
// result := [ _x , _y ] ;
41433: LD_ADDR_VAR 0 5
41437: PUSH
41438: LD_VAR 0 6
41442: PUSH
41443: LD_VAR 0 7
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: ST_TO_ADDR
// end ;
41452: LD_VAR 0 5
41456: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
41457: LD_INT 0
41459: PPUSH
41460: PPUSH
41461: PPUSH
41462: PPUSH
// task := GetTaskList ( unit ) ;
41463: LD_ADDR_VAR 0 7
41467: PUSH
41468: LD_VAR 0 1
41472: PPUSH
41473: CALL_OW 437
41477: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
41478: LD_VAR 0 7
41482: NOT
41483: PUSH
41484: LD_VAR 0 1
41488: PPUSH
41489: LD_VAR 0 2
41493: PPUSH
41494: CALL_OW 308
41498: NOT
41499: AND
41500: IFFALSE 41504
// exit ;
41502: GO 41622
// if IsInArea ( unit , area ) then
41504: LD_VAR 0 1
41508: PPUSH
41509: LD_VAR 0 2
41513: PPUSH
41514: CALL_OW 308
41518: IFFALSE 41536
// begin ComMoveToArea ( unit , goAway ) ;
41520: LD_VAR 0 1
41524: PPUSH
41525: LD_VAR 0 3
41529: PPUSH
41530: CALL_OW 113
// exit ;
41534: GO 41622
// end ; if task [ 1 ] [ 1 ] <> M then
41536: LD_VAR 0 7
41540: PUSH
41541: LD_INT 1
41543: ARRAY
41544: PUSH
41545: LD_INT 1
41547: ARRAY
41548: PUSH
41549: LD_STRING M
41551: NONEQUAL
41552: IFFALSE 41556
// exit ;
41554: GO 41622
// x := task [ 1 ] [ 2 ] ;
41556: LD_ADDR_VAR 0 5
41560: PUSH
41561: LD_VAR 0 7
41565: PUSH
41566: LD_INT 1
41568: ARRAY
41569: PUSH
41570: LD_INT 2
41572: ARRAY
41573: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
41574: LD_ADDR_VAR 0 6
41578: PUSH
41579: LD_VAR 0 7
41583: PUSH
41584: LD_INT 1
41586: ARRAY
41587: PUSH
41588: LD_INT 3
41590: ARRAY
41591: ST_TO_ADDR
// if InArea ( x , y , area ) then
41592: LD_VAR 0 5
41596: PPUSH
41597: LD_VAR 0 6
41601: PPUSH
41602: LD_VAR 0 2
41606: PPUSH
41607: CALL_OW 309
41611: IFFALSE 41622
// ComStop ( unit ) ;
41613: LD_VAR 0 1
41617: PPUSH
41618: CALL_OW 141
// end ;
41622: LD_VAR 0 4
41626: RET
// export function Abs ( value ) ; begin
41627: LD_INT 0
41629: PPUSH
// result := value ;
41630: LD_ADDR_VAR 0 2
41634: PUSH
41635: LD_VAR 0 1
41639: ST_TO_ADDR
// if value < 0 then
41640: LD_VAR 0 1
41644: PUSH
41645: LD_INT 0
41647: LESS
41648: IFFALSE 41665
// result := value * - 1 ;
41650: LD_ADDR_VAR 0 2
41654: PUSH
41655: LD_VAR 0 1
41659: PUSH
41660: LD_INT 1
41662: NEG
41663: MUL
41664: ST_TO_ADDR
// end ;
41665: LD_VAR 0 2
41669: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
41670: LD_INT 0
41672: PPUSH
41673: PPUSH
41674: PPUSH
41675: PPUSH
41676: PPUSH
41677: PPUSH
41678: PPUSH
41679: PPUSH
// if not unit or not building then
41680: LD_VAR 0 1
41684: NOT
41685: PUSH
41686: LD_VAR 0 2
41690: NOT
41691: OR
41692: IFFALSE 41696
// exit ;
41694: GO 41922
// x := GetX ( building ) ;
41696: LD_ADDR_VAR 0 4
41700: PUSH
41701: LD_VAR 0 2
41705: PPUSH
41706: CALL_OW 250
41710: ST_TO_ADDR
// y := GetY ( building ) ;
41711: LD_ADDR_VAR 0 6
41715: PUSH
41716: LD_VAR 0 2
41720: PPUSH
41721: CALL_OW 251
41725: ST_TO_ADDR
// d := GetDir ( building ) ;
41726: LD_ADDR_VAR 0 8
41730: PUSH
41731: LD_VAR 0 2
41735: PPUSH
41736: CALL_OW 254
41740: ST_TO_ADDR
// r := 4 ;
41741: LD_ADDR_VAR 0 9
41745: PUSH
41746: LD_INT 4
41748: ST_TO_ADDR
// for i := 1 to 5 do
41749: LD_ADDR_VAR 0 10
41753: PUSH
41754: DOUBLE
41755: LD_INT 1
41757: DEC
41758: ST_TO_ADDR
41759: LD_INT 5
41761: PUSH
41762: FOR_TO
41763: IFFALSE 41920
// begin _x := ShiftX ( x , d , r + i ) ;
41765: LD_ADDR_VAR 0 5
41769: PUSH
41770: LD_VAR 0 4
41774: PPUSH
41775: LD_VAR 0 8
41779: PPUSH
41780: LD_VAR 0 9
41784: PUSH
41785: LD_VAR 0 10
41789: PLUS
41790: PPUSH
41791: CALL_OW 272
41795: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
41796: LD_ADDR_VAR 0 7
41800: PUSH
41801: LD_VAR 0 6
41805: PPUSH
41806: LD_VAR 0 8
41810: PPUSH
41811: LD_VAR 0 9
41815: PUSH
41816: LD_VAR 0 10
41820: PLUS
41821: PPUSH
41822: CALL_OW 273
41826: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
41827: LD_VAR 0 5
41831: PPUSH
41832: LD_VAR 0 7
41836: PPUSH
41837: CALL_OW 488
41841: PUSH
41842: LD_VAR 0 5
41846: PPUSH
41847: LD_VAR 0 7
41851: PPUSH
41852: CALL_OW 428
41856: PPUSH
41857: CALL_OW 247
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: LD_INT 2
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: IN
41872: NOT
41873: AND
41874: IFFALSE 41918
// begin ComMoveXY ( unit , _x , _y ) ;
41876: LD_VAR 0 1
41880: PPUSH
41881: LD_VAR 0 5
41885: PPUSH
41886: LD_VAR 0 7
41890: PPUSH
41891: CALL_OW 111
// result := [ _x , _y ] ;
41895: LD_ADDR_VAR 0 3
41899: PUSH
41900: LD_VAR 0 5
41904: PUSH
41905: LD_VAR 0 7
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: ST_TO_ADDR
// exit ;
41914: POP
41915: POP
41916: GO 41922
// end ; end ;
41918: GO 41762
41920: POP
41921: POP
// end ;
41922: LD_VAR 0 3
41926: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
41927: LD_INT 0
41929: PPUSH
41930: PPUSH
41931: PPUSH
// result := 0 ;
41932: LD_ADDR_VAR 0 3
41936: PUSH
41937: LD_INT 0
41939: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
41940: LD_VAR 0 1
41944: PUSH
41945: LD_INT 0
41947: LESS
41948: PUSH
41949: LD_VAR 0 1
41953: PUSH
41954: LD_INT 8
41956: GREATER
41957: OR
41958: PUSH
41959: LD_VAR 0 2
41963: PUSH
41964: LD_INT 0
41966: LESS
41967: OR
41968: PUSH
41969: LD_VAR 0 2
41973: PUSH
41974: LD_INT 8
41976: GREATER
41977: OR
41978: IFFALSE 41982
// exit ;
41980: GO 42057
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
41982: LD_ADDR_VAR 0 4
41986: PUSH
41987: LD_INT 22
41989: PUSH
41990: LD_VAR 0 2
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PPUSH
41999: CALL_OW 69
42003: PUSH
42004: FOR_IN
42005: IFFALSE 42055
// begin un := UnitShoot ( i ) ;
42007: LD_ADDR_VAR 0 5
42011: PUSH
42012: LD_VAR 0 4
42016: PPUSH
42017: CALL_OW 504
42021: ST_TO_ADDR
// if GetSide ( un ) = side1 then
42022: LD_VAR 0 5
42026: PPUSH
42027: CALL_OW 255
42031: PUSH
42032: LD_VAR 0 1
42036: EQUAL
42037: IFFALSE 42053
// begin result := un ;
42039: LD_ADDR_VAR 0 3
42043: PUSH
42044: LD_VAR 0 5
42048: ST_TO_ADDR
// exit ;
42049: POP
42050: POP
42051: GO 42057
// end ; end ;
42053: GO 42004
42055: POP
42056: POP
// end ;
42057: LD_VAR 0 3
42061: RET
// export function GetCargoBay ( units ) ; begin
42062: LD_INT 0
42064: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
42065: LD_ADDR_VAR 0 2
42069: PUSH
42070: LD_VAR 0 1
42074: PPUSH
42075: LD_INT 2
42077: PUSH
42078: LD_INT 34
42080: PUSH
42081: LD_INT 12
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 34
42090: PUSH
42091: LD_INT 51
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 34
42100: PUSH
42101: LD_INT 32
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 34
42110: PUSH
42111: LD_EXP 59
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: PPUSH
42127: CALL_OW 72
42131: ST_TO_ADDR
// end ; end_of_file
42132: LD_VAR 0 2
42136: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
42137: LD_INT 0
42139: PPUSH
42140: PPUSH
// skirmish := false ;
42141: LD_ADDR_EXP 12
42145: PUSH
42146: LD_INT 0
42148: ST_TO_ADDR
// debug_mc := false ;
42149: LD_ADDR_EXP 13
42153: PUSH
42154: LD_INT 0
42156: ST_TO_ADDR
// mc_bases := [ ] ;
42157: LD_ADDR_EXP 14
42161: PUSH
42162: EMPTY
42163: ST_TO_ADDR
// mc_sides := [ ] ;
42164: LD_ADDR_EXP 40
42168: PUSH
42169: EMPTY
42170: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
42171: LD_ADDR_EXP 15
42175: PUSH
42176: EMPTY
42177: ST_TO_ADDR
// mc_building_repairs := [ ] ;
42178: LD_ADDR_EXP 16
42182: PUSH
42183: EMPTY
42184: ST_TO_ADDR
// mc_need_heal := [ ] ;
42185: LD_ADDR_EXP 17
42189: PUSH
42190: EMPTY
42191: ST_TO_ADDR
// mc_healers := [ ] ;
42192: LD_ADDR_EXP 18
42196: PUSH
42197: EMPTY
42198: ST_TO_ADDR
// mc_build_list := [ ] ;
42199: LD_ADDR_EXP 19
42203: PUSH
42204: EMPTY
42205: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
42206: LD_ADDR_EXP 46
42210: PUSH
42211: EMPTY
42212: ST_TO_ADDR
// mc_builders := [ ] ;
42213: LD_ADDR_EXP 20
42217: PUSH
42218: EMPTY
42219: ST_TO_ADDR
// mc_construct_list := [ ] ;
42220: LD_ADDR_EXP 21
42224: PUSH
42225: EMPTY
42226: ST_TO_ADDR
// mc_turret_list := [ ] ;
42227: LD_ADDR_EXP 22
42231: PUSH
42232: EMPTY
42233: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
42234: LD_ADDR_EXP 23
42238: PUSH
42239: EMPTY
42240: ST_TO_ADDR
// mc_miners := [ ] ;
42241: LD_ADDR_EXP 28
42245: PUSH
42246: EMPTY
42247: ST_TO_ADDR
// mc_mines := [ ] ;
42248: LD_ADDR_EXP 27
42252: PUSH
42253: EMPTY
42254: ST_TO_ADDR
// mc_minefields := [ ] ;
42255: LD_ADDR_EXP 29
42259: PUSH
42260: EMPTY
42261: ST_TO_ADDR
// mc_crates := [ ] ;
42262: LD_ADDR_EXP 30
42266: PUSH
42267: EMPTY
42268: ST_TO_ADDR
// mc_crates_collector := [ ] ;
42269: LD_ADDR_EXP 31
42273: PUSH
42274: EMPTY
42275: ST_TO_ADDR
// mc_crates_area := [ ] ;
42276: LD_ADDR_EXP 32
42280: PUSH
42281: EMPTY
42282: ST_TO_ADDR
// mc_vehicles := [ ] ;
42283: LD_ADDR_EXP 33
42287: PUSH
42288: EMPTY
42289: ST_TO_ADDR
// mc_attack := [ ] ;
42290: LD_ADDR_EXP 34
42294: PUSH
42295: EMPTY
42296: ST_TO_ADDR
// mc_produce := [ ] ;
42297: LD_ADDR_EXP 35
42301: PUSH
42302: EMPTY
42303: ST_TO_ADDR
// mc_defender := [ ] ;
42304: LD_ADDR_EXP 36
42308: PUSH
42309: EMPTY
42310: ST_TO_ADDR
// mc_parking := [ ] ;
42311: LD_ADDR_EXP 38
42315: PUSH
42316: EMPTY
42317: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
42318: LD_ADDR_EXP 24
42322: PUSH
42323: EMPTY
42324: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
42325: LD_ADDR_EXP 26
42329: PUSH
42330: EMPTY
42331: ST_TO_ADDR
// mc_scan := [ ] ;
42332: LD_ADDR_EXP 37
42336: PUSH
42337: EMPTY
42338: ST_TO_ADDR
// mc_scan_area := [ ] ;
42339: LD_ADDR_EXP 39
42343: PUSH
42344: EMPTY
42345: ST_TO_ADDR
// mc_tech := [ ] ;
42346: LD_ADDR_EXP 41
42350: PUSH
42351: EMPTY
42352: ST_TO_ADDR
// mc_class := [ ] ;
42353: LD_ADDR_EXP 55
42357: PUSH
42358: EMPTY
42359: ST_TO_ADDR
// mc_class_case_use := [ ] ;
42360: LD_ADDR_EXP 56
42364: PUSH
42365: EMPTY
42366: ST_TO_ADDR
// mc_is_defending := [ ] ;
42367: LD_ADDR_EXP 57
42371: PUSH
42372: EMPTY
42373: ST_TO_ADDR
// end ;
42374: LD_VAR 0 1
42378: RET
// export function MC_Kill ( base ) ; begin
42379: LD_INT 0
42381: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
42382: LD_ADDR_EXP 14
42386: PUSH
42387: LD_EXP 14
42391: PPUSH
42392: LD_VAR 0 1
42396: PPUSH
42397: EMPTY
42398: PPUSH
42399: CALL_OW 1
42403: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
42404: LD_ADDR_EXP 15
42408: PUSH
42409: LD_EXP 15
42413: PPUSH
42414: LD_VAR 0 1
42418: PPUSH
42419: EMPTY
42420: PPUSH
42421: CALL_OW 1
42425: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
42426: LD_ADDR_EXP 16
42430: PUSH
42431: LD_EXP 16
42435: PPUSH
42436: LD_VAR 0 1
42440: PPUSH
42441: EMPTY
42442: PPUSH
42443: CALL_OW 1
42447: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
42448: LD_ADDR_EXP 17
42452: PUSH
42453: LD_EXP 17
42457: PPUSH
42458: LD_VAR 0 1
42462: PPUSH
42463: EMPTY
42464: PPUSH
42465: CALL_OW 1
42469: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
42470: LD_ADDR_EXP 18
42474: PUSH
42475: LD_EXP 18
42479: PPUSH
42480: LD_VAR 0 1
42484: PPUSH
42485: EMPTY
42486: PPUSH
42487: CALL_OW 1
42491: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
42492: LD_ADDR_EXP 19
42496: PUSH
42497: LD_EXP 19
42501: PPUSH
42502: LD_VAR 0 1
42506: PPUSH
42507: EMPTY
42508: PPUSH
42509: CALL_OW 1
42513: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
42514: LD_ADDR_EXP 20
42518: PUSH
42519: LD_EXP 20
42523: PPUSH
42524: LD_VAR 0 1
42528: PPUSH
42529: EMPTY
42530: PPUSH
42531: CALL_OW 1
42535: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
42536: LD_ADDR_EXP 21
42540: PUSH
42541: LD_EXP 21
42545: PPUSH
42546: LD_VAR 0 1
42550: PPUSH
42551: EMPTY
42552: PPUSH
42553: CALL_OW 1
42557: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
42558: LD_ADDR_EXP 22
42562: PUSH
42563: LD_EXP 22
42567: PPUSH
42568: LD_VAR 0 1
42572: PPUSH
42573: EMPTY
42574: PPUSH
42575: CALL_OW 1
42579: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
42580: LD_ADDR_EXP 23
42584: PUSH
42585: LD_EXP 23
42589: PPUSH
42590: LD_VAR 0 1
42594: PPUSH
42595: EMPTY
42596: PPUSH
42597: CALL_OW 1
42601: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
42602: LD_ADDR_EXP 24
42606: PUSH
42607: LD_EXP 24
42611: PPUSH
42612: LD_VAR 0 1
42616: PPUSH
42617: EMPTY
42618: PPUSH
42619: CALL_OW 1
42623: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
42624: LD_ADDR_EXP 25
42628: PUSH
42629: LD_EXP 25
42633: PPUSH
42634: LD_VAR 0 1
42638: PPUSH
42639: LD_INT 0
42641: PPUSH
42642: CALL_OW 1
42646: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
42647: LD_ADDR_EXP 26
42651: PUSH
42652: LD_EXP 26
42656: PPUSH
42657: LD_VAR 0 1
42661: PPUSH
42662: EMPTY
42663: PPUSH
42664: CALL_OW 1
42668: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
42669: LD_ADDR_EXP 27
42673: PUSH
42674: LD_EXP 27
42678: PPUSH
42679: LD_VAR 0 1
42683: PPUSH
42684: EMPTY
42685: PPUSH
42686: CALL_OW 1
42690: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
42691: LD_ADDR_EXP 28
42695: PUSH
42696: LD_EXP 28
42700: PPUSH
42701: LD_VAR 0 1
42705: PPUSH
42706: EMPTY
42707: PPUSH
42708: CALL_OW 1
42712: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
42713: LD_ADDR_EXP 29
42717: PUSH
42718: LD_EXP 29
42722: PPUSH
42723: LD_VAR 0 1
42727: PPUSH
42728: EMPTY
42729: PPUSH
42730: CALL_OW 1
42734: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
42735: LD_ADDR_EXP 30
42739: PUSH
42740: LD_EXP 30
42744: PPUSH
42745: LD_VAR 0 1
42749: PPUSH
42750: EMPTY
42751: PPUSH
42752: CALL_OW 1
42756: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
42757: LD_ADDR_EXP 31
42761: PUSH
42762: LD_EXP 31
42766: PPUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: EMPTY
42773: PPUSH
42774: CALL_OW 1
42778: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
42779: LD_ADDR_EXP 32
42783: PUSH
42784: LD_EXP 32
42788: PPUSH
42789: LD_VAR 0 1
42793: PPUSH
42794: EMPTY
42795: PPUSH
42796: CALL_OW 1
42800: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
42801: LD_ADDR_EXP 33
42805: PUSH
42806: LD_EXP 33
42810: PPUSH
42811: LD_VAR 0 1
42815: PPUSH
42816: EMPTY
42817: PPUSH
42818: CALL_OW 1
42822: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
42823: LD_ADDR_EXP 34
42827: PUSH
42828: LD_EXP 34
42832: PPUSH
42833: LD_VAR 0 1
42837: PPUSH
42838: EMPTY
42839: PPUSH
42840: CALL_OW 1
42844: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
42845: LD_ADDR_EXP 35
42849: PUSH
42850: LD_EXP 35
42854: PPUSH
42855: LD_VAR 0 1
42859: PPUSH
42860: EMPTY
42861: PPUSH
42862: CALL_OW 1
42866: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
42867: LD_ADDR_EXP 36
42871: PUSH
42872: LD_EXP 36
42876: PPUSH
42877: LD_VAR 0 1
42881: PPUSH
42882: EMPTY
42883: PPUSH
42884: CALL_OW 1
42888: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
42889: LD_ADDR_EXP 37
42893: PUSH
42894: LD_EXP 37
42898: PPUSH
42899: LD_VAR 0 1
42903: PPUSH
42904: EMPTY
42905: PPUSH
42906: CALL_OW 1
42910: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
42911: LD_ADDR_EXP 38
42915: PUSH
42916: LD_EXP 38
42920: PPUSH
42921: LD_VAR 0 1
42925: PPUSH
42926: EMPTY
42927: PPUSH
42928: CALL_OW 1
42932: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
42933: LD_ADDR_EXP 39
42937: PUSH
42938: LD_EXP 39
42942: PPUSH
42943: LD_VAR 0 1
42947: PPUSH
42948: EMPTY
42949: PPUSH
42950: CALL_OW 1
42954: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
42955: LD_ADDR_EXP 41
42959: PUSH
42960: LD_EXP 41
42964: PPUSH
42965: LD_VAR 0 1
42969: PPUSH
42970: EMPTY
42971: PPUSH
42972: CALL_OW 1
42976: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
42977: LD_ADDR_EXP 43
42981: PUSH
42982: LD_EXP 43
42986: PPUSH
42987: LD_VAR 0 1
42991: PPUSH
42992: EMPTY
42993: PPUSH
42994: CALL_OW 1
42998: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
42999: LD_ADDR_EXP 44
43003: PUSH
43004: LD_EXP 44
43008: PPUSH
43009: LD_VAR 0 1
43013: PPUSH
43014: EMPTY
43015: PPUSH
43016: CALL_OW 1
43020: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43021: LD_ADDR_EXP 45
43025: PUSH
43026: LD_EXP 45
43030: PPUSH
43031: LD_VAR 0 1
43035: PPUSH
43036: EMPTY
43037: PPUSH
43038: CALL_OW 1
43042: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
43043: LD_ADDR_EXP 46
43047: PUSH
43048: LD_EXP 46
43052: PPUSH
43053: LD_VAR 0 1
43057: PPUSH
43058: EMPTY
43059: PPUSH
43060: CALL_OW 1
43064: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
43065: LD_ADDR_EXP 47
43069: PUSH
43070: LD_EXP 47
43074: PPUSH
43075: LD_VAR 0 1
43079: PPUSH
43080: EMPTY
43081: PPUSH
43082: CALL_OW 1
43086: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
43087: LD_ADDR_EXP 48
43091: PUSH
43092: LD_EXP 48
43096: PPUSH
43097: LD_VAR 0 1
43101: PPUSH
43102: EMPTY
43103: PPUSH
43104: CALL_OW 1
43108: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
43109: LD_ADDR_EXP 49
43113: PUSH
43114: LD_EXP 49
43118: PPUSH
43119: LD_VAR 0 1
43123: PPUSH
43124: EMPTY
43125: PPUSH
43126: CALL_OW 1
43130: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
43131: LD_ADDR_EXP 50
43135: PUSH
43136: LD_EXP 50
43140: PPUSH
43141: LD_VAR 0 1
43145: PPUSH
43146: EMPTY
43147: PPUSH
43148: CALL_OW 1
43152: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
43153: LD_ADDR_EXP 51
43157: PUSH
43158: LD_EXP 51
43162: PPUSH
43163: LD_VAR 0 1
43167: PPUSH
43168: EMPTY
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
43175: LD_ADDR_EXP 52
43179: PUSH
43180: LD_EXP 52
43184: PPUSH
43185: LD_VAR 0 1
43189: PPUSH
43190: EMPTY
43191: PPUSH
43192: CALL_OW 1
43196: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
43197: LD_ADDR_EXP 53
43201: PUSH
43202: LD_EXP 53
43206: PPUSH
43207: LD_VAR 0 1
43211: PPUSH
43212: EMPTY
43213: PPUSH
43214: CALL_OW 1
43218: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
43219: LD_ADDR_EXP 54
43223: PUSH
43224: LD_EXP 54
43228: PPUSH
43229: LD_VAR 0 1
43233: PPUSH
43234: EMPTY
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
43241: LD_ADDR_EXP 55
43245: PUSH
43246: LD_EXP 55
43250: PPUSH
43251: LD_VAR 0 1
43255: PPUSH
43256: EMPTY
43257: PPUSH
43258: CALL_OW 1
43262: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
43263: LD_ADDR_EXP 56
43267: PUSH
43268: LD_EXP 56
43272: PPUSH
43273: LD_VAR 0 1
43277: PPUSH
43278: LD_INT 0
43280: PPUSH
43281: CALL_OW 1
43285: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
43286: LD_ADDR_EXP 57
43290: PUSH
43291: LD_EXP 57
43295: PPUSH
43296: LD_VAR 0 1
43300: PPUSH
43301: LD_INT 0
43303: PPUSH
43304: CALL_OW 1
43308: ST_TO_ADDR
// end ;
43309: LD_VAR 0 2
43313: RET
// export function MC_Add ( side , units ) ; var base ; begin
43314: LD_INT 0
43316: PPUSH
43317: PPUSH
// base := mc_bases + 1 ;
43318: LD_ADDR_VAR 0 4
43322: PUSH
43323: LD_EXP 14
43327: PUSH
43328: LD_INT 1
43330: PLUS
43331: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
43332: LD_ADDR_EXP 40
43336: PUSH
43337: LD_EXP 40
43341: PPUSH
43342: LD_VAR 0 4
43346: PPUSH
43347: LD_VAR 0 1
43351: PPUSH
43352: CALL_OW 1
43356: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
43357: LD_ADDR_EXP 14
43361: PUSH
43362: LD_EXP 14
43366: PPUSH
43367: LD_VAR 0 4
43371: PPUSH
43372: LD_VAR 0 2
43376: PPUSH
43377: CALL_OW 1
43381: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
43382: LD_ADDR_EXP 15
43386: PUSH
43387: LD_EXP 15
43391: PPUSH
43392: LD_VAR 0 4
43396: PPUSH
43397: EMPTY
43398: PPUSH
43399: CALL_OW 1
43403: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
43404: LD_ADDR_EXP 16
43408: PUSH
43409: LD_EXP 16
43413: PPUSH
43414: LD_VAR 0 4
43418: PPUSH
43419: EMPTY
43420: PPUSH
43421: CALL_OW 1
43425: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
43426: LD_ADDR_EXP 17
43430: PUSH
43431: LD_EXP 17
43435: PPUSH
43436: LD_VAR 0 4
43440: PPUSH
43441: EMPTY
43442: PPUSH
43443: CALL_OW 1
43447: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
43448: LD_ADDR_EXP 18
43452: PUSH
43453: LD_EXP 18
43457: PPUSH
43458: LD_VAR 0 4
43462: PPUSH
43463: EMPTY
43464: PPUSH
43465: CALL_OW 1
43469: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
43470: LD_ADDR_EXP 19
43474: PUSH
43475: LD_EXP 19
43479: PPUSH
43480: LD_VAR 0 4
43484: PPUSH
43485: EMPTY
43486: PPUSH
43487: CALL_OW 1
43491: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
43492: LD_ADDR_EXP 20
43496: PUSH
43497: LD_EXP 20
43501: PPUSH
43502: LD_VAR 0 4
43506: PPUSH
43507: EMPTY
43508: PPUSH
43509: CALL_OW 1
43513: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
43514: LD_ADDR_EXP 21
43518: PUSH
43519: LD_EXP 21
43523: PPUSH
43524: LD_VAR 0 4
43528: PPUSH
43529: EMPTY
43530: PPUSH
43531: CALL_OW 1
43535: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
43536: LD_ADDR_EXP 22
43540: PUSH
43541: LD_EXP 22
43545: PPUSH
43546: LD_VAR 0 4
43550: PPUSH
43551: EMPTY
43552: PPUSH
43553: CALL_OW 1
43557: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
43558: LD_ADDR_EXP 23
43562: PUSH
43563: LD_EXP 23
43567: PPUSH
43568: LD_VAR 0 4
43572: PPUSH
43573: EMPTY
43574: PPUSH
43575: CALL_OW 1
43579: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
43580: LD_ADDR_EXP 24
43584: PUSH
43585: LD_EXP 24
43589: PPUSH
43590: LD_VAR 0 4
43594: PPUSH
43595: EMPTY
43596: PPUSH
43597: CALL_OW 1
43601: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
43602: LD_ADDR_EXP 25
43606: PUSH
43607: LD_EXP 25
43611: PPUSH
43612: LD_VAR 0 4
43616: PPUSH
43617: LD_INT 0
43619: PPUSH
43620: CALL_OW 1
43624: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
43625: LD_ADDR_EXP 26
43629: PUSH
43630: LD_EXP 26
43634: PPUSH
43635: LD_VAR 0 4
43639: PPUSH
43640: EMPTY
43641: PPUSH
43642: CALL_OW 1
43646: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
43647: LD_ADDR_EXP 27
43651: PUSH
43652: LD_EXP 27
43656: PPUSH
43657: LD_VAR 0 4
43661: PPUSH
43662: EMPTY
43663: PPUSH
43664: CALL_OW 1
43668: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
43669: LD_ADDR_EXP 28
43673: PUSH
43674: LD_EXP 28
43678: PPUSH
43679: LD_VAR 0 4
43683: PPUSH
43684: EMPTY
43685: PPUSH
43686: CALL_OW 1
43690: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
43691: LD_ADDR_EXP 29
43695: PUSH
43696: LD_EXP 29
43700: PPUSH
43701: LD_VAR 0 4
43705: PPUSH
43706: EMPTY
43707: PPUSH
43708: CALL_OW 1
43712: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
43713: LD_ADDR_EXP 30
43717: PUSH
43718: LD_EXP 30
43722: PPUSH
43723: LD_VAR 0 4
43727: PPUSH
43728: EMPTY
43729: PPUSH
43730: CALL_OW 1
43734: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
43735: LD_ADDR_EXP 31
43739: PUSH
43740: LD_EXP 31
43744: PPUSH
43745: LD_VAR 0 4
43749: PPUSH
43750: EMPTY
43751: PPUSH
43752: CALL_OW 1
43756: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
43757: LD_ADDR_EXP 32
43761: PUSH
43762: LD_EXP 32
43766: PPUSH
43767: LD_VAR 0 4
43771: PPUSH
43772: EMPTY
43773: PPUSH
43774: CALL_OW 1
43778: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
43779: LD_ADDR_EXP 33
43783: PUSH
43784: LD_EXP 33
43788: PPUSH
43789: LD_VAR 0 4
43793: PPUSH
43794: EMPTY
43795: PPUSH
43796: CALL_OW 1
43800: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
43801: LD_ADDR_EXP 34
43805: PUSH
43806: LD_EXP 34
43810: PPUSH
43811: LD_VAR 0 4
43815: PPUSH
43816: EMPTY
43817: PPUSH
43818: CALL_OW 1
43822: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
43823: LD_ADDR_EXP 35
43827: PUSH
43828: LD_EXP 35
43832: PPUSH
43833: LD_VAR 0 4
43837: PPUSH
43838: EMPTY
43839: PPUSH
43840: CALL_OW 1
43844: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
43845: LD_ADDR_EXP 36
43849: PUSH
43850: LD_EXP 36
43854: PPUSH
43855: LD_VAR 0 4
43859: PPUSH
43860: EMPTY
43861: PPUSH
43862: CALL_OW 1
43866: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
43867: LD_ADDR_EXP 37
43871: PUSH
43872: LD_EXP 37
43876: PPUSH
43877: LD_VAR 0 4
43881: PPUSH
43882: EMPTY
43883: PPUSH
43884: CALL_OW 1
43888: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
43889: LD_ADDR_EXP 38
43893: PUSH
43894: LD_EXP 38
43898: PPUSH
43899: LD_VAR 0 4
43903: PPUSH
43904: EMPTY
43905: PPUSH
43906: CALL_OW 1
43910: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
43911: LD_ADDR_EXP 39
43915: PUSH
43916: LD_EXP 39
43920: PPUSH
43921: LD_VAR 0 4
43925: PPUSH
43926: EMPTY
43927: PPUSH
43928: CALL_OW 1
43932: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
43933: LD_ADDR_EXP 41
43937: PUSH
43938: LD_EXP 41
43942: PPUSH
43943: LD_VAR 0 4
43947: PPUSH
43948: EMPTY
43949: PPUSH
43950: CALL_OW 1
43954: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
43955: LD_ADDR_EXP 43
43959: PUSH
43960: LD_EXP 43
43964: PPUSH
43965: LD_VAR 0 4
43969: PPUSH
43970: EMPTY
43971: PPUSH
43972: CALL_OW 1
43976: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
43977: LD_ADDR_EXP 44
43981: PUSH
43982: LD_EXP 44
43986: PPUSH
43987: LD_VAR 0 4
43991: PPUSH
43992: EMPTY
43993: PPUSH
43994: CALL_OW 1
43998: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
43999: LD_ADDR_EXP 45
44003: PUSH
44004: LD_EXP 45
44008: PPUSH
44009: LD_VAR 0 4
44013: PPUSH
44014: EMPTY
44015: PPUSH
44016: CALL_OW 1
44020: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
44021: LD_ADDR_EXP 46
44025: PUSH
44026: LD_EXP 46
44030: PPUSH
44031: LD_VAR 0 4
44035: PPUSH
44036: EMPTY
44037: PPUSH
44038: CALL_OW 1
44042: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
44043: LD_ADDR_EXP 47
44047: PUSH
44048: LD_EXP 47
44052: PPUSH
44053: LD_VAR 0 4
44057: PPUSH
44058: EMPTY
44059: PPUSH
44060: CALL_OW 1
44064: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
44065: LD_ADDR_EXP 48
44069: PUSH
44070: LD_EXP 48
44074: PPUSH
44075: LD_VAR 0 4
44079: PPUSH
44080: EMPTY
44081: PPUSH
44082: CALL_OW 1
44086: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
44087: LD_ADDR_EXP 49
44091: PUSH
44092: LD_EXP 49
44096: PPUSH
44097: LD_VAR 0 4
44101: PPUSH
44102: EMPTY
44103: PPUSH
44104: CALL_OW 1
44108: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
44109: LD_ADDR_EXP 50
44113: PUSH
44114: LD_EXP 50
44118: PPUSH
44119: LD_VAR 0 4
44123: PPUSH
44124: EMPTY
44125: PPUSH
44126: CALL_OW 1
44130: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
44131: LD_ADDR_EXP 51
44135: PUSH
44136: LD_EXP 51
44140: PPUSH
44141: LD_VAR 0 4
44145: PPUSH
44146: EMPTY
44147: PPUSH
44148: CALL_OW 1
44152: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
44153: LD_ADDR_EXP 52
44157: PUSH
44158: LD_EXP 52
44162: PPUSH
44163: LD_VAR 0 4
44167: PPUSH
44168: EMPTY
44169: PPUSH
44170: CALL_OW 1
44174: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
44175: LD_ADDR_EXP 53
44179: PUSH
44180: LD_EXP 53
44184: PPUSH
44185: LD_VAR 0 4
44189: PPUSH
44190: EMPTY
44191: PPUSH
44192: CALL_OW 1
44196: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
44197: LD_ADDR_EXP 54
44201: PUSH
44202: LD_EXP 54
44206: PPUSH
44207: LD_VAR 0 4
44211: PPUSH
44212: EMPTY
44213: PPUSH
44214: CALL_OW 1
44218: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
44219: LD_ADDR_EXP 55
44223: PUSH
44224: LD_EXP 55
44228: PPUSH
44229: LD_VAR 0 4
44233: PPUSH
44234: EMPTY
44235: PPUSH
44236: CALL_OW 1
44240: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
44241: LD_ADDR_EXP 56
44245: PUSH
44246: LD_EXP 56
44250: PPUSH
44251: LD_VAR 0 4
44255: PPUSH
44256: LD_INT 0
44258: PPUSH
44259: CALL_OW 1
44263: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
44264: LD_ADDR_EXP 57
44268: PUSH
44269: LD_EXP 57
44273: PPUSH
44274: LD_VAR 0 4
44278: PPUSH
44279: LD_INT 0
44281: PPUSH
44282: CALL_OW 1
44286: ST_TO_ADDR
// result := base ;
44287: LD_ADDR_VAR 0 3
44291: PUSH
44292: LD_VAR 0 4
44296: ST_TO_ADDR
// end ;
44297: LD_VAR 0 3
44301: RET
// export function MC_Start ( ) ; var i ; begin
44302: LD_INT 0
44304: PPUSH
44305: PPUSH
// for i = 1 to mc_bases do
44306: LD_ADDR_VAR 0 2
44310: PUSH
44311: DOUBLE
44312: LD_INT 1
44314: DEC
44315: ST_TO_ADDR
44316: LD_EXP 14
44320: PUSH
44321: FOR_TO
44322: IFFALSE 45399
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
44324: LD_ADDR_EXP 14
44328: PUSH
44329: LD_EXP 14
44333: PPUSH
44334: LD_VAR 0 2
44338: PPUSH
44339: LD_EXP 14
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: PUSH
44350: LD_INT 0
44352: DIFF
44353: PPUSH
44354: CALL_OW 1
44358: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
44359: LD_ADDR_EXP 15
44363: PUSH
44364: LD_EXP 15
44368: PPUSH
44369: LD_VAR 0 2
44373: PPUSH
44374: EMPTY
44375: PPUSH
44376: CALL_OW 1
44380: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44381: LD_ADDR_EXP 16
44385: PUSH
44386: LD_EXP 16
44390: PPUSH
44391: LD_VAR 0 2
44395: PPUSH
44396: EMPTY
44397: PPUSH
44398: CALL_OW 1
44402: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
44403: LD_ADDR_EXP 17
44407: PUSH
44408: LD_EXP 17
44412: PPUSH
44413: LD_VAR 0 2
44417: PPUSH
44418: EMPTY
44419: PPUSH
44420: CALL_OW 1
44424: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
44425: LD_ADDR_EXP 18
44429: PUSH
44430: LD_EXP 18
44434: PPUSH
44435: LD_VAR 0 2
44439: PPUSH
44440: EMPTY
44441: PUSH
44442: EMPTY
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: PPUSH
44448: CALL_OW 1
44452: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
44453: LD_ADDR_EXP 19
44457: PUSH
44458: LD_EXP 19
44462: PPUSH
44463: LD_VAR 0 2
44467: PPUSH
44468: EMPTY
44469: PPUSH
44470: CALL_OW 1
44474: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
44475: LD_ADDR_EXP 46
44479: PUSH
44480: LD_EXP 46
44484: PPUSH
44485: LD_VAR 0 2
44489: PPUSH
44490: EMPTY
44491: PPUSH
44492: CALL_OW 1
44496: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
44497: LD_ADDR_EXP 20
44501: PUSH
44502: LD_EXP 20
44506: PPUSH
44507: LD_VAR 0 2
44511: PPUSH
44512: EMPTY
44513: PPUSH
44514: CALL_OW 1
44518: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
44519: LD_ADDR_EXP 21
44523: PUSH
44524: LD_EXP 21
44528: PPUSH
44529: LD_VAR 0 2
44533: PPUSH
44534: EMPTY
44535: PPUSH
44536: CALL_OW 1
44540: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
44541: LD_ADDR_EXP 22
44545: PUSH
44546: LD_EXP 22
44550: PPUSH
44551: LD_VAR 0 2
44555: PPUSH
44556: LD_EXP 14
44560: PUSH
44561: LD_VAR 0 2
44565: ARRAY
44566: PPUSH
44567: LD_INT 2
44569: PUSH
44570: LD_INT 30
44572: PUSH
44573: LD_INT 32
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 30
44582: PUSH
44583: LD_INT 33
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: LIST
44594: PPUSH
44595: CALL_OW 72
44599: PPUSH
44600: CALL_OW 1
44604: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
44605: LD_ADDR_EXP 23
44609: PUSH
44610: LD_EXP 23
44614: PPUSH
44615: LD_VAR 0 2
44619: PPUSH
44620: LD_EXP 14
44624: PUSH
44625: LD_VAR 0 2
44629: ARRAY
44630: PPUSH
44631: LD_INT 2
44633: PUSH
44634: LD_INT 30
44636: PUSH
44637: LD_INT 32
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 30
44646: PUSH
44647: LD_INT 31
44649: PUSH
44650: EMPTY
44651: LIST
44652: LIST
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 58
44661: PUSH
44662: EMPTY
44663: LIST
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PPUSH
44669: CALL_OW 72
44673: PPUSH
44674: CALL_OW 1
44678: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
44679: LD_ADDR_EXP 24
44683: PUSH
44684: LD_EXP 24
44688: PPUSH
44689: LD_VAR 0 2
44693: PPUSH
44694: EMPTY
44695: PPUSH
44696: CALL_OW 1
44700: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
44701: LD_ADDR_EXP 28
44705: PUSH
44706: LD_EXP 28
44710: PPUSH
44711: LD_VAR 0 2
44715: PPUSH
44716: EMPTY
44717: PPUSH
44718: CALL_OW 1
44722: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
44723: LD_ADDR_EXP 27
44727: PUSH
44728: LD_EXP 27
44732: PPUSH
44733: LD_VAR 0 2
44737: PPUSH
44738: EMPTY
44739: PPUSH
44740: CALL_OW 1
44744: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
44745: LD_ADDR_EXP 29
44749: PUSH
44750: LD_EXP 29
44754: PPUSH
44755: LD_VAR 0 2
44759: PPUSH
44760: EMPTY
44761: PPUSH
44762: CALL_OW 1
44766: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
44767: LD_ADDR_EXP 30
44771: PUSH
44772: LD_EXP 30
44776: PPUSH
44777: LD_VAR 0 2
44781: PPUSH
44782: EMPTY
44783: PPUSH
44784: CALL_OW 1
44788: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
44789: LD_ADDR_EXP 31
44793: PUSH
44794: LD_EXP 31
44798: PPUSH
44799: LD_VAR 0 2
44803: PPUSH
44804: EMPTY
44805: PPUSH
44806: CALL_OW 1
44810: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
44811: LD_ADDR_EXP 32
44815: PUSH
44816: LD_EXP 32
44820: PPUSH
44821: LD_VAR 0 2
44825: PPUSH
44826: EMPTY
44827: PPUSH
44828: CALL_OW 1
44832: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
44833: LD_ADDR_EXP 33
44837: PUSH
44838: LD_EXP 33
44842: PPUSH
44843: LD_VAR 0 2
44847: PPUSH
44848: EMPTY
44849: PPUSH
44850: CALL_OW 1
44854: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
44855: LD_ADDR_EXP 34
44859: PUSH
44860: LD_EXP 34
44864: PPUSH
44865: LD_VAR 0 2
44869: PPUSH
44870: EMPTY
44871: PPUSH
44872: CALL_OW 1
44876: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
44877: LD_ADDR_EXP 35
44881: PUSH
44882: LD_EXP 35
44886: PPUSH
44887: LD_VAR 0 2
44891: PPUSH
44892: EMPTY
44893: PPUSH
44894: CALL_OW 1
44898: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
44899: LD_ADDR_EXP 36
44903: PUSH
44904: LD_EXP 36
44908: PPUSH
44909: LD_VAR 0 2
44913: PPUSH
44914: EMPTY
44915: PPUSH
44916: CALL_OW 1
44920: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
44921: LD_ADDR_EXP 25
44925: PUSH
44926: LD_EXP 25
44930: PPUSH
44931: LD_VAR 0 2
44935: PPUSH
44936: LD_INT 0
44938: PPUSH
44939: CALL_OW 1
44943: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
44944: LD_ADDR_EXP 38
44948: PUSH
44949: LD_EXP 38
44953: PPUSH
44954: LD_VAR 0 2
44958: PPUSH
44959: LD_INT 0
44961: PPUSH
44962: CALL_OW 1
44966: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
44967: LD_ADDR_EXP 26
44971: PUSH
44972: LD_EXP 26
44976: PPUSH
44977: LD_VAR 0 2
44981: PPUSH
44982: EMPTY
44983: PPUSH
44984: CALL_OW 1
44988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
44989: LD_ADDR_EXP 37
44993: PUSH
44994: LD_EXP 37
44998: PPUSH
44999: LD_VAR 0 2
45003: PPUSH
45004: LD_INT 0
45006: PPUSH
45007: CALL_OW 1
45011: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
45012: LD_ADDR_EXP 39
45016: PUSH
45017: LD_EXP 39
45021: PPUSH
45022: LD_VAR 0 2
45026: PPUSH
45027: EMPTY
45028: PPUSH
45029: CALL_OW 1
45033: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
45034: LD_ADDR_EXP 42
45038: PUSH
45039: LD_EXP 42
45043: PPUSH
45044: LD_VAR 0 2
45048: PPUSH
45049: LD_INT 0
45051: PPUSH
45052: CALL_OW 1
45056: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
45057: LD_ADDR_EXP 43
45061: PUSH
45062: LD_EXP 43
45066: PPUSH
45067: LD_VAR 0 2
45071: PPUSH
45072: EMPTY
45073: PPUSH
45074: CALL_OW 1
45078: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45079: LD_ADDR_EXP 44
45083: PUSH
45084: LD_EXP 44
45088: PPUSH
45089: LD_VAR 0 2
45093: PPUSH
45094: EMPTY
45095: PPUSH
45096: CALL_OW 1
45100: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45101: LD_ADDR_EXP 45
45105: PUSH
45106: LD_EXP 45
45110: PPUSH
45111: LD_VAR 0 2
45115: PPUSH
45116: EMPTY
45117: PPUSH
45118: CALL_OW 1
45122: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
45123: LD_ADDR_EXP 47
45127: PUSH
45128: LD_EXP 47
45132: PPUSH
45133: LD_VAR 0 2
45137: PPUSH
45138: LD_EXP 14
45142: PUSH
45143: LD_VAR 0 2
45147: ARRAY
45148: PPUSH
45149: LD_INT 2
45151: PUSH
45152: LD_INT 30
45154: PUSH
45155: LD_INT 6
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 30
45164: PUSH
45165: LD_INT 7
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: PUSH
45172: LD_INT 30
45174: PUSH
45175: LD_INT 8
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: EMPTY
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: PPUSH
45188: CALL_OW 72
45192: PPUSH
45193: CALL_OW 1
45197: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
45198: LD_ADDR_EXP 48
45202: PUSH
45203: LD_EXP 48
45207: PPUSH
45208: LD_VAR 0 2
45212: PPUSH
45213: EMPTY
45214: PPUSH
45215: CALL_OW 1
45219: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
45220: LD_ADDR_EXP 49
45224: PUSH
45225: LD_EXP 49
45229: PPUSH
45230: LD_VAR 0 2
45234: PPUSH
45235: EMPTY
45236: PPUSH
45237: CALL_OW 1
45241: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
45242: LD_ADDR_EXP 50
45246: PUSH
45247: LD_EXP 50
45251: PPUSH
45252: LD_VAR 0 2
45256: PPUSH
45257: EMPTY
45258: PPUSH
45259: CALL_OW 1
45263: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
45264: LD_ADDR_EXP 51
45268: PUSH
45269: LD_EXP 51
45273: PPUSH
45274: LD_VAR 0 2
45278: PPUSH
45279: EMPTY
45280: PPUSH
45281: CALL_OW 1
45285: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
45286: LD_ADDR_EXP 52
45290: PUSH
45291: LD_EXP 52
45295: PPUSH
45296: LD_VAR 0 2
45300: PPUSH
45301: EMPTY
45302: PPUSH
45303: CALL_OW 1
45307: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
45308: LD_ADDR_EXP 53
45312: PUSH
45313: LD_EXP 53
45317: PPUSH
45318: LD_VAR 0 2
45322: PPUSH
45323: EMPTY
45324: PPUSH
45325: CALL_OW 1
45329: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
45330: LD_ADDR_EXP 54
45334: PUSH
45335: LD_EXP 54
45339: PPUSH
45340: LD_VAR 0 2
45344: PPUSH
45345: EMPTY
45346: PPUSH
45347: CALL_OW 1
45351: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
45352: LD_ADDR_EXP 55
45356: PUSH
45357: LD_EXP 55
45361: PPUSH
45362: LD_VAR 0 2
45366: PPUSH
45367: EMPTY
45368: PPUSH
45369: CALL_OW 1
45373: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
45374: LD_ADDR_EXP 56
45378: PUSH
45379: LD_EXP 56
45383: PPUSH
45384: LD_VAR 0 2
45388: PPUSH
45389: LD_INT 0
45391: PPUSH
45392: CALL_OW 1
45396: ST_TO_ADDR
// end ;
45397: GO 44321
45399: POP
45400: POP
// MC_InitSides ( ) ;
45401: CALL 45687 0 0
// MC_InitResearch ( ) ;
45405: CALL 45426 0 0
// CustomInitMacro ( ) ;
45409: CALL 211 0 0
// skirmish := true ;
45413: LD_ADDR_EXP 12
45417: PUSH
45418: LD_INT 1
45420: ST_TO_ADDR
// end ;
45421: LD_VAR 0 1
45425: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
45426: LD_INT 0
45428: PPUSH
45429: PPUSH
45430: PPUSH
45431: PPUSH
45432: PPUSH
45433: PPUSH
// if not mc_bases then
45434: LD_EXP 14
45438: NOT
45439: IFFALSE 45443
// exit ;
45441: GO 45682
// for i = 1 to 8 do
45443: LD_ADDR_VAR 0 2
45447: PUSH
45448: DOUBLE
45449: LD_INT 1
45451: DEC
45452: ST_TO_ADDR
45453: LD_INT 8
45455: PUSH
45456: FOR_TO
45457: IFFALSE 45483
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
45459: LD_ADDR_EXP 41
45463: PUSH
45464: LD_EXP 41
45468: PPUSH
45469: LD_VAR 0 2
45473: PPUSH
45474: EMPTY
45475: PPUSH
45476: CALL_OW 1
45480: ST_TO_ADDR
45481: GO 45456
45483: POP
45484: POP
// tmp := [ ] ;
45485: LD_ADDR_VAR 0 5
45489: PUSH
45490: EMPTY
45491: ST_TO_ADDR
// for i = 1 to mc_sides do
45492: LD_ADDR_VAR 0 2
45496: PUSH
45497: DOUBLE
45498: LD_INT 1
45500: DEC
45501: ST_TO_ADDR
45502: LD_EXP 40
45506: PUSH
45507: FOR_TO
45508: IFFALSE 45566
// if not mc_sides [ i ] in tmp then
45510: LD_EXP 40
45514: PUSH
45515: LD_VAR 0 2
45519: ARRAY
45520: PUSH
45521: LD_VAR 0 5
45525: IN
45526: NOT
45527: IFFALSE 45564
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
45529: LD_ADDR_VAR 0 5
45533: PUSH
45534: LD_VAR 0 5
45538: PPUSH
45539: LD_VAR 0 5
45543: PUSH
45544: LD_INT 1
45546: PLUS
45547: PPUSH
45548: LD_EXP 40
45552: PUSH
45553: LD_VAR 0 2
45557: ARRAY
45558: PPUSH
45559: CALL_OW 2
45563: ST_TO_ADDR
45564: GO 45507
45566: POP
45567: POP
// if not tmp then
45568: LD_VAR 0 5
45572: NOT
45573: IFFALSE 45577
// exit ;
45575: GO 45682
// for j in tmp do
45577: LD_ADDR_VAR 0 3
45581: PUSH
45582: LD_VAR 0 5
45586: PUSH
45587: FOR_IN
45588: IFFALSE 45680
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
45590: LD_ADDR_VAR 0 6
45594: PUSH
45595: LD_INT 22
45597: PUSH
45598: LD_VAR 0 3
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PPUSH
45607: CALL_OW 69
45611: ST_TO_ADDR
// if not un then
45612: LD_VAR 0 6
45616: NOT
45617: IFFALSE 45621
// continue ;
45619: GO 45587
// nation := GetNation ( un [ 1 ] ) ;
45621: LD_ADDR_VAR 0 4
45625: PUSH
45626: LD_VAR 0 6
45630: PUSH
45631: LD_INT 1
45633: ARRAY
45634: PPUSH
45635: CALL_OW 248
45639: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
45640: LD_ADDR_EXP 41
45644: PUSH
45645: LD_EXP 41
45649: PPUSH
45650: LD_VAR 0 3
45654: PPUSH
45655: LD_VAR 0 3
45659: PPUSH
45660: LD_VAR 0 4
45664: PPUSH
45665: LD_INT 1
45667: PPUSH
45668: CALL 4544 0 3
45672: PPUSH
45673: CALL_OW 1
45677: ST_TO_ADDR
// end ;
45678: GO 45587
45680: POP
45681: POP
// end ;
45682: LD_VAR 0 1
45686: RET
// export function MC_InitSides ( ) ; var i ; begin
45687: LD_INT 0
45689: PPUSH
45690: PPUSH
// if not mc_bases then
45691: LD_EXP 14
45695: NOT
45696: IFFALSE 45700
// exit ;
45698: GO 45774
// for i = 1 to mc_bases do
45700: LD_ADDR_VAR 0 2
45704: PUSH
45705: DOUBLE
45706: LD_INT 1
45708: DEC
45709: ST_TO_ADDR
45710: LD_EXP 14
45714: PUSH
45715: FOR_TO
45716: IFFALSE 45772
// if mc_bases [ i ] then
45718: LD_EXP 14
45722: PUSH
45723: LD_VAR 0 2
45727: ARRAY
45728: IFFALSE 45770
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
45730: LD_ADDR_EXP 40
45734: PUSH
45735: LD_EXP 40
45739: PPUSH
45740: LD_VAR 0 2
45744: PPUSH
45745: LD_EXP 14
45749: PUSH
45750: LD_VAR 0 2
45754: ARRAY
45755: PUSH
45756: LD_INT 1
45758: ARRAY
45759: PPUSH
45760: CALL_OW 255
45764: PPUSH
45765: CALL_OW 1
45769: ST_TO_ADDR
45770: GO 45715
45772: POP
45773: POP
// end ;
45774: LD_VAR 0 1
45778: RET
// every 0 0$03 trigger skirmish do
45779: LD_EXP 12
45783: IFFALSE 45937
45785: GO 45787
45787: DISABLE
// begin enable ;
45788: ENABLE
// MC_CheckBuildings ( ) ;
45789: CALL 50435 0 0
// MC_CheckPeopleLife ( ) ;
45793: CALL 50560 0 0
// RaiseSailEvent ( 100 ) ;
45797: LD_INT 100
45799: PPUSH
45800: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
45804: LD_INT 103
45806: PPUSH
45807: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
45811: LD_INT 104
45813: PPUSH
45814: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
45818: LD_INT 105
45820: PPUSH
45821: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
45825: LD_INT 106
45827: PPUSH
45828: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
45832: LD_INT 107
45834: PPUSH
45835: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
45839: LD_INT 108
45841: PPUSH
45842: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
45846: LD_INT 109
45848: PPUSH
45849: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
45853: LD_INT 110
45855: PPUSH
45856: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
45860: LD_INT 111
45862: PPUSH
45863: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
45867: LD_INT 112
45869: PPUSH
45870: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
45874: LD_INT 113
45876: PPUSH
45877: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
45881: LD_INT 120
45883: PPUSH
45884: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
45888: LD_INT 121
45890: PPUSH
45891: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
45895: LD_INT 122
45897: PPUSH
45898: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
45902: LD_INT 123
45904: PPUSH
45905: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
45909: LD_INT 124
45911: PPUSH
45912: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
45916: LD_INT 125
45918: PPUSH
45919: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
45923: LD_INT 126
45925: PPUSH
45926: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
45930: LD_INT 200
45932: PPUSH
45933: CALL_OW 427
// end ;
45937: END
// on SailEvent ( event ) do begin if event < 100 then
45938: LD_VAR 0 1
45942: PUSH
45943: LD_INT 100
45945: LESS
45946: IFFALSE 45957
// CustomEvent ( event ) ;
45948: LD_VAR 0 1
45952: PPUSH
45953: CALL 4443 0 1
// if event = 100 then
45957: LD_VAR 0 1
45961: PUSH
45962: LD_INT 100
45964: EQUAL
45965: IFFALSE 45971
// MC_ClassManager ( ) ;
45967: CALL 46363 0 0
// if event = 101 then
45971: LD_VAR 0 1
45975: PUSH
45976: LD_INT 101
45978: EQUAL
45979: IFFALSE 45985
// MC_RepairBuildings ( ) ;
45981: CALL 51145 0 0
// if event = 102 then
45985: LD_VAR 0 1
45989: PUSH
45990: LD_INT 102
45992: EQUAL
45993: IFFALSE 45999
// MC_Heal ( ) ;
45995: CALL 52030 0 0
// if event = 103 then
45999: LD_VAR 0 1
46003: PUSH
46004: LD_INT 103
46006: EQUAL
46007: IFFALSE 46013
// MC_Build ( ) ;
46009: CALL 52452 0 0
// if event = 104 then
46013: LD_VAR 0 1
46017: PUSH
46018: LD_INT 104
46020: EQUAL
46021: IFFALSE 46027
// MC_TurretWeapon ( ) ;
46023: CALL 54093 0 0
// if event = 105 then
46027: LD_VAR 0 1
46031: PUSH
46032: LD_INT 105
46034: EQUAL
46035: IFFALSE 46041
// MC_BuildUpgrade ( ) ;
46037: CALL 53644 0 0
// if event = 106 then
46041: LD_VAR 0 1
46045: PUSH
46046: LD_INT 106
46048: EQUAL
46049: IFFALSE 46055
// MC_PlantMines ( ) ;
46051: CALL 54523 0 0
// if event = 107 then
46055: LD_VAR 0 1
46059: PUSH
46060: LD_INT 107
46062: EQUAL
46063: IFFALSE 46069
// MC_CollectCrates ( ) ;
46065: CALL 55314 0 0
// if event = 108 then
46069: LD_VAR 0 1
46073: PUSH
46074: LD_INT 108
46076: EQUAL
46077: IFFALSE 46083
// MC_LinkRemoteControl ( ) ;
46079: CALL 57090 0 0
// if event = 109 then
46083: LD_VAR 0 1
46087: PUSH
46088: LD_INT 109
46090: EQUAL
46091: IFFALSE 46097
// MC_ProduceVehicle ( ) ;
46093: CALL 57271 0 0
// if event = 110 then
46097: LD_VAR 0 1
46101: PUSH
46102: LD_INT 110
46104: EQUAL
46105: IFFALSE 46111
// MC_SendAttack ( ) ;
46107: CALL 57737 0 0
// if event = 111 then
46111: LD_VAR 0 1
46115: PUSH
46116: LD_INT 111
46118: EQUAL
46119: IFFALSE 46125
// MC_Defend ( ) ;
46121: CALL 57845 0 0
// if event = 112 then
46125: LD_VAR 0 1
46129: PUSH
46130: LD_INT 112
46132: EQUAL
46133: IFFALSE 46139
// MC_Research ( ) ;
46135: CALL 58567 0 0
// if event = 113 then
46139: LD_VAR 0 1
46143: PUSH
46144: LD_INT 113
46146: EQUAL
46147: IFFALSE 46153
// MC_MinesTrigger ( ) ;
46149: CALL 59681 0 0
// if event = 120 then
46153: LD_VAR 0 1
46157: PUSH
46158: LD_INT 120
46160: EQUAL
46161: IFFALSE 46167
// MC_RepairVehicle ( ) ;
46163: CALL 59780 0 0
// if event = 121 then
46167: LD_VAR 0 1
46171: PUSH
46172: LD_INT 121
46174: EQUAL
46175: IFFALSE 46181
// MC_TameApe ( ) ;
46177: CALL 60510 0 0
// if event = 122 then
46181: LD_VAR 0 1
46185: PUSH
46186: LD_INT 122
46188: EQUAL
46189: IFFALSE 46195
// MC_ChangeApeClass ( ) ;
46191: CALL 61339 0 0
// if event = 123 then
46195: LD_VAR 0 1
46199: PUSH
46200: LD_INT 123
46202: EQUAL
46203: IFFALSE 46209
// MC_Bazooka ( ) ;
46205: CALL 61989 0 0
// if event = 124 then
46209: LD_VAR 0 1
46213: PUSH
46214: LD_INT 124
46216: EQUAL
46217: IFFALSE 46223
// MC_TeleportExit ( ) ;
46219: CALL 62187 0 0
// if event = 125 then
46223: LD_VAR 0 1
46227: PUSH
46228: LD_INT 125
46230: EQUAL
46231: IFFALSE 46237
// MC_Deposits ( ) ;
46233: CALL 62834 0 0
// if event = 126 then
46237: LD_VAR 0 1
46241: PUSH
46242: LD_INT 126
46244: EQUAL
46245: IFFALSE 46251
// MC_RemoteDriver ( ) ;
46247: CALL 63459 0 0
// if event = 200 then
46251: LD_VAR 0 1
46255: PUSH
46256: LD_INT 200
46258: EQUAL
46259: IFFALSE 46265
// MC_Idle ( ) ;
46261: CALL 65408 0 0
// end ;
46265: PPOPN 1
46267: END
// export function MC_Reset ( base , tag ) ; var i ; begin
46268: LD_INT 0
46270: PPUSH
46271: PPUSH
// if not mc_bases [ base ] or not tag then
46272: LD_EXP 14
46276: PUSH
46277: LD_VAR 0 1
46281: ARRAY
46282: NOT
46283: PUSH
46284: LD_VAR 0 2
46288: NOT
46289: OR
46290: IFFALSE 46294
// exit ;
46292: GO 46358
// for i in mc_bases [ base ] union mc_ape [ base ] do
46294: LD_ADDR_VAR 0 4
46298: PUSH
46299: LD_EXP 14
46303: PUSH
46304: LD_VAR 0 1
46308: ARRAY
46309: PUSH
46310: LD_EXP 43
46314: PUSH
46315: LD_VAR 0 1
46319: ARRAY
46320: UNION
46321: PUSH
46322: FOR_IN
46323: IFFALSE 46356
// if GetTag ( i ) = tag then
46325: LD_VAR 0 4
46329: PPUSH
46330: CALL_OW 110
46334: PUSH
46335: LD_VAR 0 2
46339: EQUAL
46340: IFFALSE 46354
// SetTag ( i , 0 ) ;
46342: LD_VAR 0 4
46346: PPUSH
46347: LD_INT 0
46349: PPUSH
46350: CALL_OW 109
46354: GO 46322
46356: POP
46357: POP
// end ;
46358: LD_VAR 0 3
46362: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
46363: LD_INT 0
46365: PPUSH
46366: PPUSH
46367: PPUSH
46368: PPUSH
46369: PPUSH
46370: PPUSH
46371: PPUSH
46372: PPUSH
// if not mc_bases then
46373: LD_EXP 14
46377: NOT
46378: IFFALSE 46382
// exit ;
46380: GO 46840
// for i = 1 to mc_bases do
46382: LD_ADDR_VAR 0 2
46386: PUSH
46387: DOUBLE
46388: LD_INT 1
46390: DEC
46391: ST_TO_ADDR
46392: LD_EXP 14
46396: PUSH
46397: FOR_TO
46398: IFFALSE 46838
// begin tmp := MC_ClassCheckReq ( i ) ;
46400: LD_ADDR_VAR 0 4
46404: PUSH
46405: LD_VAR 0 2
46409: PPUSH
46410: CALL 46845 0 1
46414: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
46415: LD_ADDR_EXP 55
46419: PUSH
46420: LD_EXP 55
46424: PPUSH
46425: LD_VAR 0 2
46429: PPUSH
46430: LD_VAR 0 4
46434: PPUSH
46435: CALL_OW 1
46439: ST_TO_ADDR
// if not tmp then
46440: LD_VAR 0 4
46444: NOT
46445: IFFALSE 46449
// continue ;
46447: GO 46397
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
46449: LD_ADDR_VAR 0 6
46453: PUSH
46454: LD_EXP 14
46458: PUSH
46459: LD_VAR 0 2
46463: ARRAY
46464: PPUSH
46465: LD_INT 2
46467: PUSH
46468: LD_INT 30
46470: PUSH
46471: LD_INT 4
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 30
46480: PUSH
46481: LD_INT 5
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: LIST
46492: PPUSH
46493: CALL_OW 72
46497: PUSH
46498: LD_EXP 14
46502: PUSH
46503: LD_VAR 0 2
46507: ARRAY
46508: PPUSH
46509: LD_INT 2
46511: PUSH
46512: LD_INT 30
46514: PUSH
46515: LD_INT 0
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PUSH
46522: LD_INT 30
46524: PUSH
46525: LD_INT 1
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: LIST
46536: PPUSH
46537: CALL_OW 72
46541: PUSH
46542: LD_EXP 14
46546: PUSH
46547: LD_VAR 0 2
46551: ARRAY
46552: PPUSH
46553: LD_INT 30
46555: PUSH
46556: LD_INT 3
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PPUSH
46563: CALL_OW 72
46567: PUSH
46568: LD_EXP 14
46572: PUSH
46573: LD_VAR 0 2
46577: ARRAY
46578: PPUSH
46579: LD_INT 2
46581: PUSH
46582: LD_INT 30
46584: PUSH
46585: LD_INT 6
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 30
46594: PUSH
46595: LD_INT 7
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 30
46604: PUSH
46605: LD_INT 8
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: PPUSH
46618: CALL_OW 72
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: ST_TO_ADDR
// for j = 1 to 4 do
46629: LD_ADDR_VAR 0 3
46633: PUSH
46634: DOUBLE
46635: LD_INT 1
46637: DEC
46638: ST_TO_ADDR
46639: LD_INT 4
46641: PUSH
46642: FOR_TO
46643: IFFALSE 46834
// begin if not tmp [ j ] then
46645: LD_VAR 0 4
46649: PUSH
46650: LD_VAR 0 3
46654: ARRAY
46655: NOT
46656: IFFALSE 46660
// continue ;
46658: GO 46642
// for p in tmp [ j ] do
46660: LD_ADDR_VAR 0 5
46664: PUSH
46665: LD_VAR 0 4
46669: PUSH
46670: LD_VAR 0 3
46674: ARRAY
46675: PUSH
46676: FOR_IN
46677: IFFALSE 46830
// begin if not b [ j ] then
46679: LD_VAR 0 6
46683: PUSH
46684: LD_VAR 0 3
46688: ARRAY
46689: NOT
46690: IFFALSE 46694
// break ;
46692: GO 46830
// e := 0 ;
46694: LD_ADDR_VAR 0 7
46698: PUSH
46699: LD_INT 0
46701: ST_TO_ADDR
// for k in b [ j ] do
46702: LD_ADDR_VAR 0 8
46706: PUSH
46707: LD_VAR 0 6
46711: PUSH
46712: LD_VAR 0 3
46716: ARRAY
46717: PUSH
46718: FOR_IN
46719: IFFALSE 46746
// if IsNotFull ( k ) then
46721: LD_VAR 0 8
46725: PPUSH
46726: CALL 6693 0 1
46730: IFFALSE 46744
// begin e := k ;
46732: LD_ADDR_VAR 0 7
46736: PUSH
46737: LD_VAR 0 8
46741: ST_TO_ADDR
// break ;
46742: GO 46746
// end ;
46744: GO 46718
46746: POP
46747: POP
// if e and not UnitGoingToBuilding ( p , e ) then
46748: LD_VAR 0 7
46752: PUSH
46753: LD_VAR 0 5
46757: PPUSH
46758: LD_VAR 0 7
46762: PPUSH
46763: CALL 39446 0 2
46767: NOT
46768: AND
46769: IFFALSE 46828
// begin if IsInUnit ( p ) then
46771: LD_VAR 0 5
46775: PPUSH
46776: CALL_OW 310
46780: IFFALSE 46791
// ComExitBuilding ( p ) ;
46782: LD_VAR 0 5
46786: PPUSH
46787: CALL_OW 122
// ComEnterUnit ( p , e ) ;
46791: LD_VAR 0 5
46795: PPUSH
46796: LD_VAR 0 7
46800: PPUSH
46801: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
46805: LD_VAR 0 5
46809: PPUSH
46810: LD_VAR 0 3
46814: PPUSH
46815: CALL_OW 183
// AddComExitBuilding ( p ) ;
46819: LD_VAR 0 5
46823: PPUSH
46824: CALL_OW 182
// end ; end ;
46828: GO 46676
46830: POP
46831: POP
// end ;
46832: GO 46642
46834: POP
46835: POP
// end ;
46836: GO 46397
46838: POP
46839: POP
// end ;
46840: LD_VAR 0 1
46844: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
46845: LD_INT 0
46847: PPUSH
46848: PPUSH
46849: PPUSH
46850: PPUSH
46851: PPUSH
46852: PPUSH
46853: PPUSH
46854: PPUSH
46855: PPUSH
46856: PPUSH
46857: PPUSH
46858: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46859: LD_VAR 0 1
46863: NOT
46864: PUSH
46865: LD_EXP 14
46869: PUSH
46870: LD_VAR 0 1
46874: ARRAY
46875: NOT
46876: OR
46877: PUSH
46878: LD_EXP 14
46882: PUSH
46883: LD_VAR 0 1
46887: ARRAY
46888: PPUSH
46889: LD_INT 2
46891: PUSH
46892: LD_INT 30
46894: PUSH
46895: LD_INT 0
46897: PUSH
46898: EMPTY
46899: LIST
46900: LIST
46901: PUSH
46902: LD_INT 30
46904: PUSH
46905: LD_INT 1
46907: PUSH
46908: EMPTY
46909: LIST
46910: LIST
46911: PUSH
46912: EMPTY
46913: LIST
46914: LIST
46915: LIST
46916: PPUSH
46917: CALL_OW 72
46921: NOT
46922: OR
46923: IFFALSE 46927
// exit ;
46925: GO 50430
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46927: LD_ADDR_VAR 0 4
46931: PUSH
46932: LD_EXP 14
46936: PUSH
46937: LD_VAR 0 1
46941: ARRAY
46942: PPUSH
46943: LD_INT 2
46945: PUSH
46946: LD_INT 25
46948: PUSH
46949: LD_INT 1
46951: PUSH
46952: EMPTY
46953: LIST
46954: LIST
46955: PUSH
46956: LD_INT 25
46958: PUSH
46959: LD_INT 2
46961: PUSH
46962: EMPTY
46963: LIST
46964: LIST
46965: PUSH
46966: LD_INT 25
46968: PUSH
46969: LD_INT 3
46971: PUSH
46972: EMPTY
46973: LIST
46974: LIST
46975: PUSH
46976: LD_INT 25
46978: PUSH
46979: LD_INT 4
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 25
46988: PUSH
46989: LD_INT 5
46991: PUSH
46992: EMPTY
46993: LIST
46994: LIST
46995: PUSH
46996: LD_INT 25
46998: PUSH
46999: LD_INT 8
47001: PUSH
47002: EMPTY
47003: LIST
47004: LIST
47005: PUSH
47006: LD_INT 25
47008: PUSH
47009: LD_INT 9
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: EMPTY
47017: LIST
47018: LIST
47019: LIST
47020: LIST
47021: LIST
47022: LIST
47023: LIST
47024: LIST
47025: PPUSH
47026: CALL_OW 72
47030: ST_TO_ADDR
// if not tmp then
47031: LD_VAR 0 4
47035: NOT
47036: IFFALSE 47040
// exit ;
47038: GO 50430
// for i in tmp do
47040: LD_ADDR_VAR 0 3
47044: PUSH
47045: LD_VAR 0 4
47049: PUSH
47050: FOR_IN
47051: IFFALSE 47082
// if GetTag ( i ) then
47053: LD_VAR 0 3
47057: PPUSH
47058: CALL_OW 110
47062: IFFALSE 47080
// tmp := tmp diff i ;
47064: LD_ADDR_VAR 0 4
47068: PUSH
47069: LD_VAR 0 4
47073: PUSH
47074: LD_VAR 0 3
47078: DIFF
47079: ST_TO_ADDR
47080: GO 47050
47082: POP
47083: POP
// if not tmp then
47084: LD_VAR 0 4
47088: NOT
47089: IFFALSE 47093
// exit ;
47091: GO 50430
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
47093: LD_ADDR_VAR 0 5
47097: PUSH
47098: LD_EXP 14
47102: PUSH
47103: LD_VAR 0 1
47107: ARRAY
47108: PPUSH
47109: LD_INT 2
47111: PUSH
47112: LD_INT 25
47114: PUSH
47115: LD_INT 1
47117: PUSH
47118: EMPTY
47119: LIST
47120: LIST
47121: PUSH
47122: LD_INT 25
47124: PUSH
47125: LD_INT 5
47127: PUSH
47128: EMPTY
47129: LIST
47130: LIST
47131: PUSH
47132: LD_INT 25
47134: PUSH
47135: LD_INT 8
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: PUSH
47142: LD_INT 25
47144: PUSH
47145: LD_INT 9
47147: PUSH
47148: EMPTY
47149: LIST
47150: LIST
47151: PUSH
47152: EMPTY
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: PPUSH
47159: CALL_OW 72
47163: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
47164: LD_ADDR_VAR 0 6
47168: PUSH
47169: LD_EXP 14
47173: PUSH
47174: LD_VAR 0 1
47178: ARRAY
47179: PPUSH
47180: LD_INT 25
47182: PUSH
47183: LD_INT 2
47185: PUSH
47186: EMPTY
47187: LIST
47188: LIST
47189: PPUSH
47190: CALL_OW 72
47194: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
47195: LD_ADDR_VAR 0 7
47199: PUSH
47200: LD_EXP 14
47204: PUSH
47205: LD_VAR 0 1
47209: ARRAY
47210: PPUSH
47211: LD_INT 25
47213: PUSH
47214: LD_INT 3
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PPUSH
47221: CALL_OW 72
47225: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
47226: LD_ADDR_VAR 0 8
47230: PUSH
47231: LD_EXP 14
47235: PUSH
47236: LD_VAR 0 1
47240: ARRAY
47241: PPUSH
47242: LD_INT 25
47244: PUSH
47245: LD_INT 4
47247: PUSH
47248: EMPTY
47249: LIST
47250: LIST
47251: PUSH
47252: LD_INT 24
47254: PUSH
47255: LD_INT 251
47257: PUSH
47258: EMPTY
47259: LIST
47260: LIST
47261: PUSH
47262: EMPTY
47263: LIST
47264: LIST
47265: PPUSH
47266: CALL_OW 72
47270: ST_TO_ADDR
// if mc_scan [ base ] then
47271: LD_EXP 37
47275: PUSH
47276: LD_VAR 0 1
47280: ARRAY
47281: IFFALSE 47742
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
47283: LD_ADDR_EXP 56
47287: PUSH
47288: LD_EXP 56
47292: PPUSH
47293: LD_VAR 0 1
47297: PPUSH
47298: LD_INT 4
47300: PPUSH
47301: CALL_OW 1
47305: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47306: LD_ADDR_VAR 0 12
47310: PUSH
47311: LD_EXP 14
47315: PUSH
47316: LD_VAR 0 1
47320: ARRAY
47321: PPUSH
47322: LD_INT 2
47324: PUSH
47325: LD_INT 30
47327: PUSH
47328: LD_INT 4
47330: PUSH
47331: EMPTY
47332: LIST
47333: LIST
47334: PUSH
47335: LD_INT 30
47337: PUSH
47338: LD_INT 5
47340: PUSH
47341: EMPTY
47342: LIST
47343: LIST
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: LIST
47349: PPUSH
47350: CALL_OW 72
47354: ST_TO_ADDR
// if not b then
47355: LD_VAR 0 12
47359: NOT
47360: IFFALSE 47364
// exit ;
47362: GO 50430
// p := [ ] ;
47364: LD_ADDR_VAR 0 11
47368: PUSH
47369: EMPTY
47370: ST_TO_ADDR
// if sci >= 2 then
47371: LD_VAR 0 8
47375: PUSH
47376: LD_INT 2
47378: GREATEREQUAL
47379: IFFALSE 47410
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
47381: LD_ADDR_VAR 0 8
47385: PUSH
47386: LD_VAR 0 8
47390: PUSH
47391: LD_INT 1
47393: ARRAY
47394: PUSH
47395: LD_VAR 0 8
47399: PUSH
47400: LD_INT 2
47402: ARRAY
47403: PUSH
47404: EMPTY
47405: LIST
47406: LIST
47407: ST_TO_ADDR
47408: GO 47471
// if sci = 1 then
47410: LD_VAR 0 8
47414: PUSH
47415: LD_INT 1
47417: EQUAL
47418: IFFALSE 47439
// sci := [ sci [ 1 ] ] else
47420: LD_ADDR_VAR 0 8
47424: PUSH
47425: LD_VAR 0 8
47429: PUSH
47430: LD_INT 1
47432: ARRAY
47433: PUSH
47434: EMPTY
47435: LIST
47436: ST_TO_ADDR
47437: GO 47471
// if sci = 0 then
47439: LD_VAR 0 8
47443: PUSH
47444: LD_INT 0
47446: EQUAL
47447: IFFALSE 47471
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
47449: LD_ADDR_VAR 0 11
47453: PUSH
47454: LD_VAR 0 4
47458: PPUSH
47459: LD_INT 4
47461: PPUSH
47462: CALL 39309 0 2
47466: PUSH
47467: LD_INT 1
47469: ARRAY
47470: ST_TO_ADDR
// if eng > 4 then
47471: LD_VAR 0 6
47475: PUSH
47476: LD_INT 4
47478: GREATER
47479: IFFALSE 47525
// for i = eng downto 4 do
47481: LD_ADDR_VAR 0 3
47485: PUSH
47486: DOUBLE
47487: LD_VAR 0 6
47491: INC
47492: ST_TO_ADDR
47493: LD_INT 4
47495: PUSH
47496: FOR_DOWNTO
47497: IFFALSE 47523
// eng := eng diff eng [ i ] ;
47499: LD_ADDR_VAR 0 6
47503: PUSH
47504: LD_VAR 0 6
47508: PUSH
47509: LD_VAR 0 6
47513: PUSH
47514: LD_VAR 0 3
47518: ARRAY
47519: DIFF
47520: ST_TO_ADDR
47521: GO 47496
47523: POP
47524: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
47525: LD_ADDR_VAR 0 4
47529: PUSH
47530: LD_VAR 0 4
47534: PUSH
47535: LD_VAR 0 5
47539: PUSH
47540: LD_VAR 0 6
47544: UNION
47545: PUSH
47546: LD_VAR 0 7
47550: UNION
47551: PUSH
47552: LD_VAR 0 8
47556: UNION
47557: DIFF
47558: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
47559: LD_ADDR_VAR 0 13
47563: PUSH
47564: LD_EXP 14
47568: PUSH
47569: LD_VAR 0 1
47573: ARRAY
47574: PPUSH
47575: LD_INT 2
47577: PUSH
47578: LD_INT 30
47580: PUSH
47581: LD_INT 32
47583: PUSH
47584: EMPTY
47585: LIST
47586: LIST
47587: PUSH
47588: LD_INT 30
47590: PUSH
47591: LD_INT 31
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: PUSH
47598: EMPTY
47599: LIST
47600: LIST
47601: LIST
47602: PPUSH
47603: CALL_OW 72
47607: PUSH
47608: LD_EXP 14
47612: PUSH
47613: LD_VAR 0 1
47617: ARRAY
47618: PPUSH
47619: LD_INT 2
47621: PUSH
47622: LD_INT 30
47624: PUSH
47625: LD_INT 4
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PUSH
47632: LD_INT 30
47634: PUSH
47635: LD_INT 5
47637: PUSH
47638: EMPTY
47639: LIST
47640: LIST
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: LIST
47646: PPUSH
47647: CALL_OW 72
47651: PUSH
47652: LD_INT 6
47654: MUL
47655: PLUS
47656: ST_TO_ADDR
// if bcount < tmp then
47657: LD_VAR 0 13
47661: PUSH
47662: LD_VAR 0 4
47666: LESS
47667: IFFALSE 47713
// for i = tmp downto bcount do
47669: LD_ADDR_VAR 0 3
47673: PUSH
47674: DOUBLE
47675: LD_VAR 0 4
47679: INC
47680: ST_TO_ADDR
47681: LD_VAR 0 13
47685: PUSH
47686: FOR_DOWNTO
47687: IFFALSE 47711
// tmp := Delete ( tmp , tmp ) ;
47689: LD_ADDR_VAR 0 4
47693: PUSH
47694: LD_VAR 0 4
47698: PPUSH
47699: LD_VAR 0 4
47703: PPUSH
47704: CALL_OW 3
47708: ST_TO_ADDR
47709: GO 47686
47711: POP
47712: POP
// result := [ tmp , 0 , 0 , p ] ;
47713: LD_ADDR_VAR 0 2
47717: PUSH
47718: LD_VAR 0 4
47722: PUSH
47723: LD_INT 0
47725: PUSH
47726: LD_INT 0
47728: PUSH
47729: LD_VAR 0 11
47733: PUSH
47734: EMPTY
47735: LIST
47736: LIST
47737: LIST
47738: LIST
47739: ST_TO_ADDR
// exit ;
47740: GO 50430
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47742: LD_EXP 14
47746: PUSH
47747: LD_VAR 0 1
47751: ARRAY
47752: PPUSH
47753: LD_INT 2
47755: PUSH
47756: LD_INT 30
47758: PUSH
47759: LD_INT 6
47761: PUSH
47762: EMPTY
47763: LIST
47764: LIST
47765: PUSH
47766: LD_INT 30
47768: PUSH
47769: LD_INT 7
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: PUSH
47776: LD_INT 30
47778: PUSH
47779: LD_INT 8
47781: PUSH
47782: EMPTY
47783: LIST
47784: LIST
47785: PUSH
47786: EMPTY
47787: LIST
47788: LIST
47789: LIST
47790: LIST
47791: PPUSH
47792: CALL_OW 72
47796: NOT
47797: PUSH
47798: LD_EXP 14
47802: PUSH
47803: LD_VAR 0 1
47807: ARRAY
47808: PPUSH
47809: LD_INT 30
47811: PUSH
47812: LD_INT 3
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PPUSH
47819: CALL_OW 72
47823: NOT
47824: AND
47825: IFFALSE 47897
// begin if eng = tmp then
47827: LD_VAR 0 6
47831: PUSH
47832: LD_VAR 0 4
47836: EQUAL
47837: IFFALSE 47841
// exit ;
47839: GO 50430
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
47841: LD_ADDR_EXP 56
47845: PUSH
47846: LD_EXP 56
47850: PPUSH
47851: LD_VAR 0 1
47855: PPUSH
47856: LD_INT 1
47858: PPUSH
47859: CALL_OW 1
47863: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
47864: LD_ADDR_VAR 0 2
47868: PUSH
47869: LD_INT 0
47871: PUSH
47872: LD_VAR 0 4
47876: PUSH
47877: LD_VAR 0 6
47881: DIFF
47882: PUSH
47883: LD_INT 0
47885: PUSH
47886: LD_INT 0
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: LIST
47893: LIST
47894: ST_TO_ADDR
// exit ;
47895: GO 50430
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
47897: LD_EXP 41
47901: PUSH
47902: LD_EXP 40
47906: PUSH
47907: LD_VAR 0 1
47911: ARRAY
47912: ARRAY
47913: PUSH
47914: LD_EXP 14
47918: PUSH
47919: LD_VAR 0 1
47923: ARRAY
47924: PPUSH
47925: LD_INT 2
47927: PUSH
47928: LD_INT 30
47930: PUSH
47931: LD_INT 6
47933: PUSH
47934: EMPTY
47935: LIST
47936: LIST
47937: PUSH
47938: LD_INT 30
47940: PUSH
47941: LD_INT 7
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: LD_INT 30
47950: PUSH
47951: LD_INT 8
47953: PUSH
47954: EMPTY
47955: LIST
47956: LIST
47957: PUSH
47958: EMPTY
47959: LIST
47960: LIST
47961: LIST
47962: LIST
47963: PPUSH
47964: CALL_OW 72
47968: AND
47969: PUSH
47970: LD_EXP 14
47974: PUSH
47975: LD_VAR 0 1
47979: ARRAY
47980: PPUSH
47981: LD_INT 30
47983: PUSH
47984: LD_INT 3
47986: PUSH
47987: EMPTY
47988: LIST
47989: LIST
47990: PPUSH
47991: CALL_OW 72
47995: NOT
47996: AND
47997: IFFALSE 48211
// begin if sci >= 6 then
47999: LD_VAR 0 8
48003: PUSH
48004: LD_INT 6
48006: GREATEREQUAL
48007: IFFALSE 48011
// exit ;
48009: GO 50430
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
48011: LD_ADDR_EXP 56
48015: PUSH
48016: LD_EXP 56
48020: PPUSH
48021: LD_VAR 0 1
48025: PPUSH
48026: LD_INT 2
48028: PPUSH
48029: CALL_OW 1
48033: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
48034: LD_ADDR_VAR 0 9
48038: PUSH
48039: LD_VAR 0 4
48043: PUSH
48044: LD_VAR 0 8
48048: DIFF
48049: PPUSH
48050: LD_INT 4
48052: PPUSH
48053: CALL 39309 0 2
48057: ST_TO_ADDR
// p := [ ] ;
48058: LD_ADDR_VAR 0 11
48062: PUSH
48063: EMPTY
48064: ST_TO_ADDR
// if sci < 6 and sort > 6 then
48065: LD_VAR 0 8
48069: PUSH
48070: LD_INT 6
48072: LESS
48073: PUSH
48074: LD_VAR 0 9
48078: PUSH
48079: LD_INT 6
48081: GREATER
48082: AND
48083: IFFALSE 48164
// begin for i = 1 to 6 - sci do
48085: LD_ADDR_VAR 0 3
48089: PUSH
48090: DOUBLE
48091: LD_INT 1
48093: DEC
48094: ST_TO_ADDR
48095: LD_INT 6
48097: PUSH
48098: LD_VAR 0 8
48102: MINUS
48103: PUSH
48104: FOR_TO
48105: IFFALSE 48160
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
48107: LD_ADDR_VAR 0 11
48111: PUSH
48112: LD_VAR 0 11
48116: PPUSH
48117: LD_VAR 0 11
48121: PUSH
48122: LD_INT 1
48124: PLUS
48125: PPUSH
48126: LD_VAR 0 9
48130: PUSH
48131: LD_INT 1
48133: ARRAY
48134: PPUSH
48135: CALL_OW 2
48139: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
48140: LD_ADDR_VAR 0 9
48144: PUSH
48145: LD_VAR 0 9
48149: PPUSH
48150: LD_INT 1
48152: PPUSH
48153: CALL_OW 3
48157: ST_TO_ADDR
// end ;
48158: GO 48104
48160: POP
48161: POP
// end else
48162: GO 48184
// if sort then
48164: LD_VAR 0 9
48168: IFFALSE 48184
// p := sort [ 1 ] ;
48170: LD_ADDR_VAR 0 11
48174: PUSH
48175: LD_VAR 0 9
48179: PUSH
48180: LD_INT 1
48182: ARRAY
48183: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
48184: LD_ADDR_VAR 0 2
48188: PUSH
48189: LD_INT 0
48191: PUSH
48192: LD_INT 0
48194: PUSH
48195: LD_INT 0
48197: PUSH
48198: LD_VAR 0 11
48202: PUSH
48203: EMPTY
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: ST_TO_ADDR
// exit ;
48209: GO 50430
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
48211: LD_EXP 41
48215: PUSH
48216: LD_EXP 40
48220: PUSH
48221: LD_VAR 0 1
48225: ARRAY
48226: ARRAY
48227: PUSH
48228: LD_EXP 14
48232: PUSH
48233: LD_VAR 0 1
48237: ARRAY
48238: PPUSH
48239: LD_INT 2
48241: PUSH
48242: LD_INT 30
48244: PUSH
48245: LD_INT 6
48247: PUSH
48248: EMPTY
48249: LIST
48250: LIST
48251: PUSH
48252: LD_INT 30
48254: PUSH
48255: LD_INT 7
48257: PUSH
48258: EMPTY
48259: LIST
48260: LIST
48261: PUSH
48262: LD_INT 30
48264: PUSH
48265: LD_INT 8
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: PPUSH
48278: CALL_OW 72
48282: AND
48283: PUSH
48284: LD_EXP 14
48288: PUSH
48289: LD_VAR 0 1
48293: ARRAY
48294: PPUSH
48295: LD_INT 30
48297: PUSH
48298: LD_INT 3
48300: PUSH
48301: EMPTY
48302: LIST
48303: LIST
48304: PPUSH
48305: CALL_OW 72
48309: AND
48310: IFFALSE 49044
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
48312: LD_ADDR_EXP 56
48316: PUSH
48317: LD_EXP 56
48321: PPUSH
48322: LD_VAR 0 1
48326: PPUSH
48327: LD_INT 3
48329: PPUSH
48330: CALL_OW 1
48334: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
48335: LD_ADDR_VAR 0 2
48339: PUSH
48340: LD_INT 0
48342: PUSH
48343: LD_INT 0
48345: PUSH
48346: LD_INT 0
48348: PUSH
48349: LD_INT 0
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: LIST
48356: LIST
48357: ST_TO_ADDR
// if not eng then
48358: LD_VAR 0 6
48362: NOT
48363: IFFALSE 48426
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
48365: LD_ADDR_VAR 0 11
48369: PUSH
48370: LD_VAR 0 4
48374: PPUSH
48375: LD_INT 2
48377: PPUSH
48378: CALL 39309 0 2
48382: PUSH
48383: LD_INT 1
48385: ARRAY
48386: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
48387: LD_ADDR_VAR 0 2
48391: PUSH
48392: LD_VAR 0 2
48396: PPUSH
48397: LD_INT 2
48399: PPUSH
48400: LD_VAR 0 11
48404: PPUSH
48405: CALL_OW 1
48409: ST_TO_ADDR
// tmp := tmp diff p ;
48410: LD_ADDR_VAR 0 4
48414: PUSH
48415: LD_VAR 0 4
48419: PUSH
48420: LD_VAR 0 11
48424: DIFF
48425: ST_TO_ADDR
// end ; if tmp and sci < 6 then
48426: LD_VAR 0 4
48430: PUSH
48431: LD_VAR 0 8
48435: PUSH
48436: LD_INT 6
48438: LESS
48439: AND
48440: IFFALSE 48628
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
48442: LD_ADDR_VAR 0 9
48446: PUSH
48447: LD_VAR 0 4
48451: PUSH
48452: LD_VAR 0 8
48456: PUSH
48457: LD_VAR 0 7
48461: UNION
48462: DIFF
48463: PPUSH
48464: LD_INT 4
48466: PPUSH
48467: CALL 39309 0 2
48471: ST_TO_ADDR
// p := [ ] ;
48472: LD_ADDR_VAR 0 11
48476: PUSH
48477: EMPTY
48478: ST_TO_ADDR
// if sort then
48479: LD_VAR 0 9
48483: IFFALSE 48599
// for i = 1 to 6 - sci do
48485: LD_ADDR_VAR 0 3
48489: PUSH
48490: DOUBLE
48491: LD_INT 1
48493: DEC
48494: ST_TO_ADDR
48495: LD_INT 6
48497: PUSH
48498: LD_VAR 0 8
48502: MINUS
48503: PUSH
48504: FOR_TO
48505: IFFALSE 48597
// begin if i = sort then
48507: LD_VAR 0 3
48511: PUSH
48512: LD_VAR 0 9
48516: EQUAL
48517: IFFALSE 48521
// break ;
48519: GO 48597
// if GetClass ( i ) = 4 then
48521: LD_VAR 0 3
48525: PPUSH
48526: CALL_OW 257
48530: PUSH
48531: LD_INT 4
48533: EQUAL
48534: IFFALSE 48538
// continue ;
48536: GO 48504
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48538: LD_ADDR_VAR 0 11
48542: PUSH
48543: LD_VAR 0 11
48547: PPUSH
48548: LD_VAR 0 11
48552: PUSH
48553: LD_INT 1
48555: PLUS
48556: PPUSH
48557: LD_VAR 0 9
48561: PUSH
48562: LD_VAR 0 3
48566: ARRAY
48567: PPUSH
48568: CALL_OW 2
48572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48573: LD_ADDR_VAR 0 4
48577: PUSH
48578: LD_VAR 0 4
48582: PUSH
48583: LD_VAR 0 9
48587: PUSH
48588: LD_VAR 0 3
48592: ARRAY
48593: DIFF
48594: ST_TO_ADDR
// end ;
48595: GO 48504
48597: POP
48598: POP
// if p then
48599: LD_VAR 0 11
48603: IFFALSE 48628
// result := Replace ( result , 4 , p ) ;
48605: LD_ADDR_VAR 0 2
48609: PUSH
48610: LD_VAR 0 2
48614: PPUSH
48615: LD_INT 4
48617: PPUSH
48618: LD_VAR 0 11
48622: PPUSH
48623: CALL_OW 1
48627: ST_TO_ADDR
// end ; if tmp and mech < 6 then
48628: LD_VAR 0 4
48632: PUSH
48633: LD_VAR 0 7
48637: PUSH
48638: LD_INT 6
48640: LESS
48641: AND
48642: IFFALSE 48830
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
48644: LD_ADDR_VAR 0 9
48648: PUSH
48649: LD_VAR 0 4
48653: PUSH
48654: LD_VAR 0 8
48658: PUSH
48659: LD_VAR 0 7
48663: UNION
48664: DIFF
48665: PPUSH
48666: LD_INT 3
48668: PPUSH
48669: CALL 39309 0 2
48673: ST_TO_ADDR
// p := [ ] ;
48674: LD_ADDR_VAR 0 11
48678: PUSH
48679: EMPTY
48680: ST_TO_ADDR
// if sort then
48681: LD_VAR 0 9
48685: IFFALSE 48801
// for i = 1 to 6 - mech do
48687: LD_ADDR_VAR 0 3
48691: PUSH
48692: DOUBLE
48693: LD_INT 1
48695: DEC
48696: ST_TO_ADDR
48697: LD_INT 6
48699: PUSH
48700: LD_VAR 0 7
48704: MINUS
48705: PUSH
48706: FOR_TO
48707: IFFALSE 48799
// begin if i = sort then
48709: LD_VAR 0 3
48713: PUSH
48714: LD_VAR 0 9
48718: EQUAL
48719: IFFALSE 48723
// break ;
48721: GO 48799
// if GetClass ( i ) = 3 then
48723: LD_VAR 0 3
48727: PPUSH
48728: CALL_OW 257
48732: PUSH
48733: LD_INT 3
48735: EQUAL
48736: IFFALSE 48740
// continue ;
48738: GO 48706
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48740: LD_ADDR_VAR 0 11
48744: PUSH
48745: LD_VAR 0 11
48749: PPUSH
48750: LD_VAR 0 11
48754: PUSH
48755: LD_INT 1
48757: PLUS
48758: PPUSH
48759: LD_VAR 0 9
48763: PUSH
48764: LD_VAR 0 3
48768: ARRAY
48769: PPUSH
48770: CALL_OW 2
48774: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48775: LD_ADDR_VAR 0 4
48779: PUSH
48780: LD_VAR 0 4
48784: PUSH
48785: LD_VAR 0 9
48789: PUSH
48790: LD_VAR 0 3
48794: ARRAY
48795: DIFF
48796: ST_TO_ADDR
// end ;
48797: GO 48706
48799: POP
48800: POP
// if p then
48801: LD_VAR 0 11
48805: IFFALSE 48830
// result := Replace ( result , 3 , p ) ;
48807: LD_ADDR_VAR 0 2
48811: PUSH
48812: LD_VAR 0 2
48816: PPUSH
48817: LD_INT 3
48819: PPUSH
48820: LD_VAR 0 11
48824: PPUSH
48825: CALL_OW 1
48829: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
48830: LD_VAR 0 4
48834: PUSH
48835: LD_INT 6
48837: GREATER
48838: PUSH
48839: LD_VAR 0 6
48843: PUSH
48844: LD_INT 6
48846: LESS
48847: AND
48848: IFFALSE 49042
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
48850: LD_ADDR_VAR 0 9
48854: PUSH
48855: LD_VAR 0 4
48859: PUSH
48860: LD_VAR 0 8
48864: PUSH
48865: LD_VAR 0 7
48869: UNION
48870: PUSH
48871: LD_VAR 0 6
48875: UNION
48876: DIFF
48877: PPUSH
48878: LD_INT 2
48880: PPUSH
48881: CALL 39309 0 2
48885: ST_TO_ADDR
// p := [ ] ;
48886: LD_ADDR_VAR 0 11
48890: PUSH
48891: EMPTY
48892: ST_TO_ADDR
// if sort then
48893: LD_VAR 0 9
48897: IFFALSE 49013
// for i = 1 to 6 - eng do
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: DOUBLE
48905: LD_INT 1
48907: DEC
48908: ST_TO_ADDR
48909: LD_INT 6
48911: PUSH
48912: LD_VAR 0 6
48916: MINUS
48917: PUSH
48918: FOR_TO
48919: IFFALSE 49011
// begin if i = sort then
48921: LD_VAR 0 3
48925: PUSH
48926: LD_VAR 0 9
48930: EQUAL
48931: IFFALSE 48935
// break ;
48933: GO 49011
// if GetClass ( i ) = 2 then
48935: LD_VAR 0 3
48939: PPUSH
48940: CALL_OW 257
48944: PUSH
48945: LD_INT 2
48947: EQUAL
48948: IFFALSE 48952
// continue ;
48950: GO 48918
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48952: LD_ADDR_VAR 0 11
48956: PUSH
48957: LD_VAR 0 11
48961: PPUSH
48962: LD_VAR 0 11
48966: PUSH
48967: LD_INT 1
48969: PLUS
48970: PPUSH
48971: LD_VAR 0 9
48975: PUSH
48976: LD_VAR 0 3
48980: ARRAY
48981: PPUSH
48982: CALL_OW 2
48986: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48987: LD_ADDR_VAR 0 4
48991: PUSH
48992: LD_VAR 0 4
48996: PUSH
48997: LD_VAR 0 9
49001: PUSH
49002: LD_VAR 0 3
49006: ARRAY
49007: DIFF
49008: ST_TO_ADDR
// end ;
49009: GO 48918
49011: POP
49012: POP
// if p then
49013: LD_VAR 0 11
49017: IFFALSE 49042
// result := Replace ( result , 2 , p ) ;
49019: LD_ADDR_VAR 0 2
49023: PUSH
49024: LD_VAR 0 2
49028: PPUSH
49029: LD_INT 2
49031: PPUSH
49032: LD_VAR 0 11
49036: PPUSH
49037: CALL_OW 1
49041: ST_TO_ADDR
// end ; exit ;
49042: GO 50430
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
49044: LD_EXP 41
49048: PUSH
49049: LD_EXP 40
49053: PUSH
49054: LD_VAR 0 1
49058: ARRAY
49059: ARRAY
49060: NOT
49061: PUSH
49062: LD_EXP 14
49066: PUSH
49067: LD_VAR 0 1
49071: ARRAY
49072: PPUSH
49073: LD_INT 30
49075: PUSH
49076: LD_INT 3
49078: PUSH
49079: EMPTY
49080: LIST
49081: LIST
49082: PPUSH
49083: CALL_OW 72
49087: AND
49088: PUSH
49089: LD_EXP 19
49093: PUSH
49094: LD_VAR 0 1
49098: ARRAY
49099: AND
49100: IFFALSE 49708
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
49102: LD_ADDR_EXP 56
49106: PUSH
49107: LD_EXP 56
49111: PPUSH
49112: LD_VAR 0 1
49116: PPUSH
49117: LD_INT 5
49119: PPUSH
49120: CALL_OW 1
49124: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
49125: LD_ADDR_VAR 0 2
49129: PUSH
49130: LD_INT 0
49132: PUSH
49133: LD_INT 0
49135: PUSH
49136: LD_INT 0
49138: PUSH
49139: LD_INT 0
49141: PUSH
49142: EMPTY
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: ST_TO_ADDR
// if sci > 1 then
49148: LD_VAR 0 8
49152: PUSH
49153: LD_INT 1
49155: GREATER
49156: IFFALSE 49184
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
49158: LD_ADDR_VAR 0 4
49162: PUSH
49163: LD_VAR 0 4
49167: PUSH
49168: LD_VAR 0 8
49172: PUSH
49173: LD_VAR 0 8
49177: PUSH
49178: LD_INT 1
49180: ARRAY
49181: DIFF
49182: DIFF
49183: ST_TO_ADDR
// if tmp and not sci then
49184: LD_VAR 0 4
49188: PUSH
49189: LD_VAR 0 8
49193: NOT
49194: AND
49195: IFFALSE 49264
// begin sort := SortBySkill ( tmp , 4 ) ;
49197: LD_ADDR_VAR 0 9
49201: PUSH
49202: LD_VAR 0 4
49206: PPUSH
49207: LD_INT 4
49209: PPUSH
49210: CALL 39309 0 2
49214: ST_TO_ADDR
// if sort then
49215: LD_VAR 0 9
49219: IFFALSE 49235
// p := sort [ 1 ] ;
49221: LD_ADDR_VAR 0 11
49225: PUSH
49226: LD_VAR 0 9
49230: PUSH
49231: LD_INT 1
49233: ARRAY
49234: ST_TO_ADDR
// if p then
49235: LD_VAR 0 11
49239: IFFALSE 49264
// result := Replace ( result , 4 , p ) ;
49241: LD_ADDR_VAR 0 2
49245: PUSH
49246: LD_VAR 0 2
49250: PPUSH
49251: LD_INT 4
49253: PPUSH
49254: LD_VAR 0 11
49258: PPUSH
49259: CALL_OW 1
49263: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49264: LD_ADDR_VAR 0 4
49268: PUSH
49269: LD_VAR 0 4
49273: PUSH
49274: LD_VAR 0 7
49278: DIFF
49279: ST_TO_ADDR
// if tmp and mech < 6 then
49280: LD_VAR 0 4
49284: PUSH
49285: LD_VAR 0 7
49289: PUSH
49290: LD_INT 6
49292: LESS
49293: AND
49294: IFFALSE 49482
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
49296: LD_ADDR_VAR 0 9
49300: PUSH
49301: LD_VAR 0 4
49305: PUSH
49306: LD_VAR 0 8
49310: PUSH
49311: LD_VAR 0 7
49315: UNION
49316: DIFF
49317: PPUSH
49318: LD_INT 3
49320: PPUSH
49321: CALL 39309 0 2
49325: ST_TO_ADDR
// p := [ ] ;
49326: LD_ADDR_VAR 0 11
49330: PUSH
49331: EMPTY
49332: ST_TO_ADDR
// if sort then
49333: LD_VAR 0 9
49337: IFFALSE 49453
// for i = 1 to 6 - mech do
49339: LD_ADDR_VAR 0 3
49343: PUSH
49344: DOUBLE
49345: LD_INT 1
49347: DEC
49348: ST_TO_ADDR
49349: LD_INT 6
49351: PUSH
49352: LD_VAR 0 7
49356: MINUS
49357: PUSH
49358: FOR_TO
49359: IFFALSE 49451
// begin if i = sort then
49361: LD_VAR 0 3
49365: PUSH
49366: LD_VAR 0 9
49370: EQUAL
49371: IFFALSE 49375
// break ;
49373: GO 49451
// if GetClass ( i ) = 3 then
49375: LD_VAR 0 3
49379: PPUSH
49380: CALL_OW 257
49384: PUSH
49385: LD_INT 3
49387: EQUAL
49388: IFFALSE 49392
// continue ;
49390: GO 49358
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49392: LD_ADDR_VAR 0 11
49396: PUSH
49397: LD_VAR 0 11
49401: PPUSH
49402: LD_VAR 0 11
49406: PUSH
49407: LD_INT 1
49409: PLUS
49410: PPUSH
49411: LD_VAR 0 9
49415: PUSH
49416: LD_VAR 0 3
49420: ARRAY
49421: PPUSH
49422: CALL_OW 2
49426: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49427: LD_ADDR_VAR 0 4
49431: PUSH
49432: LD_VAR 0 4
49436: PUSH
49437: LD_VAR 0 9
49441: PUSH
49442: LD_VAR 0 3
49446: ARRAY
49447: DIFF
49448: ST_TO_ADDR
// end ;
49449: GO 49358
49451: POP
49452: POP
// if p then
49453: LD_VAR 0 11
49457: IFFALSE 49482
// result := Replace ( result , 3 , p ) ;
49459: LD_ADDR_VAR 0 2
49463: PUSH
49464: LD_VAR 0 2
49468: PPUSH
49469: LD_INT 3
49471: PPUSH
49472: LD_VAR 0 11
49476: PPUSH
49477: CALL_OW 1
49481: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
49482: LD_ADDR_VAR 0 4
49486: PUSH
49487: LD_VAR 0 4
49491: PUSH
49492: LD_VAR 0 6
49496: DIFF
49497: ST_TO_ADDR
// if tmp and eng < 6 then
49498: LD_VAR 0 4
49502: PUSH
49503: LD_VAR 0 6
49507: PUSH
49508: LD_INT 6
49510: LESS
49511: AND
49512: IFFALSE 49706
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
49514: LD_ADDR_VAR 0 9
49518: PUSH
49519: LD_VAR 0 4
49523: PUSH
49524: LD_VAR 0 8
49528: PUSH
49529: LD_VAR 0 7
49533: UNION
49534: PUSH
49535: LD_VAR 0 6
49539: UNION
49540: DIFF
49541: PPUSH
49542: LD_INT 2
49544: PPUSH
49545: CALL 39309 0 2
49549: ST_TO_ADDR
// p := [ ] ;
49550: LD_ADDR_VAR 0 11
49554: PUSH
49555: EMPTY
49556: ST_TO_ADDR
// if sort then
49557: LD_VAR 0 9
49561: IFFALSE 49677
// for i = 1 to 6 - eng do
49563: LD_ADDR_VAR 0 3
49567: PUSH
49568: DOUBLE
49569: LD_INT 1
49571: DEC
49572: ST_TO_ADDR
49573: LD_INT 6
49575: PUSH
49576: LD_VAR 0 6
49580: MINUS
49581: PUSH
49582: FOR_TO
49583: IFFALSE 49675
// begin if i = sort then
49585: LD_VAR 0 3
49589: PUSH
49590: LD_VAR 0 9
49594: EQUAL
49595: IFFALSE 49599
// break ;
49597: GO 49675
// if GetClass ( i ) = 2 then
49599: LD_VAR 0 3
49603: PPUSH
49604: CALL_OW 257
49608: PUSH
49609: LD_INT 2
49611: EQUAL
49612: IFFALSE 49616
// continue ;
49614: GO 49582
// p := Insert ( p , p + 1 , sort [ i ] ) ;
49616: LD_ADDR_VAR 0 11
49620: PUSH
49621: LD_VAR 0 11
49625: PPUSH
49626: LD_VAR 0 11
49630: PUSH
49631: LD_INT 1
49633: PLUS
49634: PPUSH
49635: LD_VAR 0 9
49639: PUSH
49640: LD_VAR 0 3
49644: ARRAY
49645: PPUSH
49646: CALL_OW 2
49650: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
49651: LD_ADDR_VAR 0 4
49655: PUSH
49656: LD_VAR 0 4
49660: PUSH
49661: LD_VAR 0 9
49665: PUSH
49666: LD_VAR 0 3
49670: ARRAY
49671: DIFF
49672: ST_TO_ADDR
// end ;
49673: GO 49582
49675: POP
49676: POP
// if p then
49677: LD_VAR 0 11
49681: IFFALSE 49706
// result := Replace ( result , 2 , p ) ;
49683: LD_ADDR_VAR 0 2
49687: PUSH
49688: LD_VAR 0 2
49692: PPUSH
49693: LD_INT 2
49695: PPUSH
49696: LD_VAR 0 11
49700: PPUSH
49701: CALL_OW 1
49705: ST_TO_ADDR
// end ; exit ;
49706: GO 50430
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
49708: LD_EXP 41
49712: PUSH
49713: LD_EXP 40
49717: PUSH
49718: LD_VAR 0 1
49722: ARRAY
49723: ARRAY
49724: NOT
49725: PUSH
49726: LD_EXP 14
49730: PUSH
49731: LD_VAR 0 1
49735: ARRAY
49736: PPUSH
49737: LD_INT 30
49739: PUSH
49740: LD_INT 3
49742: PUSH
49743: EMPTY
49744: LIST
49745: LIST
49746: PPUSH
49747: CALL_OW 72
49751: AND
49752: PUSH
49753: LD_EXP 19
49757: PUSH
49758: LD_VAR 0 1
49762: ARRAY
49763: NOT
49764: AND
49765: IFFALSE 50430
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
49767: LD_ADDR_EXP 56
49771: PUSH
49772: LD_EXP 56
49776: PPUSH
49777: LD_VAR 0 1
49781: PPUSH
49782: LD_INT 6
49784: PPUSH
49785: CALL_OW 1
49789: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
49790: LD_ADDR_VAR 0 2
49794: PUSH
49795: LD_INT 0
49797: PUSH
49798: LD_INT 0
49800: PUSH
49801: LD_INT 0
49803: PUSH
49804: LD_INT 0
49806: PUSH
49807: EMPTY
49808: LIST
49809: LIST
49810: LIST
49811: LIST
49812: ST_TO_ADDR
// if sci >= 1 then
49813: LD_VAR 0 8
49817: PUSH
49818: LD_INT 1
49820: GREATEREQUAL
49821: IFFALSE 49843
// tmp := tmp diff sci [ 1 ] ;
49823: LD_ADDR_VAR 0 4
49827: PUSH
49828: LD_VAR 0 4
49832: PUSH
49833: LD_VAR 0 8
49837: PUSH
49838: LD_INT 1
49840: ARRAY
49841: DIFF
49842: ST_TO_ADDR
// if tmp and not sci then
49843: LD_VAR 0 4
49847: PUSH
49848: LD_VAR 0 8
49852: NOT
49853: AND
49854: IFFALSE 49923
// begin sort := SortBySkill ( tmp , 4 ) ;
49856: LD_ADDR_VAR 0 9
49860: PUSH
49861: LD_VAR 0 4
49865: PPUSH
49866: LD_INT 4
49868: PPUSH
49869: CALL 39309 0 2
49873: ST_TO_ADDR
// if sort then
49874: LD_VAR 0 9
49878: IFFALSE 49894
// p := sort [ 1 ] ;
49880: LD_ADDR_VAR 0 11
49884: PUSH
49885: LD_VAR 0 9
49889: PUSH
49890: LD_INT 1
49892: ARRAY
49893: ST_TO_ADDR
// if p then
49894: LD_VAR 0 11
49898: IFFALSE 49923
// result := Replace ( result , 4 , p ) ;
49900: LD_ADDR_VAR 0 2
49904: PUSH
49905: LD_VAR 0 2
49909: PPUSH
49910: LD_INT 4
49912: PPUSH
49913: LD_VAR 0 11
49917: PPUSH
49918: CALL_OW 1
49922: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
49923: LD_ADDR_VAR 0 4
49927: PUSH
49928: LD_VAR 0 4
49932: PUSH
49933: LD_VAR 0 7
49937: DIFF
49938: ST_TO_ADDR
// if tmp and mech < 6 then
49939: LD_VAR 0 4
49943: PUSH
49944: LD_VAR 0 7
49948: PUSH
49949: LD_INT 6
49951: LESS
49952: AND
49953: IFFALSE 50135
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
49955: LD_ADDR_VAR 0 9
49959: PUSH
49960: LD_VAR 0 4
49964: PUSH
49965: LD_VAR 0 7
49969: DIFF
49970: PPUSH
49971: LD_INT 3
49973: PPUSH
49974: CALL 39309 0 2
49978: ST_TO_ADDR
// p := [ ] ;
49979: LD_ADDR_VAR 0 11
49983: PUSH
49984: EMPTY
49985: ST_TO_ADDR
// if sort then
49986: LD_VAR 0 9
49990: IFFALSE 50106
// for i = 1 to 6 - mech do
49992: LD_ADDR_VAR 0 3
49996: PUSH
49997: DOUBLE
49998: LD_INT 1
50000: DEC
50001: ST_TO_ADDR
50002: LD_INT 6
50004: PUSH
50005: LD_VAR 0 7
50009: MINUS
50010: PUSH
50011: FOR_TO
50012: IFFALSE 50104
// begin if i = sort then
50014: LD_VAR 0 3
50018: PUSH
50019: LD_VAR 0 9
50023: EQUAL
50024: IFFALSE 50028
// break ;
50026: GO 50104
// if GetClass ( i ) = 3 then
50028: LD_VAR 0 3
50032: PPUSH
50033: CALL_OW 257
50037: PUSH
50038: LD_INT 3
50040: EQUAL
50041: IFFALSE 50045
// continue ;
50043: GO 50011
// p := Insert ( p , p + 1 , sort [ i ] ) ;
50045: LD_ADDR_VAR 0 11
50049: PUSH
50050: LD_VAR 0 11
50054: PPUSH
50055: LD_VAR 0 11
50059: PUSH
50060: LD_INT 1
50062: PLUS
50063: PPUSH
50064: LD_VAR 0 9
50068: PUSH
50069: LD_VAR 0 3
50073: ARRAY
50074: PPUSH
50075: CALL_OW 2
50079: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
50080: LD_ADDR_VAR 0 4
50084: PUSH
50085: LD_VAR 0 4
50089: PUSH
50090: LD_VAR 0 9
50094: PUSH
50095: LD_VAR 0 3
50099: ARRAY
50100: DIFF
50101: ST_TO_ADDR
// end ;
50102: GO 50011
50104: POP
50105: POP
// if p then
50106: LD_VAR 0 11
50110: IFFALSE 50135
// result := Replace ( result , 3 , p ) ;
50112: LD_ADDR_VAR 0 2
50116: PUSH
50117: LD_VAR 0 2
50121: PPUSH
50122: LD_INT 3
50124: PPUSH
50125: LD_VAR 0 11
50129: PPUSH
50130: CALL_OW 1
50134: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
50135: LD_ADDR_VAR 0 4
50139: PUSH
50140: LD_VAR 0 4
50144: PUSH
50145: LD_VAR 0 6
50149: DIFF
50150: ST_TO_ADDR
// if tmp and eng < 4 then
50151: LD_VAR 0 4
50155: PUSH
50156: LD_VAR 0 6
50160: PUSH
50161: LD_INT 4
50163: LESS
50164: AND
50165: IFFALSE 50355
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
50167: LD_ADDR_VAR 0 9
50171: PUSH
50172: LD_VAR 0 4
50176: PUSH
50177: LD_VAR 0 7
50181: PUSH
50182: LD_VAR 0 6
50186: UNION
50187: DIFF
50188: PPUSH
50189: LD_INT 2
50191: PPUSH
50192: CALL 39309 0 2
50196: ST_TO_ADDR
// p := [ ] ;
50197: LD_ADDR_VAR 0 11
50201: PUSH
50202: EMPTY
50203: ST_TO_ADDR
// if sort then
50204: LD_VAR 0 9
50208: IFFALSE 50324
// for i = 1 to 4 - eng do
50210: LD_ADDR_VAR 0 3
50214: PUSH
50215: DOUBLE
50216: LD_INT 1
50218: DEC
50219: ST_TO_ADDR
50220: LD_INT 4
50222: PUSH
50223: LD_VAR 0 6
50227: MINUS
50228: PUSH
50229: FOR_TO
50230: IFFALSE 50322
// begin if i = sort then
50232: LD_VAR 0 3
50236: PUSH
50237: LD_VAR 0 9
50241: EQUAL
50242: IFFALSE 50246
// break ;
50244: GO 50322
// if GetClass ( i ) = 2 then
50246: LD_VAR 0 3
50250: PPUSH
50251: CALL_OW 257
50255: PUSH
50256: LD_INT 2
50258: EQUAL
50259: IFFALSE 50263
// continue ;
50261: GO 50229
// p := Insert ( p , p + 1 , sort [ i ] ) ;
50263: LD_ADDR_VAR 0 11
50267: PUSH
50268: LD_VAR 0 11
50272: PPUSH
50273: LD_VAR 0 11
50277: PUSH
50278: LD_INT 1
50280: PLUS
50281: PPUSH
50282: LD_VAR 0 9
50286: PUSH
50287: LD_VAR 0 3
50291: ARRAY
50292: PPUSH
50293: CALL_OW 2
50297: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
50298: LD_ADDR_VAR 0 4
50302: PUSH
50303: LD_VAR 0 4
50307: PUSH
50308: LD_VAR 0 9
50312: PUSH
50313: LD_VAR 0 3
50317: ARRAY
50318: DIFF
50319: ST_TO_ADDR
// end ;
50320: GO 50229
50322: POP
50323: POP
// if p then
50324: LD_VAR 0 11
50328: IFFALSE 50353
// result := Replace ( result , 2 , p ) ;
50330: LD_ADDR_VAR 0 2
50334: PUSH
50335: LD_VAR 0 2
50339: PPUSH
50340: LD_INT 2
50342: PPUSH
50343: LD_VAR 0 11
50347: PPUSH
50348: CALL_OW 1
50352: ST_TO_ADDR
// end else
50353: GO 50399
// for i = eng downto 5 do
50355: LD_ADDR_VAR 0 3
50359: PUSH
50360: DOUBLE
50361: LD_VAR 0 6
50365: INC
50366: ST_TO_ADDR
50367: LD_INT 5
50369: PUSH
50370: FOR_DOWNTO
50371: IFFALSE 50397
// tmp := tmp union eng [ i ] ;
50373: LD_ADDR_VAR 0 4
50377: PUSH
50378: LD_VAR 0 4
50382: PUSH
50383: LD_VAR 0 6
50387: PUSH
50388: LD_VAR 0 3
50392: ARRAY
50393: UNION
50394: ST_TO_ADDR
50395: GO 50370
50397: POP
50398: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
50399: LD_ADDR_VAR 0 2
50403: PUSH
50404: LD_VAR 0 2
50408: PPUSH
50409: LD_INT 1
50411: PPUSH
50412: LD_VAR 0 4
50416: PUSH
50417: LD_VAR 0 5
50421: DIFF
50422: PPUSH
50423: CALL_OW 1
50427: ST_TO_ADDR
// exit ;
50428: GO 50430
// end ; end ;
50430: LD_VAR 0 2
50434: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
50435: LD_INT 0
50437: PPUSH
50438: PPUSH
50439: PPUSH
// if not mc_bases then
50440: LD_EXP 14
50444: NOT
50445: IFFALSE 50449
// exit ;
50447: GO 50555
// for i = 1 to mc_bases do
50449: LD_ADDR_VAR 0 2
50453: PUSH
50454: DOUBLE
50455: LD_INT 1
50457: DEC
50458: ST_TO_ADDR
50459: LD_EXP 14
50463: PUSH
50464: FOR_TO
50465: IFFALSE 50546
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
50467: LD_ADDR_VAR 0 3
50471: PUSH
50472: LD_EXP 14
50476: PUSH
50477: LD_VAR 0 2
50481: ARRAY
50482: PPUSH
50483: LD_INT 21
50485: PUSH
50486: LD_INT 3
50488: PUSH
50489: EMPTY
50490: LIST
50491: LIST
50492: PUSH
50493: LD_INT 3
50495: PUSH
50496: LD_INT 24
50498: PUSH
50499: LD_INT 1000
50501: PUSH
50502: EMPTY
50503: LIST
50504: LIST
50505: PUSH
50506: EMPTY
50507: LIST
50508: LIST
50509: PUSH
50510: EMPTY
50511: LIST
50512: LIST
50513: PPUSH
50514: CALL_OW 72
50518: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
50519: LD_ADDR_EXP 15
50523: PUSH
50524: LD_EXP 15
50528: PPUSH
50529: LD_VAR 0 2
50533: PPUSH
50534: LD_VAR 0 3
50538: PPUSH
50539: CALL_OW 1
50543: ST_TO_ADDR
// end ;
50544: GO 50464
50546: POP
50547: POP
// RaiseSailEvent ( 101 ) ;
50548: LD_INT 101
50550: PPUSH
50551: CALL_OW 427
// end ;
50555: LD_VAR 0 1
50559: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
50560: LD_INT 0
50562: PPUSH
50563: PPUSH
50564: PPUSH
50565: PPUSH
50566: PPUSH
50567: PPUSH
50568: PPUSH
// if not mc_bases then
50569: LD_EXP 14
50573: NOT
50574: IFFALSE 50578
// exit ;
50576: GO 51140
// for i = 1 to mc_bases do
50578: LD_ADDR_VAR 0 2
50582: PUSH
50583: DOUBLE
50584: LD_INT 1
50586: DEC
50587: ST_TO_ADDR
50588: LD_EXP 14
50592: PUSH
50593: FOR_TO
50594: IFFALSE 51131
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
50596: LD_ADDR_VAR 0 5
50600: PUSH
50601: LD_EXP 14
50605: PUSH
50606: LD_VAR 0 2
50610: ARRAY
50611: PUSH
50612: LD_EXP 43
50616: PUSH
50617: LD_VAR 0 2
50621: ARRAY
50622: UNION
50623: PPUSH
50624: LD_INT 21
50626: PUSH
50627: LD_INT 1
50629: PUSH
50630: EMPTY
50631: LIST
50632: LIST
50633: PUSH
50634: LD_INT 1
50636: PUSH
50637: LD_INT 3
50639: PUSH
50640: LD_INT 54
50642: PUSH
50643: EMPTY
50644: LIST
50645: PUSH
50646: EMPTY
50647: LIST
50648: LIST
50649: PUSH
50650: LD_INT 3
50652: PUSH
50653: LD_INT 24
50655: PUSH
50656: LD_INT 1000
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: LIST
50671: PUSH
50672: EMPTY
50673: LIST
50674: LIST
50675: PPUSH
50676: CALL_OW 72
50680: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
50681: LD_ADDR_VAR 0 6
50685: PUSH
50686: LD_EXP 14
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: PPUSH
50697: LD_INT 21
50699: PUSH
50700: LD_INT 1
50702: PUSH
50703: EMPTY
50704: LIST
50705: LIST
50706: PUSH
50707: LD_INT 1
50709: PUSH
50710: LD_INT 3
50712: PUSH
50713: LD_INT 54
50715: PUSH
50716: EMPTY
50717: LIST
50718: PUSH
50719: EMPTY
50720: LIST
50721: LIST
50722: PUSH
50723: LD_INT 3
50725: PUSH
50726: LD_INT 24
50728: PUSH
50729: LD_INT 250
50731: PUSH
50732: EMPTY
50733: LIST
50734: LIST
50735: PUSH
50736: EMPTY
50737: LIST
50738: LIST
50739: PUSH
50740: EMPTY
50741: LIST
50742: LIST
50743: LIST
50744: PUSH
50745: EMPTY
50746: LIST
50747: LIST
50748: PPUSH
50749: CALL_OW 72
50753: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
50754: LD_ADDR_VAR 0 7
50758: PUSH
50759: LD_VAR 0 5
50763: PUSH
50764: LD_VAR 0 6
50768: DIFF
50769: ST_TO_ADDR
// if not need_heal_1 then
50770: LD_VAR 0 6
50774: NOT
50775: IFFALSE 50808
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
50777: LD_ADDR_EXP 17
50781: PUSH
50782: LD_EXP 17
50786: PPUSH
50787: LD_VAR 0 2
50791: PUSH
50792: LD_INT 1
50794: PUSH
50795: EMPTY
50796: LIST
50797: LIST
50798: PPUSH
50799: EMPTY
50800: PPUSH
50801: CALL 9427 0 3
50805: ST_TO_ADDR
50806: GO 50878
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
50808: LD_ADDR_EXP 17
50812: PUSH
50813: LD_EXP 17
50817: PPUSH
50818: LD_VAR 0 2
50822: PUSH
50823: LD_INT 1
50825: PUSH
50826: EMPTY
50827: LIST
50828: LIST
50829: PPUSH
50830: LD_EXP 17
50834: PUSH
50835: LD_VAR 0 2
50839: ARRAY
50840: PUSH
50841: LD_INT 1
50843: ARRAY
50844: PPUSH
50845: LD_INT 3
50847: PUSH
50848: LD_INT 24
50850: PUSH
50851: LD_INT 1000
50853: PUSH
50854: EMPTY
50855: LIST
50856: LIST
50857: PUSH
50858: EMPTY
50859: LIST
50860: LIST
50861: PPUSH
50862: CALL_OW 72
50866: PUSH
50867: LD_VAR 0 6
50871: UNION
50872: PPUSH
50873: CALL 9427 0 3
50877: ST_TO_ADDR
// if not need_heal_2 then
50878: LD_VAR 0 7
50882: NOT
50883: IFFALSE 50916
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
50885: LD_ADDR_EXP 17
50889: PUSH
50890: LD_EXP 17
50894: PPUSH
50895: LD_VAR 0 2
50899: PUSH
50900: LD_INT 2
50902: PUSH
50903: EMPTY
50904: LIST
50905: LIST
50906: PPUSH
50907: EMPTY
50908: PPUSH
50909: CALL 9427 0 3
50913: ST_TO_ADDR
50914: GO 50948
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
50916: LD_ADDR_EXP 17
50920: PUSH
50921: LD_EXP 17
50925: PPUSH
50926: LD_VAR 0 2
50930: PUSH
50931: LD_INT 2
50933: PUSH
50934: EMPTY
50935: LIST
50936: LIST
50937: PPUSH
50938: LD_VAR 0 7
50942: PPUSH
50943: CALL 9427 0 3
50947: ST_TO_ADDR
// if need_heal_2 then
50948: LD_VAR 0 7
50952: IFFALSE 51113
// for j in need_heal_2 do
50954: LD_ADDR_VAR 0 3
50958: PUSH
50959: LD_VAR 0 7
50963: PUSH
50964: FOR_IN
50965: IFFALSE 51111
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50967: LD_ADDR_VAR 0 5
50971: PUSH
50972: LD_EXP 14
50976: PUSH
50977: LD_VAR 0 2
50981: ARRAY
50982: PPUSH
50983: LD_INT 2
50985: PUSH
50986: LD_INT 30
50988: PUSH
50989: LD_INT 6
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: PUSH
50996: LD_INT 30
50998: PUSH
50999: LD_INT 7
51001: PUSH
51002: EMPTY
51003: LIST
51004: LIST
51005: PUSH
51006: LD_INT 30
51008: PUSH
51009: LD_INT 8
51011: PUSH
51012: EMPTY
51013: LIST
51014: LIST
51015: PUSH
51016: LD_INT 30
51018: PUSH
51019: LD_INT 0
51021: PUSH
51022: EMPTY
51023: LIST
51024: LIST
51025: PUSH
51026: LD_INT 30
51028: PUSH
51029: LD_INT 1
51031: PUSH
51032: EMPTY
51033: LIST
51034: LIST
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: LIST
51043: PPUSH
51044: CALL_OW 72
51048: ST_TO_ADDR
// if tmp then
51049: LD_VAR 0 5
51053: IFFALSE 51109
// begin k := NearestUnitToUnit ( tmp , j ) ;
51055: LD_ADDR_VAR 0 4
51059: PUSH
51060: LD_VAR 0 5
51064: PPUSH
51065: LD_VAR 0 3
51069: PPUSH
51070: CALL_OW 74
51074: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
51075: LD_VAR 0 3
51079: PPUSH
51080: LD_VAR 0 4
51084: PPUSH
51085: CALL_OW 296
51089: PUSH
51090: LD_INT 5
51092: GREATER
51093: IFFALSE 51109
// ComMoveToNearbyEntrance ( j , k ) ;
51095: LD_VAR 0 3
51099: PPUSH
51100: LD_VAR 0 4
51104: PPUSH
51105: CALL 41670 0 2
// end ; end ;
51109: GO 50964
51111: POP
51112: POP
// if not need_heal_1 and not need_heal_2 then
51113: LD_VAR 0 6
51117: NOT
51118: PUSH
51119: LD_VAR 0 7
51123: NOT
51124: AND
51125: IFFALSE 51129
// continue ;
51127: GO 50593
// end ;
51129: GO 50593
51131: POP
51132: POP
// RaiseSailEvent ( 102 ) ;
51133: LD_INT 102
51135: PPUSH
51136: CALL_OW 427
// end ;
51140: LD_VAR 0 1
51144: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
51145: LD_INT 0
51147: PPUSH
51148: PPUSH
51149: PPUSH
51150: PPUSH
51151: PPUSH
51152: PPUSH
51153: PPUSH
51154: PPUSH
// if not mc_bases then
51155: LD_EXP 14
51159: NOT
51160: IFFALSE 51164
// exit ;
51162: GO 52025
// for i = 1 to mc_bases do
51164: LD_ADDR_VAR 0 2
51168: PUSH
51169: DOUBLE
51170: LD_INT 1
51172: DEC
51173: ST_TO_ADDR
51174: LD_EXP 14
51178: PUSH
51179: FOR_TO
51180: IFFALSE 52023
// begin if not mc_building_need_repair [ i ] then
51182: LD_EXP 15
51186: PUSH
51187: LD_VAR 0 2
51191: ARRAY
51192: NOT
51193: IFFALSE 51380
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
51195: LD_ADDR_VAR 0 6
51199: PUSH
51200: LD_EXP 33
51204: PUSH
51205: LD_VAR 0 2
51209: ARRAY
51210: PPUSH
51211: LD_INT 3
51213: PUSH
51214: LD_INT 24
51216: PUSH
51217: LD_INT 1000
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: EMPTY
51225: LIST
51226: LIST
51227: PUSH
51228: LD_INT 2
51230: PUSH
51231: LD_INT 34
51233: PUSH
51234: LD_INT 13
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PUSH
51241: LD_INT 34
51243: PUSH
51244: LD_INT 52
51246: PUSH
51247: EMPTY
51248: LIST
51249: LIST
51250: PUSH
51251: LD_INT 34
51253: PUSH
51254: LD_EXP 64
51258: PUSH
51259: EMPTY
51260: LIST
51261: LIST
51262: PUSH
51263: EMPTY
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: PUSH
51269: EMPTY
51270: LIST
51271: LIST
51272: PPUSH
51273: CALL_OW 72
51277: ST_TO_ADDR
// if cranes then
51278: LD_VAR 0 6
51282: IFFALSE 51344
// for j in cranes do
51284: LD_ADDR_VAR 0 3
51288: PUSH
51289: LD_VAR 0 6
51293: PUSH
51294: FOR_IN
51295: IFFALSE 51342
// if not IsInArea ( j , mc_parking [ i ] ) then
51297: LD_VAR 0 3
51301: PPUSH
51302: LD_EXP 38
51306: PUSH
51307: LD_VAR 0 2
51311: ARRAY
51312: PPUSH
51313: CALL_OW 308
51317: NOT
51318: IFFALSE 51340
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51320: LD_VAR 0 3
51324: PPUSH
51325: LD_EXP 38
51329: PUSH
51330: LD_VAR 0 2
51334: ARRAY
51335: PPUSH
51336: CALL_OW 113
51340: GO 51294
51342: POP
51343: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
51344: LD_ADDR_EXP 16
51348: PUSH
51349: LD_EXP 16
51353: PPUSH
51354: LD_VAR 0 2
51358: PPUSH
51359: EMPTY
51360: PPUSH
51361: CALL_OW 1
51365: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
51366: LD_VAR 0 2
51370: PPUSH
51371: LD_INT 101
51373: PPUSH
51374: CALL 46268 0 2
// continue ;
51378: GO 51179
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
51380: LD_ADDR_EXP 20
51384: PUSH
51385: LD_EXP 20
51389: PPUSH
51390: LD_VAR 0 2
51394: PPUSH
51395: EMPTY
51396: PPUSH
51397: CALL_OW 1
51401: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
51402: LD_VAR 0 2
51406: PPUSH
51407: LD_INT 103
51409: PPUSH
51410: CALL 46268 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
51414: LD_ADDR_VAR 0 5
51418: PUSH
51419: LD_EXP 14
51423: PUSH
51424: LD_VAR 0 2
51428: ARRAY
51429: PUSH
51430: LD_EXP 43
51434: PUSH
51435: LD_VAR 0 2
51439: ARRAY
51440: UNION
51441: PPUSH
51442: LD_INT 2
51444: PUSH
51445: LD_INT 25
51447: PUSH
51448: LD_INT 2
51450: PUSH
51451: EMPTY
51452: LIST
51453: LIST
51454: PUSH
51455: LD_INT 25
51457: PUSH
51458: LD_INT 16
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: EMPTY
51466: LIST
51467: LIST
51468: LIST
51469: PUSH
51470: EMPTY
51471: LIST
51472: PPUSH
51473: CALL_OW 72
51477: PUSH
51478: LD_EXP 17
51482: PUSH
51483: LD_VAR 0 2
51487: ARRAY
51488: PUSH
51489: LD_INT 1
51491: ARRAY
51492: PUSH
51493: LD_EXP 17
51497: PUSH
51498: LD_VAR 0 2
51502: ARRAY
51503: PUSH
51504: LD_INT 2
51506: ARRAY
51507: UNION
51508: DIFF
51509: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
51510: LD_ADDR_VAR 0 6
51514: PUSH
51515: LD_EXP 33
51519: PUSH
51520: LD_VAR 0 2
51524: ARRAY
51525: PPUSH
51526: LD_INT 2
51528: PUSH
51529: LD_INT 34
51531: PUSH
51532: LD_INT 13
51534: PUSH
51535: EMPTY
51536: LIST
51537: LIST
51538: PUSH
51539: LD_INT 34
51541: PUSH
51542: LD_INT 52
51544: PUSH
51545: EMPTY
51546: LIST
51547: LIST
51548: PUSH
51549: LD_INT 34
51551: PUSH
51552: LD_EXP 64
51556: PUSH
51557: EMPTY
51558: LIST
51559: LIST
51560: PUSH
51561: EMPTY
51562: LIST
51563: LIST
51564: LIST
51565: LIST
51566: PPUSH
51567: CALL_OW 72
51571: ST_TO_ADDR
// if cranes then
51572: LD_VAR 0 6
51576: IFFALSE 51712
// begin for j in cranes do
51578: LD_ADDR_VAR 0 3
51582: PUSH
51583: LD_VAR 0 6
51587: PUSH
51588: FOR_IN
51589: IFFALSE 51710
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
51591: LD_VAR 0 3
51595: PPUSH
51596: CALL_OW 256
51600: PUSH
51601: LD_INT 1000
51603: EQUAL
51604: PUSH
51605: LD_VAR 0 3
51609: PPUSH
51610: CALL_OW 314
51614: NOT
51615: AND
51616: IFFALSE 51650
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
51618: LD_VAR 0 3
51622: PPUSH
51623: LD_EXP 15
51627: PUSH
51628: LD_VAR 0 2
51632: ARRAY
51633: PPUSH
51634: LD_VAR 0 3
51638: PPUSH
51639: CALL_OW 74
51643: PPUSH
51644: CALL_OW 130
51648: GO 51708
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
51650: LD_VAR 0 3
51654: PPUSH
51655: CALL_OW 256
51659: PUSH
51660: LD_INT 500
51662: LESS
51663: PUSH
51664: LD_VAR 0 3
51668: PPUSH
51669: LD_EXP 38
51673: PUSH
51674: LD_VAR 0 2
51678: ARRAY
51679: PPUSH
51680: CALL_OW 308
51684: NOT
51685: AND
51686: IFFALSE 51708
// ComMoveToArea ( j , mc_parking [ i ] ) ;
51688: LD_VAR 0 3
51692: PPUSH
51693: LD_EXP 38
51697: PUSH
51698: LD_VAR 0 2
51702: ARRAY
51703: PPUSH
51704: CALL_OW 113
// end ;
51708: GO 51588
51710: POP
51711: POP
// end ; if tmp > 3 then
51712: LD_VAR 0 5
51716: PUSH
51717: LD_INT 3
51719: GREATER
51720: IFFALSE 51740
// tmp := ShrinkArray ( tmp , 4 ) ;
51722: LD_ADDR_VAR 0 5
51726: PUSH
51727: LD_VAR 0 5
51731: PPUSH
51732: LD_INT 4
51734: PPUSH
51735: CALL 41118 0 2
51739: ST_TO_ADDR
// if not tmp then
51740: LD_VAR 0 5
51744: NOT
51745: IFFALSE 51749
// continue ;
51747: GO 51179
// for j in tmp do
51749: LD_ADDR_VAR 0 3
51753: PUSH
51754: LD_VAR 0 5
51758: PUSH
51759: FOR_IN
51760: IFFALSE 52019
// begin if IsInUnit ( j ) then
51762: LD_VAR 0 3
51766: PPUSH
51767: CALL_OW 310
51771: IFFALSE 51782
// ComExitBuilding ( j ) ;
51773: LD_VAR 0 3
51777: PPUSH
51778: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
51782: LD_VAR 0 3
51786: PUSH
51787: LD_EXP 16
51791: PUSH
51792: LD_VAR 0 2
51796: ARRAY
51797: IN
51798: NOT
51799: IFFALSE 51857
// begin SetTag ( j , 101 ) ;
51801: LD_VAR 0 3
51805: PPUSH
51806: LD_INT 101
51808: PPUSH
51809: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
51813: LD_ADDR_EXP 16
51817: PUSH
51818: LD_EXP 16
51822: PPUSH
51823: LD_VAR 0 2
51827: PUSH
51828: LD_EXP 16
51832: PUSH
51833: LD_VAR 0 2
51837: ARRAY
51838: PUSH
51839: LD_INT 1
51841: PLUS
51842: PUSH
51843: EMPTY
51844: LIST
51845: LIST
51846: PPUSH
51847: LD_VAR 0 3
51851: PPUSH
51852: CALL 9427 0 3
51856: ST_TO_ADDR
// end ; wait ( 1 ) ;
51857: LD_INT 1
51859: PPUSH
51860: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
51864: LD_ADDR_VAR 0 7
51868: PUSH
51869: LD_EXP 15
51873: PUSH
51874: LD_VAR 0 2
51878: ARRAY
51879: ST_TO_ADDR
// if mc_scan [ i ] then
51880: LD_EXP 37
51884: PUSH
51885: LD_VAR 0 2
51889: ARRAY
51890: IFFALSE 51952
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
51892: LD_ADDR_VAR 0 7
51896: PUSH
51897: LD_EXP 15
51901: PUSH
51902: LD_VAR 0 2
51906: ARRAY
51907: PPUSH
51908: LD_INT 3
51910: PUSH
51911: LD_INT 30
51913: PUSH
51914: LD_INT 32
51916: PUSH
51917: EMPTY
51918: LIST
51919: LIST
51920: PUSH
51921: LD_INT 30
51923: PUSH
51924: LD_INT 33
51926: PUSH
51927: EMPTY
51928: LIST
51929: LIST
51930: PUSH
51931: LD_INT 30
51933: PUSH
51934: LD_INT 31
51936: PUSH
51937: EMPTY
51938: LIST
51939: LIST
51940: PUSH
51941: EMPTY
51942: LIST
51943: LIST
51944: LIST
51945: LIST
51946: PPUSH
51947: CALL_OW 72
51951: ST_TO_ADDR
// if not to_repair_tmp then
51952: LD_VAR 0 7
51956: NOT
51957: IFFALSE 51961
// continue ;
51959: GO 51759
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
51961: LD_ADDR_VAR 0 8
51965: PUSH
51966: LD_VAR 0 7
51970: PPUSH
51971: LD_VAR 0 3
51975: PPUSH
51976: CALL_OW 74
51980: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
51981: LD_VAR 0 8
51985: PPUSH
51986: LD_INT 16
51988: PPUSH
51989: CALL 12020 0 2
51993: PUSH
51994: LD_INT 4
51996: ARRAY
51997: PUSH
51998: LD_INT 10
52000: LESS
52001: IFFALSE 52017
// ComRepairBuilding ( j , to_repair ) ;
52003: LD_VAR 0 3
52007: PPUSH
52008: LD_VAR 0 8
52012: PPUSH
52013: CALL_OW 130
// end ;
52017: GO 51759
52019: POP
52020: POP
// end ;
52021: GO 51179
52023: POP
52024: POP
// end ;
52025: LD_VAR 0 1
52029: RET
// export function MC_Heal ; var i , j , tmp ; begin
52030: LD_INT 0
52032: PPUSH
52033: PPUSH
52034: PPUSH
52035: PPUSH
// if not mc_bases then
52036: LD_EXP 14
52040: NOT
52041: IFFALSE 52045
// exit ;
52043: GO 52447
// for i = 1 to mc_bases do
52045: LD_ADDR_VAR 0 2
52049: PUSH
52050: DOUBLE
52051: LD_INT 1
52053: DEC
52054: ST_TO_ADDR
52055: LD_EXP 14
52059: PUSH
52060: FOR_TO
52061: IFFALSE 52445
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
52063: LD_EXP 17
52067: PUSH
52068: LD_VAR 0 2
52072: ARRAY
52073: PUSH
52074: LD_INT 1
52076: ARRAY
52077: NOT
52078: PUSH
52079: LD_EXP 17
52083: PUSH
52084: LD_VAR 0 2
52088: ARRAY
52089: PUSH
52090: LD_INT 2
52092: ARRAY
52093: NOT
52094: AND
52095: IFFALSE 52133
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
52097: LD_ADDR_EXP 18
52101: PUSH
52102: LD_EXP 18
52106: PPUSH
52107: LD_VAR 0 2
52111: PPUSH
52112: EMPTY
52113: PPUSH
52114: CALL_OW 1
52118: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
52119: LD_VAR 0 2
52123: PPUSH
52124: LD_INT 102
52126: PPUSH
52127: CALL 46268 0 2
// continue ;
52131: GO 52060
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
52133: LD_ADDR_VAR 0 4
52137: PUSH
52138: LD_EXP 14
52142: PUSH
52143: LD_VAR 0 2
52147: ARRAY
52148: PPUSH
52149: LD_INT 25
52151: PUSH
52152: LD_INT 4
52154: PUSH
52155: EMPTY
52156: LIST
52157: LIST
52158: PPUSH
52159: CALL_OW 72
52163: ST_TO_ADDR
// if not tmp then
52164: LD_VAR 0 4
52168: NOT
52169: IFFALSE 52173
// continue ;
52171: GO 52060
// if mc_taming [ i ] then
52173: LD_EXP 45
52177: PUSH
52178: LD_VAR 0 2
52182: ARRAY
52183: IFFALSE 52207
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52185: LD_ADDR_EXP 45
52189: PUSH
52190: LD_EXP 45
52194: PPUSH
52195: LD_VAR 0 2
52199: PPUSH
52200: EMPTY
52201: PPUSH
52202: CALL_OW 1
52206: ST_TO_ADDR
// for j in tmp do
52207: LD_ADDR_VAR 0 3
52211: PUSH
52212: LD_VAR 0 4
52216: PUSH
52217: FOR_IN
52218: IFFALSE 52441
// begin if IsInUnit ( j ) then
52220: LD_VAR 0 3
52224: PPUSH
52225: CALL_OW 310
52229: IFFALSE 52240
// ComExitBuilding ( j ) ;
52231: LD_VAR 0 3
52235: PPUSH
52236: CALL_OW 122
// if not j in mc_healers [ i ] then
52240: LD_VAR 0 3
52244: PUSH
52245: LD_EXP 18
52249: PUSH
52250: LD_VAR 0 2
52254: ARRAY
52255: IN
52256: NOT
52257: IFFALSE 52303
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
52259: LD_ADDR_EXP 18
52263: PUSH
52264: LD_EXP 18
52268: PPUSH
52269: LD_VAR 0 2
52273: PUSH
52274: LD_EXP 18
52278: PUSH
52279: LD_VAR 0 2
52283: ARRAY
52284: PUSH
52285: LD_INT 1
52287: PLUS
52288: PUSH
52289: EMPTY
52290: LIST
52291: LIST
52292: PPUSH
52293: LD_VAR 0 3
52297: PPUSH
52298: CALL 9427 0 3
52302: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
52303: LD_VAR 0 3
52307: PPUSH
52308: CALL_OW 110
52312: PUSH
52313: LD_INT 102
52315: NONEQUAL
52316: IFFALSE 52330
// SetTag ( j , 102 ) ;
52318: LD_VAR 0 3
52322: PPUSH
52323: LD_INT 102
52325: PPUSH
52326: CALL_OW 109
// Wait ( 3 ) ;
52330: LD_INT 3
52332: PPUSH
52333: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
52337: LD_EXP 17
52341: PUSH
52342: LD_VAR 0 2
52346: ARRAY
52347: PUSH
52348: LD_INT 1
52350: ARRAY
52351: IFFALSE 52383
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
52353: LD_VAR 0 3
52357: PPUSH
52358: LD_EXP 17
52362: PUSH
52363: LD_VAR 0 2
52367: ARRAY
52368: PUSH
52369: LD_INT 1
52371: ARRAY
52372: PUSH
52373: LD_INT 1
52375: ARRAY
52376: PPUSH
52377: CALL_OW 128
52381: GO 52439
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
52383: LD_VAR 0 3
52387: PPUSH
52388: CALL_OW 314
52392: NOT
52393: PUSH
52394: LD_EXP 17
52398: PUSH
52399: LD_VAR 0 2
52403: ARRAY
52404: PUSH
52405: LD_INT 2
52407: ARRAY
52408: AND
52409: IFFALSE 52439
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
52411: LD_VAR 0 3
52415: PPUSH
52416: LD_EXP 17
52420: PUSH
52421: LD_VAR 0 2
52425: ARRAY
52426: PUSH
52427: LD_INT 2
52429: ARRAY
52430: PUSH
52431: LD_INT 1
52433: ARRAY
52434: PPUSH
52435: CALL_OW 128
// end ;
52439: GO 52217
52441: POP
52442: POP
// end ;
52443: GO 52060
52445: POP
52446: POP
// end ;
52447: LD_VAR 0 1
52451: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
52452: LD_INT 0
52454: PPUSH
52455: PPUSH
52456: PPUSH
52457: PPUSH
52458: PPUSH
// if not mc_bases then
52459: LD_EXP 14
52463: NOT
52464: IFFALSE 52468
// exit ;
52466: GO 53639
// for i = 1 to mc_bases do
52468: LD_ADDR_VAR 0 2
52472: PUSH
52473: DOUBLE
52474: LD_INT 1
52476: DEC
52477: ST_TO_ADDR
52478: LD_EXP 14
52482: PUSH
52483: FOR_TO
52484: IFFALSE 53637
// begin if mc_scan [ i ] then
52486: LD_EXP 37
52490: PUSH
52491: LD_VAR 0 2
52495: ARRAY
52496: IFFALSE 52500
// continue ;
52498: GO 52483
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
52500: LD_EXP 19
52504: PUSH
52505: LD_VAR 0 2
52509: ARRAY
52510: NOT
52511: PUSH
52512: LD_EXP 21
52516: PUSH
52517: LD_VAR 0 2
52521: ARRAY
52522: NOT
52523: AND
52524: PUSH
52525: LD_EXP 20
52529: PUSH
52530: LD_VAR 0 2
52534: ARRAY
52535: AND
52536: IFFALSE 52574
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
52538: LD_ADDR_EXP 20
52542: PUSH
52543: LD_EXP 20
52547: PPUSH
52548: LD_VAR 0 2
52552: PPUSH
52553: EMPTY
52554: PPUSH
52555: CALL_OW 1
52559: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
52560: LD_VAR 0 2
52564: PPUSH
52565: LD_INT 103
52567: PPUSH
52568: CALL 46268 0 2
// continue ;
52572: GO 52483
// end ; if mc_construct_list [ i ] then
52574: LD_EXP 21
52578: PUSH
52579: LD_VAR 0 2
52583: ARRAY
52584: IFFALSE 52804
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
52586: LD_ADDR_VAR 0 4
52590: PUSH
52591: LD_EXP 14
52595: PUSH
52596: LD_VAR 0 2
52600: ARRAY
52601: PPUSH
52602: LD_INT 25
52604: PUSH
52605: LD_INT 2
52607: PUSH
52608: EMPTY
52609: LIST
52610: LIST
52611: PPUSH
52612: CALL_OW 72
52616: PUSH
52617: LD_EXP 16
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: DIFF
52628: ST_TO_ADDR
// if not tmp then
52629: LD_VAR 0 4
52633: NOT
52634: IFFALSE 52638
// continue ;
52636: GO 52483
// for j in tmp do
52638: LD_ADDR_VAR 0 3
52642: PUSH
52643: LD_VAR 0 4
52647: PUSH
52648: FOR_IN
52649: IFFALSE 52800
// begin if not mc_builders [ i ] then
52651: LD_EXP 20
52655: PUSH
52656: LD_VAR 0 2
52660: ARRAY
52661: NOT
52662: IFFALSE 52720
// begin SetTag ( j , 103 ) ;
52664: LD_VAR 0 3
52668: PPUSH
52669: LD_INT 103
52671: PPUSH
52672: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
52676: LD_ADDR_EXP 20
52680: PUSH
52681: LD_EXP 20
52685: PPUSH
52686: LD_VAR 0 2
52690: PUSH
52691: LD_EXP 20
52695: PUSH
52696: LD_VAR 0 2
52700: ARRAY
52701: PUSH
52702: LD_INT 1
52704: PLUS
52705: PUSH
52706: EMPTY
52707: LIST
52708: LIST
52709: PPUSH
52710: LD_VAR 0 3
52714: PPUSH
52715: CALL 9427 0 3
52719: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
52720: LD_VAR 0 3
52724: PPUSH
52725: CALL_OW 310
52729: IFFALSE 52740
// ComExitBuilding ( j ) ;
52731: LD_VAR 0 3
52735: PPUSH
52736: CALL_OW 122
// wait ( 3 ) ;
52740: LD_INT 3
52742: PPUSH
52743: CALL_OW 67
// if not mc_construct_list [ i ] then
52747: LD_EXP 21
52751: PUSH
52752: LD_VAR 0 2
52756: ARRAY
52757: NOT
52758: IFFALSE 52762
// break ;
52760: GO 52800
// if not HasTask ( j ) then
52762: LD_VAR 0 3
52766: PPUSH
52767: CALL_OW 314
52771: NOT
52772: IFFALSE 52798
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
52774: LD_VAR 0 3
52778: PPUSH
52779: LD_EXP 21
52783: PUSH
52784: LD_VAR 0 2
52788: ARRAY
52789: PUSH
52790: LD_INT 1
52792: ARRAY
52793: PPUSH
52794: CALL 12284 0 2
// end ;
52798: GO 52648
52800: POP
52801: POP
// end else
52802: GO 53635
// if mc_build_list [ i ] then
52804: LD_EXP 19
52808: PUSH
52809: LD_VAR 0 2
52813: ARRAY
52814: IFFALSE 53635
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52816: LD_ADDR_VAR 0 5
52820: PUSH
52821: LD_EXP 14
52825: PUSH
52826: LD_VAR 0 2
52830: ARRAY
52831: PPUSH
52832: LD_INT 2
52834: PUSH
52835: LD_INT 30
52837: PUSH
52838: LD_INT 0
52840: PUSH
52841: EMPTY
52842: LIST
52843: LIST
52844: PUSH
52845: LD_INT 30
52847: PUSH
52848: LD_INT 1
52850: PUSH
52851: EMPTY
52852: LIST
52853: LIST
52854: PUSH
52855: EMPTY
52856: LIST
52857: LIST
52858: LIST
52859: PPUSH
52860: CALL_OW 72
52864: ST_TO_ADDR
// if depot then
52865: LD_VAR 0 5
52869: IFFALSE 52887
// depot := depot [ 1 ] else
52871: LD_ADDR_VAR 0 5
52875: PUSH
52876: LD_VAR 0 5
52880: PUSH
52881: LD_INT 1
52883: ARRAY
52884: ST_TO_ADDR
52885: GO 52895
// depot := 0 ;
52887: LD_ADDR_VAR 0 5
52891: PUSH
52892: LD_INT 0
52894: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
52895: LD_EXP 19
52899: PUSH
52900: LD_VAR 0 2
52904: ARRAY
52905: PUSH
52906: LD_INT 1
52908: ARRAY
52909: PUSH
52910: LD_INT 1
52912: ARRAY
52913: PPUSH
52914: CALL 12108 0 1
52918: PUSH
52919: LD_EXP 14
52923: PUSH
52924: LD_VAR 0 2
52928: ARRAY
52929: PPUSH
52930: LD_INT 2
52932: PUSH
52933: LD_INT 30
52935: PUSH
52936: LD_INT 2
52938: PUSH
52939: EMPTY
52940: LIST
52941: LIST
52942: PUSH
52943: LD_INT 30
52945: PUSH
52946: LD_INT 3
52948: PUSH
52949: EMPTY
52950: LIST
52951: LIST
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: LIST
52957: PPUSH
52958: CALL_OW 72
52962: NOT
52963: AND
52964: IFFALSE 53069
// begin for j = 1 to mc_build_list [ i ] do
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: DOUBLE
52972: LD_INT 1
52974: DEC
52975: ST_TO_ADDR
52976: LD_EXP 19
52980: PUSH
52981: LD_VAR 0 2
52985: ARRAY
52986: PUSH
52987: FOR_TO
52988: IFFALSE 53067
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
52990: LD_EXP 19
52994: PUSH
52995: LD_VAR 0 2
52999: ARRAY
53000: PUSH
53001: LD_VAR 0 3
53005: ARRAY
53006: PUSH
53007: LD_INT 1
53009: ARRAY
53010: PUSH
53011: LD_INT 2
53013: EQUAL
53014: IFFALSE 53065
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
53016: LD_ADDR_EXP 19
53020: PUSH
53021: LD_EXP 19
53025: PPUSH
53026: LD_VAR 0 2
53030: PPUSH
53031: LD_EXP 19
53035: PUSH
53036: LD_VAR 0 2
53040: ARRAY
53041: PPUSH
53042: LD_VAR 0 3
53046: PPUSH
53047: LD_INT 1
53049: PPUSH
53050: LD_INT 0
53052: PPUSH
53053: CALL 8845 0 4
53057: PPUSH
53058: CALL_OW 1
53062: ST_TO_ADDR
// break ;
53063: GO 53067
// end ;
53065: GO 52987
53067: POP
53068: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
53069: LD_EXP 19
53073: PUSH
53074: LD_VAR 0 2
53078: ARRAY
53079: PUSH
53080: LD_INT 1
53082: ARRAY
53083: PUSH
53084: LD_INT 1
53086: ARRAY
53087: PUSH
53088: LD_INT 0
53090: EQUAL
53091: PUSH
53092: LD_VAR 0 5
53096: PUSH
53097: LD_VAR 0 5
53101: PPUSH
53102: LD_EXP 19
53106: PUSH
53107: LD_VAR 0 2
53111: ARRAY
53112: PUSH
53113: LD_INT 1
53115: ARRAY
53116: PUSH
53117: LD_INT 1
53119: ARRAY
53120: PPUSH
53121: LD_EXP 19
53125: PUSH
53126: LD_VAR 0 2
53130: ARRAY
53131: PUSH
53132: LD_INT 1
53134: ARRAY
53135: PUSH
53136: LD_INT 2
53138: ARRAY
53139: PPUSH
53140: LD_EXP 19
53144: PUSH
53145: LD_VAR 0 2
53149: ARRAY
53150: PUSH
53151: LD_INT 1
53153: ARRAY
53154: PUSH
53155: LD_INT 3
53157: ARRAY
53158: PPUSH
53159: LD_EXP 19
53163: PUSH
53164: LD_VAR 0 2
53168: ARRAY
53169: PUSH
53170: LD_INT 1
53172: ARRAY
53173: PUSH
53174: LD_INT 4
53176: ARRAY
53177: PPUSH
53178: CALL 17175 0 5
53182: AND
53183: OR
53184: IFFALSE 53465
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
53186: LD_ADDR_VAR 0 4
53190: PUSH
53191: LD_EXP 14
53195: PUSH
53196: LD_VAR 0 2
53200: ARRAY
53201: PPUSH
53202: LD_INT 25
53204: PUSH
53205: LD_INT 2
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PPUSH
53212: CALL_OW 72
53216: PUSH
53217: LD_EXP 16
53221: PUSH
53222: LD_VAR 0 2
53226: ARRAY
53227: DIFF
53228: ST_TO_ADDR
// if not tmp then
53229: LD_VAR 0 4
53233: NOT
53234: IFFALSE 53238
// continue ;
53236: GO 52483
// for j in tmp do
53238: LD_ADDR_VAR 0 3
53242: PUSH
53243: LD_VAR 0 4
53247: PUSH
53248: FOR_IN
53249: IFFALSE 53461
// begin if not mc_builders [ i ] then
53251: LD_EXP 20
53255: PUSH
53256: LD_VAR 0 2
53260: ARRAY
53261: NOT
53262: IFFALSE 53320
// begin SetTag ( j , 103 ) ;
53264: LD_VAR 0 3
53268: PPUSH
53269: LD_INT 103
53271: PPUSH
53272: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
53276: LD_ADDR_EXP 20
53280: PUSH
53281: LD_EXP 20
53285: PPUSH
53286: LD_VAR 0 2
53290: PUSH
53291: LD_EXP 20
53295: PUSH
53296: LD_VAR 0 2
53300: ARRAY
53301: PUSH
53302: LD_INT 1
53304: PLUS
53305: PUSH
53306: EMPTY
53307: LIST
53308: LIST
53309: PPUSH
53310: LD_VAR 0 3
53314: PPUSH
53315: CALL 9427 0 3
53319: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
53320: LD_VAR 0 3
53324: PPUSH
53325: CALL_OW 310
53329: IFFALSE 53340
// ComExitBuilding ( j ) ;
53331: LD_VAR 0 3
53335: PPUSH
53336: CALL_OW 122
// wait ( 3 ) ;
53340: LD_INT 3
53342: PPUSH
53343: CALL_OW 67
// if not mc_build_list [ i ] then
53347: LD_EXP 19
53351: PUSH
53352: LD_VAR 0 2
53356: ARRAY
53357: NOT
53358: IFFALSE 53362
// break ;
53360: GO 53461
// if not HasTask ( j ) then
53362: LD_VAR 0 3
53366: PPUSH
53367: CALL_OW 314
53371: NOT
53372: IFFALSE 53459
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
53374: LD_VAR 0 3
53378: PPUSH
53379: LD_EXP 19
53383: PUSH
53384: LD_VAR 0 2
53388: ARRAY
53389: PUSH
53390: LD_INT 1
53392: ARRAY
53393: PUSH
53394: LD_INT 1
53396: ARRAY
53397: PPUSH
53398: LD_EXP 19
53402: PUSH
53403: LD_VAR 0 2
53407: ARRAY
53408: PUSH
53409: LD_INT 1
53411: ARRAY
53412: PUSH
53413: LD_INT 2
53415: ARRAY
53416: PPUSH
53417: LD_EXP 19
53421: PUSH
53422: LD_VAR 0 2
53426: ARRAY
53427: PUSH
53428: LD_INT 1
53430: ARRAY
53431: PUSH
53432: LD_INT 3
53434: ARRAY
53435: PPUSH
53436: LD_EXP 19
53440: PUSH
53441: LD_VAR 0 2
53445: ARRAY
53446: PUSH
53447: LD_INT 1
53449: ARRAY
53450: PUSH
53451: LD_INT 4
53453: ARRAY
53454: PPUSH
53455: CALL_OW 145
// end ;
53459: GO 53248
53461: POP
53462: POP
// end else
53463: GO 53635
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
53465: LD_EXP 14
53469: PUSH
53470: LD_VAR 0 2
53474: ARRAY
53475: PPUSH
53476: LD_EXP 19
53480: PUSH
53481: LD_VAR 0 2
53485: ARRAY
53486: PUSH
53487: LD_INT 1
53489: ARRAY
53490: PUSH
53491: LD_INT 1
53493: ARRAY
53494: PPUSH
53495: LD_EXP 19
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: PUSH
53506: LD_INT 1
53508: ARRAY
53509: PUSH
53510: LD_INT 2
53512: ARRAY
53513: PPUSH
53514: LD_EXP 19
53518: PUSH
53519: LD_VAR 0 2
53523: ARRAY
53524: PUSH
53525: LD_INT 1
53527: ARRAY
53528: PUSH
53529: LD_INT 3
53531: ARRAY
53532: PPUSH
53533: LD_EXP 19
53537: PUSH
53538: LD_VAR 0 2
53542: ARRAY
53543: PUSH
53544: LD_INT 1
53546: ARRAY
53547: PUSH
53548: LD_INT 4
53550: ARRAY
53551: PPUSH
53552: LD_EXP 14
53556: PUSH
53557: LD_VAR 0 2
53561: ARRAY
53562: PPUSH
53563: LD_INT 21
53565: PUSH
53566: LD_INT 3
53568: PUSH
53569: EMPTY
53570: LIST
53571: LIST
53572: PPUSH
53573: CALL_OW 72
53577: PPUSH
53578: EMPTY
53579: PPUSH
53580: CALL 16305 0 7
53584: NOT
53585: IFFALSE 53635
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
53587: LD_ADDR_EXP 19
53591: PUSH
53592: LD_EXP 19
53596: PPUSH
53597: LD_VAR 0 2
53601: PPUSH
53602: LD_EXP 19
53606: PUSH
53607: LD_VAR 0 2
53611: ARRAY
53612: PPUSH
53613: LD_INT 1
53615: PPUSH
53616: LD_INT 1
53618: NEG
53619: PPUSH
53620: LD_INT 0
53622: PPUSH
53623: CALL 8845 0 4
53627: PPUSH
53628: CALL_OW 1
53632: ST_TO_ADDR
// continue ;
53633: GO 52483
// end ; end ; end ;
53635: GO 52483
53637: POP
53638: POP
// end ;
53639: LD_VAR 0 1
53643: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
53644: LD_INT 0
53646: PPUSH
53647: PPUSH
53648: PPUSH
53649: PPUSH
53650: PPUSH
53651: PPUSH
// if not mc_bases then
53652: LD_EXP 14
53656: NOT
53657: IFFALSE 53661
// exit ;
53659: GO 54088
// for i = 1 to mc_bases do
53661: LD_ADDR_VAR 0 2
53665: PUSH
53666: DOUBLE
53667: LD_INT 1
53669: DEC
53670: ST_TO_ADDR
53671: LD_EXP 14
53675: PUSH
53676: FOR_TO
53677: IFFALSE 54086
// begin tmp := mc_build_upgrade [ i ] ;
53679: LD_ADDR_VAR 0 4
53683: PUSH
53684: LD_EXP 46
53688: PUSH
53689: LD_VAR 0 2
53693: ARRAY
53694: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
53695: LD_ADDR_VAR 0 6
53699: PUSH
53700: LD_EXP 47
53704: PUSH
53705: LD_VAR 0 2
53709: ARRAY
53710: PPUSH
53711: LD_INT 2
53713: PUSH
53714: LD_INT 30
53716: PUSH
53717: LD_INT 6
53719: PUSH
53720: EMPTY
53721: LIST
53722: LIST
53723: PUSH
53724: LD_INT 30
53726: PUSH
53727: LD_INT 7
53729: PUSH
53730: EMPTY
53731: LIST
53732: LIST
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: LIST
53738: PPUSH
53739: CALL_OW 72
53743: ST_TO_ADDR
// if not tmp and not lab then
53744: LD_VAR 0 4
53748: NOT
53749: PUSH
53750: LD_VAR 0 6
53754: NOT
53755: AND
53756: IFFALSE 53760
// continue ;
53758: GO 53676
// if tmp then
53760: LD_VAR 0 4
53764: IFFALSE 53884
// for j in tmp do
53766: LD_ADDR_VAR 0 3
53770: PUSH
53771: LD_VAR 0 4
53775: PUSH
53776: FOR_IN
53777: IFFALSE 53882
// begin if UpgradeCost ( j ) then
53779: LD_VAR 0 3
53783: PPUSH
53784: CALL 15965 0 1
53788: IFFALSE 53880
// begin ComUpgrade ( j ) ;
53790: LD_VAR 0 3
53794: PPUSH
53795: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
53799: LD_ADDR_EXP 46
53803: PUSH
53804: LD_EXP 46
53808: PPUSH
53809: LD_VAR 0 2
53813: PPUSH
53814: LD_EXP 46
53818: PUSH
53819: LD_VAR 0 2
53823: ARRAY
53824: PUSH
53825: LD_VAR 0 3
53829: DIFF
53830: PPUSH
53831: CALL_OW 1
53835: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
53836: LD_ADDR_EXP 21
53840: PUSH
53841: LD_EXP 21
53845: PPUSH
53846: LD_VAR 0 2
53850: PUSH
53851: LD_EXP 21
53855: PUSH
53856: LD_VAR 0 2
53860: ARRAY
53861: PUSH
53862: LD_INT 1
53864: PLUS
53865: PUSH
53866: EMPTY
53867: LIST
53868: LIST
53869: PPUSH
53870: LD_VAR 0 3
53874: PPUSH
53875: CALL 9427 0 3
53879: ST_TO_ADDR
// end ; end ;
53880: GO 53776
53882: POP
53883: POP
// if not lab or not mc_lab_upgrade [ i ] then
53884: LD_VAR 0 6
53888: NOT
53889: PUSH
53890: LD_EXP 48
53894: PUSH
53895: LD_VAR 0 2
53899: ARRAY
53900: NOT
53901: OR
53902: IFFALSE 53906
// continue ;
53904: GO 53676
// for j in lab do
53906: LD_ADDR_VAR 0 3
53910: PUSH
53911: LD_VAR 0 6
53915: PUSH
53916: FOR_IN
53917: IFFALSE 54082
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
53919: LD_VAR 0 3
53923: PPUSH
53924: CALL_OW 266
53928: PUSH
53929: LD_INT 6
53931: PUSH
53932: LD_INT 7
53934: PUSH
53935: EMPTY
53936: LIST
53937: LIST
53938: IN
53939: PUSH
53940: LD_VAR 0 3
53944: PPUSH
53945: CALL_OW 461
53949: PUSH
53950: LD_INT 1
53952: NONEQUAL
53953: AND
53954: IFFALSE 54080
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
53956: LD_VAR 0 3
53960: PPUSH
53961: LD_EXP 48
53965: PUSH
53966: LD_VAR 0 2
53970: ARRAY
53971: PUSH
53972: LD_INT 1
53974: ARRAY
53975: PPUSH
53976: CALL 16170 0 2
53980: IFFALSE 54080
// begin ComCancel ( j ) ;
53982: LD_VAR 0 3
53986: PPUSH
53987: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
53991: LD_VAR 0 3
53995: PPUSH
53996: LD_EXP 48
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: PUSH
54007: LD_INT 1
54009: ARRAY
54010: PPUSH
54011: CALL_OW 207
// if not j in mc_construct_list [ i ] then
54015: LD_VAR 0 3
54019: PUSH
54020: LD_EXP 21
54024: PUSH
54025: LD_VAR 0 2
54029: ARRAY
54030: IN
54031: NOT
54032: IFFALSE 54078
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
54034: LD_ADDR_EXP 21
54038: PUSH
54039: LD_EXP 21
54043: PPUSH
54044: LD_VAR 0 2
54048: PUSH
54049: LD_EXP 21
54053: PUSH
54054: LD_VAR 0 2
54058: ARRAY
54059: PUSH
54060: LD_INT 1
54062: PLUS
54063: PUSH
54064: EMPTY
54065: LIST
54066: LIST
54067: PPUSH
54068: LD_VAR 0 3
54072: PPUSH
54073: CALL 9427 0 3
54077: ST_TO_ADDR
// break ;
54078: GO 54082
// end ; end ; end ;
54080: GO 53916
54082: POP
54083: POP
// end ;
54084: GO 53676
54086: POP
54087: POP
// end ;
54088: LD_VAR 0 1
54092: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
54093: LD_INT 0
54095: PPUSH
54096: PPUSH
54097: PPUSH
54098: PPUSH
54099: PPUSH
54100: PPUSH
54101: PPUSH
54102: PPUSH
54103: PPUSH
// if not mc_bases then
54104: LD_EXP 14
54108: NOT
54109: IFFALSE 54113
// exit ;
54111: GO 54518
// for i = 1 to mc_bases do
54113: LD_ADDR_VAR 0 2
54117: PUSH
54118: DOUBLE
54119: LD_INT 1
54121: DEC
54122: ST_TO_ADDR
54123: LD_EXP 14
54127: PUSH
54128: FOR_TO
54129: IFFALSE 54516
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
54131: LD_EXP 22
54135: PUSH
54136: LD_VAR 0 2
54140: ARRAY
54141: NOT
54142: PUSH
54143: LD_EXP 14
54147: PUSH
54148: LD_VAR 0 2
54152: ARRAY
54153: PPUSH
54154: LD_INT 30
54156: PUSH
54157: LD_INT 3
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: PPUSH
54164: CALL_OW 72
54168: NOT
54169: OR
54170: IFFALSE 54174
// continue ;
54172: GO 54128
// busy := false ;
54174: LD_ADDR_VAR 0 8
54178: PUSH
54179: LD_INT 0
54181: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
54182: LD_ADDR_VAR 0 4
54186: PUSH
54187: LD_EXP 14
54191: PUSH
54192: LD_VAR 0 2
54196: ARRAY
54197: PPUSH
54198: LD_INT 30
54200: PUSH
54201: LD_INT 3
54203: PUSH
54204: EMPTY
54205: LIST
54206: LIST
54207: PPUSH
54208: CALL_OW 72
54212: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
54213: LD_ADDR_VAR 0 6
54217: PUSH
54218: LD_EXP 22
54222: PUSH
54223: LD_VAR 0 2
54227: ARRAY
54228: PPUSH
54229: LD_INT 2
54231: PUSH
54232: LD_INT 30
54234: PUSH
54235: LD_INT 32
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: PUSH
54242: LD_INT 30
54244: PUSH
54245: LD_INT 33
54247: PUSH
54248: EMPTY
54249: LIST
54250: LIST
54251: PUSH
54252: EMPTY
54253: LIST
54254: LIST
54255: LIST
54256: PPUSH
54257: CALL_OW 72
54261: ST_TO_ADDR
// if not t then
54262: LD_VAR 0 6
54266: NOT
54267: IFFALSE 54271
// continue ;
54269: GO 54128
// for j in tmp do
54271: LD_ADDR_VAR 0 3
54275: PUSH
54276: LD_VAR 0 4
54280: PUSH
54281: FOR_IN
54282: IFFALSE 54312
// if not BuildingStatus ( j ) = bs_idle then
54284: LD_VAR 0 3
54288: PPUSH
54289: CALL_OW 461
54293: PUSH
54294: LD_INT 2
54296: EQUAL
54297: NOT
54298: IFFALSE 54310
// begin busy := true ;
54300: LD_ADDR_VAR 0 8
54304: PUSH
54305: LD_INT 1
54307: ST_TO_ADDR
// break ;
54308: GO 54312
// end ;
54310: GO 54281
54312: POP
54313: POP
// if busy then
54314: LD_VAR 0 8
54318: IFFALSE 54322
// continue ;
54320: GO 54128
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
54322: LD_ADDR_VAR 0 7
54326: PUSH
54327: LD_VAR 0 6
54331: PPUSH
54332: LD_INT 35
54334: PUSH
54335: LD_INT 0
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: PPUSH
54342: CALL_OW 72
54346: ST_TO_ADDR
// if tw then
54347: LD_VAR 0 7
54351: IFFALSE 54428
// begin tw := tw [ 1 ] ;
54353: LD_ADDR_VAR 0 7
54357: PUSH
54358: LD_VAR 0 7
54362: PUSH
54363: LD_INT 1
54365: ARRAY
54366: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
54367: LD_ADDR_VAR 0 9
54371: PUSH
54372: LD_VAR 0 7
54376: PPUSH
54377: LD_EXP 39
54381: PUSH
54382: LD_VAR 0 2
54386: ARRAY
54387: PPUSH
54388: CALL 14432 0 2
54392: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
54393: LD_EXP 53
54397: PUSH
54398: LD_VAR 0 2
54402: ARRAY
54403: IFFALSE 54426
// if not weapon in mc_allowed_tower_weapons [ i ] then
54405: LD_VAR 0 9
54409: PUSH
54410: LD_EXP 53
54414: PUSH
54415: LD_VAR 0 2
54419: ARRAY
54420: IN
54421: NOT
54422: IFFALSE 54426
// continue ;
54424: GO 54128
// end else
54426: GO 54491
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
54428: LD_ADDR_VAR 0 5
54432: PUSH
54433: LD_EXP 22
54437: PUSH
54438: LD_VAR 0 2
54442: ARRAY
54443: PPUSH
54444: LD_VAR 0 4
54448: PPUSH
54449: CALL 40351 0 2
54453: ST_TO_ADDR
// if not tmp2 then
54454: LD_VAR 0 5
54458: NOT
54459: IFFALSE 54463
// continue ;
54461: GO 54128
// tw := tmp2 [ 1 ] ;
54463: LD_ADDR_VAR 0 7
54467: PUSH
54468: LD_VAR 0 5
54472: PUSH
54473: LD_INT 1
54475: ARRAY
54476: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
54477: LD_ADDR_VAR 0 9
54481: PUSH
54482: LD_VAR 0 5
54486: PUSH
54487: LD_INT 2
54489: ARRAY
54490: ST_TO_ADDR
// end ; if not weapon then
54491: LD_VAR 0 9
54495: NOT
54496: IFFALSE 54500
// continue ;
54498: GO 54128
// ComPlaceWeapon ( tw , weapon ) ;
54500: LD_VAR 0 7
54504: PPUSH
54505: LD_VAR 0 9
54509: PPUSH
54510: CALL_OW 148
// end ;
54514: GO 54128
54516: POP
54517: POP
// end ;
54518: LD_VAR 0 1
54522: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
54523: LD_INT 0
54525: PPUSH
54526: PPUSH
54527: PPUSH
54528: PPUSH
54529: PPUSH
54530: PPUSH
54531: PPUSH
// if not mc_bases then
54532: LD_EXP 14
54536: NOT
54537: IFFALSE 54541
// exit ;
54539: GO 55309
// for i = 1 to mc_bases do
54541: LD_ADDR_VAR 0 2
54545: PUSH
54546: DOUBLE
54547: LD_INT 1
54549: DEC
54550: ST_TO_ADDR
54551: LD_EXP 14
54555: PUSH
54556: FOR_TO
54557: IFFALSE 55307
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
54559: LD_EXP 27
54563: PUSH
54564: LD_VAR 0 2
54568: ARRAY
54569: NOT
54570: PUSH
54571: LD_EXP 27
54575: PUSH
54576: LD_VAR 0 2
54580: ARRAY
54581: PUSH
54582: LD_EXP 28
54586: PUSH
54587: LD_VAR 0 2
54591: ARRAY
54592: EQUAL
54593: OR
54594: PUSH
54595: LD_EXP 37
54599: PUSH
54600: LD_VAR 0 2
54604: ARRAY
54605: OR
54606: IFFALSE 54610
// continue ;
54608: GO 54556
// if mc_miners [ i ] then
54610: LD_EXP 28
54614: PUSH
54615: LD_VAR 0 2
54619: ARRAY
54620: IFFALSE 54994
// begin for j = mc_miners [ i ] downto 1 do
54622: LD_ADDR_VAR 0 3
54626: PUSH
54627: DOUBLE
54628: LD_EXP 28
54632: PUSH
54633: LD_VAR 0 2
54637: ARRAY
54638: INC
54639: ST_TO_ADDR
54640: LD_INT 1
54642: PUSH
54643: FOR_DOWNTO
54644: IFFALSE 54992
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
54646: LD_EXP 28
54650: PUSH
54651: LD_VAR 0 2
54655: ARRAY
54656: PUSH
54657: LD_VAR 0 3
54661: ARRAY
54662: PPUSH
54663: CALL_OW 301
54667: PUSH
54668: LD_EXP 28
54672: PUSH
54673: LD_VAR 0 2
54677: ARRAY
54678: PUSH
54679: LD_VAR 0 3
54683: ARRAY
54684: PPUSH
54685: CALL_OW 257
54689: PUSH
54690: LD_INT 1
54692: NONEQUAL
54693: OR
54694: IFFALSE 54757
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
54696: LD_ADDR_VAR 0 5
54700: PUSH
54701: LD_EXP 28
54705: PUSH
54706: LD_VAR 0 2
54710: ARRAY
54711: PUSH
54712: LD_EXP 28
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PUSH
54723: LD_VAR 0 3
54727: ARRAY
54728: DIFF
54729: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
54730: LD_ADDR_EXP 28
54734: PUSH
54735: LD_EXP 28
54739: PPUSH
54740: LD_VAR 0 2
54744: PPUSH
54745: LD_VAR 0 5
54749: PPUSH
54750: CALL_OW 1
54754: ST_TO_ADDR
// continue ;
54755: GO 54643
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
54757: LD_EXP 28
54761: PUSH
54762: LD_VAR 0 2
54766: ARRAY
54767: PUSH
54768: LD_VAR 0 3
54772: ARRAY
54773: PPUSH
54774: CALL_OW 257
54778: PUSH
54779: LD_INT 1
54781: EQUAL
54782: PUSH
54783: LD_EXP 28
54787: PUSH
54788: LD_VAR 0 2
54792: ARRAY
54793: PUSH
54794: LD_VAR 0 3
54798: ARRAY
54799: PPUSH
54800: CALL_OW 459
54804: NOT
54805: AND
54806: PUSH
54807: LD_EXP 28
54811: PUSH
54812: LD_VAR 0 2
54816: ARRAY
54817: PUSH
54818: LD_VAR 0 3
54822: ARRAY
54823: PPUSH
54824: CALL_OW 314
54828: NOT
54829: AND
54830: IFFALSE 54990
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
54832: LD_EXP 28
54836: PUSH
54837: LD_VAR 0 2
54841: ARRAY
54842: PUSH
54843: LD_VAR 0 3
54847: ARRAY
54848: PPUSH
54849: CALL_OW 310
54853: IFFALSE 54876
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
54855: LD_EXP 28
54859: PUSH
54860: LD_VAR 0 2
54864: ARRAY
54865: PUSH
54866: LD_VAR 0 3
54870: ARRAY
54871: PPUSH
54872: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
54876: LD_EXP 28
54880: PUSH
54881: LD_VAR 0 2
54885: ARRAY
54886: PUSH
54887: LD_VAR 0 3
54891: ARRAY
54892: PPUSH
54893: CALL_OW 314
54897: NOT
54898: IFFALSE 54990
// begin r := rand ( 1 , mc_mines [ i ] ) ;
54900: LD_ADDR_VAR 0 7
54904: PUSH
54905: LD_INT 1
54907: PPUSH
54908: LD_EXP 27
54912: PUSH
54913: LD_VAR 0 2
54917: ARRAY
54918: PPUSH
54919: CALL_OW 12
54923: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
54924: LD_EXP 28
54928: PUSH
54929: LD_VAR 0 2
54933: ARRAY
54934: PUSH
54935: LD_VAR 0 3
54939: ARRAY
54940: PPUSH
54941: LD_EXP 27
54945: PUSH
54946: LD_VAR 0 2
54950: ARRAY
54951: PUSH
54952: LD_VAR 0 7
54956: ARRAY
54957: PUSH
54958: LD_INT 1
54960: ARRAY
54961: PPUSH
54962: LD_EXP 27
54966: PUSH
54967: LD_VAR 0 2
54971: ARRAY
54972: PUSH
54973: LD_VAR 0 7
54977: ARRAY
54978: PUSH
54979: LD_INT 2
54981: ARRAY
54982: PPUSH
54983: LD_INT 0
54985: PPUSH
54986: CALL_OW 193
// end ; end ; end ;
54990: GO 54643
54992: POP
54993: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
54994: LD_ADDR_VAR 0 5
54998: PUSH
54999: LD_EXP 14
55003: PUSH
55004: LD_VAR 0 2
55008: ARRAY
55009: PPUSH
55010: LD_INT 2
55012: PUSH
55013: LD_INT 30
55015: PUSH
55016: LD_INT 4
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PUSH
55023: LD_INT 30
55025: PUSH
55026: LD_INT 5
55028: PUSH
55029: EMPTY
55030: LIST
55031: LIST
55032: PUSH
55033: LD_INT 30
55035: PUSH
55036: LD_INT 32
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: PUSH
55043: EMPTY
55044: LIST
55045: LIST
55046: LIST
55047: LIST
55048: PPUSH
55049: CALL_OW 72
55053: ST_TO_ADDR
// if not tmp then
55054: LD_VAR 0 5
55058: NOT
55059: IFFALSE 55063
// continue ;
55061: GO 54556
// list := [ ] ;
55063: LD_ADDR_VAR 0 6
55067: PUSH
55068: EMPTY
55069: ST_TO_ADDR
// for j in tmp do
55070: LD_ADDR_VAR 0 3
55074: PUSH
55075: LD_VAR 0 5
55079: PUSH
55080: FOR_IN
55081: IFFALSE 55150
// begin for k in UnitsInside ( j ) do
55083: LD_ADDR_VAR 0 4
55087: PUSH
55088: LD_VAR 0 3
55092: PPUSH
55093: CALL_OW 313
55097: PUSH
55098: FOR_IN
55099: IFFALSE 55146
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
55101: LD_VAR 0 4
55105: PPUSH
55106: CALL_OW 257
55110: PUSH
55111: LD_INT 1
55113: EQUAL
55114: PUSH
55115: LD_VAR 0 4
55119: PPUSH
55120: CALL_OW 459
55124: NOT
55125: AND
55126: IFFALSE 55144
// list := list ^ k ;
55128: LD_ADDR_VAR 0 6
55132: PUSH
55133: LD_VAR 0 6
55137: PUSH
55138: LD_VAR 0 4
55142: ADD
55143: ST_TO_ADDR
55144: GO 55098
55146: POP
55147: POP
// end ;
55148: GO 55080
55150: POP
55151: POP
// list := list diff mc_miners [ i ] ;
55152: LD_ADDR_VAR 0 6
55156: PUSH
55157: LD_VAR 0 6
55161: PUSH
55162: LD_EXP 28
55166: PUSH
55167: LD_VAR 0 2
55171: ARRAY
55172: DIFF
55173: ST_TO_ADDR
// if not list then
55174: LD_VAR 0 6
55178: NOT
55179: IFFALSE 55183
// continue ;
55181: GO 54556
// k := mc_mines [ i ] - mc_miners [ i ] ;
55183: LD_ADDR_VAR 0 4
55187: PUSH
55188: LD_EXP 27
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PUSH
55199: LD_EXP 28
55203: PUSH
55204: LD_VAR 0 2
55208: ARRAY
55209: MINUS
55210: ST_TO_ADDR
// if k > list then
55211: LD_VAR 0 4
55215: PUSH
55216: LD_VAR 0 6
55220: GREATER
55221: IFFALSE 55233
// k := list ;
55223: LD_ADDR_VAR 0 4
55227: PUSH
55228: LD_VAR 0 6
55232: ST_TO_ADDR
// for j = 1 to k do
55233: LD_ADDR_VAR 0 3
55237: PUSH
55238: DOUBLE
55239: LD_INT 1
55241: DEC
55242: ST_TO_ADDR
55243: LD_VAR 0 4
55247: PUSH
55248: FOR_TO
55249: IFFALSE 55303
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
55251: LD_ADDR_EXP 28
55255: PUSH
55256: LD_EXP 28
55260: PPUSH
55261: LD_VAR 0 2
55265: PUSH
55266: LD_EXP 28
55270: PUSH
55271: LD_VAR 0 2
55275: ARRAY
55276: PUSH
55277: LD_INT 1
55279: PLUS
55280: PUSH
55281: EMPTY
55282: LIST
55283: LIST
55284: PPUSH
55285: LD_VAR 0 6
55289: PUSH
55290: LD_VAR 0 3
55294: ARRAY
55295: PPUSH
55296: CALL 9427 0 3
55300: ST_TO_ADDR
55301: GO 55248
55303: POP
55304: POP
// end ;
55305: GO 54556
55307: POP
55308: POP
// end ;
55309: LD_VAR 0 1
55313: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
55314: LD_INT 0
55316: PPUSH
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
55322: PPUSH
55323: PPUSH
55324: PPUSH
55325: PPUSH
// if not mc_bases then
55326: LD_EXP 14
55330: NOT
55331: IFFALSE 55335
// exit ;
55333: GO 57085
// for i = 1 to mc_bases do
55335: LD_ADDR_VAR 0 2
55339: PUSH
55340: DOUBLE
55341: LD_INT 1
55343: DEC
55344: ST_TO_ADDR
55345: LD_EXP 14
55349: PUSH
55350: FOR_TO
55351: IFFALSE 57083
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
55353: LD_EXP 14
55357: PUSH
55358: LD_VAR 0 2
55362: ARRAY
55363: NOT
55364: PUSH
55365: LD_EXP 21
55369: PUSH
55370: LD_VAR 0 2
55374: ARRAY
55375: OR
55376: IFFALSE 55380
// continue ;
55378: GO 55350
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
55380: LD_EXP 30
55384: PUSH
55385: LD_VAR 0 2
55389: ARRAY
55390: NOT
55391: PUSH
55392: LD_EXP 31
55396: PUSH
55397: LD_VAR 0 2
55401: ARRAY
55402: AND
55403: IFFALSE 55441
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
55405: LD_ADDR_EXP 31
55409: PUSH
55410: LD_EXP 31
55414: PPUSH
55415: LD_VAR 0 2
55419: PPUSH
55420: EMPTY
55421: PPUSH
55422: CALL_OW 1
55426: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
55427: LD_VAR 0 2
55431: PPUSH
55432: LD_INT 107
55434: PPUSH
55435: CALL 46268 0 2
// continue ;
55439: GO 55350
// end ; target := [ ] ;
55441: LD_ADDR_VAR 0 6
55445: PUSH
55446: EMPTY
55447: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
55448: LD_ADDR_VAR 0 3
55452: PUSH
55453: DOUBLE
55454: LD_EXP 30
55458: PUSH
55459: LD_VAR 0 2
55463: ARRAY
55464: INC
55465: ST_TO_ADDR
55466: LD_INT 1
55468: PUSH
55469: FOR_DOWNTO
55470: IFFALSE 55730
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
55472: LD_EXP 30
55476: PUSH
55477: LD_VAR 0 2
55481: ARRAY
55482: PUSH
55483: LD_VAR 0 3
55487: ARRAY
55488: PUSH
55489: LD_INT 2
55491: ARRAY
55492: PPUSH
55493: LD_EXP 30
55497: PUSH
55498: LD_VAR 0 2
55502: ARRAY
55503: PUSH
55504: LD_VAR 0 3
55508: ARRAY
55509: PUSH
55510: LD_INT 3
55512: ARRAY
55513: PPUSH
55514: CALL_OW 488
55518: PUSH
55519: LD_EXP 30
55523: PUSH
55524: LD_VAR 0 2
55528: ARRAY
55529: PUSH
55530: LD_VAR 0 3
55534: ARRAY
55535: PUSH
55536: LD_INT 2
55538: ARRAY
55539: PPUSH
55540: LD_EXP 30
55544: PUSH
55545: LD_VAR 0 2
55549: ARRAY
55550: PUSH
55551: LD_VAR 0 3
55555: ARRAY
55556: PUSH
55557: LD_INT 3
55559: ARRAY
55560: PPUSH
55561: CALL_OW 284
55565: PUSH
55566: LD_INT 0
55568: EQUAL
55569: AND
55570: IFFALSE 55625
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
55572: LD_ADDR_VAR 0 5
55576: PUSH
55577: LD_EXP 30
55581: PUSH
55582: LD_VAR 0 2
55586: ARRAY
55587: PPUSH
55588: LD_VAR 0 3
55592: PPUSH
55593: CALL_OW 3
55597: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
55598: LD_ADDR_EXP 30
55602: PUSH
55603: LD_EXP 30
55607: PPUSH
55608: LD_VAR 0 2
55612: PPUSH
55613: LD_VAR 0 5
55617: PPUSH
55618: CALL_OW 1
55622: ST_TO_ADDR
// continue ;
55623: GO 55469
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
55625: LD_EXP 14
55629: PUSH
55630: LD_VAR 0 2
55634: ARRAY
55635: PUSH
55636: LD_INT 1
55638: ARRAY
55639: PPUSH
55640: CALL_OW 255
55644: PPUSH
55645: LD_EXP 30
55649: PUSH
55650: LD_VAR 0 2
55654: ARRAY
55655: PUSH
55656: LD_VAR 0 3
55660: ARRAY
55661: PUSH
55662: LD_INT 2
55664: ARRAY
55665: PPUSH
55666: LD_EXP 30
55670: PUSH
55671: LD_VAR 0 2
55675: ARRAY
55676: PUSH
55677: LD_VAR 0 3
55681: ARRAY
55682: PUSH
55683: LD_INT 3
55685: ARRAY
55686: PPUSH
55687: LD_INT 30
55689: PPUSH
55690: CALL 10323 0 4
55694: PUSH
55695: LD_INT 4
55697: ARRAY
55698: PUSH
55699: LD_INT 0
55701: EQUAL
55702: IFFALSE 55728
// begin target := mc_crates [ i ] [ j ] ;
55704: LD_ADDR_VAR 0 6
55708: PUSH
55709: LD_EXP 30
55713: PUSH
55714: LD_VAR 0 2
55718: ARRAY
55719: PUSH
55720: LD_VAR 0 3
55724: ARRAY
55725: ST_TO_ADDR
// break ;
55726: GO 55730
// end ; end ;
55728: GO 55469
55730: POP
55731: POP
// if not target then
55732: LD_VAR 0 6
55736: NOT
55737: IFFALSE 55741
// continue ;
55739: GO 55350
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
55741: LD_ADDR_VAR 0 7
55745: PUSH
55746: LD_EXP 33
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 2
55759: PUSH
55760: LD_INT 3
55762: PUSH
55763: LD_INT 58
55765: PUSH
55766: EMPTY
55767: LIST
55768: PUSH
55769: EMPTY
55770: LIST
55771: LIST
55772: PUSH
55773: LD_INT 61
55775: PUSH
55776: EMPTY
55777: LIST
55778: PUSH
55779: LD_INT 33
55781: PUSH
55782: LD_INT 5
55784: PUSH
55785: EMPTY
55786: LIST
55787: LIST
55788: PUSH
55789: LD_INT 33
55791: PUSH
55792: LD_INT 3
55794: PUSH
55795: EMPTY
55796: LIST
55797: LIST
55798: PUSH
55799: EMPTY
55800: LIST
55801: LIST
55802: LIST
55803: LIST
55804: LIST
55805: PUSH
55806: LD_INT 2
55808: PUSH
55809: LD_INT 34
55811: PUSH
55812: LD_INT 32
55814: PUSH
55815: EMPTY
55816: LIST
55817: LIST
55818: PUSH
55819: LD_INT 34
55821: PUSH
55822: LD_INT 51
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: PUSH
55829: LD_INT 34
55831: PUSH
55832: LD_INT 12
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: PUSH
55839: EMPTY
55840: LIST
55841: LIST
55842: LIST
55843: LIST
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PPUSH
55849: CALL_OW 72
55853: ST_TO_ADDR
// if not cargo then
55854: LD_VAR 0 7
55858: NOT
55859: IFFALSE 56502
// begin if mc_crates_collector [ i ] < 5 then
55861: LD_EXP 31
55865: PUSH
55866: LD_VAR 0 2
55870: ARRAY
55871: PUSH
55872: LD_INT 5
55874: LESS
55875: IFFALSE 56241
// begin if mc_ape [ i ] then
55877: LD_EXP 43
55881: PUSH
55882: LD_VAR 0 2
55886: ARRAY
55887: IFFALSE 55934
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
55889: LD_ADDR_VAR 0 5
55893: PUSH
55894: LD_EXP 43
55898: PUSH
55899: LD_VAR 0 2
55903: ARRAY
55904: PPUSH
55905: LD_INT 25
55907: PUSH
55908: LD_INT 16
55910: PUSH
55911: EMPTY
55912: LIST
55913: LIST
55914: PUSH
55915: LD_INT 24
55917: PUSH
55918: LD_INT 750
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PPUSH
55929: CALL_OW 72
55933: ST_TO_ADDR
// if not tmp then
55934: LD_VAR 0 5
55938: NOT
55939: IFFALSE 55986
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
55941: LD_ADDR_VAR 0 5
55945: PUSH
55946: LD_EXP 14
55950: PUSH
55951: LD_VAR 0 2
55955: ARRAY
55956: PPUSH
55957: LD_INT 25
55959: PUSH
55960: LD_INT 2
55962: PUSH
55963: EMPTY
55964: LIST
55965: LIST
55966: PUSH
55967: LD_INT 24
55969: PUSH
55970: LD_INT 750
55972: PUSH
55973: EMPTY
55974: LIST
55975: LIST
55976: PUSH
55977: EMPTY
55978: LIST
55979: LIST
55980: PPUSH
55981: CALL_OW 72
55985: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
55986: LD_EXP 43
55990: PUSH
55991: LD_VAR 0 2
55995: ARRAY
55996: PUSH
55997: LD_EXP 14
56001: PUSH
56002: LD_VAR 0 2
56006: ARRAY
56007: PPUSH
56008: LD_INT 25
56010: PUSH
56011: LD_INT 2
56013: PUSH
56014: EMPTY
56015: LIST
56016: LIST
56017: PUSH
56018: LD_INT 24
56020: PUSH
56021: LD_INT 750
56023: PUSH
56024: EMPTY
56025: LIST
56026: LIST
56027: PUSH
56028: EMPTY
56029: LIST
56030: LIST
56031: PPUSH
56032: CALL_OW 72
56036: AND
56037: PUSH
56038: LD_VAR 0 5
56042: PUSH
56043: LD_INT 5
56045: LESS
56046: AND
56047: IFFALSE 56129
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
56049: LD_ADDR_VAR 0 3
56053: PUSH
56054: LD_EXP 14
56058: PUSH
56059: LD_VAR 0 2
56063: ARRAY
56064: PPUSH
56065: LD_INT 25
56067: PUSH
56068: LD_INT 2
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: PUSH
56075: LD_INT 24
56077: PUSH
56078: LD_INT 750
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: PUSH
56085: EMPTY
56086: LIST
56087: LIST
56088: PPUSH
56089: CALL_OW 72
56093: PUSH
56094: FOR_IN
56095: IFFALSE 56127
// begin tmp := tmp union j ;
56097: LD_ADDR_VAR 0 5
56101: PUSH
56102: LD_VAR 0 5
56106: PUSH
56107: LD_VAR 0 3
56111: UNION
56112: ST_TO_ADDR
// if tmp >= 5 then
56113: LD_VAR 0 5
56117: PUSH
56118: LD_INT 5
56120: GREATEREQUAL
56121: IFFALSE 56125
// break ;
56123: GO 56127
// end ;
56125: GO 56094
56127: POP
56128: POP
// end ; if not tmp then
56129: LD_VAR 0 5
56133: NOT
56134: IFFALSE 56138
// continue ;
56136: GO 55350
// for j in tmp do
56138: LD_ADDR_VAR 0 3
56142: PUSH
56143: LD_VAR 0 5
56147: PUSH
56148: FOR_IN
56149: IFFALSE 56239
// if not GetTag ( j ) then
56151: LD_VAR 0 3
56155: PPUSH
56156: CALL_OW 110
56160: NOT
56161: IFFALSE 56237
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
56163: LD_ADDR_EXP 31
56167: PUSH
56168: LD_EXP 31
56172: PPUSH
56173: LD_VAR 0 2
56177: PUSH
56178: LD_EXP 31
56182: PUSH
56183: LD_VAR 0 2
56187: ARRAY
56188: PUSH
56189: LD_INT 1
56191: PLUS
56192: PUSH
56193: EMPTY
56194: LIST
56195: LIST
56196: PPUSH
56197: LD_VAR 0 3
56201: PPUSH
56202: CALL 9427 0 3
56206: ST_TO_ADDR
// SetTag ( j , 107 ) ;
56207: LD_VAR 0 3
56211: PPUSH
56212: LD_INT 107
56214: PPUSH
56215: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
56219: LD_EXP 31
56223: PUSH
56224: LD_VAR 0 2
56228: ARRAY
56229: PUSH
56230: LD_INT 5
56232: GREATEREQUAL
56233: IFFALSE 56237
// break ;
56235: GO 56239
// end ;
56237: GO 56148
56239: POP
56240: POP
// end ; if mc_crates_collector [ i ] and target then
56241: LD_EXP 31
56245: PUSH
56246: LD_VAR 0 2
56250: ARRAY
56251: PUSH
56252: LD_VAR 0 6
56256: AND
56257: IFFALSE 56500
// begin if mc_crates_collector [ i ] < target [ 1 ] then
56259: LD_EXP 31
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: PUSH
56270: LD_VAR 0 6
56274: PUSH
56275: LD_INT 1
56277: ARRAY
56278: LESS
56279: IFFALSE 56299
// tmp := mc_crates_collector [ i ] else
56281: LD_ADDR_VAR 0 5
56285: PUSH
56286: LD_EXP 31
56290: PUSH
56291: LD_VAR 0 2
56295: ARRAY
56296: ST_TO_ADDR
56297: GO 56313
// tmp := target [ 1 ] ;
56299: LD_ADDR_VAR 0 5
56303: PUSH
56304: LD_VAR 0 6
56308: PUSH
56309: LD_INT 1
56311: ARRAY
56312: ST_TO_ADDR
// k := 0 ;
56313: LD_ADDR_VAR 0 4
56317: PUSH
56318: LD_INT 0
56320: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
56321: LD_ADDR_VAR 0 3
56325: PUSH
56326: LD_EXP 31
56330: PUSH
56331: LD_VAR 0 2
56335: ARRAY
56336: PUSH
56337: FOR_IN
56338: IFFALSE 56498
// begin k := k + 1 ;
56340: LD_ADDR_VAR 0 4
56344: PUSH
56345: LD_VAR 0 4
56349: PUSH
56350: LD_INT 1
56352: PLUS
56353: ST_TO_ADDR
// if k > tmp then
56354: LD_VAR 0 4
56358: PUSH
56359: LD_VAR 0 5
56363: GREATER
56364: IFFALSE 56368
// break ;
56366: GO 56498
// if not GetClass ( j ) in [ 2 , 16 ] then
56368: LD_VAR 0 3
56372: PPUSH
56373: CALL_OW 257
56377: PUSH
56378: LD_INT 2
56380: PUSH
56381: LD_INT 16
56383: PUSH
56384: EMPTY
56385: LIST
56386: LIST
56387: IN
56388: NOT
56389: IFFALSE 56442
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
56391: LD_ADDR_EXP 31
56395: PUSH
56396: LD_EXP 31
56400: PPUSH
56401: LD_VAR 0 2
56405: PPUSH
56406: LD_EXP 31
56410: PUSH
56411: LD_VAR 0 2
56415: ARRAY
56416: PUSH
56417: LD_VAR 0 3
56421: DIFF
56422: PPUSH
56423: CALL_OW 1
56427: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56428: LD_VAR 0 3
56432: PPUSH
56433: LD_INT 0
56435: PPUSH
56436: CALL_OW 109
// continue ;
56440: GO 56337
// end ; if IsInUnit ( j ) then
56442: LD_VAR 0 3
56446: PPUSH
56447: CALL_OW 310
56451: IFFALSE 56462
// ComExitBuilding ( j ) ;
56453: LD_VAR 0 3
56457: PPUSH
56458: CALL_OW 122
// wait ( 3 ) ;
56462: LD_INT 3
56464: PPUSH
56465: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
56469: LD_VAR 0 3
56473: PPUSH
56474: LD_VAR 0 6
56478: PUSH
56479: LD_INT 2
56481: ARRAY
56482: PPUSH
56483: LD_VAR 0 6
56487: PUSH
56488: LD_INT 3
56490: ARRAY
56491: PPUSH
56492: CALL_OW 117
// end ;
56496: GO 56337
56498: POP
56499: POP
// end ; end else
56500: GO 57081
// begin for j in cargo do
56502: LD_ADDR_VAR 0 3
56506: PUSH
56507: LD_VAR 0 7
56511: PUSH
56512: FOR_IN
56513: IFFALSE 57079
// begin if GetTag ( j ) <> 0 then
56515: LD_VAR 0 3
56519: PPUSH
56520: CALL_OW 110
56524: PUSH
56525: LD_INT 0
56527: NONEQUAL
56528: IFFALSE 56532
// continue ;
56530: GO 56512
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
56532: LD_VAR 0 3
56536: PPUSH
56537: CALL_OW 256
56541: PUSH
56542: LD_INT 1000
56544: LESS
56545: PUSH
56546: LD_VAR 0 3
56550: PPUSH
56551: LD_EXP 38
56555: PUSH
56556: LD_VAR 0 2
56560: ARRAY
56561: PPUSH
56562: CALL_OW 308
56566: NOT
56567: AND
56568: IFFALSE 56590
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56570: LD_VAR 0 3
56574: PPUSH
56575: LD_EXP 38
56579: PUSH
56580: LD_VAR 0 2
56584: ARRAY
56585: PPUSH
56586: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
56590: LD_VAR 0 3
56594: PPUSH
56595: CALL_OW 256
56599: PUSH
56600: LD_INT 1000
56602: LESS
56603: PUSH
56604: LD_VAR 0 3
56608: PPUSH
56609: LD_EXP 38
56613: PUSH
56614: LD_VAR 0 2
56618: ARRAY
56619: PPUSH
56620: CALL_OW 308
56624: AND
56625: IFFALSE 56629
// continue ;
56627: GO 56512
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
56629: LD_VAR 0 3
56633: PPUSH
56634: CALL_OW 262
56638: PUSH
56639: LD_INT 2
56641: EQUAL
56642: PUSH
56643: LD_VAR 0 3
56647: PPUSH
56648: CALL_OW 261
56652: PUSH
56653: LD_INT 15
56655: LESS
56656: AND
56657: IFFALSE 56661
// continue ;
56659: GO 56512
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
56661: LD_VAR 0 3
56665: PPUSH
56666: CALL_OW 262
56670: PUSH
56671: LD_INT 1
56673: EQUAL
56674: PUSH
56675: LD_VAR 0 3
56679: PPUSH
56680: CALL_OW 261
56684: PUSH
56685: LD_INT 10
56687: LESS
56688: AND
56689: IFFALSE 57018
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56691: LD_ADDR_VAR 0 8
56695: PUSH
56696: LD_EXP 14
56700: PUSH
56701: LD_VAR 0 2
56705: ARRAY
56706: PPUSH
56707: LD_INT 2
56709: PUSH
56710: LD_INT 30
56712: PUSH
56713: LD_INT 0
56715: PUSH
56716: EMPTY
56717: LIST
56718: LIST
56719: PUSH
56720: LD_INT 30
56722: PUSH
56723: LD_INT 1
56725: PUSH
56726: EMPTY
56727: LIST
56728: LIST
56729: PUSH
56730: EMPTY
56731: LIST
56732: LIST
56733: LIST
56734: PPUSH
56735: CALL_OW 72
56739: ST_TO_ADDR
// if not depot then
56740: LD_VAR 0 8
56744: NOT
56745: IFFALSE 56749
// continue ;
56747: GO 56512
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
56749: LD_VAR 0 3
56753: PPUSH
56754: LD_VAR 0 8
56758: PPUSH
56759: LD_VAR 0 3
56763: PPUSH
56764: CALL_OW 74
56768: PPUSH
56769: CALL_OW 296
56773: PUSH
56774: LD_INT 6
56776: LESS
56777: IFFALSE 56793
// SetFuel ( j , 100 ) else
56779: LD_VAR 0 3
56783: PPUSH
56784: LD_INT 100
56786: PPUSH
56787: CALL_OW 240
56791: GO 57018
// if GetFuel ( j ) = 0 then
56793: LD_VAR 0 3
56797: PPUSH
56798: CALL_OW 261
56802: PUSH
56803: LD_INT 0
56805: EQUAL
56806: IFFALSE 57018
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
56808: LD_ADDR_EXP 33
56812: PUSH
56813: LD_EXP 33
56817: PPUSH
56818: LD_VAR 0 2
56822: PPUSH
56823: LD_EXP 33
56827: PUSH
56828: LD_VAR 0 2
56832: ARRAY
56833: PUSH
56834: LD_VAR 0 3
56838: DIFF
56839: PPUSH
56840: CALL_OW 1
56844: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
56845: LD_VAR 0 3
56849: PPUSH
56850: CALL_OW 263
56854: PUSH
56855: LD_INT 1
56857: EQUAL
56858: IFFALSE 56874
// ComExitVehicle ( IsInUnit ( j ) ) ;
56860: LD_VAR 0 3
56864: PPUSH
56865: CALL_OW 310
56869: PPUSH
56870: CALL_OW 121
// if GetControl ( j ) = control_remote then
56874: LD_VAR 0 3
56878: PPUSH
56879: CALL_OW 263
56883: PUSH
56884: LD_INT 2
56886: EQUAL
56887: IFFALSE 56898
// ComUnlink ( j ) ;
56889: LD_VAR 0 3
56893: PPUSH
56894: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
56898: LD_ADDR_VAR 0 9
56902: PUSH
56903: LD_VAR 0 2
56907: PPUSH
56908: LD_INT 3
56910: PPUSH
56911: CALL 66488 0 2
56915: ST_TO_ADDR
// if fac then
56916: LD_VAR 0 9
56920: IFFALSE 57016
// begin for k in fac do
56922: LD_ADDR_VAR 0 4
56926: PUSH
56927: LD_VAR 0 9
56931: PUSH
56932: FOR_IN
56933: IFFALSE 57014
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
56935: LD_ADDR_VAR 0 10
56939: PUSH
56940: LD_VAR 0 9
56944: PPUSH
56945: LD_VAR 0 3
56949: PPUSH
56950: CALL_OW 265
56954: PPUSH
56955: LD_VAR 0 3
56959: PPUSH
56960: CALL_OW 262
56964: PPUSH
56965: LD_VAR 0 3
56969: PPUSH
56970: CALL_OW 263
56974: PPUSH
56975: LD_VAR 0 3
56979: PPUSH
56980: CALL_OW 264
56984: PPUSH
56985: CALL 6959 0 5
56989: ST_TO_ADDR
// if components then
56990: LD_VAR 0 10
56994: IFFALSE 57012
// begin MC_InsertProduceList ( i , components ) ;
56996: LD_VAR 0 2
57000: PPUSH
57001: LD_VAR 0 10
57005: PPUSH
57006: CALL 66033 0 2
// break ;
57010: GO 57014
// end ; end ;
57012: GO 56932
57014: POP
57015: POP
// end ; continue ;
57016: GO 56512
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
57018: LD_VAR 0 3
57022: PPUSH
57023: LD_INT 1
57025: PPUSH
57026: CALL_OW 289
57030: PUSH
57031: LD_INT 100
57033: LESS
57034: PUSH
57035: LD_VAR 0 3
57039: PPUSH
57040: CALL_OW 314
57044: NOT
57045: AND
57046: IFFALSE 57075
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
57048: LD_VAR 0 3
57052: PPUSH
57053: LD_VAR 0 6
57057: PUSH
57058: LD_INT 2
57060: ARRAY
57061: PPUSH
57062: LD_VAR 0 6
57066: PUSH
57067: LD_INT 3
57069: ARRAY
57070: PPUSH
57071: CALL_OW 117
// break ;
57075: GO 57079
// end ;
57077: GO 56512
57079: POP
57080: POP
// end ; end ;
57081: GO 55350
57083: POP
57084: POP
// end ;
57085: LD_VAR 0 1
57089: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
57090: LD_INT 0
57092: PPUSH
57093: PPUSH
57094: PPUSH
57095: PPUSH
// if not mc_bases then
57096: LD_EXP 14
57100: NOT
57101: IFFALSE 57105
// exit ;
57103: GO 57266
// for i = 1 to mc_bases do
57105: LD_ADDR_VAR 0 2
57109: PUSH
57110: DOUBLE
57111: LD_INT 1
57113: DEC
57114: ST_TO_ADDR
57115: LD_EXP 14
57119: PUSH
57120: FOR_TO
57121: IFFALSE 57264
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
57123: LD_ADDR_VAR 0 4
57127: PUSH
57128: LD_EXP 33
57132: PUSH
57133: LD_VAR 0 2
57137: ARRAY
57138: PUSH
57139: LD_EXP 36
57143: PUSH
57144: LD_VAR 0 2
57148: ARRAY
57149: UNION
57150: PPUSH
57151: LD_INT 33
57153: PUSH
57154: LD_INT 2
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PPUSH
57161: CALL_OW 72
57165: ST_TO_ADDR
// if tmp then
57166: LD_VAR 0 4
57170: IFFALSE 57262
// for j in tmp do
57172: LD_ADDR_VAR 0 3
57176: PUSH
57177: LD_VAR 0 4
57181: PUSH
57182: FOR_IN
57183: IFFALSE 57260
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
57185: LD_VAR 0 3
57189: PPUSH
57190: CALL_OW 312
57194: NOT
57195: PUSH
57196: LD_VAR 0 3
57200: PPUSH
57201: CALL_OW 256
57205: PUSH
57206: LD_INT 250
57208: GREATEREQUAL
57209: AND
57210: IFFALSE 57223
// Connect ( j ) else
57212: LD_VAR 0 3
57216: PPUSH
57217: CALL 12392 0 1
57221: GO 57258
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
57223: LD_VAR 0 3
57227: PPUSH
57228: CALL_OW 256
57232: PUSH
57233: LD_INT 250
57235: LESS
57236: PUSH
57237: LD_VAR 0 3
57241: PPUSH
57242: CALL_OW 312
57246: AND
57247: IFFALSE 57258
// ComUnlink ( j ) ;
57249: LD_VAR 0 3
57253: PPUSH
57254: CALL_OW 136
57258: GO 57182
57260: POP
57261: POP
// end ;
57262: GO 57120
57264: POP
57265: POP
// end ;
57266: LD_VAR 0 1
57270: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
57271: LD_INT 0
57273: PPUSH
57274: PPUSH
57275: PPUSH
57276: PPUSH
57277: PPUSH
// if not mc_bases then
57278: LD_EXP 14
57282: NOT
57283: IFFALSE 57287
// exit ;
57285: GO 57732
// for i = 1 to mc_bases do
57287: LD_ADDR_VAR 0 2
57291: PUSH
57292: DOUBLE
57293: LD_INT 1
57295: DEC
57296: ST_TO_ADDR
57297: LD_EXP 14
57301: PUSH
57302: FOR_TO
57303: IFFALSE 57730
// begin if not mc_produce [ i ] then
57305: LD_EXP 35
57309: PUSH
57310: LD_VAR 0 2
57314: ARRAY
57315: NOT
57316: IFFALSE 57320
// continue ;
57318: GO 57302
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
57320: LD_ADDR_VAR 0 5
57324: PUSH
57325: LD_EXP 14
57329: PUSH
57330: LD_VAR 0 2
57334: ARRAY
57335: PPUSH
57336: LD_INT 30
57338: PUSH
57339: LD_INT 3
57341: PUSH
57342: EMPTY
57343: LIST
57344: LIST
57345: PPUSH
57346: CALL_OW 72
57350: ST_TO_ADDR
// if not fac then
57351: LD_VAR 0 5
57355: NOT
57356: IFFALSE 57360
// continue ;
57358: GO 57302
// for j in fac do
57360: LD_ADDR_VAR 0 3
57364: PUSH
57365: LD_VAR 0 5
57369: PUSH
57370: FOR_IN
57371: IFFALSE 57726
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
57373: LD_VAR 0 3
57377: PPUSH
57378: CALL_OW 461
57382: PUSH
57383: LD_INT 2
57385: NONEQUAL
57386: PUSH
57387: LD_VAR 0 3
57391: PPUSH
57392: LD_INT 15
57394: PPUSH
57395: CALL 12020 0 2
57399: PUSH
57400: LD_INT 4
57402: ARRAY
57403: OR
57404: IFFALSE 57408
// continue ;
57406: GO 57370
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
57408: LD_VAR 0 3
57412: PPUSH
57413: LD_EXP 35
57417: PUSH
57418: LD_VAR 0 2
57422: ARRAY
57423: PUSH
57424: LD_INT 1
57426: ARRAY
57427: PUSH
57428: LD_INT 1
57430: ARRAY
57431: PPUSH
57432: LD_EXP 35
57436: PUSH
57437: LD_VAR 0 2
57441: ARRAY
57442: PUSH
57443: LD_INT 1
57445: ARRAY
57446: PUSH
57447: LD_INT 2
57449: ARRAY
57450: PPUSH
57451: LD_EXP 35
57455: PUSH
57456: LD_VAR 0 2
57460: ARRAY
57461: PUSH
57462: LD_INT 1
57464: ARRAY
57465: PUSH
57466: LD_INT 3
57468: ARRAY
57469: PPUSH
57470: LD_EXP 35
57474: PUSH
57475: LD_VAR 0 2
57479: ARRAY
57480: PUSH
57481: LD_INT 1
57483: ARRAY
57484: PUSH
57485: LD_INT 4
57487: ARRAY
57488: PPUSH
57489: CALL_OW 448
57493: PUSH
57494: LD_VAR 0 3
57498: PPUSH
57499: LD_EXP 35
57503: PUSH
57504: LD_VAR 0 2
57508: ARRAY
57509: PUSH
57510: LD_INT 1
57512: ARRAY
57513: PUSH
57514: LD_INT 1
57516: ARRAY
57517: PUSH
57518: LD_EXP 35
57522: PUSH
57523: LD_VAR 0 2
57527: ARRAY
57528: PUSH
57529: LD_INT 1
57531: ARRAY
57532: PUSH
57533: LD_INT 2
57535: ARRAY
57536: PUSH
57537: LD_EXP 35
57541: PUSH
57542: LD_VAR 0 2
57546: ARRAY
57547: PUSH
57548: LD_INT 1
57550: ARRAY
57551: PUSH
57552: LD_INT 3
57554: ARRAY
57555: PUSH
57556: LD_EXP 35
57560: PUSH
57561: LD_VAR 0 2
57565: ARRAY
57566: PUSH
57567: LD_INT 1
57569: ARRAY
57570: PUSH
57571: LD_INT 4
57573: ARRAY
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: LIST
57579: LIST
57580: PPUSH
57581: CALL 15818 0 2
57585: AND
57586: IFFALSE 57724
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
57588: LD_VAR 0 3
57592: PPUSH
57593: LD_EXP 35
57597: PUSH
57598: LD_VAR 0 2
57602: ARRAY
57603: PUSH
57604: LD_INT 1
57606: ARRAY
57607: PUSH
57608: LD_INT 1
57610: ARRAY
57611: PPUSH
57612: LD_EXP 35
57616: PUSH
57617: LD_VAR 0 2
57621: ARRAY
57622: PUSH
57623: LD_INT 1
57625: ARRAY
57626: PUSH
57627: LD_INT 2
57629: ARRAY
57630: PPUSH
57631: LD_EXP 35
57635: PUSH
57636: LD_VAR 0 2
57640: ARRAY
57641: PUSH
57642: LD_INT 1
57644: ARRAY
57645: PUSH
57646: LD_INT 3
57648: ARRAY
57649: PPUSH
57650: LD_EXP 35
57654: PUSH
57655: LD_VAR 0 2
57659: ARRAY
57660: PUSH
57661: LD_INT 1
57663: ARRAY
57664: PUSH
57665: LD_INT 4
57667: ARRAY
57668: PPUSH
57669: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
57673: LD_ADDR_VAR 0 4
57677: PUSH
57678: LD_EXP 35
57682: PUSH
57683: LD_VAR 0 2
57687: ARRAY
57688: PPUSH
57689: LD_INT 1
57691: PPUSH
57692: CALL_OW 3
57696: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
57697: LD_ADDR_EXP 35
57701: PUSH
57702: LD_EXP 35
57706: PPUSH
57707: LD_VAR 0 2
57711: PPUSH
57712: LD_VAR 0 4
57716: PPUSH
57717: CALL_OW 1
57721: ST_TO_ADDR
// break ;
57722: GO 57726
// end ; end ;
57724: GO 57370
57726: POP
57727: POP
// end ;
57728: GO 57302
57730: POP
57731: POP
// end ;
57732: LD_VAR 0 1
57736: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
57737: LD_INT 0
57739: PPUSH
57740: PPUSH
57741: PPUSH
// if not mc_bases then
57742: LD_EXP 14
57746: NOT
57747: IFFALSE 57751
// exit ;
57749: GO 57840
// for i = 1 to mc_bases do
57751: LD_ADDR_VAR 0 2
57755: PUSH
57756: DOUBLE
57757: LD_INT 1
57759: DEC
57760: ST_TO_ADDR
57761: LD_EXP 14
57765: PUSH
57766: FOR_TO
57767: IFFALSE 57838
// begin if mc_attack [ i ] then
57769: LD_EXP 34
57773: PUSH
57774: LD_VAR 0 2
57778: ARRAY
57779: IFFALSE 57836
// begin tmp := mc_attack [ i ] [ 1 ] ;
57781: LD_ADDR_VAR 0 3
57785: PUSH
57786: LD_EXP 34
57790: PUSH
57791: LD_VAR 0 2
57795: ARRAY
57796: PUSH
57797: LD_INT 1
57799: ARRAY
57800: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57801: LD_ADDR_EXP 34
57805: PUSH
57806: LD_EXP 34
57810: PPUSH
57811: LD_VAR 0 2
57815: PPUSH
57816: EMPTY
57817: PPUSH
57818: CALL_OW 1
57822: ST_TO_ADDR
// Attack ( tmp ) ;
57823: LD_VAR 0 3
57827: PPUSH
57828: CALL 72556 0 1
// exit ;
57832: POP
57833: POP
57834: GO 57840
// end ; end ;
57836: GO 57766
57838: POP
57839: POP
// end ;
57840: LD_VAR 0 1
57844: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
57845: LD_INT 0
57847: PPUSH
57848: PPUSH
57849: PPUSH
57850: PPUSH
57851: PPUSH
57852: PPUSH
57853: PPUSH
// if not mc_bases then
57854: LD_EXP 14
57858: NOT
57859: IFFALSE 57863
// exit ;
57861: GO 58562
// for i = 1 to mc_bases do
57863: LD_ADDR_VAR 0 2
57867: PUSH
57868: DOUBLE
57869: LD_INT 1
57871: DEC
57872: ST_TO_ADDR
57873: LD_EXP 14
57877: PUSH
57878: FOR_TO
57879: IFFALSE 58560
// begin if not mc_bases [ i ] then
57881: LD_EXP 14
57885: PUSH
57886: LD_VAR 0 2
57890: ARRAY
57891: NOT
57892: IFFALSE 57896
// continue ;
57894: GO 57878
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
57896: LD_ADDR_VAR 0 7
57900: PUSH
57901: LD_EXP 14
57905: PUSH
57906: LD_VAR 0 2
57910: ARRAY
57911: PUSH
57912: LD_INT 1
57914: ARRAY
57915: PPUSH
57916: CALL 6263 0 1
57920: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
57921: LD_ADDR_EXP 37
57925: PUSH
57926: LD_EXP 37
57930: PPUSH
57931: LD_VAR 0 2
57935: PPUSH
57936: LD_EXP 14
57940: PUSH
57941: LD_VAR 0 2
57945: ARRAY
57946: PUSH
57947: LD_INT 1
57949: ARRAY
57950: PPUSH
57951: CALL_OW 255
57955: PPUSH
57956: LD_EXP 39
57960: PUSH
57961: LD_VAR 0 2
57965: ARRAY
57966: PPUSH
57967: CALL 6228 0 2
57971: PPUSH
57972: CALL_OW 1
57976: ST_TO_ADDR
// if not mc_scan [ i ] then
57977: LD_EXP 37
57981: PUSH
57982: LD_VAR 0 2
57986: ARRAY
57987: NOT
57988: IFFALSE 58166
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
57990: LD_ADDR_VAR 0 4
57994: PUSH
57995: LD_EXP 14
57999: PUSH
58000: LD_VAR 0 2
58004: ARRAY
58005: PPUSH
58006: LD_INT 2
58008: PUSH
58009: LD_INT 25
58011: PUSH
58012: LD_INT 5
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: PUSH
58019: LD_INT 25
58021: PUSH
58022: LD_INT 8
58024: PUSH
58025: EMPTY
58026: LIST
58027: LIST
58028: PUSH
58029: LD_INT 25
58031: PUSH
58032: LD_INT 9
58034: PUSH
58035: EMPTY
58036: LIST
58037: LIST
58038: PUSH
58039: EMPTY
58040: LIST
58041: LIST
58042: LIST
58043: LIST
58044: PPUSH
58045: CALL_OW 72
58049: ST_TO_ADDR
// if not tmp then
58050: LD_VAR 0 4
58054: NOT
58055: IFFALSE 58059
// continue ;
58057: GO 57878
// for j in tmp do
58059: LD_ADDR_VAR 0 3
58063: PUSH
58064: LD_VAR 0 4
58068: PUSH
58069: FOR_IN
58070: IFFALSE 58141
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
58072: LD_VAR 0 3
58076: PPUSH
58077: CALL_OW 310
58081: PPUSH
58082: CALL_OW 266
58086: PUSH
58087: LD_INT 5
58089: EQUAL
58090: PUSH
58091: LD_VAR 0 3
58095: PPUSH
58096: CALL_OW 257
58100: PUSH
58101: LD_INT 1
58103: EQUAL
58104: AND
58105: PUSH
58106: LD_VAR 0 3
58110: PPUSH
58111: CALL_OW 459
58115: NOT
58116: AND
58117: PUSH
58118: LD_VAR 0 7
58122: AND
58123: IFFALSE 58139
// ComChangeProfession ( j , class ) ;
58125: LD_VAR 0 3
58129: PPUSH
58130: LD_VAR 0 7
58134: PPUSH
58135: CALL_OW 123
58139: GO 58069
58141: POP
58142: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58143: LD_ADDR_EXP 57
58147: PUSH
58148: LD_EXP 57
58152: PPUSH
58153: LD_VAR 0 2
58157: PPUSH
58158: LD_INT 0
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
58166: LD_EXP 37
58170: PUSH
58171: LD_VAR 0 2
58175: ARRAY
58176: PUSH
58177: LD_EXP 57
58181: PUSH
58182: LD_VAR 0 2
58186: ARRAY
58187: NOT
58188: AND
58189: PUSH
58190: LD_EXP 36
58194: PUSH
58195: LD_VAR 0 2
58199: ARRAY
58200: NOT
58201: AND
58202: PUSH
58203: LD_EXP 14
58207: PUSH
58208: LD_VAR 0 2
58212: ARRAY
58213: PPUSH
58214: LD_INT 30
58216: PUSH
58217: LD_INT 32
58219: PUSH
58220: EMPTY
58221: LIST
58222: LIST
58223: PPUSH
58224: CALL_OW 72
58228: NOT
58229: AND
58230: PUSH
58231: LD_EXP 14
58235: PUSH
58236: LD_VAR 0 2
58240: ARRAY
58241: PPUSH
58242: LD_INT 2
58244: PUSH
58245: LD_INT 30
58247: PUSH
58248: LD_INT 4
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: PUSH
58255: LD_INT 30
58257: PUSH
58258: LD_INT 5
58260: PUSH
58261: EMPTY
58262: LIST
58263: LIST
58264: PUSH
58265: EMPTY
58266: LIST
58267: LIST
58268: LIST
58269: PPUSH
58270: CALL_OW 72
58274: NOT
58275: AND
58276: IFFALSE 58431
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
58278: LD_ADDR_VAR 0 4
58282: PUSH
58283: LD_EXP 14
58287: PUSH
58288: LD_VAR 0 2
58292: ARRAY
58293: PPUSH
58294: LD_INT 2
58296: PUSH
58297: LD_INT 25
58299: PUSH
58300: LD_INT 1
58302: PUSH
58303: EMPTY
58304: LIST
58305: LIST
58306: PUSH
58307: LD_INT 25
58309: PUSH
58310: LD_INT 5
58312: PUSH
58313: EMPTY
58314: LIST
58315: LIST
58316: PUSH
58317: LD_INT 25
58319: PUSH
58320: LD_INT 8
58322: PUSH
58323: EMPTY
58324: LIST
58325: LIST
58326: PUSH
58327: LD_INT 25
58329: PUSH
58330: LD_INT 9
58332: PUSH
58333: EMPTY
58334: LIST
58335: LIST
58336: PUSH
58337: EMPTY
58338: LIST
58339: LIST
58340: LIST
58341: LIST
58342: LIST
58343: PPUSH
58344: CALL_OW 72
58348: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
58349: LD_ADDR_VAR 0 4
58353: PUSH
58354: LD_VAR 0 4
58358: PUSH
58359: LD_VAR 0 4
58363: PPUSH
58364: LD_INT 18
58366: PPUSH
58367: CALL 38321 0 2
58371: DIFF
58372: ST_TO_ADDR
// if tmp then
58373: LD_VAR 0 4
58377: IFFALSE 58431
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
58379: LD_ADDR_EXP 57
58383: PUSH
58384: LD_EXP 57
58388: PPUSH
58389: LD_VAR 0 2
58393: PPUSH
58394: LD_INT 1
58396: PPUSH
58397: CALL_OW 1
58401: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
58402: LD_VAR 0 2
58406: PPUSH
58407: LD_VAR 0 4
58411: PPUSH
58412: LD_EXP 39
58416: PUSH
58417: LD_VAR 0 2
58421: ARRAY
58422: PPUSH
58423: CALL 77265 0 3
// exit ;
58427: POP
58428: POP
58429: GO 58562
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
58431: LD_EXP 37
58435: PUSH
58436: LD_VAR 0 2
58440: ARRAY
58441: PUSH
58442: LD_EXP 57
58446: PUSH
58447: LD_VAR 0 2
58451: ARRAY
58452: NOT
58453: AND
58454: PUSH
58455: LD_EXP 36
58459: PUSH
58460: LD_VAR 0 2
58464: ARRAY
58465: AND
58466: IFFALSE 58558
// begin tmp := mc_defender [ i ] ;
58468: LD_ADDR_VAR 0 4
58472: PUSH
58473: LD_EXP 36
58477: PUSH
58478: LD_VAR 0 2
58482: ARRAY
58483: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58484: LD_ADDR_EXP 36
58488: PUSH
58489: LD_EXP 36
58493: PPUSH
58494: LD_VAR 0 2
58498: PPUSH
58499: EMPTY
58500: PPUSH
58501: CALL_OW 1
58505: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
58506: LD_ADDR_EXP 57
58510: PUSH
58511: LD_EXP 57
58515: PPUSH
58516: LD_VAR 0 2
58520: PPUSH
58521: LD_INT 1
58523: PPUSH
58524: CALL_OW 1
58528: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
58529: LD_VAR 0 2
58533: PPUSH
58534: LD_VAR 0 4
58538: PPUSH
58539: LD_EXP 37
58543: PUSH
58544: LD_VAR 0 2
58548: ARRAY
58549: PPUSH
58550: CALL 77826 0 3
// exit ;
58554: POP
58555: POP
58556: GO 58562
// end ; end ;
58558: GO 57878
58560: POP
58561: POP
// end ;
58562: LD_VAR 0 1
58566: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
58567: LD_INT 0
58569: PPUSH
58570: PPUSH
58571: PPUSH
58572: PPUSH
58573: PPUSH
58574: PPUSH
58575: PPUSH
58576: PPUSH
58577: PPUSH
58578: PPUSH
58579: PPUSH
// if not mc_bases then
58580: LD_EXP 14
58584: NOT
58585: IFFALSE 58589
// exit ;
58587: GO 59676
// for i = 1 to mc_bases do
58589: LD_ADDR_VAR 0 2
58593: PUSH
58594: DOUBLE
58595: LD_INT 1
58597: DEC
58598: ST_TO_ADDR
58599: LD_EXP 14
58603: PUSH
58604: FOR_TO
58605: IFFALSE 59674
// begin tmp := mc_lab [ i ] ;
58607: LD_ADDR_VAR 0 6
58611: PUSH
58612: LD_EXP 47
58616: PUSH
58617: LD_VAR 0 2
58621: ARRAY
58622: ST_TO_ADDR
// if not tmp then
58623: LD_VAR 0 6
58627: NOT
58628: IFFALSE 58632
// continue ;
58630: GO 58604
// idle_lab := 0 ;
58632: LD_ADDR_VAR 0 11
58636: PUSH
58637: LD_INT 0
58639: ST_TO_ADDR
// for j in tmp do
58640: LD_ADDR_VAR 0 3
58644: PUSH
58645: LD_VAR 0 6
58649: PUSH
58650: FOR_IN
58651: IFFALSE 59670
// begin researching := false ;
58653: LD_ADDR_VAR 0 10
58657: PUSH
58658: LD_INT 0
58660: ST_TO_ADDR
// side := GetSide ( j ) ;
58661: LD_ADDR_VAR 0 4
58665: PUSH
58666: LD_VAR 0 3
58670: PPUSH
58671: CALL_OW 255
58675: ST_TO_ADDR
// if not mc_tech [ side ] then
58676: LD_EXP 41
58680: PUSH
58681: LD_VAR 0 4
58685: ARRAY
58686: NOT
58687: IFFALSE 58691
// continue ;
58689: GO 58650
// if BuildingStatus ( j ) = bs_idle then
58691: LD_VAR 0 3
58695: PPUSH
58696: CALL_OW 461
58700: PUSH
58701: LD_INT 2
58703: EQUAL
58704: IFFALSE 58892
// begin if idle_lab and UnitsInside ( j ) < 6 then
58706: LD_VAR 0 11
58710: PUSH
58711: LD_VAR 0 3
58715: PPUSH
58716: CALL_OW 313
58720: PUSH
58721: LD_INT 6
58723: LESS
58724: AND
58725: IFFALSE 58796
// begin tmp2 := UnitsInside ( idle_lab ) ;
58727: LD_ADDR_VAR 0 9
58731: PUSH
58732: LD_VAR 0 11
58736: PPUSH
58737: CALL_OW 313
58741: ST_TO_ADDR
// if tmp2 then
58742: LD_VAR 0 9
58746: IFFALSE 58788
// for x in tmp2 do
58748: LD_ADDR_VAR 0 7
58752: PUSH
58753: LD_VAR 0 9
58757: PUSH
58758: FOR_IN
58759: IFFALSE 58786
// begin ComExitBuilding ( x ) ;
58761: LD_VAR 0 7
58765: PPUSH
58766: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
58770: LD_VAR 0 7
58774: PPUSH
58775: LD_VAR 0 3
58779: PPUSH
58780: CALL_OW 180
// end ;
58784: GO 58758
58786: POP
58787: POP
// idle_lab := 0 ;
58788: LD_ADDR_VAR 0 11
58792: PUSH
58793: LD_INT 0
58795: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
58796: LD_ADDR_VAR 0 5
58800: PUSH
58801: LD_EXP 41
58805: PUSH
58806: LD_VAR 0 4
58810: ARRAY
58811: PUSH
58812: FOR_IN
58813: IFFALSE 58873
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
58815: LD_VAR 0 3
58819: PPUSH
58820: LD_VAR 0 5
58824: PPUSH
58825: CALL_OW 430
58829: PUSH
58830: LD_VAR 0 4
58834: PPUSH
58835: LD_VAR 0 5
58839: PPUSH
58840: CALL 5333 0 2
58844: AND
58845: IFFALSE 58871
// begin researching := true ;
58847: LD_ADDR_VAR 0 10
58851: PUSH
58852: LD_INT 1
58854: ST_TO_ADDR
// ComResearch ( j , t ) ;
58855: LD_VAR 0 3
58859: PPUSH
58860: LD_VAR 0 5
58864: PPUSH
58865: CALL_OW 124
// break ;
58869: GO 58873
// end ;
58871: GO 58812
58873: POP
58874: POP
// if not researching then
58875: LD_VAR 0 10
58879: NOT
58880: IFFALSE 58892
// idle_lab := j ;
58882: LD_ADDR_VAR 0 11
58886: PUSH
58887: LD_VAR 0 3
58891: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
58892: LD_VAR 0 3
58896: PPUSH
58897: CALL_OW 461
58901: PUSH
58902: LD_INT 10
58904: EQUAL
58905: IFFALSE 59493
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
58907: LD_EXP 43
58911: PUSH
58912: LD_VAR 0 2
58916: ARRAY
58917: NOT
58918: PUSH
58919: LD_EXP 44
58923: PUSH
58924: LD_VAR 0 2
58928: ARRAY
58929: NOT
58930: AND
58931: PUSH
58932: LD_EXP 41
58936: PUSH
58937: LD_VAR 0 4
58941: ARRAY
58942: PUSH
58943: LD_INT 1
58945: GREATER
58946: AND
58947: IFFALSE 59078
// begin ComCancel ( j ) ;
58949: LD_VAR 0 3
58953: PPUSH
58954: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
58958: LD_ADDR_EXP 41
58962: PUSH
58963: LD_EXP 41
58967: PPUSH
58968: LD_VAR 0 4
58972: PPUSH
58973: LD_EXP 41
58977: PUSH
58978: LD_VAR 0 4
58982: ARRAY
58983: PPUSH
58984: LD_EXP 41
58988: PUSH
58989: LD_VAR 0 4
58993: ARRAY
58994: PUSH
58995: LD_INT 1
58997: MINUS
58998: PPUSH
58999: LD_EXP 41
59003: PUSH
59004: LD_VAR 0 4
59008: ARRAY
59009: PPUSH
59010: LD_INT 0
59012: PPUSH
59013: CALL 8845 0 4
59017: PPUSH
59018: CALL_OW 1
59022: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
59023: LD_ADDR_EXP 41
59027: PUSH
59028: LD_EXP 41
59032: PPUSH
59033: LD_VAR 0 4
59037: PPUSH
59038: LD_EXP 41
59042: PUSH
59043: LD_VAR 0 4
59047: ARRAY
59048: PPUSH
59049: LD_EXP 41
59053: PUSH
59054: LD_VAR 0 4
59058: ARRAY
59059: PPUSH
59060: LD_INT 1
59062: PPUSH
59063: LD_INT 0
59065: PPUSH
59066: CALL 8845 0 4
59070: PPUSH
59071: CALL_OW 1
59075: ST_TO_ADDR
// continue ;
59076: GO 58650
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
59078: LD_EXP 43
59082: PUSH
59083: LD_VAR 0 2
59087: ARRAY
59088: PUSH
59089: LD_EXP 44
59093: PUSH
59094: LD_VAR 0 2
59098: ARRAY
59099: NOT
59100: AND
59101: IFFALSE 59228
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
59103: LD_ADDR_EXP 44
59107: PUSH
59108: LD_EXP 44
59112: PPUSH
59113: LD_VAR 0 2
59117: PUSH
59118: LD_EXP 44
59122: PUSH
59123: LD_VAR 0 2
59127: ARRAY
59128: PUSH
59129: LD_INT 1
59131: PLUS
59132: PUSH
59133: EMPTY
59134: LIST
59135: LIST
59136: PPUSH
59137: LD_EXP 43
59141: PUSH
59142: LD_VAR 0 2
59146: ARRAY
59147: PUSH
59148: LD_INT 1
59150: ARRAY
59151: PPUSH
59152: CALL 9427 0 3
59156: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
59157: LD_EXP 43
59161: PUSH
59162: LD_VAR 0 2
59166: ARRAY
59167: PUSH
59168: LD_INT 1
59170: ARRAY
59171: PPUSH
59172: LD_INT 112
59174: PPUSH
59175: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
59179: LD_ADDR_VAR 0 9
59183: PUSH
59184: LD_EXP 43
59188: PUSH
59189: LD_VAR 0 2
59193: ARRAY
59194: PPUSH
59195: LD_INT 1
59197: PPUSH
59198: CALL_OW 3
59202: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
59203: LD_ADDR_EXP 43
59207: PUSH
59208: LD_EXP 43
59212: PPUSH
59213: LD_VAR 0 2
59217: PPUSH
59218: LD_VAR 0 9
59222: PPUSH
59223: CALL_OW 1
59227: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
59228: LD_EXP 43
59232: PUSH
59233: LD_VAR 0 2
59237: ARRAY
59238: PUSH
59239: LD_EXP 44
59243: PUSH
59244: LD_VAR 0 2
59248: ARRAY
59249: AND
59250: PUSH
59251: LD_EXP 44
59255: PUSH
59256: LD_VAR 0 2
59260: ARRAY
59261: PUSH
59262: LD_INT 1
59264: ARRAY
59265: PPUSH
59266: CALL_OW 310
59270: NOT
59271: AND
59272: PUSH
59273: LD_VAR 0 3
59277: PPUSH
59278: CALL_OW 313
59282: PUSH
59283: LD_INT 6
59285: EQUAL
59286: AND
59287: IFFALSE 59343
// begin tmp2 := UnitsInside ( j ) ;
59289: LD_ADDR_VAR 0 9
59293: PUSH
59294: LD_VAR 0 3
59298: PPUSH
59299: CALL_OW 313
59303: ST_TO_ADDR
// if tmp2 = 6 then
59304: LD_VAR 0 9
59308: PUSH
59309: LD_INT 6
59311: EQUAL
59312: IFFALSE 59343
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
59314: LD_VAR 0 9
59318: PUSH
59319: LD_INT 1
59321: ARRAY
59322: PPUSH
59323: LD_INT 112
59325: PPUSH
59326: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
59330: LD_VAR 0 9
59334: PUSH
59335: LD_INT 1
59337: ARRAY
59338: PPUSH
59339: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
59343: LD_EXP 44
59347: PUSH
59348: LD_VAR 0 2
59352: ARRAY
59353: PUSH
59354: LD_EXP 44
59358: PUSH
59359: LD_VAR 0 2
59363: ARRAY
59364: PUSH
59365: LD_INT 1
59367: ARRAY
59368: PPUSH
59369: CALL_OW 314
59373: NOT
59374: AND
59375: PUSH
59376: LD_EXP 44
59380: PUSH
59381: LD_VAR 0 2
59385: ARRAY
59386: PUSH
59387: LD_INT 1
59389: ARRAY
59390: PPUSH
59391: CALL_OW 310
59395: NOT
59396: AND
59397: IFFALSE 59423
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
59399: LD_EXP 44
59403: PUSH
59404: LD_VAR 0 2
59408: ARRAY
59409: PUSH
59410: LD_INT 1
59412: ARRAY
59413: PPUSH
59414: LD_VAR 0 3
59418: PPUSH
59419: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
59423: LD_EXP 44
59427: PUSH
59428: LD_VAR 0 2
59432: ARRAY
59433: PUSH
59434: LD_INT 1
59436: ARRAY
59437: PPUSH
59438: CALL_OW 310
59442: PUSH
59443: LD_EXP 44
59447: PUSH
59448: LD_VAR 0 2
59452: ARRAY
59453: PUSH
59454: LD_INT 1
59456: ARRAY
59457: PPUSH
59458: CALL_OW 310
59462: PPUSH
59463: CALL_OW 461
59467: PUSH
59468: LD_INT 3
59470: NONEQUAL
59471: AND
59472: IFFALSE 59493
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
59474: LD_EXP 44
59478: PUSH
59479: LD_VAR 0 2
59483: ARRAY
59484: PUSH
59485: LD_INT 1
59487: ARRAY
59488: PPUSH
59489: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
59493: LD_VAR 0 3
59497: PPUSH
59498: CALL_OW 461
59502: PUSH
59503: LD_INT 6
59505: EQUAL
59506: PUSH
59507: LD_VAR 0 6
59511: PUSH
59512: LD_INT 1
59514: GREATER
59515: AND
59516: IFFALSE 59668
// begin sci := [ ] ;
59518: LD_ADDR_VAR 0 8
59522: PUSH
59523: EMPTY
59524: ST_TO_ADDR
// for x in ( tmp diff j ) do
59525: LD_ADDR_VAR 0 7
59529: PUSH
59530: LD_VAR 0 6
59534: PUSH
59535: LD_VAR 0 3
59539: DIFF
59540: PUSH
59541: FOR_IN
59542: IFFALSE 59594
// begin if sci = 6 then
59544: LD_VAR 0 8
59548: PUSH
59549: LD_INT 6
59551: EQUAL
59552: IFFALSE 59556
// break ;
59554: GO 59594
// if BuildingStatus ( x ) = bs_idle then
59556: LD_VAR 0 7
59560: PPUSH
59561: CALL_OW 461
59565: PUSH
59566: LD_INT 2
59568: EQUAL
59569: IFFALSE 59592
// sci := sci ^ UnitsInside ( x ) ;
59571: LD_ADDR_VAR 0 8
59575: PUSH
59576: LD_VAR 0 8
59580: PUSH
59581: LD_VAR 0 7
59585: PPUSH
59586: CALL_OW 313
59590: ADD
59591: ST_TO_ADDR
// end ;
59592: GO 59541
59594: POP
59595: POP
// if not sci then
59596: LD_VAR 0 8
59600: NOT
59601: IFFALSE 59605
// continue ;
59603: GO 58650
// for x in sci do
59605: LD_ADDR_VAR 0 7
59609: PUSH
59610: LD_VAR 0 8
59614: PUSH
59615: FOR_IN
59616: IFFALSE 59666
// if IsInUnit ( x ) and not HasTask ( x ) then
59618: LD_VAR 0 7
59622: PPUSH
59623: CALL_OW 310
59627: PUSH
59628: LD_VAR 0 7
59632: PPUSH
59633: CALL_OW 314
59637: NOT
59638: AND
59639: IFFALSE 59664
// begin ComExitBuilding ( x ) ;
59641: LD_VAR 0 7
59645: PPUSH
59646: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
59650: LD_VAR 0 7
59654: PPUSH
59655: LD_VAR 0 3
59659: PPUSH
59660: CALL_OW 180
// end ;
59664: GO 59615
59666: POP
59667: POP
// end ; end ;
59668: GO 58650
59670: POP
59671: POP
// end ;
59672: GO 58604
59674: POP
59675: POP
// end ;
59676: LD_VAR 0 1
59680: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
59681: LD_INT 0
59683: PPUSH
59684: PPUSH
// if not mc_bases then
59685: LD_EXP 14
59689: NOT
59690: IFFALSE 59694
// exit ;
59692: GO 59775
// for i = 1 to mc_bases do
59694: LD_ADDR_VAR 0 2
59698: PUSH
59699: DOUBLE
59700: LD_INT 1
59702: DEC
59703: ST_TO_ADDR
59704: LD_EXP 14
59708: PUSH
59709: FOR_TO
59710: IFFALSE 59773
// if mc_mines [ i ] and mc_miners [ i ] then
59712: LD_EXP 27
59716: PUSH
59717: LD_VAR 0 2
59721: ARRAY
59722: PUSH
59723: LD_EXP 28
59727: PUSH
59728: LD_VAR 0 2
59732: ARRAY
59733: AND
59734: IFFALSE 59771
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
59736: LD_EXP 28
59740: PUSH
59741: LD_VAR 0 2
59745: ARRAY
59746: PUSH
59747: LD_INT 1
59749: ARRAY
59750: PPUSH
59751: CALL_OW 255
59755: PPUSH
59756: LD_EXP 27
59760: PUSH
59761: LD_VAR 0 2
59765: ARRAY
59766: PPUSH
59767: CALL 6416 0 2
59771: GO 59709
59773: POP
59774: POP
// end ;
59775: LD_VAR 0 1
59779: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
59780: LD_INT 0
59782: PPUSH
59783: PPUSH
59784: PPUSH
59785: PPUSH
59786: PPUSH
59787: PPUSH
59788: PPUSH
59789: PPUSH
// if not mc_bases or not mc_parking then
59790: LD_EXP 14
59794: NOT
59795: PUSH
59796: LD_EXP 38
59800: NOT
59801: OR
59802: IFFALSE 59806
// exit ;
59804: GO 60505
// for i = 1 to mc_bases do
59806: LD_ADDR_VAR 0 2
59810: PUSH
59811: DOUBLE
59812: LD_INT 1
59814: DEC
59815: ST_TO_ADDR
59816: LD_EXP 14
59820: PUSH
59821: FOR_TO
59822: IFFALSE 60503
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
59824: LD_EXP 14
59828: PUSH
59829: LD_VAR 0 2
59833: ARRAY
59834: NOT
59835: PUSH
59836: LD_EXP 38
59840: PUSH
59841: LD_VAR 0 2
59845: ARRAY
59846: NOT
59847: OR
59848: IFFALSE 59852
// continue ;
59850: GO 59821
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
59852: LD_ADDR_VAR 0 5
59856: PUSH
59857: LD_EXP 14
59861: PUSH
59862: LD_VAR 0 2
59866: ARRAY
59867: PUSH
59868: LD_INT 1
59870: ARRAY
59871: PPUSH
59872: CALL_OW 255
59876: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59877: LD_ADDR_VAR 0 6
59881: PUSH
59882: LD_EXP 14
59886: PUSH
59887: LD_VAR 0 2
59891: ARRAY
59892: PPUSH
59893: LD_INT 30
59895: PUSH
59896: LD_INT 3
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PPUSH
59903: CALL_OW 72
59907: ST_TO_ADDR
// if not fac then
59908: LD_VAR 0 6
59912: NOT
59913: IFFALSE 59964
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59915: LD_ADDR_VAR 0 6
59919: PUSH
59920: LD_EXP 14
59924: PUSH
59925: LD_VAR 0 2
59929: ARRAY
59930: PPUSH
59931: LD_INT 2
59933: PUSH
59934: LD_INT 30
59936: PUSH
59937: LD_INT 0
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: PUSH
59944: LD_INT 30
59946: PUSH
59947: LD_INT 1
59949: PUSH
59950: EMPTY
59951: LIST
59952: LIST
59953: PUSH
59954: EMPTY
59955: LIST
59956: LIST
59957: LIST
59958: PPUSH
59959: CALL_OW 72
59963: ST_TO_ADDR
// if not fac then
59964: LD_VAR 0 6
59968: NOT
59969: IFFALSE 59973
// continue ;
59971: GO 59821
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59973: LD_ADDR_VAR 0 7
59977: PUSH
59978: LD_EXP 38
59982: PUSH
59983: LD_VAR 0 2
59987: ARRAY
59988: PPUSH
59989: LD_INT 22
59991: PUSH
59992: LD_VAR 0 5
59996: PUSH
59997: EMPTY
59998: LIST
59999: LIST
60000: PUSH
60001: LD_INT 21
60003: PUSH
60004: LD_INT 2
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 3
60013: PUSH
60014: LD_INT 24
60016: PUSH
60017: LD_INT 1000
60019: PUSH
60020: EMPTY
60021: LIST
60022: LIST
60023: PUSH
60024: EMPTY
60025: LIST
60026: LIST
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: LIST
60032: PPUSH
60033: CALL_OW 70
60037: ST_TO_ADDR
// for j in fac do
60038: LD_ADDR_VAR 0 3
60042: PUSH
60043: LD_VAR 0 6
60047: PUSH
60048: FOR_IN
60049: IFFALSE 60130
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60051: LD_ADDR_VAR 0 7
60055: PUSH
60056: LD_VAR 0 7
60060: PUSH
60061: LD_INT 22
60063: PUSH
60064: LD_VAR 0 5
60068: PUSH
60069: EMPTY
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 91
60075: PUSH
60076: LD_VAR 0 3
60080: PUSH
60081: LD_INT 15
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: LIST
60088: PUSH
60089: LD_INT 21
60091: PUSH
60092: LD_INT 2
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: PUSH
60099: LD_INT 3
60101: PUSH
60102: LD_INT 24
60104: PUSH
60105: LD_INT 1000
60107: PUSH
60108: EMPTY
60109: LIST
60110: LIST
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: EMPTY
60117: LIST
60118: LIST
60119: LIST
60120: LIST
60121: PPUSH
60122: CALL_OW 69
60126: UNION
60127: ST_TO_ADDR
60128: GO 60048
60130: POP
60131: POP
// if not vehs then
60132: LD_VAR 0 7
60136: NOT
60137: IFFALSE 60163
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
60139: LD_ADDR_EXP 26
60143: PUSH
60144: LD_EXP 26
60148: PPUSH
60149: LD_VAR 0 2
60153: PPUSH
60154: EMPTY
60155: PPUSH
60156: CALL_OW 1
60160: ST_TO_ADDR
// continue ;
60161: GO 59821
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
60163: LD_ADDR_VAR 0 8
60167: PUSH
60168: LD_EXP 14
60172: PUSH
60173: LD_VAR 0 2
60177: ARRAY
60178: PPUSH
60179: LD_INT 30
60181: PUSH
60182: LD_INT 3
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PPUSH
60189: CALL_OW 72
60193: ST_TO_ADDR
// if tmp then
60194: LD_VAR 0 8
60198: IFFALSE 60301
// begin for j in tmp do
60200: LD_ADDR_VAR 0 3
60204: PUSH
60205: LD_VAR 0 8
60209: PUSH
60210: FOR_IN
60211: IFFALSE 60299
// for k in UnitsInside ( j ) do
60213: LD_ADDR_VAR 0 4
60217: PUSH
60218: LD_VAR 0 3
60222: PPUSH
60223: CALL_OW 313
60227: PUSH
60228: FOR_IN
60229: IFFALSE 60295
// if k then
60231: LD_VAR 0 4
60235: IFFALSE 60293
// if not k in mc_repair_vehicle [ i ] then
60237: LD_VAR 0 4
60241: PUSH
60242: LD_EXP 26
60246: PUSH
60247: LD_VAR 0 2
60251: ARRAY
60252: IN
60253: NOT
60254: IFFALSE 60293
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
60256: LD_ADDR_EXP 26
60260: PUSH
60261: LD_EXP 26
60265: PPUSH
60266: LD_VAR 0 2
60270: PPUSH
60271: LD_EXP 26
60275: PUSH
60276: LD_VAR 0 2
60280: ARRAY
60281: PUSH
60282: LD_VAR 0 4
60286: UNION
60287: PPUSH
60288: CALL_OW 1
60292: ST_TO_ADDR
60293: GO 60228
60295: POP
60296: POP
60297: GO 60210
60299: POP
60300: POP
// end ; if not mc_repair_vehicle [ i ] then
60301: LD_EXP 26
60305: PUSH
60306: LD_VAR 0 2
60310: ARRAY
60311: NOT
60312: IFFALSE 60316
// continue ;
60314: GO 59821
// for j in mc_repair_vehicle [ i ] do
60316: LD_ADDR_VAR 0 3
60320: PUSH
60321: LD_EXP 26
60325: PUSH
60326: LD_VAR 0 2
60330: ARRAY
60331: PUSH
60332: FOR_IN
60333: IFFALSE 60499
// begin if GetClass ( j ) <> 3 then
60335: LD_VAR 0 3
60339: PPUSH
60340: CALL_OW 257
60344: PUSH
60345: LD_INT 3
60347: NONEQUAL
60348: IFFALSE 60389
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
60350: LD_ADDR_EXP 26
60354: PUSH
60355: LD_EXP 26
60359: PPUSH
60360: LD_VAR 0 2
60364: PPUSH
60365: LD_EXP 26
60369: PUSH
60370: LD_VAR 0 2
60374: ARRAY
60375: PUSH
60376: LD_VAR 0 3
60380: DIFF
60381: PPUSH
60382: CALL_OW 1
60386: ST_TO_ADDR
// continue ;
60387: GO 60332
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
60389: LD_VAR 0 3
60393: PPUSH
60394: CALL_OW 311
60398: NOT
60399: PUSH
60400: LD_VAR 0 3
60404: PUSH
60405: LD_EXP 17
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PUSH
60416: LD_INT 1
60418: ARRAY
60419: IN
60420: NOT
60421: AND
60422: PUSH
60423: LD_VAR 0 3
60427: PUSH
60428: LD_EXP 17
60432: PUSH
60433: LD_VAR 0 2
60437: ARRAY
60438: PUSH
60439: LD_INT 2
60441: ARRAY
60442: IN
60443: NOT
60444: AND
60445: IFFALSE 60497
// begin if IsInUnit ( j ) then
60447: LD_VAR 0 3
60451: PPUSH
60452: CALL_OW 310
60456: IFFALSE 60467
// ComExitBuilding ( j ) ;
60458: LD_VAR 0 3
60462: PPUSH
60463: CALL_OW 122
// if not HasTask ( j ) then
60467: LD_VAR 0 3
60471: PPUSH
60472: CALL_OW 314
60476: NOT
60477: IFFALSE 60497
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
60479: LD_VAR 0 3
60483: PPUSH
60484: LD_VAR 0 7
60488: PUSH
60489: LD_INT 1
60491: ARRAY
60492: PPUSH
60493: CALL_OW 189
// end ; end ;
60497: GO 60332
60499: POP
60500: POP
// end ;
60501: GO 59821
60503: POP
60504: POP
// end ;
60505: LD_VAR 0 1
60509: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
60510: LD_INT 0
60512: PPUSH
60513: PPUSH
60514: PPUSH
60515: PPUSH
60516: PPUSH
60517: PPUSH
60518: PPUSH
60519: PPUSH
60520: PPUSH
60521: PPUSH
60522: PPUSH
// if not mc_bases then
60523: LD_EXP 14
60527: NOT
60528: IFFALSE 60532
// exit ;
60530: GO 61334
// for i = 1 to mc_bases do
60532: LD_ADDR_VAR 0 2
60536: PUSH
60537: DOUBLE
60538: LD_INT 1
60540: DEC
60541: ST_TO_ADDR
60542: LD_EXP 14
60546: PUSH
60547: FOR_TO
60548: IFFALSE 61332
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
60550: LD_EXP 42
60554: PUSH
60555: LD_VAR 0 2
60559: ARRAY
60560: NOT
60561: PUSH
60562: LD_EXP 17
60566: PUSH
60567: LD_VAR 0 2
60571: ARRAY
60572: PUSH
60573: LD_INT 1
60575: ARRAY
60576: OR
60577: PUSH
60578: LD_EXP 17
60582: PUSH
60583: LD_VAR 0 2
60587: ARRAY
60588: PUSH
60589: LD_INT 2
60591: ARRAY
60592: OR
60593: PUSH
60594: LD_EXP 40
60598: PUSH
60599: LD_VAR 0 2
60603: ARRAY
60604: PPUSH
60605: LD_INT 1
60607: PPUSH
60608: CALL_OW 325
60612: NOT
60613: OR
60614: PUSH
60615: LD_EXP 37
60619: PUSH
60620: LD_VAR 0 2
60624: ARRAY
60625: OR
60626: IFFALSE 60630
// continue ;
60628: GO 60547
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
60630: LD_ADDR_VAR 0 8
60634: PUSH
60635: LD_EXP 14
60639: PUSH
60640: LD_VAR 0 2
60644: ARRAY
60645: PPUSH
60646: LD_INT 25
60648: PUSH
60649: LD_INT 4
60651: PUSH
60652: EMPTY
60653: LIST
60654: LIST
60655: PUSH
60656: LD_INT 50
60658: PUSH
60659: EMPTY
60660: LIST
60661: PUSH
60662: LD_INT 3
60664: PUSH
60665: LD_INT 60
60667: PUSH
60668: EMPTY
60669: LIST
60670: PUSH
60671: EMPTY
60672: LIST
60673: LIST
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: LIST
60679: PPUSH
60680: CALL_OW 72
60684: PUSH
60685: LD_EXP 18
60689: PUSH
60690: LD_VAR 0 2
60694: ARRAY
60695: DIFF
60696: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60697: LD_ADDR_VAR 0 9
60701: PUSH
60702: LD_EXP 14
60706: PUSH
60707: LD_VAR 0 2
60711: ARRAY
60712: PPUSH
60713: LD_INT 2
60715: PUSH
60716: LD_INT 30
60718: PUSH
60719: LD_INT 0
60721: PUSH
60722: EMPTY
60723: LIST
60724: LIST
60725: PUSH
60726: LD_INT 30
60728: PUSH
60729: LD_INT 1
60731: PUSH
60732: EMPTY
60733: LIST
60734: LIST
60735: PUSH
60736: EMPTY
60737: LIST
60738: LIST
60739: LIST
60740: PPUSH
60741: CALL_OW 72
60745: ST_TO_ADDR
// if not tmp or not dep then
60746: LD_VAR 0 8
60750: NOT
60751: PUSH
60752: LD_VAR 0 9
60756: NOT
60757: OR
60758: IFFALSE 60762
// continue ;
60760: GO 60547
// side := GetSide ( tmp [ 1 ] ) ;
60762: LD_ADDR_VAR 0 11
60766: PUSH
60767: LD_VAR 0 8
60771: PUSH
60772: LD_INT 1
60774: ARRAY
60775: PPUSH
60776: CALL_OW 255
60780: ST_TO_ADDR
// dep := dep [ 1 ] ;
60781: LD_ADDR_VAR 0 9
60785: PUSH
60786: LD_VAR 0 9
60790: PUSH
60791: LD_INT 1
60793: ARRAY
60794: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
60795: LD_ADDR_VAR 0 7
60799: PUSH
60800: LD_EXP 42
60804: PUSH
60805: LD_VAR 0 2
60809: ARRAY
60810: PPUSH
60811: LD_INT 22
60813: PUSH
60814: LD_INT 0
60816: PUSH
60817: EMPTY
60818: LIST
60819: LIST
60820: PUSH
60821: LD_INT 25
60823: PUSH
60824: LD_INT 12
60826: PUSH
60827: EMPTY
60828: LIST
60829: LIST
60830: PUSH
60831: EMPTY
60832: LIST
60833: LIST
60834: PPUSH
60835: CALL_OW 70
60839: PUSH
60840: LD_INT 22
60842: PUSH
60843: LD_INT 0
60845: PUSH
60846: EMPTY
60847: LIST
60848: LIST
60849: PUSH
60850: LD_INT 25
60852: PUSH
60853: LD_INT 12
60855: PUSH
60856: EMPTY
60857: LIST
60858: LIST
60859: PUSH
60860: LD_INT 91
60862: PUSH
60863: LD_VAR 0 9
60867: PUSH
60868: LD_INT 20
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: LIST
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: LIST
60880: PPUSH
60881: CALL_OW 69
60885: UNION
60886: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
60887: LD_ADDR_VAR 0 10
60891: PUSH
60892: LD_EXP 42
60896: PUSH
60897: LD_VAR 0 2
60901: ARRAY
60902: PPUSH
60903: LD_INT 81
60905: PUSH
60906: LD_VAR 0 11
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: PPUSH
60915: CALL_OW 70
60919: ST_TO_ADDR
// if not apes or danger_at_area then
60920: LD_VAR 0 7
60924: NOT
60925: PUSH
60926: LD_VAR 0 10
60930: OR
60931: IFFALSE 60981
// begin if mc_taming [ i ] then
60933: LD_EXP 45
60937: PUSH
60938: LD_VAR 0 2
60942: ARRAY
60943: IFFALSE 60979
// begin MC_Reset ( i , 121 ) ;
60945: LD_VAR 0 2
60949: PPUSH
60950: LD_INT 121
60952: PPUSH
60953: CALL 46268 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60957: LD_ADDR_EXP 45
60961: PUSH
60962: LD_EXP 45
60966: PPUSH
60967: LD_VAR 0 2
60971: PPUSH
60972: EMPTY
60973: PPUSH
60974: CALL_OW 1
60978: ST_TO_ADDR
// end ; continue ;
60979: GO 60547
// end ; for j in tmp do
60981: LD_ADDR_VAR 0 3
60985: PUSH
60986: LD_VAR 0 8
60990: PUSH
60991: FOR_IN
60992: IFFALSE 61328
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
60994: LD_VAR 0 3
60998: PUSH
60999: LD_EXP 45
61003: PUSH
61004: LD_VAR 0 2
61008: ARRAY
61009: IN
61010: NOT
61011: PUSH
61012: LD_EXP 45
61016: PUSH
61017: LD_VAR 0 2
61021: ARRAY
61022: PUSH
61023: LD_INT 3
61025: LESS
61026: AND
61027: IFFALSE 61085
// begin SetTag ( j , 121 ) ;
61029: LD_VAR 0 3
61033: PPUSH
61034: LD_INT 121
61036: PPUSH
61037: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
61041: LD_ADDR_EXP 45
61045: PUSH
61046: LD_EXP 45
61050: PPUSH
61051: LD_VAR 0 2
61055: PUSH
61056: LD_EXP 45
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: PUSH
61067: LD_INT 1
61069: PLUS
61070: PUSH
61071: EMPTY
61072: LIST
61073: LIST
61074: PPUSH
61075: LD_VAR 0 3
61079: PPUSH
61080: CALL 9427 0 3
61084: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
61085: LD_VAR 0 3
61089: PUSH
61090: LD_EXP 45
61094: PUSH
61095: LD_VAR 0 2
61099: ARRAY
61100: IN
61101: IFFALSE 61326
// begin if GetClass ( j ) <> 4 then
61103: LD_VAR 0 3
61107: PPUSH
61108: CALL_OW 257
61112: PUSH
61113: LD_INT 4
61115: NONEQUAL
61116: IFFALSE 61169
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
61118: LD_ADDR_EXP 45
61122: PUSH
61123: LD_EXP 45
61127: PPUSH
61128: LD_VAR 0 2
61132: PPUSH
61133: LD_EXP 45
61137: PUSH
61138: LD_VAR 0 2
61142: ARRAY
61143: PUSH
61144: LD_VAR 0 3
61148: DIFF
61149: PPUSH
61150: CALL_OW 1
61154: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61155: LD_VAR 0 3
61159: PPUSH
61160: LD_INT 0
61162: PPUSH
61163: CALL_OW 109
// continue ;
61167: GO 60991
// end ; if IsInUnit ( j ) then
61169: LD_VAR 0 3
61173: PPUSH
61174: CALL_OW 310
61178: IFFALSE 61189
// ComExitBuilding ( j ) ;
61180: LD_VAR 0 3
61184: PPUSH
61185: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
61189: LD_ADDR_VAR 0 6
61193: PUSH
61194: LD_VAR 0 7
61198: PPUSH
61199: LD_VAR 0 3
61203: PPUSH
61204: CALL_OW 74
61208: ST_TO_ADDR
// if not ape then
61209: LD_VAR 0 6
61213: NOT
61214: IFFALSE 61218
// break ;
61216: GO 61328
// x := GetX ( ape ) ;
61218: LD_ADDR_VAR 0 4
61222: PUSH
61223: LD_VAR 0 6
61227: PPUSH
61228: CALL_OW 250
61232: ST_TO_ADDR
// y := GetY ( ape ) ;
61233: LD_ADDR_VAR 0 5
61237: PUSH
61238: LD_VAR 0 6
61242: PPUSH
61243: CALL_OW 251
61247: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
61248: LD_VAR 0 4
61252: PPUSH
61253: LD_VAR 0 5
61257: PPUSH
61258: CALL_OW 488
61262: NOT
61263: PUSH
61264: LD_VAR 0 11
61268: PPUSH
61269: LD_VAR 0 4
61273: PPUSH
61274: LD_VAR 0 5
61278: PPUSH
61279: LD_INT 20
61281: PPUSH
61282: CALL 10323 0 4
61286: PUSH
61287: LD_INT 4
61289: ARRAY
61290: OR
61291: IFFALSE 61295
// break ;
61293: GO 61328
// if not HasTask ( j ) then
61295: LD_VAR 0 3
61299: PPUSH
61300: CALL_OW 314
61304: NOT
61305: IFFALSE 61326
// ComTameXY ( j , x , y ) ;
61307: LD_VAR 0 3
61311: PPUSH
61312: LD_VAR 0 4
61316: PPUSH
61317: LD_VAR 0 5
61321: PPUSH
61322: CALL_OW 131
// end ; end ;
61326: GO 60991
61328: POP
61329: POP
// end ;
61330: GO 60547
61332: POP
61333: POP
// end ;
61334: LD_VAR 0 1
61338: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
61339: LD_INT 0
61341: PPUSH
61342: PPUSH
61343: PPUSH
61344: PPUSH
61345: PPUSH
61346: PPUSH
61347: PPUSH
61348: PPUSH
// if not mc_bases then
61349: LD_EXP 14
61353: NOT
61354: IFFALSE 61358
// exit ;
61356: GO 61984
// for i = 1 to mc_bases do
61358: LD_ADDR_VAR 0 2
61362: PUSH
61363: DOUBLE
61364: LD_INT 1
61366: DEC
61367: ST_TO_ADDR
61368: LD_EXP 14
61372: PUSH
61373: FOR_TO
61374: IFFALSE 61982
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
61376: LD_EXP 43
61380: PUSH
61381: LD_VAR 0 2
61385: ARRAY
61386: NOT
61387: PUSH
61388: LD_EXP 43
61392: PUSH
61393: LD_VAR 0 2
61397: ARRAY
61398: PPUSH
61399: LD_INT 25
61401: PUSH
61402: LD_INT 12
61404: PUSH
61405: EMPTY
61406: LIST
61407: LIST
61408: PPUSH
61409: CALL_OW 72
61413: NOT
61414: OR
61415: IFFALSE 61419
// continue ;
61417: GO 61373
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
61419: LD_ADDR_VAR 0 5
61423: PUSH
61424: LD_EXP 43
61428: PUSH
61429: LD_VAR 0 2
61433: ARRAY
61434: PUSH
61435: LD_INT 1
61437: ARRAY
61438: PPUSH
61439: CALL_OW 255
61443: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
61444: LD_VAR 0 5
61448: PPUSH
61449: LD_INT 2
61451: PPUSH
61452: CALL_OW 325
61456: IFFALSE 61709
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
61458: LD_ADDR_VAR 0 4
61462: PUSH
61463: LD_EXP 43
61467: PUSH
61468: LD_VAR 0 2
61472: ARRAY
61473: PPUSH
61474: LD_INT 25
61476: PUSH
61477: LD_INT 16
61479: PUSH
61480: EMPTY
61481: LIST
61482: LIST
61483: PPUSH
61484: CALL_OW 72
61488: ST_TO_ADDR
// if tmp < 6 then
61489: LD_VAR 0 4
61493: PUSH
61494: LD_INT 6
61496: LESS
61497: IFFALSE 61709
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61499: LD_ADDR_VAR 0 6
61503: PUSH
61504: LD_EXP 14
61508: PUSH
61509: LD_VAR 0 2
61513: ARRAY
61514: PPUSH
61515: LD_INT 2
61517: PUSH
61518: LD_INT 30
61520: PUSH
61521: LD_INT 0
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 30
61530: PUSH
61531: LD_INT 1
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: LIST
61542: PPUSH
61543: CALL_OW 72
61547: ST_TO_ADDR
// if depot then
61548: LD_VAR 0 6
61552: IFFALSE 61709
// begin selected := 0 ;
61554: LD_ADDR_VAR 0 7
61558: PUSH
61559: LD_INT 0
61561: ST_TO_ADDR
// for j in depot do
61562: LD_ADDR_VAR 0 3
61566: PUSH
61567: LD_VAR 0 6
61571: PUSH
61572: FOR_IN
61573: IFFALSE 61604
// begin if UnitsInside ( j ) < 6 then
61575: LD_VAR 0 3
61579: PPUSH
61580: CALL_OW 313
61584: PUSH
61585: LD_INT 6
61587: LESS
61588: IFFALSE 61602
// begin selected := j ;
61590: LD_ADDR_VAR 0 7
61594: PUSH
61595: LD_VAR 0 3
61599: ST_TO_ADDR
// break ;
61600: GO 61604
// end ; end ;
61602: GO 61572
61604: POP
61605: POP
// if selected then
61606: LD_VAR 0 7
61610: IFFALSE 61709
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
61612: LD_ADDR_VAR 0 3
61616: PUSH
61617: LD_EXP 43
61621: PUSH
61622: LD_VAR 0 2
61626: ARRAY
61627: PPUSH
61628: LD_INT 25
61630: PUSH
61631: LD_INT 12
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: PPUSH
61638: CALL_OW 72
61642: PUSH
61643: FOR_IN
61644: IFFALSE 61707
// if not HasTask ( j ) then
61646: LD_VAR 0 3
61650: PPUSH
61651: CALL_OW 314
61655: NOT
61656: IFFALSE 61705
// begin if not IsInUnit ( j ) then
61658: LD_VAR 0 3
61662: PPUSH
61663: CALL_OW 310
61667: NOT
61668: IFFALSE 61684
// ComEnterUnit ( j , selected ) ;
61670: LD_VAR 0 3
61674: PPUSH
61675: LD_VAR 0 7
61679: PPUSH
61680: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
61684: LD_VAR 0 3
61688: PPUSH
61689: LD_INT 16
61691: PPUSH
61692: CALL_OW 183
// AddComExitBuilding ( j ) ;
61696: LD_VAR 0 3
61700: PPUSH
61701: CALL_OW 182
// end ;
61705: GO 61643
61707: POP
61708: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
61709: LD_VAR 0 5
61713: PPUSH
61714: LD_INT 11
61716: PPUSH
61717: CALL_OW 325
61721: IFFALSE 61980
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
61723: LD_ADDR_VAR 0 4
61727: PUSH
61728: LD_EXP 43
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PPUSH
61739: LD_INT 25
61741: PUSH
61742: LD_INT 16
61744: PUSH
61745: EMPTY
61746: LIST
61747: LIST
61748: PPUSH
61749: CALL_OW 72
61753: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
61754: LD_VAR 0 4
61758: PUSH
61759: LD_INT 6
61761: GREATEREQUAL
61762: PUSH
61763: LD_VAR 0 5
61767: PPUSH
61768: LD_INT 2
61770: PPUSH
61771: CALL_OW 325
61775: NOT
61776: OR
61777: IFFALSE 61980
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61779: LD_ADDR_VAR 0 8
61783: PUSH
61784: LD_EXP 14
61788: PUSH
61789: LD_VAR 0 2
61793: ARRAY
61794: PPUSH
61795: LD_INT 2
61797: PUSH
61798: LD_INT 30
61800: PUSH
61801: LD_INT 4
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PUSH
61808: LD_INT 30
61810: PUSH
61811: LD_INT 5
61813: PUSH
61814: EMPTY
61815: LIST
61816: LIST
61817: PUSH
61818: EMPTY
61819: LIST
61820: LIST
61821: LIST
61822: PPUSH
61823: CALL_OW 72
61827: ST_TO_ADDR
// if barracks then
61828: LD_VAR 0 8
61832: IFFALSE 61980
// begin selected := 0 ;
61834: LD_ADDR_VAR 0 7
61838: PUSH
61839: LD_INT 0
61841: ST_TO_ADDR
// for j in barracks do
61842: LD_ADDR_VAR 0 3
61846: PUSH
61847: LD_VAR 0 8
61851: PUSH
61852: FOR_IN
61853: IFFALSE 61884
// begin if UnitsInside ( j ) < 6 then
61855: LD_VAR 0 3
61859: PPUSH
61860: CALL_OW 313
61864: PUSH
61865: LD_INT 6
61867: LESS
61868: IFFALSE 61882
// begin selected := j ;
61870: LD_ADDR_VAR 0 7
61874: PUSH
61875: LD_VAR 0 3
61879: ST_TO_ADDR
// break ;
61880: GO 61884
// end ; end ;
61882: GO 61852
61884: POP
61885: POP
// if selected then
61886: LD_VAR 0 7
61890: IFFALSE 61980
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
61892: LD_ADDR_VAR 0 3
61896: PUSH
61897: LD_EXP 43
61901: PUSH
61902: LD_VAR 0 2
61906: ARRAY
61907: PPUSH
61908: LD_INT 25
61910: PUSH
61911: LD_INT 12
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PPUSH
61918: CALL_OW 72
61922: PUSH
61923: FOR_IN
61924: IFFALSE 61978
// if not IsInUnit ( j ) and not HasTask ( j ) then
61926: LD_VAR 0 3
61930: PPUSH
61931: CALL_OW 310
61935: NOT
61936: PUSH
61937: LD_VAR 0 3
61941: PPUSH
61942: CALL_OW 314
61946: NOT
61947: AND
61948: IFFALSE 61976
// begin ComEnterUnit ( j , selected ) ;
61950: LD_VAR 0 3
61954: PPUSH
61955: LD_VAR 0 7
61959: PPUSH
61960: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
61964: LD_VAR 0 3
61968: PPUSH
61969: LD_INT 15
61971: PPUSH
61972: CALL_OW 183
// end ;
61976: GO 61923
61978: POP
61979: POP
// end ; end ; end ; end ; end ;
61980: GO 61373
61982: POP
61983: POP
// end ;
61984: LD_VAR 0 1
61988: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
61989: LD_INT 0
61991: PPUSH
61992: PPUSH
61993: PPUSH
61994: PPUSH
// if not mc_bases then
61995: LD_EXP 14
61999: NOT
62000: IFFALSE 62004
// exit ;
62002: GO 62182
// for i = 1 to mc_bases do
62004: LD_ADDR_VAR 0 2
62008: PUSH
62009: DOUBLE
62010: LD_INT 1
62012: DEC
62013: ST_TO_ADDR
62014: LD_EXP 14
62018: PUSH
62019: FOR_TO
62020: IFFALSE 62180
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
62022: LD_ADDR_VAR 0 4
62026: PUSH
62027: LD_EXP 14
62031: PUSH
62032: LD_VAR 0 2
62036: ARRAY
62037: PPUSH
62038: LD_INT 25
62040: PUSH
62041: LD_INT 9
62043: PUSH
62044: EMPTY
62045: LIST
62046: LIST
62047: PPUSH
62048: CALL_OW 72
62052: ST_TO_ADDR
// if not tmp then
62053: LD_VAR 0 4
62057: NOT
62058: IFFALSE 62062
// continue ;
62060: GO 62019
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
62062: LD_EXP 40
62066: PUSH
62067: LD_VAR 0 2
62071: ARRAY
62072: PPUSH
62073: LD_INT 29
62075: PPUSH
62076: CALL_OW 325
62080: NOT
62081: PUSH
62082: LD_EXP 40
62086: PUSH
62087: LD_VAR 0 2
62091: ARRAY
62092: PPUSH
62093: LD_INT 28
62095: PPUSH
62096: CALL_OW 325
62100: NOT
62101: AND
62102: IFFALSE 62106
// continue ;
62104: GO 62019
// for j in tmp do
62106: LD_ADDR_VAR 0 3
62110: PUSH
62111: LD_VAR 0 4
62115: PUSH
62116: FOR_IN
62117: IFFALSE 62176
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
62119: LD_VAR 0 3
62123: PUSH
62124: LD_EXP 17
62128: PUSH
62129: LD_VAR 0 2
62133: ARRAY
62134: PUSH
62135: LD_INT 1
62137: ARRAY
62138: IN
62139: NOT
62140: PUSH
62141: LD_VAR 0 3
62145: PUSH
62146: LD_EXP 17
62150: PUSH
62151: LD_VAR 0 2
62155: ARRAY
62156: PUSH
62157: LD_INT 2
62159: ARRAY
62160: IN
62161: NOT
62162: AND
62163: IFFALSE 62174
// ComSpaceTimeShoot ( j ) ;
62165: LD_VAR 0 3
62169: PPUSH
62170: CALL 5424 0 1
62174: GO 62116
62176: POP
62177: POP
// end ;
62178: GO 62019
62180: POP
62181: POP
// end ;
62182: LD_VAR 0 1
62186: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
62187: LD_INT 0
62189: PPUSH
62190: PPUSH
62191: PPUSH
62192: PPUSH
62193: PPUSH
62194: PPUSH
62195: PPUSH
62196: PPUSH
62197: PPUSH
// if not mc_bases then
62198: LD_EXP 14
62202: NOT
62203: IFFALSE 62207
// exit ;
62205: GO 62829
// for i = 1 to mc_bases do
62207: LD_ADDR_VAR 0 2
62211: PUSH
62212: DOUBLE
62213: LD_INT 1
62215: DEC
62216: ST_TO_ADDR
62217: LD_EXP 14
62221: PUSH
62222: FOR_TO
62223: IFFALSE 62827
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
62225: LD_EXP 49
62229: PUSH
62230: LD_VAR 0 2
62234: ARRAY
62235: NOT
62236: PUSH
62237: LD_INT 38
62239: PPUSH
62240: LD_EXP 40
62244: PUSH
62245: LD_VAR 0 2
62249: ARRAY
62250: PPUSH
62251: CALL_OW 321
62255: PUSH
62256: LD_INT 2
62258: NONEQUAL
62259: OR
62260: IFFALSE 62264
// continue ;
62262: GO 62222
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
62264: LD_ADDR_VAR 0 8
62268: PUSH
62269: LD_EXP 14
62273: PUSH
62274: LD_VAR 0 2
62278: ARRAY
62279: PPUSH
62280: LD_INT 30
62282: PUSH
62283: LD_INT 34
62285: PUSH
62286: EMPTY
62287: LIST
62288: LIST
62289: PPUSH
62290: CALL_OW 72
62294: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
62295: LD_ADDR_VAR 0 9
62299: PUSH
62300: LD_EXP 14
62304: PUSH
62305: LD_VAR 0 2
62309: ARRAY
62310: PPUSH
62311: LD_INT 25
62313: PUSH
62314: LD_INT 4
62316: PUSH
62317: EMPTY
62318: LIST
62319: LIST
62320: PPUSH
62321: CALL_OW 72
62325: PPUSH
62326: LD_INT 0
62328: PPUSH
62329: CALL 38321 0 2
62333: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
62334: LD_VAR 0 9
62338: NOT
62339: PUSH
62340: LD_VAR 0 8
62344: NOT
62345: OR
62346: PUSH
62347: LD_EXP 14
62351: PUSH
62352: LD_VAR 0 2
62356: ARRAY
62357: PPUSH
62358: LD_INT 124
62360: PPUSH
62361: CALL 38321 0 2
62365: OR
62366: IFFALSE 62370
// continue ;
62368: GO 62222
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
62370: LD_EXP 50
62374: PUSH
62375: LD_VAR 0 2
62379: ARRAY
62380: PUSH
62381: LD_EXP 49
62385: PUSH
62386: LD_VAR 0 2
62390: ARRAY
62391: LESS
62392: PUSH
62393: LD_EXP 50
62397: PUSH
62398: LD_VAR 0 2
62402: ARRAY
62403: PUSH
62404: LD_VAR 0 8
62408: LESS
62409: AND
62410: IFFALSE 62825
// begin tmp := sci [ 1 ] ;
62412: LD_ADDR_VAR 0 7
62416: PUSH
62417: LD_VAR 0 9
62421: PUSH
62422: LD_INT 1
62424: ARRAY
62425: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
62426: LD_VAR 0 7
62430: PPUSH
62431: LD_INT 124
62433: PPUSH
62434: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
62438: LD_ADDR_VAR 0 3
62442: PUSH
62443: DOUBLE
62444: LD_EXP 49
62448: PUSH
62449: LD_VAR 0 2
62453: ARRAY
62454: INC
62455: ST_TO_ADDR
62456: LD_EXP 49
62460: PUSH
62461: LD_VAR 0 2
62465: ARRAY
62466: PUSH
62467: FOR_DOWNTO
62468: IFFALSE 62811
// begin if IsInUnit ( tmp ) then
62470: LD_VAR 0 7
62474: PPUSH
62475: CALL_OW 310
62479: IFFALSE 62490
// ComExitBuilding ( tmp ) ;
62481: LD_VAR 0 7
62485: PPUSH
62486: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
62490: LD_INT 35
62492: PPUSH
62493: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
62497: LD_VAR 0 7
62501: PPUSH
62502: CALL_OW 310
62506: NOT
62507: PUSH
62508: LD_VAR 0 7
62512: PPUSH
62513: CALL_OW 314
62517: NOT
62518: AND
62519: IFFALSE 62490
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
62521: LD_ADDR_VAR 0 6
62525: PUSH
62526: LD_VAR 0 7
62530: PPUSH
62531: CALL_OW 250
62535: PUSH
62536: LD_VAR 0 7
62540: PPUSH
62541: CALL_OW 251
62545: PUSH
62546: EMPTY
62547: LIST
62548: LIST
62549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
62550: LD_INT 35
62552: PPUSH
62553: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
62557: LD_ADDR_VAR 0 4
62561: PUSH
62562: LD_EXP 49
62566: PUSH
62567: LD_VAR 0 2
62571: ARRAY
62572: PUSH
62573: LD_VAR 0 3
62577: ARRAY
62578: PUSH
62579: LD_INT 1
62581: ARRAY
62582: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
62583: LD_ADDR_VAR 0 5
62587: PUSH
62588: LD_EXP 49
62592: PUSH
62593: LD_VAR 0 2
62597: ARRAY
62598: PUSH
62599: LD_VAR 0 3
62603: ARRAY
62604: PUSH
62605: LD_INT 2
62607: ARRAY
62608: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
62609: LD_VAR 0 7
62613: PPUSH
62614: LD_INT 10
62616: PPUSH
62617: CALL 12020 0 2
62621: PUSH
62622: LD_INT 4
62624: ARRAY
62625: IFFALSE 62663
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
62627: LD_VAR 0 7
62631: PPUSH
62632: LD_VAR 0 6
62636: PUSH
62637: LD_INT 1
62639: ARRAY
62640: PPUSH
62641: LD_VAR 0 6
62645: PUSH
62646: LD_INT 2
62648: ARRAY
62649: PPUSH
62650: CALL_OW 111
// wait ( 0 0$10 ) ;
62654: LD_INT 350
62656: PPUSH
62657: CALL_OW 67
// end else
62661: GO 62689
// begin ComMoveXY ( tmp , x , y ) ;
62663: LD_VAR 0 7
62667: PPUSH
62668: LD_VAR 0 4
62672: PPUSH
62673: LD_VAR 0 5
62677: PPUSH
62678: CALL_OW 111
// wait ( 0 0$3 ) ;
62682: LD_INT 105
62684: PPUSH
62685: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
62689: LD_VAR 0 7
62693: PPUSH
62694: LD_VAR 0 4
62698: PPUSH
62699: LD_VAR 0 5
62703: PPUSH
62704: CALL_OW 307
62708: IFFALSE 62550
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
62710: LD_VAR 0 7
62714: PPUSH
62715: LD_VAR 0 4
62719: PPUSH
62720: LD_VAR 0 5
62724: PPUSH
62725: LD_VAR 0 8
62729: PUSH
62730: LD_VAR 0 3
62734: ARRAY
62735: PPUSH
62736: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
62740: LD_INT 35
62742: PPUSH
62743: CALL_OW 67
// until not HasTask ( tmp ) ;
62747: LD_VAR 0 7
62751: PPUSH
62752: CALL_OW 314
62756: NOT
62757: IFFALSE 62740
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
62759: LD_ADDR_EXP 50
62763: PUSH
62764: LD_EXP 50
62768: PPUSH
62769: LD_VAR 0 2
62773: PUSH
62774: LD_EXP 50
62778: PUSH
62779: LD_VAR 0 2
62783: ARRAY
62784: PUSH
62785: LD_INT 1
62787: PLUS
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PPUSH
62793: LD_VAR 0 8
62797: PUSH
62798: LD_VAR 0 3
62802: ARRAY
62803: PPUSH
62804: CALL 9427 0 3
62808: ST_TO_ADDR
// end ;
62809: GO 62467
62811: POP
62812: POP
// MC_Reset ( i , 124 ) ;
62813: LD_VAR 0 2
62817: PPUSH
62818: LD_INT 124
62820: PPUSH
62821: CALL 46268 0 2
// end ; end ;
62825: GO 62222
62827: POP
62828: POP
// end ;
62829: LD_VAR 0 1
62833: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
62834: LD_INT 0
62836: PPUSH
62837: PPUSH
62838: PPUSH
// if not mc_bases then
62839: LD_EXP 14
62843: NOT
62844: IFFALSE 62848
// exit ;
62846: GO 63454
// for i = 1 to mc_bases do
62848: LD_ADDR_VAR 0 2
62852: PUSH
62853: DOUBLE
62854: LD_INT 1
62856: DEC
62857: ST_TO_ADDR
62858: LD_EXP 14
62862: PUSH
62863: FOR_TO
62864: IFFALSE 63452
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62866: LD_ADDR_VAR 0 3
62870: PUSH
62871: LD_EXP 14
62875: PUSH
62876: LD_VAR 0 2
62880: ARRAY
62881: PPUSH
62882: LD_INT 25
62884: PUSH
62885: LD_INT 4
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PPUSH
62892: CALL_OW 72
62896: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62897: LD_VAR 0 3
62901: NOT
62902: PUSH
62903: LD_EXP 51
62907: PUSH
62908: LD_VAR 0 2
62912: ARRAY
62913: NOT
62914: OR
62915: PUSH
62916: LD_EXP 14
62920: PUSH
62921: LD_VAR 0 2
62925: ARRAY
62926: PPUSH
62927: LD_INT 2
62929: PUSH
62930: LD_INT 30
62932: PUSH
62933: LD_INT 0
62935: PUSH
62936: EMPTY
62937: LIST
62938: LIST
62939: PUSH
62940: LD_INT 30
62942: PUSH
62943: LD_INT 1
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: EMPTY
62951: LIST
62952: LIST
62953: LIST
62954: PPUSH
62955: CALL_OW 72
62959: NOT
62960: OR
62961: IFFALSE 63011
// begin if mc_deposits_finder [ i ] then
62963: LD_EXP 52
62967: PUSH
62968: LD_VAR 0 2
62972: ARRAY
62973: IFFALSE 63009
// begin MC_Reset ( i , 125 ) ;
62975: LD_VAR 0 2
62979: PPUSH
62980: LD_INT 125
62982: PPUSH
62983: CALL 46268 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
62987: LD_ADDR_EXP 52
62991: PUSH
62992: LD_EXP 52
62996: PPUSH
62997: LD_VAR 0 2
63001: PPUSH
63002: EMPTY
63003: PPUSH
63004: CALL_OW 1
63008: ST_TO_ADDR
// end ; continue ;
63009: GO 62863
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
63011: LD_EXP 51
63015: PUSH
63016: LD_VAR 0 2
63020: ARRAY
63021: PUSH
63022: LD_INT 1
63024: ARRAY
63025: PUSH
63026: LD_INT 3
63028: ARRAY
63029: PUSH
63030: LD_INT 1
63032: EQUAL
63033: PUSH
63034: LD_INT 20
63036: PPUSH
63037: LD_EXP 40
63041: PUSH
63042: LD_VAR 0 2
63046: ARRAY
63047: PPUSH
63048: CALL_OW 321
63052: PUSH
63053: LD_INT 2
63055: NONEQUAL
63056: AND
63057: IFFALSE 63107
// begin if mc_deposits_finder [ i ] then
63059: LD_EXP 52
63063: PUSH
63064: LD_VAR 0 2
63068: ARRAY
63069: IFFALSE 63105
// begin MC_Reset ( i , 125 ) ;
63071: LD_VAR 0 2
63075: PPUSH
63076: LD_INT 125
63078: PPUSH
63079: CALL 46268 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
63083: LD_ADDR_EXP 52
63087: PUSH
63088: LD_EXP 52
63092: PPUSH
63093: LD_VAR 0 2
63097: PPUSH
63098: EMPTY
63099: PPUSH
63100: CALL_OW 1
63104: ST_TO_ADDR
// end ; continue ;
63105: GO 62863
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
63107: LD_EXP 51
63111: PUSH
63112: LD_VAR 0 2
63116: ARRAY
63117: PUSH
63118: LD_INT 1
63120: ARRAY
63121: PUSH
63122: LD_INT 1
63124: ARRAY
63125: PPUSH
63126: LD_EXP 51
63130: PUSH
63131: LD_VAR 0 2
63135: ARRAY
63136: PUSH
63137: LD_INT 1
63139: ARRAY
63140: PUSH
63141: LD_INT 2
63143: ARRAY
63144: PPUSH
63145: LD_EXP 40
63149: PUSH
63150: LD_VAR 0 2
63154: ARRAY
63155: PPUSH
63156: CALL_OW 440
63160: IFFALSE 63203
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
63162: LD_ADDR_EXP 51
63166: PUSH
63167: LD_EXP 51
63171: PPUSH
63172: LD_VAR 0 2
63176: PPUSH
63177: LD_EXP 51
63181: PUSH
63182: LD_VAR 0 2
63186: ARRAY
63187: PPUSH
63188: LD_INT 1
63190: PPUSH
63191: CALL_OW 3
63195: PPUSH
63196: CALL_OW 1
63200: ST_TO_ADDR
63201: GO 63450
// begin if not mc_deposits_finder [ i ] then
63203: LD_EXP 52
63207: PUSH
63208: LD_VAR 0 2
63212: ARRAY
63213: NOT
63214: IFFALSE 63266
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
63216: LD_ADDR_EXP 52
63220: PUSH
63221: LD_EXP 52
63225: PPUSH
63226: LD_VAR 0 2
63230: PPUSH
63231: LD_VAR 0 3
63235: PUSH
63236: LD_INT 1
63238: ARRAY
63239: PUSH
63240: EMPTY
63241: LIST
63242: PPUSH
63243: CALL_OW 1
63247: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
63248: LD_VAR 0 3
63252: PUSH
63253: LD_INT 1
63255: ARRAY
63256: PPUSH
63257: LD_INT 125
63259: PPUSH
63260: CALL_OW 109
// end else
63264: GO 63450
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
63266: LD_EXP 52
63270: PUSH
63271: LD_VAR 0 2
63275: ARRAY
63276: PUSH
63277: LD_INT 1
63279: ARRAY
63280: PPUSH
63281: CALL_OW 310
63285: IFFALSE 63308
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
63287: LD_EXP 52
63291: PUSH
63292: LD_VAR 0 2
63296: ARRAY
63297: PUSH
63298: LD_INT 1
63300: ARRAY
63301: PPUSH
63302: CALL_OW 122
63306: GO 63450
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
63308: LD_EXP 52
63312: PUSH
63313: LD_VAR 0 2
63317: ARRAY
63318: PUSH
63319: LD_INT 1
63321: ARRAY
63322: PPUSH
63323: CALL_OW 314
63327: NOT
63328: PUSH
63329: LD_EXP 52
63333: PUSH
63334: LD_VAR 0 2
63338: ARRAY
63339: PUSH
63340: LD_INT 1
63342: ARRAY
63343: PPUSH
63344: LD_EXP 51
63348: PUSH
63349: LD_VAR 0 2
63353: ARRAY
63354: PUSH
63355: LD_INT 1
63357: ARRAY
63358: PUSH
63359: LD_INT 1
63361: ARRAY
63362: PPUSH
63363: LD_EXP 51
63367: PUSH
63368: LD_VAR 0 2
63372: ARRAY
63373: PUSH
63374: LD_INT 1
63376: ARRAY
63377: PUSH
63378: LD_INT 2
63380: ARRAY
63381: PPUSH
63382: CALL_OW 297
63386: PUSH
63387: LD_INT 6
63389: GREATER
63390: AND
63391: IFFALSE 63450
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
63393: LD_EXP 52
63397: PUSH
63398: LD_VAR 0 2
63402: ARRAY
63403: PUSH
63404: LD_INT 1
63406: ARRAY
63407: PPUSH
63408: LD_EXP 51
63412: PUSH
63413: LD_VAR 0 2
63417: ARRAY
63418: PUSH
63419: LD_INT 1
63421: ARRAY
63422: PUSH
63423: LD_INT 1
63425: ARRAY
63426: PPUSH
63427: LD_EXP 51
63431: PUSH
63432: LD_VAR 0 2
63436: ARRAY
63437: PUSH
63438: LD_INT 1
63440: ARRAY
63441: PUSH
63442: LD_INT 2
63444: ARRAY
63445: PPUSH
63446: CALL_OW 111
// end ; end ; end ;
63450: GO 62863
63452: POP
63453: POP
// end ;
63454: LD_VAR 0 1
63458: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
63459: LD_INT 0
63461: PPUSH
63462: PPUSH
63463: PPUSH
63464: PPUSH
63465: PPUSH
63466: PPUSH
63467: PPUSH
63468: PPUSH
63469: PPUSH
63470: PPUSH
63471: PPUSH
// if not mc_bases then
63472: LD_EXP 14
63476: NOT
63477: IFFALSE 63481
// exit ;
63479: GO 64421
// for i = 1 to mc_bases do
63481: LD_ADDR_VAR 0 2
63485: PUSH
63486: DOUBLE
63487: LD_INT 1
63489: DEC
63490: ST_TO_ADDR
63491: LD_EXP 14
63495: PUSH
63496: FOR_TO
63497: IFFALSE 64419
// begin if not mc_bases [ i ] or mc_scan [ i ] then
63499: LD_EXP 14
63503: PUSH
63504: LD_VAR 0 2
63508: ARRAY
63509: NOT
63510: PUSH
63511: LD_EXP 37
63515: PUSH
63516: LD_VAR 0 2
63520: ARRAY
63521: OR
63522: IFFALSE 63526
// continue ;
63524: GO 63496
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
63526: LD_ADDR_VAR 0 7
63530: PUSH
63531: LD_EXP 14
63535: PUSH
63536: LD_VAR 0 2
63540: ARRAY
63541: PUSH
63542: LD_INT 1
63544: ARRAY
63545: PPUSH
63546: CALL_OW 248
63550: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
63551: LD_VAR 0 7
63555: PUSH
63556: LD_INT 3
63558: EQUAL
63559: PUSH
63560: LD_EXP 33
63564: PUSH
63565: LD_VAR 0 2
63569: ARRAY
63570: PUSH
63571: LD_EXP 36
63575: PUSH
63576: LD_VAR 0 2
63580: ARRAY
63581: UNION
63582: PPUSH
63583: LD_INT 33
63585: PUSH
63586: LD_INT 2
63588: PUSH
63589: EMPTY
63590: LIST
63591: LIST
63592: PPUSH
63593: CALL_OW 72
63597: NOT
63598: OR
63599: IFFALSE 63603
// continue ;
63601: GO 63496
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
63603: LD_ADDR_VAR 0 9
63607: PUSH
63608: LD_EXP 14
63612: PUSH
63613: LD_VAR 0 2
63617: ARRAY
63618: PPUSH
63619: LD_INT 30
63621: PUSH
63622: LD_INT 36
63624: PUSH
63625: EMPTY
63626: LIST
63627: LIST
63628: PPUSH
63629: CALL_OW 72
63633: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
63634: LD_ADDR_VAR 0 10
63638: PUSH
63639: LD_EXP 33
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: PPUSH
63650: LD_INT 34
63652: PUSH
63653: LD_INT 31
63655: PUSH
63656: EMPTY
63657: LIST
63658: LIST
63659: PPUSH
63660: CALL_OW 72
63664: ST_TO_ADDR
// if not cts and not mcts then
63665: LD_VAR 0 9
63669: NOT
63670: PUSH
63671: LD_VAR 0 10
63675: NOT
63676: AND
63677: IFFALSE 63681
// continue ;
63679: GO 63496
// x := cts ;
63681: LD_ADDR_VAR 0 11
63685: PUSH
63686: LD_VAR 0 9
63690: ST_TO_ADDR
// if not x then
63691: LD_VAR 0 11
63695: NOT
63696: IFFALSE 63708
// x := mcts ;
63698: LD_ADDR_VAR 0 11
63702: PUSH
63703: LD_VAR 0 10
63707: ST_TO_ADDR
// if not x then
63708: LD_VAR 0 11
63712: NOT
63713: IFFALSE 63717
// continue ;
63715: GO 63496
// if mc_remote_driver [ i ] then
63717: LD_EXP 54
63721: PUSH
63722: LD_VAR 0 2
63726: ARRAY
63727: IFFALSE 64114
// for j in mc_remote_driver [ i ] do
63729: LD_ADDR_VAR 0 3
63733: PUSH
63734: LD_EXP 54
63738: PUSH
63739: LD_VAR 0 2
63743: ARRAY
63744: PUSH
63745: FOR_IN
63746: IFFALSE 64112
// begin if GetClass ( j ) <> 3 then
63748: LD_VAR 0 3
63752: PPUSH
63753: CALL_OW 257
63757: PUSH
63758: LD_INT 3
63760: NONEQUAL
63761: IFFALSE 63814
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
63763: LD_ADDR_EXP 54
63767: PUSH
63768: LD_EXP 54
63772: PPUSH
63773: LD_VAR 0 2
63777: PPUSH
63778: LD_EXP 54
63782: PUSH
63783: LD_VAR 0 2
63787: ARRAY
63788: PUSH
63789: LD_VAR 0 3
63793: DIFF
63794: PPUSH
63795: CALL_OW 1
63799: ST_TO_ADDR
// SetTag ( j , 0 ) ;
63800: LD_VAR 0 3
63804: PPUSH
63805: LD_INT 0
63807: PPUSH
63808: CALL_OW 109
// continue ;
63812: GO 63745
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
63814: LD_EXP 33
63818: PUSH
63819: LD_VAR 0 2
63823: ARRAY
63824: PPUSH
63825: LD_INT 34
63827: PUSH
63828: LD_INT 31
63830: PUSH
63831: EMPTY
63832: LIST
63833: LIST
63834: PUSH
63835: LD_INT 58
63837: PUSH
63838: EMPTY
63839: LIST
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PPUSH
63845: CALL_OW 72
63849: PUSH
63850: LD_VAR 0 3
63854: PPUSH
63855: CALL 38409 0 1
63859: NOT
63860: AND
63861: IFFALSE 63932
// begin if IsInUnit ( j ) then
63863: LD_VAR 0 3
63867: PPUSH
63868: CALL_OW 310
63872: IFFALSE 63883
// ComExitBuilding ( j ) ;
63874: LD_VAR 0 3
63878: PPUSH
63879: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
63883: LD_VAR 0 3
63887: PPUSH
63888: LD_EXP 33
63892: PUSH
63893: LD_VAR 0 2
63897: ARRAY
63898: PPUSH
63899: LD_INT 34
63901: PUSH
63902: LD_INT 31
63904: PUSH
63905: EMPTY
63906: LIST
63907: LIST
63908: PUSH
63909: LD_INT 58
63911: PUSH
63912: EMPTY
63913: LIST
63914: PUSH
63915: EMPTY
63916: LIST
63917: LIST
63918: PPUSH
63919: CALL_OW 72
63923: PUSH
63924: LD_INT 1
63926: ARRAY
63927: PPUSH
63928: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
63932: LD_VAR 0 3
63936: PPUSH
63937: CALL_OW 310
63941: NOT
63942: PUSH
63943: LD_VAR 0 3
63947: PPUSH
63948: CALL_OW 310
63952: PPUSH
63953: CALL_OW 266
63957: PUSH
63958: LD_INT 36
63960: NONEQUAL
63961: PUSH
63962: LD_VAR 0 3
63966: PPUSH
63967: CALL 38409 0 1
63971: NOT
63972: AND
63973: OR
63974: IFFALSE 64110
// begin if IsInUnit ( j ) then
63976: LD_VAR 0 3
63980: PPUSH
63981: CALL_OW 310
63985: IFFALSE 63996
// ComExitBuilding ( j ) ;
63987: LD_VAR 0 3
63991: PPUSH
63992: CALL_OW 122
// ct := 0 ;
63996: LD_ADDR_VAR 0 8
64000: PUSH
64001: LD_INT 0
64003: ST_TO_ADDR
// for k in x do
64004: LD_ADDR_VAR 0 4
64008: PUSH
64009: LD_VAR 0 11
64013: PUSH
64014: FOR_IN
64015: IFFALSE 64088
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
64017: LD_VAR 0 4
64021: PPUSH
64022: CALL_OW 264
64026: PUSH
64027: LD_INT 31
64029: EQUAL
64030: PUSH
64031: LD_VAR 0 4
64035: PPUSH
64036: CALL_OW 311
64040: NOT
64041: AND
64042: PUSH
64043: LD_VAR 0 4
64047: PPUSH
64048: CALL_OW 266
64052: PUSH
64053: LD_INT 36
64055: EQUAL
64056: PUSH
64057: LD_VAR 0 4
64061: PPUSH
64062: CALL_OW 313
64066: PUSH
64067: LD_INT 3
64069: LESS
64070: AND
64071: OR
64072: IFFALSE 64086
// begin ct := k ;
64074: LD_ADDR_VAR 0 8
64078: PUSH
64079: LD_VAR 0 4
64083: ST_TO_ADDR
// break ;
64084: GO 64088
// end ;
64086: GO 64014
64088: POP
64089: POP
// if ct then
64090: LD_VAR 0 8
64094: IFFALSE 64110
// ComEnterUnit ( j , ct ) ;
64096: LD_VAR 0 3
64100: PPUSH
64101: LD_VAR 0 8
64105: PPUSH
64106: CALL_OW 120
// end ; end ;
64110: GO 63745
64112: POP
64113: POP
// places := 0 ;
64114: LD_ADDR_VAR 0 5
64118: PUSH
64119: LD_INT 0
64121: ST_TO_ADDR
// for j = 1 to x do
64122: LD_ADDR_VAR 0 3
64126: PUSH
64127: DOUBLE
64128: LD_INT 1
64130: DEC
64131: ST_TO_ADDR
64132: LD_VAR 0 11
64136: PUSH
64137: FOR_TO
64138: IFFALSE 64214
// if GetWeapon ( x [ j ] ) = ar_control_tower then
64140: LD_VAR 0 11
64144: PUSH
64145: LD_VAR 0 3
64149: ARRAY
64150: PPUSH
64151: CALL_OW 264
64155: PUSH
64156: LD_INT 31
64158: EQUAL
64159: IFFALSE 64177
// places := places + 1 else
64161: LD_ADDR_VAR 0 5
64165: PUSH
64166: LD_VAR 0 5
64170: PUSH
64171: LD_INT 1
64173: PLUS
64174: ST_TO_ADDR
64175: GO 64212
// if GetBType ( x [ j ] ) = b_control_tower then
64177: LD_VAR 0 11
64181: PUSH
64182: LD_VAR 0 3
64186: ARRAY
64187: PPUSH
64188: CALL_OW 266
64192: PUSH
64193: LD_INT 36
64195: EQUAL
64196: IFFALSE 64212
// places := places + 3 ;
64198: LD_ADDR_VAR 0 5
64202: PUSH
64203: LD_VAR 0 5
64207: PUSH
64208: LD_INT 3
64210: PLUS
64211: ST_TO_ADDR
64212: GO 64137
64214: POP
64215: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
64216: LD_VAR 0 5
64220: PUSH
64221: LD_INT 0
64223: EQUAL
64224: PUSH
64225: LD_VAR 0 5
64229: PUSH
64230: LD_EXP 54
64234: PUSH
64235: LD_VAR 0 2
64239: ARRAY
64240: LESSEQUAL
64241: OR
64242: IFFALSE 64246
// continue ;
64244: GO 63496
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
64246: LD_ADDR_VAR 0 6
64250: PUSH
64251: LD_EXP 14
64255: PUSH
64256: LD_VAR 0 2
64260: ARRAY
64261: PPUSH
64262: LD_INT 25
64264: PUSH
64265: LD_INT 3
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PPUSH
64272: CALL_OW 72
64276: PUSH
64277: LD_EXP 54
64281: PUSH
64282: LD_VAR 0 2
64286: ARRAY
64287: DIFF
64288: PPUSH
64289: LD_INT 3
64291: PPUSH
64292: CALL 39309 0 2
64296: ST_TO_ADDR
// for j in tmp do
64297: LD_ADDR_VAR 0 3
64301: PUSH
64302: LD_VAR 0 6
64306: PUSH
64307: FOR_IN
64308: IFFALSE 64343
// if GetTag ( j ) > 0 then
64310: LD_VAR 0 3
64314: PPUSH
64315: CALL_OW 110
64319: PUSH
64320: LD_INT 0
64322: GREATER
64323: IFFALSE 64341
// tmp := tmp diff j ;
64325: LD_ADDR_VAR 0 6
64329: PUSH
64330: LD_VAR 0 6
64334: PUSH
64335: LD_VAR 0 3
64339: DIFF
64340: ST_TO_ADDR
64341: GO 64307
64343: POP
64344: POP
// if not tmp then
64345: LD_VAR 0 6
64349: NOT
64350: IFFALSE 64354
// continue ;
64352: GO 63496
// if places then
64354: LD_VAR 0 5
64358: IFFALSE 64417
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
64360: LD_ADDR_EXP 54
64364: PUSH
64365: LD_EXP 54
64369: PPUSH
64370: LD_VAR 0 2
64374: PPUSH
64375: LD_EXP 54
64379: PUSH
64380: LD_VAR 0 2
64384: ARRAY
64385: PUSH
64386: LD_VAR 0 6
64390: PUSH
64391: LD_INT 1
64393: ARRAY
64394: UNION
64395: PPUSH
64396: CALL_OW 1
64400: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
64401: LD_VAR 0 6
64405: PUSH
64406: LD_INT 1
64408: ARRAY
64409: PPUSH
64410: LD_INT 126
64412: PPUSH
64413: CALL_OW 109
// end ; end ;
64417: GO 63496
64419: POP
64420: POP
// end ;
64421: LD_VAR 0 1
64425: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
64426: LD_INT 0
64428: PPUSH
64429: PPUSH
64430: PPUSH
64431: PPUSH
64432: PPUSH
64433: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
64434: LD_VAR 0 1
64438: NOT
64439: PUSH
64440: LD_VAR 0 2
64444: NOT
64445: OR
64446: PUSH
64447: LD_VAR 0 3
64451: NOT
64452: OR
64453: PUSH
64454: LD_VAR 0 4
64458: PUSH
64459: LD_INT 1
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: LD_INT 3
64467: PUSH
64468: LD_INT 4
64470: PUSH
64471: LD_INT 5
64473: PUSH
64474: LD_INT 8
64476: PUSH
64477: LD_INT 9
64479: PUSH
64480: LD_INT 15
64482: PUSH
64483: LD_INT 16
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: IN
64497: NOT
64498: OR
64499: IFFALSE 64503
// exit ;
64501: GO 65403
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
64503: LD_ADDR_VAR 0 2
64507: PUSH
64508: LD_VAR 0 2
64512: PPUSH
64513: LD_INT 21
64515: PUSH
64516: LD_INT 3
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: PUSH
64523: LD_INT 24
64525: PUSH
64526: LD_INT 250
64528: PUSH
64529: EMPTY
64530: LIST
64531: LIST
64532: PUSH
64533: EMPTY
64534: LIST
64535: LIST
64536: PPUSH
64537: CALL_OW 72
64541: ST_TO_ADDR
// case class of 1 , 15 :
64542: LD_VAR 0 4
64546: PUSH
64547: LD_INT 1
64549: DOUBLE
64550: EQUAL
64551: IFTRUE 64561
64553: LD_INT 15
64555: DOUBLE
64556: EQUAL
64557: IFTRUE 64561
64559: GO 64646
64561: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
64562: LD_ADDR_VAR 0 8
64566: PUSH
64567: LD_VAR 0 2
64571: PPUSH
64572: LD_INT 2
64574: PUSH
64575: LD_INT 30
64577: PUSH
64578: LD_INT 32
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 30
64587: PUSH
64588: LD_INT 31
64590: PUSH
64591: EMPTY
64592: LIST
64593: LIST
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: LIST
64599: PPUSH
64600: CALL_OW 72
64604: PUSH
64605: LD_VAR 0 2
64609: PPUSH
64610: LD_INT 2
64612: PUSH
64613: LD_INT 30
64615: PUSH
64616: LD_INT 4
64618: PUSH
64619: EMPTY
64620: LIST
64621: LIST
64622: PUSH
64623: LD_INT 30
64625: PUSH
64626: LD_INT 5
64628: PUSH
64629: EMPTY
64630: LIST
64631: LIST
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: LIST
64637: PPUSH
64638: CALL_OW 72
64642: ADD
64643: ST_TO_ADDR
64644: GO 64892
64646: LD_INT 2
64648: DOUBLE
64649: EQUAL
64650: IFTRUE 64660
64652: LD_INT 16
64654: DOUBLE
64655: EQUAL
64656: IFTRUE 64660
64658: GO 64706
64660: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
64661: LD_ADDR_VAR 0 8
64665: PUSH
64666: LD_VAR 0 2
64670: PPUSH
64671: LD_INT 2
64673: PUSH
64674: LD_INT 30
64676: PUSH
64677: LD_INT 0
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: PUSH
64684: LD_INT 30
64686: PUSH
64687: LD_INT 1
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: LIST
64698: PPUSH
64699: CALL_OW 72
64703: ST_TO_ADDR
64704: GO 64892
64706: LD_INT 3
64708: DOUBLE
64709: EQUAL
64710: IFTRUE 64714
64712: GO 64760
64714: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
64715: LD_ADDR_VAR 0 8
64719: PUSH
64720: LD_VAR 0 2
64724: PPUSH
64725: LD_INT 2
64727: PUSH
64728: LD_INT 30
64730: PUSH
64731: LD_INT 2
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 30
64740: PUSH
64741: LD_INT 3
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: LIST
64752: PPUSH
64753: CALL_OW 72
64757: ST_TO_ADDR
64758: GO 64892
64760: LD_INT 4
64762: DOUBLE
64763: EQUAL
64764: IFTRUE 64768
64766: GO 64825
64768: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
64769: LD_ADDR_VAR 0 8
64773: PUSH
64774: LD_VAR 0 2
64778: PPUSH
64779: LD_INT 2
64781: PUSH
64782: LD_INT 30
64784: PUSH
64785: LD_INT 6
64787: PUSH
64788: EMPTY
64789: LIST
64790: LIST
64791: PUSH
64792: LD_INT 30
64794: PUSH
64795: LD_INT 7
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: PUSH
64802: LD_INT 30
64804: PUSH
64805: LD_INT 8
64807: PUSH
64808: EMPTY
64809: LIST
64810: LIST
64811: PUSH
64812: EMPTY
64813: LIST
64814: LIST
64815: LIST
64816: LIST
64817: PPUSH
64818: CALL_OW 72
64822: ST_TO_ADDR
64823: GO 64892
64825: LD_INT 5
64827: DOUBLE
64828: EQUAL
64829: IFTRUE 64845
64831: LD_INT 8
64833: DOUBLE
64834: EQUAL
64835: IFTRUE 64845
64837: LD_INT 9
64839: DOUBLE
64840: EQUAL
64841: IFTRUE 64845
64843: GO 64891
64845: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
64846: LD_ADDR_VAR 0 8
64850: PUSH
64851: LD_VAR 0 2
64855: PPUSH
64856: LD_INT 2
64858: PUSH
64859: LD_INT 30
64861: PUSH
64862: LD_INT 4
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 30
64871: PUSH
64872: LD_INT 5
64874: PUSH
64875: EMPTY
64876: LIST
64877: LIST
64878: PUSH
64879: EMPTY
64880: LIST
64881: LIST
64882: LIST
64883: PPUSH
64884: CALL_OW 72
64888: ST_TO_ADDR
64889: GO 64892
64891: POP
// if not tmp then
64892: LD_VAR 0 8
64896: NOT
64897: IFFALSE 64901
// exit ;
64899: GO 65403
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
64901: LD_VAR 0 4
64905: PUSH
64906: LD_INT 1
64908: PUSH
64909: LD_INT 15
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: IN
64916: PUSH
64917: LD_EXP 23
64921: PUSH
64922: LD_VAR 0 1
64926: ARRAY
64927: AND
64928: IFFALSE 65084
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
64930: LD_ADDR_VAR 0 9
64934: PUSH
64935: LD_EXP 23
64939: PUSH
64940: LD_VAR 0 1
64944: ARRAY
64945: PUSH
64946: LD_INT 1
64948: ARRAY
64949: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
64950: LD_VAR 0 9
64954: PUSH
64955: LD_EXP 24
64959: PUSH
64960: LD_VAR 0 1
64964: ARRAY
64965: IN
64966: NOT
64967: IFFALSE 65082
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
64969: LD_ADDR_EXP 24
64973: PUSH
64974: LD_EXP 24
64978: PPUSH
64979: LD_VAR 0 1
64983: PUSH
64984: LD_EXP 24
64988: PUSH
64989: LD_VAR 0 1
64993: ARRAY
64994: PUSH
64995: LD_INT 1
64997: PLUS
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PPUSH
65003: LD_VAR 0 9
65007: PPUSH
65008: CALL 9427 0 3
65012: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
65013: LD_ADDR_EXP 23
65017: PUSH
65018: LD_EXP 23
65022: PPUSH
65023: LD_VAR 0 1
65027: PPUSH
65028: LD_EXP 23
65032: PUSH
65033: LD_VAR 0 1
65037: ARRAY
65038: PUSH
65039: LD_VAR 0 9
65043: DIFF
65044: PPUSH
65045: CALL_OW 1
65049: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
65050: LD_VAR 0 3
65054: PPUSH
65055: LD_EXP 24
65059: PUSH
65060: LD_VAR 0 1
65064: ARRAY
65065: PUSH
65066: LD_EXP 24
65070: PUSH
65071: LD_VAR 0 1
65075: ARRAY
65076: ARRAY
65077: PPUSH
65078: CALL_OW 120
// end ; exit ;
65082: GO 65403
// end ; if tmp > 1 then
65084: LD_VAR 0 8
65088: PUSH
65089: LD_INT 1
65091: GREATER
65092: IFFALSE 65196
// for i = 2 to tmp do
65094: LD_ADDR_VAR 0 6
65098: PUSH
65099: DOUBLE
65100: LD_INT 2
65102: DEC
65103: ST_TO_ADDR
65104: LD_VAR 0 8
65108: PUSH
65109: FOR_TO
65110: IFFALSE 65194
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
65112: LD_VAR 0 8
65116: PUSH
65117: LD_VAR 0 6
65121: ARRAY
65122: PPUSH
65123: CALL_OW 461
65127: PUSH
65128: LD_INT 6
65130: EQUAL
65131: IFFALSE 65192
// begin x := tmp [ i ] ;
65133: LD_ADDR_VAR 0 9
65137: PUSH
65138: LD_VAR 0 8
65142: PUSH
65143: LD_VAR 0 6
65147: ARRAY
65148: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
65149: LD_ADDR_VAR 0 8
65153: PUSH
65154: LD_VAR 0 8
65158: PPUSH
65159: LD_VAR 0 6
65163: PPUSH
65164: CALL_OW 3
65168: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
65169: LD_ADDR_VAR 0 8
65173: PUSH
65174: LD_VAR 0 8
65178: PPUSH
65179: LD_INT 1
65181: PPUSH
65182: LD_VAR 0 9
65186: PPUSH
65187: CALL_OW 2
65191: ST_TO_ADDR
// end ;
65192: GO 65109
65194: POP
65195: POP
// for i in tmp do
65196: LD_ADDR_VAR 0 6
65200: PUSH
65201: LD_VAR 0 8
65205: PUSH
65206: FOR_IN
65207: IFFALSE 65276
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
65209: LD_VAR 0 6
65213: PPUSH
65214: CALL_OW 313
65218: PUSH
65219: LD_INT 6
65221: LESS
65222: PUSH
65223: LD_VAR 0 6
65227: PPUSH
65228: CALL_OW 266
65232: PUSH
65233: LD_INT 31
65235: PUSH
65236: LD_INT 32
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: IN
65243: NOT
65244: AND
65245: PUSH
65246: LD_VAR 0 6
65250: PPUSH
65251: CALL_OW 313
65255: PUSH
65256: LD_INT 0
65258: EQUAL
65259: OR
65260: IFFALSE 65274
// begin j := i ;
65262: LD_ADDR_VAR 0 7
65266: PUSH
65267: LD_VAR 0 6
65271: ST_TO_ADDR
// break ;
65272: GO 65276
// end ; end ;
65274: GO 65206
65276: POP
65277: POP
// if j then
65278: LD_VAR 0 7
65282: IFFALSE 65300
// ComEnterUnit ( unit , j ) else
65284: LD_VAR 0 3
65288: PPUSH
65289: LD_VAR 0 7
65293: PPUSH
65294: CALL_OW 120
65298: GO 65403
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65300: LD_ADDR_VAR 0 10
65304: PUSH
65305: LD_VAR 0 2
65309: PPUSH
65310: LD_INT 2
65312: PUSH
65313: LD_INT 30
65315: PUSH
65316: LD_INT 0
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: PUSH
65323: LD_INT 30
65325: PUSH
65326: LD_INT 1
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PUSH
65333: EMPTY
65334: LIST
65335: LIST
65336: LIST
65337: PPUSH
65338: CALL_OW 72
65342: ST_TO_ADDR
// if depot then
65343: LD_VAR 0 10
65347: IFFALSE 65403
// begin depot := NearestUnitToUnit ( depot , unit ) ;
65349: LD_ADDR_VAR 0 10
65353: PUSH
65354: LD_VAR 0 10
65358: PPUSH
65359: LD_VAR 0 3
65363: PPUSH
65364: CALL_OW 74
65368: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
65369: LD_VAR 0 3
65373: PPUSH
65374: LD_VAR 0 10
65378: PPUSH
65379: CALL_OW 296
65383: PUSH
65384: LD_INT 10
65386: GREATER
65387: IFFALSE 65403
// ComStandNearbyBuilding ( unit , depot ) ;
65389: LD_VAR 0 3
65393: PPUSH
65394: LD_VAR 0 10
65398: PPUSH
65399: CALL 6041 0 2
// end ; end ; end ;
65403: LD_VAR 0 5
65407: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
65408: LD_INT 0
65410: PPUSH
65411: PPUSH
65412: PPUSH
65413: PPUSH
// if not mc_bases then
65414: LD_EXP 14
65418: NOT
65419: IFFALSE 65423
// exit ;
65421: GO 65662
// for i = 1 to mc_bases do
65423: LD_ADDR_VAR 0 2
65427: PUSH
65428: DOUBLE
65429: LD_INT 1
65431: DEC
65432: ST_TO_ADDR
65433: LD_EXP 14
65437: PUSH
65438: FOR_TO
65439: IFFALSE 65660
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
65441: LD_ADDR_VAR 0 4
65445: PUSH
65446: LD_EXP 14
65450: PUSH
65451: LD_VAR 0 2
65455: ARRAY
65456: PPUSH
65457: LD_INT 21
65459: PUSH
65460: LD_INT 1
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PPUSH
65467: CALL_OW 72
65471: PUSH
65472: LD_EXP 43
65476: PUSH
65477: LD_VAR 0 2
65481: ARRAY
65482: UNION
65483: ST_TO_ADDR
// if not tmp then
65484: LD_VAR 0 4
65488: NOT
65489: IFFALSE 65493
// continue ;
65491: GO 65438
// for j in tmp do
65493: LD_ADDR_VAR 0 3
65497: PUSH
65498: LD_VAR 0 4
65502: PUSH
65503: FOR_IN
65504: IFFALSE 65656
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
65506: LD_VAR 0 3
65510: PPUSH
65511: CALL_OW 110
65515: NOT
65516: PUSH
65517: LD_VAR 0 3
65521: PPUSH
65522: CALL_OW 314
65526: NOT
65527: AND
65528: PUSH
65529: LD_VAR 0 3
65533: PPUSH
65534: CALL_OW 311
65538: NOT
65539: AND
65540: PUSH
65541: LD_VAR 0 3
65545: PPUSH
65546: CALL_OW 310
65550: NOT
65551: AND
65552: PUSH
65553: LD_VAR 0 3
65557: PUSH
65558: LD_EXP 17
65562: PUSH
65563: LD_VAR 0 2
65567: ARRAY
65568: PUSH
65569: LD_INT 1
65571: ARRAY
65572: IN
65573: NOT
65574: AND
65575: PUSH
65576: LD_VAR 0 3
65580: PUSH
65581: LD_EXP 17
65585: PUSH
65586: LD_VAR 0 2
65590: ARRAY
65591: PUSH
65592: LD_INT 2
65594: ARRAY
65595: IN
65596: NOT
65597: AND
65598: PUSH
65599: LD_VAR 0 3
65603: PUSH
65604: LD_EXP 26
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: IN
65615: NOT
65616: AND
65617: IFFALSE 65654
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
65619: LD_VAR 0 2
65623: PPUSH
65624: LD_EXP 14
65628: PUSH
65629: LD_VAR 0 2
65633: ARRAY
65634: PPUSH
65635: LD_VAR 0 3
65639: PPUSH
65640: LD_VAR 0 3
65644: PPUSH
65645: CALL_OW 257
65649: PPUSH
65650: CALL 64426 0 4
// end ;
65654: GO 65503
65656: POP
65657: POP
// end ;
65658: GO 65438
65660: POP
65661: POP
// end ;
65662: LD_VAR 0 1
65666: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
65667: LD_INT 0
65669: PPUSH
65670: PPUSH
65671: PPUSH
65672: PPUSH
65673: PPUSH
65674: PPUSH
// if not mc_bases [ base ] then
65675: LD_EXP 14
65679: PUSH
65680: LD_VAR 0 1
65684: ARRAY
65685: NOT
65686: IFFALSE 65690
// exit ;
65688: GO 65872
// tmp := [ ] ;
65690: LD_ADDR_VAR 0 6
65694: PUSH
65695: EMPTY
65696: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
65697: LD_ADDR_VAR 0 7
65701: PUSH
65702: LD_VAR 0 3
65706: PPUSH
65707: LD_INT 0
65709: PPUSH
65710: CALL_OW 517
65714: ST_TO_ADDR
// if not list then
65715: LD_VAR 0 7
65719: NOT
65720: IFFALSE 65724
// exit ;
65722: GO 65872
// for i = 1 to amount do
65724: LD_ADDR_VAR 0 5
65728: PUSH
65729: DOUBLE
65730: LD_INT 1
65732: DEC
65733: ST_TO_ADDR
65734: LD_VAR 0 2
65738: PUSH
65739: FOR_TO
65740: IFFALSE 65820
// begin x := rand ( 1 , list [ 1 ] ) ;
65742: LD_ADDR_VAR 0 8
65746: PUSH
65747: LD_INT 1
65749: PPUSH
65750: LD_VAR 0 7
65754: PUSH
65755: LD_INT 1
65757: ARRAY
65758: PPUSH
65759: CALL_OW 12
65763: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
65764: LD_ADDR_VAR 0 6
65768: PUSH
65769: LD_VAR 0 6
65773: PPUSH
65774: LD_VAR 0 5
65778: PPUSH
65779: LD_VAR 0 7
65783: PUSH
65784: LD_INT 1
65786: ARRAY
65787: PUSH
65788: LD_VAR 0 8
65792: ARRAY
65793: PUSH
65794: LD_VAR 0 7
65798: PUSH
65799: LD_INT 2
65801: ARRAY
65802: PUSH
65803: LD_VAR 0 8
65807: ARRAY
65808: PUSH
65809: EMPTY
65810: LIST
65811: LIST
65812: PPUSH
65813: CALL_OW 1
65817: ST_TO_ADDR
// end ;
65818: GO 65739
65820: POP
65821: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
65822: LD_ADDR_EXP 27
65826: PUSH
65827: LD_EXP 27
65831: PPUSH
65832: LD_VAR 0 1
65836: PPUSH
65837: LD_VAR 0 6
65841: PPUSH
65842: CALL_OW 1
65846: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
65847: LD_ADDR_EXP 29
65851: PUSH
65852: LD_EXP 29
65856: PPUSH
65857: LD_VAR 0 1
65861: PPUSH
65862: LD_VAR 0 3
65866: PPUSH
65867: CALL_OW 1
65871: ST_TO_ADDR
// end ;
65872: LD_VAR 0 4
65876: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
65877: LD_INT 0
65879: PPUSH
// if not mc_bases [ base ] then
65880: LD_EXP 14
65884: PUSH
65885: LD_VAR 0 1
65889: ARRAY
65890: NOT
65891: IFFALSE 65895
// exit ;
65893: GO 65920
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
65895: LD_ADDR_EXP 19
65899: PUSH
65900: LD_EXP 19
65904: PPUSH
65905: LD_VAR 0 1
65909: PPUSH
65910: LD_VAR 0 2
65914: PPUSH
65915: CALL_OW 1
65919: ST_TO_ADDR
// end ;
65920: LD_VAR 0 3
65924: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
65925: LD_INT 0
65927: PPUSH
// if not mc_bases [ base ] then
65928: LD_EXP 14
65932: PUSH
65933: LD_VAR 0 1
65937: ARRAY
65938: NOT
65939: IFFALSE 65943
// exit ;
65941: GO 65980
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
65943: LD_ADDR_EXP 19
65947: PUSH
65948: LD_EXP 19
65952: PPUSH
65953: LD_VAR 0 1
65957: PPUSH
65958: LD_EXP 19
65962: PUSH
65963: LD_VAR 0 1
65967: ARRAY
65968: PUSH
65969: LD_VAR 0 2
65973: UNION
65974: PPUSH
65975: CALL_OW 1
65979: ST_TO_ADDR
// end ;
65980: LD_VAR 0 3
65984: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
65985: LD_INT 0
65987: PPUSH
// if not mc_bases [ base ] then
65988: LD_EXP 14
65992: PUSH
65993: LD_VAR 0 1
65997: ARRAY
65998: NOT
65999: IFFALSE 66003
// exit ;
66001: GO 66028
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
66003: LD_ADDR_EXP 35
66007: PUSH
66008: LD_EXP 35
66012: PPUSH
66013: LD_VAR 0 1
66017: PPUSH
66018: LD_VAR 0 2
66022: PPUSH
66023: CALL_OW 1
66027: ST_TO_ADDR
// end ;
66028: LD_VAR 0 3
66032: RET
// export function MC_InsertProduceList ( base , components ) ; begin
66033: LD_INT 0
66035: PPUSH
// if not mc_bases [ base ] then
66036: LD_EXP 14
66040: PUSH
66041: LD_VAR 0 1
66045: ARRAY
66046: NOT
66047: IFFALSE 66051
// exit ;
66049: GO 66088
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
66051: LD_ADDR_EXP 35
66055: PUSH
66056: LD_EXP 35
66060: PPUSH
66061: LD_VAR 0 1
66065: PPUSH
66066: LD_EXP 35
66070: PUSH
66071: LD_VAR 0 1
66075: ARRAY
66076: PUSH
66077: LD_VAR 0 2
66081: ADD
66082: PPUSH
66083: CALL_OW 1
66087: ST_TO_ADDR
// end ;
66088: LD_VAR 0 3
66092: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
66093: LD_INT 0
66095: PPUSH
// if not mc_bases [ base ] then
66096: LD_EXP 14
66100: PUSH
66101: LD_VAR 0 1
66105: ARRAY
66106: NOT
66107: IFFALSE 66111
// exit ;
66109: GO 66165
// mc_defender := Replace ( mc_defender , base , deflist ) ;
66111: LD_ADDR_EXP 36
66115: PUSH
66116: LD_EXP 36
66120: PPUSH
66121: LD_VAR 0 1
66125: PPUSH
66126: LD_VAR 0 2
66130: PPUSH
66131: CALL_OW 1
66135: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
66136: LD_ADDR_EXP 25
66140: PUSH
66141: LD_EXP 25
66145: PPUSH
66146: LD_VAR 0 1
66150: PPUSH
66151: LD_VAR 0 2
66155: PUSH
66156: LD_INT 0
66158: PLUS
66159: PPUSH
66160: CALL_OW 1
66164: ST_TO_ADDR
// end ;
66165: LD_VAR 0 3
66169: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
66170: LD_INT 0
66172: PPUSH
// if not mc_bases [ base ] then
66173: LD_EXP 14
66177: PUSH
66178: LD_VAR 0 1
66182: ARRAY
66183: NOT
66184: IFFALSE 66188
// exit ;
66186: GO 66213
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
66188: LD_ADDR_EXP 25
66192: PUSH
66193: LD_EXP 25
66197: PPUSH
66198: LD_VAR 0 1
66202: PPUSH
66203: LD_VAR 0 2
66207: PPUSH
66208: CALL_OW 1
66212: ST_TO_ADDR
// end ;
66213: LD_VAR 0 3
66217: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
66218: LD_INT 0
66220: PPUSH
66221: PPUSH
66222: PPUSH
66223: PPUSH
// if not mc_bases [ base ] then
66224: LD_EXP 14
66228: PUSH
66229: LD_VAR 0 1
66233: ARRAY
66234: NOT
66235: IFFALSE 66239
// exit ;
66237: GO 66304
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
66239: LD_ADDR_EXP 34
66243: PUSH
66244: LD_EXP 34
66248: PPUSH
66249: LD_VAR 0 1
66253: PUSH
66254: LD_EXP 34
66258: PUSH
66259: LD_VAR 0 1
66263: ARRAY
66264: PUSH
66265: LD_INT 1
66267: PLUS
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PPUSH
66273: LD_VAR 0 1
66277: PUSH
66278: LD_VAR 0 2
66282: PUSH
66283: LD_VAR 0 3
66287: PUSH
66288: LD_VAR 0 4
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: LIST
66297: LIST
66298: PPUSH
66299: CALL 9427 0 3
66303: ST_TO_ADDR
// end ;
66304: LD_VAR 0 5
66308: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
66309: LD_INT 0
66311: PPUSH
// if not mc_bases [ base ] then
66312: LD_EXP 14
66316: PUSH
66317: LD_VAR 0 1
66321: ARRAY
66322: NOT
66323: IFFALSE 66327
// exit ;
66325: GO 66352
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
66327: LD_ADDR_EXP 51
66331: PUSH
66332: LD_EXP 51
66336: PPUSH
66337: LD_VAR 0 1
66341: PPUSH
66342: LD_VAR 0 2
66346: PPUSH
66347: CALL_OW 1
66351: ST_TO_ADDR
// end ;
66352: LD_VAR 0 3
66356: RET
// export function MC_GetMinesField ( base ) ; begin
66357: LD_INT 0
66359: PPUSH
// result := mc_mines [ base ] ;
66360: LD_ADDR_VAR 0 2
66364: PUSH
66365: LD_EXP 27
66369: PUSH
66370: LD_VAR 0 1
66374: ARRAY
66375: ST_TO_ADDR
// end ;
66376: LD_VAR 0 2
66380: RET
// export function MC_GetProduceList ( base ) ; begin
66381: LD_INT 0
66383: PPUSH
// result := mc_produce [ base ] ;
66384: LD_ADDR_VAR 0 2
66388: PUSH
66389: LD_EXP 35
66393: PUSH
66394: LD_VAR 0 1
66398: ARRAY
66399: ST_TO_ADDR
// end ;
66400: LD_VAR 0 2
66404: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
66405: LD_INT 0
66407: PPUSH
66408: PPUSH
// if not mc_bases then
66409: LD_EXP 14
66413: NOT
66414: IFFALSE 66418
// exit ;
66416: GO 66483
// if mc_bases [ base ] then
66418: LD_EXP 14
66422: PUSH
66423: LD_VAR 0 1
66427: ARRAY
66428: IFFALSE 66483
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66430: LD_ADDR_VAR 0 3
66434: PUSH
66435: LD_EXP 14
66439: PUSH
66440: LD_VAR 0 1
66444: ARRAY
66445: PPUSH
66446: LD_INT 30
66448: PUSH
66449: LD_VAR 0 2
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PPUSH
66458: CALL_OW 72
66462: ST_TO_ADDR
// if result then
66463: LD_VAR 0 3
66467: IFFALSE 66483
// result := result [ 1 ] ;
66469: LD_ADDR_VAR 0 3
66473: PUSH
66474: LD_VAR 0 3
66478: PUSH
66479: LD_INT 1
66481: ARRAY
66482: ST_TO_ADDR
// end ; end ;
66483: LD_VAR 0 3
66487: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
66488: LD_INT 0
66490: PPUSH
66491: PPUSH
// if not mc_bases then
66492: LD_EXP 14
66496: NOT
66497: IFFALSE 66501
// exit ;
66499: GO 66546
// if mc_bases [ base ] then
66501: LD_EXP 14
66505: PUSH
66506: LD_VAR 0 1
66510: ARRAY
66511: IFFALSE 66546
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66513: LD_ADDR_VAR 0 3
66517: PUSH
66518: LD_EXP 14
66522: PUSH
66523: LD_VAR 0 1
66527: ARRAY
66528: PPUSH
66529: LD_INT 30
66531: PUSH
66532: LD_VAR 0 2
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PPUSH
66541: CALL_OW 72
66545: ST_TO_ADDR
// end ;
66546: LD_VAR 0 3
66550: RET
// export function MC_SetTame ( base , area ) ; begin
66551: LD_INT 0
66553: PPUSH
// if not mc_bases or not base then
66554: LD_EXP 14
66558: NOT
66559: PUSH
66560: LD_VAR 0 1
66564: NOT
66565: OR
66566: IFFALSE 66570
// exit ;
66568: GO 66595
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
66570: LD_ADDR_EXP 42
66574: PUSH
66575: LD_EXP 42
66579: PPUSH
66580: LD_VAR 0 1
66584: PPUSH
66585: LD_VAR 0 2
66589: PPUSH
66590: CALL_OW 1
66594: ST_TO_ADDR
// end ;
66595: LD_VAR 0 3
66599: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
66600: LD_INT 0
66602: PPUSH
66603: PPUSH
// if not mc_bases or not base then
66604: LD_EXP 14
66608: NOT
66609: PUSH
66610: LD_VAR 0 1
66614: NOT
66615: OR
66616: IFFALSE 66620
// exit ;
66618: GO 66722
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
66620: LD_ADDR_VAR 0 4
66624: PUSH
66625: LD_EXP 14
66629: PUSH
66630: LD_VAR 0 1
66634: ARRAY
66635: PPUSH
66636: LD_INT 30
66638: PUSH
66639: LD_VAR 0 2
66643: PUSH
66644: EMPTY
66645: LIST
66646: LIST
66647: PPUSH
66648: CALL_OW 72
66652: ST_TO_ADDR
// if not tmp then
66653: LD_VAR 0 4
66657: NOT
66658: IFFALSE 66662
// exit ;
66660: GO 66722
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
66662: LD_ADDR_EXP 46
66666: PUSH
66667: LD_EXP 46
66671: PPUSH
66672: LD_VAR 0 1
66676: PPUSH
66677: LD_EXP 46
66681: PUSH
66682: LD_VAR 0 1
66686: ARRAY
66687: PPUSH
66688: LD_EXP 46
66692: PUSH
66693: LD_VAR 0 1
66697: ARRAY
66698: PUSH
66699: LD_INT 1
66701: PLUS
66702: PPUSH
66703: LD_VAR 0 4
66707: PUSH
66708: LD_INT 1
66710: ARRAY
66711: PPUSH
66712: CALL_OW 2
66716: PPUSH
66717: CALL_OW 1
66721: ST_TO_ADDR
// end ;
66722: LD_VAR 0 3
66726: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
66727: LD_INT 0
66729: PPUSH
66730: PPUSH
// if not mc_bases or not base or not kinds then
66731: LD_EXP 14
66735: NOT
66736: PUSH
66737: LD_VAR 0 1
66741: NOT
66742: OR
66743: PUSH
66744: LD_VAR 0 2
66748: NOT
66749: OR
66750: IFFALSE 66754
// exit ;
66752: GO 66815
// for i in kinds do
66754: LD_ADDR_VAR 0 4
66758: PUSH
66759: LD_VAR 0 2
66763: PUSH
66764: FOR_IN
66765: IFFALSE 66813
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
66767: LD_ADDR_EXP 48
66771: PUSH
66772: LD_EXP 48
66776: PPUSH
66777: LD_VAR 0 1
66781: PUSH
66782: LD_EXP 48
66786: PUSH
66787: LD_VAR 0 1
66791: ARRAY
66792: PUSH
66793: LD_INT 1
66795: PLUS
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PPUSH
66801: LD_VAR 0 4
66805: PPUSH
66806: CALL 9427 0 3
66810: ST_TO_ADDR
66811: GO 66764
66813: POP
66814: POP
// end ;
66815: LD_VAR 0 3
66819: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
66820: LD_INT 0
66822: PPUSH
// if not mc_bases or not base or not areas then
66823: LD_EXP 14
66827: NOT
66828: PUSH
66829: LD_VAR 0 1
66833: NOT
66834: OR
66835: PUSH
66836: LD_VAR 0 2
66840: NOT
66841: OR
66842: IFFALSE 66846
// exit ;
66844: GO 66871
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
66846: LD_ADDR_EXP 32
66850: PUSH
66851: LD_EXP 32
66855: PPUSH
66856: LD_VAR 0 1
66860: PPUSH
66861: LD_VAR 0 2
66865: PPUSH
66866: CALL_OW 1
66870: ST_TO_ADDR
// end ;
66871: LD_VAR 0 3
66875: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
66876: LD_INT 0
66878: PPUSH
// if not mc_bases or not base or not teleports_exit then
66879: LD_EXP 14
66883: NOT
66884: PUSH
66885: LD_VAR 0 1
66889: NOT
66890: OR
66891: PUSH
66892: LD_VAR 0 2
66896: NOT
66897: OR
66898: IFFALSE 66902
// exit ;
66900: GO 66927
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
66902: LD_ADDR_EXP 49
66906: PUSH
66907: LD_EXP 49
66911: PPUSH
66912: LD_VAR 0 1
66916: PPUSH
66917: LD_VAR 0 2
66921: PPUSH
66922: CALL_OW 1
66926: ST_TO_ADDR
// end ;
66927: LD_VAR 0 3
66931: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
66932: LD_INT 0
66934: PPUSH
66935: PPUSH
66936: PPUSH
// if not mc_bases or not base or not ext_list then
66937: LD_EXP 14
66941: NOT
66942: PUSH
66943: LD_VAR 0 1
66947: NOT
66948: OR
66949: PUSH
66950: LD_VAR 0 5
66954: NOT
66955: OR
66956: IFFALSE 66960
// exit ;
66958: GO 67133
// tmp := GetFacExtXYD ( x , y , d ) ;
66960: LD_ADDR_VAR 0 8
66964: PUSH
66965: LD_VAR 0 2
66969: PPUSH
66970: LD_VAR 0 3
66974: PPUSH
66975: LD_VAR 0 4
66979: PPUSH
66980: CALL 38439 0 3
66984: ST_TO_ADDR
// if not tmp then
66985: LD_VAR 0 8
66989: NOT
66990: IFFALSE 66994
// exit ;
66992: GO 67133
// for i in tmp do
66994: LD_ADDR_VAR 0 7
66998: PUSH
66999: LD_VAR 0 8
67003: PUSH
67004: FOR_IN
67005: IFFALSE 67131
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
67007: LD_ADDR_EXP 19
67011: PUSH
67012: LD_EXP 19
67016: PPUSH
67017: LD_VAR 0 1
67021: PPUSH
67022: LD_EXP 19
67026: PUSH
67027: LD_VAR 0 1
67031: ARRAY
67032: PPUSH
67033: LD_EXP 19
67037: PUSH
67038: LD_VAR 0 1
67042: ARRAY
67043: PUSH
67044: LD_INT 1
67046: PLUS
67047: PPUSH
67048: LD_VAR 0 5
67052: PUSH
67053: LD_INT 1
67055: ARRAY
67056: PUSH
67057: LD_VAR 0 7
67061: PUSH
67062: LD_INT 1
67064: ARRAY
67065: PUSH
67066: LD_VAR 0 7
67070: PUSH
67071: LD_INT 2
67073: ARRAY
67074: PUSH
67075: LD_VAR 0 7
67079: PUSH
67080: LD_INT 3
67082: ARRAY
67083: PUSH
67084: EMPTY
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: PPUSH
67090: CALL_OW 2
67094: PPUSH
67095: CALL_OW 1
67099: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
67100: LD_ADDR_VAR 0 5
67104: PUSH
67105: LD_VAR 0 5
67109: PPUSH
67110: LD_INT 1
67112: PPUSH
67113: CALL_OW 3
67117: ST_TO_ADDR
// if not ext_list then
67118: LD_VAR 0 5
67122: NOT
67123: IFFALSE 67129
// exit ;
67125: POP
67126: POP
67127: GO 67133
// end ;
67129: GO 67004
67131: POP
67132: POP
// end ;
67133: LD_VAR 0 6
67137: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
67138: LD_INT 0
67140: PPUSH
// if not mc_bases or not base or not weapon_list then
67141: LD_EXP 14
67145: NOT
67146: PUSH
67147: LD_VAR 0 1
67151: NOT
67152: OR
67153: PUSH
67154: LD_VAR 0 2
67158: NOT
67159: OR
67160: IFFALSE 67164
// exit ;
67162: GO 67189
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
67164: LD_ADDR_EXP 53
67168: PUSH
67169: LD_EXP 53
67173: PPUSH
67174: LD_VAR 0 1
67178: PPUSH
67179: LD_VAR 0 2
67183: PPUSH
67184: CALL_OW 1
67188: ST_TO_ADDR
// end ;
67189: LD_VAR 0 3
67193: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
67194: LD_INT 0
67196: PPUSH
// if not mc_bases or not base or not tech_list then
67197: LD_EXP 14
67201: NOT
67202: PUSH
67203: LD_VAR 0 1
67207: NOT
67208: OR
67209: PUSH
67210: LD_VAR 0 2
67214: NOT
67215: OR
67216: IFFALSE 67220
// exit ;
67218: GO 67245
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
67220: LD_ADDR_EXP 41
67224: PUSH
67225: LD_EXP 41
67229: PPUSH
67230: LD_VAR 0 1
67234: PPUSH
67235: LD_VAR 0 2
67239: PPUSH
67240: CALL_OW 1
67244: ST_TO_ADDR
// end ;
67245: LD_VAR 0 3
67249: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
67250: LD_INT 0
67252: PPUSH
// if not mc_bases or not parking_area or not base then
67253: LD_EXP 14
67257: NOT
67258: PUSH
67259: LD_VAR 0 2
67263: NOT
67264: OR
67265: PUSH
67266: LD_VAR 0 1
67270: NOT
67271: OR
67272: IFFALSE 67276
// exit ;
67274: GO 67301
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
67276: LD_ADDR_EXP 38
67280: PUSH
67281: LD_EXP 38
67285: PPUSH
67286: LD_VAR 0 1
67290: PPUSH
67291: LD_VAR 0 2
67295: PPUSH
67296: CALL_OW 1
67300: ST_TO_ADDR
// end ;
67301: LD_VAR 0 3
67305: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
67306: LD_INT 0
67308: PPUSH
// if not mc_bases or not base or not scan_area then
67309: LD_EXP 14
67313: NOT
67314: PUSH
67315: LD_VAR 0 1
67319: NOT
67320: OR
67321: PUSH
67322: LD_VAR 0 2
67326: NOT
67327: OR
67328: IFFALSE 67332
// exit ;
67330: GO 67357
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
67332: LD_ADDR_EXP 39
67336: PUSH
67337: LD_EXP 39
67341: PPUSH
67342: LD_VAR 0 1
67346: PPUSH
67347: LD_VAR 0 2
67351: PPUSH
67352: CALL_OW 1
67356: ST_TO_ADDR
// end ;
67357: LD_VAR 0 3
67361: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
67362: LD_INT 0
67364: PPUSH
67365: PPUSH
// if not mc_bases or not base then
67366: LD_EXP 14
67370: NOT
67371: PUSH
67372: LD_VAR 0 1
67376: NOT
67377: OR
67378: IFFALSE 67382
// exit ;
67380: GO 67446
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
67382: LD_ADDR_VAR 0 3
67386: PUSH
67387: LD_INT 1
67389: PUSH
67390: LD_INT 2
67392: PUSH
67393: LD_INT 3
67395: PUSH
67396: LD_INT 4
67398: PUSH
67399: LD_INT 11
67401: PUSH
67402: EMPTY
67403: LIST
67404: LIST
67405: LIST
67406: LIST
67407: LIST
67408: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
67409: LD_ADDR_EXP 41
67413: PUSH
67414: LD_EXP 41
67418: PPUSH
67419: LD_VAR 0 1
67423: PPUSH
67424: LD_EXP 41
67428: PUSH
67429: LD_VAR 0 1
67433: ARRAY
67434: PUSH
67435: LD_VAR 0 3
67439: DIFF
67440: PPUSH
67441: CALL_OW 1
67445: ST_TO_ADDR
// end ;
67446: LD_VAR 0 2
67450: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
67451: LD_INT 0
67453: PPUSH
// result := mc_vehicles [ base ] ;
67454: LD_ADDR_VAR 0 3
67458: PUSH
67459: LD_EXP 33
67463: PUSH
67464: LD_VAR 0 1
67468: ARRAY
67469: ST_TO_ADDR
// if onlyCombat then
67470: LD_VAR 0 2
67474: IFFALSE 67652
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
67476: LD_ADDR_VAR 0 3
67480: PUSH
67481: LD_VAR 0 3
67485: PUSH
67486: LD_VAR 0 3
67490: PPUSH
67491: LD_INT 2
67493: PUSH
67494: LD_INT 34
67496: PUSH
67497: LD_INT 12
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 34
67506: PUSH
67507: LD_INT 51
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 34
67516: PUSH
67517: LD_EXP 59
67521: PUSH
67522: EMPTY
67523: LIST
67524: LIST
67525: PUSH
67526: LD_INT 34
67528: PUSH
67529: LD_INT 32
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 34
67538: PUSH
67539: LD_INT 13
67541: PUSH
67542: EMPTY
67543: LIST
67544: LIST
67545: PUSH
67546: LD_INT 34
67548: PUSH
67549: LD_INT 52
67551: PUSH
67552: EMPTY
67553: LIST
67554: LIST
67555: PUSH
67556: LD_INT 34
67558: PUSH
67559: LD_EXP 64
67563: PUSH
67564: EMPTY
67565: LIST
67566: LIST
67567: PUSH
67568: LD_INT 34
67570: PUSH
67571: LD_INT 14
67573: PUSH
67574: EMPTY
67575: LIST
67576: LIST
67577: PUSH
67578: LD_INT 34
67580: PUSH
67581: LD_INT 53
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 34
67590: PUSH
67591: LD_EXP 58
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 34
67602: PUSH
67603: LD_INT 31
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 34
67612: PUSH
67613: LD_INT 48
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 34
67622: PUSH
67623: LD_INT 8
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: EMPTY
67631: LIST
67632: LIST
67633: LIST
67634: LIST
67635: LIST
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: PPUSH
67646: CALL_OW 72
67650: DIFF
67651: ST_TO_ADDR
// end ; end_of_file
67652: LD_VAR 0 3
67656: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
67657: LD_INT 0
67659: PPUSH
67660: PPUSH
67661: PPUSH
// if not mc_bases or not skirmish then
67662: LD_EXP 14
67666: NOT
67667: PUSH
67668: LD_EXP 12
67672: NOT
67673: OR
67674: IFFALSE 67678
// exit ;
67676: GO 67843
// for i = 1 to mc_bases do
67678: LD_ADDR_VAR 0 4
67682: PUSH
67683: DOUBLE
67684: LD_INT 1
67686: DEC
67687: ST_TO_ADDR
67688: LD_EXP 14
67692: PUSH
67693: FOR_TO
67694: IFFALSE 67841
// begin if sci in mc_bases [ i ] then
67696: LD_VAR 0 2
67700: PUSH
67701: LD_EXP 14
67705: PUSH
67706: LD_VAR 0 4
67710: ARRAY
67711: IN
67712: IFFALSE 67839
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
67714: LD_ADDR_EXP 43
67718: PUSH
67719: LD_EXP 43
67723: PPUSH
67724: LD_VAR 0 4
67728: PUSH
67729: LD_EXP 43
67733: PUSH
67734: LD_VAR 0 4
67738: ARRAY
67739: PUSH
67740: LD_INT 1
67742: PLUS
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PPUSH
67748: LD_VAR 0 1
67752: PPUSH
67753: CALL 9427 0 3
67757: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
67758: LD_ADDR_VAR 0 5
67762: PUSH
67763: LD_EXP 14
67767: PUSH
67768: LD_VAR 0 4
67772: ARRAY
67773: PPUSH
67774: LD_INT 2
67776: PUSH
67777: LD_INT 30
67779: PUSH
67780: LD_INT 0
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: PUSH
67787: LD_INT 30
67789: PUSH
67790: LD_INT 1
67792: PUSH
67793: EMPTY
67794: LIST
67795: LIST
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: LIST
67801: PPUSH
67802: CALL_OW 72
67806: PPUSH
67807: LD_VAR 0 1
67811: PPUSH
67812: CALL_OW 74
67816: ST_TO_ADDR
// if tmp then
67817: LD_VAR 0 5
67821: IFFALSE 67837
// ComStandNearbyBuilding ( ape , tmp ) ;
67823: LD_VAR 0 1
67827: PPUSH
67828: LD_VAR 0 5
67832: PPUSH
67833: CALL 6041 0 2
// break ;
67837: GO 67841
// end ; end ;
67839: GO 67693
67841: POP
67842: POP
// end ;
67843: LD_VAR 0 3
67847: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
67848: LD_INT 0
67850: PPUSH
67851: PPUSH
67852: PPUSH
// if not mc_bases or not skirmish then
67853: LD_EXP 14
67857: NOT
67858: PUSH
67859: LD_EXP 12
67863: NOT
67864: OR
67865: IFFALSE 67869
// exit ;
67867: GO 67958
// for i = 1 to mc_bases do
67869: LD_ADDR_VAR 0 4
67873: PUSH
67874: DOUBLE
67875: LD_INT 1
67877: DEC
67878: ST_TO_ADDR
67879: LD_EXP 14
67883: PUSH
67884: FOR_TO
67885: IFFALSE 67956
// begin if building in mc_busy_turret_list [ i ] then
67887: LD_VAR 0 1
67891: PUSH
67892: LD_EXP 24
67896: PUSH
67897: LD_VAR 0 4
67901: ARRAY
67902: IN
67903: IFFALSE 67954
// begin tmp := mc_busy_turret_list [ i ] diff building ;
67905: LD_ADDR_VAR 0 5
67909: PUSH
67910: LD_EXP 24
67914: PUSH
67915: LD_VAR 0 4
67919: ARRAY
67920: PUSH
67921: LD_VAR 0 1
67925: DIFF
67926: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
67927: LD_ADDR_EXP 24
67931: PUSH
67932: LD_EXP 24
67936: PPUSH
67937: LD_VAR 0 4
67941: PPUSH
67942: LD_VAR 0 5
67946: PPUSH
67947: CALL_OW 1
67951: ST_TO_ADDR
// break ;
67952: GO 67956
// end ; end ;
67954: GO 67884
67956: POP
67957: POP
// end ;
67958: LD_VAR 0 3
67962: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
67963: LD_INT 0
67965: PPUSH
67966: PPUSH
67967: PPUSH
// if not mc_bases or not skirmish then
67968: LD_EXP 14
67972: NOT
67973: PUSH
67974: LD_EXP 12
67978: NOT
67979: OR
67980: IFFALSE 67984
// exit ;
67982: GO 68183
// for i = 1 to mc_bases do
67984: LD_ADDR_VAR 0 5
67988: PUSH
67989: DOUBLE
67990: LD_INT 1
67992: DEC
67993: ST_TO_ADDR
67994: LD_EXP 14
67998: PUSH
67999: FOR_TO
68000: IFFALSE 68181
// if building in mc_bases [ i ] then
68002: LD_VAR 0 1
68006: PUSH
68007: LD_EXP 14
68011: PUSH
68012: LD_VAR 0 5
68016: ARRAY
68017: IN
68018: IFFALSE 68179
// begin tmp := mc_bases [ i ] diff building ;
68020: LD_ADDR_VAR 0 6
68024: PUSH
68025: LD_EXP 14
68029: PUSH
68030: LD_VAR 0 5
68034: ARRAY
68035: PUSH
68036: LD_VAR 0 1
68040: DIFF
68041: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
68042: LD_ADDR_EXP 14
68046: PUSH
68047: LD_EXP 14
68051: PPUSH
68052: LD_VAR 0 5
68056: PPUSH
68057: LD_VAR 0 6
68061: PPUSH
68062: CALL_OW 1
68066: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
68067: LD_VAR 0 1
68071: PUSH
68072: LD_EXP 22
68076: PUSH
68077: LD_VAR 0 5
68081: ARRAY
68082: IN
68083: IFFALSE 68122
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
68085: LD_ADDR_EXP 22
68089: PUSH
68090: LD_EXP 22
68094: PPUSH
68095: LD_VAR 0 5
68099: PPUSH
68100: LD_EXP 22
68104: PUSH
68105: LD_VAR 0 5
68109: ARRAY
68110: PUSH
68111: LD_VAR 0 1
68115: DIFF
68116: PPUSH
68117: CALL_OW 1
68121: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
68122: LD_VAR 0 1
68126: PUSH
68127: LD_EXP 23
68131: PUSH
68132: LD_VAR 0 5
68136: ARRAY
68137: IN
68138: IFFALSE 68177
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
68140: LD_ADDR_EXP 23
68144: PUSH
68145: LD_EXP 23
68149: PPUSH
68150: LD_VAR 0 5
68154: PPUSH
68155: LD_EXP 23
68159: PUSH
68160: LD_VAR 0 5
68164: ARRAY
68165: PUSH
68166: LD_VAR 0 1
68170: DIFF
68171: PPUSH
68172: CALL_OW 1
68176: ST_TO_ADDR
// break ;
68177: GO 68181
// end ;
68179: GO 67999
68181: POP
68182: POP
// end ;
68183: LD_VAR 0 4
68187: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
68188: LD_INT 0
68190: PPUSH
68191: PPUSH
68192: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
68193: LD_EXP 14
68197: NOT
68198: PUSH
68199: LD_EXP 12
68203: NOT
68204: OR
68205: PUSH
68206: LD_VAR 0 3
68210: PUSH
68211: LD_EXP 40
68215: IN
68216: NOT
68217: OR
68218: IFFALSE 68222
// exit ;
68220: GO 68345
// for i = 1 to mc_vehicles do
68222: LD_ADDR_VAR 0 6
68226: PUSH
68227: DOUBLE
68228: LD_INT 1
68230: DEC
68231: ST_TO_ADDR
68232: LD_EXP 33
68236: PUSH
68237: FOR_TO
68238: IFFALSE 68343
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
68240: LD_VAR 0 2
68244: PUSH
68245: LD_EXP 33
68249: PUSH
68250: LD_VAR 0 6
68254: ARRAY
68255: IN
68256: PUSH
68257: LD_VAR 0 1
68261: PUSH
68262: LD_EXP 33
68266: PUSH
68267: LD_VAR 0 6
68271: ARRAY
68272: IN
68273: OR
68274: IFFALSE 68341
// begin tmp := mc_vehicles [ i ] diff old ;
68276: LD_ADDR_VAR 0 7
68280: PUSH
68281: LD_EXP 33
68285: PUSH
68286: LD_VAR 0 6
68290: ARRAY
68291: PUSH
68292: LD_VAR 0 2
68296: DIFF
68297: ST_TO_ADDR
// tmp := tmp diff new ;
68298: LD_ADDR_VAR 0 7
68302: PUSH
68303: LD_VAR 0 7
68307: PUSH
68308: LD_VAR 0 1
68312: DIFF
68313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
68314: LD_ADDR_EXP 33
68318: PUSH
68319: LD_EXP 33
68323: PPUSH
68324: LD_VAR 0 6
68328: PPUSH
68329: LD_VAR 0 7
68333: PPUSH
68334: CALL_OW 1
68338: ST_TO_ADDR
// break ;
68339: GO 68343
// end ;
68341: GO 68237
68343: POP
68344: POP
// end ;
68345: LD_VAR 0 5
68349: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
68350: LD_INT 0
68352: PPUSH
68353: PPUSH
68354: PPUSH
68355: PPUSH
// if not mc_bases or not skirmish then
68356: LD_EXP 14
68360: NOT
68361: PUSH
68362: LD_EXP 12
68366: NOT
68367: OR
68368: IFFALSE 68372
// exit ;
68370: GO 68755
// side := GetSide ( vehicle ) ;
68372: LD_ADDR_VAR 0 5
68376: PUSH
68377: LD_VAR 0 1
68381: PPUSH
68382: CALL_OW 255
68386: ST_TO_ADDR
// for i = 1 to mc_bases do
68387: LD_ADDR_VAR 0 4
68391: PUSH
68392: DOUBLE
68393: LD_INT 1
68395: DEC
68396: ST_TO_ADDR
68397: LD_EXP 14
68401: PUSH
68402: FOR_TO
68403: IFFALSE 68753
// begin if factory in mc_bases [ i ] then
68405: LD_VAR 0 2
68409: PUSH
68410: LD_EXP 14
68414: PUSH
68415: LD_VAR 0 4
68419: ARRAY
68420: IN
68421: IFFALSE 68751
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
68423: LD_EXP 36
68427: PUSH
68428: LD_VAR 0 4
68432: ARRAY
68433: PUSH
68434: LD_EXP 25
68438: PUSH
68439: LD_VAR 0 4
68443: ARRAY
68444: LESS
68445: PUSH
68446: LD_VAR 0 1
68450: PPUSH
68451: CALL_OW 264
68455: PUSH
68456: LD_INT 31
68458: PUSH
68459: LD_INT 32
68461: PUSH
68462: LD_INT 51
68464: PUSH
68465: LD_EXP 59
68469: PUSH
68470: LD_INT 12
68472: PUSH
68473: LD_INT 30
68475: PUSH
68476: LD_EXP 58
68480: PUSH
68481: LD_INT 11
68483: PUSH
68484: LD_INT 53
68486: PUSH
68487: LD_INT 14
68489: PUSH
68490: LD_EXP 62
68494: PUSH
68495: LD_INT 29
68497: PUSH
68498: LD_EXP 60
68502: PUSH
68503: LD_INT 13
68505: PUSH
68506: LD_INT 52
68508: PUSH
68509: LD_EXP 64
68513: PUSH
68514: LD_INT 48
68516: PUSH
68517: LD_INT 8
68519: PUSH
68520: EMPTY
68521: LIST
68522: LIST
68523: LIST
68524: LIST
68525: LIST
68526: LIST
68527: LIST
68528: LIST
68529: LIST
68530: LIST
68531: LIST
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: LIST
68537: LIST
68538: LIST
68539: IN
68540: NOT
68541: AND
68542: IFFALSE 68590
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
68544: LD_ADDR_EXP 36
68548: PUSH
68549: LD_EXP 36
68553: PPUSH
68554: LD_VAR 0 4
68558: PUSH
68559: LD_EXP 36
68563: PUSH
68564: LD_VAR 0 4
68568: ARRAY
68569: PUSH
68570: LD_INT 1
68572: PLUS
68573: PUSH
68574: EMPTY
68575: LIST
68576: LIST
68577: PPUSH
68578: LD_VAR 0 1
68582: PPUSH
68583: CALL 9427 0 3
68587: ST_TO_ADDR
68588: GO 68634
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
68590: LD_ADDR_EXP 33
68594: PUSH
68595: LD_EXP 33
68599: PPUSH
68600: LD_VAR 0 4
68604: PUSH
68605: LD_EXP 33
68609: PUSH
68610: LD_VAR 0 4
68614: ARRAY
68615: PUSH
68616: LD_INT 1
68618: PLUS
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PPUSH
68624: LD_VAR 0 1
68628: PPUSH
68629: CALL 9427 0 3
68633: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
68634: LD_VAR 0 1
68638: PPUSH
68639: CALL_OW 263
68643: PUSH
68644: LD_INT 2
68646: EQUAL
68647: IFFALSE 68667
// begin repeat wait ( 0 0$1 ) ;
68649: LD_INT 35
68651: PPUSH
68652: CALL_OW 67
// until IsControledBy ( vehicle ) ;
68656: LD_VAR 0 1
68660: PPUSH
68661: CALL_OW 312
68665: IFFALSE 68649
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
68667: LD_VAR 0 1
68671: PPUSH
68672: LD_EXP 38
68676: PUSH
68677: LD_VAR 0 4
68681: ARRAY
68682: PPUSH
68683: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
68687: LD_VAR 0 1
68691: PPUSH
68692: CALL_OW 263
68696: PUSH
68697: LD_INT 1
68699: NONEQUAL
68700: IFFALSE 68704
// break ;
68702: GO 68753
// repeat wait ( 0 0$1 ) ;
68704: LD_INT 35
68706: PPUSH
68707: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
68711: LD_VAR 0 1
68715: PPUSH
68716: LD_EXP 38
68720: PUSH
68721: LD_VAR 0 4
68725: ARRAY
68726: PPUSH
68727: CALL_OW 308
68731: IFFALSE 68704
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
68733: LD_VAR 0 1
68737: PPUSH
68738: CALL_OW 311
68742: PPUSH
68743: CALL_OW 121
// exit ;
68747: POP
68748: POP
68749: GO 68755
// end ; end ;
68751: GO 68402
68753: POP
68754: POP
// end ;
68755: LD_VAR 0 3
68759: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
68760: LD_INT 0
68762: PPUSH
68763: PPUSH
68764: PPUSH
68765: PPUSH
// if not mc_bases or not skirmish then
68766: LD_EXP 14
68770: NOT
68771: PUSH
68772: LD_EXP 12
68776: NOT
68777: OR
68778: IFFALSE 68782
// exit ;
68780: GO 69135
// repeat wait ( 0 0$1 ) ;
68782: LD_INT 35
68784: PPUSH
68785: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
68789: LD_VAR 0 2
68793: PPUSH
68794: LD_VAR 0 3
68798: PPUSH
68799: CALL_OW 284
68803: IFFALSE 68782
// if GetResourceTypeXY ( x , y ) = mat_artefact then
68805: LD_VAR 0 2
68809: PPUSH
68810: LD_VAR 0 3
68814: PPUSH
68815: CALL_OW 283
68819: PUSH
68820: LD_INT 4
68822: EQUAL
68823: IFFALSE 68827
// exit ;
68825: GO 69135
// for i = 1 to mc_bases do
68827: LD_ADDR_VAR 0 7
68831: PUSH
68832: DOUBLE
68833: LD_INT 1
68835: DEC
68836: ST_TO_ADDR
68837: LD_EXP 14
68841: PUSH
68842: FOR_TO
68843: IFFALSE 69133
// begin if mc_crates_area [ i ] then
68845: LD_EXP 32
68849: PUSH
68850: LD_VAR 0 7
68854: ARRAY
68855: IFFALSE 68966
// for j in mc_crates_area [ i ] do
68857: LD_ADDR_VAR 0 8
68861: PUSH
68862: LD_EXP 32
68866: PUSH
68867: LD_VAR 0 7
68871: ARRAY
68872: PUSH
68873: FOR_IN
68874: IFFALSE 68964
// if InArea ( x , y , j ) then
68876: LD_VAR 0 2
68880: PPUSH
68881: LD_VAR 0 3
68885: PPUSH
68886: LD_VAR 0 8
68890: PPUSH
68891: CALL_OW 309
68895: IFFALSE 68962
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
68897: LD_ADDR_EXP 30
68901: PUSH
68902: LD_EXP 30
68906: PPUSH
68907: LD_VAR 0 7
68911: PUSH
68912: LD_EXP 30
68916: PUSH
68917: LD_VAR 0 7
68921: ARRAY
68922: PUSH
68923: LD_INT 1
68925: PLUS
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PPUSH
68931: LD_VAR 0 4
68935: PUSH
68936: LD_VAR 0 2
68940: PUSH
68941: LD_VAR 0 3
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: LIST
68950: PPUSH
68951: CALL 9427 0 3
68955: ST_TO_ADDR
// exit ;
68956: POP
68957: POP
68958: POP
68959: POP
68960: GO 69135
// end ;
68962: GO 68873
68964: POP
68965: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68966: LD_ADDR_VAR 0 9
68970: PUSH
68971: LD_EXP 14
68975: PUSH
68976: LD_VAR 0 7
68980: ARRAY
68981: PPUSH
68982: LD_INT 2
68984: PUSH
68985: LD_INT 30
68987: PUSH
68988: LD_INT 0
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: LD_INT 30
68997: PUSH
68998: LD_INT 1
69000: PUSH
69001: EMPTY
69002: LIST
69003: LIST
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: LIST
69009: PPUSH
69010: CALL_OW 72
69014: ST_TO_ADDR
// if not depot then
69015: LD_VAR 0 9
69019: NOT
69020: IFFALSE 69024
// continue ;
69022: GO 68842
// for j in depot do
69024: LD_ADDR_VAR 0 8
69028: PUSH
69029: LD_VAR 0 9
69033: PUSH
69034: FOR_IN
69035: IFFALSE 69129
// if GetDistUnitXY ( j , x , y ) < 30 then
69037: LD_VAR 0 8
69041: PPUSH
69042: LD_VAR 0 2
69046: PPUSH
69047: LD_VAR 0 3
69051: PPUSH
69052: CALL_OW 297
69056: PUSH
69057: LD_INT 30
69059: LESS
69060: IFFALSE 69127
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
69062: LD_ADDR_EXP 30
69066: PUSH
69067: LD_EXP 30
69071: PPUSH
69072: LD_VAR 0 7
69076: PUSH
69077: LD_EXP 30
69081: PUSH
69082: LD_VAR 0 7
69086: ARRAY
69087: PUSH
69088: LD_INT 1
69090: PLUS
69091: PUSH
69092: EMPTY
69093: LIST
69094: LIST
69095: PPUSH
69096: LD_VAR 0 4
69100: PUSH
69101: LD_VAR 0 2
69105: PUSH
69106: LD_VAR 0 3
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: LIST
69115: PPUSH
69116: CALL 9427 0 3
69120: ST_TO_ADDR
// exit ;
69121: POP
69122: POP
69123: POP
69124: POP
69125: GO 69135
// end ;
69127: GO 69034
69129: POP
69130: POP
// end ;
69131: GO 68842
69133: POP
69134: POP
// end ;
69135: LD_VAR 0 6
69139: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
69140: LD_INT 0
69142: PPUSH
69143: PPUSH
69144: PPUSH
69145: PPUSH
// if not mc_bases or not skirmish then
69146: LD_EXP 14
69150: NOT
69151: PUSH
69152: LD_EXP 12
69156: NOT
69157: OR
69158: IFFALSE 69162
// exit ;
69160: GO 69439
// side := GetSide ( lab ) ;
69162: LD_ADDR_VAR 0 4
69166: PUSH
69167: LD_VAR 0 2
69171: PPUSH
69172: CALL_OW 255
69176: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
69177: LD_VAR 0 4
69181: PUSH
69182: LD_EXP 40
69186: IN
69187: NOT
69188: PUSH
69189: LD_EXP 41
69193: NOT
69194: OR
69195: PUSH
69196: LD_EXP 14
69200: NOT
69201: OR
69202: IFFALSE 69206
// exit ;
69204: GO 69439
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
69206: LD_ADDR_EXP 41
69210: PUSH
69211: LD_EXP 41
69215: PPUSH
69216: LD_VAR 0 4
69220: PPUSH
69221: LD_EXP 41
69225: PUSH
69226: LD_VAR 0 4
69230: ARRAY
69231: PUSH
69232: LD_VAR 0 1
69236: DIFF
69237: PPUSH
69238: CALL_OW 1
69242: ST_TO_ADDR
// for i = 1 to mc_bases do
69243: LD_ADDR_VAR 0 5
69247: PUSH
69248: DOUBLE
69249: LD_INT 1
69251: DEC
69252: ST_TO_ADDR
69253: LD_EXP 14
69257: PUSH
69258: FOR_TO
69259: IFFALSE 69437
// begin if lab in mc_bases [ i ] then
69261: LD_VAR 0 2
69265: PUSH
69266: LD_EXP 14
69270: PUSH
69271: LD_VAR 0 5
69275: ARRAY
69276: IN
69277: IFFALSE 69435
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
69279: LD_VAR 0 1
69283: PUSH
69284: LD_INT 11
69286: PUSH
69287: LD_INT 4
69289: PUSH
69290: LD_INT 3
69292: PUSH
69293: LD_INT 2
69295: PUSH
69296: EMPTY
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: IN
69302: PUSH
69303: LD_EXP 44
69307: PUSH
69308: LD_VAR 0 5
69312: ARRAY
69313: AND
69314: IFFALSE 69435
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
69316: LD_ADDR_VAR 0 6
69320: PUSH
69321: LD_EXP 44
69325: PUSH
69326: LD_VAR 0 5
69330: ARRAY
69331: PUSH
69332: LD_INT 1
69334: ARRAY
69335: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
69336: LD_ADDR_EXP 44
69340: PUSH
69341: LD_EXP 44
69345: PPUSH
69346: LD_VAR 0 5
69350: PPUSH
69351: EMPTY
69352: PPUSH
69353: CALL_OW 1
69357: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
69358: LD_VAR 0 6
69362: PPUSH
69363: LD_INT 0
69365: PPUSH
69366: CALL_OW 109
// ComExitBuilding ( tmp ) ;
69370: LD_VAR 0 6
69374: PPUSH
69375: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
69379: LD_ADDR_EXP 43
69383: PUSH
69384: LD_EXP 43
69388: PPUSH
69389: LD_VAR 0 5
69393: PPUSH
69394: LD_EXP 43
69398: PUSH
69399: LD_VAR 0 5
69403: ARRAY
69404: PPUSH
69405: LD_INT 1
69407: PPUSH
69408: LD_VAR 0 6
69412: PPUSH
69413: CALL_OW 2
69417: PPUSH
69418: CALL_OW 1
69422: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
69423: LD_VAR 0 5
69427: PPUSH
69428: LD_INT 112
69430: PPUSH
69431: CALL 46268 0 2
// end ; end ; end ;
69435: GO 69258
69437: POP
69438: POP
// end ;
69439: LD_VAR 0 3
69443: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
69444: LD_INT 0
69446: PPUSH
69447: PPUSH
69448: PPUSH
69449: PPUSH
69450: PPUSH
69451: PPUSH
69452: PPUSH
69453: PPUSH
// if not mc_bases or not skirmish then
69454: LD_EXP 14
69458: NOT
69459: PUSH
69460: LD_EXP 12
69464: NOT
69465: OR
69466: IFFALSE 69470
// exit ;
69468: GO 70841
// for i = 1 to mc_bases do
69470: LD_ADDR_VAR 0 3
69474: PUSH
69475: DOUBLE
69476: LD_INT 1
69478: DEC
69479: ST_TO_ADDR
69480: LD_EXP 14
69484: PUSH
69485: FOR_TO
69486: IFFALSE 70839
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
69488: LD_VAR 0 1
69492: PUSH
69493: LD_EXP 14
69497: PUSH
69498: LD_VAR 0 3
69502: ARRAY
69503: IN
69504: PUSH
69505: LD_VAR 0 1
69509: PUSH
69510: LD_EXP 21
69514: PUSH
69515: LD_VAR 0 3
69519: ARRAY
69520: IN
69521: OR
69522: PUSH
69523: LD_VAR 0 1
69527: PUSH
69528: LD_EXP 36
69532: PUSH
69533: LD_VAR 0 3
69537: ARRAY
69538: IN
69539: OR
69540: PUSH
69541: LD_VAR 0 1
69545: PUSH
69546: LD_EXP 33
69550: PUSH
69551: LD_VAR 0 3
69555: ARRAY
69556: IN
69557: OR
69558: PUSH
69559: LD_VAR 0 1
69563: PUSH
69564: LD_EXP 43
69568: PUSH
69569: LD_VAR 0 3
69573: ARRAY
69574: IN
69575: OR
69576: PUSH
69577: LD_VAR 0 1
69581: PUSH
69582: LD_EXP 44
69586: PUSH
69587: LD_VAR 0 3
69591: ARRAY
69592: IN
69593: OR
69594: IFFALSE 70837
// begin if un in mc_ape [ i ] then
69596: LD_VAR 0 1
69600: PUSH
69601: LD_EXP 43
69605: PUSH
69606: LD_VAR 0 3
69610: ARRAY
69611: IN
69612: IFFALSE 69651
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
69614: LD_ADDR_EXP 43
69618: PUSH
69619: LD_EXP 43
69623: PPUSH
69624: LD_VAR 0 3
69628: PPUSH
69629: LD_EXP 43
69633: PUSH
69634: LD_VAR 0 3
69638: ARRAY
69639: PUSH
69640: LD_VAR 0 1
69644: DIFF
69645: PPUSH
69646: CALL_OW 1
69650: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
69651: LD_VAR 0 1
69655: PUSH
69656: LD_EXP 44
69660: PUSH
69661: LD_VAR 0 3
69665: ARRAY
69666: IN
69667: IFFALSE 69691
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
69669: LD_ADDR_EXP 44
69673: PUSH
69674: LD_EXP 44
69678: PPUSH
69679: LD_VAR 0 3
69683: PPUSH
69684: EMPTY
69685: PPUSH
69686: CALL_OW 1
69690: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
69691: LD_VAR 0 1
69695: PPUSH
69696: CALL_OW 247
69700: PUSH
69701: LD_INT 2
69703: EQUAL
69704: PUSH
69705: LD_VAR 0 1
69709: PPUSH
69710: CALL_OW 110
69714: PUSH
69715: LD_INT 20
69717: EQUAL
69718: PUSH
69719: LD_VAR 0 1
69723: PUSH
69724: LD_EXP 36
69728: PUSH
69729: LD_VAR 0 3
69733: ARRAY
69734: IN
69735: OR
69736: PUSH
69737: LD_VAR 0 1
69741: PPUSH
69742: CALL_OW 264
69746: PUSH
69747: LD_INT 12
69749: PUSH
69750: LD_INT 51
69752: PUSH
69753: LD_EXP 59
69757: PUSH
69758: LD_INT 32
69760: PUSH
69761: LD_INT 13
69763: PUSH
69764: LD_INT 52
69766: PUSH
69767: LD_INT 31
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: LIST
69774: LIST
69775: LIST
69776: LIST
69777: LIST
69778: IN
69779: OR
69780: AND
69781: IFFALSE 70089
// begin if un in mc_defender [ i ] then
69783: LD_VAR 0 1
69787: PUSH
69788: LD_EXP 36
69792: PUSH
69793: LD_VAR 0 3
69797: ARRAY
69798: IN
69799: IFFALSE 69838
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69801: LD_ADDR_EXP 36
69805: PUSH
69806: LD_EXP 36
69810: PPUSH
69811: LD_VAR 0 3
69815: PPUSH
69816: LD_EXP 36
69820: PUSH
69821: LD_VAR 0 3
69825: ARRAY
69826: PUSH
69827: LD_VAR 0 1
69831: DIFF
69832: PPUSH
69833: CALL_OW 1
69837: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
69838: LD_ADDR_VAR 0 8
69842: PUSH
69843: LD_VAR 0 3
69847: PPUSH
69848: LD_INT 3
69850: PPUSH
69851: CALL 66488 0 2
69855: ST_TO_ADDR
// if fac then
69856: LD_VAR 0 8
69860: IFFALSE 70089
// begin for j in fac do
69862: LD_ADDR_VAR 0 4
69866: PUSH
69867: LD_VAR 0 8
69871: PUSH
69872: FOR_IN
69873: IFFALSE 70087
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
69875: LD_ADDR_VAR 0 9
69879: PUSH
69880: LD_VAR 0 8
69884: PPUSH
69885: LD_VAR 0 1
69889: PPUSH
69890: CALL_OW 265
69894: PPUSH
69895: LD_VAR 0 1
69899: PPUSH
69900: CALL_OW 262
69904: PPUSH
69905: LD_VAR 0 1
69909: PPUSH
69910: CALL_OW 263
69914: PPUSH
69915: LD_VAR 0 1
69919: PPUSH
69920: CALL_OW 264
69924: PPUSH
69925: CALL 6959 0 5
69929: ST_TO_ADDR
// if components then
69930: LD_VAR 0 9
69934: IFFALSE 70085
// begin if GetWeapon ( un ) = ar_control_tower then
69936: LD_VAR 0 1
69940: PPUSH
69941: CALL_OW 264
69945: PUSH
69946: LD_INT 31
69948: EQUAL
69949: IFFALSE 70066
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
69951: LD_VAR 0 1
69955: PPUSH
69956: CALL_OW 311
69960: PPUSH
69961: LD_INT 0
69963: PPUSH
69964: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
69968: LD_ADDR_EXP 54
69972: PUSH
69973: LD_EXP 54
69977: PPUSH
69978: LD_VAR 0 3
69982: PPUSH
69983: LD_EXP 54
69987: PUSH
69988: LD_VAR 0 3
69992: ARRAY
69993: PUSH
69994: LD_VAR 0 1
69998: PPUSH
69999: CALL_OW 311
70003: DIFF
70004: PPUSH
70005: CALL_OW 1
70009: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
70010: LD_ADDR_VAR 0 7
70014: PUSH
70015: LD_EXP 35
70019: PUSH
70020: LD_VAR 0 3
70024: ARRAY
70025: PPUSH
70026: LD_INT 1
70028: PPUSH
70029: LD_VAR 0 9
70033: PPUSH
70034: CALL_OW 2
70038: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70039: LD_ADDR_EXP 35
70043: PUSH
70044: LD_EXP 35
70048: PPUSH
70049: LD_VAR 0 3
70053: PPUSH
70054: LD_VAR 0 7
70058: PPUSH
70059: CALL_OW 1
70063: ST_TO_ADDR
// end else
70064: GO 70083
// MC_InsertProduceList ( i , [ components ] ) ;
70066: LD_VAR 0 3
70070: PPUSH
70071: LD_VAR 0 9
70075: PUSH
70076: EMPTY
70077: LIST
70078: PPUSH
70079: CALL 66033 0 2
// break ;
70083: GO 70087
// end ; end ;
70085: GO 69872
70087: POP
70088: POP
// end ; end ; if GetType ( un ) = unit_building then
70089: LD_VAR 0 1
70093: PPUSH
70094: CALL_OW 247
70098: PUSH
70099: LD_INT 3
70101: EQUAL
70102: IFFALSE 70505
// begin btype := GetBType ( un ) ;
70104: LD_ADDR_VAR 0 5
70108: PUSH
70109: LD_VAR 0 1
70113: PPUSH
70114: CALL_OW 266
70118: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
70119: LD_VAR 0 5
70123: PUSH
70124: LD_INT 29
70126: PUSH
70127: LD_INT 30
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: IN
70134: IFFALSE 70207
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
70136: LD_VAR 0 1
70140: PPUSH
70141: CALL_OW 250
70145: PPUSH
70146: LD_VAR 0 1
70150: PPUSH
70151: CALL_OW 251
70155: PPUSH
70156: LD_VAR 0 1
70160: PPUSH
70161: CALL_OW 255
70165: PPUSH
70166: CALL_OW 440
70170: NOT
70171: IFFALSE 70207
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
70173: LD_VAR 0 1
70177: PPUSH
70178: CALL_OW 250
70182: PPUSH
70183: LD_VAR 0 1
70187: PPUSH
70188: CALL_OW 251
70192: PPUSH
70193: LD_VAR 0 1
70197: PPUSH
70198: CALL_OW 255
70202: PPUSH
70203: CALL_OW 441
// end ; if btype = b_warehouse then
70207: LD_VAR 0 5
70211: PUSH
70212: LD_INT 1
70214: EQUAL
70215: IFFALSE 70233
// begin btype := b_depot ;
70217: LD_ADDR_VAR 0 5
70221: PUSH
70222: LD_INT 0
70224: ST_TO_ADDR
// pos := 1 ;
70225: LD_ADDR_VAR 0 6
70229: PUSH
70230: LD_INT 1
70232: ST_TO_ADDR
// end ; if btype = b_factory then
70233: LD_VAR 0 5
70237: PUSH
70238: LD_INT 3
70240: EQUAL
70241: IFFALSE 70259
// begin btype := b_workshop ;
70243: LD_ADDR_VAR 0 5
70247: PUSH
70248: LD_INT 2
70250: ST_TO_ADDR
// pos := 1 ;
70251: LD_ADDR_VAR 0 6
70255: PUSH
70256: LD_INT 1
70258: ST_TO_ADDR
// end ; if btype = b_barracks then
70259: LD_VAR 0 5
70263: PUSH
70264: LD_INT 5
70266: EQUAL
70267: IFFALSE 70277
// btype := b_armoury ;
70269: LD_ADDR_VAR 0 5
70273: PUSH
70274: LD_INT 4
70276: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
70277: LD_VAR 0 5
70281: PUSH
70282: LD_INT 7
70284: PUSH
70285: LD_INT 8
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: IN
70292: IFFALSE 70302
// btype := b_lab ;
70294: LD_ADDR_VAR 0 5
70298: PUSH
70299: LD_INT 6
70301: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
70302: LD_ADDR_EXP 19
70306: PUSH
70307: LD_EXP 19
70311: PPUSH
70312: LD_VAR 0 3
70316: PUSH
70317: LD_EXP 19
70321: PUSH
70322: LD_VAR 0 3
70326: ARRAY
70327: PUSH
70328: LD_INT 1
70330: PLUS
70331: PUSH
70332: EMPTY
70333: LIST
70334: LIST
70335: PPUSH
70336: LD_VAR 0 5
70340: PUSH
70341: LD_VAR 0 1
70345: PPUSH
70346: CALL_OW 250
70350: PUSH
70351: LD_VAR 0 1
70355: PPUSH
70356: CALL_OW 251
70360: PUSH
70361: LD_VAR 0 1
70365: PPUSH
70366: CALL_OW 254
70370: PUSH
70371: EMPTY
70372: LIST
70373: LIST
70374: LIST
70375: LIST
70376: PPUSH
70377: CALL 9427 0 3
70381: ST_TO_ADDR
// if pos = 1 then
70382: LD_VAR 0 6
70386: PUSH
70387: LD_INT 1
70389: EQUAL
70390: IFFALSE 70505
// begin tmp := mc_build_list [ i ] ;
70392: LD_ADDR_VAR 0 7
70396: PUSH
70397: LD_EXP 19
70401: PUSH
70402: LD_VAR 0 3
70406: ARRAY
70407: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
70408: LD_VAR 0 7
70412: PPUSH
70413: LD_INT 2
70415: PUSH
70416: LD_INT 30
70418: PUSH
70419: LD_INT 0
70421: PUSH
70422: EMPTY
70423: LIST
70424: LIST
70425: PUSH
70426: LD_INT 30
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: LIST
70440: PPUSH
70441: CALL_OW 72
70445: IFFALSE 70455
// pos := 2 ;
70447: LD_ADDR_VAR 0 6
70451: PUSH
70452: LD_INT 2
70454: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
70455: LD_ADDR_VAR 0 7
70459: PUSH
70460: LD_VAR 0 7
70464: PPUSH
70465: LD_VAR 0 6
70469: PPUSH
70470: LD_VAR 0 7
70474: PPUSH
70475: CALL 9753 0 3
70479: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
70480: LD_ADDR_EXP 19
70484: PUSH
70485: LD_EXP 19
70489: PPUSH
70490: LD_VAR 0 3
70494: PPUSH
70495: LD_VAR 0 7
70499: PPUSH
70500: CALL_OW 1
70504: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
70505: LD_VAR 0 1
70509: PUSH
70510: LD_EXP 14
70514: PUSH
70515: LD_VAR 0 3
70519: ARRAY
70520: IN
70521: IFFALSE 70560
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
70523: LD_ADDR_EXP 14
70527: PUSH
70528: LD_EXP 14
70532: PPUSH
70533: LD_VAR 0 3
70537: PPUSH
70538: LD_EXP 14
70542: PUSH
70543: LD_VAR 0 3
70547: ARRAY
70548: PUSH
70549: LD_VAR 0 1
70553: DIFF
70554: PPUSH
70555: CALL_OW 1
70559: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
70560: LD_VAR 0 1
70564: PUSH
70565: LD_EXP 21
70569: PUSH
70570: LD_VAR 0 3
70574: ARRAY
70575: IN
70576: IFFALSE 70615
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
70578: LD_ADDR_EXP 21
70582: PUSH
70583: LD_EXP 21
70587: PPUSH
70588: LD_VAR 0 3
70592: PPUSH
70593: LD_EXP 21
70597: PUSH
70598: LD_VAR 0 3
70602: ARRAY
70603: PUSH
70604: LD_VAR 0 1
70608: DIFF
70609: PPUSH
70610: CALL_OW 1
70614: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
70615: LD_VAR 0 1
70619: PUSH
70620: LD_EXP 33
70624: PUSH
70625: LD_VAR 0 3
70629: ARRAY
70630: IN
70631: IFFALSE 70670
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
70633: LD_ADDR_EXP 33
70637: PUSH
70638: LD_EXP 33
70642: PPUSH
70643: LD_VAR 0 3
70647: PPUSH
70648: LD_EXP 33
70652: PUSH
70653: LD_VAR 0 3
70657: ARRAY
70658: PUSH
70659: LD_VAR 0 1
70663: DIFF
70664: PPUSH
70665: CALL_OW 1
70669: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
70670: LD_VAR 0 1
70674: PUSH
70675: LD_EXP 36
70679: PUSH
70680: LD_VAR 0 3
70684: ARRAY
70685: IN
70686: IFFALSE 70725
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
70688: LD_ADDR_EXP 36
70692: PUSH
70693: LD_EXP 36
70697: PPUSH
70698: LD_VAR 0 3
70702: PPUSH
70703: LD_EXP 36
70707: PUSH
70708: LD_VAR 0 3
70712: ARRAY
70713: PUSH
70714: LD_VAR 0 1
70718: DIFF
70719: PPUSH
70720: CALL_OW 1
70724: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
70725: LD_VAR 0 1
70729: PUSH
70730: LD_EXP 23
70734: PUSH
70735: LD_VAR 0 3
70739: ARRAY
70740: IN
70741: IFFALSE 70780
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
70743: LD_ADDR_EXP 23
70747: PUSH
70748: LD_EXP 23
70752: PPUSH
70753: LD_VAR 0 3
70757: PPUSH
70758: LD_EXP 23
70762: PUSH
70763: LD_VAR 0 3
70767: ARRAY
70768: PUSH
70769: LD_VAR 0 1
70773: DIFF
70774: PPUSH
70775: CALL_OW 1
70779: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
70780: LD_VAR 0 1
70784: PUSH
70785: LD_EXP 22
70789: PUSH
70790: LD_VAR 0 3
70794: ARRAY
70795: IN
70796: IFFALSE 70835
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
70798: LD_ADDR_EXP 22
70802: PUSH
70803: LD_EXP 22
70807: PPUSH
70808: LD_VAR 0 3
70812: PPUSH
70813: LD_EXP 22
70817: PUSH
70818: LD_VAR 0 3
70822: ARRAY
70823: PUSH
70824: LD_VAR 0 1
70828: DIFF
70829: PPUSH
70830: CALL_OW 1
70834: ST_TO_ADDR
// end ; break ;
70835: GO 70839
// end ;
70837: GO 69485
70839: POP
70840: POP
// end ;
70841: LD_VAR 0 2
70845: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
70846: LD_INT 0
70848: PPUSH
70849: PPUSH
70850: PPUSH
// if not mc_bases or not skirmish then
70851: LD_EXP 14
70855: NOT
70856: PUSH
70857: LD_EXP 12
70861: NOT
70862: OR
70863: IFFALSE 70867
// exit ;
70865: GO 71082
// for i = 1 to mc_bases do
70867: LD_ADDR_VAR 0 3
70871: PUSH
70872: DOUBLE
70873: LD_INT 1
70875: DEC
70876: ST_TO_ADDR
70877: LD_EXP 14
70881: PUSH
70882: FOR_TO
70883: IFFALSE 71080
// begin if building in mc_construct_list [ i ] then
70885: LD_VAR 0 1
70889: PUSH
70890: LD_EXP 21
70894: PUSH
70895: LD_VAR 0 3
70899: ARRAY
70900: IN
70901: IFFALSE 71078
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
70903: LD_ADDR_EXP 21
70907: PUSH
70908: LD_EXP 21
70912: PPUSH
70913: LD_VAR 0 3
70917: PPUSH
70918: LD_EXP 21
70922: PUSH
70923: LD_VAR 0 3
70927: ARRAY
70928: PUSH
70929: LD_VAR 0 1
70933: DIFF
70934: PPUSH
70935: CALL_OW 1
70939: ST_TO_ADDR
// if building in mc_lab [ i ] then
70940: LD_VAR 0 1
70944: PUSH
70945: LD_EXP 47
70949: PUSH
70950: LD_VAR 0 3
70954: ARRAY
70955: IN
70956: IFFALSE 71011
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
70958: LD_ADDR_EXP 48
70962: PUSH
70963: LD_EXP 48
70967: PPUSH
70968: LD_VAR 0 3
70972: PPUSH
70973: LD_EXP 48
70977: PUSH
70978: LD_VAR 0 3
70982: ARRAY
70983: PPUSH
70984: LD_INT 1
70986: PPUSH
70987: LD_EXP 48
70991: PUSH
70992: LD_VAR 0 3
70996: ARRAY
70997: PPUSH
70998: LD_INT 0
71000: PPUSH
71001: CALL 8845 0 4
71005: PPUSH
71006: CALL_OW 1
71010: ST_TO_ADDR
// if not building in mc_bases [ i ] then
71011: LD_VAR 0 1
71015: PUSH
71016: LD_EXP 14
71020: PUSH
71021: LD_VAR 0 3
71025: ARRAY
71026: IN
71027: NOT
71028: IFFALSE 71074
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
71030: LD_ADDR_EXP 14
71034: PUSH
71035: LD_EXP 14
71039: PPUSH
71040: LD_VAR 0 3
71044: PUSH
71045: LD_EXP 14
71049: PUSH
71050: LD_VAR 0 3
71054: ARRAY
71055: PUSH
71056: LD_INT 1
71058: PLUS
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: PPUSH
71064: LD_VAR 0 1
71068: PPUSH
71069: CALL 9427 0 3
71073: ST_TO_ADDR
// exit ;
71074: POP
71075: POP
71076: GO 71082
// end ; end ;
71078: GO 70882
71080: POP
71081: POP
// end ;
71082: LD_VAR 0 2
71086: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
71087: LD_INT 0
71089: PPUSH
71090: PPUSH
71091: PPUSH
71092: PPUSH
71093: PPUSH
71094: PPUSH
71095: PPUSH
// if not mc_bases or not skirmish then
71096: LD_EXP 14
71100: NOT
71101: PUSH
71102: LD_EXP 12
71106: NOT
71107: OR
71108: IFFALSE 71112
// exit ;
71110: GO 71773
// for i = 1 to mc_bases do
71112: LD_ADDR_VAR 0 3
71116: PUSH
71117: DOUBLE
71118: LD_INT 1
71120: DEC
71121: ST_TO_ADDR
71122: LD_EXP 14
71126: PUSH
71127: FOR_TO
71128: IFFALSE 71771
// begin if building in mc_construct_list [ i ] then
71130: LD_VAR 0 1
71134: PUSH
71135: LD_EXP 21
71139: PUSH
71140: LD_VAR 0 3
71144: ARRAY
71145: IN
71146: IFFALSE 71769
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
71148: LD_ADDR_EXP 21
71152: PUSH
71153: LD_EXP 21
71157: PPUSH
71158: LD_VAR 0 3
71162: PPUSH
71163: LD_EXP 21
71167: PUSH
71168: LD_VAR 0 3
71172: ARRAY
71173: PUSH
71174: LD_VAR 0 1
71178: DIFF
71179: PPUSH
71180: CALL_OW 1
71184: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
71185: LD_ADDR_EXP 14
71189: PUSH
71190: LD_EXP 14
71194: PPUSH
71195: LD_VAR 0 3
71199: PUSH
71200: LD_EXP 14
71204: PUSH
71205: LD_VAR 0 3
71209: ARRAY
71210: PUSH
71211: LD_INT 1
71213: PLUS
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PPUSH
71219: LD_VAR 0 1
71223: PPUSH
71224: CALL 9427 0 3
71228: ST_TO_ADDR
// btype := GetBType ( building ) ;
71229: LD_ADDR_VAR 0 5
71233: PUSH
71234: LD_VAR 0 1
71238: PPUSH
71239: CALL_OW 266
71243: ST_TO_ADDR
// side := GetSide ( building ) ;
71244: LD_ADDR_VAR 0 8
71248: PUSH
71249: LD_VAR 0 1
71253: PPUSH
71254: CALL_OW 255
71258: ST_TO_ADDR
// if btype = b_lab then
71259: LD_VAR 0 5
71263: PUSH
71264: LD_INT 6
71266: EQUAL
71267: IFFALSE 71317
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
71269: LD_ADDR_EXP 47
71273: PUSH
71274: LD_EXP 47
71278: PPUSH
71279: LD_VAR 0 3
71283: PUSH
71284: LD_EXP 47
71288: PUSH
71289: LD_VAR 0 3
71293: ARRAY
71294: PUSH
71295: LD_INT 1
71297: PLUS
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PPUSH
71303: LD_VAR 0 1
71307: PPUSH
71308: CALL 9427 0 3
71312: ST_TO_ADDR
// exit ;
71313: POP
71314: POP
71315: GO 71773
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
71317: LD_VAR 0 5
71321: PUSH
71322: LD_INT 0
71324: PUSH
71325: LD_INT 2
71327: PUSH
71328: LD_INT 4
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: LIST
71335: IN
71336: IFFALSE 71460
// begin if btype = b_armoury then
71338: LD_VAR 0 5
71342: PUSH
71343: LD_INT 4
71345: EQUAL
71346: IFFALSE 71356
// btype := b_barracks ;
71348: LD_ADDR_VAR 0 5
71352: PUSH
71353: LD_INT 5
71355: ST_TO_ADDR
// if btype = b_depot then
71356: LD_VAR 0 5
71360: PUSH
71361: LD_INT 0
71363: EQUAL
71364: IFFALSE 71374
// btype := b_warehouse ;
71366: LD_ADDR_VAR 0 5
71370: PUSH
71371: LD_INT 1
71373: ST_TO_ADDR
// if btype = b_workshop then
71374: LD_VAR 0 5
71378: PUSH
71379: LD_INT 2
71381: EQUAL
71382: IFFALSE 71392
// btype := b_factory ;
71384: LD_ADDR_VAR 0 5
71388: PUSH
71389: LD_INT 3
71391: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
71392: LD_VAR 0 5
71396: PPUSH
71397: LD_VAR 0 8
71401: PPUSH
71402: CALL_OW 323
71406: PUSH
71407: LD_INT 1
71409: EQUAL
71410: IFFALSE 71456
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
71412: LD_ADDR_EXP 46
71416: PUSH
71417: LD_EXP 46
71421: PPUSH
71422: LD_VAR 0 3
71426: PUSH
71427: LD_EXP 46
71431: PUSH
71432: LD_VAR 0 3
71436: ARRAY
71437: PUSH
71438: LD_INT 1
71440: PLUS
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PPUSH
71446: LD_VAR 0 1
71450: PPUSH
71451: CALL 9427 0 3
71455: ST_TO_ADDR
// exit ;
71456: POP
71457: POP
71458: GO 71773
// end ; if btype in [ b_bunker , b_turret ] then
71460: LD_VAR 0 5
71464: PUSH
71465: LD_INT 32
71467: PUSH
71468: LD_INT 33
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: IN
71475: IFFALSE 71765
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
71477: LD_ADDR_EXP 22
71481: PUSH
71482: LD_EXP 22
71486: PPUSH
71487: LD_VAR 0 3
71491: PUSH
71492: LD_EXP 22
71496: PUSH
71497: LD_VAR 0 3
71501: ARRAY
71502: PUSH
71503: LD_INT 1
71505: PLUS
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PPUSH
71511: LD_VAR 0 1
71515: PPUSH
71516: CALL 9427 0 3
71520: ST_TO_ADDR
// if btype = b_bunker then
71521: LD_VAR 0 5
71525: PUSH
71526: LD_INT 32
71528: EQUAL
71529: IFFALSE 71765
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
71531: LD_ADDR_EXP 23
71535: PUSH
71536: LD_EXP 23
71540: PPUSH
71541: LD_VAR 0 3
71545: PUSH
71546: LD_EXP 23
71550: PUSH
71551: LD_VAR 0 3
71555: ARRAY
71556: PUSH
71557: LD_INT 1
71559: PLUS
71560: PUSH
71561: EMPTY
71562: LIST
71563: LIST
71564: PPUSH
71565: LD_VAR 0 1
71569: PPUSH
71570: CALL 9427 0 3
71574: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
71575: LD_ADDR_VAR 0 6
71579: PUSH
71580: LD_EXP 14
71584: PUSH
71585: LD_VAR 0 3
71589: ARRAY
71590: PPUSH
71591: LD_INT 25
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 3
71603: PUSH
71604: LD_INT 54
71606: PUSH
71607: EMPTY
71608: LIST
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PPUSH
71618: CALL_OW 72
71622: ST_TO_ADDR
// if tmp then
71623: LD_VAR 0 6
71627: IFFALSE 71633
// exit ;
71629: POP
71630: POP
71631: GO 71773
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71633: LD_ADDR_VAR 0 6
71637: PUSH
71638: LD_EXP 14
71642: PUSH
71643: LD_VAR 0 3
71647: ARRAY
71648: PPUSH
71649: LD_INT 2
71651: PUSH
71652: LD_INT 30
71654: PUSH
71655: LD_INT 4
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 30
71664: PUSH
71665: LD_INT 5
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: LIST
71676: PPUSH
71677: CALL_OW 72
71681: ST_TO_ADDR
// if not tmp then
71682: LD_VAR 0 6
71686: NOT
71687: IFFALSE 71693
// exit ;
71689: POP
71690: POP
71691: GO 71773
// for j in tmp do
71693: LD_ADDR_VAR 0 4
71697: PUSH
71698: LD_VAR 0 6
71702: PUSH
71703: FOR_IN
71704: IFFALSE 71763
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
71706: LD_ADDR_VAR 0 7
71710: PUSH
71711: LD_VAR 0 4
71715: PPUSH
71716: CALL_OW 313
71720: PPUSH
71721: LD_INT 25
71723: PUSH
71724: LD_INT 1
71726: PUSH
71727: EMPTY
71728: LIST
71729: LIST
71730: PPUSH
71731: CALL_OW 72
71735: ST_TO_ADDR
// if units then
71736: LD_VAR 0 7
71740: IFFALSE 71761
// begin ComExitBuilding ( units [ 1 ] ) ;
71742: LD_VAR 0 7
71746: PUSH
71747: LD_INT 1
71749: ARRAY
71750: PPUSH
71751: CALL_OW 122
// exit ;
71755: POP
71756: POP
71757: POP
71758: POP
71759: GO 71773
// end ; end ;
71761: GO 71703
71763: POP
71764: POP
// end ; end ; exit ;
71765: POP
71766: POP
71767: GO 71773
// end ; end ;
71769: GO 71127
71771: POP
71772: POP
// end ;
71773: LD_VAR 0 2
71777: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
71778: LD_INT 0
71780: PPUSH
71781: PPUSH
71782: PPUSH
71783: PPUSH
71784: PPUSH
71785: PPUSH
71786: PPUSH
// if not mc_bases or not skirmish then
71787: LD_EXP 14
71791: NOT
71792: PUSH
71793: LD_EXP 12
71797: NOT
71798: OR
71799: IFFALSE 71803
// exit ;
71801: GO 72034
// btype := GetBType ( building ) ;
71803: LD_ADDR_VAR 0 6
71807: PUSH
71808: LD_VAR 0 1
71812: PPUSH
71813: CALL_OW 266
71817: ST_TO_ADDR
// x := GetX ( building ) ;
71818: LD_ADDR_VAR 0 7
71822: PUSH
71823: LD_VAR 0 1
71827: PPUSH
71828: CALL_OW 250
71832: ST_TO_ADDR
// y := GetY ( building ) ;
71833: LD_ADDR_VAR 0 8
71837: PUSH
71838: LD_VAR 0 1
71842: PPUSH
71843: CALL_OW 251
71847: ST_TO_ADDR
// d := GetDir ( building ) ;
71848: LD_ADDR_VAR 0 9
71852: PUSH
71853: LD_VAR 0 1
71857: PPUSH
71858: CALL_OW 254
71862: ST_TO_ADDR
// for i = 1 to mc_bases do
71863: LD_ADDR_VAR 0 4
71867: PUSH
71868: DOUBLE
71869: LD_INT 1
71871: DEC
71872: ST_TO_ADDR
71873: LD_EXP 14
71877: PUSH
71878: FOR_TO
71879: IFFALSE 72032
// begin if not mc_build_list [ i ] then
71881: LD_EXP 19
71885: PUSH
71886: LD_VAR 0 4
71890: ARRAY
71891: NOT
71892: IFFALSE 71896
// continue ;
71894: GO 71878
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
71896: LD_VAR 0 6
71900: PUSH
71901: LD_VAR 0 7
71905: PUSH
71906: LD_VAR 0 8
71910: PUSH
71911: LD_VAR 0 9
71915: PUSH
71916: EMPTY
71917: LIST
71918: LIST
71919: LIST
71920: LIST
71921: PPUSH
71922: LD_EXP 19
71926: PUSH
71927: LD_VAR 0 4
71931: ARRAY
71932: PUSH
71933: LD_INT 1
71935: ARRAY
71936: PPUSH
71937: CALL 15634 0 2
71941: IFFALSE 72030
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
71943: LD_ADDR_EXP 19
71947: PUSH
71948: LD_EXP 19
71952: PPUSH
71953: LD_VAR 0 4
71957: PPUSH
71958: LD_EXP 19
71962: PUSH
71963: LD_VAR 0 4
71967: ARRAY
71968: PPUSH
71969: LD_INT 1
71971: PPUSH
71972: CALL_OW 3
71976: PPUSH
71977: CALL_OW 1
71981: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
71982: LD_ADDR_EXP 21
71986: PUSH
71987: LD_EXP 21
71991: PPUSH
71992: LD_VAR 0 4
71996: PUSH
71997: LD_EXP 21
72001: PUSH
72002: LD_VAR 0 4
72006: ARRAY
72007: PUSH
72008: LD_INT 1
72010: PLUS
72011: PUSH
72012: EMPTY
72013: LIST
72014: LIST
72015: PPUSH
72016: LD_VAR 0 1
72020: PPUSH
72021: CALL 9427 0 3
72025: ST_TO_ADDR
// exit ;
72026: POP
72027: POP
72028: GO 72034
// end ; end ;
72030: GO 71878
72032: POP
72033: POP
// end ;
72034: LD_VAR 0 3
72038: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
72039: LD_INT 0
72041: PPUSH
72042: PPUSH
72043: PPUSH
// if not mc_bases or not skirmish then
72044: LD_EXP 14
72048: NOT
72049: PUSH
72050: LD_EXP 12
72054: NOT
72055: OR
72056: IFFALSE 72060
// exit ;
72058: GO 72250
// for i = 1 to mc_bases do
72060: LD_ADDR_VAR 0 4
72064: PUSH
72065: DOUBLE
72066: LD_INT 1
72068: DEC
72069: ST_TO_ADDR
72070: LD_EXP 14
72074: PUSH
72075: FOR_TO
72076: IFFALSE 72163
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
72078: LD_VAR 0 1
72082: PUSH
72083: LD_EXP 22
72087: PUSH
72088: LD_VAR 0 4
72092: ARRAY
72093: IN
72094: PUSH
72095: LD_VAR 0 1
72099: PUSH
72100: LD_EXP 23
72104: PUSH
72105: LD_VAR 0 4
72109: ARRAY
72110: IN
72111: NOT
72112: AND
72113: IFFALSE 72161
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
72115: LD_ADDR_EXP 23
72119: PUSH
72120: LD_EXP 23
72124: PPUSH
72125: LD_VAR 0 4
72129: PUSH
72130: LD_EXP 23
72134: PUSH
72135: LD_VAR 0 4
72139: ARRAY
72140: PUSH
72141: LD_INT 1
72143: PLUS
72144: PUSH
72145: EMPTY
72146: LIST
72147: LIST
72148: PPUSH
72149: LD_VAR 0 1
72153: PPUSH
72154: CALL 9427 0 3
72158: ST_TO_ADDR
// break ;
72159: GO 72163
// end ; end ;
72161: GO 72075
72163: POP
72164: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
72165: LD_VAR 0 1
72169: PPUSH
72170: CALL_OW 257
72174: PUSH
72175: LD_EXP 40
72179: IN
72180: PUSH
72181: LD_VAR 0 1
72185: PPUSH
72186: CALL_OW 266
72190: PUSH
72191: LD_INT 5
72193: EQUAL
72194: AND
72195: PUSH
72196: LD_VAR 0 2
72200: PPUSH
72201: CALL_OW 110
72205: PUSH
72206: LD_INT 18
72208: NONEQUAL
72209: AND
72210: IFFALSE 72250
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
72212: LD_VAR 0 2
72216: PPUSH
72217: CALL_OW 257
72221: PUSH
72222: LD_INT 5
72224: PUSH
72225: LD_INT 8
72227: PUSH
72228: LD_INT 9
72230: PUSH
72231: EMPTY
72232: LIST
72233: LIST
72234: LIST
72235: IN
72236: IFFALSE 72250
// SetClass ( unit , 1 ) ;
72238: LD_VAR 0 2
72242: PPUSH
72243: LD_INT 1
72245: PPUSH
72246: CALL_OW 336
// end ;
72250: LD_VAR 0 3
72254: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
72255: LD_INT 0
72257: PPUSH
72258: PPUSH
// if not mc_bases or not skirmish then
72259: LD_EXP 14
72263: NOT
72264: PUSH
72265: LD_EXP 12
72269: NOT
72270: OR
72271: IFFALSE 72275
// exit ;
72273: GO 72391
// if GetLives ( abandoned_vehicle ) > 250 then
72275: LD_VAR 0 2
72279: PPUSH
72280: CALL_OW 256
72284: PUSH
72285: LD_INT 250
72287: GREATER
72288: IFFALSE 72292
// exit ;
72290: GO 72391
// for i = 1 to mc_bases do
72292: LD_ADDR_VAR 0 6
72296: PUSH
72297: DOUBLE
72298: LD_INT 1
72300: DEC
72301: ST_TO_ADDR
72302: LD_EXP 14
72306: PUSH
72307: FOR_TO
72308: IFFALSE 72389
// begin if driver in mc_bases [ i ] then
72310: LD_VAR 0 1
72314: PUSH
72315: LD_EXP 14
72319: PUSH
72320: LD_VAR 0 6
72324: ARRAY
72325: IN
72326: IFFALSE 72387
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
72328: LD_VAR 0 1
72332: PPUSH
72333: LD_EXP 14
72337: PUSH
72338: LD_VAR 0 6
72342: ARRAY
72343: PPUSH
72344: LD_INT 2
72346: PUSH
72347: LD_INT 30
72349: PUSH
72350: LD_INT 0
72352: PUSH
72353: EMPTY
72354: LIST
72355: LIST
72356: PUSH
72357: LD_INT 30
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: EMPTY
72364: LIST
72365: LIST
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: LIST
72371: PPUSH
72372: CALL_OW 72
72376: PUSH
72377: LD_INT 1
72379: ARRAY
72380: PPUSH
72381: CALL 41670 0 2
// break ;
72385: GO 72389
// end ; end ;
72387: GO 72307
72389: POP
72390: POP
// end ; end_of_file
72391: LD_VAR 0 5
72395: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
72396: LD_INT 0
72398: PPUSH
// ar_miner := 81 ;
72399: LD_ADDR_EXP 65
72403: PUSH
72404: LD_INT 81
72406: ST_TO_ADDR
// ar_crane := 88 ;
72407: LD_ADDR_EXP 64
72411: PUSH
72412: LD_INT 88
72414: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
72415: LD_ADDR_EXP 59
72419: PUSH
72420: LD_INT 89
72422: ST_TO_ADDR
// us_hack := 99 ;
72423: LD_ADDR_EXP 60
72427: PUSH
72428: LD_INT 99
72430: ST_TO_ADDR
// us_artillery := 97 ;
72431: LD_ADDR_EXP 61
72435: PUSH
72436: LD_INT 97
72438: ST_TO_ADDR
// ar_bio_bomb := 91 ;
72439: LD_ADDR_EXP 62
72443: PUSH
72444: LD_INT 91
72446: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
72447: LD_ADDR_EXP 63
72451: PUSH
72452: LD_INT 92
72454: ST_TO_ADDR
// ru_radar := 98 ;
72455: LD_ADDR_EXP 58
72459: PUSH
72460: LD_INT 98
72462: ST_TO_ADDR
// tech_Artillery := 80 ;
72463: LD_ADDR_EXP 66
72467: PUSH
72468: LD_INT 80
72470: ST_TO_ADDR
// tech_RadMat := 81 ;
72471: LD_ADDR_EXP 67
72475: PUSH
72476: LD_INT 81
72478: ST_TO_ADDR
// tech_BasicTools := 82 ;
72479: LD_ADDR_EXP 68
72483: PUSH
72484: LD_INT 82
72486: ST_TO_ADDR
// tech_Cargo := 83 ;
72487: LD_ADDR_EXP 69
72491: PUSH
72492: LD_INT 83
72494: ST_TO_ADDR
// tech_Track := 84 ;
72495: LD_ADDR_EXP 70
72499: PUSH
72500: LD_INT 84
72502: ST_TO_ADDR
// tech_Crane := 85 ;
72503: LD_ADDR_EXP 71
72507: PUSH
72508: LD_INT 85
72510: ST_TO_ADDR
// tech_Bulldozer := 86 ;
72511: LD_ADDR_EXP 72
72515: PUSH
72516: LD_INT 86
72518: ST_TO_ADDR
// tech_Hovercraft := 87 ;
72519: LD_ADDR_EXP 73
72523: PUSH
72524: LD_INT 87
72526: ST_TO_ADDR
// class_mastodont := 31 ;
72527: LD_ADDR_EXP 74
72531: PUSH
72532: LD_INT 31
72534: ST_TO_ADDR
// class_horse := 21 ;
72535: LD_ADDR_EXP 75
72539: PUSH
72540: LD_INT 21
72542: ST_TO_ADDR
// end ;
72543: LD_VAR 0 1
72547: RET
// every 1 do
72548: GO 72550
72550: DISABLE
// InitGlobalVariables ; end_of_file
72551: CALL 72396 0 0
72555: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
72556: LD_INT 0
72558: PPUSH
72559: PPUSH
72560: PPUSH
72561: PPUSH
72562: PPUSH
72563: PPUSH
72564: PPUSH
72565: PPUSH
72566: PPUSH
72567: PPUSH
72568: PPUSH
72569: PPUSH
72570: PPUSH
72571: PPUSH
72572: PPUSH
72573: PPUSH
72574: PPUSH
72575: PPUSH
72576: PPUSH
72577: PPUSH
72578: PPUSH
72579: PPUSH
72580: PPUSH
72581: PPUSH
72582: PPUSH
72583: PPUSH
72584: PPUSH
72585: PPUSH
72586: PPUSH
72587: PPUSH
72588: PPUSH
72589: PPUSH
72590: PPUSH
72591: PPUSH
// if not list then
72592: LD_VAR 0 1
72596: NOT
72597: IFFALSE 72601
// exit ;
72599: GO 77260
// base := list [ 1 ] ;
72601: LD_ADDR_VAR 0 3
72605: PUSH
72606: LD_VAR 0 1
72610: PUSH
72611: LD_INT 1
72613: ARRAY
72614: ST_TO_ADDR
// group := list [ 2 ] ;
72615: LD_ADDR_VAR 0 4
72619: PUSH
72620: LD_VAR 0 1
72624: PUSH
72625: LD_INT 2
72627: ARRAY
72628: ST_TO_ADDR
// path := list [ 3 ] ;
72629: LD_ADDR_VAR 0 5
72633: PUSH
72634: LD_VAR 0 1
72638: PUSH
72639: LD_INT 3
72641: ARRAY
72642: ST_TO_ADDR
// flags := list [ 4 ] ;
72643: LD_ADDR_VAR 0 6
72647: PUSH
72648: LD_VAR 0 1
72652: PUSH
72653: LD_INT 4
72655: ARRAY
72656: ST_TO_ADDR
// mined := [ ] ;
72657: LD_ADDR_VAR 0 27
72661: PUSH
72662: EMPTY
72663: ST_TO_ADDR
// bombed := [ ] ;
72664: LD_ADDR_VAR 0 28
72668: PUSH
72669: EMPTY
72670: ST_TO_ADDR
// healers := [ ] ;
72671: LD_ADDR_VAR 0 31
72675: PUSH
72676: EMPTY
72677: ST_TO_ADDR
// to_heal := [ ] ;
72678: LD_ADDR_VAR 0 30
72682: PUSH
72683: EMPTY
72684: ST_TO_ADDR
// repairs := [ ] ;
72685: LD_ADDR_VAR 0 33
72689: PUSH
72690: EMPTY
72691: ST_TO_ADDR
// to_repair := [ ] ;
72692: LD_ADDR_VAR 0 32
72696: PUSH
72697: EMPTY
72698: ST_TO_ADDR
// if not group or not path then
72699: LD_VAR 0 4
72703: NOT
72704: PUSH
72705: LD_VAR 0 5
72709: NOT
72710: OR
72711: IFFALSE 72715
// exit ;
72713: GO 77260
// side := GetSide ( group [ 1 ] ) ;
72715: LD_ADDR_VAR 0 35
72719: PUSH
72720: LD_VAR 0 4
72724: PUSH
72725: LD_INT 1
72727: ARRAY
72728: PPUSH
72729: CALL_OW 255
72733: ST_TO_ADDR
// if flags then
72734: LD_VAR 0 6
72738: IFFALSE 72882
// begin f_ignore_area := flags [ 1 ] ;
72740: LD_ADDR_VAR 0 17
72744: PUSH
72745: LD_VAR 0 6
72749: PUSH
72750: LD_INT 1
72752: ARRAY
72753: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
72754: LD_ADDR_VAR 0 18
72758: PUSH
72759: LD_VAR 0 6
72763: PUSH
72764: LD_INT 2
72766: ARRAY
72767: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
72768: LD_ADDR_VAR 0 19
72772: PUSH
72773: LD_VAR 0 6
72777: PUSH
72778: LD_INT 3
72780: ARRAY
72781: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
72782: LD_ADDR_VAR 0 20
72786: PUSH
72787: LD_VAR 0 6
72791: PUSH
72792: LD_INT 4
72794: ARRAY
72795: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
72796: LD_ADDR_VAR 0 21
72800: PUSH
72801: LD_VAR 0 6
72805: PUSH
72806: LD_INT 5
72808: ARRAY
72809: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
72810: LD_ADDR_VAR 0 22
72814: PUSH
72815: LD_VAR 0 6
72819: PUSH
72820: LD_INT 6
72822: ARRAY
72823: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
72824: LD_ADDR_VAR 0 23
72828: PUSH
72829: LD_VAR 0 6
72833: PUSH
72834: LD_INT 7
72836: ARRAY
72837: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
72838: LD_ADDR_VAR 0 24
72842: PUSH
72843: LD_VAR 0 6
72847: PUSH
72848: LD_INT 8
72850: ARRAY
72851: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
72852: LD_ADDR_VAR 0 25
72856: PUSH
72857: LD_VAR 0 6
72861: PUSH
72862: LD_INT 9
72864: ARRAY
72865: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
72866: LD_ADDR_VAR 0 26
72870: PUSH
72871: LD_VAR 0 6
72875: PUSH
72876: LD_INT 10
72878: ARRAY
72879: ST_TO_ADDR
// end else
72880: GO 72962
// begin f_ignore_area := false ;
72882: LD_ADDR_VAR 0 17
72886: PUSH
72887: LD_INT 0
72889: ST_TO_ADDR
// f_capture := false ;
72890: LD_ADDR_VAR 0 18
72894: PUSH
72895: LD_INT 0
72897: ST_TO_ADDR
// f_ignore_civ := false ;
72898: LD_ADDR_VAR 0 19
72902: PUSH
72903: LD_INT 0
72905: ST_TO_ADDR
// f_murder := false ;
72906: LD_ADDR_VAR 0 20
72910: PUSH
72911: LD_INT 0
72913: ST_TO_ADDR
// f_mines := false ;
72914: LD_ADDR_VAR 0 21
72918: PUSH
72919: LD_INT 0
72921: ST_TO_ADDR
// f_repair := false ;
72922: LD_ADDR_VAR 0 22
72926: PUSH
72927: LD_INT 0
72929: ST_TO_ADDR
// f_heal := false ;
72930: LD_ADDR_VAR 0 23
72934: PUSH
72935: LD_INT 0
72937: ST_TO_ADDR
// f_spacetime := false ;
72938: LD_ADDR_VAR 0 24
72942: PUSH
72943: LD_INT 0
72945: ST_TO_ADDR
// f_attack_depot := false ;
72946: LD_ADDR_VAR 0 25
72950: PUSH
72951: LD_INT 0
72953: ST_TO_ADDR
// f_crawl := false ;
72954: LD_ADDR_VAR 0 26
72958: PUSH
72959: LD_INT 0
72961: ST_TO_ADDR
// end ; if f_heal then
72962: LD_VAR 0 23
72966: IFFALSE 72993
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
72968: LD_ADDR_VAR 0 31
72972: PUSH
72973: LD_VAR 0 4
72977: PPUSH
72978: LD_INT 25
72980: PUSH
72981: LD_INT 4
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: PPUSH
72988: CALL_OW 72
72992: ST_TO_ADDR
// if f_repair then
72993: LD_VAR 0 22
72997: IFFALSE 73024
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
72999: LD_ADDR_VAR 0 33
73003: PUSH
73004: LD_VAR 0 4
73008: PPUSH
73009: LD_INT 25
73011: PUSH
73012: LD_INT 3
73014: PUSH
73015: EMPTY
73016: LIST
73017: LIST
73018: PPUSH
73019: CALL_OW 72
73023: ST_TO_ADDR
// units_path := [ ] ;
73024: LD_ADDR_VAR 0 16
73028: PUSH
73029: EMPTY
73030: ST_TO_ADDR
// for i = 1 to group do
73031: LD_ADDR_VAR 0 7
73035: PUSH
73036: DOUBLE
73037: LD_INT 1
73039: DEC
73040: ST_TO_ADDR
73041: LD_VAR 0 4
73045: PUSH
73046: FOR_TO
73047: IFFALSE 73076
// units_path := Replace ( units_path , i , path ) ;
73049: LD_ADDR_VAR 0 16
73053: PUSH
73054: LD_VAR 0 16
73058: PPUSH
73059: LD_VAR 0 7
73063: PPUSH
73064: LD_VAR 0 5
73068: PPUSH
73069: CALL_OW 1
73073: ST_TO_ADDR
73074: GO 73046
73076: POP
73077: POP
// repeat for i = group downto 1 do
73078: LD_ADDR_VAR 0 7
73082: PUSH
73083: DOUBLE
73084: LD_VAR 0 4
73088: INC
73089: ST_TO_ADDR
73090: LD_INT 1
73092: PUSH
73093: FOR_DOWNTO
73094: IFFALSE 77216
// begin wait ( 5 ) ;
73096: LD_INT 5
73098: PPUSH
73099: CALL_OW 67
// tmp := [ ] ;
73103: LD_ADDR_VAR 0 14
73107: PUSH
73108: EMPTY
73109: ST_TO_ADDR
// attacking := false ;
73110: LD_ADDR_VAR 0 29
73114: PUSH
73115: LD_INT 0
73117: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
73118: LD_VAR 0 4
73122: PUSH
73123: LD_VAR 0 7
73127: ARRAY
73128: PPUSH
73129: CALL_OW 301
73133: PUSH
73134: LD_VAR 0 4
73138: PUSH
73139: LD_VAR 0 7
73143: ARRAY
73144: NOT
73145: OR
73146: IFFALSE 73255
// begin if GetType ( group [ i ] ) = unit_human then
73148: LD_VAR 0 4
73152: PUSH
73153: LD_VAR 0 7
73157: ARRAY
73158: PPUSH
73159: CALL_OW 247
73163: PUSH
73164: LD_INT 1
73166: EQUAL
73167: IFFALSE 73213
// begin to_heal := to_heal diff group [ i ] ;
73169: LD_ADDR_VAR 0 30
73173: PUSH
73174: LD_VAR 0 30
73178: PUSH
73179: LD_VAR 0 4
73183: PUSH
73184: LD_VAR 0 7
73188: ARRAY
73189: DIFF
73190: ST_TO_ADDR
// healers := healers diff group [ i ] ;
73191: LD_ADDR_VAR 0 31
73195: PUSH
73196: LD_VAR 0 31
73200: PUSH
73201: LD_VAR 0 4
73205: PUSH
73206: LD_VAR 0 7
73210: ARRAY
73211: DIFF
73212: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
73213: LD_ADDR_VAR 0 4
73217: PUSH
73218: LD_VAR 0 4
73222: PPUSH
73223: LD_VAR 0 7
73227: PPUSH
73228: CALL_OW 3
73232: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
73233: LD_ADDR_VAR 0 16
73237: PUSH
73238: LD_VAR 0 16
73242: PPUSH
73243: LD_VAR 0 7
73247: PPUSH
73248: CALL_OW 3
73252: ST_TO_ADDR
// continue ;
73253: GO 73093
// end ; if f_repair then
73255: LD_VAR 0 22
73259: IFFALSE 73748
// begin if GetType ( group [ i ] ) = unit_vehicle then
73261: LD_VAR 0 4
73265: PUSH
73266: LD_VAR 0 7
73270: ARRAY
73271: PPUSH
73272: CALL_OW 247
73276: PUSH
73277: LD_INT 2
73279: EQUAL
73280: IFFALSE 73470
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
73282: LD_VAR 0 4
73286: PUSH
73287: LD_VAR 0 7
73291: ARRAY
73292: PPUSH
73293: CALL_OW 256
73297: PUSH
73298: LD_INT 700
73300: LESS
73301: PUSH
73302: LD_VAR 0 4
73306: PUSH
73307: LD_VAR 0 7
73311: ARRAY
73312: PUSH
73313: LD_VAR 0 32
73317: IN
73318: NOT
73319: AND
73320: IFFALSE 73344
// to_repair := to_repair union group [ i ] ;
73322: LD_ADDR_VAR 0 32
73326: PUSH
73327: LD_VAR 0 32
73331: PUSH
73332: LD_VAR 0 4
73336: PUSH
73337: LD_VAR 0 7
73341: ARRAY
73342: UNION
73343: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
73344: LD_VAR 0 4
73348: PUSH
73349: LD_VAR 0 7
73353: ARRAY
73354: PPUSH
73355: CALL_OW 256
73359: PUSH
73360: LD_INT 1000
73362: EQUAL
73363: PUSH
73364: LD_VAR 0 4
73368: PUSH
73369: LD_VAR 0 7
73373: ARRAY
73374: PUSH
73375: LD_VAR 0 32
73379: IN
73380: AND
73381: IFFALSE 73405
// to_repair := to_repair diff group [ i ] ;
73383: LD_ADDR_VAR 0 32
73387: PUSH
73388: LD_VAR 0 32
73392: PUSH
73393: LD_VAR 0 4
73397: PUSH
73398: LD_VAR 0 7
73402: ARRAY
73403: DIFF
73404: ST_TO_ADDR
// if group [ i ] in to_repair then
73405: LD_VAR 0 4
73409: PUSH
73410: LD_VAR 0 7
73414: ARRAY
73415: PUSH
73416: LD_VAR 0 32
73420: IN
73421: IFFALSE 73468
// begin if not IsInArea ( group [ i ] , f_repair ) then
73423: LD_VAR 0 4
73427: PUSH
73428: LD_VAR 0 7
73432: ARRAY
73433: PPUSH
73434: LD_VAR 0 22
73438: PPUSH
73439: CALL_OW 308
73443: NOT
73444: IFFALSE 73466
// ComMoveToArea ( group [ i ] , f_repair ) ;
73446: LD_VAR 0 4
73450: PUSH
73451: LD_VAR 0 7
73455: ARRAY
73456: PPUSH
73457: LD_VAR 0 22
73461: PPUSH
73462: CALL_OW 113
// continue ;
73466: GO 73093
// end ; end else
73468: GO 73748
// if group [ i ] in repairs then
73470: LD_VAR 0 4
73474: PUSH
73475: LD_VAR 0 7
73479: ARRAY
73480: PUSH
73481: LD_VAR 0 33
73485: IN
73486: IFFALSE 73748
// begin if IsInUnit ( group [ i ] ) then
73488: LD_VAR 0 4
73492: PUSH
73493: LD_VAR 0 7
73497: ARRAY
73498: PPUSH
73499: CALL_OW 310
73503: IFFALSE 73571
// begin z := IsInUnit ( group [ i ] ) ;
73505: LD_ADDR_VAR 0 13
73509: PUSH
73510: LD_VAR 0 4
73514: PUSH
73515: LD_VAR 0 7
73519: ARRAY
73520: PPUSH
73521: CALL_OW 310
73525: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
73526: LD_VAR 0 13
73530: PUSH
73531: LD_VAR 0 32
73535: IN
73536: PUSH
73537: LD_VAR 0 13
73541: PPUSH
73542: LD_VAR 0 22
73546: PPUSH
73547: CALL_OW 308
73551: AND
73552: IFFALSE 73569
// ComExitVehicle ( group [ i ] ) ;
73554: LD_VAR 0 4
73558: PUSH
73559: LD_VAR 0 7
73563: ARRAY
73564: PPUSH
73565: CALL_OW 121
// end else
73569: GO 73748
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
73571: LD_ADDR_VAR 0 13
73575: PUSH
73576: LD_VAR 0 4
73580: PPUSH
73581: LD_INT 95
73583: PUSH
73584: LD_VAR 0 22
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 58
73595: PUSH
73596: EMPTY
73597: LIST
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PPUSH
73603: CALL_OW 72
73607: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
73608: LD_VAR 0 4
73612: PUSH
73613: LD_VAR 0 7
73617: ARRAY
73618: PPUSH
73619: CALL_OW 314
73623: NOT
73624: IFFALSE 73746
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
73626: LD_ADDR_VAR 0 10
73630: PUSH
73631: LD_VAR 0 13
73635: PPUSH
73636: LD_VAR 0 4
73640: PUSH
73641: LD_VAR 0 7
73645: ARRAY
73646: PPUSH
73647: CALL_OW 74
73651: ST_TO_ADDR
// if not x then
73652: LD_VAR 0 10
73656: NOT
73657: IFFALSE 73661
// continue ;
73659: GO 73093
// if GetLives ( x ) < 1000 then
73661: LD_VAR 0 10
73665: PPUSH
73666: CALL_OW 256
73670: PUSH
73671: LD_INT 1000
73673: LESS
73674: IFFALSE 73698
// ComRepairVehicle ( group [ i ] , x ) else
73676: LD_VAR 0 4
73680: PUSH
73681: LD_VAR 0 7
73685: ARRAY
73686: PPUSH
73687: LD_VAR 0 10
73691: PPUSH
73692: CALL_OW 129
73696: GO 73746
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
73698: LD_VAR 0 23
73702: PUSH
73703: LD_VAR 0 4
73707: PUSH
73708: LD_VAR 0 7
73712: ARRAY
73713: PPUSH
73714: CALL_OW 256
73718: PUSH
73719: LD_INT 1000
73721: LESS
73722: AND
73723: NOT
73724: IFFALSE 73746
// ComEnterUnit ( group [ i ] , x ) ;
73726: LD_VAR 0 4
73730: PUSH
73731: LD_VAR 0 7
73735: ARRAY
73736: PPUSH
73737: LD_VAR 0 10
73741: PPUSH
73742: CALL_OW 120
// end ; continue ;
73746: GO 73093
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
73748: LD_VAR 0 23
73752: PUSH
73753: LD_VAR 0 4
73757: PUSH
73758: LD_VAR 0 7
73762: ARRAY
73763: PPUSH
73764: CALL_OW 247
73768: PUSH
73769: LD_INT 1
73771: EQUAL
73772: AND
73773: IFFALSE 74251
// begin if group [ i ] in healers then
73775: LD_VAR 0 4
73779: PUSH
73780: LD_VAR 0 7
73784: ARRAY
73785: PUSH
73786: LD_VAR 0 31
73790: IN
73791: IFFALSE 74064
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
73793: LD_VAR 0 4
73797: PUSH
73798: LD_VAR 0 7
73802: ARRAY
73803: PPUSH
73804: LD_VAR 0 23
73808: PPUSH
73809: CALL_OW 308
73813: NOT
73814: PUSH
73815: LD_VAR 0 4
73819: PUSH
73820: LD_VAR 0 7
73824: ARRAY
73825: PPUSH
73826: CALL_OW 314
73830: NOT
73831: AND
73832: IFFALSE 73856
// ComMoveToArea ( group [ i ] , f_heal ) else
73834: LD_VAR 0 4
73838: PUSH
73839: LD_VAR 0 7
73843: ARRAY
73844: PPUSH
73845: LD_VAR 0 23
73849: PPUSH
73850: CALL_OW 113
73854: GO 74062
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
73856: LD_VAR 0 4
73860: PUSH
73861: LD_VAR 0 7
73865: ARRAY
73866: PPUSH
73867: CALL 38132 0 1
73871: PPUSH
73872: CALL_OW 256
73876: PUSH
73877: LD_INT 1000
73879: EQUAL
73880: IFFALSE 73899
// ComStop ( group [ i ] ) else
73882: LD_VAR 0 4
73886: PUSH
73887: LD_VAR 0 7
73891: ARRAY
73892: PPUSH
73893: CALL_OW 141
73897: GO 74062
// if not HasTask ( group [ i ] ) and to_heal then
73899: LD_VAR 0 4
73903: PUSH
73904: LD_VAR 0 7
73908: ARRAY
73909: PPUSH
73910: CALL_OW 314
73914: NOT
73915: PUSH
73916: LD_VAR 0 30
73920: AND
73921: IFFALSE 74062
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
73923: LD_ADDR_VAR 0 13
73927: PUSH
73928: LD_VAR 0 30
73932: PPUSH
73933: LD_INT 3
73935: PUSH
73936: LD_INT 54
73938: PUSH
73939: EMPTY
73940: LIST
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PPUSH
73946: CALL_OW 72
73950: PPUSH
73951: LD_VAR 0 4
73955: PUSH
73956: LD_VAR 0 7
73960: ARRAY
73961: PPUSH
73962: CALL_OW 74
73966: ST_TO_ADDR
// if z then
73967: LD_VAR 0 13
73971: IFFALSE 74062
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
73973: LD_INT 91
73975: PUSH
73976: LD_VAR 0 13
73980: PUSH
73981: LD_INT 10
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: LIST
73988: PUSH
73989: LD_INT 81
73991: PUSH
73992: LD_VAR 0 13
73996: PPUSH
73997: CALL_OW 255
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PPUSH
74010: CALL_OW 69
74014: PUSH
74015: LD_INT 0
74017: EQUAL
74018: IFFALSE 74042
// ComHeal ( group [ i ] , z ) else
74020: LD_VAR 0 4
74024: PUSH
74025: LD_VAR 0 7
74029: ARRAY
74030: PPUSH
74031: LD_VAR 0 13
74035: PPUSH
74036: CALL_OW 128
74040: GO 74062
// ComMoveToArea ( group [ i ] , f_heal ) ;
74042: LD_VAR 0 4
74046: PUSH
74047: LD_VAR 0 7
74051: ARRAY
74052: PPUSH
74053: LD_VAR 0 23
74057: PPUSH
74058: CALL_OW 113
// end ; continue ;
74062: GO 73093
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
74064: LD_VAR 0 4
74068: PUSH
74069: LD_VAR 0 7
74073: ARRAY
74074: PPUSH
74075: CALL_OW 256
74079: PUSH
74080: LD_INT 700
74082: LESS
74083: PUSH
74084: LD_VAR 0 4
74088: PUSH
74089: LD_VAR 0 7
74093: ARRAY
74094: PUSH
74095: LD_VAR 0 30
74099: IN
74100: NOT
74101: AND
74102: IFFALSE 74126
// to_heal := to_heal union group [ i ] ;
74104: LD_ADDR_VAR 0 30
74108: PUSH
74109: LD_VAR 0 30
74113: PUSH
74114: LD_VAR 0 4
74118: PUSH
74119: LD_VAR 0 7
74123: ARRAY
74124: UNION
74125: ST_TO_ADDR
// if group [ i ] in to_heal then
74126: LD_VAR 0 4
74130: PUSH
74131: LD_VAR 0 7
74135: ARRAY
74136: PUSH
74137: LD_VAR 0 30
74141: IN
74142: IFFALSE 74251
// begin if GetLives ( group [ i ] ) = 1000 then
74144: LD_VAR 0 4
74148: PUSH
74149: LD_VAR 0 7
74153: ARRAY
74154: PPUSH
74155: CALL_OW 256
74159: PUSH
74160: LD_INT 1000
74162: EQUAL
74163: IFFALSE 74189
// to_heal := to_heal diff group [ i ] else
74165: LD_ADDR_VAR 0 30
74169: PUSH
74170: LD_VAR 0 30
74174: PUSH
74175: LD_VAR 0 4
74179: PUSH
74180: LD_VAR 0 7
74184: ARRAY
74185: DIFF
74186: ST_TO_ADDR
74187: GO 74251
// begin if not IsInArea ( group [ i ] , to_heal ) then
74189: LD_VAR 0 4
74193: PUSH
74194: LD_VAR 0 7
74198: ARRAY
74199: PPUSH
74200: LD_VAR 0 30
74204: PPUSH
74205: CALL_OW 308
74209: NOT
74210: IFFALSE 74234
// ComMoveToArea ( group [ i ] , f_heal ) else
74212: LD_VAR 0 4
74216: PUSH
74217: LD_VAR 0 7
74221: ARRAY
74222: PPUSH
74223: LD_VAR 0 23
74227: PPUSH
74228: CALL_OW 113
74232: GO 74249
// ComHold ( group [ i ] ) ;
74234: LD_VAR 0 4
74238: PUSH
74239: LD_VAR 0 7
74243: ARRAY
74244: PPUSH
74245: CALL_OW 140
// continue ;
74249: GO 73093
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
74251: LD_VAR 0 4
74255: PUSH
74256: LD_VAR 0 7
74260: ARRAY
74261: PPUSH
74262: LD_INT 10
74264: PPUSH
74265: CALL 36552 0 2
74269: NOT
74270: PUSH
74271: LD_VAR 0 16
74275: PUSH
74276: LD_VAR 0 7
74280: ARRAY
74281: PUSH
74282: EMPTY
74283: EQUAL
74284: NOT
74285: AND
74286: IFFALSE 74552
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
74288: LD_VAR 0 4
74292: PUSH
74293: LD_VAR 0 7
74297: ARRAY
74298: PPUSH
74299: CALL_OW 262
74303: PUSH
74304: LD_INT 1
74306: PUSH
74307: LD_INT 2
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: IN
74314: IFFALSE 74355
// if GetFuel ( group [ i ] ) < 10 then
74316: LD_VAR 0 4
74320: PUSH
74321: LD_VAR 0 7
74325: ARRAY
74326: PPUSH
74327: CALL_OW 261
74331: PUSH
74332: LD_INT 10
74334: LESS
74335: IFFALSE 74355
// SetFuel ( group [ i ] , 12 ) ;
74337: LD_VAR 0 4
74341: PUSH
74342: LD_VAR 0 7
74346: ARRAY
74347: PPUSH
74348: LD_INT 12
74350: PPUSH
74351: CALL_OW 240
// if units_path [ i ] then
74355: LD_VAR 0 16
74359: PUSH
74360: LD_VAR 0 7
74364: ARRAY
74365: IFFALSE 74550
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
74367: LD_VAR 0 4
74371: PUSH
74372: LD_VAR 0 7
74376: ARRAY
74377: PPUSH
74378: LD_VAR 0 16
74382: PUSH
74383: LD_VAR 0 7
74387: ARRAY
74388: PUSH
74389: LD_INT 1
74391: ARRAY
74392: PUSH
74393: LD_INT 1
74395: ARRAY
74396: PPUSH
74397: LD_VAR 0 16
74401: PUSH
74402: LD_VAR 0 7
74406: ARRAY
74407: PUSH
74408: LD_INT 1
74410: ARRAY
74411: PUSH
74412: LD_INT 2
74414: ARRAY
74415: PPUSH
74416: CALL_OW 297
74420: PUSH
74421: LD_INT 6
74423: GREATER
74424: IFFALSE 74499
// begin if not HasTask ( group [ i ] ) then
74426: LD_VAR 0 4
74430: PUSH
74431: LD_VAR 0 7
74435: ARRAY
74436: PPUSH
74437: CALL_OW 314
74441: NOT
74442: IFFALSE 74497
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
74444: LD_VAR 0 4
74448: PUSH
74449: LD_VAR 0 7
74453: ARRAY
74454: PPUSH
74455: LD_VAR 0 16
74459: PUSH
74460: LD_VAR 0 7
74464: ARRAY
74465: PUSH
74466: LD_INT 1
74468: ARRAY
74469: PUSH
74470: LD_INT 1
74472: ARRAY
74473: PPUSH
74474: LD_VAR 0 16
74478: PUSH
74479: LD_VAR 0 7
74483: ARRAY
74484: PUSH
74485: LD_INT 1
74487: ARRAY
74488: PUSH
74489: LD_INT 2
74491: ARRAY
74492: PPUSH
74493: CALL_OW 114
// end else
74497: GO 74550
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
74499: LD_ADDR_VAR 0 15
74503: PUSH
74504: LD_VAR 0 16
74508: PUSH
74509: LD_VAR 0 7
74513: ARRAY
74514: PPUSH
74515: LD_INT 1
74517: PPUSH
74518: CALL_OW 3
74522: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
74523: LD_ADDR_VAR 0 16
74527: PUSH
74528: LD_VAR 0 16
74532: PPUSH
74533: LD_VAR 0 7
74537: PPUSH
74538: LD_VAR 0 15
74542: PPUSH
74543: CALL_OW 1
74547: ST_TO_ADDR
// continue ;
74548: GO 73093
// end ; end ; end else
74550: GO 77214
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
74552: LD_ADDR_VAR 0 14
74556: PUSH
74557: LD_INT 81
74559: PUSH
74560: LD_VAR 0 4
74564: PUSH
74565: LD_VAR 0 7
74569: ARRAY
74570: PPUSH
74571: CALL_OW 255
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PPUSH
74580: CALL_OW 69
74584: ST_TO_ADDR
// if not tmp then
74585: LD_VAR 0 14
74589: NOT
74590: IFFALSE 74594
// continue ;
74592: GO 73093
// if f_ignore_area then
74594: LD_VAR 0 17
74598: IFFALSE 74686
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
74600: LD_ADDR_VAR 0 15
74604: PUSH
74605: LD_VAR 0 14
74609: PPUSH
74610: LD_INT 3
74612: PUSH
74613: LD_INT 92
74615: PUSH
74616: LD_VAR 0 17
74620: PUSH
74621: LD_INT 1
74623: ARRAY
74624: PUSH
74625: LD_VAR 0 17
74629: PUSH
74630: LD_INT 2
74632: ARRAY
74633: PUSH
74634: LD_VAR 0 17
74638: PUSH
74639: LD_INT 3
74641: ARRAY
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: LIST
74647: LIST
74648: PUSH
74649: EMPTY
74650: LIST
74651: LIST
74652: PPUSH
74653: CALL_OW 72
74657: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
74658: LD_VAR 0 14
74662: PUSH
74663: LD_VAR 0 15
74667: DIFF
74668: IFFALSE 74686
// tmp := tmp diff tmp2 ;
74670: LD_ADDR_VAR 0 14
74674: PUSH
74675: LD_VAR 0 14
74679: PUSH
74680: LD_VAR 0 15
74684: DIFF
74685: ST_TO_ADDR
// end ; if not f_murder then
74686: LD_VAR 0 20
74690: NOT
74691: IFFALSE 74749
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
74693: LD_ADDR_VAR 0 15
74697: PUSH
74698: LD_VAR 0 14
74702: PPUSH
74703: LD_INT 3
74705: PUSH
74706: LD_INT 50
74708: PUSH
74709: EMPTY
74710: LIST
74711: PUSH
74712: EMPTY
74713: LIST
74714: LIST
74715: PPUSH
74716: CALL_OW 72
74720: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
74721: LD_VAR 0 14
74725: PUSH
74726: LD_VAR 0 15
74730: DIFF
74731: IFFALSE 74749
// tmp := tmp diff tmp2 ;
74733: LD_ADDR_VAR 0 14
74737: PUSH
74738: LD_VAR 0 14
74742: PUSH
74743: LD_VAR 0 15
74747: DIFF
74748: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
74749: LD_ADDR_VAR 0 14
74753: PUSH
74754: LD_VAR 0 4
74758: PUSH
74759: LD_VAR 0 7
74763: ARRAY
74764: PPUSH
74765: LD_VAR 0 14
74769: PPUSH
74770: LD_INT 1
74772: PPUSH
74773: LD_INT 1
74775: PPUSH
74776: CALL 9862 0 4
74780: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
74781: LD_VAR 0 4
74785: PUSH
74786: LD_VAR 0 7
74790: ARRAY
74791: PPUSH
74792: CALL_OW 257
74796: PUSH
74797: LD_INT 1
74799: EQUAL
74800: IFFALSE 75248
// begin if WantPlant ( group [ i ] ) then
74802: LD_VAR 0 4
74806: PUSH
74807: LD_VAR 0 7
74811: ARRAY
74812: PPUSH
74813: CALL 9363 0 1
74817: IFFALSE 74821
// continue ;
74819: GO 73093
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
74821: LD_VAR 0 18
74825: PUSH
74826: LD_VAR 0 4
74830: PUSH
74831: LD_VAR 0 7
74835: ARRAY
74836: PPUSH
74837: CALL_OW 310
74841: NOT
74842: AND
74843: PUSH
74844: LD_VAR 0 14
74848: PUSH
74849: LD_INT 1
74851: ARRAY
74852: PUSH
74853: LD_VAR 0 14
74857: PPUSH
74858: LD_INT 21
74860: PUSH
74861: LD_INT 2
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PUSH
74868: LD_INT 58
74870: PUSH
74871: EMPTY
74872: LIST
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PPUSH
74878: CALL_OW 72
74882: IN
74883: AND
74884: IFFALSE 74920
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
74886: LD_VAR 0 4
74890: PUSH
74891: LD_VAR 0 7
74895: ARRAY
74896: PPUSH
74897: LD_VAR 0 14
74901: PUSH
74902: LD_INT 1
74904: ARRAY
74905: PPUSH
74906: CALL_OW 120
// attacking := true ;
74910: LD_ADDR_VAR 0 29
74914: PUSH
74915: LD_INT 1
74917: ST_TO_ADDR
// continue ;
74918: GO 73093
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
74920: LD_VAR 0 26
74924: PUSH
74925: LD_VAR 0 4
74929: PUSH
74930: LD_VAR 0 7
74934: ARRAY
74935: PPUSH
74936: CALL_OW 257
74940: PUSH
74941: LD_INT 1
74943: EQUAL
74944: AND
74945: PUSH
74946: LD_VAR 0 4
74950: PUSH
74951: LD_VAR 0 7
74955: ARRAY
74956: PPUSH
74957: CALL_OW 256
74961: PUSH
74962: LD_INT 800
74964: LESS
74965: AND
74966: PUSH
74967: LD_VAR 0 4
74971: PUSH
74972: LD_VAR 0 7
74976: ARRAY
74977: PPUSH
74978: CALL_OW 318
74982: NOT
74983: AND
74984: IFFALSE 75001
// ComCrawl ( group [ i ] ) ;
74986: LD_VAR 0 4
74990: PUSH
74991: LD_VAR 0 7
74995: ARRAY
74996: PPUSH
74997: CALL_OW 137
// if f_mines then
75001: LD_VAR 0 21
75005: IFFALSE 75248
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
75007: LD_VAR 0 14
75011: PUSH
75012: LD_INT 1
75014: ARRAY
75015: PPUSH
75016: CALL_OW 247
75020: PUSH
75021: LD_INT 3
75023: EQUAL
75024: PUSH
75025: LD_VAR 0 14
75029: PUSH
75030: LD_INT 1
75032: ARRAY
75033: PUSH
75034: LD_VAR 0 27
75038: IN
75039: NOT
75040: AND
75041: IFFALSE 75248
// begin x := GetX ( tmp [ 1 ] ) ;
75043: LD_ADDR_VAR 0 10
75047: PUSH
75048: LD_VAR 0 14
75052: PUSH
75053: LD_INT 1
75055: ARRAY
75056: PPUSH
75057: CALL_OW 250
75061: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
75062: LD_ADDR_VAR 0 11
75066: PUSH
75067: LD_VAR 0 14
75071: PUSH
75072: LD_INT 1
75074: ARRAY
75075: PPUSH
75076: CALL_OW 251
75080: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
75081: LD_ADDR_VAR 0 12
75085: PUSH
75086: LD_VAR 0 4
75090: PUSH
75091: LD_VAR 0 7
75095: ARRAY
75096: PPUSH
75097: CALL 36637 0 1
75101: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
75102: LD_VAR 0 4
75106: PUSH
75107: LD_VAR 0 7
75111: ARRAY
75112: PPUSH
75113: LD_VAR 0 10
75117: PPUSH
75118: LD_VAR 0 11
75122: PPUSH
75123: LD_VAR 0 14
75127: PUSH
75128: LD_INT 1
75130: ARRAY
75131: PPUSH
75132: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
75136: LD_VAR 0 4
75140: PUSH
75141: LD_VAR 0 7
75145: ARRAY
75146: PPUSH
75147: LD_VAR 0 10
75151: PPUSH
75152: LD_VAR 0 12
75156: PPUSH
75157: LD_INT 7
75159: PPUSH
75160: CALL_OW 272
75164: PPUSH
75165: LD_VAR 0 11
75169: PPUSH
75170: LD_VAR 0 12
75174: PPUSH
75175: LD_INT 7
75177: PPUSH
75178: CALL_OW 273
75182: PPUSH
75183: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
75187: LD_VAR 0 4
75191: PUSH
75192: LD_VAR 0 7
75196: ARRAY
75197: PPUSH
75198: LD_INT 71
75200: PPUSH
75201: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
75205: LD_ADDR_VAR 0 27
75209: PUSH
75210: LD_VAR 0 27
75214: PPUSH
75215: LD_VAR 0 27
75219: PUSH
75220: LD_INT 1
75222: PLUS
75223: PPUSH
75224: LD_VAR 0 14
75228: PUSH
75229: LD_INT 1
75231: ARRAY
75232: PPUSH
75233: CALL_OW 1
75237: ST_TO_ADDR
// attacking := true ;
75238: LD_ADDR_VAR 0 29
75242: PUSH
75243: LD_INT 1
75245: ST_TO_ADDR
// continue ;
75246: GO 73093
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
75248: LD_VAR 0 4
75252: PUSH
75253: LD_VAR 0 7
75257: ARRAY
75258: PPUSH
75259: CALL_OW 257
75263: PUSH
75264: LD_INT 17
75266: EQUAL
75267: PUSH
75268: LD_VAR 0 4
75272: PUSH
75273: LD_VAR 0 7
75277: ARRAY
75278: PPUSH
75279: CALL_OW 110
75283: PUSH
75284: LD_INT 71
75286: EQUAL
75287: NOT
75288: AND
75289: IFFALSE 75435
// begin attacking := false ;
75291: LD_ADDR_VAR 0 29
75295: PUSH
75296: LD_INT 0
75298: ST_TO_ADDR
// k := 5 ;
75299: LD_ADDR_VAR 0 9
75303: PUSH
75304: LD_INT 5
75306: ST_TO_ADDR
// if tmp < k then
75307: LD_VAR 0 14
75311: PUSH
75312: LD_VAR 0 9
75316: LESS
75317: IFFALSE 75329
// k := tmp ;
75319: LD_ADDR_VAR 0 9
75323: PUSH
75324: LD_VAR 0 14
75328: ST_TO_ADDR
// for j = 1 to k do
75329: LD_ADDR_VAR 0 8
75333: PUSH
75334: DOUBLE
75335: LD_INT 1
75337: DEC
75338: ST_TO_ADDR
75339: LD_VAR 0 9
75343: PUSH
75344: FOR_TO
75345: IFFALSE 75433
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
75347: LD_VAR 0 14
75351: PUSH
75352: LD_VAR 0 8
75356: ARRAY
75357: PUSH
75358: LD_VAR 0 14
75362: PPUSH
75363: LD_INT 58
75365: PUSH
75366: EMPTY
75367: LIST
75368: PPUSH
75369: CALL_OW 72
75373: IN
75374: NOT
75375: IFFALSE 75431
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
75377: LD_VAR 0 4
75381: PUSH
75382: LD_VAR 0 7
75386: ARRAY
75387: PPUSH
75388: LD_VAR 0 14
75392: PUSH
75393: LD_VAR 0 8
75397: ARRAY
75398: PPUSH
75399: CALL_OW 115
// attacking := true ;
75403: LD_ADDR_VAR 0 29
75407: PUSH
75408: LD_INT 1
75410: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
75411: LD_VAR 0 4
75415: PUSH
75416: LD_VAR 0 7
75420: ARRAY
75421: PPUSH
75422: LD_INT 71
75424: PPUSH
75425: CALL_OW 109
// continue ;
75429: GO 75344
// end ; end ;
75431: GO 75344
75433: POP
75434: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
75435: LD_VAR 0 4
75439: PUSH
75440: LD_VAR 0 7
75444: ARRAY
75445: PPUSH
75446: CALL_OW 257
75450: PUSH
75451: LD_INT 8
75453: EQUAL
75454: PUSH
75455: LD_VAR 0 4
75459: PUSH
75460: LD_VAR 0 7
75464: ARRAY
75465: PPUSH
75466: CALL_OW 264
75470: PUSH
75471: LD_INT 28
75473: PUSH
75474: LD_INT 45
75476: PUSH
75477: LD_INT 7
75479: PUSH
75480: LD_INT 47
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: LIST
75487: LIST
75488: IN
75489: OR
75490: IFFALSE 75746
// begin attacking := false ;
75492: LD_ADDR_VAR 0 29
75496: PUSH
75497: LD_INT 0
75499: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
75500: LD_VAR 0 14
75504: PUSH
75505: LD_INT 1
75507: ARRAY
75508: PPUSH
75509: CALL_OW 266
75513: PUSH
75514: LD_INT 32
75516: PUSH
75517: LD_INT 31
75519: PUSH
75520: LD_INT 33
75522: PUSH
75523: LD_INT 4
75525: PUSH
75526: LD_INT 5
75528: PUSH
75529: EMPTY
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: IN
75536: IFFALSE 75722
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
75538: LD_ADDR_VAR 0 9
75542: PUSH
75543: LD_VAR 0 14
75547: PUSH
75548: LD_INT 1
75550: ARRAY
75551: PPUSH
75552: CALL_OW 266
75556: PPUSH
75557: LD_VAR 0 14
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: PPUSH
75566: CALL_OW 250
75570: PPUSH
75571: LD_VAR 0 14
75575: PUSH
75576: LD_INT 1
75578: ARRAY
75579: PPUSH
75580: CALL_OW 251
75584: PPUSH
75585: LD_VAR 0 14
75589: PUSH
75590: LD_INT 1
75592: ARRAY
75593: PPUSH
75594: CALL_OW 254
75598: PPUSH
75599: LD_VAR 0 14
75603: PUSH
75604: LD_INT 1
75606: ARRAY
75607: PPUSH
75608: CALL_OW 248
75612: PPUSH
75613: LD_INT 0
75615: PPUSH
75616: CALL 18007 0 6
75620: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
75621: LD_ADDR_VAR 0 8
75625: PUSH
75626: LD_VAR 0 4
75630: PUSH
75631: LD_VAR 0 7
75635: ARRAY
75636: PPUSH
75637: LD_VAR 0 9
75641: PPUSH
75642: CALL 36677 0 2
75646: ST_TO_ADDR
// if j then
75647: LD_VAR 0 8
75651: IFFALSE 75720
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75653: LD_VAR 0 8
75657: PUSH
75658: LD_INT 1
75660: ARRAY
75661: PPUSH
75662: LD_VAR 0 8
75666: PUSH
75667: LD_INT 2
75669: ARRAY
75670: PPUSH
75671: CALL_OW 488
75675: IFFALSE 75720
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
75677: LD_VAR 0 4
75681: PUSH
75682: LD_VAR 0 7
75686: ARRAY
75687: PPUSH
75688: LD_VAR 0 8
75692: PUSH
75693: LD_INT 1
75695: ARRAY
75696: PPUSH
75697: LD_VAR 0 8
75701: PUSH
75702: LD_INT 2
75704: ARRAY
75705: PPUSH
75706: CALL_OW 116
// attacking := true ;
75710: LD_ADDR_VAR 0 29
75714: PUSH
75715: LD_INT 1
75717: ST_TO_ADDR
// continue ;
75718: GO 73093
// end ; end else
75720: GO 75746
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
75722: LD_VAR 0 4
75726: PUSH
75727: LD_VAR 0 7
75731: ARRAY
75732: PPUSH
75733: LD_VAR 0 14
75737: PUSH
75738: LD_INT 1
75740: ARRAY
75741: PPUSH
75742: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
75746: LD_VAR 0 4
75750: PUSH
75751: LD_VAR 0 7
75755: ARRAY
75756: PPUSH
75757: CALL_OW 265
75761: PUSH
75762: LD_INT 11
75764: EQUAL
75765: IFFALSE 76043
// begin k := 10 ;
75767: LD_ADDR_VAR 0 9
75771: PUSH
75772: LD_INT 10
75774: ST_TO_ADDR
// x := 0 ;
75775: LD_ADDR_VAR 0 10
75779: PUSH
75780: LD_INT 0
75782: ST_TO_ADDR
// if tmp < k then
75783: LD_VAR 0 14
75787: PUSH
75788: LD_VAR 0 9
75792: LESS
75793: IFFALSE 75805
// k := tmp ;
75795: LD_ADDR_VAR 0 9
75799: PUSH
75800: LD_VAR 0 14
75804: ST_TO_ADDR
// for j = k downto 1 do
75805: LD_ADDR_VAR 0 8
75809: PUSH
75810: DOUBLE
75811: LD_VAR 0 9
75815: INC
75816: ST_TO_ADDR
75817: LD_INT 1
75819: PUSH
75820: FOR_DOWNTO
75821: IFFALSE 75896
// begin if GetType ( tmp [ j ] ) = unit_human then
75823: LD_VAR 0 14
75827: PUSH
75828: LD_VAR 0 8
75832: ARRAY
75833: PPUSH
75834: CALL_OW 247
75838: PUSH
75839: LD_INT 1
75841: EQUAL
75842: IFFALSE 75894
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
75844: LD_VAR 0 4
75848: PUSH
75849: LD_VAR 0 7
75853: ARRAY
75854: PPUSH
75855: LD_VAR 0 14
75859: PUSH
75860: LD_VAR 0 8
75864: ARRAY
75865: PPUSH
75866: CALL 36948 0 2
// x := tmp [ j ] ;
75870: LD_ADDR_VAR 0 10
75874: PUSH
75875: LD_VAR 0 14
75879: PUSH
75880: LD_VAR 0 8
75884: ARRAY
75885: ST_TO_ADDR
// attacking := true ;
75886: LD_ADDR_VAR 0 29
75890: PUSH
75891: LD_INT 1
75893: ST_TO_ADDR
// end ; end ;
75894: GO 75820
75896: POP
75897: POP
// if not x then
75898: LD_VAR 0 10
75902: NOT
75903: IFFALSE 76043
// begin attacking := true ;
75905: LD_ADDR_VAR 0 29
75909: PUSH
75910: LD_INT 1
75912: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
75913: LD_VAR 0 4
75917: PUSH
75918: LD_VAR 0 7
75922: ARRAY
75923: PPUSH
75924: CALL_OW 250
75928: PPUSH
75929: LD_VAR 0 4
75933: PUSH
75934: LD_VAR 0 7
75938: ARRAY
75939: PPUSH
75940: CALL_OW 251
75944: PPUSH
75945: CALL_OW 546
75949: PUSH
75950: LD_INT 2
75952: ARRAY
75953: PUSH
75954: LD_VAR 0 14
75958: PUSH
75959: LD_INT 1
75961: ARRAY
75962: PPUSH
75963: CALL_OW 250
75967: PPUSH
75968: LD_VAR 0 14
75972: PUSH
75973: LD_INT 1
75975: ARRAY
75976: PPUSH
75977: CALL_OW 251
75981: PPUSH
75982: CALL_OW 546
75986: PUSH
75987: LD_INT 2
75989: ARRAY
75990: EQUAL
75991: IFFALSE 76019
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
75993: LD_VAR 0 4
75997: PUSH
75998: LD_VAR 0 7
76002: ARRAY
76003: PPUSH
76004: LD_VAR 0 14
76008: PUSH
76009: LD_INT 1
76011: ARRAY
76012: PPUSH
76013: CALL 36948 0 2
76017: GO 76043
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76019: LD_VAR 0 4
76023: PUSH
76024: LD_VAR 0 7
76028: ARRAY
76029: PPUSH
76030: LD_VAR 0 14
76034: PUSH
76035: LD_INT 1
76037: ARRAY
76038: PPUSH
76039: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
76043: LD_VAR 0 4
76047: PUSH
76048: LD_VAR 0 7
76052: ARRAY
76053: PPUSH
76054: CALL_OW 264
76058: PUSH
76059: LD_INT 29
76061: EQUAL
76062: IFFALSE 76428
// begin if WantsToAttack ( group [ i ] ) in bombed then
76064: LD_VAR 0 4
76068: PUSH
76069: LD_VAR 0 7
76073: ARRAY
76074: PPUSH
76075: CALL_OW 319
76079: PUSH
76080: LD_VAR 0 28
76084: IN
76085: IFFALSE 76089
// continue ;
76087: GO 73093
// k := 8 ;
76089: LD_ADDR_VAR 0 9
76093: PUSH
76094: LD_INT 8
76096: ST_TO_ADDR
// x := 0 ;
76097: LD_ADDR_VAR 0 10
76101: PUSH
76102: LD_INT 0
76104: ST_TO_ADDR
// if tmp < k then
76105: LD_VAR 0 14
76109: PUSH
76110: LD_VAR 0 9
76114: LESS
76115: IFFALSE 76127
// k := tmp ;
76117: LD_ADDR_VAR 0 9
76121: PUSH
76122: LD_VAR 0 14
76126: ST_TO_ADDR
// for j = 1 to k do
76127: LD_ADDR_VAR 0 8
76131: PUSH
76132: DOUBLE
76133: LD_INT 1
76135: DEC
76136: ST_TO_ADDR
76137: LD_VAR 0 9
76141: PUSH
76142: FOR_TO
76143: IFFALSE 76275
// begin if GetType ( tmp [ j ] ) = unit_building then
76145: LD_VAR 0 14
76149: PUSH
76150: LD_VAR 0 8
76154: ARRAY
76155: PPUSH
76156: CALL_OW 247
76160: PUSH
76161: LD_INT 3
76163: EQUAL
76164: IFFALSE 76273
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
76166: LD_VAR 0 14
76170: PUSH
76171: LD_VAR 0 8
76175: ARRAY
76176: PUSH
76177: LD_VAR 0 28
76181: IN
76182: NOT
76183: PUSH
76184: LD_VAR 0 14
76188: PUSH
76189: LD_VAR 0 8
76193: ARRAY
76194: PPUSH
76195: CALL_OW 313
76199: AND
76200: IFFALSE 76273
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76202: LD_VAR 0 4
76206: PUSH
76207: LD_VAR 0 7
76211: ARRAY
76212: PPUSH
76213: LD_VAR 0 14
76217: PUSH
76218: LD_VAR 0 8
76222: ARRAY
76223: PPUSH
76224: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
76228: LD_ADDR_VAR 0 28
76232: PUSH
76233: LD_VAR 0 28
76237: PPUSH
76238: LD_VAR 0 28
76242: PUSH
76243: LD_INT 1
76245: PLUS
76246: PPUSH
76247: LD_VAR 0 14
76251: PUSH
76252: LD_VAR 0 8
76256: ARRAY
76257: PPUSH
76258: CALL_OW 1
76262: ST_TO_ADDR
// attacking := true ;
76263: LD_ADDR_VAR 0 29
76267: PUSH
76268: LD_INT 1
76270: ST_TO_ADDR
// break ;
76271: GO 76275
// end ; end ;
76273: GO 76142
76275: POP
76276: POP
// if not attacking and f_attack_depot then
76277: LD_VAR 0 29
76281: NOT
76282: PUSH
76283: LD_VAR 0 25
76287: AND
76288: IFFALSE 76383
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76290: LD_ADDR_VAR 0 13
76294: PUSH
76295: LD_VAR 0 14
76299: PPUSH
76300: LD_INT 2
76302: PUSH
76303: LD_INT 30
76305: PUSH
76306: LD_INT 0
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 30
76315: PUSH
76316: LD_INT 1
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: LIST
76327: PPUSH
76328: CALL_OW 72
76332: ST_TO_ADDR
// if z then
76333: LD_VAR 0 13
76337: IFFALSE 76383
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
76339: LD_VAR 0 4
76343: PUSH
76344: LD_VAR 0 7
76348: ARRAY
76349: PPUSH
76350: LD_VAR 0 13
76354: PPUSH
76355: LD_VAR 0 4
76359: PUSH
76360: LD_VAR 0 7
76364: ARRAY
76365: PPUSH
76366: CALL_OW 74
76370: PPUSH
76371: CALL_OW 115
// attacking := true ;
76375: LD_ADDR_VAR 0 29
76379: PUSH
76380: LD_INT 1
76382: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
76383: LD_VAR 0 4
76387: PUSH
76388: LD_VAR 0 7
76392: ARRAY
76393: PPUSH
76394: CALL_OW 256
76398: PUSH
76399: LD_INT 500
76401: LESS
76402: IFFALSE 76428
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
76404: LD_VAR 0 4
76408: PUSH
76409: LD_VAR 0 7
76413: ARRAY
76414: PPUSH
76415: LD_VAR 0 14
76419: PUSH
76420: LD_INT 1
76422: ARRAY
76423: PPUSH
76424: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
76428: LD_VAR 0 4
76432: PUSH
76433: LD_VAR 0 7
76437: ARRAY
76438: PPUSH
76439: CALL_OW 264
76443: PUSH
76444: LD_INT 49
76446: EQUAL
76447: IFFALSE 76568
// begin if not HasTask ( group [ i ] ) then
76449: LD_VAR 0 4
76453: PUSH
76454: LD_VAR 0 7
76458: ARRAY
76459: PPUSH
76460: CALL_OW 314
76464: NOT
76465: IFFALSE 76568
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
76467: LD_ADDR_VAR 0 9
76471: PUSH
76472: LD_INT 81
76474: PUSH
76475: LD_VAR 0 4
76479: PUSH
76480: LD_VAR 0 7
76484: ARRAY
76485: PPUSH
76486: CALL_OW 255
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PPUSH
76495: CALL_OW 69
76499: PPUSH
76500: LD_VAR 0 4
76504: PUSH
76505: LD_VAR 0 7
76509: ARRAY
76510: PPUSH
76511: CALL_OW 74
76515: ST_TO_ADDR
// if k then
76516: LD_VAR 0 9
76520: IFFALSE 76568
// if GetDistUnits ( group [ i ] , k ) > 10 then
76522: LD_VAR 0 4
76526: PUSH
76527: LD_VAR 0 7
76531: ARRAY
76532: PPUSH
76533: LD_VAR 0 9
76537: PPUSH
76538: CALL_OW 296
76542: PUSH
76543: LD_INT 10
76545: GREATER
76546: IFFALSE 76568
// ComMoveUnit ( group [ i ] , k ) ;
76548: LD_VAR 0 4
76552: PUSH
76553: LD_VAR 0 7
76557: ARRAY
76558: PPUSH
76559: LD_VAR 0 9
76563: PPUSH
76564: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
76568: LD_VAR 0 4
76572: PUSH
76573: LD_VAR 0 7
76577: ARRAY
76578: PPUSH
76579: CALL_OW 256
76583: PUSH
76584: LD_INT 250
76586: LESS
76587: PUSH
76588: LD_VAR 0 4
76592: PUSH
76593: LD_VAR 0 7
76597: ARRAY
76598: PUSH
76599: LD_INT 21
76601: PUSH
76602: LD_INT 2
76604: PUSH
76605: EMPTY
76606: LIST
76607: LIST
76608: PUSH
76609: LD_INT 23
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: EMPTY
76620: LIST
76621: LIST
76622: PPUSH
76623: CALL_OW 69
76627: IN
76628: AND
76629: IFFALSE 76754
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
76631: LD_ADDR_VAR 0 9
76635: PUSH
76636: LD_OWVAR 3
76640: PUSH
76641: LD_VAR 0 4
76645: PUSH
76646: LD_VAR 0 7
76650: ARRAY
76651: DIFF
76652: PPUSH
76653: LD_VAR 0 4
76657: PUSH
76658: LD_VAR 0 7
76662: ARRAY
76663: PPUSH
76664: CALL_OW 74
76668: ST_TO_ADDR
// if not k then
76669: LD_VAR 0 9
76673: NOT
76674: IFFALSE 76678
// continue ;
76676: GO 73093
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
76678: LD_VAR 0 9
76682: PUSH
76683: LD_INT 81
76685: PUSH
76686: LD_VAR 0 4
76690: PUSH
76691: LD_VAR 0 7
76695: ARRAY
76696: PPUSH
76697: CALL_OW 255
76701: PUSH
76702: EMPTY
76703: LIST
76704: LIST
76705: PPUSH
76706: CALL_OW 69
76710: IN
76711: PUSH
76712: LD_VAR 0 9
76716: PPUSH
76717: LD_VAR 0 4
76721: PUSH
76722: LD_VAR 0 7
76726: ARRAY
76727: PPUSH
76728: CALL_OW 296
76732: PUSH
76733: LD_INT 5
76735: LESS
76736: AND
76737: IFFALSE 76754
// ComAutodestruct ( group [ i ] ) ;
76739: LD_VAR 0 4
76743: PUSH
76744: LD_VAR 0 7
76748: ARRAY
76749: PPUSH
76750: CALL 36846 0 1
// end ; if f_attack_depot then
76754: LD_VAR 0 25
76758: IFFALSE 76870
// begin k := 6 ;
76760: LD_ADDR_VAR 0 9
76764: PUSH
76765: LD_INT 6
76767: ST_TO_ADDR
// if tmp < k then
76768: LD_VAR 0 14
76772: PUSH
76773: LD_VAR 0 9
76777: LESS
76778: IFFALSE 76790
// k := tmp ;
76780: LD_ADDR_VAR 0 9
76784: PUSH
76785: LD_VAR 0 14
76789: ST_TO_ADDR
// for j = 1 to k do
76790: LD_ADDR_VAR 0 8
76794: PUSH
76795: DOUBLE
76796: LD_INT 1
76798: DEC
76799: ST_TO_ADDR
76800: LD_VAR 0 9
76804: PUSH
76805: FOR_TO
76806: IFFALSE 76868
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
76808: LD_VAR 0 8
76812: PPUSH
76813: CALL_OW 266
76817: PUSH
76818: LD_INT 0
76820: PUSH
76821: LD_INT 1
76823: PUSH
76824: EMPTY
76825: LIST
76826: LIST
76827: IN
76828: IFFALSE 76866
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
76830: LD_VAR 0 4
76834: PUSH
76835: LD_VAR 0 7
76839: ARRAY
76840: PPUSH
76841: LD_VAR 0 14
76845: PUSH
76846: LD_VAR 0 8
76850: ARRAY
76851: PPUSH
76852: CALL_OW 115
// attacking := true ;
76856: LD_ADDR_VAR 0 29
76860: PUSH
76861: LD_INT 1
76863: ST_TO_ADDR
// break ;
76864: GO 76868
// end ;
76866: GO 76805
76868: POP
76869: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
76870: LD_VAR 0 4
76874: PUSH
76875: LD_VAR 0 7
76879: ARRAY
76880: PPUSH
76881: CALL_OW 302
76885: PUSH
76886: LD_VAR 0 29
76890: NOT
76891: AND
76892: IFFALSE 77214
// begin if GetTag ( group [ i ] ) = 71 then
76894: LD_VAR 0 4
76898: PUSH
76899: LD_VAR 0 7
76903: ARRAY
76904: PPUSH
76905: CALL_OW 110
76909: PUSH
76910: LD_INT 71
76912: EQUAL
76913: IFFALSE 76954
// begin if HasTask ( group [ i ] ) then
76915: LD_VAR 0 4
76919: PUSH
76920: LD_VAR 0 7
76924: ARRAY
76925: PPUSH
76926: CALL_OW 314
76930: IFFALSE 76936
// continue else
76932: GO 73093
76934: GO 76954
// SetTag ( group [ i ] , 0 ) ;
76936: LD_VAR 0 4
76940: PUSH
76941: LD_VAR 0 7
76945: ARRAY
76946: PPUSH
76947: LD_INT 0
76949: PPUSH
76950: CALL_OW 109
// end ; k := 8 ;
76954: LD_ADDR_VAR 0 9
76958: PUSH
76959: LD_INT 8
76961: ST_TO_ADDR
// x := 0 ;
76962: LD_ADDR_VAR 0 10
76966: PUSH
76967: LD_INT 0
76969: ST_TO_ADDR
// if tmp < k then
76970: LD_VAR 0 14
76974: PUSH
76975: LD_VAR 0 9
76979: LESS
76980: IFFALSE 76992
// k := tmp ;
76982: LD_ADDR_VAR 0 9
76986: PUSH
76987: LD_VAR 0 14
76991: ST_TO_ADDR
// for j = 1 to k do
76992: LD_ADDR_VAR 0 8
76996: PUSH
76997: DOUBLE
76998: LD_INT 1
77000: DEC
77001: ST_TO_ADDR
77002: LD_VAR 0 9
77006: PUSH
77007: FOR_TO
77008: IFFALSE 77106
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
77010: LD_VAR 0 14
77014: PUSH
77015: LD_VAR 0 8
77019: ARRAY
77020: PPUSH
77021: CALL_OW 247
77025: PUSH
77026: LD_INT 1
77028: EQUAL
77029: PUSH
77030: LD_VAR 0 14
77034: PUSH
77035: LD_VAR 0 8
77039: ARRAY
77040: PPUSH
77041: CALL_OW 256
77045: PUSH
77046: LD_INT 250
77048: LESS
77049: PUSH
77050: LD_VAR 0 20
77054: AND
77055: PUSH
77056: LD_VAR 0 20
77060: NOT
77061: PUSH
77062: LD_VAR 0 14
77066: PUSH
77067: LD_VAR 0 8
77071: ARRAY
77072: PPUSH
77073: CALL_OW 256
77077: PUSH
77078: LD_INT 250
77080: GREATEREQUAL
77081: AND
77082: OR
77083: AND
77084: IFFALSE 77104
// begin x := tmp [ j ] ;
77086: LD_ADDR_VAR 0 10
77090: PUSH
77091: LD_VAR 0 14
77095: PUSH
77096: LD_VAR 0 8
77100: ARRAY
77101: ST_TO_ADDR
// break ;
77102: GO 77106
// end ;
77104: GO 77007
77106: POP
77107: POP
// if x then
77108: LD_VAR 0 10
77112: IFFALSE 77136
// ComAttackUnit ( group [ i ] , x ) else
77114: LD_VAR 0 4
77118: PUSH
77119: LD_VAR 0 7
77123: ARRAY
77124: PPUSH
77125: LD_VAR 0 10
77129: PPUSH
77130: CALL_OW 115
77134: GO 77160
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
77136: LD_VAR 0 4
77140: PUSH
77141: LD_VAR 0 7
77145: ARRAY
77146: PPUSH
77147: LD_VAR 0 14
77151: PUSH
77152: LD_INT 1
77154: ARRAY
77155: PPUSH
77156: CALL_OW 115
// if not HasTask ( group [ i ] ) then
77160: LD_VAR 0 4
77164: PUSH
77165: LD_VAR 0 7
77169: ARRAY
77170: PPUSH
77171: CALL_OW 314
77175: NOT
77176: IFFALSE 77214
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
77178: LD_VAR 0 4
77182: PUSH
77183: LD_VAR 0 7
77187: ARRAY
77188: PPUSH
77189: LD_VAR 0 14
77193: PPUSH
77194: LD_VAR 0 4
77198: PUSH
77199: LD_VAR 0 7
77203: ARRAY
77204: PPUSH
77205: CALL_OW 74
77209: PPUSH
77210: CALL_OW 115
// end ; end ; end ;
77214: GO 73093
77216: POP
77217: POP
// wait ( 0 0$2 ) ;
77218: LD_INT 70
77220: PPUSH
77221: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
77225: LD_VAR 0 4
77229: NOT
77230: PUSH
77231: LD_VAR 0 4
77235: PUSH
77236: EMPTY
77237: EQUAL
77238: OR
77239: PUSH
77240: LD_INT 81
77242: PUSH
77243: LD_VAR 0 35
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PPUSH
77252: CALL_OW 69
77256: NOT
77257: OR
77258: IFFALSE 73078
// end ;
77260: LD_VAR 0 2
77264: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
77265: LD_INT 0
77267: PPUSH
77268: PPUSH
77269: PPUSH
77270: PPUSH
77271: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
77272: LD_VAR 0 1
77276: NOT
77277: PUSH
77278: LD_EXP 14
77282: PUSH
77283: LD_VAR 0 1
77287: ARRAY
77288: NOT
77289: OR
77290: PUSH
77291: LD_VAR 0 2
77295: NOT
77296: OR
77297: PUSH
77298: LD_VAR 0 3
77302: NOT
77303: OR
77304: IFFALSE 77308
// exit ;
77306: GO 77821
// side := mc_sides [ base ] ;
77308: LD_ADDR_VAR 0 6
77312: PUSH
77313: LD_EXP 40
77317: PUSH
77318: LD_VAR 0 1
77322: ARRAY
77323: ST_TO_ADDR
// if not side then
77324: LD_VAR 0 6
77328: NOT
77329: IFFALSE 77333
// exit ;
77331: GO 77821
// for i in solds do
77333: LD_ADDR_VAR 0 7
77337: PUSH
77338: LD_VAR 0 2
77342: PUSH
77343: FOR_IN
77344: IFFALSE 77405
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
77346: LD_VAR 0 7
77350: PPUSH
77351: CALL_OW 310
77355: PPUSH
77356: CALL_OW 266
77360: PUSH
77361: LD_INT 32
77363: PUSH
77364: LD_INT 31
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: IN
77371: IFFALSE 77391
// solds := solds diff i else
77373: LD_ADDR_VAR 0 2
77377: PUSH
77378: LD_VAR 0 2
77382: PUSH
77383: LD_VAR 0 7
77387: DIFF
77388: ST_TO_ADDR
77389: GO 77403
// SetTag ( i , 18 ) ;
77391: LD_VAR 0 7
77395: PPUSH
77396: LD_INT 18
77398: PPUSH
77399: CALL_OW 109
77403: GO 77343
77405: POP
77406: POP
// if not solds then
77407: LD_VAR 0 2
77411: NOT
77412: IFFALSE 77416
// exit ;
77414: GO 77821
// repeat wait ( 0 0$2 ) ;
77416: LD_INT 70
77418: PPUSH
77419: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
77423: LD_ADDR_VAR 0 5
77427: PUSH
77428: LD_VAR 0 6
77432: PPUSH
77433: LD_VAR 0 3
77437: PPUSH
77438: CALL 6228 0 2
77442: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
77443: LD_EXP 14
77447: PUSH
77448: LD_VAR 0 1
77452: ARRAY
77453: NOT
77454: PUSH
77455: LD_EXP 14
77459: PUSH
77460: LD_VAR 0 1
77464: ARRAY
77465: PUSH
77466: EMPTY
77467: EQUAL
77468: OR
77469: IFFALSE 77506
// begin for i in solds do
77471: LD_ADDR_VAR 0 7
77475: PUSH
77476: LD_VAR 0 2
77480: PUSH
77481: FOR_IN
77482: IFFALSE 77495
// ComStop ( i ) ;
77484: LD_VAR 0 7
77488: PPUSH
77489: CALL_OW 141
77493: GO 77481
77495: POP
77496: POP
// solds := [ ] ;
77497: LD_ADDR_VAR 0 2
77501: PUSH
77502: EMPTY
77503: ST_TO_ADDR
// exit ;
77504: GO 77821
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
77506: LD_VAR 0 5
77510: NOT
77511: PUSH
77512: LD_VAR 0 5
77516: PUSH
77517: LD_INT 3
77519: GREATER
77520: OR
77521: PUSH
77522: LD_EXP 36
77526: PUSH
77527: LD_VAR 0 1
77531: ARRAY
77532: OR
77533: IFFALSE 77574
// begin for i in solds do
77535: LD_ADDR_VAR 0 7
77539: PUSH
77540: LD_VAR 0 2
77544: PUSH
77545: FOR_IN
77546: IFFALSE 77570
// if HasTask ( i ) then
77548: LD_VAR 0 7
77552: PPUSH
77553: CALL_OW 314
77557: IFFALSE 77568
// ComStop ( i ) ;
77559: LD_VAR 0 7
77563: PPUSH
77564: CALL_OW 141
77568: GO 77545
77570: POP
77571: POP
// break ;
77572: GO 77809
// end ; for i in solds do
77574: LD_ADDR_VAR 0 7
77578: PUSH
77579: LD_VAR 0 2
77583: PUSH
77584: FOR_IN
77585: IFFALSE 77801
// begin if IsInUnit ( i ) then
77587: LD_VAR 0 7
77591: PPUSH
77592: CALL_OW 310
77596: IFFALSE 77607
// ComExitBuilding ( i ) ;
77598: LD_VAR 0 7
77602: PPUSH
77603: CALL_OW 122
// if GetLives ( i ) > 333 then
77607: LD_VAR 0 7
77611: PPUSH
77612: CALL_OW 256
77616: PUSH
77617: LD_INT 333
77619: GREATER
77620: IFFALSE 77648
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
77622: LD_VAR 0 7
77626: PPUSH
77627: LD_VAR 0 5
77631: PPUSH
77632: LD_VAR 0 7
77636: PPUSH
77637: CALL_OW 74
77641: PPUSH
77642: CALL_OW 115
77646: GO 77799
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
77648: LD_ADDR_VAR 0 8
77652: PUSH
77653: LD_EXP 14
77657: PUSH
77658: LD_VAR 0 1
77662: ARRAY
77663: PPUSH
77664: LD_INT 2
77666: PUSH
77667: LD_INT 30
77669: PUSH
77670: LD_INT 0
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 30
77679: PUSH
77680: LD_INT 1
77682: PUSH
77683: EMPTY
77684: LIST
77685: LIST
77686: PUSH
77687: LD_INT 30
77689: PUSH
77690: LD_INT 6
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: EMPTY
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: PPUSH
77703: CALL_OW 72
77707: PPUSH
77708: LD_VAR 0 7
77712: PPUSH
77713: CALL_OW 74
77717: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
77718: LD_VAR 0 7
77722: PPUSH
77723: LD_VAR 0 8
77727: PPUSH
77728: CALL_OW 250
77732: PPUSH
77733: LD_INT 3
77735: PPUSH
77736: LD_INT 5
77738: PPUSH
77739: CALL_OW 272
77743: PPUSH
77744: LD_VAR 0 8
77748: PPUSH
77749: CALL_OW 251
77753: PPUSH
77754: LD_INT 3
77756: PPUSH
77757: LD_INT 5
77759: PPUSH
77760: CALL_OW 273
77764: PPUSH
77765: CALL_OW 111
// SetTag ( i , 0 ) ;
77769: LD_VAR 0 7
77773: PPUSH
77774: LD_INT 0
77776: PPUSH
77777: CALL_OW 109
// solds := solds diff i ;
77781: LD_ADDR_VAR 0 2
77785: PUSH
77786: LD_VAR 0 2
77790: PUSH
77791: LD_VAR 0 7
77795: DIFF
77796: ST_TO_ADDR
// continue ;
77797: GO 77584
// end ; end ;
77799: GO 77584
77801: POP
77802: POP
// until solds ;
77803: LD_VAR 0 2
77807: IFFALSE 77416
// MC_Reset ( base , 18 ) ;
77809: LD_VAR 0 1
77813: PPUSH
77814: LD_INT 18
77816: PPUSH
77817: CALL 46268 0 2
// end ;
77821: LD_VAR 0 4
77825: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
77826: LD_INT 0
77828: PPUSH
77829: PPUSH
77830: PPUSH
77831: PPUSH
77832: PPUSH
77833: PPUSH
77834: PPUSH
77835: PPUSH
77836: PPUSH
77837: PPUSH
77838: PPUSH
77839: PPUSH
77840: PPUSH
77841: PPUSH
77842: PPUSH
77843: PPUSH
77844: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
77845: LD_ADDR_VAR 0 13
77849: PUSH
77850: LD_EXP 14
77854: PUSH
77855: LD_VAR 0 1
77859: ARRAY
77860: PPUSH
77861: LD_INT 25
77863: PUSH
77864: LD_INT 3
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PPUSH
77871: CALL_OW 72
77875: ST_TO_ADDR
// if mc_remote_driver [ base ] then
77876: LD_EXP 54
77880: PUSH
77881: LD_VAR 0 1
77885: ARRAY
77886: IFFALSE 77910
// mechs := mechs diff mc_remote_driver [ base ] ;
77888: LD_ADDR_VAR 0 13
77892: PUSH
77893: LD_VAR 0 13
77897: PUSH
77898: LD_EXP 54
77902: PUSH
77903: LD_VAR 0 1
77907: ARRAY
77908: DIFF
77909: ST_TO_ADDR
// for i in mechs do
77910: LD_ADDR_VAR 0 5
77914: PUSH
77915: LD_VAR 0 13
77919: PUSH
77920: FOR_IN
77921: IFFALSE 77956
// if GetTag ( i ) > 0 then
77923: LD_VAR 0 5
77927: PPUSH
77928: CALL_OW 110
77932: PUSH
77933: LD_INT 0
77935: GREATER
77936: IFFALSE 77954
// mechs := mechs diff i ;
77938: LD_ADDR_VAR 0 13
77942: PUSH
77943: LD_VAR 0 13
77947: PUSH
77948: LD_VAR 0 5
77952: DIFF
77953: ST_TO_ADDR
77954: GO 77920
77956: POP
77957: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77958: LD_ADDR_VAR 0 9
77962: PUSH
77963: LD_EXP 14
77967: PUSH
77968: LD_VAR 0 1
77972: ARRAY
77973: PPUSH
77974: LD_INT 2
77976: PUSH
77977: LD_INT 25
77979: PUSH
77980: LD_INT 1
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: PUSH
77987: LD_INT 25
77989: PUSH
77990: LD_INT 5
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 25
77999: PUSH
78000: LD_INT 8
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PUSH
78007: LD_INT 25
78009: PUSH
78010: LD_INT 9
78012: PUSH
78013: EMPTY
78014: LIST
78015: LIST
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: LIST
78021: LIST
78022: LIST
78023: PPUSH
78024: CALL_OW 72
78028: ST_TO_ADDR
// if not defenders and not solds then
78029: LD_VAR 0 2
78033: NOT
78034: PUSH
78035: LD_VAR 0 9
78039: NOT
78040: AND
78041: IFFALSE 78045
// exit ;
78043: GO 79735
// depot_under_attack := false ;
78045: LD_ADDR_VAR 0 17
78049: PUSH
78050: LD_INT 0
78052: ST_TO_ADDR
// sold_defenders := [ ] ;
78053: LD_ADDR_VAR 0 18
78057: PUSH
78058: EMPTY
78059: ST_TO_ADDR
// if mechs then
78060: LD_VAR 0 13
78064: IFFALSE 78217
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
78066: LD_ADDR_VAR 0 5
78070: PUSH
78071: LD_VAR 0 2
78075: PPUSH
78076: LD_INT 21
78078: PUSH
78079: LD_INT 2
78081: PUSH
78082: EMPTY
78083: LIST
78084: LIST
78085: PPUSH
78086: CALL_OW 72
78090: PUSH
78091: FOR_IN
78092: IFFALSE 78215
// begin if GetTag ( i ) <> 20 then
78094: LD_VAR 0 5
78098: PPUSH
78099: CALL_OW 110
78103: PUSH
78104: LD_INT 20
78106: NONEQUAL
78107: IFFALSE 78121
// SetTag ( i , 20 ) ;
78109: LD_VAR 0 5
78113: PPUSH
78114: LD_INT 20
78116: PPUSH
78117: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
78121: LD_VAR 0 5
78125: PPUSH
78126: CALL_OW 263
78130: PUSH
78131: LD_INT 1
78133: EQUAL
78134: PUSH
78135: LD_VAR 0 5
78139: PPUSH
78140: CALL_OW 311
78144: NOT
78145: AND
78146: IFFALSE 78213
// begin un := mechs [ 1 ] ;
78148: LD_ADDR_VAR 0 11
78152: PUSH
78153: LD_VAR 0 13
78157: PUSH
78158: LD_INT 1
78160: ARRAY
78161: ST_TO_ADDR
// ComExit ( un ) ;
78162: LD_VAR 0 11
78166: PPUSH
78167: CALL 41191 0 1
// AddComEnterUnit ( un , i ) ;
78171: LD_VAR 0 11
78175: PPUSH
78176: LD_VAR 0 5
78180: PPUSH
78181: CALL_OW 180
// SetTag ( un , 19 ) ;
78185: LD_VAR 0 11
78189: PPUSH
78190: LD_INT 19
78192: PPUSH
78193: CALL_OW 109
// mechs := mechs diff un ;
78197: LD_ADDR_VAR 0 13
78201: PUSH
78202: LD_VAR 0 13
78206: PUSH
78207: LD_VAR 0 11
78211: DIFF
78212: ST_TO_ADDR
// end ; end ;
78213: GO 78091
78215: POP
78216: POP
// if solds then
78217: LD_VAR 0 9
78221: IFFALSE 78280
// for i in solds do
78223: LD_ADDR_VAR 0 5
78227: PUSH
78228: LD_VAR 0 9
78232: PUSH
78233: FOR_IN
78234: IFFALSE 78278
// if not GetTag ( i ) then
78236: LD_VAR 0 5
78240: PPUSH
78241: CALL_OW 110
78245: NOT
78246: IFFALSE 78276
// begin defenders := defenders union i ;
78248: LD_ADDR_VAR 0 2
78252: PUSH
78253: LD_VAR 0 2
78257: PUSH
78258: LD_VAR 0 5
78262: UNION
78263: ST_TO_ADDR
// SetTag ( i , 18 ) ;
78264: LD_VAR 0 5
78268: PPUSH
78269: LD_INT 18
78271: PPUSH
78272: CALL_OW 109
// end ;
78276: GO 78233
78278: POP
78279: POP
// repeat wait ( 0 0$2 ) ;
78280: LD_INT 70
78282: PPUSH
78283: CALL_OW 67
// enemy := mc_scan [ base ] ;
78287: LD_ADDR_VAR 0 3
78291: PUSH
78292: LD_EXP 37
78296: PUSH
78297: LD_VAR 0 1
78301: ARRAY
78302: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
78303: LD_EXP 14
78307: PUSH
78308: LD_VAR 0 1
78312: ARRAY
78313: NOT
78314: PUSH
78315: LD_EXP 14
78319: PUSH
78320: LD_VAR 0 1
78324: ARRAY
78325: PUSH
78326: EMPTY
78327: EQUAL
78328: OR
78329: IFFALSE 78366
// begin for i in defenders do
78331: LD_ADDR_VAR 0 5
78335: PUSH
78336: LD_VAR 0 2
78340: PUSH
78341: FOR_IN
78342: IFFALSE 78355
// ComStop ( i ) ;
78344: LD_VAR 0 5
78348: PPUSH
78349: CALL_OW 141
78353: GO 78341
78355: POP
78356: POP
// defenders := [ ] ;
78357: LD_ADDR_VAR 0 2
78361: PUSH
78362: EMPTY
78363: ST_TO_ADDR
// exit ;
78364: GO 79735
// end ; for i in defenders do
78366: LD_ADDR_VAR 0 5
78370: PUSH
78371: LD_VAR 0 2
78375: PUSH
78376: FOR_IN
78377: IFFALSE 79195
// begin e := NearestUnitToUnit ( enemy , i ) ;
78379: LD_ADDR_VAR 0 14
78383: PUSH
78384: LD_VAR 0 3
78388: PPUSH
78389: LD_VAR 0 5
78393: PPUSH
78394: CALL_OW 74
78398: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78399: LD_ADDR_VAR 0 8
78403: PUSH
78404: LD_EXP 14
78408: PUSH
78409: LD_VAR 0 1
78413: ARRAY
78414: PPUSH
78415: LD_INT 2
78417: PUSH
78418: LD_INT 30
78420: PUSH
78421: LD_INT 0
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: LD_INT 30
78430: PUSH
78431: LD_INT 1
78433: PUSH
78434: EMPTY
78435: LIST
78436: LIST
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: LIST
78442: PPUSH
78443: CALL_OW 72
78447: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
78448: LD_ADDR_VAR 0 17
78452: PUSH
78453: LD_VAR 0 8
78457: NOT
78458: PUSH
78459: LD_VAR 0 8
78463: PPUSH
78464: LD_INT 3
78466: PUSH
78467: LD_INT 24
78469: PUSH
78470: LD_INT 600
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PPUSH
78481: CALL_OW 72
78485: OR
78486: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
78487: LD_VAR 0 5
78491: PPUSH
78492: CALL_OW 247
78496: PUSH
78497: LD_INT 2
78499: DOUBLE
78500: EQUAL
78501: IFTRUE 78505
78503: GO 78901
78505: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
78506: LD_VAR 0 5
78510: PPUSH
78511: CALL_OW 256
78515: PUSH
78516: LD_INT 1000
78518: EQUAL
78519: PUSH
78520: LD_VAR 0 5
78524: PPUSH
78525: LD_VAR 0 14
78529: PPUSH
78530: CALL_OW 296
78534: PUSH
78535: LD_INT 40
78537: LESS
78538: PUSH
78539: LD_VAR 0 14
78543: PPUSH
78544: LD_EXP 39
78548: PUSH
78549: LD_VAR 0 1
78553: ARRAY
78554: PPUSH
78555: CALL_OW 308
78559: OR
78560: AND
78561: IFFALSE 78683
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
78563: LD_VAR 0 5
78567: PPUSH
78568: CALL_OW 262
78572: PUSH
78573: LD_INT 1
78575: EQUAL
78576: PUSH
78577: LD_VAR 0 5
78581: PPUSH
78582: CALL_OW 261
78586: PUSH
78587: LD_INT 30
78589: LESS
78590: AND
78591: PUSH
78592: LD_VAR 0 8
78596: AND
78597: IFFALSE 78667
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
78599: LD_VAR 0 5
78603: PPUSH
78604: LD_VAR 0 8
78608: PPUSH
78609: LD_VAR 0 5
78613: PPUSH
78614: CALL_OW 74
78618: PPUSH
78619: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
78623: LD_VAR 0 5
78627: PPUSH
78628: LD_VAR 0 8
78632: PPUSH
78633: LD_VAR 0 5
78637: PPUSH
78638: CALL_OW 74
78642: PPUSH
78643: CALL_OW 296
78647: PUSH
78648: LD_INT 6
78650: LESS
78651: IFFALSE 78665
// SetFuel ( i , 100 ) ;
78653: LD_VAR 0 5
78657: PPUSH
78658: LD_INT 100
78660: PPUSH
78661: CALL_OW 240
// end else
78665: GO 78681
// ComAttackUnit ( i , e ) ;
78667: LD_VAR 0 5
78671: PPUSH
78672: LD_VAR 0 14
78676: PPUSH
78677: CALL_OW 115
// end else
78681: GO 78784
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
78683: LD_VAR 0 14
78687: PPUSH
78688: LD_EXP 39
78692: PUSH
78693: LD_VAR 0 1
78697: ARRAY
78698: PPUSH
78699: CALL_OW 308
78703: NOT
78704: PUSH
78705: LD_VAR 0 5
78709: PPUSH
78710: LD_VAR 0 14
78714: PPUSH
78715: CALL_OW 296
78719: PUSH
78720: LD_INT 40
78722: GREATEREQUAL
78723: AND
78724: PUSH
78725: LD_VAR 0 5
78729: PPUSH
78730: CALL_OW 256
78734: PUSH
78735: LD_INT 650
78737: LESSEQUAL
78738: OR
78739: PUSH
78740: LD_VAR 0 5
78744: PPUSH
78745: LD_EXP 38
78749: PUSH
78750: LD_VAR 0 1
78754: ARRAY
78755: PPUSH
78756: CALL_OW 308
78760: NOT
78761: AND
78762: IFFALSE 78784
// ComMoveToArea ( i , mc_parking [ base ] ) ;
78764: LD_VAR 0 5
78768: PPUSH
78769: LD_EXP 38
78773: PUSH
78774: LD_VAR 0 1
78778: ARRAY
78779: PPUSH
78780: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
78784: LD_VAR 0 5
78788: PPUSH
78789: CALL_OW 256
78793: PUSH
78794: LD_INT 1000
78796: LESS
78797: PUSH
78798: LD_VAR 0 5
78802: PPUSH
78803: CALL_OW 263
78807: PUSH
78808: LD_INT 1
78810: EQUAL
78811: AND
78812: PUSH
78813: LD_VAR 0 5
78817: PPUSH
78818: CALL_OW 311
78822: AND
78823: PUSH
78824: LD_VAR 0 5
78828: PPUSH
78829: LD_EXP 38
78833: PUSH
78834: LD_VAR 0 1
78838: ARRAY
78839: PPUSH
78840: CALL_OW 308
78844: AND
78845: IFFALSE 78899
// begin mech := IsDrivenBy ( i ) ;
78847: LD_ADDR_VAR 0 10
78851: PUSH
78852: LD_VAR 0 5
78856: PPUSH
78857: CALL_OW 311
78861: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
78862: LD_VAR 0 10
78866: PPUSH
78867: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
78871: LD_VAR 0 10
78875: PPUSH
78876: LD_VAR 0 5
78880: PPUSH
78881: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
78885: LD_VAR 0 10
78889: PPUSH
78890: LD_VAR 0 5
78894: PPUSH
78895: CALL_OW 180
// end ; end ; unit_human :
78899: GO 79166
78901: LD_INT 1
78903: DOUBLE
78904: EQUAL
78905: IFTRUE 78909
78907: GO 79165
78909: POP
// begin b := IsInUnit ( i ) ;
78910: LD_ADDR_VAR 0 19
78914: PUSH
78915: LD_VAR 0 5
78919: PPUSH
78920: CALL_OW 310
78924: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
78925: LD_ADDR_VAR 0 20
78929: PUSH
78930: LD_VAR 0 19
78934: NOT
78935: PUSH
78936: LD_VAR 0 19
78940: PPUSH
78941: CALL_OW 266
78945: PUSH
78946: LD_INT 32
78948: PUSH
78949: LD_INT 31
78951: PUSH
78952: EMPTY
78953: LIST
78954: LIST
78955: IN
78956: OR
78957: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
78958: LD_VAR 0 17
78962: PUSH
78963: LD_VAR 0 2
78967: PPUSH
78968: LD_INT 21
78970: PUSH
78971: LD_INT 2
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PPUSH
78978: CALL_OW 72
78982: PUSH
78983: LD_INT 1
78985: LESSEQUAL
78986: OR
78987: PUSH
78988: LD_VAR 0 20
78992: AND
78993: PUSH
78994: LD_VAR 0 5
78998: PUSH
78999: LD_VAR 0 18
79003: IN
79004: NOT
79005: AND
79006: IFFALSE 79099
// begin if b then
79008: LD_VAR 0 19
79012: IFFALSE 79061
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
79014: LD_VAR 0 19
79018: PPUSH
79019: LD_VAR 0 3
79023: PPUSH
79024: LD_VAR 0 19
79028: PPUSH
79029: CALL_OW 74
79033: PPUSH
79034: CALL_OW 296
79038: PUSH
79039: LD_INT 10
79041: LESS
79042: PUSH
79043: LD_VAR 0 19
79047: PPUSH
79048: CALL_OW 461
79052: PUSH
79053: LD_INT 7
79055: NONEQUAL
79056: AND
79057: IFFALSE 79061
// continue ;
79059: GO 78376
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
79061: LD_ADDR_VAR 0 18
79065: PUSH
79066: LD_VAR 0 18
79070: PPUSH
79071: LD_VAR 0 18
79075: PUSH
79076: LD_INT 1
79078: PLUS
79079: PPUSH
79080: LD_VAR 0 5
79084: PPUSH
79085: CALL_OW 1
79089: ST_TO_ADDR
// ComExitBuilding ( i ) ;
79090: LD_VAR 0 5
79094: PPUSH
79095: CALL_OW 122
// end ; if sold_defenders then
79099: LD_VAR 0 18
79103: IFFALSE 79163
// if i in sold_defenders then
79105: LD_VAR 0 5
79109: PUSH
79110: LD_VAR 0 18
79114: IN
79115: IFFALSE 79163
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
79117: LD_VAR 0 5
79121: PPUSH
79122: CALL_OW 314
79126: NOT
79127: PUSH
79128: LD_VAR 0 5
79132: PPUSH
79133: LD_VAR 0 14
79137: PPUSH
79138: CALL_OW 296
79142: PUSH
79143: LD_INT 30
79145: LESS
79146: AND
79147: IFFALSE 79163
// ComAttackUnit ( i , e ) ;
79149: LD_VAR 0 5
79153: PPUSH
79154: LD_VAR 0 14
79158: PPUSH
79159: CALL_OW 115
// end ; end ; end ;
79163: GO 79166
79165: POP
// if IsDead ( i ) then
79166: LD_VAR 0 5
79170: PPUSH
79171: CALL_OW 301
79175: IFFALSE 79193
// defenders := defenders diff i ;
79177: LD_ADDR_VAR 0 2
79181: PUSH
79182: LD_VAR 0 2
79186: PUSH
79187: LD_VAR 0 5
79191: DIFF
79192: ST_TO_ADDR
// end ;
79193: GO 78376
79195: POP
79196: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
79197: LD_VAR 0 3
79201: NOT
79202: PUSH
79203: LD_VAR 0 2
79207: NOT
79208: OR
79209: PUSH
79210: LD_EXP 14
79214: PUSH
79215: LD_VAR 0 1
79219: ARRAY
79220: NOT
79221: OR
79222: IFFALSE 78280
// MC_Reset ( base , 18 ) ;
79224: LD_VAR 0 1
79228: PPUSH
79229: LD_INT 18
79231: PPUSH
79232: CALL 46268 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
79236: LD_ADDR_VAR 0 2
79240: PUSH
79241: LD_VAR 0 2
79245: PUSH
79246: LD_VAR 0 2
79250: PPUSH
79251: LD_INT 2
79253: PUSH
79254: LD_INT 25
79256: PUSH
79257: LD_INT 1
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: LD_INT 25
79266: PUSH
79267: LD_INT 5
79269: PUSH
79270: EMPTY
79271: LIST
79272: LIST
79273: PUSH
79274: LD_INT 25
79276: PUSH
79277: LD_INT 8
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 25
79286: PUSH
79287: LD_INT 9
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PUSH
79294: EMPTY
79295: LIST
79296: LIST
79297: LIST
79298: LIST
79299: LIST
79300: PPUSH
79301: CALL_OW 72
79305: DIFF
79306: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
79307: LD_VAR 0 3
79311: NOT
79312: PUSH
79313: LD_VAR 0 2
79317: PPUSH
79318: LD_INT 21
79320: PUSH
79321: LD_INT 2
79323: PUSH
79324: EMPTY
79325: LIST
79326: LIST
79327: PPUSH
79328: CALL_OW 72
79332: AND
79333: IFFALSE 79671
// begin tmp := FilterByTag ( defenders , 19 ) ;
79335: LD_ADDR_VAR 0 12
79339: PUSH
79340: LD_VAR 0 2
79344: PPUSH
79345: LD_INT 19
79347: PPUSH
79348: CALL 38321 0 2
79352: ST_TO_ADDR
// if tmp then
79353: LD_VAR 0 12
79357: IFFALSE 79427
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
79359: LD_ADDR_VAR 0 12
79363: PUSH
79364: LD_VAR 0 12
79368: PPUSH
79369: LD_INT 25
79371: PUSH
79372: LD_INT 3
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PPUSH
79379: CALL_OW 72
79383: ST_TO_ADDR
// if tmp then
79384: LD_VAR 0 12
79388: IFFALSE 79427
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
79390: LD_ADDR_EXP 26
79394: PUSH
79395: LD_EXP 26
79399: PPUSH
79400: LD_VAR 0 1
79404: PPUSH
79405: LD_EXP 26
79409: PUSH
79410: LD_VAR 0 1
79414: ARRAY
79415: PUSH
79416: LD_VAR 0 12
79420: UNION
79421: PPUSH
79422: CALL_OW 1
79426: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
79427: LD_VAR 0 1
79431: PPUSH
79432: LD_INT 19
79434: PPUSH
79435: CALL 46268 0 2
// repeat wait ( 0 0$1 ) ;
79439: LD_INT 35
79441: PPUSH
79442: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
79446: LD_EXP 14
79450: PUSH
79451: LD_VAR 0 1
79455: ARRAY
79456: NOT
79457: PUSH
79458: LD_EXP 14
79462: PUSH
79463: LD_VAR 0 1
79467: ARRAY
79468: PUSH
79469: EMPTY
79470: EQUAL
79471: OR
79472: IFFALSE 79509
// begin for i in defenders do
79474: LD_ADDR_VAR 0 5
79478: PUSH
79479: LD_VAR 0 2
79483: PUSH
79484: FOR_IN
79485: IFFALSE 79498
// ComStop ( i ) ;
79487: LD_VAR 0 5
79491: PPUSH
79492: CALL_OW 141
79496: GO 79484
79498: POP
79499: POP
// defenders := [ ] ;
79500: LD_ADDR_VAR 0 2
79504: PUSH
79505: EMPTY
79506: ST_TO_ADDR
// exit ;
79507: GO 79735
// end ; for i in defenders do
79509: LD_ADDR_VAR 0 5
79513: PUSH
79514: LD_VAR 0 2
79518: PUSH
79519: FOR_IN
79520: IFFALSE 79609
// begin if not IsInArea ( i , mc_parking [ base ] ) then
79522: LD_VAR 0 5
79526: PPUSH
79527: LD_EXP 38
79531: PUSH
79532: LD_VAR 0 1
79536: ARRAY
79537: PPUSH
79538: CALL_OW 308
79542: NOT
79543: IFFALSE 79567
// ComMoveToArea ( i , mc_parking [ base ] ) else
79545: LD_VAR 0 5
79549: PPUSH
79550: LD_EXP 38
79554: PUSH
79555: LD_VAR 0 1
79559: ARRAY
79560: PPUSH
79561: CALL_OW 113
79565: GO 79607
// if GetControl ( i ) = control_manual then
79567: LD_VAR 0 5
79571: PPUSH
79572: CALL_OW 263
79576: PUSH
79577: LD_INT 1
79579: EQUAL
79580: IFFALSE 79607
// if IsDrivenBy ( i ) then
79582: LD_VAR 0 5
79586: PPUSH
79587: CALL_OW 311
79591: IFFALSE 79607
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
79593: LD_VAR 0 5
79597: PPUSH
79598: CALL_OW 311
79602: PPUSH
79603: CALL_OW 121
// end ;
79607: GO 79519
79609: POP
79610: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
79611: LD_VAR 0 2
79615: PPUSH
79616: LD_INT 95
79618: PUSH
79619: LD_EXP 38
79623: PUSH
79624: LD_VAR 0 1
79628: ARRAY
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PPUSH
79634: CALL_OW 72
79638: PUSH
79639: LD_VAR 0 2
79643: EQUAL
79644: PUSH
79645: LD_EXP 37
79649: PUSH
79650: LD_VAR 0 1
79654: ARRAY
79655: OR
79656: PUSH
79657: LD_EXP 14
79661: PUSH
79662: LD_VAR 0 1
79666: ARRAY
79667: NOT
79668: OR
79669: IFFALSE 79439
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
79671: LD_ADDR_EXP 36
79675: PUSH
79676: LD_EXP 36
79680: PPUSH
79681: LD_VAR 0 1
79685: PPUSH
79686: LD_VAR 0 2
79690: PPUSH
79691: LD_INT 21
79693: PUSH
79694: LD_INT 2
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PPUSH
79701: CALL_OW 72
79705: PPUSH
79706: CALL_OW 1
79710: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
79711: LD_VAR 0 1
79715: PPUSH
79716: LD_INT 19
79718: PPUSH
79719: CALL 46268 0 2
// MC_Reset ( base , 20 ) ;
79723: LD_VAR 0 1
79727: PPUSH
79728: LD_INT 20
79730: PPUSH
79731: CALL 46268 0 2
// end ; end_of_file
79735: LD_VAR 0 4
79739: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
79740: LD_INT 0
79742: PPUSH
79743: PPUSH
79744: PPUSH
79745: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
79746: LD_VAR 0 1
79750: PPUSH
79751: CALL_OW 264
79755: PUSH
79756: LD_EXP 62
79760: EQUAL
79761: IFFALSE 79833
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
79763: LD_INT 68
79765: PPUSH
79766: LD_VAR 0 1
79770: PPUSH
79771: CALL_OW 255
79775: PPUSH
79776: CALL_OW 321
79780: PUSH
79781: LD_INT 2
79783: EQUAL
79784: IFFALSE 79796
// eff := 70 else
79786: LD_ADDR_VAR 0 4
79790: PUSH
79791: LD_INT 70
79793: ST_TO_ADDR
79794: GO 79804
// eff := 30 ;
79796: LD_ADDR_VAR 0 4
79800: PUSH
79801: LD_INT 30
79803: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
79804: LD_VAR 0 1
79808: PPUSH
79809: CALL_OW 250
79813: PPUSH
79814: LD_VAR 0 1
79818: PPUSH
79819: CALL_OW 251
79823: PPUSH
79824: LD_VAR 0 4
79828: PPUSH
79829: CALL_OW 495
// end ; end ;
79833: LD_VAR 0 2
79837: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
79838: LD_INT 0
79840: PPUSH
// end ;
79841: LD_VAR 0 4
79845: RET
// export function SOS_Command ( cmd ) ; begin
79846: LD_INT 0
79848: PPUSH
// end ;
79849: LD_VAR 0 2
79853: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
79854: LD_INT 0
79856: PPUSH
// if cmd = 121 then
79857: LD_VAR 0 1
79861: PUSH
79862: LD_INT 121
79864: EQUAL
79865: IFFALSE 79867
// end ;
79867: LD_VAR 0 6
79871: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
79872: LD_INT 0
79874: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
79875: LD_VAR 0 1
79879: PUSH
79880: LD_INT 250
79882: EQUAL
79883: PUSH
79884: LD_VAR 0 2
79888: PPUSH
79889: CALL_OW 264
79893: PUSH
79894: LD_EXP 65
79898: EQUAL
79899: AND
79900: IFFALSE 79921
// MinerPlaceMine ( unit , x , y ) ;
79902: LD_VAR 0 2
79906: PPUSH
79907: LD_VAR 0 4
79911: PPUSH
79912: LD_VAR 0 5
79916: PPUSH
79917: CALL 82270 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
79921: LD_VAR 0 1
79925: PUSH
79926: LD_INT 251
79928: EQUAL
79929: PUSH
79930: LD_VAR 0 2
79934: PPUSH
79935: CALL_OW 264
79939: PUSH
79940: LD_EXP 65
79944: EQUAL
79945: AND
79946: IFFALSE 79967
// MinerDetonateMine ( unit , x , y ) ;
79948: LD_VAR 0 2
79952: PPUSH
79953: LD_VAR 0 4
79957: PPUSH
79958: LD_VAR 0 5
79962: PPUSH
79963: CALL 82547 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
79967: LD_VAR 0 1
79971: PUSH
79972: LD_INT 252
79974: EQUAL
79975: PUSH
79976: LD_VAR 0 2
79980: PPUSH
79981: CALL_OW 264
79985: PUSH
79986: LD_EXP 65
79990: EQUAL
79991: AND
79992: IFFALSE 80013
// MinerCreateMinefield ( unit , x , y ) ;
79994: LD_VAR 0 2
79998: PPUSH
79999: LD_VAR 0 4
80003: PPUSH
80004: LD_VAR 0 5
80008: PPUSH
80009: CALL 82964 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
80013: LD_VAR 0 1
80017: PUSH
80018: LD_INT 253
80020: EQUAL
80021: PUSH
80022: LD_VAR 0 2
80026: PPUSH
80027: CALL_OW 257
80031: PUSH
80032: LD_INT 5
80034: EQUAL
80035: AND
80036: IFFALSE 80057
// ComBinocular ( unit , x , y ) ;
80038: LD_VAR 0 2
80042: PPUSH
80043: LD_VAR 0 4
80047: PPUSH
80048: LD_VAR 0 5
80052: PPUSH
80053: CALL 83335 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
80057: LD_VAR 0 1
80061: PUSH
80062: LD_INT 254
80064: EQUAL
80065: PUSH
80066: LD_VAR 0 2
80070: PPUSH
80071: CALL_OW 264
80075: PUSH
80076: LD_EXP 60
80080: EQUAL
80081: AND
80082: PUSH
80083: LD_VAR 0 3
80087: PPUSH
80088: CALL_OW 263
80092: PUSH
80093: LD_INT 3
80095: EQUAL
80096: AND
80097: IFFALSE 80113
// HackDestroyVehicle ( unit , selectedUnit ) ;
80099: LD_VAR 0 2
80103: PPUSH
80104: LD_VAR 0 3
80108: PPUSH
80109: CALL 81630 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
80113: LD_VAR 0 1
80117: PUSH
80118: LD_INT 255
80120: EQUAL
80121: PUSH
80122: LD_VAR 0 2
80126: PPUSH
80127: CALL_OW 264
80131: PUSH
80132: LD_INT 14
80134: PUSH
80135: LD_INT 53
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: IN
80142: AND
80143: PUSH
80144: LD_VAR 0 4
80148: PPUSH
80149: LD_VAR 0 5
80153: PPUSH
80154: CALL_OW 488
80158: AND
80159: IFFALSE 80183
// CutTreeXYR ( unit , x , y , 12 ) ;
80161: LD_VAR 0 2
80165: PPUSH
80166: LD_VAR 0 4
80170: PPUSH
80171: LD_VAR 0 5
80175: PPUSH
80176: LD_INT 12
80178: PPUSH
80179: CALL 80196 0 4
// end ;
80183: LD_VAR 0 6
80187: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
80188: LD_INT 0
80190: PPUSH
// end ;
80191: LD_VAR 0 4
80195: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
80196: LD_INT 0
80198: PPUSH
80199: PPUSH
80200: PPUSH
80201: PPUSH
80202: PPUSH
80203: PPUSH
80204: PPUSH
80205: PPUSH
80206: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
80207: LD_VAR 0 1
80211: NOT
80212: PUSH
80213: LD_VAR 0 2
80217: PPUSH
80218: LD_VAR 0 3
80222: PPUSH
80223: CALL_OW 488
80227: NOT
80228: OR
80229: PUSH
80230: LD_VAR 0 4
80234: NOT
80235: OR
80236: IFFALSE 80240
// exit ;
80238: GO 80580
// list := [ ] ;
80240: LD_ADDR_VAR 0 13
80244: PUSH
80245: EMPTY
80246: ST_TO_ADDR
// if x - r < 0 then
80247: LD_VAR 0 2
80251: PUSH
80252: LD_VAR 0 4
80256: MINUS
80257: PUSH
80258: LD_INT 0
80260: LESS
80261: IFFALSE 80273
// min_x := 0 else
80263: LD_ADDR_VAR 0 7
80267: PUSH
80268: LD_INT 0
80270: ST_TO_ADDR
80271: GO 80289
// min_x := x - r ;
80273: LD_ADDR_VAR 0 7
80277: PUSH
80278: LD_VAR 0 2
80282: PUSH
80283: LD_VAR 0 4
80287: MINUS
80288: ST_TO_ADDR
// if y - r < 0 then
80289: LD_VAR 0 3
80293: PUSH
80294: LD_VAR 0 4
80298: MINUS
80299: PUSH
80300: LD_INT 0
80302: LESS
80303: IFFALSE 80315
// min_y := 0 else
80305: LD_ADDR_VAR 0 8
80309: PUSH
80310: LD_INT 0
80312: ST_TO_ADDR
80313: GO 80331
// min_y := y - r ;
80315: LD_ADDR_VAR 0 8
80319: PUSH
80320: LD_VAR 0 3
80324: PUSH
80325: LD_VAR 0 4
80329: MINUS
80330: ST_TO_ADDR
// max_x := x + r ;
80331: LD_ADDR_VAR 0 9
80335: PUSH
80336: LD_VAR 0 2
80340: PUSH
80341: LD_VAR 0 4
80345: PLUS
80346: ST_TO_ADDR
// max_y := y + r ;
80347: LD_ADDR_VAR 0 10
80351: PUSH
80352: LD_VAR 0 3
80356: PUSH
80357: LD_VAR 0 4
80361: PLUS
80362: ST_TO_ADDR
// for _x = min_x to max_x do
80363: LD_ADDR_VAR 0 11
80367: PUSH
80368: DOUBLE
80369: LD_VAR 0 7
80373: DEC
80374: ST_TO_ADDR
80375: LD_VAR 0 9
80379: PUSH
80380: FOR_TO
80381: IFFALSE 80498
// for _y = min_y to max_y do
80383: LD_ADDR_VAR 0 12
80387: PUSH
80388: DOUBLE
80389: LD_VAR 0 8
80393: DEC
80394: ST_TO_ADDR
80395: LD_VAR 0 10
80399: PUSH
80400: FOR_TO
80401: IFFALSE 80494
// begin if not ValidHex ( _x , _y ) then
80403: LD_VAR 0 11
80407: PPUSH
80408: LD_VAR 0 12
80412: PPUSH
80413: CALL_OW 488
80417: NOT
80418: IFFALSE 80422
// continue ;
80420: GO 80400
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
80422: LD_VAR 0 11
80426: PPUSH
80427: LD_VAR 0 12
80431: PPUSH
80432: CALL_OW 351
80436: PUSH
80437: LD_VAR 0 11
80441: PPUSH
80442: LD_VAR 0 12
80446: PPUSH
80447: CALL_OW 554
80451: AND
80452: IFFALSE 80492
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
80454: LD_ADDR_VAR 0 13
80458: PUSH
80459: LD_VAR 0 13
80463: PPUSH
80464: LD_VAR 0 13
80468: PUSH
80469: LD_INT 1
80471: PLUS
80472: PPUSH
80473: LD_VAR 0 11
80477: PUSH
80478: LD_VAR 0 12
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PPUSH
80487: CALL_OW 2
80491: ST_TO_ADDR
// end ;
80492: GO 80400
80494: POP
80495: POP
80496: GO 80380
80498: POP
80499: POP
// if not list then
80500: LD_VAR 0 13
80504: NOT
80505: IFFALSE 80509
// exit ;
80507: GO 80580
// for i in list do
80509: LD_ADDR_VAR 0 6
80513: PUSH
80514: LD_VAR 0 13
80518: PUSH
80519: FOR_IN
80520: IFFALSE 80578
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
80522: LD_VAR 0 1
80526: PPUSH
80527: LD_STRING M
80529: PUSH
80530: LD_VAR 0 6
80534: PUSH
80535: LD_INT 1
80537: ARRAY
80538: PUSH
80539: LD_VAR 0 6
80543: PUSH
80544: LD_INT 2
80546: ARRAY
80547: PUSH
80548: LD_INT 0
80550: PUSH
80551: LD_INT 0
80553: PUSH
80554: LD_INT 0
80556: PUSH
80557: LD_INT 0
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: PUSH
80569: EMPTY
80570: LIST
80571: PPUSH
80572: CALL_OW 447
80576: GO 80519
80578: POP
80579: POP
// end ;
80580: LD_VAR 0 5
80584: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
80585: LD_EXP 78
80589: NOT
80590: IFFALSE 80640
80592: GO 80594
80594: DISABLE
// begin initHack := true ;
80595: LD_ADDR_EXP 78
80599: PUSH
80600: LD_INT 1
80602: ST_TO_ADDR
// hackTanks := [ ] ;
80603: LD_ADDR_EXP 79
80607: PUSH
80608: EMPTY
80609: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
80610: LD_ADDR_EXP 80
80614: PUSH
80615: EMPTY
80616: ST_TO_ADDR
// hackLimit := 3 ;
80617: LD_ADDR_EXP 81
80621: PUSH
80622: LD_INT 3
80624: ST_TO_ADDR
// hackDist := 12 ;
80625: LD_ADDR_EXP 82
80629: PUSH
80630: LD_INT 12
80632: ST_TO_ADDR
// hackCounter := [ ] ;
80633: LD_ADDR_EXP 83
80637: PUSH
80638: EMPTY
80639: ST_TO_ADDR
// end ;
80640: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
80641: LD_EXP 78
80645: PUSH
80646: LD_INT 34
80648: PUSH
80649: LD_EXP 60
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: PPUSH
80658: CALL_OW 69
80662: AND
80663: IFFALSE 80918
80665: GO 80667
80667: DISABLE
80668: LD_INT 0
80670: PPUSH
80671: PPUSH
// begin enable ;
80672: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
80673: LD_ADDR_VAR 0 1
80677: PUSH
80678: LD_INT 34
80680: PUSH
80681: LD_EXP 60
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PPUSH
80690: CALL_OW 69
80694: PUSH
80695: FOR_IN
80696: IFFALSE 80916
// begin if not i in hackTanks then
80698: LD_VAR 0 1
80702: PUSH
80703: LD_EXP 79
80707: IN
80708: NOT
80709: IFFALSE 80792
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
80711: LD_ADDR_EXP 79
80715: PUSH
80716: LD_EXP 79
80720: PPUSH
80721: LD_EXP 79
80725: PUSH
80726: LD_INT 1
80728: PLUS
80729: PPUSH
80730: LD_VAR 0 1
80734: PPUSH
80735: CALL_OW 1
80739: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
80740: LD_ADDR_EXP 80
80744: PUSH
80745: LD_EXP 80
80749: PPUSH
80750: LD_EXP 80
80754: PUSH
80755: LD_INT 1
80757: PLUS
80758: PPUSH
80759: EMPTY
80760: PPUSH
80761: CALL_OW 1
80765: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
80766: LD_ADDR_EXP 83
80770: PUSH
80771: LD_EXP 83
80775: PPUSH
80776: LD_EXP 83
80780: PUSH
80781: LD_INT 1
80783: PLUS
80784: PPUSH
80785: EMPTY
80786: PPUSH
80787: CALL_OW 1
80791: ST_TO_ADDR
// end ; if not IsOk ( i ) then
80792: LD_VAR 0 1
80796: PPUSH
80797: CALL_OW 302
80801: NOT
80802: IFFALSE 80815
// begin HackUnlinkAll ( i ) ;
80804: LD_VAR 0 1
80808: PPUSH
80809: CALL 80921 0 1
// continue ;
80813: GO 80695
// end ; HackCheckCapturedStatus ( i ) ;
80815: LD_VAR 0 1
80819: PPUSH
80820: CALL 81364 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
80824: LD_ADDR_VAR 0 2
80828: PUSH
80829: LD_INT 81
80831: PUSH
80832: LD_VAR 0 1
80836: PPUSH
80837: CALL_OW 255
80841: PUSH
80842: EMPTY
80843: LIST
80844: LIST
80845: PUSH
80846: LD_INT 33
80848: PUSH
80849: LD_INT 3
80851: PUSH
80852: EMPTY
80853: LIST
80854: LIST
80855: PUSH
80856: LD_INT 91
80858: PUSH
80859: LD_VAR 0 1
80863: PUSH
80864: LD_EXP 82
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: LIST
80873: PUSH
80874: LD_INT 50
80876: PUSH
80877: EMPTY
80878: LIST
80879: PUSH
80880: EMPTY
80881: LIST
80882: LIST
80883: LIST
80884: LIST
80885: PPUSH
80886: CALL_OW 69
80890: ST_TO_ADDR
// if not tmp then
80891: LD_VAR 0 2
80895: NOT
80896: IFFALSE 80900
// continue ;
80898: GO 80695
// HackLink ( i , tmp ) ;
80900: LD_VAR 0 1
80904: PPUSH
80905: LD_VAR 0 2
80909: PPUSH
80910: CALL 81057 0 2
// end ;
80914: GO 80695
80916: POP
80917: POP
// end ;
80918: PPOPN 2
80920: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
80921: LD_INT 0
80923: PPUSH
80924: PPUSH
80925: PPUSH
// if not hack in hackTanks then
80926: LD_VAR 0 1
80930: PUSH
80931: LD_EXP 79
80935: IN
80936: NOT
80937: IFFALSE 80941
// exit ;
80939: GO 81052
// index := GetElementIndex ( hackTanks , hack ) ;
80941: LD_ADDR_VAR 0 4
80945: PUSH
80946: LD_EXP 79
80950: PPUSH
80951: LD_VAR 0 1
80955: PPUSH
80956: CALL 9212 0 2
80960: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
80961: LD_EXP 80
80965: PUSH
80966: LD_VAR 0 4
80970: ARRAY
80971: IFFALSE 81052
// begin for i in hackTanksCaptured [ index ] do
80973: LD_ADDR_VAR 0 3
80977: PUSH
80978: LD_EXP 80
80982: PUSH
80983: LD_VAR 0 4
80987: ARRAY
80988: PUSH
80989: FOR_IN
80990: IFFALSE 81016
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
80992: LD_VAR 0 3
80996: PUSH
80997: LD_INT 1
80999: ARRAY
81000: PPUSH
81001: LD_VAR 0 3
81005: PUSH
81006: LD_INT 2
81008: ARRAY
81009: PPUSH
81010: CALL_OW 235
81014: GO 80989
81016: POP
81017: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
81018: LD_ADDR_EXP 80
81022: PUSH
81023: LD_EXP 80
81027: PPUSH
81028: LD_VAR 0 4
81032: PPUSH
81033: EMPTY
81034: PPUSH
81035: CALL_OW 1
81039: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
81040: LD_VAR 0 1
81044: PPUSH
81045: LD_INT 0
81047: PPUSH
81048: CALL_OW 505
// end ; end ;
81052: LD_VAR 0 2
81056: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
81057: LD_INT 0
81059: PPUSH
81060: PPUSH
81061: PPUSH
// if not hack in hackTanks or not vehicles then
81062: LD_VAR 0 1
81066: PUSH
81067: LD_EXP 79
81071: IN
81072: NOT
81073: PUSH
81074: LD_VAR 0 2
81078: NOT
81079: OR
81080: IFFALSE 81084
// exit ;
81082: GO 81359
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
81084: LD_ADDR_VAR 0 2
81088: PUSH
81089: LD_VAR 0 1
81093: PPUSH
81094: LD_VAR 0 2
81098: PPUSH
81099: LD_INT 1
81101: PPUSH
81102: LD_INT 1
81104: PPUSH
81105: CALL 9862 0 4
81109: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
81110: LD_ADDR_VAR 0 5
81114: PUSH
81115: LD_EXP 79
81119: PPUSH
81120: LD_VAR 0 1
81124: PPUSH
81125: CALL 9212 0 2
81129: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
81130: LD_EXP 80
81134: PUSH
81135: LD_VAR 0 5
81139: ARRAY
81140: PUSH
81141: LD_EXP 81
81145: LESS
81146: IFFALSE 81335
// begin for i := 1 to vehicles do
81148: LD_ADDR_VAR 0 4
81152: PUSH
81153: DOUBLE
81154: LD_INT 1
81156: DEC
81157: ST_TO_ADDR
81158: LD_VAR 0 2
81162: PUSH
81163: FOR_TO
81164: IFFALSE 81333
// begin if hackTanksCaptured [ index ] = hackLimit then
81166: LD_EXP 80
81170: PUSH
81171: LD_VAR 0 5
81175: ARRAY
81176: PUSH
81177: LD_EXP 81
81181: EQUAL
81182: IFFALSE 81186
// break ;
81184: GO 81333
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
81186: LD_ADDR_EXP 83
81190: PUSH
81191: LD_EXP 83
81195: PPUSH
81196: LD_VAR 0 5
81200: PPUSH
81201: LD_EXP 83
81205: PUSH
81206: LD_VAR 0 5
81210: ARRAY
81211: PUSH
81212: LD_INT 1
81214: PLUS
81215: PPUSH
81216: CALL_OW 1
81220: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
81221: LD_ADDR_EXP 80
81225: PUSH
81226: LD_EXP 80
81230: PPUSH
81231: LD_VAR 0 5
81235: PUSH
81236: LD_EXP 80
81240: PUSH
81241: LD_VAR 0 5
81245: ARRAY
81246: PUSH
81247: LD_INT 1
81249: PLUS
81250: PUSH
81251: EMPTY
81252: LIST
81253: LIST
81254: PPUSH
81255: LD_VAR 0 2
81259: PUSH
81260: LD_VAR 0 4
81264: ARRAY
81265: PUSH
81266: LD_VAR 0 2
81270: PUSH
81271: LD_VAR 0 4
81275: ARRAY
81276: PPUSH
81277: CALL_OW 255
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PPUSH
81286: CALL 9427 0 3
81290: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
81291: LD_VAR 0 2
81295: PUSH
81296: LD_VAR 0 4
81300: ARRAY
81301: PPUSH
81302: LD_VAR 0 1
81306: PPUSH
81307: CALL_OW 255
81311: PPUSH
81312: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
81316: LD_VAR 0 2
81320: PUSH
81321: LD_VAR 0 4
81325: ARRAY
81326: PPUSH
81327: CALL_OW 141
// end ;
81331: GO 81163
81333: POP
81334: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
81335: LD_VAR 0 1
81339: PPUSH
81340: LD_EXP 80
81344: PUSH
81345: LD_VAR 0 5
81349: ARRAY
81350: PUSH
81351: LD_INT 0
81353: PLUS
81354: PPUSH
81355: CALL_OW 505
// end ;
81359: LD_VAR 0 3
81363: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
81364: LD_INT 0
81366: PPUSH
81367: PPUSH
81368: PPUSH
81369: PPUSH
// if not hack in hackTanks then
81370: LD_VAR 0 1
81374: PUSH
81375: LD_EXP 79
81379: IN
81380: NOT
81381: IFFALSE 81385
// exit ;
81383: GO 81625
// index := GetElementIndex ( hackTanks , hack ) ;
81385: LD_ADDR_VAR 0 4
81389: PUSH
81390: LD_EXP 79
81394: PPUSH
81395: LD_VAR 0 1
81399: PPUSH
81400: CALL 9212 0 2
81404: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
81405: LD_ADDR_VAR 0 3
81409: PUSH
81410: DOUBLE
81411: LD_EXP 80
81415: PUSH
81416: LD_VAR 0 4
81420: ARRAY
81421: INC
81422: ST_TO_ADDR
81423: LD_INT 1
81425: PUSH
81426: FOR_DOWNTO
81427: IFFALSE 81599
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
81429: LD_ADDR_VAR 0 5
81433: PUSH
81434: LD_EXP 80
81438: PUSH
81439: LD_VAR 0 4
81443: ARRAY
81444: PUSH
81445: LD_VAR 0 3
81449: ARRAY
81450: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
81451: LD_VAR 0 5
81455: PUSH
81456: LD_INT 1
81458: ARRAY
81459: PPUSH
81460: CALL_OW 302
81464: NOT
81465: PUSH
81466: LD_VAR 0 5
81470: PUSH
81471: LD_INT 1
81473: ARRAY
81474: PPUSH
81475: CALL_OW 255
81479: PUSH
81480: LD_VAR 0 1
81484: PPUSH
81485: CALL_OW 255
81489: NONEQUAL
81490: OR
81491: IFFALSE 81597
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
81493: LD_VAR 0 5
81497: PUSH
81498: LD_INT 1
81500: ARRAY
81501: PPUSH
81502: CALL_OW 305
81506: PUSH
81507: LD_VAR 0 5
81511: PUSH
81512: LD_INT 1
81514: ARRAY
81515: PPUSH
81516: CALL_OW 255
81520: PUSH
81521: LD_VAR 0 1
81525: PPUSH
81526: CALL_OW 255
81530: EQUAL
81531: AND
81532: IFFALSE 81556
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
81534: LD_VAR 0 5
81538: PUSH
81539: LD_INT 1
81541: ARRAY
81542: PPUSH
81543: LD_VAR 0 5
81547: PUSH
81548: LD_INT 2
81550: ARRAY
81551: PPUSH
81552: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
81556: LD_ADDR_EXP 80
81560: PUSH
81561: LD_EXP 80
81565: PPUSH
81566: LD_VAR 0 4
81570: PPUSH
81571: LD_EXP 80
81575: PUSH
81576: LD_VAR 0 4
81580: ARRAY
81581: PPUSH
81582: LD_VAR 0 3
81586: PPUSH
81587: CALL_OW 3
81591: PPUSH
81592: CALL_OW 1
81596: ST_TO_ADDR
// end ; end ;
81597: GO 81426
81599: POP
81600: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
81601: LD_VAR 0 1
81605: PPUSH
81606: LD_EXP 80
81610: PUSH
81611: LD_VAR 0 4
81615: ARRAY
81616: PUSH
81617: LD_INT 0
81619: PLUS
81620: PPUSH
81621: CALL_OW 505
// end ;
81625: LD_VAR 0 2
81629: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
81630: LD_INT 0
81632: PPUSH
81633: PPUSH
81634: PPUSH
81635: PPUSH
// if not hack in hackTanks then
81636: LD_VAR 0 1
81640: PUSH
81641: LD_EXP 79
81645: IN
81646: NOT
81647: IFFALSE 81651
// exit ;
81649: GO 81736
// index := GetElementIndex ( hackTanks , hack ) ;
81651: LD_ADDR_VAR 0 5
81655: PUSH
81656: LD_EXP 79
81660: PPUSH
81661: LD_VAR 0 1
81665: PPUSH
81666: CALL 9212 0 2
81670: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
81671: LD_ADDR_VAR 0 4
81675: PUSH
81676: DOUBLE
81677: LD_INT 1
81679: DEC
81680: ST_TO_ADDR
81681: LD_EXP 80
81685: PUSH
81686: LD_VAR 0 5
81690: ARRAY
81691: PUSH
81692: FOR_TO
81693: IFFALSE 81734
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
81695: LD_EXP 80
81699: PUSH
81700: LD_VAR 0 5
81704: ARRAY
81705: PUSH
81706: LD_VAR 0 4
81710: ARRAY
81711: PUSH
81712: LD_INT 1
81714: ARRAY
81715: PUSH
81716: LD_VAR 0 2
81720: EQUAL
81721: IFFALSE 81732
// KillUnit ( vehicle ) ;
81723: LD_VAR 0 2
81727: PPUSH
81728: CALL_OW 66
81732: GO 81692
81734: POP
81735: POP
// end ;
81736: LD_VAR 0 3
81740: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
81741: LD_EXP 84
81745: NOT
81746: IFFALSE 81781
81748: GO 81750
81750: DISABLE
// begin initMiner := true ;
81751: LD_ADDR_EXP 84
81755: PUSH
81756: LD_INT 1
81758: ST_TO_ADDR
// minersList := [ ] ;
81759: LD_ADDR_EXP 85
81763: PUSH
81764: EMPTY
81765: ST_TO_ADDR
// minerMinesList := [ ] ;
81766: LD_ADDR_EXP 86
81770: PUSH
81771: EMPTY
81772: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
81773: LD_ADDR_EXP 87
81777: PUSH
81778: LD_INT 5
81780: ST_TO_ADDR
// end ;
81781: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
81782: LD_EXP 84
81786: PUSH
81787: LD_INT 34
81789: PUSH
81790: LD_EXP 65
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PPUSH
81799: CALL_OW 69
81803: AND
81804: IFFALSE 82267
81806: GO 81808
81808: DISABLE
81809: LD_INT 0
81811: PPUSH
81812: PPUSH
81813: PPUSH
81814: PPUSH
// begin enable ;
81815: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
81816: LD_ADDR_VAR 0 1
81820: PUSH
81821: LD_INT 34
81823: PUSH
81824: LD_EXP 65
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: PPUSH
81833: CALL_OW 69
81837: PUSH
81838: FOR_IN
81839: IFFALSE 81911
// begin if not i in minersList then
81841: LD_VAR 0 1
81845: PUSH
81846: LD_EXP 85
81850: IN
81851: NOT
81852: IFFALSE 81909
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
81854: LD_ADDR_EXP 85
81858: PUSH
81859: LD_EXP 85
81863: PPUSH
81864: LD_EXP 85
81868: PUSH
81869: LD_INT 1
81871: PLUS
81872: PPUSH
81873: LD_VAR 0 1
81877: PPUSH
81878: CALL_OW 1
81882: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
81883: LD_ADDR_EXP 86
81887: PUSH
81888: LD_EXP 86
81892: PPUSH
81893: LD_EXP 86
81897: PUSH
81898: LD_INT 1
81900: PLUS
81901: PPUSH
81902: EMPTY
81903: PPUSH
81904: CALL_OW 1
81908: ST_TO_ADDR
// end end ;
81909: GO 81838
81911: POP
81912: POP
// for i := minerMinesList downto 1 do
81913: LD_ADDR_VAR 0 1
81917: PUSH
81918: DOUBLE
81919: LD_EXP 86
81923: INC
81924: ST_TO_ADDR
81925: LD_INT 1
81927: PUSH
81928: FOR_DOWNTO
81929: IFFALSE 82265
// begin if IsLive ( minersList [ i ] ) then
81931: LD_EXP 85
81935: PUSH
81936: LD_VAR 0 1
81940: ARRAY
81941: PPUSH
81942: CALL_OW 300
81946: IFFALSE 81974
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
81948: LD_EXP 85
81952: PUSH
81953: LD_VAR 0 1
81957: ARRAY
81958: PPUSH
81959: LD_EXP 86
81963: PUSH
81964: LD_VAR 0 1
81968: ARRAY
81969: PPUSH
81970: CALL_OW 505
// if not minerMinesList [ i ] then
81974: LD_EXP 86
81978: PUSH
81979: LD_VAR 0 1
81983: ARRAY
81984: NOT
81985: IFFALSE 81989
// continue ;
81987: GO 81928
// for j := minerMinesList [ i ] downto 1 do
81989: LD_ADDR_VAR 0 2
81993: PUSH
81994: DOUBLE
81995: LD_EXP 86
81999: PUSH
82000: LD_VAR 0 1
82004: ARRAY
82005: INC
82006: ST_TO_ADDR
82007: LD_INT 1
82009: PUSH
82010: FOR_DOWNTO
82011: IFFALSE 82261
// begin side := GetSide ( minersList [ i ] ) ;
82013: LD_ADDR_VAR 0 3
82017: PUSH
82018: LD_EXP 85
82022: PUSH
82023: LD_VAR 0 1
82027: ARRAY
82028: PPUSH
82029: CALL_OW 255
82033: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
82034: LD_ADDR_VAR 0 4
82038: PUSH
82039: LD_EXP 86
82043: PUSH
82044: LD_VAR 0 1
82048: ARRAY
82049: PUSH
82050: LD_VAR 0 2
82054: ARRAY
82055: PUSH
82056: LD_INT 1
82058: ARRAY
82059: PPUSH
82060: LD_EXP 86
82064: PUSH
82065: LD_VAR 0 1
82069: ARRAY
82070: PUSH
82071: LD_VAR 0 2
82075: ARRAY
82076: PUSH
82077: LD_INT 2
82079: ARRAY
82080: PPUSH
82081: CALL_OW 428
82085: ST_TO_ADDR
// if not tmp then
82086: LD_VAR 0 4
82090: NOT
82091: IFFALSE 82095
// continue ;
82093: GO 82010
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
82095: LD_VAR 0 4
82099: PUSH
82100: LD_INT 81
82102: PUSH
82103: LD_VAR 0 3
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PPUSH
82112: CALL_OW 69
82116: IN
82117: PUSH
82118: LD_EXP 86
82122: PUSH
82123: LD_VAR 0 1
82127: ARRAY
82128: PUSH
82129: LD_VAR 0 2
82133: ARRAY
82134: PUSH
82135: LD_INT 1
82137: ARRAY
82138: PPUSH
82139: LD_EXP 86
82143: PUSH
82144: LD_VAR 0 1
82148: ARRAY
82149: PUSH
82150: LD_VAR 0 2
82154: ARRAY
82155: PUSH
82156: LD_INT 2
82158: ARRAY
82159: PPUSH
82160: CALL_OW 458
82164: AND
82165: IFFALSE 82259
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
82167: LD_EXP 86
82171: PUSH
82172: LD_VAR 0 1
82176: ARRAY
82177: PUSH
82178: LD_VAR 0 2
82182: ARRAY
82183: PUSH
82184: LD_INT 1
82186: ARRAY
82187: PPUSH
82188: LD_EXP 86
82192: PUSH
82193: LD_VAR 0 1
82197: ARRAY
82198: PUSH
82199: LD_VAR 0 2
82203: ARRAY
82204: PUSH
82205: LD_INT 2
82207: ARRAY
82208: PPUSH
82209: LD_VAR 0 3
82213: PPUSH
82214: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
82218: LD_ADDR_EXP 86
82222: PUSH
82223: LD_EXP 86
82227: PPUSH
82228: LD_VAR 0 1
82232: PPUSH
82233: LD_EXP 86
82237: PUSH
82238: LD_VAR 0 1
82242: ARRAY
82243: PPUSH
82244: LD_VAR 0 2
82248: PPUSH
82249: CALL_OW 3
82253: PPUSH
82254: CALL_OW 1
82258: ST_TO_ADDR
// end ; end ;
82259: GO 82010
82261: POP
82262: POP
// end ;
82263: GO 81928
82265: POP
82266: POP
// end ;
82267: PPOPN 4
82269: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
82270: LD_INT 0
82272: PPUSH
82273: PPUSH
// result := false ;
82274: LD_ADDR_VAR 0 4
82278: PUSH
82279: LD_INT 0
82281: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
82282: LD_VAR 0 1
82286: PPUSH
82287: CALL_OW 264
82291: PUSH
82292: LD_EXP 65
82296: EQUAL
82297: NOT
82298: IFFALSE 82302
// exit ;
82300: GO 82542
// index := GetElementIndex ( minersList , unit ) ;
82302: LD_ADDR_VAR 0 5
82306: PUSH
82307: LD_EXP 85
82311: PPUSH
82312: LD_VAR 0 1
82316: PPUSH
82317: CALL 9212 0 2
82321: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
82322: LD_EXP 86
82326: PUSH
82327: LD_VAR 0 5
82331: ARRAY
82332: PUSH
82333: LD_EXP 87
82337: GREATEREQUAL
82338: IFFALSE 82342
// exit ;
82340: GO 82542
// ComMoveXY ( unit , x , y ) ;
82342: LD_VAR 0 1
82346: PPUSH
82347: LD_VAR 0 2
82351: PPUSH
82352: LD_VAR 0 3
82356: PPUSH
82357: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
82361: LD_INT 35
82363: PPUSH
82364: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
82368: LD_VAR 0 1
82372: PPUSH
82373: LD_VAR 0 2
82377: PPUSH
82378: LD_VAR 0 3
82382: PPUSH
82383: CALL 39609 0 3
82387: NOT
82388: PUSH
82389: LD_VAR 0 1
82393: PPUSH
82394: CALL_OW 314
82398: AND
82399: IFFALSE 82403
// exit ;
82401: GO 82542
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
82403: LD_VAR 0 2
82407: PPUSH
82408: LD_VAR 0 3
82412: PPUSH
82413: CALL_OW 428
82417: PUSH
82418: LD_VAR 0 1
82422: EQUAL
82423: PUSH
82424: LD_VAR 0 1
82428: PPUSH
82429: CALL_OW 314
82433: NOT
82434: AND
82435: IFFALSE 82361
// PlaySoundXY ( x , y , PlantMine ) ;
82437: LD_VAR 0 2
82441: PPUSH
82442: LD_VAR 0 3
82446: PPUSH
82447: LD_STRING PlantMine
82449: PPUSH
82450: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
82454: LD_VAR 0 2
82458: PPUSH
82459: LD_VAR 0 3
82463: PPUSH
82464: LD_VAR 0 1
82468: PPUSH
82469: CALL_OW 255
82473: PPUSH
82474: LD_INT 0
82476: PPUSH
82477: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
82481: LD_ADDR_EXP 86
82485: PUSH
82486: LD_EXP 86
82490: PPUSH
82491: LD_VAR 0 5
82495: PUSH
82496: LD_EXP 86
82500: PUSH
82501: LD_VAR 0 5
82505: ARRAY
82506: PUSH
82507: LD_INT 1
82509: PLUS
82510: PUSH
82511: EMPTY
82512: LIST
82513: LIST
82514: PPUSH
82515: LD_VAR 0 2
82519: PUSH
82520: LD_VAR 0 3
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PPUSH
82529: CALL 9427 0 3
82533: ST_TO_ADDR
// result := true ;
82534: LD_ADDR_VAR 0 4
82538: PUSH
82539: LD_INT 1
82541: ST_TO_ADDR
// end ;
82542: LD_VAR 0 4
82546: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
82547: LD_INT 0
82549: PPUSH
82550: PPUSH
82551: PPUSH
// if not unit in minersList then
82552: LD_VAR 0 1
82556: PUSH
82557: LD_EXP 85
82561: IN
82562: NOT
82563: IFFALSE 82567
// exit ;
82565: GO 82959
// index := GetElementIndex ( minersList , unit ) ;
82567: LD_ADDR_VAR 0 6
82571: PUSH
82572: LD_EXP 85
82576: PPUSH
82577: LD_VAR 0 1
82581: PPUSH
82582: CALL 9212 0 2
82586: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
82587: LD_ADDR_VAR 0 5
82591: PUSH
82592: DOUBLE
82593: LD_EXP 86
82597: PUSH
82598: LD_VAR 0 6
82602: ARRAY
82603: INC
82604: ST_TO_ADDR
82605: LD_INT 1
82607: PUSH
82608: FOR_DOWNTO
82609: IFFALSE 82770
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
82611: LD_EXP 86
82615: PUSH
82616: LD_VAR 0 6
82620: ARRAY
82621: PUSH
82622: LD_VAR 0 5
82626: ARRAY
82627: PUSH
82628: LD_INT 1
82630: ARRAY
82631: PUSH
82632: LD_VAR 0 2
82636: EQUAL
82637: PUSH
82638: LD_EXP 86
82642: PUSH
82643: LD_VAR 0 6
82647: ARRAY
82648: PUSH
82649: LD_VAR 0 5
82653: ARRAY
82654: PUSH
82655: LD_INT 2
82657: ARRAY
82658: PUSH
82659: LD_VAR 0 3
82663: EQUAL
82664: AND
82665: IFFALSE 82768
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
82667: LD_EXP 86
82671: PUSH
82672: LD_VAR 0 6
82676: ARRAY
82677: PUSH
82678: LD_VAR 0 5
82682: ARRAY
82683: PUSH
82684: LD_INT 1
82686: ARRAY
82687: PPUSH
82688: LD_EXP 86
82692: PUSH
82693: LD_VAR 0 6
82697: ARRAY
82698: PUSH
82699: LD_VAR 0 5
82703: ARRAY
82704: PUSH
82705: LD_INT 2
82707: ARRAY
82708: PPUSH
82709: LD_VAR 0 1
82713: PPUSH
82714: CALL_OW 255
82718: PPUSH
82719: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
82723: LD_ADDR_EXP 86
82727: PUSH
82728: LD_EXP 86
82732: PPUSH
82733: LD_VAR 0 6
82737: PPUSH
82738: LD_EXP 86
82742: PUSH
82743: LD_VAR 0 6
82747: ARRAY
82748: PPUSH
82749: LD_VAR 0 5
82753: PPUSH
82754: CALL_OW 3
82758: PPUSH
82759: CALL_OW 1
82763: ST_TO_ADDR
// exit ;
82764: POP
82765: POP
82766: GO 82959
// end ; end ;
82768: GO 82608
82770: POP
82771: POP
// for i := minerMinesList [ index ] downto 1 do
82772: LD_ADDR_VAR 0 5
82776: PUSH
82777: DOUBLE
82778: LD_EXP 86
82782: PUSH
82783: LD_VAR 0 6
82787: ARRAY
82788: INC
82789: ST_TO_ADDR
82790: LD_INT 1
82792: PUSH
82793: FOR_DOWNTO
82794: IFFALSE 82957
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
82796: LD_EXP 86
82800: PUSH
82801: LD_VAR 0 6
82805: ARRAY
82806: PUSH
82807: LD_VAR 0 5
82811: ARRAY
82812: PUSH
82813: LD_INT 1
82815: ARRAY
82816: PPUSH
82817: LD_EXP 86
82821: PUSH
82822: LD_VAR 0 6
82826: ARRAY
82827: PUSH
82828: LD_VAR 0 5
82832: ARRAY
82833: PUSH
82834: LD_INT 2
82836: ARRAY
82837: PPUSH
82838: LD_VAR 0 2
82842: PPUSH
82843: LD_VAR 0 3
82847: PPUSH
82848: CALL_OW 298
82852: PUSH
82853: LD_INT 6
82855: LESS
82856: IFFALSE 82955
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
82858: LD_EXP 86
82862: PUSH
82863: LD_VAR 0 6
82867: ARRAY
82868: PUSH
82869: LD_VAR 0 5
82873: ARRAY
82874: PUSH
82875: LD_INT 1
82877: ARRAY
82878: PPUSH
82879: LD_EXP 86
82883: PUSH
82884: LD_VAR 0 6
82888: ARRAY
82889: PUSH
82890: LD_VAR 0 5
82894: ARRAY
82895: PUSH
82896: LD_INT 2
82898: ARRAY
82899: PPUSH
82900: LD_VAR 0 1
82904: PPUSH
82905: CALL_OW 255
82909: PPUSH
82910: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
82914: LD_ADDR_EXP 86
82918: PUSH
82919: LD_EXP 86
82923: PPUSH
82924: LD_VAR 0 6
82928: PPUSH
82929: LD_EXP 86
82933: PUSH
82934: LD_VAR 0 6
82938: ARRAY
82939: PPUSH
82940: LD_VAR 0 5
82944: PPUSH
82945: CALL_OW 3
82949: PPUSH
82950: CALL_OW 1
82954: ST_TO_ADDR
// end ; end ;
82955: GO 82793
82957: POP
82958: POP
// end ;
82959: LD_VAR 0 4
82963: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
82964: LD_INT 0
82966: PPUSH
82967: PPUSH
82968: PPUSH
82969: PPUSH
82970: PPUSH
82971: PPUSH
82972: PPUSH
82973: PPUSH
82974: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
82975: LD_VAR 0 1
82979: PPUSH
82980: CALL_OW 264
82984: PUSH
82985: LD_EXP 65
82989: EQUAL
82990: NOT
82991: PUSH
82992: LD_VAR 0 1
82996: PUSH
82997: LD_EXP 85
83001: IN
83002: NOT
83003: OR
83004: IFFALSE 83008
// exit ;
83006: GO 83330
// index := GetElementIndex ( minersList , unit ) ;
83008: LD_ADDR_VAR 0 6
83012: PUSH
83013: LD_EXP 85
83017: PPUSH
83018: LD_VAR 0 1
83022: PPUSH
83023: CALL 9212 0 2
83027: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
83028: LD_ADDR_VAR 0 8
83032: PUSH
83033: LD_EXP 87
83037: PUSH
83038: LD_EXP 86
83042: PUSH
83043: LD_VAR 0 6
83047: ARRAY
83048: MINUS
83049: ST_TO_ADDR
// if not minesFreeAmount then
83050: LD_VAR 0 8
83054: NOT
83055: IFFALSE 83059
// exit ;
83057: GO 83330
// tmp := [ ] ;
83059: LD_ADDR_VAR 0 7
83063: PUSH
83064: EMPTY
83065: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
83066: LD_ADDR_VAR 0 5
83070: PUSH
83071: DOUBLE
83072: LD_INT 1
83074: DEC
83075: ST_TO_ADDR
83076: LD_VAR 0 8
83080: PUSH
83081: FOR_TO
83082: IFFALSE 83277
// begin _d := rand ( 0 , 5 ) ;
83084: LD_ADDR_VAR 0 11
83088: PUSH
83089: LD_INT 0
83091: PPUSH
83092: LD_INT 5
83094: PPUSH
83095: CALL_OW 12
83099: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
83100: LD_ADDR_VAR 0 12
83104: PUSH
83105: LD_INT 2
83107: PPUSH
83108: LD_INT 6
83110: PPUSH
83111: CALL_OW 12
83115: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
83116: LD_ADDR_VAR 0 9
83120: PUSH
83121: LD_VAR 0 2
83125: PPUSH
83126: LD_VAR 0 11
83130: PPUSH
83131: LD_VAR 0 12
83135: PPUSH
83136: CALL_OW 272
83140: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
83141: LD_ADDR_VAR 0 10
83145: PUSH
83146: LD_VAR 0 3
83150: PPUSH
83151: LD_VAR 0 11
83155: PPUSH
83156: LD_VAR 0 12
83160: PPUSH
83161: CALL_OW 273
83165: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
83166: LD_VAR 0 9
83170: PPUSH
83171: LD_VAR 0 10
83175: PPUSH
83176: CALL_OW 488
83180: PUSH
83181: LD_VAR 0 9
83185: PUSH
83186: LD_VAR 0 10
83190: PUSH
83191: EMPTY
83192: LIST
83193: LIST
83194: PUSH
83195: LD_VAR 0 7
83199: IN
83200: NOT
83201: AND
83202: PUSH
83203: LD_VAR 0 9
83207: PPUSH
83208: LD_VAR 0 10
83212: PPUSH
83213: CALL_OW 458
83217: NOT
83218: AND
83219: IFFALSE 83261
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
83221: LD_ADDR_VAR 0 7
83225: PUSH
83226: LD_VAR 0 7
83230: PPUSH
83231: LD_VAR 0 7
83235: PUSH
83236: LD_INT 1
83238: PLUS
83239: PPUSH
83240: LD_VAR 0 9
83244: PUSH
83245: LD_VAR 0 10
83249: PUSH
83250: EMPTY
83251: LIST
83252: LIST
83253: PPUSH
83254: CALL_OW 1
83258: ST_TO_ADDR
83259: GO 83275
// i := i - 1 ;
83261: LD_ADDR_VAR 0 5
83265: PUSH
83266: LD_VAR 0 5
83270: PUSH
83271: LD_INT 1
83273: MINUS
83274: ST_TO_ADDR
// end ;
83275: GO 83081
83277: POP
83278: POP
// for i in tmp do
83279: LD_ADDR_VAR 0 5
83283: PUSH
83284: LD_VAR 0 7
83288: PUSH
83289: FOR_IN
83290: IFFALSE 83328
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
83292: LD_VAR 0 1
83296: PPUSH
83297: LD_VAR 0 5
83301: PUSH
83302: LD_INT 1
83304: ARRAY
83305: PPUSH
83306: LD_VAR 0 5
83310: PUSH
83311: LD_INT 2
83313: ARRAY
83314: PPUSH
83315: CALL 82270 0 3
83319: NOT
83320: IFFALSE 83326
// exit ;
83322: POP
83323: POP
83324: GO 83330
83326: GO 83289
83328: POP
83329: POP
// end ;
83330: LD_VAR 0 4
83334: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
83335: LD_INT 0
83337: PPUSH
83338: PPUSH
83339: PPUSH
83340: PPUSH
83341: PPUSH
83342: PPUSH
83343: PPUSH
// if not GetClass ( unit ) = class_sniper then
83344: LD_VAR 0 1
83348: PPUSH
83349: CALL_OW 257
83353: PUSH
83354: LD_INT 5
83356: EQUAL
83357: NOT
83358: IFFALSE 83362
// exit ;
83360: GO 83750
// dist := 8 ;
83362: LD_ADDR_VAR 0 5
83366: PUSH
83367: LD_INT 8
83369: ST_TO_ADDR
// viewRange := 12 ;
83370: LD_ADDR_VAR 0 7
83374: PUSH
83375: LD_INT 12
83377: ST_TO_ADDR
// side := GetSide ( unit ) ;
83378: LD_ADDR_VAR 0 6
83382: PUSH
83383: LD_VAR 0 1
83387: PPUSH
83388: CALL_OW 255
83392: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
83393: LD_INT 61
83395: PPUSH
83396: LD_VAR 0 6
83400: PPUSH
83401: CALL_OW 321
83405: PUSH
83406: LD_INT 2
83408: EQUAL
83409: IFFALSE 83419
// viewRange := 16 ;
83411: LD_ADDR_VAR 0 7
83415: PUSH
83416: LD_INT 16
83418: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
83419: LD_VAR 0 1
83423: PPUSH
83424: LD_VAR 0 2
83428: PPUSH
83429: LD_VAR 0 3
83433: PPUSH
83434: CALL_OW 297
83438: PUSH
83439: LD_VAR 0 5
83443: GREATER
83444: IFFALSE 83523
// begin ComMoveXY ( unit , x , y ) ;
83446: LD_VAR 0 1
83450: PPUSH
83451: LD_VAR 0 2
83455: PPUSH
83456: LD_VAR 0 3
83460: PPUSH
83461: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
83465: LD_INT 35
83467: PPUSH
83468: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
83472: LD_VAR 0 1
83476: PPUSH
83477: LD_VAR 0 2
83481: PPUSH
83482: LD_VAR 0 3
83486: PPUSH
83487: CALL 39609 0 3
83491: NOT
83492: IFFALSE 83496
// exit ;
83494: GO 83750
// until GetDistUnitXY ( unit , x , y ) < dist ;
83496: LD_VAR 0 1
83500: PPUSH
83501: LD_VAR 0 2
83505: PPUSH
83506: LD_VAR 0 3
83510: PPUSH
83511: CALL_OW 297
83515: PUSH
83516: LD_VAR 0 5
83520: LESS
83521: IFFALSE 83465
// end ; ComTurnXY ( unit , x , y ) ;
83523: LD_VAR 0 1
83527: PPUSH
83528: LD_VAR 0 2
83532: PPUSH
83533: LD_VAR 0 3
83537: PPUSH
83538: CALL_OW 118
// wait ( 5 ) ;
83542: LD_INT 5
83544: PPUSH
83545: CALL_OW 67
// _d := GetDir ( unit ) ;
83549: LD_ADDR_VAR 0 10
83553: PUSH
83554: LD_VAR 0 1
83558: PPUSH
83559: CALL_OW 254
83563: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
83564: LD_ADDR_VAR 0 8
83568: PUSH
83569: LD_VAR 0 1
83573: PPUSH
83574: CALL_OW 250
83578: PPUSH
83579: LD_VAR 0 10
83583: PPUSH
83584: LD_VAR 0 5
83588: PPUSH
83589: CALL_OW 272
83593: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
83594: LD_ADDR_VAR 0 9
83598: PUSH
83599: LD_VAR 0 1
83603: PPUSH
83604: CALL_OW 251
83608: PPUSH
83609: LD_VAR 0 10
83613: PPUSH
83614: LD_VAR 0 5
83618: PPUSH
83619: CALL_OW 273
83623: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
83624: LD_VAR 0 8
83628: PPUSH
83629: LD_VAR 0 9
83633: PPUSH
83634: CALL_OW 488
83638: NOT
83639: IFFALSE 83643
// exit ;
83641: GO 83750
// ComAnimCustom ( unit , 1 ) ;
83643: LD_VAR 0 1
83647: PPUSH
83648: LD_INT 1
83650: PPUSH
83651: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
83655: LD_VAR 0 8
83659: PPUSH
83660: LD_VAR 0 9
83664: PPUSH
83665: LD_VAR 0 6
83669: PPUSH
83670: LD_VAR 0 7
83674: PPUSH
83675: CALL_OW 330
// repeat wait ( 1 ) ;
83679: LD_INT 1
83681: PPUSH
83682: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
83686: LD_VAR 0 1
83690: PPUSH
83691: CALL_OW 316
83695: PUSH
83696: LD_VAR 0 1
83700: PPUSH
83701: CALL_OW 314
83705: OR
83706: PUSH
83707: LD_VAR 0 1
83711: PPUSH
83712: CALL_OW 302
83716: NOT
83717: OR
83718: PUSH
83719: LD_VAR 0 1
83723: PPUSH
83724: CALL_OW 301
83728: OR
83729: IFFALSE 83679
// RemoveSeeing ( _x , _y , side ) ;
83731: LD_VAR 0 8
83735: PPUSH
83736: LD_VAR 0 9
83740: PPUSH
83741: LD_VAR 0 6
83745: PPUSH
83746: CALL_OW 331
// end ; end_of_file end_of_file
83750: LD_VAR 0 4
83754: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
83755: LD_VAR 0 1
83759: PUSH
83760: LD_INT 200
83762: DOUBLE
83763: GREATEREQUAL
83764: IFFALSE 83772
83766: LD_INT 299
83768: DOUBLE
83769: LESSEQUAL
83770: IFTRUE 83774
83772: GO 83806
83774: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
83775: LD_VAR 0 1
83779: PPUSH
83780: LD_VAR 0 2
83784: PPUSH
83785: LD_VAR 0 3
83789: PPUSH
83790: LD_VAR 0 4
83794: PPUSH
83795: LD_VAR 0 5
83799: PPUSH
83800: CALL 79872 0 5
83804: GO 83883
83806: LD_INT 300
83808: DOUBLE
83809: GREATEREQUAL
83810: IFFALSE 83818
83812: LD_INT 399
83814: DOUBLE
83815: LESSEQUAL
83816: IFTRUE 83820
83818: GO 83882
83820: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
83821: LD_VAR 0 1
83825: PPUSH
83826: LD_VAR 0 2
83830: PPUSH
83831: LD_VAR 0 3
83835: PPUSH
83836: LD_VAR 0 4
83840: PPUSH
83841: LD_VAR 0 5
83845: PPUSH
83846: LD_VAR 0 6
83850: PPUSH
83851: LD_VAR 0 7
83855: PPUSH
83856: LD_VAR 0 8
83860: PPUSH
83861: LD_VAR 0 9
83865: PPUSH
83866: LD_VAR 0 10
83870: PPUSH
83871: LD_VAR 0 11
83875: PPUSH
83876: CALL 95110 0 11
83880: GO 83883
83882: POP
// end ;
83883: PPOPN 11
83885: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
83886: LD_VAR 0 1
83890: PPUSH
83891: LD_VAR 0 2
83895: PPUSH
83896: LD_VAR 0 3
83900: PPUSH
83901: LD_VAR 0 4
83905: PPUSH
83906: LD_VAR 0 5
83910: PPUSH
83911: CALL 79854 0 5
// end ; end_of_file
83915: PPOPN 5
83917: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
83918: LD_INT 0
83920: PPUSH
// if p2 = 100 then
83921: LD_VAR 0 2
83925: PUSH
83926: LD_INT 100
83928: EQUAL
83929: IFFALSE 84878
// begin if not StreamModeActive then
83931: LD_EXP 88
83935: NOT
83936: IFFALSE 83946
// StreamModeActive := true ;
83938: LD_ADDR_EXP 88
83942: PUSH
83943: LD_INT 1
83945: ST_TO_ADDR
// if p3 = 0 then
83946: LD_VAR 0 3
83950: PUSH
83951: LD_INT 0
83953: EQUAL
83954: IFFALSE 83960
// InitStreamMode ;
83956: CALL 85038 0 0
// if p3 = 1 then
83960: LD_VAR 0 3
83964: PUSH
83965: LD_INT 1
83967: EQUAL
83968: IFFALSE 83978
// sRocket := true ;
83970: LD_ADDR_EXP 93
83974: PUSH
83975: LD_INT 1
83977: ST_TO_ADDR
// if p3 = 2 then
83978: LD_VAR 0 3
83982: PUSH
83983: LD_INT 2
83985: EQUAL
83986: IFFALSE 83996
// sSpeed := true ;
83988: LD_ADDR_EXP 92
83992: PUSH
83993: LD_INT 1
83995: ST_TO_ADDR
// if p3 = 3 then
83996: LD_VAR 0 3
84000: PUSH
84001: LD_INT 3
84003: EQUAL
84004: IFFALSE 84014
// sEngine := true ;
84006: LD_ADDR_EXP 94
84010: PUSH
84011: LD_INT 1
84013: ST_TO_ADDR
// if p3 = 4 then
84014: LD_VAR 0 3
84018: PUSH
84019: LD_INT 4
84021: EQUAL
84022: IFFALSE 84032
// sSpec := true ;
84024: LD_ADDR_EXP 91
84028: PUSH
84029: LD_INT 1
84031: ST_TO_ADDR
// if p3 = 5 then
84032: LD_VAR 0 3
84036: PUSH
84037: LD_INT 5
84039: EQUAL
84040: IFFALSE 84050
// sLevel := true ;
84042: LD_ADDR_EXP 95
84046: PUSH
84047: LD_INT 1
84049: ST_TO_ADDR
// if p3 = 6 then
84050: LD_VAR 0 3
84054: PUSH
84055: LD_INT 6
84057: EQUAL
84058: IFFALSE 84068
// sArmoury := true ;
84060: LD_ADDR_EXP 96
84064: PUSH
84065: LD_INT 1
84067: ST_TO_ADDR
// if p3 = 7 then
84068: LD_VAR 0 3
84072: PUSH
84073: LD_INT 7
84075: EQUAL
84076: IFFALSE 84086
// sRadar := true ;
84078: LD_ADDR_EXP 97
84082: PUSH
84083: LD_INT 1
84085: ST_TO_ADDR
// if p3 = 8 then
84086: LD_VAR 0 3
84090: PUSH
84091: LD_INT 8
84093: EQUAL
84094: IFFALSE 84104
// sBunker := true ;
84096: LD_ADDR_EXP 98
84100: PUSH
84101: LD_INT 1
84103: ST_TO_ADDR
// if p3 = 9 then
84104: LD_VAR 0 3
84108: PUSH
84109: LD_INT 9
84111: EQUAL
84112: IFFALSE 84122
// sHack := true ;
84114: LD_ADDR_EXP 99
84118: PUSH
84119: LD_INT 1
84121: ST_TO_ADDR
// if p3 = 10 then
84122: LD_VAR 0 3
84126: PUSH
84127: LD_INT 10
84129: EQUAL
84130: IFFALSE 84140
// sFire := true ;
84132: LD_ADDR_EXP 100
84136: PUSH
84137: LD_INT 1
84139: ST_TO_ADDR
// if p3 = 11 then
84140: LD_VAR 0 3
84144: PUSH
84145: LD_INT 11
84147: EQUAL
84148: IFFALSE 84158
// sRefresh := true ;
84150: LD_ADDR_EXP 101
84154: PUSH
84155: LD_INT 1
84157: ST_TO_ADDR
// if p3 = 12 then
84158: LD_VAR 0 3
84162: PUSH
84163: LD_INT 12
84165: EQUAL
84166: IFFALSE 84176
// sExp := true ;
84168: LD_ADDR_EXP 102
84172: PUSH
84173: LD_INT 1
84175: ST_TO_ADDR
// if p3 = 13 then
84176: LD_VAR 0 3
84180: PUSH
84181: LD_INT 13
84183: EQUAL
84184: IFFALSE 84194
// sDepot := true ;
84186: LD_ADDR_EXP 103
84190: PUSH
84191: LD_INT 1
84193: ST_TO_ADDR
// if p3 = 14 then
84194: LD_VAR 0 3
84198: PUSH
84199: LD_INT 14
84201: EQUAL
84202: IFFALSE 84212
// sFlag := true ;
84204: LD_ADDR_EXP 104
84208: PUSH
84209: LD_INT 1
84211: ST_TO_ADDR
// if p3 = 15 then
84212: LD_VAR 0 3
84216: PUSH
84217: LD_INT 15
84219: EQUAL
84220: IFFALSE 84230
// sKamikadze := true ;
84222: LD_ADDR_EXP 112
84226: PUSH
84227: LD_INT 1
84229: ST_TO_ADDR
// if p3 = 16 then
84230: LD_VAR 0 3
84234: PUSH
84235: LD_INT 16
84237: EQUAL
84238: IFFALSE 84248
// sTroll := true ;
84240: LD_ADDR_EXP 113
84244: PUSH
84245: LD_INT 1
84247: ST_TO_ADDR
// if p3 = 17 then
84248: LD_VAR 0 3
84252: PUSH
84253: LD_INT 17
84255: EQUAL
84256: IFFALSE 84266
// sSlow := true ;
84258: LD_ADDR_EXP 114
84262: PUSH
84263: LD_INT 1
84265: ST_TO_ADDR
// if p3 = 18 then
84266: LD_VAR 0 3
84270: PUSH
84271: LD_INT 18
84273: EQUAL
84274: IFFALSE 84284
// sLack := true ;
84276: LD_ADDR_EXP 115
84280: PUSH
84281: LD_INT 1
84283: ST_TO_ADDR
// if p3 = 19 then
84284: LD_VAR 0 3
84288: PUSH
84289: LD_INT 19
84291: EQUAL
84292: IFFALSE 84302
// sTank := true ;
84294: LD_ADDR_EXP 117
84298: PUSH
84299: LD_INT 1
84301: ST_TO_ADDR
// if p3 = 20 then
84302: LD_VAR 0 3
84306: PUSH
84307: LD_INT 20
84309: EQUAL
84310: IFFALSE 84320
// sRemote := true ;
84312: LD_ADDR_EXP 118
84316: PUSH
84317: LD_INT 1
84319: ST_TO_ADDR
// if p3 = 21 then
84320: LD_VAR 0 3
84324: PUSH
84325: LD_INT 21
84327: EQUAL
84328: IFFALSE 84338
// sPowell := true ;
84330: LD_ADDR_EXP 119
84334: PUSH
84335: LD_INT 1
84337: ST_TO_ADDR
// if p3 = 22 then
84338: LD_VAR 0 3
84342: PUSH
84343: LD_INT 22
84345: EQUAL
84346: IFFALSE 84356
// sTeleport := true ;
84348: LD_ADDR_EXP 122
84352: PUSH
84353: LD_INT 1
84355: ST_TO_ADDR
// if p3 = 23 then
84356: LD_VAR 0 3
84360: PUSH
84361: LD_INT 23
84363: EQUAL
84364: IFFALSE 84374
// sOilTower := true ;
84366: LD_ADDR_EXP 124
84370: PUSH
84371: LD_INT 1
84373: ST_TO_ADDR
// if p3 = 24 then
84374: LD_VAR 0 3
84378: PUSH
84379: LD_INT 24
84381: EQUAL
84382: IFFALSE 84392
// sShovel := true ;
84384: LD_ADDR_EXP 125
84388: PUSH
84389: LD_INT 1
84391: ST_TO_ADDR
// if p3 = 25 then
84392: LD_VAR 0 3
84396: PUSH
84397: LD_INT 25
84399: EQUAL
84400: IFFALSE 84410
// sSheik := true ;
84402: LD_ADDR_EXP 126
84406: PUSH
84407: LD_INT 1
84409: ST_TO_ADDR
// if p3 = 26 then
84410: LD_VAR 0 3
84414: PUSH
84415: LD_INT 26
84417: EQUAL
84418: IFFALSE 84428
// sEarthquake := true ;
84420: LD_ADDR_EXP 128
84424: PUSH
84425: LD_INT 1
84427: ST_TO_ADDR
// if p3 = 27 then
84428: LD_VAR 0 3
84432: PUSH
84433: LD_INT 27
84435: EQUAL
84436: IFFALSE 84446
// sAI := true ;
84438: LD_ADDR_EXP 129
84442: PUSH
84443: LD_INT 1
84445: ST_TO_ADDR
// if p3 = 28 then
84446: LD_VAR 0 3
84450: PUSH
84451: LD_INT 28
84453: EQUAL
84454: IFFALSE 84464
// sCargo := true ;
84456: LD_ADDR_EXP 132
84460: PUSH
84461: LD_INT 1
84463: ST_TO_ADDR
// if p3 = 29 then
84464: LD_VAR 0 3
84468: PUSH
84469: LD_INT 29
84471: EQUAL
84472: IFFALSE 84482
// sDLaser := true ;
84474: LD_ADDR_EXP 133
84478: PUSH
84479: LD_INT 1
84481: ST_TO_ADDR
// if p3 = 30 then
84482: LD_VAR 0 3
84486: PUSH
84487: LD_INT 30
84489: EQUAL
84490: IFFALSE 84500
// sExchange := true ;
84492: LD_ADDR_EXP 134
84496: PUSH
84497: LD_INT 1
84499: ST_TO_ADDR
// if p3 = 31 then
84500: LD_VAR 0 3
84504: PUSH
84505: LD_INT 31
84507: EQUAL
84508: IFFALSE 84518
// sFac := true ;
84510: LD_ADDR_EXP 135
84514: PUSH
84515: LD_INT 1
84517: ST_TO_ADDR
// if p3 = 32 then
84518: LD_VAR 0 3
84522: PUSH
84523: LD_INT 32
84525: EQUAL
84526: IFFALSE 84536
// sPower := true ;
84528: LD_ADDR_EXP 136
84532: PUSH
84533: LD_INT 1
84535: ST_TO_ADDR
// if p3 = 33 then
84536: LD_VAR 0 3
84540: PUSH
84541: LD_INT 33
84543: EQUAL
84544: IFFALSE 84554
// sRandom := true ;
84546: LD_ADDR_EXP 137
84550: PUSH
84551: LD_INT 1
84553: ST_TO_ADDR
// if p3 = 34 then
84554: LD_VAR 0 3
84558: PUSH
84559: LD_INT 34
84561: EQUAL
84562: IFFALSE 84572
// sShield := true ;
84564: LD_ADDR_EXP 138
84568: PUSH
84569: LD_INT 1
84571: ST_TO_ADDR
// if p3 = 35 then
84572: LD_VAR 0 3
84576: PUSH
84577: LD_INT 35
84579: EQUAL
84580: IFFALSE 84590
// sTime := true ;
84582: LD_ADDR_EXP 139
84586: PUSH
84587: LD_INT 1
84589: ST_TO_ADDR
// if p3 = 36 then
84590: LD_VAR 0 3
84594: PUSH
84595: LD_INT 36
84597: EQUAL
84598: IFFALSE 84608
// sTools := true ;
84600: LD_ADDR_EXP 140
84604: PUSH
84605: LD_INT 1
84607: ST_TO_ADDR
// if p3 = 101 then
84608: LD_VAR 0 3
84612: PUSH
84613: LD_INT 101
84615: EQUAL
84616: IFFALSE 84626
// sSold := true ;
84618: LD_ADDR_EXP 105
84622: PUSH
84623: LD_INT 1
84625: ST_TO_ADDR
// if p3 = 102 then
84626: LD_VAR 0 3
84630: PUSH
84631: LD_INT 102
84633: EQUAL
84634: IFFALSE 84644
// sDiff := true ;
84636: LD_ADDR_EXP 106
84640: PUSH
84641: LD_INT 1
84643: ST_TO_ADDR
// if p3 = 103 then
84644: LD_VAR 0 3
84648: PUSH
84649: LD_INT 103
84651: EQUAL
84652: IFFALSE 84662
// sFog := true ;
84654: LD_ADDR_EXP 109
84658: PUSH
84659: LD_INT 1
84661: ST_TO_ADDR
// if p3 = 104 then
84662: LD_VAR 0 3
84666: PUSH
84667: LD_INT 104
84669: EQUAL
84670: IFFALSE 84680
// sReset := true ;
84672: LD_ADDR_EXP 110
84676: PUSH
84677: LD_INT 1
84679: ST_TO_ADDR
// if p3 = 105 then
84680: LD_VAR 0 3
84684: PUSH
84685: LD_INT 105
84687: EQUAL
84688: IFFALSE 84698
// sSun := true ;
84690: LD_ADDR_EXP 111
84694: PUSH
84695: LD_INT 1
84697: ST_TO_ADDR
// if p3 = 106 then
84698: LD_VAR 0 3
84702: PUSH
84703: LD_INT 106
84705: EQUAL
84706: IFFALSE 84716
// sTiger := true ;
84708: LD_ADDR_EXP 107
84712: PUSH
84713: LD_INT 1
84715: ST_TO_ADDR
// if p3 = 107 then
84716: LD_VAR 0 3
84720: PUSH
84721: LD_INT 107
84723: EQUAL
84724: IFFALSE 84734
// sBomb := true ;
84726: LD_ADDR_EXP 108
84730: PUSH
84731: LD_INT 1
84733: ST_TO_ADDR
// if p3 = 108 then
84734: LD_VAR 0 3
84738: PUSH
84739: LD_INT 108
84741: EQUAL
84742: IFFALSE 84752
// sWound := true ;
84744: LD_ADDR_EXP 116
84748: PUSH
84749: LD_INT 1
84751: ST_TO_ADDR
// if p3 = 109 then
84752: LD_VAR 0 3
84756: PUSH
84757: LD_INT 109
84759: EQUAL
84760: IFFALSE 84770
// sBetray := true ;
84762: LD_ADDR_EXP 120
84766: PUSH
84767: LD_INT 1
84769: ST_TO_ADDR
// if p3 = 110 then
84770: LD_VAR 0 3
84774: PUSH
84775: LD_INT 110
84777: EQUAL
84778: IFFALSE 84788
// sContamin := true ;
84780: LD_ADDR_EXP 121
84784: PUSH
84785: LD_INT 1
84787: ST_TO_ADDR
// if p3 = 111 then
84788: LD_VAR 0 3
84792: PUSH
84793: LD_INT 111
84795: EQUAL
84796: IFFALSE 84806
// sOil := true ;
84798: LD_ADDR_EXP 123
84802: PUSH
84803: LD_INT 1
84805: ST_TO_ADDR
// if p3 = 112 then
84806: LD_VAR 0 3
84810: PUSH
84811: LD_INT 112
84813: EQUAL
84814: IFFALSE 84824
// sStu := true ;
84816: LD_ADDR_EXP 127
84820: PUSH
84821: LD_INT 1
84823: ST_TO_ADDR
// if p3 = 113 then
84824: LD_VAR 0 3
84828: PUSH
84829: LD_INT 113
84831: EQUAL
84832: IFFALSE 84842
// sBazooka := true ;
84834: LD_ADDR_EXP 130
84838: PUSH
84839: LD_INT 1
84841: ST_TO_ADDR
// if p3 = 114 then
84842: LD_VAR 0 3
84846: PUSH
84847: LD_INT 114
84849: EQUAL
84850: IFFALSE 84860
// sMortar := true ;
84852: LD_ADDR_EXP 131
84856: PUSH
84857: LD_INT 1
84859: ST_TO_ADDR
// if p3 = 115 then
84860: LD_VAR 0 3
84864: PUSH
84865: LD_INT 115
84867: EQUAL
84868: IFFALSE 84878
// sRanger := true ;
84870: LD_ADDR_EXP 141
84874: PUSH
84875: LD_INT 1
84877: ST_TO_ADDR
// end ; if p2 = 101 then
84878: LD_VAR 0 2
84882: PUSH
84883: LD_INT 101
84885: EQUAL
84886: IFFALSE 85014
// begin case p3 of 1 :
84888: LD_VAR 0 3
84892: PUSH
84893: LD_INT 1
84895: DOUBLE
84896: EQUAL
84897: IFTRUE 84901
84899: GO 84908
84901: POP
// hHackUnlimitedResources ; 2 :
84902: CALL 96051 0 0
84906: GO 85014
84908: LD_INT 2
84910: DOUBLE
84911: EQUAL
84912: IFTRUE 84916
84914: GO 84923
84916: POP
// hHackSetLevel10 ; 3 :
84917: CALL 96184 0 0
84921: GO 85014
84923: LD_INT 3
84925: DOUBLE
84926: EQUAL
84927: IFTRUE 84931
84929: GO 84938
84931: POP
// hHackSetLevel10YourUnits ; 4 :
84932: CALL 96269 0 0
84936: GO 85014
84938: LD_INT 4
84940: DOUBLE
84941: EQUAL
84942: IFTRUE 84946
84944: GO 84953
84946: POP
// hHackInvincible ; 5 :
84947: CALL 96717 0 0
84951: GO 85014
84953: LD_INT 5
84955: DOUBLE
84956: EQUAL
84957: IFTRUE 84961
84959: GO 84968
84961: POP
// hHackInvisible ; 6 :
84962: CALL 96828 0 0
84966: GO 85014
84968: LD_INT 6
84970: DOUBLE
84971: EQUAL
84972: IFTRUE 84976
84974: GO 84983
84976: POP
// hHackChangeYourSide ; 7 :
84977: CALL 96885 0 0
84981: GO 85014
84983: LD_INT 7
84985: DOUBLE
84986: EQUAL
84987: IFTRUE 84991
84989: GO 84998
84991: POP
// hHackChangeUnitSide ; 8 :
84992: CALL 96927 0 0
84996: GO 85014
84998: LD_INT 8
85000: DOUBLE
85001: EQUAL
85002: IFTRUE 85006
85004: GO 85013
85006: POP
// hHackFog ; end ;
85007: CALL 97028 0 0
85011: GO 85014
85013: POP
// end ; end ;
85014: LD_VAR 0 7
85018: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
85019: GO 85021
85021: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
85022: LD_STRING initStreamRollete();
85024: PPUSH
85025: CALL_OW 559
// InitStreamMode ;
85029: CALL 85038 0 0
// DefineStreamItems ( ) ;
85033: CALL 85478 0 0
// end ;
85037: END
// function InitStreamMode ; begin
85038: LD_INT 0
85040: PPUSH
// streamModeActive := false ;
85041: LD_ADDR_EXP 88
85045: PUSH
85046: LD_INT 0
85048: ST_TO_ADDR
// normalCounter := 36 ;
85049: LD_ADDR_EXP 89
85053: PUSH
85054: LD_INT 36
85056: ST_TO_ADDR
// hardcoreCounter := 16 ;
85057: LD_ADDR_EXP 90
85061: PUSH
85062: LD_INT 16
85064: ST_TO_ADDR
// sRocket := false ;
85065: LD_ADDR_EXP 93
85069: PUSH
85070: LD_INT 0
85072: ST_TO_ADDR
// sSpeed := false ;
85073: LD_ADDR_EXP 92
85077: PUSH
85078: LD_INT 0
85080: ST_TO_ADDR
// sEngine := false ;
85081: LD_ADDR_EXP 94
85085: PUSH
85086: LD_INT 0
85088: ST_TO_ADDR
// sSpec := false ;
85089: LD_ADDR_EXP 91
85093: PUSH
85094: LD_INT 0
85096: ST_TO_ADDR
// sLevel := false ;
85097: LD_ADDR_EXP 95
85101: PUSH
85102: LD_INT 0
85104: ST_TO_ADDR
// sArmoury := false ;
85105: LD_ADDR_EXP 96
85109: PUSH
85110: LD_INT 0
85112: ST_TO_ADDR
// sRadar := false ;
85113: LD_ADDR_EXP 97
85117: PUSH
85118: LD_INT 0
85120: ST_TO_ADDR
// sBunker := false ;
85121: LD_ADDR_EXP 98
85125: PUSH
85126: LD_INT 0
85128: ST_TO_ADDR
// sHack := false ;
85129: LD_ADDR_EXP 99
85133: PUSH
85134: LD_INT 0
85136: ST_TO_ADDR
// sFire := false ;
85137: LD_ADDR_EXP 100
85141: PUSH
85142: LD_INT 0
85144: ST_TO_ADDR
// sRefresh := false ;
85145: LD_ADDR_EXP 101
85149: PUSH
85150: LD_INT 0
85152: ST_TO_ADDR
// sExp := false ;
85153: LD_ADDR_EXP 102
85157: PUSH
85158: LD_INT 0
85160: ST_TO_ADDR
// sDepot := false ;
85161: LD_ADDR_EXP 103
85165: PUSH
85166: LD_INT 0
85168: ST_TO_ADDR
// sFlag := false ;
85169: LD_ADDR_EXP 104
85173: PUSH
85174: LD_INT 0
85176: ST_TO_ADDR
// sKamikadze := false ;
85177: LD_ADDR_EXP 112
85181: PUSH
85182: LD_INT 0
85184: ST_TO_ADDR
// sTroll := false ;
85185: LD_ADDR_EXP 113
85189: PUSH
85190: LD_INT 0
85192: ST_TO_ADDR
// sSlow := false ;
85193: LD_ADDR_EXP 114
85197: PUSH
85198: LD_INT 0
85200: ST_TO_ADDR
// sLack := false ;
85201: LD_ADDR_EXP 115
85205: PUSH
85206: LD_INT 0
85208: ST_TO_ADDR
// sTank := false ;
85209: LD_ADDR_EXP 117
85213: PUSH
85214: LD_INT 0
85216: ST_TO_ADDR
// sRemote := false ;
85217: LD_ADDR_EXP 118
85221: PUSH
85222: LD_INT 0
85224: ST_TO_ADDR
// sPowell := false ;
85225: LD_ADDR_EXP 119
85229: PUSH
85230: LD_INT 0
85232: ST_TO_ADDR
// sTeleport := false ;
85233: LD_ADDR_EXP 122
85237: PUSH
85238: LD_INT 0
85240: ST_TO_ADDR
// sOilTower := false ;
85241: LD_ADDR_EXP 124
85245: PUSH
85246: LD_INT 0
85248: ST_TO_ADDR
// sShovel := false ;
85249: LD_ADDR_EXP 125
85253: PUSH
85254: LD_INT 0
85256: ST_TO_ADDR
// sSheik := false ;
85257: LD_ADDR_EXP 126
85261: PUSH
85262: LD_INT 0
85264: ST_TO_ADDR
// sEarthquake := false ;
85265: LD_ADDR_EXP 128
85269: PUSH
85270: LD_INT 0
85272: ST_TO_ADDR
// sAI := false ;
85273: LD_ADDR_EXP 129
85277: PUSH
85278: LD_INT 0
85280: ST_TO_ADDR
// sCargo := false ;
85281: LD_ADDR_EXP 132
85285: PUSH
85286: LD_INT 0
85288: ST_TO_ADDR
// sDLaser := false ;
85289: LD_ADDR_EXP 133
85293: PUSH
85294: LD_INT 0
85296: ST_TO_ADDR
// sExchange := false ;
85297: LD_ADDR_EXP 134
85301: PUSH
85302: LD_INT 0
85304: ST_TO_ADDR
// sFac := false ;
85305: LD_ADDR_EXP 135
85309: PUSH
85310: LD_INT 0
85312: ST_TO_ADDR
// sPower := false ;
85313: LD_ADDR_EXP 136
85317: PUSH
85318: LD_INT 0
85320: ST_TO_ADDR
// sRandom := false ;
85321: LD_ADDR_EXP 137
85325: PUSH
85326: LD_INT 0
85328: ST_TO_ADDR
// sShield := false ;
85329: LD_ADDR_EXP 138
85333: PUSH
85334: LD_INT 0
85336: ST_TO_ADDR
// sTime := false ;
85337: LD_ADDR_EXP 139
85341: PUSH
85342: LD_INT 0
85344: ST_TO_ADDR
// sTools := false ;
85345: LD_ADDR_EXP 140
85349: PUSH
85350: LD_INT 0
85352: ST_TO_ADDR
// sSold := false ;
85353: LD_ADDR_EXP 105
85357: PUSH
85358: LD_INT 0
85360: ST_TO_ADDR
// sDiff := false ;
85361: LD_ADDR_EXP 106
85365: PUSH
85366: LD_INT 0
85368: ST_TO_ADDR
// sFog := false ;
85369: LD_ADDR_EXP 109
85373: PUSH
85374: LD_INT 0
85376: ST_TO_ADDR
// sReset := false ;
85377: LD_ADDR_EXP 110
85381: PUSH
85382: LD_INT 0
85384: ST_TO_ADDR
// sSun := false ;
85385: LD_ADDR_EXP 111
85389: PUSH
85390: LD_INT 0
85392: ST_TO_ADDR
// sTiger := false ;
85393: LD_ADDR_EXP 107
85397: PUSH
85398: LD_INT 0
85400: ST_TO_ADDR
// sBomb := false ;
85401: LD_ADDR_EXP 108
85405: PUSH
85406: LD_INT 0
85408: ST_TO_ADDR
// sWound := false ;
85409: LD_ADDR_EXP 116
85413: PUSH
85414: LD_INT 0
85416: ST_TO_ADDR
// sBetray := false ;
85417: LD_ADDR_EXP 120
85421: PUSH
85422: LD_INT 0
85424: ST_TO_ADDR
// sContamin := false ;
85425: LD_ADDR_EXP 121
85429: PUSH
85430: LD_INT 0
85432: ST_TO_ADDR
// sOil := false ;
85433: LD_ADDR_EXP 123
85437: PUSH
85438: LD_INT 0
85440: ST_TO_ADDR
// sStu := false ;
85441: LD_ADDR_EXP 127
85445: PUSH
85446: LD_INT 0
85448: ST_TO_ADDR
// sBazooka := false ;
85449: LD_ADDR_EXP 130
85453: PUSH
85454: LD_INT 0
85456: ST_TO_ADDR
// sMortar := false ;
85457: LD_ADDR_EXP 131
85461: PUSH
85462: LD_INT 0
85464: ST_TO_ADDR
// sRanger := false ;
85465: LD_ADDR_EXP 141
85469: PUSH
85470: LD_INT 0
85472: ST_TO_ADDR
// end ;
85473: LD_VAR 0 1
85477: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
85478: LD_INT 0
85480: PPUSH
85481: PPUSH
85482: PPUSH
85483: PPUSH
85484: PPUSH
// result := [ ] ;
85485: LD_ADDR_VAR 0 1
85489: PUSH
85490: EMPTY
85491: ST_TO_ADDR
// if campaign_id = 1 then
85492: LD_OWVAR 69
85496: PUSH
85497: LD_INT 1
85499: EQUAL
85500: IFFALSE 88438
// begin case mission_number of 1 :
85502: LD_OWVAR 70
85506: PUSH
85507: LD_INT 1
85509: DOUBLE
85510: EQUAL
85511: IFTRUE 85515
85513: GO 85579
85515: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
85516: LD_ADDR_VAR 0 1
85520: PUSH
85521: LD_INT 2
85523: PUSH
85524: LD_INT 4
85526: PUSH
85527: LD_INT 11
85529: PUSH
85530: LD_INT 12
85532: PUSH
85533: LD_INT 15
85535: PUSH
85536: LD_INT 16
85538: PUSH
85539: LD_INT 22
85541: PUSH
85542: LD_INT 23
85544: PUSH
85545: LD_INT 26
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: LIST
85552: LIST
85553: LIST
85554: LIST
85555: LIST
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 101
85561: PUSH
85562: LD_INT 102
85564: PUSH
85565: LD_INT 106
85567: PUSH
85568: EMPTY
85569: LIST
85570: LIST
85571: LIST
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: ST_TO_ADDR
85577: GO 88436
85579: LD_INT 2
85581: DOUBLE
85582: EQUAL
85583: IFTRUE 85587
85585: GO 85659
85587: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
85588: LD_ADDR_VAR 0 1
85592: PUSH
85593: LD_INT 2
85595: PUSH
85596: LD_INT 4
85598: PUSH
85599: LD_INT 11
85601: PUSH
85602: LD_INT 12
85604: PUSH
85605: LD_INT 15
85607: PUSH
85608: LD_INT 16
85610: PUSH
85611: LD_INT 22
85613: PUSH
85614: LD_INT 23
85616: PUSH
85617: LD_INT 26
85619: PUSH
85620: EMPTY
85621: LIST
85622: LIST
85623: LIST
85624: LIST
85625: LIST
85626: LIST
85627: LIST
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 101
85633: PUSH
85634: LD_INT 102
85636: PUSH
85637: LD_INT 105
85639: PUSH
85640: LD_INT 106
85642: PUSH
85643: LD_INT 108
85645: PUSH
85646: EMPTY
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: PUSH
85653: EMPTY
85654: LIST
85655: LIST
85656: ST_TO_ADDR
85657: GO 88436
85659: LD_INT 3
85661: DOUBLE
85662: EQUAL
85663: IFTRUE 85667
85665: GO 85743
85667: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
85668: LD_ADDR_VAR 0 1
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: LD_INT 4
85678: PUSH
85679: LD_INT 5
85681: PUSH
85682: LD_INT 11
85684: PUSH
85685: LD_INT 12
85687: PUSH
85688: LD_INT 15
85690: PUSH
85691: LD_INT 16
85693: PUSH
85694: LD_INT 22
85696: PUSH
85697: LD_INT 26
85699: PUSH
85700: LD_INT 36
85702: PUSH
85703: EMPTY
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 101
85717: PUSH
85718: LD_INT 102
85720: PUSH
85721: LD_INT 105
85723: PUSH
85724: LD_INT 106
85726: PUSH
85727: LD_INT 108
85729: PUSH
85730: EMPTY
85731: LIST
85732: LIST
85733: LIST
85734: LIST
85735: LIST
85736: PUSH
85737: EMPTY
85738: LIST
85739: LIST
85740: ST_TO_ADDR
85741: GO 88436
85743: LD_INT 4
85745: DOUBLE
85746: EQUAL
85747: IFTRUE 85751
85749: GO 85835
85751: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
85752: LD_ADDR_VAR 0 1
85756: PUSH
85757: LD_INT 2
85759: PUSH
85760: LD_INT 4
85762: PUSH
85763: LD_INT 5
85765: PUSH
85766: LD_INT 8
85768: PUSH
85769: LD_INT 11
85771: PUSH
85772: LD_INT 12
85774: PUSH
85775: LD_INT 15
85777: PUSH
85778: LD_INT 16
85780: PUSH
85781: LD_INT 22
85783: PUSH
85784: LD_INT 23
85786: PUSH
85787: LD_INT 26
85789: PUSH
85790: LD_INT 36
85792: PUSH
85793: EMPTY
85794: LIST
85795: LIST
85796: LIST
85797: LIST
85798: LIST
85799: LIST
85800: LIST
85801: LIST
85802: LIST
85803: LIST
85804: LIST
85805: LIST
85806: PUSH
85807: LD_INT 101
85809: PUSH
85810: LD_INT 102
85812: PUSH
85813: LD_INT 105
85815: PUSH
85816: LD_INT 106
85818: PUSH
85819: LD_INT 108
85821: PUSH
85822: EMPTY
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: ST_TO_ADDR
85833: GO 88436
85835: LD_INT 5
85837: DOUBLE
85838: EQUAL
85839: IFTRUE 85843
85841: GO 85943
85843: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
85844: LD_ADDR_VAR 0 1
85848: PUSH
85849: LD_INT 2
85851: PUSH
85852: LD_INT 4
85854: PUSH
85855: LD_INT 5
85857: PUSH
85858: LD_INT 6
85860: PUSH
85861: LD_INT 8
85863: PUSH
85864: LD_INT 11
85866: PUSH
85867: LD_INT 12
85869: PUSH
85870: LD_INT 15
85872: PUSH
85873: LD_INT 16
85875: PUSH
85876: LD_INT 22
85878: PUSH
85879: LD_INT 23
85881: PUSH
85882: LD_INT 25
85884: PUSH
85885: LD_INT 26
85887: PUSH
85888: LD_INT 36
85890: PUSH
85891: EMPTY
85892: LIST
85893: LIST
85894: LIST
85895: LIST
85896: LIST
85897: LIST
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 101
85909: PUSH
85910: LD_INT 102
85912: PUSH
85913: LD_INT 105
85915: PUSH
85916: LD_INT 106
85918: PUSH
85919: LD_INT 108
85921: PUSH
85922: LD_INT 109
85924: PUSH
85925: LD_INT 112
85927: PUSH
85928: EMPTY
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: ST_TO_ADDR
85941: GO 88436
85943: LD_INT 6
85945: DOUBLE
85946: EQUAL
85947: IFTRUE 85951
85949: GO 86071
85951: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
85952: LD_ADDR_VAR 0 1
85956: PUSH
85957: LD_INT 2
85959: PUSH
85960: LD_INT 4
85962: PUSH
85963: LD_INT 5
85965: PUSH
85966: LD_INT 6
85968: PUSH
85969: LD_INT 8
85971: PUSH
85972: LD_INT 11
85974: PUSH
85975: LD_INT 12
85977: PUSH
85978: LD_INT 15
85980: PUSH
85981: LD_INT 16
85983: PUSH
85984: LD_INT 20
85986: PUSH
85987: LD_INT 21
85989: PUSH
85990: LD_INT 22
85992: PUSH
85993: LD_INT 23
85995: PUSH
85996: LD_INT 25
85998: PUSH
85999: LD_INT 26
86001: PUSH
86002: LD_INT 30
86004: PUSH
86005: LD_INT 31
86007: PUSH
86008: LD_INT 32
86010: PUSH
86011: LD_INT 36
86013: PUSH
86014: EMPTY
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 101
86037: PUSH
86038: LD_INT 102
86040: PUSH
86041: LD_INT 105
86043: PUSH
86044: LD_INT 106
86046: PUSH
86047: LD_INT 108
86049: PUSH
86050: LD_INT 109
86052: PUSH
86053: LD_INT 112
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: LIST
86060: LIST
86061: LIST
86062: LIST
86063: LIST
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: ST_TO_ADDR
86069: GO 88436
86071: LD_INT 7
86073: DOUBLE
86074: EQUAL
86075: IFTRUE 86079
86077: GO 86179
86079: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
86080: LD_ADDR_VAR 0 1
86084: PUSH
86085: LD_INT 2
86087: PUSH
86088: LD_INT 4
86090: PUSH
86091: LD_INT 5
86093: PUSH
86094: LD_INT 7
86096: PUSH
86097: LD_INT 11
86099: PUSH
86100: LD_INT 12
86102: PUSH
86103: LD_INT 15
86105: PUSH
86106: LD_INT 16
86108: PUSH
86109: LD_INT 20
86111: PUSH
86112: LD_INT 21
86114: PUSH
86115: LD_INT 22
86117: PUSH
86118: LD_INT 23
86120: PUSH
86121: LD_INT 25
86123: PUSH
86124: LD_INT 26
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 101
86145: PUSH
86146: LD_INT 102
86148: PUSH
86149: LD_INT 103
86151: PUSH
86152: LD_INT 105
86154: PUSH
86155: LD_INT 106
86157: PUSH
86158: LD_INT 108
86160: PUSH
86161: LD_INT 112
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: ST_TO_ADDR
86177: GO 88436
86179: LD_INT 8
86181: DOUBLE
86182: EQUAL
86183: IFTRUE 86187
86185: GO 86315
86187: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
86188: LD_ADDR_VAR 0 1
86192: PUSH
86193: LD_INT 2
86195: PUSH
86196: LD_INT 4
86198: PUSH
86199: LD_INT 5
86201: PUSH
86202: LD_INT 6
86204: PUSH
86205: LD_INT 7
86207: PUSH
86208: LD_INT 8
86210: PUSH
86211: LD_INT 11
86213: PUSH
86214: LD_INT 12
86216: PUSH
86217: LD_INT 15
86219: PUSH
86220: LD_INT 16
86222: PUSH
86223: LD_INT 20
86225: PUSH
86226: LD_INT 21
86228: PUSH
86229: LD_INT 22
86231: PUSH
86232: LD_INT 23
86234: PUSH
86235: LD_INT 25
86237: PUSH
86238: LD_INT 26
86240: PUSH
86241: LD_INT 30
86243: PUSH
86244: LD_INT 31
86246: PUSH
86247: LD_INT 32
86249: PUSH
86250: LD_INT 36
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 101
86277: PUSH
86278: LD_INT 102
86280: PUSH
86281: LD_INT 103
86283: PUSH
86284: LD_INT 105
86286: PUSH
86287: LD_INT 106
86289: PUSH
86290: LD_INT 108
86292: PUSH
86293: LD_INT 109
86295: PUSH
86296: LD_INT 112
86298: PUSH
86299: EMPTY
86300: LIST
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: ST_TO_ADDR
86313: GO 88436
86315: LD_INT 9
86317: DOUBLE
86318: EQUAL
86319: IFTRUE 86323
86321: GO 86459
86323: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
86324: LD_ADDR_VAR 0 1
86328: PUSH
86329: LD_INT 2
86331: PUSH
86332: LD_INT 4
86334: PUSH
86335: LD_INT 5
86337: PUSH
86338: LD_INT 6
86340: PUSH
86341: LD_INT 7
86343: PUSH
86344: LD_INT 8
86346: PUSH
86347: LD_INT 11
86349: PUSH
86350: LD_INT 12
86352: PUSH
86353: LD_INT 15
86355: PUSH
86356: LD_INT 16
86358: PUSH
86359: LD_INT 20
86361: PUSH
86362: LD_INT 21
86364: PUSH
86365: LD_INT 22
86367: PUSH
86368: LD_INT 23
86370: PUSH
86371: LD_INT 25
86373: PUSH
86374: LD_INT 26
86376: PUSH
86377: LD_INT 28
86379: PUSH
86380: LD_INT 30
86382: PUSH
86383: LD_INT 31
86385: PUSH
86386: LD_INT 32
86388: PUSH
86389: LD_INT 36
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: LIST
86396: LIST
86397: LIST
86398: LIST
86399: LIST
86400: LIST
86401: LIST
86402: LIST
86403: LIST
86404: LIST
86405: LIST
86406: LIST
86407: LIST
86408: LIST
86409: LIST
86410: LIST
86411: LIST
86412: LIST
86413: LIST
86414: PUSH
86415: LD_INT 101
86417: PUSH
86418: LD_INT 102
86420: PUSH
86421: LD_INT 103
86423: PUSH
86424: LD_INT 105
86426: PUSH
86427: LD_INT 106
86429: PUSH
86430: LD_INT 108
86432: PUSH
86433: LD_INT 109
86435: PUSH
86436: LD_INT 112
86438: PUSH
86439: LD_INT 114
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: LIST
86446: LIST
86447: LIST
86448: LIST
86449: LIST
86450: LIST
86451: LIST
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: ST_TO_ADDR
86457: GO 88436
86459: LD_INT 10
86461: DOUBLE
86462: EQUAL
86463: IFTRUE 86467
86465: GO 86651
86467: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
86468: LD_ADDR_VAR 0 1
86472: PUSH
86473: LD_INT 2
86475: PUSH
86476: LD_INT 4
86478: PUSH
86479: LD_INT 5
86481: PUSH
86482: LD_INT 6
86484: PUSH
86485: LD_INT 7
86487: PUSH
86488: LD_INT 8
86490: PUSH
86491: LD_INT 9
86493: PUSH
86494: LD_INT 10
86496: PUSH
86497: LD_INT 11
86499: PUSH
86500: LD_INT 12
86502: PUSH
86503: LD_INT 13
86505: PUSH
86506: LD_INT 14
86508: PUSH
86509: LD_INT 15
86511: PUSH
86512: LD_INT 16
86514: PUSH
86515: LD_INT 17
86517: PUSH
86518: LD_INT 18
86520: PUSH
86521: LD_INT 19
86523: PUSH
86524: LD_INT 20
86526: PUSH
86527: LD_INT 21
86529: PUSH
86530: LD_INT 22
86532: PUSH
86533: LD_INT 23
86535: PUSH
86536: LD_INT 24
86538: PUSH
86539: LD_INT 25
86541: PUSH
86542: LD_INT 26
86544: PUSH
86545: LD_INT 28
86547: PUSH
86548: LD_INT 30
86550: PUSH
86551: LD_INT 31
86553: PUSH
86554: LD_INT 32
86556: PUSH
86557: LD_INT 36
86559: PUSH
86560: EMPTY
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: LIST
86575: LIST
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: LIST
86581: LIST
86582: LIST
86583: LIST
86584: LIST
86585: LIST
86586: LIST
86587: LIST
86588: LIST
86589: LIST
86590: PUSH
86591: LD_INT 101
86593: PUSH
86594: LD_INT 102
86596: PUSH
86597: LD_INT 103
86599: PUSH
86600: LD_INT 104
86602: PUSH
86603: LD_INT 105
86605: PUSH
86606: LD_INT 106
86608: PUSH
86609: LD_INT 107
86611: PUSH
86612: LD_INT 108
86614: PUSH
86615: LD_INT 109
86617: PUSH
86618: LD_INT 110
86620: PUSH
86621: LD_INT 111
86623: PUSH
86624: LD_INT 112
86626: PUSH
86627: LD_INT 114
86629: PUSH
86630: EMPTY
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: LIST
86636: LIST
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: PUSH
86645: EMPTY
86646: LIST
86647: LIST
86648: ST_TO_ADDR
86649: GO 88436
86651: LD_INT 11
86653: DOUBLE
86654: EQUAL
86655: IFTRUE 86659
86657: GO 86851
86659: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
86660: LD_ADDR_VAR 0 1
86664: PUSH
86665: LD_INT 2
86667: PUSH
86668: LD_INT 3
86670: PUSH
86671: LD_INT 4
86673: PUSH
86674: LD_INT 5
86676: PUSH
86677: LD_INT 6
86679: PUSH
86680: LD_INT 7
86682: PUSH
86683: LD_INT 8
86685: PUSH
86686: LD_INT 9
86688: PUSH
86689: LD_INT 10
86691: PUSH
86692: LD_INT 11
86694: PUSH
86695: LD_INT 12
86697: PUSH
86698: LD_INT 13
86700: PUSH
86701: LD_INT 14
86703: PUSH
86704: LD_INT 15
86706: PUSH
86707: LD_INT 16
86709: PUSH
86710: LD_INT 17
86712: PUSH
86713: LD_INT 18
86715: PUSH
86716: LD_INT 19
86718: PUSH
86719: LD_INT 20
86721: PUSH
86722: LD_INT 21
86724: PUSH
86725: LD_INT 22
86727: PUSH
86728: LD_INT 23
86730: PUSH
86731: LD_INT 24
86733: PUSH
86734: LD_INT 25
86736: PUSH
86737: LD_INT 26
86739: PUSH
86740: LD_INT 28
86742: PUSH
86743: LD_INT 30
86745: PUSH
86746: LD_INT 31
86748: PUSH
86749: LD_INT 32
86751: PUSH
86752: LD_INT 34
86754: PUSH
86755: LD_INT 36
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: LIST
86762: LIST
86763: LIST
86764: LIST
86765: LIST
86766: LIST
86767: LIST
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: PUSH
86791: LD_INT 101
86793: PUSH
86794: LD_INT 102
86796: PUSH
86797: LD_INT 103
86799: PUSH
86800: LD_INT 104
86802: PUSH
86803: LD_INT 105
86805: PUSH
86806: LD_INT 106
86808: PUSH
86809: LD_INT 107
86811: PUSH
86812: LD_INT 108
86814: PUSH
86815: LD_INT 109
86817: PUSH
86818: LD_INT 110
86820: PUSH
86821: LD_INT 111
86823: PUSH
86824: LD_INT 112
86826: PUSH
86827: LD_INT 114
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: LIST
86834: LIST
86835: LIST
86836: LIST
86837: LIST
86838: LIST
86839: LIST
86840: LIST
86841: LIST
86842: LIST
86843: LIST
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: ST_TO_ADDR
86849: GO 88436
86851: LD_INT 12
86853: DOUBLE
86854: EQUAL
86855: IFTRUE 86859
86857: GO 87067
86859: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
86860: LD_ADDR_VAR 0 1
86864: PUSH
86865: LD_INT 1
86867: PUSH
86868: LD_INT 2
86870: PUSH
86871: LD_INT 3
86873: PUSH
86874: LD_INT 4
86876: PUSH
86877: LD_INT 5
86879: PUSH
86880: LD_INT 6
86882: PUSH
86883: LD_INT 7
86885: PUSH
86886: LD_INT 8
86888: PUSH
86889: LD_INT 9
86891: PUSH
86892: LD_INT 10
86894: PUSH
86895: LD_INT 11
86897: PUSH
86898: LD_INT 12
86900: PUSH
86901: LD_INT 13
86903: PUSH
86904: LD_INT 14
86906: PUSH
86907: LD_INT 15
86909: PUSH
86910: LD_INT 16
86912: PUSH
86913: LD_INT 17
86915: PUSH
86916: LD_INT 18
86918: PUSH
86919: LD_INT 19
86921: PUSH
86922: LD_INT 20
86924: PUSH
86925: LD_INT 21
86927: PUSH
86928: LD_INT 22
86930: PUSH
86931: LD_INT 23
86933: PUSH
86934: LD_INT 24
86936: PUSH
86937: LD_INT 25
86939: PUSH
86940: LD_INT 26
86942: PUSH
86943: LD_INT 27
86945: PUSH
86946: LD_INT 28
86948: PUSH
86949: LD_INT 30
86951: PUSH
86952: LD_INT 31
86954: PUSH
86955: LD_INT 32
86957: PUSH
86958: LD_INT 33
86960: PUSH
86961: LD_INT 34
86963: PUSH
86964: LD_INT 36
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: LIST
87002: PUSH
87003: LD_INT 101
87005: PUSH
87006: LD_INT 102
87008: PUSH
87009: LD_INT 103
87011: PUSH
87012: LD_INT 104
87014: PUSH
87015: LD_INT 105
87017: PUSH
87018: LD_INT 106
87020: PUSH
87021: LD_INT 107
87023: PUSH
87024: LD_INT 108
87026: PUSH
87027: LD_INT 109
87029: PUSH
87030: LD_INT 110
87032: PUSH
87033: LD_INT 111
87035: PUSH
87036: LD_INT 112
87038: PUSH
87039: LD_INT 113
87041: PUSH
87042: LD_INT 114
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: ST_TO_ADDR
87065: GO 88436
87067: LD_INT 13
87069: DOUBLE
87070: EQUAL
87071: IFTRUE 87075
87073: GO 87271
87075: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
87076: LD_ADDR_VAR 0 1
87080: PUSH
87081: LD_INT 1
87083: PUSH
87084: LD_INT 2
87086: PUSH
87087: LD_INT 3
87089: PUSH
87090: LD_INT 4
87092: PUSH
87093: LD_INT 5
87095: PUSH
87096: LD_INT 8
87098: PUSH
87099: LD_INT 9
87101: PUSH
87102: LD_INT 10
87104: PUSH
87105: LD_INT 11
87107: PUSH
87108: LD_INT 12
87110: PUSH
87111: LD_INT 14
87113: PUSH
87114: LD_INT 15
87116: PUSH
87117: LD_INT 16
87119: PUSH
87120: LD_INT 17
87122: PUSH
87123: LD_INT 18
87125: PUSH
87126: LD_INT 19
87128: PUSH
87129: LD_INT 20
87131: PUSH
87132: LD_INT 21
87134: PUSH
87135: LD_INT 22
87137: PUSH
87138: LD_INT 23
87140: PUSH
87141: LD_INT 24
87143: PUSH
87144: LD_INT 25
87146: PUSH
87147: LD_INT 26
87149: PUSH
87150: LD_INT 27
87152: PUSH
87153: LD_INT 28
87155: PUSH
87156: LD_INT 30
87158: PUSH
87159: LD_INT 31
87161: PUSH
87162: LD_INT 32
87164: PUSH
87165: LD_INT 33
87167: PUSH
87168: LD_INT 34
87170: PUSH
87171: LD_INT 36
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: LIST
87190: LIST
87191: LIST
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: LIST
87201: LIST
87202: LIST
87203: LIST
87204: LIST
87205: LIST
87206: PUSH
87207: LD_INT 101
87209: PUSH
87210: LD_INT 102
87212: PUSH
87213: LD_INT 103
87215: PUSH
87216: LD_INT 104
87218: PUSH
87219: LD_INT 105
87221: PUSH
87222: LD_INT 106
87224: PUSH
87225: LD_INT 107
87227: PUSH
87228: LD_INT 108
87230: PUSH
87231: LD_INT 109
87233: PUSH
87234: LD_INT 110
87236: PUSH
87237: LD_INT 111
87239: PUSH
87240: LD_INT 112
87242: PUSH
87243: LD_INT 113
87245: PUSH
87246: LD_INT 114
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: LIST
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: LIST
87261: LIST
87262: LIST
87263: LIST
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: ST_TO_ADDR
87269: GO 88436
87271: LD_INT 14
87273: DOUBLE
87274: EQUAL
87275: IFTRUE 87279
87277: GO 87491
87279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
87280: LD_ADDR_VAR 0 1
87284: PUSH
87285: LD_INT 1
87287: PUSH
87288: LD_INT 2
87290: PUSH
87291: LD_INT 3
87293: PUSH
87294: LD_INT 4
87296: PUSH
87297: LD_INT 5
87299: PUSH
87300: LD_INT 6
87302: PUSH
87303: LD_INT 7
87305: PUSH
87306: LD_INT 8
87308: PUSH
87309: LD_INT 9
87311: PUSH
87312: LD_INT 10
87314: PUSH
87315: LD_INT 11
87317: PUSH
87318: LD_INT 12
87320: PUSH
87321: LD_INT 13
87323: PUSH
87324: LD_INT 14
87326: PUSH
87327: LD_INT 15
87329: PUSH
87330: LD_INT 16
87332: PUSH
87333: LD_INT 17
87335: PUSH
87336: LD_INT 18
87338: PUSH
87339: LD_INT 19
87341: PUSH
87342: LD_INT 20
87344: PUSH
87345: LD_INT 21
87347: PUSH
87348: LD_INT 22
87350: PUSH
87351: LD_INT 23
87353: PUSH
87354: LD_INT 24
87356: PUSH
87357: LD_INT 25
87359: PUSH
87360: LD_INT 26
87362: PUSH
87363: LD_INT 27
87365: PUSH
87366: LD_INT 28
87368: PUSH
87369: LD_INT 29
87371: PUSH
87372: LD_INT 30
87374: PUSH
87375: LD_INT 31
87377: PUSH
87378: LD_INT 32
87380: PUSH
87381: LD_INT 33
87383: PUSH
87384: LD_INT 34
87386: PUSH
87387: LD_INT 36
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: LIST
87426: PUSH
87427: LD_INT 101
87429: PUSH
87430: LD_INT 102
87432: PUSH
87433: LD_INT 103
87435: PUSH
87436: LD_INT 104
87438: PUSH
87439: LD_INT 105
87441: PUSH
87442: LD_INT 106
87444: PUSH
87445: LD_INT 107
87447: PUSH
87448: LD_INT 108
87450: PUSH
87451: LD_INT 109
87453: PUSH
87454: LD_INT 110
87456: PUSH
87457: LD_INT 111
87459: PUSH
87460: LD_INT 112
87462: PUSH
87463: LD_INT 113
87465: PUSH
87466: LD_INT 114
87468: PUSH
87469: EMPTY
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: LIST
87478: LIST
87479: LIST
87480: LIST
87481: LIST
87482: LIST
87483: LIST
87484: PUSH
87485: EMPTY
87486: LIST
87487: LIST
87488: ST_TO_ADDR
87489: GO 88436
87491: LD_INT 15
87493: DOUBLE
87494: EQUAL
87495: IFTRUE 87499
87497: GO 87711
87499: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
87500: LD_ADDR_VAR 0 1
87504: PUSH
87505: LD_INT 1
87507: PUSH
87508: LD_INT 2
87510: PUSH
87511: LD_INT 3
87513: PUSH
87514: LD_INT 4
87516: PUSH
87517: LD_INT 5
87519: PUSH
87520: LD_INT 6
87522: PUSH
87523: LD_INT 7
87525: PUSH
87526: LD_INT 8
87528: PUSH
87529: LD_INT 9
87531: PUSH
87532: LD_INT 10
87534: PUSH
87535: LD_INT 11
87537: PUSH
87538: LD_INT 12
87540: PUSH
87541: LD_INT 13
87543: PUSH
87544: LD_INT 14
87546: PUSH
87547: LD_INT 15
87549: PUSH
87550: LD_INT 16
87552: PUSH
87553: LD_INT 17
87555: PUSH
87556: LD_INT 18
87558: PUSH
87559: LD_INT 19
87561: PUSH
87562: LD_INT 20
87564: PUSH
87565: LD_INT 21
87567: PUSH
87568: LD_INT 22
87570: PUSH
87571: LD_INT 23
87573: PUSH
87574: LD_INT 24
87576: PUSH
87577: LD_INT 25
87579: PUSH
87580: LD_INT 26
87582: PUSH
87583: LD_INT 27
87585: PUSH
87586: LD_INT 28
87588: PUSH
87589: LD_INT 29
87591: PUSH
87592: LD_INT 30
87594: PUSH
87595: LD_INT 31
87597: PUSH
87598: LD_INT 32
87600: PUSH
87601: LD_INT 33
87603: PUSH
87604: LD_INT 34
87606: PUSH
87607: LD_INT 36
87609: PUSH
87610: EMPTY
87611: LIST
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 101
87649: PUSH
87650: LD_INT 102
87652: PUSH
87653: LD_INT 103
87655: PUSH
87656: LD_INT 104
87658: PUSH
87659: LD_INT 105
87661: PUSH
87662: LD_INT 106
87664: PUSH
87665: LD_INT 107
87667: PUSH
87668: LD_INT 108
87670: PUSH
87671: LD_INT 109
87673: PUSH
87674: LD_INT 110
87676: PUSH
87677: LD_INT 111
87679: PUSH
87680: LD_INT 112
87682: PUSH
87683: LD_INT 113
87685: PUSH
87686: LD_INT 114
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: LIST
87693: LIST
87694: LIST
87695: LIST
87696: LIST
87697: LIST
87698: LIST
87699: LIST
87700: LIST
87701: LIST
87702: LIST
87703: LIST
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: ST_TO_ADDR
87709: GO 88436
87711: LD_INT 16
87713: DOUBLE
87714: EQUAL
87715: IFTRUE 87719
87717: GO 87843
87719: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
87720: LD_ADDR_VAR 0 1
87724: PUSH
87725: LD_INT 2
87727: PUSH
87728: LD_INT 4
87730: PUSH
87731: LD_INT 5
87733: PUSH
87734: LD_INT 7
87736: PUSH
87737: LD_INT 11
87739: PUSH
87740: LD_INT 12
87742: PUSH
87743: LD_INT 15
87745: PUSH
87746: LD_INT 16
87748: PUSH
87749: LD_INT 20
87751: PUSH
87752: LD_INT 21
87754: PUSH
87755: LD_INT 22
87757: PUSH
87758: LD_INT 23
87760: PUSH
87761: LD_INT 25
87763: PUSH
87764: LD_INT 26
87766: PUSH
87767: LD_INT 30
87769: PUSH
87770: LD_INT 31
87772: PUSH
87773: LD_INT 32
87775: PUSH
87776: LD_INT 33
87778: PUSH
87779: LD_INT 34
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: LIST
87792: LIST
87793: LIST
87794: LIST
87795: LIST
87796: LIST
87797: LIST
87798: LIST
87799: LIST
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 101
87805: PUSH
87806: LD_INT 102
87808: PUSH
87809: LD_INT 103
87811: PUSH
87812: LD_INT 106
87814: PUSH
87815: LD_INT 108
87817: PUSH
87818: LD_INT 112
87820: PUSH
87821: LD_INT 113
87823: PUSH
87824: LD_INT 114
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: LIST
87835: LIST
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: ST_TO_ADDR
87841: GO 88436
87843: LD_INT 17
87845: DOUBLE
87846: EQUAL
87847: IFTRUE 87851
87849: GO 88063
87851: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
87852: LD_ADDR_VAR 0 1
87856: PUSH
87857: LD_INT 1
87859: PUSH
87860: LD_INT 2
87862: PUSH
87863: LD_INT 3
87865: PUSH
87866: LD_INT 4
87868: PUSH
87869: LD_INT 5
87871: PUSH
87872: LD_INT 6
87874: PUSH
87875: LD_INT 7
87877: PUSH
87878: LD_INT 8
87880: PUSH
87881: LD_INT 9
87883: PUSH
87884: LD_INT 10
87886: PUSH
87887: LD_INT 11
87889: PUSH
87890: LD_INT 12
87892: PUSH
87893: LD_INT 13
87895: PUSH
87896: LD_INT 14
87898: PUSH
87899: LD_INT 15
87901: PUSH
87902: LD_INT 16
87904: PUSH
87905: LD_INT 17
87907: PUSH
87908: LD_INT 18
87910: PUSH
87911: LD_INT 19
87913: PUSH
87914: LD_INT 20
87916: PUSH
87917: LD_INT 21
87919: PUSH
87920: LD_INT 22
87922: PUSH
87923: LD_INT 23
87925: PUSH
87926: LD_INT 24
87928: PUSH
87929: LD_INT 25
87931: PUSH
87932: LD_INT 26
87934: PUSH
87935: LD_INT 27
87937: PUSH
87938: LD_INT 28
87940: PUSH
87941: LD_INT 29
87943: PUSH
87944: LD_INT 30
87946: PUSH
87947: LD_INT 31
87949: PUSH
87950: LD_INT 32
87952: PUSH
87953: LD_INT 33
87955: PUSH
87956: LD_INT 34
87958: PUSH
87959: LD_INT 36
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: LIST
87977: LIST
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: PUSH
87999: LD_INT 101
88001: PUSH
88002: LD_INT 102
88004: PUSH
88005: LD_INT 103
88007: PUSH
88008: LD_INT 104
88010: PUSH
88011: LD_INT 105
88013: PUSH
88014: LD_INT 106
88016: PUSH
88017: LD_INT 107
88019: PUSH
88020: LD_INT 108
88022: PUSH
88023: LD_INT 109
88025: PUSH
88026: LD_INT 110
88028: PUSH
88029: LD_INT 111
88031: PUSH
88032: LD_INT 112
88034: PUSH
88035: LD_INT 113
88037: PUSH
88038: LD_INT 114
88040: PUSH
88041: EMPTY
88042: LIST
88043: LIST
88044: LIST
88045: LIST
88046: LIST
88047: LIST
88048: LIST
88049: LIST
88050: LIST
88051: LIST
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: ST_TO_ADDR
88061: GO 88436
88063: LD_INT 18
88065: DOUBLE
88066: EQUAL
88067: IFTRUE 88071
88069: GO 88207
88071: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
88072: LD_ADDR_VAR 0 1
88076: PUSH
88077: LD_INT 2
88079: PUSH
88080: LD_INT 4
88082: PUSH
88083: LD_INT 5
88085: PUSH
88086: LD_INT 7
88088: PUSH
88089: LD_INT 11
88091: PUSH
88092: LD_INT 12
88094: PUSH
88095: LD_INT 15
88097: PUSH
88098: LD_INT 16
88100: PUSH
88101: LD_INT 20
88103: PUSH
88104: LD_INT 21
88106: PUSH
88107: LD_INT 22
88109: PUSH
88110: LD_INT 23
88112: PUSH
88113: LD_INT 25
88115: PUSH
88116: LD_INT 26
88118: PUSH
88119: LD_INT 30
88121: PUSH
88122: LD_INT 31
88124: PUSH
88125: LD_INT 32
88127: PUSH
88128: LD_INT 33
88130: PUSH
88131: LD_INT 34
88133: PUSH
88134: LD_INT 35
88136: PUSH
88137: LD_INT 36
88139: PUSH
88140: EMPTY
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: LIST
88150: LIST
88151: LIST
88152: LIST
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: PUSH
88163: LD_INT 101
88165: PUSH
88166: LD_INT 102
88168: PUSH
88169: LD_INT 103
88171: PUSH
88172: LD_INT 106
88174: PUSH
88175: LD_INT 108
88177: PUSH
88178: LD_INT 112
88180: PUSH
88181: LD_INT 113
88183: PUSH
88184: LD_INT 114
88186: PUSH
88187: LD_INT 115
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: ST_TO_ADDR
88205: GO 88436
88207: LD_INT 19
88209: DOUBLE
88210: EQUAL
88211: IFTRUE 88215
88213: GO 88435
88215: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
88216: LD_ADDR_VAR 0 1
88220: PUSH
88221: LD_INT 1
88223: PUSH
88224: LD_INT 2
88226: PUSH
88227: LD_INT 3
88229: PUSH
88230: LD_INT 4
88232: PUSH
88233: LD_INT 5
88235: PUSH
88236: LD_INT 6
88238: PUSH
88239: LD_INT 7
88241: PUSH
88242: LD_INT 8
88244: PUSH
88245: LD_INT 9
88247: PUSH
88248: LD_INT 10
88250: PUSH
88251: LD_INT 11
88253: PUSH
88254: LD_INT 12
88256: PUSH
88257: LD_INT 13
88259: PUSH
88260: LD_INT 14
88262: PUSH
88263: LD_INT 15
88265: PUSH
88266: LD_INT 16
88268: PUSH
88269: LD_INT 17
88271: PUSH
88272: LD_INT 18
88274: PUSH
88275: LD_INT 19
88277: PUSH
88278: LD_INT 20
88280: PUSH
88281: LD_INT 21
88283: PUSH
88284: LD_INT 22
88286: PUSH
88287: LD_INT 23
88289: PUSH
88290: LD_INT 24
88292: PUSH
88293: LD_INT 25
88295: PUSH
88296: LD_INT 26
88298: PUSH
88299: LD_INT 27
88301: PUSH
88302: LD_INT 28
88304: PUSH
88305: LD_INT 29
88307: PUSH
88308: LD_INT 30
88310: PUSH
88311: LD_INT 31
88313: PUSH
88314: LD_INT 32
88316: PUSH
88317: LD_INT 33
88319: PUSH
88320: LD_INT 34
88322: PUSH
88323: LD_INT 35
88325: PUSH
88326: LD_INT 36
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: LIST
88354: LIST
88355: LIST
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: PUSH
88367: LD_INT 101
88369: PUSH
88370: LD_INT 102
88372: PUSH
88373: LD_INT 103
88375: PUSH
88376: LD_INT 104
88378: PUSH
88379: LD_INT 105
88381: PUSH
88382: LD_INT 106
88384: PUSH
88385: LD_INT 107
88387: PUSH
88388: LD_INT 108
88390: PUSH
88391: LD_INT 109
88393: PUSH
88394: LD_INT 110
88396: PUSH
88397: LD_INT 111
88399: PUSH
88400: LD_INT 112
88402: PUSH
88403: LD_INT 113
88405: PUSH
88406: LD_INT 114
88408: PUSH
88409: LD_INT 115
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: ST_TO_ADDR
88433: GO 88436
88435: POP
// end else
88436: GO 88655
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
88438: LD_ADDR_VAR 0 1
88442: PUSH
88443: LD_INT 1
88445: PUSH
88446: LD_INT 2
88448: PUSH
88449: LD_INT 3
88451: PUSH
88452: LD_INT 4
88454: PUSH
88455: LD_INT 5
88457: PUSH
88458: LD_INT 6
88460: PUSH
88461: LD_INT 7
88463: PUSH
88464: LD_INT 8
88466: PUSH
88467: LD_INT 9
88469: PUSH
88470: LD_INT 10
88472: PUSH
88473: LD_INT 11
88475: PUSH
88476: LD_INT 12
88478: PUSH
88479: LD_INT 13
88481: PUSH
88482: LD_INT 14
88484: PUSH
88485: LD_INT 15
88487: PUSH
88488: LD_INT 16
88490: PUSH
88491: LD_INT 17
88493: PUSH
88494: LD_INT 18
88496: PUSH
88497: LD_INT 19
88499: PUSH
88500: LD_INT 20
88502: PUSH
88503: LD_INT 21
88505: PUSH
88506: LD_INT 22
88508: PUSH
88509: LD_INT 23
88511: PUSH
88512: LD_INT 24
88514: PUSH
88515: LD_INT 25
88517: PUSH
88518: LD_INT 26
88520: PUSH
88521: LD_INT 27
88523: PUSH
88524: LD_INT 28
88526: PUSH
88527: LD_INT 29
88529: PUSH
88530: LD_INT 30
88532: PUSH
88533: LD_INT 31
88535: PUSH
88536: LD_INT 32
88538: PUSH
88539: LD_INT 33
88541: PUSH
88542: LD_INT 34
88544: PUSH
88545: LD_INT 35
88547: PUSH
88548: LD_INT 36
88550: PUSH
88551: EMPTY
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: LIST
88574: LIST
88575: LIST
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 101
88591: PUSH
88592: LD_INT 102
88594: PUSH
88595: LD_INT 103
88597: PUSH
88598: LD_INT 104
88600: PUSH
88601: LD_INT 105
88603: PUSH
88604: LD_INT 106
88606: PUSH
88607: LD_INT 107
88609: PUSH
88610: LD_INT 108
88612: PUSH
88613: LD_INT 109
88615: PUSH
88616: LD_INT 110
88618: PUSH
88619: LD_INT 111
88621: PUSH
88622: LD_INT 112
88624: PUSH
88625: LD_INT 113
88627: PUSH
88628: LD_INT 114
88630: PUSH
88631: LD_INT 115
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: LIST
88641: LIST
88642: LIST
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: PUSH
88651: EMPTY
88652: LIST
88653: LIST
88654: ST_TO_ADDR
// if result then
88655: LD_VAR 0 1
88659: IFFALSE 88948
// begin normal :=  ;
88661: LD_ADDR_VAR 0 3
88665: PUSH
88666: LD_STRING 
88668: ST_TO_ADDR
// hardcore :=  ;
88669: LD_ADDR_VAR 0 4
88673: PUSH
88674: LD_STRING 
88676: ST_TO_ADDR
// for i = 1 to normalCounter do
88677: LD_ADDR_VAR 0 5
88681: PUSH
88682: DOUBLE
88683: LD_INT 1
88685: DEC
88686: ST_TO_ADDR
88687: LD_EXP 89
88691: PUSH
88692: FOR_TO
88693: IFFALSE 88794
// begin tmp := 0 ;
88695: LD_ADDR_VAR 0 2
88699: PUSH
88700: LD_STRING 0
88702: ST_TO_ADDR
// if result [ 1 ] then
88703: LD_VAR 0 1
88707: PUSH
88708: LD_INT 1
88710: ARRAY
88711: IFFALSE 88776
// if result [ 1 ] [ 1 ] = i then
88713: LD_VAR 0 1
88717: PUSH
88718: LD_INT 1
88720: ARRAY
88721: PUSH
88722: LD_INT 1
88724: ARRAY
88725: PUSH
88726: LD_VAR 0 5
88730: EQUAL
88731: IFFALSE 88776
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
88733: LD_ADDR_VAR 0 1
88737: PUSH
88738: LD_VAR 0 1
88742: PPUSH
88743: LD_INT 1
88745: PPUSH
88746: LD_VAR 0 1
88750: PUSH
88751: LD_INT 1
88753: ARRAY
88754: PPUSH
88755: LD_INT 1
88757: PPUSH
88758: CALL_OW 3
88762: PPUSH
88763: CALL_OW 1
88767: ST_TO_ADDR
// tmp := 1 ;
88768: LD_ADDR_VAR 0 2
88772: PUSH
88773: LD_STRING 1
88775: ST_TO_ADDR
// end ; normal := normal & tmp ;
88776: LD_ADDR_VAR 0 3
88780: PUSH
88781: LD_VAR 0 3
88785: PUSH
88786: LD_VAR 0 2
88790: STR
88791: ST_TO_ADDR
// end ;
88792: GO 88692
88794: POP
88795: POP
// for i = 1 to hardcoreCounter do
88796: LD_ADDR_VAR 0 5
88800: PUSH
88801: DOUBLE
88802: LD_INT 1
88804: DEC
88805: ST_TO_ADDR
88806: LD_EXP 90
88810: PUSH
88811: FOR_TO
88812: IFFALSE 88917
// begin tmp := 0 ;
88814: LD_ADDR_VAR 0 2
88818: PUSH
88819: LD_STRING 0
88821: ST_TO_ADDR
// if result [ 2 ] then
88822: LD_VAR 0 1
88826: PUSH
88827: LD_INT 2
88829: ARRAY
88830: IFFALSE 88899
// if result [ 2 ] [ 1 ] = 100 + i then
88832: LD_VAR 0 1
88836: PUSH
88837: LD_INT 2
88839: ARRAY
88840: PUSH
88841: LD_INT 1
88843: ARRAY
88844: PUSH
88845: LD_INT 100
88847: PUSH
88848: LD_VAR 0 5
88852: PLUS
88853: EQUAL
88854: IFFALSE 88899
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
88856: LD_ADDR_VAR 0 1
88860: PUSH
88861: LD_VAR 0 1
88865: PPUSH
88866: LD_INT 2
88868: PPUSH
88869: LD_VAR 0 1
88873: PUSH
88874: LD_INT 2
88876: ARRAY
88877: PPUSH
88878: LD_INT 1
88880: PPUSH
88881: CALL_OW 3
88885: PPUSH
88886: CALL_OW 1
88890: ST_TO_ADDR
// tmp := 1 ;
88891: LD_ADDR_VAR 0 2
88895: PUSH
88896: LD_STRING 1
88898: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
88899: LD_ADDR_VAR 0 4
88903: PUSH
88904: LD_VAR 0 4
88908: PUSH
88909: LD_VAR 0 2
88913: STR
88914: ST_TO_ADDR
// end ;
88915: GO 88811
88917: POP
88918: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
88919: LD_STRING getStreamItemsFromMission("
88921: PUSH
88922: LD_VAR 0 3
88926: STR
88927: PUSH
88928: LD_STRING ","
88930: STR
88931: PUSH
88932: LD_VAR 0 4
88936: STR
88937: PUSH
88938: LD_STRING ")
88940: STR
88941: PPUSH
88942: CALL_OW 559
// end else
88946: GO 88955
// ToLua ( getStreamItemsFromMission("","") ) ;
88948: LD_STRING getStreamItemsFromMission("","")
88950: PPUSH
88951: CALL_OW 559
// end ;
88955: LD_VAR 0 1
88959: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
88960: LD_EXP 88
88964: PUSH
88965: LD_EXP 93
88969: AND
88970: IFFALSE 89094
88972: GO 88974
88974: DISABLE
88975: LD_INT 0
88977: PPUSH
88978: PPUSH
// begin enable ;
88979: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
88980: LD_ADDR_VAR 0 2
88984: PUSH
88985: LD_INT 22
88987: PUSH
88988: LD_OWVAR 2
88992: PUSH
88993: EMPTY
88994: LIST
88995: LIST
88996: PUSH
88997: LD_INT 2
88999: PUSH
89000: LD_INT 34
89002: PUSH
89003: LD_INT 7
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 34
89012: PUSH
89013: LD_INT 45
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 34
89022: PUSH
89023: LD_INT 28
89025: PUSH
89026: EMPTY
89027: LIST
89028: LIST
89029: PUSH
89030: LD_INT 34
89032: PUSH
89033: LD_INT 47
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: LIST
89044: LIST
89045: LIST
89046: PUSH
89047: EMPTY
89048: LIST
89049: LIST
89050: PPUSH
89051: CALL_OW 69
89055: ST_TO_ADDR
// if not tmp then
89056: LD_VAR 0 2
89060: NOT
89061: IFFALSE 89065
// exit ;
89063: GO 89094
// for i in tmp do
89065: LD_ADDR_VAR 0 1
89069: PUSH
89070: LD_VAR 0 2
89074: PUSH
89075: FOR_IN
89076: IFFALSE 89092
// begin SetLives ( i , 0 ) ;
89078: LD_VAR 0 1
89082: PPUSH
89083: LD_INT 0
89085: PPUSH
89086: CALL_OW 234
// end ;
89090: GO 89075
89092: POP
89093: POP
// end ;
89094: PPOPN 2
89096: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
89097: LD_EXP 88
89101: PUSH
89102: LD_EXP 94
89106: AND
89107: IFFALSE 89191
89109: GO 89111
89111: DISABLE
89112: LD_INT 0
89114: PPUSH
89115: PPUSH
// begin enable ;
89116: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
89117: LD_ADDR_VAR 0 2
89121: PUSH
89122: LD_INT 22
89124: PUSH
89125: LD_OWVAR 2
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PUSH
89134: LD_INT 32
89136: PUSH
89137: LD_INT 3
89139: PUSH
89140: EMPTY
89141: LIST
89142: LIST
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PPUSH
89148: CALL_OW 69
89152: ST_TO_ADDR
// if not tmp then
89153: LD_VAR 0 2
89157: NOT
89158: IFFALSE 89162
// exit ;
89160: GO 89191
// for i in tmp do
89162: LD_ADDR_VAR 0 1
89166: PUSH
89167: LD_VAR 0 2
89171: PUSH
89172: FOR_IN
89173: IFFALSE 89189
// begin SetLives ( i , 0 ) ;
89175: LD_VAR 0 1
89179: PPUSH
89180: LD_INT 0
89182: PPUSH
89183: CALL_OW 234
// end ;
89187: GO 89172
89189: POP
89190: POP
// end ;
89191: PPOPN 2
89193: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
89194: LD_EXP 88
89198: PUSH
89199: LD_EXP 91
89203: AND
89204: IFFALSE 89297
89206: GO 89208
89208: DISABLE
89209: LD_INT 0
89211: PPUSH
// begin enable ;
89212: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
89213: LD_ADDR_VAR 0 1
89217: PUSH
89218: LD_INT 22
89220: PUSH
89221: LD_OWVAR 2
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 2
89232: PUSH
89233: LD_INT 25
89235: PUSH
89236: LD_INT 5
89238: PUSH
89239: EMPTY
89240: LIST
89241: LIST
89242: PUSH
89243: LD_INT 25
89245: PUSH
89246: LD_INT 9
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 25
89255: PUSH
89256: LD_INT 8
89258: PUSH
89259: EMPTY
89260: LIST
89261: LIST
89262: PUSH
89263: EMPTY
89264: LIST
89265: LIST
89266: LIST
89267: LIST
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PPUSH
89273: CALL_OW 69
89277: PUSH
89278: FOR_IN
89279: IFFALSE 89295
// begin SetClass ( i , 1 ) ;
89281: LD_VAR 0 1
89285: PPUSH
89286: LD_INT 1
89288: PPUSH
89289: CALL_OW 336
// end ;
89293: GO 89278
89295: POP
89296: POP
// end ;
89297: PPOPN 1
89299: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
89300: LD_EXP 88
89304: PUSH
89305: LD_EXP 92
89309: AND
89310: PUSH
89311: LD_OWVAR 65
89315: PUSH
89316: LD_INT 7
89318: LESS
89319: AND
89320: IFFALSE 89334
89322: GO 89324
89324: DISABLE
// begin enable ;
89325: ENABLE
// game_speed := 7 ;
89326: LD_ADDR_OWVAR 65
89330: PUSH
89331: LD_INT 7
89333: ST_TO_ADDR
// end ;
89334: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
89335: LD_EXP 88
89339: PUSH
89340: LD_EXP 95
89344: AND
89345: IFFALSE 89547
89347: GO 89349
89349: DISABLE
89350: LD_INT 0
89352: PPUSH
89353: PPUSH
89354: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
89355: LD_ADDR_VAR 0 3
89359: PUSH
89360: LD_INT 81
89362: PUSH
89363: LD_OWVAR 2
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 21
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: EMPTY
89383: LIST
89384: LIST
89385: PPUSH
89386: CALL_OW 69
89390: ST_TO_ADDR
// if not tmp then
89391: LD_VAR 0 3
89395: NOT
89396: IFFALSE 89400
// exit ;
89398: GO 89547
// if tmp > 5 then
89400: LD_VAR 0 3
89404: PUSH
89405: LD_INT 5
89407: GREATER
89408: IFFALSE 89420
// k := 5 else
89410: LD_ADDR_VAR 0 2
89414: PUSH
89415: LD_INT 5
89417: ST_TO_ADDR
89418: GO 89430
// k := tmp ;
89420: LD_ADDR_VAR 0 2
89424: PUSH
89425: LD_VAR 0 3
89429: ST_TO_ADDR
// for i := 1 to k do
89430: LD_ADDR_VAR 0 1
89434: PUSH
89435: DOUBLE
89436: LD_INT 1
89438: DEC
89439: ST_TO_ADDR
89440: LD_VAR 0 2
89444: PUSH
89445: FOR_TO
89446: IFFALSE 89545
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
89448: LD_VAR 0 3
89452: PUSH
89453: LD_VAR 0 1
89457: ARRAY
89458: PPUSH
89459: LD_VAR 0 1
89463: PUSH
89464: LD_INT 4
89466: MOD
89467: PUSH
89468: LD_INT 1
89470: PLUS
89471: PPUSH
89472: CALL_OW 259
89476: PUSH
89477: LD_INT 10
89479: LESS
89480: IFFALSE 89543
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
89482: LD_VAR 0 3
89486: PUSH
89487: LD_VAR 0 1
89491: ARRAY
89492: PPUSH
89493: LD_VAR 0 1
89497: PUSH
89498: LD_INT 4
89500: MOD
89501: PUSH
89502: LD_INT 1
89504: PLUS
89505: PPUSH
89506: LD_VAR 0 3
89510: PUSH
89511: LD_VAR 0 1
89515: ARRAY
89516: PPUSH
89517: LD_VAR 0 1
89521: PUSH
89522: LD_INT 4
89524: MOD
89525: PUSH
89526: LD_INT 1
89528: PLUS
89529: PPUSH
89530: CALL_OW 259
89534: PUSH
89535: LD_INT 1
89537: PLUS
89538: PPUSH
89539: CALL_OW 237
89543: GO 89445
89545: POP
89546: POP
// end ;
89547: PPOPN 3
89549: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
89550: LD_EXP 88
89554: PUSH
89555: LD_EXP 96
89559: AND
89560: IFFALSE 89580
89562: GO 89564
89564: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
89565: LD_INT 4
89567: PPUSH
89568: LD_OWVAR 2
89572: PPUSH
89573: LD_INT 0
89575: PPUSH
89576: CALL_OW 324
89580: END
// every 0 0$1 trigger StreamModeActive and sShovel do
89581: LD_EXP 88
89585: PUSH
89586: LD_EXP 125
89590: AND
89591: IFFALSE 89611
89593: GO 89595
89595: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
89596: LD_INT 19
89598: PPUSH
89599: LD_OWVAR 2
89603: PPUSH
89604: LD_INT 0
89606: PPUSH
89607: CALL_OW 324
89611: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
89612: LD_EXP 88
89616: PUSH
89617: LD_EXP 97
89621: AND
89622: IFFALSE 89724
89624: GO 89626
89626: DISABLE
89627: LD_INT 0
89629: PPUSH
89630: PPUSH
// begin enable ;
89631: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
89632: LD_ADDR_VAR 0 2
89636: PUSH
89637: LD_INT 22
89639: PUSH
89640: LD_OWVAR 2
89644: PUSH
89645: EMPTY
89646: LIST
89647: LIST
89648: PUSH
89649: LD_INT 2
89651: PUSH
89652: LD_INT 34
89654: PUSH
89655: LD_INT 11
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 34
89664: PUSH
89665: LD_INT 30
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: LIST
89676: PUSH
89677: EMPTY
89678: LIST
89679: LIST
89680: PPUSH
89681: CALL_OW 69
89685: ST_TO_ADDR
// if not tmp then
89686: LD_VAR 0 2
89690: NOT
89691: IFFALSE 89695
// exit ;
89693: GO 89724
// for i in tmp do
89695: LD_ADDR_VAR 0 1
89699: PUSH
89700: LD_VAR 0 2
89704: PUSH
89705: FOR_IN
89706: IFFALSE 89722
// begin SetLives ( i , 0 ) ;
89708: LD_VAR 0 1
89712: PPUSH
89713: LD_INT 0
89715: PPUSH
89716: CALL_OW 234
// end ;
89720: GO 89705
89722: POP
89723: POP
// end ;
89724: PPOPN 2
89726: END
// every 0 0$1 trigger StreamModeActive and sBunker do
89727: LD_EXP 88
89731: PUSH
89732: LD_EXP 98
89736: AND
89737: IFFALSE 89757
89739: GO 89741
89741: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
89742: LD_INT 32
89744: PPUSH
89745: LD_OWVAR 2
89749: PPUSH
89750: LD_INT 0
89752: PPUSH
89753: CALL_OW 324
89757: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
89758: LD_EXP 88
89762: PUSH
89763: LD_EXP 99
89767: AND
89768: IFFALSE 89949
89770: GO 89772
89772: DISABLE
89773: LD_INT 0
89775: PPUSH
89776: PPUSH
89777: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
89778: LD_ADDR_VAR 0 2
89782: PUSH
89783: LD_INT 22
89785: PUSH
89786: LD_OWVAR 2
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 33
89797: PUSH
89798: LD_INT 3
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: EMPTY
89806: LIST
89807: LIST
89808: PPUSH
89809: CALL_OW 69
89813: ST_TO_ADDR
// if not tmp then
89814: LD_VAR 0 2
89818: NOT
89819: IFFALSE 89823
// exit ;
89821: GO 89949
// side := 0 ;
89823: LD_ADDR_VAR 0 3
89827: PUSH
89828: LD_INT 0
89830: ST_TO_ADDR
// for i := 1 to 8 do
89831: LD_ADDR_VAR 0 1
89835: PUSH
89836: DOUBLE
89837: LD_INT 1
89839: DEC
89840: ST_TO_ADDR
89841: LD_INT 8
89843: PUSH
89844: FOR_TO
89845: IFFALSE 89893
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
89847: LD_OWVAR 2
89851: PUSH
89852: LD_VAR 0 1
89856: NONEQUAL
89857: PUSH
89858: LD_OWVAR 2
89862: PPUSH
89863: LD_VAR 0 1
89867: PPUSH
89868: CALL_OW 81
89872: PUSH
89873: LD_INT 2
89875: EQUAL
89876: AND
89877: IFFALSE 89891
// begin side := i ;
89879: LD_ADDR_VAR 0 3
89883: PUSH
89884: LD_VAR 0 1
89888: ST_TO_ADDR
// break ;
89889: GO 89893
// end ;
89891: GO 89844
89893: POP
89894: POP
// if not side then
89895: LD_VAR 0 3
89899: NOT
89900: IFFALSE 89904
// exit ;
89902: GO 89949
// for i := 1 to tmp do
89904: LD_ADDR_VAR 0 1
89908: PUSH
89909: DOUBLE
89910: LD_INT 1
89912: DEC
89913: ST_TO_ADDR
89914: LD_VAR 0 2
89918: PUSH
89919: FOR_TO
89920: IFFALSE 89947
// if Prob ( 60 ) then
89922: LD_INT 60
89924: PPUSH
89925: CALL_OW 13
89929: IFFALSE 89945
// SetSide ( i , side ) ;
89931: LD_VAR 0 1
89935: PPUSH
89936: LD_VAR 0 3
89940: PPUSH
89941: CALL_OW 235
89945: GO 89919
89947: POP
89948: POP
// end ;
89949: PPOPN 3
89951: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
89952: LD_EXP 88
89956: PUSH
89957: LD_EXP 101
89961: AND
89962: IFFALSE 90081
89964: GO 89966
89966: DISABLE
89967: LD_INT 0
89969: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
89970: LD_ADDR_VAR 0 1
89974: PUSH
89975: LD_INT 22
89977: PUSH
89978: LD_OWVAR 2
89982: PUSH
89983: EMPTY
89984: LIST
89985: LIST
89986: PUSH
89987: LD_INT 21
89989: PUSH
89990: LD_INT 1
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 3
89999: PUSH
90000: LD_INT 23
90002: PUSH
90003: LD_INT 0
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: EMPTY
90011: LIST
90012: LIST
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: LIST
90018: PPUSH
90019: CALL_OW 69
90023: PUSH
90024: FOR_IN
90025: IFFALSE 90079
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
90027: LD_VAR 0 1
90031: PPUSH
90032: CALL_OW 257
90036: PUSH
90037: LD_INT 1
90039: PUSH
90040: LD_INT 2
90042: PUSH
90043: LD_INT 3
90045: PUSH
90046: LD_INT 4
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: IN
90055: IFFALSE 90077
// SetClass ( un , rand ( 1 , 4 ) ) ;
90057: LD_VAR 0 1
90061: PPUSH
90062: LD_INT 1
90064: PPUSH
90065: LD_INT 4
90067: PPUSH
90068: CALL_OW 12
90072: PPUSH
90073: CALL_OW 336
90077: GO 90024
90079: POP
90080: POP
// end ;
90081: PPOPN 1
90083: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
90084: LD_EXP 88
90088: PUSH
90089: LD_EXP 100
90093: AND
90094: IFFALSE 90173
90096: GO 90098
90098: DISABLE
90099: LD_INT 0
90101: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90102: LD_ADDR_VAR 0 1
90106: PUSH
90107: LD_INT 22
90109: PUSH
90110: LD_OWVAR 2
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 21
90121: PUSH
90122: LD_INT 3
90124: PUSH
90125: EMPTY
90126: LIST
90127: LIST
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PPUSH
90133: CALL_OW 69
90137: ST_TO_ADDR
// if not tmp then
90138: LD_VAR 0 1
90142: NOT
90143: IFFALSE 90147
// exit ;
90145: GO 90173
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
90147: LD_VAR 0 1
90151: PUSH
90152: LD_INT 1
90154: PPUSH
90155: LD_VAR 0 1
90159: PPUSH
90160: CALL_OW 12
90164: ARRAY
90165: PPUSH
90166: LD_INT 100
90168: PPUSH
90169: CALL_OW 234
// end ;
90173: PPOPN 1
90175: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
90176: LD_EXP 88
90180: PUSH
90181: LD_EXP 102
90185: AND
90186: IFFALSE 90284
90188: GO 90190
90190: DISABLE
90191: LD_INT 0
90193: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90194: LD_ADDR_VAR 0 1
90198: PUSH
90199: LD_INT 22
90201: PUSH
90202: LD_OWVAR 2
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 21
90213: PUSH
90214: LD_INT 1
90216: PUSH
90217: EMPTY
90218: LIST
90219: LIST
90220: PUSH
90221: EMPTY
90222: LIST
90223: LIST
90224: PPUSH
90225: CALL_OW 69
90229: ST_TO_ADDR
// if not tmp then
90230: LD_VAR 0 1
90234: NOT
90235: IFFALSE 90239
// exit ;
90237: GO 90284
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
90239: LD_VAR 0 1
90243: PUSH
90244: LD_INT 1
90246: PPUSH
90247: LD_VAR 0 1
90251: PPUSH
90252: CALL_OW 12
90256: ARRAY
90257: PPUSH
90258: LD_INT 1
90260: PPUSH
90261: LD_INT 4
90263: PPUSH
90264: CALL_OW 12
90268: PPUSH
90269: LD_INT 3000
90271: PPUSH
90272: LD_INT 9000
90274: PPUSH
90275: CALL_OW 12
90279: PPUSH
90280: CALL_OW 492
// end ;
90284: PPOPN 1
90286: END
// every 0 0$1 trigger StreamModeActive and sDepot do
90287: LD_EXP 88
90291: PUSH
90292: LD_EXP 103
90296: AND
90297: IFFALSE 90317
90299: GO 90301
90301: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
90302: LD_INT 1
90304: PPUSH
90305: LD_OWVAR 2
90309: PPUSH
90310: LD_INT 0
90312: PPUSH
90313: CALL_OW 324
90317: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
90318: LD_EXP 88
90322: PUSH
90323: LD_EXP 104
90327: AND
90328: IFFALSE 90411
90330: GO 90332
90332: DISABLE
90333: LD_INT 0
90335: PPUSH
90336: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
90337: LD_ADDR_VAR 0 2
90341: PUSH
90342: LD_INT 22
90344: PUSH
90345: LD_OWVAR 2
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 21
90356: PUSH
90357: LD_INT 3
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PPUSH
90368: CALL_OW 69
90372: ST_TO_ADDR
// if not tmp then
90373: LD_VAR 0 2
90377: NOT
90378: IFFALSE 90382
// exit ;
90380: GO 90411
// for i in tmp do
90382: LD_ADDR_VAR 0 1
90386: PUSH
90387: LD_VAR 0 2
90391: PUSH
90392: FOR_IN
90393: IFFALSE 90409
// SetBLevel ( i , 10 ) ;
90395: LD_VAR 0 1
90399: PPUSH
90400: LD_INT 10
90402: PPUSH
90403: CALL_OW 241
90407: GO 90392
90409: POP
90410: POP
// end ;
90411: PPOPN 2
90413: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
90414: LD_EXP 88
90418: PUSH
90419: LD_EXP 105
90423: AND
90424: IFFALSE 90535
90426: GO 90428
90428: DISABLE
90429: LD_INT 0
90431: PPUSH
90432: PPUSH
90433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90434: LD_ADDR_VAR 0 3
90438: PUSH
90439: LD_INT 22
90441: PUSH
90442: LD_OWVAR 2
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 25
90453: PUSH
90454: LD_INT 1
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PPUSH
90465: CALL_OW 69
90469: ST_TO_ADDR
// if not tmp then
90470: LD_VAR 0 3
90474: NOT
90475: IFFALSE 90479
// exit ;
90477: GO 90535
// un := tmp [ rand ( 1 , tmp ) ] ;
90479: LD_ADDR_VAR 0 2
90483: PUSH
90484: LD_VAR 0 3
90488: PUSH
90489: LD_INT 1
90491: PPUSH
90492: LD_VAR 0 3
90496: PPUSH
90497: CALL_OW 12
90501: ARRAY
90502: ST_TO_ADDR
// if Crawls ( un ) then
90503: LD_VAR 0 2
90507: PPUSH
90508: CALL_OW 318
90512: IFFALSE 90523
// ComWalk ( un ) ;
90514: LD_VAR 0 2
90518: PPUSH
90519: CALL_OW 138
// SetClass ( un , class_sniper ) ;
90523: LD_VAR 0 2
90527: PPUSH
90528: LD_INT 5
90530: PPUSH
90531: CALL_OW 336
// end ;
90535: PPOPN 3
90537: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
90538: LD_EXP 88
90542: PUSH
90543: LD_EXP 106
90547: AND
90548: PUSH
90549: LD_OWVAR 67
90553: PUSH
90554: LD_INT 3
90556: LESS
90557: AND
90558: IFFALSE 90577
90560: GO 90562
90562: DISABLE
// Difficulty := Difficulty + 1 ;
90563: LD_ADDR_OWVAR 67
90567: PUSH
90568: LD_OWVAR 67
90572: PUSH
90573: LD_INT 1
90575: PLUS
90576: ST_TO_ADDR
90577: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
90578: LD_EXP 88
90582: PUSH
90583: LD_EXP 107
90587: AND
90588: IFFALSE 90691
90590: GO 90592
90592: DISABLE
90593: LD_INT 0
90595: PPUSH
// begin for i := 1 to 5 do
90596: LD_ADDR_VAR 0 1
90600: PUSH
90601: DOUBLE
90602: LD_INT 1
90604: DEC
90605: ST_TO_ADDR
90606: LD_INT 5
90608: PUSH
90609: FOR_TO
90610: IFFALSE 90689
// begin uc_nation := nation_nature ;
90612: LD_ADDR_OWVAR 21
90616: PUSH
90617: LD_INT 0
90619: ST_TO_ADDR
// uc_side := 0 ;
90620: LD_ADDR_OWVAR 20
90624: PUSH
90625: LD_INT 0
90627: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
90628: LD_ADDR_OWVAR 29
90632: PUSH
90633: LD_INT 12
90635: PUSH
90636: LD_INT 12
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: ST_TO_ADDR
// hc_agressivity := 20 ;
90643: LD_ADDR_OWVAR 35
90647: PUSH
90648: LD_INT 20
90650: ST_TO_ADDR
// hc_class := class_tiger ;
90651: LD_ADDR_OWVAR 28
90655: PUSH
90656: LD_INT 14
90658: ST_TO_ADDR
// hc_gallery :=  ;
90659: LD_ADDR_OWVAR 33
90663: PUSH
90664: LD_STRING 
90666: ST_TO_ADDR
// hc_name :=  ;
90667: LD_ADDR_OWVAR 26
90671: PUSH
90672: LD_STRING 
90674: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
90675: CALL_OW 44
90679: PPUSH
90680: LD_INT 0
90682: PPUSH
90683: CALL_OW 51
// end ;
90687: GO 90609
90689: POP
90690: POP
// end ;
90691: PPOPN 1
90693: END
// every 0 0$1 trigger StreamModeActive and sBomb do
90694: LD_EXP 88
90698: PUSH
90699: LD_EXP 108
90703: AND
90704: IFFALSE 90713
90706: GO 90708
90708: DISABLE
// StreamSibBomb ;
90709: CALL 90714 0 0
90713: END
// export function StreamSibBomb ; var i , x , y ; begin
90714: LD_INT 0
90716: PPUSH
90717: PPUSH
90718: PPUSH
90719: PPUSH
// result := false ;
90720: LD_ADDR_VAR 0 1
90724: PUSH
90725: LD_INT 0
90727: ST_TO_ADDR
// for i := 1 to 16 do
90728: LD_ADDR_VAR 0 2
90732: PUSH
90733: DOUBLE
90734: LD_INT 1
90736: DEC
90737: ST_TO_ADDR
90738: LD_INT 16
90740: PUSH
90741: FOR_TO
90742: IFFALSE 90941
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90744: LD_ADDR_VAR 0 3
90748: PUSH
90749: LD_INT 10
90751: PUSH
90752: LD_INT 20
90754: PUSH
90755: LD_INT 30
90757: PUSH
90758: LD_INT 40
90760: PUSH
90761: LD_INT 50
90763: PUSH
90764: LD_INT 60
90766: PUSH
90767: LD_INT 70
90769: PUSH
90770: LD_INT 80
90772: PUSH
90773: LD_INT 90
90775: PUSH
90776: LD_INT 100
90778: PUSH
90779: LD_INT 110
90781: PUSH
90782: LD_INT 120
90784: PUSH
90785: LD_INT 130
90787: PUSH
90788: LD_INT 140
90790: PUSH
90791: LD_INT 150
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 1
90813: PPUSH
90814: LD_INT 15
90816: PPUSH
90817: CALL_OW 12
90821: ARRAY
90822: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
90823: LD_ADDR_VAR 0 4
90827: PUSH
90828: LD_INT 10
90830: PUSH
90831: LD_INT 20
90833: PUSH
90834: LD_INT 30
90836: PUSH
90837: LD_INT 40
90839: PUSH
90840: LD_INT 50
90842: PUSH
90843: LD_INT 60
90845: PUSH
90846: LD_INT 70
90848: PUSH
90849: LD_INT 80
90851: PUSH
90852: LD_INT 90
90854: PUSH
90855: LD_INT 100
90857: PUSH
90858: LD_INT 110
90860: PUSH
90861: LD_INT 120
90863: PUSH
90864: LD_INT 130
90866: PUSH
90867: LD_INT 140
90869: PUSH
90870: LD_INT 150
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: PUSH
90890: LD_INT 1
90892: PPUSH
90893: LD_INT 15
90895: PPUSH
90896: CALL_OW 12
90900: ARRAY
90901: ST_TO_ADDR
// if ValidHex ( x , y ) then
90902: LD_VAR 0 3
90906: PPUSH
90907: LD_VAR 0 4
90911: PPUSH
90912: CALL_OW 488
90916: IFFALSE 90939
// begin result := [ x , y ] ;
90918: LD_ADDR_VAR 0 1
90922: PUSH
90923: LD_VAR 0 3
90927: PUSH
90928: LD_VAR 0 4
90932: PUSH
90933: EMPTY
90934: LIST
90935: LIST
90936: ST_TO_ADDR
// break ;
90937: GO 90941
// end ; end ;
90939: GO 90741
90941: POP
90942: POP
// if result then
90943: LD_VAR 0 1
90947: IFFALSE 91007
// begin ToLua ( playSibBomb() ) ;
90949: LD_STRING playSibBomb()
90951: PPUSH
90952: CALL_OW 559
// wait ( 0 0$14 ) ;
90956: LD_INT 490
90958: PPUSH
90959: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
90963: LD_VAR 0 1
90967: PUSH
90968: LD_INT 1
90970: ARRAY
90971: PPUSH
90972: LD_VAR 0 1
90976: PUSH
90977: LD_INT 2
90979: ARRAY
90980: PPUSH
90981: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
90985: LD_VAR 0 1
90989: PUSH
90990: LD_INT 1
90992: ARRAY
90993: PPUSH
90994: LD_VAR 0 1
90998: PUSH
90999: LD_INT 2
91001: ARRAY
91002: PPUSH
91003: CALL_OW 429
// end ; end ;
91007: LD_VAR 0 1
91011: RET
// every 0 0$1 trigger StreamModeActive and sReset do
91012: LD_EXP 88
91016: PUSH
91017: LD_EXP 110
91021: AND
91022: IFFALSE 91034
91024: GO 91026
91026: DISABLE
// YouLost (  ) ;
91027: LD_STRING 
91029: PPUSH
91030: CALL_OW 104
91034: END
// every 0 0$1 trigger StreamModeActive and sFog do
91035: LD_EXP 88
91039: PUSH
91040: LD_EXP 109
91044: AND
91045: IFFALSE 91059
91047: GO 91049
91049: DISABLE
// FogOff ( your_side ) ;
91050: LD_OWVAR 2
91054: PPUSH
91055: CALL_OW 344
91059: END
// every 0 0$1 trigger StreamModeActive and sSun do
91060: LD_EXP 88
91064: PUSH
91065: LD_EXP 111
91069: AND
91070: IFFALSE 91098
91072: GO 91074
91074: DISABLE
// begin solar_recharge_percent := 0 ;
91075: LD_ADDR_OWVAR 79
91079: PUSH
91080: LD_INT 0
91082: ST_TO_ADDR
// wait ( 5 5$00 ) ;
91083: LD_INT 10500
91085: PPUSH
91086: CALL_OW 67
// solar_recharge_percent := 100 ;
91090: LD_ADDR_OWVAR 79
91094: PUSH
91095: LD_INT 100
91097: ST_TO_ADDR
// end ;
91098: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
91099: LD_EXP 88
91103: PUSH
91104: LD_EXP 112
91108: AND
91109: IFFALSE 91348
91111: GO 91113
91113: DISABLE
91114: LD_INT 0
91116: PPUSH
91117: PPUSH
91118: PPUSH
// begin tmp := [ ] ;
91119: LD_ADDR_VAR 0 3
91123: PUSH
91124: EMPTY
91125: ST_TO_ADDR
// for i := 1 to 6 do
91126: LD_ADDR_VAR 0 1
91130: PUSH
91131: DOUBLE
91132: LD_INT 1
91134: DEC
91135: ST_TO_ADDR
91136: LD_INT 6
91138: PUSH
91139: FOR_TO
91140: IFFALSE 91245
// begin uc_nation := nation_nature ;
91142: LD_ADDR_OWVAR 21
91146: PUSH
91147: LD_INT 0
91149: ST_TO_ADDR
// uc_side := 0 ;
91150: LD_ADDR_OWVAR 20
91154: PUSH
91155: LD_INT 0
91157: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91158: LD_ADDR_OWVAR 29
91162: PUSH
91163: LD_INT 12
91165: PUSH
91166: LD_INT 12
91168: PUSH
91169: EMPTY
91170: LIST
91171: LIST
91172: ST_TO_ADDR
// hc_agressivity := 20 ;
91173: LD_ADDR_OWVAR 35
91177: PUSH
91178: LD_INT 20
91180: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
91181: LD_ADDR_OWVAR 28
91185: PUSH
91186: LD_INT 17
91188: ST_TO_ADDR
// hc_gallery :=  ;
91189: LD_ADDR_OWVAR 33
91193: PUSH
91194: LD_STRING 
91196: ST_TO_ADDR
// hc_name :=  ;
91197: LD_ADDR_OWVAR 26
91201: PUSH
91202: LD_STRING 
91204: ST_TO_ADDR
// un := CreateHuman ;
91205: LD_ADDR_VAR 0 2
91209: PUSH
91210: CALL_OW 44
91214: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
91215: LD_VAR 0 2
91219: PPUSH
91220: LD_INT 1
91222: PPUSH
91223: CALL_OW 51
// tmp := tmp ^ un ;
91227: LD_ADDR_VAR 0 3
91231: PUSH
91232: LD_VAR 0 3
91236: PUSH
91237: LD_VAR 0 2
91241: ADD
91242: ST_TO_ADDR
// end ;
91243: GO 91139
91245: POP
91246: POP
// repeat wait ( 0 0$1 ) ;
91247: LD_INT 35
91249: PPUSH
91250: CALL_OW 67
// for un in tmp do
91254: LD_ADDR_VAR 0 2
91258: PUSH
91259: LD_VAR 0 3
91263: PUSH
91264: FOR_IN
91265: IFFALSE 91339
// begin if IsDead ( un ) then
91267: LD_VAR 0 2
91271: PPUSH
91272: CALL_OW 301
91276: IFFALSE 91296
// begin tmp := tmp diff un ;
91278: LD_ADDR_VAR 0 3
91282: PUSH
91283: LD_VAR 0 3
91287: PUSH
91288: LD_VAR 0 2
91292: DIFF
91293: ST_TO_ADDR
// continue ;
91294: GO 91264
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
91296: LD_VAR 0 2
91300: PPUSH
91301: LD_INT 3
91303: PUSH
91304: LD_INT 22
91306: PUSH
91307: LD_INT 0
91309: PUSH
91310: EMPTY
91311: LIST
91312: LIST
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PPUSH
91318: CALL_OW 69
91322: PPUSH
91323: LD_VAR 0 2
91327: PPUSH
91328: CALL_OW 74
91332: PPUSH
91333: CALL_OW 115
// end ;
91337: GO 91264
91339: POP
91340: POP
// until not tmp ;
91341: LD_VAR 0 3
91345: NOT
91346: IFFALSE 91247
// end ;
91348: PPOPN 3
91350: END
// every 0 0$1 trigger StreamModeActive and sTroll do
91351: LD_EXP 88
91355: PUSH
91356: LD_EXP 113
91360: AND
91361: IFFALSE 91415
91363: GO 91365
91365: DISABLE
// begin ToLua ( displayTroll(); ) ;
91366: LD_STRING displayTroll();
91368: PPUSH
91369: CALL_OW 559
// wait ( 3 3$00 ) ;
91373: LD_INT 6300
91375: PPUSH
91376: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91380: LD_STRING hideTroll();
91382: PPUSH
91383: CALL_OW 559
// wait ( 1 1$00 ) ;
91387: LD_INT 2100
91389: PPUSH
91390: CALL_OW 67
// ToLua ( displayTroll(); ) ;
91394: LD_STRING displayTroll();
91396: PPUSH
91397: CALL_OW 559
// wait ( 1 1$00 ) ;
91401: LD_INT 2100
91403: PPUSH
91404: CALL_OW 67
// ToLua ( hideTroll(); ) ;
91408: LD_STRING hideTroll();
91410: PPUSH
91411: CALL_OW 559
// end ;
91415: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
91416: LD_EXP 88
91420: PUSH
91421: LD_EXP 114
91425: AND
91426: IFFALSE 91489
91428: GO 91430
91430: DISABLE
91431: LD_INT 0
91433: PPUSH
// begin p := 0 ;
91434: LD_ADDR_VAR 0 1
91438: PUSH
91439: LD_INT 0
91441: ST_TO_ADDR
// repeat game_speed := 1 ;
91442: LD_ADDR_OWVAR 65
91446: PUSH
91447: LD_INT 1
91449: ST_TO_ADDR
// wait ( 0 0$1 ) ;
91450: LD_INT 35
91452: PPUSH
91453: CALL_OW 67
// p := p + 1 ;
91457: LD_ADDR_VAR 0 1
91461: PUSH
91462: LD_VAR 0 1
91466: PUSH
91467: LD_INT 1
91469: PLUS
91470: ST_TO_ADDR
// until p >= 60 ;
91471: LD_VAR 0 1
91475: PUSH
91476: LD_INT 60
91478: GREATEREQUAL
91479: IFFALSE 91442
// game_speed := 4 ;
91481: LD_ADDR_OWVAR 65
91485: PUSH
91486: LD_INT 4
91488: ST_TO_ADDR
// end ;
91489: PPOPN 1
91491: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
91492: LD_EXP 88
91496: PUSH
91497: LD_EXP 115
91501: AND
91502: IFFALSE 91648
91504: GO 91506
91506: DISABLE
91507: LD_INT 0
91509: PPUSH
91510: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
91511: LD_ADDR_VAR 0 1
91515: PUSH
91516: LD_INT 22
91518: PUSH
91519: LD_OWVAR 2
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 2
91530: PUSH
91531: LD_INT 30
91533: PUSH
91534: LD_INT 0
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 30
91543: PUSH
91544: LD_INT 1
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: EMPTY
91552: LIST
91553: LIST
91554: LIST
91555: PUSH
91556: EMPTY
91557: LIST
91558: LIST
91559: PPUSH
91560: CALL_OW 69
91564: ST_TO_ADDR
// if not depot then
91565: LD_VAR 0 1
91569: NOT
91570: IFFALSE 91574
// exit ;
91572: GO 91648
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
91574: LD_ADDR_VAR 0 2
91578: PUSH
91579: LD_VAR 0 1
91583: PUSH
91584: LD_INT 1
91586: PPUSH
91587: LD_VAR 0 1
91591: PPUSH
91592: CALL_OW 12
91596: ARRAY
91597: PPUSH
91598: CALL_OW 274
91602: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
91603: LD_VAR 0 2
91607: PPUSH
91608: LD_INT 1
91610: PPUSH
91611: LD_INT 0
91613: PPUSH
91614: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
91618: LD_VAR 0 2
91622: PPUSH
91623: LD_INT 2
91625: PPUSH
91626: LD_INT 0
91628: PPUSH
91629: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
91633: LD_VAR 0 2
91637: PPUSH
91638: LD_INT 3
91640: PPUSH
91641: LD_INT 0
91643: PPUSH
91644: CALL_OW 277
// end ;
91648: PPOPN 2
91650: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
91651: LD_EXP 88
91655: PUSH
91656: LD_EXP 116
91660: AND
91661: IFFALSE 91758
91663: GO 91665
91665: DISABLE
91666: LD_INT 0
91668: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91669: LD_ADDR_VAR 0 1
91673: PUSH
91674: LD_INT 22
91676: PUSH
91677: LD_OWVAR 2
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 21
91688: PUSH
91689: LD_INT 1
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 3
91698: PUSH
91699: LD_INT 23
91701: PUSH
91702: LD_INT 0
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: LIST
91717: PPUSH
91718: CALL_OW 69
91722: ST_TO_ADDR
// if not tmp then
91723: LD_VAR 0 1
91727: NOT
91728: IFFALSE 91732
// exit ;
91730: GO 91758
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
91732: LD_VAR 0 1
91736: PUSH
91737: LD_INT 1
91739: PPUSH
91740: LD_VAR 0 1
91744: PPUSH
91745: CALL_OW 12
91749: ARRAY
91750: PPUSH
91751: LD_INT 200
91753: PPUSH
91754: CALL_OW 234
// end ;
91758: PPOPN 1
91760: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
91761: LD_EXP 88
91765: PUSH
91766: LD_EXP 117
91770: AND
91771: IFFALSE 91850
91773: GO 91775
91775: DISABLE
91776: LD_INT 0
91778: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
91779: LD_ADDR_VAR 0 1
91783: PUSH
91784: LD_INT 22
91786: PUSH
91787: LD_OWVAR 2
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 21
91798: PUSH
91799: LD_INT 2
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: PPUSH
91810: CALL_OW 69
91814: ST_TO_ADDR
// if not tmp then
91815: LD_VAR 0 1
91819: NOT
91820: IFFALSE 91824
// exit ;
91822: GO 91850
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
91824: LD_VAR 0 1
91828: PUSH
91829: LD_INT 1
91831: PPUSH
91832: LD_VAR 0 1
91836: PPUSH
91837: CALL_OW 12
91841: ARRAY
91842: PPUSH
91843: LD_INT 60
91845: PPUSH
91846: CALL_OW 234
// end ;
91850: PPOPN 1
91852: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
91853: LD_EXP 88
91857: PUSH
91858: LD_EXP 118
91862: AND
91863: IFFALSE 91962
91865: GO 91867
91867: DISABLE
91868: LD_INT 0
91870: PPUSH
91871: PPUSH
// begin enable ;
91872: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
91873: LD_ADDR_VAR 0 1
91877: PUSH
91878: LD_INT 22
91880: PUSH
91881: LD_OWVAR 2
91885: PUSH
91886: EMPTY
91887: LIST
91888: LIST
91889: PUSH
91890: LD_INT 61
91892: PUSH
91893: EMPTY
91894: LIST
91895: PUSH
91896: LD_INT 33
91898: PUSH
91899: LD_INT 2
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: LIST
91910: PPUSH
91911: CALL_OW 69
91915: ST_TO_ADDR
// if not tmp then
91916: LD_VAR 0 1
91920: NOT
91921: IFFALSE 91925
// exit ;
91923: GO 91962
// for i in tmp do
91925: LD_ADDR_VAR 0 2
91929: PUSH
91930: LD_VAR 0 1
91934: PUSH
91935: FOR_IN
91936: IFFALSE 91960
// if IsControledBy ( i ) then
91938: LD_VAR 0 2
91942: PPUSH
91943: CALL_OW 312
91947: IFFALSE 91958
// ComUnlink ( i ) ;
91949: LD_VAR 0 2
91953: PPUSH
91954: CALL_OW 136
91958: GO 91935
91960: POP
91961: POP
// end ;
91962: PPOPN 2
91964: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
91965: LD_EXP 88
91969: PUSH
91970: LD_EXP 119
91974: AND
91975: IFFALSE 92115
91977: GO 91979
91979: DISABLE
91980: LD_INT 0
91982: PPUSH
91983: PPUSH
// begin ToLua ( displayPowell(); ) ;
91984: LD_STRING displayPowell();
91986: PPUSH
91987: CALL_OW 559
// uc_side := 0 ;
91991: LD_ADDR_OWVAR 20
91995: PUSH
91996: LD_INT 0
91998: ST_TO_ADDR
// uc_nation := 2 ;
91999: LD_ADDR_OWVAR 21
92003: PUSH
92004: LD_INT 2
92006: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
92007: LD_ADDR_OWVAR 37
92011: PUSH
92012: LD_INT 14
92014: ST_TO_ADDR
// vc_engine := engine_siberite ;
92015: LD_ADDR_OWVAR 39
92019: PUSH
92020: LD_INT 3
92022: ST_TO_ADDR
// vc_control := control_apeman ;
92023: LD_ADDR_OWVAR 38
92027: PUSH
92028: LD_INT 5
92030: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
92031: LD_ADDR_OWVAR 40
92035: PUSH
92036: LD_INT 29
92038: ST_TO_ADDR
// un := CreateVehicle ;
92039: LD_ADDR_VAR 0 2
92043: PUSH
92044: CALL_OW 45
92048: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92049: LD_VAR 0 2
92053: PPUSH
92054: LD_INT 1
92056: PPUSH
92057: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92061: LD_INT 35
92063: PPUSH
92064: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92068: LD_VAR 0 2
92072: PPUSH
92073: LD_INT 22
92075: PUSH
92076: LD_OWVAR 2
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PPUSH
92085: CALL_OW 69
92089: PPUSH
92090: LD_VAR 0 2
92094: PPUSH
92095: CALL_OW 74
92099: PPUSH
92100: CALL_OW 115
// until IsDead ( un ) ;
92104: LD_VAR 0 2
92108: PPUSH
92109: CALL_OW 301
92113: IFFALSE 92061
// end ;
92115: PPOPN 2
92117: END
// every 0 0$1 trigger StreamModeActive and sStu do
92118: LD_EXP 88
92122: PUSH
92123: LD_EXP 127
92127: AND
92128: IFFALSE 92144
92130: GO 92132
92132: DISABLE
// begin ToLua ( displayStucuk(); ) ;
92133: LD_STRING displayStucuk();
92135: PPUSH
92136: CALL_OW 559
// ResetFog ;
92140: CALL_OW 335
// end ;
92144: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
92145: LD_EXP 88
92149: PUSH
92150: LD_EXP 120
92154: AND
92155: IFFALSE 92296
92157: GO 92159
92159: DISABLE
92160: LD_INT 0
92162: PPUSH
92163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92164: LD_ADDR_VAR 0 2
92168: PUSH
92169: LD_INT 22
92171: PUSH
92172: LD_OWVAR 2
92176: PUSH
92177: EMPTY
92178: LIST
92179: LIST
92180: PUSH
92181: LD_INT 21
92183: PUSH
92184: LD_INT 1
92186: PUSH
92187: EMPTY
92188: LIST
92189: LIST
92190: PUSH
92191: EMPTY
92192: LIST
92193: LIST
92194: PPUSH
92195: CALL_OW 69
92199: ST_TO_ADDR
// if not tmp then
92200: LD_VAR 0 2
92204: NOT
92205: IFFALSE 92209
// exit ;
92207: GO 92296
// un := tmp [ rand ( 1 , tmp ) ] ;
92209: LD_ADDR_VAR 0 1
92213: PUSH
92214: LD_VAR 0 2
92218: PUSH
92219: LD_INT 1
92221: PPUSH
92222: LD_VAR 0 2
92226: PPUSH
92227: CALL_OW 12
92231: ARRAY
92232: ST_TO_ADDR
// SetSide ( un , 0 ) ;
92233: LD_VAR 0 1
92237: PPUSH
92238: LD_INT 0
92240: PPUSH
92241: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
92245: LD_VAR 0 1
92249: PPUSH
92250: LD_OWVAR 3
92254: PUSH
92255: LD_VAR 0 1
92259: DIFF
92260: PPUSH
92261: LD_VAR 0 1
92265: PPUSH
92266: CALL_OW 74
92270: PPUSH
92271: CALL_OW 115
// wait ( 0 0$20 ) ;
92275: LD_INT 700
92277: PPUSH
92278: CALL_OW 67
// SetSide ( un , your_side ) ;
92282: LD_VAR 0 1
92286: PPUSH
92287: LD_OWVAR 2
92291: PPUSH
92292: CALL_OW 235
// end ;
92296: PPOPN 2
92298: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
92299: LD_EXP 88
92303: PUSH
92304: LD_EXP 121
92308: AND
92309: IFFALSE 92415
92311: GO 92313
92313: DISABLE
92314: LD_INT 0
92316: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92317: LD_ADDR_VAR 0 1
92321: PUSH
92322: LD_INT 22
92324: PUSH
92325: LD_OWVAR 2
92329: PUSH
92330: EMPTY
92331: LIST
92332: LIST
92333: PUSH
92334: LD_INT 2
92336: PUSH
92337: LD_INT 30
92339: PUSH
92340: LD_INT 0
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 30
92349: PUSH
92350: LD_INT 1
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: LIST
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PPUSH
92366: CALL_OW 69
92370: ST_TO_ADDR
// if not depot then
92371: LD_VAR 0 1
92375: NOT
92376: IFFALSE 92380
// exit ;
92378: GO 92415
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
92380: LD_VAR 0 1
92384: PUSH
92385: LD_INT 1
92387: ARRAY
92388: PPUSH
92389: CALL_OW 250
92393: PPUSH
92394: LD_VAR 0 1
92398: PUSH
92399: LD_INT 1
92401: ARRAY
92402: PPUSH
92403: CALL_OW 251
92407: PPUSH
92408: LD_INT 70
92410: PPUSH
92411: CALL_OW 495
// end ;
92415: PPOPN 1
92417: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
92418: LD_EXP 88
92422: PUSH
92423: LD_EXP 122
92427: AND
92428: IFFALSE 92639
92430: GO 92432
92432: DISABLE
92433: LD_INT 0
92435: PPUSH
92436: PPUSH
92437: PPUSH
92438: PPUSH
92439: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92440: LD_ADDR_VAR 0 5
92444: PUSH
92445: LD_INT 22
92447: PUSH
92448: LD_OWVAR 2
92452: PUSH
92453: EMPTY
92454: LIST
92455: LIST
92456: PUSH
92457: LD_INT 21
92459: PUSH
92460: LD_INT 1
92462: PUSH
92463: EMPTY
92464: LIST
92465: LIST
92466: PUSH
92467: EMPTY
92468: LIST
92469: LIST
92470: PPUSH
92471: CALL_OW 69
92475: ST_TO_ADDR
// if not tmp then
92476: LD_VAR 0 5
92480: NOT
92481: IFFALSE 92485
// exit ;
92483: GO 92639
// for i in tmp do
92485: LD_ADDR_VAR 0 1
92489: PUSH
92490: LD_VAR 0 5
92494: PUSH
92495: FOR_IN
92496: IFFALSE 92637
// begin d := rand ( 0 , 5 ) ;
92498: LD_ADDR_VAR 0 4
92502: PUSH
92503: LD_INT 0
92505: PPUSH
92506: LD_INT 5
92508: PPUSH
92509: CALL_OW 12
92513: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
92514: LD_ADDR_VAR 0 2
92518: PUSH
92519: LD_VAR 0 1
92523: PPUSH
92524: CALL_OW 250
92528: PPUSH
92529: LD_VAR 0 4
92533: PPUSH
92534: LD_INT 3
92536: PPUSH
92537: LD_INT 12
92539: PPUSH
92540: CALL_OW 12
92544: PPUSH
92545: CALL_OW 272
92549: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
92550: LD_ADDR_VAR 0 3
92554: PUSH
92555: LD_VAR 0 1
92559: PPUSH
92560: CALL_OW 251
92564: PPUSH
92565: LD_VAR 0 4
92569: PPUSH
92570: LD_INT 3
92572: PPUSH
92573: LD_INT 12
92575: PPUSH
92576: CALL_OW 12
92580: PPUSH
92581: CALL_OW 273
92585: ST_TO_ADDR
// if ValidHex ( x , y ) then
92586: LD_VAR 0 2
92590: PPUSH
92591: LD_VAR 0 3
92595: PPUSH
92596: CALL_OW 488
92600: IFFALSE 92635
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
92602: LD_VAR 0 1
92606: PPUSH
92607: LD_VAR 0 2
92611: PPUSH
92612: LD_VAR 0 3
92616: PPUSH
92617: LD_INT 3
92619: PPUSH
92620: LD_INT 6
92622: PPUSH
92623: CALL_OW 12
92627: PPUSH
92628: LD_INT 1
92630: PPUSH
92631: CALL_OW 483
// end ;
92635: GO 92495
92637: POP
92638: POP
// end ;
92639: PPOPN 5
92641: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
92642: LD_EXP 88
92646: PUSH
92647: LD_EXP 123
92651: AND
92652: IFFALSE 92746
92654: GO 92656
92656: DISABLE
92657: LD_INT 0
92659: PPUSH
92660: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
92661: LD_ADDR_VAR 0 2
92665: PUSH
92666: LD_INT 22
92668: PUSH
92669: LD_OWVAR 2
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 32
92680: PUSH
92681: LD_INT 1
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 21
92690: PUSH
92691: LD_INT 2
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: LIST
92702: PPUSH
92703: CALL_OW 69
92707: ST_TO_ADDR
// if not tmp then
92708: LD_VAR 0 2
92712: NOT
92713: IFFALSE 92717
// exit ;
92715: GO 92746
// for i in tmp do
92717: LD_ADDR_VAR 0 1
92721: PUSH
92722: LD_VAR 0 2
92726: PUSH
92727: FOR_IN
92728: IFFALSE 92744
// SetFuel ( i , 0 ) ;
92730: LD_VAR 0 1
92734: PPUSH
92735: LD_INT 0
92737: PPUSH
92738: CALL_OW 240
92742: GO 92727
92744: POP
92745: POP
// end ;
92746: PPOPN 2
92748: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
92749: LD_EXP 88
92753: PUSH
92754: LD_EXP 124
92758: AND
92759: IFFALSE 92825
92761: GO 92763
92763: DISABLE
92764: LD_INT 0
92766: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92767: LD_ADDR_VAR 0 1
92771: PUSH
92772: LD_INT 22
92774: PUSH
92775: LD_OWVAR 2
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 30
92786: PUSH
92787: LD_INT 29
92789: PUSH
92790: EMPTY
92791: LIST
92792: LIST
92793: PUSH
92794: EMPTY
92795: LIST
92796: LIST
92797: PPUSH
92798: CALL_OW 69
92802: ST_TO_ADDR
// if not tmp then
92803: LD_VAR 0 1
92807: NOT
92808: IFFALSE 92812
// exit ;
92810: GO 92825
// DestroyUnit ( tmp [ 1 ] ) ;
92812: LD_VAR 0 1
92816: PUSH
92817: LD_INT 1
92819: ARRAY
92820: PPUSH
92821: CALL_OW 65
// end ;
92825: PPOPN 1
92827: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
92828: LD_EXP 88
92832: PUSH
92833: LD_EXP 126
92837: AND
92838: IFFALSE 92967
92840: GO 92842
92842: DISABLE
92843: LD_INT 0
92845: PPUSH
// begin uc_side := 0 ;
92846: LD_ADDR_OWVAR 20
92850: PUSH
92851: LD_INT 0
92853: ST_TO_ADDR
// uc_nation := nation_arabian ;
92854: LD_ADDR_OWVAR 21
92858: PUSH
92859: LD_INT 2
92861: ST_TO_ADDR
// hc_gallery :=  ;
92862: LD_ADDR_OWVAR 33
92866: PUSH
92867: LD_STRING 
92869: ST_TO_ADDR
// hc_name :=  ;
92870: LD_ADDR_OWVAR 26
92874: PUSH
92875: LD_STRING 
92877: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
92878: LD_INT 1
92880: PPUSH
92881: LD_INT 11
92883: PPUSH
92884: LD_INT 10
92886: PPUSH
92887: CALL_OW 380
// un := CreateHuman ;
92891: LD_ADDR_VAR 0 1
92895: PUSH
92896: CALL_OW 44
92900: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92901: LD_VAR 0 1
92905: PPUSH
92906: LD_INT 1
92908: PPUSH
92909: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
92913: LD_INT 35
92915: PPUSH
92916: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
92920: LD_VAR 0 1
92924: PPUSH
92925: LD_INT 22
92927: PUSH
92928: LD_OWVAR 2
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PPUSH
92937: CALL_OW 69
92941: PPUSH
92942: LD_VAR 0 1
92946: PPUSH
92947: CALL_OW 74
92951: PPUSH
92952: CALL_OW 115
// until IsDead ( un ) ;
92956: LD_VAR 0 1
92960: PPUSH
92961: CALL_OW 301
92965: IFFALSE 92913
// end ;
92967: PPOPN 1
92969: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
92970: LD_EXP 88
92974: PUSH
92975: LD_EXP 128
92979: AND
92980: IFFALSE 92992
92982: GO 92984
92984: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
92985: LD_STRING earthquake(getX(game), 0, 32)
92987: PPUSH
92988: CALL_OW 559
92992: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
92993: LD_EXP 88
92997: PUSH
92998: LD_EXP 129
93002: AND
93003: IFFALSE 93094
93005: GO 93007
93007: DISABLE
93008: LD_INT 0
93010: PPUSH
// begin enable ;
93011: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
93012: LD_ADDR_VAR 0 1
93016: PUSH
93017: LD_INT 22
93019: PUSH
93020: LD_OWVAR 2
93024: PUSH
93025: EMPTY
93026: LIST
93027: LIST
93028: PUSH
93029: LD_INT 21
93031: PUSH
93032: LD_INT 2
93034: PUSH
93035: EMPTY
93036: LIST
93037: LIST
93038: PUSH
93039: LD_INT 33
93041: PUSH
93042: LD_INT 3
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: LIST
93053: PPUSH
93054: CALL_OW 69
93058: ST_TO_ADDR
// if not tmp then
93059: LD_VAR 0 1
93063: NOT
93064: IFFALSE 93068
// exit ;
93066: GO 93094
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
93068: LD_VAR 0 1
93072: PUSH
93073: LD_INT 1
93075: PPUSH
93076: LD_VAR 0 1
93080: PPUSH
93081: CALL_OW 12
93085: ARRAY
93086: PPUSH
93087: LD_INT 1
93089: PPUSH
93090: CALL_OW 234
// end ;
93094: PPOPN 1
93096: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
93097: LD_EXP 88
93101: PUSH
93102: LD_EXP 130
93106: AND
93107: IFFALSE 93248
93109: GO 93111
93111: DISABLE
93112: LD_INT 0
93114: PPUSH
93115: PPUSH
93116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93117: LD_ADDR_VAR 0 3
93121: PUSH
93122: LD_INT 22
93124: PUSH
93125: LD_OWVAR 2
93129: PUSH
93130: EMPTY
93131: LIST
93132: LIST
93133: PUSH
93134: LD_INT 25
93136: PUSH
93137: LD_INT 1
93139: PUSH
93140: EMPTY
93141: LIST
93142: LIST
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PPUSH
93148: CALL_OW 69
93152: ST_TO_ADDR
// if not tmp then
93153: LD_VAR 0 3
93157: NOT
93158: IFFALSE 93162
// exit ;
93160: GO 93248
// un := tmp [ rand ( 1 , tmp ) ] ;
93162: LD_ADDR_VAR 0 2
93166: PUSH
93167: LD_VAR 0 3
93171: PUSH
93172: LD_INT 1
93174: PPUSH
93175: LD_VAR 0 3
93179: PPUSH
93180: CALL_OW 12
93184: ARRAY
93185: ST_TO_ADDR
// if Crawls ( un ) then
93186: LD_VAR 0 2
93190: PPUSH
93191: CALL_OW 318
93195: IFFALSE 93206
// ComWalk ( un ) ;
93197: LD_VAR 0 2
93201: PPUSH
93202: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
93206: LD_VAR 0 2
93210: PPUSH
93211: LD_INT 9
93213: PPUSH
93214: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
93218: LD_INT 28
93220: PPUSH
93221: LD_OWVAR 2
93225: PPUSH
93226: LD_INT 2
93228: PPUSH
93229: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
93233: LD_INT 29
93235: PPUSH
93236: LD_OWVAR 2
93240: PPUSH
93241: LD_INT 2
93243: PPUSH
93244: CALL_OW 322
// end ;
93248: PPOPN 3
93250: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
93251: LD_EXP 88
93255: PUSH
93256: LD_EXP 131
93260: AND
93261: IFFALSE 93372
93263: GO 93265
93265: DISABLE
93266: LD_INT 0
93268: PPUSH
93269: PPUSH
93270: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93271: LD_ADDR_VAR 0 3
93275: PUSH
93276: LD_INT 22
93278: PUSH
93279: LD_OWVAR 2
93283: PUSH
93284: EMPTY
93285: LIST
93286: LIST
93287: PUSH
93288: LD_INT 25
93290: PUSH
93291: LD_INT 1
93293: PUSH
93294: EMPTY
93295: LIST
93296: LIST
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PPUSH
93302: CALL_OW 69
93306: ST_TO_ADDR
// if not tmp then
93307: LD_VAR 0 3
93311: NOT
93312: IFFALSE 93316
// exit ;
93314: GO 93372
// un := tmp [ rand ( 1 , tmp ) ] ;
93316: LD_ADDR_VAR 0 2
93320: PUSH
93321: LD_VAR 0 3
93325: PUSH
93326: LD_INT 1
93328: PPUSH
93329: LD_VAR 0 3
93333: PPUSH
93334: CALL_OW 12
93338: ARRAY
93339: ST_TO_ADDR
// if Crawls ( un ) then
93340: LD_VAR 0 2
93344: PPUSH
93345: CALL_OW 318
93349: IFFALSE 93360
// ComWalk ( un ) ;
93351: LD_VAR 0 2
93355: PPUSH
93356: CALL_OW 138
// SetClass ( un , class_mortar ) ;
93360: LD_VAR 0 2
93364: PPUSH
93365: LD_INT 8
93367: PPUSH
93368: CALL_OW 336
// end ;
93372: PPOPN 3
93374: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
93375: LD_EXP 88
93379: PUSH
93380: LD_EXP 132
93384: AND
93385: IFFALSE 93529
93387: GO 93389
93389: DISABLE
93390: LD_INT 0
93392: PPUSH
93393: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
93394: LD_ADDR_VAR 0 2
93398: PUSH
93399: LD_INT 22
93401: PUSH
93402: LD_OWVAR 2
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 21
93413: PUSH
93414: LD_INT 2
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 2
93423: PUSH
93424: LD_INT 34
93426: PUSH
93427: LD_INT 12
93429: PUSH
93430: EMPTY
93431: LIST
93432: LIST
93433: PUSH
93434: LD_INT 34
93436: PUSH
93437: LD_INT 51
93439: PUSH
93440: EMPTY
93441: LIST
93442: LIST
93443: PUSH
93444: LD_INT 34
93446: PUSH
93447: LD_INT 32
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: PUSH
93460: EMPTY
93461: LIST
93462: LIST
93463: LIST
93464: PPUSH
93465: CALL_OW 69
93469: ST_TO_ADDR
// if not tmp then
93470: LD_VAR 0 2
93474: NOT
93475: IFFALSE 93479
// exit ;
93477: GO 93529
// for i in tmp do
93479: LD_ADDR_VAR 0 1
93483: PUSH
93484: LD_VAR 0 2
93488: PUSH
93489: FOR_IN
93490: IFFALSE 93527
// if GetCargo ( i , mat_artifact ) = 0 then
93492: LD_VAR 0 1
93496: PPUSH
93497: LD_INT 4
93499: PPUSH
93500: CALL_OW 289
93504: PUSH
93505: LD_INT 0
93507: EQUAL
93508: IFFALSE 93525
// SetCargo ( i , mat_siberit , 100 ) ;
93510: LD_VAR 0 1
93514: PPUSH
93515: LD_INT 3
93517: PPUSH
93518: LD_INT 100
93520: PPUSH
93521: CALL_OW 290
93525: GO 93489
93527: POP
93528: POP
// end ;
93529: PPOPN 2
93531: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
93532: LD_EXP 88
93536: PUSH
93537: LD_EXP 133
93541: AND
93542: IFFALSE 93725
93544: GO 93546
93546: DISABLE
93547: LD_INT 0
93549: PPUSH
93550: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
93551: LD_ADDR_VAR 0 2
93555: PUSH
93556: LD_INT 22
93558: PUSH
93559: LD_OWVAR 2
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PPUSH
93568: CALL_OW 69
93572: ST_TO_ADDR
// if not tmp then
93573: LD_VAR 0 2
93577: NOT
93578: IFFALSE 93582
// exit ;
93580: GO 93725
// for i := 1 to 2 do
93582: LD_ADDR_VAR 0 1
93586: PUSH
93587: DOUBLE
93588: LD_INT 1
93590: DEC
93591: ST_TO_ADDR
93592: LD_INT 2
93594: PUSH
93595: FOR_TO
93596: IFFALSE 93723
// begin uc_side := your_side ;
93598: LD_ADDR_OWVAR 20
93602: PUSH
93603: LD_OWVAR 2
93607: ST_TO_ADDR
// uc_nation := nation_american ;
93608: LD_ADDR_OWVAR 21
93612: PUSH
93613: LD_INT 1
93615: ST_TO_ADDR
// vc_chassis := us_morphling ;
93616: LD_ADDR_OWVAR 37
93620: PUSH
93621: LD_INT 5
93623: ST_TO_ADDR
// vc_engine := engine_siberite ;
93624: LD_ADDR_OWVAR 39
93628: PUSH
93629: LD_INT 3
93631: ST_TO_ADDR
// vc_control := control_computer ;
93632: LD_ADDR_OWVAR 38
93636: PUSH
93637: LD_INT 3
93639: ST_TO_ADDR
// vc_weapon := us_double_laser ;
93640: LD_ADDR_OWVAR 40
93644: PUSH
93645: LD_INT 10
93647: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
93648: LD_VAR 0 2
93652: PUSH
93653: LD_INT 1
93655: ARRAY
93656: PPUSH
93657: CALL_OW 310
93661: NOT
93662: IFFALSE 93709
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
93664: CALL_OW 45
93668: PPUSH
93669: LD_VAR 0 2
93673: PUSH
93674: LD_INT 1
93676: ARRAY
93677: PPUSH
93678: CALL_OW 250
93682: PPUSH
93683: LD_VAR 0 2
93687: PUSH
93688: LD_INT 1
93690: ARRAY
93691: PPUSH
93692: CALL_OW 251
93696: PPUSH
93697: LD_INT 12
93699: PPUSH
93700: LD_INT 1
93702: PPUSH
93703: CALL_OW 50
93707: GO 93721
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
93709: CALL_OW 45
93713: PPUSH
93714: LD_INT 1
93716: PPUSH
93717: CALL_OW 51
// end ;
93721: GO 93595
93723: POP
93724: POP
// end ;
93725: PPOPN 2
93727: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
93728: LD_EXP 88
93732: PUSH
93733: LD_EXP 134
93737: AND
93738: IFFALSE 93960
93740: GO 93742
93742: DISABLE
93743: LD_INT 0
93745: PPUSH
93746: PPUSH
93747: PPUSH
93748: PPUSH
93749: PPUSH
93750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93751: LD_ADDR_VAR 0 6
93755: PUSH
93756: LD_INT 22
93758: PUSH
93759: LD_OWVAR 2
93763: PUSH
93764: EMPTY
93765: LIST
93766: LIST
93767: PUSH
93768: LD_INT 21
93770: PUSH
93771: LD_INT 1
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: PUSH
93778: LD_INT 3
93780: PUSH
93781: LD_INT 23
93783: PUSH
93784: LD_INT 0
93786: PUSH
93787: EMPTY
93788: LIST
93789: LIST
93790: PUSH
93791: EMPTY
93792: LIST
93793: LIST
93794: PUSH
93795: EMPTY
93796: LIST
93797: LIST
93798: LIST
93799: PPUSH
93800: CALL_OW 69
93804: ST_TO_ADDR
// if not tmp then
93805: LD_VAR 0 6
93809: NOT
93810: IFFALSE 93814
// exit ;
93812: GO 93960
// s1 := rand ( 1 , 4 ) ;
93814: LD_ADDR_VAR 0 2
93818: PUSH
93819: LD_INT 1
93821: PPUSH
93822: LD_INT 4
93824: PPUSH
93825: CALL_OW 12
93829: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
93830: LD_ADDR_VAR 0 4
93834: PUSH
93835: LD_VAR 0 6
93839: PUSH
93840: LD_INT 1
93842: ARRAY
93843: PPUSH
93844: LD_VAR 0 2
93848: PPUSH
93849: CALL_OW 259
93853: ST_TO_ADDR
// if s1 = 1 then
93854: LD_VAR 0 2
93858: PUSH
93859: LD_INT 1
93861: EQUAL
93862: IFFALSE 93882
// s2 := rand ( 2 , 4 ) else
93864: LD_ADDR_VAR 0 3
93868: PUSH
93869: LD_INT 2
93871: PPUSH
93872: LD_INT 4
93874: PPUSH
93875: CALL_OW 12
93879: ST_TO_ADDR
93880: GO 93890
// s2 := 1 ;
93882: LD_ADDR_VAR 0 3
93886: PUSH
93887: LD_INT 1
93889: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
93890: LD_ADDR_VAR 0 5
93894: PUSH
93895: LD_VAR 0 6
93899: PUSH
93900: LD_INT 1
93902: ARRAY
93903: PPUSH
93904: LD_VAR 0 3
93908: PPUSH
93909: CALL_OW 259
93913: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
93914: LD_VAR 0 6
93918: PUSH
93919: LD_INT 1
93921: ARRAY
93922: PPUSH
93923: LD_VAR 0 2
93927: PPUSH
93928: LD_VAR 0 5
93932: PPUSH
93933: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
93937: LD_VAR 0 6
93941: PUSH
93942: LD_INT 1
93944: ARRAY
93945: PPUSH
93946: LD_VAR 0 3
93950: PPUSH
93951: LD_VAR 0 4
93955: PPUSH
93956: CALL_OW 237
// end ;
93960: PPOPN 6
93962: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
93963: LD_EXP 88
93967: PUSH
93968: LD_EXP 135
93972: AND
93973: IFFALSE 94052
93975: GO 93977
93977: DISABLE
93978: LD_INT 0
93980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
93981: LD_ADDR_VAR 0 1
93985: PUSH
93986: LD_INT 22
93988: PUSH
93989: LD_OWVAR 2
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PUSH
93998: LD_INT 30
94000: PUSH
94001: LD_INT 3
94003: PUSH
94004: EMPTY
94005: LIST
94006: LIST
94007: PUSH
94008: EMPTY
94009: LIST
94010: LIST
94011: PPUSH
94012: CALL_OW 69
94016: ST_TO_ADDR
// if not tmp then
94017: LD_VAR 0 1
94021: NOT
94022: IFFALSE 94026
// exit ;
94024: GO 94052
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94026: LD_VAR 0 1
94030: PUSH
94031: LD_INT 1
94033: PPUSH
94034: LD_VAR 0 1
94038: PPUSH
94039: CALL_OW 12
94043: ARRAY
94044: PPUSH
94045: LD_INT 1
94047: PPUSH
94048: CALL_OW 234
// end ;
94052: PPOPN 1
94054: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
94055: LD_EXP 88
94059: PUSH
94060: LD_EXP 136
94064: AND
94065: IFFALSE 94177
94067: GO 94069
94069: DISABLE
94070: LD_INT 0
94072: PPUSH
94073: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
94074: LD_ADDR_VAR 0 2
94078: PUSH
94079: LD_INT 22
94081: PUSH
94082: LD_OWVAR 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 2
94093: PUSH
94094: LD_INT 30
94096: PUSH
94097: LD_INT 27
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 30
94106: PUSH
94107: LD_INT 26
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 30
94116: PUSH
94117: LD_INT 28
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: PUSH
94130: EMPTY
94131: LIST
94132: LIST
94133: PPUSH
94134: CALL_OW 69
94138: ST_TO_ADDR
// if not tmp then
94139: LD_VAR 0 2
94143: NOT
94144: IFFALSE 94148
// exit ;
94146: GO 94177
// for i in tmp do
94148: LD_ADDR_VAR 0 1
94152: PUSH
94153: LD_VAR 0 2
94157: PUSH
94158: FOR_IN
94159: IFFALSE 94175
// SetLives ( i , 1 ) ;
94161: LD_VAR 0 1
94165: PPUSH
94166: LD_INT 1
94168: PPUSH
94169: CALL_OW 234
94173: GO 94158
94175: POP
94176: POP
// end ;
94177: PPOPN 2
94179: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
94180: LD_EXP 88
94184: PUSH
94185: LD_EXP 137
94189: AND
94190: IFFALSE 94464
94192: GO 94194
94194: DISABLE
94195: LD_INT 0
94197: PPUSH
94198: PPUSH
94199: PPUSH
// begin i := rand ( 1 , 7 ) ;
94200: LD_ADDR_VAR 0 1
94204: PUSH
94205: LD_INT 1
94207: PPUSH
94208: LD_INT 7
94210: PPUSH
94211: CALL_OW 12
94215: ST_TO_ADDR
// case i of 1 :
94216: LD_VAR 0 1
94220: PUSH
94221: LD_INT 1
94223: DOUBLE
94224: EQUAL
94225: IFTRUE 94229
94227: GO 94239
94229: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
94230: LD_STRING earthquake(getX(game), 0, 32)
94232: PPUSH
94233: CALL_OW 559
94237: GO 94464
94239: LD_INT 2
94241: DOUBLE
94242: EQUAL
94243: IFTRUE 94247
94245: GO 94261
94247: POP
// begin ToLua ( displayStucuk(); ) ;
94248: LD_STRING displayStucuk();
94250: PPUSH
94251: CALL_OW 559
// ResetFog ;
94255: CALL_OW 335
// end ; 3 :
94259: GO 94464
94261: LD_INT 3
94263: DOUBLE
94264: EQUAL
94265: IFTRUE 94269
94267: GO 94373
94269: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94270: LD_ADDR_VAR 0 2
94274: PUSH
94275: LD_INT 22
94277: PUSH
94278: LD_OWVAR 2
94282: PUSH
94283: EMPTY
94284: LIST
94285: LIST
94286: PUSH
94287: LD_INT 25
94289: PUSH
94290: LD_INT 1
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PPUSH
94301: CALL_OW 69
94305: ST_TO_ADDR
// if not tmp then
94306: LD_VAR 0 2
94310: NOT
94311: IFFALSE 94315
// exit ;
94313: GO 94464
// un := tmp [ rand ( 1 , tmp ) ] ;
94315: LD_ADDR_VAR 0 3
94319: PUSH
94320: LD_VAR 0 2
94324: PUSH
94325: LD_INT 1
94327: PPUSH
94328: LD_VAR 0 2
94332: PPUSH
94333: CALL_OW 12
94337: ARRAY
94338: ST_TO_ADDR
// if Crawls ( un ) then
94339: LD_VAR 0 3
94343: PPUSH
94344: CALL_OW 318
94348: IFFALSE 94359
// ComWalk ( un ) ;
94350: LD_VAR 0 3
94354: PPUSH
94355: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94359: LD_VAR 0 3
94363: PPUSH
94364: LD_INT 8
94366: PPUSH
94367: CALL_OW 336
// end ; 4 :
94371: GO 94464
94373: LD_INT 4
94375: DOUBLE
94376: EQUAL
94377: IFTRUE 94381
94379: GO 94442
94381: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94382: LD_ADDR_VAR 0 2
94386: PUSH
94387: LD_INT 22
94389: PUSH
94390: LD_OWVAR 2
94394: PUSH
94395: EMPTY
94396: LIST
94397: LIST
94398: PUSH
94399: LD_INT 30
94401: PUSH
94402: LD_INT 29
94404: PUSH
94405: EMPTY
94406: LIST
94407: LIST
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PPUSH
94413: CALL_OW 69
94417: ST_TO_ADDR
// if not tmp then
94418: LD_VAR 0 2
94422: NOT
94423: IFFALSE 94427
// exit ;
94425: GO 94464
// DestroyUnit ( tmp [ 1 ] ) ;
94427: LD_VAR 0 2
94431: PUSH
94432: LD_INT 1
94434: ARRAY
94435: PPUSH
94436: CALL_OW 65
// end ; 5 .. 7 :
94440: GO 94464
94442: LD_INT 5
94444: DOUBLE
94445: GREATEREQUAL
94446: IFFALSE 94454
94448: LD_INT 7
94450: DOUBLE
94451: LESSEQUAL
94452: IFTRUE 94456
94454: GO 94463
94456: POP
// StreamSibBomb ; end ;
94457: CALL 90714 0 0
94461: GO 94464
94463: POP
// end ;
94464: PPOPN 3
94466: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
94467: LD_EXP 88
94471: PUSH
94472: LD_EXP 138
94476: AND
94477: IFFALSE 94633
94479: GO 94481
94481: DISABLE
94482: LD_INT 0
94484: PPUSH
94485: PPUSH
94486: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
94487: LD_ADDR_VAR 0 2
94491: PUSH
94492: LD_INT 81
94494: PUSH
94495: LD_OWVAR 2
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: LD_INT 2
94506: PUSH
94507: LD_INT 21
94509: PUSH
94510: LD_INT 1
94512: PUSH
94513: EMPTY
94514: LIST
94515: LIST
94516: PUSH
94517: LD_INT 21
94519: PUSH
94520: LD_INT 2
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: EMPTY
94528: LIST
94529: LIST
94530: LIST
94531: PUSH
94532: EMPTY
94533: LIST
94534: LIST
94535: PPUSH
94536: CALL_OW 69
94540: ST_TO_ADDR
// if not tmp then
94541: LD_VAR 0 2
94545: NOT
94546: IFFALSE 94550
// exit ;
94548: GO 94633
// p := 0 ;
94550: LD_ADDR_VAR 0 3
94554: PUSH
94555: LD_INT 0
94557: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94558: LD_INT 35
94560: PPUSH
94561: CALL_OW 67
// p := p + 1 ;
94565: LD_ADDR_VAR 0 3
94569: PUSH
94570: LD_VAR 0 3
94574: PUSH
94575: LD_INT 1
94577: PLUS
94578: ST_TO_ADDR
// for i in tmp do
94579: LD_ADDR_VAR 0 1
94583: PUSH
94584: LD_VAR 0 2
94588: PUSH
94589: FOR_IN
94590: IFFALSE 94621
// if GetLives ( i ) < 1000 then
94592: LD_VAR 0 1
94596: PPUSH
94597: CALL_OW 256
94601: PUSH
94602: LD_INT 1000
94604: LESS
94605: IFFALSE 94619
// SetLives ( i , 1000 ) ;
94607: LD_VAR 0 1
94611: PPUSH
94612: LD_INT 1000
94614: PPUSH
94615: CALL_OW 234
94619: GO 94589
94621: POP
94622: POP
// until p > 20 ;
94623: LD_VAR 0 3
94627: PUSH
94628: LD_INT 20
94630: GREATER
94631: IFFALSE 94558
// end ;
94633: PPOPN 3
94635: END
// every 0 0$1 trigger StreamModeActive and sTime do
94636: LD_EXP 88
94640: PUSH
94641: LD_EXP 139
94645: AND
94646: IFFALSE 94681
94648: GO 94650
94650: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
94651: LD_INT 28
94653: PPUSH
94654: LD_OWVAR 2
94658: PPUSH
94659: LD_INT 2
94661: PPUSH
94662: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
94666: LD_INT 30
94668: PPUSH
94669: LD_OWVAR 2
94673: PPUSH
94674: LD_INT 2
94676: PPUSH
94677: CALL_OW 322
// end ;
94681: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
94682: LD_EXP 88
94686: PUSH
94687: LD_EXP 140
94691: AND
94692: IFFALSE 94813
94694: GO 94696
94696: DISABLE
94697: LD_INT 0
94699: PPUSH
94700: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94701: LD_ADDR_VAR 0 2
94705: PUSH
94706: LD_INT 22
94708: PUSH
94709: LD_OWVAR 2
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 21
94720: PUSH
94721: LD_INT 1
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 3
94730: PUSH
94731: LD_INT 23
94733: PUSH
94734: LD_INT 0
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: EMPTY
94742: LIST
94743: LIST
94744: PUSH
94745: EMPTY
94746: LIST
94747: LIST
94748: LIST
94749: PPUSH
94750: CALL_OW 69
94754: ST_TO_ADDR
// if not tmp then
94755: LD_VAR 0 2
94759: NOT
94760: IFFALSE 94764
// exit ;
94762: GO 94813
// for i in tmp do
94764: LD_ADDR_VAR 0 1
94768: PUSH
94769: LD_VAR 0 2
94773: PUSH
94774: FOR_IN
94775: IFFALSE 94811
// begin if Crawls ( i ) then
94777: LD_VAR 0 1
94781: PPUSH
94782: CALL_OW 318
94786: IFFALSE 94797
// ComWalk ( i ) ;
94788: LD_VAR 0 1
94792: PPUSH
94793: CALL_OW 138
// SetClass ( i , 2 ) ;
94797: LD_VAR 0 1
94801: PPUSH
94802: LD_INT 2
94804: PPUSH
94805: CALL_OW 336
// end ;
94809: GO 94774
94811: POP
94812: POP
// end ;
94813: PPOPN 2
94815: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
94816: LD_EXP 88
94820: PUSH
94821: LD_EXP 141
94825: AND
94826: IFFALSE 95107
94828: GO 94830
94830: DISABLE
94831: LD_INT 0
94833: PPUSH
94834: PPUSH
94835: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
94836: LD_OWVAR 2
94840: PPUSH
94841: LD_INT 9
94843: PPUSH
94844: LD_INT 1
94846: PPUSH
94847: LD_INT 1
94849: PPUSH
94850: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
94854: LD_INT 9
94856: PPUSH
94857: LD_OWVAR 2
94861: PPUSH
94862: CALL_OW 343
// uc_side := 9 ;
94866: LD_ADDR_OWVAR 20
94870: PUSH
94871: LD_INT 9
94873: ST_TO_ADDR
// uc_nation := 2 ;
94874: LD_ADDR_OWVAR 21
94878: PUSH
94879: LD_INT 2
94881: ST_TO_ADDR
// hc_name := Dark Warrior ;
94882: LD_ADDR_OWVAR 26
94886: PUSH
94887: LD_STRING Dark Warrior
94889: ST_TO_ADDR
// hc_gallery :=  ;
94890: LD_ADDR_OWVAR 33
94894: PUSH
94895: LD_STRING 
94897: ST_TO_ADDR
// hc_noskilllimit := true ;
94898: LD_ADDR_OWVAR 76
94902: PUSH
94903: LD_INT 1
94905: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
94906: LD_ADDR_OWVAR 31
94910: PUSH
94911: LD_INT 30
94913: PUSH
94914: LD_INT 30
94916: PUSH
94917: LD_INT 30
94919: PUSH
94920: LD_INT 30
94922: PUSH
94923: EMPTY
94924: LIST
94925: LIST
94926: LIST
94927: LIST
94928: ST_TO_ADDR
// un := CreateHuman ;
94929: LD_ADDR_VAR 0 3
94933: PUSH
94934: CALL_OW 44
94938: ST_TO_ADDR
// hc_noskilllimit := false ;
94939: LD_ADDR_OWVAR 76
94943: PUSH
94944: LD_INT 0
94946: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94947: LD_VAR 0 3
94951: PPUSH
94952: LD_INT 1
94954: PPUSH
94955: CALL_OW 51
// p := 0 ;
94959: LD_ADDR_VAR 0 2
94963: PUSH
94964: LD_INT 0
94966: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
94967: LD_INT 35
94969: PPUSH
94970: CALL_OW 67
// p := p + 1 ;
94974: LD_ADDR_VAR 0 2
94978: PUSH
94979: LD_VAR 0 2
94983: PUSH
94984: LD_INT 1
94986: PLUS
94987: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
94988: LD_VAR 0 3
94992: PPUSH
94993: CALL_OW 256
94997: PUSH
94998: LD_INT 1000
95000: LESS
95001: IFFALSE 95015
// SetLives ( un , 1000 ) ;
95003: LD_VAR 0 3
95007: PPUSH
95008: LD_INT 1000
95010: PPUSH
95011: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
95015: LD_VAR 0 3
95019: PPUSH
95020: LD_INT 81
95022: PUSH
95023: LD_OWVAR 2
95027: PUSH
95028: EMPTY
95029: LIST
95030: LIST
95031: PUSH
95032: LD_INT 91
95034: PUSH
95035: LD_VAR 0 3
95039: PUSH
95040: LD_INT 30
95042: PUSH
95043: EMPTY
95044: LIST
95045: LIST
95046: LIST
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PPUSH
95052: CALL_OW 69
95056: PPUSH
95057: LD_VAR 0 3
95061: PPUSH
95062: CALL_OW 74
95066: PPUSH
95067: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
95071: LD_VAR 0 2
95075: PUSH
95076: LD_INT 60
95078: GREATER
95079: PUSH
95080: LD_VAR 0 3
95084: PPUSH
95085: CALL_OW 301
95089: OR
95090: IFFALSE 94967
// if un then
95092: LD_VAR 0 3
95096: IFFALSE 95107
// RemoveUnit ( un ) ;
95098: LD_VAR 0 3
95102: PPUSH
95103: CALL_OW 64
// end ;
95107: PPOPN 3
95109: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
95110: LD_INT 0
95112: PPUSH
// case cmd of 301 :
95113: LD_VAR 0 1
95117: PUSH
95118: LD_INT 301
95120: DOUBLE
95121: EQUAL
95122: IFTRUE 95126
95124: GO 95158
95126: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
95127: LD_VAR 0 6
95131: PPUSH
95132: LD_VAR 0 7
95136: PPUSH
95137: LD_VAR 0 8
95141: PPUSH
95142: LD_VAR 0 4
95146: PPUSH
95147: LD_VAR 0 5
95151: PPUSH
95152: CALL 96359 0 5
95156: GO 95279
95158: LD_INT 302
95160: DOUBLE
95161: EQUAL
95162: IFTRUE 95166
95164: GO 95203
95166: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
95167: LD_VAR 0 6
95171: PPUSH
95172: LD_VAR 0 7
95176: PPUSH
95177: LD_VAR 0 8
95181: PPUSH
95182: LD_VAR 0 9
95186: PPUSH
95187: LD_VAR 0 4
95191: PPUSH
95192: LD_VAR 0 5
95196: PPUSH
95197: CALL 96450 0 6
95201: GO 95279
95203: LD_INT 303
95205: DOUBLE
95206: EQUAL
95207: IFTRUE 95211
95209: GO 95248
95211: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
95212: LD_VAR 0 6
95216: PPUSH
95217: LD_VAR 0 7
95221: PPUSH
95222: LD_VAR 0 8
95226: PPUSH
95227: LD_VAR 0 9
95231: PPUSH
95232: LD_VAR 0 4
95236: PPUSH
95237: LD_VAR 0 5
95241: PPUSH
95242: CALL 95284 0 6
95246: GO 95279
95248: LD_INT 304
95250: DOUBLE
95251: EQUAL
95252: IFTRUE 95256
95254: GO 95278
95256: POP
// hHackTeleport ( unit , x , y ) ; end ;
95257: LD_VAR 0 2
95261: PPUSH
95262: LD_VAR 0 4
95266: PPUSH
95267: LD_VAR 0 5
95271: PPUSH
95272: CALL 97043 0 3
95276: GO 95279
95278: POP
// end ;
95279: LD_VAR 0 12
95283: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
95284: LD_INT 0
95286: PPUSH
95287: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
95288: LD_VAR 0 1
95292: PUSH
95293: LD_INT 1
95295: LESS
95296: PUSH
95297: LD_VAR 0 1
95301: PUSH
95302: LD_INT 3
95304: GREATER
95305: OR
95306: PUSH
95307: LD_VAR 0 5
95311: PPUSH
95312: LD_VAR 0 6
95316: PPUSH
95317: CALL_OW 428
95321: OR
95322: IFFALSE 95326
// exit ;
95324: GO 96046
// uc_side := your_side ;
95326: LD_ADDR_OWVAR 20
95330: PUSH
95331: LD_OWVAR 2
95335: ST_TO_ADDR
// uc_nation := nation ;
95336: LD_ADDR_OWVAR 21
95340: PUSH
95341: LD_VAR 0 1
95345: ST_TO_ADDR
// bc_level = 1 ;
95346: LD_ADDR_OWVAR 43
95350: PUSH
95351: LD_INT 1
95353: ST_TO_ADDR
// case btype of 1 :
95354: LD_VAR 0 2
95358: PUSH
95359: LD_INT 1
95361: DOUBLE
95362: EQUAL
95363: IFTRUE 95367
95365: GO 95378
95367: POP
// bc_type := b_depot ; 2 :
95368: LD_ADDR_OWVAR 42
95372: PUSH
95373: LD_INT 0
95375: ST_TO_ADDR
95376: GO 95990
95378: LD_INT 2
95380: DOUBLE
95381: EQUAL
95382: IFTRUE 95386
95384: GO 95397
95386: POP
// bc_type := b_warehouse ; 3 :
95387: LD_ADDR_OWVAR 42
95391: PUSH
95392: LD_INT 1
95394: ST_TO_ADDR
95395: GO 95990
95397: LD_INT 3
95399: DOUBLE
95400: EQUAL
95401: IFTRUE 95405
95403: GO 95416
95405: POP
// bc_type := b_lab ; 4 .. 9 :
95406: LD_ADDR_OWVAR 42
95410: PUSH
95411: LD_INT 6
95413: ST_TO_ADDR
95414: GO 95990
95416: LD_INT 4
95418: DOUBLE
95419: GREATEREQUAL
95420: IFFALSE 95428
95422: LD_INT 9
95424: DOUBLE
95425: LESSEQUAL
95426: IFTRUE 95430
95428: GO 95482
95430: POP
// begin bc_type := b_lab_half ;
95431: LD_ADDR_OWVAR 42
95435: PUSH
95436: LD_INT 7
95438: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
95439: LD_ADDR_OWVAR 44
95443: PUSH
95444: LD_INT 10
95446: PUSH
95447: LD_INT 11
95449: PUSH
95450: LD_INT 12
95452: PUSH
95453: LD_INT 15
95455: PUSH
95456: LD_INT 14
95458: PUSH
95459: LD_INT 13
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: PUSH
95470: LD_VAR 0 2
95474: PUSH
95475: LD_INT 3
95477: MINUS
95478: ARRAY
95479: ST_TO_ADDR
// end ; 10 .. 13 :
95480: GO 95990
95482: LD_INT 10
95484: DOUBLE
95485: GREATEREQUAL
95486: IFFALSE 95494
95488: LD_INT 13
95490: DOUBLE
95491: LESSEQUAL
95492: IFTRUE 95496
95494: GO 95573
95496: POP
// begin bc_type := b_lab_full ;
95497: LD_ADDR_OWVAR 42
95501: PUSH
95502: LD_INT 8
95504: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
95505: LD_ADDR_OWVAR 44
95509: PUSH
95510: LD_INT 10
95512: PUSH
95513: LD_INT 12
95515: PUSH
95516: LD_INT 14
95518: PUSH
95519: LD_INT 13
95521: PUSH
95522: EMPTY
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: PUSH
95528: LD_VAR 0 2
95532: PUSH
95533: LD_INT 9
95535: MINUS
95536: ARRAY
95537: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
95538: LD_ADDR_OWVAR 45
95542: PUSH
95543: LD_INT 11
95545: PUSH
95546: LD_INT 15
95548: PUSH
95549: LD_INT 12
95551: PUSH
95552: LD_INT 15
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: PUSH
95561: LD_VAR 0 2
95565: PUSH
95566: LD_INT 9
95568: MINUS
95569: ARRAY
95570: ST_TO_ADDR
// end ; 14 :
95571: GO 95990
95573: LD_INT 14
95575: DOUBLE
95576: EQUAL
95577: IFTRUE 95581
95579: GO 95592
95581: POP
// bc_type := b_workshop ; 15 :
95582: LD_ADDR_OWVAR 42
95586: PUSH
95587: LD_INT 2
95589: ST_TO_ADDR
95590: GO 95990
95592: LD_INT 15
95594: DOUBLE
95595: EQUAL
95596: IFTRUE 95600
95598: GO 95611
95600: POP
// bc_type := b_factory ; 16 :
95601: LD_ADDR_OWVAR 42
95605: PUSH
95606: LD_INT 3
95608: ST_TO_ADDR
95609: GO 95990
95611: LD_INT 16
95613: DOUBLE
95614: EQUAL
95615: IFTRUE 95619
95617: GO 95630
95619: POP
// bc_type := b_ext_gun ; 17 :
95620: LD_ADDR_OWVAR 42
95624: PUSH
95625: LD_INT 17
95627: ST_TO_ADDR
95628: GO 95990
95630: LD_INT 17
95632: DOUBLE
95633: EQUAL
95634: IFTRUE 95638
95636: GO 95666
95638: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
95639: LD_ADDR_OWVAR 42
95643: PUSH
95644: LD_INT 19
95646: PUSH
95647: LD_INT 23
95649: PUSH
95650: LD_INT 19
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: LIST
95657: PUSH
95658: LD_VAR 0 1
95662: ARRAY
95663: ST_TO_ADDR
95664: GO 95990
95666: LD_INT 18
95668: DOUBLE
95669: EQUAL
95670: IFTRUE 95674
95672: GO 95685
95674: POP
// bc_type := b_ext_radar ; 19 :
95675: LD_ADDR_OWVAR 42
95679: PUSH
95680: LD_INT 20
95682: ST_TO_ADDR
95683: GO 95990
95685: LD_INT 19
95687: DOUBLE
95688: EQUAL
95689: IFTRUE 95693
95691: GO 95704
95693: POP
// bc_type := b_ext_radio ; 20 :
95694: LD_ADDR_OWVAR 42
95698: PUSH
95699: LD_INT 22
95701: ST_TO_ADDR
95702: GO 95990
95704: LD_INT 20
95706: DOUBLE
95707: EQUAL
95708: IFTRUE 95712
95710: GO 95723
95712: POP
// bc_type := b_ext_siberium ; 21 :
95713: LD_ADDR_OWVAR 42
95717: PUSH
95718: LD_INT 21
95720: ST_TO_ADDR
95721: GO 95990
95723: LD_INT 21
95725: DOUBLE
95726: EQUAL
95727: IFTRUE 95731
95729: GO 95742
95731: POP
// bc_type := b_ext_computer ; 22 :
95732: LD_ADDR_OWVAR 42
95736: PUSH
95737: LD_INT 24
95739: ST_TO_ADDR
95740: GO 95990
95742: LD_INT 22
95744: DOUBLE
95745: EQUAL
95746: IFTRUE 95750
95748: GO 95761
95750: POP
// bc_type := b_ext_track ; 23 :
95751: LD_ADDR_OWVAR 42
95755: PUSH
95756: LD_INT 16
95758: ST_TO_ADDR
95759: GO 95990
95761: LD_INT 23
95763: DOUBLE
95764: EQUAL
95765: IFTRUE 95769
95767: GO 95780
95769: POP
// bc_type := b_ext_laser ; 24 :
95770: LD_ADDR_OWVAR 42
95774: PUSH
95775: LD_INT 25
95777: ST_TO_ADDR
95778: GO 95990
95780: LD_INT 24
95782: DOUBLE
95783: EQUAL
95784: IFTRUE 95788
95786: GO 95799
95788: POP
// bc_type := b_control_tower ; 25 :
95789: LD_ADDR_OWVAR 42
95793: PUSH
95794: LD_INT 36
95796: ST_TO_ADDR
95797: GO 95990
95799: LD_INT 25
95801: DOUBLE
95802: EQUAL
95803: IFTRUE 95807
95805: GO 95818
95807: POP
// bc_type := b_breastwork ; 26 :
95808: LD_ADDR_OWVAR 42
95812: PUSH
95813: LD_INT 31
95815: ST_TO_ADDR
95816: GO 95990
95818: LD_INT 26
95820: DOUBLE
95821: EQUAL
95822: IFTRUE 95826
95824: GO 95837
95826: POP
// bc_type := b_bunker ; 27 :
95827: LD_ADDR_OWVAR 42
95831: PUSH
95832: LD_INT 32
95834: ST_TO_ADDR
95835: GO 95990
95837: LD_INT 27
95839: DOUBLE
95840: EQUAL
95841: IFTRUE 95845
95843: GO 95856
95845: POP
// bc_type := b_turret ; 28 :
95846: LD_ADDR_OWVAR 42
95850: PUSH
95851: LD_INT 33
95853: ST_TO_ADDR
95854: GO 95990
95856: LD_INT 28
95858: DOUBLE
95859: EQUAL
95860: IFTRUE 95864
95862: GO 95875
95864: POP
// bc_type := b_armoury ; 29 :
95865: LD_ADDR_OWVAR 42
95869: PUSH
95870: LD_INT 4
95872: ST_TO_ADDR
95873: GO 95990
95875: LD_INT 29
95877: DOUBLE
95878: EQUAL
95879: IFTRUE 95883
95881: GO 95894
95883: POP
// bc_type := b_barracks ; 30 :
95884: LD_ADDR_OWVAR 42
95888: PUSH
95889: LD_INT 5
95891: ST_TO_ADDR
95892: GO 95990
95894: LD_INT 30
95896: DOUBLE
95897: EQUAL
95898: IFTRUE 95902
95900: GO 95913
95902: POP
// bc_type := b_solar_power ; 31 :
95903: LD_ADDR_OWVAR 42
95907: PUSH
95908: LD_INT 27
95910: ST_TO_ADDR
95911: GO 95990
95913: LD_INT 31
95915: DOUBLE
95916: EQUAL
95917: IFTRUE 95921
95919: GO 95932
95921: POP
// bc_type := b_oil_power ; 32 :
95922: LD_ADDR_OWVAR 42
95926: PUSH
95927: LD_INT 26
95929: ST_TO_ADDR
95930: GO 95990
95932: LD_INT 32
95934: DOUBLE
95935: EQUAL
95936: IFTRUE 95940
95938: GO 95951
95940: POP
// bc_type := b_siberite_power ; 33 :
95941: LD_ADDR_OWVAR 42
95945: PUSH
95946: LD_INT 28
95948: ST_TO_ADDR
95949: GO 95990
95951: LD_INT 33
95953: DOUBLE
95954: EQUAL
95955: IFTRUE 95959
95957: GO 95970
95959: POP
// bc_type := b_oil_mine ; 34 :
95960: LD_ADDR_OWVAR 42
95964: PUSH
95965: LD_INT 29
95967: ST_TO_ADDR
95968: GO 95990
95970: LD_INT 34
95972: DOUBLE
95973: EQUAL
95974: IFTRUE 95978
95976: GO 95989
95978: POP
// bc_type := b_siberite_mine ; end ;
95979: LD_ADDR_OWVAR 42
95983: PUSH
95984: LD_INT 30
95986: ST_TO_ADDR
95987: GO 95990
95989: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
95990: LD_ADDR_VAR 0 8
95994: PUSH
95995: LD_VAR 0 5
95999: PPUSH
96000: LD_VAR 0 6
96004: PPUSH
96005: LD_VAR 0 3
96009: PPUSH
96010: CALL_OW 47
96014: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
96015: LD_OWVAR 42
96019: PUSH
96020: LD_INT 32
96022: PUSH
96023: LD_INT 33
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: IN
96030: IFFALSE 96046
// PlaceWeaponTurret ( b , weapon ) ;
96032: LD_VAR 0 8
96036: PPUSH
96037: LD_VAR 0 4
96041: PPUSH
96042: CALL_OW 431
// end ;
96046: LD_VAR 0 7
96050: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
96051: LD_INT 0
96053: PPUSH
96054: PPUSH
96055: PPUSH
96056: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96057: LD_ADDR_VAR 0 4
96061: PUSH
96062: LD_INT 22
96064: PUSH
96065: LD_OWVAR 2
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 2
96076: PUSH
96077: LD_INT 30
96079: PUSH
96080: LD_INT 0
96082: PUSH
96083: EMPTY
96084: LIST
96085: LIST
96086: PUSH
96087: LD_INT 30
96089: PUSH
96090: LD_INT 1
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: LIST
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PPUSH
96106: CALL_OW 69
96110: ST_TO_ADDR
// if not tmp then
96111: LD_VAR 0 4
96115: NOT
96116: IFFALSE 96120
// exit ;
96118: GO 96179
// for i in tmp do
96120: LD_ADDR_VAR 0 2
96124: PUSH
96125: LD_VAR 0 4
96129: PUSH
96130: FOR_IN
96131: IFFALSE 96177
// for j = 1 to 3 do
96133: LD_ADDR_VAR 0 3
96137: PUSH
96138: DOUBLE
96139: LD_INT 1
96141: DEC
96142: ST_TO_ADDR
96143: LD_INT 3
96145: PUSH
96146: FOR_TO
96147: IFFALSE 96173
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
96149: LD_VAR 0 2
96153: PPUSH
96154: CALL_OW 274
96158: PPUSH
96159: LD_VAR 0 3
96163: PPUSH
96164: LD_INT 99999
96166: PPUSH
96167: CALL_OW 277
96171: GO 96146
96173: POP
96174: POP
96175: GO 96130
96177: POP
96178: POP
// end ;
96179: LD_VAR 0 1
96183: RET
// export function hHackSetLevel10 ; var i , j ; begin
96184: LD_INT 0
96186: PPUSH
96187: PPUSH
96188: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96189: LD_ADDR_VAR 0 2
96193: PUSH
96194: LD_INT 21
96196: PUSH
96197: LD_INT 1
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PPUSH
96204: CALL_OW 69
96208: PUSH
96209: FOR_IN
96210: IFFALSE 96262
// if IsSelected ( i ) then
96212: LD_VAR 0 2
96216: PPUSH
96217: CALL_OW 306
96221: IFFALSE 96260
// begin for j := 1 to 4 do
96223: LD_ADDR_VAR 0 3
96227: PUSH
96228: DOUBLE
96229: LD_INT 1
96231: DEC
96232: ST_TO_ADDR
96233: LD_INT 4
96235: PUSH
96236: FOR_TO
96237: IFFALSE 96258
// SetSkill ( i , j , 10 ) ;
96239: LD_VAR 0 2
96243: PPUSH
96244: LD_VAR 0 3
96248: PPUSH
96249: LD_INT 10
96251: PPUSH
96252: CALL_OW 237
96256: GO 96236
96258: POP
96259: POP
// end ;
96260: GO 96209
96262: POP
96263: POP
// end ;
96264: LD_VAR 0 1
96268: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
96269: LD_INT 0
96271: PPUSH
96272: PPUSH
96273: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
96274: LD_ADDR_VAR 0 2
96278: PUSH
96279: LD_INT 22
96281: PUSH
96282: LD_OWVAR 2
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: LD_INT 21
96293: PUSH
96294: LD_INT 1
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PPUSH
96305: CALL_OW 69
96309: PUSH
96310: FOR_IN
96311: IFFALSE 96352
// begin for j := 1 to 4 do
96313: LD_ADDR_VAR 0 3
96317: PUSH
96318: DOUBLE
96319: LD_INT 1
96321: DEC
96322: ST_TO_ADDR
96323: LD_INT 4
96325: PUSH
96326: FOR_TO
96327: IFFALSE 96348
// SetSkill ( i , j , 10 ) ;
96329: LD_VAR 0 2
96333: PPUSH
96334: LD_VAR 0 3
96338: PPUSH
96339: LD_INT 10
96341: PPUSH
96342: CALL_OW 237
96346: GO 96326
96348: POP
96349: POP
// end ;
96350: GO 96310
96352: POP
96353: POP
// end ;
96354: LD_VAR 0 1
96358: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
96359: LD_INT 0
96361: PPUSH
// uc_side := your_side ;
96362: LD_ADDR_OWVAR 20
96366: PUSH
96367: LD_OWVAR 2
96371: ST_TO_ADDR
// uc_nation := nation ;
96372: LD_ADDR_OWVAR 21
96376: PUSH
96377: LD_VAR 0 1
96381: ST_TO_ADDR
// InitHc ;
96382: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
96386: LD_INT 0
96388: PPUSH
96389: LD_VAR 0 2
96393: PPUSH
96394: LD_VAR 0 3
96398: PPUSH
96399: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
96403: LD_VAR 0 4
96407: PPUSH
96408: LD_VAR 0 5
96412: PPUSH
96413: CALL_OW 428
96417: PUSH
96418: LD_INT 0
96420: EQUAL
96421: IFFALSE 96445
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
96423: CALL_OW 44
96427: PPUSH
96428: LD_VAR 0 4
96432: PPUSH
96433: LD_VAR 0 5
96437: PPUSH
96438: LD_INT 1
96440: PPUSH
96441: CALL_OW 48
// end ;
96445: LD_VAR 0 6
96449: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
96450: LD_INT 0
96452: PPUSH
96453: PPUSH
// uc_side := your_side ;
96454: LD_ADDR_OWVAR 20
96458: PUSH
96459: LD_OWVAR 2
96463: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
96464: LD_VAR 0 1
96468: PUSH
96469: LD_INT 1
96471: PUSH
96472: LD_INT 2
96474: PUSH
96475: LD_INT 3
96477: PUSH
96478: LD_INT 4
96480: PUSH
96481: LD_INT 5
96483: PUSH
96484: EMPTY
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: IN
96491: IFFALSE 96503
// uc_nation := nation_american else
96493: LD_ADDR_OWVAR 21
96497: PUSH
96498: LD_INT 1
96500: ST_TO_ADDR
96501: GO 96546
// if chassis in [ 11 , 12 , 13 , 14 ] then
96503: LD_VAR 0 1
96507: PUSH
96508: LD_INT 11
96510: PUSH
96511: LD_INT 12
96513: PUSH
96514: LD_INT 13
96516: PUSH
96517: LD_INT 14
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: IN
96526: IFFALSE 96538
// uc_nation := nation_arabian else
96528: LD_ADDR_OWVAR 21
96532: PUSH
96533: LD_INT 2
96535: ST_TO_ADDR
96536: GO 96546
// uc_nation := nation_russian ;
96538: LD_ADDR_OWVAR 21
96542: PUSH
96543: LD_INT 3
96545: ST_TO_ADDR
// vc_chassis := chassis ;
96546: LD_ADDR_OWVAR 37
96550: PUSH
96551: LD_VAR 0 1
96555: ST_TO_ADDR
// vc_engine := engine ;
96556: LD_ADDR_OWVAR 39
96560: PUSH
96561: LD_VAR 0 2
96565: ST_TO_ADDR
// vc_control := control ;
96566: LD_ADDR_OWVAR 38
96570: PUSH
96571: LD_VAR 0 3
96575: ST_TO_ADDR
// vc_weapon := weapon ;
96576: LD_ADDR_OWVAR 40
96580: PUSH
96581: LD_VAR 0 4
96585: ST_TO_ADDR
// un := CreateVehicle ;
96586: LD_ADDR_VAR 0 8
96590: PUSH
96591: CALL_OW 45
96595: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
96596: LD_VAR 0 8
96600: PPUSH
96601: LD_INT 0
96603: PPUSH
96604: LD_INT 5
96606: PPUSH
96607: CALL_OW 12
96611: PPUSH
96612: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
96616: LD_VAR 0 8
96620: PPUSH
96621: LD_VAR 0 5
96625: PPUSH
96626: LD_VAR 0 6
96630: PPUSH
96631: LD_INT 1
96633: PPUSH
96634: CALL_OW 48
// end ;
96638: LD_VAR 0 7
96642: RET
// export hInvincible ; every 1 do
96643: GO 96645
96645: DISABLE
// hInvincible := [ ] ;
96646: LD_ADDR_EXP 142
96650: PUSH
96651: EMPTY
96652: ST_TO_ADDR
96653: END
// every 10 do var i ;
96654: GO 96656
96656: DISABLE
96657: LD_INT 0
96659: PPUSH
// begin enable ;
96660: ENABLE
// if not hInvincible then
96661: LD_EXP 142
96665: NOT
96666: IFFALSE 96670
// exit ;
96668: GO 96714
// for i in hInvincible do
96670: LD_ADDR_VAR 0 1
96674: PUSH
96675: LD_EXP 142
96679: PUSH
96680: FOR_IN
96681: IFFALSE 96712
// if GetLives ( i ) < 1000 then
96683: LD_VAR 0 1
96687: PPUSH
96688: CALL_OW 256
96692: PUSH
96693: LD_INT 1000
96695: LESS
96696: IFFALSE 96710
// SetLives ( i , 1000 ) ;
96698: LD_VAR 0 1
96702: PPUSH
96703: LD_INT 1000
96705: PPUSH
96706: CALL_OW 234
96710: GO 96680
96712: POP
96713: POP
// end ;
96714: PPOPN 1
96716: END
// export function hHackInvincible ; var i ; begin
96717: LD_INT 0
96719: PPUSH
96720: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
96721: LD_ADDR_VAR 0 2
96725: PUSH
96726: LD_INT 2
96728: PUSH
96729: LD_INT 21
96731: PUSH
96732: LD_INT 1
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PUSH
96739: LD_INT 21
96741: PUSH
96742: LD_INT 2
96744: PUSH
96745: EMPTY
96746: LIST
96747: LIST
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: LIST
96753: PPUSH
96754: CALL_OW 69
96758: PUSH
96759: FOR_IN
96760: IFFALSE 96821
// if IsSelected ( i ) then
96762: LD_VAR 0 2
96766: PPUSH
96767: CALL_OW 306
96771: IFFALSE 96819
// begin if i in hInvincible then
96773: LD_VAR 0 2
96777: PUSH
96778: LD_EXP 142
96782: IN
96783: IFFALSE 96803
// hInvincible := hInvincible diff i else
96785: LD_ADDR_EXP 142
96789: PUSH
96790: LD_EXP 142
96794: PUSH
96795: LD_VAR 0 2
96799: DIFF
96800: ST_TO_ADDR
96801: GO 96819
// hInvincible := hInvincible union i ;
96803: LD_ADDR_EXP 142
96807: PUSH
96808: LD_EXP 142
96812: PUSH
96813: LD_VAR 0 2
96817: UNION
96818: ST_TO_ADDR
// end ;
96819: GO 96759
96821: POP
96822: POP
// end ;
96823: LD_VAR 0 1
96827: RET
// export function hHackInvisible ; var i , j ; begin
96828: LD_INT 0
96830: PPUSH
96831: PPUSH
96832: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
96833: LD_ADDR_VAR 0 2
96837: PUSH
96838: LD_INT 21
96840: PUSH
96841: LD_INT 1
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PPUSH
96848: CALL_OW 69
96852: PUSH
96853: FOR_IN
96854: IFFALSE 96878
// if IsSelected ( i ) then
96856: LD_VAR 0 2
96860: PPUSH
96861: CALL_OW 306
96865: IFFALSE 96876
// ComForceInvisible ( i ) ;
96867: LD_VAR 0 2
96871: PPUSH
96872: CALL_OW 496
96876: GO 96853
96878: POP
96879: POP
// end ;
96880: LD_VAR 0 1
96884: RET
// export function hHackChangeYourSide ; begin
96885: LD_INT 0
96887: PPUSH
// if your_side = 8 then
96888: LD_OWVAR 2
96892: PUSH
96893: LD_INT 8
96895: EQUAL
96896: IFFALSE 96908
// your_side := 0 else
96898: LD_ADDR_OWVAR 2
96902: PUSH
96903: LD_INT 0
96905: ST_TO_ADDR
96906: GO 96922
// your_side := your_side + 1 ;
96908: LD_ADDR_OWVAR 2
96912: PUSH
96913: LD_OWVAR 2
96917: PUSH
96918: LD_INT 1
96920: PLUS
96921: ST_TO_ADDR
// end ;
96922: LD_VAR 0 1
96926: RET
// export function hHackChangeUnitSide ; var i , j ; begin
96927: LD_INT 0
96929: PPUSH
96930: PPUSH
96931: PPUSH
// for i in all_units do
96932: LD_ADDR_VAR 0 2
96936: PUSH
96937: LD_OWVAR 3
96941: PUSH
96942: FOR_IN
96943: IFFALSE 97021
// if IsSelected ( i ) then
96945: LD_VAR 0 2
96949: PPUSH
96950: CALL_OW 306
96954: IFFALSE 97019
// begin j := GetSide ( i ) ;
96956: LD_ADDR_VAR 0 3
96960: PUSH
96961: LD_VAR 0 2
96965: PPUSH
96966: CALL_OW 255
96970: ST_TO_ADDR
// if j = 8 then
96971: LD_VAR 0 3
96975: PUSH
96976: LD_INT 8
96978: EQUAL
96979: IFFALSE 96991
// j := 0 else
96981: LD_ADDR_VAR 0 3
96985: PUSH
96986: LD_INT 0
96988: ST_TO_ADDR
96989: GO 97005
// j := j + 1 ;
96991: LD_ADDR_VAR 0 3
96995: PUSH
96996: LD_VAR 0 3
97000: PUSH
97001: LD_INT 1
97003: PLUS
97004: ST_TO_ADDR
// SetSide ( i , j ) ;
97005: LD_VAR 0 2
97009: PPUSH
97010: LD_VAR 0 3
97014: PPUSH
97015: CALL_OW 235
// end ;
97019: GO 96942
97021: POP
97022: POP
// end ;
97023: LD_VAR 0 1
97027: RET
// export function hHackFog ; begin
97028: LD_INT 0
97030: PPUSH
// FogOff ( true ) ;
97031: LD_INT 1
97033: PPUSH
97034: CALL_OW 344
// end ;
97038: LD_VAR 0 1
97042: RET
// export function hHackTeleport ( unit , x , y ) ; begin
97043: LD_INT 0
97045: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
97046: LD_VAR 0 1
97050: PPUSH
97051: LD_VAR 0 2
97055: PPUSH
97056: LD_VAR 0 3
97060: PPUSH
97061: LD_INT 1
97063: PPUSH
97064: LD_INT 1
97066: PPUSH
97067: CALL_OW 483
// CenterOnXY ( x , y ) ;
97071: LD_VAR 0 2
97075: PPUSH
97076: LD_VAR 0 3
97080: PPUSH
97081: CALL_OW 84
// end ; end_of_file
97085: LD_VAR 0 4
97089: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
97090: LD_VAR 0 1
97094: PPUSH
97095: LD_VAR 0 2
97099: PPUSH
97100: LD_VAR 0 3
97104: PPUSH
97105: LD_VAR 0 4
97109: PPUSH
97110: LD_VAR 0 5
97114: PPUSH
97115: LD_VAR 0 6
97119: PPUSH
97120: CALL 83918 0 6
// end ;
97124: PPOPN 6
97126: END
