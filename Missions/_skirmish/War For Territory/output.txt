// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 210 0 0
// if debug then
  15: LD_EXP 1
  19: IFFALSE 38
// begin FogOff ( 1 ) ;
  21: LD_INT 1
  23: PPUSH
  24: CALL_OW 344
// Difficulty := 2 ;
  28: LD_ADDR_OWVAR 67
  32: PUSH
  33: LD_INT 2
  35: ST_TO_ADDR
// end else
  36: GO 51
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  38: LD_ADDR_OWVAR 67
  42: PUSH
  43: LD_INT 0
  45: PPUSH
  46: CALL_OW 426
  50: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  51: LD_INT 4
  53: PPUSH
  54: LD_INT 1
  56: PPUSH
  57: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 0
  66: PPUSH
  67: LD_INT 5
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 0
  81: PPUSH
  82: LD_INT 7
  84: PPUSH
  85: LD_INT 0
  87: PPUSH
  88: CALL 45954 0 9
// PrepareNature ( 0 , 0 , 3 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 0
  97: PPUSH
  98: LD_INT 3
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 0
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 0
 112: PPUSH
 113: LD_INT 4
 115: PPUSH
 116: LD_INT 0
 118: PPUSH
 119: CALL 45954 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 0
 128: PPUSH
 129: LD_INT 5
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 0
 143: PPUSH
 144: LD_INT 11
 146: PPUSH
 147: LD_INT 0
 149: PPUSH
 150: CALL 45954 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 154: LD_INT 0
 156: PPUSH
 157: LD_INT 0
 159: PPUSH
 160: LD_INT 5
 162: PPUSH
 163: LD_INT 0
 165: PPUSH
 166: LD_INT 0
 168: PPUSH
 169: LD_INT 0
 171: PPUSH
 172: LD_INT 0
 174: PPUSH
 175: LD_INT 14
 177: PPUSH
 178: LD_INT 0
 180: PPUSH
 181: CALL 45954 0 9
// PrepareGensher ;
 185: CALL 3190 0 0
// PreparePopov ;
 189: CALL 6437 0 0
// PreparePowell ;
 193: CALL 589 0 0
// PrepareSikorski ;
 197: CALL 9165 0 0
// MC_Start ( ) ;
 201: CALL 56837 0 0
// Action ;
 205: CALL 9572 0 0
// end ;
 209: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 210: LD_INT 0
 212: PPUSH
// debug := false ;
 213: LD_ADDR_EXP 1
 217: PUSH
 218: LD_INT 0
 220: ST_TO_ADDR
// game := true ;
 221: LD_ADDR_EXP 2
 225: PUSH
 226: LD_INT 1
 228: ST_TO_ADDR
// staticMines := [ ] ;
 229: LD_ADDR_EXP 3
 233: PUSH
 234: EMPTY
 235: ST_TO_ADDR
// arDestroyed := false ;
 236: LD_ADDR_EXP 4
 240: PUSH
 241: LD_INT 0
 243: ST_TO_ADDR
// ruDestroyed := false ;
 244: LD_ADDR_EXP 5
 248: PUSH
 249: LD_INT 0
 251: ST_TO_ADDR
// powellInTrouble := false ;
 252: LD_ADDR_EXP 8
 256: PUSH
 257: LD_INT 0
 259: ST_TO_ADDR
// sikorskiInTrouble := false ;
 260: LD_ADDR_EXP 9
 264: PUSH
 265: LD_INT 0
 267: ST_TO_ADDR
// end ;
 268: LD_VAR 0 1
 272: RET
// export function CustomInitMacro ; begin
 273: LD_INT 0
 275: PPUSH
// InitMC_Gensher ( ) ;
 276: CALL 4356 0 0
// InitMC_Powell ( ) ;
 280: CALL 1543 0 0
// InitMC_Popov ( ) ;
 284: CALL 7627 0 0
// end ;
 288: LD_VAR 0 1
 292: RET
// every 0 0$10 do var cr , time , i ;
 293: GO 295
 295: DISABLE
 296: LD_INT 0
 298: PPUSH
 299: PPUSH
 300: PPUSH
// begin time := 0 0$20 ;
 301: LD_ADDR_VAR 0 2
 305: PUSH
 306: LD_INT 700
 308: ST_TO_ADDR
// repeat wait ( time ) ;
 309: LD_VAR 0 2
 313: PPUSH
 314: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 318: LD_ADDR_VAR 0 1
 322: PUSH
 323: LD_INT 1
 325: PPUSH
 326: LD_INT 5
 328: PPUSH
 329: CALL_OW 12
 333: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 334: LD_ADDR_VAR 0 3
 338: PUSH
 339: LD_INT 5
 341: PUSH
 342: LD_INT 8
 344: PUSH
 345: LD_INT 12
 347: PUSH
 348: LD_INT 13
 350: PUSH
 351: EMPTY
 352: LIST
 353: LIST
 354: LIST
 355: LIST
 356: PUSH
 357: FOR_IN
 358: IFFALSE 412
// begin if GetResourceArea ( i , mat_cans ) < 40 then
 360: LD_VAR 0 3
 364: PPUSH
 365: LD_INT 1
 367: PPUSH
 368: CALL_OW 287
 372: PUSH
 373: LD_INT 40
 375: LESS
 376: IFFALSE 395
// CreateCratesArea ( cr , i , true ) ;
 378: LD_VAR 0 1
 382: PPUSH
 383: LD_VAR 0 3
 387: PPUSH
 388: LD_INT 1
 390: PPUSH
 391: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$15 ) ) ;
 395: LD_INT 175
 397: PPUSH
 398: LD_INT 525
 400: PPUSH
 401: CALL_OW 12
 405: PPUSH
 406: CALL_OW 67
// end ;
 410: GO 357
 412: POP
 413: POP
// time := time + 0 0$2 ;
 414: LD_ADDR_VAR 0 2
 418: PUSH
 419: LD_VAR 0 2
 423: PUSH
 424: LD_INT 70
 426: PLUS
 427: ST_TO_ADDR
// if time > 0 0$35 then
 428: LD_VAR 0 2
 432: PUSH
 433: LD_INT 1225
 435: GREATER
 436: IFFALSE 446
// time := 0 0$25 ;
 438: LD_ADDR_VAR 0 2
 442: PUSH
 443: LD_INT 875
 445: ST_TO_ADDR
// until not game ;
 446: LD_EXP 2
 450: NOT
 451: IFFALSE 309
// end ;
 453: PPOPN 3
 455: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) do var i , tmp ;
 456: LD_INT 3
 458: PUSH
 459: LD_INT 22
 461: PUSH
 462: LD_INT 1
 464: PUSH
 465: EMPTY
 466: LIST
 467: LIST
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: PUSH
 473: LD_INT 32
 475: PUSH
 476: LD_INT 1
 478: PUSH
 479: EMPTY
 480: LIST
 481: LIST
 482: PUSH
 483: EMPTY
 484: LIST
 485: LIST
 486: PPUSH
 487: CALL_OW 69
 491: IFFALSE 586
 493: GO 495
 495: DISABLE
 496: LD_INT 0
 498: PPUSH
 499: PPUSH
// begin enable ;
 500: ENABLE
// tmp := FilterAllUnits ( [ [ f_not , [ f_side , 1 ] ] , [ f_engine , engine_combustion ] ] ) ;
 501: LD_ADDR_VAR 0 2
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: LD_INT 22
 511: PUSH
 512: LD_INT 1
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: PUSH
 519: EMPTY
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 32
 525: PUSH
 526: LD_INT 1
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PUSH
 533: EMPTY
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL_OW 69
 541: ST_TO_ADDR
// for i in tmp do
 542: LD_ADDR_VAR 0 1
 546: PUSH
 547: LD_VAR 0 2
 551: PUSH
 552: FOR_IN
 553: IFFALSE 584
// if GetFuel ( i ) < 5 then
 555: LD_VAR 0 1
 559: PPUSH
 560: CALL_OW 261
 564: PUSH
 565: LD_INT 5
 567: LESS
 568: IFFALSE 582
// SetFuel ( i , 5 ) ;
 570: LD_VAR 0 1
 574: PPUSH
 575: LD_INT 5
 577: PPUSH
 578: CALL_OW 240
 582: GO 552
 584: POP
 585: POP
// end ; end_of_file
 586: PPOPN 2
 588: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , list , b , tmp ; begin
 589: LD_INT 0
 591: PPUSH
 592: PPUSH
 593: PPUSH
 594: PPUSH
 595: PPUSH
// powell_side := 4 ;
 596: LD_ADDR_EXP 11
 600: PUSH
 601: LD_INT 4
 603: ST_TO_ADDR
// uc_side := powell_side ;
 604: LD_ADDR_OWVAR 20
 608: PUSH
 609: LD_EXP 11
 613: ST_TO_ADDR
// uc_nation := 1 ;
 614: LD_ADDR_OWVAR 21
 618: PUSH
 619: LD_INT 1
 621: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 622: LD_ADDR_EXP 10
 626: PUSH
 627: LD_STRING Powell
 629: PPUSH
 630: CALL_OW 25
 634: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 635: LD_EXP 10
 639: PPUSH
 640: LD_INT 1
 642: PPUSH
 643: LD_INT 7
 645: PPUSH
 646: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 650: LD_EXP 10
 654: PPUSH
 655: LD_INT 2
 657: PPUSH
 658: LD_INT 5
 660: PPUSH
 661: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 665: LD_EXP 10
 669: PPUSH
 670: LD_INT 3
 672: PPUSH
 673: LD_INT 6
 675: PPUSH
 676: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 680: LD_EXP 10
 684: PPUSH
 685: LD_INT 4
 687: PPUSH
 688: LD_INT 4
 690: PPUSH
 691: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 695: LD_EXP 10
 699: PPUSH
 700: LD_INT 4
 702: PPUSH
 703: CALL_OW 52
// list := [ [ b_barracks , 178 , 117 , 2 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_lab , 200 , 111 , 4 , b_lab_weapon , b_lab_siberium ] , [ b_factory , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 , b_lab_computer , b_lab_opto ] , [ b_turret , 173 , 99 , 2 , us_heavy_gun ] , [ b_bunker , 174 , 102 , 2 , us_heavy_gun ] , [ b_bunker , 178 , 100 , 2 , us_heavy_gun ] , [ b_turret , 174 , 108 , 1 , us_rocket_launcher ] , [ b_turret , 182 , 122 , 1 , us_rocket_launcher ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 , us_heavy_gun ] , [ b_turret , 183 , 131 , 2 , us_radar ] , [ b_turret , 194 , 146 , 4 , us_rocket_launcher ] , [ b_turret , 190 , 142 , 4 , us_rocket_launcher ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ;
 707: LD_ADDR_VAR 0 3
 711: PUSH
 712: LD_INT 5
 714: PUSH
 715: LD_INT 178
 717: PUSH
 718: LD_INT 117
 720: PUSH
 721: LD_INT 2
 723: PUSH
 724: EMPTY
 725: LIST
 726: LIST
 727: LIST
 728: LIST
 729: PUSH
 730: LD_INT 29
 732: PUSH
 733: LD_INT 167
 735: PUSH
 736: LD_INT 102
 738: PUSH
 739: LD_INT 0
 741: PUSH
 742: EMPTY
 743: LIST
 744: LIST
 745: LIST
 746: LIST
 747: PUSH
 748: LD_INT 6
 750: PUSH
 751: LD_INT 200
 753: PUSH
 754: LD_INT 111
 756: PUSH
 757: LD_INT 4
 759: PUSH
 760: LD_INT 10
 762: PUSH
 763: LD_INT 11
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: LIST
 772: LIST
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 201
 779: PUSH
 780: LD_INT 140
 782: PUSH
 783: LD_INT 4
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_INT 27
 794: PUSH
 795: LD_INT 206
 797: PUSH
 798: LD_INT 124
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: EMPTY
 805: LIST
 806: LIST
 807: LIST
 808: LIST
 809: PUSH
 810: LD_INT 27
 812: PUSH
 813: LD_INT 209
 815: PUSH
 816: LD_INT 128
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: EMPTY
 823: LIST
 824: LIST
 825: LIST
 826: LIST
 827: PUSH
 828: LD_INT 27
 830: PUSH
 831: LD_INT 211
 833: PUSH
 834: LD_INT 132
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 30
 848: PUSH
 849: LD_INT 173
 851: PUSH
 852: LD_INT 83
 854: PUSH
 855: LD_INT 3
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 6
 866: PUSH
 867: LD_INT 186
 869: PUSH
 870: LD_INT 103
 872: PUSH
 873: LD_INT 2
 875: PUSH
 876: LD_INT 12
 878: PUSH
 879: LD_INT 15
 881: PUSH
 882: EMPTY
 883: LIST
 884: LIST
 885: LIST
 886: LIST
 887: LIST
 888: LIST
 889: PUSH
 890: LD_INT 33
 892: PUSH
 893: LD_INT 173
 895: PUSH
 896: LD_INT 99
 898: PUSH
 899: LD_INT 2
 901: PUSH
 902: LD_INT 6
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: LIST
 911: PUSH
 912: LD_INT 32
 914: PUSH
 915: LD_INT 174
 917: PUSH
 918: LD_INT 102
 920: PUSH
 921: LD_INT 2
 923: PUSH
 924: LD_INT 6
 926: PUSH
 927: EMPTY
 928: LIST
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PUSH
 934: LD_INT 32
 936: PUSH
 937: LD_INT 178
 939: PUSH
 940: LD_INT 100
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 6
 948: PUSH
 949: EMPTY
 950: LIST
 951: LIST
 952: LIST
 953: LIST
 954: LIST
 955: PUSH
 956: LD_INT 33
 958: PUSH
 959: LD_INT 174
 961: PUSH
 962: LD_INT 108
 964: PUSH
 965: LD_INT 1
 967: PUSH
 968: LD_INT 7
 970: PUSH
 971: EMPTY
 972: LIST
 973: LIST
 974: LIST
 975: LIST
 976: LIST
 977: PUSH
 978: LD_INT 33
 980: PUSH
 981: LD_INT 182
 983: PUSH
 984: LD_INT 122
 986: PUSH
 987: LD_INT 1
 989: PUSH
 990: LD_INT 7
 992: PUSH
 993: EMPTY
 994: LIST
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 36
1002: PUSH
1003: LD_INT 194
1005: PUSH
1006: LD_INT 124
1008: PUSH
1009: LD_INT 5
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 33
1020: PUSH
1021: LD_INT 184
1023: PUSH
1024: LD_INT 141
1026: PUSH
1027: LD_INT 1
1029: PUSH
1030: LD_INT 6
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: LIST
1039: PUSH
1040: LD_INT 33
1042: PUSH
1043: LD_INT 183
1045: PUSH
1046: LD_INT 131
1048: PUSH
1049: LD_INT 2
1051: PUSH
1052: LD_INT 11
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: LIST
1060: LIST
1061: PUSH
1062: LD_INT 33
1064: PUSH
1065: LD_INT 194
1067: PUSH
1068: LD_INT 146
1070: PUSH
1071: LD_INT 4
1073: PUSH
1074: LD_INT 7
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: PUSH
1084: LD_INT 33
1086: PUSH
1087: LD_INT 190
1089: PUSH
1090: LD_INT 142
1092: PUSH
1093: LD_INT 4
1095: PUSH
1096: LD_INT 7
1098: PUSH
1099: EMPTY
1100: LIST
1101: LIST
1102: LIST
1103: LIST
1104: LIST
1105: PUSH
1106: LD_INT 28
1108: PUSH
1109: LD_INT 204
1111: PUSH
1112: LD_INT 133
1114: PUSH
1115: LD_INT 3
1117: PUSH
1118: EMPTY
1119: LIST
1120: LIST
1121: LIST
1122: LIST
1123: PUSH
1124: LD_INT 27
1126: PUSH
1127: LD_INT 201
1129: PUSH
1130: LD_INT 133
1132: PUSH
1133: LD_INT 3
1135: PUSH
1136: EMPTY
1137: LIST
1138: LIST
1139: LIST
1140: LIST
1141: PUSH
1142: LD_INT 28
1144: PUSH
1145: LD_INT 199
1147: PUSH
1148: LD_INT 119
1150: PUSH
1151: LD_INT 5
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: LIST
1158: LIST
1159: PUSH
1160: EMPTY
1161: LIST
1162: LIST
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: LIST
1173: LIST
1174: LIST
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: LIST
1183: ST_TO_ADDR
// for i in list do
1184: LD_ADDR_VAR 0 2
1188: PUSH
1189: LD_VAR 0 3
1193: PUSH
1194: FOR_IN
1195: IFFALSE 1405
// begin uc_side := 4 ;
1197: LD_ADDR_OWVAR 20
1201: PUSH
1202: LD_INT 4
1204: ST_TO_ADDR
// uc_nation := 1 ;
1205: LD_ADDR_OWVAR 21
1209: PUSH
1210: LD_INT 1
1212: ST_TO_ADDR
// InitBc ;
1213: CALL_OW 21
// bc_type := i [ 1 ] ;
1217: LD_ADDR_OWVAR 42
1221: PUSH
1222: LD_VAR 0 2
1226: PUSH
1227: LD_INT 1
1229: ARRAY
1230: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
1231: LD_VAR 0 2
1235: PUSH
1236: LD_INT 1
1238: ARRAY
1239: PUSH
1240: LD_INT 29
1242: PUSH
1243: LD_INT 30
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: IN
1250: IFFALSE 1277
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 4 ) ;
1252: LD_VAR 0 2
1256: PUSH
1257: LD_INT 2
1259: ARRAY
1260: PPUSH
1261: LD_VAR 0 2
1265: PUSH
1266: LD_INT 3
1268: ARRAY
1269: PPUSH
1270: LD_INT 4
1272: PPUSH
1273: CALL_OW 441
// if i [ 1 ] = b_lab then
1277: LD_VAR 0 2
1281: PUSH
1282: LD_INT 1
1284: ARRAY
1285: PUSH
1286: LD_INT 6
1288: EQUAL
1289: IFFALSE 1327
// begin bc_type := b_lab_full ;
1291: LD_ADDR_OWVAR 42
1295: PUSH
1296: LD_INT 8
1298: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
1299: LD_ADDR_OWVAR 44
1303: PUSH
1304: LD_VAR 0 2
1308: PUSH
1309: LD_INT 5
1311: ARRAY
1312: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
1313: LD_ADDR_OWVAR 45
1317: PUSH
1318: LD_VAR 0 2
1322: PUSH
1323: LD_INT 6
1325: ARRAY
1326: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
1327: LD_ADDR_VAR 0 4
1331: PUSH
1332: LD_VAR 0 2
1336: PUSH
1337: LD_INT 2
1339: ARRAY
1340: PPUSH
1341: LD_VAR 0 2
1345: PUSH
1346: LD_INT 3
1348: ARRAY
1349: PPUSH
1350: LD_VAR 0 2
1354: PUSH
1355: LD_INT 4
1357: ARRAY
1358: PPUSH
1359: CALL_OW 47
1363: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
1364: LD_VAR 0 2
1368: PUSH
1369: LD_INT 1
1371: ARRAY
1372: PUSH
1373: LD_INT 33
1375: PUSH
1376: LD_INT 32
1378: PUSH
1379: EMPTY
1380: LIST
1381: LIST
1382: IN
1383: IFFALSE 1403
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
1385: LD_VAR 0 4
1389: PPUSH
1390: LD_VAR 0 2
1394: PUSH
1395: LD_INT 5
1397: ARRAY
1398: PPUSH
1399: CALL_OW 431
// end ;
1403: GO 1194
1405: POP
1406: POP
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 5500 , 500 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
1407: LD_ADDR_VAR 0 5
1411: PUSH
1412: LD_INT 4
1414: PPUSH
1415: LD_INT 1
1417: PPUSH
1418: LD_STRING 
1420: PPUSH
1421: LD_INT 8
1423: PUSH
1424: LD_INT 7
1426: PUSH
1427: LD_INT 6
1429: PUSH
1430: EMPTY
1431: LIST
1432: LIST
1433: LIST
1434: PUSH
1435: LD_OWVAR 67
1439: ARRAY
1440: PPUSH
1441: LD_INT 5500
1443: PUSH
1444: LD_INT 500
1446: PUSH
1447: LD_INT 0
1449: PUSH
1450: EMPTY
1451: LIST
1452: LIST
1453: LIST
1454: PPUSH
1455: LD_INT 6
1457: PUSH
1458: LD_INT 6
1460: PUSH
1461: LD_INT 6
1463: PUSH
1464: LD_INT 6
1466: PUSH
1467: EMPTY
1468: LIST
1469: LIST
1470: LIST
1471: LIST
1472: PPUSH
1473: CALL 19970 0 6
1477: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) ) ;
1478: LD_ADDR_EXP 23
1482: PUSH
1483: LD_EXP 23
1487: PPUSH
1488: LD_INT 1
1490: PPUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 22
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: EMPTY
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 21
1508: PUSH
1509: LD_INT 3
1511: PUSH
1512: EMPTY
1513: LIST
1514: LIST
1515: PUSH
1516: EMPTY
1517: LIST
1518: LIST
1519: PPUSH
1520: CALL_OW 69
1524: UNION
1525: PPUSH
1526: CALL_OW 1
1530: ST_TO_ADDR
// powellAttackGroup := [ ] ;
1531: LD_ADDR_EXP 12
1535: PUSH
1536: EMPTY
1537: ST_TO_ADDR
// end ;
1538: LD_VAR 0 1
1542: RET
// export function InitMC_Powell ( ) ; begin
1543: LD_INT 0
1545: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
1546: LD_INT 1
1548: PPUSH
1549: LD_INT 1
1551: PPUSH
1552: CALL 80500 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
1556: LD_INT 1
1558: PPUSH
1559: LD_INT 6
1561: PPUSH
1562: CALL 80440 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
1566: LD_INT 1
1568: PPUSH
1569: LD_INT 167
1571: PUSH
1572: LD_INT 102
1574: PUSH
1575: LD_INT 0
1577: PUSH
1578: EMPTY
1579: LIST
1580: LIST
1581: LIST
1582: PUSH
1583: LD_INT 173
1585: PUSH
1586: LD_INT 83
1588: PUSH
1589: LD_INT 1
1591: PUSH
1592: EMPTY
1593: LIST
1594: LIST
1595: LIST
1596: PUSH
1597: LD_INT 171
1599: PUSH
1600: LD_INT 141
1602: PUSH
1603: LD_INT 0
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 178
1613: PUSH
1614: LD_INT 148
1616: PUSH
1617: LD_INT 1
1619: PUSH
1620: EMPTY
1621: LIST
1622: LIST
1623: LIST
1624: PUSH
1625: EMPTY
1626: LIST
1627: LIST
1628: LIST
1629: LIST
1630: PPUSH
1631: CALL 79471 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
1635: LD_INT 1
1637: PPUSH
1638: LD_INT 11
1640: PUSH
1641: LD_INT 6
1643: PUSH
1644: LD_INT 7
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: LIST
1651: PPUSH
1652: CALL 80320 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: CALL 79990 0 2
// MC_SetTame ( 1 , powell_ape ) ;
1666: LD_INT 1
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: CALL 79713 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
1676: LD_INT 1
1678: PPUSH
1679: LD_INT 4
1681: PPUSH
1682: CALL 79332 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
1686: LD_INT 1
1688: PPUSH
1689: LD_INT 3
1691: PUSH
1692: LD_INT 1
1694: PUSH
1695: LD_INT 2
1697: PUSH
1698: LD_INT 5
1700: PUSH
1701: EMPTY
1702: LIST
1703: LIST
1704: LIST
1705: LIST
1706: PUSH
1707: LD_INT 4
1709: PUSH
1710: LD_INT 1
1712: PUSH
1713: LD_INT 2
1715: PUSH
1716: LD_INT 6
1718: PUSH
1719: EMPTY
1720: LIST
1721: LIST
1722: LIST
1723: LIST
1724: PUSH
1725: LD_INT 4
1727: PUSH
1728: LD_INT 1
1730: PUSH
1731: LD_INT 2
1733: PUSH
1734: LD_INT 7
1736: PUSH
1737: EMPTY
1738: LIST
1739: LIST
1740: LIST
1741: LIST
1742: PUSH
1743: LD_INT 4
1745: PUSH
1746: LD_INT 1
1748: PUSH
1749: LD_INT 2
1751: PUSH
1752: LD_INT 6
1754: PUSH
1755: EMPTY
1756: LIST
1757: LIST
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: LIST
1765: LIST
1766: PPUSH
1767: CALL 79147 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1771: LD_INT 1
1773: PPUSH
1774: LD_INT 201
1776: PPUSH
1777: LD_INT 140
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 19
1785: PUSH
1786: LD_INT 16
1788: PUSH
1789: LD_INT 17
1791: PUSH
1792: LD_INT 18
1794: PUSH
1795: LD_INT 22
1797: PUSH
1798: EMPTY
1799: LIST
1800: LIST
1801: LIST
1802: LIST
1803: LIST
1804: PPUSH
1805: CALL 80110 0 5
// end ;
1809: LD_VAR 0 1
1813: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1814: LD_INT 4
1816: PPUSH
1817: CALL_OW 302
1821: IFFALSE 2483
1823: GO 1825
1825: DISABLE
1826: LD_INT 0
1828: PPUSH
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// begin enable ;
1833: ENABLE
// base := 1 ;
1834: LD_ADDR_VAR 0 2
1838: PUSH
1839: LD_INT 1
1841: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1842: LD_ADDR_VAR 0 3
1846: PUSH
1847: LD_INT 4
1849: PUSH
1850: LD_INT 1
1852: PUSH
1853: LD_INT 2
1855: PUSH
1856: LD_INT 6
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: PUSH
1865: LD_INT 4
1867: PUSH
1868: LD_INT 1
1870: PUSH
1871: LD_INT 2
1873: PUSH
1874: LD_INT 6
1876: PUSH
1877: EMPTY
1878: LIST
1879: LIST
1880: LIST
1881: LIST
1882: PUSH
1883: LD_INT 3
1885: PUSH
1886: LD_INT 1
1888: PUSH
1889: LD_INT 2
1891: PUSH
1892: LD_INT 7
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_INT 3
1903: PUSH
1904: LD_INT 1
1906: PUSH
1907: LD_INT 2
1909: PUSH
1910: LD_INT 7
1912: PUSH
1913: EMPTY
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: PUSH
1919: EMPTY
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1925: LD_ADDR_VAR 0 5
1929: PUSH
1930: LD_VAR 0 5
1934: PUSH
1935: LD_OWVAR 1
1939: PUSH
1940: LD_INT 21000
1942: DIV
1943: PLUS
1944: ST_TO_ADDR
// if amount > 8 then
1945: LD_VAR 0 5
1949: PUSH
1950: LD_INT 8
1952: GREATER
1953: IFFALSE 1963
// amount := 8 ;
1955: LD_ADDR_VAR 0 5
1959: PUSH
1960: LD_INT 8
1962: ST_TO_ADDR
// for i = 1 to amount do
1963: LD_ADDR_VAR 0 1
1967: PUSH
1968: DOUBLE
1969: LD_INT 1
1971: DEC
1972: ST_TO_ADDR
1973: LD_VAR 0 5
1977: PUSH
1978: FOR_TO
1979: IFFALSE 2063
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1981: LD_ADDR_VAR 0 3
1985: PUSH
1986: LD_VAR 0 3
1990: PPUSH
1991: LD_VAR 0 3
1995: PUSH
1996: LD_INT 1
1998: PLUS
1999: PPUSH
2000: LD_INT 3
2002: PUSH
2003: LD_INT 4
2005: PUSH
2006: EMPTY
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 1
2012: PPUSH
2013: LD_INT 2
2015: PPUSH
2016: CALL_OW 12
2020: ARRAY
2021: PUSH
2022: LD_INT 1
2024: PUSH
2025: LD_INT 2
2027: PUSH
2028: LD_INT 7
2030: PUSH
2031: LD_INT 5
2033: PUSH
2034: EMPTY
2035: LIST
2036: LIST
2037: PUSH
2038: LD_INT 1
2040: PPUSH
2041: LD_INT 2
2043: PPUSH
2044: CALL_OW 12
2048: ARRAY
2049: PUSH
2050: EMPTY
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: PPUSH
2056: CALL_OW 2
2060: ST_TO_ADDR
2061: GO 1978
2063: POP
2064: POP
// MC_InsertProduceList ( base , tmp ) ;
2065: LD_VAR 0 2
2069: PPUSH
2070: LD_VAR 0 3
2074: PPUSH
2075: CALL 79195 0 2
// repeat wait ( 0 0$1 ) ;
2079: LD_INT 35
2081: PPUSH
2082: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
2086: LD_VAR 0 2
2090: PPUSH
2091: LD_INT 1
2093: PPUSH
2094: CALL 80651 0 2
2098: PUSH
2099: LD_VAR 0 5
2103: GREATEREQUAL
2104: IFFALSE 2079
// wait ( 0 0$30 ) ;
2106: LD_INT 1050
2108: PPUSH
2109: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
2113: LD_ADDR_VAR 0 4
2117: PUSH
2118: LD_EXP 42
2122: PUSH
2123: LD_VAR 0 2
2127: ARRAY
2128: PUSH
2129: LD_EXP 42
2133: PUSH
2134: LD_VAR 0 2
2138: ARRAY
2139: PPUSH
2140: LD_INT 2
2142: PUSH
2143: LD_INT 34
2145: PUSH
2146: LD_INT 12
2148: PUSH
2149: EMPTY
2150: LIST
2151: LIST
2152: PUSH
2153: LD_INT 34
2155: PUSH
2156: LD_INT 13
2158: PUSH
2159: EMPTY
2160: LIST
2161: LIST
2162: PUSH
2163: LD_INT 34
2165: PUSH
2166: LD_INT 14
2168: PUSH
2169: EMPTY
2170: LIST
2171: LIST
2172: PUSH
2173: EMPTY
2174: LIST
2175: LIST
2176: LIST
2177: LIST
2178: PPUSH
2179: CALL_OW 72
2183: DIFF
2184: ST_TO_ADDR
// if not attackers then
2185: LD_VAR 0 4
2189: NOT
2190: IFFALSE 2194
// exit ;
2192: GO 2483
// DialogPowellsAttack ;
2194: CALL 9703 0 0
// powellAttackGroup := attackers ;
2198: LD_ADDR_EXP 12
2202: PUSH
2203: LD_VAR 0 4
2207: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
2208: LD_ADDR_EXP 42
2212: PUSH
2213: LD_EXP 42
2217: PPUSH
2218: LD_VAR 0 2
2222: PPUSH
2223: LD_EXP 42
2227: PUSH
2228: LD_VAR 0 2
2232: ARRAY
2233: PUSH
2234: LD_VAR 0 4
2238: DIFF
2239: PPUSH
2240: CALL_OW 1
2244: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
2245: LD_EXP 9
2249: IFFALSE 2270
2251: PUSH
2252: LD_INT 16
2254: PPUSH
2255: LD_INT 81
2257: PUSH
2258: LD_INT 4
2260: PUSH
2261: EMPTY
2262: LIST
2263: LIST
2264: PPUSH
2265: CALL_OW 70
2269: AND
2270: IFFALSE 2289
// ComAgressiveMove ( attackers , 135 , 21 ) else
2272: LD_VAR 0 4
2276: PPUSH
2277: LD_INT 135
2279: PPUSH
2280: LD_INT 21
2282: PPUSH
2283: CALL_OW 114
2287: GO 2304
// ComAgressiveMove ( attackers , 146 , 103 ) ;
2289: LD_VAR 0 4
2293: PPUSH
2294: LD_INT 146
2296: PPUSH
2297: LD_INT 103
2299: PPUSH
2300: CALL_OW 114
// wait ( 0 0$5 ) ;
2304: LD_INT 175
2306: PPUSH
2307: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2311: LD_INT 35
2313: PPUSH
2314: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
2318: LD_VAR 0 4
2322: PPUSH
2323: LD_INT 60
2325: PUSH
2326: EMPTY
2327: LIST
2328: PPUSH
2329: CALL_OW 72
2333: NOT
2334: IFFALSE 2311
// if FilterAllUnits ( [ f_side , 3 ] ) then
2336: LD_INT 22
2338: PUSH
2339: LD_INT 3
2341: PUSH
2342: EMPTY
2343: LIST
2344: LIST
2345: PPUSH
2346: CALL_OW 69
2350: IFFALSE 2369
// ComAgressiveMove ( attackers , 102 , 116 ) else
2352: LD_VAR 0 4
2356: PPUSH
2357: LD_INT 102
2359: PPUSH
2360: LD_INT 116
2362: PPUSH
2363: CALL_OW 114
2367: GO 2384
// ComAgressiveMove ( attackers , 66 , 41 ) ;
2369: LD_VAR 0 4
2373: PPUSH
2374: LD_INT 66
2376: PPUSH
2377: LD_INT 41
2379: PPUSH
2380: CALL_OW 114
// wait ( 0 0$10 ) ;
2384: LD_INT 350
2386: PPUSH
2387: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
2391: LD_INT 35
2393: PPUSH
2394: CALL_OW 67
// for i in attackers do
2398: LD_ADDR_VAR 0 1
2402: PUSH
2403: LD_VAR 0 4
2407: PUSH
2408: FOR_IN
2409: IFFALSE 2459
// if not HasTask ( i ) then
2411: LD_VAR 0 1
2415: PPUSH
2416: CALL_OW 314
2420: NOT
2421: IFFALSE 2457
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2423: LD_VAR 0 1
2427: PPUSH
2428: LD_INT 81
2430: PUSH
2431: LD_INT 4
2433: PUSH
2434: EMPTY
2435: LIST
2436: LIST
2437: PPUSH
2438: CALL_OW 69
2442: PPUSH
2443: LD_VAR 0 1
2447: PPUSH
2448: CALL_OW 74
2452: PPUSH
2453: CALL_OW 115
2457: GO 2408
2459: POP
2460: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2461: LD_VAR 0 4
2465: PPUSH
2466: LD_INT 50
2468: PUSH
2469: EMPTY
2470: LIST
2471: PPUSH
2472: CALL_OW 72
2476: NOT
2477: IFFALSE 2391
// DialogPowellsAttackFailed ;
2479: CALL 9972 0 0
// end ;
2483: PPOPN 5
2485: END
// every 0 0$2 do var vehicles , mechs , i ;
2486: GO 2488
2488: DISABLE
2489: LD_INT 0
2491: PPUSH
2492: PPUSH
2493: PPUSH
// begin enable ;
2494: ENABLE
// vehicles := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 191 , 140 , 10 ] ] ) ;
2495: LD_ADDR_VAR 0 1
2499: PUSH
2500: LD_INT 22
2502: PUSH
2503: LD_INT 1
2505: PUSH
2506: EMPTY
2507: LIST
2508: LIST
2509: PUSH
2510: LD_INT 21
2512: PUSH
2513: LD_INT 2
2515: PUSH
2516: EMPTY
2517: LIST
2518: LIST
2519: PUSH
2520: LD_INT 3
2522: PUSH
2523: LD_INT 24
2525: PUSH
2526: LD_INT 1000
2528: PUSH
2529: EMPTY
2530: LIST
2531: LIST
2532: PUSH
2533: EMPTY
2534: LIST
2535: LIST
2536: PUSH
2537: LD_INT 92
2539: PUSH
2540: LD_INT 191
2542: PUSH
2543: LD_INT 140
2545: PUSH
2546: LD_INT 10
2548: PUSH
2549: EMPTY
2550: LIST
2551: LIST
2552: LIST
2553: LIST
2554: PUSH
2555: EMPTY
2556: LIST
2557: LIST
2558: LIST
2559: LIST
2560: PPUSH
2561: CALL_OW 69
2565: ST_TO_ADDR
// mechs := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 3 ] ] ) ;
2566: LD_ADDR_VAR 0 2
2570: PUSH
2571: LD_INT 22
2573: PUSH
2574: LD_INT 4
2576: PUSH
2577: EMPTY
2578: LIST
2579: LIST
2580: PUSH
2581: LD_INT 25
2583: PUSH
2584: LD_INT 3
2586: PUSH
2587: EMPTY
2588: LIST
2589: LIST
2590: PUSH
2591: EMPTY
2592: LIST
2593: LIST
2594: PPUSH
2595: CALL_OW 69
2599: ST_TO_ADDR
// if not mechs then
2600: LD_VAR 0 2
2604: NOT
2605: IFFALSE 2609
// exit ;
2607: GO 2783
// if mc_remote_driver [ 1 ] then
2609: LD_EXP 63
2613: PUSH
2614: LD_INT 1
2616: ARRAY
2617: IFFALSE 2639
// mechs := mechs diff mc_remote_driver [ 1 ] ;
2619: LD_ADDR_VAR 0 2
2623: PUSH
2624: LD_VAR 0 2
2628: PUSH
2629: LD_EXP 63
2633: PUSH
2634: LD_INT 1
2636: ARRAY
2637: DIFF
2638: ST_TO_ADDR
// if not mechs then
2639: LD_VAR 0 2
2643: NOT
2644: IFFALSE 2648
// exit ;
2646: GO 2783
// if vehicles then
2648: LD_VAR 0 1
2652: IFFALSE 2740
// begin for i in mechs do
2654: LD_ADDR_VAR 0 3
2658: PUSH
2659: LD_VAR 0 2
2663: PUSH
2664: FOR_IN
2665: IFFALSE 2736
// begin if GetTag ( i ) <> 120 then
2667: LD_VAR 0 3
2671: PPUSH
2672: CALL_OW 110
2676: PUSH
2677: LD_INT 120
2679: NONEQUAL
2680: IFFALSE 2694
// SetTag ( i , 120 ) ;
2682: LD_VAR 0 3
2686: PPUSH
2687: LD_INT 120
2689: PPUSH
2690: CALL_OW 109
// if IsInUnit ( i ) then
2694: LD_VAR 0 3
2698: PPUSH
2699: CALL_OW 310
2703: IFFALSE 2716
// ComExitBuilding ( i ) else
2705: LD_VAR 0 3
2709: PPUSH
2710: CALL_OW 122
2714: GO 2734
// ComRepairVehicle ( i , vehicles [ 1 ] ) ;
2716: LD_VAR 0 3
2720: PPUSH
2721: LD_VAR 0 1
2725: PUSH
2726: LD_INT 1
2728: ARRAY
2729: PPUSH
2730: CALL_OW 129
// end ;
2734: GO 2664
2736: POP
2737: POP
// end else
2738: GO 2783
// if FilterByTag ( mechs , 120 ) then
2740: LD_VAR 0 2
2744: PPUSH
2745: LD_INT 120
2747: PPUSH
2748: CALL 46848 0 2
2752: IFFALSE 2783
// begin for i in mechs do
2754: LD_ADDR_VAR 0 3
2758: PUSH
2759: LD_VAR 0 2
2763: PUSH
2764: FOR_IN
2765: IFFALSE 2781
// begin SetTag ( i , 0 ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 0
2774: PPUSH
2775: CALL_OW 109
// end ;
2779: GO 2764
2781: POP
2782: POP
// end ; end ;
2783: PPOPN 3
2785: END
// every 0 0$2 do var people , sci , i ;
2786: GO 2788
2788: DISABLE
2789: LD_INT 0
2791: PPUSH
2792: PPUSH
2793: PPUSH
// begin enable ;
2794: ENABLE
// people := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_not , [ f_lives , 1000 ] ] , [ f_distxy , 188 , 112 , 10 ] ] ) ;
2795: LD_ADDR_VAR 0 1
2799: PUSH
2800: LD_INT 22
2802: PUSH
2803: LD_INT 1
2805: PUSH
2806: EMPTY
2807: LIST
2808: LIST
2809: PUSH
2810: LD_INT 21
2812: PUSH
2813: LD_INT 1
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PUSH
2820: LD_INT 3
2822: PUSH
2823: LD_INT 24
2825: PUSH
2826: LD_INT 1000
2828: PUSH
2829: EMPTY
2830: LIST
2831: LIST
2832: PUSH
2833: EMPTY
2834: LIST
2835: LIST
2836: PUSH
2837: LD_INT 92
2839: PUSH
2840: LD_INT 188
2842: PUSH
2843: LD_INT 112
2845: PUSH
2846: LD_INT 10
2848: PUSH
2849: EMPTY
2850: LIST
2851: LIST
2852: LIST
2853: LIST
2854: PUSH
2855: EMPTY
2856: LIST
2857: LIST
2858: LIST
2859: LIST
2860: PPUSH
2861: CALL_OW 69
2865: ST_TO_ADDR
// sci := FilterAllUnits ( [ [ f_side , 4 ] , [ f_class , 4 ] ] ) ;
2866: LD_ADDR_VAR 0 2
2870: PUSH
2871: LD_INT 22
2873: PUSH
2874: LD_INT 4
2876: PUSH
2877: EMPTY
2878: LIST
2879: LIST
2880: PUSH
2881: LD_INT 25
2883: PUSH
2884: LD_INT 4
2886: PUSH
2887: EMPTY
2888: LIST
2889: LIST
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: PPUSH
2895: CALL_OW 69
2899: ST_TO_ADDR
// if not sci then
2900: LD_VAR 0 2
2904: NOT
2905: IFFALSE 2909
// exit ;
2907: GO 3044
// if people then
2909: LD_VAR 0 1
2913: IFFALSE 3001
// begin for i in sci do
2915: LD_ADDR_VAR 0 3
2919: PUSH
2920: LD_VAR 0 2
2924: PUSH
2925: FOR_IN
2926: IFFALSE 2997
// begin if GetTag ( i ) <> 102 then
2928: LD_VAR 0 3
2932: PPUSH
2933: CALL_OW 110
2937: PUSH
2938: LD_INT 102
2940: NONEQUAL
2941: IFFALSE 2955
// SetTag ( i , 102 ) ;
2943: LD_VAR 0 3
2947: PPUSH
2948: LD_INT 102
2950: PPUSH
2951: CALL_OW 109
// if IsInUnit ( i ) then
2955: LD_VAR 0 3
2959: PPUSH
2960: CALL_OW 310
2964: IFFALSE 2977
// ComExitBuilding ( i ) else
2966: LD_VAR 0 3
2970: PPUSH
2971: CALL_OW 122
2975: GO 2995
// ComHeal ( i , people [ 1 ] ) ;
2977: LD_VAR 0 3
2981: PPUSH
2982: LD_VAR 0 1
2986: PUSH
2987: LD_INT 1
2989: ARRAY
2990: PPUSH
2991: CALL_OW 128
// end ;
2995: GO 2925
2997: POP
2998: POP
// end else
2999: GO 3044
// if FilterByTag ( sci , 102 ) then
3001: LD_VAR 0 2
3005: PPUSH
3006: LD_INT 102
3008: PPUSH
3009: CALL 46848 0 2
3013: IFFALSE 3044
// begin for i in sci do
3015: LD_ADDR_VAR 0 3
3019: PUSH
3020: LD_VAR 0 2
3024: PUSH
3025: FOR_IN
3026: IFFALSE 3042
// begin SetTag ( i , 0 ) ;
3028: LD_VAR 0 3
3032: PPUSH
3033: LD_INT 0
3035: PPUSH
3036: CALL_OW 109
// end ;
3040: GO 3025
3042: POP
3043: POP
// end ; end ;
3044: PPOPN 3
3046: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
3047: LD_INT 22
3049: PUSH
3050: LD_INT 4
3052: PUSH
3053: EMPTY
3054: LIST
3055: LIST
3056: PUSH
3057: LD_INT 33
3059: PUSH
3060: LD_INT 2
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 50
3069: PUSH
3070: EMPTY
3071: LIST
3072: PUSH
3073: LD_INT 3
3075: PUSH
3076: LD_INT 61
3078: PUSH
3079: EMPTY
3080: LIST
3081: PUSH
3082: EMPTY
3083: LIST
3084: LIST
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PPUSH
3092: CALL_OW 69
3096: IFFALSE 3187
3098: GO 3100
3100: DISABLE
3101: LD_INT 0
3103: PPUSH
3104: PPUSH
// begin enable ;
3105: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
3106: LD_ADDR_VAR 0 2
3110: PUSH
3111: LD_INT 22
3113: PUSH
3114: LD_INT 4
3116: PUSH
3117: EMPTY
3118: LIST
3119: LIST
3120: PUSH
3121: LD_INT 33
3123: PUSH
3124: LD_INT 2
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: LD_INT 50
3133: PUSH
3134: EMPTY
3135: LIST
3136: PUSH
3137: LD_INT 3
3139: PUSH
3140: LD_INT 61
3142: PUSH
3143: EMPTY
3144: LIST
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: EMPTY
3151: LIST
3152: LIST
3153: LIST
3154: LIST
3155: PPUSH
3156: CALL_OW 69
3160: ST_TO_ADDR
// for i in tmp do
3161: LD_ADDR_VAR 0 1
3165: PUSH
3166: LD_VAR 0 2
3170: PUSH
3171: FOR_IN
3172: IFFALSE 3185
// Connect ( i ) ;
3174: LD_VAR 0 1
3178: PPUSH
3179: CALL 19615 0 1
3183: GO 3171
3185: POP
3186: POP
// end ; end_of_file
3187: PPOPN 2
3189: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , b , tmp , un , list ; begin
3190: LD_INT 0
3192: PPUSH
3193: PPUSH
3194: PPUSH
3195: PPUSH
3196: PPUSH
3197: PPUSH
// gensher_side := 2 ;
3198: LD_ADDR_EXP 14
3202: PUSH
3203: LD_INT 2
3205: ST_TO_ADDR
// uc_side := gensher_side ;
3206: LD_ADDR_OWVAR 20
3210: PUSH
3211: LD_EXP 14
3215: ST_TO_ADDR
// uc_nation := 2 ;
3216: LD_ADDR_OWVAR 21
3220: PUSH
3221: LD_INT 2
3223: ST_TO_ADDR
// list := [ [ b_barracks , 42 , 29 , 5 ] , [ b_barracks , 36 , 40 , 5 ] , [ b_lab , 13 , 18 , 1 , b_lab_weapon , b_lab_opto ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_factory , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 , b_lab_biological , b_lab_siberium ] , [ b_bunker , 27 , 44 , 5 , ar_gun ] , [ b_bunker , 41 , 41 , 5 , ar_gun ] , [ b_bunker , 45 , 24 , 5 , ar_rocket_launcher ] , [ b_bunker , 48 , 19 , 5 , ar_rocket_launcher ] , [ b_bunker , 41 , 3 , 4 , ar_rocket_launcher ] , [ b_barracks , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ;
3224: LD_ADDR_VAR 0 6
3228: PUSH
3229: LD_INT 5
3231: PUSH
3232: LD_INT 42
3234: PUSH
3235: LD_INT 29
3237: PUSH
3238: LD_INT 5
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: LIST
3245: LIST
3246: PUSH
3247: LD_INT 5
3249: PUSH
3250: LD_INT 36
3252: PUSH
3253: LD_INT 40
3255: PUSH
3256: LD_INT 5
3258: PUSH
3259: EMPTY
3260: LIST
3261: LIST
3262: LIST
3263: LIST
3264: PUSH
3265: LD_INT 6
3267: PUSH
3268: LD_INT 13
3270: PUSH
3271: LD_INT 18
3273: PUSH
3274: LD_INT 1
3276: PUSH
3277: LD_INT 10
3279: PUSH
3280: LD_INT 15
3282: PUSH
3283: EMPTY
3284: LIST
3285: LIST
3286: LIST
3287: LIST
3288: LIST
3289: LIST
3290: PUSH
3291: LD_INT 27
3293: PUSH
3294: LD_INT 17
3296: PUSH
3297: LD_INT 3
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: LIST
3307: LIST
3308: PUSH
3309: LD_INT 29
3311: PUSH
3312: LD_INT 56
3314: PUSH
3315: LD_INT 23
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 3
3329: PUSH
3330: LD_INT 11
3332: PUSH
3333: LD_INT 7
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: LIST
3343: LIST
3344: PUSH
3345: LD_INT 27
3347: PUSH
3348: LD_INT 20
3350: PUSH
3351: LD_INT 3
3353: PUSH
3354: LD_INT 0
3356: PUSH
3357: EMPTY
3358: LIST
3359: LIST
3360: LIST
3361: LIST
3362: PUSH
3363: LD_INT 27
3365: PUSH
3366: LD_INT 23
3368: PUSH
3369: LD_INT 3
3371: PUSH
3372: LD_INT 0
3374: PUSH
3375: EMPTY
3376: LIST
3377: LIST
3378: LIST
3379: LIST
3380: PUSH
3381: LD_INT 27
3383: PUSH
3384: LD_INT 26
3386: PUSH
3387: LD_INT 3
3389: PUSH
3390: LD_INT 0
3392: PUSH
3393: EMPTY
3394: LIST
3395: LIST
3396: LIST
3397: LIST
3398: PUSH
3399: LD_INT 6
3401: PUSH
3402: LD_INT 17
3404: PUSH
3405: LD_INT 27
3407: PUSH
3408: LD_INT 1
3410: PUSH
3411: LD_INT 13
3413: PUSH
3414: LD_INT 11
3416: PUSH
3417: EMPTY
3418: LIST
3419: LIST
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: PUSH
3425: LD_INT 32
3427: PUSH
3428: LD_INT 27
3430: PUSH
3431: LD_INT 44
3433: PUSH
3434: LD_INT 5
3436: PUSH
3437: LD_INT 27
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: LIST
3444: LIST
3445: LIST
3446: PUSH
3447: LD_INT 32
3449: PUSH
3450: LD_INT 41
3452: PUSH
3453: LD_INT 41
3455: PUSH
3456: LD_INT 5
3458: PUSH
3459: LD_INT 27
3461: PUSH
3462: EMPTY
3463: LIST
3464: LIST
3465: LIST
3466: LIST
3467: LIST
3468: PUSH
3469: LD_INT 32
3471: PUSH
3472: LD_INT 45
3474: PUSH
3475: LD_INT 24
3477: PUSH
3478: LD_INT 5
3480: PUSH
3481: LD_INT 28
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: LIST
3488: LIST
3489: LIST
3490: PUSH
3491: LD_INT 32
3493: PUSH
3494: LD_INT 48
3496: PUSH
3497: LD_INT 19
3499: PUSH
3500: LD_INT 5
3502: PUSH
3503: LD_INT 28
3505: PUSH
3506: EMPTY
3507: LIST
3508: LIST
3509: LIST
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 32
3515: PUSH
3516: LD_INT 41
3518: PUSH
3519: LD_INT 3
3521: PUSH
3522: LD_INT 4
3524: PUSH
3525: LD_INT 28
3527: PUSH
3528: EMPTY
3529: LIST
3530: LIST
3531: LIST
3532: LIST
3533: LIST
3534: PUSH
3535: LD_INT 5
3537: PUSH
3538: LD_INT 44
3540: PUSH
3541: LD_INT 9
3543: PUSH
3544: LD_INT 4
3546: PUSH
3547: EMPTY
3548: LIST
3549: LIST
3550: LIST
3551: LIST
3552: PUSH
3553: LD_INT 30
3555: PUSH
3556: LD_INT 52
3558: PUSH
3559: LD_INT 40
3561: PUSH
3562: LD_INT 3
3564: PUSH
3565: EMPTY
3566: LIST
3567: LIST
3568: LIST
3569: LIST
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: LIST
3577: LIST
3578: LIST
3579: LIST
3580: LIST
3581: LIST
3582: LIST
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: LIST
3588: LIST
3589: ST_TO_ADDR
// for i in list do
3590: LD_ADDR_VAR 0 2
3594: PUSH
3595: LD_VAR 0 6
3599: PUSH
3600: FOR_IN
3601: IFFALSE 3811
// begin uc_side := 2 ;
3603: LD_ADDR_OWVAR 20
3607: PUSH
3608: LD_INT 2
3610: ST_TO_ADDR
// uc_nation := 2 ;
3611: LD_ADDR_OWVAR 21
3615: PUSH
3616: LD_INT 2
3618: ST_TO_ADDR
// InitBc ;
3619: CALL_OW 21
// bc_type := i [ 1 ] ;
3623: LD_ADDR_OWVAR 42
3627: PUSH
3628: LD_VAR 0 2
3632: PUSH
3633: LD_INT 1
3635: ARRAY
3636: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
3637: LD_VAR 0 2
3641: PUSH
3642: LD_INT 1
3644: ARRAY
3645: PUSH
3646: LD_INT 29
3648: PUSH
3649: LD_INT 30
3651: PUSH
3652: EMPTY
3653: LIST
3654: LIST
3655: IN
3656: IFFALSE 3683
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 2 ) ;
3658: LD_VAR 0 2
3662: PUSH
3663: LD_INT 2
3665: ARRAY
3666: PPUSH
3667: LD_VAR 0 2
3671: PUSH
3672: LD_INT 3
3674: ARRAY
3675: PPUSH
3676: LD_INT 2
3678: PPUSH
3679: CALL_OW 441
// if i [ 1 ] = b_lab then
3683: LD_VAR 0 2
3687: PUSH
3688: LD_INT 1
3690: ARRAY
3691: PUSH
3692: LD_INT 6
3694: EQUAL
3695: IFFALSE 3733
// begin bc_type := b_lab_full ;
3697: LD_ADDR_OWVAR 42
3701: PUSH
3702: LD_INT 8
3704: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
3705: LD_ADDR_OWVAR 44
3709: PUSH
3710: LD_VAR 0 2
3714: PUSH
3715: LD_INT 5
3717: ARRAY
3718: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
3719: LD_ADDR_OWVAR 45
3723: PUSH
3724: LD_VAR 0 2
3728: PUSH
3729: LD_INT 6
3731: ARRAY
3732: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
3733: LD_ADDR_VAR 0 3
3737: PUSH
3738: LD_VAR 0 2
3742: PUSH
3743: LD_INT 2
3745: ARRAY
3746: PPUSH
3747: LD_VAR 0 2
3751: PUSH
3752: LD_INT 3
3754: ARRAY
3755: PPUSH
3756: LD_VAR 0 2
3760: PUSH
3761: LD_INT 4
3763: ARRAY
3764: PPUSH
3765: CALL_OW 47
3769: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
3770: LD_VAR 0 2
3774: PUSH
3775: LD_INT 1
3777: ARRAY
3778: PUSH
3779: LD_INT 33
3781: PUSH
3782: LD_INT 32
3784: PUSH
3785: EMPTY
3786: LIST
3787: LIST
3788: IN
3789: IFFALSE 3809
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
3791: LD_VAR 0 3
3795: PPUSH
3796: LD_VAR 0 2
3800: PUSH
3801: LD_INT 5
3803: ARRAY
3804: PPUSH
3805: CALL_OW 431
// end ;
3809: GO 3600
3811: POP
3812: POP
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
3813: LD_ADDR_VAR 0 4
3817: PUSH
3818: LD_INT 7
3820: PPUSH
3821: LD_INT 2
3823: PPUSH
3824: LD_STRING 
3826: PPUSH
3827: LD_INT 8
3829: PUSH
3830: LD_INT 7
3832: PUSH
3833: LD_INT 6
3835: PUSH
3836: EMPTY
3837: LIST
3838: LIST
3839: LIST
3840: PUSH
3841: LD_OWVAR 67
3845: ARRAY
3846: PPUSH
3847: LD_INT 11500
3849: PUSH
3850: LD_INT 1100
3852: PUSH
3853: LD_INT 60
3855: PUSH
3856: EMPTY
3857: LIST
3858: LIST
3859: LIST
3860: PPUSH
3861: LD_INT 6
3863: PUSH
3864: LD_INT 6
3866: PUSH
3867: LD_INT 6
3869: PUSH
3870: LD_INT 6
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: LIST
3877: LIST
3878: PPUSH
3879: CALL 19970 0 6
3883: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ) ;
3884: LD_ADDR_EXP 23
3888: PUSH
3889: LD_EXP 23
3893: PPUSH
3894: LD_INT 2
3896: PPUSH
3897: LD_VAR 0 4
3901: PUSH
3902: LD_INT 22
3904: PUSH
3905: LD_INT 2
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: LD_INT 21
3914: PUSH
3915: LD_INT 3
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: PPUSH
3926: CALL_OW 69
3930: UNION
3931: PPUSH
3932: CALL_OW 1
3936: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
3937: LD_ADDR_VAR 0 4
3941: PUSH
3942: LD_INT 22
3944: PUSH
3945: LD_INT 2
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PUSH
3952: LD_INT 30
3954: PUSH
3955: LD_INT 31
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: PUSH
3962: EMPTY
3963: LIST
3964: LIST
3965: PPUSH
3966: CALL_OW 69
3970: ST_TO_ADDR
// for i in tmp do
3971: LD_ADDR_VAR 0 2
3975: PUSH
3976: LD_VAR 0 4
3980: PUSH
3981: FOR_IN
3982: IFFALSE 4052
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
3984: LD_INT 0
3986: PPUSH
3987: LD_INT 1
3989: PPUSH
3990: LD_INT 4
3992: PUSH
3993: LD_INT 3
3995: PUSH
3996: LD_INT 3
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: LIST
4003: PUSH
4004: LD_OWVAR 67
4008: ARRAY
4009: PPUSH
4010: CALL_OW 380
// un := CreateHuman ;
4014: LD_ADDR_VAR 0 5
4018: PUSH
4019: CALL_OW 44
4023: ST_TO_ADDR
// SetDir ( un , 1 ) ;
4024: LD_VAR 0 5
4028: PPUSH
4029: LD_INT 1
4031: PPUSH
4032: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
4036: LD_VAR 0 5
4040: PPUSH
4041: LD_VAR 0 2
4045: PPUSH
4046: CALL_OW 52
// end ;
4050: GO 3981
4052: POP
4053: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
4054: LD_ADDR_VAR 0 4
4058: PUSH
4059: LD_INT 15
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: CALL_OW 517
4069: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4070: LD_ADDR_VAR 0 2
4074: PUSH
4075: DOUBLE
4076: LD_INT 1
4078: DEC
4079: ST_TO_ADDR
4080: LD_VAR 0 4
4084: PUSH
4085: LD_INT 1
4087: ARRAY
4088: PUSH
4089: FOR_TO
4090: IFFALSE 4192
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4092: LD_VAR 0 4
4096: PUSH
4097: LD_INT 1
4099: ARRAY
4100: PUSH
4101: LD_VAR 0 2
4105: ARRAY
4106: PPUSH
4107: LD_VAR 0 4
4111: PUSH
4112: LD_INT 2
4114: ARRAY
4115: PUSH
4116: LD_VAR 0 2
4120: ARRAY
4121: PPUSH
4122: LD_INT 2
4124: PPUSH
4125: LD_INT 0
4127: PPUSH
4128: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4132: LD_ADDR_EXP 3
4136: PUSH
4137: LD_EXP 3
4141: PPUSH
4142: LD_EXP 3
4146: PUSH
4147: LD_INT 1
4149: PLUS
4150: PPUSH
4151: LD_VAR 0 4
4155: PUSH
4156: LD_INT 1
4158: ARRAY
4159: PUSH
4160: LD_VAR 0 2
4164: ARRAY
4165: PUSH
4166: LD_VAR 0 4
4170: PUSH
4171: LD_INT 2
4173: ARRAY
4174: PUSH
4175: LD_VAR 0 2
4179: ARRAY
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: PPUSH
4185: CALL_OW 2
4189: ST_TO_ADDR
// end ;
4190: GO 4089
4192: POP
4193: POP
// if Difficulty > 1 then
4194: LD_OWVAR 67
4198: PUSH
4199: LD_INT 1
4201: GREATER
4202: IFFALSE 4344
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
4204: LD_ADDR_VAR 0 4
4208: PUSH
4209: LD_INT 19
4211: PPUSH
4212: LD_INT 0
4214: PPUSH
4215: CALL_OW 517
4219: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
4220: LD_ADDR_VAR 0 2
4224: PUSH
4225: DOUBLE
4226: LD_INT 1
4228: DEC
4229: ST_TO_ADDR
4230: LD_VAR 0 4
4234: PUSH
4235: LD_INT 1
4237: ARRAY
4238: PUSH
4239: FOR_TO
4240: IFFALSE 4342
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
4242: LD_VAR 0 4
4246: PUSH
4247: LD_INT 1
4249: ARRAY
4250: PUSH
4251: LD_VAR 0 2
4255: ARRAY
4256: PPUSH
4257: LD_VAR 0 4
4261: PUSH
4262: LD_INT 2
4264: ARRAY
4265: PUSH
4266: LD_VAR 0 2
4270: ARRAY
4271: PPUSH
4272: LD_INT 2
4274: PPUSH
4275: LD_INT 0
4277: PPUSH
4278: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
4282: LD_ADDR_EXP 3
4286: PUSH
4287: LD_EXP 3
4291: PPUSH
4292: LD_EXP 3
4296: PUSH
4297: LD_INT 1
4299: PLUS
4300: PPUSH
4301: LD_VAR 0 4
4305: PUSH
4306: LD_INT 1
4308: ARRAY
4309: PUSH
4310: LD_VAR 0 2
4314: ARRAY
4315: PUSH
4316: LD_VAR 0 4
4320: PUSH
4321: LD_INT 2
4323: ARRAY
4324: PUSH
4325: LD_VAR 0 2
4329: ARRAY
4330: PUSH
4331: EMPTY
4332: LIST
4333: LIST
4334: PPUSH
4335: CALL_OW 2
4339: ST_TO_ADDR
// end ;
4340: GO 4239
4342: POP
4343: POP
// end ; gensherAttackGroup := [ ] ;
4344: LD_ADDR_EXP 15
4348: PUSH
4349: EMPTY
4350: ST_TO_ADDR
// end ;
4351: LD_VAR 0 1
4355: RET
// export function InitMC_Gensher ( ) ; begin
4356: LD_INT 0
4358: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
4359: LD_INT 2
4361: PPUSH
4362: LD_INT 2
4364: PPUSH
4365: CALL 80500 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
4369: LD_INT 2
4371: PPUSH
4372: LD_INT 9
4374: PPUSH
4375: CALL 80440 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
4379: LD_INT 2
4381: PPUSH
4382: LD_INT 56
4384: PUSH
4385: LD_INT 23
4387: PUSH
4388: LD_INT 0
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: PUSH
4396: LD_INT 52
4398: PUSH
4399: LD_INT 40
4401: PUSH
4402: LD_INT 1
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: LIST
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: PPUSH
4414: CALL 79471 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
4418: LD_INT 2
4420: PPUSH
4421: LD_INT 27
4423: PUSH
4424: LD_INT 28
4426: PUSH
4427: EMPTY
4428: LIST
4429: LIST
4430: PPUSH
4431: CALL 80320 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
4435: LD_INT 2
4437: PPUSH
4438: LD_INT 8
4440: PPUSH
4441: CALL 79990 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
4445: LD_INT 2
4447: PPUSH
4448: LD_INT 7
4450: PPUSH
4451: CALL 79713 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
4455: LD_INT 2
4457: PPUSH
4458: LD_INT 4
4460: PPUSH
4461: CALL 79332 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
4465: LD_INT 2
4467: PPUSH
4468: LD_INT 13
4470: PUSH
4471: LD_INT 2
4473: PUSH
4474: LD_INT 1
4476: PUSH
4477: LD_INT 31
4479: PUSH
4480: EMPTY
4481: LIST
4482: LIST
4483: LIST
4484: LIST
4485: PUSH
4486: LD_INT 13
4488: PUSH
4489: LD_INT 2
4491: PUSH
4492: LD_INT 1
4494: PUSH
4495: LD_INT 31
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: LIST
4502: LIST
4503: PUSH
4504: LD_INT 14
4506: PUSH
4507: LD_INT 1
4509: PUSH
4510: LD_INT 2
4512: PUSH
4513: LD_INT 27
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: LIST
4520: LIST
4521: PUSH
4522: LD_INT 14
4524: PUSH
4525: LD_INT 1
4527: PUSH
4528: LD_INT 2
4530: PUSH
4531: LD_INT 27
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: PUSH
4540: LD_INT 14
4542: PUSH
4543: LD_INT 1
4545: PUSH
4546: LD_INT 2
4548: PUSH
4549: LD_INT 28
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: LIST
4556: LIST
4557: PUSH
4558: LD_INT 14
4560: PUSH
4561: LD_INT 1
4563: PUSH
4564: LD_INT 2
4566: PUSH
4567: LD_INT 26
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: LIST
4574: LIST
4575: PUSH
4576: EMPTY
4577: LIST
4578: LIST
4579: LIST
4580: LIST
4581: LIST
4582: LIST
4583: PPUSH
4584: CALL 79147 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
4588: LD_INT 2
4590: PPUSH
4591: LD_INT 11
4593: PPUSH
4594: LD_INT 7
4596: PPUSH
4597: LD_INT 2
4599: PPUSH
4600: LD_INT 23
4602: PUSH
4603: LD_INT 16
4605: PUSH
4606: LD_INT 17
4608: PUSH
4609: LD_INT 18
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: LIST
4619: LIST
4620: LIST
4621: PPUSH
4622: CALL 80110 0 5
// end ;
4626: LD_VAR 0 1
4630: RET
// every 2 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
4631: LD_EXP 3
4635: IFFALSE 4656
4637: PUSH
4638: LD_INT 15
4640: PPUSH
4641: LD_INT 81
4643: PUSH
4644: LD_INT 2
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: PPUSH
4651: CALL_OW 70
4655: AND
4656: IFFALSE 4871
4658: GO 4660
4660: DISABLE
4661: LD_INT 0
4663: PPUSH
4664: PPUSH
4665: PPUSH
4666: PPUSH
4667: PPUSH
// begin enable ;
4668: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
4669: LD_ADDR_VAR 0 3
4673: PUSH
4674: LD_INT 15
4676: PPUSH
4677: LD_INT 81
4679: PUSH
4680: LD_INT 2
4682: PUSH
4683: EMPTY
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 70
4691: ST_TO_ADDR
// if not tmp then
4692: LD_VAR 0 3
4696: NOT
4697: IFFALSE 4701
// exit ;
4699: GO 4871
// for i in tmp do
4701: LD_ADDR_VAR 0 1
4705: PUSH
4706: LD_VAR 0 3
4710: PUSH
4711: FOR_IN
4712: IFFALSE 4869
// begin x := GetX ( i ) ;
4714: LD_ADDR_VAR 0 4
4718: PUSH
4719: LD_VAR 0 1
4723: PPUSH
4724: CALL_OW 250
4728: ST_TO_ADDR
// y := GetY ( i ) ;
4729: LD_ADDR_VAR 0 5
4733: PUSH
4734: LD_VAR 0 1
4738: PPUSH
4739: CALL_OW 251
4743: ST_TO_ADDR
// if MineAtPos ( x , y ) then
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 458
4758: IFFALSE 4867
// begin LaunchMineAtPos ( x , y , 2 ) ;
4760: LD_VAR 0 4
4764: PPUSH
4765: LD_VAR 0 5
4769: PPUSH
4770: LD_INT 2
4772: PPUSH
4773: CALL_OW 456
// for j = 1 to staticMines do
4777: LD_ADDR_VAR 0 2
4781: PUSH
4782: DOUBLE
4783: LD_INT 1
4785: DEC
4786: ST_TO_ADDR
4787: LD_EXP 3
4791: PUSH
4792: FOR_TO
4793: IFFALSE 4865
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
4795: LD_EXP 3
4799: PUSH
4800: LD_VAR 0 2
4804: ARRAY
4805: PUSH
4806: LD_INT 1
4808: ARRAY
4809: PUSH
4810: LD_VAR 0 4
4814: EQUAL
4815: IFFALSE 4839
4817: PUSH
4818: LD_EXP 3
4822: PUSH
4823: LD_VAR 0 2
4827: ARRAY
4828: PUSH
4829: LD_INT 2
4831: ARRAY
4832: PUSH
4833: LD_VAR 0 5
4837: EQUAL
4838: AND
4839: IFFALSE 4863
// begin staticMines := Delete ( staticMines , j ) ;
4841: LD_ADDR_EXP 3
4845: PUSH
4846: LD_EXP 3
4850: PPUSH
4851: LD_VAR 0 2
4855: PPUSH
4856: CALL_OW 3
4860: ST_TO_ADDR
// break ;
4861: GO 4865
// end ;
4863: GO 4792
4865: POP
4866: POP
// end ; end ;
4867: GO 4711
4869: POP
4870: POP
// end ;
4871: PPOPN 5
4873: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
4874: LD_INT 7
4876: PPUSH
4877: CALL_OW 302
4881: IFFALSE 4890
4883: PUSH
4884: LD_EXP 4
4888: NOT
4889: AND
4890: IFFALSE 5490
4892: GO 4894
4894: DISABLE
4895: LD_INT 0
4897: PPUSH
4898: PPUSH
4899: PPUSH
4900: PPUSH
4901: PPUSH
// begin enable ;
4902: ENABLE
// base := 2 ;
4903: LD_ADDR_VAR 0 2
4907: PUSH
4908: LD_INT 2
4910: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
4911: LD_ADDR_VAR 0 3
4915: PUSH
4916: LD_INT 14
4918: PUSH
4919: LD_INT 1
4921: PUSH
4922: LD_INT 2
4924: PUSH
4925: LD_INT 27
4927: PUSH
4928: EMPTY
4929: LIST
4930: LIST
4931: LIST
4932: LIST
4933: PUSH
4934: LD_INT 14
4936: PUSH
4937: LD_INT 1
4939: PUSH
4940: LD_INT 2
4942: PUSH
4943: LD_INT 27
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: LIST
4950: LIST
4951: PUSH
4952: LD_INT 14
4954: PUSH
4955: LD_INT 1
4957: PUSH
4958: LD_INT 2
4960: PUSH
4961: LD_INT 28
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: LIST
4969: PUSH
4970: LD_INT 14
4972: PUSH
4973: LD_INT 1
4975: PUSH
4976: LD_INT 2
4978: PUSH
4979: LD_INT 26
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: LIST
4992: LIST
4993: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
4994: LD_ADDR_VAR 0 5
4998: PUSH
4999: LD_VAR 0 5
5003: PUSH
5004: LD_OWVAR 1
5008: PUSH
5009: LD_INT 21000
5011: DIV
5012: PLUS
5013: ST_TO_ADDR
// if amount > 8 then
5014: LD_VAR 0 5
5018: PUSH
5019: LD_INT 8
5021: GREATER
5022: IFFALSE 5032
// amount := 8 ;
5024: LD_ADDR_VAR 0 5
5028: PUSH
5029: LD_INT 8
5031: ST_TO_ADDR
// for i = 1 to amount do
5032: LD_ADDR_VAR 0 1
5036: PUSH
5037: DOUBLE
5038: LD_INT 1
5040: DEC
5041: ST_TO_ADDR
5042: LD_VAR 0 5
5046: PUSH
5047: FOR_TO
5048: IFFALSE 5136
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
5050: LD_ADDR_VAR 0 3
5054: PUSH
5055: LD_VAR 0 3
5059: PPUSH
5060: LD_VAR 0 3
5064: PUSH
5065: LD_INT 1
5067: PLUS
5068: PPUSH
5069: LD_INT 14
5071: PUSH
5072: LD_INT 13
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: LD_INT 1
5081: PPUSH
5082: LD_INT 2
5084: PPUSH
5085: CALL_OW 12
5089: ARRAY
5090: PUSH
5091: LD_INT 1
5093: PUSH
5094: LD_INT 2
5096: PUSH
5097: LD_INT 28
5099: PUSH
5100: LD_INT 25
5102: PUSH
5103: LD_INT 27
5105: PUSH
5106: EMPTY
5107: LIST
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 1
5113: PPUSH
5114: LD_INT 3
5116: PPUSH
5117: CALL_OW 12
5121: ARRAY
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: LIST
5127: LIST
5128: PPUSH
5129: CALL_OW 2
5133: ST_TO_ADDR
5134: GO 5047
5136: POP
5137: POP
// MC_InsertProduceList ( base , tmp ) ;
5138: LD_VAR 0 2
5142: PPUSH
5143: LD_VAR 0 3
5147: PPUSH
5148: CALL 79195 0 2
// repeat wait ( 0 0$1 ) ;
5152: LD_INT 35
5154: PPUSH
5155: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
5159: LD_VAR 0 2
5163: PPUSH
5164: LD_INT 1
5166: PPUSH
5167: CALL 80651 0 2
5171: PUSH
5172: LD_VAR 0 5
5176: GREATEREQUAL
5177: IFFALSE 5152
// wait ( 0 0$30 ) ;
5179: LD_INT 1050
5181: PPUSH
5182: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5186: LD_ADDR_VAR 0 4
5190: PUSH
5191: LD_EXP 42
5195: PUSH
5196: LD_VAR 0 2
5200: ARRAY
5201: PUSH
5202: LD_EXP 42
5206: PUSH
5207: LD_VAR 0 2
5211: ARRAY
5212: PPUSH
5213: LD_INT 2
5215: PUSH
5216: LD_INT 34
5218: PUSH
5219: LD_INT 31
5221: PUSH
5222: EMPTY
5223: LIST
5224: LIST
5225: PUSH
5226: LD_INT 34
5228: PUSH
5229: LD_INT 32
5231: PUSH
5232: EMPTY
5233: LIST
5234: LIST
5235: PUSH
5236: LD_INT 34
5238: PUSH
5239: LD_INT 88
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: LIST
5250: LIST
5251: PPUSH
5252: CALL_OW 72
5256: DIFF
5257: ST_TO_ADDR
// if not attackers then
5258: LD_VAR 0 4
5262: NOT
5263: IFFALSE 5267
// exit ;
5265: GO 5490
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
5267: LD_ADDR_EXP 42
5271: PUSH
5272: LD_EXP 42
5276: PPUSH
5277: LD_VAR 0 2
5281: PPUSH
5282: LD_EXP 42
5286: PUSH
5287: LD_VAR 0 2
5291: ARRAY
5292: PUSH
5293: LD_VAR 0 4
5297: DIFF
5298: PPUSH
5299: CALL_OW 1
5303: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
5304: LD_VAR 0 4
5308: PPUSH
5309: LD_INT 107
5311: PPUSH
5312: LD_INT 74
5314: PPUSH
5315: CALL_OW 114
// wait ( 0 0$5 ) ;
5319: LD_INT 175
5321: PPUSH
5322: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5326: LD_INT 35
5328: PPUSH
5329: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5333: LD_VAR 0 4
5337: PPUSH
5338: LD_INT 60
5340: PUSH
5341: EMPTY
5342: LIST
5343: PPUSH
5344: CALL_OW 72
5348: NOT
5349: IFFALSE 5326
// if rand ( 0 , 1 ) then
5351: LD_INT 0
5353: PPUSH
5354: LD_INT 1
5356: PPUSH
5357: CALL_OW 12
5361: IFFALSE 5380
// ComAgressiveMove ( attackers , 155 , 108 ) else
5363: LD_VAR 0 4
5367: PPUSH
5368: LD_INT 155
5370: PPUSH
5371: LD_INT 108
5373: PPUSH
5374: CALL_OW 114
5378: GO 5395
// ComAgressiveMove ( attackers , 149 , 55 ) ;
5380: LD_VAR 0 4
5384: PPUSH
5385: LD_INT 149
5387: PPUSH
5388: LD_INT 55
5390: PPUSH
5391: CALL_OW 114
// wait ( 0 0$10 ) ;
5395: LD_INT 350
5397: PPUSH
5398: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
5402: LD_INT 35
5404: PPUSH
5405: CALL_OW 67
// for i in attackers do
5409: LD_ADDR_VAR 0 1
5413: PUSH
5414: LD_VAR 0 4
5418: PUSH
5419: FOR_IN
5420: IFFALSE 5470
// if not HasTask ( i ) then
5422: LD_VAR 0 1
5426: PPUSH
5427: CALL_OW 314
5431: NOT
5432: IFFALSE 5468
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
5434: LD_VAR 0 1
5438: PPUSH
5439: LD_INT 81
5441: PUSH
5442: LD_INT 2
5444: PUSH
5445: EMPTY
5446: LIST
5447: LIST
5448: PPUSH
5449: CALL_OW 69
5453: PPUSH
5454: LD_VAR 0 1
5458: PPUSH
5459: CALL_OW 74
5463: PPUSH
5464: CALL_OW 115
5468: GO 5419
5470: POP
5471: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
5472: LD_VAR 0 4
5476: PPUSH
5477: LD_INT 50
5479: PUSH
5480: EMPTY
5481: LIST
5482: PPUSH
5483: CALL_OW 72
5487: NOT
5488: IFFALSE 5402
// end ;
5490: PPOPN 5
5492: END
// every 8 8$00 + 9 9$00 trigger not arDestroyed and tick < 91 91$00 do var i , un , tmp ;
5493: LD_EXP 4
5497: NOT
5498: IFFALSE 5510
5500: PUSH
5501: LD_OWVAR 1
5505: PUSH
5506: LD_INT 191100
5508: LESS
5509: AND
5510: IFFALSE 6182
5512: GO 5514
5514: DISABLE
5515: LD_INT 0
5517: PPUSH
5518: PPUSH
5519: PPUSH
// begin enable ;
5520: ENABLE
// tmp := [ ] ;
5521: LD_ADDR_VAR 0 3
5525: PUSH
5526: EMPTY
5527: ST_TO_ADDR
// if tick < 35 35$00 then
5528: LD_OWVAR 1
5532: PUSH
5533: LD_INT 73500
5535: LESS
5536: IFFALSE 5734
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5538: LD_ADDR_VAR 0 1
5542: PUSH
5543: DOUBLE
5544: LD_INT 1
5546: DEC
5547: ST_TO_ADDR
5548: LD_INT 4
5550: PUSH
5551: LD_INT 5
5553: PUSH
5554: LD_INT 5
5556: PUSH
5557: EMPTY
5558: LIST
5559: LIST
5560: LIST
5561: PUSH
5562: LD_OWVAR 67
5566: ARRAY
5567: PUSH
5568: FOR_TO
5569: IFFALSE 5730
// begin uc_side := 2 ;
5571: LD_ADDR_OWVAR 20
5575: PUSH
5576: LD_INT 2
5578: ST_TO_ADDR
// uc_nation := 2 ;
5579: LD_ADDR_OWVAR 21
5583: PUSH
5584: LD_INT 2
5586: ST_TO_ADDR
// InitHC_All ( ) ;
5587: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
5591: LD_INT 0
5593: PPUSH
5594: LD_INT 1
5596: PPUSH
5597: LD_INT 5
5599: PUSH
5600: LD_INT 6
5602: PUSH
5603: LD_INT 7
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: PUSH
5611: LD_OWVAR 67
5615: ARRAY
5616: PPUSH
5617: CALL_OW 380
// un := CreateHuman ;
5621: LD_ADDR_VAR 0 2
5625: PUSH
5626: CALL_OW 44
5630: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5631: LD_VAR 0 2
5635: PPUSH
5636: LD_INT 17
5638: PPUSH
5639: LD_INT 0
5641: PPUSH
5642: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
5646: LD_VAR 0 2
5650: PPUSH
5651: LD_INT 1
5653: PUSH
5654: LD_INT 8
5656: PUSH
5657: EMPTY
5658: LIST
5659: LIST
5660: PUSH
5661: LD_INT 1
5663: PPUSH
5664: LD_INT 2
5666: PPUSH
5667: CALL_OW 12
5671: ARRAY
5672: PPUSH
5673: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
5677: LD_VAR 0 2
5681: PPUSH
5682: LD_INT 111
5684: PPUSH
5685: LD_INT 34
5687: PPUSH
5688: CALL_OW 114
// wait ( 0 0$2 ) ;
5692: LD_INT 70
5694: PPUSH
5695: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5699: LD_ADDR_VAR 0 3
5703: PUSH
5704: LD_VAR 0 3
5708: PPUSH
5709: LD_VAR 0 3
5713: PUSH
5714: LD_INT 1
5716: PLUS
5717: PPUSH
5718: LD_VAR 0 2
5722: PPUSH
5723: CALL_OW 1
5727: ST_TO_ADDR
// end ;
5728: GO 5568
5730: POP
5731: POP
// end else
5732: GO 5875
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
5734: LD_ADDR_VAR 0 1
5738: PUSH
5739: DOUBLE
5740: LD_INT 1
5742: DEC
5743: ST_TO_ADDR
5744: LD_INT 4
5746: PUSH
5747: LD_INT 5
5749: PUSH
5750: LD_INT 5
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: PUSH
5758: LD_OWVAR 67
5762: ARRAY
5763: PUSH
5764: FOR_TO
5765: IFFALSE 5873
// begin uc_side := 2 ;
5767: LD_ADDR_OWVAR 20
5771: PUSH
5772: LD_INT 2
5774: ST_TO_ADDR
// uc_nation := 0 ;
5775: LD_ADDR_OWVAR 21
5779: PUSH
5780: LD_INT 0
5782: ST_TO_ADDR
// InitHC_All ( ) ;
5783: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
5787: LD_ADDR_OWVAR 28
5791: PUSH
5792: LD_INT 17
5794: ST_TO_ADDR
// un := CreateHuman ;
5795: LD_ADDR_VAR 0 2
5799: PUSH
5800: CALL_OW 44
5804: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5805: LD_VAR 0 2
5809: PPUSH
5810: LD_INT 17
5812: PPUSH
5813: LD_INT 0
5815: PPUSH
5816: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
5820: LD_VAR 0 2
5824: PPUSH
5825: LD_INT 110
5827: PPUSH
5828: LD_INT 33
5830: PPUSH
5831: CALL_OW 114
// wait ( 0 0$2 ) ;
5835: LD_INT 70
5837: PPUSH
5838: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
5842: LD_ADDR_VAR 0 3
5846: PUSH
5847: LD_VAR 0 3
5851: PPUSH
5852: LD_VAR 0 3
5856: PUSH
5857: LD_INT 1
5859: PLUS
5860: PPUSH
5861: LD_VAR 0 2
5865: PPUSH
5866: CALL_OW 1
5870: ST_TO_ADDR
// end ;
5871: GO 5764
5873: POP
5874: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_INT 3
5887: PUSH
5888: LD_INT 4
5890: PUSH
5891: LD_INT 5
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_OWVAR 67
5903: ARRAY
5904: PUSH
5905: FOR_TO
5906: IFFALSE 6071
// begin uc_side := 2 ;
5908: LD_ADDR_OWVAR 20
5912: PUSH
5913: LD_INT 2
5915: ST_TO_ADDR
// uc_nation := 2 ;
5916: LD_ADDR_OWVAR 21
5920: PUSH
5921: LD_INT 2
5923: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
5924: LD_INT 14
5926: PPUSH
5927: LD_INT 3
5929: PPUSH
5930: LD_INT 5
5932: PPUSH
5933: LD_INT 29
5935: PUSH
5936: LD_INT 28
5938: PUSH
5939: LD_INT 27
5941: PUSH
5942: EMPTY
5943: LIST
5944: LIST
5945: LIST
5946: PUSH
5947: LD_INT 1
5949: PPUSH
5950: LD_INT 3
5952: PPUSH
5953: CALL_OW 12
5957: ARRAY
5958: PPUSH
5959: LD_INT 90
5961: PPUSH
5962: CALL 16133 0 5
// un := CreateVehicle ;
5966: LD_ADDR_VAR 0 2
5970: PUSH
5971: CALL_OW 45
5975: ST_TO_ADDR
// SetDir ( un , 2 ) ;
5976: LD_VAR 0 2
5980: PPUSH
5981: LD_INT 2
5983: PPUSH
5984: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
5988: LD_VAR 0 2
5992: PPUSH
5993: LD_INT 17
5995: PPUSH
5996: LD_INT 0
5998: PPUSH
5999: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
6003: LD_VAR 0 2
6007: PPUSH
6008: LD_INT 66
6010: PPUSH
6011: LD_INT 23
6013: PPUSH
6014: CALL_OW 111
// wait ( 0 0$3 ) ;
6018: LD_INT 105
6020: PPUSH
6021: CALL_OW 67
// AddComAgressiveMove ( un , 147 , 103 ) ;
6025: LD_VAR 0 2
6029: PPUSH
6030: LD_INT 147
6032: PPUSH
6033: LD_INT 103
6035: PPUSH
6036: CALL_OW 174
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6040: LD_ADDR_VAR 0 3
6044: PUSH
6045: LD_VAR 0 3
6049: PPUSH
6050: LD_VAR 0 3
6054: PUSH
6055: LD_INT 1
6057: PLUS
6058: PPUSH
6059: LD_VAR 0 2
6063: PPUSH
6064: CALL_OW 1
6068: ST_TO_ADDR
// end ;
6069: GO 5905
6071: POP
6072: POP
// if not tmp then
6073: LD_VAR 0 3
6077: NOT
6078: IFFALSE 6082
// exit ;
6080: GO 6182
// wait ( 0 0$5 ) ;
6082: LD_INT 175
6084: PPUSH
6085: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
6089: LD_INT 70
6091: PPUSH
6092: CALL_OW 67
// for i in tmp do
6096: LD_ADDR_VAR 0 1
6100: PUSH
6101: LD_VAR 0 3
6105: PUSH
6106: FOR_IN
6107: IFFALSE 6173
// begin if not IsOk ( i ) then
6109: LD_VAR 0 1
6113: PPUSH
6114: CALL_OW 302
6118: NOT
6119: IFFALSE 6137
// tmp := tmp diff i ;
6121: LD_ADDR_VAR 0 3
6125: PUSH
6126: LD_VAR 0 3
6130: PUSH
6131: LD_VAR 0 1
6135: DIFF
6136: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
6137: LD_VAR 0 1
6141: PPUSH
6142: LD_INT 81
6144: PUSH
6145: LD_INT 2
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: PPUSH
6157: LD_VAR 0 1
6161: PPUSH
6162: CALL_OW 74
6166: PPUSH
6167: CALL_OW 115
// end ;
6171: GO 6106
6173: POP
6174: POP
// until not tmp ;
6175: LD_VAR 0 3
6179: NOT
6180: IFFALSE 6089
// end ;
6182: PPOPN 3
6184: END
// every 9 9$00 trigger Difficulty > 1 do var un ;
6185: LD_OWVAR 67
6189: PUSH
6190: LD_INT 1
6192: GREATER
6193: IFFALSE 6291
6195: GO 6197
6197: DISABLE
6198: LD_INT 0
6200: PPUSH
// begin uc_side := 2 ;
6201: LD_ADDR_OWVAR 20
6205: PUSH
6206: LD_INT 2
6208: ST_TO_ADDR
// uc_nation := 2 ;
6209: LD_ADDR_OWVAR 21
6213: PUSH
6214: LD_INT 2
6216: ST_TO_ADDR
// PrepareHuman ( false , 4 , 6 ) ;
6217: LD_INT 0
6219: PPUSH
6220: LD_INT 4
6222: PPUSH
6223: LD_INT 6
6225: PPUSH
6226: CALL_OW 380
// un := CreateHuman ;
6230: LD_ADDR_VAR 0 1
6234: PUSH
6235: CALL_OW 44
6239: ST_TO_ADDR
// PlaceUnitXYD ( un , 88 , 1 , 2 , false ) ;
6240: LD_VAR 0 1
6244: PPUSH
6245: LD_INT 88
6247: PPUSH
6248: LD_INT 1
6250: PPUSH
6251: LD_INT 2
6253: PPUSH
6254: LD_INT 0
6256: PPUSH
6257: CALL 51463 0 5
// ComMoveXY ( un , 130 , 35 ) ;
6261: LD_VAR 0 1
6265: PPUSH
6266: LD_INT 130
6268: PPUSH
6269: LD_INT 35
6271: PPUSH
6272: CALL_OW 111
// AddComContaminate ( un , 132 , 39 ) ;
6276: LD_VAR 0 1
6280: PPUSH
6281: LD_INT 132
6283: PPUSH
6284: LD_INT 39
6286: PPUSH
6287: CALL_OW 218
// end ;
6291: PPOPN 1
6293: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) do var i , tmp ;
6294: LD_INT 22
6296: PUSH
6297: LD_INT 2
6299: PUSH
6300: EMPTY
6301: LIST
6302: LIST
6303: PUSH
6304: LD_INT 33
6306: PUSH
6307: LD_INT 2
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 50
6316: PUSH
6317: EMPTY
6318: LIST
6319: PUSH
6320: LD_INT 3
6322: PUSH
6323: LD_INT 61
6325: PUSH
6326: EMPTY
6327: LIST
6328: PUSH
6329: EMPTY
6330: LIST
6331: LIST
6332: PUSH
6333: EMPTY
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: PPUSH
6339: CALL_OW 69
6343: IFFALSE 6434
6345: GO 6347
6347: DISABLE
6348: LD_INT 0
6350: PPUSH
6351: PPUSH
// begin enable ;
6352: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] , [ f_ok ] , [ f_not , [ f_linked ] ] ] ) ;
6353: LD_ADDR_VAR 0 2
6357: PUSH
6358: LD_INT 22
6360: PUSH
6361: LD_INT 2
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: PUSH
6368: LD_INT 33
6370: PUSH
6371: LD_INT 2
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 50
6380: PUSH
6381: EMPTY
6382: LIST
6383: PUSH
6384: LD_INT 3
6386: PUSH
6387: LD_INT 61
6389: PUSH
6390: EMPTY
6391: LIST
6392: PUSH
6393: EMPTY
6394: LIST
6395: LIST
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PPUSH
6403: CALL_OW 69
6407: ST_TO_ADDR
// for i in tmp do
6408: LD_ADDR_VAR 0 1
6412: PUSH
6413: LD_VAR 0 2
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6432
// Connect ( i ) ;
6421: LD_VAR 0 1
6425: PPUSH
6426: CALL 19615 0 1
6430: GO 6418
6432: POP
6433: POP
// end ; end_of_file
6434: PPOPN 2
6436: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp , b , list ; begin
6437: LD_INT 0
6439: PPUSH
6440: PPUSH
6441: PPUSH
6442: PPUSH
6443: PPUSH
6444: PPUSH
// popov_side := 3 ;
6445: LD_ADDR_EXP 17
6449: PUSH
6450: LD_INT 3
6452: ST_TO_ADDR
// uc_side := popov_side ;
6453: LD_ADDR_OWVAR 20
6457: PUSH
6458: LD_EXP 17
6462: ST_TO_ADDR
// uc_nation := 3 ;
6463: LD_ADDR_OWVAR 21
6467: PUSH
6468: LD_INT 3
6470: ST_TO_ADDR
// list := [ [ b_barracks , 103 , 147 , 3 ] , [ b_barracks , 70 , 117 , 3 ] , [ b_lab , 76 , 145 , 1 , b_lab_weapon , b_lab_siberium ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_siberite_mine , 123 , 151 , 1 ] , [ b_factory , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 , b_lab_computer , b_lab_spacetime ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 , ru_heavy_gun ] , [ b_bunker , 112 , 148 , 3 , ru_heavy_gun ] , [ b_turret , 120 , 159 , 4 , ru_rocket_launcher ] , [ b_turret , 122 , 163 , 4 , ru_rocket_launcher ] , [ b_turret , 123 , 167 , 4 , ru_rocket_launcher ] , [ b_turret , 59 , 111 , 3 , ru_rocket_launcher ] , [ b_turret , 65 , 111 , 3 , ru_heavy_gun ] , [ b_turret , 76 , 117 , 3 , ru_rocket_launcher ] , [ b_turret , 80 , 119 , 3 , ru_heavy_gun ] , [ b_turret , 87 , 125 , 3 , ru_rocket_launcher ] , [ b_barracks , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ;
6471: LD_ADDR_VAR 0 6
6475: PUSH
6476: LD_INT 5
6478: PUSH
6479: LD_INT 103
6481: PUSH
6482: LD_INT 147
6484: PUSH
6485: LD_INT 3
6487: PUSH
6488: EMPTY
6489: LIST
6490: LIST
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 5
6496: PUSH
6497: LD_INT 70
6499: PUSH
6500: LD_INT 117
6502: PUSH
6503: LD_INT 3
6505: PUSH
6506: EMPTY
6507: LIST
6508: LIST
6509: LIST
6510: LIST
6511: PUSH
6512: LD_INT 6
6514: PUSH
6515: LD_INT 76
6517: PUSH
6518: LD_INT 145
6520: PUSH
6521: LD_INT 1
6523: PUSH
6524: LD_INT 10
6526: PUSH
6527: LD_INT 11
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: LIST
6534: LIST
6535: LIST
6536: LIST
6537: PUSH
6538: LD_INT 26
6540: PUSH
6541: LD_INT 87
6543: PUSH
6544: LD_INT 144
6546: PUSH
6547: LD_INT 0
6549: PUSH
6550: EMPTY
6551: LIST
6552: LIST
6553: LIST
6554: LIST
6555: PUSH
6556: LD_INT 29
6558: PUSH
6559: LD_INT 86
6561: PUSH
6562: LD_INT 118
6564: PUSH
6565: LD_INT 0
6567: PUSH
6568: EMPTY
6569: LIST
6570: LIST
6571: LIST
6572: LIST
6573: PUSH
6574: LD_INT 29
6576: PUSH
6577: LD_INT 98
6579: PUSH
6580: LD_INT 121
6582: PUSH
6583: LD_INT 0
6585: PUSH
6586: EMPTY
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PUSH
6592: LD_INT 26
6594: PUSH
6595: LD_INT 87
6597: PUSH
6598: LD_INT 147
6600: PUSH
6601: LD_INT 1
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: LIST
6609: PUSH
6610: LD_INT 30
6612: PUSH
6613: LD_INT 123
6615: PUSH
6616: LD_INT 151
6618: PUSH
6619: LD_INT 1
6621: PUSH
6622: EMPTY
6623: LIST
6624: LIST
6625: LIST
6626: LIST
6627: PUSH
6628: LD_INT 3
6630: PUSH
6631: LD_INT 94
6633: PUSH
6634: LD_INT 161
6636: PUSH
6637: LD_INT 0
6639: PUSH
6640: EMPTY
6641: LIST
6642: LIST
6643: LIST
6644: LIST
6645: PUSH
6646: LD_INT 6
6648: PUSH
6649: LD_INT 81
6651: PUSH
6652: LD_INT 155
6654: PUSH
6655: LD_INT 1
6657: PUSH
6658: LD_INT 12
6660: PUSH
6661: LD_INT 14
6663: PUSH
6664: EMPTY
6665: LIST
6666: LIST
6667: LIST
6668: LIST
6669: LIST
6670: LIST
6671: PUSH
6672: LD_INT 26
6674: PUSH
6675: LD_INT 96
6677: PUSH
6678: LD_INT 152
6680: PUSH
6681: LD_INT 0
6683: PUSH
6684: EMPTY
6685: LIST
6686: LIST
6687: LIST
6688: LIST
6689: PUSH
6690: LD_INT 26
6692: PUSH
6693: LD_INT 96
6695: PUSH
6696: LD_INT 149
6698: PUSH
6699: LD_INT 3
6701: PUSH
6702: EMPTY
6703: LIST
6704: LIST
6705: LIST
6706: LIST
6707: PUSH
6708: LD_INT 32
6710: PUSH
6711: LD_INT 109
6713: PUSH
6714: LD_INT 142
6716: PUSH
6717: LD_INT 3
6719: PUSH
6720: LD_INT 46
6722: PUSH
6723: EMPTY
6724: LIST
6725: LIST
6726: LIST
6727: LIST
6728: LIST
6729: PUSH
6730: LD_INT 32
6732: PUSH
6733: LD_INT 112
6735: PUSH
6736: LD_INT 148
6738: PUSH
6739: LD_INT 3
6741: PUSH
6742: LD_INT 46
6744: PUSH
6745: EMPTY
6746: LIST
6747: LIST
6748: LIST
6749: LIST
6750: LIST
6751: PUSH
6752: LD_INT 33
6754: PUSH
6755: LD_INT 120
6757: PUSH
6758: LD_INT 159
6760: PUSH
6761: LD_INT 4
6763: PUSH
6764: LD_INT 45
6766: PUSH
6767: EMPTY
6768: LIST
6769: LIST
6770: LIST
6771: LIST
6772: LIST
6773: PUSH
6774: LD_INT 33
6776: PUSH
6777: LD_INT 122
6779: PUSH
6780: LD_INT 163
6782: PUSH
6783: LD_INT 4
6785: PUSH
6786: LD_INT 45
6788: PUSH
6789: EMPTY
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: PUSH
6796: LD_INT 33
6798: PUSH
6799: LD_INT 123
6801: PUSH
6802: LD_INT 167
6804: PUSH
6805: LD_INT 4
6807: PUSH
6808: LD_INT 45
6810: PUSH
6811: EMPTY
6812: LIST
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 33
6820: PUSH
6821: LD_INT 59
6823: PUSH
6824: LD_INT 111
6826: PUSH
6827: LD_INT 3
6829: PUSH
6830: LD_INT 45
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: PUSH
6840: LD_INT 33
6842: PUSH
6843: LD_INT 65
6845: PUSH
6846: LD_INT 111
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: LD_INT 46
6854: PUSH
6855: EMPTY
6856: LIST
6857: LIST
6858: LIST
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 33
6864: PUSH
6865: LD_INT 76
6867: PUSH
6868: LD_INT 117
6870: PUSH
6871: LD_INT 3
6873: PUSH
6874: LD_INT 45
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: LIST
6883: PUSH
6884: LD_INT 33
6886: PUSH
6887: LD_INT 80
6889: PUSH
6890: LD_INT 119
6892: PUSH
6893: LD_INT 3
6895: PUSH
6896: LD_INT 46
6898: PUSH
6899: EMPTY
6900: LIST
6901: LIST
6902: LIST
6903: LIST
6904: LIST
6905: PUSH
6906: LD_INT 33
6908: PUSH
6909: LD_INT 87
6911: PUSH
6912: LD_INT 125
6914: PUSH
6915: LD_INT 3
6917: PUSH
6918: LD_INT 45
6920: PUSH
6921: EMPTY
6922: LIST
6923: LIST
6924: LIST
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 5
6930: PUSH
6931: LD_INT 92
6933: PUSH
6934: LD_INT 129
6936: PUSH
6937: LD_INT 3
6939: PUSH
6940: EMPTY
6941: LIST
6942: LIST
6943: LIST
6944: LIST
6945: PUSH
6946: LD_INT 28
6948: PUSH
6949: LD_INT 85
6951: PUSH
6952: LD_INT 165
6954: PUSH
6955: LD_INT 0
6957: PUSH
6958: EMPTY
6959: LIST
6960: LIST
6961: LIST
6962: LIST
6963: PUSH
6964: LD_INT 28
6966: PUSH
6967: LD_INT 83
6969: PUSH
6970: LD_INT 161
6972: PUSH
6973: LD_INT 4
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: LD_INT 28
6984: PUSH
6985: LD_INT 91
6987: PUSH
6988: LD_INT 166
6990: PUSH
6991: LD_INT 3
6993: PUSH
6994: EMPTY
6995: LIST
6996: LIST
6997: LIST
6998: LIST
6999: PUSH
7000: LD_INT 28
7002: PUSH
7003: LD_INT 102
7005: PUSH
7006: LD_INT 166
7008: PUSH
7009: LD_INT 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: LIST
7016: LIST
7017: PUSH
7018: EMPTY
7019: LIST
7020: LIST
7021: LIST
7022: LIST
7023: LIST
7024: LIST
7025: LIST
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: LIST
7039: LIST
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: ST_TO_ADDR
// for i in list do
7047: LD_ADDR_VAR 0 2
7051: PUSH
7052: LD_VAR 0 6
7056: PUSH
7057: FOR_IN
7058: IFFALSE 7268
// begin uc_side := 3 ;
7060: LD_ADDR_OWVAR 20
7064: PUSH
7065: LD_INT 3
7067: ST_TO_ADDR
// uc_nation := 3 ;
7068: LD_ADDR_OWVAR 21
7072: PUSH
7073: LD_INT 3
7075: ST_TO_ADDR
// InitBc ;
7076: CALL_OW 21
// bc_type := i [ 1 ] ;
7080: LD_ADDR_OWVAR 42
7084: PUSH
7085: LD_VAR 0 2
7089: PUSH
7090: LD_INT 1
7092: ARRAY
7093: ST_TO_ADDR
// if i [ 1 ] in [ b_oil_mine , b_siberite_mine ] then
7094: LD_VAR 0 2
7098: PUSH
7099: LD_INT 1
7101: ARRAY
7102: PUSH
7103: LD_INT 29
7105: PUSH
7106: LD_INT 30
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: IN
7113: IFFALSE 7140
// SetResourceVisibility ( i [ 2 ] , i [ 3 ] , 3 ) ;
7115: LD_VAR 0 2
7119: PUSH
7120: LD_INT 2
7122: ARRAY
7123: PPUSH
7124: LD_VAR 0 2
7128: PUSH
7129: LD_INT 3
7131: ARRAY
7132: PPUSH
7133: LD_INT 3
7135: PPUSH
7136: CALL_OW 441
// if i [ 1 ] = b_lab then
7140: LD_VAR 0 2
7144: PUSH
7145: LD_INT 1
7147: ARRAY
7148: PUSH
7149: LD_INT 6
7151: EQUAL
7152: IFFALSE 7190
// begin bc_type := b_lab_full ;
7154: LD_ADDR_OWVAR 42
7158: PUSH
7159: LD_INT 8
7161: ST_TO_ADDR
// bc_kind1 = i [ 5 ] ;
7162: LD_ADDR_OWVAR 44
7166: PUSH
7167: LD_VAR 0 2
7171: PUSH
7172: LD_INT 5
7174: ARRAY
7175: ST_TO_ADDR
// bc_kind2 = i [ 6 ] ;
7176: LD_ADDR_OWVAR 45
7180: PUSH
7181: LD_VAR 0 2
7185: PUSH
7186: LD_INT 6
7188: ARRAY
7189: ST_TO_ADDR
// end ; b := CreateAndPlaceBuildingXYD ( i [ 2 ] , i [ 3 ] , i [ 4 ] ) ;
7190: LD_ADDR_VAR 0 5
7194: PUSH
7195: LD_VAR 0 2
7199: PUSH
7200: LD_INT 2
7202: ARRAY
7203: PPUSH
7204: LD_VAR 0 2
7208: PUSH
7209: LD_INT 3
7211: ARRAY
7212: PPUSH
7213: LD_VAR 0 2
7217: PUSH
7218: LD_INT 4
7220: ARRAY
7221: PPUSH
7222: CALL_OW 47
7226: ST_TO_ADDR
// if i [ 1 ] in [ b_turret , b_bunker ] then
7227: LD_VAR 0 2
7231: PUSH
7232: LD_INT 1
7234: ARRAY
7235: PUSH
7236: LD_INT 33
7238: PUSH
7239: LD_INT 32
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: IN
7246: IFFALSE 7266
// PlaceWeaponTurret ( b , i [ 5 ] ) ;
7248: LD_VAR 0 5
7252: PPUSH
7253: LD_VAR 0 2
7257: PUSH
7258: LD_INT 5
7260: ARRAY
7261: PPUSH
7262: CALL_OW 431
// end ;
7266: GO 7057
7268: POP
7269: POP
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 11500 , 1100 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
7270: LD_ADDR_VAR 0 4
7274: PUSH
7275: LD_INT 9
7277: PPUSH
7278: LD_INT 3
7280: PPUSH
7281: LD_STRING 
7283: PPUSH
7284: LD_INT 8
7286: PUSH
7287: LD_INT 7
7289: PUSH
7290: LD_INT 6
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: LIST
7297: PUSH
7298: LD_OWVAR 67
7302: ARRAY
7303: PPUSH
7304: LD_INT 11500
7306: PUSH
7307: LD_INT 1100
7309: PUSH
7310: LD_INT 60
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: LIST
7317: PPUSH
7318: LD_INT 6
7320: PUSH
7321: LD_INT 6
7323: PUSH
7324: LD_INT 6
7326: PUSH
7327: LD_INT 6
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: LIST
7334: LIST
7335: PPUSH
7336: CALL 19970 0 6
7340: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp union FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_building ] ] ) ) ;
7341: LD_ADDR_EXP 23
7345: PUSH
7346: LD_EXP 23
7350: PPUSH
7351: LD_INT 3
7353: PPUSH
7354: LD_VAR 0 4
7358: PUSH
7359: LD_INT 22
7361: PUSH
7362: LD_INT 3
7364: PUSH
7365: EMPTY
7366: LIST
7367: LIST
7368: PUSH
7369: LD_INT 21
7371: PUSH
7372: LD_INT 3
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: PUSH
7379: EMPTY
7380: LIST
7381: LIST
7382: PPUSH
7383: CALL_OW 69
7387: UNION
7388: PPUSH
7389: CALL_OW 1
7393: ST_TO_ADDR
// extraPopovForces := [ ] ;
7394: LD_ADDR_EXP 18
7398: PUSH
7399: EMPTY
7400: ST_TO_ADDR
// for i := 1 to [ 8 , 9 , 10 ] [ Difficulty ] do
7401: LD_ADDR_VAR 0 2
7405: PUSH
7406: DOUBLE
7407: LD_INT 1
7409: DEC
7410: ST_TO_ADDR
7411: LD_INT 8
7413: PUSH
7414: LD_INT 9
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: PUSH
7425: LD_OWVAR 67
7429: ARRAY
7430: PUSH
7431: FOR_TO
7432: IFFALSE 7561
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
7434: LD_INT 0
7436: PPUSH
7437: LD_INT 1
7439: PPUSH
7440: LD_INT 4
7442: PUSH
7443: LD_INT 5
7445: PUSH
7446: LD_INT 6
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: LIST
7453: PUSH
7454: LD_OWVAR 67
7458: ARRAY
7459: PPUSH
7460: CALL_OW 380
// un := CreateHuman ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: CALL_OW 44
7473: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7474: LD_INT 0
7476: PPUSH
7477: LD_INT 1
7479: PPUSH
7480: CALL_OW 12
7484: IFFALSE 7509
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) else
7486: LD_VAR 0 3
7490: PPUSH
7491: LD_INT 131
7493: PPUSH
7494: LD_INT 110
7496: PPUSH
7497: LD_INT 8
7499: PPUSH
7500: LD_INT 0
7502: PPUSH
7503: CALL_OW 50
7507: GO 7530
// PlaceUnitXYR ( un , 100 , 99 , 8 , false ) ;
7509: LD_VAR 0 3
7513: PPUSH
7514: LD_INT 100
7516: PPUSH
7517: LD_INT 99
7519: PPUSH
7520: LD_INT 8
7522: PPUSH
7523: LD_INT 0
7525: PPUSH
7526: CALL_OW 50
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
7530: LD_ADDR_EXP 18
7534: PUSH
7535: LD_EXP 18
7539: PPUSH
7540: LD_EXP 18
7544: PUSH
7545: LD_INT 1
7547: PLUS
7548: PPUSH
7549: LD_VAR 0 3
7553: PPUSH
7554: CALL_OW 1
7558: ST_TO_ADDR
// end ;
7559: GO 7431
7561: POP
7562: POP
// PrepareSoldier ( false , 6 ) ;
7563: LD_INT 0
7565: PPUSH
7566: LD_INT 6
7568: PPUSH
7569: CALL_OW 381
// un := CreateHuman ;
7573: LD_ADDR_VAR 0 3
7577: PUSH
7578: CALL_OW 44
7582: ST_TO_ADDR
// SetDir ( un , 1 ) ;
7583: LD_VAR 0 3
7587: PPUSH
7588: LD_INT 1
7590: PPUSH
7591: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
7595: LD_VAR 0 3
7599: PPUSH
7600: LD_INT 150
7602: PPUSH
7603: LD_INT 158
7605: PPUSH
7606: CALL_OW 428
7610: PPUSH
7611: CALL_OW 52
// popovAttackGroup := [ ] ;
7615: LD_ADDR_EXP 19
7619: PUSH
7620: EMPTY
7621: ST_TO_ADDR
// end ;
7622: LD_VAR 0 1
7626: RET
// export function InitMC_Popov ( ) ; begin
7627: LD_INT 0
7629: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
7630: LD_INT 3
7632: PPUSH
7633: LD_INT 3
7635: PPUSH
7636: CALL 80500 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
7640: LD_INT 3
7642: PPUSH
7643: LD_INT 10
7645: PPUSH
7646: CALL 80440 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
7650: LD_INT 3
7652: PPUSH
7653: LD_INT 86
7655: PUSH
7656: LD_INT 118
7658: PUSH
7659: LD_INT 0
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: LIST
7666: PUSH
7667: LD_INT 123
7669: PUSH
7670: LD_INT 151
7672: PUSH
7673: LD_INT 1
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: LIST
7680: PUSH
7681: LD_INT 98
7683: PUSH
7684: LD_INT 121
7686: PUSH
7687: LD_INT 0
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: LIST
7699: PPUSH
7700: CALL 79471 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
7704: LD_INT 3
7706: PPUSH
7707: LD_INT 46
7709: PUSH
7710: LD_INT 45
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PPUSH
7717: CALL 80320 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
7721: LD_INT 3
7723: PPUSH
7724: LD_INT 12
7726: PPUSH
7727: CALL 79990 0 2
// MC_SetTame ( 3 , popov_ape ) ;
7731: LD_INT 3
7733: PPUSH
7734: LD_INT 11
7736: PPUSH
7737: CALL 79713 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
7741: LD_INT 3
7743: PPUSH
7744: LD_INT 4
7746: PPUSH
7747: CALL 79332 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
7751: LD_INT 3
7753: PPUSH
7754: LD_INT 23
7756: PUSH
7757: LD_INT 1
7759: PUSH
7760: LD_INT 3
7762: PUSH
7763: LD_INT 44
7765: PUSH
7766: EMPTY
7767: LIST
7768: LIST
7769: LIST
7770: LIST
7771: PUSH
7772: LD_INT 23
7774: PUSH
7775: LD_INT 1
7777: PUSH
7778: LD_INT 3
7780: PUSH
7781: LD_INT 45
7783: PUSH
7784: EMPTY
7785: LIST
7786: LIST
7787: LIST
7788: LIST
7789: PUSH
7790: LD_INT 21
7792: PUSH
7793: LD_INT 1
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: LD_INT 44
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: LIST
7806: LIST
7807: PUSH
7808: LD_INT 21
7810: PUSH
7811: LD_INT 1
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: LD_INT 45
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: LIST
7824: LIST
7825: PUSH
7826: EMPTY
7827: LIST
7828: LIST
7829: LIST
7830: LIST
7831: PPUSH
7832: CALL 79147 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
7836: LD_INT 3
7838: PPUSH
7839: LD_INT 94
7841: PPUSH
7842: LD_INT 161
7844: PPUSH
7845: LD_INT 0
7847: PPUSH
7848: LD_INT 19
7850: PUSH
7851: LD_INT 17
7853: PUSH
7854: LD_INT 18
7856: PUSH
7857: LD_INT 24
7859: PUSH
7860: LD_INT 21
7862: PUSH
7863: EMPTY
7864: LIST
7865: LIST
7866: LIST
7867: LIST
7868: LIST
7869: PPUSH
7870: CALL 80110 0 5
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
7874: LD_INT 3
7876: PPUSH
7877: LD_INT 21
7879: PUSH
7880: LD_INT 1
7882: PUSH
7883: LD_INT 3
7885: PUSH
7886: LD_INT 51
7888: PUSH
7889: EMPTY
7890: LIST
7891: LIST
7892: LIST
7893: LIST
7894: PUSH
7895: EMPTY
7896: LIST
7897: PPUSH
7898: CALL 79195 0 2
// end ;
7902: LD_VAR 0 1
7906: RET
// every 9 9$00 trigger extraPopovForces and not ruDestroyed do
7907: LD_EXP 18
7911: IFFALSE 7920
7913: PUSH
7914: LD_EXP 5
7918: NOT
7919: AND
7920: IFFALSE 7980
7922: GO 7924
7924: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
7925: LD_EXP 18
7929: PPUSH
7930: LD_INT 106
7932: PPUSH
7933: LD_INT 137
7935: PPUSH
7936: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
7940: LD_ADDR_EXP 23
7944: PUSH
7945: LD_EXP 23
7949: PPUSH
7950: LD_INT 3
7952: PPUSH
7953: LD_EXP 23
7957: PUSH
7958: LD_INT 3
7960: ARRAY
7961: PUSH
7962: LD_EXP 18
7966: UNION
7967: PPUSH
7968: CALL_OW 1
7972: ST_TO_ADDR
// extraPopovForces := [ ] ;
7973: LD_ADDR_EXP 18
7977: PUSH
7978: EMPTY
7979: ST_TO_ADDR
// end ;
7980: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
7981: LD_INT 9
7983: PPUSH
7984: CALL_OW 302
7988: IFFALSE 7997
7990: PUSH
7991: LD_EXP 5
7995: NOT
7996: AND
7997: IFFALSE 8563
7999: GO 8001
8001: DISABLE
8002: LD_INT 0
8004: PPUSH
8005: PPUSH
8006: PPUSH
8007: PPUSH
8008: PPUSH
// begin enable ;
8009: ENABLE
// base := 3 ;
8010: LD_ADDR_VAR 0 2
8014: PUSH
8015: LD_INT 3
8017: ST_TO_ADDR
// tmp := [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
8018: LD_ADDR_VAR 0 3
8022: PUSH
8023: LD_INT 21
8025: PUSH
8026: LD_INT 1
8028: PUSH
8029: LD_INT 3
8031: PUSH
8032: LD_INT 44
8034: PUSH
8035: EMPTY
8036: LIST
8037: LIST
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 23
8043: PUSH
8044: LD_INT 1
8046: PUSH
8047: LD_INT 3
8049: PUSH
8050: LD_INT 46
8052: PUSH
8053: EMPTY
8054: LIST
8055: LIST
8056: LIST
8057: LIST
8058: PUSH
8059: LD_INT 23
8061: PUSH
8062: LD_INT 1
8064: PUSH
8065: LD_INT 3
8067: PUSH
8068: LD_INT 46
8070: PUSH
8071: EMPTY
8072: LIST
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_INT 23
8079: PUSH
8080: LD_INT 1
8082: PUSH
8083: LD_INT 3
8085: PUSH
8086: LD_INT 46
8088: PUSH
8089: EMPTY
8090: LIST
8091: LIST
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: LIST
8099: LIST
8100: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
8101: LD_ADDR_VAR 0 5
8105: PUSH
8106: LD_VAR 0 5
8110: PUSH
8111: LD_OWVAR 1
8115: PUSH
8116: LD_INT 21000
8118: DIV
8119: PLUS
8120: ST_TO_ADDR
// if amount > 8 then
8121: LD_VAR 0 5
8125: PUSH
8126: LD_INT 8
8128: GREATER
8129: IFFALSE 8139
// amount := 8 ;
8131: LD_ADDR_VAR 0 5
8135: PUSH
8136: LD_INT 8
8138: ST_TO_ADDR
// for i = 1 to amount do
8139: LD_ADDR_VAR 0 1
8143: PUSH
8144: DOUBLE
8145: LD_INT 1
8147: DEC
8148: ST_TO_ADDR
8149: LD_VAR 0 5
8153: PUSH
8154: FOR_TO
8155: IFFALSE 8220
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_wheeled , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
8157: LD_ADDR_VAR 0 3
8161: PUSH
8162: LD_VAR 0 3
8166: PPUSH
8167: LD_VAR 0 3
8171: PUSH
8172: LD_INT 1
8174: PLUS
8175: PPUSH
8176: LD_INT 23
8178: PUSH
8179: LD_INT 1
8181: PUSH
8182: LD_INT 3
8184: PUSH
8185: LD_INT 46
8187: PUSH
8188: LD_INT 45
8190: PUSH
8191: EMPTY
8192: LIST
8193: LIST
8194: PUSH
8195: LD_INT 1
8197: PPUSH
8198: LD_INT 2
8200: PPUSH
8201: CALL_OW 12
8205: ARRAY
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: PPUSH
8213: CALL_OW 2
8217: ST_TO_ADDR
8218: GO 8154
8220: POP
8221: POP
// MC_InsertProduceList ( base , tmp ) ;
8222: LD_VAR 0 2
8226: PPUSH
8227: LD_VAR 0 3
8231: PPUSH
8232: CALL 79195 0 2
// repeat wait ( 0 0$1 ) ;
8236: LD_INT 35
8238: PPUSH
8239: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
8243: LD_VAR 0 2
8247: PPUSH
8248: LD_INT 1
8250: PPUSH
8251: CALL 80651 0 2
8255: PUSH
8256: LD_VAR 0 5
8260: GREATEREQUAL
8261: IFFALSE 8236
// wait ( 0 0$30 ) ;
8263: LD_INT 1050
8265: PPUSH
8266: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
8270: LD_ADDR_VAR 0 4
8274: PUSH
8275: LD_EXP 42
8279: PUSH
8280: LD_VAR 0 2
8284: ARRAY
8285: PUSH
8286: LD_EXP 42
8290: PUSH
8291: LD_VAR 0 2
8295: ARRAY
8296: PPUSH
8297: LD_INT 2
8299: PUSH
8300: LD_INT 34
8302: PUSH
8303: LD_INT 51
8305: PUSH
8306: EMPTY
8307: LIST
8308: LIST
8309: PUSH
8310: LD_INT 34
8312: PUSH
8313: LD_INT 52
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: PUSH
8320: EMPTY
8321: LIST
8322: LIST
8323: LIST
8324: PPUSH
8325: CALL_OW 72
8329: DIFF
8330: ST_TO_ADDR
// if not attackers then
8331: LD_VAR 0 4
8335: NOT
8336: IFFALSE 8340
// exit ;
8338: GO 8563
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
8340: LD_ADDR_EXP 42
8344: PUSH
8345: LD_EXP 42
8349: PPUSH
8350: LD_VAR 0 2
8354: PPUSH
8355: LD_EXP 42
8359: PUSH
8360: LD_VAR 0 2
8364: ARRAY
8365: PUSH
8366: LD_VAR 0 4
8370: DIFF
8371: PPUSH
8372: CALL_OW 1
8376: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
8377: LD_VAR 0 4
8381: PPUSH
8382: LD_INT 107
8384: PPUSH
8385: LD_INT 74
8387: PPUSH
8388: CALL_OW 114
// wait ( 0 0$5 ) ;
8392: LD_INT 175
8394: PPUSH
8395: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8399: LD_INT 35
8401: PPUSH
8402: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
8406: LD_VAR 0 4
8410: PPUSH
8411: LD_INT 60
8413: PUSH
8414: EMPTY
8415: LIST
8416: PPUSH
8417: CALL_OW 72
8421: NOT
8422: IFFALSE 8399
// if rand ( 0 , 1 ) then
8424: LD_INT 0
8426: PPUSH
8427: LD_INT 1
8429: PPUSH
8430: CALL_OW 12
8434: IFFALSE 8453
// ComAgressiveMove ( attackers , 155 , 108 ) else
8436: LD_VAR 0 4
8440: PPUSH
8441: LD_INT 155
8443: PPUSH
8444: LD_INT 108
8446: PPUSH
8447: CALL_OW 114
8451: GO 8468
// ComAgressiveMove ( attackers , 149 , 55 ) ;
8453: LD_VAR 0 4
8457: PPUSH
8458: LD_INT 149
8460: PPUSH
8461: LD_INT 55
8463: PPUSH
8464: CALL_OW 114
// wait ( 0 0$10 ) ;
8468: LD_INT 350
8470: PPUSH
8471: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8475: LD_INT 35
8477: PPUSH
8478: CALL_OW 67
// for i in attackers do
8482: LD_ADDR_VAR 0 1
8486: PUSH
8487: LD_VAR 0 4
8491: PUSH
8492: FOR_IN
8493: IFFALSE 8543
// if not HasTask ( i ) then
8495: LD_VAR 0 1
8499: PPUSH
8500: CALL_OW 314
8504: NOT
8505: IFFALSE 8541
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8507: LD_VAR 0 1
8511: PPUSH
8512: LD_INT 81
8514: PUSH
8515: LD_INT 3
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: PPUSH
8527: LD_VAR 0 1
8531: PPUSH
8532: CALL_OW 74
8536: PPUSH
8537: CALL_OW 115
8541: GO 8492
8543: POP
8544: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
8545: LD_VAR 0 4
8549: PPUSH
8550: LD_INT 50
8552: PUSH
8553: EMPTY
8554: LIST
8555: PPUSH
8556: CALL_OW 72
8560: NOT
8561: IFFALSE 8475
// end ;
8563: PPOPN 5
8565: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
8566: LD_EXP 5
8570: NOT
8571: IFFALSE 9162
8573: GO 8575
8575: DISABLE
8576: LD_INT 0
8578: PPUSH
8579: PPUSH
8580: PPUSH
8581: PPUSH
// begin enable ;
8582: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
8583: LD_OWVAR 67
8587: PUSH
8588: LD_INT 1
8590: EQUAL
8591: IFFALSE 8603
8593: PUSH
8594: LD_OWVAR 1
8598: PUSH
8599: LD_INT 63000
8601: LESS
8602: AND
8603: IFFALSE 8607
// exit ;
8605: GO 9162
// tmp := [ ] ;
8607: LD_ADDR_VAR 0 3
8611: PUSH
8612: EMPTY
8613: ST_TO_ADDR
// if tick < 45 45$00 then
8614: LD_OWVAR 1
8618: PUSH
8619: LD_INT 94500
8621: LESS
8622: IFFALSE 8799
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
8624: LD_ADDR_VAR 0 1
8628: PUSH
8629: DOUBLE
8630: LD_INT 1
8632: DEC
8633: ST_TO_ADDR
8634: LD_INT 2
8636: PUSH
8637: LD_INT 3
8639: PUSH
8640: LD_INT 4
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: PUSH
8648: LD_OWVAR 67
8652: ARRAY
8653: PUSH
8654: FOR_TO
8655: IFFALSE 8797
// begin uc_side := 3 ;
8657: LD_ADDR_OWVAR 20
8661: PUSH
8662: LD_INT 3
8664: ST_TO_ADDR
// uc_nation := 3 ;
8665: LD_ADDR_OWVAR 21
8669: PUSH
8670: LD_INT 3
8672: ST_TO_ADDR
// InitHC_All ( ) ;
8673: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
8677: LD_INT 0
8679: PPUSH
8680: LD_INT 1
8682: PPUSH
8683: LD_INT 5
8685: PUSH
8686: LD_INT 6
8688: PUSH
8689: LD_INT 7
8691: PUSH
8692: EMPTY
8693: LIST
8694: LIST
8695: LIST
8696: PUSH
8697: LD_OWVAR 67
8701: ARRAY
8702: PPUSH
8703: CALL_OW 380
// un := CreateHuman ;
8707: LD_ADDR_VAR 0 2
8711: PUSH
8712: CALL_OW 44
8716: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8717: LD_VAR 0 2
8721: PPUSH
8722: LD_INT 18
8724: PPUSH
8725: LD_INT 0
8727: PPUSH
8728: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
8732: LD_VAR 0 2
8736: PPUSH
8737: LD_INT 9
8739: PPUSH
8740: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
8744: LD_VAR 0 2
8748: PPUSH
8749: LD_INT 147
8751: PPUSH
8752: LD_INT 161
8754: PPUSH
8755: CALL_OW 111
// wait ( 0 0$2 ) ;
8759: LD_INT 70
8761: PPUSH
8762: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8766: LD_ADDR_VAR 0 3
8770: PUSH
8771: LD_VAR 0 3
8775: PPUSH
8776: LD_VAR 0 3
8780: PUSH
8781: LD_INT 1
8783: PLUS
8784: PPUSH
8785: LD_VAR 0 2
8789: PPUSH
8790: CALL_OW 1
8794: ST_TO_ADDR
// end ;
8795: GO 8654
8797: POP
8798: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
8799: LD_ADDR_VAR 0 4
8803: PUSH
8804: LD_INT 3
8806: PUSH
8807: LD_INT 4
8809: PUSH
8810: LD_INT 5
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: LIST
8817: PUSH
8818: LD_OWVAR 67
8822: ARRAY
8823: PUSH
8824: LD_OWVAR 1
8828: PUSH
8829: LD_INT 21000
8831: DIV
8832: PLUS
8833: ST_TO_ADDR
// if amount > 15 then
8834: LD_VAR 0 4
8838: PUSH
8839: LD_INT 15
8841: GREATER
8842: IFFALSE 8852
// amount := 15 ;
8844: LD_ADDR_VAR 0 4
8848: PUSH
8849: LD_INT 15
8851: ST_TO_ADDR
// for i := 1 to amount do
8852: LD_ADDR_VAR 0 1
8856: PUSH
8857: DOUBLE
8858: LD_INT 1
8860: DEC
8861: ST_TO_ADDR
8862: LD_VAR 0 4
8866: PUSH
8867: FOR_TO
8868: IFFALSE 9014
// begin uc_side := 3 ;
8870: LD_ADDR_OWVAR 20
8874: PUSH
8875: LD_INT 3
8877: ST_TO_ADDR
// uc_nation := 3 ;
8878: LD_ADDR_OWVAR 21
8882: PUSH
8883: LD_INT 3
8885: ST_TO_ADDR
// PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
8886: LD_INT 24
8888: PPUSH
8889: LD_INT 1
8891: PPUSH
8892: LD_INT 3
8894: PPUSH
8895: LD_INT 46
8897: PUSH
8898: LD_INT 45
8900: PUSH
8901: LD_INT 44
8903: PUSH
8904: LD_INT 43
8906: PUSH
8907: LD_INT 42
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: LIST
8915: LIST
8916: PUSH
8917: LD_INT 1
8919: PPUSH
8920: LD_INT 5
8922: PPUSH
8923: CALL_OW 12
8927: ARRAY
8928: PPUSH
8929: LD_INT 90
8931: PPUSH
8932: CALL 16133 0 5
// un := CreateVehicle ;
8936: LD_ADDR_VAR 0 2
8940: PUSH
8941: CALL_OW 45
8945: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
8946: LD_VAR 0 2
8950: PPUSH
8951: LD_INT 18
8953: PPUSH
8954: LD_INT 0
8956: PPUSH
8957: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
8961: LD_VAR 0 2
8965: PPUSH
8966: LD_INT 147
8968: PPUSH
8969: LD_INT 161
8971: PPUSH
8972: CALL_OW 111
// wait ( 0 0$3 ) ;
8976: LD_INT 105
8978: PPUSH
8979: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8983: LD_ADDR_VAR 0 3
8987: PUSH
8988: LD_VAR 0 3
8992: PPUSH
8993: LD_VAR 0 3
8997: PUSH
8998: LD_INT 1
9000: PLUS
9001: PPUSH
9002: LD_VAR 0 2
9006: PPUSH
9007: CALL_OW 1
9011: ST_TO_ADDR
// end ;
9012: GO 8867
9014: POP
9015: POP
// if not tmp then
9016: LD_VAR 0 3
9020: NOT
9021: IFFALSE 9025
// exit ;
9023: GO 9162
// wait ( 0 0$5 ) ;
9025: LD_INT 175
9027: PPUSH
9028: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
9032: LD_INT 70
9034: PPUSH
9035: CALL_OW 67
// for i in tmp do
9039: LD_ADDR_VAR 0 1
9043: PUSH
9044: LD_VAR 0 3
9048: PUSH
9049: FOR_IN
9050: IFFALSE 9153
// begin if not IsOk ( i ) or IsDead ( i ) then
9052: LD_VAR 0 1
9056: PPUSH
9057: CALL_OW 302
9061: NOT
9062: IFTRUE 9075
9064: PUSH
9065: LD_VAR 0 1
9069: PPUSH
9070: CALL_OW 301
9074: OR
9075: IFFALSE 9093
// tmp := tmp diff i ;
9077: LD_ADDR_VAR 0 3
9081: PUSH
9082: LD_VAR 0 3
9086: PUSH
9087: LD_VAR 0 1
9091: DIFF
9092: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
9093: LD_VAR 0 1
9097: PPUSH
9098: CALL_OW 257
9102: PUSH
9103: LD_INT 9
9105: EQUAL
9106: IFFALSE 9117
// ComSpaceTimeShoot ( i ) ;
9108: LD_VAR 0 1
9112: PPUSH
9113: CALL 12206 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
9117: LD_VAR 0 1
9121: PPUSH
9122: LD_INT 81
9124: PUSH
9125: LD_INT 3
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PPUSH
9132: CALL_OW 69
9136: PPUSH
9137: LD_VAR 0 1
9141: PPUSH
9142: CALL_OW 74
9146: PPUSH
9147: CALL_OW 115
// end ;
9151: GO 9049
9153: POP
9154: POP
// until not tmp ;
9155: LD_VAR 0 3
9159: NOT
9160: IFFALSE 9032
// end ; end_of_file
9162: PPOPN 4
9164: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
9165: LD_INT 0
9167: PPUSH
9168: PPUSH
9169: PPUSH
9170: PPUSH
// uc_side := 1 ;
9171: LD_ADDR_OWVAR 20
9175: PUSH
9176: LD_INT 1
9178: ST_TO_ADDR
// uc_nation := 1 ;
9179: LD_ADDR_OWVAR 21
9183: PUSH
9184: LD_INT 1
9186: ST_TO_ADDR
// hc_importance := 100 ;
9187: LD_ADDR_OWVAR 32
9191: PUSH
9192: LD_INT 100
9194: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
9195: LD_ADDR_OWVAR 26
9199: PUSH
9200: LD_STRING Jeremy Sikorski
9202: ST_TO_ADDR
// hc_gallery := us ;
9203: LD_ADDR_OWVAR 33
9207: PUSH
9208: LD_STRING us
9210: ST_TO_ADDR
// hc_face_number := 19 ;
9211: LD_ADDR_OWVAR 34
9215: PUSH
9216: LD_INT 19
9218: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
9219: LD_INT 1
9221: PPUSH
9222: LD_INT 1
9224: PPUSH
9225: LD_INT 4
9227: PUSH
9228: LD_INT 4
9230: PUSH
9231: LD_INT 3
9233: PUSH
9234: EMPTY
9235: LIST
9236: LIST
9237: LIST
9238: PUSH
9239: LD_OWVAR 67
9243: ARRAY
9244: PPUSH
9245: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
9249: LD_ADDR_OWVAR 29
9253: PUSH
9254: LD_INT 10
9256: PUSH
9257: LD_INT 12
9259: PUSH
9260: EMPTY
9261: LIST
9262: LIST
9263: ST_TO_ADDR
// Sikorski := CreateHuman ;
9264: LD_ADDR_EXP 20
9268: PUSH
9269: CALL_OW 44
9273: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
9274: LD_EXP 20
9278: PPUSH
9279: LD_INT 133
9281: PPUSH
9282: LD_INT 19
9284: PPUSH
9285: LD_INT 2
9287: PPUSH
9288: LD_INT 0
9290: PPUSH
9291: CALL_OW 50
// InitHc_All ( ) ;
9295: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
9299: LD_ADDR_VAR 0 2
9303: PUSH
9304: DOUBLE
9305: LD_INT 1
9307: DEC
9308: ST_TO_ADDR
9309: LD_INT 4
9311: PUSH
9312: LD_INT 3
9314: PUSH
9315: LD_INT 3
9317: PUSH
9318: EMPTY
9319: LIST
9320: LIST
9321: LIST
9322: PUSH
9323: LD_OWVAR 67
9327: ARRAY
9328: PUSH
9329: FOR_TO
9330: IFFALSE 9446
// for j := 1 to 4 do
9332: LD_ADDR_VAR 0 3
9336: PUSH
9337: DOUBLE
9338: LD_INT 1
9340: DEC
9341: ST_TO_ADDR
9342: LD_INT 4
9344: PUSH
9345: FOR_TO
9346: IFFALSE 9442
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
9348: LD_INT 0
9350: PPUSH
9351: LD_VAR 0 3
9355: PPUSH
9356: LD_INT 5
9358: PUSH
9359: LD_INT 4
9361: PUSH
9362: LD_INT 3
9364: PUSH
9365: EMPTY
9366: LIST
9367: LIST
9368: LIST
9369: PUSH
9370: LD_OWVAR 67
9374: ARRAY
9375: PPUSH
9376: CALL_OW 380
// un := CreateHuman ;
9380: LD_ADDR_VAR 0 4
9384: PUSH
9385: CALL_OW 44
9389: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
9390: LD_VAR 0 4
9394: PPUSH
9395: LD_INT 0
9397: PPUSH
9398: LD_INT 5
9400: PPUSH
9401: CALL_OW 12
9405: PPUSH
9406: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
9410: LD_VAR 0 4
9414: PPUSH
9415: LD_INT 133
9417: PPUSH
9418: LD_INT 19
9420: PPUSH
9421: LD_INT 6
9423: PPUSH
9424: LD_INT 0
9426: PPUSH
9427: CALL_OW 50
// ComHold ( un ) ;
9431: LD_VAR 0 4
9435: PPUSH
9436: CALL_OW 140
// end ;
9440: GO 9345
9442: POP
9443: POP
9444: GO 9329
9446: POP
9447: POP
// vc_chassis := us_heavy_tracked ;
9448: LD_ADDR_OWVAR 37
9452: PUSH
9453: LD_INT 4
9455: ST_TO_ADDR
// vc_engine := engine_combustion ;
9456: LD_ADDR_OWVAR 39
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// vc_control := control_manual ;
9464: LD_ADDR_OWVAR 38
9468: PUSH
9469: LD_INT 1
9471: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
9472: LD_ADDR_OWVAR 40
9476: PUSH
9477: LD_INT 14
9479: ST_TO_ADDR
// vc_fuel_battery := 60 ;
9480: LD_ADDR_OWVAR 41
9484: PUSH
9485: LD_INT 60
9487: ST_TO_ADDR
// un := CreateVehicle ;
9488: LD_ADDR_VAR 0 4
9492: PUSH
9493: CALL_OW 45
9497: ST_TO_ADDR
// SetDir ( un , 2 ) ;
9498: LD_VAR 0 4
9502: PPUSH
9503: LD_INT 2
9505: PPUSH
9506: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
9510: LD_VAR 0 4
9514: PPUSH
9515: LD_INT 128
9517: PPUSH
9518: LD_INT 12
9520: PPUSH
9521: LD_INT 0
9523: PPUSH
9524: CALL_OW 48
// for i := 1 to 3 do
9528: LD_ADDR_VAR 0 2
9532: PUSH
9533: DOUBLE
9534: LD_INT 1
9536: DEC
9537: ST_TO_ADDR
9538: LD_INT 3
9540: PUSH
9541: FOR_TO
9542: IFFALSE 9565
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
9544: LD_INT 5
9546: PPUSH
9547: LD_INT 133
9549: PPUSH
9550: LD_INT 19
9552: PPUSH
9553: LD_INT 3
9555: PPUSH
9556: LD_INT 0
9558: PPUSH
9559: CALL_OW 56
9563: GO 9541
9565: POP
9566: POP
// end ; end_of_file
9567: LD_VAR 0 1
9571: RET
// export function Action ; begin
9572: LD_INT 0
9574: PPUSH
// InGameOn ;
9575: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
9579: LD_INT 133
9581: PPUSH
9582: LD_INT 19
9584: PPUSH
9585: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
9589: LD_EXP 20
9593: PPUSH
9594: LD_STRING WT-DS-1
9596: PPUSH
9597: CALL_OW 88
// InGameOff ;
9601: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
9605: LD_STRING DestroyEnemy
9607: PPUSH
9608: CALL_OW 337
// wait ( 0 0$20 ) ;
9612: LD_INT 700
9614: PPUSH
9615: CALL_OW 67
// DialogueOn ;
9619: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
9623: LD_INT 100
9625: PPUSH
9626: LD_INT 37
9628: PPUSH
9629: LD_INT 1
9631: PPUSH
9632: LD_INT 30
9634: NEG
9635: PPUSH
9636: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
9640: LD_INT 100
9642: PPUSH
9643: LD_INT 37
9645: PPUSH
9646: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
9650: LD_EXP 10
9654: PPUSH
9655: LD_STRING WT-PL-1
9657: PPUSH
9658: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
9662: LD_EXP 20
9666: PPUSH
9667: LD_STRING WT-DS-2
9669: PPUSH
9670: CALL_OW 88
// DialogueOff ;
9674: CALL_OW 7
// wait ( 0 0$2 ) ;
9678: LD_INT 70
9680: PPUSH
9681: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
9685: LD_INT 100
9687: PPUSH
9688: LD_INT 37
9690: PPUSH
9691: LD_INT 1
9693: PPUSH
9694: CALL_OW 331
// end ;
9698: LD_VAR 0 1
9702: RET
// export function DialogPowellsAttack ; begin
9703: LD_INT 0
9705: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
9706: LD_EXP 10
9710: PPUSH
9711: LD_STRING WT-PL-8
9713: PPUSH
9714: CALL_OW 94
// end ;
9718: LD_VAR 0 1
9722: RET
// export function DialogContaminateSib ( x , y ) ; begin
9723: LD_INT 0
9725: PPUSH
// DialogueOn ;
9726: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
9730: LD_VAR 0 1
9734: PPUSH
9735: LD_VAR 0 2
9739: PPUSH
9740: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
9744: LD_EXP 20
9748: PPUSH
9749: LD_STRING WT-DS-3
9751: PPUSH
9752: CALL_OW 88
// DialogueOff ;
9756: CALL_OW 7
// end ;
9760: LD_VAR 0 3
9764: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
9765: LD_EXP 8
9769: NOT
9770: IFFALSE 9795
9772: PUSH
9773: LD_INT 1
9775: PPUSH
9776: LD_INT 81
9778: PUSH
9779: LD_INT 4
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: PPUSH
9786: CALL_OW 70
9790: PUSH
9791: LD_INT 3
9793: GREATER
9794: AND
9795: IFFALSE 9867
9797: GO 9799
9799: DISABLE
// begin powellInTrouble := true ;
9800: LD_ADDR_EXP 8
9804: PUSH
9805: LD_INT 1
9807: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
9808: LD_EXP 20
9812: PPUSH
9813: LD_STRING WT-DS-6
9815: PPUSH
9816: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
9820: LD_INT 1
9822: PPUSH
9823: LD_INT 22
9825: PUSH
9826: LD_INT 1
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: PPUSH
9833: CALL_OW 70
9837: NOT
9838: IFFALSE 9852
// SayRadio ( Powell , WT-PL-6 ) ;
9840: LD_EXP 10
9844: PPUSH
9845: LD_STRING WT-PL-6
9847: PPUSH
9848: CALL_OW 94
// wait ( 1 1$30 ) ;
9852: LD_INT 3150
9854: PPUSH
9855: CALL_OW 67
// powellInTrouble := false ;
9859: LD_ADDR_EXP 8
9863: PUSH
9864: LD_INT 0
9866: ST_TO_ADDR
// end ;
9867: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
9868: LD_EXP 9
9872: NOT
9873: IFFALSE 9898
9875: PUSH
9876: LD_INT 16
9878: PPUSH
9879: LD_INT 81
9881: PUSH
9882: LD_INT 1
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PPUSH
9889: CALL_OW 70
9893: PUSH
9894: LD_INT 6
9896: GREATER
9897: AND
9898: IFFALSE 9971
9900: GO 9902
9902: DISABLE
// begin sikorskiInTrouble := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
9911: LD_EXP 20
9915: PPUSH
9916: LD_STRING WT-DS-7
9918: PPUSH
9919: CALL_OW 88
// if not powellAttackGroup then
9923: LD_EXP 12
9927: NOT
9928: IFFALSE 9944
// SayRadio ( Powell , WT-PL-7n ) else
9930: LD_EXP 10
9934: PPUSH
9935: LD_STRING WT-PL-7n
9937: PPUSH
9938: CALL_OW 94
9942: GO 9956
// SayRadio ( Powell , WT-PL-7y ) ;
9944: LD_EXP 10
9948: PPUSH
9949: LD_STRING WT-PL-7y
9951: PPUSH
9952: CALL_OW 94
// wait ( 1 1$30 ) ;
9956: LD_INT 3150
9958: PPUSH
9959: CALL_OW 67
// sikorskiInTrouble := false ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 0
9970: ST_TO_ADDR
// end ;
9971: END
// export function DialogPowellsAttackFailed ; begin
9972: LD_INT 0
9974: PPUSH
// if not ruDestroyed then
9975: LD_EXP 5
9979: NOT
9980: IFFALSE 9996
// SayRadio ( Powell , WT-PL-9 ) else
9982: LD_EXP 10
9986: PPUSH
9987: LD_STRING WT-PL-9
9989: PPUSH
9990: CALL_OW 94
9994: GO 10008
// SayRadio ( Powell , WT-PL-10 ) ;
9996: LD_EXP 10
10000: PPUSH
10001: LD_STRING WT-PL-10
10003: PPUSH
10004: CALL_OW 94
// end ;
10008: LD_VAR 0 1
10012: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10013: LD_INT 22
10015: PUSH
10016: LD_INT 2
10018: PUSH
10019: EMPTY
10020: LIST
10021: LIST
10022: PUSH
10023: LD_INT 21
10025: PUSH
10026: LD_INT 1
10028: PUSH
10029: EMPTY
10030: LIST
10031: LIST
10032: PUSH
10033: EMPTY
10034: LIST
10035: LIST
10036: PPUSH
10037: CALL_OW 69
10041: PUSH
10042: LD_INT 0
10044: EQUAL
10045: IFFALSE 10089
10047: GO 10049
10049: DISABLE
// begin arDestroyed := true ;
10050: LD_ADDR_EXP 4
10054: PUSH
10055: LD_INT 1
10057: ST_TO_ADDR
// MC_Kill ( 2 ) ;
10058: LD_INT 2
10060: PPUSH
10061: CALL 54914 0 1
// Say ( Sikorski , WT-DS-4 ) ;
10065: LD_EXP 20
10069: PPUSH
10070: LD_STRING WT-DS-4
10072: PPUSH
10073: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
10077: LD_EXP 10
10081: PPUSH
10082: LD_STRING WT-PL-4
10084: PPUSH
10085: CALL_OW 94
// end ;
10089: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10090: LD_INT 22
10092: PUSH
10093: LD_INT 3
10095: PUSH
10096: EMPTY
10097: LIST
10098: LIST
10099: PUSH
10100: LD_INT 21
10102: PUSH
10103: LD_INT 1
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PPUSH
10114: CALL_OW 69
10118: PUSH
10119: LD_INT 0
10121: EQUAL
10122: IFFALSE 10166
10124: GO 10126
10126: DISABLE
// begin ruDestroyed := true ;
10127: LD_ADDR_EXP 5
10131: PUSH
10132: LD_INT 1
10134: ST_TO_ADDR
// MC_Kill ( 3 ) ;
10135: LD_INT 3
10137: PPUSH
10138: CALL 54914 0 1
// Say ( Sikorski , WT-DS-5 ) ;
10142: LD_EXP 20
10146: PPUSH
10147: LD_STRING WT-DS-5
10149: PPUSH
10150: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
10154: LD_EXP 10
10158: PPUSH
10159: LD_STRING WT-PL-5
10161: PPUSH
10162: CALL_OW 94
// end ;
10166: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
10167: LD_EXP 5
10171: IFFALSE 10179
10173: PUSH
10174: LD_EXP 4
10178: AND
10179: IFFALSE 10352
10181: GO 10183
10183: DISABLE
// begin wait ( 0 0$3 ) ;
10184: LD_INT 105
10186: PPUSH
10187: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
10191: LD_OWVAR 1
10195: PUSH
10196: LD_INT 126000
10198: PUSH
10199: LD_INT 105000
10201: PUSH
10202: LD_INT 94500
10204: PUSH
10205: EMPTY
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_OWVAR 67
10214: ARRAY
10215: GREATEREQUAL
10216: IFFALSE 10231
// AddMedal ( WoT-med-1 , - 1 ) else
10218: LD_STRING WoT-med-1
10220: PPUSH
10221: LD_INT 1
10223: NEG
10224: PPUSH
10225: CALL_OW 101
10229: GO 10241
// AddMedal ( WoT-med-1 , 1 ) ;
10231: LD_STRING WoT-med-1
10233: PPUSH
10234: LD_INT 1
10236: PPUSH
10237: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
10241: LD_EXP 6
10245: PUSH
10246: LD_INT 4
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 2
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: PUSH
10260: LD_OWVAR 67
10264: ARRAY
10265: GREATEREQUAL
10266: IFFALSE 10281
// AddMedal ( WoT-med-2 , - 1 ) else
10268: LD_STRING WoT-med-2
10270: PPUSH
10271: LD_INT 1
10273: NEG
10274: PPUSH
10275: CALL_OW 101
10279: GO 10291
// AddMedal ( WoT-med-2 , 1 ) ;
10281: LD_STRING WoT-med-2
10283: PPUSH
10284: LD_INT 1
10286: PPUSH
10287: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
10291: LD_EXP 7
10295: PUSH
10296: LD_INT 8
10298: PUSH
10299: LD_INT 6
10301: PUSH
10302: LD_INT 5
10304: PUSH
10305: EMPTY
10306: LIST
10307: LIST
10308: LIST
10309: PUSH
10310: LD_OWVAR 67
10314: ARRAY
10315: GREATEREQUAL
10316: IFFALSE 10331
// AddMedal ( WoT-med-3 , - 1 ) else
10318: LD_STRING WoT-med-3
10320: PPUSH
10321: LD_INT 1
10323: NEG
10324: PPUSH
10325: CALL_OW 101
10329: GO 10341
// AddMedal ( WoT-med-3 , 1 ) ;
10331: LD_STRING WoT-med-3
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 101
// GiveMedals ( MAIN ) ;
10341: LD_STRING MAIN
10343: PPUSH
10344: CALL_OW 102
// YouWin ;
10348: CALL_OW 103
// end ; end_of_file
10352: END
// export function CustomEvent ( event ) ; begin
10353: LD_INT 0
10355: PPUSH
// end ;
10356: LD_VAR 0 2
10360: RET
// on Command ( com ) do var i , j , temp ;
10361: LD_INT 0
10363: PPUSH
10364: PPUSH
10365: PPUSH
// begin if com = 60 then
10366: LD_VAR 0 1
10370: PUSH
10371: LD_INT 60
10373: EQUAL
10374: IFFALSE 10555
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
10376: LD_ADDR_VAR 0 2
10380: PUSH
10381: LD_INT 22
10383: PUSH
10384: LD_INT 1
10386: PUSH
10387: EMPTY
10388: LIST
10389: LIST
10390: PUSH
10391: LD_INT 2
10393: PUSH
10394: LD_INT 21
10396: PUSH
10397: LD_INT 1
10399: PUSH
10400: EMPTY
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 34
10406: PUSH
10407: LD_INT 12
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: PUSH
10414: EMPTY
10415: LIST
10416: LIST
10417: LIST
10418: PUSH
10419: EMPTY
10420: LIST
10421: LIST
10422: PPUSH
10423: CALL_OW 69
10427: PUSH
10428: FOR_IN
10429: IFFALSE 10553
// begin if GetTaskList ( i ) > 0 then
10431: LD_VAR 0 2
10435: PPUSH
10436: CALL_OW 437
10440: PUSH
10441: LD_INT 0
10443: GREATER
10444: IFFALSE 10551
// for j = 1 to GetTaskList ( i ) do
10446: LD_ADDR_VAR 0 3
10450: PUSH
10451: DOUBLE
10452: LD_INT 1
10454: DEC
10455: ST_TO_ADDR
10456: LD_VAR 0 2
10460: PPUSH
10461: CALL_OW 437
10465: PUSH
10466: FOR_TO
10467: IFFALSE 10549
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
10469: LD_ADDR_VAR 0 4
10473: PUSH
10474: LD_VAR 0 2
10478: PPUSH
10479: CALL_OW 437
10483: PUSH
10484: LD_VAR 0 3
10488: ARRAY
10489: PUSH
10490: LD_INT 4
10492: ARRAY
10493: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
10494: LD_VAR 0 4
10498: PPUSH
10499: CALL_OW 255
10503: PUSH
10504: LD_INT 4
10506: EQUAL
10507: IFFALSE 10534
10509: PUSH
10510: LD_VAR 0 2
10514: PPUSH
10515: CALL_OW 437
10519: PUSH
10520: LD_VAR 0 3
10524: ARRAY
10525: PUSH
10526: LD_INT 1
10528: ARRAY
10529: PUSH
10530: LD_STRING <
10532: EQUAL
10533: AND
10534: IFFALSE 10547
// SetTaskList ( i , [ ] ) ;
10536: LD_VAR 0 2
10540: PPUSH
10541: EMPTY
10542: PPUSH
10543: CALL_OW 446
// end ;
10547: GO 10466
10549: POP
10550: POP
// end ;
10551: GO 10428
10553: POP
10554: POP
// end ; end ;
10555: PPOPN 4
10557: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 or ( x = 132 and y = 39 ) then
10558: LD_VAR 0 2
10562: PPUSH
10563: LD_VAR 0 3
10567: PPUSH
10568: CALL_OW 428
10572: PPUSH
10573: CALL_OW 255
10577: PUSH
10578: LD_INT 1
10580: EQUAL
10581: IFTRUE 10605
10583: PUSH
10584: LD_VAR 0 2
10588: PUSH
10589: LD_INT 132
10591: EQUAL
10592: IFFALSE 10604
10594: PUSH
10595: LD_VAR 0 3
10599: PUSH
10600: LD_INT 39
10602: EQUAL
10603: AND
10604: OR
10605: IFFALSE 10621
// DialogContaminateSib ( x , y ) ;
10607: LD_VAR 0 2
10611: PPUSH
10612: LD_VAR 0 3
10616: PPUSH
10617: CALL 9723 0 2
// end ;
10621: PPOPN 3
10623: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
10624: LD_VAR 0 1
10628: PPUSH
10629: CALL 93142 0 1
// MCE_UnitDestroyed ( un ) ;
10633: LD_VAR 0 1
10637: PPUSH
10638: CALL 82701 0 1
// if un = Powell then
10642: LD_VAR 0 1
10646: PUSH
10647: LD_EXP 10
10651: EQUAL
10652: IFFALSE 10661
// YouLost ( Powell ) ;
10654: LD_STRING Powell
10656: PPUSH
10657: CALL_OW 104
// if un = Sikorski then
10661: LD_VAR 0 1
10665: PUSH
10666: LD_EXP 20
10670: EQUAL
10671: IFFALSE 10680
// YouLost ( Sikorski ) ;
10673: LD_STRING Sikorski
10675: PPUSH
10676: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
10680: LD_VAR 0 1
10684: PUSH
10685: LD_INT 22
10687: PUSH
10688: LD_INT 1
10690: PUSH
10691: EMPTY
10692: LIST
10693: LIST
10694: PUSH
10695: LD_INT 21
10697: PUSH
10698: LD_INT 1
10700: PUSH
10701: EMPTY
10702: LIST
10703: LIST
10704: PUSH
10705: EMPTY
10706: LIST
10707: LIST
10708: PPUSH
10709: CALL_OW 69
10713: IN
10714: IFFALSE 10730
// loseCounter := loseCounter + 1 ;
10716: LD_ADDR_EXP 6
10720: PUSH
10721: LD_EXP 6
10725: PUSH
10726: LD_INT 1
10728: PLUS
10729: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
10730: LD_VAR 0 1
10734: PUSH
10735: LD_INT 22
10737: PUSH
10738: LD_INT 4
10740: PUSH
10741: EMPTY
10742: LIST
10743: LIST
10744: PUSH
10745: LD_INT 21
10747: PUSH
10748: LD_INT 1
10750: PUSH
10751: EMPTY
10752: LIST
10753: LIST
10754: PUSH
10755: EMPTY
10756: LIST
10757: LIST
10758: PPUSH
10759: CALL_OW 69
10763: IN
10764: IFFALSE 10780
// powellLoseCounter := powellLoseCounter + 1 ;
10766: LD_ADDR_EXP 7
10770: PUSH
10771: LD_EXP 7
10775: PUSH
10776: LD_INT 1
10778: PLUS
10779: ST_TO_ADDR
// if un in powellAttackGroup then
10780: LD_VAR 0 1
10784: PUSH
10785: LD_EXP 12
10789: IN
10790: IFFALSE 10808
// powellAttackGroup := powellAttackGroup diff un ;
10792: LD_ADDR_EXP 12
10796: PUSH
10797: LD_EXP 12
10801: PUSH
10802: LD_VAR 0 1
10806: DIFF
10807: ST_TO_ADDR
// if un in gensherAttackGroup then
10808: LD_VAR 0 1
10812: PUSH
10813: LD_EXP 15
10817: IN
10818: IFFALSE 10836
// gensherAttackGroup := gensherAttackGroup diff un ;
10820: LD_ADDR_EXP 15
10824: PUSH
10825: LD_EXP 15
10829: PUSH
10830: LD_VAR 0 1
10834: DIFF
10835: ST_TO_ADDR
// if un in popovAttackGroup then
10836: LD_VAR 0 1
10840: PUSH
10841: LD_EXP 19
10845: IN
10846: IFFALSE 10864
// popovAttackGroup := popovAttackGroup diff un ;
10848: LD_ADDR_EXP 19
10852: PUSH
10853: LD_EXP 19
10857: PUSH
10858: LD_VAR 0 1
10862: DIFF
10863: ST_TO_ADDR
// end ;
10864: PPOPN 1
10866: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
10867: LD_VAR 0 1
10871: PPUSH
10872: LD_VAR 0 2
10876: PPUSH
10877: CALL 85055 0 2
// end ;
10881: PPOPN 2
10883: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
10884: LD_VAR 0 1
10888: PPUSH
10889: CALL 84119 0 1
// end ;
10893: PPOPN 1
10895: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
10896: LD_VAR 0 1
10900: PPUSH
10901: CALL 84362 0 1
// end ;
10905: PPOPN 1
10907: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_VAR 0 2
10917: PPUSH
10918: CALL 82389 0 2
// end ;
10922: PPOPN 2
10924: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
10925: LD_VAR 0 1
10929: PPUSH
10930: LD_VAR 0 2
10934: PPUSH
10935: LD_VAR 0 3
10939: PPUSH
10940: LD_VAR 0 4
10944: PPUSH
10945: LD_VAR 0 5
10949: PPUSH
10950: CALL 82007 0 5
// end ;
10954: PPOPN 5
10956: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
10957: LD_VAR 0 1
10961: PPUSH
10962: LD_VAR 0 2
10966: PPUSH
10967: CALL 93200 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
10971: LD_VAR 0 1
10975: PPUSH
10976: LD_VAR 0 2
10980: PPUSH
10981: CALL 81556 0 2
// end ;
10985: PPOPN 2
10987: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
10988: LD_VAR 0 1
10992: PPUSH
10993: LD_VAR 0 2
10997: PPUSH
10998: LD_VAR 0 3
11002: PPUSH
11003: LD_VAR 0 4
11007: PPUSH
11008: CALL 81388 0 4
// end ;
11012: PPOPN 4
11014: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
11015: LD_VAR 0 1
11019: PPUSH
11020: LD_VAR 0 2
11024: PPUSH
11025: LD_VAR 0 3
11029: PPUSH
11030: CALL 81161 0 3
// end ;
11034: PPOPN 3
11036: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
11037: LD_VAR 0 1
11041: PPUSH
11042: LD_VAR 0 2
11046: PPUSH
11047: CALL 81044 0 2
// end ;
11051: PPOPN 2
11053: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
11054: LD_VAR 0 1
11058: PPUSH
11059: LD_VAR 0 2
11063: PPUSH
11064: CALL 85352 0 2
// end ;
11068: PPOPN 2
11070: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
11071: LD_VAR 0 1
11075: PPUSH
11076: LD_VAR 0 2
11080: PPUSH
11081: LD_VAR 0 3
11085: PPUSH
11086: LD_VAR 0 4
11090: PPUSH
11091: CALL 85576 0 4
// end ;
11095: PPOPN 4
11097: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
11098: LD_VAR 0 1
11102: PPUSH
11103: LD_VAR 0 2
11107: PPUSH
11108: CALL 80851 0 2
// end ;
11112: PPOPN 2
11114: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
11115: LD_VAR 0 1
11119: PUSH
11120: LD_INT 1
11122: EQUAL
11123: IFFALSE 11135
11125: PUSH
11126: LD_VAR 0 2
11130: PUSH
11131: LD_INT 4
11133: EQUAL
11134: AND
11135: IFFALSE 11144
// YouLost ( FriendlyFire ) ;
11137: LD_STRING FriendlyFire
11139: PPUSH
11140: CALL_OW 104
// end ; end_of_file
11144: PPOPN 2
11146: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
11147: LD_INT 0
11149: PPUSH
11150: PPUSH
// if exist_mode then
11151: LD_VAR 0 2
11155: IFFALSE 11201
// begin unit := CreateCharacter ( prefix & ident ) ;
11157: LD_ADDR_VAR 0 5
11161: PUSH
11162: LD_VAR 0 3
11166: PUSH
11167: LD_VAR 0 1
11171: STR
11172: PPUSH
11173: CALL_OW 34
11177: ST_TO_ADDR
// if unit then
11178: LD_VAR 0 5
11182: IFFALSE 11199
// DeleteCharacters ( prefix & ident ) ;
11184: LD_VAR 0 3
11188: PUSH
11189: LD_VAR 0 1
11193: STR
11194: PPUSH
11195: CALL_OW 40
// end else
11199: GO 11216
// unit := NewCharacter ( ident ) ;
11201: LD_ADDR_VAR 0 5
11205: PUSH
11206: LD_VAR 0 1
11210: PPUSH
11211: CALL_OW 25
11215: ST_TO_ADDR
// result := unit ;
11216: LD_ADDR_VAR 0 4
11220: PUSH
11221: LD_VAR 0 5
11225: ST_TO_ADDR
// end ;
11226: LD_VAR 0 4
11230: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// if exist_mode then
11235: LD_VAR 0 2
11239: IFFALSE 11264
// unit := CreateCharacter ( prefix & ident ) else
11241: LD_ADDR_VAR 0 5
11245: PUSH
11246: LD_VAR 0 3
11250: PUSH
11251: LD_VAR 0 1
11255: STR
11256: PPUSH
11257: CALL_OW 34
11261: ST_TO_ADDR
11262: GO 11279
// unit := NewCharacter ( ident ) ;
11264: LD_ADDR_VAR 0 5
11268: PUSH
11269: LD_VAR 0 1
11273: PPUSH
11274: CALL_OW 25
11278: ST_TO_ADDR
// result := unit ;
11279: LD_ADDR_VAR 0 4
11283: PUSH
11284: LD_VAR 0 5
11288: ST_TO_ADDR
// end ;
11289: LD_VAR 0 4
11293: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
11294: LD_INT 0
11296: PPUSH
11297: PPUSH
// if not side or not nation then
11298: LD_VAR 0 1
11302: NOT
11303: IFTRUE 11312
11305: PUSH
11306: LD_VAR 0 2
11310: NOT
11311: OR
11312: IFFALSE 11316
// exit ;
11314: GO 12110
// case nation of nation_american :
11316: LD_VAR 0 2
11320: PUSH
11321: LD_INT 1
11323: DOUBLE
11324: EQUAL
11325: IFTRUE 11329
11327: GO 11551
11329: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
11330: LD_ADDR_VAR 0 4
11334: PUSH
11335: LD_INT 35
11337: PUSH
11338: LD_INT 45
11340: PUSH
11341: LD_INT 46
11343: PUSH
11344: LD_INT 47
11346: PUSH
11347: LD_INT 82
11349: PUSH
11350: LD_INT 83
11352: PUSH
11353: LD_INT 84
11355: PUSH
11356: LD_INT 85
11358: PUSH
11359: LD_INT 86
11361: PUSH
11362: LD_INT 1
11364: PUSH
11365: LD_INT 2
11367: PUSH
11368: LD_INT 6
11370: PUSH
11371: LD_INT 15
11373: PUSH
11374: LD_INT 16
11376: PUSH
11377: LD_INT 7
11379: PUSH
11380: LD_INT 12
11382: PUSH
11383: LD_INT 13
11385: PUSH
11386: LD_INT 10
11388: PUSH
11389: LD_INT 14
11391: PUSH
11392: LD_INT 20
11394: PUSH
11395: LD_INT 21
11397: PUSH
11398: LD_INT 22
11400: PUSH
11401: LD_INT 25
11403: PUSH
11404: LD_INT 32
11406: PUSH
11407: LD_INT 27
11409: PUSH
11410: LD_INT 36
11412: PUSH
11413: LD_INT 69
11415: PUSH
11416: LD_INT 39
11418: PUSH
11419: LD_INT 34
11421: PUSH
11422: LD_INT 40
11424: PUSH
11425: LD_INT 48
11427: PUSH
11428: LD_INT 49
11430: PUSH
11431: LD_INT 50
11433: PUSH
11434: LD_INT 51
11436: PUSH
11437: LD_INT 52
11439: PUSH
11440: LD_INT 53
11442: PUSH
11443: LD_INT 54
11445: PUSH
11446: LD_INT 55
11448: PUSH
11449: LD_INT 56
11451: PUSH
11452: LD_INT 57
11454: PUSH
11455: LD_INT 58
11457: PUSH
11458: LD_INT 59
11460: PUSH
11461: LD_INT 60
11463: PUSH
11464: LD_INT 61
11466: PUSH
11467: LD_INT 62
11469: PUSH
11470: LD_INT 80
11472: PUSH
11473: LD_INT 82
11475: PUSH
11476: LD_INT 83
11478: PUSH
11479: LD_INT 84
11481: PUSH
11482: LD_INT 85
11484: PUSH
11485: LD_INT 86
11487: PUSH
11488: LD_INT 90
11490: PUSH
11491: LD_INT 93
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: ST_TO_ADDR
11549: GO 12032
11551: LD_INT 2
11553: DOUBLE
11554: EQUAL
11555: IFTRUE 11559
11557: GO 11793
11559: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
11560: LD_ADDR_VAR 0 4
11564: PUSH
11565: LD_INT 35
11567: PUSH
11568: LD_INT 45
11570: PUSH
11571: LD_INT 46
11573: PUSH
11574: LD_INT 47
11576: PUSH
11577: LD_INT 82
11579: PUSH
11580: LD_INT 83
11582: PUSH
11583: LD_INT 84
11585: PUSH
11586: LD_INT 85
11588: PUSH
11589: LD_INT 87
11591: PUSH
11592: LD_INT 70
11594: PUSH
11595: LD_INT 1
11597: PUSH
11598: LD_INT 11
11600: PUSH
11601: LD_INT 3
11603: PUSH
11604: LD_INT 4
11606: PUSH
11607: LD_INT 5
11609: PUSH
11610: LD_INT 6
11612: PUSH
11613: LD_INT 15
11615: PUSH
11616: LD_INT 18
11618: PUSH
11619: LD_INT 7
11621: PUSH
11622: LD_INT 17
11624: PUSH
11625: LD_INT 8
11627: PUSH
11628: LD_INT 20
11630: PUSH
11631: LD_INT 21
11633: PUSH
11634: LD_INT 22
11636: PUSH
11637: LD_INT 72
11639: PUSH
11640: LD_INT 26
11642: PUSH
11643: LD_INT 69
11645: PUSH
11646: LD_INT 39
11648: PUSH
11649: LD_INT 40
11651: PUSH
11652: LD_INT 41
11654: PUSH
11655: LD_INT 42
11657: PUSH
11658: LD_INT 43
11660: PUSH
11661: LD_INT 48
11663: PUSH
11664: LD_INT 49
11666: PUSH
11667: LD_INT 50
11669: PUSH
11670: LD_INT 51
11672: PUSH
11673: LD_INT 52
11675: PUSH
11676: LD_INT 53
11678: PUSH
11679: LD_INT 54
11681: PUSH
11682: LD_INT 55
11684: PUSH
11685: LD_INT 56
11687: PUSH
11688: LD_INT 60
11690: PUSH
11691: LD_INT 61
11693: PUSH
11694: LD_INT 62
11696: PUSH
11697: LD_INT 66
11699: PUSH
11700: LD_INT 67
11702: PUSH
11703: LD_INT 68
11705: PUSH
11706: LD_INT 81
11708: PUSH
11709: LD_INT 82
11711: PUSH
11712: LD_INT 83
11714: PUSH
11715: LD_INT 84
11717: PUSH
11718: LD_INT 85
11720: PUSH
11721: LD_INT 87
11723: PUSH
11724: LD_INT 88
11726: PUSH
11727: LD_INT 92
11729: PUSH
11730: LD_INT 94
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: LIST
11739: LIST
11740: LIST
11741: LIST
11742: LIST
11743: LIST
11744: LIST
11745: LIST
11746: LIST
11747: LIST
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: LIST
11753: LIST
11754: LIST
11755: LIST
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: LIST
11761: LIST
11762: LIST
11763: LIST
11764: LIST
11765: LIST
11766: LIST
11767: LIST
11768: LIST
11769: LIST
11770: LIST
11771: LIST
11772: LIST
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: LIST
11784: LIST
11785: LIST
11786: LIST
11787: LIST
11788: LIST
11789: LIST
11790: ST_TO_ADDR
11791: GO 12032
11793: LD_INT 3
11795: DOUBLE
11796: EQUAL
11797: IFTRUE 11801
11799: GO 12031
11801: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
11802: LD_ADDR_VAR 0 4
11806: PUSH
11807: LD_INT 46
11809: PUSH
11810: LD_INT 47
11812: PUSH
11813: LD_INT 1
11815: PUSH
11816: LD_INT 2
11818: PUSH
11819: LD_INT 82
11821: PUSH
11822: LD_INT 83
11824: PUSH
11825: LD_INT 84
11827: PUSH
11828: LD_INT 85
11830: PUSH
11831: LD_INT 86
11833: PUSH
11834: LD_INT 11
11836: PUSH
11837: LD_INT 9
11839: PUSH
11840: LD_INT 20
11842: PUSH
11843: LD_INT 19
11845: PUSH
11846: LD_INT 21
11848: PUSH
11849: LD_INT 24
11851: PUSH
11852: LD_INT 22
11854: PUSH
11855: LD_INT 25
11857: PUSH
11858: LD_INT 28
11860: PUSH
11861: LD_INT 29
11863: PUSH
11864: LD_INT 30
11866: PUSH
11867: LD_INT 31
11869: PUSH
11870: LD_INT 37
11872: PUSH
11873: LD_INT 38
11875: PUSH
11876: LD_INT 32
11878: PUSH
11879: LD_INT 27
11881: PUSH
11882: LD_INT 33
11884: PUSH
11885: LD_INT 69
11887: PUSH
11888: LD_INT 39
11890: PUSH
11891: LD_INT 34
11893: PUSH
11894: LD_INT 40
11896: PUSH
11897: LD_INT 71
11899: PUSH
11900: LD_INT 23
11902: PUSH
11903: LD_INT 44
11905: PUSH
11906: LD_INT 48
11908: PUSH
11909: LD_INT 49
11911: PUSH
11912: LD_INT 50
11914: PUSH
11915: LD_INT 51
11917: PUSH
11918: LD_INT 52
11920: PUSH
11921: LD_INT 53
11923: PUSH
11924: LD_INT 54
11926: PUSH
11927: LD_INT 55
11929: PUSH
11930: LD_INT 56
11932: PUSH
11933: LD_INT 57
11935: PUSH
11936: LD_INT 58
11938: PUSH
11939: LD_INT 59
11941: PUSH
11942: LD_INT 63
11944: PUSH
11945: LD_INT 64
11947: PUSH
11948: LD_INT 65
11950: PUSH
11951: LD_INT 82
11953: PUSH
11954: LD_INT 83
11956: PUSH
11957: LD_INT 84
11959: PUSH
11960: LD_INT 85
11962: PUSH
11963: LD_INT 86
11965: PUSH
11966: LD_INT 89
11968: PUSH
11969: LD_INT 91
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: LIST
11982: LIST
11983: LIST
11984: LIST
11985: LIST
11986: LIST
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: LIST
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: LIST
12004: LIST
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: LIST
12016: LIST
12017: LIST
12018: LIST
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: LIST
12024: LIST
12025: LIST
12026: LIST
12027: LIST
12028: ST_TO_ADDR
12029: GO 12032
12031: POP
// if state > - 1 and state < 3 then
12032: LD_VAR 0 3
12036: PUSH
12037: LD_INT 1
12039: NEG
12040: GREATER
12041: IFFALSE 12053
12043: PUSH
12044: LD_VAR 0 3
12048: PUSH
12049: LD_INT 3
12051: LESS
12052: AND
12053: IFFALSE 12110
// for i in result do
12055: LD_ADDR_VAR 0 5
12059: PUSH
12060: LD_VAR 0 4
12064: PUSH
12065: FOR_IN
12066: IFFALSE 12108
// if GetTech ( i , side ) <> state then
12068: LD_VAR 0 5
12072: PPUSH
12073: LD_VAR 0 1
12077: PPUSH
12078: CALL_OW 321
12082: PUSH
12083: LD_VAR 0 3
12087: NONEQUAL
12088: IFFALSE 12106
// result := result diff i ;
12090: LD_ADDR_VAR 0 4
12094: PUSH
12095: LD_VAR 0 4
12099: PUSH
12100: LD_VAR 0 5
12104: DIFF
12105: ST_TO_ADDR
12106: GO 12065
12108: POP
12109: POP
// end ;
12110: LD_VAR 0 4
12114: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
12115: LD_INT 0
12117: PPUSH
12118: PPUSH
12119: PPUSH
// result := true ;
12120: LD_ADDR_VAR 0 3
12124: PUSH
12125: LD_INT 1
12127: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
12128: LD_ADDR_VAR 0 5
12132: PUSH
12133: LD_VAR 0 2
12137: PPUSH
12138: CALL_OW 480
12142: ST_TO_ADDR
// if not tmp then
12143: LD_VAR 0 5
12147: NOT
12148: IFFALSE 12152
// exit ;
12150: GO 12201
// for i in tmp do
12152: LD_ADDR_VAR 0 4
12156: PUSH
12157: LD_VAR 0 5
12161: PUSH
12162: FOR_IN
12163: IFFALSE 12199
// if GetTech ( i , side ) <> state_researched then
12165: LD_VAR 0 4
12169: PPUSH
12170: LD_VAR 0 1
12174: PPUSH
12175: CALL_OW 321
12179: PUSH
12180: LD_INT 2
12182: NONEQUAL
12183: IFFALSE 12197
// begin result := false ;
12185: LD_ADDR_VAR 0 3
12189: PUSH
12190: LD_INT 0
12192: ST_TO_ADDR
// exit ;
12193: POP
12194: POP
12195: GO 12201
// end ;
12197: GO 12162
12199: POP
12200: POP
// end ;
12201: LD_VAR 0 3
12205: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
12206: LD_INT 0
12208: PPUSH
12209: PPUSH
12210: PPUSH
12211: PPUSH
12212: PPUSH
12213: PPUSH
12214: PPUSH
12215: PPUSH
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
12221: LD_VAR 0 1
12225: NOT
12226: IFTRUE 12243
12228: PUSH
12229: LD_VAR 0 1
12233: PPUSH
12234: CALL_OW 257
12238: PUSH
12239: LD_INT 9
12241: NONEQUAL
12242: OR
12243: IFFALSE 12247
// exit ;
12245: GO 12826
// side := GetSide ( unit ) ;
12247: LD_ADDR_VAR 0 9
12251: PUSH
12252: LD_VAR 0 1
12256: PPUSH
12257: CALL_OW 255
12261: ST_TO_ADDR
// tech_space := tech_spacanom ;
12262: LD_ADDR_VAR 0 12
12266: PUSH
12267: LD_INT 29
12269: ST_TO_ADDR
// tech_time := tech_taurad ;
12270: LD_ADDR_VAR 0 13
12274: PUSH
12275: LD_INT 28
12277: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
12278: LD_ADDR_VAR 0 11
12282: PUSH
12283: LD_VAR 0 1
12287: PPUSH
12288: CALL_OW 310
12292: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
12293: LD_VAR 0 11
12297: PPUSH
12298: CALL_OW 247
12302: PUSH
12303: LD_INT 2
12305: EQUAL
12306: IFFALSE 12310
// exit ;
12308: GO 12826
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
12310: LD_ADDR_VAR 0 8
12314: PUSH
12315: LD_INT 81
12317: PUSH
12318: LD_VAR 0 9
12322: PUSH
12323: EMPTY
12324: LIST
12325: LIST
12326: PUSH
12327: LD_INT 3
12329: PUSH
12330: LD_INT 21
12332: PUSH
12333: LD_INT 3
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PPUSH
12348: CALL_OW 69
12352: ST_TO_ADDR
// if not tmp then
12353: LD_VAR 0 8
12357: NOT
12358: IFFALSE 12362
// exit ;
12360: GO 12826
// if in_unit then
12362: LD_VAR 0 11
12366: IFFALSE 12390
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
12368: LD_ADDR_VAR 0 10
12372: PUSH
12373: LD_VAR 0 8
12377: PPUSH
12378: LD_VAR 0 11
12382: PPUSH
12383: CALL_OW 74
12387: ST_TO_ADDR
12388: GO 12410
// enemy := NearestUnitToUnit ( tmp , unit ) ;
12390: LD_ADDR_VAR 0 10
12394: PUSH
12395: LD_VAR 0 8
12399: PPUSH
12400: LD_VAR 0 1
12404: PPUSH
12405: CALL_OW 74
12409: ST_TO_ADDR
// if not enemy then
12410: LD_VAR 0 10
12414: NOT
12415: IFFALSE 12419
// exit ;
12417: GO 12826
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
12419: LD_VAR 0 11
12423: IFFALSE 12445
12425: PUSH
12426: LD_VAR 0 11
12430: PPUSH
12431: LD_VAR 0 10
12435: PPUSH
12436: CALL_OW 296
12440: PUSH
12441: LD_INT 13
12443: GREATER
12444: AND
12445: IFTRUE 12467
12447: PUSH
12448: LD_VAR 0 1
12452: PPUSH
12453: LD_VAR 0 10
12457: PPUSH
12458: CALL_OW 296
12462: PUSH
12463: LD_INT 12
12465: GREATER
12466: OR
12467: IFFALSE 12471
// exit ;
12469: GO 12826
// missile := [ 1 ] ;
12471: LD_ADDR_VAR 0 14
12475: PUSH
12476: LD_INT 1
12478: PUSH
12479: EMPTY
12480: LIST
12481: ST_TO_ADDR
// if Researched ( side , tech_space ) then
12482: LD_VAR 0 9
12486: PPUSH
12487: LD_VAR 0 12
12491: PPUSH
12492: CALL_OW 325
12496: IFFALSE 12525
// missile := Replace ( missile , missile + 1 , 2 ) ;
12498: LD_ADDR_VAR 0 14
12502: PUSH
12503: LD_VAR 0 14
12507: PPUSH
12508: LD_VAR 0 14
12512: PUSH
12513: LD_INT 1
12515: PLUS
12516: PPUSH
12517: LD_INT 2
12519: PPUSH
12520: CALL_OW 1
12524: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
12525: LD_VAR 0 9
12529: PPUSH
12530: LD_VAR 0 13
12534: PPUSH
12535: CALL_OW 325
12539: IFFALSE 12563
12541: PUSH
12542: LD_VAR 0 10
12546: PPUSH
12547: CALL_OW 255
12551: PPUSH
12552: LD_VAR 0 13
12556: PPUSH
12557: CALL_OW 325
12561: NOT
12562: AND
12563: IFFALSE 12592
// missile := Replace ( missile , missile + 1 , 3 ) ;
12565: LD_ADDR_VAR 0 14
12569: PUSH
12570: LD_VAR 0 14
12574: PPUSH
12575: LD_VAR 0 14
12579: PUSH
12580: LD_INT 1
12582: PLUS
12583: PPUSH
12584: LD_INT 3
12586: PPUSH
12587: CALL_OW 1
12591: ST_TO_ADDR
// if missile < 2 then
12592: LD_VAR 0 14
12596: PUSH
12597: LD_INT 2
12599: LESS
12600: IFFALSE 12604
// exit ;
12602: GO 12826
// x := GetX ( enemy ) ;
12604: LD_ADDR_VAR 0 4
12608: PUSH
12609: LD_VAR 0 10
12613: PPUSH
12614: CALL_OW 250
12618: ST_TO_ADDR
// y := GetY ( enemy ) ;
12619: LD_ADDR_VAR 0 5
12623: PUSH
12624: LD_VAR 0 10
12628: PPUSH
12629: CALL_OW 251
12633: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
12634: LD_ADDR_VAR 0 6
12638: PUSH
12639: LD_VAR 0 4
12643: PUSH
12644: LD_INT 1
12646: NEG
12647: PPUSH
12648: LD_INT 1
12650: PPUSH
12651: CALL_OW 12
12655: PLUS
12656: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
12657: LD_ADDR_VAR 0 7
12661: PUSH
12662: LD_VAR 0 5
12666: PUSH
12667: LD_INT 1
12669: NEG
12670: PPUSH
12671: LD_INT 1
12673: PPUSH
12674: CALL_OW 12
12678: PLUS
12679: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12680: LD_VAR 0 6
12684: PPUSH
12685: LD_VAR 0 7
12689: PPUSH
12690: CALL_OW 488
12694: NOT
12695: IFFALSE 12717
// begin _x := x ;
12697: LD_ADDR_VAR 0 6
12701: PUSH
12702: LD_VAR 0 4
12706: ST_TO_ADDR
// _y := y ;
12707: LD_ADDR_VAR 0 7
12711: PUSH
12712: LD_VAR 0 5
12716: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
12717: LD_ADDR_VAR 0 3
12721: PUSH
12722: LD_INT 1
12724: PPUSH
12725: LD_VAR 0 14
12729: PPUSH
12730: CALL_OW 12
12734: ST_TO_ADDR
// case i of 1 :
12735: LD_VAR 0 3
12739: PUSH
12740: LD_INT 1
12742: DOUBLE
12743: EQUAL
12744: IFTRUE 12748
12746: GO 12765
12748: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
12749: LD_VAR 0 1
12753: PPUSH
12754: LD_VAR 0 10
12758: PPUSH
12759: CALL_OW 115
12763: GO 12826
12765: LD_INT 2
12767: DOUBLE
12768: EQUAL
12769: IFTRUE 12773
12771: GO 12795
12773: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
12774: LD_VAR 0 1
12778: PPUSH
12779: LD_VAR 0 6
12783: PPUSH
12784: LD_VAR 0 7
12788: PPUSH
12789: CALL_OW 153
12793: GO 12826
12795: LD_INT 3
12797: DOUBLE
12798: EQUAL
12799: IFTRUE 12803
12801: GO 12825
12803: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 6
12813: PPUSH
12814: LD_VAR 0 7
12818: PPUSH
12819: CALL_OW 154
12823: GO 12826
12825: POP
// end ;
12826: LD_VAR 0 2
12830: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
12831: LD_INT 0
12833: PPUSH
12834: PPUSH
12835: PPUSH
12836: PPUSH
12837: PPUSH
12838: PPUSH
// if not unit or not building then
12839: LD_VAR 0 1
12843: NOT
12844: IFTRUE 12853
12846: PUSH
12847: LD_VAR 0 2
12851: NOT
12852: OR
12853: IFFALSE 12857
// exit ;
12855: GO 13015
// x := GetX ( building ) ;
12857: LD_ADDR_VAR 0 5
12861: PUSH
12862: LD_VAR 0 2
12866: PPUSH
12867: CALL_OW 250
12871: ST_TO_ADDR
// y := GetY ( building ) ;
12872: LD_ADDR_VAR 0 6
12876: PUSH
12877: LD_VAR 0 2
12881: PPUSH
12882: CALL_OW 251
12886: ST_TO_ADDR
// for i := 0 to 5 do
12887: LD_ADDR_VAR 0 4
12891: PUSH
12892: DOUBLE
12893: LD_INT 0
12895: DEC
12896: ST_TO_ADDR
12897: LD_INT 5
12899: PUSH
12900: FOR_TO
12901: IFFALSE 13013
// begin _x := ShiftX ( x , i , 3 ) ;
12903: LD_ADDR_VAR 0 7
12907: PUSH
12908: LD_VAR 0 5
12912: PPUSH
12913: LD_VAR 0 4
12917: PPUSH
12918: LD_INT 3
12920: PPUSH
12921: CALL_OW 272
12925: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
12926: LD_ADDR_VAR 0 8
12930: PUSH
12931: LD_VAR 0 6
12935: PPUSH
12936: LD_VAR 0 4
12940: PPUSH
12941: LD_INT 3
12943: PPUSH
12944: CALL_OW 273
12948: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
12949: LD_VAR 0 7
12953: PPUSH
12954: LD_VAR 0 8
12958: PPUSH
12959: CALL_OW 488
12963: NOT
12964: IFFALSE 12968
// continue ;
12966: GO 12900
// if HexInfo ( _x , _y ) = 0 then
12968: LD_VAR 0 7
12972: PPUSH
12973: LD_VAR 0 8
12977: PPUSH
12978: CALL_OW 428
12982: PUSH
12983: LD_INT 0
12985: EQUAL
12986: IFFALSE 13011
// begin ComMoveXY ( unit , _x , _y ) ;
12988: LD_VAR 0 1
12992: PPUSH
12993: LD_VAR 0 7
12997: PPUSH
12998: LD_VAR 0 8
13002: PPUSH
13003: CALL_OW 111
// exit ;
13007: POP
13008: POP
13009: GO 13015
// end ; end ;
13011: GO 12900
13013: POP
13014: POP
// end ;
13015: LD_VAR 0 3
13019: RET
// export function ScanBase ( side , base_area ) ; begin
13020: LD_INT 0
13022: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
13023: LD_ADDR_VAR 0 3
13027: PUSH
13028: LD_VAR 0 2
13032: PPUSH
13033: LD_INT 81
13035: PUSH
13036: LD_VAR 0 1
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 70
13049: ST_TO_ADDR
// end ;
13050: LD_VAR 0 3
13054: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
13055: LD_INT 0
13057: PPUSH
13058: PPUSH
13059: PPUSH
13060: PPUSH
// result := false ;
13061: LD_ADDR_VAR 0 2
13065: PUSH
13066: LD_INT 0
13068: ST_TO_ADDR
// side := GetSide ( unit ) ;
13069: LD_ADDR_VAR 0 3
13073: PUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 255
13083: ST_TO_ADDR
// nat := GetNation ( unit ) ;
13084: LD_ADDR_VAR 0 4
13088: PUSH
13089: LD_VAR 0 1
13093: PPUSH
13094: CALL_OW 248
13098: ST_TO_ADDR
// case nat of 1 :
13099: LD_VAR 0 4
13103: PUSH
13104: LD_INT 1
13106: DOUBLE
13107: EQUAL
13108: IFTRUE 13112
13110: GO 13123
13112: POP
// tech := tech_lassight ; 2 :
13113: LD_ADDR_VAR 0 5
13117: PUSH
13118: LD_INT 12
13120: ST_TO_ADDR
13121: GO 13162
13123: LD_INT 2
13125: DOUBLE
13126: EQUAL
13127: IFTRUE 13131
13129: GO 13142
13131: POP
// tech := tech_mortar ; 3 :
13132: LD_ADDR_VAR 0 5
13136: PUSH
13137: LD_INT 41
13139: ST_TO_ADDR
13140: GO 13162
13142: LD_INT 3
13144: DOUBLE
13145: EQUAL
13146: IFTRUE 13150
13148: GO 13161
13150: POP
// tech := tech_bazooka ; end ;
13151: LD_ADDR_VAR 0 5
13155: PUSH
13156: LD_INT 44
13158: ST_TO_ADDR
13159: GO 13162
13161: POP
// if Researched ( side , tech ) then
13162: LD_VAR 0 3
13166: PPUSH
13167: LD_VAR 0 5
13171: PPUSH
13172: CALL_OW 325
13176: IFFALSE 13203
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
13178: LD_ADDR_VAR 0 2
13182: PUSH
13183: LD_INT 5
13185: PUSH
13186: LD_INT 8
13188: PUSH
13189: LD_INT 9
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: LIST
13196: PUSH
13197: LD_VAR 0 4
13201: ARRAY
13202: ST_TO_ADDR
// end ;
13203: LD_VAR 0 2
13207: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
13208: LD_INT 0
13210: PPUSH
13211: PPUSH
13212: PPUSH
// if not mines then
13213: LD_VAR 0 2
13217: NOT
13218: IFFALSE 13222
// exit ;
13220: GO 13366
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
13222: LD_ADDR_VAR 0 5
13226: PUSH
13227: LD_INT 81
13229: PUSH
13230: LD_VAR 0 1
13234: PUSH
13235: EMPTY
13236: LIST
13237: LIST
13238: PUSH
13239: LD_INT 3
13241: PUSH
13242: LD_INT 21
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: EMPTY
13249: LIST
13250: LIST
13251: PUSH
13252: EMPTY
13253: LIST
13254: LIST
13255: PUSH
13256: EMPTY
13257: LIST
13258: LIST
13259: PPUSH
13260: CALL_OW 69
13264: ST_TO_ADDR
// for i in mines do
13265: LD_ADDR_VAR 0 4
13269: PUSH
13270: LD_VAR 0 2
13274: PUSH
13275: FOR_IN
13276: IFFALSE 13364
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
13278: LD_VAR 0 4
13282: PUSH
13283: LD_INT 1
13285: ARRAY
13286: PPUSH
13287: LD_VAR 0 4
13291: PUSH
13292: LD_INT 2
13294: ARRAY
13295: PPUSH
13296: CALL_OW 458
13300: NOT
13301: IFFALSE 13305
// continue ;
13303: GO 13275
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
13305: LD_VAR 0 4
13309: PUSH
13310: LD_INT 1
13312: ARRAY
13313: PPUSH
13314: LD_VAR 0 4
13318: PUSH
13319: LD_INT 2
13321: ARRAY
13322: PPUSH
13323: CALL_OW 428
13327: PUSH
13328: LD_VAR 0 5
13332: IN
13333: IFFALSE 13362
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
13335: LD_VAR 0 4
13339: PUSH
13340: LD_INT 1
13342: ARRAY
13343: PPUSH
13344: LD_VAR 0 4
13348: PUSH
13349: LD_INT 2
13351: ARRAY
13352: PPUSH
13353: LD_VAR 0 1
13357: PPUSH
13358: CALL_OW 456
// end ;
13362: GO 13275
13364: POP
13365: POP
// end ;
13366: LD_VAR 0 3
13370: RET
// export function Count ( array ) ; begin
13371: LD_INT 0
13373: PPUSH
// result := array + 0 ;
13374: LD_ADDR_VAR 0 2
13378: PUSH
13379: LD_VAR 0 1
13383: PUSH
13384: LD_INT 0
13386: PLUS
13387: ST_TO_ADDR
// end ;
13388: LD_VAR 0 2
13392: RET
// export function IsEmpty ( building ) ; begin
13393: LD_INT 0
13395: PPUSH
// if not building then
13396: LD_VAR 0 1
13400: NOT
13401: IFFALSE 13405
// exit ;
13403: GO 13448
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
13405: LD_ADDR_VAR 0 2
13409: PUSH
13410: LD_VAR 0 1
13414: PUSH
13415: LD_INT 22
13417: PUSH
13418: LD_VAR 0 1
13422: PPUSH
13423: CALL_OW 255
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: PUSH
13432: LD_INT 58
13434: PUSH
13435: EMPTY
13436: LIST
13437: PUSH
13438: EMPTY
13439: LIST
13440: LIST
13441: PPUSH
13442: CALL_OW 69
13446: IN
13447: ST_TO_ADDR
// end ;
13448: LD_VAR 0 2
13452: RET
// export function IsNotFull ( building ) ; var places ; begin
13453: LD_INT 0
13455: PPUSH
13456: PPUSH
// if not building then
13457: LD_VAR 0 1
13461: NOT
13462: IFFALSE 13466
// exit ;
13464: GO 13494
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
13466: LD_ADDR_VAR 0 2
13470: PUSH
13471: LD_VAR 0 1
13475: PPUSH
13476: LD_INT 3
13478: PUSH
13479: LD_INT 62
13481: PUSH
13482: EMPTY
13483: LIST
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PPUSH
13489: CALL_OW 72
13493: ST_TO_ADDR
// end ;
13494: LD_VAR 0 2
13498: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
13499: LD_INT 0
13501: PPUSH
13502: PPUSH
13503: PPUSH
13504: PPUSH
// tmp := [ ] ;
13505: LD_ADDR_VAR 0 3
13509: PUSH
13510: EMPTY
13511: ST_TO_ADDR
// list := [ ] ;
13512: LD_ADDR_VAR 0 5
13516: PUSH
13517: EMPTY
13518: ST_TO_ADDR
// for i = 16 to 25 do
13519: LD_ADDR_VAR 0 4
13523: PUSH
13524: DOUBLE
13525: LD_INT 16
13527: DEC
13528: ST_TO_ADDR
13529: LD_INT 25
13531: PUSH
13532: FOR_TO
13533: IFFALSE 13606
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
13535: LD_ADDR_VAR 0 3
13539: PUSH
13540: LD_VAR 0 3
13544: PUSH
13545: LD_INT 22
13547: PUSH
13548: LD_VAR 0 1
13552: PPUSH
13553: CALL_OW 255
13557: PUSH
13558: EMPTY
13559: LIST
13560: LIST
13561: PUSH
13562: LD_INT 91
13564: PUSH
13565: LD_VAR 0 1
13569: PUSH
13570: LD_INT 6
13572: PUSH
13573: EMPTY
13574: LIST
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 30
13580: PUSH
13581: LD_VAR 0 4
13585: PUSH
13586: EMPTY
13587: LIST
13588: LIST
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: LIST
13594: PUSH
13595: EMPTY
13596: LIST
13597: PPUSH
13598: CALL_OW 69
13602: ADD
13603: ST_TO_ADDR
13604: GO 13532
13606: POP
13607: POP
// for i = 1 to tmp do
13608: LD_ADDR_VAR 0 4
13612: PUSH
13613: DOUBLE
13614: LD_INT 1
13616: DEC
13617: ST_TO_ADDR
13618: LD_VAR 0 3
13622: PUSH
13623: FOR_TO
13624: IFFALSE 13712
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
13626: LD_ADDR_VAR 0 5
13630: PUSH
13631: LD_VAR 0 5
13635: PUSH
13636: LD_VAR 0 3
13640: PUSH
13641: LD_VAR 0 4
13645: ARRAY
13646: PPUSH
13647: CALL_OW 266
13651: PUSH
13652: LD_VAR 0 3
13656: PUSH
13657: LD_VAR 0 4
13661: ARRAY
13662: PPUSH
13663: CALL_OW 250
13667: PUSH
13668: LD_VAR 0 3
13672: PUSH
13673: LD_VAR 0 4
13677: ARRAY
13678: PPUSH
13679: CALL_OW 251
13683: PUSH
13684: LD_VAR 0 3
13688: PUSH
13689: LD_VAR 0 4
13693: ARRAY
13694: PPUSH
13695: CALL_OW 254
13699: PUSH
13700: EMPTY
13701: LIST
13702: LIST
13703: LIST
13704: LIST
13705: PUSH
13706: EMPTY
13707: LIST
13708: ADD
13709: ST_TO_ADDR
13710: GO 13623
13712: POP
13713: POP
// result := list ;
13714: LD_ADDR_VAR 0 2
13718: PUSH
13719: LD_VAR 0 5
13723: ST_TO_ADDR
// end ;
13724: LD_VAR 0 2
13728: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
13729: LD_INT 0
13731: PPUSH
13732: PPUSH
13733: PPUSH
13734: PPUSH
13735: PPUSH
13736: PPUSH
13737: PPUSH
// if not factory then
13738: LD_VAR 0 1
13742: NOT
13743: IFFALSE 13747
// exit ;
13745: GO 14350
// if control = control_apeman then
13747: LD_VAR 0 4
13751: PUSH
13752: LD_INT 5
13754: EQUAL
13755: IFFALSE 13864
// begin tmp := UnitsInside ( factory ) ;
13757: LD_ADDR_VAR 0 8
13761: PUSH
13762: LD_VAR 0 1
13766: PPUSH
13767: CALL_OW 313
13771: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
13772: LD_VAR 0 8
13776: PPUSH
13777: LD_INT 25
13779: PUSH
13780: LD_INT 12
13782: PUSH
13783: EMPTY
13784: LIST
13785: LIST
13786: PPUSH
13787: CALL_OW 72
13791: NOT
13792: IFFALSE 13802
// control := control_manual ;
13794: LD_ADDR_VAR 0 4
13798: PUSH
13799: LD_INT 1
13801: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
13802: LD_ADDR_VAR 0 8
13806: PUSH
13807: LD_VAR 0 1
13811: PPUSH
13812: CALL 13499 0 1
13816: ST_TO_ADDR
// if tmp then
13817: LD_VAR 0 8
13821: IFFALSE 13864
// begin for i in tmp do
13823: LD_ADDR_VAR 0 7
13827: PUSH
13828: LD_VAR 0 8
13832: PUSH
13833: FOR_IN
13834: IFFALSE 13862
// if i [ 1 ] = b_ext_radio then
13836: LD_VAR 0 7
13840: PUSH
13841: LD_INT 1
13843: ARRAY
13844: PUSH
13845: LD_INT 22
13847: EQUAL
13848: IFFALSE 13860
// begin control := control_remote ;
13850: LD_ADDR_VAR 0 4
13854: PUSH
13855: LD_INT 2
13857: ST_TO_ADDR
// break ;
13858: GO 13862
// end ;
13860: GO 13833
13862: POP
13863: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
13864: LD_VAR 0 1
13868: PPUSH
13869: LD_VAR 0 2
13873: PPUSH
13874: LD_VAR 0 3
13878: PPUSH
13879: LD_VAR 0 4
13883: PPUSH
13884: LD_VAR 0 5
13888: PPUSH
13889: CALL_OW 448
13893: IFFALSE 13928
// begin result := [ chassis , engine , control , weapon ] ;
13895: LD_ADDR_VAR 0 6
13899: PUSH
13900: LD_VAR 0 2
13904: PUSH
13905: LD_VAR 0 3
13909: PUSH
13910: LD_VAR 0 4
13914: PUSH
13915: LD_VAR 0 5
13919: PUSH
13920: EMPTY
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: ST_TO_ADDR
// exit ;
13926: GO 14350
// end ; _chassis := AvailableChassisList ( factory ) ;
13928: LD_ADDR_VAR 0 9
13932: PUSH
13933: LD_VAR 0 1
13937: PPUSH
13938: CALL_OW 475
13942: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
13943: LD_ADDR_VAR 0 11
13947: PUSH
13948: LD_VAR 0 1
13952: PPUSH
13953: CALL_OW 476
13957: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
13958: LD_ADDR_VAR 0 12
13962: PUSH
13963: LD_VAR 0 1
13967: PPUSH
13968: CALL_OW 477
13972: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
13973: LD_ADDR_VAR 0 10
13977: PUSH
13978: LD_VAR 0 1
13982: PPUSH
13983: CALL_OW 478
13987: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
13988: LD_VAR 0 9
13992: NOT
13993: IFTRUE 14002
13995: PUSH
13996: LD_VAR 0 11
14000: NOT
14001: OR
14002: IFTRUE 14011
14004: PUSH
14005: LD_VAR 0 12
14009: NOT
14010: OR
14011: IFTRUE 14020
14013: PUSH
14014: LD_VAR 0 10
14018: NOT
14019: OR
14020: IFFALSE 14055
// begin result := [ chassis , engine , control , weapon ] ;
14022: LD_ADDR_VAR 0 6
14026: PUSH
14027: LD_VAR 0 2
14031: PUSH
14032: LD_VAR 0 3
14036: PUSH
14037: LD_VAR 0 4
14041: PUSH
14042: LD_VAR 0 5
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: ST_TO_ADDR
// exit ;
14053: GO 14350
// end ; if not chassis in _chassis then
14055: LD_VAR 0 2
14059: PUSH
14060: LD_VAR 0 9
14064: IN
14065: NOT
14066: IFFALSE 14092
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
14068: LD_ADDR_VAR 0 2
14072: PUSH
14073: LD_VAR 0 9
14077: PUSH
14078: LD_INT 1
14080: PPUSH
14081: LD_VAR 0 9
14085: PPUSH
14086: CALL_OW 12
14090: ARRAY
14091: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
14092: LD_VAR 0 2
14096: PPUSH
14097: LD_VAR 0 3
14101: PPUSH
14102: CALL 14355 0 2
14106: NOT
14107: IFFALSE 14168
// repeat engine := _engine [ 1 ] ;
14109: LD_ADDR_VAR 0 3
14113: PUSH
14114: LD_VAR 0 11
14118: PUSH
14119: LD_INT 1
14121: ARRAY
14122: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
14123: LD_ADDR_VAR 0 11
14127: PUSH
14128: LD_VAR 0 11
14132: PPUSH
14133: LD_INT 1
14135: PPUSH
14136: CALL_OW 3
14140: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
14141: LD_VAR 0 2
14145: PPUSH
14146: LD_VAR 0 3
14150: PPUSH
14151: CALL 14355 0 2
14155: IFTRUE 14166
14157: PUSH
14158: LD_VAR 0 11
14162: PUSH
14163: EMPTY
14164: EQUAL
14165: OR
14166: IFFALSE 14109
// if not control in _control then
14168: LD_VAR 0 4
14172: PUSH
14173: LD_VAR 0 12
14177: IN
14178: NOT
14179: IFFALSE 14205
// control := _control [ rand ( 1 , _control ) ] ;
14181: LD_ADDR_VAR 0 4
14185: PUSH
14186: LD_VAR 0 12
14190: PUSH
14191: LD_INT 1
14193: PPUSH
14194: LD_VAR 0 12
14198: PPUSH
14199: CALL_OW 12
14203: ARRAY
14204: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
14205: LD_VAR 0 2
14209: PPUSH
14210: LD_VAR 0 5
14214: PPUSH
14215: CALL 14577 0 2
14219: NOT
14220: IFFALSE 14281
// repeat weapon := _weapon [ 1 ] ;
14222: LD_ADDR_VAR 0 5
14226: PUSH
14227: LD_VAR 0 10
14231: PUSH
14232: LD_INT 1
14234: ARRAY
14235: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
14236: LD_ADDR_VAR 0 10
14240: PUSH
14241: LD_VAR 0 10
14245: PPUSH
14246: LD_INT 1
14248: PPUSH
14249: CALL_OW 3
14253: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
14254: LD_VAR 0 2
14258: PPUSH
14259: LD_VAR 0 5
14263: PPUSH
14264: CALL 14577 0 2
14268: IFTRUE 14279
14270: PUSH
14271: LD_VAR 0 10
14275: PUSH
14276: EMPTY
14277: EQUAL
14278: OR
14279: IFFALSE 14222
// result := [ ] ;
14281: LD_ADDR_VAR 0 6
14285: PUSH
14286: EMPTY
14287: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
14288: LD_VAR 0 1
14292: PPUSH
14293: LD_VAR 0 2
14297: PPUSH
14298: LD_VAR 0 3
14302: PPUSH
14303: LD_VAR 0 4
14307: PPUSH
14308: LD_VAR 0 5
14312: PPUSH
14313: CALL_OW 448
14317: IFFALSE 14350
// result := [ chassis , engine , control , weapon ] ;
14319: LD_ADDR_VAR 0 6
14323: PUSH
14324: LD_VAR 0 2
14328: PUSH
14329: LD_VAR 0 3
14333: PUSH
14334: LD_VAR 0 4
14338: PUSH
14339: LD_VAR 0 5
14343: PUSH
14344: EMPTY
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 6
14354: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
14355: LD_INT 0
14357: PPUSH
// if not chassis or not engine then
14358: LD_VAR 0 1
14362: NOT
14363: IFTRUE 14372
14365: PUSH
14366: LD_VAR 0 2
14370: NOT
14371: OR
14372: IFFALSE 14376
// exit ;
14374: GO 14572
// case engine of engine_solar :
14376: LD_VAR 0 2
14380: PUSH
14381: LD_INT 2
14383: DOUBLE
14384: EQUAL
14385: IFTRUE 14389
14387: GO 14427
14389: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
14390: LD_ADDR_VAR 0 3
14394: PUSH
14395: LD_INT 11
14397: PUSH
14398: LD_INT 12
14400: PUSH
14401: LD_INT 13
14403: PUSH
14404: LD_INT 14
14406: PUSH
14407: LD_INT 1
14409: PUSH
14410: LD_INT 2
14412: PUSH
14413: LD_INT 3
14415: PUSH
14416: EMPTY
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: LIST
14424: ST_TO_ADDR
14425: GO 14556
14427: LD_INT 1
14429: DOUBLE
14430: EQUAL
14431: IFTRUE 14435
14433: GO 14497
14435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
14436: LD_ADDR_VAR 0 3
14440: PUSH
14441: LD_INT 11
14443: PUSH
14444: LD_INT 12
14446: PUSH
14447: LD_INT 13
14449: PUSH
14450: LD_INT 14
14452: PUSH
14453: LD_INT 1
14455: PUSH
14456: LD_INT 2
14458: PUSH
14459: LD_INT 3
14461: PUSH
14462: LD_INT 4
14464: PUSH
14465: LD_INT 5
14467: PUSH
14468: LD_INT 21
14470: PUSH
14471: LD_INT 23
14473: PUSH
14474: LD_INT 22
14476: PUSH
14477: LD_INT 24
14479: PUSH
14480: EMPTY
14481: LIST
14482: LIST
14483: LIST
14484: LIST
14485: LIST
14486: LIST
14487: LIST
14488: LIST
14489: LIST
14490: LIST
14491: LIST
14492: LIST
14493: LIST
14494: ST_TO_ADDR
14495: GO 14556
14497: LD_INT 3
14499: DOUBLE
14500: EQUAL
14501: IFTRUE 14505
14503: GO 14555
14505: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
14506: LD_ADDR_VAR 0 3
14510: PUSH
14511: LD_INT 13
14513: PUSH
14514: LD_INT 14
14516: PUSH
14517: LD_INT 2
14519: PUSH
14520: LD_INT 3
14522: PUSH
14523: LD_INT 4
14525: PUSH
14526: LD_INT 5
14528: PUSH
14529: LD_INT 21
14531: PUSH
14532: LD_INT 22
14534: PUSH
14535: LD_INT 23
14537: PUSH
14538: LD_INT 24
14540: PUSH
14541: EMPTY
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: ST_TO_ADDR
14553: GO 14556
14555: POP
// result := ( chassis in result ) ;
14556: LD_ADDR_VAR 0 3
14560: PUSH
14561: LD_VAR 0 1
14565: PUSH
14566: LD_VAR 0 3
14570: IN
14571: ST_TO_ADDR
// end ;
14572: LD_VAR 0 3
14576: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
14577: LD_INT 0
14579: PPUSH
// if not chassis or not weapon then
14580: LD_VAR 0 1
14584: NOT
14585: IFTRUE 14594
14587: PUSH
14588: LD_VAR 0 2
14592: NOT
14593: OR
14594: IFFALSE 14598
// exit ;
14596: GO 15658
// case weapon of us_machine_gun :
14598: LD_VAR 0 2
14602: PUSH
14603: LD_INT 2
14605: DOUBLE
14606: EQUAL
14607: IFTRUE 14611
14609: GO 14641
14611: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
14612: LD_ADDR_VAR 0 3
14616: PUSH
14617: LD_INT 1
14619: PUSH
14620: LD_INT 2
14622: PUSH
14623: LD_INT 3
14625: PUSH
14626: LD_INT 4
14628: PUSH
14629: LD_INT 5
14631: PUSH
14632: EMPTY
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: ST_TO_ADDR
14639: GO 15642
14641: LD_INT 3
14643: DOUBLE
14644: EQUAL
14645: IFTRUE 14649
14647: GO 14679
14649: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
14650: LD_ADDR_VAR 0 3
14654: PUSH
14655: LD_INT 1
14657: PUSH
14658: LD_INT 2
14660: PUSH
14661: LD_INT 3
14663: PUSH
14664: LD_INT 4
14666: PUSH
14667: LD_INT 5
14669: PUSH
14670: EMPTY
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: ST_TO_ADDR
14677: GO 15642
14679: LD_INT 11
14681: DOUBLE
14682: EQUAL
14683: IFTRUE 14687
14685: GO 14717
14687: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
14688: LD_ADDR_VAR 0 3
14692: PUSH
14693: LD_INT 1
14695: PUSH
14696: LD_INT 2
14698: PUSH
14699: LD_INT 3
14701: PUSH
14702: LD_INT 4
14704: PUSH
14705: LD_INT 5
14707: PUSH
14708: EMPTY
14709: LIST
14710: LIST
14711: LIST
14712: LIST
14713: LIST
14714: ST_TO_ADDR
14715: GO 15642
14717: LD_INT 4
14719: DOUBLE
14720: EQUAL
14721: IFTRUE 14725
14723: GO 14751
14725: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
14726: LD_ADDR_VAR 0 3
14730: PUSH
14731: LD_INT 2
14733: PUSH
14734: LD_INT 3
14736: PUSH
14737: LD_INT 4
14739: PUSH
14740: LD_INT 5
14742: PUSH
14743: EMPTY
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: ST_TO_ADDR
14749: GO 15642
14751: LD_INT 5
14753: DOUBLE
14754: EQUAL
14755: IFTRUE 14759
14757: GO 14785
14759: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
14760: LD_ADDR_VAR 0 3
14764: PUSH
14765: LD_INT 2
14767: PUSH
14768: LD_INT 3
14770: PUSH
14771: LD_INT 4
14773: PUSH
14774: LD_INT 5
14776: PUSH
14777: EMPTY
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: ST_TO_ADDR
14783: GO 15642
14785: LD_INT 9
14787: DOUBLE
14788: EQUAL
14789: IFTRUE 14793
14791: GO 14819
14793: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
14794: LD_ADDR_VAR 0 3
14798: PUSH
14799: LD_INT 2
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: LD_INT 4
14807: PUSH
14808: LD_INT 5
14810: PUSH
14811: EMPTY
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: ST_TO_ADDR
14817: GO 15642
14819: LD_INT 7
14821: DOUBLE
14822: EQUAL
14823: IFTRUE 14827
14825: GO 14853
14827: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
14828: LD_ADDR_VAR 0 3
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: LD_INT 3
14838: PUSH
14839: LD_INT 4
14841: PUSH
14842: LD_INT 5
14844: PUSH
14845: EMPTY
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: ST_TO_ADDR
14851: GO 15642
14853: LD_INT 12
14855: DOUBLE
14856: EQUAL
14857: IFTRUE 14861
14859: GO 14887
14861: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
14862: LD_ADDR_VAR 0 3
14866: PUSH
14867: LD_INT 2
14869: PUSH
14870: LD_INT 3
14872: PUSH
14873: LD_INT 4
14875: PUSH
14876: LD_INT 5
14878: PUSH
14879: EMPTY
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: ST_TO_ADDR
14885: GO 15642
14887: LD_INT 13
14889: DOUBLE
14890: EQUAL
14891: IFTRUE 14895
14893: GO 14921
14895: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
14896: LD_ADDR_VAR 0 3
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: LD_INT 3
14906: PUSH
14907: LD_INT 4
14909: PUSH
14910: LD_INT 5
14912: PUSH
14913: EMPTY
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: ST_TO_ADDR
14919: GO 15642
14921: LD_INT 14
14923: DOUBLE
14924: EQUAL
14925: IFTRUE 14929
14927: GO 14947
14929: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
14930: LD_ADDR_VAR 0 3
14934: PUSH
14935: LD_INT 4
14937: PUSH
14938: LD_INT 5
14940: PUSH
14941: EMPTY
14942: LIST
14943: LIST
14944: ST_TO_ADDR
14945: GO 15642
14947: LD_INT 6
14949: DOUBLE
14950: EQUAL
14951: IFTRUE 14955
14953: GO 14973
14955: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
14956: LD_ADDR_VAR 0 3
14960: PUSH
14961: LD_INT 4
14963: PUSH
14964: LD_INT 5
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: ST_TO_ADDR
14971: GO 15642
14973: LD_INT 10
14975: DOUBLE
14976: EQUAL
14977: IFTRUE 14981
14979: GO 14999
14981: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
14982: LD_ADDR_VAR 0 3
14986: PUSH
14987: LD_INT 4
14989: PUSH
14990: LD_INT 5
14992: PUSH
14993: EMPTY
14994: LIST
14995: LIST
14996: ST_TO_ADDR
14997: GO 15642
14999: LD_INT 22
15001: DOUBLE
15002: EQUAL
15003: IFTRUE 15007
15005: GO 15033
15007: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
15008: LD_ADDR_VAR 0 3
15012: PUSH
15013: LD_INT 11
15015: PUSH
15016: LD_INT 12
15018: PUSH
15019: LD_INT 13
15021: PUSH
15022: LD_INT 14
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: ST_TO_ADDR
15031: GO 15642
15033: LD_INT 23
15035: DOUBLE
15036: EQUAL
15037: IFTRUE 15041
15039: GO 15067
15041: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
15042: LD_ADDR_VAR 0 3
15046: PUSH
15047: LD_INT 11
15049: PUSH
15050: LD_INT 12
15052: PUSH
15053: LD_INT 13
15055: PUSH
15056: LD_INT 14
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: ST_TO_ADDR
15065: GO 15642
15067: LD_INT 24
15069: DOUBLE
15070: EQUAL
15071: IFTRUE 15075
15073: GO 15101
15075: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
15076: LD_ADDR_VAR 0 3
15080: PUSH
15081: LD_INT 11
15083: PUSH
15084: LD_INT 12
15086: PUSH
15087: LD_INT 13
15089: PUSH
15090: LD_INT 14
15092: PUSH
15093: EMPTY
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: ST_TO_ADDR
15099: GO 15642
15101: LD_INT 30
15103: DOUBLE
15104: EQUAL
15105: IFTRUE 15109
15107: GO 15135
15109: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
15110: LD_ADDR_VAR 0 3
15114: PUSH
15115: LD_INT 11
15117: PUSH
15118: LD_INT 12
15120: PUSH
15121: LD_INT 13
15123: PUSH
15124: LD_INT 14
15126: PUSH
15127: EMPTY
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: ST_TO_ADDR
15133: GO 15642
15135: LD_INT 25
15137: DOUBLE
15138: EQUAL
15139: IFTRUE 15143
15141: GO 15161
15143: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
15144: LD_ADDR_VAR 0 3
15148: PUSH
15149: LD_INT 13
15151: PUSH
15152: LD_INT 14
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: ST_TO_ADDR
15159: GO 15642
15161: LD_INT 27
15163: DOUBLE
15164: EQUAL
15165: IFTRUE 15169
15167: GO 15187
15169: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
15170: LD_ADDR_VAR 0 3
15174: PUSH
15175: LD_INT 13
15177: PUSH
15178: LD_INT 14
15180: PUSH
15181: EMPTY
15182: LIST
15183: LIST
15184: ST_TO_ADDR
15185: GO 15642
15187: LD_INT 92
15189: DOUBLE
15190: EQUAL
15191: IFTRUE 15195
15193: GO 15221
15195: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
15196: LD_ADDR_VAR 0 3
15200: PUSH
15201: LD_INT 11
15203: PUSH
15204: LD_INT 12
15206: PUSH
15207: LD_INT 13
15209: PUSH
15210: LD_INT 14
15212: PUSH
15213: EMPTY
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: ST_TO_ADDR
15219: GO 15642
15221: LD_INT 28
15223: DOUBLE
15224: EQUAL
15225: IFTRUE 15229
15227: GO 15247
15229: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
15230: LD_ADDR_VAR 0 3
15234: PUSH
15235: LD_INT 13
15237: PUSH
15238: LD_INT 14
15240: PUSH
15241: EMPTY
15242: LIST
15243: LIST
15244: ST_TO_ADDR
15245: GO 15642
15247: LD_INT 29
15249: DOUBLE
15250: EQUAL
15251: IFTRUE 15255
15253: GO 15273
15255: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
15256: LD_ADDR_VAR 0 3
15260: PUSH
15261: LD_INT 13
15263: PUSH
15264: LD_INT 14
15266: PUSH
15267: EMPTY
15268: LIST
15269: LIST
15270: ST_TO_ADDR
15271: GO 15642
15273: LD_INT 31
15275: DOUBLE
15276: EQUAL
15277: IFTRUE 15281
15279: GO 15299
15281: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
15282: LD_ADDR_VAR 0 3
15286: PUSH
15287: LD_INT 13
15289: PUSH
15290: LD_INT 14
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: ST_TO_ADDR
15297: GO 15642
15299: LD_INT 26
15301: DOUBLE
15302: EQUAL
15303: IFTRUE 15307
15305: GO 15325
15307: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
15308: LD_ADDR_VAR 0 3
15312: PUSH
15313: LD_INT 13
15315: PUSH
15316: LD_INT 14
15318: PUSH
15319: EMPTY
15320: LIST
15321: LIST
15322: ST_TO_ADDR
15323: GO 15642
15325: LD_INT 42
15327: DOUBLE
15328: EQUAL
15329: IFTRUE 15333
15331: GO 15359
15333: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
15334: LD_ADDR_VAR 0 3
15338: PUSH
15339: LD_INT 21
15341: PUSH
15342: LD_INT 22
15344: PUSH
15345: LD_INT 23
15347: PUSH
15348: LD_INT 24
15350: PUSH
15351: EMPTY
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: ST_TO_ADDR
15357: GO 15642
15359: LD_INT 43
15361: DOUBLE
15362: EQUAL
15363: IFTRUE 15367
15365: GO 15393
15367: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
15368: LD_ADDR_VAR 0 3
15372: PUSH
15373: LD_INT 21
15375: PUSH
15376: LD_INT 22
15378: PUSH
15379: LD_INT 23
15381: PUSH
15382: LD_INT 24
15384: PUSH
15385: EMPTY
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: ST_TO_ADDR
15391: GO 15642
15393: LD_INT 44
15395: DOUBLE
15396: EQUAL
15397: IFTRUE 15401
15399: GO 15427
15401: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
15402: LD_ADDR_VAR 0 3
15406: PUSH
15407: LD_INT 21
15409: PUSH
15410: LD_INT 22
15412: PUSH
15413: LD_INT 23
15415: PUSH
15416: LD_INT 24
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: LIST
15423: LIST
15424: ST_TO_ADDR
15425: GO 15642
15427: LD_INT 45
15429: DOUBLE
15430: EQUAL
15431: IFTRUE 15435
15433: GO 15461
15435: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
15436: LD_ADDR_VAR 0 3
15440: PUSH
15441: LD_INT 21
15443: PUSH
15444: LD_INT 22
15446: PUSH
15447: LD_INT 23
15449: PUSH
15450: LD_INT 24
15452: PUSH
15453: EMPTY
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: ST_TO_ADDR
15459: GO 15642
15461: LD_INT 49
15463: DOUBLE
15464: EQUAL
15465: IFTRUE 15469
15467: GO 15495
15469: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
15470: LD_ADDR_VAR 0 3
15474: PUSH
15475: LD_INT 21
15477: PUSH
15478: LD_INT 22
15480: PUSH
15481: LD_INT 23
15483: PUSH
15484: LD_INT 24
15486: PUSH
15487: EMPTY
15488: LIST
15489: LIST
15490: LIST
15491: LIST
15492: ST_TO_ADDR
15493: GO 15642
15495: LD_INT 51
15497: DOUBLE
15498: EQUAL
15499: IFTRUE 15503
15501: GO 15529
15503: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
15504: LD_ADDR_VAR 0 3
15508: PUSH
15509: LD_INT 21
15511: PUSH
15512: LD_INT 22
15514: PUSH
15515: LD_INT 23
15517: PUSH
15518: LD_INT 24
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: ST_TO_ADDR
15527: GO 15642
15529: LD_INT 52
15531: DOUBLE
15532: EQUAL
15533: IFTRUE 15537
15535: GO 15563
15537: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
15538: LD_ADDR_VAR 0 3
15542: PUSH
15543: LD_INT 21
15545: PUSH
15546: LD_INT 22
15548: PUSH
15549: LD_INT 23
15551: PUSH
15552: LD_INT 24
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: ST_TO_ADDR
15561: GO 15642
15563: LD_INT 53
15565: DOUBLE
15566: EQUAL
15567: IFTRUE 15571
15569: GO 15589
15571: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
15572: LD_ADDR_VAR 0 3
15576: PUSH
15577: LD_INT 23
15579: PUSH
15580: LD_INT 24
15582: PUSH
15583: EMPTY
15584: LIST
15585: LIST
15586: ST_TO_ADDR
15587: GO 15642
15589: LD_INT 46
15591: DOUBLE
15592: EQUAL
15593: IFTRUE 15597
15595: GO 15615
15597: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
15598: LD_ADDR_VAR 0 3
15602: PUSH
15603: LD_INT 23
15605: PUSH
15606: LD_INT 24
15608: PUSH
15609: EMPTY
15610: LIST
15611: LIST
15612: ST_TO_ADDR
15613: GO 15642
15615: LD_INT 47
15617: DOUBLE
15618: EQUAL
15619: IFTRUE 15623
15621: GO 15641
15623: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
15624: LD_ADDR_VAR 0 3
15628: PUSH
15629: LD_INT 23
15631: PUSH
15632: LD_INT 24
15634: PUSH
15635: EMPTY
15636: LIST
15637: LIST
15638: ST_TO_ADDR
15639: GO 15642
15641: POP
// result := ( chassis in result ) ;
15642: LD_ADDR_VAR 0 3
15646: PUSH
15647: LD_VAR 0 1
15651: PUSH
15652: LD_VAR 0 3
15656: IN
15657: ST_TO_ADDR
// end ;
15658: LD_VAR 0 3
15662: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
15663: LD_INT 0
15665: PPUSH
15666: PPUSH
15667: PPUSH
15668: PPUSH
15669: PPUSH
15670: PPUSH
15671: PPUSH
// result := array ;
15672: LD_ADDR_VAR 0 5
15676: PUSH
15677: LD_VAR 0 1
15681: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
15682: LD_VAR 0 1
15686: NOT
15687: IFTRUE 15696
15689: PUSH
15690: LD_VAR 0 2
15694: NOT
15695: OR
15696: IFTRUE 15705
15698: PUSH
15699: LD_VAR 0 3
15703: NOT
15704: OR
15705: IFTRUE 15719
15707: PUSH
15708: LD_VAR 0 2
15712: PUSH
15713: LD_VAR 0 1
15717: GREATER
15718: OR
15719: IFTRUE 15733
15721: PUSH
15722: LD_VAR 0 3
15726: PUSH
15727: LD_VAR 0 1
15731: GREATER
15732: OR
15733: IFFALSE 15737
// exit ;
15735: GO 16033
// if direction then
15737: LD_VAR 0 4
15741: IFFALSE 15805
// begin d := 1 ;
15743: LD_ADDR_VAR 0 9
15747: PUSH
15748: LD_INT 1
15750: ST_TO_ADDR
// if i_from > i_to then
15751: LD_VAR 0 2
15755: PUSH
15756: LD_VAR 0 3
15760: GREATER
15761: IFFALSE 15787
// length := ( array - i_from ) + i_to else
15763: LD_ADDR_VAR 0 11
15767: PUSH
15768: LD_VAR 0 1
15772: PUSH
15773: LD_VAR 0 2
15777: MINUS
15778: PUSH
15779: LD_VAR 0 3
15783: PLUS
15784: ST_TO_ADDR
15785: GO 15803
// length := i_to - i_from ;
15787: LD_ADDR_VAR 0 11
15791: PUSH
15792: LD_VAR 0 3
15796: PUSH
15797: LD_VAR 0 2
15801: MINUS
15802: ST_TO_ADDR
// end else
15803: GO 15866
// begin d := - 1 ;
15805: LD_ADDR_VAR 0 9
15809: PUSH
15810: LD_INT 1
15812: NEG
15813: ST_TO_ADDR
// if i_from > i_to then
15814: LD_VAR 0 2
15818: PUSH
15819: LD_VAR 0 3
15823: GREATER
15824: IFFALSE 15844
// length := i_from - i_to else
15826: LD_ADDR_VAR 0 11
15830: PUSH
15831: LD_VAR 0 2
15835: PUSH
15836: LD_VAR 0 3
15840: MINUS
15841: ST_TO_ADDR
15842: GO 15866
// length := ( array - i_to ) + i_from ;
15844: LD_ADDR_VAR 0 11
15848: PUSH
15849: LD_VAR 0 1
15853: PUSH
15854: LD_VAR 0 3
15858: MINUS
15859: PUSH
15860: LD_VAR 0 2
15864: PLUS
15865: ST_TO_ADDR
// end ; if not length then
15866: LD_VAR 0 11
15870: NOT
15871: IFFALSE 15875
// exit ;
15873: GO 16033
// tmp := array ;
15875: LD_ADDR_VAR 0 10
15879: PUSH
15880: LD_VAR 0 1
15884: ST_TO_ADDR
// for i = 1 to length do
15885: LD_ADDR_VAR 0 6
15889: PUSH
15890: DOUBLE
15891: LD_INT 1
15893: DEC
15894: ST_TO_ADDR
15895: LD_VAR 0 11
15899: PUSH
15900: FOR_TO
15901: IFFALSE 16021
// begin for j = 1 to array do
15903: LD_ADDR_VAR 0 7
15907: PUSH
15908: DOUBLE
15909: LD_INT 1
15911: DEC
15912: ST_TO_ADDR
15913: LD_VAR 0 1
15917: PUSH
15918: FOR_TO
15919: IFFALSE 16007
// begin k := j + d ;
15921: LD_ADDR_VAR 0 8
15925: PUSH
15926: LD_VAR 0 7
15930: PUSH
15931: LD_VAR 0 9
15935: PLUS
15936: ST_TO_ADDR
// if k > array then
15937: LD_VAR 0 8
15941: PUSH
15942: LD_VAR 0 1
15946: GREATER
15947: IFFALSE 15957
// k := 1 ;
15949: LD_ADDR_VAR 0 8
15953: PUSH
15954: LD_INT 1
15956: ST_TO_ADDR
// if not k then
15957: LD_VAR 0 8
15961: NOT
15962: IFFALSE 15974
// k := array ;
15964: LD_ADDR_VAR 0 8
15968: PUSH
15969: LD_VAR 0 1
15973: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
15974: LD_ADDR_VAR 0 10
15978: PUSH
15979: LD_VAR 0 10
15983: PPUSH
15984: LD_VAR 0 8
15988: PPUSH
15989: LD_VAR 0 1
15993: PUSH
15994: LD_VAR 0 7
15998: ARRAY
15999: PPUSH
16000: CALL_OW 1
16004: ST_TO_ADDR
// end ;
16005: GO 15918
16007: POP
16008: POP
// array := tmp ;
16009: LD_ADDR_VAR 0 1
16013: PUSH
16014: LD_VAR 0 10
16018: ST_TO_ADDR
// end ;
16019: GO 15900
16021: POP
16022: POP
// result := array ;
16023: LD_ADDR_VAR 0 5
16027: PUSH
16028: LD_VAR 0 1
16032: ST_TO_ADDR
// end ;
16033: LD_VAR 0 5
16037: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
16038: LD_INT 0
16040: PPUSH
16041: PPUSH
// result := 0 ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_INT 0
16049: ST_TO_ADDR
// if not array or not value in array then
16050: LD_VAR 0 1
16054: NOT
16055: IFTRUE 16070
16057: PUSH
16058: LD_VAR 0 2
16062: PUSH
16063: LD_VAR 0 1
16067: IN
16068: NOT
16069: OR
16070: IFFALSE 16074
// exit ;
16072: GO 16128
// for i = 1 to array do
16074: LD_ADDR_VAR 0 4
16078: PUSH
16079: DOUBLE
16080: LD_INT 1
16082: DEC
16083: ST_TO_ADDR
16084: LD_VAR 0 1
16088: PUSH
16089: FOR_TO
16090: IFFALSE 16126
// if value = array [ i ] then
16092: LD_VAR 0 2
16096: PUSH
16097: LD_VAR 0 1
16101: PUSH
16102: LD_VAR 0 4
16106: ARRAY
16107: EQUAL
16108: IFFALSE 16124
// begin result := i ;
16110: LD_ADDR_VAR 0 3
16114: PUSH
16115: LD_VAR 0 4
16119: ST_TO_ADDR
// exit ;
16120: POP
16121: POP
16122: GO 16128
// end ;
16124: GO 16089
16126: POP
16127: POP
// end ;
16128: LD_VAR 0 3
16132: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
16133: LD_INT 0
16135: PPUSH
// vc_chassis := chassis ;
16136: LD_ADDR_OWVAR 37
16140: PUSH
16141: LD_VAR 0 1
16145: ST_TO_ADDR
// vc_engine := engine ;
16146: LD_ADDR_OWVAR 39
16150: PUSH
16151: LD_VAR 0 2
16155: ST_TO_ADDR
// vc_control := control ;
16156: LD_ADDR_OWVAR 38
16160: PUSH
16161: LD_VAR 0 3
16165: ST_TO_ADDR
// vc_weapon := weapon ;
16166: LD_ADDR_OWVAR 40
16170: PUSH
16171: LD_VAR 0 4
16175: ST_TO_ADDR
// vc_fuel_battery := fuel ;
16176: LD_ADDR_OWVAR 41
16180: PUSH
16181: LD_VAR 0 5
16185: ST_TO_ADDR
// end ;
16186: LD_VAR 0 6
16190: RET
// export function WantPlant ( unit ) ; var task ; begin
16191: LD_INT 0
16193: PPUSH
16194: PPUSH
// result := false ;
16195: LD_ADDR_VAR 0 2
16199: PUSH
16200: LD_INT 0
16202: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
16203: LD_ADDR_VAR 0 3
16207: PUSH
16208: LD_VAR 0 1
16212: PPUSH
16213: CALL_OW 437
16217: ST_TO_ADDR
// if task then
16218: LD_VAR 0 3
16222: IFFALSE 16250
// if task [ 1 ] [ 1 ] = p then
16224: LD_VAR 0 3
16228: PUSH
16229: LD_INT 1
16231: ARRAY
16232: PUSH
16233: LD_INT 1
16235: ARRAY
16236: PUSH
16237: LD_STRING p
16239: EQUAL
16240: IFFALSE 16250
// result := true ;
16242: LD_ADDR_VAR 0 2
16246: PUSH
16247: LD_INT 1
16249: ST_TO_ADDR
// end ;
16250: LD_VAR 0 2
16254: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
16255: LD_INT 0
16257: PPUSH
16258: PPUSH
16259: PPUSH
16260: PPUSH
// if pos < 1 then
16261: LD_VAR 0 2
16265: PUSH
16266: LD_INT 1
16268: LESS
16269: IFFALSE 16273
// exit ;
16271: GO 16576
// if pos = 1 then
16273: LD_VAR 0 2
16277: PUSH
16278: LD_INT 1
16280: EQUAL
16281: IFFALSE 16314
// result := Replace ( arr , pos [ 1 ] , value ) else
16283: LD_ADDR_VAR 0 4
16287: PUSH
16288: LD_VAR 0 1
16292: PPUSH
16293: LD_VAR 0 2
16297: PUSH
16298: LD_INT 1
16300: ARRAY
16301: PPUSH
16302: LD_VAR 0 3
16306: PPUSH
16307: CALL_OW 1
16311: ST_TO_ADDR
16312: GO 16576
// begin tmp := arr ;
16314: LD_ADDR_VAR 0 6
16318: PUSH
16319: LD_VAR 0 1
16323: ST_TO_ADDR
// s_arr := [ tmp ] ;
16324: LD_ADDR_VAR 0 7
16328: PUSH
16329: LD_VAR 0 6
16333: PUSH
16334: EMPTY
16335: LIST
16336: ST_TO_ADDR
// for i = 1 to pos - 1 do
16337: LD_ADDR_VAR 0 5
16341: PUSH
16342: DOUBLE
16343: LD_INT 1
16345: DEC
16346: ST_TO_ADDR
16347: LD_VAR 0 2
16351: PUSH
16352: LD_INT 1
16354: MINUS
16355: PUSH
16356: FOR_TO
16357: IFFALSE 16402
// begin tmp := tmp [ pos [ i ] ] ;
16359: LD_ADDR_VAR 0 6
16363: PUSH
16364: LD_VAR 0 6
16368: PUSH
16369: LD_VAR 0 2
16373: PUSH
16374: LD_VAR 0 5
16378: ARRAY
16379: ARRAY
16380: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
16381: LD_ADDR_VAR 0 7
16385: PUSH
16386: LD_VAR 0 7
16390: PUSH
16391: LD_VAR 0 6
16395: PUSH
16396: EMPTY
16397: LIST
16398: ADD
16399: ST_TO_ADDR
// end ;
16400: GO 16356
16402: POP
16403: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
16404: LD_ADDR_VAR 0 6
16408: PUSH
16409: LD_VAR 0 6
16413: PPUSH
16414: LD_VAR 0 2
16418: PUSH
16419: LD_VAR 0 2
16423: ARRAY
16424: PPUSH
16425: LD_VAR 0 3
16429: PPUSH
16430: CALL_OW 1
16434: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
16435: LD_ADDR_VAR 0 7
16439: PUSH
16440: LD_VAR 0 7
16444: PPUSH
16445: LD_VAR 0 7
16449: PPUSH
16450: LD_VAR 0 6
16454: PPUSH
16455: CALL_OW 1
16459: ST_TO_ADDR
// for i = s_arr downto 2 do
16460: LD_ADDR_VAR 0 5
16464: PUSH
16465: DOUBLE
16466: LD_VAR 0 7
16470: INC
16471: ST_TO_ADDR
16472: LD_INT 2
16474: PUSH
16475: FOR_DOWNTO
16476: IFFALSE 16560
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
16478: LD_ADDR_VAR 0 6
16482: PUSH
16483: LD_VAR 0 7
16487: PUSH
16488: LD_VAR 0 5
16492: PUSH
16493: LD_INT 1
16495: MINUS
16496: ARRAY
16497: PPUSH
16498: LD_VAR 0 2
16502: PUSH
16503: LD_VAR 0 5
16507: PUSH
16508: LD_INT 1
16510: MINUS
16511: ARRAY
16512: PPUSH
16513: LD_VAR 0 7
16517: PUSH
16518: LD_VAR 0 5
16522: ARRAY
16523: PPUSH
16524: CALL_OW 1
16528: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
16529: LD_ADDR_VAR 0 7
16533: PUSH
16534: LD_VAR 0 7
16538: PPUSH
16539: LD_VAR 0 5
16543: PUSH
16544: LD_INT 1
16546: MINUS
16547: PPUSH
16548: LD_VAR 0 6
16552: PPUSH
16553: CALL_OW 1
16557: ST_TO_ADDR
// end ;
16558: GO 16475
16560: POP
16561: POP
// result := s_arr [ 1 ] ;
16562: LD_ADDR_VAR 0 4
16566: PUSH
16567: LD_VAR 0 7
16571: PUSH
16572: LD_INT 1
16574: ARRAY
16575: ST_TO_ADDR
// end ; end ;
16576: LD_VAR 0 4
16580: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
16581: LD_INT 0
16583: PPUSH
16584: PPUSH
// if not list then
16585: LD_VAR 0 1
16589: NOT
16590: IFFALSE 16594
// exit ;
16592: GO 16685
// i := list [ pos1 ] ;
16594: LD_ADDR_VAR 0 5
16598: PUSH
16599: LD_VAR 0 1
16603: PUSH
16604: LD_VAR 0 2
16608: ARRAY
16609: ST_TO_ADDR
// if not i then
16610: LD_VAR 0 5
16614: NOT
16615: IFFALSE 16619
// exit ;
16617: GO 16685
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
16619: LD_ADDR_VAR 0 1
16623: PUSH
16624: LD_VAR 0 1
16628: PPUSH
16629: LD_VAR 0 2
16633: PPUSH
16634: LD_VAR 0 1
16638: PUSH
16639: LD_VAR 0 3
16643: ARRAY
16644: PPUSH
16645: CALL_OW 1
16649: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
16650: LD_ADDR_VAR 0 1
16654: PUSH
16655: LD_VAR 0 1
16659: PPUSH
16660: LD_VAR 0 3
16664: PPUSH
16665: LD_VAR 0 5
16669: PPUSH
16670: CALL_OW 1
16674: ST_TO_ADDR
// result := list ;
16675: LD_ADDR_VAR 0 4
16679: PUSH
16680: LD_VAR 0 1
16684: ST_TO_ADDR
// end ;
16685: LD_VAR 0 4
16689: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
16690: LD_INT 0
16692: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
16693: LD_ADDR_VAR 0 5
16697: PUSH
16698: LD_VAR 0 1
16702: PPUSH
16703: CALL_OW 250
16707: PPUSH
16708: LD_VAR 0 1
16712: PPUSH
16713: CALL_OW 251
16717: PPUSH
16718: LD_VAR 0 2
16722: PPUSH
16723: LD_VAR 0 3
16727: PPUSH
16728: LD_VAR 0 4
16732: PPUSH
16733: CALL 17115 0 5
16737: ST_TO_ADDR
// end ;
16738: LD_VAR 0 5
16742: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
16743: LD_INT 0
16745: PPUSH
16746: PPUSH
16747: PPUSH
16748: PPUSH
// if not list or not unit then
16749: LD_VAR 0 2
16753: NOT
16754: IFTRUE 16763
16756: PUSH
16757: LD_VAR 0 1
16761: NOT
16762: OR
16763: IFFALSE 16767
// exit ;
16765: GO 17110
// result := [ ] ;
16767: LD_ADDR_VAR 0 5
16771: PUSH
16772: EMPTY
16773: ST_TO_ADDR
// for i in list do
16774: LD_ADDR_VAR 0 6
16778: PUSH
16779: LD_VAR 0 2
16783: PUSH
16784: FOR_IN
16785: IFFALSE 17003
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
16787: LD_ADDR_VAR 0 8
16791: PUSH
16792: LD_VAR 0 1
16796: PPUSH
16797: LD_VAR 0 6
16801: PUSH
16802: LD_INT 1
16804: ARRAY
16805: PPUSH
16806: LD_VAR 0 6
16810: PUSH
16811: LD_INT 2
16813: ARRAY
16814: PPUSH
16815: CALL_OW 297
16819: ST_TO_ADDR
// if not Count ( result ) then
16820: LD_VAR 0 5
16824: PPUSH
16825: CALL 13371 0 1
16829: NOT
16830: IFFALSE 16863
// begin result := Join ( result , [ i , tmp ] ) ;
16832: LD_ADDR_VAR 0 5
16836: PUSH
16837: LD_VAR 0 5
16841: PPUSH
16842: LD_VAR 0 6
16846: PUSH
16847: LD_VAR 0 8
16851: PUSH
16852: EMPTY
16853: LIST
16854: LIST
16855: PPUSH
16856: CALL 49303 0 2
16860: ST_TO_ADDR
// continue ;
16861: GO 16784
// end ; if result [ result ] [ 2 ] <= tmp then
16863: LD_VAR 0 5
16867: PUSH
16868: LD_VAR 0 5
16872: ARRAY
16873: PUSH
16874: LD_INT 2
16876: ARRAY
16877: PUSH
16878: LD_VAR 0 8
16882: LESSEQUAL
16883: IFFALSE 16916
// result := Join ( result , [ i , tmp ] ) else
16885: LD_ADDR_VAR 0 5
16889: PUSH
16890: LD_VAR 0 5
16894: PPUSH
16895: LD_VAR 0 6
16899: PUSH
16900: LD_VAR 0 8
16904: PUSH
16905: EMPTY
16906: LIST
16907: LIST
16908: PPUSH
16909: CALL 49303 0 2
16913: ST_TO_ADDR
16914: GO 17001
// begin for j := 1 to Count ( result ) do
16916: LD_ADDR_VAR 0 7
16920: PUSH
16921: DOUBLE
16922: LD_INT 1
16924: DEC
16925: ST_TO_ADDR
16926: LD_VAR 0 5
16930: PPUSH
16931: CALL 13371 0 1
16935: PUSH
16936: FOR_TO
16937: IFFALSE 16999
// begin if tmp < result [ j ] [ 2 ] then
16939: LD_VAR 0 8
16943: PUSH
16944: LD_VAR 0 5
16948: PUSH
16949: LD_VAR 0 7
16953: ARRAY
16954: PUSH
16955: LD_INT 2
16957: ARRAY
16958: LESS
16959: IFFALSE 16997
// begin result := Insert ( result , j , [ i , tmp ] ) ;
16961: LD_ADDR_VAR 0 5
16965: PUSH
16966: LD_VAR 0 5
16970: PPUSH
16971: LD_VAR 0 7
16975: PPUSH
16976: LD_VAR 0 6
16980: PUSH
16981: LD_VAR 0 8
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: PPUSH
16990: CALL_OW 2
16994: ST_TO_ADDR
// break ;
16995: GO 16999
// end ; end ;
16997: GO 16936
16999: POP
17000: POP
// end ; end ;
17001: GO 16784
17003: POP
17004: POP
// if result and not asc then
17005: LD_VAR 0 5
17009: IFFALSE 17018
17011: PUSH
17012: LD_VAR 0 3
17016: NOT
17017: AND
17018: IFFALSE 17035
// result := ReverseArray ( result ) ;
17020: LD_ADDR_VAR 0 5
17024: PUSH
17025: LD_VAR 0 5
17029: PPUSH
17030: CALL 44393 0 1
17034: ST_TO_ADDR
// tmp := [ ] ;
17035: LD_ADDR_VAR 0 8
17039: PUSH
17040: EMPTY
17041: ST_TO_ADDR
// if mode then
17042: LD_VAR 0 4
17046: IFFALSE 17110
// begin for i := 1 to result do
17048: LD_ADDR_VAR 0 6
17052: PUSH
17053: DOUBLE
17054: LD_INT 1
17056: DEC
17057: ST_TO_ADDR
17058: LD_VAR 0 5
17062: PUSH
17063: FOR_TO
17064: IFFALSE 17098
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
17066: LD_ADDR_VAR 0 8
17070: PUSH
17071: LD_VAR 0 8
17075: PPUSH
17076: LD_VAR 0 5
17080: PUSH
17081: LD_VAR 0 6
17085: ARRAY
17086: PUSH
17087: LD_INT 1
17089: ARRAY
17090: PPUSH
17091: CALL 49303 0 2
17095: ST_TO_ADDR
17096: GO 17063
17098: POP
17099: POP
// result := tmp ;
17100: LD_ADDR_VAR 0 5
17104: PUSH
17105: LD_VAR 0 8
17109: ST_TO_ADDR
// end ; end ;
17110: LD_VAR 0 5
17114: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
17115: LD_INT 0
17117: PPUSH
17118: PPUSH
17119: PPUSH
17120: PPUSH
// if not list then
17121: LD_VAR 0 3
17125: NOT
17126: IFFALSE 17130
// exit ;
17128: GO 17520
// result := [ ] ;
17130: LD_ADDR_VAR 0 6
17134: PUSH
17135: EMPTY
17136: ST_TO_ADDR
// for i in list do
17137: LD_ADDR_VAR 0 7
17141: PUSH
17142: LD_VAR 0 3
17146: PUSH
17147: FOR_IN
17148: IFFALSE 17350
// begin tmp := GetDistUnitXY ( i , x , y ) ;
17150: LD_ADDR_VAR 0 9
17154: PUSH
17155: LD_VAR 0 7
17159: PPUSH
17160: LD_VAR 0 1
17164: PPUSH
17165: LD_VAR 0 2
17169: PPUSH
17170: CALL_OW 297
17174: ST_TO_ADDR
// if not result then
17175: LD_VAR 0 6
17179: NOT
17180: IFFALSE 17206
// result := [ [ i , tmp ] ] else
17182: LD_ADDR_VAR 0 6
17186: PUSH
17187: LD_VAR 0 7
17191: PUSH
17192: LD_VAR 0 9
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: EMPTY
17202: LIST
17203: ST_TO_ADDR
17204: GO 17348
// begin if result [ result ] [ 2 ] <= tmp then
17206: LD_VAR 0 6
17210: PUSH
17211: LD_VAR 0 6
17215: ARRAY
17216: PUSH
17217: LD_INT 2
17219: ARRAY
17220: PUSH
17221: LD_VAR 0 9
17225: LESSEQUAL
17226: IFFALSE 17268
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
17228: LD_ADDR_VAR 0 6
17232: PUSH
17233: LD_VAR 0 6
17237: PPUSH
17238: LD_VAR 0 6
17242: PUSH
17243: LD_INT 1
17245: PLUS
17246: PPUSH
17247: LD_VAR 0 7
17251: PUSH
17252: LD_VAR 0 9
17256: PUSH
17257: EMPTY
17258: LIST
17259: LIST
17260: PPUSH
17261: CALL_OW 2
17265: ST_TO_ADDR
17266: GO 17348
// for j := 1 to result do
17268: LD_ADDR_VAR 0 8
17272: PUSH
17273: DOUBLE
17274: LD_INT 1
17276: DEC
17277: ST_TO_ADDR
17278: LD_VAR 0 6
17282: PUSH
17283: FOR_TO
17284: IFFALSE 17346
// begin if tmp < result [ j ] [ 2 ] then
17286: LD_VAR 0 9
17290: PUSH
17291: LD_VAR 0 6
17295: PUSH
17296: LD_VAR 0 8
17300: ARRAY
17301: PUSH
17302: LD_INT 2
17304: ARRAY
17305: LESS
17306: IFFALSE 17344
// begin result := Insert ( result , j , [ i , tmp ] ) ;
17308: LD_ADDR_VAR 0 6
17312: PUSH
17313: LD_VAR 0 6
17317: PPUSH
17318: LD_VAR 0 8
17322: PPUSH
17323: LD_VAR 0 7
17327: PUSH
17328: LD_VAR 0 9
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: PPUSH
17337: CALL_OW 2
17341: ST_TO_ADDR
// break ;
17342: GO 17346
// end ; end ;
17344: GO 17283
17346: POP
17347: POP
// end ; end ;
17348: GO 17147
17350: POP
17351: POP
// if result and not asc then
17352: LD_VAR 0 6
17356: IFFALSE 17365
17358: PUSH
17359: LD_VAR 0 4
17363: NOT
17364: AND
17365: IFFALSE 17440
// begin tmp := result ;
17367: LD_ADDR_VAR 0 9
17371: PUSH
17372: LD_VAR 0 6
17376: ST_TO_ADDR
// for i = tmp downto 1 do
17377: LD_ADDR_VAR 0 7
17381: PUSH
17382: DOUBLE
17383: LD_VAR 0 9
17387: INC
17388: ST_TO_ADDR
17389: LD_INT 1
17391: PUSH
17392: FOR_DOWNTO
17393: IFFALSE 17438
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
17395: LD_ADDR_VAR 0 6
17399: PUSH
17400: LD_VAR 0 6
17404: PPUSH
17405: LD_VAR 0 9
17409: PUSH
17410: LD_VAR 0 7
17414: MINUS
17415: PUSH
17416: LD_INT 1
17418: PLUS
17419: PPUSH
17420: LD_VAR 0 9
17424: PUSH
17425: LD_VAR 0 7
17429: ARRAY
17430: PPUSH
17431: CALL_OW 1
17435: ST_TO_ADDR
17436: GO 17392
17438: POP
17439: POP
// end ; tmp := [ ] ;
17440: LD_ADDR_VAR 0 9
17444: PUSH
17445: EMPTY
17446: ST_TO_ADDR
// if mode then
17447: LD_VAR 0 5
17451: IFFALSE 17520
// begin for i = 1 to result do
17453: LD_ADDR_VAR 0 7
17457: PUSH
17458: DOUBLE
17459: LD_INT 1
17461: DEC
17462: ST_TO_ADDR
17463: LD_VAR 0 6
17467: PUSH
17468: FOR_TO
17469: IFFALSE 17508
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
17471: LD_ADDR_VAR 0 9
17475: PUSH
17476: LD_VAR 0 9
17480: PPUSH
17481: LD_VAR 0 7
17485: PPUSH
17486: LD_VAR 0 6
17490: PUSH
17491: LD_VAR 0 7
17495: ARRAY
17496: PUSH
17497: LD_INT 1
17499: ARRAY
17500: PPUSH
17501: CALL_OW 1
17505: ST_TO_ADDR
17506: GO 17468
17508: POP
17509: POP
// result := tmp ;
17510: LD_ADDR_VAR 0 6
17514: PUSH
17515: LD_VAR 0 9
17519: ST_TO_ADDR
// end ; end ;
17520: LD_VAR 0 6
17524: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
17525: LD_INT 0
17527: PPUSH
17528: PPUSH
17529: PPUSH
17530: PPUSH
17531: PPUSH
17532: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
17533: LD_ADDR_VAR 0 5
17537: PUSH
17538: LD_INT 0
17540: PUSH
17541: LD_INT 0
17543: PUSH
17544: LD_INT 0
17546: PUSH
17547: EMPTY
17548: PUSH
17549: EMPTY
17550: LIST
17551: LIST
17552: LIST
17553: LIST
17554: ST_TO_ADDR
// if not x or not y then
17555: LD_VAR 0 2
17559: NOT
17560: IFTRUE 17569
17562: PUSH
17563: LD_VAR 0 3
17567: NOT
17568: OR
17569: IFFALSE 17573
// exit ;
17571: GO 19229
// if not range then
17573: LD_VAR 0 4
17577: NOT
17578: IFFALSE 17588
// range := 10 ;
17580: LD_ADDR_VAR 0 4
17584: PUSH
17585: LD_INT 10
17587: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17588: LD_ADDR_VAR 0 8
17592: PUSH
17593: LD_INT 81
17595: PUSH
17596: LD_VAR 0 1
17600: PUSH
17601: EMPTY
17602: LIST
17603: LIST
17604: PUSH
17605: LD_INT 92
17607: PUSH
17608: LD_VAR 0 2
17612: PUSH
17613: LD_VAR 0 3
17617: PUSH
17618: LD_VAR 0 4
17622: PUSH
17623: EMPTY
17624: LIST
17625: LIST
17626: LIST
17627: LIST
17628: PUSH
17629: LD_INT 3
17631: PUSH
17632: LD_INT 21
17634: PUSH
17635: LD_INT 3
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: PUSH
17642: EMPTY
17643: LIST
17644: LIST
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: LIST
17650: PPUSH
17651: CALL_OW 69
17655: ST_TO_ADDR
// if not tmp then
17656: LD_VAR 0 8
17660: NOT
17661: IFFALSE 17665
// exit ;
17663: GO 19229
// for i in tmp do
17665: LD_ADDR_VAR 0 6
17669: PUSH
17670: LD_VAR 0 8
17674: PUSH
17675: FOR_IN
17676: IFFALSE 19204
// begin points := [ 0 , 0 , 0 ] ;
17678: LD_ADDR_VAR 0 9
17682: PUSH
17683: LD_INT 0
17685: PUSH
17686: LD_INT 0
17688: PUSH
17689: LD_INT 0
17691: PUSH
17692: EMPTY
17693: LIST
17694: LIST
17695: LIST
17696: ST_TO_ADDR
// bpoints := 1 ;
17697: LD_ADDR_VAR 0 10
17701: PUSH
17702: LD_INT 1
17704: ST_TO_ADDR
// case GetType ( i ) of unit_human :
17705: LD_VAR 0 6
17709: PPUSH
17710: CALL_OW 247
17714: PUSH
17715: LD_INT 1
17717: DOUBLE
17718: EQUAL
17719: IFTRUE 17723
17721: GO 18305
17723: POP
// begin if GetClass ( i ) = 1 then
17724: LD_VAR 0 6
17728: PPUSH
17729: CALL_OW 257
17733: PUSH
17734: LD_INT 1
17736: EQUAL
17737: IFFALSE 17758
// points := [ 10 , 5 , 3 ] ;
17739: LD_ADDR_VAR 0 9
17743: PUSH
17744: LD_INT 10
17746: PUSH
17747: LD_INT 5
17749: PUSH
17750: LD_INT 3
17752: PUSH
17753: EMPTY
17754: LIST
17755: LIST
17756: LIST
17757: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
17758: LD_VAR 0 6
17762: PPUSH
17763: CALL_OW 257
17767: PUSH
17768: LD_INT 2
17770: PUSH
17771: LD_INT 3
17773: PUSH
17774: LD_INT 4
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: LIST
17781: IN
17782: IFFALSE 17803
// points := [ 3 , 2 , 1 ] ;
17784: LD_ADDR_VAR 0 9
17788: PUSH
17789: LD_INT 3
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 1
17797: PUSH
17798: EMPTY
17799: LIST
17800: LIST
17801: LIST
17802: ST_TO_ADDR
// if GetClass ( i ) = 5 then
17803: LD_VAR 0 6
17807: PPUSH
17808: CALL_OW 257
17812: PUSH
17813: LD_INT 5
17815: EQUAL
17816: IFFALSE 17837
// points := [ 130 , 5 , 2 ] ;
17818: LD_ADDR_VAR 0 9
17822: PUSH
17823: LD_INT 130
17825: PUSH
17826: LD_INT 5
17828: PUSH
17829: LD_INT 2
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: LIST
17836: ST_TO_ADDR
// if GetClass ( i ) = 8 then
17837: LD_VAR 0 6
17841: PPUSH
17842: CALL_OW 257
17846: PUSH
17847: LD_INT 8
17849: EQUAL
17850: IFFALSE 17871
// points := [ 35 , 35 , 30 ] ;
17852: LD_ADDR_VAR 0 9
17856: PUSH
17857: LD_INT 35
17859: PUSH
17860: LD_INT 35
17862: PUSH
17863: LD_INT 30
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: LIST
17870: ST_TO_ADDR
// if GetClass ( i ) = 9 then
17871: LD_VAR 0 6
17875: PPUSH
17876: CALL_OW 257
17880: PUSH
17881: LD_INT 9
17883: EQUAL
17884: IFFALSE 17905
// points := [ 20 , 55 , 40 ] ;
17886: LD_ADDR_VAR 0 9
17890: PUSH
17891: LD_INT 20
17893: PUSH
17894: LD_INT 55
17896: PUSH
17897: LD_INT 40
17899: PUSH
17900: EMPTY
17901: LIST
17902: LIST
17903: LIST
17904: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
17905: LD_VAR 0 6
17909: PPUSH
17910: CALL_OW 257
17914: PUSH
17915: LD_INT 12
17917: PUSH
17918: LD_INT 16
17920: PUSH
17921: EMPTY
17922: LIST
17923: LIST
17924: IN
17925: IFFALSE 17946
// points := [ 5 , 3 , 2 ] ;
17927: LD_ADDR_VAR 0 9
17931: PUSH
17932: LD_INT 5
17934: PUSH
17935: LD_INT 3
17937: PUSH
17938: LD_INT 2
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
// if GetClass ( i ) = 17 then
17946: LD_VAR 0 6
17950: PPUSH
17951: CALL_OW 257
17955: PUSH
17956: LD_INT 17
17958: EQUAL
17959: IFFALSE 17980
// points := [ 100 , 50 , 75 ] ;
17961: LD_ADDR_VAR 0 9
17965: PUSH
17966: LD_INT 100
17968: PUSH
17969: LD_INT 50
17971: PUSH
17972: LD_INT 75
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: LIST
17979: ST_TO_ADDR
// if GetClass ( i ) = 15 then
17980: LD_VAR 0 6
17984: PPUSH
17985: CALL_OW 257
17989: PUSH
17990: LD_INT 15
17992: EQUAL
17993: IFFALSE 18014
// points := [ 10 , 5 , 3 ] ;
17995: LD_ADDR_VAR 0 9
17999: PUSH
18000: LD_INT 10
18002: PUSH
18003: LD_INT 5
18005: PUSH
18006: LD_INT 3
18008: PUSH
18009: EMPTY
18010: LIST
18011: LIST
18012: LIST
18013: ST_TO_ADDR
// if GetClass ( i ) = 14 then
18014: LD_VAR 0 6
18018: PPUSH
18019: CALL_OW 257
18023: PUSH
18024: LD_INT 14
18026: EQUAL
18027: IFFALSE 18048
// points := [ 10 , 0 , 0 ] ;
18029: LD_ADDR_VAR 0 9
18033: PUSH
18034: LD_INT 10
18036: PUSH
18037: LD_INT 0
18039: PUSH
18040: LD_INT 0
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: LIST
18047: ST_TO_ADDR
// if GetClass ( i ) = 11 then
18048: LD_VAR 0 6
18052: PPUSH
18053: CALL_OW 257
18057: PUSH
18058: LD_INT 11
18060: EQUAL
18061: IFFALSE 18082
// points := [ 30 , 10 , 5 ] ;
18063: LD_ADDR_VAR 0 9
18067: PUSH
18068: LD_INT 30
18070: PUSH
18071: LD_INT 10
18073: PUSH
18074: LD_INT 5
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
18082: LD_VAR 0 1
18086: PPUSH
18087: LD_INT 5
18089: PPUSH
18090: CALL_OW 321
18094: PUSH
18095: LD_INT 2
18097: EQUAL
18098: IFFALSE 18115
// bpoints := bpoints * 1.8 ;
18100: LD_ADDR_VAR 0 10
18104: PUSH
18105: LD_VAR 0 10
18109: PUSH
18110: LD_REAL  1.80000000000000E+0000
18113: MUL
18114: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
18115: LD_VAR 0 6
18119: PPUSH
18120: CALL_OW 257
18124: PUSH
18125: LD_INT 1
18127: PUSH
18128: LD_INT 2
18130: PUSH
18131: LD_INT 3
18133: PUSH
18134: LD_INT 4
18136: PUSH
18137: EMPTY
18138: LIST
18139: LIST
18140: LIST
18141: LIST
18142: IN
18143: IFFALSE 18163
18145: PUSH
18146: LD_VAR 0 1
18150: PPUSH
18151: LD_INT 51
18153: PPUSH
18154: CALL_OW 321
18158: PUSH
18159: LD_INT 2
18161: EQUAL
18162: AND
18163: IFFALSE 18180
// bpoints := bpoints * 1.2 ;
18165: LD_ADDR_VAR 0 10
18169: PUSH
18170: LD_VAR 0 10
18174: PUSH
18175: LD_REAL  1.20000000000000E+0000
18178: MUL
18179: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
18180: LD_VAR 0 6
18184: PPUSH
18185: CALL_OW 257
18189: PUSH
18190: LD_INT 5
18192: PUSH
18193: LD_INT 7
18195: PUSH
18196: LD_INT 9
18198: PUSH
18199: EMPTY
18200: LIST
18201: LIST
18202: LIST
18203: IN
18204: IFFALSE 18224
18206: PUSH
18207: LD_VAR 0 1
18211: PPUSH
18212: LD_INT 52
18214: PPUSH
18215: CALL_OW 321
18219: PUSH
18220: LD_INT 2
18222: EQUAL
18223: AND
18224: IFFALSE 18241
// bpoints := bpoints * 1.5 ;
18226: LD_ADDR_VAR 0 10
18230: PUSH
18231: LD_VAR 0 10
18235: PUSH
18236: LD_REAL  1.50000000000000E+0000
18239: MUL
18240: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
18241: LD_VAR 0 1
18245: PPUSH
18246: LD_INT 66
18248: PPUSH
18249: CALL_OW 321
18253: PUSH
18254: LD_INT 2
18256: EQUAL
18257: IFFALSE 18274
// bpoints := bpoints * 1.1 ;
18259: LD_ADDR_VAR 0 10
18263: PUSH
18264: LD_VAR 0 10
18268: PUSH
18269: LD_REAL  1.10000000000000E+0000
18272: MUL
18273: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
18274: LD_ADDR_VAR 0 10
18278: PUSH
18279: LD_VAR 0 10
18283: PUSH
18284: LD_VAR 0 6
18288: PPUSH
18289: LD_INT 1
18291: PPUSH
18292: CALL_OW 259
18296: PUSH
18297: LD_REAL  1.15000000000000E+0000
18300: MUL
18301: MUL
18302: ST_TO_ADDR
// end ; unit_vehicle :
18303: GO 19133
18305: LD_INT 2
18307: DOUBLE
18308: EQUAL
18309: IFTRUE 18313
18311: GO 19121
18313: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
18314: LD_VAR 0 6
18318: PPUSH
18319: CALL_OW 264
18323: PUSH
18324: LD_INT 2
18326: PUSH
18327: LD_INT 42
18329: PUSH
18330: LD_INT 24
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: IN
18338: IFFALSE 18359
// points := [ 25 , 5 , 3 ] ;
18340: LD_ADDR_VAR 0 9
18344: PUSH
18345: LD_INT 25
18347: PUSH
18348: LD_INT 5
18350: PUSH
18351: LD_INT 3
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: LIST
18358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
18359: LD_VAR 0 6
18363: PPUSH
18364: CALL_OW 264
18368: PUSH
18369: LD_INT 4
18371: PUSH
18372: LD_INT 43
18374: PUSH
18375: LD_INT 25
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: IN
18383: IFFALSE 18404
// points := [ 40 , 15 , 5 ] ;
18385: LD_ADDR_VAR 0 9
18389: PUSH
18390: LD_INT 40
18392: PUSH
18393: LD_INT 15
18395: PUSH
18396: LD_INT 5
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
18404: LD_VAR 0 6
18408: PPUSH
18409: CALL_OW 264
18413: PUSH
18414: LD_INT 3
18416: PUSH
18417: LD_INT 23
18419: PUSH
18420: EMPTY
18421: LIST
18422: LIST
18423: IN
18424: IFFALSE 18445
// points := [ 7 , 25 , 8 ] ;
18426: LD_ADDR_VAR 0 9
18430: PUSH
18431: LD_INT 7
18433: PUSH
18434: LD_INT 25
18436: PUSH
18437: LD_INT 8
18439: PUSH
18440: EMPTY
18441: LIST
18442: LIST
18443: LIST
18444: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
18445: LD_VAR 0 6
18449: PPUSH
18450: CALL_OW 264
18454: PUSH
18455: LD_INT 5
18457: PUSH
18458: LD_INT 27
18460: PUSH
18461: LD_INT 44
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: LIST
18468: IN
18469: IFFALSE 18490
// points := [ 14 , 50 , 16 ] ;
18471: LD_ADDR_VAR 0 9
18475: PUSH
18476: LD_INT 14
18478: PUSH
18479: LD_INT 50
18481: PUSH
18482: LD_INT 16
18484: PUSH
18485: EMPTY
18486: LIST
18487: LIST
18488: LIST
18489: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
18490: LD_VAR 0 6
18494: PPUSH
18495: CALL_OW 264
18499: PUSH
18500: LD_INT 6
18502: PUSH
18503: LD_INT 46
18505: PUSH
18506: EMPTY
18507: LIST
18508: LIST
18509: IN
18510: IFFALSE 18531
// points := [ 32 , 120 , 70 ] ;
18512: LD_ADDR_VAR 0 9
18516: PUSH
18517: LD_INT 32
18519: PUSH
18520: LD_INT 120
18522: PUSH
18523: LD_INT 70
18525: PUSH
18526: EMPTY
18527: LIST
18528: LIST
18529: LIST
18530: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
18531: LD_VAR 0 6
18535: PPUSH
18536: CALL_OW 264
18540: PUSH
18541: LD_INT 7
18543: PUSH
18544: LD_INT 28
18546: PUSH
18547: LD_INT 45
18549: PUSH
18550: LD_INT 92
18552: PUSH
18553: EMPTY
18554: LIST
18555: LIST
18556: LIST
18557: LIST
18558: IN
18559: IFFALSE 18580
// points := [ 35 , 20 , 45 ] ;
18561: LD_ADDR_VAR 0 9
18565: PUSH
18566: LD_INT 35
18568: PUSH
18569: LD_INT 20
18571: PUSH
18572: LD_INT 45
18574: PUSH
18575: EMPTY
18576: LIST
18577: LIST
18578: LIST
18579: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
18580: LD_VAR 0 6
18584: PPUSH
18585: CALL_OW 264
18589: PUSH
18590: LD_INT 47
18592: PUSH
18593: EMPTY
18594: LIST
18595: IN
18596: IFFALSE 18617
// points := [ 67 , 45 , 75 ] ;
18598: LD_ADDR_VAR 0 9
18602: PUSH
18603: LD_INT 67
18605: PUSH
18606: LD_INT 45
18608: PUSH
18609: LD_INT 75
18611: PUSH
18612: EMPTY
18613: LIST
18614: LIST
18615: LIST
18616: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
18617: LD_VAR 0 6
18621: PPUSH
18622: CALL_OW 264
18626: PUSH
18627: LD_INT 26
18629: PUSH
18630: EMPTY
18631: LIST
18632: IN
18633: IFFALSE 18654
// points := [ 120 , 30 , 80 ] ;
18635: LD_ADDR_VAR 0 9
18639: PUSH
18640: LD_INT 120
18642: PUSH
18643: LD_INT 30
18645: PUSH
18646: LD_INT 80
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: LIST
18653: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
18654: LD_VAR 0 6
18658: PPUSH
18659: CALL_OW 264
18663: PUSH
18664: LD_INT 22
18666: PUSH
18667: EMPTY
18668: LIST
18669: IN
18670: IFFALSE 18691
// points := [ 40 , 1 , 1 ] ;
18672: LD_ADDR_VAR 0 9
18676: PUSH
18677: LD_INT 40
18679: PUSH
18680: LD_INT 1
18682: PUSH
18683: LD_INT 1
18685: PUSH
18686: EMPTY
18687: LIST
18688: LIST
18689: LIST
18690: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
18691: LD_VAR 0 6
18695: PPUSH
18696: CALL_OW 264
18700: PUSH
18701: LD_INT 29
18703: PUSH
18704: EMPTY
18705: LIST
18706: IN
18707: IFFALSE 18728
// points := [ 70 , 200 , 400 ] ;
18709: LD_ADDR_VAR 0 9
18713: PUSH
18714: LD_INT 70
18716: PUSH
18717: LD_INT 200
18719: PUSH
18720: LD_INT 400
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: LIST
18727: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
18728: LD_VAR 0 6
18732: PPUSH
18733: CALL_OW 264
18737: PUSH
18738: LD_INT 14
18740: PUSH
18741: LD_INT 53
18743: PUSH
18744: EMPTY
18745: LIST
18746: LIST
18747: IN
18748: IFFALSE 18769
// points := [ 40 , 10 , 20 ] ;
18750: LD_ADDR_VAR 0 9
18754: PUSH
18755: LD_INT 40
18757: PUSH
18758: LD_INT 10
18760: PUSH
18761: LD_INT 20
18763: PUSH
18764: EMPTY
18765: LIST
18766: LIST
18767: LIST
18768: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
18769: LD_VAR 0 6
18773: PPUSH
18774: CALL_OW 264
18778: PUSH
18779: LD_INT 9
18781: PUSH
18782: EMPTY
18783: LIST
18784: IN
18785: IFFALSE 18806
// points := [ 5 , 70 , 20 ] ;
18787: LD_ADDR_VAR 0 9
18791: PUSH
18792: LD_INT 5
18794: PUSH
18795: LD_INT 70
18797: PUSH
18798: LD_INT 20
18800: PUSH
18801: EMPTY
18802: LIST
18803: LIST
18804: LIST
18805: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
18806: LD_VAR 0 6
18810: PPUSH
18811: CALL_OW 264
18815: PUSH
18816: LD_INT 10
18818: PUSH
18819: EMPTY
18820: LIST
18821: IN
18822: IFFALSE 18843
// points := [ 35 , 110 , 70 ] ;
18824: LD_ADDR_VAR 0 9
18828: PUSH
18829: LD_INT 35
18831: PUSH
18832: LD_INT 110
18834: PUSH
18835: LD_INT 70
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: LIST
18842: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
18843: LD_VAR 0 6
18847: PPUSH
18848: CALL_OW 265
18852: PUSH
18853: LD_INT 25
18855: EQUAL
18856: IFFALSE 18877
// points := [ 80 , 65 , 100 ] ;
18858: LD_ADDR_VAR 0 9
18862: PUSH
18863: LD_INT 80
18865: PUSH
18866: LD_INT 65
18868: PUSH
18869: LD_INT 100
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
18877: LD_VAR 0 6
18881: PPUSH
18882: CALL_OW 263
18886: PUSH
18887: LD_INT 1
18889: EQUAL
18890: IFFALSE 18925
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
18892: LD_ADDR_VAR 0 10
18896: PUSH
18897: LD_VAR 0 10
18901: PUSH
18902: LD_VAR 0 6
18906: PPUSH
18907: CALL_OW 311
18911: PPUSH
18912: LD_INT 3
18914: PPUSH
18915: CALL_OW 259
18919: PUSH
18920: LD_INT 4
18922: MUL
18923: MUL
18924: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
18925: LD_VAR 0 6
18929: PPUSH
18930: CALL_OW 263
18934: PUSH
18935: LD_INT 2
18937: EQUAL
18938: IFFALSE 18989
// begin j := IsControledBy ( i ) ;
18940: LD_ADDR_VAR 0 7
18944: PUSH
18945: LD_VAR 0 6
18949: PPUSH
18950: CALL_OW 312
18954: ST_TO_ADDR
// if j then
18955: LD_VAR 0 7
18959: IFFALSE 18989
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
18961: LD_ADDR_VAR 0 10
18965: PUSH
18966: LD_VAR 0 10
18970: PUSH
18971: LD_VAR 0 7
18975: PPUSH
18976: LD_INT 3
18978: PPUSH
18979: CALL_OW 259
18983: PUSH
18984: LD_INT 3
18986: MUL
18987: MUL
18988: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
18989: LD_VAR 0 6
18993: PPUSH
18994: CALL_OW 264
18998: PUSH
18999: LD_INT 5
19001: PUSH
19002: LD_INT 6
19004: PUSH
19005: LD_INT 46
19007: PUSH
19008: LD_INT 44
19010: PUSH
19011: LD_INT 47
19013: PUSH
19014: LD_INT 45
19016: PUSH
19017: LD_INT 28
19019: PUSH
19020: LD_INT 7
19022: PUSH
19023: LD_INT 27
19025: PUSH
19026: LD_INT 29
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: LIST
19038: LIST
19039: LIST
19040: IN
19041: IFFALSE 19061
19043: PUSH
19044: LD_VAR 0 1
19048: PPUSH
19049: LD_INT 52
19051: PPUSH
19052: CALL_OW 321
19056: PUSH
19057: LD_INT 2
19059: EQUAL
19060: AND
19061: IFFALSE 19078
// bpoints := bpoints * 1.2 ;
19063: LD_ADDR_VAR 0 10
19067: PUSH
19068: LD_VAR 0 10
19072: PUSH
19073: LD_REAL  1.20000000000000E+0000
19076: MUL
19077: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
19078: LD_VAR 0 6
19082: PPUSH
19083: CALL_OW 264
19087: PUSH
19088: LD_INT 6
19090: PUSH
19091: LD_INT 46
19093: PUSH
19094: LD_INT 47
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: IN
19102: IFFALSE 19119
// bpoints := bpoints * 1.2 ;
19104: LD_ADDR_VAR 0 10
19108: PUSH
19109: LD_VAR 0 10
19113: PUSH
19114: LD_REAL  1.20000000000000E+0000
19117: MUL
19118: ST_TO_ADDR
// end ; unit_building :
19119: GO 19133
19121: LD_INT 3
19123: DOUBLE
19124: EQUAL
19125: IFTRUE 19129
19127: GO 19132
19129: POP
// ; end ;
19130: GO 19133
19132: POP
// for j = 1 to 3 do
19133: LD_ADDR_VAR 0 7
19137: PUSH
19138: DOUBLE
19139: LD_INT 1
19141: DEC
19142: ST_TO_ADDR
19143: LD_INT 3
19145: PUSH
19146: FOR_TO
19147: IFFALSE 19200
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
19149: LD_ADDR_VAR 0 5
19153: PUSH
19154: LD_VAR 0 5
19158: PPUSH
19159: LD_VAR 0 7
19163: PPUSH
19164: LD_VAR 0 5
19168: PUSH
19169: LD_VAR 0 7
19173: ARRAY
19174: PUSH
19175: LD_VAR 0 9
19179: PUSH
19180: LD_VAR 0 7
19184: ARRAY
19185: PUSH
19186: LD_VAR 0 10
19190: MUL
19191: PLUS
19192: PPUSH
19193: CALL_OW 1
19197: ST_TO_ADDR
19198: GO 19146
19200: POP
19201: POP
// end ;
19202: GO 17675
19204: POP
19205: POP
// result := Replace ( result , 4 , tmp ) ;
19206: LD_ADDR_VAR 0 5
19210: PUSH
19211: LD_VAR 0 5
19215: PPUSH
19216: LD_INT 4
19218: PPUSH
19219: LD_VAR 0 8
19223: PPUSH
19224: CALL_OW 1
19228: ST_TO_ADDR
// end ;
19229: LD_VAR 0 5
19233: RET
// export function DangerAtRange ( unit , range ) ; begin
19234: LD_INT 0
19236: PPUSH
// if not unit then
19237: LD_VAR 0 1
19241: NOT
19242: IFFALSE 19246
// exit ;
19244: GO 19291
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
19246: LD_ADDR_VAR 0 3
19250: PUSH
19251: LD_VAR 0 1
19255: PPUSH
19256: CALL_OW 255
19260: PPUSH
19261: LD_VAR 0 1
19265: PPUSH
19266: CALL_OW 250
19270: PPUSH
19271: LD_VAR 0 1
19275: PPUSH
19276: CALL_OW 251
19280: PPUSH
19281: LD_VAR 0 2
19285: PPUSH
19286: CALL 17525 0 4
19290: ST_TO_ADDR
// end ;
19291: LD_VAR 0 3
19295: RET
// export function DangerInArea ( side , area ) ; begin
19296: LD_INT 0
19298: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
19299: LD_ADDR_VAR 0 3
19303: PUSH
19304: LD_VAR 0 2
19308: PPUSH
19309: LD_INT 81
19311: PUSH
19312: LD_VAR 0 1
19316: PUSH
19317: EMPTY
19318: LIST
19319: LIST
19320: PPUSH
19321: CALL_OW 70
19325: ST_TO_ADDR
// end ;
19326: LD_VAR 0 3
19330: RET
// export function IsExtension ( b ) ; begin
19331: LD_INT 0
19333: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
19334: LD_ADDR_VAR 0 2
19338: PUSH
19339: LD_VAR 0 1
19343: PUSH
19344: LD_INT 23
19346: PUSH
19347: LD_INT 20
19349: PUSH
19350: LD_INT 22
19352: PUSH
19353: LD_INT 17
19355: PUSH
19356: LD_INT 24
19358: PUSH
19359: LD_INT 21
19361: PUSH
19362: LD_INT 19
19364: PUSH
19365: LD_INT 16
19367: PUSH
19368: LD_INT 25
19370: PUSH
19371: LD_INT 18
19373: PUSH
19374: EMPTY
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: IN
19386: ST_TO_ADDR
// end ;
19387: LD_VAR 0 2
19391: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
19392: LD_INT 0
19394: PPUSH
19395: PPUSH
19396: PPUSH
// result := [ ] ;
19397: LD_ADDR_VAR 0 4
19401: PUSH
19402: EMPTY
19403: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
19404: LD_ADDR_VAR 0 5
19408: PUSH
19409: LD_VAR 0 2
19413: PPUSH
19414: LD_INT 21
19416: PUSH
19417: LD_INT 3
19419: PUSH
19420: EMPTY
19421: LIST
19422: LIST
19423: PPUSH
19424: CALL_OW 70
19428: ST_TO_ADDR
// if not tmp then
19429: LD_VAR 0 5
19433: NOT
19434: IFFALSE 19438
// exit ;
19436: GO 19502
// if checkLink then
19438: LD_VAR 0 3
19442: IFFALSE 19492
// begin for i in tmp do
19444: LD_ADDR_VAR 0 6
19448: PUSH
19449: LD_VAR 0 5
19453: PUSH
19454: FOR_IN
19455: IFFALSE 19490
// if GetBase ( i ) <> base then
19457: LD_VAR 0 6
19461: PPUSH
19462: CALL_OW 274
19466: PUSH
19467: LD_VAR 0 1
19471: NONEQUAL
19472: IFFALSE 19488
// ComLinkToBase ( base , i ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_VAR 0 6
19483: PPUSH
19484: CALL_OW 169
19488: GO 19454
19490: POP
19491: POP
// end ; result := tmp ;
19492: LD_ADDR_VAR 0 4
19496: PUSH
19497: LD_VAR 0 5
19501: ST_TO_ADDR
// end ;
19502: LD_VAR 0 4
19506: RET
// export function ComComplete ( units , b ) ; var i ; begin
19507: LD_INT 0
19509: PPUSH
19510: PPUSH
// if not units then
19511: LD_VAR 0 1
19515: NOT
19516: IFFALSE 19520
// exit ;
19518: GO 19610
// for i in units do
19520: LD_ADDR_VAR 0 4
19524: PUSH
19525: LD_VAR 0 1
19529: PUSH
19530: FOR_IN
19531: IFFALSE 19608
// if BuildingStatus ( b ) = bs_build then
19533: LD_VAR 0 2
19537: PPUSH
19538: CALL_OW 461
19542: PUSH
19543: LD_INT 1
19545: EQUAL
19546: IFFALSE 19606
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
19548: LD_VAR 0 4
19552: PPUSH
19553: LD_STRING h
19555: PUSH
19556: LD_VAR 0 2
19560: PPUSH
19561: CALL_OW 250
19565: PUSH
19566: LD_VAR 0 2
19570: PPUSH
19571: CALL_OW 251
19575: PUSH
19576: LD_VAR 0 2
19580: PUSH
19581: LD_INT 0
19583: PUSH
19584: LD_INT 0
19586: PUSH
19587: LD_INT 0
19589: PUSH
19590: EMPTY
19591: LIST
19592: LIST
19593: LIST
19594: LIST
19595: LIST
19596: LIST
19597: LIST
19598: PUSH
19599: EMPTY
19600: LIST
19601: PPUSH
19602: CALL_OW 446
19606: GO 19530
19608: POP
19609: POP
// end ;
19610: LD_VAR 0 3
19614: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
19615: LD_INT 0
19617: PPUSH
19618: PPUSH
19619: PPUSH
19620: PPUSH
19621: PPUSH
19622: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
19623: LD_VAR 0 1
19627: NOT
19628: IFTRUE 19645
19630: PUSH
19631: LD_VAR 0 1
19635: PPUSH
19636: CALL_OW 263
19640: PUSH
19641: LD_INT 2
19643: NONEQUAL
19644: OR
19645: IFFALSE 19649
// exit ;
19647: GO 19965
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
19649: LD_ADDR_VAR 0 6
19653: PUSH
19654: LD_INT 22
19656: PUSH
19657: LD_VAR 0 1
19661: PPUSH
19662: CALL_OW 255
19666: PUSH
19667: EMPTY
19668: LIST
19669: LIST
19670: PUSH
19671: LD_INT 2
19673: PUSH
19674: LD_INT 30
19676: PUSH
19677: LD_INT 36
19679: PUSH
19680: EMPTY
19681: LIST
19682: LIST
19683: PUSH
19684: LD_INT 34
19686: PUSH
19687: LD_INT 31
19689: PUSH
19690: EMPTY
19691: LIST
19692: LIST
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: LIST
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PPUSH
19703: CALL_OW 69
19707: ST_TO_ADDR
// if not tmp then
19708: LD_VAR 0 6
19712: NOT
19713: IFFALSE 19717
// exit ;
19715: GO 19965
// result := [ ] ;
19717: LD_ADDR_VAR 0 2
19721: PUSH
19722: EMPTY
19723: ST_TO_ADDR
// for i in tmp do
19724: LD_ADDR_VAR 0 3
19728: PUSH
19729: LD_VAR 0 6
19733: PUSH
19734: FOR_IN
19735: IFFALSE 19806
// begin t := UnitsInside ( i ) ;
19737: LD_ADDR_VAR 0 4
19741: PUSH
19742: LD_VAR 0 3
19746: PPUSH
19747: CALL_OW 313
19751: ST_TO_ADDR
// if t then
19752: LD_VAR 0 4
19756: IFFALSE 19804
// for j in t do
19758: LD_ADDR_VAR 0 7
19762: PUSH
19763: LD_VAR 0 4
19767: PUSH
19768: FOR_IN
19769: IFFALSE 19802
// result := Replace ( result , result + 1 , j ) ;
19771: LD_ADDR_VAR 0 2
19775: PUSH
19776: LD_VAR 0 2
19780: PPUSH
19781: LD_VAR 0 2
19785: PUSH
19786: LD_INT 1
19788: PLUS
19789: PPUSH
19790: LD_VAR 0 7
19794: PPUSH
19795: CALL_OW 1
19799: ST_TO_ADDR
19800: GO 19768
19802: POP
19803: POP
// end ;
19804: GO 19734
19806: POP
19807: POP
// if not result then
19808: LD_VAR 0 2
19812: NOT
19813: IFFALSE 19817
// exit ;
19815: GO 19965
// mech := result [ 1 ] ;
19817: LD_ADDR_VAR 0 5
19821: PUSH
19822: LD_VAR 0 2
19826: PUSH
19827: LD_INT 1
19829: ARRAY
19830: ST_TO_ADDR
// if result > 1 then
19831: LD_VAR 0 2
19835: PUSH
19836: LD_INT 1
19838: GREATER
19839: IFFALSE 19951
// begin for i = 2 to result do
19841: LD_ADDR_VAR 0 3
19845: PUSH
19846: DOUBLE
19847: LD_INT 2
19849: DEC
19850: ST_TO_ADDR
19851: LD_VAR 0 2
19855: PUSH
19856: FOR_TO
19857: IFFALSE 19949
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: LD_VAR 0 2
19868: PUSH
19869: LD_VAR 0 3
19873: ARRAY
19874: PPUSH
19875: LD_INT 3
19877: PPUSH
19878: CALL_OW 259
19882: PUSH
19883: LD_VAR 0 2
19887: PUSH
19888: LD_VAR 0 3
19892: ARRAY
19893: PPUSH
19894: CALL_OW 432
19898: MINUS
19899: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
19900: LD_VAR 0 4
19904: PUSH
19905: LD_VAR 0 5
19909: PPUSH
19910: LD_INT 3
19912: PPUSH
19913: CALL_OW 259
19917: PUSH
19918: LD_VAR 0 5
19922: PPUSH
19923: CALL_OW 432
19927: MINUS
19928: GREATEREQUAL
19929: IFFALSE 19947
// mech := result [ i ] ;
19931: LD_ADDR_VAR 0 5
19935: PUSH
19936: LD_VAR 0 2
19940: PUSH
19941: LD_VAR 0 3
19945: ARRAY
19946: ST_TO_ADDR
// end ;
19947: GO 19856
19949: POP
19950: POP
// end ; ComLinkTo ( vehicle , mech ) ;
19951: LD_VAR 0 1
19955: PPUSH
19956: LD_VAR 0 5
19960: PPUSH
19961: CALL_OW 135
// end ;
19965: LD_VAR 0 2
19969: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
19970: LD_INT 0
19972: PPUSH
19973: PPUSH
19974: PPUSH
19975: PPUSH
19976: PPUSH
19977: PPUSH
19978: PPUSH
19979: PPUSH
19980: PPUSH
19981: PPUSH
19982: PPUSH
19983: PPUSH
19984: PPUSH
// result := [ ] ;
19985: LD_ADDR_VAR 0 7
19989: PUSH
19990: EMPTY
19991: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
19992: LD_VAR 0 1
19996: PPUSH
19997: CALL_OW 266
20001: PUSH
20002: LD_INT 0
20004: PUSH
20005: LD_INT 1
20007: PUSH
20008: EMPTY
20009: LIST
20010: LIST
20011: IN
20012: NOT
20013: IFFALSE 20017
// exit ;
20015: GO 21657
// if name then
20017: LD_VAR 0 3
20021: IFFALSE 20037
// SetBName ( base_dep , name ) ;
20023: LD_VAR 0 1
20027: PPUSH
20028: LD_VAR 0 3
20032: PPUSH
20033: CALL_OW 500
// base := GetBase ( base_dep ) ;
20037: LD_ADDR_VAR 0 15
20041: PUSH
20042: LD_VAR 0 1
20046: PPUSH
20047: CALL_OW 274
20051: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
20052: LD_ADDR_VAR 0 16
20056: PUSH
20057: LD_VAR 0 1
20061: PPUSH
20062: CALL_OW 255
20066: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
20067: LD_ADDR_VAR 0 17
20071: PUSH
20072: LD_VAR 0 1
20076: PPUSH
20077: CALL_OW 248
20081: ST_TO_ADDR
// if sources then
20082: LD_VAR 0 5
20086: IFFALSE 20133
// for i = 1 to 3 do
20088: LD_ADDR_VAR 0 8
20092: PUSH
20093: DOUBLE
20094: LD_INT 1
20096: DEC
20097: ST_TO_ADDR
20098: LD_INT 3
20100: PUSH
20101: FOR_TO
20102: IFFALSE 20131
// AddResourceType ( base , i , sources [ i ] ) ;
20104: LD_VAR 0 15
20108: PPUSH
20109: LD_VAR 0 8
20113: PPUSH
20114: LD_VAR 0 5
20118: PUSH
20119: LD_VAR 0 8
20123: ARRAY
20124: PPUSH
20125: CALL_OW 276
20129: GO 20101
20131: POP
20132: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
20133: LD_ADDR_VAR 0 18
20137: PUSH
20138: LD_VAR 0 15
20142: PPUSH
20143: LD_VAR 0 2
20147: PPUSH
20148: LD_INT 1
20150: PPUSH
20151: CALL 19392 0 3
20155: ST_TO_ADDR
// InitHc ;
20156: CALL_OW 19
// InitUc ;
20160: CALL_OW 18
// uc_side := side ;
20164: LD_ADDR_OWVAR 20
20168: PUSH
20169: LD_VAR 0 16
20173: ST_TO_ADDR
// uc_nation := nation ;
20174: LD_ADDR_OWVAR 21
20178: PUSH
20179: LD_VAR 0 17
20183: ST_TO_ADDR
// if buildings then
20184: LD_VAR 0 18
20188: IFFALSE 21516
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
20190: LD_ADDR_VAR 0 19
20194: PUSH
20195: LD_VAR 0 18
20199: PPUSH
20200: LD_INT 2
20202: PUSH
20203: LD_INT 30
20205: PUSH
20206: LD_INT 29
20208: PUSH
20209: EMPTY
20210: LIST
20211: LIST
20212: PUSH
20213: LD_INT 30
20215: PUSH
20216: LD_INT 30
20218: PUSH
20219: EMPTY
20220: LIST
20221: LIST
20222: PUSH
20223: EMPTY
20224: LIST
20225: LIST
20226: LIST
20227: PPUSH
20228: CALL_OW 72
20232: ST_TO_ADDR
// if tmp then
20233: LD_VAR 0 19
20237: IFFALSE 20285
// for i in tmp do
20239: LD_ADDR_VAR 0 8
20243: PUSH
20244: LD_VAR 0 19
20248: PUSH
20249: FOR_IN
20250: IFFALSE 20283
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
20252: LD_VAR 0 8
20256: PPUSH
20257: CALL_OW 250
20261: PPUSH
20262: LD_VAR 0 8
20266: PPUSH
20267: CALL_OW 251
20271: PPUSH
20272: LD_VAR 0 16
20276: PPUSH
20277: CALL_OW 441
20281: GO 20249
20283: POP
20284: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
20285: LD_VAR 0 18
20289: PPUSH
20290: LD_INT 2
20292: PUSH
20293: LD_INT 30
20295: PUSH
20296: LD_INT 32
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 30
20305: PUSH
20306: LD_INT 33
20308: PUSH
20309: EMPTY
20310: LIST
20311: LIST
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: LIST
20317: PPUSH
20318: CALL_OW 72
20322: IFFALSE 20410
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
20324: LD_ADDR_VAR 0 8
20328: PUSH
20329: LD_VAR 0 18
20333: PPUSH
20334: LD_INT 2
20336: PUSH
20337: LD_INT 30
20339: PUSH
20340: LD_INT 32
20342: PUSH
20343: EMPTY
20344: LIST
20345: LIST
20346: PUSH
20347: LD_INT 30
20349: PUSH
20350: LD_INT 33
20352: PUSH
20353: EMPTY
20354: LIST
20355: LIST
20356: PUSH
20357: EMPTY
20358: LIST
20359: LIST
20360: LIST
20361: PPUSH
20362: CALL_OW 72
20366: PUSH
20367: FOR_IN
20368: IFFALSE 20408
// begin if not GetBWeapon ( i ) then
20370: LD_VAR 0 8
20374: PPUSH
20375: CALL_OW 269
20379: NOT
20380: IFFALSE 20406
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
20382: LD_VAR 0 8
20386: PPUSH
20387: LD_VAR 0 8
20391: PPUSH
20392: LD_VAR 0 2
20396: PPUSH
20397: CALL 21662 0 2
20401: PPUSH
20402: CALL_OW 431
// end ;
20406: GO 20367
20408: POP
20409: POP
// end ; for i = 1 to personel do
20410: LD_ADDR_VAR 0 8
20414: PUSH
20415: DOUBLE
20416: LD_INT 1
20418: DEC
20419: ST_TO_ADDR
20420: LD_VAR 0 6
20424: PUSH
20425: FOR_TO
20426: IFFALSE 21496
// begin if i > 4 then
20428: LD_VAR 0 8
20432: PUSH
20433: LD_INT 4
20435: GREATER
20436: IFFALSE 20440
// break ;
20438: GO 21496
// case i of 1 :
20440: LD_VAR 0 8
20444: PUSH
20445: LD_INT 1
20447: DOUBLE
20448: EQUAL
20449: IFTRUE 20453
20451: GO 20533
20453: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
20454: LD_ADDR_VAR 0 12
20458: PUSH
20459: LD_VAR 0 18
20463: PPUSH
20464: LD_INT 22
20466: PUSH
20467: LD_VAR 0 16
20471: PUSH
20472: EMPTY
20473: LIST
20474: LIST
20475: PUSH
20476: LD_INT 58
20478: PUSH
20479: EMPTY
20480: LIST
20481: PUSH
20482: LD_INT 2
20484: PUSH
20485: LD_INT 30
20487: PUSH
20488: LD_INT 32
20490: PUSH
20491: EMPTY
20492: LIST
20493: LIST
20494: PUSH
20495: LD_INT 30
20497: PUSH
20498: LD_INT 4
20500: PUSH
20501: EMPTY
20502: LIST
20503: LIST
20504: PUSH
20505: LD_INT 30
20507: PUSH
20508: LD_INT 5
20510: PUSH
20511: EMPTY
20512: LIST
20513: LIST
20514: PUSH
20515: EMPTY
20516: LIST
20517: LIST
20518: LIST
20519: LIST
20520: PUSH
20521: EMPTY
20522: LIST
20523: LIST
20524: LIST
20525: PPUSH
20526: CALL_OW 72
20530: ST_TO_ADDR
20531: GO 20755
20533: LD_INT 2
20535: DOUBLE
20536: EQUAL
20537: IFTRUE 20541
20539: GO 20603
20541: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
20542: LD_ADDR_VAR 0 12
20546: PUSH
20547: LD_VAR 0 18
20551: PPUSH
20552: LD_INT 22
20554: PUSH
20555: LD_VAR 0 16
20559: PUSH
20560: EMPTY
20561: LIST
20562: LIST
20563: PUSH
20564: LD_INT 2
20566: PUSH
20567: LD_INT 30
20569: PUSH
20570: LD_INT 0
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: LD_INT 30
20579: PUSH
20580: LD_INT 1
20582: PUSH
20583: EMPTY
20584: LIST
20585: LIST
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: LIST
20591: PUSH
20592: EMPTY
20593: LIST
20594: LIST
20595: PPUSH
20596: CALL_OW 72
20600: ST_TO_ADDR
20601: GO 20755
20603: LD_INT 3
20605: DOUBLE
20606: EQUAL
20607: IFTRUE 20611
20609: GO 20673
20611: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
20612: LD_ADDR_VAR 0 12
20616: PUSH
20617: LD_VAR 0 18
20621: PPUSH
20622: LD_INT 22
20624: PUSH
20625: LD_VAR 0 16
20629: PUSH
20630: EMPTY
20631: LIST
20632: LIST
20633: PUSH
20634: LD_INT 2
20636: PUSH
20637: LD_INT 30
20639: PUSH
20640: LD_INT 2
20642: PUSH
20643: EMPTY
20644: LIST
20645: LIST
20646: PUSH
20647: LD_INT 30
20649: PUSH
20650: LD_INT 3
20652: PUSH
20653: EMPTY
20654: LIST
20655: LIST
20656: PUSH
20657: EMPTY
20658: LIST
20659: LIST
20660: LIST
20661: PUSH
20662: EMPTY
20663: LIST
20664: LIST
20665: PPUSH
20666: CALL_OW 72
20670: ST_TO_ADDR
20671: GO 20755
20673: LD_INT 4
20675: DOUBLE
20676: EQUAL
20677: IFTRUE 20681
20679: GO 20754
20681: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
20682: LD_ADDR_VAR 0 12
20686: PUSH
20687: LD_VAR 0 18
20691: PPUSH
20692: LD_INT 22
20694: PUSH
20695: LD_VAR 0 16
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: PUSH
20704: LD_INT 2
20706: PUSH
20707: LD_INT 30
20709: PUSH
20710: LD_INT 6
20712: PUSH
20713: EMPTY
20714: LIST
20715: LIST
20716: PUSH
20717: LD_INT 30
20719: PUSH
20720: LD_INT 7
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: PUSH
20727: LD_INT 30
20729: PUSH
20730: LD_INT 8
20732: PUSH
20733: EMPTY
20734: LIST
20735: LIST
20736: PUSH
20737: EMPTY
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: PUSH
20743: EMPTY
20744: LIST
20745: LIST
20746: PPUSH
20747: CALL_OW 72
20751: ST_TO_ADDR
20752: GO 20755
20754: POP
// if i = 1 then
20755: LD_VAR 0 8
20759: PUSH
20760: LD_INT 1
20762: EQUAL
20763: IFFALSE 20874
// begin tmp := [ ] ;
20765: LD_ADDR_VAR 0 19
20769: PUSH
20770: EMPTY
20771: ST_TO_ADDR
// for j in f do
20772: LD_ADDR_VAR 0 9
20776: PUSH
20777: LD_VAR 0 12
20781: PUSH
20782: FOR_IN
20783: IFFALSE 20856
// if GetBType ( j ) = b_bunker then
20785: LD_VAR 0 9
20789: PPUSH
20790: CALL_OW 266
20794: PUSH
20795: LD_INT 32
20797: EQUAL
20798: IFFALSE 20825
// tmp := Insert ( tmp , 1 , j ) else
20800: LD_ADDR_VAR 0 19
20804: PUSH
20805: LD_VAR 0 19
20809: PPUSH
20810: LD_INT 1
20812: PPUSH
20813: LD_VAR 0 9
20817: PPUSH
20818: CALL_OW 2
20822: ST_TO_ADDR
20823: GO 20854
// tmp := Insert ( tmp , tmp + 1 , j ) ;
20825: LD_ADDR_VAR 0 19
20829: PUSH
20830: LD_VAR 0 19
20834: PPUSH
20835: LD_VAR 0 19
20839: PUSH
20840: LD_INT 1
20842: PLUS
20843: PPUSH
20844: LD_VAR 0 9
20848: PPUSH
20849: CALL_OW 2
20853: ST_TO_ADDR
20854: GO 20782
20856: POP
20857: POP
// if tmp then
20858: LD_VAR 0 19
20862: IFFALSE 20874
// f := tmp ;
20864: LD_ADDR_VAR 0 12
20868: PUSH
20869: LD_VAR 0 19
20873: ST_TO_ADDR
// end ; x := personel [ i ] ;
20874: LD_ADDR_VAR 0 13
20878: PUSH
20879: LD_VAR 0 6
20883: PUSH
20884: LD_VAR 0 8
20888: ARRAY
20889: ST_TO_ADDR
// if x = - 1 then
20890: LD_VAR 0 13
20894: PUSH
20895: LD_INT 1
20897: NEG
20898: EQUAL
20899: IFFALSE 21110
// begin for j in f do
20901: LD_ADDR_VAR 0 9
20905: PUSH
20906: LD_VAR 0 12
20910: PUSH
20911: FOR_IN
20912: IFFALSE 21106
// repeat InitHc ;
20914: CALL_OW 19
// if GetBType ( j ) = b_barracks then
20918: LD_VAR 0 9
20922: PPUSH
20923: CALL_OW 266
20927: PUSH
20928: LD_INT 5
20930: EQUAL
20931: IFFALSE 21001
// begin if UnitsInside ( j ) < 3 then
20933: LD_VAR 0 9
20937: PPUSH
20938: CALL_OW 313
20942: PUSH
20943: LD_INT 3
20945: LESS
20946: IFFALSE 20982
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
20948: LD_INT 0
20950: PPUSH
20951: LD_INT 5
20953: PUSH
20954: LD_INT 8
20956: PUSH
20957: LD_INT 9
20959: PUSH
20960: EMPTY
20961: LIST
20962: LIST
20963: LIST
20964: PUSH
20965: LD_VAR 0 17
20969: ARRAY
20970: PPUSH
20971: LD_VAR 0 4
20975: PPUSH
20976: CALL_OW 380
20980: GO 20999
// PrepareHuman ( false , i , skill ) ;
20982: LD_INT 0
20984: PPUSH
20985: LD_VAR 0 8
20989: PPUSH
20990: LD_VAR 0 4
20994: PPUSH
20995: CALL_OW 380
// end else
20999: GO 21018
// PrepareHuman ( false , i , skill ) ;
21001: LD_INT 0
21003: PPUSH
21004: LD_VAR 0 8
21008: PPUSH
21009: LD_VAR 0 4
21013: PPUSH
21014: CALL_OW 380
// un := CreateHuman ;
21018: LD_ADDR_VAR 0 14
21022: PUSH
21023: CALL_OW 44
21027: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21028: LD_ADDR_VAR 0 7
21032: PUSH
21033: LD_VAR 0 7
21037: PPUSH
21038: LD_INT 1
21040: PPUSH
21041: LD_VAR 0 14
21045: PPUSH
21046: CALL_OW 2
21050: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
21051: LD_VAR 0 14
21055: PPUSH
21056: LD_VAR 0 9
21060: PPUSH
21061: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
21065: LD_VAR 0 9
21069: PPUSH
21070: CALL_OW 313
21074: PUSH
21075: LD_INT 6
21077: EQUAL
21078: IFTRUE 21102
21080: PUSH
21081: LD_VAR 0 9
21085: PPUSH
21086: CALL_OW 266
21090: PUSH
21091: LD_INT 32
21093: PUSH
21094: LD_INT 31
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: IN
21101: OR
21102: IFFALSE 20914
21104: GO 20911
21106: POP
21107: POP
// end else
21108: GO 21494
// for j = 1 to x do
21110: LD_ADDR_VAR 0 9
21114: PUSH
21115: DOUBLE
21116: LD_INT 1
21118: DEC
21119: ST_TO_ADDR
21120: LD_VAR 0 13
21124: PUSH
21125: FOR_TO
21126: IFFALSE 21492
// begin InitHc ;
21128: CALL_OW 19
// if not f then
21132: LD_VAR 0 12
21136: NOT
21137: IFFALSE 21226
// begin PrepareHuman ( false , i , skill ) ;
21139: LD_INT 0
21141: PPUSH
21142: LD_VAR 0 8
21146: PPUSH
21147: LD_VAR 0 4
21151: PPUSH
21152: CALL_OW 380
// un := CreateHuman ;
21156: LD_ADDR_VAR 0 14
21160: PUSH
21161: CALL_OW 44
21165: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21166: LD_ADDR_VAR 0 7
21170: PUSH
21171: LD_VAR 0 7
21175: PPUSH
21176: LD_INT 1
21178: PPUSH
21179: LD_VAR 0 14
21183: PPUSH
21184: CALL_OW 2
21188: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21189: LD_VAR 0 14
21193: PPUSH
21194: LD_VAR 0 1
21198: PPUSH
21199: CALL_OW 250
21203: PPUSH
21204: LD_VAR 0 1
21208: PPUSH
21209: CALL_OW 251
21213: PPUSH
21214: LD_INT 10
21216: PPUSH
21217: LD_INT 0
21219: PPUSH
21220: CALL_OW 50
// continue ;
21224: GO 21125
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
21226: LD_VAR 0 12
21230: PUSH
21231: LD_INT 1
21233: ARRAY
21234: PPUSH
21235: CALL_OW 313
21239: IFFALSE 21267
21241: PUSH
21242: LD_VAR 0 12
21246: PUSH
21247: LD_INT 1
21249: ARRAY
21250: PPUSH
21251: CALL_OW 266
21255: PUSH
21256: LD_INT 32
21258: PUSH
21259: LD_INT 31
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: IN
21266: AND
21267: IFTRUE 21288
21269: PUSH
21270: LD_VAR 0 12
21274: PUSH
21275: LD_INT 1
21277: ARRAY
21278: PPUSH
21279: CALL_OW 313
21283: PUSH
21284: LD_INT 6
21286: EQUAL
21287: OR
21288: IFFALSE 21308
// f := Delete ( f , 1 ) ;
21290: LD_ADDR_VAR 0 12
21294: PUSH
21295: LD_VAR 0 12
21299: PPUSH
21300: LD_INT 1
21302: PPUSH
21303: CALL_OW 3
21307: ST_TO_ADDR
// if not f then
21308: LD_VAR 0 12
21312: NOT
21313: IFFALSE 21331
// begin x := x + 2 ;
21315: LD_ADDR_VAR 0 13
21319: PUSH
21320: LD_VAR 0 13
21324: PUSH
21325: LD_INT 2
21327: PLUS
21328: ST_TO_ADDR
// continue ;
21329: GO 21125
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
21331: LD_VAR 0 12
21335: PUSH
21336: LD_INT 1
21338: ARRAY
21339: PPUSH
21340: CALL_OW 266
21344: PUSH
21345: LD_INT 5
21347: EQUAL
21348: IFFALSE 21422
// begin if UnitsInside ( f [ 1 ] ) < 3 then
21350: LD_VAR 0 12
21354: PUSH
21355: LD_INT 1
21357: ARRAY
21358: PPUSH
21359: CALL_OW 313
21363: PUSH
21364: LD_INT 3
21366: LESS
21367: IFFALSE 21403
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
21369: LD_INT 0
21371: PPUSH
21372: LD_INT 5
21374: PUSH
21375: LD_INT 8
21377: PUSH
21378: LD_INT 9
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: LIST
21385: PUSH
21386: LD_VAR 0 17
21390: ARRAY
21391: PPUSH
21392: LD_VAR 0 4
21396: PPUSH
21397: CALL_OW 380
21401: GO 21420
// PrepareHuman ( false , i , skill ) ;
21403: LD_INT 0
21405: PPUSH
21406: LD_VAR 0 8
21410: PPUSH
21411: LD_VAR 0 4
21415: PPUSH
21416: CALL_OW 380
// end else
21420: GO 21439
// PrepareHuman ( false , i , skill ) ;
21422: LD_INT 0
21424: PPUSH
21425: LD_VAR 0 8
21429: PPUSH
21430: LD_VAR 0 4
21434: PPUSH
21435: CALL_OW 380
// un := CreateHuman ;
21439: LD_ADDR_VAR 0 14
21443: PUSH
21444: CALL_OW 44
21448: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
21449: LD_ADDR_VAR 0 7
21453: PUSH
21454: LD_VAR 0 7
21458: PPUSH
21459: LD_INT 1
21461: PPUSH
21462: LD_VAR 0 14
21466: PPUSH
21467: CALL_OW 2
21471: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
21472: LD_VAR 0 14
21476: PPUSH
21477: LD_VAR 0 12
21481: PUSH
21482: LD_INT 1
21484: ARRAY
21485: PPUSH
21486: CALL_OW 52
// end ;
21490: GO 21125
21492: POP
21493: POP
// end ;
21494: GO 20425
21496: POP
21497: POP
// result := result ^ buildings ;
21498: LD_ADDR_VAR 0 7
21502: PUSH
21503: LD_VAR 0 7
21507: PUSH
21508: LD_VAR 0 18
21512: ADD
21513: ST_TO_ADDR
// end else
21514: GO 21657
// begin for i = 1 to personel do
21516: LD_ADDR_VAR 0 8
21520: PUSH
21521: DOUBLE
21522: LD_INT 1
21524: DEC
21525: ST_TO_ADDR
21526: LD_VAR 0 6
21530: PUSH
21531: FOR_TO
21532: IFFALSE 21655
// begin if i > 4 then
21534: LD_VAR 0 8
21538: PUSH
21539: LD_INT 4
21541: GREATER
21542: IFFALSE 21546
// break ;
21544: GO 21655
// x := personel [ i ] ;
21546: LD_ADDR_VAR 0 13
21550: PUSH
21551: LD_VAR 0 6
21555: PUSH
21556: LD_VAR 0 8
21560: ARRAY
21561: ST_TO_ADDR
// if x = - 1 then
21562: LD_VAR 0 13
21566: PUSH
21567: LD_INT 1
21569: NEG
21570: EQUAL
21571: IFFALSE 21575
// continue ;
21573: GO 21531
// PrepareHuman ( false , i , skill ) ;
21575: LD_INT 0
21577: PPUSH
21578: LD_VAR 0 8
21582: PPUSH
21583: LD_VAR 0 4
21587: PPUSH
21588: CALL_OW 380
// un := CreateHuman ;
21592: LD_ADDR_VAR 0 14
21596: PUSH
21597: CALL_OW 44
21601: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
21602: LD_VAR 0 14
21606: PPUSH
21607: LD_VAR 0 1
21611: PPUSH
21612: CALL_OW 250
21616: PPUSH
21617: LD_VAR 0 1
21621: PPUSH
21622: CALL_OW 251
21626: PPUSH
21627: LD_INT 10
21629: PPUSH
21630: LD_INT 0
21632: PPUSH
21633: CALL_OW 50
// result := result ^ un ;
21637: LD_ADDR_VAR 0 7
21641: PUSH
21642: LD_VAR 0 7
21646: PUSH
21647: LD_VAR 0 14
21651: ADD
21652: ST_TO_ADDR
// end ;
21653: GO 21531
21655: POP
21656: POP
// end ; end ;
21657: LD_VAR 0 7
21661: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
21662: LD_INT 0
21664: PPUSH
21665: PPUSH
21666: PPUSH
21667: PPUSH
21668: PPUSH
21669: PPUSH
21670: PPUSH
21671: PPUSH
21672: PPUSH
21673: PPUSH
21674: PPUSH
21675: PPUSH
21676: PPUSH
21677: PPUSH
21678: PPUSH
21679: PPUSH
// result := false ;
21680: LD_ADDR_VAR 0 3
21684: PUSH
21685: LD_INT 0
21687: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
21688: LD_VAR 0 1
21692: NOT
21693: IFTRUE 21718
21695: PUSH
21696: LD_VAR 0 1
21700: PPUSH
21701: CALL_OW 266
21705: PUSH
21706: LD_INT 32
21708: PUSH
21709: LD_INT 33
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: IN
21716: NOT
21717: OR
21718: IFFALSE 21722
// exit ;
21720: GO 22857
// nat := GetNation ( tower ) ;
21722: LD_ADDR_VAR 0 12
21726: PUSH
21727: LD_VAR 0 1
21731: PPUSH
21732: CALL_OW 248
21736: ST_TO_ADDR
// side := GetSide ( tower ) ;
21737: LD_ADDR_VAR 0 16
21741: PUSH
21742: LD_VAR 0 1
21746: PPUSH
21747: CALL_OW 255
21751: ST_TO_ADDR
// x := GetX ( tower ) ;
21752: LD_ADDR_VAR 0 10
21756: PUSH
21757: LD_VAR 0 1
21761: PPUSH
21762: CALL_OW 250
21766: ST_TO_ADDR
// y := GetY ( tower ) ;
21767: LD_ADDR_VAR 0 11
21771: PUSH
21772: LD_VAR 0 1
21776: PPUSH
21777: CALL_OW 251
21781: ST_TO_ADDR
// if not x or not y then
21782: LD_VAR 0 10
21786: NOT
21787: IFTRUE 21796
21789: PUSH
21790: LD_VAR 0 11
21794: NOT
21795: OR
21796: IFFALSE 21800
// exit ;
21798: GO 22857
// weapon := 0 ;
21800: LD_ADDR_VAR 0 18
21804: PUSH
21805: LD_INT 0
21807: ST_TO_ADDR
// fac_list := [ ] ;
21808: LD_ADDR_VAR 0 17
21812: PUSH
21813: EMPTY
21814: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
21815: LD_ADDR_VAR 0 6
21819: PUSH
21820: LD_VAR 0 1
21824: PPUSH
21825: CALL_OW 274
21829: PPUSH
21830: LD_VAR 0 2
21834: PPUSH
21835: LD_INT 0
21837: PPUSH
21838: CALL 19392 0 3
21842: PPUSH
21843: LD_INT 30
21845: PUSH
21846: LD_INT 3
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: PPUSH
21853: CALL_OW 72
21857: ST_TO_ADDR
// if not factories then
21858: LD_VAR 0 6
21862: NOT
21863: IFFALSE 21867
// exit ;
21865: GO 22857
// for i in factories do
21867: LD_ADDR_VAR 0 8
21871: PUSH
21872: LD_VAR 0 6
21876: PUSH
21877: FOR_IN
21878: IFFALSE 21903
// fac_list := fac_list union AvailableWeaponList ( i ) ;
21880: LD_ADDR_VAR 0 17
21884: PUSH
21885: LD_VAR 0 17
21889: PUSH
21890: LD_VAR 0 8
21894: PPUSH
21895: CALL_OW 478
21899: UNION
21900: ST_TO_ADDR
21901: GO 21877
21903: POP
21904: POP
// if not fac_list then
21905: LD_VAR 0 17
21909: NOT
21910: IFFALSE 21914
// exit ;
21912: GO 22857
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
21914: LD_ADDR_VAR 0 5
21918: PUSH
21919: LD_INT 4
21921: PUSH
21922: LD_INT 5
21924: PUSH
21925: LD_INT 9
21927: PUSH
21928: LD_INT 10
21930: PUSH
21931: LD_INT 6
21933: PUSH
21934: LD_INT 7
21936: PUSH
21937: LD_INT 11
21939: PUSH
21940: EMPTY
21941: LIST
21942: LIST
21943: LIST
21944: LIST
21945: LIST
21946: LIST
21947: LIST
21948: PUSH
21949: LD_INT 27
21951: PUSH
21952: LD_INT 28
21954: PUSH
21955: LD_INT 26
21957: PUSH
21958: LD_INT 30
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: LIST
21965: LIST
21966: PUSH
21967: LD_INT 43
21969: PUSH
21970: LD_INT 44
21972: PUSH
21973: LD_INT 46
21975: PUSH
21976: LD_INT 45
21978: PUSH
21979: LD_INT 47
21981: PUSH
21982: LD_INT 49
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: LIST
21997: PUSH
21998: LD_VAR 0 12
22002: ARRAY
22003: ST_TO_ADDR
// list := list isect fac_list ;
22004: LD_ADDR_VAR 0 5
22008: PUSH
22009: LD_VAR 0 5
22013: PUSH
22014: LD_VAR 0 17
22018: ISECT
22019: ST_TO_ADDR
// if not list then
22020: LD_VAR 0 5
22024: NOT
22025: IFFALSE 22029
// exit ;
22027: GO 22857
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
22029: LD_VAR 0 12
22033: PUSH
22034: LD_INT 3
22036: EQUAL
22037: IFFALSE 22049
22039: PUSH
22040: LD_INT 49
22042: PUSH
22043: LD_VAR 0 5
22047: IN
22048: AND
22049: IFFALSE 22069
22051: PUSH
22052: LD_INT 31
22054: PPUSH
22055: LD_VAR 0 16
22059: PPUSH
22060: CALL_OW 321
22064: PUSH
22065: LD_INT 2
22067: EQUAL
22068: AND
22069: IFFALSE 22129
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
22071: LD_INT 22
22073: PUSH
22074: LD_VAR 0 16
22078: PUSH
22079: EMPTY
22080: LIST
22081: LIST
22082: PUSH
22083: LD_INT 35
22085: PUSH
22086: LD_INT 49
22088: PUSH
22089: EMPTY
22090: LIST
22091: LIST
22092: PUSH
22093: LD_INT 91
22095: PUSH
22096: LD_VAR 0 1
22100: PUSH
22101: LD_INT 10
22103: PUSH
22104: EMPTY
22105: LIST
22106: LIST
22107: LIST
22108: PUSH
22109: EMPTY
22110: LIST
22111: LIST
22112: LIST
22113: PPUSH
22114: CALL_OW 69
22118: NOT
22119: IFFALSE 22129
// weapon := ru_time_lapser ;
22121: LD_ADDR_VAR 0 18
22125: PUSH
22126: LD_INT 49
22128: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
22129: LD_VAR 0 12
22133: PUSH
22134: LD_INT 1
22136: PUSH
22137: LD_INT 2
22139: PUSH
22140: EMPTY
22141: LIST
22142: LIST
22143: IN
22144: IFFALSE 22168
22146: PUSH
22147: LD_INT 11
22149: PUSH
22150: LD_VAR 0 5
22154: IN
22155: IFTRUE 22167
22157: PUSH
22158: LD_INT 30
22160: PUSH
22161: LD_VAR 0 5
22165: IN
22166: OR
22167: AND
22168: IFFALSE 22188
22170: PUSH
22171: LD_INT 6
22173: PPUSH
22174: LD_VAR 0 16
22178: PPUSH
22179: CALL_OW 321
22183: PUSH
22184: LD_INT 2
22186: EQUAL
22187: AND
22188: IFFALSE 22355
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
22190: LD_INT 22
22192: PUSH
22193: LD_VAR 0 16
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 2
22204: PUSH
22205: LD_INT 35
22207: PUSH
22208: LD_INT 11
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: PUSH
22215: LD_INT 35
22217: PUSH
22218: LD_INT 30
22220: PUSH
22221: EMPTY
22222: LIST
22223: LIST
22224: PUSH
22225: EMPTY
22226: LIST
22227: LIST
22228: LIST
22229: PUSH
22230: LD_INT 91
22232: PUSH
22233: LD_VAR 0 1
22237: PUSH
22238: LD_INT 18
22240: PUSH
22241: EMPTY
22242: LIST
22243: LIST
22244: LIST
22245: PUSH
22246: EMPTY
22247: LIST
22248: LIST
22249: LIST
22250: PPUSH
22251: CALL_OW 69
22255: NOT
22256: IFFALSE 22332
22258: PUSH
22259: LD_INT 22
22261: PUSH
22262: LD_VAR 0 16
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: PUSH
22271: LD_INT 2
22273: PUSH
22274: LD_INT 30
22276: PUSH
22277: LD_INT 32
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: PUSH
22284: LD_INT 30
22286: PUSH
22287: LD_INT 33
22289: PUSH
22290: EMPTY
22291: LIST
22292: LIST
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: LIST
22298: PUSH
22299: LD_INT 91
22301: PUSH
22302: LD_VAR 0 1
22306: PUSH
22307: LD_INT 12
22309: PUSH
22310: EMPTY
22311: LIST
22312: LIST
22313: LIST
22314: PUSH
22315: EMPTY
22316: LIST
22317: LIST
22318: LIST
22319: PUSH
22320: EMPTY
22321: LIST
22322: PPUSH
22323: CALL_OW 69
22327: PUSH
22328: LD_INT 2
22330: GREATER
22331: AND
22332: IFFALSE 22355
// weapon := [ us_radar , ar_radar ] [ nat ] ;
22334: LD_ADDR_VAR 0 18
22338: PUSH
22339: LD_INT 11
22341: PUSH
22342: LD_INT 30
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: PUSH
22349: LD_VAR 0 12
22353: ARRAY
22354: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
22355: LD_VAR 0 18
22359: NOT
22360: IFFALSE 22380
22362: PUSH
22363: LD_INT 40
22365: PPUSH
22366: LD_VAR 0 16
22370: PPUSH
22371: CALL_OW 321
22375: PUSH
22376: LD_INT 2
22378: EQUAL
22379: AND
22380: IFFALSE 22416
22382: PUSH
22383: LD_INT 7
22385: PUSH
22386: LD_VAR 0 5
22390: IN
22391: IFTRUE 22403
22393: PUSH
22394: LD_INT 28
22396: PUSH
22397: LD_VAR 0 5
22401: IN
22402: OR
22403: IFTRUE 22415
22405: PUSH
22406: LD_INT 45
22408: PUSH
22409: LD_VAR 0 5
22413: IN
22414: OR
22415: AND
22416: IFFALSE 22670
// begin hex := GetHexInfo ( x , y ) ;
22418: LD_ADDR_VAR 0 4
22422: PUSH
22423: LD_VAR 0 10
22427: PPUSH
22428: LD_VAR 0 11
22432: PPUSH
22433: CALL_OW 546
22437: ST_TO_ADDR
// if hex [ 1 ] then
22438: LD_VAR 0 4
22442: PUSH
22443: LD_INT 1
22445: ARRAY
22446: IFFALSE 22450
// exit ;
22448: GO 22857
// height := hex [ 2 ] ;
22450: LD_ADDR_VAR 0 15
22454: PUSH
22455: LD_VAR 0 4
22459: PUSH
22460: LD_INT 2
22462: ARRAY
22463: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
22464: LD_ADDR_VAR 0 14
22468: PUSH
22469: LD_INT 0
22471: PUSH
22472: LD_INT 2
22474: PUSH
22475: LD_INT 3
22477: PUSH
22478: LD_INT 5
22480: PUSH
22481: EMPTY
22482: LIST
22483: LIST
22484: LIST
22485: LIST
22486: ST_TO_ADDR
// for i in tmp do
22487: LD_ADDR_VAR 0 8
22491: PUSH
22492: LD_VAR 0 14
22496: PUSH
22497: FOR_IN
22498: IFFALSE 22668
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
22500: LD_ADDR_VAR 0 9
22504: PUSH
22505: LD_VAR 0 10
22509: PPUSH
22510: LD_VAR 0 8
22514: PPUSH
22515: LD_INT 5
22517: PPUSH
22518: CALL_OW 272
22522: PUSH
22523: LD_VAR 0 11
22527: PPUSH
22528: LD_VAR 0 8
22532: PPUSH
22533: LD_INT 5
22535: PPUSH
22536: CALL_OW 273
22540: PUSH
22541: EMPTY
22542: LIST
22543: LIST
22544: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
22545: LD_VAR 0 9
22549: PUSH
22550: LD_INT 1
22552: ARRAY
22553: PPUSH
22554: LD_VAR 0 9
22558: PUSH
22559: LD_INT 2
22561: ARRAY
22562: PPUSH
22563: CALL_OW 488
22567: IFFALSE 22666
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
22569: LD_ADDR_VAR 0 4
22573: PUSH
22574: LD_VAR 0 9
22578: PUSH
22579: LD_INT 1
22581: ARRAY
22582: PPUSH
22583: LD_VAR 0 9
22587: PUSH
22588: LD_INT 2
22590: ARRAY
22591: PPUSH
22592: CALL_OW 546
22596: ST_TO_ADDR
// if hex [ 1 ] then
22597: LD_VAR 0 4
22601: PUSH
22602: LD_INT 1
22604: ARRAY
22605: IFFALSE 22609
// continue ;
22607: GO 22497
// h := hex [ 2 ] ;
22609: LD_ADDR_VAR 0 13
22613: PUSH
22614: LD_VAR 0 4
22618: PUSH
22619: LD_INT 2
22621: ARRAY
22622: ST_TO_ADDR
// if h + 7 < height then
22623: LD_VAR 0 13
22627: PUSH
22628: LD_INT 7
22630: PLUS
22631: PUSH
22632: LD_VAR 0 15
22636: LESS
22637: IFFALSE 22666
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
22639: LD_ADDR_VAR 0 18
22643: PUSH
22644: LD_INT 7
22646: PUSH
22647: LD_INT 28
22649: PUSH
22650: LD_INT 45
22652: PUSH
22653: EMPTY
22654: LIST
22655: LIST
22656: LIST
22657: PUSH
22658: LD_VAR 0 12
22662: ARRAY
22663: ST_TO_ADDR
// break ;
22664: GO 22668
// end ; end ; end ;
22666: GO 22497
22668: POP
22669: POP
// end ; if not weapon then
22670: LD_VAR 0 18
22674: NOT
22675: IFFALSE 22735
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
22677: LD_ADDR_VAR 0 5
22681: PUSH
22682: LD_VAR 0 5
22686: PUSH
22687: LD_INT 11
22689: PUSH
22690: LD_INT 30
22692: PUSH
22693: LD_INT 49
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: DIFF
22701: ST_TO_ADDR
// if not list then
22702: LD_VAR 0 5
22706: NOT
22707: IFFALSE 22711
// exit ;
22709: GO 22857
// weapon := list [ rand ( 1 , list ) ] ;
22711: LD_ADDR_VAR 0 18
22715: PUSH
22716: LD_VAR 0 5
22720: PUSH
22721: LD_INT 1
22723: PPUSH
22724: LD_VAR 0 5
22728: PPUSH
22729: CALL_OW 12
22733: ARRAY
22734: ST_TO_ADDR
// end ; if weapon then
22735: LD_VAR 0 18
22739: IFFALSE 22857
// begin tmp := CostOfWeapon ( weapon ) ;
22741: LD_ADDR_VAR 0 14
22745: PUSH
22746: LD_VAR 0 18
22750: PPUSH
22751: CALL_OW 451
22755: ST_TO_ADDR
// j := GetBase ( tower ) ;
22756: LD_ADDR_VAR 0 9
22760: PUSH
22761: LD_VAR 0 1
22765: PPUSH
22766: CALL_OW 274
22770: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
22771: LD_VAR 0 9
22775: PPUSH
22776: LD_INT 1
22778: PPUSH
22779: CALL_OW 275
22783: PUSH
22784: LD_VAR 0 14
22788: PUSH
22789: LD_INT 1
22791: ARRAY
22792: GREATEREQUAL
22793: IFFALSE 22819
22795: PUSH
22796: LD_VAR 0 9
22800: PPUSH
22801: LD_INT 2
22803: PPUSH
22804: CALL_OW 275
22808: PUSH
22809: LD_VAR 0 14
22813: PUSH
22814: LD_INT 2
22816: ARRAY
22817: GREATEREQUAL
22818: AND
22819: IFFALSE 22845
22821: PUSH
22822: LD_VAR 0 9
22826: PPUSH
22827: LD_INT 3
22829: PPUSH
22830: CALL_OW 275
22834: PUSH
22835: LD_VAR 0 14
22839: PUSH
22840: LD_INT 3
22842: ARRAY
22843: GREATEREQUAL
22844: AND
22845: IFFALSE 22857
// result := weapon ;
22847: LD_ADDR_VAR 0 3
22851: PUSH
22852: LD_VAR 0 18
22856: ST_TO_ADDR
// end ; end ;
22857: LD_VAR 0 3
22861: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
22862: LD_INT 0
22864: PPUSH
22865: PPUSH
// result := true ;
22866: LD_ADDR_VAR 0 3
22870: PUSH
22871: LD_INT 1
22873: ST_TO_ADDR
// if array1 = array2 then
22874: LD_VAR 0 1
22878: PUSH
22879: LD_VAR 0 2
22883: EQUAL
22884: IFFALSE 22944
// begin for i = 1 to array1 do
22886: LD_ADDR_VAR 0 4
22890: PUSH
22891: DOUBLE
22892: LD_INT 1
22894: DEC
22895: ST_TO_ADDR
22896: LD_VAR 0 1
22900: PUSH
22901: FOR_TO
22902: IFFALSE 22940
// if array1 [ i ] <> array2 [ i ] then
22904: LD_VAR 0 1
22908: PUSH
22909: LD_VAR 0 4
22913: ARRAY
22914: PUSH
22915: LD_VAR 0 2
22919: PUSH
22920: LD_VAR 0 4
22924: ARRAY
22925: NONEQUAL
22926: IFFALSE 22938
// begin result := false ;
22928: LD_ADDR_VAR 0 3
22932: PUSH
22933: LD_INT 0
22935: ST_TO_ADDR
// break ;
22936: GO 22940
// end ;
22938: GO 22901
22940: POP
22941: POP
// end else
22942: GO 22952
// result := false ;
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_INT 0
22951: ST_TO_ADDR
// end ;
22952: LD_VAR 0 3
22956: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
22957: LD_INT 0
22959: PPUSH
22960: PPUSH
// if not array1 or not array2 then
22961: LD_VAR 0 1
22965: NOT
22966: IFTRUE 22975
22968: PUSH
22969: LD_VAR 0 2
22973: NOT
22974: OR
22975: IFFALSE 22979
// exit ;
22977: GO 23043
// result := true ;
22979: LD_ADDR_VAR 0 3
22983: PUSH
22984: LD_INT 1
22986: ST_TO_ADDR
// for i = 1 to array1 do
22987: LD_ADDR_VAR 0 4
22991: PUSH
22992: DOUBLE
22993: LD_INT 1
22995: DEC
22996: ST_TO_ADDR
22997: LD_VAR 0 1
23001: PUSH
23002: FOR_TO
23003: IFFALSE 23041
// if array1 [ i ] <> array2 [ i ] then
23005: LD_VAR 0 1
23009: PUSH
23010: LD_VAR 0 4
23014: ARRAY
23015: PUSH
23016: LD_VAR 0 2
23020: PUSH
23021: LD_VAR 0 4
23025: ARRAY
23026: NONEQUAL
23027: IFFALSE 23039
// begin result := false ;
23029: LD_ADDR_VAR 0 3
23033: PUSH
23034: LD_INT 0
23036: ST_TO_ADDR
// break ;
23037: GO 23041
// end ;
23039: GO 23002
23041: POP
23042: POP
// end ;
23043: LD_VAR 0 3
23047: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
23048: LD_INT 0
23050: PPUSH
23051: PPUSH
23052: PPUSH
// pom := GetBase ( fac ) ;
23053: LD_ADDR_VAR 0 5
23057: PUSH
23058: LD_VAR 0 1
23062: PPUSH
23063: CALL_OW 274
23067: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
23068: LD_ADDR_VAR 0 4
23072: PUSH
23073: LD_VAR 0 2
23077: PUSH
23078: LD_INT 1
23080: ARRAY
23081: PPUSH
23082: LD_VAR 0 2
23086: PUSH
23087: LD_INT 2
23089: ARRAY
23090: PPUSH
23091: LD_VAR 0 2
23095: PUSH
23096: LD_INT 3
23098: ARRAY
23099: PPUSH
23100: LD_VAR 0 2
23104: PUSH
23105: LD_INT 4
23107: ARRAY
23108: PPUSH
23109: CALL_OW 449
23113: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23114: LD_ADDR_VAR 0 3
23118: PUSH
23119: LD_VAR 0 5
23123: PPUSH
23124: LD_INT 1
23126: PPUSH
23127: CALL_OW 275
23131: PUSH
23132: LD_VAR 0 4
23136: PUSH
23137: LD_INT 1
23139: ARRAY
23140: GREATEREQUAL
23141: IFFALSE 23167
23143: PUSH
23144: LD_VAR 0 5
23148: PPUSH
23149: LD_INT 2
23151: PPUSH
23152: CALL_OW 275
23156: PUSH
23157: LD_VAR 0 4
23161: PUSH
23162: LD_INT 2
23164: ARRAY
23165: GREATEREQUAL
23166: AND
23167: IFFALSE 23193
23169: PUSH
23170: LD_VAR 0 5
23174: PPUSH
23175: LD_INT 3
23177: PPUSH
23178: CALL_OW 275
23182: PUSH
23183: LD_VAR 0 4
23187: PUSH
23188: LD_INT 3
23190: ARRAY
23191: GREATEREQUAL
23192: AND
23193: ST_TO_ADDR
// end ;
23194: LD_VAR 0 3
23198: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
23199: LD_INT 0
23201: PPUSH
23202: PPUSH
23203: PPUSH
23204: PPUSH
// pom := GetBase ( building ) ;
23205: LD_ADDR_VAR 0 3
23209: PUSH
23210: LD_VAR 0 1
23214: PPUSH
23215: CALL_OW 274
23219: ST_TO_ADDR
// if not pom then
23220: LD_VAR 0 3
23224: NOT
23225: IFFALSE 23229
// exit ;
23227: GO 23403
// btype := GetBType ( building ) ;
23229: LD_ADDR_VAR 0 5
23233: PUSH
23234: LD_VAR 0 1
23238: PPUSH
23239: CALL_OW 266
23243: ST_TO_ADDR
// if btype = b_armoury then
23244: LD_VAR 0 5
23248: PUSH
23249: LD_INT 4
23251: EQUAL
23252: IFFALSE 23262
// btype := b_barracks ;
23254: LD_ADDR_VAR 0 5
23258: PUSH
23259: LD_INT 5
23261: ST_TO_ADDR
// if btype = b_depot then
23262: LD_VAR 0 5
23266: PUSH
23267: LD_INT 0
23269: EQUAL
23270: IFFALSE 23280
// btype := b_warehouse ;
23272: LD_ADDR_VAR 0 5
23276: PUSH
23277: LD_INT 1
23279: ST_TO_ADDR
// if btype = b_workshop then
23280: LD_VAR 0 5
23284: PUSH
23285: LD_INT 2
23287: EQUAL
23288: IFFALSE 23298
// btype := b_factory ;
23290: LD_ADDR_VAR 0 5
23294: PUSH
23295: LD_INT 3
23297: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23298: LD_ADDR_VAR 0 4
23302: PUSH
23303: LD_VAR 0 5
23307: PPUSH
23308: LD_VAR 0 1
23312: PPUSH
23313: CALL_OW 248
23317: PPUSH
23318: CALL_OW 450
23322: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23323: LD_ADDR_VAR 0 2
23327: PUSH
23328: LD_VAR 0 3
23332: PPUSH
23333: LD_INT 1
23335: PPUSH
23336: CALL_OW 275
23340: PUSH
23341: LD_VAR 0 4
23345: PUSH
23346: LD_INT 1
23348: ARRAY
23349: GREATEREQUAL
23350: IFFALSE 23376
23352: PUSH
23353: LD_VAR 0 3
23357: PPUSH
23358: LD_INT 2
23360: PPUSH
23361: CALL_OW 275
23365: PUSH
23366: LD_VAR 0 4
23370: PUSH
23371: LD_INT 2
23373: ARRAY
23374: GREATEREQUAL
23375: AND
23376: IFFALSE 23402
23378: PUSH
23379: LD_VAR 0 3
23383: PPUSH
23384: LD_INT 3
23386: PPUSH
23387: CALL_OW 275
23391: PUSH
23392: LD_VAR 0 4
23396: PUSH
23397: LD_INT 3
23399: ARRAY
23400: GREATEREQUAL
23401: AND
23402: ST_TO_ADDR
// end ;
23403: LD_VAR 0 2
23407: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
23408: LD_INT 0
23410: PPUSH
23411: PPUSH
23412: PPUSH
// pom := GetBase ( building ) ;
23413: LD_ADDR_VAR 0 4
23417: PUSH
23418: LD_VAR 0 1
23422: PPUSH
23423: CALL_OW 274
23427: ST_TO_ADDR
// if not pom then
23428: LD_VAR 0 4
23432: NOT
23433: IFFALSE 23437
// exit ;
23435: GO 23542
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
23437: LD_ADDR_VAR 0 5
23441: PUSH
23442: LD_VAR 0 2
23446: PPUSH
23447: LD_VAR 0 1
23451: PPUSH
23452: CALL_OW 248
23456: PPUSH
23457: CALL_OW 450
23461: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
23462: LD_ADDR_VAR 0 3
23466: PUSH
23467: LD_VAR 0 4
23471: PPUSH
23472: LD_INT 1
23474: PPUSH
23475: CALL_OW 275
23479: PUSH
23480: LD_VAR 0 5
23484: PUSH
23485: LD_INT 1
23487: ARRAY
23488: GREATEREQUAL
23489: IFFALSE 23515
23491: PUSH
23492: LD_VAR 0 4
23496: PPUSH
23497: LD_INT 2
23499: PPUSH
23500: CALL_OW 275
23504: PUSH
23505: LD_VAR 0 5
23509: PUSH
23510: LD_INT 2
23512: ARRAY
23513: GREATEREQUAL
23514: AND
23515: IFFALSE 23541
23517: PUSH
23518: LD_VAR 0 4
23522: PPUSH
23523: LD_INT 3
23525: PPUSH
23526: CALL_OW 275
23530: PUSH
23531: LD_VAR 0 5
23535: PUSH
23536: LD_INT 3
23538: ARRAY
23539: GREATEREQUAL
23540: AND
23541: ST_TO_ADDR
// end ;
23542: LD_VAR 0 3
23546: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
23547: LD_INT 0
23549: PPUSH
23550: PPUSH
23551: PPUSH
23552: PPUSH
23553: PPUSH
23554: PPUSH
23555: PPUSH
23556: PPUSH
23557: PPUSH
23558: PPUSH
23559: PPUSH
// result := false ;
23560: LD_ADDR_VAR 0 8
23564: PUSH
23565: LD_INT 0
23567: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
23568: LD_VAR 0 5
23572: NOT
23573: IFTRUE 23582
23575: PUSH
23576: LD_VAR 0 1
23580: NOT
23581: OR
23582: IFTRUE 23591
23584: PUSH
23585: LD_VAR 0 2
23589: NOT
23590: OR
23591: IFTRUE 23600
23593: PUSH
23594: LD_VAR 0 3
23598: NOT
23599: OR
23600: IFFALSE 23604
// exit ;
23602: GO 24430
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
23604: LD_ADDR_VAR 0 14
23608: PUSH
23609: LD_VAR 0 1
23613: PPUSH
23614: LD_VAR 0 2
23618: PPUSH
23619: LD_VAR 0 3
23623: PPUSH
23624: LD_VAR 0 4
23628: PPUSH
23629: LD_VAR 0 5
23633: PUSH
23634: LD_INT 1
23636: ARRAY
23637: PPUSH
23638: CALL_OW 248
23642: PPUSH
23643: LD_INT 0
23645: PPUSH
23646: CALL 25711 0 6
23650: ST_TO_ADDR
// if not hexes then
23651: LD_VAR 0 14
23655: NOT
23656: IFFALSE 23660
// exit ;
23658: GO 24430
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
23660: LD_ADDR_VAR 0 17
23664: PUSH
23665: LD_VAR 0 5
23669: PPUSH
23670: LD_INT 22
23672: PUSH
23673: LD_VAR 0 13
23677: PPUSH
23678: CALL_OW 255
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: PUSH
23687: LD_INT 2
23689: PUSH
23690: LD_INT 30
23692: PUSH
23693: LD_INT 0
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PUSH
23700: LD_INT 30
23702: PUSH
23703: LD_INT 1
23705: PUSH
23706: EMPTY
23707: LIST
23708: LIST
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: LIST
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PPUSH
23719: CALL_OW 72
23723: ST_TO_ADDR
// for i = 1 to hexes do
23724: LD_ADDR_VAR 0 9
23728: PUSH
23729: DOUBLE
23730: LD_INT 1
23732: DEC
23733: ST_TO_ADDR
23734: LD_VAR 0 14
23738: PUSH
23739: FOR_TO
23740: IFFALSE 24428
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
23742: LD_ADDR_VAR 0 13
23746: PUSH
23747: LD_VAR 0 14
23751: PUSH
23752: LD_VAR 0 9
23756: ARRAY
23757: PUSH
23758: LD_INT 1
23760: ARRAY
23761: PPUSH
23762: LD_VAR 0 14
23766: PUSH
23767: LD_VAR 0 9
23771: ARRAY
23772: PUSH
23773: LD_INT 2
23775: ARRAY
23776: PPUSH
23777: CALL_OW 428
23781: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
23782: LD_VAR 0 14
23786: PUSH
23787: LD_VAR 0 9
23791: ARRAY
23792: PUSH
23793: LD_INT 1
23795: ARRAY
23796: PPUSH
23797: LD_VAR 0 14
23801: PUSH
23802: LD_VAR 0 9
23806: ARRAY
23807: PUSH
23808: LD_INT 2
23810: ARRAY
23811: PPUSH
23812: CALL_OW 351
23816: IFTRUE 23855
23818: PUSH
23819: LD_VAR 0 14
23823: PUSH
23824: LD_VAR 0 9
23828: ARRAY
23829: PUSH
23830: LD_INT 1
23832: ARRAY
23833: PPUSH
23834: LD_VAR 0 14
23838: PUSH
23839: LD_VAR 0 9
23843: ARRAY
23844: PUSH
23845: LD_INT 2
23847: ARRAY
23848: PPUSH
23849: CALL_OW 488
23853: NOT
23854: OR
23855: IFTRUE 23872
23857: PUSH
23858: LD_VAR 0 13
23862: PPUSH
23863: CALL_OW 247
23867: PUSH
23868: LD_INT 3
23870: EQUAL
23871: OR
23872: IFFALSE 23878
// exit ;
23874: POP
23875: POP
23876: GO 24430
// if not tmp then
23878: LD_VAR 0 13
23882: NOT
23883: IFFALSE 23887
// continue ;
23885: GO 23739
// result := true ;
23887: LD_ADDR_VAR 0 8
23891: PUSH
23892: LD_INT 1
23894: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
23895: LD_VAR 0 6
23899: IFFALSE 23916
23901: PUSH
23902: LD_VAR 0 13
23906: PPUSH
23907: CALL_OW 247
23911: PUSH
23912: LD_INT 2
23914: EQUAL
23915: AND
23916: IFFALSE 23933
23918: PUSH
23919: LD_VAR 0 13
23923: PPUSH
23924: CALL_OW 263
23928: PUSH
23929: LD_INT 1
23931: EQUAL
23932: AND
23933: IFFALSE 24097
// begin if IsDrivenBy ( tmp ) then
23935: LD_VAR 0 13
23939: PPUSH
23940: CALL_OW 311
23944: IFFALSE 23948
// continue ;
23946: GO 23739
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
23948: LD_VAR 0 6
23952: PPUSH
23953: LD_INT 3
23955: PUSH
23956: LD_INT 60
23958: PUSH
23959: EMPTY
23960: LIST
23961: PUSH
23962: EMPTY
23963: LIST
23964: LIST
23965: PUSH
23966: LD_INT 3
23968: PUSH
23969: LD_INT 55
23971: PUSH
23972: EMPTY
23973: LIST
23974: PUSH
23975: EMPTY
23976: LIST
23977: LIST
23978: PUSH
23979: EMPTY
23980: LIST
23981: LIST
23982: PPUSH
23983: CALL_OW 72
23987: IFFALSE 24095
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
23989: LD_ADDR_VAR 0 18
23993: PUSH
23994: LD_VAR 0 6
23998: PPUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 60
24004: PUSH
24005: EMPTY
24006: LIST
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 3
24014: PUSH
24015: LD_INT 55
24017: PUSH
24018: EMPTY
24019: LIST
24020: PUSH
24021: EMPTY
24022: LIST
24023: LIST
24024: PUSH
24025: EMPTY
24026: LIST
24027: LIST
24028: PPUSH
24029: CALL_OW 72
24033: PUSH
24034: LD_INT 1
24036: ARRAY
24037: ST_TO_ADDR
// if IsInUnit ( driver ) then
24038: LD_VAR 0 18
24042: PPUSH
24043: CALL_OW 310
24047: IFFALSE 24058
// ComExit ( driver ) ;
24049: LD_VAR 0 18
24053: PPUSH
24054: CALL 49701 0 1
// AddComEnterUnit ( driver , tmp ) ;
24058: LD_VAR 0 18
24062: PPUSH
24063: LD_VAR 0 13
24067: PPUSH
24068: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
24072: LD_VAR 0 18
24076: PPUSH
24077: LD_VAR 0 7
24081: PPUSH
24082: CALL_OW 173
// AddComExitVehicle ( driver ) ;
24086: LD_VAR 0 18
24090: PPUSH
24091: CALL_OW 181
// end ; continue ;
24095: GO 23739
// end ; if not cleaners or not tmp in cleaners then
24097: LD_VAR 0 6
24101: NOT
24102: IFTRUE 24117
24104: PUSH
24105: LD_VAR 0 13
24109: PUSH
24110: LD_VAR 0 6
24114: IN
24115: NOT
24116: OR
24117: IFFALSE 24426
// begin if dep then
24119: LD_VAR 0 17
24123: IFFALSE 24259
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
24125: LD_ADDR_VAR 0 16
24129: PUSH
24130: LD_VAR 0 17
24134: PUSH
24135: LD_INT 1
24137: ARRAY
24138: PPUSH
24139: CALL_OW 250
24143: PPUSH
24144: LD_VAR 0 17
24148: PUSH
24149: LD_INT 1
24151: ARRAY
24152: PPUSH
24153: CALL_OW 254
24157: PPUSH
24158: LD_INT 5
24160: PPUSH
24161: CALL_OW 272
24165: PUSH
24166: LD_VAR 0 17
24170: PUSH
24171: LD_INT 1
24173: ARRAY
24174: PPUSH
24175: CALL_OW 251
24179: PPUSH
24180: LD_VAR 0 17
24184: PUSH
24185: LD_INT 1
24187: ARRAY
24188: PPUSH
24189: CALL_OW 254
24193: PPUSH
24194: LD_INT 5
24196: PPUSH
24197: CALL_OW 273
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
24206: LD_VAR 0 16
24210: PUSH
24211: LD_INT 1
24213: ARRAY
24214: PPUSH
24215: LD_VAR 0 16
24219: PUSH
24220: LD_INT 2
24222: ARRAY
24223: PPUSH
24224: CALL_OW 488
24228: IFFALSE 24259
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
24230: LD_VAR 0 13
24234: PPUSH
24235: LD_VAR 0 16
24239: PUSH
24240: LD_INT 1
24242: ARRAY
24243: PPUSH
24244: LD_VAR 0 16
24248: PUSH
24249: LD_INT 2
24251: ARRAY
24252: PPUSH
24253: CALL_OW 111
// continue ;
24257: GO 23739
// end ; end ; r := GetDir ( tmp ) ;
24259: LD_ADDR_VAR 0 15
24263: PUSH
24264: LD_VAR 0 13
24268: PPUSH
24269: CALL_OW 254
24273: ST_TO_ADDR
// if r = 5 then
24274: LD_VAR 0 15
24278: PUSH
24279: LD_INT 5
24281: EQUAL
24282: IFFALSE 24292
// r := 0 ;
24284: LD_ADDR_VAR 0 15
24288: PUSH
24289: LD_INT 0
24291: ST_TO_ADDR
// for j = r to 5 do
24292: LD_ADDR_VAR 0 10
24296: PUSH
24297: DOUBLE
24298: LD_VAR 0 15
24302: DEC
24303: ST_TO_ADDR
24304: LD_INT 5
24306: PUSH
24307: FOR_TO
24308: IFFALSE 24424
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
24310: LD_ADDR_VAR 0 11
24314: PUSH
24315: LD_VAR 0 13
24319: PPUSH
24320: CALL_OW 250
24324: PPUSH
24325: LD_VAR 0 10
24329: PPUSH
24330: LD_INT 2
24332: PPUSH
24333: CALL_OW 272
24337: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
24338: LD_ADDR_VAR 0 12
24342: PUSH
24343: LD_VAR 0 13
24347: PPUSH
24348: CALL_OW 251
24352: PPUSH
24353: LD_VAR 0 10
24357: PPUSH
24358: LD_INT 2
24360: PPUSH
24361: CALL_OW 273
24365: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
24366: LD_VAR 0 11
24370: PPUSH
24371: LD_VAR 0 12
24375: PPUSH
24376: CALL_OW 488
24380: IFFALSE 24399
24382: PUSH
24383: LD_VAR 0 11
24387: PPUSH
24388: LD_VAR 0 12
24392: PPUSH
24393: CALL_OW 428
24397: NOT
24398: AND
24399: IFFALSE 24422
// begin ComMoveXY ( tmp , _x , _y ) ;
24401: LD_VAR 0 13
24405: PPUSH
24406: LD_VAR 0 11
24410: PPUSH
24411: LD_VAR 0 12
24415: PPUSH
24416: CALL_OW 111
// break ;
24420: GO 24424
// end ; end ;
24422: GO 24307
24424: POP
24425: POP
// end ; end ;
24426: GO 23739
24428: POP
24429: POP
// end ;
24430: LD_VAR 0 8
24434: RET
// export function BuildingTechInvented ( side , btype ) ; begin
24435: LD_INT 0
24437: PPUSH
// result := true ;
24438: LD_ADDR_VAR 0 3
24442: PUSH
24443: LD_INT 1
24445: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
24446: LD_VAR 0 2
24450: PUSH
24451: LD_INT 24
24453: DOUBLE
24454: EQUAL
24455: IFTRUE 24465
24457: LD_INT 33
24459: DOUBLE
24460: EQUAL
24461: IFTRUE 24465
24463: GO 24490
24465: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
24466: LD_ADDR_VAR 0 3
24470: PUSH
24471: LD_INT 32
24473: PPUSH
24474: LD_VAR 0 1
24478: PPUSH
24479: CALL_OW 321
24483: PUSH
24484: LD_INT 2
24486: EQUAL
24487: ST_TO_ADDR
24488: GO 24806
24490: LD_INT 20
24492: DOUBLE
24493: EQUAL
24494: IFTRUE 24498
24496: GO 24523
24498: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
24499: LD_ADDR_VAR 0 3
24503: PUSH
24504: LD_INT 6
24506: PPUSH
24507: LD_VAR 0 1
24511: PPUSH
24512: CALL_OW 321
24516: PUSH
24517: LD_INT 2
24519: EQUAL
24520: ST_TO_ADDR
24521: GO 24806
24523: LD_INT 22
24525: DOUBLE
24526: EQUAL
24527: IFTRUE 24537
24529: LD_INT 36
24531: DOUBLE
24532: EQUAL
24533: IFTRUE 24537
24535: GO 24562
24537: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
24538: LD_ADDR_VAR 0 3
24542: PUSH
24543: LD_INT 15
24545: PPUSH
24546: LD_VAR 0 1
24550: PPUSH
24551: CALL_OW 321
24555: PUSH
24556: LD_INT 2
24558: EQUAL
24559: ST_TO_ADDR
24560: GO 24806
24562: LD_INT 30
24564: DOUBLE
24565: EQUAL
24566: IFTRUE 24570
24568: GO 24595
24570: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
24571: LD_ADDR_VAR 0 3
24575: PUSH
24576: LD_INT 20
24578: PPUSH
24579: LD_VAR 0 1
24583: PPUSH
24584: CALL_OW 321
24588: PUSH
24589: LD_INT 2
24591: EQUAL
24592: ST_TO_ADDR
24593: GO 24806
24595: LD_INT 28
24597: DOUBLE
24598: EQUAL
24599: IFTRUE 24609
24601: LD_INT 21
24603: DOUBLE
24604: EQUAL
24605: IFTRUE 24609
24607: GO 24634
24609: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
24610: LD_ADDR_VAR 0 3
24614: PUSH
24615: LD_INT 21
24617: PPUSH
24618: LD_VAR 0 1
24622: PPUSH
24623: CALL_OW 321
24627: PUSH
24628: LD_INT 2
24630: EQUAL
24631: ST_TO_ADDR
24632: GO 24806
24634: LD_INT 16
24636: DOUBLE
24637: EQUAL
24638: IFTRUE 24642
24640: GO 24667
24642: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
24643: LD_ADDR_VAR 0 3
24647: PUSH
24648: LD_INT 84
24650: PPUSH
24651: LD_VAR 0 1
24655: PPUSH
24656: CALL_OW 321
24660: PUSH
24661: LD_INT 2
24663: EQUAL
24664: ST_TO_ADDR
24665: GO 24806
24667: LD_INT 19
24669: DOUBLE
24670: EQUAL
24671: IFTRUE 24681
24673: LD_INT 23
24675: DOUBLE
24676: EQUAL
24677: IFTRUE 24681
24679: GO 24706
24681: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
24682: LD_ADDR_VAR 0 3
24686: PUSH
24687: LD_INT 83
24689: PPUSH
24690: LD_VAR 0 1
24694: PPUSH
24695: CALL_OW 321
24699: PUSH
24700: LD_INT 2
24702: EQUAL
24703: ST_TO_ADDR
24704: GO 24806
24706: LD_INT 17
24708: DOUBLE
24709: EQUAL
24710: IFTRUE 24714
24712: GO 24739
24714: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
24715: LD_ADDR_VAR 0 3
24719: PUSH
24720: LD_INT 39
24722: PPUSH
24723: LD_VAR 0 1
24727: PPUSH
24728: CALL_OW 321
24732: PUSH
24733: LD_INT 2
24735: EQUAL
24736: ST_TO_ADDR
24737: GO 24806
24739: LD_INT 18
24741: DOUBLE
24742: EQUAL
24743: IFTRUE 24747
24745: GO 24772
24747: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
24748: LD_ADDR_VAR 0 3
24752: PUSH
24753: LD_INT 40
24755: PPUSH
24756: LD_VAR 0 1
24760: PPUSH
24761: CALL_OW 321
24765: PUSH
24766: LD_INT 2
24768: EQUAL
24769: ST_TO_ADDR
24770: GO 24806
24772: LD_INT 27
24774: DOUBLE
24775: EQUAL
24776: IFTRUE 24780
24778: GO 24805
24780: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
24781: LD_ADDR_VAR 0 3
24785: PUSH
24786: LD_INT 35
24788: PPUSH
24789: LD_VAR 0 1
24793: PPUSH
24794: CALL_OW 321
24798: PUSH
24799: LD_INT 2
24801: EQUAL
24802: ST_TO_ADDR
24803: GO 24806
24805: POP
// end ;
24806: LD_VAR 0 3
24810: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
24811: LD_INT 0
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
// result := false ;
24824: LD_ADDR_VAR 0 6
24828: PUSH
24829: LD_INT 0
24831: ST_TO_ADDR
// if btype = b_depot then
24832: LD_VAR 0 2
24836: PUSH
24837: LD_INT 0
24839: EQUAL
24840: IFFALSE 24852
// begin result := true ;
24842: LD_ADDR_VAR 0 6
24846: PUSH
24847: LD_INT 1
24849: ST_TO_ADDR
// exit ;
24850: GO 25706
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
24852: LD_VAR 0 1
24856: NOT
24857: IFTRUE 24882
24859: PUSH
24860: LD_VAR 0 1
24864: PPUSH
24865: CALL_OW 266
24869: PUSH
24870: LD_INT 0
24872: PUSH
24873: LD_INT 1
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: IN
24880: NOT
24881: OR
24882: IFTRUE 24891
24884: PUSH
24885: LD_VAR 0 2
24889: NOT
24890: OR
24891: IFTRUE 24927
24893: PUSH
24894: LD_VAR 0 5
24898: PUSH
24899: LD_INT 0
24901: PUSH
24902: LD_INT 1
24904: PUSH
24905: LD_INT 2
24907: PUSH
24908: LD_INT 3
24910: PUSH
24911: LD_INT 4
24913: PUSH
24914: LD_INT 5
24916: PUSH
24917: EMPTY
24918: LIST
24919: LIST
24920: LIST
24921: LIST
24922: LIST
24923: LIST
24924: IN
24925: NOT
24926: OR
24927: IFTRUE 24946
24929: PUSH
24930: LD_VAR 0 3
24934: PPUSH
24935: LD_VAR 0 4
24939: PPUSH
24940: CALL_OW 488
24944: NOT
24945: OR
24946: IFFALSE 24950
// exit ;
24948: GO 25706
// side := GetSide ( depot ) ;
24950: LD_ADDR_VAR 0 9
24954: PUSH
24955: LD_VAR 0 1
24959: PPUSH
24960: CALL_OW 255
24964: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
24965: LD_VAR 0 9
24969: PPUSH
24970: LD_VAR 0 2
24974: PPUSH
24975: CALL 24435 0 2
24979: NOT
24980: IFFALSE 24984
// exit ;
24982: GO 25706
// pom := GetBase ( depot ) ;
24984: LD_ADDR_VAR 0 10
24988: PUSH
24989: LD_VAR 0 1
24993: PPUSH
24994: CALL_OW 274
24998: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
24999: LD_ADDR_VAR 0 11
25003: PUSH
25004: LD_VAR 0 2
25008: PPUSH
25009: LD_VAR 0 1
25013: PPUSH
25014: CALL_OW 248
25018: PPUSH
25019: CALL_OW 450
25023: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
25024: LD_VAR 0 10
25028: PPUSH
25029: LD_INT 1
25031: PPUSH
25032: CALL_OW 275
25036: PUSH
25037: LD_VAR 0 11
25041: PUSH
25042: LD_INT 1
25044: ARRAY
25045: GREATEREQUAL
25046: IFFALSE 25072
25048: PUSH
25049: LD_VAR 0 10
25053: PPUSH
25054: LD_INT 2
25056: PPUSH
25057: CALL_OW 275
25061: PUSH
25062: LD_VAR 0 11
25066: PUSH
25067: LD_INT 2
25069: ARRAY
25070: GREATEREQUAL
25071: AND
25072: IFFALSE 25098
25074: PUSH
25075: LD_VAR 0 10
25079: PPUSH
25080: LD_INT 3
25082: PPUSH
25083: CALL_OW 275
25087: PUSH
25088: LD_VAR 0 11
25092: PUSH
25093: LD_INT 3
25095: ARRAY
25096: GREATEREQUAL
25097: AND
25098: NOT
25099: IFFALSE 25103
// exit ;
25101: GO 25706
// if GetBType ( depot ) = b_depot then
25103: LD_VAR 0 1
25107: PPUSH
25108: CALL_OW 266
25112: PUSH
25113: LD_INT 0
25115: EQUAL
25116: IFFALSE 25128
// dist := 28 else
25118: LD_ADDR_VAR 0 14
25122: PUSH
25123: LD_INT 28
25125: ST_TO_ADDR
25126: GO 25136
// dist := 36 ;
25128: LD_ADDR_VAR 0 14
25132: PUSH
25133: LD_INT 36
25135: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
25136: LD_VAR 0 1
25140: PPUSH
25141: LD_VAR 0 3
25145: PPUSH
25146: LD_VAR 0 4
25150: PPUSH
25151: CALL_OW 297
25155: PUSH
25156: LD_VAR 0 14
25160: GREATER
25161: IFFALSE 25165
// exit ;
25163: GO 25706
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
25165: LD_ADDR_VAR 0 12
25169: PUSH
25170: LD_VAR 0 2
25174: PPUSH
25175: LD_VAR 0 3
25179: PPUSH
25180: LD_VAR 0 4
25184: PPUSH
25185: LD_VAR 0 5
25189: PPUSH
25190: LD_VAR 0 1
25194: PPUSH
25195: CALL_OW 248
25199: PPUSH
25200: LD_INT 0
25202: PPUSH
25203: CALL 25711 0 6
25207: ST_TO_ADDR
// if not hexes then
25208: LD_VAR 0 12
25212: NOT
25213: IFFALSE 25217
// exit ;
25215: GO 25706
// hex := GetHexInfo ( x , y ) ;
25217: LD_ADDR_VAR 0 15
25221: PUSH
25222: LD_VAR 0 3
25226: PPUSH
25227: LD_VAR 0 4
25231: PPUSH
25232: CALL_OW 546
25236: ST_TO_ADDR
// if hex [ 1 ] then
25237: LD_VAR 0 15
25241: PUSH
25242: LD_INT 1
25244: ARRAY
25245: IFFALSE 25249
// exit ;
25247: GO 25706
// height := hex [ 2 ] ;
25249: LD_ADDR_VAR 0 13
25253: PUSH
25254: LD_VAR 0 15
25258: PUSH
25259: LD_INT 2
25261: ARRAY
25262: ST_TO_ADDR
// for i = 1 to hexes do
25263: LD_ADDR_VAR 0 7
25267: PUSH
25268: DOUBLE
25269: LD_INT 1
25271: DEC
25272: ST_TO_ADDR
25273: LD_VAR 0 12
25277: PUSH
25278: FOR_TO
25279: IFFALSE 25623
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
25281: LD_VAR 0 12
25285: PUSH
25286: LD_VAR 0 7
25290: ARRAY
25291: PUSH
25292: LD_INT 1
25294: ARRAY
25295: PPUSH
25296: LD_VAR 0 12
25300: PUSH
25301: LD_VAR 0 7
25305: ARRAY
25306: PUSH
25307: LD_INT 2
25309: ARRAY
25310: PPUSH
25311: CALL_OW 488
25315: NOT
25316: IFTRUE 25358
25318: PUSH
25319: LD_VAR 0 12
25323: PUSH
25324: LD_VAR 0 7
25328: ARRAY
25329: PUSH
25330: LD_INT 1
25332: ARRAY
25333: PPUSH
25334: LD_VAR 0 12
25338: PUSH
25339: LD_VAR 0 7
25343: ARRAY
25344: PUSH
25345: LD_INT 2
25347: ARRAY
25348: PPUSH
25349: CALL_OW 428
25353: PUSH
25354: LD_INT 0
25356: GREATER
25357: OR
25358: IFTRUE 25396
25360: PUSH
25361: LD_VAR 0 12
25365: PUSH
25366: LD_VAR 0 7
25370: ARRAY
25371: PUSH
25372: LD_INT 1
25374: ARRAY
25375: PPUSH
25376: LD_VAR 0 12
25380: PUSH
25381: LD_VAR 0 7
25385: ARRAY
25386: PUSH
25387: LD_INT 2
25389: ARRAY
25390: PPUSH
25391: CALL_OW 351
25395: OR
25396: IFFALSE 25402
// exit ;
25398: POP
25399: POP
25400: GO 25706
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
25402: LD_ADDR_VAR 0 8
25406: PUSH
25407: LD_VAR 0 12
25411: PUSH
25412: LD_VAR 0 7
25416: ARRAY
25417: PUSH
25418: LD_INT 1
25420: ARRAY
25421: PPUSH
25422: LD_VAR 0 12
25426: PUSH
25427: LD_VAR 0 7
25431: ARRAY
25432: PUSH
25433: LD_INT 2
25435: ARRAY
25436: PPUSH
25437: CALL_OW 546
25441: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
25442: LD_VAR 0 8
25446: PUSH
25447: LD_INT 1
25449: ARRAY
25450: IFTRUE 25472
25452: PUSH
25453: LD_VAR 0 8
25457: PUSH
25458: LD_INT 2
25460: ARRAY
25461: PUSH
25462: LD_VAR 0 13
25466: PUSH
25467: LD_INT 2
25469: PLUS
25470: GREATER
25471: OR
25472: IFTRUE 25494
25474: PUSH
25475: LD_VAR 0 8
25479: PUSH
25480: LD_INT 2
25482: ARRAY
25483: PUSH
25484: LD_VAR 0 13
25488: PUSH
25489: LD_INT 2
25491: MINUS
25492: LESS
25493: OR
25494: IFTRUE 25562
25496: PUSH
25497: LD_VAR 0 8
25501: PUSH
25502: LD_INT 3
25504: ARRAY
25505: PUSH
25506: LD_INT 0
25508: PUSH
25509: LD_INT 8
25511: PUSH
25512: LD_INT 9
25514: PUSH
25515: LD_INT 10
25517: PUSH
25518: LD_INT 11
25520: PUSH
25521: LD_INT 12
25523: PUSH
25524: LD_INT 13
25526: PUSH
25527: LD_INT 16
25529: PUSH
25530: LD_INT 17
25532: PUSH
25533: LD_INT 18
25535: PUSH
25536: LD_INT 19
25538: PUSH
25539: LD_INT 20
25541: PUSH
25542: LD_INT 21
25544: PUSH
25545: EMPTY
25546: LIST
25547: LIST
25548: LIST
25549: LIST
25550: LIST
25551: LIST
25552: LIST
25553: LIST
25554: LIST
25555: LIST
25556: LIST
25557: LIST
25558: LIST
25559: IN
25560: NOT
25561: OR
25562: IFTRUE 25575
25564: PUSH
25565: LD_VAR 0 8
25569: PUSH
25570: LD_INT 5
25572: ARRAY
25573: NOT
25574: OR
25575: IFTRUE 25615
25577: PUSH
25578: LD_VAR 0 8
25582: PUSH
25583: LD_INT 6
25585: ARRAY
25586: PUSH
25587: LD_INT 1
25589: PUSH
25590: LD_INT 2
25592: PUSH
25593: LD_INT 7
25595: PUSH
25596: LD_INT 9
25598: PUSH
25599: LD_INT 10
25601: PUSH
25602: LD_INT 11
25604: PUSH
25605: EMPTY
25606: LIST
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: LIST
25612: IN
25613: NOT
25614: OR
25615: IFFALSE 25621
// exit ;
25617: POP
25618: POP
25619: GO 25706
// end ;
25621: GO 25278
25623: POP
25624: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
25625: LD_VAR 0 9
25629: PPUSH
25630: LD_VAR 0 3
25634: PPUSH
25635: LD_VAR 0 4
25639: PPUSH
25640: LD_INT 20
25642: PPUSH
25643: CALL 17525 0 4
25647: PUSH
25648: LD_INT 4
25650: ARRAY
25651: IFFALSE 25655
// exit ;
25653: GO 25706
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
25655: LD_VAR 0 2
25659: PUSH
25660: LD_INT 29
25662: PUSH
25663: LD_INT 30
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: IN
25670: IFFALSE 25694
25672: PUSH
25673: LD_VAR 0 3
25677: PPUSH
25678: LD_VAR 0 4
25682: PPUSH
25683: LD_VAR 0 9
25687: PPUSH
25688: CALL_OW 440
25692: NOT
25693: AND
25694: IFFALSE 25698
// exit ;
25696: GO 25706
// result := true ;
25698: LD_ADDR_VAR 0 6
25702: PUSH
25703: LD_INT 1
25705: ST_TO_ADDR
// end ;
25706: LD_VAR 0 6
25710: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
25711: LD_INT 0
25713: PPUSH
25714: PPUSH
25715: PPUSH
25716: PPUSH
25717: PPUSH
25718: PPUSH
25719: PPUSH
25720: PPUSH
25721: PPUSH
25722: PPUSH
25723: PPUSH
25724: PPUSH
25725: PPUSH
25726: PPUSH
25727: PPUSH
25728: PPUSH
25729: PPUSH
25730: PPUSH
25731: PPUSH
25732: PPUSH
25733: PPUSH
25734: PPUSH
25735: PPUSH
25736: PPUSH
25737: PPUSH
25738: PPUSH
25739: PPUSH
25740: PPUSH
25741: PPUSH
25742: PPUSH
25743: PPUSH
25744: PPUSH
25745: PPUSH
25746: PPUSH
25747: PPUSH
25748: PPUSH
25749: PPUSH
25750: PPUSH
25751: PPUSH
25752: PPUSH
25753: PPUSH
25754: PPUSH
25755: PPUSH
25756: PPUSH
25757: PPUSH
25758: PPUSH
25759: PPUSH
25760: PPUSH
25761: PPUSH
25762: PPUSH
25763: PPUSH
25764: PPUSH
25765: PPUSH
25766: PPUSH
25767: PPUSH
25768: PPUSH
25769: PPUSH
25770: PPUSH
// result = [ ] ;
25771: LD_ADDR_VAR 0 7
25775: PUSH
25776: EMPTY
25777: ST_TO_ADDR
// temp_list = [ ] ;
25778: LD_ADDR_VAR 0 9
25782: PUSH
25783: EMPTY
25784: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
25785: LD_VAR 0 4
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: LD_INT 1
25795: PUSH
25796: LD_INT 2
25798: PUSH
25799: LD_INT 3
25801: PUSH
25802: LD_INT 4
25804: PUSH
25805: LD_INT 5
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: LIST
25812: LIST
25813: LIST
25814: LIST
25815: IN
25816: NOT
25817: IFTRUE 25860
25819: PUSH
25820: LD_VAR 0 1
25824: PUSH
25825: LD_INT 0
25827: PUSH
25828: LD_INT 1
25830: PUSH
25831: EMPTY
25832: LIST
25833: LIST
25834: IN
25835: IFFALSE 25859
25837: PUSH
25838: LD_VAR 0 5
25842: PUSH
25843: LD_INT 1
25845: PUSH
25846: LD_INT 2
25848: PUSH
25849: LD_INT 3
25851: PUSH
25852: EMPTY
25853: LIST
25854: LIST
25855: LIST
25856: IN
25857: NOT
25858: AND
25859: OR
25860: IFFALSE 25864
// exit ;
25862: GO 44263
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
25864: LD_VAR 0 1
25868: PUSH
25869: LD_INT 6
25871: PUSH
25872: LD_INT 7
25874: PUSH
25875: LD_INT 8
25877: PUSH
25878: LD_INT 13
25880: PUSH
25881: LD_INT 12
25883: PUSH
25884: LD_INT 15
25886: PUSH
25887: LD_INT 11
25889: PUSH
25890: LD_INT 14
25892: PUSH
25893: LD_INT 10
25895: PUSH
25896: EMPTY
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: LIST
25904: LIST
25905: LIST
25906: IN
25907: IFFALSE 25917
// btype = b_lab ;
25909: LD_ADDR_VAR 0 1
25913: PUSH
25914: LD_INT 6
25916: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
25917: LD_VAR 0 6
25921: PUSH
25922: LD_INT 0
25924: PUSH
25925: LD_INT 1
25927: PUSH
25928: LD_INT 2
25930: PUSH
25931: EMPTY
25932: LIST
25933: LIST
25934: LIST
25935: IN
25936: NOT
25937: IFTRUE 26005
25939: PUSH
25940: LD_VAR 0 1
25944: PUSH
25945: LD_INT 0
25947: PUSH
25948: LD_INT 1
25950: PUSH
25951: LD_INT 2
25953: PUSH
25954: LD_INT 3
25956: PUSH
25957: LD_INT 6
25959: PUSH
25960: LD_INT 36
25962: PUSH
25963: LD_INT 4
25965: PUSH
25966: LD_INT 5
25968: PUSH
25969: LD_INT 31
25971: PUSH
25972: LD_INT 32
25974: PUSH
25975: LD_INT 33
25977: PUSH
25978: EMPTY
25979: LIST
25980: LIST
25981: LIST
25982: LIST
25983: LIST
25984: LIST
25985: LIST
25986: LIST
25987: LIST
25988: LIST
25989: LIST
25990: IN
25991: NOT
25992: IFFALSE 26004
25994: PUSH
25995: LD_VAR 0 6
25999: PUSH
26000: LD_INT 1
26002: EQUAL
26003: AND
26004: OR
26005: IFTRUE 26037
26007: PUSH
26008: LD_VAR 0 1
26012: PUSH
26013: LD_INT 2
26015: PUSH
26016: LD_INT 3
26018: PUSH
26019: EMPTY
26020: LIST
26021: LIST
26022: IN
26023: NOT
26024: IFFALSE 26036
26026: PUSH
26027: LD_VAR 0 6
26031: PUSH
26032: LD_INT 2
26034: EQUAL
26035: AND
26036: OR
26037: IFFALSE 26047
// mode = 0 ;
26039: LD_ADDR_VAR 0 6
26043: PUSH
26044: LD_INT 0
26046: ST_TO_ADDR
// case mode of 0 :
26047: LD_VAR 0 6
26051: PUSH
26052: LD_INT 0
26054: DOUBLE
26055: EQUAL
26056: IFTRUE 26060
26058: GO 37513
26060: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
26061: LD_ADDR_VAR 0 11
26065: PUSH
26066: LD_INT 0
26068: PUSH
26069: LD_INT 0
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 0
26078: PUSH
26079: LD_INT 1
26081: NEG
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 1
26089: PUSH
26090: LD_INT 0
26092: PUSH
26093: EMPTY
26094: LIST
26095: LIST
26096: PUSH
26097: LD_INT 1
26099: PUSH
26100: LD_INT 1
26102: PUSH
26103: EMPTY
26104: LIST
26105: LIST
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 1
26112: PUSH
26113: EMPTY
26114: LIST
26115: LIST
26116: PUSH
26117: LD_INT 1
26119: NEG
26120: PUSH
26121: LD_INT 0
26123: PUSH
26124: EMPTY
26125: LIST
26126: LIST
26127: PUSH
26128: LD_INT 1
26130: NEG
26131: PUSH
26132: LD_INT 1
26134: NEG
26135: PUSH
26136: EMPTY
26137: LIST
26138: LIST
26139: PUSH
26140: LD_INT 1
26142: NEG
26143: PUSH
26144: LD_INT 2
26146: NEG
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: PUSH
26152: LD_INT 0
26154: PUSH
26155: LD_INT 2
26157: NEG
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: PUSH
26163: LD_INT 1
26165: PUSH
26166: LD_INT 1
26168: NEG
26169: PUSH
26170: EMPTY
26171: LIST
26172: LIST
26173: PUSH
26174: LD_INT 1
26176: PUSH
26177: LD_INT 2
26179: PUSH
26180: EMPTY
26181: LIST
26182: LIST
26183: PUSH
26184: LD_INT 0
26186: PUSH
26187: LD_INT 2
26189: PUSH
26190: EMPTY
26191: LIST
26192: LIST
26193: PUSH
26194: LD_INT 1
26196: NEG
26197: PUSH
26198: LD_INT 1
26200: PUSH
26201: EMPTY
26202: LIST
26203: LIST
26204: PUSH
26205: LD_INT 1
26207: PUSH
26208: LD_INT 3
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: PUSH
26215: LD_INT 0
26217: PUSH
26218: LD_INT 3
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: PUSH
26225: LD_INT 1
26227: NEG
26228: PUSH
26229: LD_INT 2
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: LIST
26240: LIST
26241: LIST
26242: LIST
26243: LIST
26244: LIST
26245: LIST
26246: LIST
26247: LIST
26248: LIST
26249: LIST
26250: LIST
26251: LIST
26252: LIST
26253: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
26254: LD_ADDR_VAR 0 12
26258: PUSH
26259: LD_INT 0
26261: PUSH
26262: LD_INT 0
26264: PUSH
26265: EMPTY
26266: LIST
26267: LIST
26268: PUSH
26269: LD_INT 0
26271: PUSH
26272: LD_INT 1
26274: NEG
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: LD_INT 1
26282: PUSH
26283: LD_INT 0
26285: PUSH
26286: EMPTY
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 1
26292: PUSH
26293: LD_INT 1
26295: PUSH
26296: EMPTY
26297: LIST
26298: LIST
26299: PUSH
26300: LD_INT 0
26302: PUSH
26303: LD_INT 1
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: PUSH
26310: LD_INT 1
26312: NEG
26313: PUSH
26314: LD_INT 0
26316: PUSH
26317: EMPTY
26318: LIST
26319: LIST
26320: PUSH
26321: LD_INT 1
26323: NEG
26324: PUSH
26325: LD_INT 1
26327: NEG
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_INT 1
26335: PUSH
26336: LD_INT 1
26338: NEG
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: PUSH
26344: LD_INT 2
26346: PUSH
26347: LD_INT 0
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 2
26356: PUSH
26357: LD_INT 1
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: LD_INT 1
26366: NEG
26367: PUSH
26368: LD_INT 1
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 2
26377: NEG
26378: PUSH
26379: LD_INT 0
26381: PUSH
26382: EMPTY
26383: LIST
26384: LIST
26385: PUSH
26386: LD_INT 2
26388: NEG
26389: PUSH
26390: LD_INT 1
26392: NEG
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 2
26400: NEG
26401: PUSH
26402: LD_INT 1
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 3
26411: NEG
26412: PUSH
26413: LD_INT 0
26415: PUSH
26416: EMPTY
26417: LIST
26418: LIST
26419: PUSH
26420: LD_INT 3
26422: NEG
26423: PUSH
26424: LD_INT 1
26426: NEG
26427: PUSH
26428: EMPTY
26429: LIST
26430: LIST
26431: PUSH
26432: EMPTY
26433: LIST
26434: LIST
26435: LIST
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
26450: LD_ADDR_VAR 0 13
26454: PUSH
26455: LD_INT 0
26457: PUSH
26458: LD_INT 0
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 1
26470: NEG
26471: PUSH
26472: EMPTY
26473: LIST
26474: LIST
26475: PUSH
26476: LD_INT 1
26478: PUSH
26479: LD_INT 0
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: LD_INT 1
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 0
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 1
26508: NEG
26509: PUSH
26510: LD_INT 0
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PUSH
26517: LD_INT 1
26519: NEG
26520: PUSH
26521: LD_INT 1
26523: NEG
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: LD_INT 1
26531: NEG
26532: PUSH
26533: LD_INT 2
26535: NEG
26536: PUSH
26537: EMPTY
26538: LIST
26539: LIST
26540: PUSH
26541: LD_INT 2
26543: PUSH
26544: LD_INT 1
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 2
26553: PUSH
26554: LD_INT 2
26556: PUSH
26557: EMPTY
26558: LIST
26559: LIST
26560: PUSH
26561: LD_INT 1
26563: PUSH
26564: LD_INT 2
26566: PUSH
26567: EMPTY
26568: LIST
26569: LIST
26570: PUSH
26571: LD_INT 2
26573: NEG
26574: PUSH
26575: LD_INT 1
26577: NEG
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 2
26585: NEG
26586: PUSH
26587: LD_INT 2
26589: NEG
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 2
26597: NEG
26598: PUSH
26599: LD_INT 3
26601: NEG
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PUSH
26607: LD_INT 3
26609: NEG
26610: PUSH
26611: LD_INT 2
26613: NEG
26614: PUSH
26615: EMPTY
26616: LIST
26617: LIST
26618: PUSH
26619: LD_INT 3
26621: NEG
26622: PUSH
26623: LD_INT 3
26625: NEG
26626: PUSH
26627: EMPTY
26628: LIST
26629: LIST
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
26649: LD_ADDR_VAR 0 14
26653: PUSH
26654: LD_INT 0
26656: PUSH
26657: LD_INT 0
26659: PUSH
26660: EMPTY
26661: LIST
26662: LIST
26663: PUSH
26664: LD_INT 0
26666: PUSH
26667: LD_INT 1
26669: NEG
26670: PUSH
26671: EMPTY
26672: LIST
26673: LIST
26674: PUSH
26675: LD_INT 1
26677: PUSH
26678: LD_INT 0
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 1
26687: PUSH
26688: LD_INT 1
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: PUSH
26695: LD_INT 0
26697: PUSH
26698: LD_INT 1
26700: PUSH
26701: EMPTY
26702: LIST
26703: LIST
26704: PUSH
26705: LD_INT 1
26707: NEG
26708: PUSH
26709: LD_INT 0
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PUSH
26716: LD_INT 1
26718: NEG
26719: PUSH
26720: LD_INT 1
26722: NEG
26723: PUSH
26724: EMPTY
26725: LIST
26726: LIST
26727: PUSH
26728: LD_INT 1
26730: NEG
26731: PUSH
26732: LD_INT 2
26734: NEG
26735: PUSH
26736: EMPTY
26737: LIST
26738: LIST
26739: PUSH
26740: LD_INT 0
26742: PUSH
26743: LD_INT 2
26745: NEG
26746: PUSH
26747: EMPTY
26748: LIST
26749: LIST
26750: PUSH
26751: LD_INT 1
26753: PUSH
26754: LD_INT 1
26756: NEG
26757: PUSH
26758: EMPTY
26759: LIST
26760: LIST
26761: PUSH
26762: LD_INT 1
26764: PUSH
26765: LD_INT 2
26767: PUSH
26768: EMPTY
26769: LIST
26770: LIST
26771: PUSH
26772: LD_INT 0
26774: PUSH
26775: LD_INT 2
26777: PUSH
26778: EMPTY
26779: LIST
26780: LIST
26781: PUSH
26782: LD_INT 1
26784: NEG
26785: PUSH
26786: LD_INT 1
26788: PUSH
26789: EMPTY
26790: LIST
26791: LIST
26792: PUSH
26793: LD_INT 1
26795: NEG
26796: PUSH
26797: LD_INT 3
26799: NEG
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 0
26807: PUSH
26808: LD_INT 3
26810: NEG
26811: PUSH
26812: EMPTY
26813: LIST
26814: LIST
26815: PUSH
26816: LD_INT 1
26818: PUSH
26819: LD_INT 2
26821: NEG
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: LIST
26831: LIST
26832: LIST
26833: LIST
26834: LIST
26835: LIST
26836: LIST
26837: LIST
26838: LIST
26839: LIST
26840: LIST
26841: LIST
26842: LIST
26843: LIST
26844: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
26845: LD_ADDR_VAR 0 15
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: LD_INT 0
26855: PUSH
26856: EMPTY
26857: LIST
26858: LIST
26859: PUSH
26860: LD_INT 0
26862: PUSH
26863: LD_INT 1
26865: NEG
26866: PUSH
26867: EMPTY
26868: LIST
26869: LIST
26870: PUSH
26871: LD_INT 1
26873: PUSH
26874: LD_INT 0
26876: PUSH
26877: EMPTY
26878: LIST
26879: LIST
26880: PUSH
26881: LD_INT 1
26883: PUSH
26884: LD_INT 1
26886: PUSH
26887: EMPTY
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 0
26893: PUSH
26894: LD_INT 1
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 1
26903: NEG
26904: PUSH
26905: LD_INT 0
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: PUSH
26912: LD_INT 1
26914: NEG
26915: PUSH
26916: LD_INT 1
26918: NEG
26919: PUSH
26920: EMPTY
26921: LIST
26922: LIST
26923: PUSH
26924: LD_INT 1
26926: PUSH
26927: LD_INT 1
26929: NEG
26930: PUSH
26931: EMPTY
26932: LIST
26933: LIST
26934: PUSH
26935: LD_INT 2
26937: PUSH
26938: LD_INT 0
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_INT 2
26947: PUSH
26948: LD_INT 1
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: LD_INT 1
26957: NEG
26958: PUSH
26959: LD_INT 1
26961: PUSH
26962: EMPTY
26963: LIST
26964: LIST
26965: PUSH
26966: LD_INT 2
26968: NEG
26969: PUSH
26970: LD_INT 0
26972: PUSH
26973: EMPTY
26974: LIST
26975: LIST
26976: PUSH
26977: LD_INT 2
26979: NEG
26980: PUSH
26981: LD_INT 1
26983: NEG
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: PUSH
26989: LD_INT 2
26991: PUSH
26992: LD_INT 1
26994: NEG
26995: PUSH
26996: EMPTY
26997: LIST
26998: LIST
26999: PUSH
27000: LD_INT 3
27002: PUSH
27003: LD_INT 0
27005: PUSH
27006: EMPTY
27007: LIST
27008: LIST
27009: PUSH
27010: LD_INT 3
27012: PUSH
27013: LD_INT 1
27015: PUSH
27016: EMPTY
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: LIST
27024: LIST
27025: LIST
27026: LIST
27027: LIST
27028: LIST
27029: LIST
27030: LIST
27031: LIST
27032: LIST
27033: LIST
27034: LIST
27035: LIST
27036: LIST
27037: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
27038: LD_ADDR_VAR 0 16
27042: PUSH
27043: LD_INT 0
27045: PUSH
27046: LD_INT 0
27048: PUSH
27049: EMPTY
27050: LIST
27051: LIST
27052: PUSH
27053: LD_INT 0
27055: PUSH
27056: LD_INT 1
27058: NEG
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: LD_INT 1
27066: PUSH
27067: LD_INT 0
27069: PUSH
27070: EMPTY
27071: LIST
27072: LIST
27073: PUSH
27074: LD_INT 1
27076: PUSH
27077: LD_INT 1
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: LD_INT 0
27086: PUSH
27087: LD_INT 1
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 1
27096: NEG
27097: PUSH
27098: LD_INT 0
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 1
27107: NEG
27108: PUSH
27109: LD_INT 1
27111: NEG
27112: PUSH
27113: EMPTY
27114: LIST
27115: LIST
27116: PUSH
27117: LD_INT 1
27119: NEG
27120: PUSH
27121: LD_INT 2
27123: NEG
27124: PUSH
27125: EMPTY
27126: LIST
27127: LIST
27128: PUSH
27129: LD_INT 2
27131: PUSH
27132: LD_INT 1
27134: PUSH
27135: EMPTY
27136: LIST
27137: LIST
27138: PUSH
27139: LD_INT 2
27141: PUSH
27142: LD_INT 2
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: PUSH
27149: LD_INT 1
27151: PUSH
27152: LD_INT 2
27154: PUSH
27155: EMPTY
27156: LIST
27157: LIST
27158: PUSH
27159: LD_INT 2
27161: NEG
27162: PUSH
27163: LD_INT 1
27165: NEG
27166: PUSH
27167: EMPTY
27168: LIST
27169: LIST
27170: PUSH
27171: LD_INT 2
27173: NEG
27174: PUSH
27175: LD_INT 2
27177: NEG
27178: PUSH
27179: EMPTY
27180: LIST
27181: LIST
27182: PUSH
27183: LD_INT 3
27185: PUSH
27186: LD_INT 2
27188: PUSH
27189: EMPTY
27190: LIST
27191: LIST
27192: PUSH
27193: LD_INT 3
27195: PUSH
27196: LD_INT 3
27198: PUSH
27199: EMPTY
27200: LIST
27201: LIST
27202: PUSH
27203: LD_INT 2
27205: PUSH
27206: LD_INT 3
27208: PUSH
27209: EMPTY
27210: LIST
27211: LIST
27212: PUSH
27213: EMPTY
27214: LIST
27215: LIST
27216: LIST
27217: LIST
27218: LIST
27219: LIST
27220: LIST
27221: LIST
27222: LIST
27223: LIST
27224: LIST
27225: LIST
27226: LIST
27227: LIST
27228: LIST
27229: LIST
27230: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27231: LD_ADDR_VAR 0 17
27235: PUSH
27236: LD_INT 0
27238: PUSH
27239: LD_INT 0
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: PUSH
27246: LD_INT 0
27248: PUSH
27249: LD_INT 1
27251: NEG
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: PUSH
27257: LD_INT 1
27259: PUSH
27260: LD_INT 0
27262: PUSH
27263: EMPTY
27264: LIST
27265: LIST
27266: PUSH
27267: LD_INT 1
27269: PUSH
27270: LD_INT 1
27272: PUSH
27273: EMPTY
27274: LIST
27275: LIST
27276: PUSH
27277: LD_INT 0
27279: PUSH
27280: LD_INT 1
27282: PUSH
27283: EMPTY
27284: LIST
27285: LIST
27286: PUSH
27287: LD_INT 1
27289: NEG
27290: PUSH
27291: LD_INT 0
27293: PUSH
27294: EMPTY
27295: LIST
27296: LIST
27297: PUSH
27298: LD_INT 1
27300: NEG
27301: PUSH
27302: LD_INT 1
27304: NEG
27305: PUSH
27306: EMPTY
27307: LIST
27308: LIST
27309: PUSH
27310: LD_INT 1
27312: NEG
27313: PUSH
27314: LD_INT 2
27316: NEG
27317: PUSH
27318: EMPTY
27319: LIST
27320: LIST
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: LD_INT 2
27327: NEG
27328: PUSH
27329: EMPTY
27330: LIST
27331: LIST
27332: PUSH
27333: LD_INT 1
27335: PUSH
27336: LD_INT 1
27338: NEG
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 2
27346: PUSH
27347: LD_INT 0
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 2
27356: PUSH
27357: LD_INT 1
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 2
27366: PUSH
27367: LD_INT 2
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 1
27376: PUSH
27377: LD_INT 2
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: LD_INT 0
27386: PUSH
27387: LD_INT 2
27389: PUSH
27390: EMPTY
27391: LIST
27392: LIST
27393: PUSH
27394: LD_INT 1
27396: NEG
27397: PUSH
27398: LD_INT 1
27400: PUSH
27401: EMPTY
27402: LIST
27403: LIST
27404: PUSH
27405: LD_INT 2
27407: NEG
27408: PUSH
27409: LD_INT 0
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: PUSH
27416: LD_INT 2
27418: NEG
27419: PUSH
27420: LD_INT 1
27422: NEG
27423: PUSH
27424: EMPTY
27425: LIST
27426: LIST
27427: PUSH
27428: LD_INT 2
27430: NEG
27431: PUSH
27432: LD_INT 2
27434: NEG
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: LIST
27444: LIST
27445: LIST
27446: LIST
27447: LIST
27448: LIST
27449: LIST
27450: LIST
27451: LIST
27452: LIST
27453: LIST
27454: LIST
27455: LIST
27456: LIST
27457: LIST
27458: LIST
27459: LIST
27460: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27461: LD_ADDR_VAR 0 18
27465: PUSH
27466: LD_INT 0
27468: PUSH
27469: LD_INT 0
27471: PUSH
27472: EMPTY
27473: LIST
27474: LIST
27475: PUSH
27476: LD_INT 0
27478: PUSH
27479: LD_INT 1
27481: NEG
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PUSH
27487: LD_INT 1
27489: PUSH
27490: LD_INT 0
27492: PUSH
27493: EMPTY
27494: LIST
27495: LIST
27496: PUSH
27497: LD_INT 1
27499: PUSH
27500: LD_INT 1
27502: PUSH
27503: EMPTY
27504: LIST
27505: LIST
27506: PUSH
27507: LD_INT 0
27509: PUSH
27510: LD_INT 1
27512: PUSH
27513: EMPTY
27514: LIST
27515: LIST
27516: PUSH
27517: LD_INT 1
27519: NEG
27520: PUSH
27521: LD_INT 0
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 1
27530: NEG
27531: PUSH
27532: LD_INT 1
27534: NEG
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: LD_INT 1
27542: NEG
27543: PUSH
27544: LD_INT 2
27546: NEG
27547: PUSH
27548: EMPTY
27549: LIST
27550: LIST
27551: PUSH
27552: LD_INT 0
27554: PUSH
27555: LD_INT 2
27557: NEG
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: LD_INT 1
27565: PUSH
27566: LD_INT 1
27568: NEG
27569: PUSH
27570: EMPTY
27571: LIST
27572: LIST
27573: PUSH
27574: LD_INT 2
27576: PUSH
27577: LD_INT 0
27579: PUSH
27580: EMPTY
27581: LIST
27582: LIST
27583: PUSH
27584: LD_INT 2
27586: PUSH
27587: LD_INT 1
27589: PUSH
27590: EMPTY
27591: LIST
27592: LIST
27593: PUSH
27594: LD_INT 2
27596: PUSH
27597: LD_INT 2
27599: PUSH
27600: EMPTY
27601: LIST
27602: LIST
27603: PUSH
27604: LD_INT 1
27606: PUSH
27607: LD_INT 2
27609: PUSH
27610: EMPTY
27611: LIST
27612: LIST
27613: PUSH
27614: LD_INT 0
27616: PUSH
27617: LD_INT 2
27619: PUSH
27620: EMPTY
27621: LIST
27622: LIST
27623: PUSH
27624: LD_INT 1
27626: NEG
27627: PUSH
27628: LD_INT 1
27630: PUSH
27631: EMPTY
27632: LIST
27633: LIST
27634: PUSH
27635: LD_INT 2
27637: NEG
27638: PUSH
27639: LD_INT 0
27641: PUSH
27642: EMPTY
27643: LIST
27644: LIST
27645: PUSH
27646: LD_INT 2
27648: NEG
27649: PUSH
27650: LD_INT 1
27652: NEG
27653: PUSH
27654: EMPTY
27655: LIST
27656: LIST
27657: PUSH
27658: LD_INT 2
27660: NEG
27661: PUSH
27662: LD_INT 2
27664: NEG
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27691: LD_ADDR_VAR 0 19
27695: PUSH
27696: LD_INT 0
27698: PUSH
27699: LD_INT 0
27701: PUSH
27702: EMPTY
27703: LIST
27704: LIST
27705: PUSH
27706: LD_INT 0
27708: PUSH
27709: LD_INT 1
27711: NEG
27712: PUSH
27713: EMPTY
27714: LIST
27715: LIST
27716: PUSH
27717: LD_INT 1
27719: PUSH
27720: LD_INT 0
27722: PUSH
27723: EMPTY
27724: LIST
27725: LIST
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: LD_INT 1
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: LD_INT 0
27739: PUSH
27740: LD_INT 1
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: LD_INT 1
27749: NEG
27750: PUSH
27751: LD_INT 0
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PUSH
27758: LD_INT 1
27760: NEG
27761: PUSH
27762: LD_INT 1
27764: NEG
27765: PUSH
27766: EMPTY
27767: LIST
27768: LIST
27769: PUSH
27770: LD_INT 1
27772: NEG
27773: PUSH
27774: LD_INT 2
27776: NEG
27777: PUSH
27778: EMPTY
27779: LIST
27780: LIST
27781: PUSH
27782: LD_INT 0
27784: PUSH
27785: LD_INT 2
27787: NEG
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: LD_INT 1
27795: PUSH
27796: LD_INT 1
27798: NEG
27799: PUSH
27800: EMPTY
27801: LIST
27802: LIST
27803: PUSH
27804: LD_INT 2
27806: PUSH
27807: LD_INT 0
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 2
27816: PUSH
27817: LD_INT 1
27819: PUSH
27820: EMPTY
27821: LIST
27822: LIST
27823: PUSH
27824: LD_INT 2
27826: PUSH
27827: LD_INT 2
27829: PUSH
27830: EMPTY
27831: LIST
27832: LIST
27833: PUSH
27834: LD_INT 1
27836: PUSH
27837: LD_INT 2
27839: PUSH
27840: EMPTY
27841: LIST
27842: LIST
27843: PUSH
27844: LD_INT 0
27846: PUSH
27847: LD_INT 2
27849: PUSH
27850: EMPTY
27851: LIST
27852: LIST
27853: PUSH
27854: LD_INT 1
27856: NEG
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 2
27867: NEG
27868: PUSH
27869: LD_INT 0
27871: PUSH
27872: EMPTY
27873: LIST
27874: LIST
27875: PUSH
27876: LD_INT 2
27878: NEG
27879: PUSH
27880: LD_INT 1
27882: NEG
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 2
27890: NEG
27891: PUSH
27892: LD_INT 2
27894: NEG
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: LIST
27914: LIST
27915: LIST
27916: LIST
27917: LIST
27918: LIST
27919: LIST
27920: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
27921: LD_ADDR_VAR 0 20
27925: PUSH
27926: LD_INT 0
27928: PUSH
27929: LD_INT 0
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 0
27938: PUSH
27939: LD_INT 1
27941: NEG
27942: PUSH
27943: EMPTY
27944: LIST
27945: LIST
27946: PUSH
27947: LD_INT 1
27949: PUSH
27950: LD_INT 0
27952: PUSH
27953: EMPTY
27954: LIST
27955: LIST
27956: PUSH
27957: LD_INT 1
27959: PUSH
27960: LD_INT 1
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 0
27969: PUSH
27970: LD_INT 1
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 1
27979: NEG
27980: PUSH
27981: LD_INT 0
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: PUSH
27988: LD_INT 1
27990: NEG
27991: PUSH
27992: LD_INT 1
27994: NEG
27995: PUSH
27996: EMPTY
27997: LIST
27998: LIST
27999: PUSH
28000: LD_INT 1
28002: NEG
28003: PUSH
28004: LD_INT 2
28006: NEG
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 0
28014: PUSH
28015: LD_INT 2
28017: NEG
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: LD_INT 1
28025: PUSH
28026: LD_INT 1
28028: NEG
28029: PUSH
28030: EMPTY
28031: LIST
28032: LIST
28033: PUSH
28034: LD_INT 2
28036: PUSH
28037: LD_INT 0
28039: PUSH
28040: EMPTY
28041: LIST
28042: LIST
28043: PUSH
28044: LD_INT 2
28046: PUSH
28047: LD_INT 1
28049: PUSH
28050: EMPTY
28051: LIST
28052: LIST
28053: PUSH
28054: LD_INT 2
28056: PUSH
28057: LD_INT 2
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 1
28066: PUSH
28067: LD_INT 2
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: LD_INT 0
28076: PUSH
28077: LD_INT 2
28079: PUSH
28080: EMPTY
28081: LIST
28082: LIST
28083: PUSH
28084: LD_INT 1
28086: NEG
28087: PUSH
28088: LD_INT 1
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 2
28097: NEG
28098: PUSH
28099: LD_INT 0
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: NEG
28109: PUSH
28110: LD_INT 1
28112: NEG
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 2
28120: NEG
28121: PUSH
28122: LD_INT 2
28124: NEG
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: EMPTY
28131: LIST
28132: LIST
28133: LIST
28134: LIST
28135: LIST
28136: LIST
28137: LIST
28138: LIST
28139: LIST
28140: LIST
28141: LIST
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: LIST
28149: LIST
28150: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28151: LD_ADDR_VAR 0 21
28155: PUSH
28156: LD_INT 0
28158: PUSH
28159: LD_INT 0
28161: PUSH
28162: EMPTY
28163: LIST
28164: LIST
28165: PUSH
28166: LD_INT 0
28168: PUSH
28169: LD_INT 1
28171: NEG
28172: PUSH
28173: EMPTY
28174: LIST
28175: LIST
28176: PUSH
28177: LD_INT 1
28179: PUSH
28180: LD_INT 0
28182: PUSH
28183: EMPTY
28184: LIST
28185: LIST
28186: PUSH
28187: LD_INT 1
28189: PUSH
28190: LD_INT 1
28192: PUSH
28193: EMPTY
28194: LIST
28195: LIST
28196: PUSH
28197: LD_INT 0
28199: PUSH
28200: LD_INT 1
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 1
28209: NEG
28210: PUSH
28211: LD_INT 0
28213: PUSH
28214: EMPTY
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 1
28220: NEG
28221: PUSH
28222: LD_INT 1
28224: NEG
28225: PUSH
28226: EMPTY
28227: LIST
28228: LIST
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: LD_INT 2
28236: NEG
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 2
28247: NEG
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: PUSH
28253: LD_INT 1
28255: PUSH
28256: LD_INT 1
28258: NEG
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PUSH
28264: LD_INT 2
28266: PUSH
28267: LD_INT 0
28269: PUSH
28270: EMPTY
28271: LIST
28272: LIST
28273: PUSH
28274: LD_INT 2
28276: PUSH
28277: LD_INT 1
28279: PUSH
28280: EMPTY
28281: LIST
28282: LIST
28283: PUSH
28284: LD_INT 2
28286: PUSH
28287: LD_INT 2
28289: PUSH
28290: EMPTY
28291: LIST
28292: LIST
28293: PUSH
28294: LD_INT 1
28296: PUSH
28297: LD_INT 2
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 0
28306: PUSH
28307: LD_INT 2
28309: PUSH
28310: EMPTY
28311: LIST
28312: LIST
28313: PUSH
28314: LD_INT 1
28316: NEG
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PUSH
28325: LD_INT 2
28327: NEG
28328: PUSH
28329: LD_INT 0
28331: PUSH
28332: EMPTY
28333: LIST
28334: LIST
28335: PUSH
28336: LD_INT 2
28338: NEG
28339: PUSH
28340: LD_INT 1
28342: NEG
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 2
28350: NEG
28351: PUSH
28352: LD_INT 2
28354: NEG
28355: PUSH
28356: EMPTY
28357: LIST
28358: LIST
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: LIST
28364: LIST
28365: LIST
28366: LIST
28367: LIST
28368: LIST
28369: LIST
28370: LIST
28371: LIST
28372: LIST
28373: LIST
28374: LIST
28375: LIST
28376: LIST
28377: LIST
28378: LIST
28379: LIST
28380: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28381: LD_ADDR_VAR 0 22
28385: PUSH
28386: LD_INT 0
28388: PUSH
28389: LD_INT 0
28391: PUSH
28392: EMPTY
28393: LIST
28394: LIST
28395: PUSH
28396: LD_INT 0
28398: PUSH
28399: LD_INT 1
28401: NEG
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: PUSH
28407: LD_INT 1
28409: PUSH
28410: LD_INT 0
28412: PUSH
28413: EMPTY
28414: LIST
28415: LIST
28416: PUSH
28417: LD_INT 1
28419: PUSH
28420: LD_INT 1
28422: PUSH
28423: EMPTY
28424: LIST
28425: LIST
28426: PUSH
28427: LD_INT 0
28429: PUSH
28430: LD_INT 1
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 1
28439: NEG
28440: PUSH
28441: LD_INT 0
28443: PUSH
28444: EMPTY
28445: LIST
28446: LIST
28447: PUSH
28448: LD_INT 1
28450: NEG
28451: PUSH
28452: LD_INT 1
28454: NEG
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: PUSH
28460: LD_INT 1
28462: NEG
28463: PUSH
28464: LD_INT 2
28466: NEG
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: PUSH
28472: LD_INT 0
28474: PUSH
28475: LD_INT 2
28477: NEG
28478: PUSH
28479: EMPTY
28480: LIST
28481: LIST
28482: PUSH
28483: LD_INT 1
28485: PUSH
28486: LD_INT 1
28488: NEG
28489: PUSH
28490: EMPTY
28491: LIST
28492: LIST
28493: PUSH
28494: LD_INT 2
28496: PUSH
28497: LD_INT 0
28499: PUSH
28500: EMPTY
28501: LIST
28502: LIST
28503: PUSH
28504: LD_INT 2
28506: PUSH
28507: LD_INT 1
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 2
28516: PUSH
28517: LD_INT 2
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 2
28557: NEG
28558: PUSH
28559: LD_INT 0
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: PUSH
28566: LD_INT 2
28568: NEG
28569: PUSH
28570: LD_INT 1
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 2
28580: NEG
28581: PUSH
28582: LD_INT 2
28584: NEG
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
28611: LD_ADDR_VAR 0 23
28615: PUSH
28616: LD_INT 0
28618: PUSH
28619: LD_INT 0
28621: PUSH
28622: EMPTY
28623: LIST
28624: LIST
28625: PUSH
28626: LD_INT 0
28628: PUSH
28629: LD_INT 1
28631: NEG
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 1
28639: PUSH
28640: LD_INT 0
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 1
28649: PUSH
28650: LD_INT 1
28652: PUSH
28653: EMPTY
28654: LIST
28655: LIST
28656: PUSH
28657: LD_INT 0
28659: PUSH
28660: LD_INT 1
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: PUSH
28667: LD_INT 1
28669: NEG
28670: PUSH
28671: LD_INT 0
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: LD_INT 1
28684: NEG
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 1
28692: NEG
28693: PUSH
28694: LD_INT 2
28696: NEG
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 0
28704: PUSH
28705: LD_INT 2
28707: NEG
28708: PUSH
28709: EMPTY
28710: LIST
28711: LIST
28712: PUSH
28713: LD_INT 1
28715: PUSH
28716: LD_INT 1
28718: NEG
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 2
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 2
28736: PUSH
28737: LD_INT 1
28739: PUSH
28740: EMPTY
28741: LIST
28742: LIST
28743: PUSH
28744: LD_INT 2
28746: PUSH
28747: LD_INT 2
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 1
28756: PUSH
28757: LD_INT 2
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 0
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: EMPTY
28771: LIST
28772: LIST
28773: PUSH
28774: LD_INT 1
28776: NEG
28777: PUSH
28778: LD_INT 1
28780: PUSH
28781: EMPTY
28782: LIST
28783: LIST
28784: PUSH
28785: LD_INT 2
28787: NEG
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: PUSH
28796: LD_INT 2
28798: NEG
28799: PUSH
28800: LD_INT 1
28802: NEG
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 2
28810: NEG
28811: PUSH
28812: LD_INT 2
28814: NEG
28815: PUSH
28816: EMPTY
28817: LIST
28818: LIST
28819: PUSH
28820: LD_INT 2
28822: NEG
28823: PUSH
28824: LD_INT 3
28826: NEG
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 1
28834: NEG
28835: PUSH
28836: LD_INT 3
28838: NEG
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: PUSH
28844: LD_INT 1
28846: PUSH
28847: LD_INT 2
28849: NEG
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: PUSH
28855: LD_INT 2
28857: PUSH
28858: LD_INT 1
28860: NEG
28861: PUSH
28862: EMPTY
28863: LIST
28864: LIST
28865: PUSH
28866: EMPTY
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: LIST
28873: LIST
28874: LIST
28875: LIST
28876: LIST
28877: LIST
28878: LIST
28879: LIST
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: LIST
28887: LIST
28888: LIST
28889: LIST
28890: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
28891: LD_ADDR_VAR 0 24
28895: PUSH
28896: LD_INT 0
28898: PUSH
28899: LD_INT 0
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 0
28908: PUSH
28909: LD_INT 1
28911: NEG
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 1
28919: PUSH
28920: LD_INT 0
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 1
28929: PUSH
28930: LD_INT 1
28932: PUSH
28933: EMPTY
28934: LIST
28935: LIST
28936: PUSH
28937: LD_INT 0
28939: PUSH
28940: LD_INT 1
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 1
28949: NEG
28950: PUSH
28951: LD_INT 0
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 1
28960: NEG
28961: PUSH
28962: LD_INT 1
28964: NEG
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 2
28976: NEG
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: LD_INT 0
28984: PUSH
28985: LD_INT 2
28987: NEG
28988: PUSH
28989: EMPTY
28990: LIST
28991: LIST
28992: PUSH
28993: LD_INT 1
28995: PUSH
28996: LD_INT 1
28998: NEG
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: PUSH
29004: LD_INT 2
29006: PUSH
29007: LD_INT 0
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 2
29016: PUSH
29017: LD_INT 1
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 2
29026: PUSH
29027: LD_INT 2
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 1
29036: PUSH
29037: LD_INT 2
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 0
29046: PUSH
29047: LD_INT 2
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: LD_INT 1
29056: NEG
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 2
29067: NEG
29068: PUSH
29069: LD_INT 0
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: LD_INT 1
29082: NEG
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 2
29090: NEG
29091: PUSH
29092: LD_INT 2
29094: NEG
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: LD_INT 2
29105: NEG
29106: PUSH
29107: EMPTY
29108: LIST
29109: LIST
29110: PUSH
29111: LD_INT 2
29113: PUSH
29114: LD_INT 1
29116: NEG
29117: PUSH
29118: EMPTY
29119: LIST
29120: LIST
29121: PUSH
29122: LD_INT 3
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: PUSH
29132: LD_INT 3
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: EMPTY
29139: LIST
29140: LIST
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: LIST
29146: LIST
29147: LIST
29148: LIST
29149: LIST
29150: LIST
29151: LIST
29152: LIST
29153: LIST
29154: LIST
29155: LIST
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
29167: LD_ADDR_VAR 0 25
29171: PUSH
29172: LD_INT 0
29174: PUSH
29175: LD_INT 0
29177: PUSH
29178: EMPTY
29179: LIST
29180: LIST
29181: PUSH
29182: LD_INT 0
29184: PUSH
29185: LD_INT 1
29187: NEG
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 1
29195: PUSH
29196: LD_INT 0
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PUSH
29203: LD_INT 1
29205: PUSH
29206: LD_INT 1
29208: PUSH
29209: EMPTY
29210: LIST
29211: LIST
29212: PUSH
29213: LD_INT 0
29215: PUSH
29216: LD_INT 1
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: PUSH
29223: LD_INT 1
29225: NEG
29226: PUSH
29227: LD_INT 0
29229: PUSH
29230: EMPTY
29231: LIST
29232: LIST
29233: PUSH
29234: LD_INT 1
29236: NEG
29237: PUSH
29238: LD_INT 1
29240: NEG
29241: PUSH
29242: EMPTY
29243: LIST
29244: LIST
29245: PUSH
29246: LD_INT 1
29248: NEG
29249: PUSH
29250: LD_INT 2
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 0
29260: PUSH
29261: LD_INT 2
29263: NEG
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: PUSH
29272: LD_INT 1
29274: NEG
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 2
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 2
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: LD_INT 2
29302: PUSH
29303: LD_INT 2
29305: PUSH
29306: EMPTY
29307: LIST
29308: LIST
29309: PUSH
29310: LD_INT 1
29312: PUSH
29313: LD_INT 2
29315: PUSH
29316: EMPTY
29317: LIST
29318: LIST
29319: PUSH
29320: LD_INT 0
29322: PUSH
29323: LD_INT 2
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: LD_INT 1
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 2
29343: NEG
29344: PUSH
29345: LD_INT 0
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 2
29354: NEG
29355: PUSH
29356: LD_INT 1
29358: NEG
29359: PUSH
29360: EMPTY
29361: LIST
29362: LIST
29363: PUSH
29364: LD_INT 2
29366: NEG
29367: PUSH
29368: LD_INT 2
29370: NEG
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 3
29378: PUSH
29379: LD_INT 1
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 3
29388: PUSH
29389: LD_INT 2
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 2
29398: PUSH
29399: LD_INT 3
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: LD_INT 1
29408: PUSH
29409: LD_INT 3
29411: PUSH
29412: EMPTY
29413: LIST
29414: LIST
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: LIST
29432: LIST
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
29441: LD_ADDR_VAR 0 26
29445: PUSH
29446: LD_INT 0
29448: PUSH
29449: LD_INT 0
29451: PUSH
29452: EMPTY
29453: LIST
29454: LIST
29455: PUSH
29456: LD_INT 0
29458: PUSH
29459: LD_INT 1
29461: NEG
29462: PUSH
29463: EMPTY
29464: LIST
29465: LIST
29466: PUSH
29467: LD_INT 1
29469: PUSH
29470: LD_INT 0
29472: PUSH
29473: EMPTY
29474: LIST
29475: LIST
29476: PUSH
29477: LD_INT 1
29479: PUSH
29480: LD_INT 1
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 0
29489: PUSH
29490: LD_INT 1
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: NEG
29500: PUSH
29501: LD_INT 0
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 1
29510: NEG
29511: PUSH
29512: LD_INT 1
29514: NEG
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 2
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 0
29534: PUSH
29535: LD_INT 2
29537: NEG
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 1
29545: PUSH
29546: LD_INT 1
29548: NEG
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 2
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 2
29566: PUSH
29567: LD_INT 1
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 2
29576: PUSH
29577: LD_INT 2
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 1
29586: PUSH
29587: LD_INT 2
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 0
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 1
29606: NEG
29607: PUSH
29608: LD_INT 1
29610: PUSH
29611: EMPTY
29612: LIST
29613: LIST
29614: PUSH
29615: LD_INT 2
29617: NEG
29618: PUSH
29619: LD_INT 0
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 2
29628: NEG
29629: PUSH
29630: LD_INT 1
29632: NEG
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 2
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: PUSH
29653: LD_INT 3
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: LD_INT 3
29665: PUSH
29666: EMPTY
29667: LIST
29668: LIST
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: LD_INT 2
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 2
29683: NEG
29684: PUSH
29685: LD_INT 1
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: LIST
29716: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29717: LD_ADDR_VAR 0 27
29721: PUSH
29722: LD_INT 0
29724: PUSH
29725: LD_INT 0
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 0
29734: PUSH
29735: LD_INT 1
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 1
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 1
29755: PUSH
29756: LD_INT 1
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 0
29765: PUSH
29766: LD_INT 1
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 1
29775: NEG
29776: PUSH
29777: LD_INT 0
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: NEG
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 2
29802: NEG
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 0
29810: PUSH
29811: LD_INT 2
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: LD_INT 1
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 2
29832: PUSH
29833: LD_INT 0
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 2
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: LD_INT 2
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: PUSH
29863: LD_INT 2
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: LD_INT 2
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: NEG
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 2
29893: NEG
29894: PUSH
29895: LD_INT 0
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 2
29904: NEG
29905: PUSH
29906: LD_INT 1
29908: NEG
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 2
29916: NEG
29917: PUSH
29918: LD_INT 2
29920: NEG
29921: PUSH
29922: EMPTY
29923: LIST
29924: LIST
29925: PUSH
29926: LD_INT 1
29928: NEG
29929: PUSH
29930: LD_INT 2
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: PUSH
29937: LD_INT 2
29939: NEG
29940: PUSH
29941: LD_INT 1
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 3
29950: NEG
29951: PUSH
29952: LD_INT 1
29954: NEG
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 3
29962: NEG
29963: PUSH
29964: LD_INT 2
29966: NEG
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: LIST
29976: LIST
29977: LIST
29978: LIST
29979: LIST
29980: LIST
29981: LIST
29982: LIST
29983: LIST
29984: LIST
29985: LIST
29986: LIST
29987: LIST
29988: LIST
29989: LIST
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
29997: LD_ADDR_VAR 0 28
30001: PUSH
30002: LD_INT 0
30004: PUSH
30005: LD_INT 0
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: LD_INT 1
30017: NEG
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: LD_INT 1
30025: PUSH
30026: LD_INT 0
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 1
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 1
30055: NEG
30056: PUSH
30057: LD_INT 0
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 1
30066: NEG
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 2
30082: NEG
30083: PUSH
30084: EMPTY
30085: LIST
30086: LIST
30087: PUSH
30088: LD_INT 0
30090: PUSH
30091: LD_INT 2
30093: NEG
30094: PUSH
30095: EMPTY
30096: LIST
30097: LIST
30098: PUSH
30099: LD_INT 1
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: PUSH
30113: LD_INT 0
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: LD_INT 1
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 2
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: LD_INT 2
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 0
30152: PUSH
30153: LD_INT 2
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 1
30162: NEG
30163: PUSH
30164: LD_INT 1
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 2
30173: NEG
30174: PUSH
30175: LD_INT 0
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 2
30184: NEG
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 2
30196: NEG
30197: PUSH
30198: LD_INT 2
30200: NEG
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: LD_INT 2
30208: NEG
30209: PUSH
30210: LD_INT 3
30212: NEG
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 1
30220: NEG
30221: PUSH
30222: LD_INT 3
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 3
30232: NEG
30233: PUSH
30234: LD_INT 1
30236: NEG
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 3
30244: NEG
30245: PUSH
30246: LD_INT 2
30248: NEG
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: LIST
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: LIST
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30279: LD_ADDR_VAR 0 29
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: LD_INT 0
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: LD_INT 1
30299: NEG
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: LD_INT 0
30310: PUSH
30311: EMPTY
30312: LIST
30313: LIST
30314: PUSH
30315: LD_INT 1
30317: PUSH
30318: LD_INT 1
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: LD_INT 1
30330: PUSH
30331: EMPTY
30332: LIST
30333: LIST
30334: PUSH
30335: LD_INT 1
30337: NEG
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: NEG
30349: PUSH
30350: LD_INT 1
30352: NEG
30353: PUSH
30354: EMPTY
30355: LIST
30356: LIST
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: LD_INT 2
30364: NEG
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 0
30372: PUSH
30373: LD_INT 2
30375: NEG
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 1
30383: PUSH
30384: LD_INT 1
30386: NEG
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 2
30394: PUSH
30395: LD_INT 0
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: LD_INT 2
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 0
30424: PUSH
30425: LD_INT 2
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: LD_INT 1
30434: NEG
30435: PUSH
30436: LD_INT 1
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 2
30445: NEG
30446: PUSH
30447: LD_INT 1
30449: NEG
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 2
30457: NEG
30458: PUSH
30459: LD_INT 2
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: LD_INT 3
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 2
30481: PUSH
30482: LD_INT 1
30484: NEG
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 3
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: PUSH
30503: LD_INT 3
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 1
30512: NEG
30513: PUSH
30514: LD_INT 2
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 3
30523: NEG
30524: PUSH
30525: LD_INT 2
30527: NEG
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: EMPTY
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: LIST
30544: LIST
30545: LIST
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
30558: LD_ADDR_VAR 0 30
30562: PUSH
30563: LD_INT 0
30565: PUSH
30566: LD_INT 0
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 1
30578: NEG
30579: PUSH
30580: EMPTY
30581: LIST
30582: LIST
30583: PUSH
30584: LD_INT 1
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: PUSH
30597: LD_INT 1
30599: PUSH
30600: EMPTY
30601: LIST
30602: LIST
30603: PUSH
30604: LD_INT 0
30606: PUSH
30607: LD_INT 1
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: NEG
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: PUSH
30625: LD_INT 1
30627: NEG
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: NEG
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 0
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 1
30662: PUSH
30663: LD_INT 1
30665: NEG
30666: PUSH
30667: EMPTY
30668: LIST
30669: LIST
30670: PUSH
30671: LD_INT 2
30673: PUSH
30674: LD_INT 0
30676: PUSH
30677: EMPTY
30678: LIST
30679: LIST
30680: PUSH
30681: LD_INT 2
30683: PUSH
30684: LD_INT 1
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 2
30693: PUSH
30694: LD_INT 2
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 1
30703: PUSH
30704: LD_INT 2
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: NEG
30714: PUSH
30715: LD_INT 1
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 2
30735: NEG
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 3
30751: NEG
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 1
30759: PUSH
30760: LD_INT 2
30762: NEG
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 3
30770: PUSH
30771: LD_INT 2
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: PUSH
30781: LD_INT 3
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: LD_INT 1
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 3
30801: NEG
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: LIST
30821: LIST
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
30836: LD_ADDR_VAR 0 31
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: LD_INT 0
30846: PUSH
30847: EMPTY
30848: LIST
30849: LIST
30850: PUSH
30851: LD_INT 0
30853: PUSH
30854: LD_INT 1
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 0
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: LD_INT 1
30874: PUSH
30875: LD_INT 1
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 0
30884: PUSH
30885: LD_INT 1
30887: PUSH
30888: EMPTY
30889: LIST
30890: LIST
30891: PUSH
30892: LD_INT 1
30894: NEG
30895: PUSH
30896: LD_INT 0
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: NEG
30906: PUSH
30907: LD_INT 1
30909: NEG
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: LD_INT 1
30917: NEG
30918: PUSH
30919: LD_INT 2
30921: NEG
30922: PUSH
30923: EMPTY
30924: LIST
30925: LIST
30926: PUSH
30927: LD_INT 1
30929: PUSH
30930: LD_INT 1
30932: NEG
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: PUSH
30938: LD_INT 2
30940: PUSH
30941: LD_INT 0
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 2
30950: PUSH
30951: LD_INT 1
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 2
30960: PUSH
30961: LD_INT 2
30963: PUSH
30964: EMPTY
30965: LIST
30966: LIST
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: LD_INT 2
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: LD_INT 2
30983: PUSH
30984: EMPTY
30985: LIST
30986: LIST
30987: PUSH
30988: LD_INT 1
30990: NEG
30991: PUSH
30992: LD_INT 1
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 2
31001: NEG
31002: PUSH
31003: LD_INT 1
31005: NEG
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 2
31013: NEG
31014: PUSH
31015: LD_INT 2
31017: NEG
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: LD_INT 3
31029: NEG
31030: PUSH
31031: EMPTY
31032: LIST
31033: LIST
31034: PUSH
31035: LD_INT 2
31037: PUSH
31038: LD_INT 1
31040: NEG
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: PUSH
31046: LD_INT 3
31048: PUSH
31049: LD_INT 1
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 3
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 3
31079: NEG
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: LIST
31099: LIST
31100: LIST
31101: LIST
31102: LIST
31103: LIST
31104: LIST
31105: LIST
31106: LIST
31107: LIST
31108: LIST
31109: LIST
31110: LIST
31111: LIST
31112: LIST
31113: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31114: LD_ADDR_VAR 0 32
31118: PUSH
31119: LD_INT 0
31121: PUSH
31122: LD_INT 0
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 0
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 1
31142: PUSH
31143: LD_INT 0
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: PUSH
31153: LD_INT 1
31155: PUSH
31156: EMPTY
31157: LIST
31158: LIST
31159: PUSH
31160: LD_INT 0
31162: PUSH
31163: LD_INT 1
31165: PUSH
31166: EMPTY
31167: LIST
31168: LIST
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: EMPTY
31178: LIST
31179: LIST
31180: PUSH
31181: LD_INT 1
31183: NEG
31184: PUSH
31185: LD_INT 1
31187: NEG
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: NEG
31196: PUSH
31197: LD_INT 2
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 0
31207: PUSH
31208: LD_INT 2
31210: NEG
31211: PUSH
31212: EMPTY
31213: LIST
31214: LIST
31215: PUSH
31216: LD_INT 1
31218: PUSH
31219: LD_INT 1
31221: NEG
31222: PUSH
31223: EMPTY
31224: LIST
31225: LIST
31226: PUSH
31227: LD_INT 2
31229: PUSH
31230: LD_INT 1
31232: PUSH
31233: EMPTY
31234: LIST
31235: LIST
31236: PUSH
31237: LD_INT 2
31239: PUSH
31240: LD_INT 2
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 1
31249: PUSH
31250: LD_INT 2
31252: PUSH
31253: EMPTY
31254: LIST
31255: LIST
31256: PUSH
31257: LD_INT 0
31259: PUSH
31260: LD_INT 2
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 1
31269: NEG
31270: PUSH
31271: LD_INT 1
31273: PUSH
31274: EMPTY
31275: LIST
31276: LIST
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: LD_INT 0
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: LD_INT 1
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 1
31303: NEG
31304: PUSH
31305: LD_INT 3
31307: NEG
31308: PUSH
31309: EMPTY
31310: LIST
31311: LIST
31312: PUSH
31313: LD_INT 1
31315: PUSH
31316: LD_INT 2
31318: NEG
31319: PUSH
31320: EMPTY
31321: LIST
31322: LIST
31323: PUSH
31324: LD_INT 3
31326: PUSH
31327: LD_INT 2
31329: PUSH
31330: EMPTY
31331: LIST
31332: LIST
31333: PUSH
31334: LD_INT 2
31336: PUSH
31337: LD_INT 3
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 3
31357: NEG
31358: PUSH
31359: LD_INT 1
31361: NEG
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
31392: LD_ADDR_VAR 0 33
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 0
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 0
31423: PUSH
31424: EMPTY
31425: LIST
31426: LIST
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: EMPTY
31435: LIST
31436: LIST
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: LD_INT 1
31443: PUSH
31444: EMPTY
31445: LIST
31446: LIST
31447: PUSH
31448: LD_INT 1
31450: NEG
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: LD_INT 1
31473: NEG
31474: PUSH
31475: LD_INT 2
31477: NEG
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 1
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 2
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: EMPTY
31501: LIST
31502: LIST
31503: PUSH
31504: LD_INT 2
31506: PUSH
31507: LD_INT 1
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: PUSH
31517: LD_INT 2
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 0
31526: PUSH
31527: LD_INT 2
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: LD_INT 1
31536: NEG
31537: PUSH
31538: LD_INT 1
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 2
31547: NEG
31548: PUSH
31549: LD_INT 0
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 2
31558: NEG
31559: PUSH
31560: LD_INT 1
31562: NEG
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 2
31570: NEG
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: LD_INT 2
31582: NEG
31583: PUSH
31584: LD_INT 3
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: LD_INT 1
31597: NEG
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 3
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: LD_INT 1
31615: PUSH
31616: LD_INT 3
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 3
31636: NEG
31637: PUSH
31638: LD_INT 2
31640: NEG
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
31671: LD_ADDR_VAR 0 34
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 0
31688: PUSH
31689: LD_INT 1
31691: NEG
31692: PUSH
31693: EMPTY
31694: LIST
31695: LIST
31696: PUSH
31697: LD_INT 1
31699: PUSH
31700: LD_INT 0
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 1
31709: PUSH
31710: LD_INT 1
31712: PUSH
31713: EMPTY
31714: LIST
31715: LIST
31716: PUSH
31717: LD_INT 0
31719: PUSH
31720: LD_INT 1
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PUSH
31727: LD_INT 1
31729: NEG
31730: PUSH
31731: LD_INT 0
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: LD_INT 1
31744: NEG
31745: PUSH
31746: EMPTY
31747: LIST
31748: LIST
31749: PUSH
31750: LD_INT 1
31752: NEG
31753: PUSH
31754: LD_INT 2
31756: NEG
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 0
31764: PUSH
31765: LD_INT 2
31767: NEG
31768: PUSH
31769: EMPTY
31770: LIST
31771: LIST
31772: PUSH
31773: LD_INT 1
31775: PUSH
31776: LD_INT 1
31778: NEG
31779: PUSH
31780: EMPTY
31781: LIST
31782: LIST
31783: PUSH
31784: LD_INT 2
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: EMPTY
31791: LIST
31792: LIST
31793: PUSH
31794: LD_INT 2
31796: PUSH
31797: LD_INT 2
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 1
31806: PUSH
31807: LD_INT 2
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 1
31816: NEG
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 2
31827: NEG
31828: PUSH
31829: LD_INT 0
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 2
31838: NEG
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 2
31850: NEG
31851: PUSH
31852: LD_INT 2
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: LD_INT 3
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 3
31885: PUSH
31886: LD_INT 2
31888: PUSH
31889: EMPTY
31890: LIST
31891: LIST
31892: PUSH
31893: LD_INT 2
31895: PUSH
31896: LD_INT 3
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 2
31905: NEG
31906: PUSH
31907: LD_INT 1
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 3
31916: NEG
31917: PUSH
31918: LD_INT 1
31920: NEG
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
31951: LD_ADDR_VAR 0 35
31955: PUSH
31956: LD_INT 0
31958: PUSH
31959: LD_INT 0
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 0
31968: PUSH
31969: LD_INT 1
31971: NEG
31972: PUSH
31973: EMPTY
31974: LIST
31975: LIST
31976: PUSH
31977: LD_INT 1
31979: PUSH
31980: LD_INT 0
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 1
31989: PUSH
31990: LD_INT 1
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: LD_INT 0
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 1
32009: NEG
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: EMPTY
32015: LIST
32016: LIST
32017: PUSH
32018: LD_INT 1
32020: NEG
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 2
32042: NEG
32043: PUSH
32044: LD_INT 1
32046: NEG
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32063: LD_ADDR_VAR 0 36
32067: PUSH
32068: LD_INT 0
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: LD_INT 0
32080: PUSH
32081: LD_INT 1
32083: NEG
32084: PUSH
32085: EMPTY
32086: LIST
32087: LIST
32088: PUSH
32089: LD_INT 1
32091: PUSH
32092: LD_INT 0
32094: PUSH
32095: EMPTY
32096: LIST
32097: LIST
32098: PUSH
32099: LD_INT 1
32101: PUSH
32102: LD_INT 1
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 0
32111: PUSH
32112: LD_INT 1
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 1
32121: NEG
32122: PUSH
32123: LD_INT 0
32125: PUSH
32126: EMPTY
32127: LIST
32128: LIST
32129: PUSH
32130: LD_INT 1
32132: NEG
32133: PUSH
32134: LD_INT 1
32136: NEG
32137: PUSH
32138: EMPTY
32139: LIST
32140: LIST
32141: PUSH
32142: LD_INT 1
32144: NEG
32145: PUSH
32146: LD_INT 2
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 1
32156: PUSH
32157: LD_INT 2
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32175: LD_ADDR_VAR 0 37
32179: PUSH
32180: LD_INT 0
32182: PUSH
32183: LD_INT 0
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: EMPTY
32208: LIST
32209: LIST
32210: PUSH
32211: LD_INT 1
32213: PUSH
32214: LD_INT 1
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: LD_INT 1
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 1
32256: PUSH
32257: LD_INT 1
32259: NEG
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: NEG
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
32287: LD_ADDR_VAR 0 38
32291: PUSH
32292: LD_INT 0
32294: PUSH
32295: LD_INT 0
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 0
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 1
32325: PUSH
32326: LD_INT 1
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 0
32335: PUSH
32336: LD_INT 1
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 1
32345: NEG
32346: PUSH
32347: LD_INT 0
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 1
32356: NEG
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 2
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 2
32378: NEG
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
32399: LD_ADDR_VAR 0 39
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 0
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: LD_INT 0
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 1
32457: NEG
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 1
32468: NEG
32469: PUSH
32470: LD_INT 1
32472: NEG
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 1
32480: NEG
32481: PUSH
32482: LD_INT 2
32484: NEG
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: PUSH
32493: LD_INT 2
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: LIST
32504: LIST
32505: LIST
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
32511: LD_ADDR_VAR 0 40
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: LD_INT 0
32521: PUSH
32522: EMPTY
32523: LIST
32524: LIST
32525: PUSH
32526: LD_INT 0
32528: PUSH
32529: LD_INT 1
32531: NEG
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PUSH
32537: LD_INT 1
32539: PUSH
32540: LD_INT 0
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 1
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 0
32559: PUSH
32560: LD_INT 1
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 1
32569: NEG
32570: PUSH
32571: LD_INT 0
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PUSH
32578: LD_INT 1
32580: NEG
32581: PUSH
32582: LD_INT 1
32584: NEG
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: PUSH
32590: LD_INT 1
32592: PUSH
32593: LD_INT 1
32595: NEG
32596: PUSH
32597: EMPTY
32598: LIST
32599: LIST
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: LD_INT 1
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32623: LD_ADDR_VAR 0 41
32627: PUSH
32628: LD_INT 0
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 0
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 1
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 1
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 0
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 2
32778: NEG
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 2
32789: NEG
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 2
32801: NEG
32802: PUSH
32803: LD_INT 2
32805: NEG
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 2
32813: NEG
32814: PUSH
32815: LD_INT 3
32817: NEG
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: LD_INT 2
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 3
32836: PUSH
32837: LD_INT 0
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 3
32846: PUSH
32847: LD_INT 1
32849: PUSH
32850: EMPTY
32851: LIST
32852: LIST
32853: PUSH
32854: LD_INT 3
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: PUSH
32867: LD_INT 3
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: PUSH
32874: LD_INT 2
32876: PUSH
32877: LD_INT 3
32879: PUSH
32880: EMPTY
32881: LIST
32882: LIST
32883: PUSH
32884: LD_INT 2
32886: NEG
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 3
32897: NEG
32898: PUSH
32899: LD_INT 0
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 3
32908: NEG
32909: PUSH
32910: LD_INT 1
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 3
32920: NEG
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 3
32932: NEG
32933: PUSH
32934: LD_INT 3
32936: NEG
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32973: LD_ADDR_VAR 0 42
32977: PUSH
32978: LD_INT 0
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 0
32990: PUSH
32991: LD_INT 1
32993: NEG
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 1
33001: PUSH
33002: LD_INT 0
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 1
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 1
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: LD_INT 0
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 1
33042: NEG
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: EMPTY
33049: LIST
33050: LIST
33051: PUSH
33052: LD_INT 1
33054: NEG
33055: PUSH
33056: LD_INT 2
33058: NEG
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: LD_INT 2
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 1
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 2
33088: PUSH
33089: LD_INT 1
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: LD_INT 2
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 1
33108: PUSH
33109: LD_INT 2
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 0
33118: PUSH
33119: LD_INT 2
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: LD_INT 1
33143: NEG
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 2
33163: NEG
33164: PUSH
33165: LD_INT 3
33167: NEG
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: NEG
33176: PUSH
33177: LD_INT 3
33179: NEG
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 0
33187: PUSH
33188: LD_INT 3
33190: NEG
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 1
33198: PUSH
33199: LD_INT 2
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 3
33209: PUSH
33210: LD_INT 2
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 3
33219: PUSH
33220: LD_INT 3
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 2
33229: PUSH
33230: LD_INT 3
33232: PUSH
33233: EMPTY
33234: LIST
33235: LIST
33236: PUSH
33237: LD_INT 1
33239: PUSH
33240: LD_INT 3
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: LD_INT 3
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 1
33259: NEG
33260: PUSH
33261: LD_INT 2
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 3
33270: NEG
33271: PUSH
33272: LD_INT 2
33274: NEG
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: PUSH
33280: LD_INT 3
33282: NEG
33283: PUSH
33284: LD_INT 3
33286: NEG
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
33323: LD_ADDR_VAR 0 43
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 0
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 0
33340: PUSH
33341: LD_INT 1
33343: NEG
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: PUSH
33352: LD_INT 0
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: PUSH
33362: LD_INT 1
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: LD_INT 1
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: NEG
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 1
33396: NEG
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 1
33404: NEG
33405: PUSH
33406: LD_INT 2
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 0
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 1
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 2
33438: PUSH
33439: LD_INT 0
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 2
33448: PUSH
33449: LD_INT 1
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 1
33458: PUSH
33459: LD_INT 2
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: LD_INT 2
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: NEG
33479: PUSH
33480: LD_INT 1
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 2
33489: NEG
33490: PUSH
33491: LD_INT 0
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: NEG
33501: PUSH
33502: LD_INT 1
33504: NEG
33505: PUSH
33506: EMPTY
33507: LIST
33508: LIST
33509: PUSH
33510: LD_INT 1
33512: NEG
33513: PUSH
33514: LD_INT 3
33516: NEG
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 0
33524: PUSH
33525: LD_INT 3
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 2
33546: PUSH
33547: LD_INT 1
33549: NEG
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: LD_INT 3
33557: PUSH
33558: LD_INT 0
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: LD_INT 3
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 1
33577: PUSH
33578: LD_INT 3
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 3
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 1
33597: NEG
33598: PUSH
33599: LD_INT 2
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 2
33608: NEG
33609: PUSH
33610: LD_INT 1
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 3
33619: NEG
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 3
33630: NEG
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: LIST
33644: LIST
33645: LIST
33646: LIST
33647: LIST
33648: LIST
33649: LIST
33650: LIST
33651: LIST
33652: LIST
33653: LIST
33654: LIST
33655: LIST
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: LIST
33661: LIST
33662: LIST
33663: LIST
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
33671: LD_ADDR_VAR 0 44
33675: PUSH
33676: LD_INT 0
33678: PUSH
33679: LD_INT 0
33681: PUSH
33682: EMPTY
33683: LIST
33684: LIST
33685: PUSH
33686: LD_INT 0
33688: PUSH
33689: LD_INT 1
33691: NEG
33692: PUSH
33693: EMPTY
33694: LIST
33695: LIST
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: PUSH
33707: LD_INT 1
33709: PUSH
33710: LD_INT 1
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: LD_INT 1
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: LD_INT 0
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 1
33740: NEG
33741: PUSH
33742: LD_INT 1
33744: NEG
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 1
33752: NEG
33753: PUSH
33754: LD_INT 2
33756: NEG
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: LD_INT 1
33767: NEG
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: LD_INT 2
33775: PUSH
33776: LD_INT 0
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 2
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: LD_INT 2
33795: PUSH
33796: LD_INT 2
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: LD_INT 2
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 1
33815: NEG
33816: PUSH
33817: LD_INT 1
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 2
33826: NEG
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 2
33837: NEG
33838: PUSH
33839: LD_INT 1
33841: NEG
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 2
33849: NEG
33850: PUSH
33851: LD_INT 2
33853: NEG
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: NEG
33862: PUSH
33863: LD_INT 3
33865: NEG
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 2
33873: PUSH
33874: LD_INT 1
33876: NEG
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 3
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 3
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 3
33904: PUSH
33905: LD_INT 2
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 3
33914: PUSH
33915: LD_INT 3
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: PUSH
33922: LD_INT 2
33924: PUSH
33925: LD_INT 3
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 2
33934: NEG
33935: PUSH
33936: LD_INT 1
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 3
33945: NEG
33946: PUSH
33947: LD_INT 0
33949: PUSH
33950: EMPTY
33951: LIST
33952: LIST
33953: PUSH
33954: LD_INT 3
33956: NEG
33957: PUSH
33958: LD_INT 1
33960: NEG
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 3
33968: NEG
33969: PUSH
33970: LD_INT 2
33972: NEG
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 3
33980: NEG
33981: PUSH
33982: LD_INT 3
33984: NEG
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: EMPTY
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: LIST
34014: LIST
34015: LIST
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34021: LD_ADDR_VAR 0 45
34025: PUSH
34026: LD_INT 0
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: LD_INT 1
34041: NEG
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 1
34059: PUSH
34060: LD_INT 1
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: LD_INT 1
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 1
34090: NEG
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: LD_INT 2
34106: NEG
34107: PUSH
34108: EMPTY
34109: LIST
34110: LIST
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: LD_INT 2
34117: NEG
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: LD_INT 1
34128: NEG
34129: PUSH
34130: EMPTY
34131: LIST
34132: LIST
34133: PUSH
34134: LD_INT 2
34136: PUSH
34137: LD_INT 1
34139: PUSH
34140: EMPTY
34141: LIST
34142: LIST
34143: PUSH
34144: LD_INT 2
34146: PUSH
34147: LD_INT 2
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 1
34156: PUSH
34157: LD_INT 2
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 0
34166: PUSH
34167: LD_INT 2
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: LD_INT 1
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: LD_INT 1
34191: NEG
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 2
34199: NEG
34200: PUSH
34201: LD_INT 2
34203: NEG
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: NEG
34212: PUSH
34213: LD_INT 3
34215: NEG
34216: PUSH
34217: EMPTY
34218: LIST
34219: LIST
34220: PUSH
34221: LD_INT 1
34223: NEG
34224: PUSH
34225: LD_INT 3
34227: NEG
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: LD_INT 3
34238: NEG
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: LD_INT 2
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 3
34267: PUSH
34268: LD_INT 3
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 2
34277: PUSH
34278: LD_INT 3
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 1
34287: PUSH
34288: LD_INT 3
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 0
34297: PUSH
34298: LD_INT 3
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 1
34307: NEG
34308: PUSH
34309: LD_INT 2
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 3
34318: NEG
34319: PUSH
34320: LD_INT 2
34322: NEG
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: LD_INT 3
34330: NEG
34331: PUSH
34332: LD_INT 3
34334: NEG
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: LIST
34364: LIST
34365: LIST
34366: LIST
34367: LIST
34368: LIST
34369: LIST
34370: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34371: LD_ADDR_VAR 0 46
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 0
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: LD_INT 1
34391: NEG
34392: PUSH
34393: EMPTY
34394: LIST
34395: LIST
34396: PUSH
34397: LD_INT 1
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: EMPTY
34404: LIST
34405: LIST
34406: PUSH
34407: LD_INT 1
34409: PUSH
34410: LD_INT 1
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 0
34419: PUSH
34420: LD_INT 1
34422: PUSH
34423: EMPTY
34424: LIST
34425: LIST
34426: PUSH
34427: LD_INT 1
34429: NEG
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: NEG
34441: PUSH
34442: LD_INT 1
34444: NEG
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: NEG
34453: PUSH
34454: LD_INT 2
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 2
34467: NEG
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 1
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 2
34486: PUSH
34487: LD_INT 0
34489: PUSH
34490: EMPTY
34491: LIST
34492: LIST
34493: PUSH
34494: LD_INT 2
34496: PUSH
34497: LD_INT 1
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 0
34516: PUSH
34517: LD_INT 2
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 1
34526: NEG
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 2
34537: NEG
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: LD_INT 2
34548: NEG
34549: PUSH
34550: LD_INT 1
34552: NEG
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: LD_INT 3
34564: NEG
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 0
34572: PUSH
34573: LD_INT 3
34575: NEG
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 1
34583: PUSH
34584: LD_INT 2
34586: NEG
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 2
34594: PUSH
34595: LD_INT 1
34597: NEG
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 3
34605: PUSH
34606: LD_INT 0
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 3
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 0
34635: PUSH
34636: LD_INT 3
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 1
34645: NEG
34646: PUSH
34647: LD_INT 2
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 2
34656: NEG
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 3
34667: NEG
34668: PUSH
34669: LD_INT 0
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 3
34678: NEG
34679: PUSH
34680: LD_INT 1
34682: NEG
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34719: LD_ADDR_VAR 0 47
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: LD_INT 1
34739: NEG
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 1
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: PUSH
34758: LD_INT 1
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: NEG
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: NEG
34789: PUSH
34790: LD_INT 1
34792: NEG
34793: PUSH
34794: EMPTY
34795: LIST
34796: LIST
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: LD_INT 2
34804: NEG
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: LD_INT 2
34815: NEG
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 1
34823: PUSH
34824: LD_INT 1
34826: NEG
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PUSH
34832: LD_INT 2
34834: NEG
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: EMPTY
34841: LIST
34842: LIST
34843: PUSH
34844: LD_INT 2
34846: NEG
34847: PUSH
34848: LD_INT 2
34850: NEG
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: EMPTY
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: LIST
34862: LIST
34863: LIST
34864: LIST
34865: LIST
34866: LIST
34867: LIST
34868: LIST
34869: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
34870: LD_ADDR_VAR 0 48
34874: PUSH
34875: LD_INT 0
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 1
34898: PUSH
34899: LD_INT 0
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 1
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 1
34928: NEG
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 1
34951: NEG
34952: PUSH
34953: LD_INT 2
34955: NEG
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: LD_INT 2
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 1
34974: PUSH
34975: LD_INT 1
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 2
34985: PUSH
34986: LD_INT 0
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 2
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
35017: LD_ADDR_VAR 0 49
35021: PUSH
35022: LD_INT 0
35024: PUSH
35025: LD_INT 0
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 0
35034: PUSH
35035: LD_INT 1
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 0
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 1
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: LD_INT 0
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: LD_INT 1
35090: NEG
35091: PUSH
35092: EMPTY
35093: LIST
35094: LIST
35095: PUSH
35096: LD_INT 1
35098: PUSH
35099: LD_INT 1
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 2
35109: PUSH
35110: LD_INT 0
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: LD_INT 2
35119: PUSH
35120: LD_INT 1
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 2
35129: PUSH
35130: LD_INT 2
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 1
35139: PUSH
35140: LD_INT 2
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: LIST
35151: LIST
35152: LIST
35153: LIST
35154: LIST
35155: LIST
35156: LIST
35157: LIST
35158: LIST
35159: LIST
35160: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
35161: LD_ADDR_VAR 0 50
35165: PUSH
35166: LD_INT 0
35168: PUSH
35169: LD_INT 0
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 1
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 0
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: LD_INT 1
35199: PUSH
35200: LD_INT 1
35202: PUSH
35203: EMPTY
35204: LIST
35205: LIST
35206: PUSH
35207: LD_INT 0
35209: PUSH
35210: LD_INT 1
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 1
35230: NEG
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: EMPTY
35237: LIST
35238: LIST
35239: PUSH
35240: LD_INT 2
35242: PUSH
35243: LD_INT 1
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 2
35252: PUSH
35253: LD_INT 2
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: LD_INT 2
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 0
35272: PUSH
35273: LD_INT 2
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 1
35282: NEG
35283: PUSH
35284: LD_INT 1
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
35305: LD_ADDR_VAR 0 51
35309: PUSH
35310: LD_INT 0
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: LD_INT 1
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 0
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: PUSH
35344: LD_INT 1
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 1
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: LD_INT 0
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: NEG
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 1
35386: PUSH
35387: LD_INT 2
35389: PUSH
35390: EMPTY
35391: LIST
35392: LIST
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: LD_INT 2
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: LD_INT 1
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 2
35417: NEG
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35452: LD_ADDR_VAR 0 52
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 0
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 0
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: NEG
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 1
35521: NEG
35522: PUSH
35523: LD_INT 1
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: NEG
35534: PUSH
35535: LD_INT 2
35537: NEG
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 1
35545: NEG
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: NEG
35557: PUSH
35558: LD_INT 0
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 2
35567: NEG
35568: PUSH
35569: LD_INT 1
35571: NEG
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: LD_INT 2
35579: NEG
35580: PUSH
35581: LD_INT 2
35583: NEG
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: LIST
35593: LIST
35594: LIST
35595: LIST
35596: LIST
35597: LIST
35598: LIST
35599: LIST
35600: LIST
35601: LIST
35602: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35603: LD_ADDR_VAR 0 53
35607: PUSH
35608: LD_INT 0
35610: PUSH
35611: LD_INT 0
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 0
35620: PUSH
35621: LD_INT 1
35623: NEG
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: LD_INT 0
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: PUSH
35642: LD_INT 1
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: EMPTY
35656: LIST
35657: LIST
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: LD_INT 0
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: NEG
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: NEG
35685: PUSH
35686: LD_INT 2
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 2
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 2
35718: PUSH
35719: LD_INT 0
35721: PUSH
35722: EMPTY
35723: LIST
35724: LIST
35725: PUSH
35726: LD_INT 2
35728: PUSH
35729: LD_INT 1
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 2
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 1
35748: PUSH
35749: LD_INT 2
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 0
35758: PUSH
35759: LD_INT 2
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 1
35768: NEG
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 2
35779: NEG
35780: PUSH
35781: LD_INT 0
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 2
35790: NEG
35791: PUSH
35792: LD_INT 1
35794: NEG
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: PUSH
35800: LD_INT 2
35802: NEG
35803: PUSH
35804: LD_INT 2
35806: NEG
35807: PUSH
35808: EMPTY
35809: LIST
35810: LIST
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
35833: LD_ADDR_VAR 0 54
35837: PUSH
35838: LD_INT 0
35840: PUSH
35841: LD_INT 0
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 0
35850: PUSH
35851: LD_INT 1
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: LD_INT 0
35864: PUSH
35865: EMPTY
35866: LIST
35867: LIST
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: LD_INT 0
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: NEG
35903: PUSH
35904: LD_INT 1
35906: NEG
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 1
35914: NEG
35915: PUSH
35916: LD_INT 2
35918: NEG
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: LD_INT 2
35929: NEG
35930: PUSH
35931: EMPTY
35932: LIST
35933: LIST
35934: PUSH
35935: LD_INT 1
35937: PUSH
35938: LD_INT 1
35940: NEG
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 2
35948: PUSH
35949: LD_INT 0
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 2
35958: PUSH
35959: LD_INT 1
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 2
35968: PUSH
35969: LD_INT 2
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 1
35978: PUSH
35979: LD_INT 2
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 0
35988: PUSH
35989: LD_INT 2
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 1
35998: NEG
35999: PUSH
36000: LD_INT 1
36002: PUSH
36003: EMPTY
36004: LIST
36005: LIST
36006: PUSH
36007: LD_INT 2
36009: NEG
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: EMPTY
36015: LIST
36016: LIST
36017: PUSH
36018: LD_INT 2
36020: NEG
36021: PUSH
36022: LD_INT 1
36024: NEG
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 2
36032: NEG
36033: PUSH
36034: LD_INT 2
36036: NEG
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: LIST
36046: LIST
36047: LIST
36048: LIST
36049: LIST
36050: LIST
36051: LIST
36052: LIST
36053: LIST
36054: LIST
36055: LIST
36056: LIST
36057: LIST
36058: LIST
36059: LIST
36060: LIST
36061: LIST
36062: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36063: LD_ADDR_VAR 0 55
36067: PUSH
36068: LD_INT 0
36070: PUSH
36071: LD_INT 0
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 0
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 1
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 1
36101: PUSH
36102: LD_INT 1
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 0
36111: PUSH
36112: LD_INT 1
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 1
36121: NEG
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 1
36132: NEG
36133: PUSH
36134: LD_INT 1
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 1
36144: NEG
36145: PUSH
36146: LD_INT 2
36148: NEG
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: LD_INT 0
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 2
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: LD_INT 2
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 1
36208: PUSH
36209: LD_INT 2
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 0
36218: PUSH
36219: LD_INT 2
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: NEG
36229: PUSH
36230: LD_INT 1
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 2
36239: NEG
36240: PUSH
36241: LD_INT 0
36243: PUSH
36244: EMPTY
36245: LIST
36246: LIST
36247: PUSH
36248: LD_INT 2
36250: NEG
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 2
36262: NEG
36263: PUSH
36264: LD_INT 2
36266: NEG
36267: PUSH
36268: EMPTY
36269: LIST
36270: LIST
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36293: LD_ADDR_VAR 0 56
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: PUSH
36322: LD_INT 0
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: PUSH
36329: LD_INT 1
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 1
36351: NEG
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 1
36362: NEG
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 1
36374: NEG
36375: PUSH
36376: LD_INT 2
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 0
36386: PUSH
36387: LD_INT 2
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: LD_INT 1
36400: NEG
36401: PUSH
36402: EMPTY
36403: LIST
36404: LIST
36405: PUSH
36406: LD_INT 2
36408: PUSH
36409: LD_INT 0
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: PUSH
36419: LD_INT 1
36421: PUSH
36422: EMPTY
36423: LIST
36424: LIST
36425: PUSH
36426: LD_INT 2
36428: PUSH
36429: LD_INT 2
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 0
36448: PUSH
36449: LD_INT 2
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 1
36458: NEG
36459: PUSH
36460: LD_INT 1
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: LD_INT 2
36469: NEG
36470: PUSH
36471: LD_INT 0
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 2
36480: NEG
36481: PUSH
36482: LD_INT 1
36484: NEG
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 2
36492: NEG
36493: PUSH
36494: LD_INT 2
36496: NEG
36497: PUSH
36498: EMPTY
36499: LIST
36500: LIST
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36523: LD_ADDR_VAR 0 57
36527: PUSH
36528: LD_INT 0
36530: PUSH
36531: LD_INT 0
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 1
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 0
36571: PUSH
36572: LD_INT 1
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: NEG
36582: PUSH
36583: LD_INT 0
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 1
36592: NEG
36593: PUSH
36594: LD_INT 1
36596: NEG
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: NEG
36605: PUSH
36606: LD_INT 2
36608: NEG
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 0
36616: PUSH
36617: LD_INT 2
36619: NEG
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 2
36638: PUSH
36639: LD_INT 0
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 2
36648: PUSH
36649: LD_INT 1
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 2
36658: PUSH
36659: LD_INT 2
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: LD_INT 2
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: LD_INT 2
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: LD_INT 1
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 2
36699: NEG
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: NEG
36711: PUSH
36712: LD_INT 1
36714: NEG
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 2
36722: NEG
36723: PUSH
36724: LD_INT 2
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: LIST
36740: LIST
36741: LIST
36742: LIST
36743: LIST
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36753: LD_ADDR_VAR 0 58
36757: PUSH
36758: LD_INT 0
36760: PUSH
36761: LD_INT 0
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 0
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 1
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: LD_INT 1
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: LD_INT 0
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 1
36822: NEG
36823: PUSH
36824: LD_INT 1
36826: NEG
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 1
36834: NEG
36835: PUSH
36836: LD_INT 2
36838: NEG
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 0
36846: PUSH
36847: LD_INT 2
36849: NEG
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 1
36857: PUSH
36858: LD_INT 1
36860: NEG
36861: PUSH
36862: EMPTY
36863: LIST
36864: LIST
36865: PUSH
36866: LD_INT 2
36868: PUSH
36869: LD_INT 0
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 2
36878: PUSH
36879: LD_INT 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: LD_INT 2
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: LD_INT 2
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: LD_INT 2
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: LD_INT 1
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 2
36929: NEG
36930: PUSH
36931: LD_INT 0
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 2
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: NEG
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 2
36952: NEG
36953: PUSH
36954: LD_INT 2
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
36983: LD_ADDR_VAR 0 59
36987: PUSH
36988: LD_INT 0
36990: PUSH
36991: LD_INT 0
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 0
37000: PUSH
37001: LD_INT 1
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 1
37011: PUSH
37012: LD_INT 0
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 1
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 0
37031: PUSH
37032: LD_INT 1
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: PUSH
37043: LD_INT 0
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37071: LD_ADDR_VAR 0 60
37075: PUSH
37076: LD_INT 0
37078: PUSH
37079: LD_INT 0
37081: PUSH
37082: EMPTY
37083: LIST
37084: LIST
37085: PUSH
37086: LD_INT 0
37088: PUSH
37089: LD_INT 1
37091: NEG
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 1
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: LD_INT 1
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 0
37119: PUSH
37120: LD_INT 1
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 1
37129: NEG
37130: PUSH
37131: LD_INT 0
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: LD_INT 1
37144: NEG
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: LIST
37154: LIST
37155: LIST
37156: LIST
37157: LIST
37158: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37159: LD_ADDR_VAR 0 61
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 0
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: LD_INT 0
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 0
37207: PUSH
37208: LD_INT 1
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 1
37217: NEG
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 1
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37247: LD_ADDR_VAR 0 62
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: LD_INT 0
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 0
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 1
37275: PUSH
37276: LD_INT 0
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 1
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 0
37295: PUSH
37296: LD_INT 1
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: LD_INT 0
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 1
37316: NEG
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37335: LD_ADDR_VAR 0 63
37339: PUSH
37340: LD_INT 0
37342: PUSH
37343: LD_INT 0
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 0
37352: PUSH
37353: LD_INT 1
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 1
37363: PUSH
37364: LD_INT 0
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 1
37373: PUSH
37374: LD_INT 1
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 0
37383: PUSH
37384: LD_INT 1
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 1
37404: NEG
37405: PUSH
37406: LD_INT 1
37408: NEG
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
37423: LD_ADDR_VAR 0 64
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: LD_INT 0
37433: PUSH
37434: EMPTY
37435: LIST
37436: LIST
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: LD_INT 1
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: LD_INT 1
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: LD_INT 1
37496: NEG
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: LIST
37506: LIST
37507: LIST
37508: LIST
37509: LIST
37510: ST_TO_ADDR
// end ; 1 :
37511: GO 43408
37513: LD_INT 1
37515: DOUBLE
37516: EQUAL
37517: IFTRUE 37521
37519: GO 40144
37521: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37522: LD_ADDR_VAR 0 11
37526: PUSH
37527: LD_INT 1
37529: NEG
37530: PUSH
37531: LD_INT 3
37533: NEG
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 0
37541: PUSH
37542: LD_INT 3
37544: NEG
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: LD_INT 2
37555: NEG
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: LIST
37565: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37566: LD_ADDR_VAR 0 12
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: EMPTY
37579: LIST
37580: LIST
37581: PUSH
37582: LD_INT 3
37584: PUSH
37585: LD_INT 0
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 3
37594: PUSH
37595: LD_INT 1
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: LIST
37606: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37607: LD_ADDR_VAR 0 13
37611: PUSH
37612: LD_INT 3
37614: PUSH
37615: LD_INT 2
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: PUSH
37622: LD_INT 3
37624: PUSH
37625: LD_INT 3
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 2
37634: PUSH
37635: LD_INT 3
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: LIST
37646: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37647: LD_ADDR_VAR 0 14
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 3
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: LD_INT 3
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: NEG
37675: PUSH
37676: LD_INT 2
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: LIST
37687: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37688: LD_ADDR_VAR 0 15
37692: PUSH
37693: LD_INT 2
37695: NEG
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: EMPTY
37701: LIST
37702: LIST
37703: PUSH
37704: LD_INT 3
37706: NEG
37707: PUSH
37708: LD_INT 0
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PUSH
37715: LD_INT 3
37717: NEG
37718: PUSH
37719: LD_INT 1
37721: NEG
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: LIST
37731: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37732: LD_ADDR_VAR 0 16
37736: PUSH
37737: LD_INT 2
37739: NEG
37740: PUSH
37741: LD_INT 3
37743: NEG
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 3
37751: NEG
37752: PUSH
37753: LD_INT 2
37755: NEG
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 3
37763: NEG
37764: PUSH
37765: LD_INT 3
37767: NEG
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: LIST
37777: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
37778: LD_ADDR_VAR 0 17
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 3
37789: NEG
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 0
37797: PUSH
37798: LD_INT 3
37800: NEG
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: LD_INT 2
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: LIST
37821: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
37822: LD_ADDR_VAR 0 18
37826: PUSH
37827: LD_INT 2
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: LIST
37862: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37863: LD_ADDR_VAR 0 19
37867: PUSH
37868: LD_INT 3
37870: PUSH
37871: LD_INT 2
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 3
37880: PUSH
37881: LD_INT 3
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: PUSH
37891: LD_INT 3
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: LIST
37902: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37903: LD_ADDR_VAR 0 20
37907: PUSH
37908: LD_INT 1
37910: PUSH
37911: LD_INT 3
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 0
37920: PUSH
37921: LD_INT 3
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 1
37930: NEG
37931: PUSH
37932: LD_INT 2
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: LIST
37943: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37944: LD_ADDR_VAR 0 21
37948: PUSH
37949: LD_INT 2
37951: NEG
37952: PUSH
37953: LD_INT 1
37955: PUSH
37956: EMPTY
37957: LIST
37958: LIST
37959: PUSH
37960: LD_INT 3
37962: NEG
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 3
37973: NEG
37974: PUSH
37975: LD_INT 1
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: EMPTY
37984: LIST
37985: LIST
37986: LIST
37987: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37988: LD_ADDR_VAR 0 22
37992: PUSH
37993: LD_INT 2
37995: NEG
37996: PUSH
37997: LD_INT 3
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 3
38007: NEG
38008: PUSH
38009: LD_INT 2
38011: NEG
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 3
38019: NEG
38020: PUSH
38021: LD_INT 3
38023: NEG
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: LIST
38033: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
38034: LD_ADDR_VAR 0 23
38038: PUSH
38039: LD_INT 0
38041: PUSH
38042: LD_INT 3
38044: NEG
38045: PUSH
38046: EMPTY
38047: LIST
38048: LIST
38049: PUSH
38050: LD_INT 1
38052: NEG
38053: PUSH
38054: LD_INT 4
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 1
38064: PUSH
38065: LD_INT 3
38067: NEG
38068: PUSH
38069: EMPTY
38070: LIST
38071: LIST
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: LIST
38077: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
38078: LD_ADDR_VAR 0 24
38082: PUSH
38083: LD_INT 3
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 3
38095: PUSH
38096: LD_INT 1
38098: NEG
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 4
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: EMPTY
38111: LIST
38112: LIST
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: LIST
38118: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
38119: LD_ADDR_VAR 0 25
38123: PUSH
38124: LD_INT 3
38126: PUSH
38127: LD_INT 3
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 4
38136: PUSH
38137: LD_INT 3
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 3
38146: PUSH
38147: LD_INT 4
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: LIST
38158: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
38159: LD_ADDR_VAR 0 26
38163: PUSH
38164: LD_INT 0
38166: PUSH
38167: LD_INT 3
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: LD_INT 4
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: LD_INT 3
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: LIST
38199: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
38200: LD_ADDR_VAR 0 27
38204: PUSH
38205: LD_INT 3
38207: NEG
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: LD_INT 3
38218: NEG
38219: PUSH
38220: LD_INT 1
38222: PUSH
38223: EMPTY
38224: LIST
38225: LIST
38226: PUSH
38227: LD_INT 4
38229: NEG
38230: PUSH
38231: LD_INT 1
38233: NEG
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: LIST
38243: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
38244: LD_ADDR_VAR 0 28
38248: PUSH
38249: LD_INT 3
38251: NEG
38252: PUSH
38253: LD_INT 3
38255: NEG
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 3
38263: NEG
38264: PUSH
38265: LD_INT 4
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 4
38275: NEG
38276: PUSH
38277: LD_INT 3
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: LIST
38289: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
38290: LD_ADDR_VAR 0 29
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: LD_INT 3
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 0
38309: PUSH
38310: LD_INT 3
38312: NEG
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 1
38320: PUSH
38321: LD_INT 2
38323: NEG
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 1
38331: NEG
38332: PUSH
38333: LD_INT 4
38335: NEG
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 0
38343: PUSH
38344: LD_INT 4
38346: NEG
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: LD_INT 3
38357: NEG
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: NEG
38366: PUSH
38367: LD_INT 5
38369: NEG
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 0
38377: PUSH
38378: LD_INT 5
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: LD_INT 1
38388: PUSH
38389: LD_INT 4
38391: NEG
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: LD_INT 6
38403: NEG
38404: PUSH
38405: EMPTY
38406: LIST
38407: LIST
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: LD_INT 6
38414: NEG
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: PUSH
38423: LD_INT 5
38425: NEG
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
38445: LD_ADDR_VAR 0 30
38449: PUSH
38450: LD_INT 2
38452: PUSH
38453: LD_INT 1
38455: NEG
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 3
38463: PUSH
38464: LD_INT 0
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 3
38473: PUSH
38474: LD_INT 1
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 3
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 4
38494: PUSH
38495: LD_INT 0
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 4
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 4
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 5
38525: PUSH
38526: LD_INT 0
38528: PUSH
38529: EMPTY
38530: LIST
38531: LIST
38532: PUSH
38533: LD_INT 5
38535: PUSH
38536: LD_INT 1
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 5
38545: PUSH
38546: LD_INT 1
38548: NEG
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 6
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 6
38566: PUSH
38567: LD_INT 1
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
38588: LD_ADDR_VAR 0 31
38592: PUSH
38593: LD_INT 3
38595: PUSH
38596: LD_INT 2
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 3
38605: PUSH
38606: LD_INT 3
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 2
38615: PUSH
38616: LD_INT 3
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 4
38625: PUSH
38626: LD_INT 3
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 4
38635: PUSH
38636: LD_INT 4
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 3
38645: PUSH
38646: LD_INT 4
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 5
38655: PUSH
38656: LD_INT 4
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 5
38665: PUSH
38666: LD_INT 5
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 4
38675: PUSH
38676: LD_INT 5
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 6
38685: PUSH
38686: LD_INT 5
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 6
38695: PUSH
38696: LD_INT 6
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 5
38705: PUSH
38706: LD_INT 6
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: LIST
38717: LIST
38718: LIST
38719: LIST
38720: LIST
38721: LIST
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
38727: LD_ADDR_VAR 0 32
38731: PUSH
38732: LD_INT 1
38734: PUSH
38735: LD_INT 3
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 0
38744: PUSH
38745: LD_INT 3
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 1
38754: NEG
38755: PUSH
38756: LD_INT 2
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 1
38765: PUSH
38766: LD_INT 4
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 0
38775: PUSH
38776: LD_INT 4
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 1
38785: NEG
38786: PUSH
38787: LD_INT 3
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: LD_INT 5
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 0
38806: PUSH
38807: LD_INT 5
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: LD_INT 4
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: PUSH
38828: LD_INT 6
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 0
38837: PUSH
38838: LD_INT 6
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 1
38847: NEG
38848: PUSH
38849: LD_INT 5
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
38870: LD_ADDR_VAR 0 33
38874: PUSH
38875: LD_INT 2
38877: NEG
38878: PUSH
38879: LD_INT 1
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: LD_INT 3
38888: NEG
38889: PUSH
38890: LD_INT 0
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 3
38899: NEG
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 3
38911: NEG
38912: PUSH
38913: LD_INT 1
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 4
38922: NEG
38923: PUSH
38924: LD_INT 0
38926: PUSH
38927: EMPTY
38928: LIST
38929: LIST
38930: PUSH
38931: LD_INT 4
38933: NEG
38934: PUSH
38935: LD_INT 1
38937: NEG
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 4
38945: NEG
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 5
38956: NEG
38957: PUSH
38958: LD_INT 0
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 5
38967: NEG
38968: PUSH
38969: LD_INT 1
38971: NEG
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 5
38979: NEG
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 6
38990: NEG
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 6
39001: NEG
39002: PUSH
39003: LD_INT 1
39005: NEG
39006: PUSH
39007: EMPTY
39008: LIST
39009: LIST
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
39025: LD_ADDR_VAR 0 34
39029: PUSH
39030: LD_INT 2
39032: NEG
39033: PUSH
39034: LD_INT 3
39036: NEG
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 3
39044: NEG
39045: PUSH
39046: LD_INT 2
39048: NEG
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 3
39056: NEG
39057: PUSH
39058: LD_INT 3
39060: NEG
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 3
39068: NEG
39069: PUSH
39070: LD_INT 4
39072: NEG
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 4
39080: NEG
39081: PUSH
39082: LD_INT 3
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 4
39092: NEG
39093: PUSH
39094: LD_INT 4
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 4
39104: NEG
39105: PUSH
39106: LD_INT 5
39108: NEG
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 5
39116: NEG
39117: PUSH
39118: LD_INT 4
39120: NEG
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PUSH
39126: LD_INT 5
39128: NEG
39129: PUSH
39130: LD_INT 5
39132: NEG
39133: PUSH
39134: EMPTY
39135: LIST
39136: LIST
39137: PUSH
39138: LD_INT 5
39140: NEG
39141: PUSH
39142: LD_INT 6
39144: NEG
39145: PUSH
39146: EMPTY
39147: LIST
39148: LIST
39149: PUSH
39150: LD_INT 6
39152: NEG
39153: PUSH
39154: LD_INT 5
39156: NEG
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 6
39164: NEG
39165: PUSH
39166: LD_INT 6
39168: NEG
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
39188: LD_ADDR_VAR 0 41
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: LD_INT 3
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 1
39218: PUSH
39219: LD_INT 2
39221: NEG
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: LIST
39231: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
39232: LD_ADDR_VAR 0 42
39236: PUSH
39237: LD_INT 2
39239: PUSH
39240: LD_INT 0
39242: PUSH
39243: EMPTY
39244: LIST
39245: LIST
39246: PUSH
39247: LD_INT 2
39249: PUSH
39250: LD_INT 1
39252: NEG
39253: PUSH
39254: EMPTY
39255: LIST
39256: LIST
39257: PUSH
39258: LD_INT 3
39260: PUSH
39261: LD_INT 1
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: LIST
39272: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
39273: LD_ADDR_VAR 0 43
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: LD_INT 2
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: LD_INT 3
39290: PUSH
39291: LD_INT 2
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 2
39300: PUSH
39301: LD_INT 3
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: LIST
39312: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
39313: LD_ADDR_VAR 0 44
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: LD_INT 2
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 1
39330: PUSH
39331: LD_INT 3
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 1
39340: NEG
39341: PUSH
39342: LD_INT 2
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: LIST
39353: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
39354: LD_ADDR_VAR 0 45
39358: PUSH
39359: LD_INT 2
39361: NEG
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 2
39372: NEG
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 3
39383: NEG
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: LIST
39397: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
39398: LD_ADDR_VAR 0 46
39402: PUSH
39403: LD_INT 2
39405: NEG
39406: PUSH
39407: LD_INT 2
39409: NEG
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: LD_INT 3
39421: NEG
39422: PUSH
39423: EMPTY
39424: LIST
39425: LIST
39426: PUSH
39427: LD_INT 3
39429: NEG
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: LIST
39443: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
39444: LD_ADDR_VAR 0 47
39448: PUSH
39449: LD_INT 2
39451: NEG
39452: PUSH
39453: LD_INT 3
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: LD_INT 3
39467: NEG
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
39477: LD_ADDR_VAR 0 48
39481: PUSH
39482: LD_INT 1
39484: PUSH
39485: LD_INT 2
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 2
39495: PUSH
39496: LD_INT 1
39498: NEG
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
39508: LD_ADDR_VAR 0 49
39512: PUSH
39513: LD_INT 3
39515: PUSH
39516: LD_INT 1
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: PUSH
39526: LD_INT 2
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
39537: LD_ADDR_VAR 0 50
39541: PUSH
39542: LD_INT 2
39544: PUSH
39545: LD_INT 3
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 1
39554: PUSH
39555: LD_INT 3
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
39566: LD_ADDR_VAR 0 51
39570: PUSH
39571: LD_INT 1
39573: NEG
39574: PUSH
39575: LD_INT 2
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 2
39584: NEG
39585: PUSH
39586: LD_INT 1
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
39597: LD_ADDR_VAR 0 52
39601: PUSH
39602: LD_INT 3
39604: NEG
39605: PUSH
39606: LD_INT 1
39608: NEG
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 3
39616: NEG
39617: PUSH
39618: LD_INT 2
39620: NEG
39621: PUSH
39622: EMPTY
39623: LIST
39624: LIST
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39630: LD_ADDR_VAR 0 53
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 3
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: LD_INT 3
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 1
39660: PUSH
39661: LD_INT 2
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: LIST
39673: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39674: LD_ADDR_VAR 0 54
39678: PUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 1
39684: NEG
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 3
39692: PUSH
39693: LD_INT 0
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 3
39702: PUSH
39703: LD_INT 1
39705: PUSH
39706: EMPTY
39707: LIST
39708: LIST
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: LIST
39714: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39715: LD_ADDR_VAR 0 55
39719: PUSH
39720: LD_INT 3
39722: PUSH
39723: LD_INT 2
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 3
39732: PUSH
39733: LD_INT 3
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 2
39742: PUSH
39743: LD_INT 3
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: LIST
39754: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39755: LD_ADDR_VAR 0 56
39759: PUSH
39760: LD_INT 1
39762: PUSH
39763: LD_INT 3
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: LD_INT 0
39772: PUSH
39773: LD_INT 3
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 2
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39796: LD_ADDR_VAR 0 57
39800: PUSH
39801: LD_INT 2
39803: NEG
39804: PUSH
39805: LD_INT 1
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 3
39814: NEG
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 3
39825: NEG
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39840: LD_ADDR_VAR 0 58
39844: PUSH
39845: LD_INT 2
39847: NEG
39848: PUSH
39849: LD_INT 3
39851: NEG
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: NEG
39860: PUSH
39861: LD_INT 2
39863: NEG
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: LD_INT 3
39871: NEG
39872: PUSH
39873: LD_INT 3
39875: NEG
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: EMPTY
39882: LIST
39883: LIST
39884: LIST
39885: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
39886: LD_ADDR_VAR 0 59
39890: PUSH
39891: LD_INT 1
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 0
39905: PUSH
39906: LD_INT 2
39908: NEG
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: LIST
39929: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
39930: LD_ADDR_VAR 0 60
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 2
39948: PUSH
39949: LD_INT 0
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 2
39958: PUSH
39959: LD_INT 1
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: LIST
39970: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
39971: LD_ADDR_VAR 0 61
39975: PUSH
39976: LD_INT 2
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 2
39988: PUSH
39989: LD_INT 2
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 1
39998: PUSH
39999: LD_INT 2
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: LIST
40010: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
40011: LD_ADDR_VAR 0 62
40015: PUSH
40016: LD_INT 1
40018: PUSH
40019: LD_INT 2
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: LD_INT 2
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 1
40038: NEG
40039: PUSH
40040: LD_INT 1
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
40052: LD_ADDR_VAR 0 63
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 2
40070: NEG
40071: PUSH
40072: LD_INT 0
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: NEG
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: LIST
40095: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40096: LD_ADDR_VAR 0 64
40100: PUSH
40101: LD_INT 1
40103: NEG
40104: PUSH
40105: LD_INT 2
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 2
40115: NEG
40116: PUSH
40117: LD_INT 1
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: LD_INT 2
40127: NEG
40128: PUSH
40129: LD_INT 2
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: LIST
40141: ST_TO_ADDR
// end ; 2 :
40142: GO 43408
40144: LD_INT 2
40146: DOUBLE
40147: EQUAL
40148: IFTRUE 40152
40150: GO 43407
40152: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
40153: LD_ADDR_VAR 0 29
40157: PUSH
40158: LD_INT 4
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 4
40170: PUSH
40171: LD_INT 1
40173: NEG
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: PUSH
40179: LD_INT 5
40181: PUSH
40182: LD_INT 0
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 5
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 4
40201: PUSH
40202: LD_INT 1
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: LD_INT 3
40211: PUSH
40212: LD_INT 0
40214: PUSH
40215: EMPTY
40216: LIST
40217: LIST
40218: PUSH
40219: LD_INT 3
40221: PUSH
40222: LD_INT 1
40224: NEG
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 3
40232: PUSH
40233: LD_INT 2
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: LD_INT 5
40243: PUSH
40244: LD_INT 2
40246: PUSH
40247: EMPTY
40248: LIST
40249: LIST
40250: PUSH
40251: LD_INT 3
40253: PUSH
40254: LD_INT 3
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 3
40263: PUSH
40264: LD_INT 2
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: LD_INT 4
40273: PUSH
40274: LD_INT 3
40276: PUSH
40277: EMPTY
40278: LIST
40279: LIST
40280: PUSH
40281: LD_INT 4
40283: PUSH
40284: LD_INT 4
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 3
40293: PUSH
40294: LD_INT 4
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: PUSH
40304: LD_INT 3
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: PUSH
40311: LD_INT 2
40313: PUSH
40314: LD_INT 2
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 4
40323: PUSH
40324: LD_INT 2
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 2
40333: PUSH
40334: LD_INT 4
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 0
40343: PUSH
40344: LD_INT 4
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: LD_INT 3
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 1
40363: PUSH
40364: LD_INT 4
40366: PUSH
40367: EMPTY
40368: LIST
40369: LIST
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: LD_INT 5
40376: PUSH
40377: EMPTY
40378: LIST
40379: LIST
40380: PUSH
40381: LD_INT 0
40383: PUSH
40384: LD_INT 5
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: LD_INT 3
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 2
40415: PUSH
40416: LD_INT 5
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 2
40425: NEG
40426: PUSH
40427: LD_INT 3
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 3
40436: NEG
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 3
40447: NEG
40448: PUSH
40449: LD_INT 1
40451: NEG
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 2
40459: NEG
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: EMPTY
40465: LIST
40466: LIST
40467: PUSH
40468: LD_INT 2
40470: NEG
40471: PUSH
40472: LD_INT 1
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: PUSH
40479: LD_INT 3
40481: NEG
40482: PUSH
40483: LD_INT 1
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 4
40492: NEG
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 4
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: LD_INT 4
40515: NEG
40516: PUSH
40517: LD_INT 2
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 2
40527: NEG
40528: PUSH
40529: LD_INT 2
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 4
40538: NEG
40539: PUSH
40540: LD_INT 4
40542: NEG
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 4
40550: NEG
40551: PUSH
40552: LD_INT 5
40554: NEG
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 3
40562: NEG
40563: PUSH
40564: LD_INT 4
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 3
40574: NEG
40575: PUSH
40576: LD_INT 3
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 4
40586: NEG
40587: PUSH
40588: LD_INT 3
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 5
40598: NEG
40599: PUSH
40600: LD_INT 4
40602: NEG
40603: PUSH
40604: EMPTY
40605: LIST
40606: LIST
40607: PUSH
40608: LD_INT 5
40610: NEG
40611: PUSH
40612: LD_INT 5
40614: NEG
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 3
40622: NEG
40623: PUSH
40624: LD_INT 5
40626: NEG
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 5
40634: NEG
40635: PUSH
40636: LD_INT 3
40638: NEG
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
40691: LD_ADDR_VAR 0 30
40695: PUSH
40696: LD_INT 4
40698: PUSH
40699: LD_INT 4
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 4
40708: PUSH
40709: LD_INT 3
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 5
40718: PUSH
40719: LD_INT 4
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 5
40728: PUSH
40729: LD_INT 5
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 4
40738: PUSH
40739: LD_INT 5
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: PUSH
40746: LD_INT 3
40748: PUSH
40749: LD_INT 4
40751: PUSH
40752: EMPTY
40753: LIST
40754: LIST
40755: PUSH
40756: LD_INT 3
40758: PUSH
40759: LD_INT 3
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 5
40768: PUSH
40769: LD_INT 3
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: LD_INT 3
40778: PUSH
40779: LD_INT 5
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: LD_INT 3
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: LD_INT 0
40798: PUSH
40799: LD_INT 2
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: LD_INT 1
40808: PUSH
40809: LD_INT 3
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 1
40818: PUSH
40819: LD_INT 4
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 0
40828: PUSH
40829: LD_INT 4
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: LD_INT 3
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 1
40849: NEG
40850: PUSH
40851: LD_INT 2
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: PUSH
40858: LD_INT 2
40860: PUSH
40861: LD_INT 4
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: LD_INT 2
40870: NEG
40871: PUSH
40872: LD_INT 2
40874: PUSH
40875: EMPTY
40876: LIST
40877: LIST
40878: PUSH
40879: LD_INT 4
40881: NEG
40882: PUSH
40883: LD_INT 0
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: LD_INT 4
40892: NEG
40893: PUSH
40894: LD_INT 1
40896: NEG
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 3
40904: NEG
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 3
40915: NEG
40916: PUSH
40917: LD_INT 1
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 4
40926: NEG
40927: PUSH
40928: LD_INT 1
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: PUSH
40935: LD_INT 5
40937: NEG
40938: PUSH
40939: LD_INT 0
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: PUSH
40946: LD_INT 5
40948: NEG
40949: PUSH
40950: LD_INT 1
40952: NEG
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 5
40960: NEG
40961: PUSH
40962: LD_INT 2
40964: NEG
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PUSH
40970: LD_INT 3
40972: NEG
40973: PUSH
40974: LD_INT 2
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 3
40983: NEG
40984: PUSH
40985: LD_INT 3
40987: NEG
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 3
40995: NEG
40996: PUSH
40997: LD_INT 4
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: LD_INT 2
41007: NEG
41008: PUSH
41009: LD_INT 3
41011: NEG
41012: PUSH
41013: EMPTY
41014: LIST
41015: LIST
41016: PUSH
41017: LD_INT 2
41019: NEG
41020: PUSH
41021: LD_INT 2
41023: NEG
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: LD_INT 2
41035: NEG
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 4
41043: NEG
41044: PUSH
41045: LD_INT 3
41047: NEG
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 4
41055: NEG
41056: PUSH
41057: LD_INT 4
41059: NEG
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 2
41067: NEG
41068: PUSH
41069: LD_INT 4
41071: NEG
41072: PUSH
41073: EMPTY
41074: LIST
41075: LIST
41076: PUSH
41077: LD_INT 4
41079: NEG
41080: PUSH
41081: LD_INT 2
41083: NEG
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 4
41094: NEG
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: LD_INT 5
41105: NEG
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: LD_INT 1
41113: PUSH
41114: LD_INT 4
41116: NEG
41117: PUSH
41118: EMPTY
41119: LIST
41120: LIST
41121: PUSH
41122: LD_INT 1
41124: PUSH
41125: LD_INT 3
41127: NEG
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: LD_INT 0
41135: PUSH
41136: LD_INT 3
41138: NEG
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 1
41146: NEG
41147: PUSH
41148: LD_INT 4
41150: NEG
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 1
41158: NEG
41159: PUSH
41160: LD_INT 5
41162: NEG
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 2
41170: PUSH
41171: LD_INT 3
41173: NEG
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: PUSH
41179: LD_INT 2
41181: NEG
41182: PUSH
41183: LD_INT 5
41185: NEG
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: LIST
41223: LIST
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: LIST
41229: LIST
41230: LIST
41231: LIST
41232: LIST
41233: LIST
41234: LIST
41235: LIST
41236: LIST
41237: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
41238: LD_ADDR_VAR 0 31
41242: PUSH
41243: LD_INT 0
41245: PUSH
41246: LD_INT 4
41248: PUSH
41249: EMPTY
41250: LIST
41251: LIST
41252: PUSH
41253: LD_INT 0
41255: PUSH
41256: LD_INT 3
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: PUSH
41263: LD_INT 1
41265: PUSH
41266: LD_INT 4
41268: PUSH
41269: EMPTY
41270: LIST
41271: LIST
41272: PUSH
41273: LD_INT 1
41275: PUSH
41276: LD_INT 5
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: LD_INT 0
41285: PUSH
41286: LD_INT 5
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 1
41295: NEG
41296: PUSH
41297: LD_INT 4
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 1
41306: NEG
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 2
41317: PUSH
41318: LD_INT 5
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: LD_INT 2
41327: NEG
41328: PUSH
41329: LD_INT 3
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: PUSH
41336: LD_INT 3
41338: NEG
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 3
41349: NEG
41350: PUSH
41351: LD_INT 1
41353: NEG
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: PUSH
41359: LD_INT 2
41361: NEG
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 2
41372: NEG
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: LD_INT 3
41383: NEG
41384: PUSH
41385: LD_INT 1
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: LD_INT 4
41394: NEG
41395: PUSH
41396: LD_INT 0
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: LD_INT 4
41405: NEG
41406: PUSH
41407: LD_INT 1
41409: NEG
41410: PUSH
41411: EMPTY
41412: LIST
41413: LIST
41414: PUSH
41415: LD_INT 4
41417: NEG
41418: PUSH
41419: LD_INT 2
41421: NEG
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 2
41429: NEG
41430: PUSH
41431: LD_INT 2
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 4
41440: NEG
41441: PUSH
41442: LD_INT 4
41444: NEG
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: LD_INT 4
41452: NEG
41453: PUSH
41454: LD_INT 5
41456: NEG
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: NEG
41465: PUSH
41466: LD_INT 4
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 3
41476: NEG
41477: PUSH
41478: LD_INT 3
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 4
41488: NEG
41489: PUSH
41490: LD_INT 3
41492: NEG
41493: PUSH
41494: EMPTY
41495: LIST
41496: LIST
41497: PUSH
41498: LD_INT 5
41500: NEG
41501: PUSH
41502: LD_INT 4
41504: NEG
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 5
41512: NEG
41513: PUSH
41514: LD_INT 5
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 3
41524: NEG
41525: PUSH
41526: LD_INT 5
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 5
41536: NEG
41537: PUSH
41538: LD_INT 3
41540: NEG
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 0
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 0
41559: PUSH
41560: LD_INT 4
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 1
41570: PUSH
41571: LD_INT 3
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: PUSH
41582: LD_INT 2
41584: NEG
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: LD_INT 2
41595: NEG
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 1
41603: NEG
41604: PUSH
41605: LD_INT 3
41607: NEG
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 1
41615: NEG
41616: PUSH
41617: LD_INT 4
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 2
41627: PUSH
41628: LD_INT 2
41630: NEG
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 2
41638: NEG
41639: PUSH
41640: LD_INT 4
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: LD_INT 4
41650: PUSH
41651: LD_INT 0
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 4
41660: PUSH
41661: LD_INT 1
41663: NEG
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 5
41671: PUSH
41672: LD_INT 0
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 5
41681: PUSH
41682: LD_INT 1
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: LD_INT 1
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: LD_INT 3
41701: PUSH
41702: LD_INT 0
41704: PUSH
41705: EMPTY
41706: LIST
41707: LIST
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: LD_INT 1
41714: NEG
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: LD_INT 2
41725: NEG
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: PUSH
41731: LD_INT 5
41733: PUSH
41734: LD_INT 2
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: LIST
41786: LIST
41787: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
41788: LD_ADDR_VAR 0 32
41792: PUSH
41793: LD_INT 4
41795: NEG
41796: PUSH
41797: LD_INT 0
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 4
41806: NEG
41807: PUSH
41808: LD_INT 1
41810: NEG
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 3
41818: NEG
41819: PUSH
41820: LD_INT 0
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 3
41829: NEG
41830: PUSH
41831: LD_INT 1
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 4
41840: NEG
41841: PUSH
41842: LD_INT 1
41844: PUSH
41845: EMPTY
41846: LIST
41847: LIST
41848: PUSH
41849: LD_INT 5
41851: NEG
41852: PUSH
41853: LD_INT 0
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 5
41862: NEG
41863: PUSH
41864: LD_INT 1
41866: NEG
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 5
41874: NEG
41875: PUSH
41876: LD_INT 2
41878: NEG
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 3
41886: NEG
41887: PUSH
41888: LD_INT 2
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: PUSH
41895: LD_INT 3
41897: NEG
41898: PUSH
41899: LD_INT 3
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 3
41909: NEG
41910: PUSH
41911: LD_INT 4
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 2
41921: NEG
41922: PUSH
41923: LD_INT 3
41925: NEG
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 2
41933: NEG
41934: PUSH
41935: LD_INT 2
41937: NEG
41938: PUSH
41939: EMPTY
41940: LIST
41941: LIST
41942: PUSH
41943: LD_INT 3
41945: NEG
41946: PUSH
41947: LD_INT 2
41949: NEG
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 4
41957: NEG
41958: PUSH
41959: LD_INT 3
41961: NEG
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: LD_INT 4
41969: NEG
41970: PUSH
41971: LD_INT 4
41973: NEG
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 2
41981: NEG
41982: PUSH
41983: LD_INT 4
41985: NEG
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 4
41993: NEG
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 0
42005: PUSH
42006: LD_INT 4
42008: NEG
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: LD_INT 0
42016: PUSH
42017: LD_INT 5
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 1
42027: PUSH
42028: LD_INT 4
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 1
42038: PUSH
42039: LD_INT 3
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 0
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 1
42060: NEG
42061: PUSH
42062: LD_INT 4
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: LD_INT 5
42076: NEG
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: PUSH
42082: LD_INT 2
42084: PUSH
42085: LD_INT 3
42087: NEG
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: NEG
42096: PUSH
42097: LD_INT 5
42099: NEG
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 3
42107: PUSH
42108: LD_INT 0
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 3
42117: PUSH
42118: LD_INT 1
42120: NEG
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 4
42128: PUSH
42129: LD_INT 0
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 4
42138: PUSH
42139: LD_INT 1
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 3
42148: PUSH
42149: LD_INT 1
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 2
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 2
42168: PUSH
42169: LD_INT 1
42171: NEG
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 2
42179: PUSH
42180: LD_INT 2
42182: NEG
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: PUSH
42188: LD_INT 4
42190: PUSH
42191: LD_INT 2
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 4
42200: PUSH
42201: LD_INT 4
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 4
42210: PUSH
42211: LD_INT 3
42213: PUSH
42214: EMPTY
42215: LIST
42216: LIST
42217: PUSH
42218: LD_INT 5
42220: PUSH
42221: LD_INT 4
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 5
42230: PUSH
42231: LD_INT 5
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 4
42240: PUSH
42241: LD_INT 5
42243: PUSH
42244: EMPTY
42245: LIST
42246: LIST
42247: PUSH
42248: LD_INT 3
42250: PUSH
42251: LD_INT 4
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 3
42260: PUSH
42261: LD_INT 3
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 5
42270: PUSH
42271: LD_INT 3
42273: PUSH
42274: EMPTY
42275: LIST
42276: LIST
42277: PUSH
42278: LD_INT 3
42280: PUSH
42281: LD_INT 5
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: LIST
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: LIST
42321: LIST
42322: LIST
42323: LIST
42324: LIST
42325: LIST
42326: LIST
42327: LIST
42328: LIST
42329: LIST
42330: LIST
42331: LIST
42332: LIST
42333: LIST
42334: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
42335: LD_ADDR_VAR 0 33
42339: PUSH
42340: LD_INT 4
42342: NEG
42343: PUSH
42344: LD_INT 4
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 4
42354: NEG
42355: PUSH
42356: LD_INT 5
42358: NEG
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: LD_INT 3
42366: NEG
42367: PUSH
42368: LD_INT 4
42370: NEG
42371: PUSH
42372: EMPTY
42373: LIST
42374: LIST
42375: PUSH
42376: LD_INT 3
42378: NEG
42379: PUSH
42380: LD_INT 3
42382: NEG
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 4
42390: NEG
42391: PUSH
42392: LD_INT 3
42394: NEG
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: PUSH
42400: LD_INT 5
42402: NEG
42403: PUSH
42404: LD_INT 4
42406: NEG
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 5
42414: NEG
42415: PUSH
42416: LD_INT 5
42418: NEG
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 3
42426: NEG
42427: PUSH
42428: LD_INT 5
42430: NEG
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 5
42438: NEG
42439: PUSH
42440: LD_INT 3
42442: NEG
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 0
42450: PUSH
42451: LD_INT 3
42453: NEG
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 0
42461: PUSH
42462: LD_INT 4
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 1
42472: PUSH
42473: LD_INT 3
42475: NEG
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 1
42483: PUSH
42484: LD_INT 2
42486: NEG
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 0
42494: PUSH
42495: LD_INT 2
42497: NEG
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 1
42505: NEG
42506: PUSH
42507: LD_INT 3
42509: NEG
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 1
42517: NEG
42518: PUSH
42519: LD_INT 4
42521: NEG
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: LD_INT 2
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 2
42540: NEG
42541: PUSH
42542: LD_INT 4
42544: NEG
42545: PUSH
42546: EMPTY
42547: LIST
42548: LIST
42549: PUSH
42550: LD_INT 4
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 4
42562: PUSH
42563: LD_INT 1
42565: NEG
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: LD_INT 5
42573: PUSH
42574: LD_INT 0
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 5
42583: PUSH
42584: LD_INT 1
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: LD_INT 1
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 3
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 3
42613: PUSH
42614: LD_INT 1
42616: NEG
42617: PUSH
42618: EMPTY
42619: LIST
42620: LIST
42621: PUSH
42622: LD_INT 3
42624: PUSH
42625: LD_INT 2
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 5
42635: PUSH
42636: LD_INT 2
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 3
42645: PUSH
42646: LD_INT 3
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 3
42655: PUSH
42656: LD_INT 2
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 4
42665: PUSH
42666: LD_INT 3
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 4
42675: PUSH
42676: LD_INT 4
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 3
42685: PUSH
42686: LD_INT 4
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 2
42695: PUSH
42696: LD_INT 3
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 2
42705: PUSH
42706: LD_INT 2
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 4
42715: PUSH
42716: LD_INT 2
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 2
42725: PUSH
42726: LD_INT 4
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 0
42735: PUSH
42736: LD_INT 4
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 0
42745: PUSH
42746: LD_INT 3
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 1
42755: PUSH
42756: LD_INT 4
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 1
42765: PUSH
42766: LD_INT 5
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 0
42775: PUSH
42776: LD_INT 5
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: NEG
42786: PUSH
42787: LD_INT 4
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 1
42796: NEG
42797: PUSH
42798: LD_INT 3
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: LD_INT 2
42807: PUSH
42808: LD_INT 5
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 2
42817: NEG
42818: PUSH
42819: LD_INT 3
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: LIST
42855: LIST
42856: LIST
42857: LIST
42858: LIST
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: LIST
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: LIST
42870: LIST
42871: LIST
42872: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
42873: LD_ADDR_VAR 0 34
42877: PUSH
42878: LD_INT 0
42880: PUSH
42881: LD_INT 4
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 0
42891: PUSH
42892: LD_INT 5
42894: NEG
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 1
42902: PUSH
42903: LD_INT 4
42905: NEG
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 1
42913: PUSH
42914: LD_INT 3
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 0
42924: PUSH
42925: LD_INT 3
42927: NEG
42928: PUSH
42929: EMPTY
42930: LIST
42931: LIST
42932: PUSH
42933: LD_INT 1
42935: NEG
42936: PUSH
42937: LD_INT 4
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 1
42947: NEG
42948: PUSH
42949: LD_INT 5
42951: NEG
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: PUSH
42957: LD_INT 2
42959: PUSH
42960: LD_INT 3
42962: NEG
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 2
42970: NEG
42971: PUSH
42972: LD_INT 5
42974: NEG
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 3
42982: PUSH
42983: LD_INT 0
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: PUSH
42993: LD_INT 1
42995: NEG
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 4
43003: PUSH
43004: LD_INT 0
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: LD_INT 4
43013: PUSH
43014: LD_INT 1
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 3
43023: PUSH
43024: LD_INT 1
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 2
43033: PUSH
43034: LD_INT 0
43036: PUSH
43037: EMPTY
43038: LIST
43039: LIST
43040: PUSH
43041: LD_INT 2
43043: PUSH
43044: LD_INT 1
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 2
43054: PUSH
43055: LD_INT 2
43057: NEG
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 4
43065: PUSH
43066: LD_INT 2
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: LD_INT 4
43075: PUSH
43076: LD_INT 4
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 4
43085: PUSH
43086: LD_INT 3
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 5
43095: PUSH
43096: LD_INT 4
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 5
43105: PUSH
43106: LD_INT 5
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 4
43115: PUSH
43116: LD_INT 5
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 3
43125: PUSH
43126: LD_INT 4
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 3
43135: PUSH
43136: LD_INT 3
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 5
43145: PUSH
43146: LD_INT 3
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 3
43155: PUSH
43156: LD_INT 5
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: PUSH
43163: LD_INT 0
43165: PUSH
43166: LD_INT 3
43168: PUSH
43169: EMPTY
43170: LIST
43171: LIST
43172: PUSH
43173: LD_INT 0
43175: PUSH
43176: LD_INT 2
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: LD_INT 1
43185: PUSH
43186: LD_INT 3
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PUSH
43193: LD_INT 1
43195: PUSH
43196: LD_INT 4
43198: PUSH
43199: EMPTY
43200: LIST
43201: LIST
43202: PUSH
43203: LD_INT 0
43205: PUSH
43206: LD_INT 4
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: LD_INT 3
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 1
43226: NEG
43227: PUSH
43228: LD_INT 2
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: PUSH
43235: LD_INT 2
43237: PUSH
43238: LD_INT 4
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: PUSH
43245: LD_INT 2
43247: NEG
43248: PUSH
43249: LD_INT 2
43251: PUSH
43252: EMPTY
43253: LIST
43254: LIST
43255: PUSH
43256: LD_INT 4
43258: NEG
43259: PUSH
43260: LD_INT 0
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PUSH
43267: LD_INT 4
43269: NEG
43270: PUSH
43271: LD_INT 1
43273: NEG
43274: PUSH
43275: EMPTY
43276: LIST
43277: LIST
43278: PUSH
43279: LD_INT 3
43281: NEG
43282: PUSH
43283: LD_INT 0
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 3
43292: NEG
43293: PUSH
43294: LD_INT 1
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 4
43303: NEG
43304: PUSH
43305: LD_INT 1
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 5
43314: NEG
43315: PUSH
43316: LD_INT 0
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 5
43325: NEG
43326: PUSH
43327: LD_INT 1
43329: NEG
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: PUSH
43335: LD_INT 5
43337: NEG
43338: PUSH
43339: LD_INT 2
43341: NEG
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: LD_INT 3
43349: NEG
43350: PUSH
43351: LD_INT 2
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: EMPTY
43359: LIST
43360: LIST
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: LIST
43402: LIST
43403: LIST
43404: ST_TO_ADDR
// end ; end ;
43405: GO 43408
43407: POP
// case btype of b_depot , b_warehouse :
43408: LD_VAR 0 1
43412: PUSH
43413: LD_INT 0
43415: DOUBLE
43416: EQUAL
43417: IFTRUE 43427
43419: LD_INT 1
43421: DOUBLE
43422: EQUAL
43423: IFTRUE 43427
43425: GO 43628
43427: POP
// case nation of nation_american :
43428: LD_VAR 0 5
43432: PUSH
43433: LD_INT 1
43435: DOUBLE
43436: EQUAL
43437: IFTRUE 43441
43439: GO 43497
43441: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
43442: LD_ADDR_VAR 0 9
43446: PUSH
43447: LD_VAR 0 11
43451: PUSH
43452: LD_VAR 0 12
43456: PUSH
43457: LD_VAR 0 13
43461: PUSH
43462: LD_VAR 0 14
43466: PUSH
43467: LD_VAR 0 15
43471: PUSH
43472: LD_VAR 0 16
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: LIST
43481: LIST
43482: LIST
43483: LIST
43484: PUSH
43485: LD_VAR 0 4
43489: PUSH
43490: LD_INT 1
43492: PLUS
43493: ARRAY
43494: ST_TO_ADDR
43495: GO 43626
43497: LD_INT 2
43499: DOUBLE
43500: EQUAL
43501: IFTRUE 43505
43503: GO 43561
43505: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
43506: LD_ADDR_VAR 0 9
43510: PUSH
43511: LD_VAR 0 17
43515: PUSH
43516: LD_VAR 0 18
43520: PUSH
43521: LD_VAR 0 19
43525: PUSH
43526: LD_VAR 0 20
43530: PUSH
43531: LD_VAR 0 21
43535: PUSH
43536: LD_VAR 0 22
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: PUSH
43549: LD_VAR 0 4
43553: PUSH
43554: LD_INT 1
43556: PLUS
43557: ARRAY
43558: ST_TO_ADDR
43559: GO 43626
43561: LD_INT 3
43563: DOUBLE
43564: EQUAL
43565: IFTRUE 43569
43567: GO 43625
43569: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
43570: LD_ADDR_VAR 0 9
43574: PUSH
43575: LD_VAR 0 23
43579: PUSH
43580: LD_VAR 0 24
43584: PUSH
43585: LD_VAR 0 25
43589: PUSH
43590: LD_VAR 0 26
43594: PUSH
43595: LD_VAR 0 27
43599: PUSH
43600: LD_VAR 0 28
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: LIST
43612: PUSH
43613: LD_VAR 0 4
43617: PUSH
43618: LD_INT 1
43620: PLUS
43621: ARRAY
43622: ST_TO_ADDR
43623: GO 43626
43625: POP
43626: GO 44181
43628: LD_INT 2
43630: DOUBLE
43631: EQUAL
43632: IFTRUE 43642
43634: LD_INT 3
43636: DOUBLE
43637: EQUAL
43638: IFTRUE 43642
43640: GO 43698
43642: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
43643: LD_ADDR_VAR 0 9
43647: PUSH
43648: LD_VAR 0 29
43652: PUSH
43653: LD_VAR 0 30
43657: PUSH
43658: LD_VAR 0 31
43662: PUSH
43663: LD_VAR 0 32
43667: PUSH
43668: LD_VAR 0 33
43672: PUSH
43673: LD_VAR 0 34
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: PUSH
43686: LD_VAR 0 4
43690: PUSH
43691: LD_INT 1
43693: PLUS
43694: ARRAY
43695: ST_TO_ADDR
43696: GO 44181
43698: LD_INT 16
43700: DOUBLE
43701: EQUAL
43702: IFTRUE 43760
43704: LD_INT 17
43706: DOUBLE
43707: EQUAL
43708: IFTRUE 43760
43710: LD_INT 18
43712: DOUBLE
43713: EQUAL
43714: IFTRUE 43760
43716: LD_INT 19
43718: DOUBLE
43719: EQUAL
43720: IFTRUE 43760
43722: LD_INT 22
43724: DOUBLE
43725: EQUAL
43726: IFTRUE 43760
43728: LD_INT 20
43730: DOUBLE
43731: EQUAL
43732: IFTRUE 43760
43734: LD_INT 21
43736: DOUBLE
43737: EQUAL
43738: IFTRUE 43760
43740: LD_INT 23
43742: DOUBLE
43743: EQUAL
43744: IFTRUE 43760
43746: LD_INT 24
43748: DOUBLE
43749: EQUAL
43750: IFTRUE 43760
43752: LD_INT 25
43754: DOUBLE
43755: EQUAL
43756: IFTRUE 43760
43758: GO 43816
43760: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
43761: LD_ADDR_VAR 0 9
43765: PUSH
43766: LD_VAR 0 35
43770: PUSH
43771: LD_VAR 0 36
43775: PUSH
43776: LD_VAR 0 37
43780: PUSH
43781: LD_VAR 0 38
43785: PUSH
43786: LD_VAR 0 39
43790: PUSH
43791: LD_VAR 0 40
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: PUSH
43804: LD_VAR 0 4
43808: PUSH
43809: LD_INT 1
43811: PLUS
43812: ARRAY
43813: ST_TO_ADDR
43814: GO 44181
43816: LD_INT 6
43818: DOUBLE
43819: EQUAL
43820: IFTRUE 43872
43822: LD_INT 7
43824: DOUBLE
43825: EQUAL
43826: IFTRUE 43872
43828: LD_INT 8
43830: DOUBLE
43831: EQUAL
43832: IFTRUE 43872
43834: LD_INT 13
43836: DOUBLE
43837: EQUAL
43838: IFTRUE 43872
43840: LD_INT 12
43842: DOUBLE
43843: EQUAL
43844: IFTRUE 43872
43846: LD_INT 15
43848: DOUBLE
43849: EQUAL
43850: IFTRUE 43872
43852: LD_INT 11
43854: DOUBLE
43855: EQUAL
43856: IFTRUE 43872
43858: LD_INT 14
43860: DOUBLE
43861: EQUAL
43862: IFTRUE 43872
43864: LD_INT 10
43866: DOUBLE
43867: EQUAL
43868: IFTRUE 43872
43870: GO 43928
43872: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
43873: LD_ADDR_VAR 0 9
43877: PUSH
43878: LD_VAR 0 41
43882: PUSH
43883: LD_VAR 0 42
43887: PUSH
43888: LD_VAR 0 43
43892: PUSH
43893: LD_VAR 0 44
43897: PUSH
43898: LD_VAR 0 45
43902: PUSH
43903: LD_VAR 0 46
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: PUSH
43916: LD_VAR 0 4
43920: PUSH
43921: LD_INT 1
43923: PLUS
43924: ARRAY
43925: ST_TO_ADDR
43926: GO 44181
43928: LD_INT 36
43930: DOUBLE
43931: EQUAL
43932: IFTRUE 43936
43934: GO 43992
43936: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
43937: LD_ADDR_VAR 0 9
43941: PUSH
43942: LD_VAR 0 47
43946: PUSH
43947: LD_VAR 0 48
43951: PUSH
43952: LD_VAR 0 49
43956: PUSH
43957: LD_VAR 0 50
43961: PUSH
43962: LD_VAR 0 51
43966: PUSH
43967: LD_VAR 0 52
43971: PUSH
43972: EMPTY
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: PUSH
43980: LD_VAR 0 4
43984: PUSH
43985: LD_INT 1
43987: PLUS
43988: ARRAY
43989: ST_TO_ADDR
43990: GO 44181
43992: LD_INT 4
43994: DOUBLE
43995: EQUAL
43996: IFTRUE 44018
43998: LD_INT 5
44000: DOUBLE
44001: EQUAL
44002: IFTRUE 44018
44004: LD_INT 34
44006: DOUBLE
44007: EQUAL
44008: IFTRUE 44018
44010: LD_INT 37
44012: DOUBLE
44013: EQUAL
44014: IFTRUE 44018
44016: GO 44074
44018: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
44019: LD_ADDR_VAR 0 9
44023: PUSH
44024: LD_VAR 0 53
44028: PUSH
44029: LD_VAR 0 54
44033: PUSH
44034: LD_VAR 0 55
44038: PUSH
44039: LD_VAR 0 56
44043: PUSH
44044: LD_VAR 0 57
44048: PUSH
44049: LD_VAR 0 58
44053: PUSH
44054: EMPTY
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: PUSH
44062: LD_VAR 0 4
44066: PUSH
44067: LD_INT 1
44069: PLUS
44070: ARRAY
44071: ST_TO_ADDR
44072: GO 44181
44074: LD_INT 31
44076: DOUBLE
44077: EQUAL
44078: IFTRUE 44124
44080: LD_INT 32
44082: DOUBLE
44083: EQUAL
44084: IFTRUE 44124
44086: LD_INT 33
44088: DOUBLE
44089: EQUAL
44090: IFTRUE 44124
44092: LD_INT 27
44094: DOUBLE
44095: EQUAL
44096: IFTRUE 44124
44098: LD_INT 26
44100: DOUBLE
44101: EQUAL
44102: IFTRUE 44124
44104: LD_INT 28
44106: DOUBLE
44107: EQUAL
44108: IFTRUE 44124
44110: LD_INT 29
44112: DOUBLE
44113: EQUAL
44114: IFTRUE 44124
44116: LD_INT 30
44118: DOUBLE
44119: EQUAL
44120: IFTRUE 44124
44122: GO 44180
44124: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
44125: LD_ADDR_VAR 0 9
44129: PUSH
44130: LD_VAR 0 59
44134: PUSH
44135: LD_VAR 0 60
44139: PUSH
44140: LD_VAR 0 61
44144: PUSH
44145: LD_VAR 0 62
44149: PUSH
44150: LD_VAR 0 63
44154: PUSH
44155: LD_VAR 0 64
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: LIST
44164: LIST
44165: LIST
44166: LIST
44167: PUSH
44168: LD_VAR 0 4
44172: PUSH
44173: LD_INT 1
44175: PLUS
44176: ARRAY
44177: ST_TO_ADDR
44178: GO 44181
44180: POP
// temp_list2 = [ ] ;
44181: LD_ADDR_VAR 0 10
44185: PUSH
44186: EMPTY
44187: ST_TO_ADDR
// for i in temp_list do
44188: LD_ADDR_VAR 0 8
44192: PUSH
44193: LD_VAR 0 9
44197: PUSH
44198: FOR_IN
44199: IFFALSE 44251
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
44201: LD_ADDR_VAR 0 10
44205: PUSH
44206: LD_VAR 0 10
44210: PUSH
44211: LD_VAR 0 8
44215: PUSH
44216: LD_INT 1
44218: ARRAY
44219: PUSH
44220: LD_VAR 0 2
44224: PLUS
44225: PUSH
44226: LD_VAR 0 8
44230: PUSH
44231: LD_INT 2
44233: ARRAY
44234: PUSH
44235: LD_VAR 0 3
44239: PLUS
44240: PUSH
44241: EMPTY
44242: LIST
44243: LIST
44244: PUSH
44245: EMPTY
44246: LIST
44247: ADD
44248: ST_TO_ADDR
44249: GO 44198
44251: POP
44252: POP
// result = temp_list2 ;
44253: LD_ADDR_VAR 0 7
44257: PUSH
44258: LD_VAR 0 10
44262: ST_TO_ADDR
// end ;
44263: LD_VAR 0 7
44267: RET
// export function EnemyInRange ( unit , dist ) ; begin
44268: LD_INT 0
44270: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
44271: LD_ADDR_VAR 0 3
44275: PUSH
44276: LD_VAR 0 1
44280: PPUSH
44281: CALL_OW 255
44285: PPUSH
44286: LD_VAR 0 1
44290: PPUSH
44291: CALL_OW 250
44295: PPUSH
44296: LD_VAR 0 1
44300: PPUSH
44301: CALL_OW 251
44305: PPUSH
44306: LD_VAR 0 2
44310: PPUSH
44311: CALL 17525 0 4
44315: PUSH
44316: LD_INT 4
44318: ARRAY
44319: ST_TO_ADDR
// end ;
44320: LD_VAR 0 3
44324: RET
// export function PlayerSeeMe ( unit ) ; begin
44325: LD_INT 0
44327: PPUSH
// result := See ( your_side , unit ) ;
44328: LD_ADDR_VAR 0 2
44332: PUSH
44333: LD_OWVAR 2
44337: PPUSH
44338: LD_VAR 0 1
44342: PPUSH
44343: CALL_OW 292
44347: ST_TO_ADDR
// end ;
44348: LD_VAR 0 2
44352: RET
// export function ReverseDir ( unit ) ; begin
44353: LD_INT 0
44355: PPUSH
// if not unit then
44356: LD_VAR 0 1
44360: NOT
44361: IFFALSE 44365
// exit ;
44363: GO 44388
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
44365: LD_ADDR_VAR 0 2
44369: PUSH
44370: LD_VAR 0 1
44374: PPUSH
44375: CALL_OW 254
44379: PUSH
44380: LD_INT 3
44382: PLUS
44383: PUSH
44384: LD_INT 6
44386: MOD
44387: ST_TO_ADDR
// end ;
44388: LD_VAR 0 2
44392: RET
// export function ReverseArray ( array ) ; var i ; begin
44393: LD_INT 0
44395: PPUSH
44396: PPUSH
// if not array then
44397: LD_VAR 0 1
44401: NOT
44402: IFFALSE 44406
// exit ;
44404: GO 44461
// result := [ ] ;
44406: LD_ADDR_VAR 0 2
44410: PUSH
44411: EMPTY
44412: ST_TO_ADDR
// for i := array downto 1 do
44413: LD_ADDR_VAR 0 3
44417: PUSH
44418: DOUBLE
44419: LD_VAR 0 1
44423: INC
44424: ST_TO_ADDR
44425: LD_INT 1
44427: PUSH
44428: FOR_DOWNTO
44429: IFFALSE 44459
// result := Join ( result , array [ i ] ) ;
44431: LD_ADDR_VAR 0 2
44435: PUSH
44436: LD_VAR 0 2
44440: PPUSH
44441: LD_VAR 0 1
44445: PUSH
44446: LD_VAR 0 3
44450: ARRAY
44451: PPUSH
44452: CALL 49303 0 2
44456: ST_TO_ADDR
44457: GO 44428
44459: POP
44460: POP
// end ;
44461: LD_VAR 0 2
44465: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
44466: LD_INT 0
44468: PPUSH
44469: PPUSH
44470: PPUSH
44471: PPUSH
44472: PPUSH
44473: PPUSH
// if not unit or not hexes then
44474: LD_VAR 0 1
44478: NOT
44479: IFTRUE 44488
44481: PUSH
44482: LD_VAR 0 2
44486: NOT
44487: OR
44488: IFFALSE 44492
// exit ;
44490: GO 44615
// dist := 9999 ;
44492: LD_ADDR_VAR 0 5
44496: PUSH
44497: LD_INT 9999
44499: ST_TO_ADDR
// for i = 1 to hexes do
44500: LD_ADDR_VAR 0 4
44504: PUSH
44505: DOUBLE
44506: LD_INT 1
44508: DEC
44509: ST_TO_ADDR
44510: LD_VAR 0 2
44514: PUSH
44515: FOR_TO
44516: IFFALSE 44603
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
44518: LD_ADDR_VAR 0 6
44522: PUSH
44523: LD_VAR 0 1
44527: PPUSH
44528: LD_VAR 0 2
44532: PUSH
44533: LD_VAR 0 4
44537: ARRAY
44538: PUSH
44539: LD_INT 1
44541: ARRAY
44542: PPUSH
44543: LD_VAR 0 2
44547: PUSH
44548: LD_VAR 0 4
44552: ARRAY
44553: PUSH
44554: LD_INT 2
44556: ARRAY
44557: PPUSH
44558: CALL_OW 297
44562: ST_TO_ADDR
// if tdist < dist then
44563: LD_VAR 0 6
44567: PUSH
44568: LD_VAR 0 5
44572: LESS
44573: IFFALSE 44601
// begin hex := hexes [ i ] ;
44575: LD_ADDR_VAR 0 8
44579: PUSH
44580: LD_VAR 0 2
44584: PUSH
44585: LD_VAR 0 4
44589: ARRAY
44590: ST_TO_ADDR
// dist := tdist ;
44591: LD_ADDR_VAR 0 5
44595: PUSH
44596: LD_VAR 0 6
44600: ST_TO_ADDR
// end ; end ;
44601: GO 44515
44603: POP
44604: POP
// result := hex ;
44605: LD_ADDR_VAR 0 3
44609: PUSH
44610: LD_VAR 0 8
44614: ST_TO_ADDR
// end ;
44615: LD_VAR 0 3
44619: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
44620: LD_INT 0
44622: PPUSH
44623: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
44624: LD_VAR 0 1
44628: NOT
44629: IFTRUE 44668
44631: PUSH
44632: LD_VAR 0 1
44636: PUSH
44637: LD_INT 21
44639: PUSH
44640: LD_INT 2
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 23
44649: PUSH
44650: LD_INT 2
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PPUSH
44661: CALL_OW 69
44665: IN
44666: NOT
44667: OR
44668: IFFALSE 44672
// exit ;
44670: GO 44719
// for i = 1 to 3 do
44672: LD_ADDR_VAR 0 3
44676: PUSH
44677: DOUBLE
44678: LD_INT 1
44680: DEC
44681: ST_TO_ADDR
44682: LD_INT 3
44684: PUSH
44685: FOR_TO
44686: IFFALSE 44717
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
44688: LD_VAR 0 1
44692: PPUSH
44693: CALL_OW 250
44697: PPUSH
44698: LD_VAR 0 1
44702: PPUSH
44703: CALL_OW 251
44707: PPUSH
44708: LD_INT 1
44710: PPUSH
44711: CALL_OW 453
44715: GO 44685
44717: POP
44718: POP
// end ;
44719: LD_VAR 0 2
44723: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
44724: LD_INT 0
44726: PPUSH
44727: PPUSH
44728: PPUSH
44729: PPUSH
44730: PPUSH
44731: PPUSH
// if not unit or not enemy_unit then
44732: LD_VAR 0 1
44736: NOT
44737: IFTRUE 44746
44739: PUSH
44740: LD_VAR 0 2
44744: NOT
44745: OR
44746: IFFALSE 44750
// exit ;
44748: GO 45221
// if GetLives ( i ) < 250 then
44750: LD_VAR 0 4
44754: PPUSH
44755: CALL_OW 256
44759: PUSH
44760: LD_INT 250
44762: LESS
44763: IFFALSE 44776
// begin ComAutodestruct ( i ) ;
44765: LD_VAR 0 4
44769: PPUSH
44770: CALL 44620 0 1
// exit ;
44774: GO 45221
// end ; x := GetX ( enemy_unit ) ;
44776: LD_ADDR_VAR 0 7
44780: PUSH
44781: LD_VAR 0 2
44785: PPUSH
44786: CALL_OW 250
44790: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
44791: LD_ADDR_VAR 0 8
44795: PUSH
44796: LD_VAR 0 2
44800: PPUSH
44801: CALL_OW 251
44805: ST_TO_ADDR
// if not x or not y then
44806: LD_VAR 0 7
44810: NOT
44811: IFTRUE 44820
44813: PUSH
44814: LD_VAR 0 8
44818: NOT
44819: OR
44820: IFFALSE 44824
// exit ;
44822: GO 45221
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
44824: LD_ADDR_VAR 0 6
44828: PUSH
44829: LD_VAR 0 7
44833: PPUSH
44834: LD_INT 0
44836: PPUSH
44837: LD_INT 4
44839: PPUSH
44840: CALL_OW 272
44844: PUSH
44845: LD_VAR 0 8
44849: PPUSH
44850: LD_INT 0
44852: PPUSH
44853: LD_INT 4
44855: PPUSH
44856: CALL_OW 273
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_VAR 0 7
44869: PPUSH
44870: LD_INT 1
44872: PPUSH
44873: LD_INT 4
44875: PPUSH
44876: CALL_OW 272
44880: PUSH
44881: LD_VAR 0 8
44885: PPUSH
44886: LD_INT 1
44888: PPUSH
44889: LD_INT 4
44891: PPUSH
44892: CALL_OW 273
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_VAR 0 7
44905: PPUSH
44906: LD_INT 2
44908: PPUSH
44909: LD_INT 4
44911: PPUSH
44912: CALL_OW 272
44916: PUSH
44917: LD_VAR 0 8
44921: PPUSH
44922: LD_INT 2
44924: PPUSH
44925: LD_INT 4
44927: PPUSH
44928: CALL_OW 273
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_VAR 0 7
44941: PPUSH
44942: LD_INT 3
44944: PPUSH
44945: LD_INT 4
44947: PPUSH
44948: CALL_OW 272
44952: PUSH
44953: LD_VAR 0 8
44957: PPUSH
44958: LD_INT 3
44960: PPUSH
44961: LD_INT 4
44963: PPUSH
44964: CALL_OW 273
44968: PUSH
44969: EMPTY
44970: LIST
44971: LIST
44972: PUSH
44973: LD_VAR 0 7
44977: PPUSH
44978: LD_INT 4
44980: PPUSH
44981: LD_INT 4
44983: PPUSH
44984: CALL_OW 272
44988: PUSH
44989: LD_VAR 0 8
44993: PPUSH
44994: LD_INT 4
44996: PPUSH
44997: LD_INT 4
44999: PPUSH
45000: CALL_OW 273
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_VAR 0 7
45013: PPUSH
45014: LD_INT 5
45016: PPUSH
45017: LD_INT 4
45019: PPUSH
45020: CALL_OW 272
45024: PUSH
45025: LD_VAR 0 8
45029: PPUSH
45030: LD_INT 5
45032: PPUSH
45033: LD_INT 4
45035: PPUSH
45036: CALL_OW 273
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: EMPTY
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: LIST
45052: ST_TO_ADDR
// for i = tmp downto 1 do
45053: LD_ADDR_VAR 0 4
45057: PUSH
45058: DOUBLE
45059: LD_VAR 0 6
45063: INC
45064: ST_TO_ADDR
45065: LD_INT 1
45067: PUSH
45068: FOR_DOWNTO
45069: IFFALSE 45172
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
45071: LD_VAR 0 6
45075: PUSH
45076: LD_VAR 0 4
45080: ARRAY
45081: PUSH
45082: LD_INT 1
45084: ARRAY
45085: PPUSH
45086: LD_VAR 0 6
45090: PUSH
45091: LD_VAR 0 4
45095: ARRAY
45096: PUSH
45097: LD_INT 2
45099: ARRAY
45100: PPUSH
45101: CALL_OW 488
45105: NOT
45106: IFTRUE 45148
45108: PUSH
45109: LD_VAR 0 6
45113: PUSH
45114: LD_VAR 0 4
45118: ARRAY
45119: PUSH
45120: LD_INT 1
45122: ARRAY
45123: PPUSH
45124: LD_VAR 0 6
45128: PUSH
45129: LD_VAR 0 4
45133: ARRAY
45134: PUSH
45135: LD_INT 2
45137: ARRAY
45138: PPUSH
45139: CALL_OW 428
45143: PUSH
45144: LD_INT 0
45146: NONEQUAL
45147: OR
45148: IFFALSE 45170
// tmp := Delete ( tmp , i ) ;
45150: LD_ADDR_VAR 0 6
45154: PUSH
45155: LD_VAR 0 6
45159: PPUSH
45160: LD_VAR 0 4
45164: PPUSH
45165: CALL_OW 3
45169: ST_TO_ADDR
45170: GO 45068
45172: POP
45173: POP
// j := GetClosestHex ( unit , tmp ) ;
45174: LD_ADDR_VAR 0 5
45178: PUSH
45179: LD_VAR 0 1
45183: PPUSH
45184: LD_VAR 0 6
45188: PPUSH
45189: CALL 44466 0 2
45193: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
45194: LD_VAR 0 1
45198: PPUSH
45199: LD_VAR 0 5
45203: PUSH
45204: LD_INT 1
45206: ARRAY
45207: PPUSH
45208: LD_VAR 0 5
45212: PUSH
45213: LD_INT 2
45215: ARRAY
45216: PPUSH
45217: CALL_OW 111
// end ;
45221: LD_VAR 0 3
45225: RET
// export function PrepareApemanSoldier ( ) ; begin
45226: LD_INT 0
45228: PPUSH
// uc_nation := 0 ;
45229: LD_ADDR_OWVAR 21
45233: PUSH
45234: LD_INT 0
45236: ST_TO_ADDR
// hc_sex := sex_male ;
45237: LD_ADDR_OWVAR 27
45241: PUSH
45242: LD_INT 1
45244: ST_TO_ADDR
// hc_name :=  ;
45245: LD_ADDR_OWVAR 26
45249: PUSH
45250: LD_STRING 
45252: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
45253: LD_ADDR_OWVAR 28
45257: PUSH
45258: LD_INT 15
45260: ST_TO_ADDR
// hc_gallery :=  ;
45261: LD_ADDR_OWVAR 33
45265: PUSH
45266: LD_STRING 
45268: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45269: LD_ADDR_OWVAR 31
45273: PUSH
45274: LD_INT 0
45276: PPUSH
45277: LD_INT 3
45279: PPUSH
45280: CALL_OW 12
45284: PUSH
45285: LD_INT 0
45287: PPUSH
45288: LD_INT 3
45290: PPUSH
45291: CALL_OW 12
45295: PUSH
45296: LD_INT 0
45298: PUSH
45299: LD_INT 0
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
45308: LD_ADDR_OWVAR 29
45312: PUSH
45313: LD_INT 12
45315: PUSH
45316: LD_INT 12
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: ST_TO_ADDR
// end ;
45323: LD_VAR 0 1
45327: RET
// export function PrepareApemanEngineer ( ) ; begin
45328: LD_INT 0
45330: PPUSH
// uc_nation := 0 ;
45331: LD_ADDR_OWVAR 21
45335: PUSH
45336: LD_INT 0
45338: ST_TO_ADDR
// hc_sex := sex_male ;
45339: LD_ADDR_OWVAR 27
45343: PUSH
45344: LD_INT 1
45346: ST_TO_ADDR
// hc_name :=  ;
45347: LD_ADDR_OWVAR 26
45351: PUSH
45352: LD_STRING 
45354: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
45355: LD_ADDR_OWVAR 28
45359: PUSH
45360: LD_INT 16
45362: ST_TO_ADDR
// hc_gallery :=  ;
45363: LD_ADDR_OWVAR 33
45367: PUSH
45368: LD_STRING 
45370: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45371: LD_ADDR_OWVAR 31
45375: PUSH
45376: LD_INT 0
45378: PPUSH
45379: LD_INT 3
45381: PPUSH
45382: CALL_OW 12
45386: PUSH
45387: LD_INT 0
45389: PPUSH
45390: LD_INT 3
45392: PPUSH
45393: CALL_OW 12
45397: PUSH
45398: LD_INT 0
45400: PUSH
45401: LD_INT 0
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
45410: LD_ADDR_OWVAR 29
45414: PUSH
45415: LD_INT 12
45417: PUSH
45418: LD_INT 12
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: ST_TO_ADDR
// end ;
45425: LD_VAR 0 1
45429: RET
// export function PrepareApeman ( agressivity ) ; begin
45430: LD_INT 0
45432: PPUSH
// uc_side := 0 ;
45433: LD_ADDR_OWVAR 20
45437: PUSH
45438: LD_INT 0
45440: ST_TO_ADDR
// uc_nation := 0 ;
45441: LD_ADDR_OWVAR 21
45445: PUSH
45446: LD_INT 0
45448: ST_TO_ADDR
// hc_sex := sex_male ;
45449: LD_ADDR_OWVAR 27
45453: PUSH
45454: LD_INT 1
45456: ST_TO_ADDR
// hc_class := class_apeman ;
45457: LD_ADDR_OWVAR 28
45461: PUSH
45462: LD_INT 12
45464: ST_TO_ADDR
// hc_gallery :=  ;
45465: LD_ADDR_OWVAR 33
45469: PUSH
45470: LD_STRING 
45472: ST_TO_ADDR
// hc_name :=  ;
45473: LD_ADDR_OWVAR 26
45477: PUSH
45478: LD_STRING 
45480: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
45481: LD_ADDR_OWVAR 29
45485: PUSH
45486: LD_INT 12
45488: PUSH
45489: LD_INT 12
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: ST_TO_ADDR
// if agressivity = 0 then
45496: LD_VAR 0 1
45500: PUSH
45501: LD_INT 0
45503: EQUAL
45504: IFFALSE 45516
// hc_agressivity := 0 else
45506: LD_ADDR_OWVAR 35
45510: PUSH
45511: LD_INT 0
45513: ST_TO_ADDR
45514: GO 45537
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45516: LD_ADDR_OWVAR 35
45520: PUSH
45521: LD_VAR 0 1
45525: NEG
45526: PPUSH
45527: LD_VAR 0 1
45531: PPUSH
45532: CALL_OW 12
45536: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
45537: LD_ADDR_OWVAR 31
45541: PUSH
45542: LD_INT 0
45544: PPUSH
45545: LD_INT 3
45547: PPUSH
45548: CALL_OW 12
45552: PUSH
45553: LD_INT 0
45555: PPUSH
45556: LD_INT 3
45558: PPUSH
45559: CALL_OW 12
45563: PUSH
45564: LD_INT 0
45566: PUSH
45567: LD_INT 0
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: ST_TO_ADDR
// end ;
45576: LD_VAR 0 2
45580: RET
// export function PrepareTiger ( agressivity ) ; begin
45581: LD_INT 0
45583: PPUSH
// uc_side := 0 ;
45584: LD_ADDR_OWVAR 20
45588: PUSH
45589: LD_INT 0
45591: ST_TO_ADDR
// uc_nation := 0 ;
45592: LD_ADDR_OWVAR 21
45596: PUSH
45597: LD_INT 0
45599: ST_TO_ADDR
// InitHc ;
45600: CALL_OW 19
// hc_class := class_tiger ;
45604: LD_ADDR_OWVAR 28
45608: PUSH
45609: LD_INT 14
45611: ST_TO_ADDR
// hc_gallery :=  ;
45612: LD_ADDR_OWVAR 33
45616: PUSH
45617: LD_STRING 
45619: ST_TO_ADDR
// hc_name :=  ;
45620: LD_ADDR_OWVAR 26
45624: PUSH
45625: LD_STRING 
45627: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
45628: LD_ADDR_OWVAR 35
45632: PUSH
45633: LD_VAR 0 1
45637: NEG
45638: PPUSH
45639: LD_VAR 0 1
45643: PPUSH
45644: CALL_OW 12
45648: ST_TO_ADDR
// end ;
45649: LD_VAR 0 2
45653: RET
// export function PrepareEnchidna ( ) ; begin
45654: LD_INT 0
45656: PPUSH
// uc_side := 0 ;
45657: LD_ADDR_OWVAR 20
45661: PUSH
45662: LD_INT 0
45664: ST_TO_ADDR
// uc_nation := 0 ;
45665: LD_ADDR_OWVAR 21
45669: PUSH
45670: LD_INT 0
45672: ST_TO_ADDR
// InitHc ;
45673: CALL_OW 19
// hc_class := class_baggie ;
45677: LD_ADDR_OWVAR 28
45681: PUSH
45682: LD_INT 13
45684: ST_TO_ADDR
// hc_gallery :=  ;
45685: LD_ADDR_OWVAR 33
45689: PUSH
45690: LD_STRING 
45692: ST_TO_ADDR
// hc_name :=  ;
45693: LD_ADDR_OWVAR 26
45697: PUSH
45698: LD_STRING 
45700: ST_TO_ADDR
// end ;
45701: LD_VAR 0 1
45705: RET
// export function PrepareFrog ( ) ; begin
45706: LD_INT 0
45708: PPUSH
// uc_side := 0 ;
45709: LD_ADDR_OWVAR 20
45713: PUSH
45714: LD_INT 0
45716: ST_TO_ADDR
// uc_nation := 0 ;
45717: LD_ADDR_OWVAR 21
45721: PUSH
45722: LD_INT 0
45724: ST_TO_ADDR
// InitHc ;
45725: CALL_OW 19
// hc_class := class_frog ;
45729: LD_ADDR_OWVAR 28
45733: PUSH
45734: LD_INT 19
45736: ST_TO_ADDR
// hc_gallery :=  ;
45737: LD_ADDR_OWVAR 33
45741: PUSH
45742: LD_STRING 
45744: ST_TO_ADDR
// hc_name :=  ;
45745: LD_ADDR_OWVAR 26
45749: PUSH
45750: LD_STRING 
45752: ST_TO_ADDR
// end ;
45753: LD_VAR 0 1
45757: RET
// export function PrepareFish ( ) ; begin
45758: LD_INT 0
45760: PPUSH
// uc_side := 0 ;
45761: LD_ADDR_OWVAR 20
45765: PUSH
45766: LD_INT 0
45768: ST_TO_ADDR
// uc_nation := 0 ;
45769: LD_ADDR_OWVAR 21
45773: PUSH
45774: LD_INT 0
45776: ST_TO_ADDR
// InitHc ;
45777: CALL_OW 19
// hc_class := class_fish ;
45781: LD_ADDR_OWVAR 28
45785: PUSH
45786: LD_INT 20
45788: ST_TO_ADDR
// hc_gallery :=  ;
45789: LD_ADDR_OWVAR 33
45793: PUSH
45794: LD_STRING 
45796: ST_TO_ADDR
// hc_name :=  ;
45797: LD_ADDR_OWVAR 26
45801: PUSH
45802: LD_STRING 
45804: ST_TO_ADDR
// end ;
45805: LD_VAR 0 1
45809: RET
// export function PrepareBird ( ) ; begin
45810: LD_INT 0
45812: PPUSH
// uc_side := 0 ;
45813: LD_ADDR_OWVAR 20
45817: PUSH
45818: LD_INT 0
45820: ST_TO_ADDR
// uc_nation := 0 ;
45821: LD_ADDR_OWVAR 21
45825: PUSH
45826: LD_INT 0
45828: ST_TO_ADDR
// InitHc ;
45829: CALL_OW 19
// hc_class := class_phororhacos ;
45833: LD_ADDR_OWVAR 28
45837: PUSH
45838: LD_INT 18
45840: ST_TO_ADDR
// hc_gallery :=  ;
45841: LD_ADDR_OWVAR 33
45845: PUSH
45846: LD_STRING 
45848: ST_TO_ADDR
// hc_name :=  ;
45849: LD_ADDR_OWVAR 26
45853: PUSH
45854: LD_STRING 
45856: ST_TO_ADDR
// end ;
45857: LD_VAR 0 1
45861: RET
// export function PrepareHorse ( ) ; begin
45862: LD_INT 0
45864: PPUSH
// uc_side := 0 ;
45865: LD_ADDR_OWVAR 20
45869: PUSH
45870: LD_INT 0
45872: ST_TO_ADDR
// uc_nation := 0 ;
45873: LD_ADDR_OWVAR 21
45877: PUSH
45878: LD_INT 0
45880: ST_TO_ADDR
// InitHc ;
45881: CALL_OW 19
// hc_class := class_horse ;
45885: LD_ADDR_OWVAR 28
45889: PUSH
45890: LD_INT 21
45892: ST_TO_ADDR
// hc_gallery :=  ;
45893: LD_ADDR_OWVAR 33
45897: PUSH
45898: LD_STRING 
45900: ST_TO_ADDR
// hc_name :=  ;
45901: LD_ADDR_OWVAR 26
45905: PUSH
45906: LD_STRING 
45908: ST_TO_ADDR
// end ;
45909: LD_VAR 0 1
45913: RET
// export function PrepareMastodont ( ) ; begin
45914: LD_INT 0
45916: PPUSH
// uc_side := 0 ;
45917: LD_ADDR_OWVAR 20
45921: PUSH
45922: LD_INT 0
45924: ST_TO_ADDR
// uc_nation := 0 ;
45925: LD_ADDR_OWVAR 21
45929: PUSH
45930: LD_INT 0
45932: ST_TO_ADDR
// vc_chassis := class_mastodont ;
45933: LD_ADDR_OWVAR 37
45937: PUSH
45938: LD_INT 31
45940: ST_TO_ADDR
// vc_control := control_rider ;
45941: LD_ADDR_OWVAR 38
45945: PUSH
45946: LD_INT 4
45948: ST_TO_ADDR
// end ;
45949: LD_VAR 0 1
45953: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
45954: LD_INT 0
45956: PPUSH
45957: PPUSH
45958: PPUSH
// uc_side = 0 ;
45959: LD_ADDR_OWVAR 20
45963: PUSH
45964: LD_INT 0
45966: ST_TO_ADDR
// uc_nation = 0 ;
45967: LD_ADDR_OWVAR 21
45971: PUSH
45972: LD_INT 0
45974: ST_TO_ADDR
// InitHc_All ( ) ;
45975: CALL_OW 584
// InitVc ;
45979: CALL_OW 20
// if mastodonts then
45983: LD_VAR 0 6
45987: IFFALSE 46054
// for i = 1 to mastodonts do
45989: LD_ADDR_VAR 0 11
45993: PUSH
45994: DOUBLE
45995: LD_INT 1
45997: DEC
45998: ST_TO_ADDR
45999: LD_VAR 0 6
46003: PUSH
46004: FOR_TO
46005: IFFALSE 46052
// begin vc_chassis := 31 ;
46007: LD_ADDR_OWVAR 37
46011: PUSH
46012: LD_INT 31
46014: ST_TO_ADDR
// vc_control := control_rider ;
46015: LD_ADDR_OWVAR 38
46019: PUSH
46020: LD_INT 4
46022: ST_TO_ADDR
// animal := CreateVehicle ;
46023: LD_ADDR_VAR 0 12
46027: PUSH
46028: CALL_OW 45
46032: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46033: LD_VAR 0 12
46037: PPUSH
46038: LD_VAR 0 8
46042: PPUSH
46043: LD_INT 0
46045: PPUSH
46046: CALL 48196 0 3
// end ;
46050: GO 46004
46052: POP
46053: POP
// if horses then
46054: LD_VAR 0 5
46058: IFFALSE 46125
// for i = 1 to horses do
46060: LD_ADDR_VAR 0 11
46064: PUSH
46065: DOUBLE
46066: LD_INT 1
46068: DEC
46069: ST_TO_ADDR
46070: LD_VAR 0 5
46074: PUSH
46075: FOR_TO
46076: IFFALSE 46123
// begin hc_class := 21 ;
46078: LD_ADDR_OWVAR 28
46082: PUSH
46083: LD_INT 21
46085: ST_TO_ADDR
// hc_gallery :=  ;
46086: LD_ADDR_OWVAR 33
46090: PUSH
46091: LD_STRING 
46093: ST_TO_ADDR
// animal := CreateHuman ;
46094: LD_ADDR_VAR 0 12
46098: PUSH
46099: CALL_OW 44
46103: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46104: LD_VAR 0 12
46108: PPUSH
46109: LD_VAR 0 8
46113: PPUSH
46114: LD_INT 0
46116: PPUSH
46117: CALL 48196 0 3
// end ;
46121: GO 46075
46123: POP
46124: POP
// if birds then
46125: LD_VAR 0 1
46129: IFFALSE 46196
// for i = 1 to birds do
46131: LD_ADDR_VAR 0 11
46135: PUSH
46136: DOUBLE
46137: LD_INT 1
46139: DEC
46140: ST_TO_ADDR
46141: LD_VAR 0 1
46145: PUSH
46146: FOR_TO
46147: IFFALSE 46194
// begin hc_class := 18 ;
46149: LD_ADDR_OWVAR 28
46153: PUSH
46154: LD_INT 18
46156: ST_TO_ADDR
// hc_gallery =  ;
46157: LD_ADDR_OWVAR 33
46161: PUSH
46162: LD_STRING 
46164: ST_TO_ADDR
// animal := CreateHuman ;
46165: LD_ADDR_VAR 0 12
46169: PUSH
46170: CALL_OW 44
46174: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46175: LD_VAR 0 12
46179: PPUSH
46180: LD_VAR 0 8
46184: PPUSH
46185: LD_INT 0
46187: PPUSH
46188: CALL 48196 0 3
// end ;
46192: GO 46146
46194: POP
46195: POP
// if tigers then
46196: LD_VAR 0 2
46200: IFFALSE 46284
// for i = 1 to tigers do
46202: LD_ADDR_VAR 0 11
46206: PUSH
46207: DOUBLE
46208: LD_INT 1
46210: DEC
46211: ST_TO_ADDR
46212: LD_VAR 0 2
46216: PUSH
46217: FOR_TO
46218: IFFALSE 46282
// begin hc_class = class_tiger ;
46220: LD_ADDR_OWVAR 28
46224: PUSH
46225: LD_INT 14
46227: ST_TO_ADDR
// hc_gallery =  ;
46228: LD_ADDR_OWVAR 33
46232: PUSH
46233: LD_STRING 
46235: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
46236: LD_ADDR_OWVAR 35
46240: PUSH
46241: LD_INT 7
46243: NEG
46244: PPUSH
46245: LD_INT 7
46247: PPUSH
46248: CALL_OW 12
46252: ST_TO_ADDR
// animal := CreateHuman ;
46253: LD_ADDR_VAR 0 12
46257: PUSH
46258: CALL_OW 44
46262: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46263: LD_VAR 0 12
46267: PPUSH
46268: LD_VAR 0 8
46272: PPUSH
46273: LD_INT 0
46275: PPUSH
46276: CALL 48196 0 3
// end ;
46280: GO 46217
46282: POP
46283: POP
// if apemans then
46284: LD_VAR 0 3
46288: IFFALSE 46411
// for i = 1 to apemans do
46290: LD_ADDR_VAR 0 11
46294: PUSH
46295: DOUBLE
46296: LD_INT 1
46298: DEC
46299: ST_TO_ADDR
46300: LD_VAR 0 3
46304: PUSH
46305: FOR_TO
46306: IFFALSE 46409
// begin hc_class = class_apeman ;
46308: LD_ADDR_OWVAR 28
46312: PUSH
46313: LD_INT 12
46315: ST_TO_ADDR
// hc_gallery =  ;
46316: LD_ADDR_OWVAR 33
46320: PUSH
46321: LD_STRING 
46323: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
46324: LD_ADDR_OWVAR 35
46328: PUSH
46329: LD_INT 2
46331: NEG
46332: PPUSH
46333: LD_INT 2
46335: PPUSH
46336: CALL_OW 12
46340: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
46341: LD_ADDR_OWVAR 31
46345: PUSH
46346: LD_INT 1
46348: PPUSH
46349: LD_INT 3
46351: PPUSH
46352: CALL_OW 12
46356: PUSH
46357: LD_INT 1
46359: PPUSH
46360: LD_INT 3
46362: PPUSH
46363: CALL_OW 12
46367: PUSH
46368: LD_INT 0
46370: PUSH
46371: LD_INT 0
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: ST_TO_ADDR
// animal := CreateHuman ;
46380: LD_ADDR_VAR 0 12
46384: PUSH
46385: CALL_OW 44
46389: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46390: LD_VAR 0 12
46394: PPUSH
46395: LD_VAR 0 8
46399: PPUSH
46400: LD_INT 0
46402: PPUSH
46403: CALL 48196 0 3
// end ;
46407: GO 46305
46409: POP
46410: POP
// if enchidnas then
46411: LD_VAR 0 4
46415: IFFALSE 46482
// for i = 1 to enchidnas do
46417: LD_ADDR_VAR 0 11
46421: PUSH
46422: DOUBLE
46423: LD_INT 1
46425: DEC
46426: ST_TO_ADDR
46427: LD_VAR 0 4
46431: PUSH
46432: FOR_TO
46433: IFFALSE 46480
// begin hc_class = 13 ;
46435: LD_ADDR_OWVAR 28
46439: PUSH
46440: LD_INT 13
46442: ST_TO_ADDR
// hc_gallery =  ;
46443: LD_ADDR_OWVAR 33
46447: PUSH
46448: LD_STRING 
46450: ST_TO_ADDR
// animal := CreateHuman ;
46451: LD_ADDR_VAR 0 12
46455: PUSH
46456: CALL_OW 44
46460: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46461: LD_VAR 0 12
46465: PPUSH
46466: LD_VAR 0 8
46470: PPUSH
46471: LD_INT 0
46473: PPUSH
46474: CALL 48196 0 3
// end ;
46478: GO 46432
46480: POP
46481: POP
// if fishes then
46482: LD_VAR 0 7
46486: IFFALSE 46553
// for i = 1 to fishes do
46488: LD_ADDR_VAR 0 11
46492: PUSH
46493: DOUBLE
46494: LD_INT 1
46496: DEC
46497: ST_TO_ADDR
46498: LD_VAR 0 7
46502: PUSH
46503: FOR_TO
46504: IFFALSE 46551
// begin hc_class = 20 ;
46506: LD_ADDR_OWVAR 28
46510: PUSH
46511: LD_INT 20
46513: ST_TO_ADDR
// hc_gallery =  ;
46514: LD_ADDR_OWVAR 33
46518: PUSH
46519: LD_STRING 
46521: ST_TO_ADDR
// animal := CreateHuman ;
46522: LD_ADDR_VAR 0 12
46526: PUSH
46527: CALL_OW 44
46531: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
46532: LD_VAR 0 12
46536: PPUSH
46537: LD_VAR 0 9
46541: PPUSH
46542: LD_INT 0
46544: PPUSH
46545: CALL 48196 0 3
// end ;
46549: GO 46503
46551: POP
46552: POP
// end ;
46553: LD_VAR 0 10
46557: RET
// export function WantHeal ( sci , unit ) ; begin
46558: LD_INT 0
46560: PPUSH
// if GetTaskList ( sci ) > 0 then
46561: LD_VAR 0 1
46565: PPUSH
46566: CALL_OW 437
46570: PUSH
46571: LD_INT 0
46573: GREATER
46574: IFFALSE 46646
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
46576: LD_VAR 0 1
46580: PPUSH
46581: CALL_OW 437
46585: PUSH
46586: LD_INT 1
46588: ARRAY
46589: PUSH
46590: LD_INT 1
46592: ARRAY
46593: PUSH
46594: LD_STRING l
46596: EQUAL
46597: IFFALSE 46624
46599: PUSH
46600: LD_VAR 0 1
46604: PPUSH
46605: CALL_OW 437
46609: PUSH
46610: LD_INT 1
46612: ARRAY
46613: PUSH
46614: LD_INT 4
46616: ARRAY
46617: PUSH
46618: LD_VAR 0 2
46622: EQUAL
46623: AND
46624: IFFALSE 46636
// result := true else
46626: LD_ADDR_VAR 0 3
46630: PUSH
46631: LD_INT 1
46633: ST_TO_ADDR
46634: GO 46644
// result := false ;
46636: LD_ADDR_VAR 0 3
46640: PUSH
46641: LD_INT 0
46643: ST_TO_ADDR
// end else
46644: GO 46654
// result := false ;
46646: LD_ADDR_VAR 0 3
46650: PUSH
46651: LD_INT 0
46653: ST_TO_ADDR
// end ;
46654: LD_VAR 0 3
46658: RET
// export function HealTarget ( sci ) ; begin
46659: LD_INT 0
46661: PPUSH
// if not sci then
46662: LD_VAR 0 1
46666: NOT
46667: IFFALSE 46671
// exit ;
46669: GO 46736
// result := 0 ;
46671: LD_ADDR_VAR 0 2
46675: PUSH
46676: LD_INT 0
46678: ST_TO_ADDR
// if GetTaskList ( sci ) then
46679: LD_VAR 0 1
46683: PPUSH
46684: CALL_OW 437
46688: IFFALSE 46736
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
46690: LD_VAR 0 1
46694: PPUSH
46695: CALL_OW 437
46699: PUSH
46700: LD_INT 1
46702: ARRAY
46703: PUSH
46704: LD_INT 1
46706: ARRAY
46707: PUSH
46708: LD_STRING l
46710: EQUAL
46711: IFFALSE 46736
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
46713: LD_ADDR_VAR 0 2
46717: PUSH
46718: LD_VAR 0 1
46722: PPUSH
46723: CALL_OW 437
46727: PUSH
46728: LD_INT 1
46730: ARRAY
46731: PUSH
46732: LD_INT 4
46734: ARRAY
46735: ST_TO_ADDR
// end ;
46736: LD_VAR 0 2
46740: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
46741: LD_INT 0
46743: PPUSH
46744: PPUSH
46745: PPUSH
46746: PPUSH
// if not base_units then
46747: LD_VAR 0 1
46751: NOT
46752: IFFALSE 46756
// exit ;
46754: GO 46843
// result := false ;
46756: LD_ADDR_VAR 0 2
46760: PUSH
46761: LD_INT 0
46763: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
46764: LD_ADDR_VAR 0 5
46768: PUSH
46769: LD_VAR 0 1
46773: PPUSH
46774: LD_INT 21
46776: PUSH
46777: LD_INT 3
46779: PUSH
46780: EMPTY
46781: LIST
46782: LIST
46783: PPUSH
46784: CALL_OW 72
46788: ST_TO_ADDR
// if not tmp then
46789: LD_VAR 0 5
46793: NOT
46794: IFFALSE 46798
// exit ;
46796: GO 46843
// for i in tmp do
46798: LD_ADDR_VAR 0 3
46802: PUSH
46803: LD_VAR 0 5
46807: PUSH
46808: FOR_IN
46809: IFFALSE 46841
// begin result := EnemyInRange ( i , 22 ) ;
46811: LD_ADDR_VAR 0 2
46815: PUSH
46816: LD_VAR 0 3
46820: PPUSH
46821: LD_INT 22
46823: PPUSH
46824: CALL 44268 0 2
46828: ST_TO_ADDR
// if result then
46829: LD_VAR 0 2
46833: IFFALSE 46839
// exit ;
46835: POP
46836: POP
46837: GO 46843
// end ;
46839: GO 46808
46841: POP
46842: POP
// end ;
46843: LD_VAR 0 2
46847: RET
// export function FilterByTag ( units , tag ) ; begin
46848: LD_INT 0
46850: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
46851: LD_ADDR_VAR 0 3
46855: PUSH
46856: LD_VAR 0 1
46860: PPUSH
46861: LD_INT 120
46863: PUSH
46864: LD_VAR 0 2
46868: PUSH
46869: EMPTY
46870: LIST
46871: LIST
46872: PPUSH
46873: CALL_OW 72
46877: ST_TO_ADDR
// end ;
46878: LD_VAR 0 3
46882: RET
// export function IsDriver ( un ) ; begin
46883: LD_INT 0
46885: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
46886: LD_ADDR_VAR 0 2
46890: PUSH
46891: LD_VAR 0 1
46895: PUSH
46896: LD_INT 55
46898: PUSH
46899: EMPTY
46900: LIST
46901: PPUSH
46902: CALL_OW 69
46906: IN
46907: ST_TO_ADDR
// end ;
46908: LD_VAR 0 2
46912: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
46913: LD_INT 0
46915: PPUSH
46916: PPUSH
// list := [ ] ;
46917: LD_ADDR_VAR 0 5
46921: PUSH
46922: EMPTY
46923: ST_TO_ADDR
// case d of 0 :
46924: LD_VAR 0 3
46928: PUSH
46929: LD_INT 0
46931: DOUBLE
46932: EQUAL
46933: IFTRUE 46937
46935: GO 47070
46937: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
46938: LD_ADDR_VAR 0 5
46942: PUSH
46943: LD_VAR 0 1
46947: PUSH
46948: LD_INT 4
46950: MINUS
46951: PUSH
46952: LD_VAR 0 2
46956: PUSH
46957: LD_INT 4
46959: MINUS
46960: PUSH
46961: LD_INT 2
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: LD_VAR 0 1
46973: PUSH
46974: LD_INT 3
46976: MINUS
46977: PUSH
46978: LD_VAR 0 2
46982: PUSH
46983: LD_INT 1
46985: PUSH
46986: EMPTY
46987: LIST
46988: LIST
46989: LIST
46990: PUSH
46991: LD_VAR 0 1
46995: PUSH
46996: LD_INT 4
46998: PLUS
46999: PUSH
47000: LD_VAR 0 2
47004: PUSH
47005: LD_INT 4
47007: PUSH
47008: EMPTY
47009: LIST
47010: LIST
47011: LIST
47012: PUSH
47013: LD_VAR 0 1
47017: PUSH
47018: LD_INT 3
47020: PLUS
47021: PUSH
47022: LD_VAR 0 2
47026: PUSH
47027: LD_INT 3
47029: PLUS
47030: PUSH
47031: LD_INT 5
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: LIST
47038: PUSH
47039: LD_VAR 0 1
47043: PUSH
47044: LD_VAR 0 2
47048: PUSH
47049: LD_INT 4
47051: PLUS
47052: PUSH
47053: LD_INT 0
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: LIST
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: ST_TO_ADDR
// end ; 1 :
47068: GO 47768
47070: LD_INT 1
47072: DOUBLE
47073: EQUAL
47074: IFTRUE 47078
47076: GO 47211
47078: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
47079: LD_ADDR_VAR 0 5
47083: PUSH
47084: LD_VAR 0 1
47088: PUSH
47089: LD_VAR 0 2
47093: PUSH
47094: LD_INT 4
47096: MINUS
47097: PUSH
47098: LD_INT 3
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: LIST
47105: PUSH
47106: LD_VAR 0 1
47110: PUSH
47111: LD_INT 3
47113: MINUS
47114: PUSH
47115: LD_VAR 0 2
47119: PUSH
47120: LD_INT 3
47122: MINUS
47123: PUSH
47124: LD_INT 2
47126: PUSH
47127: EMPTY
47128: LIST
47129: LIST
47130: LIST
47131: PUSH
47132: LD_VAR 0 1
47136: PUSH
47137: LD_INT 4
47139: MINUS
47140: PUSH
47141: LD_VAR 0 2
47145: PUSH
47146: LD_INT 1
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: LIST
47153: PUSH
47154: LD_VAR 0 1
47158: PUSH
47159: LD_VAR 0 2
47163: PUSH
47164: LD_INT 3
47166: PLUS
47167: PUSH
47168: LD_INT 0
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: LIST
47175: PUSH
47176: LD_VAR 0 1
47180: PUSH
47181: LD_INT 4
47183: PLUS
47184: PUSH
47185: LD_VAR 0 2
47189: PUSH
47190: LD_INT 4
47192: PLUS
47193: PUSH
47194: LD_INT 5
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: LIST
47201: PUSH
47202: EMPTY
47203: LIST
47204: LIST
47205: LIST
47206: LIST
47207: LIST
47208: ST_TO_ADDR
// end ; 2 :
47209: GO 47768
47211: LD_INT 2
47213: DOUBLE
47214: EQUAL
47215: IFTRUE 47219
47217: GO 47348
47219: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
47220: LD_ADDR_VAR 0 5
47224: PUSH
47225: LD_VAR 0 1
47229: PUSH
47230: LD_VAR 0 2
47234: PUSH
47235: LD_INT 3
47237: MINUS
47238: PUSH
47239: LD_INT 3
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: LIST
47246: PUSH
47247: LD_VAR 0 1
47251: PUSH
47252: LD_INT 4
47254: PLUS
47255: PUSH
47256: LD_VAR 0 2
47260: PUSH
47261: LD_INT 4
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: LIST
47268: PUSH
47269: LD_VAR 0 1
47273: PUSH
47274: LD_VAR 0 2
47278: PUSH
47279: LD_INT 4
47281: PLUS
47282: PUSH
47283: LD_INT 0
47285: PUSH
47286: EMPTY
47287: LIST
47288: LIST
47289: LIST
47290: PUSH
47291: LD_VAR 0 1
47295: PUSH
47296: LD_INT 3
47298: MINUS
47299: PUSH
47300: LD_VAR 0 2
47304: PUSH
47305: LD_INT 1
47307: PUSH
47308: EMPTY
47309: LIST
47310: LIST
47311: LIST
47312: PUSH
47313: LD_VAR 0 1
47317: PUSH
47318: LD_INT 4
47320: MINUS
47321: PUSH
47322: LD_VAR 0 2
47326: PUSH
47327: LD_INT 4
47329: MINUS
47330: PUSH
47331: LD_INT 2
47333: PUSH
47334: EMPTY
47335: LIST
47336: LIST
47337: LIST
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: LIST
47343: LIST
47344: LIST
47345: ST_TO_ADDR
// end ; 3 :
47346: GO 47768
47348: LD_INT 3
47350: DOUBLE
47351: EQUAL
47352: IFTRUE 47356
47354: GO 47489
47356: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
47357: LD_ADDR_VAR 0 5
47361: PUSH
47362: LD_VAR 0 1
47366: PUSH
47367: LD_INT 3
47369: PLUS
47370: PUSH
47371: LD_VAR 0 2
47375: PUSH
47376: LD_INT 4
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: LIST
47383: PUSH
47384: LD_VAR 0 1
47388: PUSH
47389: LD_INT 4
47391: PLUS
47392: PUSH
47393: LD_VAR 0 2
47397: PUSH
47398: LD_INT 4
47400: PLUS
47401: PUSH
47402: LD_INT 5
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: LIST
47409: PUSH
47410: LD_VAR 0 1
47414: PUSH
47415: LD_INT 4
47417: MINUS
47418: PUSH
47419: LD_VAR 0 2
47423: PUSH
47424: LD_INT 1
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: LIST
47431: PUSH
47432: LD_VAR 0 1
47436: PUSH
47437: LD_VAR 0 2
47441: PUSH
47442: LD_INT 4
47444: MINUS
47445: PUSH
47446: LD_INT 3
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: LIST
47453: PUSH
47454: LD_VAR 0 1
47458: PUSH
47459: LD_INT 3
47461: MINUS
47462: PUSH
47463: LD_VAR 0 2
47467: PUSH
47468: LD_INT 3
47470: MINUS
47471: PUSH
47472: LD_INT 2
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: LIST
47479: PUSH
47480: EMPTY
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: ST_TO_ADDR
// end ; 4 :
47487: GO 47768
47489: LD_INT 4
47491: DOUBLE
47492: EQUAL
47493: IFTRUE 47497
47495: GO 47630
47497: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
47498: LD_ADDR_VAR 0 5
47502: PUSH
47503: LD_VAR 0 1
47507: PUSH
47508: LD_VAR 0 2
47512: PUSH
47513: LD_INT 4
47515: PLUS
47516: PUSH
47517: LD_INT 0
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: LIST
47524: PUSH
47525: LD_VAR 0 1
47529: PUSH
47530: LD_INT 3
47532: PLUS
47533: PUSH
47534: LD_VAR 0 2
47538: PUSH
47539: LD_INT 3
47541: PLUS
47542: PUSH
47543: LD_INT 5
47545: PUSH
47546: EMPTY
47547: LIST
47548: LIST
47549: LIST
47550: PUSH
47551: LD_VAR 0 1
47555: PUSH
47556: LD_INT 4
47558: PLUS
47559: PUSH
47560: LD_VAR 0 2
47564: PUSH
47565: LD_INT 4
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: LIST
47572: PUSH
47573: LD_VAR 0 1
47577: PUSH
47578: LD_VAR 0 2
47582: PUSH
47583: LD_INT 3
47585: MINUS
47586: PUSH
47587: LD_INT 3
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: PUSH
47595: LD_VAR 0 1
47599: PUSH
47600: LD_INT 4
47602: MINUS
47603: PUSH
47604: LD_VAR 0 2
47608: PUSH
47609: LD_INT 4
47611: MINUS
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: LIST
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: LIST
47625: LIST
47626: LIST
47627: ST_TO_ADDR
// end ; 5 :
47628: GO 47768
47630: LD_INT 5
47632: DOUBLE
47633: EQUAL
47634: IFTRUE 47638
47636: GO 47767
47638: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
47639: LD_ADDR_VAR 0 5
47643: PUSH
47644: LD_VAR 0 1
47648: PUSH
47649: LD_INT 4
47651: MINUS
47652: PUSH
47653: LD_VAR 0 2
47657: PUSH
47658: LD_INT 1
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: LIST
47665: PUSH
47666: LD_VAR 0 1
47670: PUSH
47671: LD_VAR 0 2
47675: PUSH
47676: LD_INT 4
47678: MINUS
47679: PUSH
47680: LD_INT 3
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: LIST
47687: PUSH
47688: LD_VAR 0 1
47692: PUSH
47693: LD_INT 4
47695: PLUS
47696: PUSH
47697: LD_VAR 0 2
47701: PUSH
47702: LD_INT 4
47704: PLUS
47705: PUSH
47706: LD_INT 5
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: LIST
47713: PUSH
47714: LD_VAR 0 1
47718: PUSH
47719: LD_INT 3
47721: PLUS
47722: PUSH
47723: LD_VAR 0 2
47727: PUSH
47728: LD_INT 4
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: LIST
47735: PUSH
47736: LD_VAR 0 1
47740: PUSH
47741: LD_VAR 0 2
47745: PUSH
47746: LD_INT 3
47748: PLUS
47749: PUSH
47750: LD_INT 0
47752: PUSH
47753: EMPTY
47754: LIST
47755: LIST
47756: LIST
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: ST_TO_ADDR
// end ; end ;
47765: GO 47768
47767: POP
// result := list ;
47768: LD_ADDR_VAR 0 4
47772: PUSH
47773: LD_VAR 0 5
47777: ST_TO_ADDR
// end ;
47778: LD_VAR 0 4
47782: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
47783: LD_INT 0
47785: PPUSH
47786: PPUSH
47787: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
47788: LD_VAR 0 1
47792: NOT
47793: IFTRUE 47821
47795: PUSH
47796: LD_VAR 0 2
47800: PUSH
47801: LD_INT 1
47803: PUSH
47804: LD_INT 2
47806: PUSH
47807: LD_INT 3
47809: PUSH
47810: LD_INT 4
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: LIST
47817: LIST
47818: IN
47819: NOT
47820: OR
47821: IFFALSE 47825
// exit ;
47823: GO 47908
// tmp := [ ] ;
47825: LD_ADDR_VAR 0 5
47829: PUSH
47830: EMPTY
47831: ST_TO_ADDR
// for i in units do
47832: LD_ADDR_VAR 0 4
47836: PUSH
47837: LD_VAR 0 1
47841: PUSH
47842: FOR_IN
47843: IFFALSE 47877
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
47845: LD_ADDR_VAR 0 5
47849: PUSH
47850: LD_VAR 0 5
47854: PPUSH
47855: LD_VAR 0 4
47859: PPUSH
47860: LD_VAR 0 2
47864: PPUSH
47865: CALL_OW 259
47869: PPUSH
47870: CALL 49303 0 2
47874: ST_TO_ADDR
47875: GO 47842
47877: POP
47878: POP
// if not tmp then
47879: LD_VAR 0 5
47883: NOT
47884: IFFALSE 47888
// exit ;
47886: GO 47908
// result := SortListByListDesc ( units , tmp ) ;
47888: LD_ADDR_VAR 0 3
47892: PUSH
47893: LD_VAR 0 1
47897: PPUSH
47898: LD_VAR 0 5
47902: PPUSH
47903: CALL_OW 77
47907: ST_TO_ADDR
// end ;
47908: LD_VAR 0 3
47912: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
47913: LD_INT 0
47915: PPUSH
47916: PPUSH
47917: PPUSH
// result := false ;
47918: LD_ADDR_VAR 0 3
47922: PUSH
47923: LD_INT 0
47925: ST_TO_ADDR
// if not building then
47926: LD_VAR 0 2
47930: NOT
47931: IFFALSE 47935
// exit ;
47933: GO 48079
// x := GetX ( building ) ;
47935: LD_ADDR_VAR 0 4
47939: PUSH
47940: LD_VAR 0 2
47944: PPUSH
47945: CALL_OW 250
47949: ST_TO_ADDR
// y := GetY ( building ) ;
47950: LD_ADDR_VAR 0 5
47954: PUSH
47955: LD_VAR 0 2
47959: PPUSH
47960: CALL_OW 251
47964: ST_TO_ADDR
// if not x or not y then
47965: LD_VAR 0 4
47969: NOT
47970: IFTRUE 47979
47972: PUSH
47973: LD_VAR 0 5
47977: NOT
47978: OR
47979: IFFALSE 47983
// exit ;
47981: GO 48079
// if GetTaskList ( unit ) then
47983: LD_VAR 0 1
47987: PPUSH
47988: CALL_OW 437
47992: IFFALSE 48079
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
47994: LD_STRING e
47996: PUSH
47997: LD_VAR 0 1
48001: PPUSH
48002: CALL_OW 437
48006: PUSH
48007: LD_INT 1
48009: ARRAY
48010: PUSH
48011: LD_INT 1
48013: ARRAY
48014: EQUAL
48015: IFFALSE 48042
48017: PUSH
48018: LD_VAR 0 4
48022: PUSH
48023: LD_VAR 0 1
48027: PPUSH
48028: CALL_OW 437
48032: PUSH
48033: LD_INT 1
48035: ARRAY
48036: PUSH
48037: LD_INT 2
48039: ARRAY
48040: EQUAL
48041: AND
48042: IFFALSE 48069
48044: PUSH
48045: LD_VAR 0 5
48049: PUSH
48050: LD_VAR 0 1
48054: PPUSH
48055: CALL_OW 437
48059: PUSH
48060: LD_INT 1
48062: ARRAY
48063: PUSH
48064: LD_INT 3
48066: ARRAY
48067: EQUAL
48068: AND
48069: IFFALSE 48079
// result := true end ;
48071: LD_ADDR_VAR 0 3
48075: PUSH
48076: LD_INT 1
48078: ST_TO_ADDR
// end ;
48079: LD_VAR 0 3
48083: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
48084: LD_INT 0
48086: PPUSH
// result := false ;
48087: LD_ADDR_VAR 0 4
48091: PUSH
48092: LD_INT 0
48094: ST_TO_ADDR
// if GetTaskList ( unit ) then
48095: LD_VAR 0 1
48099: PPUSH
48100: CALL_OW 437
48104: IFFALSE 48191
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48106: LD_STRING M
48108: PUSH
48109: LD_VAR 0 1
48113: PPUSH
48114: CALL_OW 437
48118: PUSH
48119: LD_INT 1
48121: ARRAY
48122: PUSH
48123: LD_INT 1
48125: ARRAY
48126: EQUAL
48127: IFFALSE 48154
48129: PUSH
48130: LD_VAR 0 2
48134: PUSH
48135: LD_VAR 0 1
48139: PPUSH
48140: CALL_OW 437
48144: PUSH
48145: LD_INT 1
48147: ARRAY
48148: PUSH
48149: LD_INT 2
48151: ARRAY
48152: EQUAL
48153: AND
48154: IFFALSE 48181
48156: PUSH
48157: LD_VAR 0 3
48161: PUSH
48162: LD_VAR 0 1
48166: PPUSH
48167: CALL_OW 437
48171: PUSH
48172: LD_INT 1
48174: ARRAY
48175: PUSH
48176: LD_INT 3
48178: ARRAY
48179: EQUAL
48180: AND
48181: IFFALSE 48191
// result := true ;
48183: LD_ADDR_VAR 0 4
48187: PUSH
48188: LD_INT 1
48190: ST_TO_ADDR
// end ; end ;
48191: LD_VAR 0 4
48195: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
48196: LD_INT 0
48198: PPUSH
48199: PPUSH
48200: PPUSH
48201: PPUSH
// if not unit or not area then
48202: LD_VAR 0 1
48206: NOT
48207: IFTRUE 48216
48209: PUSH
48210: LD_VAR 0 2
48214: NOT
48215: OR
48216: IFFALSE 48220
// exit ;
48218: GO 48396
// tmp := AreaToList ( area , i ) ;
48220: LD_ADDR_VAR 0 6
48224: PUSH
48225: LD_VAR 0 2
48229: PPUSH
48230: LD_VAR 0 5
48234: PPUSH
48235: CALL_OW 517
48239: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
48240: LD_ADDR_VAR 0 5
48244: PUSH
48245: DOUBLE
48246: LD_INT 1
48248: DEC
48249: ST_TO_ADDR
48250: LD_VAR 0 6
48254: PUSH
48255: LD_INT 1
48257: ARRAY
48258: PUSH
48259: FOR_TO
48260: IFFALSE 48394
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
48262: LD_ADDR_VAR 0 7
48266: PUSH
48267: LD_VAR 0 6
48271: PUSH
48272: LD_INT 1
48274: ARRAY
48275: PUSH
48276: LD_VAR 0 5
48280: ARRAY
48281: PUSH
48282: LD_VAR 0 6
48286: PUSH
48287: LD_INT 2
48289: ARRAY
48290: PUSH
48291: LD_VAR 0 5
48295: ARRAY
48296: PUSH
48297: EMPTY
48298: LIST
48299: LIST
48300: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
48301: LD_INT 92
48303: PUSH
48304: LD_VAR 0 7
48308: PUSH
48309: LD_INT 1
48311: ARRAY
48312: PUSH
48313: LD_VAR 0 7
48317: PUSH
48318: LD_INT 2
48320: ARRAY
48321: PUSH
48322: LD_INT 2
48324: PUSH
48325: EMPTY
48326: LIST
48327: LIST
48328: LIST
48329: LIST
48330: PPUSH
48331: CALL_OW 69
48335: PUSH
48336: LD_INT 0
48338: EQUAL
48339: IFFALSE 48392
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
48341: LD_VAR 0 1
48345: PPUSH
48346: LD_VAR 0 7
48350: PUSH
48351: LD_INT 1
48353: ARRAY
48354: PPUSH
48355: LD_VAR 0 7
48359: PUSH
48360: LD_INT 2
48362: ARRAY
48363: PPUSH
48364: LD_VAR 0 3
48368: PPUSH
48369: CALL_OW 48
// result := IsPlaced ( unit ) ;
48373: LD_ADDR_VAR 0 4
48377: PUSH
48378: LD_VAR 0 1
48382: PPUSH
48383: CALL_OW 305
48387: ST_TO_ADDR
// exit ;
48388: POP
48389: POP
48390: GO 48396
// end ; end ;
48392: GO 48259
48394: POP
48395: POP
// end ;
48396: LD_VAR 0 4
48400: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
48401: LD_INT 0
48403: PPUSH
48404: PPUSH
48405: PPUSH
// if not side or side > 8 then
48406: LD_VAR 0 1
48410: NOT
48411: IFTRUE 48423
48413: PUSH
48414: LD_VAR 0 1
48418: PUSH
48419: LD_INT 8
48421: GREATER
48422: OR
48423: IFFALSE 48427
// exit ;
48425: GO 48614
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
48427: LD_ADDR_VAR 0 4
48431: PUSH
48432: LD_INT 22
48434: PUSH
48435: LD_VAR 0 1
48439: PUSH
48440: EMPTY
48441: LIST
48442: LIST
48443: PUSH
48444: LD_INT 21
48446: PUSH
48447: LD_INT 3
48449: PUSH
48450: EMPTY
48451: LIST
48452: LIST
48453: PUSH
48454: EMPTY
48455: LIST
48456: LIST
48457: PPUSH
48458: CALL_OW 69
48462: ST_TO_ADDR
// if not tmp then
48463: LD_VAR 0 4
48467: NOT
48468: IFFALSE 48472
// exit ;
48470: GO 48614
// enable_addtolog := true ;
48472: LD_ADDR_OWVAR 81
48476: PUSH
48477: LD_INT 1
48479: ST_TO_ADDR
// AddToLog ( [ ) ;
48480: LD_STRING [
48482: PPUSH
48483: CALL_OW 561
// for i in tmp do
48487: LD_ADDR_VAR 0 3
48491: PUSH
48492: LD_VAR 0 4
48496: PUSH
48497: FOR_IN
48498: IFFALSE 48605
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
48500: LD_STRING [
48502: PUSH
48503: LD_VAR 0 3
48507: PPUSH
48508: CALL_OW 266
48512: STR
48513: PUSH
48514: LD_STRING , 
48516: STR
48517: PUSH
48518: LD_VAR 0 3
48522: PPUSH
48523: CALL_OW 250
48527: STR
48528: PUSH
48529: LD_STRING , 
48531: STR
48532: PUSH
48533: LD_VAR 0 3
48537: PPUSH
48538: CALL_OW 251
48542: STR
48543: PUSH
48544: LD_STRING , 
48546: STR
48547: PUSH
48548: LD_VAR 0 3
48552: PPUSH
48553: CALL_OW 254
48557: STR
48558: PUSH
48559: LD_STRING , 
48561: STR
48562: PUSH
48563: LD_VAR 0 3
48567: PPUSH
48568: LD_INT 1
48570: PPUSH
48571: CALL_OW 268
48575: STR
48576: PUSH
48577: LD_STRING , 
48579: STR
48580: PUSH
48581: LD_VAR 0 3
48585: PPUSH
48586: LD_INT 2
48588: PPUSH
48589: CALL_OW 268
48593: STR
48594: PUSH
48595: LD_STRING ],
48597: STR
48598: PPUSH
48599: CALL_OW 561
// end ;
48603: GO 48497
48605: POP
48606: POP
// AddToLog ( ]; ) ;
48607: LD_STRING ];
48609: PPUSH
48610: CALL_OW 561
// end ;
48614: LD_VAR 0 2
48618: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
48619: LD_INT 0
48621: PPUSH
48622: PPUSH
48623: PPUSH
48624: PPUSH
48625: PPUSH
// if not area or not rate or not max then
48626: LD_VAR 0 1
48630: NOT
48631: IFTRUE 48640
48633: PUSH
48634: LD_VAR 0 2
48638: NOT
48639: OR
48640: IFTRUE 48649
48642: PUSH
48643: LD_VAR 0 4
48647: NOT
48648: OR
48649: IFFALSE 48653
// exit ;
48651: GO 48842
// while 1 do
48653: LD_INT 1
48655: IFFALSE 48842
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
48657: LD_ADDR_VAR 0 9
48661: PUSH
48662: LD_VAR 0 1
48666: PPUSH
48667: LD_INT 1
48669: PPUSH
48670: CALL_OW 287
48674: PUSH
48675: LD_INT 10
48677: MUL
48678: ST_TO_ADDR
// r := rate / 10 ;
48679: LD_ADDR_VAR 0 7
48683: PUSH
48684: LD_VAR 0 2
48688: PUSH
48689: LD_INT 10
48691: DIVREAL
48692: ST_TO_ADDR
// time := 1 1$00 ;
48693: LD_ADDR_VAR 0 8
48697: PUSH
48698: LD_INT 2100
48700: ST_TO_ADDR
// if amount < min then
48701: LD_VAR 0 9
48705: PUSH
48706: LD_VAR 0 3
48710: LESS
48711: IFFALSE 48729
// r := r * 2 else
48713: LD_ADDR_VAR 0 7
48717: PUSH
48718: LD_VAR 0 7
48722: PUSH
48723: LD_INT 2
48725: MUL
48726: ST_TO_ADDR
48727: GO 48755
// if amount > max then
48729: LD_VAR 0 9
48733: PUSH
48734: LD_VAR 0 4
48738: GREATER
48739: IFFALSE 48755
// r := r / 2 ;
48741: LD_ADDR_VAR 0 7
48745: PUSH
48746: LD_VAR 0 7
48750: PUSH
48751: LD_INT 2
48753: DIVREAL
48754: ST_TO_ADDR
// time := time / r ;
48755: LD_ADDR_VAR 0 8
48759: PUSH
48760: LD_VAR 0 8
48764: PUSH
48765: LD_VAR 0 7
48769: DIVREAL
48770: ST_TO_ADDR
// if time < 0 then
48771: LD_VAR 0 8
48775: PUSH
48776: LD_INT 0
48778: LESS
48779: IFFALSE 48796
// time := time * - 1 ;
48781: LD_ADDR_VAR 0 8
48785: PUSH
48786: LD_VAR 0 8
48790: PUSH
48791: LD_INT 1
48793: NEG
48794: MUL
48795: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
48796: LD_VAR 0 8
48800: PUSH
48801: LD_INT 35
48803: PPUSH
48804: LD_INT 875
48806: PPUSH
48807: CALL_OW 12
48811: PLUS
48812: PPUSH
48813: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
48817: LD_INT 1
48819: PPUSH
48820: LD_INT 5
48822: PPUSH
48823: CALL_OW 12
48827: PPUSH
48828: LD_VAR 0 1
48832: PPUSH
48833: LD_INT 1
48835: PPUSH
48836: CALL_OW 55
// end ;
48840: GO 48653
// end ;
48842: LD_VAR 0 5
48846: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
48847: LD_INT 0
48849: PPUSH
48850: PPUSH
48851: PPUSH
48852: PPUSH
48853: PPUSH
48854: PPUSH
48855: PPUSH
48856: PPUSH
// if not turrets or not factories then
48857: LD_VAR 0 1
48861: NOT
48862: IFTRUE 48871
48864: PUSH
48865: LD_VAR 0 2
48869: NOT
48870: OR
48871: IFFALSE 48875
// exit ;
48873: GO 49182
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
48875: LD_ADDR_VAR 0 10
48879: PUSH
48880: LD_INT 5
48882: PUSH
48883: LD_INT 6
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 2
48892: PUSH
48893: LD_INT 4
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 3
48902: PUSH
48903: LD_INT 5
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: PUSH
48915: LD_INT 24
48917: PUSH
48918: LD_INT 25
48920: PUSH
48921: EMPTY
48922: LIST
48923: LIST
48924: PUSH
48925: LD_INT 23
48927: PUSH
48928: LD_INT 27
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: PUSH
48939: LD_INT 42
48941: PUSH
48942: LD_INT 43
48944: PUSH
48945: EMPTY
48946: LIST
48947: LIST
48948: PUSH
48949: LD_INT 44
48951: PUSH
48952: LD_INT 46
48954: PUSH
48955: EMPTY
48956: LIST
48957: LIST
48958: PUSH
48959: LD_INT 45
48961: PUSH
48962: LD_INT 47
48964: PUSH
48965: EMPTY
48966: LIST
48967: LIST
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: LIST
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: LIST
48978: ST_TO_ADDR
// result := [ ] ;
48979: LD_ADDR_VAR 0 3
48983: PUSH
48984: EMPTY
48985: ST_TO_ADDR
// for i in turrets do
48986: LD_ADDR_VAR 0 4
48990: PUSH
48991: LD_VAR 0 1
48995: PUSH
48996: FOR_IN
48997: IFFALSE 49180
// begin nat := GetNation ( i ) ;
48999: LD_ADDR_VAR 0 7
49003: PUSH
49004: LD_VAR 0 4
49008: PPUSH
49009: CALL_OW 248
49013: ST_TO_ADDR
// weapon := 0 ;
49014: LD_ADDR_VAR 0 8
49018: PUSH
49019: LD_INT 0
49021: ST_TO_ADDR
// if not nat then
49022: LD_VAR 0 7
49026: NOT
49027: IFFALSE 49031
// continue ;
49029: GO 48996
// for j in list [ nat ] do
49031: LD_ADDR_VAR 0 5
49035: PUSH
49036: LD_VAR 0 10
49040: PUSH
49041: LD_VAR 0 7
49045: ARRAY
49046: PUSH
49047: FOR_IN
49048: IFFALSE 49089
// if GetBWeapon ( i ) = j [ 1 ] then
49050: LD_VAR 0 4
49054: PPUSH
49055: CALL_OW 269
49059: PUSH
49060: LD_VAR 0 5
49064: PUSH
49065: LD_INT 1
49067: ARRAY
49068: EQUAL
49069: IFFALSE 49087
// begin weapon := j [ 2 ] ;
49071: LD_ADDR_VAR 0 8
49075: PUSH
49076: LD_VAR 0 5
49080: PUSH
49081: LD_INT 2
49083: ARRAY
49084: ST_TO_ADDR
// break ;
49085: GO 49089
// end ;
49087: GO 49047
49089: POP
49090: POP
// if not weapon then
49091: LD_VAR 0 8
49095: NOT
49096: IFFALSE 49100
// continue ;
49098: GO 48996
// for k in factories do
49100: LD_ADDR_VAR 0 6
49104: PUSH
49105: LD_VAR 0 2
49109: PUSH
49110: FOR_IN
49111: IFFALSE 49176
// begin weapons := AvailableWeaponList ( k ) ;
49113: LD_ADDR_VAR 0 9
49117: PUSH
49118: LD_VAR 0 6
49122: PPUSH
49123: CALL_OW 478
49127: ST_TO_ADDR
// if not weapons then
49128: LD_VAR 0 9
49132: NOT
49133: IFFALSE 49137
// continue ;
49135: GO 49110
// if weapon in weapons then
49137: LD_VAR 0 8
49141: PUSH
49142: LD_VAR 0 9
49146: IN
49147: IFFALSE 49174
// begin result := [ i , weapon ] ;
49149: LD_ADDR_VAR 0 3
49153: PUSH
49154: LD_VAR 0 4
49158: PUSH
49159: LD_VAR 0 8
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: ST_TO_ADDR
// exit ;
49168: POP
49169: POP
49170: POP
49171: POP
49172: GO 49182
// end ; end ;
49174: GO 49110
49176: POP
49177: POP
// end ;
49178: GO 48996
49180: POP
49181: POP
// end ;
49182: LD_VAR 0 3
49186: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
49187: LD_INT 0
49189: PPUSH
// if not side or side > 8 then
49190: LD_VAR 0 3
49194: NOT
49195: IFTRUE 49207
49197: PUSH
49198: LD_VAR 0 3
49202: PUSH
49203: LD_INT 8
49205: GREATER
49206: OR
49207: IFFALSE 49211
// exit ;
49209: GO 49270
// if not range then
49211: LD_VAR 0 4
49215: NOT
49216: IFFALSE 49227
// range := - 12 ;
49218: LD_ADDR_VAR 0 4
49222: PUSH
49223: LD_INT 12
49225: NEG
49226: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
49227: LD_VAR 0 1
49231: PPUSH
49232: LD_VAR 0 2
49236: PPUSH
49237: LD_VAR 0 3
49241: PPUSH
49242: LD_VAR 0 4
49246: PPUSH
49247: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
49251: LD_VAR 0 1
49255: PPUSH
49256: LD_VAR 0 2
49260: PPUSH
49261: LD_VAR 0 3
49265: PPUSH
49266: CALL_OW 331
// end ;
49270: LD_VAR 0 5
49274: RET
// export function Video ( mode ) ; begin
49275: LD_INT 0
49277: PPUSH
// ingame_video = mode ;
49278: LD_ADDR_OWVAR 52
49282: PUSH
49283: LD_VAR 0 1
49287: ST_TO_ADDR
// interface_hidden = mode ;
49288: LD_ADDR_OWVAR 54
49292: PUSH
49293: LD_VAR 0 1
49297: ST_TO_ADDR
// end ;
49298: LD_VAR 0 2
49302: RET
// export function Join ( array , element ) ; begin
49303: LD_INT 0
49305: PPUSH
// result := Replace ( array , array + 1 , element ) ;
49306: LD_ADDR_VAR 0 3
49310: PUSH
49311: LD_VAR 0 1
49315: PPUSH
49316: LD_VAR 0 1
49320: PUSH
49321: LD_INT 1
49323: PLUS
49324: PPUSH
49325: LD_VAR 0 2
49329: PPUSH
49330: CALL_OW 1
49334: ST_TO_ADDR
// end ;
49335: LD_VAR 0 3
49339: RET
// export function JoinUnion ( array , element ) ; begin
49340: LD_INT 0
49342: PPUSH
// result := array union element ;
49343: LD_ADDR_VAR 0 3
49347: PUSH
49348: LD_VAR 0 1
49352: PUSH
49353: LD_VAR 0 2
49357: UNION
49358: ST_TO_ADDR
// end ;
49359: LD_VAR 0 3
49363: RET
// export function GetBehemoths ( side ) ; begin
49364: LD_INT 0
49366: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
49367: LD_ADDR_VAR 0 2
49371: PUSH
49372: LD_INT 22
49374: PUSH
49375: LD_VAR 0 1
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: PUSH
49384: LD_INT 31
49386: PUSH
49387: LD_INT 25
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: EMPTY
49395: LIST
49396: LIST
49397: PPUSH
49398: CALL_OW 69
49402: ST_TO_ADDR
// end ;
49403: LD_VAR 0 2
49407: RET
// export function Shuffle ( array ) ; var i , index ; begin
49408: LD_INT 0
49410: PPUSH
49411: PPUSH
49412: PPUSH
// result := [ ] ;
49413: LD_ADDR_VAR 0 2
49417: PUSH
49418: EMPTY
49419: ST_TO_ADDR
// if not array then
49420: LD_VAR 0 1
49424: NOT
49425: IFFALSE 49429
// exit ;
49427: GO 49528
// Randomize ;
49429: CALL_OW 10
// for i = array downto 1 do
49433: LD_ADDR_VAR 0 3
49437: PUSH
49438: DOUBLE
49439: LD_VAR 0 1
49443: INC
49444: ST_TO_ADDR
49445: LD_INT 1
49447: PUSH
49448: FOR_DOWNTO
49449: IFFALSE 49526
// begin index := rand ( 1 , array ) ;
49451: LD_ADDR_VAR 0 4
49455: PUSH
49456: LD_INT 1
49458: PPUSH
49459: LD_VAR 0 1
49463: PPUSH
49464: CALL_OW 12
49468: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
49469: LD_ADDR_VAR 0 2
49473: PUSH
49474: LD_VAR 0 2
49478: PPUSH
49479: LD_VAR 0 2
49483: PUSH
49484: LD_INT 1
49486: PLUS
49487: PPUSH
49488: LD_VAR 0 1
49492: PUSH
49493: LD_VAR 0 4
49497: ARRAY
49498: PPUSH
49499: CALL_OW 2
49503: ST_TO_ADDR
// array := Delete ( array , index ) ;
49504: LD_ADDR_VAR 0 1
49508: PUSH
49509: LD_VAR 0 1
49513: PPUSH
49514: LD_VAR 0 4
49518: PPUSH
49519: CALL_OW 3
49523: ST_TO_ADDR
// end ;
49524: GO 49448
49526: POP
49527: POP
// end ;
49528: LD_VAR 0 2
49532: RET
// export function GetBaseMaterials ( base ) ; begin
49533: LD_INT 0
49535: PPUSH
// result := [ 0 , 0 , 0 ] ;
49536: LD_ADDR_VAR 0 2
49540: PUSH
49541: LD_INT 0
49543: PUSH
49544: LD_INT 0
49546: PUSH
49547: LD_INT 0
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: LIST
49554: ST_TO_ADDR
// if not base then
49555: LD_VAR 0 1
49559: NOT
49560: IFFALSE 49564
// exit ;
49562: GO 49613
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
49564: LD_ADDR_VAR 0 2
49568: PUSH
49569: LD_VAR 0 1
49573: PPUSH
49574: LD_INT 1
49576: PPUSH
49577: CALL_OW 275
49581: PUSH
49582: LD_VAR 0 1
49586: PPUSH
49587: LD_INT 2
49589: PPUSH
49590: CALL_OW 275
49594: PUSH
49595: LD_VAR 0 1
49599: PPUSH
49600: LD_INT 3
49602: PPUSH
49603: CALL_OW 275
49607: PUSH
49608: EMPTY
49609: LIST
49610: LIST
49611: LIST
49612: ST_TO_ADDR
// end ;
49613: LD_VAR 0 2
49617: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
49618: LD_INT 0
49620: PPUSH
49621: PPUSH
// result := array ;
49622: LD_ADDR_VAR 0 3
49626: PUSH
49627: LD_VAR 0 1
49631: ST_TO_ADDR
// if size >= result then
49632: LD_VAR 0 2
49636: PUSH
49637: LD_VAR 0 3
49641: GREATEREQUAL
49642: IFFALSE 49646
// exit ;
49644: GO 49696
// if size then
49646: LD_VAR 0 2
49650: IFFALSE 49696
// for i := array downto size do
49652: LD_ADDR_VAR 0 4
49656: PUSH
49657: DOUBLE
49658: LD_VAR 0 1
49662: INC
49663: ST_TO_ADDR
49664: LD_VAR 0 2
49668: PUSH
49669: FOR_DOWNTO
49670: IFFALSE 49694
// result := Delete ( result , result ) ;
49672: LD_ADDR_VAR 0 3
49676: PUSH
49677: LD_VAR 0 3
49681: PPUSH
49682: LD_VAR 0 3
49686: PPUSH
49687: CALL_OW 3
49691: ST_TO_ADDR
49692: GO 49669
49694: POP
49695: POP
// end ;
49696: LD_VAR 0 3
49700: RET
// export function ComExit ( unit ) ; var tmp ; begin
49701: LD_INT 0
49703: PPUSH
49704: PPUSH
// if not IsInUnit ( unit ) then
49705: LD_VAR 0 1
49709: PPUSH
49710: CALL_OW 310
49714: NOT
49715: IFFALSE 49719
// exit ;
49717: GO 49779
// tmp := IsInUnit ( unit ) ;
49719: LD_ADDR_VAR 0 3
49723: PUSH
49724: LD_VAR 0 1
49728: PPUSH
49729: CALL_OW 310
49733: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
49734: LD_VAR 0 3
49738: PPUSH
49739: CALL_OW 247
49743: PUSH
49744: LD_INT 2
49746: EQUAL
49747: IFFALSE 49760
// ComExitVehicle ( unit ) else
49749: LD_VAR 0 1
49753: PPUSH
49754: CALL_OW 121
49758: GO 49769
// ComExitBuilding ( unit ) ;
49760: LD_VAR 0 1
49764: PPUSH
49765: CALL_OW 122
// result := tmp ;
49769: LD_ADDR_VAR 0 2
49773: PUSH
49774: LD_VAR 0 3
49778: ST_TO_ADDR
// end ;
49779: LD_VAR 0 2
49783: RET
// export function ComExitAll ( units ) ; var i ; begin
49784: LD_INT 0
49786: PPUSH
49787: PPUSH
// if not units then
49788: LD_VAR 0 1
49792: NOT
49793: IFFALSE 49797
// exit ;
49795: GO 49823
// for i in units do
49797: LD_ADDR_VAR 0 3
49801: PUSH
49802: LD_VAR 0 1
49806: PUSH
49807: FOR_IN
49808: IFFALSE 49821
// ComExit ( i ) ;
49810: LD_VAR 0 3
49814: PPUSH
49815: CALL 49701 0 1
49819: GO 49807
49821: POP
49822: POP
// end ;
49823: LD_VAR 0 2
49827: RET
// export function ResetHc ; begin
49828: LD_INT 0
49830: PPUSH
// InitHc ;
49831: CALL_OW 19
// hc_importance := 0 ;
49835: LD_ADDR_OWVAR 32
49839: PUSH
49840: LD_INT 0
49842: ST_TO_ADDR
// end ;
49843: LD_VAR 0 1
49847: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
49848: LD_INT 0
49850: PPUSH
49851: PPUSH
49852: PPUSH
// _x := ( x1 + x2 ) div 2 ;
49853: LD_ADDR_VAR 0 6
49857: PUSH
49858: LD_VAR 0 1
49862: PUSH
49863: LD_VAR 0 3
49867: PLUS
49868: PUSH
49869: LD_INT 2
49871: DIV
49872: ST_TO_ADDR
// if _x < 0 then
49873: LD_VAR 0 6
49877: PUSH
49878: LD_INT 0
49880: LESS
49881: IFFALSE 49898
// _x := _x * - 1 ;
49883: LD_ADDR_VAR 0 6
49887: PUSH
49888: LD_VAR 0 6
49892: PUSH
49893: LD_INT 1
49895: NEG
49896: MUL
49897: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
49898: LD_ADDR_VAR 0 7
49902: PUSH
49903: LD_VAR 0 2
49907: PUSH
49908: LD_VAR 0 4
49912: PLUS
49913: PUSH
49914: LD_INT 2
49916: DIV
49917: ST_TO_ADDR
// if _y < 0 then
49918: LD_VAR 0 7
49922: PUSH
49923: LD_INT 0
49925: LESS
49926: IFFALSE 49943
// _y := _y * - 1 ;
49928: LD_ADDR_VAR 0 7
49932: PUSH
49933: LD_VAR 0 7
49937: PUSH
49938: LD_INT 1
49940: NEG
49941: MUL
49942: ST_TO_ADDR
// result := [ _x , _y ] ;
49943: LD_ADDR_VAR 0 5
49947: PUSH
49948: LD_VAR 0 6
49952: PUSH
49953: LD_VAR 0 7
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: ST_TO_ADDR
// end ;
49962: LD_VAR 0 5
49966: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
49967: LD_INT 0
49969: PPUSH
49970: PPUSH
49971: PPUSH
49972: PPUSH
// task := GetTaskList ( unit ) ;
49973: LD_ADDR_VAR 0 7
49977: PUSH
49978: LD_VAR 0 1
49982: PPUSH
49983: CALL_OW 437
49987: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
49988: LD_VAR 0 7
49992: NOT
49993: IFFALSE 50012
49995: PUSH
49996: LD_VAR 0 1
50000: PPUSH
50001: LD_VAR 0 2
50005: PPUSH
50006: CALL_OW 308
50010: NOT
50011: AND
50012: IFFALSE 50016
// exit ;
50014: GO 50134
// if IsInArea ( unit , area ) then
50016: LD_VAR 0 1
50020: PPUSH
50021: LD_VAR 0 2
50025: PPUSH
50026: CALL_OW 308
50030: IFFALSE 50048
// begin ComMoveToArea ( unit , goAway ) ;
50032: LD_VAR 0 1
50036: PPUSH
50037: LD_VAR 0 3
50041: PPUSH
50042: CALL_OW 113
// exit ;
50046: GO 50134
// end ; if task [ 1 ] [ 1 ] <> M then
50048: LD_VAR 0 7
50052: PUSH
50053: LD_INT 1
50055: ARRAY
50056: PUSH
50057: LD_INT 1
50059: ARRAY
50060: PUSH
50061: LD_STRING M
50063: NONEQUAL
50064: IFFALSE 50068
// exit ;
50066: GO 50134
// x := task [ 1 ] [ 2 ] ;
50068: LD_ADDR_VAR 0 5
50072: PUSH
50073: LD_VAR 0 7
50077: PUSH
50078: LD_INT 1
50080: ARRAY
50081: PUSH
50082: LD_INT 2
50084: ARRAY
50085: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
50086: LD_ADDR_VAR 0 6
50090: PUSH
50091: LD_VAR 0 7
50095: PUSH
50096: LD_INT 1
50098: ARRAY
50099: PUSH
50100: LD_INT 3
50102: ARRAY
50103: ST_TO_ADDR
// if InArea ( x , y , area ) then
50104: LD_VAR 0 5
50108: PPUSH
50109: LD_VAR 0 6
50113: PPUSH
50114: LD_VAR 0 2
50118: PPUSH
50119: CALL_OW 309
50123: IFFALSE 50134
// ComStop ( unit ) ;
50125: LD_VAR 0 1
50129: PPUSH
50130: CALL_OW 141
// end ;
50134: LD_VAR 0 4
50138: RET
// export function Abs ( value ) ; begin
50139: LD_INT 0
50141: PPUSH
// result := value ;
50142: LD_ADDR_VAR 0 2
50146: PUSH
50147: LD_VAR 0 1
50151: ST_TO_ADDR
// if value < 0 then
50152: LD_VAR 0 1
50156: PUSH
50157: LD_INT 0
50159: LESS
50160: IFFALSE 50177
// result := value * - 1 ;
50162: LD_ADDR_VAR 0 2
50166: PUSH
50167: LD_VAR 0 1
50171: PUSH
50172: LD_INT 1
50174: NEG
50175: MUL
50176: ST_TO_ADDR
// end ;
50177: LD_VAR 0 2
50181: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
50182: LD_INT 0
50184: PPUSH
50185: PPUSH
50186: PPUSH
50187: PPUSH
50188: PPUSH
50189: PPUSH
50190: PPUSH
50191: PPUSH
// if not unit or not building then
50192: LD_VAR 0 1
50196: NOT
50197: IFTRUE 50206
50199: PUSH
50200: LD_VAR 0 2
50204: NOT
50205: OR
50206: IFFALSE 50210
// exit ;
50208: GO 50438
// x := GetX ( building ) ;
50210: LD_ADDR_VAR 0 4
50214: PUSH
50215: LD_VAR 0 2
50219: PPUSH
50220: CALL_OW 250
50224: ST_TO_ADDR
// y := GetY ( building ) ;
50225: LD_ADDR_VAR 0 6
50229: PUSH
50230: LD_VAR 0 2
50234: PPUSH
50235: CALL_OW 251
50239: ST_TO_ADDR
// d := GetDir ( building ) ;
50240: LD_ADDR_VAR 0 8
50244: PUSH
50245: LD_VAR 0 2
50249: PPUSH
50250: CALL_OW 254
50254: ST_TO_ADDR
// r := 4 ;
50255: LD_ADDR_VAR 0 9
50259: PUSH
50260: LD_INT 4
50262: ST_TO_ADDR
// for i := 1 to 5 do
50263: LD_ADDR_VAR 0 10
50267: PUSH
50268: DOUBLE
50269: LD_INT 1
50271: DEC
50272: ST_TO_ADDR
50273: LD_INT 5
50275: PUSH
50276: FOR_TO
50277: IFFALSE 50436
// begin _x := ShiftX ( x , d , r + i ) ;
50279: LD_ADDR_VAR 0 5
50283: PUSH
50284: LD_VAR 0 4
50288: PPUSH
50289: LD_VAR 0 8
50293: PPUSH
50294: LD_VAR 0 9
50298: PUSH
50299: LD_VAR 0 10
50303: PLUS
50304: PPUSH
50305: CALL_OW 272
50309: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
50310: LD_ADDR_VAR 0 7
50314: PUSH
50315: LD_VAR 0 6
50319: PPUSH
50320: LD_VAR 0 8
50324: PPUSH
50325: LD_VAR 0 9
50329: PUSH
50330: LD_VAR 0 10
50334: PLUS
50335: PPUSH
50336: CALL_OW 273
50340: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
50341: LD_VAR 0 5
50345: PPUSH
50346: LD_VAR 0 7
50350: PPUSH
50351: CALL_OW 488
50355: IFFALSE 50390
50357: PUSH
50358: LD_VAR 0 5
50362: PPUSH
50363: LD_VAR 0 7
50367: PPUSH
50368: CALL_OW 428
50372: PPUSH
50373: CALL_OW 247
50377: PUSH
50378: LD_INT 3
50380: PUSH
50381: LD_INT 2
50383: PUSH
50384: EMPTY
50385: LIST
50386: LIST
50387: IN
50388: NOT
50389: AND
50390: IFFALSE 50434
// begin ComMoveXY ( unit , _x , _y ) ;
50392: LD_VAR 0 1
50396: PPUSH
50397: LD_VAR 0 5
50401: PPUSH
50402: LD_VAR 0 7
50406: PPUSH
50407: CALL_OW 111
// result := [ _x , _y ] ;
50411: LD_ADDR_VAR 0 3
50415: PUSH
50416: LD_VAR 0 5
50420: PUSH
50421: LD_VAR 0 7
50425: PUSH
50426: EMPTY
50427: LIST
50428: LIST
50429: ST_TO_ADDR
// exit ;
50430: POP
50431: POP
50432: GO 50438
// end ; end ;
50434: GO 50276
50436: POP
50437: POP
// end ;
50438: LD_VAR 0 3
50442: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
50443: LD_INT 0
50445: PPUSH
50446: PPUSH
50447: PPUSH
// result := 0 ;
50448: LD_ADDR_VAR 0 3
50452: PUSH
50453: LD_INT 0
50455: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
50456: LD_VAR 0 1
50460: PUSH
50461: LD_INT 0
50463: LESS
50464: IFTRUE 50476
50466: PUSH
50467: LD_VAR 0 1
50471: PUSH
50472: LD_INT 8
50474: GREATER
50475: OR
50476: IFTRUE 50488
50478: PUSH
50479: LD_VAR 0 2
50483: PUSH
50484: LD_INT 0
50486: LESS
50487: OR
50488: IFTRUE 50500
50490: PUSH
50491: LD_VAR 0 2
50495: PUSH
50496: LD_INT 8
50498: GREATER
50499: OR
50500: IFFALSE 50504
// exit ;
50502: GO 50579
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
50504: LD_ADDR_VAR 0 4
50508: PUSH
50509: LD_INT 22
50511: PUSH
50512: LD_VAR 0 2
50516: PUSH
50517: EMPTY
50518: LIST
50519: LIST
50520: PPUSH
50521: CALL_OW 69
50525: PUSH
50526: FOR_IN
50527: IFFALSE 50577
// begin un := UnitShoot ( i ) ;
50529: LD_ADDR_VAR 0 5
50533: PUSH
50534: LD_VAR 0 4
50538: PPUSH
50539: CALL_OW 504
50543: ST_TO_ADDR
// if GetSide ( un ) = side1 then
50544: LD_VAR 0 5
50548: PPUSH
50549: CALL_OW 255
50553: PUSH
50554: LD_VAR 0 1
50558: EQUAL
50559: IFFALSE 50575
// begin result := un ;
50561: LD_ADDR_VAR 0 3
50565: PUSH
50566: LD_VAR 0 5
50570: ST_TO_ADDR
// exit ;
50571: POP
50572: POP
50573: GO 50579
// end ; end ;
50575: GO 50526
50577: POP
50578: POP
// end ;
50579: LD_VAR 0 3
50583: RET
// export function GetCargoBay ( units ) ; begin
50584: LD_INT 0
50586: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
50587: LD_ADDR_VAR 0 2
50591: PUSH
50592: LD_VAR 0 1
50596: PPUSH
50597: LD_INT 2
50599: PUSH
50600: LD_INT 34
50602: PUSH
50603: LD_INT 12
50605: PUSH
50606: EMPTY
50607: LIST
50608: LIST
50609: PUSH
50610: LD_INT 34
50612: PUSH
50613: LD_INT 51
50615: PUSH
50616: EMPTY
50617: LIST
50618: LIST
50619: PUSH
50620: LD_INT 34
50622: PUSH
50623: LD_INT 32
50625: PUSH
50626: EMPTY
50627: LIST
50628: LIST
50629: PUSH
50630: LD_INT 34
50632: PUSH
50633: LD_INT 89
50635: PUSH
50636: EMPTY
50637: LIST
50638: LIST
50639: PUSH
50640: EMPTY
50641: LIST
50642: LIST
50643: LIST
50644: LIST
50645: LIST
50646: PPUSH
50647: CALL_OW 72
50651: ST_TO_ADDR
// end ;
50652: LD_VAR 0 2
50656: RET
// export function Negate ( value ) ; begin
50657: LD_INT 0
50659: PPUSH
// result := not value ;
50660: LD_ADDR_VAR 0 2
50664: PUSH
50665: LD_VAR 0 1
50669: NOT
50670: ST_TO_ADDR
// end ;
50671: LD_VAR 0 2
50675: RET
// export function Inc ( value ) ; begin
50676: LD_INT 0
50678: PPUSH
// result := value + 1 ;
50679: LD_ADDR_VAR 0 2
50683: PUSH
50684: LD_VAR 0 1
50688: PUSH
50689: LD_INT 1
50691: PLUS
50692: ST_TO_ADDR
// end ;
50693: LD_VAR 0 2
50697: RET
// export function Dec ( value ) ; begin
50698: LD_INT 0
50700: PPUSH
// result := value - 1 ;
50701: LD_ADDR_VAR 0 2
50705: PUSH
50706: LD_VAR 0 1
50710: PUSH
50711: LD_INT 1
50713: MINUS
50714: ST_TO_ADDR
// end ;
50715: LD_VAR 0 2
50719: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
50720: LD_INT 0
50722: PPUSH
50723: PPUSH
50724: PPUSH
50725: PPUSH
50726: PPUSH
50727: PPUSH
50728: PPUSH
50729: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
50730: LD_VAR 0 1
50734: PPUSH
50735: LD_VAR 0 2
50739: PPUSH
50740: CALL_OW 488
50744: NOT
50745: IFTRUE 50764
50747: PUSH
50748: LD_VAR 0 3
50752: PPUSH
50753: LD_VAR 0 4
50757: PPUSH
50758: CALL_OW 488
50762: NOT
50763: OR
50764: IFFALSE 50777
// begin result := - 1 ;
50766: LD_ADDR_VAR 0 5
50770: PUSH
50771: LD_INT 1
50773: NEG
50774: ST_TO_ADDR
// exit ;
50775: GO 51012
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
50777: LD_ADDR_VAR 0 12
50781: PUSH
50782: LD_VAR 0 1
50786: PPUSH
50787: LD_VAR 0 2
50791: PPUSH
50792: LD_VAR 0 3
50796: PPUSH
50797: LD_VAR 0 4
50801: PPUSH
50802: CALL 49848 0 4
50806: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
50807: LD_ADDR_VAR 0 11
50811: PUSH
50812: LD_VAR 0 1
50816: PPUSH
50817: LD_VAR 0 2
50821: PPUSH
50822: LD_VAR 0 12
50826: PUSH
50827: LD_INT 1
50829: ARRAY
50830: PPUSH
50831: LD_VAR 0 12
50835: PUSH
50836: LD_INT 2
50838: ARRAY
50839: PPUSH
50840: CALL_OW 298
50844: ST_TO_ADDR
// distance := 9999 ;
50845: LD_ADDR_VAR 0 10
50849: PUSH
50850: LD_INT 9999
50852: ST_TO_ADDR
// for i := 0 to 5 do
50853: LD_ADDR_VAR 0 6
50857: PUSH
50858: DOUBLE
50859: LD_INT 0
50861: DEC
50862: ST_TO_ADDR
50863: LD_INT 5
50865: PUSH
50866: FOR_TO
50867: IFFALSE 51010
// begin _x := ShiftX ( x1 , i , centerDist ) ;
50869: LD_ADDR_VAR 0 7
50873: PUSH
50874: LD_VAR 0 1
50878: PPUSH
50879: LD_VAR 0 6
50883: PPUSH
50884: LD_VAR 0 11
50888: PPUSH
50889: CALL_OW 272
50893: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
50894: LD_ADDR_VAR 0 8
50898: PUSH
50899: LD_VAR 0 2
50903: PPUSH
50904: LD_VAR 0 6
50908: PPUSH
50909: LD_VAR 0 11
50913: PPUSH
50914: CALL_OW 273
50918: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50919: LD_VAR 0 7
50923: PPUSH
50924: LD_VAR 0 8
50928: PPUSH
50929: CALL_OW 488
50933: NOT
50934: IFFALSE 50938
// continue ;
50936: GO 50866
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
50938: LD_ADDR_VAR 0 9
50942: PUSH
50943: LD_VAR 0 12
50947: PUSH
50948: LD_INT 1
50950: ARRAY
50951: PPUSH
50952: LD_VAR 0 12
50956: PUSH
50957: LD_INT 2
50959: ARRAY
50960: PPUSH
50961: LD_VAR 0 7
50965: PPUSH
50966: LD_VAR 0 8
50970: PPUSH
50971: CALL_OW 298
50975: ST_TO_ADDR
// if tmp < distance then
50976: LD_VAR 0 9
50980: PUSH
50981: LD_VAR 0 10
50985: LESS
50986: IFFALSE 51008
// begin result := i ;
50988: LD_ADDR_VAR 0 5
50992: PUSH
50993: LD_VAR 0 6
50997: ST_TO_ADDR
// distance := tmp ;
50998: LD_ADDR_VAR 0 10
51002: PUSH
51003: LD_VAR 0 9
51007: ST_TO_ADDR
// end ; end ;
51008: GO 50866
51010: POP
51011: POP
// end ;
51012: LD_VAR 0 5
51016: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51017: LD_INT 0
51019: PPUSH
51020: PPUSH
// if not driver or not IsInUnit ( driver ) then
51021: LD_VAR 0 1
51025: NOT
51026: IFTRUE 51040
51028: PUSH
51029: LD_VAR 0 1
51033: PPUSH
51034: CALL_OW 310
51038: NOT
51039: OR
51040: IFFALSE 51044
// exit ;
51042: GO 51134
// vehicle := IsInUnit ( driver ) ;
51044: LD_ADDR_VAR 0 3
51048: PUSH
51049: LD_VAR 0 1
51053: PPUSH
51054: CALL_OW 310
51058: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51059: LD_VAR 0 1
51063: PPUSH
51064: LD_STRING \
51066: PUSH
51067: LD_INT 0
51069: PUSH
51070: LD_INT 0
51072: PUSH
51073: LD_INT 0
51075: PUSH
51076: LD_INT 0
51078: PUSH
51079: LD_INT 0
51081: PUSH
51082: LD_INT 0
51084: PUSH
51085: EMPTY
51086: LIST
51087: LIST
51088: LIST
51089: LIST
51090: LIST
51091: LIST
51092: LIST
51093: PUSH
51094: LD_STRING E
51096: PUSH
51097: LD_INT 0
51099: PUSH
51100: LD_INT 0
51102: PUSH
51103: LD_VAR 0 3
51107: PUSH
51108: LD_INT 0
51110: PUSH
51111: LD_INT 0
51113: PUSH
51114: LD_INT 0
51116: PUSH
51117: EMPTY
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: PPUSH
51130: CALL_OW 446
// end ;
51134: LD_VAR 0 2
51138: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
51139: LD_INT 0
51141: PPUSH
51142: PPUSH
// if not driver or not IsInUnit ( driver ) then
51143: LD_VAR 0 1
51147: NOT
51148: IFTRUE 51162
51150: PUSH
51151: LD_VAR 0 1
51155: PPUSH
51156: CALL_OW 310
51160: NOT
51161: OR
51162: IFFALSE 51166
// exit ;
51164: GO 51256
// vehicle := IsInUnit ( driver ) ;
51166: LD_ADDR_VAR 0 3
51170: PUSH
51171: LD_VAR 0 1
51175: PPUSH
51176: CALL_OW 310
51180: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
51181: LD_VAR 0 1
51185: PPUSH
51186: LD_STRING \
51188: PUSH
51189: LD_INT 0
51191: PUSH
51192: LD_INT 0
51194: PUSH
51195: LD_INT 0
51197: PUSH
51198: LD_INT 0
51200: PUSH
51201: LD_INT 0
51203: PUSH
51204: LD_INT 0
51206: PUSH
51207: EMPTY
51208: LIST
51209: LIST
51210: LIST
51211: LIST
51212: LIST
51213: LIST
51214: LIST
51215: PUSH
51216: LD_STRING E
51218: PUSH
51219: LD_INT 0
51221: PUSH
51222: LD_INT 0
51224: PUSH
51225: LD_VAR 0 3
51229: PUSH
51230: LD_INT 0
51232: PUSH
51233: LD_INT 0
51235: PUSH
51236: LD_INT 0
51238: PUSH
51239: EMPTY
51240: LIST
51241: LIST
51242: LIST
51243: LIST
51244: LIST
51245: LIST
51246: LIST
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PPUSH
51252: CALL_OW 447
// end ;
51256: LD_VAR 0 2
51260: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
51261: LD_INT 0
51263: PPUSH
51264: PPUSH
51265: PPUSH
// tmp := [ ] ;
51266: LD_ADDR_VAR 0 5
51270: PUSH
51271: EMPTY
51272: ST_TO_ADDR
// for i in units do
51273: LD_ADDR_VAR 0 4
51277: PUSH
51278: LD_VAR 0 1
51282: PUSH
51283: FOR_IN
51284: IFFALSE 51322
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
51286: LD_ADDR_VAR 0 5
51290: PUSH
51291: LD_VAR 0 5
51295: PPUSH
51296: LD_VAR 0 5
51300: PUSH
51301: LD_INT 1
51303: PLUS
51304: PPUSH
51305: LD_VAR 0 4
51309: PPUSH
51310: CALL_OW 256
51314: PPUSH
51315: CALL_OW 2
51319: ST_TO_ADDR
51320: GO 51283
51322: POP
51323: POP
// if not tmp then
51324: LD_VAR 0 5
51328: NOT
51329: IFFALSE 51333
// exit ;
51331: GO 51381
// if asc then
51333: LD_VAR 0 2
51337: IFFALSE 51361
// result := SortListByListAsc ( units , tmp ) else
51339: LD_ADDR_VAR 0 3
51343: PUSH
51344: LD_VAR 0 1
51348: PPUSH
51349: LD_VAR 0 5
51353: PPUSH
51354: CALL_OW 76
51358: ST_TO_ADDR
51359: GO 51381
// result := SortListByListDesc ( units , tmp ) ;
51361: LD_ADDR_VAR 0 3
51365: PUSH
51366: LD_VAR 0 1
51370: PPUSH
51371: LD_VAR 0 5
51375: PPUSH
51376: CALL_OW 77
51380: ST_TO_ADDR
// end ;
51381: LD_VAR 0 3
51385: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
51386: LD_INT 0
51388: PPUSH
51389: PPUSH
// task := GetTaskList ( mech ) ;
51390: LD_ADDR_VAR 0 4
51394: PUSH
51395: LD_VAR 0 1
51399: PPUSH
51400: CALL_OW 437
51404: ST_TO_ADDR
// if not task then
51405: LD_VAR 0 4
51409: NOT
51410: IFFALSE 51414
// exit ;
51412: GO 51458
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
51414: LD_ADDR_VAR 0 3
51418: PUSH
51419: LD_VAR 0 4
51423: PUSH
51424: LD_INT 1
51426: ARRAY
51427: PUSH
51428: LD_INT 1
51430: ARRAY
51431: PUSH
51432: LD_STRING r
51434: EQUAL
51435: IFFALSE 51457
51437: PUSH
51438: LD_VAR 0 4
51442: PUSH
51443: LD_INT 1
51445: ARRAY
51446: PUSH
51447: LD_INT 4
51449: ARRAY
51450: PUSH
51451: LD_VAR 0 2
51455: EQUAL
51456: AND
51457: ST_TO_ADDR
// end ;
51458: LD_VAR 0 3
51462: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
51463: LD_INT 0
51465: PPUSH
// SetDir ( unit , d ) ;
51466: LD_VAR 0 1
51470: PPUSH
51471: LD_VAR 0 4
51475: PPUSH
51476: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
51480: LD_ADDR_VAR 0 6
51484: PUSH
51485: LD_VAR 0 1
51489: PPUSH
51490: LD_VAR 0 2
51494: PPUSH
51495: LD_VAR 0 3
51499: PPUSH
51500: LD_VAR 0 5
51504: PPUSH
51505: CALL_OW 48
51509: ST_TO_ADDR
// end ;
51510: LD_VAR 0 6
51514: RET
// export function ToNaturalNumber ( number ) ; begin
51515: LD_INT 0
51517: PPUSH
// result := number div 1 ;
51518: LD_ADDR_VAR 0 2
51522: PUSH
51523: LD_VAR 0 1
51527: PUSH
51528: LD_INT 1
51530: DIV
51531: ST_TO_ADDR
// if number < 0 then
51532: LD_VAR 0 1
51536: PUSH
51537: LD_INT 0
51539: LESS
51540: IFFALSE 51550
// result := 0 ;
51542: LD_ADDR_VAR 0 2
51546: PUSH
51547: LD_INT 0
51549: ST_TO_ADDR
// end ;
51550: LD_VAR 0 2
51554: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
51555: LD_INT 0
51557: PPUSH
51558: PPUSH
51559: PPUSH
// if not buildings then
51560: LD_VAR 0 1
51564: NOT
51565: IFFALSE 51569
// exit ;
51567: GO 51684
// tmp := [ ] ;
51569: LD_ADDR_VAR 0 5
51573: PUSH
51574: EMPTY
51575: ST_TO_ADDR
// for b in buildings do
51576: LD_ADDR_VAR 0 4
51580: PUSH
51581: LD_VAR 0 1
51585: PUSH
51586: FOR_IN
51587: IFFALSE 51625
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
51589: LD_ADDR_VAR 0 5
51593: PUSH
51594: LD_VAR 0 5
51598: PPUSH
51599: LD_VAR 0 5
51603: PUSH
51604: LD_INT 1
51606: PLUS
51607: PPUSH
51608: LD_VAR 0 4
51612: PPUSH
51613: CALL_OW 266
51617: PPUSH
51618: CALL_OW 1
51622: ST_TO_ADDR
51623: GO 51586
51625: POP
51626: POP
// if not tmp then
51627: LD_VAR 0 5
51631: NOT
51632: IFFALSE 51636
// exit ;
51634: GO 51684
// if asc then
51636: LD_VAR 0 2
51640: IFFALSE 51664
// result := SortListByListAsc ( buildings , tmp ) else
51642: LD_ADDR_VAR 0 3
51646: PUSH
51647: LD_VAR 0 1
51651: PPUSH
51652: LD_VAR 0 5
51656: PPUSH
51657: CALL_OW 76
51661: ST_TO_ADDR
51662: GO 51684
// result := SortListByListDesc ( buildings , tmp ) ;
51664: LD_ADDR_VAR 0 3
51668: PUSH
51669: LD_VAR 0 1
51673: PPUSH
51674: LD_VAR 0 5
51678: PPUSH
51679: CALL_OW 77
51683: ST_TO_ADDR
// end ;
51684: LD_VAR 0 3
51688: RET
// export function SortByClass ( units , class ) ; var un ; begin
51689: LD_INT 0
51691: PPUSH
51692: PPUSH
// if not units or not class then
51693: LD_VAR 0 1
51697: NOT
51698: IFTRUE 51707
51700: PUSH
51701: LD_VAR 0 2
51705: NOT
51706: OR
51707: IFFALSE 51711
// exit ;
51709: GO 51806
// result := [ ] ;
51711: LD_ADDR_VAR 0 3
51715: PUSH
51716: EMPTY
51717: ST_TO_ADDR
// for un in units do
51718: LD_ADDR_VAR 0 4
51722: PUSH
51723: LD_VAR 0 1
51727: PUSH
51728: FOR_IN
51729: IFFALSE 51804
// if GetClass ( un ) = class then
51731: LD_VAR 0 4
51735: PPUSH
51736: CALL_OW 257
51740: PUSH
51741: LD_VAR 0 2
51745: EQUAL
51746: IFFALSE 51773
// result := Insert ( result , 1 , un ) else
51748: LD_ADDR_VAR 0 3
51752: PUSH
51753: LD_VAR 0 3
51757: PPUSH
51758: LD_INT 1
51760: PPUSH
51761: LD_VAR 0 4
51765: PPUSH
51766: CALL_OW 2
51770: ST_TO_ADDR
51771: GO 51802
// result := Replace ( result , result + 1 , un ) ;
51773: LD_ADDR_VAR 0 3
51777: PUSH
51778: LD_VAR 0 3
51782: PPUSH
51783: LD_VAR 0 3
51787: PUSH
51788: LD_INT 1
51790: PLUS
51791: PPUSH
51792: LD_VAR 0 4
51796: PPUSH
51797: CALL_OW 1
51801: ST_TO_ADDR
51802: GO 51728
51804: POP
51805: POP
// end ;
51806: LD_VAR 0 3
51810: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
51811: LD_INT 0
51813: PPUSH
51814: PPUSH
51815: PPUSH
51816: PPUSH
51817: PPUSH
51818: PPUSH
51819: PPUSH
// result := [ ] ;
51820: LD_ADDR_VAR 0 4
51824: PUSH
51825: EMPTY
51826: ST_TO_ADDR
// if x - r < 0 then
51827: LD_VAR 0 1
51831: PUSH
51832: LD_VAR 0 3
51836: MINUS
51837: PUSH
51838: LD_INT 0
51840: LESS
51841: IFFALSE 51853
// min_x := 0 else
51843: LD_ADDR_VAR 0 8
51847: PUSH
51848: LD_INT 0
51850: ST_TO_ADDR
51851: GO 51869
// min_x := x - r ;
51853: LD_ADDR_VAR 0 8
51857: PUSH
51858: LD_VAR 0 1
51862: PUSH
51863: LD_VAR 0 3
51867: MINUS
51868: ST_TO_ADDR
// if y - r < 0 then
51869: LD_VAR 0 2
51873: PUSH
51874: LD_VAR 0 3
51878: MINUS
51879: PUSH
51880: LD_INT 0
51882: LESS
51883: IFFALSE 51895
// min_y := 0 else
51885: LD_ADDR_VAR 0 7
51889: PUSH
51890: LD_INT 0
51892: ST_TO_ADDR
51893: GO 51911
// min_y := y - r ;
51895: LD_ADDR_VAR 0 7
51899: PUSH
51900: LD_VAR 0 2
51904: PUSH
51905: LD_VAR 0 3
51909: MINUS
51910: ST_TO_ADDR
// max_x := x + r ;
51911: LD_ADDR_VAR 0 9
51915: PUSH
51916: LD_VAR 0 1
51920: PUSH
51921: LD_VAR 0 3
51925: PLUS
51926: ST_TO_ADDR
// max_y := y + r ;
51927: LD_ADDR_VAR 0 10
51931: PUSH
51932: LD_VAR 0 2
51936: PUSH
51937: LD_VAR 0 3
51941: PLUS
51942: ST_TO_ADDR
// for _x = min_x to max_x do
51943: LD_ADDR_VAR 0 5
51947: PUSH
51948: DOUBLE
51949: LD_VAR 0 8
51953: DEC
51954: ST_TO_ADDR
51955: LD_VAR 0 9
51959: PUSH
51960: FOR_TO
51961: IFFALSE 52062
// for _y = min_y to max_y do
51963: LD_ADDR_VAR 0 6
51967: PUSH
51968: DOUBLE
51969: LD_VAR 0 7
51973: DEC
51974: ST_TO_ADDR
51975: LD_VAR 0 10
51979: PUSH
51980: FOR_TO
51981: IFFALSE 52058
// begin if not ValidHex ( _x , _y ) then
51983: LD_VAR 0 5
51987: PPUSH
51988: LD_VAR 0 6
51992: PPUSH
51993: CALL_OW 488
51997: NOT
51998: IFFALSE 52002
// continue ;
52000: GO 51980
// if GetResourceTypeXY ( _x , _y ) then
52002: LD_VAR 0 5
52006: PPUSH
52007: LD_VAR 0 6
52011: PPUSH
52012: CALL_OW 283
52016: IFFALSE 52056
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
52018: LD_ADDR_VAR 0 4
52022: PUSH
52023: LD_VAR 0 4
52027: PPUSH
52028: LD_VAR 0 4
52032: PUSH
52033: LD_INT 1
52035: PLUS
52036: PPUSH
52037: LD_VAR 0 5
52041: PUSH
52042: LD_VAR 0 6
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: PPUSH
52051: CALL_OW 1
52055: ST_TO_ADDR
// end ;
52056: GO 51980
52058: POP
52059: POP
52060: GO 51960
52062: POP
52063: POP
// end ;
52064: LD_VAR 0 4
52068: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
52069: LD_INT 0
52071: PPUSH
52072: PPUSH
52073: PPUSH
52074: PPUSH
52075: PPUSH
52076: PPUSH
52077: PPUSH
52078: PPUSH
// if not units then
52079: LD_VAR 0 1
52083: NOT
52084: IFFALSE 52088
// exit ;
52086: GO 52620
// result := UnitFilter ( units , [ f_ok ] ) ;
52088: LD_ADDR_VAR 0 3
52092: PUSH
52093: LD_VAR 0 1
52097: PPUSH
52098: LD_INT 50
52100: PUSH
52101: EMPTY
52102: LIST
52103: PPUSH
52104: CALL_OW 72
52108: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
52109: LD_ADDR_VAR 0 8
52113: PUSH
52114: LD_VAR 0 1
52118: PUSH
52119: LD_INT 1
52121: ARRAY
52122: PPUSH
52123: CALL_OW 255
52127: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
52128: LD_ADDR_VAR 0 10
52132: PUSH
52133: LD_INT 29
52135: PUSH
52136: LD_INT 91
52138: PUSH
52139: LD_INT 49
52141: PUSH
52142: EMPTY
52143: LIST
52144: LIST
52145: LIST
52146: ST_TO_ADDR
// if not result then
52147: LD_VAR 0 3
52151: NOT
52152: IFFALSE 52156
// exit ;
52154: GO 52620
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
52156: LD_ADDR_VAR 0 5
52160: PUSH
52161: LD_INT 81
52163: PUSH
52164: LD_VAR 0 8
52168: PUSH
52169: EMPTY
52170: LIST
52171: LIST
52172: PPUSH
52173: CALL_OW 69
52177: ST_TO_ADDR
// for i in result do
52178: LD_ADDR_VAR 0 4
52182: PUSH
52183: LD_VAR 0 3
52187: PUSH
52188: FOR_IN
52189: IFFALSE 52618
// begin tag := GetTag ( i ) + 1 ;
52191: LD_ADDR_VAR 0 9
52195: PUSH
52196: LD_VAR 0 4
52200: PPUSH
52201: CALL_OW 110
52205: PUSH
52206: LD_INT 1
52208: PLUS
52209: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
52210: LD_ADDR_VAR 0 7
52214: PUSH
52215: LD_VAR 0 4
52219: PPUSH
52220: CALL_OW 250
52224: PPUSH
52225: LD_VAR 0 4
52229: PPUSH
52230: CALL_OW 251
52234: PPUSH
52235: LD_INT 4
52237: PPUSH
52238: CALL 51811 0 3
52242: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
52243: LD_VAR 0 4
52247: PPUSH
52248: CALL_OW 247
52252: PUSH
52253: LD_INT 2
52255: EQUAL
52256: IFFALSE 52268
52258: PUSH
52259: LD_VAR 0 7
52263: PUSH
52264: LD_INT 2
52266: GREATER
52267: AND
52268: IFFALSE 52288
52270: PUSH
52271: LD_VAR 0 4
52275: PPUSH
52276: CALL_OW 264
52280: PUSH
52281: LD_VAR 0 10
52285: IN
52286: NOT
52287: AND
52288: IFFALSE 52327
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
52290: LD_VAR 0 4
52294: PPUSH
52295: LD_VAR 0 7
52299: PUSH
52300: LD_INT 1
52302: ARRAY
52303: PUSH
52304: LD_INT 1
52306: ARRAY
52307: PPUSH
52308: LD_VAR 0 7
52312: PUSH
52313: LD_INT 1
52315: ARRAY
52316: PUSH
52317: LD_INT 2
52319: ARRAY
52320: PPUSH
52321: CALL_OW 116
52325: GO 52616
// if path > tag then
52327: LD_VAR 0 2
52331: PUSH
52332: LD_VAR 0 9
52336: GREATER
52337: IFFALSE 52545
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
52339: LD_ADDR_VAR 0 6
52343: PUSH
52344: LD_VAR 0 5
52348: PPUSH
52349: LD_INT 91
52351: PUSH
52352: LD_VAR 0 4
52356: PUSH
52357: LD_INT 8
52359: PUSH
52360: EMPTY
52361: LIST
52362: LIST
52363: LIST
52364: PPUSH
52365: CALL_OW 72
52369: ST_TO_ADDR
// if nearEnemy then
52370: LD_VAR 0 6
52374: IFFALSE 52443
// begin if GetWeapon ( i ) = ru_time_lapser then
52376: LD_VAR 0 4
52380: PPUSH
52381: CALL_OW 264
52385: PUSH
52386: LD_INT 49
52388: EQUAL
52389: IFFALSE 52417
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
52391: LD_VAR 0 4
52395: PPUSH
52396: LD_VAR 0 6
52400: PPUSH
52401: LD_VAR 0 4
52405: PPUSH
52406: CALL_OW 74
52410: PPUSH
52411: CALL_OW 112
52415: GO 52441
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
52417: LD_VAR 0 4
52421: PPUSH
52422: LD_VAR 0 6
52426: PPUSH
52427: LD_VAR 0 4
52431: PPUSH
52432: CALL_OW 74
52436: PPUSH
52437: CALL 53701 0 2
// end else
52441: GO 52543
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
52443: LD_VAR 0 4
52447: PPUSH
52448: LD_VAR 0 2
52452: PUSH
52453: LD_VAR 0 9
52457: ARRAY
52458: PUSH
52459: LD_INT 1
52461: ARRAY
52462: PPUSH
52463: LD_VAR 0 2
52467: PUSH
52468: LD_VAR 0 9
52472: ARRAY
52473: PUSH
52474: LD_INT 2
52476: ARRAY
52477: PPUSH
52478: CALL_OW 297
52482: PUSH
52483: LD_INT 6
52485: GREATER
52486: IFFALSE 52529
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
52488: LD_VAR 0 4
52492: PPUSH
52493: LD_VAR 0 2
52497: PUSH
52498: LD_VAR 0 9
52502: ARRAY
52503: PUSH
52504: LD_INT 1
52506: ARRAY
52507: PPUSH
52508: LD_VAR 0 2
52512: PUSH
52513: LD_VAR 0 9
52517: ARRAY
52518: PUSH
52519: LD_INT 2
52521: ARRAY
52522: PPUSH
52523: CALL_OW 114
52527: GO 52543
// SetTag ( i , tag ) ;
52529: LD_VAR 0 4
52533: PPUSH
52534: LD_VAR 0 9
52538: PPUSH
52539: CALL_OW 109
// end else
52543: GO 52616
// if enemy then
52545: LD_VAR 0 5
52549: IFFALSE 52616
// begin if GetWeapon ( i ) = ru_time_lapser then
52551: LD_VAR 0 4
52555: PPUSH
52556: CALL_OW 264
52560: PUSH
52561: LD_INT 49
52563: EQUAL
52564: IFFALSE 52592
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
52566: LD_VAR 0 4
52570: PPUSH
52571: LD_VAR 0 5
52575: PPUSH
52576: LD_VAR 0 4
52580: PPUSH
52581: CALL_OW 74
52585: PPUSH
52586: CALL_OW 112
52590: GO 52616
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
52592: LD_VAR 0 4
52596: PPUSH
52597: LD_VAR 0 5
52601: PPUSH
52602: LD_VAR 0 4
52606: PPUSH
52607: CALL_OW 74
52611: PPUSH
52612: CALL 53701 0 2
// end ; end ;
52616: GO 52188
52618: POP
52619: POP
// end ;
52620: LD_VAR 0 3
52624: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
52625: LD_INT 0
52627: PPUSH
52628: PPUSH
52629: PPUSH
// if not unit or IsInUnit ( unit ) then
52630: LD_VAR 0 1
52634: NOT
52635: IFTRUE 52648
52637: PUSH
52638: LD_VAR 0 1
52642: PPUSH
52643: CALL_OW 310
52647: OR
52648: IFFALSE 52652
// exit ;
52650: GO 52743
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
52652: LD_ADDR_VAR 0 4
52656: PUSH
52657: LD_VAR 0 1
52661: PPUSH
52662: CALL_OW 250
52666: PPUSH
52667: LD_VAR 0 2
52671: PPUSH
52672: LD_INT 1
52674: PPUSH
52675: CALL_OW 272
52679: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
52680: LD_ADDR_VAR 0 5
52684: PUSH
52685: LD_VAR 0 1
52689: PPUSH
52690: CALL_OW 251
52694: PPUSH
52695: LD_VAR 0 2
52699: PPUSH
52700: LD_INT 1
52702: PPUSH
52703: CALL_OW 273
52707: ST_TO_ADDR
// if ValidHex ( x , y ) then
52708: LD_VAR 0 4
52712: PPUSH
52713: LD_VAR 0 5
52717: PPUSH
52718: CALL_OW 488
52722: IFFALSE 52743
// ComTurnXY ( unit , x , y ) ;
52724: LD_VAR 0 1
52728: PPUSH
52729: LD_VAR 0 4
52733: PPUSH
52734: LD_VAR 0 5
52738: PPUSH
52739: CALL_OW 118
// end ;
52743: LD_VAR 0 3
52747: RET
// export function SeeUnits ( side , units ) ; var i ; begin
52748: LD_INT 0
52750: PPUSH
52751: PPUSH
// result := false ;
52752: LD_ADDR_VAR 0 3
52756: PUSH
52757: LD_INT 0
52759: ST_TO_ADDR
// if not units then
52760: LD_VAR 0 2
52764: NOT
52765: IFFALSE 52769
// exit ;
52767: GO 52814
// for i in units do
52769: LD_ADDR_VAR 0 4
52773: PUSH
52774: LD_VAR 0 2
52778: PUSH
52779: FOR_IN
52780: IFFALSE 52812
// if See ( side , i ) then
52782: LD_VAR 0 1
52786: PPUSH
52787: LD_VAR 0 4
52791: PPUSH
52792: CALL_OW 292
52796: IFFALSE 52810
// begin result := true ;
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: LD_INT 1
52805: ST_TO_ADDR
// exit ;
52806: POP
52807: POP
52808: GO 52814
// end ;
52810: GO 52779
52812: POP
52813: POP
// end ;
52814: LD_VAR 0 3
52818: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
52819: LD_INT 0
52821: PPUSH
52822: PPUSH
52823: PPUSH
52824: PPUSH
// if not unit or not points then
52825: LD_VAR 0 1
52829: NOT
52830: IFTRUE 52839
52832: PUSH
52833: LD_VAR 0 2
52837: NOT
52838: OR
52839: IFFALSE 52843
// exit ;
52841: GO 52933
// dist := 99999 ;
52843: LD_ADDR_VAR 0 5
52847: PUSH
52848: LD_INT 99999
52850: ST_TO_ADDR
// for i in points do
52851: LD_ADDR_VAR 0 4
52855: PUSH
52856: LD_VAR 0 2
52860: PUSH
52861: FOR_IN
52862: IFFALSE 52931
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
52864: LD_ADDR_VAR 0 6
52868: PUSH
52869: LD_VAR 0 1
52873: PPUSH
52874: LD_VAR 0 4
52878: PUSH
52879: LD_INT 1
52881: ARRAY
52882: PPUSH
52883: LD_VAR 0 4
52887: PUSH
52888: LD_INT 2
52890: ARRAY
52891: PPUSH
52892: CALL_OW 297
52896: ST_TO_ADDR
// if tmpDist < dist then
52897: LD_VAR 0 6
52901: PUSH
52902: LD_VAR 0 5
52906: LESS
52907: IFFALSE 52929
// begin result := i ;
52909: LD_ADDR_VAR 0 3
52913: PUSH
52914: LD_VAR 0 4
52918: ST_TO_ADDR
// dist := tmpDist ;
52919: LD_ADDR_VAR 0 5
52923: PUSH
52924: LD_VAR 0 6
52928: ST_TO_ADDR
// end ; end ;
52929: GO 52861
52931: POP
52932: POP
// end ;
52933: LD_VAR 0 3
52937: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
52938: LD_INT 0
52940: PPUSH
// uc_side := side ;
52941: LD_ADDR_OWVAR 20
52945: PUSH
52946: LD_VAR 0 1
52950: ST_TO_ADDR
// uc_nation := 3 ;
52951: LD_ADDR_OWVAR 21
52955: PUSH
52956: LD_INT 3
52958: ST_TO_ADDR
// vc_chassis := 25 ;
52959: LD_ADDR_OWVAR 37
52963: PUSH
52964: LD_INT 25
52966: ST_TO_ADDR
// vc_engine := engine_siberite ;
52967: LD_ADDR_OWVAR 39
52971: PUSH
52972: LD_INT 3
52974: ST_TO_ADDR
// vc_control := control_computer ;
52975: LD_ADDR_OWVAR 38
52979: PUSH
52980: LD_INT 3
52982: ST_TO_ADDR
// vc_weapon := 59 ;
52983: LD_ADDR_OWVAR 40
52987: PUSH
52988: LD_INT 59
52990: ST_TO_ADDR
// result := CreateVehicle ;
52991: LD_ADDR_VAR 0 5
52995: PUSH
52996: CALL_OW 45
53000: ST_TO_ADDR
// SetDir ( result , d ) ;
53001: LD_VAR 0 5
53005: PPUSH
53006: LD_VAR 0 4
53010: PPUSH
53011: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
53015: LD_VAR 0 5
53019: PPUSH
53020: LD_VAR 0 2
53024: PPUSH
53025: LD_VAR 0 3
53029: PPUSH
53030: LD_INT 0
53032: PPUSH
53033: CALL_OW 48
// end ;
53037: LD_VAR 0 5
53041: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
53042: LD_INT 0
53044: PPUSH
53045: PPUSH
53046: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
53047: LD_ADDR_VAR 0 2
53051: PUSH
53052: LD_INT 0
53054: PUSH
53055: LD_INT 0
53057: PUSH
53058: LD_INT 0
53060: PUSH
53061: LD_INT 0
53063: PUSH
53064: EMPTY
53065: LIST
53066: LIST
53067: LIST
53068: LIST
53069: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
53070: LD_VAR 0 1
53074: NOT
53075: IFTRUE 53108
53077: PUSH
53078: LD_VAR 0 1
53082: PPUSH
53083: CALL_OW 264
53087: PUSH
53088: LD_INT 12
53090: PUSH
53091: LD_INT 51
53093: PUSH
53094: LD_INT 32
53096: PUSH
53097: LD_INT 89
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: LIST
53104: LIST
53105: IN
53106: NOT
53107: OR
53108: IFFALSE 53112
// exit ;
53110: GO 53210
// for i := 1 to 3 do
53112: LD_ADDR_VAR 0 3
53116: PUSH
53117: DOUBLE
53118: LD_INT 1
53120: DEC
53121: ST_TO_ADDR
53122: LD_INT 3
53124: PUSH
53125: FOR_TO
53126: IFFALSE 53208
// begin tmp := GetCargo ( cargo , i ) ;
53128: LD_ADDR_VAR 0 4
53132: PUSH
53133: LD_VAR 0 1
53137: PPUSH
53138: LD_VAR 0 3
53142: PPUSH
53143: CALL_OW 289
53147: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
53148: LD_ADDR_VAR 0 2
53152: PUSH
53153: LD_VAR 0 2
53157: PPUSH
53158: LD_VAR 0 3
53162: PPUSH
53163: LD_VAR 0 4
53167: PPUSH
53168: CALL_OW 1
53172: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
53173: LD_ADDR_VAR 0 2
53177: PUSH
53178: LD_VAR 0 2
53182: PPUSH
53183: LD_INT 4
53185: PPUSH
53186: LD_VAR 0 2
53190: PUSH
53191: LD_INT 4
53193: ARRAY
53194: PUSH
53195: LD_VAR 0 4
53199: PLUS
53200: PPUSH
53201: CALL_OW 1
53205: ST_TO_ADDR
// end ;
53206: GO 53125
53208: POP
53209: POP
// end ;
53210: LD_VAR 0 2
53214: RET
// export function Length ( array ) ; begin
53215: LD_INT 0
53217: PPUSH
// result := array + 0 ;
53218: LD_ADDR_VAR 0 2
53222: PUSH
53223: LD_VAR 0 1
53227: PUSH
53228: LD_INT 0
53230: PLUS
53231: ST_TO_ADDR
// end ;
53232: LD_VAR 0 2
53236: RET
// export function PrepareArray ( array ) ; begin
53237: LD_INT 0
53239: PPUSH
// result := array diff 0 ;
53240: LD_ADDR_VAR 0 2
53244: PUSH
53245: LD_VAR 0 1
53249: PUSH
53250: LD_INT 0
53252: DIFF
53253: ST_TO_ADDR
// if not result [ 1 ] then
53254: LD_VAR 0 2
53258: PUSH
53259: LD_INT 1
53261: ARRAY
53262: NOT
53263: IFFALSE 53283
// result := Delete ( result , 1 ) ;
53265: LD_ADDR_VAR 0 2
53269: PUSH
53270: LD_VAR 0 2
53274: PPUSH
53275: LD_INT 1
53277: PPUSH
53278: CALL_OW 3
53282: ST_TO_ADDR
// end ;
53283: LD_VAR 0 2
53287: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
53288: LD_INT 0
53290: PPUSH
53291: PPUSH
53292: PPUSH
53293: PPUSH
// sibRocketRange := 25 ;
53294: LD_ADDR_VAR 0 6
53298: PUSH
53299: LD_INT 25
53301: ST_TO_ADDR
// result := false ;
53302: LD_ADDR_VAR 0 4
53306: PUSH
53307: LD_INT 0
53309: ST_TO_ADDR
// for i := 0 to 5 do
53310: LD_ADDR_VAR 0 5
53314: PUSH
53315: DOUBLE
53316: LD_INT 0
53318: DEC
53319: ST_TO_ADDR
53320: LD_INT 5
53322: PUSH
53323: FOR_TO
53324: IFFALSE 53391
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
53326: LD_VAR 0 1
53330: PPUSH
53331: LD_VAR 0 5
53335: PPUSH
53336: LD_VAR 0 6
53340: PPUSH
53341: CALL_OW 272
53345: PPUSH
53346: LD_VAR 0 2
53350: PPUSH
53351: LD_VAR 0 5
53355: PPUSH
53356: LD_VAR 0 6
53360: PPUSH
53361: CALL_OW 273
53365: PPUSH
53366: LD_VAR 0 3
53370: PPUSH
53371: CALL_OW 309
53375: IFFALSE 53389
// begin result := true ;
53377: LD_ADDR_VAR 0 4
53381: PUSH
53382: LD_INT 1
53384: ST_TO_ADDR
// exit ;
53385: POP
53386: POP
53387: GO 53393
// end ;
53389: GO 53323
53391: POP
53392: POP
// end ;
53393: LD_VAR 0 4
53397: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
53398: LD_INT 0
53400: PPUSH
53401: PPUSH
53402: PPUSH
// if btype = b_depot then
53403: LD_VAR 0 2
53407: PUSH
53408: LD_INT 0
53410: EQUAL
53411: IFFALSE 53423
// begin result := true ;
53413: LD_ADDR_VAR 0 3
53417: PUSH
53418: LD_INT 1
53420: ST_TO_ADDR
// exit ;
53421: GO 53543
// end ; pom := GetBase ( depot ) ;
53423: LD_ADDR_VAR 0 4
53427: PUSH
53428: LD_VAR 0 1
53432: PPUSH
53433: CALL_OW 274
53437: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
53438: LD_ADDR_VAR 0 5
53442: PUSH
53443: LD_VAR 0 2
53447: PPUSH
53448: LD_VAR 0 1
53452: PPUSH
53453: CALL_OW 248
53457: PPUSH
53458: CALL_OW 450
53462: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
53463: LD_ADDR_VAR 0 3
53467: PUSH
53468: LD_VAR 0 4
53472: PPUSH
53473: LD_INT 1
53475: PPUSH
53476: CALL_OW 275
53480: PUSH
53481: LD_VAR 0 5
53485: PUSH
53486: LD_INT 1
53488: ARRAY
53489: GREATEREQUAL
53490: IFFALSE 53516
53492: PUSH
53493: LD_VAR 0 4
53497: PPUSH
53498: LD_INT 2
53500: PPUSH
53501: CALL_OW 275
53505: PUSH
53506: LD_VAR 0 5
53510: PUSH
53511: LD_INT 2
53513: ARRAY
53514: GREATEREQUAL
53515: AND
53516: IFFALSE 53542
53518: PUSH
53519: LD_VAR 0 4
53523: PPUSH
53524: LD_INT 3
53526: PPUSH
53527: CALL_OW 275
53531: PUSH
53532: LD_VAR 0 5
53536: PUSH
53537: LD_INT 3
53539: ARRAY
53540: GREATEREQUAL
53541: AND
53542: ST_TO_ADDR
// end ;
53543: LD_VAR 0 3
53547: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
53548: LD_INT 0
53550: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
53551: LD_VAR 0 1
53555: PPUSH
53556: LD_VAR 0 2
53560: PPUSH
53561: LD_INT 0
53563: PPUSH
53564: LD_INT 0
53566: PPUSH
53567: LD_INT 1
53569: PPUSH
53570: LD_INT 0
53572: PPUSH
53573: CALL_OW 587
// end ;
53577: LD_VAR 0 3
53581: RET
// export function CenterOnNow ( unit ) ; begin
53582: LD_INT 0
53584: PPUSH
// result := IsInUnit ( unit ) ;
53585: LD_ADDR_VAR 0 2
53589: PUSH
53590: LD_VAR 0 1
53594: PPUSH
53595: CALL_OW 310
53599: ST_TO_ADDR
// if not result then
53600: LD_VAR 0 2
53604: NOT
53605: IFFALSE 53617
// result := unit ;
53607: LD_ADDR_VAR 0 2
53611: PUSH
53612: LD_VAR 0 1
53616: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
53617: LD_VAR 0 1
53621: PPUSH
53622: CALL_OW 87
// end ;
53626: LD_VAR 0 2
53630: RET
// export function ComMoveHex ( unit , hex ) ; begin
53631: LD_INT 0
53633: PPUSH
// if not hex then
53634: LD_VAR 0 2
53638: NOT
53639: IFFALSE 53643
// exit ;
53641: GO 53696
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
53643: LD_VAR 0 2
53647: PUSH
53648: LD_INT 1
53650: ARRAY
53651: PPUSH
53652: LD_VAR 0 2
53656: PUSH
53657: LD_INT 2
53659: ARRAY
53660: PPUSH
53661: CALL_OW 428
53665: IFFALSE 53669
// exit ;
53667: GO 53696
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
53669: LD_VAR 0 1
53673: PPUSH
53674: LD_VAR 0 2
53678: PUSH
53679: LD_INT 1
53681: ARRAY
53682: PPUSH
53683: LD_VAR 0 2
53687: PUSH
53688: LD_INT 2
53690: ARRAY
53691: PPUSH
53692: CALL_OW 111
// end ;
53696: LD_VAR 0 3
53700: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
53701: LD_INT 0
53703: PPUSH
53704: PPUSH
53705: PPUSH
// if not unit or not enemy then
53706: LD_VAR 0 1
53710: NOT
53711: IFTRUE 53720
53713: PUSH
53714: LD_VAR 0 2
53718: NOT
53719: OR
53720: IFFALSE 53724
// exit ;
53722: GO 53850
// x := GetX ( enemy ) ;
53724: LD_ADDR_VAR 0 4
53728: PUSH
53729: LD_VAR 0 2
53733: PPUSH
53734: CALL_OW 250
53738: ST_TO_ADDR
// y := GetY ( enemy ) ;
53739: LD_ADDR_VAR 0 5
53743: PUSH
53744: LD_VAR 0 2
53748: PPUSH
53749: CALL_OW 251
53753: ST_TO_ADDR
// if ValidHex ( x , y ) then
53754: LD_VAR 0 4
53758: PPUSH
53759: LD_VAR 0 5
53763: PPUSH
53764: CALL_OW 488
53768: IFFALSE 53850
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
53770: LD_VAR 0 2
53774: PPUSH
53775: CALL_OW 247
53779: PUSH
53780: LD_INT 3
53782: PUSH
53783: LD_INT 2
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: IN
53790: IFTRUE 53813
53792: PUSH
53793: LD_VAR 0 1
53797: PPUSH
53798: CALL_OW 255
53802: PPUSH
53803: LD_VAR 0 2
53807: PPUSH
53808: CALL_OW 292
53812: OR
53813: IFFALSE 53831
// ComAttackUnit ( unit , enemy ) else
53815: LD_VAR 0 1
53819: PPUSH
53820: LD_VAR 0 2
53824: PPUSH
53825: CALL_OW 115
53829: GO 53850
// ComAgressiveMove ( unit , x , y ) ;
53831: LD_VAR 0 1
53835: PPUSH
53836: LD_VAR 0 4
53840: PPUSH
53841: LD_VAR 0 5
53845: PPUSH
53846: CALL_OW 114
// end ;
53850: LD_VAR 0 3
53854: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
53855: LD_INT 0
53857: PPUSH
53858: PPUSH
53859: PPUSH
// list := AreaToList ( area , 0 ) ;
53860: LD_ADDR_VAR 0 5
53864: PUSH
53865: LD_VAR 0 1
53869: PPUSH
53870: LD_INT 0
53872: PPUSH
53873: CALL_OW 517
53877: ST_TO_ADDR
// if not list then
53878: LD_VAR 0 5
53882: NOT
53883: IFFALSE 53887
// exit ;
53885: GO 54017
// if all then
53887: LD_VAR 0 2
53891: IFFALSE 53979
// begin for i := 1 to list [ 1 ] do
53893: LD_ADDR_VAR 0 4
53897: PUSH
53898: DOUBLE
53899: LD_INT 1
53901: DEC
53902: ST_TO_ADDR
53903: LD_VAR 0 5
53907: PUSH
53908: LD_INT 1
53910: ARRAY
53911: PUSH
53912: FOR_TO
53913: IFFALSE 53975
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
53915: LD_ADDR_VAR 0 3
53919: PUSH
53920: LD_VAR 0 3
53924: PPUSH
53925: LD_VAR 0 3
53929: PUSH
53930: LD_INT 1
53932: PLUS
53933: PPUSH
53934: LD_VAR 0 5
53938: PUSH
53939: LD_INT 1
53941: ARRAY
53942: PUSH
53943: LD_VAR 0 4
53947: ARRAY
53948: PUSH
53949: LD_VAR 0 5
53953: PUSH
53954: LD_INT 2
53956: ARRAY
53957: PUSH
53958: LD_VAR 0 4
53962: ARRAY
53963: PUSH
53964: EMPTY
53965: LIST
53966: LIST
53967: PPUSH
53968: CALL_OW 1
53972: ST_TO_ADDR
53973: GO 53912
53975: POP
53976: POP
// exit ;
53977: GO 54017
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
53979: LD_ADDR_VAR 0 3
53983: PUSH
53984: LD_VAR 0 5
53988: PUSH
53989: LD_INT 1
53991: ARRAY
53992: PUSH
53993: LD_INT 1
53995: ARRAY
53996: PUSH
53997: LD_VAR 0 5
54001: PUSH
54002: LD_INT 2
54004: ARRAY
54005: PUSH
54006: LD_INT 1
54008: ARRAY
54009: PUSH
54010: EMPTY
54011: LIST
54012: LIST
54013: PUSH
54014: EMPTY
54015: LIST
54016: ST_TO_ADDR
// end ;
54017: LD_VAR 0 3
54021: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
54022: LD_INT 0
54024: PPUSH
54025: PPUSH
// list := AreaToList ( area , 0 ) ;
54026: LD_ADDR_VAR 0 4
54030: PUSH
54031: LD_VAR 0 1
54035: PPUSH
54036: LD_INT 0
54038: PPUSH
54039: CALL_OW 517
54043: ST_TO_ADDR
// if not list then
54044: LD_VAR 0 4
54048: NOT
54049: IFFALSE 54053
// exit ;
54051: GO 54094
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
54053: LD_ADDR_VAR 0 3
54057: PUSH
54058: LD_VAR 0 4
54062: PUSH
54063: LD_INT 1
54065: ARRAY
54066: PUSH
54067: LD_INT 1
54069: ARRAY
54070: PUSH
54071: LD_VAR 0 4
54075: PUSH
54076: LD_INT 2
54078: ARRAY
54079: PUSH
54080: LD_INT 1
54082: ARRAY
54083: PUSH
54084: LD_VAR 0 2
54088: PUSH
54089: EMPTY
54090: LIST
54091: LIST
54092: LIST
54093: ST_TO_ADDR
// end ;
54094: LD_VAR 0 3
54098: RET
// export function First ( array ) ; begin
54099: LD_INT 0
54101: PPUSH
// if not array then
54102: LD_VAR 0 1
54106: NOT
54107: IFFALSE 54111
// exit ;
54109: GO 54125
// result := array [ 1 ] ;
54111: LD_ADDR_VAR 0 2
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: LD_INT 1
54123: ARRAY
54124: ST_TO_ADDR
// end ;
54125: LD_VAR 0 2
54129: RET
// export function Last ( array ) ; begin
54130: LD_INT 0
54132: PPUSH
// if not array then
54133: LD_VAR 0 1
54137: NOT
54138: IFFALSE 54142
// exit ;
54140: GO 54158
// result := array [ array ] ;
54142: LD_ADDR_VAR 0 2
54146: PUSH
54147: LD_VAR 0 1
54151: PUSH
54152: LD_VAR 0 1
54156: ARRAY
54157: ST_TO_ADDR
// end ;
54158: LD_VAR 0 2
54162: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
54163: LD_INT 0
54165: PPUSH
54166: PPUSH
// result := [ ] ;
54167: LD_ADDR_VAR 0 5
54171: PUSH
54172: EMPTY
54173: ST_TO_ADDR
// if not array then
54174: LD_VAR 0 1
54178: NOT
54179: IFFALSE 54183
// exit ;
54181: GO 54295
// for i := 1 to array do
54183: LD_ADDR_VAR 0 6
54187: PUSH
54188: DOUBLE
54189: LD_INT 1
54191: DEC
54192: ST_TO_ADDR
54193: LD_VAR 0 1
54197: PUSH
54198: FOR_TO
54199: IFFALSE 54293
// if array [ i ] [ index ] = value then
54201: LD_VAR 0 1
54205: PUSH
54206: LD_VAR 0 6
54210: ARRAY
54211: PUSH
54212: LD_VAR 0 2
54216: ARRAY
54217: PUSH
54218: LD_VAR 0 3
54222: EQUAL
54223: IFFALSE 54291
// begin if indexColumn then
54225: LD_VAR 0 4
54229: IFFALSE 54265
// result := Join ( result , array [ i ] [ indexColumn ] ) else
54231: LD_ADDR_VAR 0 5
54235: PUSH
54236: LD_VAR 0 5
54240: PPUSH
54241: LD_VAR 0 1
54245: PUSH
54246: LD_VAR 0 6
54250: ARRAY
54251: PUSH
54252: LD_VAR 0 4
54256: ARRAY
54257: PPUSH
54258: CALL 49303 0 2
54262: ST_TO_ADDR
54263: GO 54291
// result := Join ( result , array [ i ] ) ;
54265: LD_ADDR_VAR 0 5
54269: PUSH
54270: LD_VAR 0 5
54274: PPUSH
54275: LD_VAR 0 1
54279: PUSH
54280: LD_VAR 0 6
54284: ARRAY
54285: PPUSH
54286: CALL 49303 0 2
54290: ST_TO_ADDR
// end ;
54291: GO 54198
54293: POP
54294: POP
// end ;
54295: LD_VAR 0 5
54299: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
54300: LD_INT 0
54302: PPUSH
// if not vehicles or not parkingPoint then
54303: LD_VAR 0 1
54307: NOT
54308: IFTRUE 54317
54310: PUSH
54311: LD_VAR 0 2
54315: NOT
54316: OR
54317: IFFALSE 54321
// exit ;
54319: GO 54419
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
54321: LD_ADDR_VAR 0 1
54325: PUSH
54326: LD_VAR 0 1
54330: PPUSH
54331: LD_INT 50
54333: PUSH
54334: EMPTY
54335: LIST
54336: PUSH
54337: LD_INT 3
54339: PUSH
54340: LD_INT 92
54342: PUSH
54343: LD_VAR 0 2
54347: PUSH
54348: LD_INT 1
54350: ARRAY
54351: PUSH
54352: LD_VAR 0 2
54356: PUSH
54357: LD_INT 2
54359: ARRAY
54360: PUSH
54361: LD_INT 8
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: LIST
54368: LIST
54369: PUSH
54370: EMPTY
54371: LIST
54372: LIST
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: PPUSH
54378: CALL_OW 72
54382: ST_TO_ADDR
// if not vehicles then
54383: LD_VAR 0 1
54387: NOT
54388: IFFALSE 54392
// exit ;
54390: GO 54419
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
54392: LD_VAR 0 1
54396: PPUSH
54397: LD_VAR 0 2
54401: PUSH
54402: LD_INT 1
54404: ARRAY
54405: PPUSH
54406: LD_VAR 0 2
54410: PUSH
54411: LD_INT 2
54413: ARRAY
54414: PPUSH
54415: CALL_OW 111
// end ;
54419: LD_VAR 0 3
54423: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
54424: LD_INT 0
54426: PPUSH
54427: PPUSH
54428: PPUSH
// if not side or not area then
54429: LD_VAR 0 1
54433: NOT
54434: IFTRUE 54443
54436: PUSH
54437: LD_VAR 0 2
54441: NOT
54442: OR
54443: IFFALSE 54447
// exit ;
54445: GO 54566
// tmp := AreaToList ( area , 0 ) ;
54447: LD_ADDR_VAR 0 5
54451: PUSH
54452: LD_VAR 0 2
54456: PPUSH
54457: LD_INT 0
54459: PPUSH
54460: CALL_OW 517
54464: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
54465: LD_ADDR_VAR 0 4
54469: PUSH
54470: DOUBLE
54471: LD_INT 1
54473: DEC
54474: ST_TO_ADDR
54475: LD_VAR 0 5
54479: PUSH
54480: LD_INT 1
54482: ARRAY
54483: PUSH
54484: FOR_TO
54485: IFFALSE 54564
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
54487: LD_VAR 0 5
54491: PUSH
54492: LD_INT 1
54494: ARRAY
54495: PUSH
54496: LD_VAR 0 4
54500: ARRAY
54501: PPUSH
54502: LD_VAR 0 5
54506: PUSH
54507: LD_INT 2
54509: ARRAY
54510: PUSH
54511: LD_VAR 0 4
54515: ARRAY
54516: PPUSH
54517: CALL_OW 351
54521: IFFALSE 54562
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
54523: LD_VAR 0 5
54527: PUSH
54528: LD_INT 1
54530: ARRAY
54531: PUSH
54532: LD_VAR 0 4
54536: ARRAY
54537: PPUSH
54538: LD_VAR 0 5
54542: PUSH
54543: LD_INT 2
54545: ARRAY
54546: PUSH
54547: LD_VAR 0 4
54551: ARRAY
54552: PPUSH
54553: LD_VAR 0 1
54557: PPUSH
54558: CALL_OW 244
// end ;
54562: GO 54484
54564: POP
54565: POP
// end ;
54566: LD_VAR 0 3
54570: RET
// export function UniqueArray ( array ) ; var i ; begin
54571: LD_INT 0
54573: PPUSH
54574: PPUSH
// result := [ ] ;
54575: LD_ADDR_VAR 0 2
54579: PUSH
54580: EMPTY
54581: ST_TO_ADDR
// if not array then
54582: LD_VAR 0 1
54586: NOT
54587: IFFALSE 54591
// exit ;
54589: GO 54652
// for i := 1 to array do
54591: LD_ADDR_VAR 0 3
54595: PUSH
54596: DOUBLE
54597: LD_INT 1
54599: DEC
54600: ST_TO_ADDR
54601: LD_VAR 0 1
54605: PUSH
54606: FOR_TO
54607: IFFALSE 54650
// if not array [ i ] in result then
54609: LD_VAR 0 1
54613: PUSH
54614: LD_VAR 0 3
54618: ARRAY
54619: PUSH
54620: LD_VAR 0 2
54624: IN
54625: NOT
54626: IFFALSE 54648
// result := Join ( result , i ) ;
54628: LD_ADDR_VAR 0 2
54632: PUSH
54633: LD_VAR 0 2
54637: PPUSH
54638: LD_VAR 0 3
54642: PPUSH
54643: CALL 49303 0 2
54647: ST_TO_ADDR
54648: GO 54606
54650: POP
54651: POP
// end ; end_of_file
54652: LD_VAR 0 2
54656: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
54657: LD_INT 0
54659: PPUSH
54660: PPUSH
// skirmish := false ;
54661: LD_ADDR_EXP 21
54665: PUSH
54666: LD_INT 0
54668: ST_TO_ADDR
// debug_mc := false ;
54669: LD_ADDR_EXP 22
54673: PUSH
54674: LD_INT 0
54676: ST_TO_ADDR
// mc_bases := [ ] ;
54677: LD_ADDR_EXP 23
54681: PUSH
54682: EMPTY
54683: ST_TO_ADDR
// mc_sides := [ ] ;
54684: LD_ADDR_EXP 49
54688: PUSH
54689: EMPTY
54690: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54691: LD_ADDR_EXP 24
54695: PUSH
54696: EMPTY
54697: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54698: LD_ADDR_EXP 25
54702: PUSH
54703: EMPTY
54704: ST_TO_ADDR
// mc_need_heal := [ ] ;
54705: LD_ADDR_EXP 26
54709: PUSH
54710: EMPTY
54711: ST_TO_ADDR
// mc_healers := [ ] ;
54712: LD_ADDR_EXP 27
54716: PUSH
54717: EMPTY
54718: ST_TO_ADDR
// mc_build_list := [ ] ;
54719: LD_ADDR_EXP 28
54723: PUSH
54724: EMPTY
54725: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54726: LD_ADDR_EXP 55
54730: PUSH
54731: EMPTY
54732: ST_TO_ADDR
// mc_builders := [ ] ;
54733: LD_ADDR_EXP 29
54737: PUSH
54738: EMPTY
54739: ST_TO_ADDR
// mc_construct_list := [ ] ;
54740: LD_ADDR_EXP 30
54744: PUSH
54745: EMPTY
54746: ST_TO_ADDR
// mc_turret_list := [ ] ;
54747: LD_ADDR_EXP 31
54751: PUSH
54752: EMPTY
54753: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54754: LD_ADDR_EXP 32
54758: PUSH
54759: EMPTY
54760: ST_TO_ADDR
// mc_miners := [ ] ;
54761: LD_ADDR_EXP 37
54765: PUSH
54766: EMPTY
54767: ST_TO_ADDR
// mc_mines := [ ] ;
54768: LD_ADDR_EXP 36
54772: PUSH
54773: EMPTY
54774: ST_TO_ADDR
// mc_minefields := [ ] ;
54775: LD_ADDR_EXP 38
54779: PUSH
54780: EMPTY
54781: ST_TO_ADDR
// mc_crates := [ ] ;
54782: LD_ADDR_EXP 39
54786: PUSH
54787: EMPTY
54788: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54789: LD_ADDR_EXP 40
54793: PUSH
54794: EMPTY
54795: ST_TO_ADDR
// mc_crates_area := [ ] ;
54796: LD_ADDR_EXP 41
54800: PUSH
54801: EMPTY
54802: ST_TO_ADDR
// mc_vehicles := [ ] ;
54803: LD_ADDR_EXP 42
54807: PUSH
54808: EMPTY
54809: ST_TO_ADDR
// mc_attack := [ ] ;
54810: LD_ADDR_EXP 43
54814: PUSH
54815: EMPTY
54816: ST_TO_ADDR
// mc_produce := [ ] ;
54817: LD_ADDR_EXP 44
54821: PUSH
54822: EMPTY
54823: ST_TO_ADDR
// mc_defender := [ ] ;
54824: LD_ADDR_EXP 45
54828: PUSH
54829: EMPTY
54830: ST_TO_ADDR
// mc_parking := [ ] ;
54831: LD_ADDR_EXP 47
54835: PUSH
54836: EMPTY
54837: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54838: LD_ADDR_EXP 33
54842: PUSH
54843: EMPTY
54844: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54845: LD_ADDR_EXP 35
54849: PUSH
54850: EMPTY
54851: ST_TO_ADDR
// mc_scan := [ ] ;
54852: LD_ADDR_EXP 46
54856: PUSH
54857: EMPTY
54858: ST_TO_ADDR
// mc_scan_area := [ ] ;
54859: LD_ADDR_EXP 48
54863: PUSH
54864: EMPTY
54865: ST_TO_ADDR
// mc_tech := [ ] ;
54866: LD_ADDR_EXP 50
54870: PUSH
54871: EMPTY
54872: ST_TO_ADDR
// mc_class := [ ] ;
54873: LD_ADDR_EXP 64
54877: PUSH
54878: EMPTY
54879: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54880: LD_ADDR_EXP 65
54884: PUSH
54885: EMPTY
54886: ST_TO_ADDR
// mc_is_defending := [ ] ;
54887: LD_ADDR_EXP 66
54891: PUSH
54892: EMPTY
54893: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
54894: LD_ADDR_EXP 57
54898: PUSH
54899: EMPTY
54900: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
54901: LD_ADDR_EXP 67
54905: PUSH
54906: LD_INT 0
54908: ST_TO_ADDR
// end ;
54909: LD_VAR 0 1
54913: RET
// export function MC_Kill ( base ) ; begin
54914: LD_INT 0
54916: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54917: LD_ADDR_EXP 23
54921: PUSH
54922: LD_EXP 23
54926: PPUSH
54927: LD_VAR 0 1
54931: PPUSH
54932: EMPTY
54933: PPUSH
54934: CALL_OW 1
54938: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54939: LD_ADDR_EXP 24
54943: PUSH
54944: LD_EXP 24
54948: PPUSH
54949: LD_VAR 0 1
54953: PPUSH
54954: EMPTY
54955: PPUSH
54956: CALL_OW 1
54960: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54961: LD_ADDR_EXP 25
54965: PUSH
54966: LD_EXP 25
54970: PPUSH
54971: LD_VAR 0 1
54975: PPUSH
54976: EMPTY
54977: PPUSH
54978: CALL_OW 1
54982: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54983: LD_ADDR_EXP 26
54987: PUSH
54988: LD_EXP 26
54992: PPUSH
54993: LD_VAR 0 1
54997: PPUSH
54998: EMPTY
54999: PPUSH
55000: CALL_OW 1
55004: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55005: LD_ADDR_EXP 27
55009: PUSH
55010: LD_EXP 27
55014: PPUSH
55015: LD_VAR 0 1
55019: PPUSH
55020: EMPTY
55021: PPUSH
55022: CALL_OW 1
55026: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55027: LD_ADDR_EXP 28
55031: PUSH
55032: LD_EXP 28
55036: PPUSH
55037: LD_VAR 0 1
55041: PPUSH
55042: EMPTY
55043: PPUSH
55044: CALL_OW 1
55048: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55049: LD_ADDR_EXP 29
55053: PUSH
55054: LD_EXP 29
55058: PPUSH
55059: LD_VAR 0 1
55063: PPUSH
55064: EMPTY
55065: PPUSH
55066: CALL_OW 1
55070: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55071: LD_ADDR_EXP 30
55075: PUSH
55076: LD_EXP 30
55080: PPUSH
55081: LD_VAR 0 1
55085: PPUSH
55086: EMPTY
55087: PPUSH
55088: CALL_OW 1
55092: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55093: LD_ADDR_EXP 31
55097: PUSH
55098: LD_EXP 31
55102: PPUSH
55103: LD_VAR 0 1
55107: PPUSH
55108: EMPTY
55109: PPUSH
55110: CALL_OW 1
55114: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55115: LD_ADDR_EXP 32
55119: PUSH
55120: LD_EXP 32
55124: PPUSH
55125: LD_VAR 0 1
55129: PPUSH
55130: EMPTY
55131: PPUSH
55132: CALL_OW 1
55136: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55137: LD_ADDR_EXP 33
55141: PUSH
55142: LD_EXP 33
55146: PPUSH
55147: LD_VAR 0 1
55151: PPUSH
55152: EMPTY
55153: PPUSH
55154: CALL_OW 1
55158: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55159: LD_ADDR_EXP 34
55163: PUSH
55164: LD_EXP 34
55168: PPUSH
55169: LD_VAR 0 1
55173: PPUSH
55174: LD_INT 0
55176: PPUSH
55177: CALL_OW 1
55181: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55182: LD_ADDR_EXP 35
55186: PUSH
55187: LD_EXP 35
55191: PPUSH
55192: LD_VAR 0 1
55196: PPUSH
55197: EMPTY
55198: PPUSH
55199: CALL_OW 1
55203: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55204: LD_ADDR_EXP 36
55208: PUSH
55209: LD_EXP 36
55213: PPUSH
55214: LD_VAR 0 1
55218: PPUSH
55219: EMPTY
55220: PPUSH
55221: CALL_OW 1
55225: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55226: LD_ADDR_EXP 37
55230: PUSH
55231: LD_EXP 37
55235: PPUSH
55236: LD_VAR 0 1
55240: PPUSH
55241: EMPTY
55242: PPUSH
55243: CALL_OW 1
55247: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55248: LD_ADDR_EXP 38
55252: PUSH
55253: LD_EXP 38
55257: PPUSH
55258: LD_VAR 0 1
55262: PPUSH
55263: EMPTY
55264: PPUSH
55265: CALL_OW 1
55269: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55270: LD_ADDR_EXP 39
55274: PUSH
55275: LD_EXP 39
55279: PPUSH
55280: LD_VAR 0 1
55284: PPUSH
55285: EMPTY
55286: PPUSH
55287: CALL_OW 1
55291: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55292: LD_ADDR_EXP 40
55296: PUSH
55297: LD_EXP 40
55301: PPUSH
55302: LD_VAR 0 1
55306: PPUSH
55307: EMPTY
55308: PPUSH
55309: CALL_OW 1
55313: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55314: LD_ADDR_EXP 41
55318: PUSH
55319: LD_EXP 41
55323: PPUSH
55324: LD_VAR 0 1
55328: PPUSH
55329: EMPTY
55330: PPUSH
55331: CALL_OW 1
55335: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55336: LD_ADDR_EXP 42
55340: PUSH
55341: LD_EXP 42
55345: PPUSH
55346: LD_VAR 0 1
55350: PPUSH
55351: EMPTY
55352: PPUSH
55353: CALL_OW 1
55357: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55358: LD_ADDR_EXP 43
55362: PUSH
55363: LD_EXP 43
55367: PPUSH
55368: LD_VAR 0 1
55372: PPUSH
55373: EMPTY
55374: PPUSH
55375: CALL_OW 1
55379: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55380: LD_ADDR_EXP 44
55384: PUSH
55385: LD_EXP 44
55389: PPUSH
55390: LD_VAR 0 1
55394: PPUSH
55395: EMPTY
55396: PPUSH
55397: CALL_OW 1
55401: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55402: LD_ADDR_EXP 45
55406: PUSH
55407: LD_EXP 45
55411: PPUSH
55412: LD_VAR 0 1
55416: PPUSH
55417: EMPTY
55418: PPUSH
55419: CALL_OW 1
55423: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55424: LD_ADDR_EXP 46
55428: PUSH
55429: LD_EXP 46
55433: PPUSH
55434: LD_VAR 0 1
55438: PPUSH
55439: EMPTY
55440: PPUSH
55441: CALL_OW 1
55445: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55446: LD_ADDR_EXP 47
55450: PUSH
55451: LD_EXP 47
55455: PPUSH
55456: LD_VAR 0 1
55460: PPUSH
55461: EMPTY
55462: PPUSH
55463: CALL_OW 1
55467: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55468: LD_ADDR_EXP 48
55472: PUSH
55473: LD_EXP 48
55477: PPUSH
55478: LD_VAR 0 1
55482: PPUSH
55483: EMPTY
55484: PPUSH
55485: CALL_OW 1
55489: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55490: LD_ADDR_EXP 50
55494: PUSH
55495: LD_EXP 50
55499: PPUSH
55500: LD_VAR 0 1
55504: PPUSH
55505: EMPTY
55506: PPUSH
55507: CALL_OW 1
55511: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55512: LD_ADDR_EXP 52
55516: PUSH
55517: LD_EXP 52
55521: PPUSH
55522: LD_VAR 0 1
55526: PPUSH
55527: EMPTY
55528: PPUSH
55529: CALL_OW 1
55533: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55534: LD_ADDR_EXP 53
55538: PUSH
55539: LD_EXP 53
55543: PPUSH
55544: LD_VAR 0 1
55548: PPUSH
55549: EMPTY
55550: PPUSH
55551: CALL_OW 1
55555: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55556: LD_ADDR_EXP 54
55560: PUSH
55561: LD_EXP 54
55565: PPUSH
55566: LD_VAR 0 1
55570: PPUSH
55571: EMPTY
55572: PPUSH
55573: CALL_OW 1
55577: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55578: LD_ADDR_EXP 55
55582: PUSH
55583: LD_EXP 55
55587: PPUSH
55588: LD_VAR 0 1
55592: PPUSH
55593: EMPTY
55594: PPUSH
55595: CALL_OW 1
55599: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55600: LD_ADDR_EXP 56
55604: PUSH
55605: LD_EXP 56
55609: PPUSH
55610: LD_VAR 0 1
55614: PPUSH
55615: EMPTY
55616: PPUSH
55617: CALL_OW 1
55621: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55622: LD_ADDR_EXP 57
55626: PUSH
55627: LD_EXP 57
55631: PPUSH
55632: LD_VAR 0 1
55636: PPUSH
55637: EMPTY
55638: PPUSH
55639: CALL_OW 1
55643: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55644: LD_ADDR_EXP 58
55648: PUSH
55649: LD_EXP 58
55653: PPUSH
55654: LD_VAR 0 1
55658: PPUSH
55659: EMPTY
55660: PPUSH
55661: CALL_OW 1
55665: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55666: LD_ADDR_EXP 59
55670: PUSH
55671: LD_EXP 59
55675: PPUSH
55676: LD_VAR 0 1
55680: PPUSH
55681: EMPTY
55682: PPUSH
55683: CALL_OW 1
55687: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55688: LD_ADDR_EXP 60
55692: PUSH
55693: LD_EXP 60
55697: PPUSH
55698: LD_VAR 0 1
55702: PPUSH
55703: EMPTY
55704: PPUSH
55705: CALL_OW 1
55709: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55710: LD_ADDR_EXP 61
55714: PUSH
55715: LD_EXP 61
55719: PPUSH
55720: LD_VAR 0 1
55724: PPUSH
55725: EMPTY
55726: PPUSH
55727: CALL_OW 1
55731: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55732: LD_ADDR_EXP 62
55736: PUSH
55737: LD_EXP 62
55741: PPUSH
55742: LD_VAR 0 1
55746: PPUSH
55747: EMPTY
55748: PPUSH
55749: CALL_OW 1
55753: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55754: LD_ADDR_EXP 63
55758: PUSH
55759: LD_EXP 63
55763: PPUSH
55764: LD_VAR 0 1
55768: PPUSH
55769: EMPTY
55770: PPUSH
55771: CALL_OW 1
55775: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55776: LD_ADDR_EXP 64
55780: PUSH
55781: LD_EXP 64
55785: PPUSH
55786: LD_VAR 0 1
55790: PPUSH
55791: EMPTY
55792: PPUSH
55793: CALL_OW 1
55797: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55798: LD_ADDR_EXP 65
55802: PUSH
55803: LD_EXP 65
55807: PPUSH
55808: LD_VAR 0 1
55812: PPUSH
55813: LD_INT 0
55815: PPUSH
55816: CALL_OW 1
55820: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55821: LD_ADDR_EXP 66
55825: PUSH
55826: LD_EXP 66
55830: PPUSH
55831: LD_VAR 0 1
55835: PPUSH
55836: LD_INT 0
55838: PPUSH
55839: CALL_OW 1
55843: ST_TO_ADDR
// end ;
55844: LD_VAR 0 2
55848: RET
// export function MC_Add ( side , units ) ; var base ; begin
55849: LD_INT 0
55851: PPUSH
55852: PPUSH
// base := mc_bases + 1 ;
55853: LD_ADDR_VAR 0 4
55857: PUSH
55858: LD_EXP 23
55862: PUSH
55863: LD_INT 1
55865: PLUS
55866: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55867: LD_ADDR_EXP 49
55871: PUSH
55872: LD_EXP 49
55876: PPUSH
55877: LD_VAR 0 4
55881: PPUSH
55882: LD_VAR 0 1
55886: PPUSH
55887: CALL_OW 1
55891: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55892: LD_ADDR_EXP 23
55896: PUSH
55897: LD_EXP 23
55901: PPUSH
55902: LD_VAR 0 4
55906: PPUSH
55907: LD_VAR 0 2
55911: PPUSH
55912: CALL_OW 1
55916: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55917: LD_ADDR_EXP 24
55921: PUSH
55922: LD_EXP 24
55926: PPUSH
55927: LD_VAR 0 4
55931: PPUSH
55932: EMPTY
55933: PPUSH
55934: CALL_OW 1
55938: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55939: LD_ADDR_EXP 25
55943: PUSH
55944: LD_EXP 25
55948: PPUSH
55949: LD_VAR 0 4
55953: PPUSH
55954: EMPTY
55955: PPUSH
55956: CALL_OW 1
55960: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55961: LD_ADDR_EXP 26
55965: PUSH
55966: LD_EXP 26
55970: PPUSH
55971: LD_VAR 0 4
55975: PPUSH
55976: EMPTY
55977: PPUSH
55978: CALL_OW 1
55982: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55983: LD_ADDR_EXP 27
55987: PUSH
55988: LD_EXP 27
55992: PPUSH
55993: LD_VAR 0 4
55997: PPUSH
55998: EMPTY
55999: PPUSH
56000: CALL_OW 1
56004: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56005: LD_ADDR_EXP 28
56009: PUSH
56010: LD_EXP 28
56014: PPUSH
56015: LD_VAR 0 4
56019: PPUSH
56020: EMPTY
56021: PPUSH
56022: CALL_OW 1
56026: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56027: LD_ADDR_EXP 29
56031: PUSH
56032: LD_EXP 29
56036: PPUSH
56037: LD_VAR 0 4
56041: PPUSH
56042: EMPTY
56043: PPUSH
56044: CALL_OW 1
56048: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56049: LD_ADDR_EXP 30
56053: PUSH
56054: LD_EXP 30
56058: PPUSH
56059: LD_VAR 0 4
56063: PPUSH
56064: EMPTY
56065: PPUSH
56066: CALL_OW 1
56070: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56071: LD_ADDR_EXP 31
56075: PUSH
56076: LD_EXP 31
56080: PPUSH
56081: LD_VAR 0 4
56085: PPUSH
56086: EMPTY
56087: PPUSH
56088: CALL_OW 1
56092: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56093: LD_ADDR_EXP 32
56097: PUSH
56098: LD_EXP 32
56102: PPUSH
56103: LD_VAR 0 4
56107: PPUSH
56108: EMPTY
56109: PPUSH
56110: CALL_OW 1
56114: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56115: LD_ADDR_EXP 33
56119: PUSH
56120: LD_EXP 33
56124: PPUSH
56125: LD_VAR 0 4
56129: PPUSH
56130: EMPTY
56131: PPUSH
56132: CALL_OW 1
56136: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56137: LD_ADDR_EXP 34
56141: PUSH
56142: LD_EXP 34
56146: PPUSH
56147: LD_VAR 0 4
56151: PPUSH
56152: LD_INT 0
56154: PPUSH
56155: CALL_OW 1
56159: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56160: LD_ADDR_EXP 35
56164: PUSH
56165: LD_EXP 35
56169: PPUSH
56170: LD_VAR 0 4
56174: PPUSH
56175: EMPTY
56176: PPUSH
56177: CALL_OW 1
56181: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56182: LD_ADDR_EXP 36
56186: PUSH
56187: LD_EXP 36
56191: PPUSH
56192: LD_VAR 0 4
56196: PPUSH
56197: EMPTY
56198: PPUSH
56199: CALL_OW 1
56203: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56204: LD_ADDR_EXP 37
56208: PUSH
56209: LD_EXP 37
56213: PPUSH
56214: LD_VAR 0 4
56218: PPUSH
56219: EMPTY
56220: PPUSH
56221: CALL_OW 1
56225: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56226: LD_ADDR_EXP 38
56230: PUSH
56231: LD_EXP 38
56235: PPUSH
56236: LD_VAR 0 4
56240: PPUSH
56241: EMPTY
56242: PPUSH
56243: CALL_OW 1
56247: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56248: LD_ADDR_EXP 39
56252: PUSH
56253: LD_EXP 39
56257: PPUSH
56258: LD_VAR 0 4
56262: PPUSH
56263: EMPTY
56264: PPUSH
56265: CALL_OW 1
56269: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56270: LD_ADDR_EXP 40
56274: PUSH
56275: LD_EXP 40
56279: PPUSH
56280: LD_VAR 0 4
56284: PPUSH
56285: EMPTY
56286: PPUSH
56287: CALL_OW 1
56291: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56292: LD_ADDR_EXP 41
56296: PUSH
56297: LD_EXP 41
56301: PPUSH
56302: LD_VAR 0 4
56306: PPUSH
56307: EMPTY
56308: PPUSH
56309: CALL_OW 1
56313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56314: LD_ADDR_EXP 42
56318: PUSH
56319: LD_EXP 42
56323: PPUSH
56324: LD_VAR 0 4
56328: PPUSH
56329: EMPTY
56330: PPUSH
56331: CALL_OW 1
56335: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56336: LD_ADDR_EXP 43
56340: PUSH
56341: LD_EXP 43
56345: PPUSH
56346: LD_VAR 0 4
56350: PPUSH
56351: EMPTY
56352: PPUSH
56353: CALL_OW 1
56357: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56358: LD_ADDR_EXP 44
56362: PUSH
56363: LD_EXP 44
56367: PPUSH
56368: LD_VAR 0 4
56372: PPUSH
56373: EMPTY
56374: PPUSH
56375: CALL_OW 1
56379: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56380: LD_ADDR_EXP 45
56384: PUSH
56385: LD_EXP 45
56389: PPUSH
56390: LD_VAR 0 4
56394: PPUSH
56395: EMPTY
56396: PPUSH
56397: CALL_OW 1
56401: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56402: LD_ADDR_EXP 46
56406: PUSH
56407: LD_EXP 46
56411: PPUSH
56412: LD_VAR 0 4
56416: PPUSH
56417: EMPTY
56418: PPUSH
56419: CALL_OW 1
56423: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56424: LD_ADDR_EXP 47
56428: PUSH
56429: LD_EXP 47
56433: PPUSH
56434: LD_VAR 0 4
56438: PPUSH
56439: EMPTY
56440: PPUSH
56441: CALL_OW 1
56445: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56446: LD_ADDR_EXP 48
56450: PUSH
56451: LD_EXP 48
56455: PPUSH
56456: LD_VAR 0 4
56460: PPUSH
56461: EMPTY
56462: PPUSH
56463: CALL_OW 1
56467: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56468: LD_ADDR_EXP 50
56472: PUSH
56473: LD_EXP 50
56477: PPUSH
56478: LD_VAR 0 4
56482: PPUSH
56483: EMPTY
56484: PPUSH
56485: CALL_OW 1
56489: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56490: LD_ADDR_EXP 52
56494: PUSH
56495: LD_EXP 52
56499: PPUSH
56500: LD_VAR 0 4
56504: PPUSH
56505: EMPTY
56506: PPUSH
56507: CALL_OW 1
56511: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56512: LD_ADDR_EXP 53
56516: PUSH
56517: LD_EXP 53
56521: PPUSH
56522: LD_VAR 0 4
56526: PPUSH
56527: EMPTY
56528: PPUSH
56529: CALL_OW 1
56533: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56534: LD_ADDR_EXP 54
56538: PUSH
56539: LD_EXP 54
56543: PPUSH
56544: LD_VAR 0 4
56548: PPUSH
56549: EMPTY
56550: PPUSH
56551: CALL_OW 1
56555: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56556: LD_ADDR_EXP 55
56560: PUSH
56561: LD_EXP 55
56565: PPUSH
56566: LD_VAR 0 4
56570: PPUSH
56571: EMPTY
56572: PPUSH
56573: CALL_OW 1
56577: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56578: LD_ADDR_EXP 56
56582: PUSH
56583: LD_EXP 56
56587: PPUSH
56588: LD_VAR 0 4
56592: PPUSH
56593: EMPTY
56594: PPUSH
56595: CALL_OW 1
56599: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56600: LD_ADDR_EXP 57
56604: PUSH
56605: LD_EXP 57
56609: PPUSH
56610: LD_VAR 0 4
56614: PPUSH
56615: EMPTY
56616: PPUSH
56617: CALL_OW 1
56621: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56622: LD_ADDR_EXP 58
56626: PUSH
56627: LD_EXP 58
56631: PPUSH
56632: LD_VAR 0 4
56636: PPUSH
56637: EMPTY
56638: PPUSH
56639: CALL_OW 1
56643: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56644: LD_ADDR_EXP 59
56648: PUSH
56649: LD_EXP 59
56653: PPUSH
56654: LD_VAR 0 4
56658: PPUSH
56659: EMPTY
56660: PPUSH
56661: CALL_OW 1
56665: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56666: LD_ADDR_EXP 60
56670: PUSH
56671: LD_EXP 60
56675: PPUSH
56676: LD_VAR 0 4
56680: PPUSH
56681: EMPTY
56682: PPUSH
56683: CALL_OW 1
56687: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56688: LD_ADDR_EXP 61
56692: PUSH
56693: LD_EXP 61
56697: PPUSH
56698: LD_VAR 0 4
56702: PPUSH
56703: EMPTY
56704: PPUSH
56705: CALL_OW 1
56709: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56710: LD_ADDR_EXP 62
56714: PUSH
56715: LD_EXP 62
56719: PPUSH
56720: LD_VAR 0 4
56724: PPUSH
56725: EMPTY
56726: PPUSH
56727: CALL_OW 1
56731: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56732: LD_ADDR_EXP 63
56736: PUSH
56737: LD_EXP 63
56741: PPUSH
56742: LD_VAR 0 4
56746: PPUSH
56747: EMPTY
56748: PPUSH
56749: CALL_OW 1
56753: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56754: LD_ADDR_EXP 64
56758: PUSH
56759: LD_EXP 64
56763: PPUSH
56764: LD_VAR 0 4
56768: PPUSH
56769: EMPTY
56770: PPUSH
56771: CALL_OW 1
56775: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56776: LD_ADDR_EXP 65
56780: PUSH
56781: LD_EXP 65
56785: PPUSH
56786: LD_VAR 0 4
56790: PPUSH
56791: LD_INT 0
56793: PPUSH
56794: CALL_OW 1
56798: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56799: LD_ADDR_EXP 66
56803: PUSH
56804: LD_EXP 66
56808: PPUSH
56809: LD_VAR 0 4
56813: PPUSH
56814: LD_INT 0
56816: PPUSH
56817: CALL_OW 1
56821: ST_TO_ADDR
// result := base ;
56822: LD_ADDR_VAR 0 3
56826: PUSH
56827: LD_VAR 0 4
56831: ST_TO_ADDR
// end ;
56832: LD_VAR 0 3
56836: RET
// export function MC_Start ( ) ; var i ; begin
56837: LD_INT 0
56839: PPUSH
56840: PPUSH
// for i = 1 to mc_bases do
56841: LD_ADDR_VAR 0 2
56845: PUSH
56846: DOUBLE
56847: LD_INT 1
56849: DEC
56850: ST_TO_ADDR
56851: LD_EXP 23
56855: PUSH
56856: FOR_TO
56857: IFFALSE 57957
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56859: LD_ADDR_EXP 23
56863: PUSH
56864: LD_EXP 23
56868: PPUSH
56869: LD_VAR 0 2
56873: PPUSH
56874: LD_EXP 23
56878: PUSH
56879: LD_VAR 0 2
56883: ARRAY
56884: PUSH
56885: LD_INT 0
56887: DIFF
56888: PPUSH
56889: CALL_OW 1
56893: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56894: LD_ADDR_EXP 24
56898: PUSH
56899: LD_EXP 24
56903: PPUSH
56904: LD_VAR 0 2
56908: PPUSH
56909: EMPTY
56910: PPUSH
56911: CALL_OW 1
56915: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56916: LD_ADDR_EXP 25
56920: PUSH
56921: LD_EXP 25
56925: PPUSH
56926: LD_VAR 0 2
56930: PPUSH
56931: EMPTY
56932: PPUSH
56933: CALL_OW 1
56937: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56938: LD_ADDR_EXP 26
56942: PUSH
56943: LD_EXP 26
56947: PPUSH
56948: LD_VAR 0 2
56952: PPUSH
56953: EMPTY
56954: PPUSH
56955: CALL_OW 1
56959: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56960: LD_ADDR_EXP 27
56964: PUSH
56965: LD_EXP 27
56969: PPUSH
56970: LD_VAR 0 2
56974: PPUSH
56975: EMPTY
56976: PUSH
56977: EMPTY
56978: PUSH
56979: EMPTY
56980: LIST
56981: LIST
56982: PPUSH
56983: CALL_OW 1
56987: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56988: LD_ADDR_EXP 28
56992: PUSH
56993: LD_EXP 28
56997: PPUSH
56998: LD_VAR 0 2
57002: PPUSH
57003: EMPTY
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57010: LD_ADDR_EXP 55
57014: PUSH
57015: LD_EXP 55
57019: PPUSH
57020: LD_VAR 0 2
57024: PPUSH
57025: EMPTY
57026: PPUSH
57027: CALL_OW 1
57031: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57032: LD_ADDR_EXP 29
57036: PUSH
57037: LD_EXP 29
57041: PPUSH
57042: LD_VAR 0 2
57046: PPUSH
57047: EMPTY
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57054: LD_ADDR_EXP 30
57058: PUSH
57059: LD_EXP 30
57063: PPUSH
57064: LD_VAR 0 2
57068: PPUSH
57069: EMPTY
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57076: LD_ADDR_EXP 31
57080: PUSH
57081: LD_EXP 31
57085: PPUSH
57086: LD_VAR 0 2
57090: PPUSH
57091: LD_EXP 23
57095: PUSH
57096: LD_VAR 0 2
57100: ARRAY
57101: PPUSH
57102: LD_INT 2
57104: PUSH
57105: LD_INT 30
57107: PUSH
57108: LD_INT 32
57110: PUSH
57111: EMPTY
57112: LIST
57113: LIST
57114: PUSH
57115: LD_INT 30
57117: PUSH
57118: LD_INT 33
57120: PUSH
57121: EMPTY
57122: LIST
57123: LIST
57124: PUSH
57125: EMPTY
57126: LIST
57127: LIST
57128: LIST
57129: PPUSH
57130: CALL_OW 72
57134: PPUSH
57135: CALL_OW 1
57139: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57140: LD_ADDR_EXP 32
57144: PUSH
57145: LD_EXP 32
57149: PPUSH
57150: LD_VAR 0 2
57154: PPUSH
57155: LD_EXP 23
57159: PUSH
57160: LD_VAR 0 2
57164: ARRAY
57165: PPUSH
57166: LD_INT 2
57168: PUSH
57169: LD_INT 30
57171: PUSH
57172: LD_INT 32
57174: PUSH
57175: EMPTY
57176: LIST
57177: LIST
57178: PUSH
57179: LD_INT 30
57181: PUSH
57182: LD_INT 31
57184: PUSH
57185: EMPTY
57186: LIST
57187: LIST
57188: PUSH
57189: EMPTY
57190: LIST
57191: LIST
57192: LIST
57193: PUSH
57194: LD_INT 58
57196: PUSH
57197: EMPTY
57198: LIST
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: PPUSH
57204: CALL_OW 72
57208: PPUSH
57209: CALL_OW 1
57213: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57214: LD_ADDR_EXP 33
57218: PUSH
57219: LD_EXP 33
57223: PPUSH
57224: LD_VAR 0 2
57228: PPUSH
57229: EMPTY
57230: PPUSH
57231: CALL_OW 1
57235: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57236: LD_ADDR_EXP 37
57240: PUSH
57241: LD_EXP 37
57245: PPUSH
57246: LD_VAR 0 2
57250: PPUSH
57251: EMPTY
57252: PPUSH
57253: CALL_OW 1
57257: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57258: LD_ADDR_EXP 36
57262: PUSH
57263: LD_EXP 36
57267: PPUSH
57268: LD_VAR 0 2
57272: PPUSH
57273: EMPTY
57274: PPUSH
57275: CALL_OW 1
57279: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57280: LD_ADDR_EXP 38
57284: PUSH
57285: LD_EXP 38
57289: PPUSH
57290: LD_VAR 0 2
57294: PPUSH
57295: EMPTY
57296: PPUSH
57297: CALL_OW 1
57301: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57302: LD_ADDR_EXP 39
57306: PUSH
57307: LD_EXP 39
57311: PPUSH
57312: LD_VAR 0 2
57316: PPUSH
57317: EMPTY
57318: PPUSH
57319: CALL_OW 1
57323: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57324: LD_ADDR_EXP 40
57328: PUSH
57329: LD_EXP 40
57333: PPUSH
57334: LD_VAR 0 2
57338: PPUSH
57339: EMPTY
57340: PPUSH
57341: CALL_OW 1
57345: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57346: LD_ADDR_EXP 41
57350: PUSH
57351: LD_EXP 41
57355: PPUSH
57356: LD_VAR 0 2
57360: PPUSH
57361: EMPTY
57362: PPUSH
57363: CALL_OW 1
57367: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57368: LD_ADDR_EXP 42
57372: PUSH
57373: LD_EXP 42
57377: PPUSH
57378: LD_VAR 0 2
57382: PPUSH
57383: EMPTY
57384: PPUSH
57385: CALL_OW 1
57389: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57390: LD_ADDR_EXP 43
57394: PUSH
57395: LD_EXP 43
57399: PPUSH
57400: LD_VAR 0 2
57404: PPUSH
57405: EMPTY
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57412: LD_ADDR_EXP 44
57416: PUSH
57417: LD_EXP 44
57421: PPUSH
57422: LD_VAR 0 2
57426: PPUSH
57427: EMPTY
57428: PPUSH
57429: CALL_OW 1
57433: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57434: LD_ADDR_EXP 45
57438: PUSH
57439: LD_EXP 45
57443: PPUSH
57444: LD_VAR 0 2
57448: PPUSH
57449: EMPTY
57450: PPUSH
57451: CALL_OW 1
57455: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57456: LD_ADDR_EXP 34
57460: PUSH
57461: LD_EXP 34
57465: PPUSH
57466: LD_VAR 0 2
57470: PPUSH
57471: LD_INT 0
57473: PPUSH
57474: CALL_OW 1
57478: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57479: LD_ADDR_EXP 47
57483: PUSH
57484: LD_EXP 47
57488: PPUSH
57489: LD_VAR 0 2
57493: PPUSH
57494: LD_INT 0
57496: PPUSH
57497: CALL_OW 1
57501: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57502: LD_ADDR_EXP 35
57506: PUSH
57507: LD_EXP 35
57511: PPUSH
57512: LD_VAR 0 2
57516: PPUSH
57517: EMPTY
57518: PPUSH
57519: CALL_OW 1
57523: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57524: LD_ADDR_EXP 46
57528: PUSH
57529: LD_EXP 46
57533: PPUSH
57534: LD_VAR 0 2
57538: PPUSH
57539: LD_INT 0
57541: PPUSH
57542: CALL_OW 1
57546: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57547: LD_ADDR_EXP 48
57551: PUSH
57552: LD_EXP 48
57556: PPUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: EMPTY
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57569: LD_ADDR_EXP 51
57573: PUSH
57574: LD_EXP 51
57578: PPUSH
57579: LD_VAR 0 2
57583: PPUSH
57584: LD_INT 0
57586: PPUSH
57587: CALL_OW 1
57591: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57592: LD_ADDR_EXP 52
57596: PUSH
57597: LD_EXP 52
57601: PPUSH
57602: LD_VAR 0 2
57606: PPUSH
57607: EMPTY
57608: PPUSH
57609: CALL_OW 1
57613: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57614: LD_ADDR_EXP 53
57618: PUSH
57619: LD_EXP 53
57623: PPUSH
57624: LD_VAR 0 2
57628: PPUSH
57629: EMPTY
57630: PPUSH
57631: CALL_OW 1
57635: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57636: LD_ADDR_EXP 54
57640: PUSH
57641: LD_EXP 54
57645: PPUSH
57646: LD_VAR 0 2
57650: PPUSH
57651: EMPTY
57652: PPUSH
57653: CALL_OW 1
57657: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57658: LD_ADDR_EXP 56
57662: PUSH
57663: LD_EXP 56
57667: PPUSH
57668: LD_VAR 0 2
57672: PPUSH
57673: LD_EXP 23
57677: PUSH
57678: LD_VAR 0 2
57682: ARRAY
57683: PPUSH
57684: LD_INT 2
57686: PUSH
57687: LD_INT 30
57689: PUSH
57690: LD_INT 6
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: PUSH
57697: LD_INT 30
57699: PUSH
57700: LD_INT 7
57702: PUSH
57703: EMPTY
57704: LIST
57705: LIST
57706: PUSH
57707: LD_INT 30
57709: PUSH
57710: LD_INT 8
57712: PUSH
57713: EMPTY
57714: LIST
57715: LIST
57716: PUSH
57717: EMPTY
57718: LIST
57719: LIST
57720: LIST
57721: LIST
57722: PPUSH
57723: CALL_OW 72
57727: PPUSH
57728: CALL_OW 1
57732: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57733: LD_ADDR_EXP 57
57737: PUSH
57738: LD_EXP 57
57742: PPUSH
57743: LD_VAR 0 2
57747: PPUSH
57748: EMPTY
57749: PPUSH
57750: CALL_OW 1
57754: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57755: LD_ADDR_EXP 58
57759: PUSH
57760: LD_EXP 58
57764: PPUSH
57765: LD_VAR 0 2
57769: PPUSH
57770: EMPTY
57771: PPUSH
57772: CALL_OW 1
57776: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57777: LD_ADDR_EXP 59
57781: PUSH
57782: LD_EXP 59
57786: PPUSH
57787: LD_VAR 0 2
57791: PPUSH
57792: EMPTY
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57799: LD_ADDR_EXP 60
57803: PUSH
57804: LD_EXP 60
57808: PPUSH
57809: LD_VAR 0 2
57813: PPUSH
57814: EMPTY
57815: PPUSH
57816: CALL_OW 1
57820: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57821: LD_ADDR_EXP 61
57825: PUSH
57826: LD_EXP 61
57830: PPUSH
57831: LD_VAR 0 2
57835: PPUSH
57836: EMPTY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57843: LD_ADDR_EXP 62
57847: PUSH
57848: LD_EXP 62
57852: PPUSH
57853: LD_VAR 0 2
57857: PPUSH
57858: EMPTY
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57865: LD_ADDR_EXP 63
57869: PUSH
57870: LD_EXP 63
57874: PPUSH
57875: LD_VAR 0 2
57879: PPUSH
57880: EMPTY
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57887: LD_ADDR_EXP 64
57891: PUSH
57892: LD_EXP 64
57896: PPUSH
57897: LD_VAR 0 2
57901: PPUSH
57902: EMPTY
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57909: LD_ADDR_EXP 65
57913: PUSH
57914: LD_EXP 65
57918: PPUSH
57919: LD_VAR 0 2
57923: PPUSH
57924: LD_INT 0
57926: PPUSH
57927: CALL_OW 1
57931: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57932: LD_ADDR_EXP 66
57936: PUSH
57937: LD_EXP 66
57941: PPUSH
57942: LD_VAR 0 2
57946: PPUSH
57947: LD_INT 0
57949: PPUSH
57950: CALL_OW 1
57954: ST_TO_ADDR
// end ;
57955: GO 56856
57957: POP
57958: POP
// MC_InitSides ( ) ;
57959: CALL 58245 0 0
// MC_InitResearch ( ) ;
57963: CALL 57984 0 0
// CustomInitMacro ( ) ;
57967: CALL 273 0 0
// skirmish := true ;
57971: LD_ADDR_EXP 21
57975: PUSH
57976: LD_INT 1
57978: ST_TO_ADDR
// end ;
57979: LD_VAR 0 1
57983: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57984: LD_INT 0
57986: PPUSH
57987: PPUSH
57988: PPUSH
57989: PPUSH
57990: PPUSH
57991: PPUSH
// if not mc_bases then
57992: LD_EXP 23
57996: NOT
57997: IFFALSE 58001
// exit ;
57999: GO 58240
// for i = 1 to 8 do
58001: LD_ADDR_VAR 0 2
58005: PUSH
58006: DOUBLE
58007: LD_INT 1
58009: DEC
58010: ST_TO_ADDR
58011: LD_INT 8
58013: PUSH
58014: FOR_TO
58015: IFFALSE 58041
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58017: LD_ADDR_EXP 50
58021: PUSH
58022: LD_EXP 50
58026: PPUSH
58027: LD_VAR 0 2
58031: PPUSH
58032: EMPTY
58033: PPUSH
58034: CALL_OW 1
58038: ST_TO_ADDR
58039: GO 58014
58041: POP
58042: POP
// tmp := [ ] ;
58043: LD_ADDR_VAR 0 5
58047: PUSH
58048: EMPTY
58049: ST_TO_ADDR
// for i = 1 to mc_sides do
58050: LD_ADDR_VAR 0 2
58054: PUSH
58055: DOUBLE
58056: LD_INT 1
58058: DEC
58059: ST_TO_ADDR
58060: LD_EXP 49
58064: PUSH
58065: FOR_TO
58066: IFFALSE 58124
// if not mc_sides [ i ] in tmp then
58068: LD_EXP 49
58072: PUSH
58073: LD_VAR 0 2
58077: ARRAY
58078: PUSH
58079: LD_VAR 0 5
58083: IN
58084: NOT
58085: IFFALSE 58122
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58087: LD_ADDR_VAR 0 5
58091: PUSH
58092: LD_VAR 0 5
58096: PPUSH
58097: LD_VAR 0 5
58101: PUSH
58102: LD_INT 1
58104: PLUS
58105: PPUSH
58106: LD_EXP 49
58110: PUSH
58111: LD_VAR 0 2
58115: ARRAY
58116: PPUSH
58117: CALL_OW 2
58121: ST_TO_ADDR
58122: GO 58065
58124: POP
58125: POP
// if not tmp then
58126: LD_VAR 0 5
58130: NOT
58131: IFFALSE 58135
// exit ;
58133: GO 58240
// for j in tmp do
58135: LD_ADDR_VAR 0 3
58139: PUSH
58140: LD_VAR 0 5
58144: PUSH
58145: FOR_IN
58146: IFFALSE 58238
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58148: LD_ADDR_VAR 0 6
58152: PUSH
58153: LD_INT 22
58155: PUSH
58156: LD_VAR 0 3
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: PPUSH
58165: CALL_OW 69
58169: ST_TO_ADDR
// if not un then
58170: LD_VAR 0 6
58174: NOT
58175: IFFALSE 58179
// continue ;
58177: GO 58145
// nation := GetNation ( un [ 1 ] ) ;
58179: LD_ADDR_VAR 0 4
58183: PUSH
58184: LD_VAR 0 6
58188: PUSH
58189: LD_INT 1
58191: ARRAY
58192: PPUSH
58193: CALL_OW 248
58197: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58198: LD_ADDR_EXP 50
58202: PUSH
58203: LD_EXP 50
58207: PPUSH
58208: LD_VAR 0 3
58212: PPUSH
58213: LD_VAR 0 3
58217: PPUSH
58218: LD_VAR 0 4
58222: PPUSH
58223: LD_INT 1
58225: PPUSH
58226: CALL 11294 0 3
58230: PPUSH
58231: CALL_OW 1
58235: ST_TO_ADDR
// end ;
58236: GO 58145
58238: POP
58239: POP
// end ;
58240: LD_VAR 0 1
58244: RET
// export function MC_InitSides ( ) ; var i ; begin
58245: LD_INT 0
58247: PPUSH
58248: PPUSH
// if not mc_bases then
58249: LD_EXP 23
58253: NOT
58254: IFFALSE 58258
// exit ;
58256: GO 58332
// for i = 1 to mc_bases do
58258: LD_ADDR_VAR 0 2
58262: PUSH
58263: DOUBLE
58264: LD_INT 1
58266: DEC
58267: ST_TO_ADDR
58268: LD_EXP 23
58272: PUSH
58273: FOR_TO
58274: IFFALSE 58330
// if mc_bases [ i ] then
58276: LD_EXP 23
58280: PUSH
58281: LD_VAR 0 2
58285: ARRAY
58286: IFFALSE 58328
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58288: LD_ADDR_EXP 49
58292: PUSH
58293: LD_EXP 49
58297: PPUSH
58298: LD_VAR 0 2
58302: PPUSH
58303: LD_EXP 23
58307: PUSH
58308: LD_VAR 0 2
58312: ARRAY
58313: PUSH
58314: LD_INT 1
58316: ARRAY
58317: PPUSH
58318: CALL_OW 255
58322: PPUSH
58323: CALL_OW 1
58327: ST_TO_ADDR
58328: GO 58273
58330: POP
58331: POP
// end ;
58332: LD_VAR 0 1
58336: RET
// every 0 0$03 trigger skirmish do
58337: LD_EXP 21
58341: IFFALSE 58495
58343: GO 58345
58345: DISABLE
// begin enable ;
58346: ENABLE
// MC_CheckBuildings ( ) ;
58347: CALL 63053 0 0
// MC_CheckPeopleLife ( ) ;
58351: CALL 63214 0 0
// RaiseSailEvent ( 100 ) ;
58355: LD_INT 100
58357: PPUSH
58358: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58362: LD_INT 103
58364: PPUSH
58365: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58369: LD_INT 104
58371: PPUSH
58372: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58376: LD_INT 105
58378: PPUSH
58379: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58383: LD_INT 106
58385: PPUSH
58386: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58390: LD_INT 107
58392: PPUSH
58393: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58397: LD_INT 108
58399: PPUSH
58400: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58404: LD_INT 109
58406: PPUSH
58407: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58411: LD_INT 110
58413: PPUSH
58414: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58418: LD_INT 111
58420: PPUSH
58421: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58425: LD_INT 112
58427: PPUSH
58428: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58432: LD_INT 113
58434: PPUSH
58435: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58439: LD_INT 120
58441: PPUSH
58442: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58446: LD_INT 121
58448: PPUSH
58449: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58453: LD_INT 122
58455: PPUSH
58456: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58460: LD_INT 123
58462: PPUSH
58463: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58467: LD_INT 124
58469: PPUSH
58470: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58474: LD_INT 125
58476: PPUSH
58477: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58481: LD_INT 126
58483: PPUSH
58484: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58488: LD_INT 200
58490: PPUSH
58491: CALL_OW 427
// end ;
58495: END
// on SailEvent ( event ) do begin if event < 100 then
58496: LD_VAR 0 1
58500: PUSH
58501: LD_INT 100
58503: LESS
58504: IFFALSE 58515
// CustomEvent ( event ) ;
58506: LD_VAR 0 1
58510: PPUSH
58511: CALL 10353 0 1
// if event = 100 then
58515: LD_VAR 0 1
58519: PUSH
58520: LD_INT 100
58522: EQUAL
58523: IFFALSE 58529
// MC_ClassManager ( ) ;
58525: CALL 58923 0 0
// if event = 101 then
58529: LD_VAR 0 1
58533: PUSH
58534: LD_INT 101
58536: EQUAL
58537: IFFALSE 58543
// MC_RepairBuildings ( ) ;
58539: CALL 63801 0 0
// if event = 102 then
58543: LD_VAR 0 1
58547: PUSH
58548: LD_INT 102
58550: EQUAL
58551: IFFALSE 58557
// MC_Heal ( ) ;
58553: CALL 64740 0 0
// if event = 103 then
58557: LD_VAR 0 1
58561: PUSH
58562: LD_INT 103
58564: EQUAL
58565: IFFALSE 58571
// MC_Build ( ) ;
58567: CALL 65166 0 0
// if event = 104 then
58571: LD_VAR 0 1
58575: PUSH
58576: LD_INT 104
58578: EQUAL
58579: IFFALSE 58585
// MC_TurretWeapon ( ) ;
58581: CALL 66814 0 0
// if event = 105 then
58585: LD_VAR 0 1
58589: PUSH
58590: LD_INT 105
58592: EQUAL
58593: IFFALSE 58599
// MC_BuildUpgrade ( ) ;
58595: CALL 66359 0 0
// if event = 106 then
58599: LD_VAR 0 1
58603: PUSH
58604: LD_INT 106
58606: EQUAL
58607: IFFALSE 58613
// MC_PlantMines ( ) ;
58609: CALL 67246 0 0
// if event = 107 then
58613: LD_VAR 0 1
58617: PUSH
58618: LD_INT 107
58620: EQUAL
58621: IFFALSE 58627
// MC_CollectCrates ( ) ;
58623: CALL 68056 0 0
// if event = 108 then
58627: LD_VAR 0 1
58631: PUSH
58632: LD_INT 108
58634: EQUAL
58635: IFFALSE 58641
// MC_LinkRemoteControl ( ) ;
58637: CALL 69930 0 0
// if event = 109 then
58641: LD_VAR 0 1
58645: PUSH
58646: LD_INT 109
58648: EQUAL
58649: IFFALSE 58655
// MC_ProduceVehicle ( ) ;
58651: CALL 70115 0 0
// if event = 110 then
58655: LD_VAR 0 1
58659: PUSH
58660: LD_INT 110
58662: EQUAL
58663: IFFALSE 58669
// MC_SendAttack ( ) ;
58665: CALL 70585 0 0
// if event = 111 then
58669: LD_VAR 0 1
58673: PUSH
58674: LD_INT 111
58676: EQUAL
58677: IFFALSE 58683
// MC_Defend ( ) ;
58679: CALL 70693 0 0
// if event = 112 then
58683: LD_VAR 0 1
58687: PUSH
58688: LD_INT 112
58690: EQUAL
58691: IFFALSE 58697
// MC_Research ( ) ;
58693: CALL 71593 0 0
// if event = 113 then
58697: LD_VAR 0 1
58701: PUSH
58702: LD_INT 113
58704: EQUAL
58705: IFFALSE 58711
// MC_MinesTrigger ( ) ;
58707: CALL 72733 0 0
// if event = 120 then
58711: LD_VAR 0 1
58715: PUSH
58716: LD_INT 120
58718: EQUAL
58719: IFFALSE 58725
// MC_RepairVehicle ( ) ;
58721: CALL 72834 0 0
// if event = 121 then
58725: LD_VAR 0 1
58729: PUSH
58730: LD_INT 121
58732: EQUAL
58733: IFFALSE 58739
// MC_TameApe ( ) ;
58735: CALL 73611 0 0
// if event = 122 then
58739: LD_VAR 0 1
58743: PUSH
58744: LD_INT 122
58746: EQUAL
58747: IFFALSE 58753
// MC_ChangeApeClass ( ) ;
58749: CALL 74456 0 0
// if event = 123 then
58753: LD_VAR 0 1
58757: PUSH
58758: LD_INT 123
58760: EQUAL
58761: IFFALSE 58767
// MC_Bazooka ( ) ;
58763: CALL 75112 0 0
// if event = 124 then
58767: LD_VAR 0 1
58771: PUSH
58772: LD_INT 124
58774: EQUAL
58775: IFFALSE 58781
// MC_TeleportExit ( ) ;
58777: CALL 75314 0 0
// if event = 125 then
58781: LD_VAR 0 1
58785: PUSH
58786: LD_INT 125
58788: EQUAL
58789: IFFALSE 58795
// MC_Deposits ( ) ;
58791: CALL 75971 0 0
// if event = 126 then
58795: LD_VAR 0 1
58799: PUSH
58800: LD_INT 126
58802: EQUAL
58803: IFFALSE 58809
// MC_RemoteDriver ( ) ;
58805: CALL 76604 0 0
// if event = 200 then
58809: LD_VAR 0 1
58813: PUSH
58814: LD_INT 200
58816: EQUAL
58817: IFFALSE 58823
// MC_Idle ( ) ;
58819: CALL 78539 0 0
// end ;
58823: PPOPN 1
58825: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58826: LD_INT 0
58828: PPUSH
58829: PPUSH
// if not mc_bases [ base ] or not tag then
58830: LD_EXP 23
58834: PUSH
58835: LD_VAR 0 1
58839: ARRAY
58840: NOT
58841: IFTRUE 58850
58843: PUSH
58844: LD_VAR 0 2
58848: NOT
58849: OR
58850: IFFALSE 58854
// exit ;
58852: GO 58918
// for i in mc_bases [ base ] union mc_ape [ base ] do
58854: LD_ADDR_VAR 0 4
58858: PUSH
58859: LD_EXP 23
58863: PUSH
58864: LD_VAR 0 1
58868: ARRAY
58869: PUSH
58870: LD_EXP 52
58874: PUSH
58875: LD_VAR 0 1
58879: ARRAY
58880: UNION
58881: PUSH
58882: FOR_IN
58883: IFFALSE 58916
// if GetTag ( i ) = tag then
58885: LD_VAR 0 4
58889: PPUSH
58890: CALL_OW 110
58894: PUSH
58895: LD_VAR 0 2
58899: EQUAL
58900: IFFALSE 58914
// SetTag ( i , 0 ) ;
58902: LD_VAR 0 4
58906: PPUSH
58907: LD_INT 0
58909: PPUSH
58910: CALL_OW 109
58914: GO 58882
58916: POP
58917: POP
// end ;
58918: LD_VAR 0 3
58922: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58923: LD_INT 0
58925: PPUSH
58926: PPUSH
58927: PPUSH
58928: PPUSH
58929: PPUSH
58930: PPUSH
58931: PPUSH
58932: PPUSH
// if not mc_bases then
58933: LD_EXP 23
58937: NOT
58938: IFFALSE 58942
// exit ;
58940: GO 59393
// for i = 1 to mc_bases do
58942: LD_ADDR_VAR 0 2
58946: PUSH
58947: DOUBLE
58948: LD_INT 1
58950: DEC
58951: ST_TO_ADDR
58952: LD_EXP 23
58956: PUSH
58957: FOR_TO
58958: IFFALSE 59391
// begin tmp := MC_ClassCheckReq ( i ) ;
58960: LD_ADDR_VAR 0 4
58964: PUSH
58965: LD_VAR 0 2
58969: PPUSH
58970: CALL 59398 0 1
58974: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58975: LD_ADDR_EXP 64
58979: PUSH
58980: LD_EXP 64
58984: PPUSH
58985: LD_VAR 0 2
58989: PPUSH
58990: LD_VAR 0 4
58994: PPUSH
58995: CALL_OW 1
58999: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59000: LD_ADDR_VAR 0 6
59004: PUSH
59005: LD_EXP 23
59009: PUSH
59010: LD_VAR 0 2
59014: ARRAY
59015: PPUSH
59016: LD_INT 2
59018: PUSH
59019: LD_INT 30
59021: PUSH
59022: LD_INT 4
59024: PUSH
59025: EMPTY
59026: LIST
59027: LIST
59028: PUSH
59029: LD_INT 30
59031: PUSH
59032: LD_INT 5
59034: PUSH
59035: EMPTY
59036: LIST
59037: LIST
59038: PUSH
59039: EMPTY
59040: LIST
59041: LIST
59042: LIST
59043: PPUSH
59044: CALL_OW 72
59048: PUSH
59049: LD_EXP 23
59053: PUSH
59054: LD_VAR 0 2
59058: ARRAY
59059: PPUSH
59060: LD_INT 2
59062: PUSH
59063: LD_INT 30
59065: PUSH
59066: LD_INT 0
59068: PUSH
59069: EMPTY
59070: LIST
59071: LIST
59072: PUSH
59073: LD_INT 30
59075: PUSH
59076: LD_INT 1
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: PUSH
59083: EMPTY
59084: LIST
59085: LIST
59086: LIST
59087: PPUSH
59088: CALL_OW 72
59092: PUSH
59093: LD_EXP 23
59097: PUSH
59098: LD_VAR 0 2
59102: ARRAY
59103: PPUSH
59104: LD_INT 30
59106: PUSH
59107: LD_INT 3
59109: PUSH
59110: EMPTY
59111: LIST
59112: LIST
59113: PPUSH
59114: CALL_OW 72
59118: PUSH
59119: LD_EXP 23
59123: PUSH
59124: LD_VAR 0 2
59128: ARRAY
59129: PPUSH
59130: LD_INT 2
59132: PUSH
59133: LD_INT 30
59135: PUSH
59136: LD_INT 6
59138: PUSH
59139: EMPTY
59140: LIST
59141: LIST
59142: PUSH
59143: LD_INT 30
59145: PUSH
59146: LD_INT 7
59148: PUSH
59149: EMPTY
59150: LIST
59151: LIST
59152: PUSH
59153: LD_INT 30
59155: PUSH
59156: LD_INT 8
59158: PUSH
59159: EMPTY
59160: LIST
59161: LIST
59162: PUSH
59163: EMPTY
59164: LIST
59165: LIST
59166: LIST
59167: LIST
59168: PPUSH
59169: CALL_OW 72
59173: PUSH
59174: EMPTY
59175: LIST
59176: LIST
59177: LIST
59178: LIST
59179: ST_TO_ADDR
// for j := 1 to 4 do
59180: LD_ADDR_VAR 0 3
59184: PUSH
59185: DOUBLE
59186: LD_INT 1
59188: DEC
59189: ST_TO_ADDR
59190: LD_INT 4
59192: PUSH
59193: FOR_TO
59194: IFFALSE 59387
// begin if not tmp [ j ] then
59196: LD_VAR 0 4
59200: PUSH
59201: LD_VAR 0 3
59205: ARRAY
59206: NOT
59207: IFFALSE 59211
// continue ;
59209: GO 59193
// for p in tmp [ j ] do
59211: LD_ADDR_VAR 0 5
59215: PUSH
59216: LD_VAR 0 4
59220: PUSH
59221: LD_VAR 0 3
59225: ARRAY
59226: PUSH
59227: FOR_IN
59228: IFFALSE 59383
// begin if not b [ j ] then
59230: LD_VAR 0 6
59234: PUSH
59235: LD_VAR 0 3
59239: ARRAY
59240: NOT
59241: IFFALSE 59245
// break ;
59243: GO 59383
// e := 0 ;
59245: LD_ADDR_VAR 0 7
59249: PUSH
59250: LD_INT 0
59252: ST_TO_ADDR
// for k in b [ j ] do
59253: LD_ADDR_VAR 0 8
59257: PUSH
59258: LD_VAR 0 6
59262: PUSH
59263: LD_VAR 0 3
59267: ARRAY
59268: PUSH
59269: FOR_IN
59270: IFFALSE 59297
// if IsNotFull ( k ) then
59272: LD_VAR 0 8
59276: PPUSH
59277: CALL 13453 0 1
59281: IFFALSE 59295
// begin e := k ;
59283: LD_ADDR_VAR 0 7
59287: PUSH
59288: LD_VAR 0 8
59292: ST_TO_ADDR
// break ;
59293: GO 59297
// end ;
59295: GO 59269
59297: POP
59298: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59299: LD_VAR 0 7
59303: IFFALSE 59322
59305: PUSH
59306: LD_VAR 0 5
59310: PPUSH
59311: LD_VAR 0 7
59315: PPUSH
59316: CALL 47913 0 2
59320: NOT
59321: AND
59322: IFFALSE 59381
// begin if IsInUnit ( p ) then
59324: LD_VAR 0 5
59328: PPUSH
59329: CALL_OW 310
59333: IFFALSE 59344
// ComExitBuilding ( p ) ;
59335: LD_VAR 0 5
59339: PPUSH
59340: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59344: LD_VAR 0 5
59348: PPUSH
59349: LD_VAR 0 7
59353: PPUSH
59354: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59358: LD_VAR 0 5
59362: PPUSH
59363: LD_VAR 0 3
59367: PPUSH
59368: CALL_OW 183
// AddComExitBuilding ( p ) ;
59372: LD_VAR 0 5
59376: PPUSH
59377: CALL_OW 182
// end ; end ;
59381: GO 59227
59383: POP
59384: POP
// end ;
59385: GO 59193
59387: POP
59388: POP
// end ;
59389: GO 58957
59391: POP
59392: POP
// end ;
59393: LD_VAR 0 1
59397: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59398: LD_INT 0
59400: PPUSH
59401: PPUSH
59402: PPUSH
59403: PPUSH
59404: PPUSH
59405: PPUSH
59406: PPUSH
59407: PPUSH
59408: PPUSH
59409: PPUSH
59410: PPUSH
59411: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59412: LD_ADDR_VAR 0 2
59416: PUSH
59417: LD_INT 0
59419: PUSH
59420: LD_INT 0
59422: PUSH
59423: LD_INT 0
59425: PUSH
59426: LD_INT 0
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: LIST
59433: LIST
59434: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59435: LD_VAR 0 1
59439: NOT
59440: IFTRUE 59455
59442: PUSH
59443: LD_EXP 23
59447: PUSH
59448: LD_VAR 0 1
59452: ARRAY
59453: NOT
59454: OR
59455: IFTRUE 59503
59457: PUSH
59458: LD_EXP 23
59462: PUSH
59463: LD_VAR 0 1
59467: ARRAY
59468: PPUSH
59469: LD_INT 2
59471: PUSH
59472: LD_INT 30
59474: PUSH
59475: LD_INT 0
59477: PUSH
59478: EMPTY
59479: LIST
59480: LIST
59481: PUSH
59482: LD_INT 30
59484: PUSH
59485: LD_INT 1
59487: PUSH
59488: EMPTY
59489: LIST
59490: LIST
59491: PUSH
59492: EMPTY
59493: LIST
59494: LIST
59495: LIST
59496: PPUSH
59497: CALL_OW 72
59501: NOT
59502: OR
59503: IFFALSE 59507
// exit ;
59505: GO 63048
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59507: LD_ADDR_VAR 0 4
59511: PUSH
59512: LD_EXP 23
59516: PUSH
59517: LD_VAR 0 1
59521: ARRAY
59522: PPUSH
59523: LD_INT 2
59525: PUSH
59526: LD_INT 25
59528: PUSH
59529: LD_INT 1
59531: PUSH
59532: EMPTY
59533: LIST
59534: LIST
59535: PUSH
59536: LD_INT 25
59538: PUSH
59539: LD_INT 2
59541: PUSH
59542: EMPTY
59543: LIST
59544: LIST
59545: PUSH
59546: LD_INT 25
59548: PUSH
59549: LD_INT 3
59551: PUSH
59552: EMPTY
59553: LIST
59554: LIST
59555: PUSH
59556: LD_INT 25
59558: PUSH
59559: LD_INT 4
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PUSH
59566: LD_INT 25
59568: PUSH
59569: LD_INT 5
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: LD_INT 25
59578: PUSH
59579: LD_INT 8
59581: PUSH
59582: EMPTY
59583: LIST
59584: LIST
59585: PUSH
59586: LD_INT 25
59588: PUSH
59589: LD_INT 9
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: PUSH
59596: EMPTY
59597: LIST
59598: LIST
59599: LIST
59600: LIST
59601: LIST
59602: LIST
59603: LIST
59604: LIST
59605: PPUSH
59606: CALL_OW 72
59610: ST_TO_ADDR
// if not tmp then
59611: LD_VAR 0 4
59615: NOT
59616: IFFALSE 59620
// exit ;
59618: GO 63048
// for i in tmp do
59620: LD_ADDR_VAR 0 3
59624: PUSH
59625: LD_VAR 0 4
59629: PUSH
59630: FOR_IN
59631: IFFALSE 59662
// if GetTag ( i ) then
59633: LD_VAR 0 3
59637: PPUSH
59638: CALL_OW 110
59642: IFFALSE 59660
// tmp := tmp diff i ;
59644: LD_ADDR_VAR 0 4
59648: PUSH
59649: LD_VAR 0 4
59653: PUSH
59654: LD_VAR 0 3
59658: DIFF
59659: ST_TO_ADDR
59660: GO 59630
59662: POP
59663: POP
// if not tmp then
59664: LD_VAR 0 4
59668: NOT
59669: IFFALSE 59673
// exit ;
59671: GO 63048
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59673: LD_ADDR_VAR 0 5
59677: PUSH
59678: LD_EXP 23
59682: PUSH
59683: LD_VAR 0 1
59687: ARRAY
59688: PPUSH
59689: LD_INT 2
59691: PUSH
59692: LD_INT 25
59694: PUSH
59695: LD_INT 1
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: PUSH
59702: LD_INT 25
59704: PUSH
59705: LD_INT 5
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: LD_INT 25
59714: PUSH
59715: LD_INT 8
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: LD_INT 25
59724: PUSH
59725: LD_INT 9
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: PUSH
59732: EMPTY
59733: LIST
59734: LIST
59735: LIST
59736: LIST
59737: LIST
59738: PPUSH
59739: CALL_OW 72
59743: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59744: LD_ADDR_VAR 0 6
59748: PUSH
59749: LD_EXP 23
59753: PUSH
59754: LD_VAR 0 1
59758: ARRAY
59759: PPUSH
59760: LD_INT 25
59762: PUSH
59763: LD_INT 2
59765: PUSH
59766: EMPTY
59767: LIST
59768: LIST
59769: PPUSH
59770: CALL_OW 72
59774: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59775: LD_ADDR_VAR 0 7
59779: PUSH
59780: LD_EXP 23
59784: PUSH
59785: LD_VAR 0 1
59789: ARRAY
59790: PPUSH
59791: LD_INT 25
59793: PUSH
59794: LD_INT 3
59796: PUSH
59797: EMPTY
59798: LIST
59799: LIST
59800: PPUSH
59801: CALL_OW 72
59805: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59806: LD_ADDR_VAR 0 8
59810: PUSH
59811: LD_EXP 23
59815: PUSH
59816: LD_VAR 0 1
59820: ARRAY
59821: PPUSH
59822: LD_INT 25
59824: PUSH
59825: LD_INT 4
59827: PUSH
59828: EMPTY
59829: LIST
59830: LIST
59831: PUSH
59832: LD_INT 24
59834: PUSH
59835: LD_INT 251
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PPUSH
59846: CALL_OW 72
59850: ST_TO_ADDR
// if mc_is_defending [ base ] then
59851: LD_EXP 66
59855: PUSH
59856: LD_VAR 0 1
59860: ARRAY
59861: IFFALSE 60322
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59863: LD_ADDR_EXP 65
59867: PUSH
59868: LD_EXP 65
59872: PPUSH
59873: LD_VAR 0 1
59877: PPUSH
59878: LD_INT 4
59880: PPUSH
59881: CALL_OW 1
59885: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59886: LD_ADDR_VAR 0 12
59890: PUSH
59891: LD_EXP 23
59895: PUSH
59896: LD_VAR 0 1
59900: ARRAY
59901: PPUSH
59902: LD_INT 2
59904: PUSH
59905: LD_INT 30
59907: PUSH
59908: LD_INT 4
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: LD_INT 30
59917: PUSH
59918: LD_INT 5
59920: PUSH
59921: EMPTY
59922: LIST
59923: LIST
59924: PUSH
59925: EMPTY
59926: LIST
59927: LIST
59928: LIST
59929: PPUSH
59930: CALL_OW 72
59934: ST_TO_ADDR
// if not b then
59935: LD_VAR 0 12
59939: NOT
59940: IFFALSE 59944
// exit ;
59942: GO 63048
// p := [ ] ;
59944: LD_ADDR_VAR 0 11
59948: PUSH
59949: EMPTY
59950: ST_TO_ADDR
// if sci >= 2 then
59951: LD_VAR 0 8
59955: PUSH
59956: LD_INT 2
59958: GREATEREQUAL
59959: IFFALSE 59990
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59961: LD_ADDR_VAR 0 8
59965: PUSH
59966: LD_VAR 0 8
59970: PUSH
59971: LD_INT 1
59973: ARRAY
59974: PUSH
59975: LD_VAR 0 8
59979: PUSH
59980: LD_INT 2
59982: ARRAY
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: ST_TO_ADDR
59988: GO 60051
// if sci = 1 then
59990: LD_VAR 0 8
59994: PUSH
59995: LD_INT 1
59997: EQUAL
59998: IFFALSE 60019
// sci := [ sci [ 1 ] ] else
60000: LD_ADDR_VAR 0 8
60004: PUSH
60005: LD_VAR 0 8
60009: PUSH
60010: LD_INT 1
60012: ARRAY
60013: PUSH
60014: EMPTY
60015: LIST
60016: ST_TO_ADDR
60017: GO 60051
// if sci = 0 then
60019: LD_VAR 0 8
60023: PUSH
60024: LD_INT 0
60026: EQUAL
60027: IFFALSE 60051
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60029: LD_ADDR_VAR 0 11
60033: PUSH
60034: LD_VAR 0 4
60038: PPUSH
60039: LD_INT 4
60041: PPUSH
60042: CALL 47783 0 2
60046: PUSH
60047: LD_INT 1
60049: ARRAY
60050: ST_TO_ADDR
// if eng > 4 then
60051: LD_VAR 0 6
60055: PUSH
60056: LD_INT 4
60058: GREATER
60059: IFFALSE 60105
// for i = eng downto 4 do
60061: LD_ADDR_VAR 0 3
60065: PUSH
60066: DOUBLE
60067: LD_VAR 0 6
60071: INC
60072: ST_TO_ADDR
60073: LD_INT 4
60075: PUSH
60076: FOR_DOWNTO
60077: IFFALSE 60103
// eng := eng diff eng [ i ] ;
60079: LD_ADDR_VAR 0 6
60083: PUSH
60084: LD_VAR 0 6
60088: PUSH
60089: LD_VAR 0 6
60093: PUSH
60094: LD_VAR 0 3
60098: ARRAY
60099: DIFF
60100: ST_TO_ADDR
60101: GO 60076
60103: POP
60104: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60105: LD_ADDR_VAR 0 4
60109: PUSH
60110: LD_VAR 0 4
60114: PUSH
60115: LD_VAR 0 5
60119: PUSH
60120: LD_VAR 0 6
60124: UNION
60125: PUSH
60126: LD_VAR 0 7
60130: UNION
60131: PUSH
60132: LD_VAR 0 8
60136: UNION
60137: DIFF
60138: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60139: LD_ADDR_VAR 0 13
60143: PUSH
60144: LD_EXP 23
60148: PUSH
60149: LD_VAR 0 1
60153: ARRAY
60154: PPUSH
60155: LD_INT 2
60157: PUSH
60158: LD_INT 30
60160: PUSH
60161: LD_INT 32
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PUSH
60168: LD_INT 30
60170: PUSH
60171: LD_INT 31
60173: PUSH
60174: EMPTY
60175: LIST
60176: LIST
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: LIST
60182: PPUSH
60183: CALL_OW 72
60187: PUSH
60188: LD_EXP 23
60192: PUSH
60193: LD_VAR 0 1
60197: ARRAY
60198: PPUSH
60199: LD_INT 2
60201: PUSH
60202: LD_INT 30
60204: PUSH
60205: LD_INT 4
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 5
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: EMPTY
60223: LIST
60224: LIST
60225: LIST
60226: PPUSH
60227: CALL_OW 72
60231: PUSH
60232: LD_INT 6
60234: MUL
60235: PLUS
60236: ST_TO_ADDR
// if bcount < tmp then
60237: LD_VAR 0 13
60241: PUSH
60242: LD_VAR 0 4
60246: LESS
60247: IFFALSE 60293
// for i = tmp downto bcount do
60249: LD_ADDR_VAR 0 3
60253: PUSH
60254: DOUBLE
60255: LD_VAR 0 4
60259: INC
60260: ST_TO_ADDR
60261: LD_VAR 0 13
60265: PUSH
60266: FOR_DOWNTO
60267: IFFALSE 60291
// tmp := Delete ( tmp , tmp ) ;
60269: LD_ADDR_VAR 0 4
60273: PUSH
60274: LD_VAR 0 4
60278: PPUSH
60279: LD_VAR 0 4
60283: PPUSH
60284: CALL_OW 3
60288: ST_TO_ADDR
60289: GO 60266
60291: POP
60292: POP
// result := [ tmp , 0 , 0 , p ] ;
60293: LD_ADDR_VAR 0 2
60297: PUSH
60298: LD_VAR 0 4
60302: PUSH
60303: LD_INT 0
60305: PUSH
60306: LD_INT 0
60308: PUSH
60309: LD_VAR 0 11
60313: PUSH
60314: EMPTY
60315: LIST
60316: LIST
60317: LIST
60318: LIST
60319: ST_TO_ADDR
// exit ;
60320: GO 63048
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60322: LD_EXP 23
60326: PUSH
60327: LD_VAR 0 1
60331: ARRAY
60332: PPUSH
60333: LD_INT 2
60335: PUSH
60336: LD_INT 30
60338: PUSH
60339: LD_INT 6
60341: PUSH
60342: EMPTY
60343: LIST
60344: LIST
60345: PUSH
60346: LD_INT 30
60348: PUSH
60349: LD_INT 7
60351: PUSH
60352: EMPTY
60353: LIST
60354: LIST
60355: PUSH
60356: LD_INT 30
60358: PUSH
60359: LD_INT 8
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PUSH
60366: EMPTY
60367: LIST
60368: LIST
60369: LIST
60370: LIST
60371: PPUSH
60372: CALL_OW 72
60376: NOT
60377: IFFALSE 60407
60379: PUSH
60380: LD_EXP 23
60384: PUSH
60385: LD_VAR 0 1
60389: ARRAY
60390: PPUSH
60391: LD_INT 30
60393: PUSH
60394: LD_INT 3
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: PPUSH
60401: CALL_OW 72
60405: NOT
60406: AND
60407: IFFALSE 60479
// begin if eng = tmp then
60409: LD_VAR 0 6
60413: PUSH
60414: LD_VAR 0 4
60418: EQUAL
60419: IFFALSE 60423
// exit ;
60421: GO 63048
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60423: LD_ADDR_EXP 65
60427: PUSH
60428: LD_EXP 65
60432: PPUSH
60433: LD_VAR 0 1
60437: PPUSH
60438: LD_INT 1
60440: PPUSH
60441: CALL_OW 1
60445: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60446: LD_ADDR_VAR 0 2
60450: PUSH
60451: LD_INT 0
60453: PUSH
60454: LD_VAR 0 4
60458: PUSH
60459: LD_VAR 0 6
60463: DIFF
60464: PUSH
60465: LD_INT 0
60467: PUSH
60468: LD_INT 0
60470: PUSH
60471: EMPTY
60472: LIST
60473: LIST
60474: LIST
60475: LIST
60476: ST_TO_ADDR
// exit ;
60477: GO 63048
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60479: LD_EXP 50
60483: PUSH
60484: LD_EXP 49
60488: PUSH
60489: LD_VAR 0 1
60493: ARRAY
60494: ARRAY
60495: IFFALSE 60553
60497: PUSH
60498: LD_EXP 23
60502: PUSH
60503: LD_VAR 0 1
60507: ARRAY
60508: PPUSH
60509: LD_INT 2
60511: PUSH
60512: LD_INT 30
60514: PUSH
60515: LD_INT 6
60517: PUSH
60518: EMPTY
60519: LIST
60520: LIST
60521: PUSH
60522: LD_INT 30
60524: PUSH
60525: LD_INT 7
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PUSH
60532: LD_INT 30
60534: PUSH
60535: LD_INT 8
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: PUSH
60542: EMPTY
60543: LIST
60544: LIST
60545: LIST
60546: LIST
60547: PPUSH
60548: CALL_OW 72
60552: AND
60553: IFFALSE 60583
60555: PUSH
60556: LD_EXP 23
60560: PUSH
60561: LD_VAR 0 1
60565: ARRAY
60566: PPUSH
60567: LD_INT 30
60569: PUSH
60570: LD_INT 3
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PPUSH
60577: CALL_OW 72
60581: NOT
60582: AND
60583: IFFALSE 60799
// begin if sci >= 6 then
60585: LD_VAR 0 8
60589: PUSH
60590: LD_INT 6
60592: GREATEREQUAL
60593: IFFALSE 60597
// exit ;
60595: GO 63048
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60597: LD_ADDR_EXP 65
60601: PUSH
60602: LD_EXP 65
60606: PPUSH
60607: LD_VAR 0 1
60611: PPUSH
60612: LD_INT 2
60614: PPUSH
60615: CALL_OW 1
60619: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60620: LD_ADDR_VAR 0 9
60624: PUSH
60625: LD_VAR 0 4
60629: PUSH
60630: LD_VAR 0 8
60634: DIFF
60635: PPUSH
60636: LD_INT 4
60638: PPUSH
60639: CALL 47783 0 2
60643: ST_TO_ADDR
// p := [ ] ;
60644: LD_ADDR_VAR 0 11
60648: PUSH
60649: EMPTY
60650: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60651: LD_VAR 0 8
60655: PUSH
60656: LD_INT 6
60658: LESS
60659: IFFALSE 60671
60661: PUSH
60662: LD_VAR 0 9
60666: PUSH
60667: LD_INT 6
60669: GREATER
60670: AND
60671: IFFALSE 60752
// begin for i = 1 to 6 - sci do
60673: LD_ADDR_VAR 0 3
60677: PUSH
60678: DOUBLE
60679: LD_INT 1
60681: DEC
60682: ST_TO_ADDR
60683: LD_INT 6
60685: PUSH
60686: LD_VAR 0 8
60690: MINUS
60691: PUSH
60692: FOR_TO
60693: IFFALSE 60748
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60695: LD_ADDR_VAR 0 11
60699: PUSH
60700: LD_VAR 0 11
60704: PPUSH
60705: LD_VAR 0 11
60709: PUSH
60710: LD_INT 1
60712: PLUS
60713: PPUSH
60714: LD_VAR 0 9
60718: PUSH
60719: LD_INT 1
60721: ARRAY
60722: PPUSH
60723: CALL_OW 2
60727: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60728: LD_ADDR_VAR 0 9
60732: PUSH
60733: LD_VAR 0 9
60737: PPUSH
60738: LD_INT 1
60740: PPUSH
60741: CALL_OW 3
60745: ST_TO_ADDR
// end ;
60746: GO 60692
60748: POP
60749: POP
// end else
60750: GO 60772
// if sort then
60752: LD_VAR 0 9
60756: IFFALSE 60772
// p := sort [ 1 ] ;
60758: LD_ADDR_VAR 0 11
60762: PUSH
60763: LD_VAR 0 9
60767: PUSH
60768: LD_INT 1
60770: ARRAY
60771: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60772: LD_ADDR_VAR 0 2
60776: PUSH
60777: LD_INT 0
60779: PUSH
60780: LD_INT 0
60782: PUSH
60783: LD_INT 0
60785: PUSH
60786: LD_VAR 0 11
60790: PUSH
60791: EMPTY
60792: LIST
60793: LIST
60794: LIST
60795: LIST
60796: ST_TO_ADDR
// exit ;
60797: GO 63048
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60799: LD_EXP 50
60803: PUSH
60804: LD_EXP 49
60808: PUSH
60809: LD_VAR 0 1
60813: ARRAY
60814: ARRAY
60815: IFFALSE 60873
60817: PUSH
60818: LD_EXP 23
60822: PUSH
60823: LD_VAR 0 1
60827: ARRAY
60828: PPUSH
60829: LD_INT 2
60831: PUSH
60832: LD_INT 30
60834: PUSH
60835: LD_INT 6
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: LD_INT 30
60844: PUSH
60845: LD_INT 7
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: PUSH
60852: LD_INT 30
60854: PUSH
60855: LD_INT 8
60857: PUSH
60858: EMPTY
60859: LIST
60860: LIST
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: LIST
60866: LIST
60867: PPUSH
60868: CALL_OW 72
60872: AND
60873: IFFALSE 60902
60875: PUSH
60876: LD_EXP 23
60880: PUSH
60881: LD_VAR 0 1
60885: ARRAY
60886: PPUSH
60887: LD_INT 30
60889: PUSH
60890: LD_INT 3
60892: PUSH
60893: EMPTY
60894: LIST
60895: LIST
60896: PPUSH
60897: CALL_OW 72
60901: AND
60902: IFFALSE 61642
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60904: LD_ADDR_EXP 65
60908: PUSH
60909: LD_EXP 65
60913: PPUSH
60914: LD_VAR 0 1
60918: PPUSH
60919: LD_INT 3
60921: PPUSH
60922: CALL_OW 1
60926: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60927: LD_ADDR_VAR 0 2
60931: PUSH
60932: LD_INT 0
60934: PUSH
60935: LD_INT 0
60937: PUSH
60938: LD_INT 0
60940: PUSH
60941: LD_INT 0
60943: PUSH
60944: EMPTY
60945: LIST
60946: LIST
60947: LIST
60948: LIST
60949: ST_TO_ADDR
// if not eng then
60950: LD_VAR 0 6
60954: NOT
60955: IFFALSE 61018
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60957: LD_ADDR_VAR 0 11
60961: PUSH
60962: LD_VAR 0 4
60966: PPUSH
60967: LD_INT 2
60969: PPUSH
60970: CALL 47783 0 2
60974: PUSH
60975: LD_INT 1
60977: ARRAY
60978: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60979: LD_ADDR_VAR 0 2
60983: PUSH
60984: LD_VAR 0 2
60988: PPUSH
60989: LD_INT 2
60991: PPUSH
60992: LD_VAR 0 11
60996: PPUSH
60997: CALL_OW 1
61001: ST_TO_ADDR
// tmp := tmp diff p ;
61002: LD_ADDR_VAR 0 4
61006: PUSH
61007: LD_VAR 0 4
61011: PUSH
61012: LD_VAR 0 11
61016: DIFF
61017: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61018: LD_VAR 0 4
61022: IFFALSE 61034
61024: PUSH
61025: LD_VAR 0 8
61029: PUSH
61030: LD_INT 6
61032: LESS
61033: AND
61034: IFFALSE 61222
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61036: LD_ADDR_VAR 0 9
61040: PUSH
61041: LD_VAR 0 4
61045: PUSH
61046: LD_VAR 0 8
61050: PUSH
61051: LD_VAR 0 7
61055: UNION
61056: DIFF
61057: PPUSH
61058: LD_INT 4
61060: PPUSH
61061: CALL 47783 0 2
61065: ST_TO_ADDR
// p := [ ] ;
61066: LD_ADDR_VAR 0 11
61070: PUSH
61071: EMPTY
61072: ST_TO_ADDR
// if sort then
61073: LD_VAR 0 9
61077: IFFALSE 61193
// for i = 1 to 6 - sci do
61079: LD_ADDR_VAR 0 3
61083: PUSH
61084: DOUBLE
61085: LD_INT 1
61087: DEC
61088: ST_TO_ADDR
61089: LD_INT 6
61091: PUSH
61092: LD_VAR 0 8
61096: MINUS
61097: PUSH
61098: FOR_TO
61099: IFFALSE 61191
// begin if i = sort then
61101: LD_VAR 0 3
61105: PUSH
61106: LD_VAR 0 9
61110: EQUAL
61111: IFFALSE 61115
// break ;
61113: GO 61191
// if GetClass ( i ) = 4 then
61115: LD_VAR 0 3
61119: PPUSH
61120: CALL_OW 257
61124: PUSH
61125: LD_INT 4
61127: EQUAL
61128: IFFALSE 61132
// continue ;
61130: GO 61098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61132: LD_ADDR_VAR 0 11
61136: PUSH
61137: LD_VAR 0 11
61141: PPUSH
61142: LD_VAR 0 11
61146: PUSH
61147: LD_INT 1
61149: PLUS
61150: PPUSH
61151: LD_VAR 0 9
61155: PUSH
61156: LD_VAR 0 3
61160: ARRAY
61161: PPUSH
61162: CALL_OW 2
61166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61167: LD_ADDR_VAR 0 4
61171: PUSH
61172: LD_VAR 0 4
61176: PUSH
61177: LD_VAR 0 9
61181: PUSH
61182: LD_VAR 0 3
61186: ARRAY
61187: DIFF
61188: ST_TO_ADDR
// end ;
61189: GO 61098
61191: POP
61192: POP
// if p then
61193: LD_VAR 0 11
61197: IFFALSE 61222
// result := Replace ( result , 4 , p ) ;
61199: LD_ADDR_VAR 0 2
61203: PUSH
61204: LD_VAR 0 2
61208: PPUSH
61209: LD_INT 4
61211: PPUSH
61212: LD_VAR 0 11
61216: PPUSH
61217: CALL_OW 1
61221: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61222: LD_VAR 0 4
61226: IFFALSE 61238
61228: PUSH
61229: LD_VAR 0 7
61233: PUSH
61234: LD_INT 6
61236: LESS
61237: AND
61238: IFFALSE 61426
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61240: LD_ADDR_VAR 0 9
61244: PUSH
61245: LD_VAR 0 4
61249: PUSH
61250: LD_VAR 0 8
61254: PUSH
61255: LD_VAR 0 7
61259: UNION
61260: DIFF
61261: PPUSH
61262: LD_INT 3
61264: PPUSH
61265: CALL 47783 0 2
61269: ST_TO_ADDR
// p := [ ] ;
61270: LD_ADDR_VAR 0 11
61274: PUSH
61275: EMPTY
61276: ST_TO_ADDR
// if sort then
61277: LD_VAR 0 9
61281: IFFALSE 61397
// for i = 1 to 6 - mech do
61283: LD_ADDR_VAR 0 3
61287: PUSH
61288: DOUBLE
61289: LD_INT 1
61291: DEC
61292: ST_TO_ADDR
61293: LD_INT 6
61295: PUSH
61296: LD_VAR 0 7
61300: MINUS
61301: PUSH
61302: FOR_TO
61303: IFFALSE 61395
// begin if i = sort then
61305: LD_VAR 0 3
61309: PUSH
61310: LD_VAR 0 9
61314: EQUAL
61315: IFFALSE 61319
// break ;
61317: GO 61395
// if GetClass ( i ) = 3 then
61319: LD_VAR 0 3
61323: PPUSH
61324: CALL_OW 257
61328: PUSH
61329: LD_INT 3
61331: EQUAL
61332: IFFALSE 61336
// continue ;
61334: GO 61302
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61336: LD_ADDR_VAR 0 11
61340: PUSH
61341: LD_VAR 0 11
61345: PPUSH
61346: LD_VAR 0 11
61350: PUSH
61351: LD_INT 1
61353: PLUS
61354: PPUSH
61355: LD_VAR 0 9
61359: PUSH
61360: LD_VAR 0 3
61364: ARRAY
61365: PPUSH
61366: CALL_OW 2
61370: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61371: LD_ADDR_VAR 0 4
61375: PUSH
61376: LD_VAR 0 4
61380: PUSH
61381: LD_VAR 0 9
61385: PUSH
61386: LD_VAR 0 3
61390: ARRAY
61391: DIFF
61392: ST_TO_ADDR
// end ;
61393: GO 61302
61395: POP
61396: POP
// if p then
61397: LD_VAR 0 11
61401: IFFALSE 61426
// result := Replace ( result , 3 , p ) ;
61403: LD_ADDR_VAR 0 2
61407: PUSH
61408: LD_VAR 0 2
61412: PPUSH
61413: LD_INT 3
61415: PPUSH
61416: LD_VAR 0 11
61420: PPUSH
61421: CALL_OW 1
61425: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61426: LD_VAR 0 4
61430: PUSH
61431: LD_INT 6
61433: GREATER
61434: IFFALSE 61446
61436: PUSH
61437: LD_VAR 0 6
61441: PUSH
61442: LD_INT 6
61444: LESS
61445: AND
61446: IFFALSE 61640
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61448: LD_ADDR_VAR 0 9
61452: PUSH
61453: LD_VAR 0 4
61457: PUSH
61458: LD_VAR 0 8
61462: PUSH
61463: LD_VAR 0 7
61467: UNION
61468: PUSH
61469: LD_VAR 0 6
61473: UNION
61474: DIFF
61475: PPUSH
61476: LD_INT 2
61478: PPUSH
61479: CALL 47783 0 2
61483: ST_TO_ADDR
// p := [ ] ;
61484: LD_ADDR_VAR 0 11
61488: PUSH
61489: EMPTY
61490: ST_TO_ADDR
// if sort then
61491: LD_VAR 0 9
61495: IFFALSE 61611
// for i = 1 to 6 - eng do
61497: LD_ADDR_VAR 0 3
61501: PUSH
61502: DOUBLE
61503: LD_INT 1
61505: DEC
61506: ST_TO_ADDR
61507: LD_INT 6
61509: PUSH
61510: LD_VAR 0 6
61514: MINUS
61515: PUSH
61516: FOR_TO
61517: IFFALSE 61609
// begin if i = sort then
61519: LD_VAR 0 3
61523: PUSH
61524: LD_VAR 0 9
61528: EQUAL
61529: IFFALSE 61533
// break ;
61531: GO 61609
// if GetClass ( i ) = 2 then
61533: LD_VAR 0 3
61537: PPUSH
61538: CALL_OW 257
61542: PUSH
61543: LD_INT 2
61545: EQUAL
61546: IFFALSE 61550
// continue ;
61548: GO 61516
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61550: LD_ADDR_VAR 0 11
61554: PUSH
61555: LD_VAR 0 11
61559: PPUSH
61560: LD_VAR 0 11
61564: PUSH
61565: LD_INT 1
61567: PLUS
61568: PPUSH
61569: LD_VAR 0 9
61573: PUSH
61574: LD_VAR 0 3
61578: ARRAY
61579: PPUSH
61580: CALL_OW 2
61584: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61585: LD_ADDR_VAR 0 4
61589: PUSH
61590: LD_VAR 0 4
61594: PUSH
61595: LD_VAR 0 9
61599: PUSH
61600: LD_VAR 0 3
61604: ARRAY
61605: DIFF
61606: ST_TO_ADDR
// end ;
61607: GO 61516
61609: POP
61610: POP
// if p then
61611: LD_VAR 0 11
61615: IFFALSE 61640
// result := Replace ( result , 2 , p ) ;
61617: LD_ADDR_VAR 0 2
61621: PUSH
61622: LD_VAR 0 2
61626: PPUSH
61627: LD_INT 2
61629: PPUSH
61630: LD_VAR 0 11
61634: PPUSH
61635: CALL_OW 1
61639: ST_TO_ADDR
// end ; exit ;
61640: GO 63048
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61642: LD_EXP 50
61646: PUSH
61647: LD_EXP 49
61651: PUSH
61652: LD_VAR 0 1
61656: ARRAY
61657: ARRAY
61658: NOT
61659: IFFALSE 61688
61661: PUSH
61662: LD_EXP 23
61666: PUSH
61667: LD_VAR 0 1
61671: ARRAY
61672: PPUSH
61673: LD_INT 30
61675: PUSH
61676: LD_INT 3
61678: PUSH
61679: EMPTY
61680: LIST
61681: LIST
61682: PPUSH
61683: CALL_OW 72
61687: AND
61688: IFFALSE 61702
61690: PUSH
61691: LD_EXP 28
61695: PUSH
61696: LD_VAR 0 1
61700: ARRAY
61701: AND
61702: IFFALSE 62316
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61704: LD_ADDR_EXP 65
61708: PUSH
61709: LD_EXP 65
61713: PPUSH
61714: LD_VAR 0 1
61718: PPUSH
61719: LD_INT 5
61721: PPUSH
61722: CALL_OW 1
61726: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61727: LD_ADDR_VAR 0 2
61731: PUSH
61732: LD_INT 0
61734: PUSH
61735: LD_INT 0
61737: PUSH
61738: LD_INT 0
61740: PUSH
61741: LD_INT 0
61743: PUSH
61744: EMPTY
61745: LIST
61746: LIST
61747: LIST
61748: LIST
61749: ST_TO_ADDR
// if sci > 1 then
61750: LD_VAR 0 8
61754: PUSH
61755: LD_INT 1
61757: GREATER
61758: IFFALSE 61786
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61760: LD_ADDR_VAR 0 4
61764: PUSH
61765: LD_VAR 0 4
61769: PUSH
61770: LD_VAR 0 8
61774: PUSH
61775: LD_VAR 0 8
61779: PUSH
61780: LD_INT 1
61782: ARRAY
61783: DIFF
61784: DIFF
61785: ST_TO_ADDR
// if tmp and not sci then
61786: LD_VAR 0 4
61790: IFFALSE 61799
61792: PUSH
61793: LD_VAR 0 8
61797: NOT
61798: AND
61799: IFFALSE 61868
// begin sort := SortBySkill ( tmp , 4 ) ;
61801: LD_ADDR_VAR 0 9
61805: PUSH
61806: LD_VAR 0 4
61810: PPUSH
61811: LD_INT 4
61813: PPUSH
61814: CALL 47783 0 2
61818: ST_TO_ADDR
// if sort then
61819: LD_VAR 0 9
61823: IFFALSE 61839
// p := sort [ 1 ] ;
61825: LD_ADDR_VAR 0 11
61829: PUSH
61830: LD_VAR 0 9
61834: PUSH
61835: LD_INT 1
61837: ARRAY
61838: ST_TO_ADDR
// if p then
61839: LD_VAR 0 11
61843: IFFALSE 61868
// result := Replace ( result , 4 , p ) ;
61845: LD_ADDR_VAR 0 2
61849: PUSH
61850: LD_VAR 0 2
61854: PPUSH
61855: LD_INT 4
61857: PPUSH
61858: LD_VAR 0 11
61862: PPUSH
61863: CALL_OW 1
61867: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61868: LD_ADDR_VAR 0 4
61872: PUSH
61873: LD_VAR 0 4
61877: PUSH
61878: LD_VAR 0 7
61882: DIFF
61883: ST_TO_ADDR
// if tmp and mech < 6 then
61884: LD_VAR 0 4
61888: IFFALSE 61900
61890: PUSH
61891: LD_VAR 0 7
61895: PUSH
61896: LD_INT 6
61898: LESS
61899: AND
61900: IFFALSE 62088
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61902: LD_ADDR_VAR 0 9
61906: PUSH
61907: LD_VAR 0 4
61911: PUSH
61912: LD_VAR 0 8
61916: PUSH
61917: LD_VAR 0 7
61921: UNION
61922: DIFF
61923: PPUSH
61924: LD_INT 3
61926: PPUSH
61927: CALL 47783 0 2
61931: ST_TO_ADDR
// p := [ ] ;
61932: LD_ADDR_VAR 0 11
61936: PUSH
61937: EMPTY
61938: ST_TO_ADDR
// if sort then
61939: LD_VAR 0 9
61943: IFFALSE 62059
// for i = 1 to 6 - mech do
61945: LD_ADDR_VAR 0 3
61949: PUSH
61950: DOUBLE
61951: LD_INT 1
61953: DEC
61954: ST_TO_ADDR
61955: LD_INT 6
61957: PUSH
61958: LD_VAR 0 7
61962: MINUS
61963: PUSH
61964: FOR_TO
61965: IFFALSE 62057
// begin if i = sort then
61967: LD_VAR 0 3
61971: PUSH
61972: LD_VAR 0 9
61976: EQUAL
61977: IFFALSE 61981
// break ;
61979: GO 62057
// if GetClass ( i ) = 3 then
61981: LD_VAR 0 3
61985: PPUSH
61986: CALL_OW 257
61990: PUSH
61991: LD_INT 3
61993: EQUAL
61994: IFFALSE 61998
// continue ;
61996: GO 61964
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61998: LD_ADDR_VAR 0 11
62002: PUSH
62003: LD_VAR 0 11
62007: PPUSH
62008: LD_VAR 0 11
62012: PUSH
62013: LD_INT 1
62015: PLUS
62016: PPUSH
62017: LD_VAR 0 9
62021: PUSH
62022: LD_VAR 0 3
62026: ARRAY
62027: PPUSH
62028: CALL_OW 2
62032: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62033: LD_ADDR_VAR 0 4
62037: PUSH
62038: LD_VAR 0 4
62042: PUSH
62043: LD_VAR 0 9
62047: PUSH
62048: LD_VAR 0 3
62052: ARRAY
62053: DIFF
62054: ST_TO_ADDR
// end ;
62055: GO 61964
62057: POP
62058: POP
// if p then
62059: LD_VAR 0 11
62063: IFFALSE 62088
// result := Replace ( result , 3 , p ) ;
62065: LD_ADDR_VAR 0 2
62069: PUSH
62070: LD_VAR 0 2
62074: PPUSH
62075: LD_INT 3
62077: PPUSH
62078: LD_VAR 0 11
62082: PPUSH
62083: CALL_OW 1
62087: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62088: LD_ADDR_VAR 0 4
62092: PUSH
62093: LD_VAR 0 4
62097: PUSH
62098: LD_VAR 0 6
62102: DIFF
62103: ST_TO_ADDR
// if tmp and eng < 6 then
62104: LD_VAR 0 4
62108: IFFALSE 62120
62110: PUSH
62111: LD_VAR 0 6
62115: PUSH
62116: LD_INT 6
62118: LESS
62119: AND
62120: IFFALSE 62314
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62122: LD_ADDR_VAR 0 9
62126: PUSH
62127: LD_VAR 0 4
62131: PUSH
62132: LD_VAR 0 8
62136: PUSH
62137: LD_VAR 0 7
62141: UNION
62142: PUSH
62143: LD_VAR 0 6
62147: UNION
62148: DIFF
62149: PPUSH
62150: LD_INT 2
62152: PPUSH
62153: CALL 47783 0 2
62157: ST_TO_ADDR
// p := [ ] ;
62158: LD_ADDR_VAR 0 11
62162: PUSH
62163: EMPTY
62164: ST_TO_ADDR
// if sort then
62165: LD_VAR 0 9
62169: IFFALSE 62285
// for i = 1 to 6 - eng do
62171: LD_ADDR_VAR 0 3
62175: PUSH
62176: DOUBLE
62177: LD_INT 1
62179: DEC
62180: ST_TO_ADDR
62181: LD_INT 6
62183: PUSH
62184: LD_VAR 0 6
62188: MINUS
62189: PUSH
62190: FOR_TO
62191: IFFALSE 62283
// begin if i = sort then
62193: LD_VAR 0 3
62197: PUSH
62198: LD_VAR 0 9
62202: EQUAL
62203: IFFALSE 62207
// break ;
62205: GO 62283
// if GetClass ( i ) = 2 then
62207: LD_VAR 0 3
62211: PPUSH
62212: CALL_OW 257
62216: PUSH
62217: LD_INT 2
62219: EQUAL
62220: IFFALSE 62224
// continue ;
62222: GO 62190
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62224: LD_ADDR_VAR 0 11
62228: PUSH
62229: LD_VAR 0 11
62233: PPUSH
62234: LD_VAR 0 11
62238: PUSH
62239: LD_INT 1
62241: PLUS
62242: PPUSH
62243: LD_VAR 0 9
62247: PUSH
62248: LD_VAR 0 3
62252: ARRAY
62253: PPUSH
62254: CALL_OW 2
62258: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62259: LD_ADDR_VAR 0 4
62263: PUSH
62264: LD_VAR 0 4
62268: PUSH
62269: LD_VAR 0 9
62273: PUSH
62274: LD_VAR 0 3
62278: ARRAY
62279: DIFF
62280: ST_TO_ADDR
// end ;
62281: GO 62190
62283: POP
62284: POP
// if p then
62285: LD_VAR 0 11
62289: IFFALSE 62314
// result := Replace ( result , 2 , p ) ;
62291: LD_ADDR_VAR 0 2
62295: PUSH
62296: LD_VAR 0 2
62300: PPUSH
62301: LD_INT 2
62303: PPUSH
62304: LD_VAR 0 11
62308: PPUSH
62309: CALL_OW 1
62313: ST_TO_ADDR
// end ; exit ;
62314: GO 63048
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62316: LD_EXP 50
62320: PUSH
62321: LD_EXP 49
62325: PUSH
62326: LD_VAR 0 1
62330: ARRAY
62331: ARRAY
62332: NOT
62333: IFFALSE 62362
62335: PUSH
62336: LD_EXP 23
62340: PUSH
62341: LD_VAR 0 1
62345: ARRAY
62346: PPUSH
62347: LD_INT 30
62349: PUSH
62350: LD_INT 3
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PPUSH
62357: CALL_OW 72
62361: AND
62362: IFFALSE 62377
62364: PUSH
62365: LD_EXP 28
62369: PUSH
62370: LD_VAR 0 1
62374: ARRAY
62375: NOT
62376: AND
62377: IFFALSE 63048
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62379: LD_ADDR_EXP 65
62383: PUSH
62384: LD_EXP 65
62388: PPUSH
62389: LD_VAR 0 1
62393: PPUSH
62394: LD_INT 6
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62402: LD_ADDR_VAR 0 2
62406: PUSH
62407: LD_INT 0
62409: PUSH
62410: LD_INT 0
62412: PUSH
62413: LD_INT 0
62415: PUSH
62416: LD_INT 0
62418: PUSH
62419: EMPTY
62420: LIST
62421: LIST
62422: LIST
62423: LIST
62424: ST_TO_ADDR
// if sci >= 1 then
62425: LD_VAR 0 8
62429: PUSH
62430: LD_INT 1
62432: GREATEREQUAL
62433: IFFALSE 62455
// tmp := tmp diff sci [ 1 ] ;
62435: LD_ADDR_VAR 0 4
62439: PUSH
62440: LD_VAR 0 4
62444: PUSH
62445: LD_VAR 0 8
62449: PUSH
62450: LD_INT 1
62452: ARRAY
62453: DIFF
62454: ST_TO_ADDR
// if tmp and not sci then
62455: LD_VAR 0 4
62459: IFFALSE 62468
62461: PUSH
62462: LD_VAR 0 8
62466: NOT
62467: AND
62468: IFFALSE 62537
// begin sort := SortBySkill ( tmp , 4 ) ;
62470: LD_ADDR_VAR 0 9
62474: PUSH
62475: LD_VAR 0 4
62479: PPUSH
62480: LD_INT 4
62482: PPUSH
62483: CALL 47783 0 2
62487: ST_TO_ADDR
// if sort then
62488: LD_VAR 0 9
62492: IFFALSE 62508
// p := sort [ 1 ] ;
62494: LD_ADDR_VAR 0 11
62498: PUSH
62499: LD_VAR 0 9
62503: PUSH
62504: LD_INT 1
62506: ARRAY
62507: ST_TO_ADDR
// if p then
62508: LD_VAR 0 11
62512: IFFALSE 62537
// result := Replace ( result , 4 , p ) ;
62514: LD_ADDR_VAR 0 2
62518: PUSH
62519: LD_VAR 0 2
62523: PPUSH
62524: LD_INT 4
62526: PPUSH
62527: LD_VAR 0 11
62531: PPUSH
62532: CALL_OW 1
62536: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62537: LD_ADDR_VAR 0 4
62541: PUSH
62542: LD_VAR 0 4
62546: PUSH
62547: LD_VAR 0 7
62551: DIFF
62552: ST_TO_ADDR
// if tmp and mech < 6 then
62553: LD_VAR 0 4
62557: IFFALSE 62569
62559: PUSH
62560: LD_VAR 0 7
62564: PUSH
62565: LD_INT 6
62567: LESS
62568: AND
62569: IFFALSE 62751
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62571: LD_ADDR_VAR 0 9
62575: PUSH
62576: LD_VAR 0 4
62580: PUSH
62581: LD_VAR 0 7
62585: DIFF
62586: PPUSH
62587: LD_INT 3
62589: PPUSH
62590: CALL 47783 0 2
62594: ST_TO_ADDR
// p := [ ] ;
62595: LD_ADDR_VAR 0 11
62599: PUSH
62600: EMPTY
62601: ST_TO_ADDR
// if sort then
62602: LD_VAR 0 9
62606: IFFALSE 62722
// for i = 1 to 6 - mech do
62608: LD_ADDR_VAR 0 3
62612: PUSH
62613: DOUBLE
62614: LD_INT 1
62616: DEC
62617: ST_TO_ADDR
62618: LD_INT 6
62620: PUSH
62621: LD_VAR 0 7
62625: MINUS
62626: PUSH
62627: FOR_TO
62628: IFFALSE 62720
// begin if i = sort then
62630: LD_VAR 0 3
62634: PUSH
62635: LD_VAR 0 9
62639: EQUAL
62640: IFFALSE 62644
// break ;
62642: GO 62720
// if GetClass ( i ) = 3 then
62644: LD_VAR 0 3
62648: PPUSH
62649: CALL_OW 257
62653: PUSH
62654: LD_INT 3
62656: EQUAL
62657: IFFALSE 62661
// continue ;
62659: GO 62627
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62661: LD_ADDR_VAR 0 11
62665: PUSH
62666: LD_VAR 0 11
62670: PPUSH
62671: LD_VAR 0 11
62675: PUSH
62676: LD_INT 1
62678: PLUS
62679: PPUSH
62680: LD_VAR 0 9
62684: PUSH
62685: LD_VAR 0 3
62689: ARRAY
62690: PPUSH
62691: CALL_OW 2
62695: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62696: LD_ADDR_VAR 0 4
62700: PUSH
62701: LD_VAR 0 4
62705: PUSH
62706: LD_VAR 0 9
62710: PUSH
62711: LD_VAR 0 3
62715: ARRAY
62716: DIFF
62717: ST_TO_ADDR
// end ;
62718: GO 62627
62720: POP
62721: POP
// if p then
62722: LD_VAR 0 11
62726: IFFALSE 62751
// result := Replace ( result , 3 , p ) ;
62728: LD_ADDR_VAR 0 2
62732: PUSH
62733: LD_VAR 0 2
62737: PPUSH
62738: LD_INT 3
62740: PPUSH
62741: LD_VAR 0 11
62745: PPUSH
62746: CALL_OW 1
62750: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62751: LD_ADDR_VAR 0 4
62755: PUSH
62756: LD_VAR 0 4
62760: PUSH
62761: LD_VAR 0 6
62765: DIFF
62766: ST_TO_ADDR
// if tmp and eng < 4 then
62767: LD_VAR 0 4
62771: IFFALSE 62783
62773: PUSH
62774: LD_VAR 0 6
62778: PUSH
62779: LD_INT 4
62781: LESS
62782: AND
62783: IFFALSE 62973
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62785: LD_ADDR_VAR 0 9
62789: PUSH
62790: LD_VAR 0 4
62794: PUSH
62795: LD_VAR 0 7
62799: PUSH
62800: LD_VAR 0 6
62804: UNION
62805: DIFF
62806: PPUSH
62807: LD_INT 2
62809: PPUSH
62810: CALL 47783 0 2
62814: ST_TO_ADDR
// p := [ ] ;
62815: LD_ADDR_VAR 0 11
62819: PUSH
62820: EMPTY
62821: ST_TO_ADDR
// if sort then
62822: LD_VAR 0 9
62826: IFFALSE 62942
// for i = 1 to 4 - eng do
62828: LD_ADDR_VAR 0 3
62832: PUSH
62833: DOUBLE
62834: LD_INT 1
62836: DEC
62837: ST_TO_ADDR
62838: LD_INT 4
62840: PUSH
62841: LD_VAR 0 6
62845: MINUS
62846: PUSH
62847: FOR_TO
62848: IFFALSE 62940
// begin if i = sort then
62850: LD_VAR 0 3
62854: PUSH
62855: LD_VAR 0 9
62859: EQUAL
62860: IFFALSE 62864
// break ;
62862: GO 62940
// if GetClass ( i ) = 2 then
62864: LD_VAR 0 3
62868: PPUSH
62869: CALL_OW 257
62873: PUSH
62874: LD_INT 2
62876: EQUAL
62877: IFFALSE 62881
// continue ;
62879: GO 62847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62881: LD_ADDR_VAR 0 11
62885: PUSH
62886: LD_VAR 0 11
62890: PPUSH
62891: LD_VAR 0 11
62895: PUSH
62896: LD_INT 1
62898: PLUS
62899: PPUSH
62900: LD_VAR 0 9
62904: PUSH
62905: LD_VAR 0 3
62909: ARRAY
62910: PPUSH
62911: CALL_OW 2
62915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62916: LD_ADDR_VAR 0 4
62920: PUSH
62921: LD_VAR 0 4
62925: PUSH
62926: LD_VAR 0 9
62930: PUSH
62931: LD_VAR 0 3
62935: ARRAY
62936: DIFF
62937: ST_TO_ADDR
// end ;
62938: GO 62847
62940: POP
62941: POP
// if p then
62942: LD_VAR 0 11
62946: IFFALSE 62971
// result := Replace ( result , 2 , p ) ;
62948: LD_ADDR_VAR 0 2
62952: PUSH
62953: LD_VAR 0 2
62957: PPUSH
62958: LD_INT 2
62960: PPUSH
62961: LD_VAR 0 11
62965: PPUSH
62966: CALL_OW 1
62970: ST_TO_ADDR
// end else
62971: GO 63017
// for i = eng downto 5 do
62973: LD_ADDR_VAR 0 3
62977: PUSH
62978: DOUBLE
62979: LD_VAR 0 6
62983: INC
62984: ST_TO_ADDR
62985: LD_INT 5
62987: PUSH
62988: FOR_DOWNTO
62989: IFFALSE 63015
// tmp := tmp union eng [ i ] ;
62991: LD_ADDR_VAR 0 4
62995: PUSH
62996: LD_VAR 0 4
63000: PUSH
63001: LD_VAR 0 6
63005: PUSH
63006: LD_VAR 0 3
63010: ARRAY
63011: UNION
63012: ST_TO_ADDR
63013: GO 62988
63015: POP
63016: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63017: LD_ADDR_VAR 0 2
63021: PUSH
63022: LD_VAR 0 2
63026: PPUSH
63027: LD_INT 1
63029: PPUSH
63030: LD_VAR 0 4
63034: PUSH
63035: LD_VAR 0 5
63039: DIFF
63040: PPUSH
63041: CALL_OW 1
63045: ST_TO_ADDR
// exit ;
63046: GO 63048
// end ; end ;
63048: LD_VAR 0 2
63052: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63053: LD_INT 0
63055: PPUSH
63056: PPUSH
63057: PPUSH
// if not mc_bases then
63058: LD_EXP 23
63062: NOT
63063: IFFALSE 63067
// exit ;
63065: GO 63209
// for i = 1 to mc_bases do
63067: LD_ADDR_VAR 0 2
63071: PUSH
63072: DOUBLE
63073: LD_INT 1
63075: DEC
63076: ST_TO_ADDR
63077: LD_EXP 23
63081: PUSH
63082: FOR_TO
63083: IFFALSE 63200
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63085: LD_ADDR_VAR 0 3
63089: PUSH
63090: LD_EXP 23
63094: PUSH
63095: LD_VAR 0 2
63099: ARRAY
63100: PPUSH
63101: LD_INT 21
63103: PUSH
63104: LD_INT 3
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PUSH
63111: LD_INT 3
63113: PUSH
63114: LD_INT 2
63116: PUSH
63117: LD_INT 30
63119: PUSH
63120: LD_INT 29
63122: PUSH
63123: EMPTY
63124: LIST
63125: LIST
63126: PUSH
63127: LD_INT 30
63129: PUSH
63130: LD_INT 30
63132: PUSH
63133: EMPTY
63134: LIST
63135: LIST
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: LIST
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PUSH
63146: LD_INT 3
63148: PUSH
63149: LD_INT 24
63151: PUSH
63152: LD_INT 1000
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: EMPTY
63160: LIST
63161: LIST
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: LIST
63167: PPUSH
63168: CALL_OW 72
63172: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63173: LD_ADDR_EXP 24
63177: PUSH
63178: LD_EXP 24
63182: PPUSH
63183: LD_VAR 0 2
63187: PPUSH
63188: LD_VAR 0 3
63192: PPUSH
63193: CALL_OW 1
63197: ST_TO_ADDR
// end ;
63198: GO 63082
63200: POP
63201: POP
// RaiseSailEvent ( 101 ) ;
63202: LD_INT 101
63204: PPUSH
63205: CALL_OW 427
// end ;
63209: LD_VAR 0 1
63213: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63214: LD_INT 0
63216: PPUSH
63217: PPUSH
63218: PPUSH
63219: PPUSH
63220: PPUSH
63221: PPUSH
63222: PPUSH
// if not mc_bases then
63223: LD_EXP 23
63227: NOT
63228: IFFALSE 63232
// exit ;
63230: GO 63796
// for i = 1 to mc_bases do
63232: LD_ADDR_VAR 0 2
63236: PUSH
63237: DOUBLE
63238: LD_INT 1
63240: DEC
63241: ST_TO_ADDR
63242: LD_EXP 23
63246: PUSH
63247: FOR_TO
63248: IFFALSE 63787
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63250: LD_ADDR_VAR 0 5
63254: PUSH
63255: LD_EXP 23
63259: PUSH
63260: LD_VAR 0 2
63264: ARRAY
63265: PUSH
63266: LD_EXP 52
63270: PUSH
63271: LD_VAR 0 2
63275: ARRAY
63276: UNION
63277: PPUSH
63278: LD_INT 21
63280: PUSH
63281: LD_INT 1
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: LD_INT 1
63290: PUSH
63291: LD_INT 3
63293: PUSH
63294: LD_INT 54
63296: PUSH
63297: EMPTY
63298: LIST
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_INT 3
63306: PUSH
63307: LD_INT 24
63309: PUSH
63310: LD_INT 1000
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: LIST
63325: PUSH
63326: EMPTY
63327: LIST
63328: LIST
63329: PPUSH
63330: CALL_OW 72
63334: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63335: LD_ADDR_VAR 0 6
63339: PUSH
63340: LD_EXP 23
63344: PUSH
63345: LD_VAR 0 2
63349: ARRAY
63350: PPUSH
63351: LD_INT 21
63353: PUSH
63354: LD_INT 1
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 1
63363: PUSH
63364: LD_INT 3
63366: PUSH
63367: LD_INT 54
63369: PUSH
63370: EMPTY
63371: LIST
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: PUSH
63377: LD_INT 3
63379: PUSH
63380: LD_INT 24
63382: PUSH
63383: LD_INT 250
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: LIST
63398: PUSH
63399: EMPTY
63400: LIST
63401: LIST
63402: PPUSH
63403: CALL_OW 72
63407: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63408: LD_ADDR_VAR 0 7
63412: PUSH
63413: LD_VAR 0 5
63417: PUSH
63418: LD_VAR 0 6
63422: DIFF
63423: ST_TO_ADDR
// if not need_heal_1 then
63424: LD_VAR 0 6
63428: NOT
63429: IFFALSE 63462
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63431: LD_ADDR_EXP 26
63435: PUSH
63436: LD_EXP 26
63440: PPUSH
63441: LD_VAR 0 2
63445: PUSH
63446: LD_INT 1
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PPUSH
63453: EMPTY
63454: PPUSH
63455: CALL 16255 0 3
63459: ST_TO_ADDR
63460: GO 63532
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63462: LD_ADDR_EXP 26
63466: PUSH
63467: LD_EXP 26
63471: PPUSH
63472: LD_VAR 0 2
63476: PUSH
63477: LD_INT 1
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PPUSH
63484: LD_EXP 26
63488: PUSH
63489: LD_VAR 0 2
63493: ARRAY
63494: PUSH
63495: LD_INT 1
63497: ARRAY
63498: PPUSH
63499: LD_INT 3
63501: PUSH
63502: LD_INT 24
63504: PUSH
63505: LD_INT 1000
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PPUSH
63516: CALL_OW 72
63520: PUSH
63521: LD_VAR 0 6
63525: UNION
63526: PPUSH
63527: CALL 16255 0 3
63531: ST_TO_ADDR
// if not need_heal_2 then
63532: LD_VAR 0 7
63536: NOT
63537: IFFALSE 63570
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63539: LD_ADDR_EXP 26
63543: PUSH
63544: LD_EXP 26
63548: PPUSH
63549: LD_VAR 0 2
63553: PUSH
63554: LD_INT 2
63556: PUSH
63557: EMPTY
63558: LIST
63559: LIST
63560: PPUSH
63561: EMPTY
63562: PPUSH
63563: CALL 16255 0 3
63567: ST_TO_ADDR
63568: GO 63602
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63570: LD_ADDR_EXP 26
63574: PUSH
63575: LD_EXP 26
63579: PPUSH
63580: LD_VAR 0 2
63584: PUSH
63585: LD_INT 2
63587: PUSH
63588: EMPTY
63589: LIST
63590: LIST
63591: PPUSH
63592: LD_VAR 0 7
63596: PPUSH
63597: CALL 16255 0 3
63601: ST_TO_ADDR
// if need_heal_2 then
63602: LD_VAR 0 7
63606: IFFALSE 63767
// for j in need_heal_2 do
63608: LD_ADDR_VAR 0 3
63612: PUSH
63613: LD_VAR 0 7
63617: PUSH
63618: FOR_IN
63619: IFFALSE 63765
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63621: LD_ADDR_VAR 0 5
63625: PUSH
63626: LD_EXP 23
63630: PUSH
63631: LD_VAR 0 2
63635: ARRAY
63636: PPUSH
63637: LD_INT 2
63639: PUSH
63640: LD_INT 30
63642: PUSH
63643: LD_INT 6
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: PUSH
63650: LD_INT 30
63652: PUSH
63653: LD_INT 7
63655: PUSH
63656: EMPTY
63657: LIST
63658: LIST
63659: PUSH
63660: LD_INT 30
63662: PUSH
63663: LD_INT 8
63665: PUSH
63666: EMPTY
63667: LIST
63668: LIST
63669: PUSH
63670: LD_INT 30
63672: PUSH
63673: LD_INT 0
63675: PUSH
63676: EMPTY
63677: LIST
63678: LIST
63679: PUSH
63680: LD_INT 30
63682: PUSH
63683: LD_INT 1
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: EMPTY
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: PPUSH
63698: CALL_OW 72
63702: ST_TO_ADDR
// if tmp then
63703: LD_VAR 0 5
63707: IFFALSE 63763
// begin k := NearestUnitToUnit ( tmp , j ) ;
63709: LD_ADDR_VAR 0 4
63713: PUSH
63714: LD_VAR 0 5
63718: PPUSH
63719: LD_VAR 0 3
63723: PPUSH
63724: CALL_OW 74
63728: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63729: LD_VAR 0 3
63733: PPUSH
63734: LD_VAR 0 4
63738: PPUSH
63739: CALL_OW 296
63743: PUSH
63744: LD_INT 5
63746: GREATER
63747: IFFALSE 63763
// ComMoveToNearbyEntrance ( j , k ) ;
63749: LD_VAR 0 3
63753: PPUSH
63754: LD_VAR 0 4
63758: PPUSH
63759: CALL 50182 0 2
// end ; end ;
63763: GO 63618
63765: POP
63766: POP
// if not need_heal_1 and not need_heal_2 then
63767: LD_VAR 0 6
63771: NOT
63772: IFFALSE 63781
63774: PUSH
63775: LD_VAR 0 7
63779: NOT
63780: AND
63781: IFFALSE 63785
// continue ;
63783: GO 63247
// end ;
63785: GO 63247
63787: POP
63788: POP
// RaiseSailEvent ( 102 ) ;
63789: LD_INT 102
63791: PPUSH
63792: CALL_OW 427
// end ;
63796: LD_VAR 0 1
63800: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63801: LD_INT 0
63803: PPUSH
63804: PPUSH
63805: PPUSH
63806: PPUSH
63807: PPUSH
63808: PPUSH
63809: PPUSH
63810: PPUSH
// if not mc_bases then
63811: LD_EXP 23
63815: NOT
63816: IFFALSE 63820
// exit ;
63818: GO 64735
// for i = 1 to mc_bases do
63820: LD_ADDR_VAR 0 2
63824: PUSH
63825: DOUBLE
63826: LD_INT 1
63828: DEC
63829: ST_TO_ADDR
63830: LD_EXP 23
63834: PUSH
63835: FOR_TO
63836: IFFALSE 64733
// begin if not mc_building_need_repair [ i ] then
63838: LD_EXP 24
63842: PUSH
63843: LD_VAR 0 2
63847: ARRAY
63848: NOT
63849: IFFALSE 64034
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63851: LD_ADDR_VAR 0 6
63855: PUSH
63856: LD_EXP 42
63860: PUSH
63861: LD_VAR 0 2
63865: ARRAY
63866: PPUSH
63867: LD_INT 3
63869: PUSH
63870: LD_INT 24
63872: PUSH
63873: LD_INT 1000
63875: PUSH
63876: EMPTY
63877: LIST
63878: LIST
63879: PUSH
63880: EMPTY
63881: LIST
63882: LIST
63883: PUSH
63884: LD_INT 2
63886: PUSH
63887: LD_INT 34
63889: PUSH
63890: LD_INT 13
63892: PUSH
63893: EMPTY
63894: LIST
63895: LIST
63896: PUSH
63897: LD_INT 34
63899: PUSH
63900: LD_INT 52
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PUSH
63907: LD_INT 34
63909: PUSH
63910: LD_INT 88
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PPUSH
63927: CALL_OW 72
63931: ST_TO_ADDR
// if cranes then
63932: LD_VAR 0 6
63936: IFFALSE 63998
// for j in cranes do
63938: LD_ADDR_VAR 0 3
63942: PUSH
63943: LD_VAR 0 6
63947: PUSH
63948: FOR_IN
63949: IFFALSE 63996
// if not IsInArea ( j , mc_parking [ i ] ) then
63951: LD_VAR 0 3
63955: PPUSH
63956: LD_EXP 47
63960: PUSH
63961: LD_VAR 0 2
63965: ARRAY
63966: PPUSH
63967: CALL_OW 308
63971: NOT
63972: IFFALSE 63994
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63974: LD_VAR 0 3
63978: PPUSH
63979: LD_EXP 47
63983: PUSH
63984: LD_VAR 0 2
63988: ARRAY
63989: PPUSH
63990: CALL_OW 113
63994: GO 63948
63996: POP
63997: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63998: LD_ADDR_EXP 25
64002: PUSH
64003: LD_EXP 25
64007: PPUSH
64008: LD_VAR 0 2
64012: PPUSH
64013: EMPTY
64014: PPUSH
64015: CALL_OW 1
64019: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64020: LD_VAR 0 2
64024: PPUSH
64025: LD_INT 101
64027: PPUSH
64028: CALL 58826 0 2
// continue ;
64032: GO 63835
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64034: LD_ADDR_EXP 29
64038: PUSH
64039: LD_EXP 29
64043: PPUSH
64044: LD_VAR 0 2
64048: PPUSH
64049: EMPTY
64050: PPUSH
64051: CALL_OW 1
64055: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64056: LD_VAR 0 2
64060: PPUSH
64061: LD_INT 103
64063: PPUSH
64064: CALL 58826 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64068: LD_ADDR_VAR 0 5
64072: PUSH
64073: LD_EXP 23
64077: PUSH
64078: LD_VAR 0 2
64082: ARRAY
64083: PUSH
64084: LD_EXP 52
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: UNION
64095: PPUSH
64096: LD_INT 2
64098: PUSH
64099: LD_INT 25
64101: PUSH
64102: LD_INT 2
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 25
64111: PUSH
64112: LD_INT 16
64114: PUSH
64115: EMPTY
64116: LIST
64117: LIST
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: LIST
64123: PUSH
64124: EMPTY
64125: LIST
64126: PPUSH
64127: CALL_OW 72
64131: ST_TO_ADDR
// if mc_need_heal [ i ] then
64132: LD_EXP 26
64136: PUSH
64137: LD_VAR 0 2
64141: ARRAY
64142: IFFALSE 64186
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64144: LD_ADDR_VAR 0 5
64148: PUSH
64149: LD_VAR 0 5
64153: PUSH
64154: LD_EXP 26
64158: PUSH
64159: LD_VAR 0 2
64163: ARRAY
64164: PUSH
64165: LD_INT 1
64167: ARRAY
64168: PUSH
64169: LD_EXP 26
64173: PUSH
64174: LD_VAR 0 2
64178: ARRAY
64179: PUSH
64180: LD_INT 2
64182: ARRAY
64183: UNION
64184: DIFF
64185: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64186: LD_ADDR_VAR 0 6
64190: PUSH
64191: LD_EXP 42
64195: PUSH
64196: LD_VAR 0 2
64200: ARRAY
64201: PPUSH
64202: LD_INT 2
64204: PUSH
64205: LD_INT 34
64207: PUSH
64208: LD_INT 13
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: LD_INT 34
64217: PUSH
64218: LD_INT 52
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: LD_INT 34
64227: PUSH
64228: LD_INT 88
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: EMPTY
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: PPUSH
64241: CALL_OW 72
64245: ST_TO_ADDR
// if cranes then
64246: LD_VAR 0 6
64250: IFFALSE 64422
// begin for j in cranes do
64252: LD_ADDR_VAR 0 3
64256: PUSH
64257: LD_VAR 0 6
64261: PUSH
64262: FOR_IN
64263: IFFALSE 64420
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64265: LD_VAR 0 3
64269: PPUSH
64270: CALL_OW 256
64274: PUSH
64275: LD_INT 1000
64277: EQUAL
64278: IFFALSE 64292
64280: PUSH
64281: LD_VAR 0 3
64285: PPUSH
64286: CALL_OW 314
64290: NOT
64291: AND
64292: IFFALSE 64358
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
64294: LD_ADDR_VAR 0 8
64298: PUSH
64299: LD_EXP 24
64303: PUSH
64304: LD_VAR 0 2
64308: ARRAY
64309: PPUSH
64310: LD_VAR 0 3
64314: PPUSH
64315: CALL_OW 74
64319: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64320: LD_VAR 0 8
64324: PPUSH
64325: LD_INT 16
64327: PPUSH
64328: CALL 19234 0 2
64332: PUSH
64333: LD_INT 4
64335: ARRAY
64336: PUSH
64337: LD_INT 10
64339: LESS
64340: IFFALSE 64356
// ComRepairBuilding ( j , to_repair ) ;
64342: LD_VAR 0 3
64346: PPUSH
64347: LD_VAR 0 8
64351: PPUSH
64352: CALL_OW 130
// end else
64356: GO 64418
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64358: LD_VAR 0 3
64362: PPUSH
64363: CALL_OW 256
64367: PUSH
64368: LD_INT 500
64370: LESS
64371: IFFALSE 64396
64373: PUSH
64374: LD_VAR 0 3
64378: PPUSH
64379: LD_EXP 47
64383: PUSH
64384: LD_VAR 0 2
64388: ARRAY
64389: PPUSH
64390: CALL_OW 308
64394: NOT
64395: AND
64396: IFFALSE 64418
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64398: LD_VAR 0 3
64402: PPUSH
64403: LD_EXP 47
64407: PUSH
64408: LD_VAR 0 2
64412: ARRAY
64413: PPUSH
64414: CALL_OW 113
// end ;
64418: GO 64262
64420: POP
64421: POP
// end ; if tmp > 3 then
64422: LD_VAR 0 5
64426: PUSH
64427: LD_INT 3
64429: GREATER
64430: IFFALSE 64450
// tmp := ShrinkArray ( tmp , 4 ) ;
64432: LD_ADDR_VAR 0 5
64436: PUSH
64437: LD_VAR 0 5
64441: PPUSH
64442: LD_INT 4
64444: PPUSH
64445: CALL 49618 0 2
64449: ST_TO_ADDR
// if not tmp then
64450: LD_VAR 0 5
64454: NOT
64455: IFFALSE 64459
// continue ;
64457: GO 63835
// for j in tmp do
64459: LD_ADDR_VAR 0 3
64463: PUSH
64464: LD_VAR 0 5
64468: PUSH
64469: FOR_IN
64470: IFFALSE 64729
// begin if IsInUnit ( j ) then
64472: LD_VAR 0 3
64476: PPUSH
64477: CALL_OW 310
64481: IFFALSE 64492
// ComExitBuilding ( j ) ;
64483: LD_VAR 0 3
64487: PPUSH
64488: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64492: LD_VAR 0 3
64496: PUSH
64497: LD_EXP 25
64501: PUSH
64502: LD_VAR 0 2
64506: ARRAY
64507: IN
64508: NOT
64509: IFFALSE 64567
// begin SetTag ( j , 101 ) ;
64511: LD_VAR 0 3
64515: PPUSH
64516: LD_INT 101
64518: PPUSH
64519: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64523: LD_ADDR_EXP 25
64527: PUSH
64528: LD_EXP 25
64532: PPUSH
64533: LD_VAR 0 2
64537: PUSH
64538: LD_EXP 25
64542: PUSH
64543: LD_VAR 0 2
64547: ARRAY
64548: PUSH
64549: LD_INT 1
64551: PLUS
64552: PUSH
64553: EMPTY
64554: LIST
64555: LIST
64556: PPUSH
64557: LD_VAR 0 3
64561: PPUSH
64562: CALL 16255 0 3
64566: ST_TO_ADDR
// end ; wait ( 1 ) ;
64567: LD_INT 1
64569: PPUSH
64570: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64574: LD_ADDR_VAR 0 7
64578: PUSH
64579: LD_EXP 24
64583: PUSH
64584: LD_VAR 0 2
64588: ARRAY
64589: ST_TO_ADDR
// if mc_scan [ i ] then
64590: LD_EXP 46
64594: PUSH
64595: LD_VAR 0 2
64599: ARRAY
64600: IFFALSE 64662
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64602: LD_ADDR_VAR 0 7
64606: PUSH
64607: LD_EXP 24
64611: PUSH
64612: LD_VAR 0 2
64616: ARRAY
64617: PPUSH
64618: LD_INT 3
64620: PUSH
64621: LD_INT 30
64623: PUSH
64624: LD_INT 32
64626: PUSH
64627: EMPTY
64628: LIST
64629: LIST
64630: PUSH
64631: LD_INT 30
64633: PUSH
64634: LD_INT 33
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 30
64643: PUSH
64644: LD_INT 31
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: LIST
64655: LIST
64656: PPUSH
64657: CALL_OW 72
64661: ST_TO_ADDR
// if not to_repair_tmp then
64662: LD_VAR 0 7
64666: NOT
64667: IFFALSE 64671
// continue ;
64669: GO 64469
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64671: LD_ADDR_VAR 0 8
64675: PUSH
64676: LD_VAR 0 7
64680: PPUSH
64681: LD_VAR 0 3
64685: PPUSH
64686: CALL_OW 74
64690: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
64691: LD_VAR 0 8
64695: PPUSH
64696: LD_INT 16
64698: PPUSH
64699: CALL 19234 0 2
64703: PUSH
64704: LD_INT 4
64706: ARRAY
64707: PUSH
64708: LD_INT 14
64710: LESS
64711: IFFALSE 64727
// ComRepairBuilding ( j , to_repair ) ;
64713: LD_VAR 0 3
64717: PPUSH
64718: LD_VAR 0 8
64722: PPUSH
64723: CALL_OW 130
// end ;
64727: GO 64469
64729: POP
64730: POP
// end ;
64731: GO 63835
64733: POP
64734: POP
// end ;
64735: LD_VAR 0 1
64739: RET
// export function MC_Heal ; var i , j , tmp ; begin
64740: LD_INT 0
64742: PPUSH
64743: PPUSH
64744: PPUSH
64745: PPUSH
// if not mc_bases then
64746: LD_EXP 23
64750: NOT
64751: IFFALSE 64755
// exit ;
64753: GO 65161
// for i = 1 to mc_bases do
64755: LD_ADDR_VAR 0 2
64759: PUSH
64760: DOUBLE
64761: LD_INT 1
64763: DEC
64764: ST_TO_ADDR
64765: LD_EXP 23
64769: PUSH
64770: FOR_TO
64771: IFFALSE 65159
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64773: LD_EXP 26
64777: PUSH
64778: LD_VAR 0 2
64782: ARRAY
64783: PUSH
64784: LD_INT 1
64786: ARRAY
64787: NOT
64788: IFFALSE 64807
64790: PUSH
64791: LD_EXP 26
64795: PUSH
64796: LD_VAR 0 2
64800: ARRAY
64801: PUSH
64802: LD_INT 2
64804: ARRAY
64805: NOT
64806: AND
64807: IFFALSE 64845
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64809: LD_ADDR_EXP 27
64813: PUSH
64814: LD_EXP 27
64818: PPUSH
64819: LD_VAR 0 2
64823: PPUSH
64824: EMPTY
64825: PPUSH
64826: CALL_OW 1
64830: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64831: LD_VAR 0 2
64835: PPUSH
64836: LD_INT 102
64838: PPUSH
64839: CALL 58826 0 2
// continue ;
64843: GO 64770
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64845: LD_ADDR_VAR 0 4
64849: PUSH
64850: LD_EXP 23
64854: PUSH
64855: LD_VAR 0 2
64859: ARRAY
64860: PPUSH
64861: LD_INT 25
64863: PUSH
64864: LD_INT 4
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PPUSH
64871: CALL_OW 72
64875: ST_TO_ADDR
// if not tmp then
64876: LD_VAR 0 4
64880: NOT
64881: IFFALSE 64885
// continue ;
64883: GO 64770
// if mc_taming [ i ] then
64885: LD_EXP 54
64889: PUSH
64890: LD_VAR 0 2
64894: ARRAY
64895: IFFALSE 64919
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64897: LD_ADDR_EXP 54
64901: PUSH
64902: LD_EXP 54
64906: PPUSH
64907: LD_VAR 0 2
64911: PPUSH
64912: EMPTY
64913: PPUSH
64914: CALL_OW 1
64918: ST_TO_ADDR
// for j in tmp do
64919: LD_ADDR_VAR 0 3
64923: PUSH
64924: LD_VAR 0 4
64928: PUSH
64929: FOR_IN
64930: IFFALSE 65155
// begin if IsInUnit ( j ) then
64932: LD_VAR 0 3
64936: PPUSH
64937: CALL_OW 310
64941: IFFALSE 64952
// ComExitBuilding ( j ) ;
64943: LD_VAR 0 3
64947: PPUSH
64948: CALL_OW 122
// if not j in mc_healers [ i ] then
64952: LD_VAR 0 3
64956: PUSH
64957: LD_EXP 27
64961: PUSH
64962: LD_VAR 0 2
64966: ARRAY
64967: IN
64968: NOT
64969: IFFALSE 65015
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64971: LD_ADDR_EXP 27
64975: PUSH
64976: LD_EXP 27
64980: PPUSH
64981: LD_VAR 0 2
64985: PUSH
64986: LD_EXP 27
64990: PUSH
64991: LD_VAR 0 2
64995: ARRAY
64996: PUSH
64997: LD_INT 1
64999: PLUS
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: PPUSH
65005: LD_VAR 0 3
65009: PPUSH
65010: CALL 16255 0 3
65014: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65015: LD_VAR 0 3
65019: PPUSH
65020: CALL_OW 110
65024: PUSH
65025: LD_INT 102
65027: NONEQUAL
65028: IFFALSE 65042
// SetTag ( j , 102 ) ;
65030: LD_VAR 0 3
65034: PPUSH
65035: LD_INT 102
65037: PPUSH
65038: CALL_OW 109
// Wait ( 3 ) ;
65042: LD_INT 3
65044: PPUSH
65045: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65049: LD_EXP 26
65053: PUSH
65054: LD_VAR 0 2
65058: ARRAY
65059: PUSH
65060: LD_INT 1
65062: ARRAY
65063: IFFALSE 65095
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65065: LD_VAR 0 3
65069: PPUSH
65070: LD_EXP 26
65074: PUSH
65075: LD_VAR 0 2
65079: ARRAY
65080: PUSH
65081: LD_INT 1
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: ARRAY
65088: PPUSH
65089: CALL_OW 128
65093: GO 65153
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65095: LD_VAR 0 3
65099: PPUSH
65100: CALL_OW 314
65104: NOT
65105: IFFALSE 65123
65107: PUSH
65108: LD_EXP 26
65112: PUSH
65113: LD_VAR 0 2
65117: ARRAY
65118: PUSH
65119: LD_INT 2
65121: ARRAY
65122: AND
65123: IFFALSE 65153
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65125: LD_VAR 0 3
65129: PPUSH
65130: LD_EXP 26
65134: PUSH
65135: LD_VAR 0 2
65139: ARRAY
65140: PUSH
65141: LD_INT 2
65143: ARRAY
65144: PUSH
65145: LD_INT 1
65147: ARRAY
65148: PPUSH
65149: CALL_OW 128
// end ;
65153: GO 64929
65155: POP
65156: POP
// end ;
65157: GO 64770
65159: POP
65160: POP
// end ;
65161: LD_VAR 0 1
65165: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
65166: LD_INT 0
65168: PPUSH
65169: PPUSH
65170: PPUSH
65171: PPUSH
65172: PPUSH
65173: PPUSH
// if not mc_bases then
65174: LD_EXP 23
65178: NOT
65179: IFFALSE 65183
// exit ;
65181: GO 66354
// for i = 1 to mc_bases do
65183: LD_ADDR_VAR 0 2
65187: PUSH
65188: DOUBLE
65189: LD_INT 1
65191: DEC
65192: ST_TO_ADDR
65193: LD_EXP 23
65197: PUSH
65198: FOR_TO
65199: IFFALSE 66352
// begin if mc_scan [ i ] then
65201: LD_EXP 46
65205: PUSH
65206: LD_VAR 0 2
65210: ARRAY
65211: IFFALSE 65215
// continue ;
65213: GO 65198
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65215: LD_EXP 28
65219: PUSH
65220: LD_VAR 0 2
65224: ARRAY
65225: NOT
65226: IFFALSE 65241
65228: PUSH
65229: LD_EXP 30
65233: PUSH
65234: LD_VAR 0 2
65238: ARRAY
65239: NOT
65240: AND
65241: IFFALSE 65255
65243: PUSH
65244: LD_EXP 29
65248: PUSH
65249: LD_VAR 0 2
65253: ARRAY
65254: AND
65255: IFFALSE 65293
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65257: LD_ADDR_EXP 29
65261: PUSH
65262: LD_EXP 29
65266: PPUSH
65267: LD_VAR 0 2
65271: PPUSH
65272: EMPTY
65273: PPUSH
65274: CALL_OW 1
65278: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65279: LD_VAR 0 2
65283: PPUSH
65284: LD_INT 103
65286: PPUSH
65287: CALL 58826 0 2
// continue ;
65291: GO 65198
// end ; if mc_construct_list [ i ] then
65293: LD_EXP 30
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: IFFALSE 65523
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65305: LD_ADDR_VAR 0 5
65309: PUSH
65310: LD_EXP 23
65314: PUSH
65315: LD_VAR 0 2
65319: ARRAY
65320: PPUSH
65321: LD_INT 25
65323: PUSH
65324: LD_INT 2
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PPUSH
65331: CALL_OW 72
65335: PUSH
65336: LD_EXP 25
65340: PUSH
65341: LD_VAR 0 2
65345: ARRAY
65346: DIFF
65347: ST_TO_ADDR
// if not tmp then
65348: LD_VAR 0 5
65352: NOT
65353: IFFALSE 65357
// continue ;
65355: GO 65198
// for j in tmp do
65357: LD_ADDR_VAR 0 3
65361: PUSH
65362: LD_VAR 0 5
65366: PUSH
65367: FOR_IN
65368: IFFALSE 65519
// begin if not mc_builders [ i ] then
65370: LD_EXP 29
65374: PUSH
65375: LD_VAR 0 2
65379: ARRAY
65380: NOT
65381: IFFALSE 65439
// begin SetTag ( j , 103 ) ;
65383: LD_VAR 0 3
65387: PPUSH
65388: LD_INT 103
65390: PPUSH
65391: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65395: LD_ADDR_EXP 29
65399: PUSH
65400: LD_EXP 29
65404: PPUSH
65405: LD_VAR 0 2
65409: PUSH
65410: LD_EXP 29
65414: PUSH
65415: LD_VAR 0 2
65419: ARRAY
65420: PUSH
65421: LD_INT 1
65423: PLUS
65424: PUSH
65425: EMPTY
65426: LIST
65427: LIST
65428: PPUSH
65429: LD_VAR 0 3
65433: PPUSH
65434: CALL 16255 0 3
65438: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65439: LD_VAR 0 3
65443: PPUSH
65444: CALL_OW 310
65448: IFFALSE 65459
// ComExitBuilding ( j ) ;
65450: LD_VAR 0 3
65454: PPUSH
65455: CALL_OW 122
// wait ( 3 ) ;
65459: LD_INT 3
65461: PPUSH
65462: CALL_OW 67
// if not mc_construct_list [ i ] then
65466: LD_EXP 30
65470: PUSH
65471: LD_VAR 0 2
65475: ARRAY
65476: NOT
65477: IFFALSE 65481
// break ;
65479: GO 65519
// if not HasTask ( j ) then
65481: LD_VAR 0 3
65485: PPUSH
65486: CALL_OW 314
65490: NOT
65491: IFFALSE 65517
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65493: LD_VAR 0 3
65497: PPUSH
65498: LD_EXP 30
65502: PUSH
65503: LD_VAR 0 2
65507: ARRAY
65508: PUSH
65509: LD_INT 1
65511: ARRAY
65512: PPUSH
65513: CALL 19507 0 2
// end ;
65517: GO 65367
65519: POP
65520: POP
// end else
65521: GO 66350
// if mc_build_list [ i ] then
65523: LD_EXP 28
65527: PUSH
65528: LD_VAR 0 2
65532: ARRAY
65533: IFFALSE 66350
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65535: LD_EXP 28
65539: PUSH
65540: LD_VAR 0 2
65544: ARRAY
65545: PUSH
65546: LD_INT 1
65548: ARRAY
65549: PUSH
65550: LD_INT 1
65552: ARRAY
65553: PPUSH
65554: CALL 19331 0 1
65558: IFFALSE 65606
65560: PUSH
65561: LD_EXP 23
65565: PUSH
65566: LD_VAR 0 2
65570: ARRAY
65571: PPUSH
65572: LD_INT 2
65574: PUSH
65575: LD_INT 30
65577: PUSH
65578: LD_INT 2
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: LD_INT 30
65587: PUSH
65588: LD_INT 3
65590: PUSH
65591: EMPTY
65592: LIST
65593: LIST
65594: PUSH
65595: EMPTY
65596: LIST
65597: LIST
65598: LIST
65599: PPUSH
65600: CALL_OW 72
65604: NOT
65605: AND
65606: IFFALSE 65711
// begin for j = 1 to mc_build_list [ i ] do
65608: LD_ADDR_VAR 0 3
65612: PUSH
65613: DOUBLE
65614: LD_INT 1
65616: DEC
65617: ST_TO_ADDR
65618: LD_EXP 28
65622: PUSH
65623: LD_VAR 0 2
65627: ARRAY
65628: PUSH
65629: FOR_TO
65630: IFFALSE 65709
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65632: LD_EXP 28
65636: PUSH
65637: LD_VAR 0 2
65641: ARRAY
65642: PUSH
65643: LD_VAR 0 3
65647: ARRAY
65648: PUSH
65649: LD_INT 1
65651: ARRAY
65652: PUSH
65653: LD_INT 2
65655: EQUAL
65656: IFFALSE 65707
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65658: LD_ADDR_EXP 28
65662: PUSH
65663: LD_EXP 28
65667: PPUSH
65668: LD_VAR 0 2
65672: PPUSH
65673: LD_EXP 28
65677: PUSH
65678: LD_VAR 0 2
65682: ARRAY
65683: PPUSH
65684: LD_VAR 0 3
65688: PPUSH
65689: LD_INT 1
65691: PPUSH
65692: LD_INT 0
65694: PPUSH
65695: CALL 15663 0 4
65699: PPUSH
65700: CALL_OW 1
65704: ST_TO_ADDR
// break ;
65705: GO 65709
// end ;
65707: GO 65629
65709: POP
65710: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65711: LD_ADDR_VAR 0 6
65715: PUSH
65716: LD_EXP 23
65720: PUSH
65721: LD_VAR 0 2
65725: ARRAY
65726: PPUSH
65727: LD_INT 2
65729: PUSH
65730: LD_INT 30
65732: PUSH
65733: LD_INT 0
65735: PUSH
65736: EMPTY
65737: LIST
65738: LIST
65739: PUSH
65740: LD_INT 30
65742: PUSH
65743: LD_INT 1
65745: PUSH
65746: EMPTY
65747: LIST
65748: LIST
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: LIST
65754: PPUSH
65755: CALL_OW 72
65759: ST_TO_ADDR
// for k := 1 to depot do
65760: LD_ADDR_VAR 0 4
65764: PUSH
65765: DOUBLE
65766: LD_INT 1
65768: DEC
65769: ST_TO_ADDR
65770: LD_VAR 0 6
65774: PUSH
65775: FOR_TO
65776: IFFALSE 66348
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65778: LD_EXP 28
65782: PUSH
65783: LD_VAR 0 2
65787: ARRAY
65788: PUSH
65789: LD_INT 1
65791: ARRAY
65792: PUSH
65793: LD_INT 1
65795: ARRAY
65796: PUSH
65797: LD_INT 0
65799: EQUAL
65800: IFTRUE 65895
65802: PUSH
65803: LD_VAR 0 6
65807: PUSH
65808: LD_VAR 0 4
65812: ARRAY
65813: PPUSH
65814: LD_EXP 28
65818: PUSH
65819: LD_VAR 0 2
65823: ARRAY
65824: PUSH
65825: LD_INT 1
65827: ARRAY
65828: PUSH
65829: LD_INT 1
65831: ARRAY
65832: PPUSH
65833: LD_EXP 28
65837: PUSH
65838: LD_VAR 0 2
65842: ARRAY
65843: PUSH
65844: LD_INT 1
65846: ARRAY
65847: PUSH
65848: LD_INT 2
65850: ARRAY
65851: PPUSH
65852: LD_EXP 28
65856: PUSH
65857: LD_VAR 0 2
65861: ARRAY
65862: PUSH
65863: LD_INT 1
65865: ARRAY
65866: PUSH
65867: LD_INT 3
65869: ARRAY
65870: PPUSH
65871: LD_EXP 28
65875: PUSH
65876: LD_VAR 0 2
65880: ARRAY
65881: PUSH
65882: LD_INT 1
65884: ARRAY
65885: PUSH
65886: LD_INT 4
65888: ARRAY
65889: PPUSH
65890: CALL 24811 0 5
65894: OR
65895: IFFALSE 66176
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65897: LD_ADDR_VAR 0 5
65901: PUSH
65902: LD_EXP 23
65906: PUSH
65907: LD_VAR 0 2
65911: ARRAY
65912: PPUSH
65913: LD_INT 25
65915: PUSH
65916: LD_INT 2
65918: PUSH
65919: EMPTY
65920: LIST
65921: LIST
65922: PPUSH
65923: CALL_OW 72
65927: PUSH
65928: LD_EXP 25
65932: PUSH
65933: LD_VAR 0 2
65937: ARRAY
65938: DIFF
65939: ST_TO_ADDR
// if not tmp then
65940: LD_VAR 0 5
65944: NOT
65945: IFFALSE 65949
// continue ;
65947: GO 65775
// for j in tmp do
65949: LD_ADDR_VAR 0 3
65953: PUSH
65954: LD_VAR 0 5
65958: PUSH
65959: FOR_IN
65960: IFFALSE 66172
// begin if not mc_builders [ i ] then
65962: LD_EXP 29
65966: PUSH
65967: LD_VAR 0 2
65971: ARRAY
65972: NOT
65973: IFFALSE 66031
// begin SetTag ( j , 103 ) ;
65975: LD_VAR 0 3
65979: PPUSH
65980: LD_INT 103
65982: PPUSH
65983: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65987: LD_ADDR_EXP 29
65991: PUSH
65992: LD_EXP 29
65996: PPUSH
65997: LD_VAR 0 2
66001: PUSH
66002: LD_EXP 29
66006: PUSH
66007: LD_VAR 0 2
66011: ARRAY
66012: PUSH
66013: LD_INT 1
66015: PLUS
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PPUSH
66021: LD_VAR 0 3
66025: PPUSH
66026: CALL 16255 0 3
66030: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66031: LD_VAR 0 3
66035: PPUSH
66036: CALL_OW 310
66040: IFFALSE 66051
// ComExitBuilding ( j ) ;
66042: LD_VAR 0 3
66046: PPUSH
66047: CALL_OW 122
// wait ( 3 ) ;
66051: LD_INT 3
66053: PPUSH
66054: CALL_OW 67
// if not mc_build_list [ i ] then
66058: LD_EXP 28
66062: PUSH
66063: LD_VAR 0 2
66067: ARRAY
66068: NOT
66069: IFFALSE 66073
// break ;
66071: GO 66172
// if not HasTask ( j ) then
66073: LD_VAR 0 3
66077: PPUSH
66078: CALL_OW 314
66082: NOT
66083: IFFALSE 66170
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66085: LD_VAR 0 3
66089: PPUSH
66090: LD_EXP 28
66094: PUSH
66095: LD_VAR 0 2
66099: ARRAY
66100: PUSH
66101: LD_INT 1
66103: ARRAY
66104: PUSH
66105: LD_INT 1
66107: ARRAY
66108: PPUSH
66109: LD_EXP 28
66113: PUSH
66114: LD_VAR 0 2
66118: ARRAY
66119: PUSH
66120: LD_INT 1
66122: ARRAY
66123: PUSH
66124: LD_INT 2
66126: ARRAY
66127: PPUSH
66128: LD_EXP 28
66132: PUSH
66133: LD_VAR 0 2
66137: ARRAY
66138: PUSH
66139: LD_INT 1
66141: ARRAY
66142: PUSH
66143: LD_INT 3
66145: ARRAY
66146: PPUSH
66147: LD_EXP 28
66151: PUSH
66152: LD_VAR 0 2
66156: ARRAY
66157: PUSH
66158: LD_INT 1
66160: ARRAY
66161: PUSH
66162: LD_INT 4
66164: ARRAY
66165: PPUSH
66166: CALL_OW 145
// end ;
66170: GO 65959
66172: POP
66173: POP
// end else
66174: GO 66346
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66176: LD_EXP 23
66180: PUSH
66181: LD_VAR 0 2
66185: ARRAY
66186: PPUSH
66187: LD_EXP 28
66191: PUSH
66192: LD_VAR 0 2
66196: ARRAY
66197: PUSH
66198: LD_INT 1
66200: ARRAY
66201: PUSH
66202: LD_INT 1
66204: ARRAY
66205: PPUSH
66206: LD_EXP 28
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PUSH
66217: LD_INT 1
66219: ARRAY
66220: PUSH
66221: LD_INT 2
66223: ARRAY
66224: PPUSH
66225: LD_EXP 28
66229: PUSH
66230: LD_VAR 0 2
66234: ARRAY
66235: PUSH
66236: LD_INT 1
66238: ARRAY
66239: PUSH
66240: LD_INT 3
66242: ARRAY
66243: PPUSH
66244: LD_EXP 28
66248: PUSH
66249: LD_VAR 0 2
66253: ARRAY
66254: PUSH
66255: LD_INT 1
66257: ARRAY
66258: PUSH
66259: LD_INT 4
66261: ARRAY
66262: PPUSH
66263: LD_EXP 23
66267: PUSH
66268: LD_VAR 0 2
66272: ARRAY
66273: PPUSH
66274: LD_INT 21
66276: PUSH
66277: LD_INT 3
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PPUSH
66284: CALL_OW 72
66288: PPUSH
66289: EMPTY
66290: PPUSH
66291: CALL 23547 0 7
66295: NOT
66296: IFFALSE 66346
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66298: LD_ADDR_EXP 28
66302: PUSH
66303: LD_EXP 28
66307: PPUSH
66308: LD_VAR 0 2
66312: PPUSH
66313: LD_EXP 28
66317: PUSH
66318: LD_VAR 0 2
66322: ARRAY
66323: PPUSH
66324: LD_INT 1
66326: PPUSH
66327: LD_INT 1
66329: NEG
66330: PPUSH
66331: LD_INT 0
66333: PPUSH
66334: CALL 15663 0 4
66338: PPUSH
66339: CALL_OW 1
66343: ST_TO_ADDR
// continue ;
66344: GO 65775
// end ; end ;
66346: GO 65775
66348: POP
66349: POP
// end ; end ;
66350: GO 65198
66352: POP
66353: POP
// end ;
66354: LD_VAR 0 1
66358: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66359: LD_INT 0
66361: PPUSH
66362: PPUSH
66363: PPUSH
66364: PPUSH
66365: PPUSH
66366: PPUSH
// if not mc_bases then
66367: LD_EXP 23
66371: NOT
66372: IFFALSE 66376
// exit ;
66374: GO 66809
// for i = 1 to mc_bases do
66376: LD_ADDR_VAR 0 2
66380: PUSH
66381: DOUBLE
66382: LD_INT 1
66384: DEC
66385: ST_TO_ADDR
66386: LD_EXP 23
66390: PUSH
66391: FOR_TO
66392: IFFALSE 66807
// begin tmp := mc_build_upgrade [ i ] ;
66394: LD_ADDR_VAR 0 4
66398: PUSH
66399: LD_EXP 55
66403: PUSH
66404: LD_VAR 0 2
66408: ARRAY
66409: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66410: LD_ADDR_VAR 0 6
66414: PUSH
66415: LD_EXP 56
66419: PUSH
66420: LD_VAR 0 2
66424: ARRAY
66425: PPUSH
66426: LD_INT 2
66428: PUSH
66429: LD_INT 30
66431: PUSH
66432: LD_INT 6
66434: PUSH
66435: EMPTY
66436: LIST
66437: LIST
66438: PUSH
66439: LD_INT 30
66441: PUSH
66442: LD_INT 7
66444: PUSH
66445: EMPTY
66446: LIST
66447: LIST
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: LIST
66453: PPUSH
66454: CALL_OW 72
66458: ST_TO_ADDR
// if not tmp and not lab then
66459: LD_VAR 0 4
66463: NOT
66464: IFFALSE 66473
66466: PUSH
66467: LD_VAR 0 6
66471: NOT
66472: AND
66473: IFFALSE 66477
// continue ;
66475: GO 66391
// if tmp then
66477: LD_VAR 0 4
66481: IFFALSE 66601
// for j in tmp do
66483: LD_ADDR_VAR 0 3
66487: PUSH
66488: LD_VAR 0 4
66492: PUSH
66493: FOR_IN
66494: IFFALSE 66599
// begin if UpgradeCost ( j ) then
66496: LD_VAR 0 3
66500: PPUSH
66501: CALL 23199 0 1
66505: IFFALSE 66597
// begin ComUpgrade ( j ) ;
66507: LD_VAR 0 3
66511: PPUSH
66512: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66516: LD_ADDR_EXP 55
66520: PUSH
66521: LD_EXP 55
66525: PPUSH
66526: LD_VAR 0 2
66530: PPUSH
66531: LD_EXP 55
66535: PUSH
66536: LD_VAR 0 2
66540: ARRAY
66541: PUSH
66542: LD_VAR 0 3
66546: DIFF
66547: PPUSH
66548: CALL_OW 1
66552: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66553: LD_ADDR_EXP 30
66557: PUSH
66558: LD_EXP 30
66562: PPUSH
66563: LD_VAR 0 2
66567: PUSH
66568: LD_EXP 30
66572: PUSH
66573: LD_VAR 0 2
66577: ARRAY
66578: PUSH
66579: LD_INT 1
66581: PLUS
66582: PUSH
66583: EMPTY
66584: LIST
66585: LIST
66586: PPUSH
66587: LD_VAR 0 3
66591: PPUSH
66592: CALL 16255 0 3
66596: ST_TO_ADDR
// end ; end ;
66597: GO 66493
66599: POP
66600: POP
// if not lab or not mc_lab_upgrade [ i ] then
66601: LD_VAR 0 6
66605: NOT
66606: IFTRUE 66621
66608: PUSH
66609: LD_EXP 57
66613: PUSH
66614: LD_VAR 0 2
66618: ARRAY
66619: NOT
66620: OR
66621: IFFALSE 66625
// continue ;
66623: GO 66391
// for j in lab do
66625: LD_ADDR_VAR 0 3
66629: PUSH
66630: LD_VAR 0 6
66634: PUSH
66635: FOR_IN
66636: IFFALSE 66803
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66638: LD_VAR 0 3
66642: PPUSH
66643: CALL_OW 266
66647: PUSH
66648: LD_INT 6
66650: PUSH
66651: LD_INT 7
66653: PUSH
66654: EMPTY
66655: LIST
66656: LIST
66657: IN
66658: IFFALSE 66675
66660: PUSH
66661: LD_VAR 0 3
66665: PPUSH
66666: CALL_OW 461
66670: PUSH
66671: LD_INT 1
66673: NONEQUAL
66674: AND
66675: IFFALSE 66801
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66677: LD_VAR 0 3
66681: PPUSH
66682: LD_EXP 57
66686: PUSH
66687: LD_VAR 0 2
66691: ARRAY
66692: PUSH
66693: LD_INT 1
66695: ARRAY
66696: PPUSH
66697: CALL 23408 0 2
66701: IFFALSE 66801
// begin ComCancel ( j ) ;
66703: LD_VAR 0 3
66707: PPUSH
66708: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66712: LD_VAR 0 3
66716: PPUSH
66717: LD_EXP 57
66721: PUSH
66722: LD_VAR 0 2
66726: ARRAY
66727: PUSH
66728: LD_INT 1
66730: ARRAY
66731: PPUSH
66732: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66736: LD_VAR 0 3
66740: PUSH
66741: LD_EXP 30
66745: PUSH
66746: LD_VAR 0 2
66750: ARRAY
66751: IN
66752: NOT
66753: IFFALSE 66799
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66755: LD_ADDR_EXP 30
66759: PUSH
66760: LD_EXP 30
66764: PPUSH
66765: LD_VAR 0 2
66769: PUSH
66770: LD_EXP 30
66774: PUSH
66775: LD_VAR 0 2
66779: ARRAY
66780: PUSH
66781: LD_INT 1
66783: PLUS
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PPUSH
66789: LD_VAR 0 3
66793: PPUSH
66794: CALL 16255 0 3
66798: ST_TO_ADDR
// break ;
66799: GO 66803
// end ; end ; end ;
66801: GO 66635
66803: POP
66804: POP
// end ;
66805: GO 66391
66807: POP
66808: POP
// end ;
66809: LD_VAR 0 1
66813: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66814: LD_INT 0
66816: PPUSH
66817: PPUSH
66818: PPUSH
66819: PPUSH
66820: PPUSH
66821: PPUSH
66822: PPUSH
66823: PPUSH
66824: PPUSH
// if not mc_bases then
66825: LD_EXP 23
66829: NOT
66830: IFFALSE 66834
// exit ;
66832: GO 67241
// for i = 1 to mc_bases do
66834: LD_ADDR_VAR 0 2
66838: PUSH
66839: DOUBLE
66840: LD_INT 1
66842: DEC
66843: ST_TO_ADDR
66844: LD_EXP 23
66848: PUSH
66849: FOR_TO
66850: IFFALSE 67239
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66852: LD_EXP 31
66856: PUSH
66857: LD_VAR 0 2
66861: ARRAY
66862: NOT
66863: IFTRUE 66893
66865: PUSH
66866: LD_EXP 23
66870: PUSH
66871: LD_VAR 0 2
66875: ARRAY
66876: PPUSH
66877: LD_INT 30
66879: PUSH
66880: LD_INT 3
66882: PUSH
66883: EMPTY
66884: LIST
66885: LIST
66886: PPUSH
66887: CALL_OW 72
66891: NOT
66892: OR
66893: IFFALSE 66897
// continue ;
66895: GO 66849
// busy := false ;
66897: LD_ADDR_VAR 0 8
66901: PUSH
66902: LD_INT 0
66904: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66905: LD_ADDR_VAR 0 4
66909: PUSH
66910: LD_EXP 23
66914: PUSH
66915: LD_VAR 0 2
66919: ARRAY
66920: PPUSH
66921: LD_INT 30
66923: PUSH
66924: LD_INT 3
66926: PUSH
66927: EMPTY
66928: LIST
66929: LIST
66930: PPUSH
66931: CALL_OW 72
66935: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66936: LD_ADDR_VAR 0 6
66940: PUSH
66941: LD_EXP 31
66945: PUSH
66946: LD_VAR 0 2
66950: ARRAY
66951: PPUSH
66952: LD_INT 2
66954: PUSH
66955: LD_INT 30
66957: PUSH
66958: LD_INT 32
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PUSH
66965: LD_INT 30
66967: PUSH
66968: LD_INT 33
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: EMPTY
66976: LIST
66977: LIST
66978: LIST
66979: PPUSH
66980: CALL_OW 72
66984: ST_TO_ADDR
// if not t then
66985: LD_VAR 0 6
66989: NOT
66990: IFFALSE 66994
// continue ;
66992: GO 66849
// for j in tmp do
66994: LD_ADDR_VAR 0 3
66998: PUSH
66999: LD_VAR 0 4
67003: PUSH
67004: FOR_IN
67005: IFFALSE 67035
// if not BuildingStatus ( j ) = bs_idle then
67007: LD_VAR 0 3
67011: PPUSH
67012: CALL_OW 461
67016: PUSH
67017: LD_INT 2
67019: EQUAL
67020: NOT
67021: IFFALSE 67033
// begin busy := true ;
67023: LD_ADDR_VAR 0 8
67027: PUSH
67028: LD_INT 1
67030: ST_TO_ADDR
// break ;
67031: GO 67035
// end ;
67033: GO 67004
67035: POP
67036: POP
// if busy then
67037: LD_VAR 0 8
67041: IFFALSE 67045
// continue ;
67043: GO 66849
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67045: LD_ADDR_VAR 0 7
67049: PUSH
67050: LD_VAR 0 6
67054: PPUSH
67055: LD_INT 35
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PPUSH
67065: CALL_OW 72
67069: ST_TO_ADDR
// if tw then
67070: LD_VAR 0 7
67074: IFFALSE 67151
// begin tw := tw [ 1 ] ;
67076: LD_ADDR_VAR 0 7
67080: PUSH
67081: LD_VAR 0 7
67085: PUSH
67086: LD_INT 1
67088: ARRAY
67089: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67090: LD_ADDR_VAR 0 9
67094: PUSH
67095: LD_VAR 0 7
67099: PPUSH
67100: LD_EXP 48
67104: PUSH
67105: LD_VAR 0 2
67109: ARRAY
67110: PPUSH
67111: CALL 21662 0 2
67115: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67116: LD_EXP 62
67120: PUSH
67121: LD_VAR 0 2
67125: ARRAY
67126: IFFALSE 67149
// if not weapon in mc_allowed_tower_weapons [ i ] then
67128: LD_VAR 0 9
67132: PUSH
67133: LD_EXP 62
67137: PUSH
67138: LD_VAR 0 2
67142: ARRAY
67143: IN
67144: NOT
67145: IFFALSE 67149
// continue ;
67147: GO 66849
// end else
67149: GO 67214
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67151: LD_ADDR_VAR 0 5
67155: PUSH
67156: LD_EXP 31
67160: PUSH
67161: LD_VAR 0 2
67165: ARRAY
67166: PPUSH
67167: LD_VAR 0 4
67171: PPUSH
67172: CALL 48847 0 2
67176: ST_TO_ADDR
// if not tmp2 then
67177: LD_VAR 0 5
67181: NOT
67182: IFFALSE 67186
// continue ;
67184: GO 66849
// tw := tmp2 [ 1 ] ;
67186: LD_ADDR_VAR 0 7
67190: PUSH
67191: LD_VAR 0 5
67195: PUSH
67196: LD_INT 1
67198: ARRAY
67199: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67200: LD_ADDR_VAR 0 9
67204: PUSH
67205: LD_VAR 0 5
67209: PUSH
67210: LD_INT 2
67212: ARRAY
67213: ST_TO_ADDR
// end ; if not weapon then
67214: LD_VAR 0 9
67218: NOT
67219: IFFALSE 67223
// continue ;
67221: GO 66849
// ComPlaceWeapon ( tw , weapon ) ;
67223: LD_VAR 0 7
67227: PPUSH
67228: LD_VAR 0 9
67232: PPUSH
67233: CALL_OW 148
// end ;
67237: GO 66849
67239: POP
67240: POP
// end ;
67241: LD_VAR 0 1
67245: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67246: LD_INT 0
67248: PPUSH
67249: PPUSH
67250: PPUSH
67251: PPUSH
67252: PPUSH
67253: PPUSH
67254: PPUSH
// if not mc_bases then
67255: LD_EXP 23
67259: NOT
67260: IFFALSE 67264
// exit ;
67262: GO 68051
// for i = 1 to mc_bases do
67264: LD_ADDR_VAR 0 2
67268: PUSH
67269: DOUBLE
67270: LD_INT 1
67272: DEC
67273: ST_TO_ADDR
67274: LD_EXP 23
67278: PUSH
67279: FOR_TO
67280: IFFALSE 68049
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67282: LD_EXP 36
67286: PUSH
67287: LD_VAR 0 2
67291: ARRAY
67292: NOT
67293: IFTRUE 67319
67295: PUSH
67296: LD_EXP 36
67300: PUSH
67301: LD_VAR 0 2
67305: ARRAY
67306: PUSH
67307: LD_EXP 37
67311: PUSH
67312: LD_VAR 0 2
67316: ARRAY
67317: EQUAL
67318: OR
67319: IFTRUE 67333
67321: PUSH
67322: LD_EXP 46
67326: PUSH
67327: LD_VAR 0 2
67331: ARRAY
67332: OR
67333: IFFALSE 67337
// continue ;
67335: GO 67279
// if mc_miners [ i ] then
67337: LD_EXP 37
67341: PUSH
67342: LD_VAR 0 2
67346: ARRAY
67347: IFFALSE 67734
// begin for j = mc_miners [ i ] downto 1 do
67349: LD_ADDR_VAR 0 3
67353: PUSH
67354: DOUBLE
67355: LD_EXP 37
67359: PUSH
67360: LD_VAR 0 2
67364: ARRAY
67365: INC
67366: ST_TO_ADDR
67367: LD_INT 1
67369: PUSH
67370: FOR_DOWNTO
67371: IFFALSE 67732
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67373: LD_EXP 37
67377: PUSH
67378: LD_VAR 0 2
67382: ARRAY
67383: PUSH
67384: LD_VAR 0 3
67388: ARRAY
67389: PPUSH
67390: CALL_OW 301
67394: IFTRUE 67423
67396: PUSH
67397: LD_EXP 37
67401: PUSH
67402: LD_VAR 0 2
67406: ARRAY
67407: PUSH
67408: LD_VAR 0 3
67412: ARRAY
67413: PPUSH
67414: CALL_OW 257
67418: PUSH
67419: LD_INT 1
67421: NONEQUAL
67422: OR
67423: IFFALSE 67486
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67425: LD_ADDR_VAR 0 5
67429: PUSH
67430: LD_EXP 37
67434: PUSH
67435: LD_VAR 0 2
67439: ARRAY
67440: PUSH
67441: LD_EXP 37
67445: PUSH
67446: LD_VAR 0 2
67450: ARRAY
67451: PUSH
67452: LD_VAR 0 3
67456: ARRAY
67457: DIFF
67458: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67459: LD_ADDR_EXP 37
67463: PUSH
67464: LD_EXP 37
67468: PPUSH
67469: LD_VAR 0 2
67473: PPUSH
67474: LD_VAR 0 5
67478: PPUSH
67479: CALL_OW 1
67483: ST_TO_ADDR
// continue ;
67484: GO 67370
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67486: LD_EXP 37
67490: PUSH
67491: LD_VAR 0 2
67495: ARRAY
67496: PUSH
67497: LD_VAR 0 3
67501: ARRAY
67502: PPUSH
67503: CALL_OW 257
67507: PUSH
67508: LD_INT 1
67510: EQUAL
67511: IFFALSE 67537
67513: PUSH
67514: LD_EXP 37
67518: PUSH
67519: LD_VAR 0 2
67523: ARRAY
67524: PUSH
67525: LD_VAR 0 3
67529: ARRAY
67530: PPUSH
67531: CALL_OW 459
67535: NOT
67536: AND
67537: IFFALSE 67563
67539: PUSH
67540: LD_EXP 37
67544: PUSH
67545: LD_VAR 0 2
67549: ARRAY
67550: PUSH
67551: LD_VAR 0 3
67555: ARRAY
67556: PPUSH
67557: CALL_OW 314
67561: NOT
67562: AND
67563: IFFALSE 67730
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67565: LD_EXP 37
67569: PUSH
67570: LD_VAR 0 2
67574: ARRAY
67575: PUSH
67576: LD_VAR 0 3
67580: ARRAY
67581: PPUSH
67582: CALL_OW 310
67586: IFFALSE 67609
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67588: LD_EXP 37
67592: PUSH
67593: LD_VAR 0 2
67597: ARRAY
67598: PUSH
67599: LD_VAR 0 3
67603: ARRAY
67604: PPUSH
67605: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67609: LD_EXP 37
67613: PUSH
67614: LD_VAR 0 2
67618: ARRAY
67619: PUSH
67620: LD_VAR 0 3
67624: ARRAY
67625: PPUSH
67626: CALL_OW 314
67630: NOT
67631: IFFALSE 67730
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
67633: LD_ADDR_VAR 0 7
67637: PUSH
67638: LD_VAR 0 3
67642: PUSH
67643: LD_EXP 36
67647: PUSH
67648: LD_VAR 0 2
67652: ARRAY
67653: PPUSH
67654: CALL 13371 0 1
67658: MOD
67659: PUSH
67660: LD_INT 1
67662: PLUS
67663: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67664: LD_EXP 37
67668: PUSH
67669: LD_VAR 0 2
67673: ARRAY
67674: PUSH
67675: LD_VAR 0 3
67679: ARRAY
67680: PPUSH
67681: LD_EXP 36
67685: PUSH
67686: LD_VAR 0 2
67690: ARRAY
67691: PUSH
67692: LD_VAR 0 7
67696: ARRAY
67697: PUSH
67698: LD_INT 1
67700: ARRAY
67701: PPUSH
67702: LD_EXP 36
67706: PUSH
67707: LD_VAR 0 2
67711: ARRAY
67712: PUSH
67713: LD_VAR 0 7
67717: ARRAY
67718: PUSH
67719: LD_INT 2
67721: ARRAY
67722: PPUSH
67723: LD_INT 0
67725: PPUSH
67726: CALL_OW 193
// end ; end ; end ;
67730: GO 67370
67732: POP
67733: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67734: LD_ADDR_VAR 0 5
67738: PUSH
67739: LD_EXP 23
67743: PUSH
67744: LD_VAR 0 2
67748: ARRAY
67749: PPUSH
67750: LD_INT 2
67752: PUSH
67753: LD_INT 30
67755: PUSH
67756: LD_INT 4
67758: PUSH
67759: EMPTY
67760: LIST
67761: LIST
67762: PUSH
67763: LD_INT 30
67765: PUSH
67766: LD_INT 5
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 30
67775: PUSH
67776: LD_INT 32
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: EMPTY
67784: LIST
67785: LIST
67786: LIST
67787: LIST
67788: PPUSH
67789: CALL_OW 72
67793: ST_TO_ADDR
// if not tmp then
67794: LD_VAR 0 5
67798: NOT
67799: IFFALSE 67803
// continue ;
67801: GO 67279
// list := [ ] ;
67803: LD_ADDR_VAR 0 6
67807: PUSH
67808: EMPTY
67809: ST_TO_ADDR
// for j in tmp do
67810: LD_ADDR_VAR 0 3
67814: PUSH
67815: LD_VAR 0 5
67819: PUSH
67820: FOR_IN
67821: IFFALSE 67892
// begin for k in UnitsInside ( j ) do
67823: LD_ADDR_VAR 0 4
67827: PUSH
67828: LD_VAR 0 3
67832: PPUSH
67833: CALL_OW 313
67837: PUSH
67838: FOR_IN
67839: IFFALSE 67888
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67841: LD_VAR 0 4
67845: PPUSH
67846: CALL_OW 257
67850: PUSH
67851: LD_INT 1
67853: EQUAL
67854: IFFALSE 67868
67856: PUSH
67857: LD_VAR 0 4
67861: PPUSH
67862: CALL_OW 459
67866: NOT
67867: AND
67868: IFFALSE 67886
// list := list ^ k ;
67870: LD_ADDR_VAR 0 6
67874: PUSH
67875: LD_VAR 0 6
67879: PUSH
67880: LD_VAR 0 4
67884: ADD
67885: ST_TO_ADDR
67886: GO 67838
67888: POP
67889: POP
// end ;
67890: GO 67820
67892: POP
67893: POP
// list := list diff mc_miners [ i ] ;
67894: LD_ADDR_VAR 0 6
67898: PUSH
67899: LD_VAR 0 6
67903: PUSH
67904: LD_EXP 37
67908: PUSH
67909: LD_VAR 0 2
67913: ARRAY
67914: DIFF
67915: ST_TO_ADDR
// if not list then
67916: LD_VAR 0 6
67920: NOT
67921: IFFALSE 67925
// continue ;
67923: GO 67279
// k := mc_mines [ i ] - mc_miners [ i ] ;
67925: LD_ADDR_VAR 0 4
67929: PUSH
67930: LD_EXP 36
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: PUSH
67941: LD_EXP 37
67945: PUSH
67946: LD_VAR 0 2
67950: ARRAY
67951: MINUS
67952: ST_TO_ADDR
// if k > list then
67953: LD_VAR 0 4
67957: PUSH
67958: LD_VAR 0 6
67962: GREATER
67963: IFFALSE 67975
// k := list ;
67965: LD_ADDR_VAR 0 4
67969: PUSH
67970: LD_VAR 0 6
67974: ST_TO_ADDR
// for j = 1 to k do
67975: LD_ADDR_VAR 0 3
67979: PUSH
67980: DOUBLE
67981: LD_INT 1
67983: DEC
67984: ST_TO_ADDR
67985: LD_VAR 0 4
67989: PUSH
67990: FOR_TO
67991: IFFALSE 68045
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67993: LD_ADDR_EXP 37
67997: PUSH
67998: LD_EXP 37
68002: PPUSH
68003: LD_VAR 0 2
68007: PUSH
68008: LD_EXP 37
68012: PUSH
68013: LD_VAR 0 2
68017: ARRAY
68018: PUSH
68019: LD_INT 1
68021: PLUS
68022: PUSH
68023: EMPTY
68024: LIST
68025: LIST
68026: PPUSH
68027: LD_VAR 0 6
68031: PUSH
68032: LD_VAR 0 3
68036: ARRAY
68037: PPUSH
68038: CALL 16255 0 3
68042: ST_TO_ADDR
68043: GO 67990
68045: POP
68046: POP
// end ;
68047: GO 67279
68049: POP
68050: POP
// end ;
68051: LD_VAR 0 1
68055: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68056: LD_INT 0
68058: PPUSH
68059: PPUSH
68060: PPUSH
68061: PPUSH
68062: PPUSH
68063: PPUSH
68064: PPUSH
68065: PPUSH
68066: PPUSH
68067: PPUSH
68068: PPUSH
// if not mc_bases then
68069: LD_EXP 23
68073: NOT
68074: IFFALSE 68078
// exit ;
68076: GO 69925
// for i = 1 to mc_bases do
68078: LD_ADDR_VAR 0 2
68082: PUSH
68083: DOUBLE
68084: LD_INT 1
68086: DEC
68087: ST_TO_ADDR
68088: LD_EXP 23
68092: PUSH
68093: FOR_TO
68094: IFFALSE 69923
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68096: LD_EXP 23
68100: PUSH
68101: LD_VAR 0 2
68105: ARRAY
68106: NOT
68107: IFTRUE 68121
68109: PUSH
68110: LD_EXP 30
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: OR
68121: IFFALSE 68125
// continue ;
68123: GO 68093
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68125: LD_EXP 39
68129: PUSH
68130: LD_VAR 0 2
68134: ARRAY
68135: NOT
68136: IFFALSE 68150
68138: PUSH
68139: LD_EXP 40
68143: PUSH
68144: LD_VAR 0 2
68148: ARRAY
68149: AND
68150: IFFALSE 68188
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68152: LD_ADDR_EXP 40
68156: PUSH
68157: LD_EXP 40
68161: PPUSH
68162: LD_VAR 0 2
68166: PPUSH
68167: EMPTY
68168: PPUSH
68169: CALL_OW 1
68173: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68174: LD_VAR 0 2
68178: PPUSH
68179: LD_INT 107
68181: PPUSH
68182: CALL 58826 0 2
// continue ;
68186: GO 68093
// end ; target := [ ] ;
68188: LD_ADDR_VAR 0 7
68192: PUSH
68193: EMPTY
68194: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68195: LD_ADDR_VAR 0 6
68199: PUSH
68200: LD_EXP 23
68204: PUSH
68205: LD_VAR 0 2
68209: ARRAY
68210: PUSH
68211: LD_INT 1
68213: ARRAY
68214: PPUSH
68215: CALL_OW 255
68219: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68220: LD_ADDR_VAR 0 9
68224: PUSH
68225: LD_EXP 23
68229: PUSH
68230: LD_VAR 0 2
68234: ARRAY
68235: PPUSH
68236: LD_INT 2
68238: PUSH
68239: LD_INT 30
68241: PUSH
68242: LD_INT 0
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 30
68251: PUSH
68252: LD_INT 1
68254: PUSH
68255: EMPTY
68256: LIST
68257: LIST
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: LIST
68263: PPUSH
68264: CALL_OW 72
68268: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68269: LD_ADDR_VAR 0 3
68273: PUSH
68274: DOUBLE
68275: LD_EXP 39
68279: PUSH
68280: LD_VAR 0 2
68284: ARRAY
68285: INC
68286: ST_TO_ADDR
68287: LD_INT 1
68289: PUSH
68290: FOR_DOWNTO
68291: IFFALSE 68538
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68293: LD_EXP 39
68297: PUSH
68298: LD_VAR 0 2
68302: ARRAY
68303: PUSH
68304: LD_VAR 0 3
68308: ARRAY
68309: PUSH
68310: LD_INT 2
68312: ARRAY
68313: PPUSH
68314: LD_EXP 39
68318: PUSH
68319: LD_VAR 0 2
68323: ARRAY
68324: PUSH
68325: LD_VAR 0 3
68329: ARRAY
68330: PUSH
68331: LD_INT 3
68333: ARRAY
68334: PPUSH
68335: CALL_OW 488
68339: IFFALSE 68393
68341: PUSH
68342: LD_EXP 39
68346: PUSH
68347: LD_VAR 0 2
68351: ARRAY
68352: PUSH
68353: LD_VAR 0 3
68357: ARRAY
68358: PUSH
68359: LD_INT 2
68361: ARRAY
68362: PPUSH
68363: LD_EXP 39
68367: PUSH
68368: LD_VAR 0 2
68372: ARRAY
68373: PUSH
68374: LD_VAR 0 3
68378: ARRAY
68379: PUSH
68380: LD_INT 3
68382: ARRAY
68383: PPUSH
68384: CALL_OW 284
68388: PUSH
68389: LD_INT 0
68391: EQUAL
68392: AND
68393: IFFALSE 68448
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68395: LD_ADDR_VAR 0 5
68399: PUSH
68400: LD_EXP 39
68404: PUSH
68405: LD_VAR 0 2
68409: ARRAY
68410: PPUSH
68411: LD_VAR 0 3
68415: PPUSH
68416: CALL_OW 3
68420: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68421: LD_ADDR_EXP 39
68425: PUSH
68426: LD_EXP 39
68430: PPUSH
68431: LD_VAR 0 2
68435: PPUSH
68436: LD_VAR 0 5
68440: PPUSH
68441: CALL_OW 1
68445: ST_TO_ADDR
// continue ;
68446: GO 68290
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68448: LD_VAR 0 6
68452: PPUSH
68453: LD_EXP 39
68457: PUSH
68458: LD_VAR 0 2
68462: ARRAY
68463: PUSH
68464: LD_VAR 0 3
68468: ARRAY
68469: PUSH
68470: LD_INT 2
68472: ARRAY
68473: PPUSH
68474: LD_EXP 39
68478: PUSH
68479: LD_VAR 0 2
68483: ARRAY
68484: PUSH
68485: LD_VAR 0 3
68489: ARRAY
68490: PUSH
68491: LD_INT 3
68493: ARRAY
68494: PPUSH
68495: LD_INT 30
68497: PPUSH
68498: CALL 17525 0 4
68502: PUSH
68503: LD_INT 4
68505: ARRAY
68506: PUSH
68507: LD_INT 0
68509: EQUAL
68510: IFFALSE 68536
// begin target := mc_crates [ i ] [ j ] ;
68512: LD_ADDR_VAR 0 7
68516: PUSH
68517: LD_EXP 39
68521: PUSH
68522: LD_VAR 0 2
68526: ARRAY
68527: PUSH
68528: LD_VAR 0 3
68532: ARRAY
68533: ST_TO_ADDR
// break ;
68534: GO 68538
// end ; end ;
68536: GO 68290
68538: POP
68539: POP
// if not target then
68540: LD_VAR 0 7
68544: NOT
68545: IFFALSE 68549
// continue ;
68547: GO 68093
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68549: LD_ADDR_VAR 0 8
68553: PUSH
68554: LD_EXP 42
68558: PUSH
68559: LD_VAR 0 2
68563: ARRAY
68564: PPUSH
68565: LD_INT 2
68567: PUSH
68568: LD_INT 3
68570: PUSH
68571: LD_INT 58
68573: PUSH
68574: EMPTY
68575: LIST
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: LD_INT 61
68583: PUSH
68584: EMPTY
68585: LIST
68586: PUSH
68587: LD_INT 33
68589: PUSH
68590: LD_INT 5
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: PUSH
68597: LD_INT 33
68599: PUSH
68600: LD_INT 3
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: LIST
68611: LIST
68612: LIST
68613: PUSH
68614: LD_INT 2
68616: PUSH
68617: LD_INT 34
68619: PUSH
68620: LD_INT 32
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: PUSH
68627: LD_INT 34
68629: PUSH
68630: LD_INT 51
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: PUSH
68637: LD_INT 34
68639: PUSH
68640: LD_INT 12
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: LIST
68651: LIST
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PPUSH
68657: CALL_OW 72
68661: ST_TO_ADDR
// if not cargo then
68662: LD_VAR 0 8
68666: NOT
68667: IFFALSE 69381
// begin if mc_crates_collector [ i ] < 5 then
68669: LD_EXP 40
68673: PUSH
68674: LD_VAR 0 2
68678: ARRAY
68679: PUSH
68680: LD_INT 5
68682: LESS
68683: IFFALSE 69053
// begin if mc_ape [ i ] then
68685: LD_EXP 52
68689: PUSH
68690: LD_VAR 0 2
68694: ARRAY
68695: IFFALSE 68742
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68697: LD_ADDR_VAR 0 5
68701: PUSH
68702: LD_EXP 52
68706: PUSH
68707: LD_VAR 0 2
68711: ARRAY
68712: PPUSH
68713: LD_INT 25
68715: PUSH
68716: LD_INT 16
68718: PUSH
68719: EMPTY
68720: LIST
68721: LIST
68722: PUSH
68723: LD_INT 24
68725: PUSH
68726: LD_INT 750
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: PPUSH
68737: CALL_OW 72
68741: ST_TO_ADDR
// if not tmp then
68742: LD_VAR 0 5
68746: NOT
68747: IFFALSE 68794
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68749: LD_ADDR_VAR 0 5
68753: PUSH
68754: LD_EXP 23
68758: PUSH
68759: LD_VAR 0 2
68763: ARRAY
68764: PPUSH
68765: LD_INT 25
68767: PUSH
68768: LD_INT 2
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: LD_INT 24
68777: PUSH
68778: LD_INT 750
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: PUSH
68785: EMPTY
68786: LIST
68787: LIST
68788: PPUSH
68789: CALL_OW 72
68793: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68794: LD_EXP 52
68798: PUSH
68799: LD_VAR 0 2
68803: ARRAY
68804: IFFALSE 68847
68806: PUSH
68807: LD_EXP 23
68811: PUSH
68812: LD_VAR 0 2
68816: ARRAY
68817: PPUSH
68818: LD_INT 25
68820: PUSH
68821: LD_INT 2
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: PUSH
68828: LD_INT 24
68830: PUSH
68831: LD_INT 750
68833: PUSH
68834: EMPTY
68835: LIST
68836: LIST
68837: PUSH
68838: EMPTY
68839: LIST
68840: LIST
68841: PPUSH
68842: CALL_OW 72
68846: AND
68847: IFFALSE 68859
68849: PUSH
68850: LD_VAR 0 5
68854: PUSH
68855: LD_INT 5
68857: LESS
68858: AND
68859: IFFALSE 68941
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68861: LD_ADDR_VAR 0 3
68865: PUSH
68866: LD_EXP 23
68870: PUSH
68871: LD_VAR 0 2
68875: ARRAY
68876: PPUSH
68877: LD_INT 25
68879: PUSH
68880: LD_INT 2
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 24
68889: PUSH
68890: LD_INT 750
68892: PUSH
68893: EMPTY
68894: LIST
68895: LIST
68896: PUSH
68897: EMPTY
68898: LIST
68899: LIST
68900: PPUSH
68901: CALL_OW 72
68905: PUSH
68906: FOR_IN
68907: IFFALSE 68939
// begin tmp := tmp union j ;
68909: LD_ADDR_VAR 0 5
68913: PUSH
68914: LD_VAR 0 5
68918: PUSH
68919: LD_VAR 0 3
68923: UNION
68924: ST_TO_ADDR
// if tmp >= 5 then
68925: LD_VAR 0 5
68929: PUSH
68930: LD_INT 5
68932: GREATEREQUAL
68933: IFFALSE 68937
// break ;
68935: GO 68939
// end ;
68937: GO 68906
68939: POP
68940: POP
// end ; if not tmp then
68941: LD_VAR 0 5
68945: NOT
68946: IFFALSE 68950
// continue ;
68948: GO 68093
// for j in tmp do
68950: LD_ADDR_VAR 0 3
68954: PUSH
68955: LD_VAR 0 5
68959: PUSH
68960: FOR_IN
68961: IFFALSE 69051
// if not GetTag ( j ) then
68963: LD_VAR 0 3
68967: PPUSH
68968: CALL_OW 110
68972: NOT
68973: IFFALSE 69049
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68975: LD_ADDR_EXP 40
68979: PUSH
68980: LD_EXP 40
68984: PPUSH
68985: LD_VAR 0 2
68989: PUSH
68990: LD_EXP 40
68994: PUSH
68995: LD_VAR 0 2
68999: ARRAY
69000: PUSH
69001: LD_INT 1
69003: PLUS
69004: PUSH
69005: EMPTY
69006: LIST
69007: LIST
69008: PPUSH
69009: LD_VAR 0 3
69013: PPUSH
69014: CALL 16255 0 3
69018: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69019: LD_VAR 0 3
69023: PPUSH
69024: LD_INT 107
69026: PPUSH
69027: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69031: LD_EXP 40
69035: PUSH
69036: LD_VAR 0 2
69040: ARRAY
69041: PUSH
69042: LD_INT 5
69044: GREATEREQUAL
69045: IFFALSE 69049
// break ;
69047: GO 69051
// end ;
69049: GO 68960
69051: POP
69052: POP
// end ; if mc_crates_collector [ i ] and target then
69053: LD_EXP 40
69057: PUSH
69058: LD_VAR 0 2
69062: ARRAY
69063: IFFALSE 69071
69065: PUSH
69066: LD_VAR 0 7
69070: AND
69071: IFFALSE 69379
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69073: LD_EXP 40
69077: PUSH
69078: LD_VAR 0 2
69082: ARRAY
69083: PUSH
69084: LD_VAR 0 7
69088: PUSH
69089: LD_INT 1
69091: ARRAY
69092: LESS
69093: IFFALSE 69113
// tmp := mc_crates_collector [ i ] else
69095: LD_ADDR_VAR 0 5
69099: PUSH
69100: LD_EXP 40
69104: PUSH
69105: LD_VAR 0 2
69109: ARRAY
69110: ST_TO_ADDR
69111: GO 69127
// tmp := target [ 1 ] ;
69113: LD_ADDR_VAR 0 5
69117: PUSH
69118: LD_VAR 0 7
69122: PUSH
69123: LD_INT 1
69125: ARRAY
69126: ST_TO_ADDR
// k := 0 ;
69127: LD_ADDR_VAR 0 4
69131: PUSH
69132: LD_INT 0
69134: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69135: LD_ADDR_VAR 0 3
69139: PUSH
69140: LD_EXP 40
69144: PUSH
69145: LD_VAR 0 2
69149: ARRAY
69150: PUSH
69151: FOR_IN
69152: IFFALSE 69377
// begin k := k + 1 ;
69154: LD_ADDR_VAR 0 4
69158: PUSH
69159: LD_VAR 0 4
69163: PUSH
69164: LD_INT 1
69166: PLUS
69167: ST_TO_ADDR
// if k > tmp then
69168: LD_VAR 0 4
69172: PUSH
69173: LD_VAR 0 5
69177: GREATER
69178: IFFALSE 69182
// break ;
69180: GO 69377
// if not GetClass ( j ) in [ 2 , 16 ] then
69182: LD_VAR 0 3
69186: PPUSH
69187: CALL_OW 257
69191: PUSH
69192: LD_INT 2
69194: PUSH
69195: LD_INT 16
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: IN
69202: NOT
69203: IFFALSE 69256
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69205: LD_ADDR_EXP 40
69209: PUSH
69210: LD_EXP 40
69214: PPUSH
69215: LD_VAR 0 2
69219: PPUSH
69220: LD_EXP 40
69224: PUSH
69225: LD_VAR 0 2
69229: ARRAY
69230: PUSH
69231: LD_VAR 0 3
69235: DIFF
69236: PPUSH
69237: CALL_OW 1
69241: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69242: LD_VAR 0 3
69246: PPUSH
69247: LD_INT 0
69249: PPUSH
69250: CALL_OW 109
// continue ;
69254: GO 69151
// end ; if IsInUnit ( j ) then
69256: LD_VAR 0 3
69260: PPUSH
69261: CALL_OW 310
69265: IFFALSE 69276
// ComExitBuilding ( j ) ;
69267: LD_VAR 0 3
69271: PPUSH
69272: CALL_OW 122
// wait ( 3 ) ;
69276: LD_INT 3
69278: PPUSH
69279: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69283: LD_VAR 0 3
69287: PPUSH
69288: CALL_OW 314
69292: IFFALSE 69330
69294: PUSH
69295: LD_VAR 0 6
69299: PPUSH
69300: LD_VAR 0 7
69304: PUSH
69305: LD_INT 2
69307: ARRAY
69308: PPUSH
69309: LD_VAR 0 7
69313: PUSH
69314: LD_INT 3
69316: ARRAY
69317: PPUSH
69318: LD_INT 30
69320: PPUSH
69321: CALL 17525 0 4
69325: PUSH
69326: LD_INT 4
69328: ARRAY
69329: AND
69330: IFFALSE 69348
// ComStandNearbyBuilding ( j , depot ) else
69332: LD_VAR 0 3
69336: PPUSH
69337: LD_VAR 0 9
69341: PPUSH
69342: CALL 12831 0 2
69346: GO 69375
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69348: LD_VAR 0 3
69352: PPUSH
69353: LD_VAR 0 7
69357: PUSH
69358: LD_INT 2
69360: ARRAY
69361: PPUSH
69362: LD_VAR 0 7
69366: PUSH
69367: LD_INT 3
69369: ARRAY
69370: PPUSH
69371: CALL_OW 117
// end ;
69375: GO 69151
69377: POP
69378: POP
// end ; end else
69379: GO 69921
// begin for j in cargo do
69381: LD_ADDR_VAR 0 3
69385: PUSH
69386: LD_VAR 0 8
69390: PUSH
69391: FOR_IN
69392: IFFALSE 69919
// begin if GetTag ( j ) <> 0 then
69394: LD_VAR 0 3
69398: PPUSH
69399: CALL_OW 110
69403: PUSH
69404: LD_INT 0
69406: NONEQUAL
69407: IFFALSE 69411
// continue ;
69409: GO 69391
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69411: LD_VAR 0 3
69415: PPUSH
69416: CALL_OW 256
69420: PUSH
69421: LD_INT 1000
69423: LESS
69424: IFFALSE 69449
69426: PUSH
69427: LD_VAR 0 3
69431: PPUSH
69432: LD_EXP 47
69436: PUSH
69437: LD_VAR 0 2
69441: ARRAY
69442: PPUSH
69443: CALL_OW 308
69447: NOT
69448: AND
69449: IFFALSE 69471
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69451: LD_VAR 0 3
69455: PPUSH
69456: LD_EXP 47
69460: PUSH
69461: LD_VAR 0 2
69465: ARRAY
69466: PPUSH
69467: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69471: LD_VAR 0 3
69475: PPUSH
69476: CALL_OW 256
69480: PUSH
69481: LD_INT 1000
69483: LESS
69484: IFFALSE 69508
69486: PUSH
69487: LD_VAR 0 3
69491: PPUSH
69492: LD_EXP 47
69496: PUSH
69497: LD_VAR 0 2
69501: ARRAY
69502: PPUSH
69503: CALL_OW 308
69507: AND
69508: IFFALSE 69512
// continue ;
69510: GO 69391
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69512: LD_VAR 0 3
69516: PPUSH
69517: CALL_OW 262
69521: PUSH
69522: LD_INT 2
69524: EQUAL
69525: IFFALSE 69542
69527: PUSH
69528: LD_VAR 0 3
69532: PPUSH
69533: CALL_OW 261
69537: PUSH
69538: LD_INT 15
69540: LESS
69541: AND
69542: IFFALSE 69546
// continue ;
69544: GO 69391
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69546: LD_VAR 0 3
69550: PPUSH
69551: CALL_OW 262
69555: PUSH
69556: LD_INT 1
69558: EQUAL
69559: IFFALSE 69576
69561: PUSH
69562: LD_VAR 0 3
69566: PPUSH
69567: CALL_OW 261
69571: PUSH
69572: LD_INT 10
69574: LESS
69575: AND
69576: IFFALSE 69856
// begin if not depot then
69578: LD_VAR 0 9
69582: NOT
69583: IFFALSE 69587
// continue ;
69585: GO 69391
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69587: LD_VAR 0 3
69591: PPUSH
69592: LD_VAR 0 9
69596: PPUSH
69597: LD_VAR 0 3
69601: PPUSH
69602: CALL_OW 74
69606: PPUSH
69607: CALL_OW 296
69611: PUSH
69612: LD_INT 6
69614: LESS
69615: IFFALSE 69631
// SetFuel ( j , 100 ) else
69617: LD_VAR 0 3
69621: PPUSH
69622: LD_INT 100
69624: PPUSH
69625: CALL_OW 240
69629: GO 69856
// if GetFuel ( j ) = 0 then
69631: LD_VAR 0 3
69635: PPUSH
69636: CALL_OW 261
69640: PUSH
69641: LD_INT 0
69643: EQUAL
69644: IFFALSE 69856
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69646: LD_ADDR_EXP 42
69650: PUSH
69651: LD_EXP 42
69655: PPUSH
69656: LD_VAR 0 2
69660: PPUSH
69661: LD_EXP 42
69665: PUSH
69666: LD_VAR 0 2
69670: ARRAY
69671: PUSH
69672: LD_VAR 0 3
69676: DIFF
69677: PPUSH
69678: CALL_OW 1
69682: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69683: LD_VAR 0 3
69687: PPUSH
69688: CALL_OW 263
69692: PUSH
69693: LD_INT 1
69695: EQUAL
69696: IFFALSE 69712
// ComExitVehicle ( IsInUnit ( j ) ) ;
69698: LD_VAR 0 3
69702: PPUSH
69703: CALL_OW 310
69707: PPUSH
69708: CALL_OW 121
// if GetControl ( j ) = control_remote then
69712: LD_VAR 0 3
69716: PPUSH
69717: CALL_OW 263
69721: PUSH
69722: LD_INT 2
69724: EQUAL
69725: IFFALSE 69736
// ComUnlink ( j ) ;
69727: LD_VAR 0 3
69731: PPUSH
69732: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69736: LD_ADDR_VAR 0 10
69740: PUSH
69741: LD_VAR 0 2
69745: PPUSH
69746: LD_INT 3
69748: PPUSH
69749: CALL 79650 0 2
69753: ST_TO_ADDR
// if fac then
69754: LD_VAR 0 10
69758: IFFALSE 69854
// begin for k in fac do
69760: LD_ADDR_VAR 0 4
69764: PUSH
69765: LD_VAR 0 10
69769: PUSH
69770: FOR_IN
69771: IFFALSE 69852
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69773: LD_ADDR_VAR 0 11
69777: PUSH
69778: LD_VAR 0 10
69782: PPUSH
69783: LD_VAR 0 3
69787: PPUSH
69788: CALL_OW 265
69792: PPUSH
69793: LD_VAR 0 3
69797: PPUSH
69798: CALL_OW 262
69802: PPUSH
69803: LD_VAR 0 3
69807: PPUSH
69808: CALL_OW 263
69812: PPUSH
69813: LD_VAR 0 3
69817: PPUSH
69818: CALL_OW 264
69822: PPUSH
69823: CALL 13729 0 5
69827: ST_TO_ADDR
// if components then
69828: LD_VAR 0 11
69832: IFFALSE 69850
// begin MC_InsertProduceList ( i , components ) ;
69834: LD_VAR 0 2
69838: PPUSH
69839: LD_VAR 0 11
69843: PPUSH
69844: CALL 79195 0 2
// break ;
69848: GO 69852
// end ; end ;
69850: GO 69770
69852: POP
69853: POP
// end ; continue ;
69854: GO 69391
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69856: LD_VAR 0 3
69860: PPUSH
69861: LD_INT 1
69863: PPUSH
69864: CALL_OW 289
69868: PUSH
69869: LD_INT 100
69871: LESS
69872: IFFALSE 69886
69874: PUSH
69875: LD_VAR 0 3
69879: PPUSH
69880: CALL_OW 314
69884: NOT
69885: AND
69886: IFFALSE 69915
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69888: LD_VAR 0 3
69892: PPUSH
69893: LD_VAR 0 7
69897: PUSH
69898: LD_INT 2
69900: ARRAY
69901: PPUSH
69902: LD_VAR 0 7
69906: PUSH
69907: LD_INT 3
69909: ARRAY
69910: PPUSH
69911: CALL_OW 117
// break ;
69915: GO 69919
// end ;
69917: GO 69391
69919: POP
69920: POP
// end ; end ;
69921: GO 68093
69923: POP
69924: POP
// end ;
69925: LD_VAR 0 1
69929: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69930: LD_INT 0
69932: PPUSH
69933: PPUSH
69934: PPUSH
69935: PPUSH
// if not mc_bases then
69936: LD_EXP 23
69940: NOT
69941: IFFALSE 69945
// exit ;
69943: GO 70110
// for i = 1 to mc_bases do
69945: LD_ADDR_VAR 0 2
69949: PUSH
69950: DOUBLE
69951: LD_INT 1
69953: DEC
69954: ST_TO_ADDR
69955: LD_EXP 23
69959: PUSH
69960: FOR_TO
69961: IFFALSE 70108
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69963: LD_ADDR_VAR 0 4
69967: PUSH
69968: LD_EXP 42
69972: PUSH
69973: LD_VAR 0 2
69977: ARRAY
69978: PUSH
69979: LD_EXP 45
69983: PUSH
69984: LD_VAR 0 2
69988: ARRAY
69989: UNION
69990: PPUSH
69991: LD_INT 33
69993: PUSH
69994: LD_INT 2
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PPUSH
70001: CALL_OW 72
70005: ST_TO_ADDR
// if tmp then
70006: LD_VAR 0 4
70010: IFFALSE 70106
// for j in tmp do
70012: LD_ADDR_VAR 0 3
70016: PUSH
70017: LD_VAR 0 4
70021: PUSH
70022: FOR_IN
70023: IFFALSE 70104
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70025: LD_VAR 0 3
70029: PPUSH
70030: CALL_OW 312
70034: NOT
70035: IFFALSE 70052
70037: PUSH
70038: LD_VAR 0 3
70042: PPUSH
70043: CALL_OW 256
70047: PUSH
70048: LD_INT 250
70050: GREATEREQUAL
70051: AND
70052: IFFALSE 70065
// Connect ( j ) else
70054: LD_VAR 0 3
70058: PPUSH
70059: CALL 19615 0 1
70063: GO 70102
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70065: LD_VAR 0 3
70069: PPUSH
70070: CALL_OW 256
70074: PUSH
70075: LD_INT 250
70077: LESS
70078: IFFALSE 70091
70080: PUSH
70081: LD_VAR 0 3
70085: PPUSH
70086: CALL_OW 312
70090: AND
70091: IFFALSE 70102
// ComUnlink ( j ) ;
70093: LD_VAR 0 3
70097: PPUSH
70098: CALL_OW 136
70102: GO 70022
70104: POP
70105: POP
// end ;
70106: GO 69960
70108: POP
70109: POP
// end ;
70110: LD_VAR 0 1
70114: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70115: LD_INT 0
70117: PPUSH
70118: PPUSH
70119: PPUSH
70120: PPUSH
70121: PPUSH
// if not mc_bases then
70122: LD_EXP 23
70126: NOT
70127: IFFALSE 70131
// exit ;
70129: GO 70580
// for i = 1 to mc_bases do
70131: LD_ADDR_VAR 0 2
70135: PUSH
70136: DOUBLE
70137: LD_INT 1
70139: DEC
70140: ST_TO_ADDR
70141: LD_EXP 23
70145: PUSH
70146: FOR_TO
70147: IFFALSE 70578
// begin if not mc_produce [ i ] then
70149: LD_EXP 44
70153: PUSH
70154: LD_VAR 0 2
70158: ARRAY
70159: NOT
70160: IFFALSE 70164
// continue ;
70162: GO 70146
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70164: LD_ADDR_VAR 0 5
70168: PUSH
70169: LD_EXP 23
70173: PUSH
70174: LD_VAR 0 2
70178: ARRAY
70179: PPUSH
70180: LD_INT 30
70182: PUSH
70183: LD_INT 3
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: PPUSH
70190: CALL_OW 72
70194: ST_TO_ADDR
// if not fac then
70195: LD_VAR 0 5
70199: NOT
70200: IFFALSE 70204
// continue ;
70202: GO 70146
// for j in fac do
70204: LD_ADDR_VAR 0 3
70208: PUSH
70209: LD_VAR 0 5
70213: PUSH
70214: FOR_IN
70215: IFFALSE 70574
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70217: LD_VAR 0 3
70221: PPUSH
70222: CALL_OW 461
70226: PUSH
70227: LD_INT 2
70229: NONEQUAL
70230: IFTRUE 70250
70232: PUSH
70233: LD_VAR 0 3
70237: PPUSH
70238: LD_INT 15
70240: PPUSH
70241: CALL 19234 0 2
70245: PUSH
70246: LD_INT 4
70248: ARRAY
70249: OR
70250: IFFALSE 70254
// continue ;
70252: GO 70214
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70254: LD_VAR 0 3
70258: PPUSH
70259: LD_EXP 44
70263: PUSH
70264: LD_VAR 0 2
70268: ARRAY
70269: PUSH
70270: LD_INT 1
70272: ARRAY
70273: PUSH
70274: LD_INT 1
70276: ARRAY
70277: PPUSH
70278: LD_EXP 44
70282: PUSH
70283: LD_VAR 0 2
70287: ARRAY
70288: PUSH
70289: LD_INT 1
70291: ARRAY
70292: PUSH
70293: LD_INT 2
70295: ARRAY
70296: PPUSH
70297: LD_EXP 44
70301: PUSH
70302: LD_VAR 0 2
70306: ARRAY
70307: PUSH
70308: LD_INT 1
70310: ARRAY
70311: PUSH
70312: LD_INT 3
70314: ARRAY
70315: PPUSH
70316: LD_EXP 44
70320: PUSH
70321: LD_VAR 0 2
70325: ARRAY
70326: PUSH
70327: LD_INT 1
70329: ARRAY
70330: PUSH
70331: LD_INT 4
70333: ARRAY
70334: PPUSH
70335: CALL_OW 448
70339: IFFALSE 70434
70341: PUSH
70342: LD_VAR 0 3
70346: PPUSH
70347: LD_EXP 44
70351: PUSH
70352: LD_VAR 0 2
70356: ARRAY
70357: PUSH
70358: LD_INT 1
70360: ARRAY
70361: PUSH
70362: LD_INT 1
70364: ARRAY
70365: PUSH
70366: LD_EXP 44
70370: PUSH
70371: LD_VAR 0 2
70375: ARRAY
70376: PUSH
70377: LD_INT 1
70379: ARRAY
70380: PUSH
70381: LD_INT 2
70383: ARRAY
70384: PUSH
70385: LD_EXP 44
70389: PUSH
70390: LD_VAR 0 2
70394: ARRAY
70395: PUSH
70396: LD_INT 1
70398: ARRAY
70399: PUSH
70400: LD_INT 3
70402: ARRAY
70403: PUSH
70404: LD_EXP 44
70408: PUSH
70409: LD_VAR 0 2
70413: ARRAY
70414: PUSH
70415: LD_INT 1
70417: ARRAY
70418: PUSH
70419: LD_INT 4
70421: ARRAY
70422: PUSH
70423: EMPTY
70424: LIST
70425: LIST
70426: LIST
70427: LIST
70428: PPUSH
70429: CALL 23048 0 2
70433: AND
70434: IFFALSE 70572
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70436: LD_VAR 0 3
70440: PPUSH
70441: LD_EXP 44
70445: PUSH
70446: LD_VAR 0 2
70450: ARRAY
70451: PUSH
70452: LD_INT 1
70454: ARRAY
70455: PUSH
70456: LD_INT 1
70458: ARRAY
70459: PPUSH
70460: LD_EXP 44
70464: PUSH
70465: LD_VAR 0 2
70469: ARRAY
70470: PUSH
70471: LD_INT 1
70473: ARRAY
70474: PUSH
70475: LD_INT 2
70477: ARRAY
70478: PPUSH
70479: LD_EXP 44
70483: PUSH
70484: LD_VAR 0 2
70488: ARRAY
70489: PUSH
70490: LD_INT 1
70492: ARRAY
70493: PUSH
70494: LD_INT 3
70496: ARRAY
70497: PPUSH
70498: LD_EXP 44
70502: PUSH
70503: LD_VAR 0 2
70507: ARRAY
70508: PUSH
70509: LD_INT 1
70511: ARRAY
70512: PUSH
70513: LD_INT 4
70515: ARRAY
70516: PPUSH
70517: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70521: LD_ADDR_VAR 0 4
70525: PUSH
70526: LD_EXP 44
70530: PUSH
70531: LD_VAR 0 2
70535: ARRAY
70536: PPUSH
70537: LD_INT 1
70539: PPUSH
70540: CALL_OW 3
70544: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70545: LD_ADDR_EXP 44
70549: PUSH
70550: LD_EXP 44
70554: PPUSH
70555: LD_VAR 0 2
70559: PPUSH
70560: LD_VAR 0 4
70564: PPUSH
70565: CALL_OW 1
70569: ST_TO_ADDR
// break ;
70570: GO 70574
// end ; end ;
70572: GO 70214
70574: POP
70575: POP
// end ;
70576: GO 70146
70578: POP
70579: POP
// end ;
70580: LD_VAR 0 1
70584: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70585: LD_INT 0
70587: PPUSH
70588: PPUSH
70589: PPUSH
// if not mc_bases then
70590: LD_EXP 23
70594: NOT
70595: IFFALSE 70599
// exit ;
70597: GO 70688
// for i = 1 to mc_bases do
70599: LD_ADDR_VAR 0 2
70603: PUSH
70604: DOUBLE
70605: LD_INT 1
70607: DEC
70608: ST_TO_ADDR
70609: LD_EXP 23
70613: PUSH
70614: FOR_TO
70615: IFFALSE 70686
// begin if mc_attack [ i ] then
70617: LD_EXP 43
70621: PUSH
70622: LD_VAR 0 2
70626: ARRAY
70627: IFFALSE 70684
// begin tmp := mc_attack [ i ] [ 1 ] ;
70629: LD_ADDR_VAR 0 3
70633: PUSH
70634: LD_EXP 43
70638: PUSH
70639: LD_VAR 0 2
70643: ARRAY
70644: PUSH
70645: LD_INT 1
70647: ARRAY
70648: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70649: LD_ADDR_EXP 43
70653: PUSH
70654: LD_EXP 43
70658: PPUSH
70659: LD_VAR 0 2
70663: PPUSH
70664: EMPTY
70665: PPUSH
70666: CALL_OW 1
70670: ST_TO_ADDR
// Attack ( tmp ) ;
70671: LD_VAR 0 3
70675: PPUSH
70676: CALL 85719 0 1
// exit ;
70680: POP
70681: POP
70682: GO 70688
// end ; end ;
70684: GO 70614
70686: POP
70687: POP
// end ;
70688: LD_VAR 0 1
70692: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70693: LD_INT 0
70695: PPUSH
70696: PPUSH
70697: PPUSH
70698: PPUSH
70699: PPUSH
70700: PPUSH
70701: PPUSH
// if not mc_bases then
70702: LD_EXP 23
70706: NOT
70707: IFFALSE 70711
// exit ;
70709: GO 71588
// for i = 1 to mc_bases do
70711: LD_ADDR_VAR 0 2
70715: PUSH
70716: DOUBLE
70717: LD_INT 1
70719: DEC
70720: ST_TO_ADDR
70721: LD_EXP 23
70725: PUSH
70726: FOR_TO
70727: IFFALSE 71586
// begin if not mc_bases [ i ] then
70729: LD_EXP 23
70733: PUSH
70734: LD_VAR 0 2
70738: ARRAY
70739: NOT
70740: IFFALSE 70744
// continue ;
70742: GO 70726
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70744: LD_ADDR_VAR 0 7
70748: PUSH
70749: LD_EXP 23
70753: PUSH
70754: LD_VAR 0 2
70758: ARRAY
70759: PUSH
70760: LD_INT 1
70762: ARRAY
70763: PPUSH
70764: CALL 13055 0 1
70768: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70769: LD_ADDR_EXP 46
70773: PUSH
70774: LD_EXP 46
70778: PPUSH
70779: LD_VAR 0 2
70783: PPUSH
70784: LD_EXP 23
70788: PUSH
70789: LD_VAR 0 2
70793: ARRAY
70794: PUSH
70795: LD_INT 1
70797: ARRAY
70798: PPUSH
70799: CALL_OW 255
70803: PPUSH
70804: LD_EXP 48
70808: PUSH
70809: LD_VAR 0 2
70813: ARRAY
70814: PPUSH
70815: CALL 13020 0 2
70819: PPUSH
70820: CALL_OW 1
70824: ST_TO_ADDR
// if not mc_scan [ i ] then
70825: LD_EXP 46
70829: PUSH
70830: LD_VAR 0 2
70834: ARRAY
70835: NOT
70836: IFFALSE 71020
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70838: LD_ADDR_EXP 66
70842: PUSH
70843: LD_EXP 66
70847: PPUSH
70848: LD_VAR 0 2
70852: PPUSH
70853: LD_INT 0
70855: PPUSH
70856: CALL_OW 1
70860: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70861: LD_ADDR_VAR 0 4
70865: PUSH
70866: LD_EXP 23
70870: PUSH
70871: LD_VAR 0 2
70875: ARRAY
70876: PPUSH
70877: LD_INT 2
70879: PUSH
70880: LD_INT 25
70882: PUSH
70883: LD_INT 5
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: LD_INT 25
70892: PUSH
70893: LD_INT 8
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 25
70902: PUSH
70903: LD_INT 9
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: PPUSH
70916: CALL_OW 72
70920: ST_TO_ADDR
// if not tmp then
70921: LD_VAR 0 4
70925: NOT
70926: IFFALSE 70930
// continue ;
70928: GO 70726
// for j in tmp do
70930: LD_ADDR_VAR 0 3
70934: PUSH
70935: LD_VAR 0 4
70939: PUSH
70940: FOR_IN
70941: IFFALSE 71018
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70943: LD_VAR 0 3
70947: PPUSH
70948: CALL_OW 310
70952: PPUSH
70953: CALL_OW 266
70957: PUSH
70958: LD_INT 5
70960: EQUAL
70961: IFFALSE 70978
70963: PUSH
70964: LD_VAR 0 3
70968: PPUSH
70969: CALL_OW 257
70973: PUSH
70974: LD_INT 1
70976: EQUAL
70977: AND
70978: IFFALSE 70992
70980: PUSH
70981: LD_VAR 0 3
70985: PPUSH
70986: CALL_OW 459
70990: NOT
70991: AND
70992: IFFALSE 71000
70994: PUSH
70995: LD_VAR 0 7
70999: AND
71000: IFFALSE 71016
// ComChangeProfession ( j , class ) ;
71002: LD_VAR 0 3
71006: PPUSH
71007: LD_VAR 0 7
71011: PPUSH
71012: CALL_OW 123
71016: GO 70940
71018: POP
71019: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71020: LD_EXP 46
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: IFFALSE 71045
71032: PUSH
71033: LD_EXP 66
71037: PUSH
71038: LD_VAR 0 2
71042: ARRAY
71043: NOT
71044: AND
71045: IFFALSE 71060
71047: PUSH
71048: LD_EXP 45
71052: PUSH
71053: LD_VAR 0 2
71057: ARRAY
71058: NOT
71059: AND
71060: IFFALSE 71211
71062: PUSH
71063: LD_EXP 23
71067: PUSH
71068: LD_VAR 0 2
71072: ARRAY
71073: PPUSH
71074: LD_INT 50
71076: PUSH
71077: EMPTY
71078: LIST
71079: PUSH
71080: LD_INT 2
71082: PUSH
71083: LD_INT 30
71085: PUSH
71086: LD_INT 32
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 30
71095: PUSH
71096: LD_INT 33
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 30
71105: PUSH
71106: LD_INT 4
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: LD_INT 30
71115: PUSH
71116: LD_INT 5
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: LIST
71127: LIST
71128: LIST
71129: PUSH
71130: EMPTY
71131: LIST
71132: LIST
71133: PPUSH
71134: CALL_OW 72
71138: PUSH
71139: LD_INT 4
71141: LESS
71142: IFTRUE 71210
71144: PUSH
71145: LD_EXP 23
71149: PUSH
71150: LD_VAR 0 2
71154: ARRAY
71155: PPUSH
71156: LD_INT 3
71158: PUSH
71159: LD_INT 24
71161: PUSH
71162: LD_INT 1000
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: EMPTY
71170: LIST
71171: LIST
71172: PUSH
71173: LD_INT 2
71175: PUSH
71176: LD_INT 30
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 30
71188: PUSH
71189: LD_INT 1
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: LIST
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PPUSH
71205: CALL_OW 72
71209: OR
71210: AND
71211: IFFALSE 71464
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71213: LD_ADDR_EXP 66
71217: PUSH
71218: LD_EXP 66
71222: PPUSH
71223: LD_VAR 0 2
71227: PPUSH
71228: LD_INT 1
71230: PPUSH
71231: CALL_OW 1
71235: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71236: LD_ADDR_VAR 0 4
71240: PUSH
71241: LD_EXP 23
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: PPUSH
71252: LD_INT 2
71254: PUSH
71255: LD_INT 25
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 25
71267: PUSH
71268: LD_INT 5
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PUSH
71275: LD_INT 25
71277: PUSH
71278: LD_INT 8
71280: PUSH
71281: EMPTY
71282: LIST
71283: LIST
71284: PUSH
71285: LD_INT 25
71287: PUSH
71288: LD_INT 9
71290: PUSH
71291: EMPTY
71292: LIST
71293: LIST
71294: PUSH
71295: EMPTY
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: PPUSH
71302: CALL_OW 72
71306: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71307: LD_ADDR_VAR 0 4
71311: PUSH
71312: LD_VAR 0 4
71316: PUSH
71317: LD_VAR 0 4
71321: PPUSH
71322: LD_INT 18
71324: PPUSH
71325: CALL 46848 0 2
71329: DIFF
71330: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71331: LD_VAR 0 4
71335: NOT
71336: IFFALSE 71384
71338: PUSH
71339: LD_EXP 23
71343: PUSH
71344: LD_VAR 0 2
71348: ARRAY
71349: PPUSH
71350: LD_INT 2
71352: PUSH
71353: LD_INT 30
71355: PUSH
71356: LD_INT 4
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: LD_INT 30
71365: PUSH
71366: LD_INT 5
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: LIST
71377: PPUSH
71378: CALL_OW 72
71382: NOT
71383: AND
71384: IFFALSE 71446
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71386: LD_ADDR_VAR 0 4
71390: PUSH
71391: LD_EXP 23
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: PPUSH
71402: LD_INT 2
71404: PUSH
71405: LD_INT 25
71407: PUSH
71408: LD_INT 2
71410: PUSH
71411: EMPTY
71412: LIST
71413: LIST
71414: PUSH
71415: LD_INT 25
71417: PUSH
71418: LD_INT 3
71420: PUSH
71421: EMPTY
71422: LIST
71423: LIST
71424: PUSH
71425: LD_INT 25
71427: PUSH
71428: LD_INT 4
71430: PUSH
71431: EMPTY
71432: LIST
71433: LIST
71434: PUSH
71435: EMPTY
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: PPUSH
71441: CALL_OW 72
71445: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71446: LD_VAR 0 2
71450: PPUSH
71451: LD_VAR 0 4
71455: PPUSH
71456: CALL 90488 0 2
// exit ;
71460: POP
71461: POP
71462: GO 71588
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71464: LD_EXP 46
71468: PUSH
71469: LD_VAR 0 2
71473: ARRAY
71474: IFFALSE 71489
71476: PUSH
71477: LD_EXP 66
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: NOT
71488: AND
71489: IFFALSE 71503
71491: PUSH
71492: LD_EXP 45
71496: PUSH
71497: LD_VAR 0 2
71501: ARRAY
71502: AND
71503: IFFALSE 71584
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71505: LD_ADDR_EXP 66
71509: PUSH
71510: LD_EXP 66
71514: PPUSH
71515: LD_VAR 0 2
71519: PPUSH
71520: LD_INT 1
71522: PPUSH
71523: CALL_OW 1
71527: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71528: LD_ADDR_VAR 0 4
71532: PUSH
71533: LD_EXP 45
71537: PUSH
71538: LD_VAR 0 2
71542: ARRAY
71543: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71544: LD_ADDR_EXP 45
71548: PUSH
71549: LD_EXP 45
71553: PPUSH
71554: LD_VAR 0 2
71558: PPUSH
71559: EMPTY
71560: PPUSH
71561: CALL_OW 1
71565: ST_TO_ADDR
// Defend ( i , tmp ) ;
71566: LD_VAR 0 2
71570: PPUSH
71571: LD_VAR 0 4
71575: PPUSH
71576: CALL 91092 0 2
// exit ;
71580: POP
71581: POP
71582: GO 71588
// end ; end ;
71584: GO 70726
71586: POP
71587: POP
// end ;
71588: LD_VAR 0 1
71592: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71593: LD_INT 0
71595: PPUSH
71596: PPUSH
71597: PPUSH
71598: PPUSH
71599: PPUSH
71600: PPUSH
71601: PPUSH
71602: PPUSH
71603: PPUSH
71604: PPUSH
71605: PPUSH
// if not mc_bases then
71606: LD_EXP 23
71610: NOT
71611: IFFALSE 71615
// exit ;
71613: GO 72728
// for i = 1 to mc_bases do
71615: LD_ADDR_VAR 0 2
71619: PUSH
71620: DOUBLE
71621: LD_INT 1
71623: DEC
71624: ST_TO_ADDR
71625: LD_EXP 23
71629: PUSH
71630: FOR_TO
71631: IFFALSE 72726
// begin tmp := mc_lab [ i ] ;
71633: LD_ADDR_VAR 0 6
71637: PUSH
71638: LD_EXP 56
71642: PUSH
71643: LD_VAR 0 2
71647: ARRAY
71648: ST_TO_ADDR
// if not tmp then
71649: LD_VAR 0 6
71653: NOT
71654: IFFALSE 71658
// continue ;
71656: GO 71630
// idle_lab := 0 ;
71658: LD_ADDR_VAR 0 11
71662: PUSH
71663: LD_INT 0
71665: ST_TO_ADDR
// for j in tmp do
71666: LD_ADDR_VAR 0 3
71670: PUSH
71671: LD_VAR 0 6
71675: PUSH
71676: FOR_IN
71677: IFFALSE 72722
// begin researching := false ;
71679: LD_ADDR_VAR 0 10
71683: PUSH
71684: LD_INT 0
71686: ST_TO_ADDR
// side := GetSide ( j ) ;
71687: LD_ADDR_VAR 0 4
71691: PUSH
71692: LD_VAR 0 3
71696: PPUSH
71697: CALL_OW 255
71701: ST_TO_ADDR
// if not mc_tech [ side ] then
71702: LD_EXP 50
71706: PUSH
71707: LD_VAR 0 4
71711: ARRAY
71712: NOT
71713: IFFALSE 71717
// continue ;
71715: GO 71676
// if BuildingStatus ( j ) = bs_idle then
71717: LD_VAR 0 3
71721: PPUSH
71722: CALL_OW 461
71726: PUSH
71727: LD_INT 2
71729: EQUAL
71730: IFFALSE 71922
// begin if idle_lab and UnitsInside ( j ) < 6 then
71732: LD_VAR 0 11
71736: IFFALSE 71753
71738: PUSH
71739: LD_VAR 0 3
71743: PPUSH
71744: CALL_OW 313
71748: PUSH
71749: LD_INT 6
71751: LESS
71752: AND
71753: IFFALSE 71824
// begin tmp2 := UnitsInside ( idle_lab ) ;
71755: LD_ADDR_VAR 0 9
71759: PUSH
71760: LD_VAR 0 11
71764: PPUSH
71765: CALL_OW 313
71769: ST_TO_ADDR
// if tmp2 then
71770: LD_VAR 0 9
71774: IFFALSE 71816
// for x in tmp2 do
71776: LD_ADDR_VAR 0 7
71780: PUSH
71781: LD_VAR 0 9
71785: PUSH
71786: FOR_IN
71787: IFFALSE 71814
// begin ComExitBuilding ( x ) ;
71789: LD_VAR 0 7
71793: PPUSH
71794: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71798: LD_VAR 0 7
71802: PPUSH
71803: LD_VAR 0 3
71807: PPUSH
71808: CALL_OW 180
// end ;
71812: GO 71786
71814: POP
71815: POP
// idle_lab := 0 ;
71816: LD_ADDR_VAR 0 11
71820: PUSH
71821: LD_INT 0
71823: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71824: LD_ADDR_VAR 0 5
71828: PUSH
71829: LD_EXP 50
71833: PUSH
71834: LD_VAR 0 4
71838: ARRAY
71839: PUSH
71840: FOR_IN
71841: IFFALSE 71903
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71843: LD_VAR 0 3
71847: PPUSH
71848: LD_VAR 0 5
71852: PPUSH
71853: CALL_OW 430
71857: IFFALSE 71875
71859: PUSH
71860: LD_VAR 0 4
71864: PPUSH
71865: LD_VAR 0 5
71869: PPUSH
71870: CALL 12115 0 2
71874: AND
71875: IFFALSE 71901
// begin researching := true ;
71877: LD_ADDR_VAR 0 10
71881: PUSH
71882: LD_INT 1
71884: ST_TO_ADDR
// ComResearch ( j , t ) ;
71885: LD_VAR 0 3
71889: PPUSH
71890: LD_VAR 0 5
71894: PPUSH
71895: CALL_OW 124
// break ;
71899: GO 71903
// end ;
71901: GO 71840
71903: POP
71904: POP
// if not researching then
71905: LD_VAR 0 10
71909: NOT
71910: IFFALSE 71922
// idle_lab := j ;
71912: LD_ADDR_VAR 0 11
71916: PUSH
71917: LD_VAR 0 3
71921: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71922: LD_VAR 0 3
71926: PPUSH
71927: CALL_OW 461
71931: PUSH
71932: LD_INT 10
71934: EQUAL
71935: IFFALSE 72541
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71937: LD_EXP 52
71941: PUSH
71942: LD_VAR 0 2
71946: ARRAY
71947: NOT
71948: IFFALSE 71963
71950: PUSH
71951: LD_EXP 53
71955: PUSH
71956: LD_VAR 0 2
71960: ARRAY
71961: NOT
71962: AND
71963: IFFALSE 71981
71965: PUSH
71966: LD_EXP 50
71970: PUSH
71971: LD_VAR 0 4
71975: ARRAY
71976: PUSH
71977: LD_INT 1
71979: GREATER
71980: AND
71981: IFFALSE 72112
// begin ComCancel ( j ) ;
71983: LD_VAR 0 3
71987: PPUSH
71988: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71992: LD_ADDR_EXP 50
71996: PUSH
71997: LD_EXP 50
72001: PPUSH
72002: LD_VAR 0 4
72006: PPUSH
72007: LD_EXP 50
72011: PUSH
72012: LD_VAR 0 4
72016: ARRAY
72017: PPUSH
72018: LD_EXP 50
72022: PUSH
72023: LD_VAR 0 4
72027: ARRAY
72028: PUSH
72029: LD_INT 1
72031: MINUS
72032: PPUSH
72033: LD_EXP 50
72037: PUSH
72038: LD_VAR 0 4
72042: ARRAY
72043: PPUSH
72044: LD_INT 0
72046: PPUSH
72047: CALL 15663 0 4
72051: PPUSH
72052: CALL_OW 1
72056: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72057: LD_ADDR_EXP 50
72061: PUSH
72062: LD_EXP 50
72066: PPUSH
72067: LD_VAR 0 4
72071: PPUSH
72072: LD_EXP 50
72076: PUSH
72077: LD_VAR 0 4
72081: ARRAY
72082: PPUSH
72083: LD_EXP 50
72087: PUSH
72088: LD_VAR 0 4
72092: ARRAY
72093: PPUSH
72094: LD_INT 1
72096: PPUSH
72097: LD_INT 0
72099: PPUSH
72100: CALL 15663 0 4
72104: PPUSH
72105: CALL_OW 1
72109: ST_TO_ADDR
// continue ;
72110: GO 71676
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72112: LD_EXP 52
72116: PUSH
72117: LD_VAR 0 2
72121: ARRAY
72122: IFFALSE 72137
72124: PUSH
72125: LD_EXP 53
72129: PUSH
72130: LD_VAR 0 2
72134: ARRAY
72135: NOT
72136: AND
72137: IFFALSE 72264
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72139: LD_ADDR_EXP 53
72143: PUSH
72144: LD_EXP 53
72148: PPUSH
72149: LD_VAR 0 2
72153: PUSH
72154: LD_EXP 53
72158: PUSH
72159: LD_VAR 0 2
72163: ARRAY
72164: PUSH
72165: LD_INT 1
72167: PLUS
72168: PUSH
72169: EMPTY
72170: LIST
72171: LIST
72172: PPUSH
72173: LD_EXP 52
72177: PUSH
72178: LD_VAR 0 2
72182: ARRAY
72183: PUSH
72184: LD_INT 1
72186: ARRAY
72187: PPUSH
72188: CALL 16255 0 3
72192: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72193: LD_EXP 52
72197: PUSH
72198: LD_VAR 0 2
72202: ARRAY
72203: PUSH
72204: LD_INT 1
72206: ARRAY
72207: PPUSH
72208: LD_INT 112
72210: PPUSH
72211: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72215: LD_ADDR_VAR 0 9
72219: PUSH
72220: LD_EXP 52
72224: PUSH
72225: LD_VAR 0 2
72229: ARRAY
72230: PPUSH
72231: LD_INT 1
72233: PPUSH
72234: CALL_OW 3
72238: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72239: LD_ADDR_EXP 52
72243: PUSH
72244: LD_EXP 52
72248: PPUSH
72249: LD_VAR 0 2
72253: PPUSH
72254: LD_VAR 0 9
72258: PPUSH
72259: CALL_OW 1
72263: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72264: LD_EXP 52
72268: PUSH
72269: LD_VAR 0 2
72273: ARRAY
72274: IFFALSE 72288
72276: PUSH
72277: LD_EXP 53
72281: PUSH
72282: LD_VAR 0 2
72286: ARRAY
72287: AND
72288: IFFALSE 72312
72290: PUSH
72291: LD_EXP 53
72295: PUSH
72296: LD_VAR 0 2
72300: ARRAY
72301: PUSH
72302: LD_INT 1
72304: ARRAY
72305: PPUSH
72306: CALL_OW 310
72310: NOT
72311: AND
72312: IFFALSE 72329
72314: PUSH
72315: LD_VAR 0 3
72319: PPUSH
72320: CALL_OW 313
72324: PUSH
72325: LD_INT 6
72327: EQUAL
72328: AND
72329: IFFALSE 72385
// begin tmp2 := UnitsInside ( j ) ;
72331: LD_ADDR_VAR 0 9
72335: PUSH
72336: LD_VAR 0 3
72340: PPUSH
72341: CALL_OW 313
72345: ST_TO_ADDR
// if tmp2 = 6 then
72346: LD_VAR 0 9
72350: PUSH
72351: LD_INT 6
72353: EQUAL
72354: IFFALSE 72385
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72356: LD_VAR 0 9
72360: PUSH
72361: LD_INT 1
72363: ARRAY
72364: PPUSH
72365: LD_INT 112
72367: PPUSH
72368: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72372: LD_VAR 0 9
72376: PUSH
72377: LD_INT 1
72379: ARRAY
72380: PPUSH
72381: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72385: LD_EXP 53
72389: PUSH
72390: LD_VAR 0 2
72394: ARRAY
72395: IFFALSE 72419
72397: PUSH
72398: LD_EXP 53
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: PUSH
72409: LD_INT 1
72411: ARRAY
72412: PPUSH
72413: CALL_OW 314
72417: NOT
72418: AND
72419: IFFALSE 72443
72421: PUSH
72422: LD_EXP 53
72426: PUSH
72427: LD_VAR 0 2
72431: ARRAY
72432: PUSH
72433: LD_INT 1
72435: ARRAY
72436: PPUSH
72437: CALL_OW 310
72441: NOT
72442: AND
72443: IFFALSE 72469
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72445: LD_EXP 53
72449: PUSH
72450: LD_VAR 0 2
72454: ARRAY
72455: PUSH
72456: LD_INT 1
72458: ARRAY
72459: PPUSH
72460: LD_VAR 0 3
72464: PPUSH
72465: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72469: LD_EXP 53
72473: PUSH
72474: LD_VAR 0 2
72478: ARRAY
72479: PUSH
72480: LD_INT 1
72482: ARRAY
72483: PPUSH
72484: CALL_OW 310
72488: IFFALSE 72520
72490: PUSH
72491: LD_EXP 53
72495: PUSH
72496: LD_VAR 0 2
72500: ARRAY
72501: PUSH
72502: LD_INT 1
72504: ARRAY
72505: PPUSH
72506: CALL_OW 310
72510: PPUSH
72511: CALL_OW 461
72515: PUSH
72516: LD_INT 3
72518: NONEQUAL
72519: AND
72520: IFFALSE 72541
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72522: LD_EXP 53
72526: PUSH
72527: LD_VAR 0 2
72531: ARRAY
72532: PUSH
72533: LD_INT 1
72535: ARRAY
72536: PPUSH
72537: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72541: LD_VAR 0 3
72545: PPUSH
72546: CALL_OW 461
72550: PUSH
72551: LD_INT 6
72553: EQUAL
72554: IFFALSE 72566
72556: PUSH
72557: LD_VAR 0 6
72561: PUSH
72562: LD_INT 1
72564: GREATER
72565: AND
72566: IFFALSE 72720
// begin sci := [ ] ;
72568: LD_ADDR_VAR 0 8
72572: PUSH
72573: EMPTY
72574: ST_TO_ADDR
// for x in ( tmp diff j ) do
72575: LD_ADDR_VAR 0 7
72579: PUSH
72580: LD_VAR 0 6
72584: PUSH
72585: LD_VAR 0 3
72589: DIFF
72590: PUSH
72591: FOR_IN
72592: IFFALSE 72644
// begin if sci = 6 then
72594: LD_VAR 0 8
72598: PUSH
72599: LD_INT 6
72601: EQUAL
72602: IFFALSE 72606
// break ;
72604: GO 72644
// if BuildingStatus ( x ) = bs_idle then
72606: LD_VAR 0 7
72610: PPUSH
72611: CALL_OW 461
72615: PUSH
72616: LD_INT 2
72618: EQUAL
72619: IFFALSE 72642
// sci := sci ^ UnitsInside ( x ) ;
72621: LD_ADDR_VAR 0 8
72625: PUSH
72626: LD_VAR 0 8
72630: PUSH
72631: LD_VAR 0 7
72635: PPUSH
72636: CALL_OW 313
72640: ADD
72641: ST_TO_ADDR
// end ;
72642: GO 72591
72644: POP
72645: POP
// if not sci then
72646: LD_VAR 0 8
72650: NOT
72651: IFFALSE 72655
// continue ;
72653: GO 71676
// for x in sci do
72655: LD_ADDR_VAR 0 7
72659: PUSH
72660: LD_VAR 0 8
72664: PUSH
72665: FOR_IN
72666: IFFALSE 72718
// if IsInUnit ( x ) and not HasTask ( x ) then
72668: LD_VAR 0 7
72672: PPUSH
72673: CALL_OW 310
72677: IFFALSE 72691
72679: PUSH
72680: LD_VAR 0 7
72684: PPUSH
72685: CALL_OW 314
72689: NOT
72690: AND
72691: IFFALSE 72716
// begin ComExitBuilding ( x ) ;
72693: LD_VAR 0 7
72697: PPUSH
72698: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72702: LD_VAR 0 7
72706: PPUSH
72707: LD_VAR 0 3
72711: PPUSH
72712: CALL_OW 180
// end ;
72716: GO 72665
72718: POP
72719: POP
// end ; end ;
72720: GO 71676
72722: POP
72723: POP
// end ;
72724: GO 71630
72726: POP
72727: POP
// end ;
72728: LD_VAR 0 1
72732: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72733: LD_INT 0
72735: PPUSH
72736: PPUSH
// if not mc_bases then
72737: LD_EXP 23
72741: NOT
72742: IFFALSE 72746
// exit ;
72744: GO 72829
// for i = 1 to mc_bases do
72746: LD_ADDR_VAR 0 2
72750: PUSH
72751: DOUBLE
72752: LD_INT 1
72754: DEC
72755: ST_TO_ADDR
72756: LD_EXP 23
72760: PUSH
72761: FOR_TO
72762: IFFALSE 72827
// if mc_mines [ i ] and mc_miners [ i ] then
72764: LD_EXP 36
72768: PUSH
72769: LD_VAR 0 2
72773: ARRAY
72774: IFFALSE 72788
72776: PUSH
72777: LD_EXP 37
72781: PUSH
72782: LD_VAR 0 2
72786: ARRAY
72787: AND
72788: IFFALSE 72825
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72790: LD_EXP 37
72794: PUSH
72795: LD_VAR 0 2
72799: ARRAY
72800: PUSH
72801: LD_INT 1
72803: ARRAY
72804: PPUSH
72805: CALL_OW 255
72809: PPUSH
72810: LD_EXP 36
72814: PUSH
72815: LD_VAR 0 2
72819: ARRAY
72820: PPUSH
72821: CALL 13208 0 2
72825: GO 72761
72827: POP
72828: POP
// end ;
72829: LD_VAR 0 1
72833: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72834: LD_INT 0
72836: PPUSH
72837: PPUSH
72838: PPUSH
72839: PPUSH
72840: PPUSH
72841: PPUSH
72842: PPUSH
72843: PPUSH
// if not mc_bases or not mc_parking then
72844: LD_EXP 23
72848: NOT
72849: IFTRUE 72858
72851: PUSH
72852: LD_EXP 47
72856: NOT
72857: OR
72858: IFFALSE 72862
// exit ;
72860: GO 73606
// for i = 1 to mc_bases do
72862: LD_ADDR_VAR 0 2
72866: PUSH
72867: DOUBLE
72868: LD_INT 1
72870: DEC
72871: ST_TO_ADDR
72872: LD_EXP 23
72876: PUSH
72877: FOR_TO
72878: IFFALSE 73604
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72880: LD_EXP 23
72884: PUSH
72885: LD_VAR 0 2
72889: ARRAY
72890: NOT
72891: IFTRUE 72906
72893: PUSH
72894: LD_EXP 47
72898: PUSH
72899: LD_VAR 0 2
72903: ARRAY
72904: NOT
72905: OR
72906: IFFALSE 72910
// continue ;
72908: GO 72877
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72910: LD_ADDR_VAR 0 5
72914: PUSH
72915: LD_EXP 23
72919: PUSH
72920: LD_VAR 0 2
72924: ARRAY
72925: PUSH
72926: LD_INT 1
72928: ARRAY
72929: PPUSH
72930: CALL_OW 255
72934: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72935: LD_ADDR_VAR 0 6
72939: PUSH
72940: LD_EXP 23
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: PPUSH
72951: LD_INT 30
72953: PUSH
72954: LD_INT 3
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PPUSH
72961: CALL_OW 72
72965: ST_TO_ADDR
// if not fac then
72966: LD_VAR 0 6
72970: NOT
72971: IFFALSE 73022
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72973: LD_ADDR_VAR 0 6
72977: PUSH
72978: LD_EXP 23
72982: PUSH
72983: LD_VAR 0 2
72987: ARRAY
72988: PPUSH
72989: LD_INT 2
72991: PUSH
72992: LD_INT 30
72994: PUSH
72995: LD_INT 0
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 30
73004: PUSH
73005: LD_INT 1
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: LIST
73016: PPUSH
73017: CALL_OW 72
73021: ST_TO_ADDR
// if not fac then
73022: LD_VAR 0 6
73026: NOT
73027: IFFALSE 73031
// continue ;
73029: GO 72877
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73031: LD_ADDR_VAR 0 7
73035: PUSH
73036: LD_EXP 47
73040: PUSH
73041: LD_VAR 0 2
73045: ARRAY
73046: PPUSH
73047: LD_INT 22
73049: PUSH
73050: LD_VAR 0 5
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: LD_INT 21
73061: PUSH
73062: LD_INT 2
73064: PUSH
73065: EMPTY
73066: LIST
73067: LIST
73068: PUSH
73069: LD_INT 3
73071: PUSH
73072: LD_INT 60
73074: PUSH
73075: EMPTY
73076: LIST
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 3
73084: PUSH
73085: LD_INT 24
73087: PUSH
73088: LD_INT 1000
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: EMPTY
73100: LIST
73101: LIST
73102: LIST
73103: LIST
73104: PPUSH
73105: CALL_OW 70
73109: ST_TO_ADDR
// for j in fac do
73110: LD_ADDR_VAR 0 3
73114: PUSH
73115: LD_VAR 0 6
73119: PUSH
73120: FOR_IN
73121: IFFALSE 73216
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73123: LD_ADDR_VAR 0 7
73127: PUSH
73128: LD_VAR 0 7
73132: PUSH
73133: LD_INT 22
73135: PUSH
73136: LD_VAR 0 5
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 91
73147: PUSH
73148: LD_VAR 0 3
73152: PUSH
73153: LD_INT 15
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 21
73163: PUSH
73164: LD_INT 2
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 3
73173: PUSH
73174: LD_INT 60
73176: PUSH
73177: EMPTY
73178: LIST
73179: PUSH
73180: EMPTY
73181: LIST
73182: LIST
73183: PUSH
73184: LD_INT 3
73186: PUSH
73187: LD_INT 24
73189: PUSH
73190: LD_INT 1000
73192: PUSH
73193: EMPTY
73194: LIST
73195: LIST
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: LIST
73205: LIST
73206: LIST
73207: PPUSH
73208: CALL_OW 69
73212: UNION
73213: ST_TO_ADDR
73214: GO 73120
73216: POP
73217: POP
// if not vehs then
73218: LD_VAR 0 7
73222: NOT
73223: IFFALSE 73249
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73225: LD_ADDR_EXP 35
73229: PUSH
73230: LD_EXP 35
73234: PPUSH
73235: LD_VAR 0 2
73239: PPUSH
73240: EMPTY
73241: PPUSH
73242: CALL_OW 1
73246: ST_TO_ADDR
// continue ;
73247: GO 72877
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73249: LD_ADDR_VAR 0 8
73253: PUSH
73254: LD_EXP 23
73258: PUSH
73259: LD_VAR 0 2
73263: ARRAY
73264: PPUSH
73265: LD_INT 30
73267: PUSH
73268: LD_INT 3
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PPUSH
73275: CALL_OW 72
73279: ST_TO_ADDR
// if tmp then
73280: LD_VAR 0 8
73284: IFFALSE 73387
// begin for j in tmp do
73286: LD_ADDR_VAR 0 3
73290: PUSH
73291: LD_VAR 0 8
73295: PUSH
73296: FOR_IN
73297: IFFALSE 73385
// for k in UnitsInside ( j ) do
73299: LD_ADDR_VAR 0 4
73303: PUSH
73304: LD_VAR 0 3
73308: PPUSH
73309: CALL_OW 313
73313: PUSH
73314: FOR_IN
73315: IFFALSE 73381
// if k then
73317: LD_VAR 0 4
73321: IFFALSE 73379
// if not k in mc_repair_vehicle [ i ] then
73323: LD_VAR 0 4
73327: PUSH
73328: LD_EXP 35
73332: PUSH
73333: LD_VAR 0 2
73337: ARRAY
73338: IN
73339: NOT
73340: IFFALSE 73379
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73342: LD_ADDR_EXP 35
73346: PUSH
73347: LD_EXP 35
73351: PPUSH
73352: LD_VAR 0 2
73356: PPUSH
73357: LD_EXP 35
73361: PUSH
73362: LD_VAR 0 2
73366: ARRAY
73367: PUSH
73368: LD_VAR 0 4
73372: UNION
73373: PPUSH
73374: CALL_OW 1
73378: ST_TO_ADDR
73379: GO 73314
73381: POP
73382: POP
73383: GO 73296
73385: POP
73386: POP
// end ; if not mc_repair_vehicle [ i ] then
73387: LD_EXP 35
73391: PUSH
73392: LD_VAR 0 2
73396: ARRAY
73397: NOT
73398: IFFALSE 73402
// continue ;
73400: GO 72877
// for j in mc_repair_vehicle [ i ] do
73402: LD_ADDR_VAR 0 3
73406: PUSH
73407: LD_EXP 35
73411: PUSH
73412: LD_VAR 0 2
73416: ARRAY
73417: PUSH
73418: FOR_IN
73419: IFFALSE 73600
// begin if GetClass ( j ) <> 3 then
73421: LD_VAR 0 3
73425: PPUSH
73426: CALL_OW 257
73430: PUSH
73431: LD_INT 3
73433: NONEQUAL
73434: IFFALSE 73475
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73436: LD_ADDR_EXP 35
73440: PUSH
73441: LD_EXP 35
73445: PPUSH
73446: LD_VAR 0 2
73450: PPUSH
73451: LD_EXP 35
73455: PUSH
73456: LD_VAR 0 2
73460: ARRAY
73461: PUSH
73462: LD_VAR 0 3
73466: DIFF
73467: PPUSH
73468: CALL_OW 1
73472: ST_TO_ADDR
// continue ;
73473: GO 73418
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73475: LD_VAR 0 3
73479: PPUSH
73480: CALL_OW 311
73484: NOT
73485: IFFALSE 73510
73487: PUSH
73488: LD_VAR 0 3
73492: PUSH
73493: LD_EXP 26
73497: PUSH
73498: LD_VAR 0 2
73502: ARRAY
73503: PUSH
73504: LD_INT 1
73506: ARRAY
73507: IN
73508: NOT
73509: AND
73510: IFFALSE 73535
73512: PUSH
73513: LD_VAR 0 3
73517: PUSH
73518: LD_EXP 26
73522: PUSH
73523: LD_VAR 0 2
73527: ARRAY
73528: PUSH
73529: LD_INT 2
73531: ARRAY
73532: IN
73533: NOT
73534: AND
73535: IFFALSE 73598
// begin if IsInUnit ( j ) then
73537: LD_VAR 0 3
73541: PPUSH
73542: CALL_OW 310
73546: IFFALSE 73559
// ComExitBuilding ( j ) else
73548: LD_VAR 0 3
73552: PPUSH
73553: CALL_OW 122
73557: GO 73598
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73559: LD_VAR 0 3
73563: PPUSH
73564: LD_VAR 0 7
73568: PUSH
73569: LD_INT 1
73571: ARRAY
73572: PPUSH
73573: CALL 51386 0 2
73577: NOT
73578: IFFALSE 73598
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73580: LD_VAR 0 3
73584: PPUSH
73585: LD_VAR 0 7
73589: PUSH
73590: LD_INT 1
73592: ARRAY
73593: PPUSH
73594: CALL_OW 129
// end ; end ;
73598: GO 73418
73600: POP
73601: POP
// end ;
73602: GO 72877
73604: POP
73605: POP
// end ;
73606: LD_VAR 0 1
73610: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73611: LD_INT 0
73613: PPUSH
73614: PPUSH
73615: PPUSH
73616: PPUSH
73617: PPUSH
73618: PPUSH
73619: PPUSH
73620: PPUSH
73621: PPUSH
73622: PPUSH
73623: PPUSH
// if not mc_bases then
73624: LD_EXP 23
73628: NOT
73629: IFFALSE 73633
// exit ;
73631: GO 74451
// for i = 1 to mc_bases do
73633: LD_ADDR_VAR 0 2
73637: PUSH
73638: DOUBLE
73639: LD_INT 1
73641: DEC
73642: ST_TO_ADDR
73643: LD_EXP 23
73647: PUSH
73648: FOR_TO
73649: IFFALSE 74449
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73651: LD_EXP 51
73655: PUSH
73656: LD_VAR 0 2
73660: ARRAY
73661: NOT
73662: IFTRUE 73680
73664: PUSH
73665: LD_EXP 26
73669: PUSH
73670: LD_VAR 0 2
73674: ARRAY
73675: PUSH
73676: LD_INT 1
73678: ARRAY
73679: OR
73680: IFTRUE 73698
73682: PUSH
73683: LD_EXP 26
73687: PUSH
73688: LD_VAR 0 2
73692: ARRAY
73693: PUSH
73694: LD_INT 2
73696: ARRAY
73697: OR
73698: IFTRUE 73721
73700: PUSH
73701: LD_EXP 49
73705: PUSH
73706: LD_VAR 0 2
73710: ARRAY
73711: PPUSH
73712: LD_INT 1
73714: PPUSH
73715: CALL_OW 325
73719: NOT
73720: OR
73721: IFTRUE 73735
73723: PUSH
73724: LD_EXP 46
73728: PUSH
73729: LD_VAR 0 2
73733: ARRAY
73734: OR
73735: IFFALSE 73739
// continue ;
73737: GO 73648
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73739: LD_ADDR_VAR 0 8
73743: PUSH
73744: LD_EXP 23
73748: PUSH
73749: LD_VAR 0 2
73753: ARRAY
73754: PPUSH
73755: LD_INT 25
73757: PUSH
73758: LD_INT 4
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 50
73767: PUSH
73768: EMPTY
73769: LIST
73770: PUSH
73771: LD_INT 3
73773: PUSH
73774: LD_INT 60
73776: PUSH
73777: EMPTY
73778: LIST
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: LIST
73788: PPUSH
73789: CALL_OW 72
73793: PUSH
73794: LD_EXP 27
73798: PUSH
73799: LD_VAR 0 2
73803: ARRAY
73804: DIFF
73805: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73806: LD_ADDR_VAR 0 9
73810: PUSH
73811: LD_EXP 23
73815: PUSH
73816: LD_VAR 0 2
73820: ARRAY
73821: PPUSH
73822: LD_INT 2
73824: PUSH
73825: LD_INT 30
73827: PUSH
73828: LD_INT 0
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 30
73837: PUSH
73838: LD_INT 1
73840: PUSH
73841: EMPTY
73842: LIST
73843: LIST
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: LIST
73849: PPUSH
73850: CALL_OW 72
73854: ST_TO_ADDR
// if not tmp or not dep then
73855: LD_VAR 0 8
73859: NOT
73860: IFTRUE 73869
73862: PUSH
73863: LD_VAR 0 9
73867: NOT
73868: OR
73869: IFFALSE 73873
// continue ;
73871: GO 73648
// side := GetSide ( tmp [ 1 ] ) ;
73873: LD_ADDR_VAR 0 11
73877: PUSH
73878: LD_VAR 0 8
73882: PUSH
73883: LD_INT 1
73885: ARRAY
73886: PPUSH
73887: CALL_OW 255
73891: ST_TO_ADDR
// dep := dep [ 1 ] ;
73892: LD_ADDR_VAR 0 9
73896: PUSH
73897: LD_VAR 0 9
73901: PUSH
73902: LD_INT 1
73904: ARRAY
73905: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73906: LD_ADDR_VAR 0 7
73910: PUSH
73911: LD_EXP 51
73915: PUSH
73916: LD_VAR 0 2
73920: ARRAY
73921: PPUSH
73922: LD_INT 22
73924: PUSH
73925: LD_INT 0
73927: PUSH
73928: EMPTY
73929: LIST
73930: LIST
73931: PUSH
73932: LD_INT 25
73934: PUSH
73935: LD_INT 12
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PPUSH
73946: CALL_OW 70
73950: PUSH
73951: LD_INT 22
73953: PUSH
73954: LD_INT 0
73956: PUSH
73957: EMPTY
73958: LIST
73959: LIST
73960: PUSH
73961: LD_INT 25
73963: PUSH
73964: LD_INT 12
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PUSH
73971: LD_INT 91
73973: PUSH
73974: LD_VAR 0 9
73978: PUSH
73979: LD_INT 20
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: LIST
73986: PUSH
73987: EMPTY
73988: LIST
73989: LIST
73990: LIST
73991: PPUSH
73992: CALL_OW 69
73996: UNION
73997: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73998: LD_ADDR_VAR 0 10
74002: PUSH
74003: LD_EXP 51
74007: PUSH
74008: LD_VAR 0 2
74012: ARRAY
74013: PPUSH
74014: LD_INT 81
74016: PUSH
74017: LD_VAR 0 11
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PPUSH
74026: CALL_OW 70
74030: ST_TO_ADDR
// if not apes or danger_at_area then
74031: LD_VAR 0 7
74035: NOT
74036: IFTRUE 74044
74038: PUSH
74039: LD_VAR 0 10
74043: OR
74044: IFFALSE 74094
// begin if mc_taming [ i ] then
74046: LD_EXP 54
74050: PUSH
74051: LD_VAR 0 2
74055: ARRAY
74056: IFFALSE 74092
// begin MC_Reset ( i , 121 ) ;
74058: LD_VAR 0 2
74062: PPUSH
74063: LD_INT 121
74065: PPUSH
74066: CALL 58826 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74070: LD_ADDR_EXP 54
74074: PUSH
74075: LD_EXP 54
74079: PPUSH
74080: LD_VAR 0 2
74084: PPUSH
74085: EMPTY
74086: PPUSH
74087: CALL_OW 1
74091: ST_TO_ADDR
// end ; continue ;
74092: GO 73648
// end ; for j in tmp do
74094: LD_ADDR_VAR 0 3
74098: PUSH
74099: LD_VAR 0 8
74103: PUSH
74104: FOR_IN
74105: IFFALSE 74445
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74107: LD_VAR 0 3
74111: PUSH
74112: LD_EXP 54
74116: PUSH
74117: LD_VAR 0 2
74121: ARRAY
74122: IN
74123: NOT
74124: IFFALSE 74142
74126: PUSH
74127: LD_EXP 54
74131: PUSH
74132: LD_VAR 0 2
74136: ARRAY
74137: PUSH
74138: LD_INT 3
74140: LESS
74141: AND
74142: IFFALSE 74200
// begin SetTag ( j , 121 ) ;
74144: LD_VAR 0 3
74148: PPUSH
74149: LD_INT 121
74151: PPUSH
74152: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74156: LD_ADDR_EXP 54
74160: PUSH
74161: LD_EXP 54
74165: PPUSH
74166: LD_VAR 0 2
74170: PUSH
74171: LD_EXP 54
74175: PUSH
74176: LD_VAR 0 2
74180: ARRAY
74181: PUSH
74182: LD_INT 1
74184: PLUS
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PPUSH
74190: LD_VAR 0 3
74194: PPUSH
74195: CALL 16255 0 3
74199: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74200: LD_VAR 0 3
74204: PUSH
74205: LD_EXP 54
74209: PUSH
74210: LD_VAR 0 2
74214: ARRAY
74215: IN
74216: IFFALSE 74443
// begin if GetClass ( j ) <> 4 then
74218: LD_VAR 0 3
74222: PPUSH
74223: CALL_OW 257
74227: PUSH
74228: LD_INT 4
74230: NONEQUAL
74231: IFFALSE 74284
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74233: LD_ADDR_EXP 54
74237: PUSH
74238: LD_EXP 54
74242: PPUSH
74243: LD_VAR 0 2
74247: PPUSH
74248: LD_EXP 54
74252: PUSH
74253: LD_VAR 0 2
74257: ARRAY
74258: PUSH
74259: LD_VAR 0 3
74263: DIFF
74264: PPUSH
74265: CALL_OW 1
74269: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74270: LD_VAR 0 3
74274: PPUSH
74275: LD_INT 0
74277: PPUSH
74278: CALL_OW 109
// continue ;
74282: GO 74104
// end ; if IsInUnit ( j ) then
74284: LD_VAR 0 3
74288: PPUSH
74289: CALL_OW 310
74293: IFFALSE 74304
// ComExitBuilding ( j ) ;
74295: LD_VAR 0 3
74299: PPUSH
74300: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74304: LD_ADDR_VAR 0 6
74308: PUSH
74309: LD_VAR 0 7
74313: PPUSH
74314: LD_VAR 0 3
74318: PPUSH
74319: CALL_OW 74
74323: ST_TO_ADDR
// if not ape then
74324: LD_VAR 0 6
74328: NOT
74329: IFFALSE 74333
// break ;
74331: GO 74445
// x := GetX ( ape ) ;
74333: LD_ADDR_VAR 0 4
74337: PUSH
74338: LD_VAR 0 6
74342: PPUSH
74343: CALL_OW 250
74347: ST_TO_ADDR
// y := GetY ( ape ) ;
74348: LD_ADDR_VAR 0 5
74352: PUSH
74353: LD_VAR 0 6
74357: PPUSH
74358: CALL_OW 251
74362: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74363: LD_VAR 0 4
74367: PPUSH
74368: LD_VAR 0 5
74372: PPUSH
74373: CALL_OW 488
74377: NOT
74378: IFTRUE 74408
74380: PUSH
74381: LD_VAR 0 11
74385: PPUSH
74386: LD_VAR 0 4
74390: PPUSH
74391: LD_VAR 0 5
74395: PPUSH
74396: LD_INT 20
74398: PPUSH
74399: CALL 17525 0 4
74403: PUSH
74404: LD_INT 4
74406: ARRAY
74407: OR
74408: IFFALSE 74412
// break ;
74410: GO 74445
// if not HasTask ( j ) then
74412: LD_VAR 0 3
74416: PPUSH
74417: CALL_OW 314
74421: NOT
74422: IFFALSE 74443
// ComTameXY ( j , x , y ) ;
74424: LD_VAR 0 3
74428: PPUSH
74429: LD_VAR 0 4
74433: PPUSH
74434: LD_VAR 0 5
74438: PPUSH
74439: CALL_OW 131
// end ; end ;
74443: GO 74104
74445: POP
74446: POP
// end ;
74447: GO 73648
74449: POP
74450: POP
// end ;
74451: LD_VAR 0 1
74455: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74456: LD_INT 0
74458: PPUSH
74459: PPUSH
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
74464: PPUSH
74465: PPUSH
// if not mc_bases then
74466: LD_EXP 23
74470: NOT
74471: IFFALSE 74475
// exit ;
74473: GO 75107
// for i = 1 to mc_bases do
74475: LD_ADDR_VAR 0 2
74479: PUSH
74480: DOUBLE
74481: LD_INT 1
74483: DEC
74484: ST_TO_ADDR
74485: LD_EXP 23
74489: PUSH
74490: FOR_TO
74491: IFFALSE 75105
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74493: LD_EXP 52
74497: PUSH
74498: LD_VAR 0 2
74502: ARRAY
74503: NOT
74504: IFTRUE 74534
74506: PUSH
74507: LD_EXP 52
74511: PUSH
74512: LD_VAR 0 2
74516: ARRAY
74517: PPUSH
74518: LD_INT 25
74520: PUSH
74521: LD_INT 12
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PPUSH
74528: CALL_OW 72
74532: NOT
74533: OR
74534: IFFALSE 74538
// continue ;
74536: GO 74490
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74538: LD_ADDR_VAR 0 5
74542: PUSH
74543: LD_EXP 52
74547: PUSH
74548: LD_VAR 0 2
74552: ARRAY
74553: PUSH
74554: LD_INT 1
74556: ARRAY
74557: PPUSH
74558: CALL_OW 255
74562: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74563: LD_VAR 0 5
74567: PPUSH
74568: LD_INT 2
74570: PPUSH
74571: CALL_OW 325
74575: IFFALSE 74828
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74577: LD_ADDR_VAR 0 4
74581: PUSH
74582: LD_EXP 52
74586: PUSH
74587: LD_VAR 0 2
74591: ARRAY
74592: PPUSH
74593: LD_INT 25
74595: PUSH
74596: LD_INT 16
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PPUSH
74603: CALL_OW 72
74607: ST_TO_ADDR
// if tmp < 6 then
74608: LD_VAR 0 4
74612: PUSH
74613: LD_INT 6
74615: LESS
74616: IFFALSE 74828
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74618: LD_ADDR_VAR 0 6
74622: PUSH
74623: LD_EXP 23
74627: PUSH
74628: LD_VAR 0 2
74632: ARRAY
74633: PPUSH
74634: LD_INT 2
74636: PUSH
74637: LD_INT 30
74639: PUSH
74640: LD_INT 0
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: LD_INT 30
74649: PUSH
74650: LD_INT 1
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: LIST
74661: PPUSH
74662: CALL_OW 72
74666: ST_TO_ADDR
// if depot then
74667: LD_VAR 0 6
74671: IFFALSE 74828
// begin selected := 0 ;
74673: LD_ADDR_VAR 0 7
74677: PUSH
74678: LD_INT 0
74680: ST_TO_ADDR
// for j in depot do
74681: LD_ADDR_VAR 0 3
74685: PUSH
74686: LD_VAR 0 6
74690: PUSH
74691: FOR_IN
74692: IFFALSE 74723
// begin if UnitsInside ( j ) < 6 then
74694: LD_VAR 0 3
74698: PPUSH
74699: CALL_OW 313
74703: PUSH
74704: LD_INT 6
74706: LESS
74707: IFFALSE 74721
// begin selected := j ;
74709: LD_ADDR_VAR 0 7
74713: PUSH
74714: LD_VAR 0 3
74718: ST_TO_ADDR
// break ;
74719: GO 74723
// end ; end ;
74721: GO 74691
74723: POP
74724: POP
// if selected then
74725: LD_VAR 0 7
74729: IFFALSE 74828
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74731: LD_ADDR_VAR 0 3
74735: PUSH
74736: LD_EXP 52
74740: PUSH
74741: LD_VAR 0 2
74745: ARRAY
74746: PPUSH
74747: LD_INT 25
74749: PUSH
74750: LD_INT 12
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PPUSH
74757: CALL_OW 72
74761: PUSH
74762: FOR_IN
74763: IFFALSE 74826
// if not HasTask ( j ) then
74765: LD_VAR 0 3
74769: PPUSH
74770: CALL_OW 314
74774: NOT
74775: IFFALSE 74824
// begin if not IsInUnit ( j ) then
74777: LD_VAR 0 3
74781: PPUSH
74782: CALL_OW 310
74786: NOT
74787: IFFALSE 74803
// ComEnterUnit ( j , selected ) ;
74789: LD_VAR 0 3
74793: PPUSH
74794: LD_VAR 0 7
74798: PPUSH
74799: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74803: LD_VAR 0 3
74807: PPUSH
74808: LD_INT 16
74810: PPUSH
74811: CALL_OW 183
// AddComExitBuilding ( j ) ;
74815: LD_VAR 0 3
74819: PPUSH
74820: CALL_OW 182
// end ;
74824: GO 74762
74826: POP
74827: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74828: LD_VAR 0 5
74832: PPUSH
74833: LD_INT 11
74835: PPUSH
74836: CALL_OW 325
74840: IFFALSE 75103
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74842: LD_ADDR_VAR 0 4
74846: PUSH
74847: LD_EXP 52
74851: PUSH
74852: LD_VAR 0 2
74856: ARRAY
74857: PPUSH
74858: LD_INT 25
74860: PUSH
74861: LD_INT 16
74863: PUSH
74864: EMPTY
74865: LIST
74866: LIST
74867: PPUSH
74868: CALL_OW 72
74872: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74873: LD_VAR 0 4
74877: PUSH
74878: LD_INT 6
74880: GREATEREQUAL
74881: IFTRUE 74898
74883: PUSH
74884: LD_VAR 0 5
74888: PPUSH
74889: LD_INT 2
74891: PPUSH
74892: CALL_OW 325
74896: NOT
74897: OR
74898: IFFALSE 75103
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74900: LD_ADDR_VAR 0 8
74904: PUSH
74905: LD_EXP 23
74909: PUSH
74910: LD_VAR 0 2
74914: ARRAY
74915: PPUSH
74916: LD_INT 2
74918: PUSH
74919: LD_INT 30
74921: PUSH
74922: LD_INT 4
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 30
74931: PUSH
74932: LD_INT 5
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: LIST
74943: PPUSH
74944: CALL_OW 72
74948: ST_TO_ADDR
// if barracks then
74949: LD_VAR 0 8
74953: IFFALSE 75103
// begin selected := 0 ;
74955: LD_ADDR_VAR 0 7
74959: PUSH
74960: LD_INT 0
74962: ST_TO_ADDR
// for j in barracks do
74963: LD_ADDR_VAR 0 3
74967: PUSH
74968: LD_VAR 0 8
74972: PUSH
74973: FOR_IN
74974: IFFALSE 75005
// begin if UnitsInside ( j ) < 6 then
74976: LD_VAR 0 3
74980: PPUSH
74981: CALL_OW 313
74985: PUSH
74986: LD_INT 6
74988: LESS
74989: IFFALSE 75003
// begin selected := j ;
74991: LD_ADDR_VAR 0 7
74995: PUSH
74996: LD_VAR 0 3
75000: ST_TO_ADDR
// break ;
75001: GO 75005
// end ; end ;
75003: GO 74973
75005: POP
75006: POP
// if selected then
75007: LD_VAR 0 7
75011: IFFALSE 75103
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75013: LD_ADDR_VAR 0 3
75017: PUSH
75018: LD_EXP 52
75022: PUSH
75023: LD_VAR 0 2
75027: ARRAY
75028: PPUSH
75029: LD_INT 25
75031: PUSH
75032: LD_INT 12
75034: PUSH
75035: EMPTY
75036: LIST
75037: LIST
75038: PPUSH
75039: CALL_OW 72
75043: PUSH
75044: FOR_IN
75045: IFFALSE 75101
// if not IsInUnit ( j ) and not HasTask ( j ) then
75047: LD_VAR 0 3
75051: PPUSH
75052: CALL_OW 310
75056: NOT
75057: IFFALSE 75071
75059: PUSH
75060: LD_VAR 0 3
75064: PPUSH
75065: CALL_OW 314
75069: NOT
75070: AND
75071: IFFALSE 75099
// begin ComEnterUnit ( j , selected ) ;
75073: LD_VAR 0 3
75077: PPUSH
75078: LD_VAR 0 7
75082: PPUSH
75083: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75087: LD_VAR 0 3
75091: PPUSH
75092: LD_INT 15
75094: PPUSH
75095: CALL_OW 183
// end ;
75099: GO 75044
75101: POP
75102: POP
// end ; end ; end ; end ; end ;
75103: GO 74490
75105: POP
75106: POP
// end ;
75107: LD_VAR 0 1
75111: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75112: LD_INT 0
75114: PPUSH
75115: PPUSH
75116: PPUSH
75117: PPUSH
// if not mc_bases then
75118: LD_EXP 23
75122: NOT
75123: IFFALSE 75127
// exit ;
75125: GO 75309
// for i = 1 to mc_bases do
75127: LD_ADDR_VAR 0 2
75131: PUSH
75132: DOUBLE
75133: LD_INT 1
75135: DEC
75136: ST_TO_ADDR
75137: LD_EXP 23
75141: PUSH
75142: FOR_TO
75143: IFFALSE 75307
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75145: LD_ADDR_VAR 0 4
75149: PUSH
75150: LD_EXP 23
75154: PUSH
75155: LD_VAR 0 2
75159: ARRAY
75160: PPUSH
75161: LD_INT 25
75163: PUSH
75164: LD_INT 9
75166: PUSH
75167: EMPTY
75168: LIST
75169: LIST
75170: PPUSH
75171: CALL_OW 72
75175: ST_TO_ADDR
// if not tmp then
75176: LD_VAR 0 4
75180: NOT
75181: IFFALSE 75185
// continue ;
75183: GO 75142
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75185: LD_EXP 49
75189: PUSH
75190: LD_VAR 0 2
75194: ARRAY
75195: PPUSH
75196: LD_INT 29
75198: PPUSH
75199: CALL_OW 325
75203: NOT
75204: IFFALSE 75227
75206: PUSH
75207: LD_EXP 49
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: PPUSH
75218: LD_INT 28
75220: PPUSH
75221: CALL_OW 325
75225: NOT
75226: AND
75227: IFFALSE 75231
// continue ;
75229: GO 75142
// for j in tmp do
75231: LD_ADDR_VAR 0 3
75235: PUSH
75236: LD_VAR 0 4
75240: PUSH
75241: FOR_IN
75242: IFFALSE 75303
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75244: LD_VAR 0 3
75248: PUSH
75249: LD_EXP 26
75253: PUSH
75254: LD_VAR 0 2
75258: ARRAY
75259: PUSH
75260: LD_INT 1
75262: ARRAY
75263: IN
75264: NOT
75265: IFFALSE 75290
75267: PUSH
75268: LD_VAR 0 3
75272: PUSH
75273: LD_EXP 26
75277: PUSH
75278: LD_VAR 0 2
75282: ARRAY
75283: PUSH
75284: LD_INT 2
75286: ARRAY
75287: IN
75288: NOT
75289: AND
75290: IFFALSE 75301
// ComSpaceTimeShoot ( j ) ;
75292: LD_VAR 0 3
75296: PPUSH
75297: CALL 12206 0 1
75301: GO 75241
75303: POP
75304: POP
// end ;
75305: GO 75142
75307: POP
75308: POP
// end ;
75309: LD_VAR 0 1
75313: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75314: LD_INT 0
75316: PPUSH
75317: PPUSH
75318: PPUSH
75319: PPUSH
75320: PPUSH
75321: PPUSH
75322: PPUSH
75323: PPUSH
75324: PPUSH
// if not mc_bases then
75325: LD_EXP 23
75329: NOT
75330: IFFALSE 75334
// exit ;
75332: GO 75966
// for i = 1 to mc_bases do
75334: LD_ADDR_VAR 0 2
75338: PUSH
75339: DOUBLE
75340: LD_INT 1
75342: DEC
75343: ST_TO_ADDR
75344: LD_EXP 23
75348: PUSH
75349: FOR_TO
75350: IFFALSE 75964
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75352: LD_EXP 58
75356: PUSH
75357: LD_VAR 0 2
75361: ARRAY
75362: NOT
75363: IFTRUE 75389
75365: PUSH
75366: LD_INT 38
75368: PPUSH
75369: LD_EXP 49
75373: PUSH
75374: LD_VAR 0 2
75378: ARRAY
75379: PPUSH
75380: CALL_OW 321
75384: PUSH
75385: LD_INT 2
75387: NONEQUAL
75388: OR
75389: IFFALSE 75393
// continue ;
75391: GO 75349
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75393: LD_ADDR_VAR 0 8
75397: PUSH
75398: LD_EXP 23
75402: PUSH
75403: LD_VAR 0 2
75407: ARRAY
75408: PPUSH
75409: LD_INT 30
75411: PUSH
75412: LD_INT 34
75414: PUSH
75415: EMPTY
75416: LIST
75417: LIST
75418: PPUSH
75419: CALL_OW 72
75423: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75424: LD_ADDR_VAR 0 9
75428: PUSH
75429: LD_EXP 23
75433: PUSH
75434: LD_VAR 0 2
75438: ARRAY
75439: PPUSH
75440: LD_INT 25
75442: PUSH
75443: LD_INT 4
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PPUSH
75450: CALL_OW 72
75454: PPUSH
75455: LD_INT 0
75457: PPUSH
75458: CALL 46848 0 2
75462: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75463: LD_VAR 0 9
75467: NOT
75468: IFTRUE 75477
75470: PUSH
75471: LD_VAR 0 8
75475: NOT
75476: OR
75477: IFTRUE 75499
75479: PUSH
75480: LD_EXP 23
75484: PUSH
75485: LD_VAR 0 2
75489: ARRAY
75490: PPUSH
75491: LD_INT 124
75493: PPUSH
75494: CALL 46848 0 2
75498: OR
75499: IFFALSE 75503
// continue ;
75501: GO 75349
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75503: LD_EXP 59
75507: PUSH
75508: LD_VAR 0 2
75512: ARRAY
75513: PUSH
75514: LD_EXP 58
75518: PUSH
75519: LD_VAR 0 2
75523: ARRAY
75524: LESS
75525: IFFALSE 75545
75527: PUSH
75528: LD_EXP 59
75532: PUSH
75533: LD_VAR 0 2
75537: ARRAY
75538: PUSH
75539: LD_VAR 0 8
75543: LESS
75544: AND
75545: IFFALSE 75962
// begin tmp := sci [ 1 ] ;
75547: LD_ADDR_VAR 0 7
75551: PUSH
75552: LD_VAR 0 9
75556: PUSH
75557: LD_INT 1
75559: ARRAY
75560: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75561: LD_VAR 0 7
75565: PPUSH
75566: LD_INT 124
75568: PPUSH
75569: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75573: LD_ADDR_VAR 0 3
75577: PUSH
75578: DOUBLE
75579: LD_EXP 58
75583: PUSH
75584: LD_VAR 0 2
75588: ARRAY
75589: INC
75590: ST_TO_ADDR
75591: LD_EXP 58
75595: PUSH
75596: LD_VAR 0 2
75600: ARRAY
75601: PUSH
75602: FOR_DOWNTO
75603: IFFALSE 75948
// begin if IsInUnit ( tmp ) then
75605: LD_VAR 0 7
75609: PPUSH
75610: CALL_OW 310
75614: IFFALSE 75625
// ComExitBuilding ( tmp ) ;
75616: LD_VAR 0 7
75620: PPUSH
75621: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75625: LD_INT 35
75627: PPUSH
75628: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75632: LD_VAR 0 7
75636: PPUSH
75637: CALL_OW 310
75641: NOT
75642: IFFALSE 75656
75644: PUSH
75645: LD_VAR 0 7
75649: PPUSH
75650: CALL_OW 314
75654: NOT
75655: AND
75656: IFFALSE 75625
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75658: LD_ADDR_VAR 0 6
75662: PUSH
75663: LD_VAR 0 7
75667: PPUSH
75668: CALL_OW 250
75672: PUSH
75673: LD_VAR 0 7
75677: PPUSH
75678: CALL_OW 251
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75687: LD_INT 35
75689: PPUSH
75690: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75694: LD_ADDR_VAR 0 4
75698: PUSH
75699: LD_EXP 58
75703: PUSH
75704: LD_VAR 0 2
75708: ARRAY
75709: PUSH
75710: LD_VAR 0 3
75714: ARRAY
75715: PUSH
75716: LD_INT 1
75718: ARRAY
75719: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75720: LD_ADDR_VAR 0 5
75724: PUSH
75725: LD_EXP 58
75729: PUSH
75730: LD_VAR 0 2
75734: ARRAY
75735: PUSH
75736: LD_VAR 0 3
75740: ARRAY
75741: PUSH
75742: LD_INT 2
75744: ARRAY
75745: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75746: LD_VAR 0 7
75750: PPUSH
75751: LD_INT 10
75753: PPUSH
75754: CALL 19234 0 2
75758: PUSH
75759: LD_INT 4
75761: ARRAY
75762: IFFALSE 75800
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75764: LD_VAR 0 7
75768: PPUSH
75769: LD_VAR 0 6
75773: PUSH
75774: LD_INT 1
75776: ARRAY
75777: PPUSH
75778: LD_VAR 0 6
75782: PUSH
75783: LD_INT 2
75785: ARRAY
75786: PPUSH
75787: CALL_OW 111
// wait ( 0 0$10 ) ;
75791: LD_INT 350
75793: PPUSH
75794: CALL_OW 67
// end else
75798: GO 75826
// begin ComMoveXY ( tmp , x , y ) ;
75800: LD_VAR 0 7
75804: PPUSH
75805: LD_VAR 0 4
75809: PPUSH
75810: LD_VAR 0 5
75814: PPUSH
75815: CALL_OW 111
// wait ( 0 0$3 ) ;
75819: LD_INT 105
75821: PPUSH
75822: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75826: LD_VAR 0 7
75830: PPUSH
75831: LD_VAR 0 4
75835: PPUSH
75836: LD_VAR 0 5
75840: PPUSH
75841: CALL_OW 307
75845: IFFALSE 75687
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75847: LD_VAR 0 7
75851: PPUSH
75852: LD_VAR 0 4
75856: PPUSH
75857: LD_VAR 0 5
75861: PPUSH
75862: LD_VAR 0 8
75866: PUSH
75867: LD_VAR 0 3
75871: ARRAY
75872: PPUSH
75873: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75877: LD_INT 35
75879: PPUSH
75880: CALL_OW 67
// until not HasTask ( tmp ) ;
75884: LD_VAR 0 7
75888: PPUSH
75889: CALL_OW 314
75893: NOT
75894: IFFALSE 75877
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75896: LD_ADDR_EXP 59
75900: PUSH
75901: LD_EXP 59
75905: PPUSH
75906: LD_VAR 0 2
75910: PUSH
75911: LD_EXP 59
75915: PUSH
75916: LD_VAR 0 2
75920: ARRAY
75921: PUSH
75922: LD_INT 1
75924: PLUS
75925: PUSH
75926: EMPTY
75927: LIST
75928: LIST
75929: PPUSH
75930: LD_VAR 0 8
75934: PUSH
75935: LD_VAR 0 3
75939: ARRAY
75940: PPUSH
75941: CALL 16255 0 3
75945: ST_TO_ADDR
// end ;
75946: GO 75602
75948: POP
75949: POP
// MC_Reset ( i , 124 ) ;
75950: LD_VAR 0 2
75954: PPUSH
75955: LD_INT 124
75957: PPUSH
75958: CALL 58826 0 2
// end ; end ;
75962: GO 75349
75964: POP
75965: POP
// end ;
75966: LD_VAR 0 1
75970: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75971: LD_INT 0
75973: PPUSH
75974: PPUSH
75975: PPUSH
// if not mc_bases then
75976: LD_EXP 23
75980: NOT
75981: IFFALSE 75985
// exit ;
75983: GO 76599
// for i = 1 to mc_bases do
75985: LD_ADDR_VAR 0 2
75989: PUSH
75990: DOUBLE
75991: LD_INT 1
75993: DEC
75994: ST_TO_ADDR
75995: LD_EXP 23
75999: PUSH
76000: FOR_TO
76001: IFFALSE 76597
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76003: LD_ADDR_VAR 0 3
76007: PUSH
76008: LD_EXP 23
76012: PUSH
76013: LD_VAR 0 2
76017: ARRAY
76018: PPUSH
76019: LD_INT 25
76021: PUSH
76022: LD_INT 4
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PPUSH
76029: CALL_OW 72
76033: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76034: LD_VAR 0 3
76038: NOT
76039: IFTRUE 76054
76041: PUSH
76042: LD_EXP 60
76046: PUSH
76047: LD_VAR 0 2
76051: ARRAY
76052: NOT
76053: OR
76054: IFTRUE 76102
76056: PUSH
76057: LD_EXP 23
76061: PUSH
76062: LD_VAR 0 2
76066: ARRAY
76067: PPUSH
76068: LD_INT 2
76070: PUSH
76071: LD_INT 30
76073: PUSH
76074: LD_INT 0
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 30
76083: PUSH
76084: LD_INT 1
76086: PUSH
76087: EMPTY
76088: LIST
76089: LIST
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: LIST
76095: PPUSH
76096: CALL_OW 72
76100: NOT
76101: OR
76102: IFFALSE 76152
// begin if mc_deposits_finder [ i ] then
76104: LD_EXP 61
76108: PUSH
76109: LD_VAR 0 2
76113: ARRAY
76114: IFFALSE 76150
// begin MC_Reset ( i , 125 ) ;
76116: LD_VAR 0 2
76120: PPUSH
76121: LD_INT 125
76123: PPUSH
76124: CALL 58826 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76128: LD_ADDR_EXP 61
76132: PUSH
76133: LD_EXP 61
76137: PPUSH
76138: LD_VAR 0 2
76142: PPUSH
76143: EMPTY
76144: PPUSH
76145: CALL_OW 1
76149: ST_TO_ADDR
// end ; continue ;
76150: GO 76000
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76152: LD_EXP 60
76156: PUSH
76157: LD_VAR 0 2
76161: ARRAY
76162: PUSH
76163: LD_INT 1
76165: ARRAY
76166: PUSH
76167: LD_INT 3
76169: ARRAY
76170: PUSH
76171: LD_INT 1
76173: EQUAL
76174: IFFALSE 76200
76176: PUSH
76177: LD_INT 20
76179: PPUSH
76180: LD_EXP 49
76184: PUSH
76185: LD_VAR 0 2
76189: ARRAY
76190: PPUSH
76191: CALL_OW 321
76195: PUSH
76196: LD_INT 2
76198: NONEQUAL
76199: AND
76200: IFFALSE 76250
// begin if mc_deposits_finder [ i ] then
76202: LD_EXP 61
76206: PUSH
76207: LD_VAR 0 2
76211: ARRAY
76212: IFFALSE 76248
// begin MC_Reset ( i , 125 ) ;
76214: LD_VAR 0 2
76218: PPUSH
76219: LD_INT 125
76221: PPUSH
76222: CALL 58826 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76226: LD_ADDR_EXP 61
76230: PUSH
76231: LD_EXP 61
76235: PPUSH
76236: LD_VAR 0 2
76240: PPUSH
76241: EMPTY
76242: PPUSH
76243: CALL_OW 1
76247: ST_TO_ADDR
// end ; continue ;
76248: GO 76000
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76250: LD_EXP 60
76254: PUSH
76255: LD_VAR 0 2
76259: ARRAY
76260: PUSH
76261: LD_INT 1
76263: ARRAY
76264: PUSH
76265: LD_INT 1
76267: ARRAY
76268: PPUSH
76269: LD_EXP 60
76273: PUSH
76274: LD_VAR 0 2
76278: ARRAY
76279: PUSH
76280: LD_INT 1
76282: ARRAY
76283: PUSH
76284: LD_INT 2
76286: ARRAY
76287: PPUSH
76288: LD_EXP 49
76292: PUSH
76293: LD_VAR 0 2
76297: ARRAY
76298: PPUSH
76299: CALL_OW 440
76303: IFFALSE 76346
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76305: LD_ADDR_EXP 60
76309: PUSH
76310: LD_EXP 60
76314: PPUSH
76315: LD_VAR 0 2
76319: PPUSH
76320: LD_EXP 60
76324: PUSH
76325: LD_VAR 0 2
76329: ARRAY
76330: PPUSH
76331: LD_INT 1
76333: PPUSH
76334: CALL_OW 3
76338: PPUSH
76339: CALL_OW 1
76343: ST_TO_ADDR
76344: GO 76595
// begin if not mc_deposits_finder [ i ] then
76346: LD_EXP 61
76350: PUSH
76351: LD_VAR 0 2
76355: ARRAY
76356: NOT
76357: IFFALSE 76409
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76359: LD_ADDR_EXP 61
76363: PUSH
76364: LD_EXP 61
76368: PPUSH
76369: LD_VAR 0 2
76373: PPUSH
76374: LD_VAR 0 3
76378: PUSH
76379: LD_INT 1
76381: ARRAY
76382: PUSH
76383: EMPTY
76384: LIST
76385: PPUSH
76386: CALL_OW 1
76390: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76391: LD_VAR 0 3
76395: PUSH
76396: LD_INT 1
76398: ARRAY
76399: PPUSH
76400: LD_INT 125
76402: PPUSH
76403: CALL_OW 109
// end else
76407: GO 76595
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76409: LD_EXP 61
76413: PUSH
76414: LD_VAR 0 2
76418: ARRAY
76419: PUSH
76420: LD_INT 1
76422: ARRAY
76423: PPUSH
76424: CALL_OW 310
76428: IFFALSE 76451
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76430: LD_EXP 61
76434: PUSH
76435: LD_VAR 0 2
76439: ARRAY
76440: PUSH
76441: LD_INT 1
76443: ARRAY
76444: PPUSH
76445: CALL_OW 122
76449: GO 76595
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76451: LD_EXP 61
76455: PUSH
76456: LD_VAR 0 2
76460: ARRAY
76461: PUSH
76462: LD_INT 1
76464: ARRAY
76465: PPUSH
76466: CALL_OW 314
76470: NOT
76471: IFFALSE 76536
76473: PUSH
76474: LD_EXP 61
76478: PUSH
76479: LD_VAR 0 2
76483: ARRAY
76484: PUSH
76485: LD_INT 1
76487: ARRAY
76488: PPUSH
76489: LD_EXP 60
76493: PUSH
76494: LD_VAR 0 2
76498: ARRAY
76499: PUSH
76500: LD_INT 1
76502: ARRAY
76503: PUSH
76504: LD_INT 1
76506: ARRAY
76507: PPUSH
76508: LD_EXP 60
76512: PUSH
76513: LD_VAR 0 2
76517: ARRAY
76518: PUSH
76519: LD_INT 1
76521: ARRAY
76522: PUSH
76523: LD_INT 2
76525: ARRAY
76526: PPUSH
76527: CALL_OW 297
76531: PUSH
76532: LD_INT 6
76534: GREATER
76535: AND
76536: IFFALSE 76595
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76538: LD_EXP 61
76542: PUSH
76543: LD_VAR 0 2
76547: ARRAY
76548: PUSH
76549: LD_INT 1
76551: ARRAY
76552: PPUSH
76553: LD_EXP 60
76557: PUSH
76558: LD_VAR 0 2
76562: ARRAY
76563: PUSH
76564: LD_INT 1
76566: ARRAY
76567: PUSH
76568: LD_INT 1
76570: ARRAY
76571: PPUSH
76572: LD_EXP 60
76576: PUSH
76577: LD_VAR 0 2
76581: ARRAY
76582: PUSH
76583: LD_INT 1
76585: ARRAY
76586: PUSH
76587: LD_INT 2
76589: ARRAY
76590: PPUSH
76591: CALL_OW 111
// end ; end ; end ;
76595: GO 76000
76597: POP
76598: POP
// end ;
76599: LD_VAR 0 1
76603: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76604: LD_INT 0
76606: PPUSH
76607: PPUSH
76608: PPUSH
76609: PPUSH
76610: PPUSH
76611: PPUSH
76612: PPUSH
76613: PPUSH
76614: PPUSH
76615: PPUSH
76616: PPUSH
// if not mc_bases then
76617: LD_EXP 23
76621: NOT
76622: IFFALSE 76626
// exit ;
76624: GO 77586
// for i = 1 to mc_bases do
76626: LD_ADDR_VAR 0 2
76630: PUSH
76631: DOUBLE
76632: LD_INT 1
76634: DEC
76635: ST_TO_ADDR
76636: LD_EXP 23
76640: PUSH
76641: FOR_TO
76642: IFFALSE 77584
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76644: LD_EXP 23
76648: PUSH
76649: LD_VAR 0 2
76653: ARRAY
76654: NOT
76655: IFTRUE 76669
76657: PUSH
76658: LD_EXP 46
76662: PUSH
76663: LD_VAR 0 2
76667: ARRAY
76668: OR
76669: IFFALSE 76673
// continue ;
76671: GO 76641
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76673: LD_ADDR_VAR 0 7
76677: PUSH
76678: LD_EXP 23
76682: PUSH
76683: LD_VAR 0 2
76687: ARRAY
76688: PUSH
76689: LD_INT 1
76691: ARRAY
76692: PPUSH
76693: CALL_OW 248
76697: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76698: LD_VAR 0 7
76702: PUSH
76703: LD_INT 3
76705: EQUAL
76706: IFTRUE 76748
76708: PUSH
76709: LD_EXP 42
76713: PUSH
76714: LD_VAR 0 2
76718: ARRAY
76719: PUSH
76720: LD_EXP 45
76724: PUSH
76725: LD_VAR 0 2
76729: ARRAY
76730: UNION
76731: PPUSH
76732: LD_INT 33
76734: PUSH
76735: LD_INT 2
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PPUSH
76742: CALL_OW 72
76746: NOT
76747: OR
76748: IFFALSE 76752
// continue ;
76750: GO 76641
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76752: LD_ADDR_VAR 0 9
76756: PUSH
76757: LD_EXP 23
76761: PUSH
76762: LD_VAR 0 2
76766: ARRAY
76767: PPUSH
76768: LD_INT 30
76770: PUSH
76771: LD_INT 36
76773: PUSH
76774: EMPTY
76775: LIST
76776: LIST
76777: PPUSH
76778: CALL_OW 72
76782: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76783: LD_ADDR_VAR 0 10
76787: PUSH
76788: LD_EXP 42
76792: PUSH
76793: LD_VAR 0 2
76797: ARRAY
76798: PPUSH
76799: LD_INT 34
76801: PUSH
76802: LD_INT 31
76804: PUSH
76805: EMPTY
76806: LIST
76807: LIST
76808: PPUSH
76809: CALL_OW 72
76813: ST_TO_ADDR
// if not cts and not mcts then
76814: LD_VAR 0 9
76818: NOT
76819: IFFALSE 76828
76821: PUSH
76822: LD_VAR 0 10
76826: NOT
76827: AND
76828: IFFALSE 76832
// continue ;
76830: GO 76641
// x := cts ;
76832: LD_ADDR_VAR 0 11
76836: PUSH
76837: LD_VAR 0 9
76841: ST_TO_ADDR
// if not x then
76842: LD_VAR 0 11
76846: NOT
76847: IFFALSE 76859
// x := mcts ;
76849: LD_ADDR_VAR 0 11
76853: PUSH
76854: LD_VAR 0 10
76858: ST_TO_ADDR
// if not x then
76859: LD_VAR 0 11
76863: NOT
76864: IFFALSE 76868
// continue ;
76866: GO 76641
// if mc_remote_driver [ i ] then
76868: LD_EXP 63
76872: PUSH
76873: LD_VAR 0 2
76877: ARRAY
76878: IFFALSE 77277
// for j in mc_remote_driver [ i ] do
76880: LD_ADDR_VAR 0 3
76884: PUSH
76885: LD_EXP 63
76889: PUSH
76890: LD_VAR 0 2
76894: ARRAY
76895: PUSH
76896: FOR_IN
76897: IFFALSE 77275
// begin if GetClass ( j ) <> 3 then
76899: LD_VAR 0 3
76903: PPUSH
76904: CALL_OW 257
76908: PUSH
76909: LD_INT 3
76911: NONEQUAL
76912: IFFALSE 76965
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76914: LD_ADDR_EXP 63
76918: PUSH
76919: LD_EXP 63
76923: PPUSH
76924: LD_VAR 0 2
76928: PPUSH
76929: LD_EXP 63
76933: PUSH
76934: LD_VAR 0 2
76938: ARRAY
76939: PUSH
76940: LD_VAR 0 3
76944: DIFF
76945: PPUSH
76946: CALL_OW 1
76950: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76951: LD_VAR 0 3
76955: PPUSH
76956: LD_INT 0
76958: PPUSH
76959: CALL_OW 109
// continue ;
76963: GO 76896
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76965: LD_EXP 42
76969: PUSH
76970: LD_VAR 0 2
76974: ARRAY
76975: PPUSH
76976: LD_INT 34
76978: PUSH
76979: LD_INT 31
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 58
76988: PUSH
76989: EMPTY
76990: LIST
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PPUSH
76996: CALL_OW 72
77000: IFFALSE 77014
77002: PUSH
77003: LD_VAR 0 3
77007: PPUSH
77008: CALL 46883 0 1
77012: NOT
77013: AND
77014: IFFALSE 77085
// begin if IsInUnit ( j ) then
77016: LD_VAR 0 3
77020: PPUSH
77021: CALL_OW 310
77025: IFFALSE 77036
// ComExitBuilding ( j ) ;
77027: LD_VAR 0 3
77031: PPUSH
77032: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
77036: LD_VAR 0 3
77040: PPUSH
77041: LD_EXP 42
77045: PUSH
77046: LD_VAR 0 2
77050: ARRAY
77051: PPUSH
77052: LD_INT 34
77054: PUSH
77055: LD_INT 31
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 58
77064: PUSH
77065: EMPTY
77066: LIST
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PPUSH
77072: CALL_OW 72
77076: PUSH
77077: LD_INT 1
77079: ARRAY
77080: PPUSH
77081: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77085: LD_VAR 0 3
77089: PPUSH
77090: CALL_OW 310
77094: NOT
77095: IFTRUE 77131
77097: PUSH
77098: LD_VAR 0 3
77102: PPUSH
77103: CALL_OW 310
77107: PPUSH
77108: CALL_OW 266
77112: PUSH
77113: LD_INT 36
77115: NONEQUAL
77116: IFFALSE 77130
77118: PUSH
77119: LD_VAR 0 3
77123: PPUSH
77124: CALL 46883 0 1
77128: NOT
77129: AND
77130: OR
77131: IFFALSE 77273
// begin if IsInUnit ( j ) then
77133: LD_VAR 0 3
77137: PPUSH
77138: CALL_OW 310
77142: IFFALSE 77153
// ComExitBuilding ( j ) ;
77144: LD_VAR 0 3
77148: PPUSH
77149: CALL_OW 122
// ct := 0 ;
77153: LD_ADDR_VAR 0 8
77157: PUSH
77158: LD_INT 0
77160: ST_TO_ADDR
// for k in x do
77161: LD_ADDR_VAR 0 4
77165: PUSH
77166: LD_VAR 0 11
77170: PUSH
77171: FOR_IN
77172: IFFALSE 77251
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77174: LD_VAR 0 4
77178: PPUSH
77179: CALL_OW 264
77183: PUSH
77184: LD_INT 31
77186: EQUAL
77187: IFFALSE 77201
77189: PUSH
77190: LD_VAR 0 4
77194: PPUSH
77195: CALL_OW 311
77199: NOT
77200: AND
77201: IFTRUE 77235
77203: PUSH
77204: LD_VAR 0 4
77208: PPUSH
77209: CALL_OW 266
77213: PUSH
77214: LD_INT 36
77216: EQUAL
77217: IFFALSE 77234
77219: PUSH
77220: LD_VAR 0 4
77224: PPUSH
77225: CALL_OW 313
77229: PUSH
77230: LD_INT 3
77232: LESS
77233: AND
77234: OR
77235: IFFALSE 77249
// begin ct := k ;
77237: LD_ADDR_VAR 0 8
77241: PUSH
77242: LD_VAR 0 4
77246: ST_TO_ADDR
// break ;
77247: GO 77251
// end ;
77249: GO 77171
77251: POP
77252: POP
// if ct then
77253: LD_VAR 0 8
77257: IFFALSE 77273
// ComEnterUnit ( j , ct ) ;
77259: LD_VAR 0 3
77263: PPUSH
77264: LD_VAR 0 8
77268: PPUSH
77269: CALL_OW 120
// end ; end ;
77273: GO 76896
77275: POP
77276: POP
// places := 0 ;
77277: LD_ADDR_VAR 0 5
77281: PUSH
77282: LD_INT 0
77284: ST_TO_ADDR
// for j = 1 to x do
77285: LD_ADDR_VAR 0 3
77289: PUSH
77290: DOUBLE
77291: LD_INT 1
77293: DEC
77294: ST_TO_ADDR
77295: LD_VAR 0 11
77299: PUSH
77300: FOR_TO
77301: IFFALSE 77377
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77303: LD_VAR 0 11
77307: PUSH
77308: LD_VAR 0 3
77312: ARRAY
77313: PPUSH
77314: CALL_OW 264
77318: PUSH
77319: LD_INT 31
77321: EQUAL
77322: IFFALSE 77340
// places := places + 1 else
77324: LD_ADDR_VAR 0 5
77328: PUSH
77329: LD_VAR 0 5
77333: PUSH
77334: LD_INT 1
77336: PLUS
77337: ST_TO_ADDR
77338: GO 77375
// if GetBType ( x [ j ] ) = b_control_tower then
77340: LD_VAR 0 11
77344: PUSH
77345: LD_VAR 0 3
77349: ARRAY
77350: PPUSH
77351: CALL_OW 266
77355: PUSH
77356: LD_INT 36
77358: EQUAL
77359: IFFALSE 77375
// places := places + 3 ;
77361: LD_ADDR_VAR 0 5
77365: PUSH
77366: LD_VAR 0 5
77370: PUSH
77371: LD_INT 3
77373: PLUS
77374: ST_TO_ADDR
77375: GO 77300
77377: POP
77378: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77379: LD_VAR 0 5
77383: PUSH
77384: LD_INT 0
77386: EQUAL
77387: IFTRUE 77407
77389: PUSH
77390: LD_VAR 0 5
77394: PUSH
77395: LD_EXP 63
77399: PUSH
77400: LD_VAR 0 2
77404: ARRAY
77405: LESSEQUAL
77406: OR
77407: IFFALSE 77411
// continue ;
77409: GO 76641
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77411: LD_ADDR_VAR 0 6
77415: PUSH
77416: LD_EXP 23
77420: PUSH
77421: LD_VAR 0 2
77425: ARRAY
77426: PPUSH
77427: LD_INT 25
77429: PUSH
77430: LD_INT 3
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PPUSH
77437: CALL_OW 72
77441: PUSH
77442: LD_EXP 63
77446: PUSH
77447: LD_VAR 0 2
77451: ARRAY
77452: DIFF
77453: PPUSH
77454: LD_INT 3
77456: PPUSH
77457: CALL 47783 0 2
77461: ST_TO_ADDR
// for j in tmp do
77462: LD_ADDR_VAR 0 3
77466: PUSH
77467: LD_VAR 0 6
77471: PUSH
77472: FOR_IN
77473: IFFALSE 77508
// if GetTag ( j ) > 0 then
77475: LD_VAR 0 3
77479: PPUSH
77480: CALL_OW 110
77484: PUSH
77485: LD_INT 0
77487: GREATER
77488: IFFALSE 77506
// tmp := tmp diff j ;
77490: LD_ADDR_VAR 0 6
77494: PUSH
77495: LD_VAR 0 6
77499: PUSH
77500: LD_VAR 0 3
77504: DIFF
77505: ST_TO_ADDR
77506: GO 77472
77508: POP
77509: POP
// if not tmp then
77510: LD_VAR 0 6
77514: NOT
77515: IFFALSE 77519
// continue ;
77517: GO 76641
// if places then
77519: LD_VAR 0 5
77523: IFFALSE 77582
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77525: LD_ADDR_EXP 63
77529: PUSH
77530: LD_EXP 63
77534: PPUSH
77535: LD_VAR 0 2
77539: PPUSH
77540: LD_EXP 63
77544: PUSH
77545: LD_VAR 0 2
77549: ARRAY
77550: PUSH
77551: LD_VAR 0 6
77555: PUSH
77556: LD_INT 1
77558: ARRAY
77559: UNION
77560: PPUSH
77561: CALL_OW 1
77565: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77566: LD_VAR 0 6
77570: PUSH
77571: LD_INT 1
77573: ARRAY
77574: PPUSH
77575: LD_INT 126
77577: PPUSH
77578: CALL_OW 109
// end ; end ;
77582: GO 76641
77584: POP
77585: POP
// end ;
77586: LD_VAR 0 1
77590: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77591: LD_INT 0
77593: PPUSH
77594: PPUSH
77595: PPUSH
77596: PPUSH
77597: PPUSH
77598: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77599: LD_VAR 0 1
77603: NOT
77604: IFTRUE 77613
77606: PUSH
77607: LD_VAR 0 2
77611: NOT
77612: OR
77613: IFTRUE 77622
77615: PUSH
77616: LD_VAR 0 3
77620: NOT
77621: OR
77622: IFTRUE 77670
77624: PUSH
77625: LD_VAR 0 4
77629: PUSH
77630: LD_INT 1
77632: PUSH
77633: LD_INT 2
77635: PUSH
77636: LD_INT 3
77638: PUSH
77639: LD_INT 4
77641: PUSH
77642: LD_INT 5
77644: PUSH
77645: LD_INT 8
77647: PUSH
77648: LD_INT 9
77650: PUSH
77651: LD_INT 15
77653: PUSH
77654: LD_INT 16
77656: PUSH
77657: EMPTY
77658: LIST
77659: LIST
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: IN
77668: NOT
77669: OR
77670: IFFALSE 77674
// exit ;
77672: GO 78534
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77674: LD_ADDR_VAR 0 2
77678: PUSH
77679: LD_VAR 0 2
77683: PPUSH
77684: LD_INT 21
77686: PUSH
77687: LD_INT 3
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PUSH
77694: LD_INT 24
77696: PUSH
77697: LD_INT 250
77699: PUSH
77700: EMPTY
77701: LIST
77702: LIST
77703: PUSH
77704: EMPTY
77705: LIST
77706: LIST
77707: PPUSH
77708: CALL_OW 72
77712: ST_TO_ADDR
// case class of 1 , 15 :
77713: LD_VAR 0 4
77717: PUSH
77718: LD_INT 1
77720: DOUBLE
77721: EQUAL
77722: IFTRUE 77732
77724: LD_INT 15
77726: DOUBLE
77727: EQUAL
77728: IFTRUE 77732
77730: GO 77817
77732: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77733: LD_ADDR_VAR 0 8
77737: PUSH
77738: LD_VAR 0 2
77742: PPUSH
77743: LD_INT 2
77745: PUSH
77746: LD_INT 30
77748: PUSH
77749: LD_INT 32
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 30
77758: PUSH
77759: LD_INT 31
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: EMPTY
77767: LIST
77768: LIST
77769: LIST
77770: PPUSH
77771: CALL_OW 72
77775: PUSH
77776: LD_VAR 0 2
77780: PPUSH
77781: LD_INT 2
77783: PUSH
77784: LD_INT 30
77786: PUSH
77787: LD_INT 4
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 30
77796: PUSH
77797: LD_INT 5
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: LIST
77808: PPUSH
77809: CALL_OW 72
77813: ADD
77814: ST_TO_ADDR
77815: GO 78063
77817: LD_INT 2
77819: DOUBLE
77820: EQUAL
77821: IFTRUE 77831
77823: LD_INT 16
77825: DOUBLE
77826: EQUAL
77827: IFTRUE 77831
77829: GO 77877
77831: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77832: LD_ADDR_VAR 0 8
77836: PUSH
77837: LD_VAR 0 2
77841: PPUSH
77842: LD_INT 2
77844: PUSH
77845: LD_INT 30
77847: PUSH
77848: LD_INT 0
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: PUSH
77855: LD_INT 30
77857: PUSH
77858: LD_INT 1
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: LIST
77869: PPUSH
77870: CALL_OW 72
77874: ST_TO_ADDR
77875: GO 78063
77877: LD_INT 3
77879: DOUBLE
77880: EQUAL
77881: IFTRUE 77885
77883: GO 77931
77885: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77886: LD_ADDR_VAR 0 8
77890: PUSH
77891: LD_VAR 0 2
77895: PPUSH
77896: LD_INT 2
77898: PUSH
77899: LD_INT 30
77901: PUSH
77902: LD_INT 2
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: PUSH
77909: LD_INT 30
77911: PUSH
77912: LD_INT 3
77914: PUSH
77915: EMPTY
77916: LIST
77917: LIST
77918: PUSH
77919: EMPTY
77920: LIST
77921: LIST
77922: LIST
77923: PPUSH
77924: CALL_OW 72
77928: ST_TO_ADDR
77929: GO 78063
77931: LD_INT 4
77933: DOUBLE
77934: EQUAL
77935: IFTRUE 77939
77937: GO 77996
77939: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77940: LD_ADDR_VAR 0 8
77944: PUSH
77945: LD_VAR 0 2
77949: PPUSH
77950: LD_INT 2
77952: PUSH
77953: LD_INT 30
77955: PUSH
77956: LD_INT 6
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 30
77965: PUSH
77966: LD_INT 7
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 30
77975: PUSH
77976: LD_INT 8
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: PPUSH
77989: CALL_OW 72
77993: ST_TO_ADDR
77994: GO 78063
77996: LD_INT 5
77998: DOUBLE
77999: EQUAL
78000: IFTRUE 78016
78002: LD_INT 8
78004: DOUBLE
78005: EQUAL
78006: IFTRUE 78016
78008: LD_INT 9
78010: DOUBLE
78011: EQUAL
78012: IFTRUE 78016
78014: GO 78062
78016: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78017: LD_ADDR_VAR 0 8
78021: PUSH
78022: LD_VAR 0 2
78026: PPUSH
78027: LD_INT 2
78029: PUSH
78030: LD_INT 30
78032: PUSH
78033: LD_INT 4
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 30
78042: PUSH
78043: LD_INT 5
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: LIST
78054: PPUSH
78055: CALL_OW 72
78059: ST_TO_ADDR
78060: GO 78063
78062: POP
// if not tmp then
78063: LD_VAR 0 8
78067: NOT
78068: IFFALSE 78072
// exit ;
78070: GO 78534
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78072: LD_VAR 0 4
78076: PUSH
78077: LD_INT 1
78079: PUSH
78080: LD_INT 15
78082: PUSH
78083: EMPTY
78084: LIST
78085: LIST
78086: IN
78087: IFFALSE 78101
78089: PUSH
78090: LD_EXP 32
78094: PUSH
78095: LD_VAR 0 1
78099: ARRAY
78100: AND
78101: IFFALSE 78257
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78103: LD_ADDR_VAR 0 9
78107: PUSH
78108: LD_EXP 32
78112: PUSH
78113: LD_VAR 0 1
78117: ARRAY
78118: PUSH
78119: LD_INT 1
78121: ARRAY
78122: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78123: LD_VAR 0 9
78127: PUSH
78128: LD_EXP 33
78132: PUSH
78133: LD_VAR 0 1
78137: ARRAY
78138: IN
78139: NOT
78140: IFFALSE 78255
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78142: LD_ADDR_EXP 33
78146: PUSH
78147: LD_EXP 33
78151: PPUSH
78152: LD_VAR 0 1
78156: PUSH
78157: LD_EXP 33
78161: PUSH
78162: LD_VAR 0 1
78166: ARRAY
78167: PUSH
78168: LD_INT 1
78170: PLUS
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PPUSH
78176: LD_VAR 0 9
78180: PPUSH
78181: CALL 16255 0 3
78185: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78186: LD_ADDR_EXP 32
78190: PUSH
78191: LD_EXP 32
78195: PPUSH
78196: LD_VAR 0 1
78200: PPUSH
78201: LD_EXP 32
78205: PUSH
78206: LD_VAR 0 1
78210: ARRAY
78211: PUSH
78212: LD_VAR 0 9
78216: DIFF
78217: PPUSH
78218: CALL_OW 1
78222: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78223: LD_VAR 0 3
78227: PPUSH
78228: LD_EXP 33
78232: PUSH
78233: LD_VAR 0 1
78237: ARRAY
78238: PUSH
78239: LD_EXP 33
78243: PUSH
78244: LD_VAR 0 1
78248: ARRAY
78249: ARRAY
78250: PPUSH
78251: CALL_OW 120
// end ; exit ;
78255: GO 78534
// end ; if tmp > 1 then
78257: LD_VAR 0 8
78261: PUSH
78262: LD_INT 1
78264: GREATER
78265: IFFALSE 78369
// for i = 2 to tmp do
78267: LD_ADDR_VAR 0 6
78271: PUSH
78272: DOUBLE
78273: LD_INT 2
78275: DEC
78276: ST_TO_ADDR
78277: LD_VAR 0 8
78281: PUSH
78282: FOR_TO
78283: IFFALSE 78367
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78285: LD_VAR 0 8
78289: PUSH
78290: LD_VAR 0 6
78294: ARRAY
78295: PPUSH
78296: CALL_OW 461
78300: PUSH
78301: LD_INT 6
78303: EQUAL
78304: IFFALSE 78365
// begin x := tmp [ i ] ;
78306: LD_ADDR_VAR 0 9
78310: PUSH
78311: LD_VAR 0 8
78315: PUSH
78316: LD_VAR 0 6
78320: ARRAY
78321: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78322: LD_ADDR_VAR 0 8
78326: PUSH
78327: LD_VAR 0 8
78331: PPUSH
78332: LD_VAR 0 6
78336: PPUSH
78337: CALL_OW 3
78341: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78342: LD_ADDR_VAR 0 8
78346: PUSH
78347: LD_VAR 0 8
78351: PPUSH
78352: LD_INT 1
78354: PPUSH
78355: LD_VAR 0 9
78359: PPUSH
78360: CALL_OW 2
78364: ST_TO_ADDR
// end ;
78365: GO 78282
78367: POP
78368: POP
// for i in tmp do
78369: LD_ADDR_VAR 0 6
78373: PUSH
78374: LD_VAR 0 8
78378: PUSH
78379: FOR_IN
78380: IFFALSE 78407
// begin if IsNotFull ( i ) then
78382: LD_VAR 0 6
78386: PPUSH
78387: CALL 13453 0 1
78391: IFFALSE 78405
// begin j := i ;
78393: LD_ADDR_VAR 0 7
78397: PUSH
78398: LD_VAR 0 6
78402: ST_TO_ADDR
// break ;
78403: GO 78407
// end ; end ;
78405: GO 78379
78407: POP
78408: POP
// if j then
78409: LD_VAR 0 7
78413: IFFALSE 78431
// ComEnterUnit ( unit , j ) else
78415: LD_VAR 0 3
78419: PPUSH
78420: LD_VAR 0 7
78424: PPUSH
78425: CALL_OW 120
78429: GO 78534
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78431: LD_ADDR_VAR 0 10
78435: PUSH
78436: LD_VAR 0 2
78440: PPUSH
78441: LD_INT 2
78443: PUSH
78444: LD_INT 30
78446: PUSH
78447: LD_INT 0
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 30
78456: PUSH
78457: LD_INT 1
78459: PUSH
78460: EMPTY
78461: LIST
78462: LIST
78463: PUSH
78464: EMPTY
78465: LIST
78466: LIST
78467: LIST
78468: PPUSH
78469: CALL_OW 72
78473: ST_TO_ADDR
// if depot then
78474: LD_VAR 0 10
78478: IFFALSE 78534
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78480: LD_ADDR_VAR 0 10
78484: PUSH
78485: LD_VAR 0 10
78489: PPUSH
78490: LD_VAR 0 3
78494: PPUSH
78495: CALL_OW 74
78499: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78500: LD_VAR 0 3
78504: PPUSH
78505: LD_VAR 0 10
78509: PPUSH
78510: CALL_OW 296
78514: PUSH
78515: LD_INT 10
78517: GREATER
78518: IFFALSE 78534
// ComStandNearbyBuilding ( unit , depot ) ;
78520: LD_VAR 0 3
78524: PPUSH
78525: LD_VAR 0 10
78529: PPUSH
78530: CALL 12831 0 2
// end ; end ; end ;
78534: LD_VAR 0 5
78538: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78539: LD_INT 0
78541: PPUSH
78542: PPUSH
78543: PPUSH
78544: PPUSH
// if not mc_bases then
78545: LD_EXP 23
78549: NOT
78550: IFFALSE 78554
// exit ;
78552: GO 78805
// for i = 1 to mc_bases do
78554: LD_ADDR_VAR 0 2
78558: PUSH
78559: DOUBLE
78560: LD_INT 1
78562: DEC
78563: ST_TO_ADDR
78564: LD_EXP 23
78568: PUSH
78569: FOR_TO
78570: IFFALSE 78803
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78572: LD_ADDR_VAR 0 4
78576: PUSH
78577: LD_EXP 23
78581: PUSH
78582: LD_VAR 0 2
78586: ARRAY
78587: PPUSH
78588: LD_INT 21
78590: PUSH
78591: LD_INT 1
78593: PUSH
78594: EMPTY
78595: LIST
78596: LIST
78597: PPUSH
78598: CALL_OW 72
78602: PUSH
78603: LD_EXP 52
78607: PUSH
78608: LD_VAR 0 2
78612: ARRAY
78613: UNION
78614: ST_TO_ADDR
// if not tmp then
78615: LD_VAR 0 4
78619: NOT
78620: IFFALSE 78624
// continue ;
78622: GO 78569
// for j in tmp do
78624: LD_ADDR_VAR 0 3
78628: PUSH
78629: LD_VAR 0 4
78633: PUSH
78634: FOR_IN
78635: IFFALSE 78799
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78637: LD_VAR 0 3
78641: PPUSH
78642: CALL_OW 110
78646: NOT
78647: IFFALSE 78661
78649: PUSH
78650: LD_VAR 0 3
78654: PPUSH
78655: CALL_OW 314
78659: NOT
78660: AND
78661: IFFALSE 78675
78663: PUSH
78664: LD_VAR 0 3
78668: PPUSH
78669: CALL_OW 311
78673: NOT
78674: AND
78675: IFFALSE 78689
78677: PUSH
78678: LD_VAR 0 3
78682: PPUSH
78683: CALL_OW 310
78687: NOT
78688: AND
78689: IFFALSE 78714
78691: PUSH
78692: LD_VAR 0 3
78696: PUSH
78697: LD_EXP 26
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: PUSH
78708: LD_INT 1
78710: ARRAY
78711: IN
78712: NOT
78713: AND
78714: IFFALSE 78739
78716: PUSH
78717: LD_VAR 0 3
78721: PUSH
78722: LD_EXP 26
78726: PUSH
78727: LD_VAR 0 2
78731: ARRAY
78732: PUSH
78733: LD_INT 2
78735: ARRAY
78736: IN
78737: NOT
78738: AND
78739: IFFALSE 78760
78741: PUSH
78742: LD_VAR 0 3
78746: PUSH
78747: LD_EXP 35
78751: PUSH
78752: LD_VAR 0 2
78756: ARRAY
78757: IN
78758: NOT
78759: AND
78760: IFFALSE 78797
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78762: LD_VAR 0 2
78766: PPUSH
78767: LD_EXP 23
78771: PUSH
78772: LD_VAR 0 2
78776: ARRAY
78777: PPUSH
78778: LD_VAR 0 3
78782: PPUSH
78783: LD_VAR 0 3
78787: PPUSH
78788: CALL_OW 257
78792: PPUSH
78793: CALL 77591 0 4
// end ;
78797: GO 78634
78799: POP
78800: POP
// end ;
78801: GO 78569
78803: POP
78804: POP
// end ;
78805: LD_VAR 0 1
78809: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
78810: LD_INT 0
78812: PPUSH
78813: PPUSH
78814: PPUSH
78815: PPUSH
78816: PPUSH
78817: PPUSH
// if not mc_bases [ base ] then
78818: LD_EXP 23
78822: PUSH
78823: LD_VAR 0 1
78827: ARRAY
78828: NOT
78829: IFFALSE 78833
// exit ;
78831: GO 79034
// tmp := [ ] ;
78833: LD_ADDR_VAR 0 6
78837: PUSH
78838: EMPTY
78839: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78840: LD_ADDR_VAR 0 7
78844: PUSH
78845: LD_VAR 0 3
78849: PPUSH
78850: LD_INT 0
78852: PPUSH
78853: CALL_OW 517
78857: ST_TO_ADDR
// if not list then
78858: LD_VAR 0 7
78862: NOT
78863: IFFALSE 78867
// exit ;
78865: GO 79034
// c := Count ( list [ 1 ] ) ;
78867: LD_ADDR_VAR 0 9
78871: PUSH
78872: LD_VAR 0 7
78876: PUSH
78877: LD_INT 1
78879: ARRAY
78880: PPUSH
78881: CALL 13371 0 1
78885: ST_TO_ADDR
// if amount > c then
78886: LD_VAR 0 2
78890: PUSH
78891: LD_VAR 0 9
78895: GREATER
78896: IFFALSE 78908
// amount := c ;
78898: LD_ADDR_VAR 0 2
78902: PUSH
78903: LD_VAR 0 9
78907: ST_TO_ADDR
// for i := 1 to amount do
78908: LD_ADDR_VAR 0 5
78912: PUSH
78913: DOUBLE
78914: LD_INT 1
78916: DEC
78917: ST_TO_ADDR
78918: LD_VAR 0 2
78922: PUSH
78923: FOR_TO
78924: IFFALSE 78982
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
78926: LD_ADDR_VAR 0 6
78930: PUSH
78931: LD_VAR 0 6
78935: PPUSH
78936: LD_VAR 0 5
78940: PPUSH
78941: LD_VAR 0 7
78945: PUSH
78946: LD_INT 1
78948: ARRAY
78949: PUSH
78950: LD_VAR 0 5
78954: ARRAY
78955: PUSH
78956: LD_VAR 0 7
78960: PUSH
78961: LD_INT 2
78963: ARRAY
78964: PUSH
78965: LD_VAR 0 5
78969: ARRAY
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PPUSH
78975: CALL_OW 1
78979: ST_TO_ADDR
78980: GO 78923
78982: POP
78983: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78984: LD_ADDR_EXP 36
78988: PUSH
78989: LD_EXP 36
78993: PPUSH
78994: LD_VAR 0 1
78998: PPUSH
78999: LD_VAR 0 6
79003: PPUSH
79004: CALL_OW 1
79008: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79009: LD_ADDR_EXP 38
79013: PUSH
79014: LD_EXP 38
79018: PPUSH
79019: LD_VAR 0 1
79023: PPUSH
79024: LD_VAR 0 3
79028: PPUSH
79029: CALL_OW 1
79033: ST_TO_ADDR
// end ;
79034: LD_VAR 0 4
79038: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79039: LD_INT 0
79041: PPUSH
// if not mc_bases [ base ] then
79042: LD_EXP 23
79046: PUSH
79047: LD_VAR 0 1
79051: ARRAY
79052: NOT
79053: IFFALSE 79057
// exit ;
79055: GO 79082
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79057: LD_ADDR_EXP 28
79061: PUSH
79062: LD_EXP 28
79066: PPUSH
79067: LD_VAR 0 1
79071: PPUSH
79072: LD_VAR 0 2
79076: PPUSH
79077: CALL_OW 1
79081: ST_TO_ADDR
// end ;
79082: LD_VAR 0 3
79086: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79087: LD_INT 0
79089: PPUSH
// if not mc_bases [ base ] then
79090: LD_EXP 23
79094: PUSH
79095: LD_VAR 0 1
79099: ARRAY
79100: NOT
79101: IFFALSE 79105
// exit ;
79103: GO 79142
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79105: LD_ADDR_EXP 28
79109: PUSH
79110: LD_EXP 28
79114: PPUSH
79115: LD_VAR 0 1
79119: PPUSH
79120: LD_EXP 28
79124: PUSH
79125: LD_VAR 0 1
79129: ARRAY
79130: PUSH
79131: LD_VAR 0 2
79135: UNION
79136: PPUSH
79137: CALL_OW 1
79141: ST_TO_ADDR
// end ;
79142: LD_VAR 0 3
79146: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79147: LD_INT 0
79149: PPUSH
// if not mc_bases [ base ] then
79150: LD_EXP 23
79154: PUSH
79155: LD_VAR 0 1
79159: ARRAY
79160: NOT
79161: IFFALSE 79165
// exit ;
79163: GO 79190
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79165: LD_ADDR_EXP 44
79169: PUSH
79170: LD_EXP 44
79174: PPUSH
79175: LD_VAR 0 1
79179: PPUSH
79180: LD_VAR 0 2
79184: PPUSH
79185: CALL_OW 1
79189: ST_TO_ADDR
// end ;
79190: LD_VAR 0 3
79194: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79195: LD_INT 0
79197: PPUSH
// if not mc_bases [ base ] then
79198: LD_EXP 23
79202: PUSH
79203: LD_VAR 0 1
79207: ARRAY
79208: NOT
79209: IFFALSE 79213
// exit ;
79211: GO 79250
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79213: LD_ADDR_EXP 44
79217: PUSH
79218: LD_EXP 44
79222: PPUSH
79223: LD_VAR 0 1
79227: PPUSH
79228: LD_EXP 44
79232: PUSH
79233: LD_VAR 0 1
79237: ARRAY
79238: PUSH
79239: LD_VAR 0 2
79243: ADD
79244: PPUSH
79245: CALL_OW 1
79249: ST_TO_ADDR
// end ;
79250: LD_VAR 0 3
79254: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79255: LD_INT 0
79257: PPUSH
// if not mc_bases [ base ] then
79258: LD_EXP 23
79262: PUSH
79263: LD_VAR 0 1
79267: ARRAY
79268: NOT
79269: IFFALSE 79273
// exit ;
79271: GO 79327
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79273: LD_ADDR_EXP 45
79277: PUSH
79278: LD_EXP 45
79282: PPUSH
79283: LD_VAR 0 1
79287: PPUSH
79288: LD_VAR 0 2
79292: PPUSH
79293: CALL_OW 1
79297: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79298: LD_ADDR_EXP 34
79302: PUSH
79303: LD_EXP 34
79307: PPUSH
79308: LD_VAR 0 1
79312: PPUSH
79313: LD_VAR 0 2
79317: PUSH
79318: LD_INT 0
79320: PLUS
79321: PPUSH
79322: CALL_OW 1
79326: ST_TO_ADDR
// end ;
79327: LD_VAR 0 3
79331: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79332: LD_INT 0
79334: PPUSH
// if not mc_bases [ base ] then
79335: LD_EXP 23
79339: PUSH
79340: LD_VAR 0 1
79344: ARRAY
79345: NOT
79346: IFFALSE 79350
// exit ;
79348: GO 79375
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79350: LD_ADDR_EXP 34
79354: PUSH
79355: LD_EXP 34
79359: PPUSH
79360: LD_VAR 0 1
79364: PPUSH
79365: LD_VAR 0 2
79369: PPUSH
79370: CALL_OW 1
79374: ST_TO_ADDR
// end ;
79375: LD_VAR 0 3
79379: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79380: LD_INT 0
79382: PPUSH
79383: PPUSH
79384: PPUSH
79385: PPUSH
// if not mc_bases [ base ] then
79386: LD_EXP 23
79390: PUSH
79391: LD_VAR 0 1
79395: ARRAY
79396: NOT
79397: IFFALSE 79401
// exit ;
79399: GO 79466
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79401: LD_ADDR_EXP 43
79405: PUSH
79406: LD_EXP 43
79410: PPUSH
79411: LD_VAR 0 1
79415: PUSH
79416: LD_EXP 43
79420: PUSH
79421: LD_VAR 0 1
79425: ARRAY
79426: PUSH
79427: LD_INT 1
79429: PLUS
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PPUSH
79435: LD_VAR 0 1
79439: PUSH
79440: LD_VAR 0 2
79444: PUSH
79445: LD_VAR 0 3
79449: PUSH
79450: LD_VAR 0 4
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: PPUSH
79461: CALL 16255 0 3
79465: ST_TO_ADDR
// end ;
79466: LD_VAR 0 5
79470: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79471: LD_INT 0
79473: PPUSH
// if not mc_bases [ base ] then
79474: LD_EXP 23
79478: PUSH
79479: LD_VAR 0 1
79483: ARRAY
79484: NOT
79485: IFFALSE 79489
// exit ;
79487: GO 79514
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79489: LD_ADDR_EXP 60
79493: PUSH
79494: LD_EXP 60
79498: PPUSH
79499: LD_VAR 0 1
79503: PPUSH
79504: LD_VAR 0 2
79508: PPUSH
79509: CALL_OW 1
79513: ST_TO_ADDR
// end ;
79514: LD_VAR 0 3
79518: RET
// export function MC_GetMinesField ( base ) ; begin
79519: LD_INT 0
79521: PPUSH
// result := mc_mines [ base ] ;
79522: LD_ADDR_VAR 0 2
79526: PUSH
79527: LD_EXP 36
79531: PUSH
79532: LD_VAR 0 1
79536: ARRAY
79537: ST_TO_ADDR
// end ;
79538: LD_VAR 0 2
79542: RET
// export function MC_GetProduceList ( base ) ; begin
79543: LD_INT 0
79545: PPUSH
// result := mc_produce [ base ] ;
79546: LD_ADDR_VAR 0 2
79550: PUSH
79551: LD_EXP 44
79555: PUSH
79556: LD_VAR 0 1
79560: ARRAY
79561: ST_TO_ADDR
// end ;
79562: LD_VAR 0 2
79566: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79567: LD_INT 0
79569: PPUSH
79570: PPUSH
// if not mc_bases then
79571: LD_EXP 23
79575: NOT
79576: IFFALSE 79580
// exit ;
79578: GO 79645
// if mc_bases [ base ] then
79580: LD_EXP 23
79584: PUSH
79585: LD_VAR 0 1
79589: ARRAY
79590: IFFALSE 79645
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79592: LD_ADDR_VAR 0 3
79596: PUSH
79597: LD_EXP 23
79601: PUSH
79602: LD_VAR 0 1
79606: ARRAY
79607: PPUSH
79608: LD_INT 30
79610: PUSH
79611: LD_VAR 0 2
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PPUSH
79620: CALL_OW 72
79624: ST_TO_ADDR
// if result then
79625: LD_VAR 0 3
79629: IFFALSE 79645
// result := result [ 1 ] ;
79631: LD_ADDR_VAR 0 3
79635: PUSH
79636: LD_VAR 0 3
79640: PUSH
79641: LD_INT 1
79643: ARRAY
79644: ST_TO_ADDR
// end ; end ;
79645: LD_VAR 0 3
79649: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79650: LD_INT 0
79652: PPUSH
79653: PPUSH
// if not mc_bases then
79654: LD_EXP 23
79658: NOT
79659: IFFALSE 79663
// exit ;
79661: GO 79708
// if mc_bases [ base ] then
79663: LD_EXP 23
79667: PUSH
79668: LD_VAR 0 1
79672: ARRAY
79673: IFFALSE 79708
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79675: LD_ADDR_VAR 0 3
79679: PUSH
79680: LD_EXP 23
79684: PUSH
79685: LD_VAR 0 1
79689: ARRAY
79690: PPUSH
79691: LD_INT 30
79693: PUSH
79694: LD_VAR 0 2
79698: PUSH
79699: EMPTY
79700: LIST
79701: LIST
79702: PPUSH
79703: CALL_OW 72
79707: ST_TO_ADDR
// end ;
79708: LD_VAR 0 3
79712: RET
// export function MC_SetTame ( base , area ) ; begin
79713: LD_INT 0
79715: PPUSH
// if not mc_bases or not base then
79716: LD_EXP 23
79720: NOT
79721: IFTRUE 79730
79723: PUSH
79724: LD_VAR 0 1
79728: NOT
79729: OR
79730: IFFALSE 79734
// exit ;
79732: GO 79759
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79734: LD_ADDR_EXP 51
79738: PUSH
79739: LD_EXP 51
79743: PPUSH
79744: LD_VAR 0 1
79748: PPUSH
79749: LD_VAR 0 2
79753: PPUSH
79754: CALL_OW 1
79758: ST_TO_ADDR
// end ;
79759: LD_VAR 0 3
79763: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79764: LD_INT 0
79766: PPUSH
79767: PPUSH
// if not mc_bases or not base then
79768: LD_EXP 23
79772: NOT
79773: IFTRUE 79782
79775: PUSH
79776: LD_VAR 0 1
79780: NOT
79781: OR
79782: IFFALSE 79786
// exit ;
79784: GO 79888
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79786: LD_ADDR_VAR 0 4
79790: PUSH
79791: LD_EXP 23
79795: PUSH
79796: LD_VAR 0 1
79800: ARRAY
79801: PPUSH
79802: LD_INT 30
79804: PUSH
79805: LD_VAR 0 2
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PPUSH
79814: CALL_OW 72
79818: ST_TO_ADDR
// if not tmp then
79819: LD_VAR 0 4
79823: NOT
79824: IFFALSE 79828
// exit ;
79826: GO 79888
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79828: LD_ADDR_EXP 55
79832: PUSH
79833: LD_EXP 55
79837: PPUSH
79838: LD_VAR 0 1
79842: PPUSH
79843: LD_EXP 55
79847: PUSH
79848: LD_VAR 0 1
79852: ARRAY
79853: PPUSH
79854: LD_EXP 55
79858: PUSH
79859: LD_VAR 0 1
79863: ARRAY
79864: PUSH
79865: LD_INT 1
79867: PLUS
79868: PPUSH
79869: LD_VAR 0 4
79873: PUSH
79874: LD_INT 1
79876: ARRAY
79877: PPUSH
79878: CALL_OW 2
79882: PPUSH
79883: CALL_OW 1
79887: ST_TO_ADDR
// end ;
79888: LD_VAR 0 3
79892: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79893: LD_INT 0
79895: PPUSH
79896: PPUSH
// if not mc_bases or not base or not kinds then
79897: LD_EXP 23
79901: NOT
79902: IFTRUE 79911
79904: PUSH
79905: LD_VAR 0 1
79909: NOT
79910: OR
79911: IFTRUE 79920
79913: PUSH
79914: LD_VAR 0 2
79918: NOT
79919: OR
79920: IFFALSE 79924
// exit ;
79922: GO 79985
// for i in kinds do
79924: LD_ADDR_VAR 0 4
79928: PUSH
79929: LD_VAR 0 2
79933: PUSH
79934: FOR_IN
79935: IFFALSE 79983
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79937: LD_ADDR_EXP 57
79941: PUSH
79942: LD_EXP 57
79946: PPUSH
79947: LD_VAR 0 1
79951: PUSH
79952: LD_EXP 57
79956: PUSH
79957: LD_VAR 0 1
79961: ARRAY
79962: PUSH
79963: LD_INT 1
79965: PLUS
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PPUSH
79971: LD_VAR 0 4
79975: PPUSH
79976: CALL 16255 0 3
79980: ST_TO_ADDR
79981: GO 79934
79983: POP
79984: POP
// end ;
79985: LD_VAR 0 3
79989: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79990: LD_INT 0
79992: PPUSH
// if not mc_bases or not base or not areas then
79993: LD_EXP 23
79997: NOT
79998: IFTRUE 80007
80000: PUSH
80001: LD_VAR 0 1
80005: NOT
80006: OR
80007: IFTRUE 80016
80009: PUSH
80010: LD_VAR 0 2
80014: NOT
80015: OR
80016: IFFALSE 80020
// exit ;
80018: GO 80045
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80020: LD_ADDR_EXP 41
80024: PUSH
80025: LD_EXP 41
80029: PPUSH
80030: LD_VAR 0 1
80034: PPUSH
80035: LD_VAR 0 2
80039: PPUSH
80040: CALL_OW 1
80044: ST_TO_ADDR
// end ;
80045: LD_VAR 0 3
80049: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80050: LD_INT 0
80052: PPUSH
// if not mc_bases or not base or not teleports_exit then
80053: LD_EXP 23
80057: NOT
80058: IFTRUE 80067
80060: PUSH
80061: LD_VAR 0 1
80065: NOT
80066: OR
80067: IFTRUE 80076
80069: PUSH
80070: LD_VAR 0 2
80074: NOT
80075: OR
80076: IFFALSE 80080
// exit ;
80078: GO 80105
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80080: LD_ADDR_EXP 58
80084: PUSH
80085: LD_EXP 58
80089: PPUSH
80090: LD_VAR 0 1
80094: PPUSH
80095: LD_VAR 0 2
80099: PPUSH
80100: CALL_OW 1
80104: ST_TO_ADDR
// end ;
80105: LD_VAR 0 3
80109: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80110: LD_INT 0
80112: PPUSH
80113: PPUSH
80114: PPUSH
// if not mc_bases or not base or not ext_list then
80115: LD_EXP 23
80119: NOT
80120: IFTRUE 80129
80122: PUSH
80123: LD_VAR 0 1
80127: NOT
80128: OR
80129: IFTRUE 80138
80131: PUSH
80132: LD_VAR 0 5
80136: NOT
80137: OR
80138: IFFALSE 80142
// exit ;
80140: GO 80315
// tmp := GetFacExtXYD ( x , y , d ) ;
80142: LD_ADDR_VAR 0 8
80146: PUSH
80147: LD_VAR 0 2
80151: PPUSH
80152: LD_VAR 0 3
80156: PPUSH
80157: LD_VAR 0 4
80161: PPUSH
80162: CALL 46913 0 3
80166: ST_TO_ADDR
// if not tmp then
80167: LD_VAR 0 8
80171: NOT
80172: IFFALSE 80176
// exit ;
80174: GO 80315
// for i in tmp do
80176: LD_ADDR_VAR 0 7
80180: PUSH
80181: LD_VAR 0 8
80185: PUSH
80186: FOR_IN
80187: IFFALSE 80313
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80189: LD_ADDR_EXP 28
80193: PUSH
80194: LD_EXP 28
80198: PPUSH
80199: LD_VAR 0 1
80203: PPUSH
80204: LD_EXP 28
80208: PUSH
80209: LD_VAR 0 1
80213: ARRAY
80214: PPUSH
80215: LD_EXP 28
80219: PUSH
80220: LD_VAR 0 1
80224: ARRAY
80225: PUSH
80226: LD_INT 1
80228: PLUS
80229: PPUSH
80230: LD_VAR 0 5
80234: PUSH
80235: LD_INT 1
80237: ARRAY
80238: PUSH
80239: LD_VAR 0 7
80243: PUSH
80244: LD_INT 1
80246: ARRAY
80247: PUSH
80248: LD_VAR 0 7
80252: PUSH
80253: LD_INT 2
80255: ARRAY
80256: PUSH
80257: LD_VAR 0 7
80261: PUSH
80262: LD_INT 3
80264: ARRAY
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: PPUSH
80272: CALL_OW 2
80276: PPUSH
80277: CALL_OW 1
80281: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80282: LD_ADDR_VAR 0 5
80286: PUSH
80287: LD_VAR 0 5
80291: PPUSH
80292: LD_INT 1
80294: PPUSH
80295: CALL_OW 3
80299: ST_TO_ADDR
// if not ext_list then
80300: LD_VAR 0 5
80304: NOT
80305: IFFALSE 80311
// exit ;
80307: POP
80308: POP
80309: GO 80315
// end ;
80311: GO 80186
80313: POP
80314: POP
// end ;
80315: LD_VAR 0 6
80319: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80320: LD_INT 0
80322: PPUSH
// if not mc_bases or not base or not weapon_list then
80323: LD_EXP 23
80327: NOT
80328: IFTRUE 80337
80330: PUSH
80331: LD_VAR 0 1
80335: NOT
80336: OR
80337: IFTRUE 80346
80339: PUSH
80340: LD_VAR 0 2
80344: NOT
80345: OR
80346: IFFALSE 80350
// exit ;
80348: GO 80375
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80350: LD_ADDR_EXP 62
80354: PUSH
80355: LD_EXP 62
80359: PPUSH
80360: LD_VAR 0 1
80364: PPUSH
80365: LD_VAR 0 2
80369: PPUSH
80370: CALL_OW 1
80374: ST_TO_ADDR
// end ;
80375: LD_VAR 0 3
80379: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80380: LD_INT 0
80382: PPUSH
// if not mc_bases or not base or not tech_list then
80383: LD_EXP 23
80387: NOT
80388: IFTRUE 80397
80390: PUSH
80391: LD_VAR 0 1
80395: NOT
80396: OR
80397: IFTRUE 80406
80399: PUSH
80400: LD_VAR 0 2
80404: NOT
80405: OR
80406: IFFALSE 80410
// exit ;
80408: GO 80435
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80410: LD_ADDR_EXP 50
80414: PUSH
80415: LD_EXP 50
80419: PPUSH
80420: LD_VAR 0 1
80424: PPUSH
80425: LD_VAR 0 2
80429: PPUSH
80430: CALL_OW 1
80434: ST_TO_ADDR
// end ;
80435: LD_VAR 0 3
80439: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80440: LD_INT 0
80442: PPUSH
// if not mc_bases or not parking_area or not base then
80443: LD_EXP 23
80447: NOT
80448: IFTRUE 80457
80450: PUSH
80451: LD_VAR 0 2
80455: NOT
80456: OR
80457: IFTRUE 80466
80459: PUSH
80460: LD_VAR 0 1
80464: NOT
80465: OR
80466: IFFALSE 80470
// exit ;
80468: GO 80495
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80470: LD_ADDR_EXP 47
80474: PUSH
80475: LD_EXP 47
80479: PPUSH
80480: LD_VAR 0 1
80484: PPUSH
80485: LD_VAR 0 2
80489: PPUSH
80490: CALL_OW 1
80494: ST_TO_ADDR
// end ;
80495: LD_VAR 0 3
80499: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80500: LD_INT 0
80502: PPUSH
// if not mc_bases or not base or not scan_area then
80503: LD_EXP 23
80507: NOT
80508: IFTRUE 80517
80510: PUSH
80511: LD_VAR 0 1
80515: NOT
80516: OR
80517: IFTRUE 80526
80519: PUSH
80520: LD_VAR 0 2
80524: NOT
80525: OR
80526: IFFALSE 80530
// exit ;
80528: GO 80555
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80530: LD_ADDR_EXP 48
80534: PUSH
80535: LD_EXP 48
80539: PPUSH
80540: LD_VAR 0 1
80544: PPUSH
80545: LD_VAR 0 2
80549: PPUSH
80550: CALL_OW 1
80554: ST_TO_ADDR
// end ;
80555: LD_VAR 0 3
80559: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80560: LD_INT 0
80562: PPUSH
80563: PPUSH
// if not mc_bases or not base then
80564: LD_EXP 23
80568: NOT
80569: IFTRUE 80578
80571: PUSH
80572: LD_VAR 0 1
80576: NOT
80577: OR
80578: IFFALSE 80582
// exit ;
80580: GO 80646
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80582: LD_ADDR_VAR 0 3
80586: PUSH
80587: LD_INT 1
80589: PUSH
80590: LD_INT 2
80592: PUSH
80593: LD_INT 3
80595: PUSH
80596: LD_INT 4
80598: PUSH
80599: LD_INT 11
80601: PUSH
80602: EMPTY
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80609: LD_ADDR_EXP 50
80613: PUSH
80614: LD_EXP 50
80618: PPUSH
80619: LD_VAR 0 1
80623: PPUSH
80624: LD_EXP 50
80628: PUSH
80629: LD_VAR 0 1
80633: ARRAY
80634: PUSH
80635: LD_VAR 0 3
80639: DIFF
80640: PPUSH
80641: CALL_OW 1
80645: ST_TO_ADDR
// end ;
80646: LD_VAR 0 2
80650: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80651: LD_INT 0
80653: PPUSH
// result := mc_vehicles [ base ] ;
80654: LD_ADDR_VAR 0 3
80658: PUSH
80659: LD_EXP 42
80663: PUSH
80664: LD_VAR 0 1
80668: ARRAY
80669: ST_TO_ADDR
// if onlyCombat then
80670: LD_VAR 0 2
80674: IFFALSE 80846
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80676: LD_ADDR_VAR 0 3
80680: PUSH
80681: LD_VAR 0 3
80685: PUSH
80686: LD_VAR 0 3
80690: PPUSH
80691: LD_INT 2
80693: PUSH
80694: LD_INT 34
80696: PUSH
80697: LD_INT 12
80699: PUSH
80700: EMPTY
80701: LIST
80702: LIST
80703: PUSH
80704: LD_INT 34
80706: PUSH
80707: LD_INT 51
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PUSH
80714: LD_INT 34
80716: PUSH
80717: LD_INT 89
80719: PUSH
80720: EMPTY
80721: LIST
80722: LIST
80723: PUSH
80724: LD_INT 34
80726: PUSH
80727: LD_INT 32
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: LD_INT 34
80736: PUSH
80737: LD_INT 13
80739: PUSH
80740: EMPTY
80741: LIST
80742: LIST
80743: PUSH
80744: LD_INT 34
80746: PUSH
80747: LD_INT 52
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PUSH
80754: LD_INT 34
80756: PUSH
80757: LD_INT 88
80759: PUSH
80760: EMPTY
80761: LIST
80762: LIST
80763: PUSH
80764: LD_INT 34
80766: PUSH
80767: LD_INT 14
80769: PUSH
80770: EMPTY
80771: LIST
80772: LIST
80773: PUSH
80774: LD_INT 34
80776: PUSH
80777: LD_INT 53
80779: PUSH
80780: EMPTY
80781: LIST
80782: LIST
80783: PUSH
80784: LD_INT 34
80786: PUSH
80787: LD_INT 98
80789: PUSH
80790: EMPTY
80791: LIST
80792: LIST
80793: PUSH
80794: LD_INT 34
80796: PUSH
80797: LD_INT 31
80799: PUSH
80800: EMPTY
80801: LIST
80802: LIST
80803: PUSH
80804: LD_INT 34
80806: PUSH
80807: LD_INT 48
80809: PUSH
80810: EMPTY
80811: LIST
80812: LIST
80813: PUSH
80814: LD_INT 34
80816: PUSH
80817: LD_INT 8
80819: PUSH
80820: EMPTY
80821: LIST
80822: LIST
80823: PUSH
80824: EMPTY
80825: LIST
80826: LIST
80827: LIST
80828: LIST
80829: LIST
80830: LIST
80831: LIST
80832: LIST
80833: LIST
80834: LIST
80835: LIST
80836: LIST
80837: LIST
80838: LIST
80839: PPUSH
80840: CALL_OW 72
80844: DIFF
80845: ST_TO_ADDR
// end ; end_of_file
80846: LD_VAR 0 3
80850: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80851: LD_INT 0
80853: PPUSH
80854: PPUSH
80855: PPUSH
// if not mc_bases or not skirmish then
80856: LD_EXP 23
80860: NOT
80861: IFTRUE 80870
80863: PUSH
80864: LD_EXP 21
80868: NOT
80869: OR
80870: IFFALSE 80874
// exit ;
80872: GO 81039
// for i = 1 to mc_bases do
80874: LD_ADDR_VAR 0 4
80878: PUSH
80879: DOUBLE
80880: LD_INT 1
80882: DEC
80883: ST_TO_ADDR
80884: LD_EXP 23
80888: PUSH
80889: FOR_TO
80890: IFFALSE 81037
// begin if sci in mc_bases [ i ] then
80892: LD_VAR 0 2
80896: PUSH
80897: LD_EXP 23
80901: PUSH
80902: LD_VAR 0 4
80906: ARRAY
80907: IN
80908: IFFALSE 81035
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80910: LD_ADDR_EXP 52
80914: PUSH
80915: LD_EXP 52
80919: PPUSH
80920: LD_VAR 0 4
80924: PUSH
80925: LD_EXP 52
80929: PUSH
80930: LD_VAR 0 4
80934: ARRAY
80935: PUSH
80936: LD_INT 1
80938: PLUS
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PPUSH
80944: LD_VAR 0 1
80948: PPUSH
80949: CALL 16255 0 3
80953: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80954: LD_ADDR_VAR 0 5
80958: PUSH
80959: LD_EXP 23
80963: PUSH
80964: LD_VAR 0 4
80968: ARRAY
80969: PPUSH
80970: LD_INT 2
80972: PUSH
80973: LD_INT 30
80975: PUSH
80976: LD_INT 0
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 30
80985: PUSH
80986: LD_INT 1
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: EMPTY
80994: LIST
80995: LIST
80996: LIST
80997: PPUSH
80998: CALL_OW 72
81002: PPUSH
81003: LD_VAR 0 1
81007: PPUSH
81008: CALL_OW 74
81012: ST_TO_ADDR
// if tmp then
81013: LD_VAR 0 5
81017: IFFALSE 81033
// ComStandNearbyBuilding ( ape , tmp ) ;
81019: LD_VAR 0 1
81023: PPUSH
81024: LD_VAR 0 5
81028: PPUSH
81029: CALL 12831 0 2
// break ;
81033: GO 81037
// end ; end ;
81035: GO 80889
81037: POP
81038: POP
// end ;
81039: LD_VAR 0 3
81043: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81044: LD_INT 0
81046: PPUSH
81047: PPUSH
81048: PPUSH
// if not mc_bases or not skirmish then
81049: LD_EXP 23
81053: NOT
81054: IFTRUE 81063
81056: PUSH
81057: LD_EXP 21
81061: NOT
81062: OR
81063: IFFALSE 81067
// exit ;
81065: GO 81156
// for i = 1 to mc_bases do
81067: LD_ADDR_VAR 0 4
81071: PUSH
81072: DOUBLE
81073: LD_INT 1
81075: DEC
81076: ST_TO_ADDR
81077: LD_EXP 23
81081: PUSH
81082: FOR_TO
81083: IFFALSE 81154
// begin if building in mc_busy_turret_list [ i ] then
81085: LD_VAR 0 1
81089: PUSH
81090: LD_EXP 33
81094: PUSH
81095: LD_VAR 0 4
81099: ARRAY
81100: IN
81101: IFFALSE 81152
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81103: LD_ADDR_VAR 0 5
81107: PUSH
81108: LD_EXP 33
81112: PUSH
81113: LD_VAR 0 4
81117: ARRAY
81118: PUSH
81119: LD_VAR 0 1
81123: DIFF
81124: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81125: LD_ADDR_EXP 33
81129: PUSH
81130: LD_EXP 33
81134: PPUSH
81135: LD_VAR 0 4
81139: PPUSH
81140: LD_VAR 0 5
81144: PPUSH
81145: CALL_OW 1
81149: ST_TO_ADDR
// break ;
81150: GO 81154
// end ; end ;
81152: GO 81082
81154: POP
81155: POP
// end ;
81156: LD_VAR 0 3
81160: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81161: LD_INT 0
81163: PPUSH
81164: PPUSH
81165: PPUSH
// if not mc_bases or not skirmish then
81166: LD_EXP 23
81170: NOT
81171: IFTRUE 81180
81173: PUSH
81174: LD_EXP 21
81178: NOT
81179: OR
81180: IFFALSE 81184
// exit ;
81182: GO 81383
// for i = 1 to mc_bases do
81184: LD_ADDR_VAR 0 5
81188: PUSH
81189: DOUBLE
81190: LD_INT 1
81192: DEC
81193: ST_TO_ADDR
81194: LD_EXP 23
81198: PUSH
81199: FOR_TO
81200: IFFALSE 81381
// if building in mc_bases [ i ] then
81202: LD_VAR 0 1
81206: PUSH
81207: LD_EXP 23
81211: PUSH
81212: LD_VAR 0 5
81216: ARRAY
81217: IN
81218: IFFALSE 81379
// begin tmp := mc_bases [ i ] diff building ;
81220: LD_ADDR_VAR 0 6
81224: PUSH
81225: LD_EXP 23
81229: PUSH
81230: LD_VAR 0 5
81234: ARRAY
81235: PUSH
81236: LD_VAR 0 1
81240: DIFF
81241: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81242: LD_ADDR_EXP 23
81246: PUSH
81247: LD_EXP 23
81251: PPUSH
81252: LD_VAR 0 5
81256: PPUSH
81257: LD_VAR 0 6
81261: PPUSH
81262: CALL_OW 1
81266: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81267: LD_VAR 0 1
81271: PUSH
81272: LD_EXP 31
81276: PUSH
81277: LD_VAR 0 5
81281: ARRAY
81282: IN
81283: IFFALSE 81322
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81285: LD_ADDR_EXP 31
81289: PUSH
81290: LD_EXP 31
81294: PPUSH
81295: LD_VAR 0 5
81299: PPUSH
81300: LD_EXP 31
81304: PUSH
81305: LD_VAR 0 5
81309: ARRAY
81310: PUSH
81311: LD_VAR 0 1
81315: DIFF
81316: PPUSH
81317: CALL_OW 1
81321: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81322: LD_VAR 0 1
81326: PUSH
81327: LD_EXP 32
81331: PUSH
81332: LD_VAR 0 5
81336: ARRAY
81337: IN
81338: IFFALSE 81377
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81340: LD_ADDR_EXP 32
81344: PUSH
81345: LD_EXP 32
81349: PPUSH
81350: LD_VAR 0 5
81354: PPUSH
81355: LD_EXP 32
81359: PUSH
81360: LD_VAR 0 5
81364: ARRAY
81365: PUSH
81366: LD_VAR 0 1
81370: DIFF
81371: PPUSH
81372: CALL_OW 1
81376: ST_TO_ADDR
// break ;
81377: GO 81381
// end ;
81379: GO 81199
81381: POP
81382: POP
// end ;
81383: LD_VAR 0 4
81387: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81388: LD_INT 0
81390: PPUSH
81391: PPUSH
81392: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81393: LD_EXP 23
81397: NOT
81398: IFTRUE 81407
81400: PUSH
81401: LD_EXP 21
81405: NOT
81406: OR
81407: IFTRUE 81422
81409: PUSH
81410: LD_VAR 0 3
81414: PUSH
81415: LD_EXP 49
81419: IN
81420: NOT
81421: OR
81422: IFFALSE 81426
// exit ;
81424: GO 81551
// for i = 1 to mc_vehicles do
81426: LD_ADDR_VAR 0 6
81430: PUSH
81431: DOUBLE
81432: LD_INT 1
81434: DEC
81435: ST_TO_ADDR
81436: LD_EXP 42
81440: PUSH
81441: FOR_TO
81442: IFFALSE 81549
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81444: LD_VAR 0 2
81448: PUSH
81449: LD_EXP 42
81453: PUSH
81454: LD_VAR 0 6
81458: ARRAY
81459: IN
81460: IFTRUE 81480
81462: PUSH
81463: LD_VAR 0 1
81467: PUSH
81468: LD_EXP 42
81472: PUSH
81473: LD_VAR 0 6
81477: ARRAY
81478: IN
81479: OR
81480: IFFALSE 81547
// begin tmp := mc_vehicles [ i ] diff old ;
81482: LD_ADDR_VAR 0 7
81486: PUSH
81487: LD_EXP 42
81491: PUSH
81492: LD_VAR 0 6
81496: ARRAY
81497: PUSH
81498: LD_VAR 0 2
81502: DIFF
81503: ST_TO_ADDR
// tmp := tmp diff new ;
81504: LD_ADDR_VAR 0 7
81508: PUSH
81509: LD_VAR 0 7
81513: PUSH
81514: LD_VAR 0 1
81518: DIFF
81519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81520: LD_ADDR_EXP 42
81524: PUSH
81525: LD_EXP 42
81529: PPUSH
81530: LD_VAR 0 6
81534: PPUSH
81535: LD_VAR 0 7
81539: PPUSH
81540: CALL_OW 1
81544: ST_TO_ADDR
// break ;
81545: GO 81549
// end ;
81547: GO 81441
81549: POP
81550: POP
// end ;
81551: LD_VAR 0 5
81555: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81556: LD_INT 0
81558: PPUSH
81559: PPUSH
81560: PPUSH
81561: PPUSH
// if not mc_bases or not skirmish then
81562: LD_EXP 23
81566: NOT
81567: IFTRUE 81576
81569: PUSH
81570: LD_EXP 21
81574: NOT
81575: OR
81576: IFFALSE 81580
// exit ;
81578: GO 82002
// repeat wait ( 0 0$1 ) ;
81580: LD_INT 35
81582: PPUSH
81583: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
81587: LD_EXP 67
81591: NOT
81592: IFFALSE 81580
// mc_block_vehicle_constructed_thread := true ;
81594: LD_ADDR_EXP 67
81598: PUSH
81599: LD_INT 1
81601: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
81602: LD_ADDR_VAR 0 5
81606: PUSH
81607: LD_VAR 0 1
81611: PPUSH
81612: CALL_OW 255
81616: ST_TO_ADDR
// for i = 1 to mc_bases do
81617: LD_ADDR_VAR 0 4
81621: PUSH
81622: DOUBLE
81623: LD_INT 1
81625: DEC
81626: ST_TO_ADDR
81627: LD_EXP 23
81631: PUSH
81632: FOR_TO
81633: IFFALSE 81992
// begin if factory in mc_bases [ i ] then
81635: LD_VAR 0 2
81639: PUSH
81640: LD_EXP 23
81644: PUSH
81645: LD_VAR 0 4
81649: ARRAY
81650: IN
81651: IFFALSE 81990
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81653: LD_EXP 45
81657: PUSH
81658: LD_VAR 0 4
81662: ARRAY
81663: PUSH
81664: LD_EXP 34
81668: PUSH
81669: LD_VAR 0 4
81673: ARRAY
81674: LESS
81675: IFFALSE 81764
81677: PUSH
81678: LD_VAR 0 1
81682: PPUSH
81683: CALL_OW 264
81687: PUSH
81688: LD_INT 31
81690: PUSH
81691: LD_INT 32
81693: PUSH
81694: LD_INT 51
81696: PUSH
81697: LD_INT 89
81699: PUSH
81700: LD_INT 12
81702: PUSH
81703: LD_INT 30
81705: PUSH
81706: LD_INT 98
81708: PUSH
81709: LD_INT 11
81711: PUSH
81712: LD_INT 53
81714: PUSH
81715: LD_INT 14
81717: PUSH
81718: LD_INT 91
81720: PUSH
81721: LD_INT 29
81723: PUSH
81724: LD_INT 99
81726: PUSH
81727: LD_INT 13
81729: PUSH
81730: LD_INT 52
81732: PUSH
81733: LD_INT 88
81735: PUSH
81736: LD_INT 48
81738: PUSH
81739: LD_INT 8
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: LIST
81753: LIST
81754: LIST
81755: LIST
81756: LIST
81757: LIST
81758: LIST
81759: LIST
81760: LIST
81761: IN
81762: NOT
81763: AND
81764: IFFALSE 81812
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81766: LD_ADDR_EXP 45
81770: PUSH
81771: LD_EXP 45
81775: PPUSH
81776: LD_VAR 0 4
81780: PUSH
81781: LD_EXP 45
81785: PUSH
81786: LD_VAR 0 4
81790: ARRAY
81791: PUSH
81792: LD_INT 1
81794: PLUS
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: PPUSH
81800: LD_VAR 0 1
81804: PPUSH
81805: CALL 16255 0 3
81809: ST_TO_ADDR
81810: GO 81856
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81812: LD_ADDR_EXP 42
81816: PUSH
81817: LD_EXP 42
81821: PPUSH
81822: LD_VAR 0 4
81826: PUSH
81827: LD_EXP 42
81831: PUSH
81832: LD_VAR 0 4
81836: ARRAY
81837: PUSH
81838: LD_INT 1
81840: PLUS
81841: PUSH
81842: EMPTY
81843: LIST
81844: LIST
81845: PPUSH
81846: LD_VAR 0 1
81850: PPUSH
81851: CALL 16255 0 3
81855: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
81856: LD_ADDR_EXP 67
81860: PUSH
81861: LD_INT 0
81863: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81864: LD_VAR 0 1
81868: PPUSH
81869: CALL_OW 263
81873: PUSH
81874: LD_INT 2
81876: EQUAL
81877: IFFALSE 81906
// begin repeat wait ( 0 0$3 ) ;
81879: LD_INT 105
81881: PPUSH
81882: CALL_OW 67
// Connect ( vehicle ) ;
81886: LD_VAR 0 1
81890: PPUSH
81891: CALL 19615 0 1
// until IsControledBy ( vehicle ) ;
81895: LD_VAR 0 1
81899: PPUSH
81900: CALL_OW 312
81904: IFFALSE 81879
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81906: LD_VAR 0 1
81910: PPUSH
81911: LD_EXP 47
81915: PUSH
81916: LD_VAR 0 4
81920: ARRAY
81921: PPUSH
81922: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81926: LD_VAR 0 1
81930: PPUSH
81931: CALL_OW 263
81935: PUSH
81936: LD_INT 1
81938: NONEQUAL
81939: IFFALSE 81943
// break ;
81941: GO 81992
// repeat wait ( 0 0$1 ) ;
81943: LD_INT 35
81945: PPUSH
81946: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81950: LD_VAR 0 1
81954: PPUSH
81955: LD_EXP 47
81959: PUSH
81960: LD_VAR 0 4
81964: ARRAY
81965: PPUSH
81966: CALL_OW 308
81970: IFFALSE 81943
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81972: LD_VAR 0 1
81976: PPUSH
81977: CALL_OW 311
81981: PPUSH
81982: CALL_OW 121
// exit ;
81986: POP
81987: POP
81988: GO 82002
// end ; end ;
81990: GO 81632
81992: POP
81993: POP
// mc_block_vehicle_constructed_thread := false ;
81994: LD_ADDR_EXP 67
81998: PUSH
81999: LD_INT 0
82001: ST_TO_ADDR
// end ;
82002: LD_VAR 0 3
82006: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82007: LD_INT 0
82009: PPUSH
82010: PPUSH
82011: PPUSH
82012: PPUSH
// if not mc_bases or not skirmish then
82013: LD_EXP 23
82017: NOT
82018: IFTRUE 82027
82020: PUSH
82021: LD_EXP 21
82025: NOT
82026: OR
82027: IFFALSE 82031
// exit ;
82029: GO 82384
// repeat wait ( 0 0$1 ) ;
82031: LD_INT 35
82033: PPUSH
82034: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82038: LD_VAR 0 2
82042: PPUSH
82043: LD_VAR 0 3
82047: PPUSH
82048: CALL_OW 284
82052: IFFALSE 82031
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82054: LD_VAR 0 2
82058: PPUSH
82059: LD_VAR 0 3
82063: PPUSH
82064: CALL_OW 283
82068: PUSH
82069: LD_INT 4
82071: EQUAL
82072: IFFALSE 82076
// exit ;
82074: GO 82384
// for i = 1 to mc_bases do
82076: LD_ADDR_VAR 0 7
82080: PUSH
82081: DOUBLE
82082: LD_INT 1
82084: DEC
82085: ST_TO_ADDR
82086: LD_EXP 23
82090: PUSH
82091: FOR_TO
82092: IFFALSE 82382
// begin if mc_crates_area [ i ] then
82094: LD_EXP 41
82098: PUSH
82099: LD_VAR 0 7
82103: ARRAY
82104: IFFALSE 82215
// for j in mc_crates_area [ i ] do
82106: LD_ADDR_VAR 0 8
82110: PUSH
82111: LD_EXP 41
82115: PUSH
82116: LD_VAR 0 7
82120: ARRAY
82121: PUSH
82122: FOR_IN
82123: IFFALSE 82213
// if InArea ( x , y , j ) then
82125: LD_VAR 0 2
82129: PPUSH
82130: LD_VAR 0 3
82134: PPUSH
82135: LD_VAR 0 8
82139: PPUSH
82140: CALL_OW 309
82144: IFFALSE 82211
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82146: LD_ADDR_EXP 39
82150: PUSH
82151: LD_EXP 39
82155: PPUSH
82156: LD_VAR 0 7
82160: PUSH
82161: LD_EXP 39
82165: PUSH
82166: LD_VAR 0 7
82170: ARRAY
82171: PUSH
82172: LD_INT 1
82174: PLUS
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PPUSH
82180: LD_VAR 0 4
82184: PUSH
82185: LD_VAR 0 2
82189: PUSH
82190: LD_VAR 0 3
82194: PUSH
82195: EMPTY
82196: LIST
82197: LIST
82198: LIST
82199: PPUSH
82200: CALL 16255 0 3
82204: ST_TO_ADDR
// exit ;
82205: POP
82206: POP
82207: POP
82208: POP
82209: GO 82384
// end ;
82211: GO 82122
82213: POP
82214: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82215: LD_ADDR_VAR 0 9
82219: PUSH
82220: LD_EXP 23
82224: PUSH
82225: LD_VAR 0 7
82229: ARRAY
82230: PPUSH
82231: LD_INT 2
82233: PUSH
82234: LD_INT 30
82236: PUSH
82237: LD_INT 0
82239: PUSH
82240: EMPTY
82241: LIST
82242: LIST
82243: PUSH
82244: LD_INT 30
82246: PUSH
82247: LD_INT 1
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: LIST
82258: PPUSH
82259: CALL_OW 72
82263: ST_TO_ADDR
// if not depot then
82264: LD_VAR 0 9
82268: NOT
82269: IFFALSE 82273
// continue ;
82271: GO 82091
// for j in depot do
82273: LD_ADDR_VAR 0 8
82277: PUSH
82278: LD_VAR 0 9
82282: PUSH
82283: FOR_IN
82284: IFFALSE 82378
// if GetDistUnitXY ( j , x , y ) < 30 then
82286: LD_VAR 0 8
82290: PPUSH
82291: LD_VAR 0 2
82295: PPUSH
82296: LD_VAR 0 3
82300: PPUSH
82301: CALL_OW 297
82305: PUSH
82306: LD_INT 30
82308: LESS
82309: IFFALSE 82376
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82311: LD_ADDR_EXP 39
82315: PUSH
82316: LD_EXP 39
82320: PPUSH
82321: LD_VAR 0 7
82325: PUSH
82326: LD_EXP 39
82330: PUSH
82331: LD_VAR 0 7
82335: ARRAY
82336: PUSH
82337: LD_INT 1
82339: PLUS
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PPUSH
82345: LD_VAR 0 4
82349: PUSH
82350: LD_VAR 0 2
82354: PUSH
82355: LD_VAR 0 3
82359: PUSH
82360: EMPTY
82361: LIST
82362: LIST
82363: LIST
82364: PPUSH
82365: CALL 16255 0 3
82369: ST_TO_ADDR
// exit ;
82370: POP
82371: POP
82372: POP
82373: POP
82374: GO 82384
// end ;
82376: GO 82283
82378: POP
82379: POP
// end ;
82380: GO 82091
82382: POP
82383: POP
// end ;
82384: LD_VAR 0 6
82388: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82389: LD_INT 0
82391: PPUSH
82392: PPUSH
82393: PPUSH
82394: PPUSH
// if not mc_bases or not skirmish then
82395: LD_EXP 23
82399: NOT
82400: IFTRUE 82409
82402: PUSH
82403: LD_EXP 21
82407: NOT
82408: OR
82409: IFFALSE 82413
// exit ;
82411: GO 82696
// side := GetSide ( lab ) ;
82413: LD_ADDR_VAR 0 4
82417: PUSH
82418: LD_VAR 0 2
82422: PPUSH
82423: CALL_OW 255
82427: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82428: LD_VAR 0 4
82432: PUSH
82433: LD_EXP 49
82437: IN
82438: NOT
82439: IFTRUE 82448
82441: PUSH
82442: LD_EXP 50
82446: NOT
82447: OR
82448: IFTRUE 82457
82450: PUSH
82451: LD_EXP 23
82455: NOT
82456: OR
82457: IFFALSE 82461
// exit ;
82459: GO 82696
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82461: LD_ADDR_EXP 50
82465: PUSH
82466: LD_EXP 50
82470: PPUSH
82471: LD_VAR 0 4
82475: PPUSH
82476: LD_EXP 50
82480: PUSH
82481: LD_VAR 0 4
82485: ARRAY
82486: PUSH
82487: LD_VAR 0 1
82491: DIFF
82492: PPUSH
82493: CALL_OW 1
82497: ST_TO_ADDR
// for i = 1 to mc_bases do
82498: LD_ADDR_VAR 0 5
82502: PUSH
82503: DOUBLE
82504: LD_INT 1
82506: DEC
82507: ST_TO_ADDR
82508: LD_EXP 23
82512: PUSH
82513: FOR_TO
82514: IFFALSE 82694
// begin if lab in mc_bases [ i ] then
82516: LD_VAR 0 2
82520: PUSH
82521: LD_EXP 23
82525: PUSH
82526: LD_VAR 0 5
82530: ARRAY
82531: IN
82532: IFFALSE 82692
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82534: LD_VAR 0 1
82538: PUSH
82539: LD_INT 11
82541: PUSH
82542: LD_INT 4
82544: PUSH
82545: LD_INT 3
82547: PUSH
82548: LD_INT 2
82550: PUSH
82551: EMPTY
82552: LIST
82553: LIST
82554: LIST
82555: LIST
82556: IN
82557: IFFALSE 82571
82559: PUSH
82560: LD_EXP 53
82564: PUSH
82565: LD_VAR 0 5
82569: ARRAY
82570: AND
82571: IFFALSE 82692
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82573: LD_ADDR_VAR 0 6
82577: PUSH
82578: LD_EXP 53
82582: PUSH
82583: LD_VAR 0 5
82587: ARRAY
82588: PUSH
82589: LD_INT 1
82591: ARRAY
82592: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82593: LD_ADDR_EXP 53
82597: PUSH
82598: LD_EXP 53
82602: PPUSH
82603: LD_VAR 0 5
82607: PPUSH
82608: EMPTY
82609: PPUSH
82610: CALL_OW 1
82614: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82615: LD_VAR 0 6
82619: PPUSH
82620: LD_INT 0
82622: PPUSH
82623: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82627: LD_VAR 0 6
82631: PPUSH
82632: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82636: LD_ADDR_EXP 52
82640: PUSH
82641: LD_EXP 52
82645: PPUSH
82646: LD_VAR 0 5
82650: PPUSH
82651: LD_EXP 52
82655: PUSH
82656: LD_VAR 0 5
82660: ARRAY
82661: PPUSH
82662: LD_INT 1
82664: PPUSH
82665: LD_VAR 0 6
82669: PPUSH
82670: CALL_OW 2
82674: PPUSH
82675: CALL_OW 1
82679: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82680: LD_VAR 0 5
82684: PPUSH
82685: LD_INT 112
82687: PPUSH
82688: CALL 58826 0 2
// end ; end ; end ;
82692: GO 82513
82694: POP
82695: POP
// end ;
82696: LD_VAR 0 3
82700: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82701: LD_INT 0
82703: PPUSH
82704: PPUSH
82705: PPUSH
82706: PPUSH
82707: PPUSH
82708: PPUSH
82709: PPUSH
82710: PPUSH
// if not mc_bases or not skirmish then
82711: LD_EXP 23
82715: NOT
82716: IFTRUE 82725
82718: PUSH
82719: LD_EXP 21
82723: NOT
82724: OR
82725: IFFALSE 82729
// exit ;
82727: GO 84114
// for i = 1 to mc_bases do
82729: LD_ADDR_VAR 0 3
82733: PUSH
82734: DOUBLE
82735: LD_INT 1
82737: DEC
82738: ST_TO_ADDR
82739: LD_EXP 23
82743: PUSH
82744: FOR_TO
82745: IFFALSE 84112
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82747: LD_VAR 0 1
82751: PUSH
82752: LD_EXP 23
82756: PUSH
82757: LD_VAR 0 3
82761: ARRAY
82762: IN
82763: IFTRUE 82783
82765: PUSH
82766: LD_VAR 0 1
82770: PUSH
82771: LD_EXP 30
82775: PUSH
82776: LD_VAR 0 3
82780: ARRAY
82781: IN
82782: OR
82783: IFTRUE 82803
82785: PUSH
82786: LD_VAR 0 1
82790: PUSH
82791: LD_EXP 45
82795: PUSH
82796: LD_VAR 0 3
82800: ARRAY
82801: IN
82802: OR
82803: IFTRUE 82823
82805: PUSH
82806: LD_VAR 0 1
82810: PUSH
82811: LD_EXP 42
82815: PUSH
82816: LD_VAR 0 3
82820: ARRAY
82821: IN
82822: OR
82823: IFTRUE 82843
82825: PUSH
82826: LD_VAR 0 1
82830: PUSH
82831: LD_EXP 52
82835: PUSH
82836: LD_VAR 0 3
82840: ARRAY
82841: IN
82842: OR
82843: IFTRUE 82863
82845: PUSH
82846: LD_VAR 0 1
82850: PUSH
82851: LD_EXP 53
82855: PUSH
82856: LD_VAR 0 3
82860: ARRAY
82861: IN
82862: OR
82863: IFFALSE 84110
// begin if un in mc_ape [ i ] then
82865: LD_VAR 0 1
82869: PUSH
82870: LD_EXP 52
82874: PUSH
82875: LD_VAR 0 3
82879: ARRAY
82880: IN
82881: IFFALSE 82920
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82883: LD_ADDR_EXP 52
82887: PUSH
82888: LD_EXP 52
82892: PPUSH
82893: LD_VAR 0 3
82897: PPUSH
82898: LD_EXP 52
82902: PUSH
82903: LD_VAR 0 3
82907: ARRAY
82908: PUSH
82909: LD_VAR 0 1
82913: DIFF
82914: PPUSH
82915: CALL_OW 1
82919: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82920: LD_VAR 0 1
82924: PUSH
82925: LD_EXP 53
82929: PUSH
82930: LD_VAR 0 3
82934: ARRAY
82935: IN
82936: IFFALSE 82960
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82938: LD_ADDR_EXP 53
82942: PUSH
82943: LD_EXP 53
82947: PPUSH
82948: LD_VAR 0 3
82952: PPUSH
82953: EMPTY
82954: PPUSH
82955: CALL_OW 1
82959: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82960: LD_VAR 0 1
82964: PPUSH
82965: CALL_OW 247
82969: PUSH
82970: LD_INT 2
82972: EQUAL
82973: IFFALSE 83054
82975: PUSH
82976: LD_VAR 0 1
82980: PPUSH
82981: CALL_OW 110
82985: PUSH
82986: LD_INT 20
82988: EQUAL
82989: IFTRUE 83009
82991: PUSH
82992: LD_VAR 0 1
82996: PUSH
82997: LD_EXP 45
83001: PUSH
83002: LD_VAR 0 3
83006: ARRAY
83007: IN
83008: OR
83009: IFTRUE 83053
83011: PUSH
83012: LD_VAR 0 1
83016: PPUSH
83017: CALL_OW 264
83021: PUSH
83022: LD_INT 12
83024: PUSH
83025: LD_INT 51
83027: PUSH
83028: LD_INT 89
83030: PUSH
83031: LD_INT 32
83033: PUSH
83034: LD_INT 13
83036: PUSH
83037: LD_INT 52
83039: PUSH
83040: LD_INT 31
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: IN
83052: OR
83053: AND
83054: IFFALSE 83362
// begin if un in mc_defender [ i ] then
83056: LD_VAR 0 1
83060: PUSH
83061: LD_EXP 45
83065: PUSH
83066: LD_VAR 0 3
83070: ARRAY
83071: IN
83072: IFFALSE 83111
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83074: LD_ADDR_EXP 45
83078: PUSH
83079: LD_EXP 45
83083: PPUSH
83084: LD_VAR 0 3
83088: PPUSH
83089: LD_EXP 45
83093: PUSH
83094: LD_VAR 0 3
83098: ARRAY
83099: PUSH
83100: LD_VAR 0 1
83104: DIFF
83105: PPUSH
83106: CALL_OW 1
83110: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
83111: LD_ADDR_VAR 0 8
83115: PUSH
83116: LD_VAR 0 3
83120: PPUSH
83121: LD_INT 3
83123: PPUSH
83124: CALL 79650 0 2
83128: ST_TO_ADDR
// if fac then
83129: LD_VAR 0 8
83133: IFFALSE 83362
// begin for j in fac do
83135: LD_ADDR_VAR 0 4
83139: PUSH
83140: LD_VAR 0 8
83144: PUSH
83145: FOR_IN
83146: IFFALSE 83360
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83148: LD_ADDR_VAR 0 9
83152: PUSH
83153: LD_VAR 0 8
83157: PPUSH
83158: LD_VAR 0 1
83162: PPUSH
83163: CALL_OW 265
83167: PPUSH
83168: LD_VAR 0 1
83172: PPUSH
83173: CALL_OW 262
83177: PPUSH
83178: LD_VAR 0 1
83182: PPUSH
83183: CALL_OW 263
83187: PPUSH
83188: LD_VAR 0 1
83192: PPUSH
83193: CALL_OW 264
83197: PPUSH
83198: CALL 13729 0 5
83202: ST_TO_ADDR
// if components then
83203: LD_VAR 0 9
83207: IFFALSE 83358
// begin if GetWeapon ( un ) = ar_control_tower then
83209: LD_VAR 0 1
83213: PPUSH
83214: CALL_OW 264
83218: PUSH
83219: LD_INT 31
83221: EQUAL
83222: IFFALSE 83339
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83224: LD_VAR 0 1
83228: PPUSH
83229: CALL_OW 311
83233: PPUSH
83234: LD_INT 0
83236: PPUSH
83237: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83241: LD_ADDR_EXP 63
83245: PUSH
83246: LD_EXP 63
83250: PPUSH
83251: LD_VAR 0 3
83255: PPUSH
83256: LD_EXP 63
83260: PUSH
83261: LD_VAR 0 3
83265: ARRAY
83266: PUSH
83267: LD_VAR 0 1
83271: PPUSH
83272: CALL_OW 311
83276: DIFF
83277: PPUSH
83278: CALL_OW 1
83282: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83283: LD_ADDR_VAR 0 7
83287: PUSH
83288: LD_EXP 44
83292: PUSH
83293: LD_VAR 0 3
83297: ARRAY
83298: PPUSH
83299: LD_INT 1
83301: PPUSH
83302: LD_VAR 0 9
83306: PPUSH
83307: CALL_OW 2
83311: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83312: LD_ADDR_EXP 44
83316: PUSH
83317: LD_EXP 44
83321: PPUSH
83322: LD_VAR 0 3
83326: PPUSH
83327: LD_VAR 0 7
83331: PPUSH
83332: CALL_OW 1
83336: ST_TO_ADDR
// end else
83337: GO 83356
// MC_InsertProduceList ( i , [ components ] ) ;
83339: LD_VAR 0 3
83343: PPUSH
83344: LD_VAR 0 9
83348: PUSH
83349: EMPTY
83350: LIST
83351: PPUSH
83352: CALL 79195 0 2
// break ;
83356: GO 83360
// end ; end ;
83358: GO 83145
83360: POP
83361: POP
// end ; end ; if GetType ( un ) = unit_building then
83362: LD_VAR 0 1
83366: PPUSH
83367: CALL_OW 247
83371: PUSH
83372: LD_INT 3
83374: EQUAL
83375: IFFALSE 83778
// begin btype := GetBType ( un ) ;
83377: LD_ADDR_VAR 0 5
83381: PUSH
83382: LD_VAR 0 1
83386: PPUSH
83387: CALL_OW 266
83391: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83392: LD_VAR 0 5
83396: PUSH
83397: LD_INT 29
83399: PUSH
83400: LD_INT 30
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: IN
83407: IFFALSE 83480
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83409: LD_VAR 0 1
83413: PPUSH
83414: CALL_OW 250
83418: PPUSH
83419: LD_VAR 0 1
83423: PPUSH
83424: CALL_OW 251
83428: PPUSH
83429: LD_VAR 0 1
83433: PPUSH
83434: CALL_OW 255
83438: PPUSH
83439: CALL_OW 440
83443: NOT
83444: IFFALSE 83480
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83446: LD_VAR 0 1
83450: PPUSH
83451: CALL_OW 250
83455: PPUSH
83456: LD_VAR 0 1
83460: PPUSH
83461: CALL_OW 251
83465: PPUSH
83466: LD_VAR 0 1
83470: PPUSH
83471: CALL_OW 255
83475: PPUSH
83476: CALL_OW 441
// end ; if btype = b_warehouse then
83480: LD_VAR 0 5
83484: PUSH
83485: LD_INT 1
83487: EQUAL
83488: IFFALSE 83506
// begin btype := b_depot ;
83490: LD_ADDR_VAR 0 5
83494: PUSH
83495: LD_INT 0
83497: ST_TO_ADDR
// pos := 1 ;
83498: LD_ADDR_VAR 0 6
83502: PUSH
83503: LD_INT 1
83505: ST_TO_ADDR
// end ; if btype = b_factory then
83506: LD_VAR 0 5
83510: PUSH
83511: LD_INT 3
83513: EQUAL
83514: IFFALSE 83532
// begin btype := b_workshop ;
83516: LD_ADDR_VAR 0 5
83520: PUSH
83521: LD_INT 2
83523: ST_TO_ADDR
// pos := 1 ;
83524: LD_ADDR_VAR 0 6
83528: PUSH
83529: LD_INT 1
83531: ST_TO_ADDR
// end ; if btype = b_barracks then
83532: LD_VAR 0 5
83536: PUSH
83537: LD_INT 5
83539: EQUAL
83540: IFFALSE 83550
// btype := b_armoury ;
83542: LD_ADDR_VAR 0 5
83546: PUSH
83547: LD_INT 4
83549: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83550: LD_VAR 0 5
83554: PUSH
83555: LD_INT 7
83557: PUSH
83558: LD_INT 8
83560: PUSH
83561: EMPTY
83562: LIST
83563: LIST
83564: IN
83565: IFFALSE 83575
// btype := b_lab ;
83567: LD_ADDR_VAR 0 5
83571: PUSH
83572: LD_INT 6
83574: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83575: LD_ADDR_EXP 28
83579: PUSH
83580: LD_EXP 28
83584: PPUSH
83585: LD_VAR 0 3
83589: PUSH
83590: LD_EXP 28
83594: PUSH
83595: LD_VAR 0 3
83599: ARRAY
83600: PUSH
83601: LD_INT 1
83603: PLUS
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PPUSH
83609: LD_VAR 0 5
83613: PUSH
83614: LD_VAR 0 1
83618: PPUSH
83619: CALL_OW 250
83623: PUSH
83624: LD_VAR 0 1
83628: PPUSH
83629: CALL_OW 251
83633: PUSH
83634: LD_VAR 0 1
83638: PPUSH
83639: CALL_OW 254
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: LIST
83648: LIST
83649: PPUSH
83650: CALL 16255 0 3
83654: ST_TO_ADDR
// if pos = 1 then
83655: LD_VAR 0 6
83659: PUSH
83660: LD_INT 1
83662: EQUAL
83663: IFFALSE 83778
// begin tmp := mc_build_list [ i ] ;
83665: LD_ADDR_VAR 0 7
83669: PUSH
83670: LD_EXP 28
83674: PUSH
83675: LD_VAR 0 3
83679: ARRAY
83680: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83681: LD_VAR 0 7
83685: PPUSH
83686: LD_INT 2
83688: PUSH
83689: LD_INT 30
83691: PUSH
83692: LD_INT 0
83694: PUSH
83695: EMPTY
83696: LIST
83697: LIST
83698: PUSH
83699: LD_INT 30
83701: PUSH
83702: LD_INT 1
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: LIST
83713: PPUSH
83714: CALL_OW 72
83718: IFFALSE 83728
// pos := 2 ;
83720: LD_ADDR_VAR 0 6
83724: PUSH
83725: LD_INT 2
83727: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83728: LD_ADDR_VAR 0 7
83732: PUSH
83733: LD_VAR 0 7
83737: PPUSH
83738: LD_VAR 0 6
83742: PPUSH
83743: LD_VAR 0 7
83747: PPUSH
83748: CALL 16581 0 3
83752: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83753: LD_ADDR_EXP 28
83757: PUSH
83758: LD_EXP 28
83762: PPUSH
83763: LD_VAR 0 3
83767: PPUSH
83768: LD_VAR 0 7
83772: PPUSH
83773: CALL_OW 1
83777: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83778: LD_VAR 0 1
83782: PUSH
83783: LD_EXP 23
83787: PUSH
83788: LD_VAR 0 3
83792: ARRAY
83793: IN
83794: IFFALSE 83833
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83796: LD_ADDR_EXP 23
83800: PUSH
83801: LD_EXP 23
83805: PPUSH
83806: LD_VAR 0 3
83810: PPUSH
83811: LD_EXP 23
83815: PUSH
83816: LD_VAR 0 3
83820: ARRAY
83821: PUSH
83822: LD_VAR 0 1
83826: DIFF
83827: PPUSH
83828: CALL_OW 1
83832: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83833: LD_VAR 0 1
83837: PUSH
83838: LD_EXP 30
83842: PUSH
83843: LD_VAR 0 3
83847: ARRAY
83848: IN
83849: IFFALSE 83888
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83851: LD_ADDR_EXP 30
83855: PUSH
83856: LD_EXP 30
83860: PPUSH
83861: LD_VAR 0 3
83865: PPUSH
83866: LD_EXP 30
83870: PUSH
83871: LD_VAR 0 3
83875: ARRAY
83876: PUSH
83877: LD_VAR 0 1
83881: DIFF
83882: PPUSH
83883: CALL_OW 1
83887: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83888: LD_VAR 0 1
83892: PUSH
83893: LD_EXP 42
83897: PUSH
83898: LD_VAR 0 3
83902: ARRAY
83903: IN
83904: IFFALSE 83943
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83906: LD_ADDR_EXP 42
83910: PUSH
83911: LD_EXP 42
83915: PPUSH
83916: LD_VAR 0 3
83920: PPUSH
83921: LD_EXP 42
83925: PUSH
83926: LD_VAR 0 3
83930: ARRAY
83931: PUSH
83932: LD_VAR 0 1
83936: DIFF
83937: PPUSH
83938: CALL_OW 1
83942: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83943: LD_VAR 0 1
83947: PUSH
83948: LD_EXP 45
83952: PUSH
83953: LD_VAR 0 3
83957: ARRAY
83958: IN
83959: IFFALSE 83998
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83961: LD_ADDR_EXP 45
83965: PUSH
83966: LD_EXP 45
83970: PPUSH
83971: LD_VAR 0 3
83975: PPUSH
83976: LD_EXP 45
83980: PUSH
83981: LD_VAR 0 3
83985: ARRAY
83986: PUSH
83987: LD_VAR 0 1
83991: DIFF
83992: PPUSH
83993: CALL_OW 1
83997: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83998: LD_VAR 0 1
84002: PUSH
84003: LD_EXP 32
84007: PUSH
84008: LD_VAR 0 3
84012: ARRAY
84013: IN
84014: IFFALSE 84053
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84016: LD_ADDR_EXP 32
84020: PUSH
84021: LD_EXP 32
84025: PPUSH
84026: LD_VAR 0 3
84030: PPUSH
84031: LD_EXP 32
84035: PUSH
84036: LD_VAR 0 3
84040: ARRAY
84041: PUSH
84042: LD_VAR 0 1
84046: DIFF
84047: PPUSH
84048: CALL_OW 1
84052: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84053: LD_VAR 0 1
84057: PUSH
84058: LD_EXP 31
84062: PUSH
84063: LD_VAR 0 3
84067: ARRAY
84068: IN
84069: IFFALSE 84108
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84071: LD_ADDR_EXP 31
84075: PUSH
84076: LD_EXP 31
84080: PPUSH
84081: LD_VAR 0 3
84085: PPUSH
84086: LD_EXP 31
84090: PUSH
84091: LD_VAR 0 3
84095: ARRAY
84096: PUSH
84097: LD_VAR 0 1
84101: DIFF
84102: PPUSH
84103: CALL_OW 1
84107: ST_TO_ADDR
// end ; break ;
84108: GO 84112
// end ;
84110: GO 82744
84112: POP
84113: POP
// end ;
84114: LD_VAR 0 2
84118: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84119: LD_INT 0
84121: PPUSH
84122: PPUSH
84123: PPUSH
// if not mc_bases or not skirmish then
84124: LD_EXP 23
84128: NOT
84129: IFTRUE 84138
84131: PUSH
84132: LD_EXP 21
84136: NOT
84137: OR
84138: IFFALSE 84142
// exit ;
84140: GO 84357
// for i = 1 to mc_bases do
84142: LD_ADDR_VAR 0 3
84146: PUSH
84147: DOUBLE
84148: LD_INT 1
84150: DEC
84151: ST_TO_ADDR
84152: LD_EXP 23
84156: PUSH
84157: FOR_TO
84158: IFFALSE 84355
// begin if building in mc_construct_list [ i ] then
84160: LD_VAR 0 1
84164: PUSH
84165: LD_EXP 30
84169: PUSH
84170: LD_VAR 0 3
84174: ARRAY
84175: IN
84176: IFFALSE 84353
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84178: LD_ADDR_EXP 30
84182: PUSH
84183: LD_EXP 30
84187: PPUSH
84188: LD_VAR 0 3
84192: PPUSH
84193: LD_EXP 30
84197: PUSH
84198: LD_VAR 0 3
84202: ARRAY
84203: PUSH
84204: LD_VAR 0 1
84208: DIFF
84209: PPUSH
84210: CALL_OW 1
84214: ST_TO_ADDR
// if building in mc_lab [ i ] then
84215: LD_VAR 0 1
84219: PUSH
84220: LD_EXP 56
84224: PUSH
84225: LD_VAR 0 3
84229: ARRAY
84230: IN
84231: IFFALSE 84286
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84233: LD_ADDR_EXP 57
84237: PUSH
84238: LD_EXP 57
84242: PPUSH
84243: LD_VAR 0 3
84247: PPUSH
84248: LD_EXP 57
84252: PUSH
84253: LD_VAR 0 3
84257: ARRAY
84258: PPUSH
84259: LD_INT 1
84261: PPUSH
84262: LD_EXP 57
84266: PUSH
84267: LD_VAR 0 3
84271: ARRAY
84272: PPUSH
84273: LD_INT 0
84275: PPUSH
84276: CALL 15663 0 4
84280: PPUSH
84281: CALL_OW 1
84285: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84286: LD_VAR 0 1
84290: PUSH
84291: LD_EXP 23
84295: PUSH
84296: LD_VAR 0 3
84300: ARRAY
84301: IN
84302: NOT
84303: IFFALSE 84349
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84305: LD_ADDR_EXP 23
84309: PUSH
84310: LD_EXP 23
84314: PPUSH
84315: LD_VAR 0 3
84319: PUSH
84320: LD_EXP 23
84324: PUSH
84325: LD_VAR 0 3
84329: ARRAY
84330: PUSH
84331: LD_INT 1
84333: PLUS
84334: PUSH
84335: EMPTY
84336: LIST
84337: LIST
84338: PPUSH
84339: LD_VAR 0 1
84343: PPUSH
84344: CALL 16255 0 3
84348: ST_TO_ADDR
// exit ;
84349: POP
84350: POP
84351: GO 84357
// end ; end ;
84353: GO 84157
84355: POP
84356: POP
// end ;
84357: LD_VAR 0 2
84361: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84362: LD_INT 0
84364: PPUSH
84365: PPUSH
84366: PPUSH
84367: PPUSH
84368: PPUSH
84369: PPUSH
84370: PPUSH
// if not mc_bases or not skirmish then
84371: LD_EXP 23
84375: NOT
84376: IFTRUE 84385
84378: PUSH
84379: LD_EXP 21
84383: NOT
84384: OR
84385: IFFALSE 84389
// exit ;
84387: GO 85050
// for i = 1 to mc_bases do
84389: LD_ADDR_VAR 0 3
84393: PUSH
84394: DOUBLE
84395: LD_INT 1
84397: DEC
84398: ST_TO_ADDR
84399: LD_EXP 23
84403: PUSH
84404: FOR_TO
84405: IFFALSE 85048
// begin if building in mc_construct_list [ i ] then
84407: LD_VAR 0 1
84411: PUSH
84412: LD_EXP 30
84416: PUSH
84417: LD_VAR 0 3
84421: ARRAY
84422: IN
84423: IFFALSE 85046
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84425: LD_ADDR_EXP 30
84429: PUSH
84430: LD_EXP 30
84434: PPUSH
84435: LD_VAR 0 3
84439: PPUSH
84440: LD_EXP 30
84444: PUSH
84445: LD_VAR 0 3
84449: ARRAY
84450: PUSH
84451: LD_VAR 0 1
84455: DIFF
84456: PPUSH
84457: CALL_OW 1
84461: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84462: LD_ADDR_EXP 23
84466: PUSH
84467: LD_EXP 23
84471: PPUSH
84472: LD_VAR 0 3
84476: PUSH
84477: LD_EXP 23
84481: PUSH
84482: LD_VAR 0 3
84486: ARRAY
84487: PUSH
84488: LD_INT 1
84490: PLUS
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PPUSH
84496: LD_VAR 0 1
84500: PPUSH
84501: CALL 16255 0 3
84505: ST_TO_ADDR
// btype := GetBType ( building ) ;
84506: LD_ADDR_VAR 0 5
84510: PUSH
84511: LD_VAR 0 1
84515: PPUSH
84516: CALL_OW 266
84520: ST_TO_ADDR
// side := GetSide ( building ) ;
84521: LD_ADDR_VAR 0 8
84525: PUSH
84526: LD_VAR 0 1
84530: PPUSH
84531: CALL_OW 255
84535: ST_TO_ADDR
// if btype = b_lab then
84536: LD_VAR 0 5
84540: PUSH
84541: LD_INT 6
84543: EQUAL
84544: IFFALSE 84594
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84546: LD_ADDR_EXP 56
84550: PUSH
84551: LD_EXP 56
84555: PPUSH
84556: LD_VAR 0 3
84560: PUSH
84561: LD_EXP 56
84565: PUSH
84566: LD_VAR 0 3
84570: ARRAY
84571: PUSH
84572: LD_INT 1
84574: PLUS
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PPUSH
84580: LD_VAR 0 1
84584: PPUSH
84585: CALL 16255 0 3
84589: ST_TO_ADDR
// exit ;
84590: POP
84591: POP
84592: GO 85050
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84594: LD_VAR 0 5
84598: PUSH
84599: LD_INT 0
84601: PUSH
84602: LD_INT 2
84604: PUSH
84605: LD_INT 4
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: LIST
84612: IN
84613: IFFALSE 84737
// begin if btype = b_armoury then
84615: LD_VAR 0 5
84619: PUSH
84620: LD_INT 4
84622: EQUAL
84623: IFFALSE 84633
// btype := b_barracks ;
84625: LD_ADDR_VAR 0 5
84629: PUSH
84630: LD_INT 5
84632: ST_TO_ADDR
// if btype = b_depot then
84633: LD_VAR 0 5
84637: PUSH
84638: LD_INT 0
84640: EQUAL
84641: IFFALSE 84651
// btype := b_warehouse ;
84643: LD_ADDR_VAR 0 5
84647: PUSH
84648: LD_INT 1
84650: ST_TO_ADDR
// if btype = b_workshop then
84651: LD_VAR 0 5
84655: PUSH
84656: LD_INT 2
84658: EQUAL
84659: IFFALSE 84669
// btype := b_factory ;
84661: LD_ADDR_VAR 0 5
84665: PUSH
84666: LD_INT 3
84668: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84669: LD_VAR 0 5
84673: PPUSH
84674: LD_VAR 0 8
84678: PPUSH
84679: CALL_OW 323
84683: PUSH
84684: LD_INT 1
84686: EQUAL
84687: IFFALSE 84733
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84689: LD_ADDR_EXP 55
84693: PUSH
84694: LD_EXP 55
84698: PPUSH
84699: LD_VAR 0 3
84703: PUSH
84704: LD_EXP 55
84708: PUSH
84709: LD_VAR 0 3
84713: ARRAY
84714: PUSH
84715: LD_INT 1
84717: PLUS
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PPUSH
84723: LD_VAR 0 1
84727: PPUSH
84728: CALL 16255 0 3
84732: ST_TO_ADDR
// exit ;
84733: POP
84734: POP
84735: GO 85050
// end ; if btype in [ b_bunker , b_turret ] then
84737: LD_VAR 0 5
84741: PUSH
84742: LD_INT 32
84744: PUSH
84745: LD_INT 33
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: IN
84752: IFFALSE 85042
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84754: LD_ADDR_EXP 31
84758: PUSH
84759: LD_EXP 31
84763: PPUSH
84764: LD_VAR 0 3
84768: PUSH
84769: LD_EXP 31
84773: PUSH
84774: LD_VAR 0 3
84778: ARRAY
84779: PUSH
84780: LD_INT 1
84782: PLUS
84783: PUSH
84784: EMPTY
84785: LIST
84786: LIST
84787: PPUSH
84788: LD_VAR 0 1
84792: PPUSH
84793: CALL 16255 0 3
84797: ST_TO_ADDR
// if btype = b_bunker then
84798: LD_VAR 0 5
84802: PUSH
84803: LD_INT 32
84805: EQUAL
84806: IFFALSE 85042
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84808: LD_ADDR_EXP 32
84812: PUSH
84813: LD_EXP 32
84817: PPUSH
84818: LD_VAR 0 3
84822: PUSH
84823: LD_EXP 32
84827: PUSH
84828: LD_VAR 0 3
84832: ARRAY
84833: PUSH
84834: LD_INT 1
84836: PLUS
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PPUSH
84842: LD_VAR 0 1
84846: PPUSH
84847: CALL 16255 0 3
84851: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84852: LD_ADDR_VAR 0 6
84856: PUSH
84857: LD_EXP 23
84861: PUSH
84862: LD_VAR 0 3
84866: ARRAY
84867: PPUSH
84868: LD_INT 25
84870: PUSH
84871: LD_INT 1
84873: PUSH
84874: EMPTY
84875: LIST
84876: LIST
84877: PUSH
84878: LD_INT 3
84880: PUSH
84881: LD_INT 54
84883: PUSH
84884: EMPTY
84885: LIST
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: PPUSH
84895: CALL_OW 72
84899: ST_TO_ADDR
// if tmp then
84900: LD_VAR 0 6
84904: IFFALSE 84910
// exit ;
84906: POP
84907: POP
84908: GO 85050
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84910: LD_ADDR_VAR 0 6
84914: PUSH
84915: LD_EXP 23
84919: PUSH
84920: LD_VAR 0 3
84924: ARRAY
84925: PPUSH
84926: LD_INT 2
84928: PUSH
84929: LD_INT 30
84931: PUSH
84932: LD_INT 4
84934: PUSH
84935: EMPTY
84936: LIST
84937: LIST
84938: PUSH
84939: LD_INT 30
84941: PUSH
84942: LD_INT 5
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: LIST
84953: PPUSH
84954: CALL_OW 72
84958: ST_TO_ADDR
// if not tmp then
84959: LD_VAR 0 6
84963: NOT
84964: IFFALSE 84970
// exit ;
84966: POP
84967: POP
84968: GO 85050
// for j in tmp do
84970: LD_ADDR_VAR 0 4
84974: PUSH
84975: LD_VAR 0 6
84979: PUSH
84980: FOR_IN
84981: IFFALSE 85040
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84983: LD_ADDR_VAR 0 7
84987: PUSH
84988: LD_VAR 0 4
84992: PPUSH
84993: CALL_OW 313
84997: PPUSH
84998: LD_INT 25
85000: PUSH
85001: LD_INT 1
85003: PUSH
85004: EMPTY
85005: LIST
85006: LIST
85007: PPUSH
85008: CALL_OW 72
85012: ST_TO_ADDR
// if units then
85013: LD_VAR 0 7
85017: IFFALSE 85038
// begin ComExitBuilding ( units [ 1 ] ) ;
85019: LD_VAR 0 7
85023: PUSH
85024: LD_INT 1
85026: ARRAY
85027: PPUSH
85028: CALL_OW 122
// exit ;
85032: POP
85033: POP
85034: POP
85035: POP
85036: GO 85050
// end ; end ;
85038: GO 84980
85040: POP
85041: POP
// end ; end ; exit ;
85042: POP
85043: POP
85044: GO 85050
// end ; end ;
85046: GO 84404
85048: POP
85049: POP
// end ;
85050: LD_VAR 0 2
85054: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85055: LD_INT 0
85057: PPUSH
85058: PPUSH
85059: PPUSH
85060: PPUSH
85061: PPUSH
85062: PPUSH
85063: PPUSH
// if not mc_bases or not skirmish then
85064: LD_EXP 23
85068: NOT
85069: IFTRUE 85078
85071: PUSH
85072: LD_EXP 21
85076: NOT
85077: OR
85078: IFFALSE 85082
// exit ;
85080: GO 85347
// btype := GetBType ( building ) ;
85082: LD_ADDR_VAR 0 6
85086: PUSH
85087: LD_VAR 0 1
85091: PPUSH
85092: CALL_OW 266
85096: ST_TO_ADDR
// x := GetX ( building ) ;
85097: LD_ADDR_VAR 0 7
85101: PUSH
85102: LD_VAR 0 1
85106: PPUSH
85107: CALL_OW 250
85111: ST_TO_ADDR
// y := GetY ( building ) ;
85112: LD_ADDR_VAR 0 8
85116: PUSH
85117: LD_VAR 0 1
85121: PPUSH
85122: CALL_OW 251
85126: ST_TO_ADDR
// d := GetDir ( building ) ;
85127: LD_ADDR_VAR 0 9
85131: PUSH
85132: LD_VAR 0 1
85136: PPUSH
85137: CALL_OW 254
85141: ST_TO_ADDR
// for i = 1 to mc_bases do
85142: LD_ADDR_VAR 0 4
85146: PUSH
85147: DOUBLE
85148: LD_INT 1
85150: DEC
85151: ST_TO_ADDR
85152: LD_EXP 23
85156: PUSH
85157: FOR_TO
85158: IFFALSE 85345
// begin if not mc_build_list [ i ] then
85160: LD_EXP 28
85164: PUSH
85165: LD_VAR 0 4
85169: ARRAY
85170: NOT
85171: IFFALSE 85175
// continue ;
85173: GO 85157
// for j := 1 to mc_build_list [ i ] do
85175: LD_ADDR_VAR 0 5
85179: PUSH
85180: DOUBLE
85181: LD_INT 1
85183: DEC
85184: ST_TO_ADDR
85185: LD_EXP 28
85189: PUSH
85190: LD_VAR 0 4
85194: ARRAY
85195: PUSH
85196: FOR_TO
85197: IFFALSE 85341
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85199: LD_VAR 0 6
85203: PUSH
85204: LD_VAR 0 7
85208: PUSH
85209: LD_VAR 0 8
85213: PUSH
85214: LD_VAR 0 9
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: PPUSH
85225: LD_EXP 28
85229: PUSH
85230: LD_VAR 0 4
85234: ARRAY
85235: PUSH
85236: LD_VAR 0 5
85240: ARRAY
85241: PPUSH
85242: CALL 22862 0 2
85246: IFFALSE 85339
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85248: LD_ADDR_EXP 28
85252: PUSH
85253: LD_EXP 28
85257: PPUSH
85258: LD_VAR 0 4
85262: PPUSH
85263: LD_EXP 28
85267: PUSH
85268: LD_VAR 0 4
85272: ARRAY
85273: PPUSH
85274: LD_VAR 0 5
85278: PPUSH
85279: CALL_OW 3
85283: PPUSH
85284: CALL_OW 1
85288: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85289: LD_ADDR_EXP 30
85293: PUSH
85294: LD_EXP 30
85298: PPUSH
85299: LD_VAR 0 4
85303: PUSH
85304: LD_EXP 30
85308: PUSH
85309: LD_VAR 0 4
85313: ARRAY
85314: PUSH
85315: LD_INT 1
85317: PLUS
85318: PUSH
85319: EMPTY
85320: LIST
85321: LIST
85322: PPUSH
85323: LD_VAR 0 1
85327: PPUSH
85328: CALL 16255 0 3
85332: ST_TO_ADDR
// exit ;
85333: POP
85334: POP
85335: POP
85336: POP
85337: GO 85347
// end ;
85339: GO 85196
85341: POP
85342: POP
// end ;
85343: GO 85157
85345: POP
85346: POP
// end ;
85347: LD_VAR 0 3
85351: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85352: LD_INT 0
85354: PPUSH
85355: PPUSH
85356: PPUSH
// if not mc_bases or not skirmish then
85357: LD_EXP 23
85361: NOT
85362: IFTRUE 85371
85364: PUSH
85365: LD_EXP 21
85369: NOT
85370: OR
85371: IFFALSE 85375
// exit ;
85373: GO 85571
// for i = 1 to mc_bases do
85375: LD_ADDR_VAR 0 4
85379: PUSH
85380: DOUBLE
85381: LD_INT 1
85383: DEC
85384: ST_TO_ADDR
85385: LD_EXP 23
85389: PUSH
85390: FOR_TO
85391: IFFALSE 85480
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85393: LD_VAR 0 1
85397: PUSH
85398: LD_EXP 31
85402: PUSH
85403: LD_VAR 0 4
85407: ARRAY
85408: IN
85409: IFFALSE 85430
85411: PUSH
85412: LD_VAR 0 1
85416: PUSH
85417: LD_EXP 32
85421: PUSH
85422: LD_VAR 0 4
85426: ARRAY
85427: IN
85428: NOT
85429: AND
85430: IFFALSE 85478
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85432: LD_ADDR_EXP 32
85436: PUSH
85437: LD_EXP 32
85441: PPUSH
85442: LD_VAR 0 4
85446: PUSH
85447: LD_EXP 32
85451: PUSH
85452: LD_VAR 0 4
85456: ARRAY
85457: PUSH
85458: LD_INT 1
85460: PLUS
85461: PUSH
85462: EMPTY
85463: LIST
85464: LIST
85465: PPUSH
85466: LD_VAR 0 1
85470: PPUSH
85471: CALL 16255 0 3
85475: ST_TO_ADDR
// break ;
85476: GO 85480
// end ; end ;
85478: GO 85390
85480: POP
85481: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85482: LD_VAR 0 1
85486: PPUSH
85487: CALL_OW 257
85491: PUSH
85492: LD_EXP 49
85496: IN
85497: IFFALSE 85514
85499: PUSH
85500: LD_VAR 0 1
85504: PPUSH
85505: CALL_OW 266
85509: PUSH
85510: LD_INT 5
85512: EQUAL
85513: AND
85514: IFFALSE 85531
85516: PUSH
85517: LD_VAR 0 2
85521: PPUSH
85522: CALL_OW 110
85526: PUSH
85527: LD_INT 18
85529: NONEQUAL
85530: AND
85531: IFFALSE 85571
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85533: LD_VAR 0 2
85537: PPUSH
85538: CALL_OW 257
85542: PUSH
85543: LD_INT 5
85545: PUSH
85546: LD_INT 8
85548: PUSH
85549: LD_INT 9
85551: PUSH
85552: EMPTY
85553: LIST
85554: LIST
85555: LIST
85556: IN
85557: IFFALSE 85571
// SetClass ( unit , 1 ) ;
85559: LD_VAR 0 2
85563: PPUSH
85564: LD_INT 1
85566: PPUSH
85567: CALL_OW 336
// end ;
85571: LD_VAR 0 3
85575: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85576: LD_INT 0
85578: PPUSH
85579: PPUSH
// if not mc_bases or not skirmish then
85580: LD_EXP 23
85584: NOT
85585: IFTRUE 85594
85587: PUSH
85588: LD_EXP 21
85592: NOT
85593: OR
85594: IFFALSE 85598
// exit ;
85596: GO 85714
// if GetLives ( abandoned_vehicle ) > 250 then
85598: LD_VAR 0 2
85602: PPUSH
85603: CALL_OW 256
85607: PUSH
85608: LD_INT 250
85610: GREATER
85611: IFFALSE 85615
// exit ;
85613: GO 85714
// for i = 1 to mc_bases do
85615: LD_ADDR_VAR 0 6
85619: PUSH
85620: DOUBLE
85621: LD_INT 1
85623: DEC
85624: ST_TO_ADDR
85625: LD_EXP 23
85629: PUSH
85630: FOR_TO
85631: IFFALSE 85712
// begin if driver in mc_bases [ i ] then
85633: LD_VAR 0 1
85637: PUSH
85638: LD_EXP 23
85642: PUSH
85643: LD_VAR 0 6
85647: ARRAY
85648: IN
85649: IFFALSE 85710
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85651: LD_VAR 0 1
85655: PPUSH
85656: LD_EXP 23
85660: PUSH
85661: LD_VAR 0 6
85665: ARRAY
85666: PPUSH
85667: LD_INT 2
85669: PUSH
85670: LD_INT 30
85672: PUSH
85673: LD_INT 0
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: PUSH
85680: LD_INT 30
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: EMPTY
85691: LIST
85692: LIST
85693: LIST
85694: PPUSH
85695: CALL_OW 72
85699: PUSH
85700: LD_INT 1
85702: ARRAY
85703: PPUSH
85704: CALL 50182 0 2
// break ;
85708: GO 85712
// end ; end ;
85710: GO 85630
85712: POP
85713: POP
// end ; end_of_file
85714: LD_VAR 0 5
85718: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
85719: LD_INT 0
85721: PPUSH
85722: PPUSH
85723: PPUSH
85724: PPUSH
85725: PPUSH
85726: PPUSH
85727: PPUSH
85728: PPUSH
85729: PPUSH
85730: PPUSH
85731: PPUSH
85732: PPUSH
85733: PPUSH
85734: PPUSH
85735: PPUSH
85736: PPUSH
85737: PPUSH
85738: PPUSH
85739: PPUSH
85740: PPUSH
85741: PPUSH
85742: PPUSH
85743: PPUSH
85744: PPUSH
85745: PPUSH
85746: PPUSH
85747: PPUSH
85748: PPUSH
85749: PPUSH
85750: PPUSH
85751: PPUSH
85752: PPUSH
85753: PPUSH
85754: PPUSH
// if not list then
85755: LD_VAR 0 1
85759: NOT
85760: IFFALSE 85764
// exit ;
85762: GO 90483
// base := list [ 1 ] ;
85764: LD_ADDR_VAR 0 3
85768: PUSH
85769: LD_VAR 0 1
85773: PUSH
85774: LD_INT 1
85776: ARRAY
85777: ST_TO_ADDR
// group := list [ 2 ] ;
85778: LD_ADDR_VAR 0 4
85782: PUSH
85783: LD_VAR 0 1
85787: PUSH
85788: LD_INT 2
85790: ARRAY
85791: ST_TO_ADDR
// path := list [ 3 ] ;
85792: LD_ADDR_VAR 0 5
85796: PUSH
85797: LD_VAR 0 1
85801: PUSH
85802: LD_INT 3
85804: ARRAY
85805: ST_TO_ADDR
// flags := list [ 4 ] ;
85806: LD_ADDR_VAR 0 6
85810: PUSH
85811: LD_VAR 0 1
85815: PUSH
85816: LD_INT 4
85818: ARRAY
85819: ST_TO_ADDR
// mined := [ ] ;
85820: LD_ADDR_VAR 0 27
85824: PUSH
85825: EMPTY
85826: ST_TO_ADDR
// bombed := [ ] ;
85827: LD_ADDR_VAR 0 28
85831: PUSH
85832: EMPTY
85833: ST_TO_ADDR
// healers := [ ] ;
85834: LD_ADDR_VAR 0 31
85838: PUSH
85839: EMPTY
85840: ST_TO_ADDR
// to_heal := [ ] ;
85841: LD_ADDR_VAR 0 30
85845: PUSH
85846: EMPTY
85847: ST_TO_ADDR
// repairs := [ ] ;
85848: LD_ADDR_VAR 0 33
85852: PUSH
85853: EMPTY
85854: ST_TO_ADDR
// to_repair := [ ] ;
85855: LD_ADDR_VAR 0 32
85859: PUSH
85860: EMPTY
85861: ST_TO_ADDR
// if not group or not path then
85862: LD_VAR 0 4
85866: NOT
85867: IFTRUE 85876
85869: PUSH
85870: LD_VAR 0 5
85874: NOT
85875: OR
85876: IFFALSE 85880
// exit ;
85878: GO 90483
// side := GetSide ( group [ 1 ] ) ;
85880: LD_ADDR_VAR 0 35
85884: PUSH
85885: LD_VAR 0 4
85889: PUSH
85890: LD_INT 1
85892: ARRAY
85893: PPUSH
85894: CALL_OW 255
85898: ST_TO_ADDR
// if flags then
85899: LD_VAR 0 6
85903: IFFALSE 86047
// begin f_ignore_area := flags [ 1 ] ;
85905: LD_ADDR_VAR 0 17
85909: PUSH
85910: LD_VAR 0 6
85914: PUSH
85915: LD_INT 1
85917: ARRAY
85918: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
85919: LD_ADDR_VAR 0 18
85923: PUSH
85924: LD_VAR 0 6
85928: PUSH
85929: LD_INT 2
85931: ARRAY
85932: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
85933: LD_ADDR_VAR 0 19
85937: PUSH
85938: LD_VAR 0 6
85942: PUSH
85943: LD_INT 3
85945: ARRAY
85946: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
85947: LD_ADDR_VAR 0 20
85951: PUSH
85952: LD_VAR 0 6
85956: PUSH
85957: LD_INT 4
85959: ARRAY
85960: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
85961: LD_ADDR_VAR 0 21
85965: PUSH
85966: LD_VAR 0 6
85970: PUSH
85971: LD_INT 5
85973: ARRAY
85974: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
85975: LD_ADDR_VAR 0 22
85979: PUSH
85980: LD_VAR 0 6
85984: PUSH
85985: LD_INT 6
85987: ARRAY
85988: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
85989: LD_ADDR_VAR 0 23
85993: PUSH
85994: LD_VAR 0 6
85998: PUSH
85999: LD_INT 7
86001: ARRAY
86002: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
86003: LD_ADDR_VAR 0 24
86007: PUSH
86008: LD_VAR 0 6
86012: PUSH
86013: LD_INT 8
86015: ARRAY
86016: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
86017: LD_ADDR_VAR 0 25
86021: PUSH
86022: LD_VAR 0 6
86026: PUSH
86027: LD_INT 9
86029: ARRAY
86030: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
86031: LD_ADDR_VAR 0 26
86035: PUSH
86036: LD_VAR 0 6
86040: PUSH
86041: LD_INT 10
86043: ARRAY
86044: ST_TO_ADDR
// end else
86045: GO 86127
// begin f_ignore_area := false ;
86047: LD_ADDR_VAR 0 17
86051: PUSH
86052: LD_INT 0
86054: ST_TO_ADDR
// f_capture := false ;
86055: LD_ADDR_VAR 0 18
86059: PUSH
86060: LD_INT 0
86062: ST_TO_ADDR
// f_ignore_civ := false ;
86063: LD_ADDR_VAR 0 19
86067: PUSH
86068: LD_INT 0
86070: ST_TO_ADDR
// f_murder := false ;
86071: LD_ADDR_VAR 0 20
86075: PUSH
86076: LD_INT 0
86078: ST_TO_ADDR
// f_mines := false ;
86079: LD_ADDR_VAR 0 21
86083: PUSH
86084: LD_INT 0
86086: ST_TO_ADDR
// f_repair := false ;
86087: LD_ADDR_VAR 0 22
86091: PUSH
86092: LD_INT 0
86094: ST_TO_ADDR
// f_heal := false ;
86095: LD_ADDR_VAR 0 23
86099: PUSH
86100: LD_INT 0
86102: ST_TO_ADDR
// f_spacetime := false ;
86103: LD_ADDR_VAR 0 24
86107: PUSH
86108: LD_INT 0
86110: ST_TO_ADDR
// f_attack_depot := false ;
86111: LD_ADDR_VAR 0 25
86115: PUSH
86116: LD_INT 0
86118: ST_TO_ADDR
// f_crawl := false ;
86119: LD_ADDR_VAR 0 26
86123: PUSH
86124: LD_INT 0
86126: ST_TO_ADDR
// end ; if f_heal then
86127: LD_VAR 0 23
86131: IFFALSE 86158
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
86133: LD_ADDR_VAR 0 31
86137: PUSH
86138: LD_VAR 0 4
86142: PPUSH
86143: LD_INT 25
86145: PUSH
86146: LD_INT 4
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PPUSH
86153: CALL_OW 72
86157: ST_TO_ADDR
// if f_repair then
86158: LD_VAR 0 22
86162: IFFALSE 86189
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
86164: LD_ADDR_VAR 0 33
86168: PUSH
86169: LD_VAR 0 4
86173: PPUSH
86174: LD_INT 25
86176: PUSH
86177: LD_INT 3
86179: PUSH
86180: EMPTY
86181: LIST
86182: LIST
86183: PPUSH
86184: CALL_OW 72
86188: ST_TO_ADDR
// units_path := [ ] ;
86189: LD_ADDR_VAR 0 16
86193: PUSH
86194: EMPTY
86195: ST_TO_ADDR
// for i = 1 to group do
86196: LD_ADDR_VAR 0 7
86200: PUSH
86201: DOUBLE
86202: LD_INT 1
86204: DEC
86205: ST_TO_ADDR
86206: LD_VAR 0 4
86210: PUSH
86211: FOR_TO
86212: IFFALSE 86241
// units_path := Replace ( units_path , i , path ) ;
86214: LD_ADDR_VAR 0 16
86218: PUSH
86219: LD_VAR 0 16
86223: PPUSH
86224: LD_VAR 0 7
86228: PPUSH
86229: LD_VAR 0 5
86233: PPUSH
86234: CALL_OW 1
86238: ST_TO_ADDR
86239: GO 86211
86241: POP
86242: POP
// repeat for i = group downto 1 do
86243: LD_ADDR_VAR 0 7
86247: PUSH
86248: DOUBLE
86249: LD_VAR 0 4
86253: INC
86254: ST_TO_ADDR
86255: LD_INT 1
86257: PUSH
86258: FOR_DOWNTO
86259: IFFALSE 90435
// begin wait ( 5 ) ;
86261: LD_INT 5
86263: PPUSH
86264: CALL_OW 67
// tmp := [ ] ;
86268: LD_ADDR_VAR 0 14
86272: PUSH
86273: EMPTY
86274: ST_TO_ADDR
// attacking := false ;
86275: LD_ADDR_VAR 0 29
86279: PUSH
86280: LD_INT 0
86282: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
86283: LD_VAR 0 4
86287: PUSH
86288: LD_VAR 0 7
86292: ARRAY
86293: PPUSH
86294: CALL_OW 301
86298: IFTRUE 86313
86300: PUSH
86301: LD_VAR 0 4
86305: PUSH
86306: LD_VAR 0 7
86310: ARRAY
86311: NOT
86312: OR
86313: IFFALSE 86422
// begin if GetType ( group [ i ] ) = unit_human then
86315: LD_VAR 0 4
86319: PUSH
86320: LD_VAR 0 7
86324: ARRAY
86325: PPUSH
86326: CALL_OW 247
86330: PUSH
86331: LD_INT 1
86333: EQUAL
86334: IFFALSE 86380
// begin to_heal := to_heal diff group [ i ] ;
86336: LD_ADDR_VAR 0 30
86340: PUSH
86341: LD_VAR 0 30
86345: PUSH
86346: LD_VAR 0 4
86350: PUSH
86351: LD_VAR 0 7
86355: ARRAY
86356: DIFF
86357: ST_TO_ADDR
// healers := healers diff group [ i ] ;
86358: LD_ADDR_VAR 0 31
86362: PUSH
86363: LD_VAR 0 31
86367: PUSH
86368: LD_VAR 0 4
86372: PUSH
86373: LD_VAR 0 7
86377: ARRAY
86378: DIFF
86379: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
86380: LD_ADDR_VAR 0 4
86384: PUSH
86385: LD_VAR 0 4
86389: PPUSH
86390: LD_VAR 0 7
86394: PPUSH
86395: CALL_OW 3
86399: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
86400: LD_ADDR_VAR 0 16
86404: PUSH
86405: LD_VAR 0 16
86409: PPUSH
86410: LD_VAR 0 7
86414: PPUSH
86415: CALL_OW 3
86419: ST_TO_ADDR
// continue ;
86420: GO 86258
// end ; if f_repair then
86422: LD_VAR 0 22
86426: IFFALSE 86923
// begin if GetType ( group [ i ] ) = unit_vehicle then
86428: LD_VAR 0 4
86432: PUSH
86433: LD_VAR 0 7
86437: ARRAY
86438: PPUSH
86439: CALL_OW 247
86443: PUSH
86444: LD_INT 2
86446: EQUAL
86447: IFFALSE 86641
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
86449: LD_VAR 0 4
86453: PUSH
86454: LD_VAR 0 7
86458: ARRAY
86459: PPUSH
86460: CALL_OW 256
86464: PUSH
86465: LD_INT 700
86467: LESS
86468: IFFALSE 86489
86470: PUSH
86471: LD_VAR 0 4
86475: PUSH
86476: LD_VAR 0 7
86480: ARRAY
86481: PUSH
86482: LD_VAR 0 32
86486: IN
86487: NOT
86488: AND
86489: IFFALSE 86513
// to_repair := to_repair union group [ i ] ;
86491: LD_ADDR_VAR 0 32
86495: PUSH
86496: LD_VAR 0 32
86500: PUSH
86501: LD_VAR 0 4
86505: PUSH
86506: LD_VAR 0 7
86510: ARRAY
86511: UNION
86512: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
86513: LD_VAR 0 4
86517: PUSH
86518: LD_VAR 0 7
86522: ARRAY
86523: PPUSH
86524: CALL_OW 256
86528: PUSH
86529: LD_INT 1000
86531: EQUAL
86532: IFFALSE 86552
86534: PUSH
86535: LD_VAR 0 4
86539: PUSH
86540: LD_VAR 0 7
86544: ARRAY
86545: PUSH
86546: LD_VAR 0 32
86550: IN
86551: AND
86552: IFFALSE 86576
// to_repair := to_repair diff group [ i ] ;
86554: LD_ADDR_VAR 0 32
86558: PUSH
86559: LD_VAR 0 32
86563: PUSH
86564: LD_VAR 0 4
86568: PUSH
86569: LD_VAR 0 7
86573: ARRAY
86574: DIFF
86575: ST_TO_ADDR
// if group [ i ] in to_repair then
86576: LD_VAR 0 4
86580: PUSH
86581: LD_VAR 0 7
86585: ARRAY
86586: PUSH
86587: LD_VAR 0 32
86591: IN
86592: IFFALSE 86639
// begin if not IsInArea ( group [ i ] , f_repair ) then
86594: LD_VAR 0 4
86598: PUSH
86599: LD_VAR 0 7
86603: ARRAY
86604: PPUSH
86605: LD_VAR 0 22
86609: PPUSH
86610: CALL_OW 308
86614: NOT
86615: IFFALSE 86637
// ComMoveToArea ( group [ i ] , f_repair ) ;
86617: LD_VAR 0 4
86621: PUSH
86622: LD_VAR 0 7
86626: ARRAY
86627: PPUSH
86628: LD_VAR 0 22
86632: PPUSH
86633: CALL_OW 113
// continue ;
86637: GO 86258
// end ; end else
86639: GO 86923
// if group [ i ] in repairs then
86641: LD_VAR 0 4
86645: PUSH
86646: LD_VAR 0 7
86650: ARRAY
86651: PUSH
86652: LD_VAR 0 33
86656: IN
86657: IFFALSE 86923
// begin if IsInUnit ( group [ i ] ) then
86659: LD_VAR 0 4
86663: PUSH
86664: LD_VAR 0 7
86668: ARRAY
86669: PPUSH
86670: CALL_OW 310
86674: IFFALSE 86744
// begin z := IsInUnit ( group [ i ] ) ;
86676: LD_ADDR_VAR 0 13
86680: PUSH
86681: LD_VAR 0 4
86685: PUSH
86686: LD_VAR 0 7
86690: ARRAY
86691: PPUSH
86692: CALL_OW 310
86696: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
86697: LD_VAR 0 13
86701: PUSH
86702: LD_VAR 0 32
86706: IN
86707: IFFALSE 86725
86709: PUSH
86710: LD_VAR 0 13
86714: PPUSH
86715: LD_VAR 0 22
86719: PPUSH
86720: CALL_OW 308
86724: AND
86725: IFFALSE 86742
// ComExitVehicle ( group [ i ] ) ;
86727: LD_VAR 0 4
86731: PUSH
86732: LD_VAR 0 7
86736: ARRAY
86737: PPUSH
86738: CALL_OW 121
// end else
86742: GO 86923
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
86744: LD_ADDR_VAR 0 13
86748: PUSH
86749: LD_VAR 0 4
86753: PPUSH
86754: LD_INT 95
86756: PUSH
86757: LD_VAR 0 22
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: LD_INT 58
86768: PUSH
86769: EMPTY
86770: LIST
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PPUSH
86776: CALL_OW 72
86780: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
86781: LD_VAR 0 4
86785: PUSH
86786: LD_VAR 0 7
86790: ARRAY
86791: PPUSH
86792: CALL_OW 314
86796: NOT
86797: IFFALSE 86921
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
86799: LD_ADDR_VAR 0 10
86803: PUSH
86804: LD_VAR 0 13
86808: PPUSH
86809: LD_VAR 0 4
86813: PUSH
86814: LD_VAR 0 7
86818: ARRAY
86819: PPUSH
86820: CALL_OW 74
86824: ST_TO_ADDR
// if not x then
86825: LD_VAR 0 10
86829: NOT
86830: IFFALSE 86834
// continue ;
86832: GO 86258
// if GetLives ( x ) < 1000 then
86834: LD_VAR 0 10
86838: PPUSH
86839: CALL_OW 256
86843: PUSH
86844: LD_INT 1000
86846: LESS
86847: IFFALSE 86871
// ComRepairVehicle ( group [ i ] , x ) else
86849: LD_VAR 0 4
86853: PUSH
86854: LD_VAR 0 7
86858: ARRAY
86859: PPUSH
86860: LD_VAR 0 10
86864: PPUSH
86865: CALL_OW 129
86869: GO 86921
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
86871: LD_VAR 0 23
86875: IFFALSE 86898
86877: PUSH
86878: LD_VAR 0 4
86882: PUSH
86883: LD_VAR 0 7
86887: ARRAY
86888: PPUSH
86889: CALL_OW 256
86893: PUSH
86894: LD_INT 1000
86896: LESS
86897: AND
86898: NOT
86899: IFFALSE 86921
// ComEnterUnit ( group [ i ] , x ) ;
86901: LD_VAR 0 4
86905: PUSH
86906: LD_VAR 0 7
86910: ARRAY
86911: PPUSH
86912: LD_VAR 0 10
86916: PPUSH
86917: CALL_OW 120
// end ; continue ;
86921: GO 86258
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
86923: LD_VAR 0 23
86927: IFFALSE 86950
86929: PUSH
86930: LD_VAR 0 4
86934: PUSH
86935: LD_VAR 0 7
86939: ARRAY
86940: PPUSH
86941: CALL_OW 247
86945: PUSH
86946: LD_INT 1
86948: EQUAL
86949: AND
86950: IFFALSE 87434
// begin if group [ i ] in healers then
86952: LD_VAR 0 4
86956: PUSH
86957: LD_VAR 0 7
86961: ARRAY
86962: PUSH
86963: LD_VAR 0 31
86967: IN
86968: IFFALSE 87245
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
86970: LD_VAR 0 4
86974: PUSH
86975: LD_VAR 0 7
86979: ARRAY
86980: PPUSH
86981: LD_VAR 0 23
86985: PPUSH
86986: CALL_OW 308
86990: NOT
86991: IFFALSE 87011
86993: PUSH
86994: LD_VAR 0 4
86998: PUSH
86999: LD_VAR 0 7
87003: ARRAY
87004: PPUSH
87005: CALL_OW 314
87009: NOT
87010: AND
87011: IFFALSE 87035
// ComMoveToArea ( group [ i ] , f_heal ) else
87013: LD_VAR 0 4
87017: PUSH
87018: LD_VAR 0 7
87022: ARRAY
87023: PPUSH
87024: LD_VAR 0 23
87028: PPUSH
87029: CALL_OW 113
87033: GO 87243
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
87035: LD_VAR 0 4
87039: PUSH
87040: LD_VAR 0 7
87044: ARRAY
87045: PPUSH
87046: CALL 46659 0 1
87050: PPUSH
87051: CALL_OW 256
87055: PUSH
87056: LD_INT 1000
87058: EQUAL
87059: IFFALSE 87078
// ComStop ( group [ i ] ) else
87061: LD_VAR 0 4
87065: PUSH
87066: LD_VAR 0 7
87070: ARRAY
87071: PPUSH
87072: CALL_OW 141
87076: GO 87243
// if not HasTask ( group [ i ] ) and to_heal then
87078: LD_VAR 0 4
87082: PUSH
87083: LD_VAR 0 7
87087: ARRAY
87088: PPUSH
87089: CALL_OW 314
87093: NOT
87094: IFFALSE 87102
87096: PUSH
87097: LD_VAR 0 30
87101: AND
87102: IFFALSE 87243
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
87104: LD_ADDR_VAR 0 13
87108: PUSH
87109: LD_VAR 0 30
87113: PPUSH
87114: LD_INT 3
87116: PUSH
87117: LD_INT 54
87119: PUSH
87120: EMPTY
87121: LIST
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: PPUSH
87127: CALL_OW 72
87131: PPUSH
87132: LD_VAR 0 4
87136: PUSH
87137: LD_VAR 0 7
87141: ARRAY
87142: PPUSH
87143: CALL_OW 74
87147: ST_TO_ADDR
// if z then
87148: LD_VAR 0 13
87152: IFFALSE 87243
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
87154: LD_INT 91
87156: PUSH
87157: LD_VAR 0 13
87161: PUSH
87162: LD_INT 10
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 81
87172: PUSH
87173: LD_VAR 0 13
87177: PPUSH
87178: CALL_OW 255
87182: PUSH
87183: EMPTY
87184: LIST
87185: LIST
87186: PUSH
87187: EMPTY
87188: LIST
87189: LIST
87190: PPUSH
87191: CALL_OW 69
87195: PUSH
87196: LD_INT 0
87198: EQUAL
87199: IFFALSE 87223
// ComHeal ( group [ i ] , z ) else
87201: LD_VAR 0 4
87205: PUSH
87206: LD_VAR 0 7
87210: ARRAY
87211: PPUSH
87212: LD_VAR 0 13
87216: PPUSH
87217: CALL_OW 128
87221: GO 87243
// ComMoveToArea ( group [ i ] , f_heal ) ;
87223: LD_VAR 0 4
87227: PUSH
87228: LD_VAR 0 7
87232: ARRAY
87233: PPUSH
87234: LD_VAR 0 23
87238: PPUSH
87239: CALL_OW 113
// end ; continue ;
87243: GO 86258
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
87245: LD_VAR 0 4
87249: PUSH
87250: LD_VAR 0 7
87254: ARRAY
87255: PPUSH
87256: CALL_OW 256
87260: PUSH
87261: LD_INT 700
87263: LESS
87264: IFFALSE 87285
87266: PUSH
87267: LD_VAR 0 4
87271: PUSH
87272: LD_VAR 0 7
87276: ARRAY
87277: PUSH
87278: LD_VAR 0 30
87282: IN
87283: NOT
87284: AND
87285: IFFALSE 87309
// to_heal := to_heal union group [ i ] ;
87287: LD_ADDR_VAR 0 30
87291: PUSH
87292: LD_VAR 0 30
87296: PUSH
87297: LD_VAR 0 4
87301: PUSH
87302: LD_VAR 0 7
87306: ARRAY
87307: UNION
87308: ST_TO_ADDR
// if group [ i ] in to_heal then
87309: LD_VAR 0 4
87313: PUSH
87314: LD_VAR 0 7
87318: ARRAY
87319: PUSH
87320: LD_VAR 0 30
87324: IN
87325: IFFALSE 87434
// begin if GetLives ( group [ i ] ) = 1000 then
87327: LD_VAR 0 4
87331: PUSH
87332: LD_VAR 0 7
87336: ARRAY
87337: PPUSH
87338: CALL_OW 256
87342: PUSH
87343: LD_INT 1000
87345: EQUAL
87346: IFFALSE 87372
// to_heal := to_heal diff group [ i ] else
87348: LD_ADDR_VAR 0 30
87352: PUSH
87353: LD_VAR 0 30
87357: PUSH
87358: LD_VAR 0 4
87362: PUSH
87363: LD_VAR 0 7
87367: ARRAY
87368: DIFF
87369: ST_TO_ADDR
87370: GO 87434
// begin if not IsInArea ( group [ i ] , to_heal ) then
87372: LD_VAR 0 4
87376: PUSH
87377: LD_VAR 0 7
87381: ARRAY
87382: PPUSH
87383: LD_VAR 0 30
87387: PPUSH
87388: CALL_OW 308
87392: NOT
87393: IFFALSE 87417
// ComMoveToArea ( group [ i ] , f_heal ) else
87395: LD_VAR 0 4
87399: PUSH
87400: LD_VAR 0 7
87404: ARRAY
87405: PPUSH
87406: LD_VAR 0 23
87410: PPUSH
87411: CALL_OW 113
87415: GO 87432
// ComHold ( group [ i ] ) ;
87417: LD_VAR 0 4
87421: PUSH
87422: LD_VAR 0 7
87426: ARRAY
87427: PPUSH
87428: CALL_OW 140
// continue ;
87432: GO 86258
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
87434: LD_VAR 0 4
87438: PUSH
87439: LD_VAR 0 7
87443: ARRAY
87444: PPUSH
87445: LD_INT 10
87447: PPUSH
87448: CALL 44268 0 2
87452: NOT
87453: IFFALSE 87471
87455: PUSH
87456: LD_VAR 0 16
87460: PUSH
87461: LD_VAR 0 7
87465: ARRAY
87466: PUSH
87467: EMPTY
87468: EQUAL
87469: NOT
87470: AND
87471: IFFALSE 87737
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
87473: LD_VAR 0 4
87477: PUSH
87478: LD_VAR 0 7
87482: ARRAY
87483: PPUSH
87484: CALL_OW 262
87488: PUSH
87489: LD_INT 1
87491: PUSH
87492: LD_INT 2
87494: PUSH
87495: EMPTY
87496: LIST
87497: LIST
87498: IN
87499: IFFALSE 87540
// if GetFuel ( group [ i ] ) < 10 then
87501: LD_VAR 0 4
87505: PUSH
87506: LD_VAR 0 7
87510: ARRAY
87511: PPUSH
87512: CALL_OW 261
87516: PUSH
87517: LD_INT 10
87519: LESS
87520: IFFALSE 87540
// SetFuel ( group [ i ] , 12 ) ;
87522: LD_VAR 0 4
87526: PUSH
87527: LD_VAR 0 7
87531: ARRAY
87532: PPUSH
87533: LD_INT 12
87535: PPUSH
87536: CALL_OW 240
// if units_path [ i ] then
87540: LD_VAR 0 16
87544: PUSH
87545: LD_VAR 0 7
87549: ARRAY
87550: IFFALSE 87735
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
87552: LD_VAR 0 4
87556: PUSH
87557: LD_VAR 0 7
87561: ARRAY
87562: PPUSH
87563: LD_VAR 0 16
87567: PUSH
87568: LD_VAR 0 7
87572: ARRAY
87573: PUSH
87574: LD_INT 1
87576: ARRAY
87577: PUSH
87578: LD_INT 1
87580: ARRAY
87581: PPUSH
87582: LD_VAR 0 16
87586: PUSH
87587: LD_VAR 0 7
87591: ARRAY
87592: PUSH
87593: LD_INT 1
87595: ARRAY
87596: PUSH
87597: LD_INT 2
87599: ARRAY
87600: PPUSH
87601: CALL_OW 297
87605: PUSH
87606: LD_INT 6
87608: GREATER
87609: IFFALSE 87684
// begin if not HasTask ( group [ i ] ) then
87611: LD_VAR 0 4
87615: PUSH
87616: LD_VAR 0 7
87620: ARRAY
87621: PPUSH
87622: CALL_OW 314
87626: NOT
87627: IFFALSE 87682
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
87629: LD_VAR 0 4
87633: PUSH
87634: LD_VAR 0 7
87638: ARRAY
87639: PPUSH
87640: LD_VAR 0 16
87644: PUSH
87645: LD_VAR 0 7
87649: ARRAY
87650: PUSH
87651: LD_INT 1
87653: ARRAY
87654: PUSH
87655: LD_INT 1
87657: ARRAY
87658: PPUSH
87659: LD_VAR 0 16
87663: PUSH
87664: LD_VAR 0 7
87668: ARRAY
87669: PUSH
87670: LD_INT 1
87672: ARRAY
87673: PUSH
87674: LD_INT 2
87676: ARRAY
87677: PPUSH
87678: CALL_OW 114
// end else
87682: GO 87735
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
87684: LD_ADDR_VAR 0 15
87688: PUSH
87689: LD_VAR 0 16
87693: PUSH
87694: LD_VAR 0 7
87698: ARRAY
87699: PPUSH
87700: LD_INT 1
87702: PPUSH
87703: CALL_OW 3
87707: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
87708: LD_ADDR_VAR 0 16
87712: PUSH
87713: LD_VAR 0 16
87717: PPUSH
87718: LD_VAR 0 7
87722: PPUSH
87723: LD_VAR 0 15
87727: PPUSH
87728: CALL_OW 1
87732: ST_TO_ADDR
// continue ;
87733: GO 86258
// end ; end ; end else
87735: GO 90433
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
87737: LD_ADDR_VAR 0 14
87741: PUSH
87742: LD_INT 81
87744: PUSH
87745: LD_VAR 0 4
87749: PUSH
87750: LD_VAR 0 7
87754: ARRAY
87755: PPUSH
87756: CALL_OW 255
87760: PUSH
87761: EMPTY
87762: LIST
87763: LIST
87764: PPUSH
87765: CALL_OW 69
87769: ST_TO_ADDR
// if not tmp then
87770: LD_VAR 0 14
87774: NOT
87775: IFFALSE 87779
// continue ;
87777: GO 86258
// if f_ignore_area then
87779: LD_VAR 0 17
87783: IFFALSE 87871
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
87785: LD_ADDR_VAR 0 15
87789: PUSH
87790: LD_VAR 0 14
87794: PPUSH
87795: LD_INT 3
87797: PUSH
87798: LD_INT 92
87800: PUSH
87801: LD_VAR 0 17
87805: PUSH
87806: LD_INT 1
87808: ARRAY
87809: PUSH
87810: LD_VAR 0 17
87814: PUSH
87815: LD_INT 2
87817: ARRAY
87818: PUSH
87819: LD_VAR 0 17
87823: PUSH
87824: LD_INT 3
87826: ARRAY
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PPUSH
87838: CALL_OW 72
87842: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87843: LD_VAR 0 14
87847: PUSH
87848: LD_VAR 0 15
87852: DIFF
87853: IFFALSE 87871
// tmp := tmp diff tmp2 ;
87855: LD_ADDR_VAR 0 14
87859: PUSH
87860: LD_VAR 0 14
87864: PUSH
87865: LD_VAR 0 15
87869: DIFF
87870: ST_TO_ADDR
// end ; if not f_murder then
87871: LD_VAR 0 20
87875: NOT
87876: IFFALSE 87934
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
87878: LD_ADDR_VAR 0 15
87882: PUSH
87883: LD_VAR 0 14
87887: PPUSH
87888: LD_INT 3
87890: PUSH
87891: LD_INT 50
87893: PUSH
87894: EMPTY
87895: LIST
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: PPUSH
87901: CALL_OW 72
87905: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
87906: LD_VAR 0 14
87910: PUSH
87911: LD_VAR 0 15
87915: DIFF
87916: IFFALSE 87934
// tmp := tmp diff tmp2 ;
87918: LD_ADDR_VAR 0 14
87922: PUSH
87923: LD_VAR 0 14
87927: PUSH
87928: LD_VAR 0 15
87932: DIFF
87933: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
87934: LD_ADDR_VAR 0 14
87938: PUSH
87939: LD_VAR 0 4
87943: PUSH
87944: LD_VAR 0 7
87948: ARRAY
87949: PPUSH
87950: LD_VAR 0 14
87954: PPUSH
87955: LD_INT 1
87957: PPUSH
87958: LD_INT 1
87960: PPUSH
87961: CALL 16690 0 4
87965: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
87966: LD_VAR 0 4
87970: PUSH
87971: LD_VAR 0 7
87975: ARRAY
87976: PPUSH
87977: CALL_OW 257
87981: PUSH
87982: LD_INT 1
87984: EQUAL
87985: IFFALSE 88445
// begin if WantPlant ( group [ i ] ) then
87987: LD_VAR 0 4
87991: PUSH
87992: LD_VAR 0 7
87996: ARRAY
87997: PPUSH
87998: CALL 16191 0 1
88002: IFFALSE 88006
// continue ;
88004: GO 86258
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
88006: LD_VAR 0 18
88010: IFFALSE 88030
88012: PUSH
88013: LD_VAR 0 4
88017: PUSH
88018: LD_VAR 0 7
88022: ARRAY
88023: PPUSH
88024: CALL_OW 310
88028: NOT
88029: AND
88030: IFFALSE 88073
88032: PUSH
88033: LD_VAR 0 14
88037: PUSH
88038: LD_INT 1
88040: ARRAY
88041: PUSH
88042: LD_VAR 0 14
88046: PPUSH
88047: LD_INT 21
88049: PUSH
88050: LD_INT 2
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 58
88059: PUSH
88060: EMPTY
88061: LIST
88062: PUSH
88063: EMPTY
88064: LIST
88065: LIST
88066: PPUSH
88067: CALL_OW 72
88071: IN
88072: AND
88073: IFFALSE 88109
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
88075: LD_VAR 0 4
88079: PUSH
88080: LD_VAR 0 7
88084: ARRAY
88085: PPUSH
88086: LD_VAR 0 14
88090: PUSH
88091: LD_INT 1
88093: ARRAY
88094: PPUSH
88095: CALL_OW 120
// attacking := true ;
88099: LD_ADDR_VAR 0 29
88103: PUSH
88104: LD_INT 1
88106: ST_TO_ADDR
// continue ;
88107: GO 86258
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
88109: LD_VAR 0 26
88113: IFFALSE 88136
88115: PUSH
88116: LD_VAR 0 4
88120: PUSH
88121: LD_VAR 0 7
88125: ARRAY
88126: PPUSH
88127: CALL_OW 257
88131: PUSH
88132: LD_INT 1
88134: EQUAL
88135: AND
88136: IFFALSE 88159
88138: PUSH
88139: LD_VAR 0 4
88143: PUSH
88144: LD_VAR 0 7
88148: ARRAY
88149: PPUSH
88150: CALL_OW 256
88154: PUSH
88155: LD_INT 800
88157: LESS
88158: AND
88159: IFFALSE 88179
88161: PUSH
88162: LD_VAR 0 4
88166: PUSH
88167: LD_VAR 0 7
88171: ARRAY
88172: PPUSH
88173: CALL_OW 318
88177: NOT
88178: AND
88179: IFFALSE 88196
// ComCrawl ( group [ i ] ) ;
88181: LD_VAR 0 4
88185: PUSH
88186: LD_VAR 0 7
88190: ARRAY
88191: PPUSH
88192: CALL_OW 137
// if f_mines then
88196: LD_VAR 0 21
88200: IFFALSE 88445
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
88202: LD_VAR 0 14
88206: PUSH
88207: LD_INT 1
88209: ARRAY
88210: PPUSH
88211: CALL_OW 247
88215: PUSH
88216: LD_INT 3
88218: EQUAL
88219: IFFALSE 88238
88221: PUSH
88222: LD_VAR 0 14
88226: PUSH
88227: LD_INT 1
88229: ARRAY
88230: PUSH
88231: LD_VAR 0 27
88235: IN
88236: NOT
88237: AND
88238: IFFALSE 88445
// begin x := GetX ( tmp [ 1 ] ) ;
88240: LD_ADDR_VAR 0 10
88244: PUSH
88245: LD_VAR 0 14
88249: PUSH
88250: LD_INT 1
88252: ARRAY
88253: PPUSH
88254: CALL_OW 250
88258: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
88259: LD_ADDR_VAR 0 11
88263: PUSH
88264: LD_VAR 0 14
88268: PUSH
88269: LD_INT 1
88271: ARRAY
88272: PPUSH
88273: CALL_OW 251
88277: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
88278: LD_ADDR_VAR 0 12
88282: PUSH
88283: LD_VAR 0 4
88287: PUSH
88288: LD_VAR 0 7
88292: ARRAY
88293: PPUSH
88294: CALL 44353 0 1
88298: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
88299: LD_VAR 0 4
88303: PUSH
88304: LD_VAR 0 7
88308: ARRAY
88309: PPUSH
88310: LD_VAR 0 10
88314: PPUSH
88315: LD_VAR 0 11
88319: PPUSH
88320: LD_VAR 0 14
88324: PUSH
88325: LD_INT 1
88327: ARRAY
88328: PPUSH
88329: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
88333: LD_VAR 0 4
88337: PUSH
88338: LD_VAR 0 7
88342: ARRAY
88343: PPUSH
88344: LD_VAR 0 10
88348: PPUSH
88349: LD_VAR 0 12
88353: PPUSH
88354: LD_INT 7
88356: PPUSH
88357: CALL_OW 272
88361: PPUSH
88362: LD_VAR 0 11
88366: PPUSH
88367: LD_VAR 0 12
88371: PPUSH
88372: LD_INT 7
88374: PPUSH
88375: CALL_OW 273
88379: PPUSH
88380: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
88384: LD_VAR 0 4
88388: PUSH
88389: LD_VAR 0 7
88393: ARRAY
88394: PPUSH
88395: LD_INT 71
88397: PPUSH
88398: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
88402: LD_ADDR_VAR 0 27
88406: PUSH
88407: LD_VAR 0 27
88411: PPUSH
88412: LD_VAR 0 27
88416: PUSH
88417: LD_INT 1
88419: PLUS
88420: PPUSH
88421: LD_VAR 0 14
88425: PUSH
88426: LD_INT 1
88428: ARRAY
88429: PPUSH
88430: CALL_OW 1
88434: ST_TO_ADDR
// attacking := true ;
88435: LD_ADDR_VAR 0 29
88439: PUSH
88440: LD_INT 1
88442: ST_TO_ADDR
// continue ;
88443: GO 86258
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
88445: LD_VAR 0 4
88449: PUSH
88450: LD_VAR 0 7
88454: ARRAY
88455: PPUSH
88456: CALL_OW 257
88460: PUSH
88461: LD_INT 17
88463: EQUAL
88464: IFFALSE 88488
88466: PUSH
88467: LD_VAR 0 4
88471: PUSH
88472: LD_VAR 0 7
88476: ARRAY
88477: PPUSH
88478: CALL_OW 110
88482: PUSH
88483: LD_INT 71
88485: EQUAL
88486: NOT
88487: AND
88488: IFFALSE 88634
// begin attacking := false ;
88490: LD_ADDR_VAR 0 29
88494: PUSH
88495: LD_INT 0
88497: ST_TO_ADDR
// k := 5 ;
88498: LD_ADDR_VAR 0 9
88502: PUSH
88503: LD_INT 5
88505: ST_TO_ADDR
// if tmp < k then
88506: LD_VAR 0 14
88510: PUSH
88511: LD_VAR 0 9
88515: LESS
88516: IFFALSE 88528
// k := tmp ;
88518: LD_ADDR_VAR 0 9
88522: PUSH
88523: LD_VAR 0 14
88527: ST_TO_ADDR
// for j = 1 to k do
88528: LD_ADDR_VAR 0 8
88532: PUSH
88533: DOUBLE
88534: LD_INT 1
88536: DEC
88537: ST_TO_ADDR
88538: LD_VAR 0 9
88542: PUSH
88543: FOR_TO
88544: IFFALSE 88632
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
88546: LD_VAR 0 14
88550: PUSH
88551: LD_VAR 0 8
88555: ARRAY
88556: PUSH
88557: LD_VAR 0 14
88561: PPUSH
88562: LD_INT 58
88564: PUSH
88565: EMPTY
88566: LIST
88567: PPUSH
88568: CALL_OW 72
88572: IN
88573: NOT
88574: IFFALSE 88630
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
88576: LD_VAR 0 4
88580: PUSH
88581: LD_VAR 0 7
88585: ARRAY
88586: PPUSH
88587: LD_VAR 0 14
88591: PUSH
88592: LD_VAR 0 8
88596: ARRAY
88597: PPUSH
88598: CALL_OW 115
// attacking := true ;
88602: LD_ADDR_VAR 0 29
88606: PUSH
88607: LD_INT 1
88609: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
88610: LD_VAR 0 4
88614: PUSH
88615: LD_VAR 0 7
88619: ARRAY
88620: PPUSH
88621: LD_INT 71
88623: PPUSH
88624: CALL_OW 109
// continue ;
88628: GO 88543
// end ; end ;
88630: GO 88543
88632: POP
88633: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
88634: LD_VAR 0 4
88638: PUSH
88639: LD_VAR 0 7
88643: ARRAY
88644: PPUSH
88645: CALL_OW 257
88649: PUSH
88650: LD_INT 8
88652: EQUAL
88653: IFTRUE 88691
88655: PUSH
88656: LD_VAR 0 4
88660: PUSH
88661: LD_VAR 0 7
88665: ARRAY
88666: PPUSH
88667: CALL_OW 264
88671: PUSH
88672: LD_INT 28
88674: PUSH
88675: LD_INT 45
88677: PUSH
88678: LD_INT 7
88680: PUSH
88681: LD_INT 47
88683: PUSH
88684: EMPTY
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: IN
88690: OR
88691: IFFALSE 88947
// begin attacking := false ;
88693: LD_ADDR_VAR 0 29
88697: PUSH
88698: LD_INT 0
88700: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
88701: LD_VAR 0 14
88705: PUSH
88706: LD_INT 1
88708: ARRAY
88709: PPUSH
88710: CALL_OW 266
88714: PUSH
88715: LD_INT 32
88717: PUSH
88718: LD_INT 31
88720: PUSH
88721: LD_INT 33
88723: PUSH
88724: LD_INT 4
88726: PUSH
88727: LD_INT 5
88729: PUSH
88730: EMPTY
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: IN
88737: IFFALSE 88923
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
88739: LD_ADDR_VAR 0 9
88743: PUSH
88744: LD_VAR 0 14
88748: PUSH
88749: LD_INT 1
88751: ARRAY
88752: PPUSH
88753: CALL_OW 266
88757: PPUSH
88758: LD_VAR 0 14
88762: PUSH
88763: LD_INT 1
88765: ARRAY
88766: PPUSH
88767: CALL_OW 250
88771: PPUSH
88772: LD_VAR 0 14
88776: PUSH
88777: LD_INT 1
88779: ARRAY
88780: PPUSH
88781: CALL_OW 251
88785: PPUSH
88786: LD_VAR 0 14
88790: PUSH
88791: LD_INT 1
88793: ARRAY
88794: PPUSH
88795: CALL_OW 254
88799: PPUSH
88800: LD_VAR 0 14
88804: PUSH
88805: LD_INT 1
88807: ARRAY
88808: PPUSH
88809: CALL_OW 248
88813: PPUSH
88814: LD_INT 0
88816: PPUSH
88817: CALL 25711 0 6
88821: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
88822: LD_ADDR_VAR 0 8
88826: PUSH
88827: LD_VAR 0 4
88831: PUSH
88832: LD_VAR 0 7
88836: ARRAY
88837: PPUSH
88838: LD_VAR 0 9
88842: PPUSH
88843: CALL 44466 0 2
88847: ST_TO_ADDR
// if j then
88848: LD_VAR 0 8
88852: IFFALSE 88921
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
88854: LD_VAR 0 8
88858: PUSH
88859: LD_INT 1
88861: ARRAY
88862: PPUSH
88863: LD_VAR 0 8
88867: PUSH
88868: LD_INT 2
88870: ARRAY
88871: PPUSH
88872: CALL_OW 488
88876: IFFALSE 88921
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
88878: LD_VAR 0 4
88882: PUSH
88883: LD_VAR 0 7
88887: ARRAY
88888: PPUSH
88889: LD_VAR 0 8
88893: PUSH
88894: LD_INT 1
88896: ARRAY
88897: PPUSH
88898: LD_VAR 0 8
88902: PUSH
88903: LD_INT 2
88905: ARRAY
88906: PPUSH
88907: CALL_OW 116
// attacking := true ;
88911: LD_ADDR_VAR 0 29
88915: PUSH
88916: LD_INT 1
88918: ST_TO_ADDR
// continue ;
88919: GO 86258
// end ; end else
88921: GO 88947
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
88923: LD_VAR 0 4
88927: PUSH
88928: LD_VAR 0 7
88932: ARRAY
88933: PPUSH
88934: LD_VAR 0 14
88938: PUSH
88939: LD_INT 1
88941: ARRAY
88942: PPUSH
88943: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
88947: LD_VAR 0 4
88951: PUSH
88952: LD_VAR 0 7
88956: ARRAY
88957: PPUSH
88958: CALL_OW 265
88962: PUSH
88963: LD_INT 11
88965: EQUAL
88966: IFFALSE 89244
// begin k := 10 ;
88968: LD_ADDR_VAR 0 9
88972: PUSH
88973: LD_INT 10
88975: ST_TO_ADDR
// x := 0 ;
88976: LD_ADDR_VAR 0 10
88980: PUSH
88981: LD_INT 0
88983: ST_TO_ADDR
// if tmp < k then
88984: LD_VAR 0 14
88988: PUSH
88989: LD_VAR 0 9
88993: LESS
88994: IFFALSE 89006
// k := tmp ;
88996: LD_ADDR_VAR 0 9
89000: PUSH
89001: LD_VAR 0 14
89005: ST_TO_ADDR
// for j = k downto 1 do
89006: LD_ADDR_VAR 0 8
89010: PUSH
89011: DOUBLE
89012: LD_VAR 0 9
89016: INC
89017: ST_TO_ADDR
89018: LD_INT 1
89020: PUSH
89021: FOR_DOWNTO
89022: IFFALSE 89097
// begin if GetType ( tmp [ j ] ) = unit_human then
89024: LD_VAR 0 14
89028: PUSH
89029: LD_VAR 0 8
89033: ARRAY
89034: PPUSH
89035: CALL_OW 247
89039: PUSH
89040: LD_INT 1
89042: EQUAL
89043: IFFALSE 89095
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
89045: LD_VAR 0 4
89049: PUSH
89050: LD_VAR 0 7
89054: ARRAY
89055: PPUSH
89056: LD_VAR 0 14
89060: PUSH
89061: LD_VAR 0 8
89065: ARRAY
89066: PPUSH
89067: CALL 44724 0 2
// x := tmp [ j ] ;
89071: LD_ADDR_VAR 0 10
89075: PUSH
89076: LD_VAR 0 14
89080: PUSH
89081: LD_VAR 0 8
89085: ARRAY
89086: ST_TO_ADDR
// attacking := true ;
89087: LD_ADDR_VAR 0 29
89091: PUSH
89092: LD_INT 1
89094: ST_TO_ADDR
// end ; end ;
89095: GO 89021
89097: POP
89098: POP
// if not x then
89099: LD_VAR 0 10
89103: NOT
89104: IFFALSE 89244
// begin attacking := true ;
89106: LD_ADDR_VAR 0 29
89110: PUSH
89111: LD_INT 1
89113: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
89114: LD_VAR 0 4
89118: PUSH
89119: LD_VAR 0 7
89123: ARRAY
89124: PPUSH
89125: CALL_OW 250
89129: PPUSH
89130: LD_VAR 0 4
89134: PUSH
89135: LD_VAR 0 7
89139: ARRAY
89140: PPUSH
89141: CALL_OW 251
89145: PPUSH
89146: CALL_OW 546
89150: PUSH
89151: LD_INT 2
89153: ARRAY
89154: PUSH
89155: LD_VAR 0 14
89159: PUSH
89160: LD_INT 1
89162: ARRAY
89163: PPUSH
89164: CALL_OW 250
89168: PPUSH
89169: LD_VAR 0 14
89173: PUSH
89174: LD_INT 1
89176: ARRAY
89177: PPUSH
89178: CALL_OW 251
89182: PPUSH
89183: CALL_OW 546
89187: PUSH
89188: LD_INT 2
89190: ARRAY
89191: EQUAL
89192: IFFALSE 89220
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
89194: LD_VAR 0 4
89198: PUSH
89199: LD_VAR 0 7
89203: ARRAY
89204: PPUSH
89205: LD_VAR 0 14
89209: PUSH
89210: LD_INT 1
89212: ARRAY
89213: PPUSH
89214: CALL 44724 0 2
89218: GO 89244
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89220: LD_VAR 0 4
89224: PUSH
89225: LD_VAR 0 7
89229: ARRAY
89230: PPUSH
89231: LD_VAR 0 14
89235: PUSH
89236: LD_INT 1
89238: ARRAY
89239: PPUSH
89240: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
89244: LD_VAR 0 4
89248: PUSH
89249: LD_VAR 0 7
89253: ARRAY
89254: PPUSH
89255: CALL_OW 264
89259: PUSH
89260: LD_INT 29
89262: EQUAL
89263: IFFALSE 89633
// begin if WantsToAttack ( group [ i ] ) in bombed then
89265: LD_VAR 0 4
89269: PUSH
89270: LD_VAR 0 7
89274: ARRAY
89275: PPUSH
89276: CALL_OW 319
89280: PUSH
89281: LD_VAR 0 28
89285: IN
89286: IFFALSE 89290
// continue ;
89288: GO 86258
// k := 8 ;
89290: LD_ADDR_VAR 0 9
89294: PUSH
89295: LD_INT 8
89297: ST_TO_ADDR
// x := 0 ;
89298: LD_ADDR_VAR 0 10
89302: PUSH
89303: LD_INT 0
89305: ST_TO_ADDR
// if tmp < k then
89306: LD_VAR 0 14
89310: PUSH
89311: LD_VAR 0 9
89315: LESS
89316: IFFALSE 89328
// k := tmp ;
89318: LD_ADDR_VAR 0 9
89322: PUSH
89323: LD_VAR 0 14
89327: ST_TO_ADDR
// for j = 1 to k do
89328: LD_ADDR_VAR 0 8
89332: PUSH
89333: DOUBLE
89334: LD_INT 1
89336: DEC
89337: ST_TO_ADDR
89338: LD_VAR 0 9
89342: PUSH
89343: FOR_TO
89344: IFFALSE 89478
// begin if GetType ( tmp [ j ] ) = unit_building then
89346: LD_VAR 0 14
89350: PUSH
89351: LD_VAR 0 8
89355: ARRAY
89356: PPUSH
89357: CALL_OW 247
89361: PUSH
89362: LD_INT 3
89364: EQUAL
89365: IFFALSE 89476
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
89367: LD_VAR 0 14
89371: PUSH
89372: LD_VAR 0 8
89376: ARRAY
89377: PUSH
89378: LD_VAR 0 28
89382: IN
89383: NOT
89384: IFFALSE 89403
89386: PUSH
89387: LD_VAR 0 14
89391: PUSH
89392: LD_VAR 0 8
89396: ARRAY
89397: PPUSH
89398: CALL_OW 313
89402: AND
89403: IFFALSE 89476
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
89405: LD_VAR 0 4
89409: PUSH
89410: LD_VAR 0 7
89414: ARRAY
89415: PPUSH
89416: LD_VAR 0 14
89420: PUSH
89421: LD_VAR 0 8
89425: ARRAY
89426: PPUSH
89427: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
89431: LD_ADDR_VAR 0 28
89435: PUSH
89436: LD_VAR 0 28
89440: PPUSH
89441: LD_VAR 0 28
89445: PUSH
89446: LD_INT 1
89448: PLUS
89449: PPUSH
89450: LD_VAR 0 14
89454: PUSH
89455: LD_VAR 0 8
89459: ARRAY
89460: PPUSH
89461: CALL_OW 1
89465: ST_TO_ADDR
// attacking := true ;
89466: LD_ADDR_VAR 0 29
89470: PUSH
89471: LD_INT 1
89473: ST_TO_ADDR
// break ;
89474: GO 89478
// end ; end ;
89476: GO 89343
89478: POP
89479: POP
// if not attacking and f_attack_depot then
89480: LD_VAR 0 29
89484: NOT
89485: IFFALSE 89493
89487: PUSH
89488: LD_VAR 0 25
89492: AND
89493: IFFALSE 89588
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
89495: LD_ADDR_VAR 0 13
89499: PUSH
89500: LD_VAR 0 14
89504: PPUSH
89505: LD_INT 2
89507: PUSH
89508: LD_INT 30
89510: PUSH
89511: LD_INT 0
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 30
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: EMPTY
89525: LIST
89526: LIST
89527: PUSH
89528: EMPTY
89529: LIST
89530: LIST
89531: LIST
89532: PPUSH
89533: CALL_OW 72
89537: ST_TO_ADDR
// if z then
89538: LD_VAR 0 13
89542: IFFALSE 89588
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
89544: LD_VAR 0 4
89548: PUSH
89549: LD_VAR 0 7
89553: ARRAY
89554: PPUSH
89555: LD_VAR 0 13
89559: PPUSH
89560: LD_VAR 0 4
89564: PUSH
89565: LD_VAR 0 7
89569: ARRAY
89570: PPUSH
89571: CALL_OW 74
89575: PPUSH
89576: CALL_OW 115
// attacking := true ;
89580: LD_ADDR_VAR 0 29
89584: PUSH
89585: LD_INT 1
89587: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
89588: LD_VAR 0 4
89592: PUSH
89593: LD_VAR 0 7
89597: ARRAY
89598: PPUSH
89599: CALL_OW 256
89603: PUSH
89604: LD_INT 500
89606: LESS
89607: IFFALSE 89633
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
89609: LD_VAR 0 4
89613: PUSH
89614: LD_VAR 0 7
89618: ARRAY
89619: PPUSH
89620: LD_VAR 0 14
89624: PUSH
89625: LD_INT 1
89627: ARRAY
89628: PPUSH
89629: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
89633: LD_VAR 0 4
89637: PUSH
89638: LD_VAR 0 7
89642: ARRAY
89643: PPUSH
89644: CALL_OW 264
89648: PUSH
89649: LD_INT 49
89651: EQUAL
89652: IFFALSE 89773
// begin if not HasTask ( group [ i ] ) then
89654: LD_VAR 0 4
89658: PUSH
89659: LD_VAR 0 7
89663: ARRAY
89664: PPUSH
89665: CALL_OW 314
89669: NOT
89670: IFFALSE 89773
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
89672: LD_ADDR_VAR 0 9
89676: PUSH
89677: LD_INT 81
89679: PUSH
89680: LD_VAR 0 4
89684: PUSH
89685: LD_VAR 0 7
89689: ARRAY
89690: PPUSH
89691: CALL_OW 255
89695: PUSH
89696: EMPTY
89697: LIST
89698: LIST
89699: PPUSH
89700: CALL_OW 69
89704: PPUSH
89705: LD_VAR 0 4
89709: PUSH
89710: LD_VAR 0 7
89714: ARRAY
89715: PPUSH
89716: CALL_OW 74
89720: ST_TO_ADDR
// if k then
89721: LD_VAR 0 9
89725: IFFALSE 89773
// if GetDistUnits ( group [ i ] , k ) > 10 then
89727: LD_VAR 0 4
89731: PUSH
89732: LD_VAR 0 7
89736: ARRAY
89737: PPUSH
89738: LD_VAR 0 9
89742: PPUSH
89743: CALL_OW 296
89747: PUSH
89748: LD_INT 10
89750: GREATER
89751: IFFALSE 89773
// ComMoveUnit ( group [ i ] , k ) ;
89753: LD_VAR 0 4
89757: PUSH
89758: LD_VAR 0 7
89762: ARRAY
89763: PPUSH
89764: LD_VAR 0 9
89768: PPUSH
89769: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
89773: LD_VAR 0 4
89777: PUSH
89778: LD_VAR 0 7
89782: ARRAY
89783: PPUSH
89784: CALL_OW 256
89788: PUSH
89789: LD_INT 250
89791: LESS
89792: IFFALSE 89836
89794: PUSH
89795: LD_VAR 0 4
89799: PUSH
89800: LD_VAR 0 7
89804: ARRAY
89805: PUSH
89806: LD_INT 21
89808: PUSH
89809: LD_INT 2
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: PUSH
89816: LD_INT 23
89818: PUSH
89819: LD_INT 2
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: EMPTY
89827: LIST
89828: LIST
89829: PPUSH
89830: CALL_OW 69
89834: IN
89835: AND
89836: IFFALSE 89963
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
89838: LD_ADDR_VAR 0 9
89842: PUSH
89843: LD_OWVAR 3
89847: PUSH
89848: LD_VAR 0 4
89852: PUSH
89853: LD_VAR 0 7
89857: ARRAY
89858: DIFF
89859: PPUSH
89860: LD_VAR 0 4
89864: PUSH
89865: LD_VAR 0 7
89869: ARRAY
89870: PPUSH
89871: CALL_OW 74
89875: ST_TO_ADDR
// if not k then
89876: LD_VAR 0 9
89880: NOT
89881: IFFALSE 89885
// continue ;
89883: GO 86258
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
89885: LD_VAR 0 9
89889: PUSH
89890: LD_INT 81
89892: PUSH
89893: LD_VAR 0 4
89897: PUSH
89898: LD_VAR 0 7
89902: ARRAY
89903: PPUSH
89904: CALL_OW 255
89908: PUSH
89909: EMPTY
89910: LIST
89911: LIST
89912: PPUSH
89913: CALL_OW 69
89917: IN
89918: IFFALSE 89946
89920: PUSH
89921: LD_VAR 0 9
89925: PPUSH
89926: LD_VAR 0 4
89930: PUSH
89931: LD_VAR 0 7
89935: ARRAY
89936: PPUSH
89937: CALL_OW 296
89941: PUSH
89942: LD_INT 5
89944: LESS
89945: AND
89946: IFFALSE 89963
// ComAutodestruct ( group [ i ] ) ;
89948: LD_VAR 0 4
89952: PUSH
89953: LD_VAR 0 7
89957: ARRAY
89958: PPUSH
89959: CALL 44620 0 1
// end ; if f_attack_depot then
89963: LD_VAR 0 25
89967: IFFALSE 90079
// begin k := 6 ;
89969: LD_ADDR_VAR 0 9
89973: PUSH
89974: LD_INT 6
89976: ST_TO_ADDR
// if tmp < k then
89977: LD_VAR 0 14
89981: PUSH
89982: LD_VAR 0 9
89986: LESS
89987: IFFALSE 89999
// k := tmp ;
89989: LD_ADDR_VAR 0 9
89993: PUSH
89994: LD_VAR 0 14
89998: ST_TO_ADDR
// for j = 1 to k do
89999: LD_ADDR_VAR 0 8
90003: PUSH
90004: DOUBLE
90005: LD_INT 1
90007: DEC
90008: ST_TO_ADDR
90009: LD_VAR 0 9
90013: PUSH
90014: FOR_TO
90015: IFFALSE 90077
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
90017: LD_VAR 0 8
90021: PPUSH
90022: CALL_OW 266
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 1
90032: PUSH
90033: EMPTY
90034: LIST
90035: LIST
90036: IN
90037: IFFALSE 90075
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
90039: LD_VAR 0 4
90043: PUSH
90044: LD_VAR 0 7
90048: ARRAY
90049: PPUSH
90050: LD_VAR 0 14
90054: PUSH
90055: LD_VAR 0 8
90059: ARRAY
90060: PPUSH
90061: CALL_OW 115
// attacking := true ;
90065: LD_ADDR_VAR 0 29
90069: PUSH
90070: LD_INT 1
90072: ST_TO_ADDR
// break ;
90073: GO 90077
// end ;
90075: GO 90014
90077: POP
90078: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
90079: LD_VAR 0 4
90083: PUSH
90084: LD_VAR 0 7
90088: ARRAY
90089: PPUSH
90090: CALL_OW 302
90094: IFFALSE 90103
90096: PUSH
90097: LD_VAR 0 29
90101: NOT
90102: AND
90103: IFFALSE 90433
// begin if GetTag ( group [ i ] ) = 71 then
90105: LD_VAR 0 4
90109: PUSH
90110: LD_VAR 0 7
90114: ARRAY
90115: PPUSH
90116: CALL_OW 110
90120: PUSH
90121: LD_INT 71
90123: EQUAL
90124: IFFALSE 90165
// begin if HasTask ( group [ i ] ) then
90126: LD_VAR 0 4
90130: PUSH
90131: LD_VAR 0 7
90135: ARRAY
90136: PPUSH
90137: CALL_OW 314
90141: IFFALSE 90147
// continue else
90143: GO 86258
90145: GO 90165
// SetTag ( group [ i ] , 0 ) ;
90147: LD_VAR 0 4
90151: PUSH
90152: LD_VAR 0 7
90156: ARRAY
90157: PPUSH
90158: LD_INT 0
90160: PPUSH
90161: CALL_OW 109
// end ; k := 8 ;
90165: LD_ADDR_VAR 0 9
90169: PUSH
90170: LD_INT 8
90172: ST_TO_ADDR
// x := 0 ;
90173: LD_ADDR_VAR 0 10
90177: PUSH
90178: LD_INT 0
90180: ST_TO_ADDR
// if tmp < k then
90181: LD_VAR 0 14
90185: PUSH
90186: LD_VAR 0 9
90190: LESS
90191: IFFALSE 90203
// k := tmp ;
90193: LD_ADDR_VAR 0 9
90197: PUSH
90198: LD_VAR 0 14
90202: ST_TO_ADDR
// for j = 1 to k do
90203: LD_ADDR_VAR 0 8
90207: PUSH
90208: DOUBLE
90209: LD_INT 1
90211: DEC
90212: ST_TO_ADDR
90213: LD_VAR 0 9
90217: PUSH
90218: FOR_TO
90219: IFFALSE 90325
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
90221: LD_VAR 0 14
90225: PUSH
90226: LD_VAR 0 8
90230: ARRAY
90231: PPUSH
90232: CALL_OW 247
90236: PUSH
90237: LD_INT 1
90239: EQUAL
90240: IFFALSE 90303
90242: PUSH
90243: LD_VAR 0 14
90247: PUSH
90248: LD_VAR 0 8
90252: ARRAY
90253: PPUSH
90254: CALL_OW 256
90258: PUSH
90259: LD_INT 250
90261: LESS
90262: IFFALSE 90270
90264: PUSH
90265: LD_VAR 0 20
90269: AND
90270: IFTRUE 90302
90272: PUSH
90273: LD_VAR 0 20
90277: NOT
90278: IFFALSE 90301
90280: PUSH
90281: LD_VAR 0 14
90285: PUSH
90286: LD_VAR 0 8
90290: ARRAY
90291: PPUSH
90292: CALL_OW 256
90296: PUSH
90297: LD_INT 250
90299: GREATEREQUAL
90300: AND
90301: OR
90302: AND
90303: IFFALSE 90323
// begin x := tmp [ j ] ;
90305: LD_ADDR_VAR 0 10
90309: PUSH
90310: LD_VAR 0 14
90314: PUSH
90315: LD_VAR 0 8
90319: ARRAY
90320: ST_TO_ADDR
// break ;
90321: GO 90325
// end ;
90323: GO 90218
90325: POP
90326: POP
// if x then
90327: LD_VAR 0 10
90331: IFFALSE 90355
// ComAttackUnit ( group [ i ] , x ) else
90333: LD_VAR 0 4
90337: PUSH
90338: LD_VAR 0 7
90342: ARRAY
90343: PPUSH
90344: LD_VAR 0 10
90348: PPUSH
90349: CALL_OW 115
90353: GO 90379
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
90355: LD_VAR 0 4
90359: PUSH
90360: LD_VAR 0 7
90364: ARRAY
90365: PPUSH
90366: LD_VAR 0 14
90370: PUSH
90371: LD_INT 1
90373: ARRAY
90374: PPUSH
90375: CALL_OW 115
// if not HasTask ( group [ i ] ) then
90379: LD_VAR 0 4
90383: PUSH
90384: LD_VAR 0 7
90388: ARRAY
90389: PPUSH
90390: CALL_OW 314
90394: NOT
90395: IFFALSE 90433
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
90397: LD_VAR 0 4
90401: PUSH
90402: LD_VAR 0 7
90406: ARRAY
90407: PPUSH
90408: LD_VAR 0 14
90412: PPUSH
90413: LD_VAR 0 4
90417: PUSH
90418: LD_VAR 0 7
90422: ARRAY
90423: PPUSH
90424: CALL_OW 74
90428: PPUSH
90429: CALL_OW 115
// end ; end ; end ;
90433: GO 86258
90435: POP
90436: POP
// wait ( 0 0$2 ) ;
90437: LD_INT 70
90439: PPUSH
90440: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
90444: LD_VAR 0 4
90448: NOT
90449: IFTRUE 90460
90451: PUSH
90452: LD_VAR 0 4
90456: PUSH
90457: EMPTY
90458: EQUAL
90459: OR
90460: IFTRUE 90481
90462: PUSH
90463: LD_INT 81
90465: PUSH
90466: LD_VAR 0 35
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PPUSH
90475: CALL_OW 69
90479: NOT
90480: OR
90481: IFFALSE 86243
// end ;
90483: LD_VAR 0 2
90487: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
90488: LD_INT 0
90490: PPUSH
90491: PPUSH
90492: PPUSH
90493: PPUSH
90494: PPUSH
90495: PPUSH
// if not base or not mc_bases [ base ] or not solds then
90496: LD_VAR 0 1
90500: NOT
90501: IFTRUE 90516
90503: PUSH
90504: LD_EXP 23
90508: PUSH
90509: LD_VAR 0 1
90513: ARRAY
90514: NOT
90515: OR
90516: IFTRUE 90525
90518: PUSH
90519: LD_VAR 0 2
90523: NOT
90524: OR
90525: IFFALSE 90529
// exit ;
90527: GO 91087
// side := mc_sides [ base ] ;
90529: LD_ADDR_VAR 0 6
90533: PUSH
90534: LD_EXP 49
90538: PUSH
90539: LD_VAR 0 1
90543: ARRAY
90544: ST_TO_ADDR
// if not side then
90545: LD_VAR 0 6
90549: NOT
90550: IFFALSE 90554
// exit ;
90552: GO 91087
// for i in solds do
90554: LD_ADDR_VAR 0 7
90558: PUSH
90559: LD_VAR 0 2
90563: PUSH
90564: FOR_IN
90565: IFFALSE 90626
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
90567: LD_VAR 0 7
90571: PPUSH
90572: CALL_OW 310
90576: PPUSH
90577: CALL_OW 266
90581: PUSH
90582: LD_INT 32
90584: PUSH
90585: LD_INT 31
90587: PUSH
90588: EMPTY
90589: LIST
90590: LIST
90591: IN
90592: IFFALSE 90612
// solds := solds diff i else
90594: LD_ADDR_VAR 0 2
90598: PUSH
90599: LD_VAR 0 2
90603: PUSH
90604: LD_VAR 0 7
90608: DIFF
90609: ST_TO_ADDR
90610: GO 90624
// SetTag ( i , 18 ) ;
90612: LD_VAR 0 7
90616: PPUSH
90617: LD_INT 18
90619: PPUSH
90620: CALL_OW 109
90624: GO 90564
90626: POP
90627: POP
// if not solds then
90628: LD_VAR 0 2
90632: NOT
90633: IFFALSE 90637
// exit ;
90635: GO 91087
// repeat wait ( 0 0$2 ) ;
90637: LD_INT 70
90639: PPUSH
90640: CALL_OW 67
// enemy := mc_scan [ base ] ;
90644: LD_ADDR_VAR 0 4
90648: PUSH
90649: LD_EXP 46
90653: PUSH
90654: LD_VAR 0 1
90658: ARRAY
90659: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
90660: LD_EXP 23
90664: PUSH
90665: LD_VAR 0 1
90669: ARRAY
90670: NOT
90671: IFTRUE 90688
90673: PUSH
90674: LD_EXP 23
90678: PUSH
90679: LD_VAR 0 1
90683: ARRAY
90684: PUSH
90685: EMPTY
90686: EQUAL
90687: OR
90688: IFFALSE 90725
// begin for i in solds do
90690: LD_ADDR_VAR 0 7
90694: PUSH
90695: LD_VAR 0 2
90699: PUSH
90700: FOR_IN
90701: IFFALSE 90714
// ComStop ( i ) ;
90703: LD_VAR 0 7
90707: PPUSH
90708: CALL_OW 141
90712: GO 90700
90714: POP
90715: POP
// solds := [ ] ;
90716: LD_ADDR_VAR 0 2
90720: PUSH
90721: EMPTY
90722: ST_TO_ADDR
// exit ;
90723: GO 91087
// end ; for i in solds do
90725: LD_ADDR_VAR 0 7
90729: PUSH
90730: LD_VAR 0 2
90734: PUSH
90735: FOR_IN
90736: IFFALSE 91057
// begin if IsInUnit ( i ) then
90738: LD_VAR 0 7
90742: PPUSH
90743: CALL_OW 310
90747: IFFALSE 90758
// ComExitBuilding ( i ) ;
90749: LD_VAR 0 7
90753: PPUSH
90754: CALL_OW 122
// if GetLives ( i ) > 500 then
90758: LD_VAR 0 7
90762: PPUSH
90763: CALL_OW 256
90767: PUSH
90768: LD_INT 500
90770: GREATER
90771: IFFALSE 90824
// begin e := NearestUnitToUnit ( enemy , i ) ;
90773: LD_ADDR_VAR 0 5
90777: PUSH
90778: LD_VAR 0 4
90782: PPUSH
90783: LD_VAR 0 7
90787: PPUSH
90788: CALL_OW 74
90792: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
90793: LD_VAR 0 7
90797: PPUSH
90798: LD_VAR 0 5
90802: PPUSH
90803: CALL_OW 250
90807: PPUSH
90808: LD_VAR 0 5
90812: PPUSH
90813: CALL_OW 251
90817: PPUSH
90818: CALL_OW 114
// end else
90822: GO 91055
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
90824: LD_VAR 0 7
90828: PPUSH
90829: LD_EXP 23
90833: PUSH
90834: LD_VAR 0 1
90838: ARRAY
90839: PPUSH
90840: LD_INT 2
90842: PUSH
90843: LD_INT 30
90845: PUSH
90846: LD_INT 0
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: PUSH
90853: LD_INT 30
90855: PUSH
90856: LD_INT 1
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 30
90865: PUSH
90866: LD_INT 6
90868: PUSH
90869: EMPTY
90870: LIST
90871: LIST
90872: PUSH
90873: EMPTY
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: PPUSH
90879: CALL_OW 72
90883: PPUSH
90884: LD_VAR 0 7
90888: PPUSH
90889: CALL_OW 74
90893: PPUSH
90894: CALL_OW 296
90898: PUSH
90899: LD_INT 10
90901: GREATER
90902: IFFALSE 91055
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
90904: LD_ADDR_VAR 0 8
90908: PUSH
90909: LD_EXP 23
90913: PUSH
90914: LD_VAR 0 1
90918: ARRAY
90919: PPUSH
90920: LD_INT 2
90922: PUSH
90923: LD_INT 30
90925: PUSH
90926: LD_INT 0
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 30
90935: PUSH
90936: LD_INT 1
90938: PUSH
90939: EMPTY
90940: LIST
90941: LIST
90942: PUSH
90943: LD_INT 30
90945: PUSH
90946: LD_INT 6
90948: PUSH
90949: EMPTY
90950: LIST
90951: LIST
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: PPUSH
90959: CALL_OW 72
90963: PPUSH
90964: LD_VAR 0 7
90968: PPUSH
90969: CALL_OW 74
90973: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
90974: LD_VAR 0 7
90978: PPUSH
90979: LD_VAR 0 8
90983: PPUSH
90984: CALL_OW 250
90988: PPUSH
90989: LD_INT 3
90991: PPUSH
90992: LD_INT 5
90994: PPUSH
90995: CALL_OW 272
90999: PPUSH
91000: LD_VAR 0 8
91004: PPUSH
91005: CALL_OW 251
91009: PPUSH
91010: LD_INT 3
91012: PPUSH
91013: LD_INT 5
91015: PPUSH
91016: CALL_OW 273
91020: PPUSH
91021: CALL_OW 111
// SetTag ( i , 0 ) ;
91025: LD_VAR 0 7
91029: PPUSH
91030: LD_INT 0
91032: PPUSH
91033: CALL_OW 109
// solds := solds diff i ;
91037: LD_ADDR_VAR 0 2
91041: PUSH
91042: LD_VAR 0 2
91046: PUSH
91047: LD_VAR 0 7
91051: DIFF
91052: ST_TO_ADDR
// continue ;
91053: GO 90735
// end ; end ;
91055: GO 90735
91057: POP
91058: POP
// until not solds or not enemy ;
91059: LD_VAR 0 2
91063: NOT
91064: IFTRUE 91073
91066: PUSH
91067: LD_VAR 0 4
91071: NOT
91072: OR
91073: IFFALSE 90637
// MC_Reset ( base , 18 ) ;
91075: LD_VAR 0 1
91079: PPUSH
91080: LD_INT 18
91082: PPUSH
91083: CALL 58826 0 2
// end ;
91087: LD_VAR 0 3
91091: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
91092: LD_INT 0
91094: PPUSH
91095: PPUSH
91096: PPUSH
91097: PPUSH
91098: PPUSH
91099: PPUSH
91100: PPUSH
91101: PPUSH
91102: PPUSH
91103: PPUSH
91104: PPUSH
91105: PPUSH
91106: PPUSH
91107: PPUSH
91108: PPUSH
91109: PPUSH
91110: PPUSH
91111: PPUSH
91112: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
91113: LD_ADDR_VAR 0 12
91117: PUSH
91118: LD_EXP 23
91122: PUSH
91123: LD_VAR 0 1
91127: ARRAY
91128: PPUSH
91129: LD_INT 25
91131: PUSH
91132: LD_INT 3
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PPUSH
91139: CALL_OW 72
91143: ST_TO_ADDR
// if mc_remote_driver [ base ] then
91144: LD_EXP 63
91148: PUSH
91149: LD_VAR 0 1
91153: ARRAY
91154: IFFALSE 91178
// mechs := mechs diff mc_remote_driver [ base ] ;
91156: LD_ADDR_VAR 0 12
91160: PUSH
91161: LD_VAR 0 12
91165: PUSH
91166: LD_EXP 63
91170: PUSH
91171: LD_VAR 0 1
91175: ARRAY
91176: DIFF
91177: ST_TO_ADDR
// for i in mechs do
91178: LD_ADDR_VAR 0 4
91182: PUSH
91183: LD_VAR 0 12
91187: PUSH
91188: FOR_IN
91189: IFFALSE 91224
// if GetTag ( i ) > 0 then
91191: LD_VAR 0 4
91195: PPUSH
91196: CALL_OW 110
91200: PUSH
91201: LD_INT 0
91203: GREATER
91204: IFFALSE 91222
// mechs := mechs diff i ;
91206: LD_ADDR_VAR 0 12
91210: PUSH
91211: LD_VAR 0 12
91215: PUSH
91216: LD_VAR 0 4
91220: DIFF
91221: ST_TO_ADDR
91222: GO 91188
91224: POP
91225: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
91226: LD_ADDR_VAR 0 8
91230: PUSH
91231: LD_EXP 23
91235: PUSH
91236: LD_VAR 0 1
91240: ARRAY
91241: PPUSH
91242: LD_INT 2
91244: PUSH
91245: LD_INT 25
91247: PUSH
91248: LD_INT 1
91250: PUSH
91251: EMPTY
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 25
91257: PUSH
91258: LD_INT 5
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PUSH
91265: LD_INT 25
91267: PUSH
91268: LD_INT 8
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 25
91277: PUSH
91278: LD_INT 9
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: EMPTY
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: LIST
91291: PPUSH
91292: CALL_OW 72
91296: ST_TO_ADDR
// if not defenders and not solds then
91297: LD_VAR 0 2
91301: NOT
91302: IFFALSE 91311
91304: PUSH
91305: LD_VAR 0 8
91309: NOT
91310: AND
91311: IFFALSE 91315
// exit ;
91313: GO 93137
// depot_under_attack := false ;
91315: LD_ADDR_VAR 0 16
91319: PUSH
91320: LD_INT 0
91322: ST_TO_ADDR
// sold_defenders := [ ] ;
91323: LD_ADDR_VAR 0 17
91327: PUSH
91328: EMPTY
91329: ST_TO_ADDR
// if mechs then
91330: LD_VAR 0 12
91334: IFFALSE 91489
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
91336: LD_ADDR_VAR 0 4
91340: PUSH
91341: LD_VAR 0 2
91345: PPUSH
91346: LD_INT 21
91348: PUSH
91349: LD_INT 2
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PPUSH
91356: CALL_OW 72
91360: PUSH
91361: FOR_IN
91362: IFFALSE 91487
// begin if GetTag ( i ) <> 20 then
91364: LD_VAR 0 4
91368: PPUSH
91369: CALL_OW 110
91373: PUSH
91374: LD_INT 20
91376: NONEQUAL
91377: IFFALSE 91391
// SetTag ( i , 20 ) ;
91379: LD_VAR 0 4
91383: PPUSH
91384: LD_INT 20
91386: PPUSH
91387: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
91391: LD_VAR 0 4
91395: PPUSH
91396: CALL_OW 263
91400: PUSH
91401: LD_INT 1
91403: EQUAL
91404: IFFALSE 91418
91406: PUSH
91407: LD_VAR 0 4
91411: PPUSH
91412: CALL_OW 311
91416: NOT
91417: AND
91418: IFFALSE 91485
// begin un := mechs [ 1 ] ;
91420: LD_ADDR_VAR 0 10
91424: PUSH
91425: LD_VAR 0 12
91429: PUSH
91430: LD_INT 1
91432: ARRAY
91433: ST_TO_ADDR
// ComExit ( un ) ;
91434: LD_VAR 0 10
91438: PPUSH
91439: CALL 49701 0 1
// AddComEnterUnit ( un , i ) ;
91443: LD_VAR 0 10
91447: PPUSH
91448: LD_VAR 0 4
91452: PPUSH
91453: CALL_OW 180
// SetTag ( un , 19 ) ;
91457: LD_VAR 0 10
91461: PPUSH
91462: LD_INT 19
91464: PPUSH
91465: CALL_OW 109
// mechs := mechs diff un ;
91469: LD_ADDR_VAR 0 12
91473: PUSH
91474: LD_VAR 0 12
91478: PUSH
91479: LD_VAR 0 10
91483: DIFF
91484: ST_TO_ADDR
// end ; end ;
91485: GO 91361
91487: POP
91488: POP
// if solds then
91489: LD_VAR 0 8
91493: IFFALSE 91552
// for i in solds do
91495: LD_ADDR_VAR 0 4
91499: PUSH
91500: LD_VAR 0 8
91504: PUSH
91505: FOR_IN
91506: IFFALSE 91550
// if not GetTag ( i ) then
91508: LD_VAR 0 4
91512: PPUSH
91513: CALL_OW 110
91517: NOT
91518: IFFALSE 91548
// begin defenders := defenders union i ;
91520: LD_ADDR_VAR 0 2
91524: PUSH
91525: LD_VAR 0 2
91529: PUSH
91530: LD_VAR 0 4
91534: UNION
91535: ST_TO_ADDR
// SetTag ( i , 18 ) ;
91536: LD_VAR 0 4
91540: PPUSH
91541: LD_INT 18
91543: PPUSH
91544: CALL_OW 109
// end ;
91548: GO 91505
91550: POP
91551: POP
// repeat wait ( 0 0$2 ) ;
91552: LD_INT 70
91554: PPUSH
91555: CALL_OW 67
// enemy := mc_scan [ base ] ;
91559: LD_ADDR_VAR 0 21
91563: PUSH
91564: LD_EXP 46
91568: PUSH
91569: LD_VAR 0 1
91573: ARRAY
91574: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
91575: LD_EXP 23
91579: PUSH
91580: LD_VAR 0 1
91584: ARRAY
91585: NOT
91586: IFTRUE 91603
91588: PUSH
91589: LD_EXP 23
91593: PUSH
91594: LD_VAR 0 1
91598: ARRAY
91599: PUSH
91600: EMPTY
91601: EQUAL
91602: OR
91603: IFFALSE 91640
// begin for i in defenders do
91605: LD_ADDR_VAR 0 4
91609: PUSH
91610: LD_VAR 0 2
91614: PUSH
91615: FOR_IN
91616: IFFALSE 91629
// ComStop ( i ) ;
91618: LD_VAR 0 4
91622: PPUSH
91623: CALL_OW 141
91627: GO 91615
91629: POP
91630: POP
// defenders := [ ] ;
91631: LD_ADDR_VAR 0 2
91635: PUSH
91636: EMPTY
91637: ST_TO_ADDR
// exit ;
91638: GO 93137
// end ; for i in defenders do
91640: LD_ADDR_VAR 0 4
91644: PUSH
91645: LD_VAR 0 2
91649: PUSH
91650: FOR_IN
91651: IFFALSE 92585
// begin e := NearestUnitToUnit ( enemy , i ) ;
91653: LD_ADDR_VAR 0 13
91657: PUSH
91658: LD_VAR 0 21
91662: PPUSH
91663: LD_VAR 0 4
91667: PPUSH
91668: CALL_OW 74
91672: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
91673: LD_ADDR_VAR 0 7
91677: PUSH
91678: LD_EXP 23
91682: PUSH
91683: LD_VAR 0 1
91687: ARRAY
91688: PPUSH
91689: LD_INT 2
91691: PUSH
91692: LD_INT 30
91694: PUSH
91695: LD_INT 0
91697: PUSH
91698: EMPTY
91699: LIST
91700: LIST
91701: PUSH
91702: LD_INT 30
91704: PUSH
91705: LD_INT 1
91707: PUSH
91708: EMPTY
91709: LIST
91710: LIST
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: LIST
91716: PPUSH
91717: CALL_OW 72
91721: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
91722: LD_ADDR_VAR 0 16
91726: PUSH
91727: LD_VAR 0 7
91731: NOT
91732: IFTRUE 91762
91734: PUSH
91735: LD_VAR 0 7
91739: PPUSH
91740: LD_INT 3
91742: PUSH
91743: LD_INT 24
91745: PUSH
91746: LD_INT 600
91748: PUSH
91749: EMPTY
91750: LIST
91751: LIST
91752: PUSH
91753: EMPTY
91754: LIST
91755: LIST
91756: PPUSH
91757: CALL_OW 72
91761: OR
91762: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
91763: LD_VAR 0 4
91767: PPUSH
91768: CALL_OW 247
91772: PUSH
91773: LD_INT 2
91775: DOUBLE
91776: EQUAL
91777: IFTRUE 91781
91779: GO 92197
91781: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
91782: LD_VAR 0 4
91786: PPUSH
91787: CALL_OW 256
91791: PUSH
91792: LD_INT 1000
91794: EQUAL
91795: IFFALSE 91841
91797: PUSH
91798: LD_VAR 0 4
91802: PPUSH
91803: LD_VAR 0 13
91807: PPUSH
91808: CALL_OW 296
91812: PUSH
91813: LD_INT 40
91815: LESS
91816: IFTRUE 91840
91818: PUSH
91819: LD_VAR 0 13
91823: PPUSH
91824: LD_EXP 48
91828: PUSH
91829: LD_VAR 0 1
91833: ARRAY
91834: PPUSH
91835: CALL_OW 308
91839: OR
91840: AND
91841: IFFALSE 91967
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
91843: LD_VAR 0 4
91847: PPUSH
91848: CALL_OW 262
91852: PUSH
91853: LD_INT 1
91855: EQUAL
91856: IFFALSE 91873
91858: PUSH
91859: LD_VAR 0 4
91863: PPUSH
91864: CALL_OW 261
91868: PUSH
91869: LD_INT 30
91871: LESS
91872: AND
91873: IFFALSE 91881
91875: PUSH
91876: LD_VAR 0 7
91880: AND
91881: IFFALSE 91951
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
91883: LD_VAR 0 4
91887: PPUSH
91888: LD_VAR 0 7
91892: PPUSH
91893: LD_VAR 0 4
91897: PPUSH
91898: CALL_OW 74
91902: PPUSH
91903: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
91907: LD_VAR 0 4
91911: PPUSH
91912: LD_VAR 0 7
91916: PPUSH
91917: LD_VAR 0 4
91921: PPUSH
91922: CALL_OW 74
91926: PPUSH
91927: CALL_OW 296
91931: PUSH
91932: LD_INT 6
91934: LESS
91935: IFFALSE 91949
// SetFuel ( i , 100 ) ;
91937: LD_VAR 0 4
91941: PPUSH
91942: LD_INT 100
91944: PPUSH
91945: CALL_OW 240
// end else
91949: GO 91965
// ComAttackUnit ( i , e ) ;
91951: LD_VAR 0 4
91955: PPUSH
91956: LD_VAR 0 13
91960: PPUSH
91961: CALL_OW 115
// end else
91965: GO 92074
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
91967: LD_VAR 0 13
91971: PPUSH
91972: LD_EXP 48
91976: PUSH
91977: LD_VAR 0 1
91981: ARRAY
91982: PPUSH
91983: CALL_OW 308
91987: NOT
91988: IFFALSE 92010
91990: PUSH
91991: LD_VAR 0 4
91995: PPUSH
91996: LD_VAR 0 13
92000: PPUSH
92001: CALL_OW 296
92005: PUSH
92006: LD_INT 40
92008: GREATEREQUAL
92009: AND
92010: IFTRUE 92027
92012: PUSH
92013: LD_VAR 0 4
92017: PPUSH
92018: CALL_OW 256
92022: PUSH
92023: LD_INT 650
92025: LESSEQUAL
92026: OR
92027: IFFALSE 92052
92029: PUSH
92030: LD_VAR 0 4
92034: PPUSH
92035: LD_EXP 47
92039: PUSH
92040: LD_VAR 0 1
92044: ARRAY
92045: PPUSH
92046: CALL_OW 308
92050: NOT
92051: AND
92052: IFFALSE 92074
// ComMoveToArea ( i , mc_parking [ base ] ) ;
92054: LD_VAR 0 4
92058: PPUSH
92059: LD_EXP 47
92063: PUSH
92064: LD_VAR 0 1
92068: ARRAY
92069: PPUSH
92070: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
92074: LD_VAR 0 4
92078: PPUSH
92079: CALL_OW 256
92083: PUSH
92084: LD_INT 1000
92086: LESS
92087: IFFALSE 92104
92089: PUSH
92090: LD_VAR 0 4
92094: PPUSH
92095: CALL_OW 263
92099: PUSH
92100: LD_INT 1
92102: EQUAL
92103: AND
92104: IFFALSE 92117
92106: PUSH
92107: LD_VAR 0 4
92111: PPUSH
92112: CALL_OW 311
92116: AND
92117: IFFALSE 92141
92119: PUSH
92120: LD_VAR 0 4
92124: PPUSH
92125: LD_EXP 47
92129: PUSH
92130: LD_VAR 0 1
92134: ARRAY
92135: PPUSH
92136: CALL_OW 308
92140: AND
92141: IFFALSE 92195
// begin mech := IsDrivenBy ( i ) ;
92143: LD_ADDR_VAR 0 9
92147: PUSH
92148: LD_VAR 0 4
92152: PPUSH
92153: CALL_OW 311
92157: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
92158: LD_VAR 0 9
92162: PPUSH
92163: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
92167: LD_VAR 0 9
92171: PPUSH
92172: LD_VAR 0 4
92176: PPUSH
92177: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
92181: LD_VAR 0 9
92185: PPUSH
92186: LD_VAR 0 4
92190: PPUSH
92191: CALL_OW 180
// end ; end ; unit_human :
92195: GO 92556
92197: LD_INT 1
92199: DOUBLE
92200: EQUAL
92201: IFTRUE 92205
92203: GO 92555
92205: POP
// begin b := IsInUnit ( i ) ;
92206: LD_ADDR_VAR 0 18
92210: PUSH
92211: LD_VAR 0 4
92215: PPUSH
92216: CALL_OW 310
92220: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
92221: LD_ADDR_VAR 0 19
92225: PUSH
92226: LD_VAR 0 18
92230: NOT
92231: IFTRUE 92255
92233: PUSH
92234: LD_VAR 0 18
92238: PPUSH
92239: CALL_OW 266
92243: PUSH
92244: LD_INT 32
92246: PUSH
92247: LD_INT 31
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: IN
92254: OR
92255: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
92256: LD_VAR 0 18
92260: PPUSH
92261: CALL_OW 266
92265: PUSH
92266: LD_INT 5
92268: EQUAL
92269: IFFALSE 92301
92271: PUSH
92272: LD_VAR 0 4
92276: PPUSH
92277: CALL_OW 257
92281: PUSH
92282: LD_INT 1
92284: PUSH
92285: LD_INT 2
92287: PUSH
92288: LD_INT 3
92290: PUSH
92291: LD_INT 4
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: IN
92300: AND
92301: IFFALSE 92338
// begin class := AllowSpecClass ( i ) ;
92303: LD_ADDR_VAR 0 20
92307: PUSH
92308: LD_VAR 0 4
92312: PPUSH
92313: CALL 13055 0 1
92317: ST_TO_ADDR
// if class then
92318: LD_VAR 0 20
92322: IFFALSE 92338
// ComChangeProfession ( i , class ) ;
92324: LD_VAR 0 4
92328: PPUSH
92329: LD_VAR 0 20
92333: PPUSH
92334: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
92338: LD_VAR 0 16
92342: IFTRUE 92369
92344: PUSH
92345: LD_VAR 0 2
92349: PPUSH
92350: LD_INT 21
92352: PUSH
92353: LD_INT 2
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: PPUSH
92360: CALL_OW 72
92364: PUSH
92365: LD_INT 1
92367: LESSEQUAL
92368: OR
92369: IFFALSE 92377
92371: PUSH
92372: LD_VAR 0 19
92376: AND
92377: IFFALSE 92392
92379: PUSH
92380: LD_VAR 0 4
92384: PUSH
92385: LD_VAR 0 17
92389: IN
92390: NOT
92391: AND
92392: IFFALSE 92487
// begin if b then
92394: LD_VAR 0 18
92398: IFFALSE 92449
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
92400: LD_VAR 0 18
92404: PPUSH
92405: LD_VAR 0 21
92409: PPUSH
92410: LD_VAR 0 18
92414: PPUSH
92415: CALL_OW 74
92419: PPUSH
92420: CALL_OW 296
92424: PUSH
92425: LD_INT 10
92427: LESS
92428: IFFALSE 92445
92430: PUSH
92431: LD_VAR 0 18
92435: PPUSH
92436: CALL_OW 461
92440: PUSH
92441: LD_INT 7
92443: NONEQUAL
92444: AND
92445: IFFALSE 92449
// continue ;
92447: GO 91650
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
92449: LD_ADDR_VAR 0 17
92453: PUSH
92454: LD_VAR 0 17
92458: PPUSH
92459: LD_VAR 0 17
92463: PUSH
92464: LD_INT 1
92466: PLUS
92467: PPUSH
92468: LD_VAR 0 4
92472: PPUSH
92473: CALL_OW 1
92477: ST_TO_ADDR
// ComExitBuilding ( i ) ;
92478: LD_VAR 0 4
92482: PPUSH
92483: CALL_OW 122
// end ; if sold_defenders then
92487: LD_VAR 0 17
92491: IFFALSE 92553
// if i in sold_defenders then
92493: LD_VAR 0 4
92497: PUSH
92498: LD_VAR 0 17
92502: IN
92503: IFFALSE 92553
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
92505: LD_VAR 0 4
92509: PPUSH
92510: CALL_OW 314
92514: NOT
92515: IFFALSE 92537
92517: PUSH
92518: LD_VAR 0 4
92522: PPUSH
92523: LD_VAR 0 13
92527: PPUSH
92528: CALL_OW 296
92532: PUSH
92533: LD_INT 30
92535: LESS
92536: AND
92537: IFFALSE 92553
// ComAttackUnit ( i , e ) ;
92539: LD_VAR 0 4
92543: PPUSH
92544: LD_VAR 0 13
92548: PPUSH
92549: CALL_OW 115
// end ; end ; end ;
92553: GO 92556
92555: POP
// if IsDead ( i ) then
92556: LD_VAR 0 4
92560: PPUSH
92561: CALL_OW 301
92565: IFFALSE 92583
// defenders := defenders diff i ;
92567: LD_ADDR_VAR 0 2
92571: PUSH
92572: LD_VAR 0 2
92576: PUSH
92577: LD_VAR 0 4
92581: DIFF
92582: ST_TO_ADDR
// end ;
92583: GO 91650
92585: POP
92586: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
92587: LD_VAR 0 21
92591: NOT
92592: IFTRUE 92601
92594: PUSH
92595: LD_VAR 0 2
92599: NOT
92600: OR
92601: IFTRUE 92616
92603: PUSH
92604: LD_EXP 23
92608: PUSH
92609: LD_VAR 0 1
92613: ARRAY
92614: NOT
92615: OR
92616: IFFALSE 91552
// MC_Reset ( base , 18 ) ;
92618: LD_VAR 0 1
92622: PPUSH
92623: LD_INT 18
92625: PPUSH
92626: CALL 58826 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
92630: LD_ADDR_VAR 0 2
92634: PUSH
92635: LD_VAR 0 2
92639: PUSH
92640: LD_VAR 0 2
92644: PPUSH
92645: LD_INT 2
92647: PUSH
92648: LD_INT 25
92650: PUSH
92651: LD_INT 1
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PUSH
92658: LD_INT 25
92660: PUSH
92661: LD_INT 5
92663: PUSH
92664: EMPTY
92665: LIST
92666: LIST
92667: PUSH
92668: LD_INT 25
92670: PUSH
92671: LD_INT 8
92673: PUSH
92674: EMPTY
92675: LIST
92676: LIST
92677: PUSH
92678: LD_INT 25
92680: PUSH
92681: LD_INT 9
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: EMPTY
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: PPUSH
92695: CALL_OW 72
92699: DIFF
92700: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
92701: LD_VAR 0 21
92705: NOT
92706: IFFALSE 92729
92708: PUSH
92709: LD_VAR 0 2
92713: PPUSH
92714: LD_INT 21
92716: PUSH
92717: LD_INT 2
92719: PUSH
92720: EMPTY
92721: LIST
92722: LIST
92723: PPUSH
92724: CALL_OW 72
92728: AND
92729: IFFALSE 93073
// begin tmp := FilterByTag ( defenders , 19 ) ;
92731: LD_ADDR_VAR 0 11
92735: PUSH
92736: LD_VAR 0 2
92740: PPUSH
92741: LD_INT 19
92743: PPUSH
92744: CALL 46848 0 2
92748: ST_TO_ADDR
// if tmp then
92749: LD_VAR 0 11
92753: IFFALSE 92823
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
92755: LD_ADDR_VAR 0 11
92759: PUSH
92760: LD_VAR 0 11
92764: PPUSH
92765: LD_INT 25
92767: PUSH
92768: LD_INT 3
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PPUSH
92775: CALL_OW 72
92779: ST_TO_ADDR
// if tmp then
92780: LD_VAR 0 11
92784: IFFALSE 92823
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
92786: LD_ADDR_EXP 35
92790: PUSH
92791: LD_EXP 35
92795: PPUSH
92796: LD_VAR 0 1
92800: PPUSH
92801: LD_EXP 35
92805: PUSH
92806: LD_VAR 0 1
92810: ARRAY
92811: PUSH
92812: LD_VAR 0 11
92816: UNION
92817: PPUSH
92818: CALL_OW 1
92822: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
92823: LD_VAR 0 1
92827: PPUSH
92828: LD_INT 19
92830: PPUSH
92831: CALL 58826 0 2
// repeat wait ( 0 0$1 ) ;
92835: LD_INT 35
92837: PPUSH
92838: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
92842: LD_EXP 23
92846: PUSH
92847: LD_VAR 0 1
92851: ARRAY
92852: NOT
92853: IFTRUE 92870
92855: PUSH
92856: LD_EXP 23
92860: PUSH
92861: LD_VAR 0 1
92865: ARRAY
92866: PUSH
92867: EMPTY
92868: EQUAL
92869: OR
92870: IFFALSE 92907
// begin for i in defenders do
92872: LD_ADDR_VAR 0 4
92876: PUSH
92877: LD_VAR 0 2
92881: PUSH
92882: FOR_IN
92883: IFFALSE 92896
// ComStop ( i ) ;
92885: LD_VAR 0 4
92889: PPUSH
92890: CALL_OW 141
92894: GO 92882
92896: POP
92897: POP
// defenders := [ ] ;
92898: LD_ADDR_VAR 0 2
92902: PUSH
92903: EMPTY
92904: ST_TO_ADDR
// exit ;
92905: GO 93137
// end ; for i in defenders do
92907: LD_ADDR_VAR 0 4
92911: PUSH
92912: LD_VAR 0 2
92916: PUSH
92917: FOR_IN
92918: IFFALSE 93007
// begin if not IsInArea ( i , mc_parking [ base ] ) then
92920: LD_VAR 0 4
92924: PPUSH
92925: LD_EXP 47
92929: PUSH
92930: LD_VAR 0 1
92934: ARRAY
92935: PPUSH
92936: CALL_OW 308
92940: NOT
92941: IFFALSE 92965
// ComMoveToArea ( i , mc_parking [ base ] ) else
92943: LD_VAR 0 4
92947: PPUSH
92948: LD_EXP 47
92952: PUSH
92953: LD_VAR 0 1
92957: ARRAY
92958: PPUSH
92959: CALL_OW 113
92963: GO 93005
// if GetControl ( i ) = control_manual then
92965: LD_VAR 0 4
92969: PPUSH
92970: CALL_OW 263
92974: PUSH
92975: LD_INT 1
92977: EQUAL
92978: IFFALSE 93005
// if IsDrivenBy ( i ) then
92980: LD_VAR 0 4
92984: PPUSH
92985: CALL_OW 311
92989: IFFALSE 93005
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
92991: LD_VAR 0 4
92995: PPUSH
92996: CALL_OW 311
93000: PPUSH
93001: CALL_OW 121
// end ;
93005: GO 92917
93007: POP
93008: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
93009: LD_VAR 0 2
93013: PPUSH
93014: LD_INT 95
93016: PUSH
93017: LD_EXP 47
93021: PUSH
93022: LD_VAR 0 1
93026: ARRAY
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PPUSH
93032: CALL_OW 72
93036: PUSH
93037: LD_VAR 0 2
93041: EQUAL
93042: IFTRUE 93056
93044: PUSH
93045: LD_EXP 46
93049: PUSH
93050: LD_VAR 0 1
93054: ARRAY
93055: OR
93056: IFTRUE 93071
93058: PUSH
93059: LD_EXP 23
93063: PUSH
93064: LD_VAR 0 1
93068: ARRAY
93069: NOT
93070: OR
93071: IFFALSE 92835
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
93073: LD_ADDR_EXP 45
93077: PUSH
93078: LD_EXP 45
93082: PPUSH
93083: LD_VAR 0 1
93087: PPUSH
93088: LD_VAR 0 2
93092: PPUSH
93093: LD_INT 21
93095: PUSH
93096: LD_INT 2
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PPUSH
93103: CALL_OW 72
93107: PPUSH
93108: CALL_OW 1
93112: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
93113: LD_VAR 0 1
93117: PPUSH
93118: LD_INT 19
93120: PPUSH
93121: CALL 58826 0 2
// MC_Reset ( base , 20 ) ;
93125: LD_VAR 0 1
93129: PPUSH
93130: LD_INT 20
93132: PPUSH
93133: CALL 58826 0 2
// end ; end_of_file
93137: LD_VAR 0 3
93141: RET
// export function SOS_UnitDestroyed ( un ) ; begin
93142: LD_INT 0
93144: PPUSH
// ComRadiation ( un ) ;
93145: LD_VAR 0 1
93149: PPUSH
93150: CALL 94231 0 1
// end ;
93154: LD_VAR 0 2
93158: RET
// export function SOS_UnitKamikazed ( un ) ; begin
93159: LD_INT 0
93161: PPUSH
// ComRadiation ( un ) ;
93162: LD_VAR 0 1
93166: PPUSH
93167: CALL 94231 0 1
// end ;
93171: LD_VAR 0 2
93175: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93176: LD_INT 0
93178: PPUSH
// end ;
93179: LD_VAR 0 4
93183: RET
// export function SOS_Command ( cmd ) ; begin
93184: LD_INT 0
93186: PPUSH
// end ;
93187: LD_VAR 0 2
93191: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
93192: LD_INT 0
93194: PPUSH
// end ;
93195: LD_VAR 0 6
93199: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
93200: LD_INT 0
93202: PPUSH
93203: PPUSH
93204: PPUSH
93205: PPUSH
// if not vehicle or not factory then
93206: LD_VAR 0 1
93210: NOT
93211: IFTRUE 93220
93213: PUSH
93214: LD_VAR 0 2
93218: NOT
93219: OR
93220: IFFALSE 93224
// exit ;
93222: GO 93806
// if not factoryWaypoints then
93224: LD_EXP 137
93228: NOT
93229: IFFALSE 93233
// exit ;
93231: GO 93806
// for i := 1 to Count ( factoryWaypoints ) do
93233: LD_ADDR_VAR 0 4
93237: PUSH
93238: DOUBLE
93239: LD_INT 1
93241: DEC
93242: ST_TO_ADDR
93243: LD_EXP 137
93247: PPUSH
93248: CALL 13371 0 1
93252: PUSH
93253: FOR_TO
93254: IFFALSE 93804
// if factoryWaypoints [ i ] [ 2 ] = factory then
93256: LD_EXP 137
93260: PUSH
93261: LD_VAR 0 4
93265: ARRAY
93266: PUSH
93267: LD_INT 2
93269: ARRAY
93270: PUSH
93271: LD_VAR 0 2
93275: EQUAL
93276: IFFALSE 93802
// begin if GetControl ( vehicle ) = control_manual then
93278: LD_VAR 0 1
93282: PPUSH
93283: CALL_OW 263
93287: PUSH
93288: LD_INT 1
93290: EQUAL
93291: IFFALSE 93655
// begin driver := IsDrivenBy ( vehicle ) ;
93293: LD_ADDR_VAR 0 5
93297: PUSH
93298: LD_VAR 0 1
93302: PPUSH
93303: CALL_OW 311
93307: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
93308: LD_VAR 0 5
93312: PUSH
93313: LD_EXP 138
93317: IN
93318: IFTRUE 93332
93320: PUSH
93321: LD_VAR 0 1
93325: PUSH
93326: LD_EXP 138
93330: IN
93331: OR
93332: IFFALSE 93338
// exit ;
93334: POP
93335: POP
93336: GO 93806
// if not HasTask ( driver ) then
93338: LD_VAR 0 5
93342: PPUSH
93343: CALL_OW 314
93347: NOT
93348: IFFALSE 93653
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
93350: LD_ADDR_EXP 138
93354: PUSH
93355: LD_EXP 138
93359: PPUSH
93360: LD_VAR 0 5
93364: PPUSH
93365: CALL 49303 0 2
93369: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
93370: LD_ADDR_EXP 138
93374: PUSH
93375: LD_EXP 138
93379: PPUSH
93380: LD_VAR 0 1
93384: PPUSH
93385: CALL 49303 0 2
93389: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93390: LD_ADDR_VAR 0 6
93394: PUSH
93395: LD_EXP 137
93399: PUSH
93400: LD_VAR 0 4
93404: ARRAY
93405: PUSH
93406: LD_INT 3
93408: ARRAY
93409: PPUSH
93410: LD_EXP 137
93414: PUSH
93415: LD_VAR 0 4
93419: ARRAY
93420: PUSH
93421: LD_INT 4
93423: ARRAY
93424: PPUSH
93425: CALL_OW 428
93429: ST_TO_ADDR
// if hex then
93430: LD_VAR 0 6
93434: IFFALSE 93452
// ComMoveUnit ( driver , hex ) else
93436: LD_VAR 0 5
93440: PPUSH
93441: LD_VAR 0 6
93445: PPUSH
93446: CALL_OW 112
93450: GO 93536
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
93452: LD_VAR 0 1
93456: PPUSH
93457: LD_EXP 137
93461: PUSH
93462: LD_VAR 0 4
93466: ARRAY
93467: PUSH
93468: LD_INT 3
93470: ARRAY
93471: PPUSH
93472: LD_EXP 137
93476: PUSH
93477: LD_VAR 0 4
93481: ARRAY
93482: PUSH
93483: LD_INT 4
93485: ARRAY
93486: PPUSH
93487: CALL_OW 297
93491: PUSH
93492: LD_INT 0
93494: GREATER
93495: IFFALSE 93536
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93497: LD_VAR 0 5
93501: PPUSH
93502: LD_EXP 137
93506: PUSH
93507: LD_VAR 0 4
93511: ARRAY
93512: PUSH
93513: LD_INT 3
93515: ARRAY
93516: PPUSH
93517: LD_EXP 137
93521: PUSH
93522: LD_VAR 0 4
93526: ARRAY
93527: PUSH
93528: LD_INT 4
93530: ARRAY
93531: PPUSH
93532: CALL_OW 111
// AddComExitVehicle ( driver ) ;
93536: LD_VAR 0 5
93540: PPUSH
93541: CALL_OW 181
// if Multiplayer then
93545: LD_OWVAR 4
93549: IFFALSE 93598
// begin repeat wait ( 10 ) ;
93551: LD_INT 10
93553: PPUSH
93554: CALL_OW 67
// until not IsInUnit ( driver ) ;
93558: LD_VAR 0 5
93562: PPUSH
93563: CALL_OW 310
93567: NOT
93568: IFFALSE 93551
// if not HasTask ( driver ) then
93570: LD_VAR 0 5
93574: PPUSH
93575: CALL_OW 314
93579: NOT
93580: IFFALSE 93596
// ComEnterUnit ( driver , factory ) ;
93582: LD_VAR 0 5
93586: PPUSH
93587: LD_VAR 0 2
93591: PPUSH
93592: CALL_OW 120
// end else
93596: GO 93612
// AddComEnterUnit ( driver , factory ) ;
93598: LD_VAR 0 5
93602: PPUSH
93603: LD_VAR 0 2
93607: PPUSH
93608: CALL_OW 180
// wait ( 0 0$1 ) ;
93612: LD_INT 35
93614: PPUSH
93615: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
93619: LD_ADDR_EXP 138
93623: PUSH
93624: LD_EXP 138
93628: PUSH
93629: LD_VAR 0 5
93633: DIFF
93634: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
93635: LD_ADDR_EXP 138
93639: PUSH
93640: LD_EXP 138
93644: PUSH
93645: LD_VAR 0 1
93649: DIFF
93650: ST_TO_ADDR
// break ;
93651: GO 93804
// end ; end else
93653: GO 93802
// if GetControl ( vehicle ) = control_remote then
93655: LD_VAR 0 1
93659: PPUSH
93660: CALL_OW 263
93664: PUSH
93665: LD_INT 2
93667: EQUAL
93668: IFFALSE 93754
// begin wait ( 0 0$2 ) ;
93670: LD_INT 70
93672: PPUSH
93673: CALL_OW 67
// repeat wait ( 10 ) ;
93677: LD_INT 10
93679: PPUSH
93680: CALL_OW 67
// Connect ( vehicle ) ;
93684: LD_VAR 0 1
93688: PPUSH
93689: CALL 19615 0 1
// until IsControledBy ( vehicle ) ;
93693: LD_VAR 0 1
93697: PPUSH
93698: CALL_OW 312
93702: IFFALSE 93677
// wait ( 10 ) ;
93704: LD_INT 10
93706: PPUSH
93707: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93711: LD_VAR 0 1
93715: PPUSH
93716: LD_EXP 137
93720: PUSH
93721: LD_VAR 0 4
93725: ARRAY
93726: PUSH
93727: LD_INT 3
93729: ARRAY
93730: PPUSH
93731: LD_EXP 137
93735: PUSH
93736: LD_VAR 0 4
93740: ARRAY
93741: PUSH
93742: LD_INT 4
93744: ARRAY
93745: PPUSH
93746: CALL_OW 111
// break ;
93750: GO 93804
// end else
93752: GO 93802
// begin wait ( 0 0$3 ) ;
93754: LD_INT 105
93756: PPUSH
93757: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
93761: LD_VAR 0 1
93765: PPUSH
93766: LD_EXP 137
93770: PUSH
93771: LD_VAR 0 4
93775: ARRAY
93776: PUSH
93777: LD_INT 3
93779: ARRAY
93780: PPUSH
93781: LD_EXP 137
93785: PUSH
93786: LD_VAR 0 4
93790: ARRAY
93791: PUSH
93792: LD_INT 4
93794: ARRAY
93795: PPUSH
93796: CALL_OW 111
// break ;
93800: GO 93804
// end ; end ;
93802: GO 93253
93804: POP
93805: POP
// end ;
93806: LD_VAR 0 3
93810: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
93811: LD_INT 0
93813: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
93814: LD_VAR 0 1
93818: PUSH
93819: LD_INT 250
93821: EQUAL
93822: IFFALSE 93839
93824: PUSH
93825: LD_VAR 0 2
93829: PPUSH
93830: CALL_OW 264
93834: PUSH
93835: LD_INT 81
93837: EQUAL
93838: AND
93839: IFFALSE 93860
// MinerPlaceMine ( unit , x , y ) ;
93841: LD_VAR 0 2
93845: PPUSH
93846: LD_VAR 0 4
93850: PPUSH
93851: LD_VAR 0 5
93855: PPUSH
93856: CALL 96992 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
93860: LD_VAR 0 1
93864: PUSH
93865: LD_INT 251
93867: EQUAL
93868: IFFALSE 93885
93870: PUSH
93871: LD_VAR 0 2
93875: PPUSH
93876: CALL_OW 264
93880: PUSH
93881: LD_INT 81
93883: EQUAL
93884: AND
93885: IFFALSE 93906
// MinerDetonateMine ( unit , x , y ) ;
93887: LD_VAR 0 2
93891: PPUSH
93892: LD_VAR 0 4
93896: PPUSH
93897: LD_VAR 0 5
93901: PPUSH
93902: CALL 97271 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
93906: LD_VAR 0 1
93910: PUSH
93911: LD_INT 252
93913: EQUAL
93914: IFFALSE 93931
93916: PUSH
93917: LD_VAR 0 2
93921: PPUSH
93922: CALL_OW 264
93926: PUSH
93927: LD_INT 81
93929: EQUAL
93930: AND
93931: IFFALSE 93952
// MinerCreateMinefield ( unit , x , y ) ;
93933: LD_VAR 0 2
93937: PPUSH
93938: LD_VAR 0 4
93942: PPUSH
93943: LD_VAR 0 5
93947: PPUSH
93948: CALL 97690 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
93952: LD_VAR 0 1
93956: PUSH
93957: LD_INT 253
93959: EQUAL
93960: IFFALSE 93977
93962: PUSH
93963: LD_VAR 0 2
93967: PPUSH
93968: CALL_OW 257
93972: PUSH
93973: LD_INT 5
93975: EQUAL
93976: AND
93977: IFFALSE 93998
// ComBinocular ( unit , x , y ) ;
93979: LD_VAR 0 2
93983: PPUSH
93984: LD_VAR 0 4
93988: PPUSH
93989: LD_VAR 0 5
93993: PPUSH
93994: CALL 98065 0 3
// if selectedUnit then
93998: LD_VAR 0 3
94002: IFFALSE 94062
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
94004: LD_VAR 0 1
94008: PUSH
94009: LD_INT 254
94011: EQUAL
94012: IFFALSE 94029
94014: PUSH
94015: LD_VAR 0 2
94019: PPUSH
94020: CALL_OW 264
94024: PUSH
94025: LD_INT 99
94027: EQUAL
94028: AND
94029: IFFALSE 94046
94031: PUSH
94032: LD_VAR 0 3
94036: PPUSH
94037: CALL_OW 263
94041: PUSH
94042: LD_INT 3
94044: EQUAL
94045: AND
94046: IFFALSE 94062
// HackDestroyVehicle ( unit , selectedUnit ) ;
94048: LD_VAR 0 2
94052: PPUSH
94053: LD_VAR 0 3
94057: PPUSH
94058: CALL 96352 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
94062: LD_VAR 0 1
94066: PUSH
94067: LD_INT 255
94069: EQUAL
94070: IFFALSE 94094
94072: PUSH
94073: LD_VAR 0 2
94077: PPUSH
94078: CALL_OW 264
94082: PUSH
94083: LD_INT 14
94085: PUSH
94086: LD_INT 53
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: IN
94093: AND
94094: IFFALSE 94112
94096: PUSH
94097: LD_VAR 0 4
94101: PPUSH
94102: LD_VAR 0 5
94106: PPUSH
94107: CALL_OW 488
94111: AND
94112: IFFALSE 94136
// CutTreeXYR ( unit , x , y , 12 ) ;
94114: LD_VAR 0 2
94118: PPUSH
94119: LD_VAR 0 4
94123: PPUSH
94124: LD_VAR 0 5
94128: PPUSH
94129: LD_INT 12
94131: PPUSH
94132: CALL 94327 0 4
// if cmd = 256 then
94136: LD_VAR 0 1
94140: PUSH
94141: LD_INT 256
94143: EQUAL
94144: IFFALSE 94165
// SetFactoryWaypoint ( unit , x , y ) ;
94146: LD_VAR 0 2
94150: PPUSH
94151: LD_VAR 0 4
94155: PPUSH
94156: LD_VAR 0 5
94160: PPUSH
94161: CALL 114132 0 3
// if cmd = 257 then
94165: LD_VAR 0 1
94169: PUSH
94170: LD_INT 257
94172: EQUAL
94173: IFFALSE 94194
// SetWarehouseGatheringPoint ( unit , x , y ) ;
94175: LD_VAR 0 2
94179: PPUSH
94180: LD_VAR 0 4
94184: PPUSH
94185: LD_VAR 0 5
94189: PPUSH
94190: CALL 114628 0 3
// if cmd = 258 then
94194: LD_VAR 0 1
94198: PUSH
94199: LD_INT 258
94201: EQUAL
94202: IFFALSE 94226
// BurnTreeXYR ( unit , x , y , 8 ) ;
94204: LD_VAR 0 2
94208: PPUSH
94209: LD_VAR 0 4
94213: PPUSH
94214: LD_VAR 0 5
94218: PPUSH
94219: LD_INT 8
94221: PPUSH
94222: CALL 94727 0 4
// end ;
94226: LD_VAR 0 6
94230: RET
// export function ComRadiation ( un ) ; var eff ; begin
94231: LD_INT 0
94233: PPUSH
94234: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
94235: LD_VAR 0 1
94239: PPUSH
94240: CALL_OW 264
94244: PUSH
94245: LD_INT 91
94247: NONEQUAL
94248: IFFALSE 94252
// exit ;
94250: GO 94322
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94252: LD_INT 68
94254: PPUSH
94255: LD_VAR 0 1
94259: PPUSH
94260: CALL_OW 255
94264: PPUSH
94265: CALL_OW 321
94269: PUSH
94270: LD_INT 2
94272: EQUAL
94273: IFFALSE 94285
// eff := 50 else
94275: LD_ADDR_VAR 0 3
94279: PUSH
94280: LD_INT 50
94282: ST_TO_ADDR
94283: GO 94293
// eff := 25 ;
94285: LD_ADDR_VAR 0 3
94289: PUSH
94290: LD_INT 25
94292: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94293: LD_VAR 0 1
94297: PPUSH
94298: CALL_OW 250
94302: PPUSH
94303: LD_VAR 0 1
94307: PPUSH
94308: CALL_OW 251
94312: PPUSH
94313: LD_VAR 0 3
94317: PPUSH
94318: CALL_OW 495
// end ;
94322: LD_VAR 0 2
94326: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
94327: LD_INT 0
94329: PPUSH
94330: PPUSH
94331: PPUSH
94332: PPUSH
94333: PPUSH
94334: PPUSH
94335: PPUSH
94336: PPUSH
94337: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
94338: LD_VAR 0 1
94342: PPUSH
94343: CALL_OW 302
94347: NOT
94348: IFTRUE 94367
94350: PUSH
94351: LD_VAR 0 2
94355: PPUSH
94356: LD_VAR 0 3
94360: PPUSH
94361: CALL_OW 488
94365: NOT
94366: OR
94367: IFTRUE 94376
94369: PUSH
94370: LD_VAR 0 4
94374: NOT
94375: OR
94376: IFFALSE 94380
// exit ;
94378: GO 94722
// list := [ ] ;
94380: LD_ADDR_VAR 0 13
94384: PUSH
94385: EMPTY
94386: ST_TO_ADDR
// if x - r < 0 then
94387: LD_VAR 0 2
94391: PUSH
94392: LD_VAR 0 4
94396: MINUS
94397: PUSH
94398: LD_INT 0
94400: LESS
94401: IFFALSE 94413
// min_x := 0 else
94403: LD_ADDR_VAR 0 7
94407: PUSH
94408: LD_INT 0
94410: ST_TO_ADDR
94411: GO 94429
// min_x := x - r ;
94413: LD_ADDR_VAR 0 7
94417: PUSH
94418: LD_VAR 0 2
94422: PUSH
94423: LD_VAR 0 4
94427: MINUS
94428: ST_TO_ADDR
// if y - r < 0 then
94429: LD_VAR 0 3
94433: PUSH
94434: LD_VAR 0 4
94438: MINUS
94439: PUSH
94440: LD_INT 0
94442: LESS
94443: IFFALSE 94455
// min_y := 0 else
94445: LD_ADDR_VAR 0 8
94449: PUSH
94450: LD_INT 0
94452: ST_TO_ADDR
94453: GO 94471
// min_y := y - r ;
94455: LD_ADDR_VAR 0 8
94459: PUSH
94460: LD_VAR 0 3
94464: PUSH
94465: LD_VAR 0 4
94469: MINUS
94470: ST_TO_ADDR
// max_x := x + r ;
94471: LD_ADDR_VAR 0 9
94475: PUSH
94476: LD_VAR 0 2
94480: PUSH
94481: LD_VAR 0 4
94485: PLUS
94486: ST_TO_ADDR
// max_y := y + r ;
94487: LD_ADDR_VAR 0 10
94491: PUSH
94492: LD_VAR 0 3
94496: PUSH
94497: LD_VAR 0 4
94501: PLUS
94502: ST_TO_ADDR
// for _x = min_x to max_x do
94503: LD_ADDR_VAR 0 11
94507: PUSH
94508: DOUBLE
94509: LD_VAR 0 7
94513: DEC
94514: ST_TO_ADDR
94515: LD_VAR 0 9
94519: PUSH
94520: FOR_TO
94521: IFFALSE 94640
// for _y = min_y to max_y do
94523: LD_ADDR_VAR 0 12
94527: PUSH
94528: DOUBLE
94529: LD_VAR 0 8
94533: DEC
94534: ST_TO_ADDR
94535: LD_VAR 0 10
94539: PUSH
94540: FOR_TO
94541: IFFALSE 94636
// begin if not ValidHex ( _x , _y ) then
94543: LD_VAR 0 11
94547: PPUSH
94548: LD_VAR 0 12
94552: PPUSH
94553: CALL_OW 488
94557: NOT
94558: IFFALSE 94562
// continue ;
94560: GO 94540
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94562: LD_VAR 0 11
94566: PPUSH
94567: LD_VAR 0 12
94571: PPUSH
94572: CALL_OW 351
94576: IFFALSE 94594
94578: PUSH
94579: LD_VAR 0 11
94583: PPUSH
94584: LD_VAR 0 12
94588: PPUSH
94589: CALL_OW 554
94593: AND
94594: IFFALSE 94634
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94596: LD_ADDR_VAR 0 13
94600: PUSH
94601: LD_VAR 0 13
94605: PPUSH
94606: LD_VAR 0 13
94610: PUSH
94611: LD_INT 1
94613: PLUS
94614: PPUSH
94615: LD_VAR 0 11
94619: PUSH
94620: LD_VAR 0 12
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PPUSH
94629: CALL_OW 2
94633: ST_TO_ADDR
// end ;
94634: GO 94540
94636: POP
94637: POP
94638: GO 94520
94640: POP
94641: POP
// if not list then
94642: LD_VAR 0 13
94646: NOT
94647: IFFALSE 94651
// exit ;
94649: GO 94722
// for i in list do
94651: LD_ADDR_VAR 0 6
94655: PUSH
94656: LD_VAR 0 13
94660: PUSH
94661: FOR_IN
94662: IFFALSE 94720
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94664: LD_VAR 0 1
94668: PPUSH
94669: LD_STRING M
94671: PUSH
94672: LD_VAR 0 6
94676: PUSH
94677: LD_INT 1
94679: ARRAY
94680: PUSH
94681: LD_VAR 0 6
94685: PUSH
94686: LD_INT 2
94688: ARRAY
94689: PUSH
94690: LD_INT 0
94692: PUSH
94693: LD_INT 0
94695: PUSH
94696: LD_INT 0
94698: PUSH
94699: LD_INT 0
94701: PUSH
94702: EMPTY
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: LIST
94709: LIST
94710: PUSH
94711: EMPTY
94712: LIST
94713: PPUSH
94714: CALL_OW 447
94718: GO 94661
94720: POP
94721: POP
// end ;
94722: LD_VAR 0 5
94726: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
94727: LD_INT 0
94729: PPUSH
94730: PPUSH
94731: PPUSH
94732: PPUSH
94733: PPUSH
94734: PPUSH
94735: PPUSH
94736: PPUSH
94737: PPUSH
94738: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
94739: LD_VAR 0 1
94743: PPUSH
94744: CALL_OW 302
94748: NOT
94749: IFTRUE 94768
94751: PUSH
94752: LD_VAR 0 2
94756: PPUSH
94757: LD_VAR 0 3
94761: PPUSH
94762: CALL_OW 488
94766: NOT
94767: OR
94768: IFTRUE 94777
94770: PUSH
94771: LD_VAR 0 4
94775: NOT
94776: OR
94777: IFFALSE 94781
// exit ;
94779: GO 95298
// list := [ ] ;
94781: LD_ADDR_VAR 0 13
94785: PUSH
94786: EMPTY
94787: ST_TO_ADDR
// if x - r < 0 then
94788: LD_VAR 0 2
94792: PUSH
94793: LD_VAR 0 4
94797: MINUS
94798: PUSH
94799: LD_INT 0
94801: LESS
94802: IFFALSE 94814
// min_x := 0 else
94804: LD_ADDR_VAR 0 7
94808: PUSH
94809: LD_INT 0
94811: ST_TO_ADDR
94812: GO 94830
// min_x := x - r ;
94814: LD_ADDR_VAR 0 7
94818: PUSH
94819: LD_VAR 0 2
94823: PUSH
94824: LD_VAR 0 4
94828: MINUS
94829: ST_TO_ADDR
// if y - r < 0 then
94830: LD_VAR 0 3
94834: PUSH
94835: LD_VAR 0 4
94839: MINUS
94840: PUSH
94841: LD_INT 0
94843: LESS
94844: IFFALSE 94856
// min_y := 0 else
94846: LD_ADDR_VAR 0 8
94850: PUSH
94851: LD_INT 0
94853: ST_TO_ADDR
94854: GO 94872
// min_y := y - r ;
94856: LD_ADDR_VAR 0 8
94860: PUSH
94861: LD_VAR 0 3
94865: PUSH
94866: LD_VAR 0 4
94870: MINUS
94871: ST_TO_ADDR
// max_x := x + r ;
94872: LD_ADDR_VAR 0 9
94876: PUSH
94877: LD_VAR 0 2
94881: PUSH
94882: LD_VAR 0 4
94886: PLUS
94887: ST_TO_ADDR
// max_y := y + r ;
94888: LD_ADDR_VAR 0 10
94892: PUSH
94893: LD_VAR 0 3
94897: PUSH
94898: LD_VAR 0 4
94902: PLUS
94903: ST_TO_ADDR
// for _x = min_x to max_x do
94904: LD_ADDR_VAR 0 11
94908: PUSH
94909: DOUBLE
94910: LD_VAR 0 7
94914: DEC
94915: ST_TO_ADDR
94916: LD_VAR 0 9
94920: PUSH
94921: FOR_TO
94922: IFFALSE 95041
// for _y = min_y to max_y do
94924: LD_ADDR_VAR 0 12
94928: PUSH
94929: DOUBLE
94930: LD_VAR 0 8
94934: DEC
94935: ST_TO_ADDR
94936: LD_VAR 0 10
94940: PUSH
94941: FOR_TO
94942: IFFALSE 95037
// begin if not ValidHex ( _x , _y ) then
94944: LD_VAR 0 11
94948: PPUSH
94949: LD_VAR 0 12
94953: PPUSH
94954: CALL_OW 488
94958: NOT
94959: IFFALSE 94963
// continue ;
94961: GO 94941
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
94963: LD_VAR 0 11
94967: PPUSH
94968: LD_VAR 0 12
94972: PPUSH
94973: CALL_OW 351
94977: IFFALSE 94995
94979: PUSH
94980: LD_VAR 0 11
94984: PPUSH
94985: LD_VAR 0 12
94989: PPUSH
94990: CALL_OW 554
94994: AND
94995: IFFALSE 95035
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
94997: LD_ADDR_VAR 0 13
95001: PUSH
95002: LD_VAR 0 13
95006: PPUSH
95007: LD_VAR 0 13
95011: PUSH
95012: LD_INT 1
95014: PLUS
95015: PPUSH
95016: LD_VAR 0 11
95020: PUSH
95021: LD_VAR 0 12
95025: PUSH
95026: EMPTY
95027: LIST
95028: LIST
95029: PPUSH
95030: CALL_OW 2
95034: ST_TO_ADDR
// end ;
95035: GO 94941
95037: POP
95038: POP
95039: GO 94921
95041: POP
95042: POP
// if not list then
95043: LD_VAR 0 13
95047: NOT
95048: IFFALSE 95052
// exit ;
95050: GO 95298
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
95052: LD_ADDR_VAR 0 13
95056: PUSH
95057: LD_VAR 0 1
95061: PPUSH
95062: LD_VAR 0 13
95066: PPUSH
95067: LD_INT 1
95069: PPUSH
95070: LD_INT 1
95072: PPUSH
95073: CALL 16743 0 4
95077: ST_TO_ADDR
// ComStop ( flame ) ;
95078: LD_VAR 0 1
95082: PPUSH
95083: CALL_OW 141
// for i in list do
95087: LD_ADDR_VAR 0 6
95091: PUSH
95092: LD_VAR 0 13
95096: PUSH
95097: FOR_IN
95098: IFFALSE 95129
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
95100: LD_VAR 0 1
95104: PPUSH
95105: LD_VAR 0 6
95109: PUSH
95110: LD_INT 1
95112: ARRAY
95113: PPUSH
95114: LD_VAR 0 6
95118: PUSH
95119: LD_INT 2
95121: ARRAY
95122: PPUSH
95123: CALL_OW 176
95127: GO 95097
95129: POP
95130: POP
// repeat wait ( 0 0$1 ) ;
95131: LD_INT 35
95133: PPUSH
95134: CALL_OW 67
// task := GetTaskList ( flame ) ;
95138: LD_ADDR_VAR 0 14
95142: PUSH
95143: LD_VAR 0 1
95147: PPUSH
95148: CALL_OW 437
95152: ST_TO_ADDR
// if not task then
95153: LD_VAR 0 14
95157: NOT
95158: IFFALSE 95162
// exit ;
95160: GO 95298
// if task [ 1 ] [ 1 ] <> | then
95162: LD_VAR 0 14
95166: PUSH
95167: LD_INT 1
95169: ARRAY
95170: PUSH
95171: LD_INT 1
95173: ARRAY
95174: PUSH
95175: LD_STRING |
95177: NONEQUAL
95178: IFFALSE 95182
// exit ;
95180: GO 95298
// _x := task [ 1 ] [ 2 ] ;
95182: LD_ADDR_VAR 0 11
95186: PUSH
95187: LD_VAR 0 14
95191: PUSH
95192: LD_INT 1
95194: ARRAY
95195: PUSH
95196: LD_INT 2
95198: ARRAY
95199: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
95200: LD_ADDR_VAR 0 12
95204: PUSH
95205: LD_VAR 0 14
95209: PUSH
95210: LD_INT 1
95212: ARRAY
95213: PUSH
95214: LD_INT 3
95216: ARRAY
95217: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
95218: LD_VAR 0 11
95222: PPUSH
95223: LD_VAR 0 12
95227: PPUSH
95228: CALL_OW 351
95232: NOT
95233: IFTRUE 95252
95235: PUSH
95236: LD_VAR 0 11
95240: PPUSH
95241: LD_VAR 0 12
95245: PPUSH
95246: CALL_OW 554
95250: NOT
95251: OR
95252: IFFALSE 95286
// begin task := Delete ( task , 1 ) ;
95254: LD_ADDR_VAR 0 14
95258: PUSH
95259: LD_VAR 0 14
95263: PPUSH
95264: LD_INT 1
95266: PPUSH
95267: CALL_OW 3
95271: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
95272: LD_VAR 0 1
95276: PPUSH
95277: LD_VAR 0 14
95281: PPUSH
95282: CALL_OW 446
// end ; until not HasTask ( flame ) ;
95286: LD_VAR 0 1
95290: PPUSH
95291: CALL_OW 314
95295: NOT
95296: IFFALSE 95131
// end ;
95298: LD_VAR 0 5
95302: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95303: LD_EXP 68
95307: NOT
95308: IFFALSE 95358
95310: GO 95312
95312: DISABLE
// begin initHack := true ;
95313: LD_ADDR_EXP 68
95317: PUSH
95318: LD_INT 1
95320: ST_TO_ADDR
// hackTanks := [ ] ;
95321: LD_ADDR_EXP 69
95325: PUSH
95326: EMPTY
95327: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95328: LD_ADDR_EXP 70
95332: PUSH
95333: EMPTY
95334: ST_TO_ADDR
// hackLimit := 3 ;
95335: LD_ADDR_EXP 71
95339: PUSH
95340: LD_INT 3
95342: ST_TO_ADDR
// hackDist := 12 ;
95343: LD_ADDR_EXP 72
95347: PUSH
95348: LD_INT 12
95350: ST_TO_ADDR
// hackCounter := [ ] ;
95351: LD_ADDR_EXP 73
95355: PUSH
95356: EMPTY
95357: ST_TO_ADDR
// end ;
95358: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95359: LD_EXP 68
95363: IFFALSE 95381
95365: PUSH
95366: LD_INT 34
95368: PUSH
95369: LD_INT 99
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PPUSH
95376: CALL_OW 69
95380: AND
95381: IFFALSE 95634
95383: GO 95385
95385: DISABLE
95386: LD_INT 0
95388: PPUSH
95389: PPUSH
// begin enable ;
95390: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95391: LD_ADDR_VAR 0 1
95395: PUSH
95396: LD_INT 34
95398: PUSH
95399: LD_INT 99
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PPUSH
95406: CALL_OW 69
95410: PUSH
95411: FOR_IN
95412: IFFALSE 95632
// begin if not i in hackTanks then
95414: LD_VAR 0 1
95418: PUSH
95419: LD_EXP 69
95423: IN
95424: NOT
95425: IFFALSE 95508
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95427: LD_ADDR_EXP 69
95431: PUSH
95432: LD_EXP 69
95436: PPUSH
95437: LD_EXP 69
95441: PUSH
95442: LD_INT 1
95444: PLUS
95445: PPUSH
95446: LD_VAR 0 1
95450: PPUSH
95451: CALL_OW 1
95455: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95456: LD_ADDR_EXP 70
95460: PUSH
95461: LD_EXP 70
95465: PPUSH
95466: LD_EXP 70
95470: PUSH
95471: LD_INT 1
95473: PLUS
95474: PPUSH
95475: EMPTY
95476: PPUSH
95477: CALL_OW 1
95481: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95482: LD_ADDR_EXP 73
95486: PUSH
95487: LD_EXP 73
95491: PPUSH
95492: LD_EXP 73
95496: PUSH
95497: LD_INT 1
95499: PLUS
95500: PPUSH
95501: EMPTY
95502: PPUSH
95503: CALL_OW 1
95507: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95508: LD_VAR 0 1
95512: PPUSH
95513: CALL_OW 302
95517: NOT
95518: IFFALSE 95531
// begin HackUnlinkAll ( i ) ;
95520: LD_VAR 0 1
95524: PPUSH
95525: CALL 95637 0 1
// continue ;
95529: GO 95411
// end ; HackCheckCapturedStatus ( i ) ;
95531: LD_VAR 0 1
95535: PPUSH
95536: CALL 96082 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95540: LD_ADDR_VAR 0 2
95544: PUSH
95545: LD_INT 81
95547: PUSH
95548: LD_VAR 0 1
95552: PPUSH
95553: CALL_OW 255
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 33
95564: PUSH
95565: LD_INT 3
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 91
95574: PUSH
95575: LD_VAR 0 1
95579: PUSH
95580: LD_EXP 72
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: LIST
95589: PUSH
95590: LD_INT 50
95592: PUSH
95593: EMPTY
95594: LIST
95595: PUSH
95596: EMPTY
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: PPUSH
95602: CALL_OW 69
95606: ST_TO_ADDR
// if not tmp then
95607: LD_VAR 0 2
95611: NOT
95612: IFFALSE 95616
// continue ;
95614: GO 95411
// HackLink ( i , tmp ) ;
95616: LD_VAR 0 1
95620: PPUSH
95621: LD_VAR 0 2
95625: PPUSH
95626: CALL 95773 0 2
// end ;
95630: GO 95411
95632: POP
95633: POP
// end ;
95634: PPOPN 2
95636: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95637: LD_INT 0
95639: PPUSH
95640: PPUSH
95641: PPUSH
// if not hack in hackTanks then
95642: LD_VAR 0 1
95646: PUSH
95647: LD_EXP 69
95651: IN
95652: NOT
95653: IFFALSE 95657
// exit ;
95655: GO 95768
// index := GetElementIndex ( hackTanks , hack ) ;
95657: LD_ADDR_VAR 0 4
95661: PUSH
95662: LD_EXP 69
95666: PPUSH
95667: LD_VAR 0 1
95671: PPUSH
95672: CALL 16038 0 2
95676: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95677: LD_EXP 70
95681: PUSH
95682: LD_VAR 0 4
95686: ARRAY
95687: IFFALSE 95768
// begin for i in hackTanksCaptured [ index ] do
95689: LD_ADDR_VAR 0 3
95693: PUSH
95694: LD_EXP 70
95698: PUSH
95699: LD_VAR 0 4
95703: ARRAY
95704: PUSH
95705: FOR_IN
95706: IFFALSE 95732
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95708: LD_VAR 0 3
95712: PUSH
95713: LD_INT 1
95715: ARRAY
95716: PPUSH
95717: LD_VAR 0 3
95721: PUSH
95722: LD_INT 2
95724: ARRAY
95725: PPUSH
95726: CALL_OW 235
95730: GO 95705
95732: POP
95733: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
95734: LD_ADDR_EXP 70
95738: PUSH
95739: LD_EXP 70
95743: PPUSH
95744: LD_VAR 0 4
95748: PPUSH
95749: EMPTY
95750: PPUSH
95751: CALL_OW 1
95755: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
95756: LD_VAR 0 1
95760: PPUSH
95761: LD_INT 0
95763: PPUSH
95764: CALL_OW 505
// end ; end ;
95768: LD_VAR 0 2
95772: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
95773: LD_INT 0
95775: PPUSH
95776: PPUSH
95777: PPUSH
// if not hack in hackTanks or not vehicles then
95778: LD_VAR 0 1
95782: PUSH
95783: LD_EXP 69
95787: IN
95788: NOT
95789: IFTRUE 95798
95791: PUSH
95792: LD_VAR 0 2
95796: NOT
95797: OR
95798: IFFALSE 95802
// exit ;
95800: GO 96077
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
95802: LD_ADDR_VAR 0 2
95806: PUSH
95807: LD_VAR 0 1
95811: PPUSH
95812: LD_VAR 0 2
95816: PPUSH
95817: LD_INT 1
95819: PPUSH
95820: LD_INT 1
95822: PPUSH
95823: CALL 16690 0 4
95827: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
95828: LD_ADDR_VAR 0 5
95832: PUSH
95833: LD_EXP 69
95837: PPUSH
95838: LD_VAR 0 1
95842: PPUSH
95843: CALL 16038 0 2
95847: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
95848: LD_EXP 70
95852: PUSH
95853: LD_VAR 0 5
95857: ARRAY
95858: PUSH
95859: LD_EXP 71
95863: LESS
95864: IFFALSE 96053
// begin for i := 1 to vehicles do
95866: LD_ADDR_VAR 0 4
95870: PUSH
95871: DOUBLE
95872: LD_INT 1
95874: DEC
95875: ST_TO_ADDR
95876: LD_VAR 0 2
95880: PUSH
95881: FOR_TO
95882: IFFALSE 96051
// begin if hackTanksCaptured [ index ] = hackLimit then
95884: LD_EXP 70
95888: PUSH
95889: LD_VAR 0 5
95893: ARRAY
95894: PUSH
95895: LD_EXP 71
95899: EQUAL
95900: IFFALSE 95904
// break ;
95902: GO 96051
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
95904: LD_ADDR_EXP 73
95908: PUSH
95909: LD_EXP 73
95913: PPUSH
95914: LD_VAR 0 5
95918: PPUSH
95919: LD_EXP 73
95923: PUSH
95924: LD_VAR 0 5
95928: ARRAY
95929: PUSH
95930: LD_INT 1
95932: PLUS
95933: PPUSH
95934: CALL_OW 1
95938: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
95939: LD_ADDR_EXP 70
95943: PUSH
95944: LD_EXP 70
95948: PPUSH
95949: LD_VAR 0 5
95953: PUSH
95954: LD_EXP 70
95958: PUSH
95959: LD_VAR 0 5
95963: ARRAY
95964: PUSH
95965: LD_INT 1
95967: PLUS
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PPUSH
95973: LD_VAR 0 2
95977: PUSH
95978: LD_VAR 0 4
95982: ARRAY
95983: PUSH
95984: LD_VAR 0 2
95988: PUSH
95989: LD_VAR 0 4
95993: ARRAY
95994: PPUSH
95995: CALL_OW 255
95999: PUSH
96000: EMPTY
96001: LIST
96002: LIST
96003: PPUSH
96004: CALL 16255 0 3
96008: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96009: LD_VAR 0 2
96013: PUSH
96014: LD_VAR 0 4
96018: ARRAY
96019: PPUSH
96020: LD_VAR 0 1
96024: PPUSH
96025: CALL_OW 255
96029: PPUSH
96030: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96034: LD_VAR 0 2
96038: PUSH
96039: LD_VAR 0 4
96043: ARRAY
96044: PPUSH
96045: CALL_OW 141
// end ;
96049: GO 95881
96051: POP
96052: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96053: LD_VAR 0 1
96057: PPUSH
96058: LD_EXP 70
96062: PUSH
96063: LD_VAR 0 5
96067: ARRAY
96068: PUSH
96069: LD_INT 0
96071: PLUS
96072: PPUSH
96073: CALL_OW 505
// end ;
96077: LD_VAR 0 3
96081: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96082: LD_INT 0
96084: PPUSH
96085: PPUSH
96086: PPUSH
96087: PPUSH
// if not hack in hackTanks then
96088: LD_VAR 0 1
96092: PUSH
96093: LD_EXP 69
96097: IN
96098: NOT
96099: IFFALSE 96103
// exit ;
96101: GO 96347
// index := GetElementIndex ( hackTanks , hack ) ;
96103: LD_ADDR_VAR 0 4
96107: PUSH
96108: LD_EXP 69
96112: PPUSH
96113: LD_VAR 0 1
96117: PPUSH
96118: CALL 16038 0 2
96122: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96123: LD_ADDR_VAR 0 3
96127: PUSH
96128: DOUBLE
96129: LD_EXP 70
96133: PUSH
96134: LD_VAR 0 4
96138: ARRAY
96139: INC
96140: ST_TO_ADDR
96141: LD_INT 1
96143: PUSH
96144: FOR_DOWNTO
96145: IFFALSE 96321
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96147: LD_ADDR_VAR 0 5
96151: PUSH
96152: LD_EXP 70
96156: PUSH
96157: LD_VAR 0 4
96161: ARRAY
96162: PUSH
96163: LD_VAR 0 3
96167: ARRAY
96168: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96169: LD_VAR 0 5
96173: PUSH
96174: LD_INT 1
96176: ARRAY
96177: PPUSH
96178: CALL_OW 302
96182: NOT
96183: IFTRUE 96211
96185: PUSH
96186: LD_VAR 0 5
96190: PUSH
96191: LD_INT 1
96193: ARRAY
96194: PPUSH
96195: CALL_OW 255
96199: PUSH
96200: LD_VAR 0 1
96204: PPUSH
96205: CALL_OW 255
96209: NONEQUAL
96210: OR
96211: IFFALSE 96319
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96213: LD_VAR 0 5
96217: PUSH
96218: LD_INT 1
96220: ARRAY
96221: PPUSH
96222: CALL_OW 305
96226: IFFALSE 96254
96228: PUSH
96229: LD_VAR 0 5
96233: PUSH
96234: LD_INT 1
96236: ARRAY
96237: PPUSH
96238: CALL_OW 255
96242: PUSH
96243: LD_VAR 0 1
96247: PPUSH
96248: CALL_OW 255
96252: EQUAL
96253: AND
96254: IFFALSE 96278
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96256: LD_VAR 0 5
96260: PUSH
96261: LD_INT 1
96263: ARRAY
96264: PPUSH
96265: LD_VAR 0 5
96269: PUSH
96270: LD_INT 2
96272: ARRAY
96273: PPUSH
96274: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96278: LD_ADDR_EXP 70
96282: PUSH
96283: LD_EXP 70
96287: PPUSH
96288: LD_VAR 0 4
96292: PPUSH
96293: LD_EXP 70
96297: PUSH
96298: LD_VAR 0 4
96302: ARRAY
96303: PPUSH
96304: LD_VAR 0 3
96308: PPUSH
96309: CALL_OW 3
96313: PPUSH
96314: CALL_OW 1
96318: ST_TO_ADDR
// end ; end ;
96319: GO 96144
96321: POP
96322: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96323: LD_VAR 0 1
96327: PPUSH
96328: LD_EXP 70
96332: PUSH
96333: LD_VAR 0 4
96337: ARRAY
96338: PUSH
96339: LD_INT 0
96341: PLUS
96342: PPUSH
96343: CALL_OW 505
// end ;
96347: LD_VAR 0 2
96351: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96352: LD_INT 0
96354: PPUSH
96355: PPUSH
96356: PPUSH
96357: PPUSH
// if not hack in hackTanks then
96358: LD_VAR 0 1
96362: PUSH
96363: LD_EXP 69
96367: IN
96368: NOT
96369: IFFALSE 96373
// exit ;
96371: GO 96458
// index := GetElementIndex ( hackTanks , hack ) ;
96373: LD_ADDR_VAR 0 5
96377: PUSH
96378: LD_EXP 69
96382: PPUSH
96383: LD_VAR 0 1
96387: PPUSH
96388: CALL 16038 0 2
96392: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96393: LD_ADDR_VAR 0 4
96397: PUSH
96398: DOUBLE
96399: LD_INT 1
96401: DEC
96402: ST_TO_ADDR
96403: LD_EXP 70
96407: PUSH
96408: LD_VAR 0 5
96412: ARRAY
96413: PUSH
96414: FOR_TO
96415: IFFALSE 96456
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96417: LD_EXP 70
96421: PUSH
96422: LD_VAR 0 5
96426: ARRAY
96427: PUSH
96428: LD_VAR 0 4
96432: ARRAY
96433: PUSH
96434: LD_INT 1
96436: ARRAY
96437: PUSH
96438: LD_VAR 0 2
96442: EQUAL
96443: IFFALSE 96454
// KillUnit ( vehicle ) ;
96445: LD_VAR 0 2
96449: PPUSH
96450: CALL_OW 66
96454: GO 96414
96456: POP
96457: POP
// end ;
96458: LD_VAR 0 3
96462: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96463: LD_EXP 74
96467: NOT
96468: IFFALSE 96503
96470: GO 96472
96472: DISABLE
// begin initMiner := true ;
96473: LD_ADDR_EXP 74
96477: PUSH
96478: LD_INT 1
96480: ST_TO_ADDR
// minersList := [ ] ;
96481: LD_ADDR_EXP 75
96485: PUSH
96486: EMPTY
96487: ST_TO_ADDR
// minerMinesList := [ ] ;
96488: LD_ADDR_EXP 76
96492: PUSH
96493: EMPTY
96494: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96495: LD_ADDR_EXP 77
96499: PUSH
96500: LD_INT 5
96502: ST_TO_ADDR
// end ;
96503: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96504: LD_EXP 74
96508: IFFALSE 96526
96510: PUSH
96511: LD_INT 34
96513: PUSH
96514: LD_INT 81
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: PPUSH
96521: CALL_OW 69
96525: AND
96526: IFFALSE 96989
96528: GO 96530
96530: DISABLE
96531: LD_INT 0
96533: PPUSH
96534: PPUSH
96535: PPUSH
96536: PPUSH
// begin enable ;
96537: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96538: LD_ADDR_VAR 0 1
96542: PUSH
96543: LD_INT 34
96545: PUSH
96546: LD_INT 81
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PPUSH
96553: CALL_OW 69
96557: PUSH
96558: FOR_IN
96559: IFFALSE 96631
// begin if not i in minersList then
96561: LD_VAR 0 1
96565: PUSH
96566: LD_EXP 75
96570: IN
96571: NOT
96572: IFFALSE 96629
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96574: LD_ADDR_EXP 75
96578: PUSH
96579: LD_EXP 75
96583: PPUSH
96584: LD_EXP 75
96588: PUSH
96589: LD_INT 1
96591: PLUS
96592: PPUSH
96593: LD_VAR 0 1
96597: PPUSH
96598: CALL_OW 1
96602: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96603: LD_ADDR_EXP 76
96607: PUSH
96608: LD_EXP 76
96612: PPUSH
96613: LD_EXP 76
96617: PUSH
96618: LD_INT 1
96620: PLUS
96621: PPUSH
96622: EMPTY
96623: PPUSH
96624: CALL_OW 1
96628: ST_TO_ADDR
// end end ;
96629: GO 96558
96631: POP
96632: POP
// for i := minerMinesList downto 1 do
96633: LD_ADDR_VAR 0 1
96637: PUSH
96638: DOUBLE
96639: LD_EXP 76
96643: INC
96644: ST_TO_ADDR
96645: LD_INT 1
96647: PUSH
96648: FOR_DOWNTO
96649: IFFALSE 96987
// begin if IsLive ( minersList [ i ] ) then
96651: LD_EXP 75
96655: PUSH
96656: LD_VAR 0 1
96660: ARRAY
96661: PPUSH
96662: CALL_OW 300
96666: IFFALSE 96694
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96668: LD_EXP 75
96672: PUSH
96673: LD_VAR 0 1
96677: ARRAY
96678: PPUSH
96679: LD_EXP 76
96683: PUSH
96684: LD_VAR 0 1
96688: ARRAY
96689: PPUSH
96690: CALL_OW 505
// if not minerMinesList [ i ] then
96694: LD_EXP 76
96698: PUSH
96699: LD_VAR 0 1
96703: ARRAY
96704: NOT
96705: IFFALSE 96709
// continue ;
96707: GO 96648
// for j := minerMinesList [ i ] downto 1 do
96709: LD_ADDR_VAR 0 2
96713: PUSH
96714: DOUBLE
96715: LD_EXP 76
96719: PUSH
96720: LD_VAR 0 1
96724: ARRAY
96725: INC
96726: ST_TO_ADDR
96727: LD_INT 1
96729: PUSH
96730: FOR_DOWNTO
96731: IFFALSE 96983
// begin side := GetSide ( minersList [ i ] ) ;
96733: LD_ADDR_VAR 0 3
96737: PUSH
96738: LD_EXP 75
96742: PUSH
96743: LD_VAR 0 1
96747: ARRAY
96748: PPUSH
96749: CALL_OW 255
96753: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
96754: LD_ADDR_VAR 0 4
96758: PUSH
96759: LD_EXP 76
96763: PUSH
96764: LD_VAR 0 1
96768: ARRAY
96769: PUSH
96770: LD_VAR 0 2
96774: ARRAY
96775: PUSH
96776: LD_INT 1
96778: ARRAY
96779: PPUSH
96780: LD_EXP 76
96784: PUSH
96785: LD_VAR 0 1
96789: ARRAY
96790: PUSH
96791: LD_VAR 0 2
96795: ARRAY
96796: PUSH
96797: LD_INT 2
96799: ARRAY
96800: PPUSH
96801: CALL_OW 428
96805: ST_TO_ADDR
// if not tmp then
96806: LD_VAR 0 4
96810: NOT
96811: IFFALSE 96815
// continue ;
96813: GO 96730
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
96815: LD_VAR 0 4
96819: PUSH
96820: LD_INT 81
96822: PUSH
96823: LD_VAR 0 3
96827: PUSH
96828: EMPTY
96829: LIST
96830: LIST
96831: PPUSH
96832: CALL_OW 69
96836: IN
96837: IFFALSE 96887
96839: PUSH
96840: LD_EXP 76
96844: PUSH
96845: LD_VAR 0 1
96849: ARRAY
96850: PUSH
96851: LD_VAR 0 2
96855: ARRAY
96856: PUSH
96857: LD_INT 1
96859: ARRAY
96860: PPUSH
96861: LD_EXP 76
96865: PUSH
96866: LD_VAR 0 1
96870: ARRAY
96871: PUSH
96872: LD_VAR 0 2
96876: ARRAY
96877: PUSH
96878: LD_INT 2
96880: ARRAY
96881: PPUSH
96882: CALL_OW 458
96886: AND
96887: IFFALSE 96981
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
96889: LD_EXP 76
96893: PUSH
96894: LD_VAR 0 1
96898: ARRAY
96899: PUSH
96900: LD_VAR 0 2
96904: ARRAY
96905: PUSH
96906: LD_INT 1
96908: ARRAY
96909: PPUSH
96910: LD_EXP 76
96914: PUSH
96915: LD_VAR 0 1
96919: ARRAY
96920: PUSH
96921: LD_VAR 0 2
96925: ARRAY
96926: PUSH
96927: LD_INT 2
96929: ARRAY
96930: PPUSH
96931: LD_VAR 0 3
96935: PPUSH
96936: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
96940: LD_ADDR_EXP 76
96944: PUSH
96945: LD_EXP 76
96949: PPUSH
96950: LD_VAR 0 1
96954: PPUSH
96955: LD_EXP 76
96959: PUSH
96960: LD_VAR 0 1
96964: ARRAY
96965: PPUSH
96966: LD_VAR 0 2
96970: PPUSH
96971: CALL_OW 3
96975: PPUSH
96976: CALL_OW 1
96980: ST_TO_ADDR
// end ; end ;
96981: GO 96730
96983: POP
96984: POP
// end ;
96985: GO 96648
96987: POP
96988: POP
// end ;
96989: PPOPN 4
96991: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
96992: LD_INT 0
96994: PPUSH
96995: PPUSH
// result := false ;
96996: LD_ADDR_VAR 0 4
97000: PUSH
97001: LD_INT 0
97003: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97004: LD_VAR 0 1
97008: PPUSH
97009: CALL_OW 264
97013: PUSH
97014: LD_INT 81
97016: EQUAL
97017: NOT
97018: IFFALSE 97022
// exit ;
97020: GO 97266
// index := GetElementIndex ( minersList , unit ) ;
97022: LD_ADDR_VAR 0 5
97026: PUSH
97027: LD_EXP 75
97031: PPUSH
97032: LD_VAR 0 1
97036: PPUSH
97037: CALL 16038 0 2
97041: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97042: LD_EXP 76
97046: PUSH
97047: LD_VAR 0 5
97051: ARRAY
97052: PUSH
97053: LD_EXP 77
97057: GREATEREQUAL
97058: IFFALSE 97062
// exit ;
97060: GO 97266
// ComMoveXY ( unit , x , y ) ;
97062: LD_VAR 0 1
97066: PPUSH
97067: LD_VAR 0 2
97071: PPUSH
97072: LD_VAR 0 3
97076: PPUSH
97077: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97081: LD_INT 35
97083: PPUSH
97084: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97088: LD_VAR 0 1
97092: PPUSH
97093: LD_VAR 0 2
97097: PPUSH
97098: LD_VAR 0 3
97102: PPUSH
97103: CALL 48084 0 3
97107: NOT
97108: IFFALSE 97121
97110: PUSH
97111: LD_VAR 0 1
97115: PPUSH
97116: CALL_OW 314
97120: AND
97121: IFFALSE 97125
// exit ;
97123: GO 97266
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97125: LD_VAR 0 2
97129: PPUSH
97130: LD_VAR 0 3
97134: PPUSH
97135: CALL_OW 428
97139: PUSH
97140: LD_VAR 0 1
97144: EQUAL
97145: IFFALSE 97159
97147: PUSH
97148: LD_VAR 0 1
97152: PPUSH
97153: CALL_OW 314
97157: NOT
97158: AND
97159: IFFALSE 97081
// PlaySoundXY ( x , y , PlantMine ) ;
97161: LD_VAR 0 2
97165: PPUSH
97166: LD_VAR 0 3
97170: PPUSH
97171: LD_STRING PlantMine
97173: PPUSH
97174: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97178: LD_VAR 0 2
97182: PPUSH
97183: LD_VAR 0 3
97187: PPUSH
97188: LD_VAR 0 1
97192: PPUSH
97193: CALL_OW 255
97197: PPUSH
97198: LD_INT 0
97200: PPUSH
97201: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97205: LD_ADDR_EXP 76
97209: PUSH
97210: LD_EXP 76
97214: PPUSH
97215: LD_VAR 0 5
97219: PUSH
97220: LD_EXP 76
97224: PUSH
97225: LD_VAR 0 5
97229: ARRAY
97230: PUSH
97231: LD_INT 1
97233: PLUS
97234: PUSH
97235: EMPTY
97236: LIST
97237: LIST
97238: PPUSH
97239: LD_VAR 0 2
97243: PUSH
97244: LD_VAR 0 3
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PPUSH
97253: CALL 16255 0 3
97257: ST_TO_ADDR
// result := true ;
97258: LD_ADDR_VAR 0 4
97262: PUSH
97263: LD_INT 1
97265: ST_TO_ADDR
// end ;
97266: LD_VAR 0 4
97270: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97271: LD_INT 0
97273: PPUSH
97274: PPUSH
97275: PPUSH
// if not unit in minersList then
97276: LD_VAR 0 1
97280: PUSH
97281: LD_EXP 75
97285: IN
97286: NOT
97287: IFFALSE 97291
// exit ;
97289: GO 97685
// index := GetElementIndex ( minersList , unit ) ;
97291: LD_ADDR_VAR 0 6
97295: PUSH
97296: LD_EXP 75
97300: PPUSH
97301: LD_VAR 0 1
97305: PPUSH
97306: CALL 16038 0 2
97310: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97311: LD_ADDR_VAR 0 5
97315: PUSH
97316: DOUBLE
97317: LD_EXP 76
97321: PUSH
97322: LD_VAR 0 6
97326: ARRAY
97327: INC
97328: ST_TO_ADDR
97329: LD_INT 1
97331: PUSH
97332: FOR_DOWNTO
97333: IFFALSE 97496
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97335: LD_EXP 76
97339: PUSH
97340: LD_VAR 0 6
97344: ARRAY
97345: PUSH
97346: LD_VAR 0 5
97350: ARRAY
97351: PUSH
97352: LD_INT 1
97354: ARRAY
97355: PUSH
97356: LD_VAR 0 2
97360: EQUAL
97361: IFFALSE 97391
97363: PUSH
97364: LD_EXP 76
97368: PUSH
97369: LD_VAR 0 6
97373: ARRAY
97374: PUSH
97375: LD_VAR 0 5
97379: ARRAY
97380: PUSH
97381: LD_INT 2
97383: ARRAY
97384: PUSH
97385: LD_VAR 0 3
97389: EQUAL
97390: AND
97391: IFFALSE 97494
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97393: LD_EXP 76
97397: PUSH
97398: LD_VAR 0 6
97402: ARRAY
97403: PUSH
97404: LD_VAR 0 5
97408: ARRAY
97409: PUSH
97410: LD_INT 1
97412: ARRAY
97413: PPUSH
97414: LD_EXP 76
97418: PUSH
97419: LD_VAR 0 6
97423: ARRAY
97424: PUSH
97425: LD_VAR 0 5
97429: ARRAY
97430: PUSH
97431: LD_INT 2
97433: ARRAY
97434: PPUSH
97435: LD_VAR 0 1
97439: PPUSH
97440: CALL_OW 255
97444: PPUSH
97445: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97449: LD_ADDR_EXP 76
97453: PUSH
97454: LD_EXP 76
97458: PPUSH
97459: LD_VAR 0 6
97463: PPUSH
97464: LD_EXP 76
97468: PUSH
97469: LD_VAR 0 6
97473: ARRAY
97474: PPUSH
97475: LD_VAR 0 5
97479: PPUSH
97480: CALL_OW 3
97484: PPUSH
97485: CALL_OW 1
97489: ST_TO_ADDR
// exit ;
97490: POP
97491: POP
97492: GO 97685
// end ; end ;
97494: GO 97332
97496: POP
97497: POP
// for i := minerMinesList [ index ] downto 1 do
97498: LD_ADDR_VAR 0 5
97502: PUSH
97503: DOUBLE
97504: LD_EXP 76
97508: PUSH
97509: LD_VAR 0 6
97513: ARRAY
97514: INC
97515: ST_TO_ADDR
97516: LD_INT 1
97518: PUSH
97519: FOR_DOWNTO
97520: IFFALSE 97683
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97522: LD_EXP 76
97526: PUSH
97527: LD_VAR 0 6
97531: ARRAY
97532: PUSH
97533: LD_VAR 0 5
97537: ARRAY
97538: PUSH
97539: LD_INT 1
97541: ARRAY
97542: PPUSH
97543: LD_EXP 76
97547: PUSH
97548: LD_VAR 0 6
97552: ARRAY
97553: PUSH
97554: LD_VAR 0 5
97558: ARRAY
97559: PUSH
97560: LD_INT 2
97562: ARRAY
97563: PPUSH
97564: LD_VAR 0 2
97568: PPUSH
97569: LD_VAR 0 3
97573: PPUSH
97574: CALL_OW 298
97578: PUSH
97579: LD_INT 6
97581: LESS
97582: IFFALSE 97681
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97584: LD_EXP 76
97588: PUSH
97589: LD_VAR 0 6
97593: ARRAY
97594: PUSH
97595: LD_VAR 0 5
97599: ARRAY
97600: PUSH
97601: LD_INT 1
97603: ARRAY
97604: PPUSH
97605: LD_EXP 76
97609: PUSH
97610: LD_VAR 0 6
97614: ARRAY
97615: PUSH
97616: LD_VAR 0 5
97620: ARRAY
97621: PUSH
97622: LD_INT 2
97624: ARRAY
97625: PPUSH
97626: LD_VAR 0 1
97630: PPUSH
97631: CALL_OW 255
97635: PPUSH
97636: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97640: LD_ADDR_EXP 76
97644: PUSH
97645: LD_EXP 76
97649: PPUSH
97650: LD_VAR 0 6
97654: PPUSH
97655: LD_EXP 76
97659: PUSH
97660: LD_VAR 0 6
97664: ARRAY
97665: PPUSH
97666: LD_VAR 0 5
97670: PPUSH
97671: CALL_OW 3
97675: PPUSH
97676: CALL_OW 1
97680: ST_TO_ADDR
// end ; end ;
97681: GO 97519
97683: POP
97684: POP
// end ;
97685: LD_VAR 0 4
97689: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97690: LD_INT 0
97692: PPUSH
97693: PPUSH
97694: PPUSH
97695: PPUSH
97696: PPUSH
97697: PPUSH
97698: PPUSH
97699: PPUSH
97700: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97701: LD_VAR 0 1
97705: PPUSH
97706: CALL_OW 264
97710: PUSH
97711: LD_INT 81
97713: EQUAL
97714: NOT
97715: IFTRUE 97730
97717: PUSH
97718: LD_VAR 0 1
97722: PUSH
97723: LD_EXP 75
97727: IN
97728: NOT
97729: OR
97730: IFFALSE 97734
// exit ;
97732: GO 98060
// index := GetElementIndex ( minersList , unit ) ;
97734: LD_ADDR_VAR 0 6
97738: PUSH
97739: LD_EXP 75
97743: PPUSH
97744: LD_VAR 0 1
97748: PPUSH
97749: CALL 16038 0 2
97753: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
97754: LD_ADDR_VAR 0 8
97758: PUSH
97759: LD_EXP 77
97763: PUSH
97764: LD_EXP 76
97768: PUSH
97769: LD_VAR 0 6
97773: ARRAY
97774: MINUS
97775: ST_TO_ADDR
// if not minesFreeAmount then
97776: LD_VAR 0 8
97780: NOT
97781: IFFALSE 97785
// exit ;
97783: GO 98060
// tmp := [ ] ;
97785: LD_ADDR_VAR 0 7
97789: PUSH
97790: EMPTY
97791: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
97792: LD_ADDR_VAR 0 5
97796: PUSH
97797: DOUBLE
97798: LD_INT 1
97800: DEC
97801: ST_TO_ADDR
97802: LD_VAR 0 8
97806: PUSH
97807: FOR_TO
97808: IFFALSE 98007
// begin _d := rand ( 0 , 5 ) ;
97810: LD_ADDR_VAR 0 11
97814: PUSH
97815: LD_INT 0
97817: PPUSH
97818: LD_INT 5
97820: PPUSH
97821: CALL_OW 12
97825: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
97826: LD_ADDR_VAR 0 12
97830: PUSH
97831: LD_INT 2
97833: PPUSH
97834: LD_INT 6
97836: PPUSH
97837: CALL_OW 12
97841: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
97842: LD_ADDR_VAR 0 9
97846: PUSH
97847: LD_VAR 0 2
97851: PPUSH
97852: LD_VAR 0 11
97856: PPUSH
97857: LD_VAR 0 12
97861: PPUSH
97862: CALL_OW 272
97866: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
97867: LD_ADDR_VAR 0 10
97871: PUSH
97872: LD_VAR 0 3
97876: PPUSH
97877: LD_VAR 0 11
97881: PPUSH
97882: LD_VAR 0 12
97886: PPUSH
97887: CALL_OW 273
97891: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
97892: LD_VAR 0 9
97896: PPUSH
97897: LD_VAR 0 10
97901: PPUSH
97902: CALL_OW 488
97906: IFFALSE 97930
97908: PUSH
97909: LD_VAR 0 9
97913: PUSH
97914: LD_VAR 0 10
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_VAR 0 7
97927: IN
97928: NOT
97929: AND
97930: IFFALSE 97949
97932: PUSH
97933: LD_VAR 0 9
97937: PPUSH
97938: LD_VAR 0 10
97942: PPUSH
97943: CALL_OW 458
97947: NOT
97948: AND
97949: IFFALSE 97991
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
97951: LD_ADDR_VAR 0 7
97955: PUSH
97956: LD_VAR 0 7
97960: PPUSH
97961: LD_VAR 0 7
97965: PUSH
97966: LD_INT 1
97968: PLUS
97969: PPUSH
97970: LD_VAR 0 9
97974: PUSH
97975: LD_VAR 0 10
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PPUSH
97984: CALL_OW 1
97988: ST_TO_ADDR
97989: GO 98005
// i := i - 1 ;
97991: LD_ADDR_VAR 0 5
97995: PUSH
97996: LD_VAR 0 5
98000: PUSH
98001: LD_INT 1
98003: MINUS
98004: ST_TO_ADDR
// end ;
98005: GO 97807
98007: POP
98008: POP
// for i in tmp do
98009: LD_ADDR_VAR 0 5
98013: PUSH
98014: LD_VAR 0 7
98018: PUSH
98019: FOR_IN
98020: IFFALSE 98058
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98022: LD_VAR 0 1
98026: PPUSH
98027: LD_VAR 0 5
98031: PUSH
98032: LD_INT 1
98034: ARRAY
98035: PPUSH
98036: LD_VAR 0 5
98040: PUSH
98041: LD_INT 2
98043: ARRAY
98044: PPUSH
98045: CALL 96992 0 3
98049: NOT
98050: IFFALSE 98056
// exit ;
98052: POP
98053: POP
98054: GO 98060
98056: GO 98019
98058: POP
98059: POP
// end ;
98060: LD_VAR 0 4
98064: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
98065: LD_INT 0
98067: PPUSH
98068: PPUSH
98069: PPUSH
98070: PPUSH
98071: PPUSH
98072: PPUSH
98073: PPUSH
98074: PPUSH
98075: PPUSH
// if GetClass ( unit ) <> class_sniper then
98076: LD_VAR 0 1
98080: PPUSH
98081: CALL_OW 257
98085: PUSH
98086: LD_INT 5
98088: NONEQUAL
98089: IFFALSE 98093
// exit ;
98091: GO 98563
// dist := 8 ;
98093: LD_ADDR_VAR 0 5
98097: PUSH
98098: LD_INT 8
98100: ST_TO_ADDR
// viewRange := 12 ;
98101: LD_ADDR_VAR 0 8
98105: PUSH
98106: LD_INT 12
98108: ST_TO_ADDR
// side := GetSide ( unit ) ;
98109: LD_ADDR_VAR 0 6
98113: PUSH
98114: LD_VAR 0 1
98118: PPUSH
98119: CALL_OW 255
98123: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98124: LD_INT 61
98126: PPUSH
98127: LD_VAR 0 6
98131: PPUSH
98132: CALL_OW 321
98136: PUSH
98137: LD_INT 2
98139: EQUAL
98140: IFFALSE 98150
// viewRange := 16 ;
98142: LD_ADDR_VAR 0 8
98146: PUSH
98147: LD_INT 16
98149: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98150: LD_VAR 0 1
98154: PPUSH
98155: LD_VAR 0 2
98159: PPUSH
98160: LD_VAR 0 3
98164: PPUSH
98165: CALL_OW 297
98169: PUSH
98170: LD_VAR 0 5
98174: GREATER
98175: IFFALSE 98254
// begin ComMoveXY ( unit , x , y ) ;
98177: LD_VAR 0 1
98181: PPUSH
98182: LD_VAR 0 2
98186: PPUSH
98187: LD_VAR 0 3
98191: PPUSH
98192: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98196: LD_INT 35
98198: PPUSH
98199: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98203: LD_VAR 0 1
98207: PPUSH
98208: LD_VAR 0 2
98212: PPUSH
98213: LD_VAR 0 3
98217: PPUSH
98218: CALL 48084 0 3
98222: NOT
98223: IFFALSE 98227
// exit ;
98225: GO 98563
// until GetDistUnitXY ( unit , x , y ) < dist ;
98227: LD_VAR 0 1
98231: PPUSH
98232: LD_VAR 0 2
98236: PPUSH
98237: LD_VAR 0 3
98241: PPUSH
98242: CALL_OW 297
98246: PUSH
98247: LD_VAR 0 5
98251: LESS
98252: IFFALSE 98196
// end ; ComTurnXY ( unit , x , y ) ;
98254: LD_VAR 0 1
98258: PPUSH
98259: LD_VAR 0 2
98263: PPUSH
98264: LD_VAR 0 3
98268: PPUSH
98269: CALL_OW 118
// repeat if Multiplayer then
98273: LD_OWVAR 4
98277: IFFALSE 98288
// wait ( 35 ) else
98279: LD_INT 35
98281: PPUSH
98282: CALL_OW 67
98286: GO 98295
// wait ( 5 ) ;
98288: LD_INT 5
98290: PPUSH
98291: CALL_OW 67
// _d := GetDir ( unit ) ;
98295: LD_ADDR_VAR 0 11
98299: PUSH
98300: LD_VAR 0 1
98304: PPUSH
98305: CALL_OW 254
98309: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
98310: LD_ADDR_VAR 0 7
98314: PUSH
98315: LD_VAR 0 1
98319: PPUSH
98320: CALL_OW 250
98324: PPUSH
98325: LD_VAR 0 1
98329: PPUSH
98330: CALL_OW 251
98334: PPUSH
98335: LD_VAR 0 2
98339: PPUSH
98340: LD_VAR 0 3
98344: PPUSH
98345: CALL 50720 0 4
98349: ST_TO_ADDR
// until dir = _d ;
98350: LD_VAR 0 7
98354: PUSH
98355: LD_VAR 0 11
98359: EQUAL
98360: IFFALSE 98273
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
98362: LD_ADDR_VAR 0 9
98366: PUSH
98367: LD_VAR 0 1
98371: PPUSH
98372: CALL_OW 250
98376: PPUSH
98377: LD_VAR 0 7
98381: PPUSH
98382: LD_VAR 0 5
98386: PPUSH
98387: CALL_OW 272
98391: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
98392: LD_ADDR_VAR 0 10
98396: PUSH
98397: LD_VAR 0 1
98401: PPUSH
98402: CALL_OW 251
98406: PPUSH
98407: LD_VAR 0 7
98411: PPUSH
98412: LD_VAR 0 5
98416: PPUSH
98417: CALL_OW 273
98421: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98422: LD_VAR 0 9
98426: PPUSH
98427: LD_VAR 0 10
98431: PPUSH
98432: CALL_OW 488
98436: NOT
98437: IFFALSE 98441
// exit ;
98439: GO 98563
// ComAnimCustom ( unit , 1 ) ;
98441: LD_VAR 0 1
98445: PPUSH
98446: LD_INT 1
98448: PPUSH
98449: CALL_OW 592
// p := 0 ;
98453: LD_ADDR_VAR 0 12
98457: PUSH
98458: LD_INT 0
98460: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98461: LD_VAR 0 9
98465: PPUSH
98466: LD_VAR 0 10
98470: PPUSH
98471: LD_VAR 0 6
98475: PPUSH
98476: LD_VAR 0 8
98480: PPUSH
98481: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
98485: LD_INT 35
98487: PPUSH
98488: CALL_OW 67
// p := Inc ( p ) ;
98492: LD_ADDR_VAR 0 12
98496: PUSH
98497: LD_VAR 0 12
98501: PPUSH
98502: CALL 50676 0 1
98506: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
98507: LD_VAR 0 12
98511: PUSH
98512: LD_INT 3
98514: EQUAL
98515: IFTRUE 98529
98517: PUSH
98518: LD_VAR 0 1
98522: PPUSH
98523: CALL_OW 302
98527: NOT
98528: OR
98529: IFTRUE 98542
98531: PUSH
98532: LD_VAR 0 1
98536: PPUSH
98537: CALL_OW 301
98541: OR
98542: IFFALSE 98485
// RemoveSeeing ( _x , _y , side ) ;
98544: LD_VAR 0 9
98548: PPUSH
98549: LD_VAR 0 10
98553: PPUSH
98554: LD_VAR 0 6
98558: PPUSH
98559: CALL_OW 331
// end ;
98563: LD_VAR 0 4
98567: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
98568: LD_INT 0
98570: PPUSH
98571: PPUSH
98572: PPUSH
98573: PPUSH
98574: PPUSH
98575: PPUSH
98576: PPUSH
98577: PPUSH
98578: PPUSH
98579: PPUSH
98580: PPUSH
// if not unit then
98581: LD_VAR 0 1
98585: NOT
98586: IFFALSE 98590
// exit ;
98588: GO 98861
// side := GetSide ( unit ) ;
98590: LD_ADDR_VAR 0 3
98594: PUSH
98595: LD_VAR 0 1
98599: PPUSH
98600: CALL_OW 255
98604: ST_TO_ADDR
// x := GetX ( unit ) ;
98605: LD_ADDR_VAR 0 5
98609: PUSH
98610: LD_VAR 0 1
98614: PPUSH
98615: CALL_OW 250
98619: ST_TO_ADDR
// y := GetY ( unit ) ;
98620: LD_ADDR_VAR 0 6
98624: PUSH
98625: LD_VAR 0 1
98629: PPUSH
98630: CALL_OW 251
98634: ST_TO_ADDR
// r := 8 ;
98635: LD_ADDR_VAR 0 4
98639: PUSH
98640: LD_INT 8
98642: ST_TO_ADDR
// if x - r < 0 then
98643: LD_VAR 0 5
98647: PUSH
98648: LD_VAR 0 4
98652: MINUS
98653: PUSH
98654: LD_INT 0
98656: LESS
98657: IFFALSE 98669
// min_x := 0 else
98659: LD_ADDR_VAR 0 7
98663: PUSH
98664: LD_INT 0
98666: ST_TO_ADDR
98667: GO 98685
// min_x := x - r ;
98669: LD_ADDR_VAR 0 7
98673: PUSH
98674: LD_VAR 0 5
98678: PUSH
98679: LD_VAR 0 4
98683: MINUS
98684: ST_TO_ADDR
// if y - r < 0 then
98685: LD_VAR 0 6
98689: PUSH
98690: LD_VAR 0 4
98694: MINUS
98695: PUSH
98696: LD_INT 0
98698: LESS
98699: IFFALSE 98711
// min_y := 0 else
98701: LD_ADDR_VAR 0 8
98705: PUSH
98706: LD_INT 0
98708: ST_TO_ADDR
98709: GO 98727
// min_y := y - r ;
98711: LD_ADDR_VAR 0 8
98715: PUSH
98716: LD_VAR 0 6
98720: PUSH
98721: LD_VAR 0 4
98725: MINUS
98726: ST_TO_ADDR
// max_x := x + r ;
98727: LD_ADDR_VAR 0 9
98731: PUSH
98732: LD_VAR 0 5
98736: PUSH
98737: LD_VAR 0 4
98741: PLUS
98742: ST_TO_ADDR
// max_y := y + r ;
98743: LD_ADDR_VAR 0 10
98747: PUSH
98748: LD_VAR 0 6
98752: PUSH
98753: LD_VAR 0 4
98757: PLUS
98758: ST_TO_ADDR
// for _x = min_x to max_x do
98759: LD_ADDR_VAR 0 11
98763: PUSH
98764: DOUBLE
98765: LD_VAR 0 7
98769: DEC
98770: ST_TO_ADDR
98771: LD_VAR 0 9
98775: PUSH
98776: FOR_TO
98777: IFFALSE 98859
// for _y = min_y to max_y do
98779: LD_ADDR_VAR 0 12
98783: PUSH
98784: DOUBLE
98785: LD_VAR 0 8
98789: DEC
98790: ST_TO_ADDR
98791: LD_VAR 0 10
98795: PUSH
98796: FOR_TO
98797: IFFALSE 98855
// begin if not ValidHex ( _x , _y ) then
98799: LD_VAR 0 11
98803: PPUSH
98804: LD_VAR 0 12
98808: PPUSH
98809: CALL_OW 488
98813: NOT
98814: IFFALSE 98818
// continue ;
98816: GO 98796
// if MineAtPos ( _x , _y ) then
98818: LD_VAR 0 11
98822: PPUSH
98823: LD_VAR 0 12
98827: PPUSH
98828: CALL_OW 458
98832: IFFALSE 98853
// ViewMineAtPos ( _x , _y , side ) ;
98834: LD_VAR 0 11
98838: PPUSH
98839: LD_VAR 0 12
98843: PPUSH
98844: LD_VAR 0 3
98848: PPUSH
98849: CALL_OW 457
// end ;
98853: GO 98796
98855: POP
98856: POP
98857: GO 98776
98859: POP
98860: POP
// end ;
98861: LD_VAR 0 2
98865: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
98866: LD_INT 0
98868: PPUSH
98869: PPUSH
98870: PPUSH
98871: PPUSH
98872: PPUSH
98873: PPUSH
// if not units then
98874: LD_VAR 0 1
98878: NOT
98879: IFFALSE 98883
// exit ;
98881: GO 99313
// scaners := [ ] ;
98883: LD_ADDR_VAR 0 6
98887: PUSH
98888: EMPTY
98889: ST_TO_ADDR
// for i in units do
98890: LD_ADDR_VAR 0 3
98894: PUSH
98895: LD_VAR 0 1
98899: PUSH
98900: FOR_IN
98901: IFFALSE 99058
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
98903: LD_VAR 0 3
98907: PPUSH
98908: CALL_OW 264
98912: PUSH
98913: LD_INT 11
98915: NONEQUAL
98916: IFTRUE 98930
98918: PUSH
98919: LD_VAR 0 3
98923: PPUSH
98924: CALL_OW 302
98928: NOT
98929: OR
98930: IFTRUE 98947
98932: PUSH
98933: LD_VAR 0 3
98937: PPUSH
98938: CALL_OW 110
98942: PUSH
98943: LD_INT 502
98945: EQUAL
98946: OR
98947: IFFALSE 98951
// continue ;
98949: GO 98900
// ComStop ( i ) ;
98951: LD_VAR 0 3
98955: PPUSH
98956: CALL_OW 141
// x := GetX ( i ) ;
98960: LD_ADDR_VAR 0 4
98964: PUSH
98965: LD_VAR 0 3
98969: PPUSH
98970: CALL_OW 250
98974: ST_TO_ADDR
// y := GetY ( i ) ;
98975: LD_ADDR_VAR 0 5
98979: PUSH
98980: LD_VAR 0 3
98984: PPUSH
98985: CALL_OW 251
98989: ST_TO_ADDR
// if GetSide ( i ) = your_side then
98990: LD_VAR 0 3
98994: PPUSH
98995: CALL_OW 255
98999: PUSH
99000: LD_OWVAR 2
99004: EQUAL
99005: IFFALSE 99024
// PlaySoundXY ( x , y , mineDetector ) ;
99007: LD_VAR 0 4
99011: PPUSH
99012: LD_VAR 0 5
99016: PPUSH
99017: LD_STRING mineDetector
99019: PPUSH
99020: CALL_OW 366
// scaners := Join ( scaners , i ) ;
99024: LD_ADDR_VAR 0 6
99028: PUSH
99029: LD_VAR 0 6
99033: PPUSH
99034: LD_VAR 0 3
99038: PPUSH
99039: CALL 49303 0 2
99043: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
99044: LD_VAR 0 3
99048: PPUSH
99049: LD_INT 502
99051: PPUSH
99052: CALL_OW 109
// end ;
99056: GO 98900
99058: POP
99059: POP
// if not scaners then
99060: LD_VAR 0 6
99064: NOT
99065: IFFALSE 99069
// exit ;
99067: GO 99313
// wait ( 3 ) ;
99069: LD_INT 3
99071: PPUSH
99072: CALL_OW 67
// timer := 6 ;
99076: LD_ADDR_VAR 0 7
99080: PUSH
99081: LD_INT 6
99083: ST_TO_ADDR
// repeat for i in scaners do
99084: LD_ADDR_VAR 0 3
99088: PUSH
99089: LD_VAR 0 6
99093: PUSH
99094: FOR_IN
99095: IFFALSE 99211
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
99097: LD_VAR 0 3
99101: PPUSH
99102: CALL_OW 302
99106: NOT
99107: IFTRUE 99120
99109: PUSH
99110: LD_VAR 0 3
99114: PPUSH
99115: CALL_OW 314
99119: OR
99120: IFTRUE 99151
99122: PUSH
99123: LD_VAR 0 3
99127: PPUSH
99128: CALL_OW 263
99132: PUSH
99133: LD_INT 1
99135: EQUAL
99136: IFFALSE 99150
99138: PUSH
99139: LD_VAR 0 3
99143: PPUSH
99144: CALL_OW 311
99148: NOT
99149: AND
99150: OR
99151: IFFALSE 99195
// begin SetUnitDisplayNumber ( i , 0 ) ;
99153: LD_VAR 0 3
99157: PPUSH
99158: LD_INT 0
99160: PPUSH
99161: CALL_OW 505
// SetTag ( i , 0 ) ;
99165: LD_VAR 0 3
99169: PPUSH
99170: LD_INT 0
99172: PPUSH
99173: CALL_OW 109
// scaners := scaners diff i ;
99177: LD_ADDR_VAR 0 6
99181: PUSH
99182: LD_VAR 0 6
99186: PUSH
99187: LD_VAR 0 3
99191: DIFF
99192: ST_TO_ADDR
// continue ;
99193: GO 99094
// end ; SetUnitDisplayNumber ( i , timer ) ;
99195: LD_VAR 0 3
99199: PPUSH
99200: LD_VAR 0 7
99204: PPUSH
99205: CALL_OW 505
// end ;
99209: GO 99094
99211: POP
99212: POP
// if not scaners then
99213: LD_VAR 0 6
99217: NOT
99218: IFFALSE 99222
// exit ;
99220: GO 99313
// timer := Dec ( timer ) ;
99222: LD_ADDR_VAR 0 7
99226: PUSH
99227: LD_VAR 0 7
99231: PPUSH
99232: CALL 50698 0 1
99236: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99237: LD_INT 35
99239: PPUSH
99240: CALL_OW 67
// until timer = 0 ;
99244: LD_VAR 0 7
99248: PUSH
99249: LD_INT 0
99251: EQUAL
99252: IFFALSE 99084
// if not scaners then
99254: LD_VAR 0 6
99258: NOT
99259: IFFALSE 99263
// exit ;
99261: GO 99313
// for i in scaners do
99263: LD_ADDR_VAR 0 3
99267: PUSH
99268: LD_VAR 0 6
99272: PUSH
99273: FOR_IN
99274: IFFALSE 99311
// begin SetUnitDisplayNumber ( i , 0 ) ;
99276: LD_VAR 0 3
99280: PPUSH
99281: LD_INT 0
99283: PPUSH
99284: CALL_OW 505
// SetTag ( i , 0 ) ;
99288: LD_VAR 0 3
99292: PPUSH
99293: LD_INT 0
99295: PPUSH
99296: CALL_OW 109
// RevealDetectorMine ( i ) ;
99300: LD_VAR 0 3
99304: PPUSH
99305: CALL 98568 0 1
// end ;
99309: GO 99273
99311: POP
99312: POP
// end ;
99313: LD_VAR 0 2
99317: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
99318: LD_INT 0
99320: PPUSH
// if p1 = mine_detector_mode then
99321: LD_VAR 0 2
99325: PUSH
99326: LD_INT 103
99328: EQUAL
99329: IFFALSE 99340
// DetectMine ( units ) ;
99331: LD_VAR 0 1
99335: PPUSH
99336: CALL 98866 0 1
// end ; end_of_file end_of_file
99340: LD_VAR 0 7
99344: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
99345: LD_VAR 0 1
99349: PUSH
99350: LD_INT 200
99352: DOUBLE
99353: GREATEREQUAL
99354: IFFALSE 99362
99356: LD_INT 299
99358: DOUBLE
99359: LESSEQUAL
99360: IFTRUE 99364
99362: GO 99396
99364: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
99365: LD_VAR 0 1
99369: PPUSH
99370: LD_VAR 0 2
99374: PPUSH
99375: LD_VAR 0 3
99379: PPUSH
99380: LD_VAR 0 4
99384: PPUSH
99385: LD_VAR 0 5
99389: PPUSH
99390: CALL 93811 0 5
99394: GO 99473
99396: LD_INT 300
99398: DOUBLE
99399: GREATEREQUAL
99400: IFFALSE 99408
99402: LD_INT 399
99404: DOUBLE
99405: LESSEQUAL
99406: IFTRUE 99410
99408: GO 99472
99410: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
99411: LD_VAR 0 1
99415: PPUSH
99416: LD_VAR 0 2
99420: PPUSH
99421: LD_VAR 0 3
99425: PPUSH
99426: LD_VAR 0 4
99430: PPUSH
99431: LD_VAR 0 5
99435: PPUSH
99436: LD_VAR 0 6
99440: PPUSH
99441: LD_VAR 0 7
99445: PPUSH
99446: LD_VAR 0 8
99450: PPUSH
99451: LD_VAR 0 9
99455: PPUSH
99456: LD_VAR 0 10
99460: PPUSH
99461: LD_VAR 0 11
99465: PPUSH
99466: CALL 112140 0 11
99470: GO 99473
99472: POP
// end ;
99473: PPOPN 11
99475: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
99476: LD_VAR 0 1
99480: PPUSH
99481: LD_VAR 0 2
99485: PPUSH
99486: LD_VAR 0 3
99490: PPUSH
99491: LD_VAR 0 4
99495: PPUSH
99496: LD_VAR 0 5
99500: PPUSH
99501: CALL 93192 0 5
// end ; end_of_file
99505: PPOPN 5
99507: END
// export globalGameSaveCounter ; every 0 0$1 do
99508: GO 99510
99510: DISABLE
// begin enable ;
99511: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
99512: LD_STRING updateTimer(
99514: PUSH
99515: LD_OWVAR 1
99519: STR
99520: PUSH
99521: LD_STRING );
99523: STR
99524: PPUSH
99525: CALL_OW 559
// end ;
99529: END
// every 0 0$1 do
99530: GO 99532
99532: DISABLE
// begin globalGameSaveCounter := 0 ;
99533: LD_ADDR_EXP 78
99537: PUSH
99538: LD_INT 0
99540: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
99541: LD_STRING setGameSaveCounter(0)
99543: PPUSH
99544: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
99548: LD_STRING initStreamRollete();
99550: PPUSH
99551: CALL_OW 559
// InitStreamMode ;
99555: CALL 100900 0 0
// DefineStreamItems ( false ) ;
99559: LD_INT 0
99561: PPUSH
99562: CALL 101364 0 1
// end ;
99566: END
// export function SOS_MapStart ( ) ; begin
99567: LD_INT 0
99569: PPUSH
// if streamModeActive then
99570: LD_EXP 79
99574: IFFALSE 99583
// DefineStreamItems ( true ) ;
99576: LD_INT 1
99578: PPUSH
99579: CALL 101364 0 1
// UpdateLuaVariables ( ) ;
99583: CALL 99600 0 0
// UpdateFactoryWaypoints ( ) ;
99587: CALL 114486 0 0
// UpdateWarehouseGatheringPoints ( ) ;
99591: CALL 114738 0 0
// end ;
99595: LD_VAR 0 1
99599: RET
// function UpdateLuaVariables ( ) ; begin
99600: LD_INT 0
99602: PPUSH
// if globalGameSaveCounter then
99603: LD_EXP 78
99607: IFFALSE 99641
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
99609: LD_ADDR_EXP 78
99613: PUSH
99614: LD_EXP 78
99618: PPUSH
99619: CALL 50676 0 1
99623: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
99624: LD_STRING setGameSaveCounter(
99626: PUSH
99627: LD_EXP 78
99631: STR
99632: PUSH
99633: LD_STRING )
99635: STR
99636: PPUSH
99637: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
99641: LD_STRING setGameDifficulty(
99643: PUSH
99644: LD_OWVAR 67
99648: STR
99649: PUSH
99650: LD_STRING )
99652: STR
99653: PPUSH
99654: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
99658: LD_STRING displayDifficulty(
99660: PUSH
99661: LD_OWVAR 67
99665: STR
99666: PUSH
99667: LD_STRING )
99669: STR
99670: PPUSH
99671: CALL_OW 559
// end ;
99675: LD_VAR 0 1
99679: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99680: LD_INT 0
99682: PPUSH
// if p2 = stream_mode then
99683: LD_VAR 0 2
99687: PUSH
99688: LD_INT 100
99690: EQUAL
99691: IFFALSE 100694
// begin if not StreamModeActive then
99693: LD_EXP 79
99697: NOT
99698: IFFALSE 99708
// StreamModeActive := true ;
99700: LD_ADDR_EXP 79
99704: PUSH
99705: LD_INT 1
99707: ST_TO_ADDR
// if p3 = 0 then
99708: LD_VAR 0 3
99712: PUSH
99713: LD_INT 0
99715: EQUAL
99716: IFFALSE 99722
// InitStreamMode ;
99718: CALL 100900 0 0
// if p3 = 1 then
99722: LD_VAR 0 3
99726: PUSH
99727: LD_INT 1
99729: EQUAL
99730: IFFALSE 99740
// sRocket := true ;
99732: LD_ADDR_EXP 84
99736: PUSH
99737: LD_INT 1
99739: ST_TO_ADDR
// if p3 = 2 then
99740: LD_VAR 0 3
99744: PUSH
99745: LD_INT 2
99747: EQUAL
99748: IFFALSE 99758
// sSpeed := true ;
99750: LD_ADDR_EXP 83
99754: PUSH
99755: LD_INT 1
99757: ST_TO_ADDR
// if p3 = 3 then
99758: LD_VAR 0 3
99762: PUSH
99763: LD_INT 3
99765: EQUAL
99766: IFFALSE 99776
// sEngine := true ;
99768: LD_ADDR_EXP 85
99772: PUSH
99773: LD_INT 1
99775: ST_TO_ADDR
// if p3 = 4 then
99776: LD_VAR 0 3
99780: PUSH
99781: LD_INT 4
99783: EQUAL
99784: IFFALSE 99794
// sSpec := true ;
99786: LD_ADDR_EXP 82
99790: PUSH
99791: LD_INT 1
99793: ST_TO_ADDR
// if p3 = 5 then
99794: LD_VAR 0 3
99798: PUSH
99799: LD_INT 5
99801: EQUAL
99802: IFFALSE 99812
// sLevel := true ;
99804: LD_ADDR_EXP 86
99808: PUSH
99809: LD_INT 1
99811: ST_TO_ADDR
// if p3 = 6 then
99812: LD_VAR 0 3
99816: PUSH
99817: LD_INT 6
99819: EQUAL
99820: IFFALSE 99830
// sArmoury := true ;
99822: LD_ADDR_EXP 87
99826: PUSH
99827: LD_INT 1
99829: ST_TO_ADDR
// if p3 = 7 then
99830: LD_VAR 0 3
99834: PUSH
99835: LD_INT 7
99837: EQUAL
99838: IFFALSE 99848
// sRadar := true ;
99840: LD_ADDR_EXP 88
99844: PUSH
99845: LD_INT 1
99847: ST_TO_ADDR
// if p3 = 8 then
99848: LD_VAR 0 3
99852: PUSH
99853: LD_INT 8
99855: EQUAL
99856: IFFALSE 99866
// sBunker := true ;
99858: LD_ADDR_EXP 89
99862: PUSH
99863: LD_INT 1
99865: ST_TO_ADDR
// if p3 = 9 then
99866: LD_VAR 0 3
99870: PUSH
99871: LD_INT 9
99873: EQUAL
99874: IFFALSE 99884
// sHack := true ;
99876: LD_ADDR_EXP 90
99880: PUSH
99881: LD_INT 1
99883: ST_TO_ADDR
// if p3 = 10 then
99884: LD_VAR 0 3
99888: PUSH
99889: LD_INT 10
99891: EQUAL
99892: IFFALSE 99902
// sFire := true ;
99894: LD_ADDR_EXP 91
99898: PUSH
99899: LD_INT 1
99901: ST_TO_ADDR
// if p3 = 11 then
99902: LD_VAR 0 3
99906: PUSH
99907: LD_INT 11
99909: EQUAL
99910: IFFALSE 99920
// sRefresh := true ;
99912: LD_ADDR_EXP 92
99916: PUSH
99917: LD_INT 1
99919: ST_TO_ADDR
// if p3 = 12 then
99920: LD_VAR 0 3
99924: PUSH
99925: LD_INT 12
99927: EQUAL
99928: IFFALSE 99938
// sExp := true ;
99930: LD_ADDR_EXP 93
99934: PUSH
99935: LD_INT 1
99937: ST_TO_ADDR
// if p3 = 13 then
99938: LD_VAR 0 3
99942: PUSH
99943: LD_INT 13
99945: EQUAL
99946: IFFALSE 99956
// sDepot := true ;
99948: LD_ADDR_EXP 94
99952: PUSH
99953: LD_INT 1
99955: ST_TO_ADDR
// if p3 = 14 then
99956: LD_VAR 0 3
99960: PUSH
99961: LD_INT 14
99963: EQUAL
99964: IFFALSE 99974
// sFlag := true ;
99966: LD_ADDR_EXP 95
99970: PUSH
99971: LD_INT 1
99973: ST_TO_ADDR
// if p3 = 15 then
99974: LD_VAR 0 3
99978: PUSH
99979: LD_INT 15
99981: EQUAL
99982: IFFALSE 99992
// sKamikadze := true ;
99984: LD_ADDR_EXP 103
99988: PUSH
99989: LD_INT 1
99991: ST_TO_ADDR
// if p3 = 16 then
99992: LD_VAR 0 3
99996: PUSH
99997: LD_INT 16
99999: EQUAL
100000: IFFALSE 100010
// sTroll := true ;
100002: LD_ADDR_EXP 104
100006: PUSH
100007: LD_INT 1
100009: ST_TO_ADDR
// if p3 = 17 then
100010: LD_VAR 0 3
100014: PUSH
100015: LD_INT 17
100017: EQUAL
100018: IFFALSE 100028
// sSlow := true ;
100020: LD_ADDR_EXP 105
100024: PUSH
100025: LD_INT 1
100027: ST_TO_ADDR
// if p3 = 18 then
100028: LD_VAR 0 3
100032: PUSH
100033: LD_INT 18
100035: EQUAL
100036: IFFALSE 100046
// sLack := true ;
100038: LD_ADDR_EXP 106
100042: PUSH
100043: LD_INT 1
100045: ST_TO_ADDR
// if p3 = 19 then
100046: LD_VAR 0 3
100050: PUSH
100051: LD_INT 19
100053: EQUAL
100054: IFFALSE 100064
// sTank := true ;
100056: LD_ADDR_EXP 108
100060: PUSH
100061: LD_INT 1
100063: ST_TO_ADDR
// if p3 = 20 then
100064: LD_VAR 0 3
100068: PUSH
100069: LD_INT 20
100071: EQUAL
100072: IFFALSE 100082
// sRemote := true ;
100074: LD_ADDR_EXP 109
100078: PUSH
100079: LD_INT 1
100081: ST_TO_ADDR
// if p3 = 21 then
100082: LD_VAR 0 3
100086: PUSH
100087: LD_INT 21
100089: EQUAL
100090: IFFALSE 100100
// sPowell := true ;
100092: LD_ADDR_EXP 110
100096: PUSH
100097: LD_INT 1
100099: ST_TO_ADDR
// if p3 = 22 then
100100: LD_VAR 0 3
100104: PUSH
100105: LD_INT 22
100107: EQUAL
100108: IFFALSE 100118
// sTeleport := true ;
100110: LD_ADDR_EXP 113
100114: PUSH
100115: LD_INT 1
100117: ST_TO_ADDR
// if p3 = 23 then
100118: LD_VAR 0 3
100122: PUSH
100123: LD_INT 23
100125: EQUAL
100126: IFFALSE 100136
// sOilTower := true ;
100128: LD_ADDR_EXP 115
100132: PUSH
100133: LD_INT 1
100135: ST_TO_ADDR
// if p3 = 24 then
100136: LD_VAR 0 3
100140: PUSH
100141: LD_INT 24
100143: EQUAL
100144: IFFALSE 100154
// sShovel := true ;
100146: LD_ADDR_EXP 116
100150: PUSH
100151: LD_INT 1
100153: ST_TO_ADDR
// if p3 = 25 then
100154: LD_VAR 0 3
100158: PUSH
100159: LD_INT 25
100161: EQUAL
100162: IFFALSE 100172
// sSheik := true ;
100164: LD_ADDR_EXP 117
100168: PUSH
100169: LD_INT 1
100171: ST_TO_ADDR
// if p3 = 26 then
100172: LD_VAR 0 3
100176: PUSH
100177: LD_INT 26
100179: EQUAL
100180: IFFALSE 100190
// sEarthquake := true ;
100182: LD_ADDR_EXP 119
100186: PUSH
100187: LD_INT 1
100189: ST_TO_ADDR
// if p3 = 27 then
100190: LD_VAR 0 3
100194: PUSH
100195: LD_INT 27
100197: EQUAL
100198: IFFALSE 100208
// sAI := true ;
100200: LD_ADDR_EXP 120
100204: PUSH
100205: LD_INT 1
100207: ST_TO_ADDR
// if p3 = 28 then
100208: LD_VAR 0 3
100212: PUSH
100213: LD_INT 28
100215: EQUAL
100216: IFFALSE 100226
// sCargo := true ;
100218: LD_ADDR_EXP 123
100222: PUSH
100223: LD_INT 1
100225: ST_TO_ADDR
// if p3 = 29 then
100226: LD_VAR 0 3
100230: PUSH
100231: LD_INT 29
100233: EQUAL
100234: IFFALSE 100244
// sDLaser := true ;
100236: LD_ADDR_EXP 124
100240: PUSH
100241: LD_INT 1
100243: ST_TO_ADDR
// if p3 = 30 then
100244: LD_VAR 0 3
100248: PUSH
100249: LD_INT 30
100251: EQUAL
100252: IFFALSE 100262
// sExchange := true ;
100254: LD_ADDR_EXP 125
100258: PUSH
100259: LD_INT 1
100261: ST_TO_ADDR
// if p3 = 31 then
100262: LD_VAR 0 3
100266: PUSH
100267: LD_INT 31
100269: EQUAL
100270: IFFALSE 100280
// sFac := true ;
100272: LD_ADDR_EXP 126
100276: PUSH
100277: LD_INT 1
100279: ST_TO_ADDR
// if p3 = 32 then
100280: LD_VAR 0 3
100284: PUSH
100285: LD_INT 32
100287: EQUAL
100288: IFFALSE 100298
// sPower := true ;
100290: LD_ADDR_EXP 127
100294: PUSH
100295: LD_INT 1
100297: ST_TO_ADDR
// if p3 = 33 then
100298: LD_VAR 0 3
100302: PUSH
100303: LD_INT 33
100305: EQUAL
100306: IFFALSE 100316
// sRandom := true ;
100308: LD_ADDR_EXP 128
100312: PUSH
100313: LD_INT 1
100315: ST_TO_ADDR
// if p3 = 34 then
100316: LD_VAR 0 3
100320: PUSH
100321: LD_INT 34
100323: EQUAL
100324: IFFALSE 100334
// sShield := true ;
100326: LD_ADDR_EXP 129
100330: PUSH
100331: LD_INT 1
100333: ST_TO_ADDR
// if p3 = 35 then
100334: LD_VAR 0 3
100338: PUSH
100339: LD_INT 35
100341: EQUAL
100342: IFFALSE 100352
// sTime := true ;
100344: LD_ADDR_EXP 130
100348: PUSH
100349: LD_INT 1
100351: ST_TO_ADDR
// if p3 = 36 then
100352: LD_VAR 0 3
100356: PUSH
100357: LD_INT 36
100359: EQUAL
100360: IFFALSE 100370
// sTools := true ;
100362: LD_ADDR_EXP 131
100366: PUSH
100367: LD_INT 1
100369: ST_TO_ADDR
// if p3 = 101 then
100370: LD_VAR 0 3
100374: PUSH
100375: LD_INT 101
100377: EQUAL
100378: IFFALSE 100388
// sSold := true ;
100380: LD_ADDR_EXP 96
100384: PUSH
100385: LD_INT 1
100387: ST_TO_ADDR
// if p3 = 102 then
100388: LD_VAR 0 3
100392: PUSH
100393: LD_INT 102
100395: EQUAL
100396: IFFALSE 100406
// sDiff := true ;
100398: LD_ADDR_EXP 97
100402: PUSH
100403: LD_INT 1
100405: ST_TO_ADDR
// if p3 = 103 then
100406: LD_VAR 0 3
100410: PUSH
100411: LD_INT 103
100413: EQUAL
100414: IFFALSE 100424
// sFog := true ;
100416: LD_ADDR_EXP 100
100420: PUSH
100421: LD_INT 1
100423: ST_TO_ADDR
// if p3 = 104 then
100424: LD_VAR 0 3
100428: PUSH
100429: LD_INT 104
100431: EQUAL
100432: IFFALSE 100442
// sReset := true ;
100434: LD_ADDR_EXP 101
100438: PUSH
100439: LD_INT 1
100441: ST_TO_ADDR
// if p3 = 105 then
100442: LD_VAR 0 3
100446: PUSH
100447: LD_INT 105
100449: EQUAL
100450: IFFALSE 100460
// sSun := true ;
100452: LD_ADDR_EXP 102
100456: PUSH
100457: LD_INT 1
100459: ST_TO_ADDR
// if p3 = 106 then
100460: LD_VAR 0 3
100464: PUSH
100465: LD_INT 106
100467: EQUAL
100468: IFFALSE 100478
// sTiger := true ;
100470: LD_ADDR_EXP 98
100474: PUSH
100475: LD_INT 1
100477: ST_TO_ADDR
// if p3 = 107 then
100478: LD_VAR 0 3
100482: PUSH
100483: LD_INT 107
100485: EQUAL
100486: IFFALSE 100496
// sBomb := true ;
100488: LD_ADDR_EXP 99
100492: PUSH
100493: LD_INT 1
100495: ST_TO_ADDR
// if p3 = 108 then
100496: LD_VAR 0 3
100500: PUSH
100501: LD_INT 108
100503: EQUAL
100504: IFFALSE 100514
// sWound := true ;
100506: LD_ADDR_EXP 107
100510: PUSH
100511: LD_INT 1
100513: ST_TO_ADDR
// if p3 = 109 then
100514: LD_VAR 0 3
100518: PUSH
100519: LD_INT 109
100521: EQUAL
100522: IFFALSE 100532
// sBetray := true ;
100524: LD_ADDR_EXP 111
100528: PUSH
100529: LD_INT 1
100531: ST_TO_ADDR
// if p3 = 110 then
100532: LD_VAR 0 3
100536: PUSH
100537: LD_INT 110
100539: EQUAL
100540: IFFALSE 100550
// sContamin := true ;
100542: LD_ADDR_EXP 112
100546: PUSH
100547: LD_INT 1
100549: ST_TO_ADDR
// if p3 = 111 then
100550: LD_VAR 0 3
100554: PUSH
100555: LD_INT 111
100557: EQUAL
100558: IFFALSE 100568
// sOil := true ;
100560: LD_ADDR_EXP 114
100564: PUSH
100565: LD_INT 1
100567: ST_TO_ADDR
// if p3 = 112 then
100568: LD_VAR 0 3
100572: PUSH
100573: LD_INT 112
100575: EQUAL
100576: IFFALSE 100586
// sStu := true ;
100578: LD_ADDR_EXP 118
100582: PUSH
100583: LD_INT 1
100585: ST_TO_ADDR
// if p3 = 113 then
100586: LD_VAR 0 3
100590: PUSH
100591: LD_INT 113
100593: EQUAL
100594: IFFALSE 100604
// sBazooka := true ;
100596: LD_ADDR_EXP 121
100600: PUSH
100601: LD_INT 1
100603: ST_TO_ADDR
// if p3 = 114 then
100604: LD_VAR 0 3
100608: PUSH
100609: LD_INT 114
100611: EQUAL
100612: IFFALSE 100622
// sMortar := true ;
100614: LD_ADDR_EXP 122
100618: PUSH
100619: LD_INT 1
100621: ST_TO_ADDR
// if p3 = 115 then
100622: LD_VAR 0 3
100626: PUSH
100627: LD_INT 115
100629: EQUAL
100630: IFFALSE 100640
// sRanger := true ;
100632: LD_ADDR_EXP 132
100636: PUSH
100637: LD_INT 1
100639: ST_TO_ADDR
// if p3 = 116 then
100640: LD_VAR 0 3
100644: PUSH
100645: LD_INT 116
100647: EQUAL
100648: IFFALSE 100658
// sComputer := true ;
100650: LD_ADDR_EXP 133
100654: PUSH
100655: LD_INT 1
100657: ST_TO_ADDR
// if p3 = 117 then
100658: LD_VAR 0 3
100662: PUSH
100663: LD_INT 117
100665: EQUAL
100666: IFFALSE 100676
// s30 := true ;
100668: LD_ADDR_EXP 134
100672: PUSH
100673: LD_INT 1
100675: ST_TO_ADDR
// if p3 = 118 then
100676: LD_VAR 0 3
100680: PUSH
100681: LD_INT 118
100683: EQUAL
100684: IFFALSE 100694
// s60 := true ;
100686: LD_ADDR_EXP 135
100690: PUSH
100691: LD_INT 1
100693: ST_TO_ADDR
// end ; if p2 = hack_mode then
100694: LD_VAR 0 2
100698: PUSH
100699: LD_INT 101
100701: EQUAL
100702: IFFALSE 100830
// begin case p3 of 1 :
100704: LD_VAR 0 3
100708: PUSH
100709: LD_INT 1
100711: DOUBLE
100712: EQUAL
100713: IFTRUE 100717
100715: GO 100724
100717: POP
// hHackUnlimitedResources ; 2 :
100718: CALL 113093 0 0
100722: GO 100830
100724: LD_INT 2
100726: DOUBLE
100727: EQUAL
100728: IFTRUE 100732
100730: GO 100739
100732: POP
// hHackSetLevel10 ; 3 :
100733: CALL 113226 0 0
100737: GO 100830
100739: LD_INT 3
100741: DOUBLE
100742: EQUAL
100743: IFTRUE 100747
100745: GO 100754
100747: POP
// hHackSetLevel10YourUnits ; 4 :
100748: CALL 113311 0 0
100752: GO 100830
100754: LD_INT 4
100756: DOUBLE
100757: EQUAL
100758: IFTRUE 100762
100760: GO 100769
100762: POP
// hHackInvincible ; 5 :
100763: CALL 113759 0 0
100767: GO 100830
100769: LD_INT 5
100771: DOUBLE
100772: EQUAL
100773: IFTRUE 100777
100775: GO 100784
100777: POP
// hHackInvisible ; 6 :
100778: CALL 113870 0 0
100782: GO 100830
100784: LD_INT 6
100786: DOUBLE
100787: EQUAL
100788: IFTRUE 100792
100790: GO 100799
100792: POP
// hHackChangeYourSide ; 7 :
100793: CALL 113927 0 0
100797: GO 100830
100799: LD_INT 7
100801: DOUBLE
100802: EQUAL
100803: IFTRUE 100807
100805: GO 100814
100807: POP
// hHackChangeUnitSide ; 8 :
100808: CALL 113969 0 0
100812: GO 100830
100814: LD_INT 8
100816: DOUBLE
100817: EQUAL
100818: IFTRUE 100822
100820: GO 100829
100822: POP
// hHackFog ; end ;
100823: CALL 114070 0 0
100827: GO 100830
100829: POP
// end ; if p2 = game_save_mode then
100830: LD_VAR 0 2
100834: PUSH
100835: LD_INT 102
100837: EQUAL
100838: IFFALSE 100895
// begin if p3 = 1 then
100840: LD_VAR 0 3
100844: PUSH
100845: LD_INT 1
100847: EQUAL
100848: IFFALSE 100860
// globalGameSaveCounter := p4 ;
100850: LD_ADDR_EXP 78
100854: PUSH
100855: LD_VAR 0 4
100859: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
100860: LD_VAR 0 3
100864: PUSH
100865: LD_INT 2
100867: EQUAL
100868: IFFALSE 100876
100870: PUSH
100871: LD_EXP 78
100875: AND
100876: IFFALSE 100895
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
100878: LD_STRING setGameSaveCounter(
100880: PUSH
100881: LD_EXP 78
100885: STR
100886: PUSH
100887: LD_STRING )
100889: STR
100890: PPUSH
100891: CALL_OW 559
// end ; end ;
100895: LD_VAR 0 7
100899: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
100900: LD_INT 0
100902: PPUSH
// streamModeActive := false ;
100903: LD_ADDR_EXP 79
100907: PUSH
100908: LD_INT 0
100910: ST_TO_ADDR
// normalCounter := 36 ;
100911: LD_ADDR_EXP 80
100915: PUSH
100916: LD_INT 36
100918: ST_TO_ADDR
// hardcoreCounter := 18 ;
100919: LD_ADDR_EXP 81
100923: PUSH
100924: LD_INT 18
100926: ST_TO_ADDR
// sRocket := false ;
100927: LD_ADDR_EXP 84
100931: PUSH
100932: LD_INT 0
100934: ST_TO_ADDR
// sSpeed := false ;
100935: LD_ADDR_EXP 83
100939: PUSH
100940: LD_INT 0
100942: ST_TO_ADDR
// sEngine := false ;
100943: LD_ADDR_EXP 85
100947: PUSH
100948: LD_INT 0
100950: ST_TO_ADDR
// sSpec := false ;
100951: LD_ADDR_EXP 82
100955: PUSH
100956: LD_INT 0
100958: ST_TO_ADDR
// sLevel := false ;
100959: LD_ADDR_EXP 86
100963: PUSH
100964: LD_INT 0
100966: ST_TO_ADDR
// sArmoury := false ;
100967: LD_ADDR_EXP 87
100971: PUSH
100972: LD_INT 0
100974: ST_TO_ADDR
// sRadar := false ;
100975: LD_ADDR_EXP 88
100979: PUSH
100980: LD_INT 0
100982: ST_TO_ADDR
// sBunker := false ;
100983: LD_ADDR_EXP 89
100987: PUSH
100988: LD_INT 0
100990: ST_TO_ADDR
// sHack := false ;
100991: LD_ADDR_EXP 90
100995: PUSH
100996: LD_INT 0
100998: ST_TO_ADDR
// sFire := false ;
100999: LD_ADDR_EXP 91
101003: PUSH
101004: LD_INT 0
101006: ST_TO_ADDR
// sRefresh := false ;
101007: LD_ADDR_EXP 92
101011: PUSH
101012: LD_INT 0
101014: ST_TO_ADDR
// sExp := false ;
101015: LD_ADDR_EXP 93
101019: PUSH
101020: LD_INT 0
101022: ST_TO_ADDR
// sDepot := false ;
101023: LD_ADDR_EXP 94
101027: PUSH
101028: LD_INT 0
101030: ST_TO_ADDR
// sFlag := false ;
101031: LD_ADDR_EXP 95
101035: PUSH
101036: LD_INT 0
101038: ST_TO_ADDR
// sKamikadze := false ;
101039: LD_ADDR_EXP 103
101043: PUSH
101044: LD_INT 0
101046: ST_TO_ADDR
// sTroll := false ;
101047: LD_ADDR_EXP 104
101051: PUSH
101052: LD_INT 0
101054: ST_TO_ADDR
// sSlow := false ;
101055: LD_ADDR_EXP 105
101059: PUSH
101060: LD_INT 0
101062: ST_TO_ADDR
// sLack := false ;
101063: LD_ADDR_EXP 106
101067: PUSH
101068: LD_INT 0
101070: ST_TO_ADDR
// sTank := false ;
101071: LD_ADDR_EXP 108
101075: PUSH
101076: LD_INT 0
101078: ST_TO_ADDR
// sRemote := false ;
101079: LD_ADDR_EXP 109
101083: PUSH
101084: LD_INT 0
101086: ST_TO_ADDR
// sPowell := false ;
101087: LD_ADDR_EXP 110
101091: PUSH
101092: LD_INT 0
101094: ST_TO_ADDR
// sTeleport := false ;
101095: LD_ADDR_EXP 113
101099: PUSH
101100: LD_INT 0
101102: ST_TO_ADDR
// sOilTower := false ;
101103: LD_ADDR_EXP 115
101107: PUSH
101108: LD_INT 0
101110: ST_TO_ADDR
// sShovel := false ;
101111: LD_ADDR_EXP 116
101115: PUSH
101116: LD_INT 0
101118: ST_TO_ADDR
// sSheik := false ;
101119: LD_ADDR_EXP 117
101123: PUSH
101124: LD_INT 0
101126: ST_TO_ADDR
// sEarthquake := false ;
101127: LD_ADDR_EXP 119
101131: PUSH
101132: LD_INT 0
101134: ST_TO_ADDR
// sAI := false ;
101135: LD_ADDR_EXP 120
101139: PUSH
101140: LD_INT 0
101142: ST_TO_ADDR
// sCargo := false ;
101143: LD_ADDR_EXP 123
101147: PUSH
101148: LD_INT 0
101150: ST_TO_ADDR
// sDLaser := false ;
101151: LD_ADDR_EXP 124
101155: PUSH
101156: LD_INT 0
101158: ST_TO_ADDR
// sExchange := false ;
101159: LD_ADDR_EXP 125
101163: PUSH
101164: LD_INT 0
101166: ST_TO_ADDR
// sFac := false ;
101167: LD_ADDR_EXP 126
101171: PUSH
101172: LD_INT 0
101174: ST_TO_ADDR
// sPower := false ;
101175: LD_ADDR_EXP 127
101179: PUSH
101180: LD_INT 0
101182: ST_TO_ADDR
// sRandom := false ;
101183: LD_ADDR_EXP 128
101187: PUSH
101188: LD_INT 0
101190: ST_TO_ADDR
// sShield := false ;
101191: LD_ADDR_EXP 129
101195: PUSH
101196: LD_INT 0
101198: ST_TO_ADDR
// sTime := false ;
101199: LD_ADDR_EXP 130
101203: PUSH
101204: LD_INT 0
101206: ST_TO_ADDR
// sTools := false ;
101207: LD_ADDR_EXP 131
101211: PUSH
101212: LD_INT 0
101214: ST_TO_ADDR
// sSold := false ;
101215: LD_ADDR_EXP 96
101219: PUSH
101220: LD_INT 0
101222: ST_TO_ADDR
// sDiff := false ;
101223: LD_ADDR_EXP 97
101227: PUSH
101228: LD_INT 0
101230: ST_TO_ADDR
// sFog := false ;
101231: LD_ADDR_EXP 100
101235: PUSH
101236: LD_INT 0
101238: ST_TO_ADDR
// sReset := false ;
101239: LD_ADDR_EXP 101
101243: PUSH
101244: LD_INT 0
101246: ST_TO_ADDR
// sSun := false ;
101247: LD_ADDR_EXP 102
101251: PUSH
101252: LD_INT 0
101254: ST_TO_ADDR
// sTiger := false ;
101255: LD_ADDR_EXP 98
101259: PUSH
101260: LD_INT 0
101262: ST_TO_ADDR
// sBomb := false ;
101263: LD_ADDR_EXP 99
101267: PUSH
101268: LD_INT 0
101270: ST_TO_ADDR
// sWound := false ;
101271: LD_ADDR_EXP 107
101275: PUSH
101276: LD_INT 0
101278: ST_TO_ADDR
// sBetray := false ;
101279: LD_ADDR_EXP 111
101283: PUSH
101284: LD_INT 0
101286: ST_TO_ADDR
// sContamin := false ;
101287: LD_ADDR_EXP 112
101291: PUSH
101292: LD_INT 0
101294: ST_TO_ADDR
// sOil := false ;
101295: LD_ADDR_EXP 114
101299: PUSH
101300: LD_INT 0
101302: ST_TO_ADDR
// sStu := false ;
101303: LD_ADDR_EXP 118
101307: PUSH
101308: LD_INT 0
101310: ST_TO_ADDR
// sBazooka := false ;
101311: LD_ADDR_EXP 121
101315: PUSH
101316: LD_INT 0
101318: ST_TO_ADDR
// sMortar := false ;
101319: LD_ADDR_EXP 122
101323: PUSH
101324: LD_INT 0
101326: ST_TO_ADDR
// sRanger := false ;
101327: LD_ADDR_EXP 132
101331: PUSH
101332: LD_INT 0
101334: ST_TO_ADDR
// sComputer := false ;
101335: LD_ADDR_EXP 133
101339: PUSH
101340: LD_INT 0
101342: ST_TO_ADDR
// s30 := false ;
101343: LD_ADDR_EXP 134
101347: PUSH
101348: LD_INT 0
101350: ST_TO_ADDR
// s60 := false ;
101351: LD_ADDR_EXP 135
101355: PUSH
101356: LD_INT 0
101358: ST_TO_ADDR
// end ;
101359: LD_VAR 0 1
101363: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
101364: LD_INT 0
101366: PPUSH
101367: PPUSH
101368: PPUSH
101369: PPUSH
101370: PPUSH
101371: PPUSH
101372: PPUSH
// result := [ ] ;
101373: LD_ADDR_VAR 0 2
101377: PUSH
101378: EMPTY
101379: ST_TO_ADDR
// if campaign_id = 1 then
101380: LD_OWVAR 69
101384: PUSH
101385: LD_INT 1
101387: EQUAL
101388: IFFALSE 104554
// begin case mission_number of 1 :
101390: LD_OWVAR 70
101394: PUSH
101395: LD_INT 1
101397: DOUBLE
101398: EQUAL
101399: IFTRUE 101403
101401: GO 101479
101403: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
101404: LD_ADDR_VAR 0 2
101408: PUSH
101409: LD_INT 2
101411: PUSH
101412: LD_INT 4
101414: PUSH
101415: LD_INT 11
101417: PUSH
101418: LD_INT 12
101420: PUSH
101421: LD_INT 15
101423: PUSH
101424: LD_INT 16
101426: PUSH
101427: LD_INT 22
101429: PUSH
101430: LD_INT 23
101432: PUSH
101433: LD_INT 26
101435: PUSH
101436: EMPTY
101437: LIST
101438: LIST
101439: LIST
101440: LIST
101441: LIST
101442: LIST
101443: LIST
101444: LIST
101445: LIST
101446: PUSH
101447: LD_INT 101
101449: PUSH
101450: LD_INT 102
101452: PUSH
101453: LD_INT 106
101455: PUSH
101456: LD_INT 116
101458: PUSH
101459: LD_INT 117
101461: PUSH
101462: LD_INT 118
101464: PUSH
101465: EMPTY
101466: LIST
101467: LIST
101468: LIST
101469: LIST
101470: LIST
101471: LIST
101472: PUSH
101473: EMPTY
101474: LIST
101475: LIST
101476: ST_TO_ADDR
101477: GO 104552
101479: LD_INT 2
101481: DOUBLE
101482: EQUAL
101483: IFTRUE 101487
101485: GO 101571
101487: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
101488: LD_ADDR_VAR 0 2
101492: PUSH
101493: LD_INT 2
101495: PUSH
101496: LD_INT 4
101498: PUSH
101499: LD_INT 11
101501: PUSH
101502: LD_INT 12
101504: PUSH
101505: LD_INT 15
101507: PUSH
101508: LD_INT 16
101510: PUSH
101511: LD_INT 22
101513: PUSH
101514: LD_INT 23
101516: PUSH
101517: LD_INT 26
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: LIST
101524: LIST
101525: LIST
101526: LIST
101527: LIST
101528: LIST
101529: LIST
101530: PUSH
101531: LD_INT 101
101533: PUSH
101534: LD_INT 102
101536: PUSH
101537: LD_INT 105
101539: PUSH
101540: LD_INT 106
101542: PUSH
101543: LD_INT 108
101545: PUSH
101546: LD_INT 116
101548: PUSH
101549: LD_INT 117
101551: PUSH
101552: LD_INT 118
101554: PUSH
101555: EMPTY
101556: LIST
101557: LIST
101558: LIST
101559: LIST
101560: LIST
101561: LIST
101562: LIST
101563: LIST
101564: PUSH
101565: EMPTY
101566: LIST
101567: LIST
101568: ST_TO_ADDR
101569: GO 104552
101571: LD_INT 3
101573: DOUBLE
101574: EQUAL
101575: IFTRUE 101579
101577: GO 101667
101579: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
101580: LD_ADDR_VAR 0 2
101584: PUSH
101585: LD_INT 2
101587: PUSH
101588: LD_INT 4
101590: PUSH
101591: LD_INT 5
101593: PUSH
101594: LD_INT 11
101596: PUSH
101597: LD_INT 12
101599: PUSH
101600: LD_INT 15
101602: PUSH
101603: LD_INT 16
101605: PUSH
101606: LD_INT 22
101608: PUSH
101609: LD_INT 26
101611: PUSH
101612: LD_INT 36
101614: PUSH
101615: EMPTY
101616: LIST
101617: LIST
101618: LIST
101619: LIST
101620: LIST
101621: LIST
101622: LIST
101623: LIST
101624: LIST
101625: LIST
101626: PUSH
101627: LD_INT 101
101629: PUSH
101630: LD_INT 102
101632: PUSH
101633: LD_INT 105
101635: PUSH
101636: LD_INT 106
101638: PUSH
101639: LD_INT 108
101641: PUSH
101642: LD_INT 116
101644: PUSH
101645: LD_INT 117
101647: PUSH
101648: LD_INT 118
101650: PUSH
101651: EMPTY
101652: LIST
101653: LIST
101654: LIST
101655: LIST
101656: LIST
101657: LIST
101658: LIST
101659: LIST
101660: PUSH
101661: EMPTY
101662: LIST
101663: LIST
101664: ST_TO_ADDR
101665: GO 104552
101667: LD_INT 4
101669: DOUBLE
101670: EQUAL
101671: IFTRUE 101675
101673: GO 101771
101675: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
101676: LD_ADDR_VAR 0 2
101680: PUSH
101681: LD_INT 2
101683: PUSH
101684: LD_INT 4
101686: PUSH
101687: LD_INT 5
101689: PUSH
101690: LD_INT 8
101692: PUSH
101693: LD_INT 11
101695: PUSH
101696: LD_INT 12
101698: PUSH
101699: LD_INT 15
101701: PUSH
101702: LD_INT 16
101704: PUSH
101705: LD_INT 22
101707: PUSH
101708: LD_INT 23
101710: PUSH
101711: LD_INT 26
101713: PUSH
101714: LD_INT 36
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: LIST
101721: LIST
101722: LIST
101723: LIST
101724: LIST
101725: LIST
101726: LIST
101727: LIST
101728: LIST
101729: LIST
101730: PUSH
101731: LD_INT 101
101733: PUSH
101734: LD_INT 102
101736: PUSH
101737: LD_INT 105
101739: PUSH
101740: LD_INT 106
101742: PUSH
101743: LD_INT 108
101745: PUSH
101746: LD_INT 116
101748: PUSH
101749: LD_INT 117
101751: PUSH
101752: LD_INT 118
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: LIST
101759: LIST
101760: LIST
101761: LIST
101762: LIST
101763: LIST
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: ST_TO_ADDR
101769: GO 104552
101771: LD_INT 5
101773: DOUBLE
101774: EQUAL
101775: IFTRUE 101779
101777: GO 101891
101779: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
101780: LD_ADDR_VAR 0 2
101784: PUSH
101785: LD_INT 2
101787: PUSH
101788: LD_INT 4
101790: PUSH
101791: LD_INT 5
101793: PUSH
101794: LD_INT 6
101796: PUSH
101797: LD_INT 8
101799: PUSH
101800: LD_INT 11
101802: PUSH
101803: LD_INT 12
101805: PUSH
101806: LD_INT 15
101808: PUSH
101809: LD_INT 16
101811: PUSH
101812: LD_INT 22
101814: PUSH
101815: LD_INT 23
101817: PUSH
101818: LD_INT 25
101820: PUSH
101821: LD_INT 26
101823: PUSH
101824: LD_INT 36
101826: PUSH
101827: EMPTY
101828: LIST
101829: LIST
101830: LIST
101831: LIST
101832: LIST
101833: LIST
101834: LIST
101835: LIST
101836: LIST
101837: LIST
101838: LIST
101839: LIST
101840: LIST
101841: LIST
101842: PUSH
101843: LD_INT 101
101845: PUSH
101846: LD_INT 102
101848: PUSH
101849: LD_INT 105
101851: PUSH
101852: LD_INT 106
101854: PUSH
101855: LD_INT 108
101857: PUSH
101858: LD_INT 109
101860: PUSH
101861: LD_INT 112
101863: PUSH
101864: LD_INT 116
101866: PUSH
101867: LD_INT 117
101869: PUSH
101870: LD_INT 118
101872: PUSH
101873: EMPTY
101874: LIST
101875: LIST
101876: LIST
101877: LIST
101878: LIST
101879: LIST
101880: LIST
101881: LIST
101882: LIST
101883: LIST
101884: PUSH
101885: EMPTY
101886: LIST
101887: LIST
101888: ST_TO_ADDR
101889: GO 104552
101891: LD_INT 6
101893: DOUBLE
101894: EQUAL
101895: IFTRUE 101899
101897: GO 102031
101899: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
101900: LD_ADDR_VAR 0 2
101904: PUSH
101905: LD_INT 2
101907: PUSH
101908: LD_INT 4
101910: PUSH
101911: LD_INT 5
101913: PUSH
101914: LD_INT 6
101916: PUSH
101917: LD_INT 8
101919: PUSH
101920: LD_INT 11
101922: PUSH
101923: LD_INT 12
101925: PUSH
101926: LD_INT 15
101928: PUSH
101929: LD_INT 16
101931: PUSH
101932: LD_INT 20
101934: PUSH
101935: LD_INT 21
101937: PUSH
101938: LD_INT 22
101940: PUSH
101941: LD_INT 23
101943: PUSH
101944: LD_INT 25
101946: PUSH
101947: LD_INT 26
101949: PUSH
101950: LD_INT 30
101952: PUSH
101953: LD_INT 31
101955: PUSH
101956: LD_INT 32
101958: PUSH
101959: LD_INT 36
101961: PUSH
101962: EMPTY
101963: LIST
101964: LIST
101965: LIST
101966: LIST
101967: LIST
101968: LIST
101969: LIST
101970: LIST
101971: LIST
101972: LIST
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: LIST
101979: LIST
101980: LIST
101981: LIST
101982: PUSH
101983: LD_INT 101
101985: PUSH
101986: LD_INT 102
101988: PUSH
101989: LD_INT 105
101991: PUSH
101992: LD_INT 106
101994: PUSH
101995: LD_INT 108
101997: PUSH
101998: LD_INT 109
102000: PUSH
102001: LD_INT 112
102003: PUSH
102004: LD_INT 116
102006: PUSH
102007: LD_INT 117
102009: PUSH
102010: LD_INT 118
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: LIST
102017: LIST
102018: LIST
102019: LIST
102020: LIST
102021: LIST
102022: LIST
102023: LIST
102024: PUSH
102025: EMPTY
102026: LIST
102027: LIST
102028: ST_TO_ADDR
102029: GO 104552
102031: LD_INT 7
102033: DOUBLE
102034: EQUAL
102035: IFTRUE 102039
102037: GO 102151
102039: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
102040: LD_ADDR_VAR 0 2
102044: PUSH
102045: LD_INT 2
102047: PUSH
102048: LD_INT 4
102050: PUSH
102051: LD_INT 5
102053: PUSH
102054: LD_INT 7
102056: PUSH
102057: LD_INT 11
102059: PUSH
102060: LD_INT 12
102062: PUSH
102063: LD_INT 15
102065: PUSH
102066: LD_INT 16
102068: PUSH
102069: LD_INT 20
102071: PUSH
102072: LD_INT 21
102074: PUSH
102075: LD_INT 22
102077: PUSH
102078: LD_INT 23
102080: PUSH
102081: LD_INT 25
102083: PUSH
102084: LD_INT 26
102086: PUSH
102087: EMPTY
102088: LIST
102089: LIST
102090: LIST
102091: LIST
102092: LIST
102093: LIST
102094: LIST
102095: LIST
102096: LIST
102097: LIST
102098: LIST
102099: LIST
102100: LIST
102101: LIST
102102: PUSH
102103: LD_INT 101
102105: PUSH
102106: LD_INT 102
102108: PUSH
102109: LD_INT 103
102111: PUSH
102112: LD_INT 105
102114: PUSH
102115: LD_INT 106
102117: PUSH
102118: LD_INT 108
102120: PUSH
102121: LD_INT 112
102123: PUSH
102124: LD_INT 116
102126: PUSH
102127: LD_INT 117
102129: PUSH
102130: LD_INT 118
102132: PUSH
102133: EMPTY
102134: LIST
102135: LIST
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: LIST
102142: LIST
102143: LIST
102144: PUSH
102145: EMPTY
102146: LIST
102147: LIST
102148: ST_TO_ADDR
102149: GO 104552
102151: LD_INT 8
102153: DOUBLE
102154: EQUAL
102155: IFTRUE 102159
102157: GO 102299
102159: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
102160: LD_ADDR_VAR 0 2
102164: PUSH
102165: LD_INT 2
102167: PUSH
102168: LD_INT 4
102170: PUSH
102171: LD_INT 5
102173: PUSH
102174: LD_INT 6
102176: PUSH
102177: LD_INT 7
102179: PUSH
102180: LD_INT 8
102182: PUSH
102183: LD_INT 11
102185: PUSH
102186: LD_INT 12
102188: PUSH
102189: LD_INT 15
102191: PUSH
102192: LD_INT 16
102194: PUSH
102195: LD_INT 20
102197: PUSH
102198: LD_INT 21
102200: PUSH
102201: LD_INT 22
102203: PUSH
102204: LD_INT 23
102206: PUSH
102207: LD_INT 25
102209: PUSH
102210: LD_INT 26
102212: PUSH
102213: LD_INT 30
102215: PUSH
102216: LD_INT 31
102218: PUSH
102219: LD_INT 32
102221: PUSH
102222: LD_INT 36
102224: PUSH
102225: EMPTY
102226: LIST
102227: LIST
102228: LIST
102229: LIST
102230: LIST
102231: LIST
102232: LIST
102233: LIST
102234: LIST
102235: LIST
102236: LIST
102237: LIST
102238: LIST
102239: LIST
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: LIST
102246: PUSH
102247: LD_INT 101
102249: PUSH
102250: LD_INT 102
102252: PUSH
102253: LD_INT 103
102255: PUSH
102256: LD_INT 105
102258: PUSH
102259: LD_INT 106
102261: PUSH
102262: LD_INT 108
102264: PUSH
102265: LD_INT 109
102267: PUSH
102268: LD_INT 112
102270: PUSH
102271: LD_INT 116
102273: PUSH
102274: LD_INT 117
102276: PUSH
102277: LD_INT 118
102279: PUSH
102280: EMPTY
102281: LIST
102282: LIST
102283: LIST
102284: LIST
102285: LIST
102286: LIST
102287: LIST
102288: LIST
102289: LIST
102290: LIST
102291: LIST
102292: PUSH
102293: EMPTY
102294: LIST
102295: LIST
102296: ST_TO_ADDR
102297: GO 104552
102299: LD_INT 9
102301: DOUBLE
102302: EQUAL
102303: IFTRUE 102307
102305: GO 102455
102307: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
102308: LD_ADDR_VAR 0 2
102312: PUSH
102313: LD_INT 2
102315: PUSH
102316: LD_INT 4
102318: PUSH
102319: LD_INT 5
102321: PUSH
102322: LD_INT 6
102324: PUSH
102325: LD_INT 7
102327: PUSH
102328: LD_INT 8
102330: PUSH
102331: LD_INT 11
102333: PUSH
102334: LD_INT 12
102336: PUSH
102337: LD_INT 15
102339: PUSH
102340: LD_INT 16
102342: PUSH
102343: LD_INT 20
102345: PUSH
102346: LD_INT 21
102348: PUSH
102349: LD_INT 22
102351: PUSH
102352: LD_INT 23
102354: PUSH
102355: LD_INT 25
102357: PUSH
102358: LD_INT 26
102360: PUSH
102361: LD_INT 28
102363: PUSH
102364: LD_INT 30
102366: PUSH
102367: LD_INT 31
102369: PUSH
102370: LD_INT 32
102372: PUSH
102373: LD_INT 36
102375: PUSH
102376: EMPTY
102377: LIST
102378: LIST
102379: LIST
102380: LIST
102381: LIST
102382: LIST
102383: LIST
102384: LIST
102385: LIST
102386: LIST
102387: LIST
102388: LIST
102389: LIST
102390: LIST
102391: LIST
102392: LIST
102393: LIST
102394: LIST
102395: LIST
102396: LIST
102397: LIST
102398: PUSH
102399: LD_INT 101
102401: PUSH
102402: LD_INT 102
102404: PUSH
102405: LD_INT 103
102407: PUSH
102408: LD_INT 105
102410: PUSH
102411: LD_INT 106
102413: PUSH
102414: LD_INT 108
102416: PUSH
102417: LD_INT 109
102419: PUSH
102420: LD_INT 112
102422: PUSH
102423: LD_INT 114
102425: PUSH
102426: LD_INT 116
102428: PUSH
102429: LD_INT 117
102431: PUSH
102432: LD_INT 118
102434: PUSH
102435: EMPTY
102436: LIST
102437: LIST
102438: LIST
102439: LIST
102440: LIST
102441: LIST
102442: LIST
102443: LIST
102444: LIST
102445: LIST
102446: LIST
102447: LIST
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: ST_TO_ADDR
102453: GO 104552
102455: LD_INT 10
102457: DOUBLE
102458: EQUAL
102459: IFTRUE 102463
102461: GO 102659
102463: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
102464: LD_ADDR_VAR 0 2
102468: PUSH
102469: LD_INT 2
102471: PUSH
102472: LD_INT 4
102474: PUSH
102475: LD_INT 5
102477: PUSH
102478: LD_INT 6
102480: PUSH
102481: LD_INT 7
102483: PUSH
102484: LD_INT 8
102486: PUSH
102487: LD_INT 9
102489: PUSH
102490: LD_INT 10
102492: PUSH
102493: LD_INT 11
102495: PUSH
102496: LD_INT 12
102498: PUSH
102499: LD_INT 13
102501: PUSH
102502: LD_INT 14
102504: PUSH
102505: LD_INT 15
102507: PUSH
102508: LD_INT 16
102510: PUSH
102511: LD_INT 17
102513: PUSH
102514: LD_INT 18
102516: PUSH
102517: LD_INT 19
102519: PUSH
102520: LD_INT 20
102522: PUSH
102523: LD_INT 21
102525: PUSH
102526: LD_INT 22
102528: PUSH
102529: LD_INT 23
102531: PUSH
102532: LD_INT 24
102534: PUSH
102535: LD_INT 25
102537: PUSH
102538: LD_INT 26
102540: PUSH
102541: LD_INT 28
102543: PUSH
102544: LD_INT 30
102546: PUSH
102547: LD_INT 31
102549: PUSH
102550: LD_INT 32
102552: PUSH
102553: LD_INT 36
102555: PUSH
102556: EMPTY
102557: LIST
102558: LIST
102559: LIST
102560: LIST
102561: LIST
102562: LIST
102563: LIST
102564: LIST
102565: LIST
102566: LIST
102567: LIST
102568: LIST
102569: LIST
102570: LIST
102571: LIST
102572: LIST
102573: LIST
102574: LIST
102575: LIST
102576: LIST
102577: LIST
102578: LIST
102579: LIST
102580: LIST
102581: LIST
102582: LIST
102583: LIST
102584: LIST
102585: LIST
102586: PUSH
102587: LD_INT 101
102589: PUSH
102590: LD_INT 102
102592: PUSH
102593: LD_INT 103
102595: PUSH
102596: LD_INT 104
102598: PUSH
102599: LD_INT 105
102601: PUSH
102602: LD_INT 106
102604: PUSH
102605: LD_INT 107
102607: PUSH
102608: LD_INT 108
102610: PUSH
102611: LD_INT 109
102613: PUSH
102614: LD_INT 110
102616: PUSH
102617: LD_INT 111
102619: PUSH
102620: LD_INT 112
102622: PUSH
102623: LD_INT 114
102625: PUSH
102626: LD_INT 116
102628: PUSH
102629: LD_INT 117
102631: PUSH
102632: LD_INT 118
102634: PUSH
102635: EMPTY
102636: LIST
102637: LIST
102638: LIST
102639: LIST
102640: LIST
102641: LIST
102642: LIST
102643: LIST
102644: LIST
102645: LIST
102646: LIST
102647: LIST
102648: LIST
102649: LIST
102650: LIST
102651: LIST
102652: PUSH
102653: EMPTY
102654: LIST
102655: LIST
102656: ST_TO_ADDR
102657: GO 104552
102659: LD_INT 11
102661: DOUBLE
102662: EQUAL
102663: IFTRUE 102667
102665: GO 102871
102667: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
102668: LD_ADDR_VAR 0 2
102672: PUSH
102673: LD_INT 2
102675: PUSH
102676: LD_INT 3
102678: PUSH
102679: LD_INT 4
102681: PUSH
102682: LD_INT 5
102684: PUSH
102685: LD_INT 6
102687: PUSH
102688: LD_INT 7
102690: PUSH
102691: LD_INT 8
102693: PUSH
102694: LD_INT 9
102696: PUSH
102697: LD_INT 10
102699: PUSH
102700: LD_INT 11
102702: PUSH
102703: LD_INT 12
102705: PUSH
102706: LD_INT 13
102708: PUSH
102709: LD_INT 14
102711: PUSH
102712: LD_INT 15
102714: PUSH
102715: LD_INT 16
102717: PUSH
102718: LD_INT 17
102720: PUSH
102721: LD_INT 18
102723: PUSH
102724: LD_INT 19
102726: PUSH
102727: LD_INT 20
102729: PUSH
102730: LD_INT 21
102732: PUSH
102733: LD_INT 22
102735: PUSH
102736: LD_INT 23
102738: PUSH
102739: LD_INT 24
102741: PUSH
102742: LD_INT 25
102744: PUSH
102745: LD_INT 26
102747: PUSH
102748: LD_INT 28
102750: PUSH
102751: LD_INT 30
102753: PUSH
102754: LD_INT 31
102756: PUSH
102757: LD_INT 32
102759: PUSH
102760: LD_INT 34
102762: PUSH
102763: LD_INT 36
102765: PUSH
102766: EMPTY
102767: LIST
102768: LIST
102769: LIST
102770: LIST
102771: LIST
102772: LIST
102773: LIST
102774: LIST
102775: LIST
102776: LIST
102777: LIST
102778: LIST
102779: LIST
102780: LIST
102781: LIST
102782: LIST
102783: LIST
102784: LIST
102785: LIST
102786: LIST
102787: LIST
102788: LIST
102789: LIST
102790: LIST
102791: LIST
102792: LIST
102793: LIST
102794: LIST
102795: LIST
102796: LIST
102797: LIST
102798: PUSH
102799: LD_INT 101
102801: PUSH
102802: LD_INT 102
102804: PUSH
102805: LD_INT 103
102807: PUSH
102808: LD_INT 104
102810: PUSH
102811: LD_INT 105
102813: PUSH
102814: LD_INT 106
102816: PUSH
102817: LD_INT 107
102819: PUSH
102820: LD_INT 108
102822: PUSH
102823: LD_INT 109
102825: PUSH
102826: LD_INT 110
102828: PUSH
102829: LD_INT 111
102831: PUSH
102832: LD_INT 112
102834: PUSH
102835: LD_INT 114
102837: PUSH
102838: LD_INT 116
102840: PUSH
102841: LD_INT 117
102843: PUSH
102844: LD_INT 118
102846: PUSH
102847: EMPTY
102848: LIST
102849: LIST
102850: LIST
102851: LIST
102852: LIST
102853: LIST
102854: LIST
102855: LIST
102856: LIST
102857: LIST
102858: LIST
102859: LIST
102860: LIST
102861: LIST
102862: LIST
102863: LIST
102864: PUSH
102865: EMPTY
102866: LIST
102867: LIST
102868: ST_TO_ADDR
102869: GO 104552
102871: LD_INT 12
102873: DOUBLE
102874: EQUAL
102875: IFTRUE 102879
102877: GO 103099
102879: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
102880: LD_ADDR_VAR 0 2
102884: PUSH
102885: LD_INT 1
102887: PUSH
102888: LD_INT 2
102890: PUSH
102891: LD_INT 3
102893: PUSH
102894: LD_INT 4
102896: PUSH
102897: LD_INT 5
102899: PUSH
102900: LD_INT 6
102902: PUSH
102903: LD_INT 7
102905: PUSH
102906: LD_INT 8
102908: PUSH
102909: LD_INT 9
102911: PUSH
102912: LD_INT 10
102914: PUSH
102915: LD_INT 11
102917: PUSH
102918: LD_INT 12
102920: PUSH
102921: LD_INT 13
102923: PUSH
102924: LD_INT 14
102926: PUSH
102927: LD_INT 15
102929: PUSH
102930: LD_INT 16
102932: PUSH
102933: LD_INT 17
102935: PUSH
102936: LD_INT 18
102938: PUSH
102939: LD_INT 19
102941: PUSH
102942: LD_INT 20
102944: PUSH
102945: LD_INT 21
102947: PUSH
102948: LD_INT 22
102950: PUSH
102951: LD_INT 23
102953: PUSH
102954: LD_INT 24
102956: PUSH
102957: LD_INT 25
102959: PUSH
102960: LD_INT 26
102962: PUSH
102963: LD_INT 27
102965: PUSH
102966: LD_INT 28
102968: PUSH
102969: LD_INT 30
102971: PUSH
102972: LD_INT 31
102974: PUSH
102975: LD_INT 32
102977: PUSH
102978: LD_INT 33
102980: PUSH
102981: LD_INT 34
102983: PUSH
102984: LD_INT 36
102986: PUSH
102987: EMPTY
102988: LIST
102989: LIST
102990: LIST
102991: LIST
102992: LIST
102993: LIST
102994: LIST
102995: LIST
102996: LIST
102997: LIST
102998: LIST
102999: LIST
103000: LIST
103001: LIST
103002: LIST
103003: LIST
103004: LIST
103005: LIST
103006: LIST
103007: LIST
103008: LIST
103009: LIST
103010: LIST
103011: LIST
103012: LIST
103013: LIST
103014: LIST
103015: LIST
103016: LIST
103017: LIST
103018: LIST
103019: LIST
103020: LIST
103021: LIST
103022: PUSH
103023: LD_INT 101
103025: PUSH
103026: LD_INT 102
103028: PUSH
103029: LD_INT 103
103031: PUSH
103032: LD_INT 104
103034: PUSH
103035: LD_INT 105
103037: PUSH
103038: LD_INT 106
103040: PUSH
103041: LD_INT 107
103043: PUSH
103044: LD_INT 108
103046: PUSH
103047: LD_INT 109
103049: PUSH
103050: LD_INT 110
103052: PUSH
103053: LD_INT 111
103055: PUSH
103056: LD_INT 112
103058: PUSH
103059: LD_INT 113
103061: PUSH
103062: LD_INT 114
103064: PUSH
103065: LD_INT 116
103067: PUSH
103068: LD_INT 117
103070: PUSH
103071: LD_INT 118
103073: PUSH
103074: EMPTY
103075: LIST
103076: LIST
103077: LIST
103078: LIST
103079: LIST
103080: LIST
103081: LIST
103082: LIST
103083: LIST
103084: LIST
103085: LIST
103086: LIST
103087: LIST
103088: LIST
103089: LIST
103090: LIST
103091: LIST
103092: PUSH
103093: EMPTY
103094: LIST
103095: LIST
103096: ST_TO_ADDR
103097: GO 104552
103099: LD_INT 13
103101: DOUBLE
103102: EQUAL
103103: IFTRUE 103107
103105: GO 103315
103107: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
103108: LD_ADDR_VAR 0 2
103112: PUSH
103113: LD_INT 1
103115: PUSH
103116: LD_INT 2
103118: PUSH
103119: LD_INT 3
103121: PUSH
103122: LD_INT 4
103124: PUSH
103125: LD_INT 5
103127: PUSH
103128: LD_INT 8
103130: PUSH
103131: LD_INT 9
103133: PUSH
103134: LD_INT 10
103136: PUSH
103137: LD_INT 11
103139: PUSH
103140: LD_INT 12
103142: PUSH
103143: LD_INT 14
103145: PUSH
103146: LD_INT 15
103148: PUSH
103149: LD_INT 16
103151: PUSH
103152: LD_INT 17
103154: PUSH
103155: LD_INT 18
103157: PUSH
103158: LD_INT 19
103160: PUSH
103161: LD_INT 20
103163: PUSH
103164: LD_INT 21
103166: PUSH
103167: LD_INT 22
103169: PUSH
103170: LD_INT 23
103172: PUSH
103173: LD_INT 24
103175: PUSH
103176: LD_INT 25
103178: PUSH
103179: LD_INT 26
103181: PUSH
103182: LD_INT 27
103184: PUSH
103185: LD_INT 28
103187: PUSH
103188: LD_INT 30
103190: PUSH
103191: LD_INT 31
103193: PUSH
103194: LD_INT 32
103196: PUSH
103197: LD_INT 33
103199: PUSH
103200: LD_INT 34
103202: PUSH
103203: LD_INT 36
103205: PUSH
103206: EMPTY
103207: LIST
103208: LIST
103209: LIST
103210: LIST
103211: LIST
103212: LIST
103213: LIST
103214: LIST
103215: LIST
103216: LIST
103217: LIST
103218: LIST
103219: LIST
103220: LIST
103221: LIST
103222: LIST
103223: LIST
103224: LIST
103225: LIST
103226: LIST
103227: LIST
103228: LIST
103229: LIST
103230: LIST
103231: LIST
103232: LIST
103233: LIST
103234: LIST
103235: LIST
103236: LIST
103237: LIST
103238: PUSH
103239: LD_INT 101
103241: PUSH
103242: LD_INT 102
103244: PUSH
103245: LD_INT 103
103247: PUSH
103248: LD_INT 104
103250: PUSH
103251: LD_INT 105
103253: PUSH
103254: LD_INT 106
103256: PUSH
103257: LD_INT 107
103259: PUSH
103260: LD_INT 108
103262: PUSH
103263: LD_INT 109
103265: PUSH
103266: LD_INT 110
103268: PUSH
103269: LD_INT 111
103271: PUSH
103272: LD_INT 112
103274: PUSH
103275: LD_INT 113
103277: PUSH
103278: LD_INT 114
103280: PUSH
103281: LD_INT 116
103283: PUSH
103284: LD_INT 117
103286: PUSH
103287: LD_INT 118
103289: PUSH
103290: EMPTY
103291: LIST
103292: LIST
103293: LIST
103294: LIST
103295: LIST
103296: LIST
103297: LIST
103298: LIST
103299: LIST
103300: LIST
103301: LIST
103302: LIST
103303: LIST
103304: LIST
103305: LIST
103306: LIST
103307: LIST
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: ST_TO_ADDR
103313: GO 104552
103315: LD_INT 14
103317: DOUBLE
103318: EQUAL
103319: IFTRUE 103323
103321: GO 103547
103323: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
103324: LD_ADDR_VAR 0 2
103328: PUSH
103329: LD_INT 1
103331: PUSH
103332: LD_INT 2
103334: PUSH
103335: LD_INT 3
103337: PUSH
103338: LD_INT 4
103340: PUSH
103341: LD_INT 5
103343: PUSH
103344: LD_INT 6
103346: PUSH
103347: LD_INT 7
103349: PUSH
103350: LD_INT 8
103352: PUSH
103353: LD_INT 9
103355: PUSH
103356: LD_INT 10
103358: PUSH
103359: LD_INT 11
103361: PUSH
103362: LD_INT 12
103364: PUSH
103365: LD_INT 13
103367: PUSH
103368: LD_INT 14
103370: PUSH
103371: LD_INT 15
103373: PUSH
103374: LD_INT 16
103376: PUSH
103377: LD_INT 17
103379: PUSH
103380: LD_INT 18
103382: PUSH
103383: LD_INT 19
103385: PUSH
103386: LD_INT 20
103388: PUSH
103389: LD_INT 21
103391: PUSH
103392: LD_INT 22
103394: PUSH
103395: LD_INT 23
103397: PUSH
103398: LD_INT 24
103400: PUSH
103401: LD_INT 25
103403: PUSH
103404: LD_INT 26
103406: PUSH
103407: LD_INT 27
103409: PUSH
103410: LD_INT 28
103412: PUSH
103413: LD_INT 29
103415: PUSH
103416: LD_INT 30
103418: PUSH
103419: LD_INT 31
103421: PUSH
103422: LD_INT 32
103424: PUSH
103425: LD_INT 33
103427: PUSH
103428: LD_INT 34
103430: PUSH
103431: LD_INT 36
103433: PUSH
103434: EMPTY
103435: LIST
103436: LIST
103437: LIST
103438: LIST
103439: LIST
103440: LIST
103441: LIST
103442: LIST
103443: LIST
103444: LIST
103445: LIST
103446: LIST
103447: LIST
103448: LIST
103449: LIST
103450: LIST
103451: LIST
103452: LIST
103453: LIST
103454: LIST
103455: LIST
103456: LIST
103457: LIST
103458: LIST
103459: LIST
103460: LIST
103461: LIST
103462: LIST
103463: LIST
103464: LIST
103465: LIST
103466: LIST
103467: LIST
103468: LIST
103469: LIST
103470: PUSH
103471: LD_INT 101
103473: PUSH
103474: LD_INT 102
103476: PUSH
103477: LD_INT 103
103479: PUSH
103480: LD_INT 104
103482: PUSH
103483: LD_INT 105
103485: PUSH
103486: LD_INT 106
103488: PUSH
103489: LD_INT 107
103491: PUSH
103492: LD_INT 108
103494: PUSH
103495: LD_INT 109
103497: PUSH
103498: LD_INT 110
103500: PUSH
103501: LD_INT 111
103503: PUSH
103504: LD_INT 112
103506: PUSH
103507: LD_INT 113
103509: PUSH
103510: LD_INT 114
103512: PUSH
103513: LD_INT 116
103515: PUSH
103516: LD_INT 117
103518: PUSH
103519: LD_INT 118
103521: PUSH
103522: EMPTY
103523: LIST
103524: LIST
103525: LIST
103526: LIST
103527: LIST
103528: LIST
103529: LIST
103530: LIST
103531: LIST
103532: LIST
103533: LIST
103534: LIST
103535: LIST
103536: LIST
103537: LIST
103538: LIST
103539: LIST
103540: PUSH
103541: EMPTY
103542: LIST
103543: LIST
103544: ST_TO_ADDR
103545: GO 104552
103547: LD_INT 15
103549: DOUBLE
103550: EQUAL
103551: IFTRUE 103555
103553: GO 103779
103555: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
103556: LD_ADDR_VAR 0 2
103560: PUSH
103561: LD_INT 1
103563: PUSH
103564: LD_INT 2
103566: PUSH
103567: LD_INT 3
103569: PUSH
103570: LD_INT 4
103572: PUSH
103573: LD_INT 5
103575: PUSH
103576: LD_INT 6
103578: PUSH
103579: LD_INT 7
103581: PUSH
103582: LD_INT 8
103584: PUSH
103585: LD_INT 9
103587: PUSH
103588: LD_INT 10
103590: PUSH
103591: LD_INT 11
103593: PUSH
103594: LD_INT 12
103596: PUSH
103597: LD_INT 13
103599: PUSH
103600: LD_INT 14
103602: PUSH
103603: LD_INT 15
103605: PUSH
103606: LD_INT 16
103608: PUSH
103609: LD_INT 17
103611: PUSH
103612: LD_INT 18
103614: PUSH
103615: LD_INT 19
103617: PUSH
103618: LD_INT 20
103620: PUSH
103621: LD_INT 21
103623: PUSH
103624: LD_INT 22
103626: PUSH
103627: LD_INT 23
103629: PUSH
103630: LD_INT 24
103632: PUSH
103633: LD_INT 25
103635: PUSH
103636: LD_INT 26
103638: PUSH
103639: LD_INT 27
103641: PUSH
103642: LD_INT 28
103644: PUSH
103645: LD_INT 29
103647: PUSH
103648: LD_INT 30
103650: PUSH
103651: LD_INT 31
103653: PUSH
103654: LD_INT 32
103656: PUSH
103657: LD_INT 33
103659: PUSH
103660: LD_INT 34
103662: PUSH
103663: LD_INT 36
103665: PUSH
103666: EMPTY
103667: LIST
103668: LIST
103669: LIST
103670: LIST
103671: LIST
103672: LIST
103673: LIST
103674: LIST
103675: LIST
103676: LIST
103677: LIST
103678: LIST
103679: LIST
103680: LIST
103681: LIST
103682: LIST
103683: LIST
103684: LIST
103685: LIST
103686: LIST
103687: LIST
103688: LIST
103689: LIST
103690: LIST
103691: LIST
103692: LIST
103693: LIST
103694: LIST
103695: LIST
103696: LIST
103697: LIST
103698: LIST
103699: LIST
103700: LIST
103701: LIST
103702: PUSH
103703: LD_INT 101
103705: PUSH
103706: LD_INT 102
103708: PUSH
103709: LD_INT 103
103711: PUSH
103712: LD_INT 104
103714: PUSH
103715: LD_INT 105
103717: PUSH
103718: LD_INT 106
103720: PUSH
103721: LD_INT 107
103723: PUSH
103724: LD_INT 108
103726: PUSH
103727: LD_INT 109
103729: PUSH
103730: LD_INT 110
103732: PUSH
103733: LD_INT 111
103735: PUSH
103736: LD_INT 112
103738: PUSH
103739: LD_INT 113
103741: PUSH
103742: LD_INT 114
103744: PUSH
103745: LD_INT 116
103747: PUSH
103748: LD_INT 117
103750: PUSH
103751: LD_INT 118
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: LIST
103758: LIST
103759: LIST
103760: LIST
103761: LIST
103762: LIST
103763: LIST
103764: LIST
103765: LIST
103766: LIST
103767: LIST
103768: LIST
103769: LIST
103770: LIST
103771: LIST
103772: PUSH
103773: EMPTY
103774: LIST
103775: LIST
103776: ST_TO_ADDR
103777: GO 104552
103779: LD_INT 16
103781: DOUBLE
103782: EQUAL
103783: IFTRUE 103787
103785: GO 103923
103787: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
103788: LD_ADDR_VAR 0 2
103792: PUSH
103793: LD_INT 2
103795: PUSH
103796: LD_INT 4
103798: PUSH
103799: LD_INT 5
103801: PUSH
103802: LD_INT 7
103804: PUSH
103805: LD_INT 11
103807: PUSH
103808: LD_INT 12
103810: PUSH
103811: LD_INT 15
103813: PUSH
103814: LD_INT 16
103816: PUSH
103817: LD_INT 20
103819: PUSH
103820: LD_INT 21
103822: PUSH
103823: LD_INT 22
103825: PUSH
103826: LD_INT 23
103828: PUSH
103829: LD_INT 25
103831: PUSH
103832: LD_INT 26
103834: PUSH
103835: LD_INT 30
103837: PUSH
103838: LD_INT 31
103840: PUSH
103841: LD_INT 32
103843: PUSH
103844: LD_INT 33
103846: PUSH
103847: LD_INT 34
103849: PUSH
103850: EMPTY
103851: LIST
103852: LIST
103853: LIST
103854: LIST
103855: LIST
103856: LIST
103857: LIST
103858: LIST
103859: LIST
103860: LIST
103861: LIST
103862: LIST
103863: LIST
103864: LIST
103865: LIST
103866: LIST
103867: LIST
103868: LIST
103869: LIST
103870: PUSH
103871: LD_INT 101
103873: PUSH
103874: LD_INT 102
103876: PUSH
103877: LD_INT 103
103879: PUSH
103880: LD_INT 106
103882: PUSH
103883: LD_INT 108
103885: PUSH
103886: LD_INT 112
103888: PUSH
103889: LD_INT 113
103891: PUSH
103892: LD_INT 114
103894: PUSH
103895: LD_INT 116
103897: PUSH
103898: LD_INT 117
103900: PUSH
103901: LD_INT 118
103903: PUSH
103904: EMPTY
103905: LIST
103906: LIST
103907: LIST
103908: LIST
103909: LIST
103910: LIST
103911: LIST
103912: LIST
103913: LIST
103914: LIST
103915: LIST
103916: PUSH
103917: EMPTY
103918: LIST
103919: LIST
103920: ST_TO_ADDR
103921: GO 104552
103923: LD_INT 17
103925: DOUBLE
103926: EQUAL
103927: IFTRUE 103931
103929: GO 104155
103931: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
103932: LD_ADDR_VAR 0 2
103936: PUSH
103937: LD_INT 1
103939: PUSH
103940: LD_INT 2
103942: PUSH
103943: LD_INT 3
103945: PUSH
103946: LD_INT 4
103948: PUSH
103949: LD_INT 5
103951: PUSH
103952: LD_INT 6
103954: PUSH
103955: LD_INT 7
103957: PUSH
103958: LD_INT 8
103960: PUSH
103961: LD_INT 9
103963: PUSH
103964: LD_INT 10
103966: PUSH
103967: LD_INT 11
103969: PUSH
103970: LD_INT 12
103972: PUSH
103973: LD_INT 13
103975: PUSH
103976: LD_INT 14
103978: PUSH
103979: LD_INT 15
103981: PUSH
103982: LD_INT 16
103984: PUSH
103985: LD_INT 17
103987: PUSH
103988: LD_INT 18
103990: PUSH
103991: LD_INT 19
103993: PUSH
103994: LD_INT 20
103996: PUSH
103997: LD_INT 21
103999: PUSH
104000: LD_INT 22
104002: PUSH
104003: LD_INT 23
104005: PUSH
104006: LD_INT 24
104008: PUSH
104009: LD_INT 25
104011: PUSH
104012: LD_INT 26
104014: PUSH
104015: LD_INT 27
104017: PUSH
104018: LD_INT 28
104020: PUSH
104021: LD_INT 29
104023: PUSH
104024: LD_INT 30
104026: PUSH
104027: LD_INT 31
104029: PUSH
104030: LD_INT 32
104032: PUSH
104033: LD_INT 33
104035: PUSH
104036: LD_INT 34
104038: PUSH
104039: LD_INT 36
104041: PUSH
104042: EMPTY
104043: LIST
104044: LIST
104045: LIST
104046: LIST
104047: LIST
104048: LIST
104049: LIST
104050: LIST
104051: LIST
104052: LIST
104053: LIST
104054: LIST
104055: LIST
104056: LIST
104057: LIST
104058: LIST
104059: LIST
104060: LIST
104061: LIST
104062: LIST
104063: LIST
104064: LIST
104065: LIST
104066: LIST
104067: LIST
104068: LIST
104069: LIST
104070: LIST
104071: LIST
104072: LIST
104073: LIST
104074: LIST
104075: LIST
104076: LIST
104077: LIST
104078: PUSH
104079: LD_INT 101
104081: PUSH
104082: LD_INT 102
104084: PUSH
104085: LD_INT 103
104087: PUSH
104088: LD_INT 104
104090: PUSH
104091: LD_INT 105
104093: PUSH
104094: LD_INT 106
104096: PUSH
104097: LD_INT 107
104099: PUSH
104100: LD_INT 108
104102: PUSH
104103: LD_INT 109
104105: PUSH
104106: LD_INT 110
104108: PUSH
104109: LD_INT 111
104111: PUSH
104112: LD_INT 112
104114: PUSH
104115: LD_INT 113
104117: PUSH
104118: LD_INT 114
104120: PUSH
104121: LD_INT 116
104123: PUSH
104124: LD_INT 117
104126: PUSH
104127: LD_INT 118
104129: PUSH
104130: EMPTY
104131: LIST
104132: LIST
104133: LIST
104134: LIST
104135: LIST
104136: LIST
104137: LIST
104138: LIST
104139: LIST
104140: LIST
104141: LIST
104142: LIST
104143: LIST
104144: LIST
104145: LIST
104146: LIST
104147: LIST
104148: PUSH
104149: EMPTY
104150: LIST
104151: LIST
104152: ST_TO_ADDR
104153: GO 104552
104155: LD_INT 18
104157: DOUBLE
104158: EQUAL
104159: IFTRUE 104163
104161: GO 104311
104163: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
104164: LD_ADDR_VAR 0 2
104168: PUSH
104169: LD_INT 2
104171: PUSH
104172: LD_INT 4
104174: PUSH
104175: LD_INT 5
104177: PUSH
104178: LD_INT 7
104180: PUSH
104181: LD_INT 11
104183: PUSH
104184: LD_INT 12
104186: PUSH
104187: LD_INT 15
104189: PUSH
104190: LD_INT 16
104192: PUSH
104193: LD_INT 20
104195: PUSH
104196: LD_INT 21
104198: PUSH
104199: LD_INT 22
104201: PUSH
104202: LD_INT 23
104204: PUSH
104205: LD_INT 25
104207: PUSH
104208: LD_INT 26
104210: PUSH
104211: LD_INT 30
104213: PUSH
104214: LD_INT 31
104216: PUSH
104217: LD_INT 32
104219: PUSH
104220: LD_INT 33
104222: PUSH
104223: LD_INT 34
104225: PUSH
104226: LD_INT 35
104228: PUSH
104229: LD_INT 36
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: LIST
104236: LIST
104237: LIST
104238: LIST
104239: LIST
104240: LIST
104241: LIST
104242: LIST
104243: LIST
104244: LIST
104245: LIST
104246: LIST
104247: LIST
104248: LIST
104249: LIST
104250: LIST
104251: LIST
104252: LIST
104253: LIST
104254: PUSH
104255: LD_INT 101
104257: PUSH
104258: LD_INT 102
104260: PUSH
104261: LD_INT 103
104263: PUSH
104264: LD_INT 106
104266: PUSH
104267: LD_INT 108
104269: PUSH
104270: LD_INT 112
104272: PUSH
104273: LD_INT 113
104275: PUSH
104276: LD_INT 114
104278: PUSH
104279: LD_INT 115
104281: PUSH
104282: LD_INT 116
104284: PUSH
104285: LD_INT 117
104287: PUSH
104288: LD_INT 118
104290: PUSH
104291: EMPTY
104292: LIST
104293: LIST
104294: LIST
104295: LIST
104296: LIST
104297: LIST
104298: LIST
104299: LIST
104300: LIST
104301: LIST
104302: LIST
104303: LIST
104304: PUSH
104305: EMPTY
104306: LIST
104307: LIST
104308: ST_TO_ADDR
104309: GO 104552
104311: LD_INT 19
104313: DOUBLE
104314: EQUAL
104315: IFTRUE 104319
104317: GO 104551
104319: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
104320: LD_ADDR_VAR 0 2
104324: PUSH
104325: LD_INT 1
104327: PUSH
104328: LD_INT 2
104330: PUSH
104331: LD_INT 3
104333: PUSH
104334: LD_INT 4
104336: PUSH
104337: LD_INT 5
104339: PUSH
104340: LD_INT 6
104342: PUSH
104343: LD_INT 7
104345: PUSH
104346: LD_INT 8
104348: PUSH
104349: LD_INT 9
104351: PUSH
104352: LD_INT 10
104354: PUSH
104355: LD_INT 11
104357: PUSH
104358: LD_INT 12
104360: PUSH
104361: LD_INT 13
104363: PUSH
104364: LD_INT 14
104366: PUSH
104367: LD_INT 15
104369: PUSH
104370: LD_INT 16
104372: PUSH
104373: LD_INT 17
104375: PUSH
104376: LD_INT 18
104378: PUSH
104379: LD_INT 19
104381: PUSH
104382: LD_INT 20
104384: PUSH
104385: LD_INT 21
104387: PUSH
104388: LD_INT 22
104390: PUSH
104391: LD_INT 23
104393: PUSH
104394: LD_INT 24
104396: PUSH
104397: LD_INT 25
104399: PUSH
104400: LD_INT 26
104402: PUSH
104403: LD_INT 27
104405: PUSH
104406: LD_INT 28
104408: PUSH
104409: LD_INT 29
104411: PUSH
104412: LD_INT 30
104414: PUSH
104415: LD_INT 31
104417: PUSH
104418: LD_INT 32
104420: PUSH
104421: LD_INT 33
104423: PUSH
104424: LD_INT 34
104426: PUSH
104427: LD_INT 35
104429: PUSH
104430: LD_INT 36
104432: PUSH
104433: EMPTY
104434: LIST
104435: LIST
104436: LIST
104437: LIST
104438: LIST
104439: LIST
104440: LIST
104441: LIST
104442: LIST
104443: LIST
104444: LIST
104445: LIST
104446: LIST
104447: LIST
104448: LIST
104449: LIST
104450: LIST
104451: LIST
104452: LIST
104453: LIST
104454: LIST
104455: LIST
104456: LIST
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: LIST
104462: LIST
104463: LIST
104464: LIST
104465: LIST
104466: LIST
104467: LIST
104468: LIST
104469: LIST
104470: PUSH
104471: LD_INT 101
104473: PUSH
104474: LD_INT 102
104476: PUSH
104477: LD_INT 103
104479: PUSH
104480: LD_INT 104
104482: PUSH
104483: LD_INT 105
104485: PUSH
104486: LD_INT 106
104488: PUSH
104489: LD_INT 107
104491: PUSH
104492: LD_INT 108
104494: PUSH
104495: LD_INT 109
104497: PUSH
104498: LD_INT 110
104500: PUSH
104501: LD_INT 111
104503: PUSH
104504: LD_INT 112
104506: PUSH
104507: LD_INT 113
104509: PUSH
104510: LD_INT 114
104512: PUSH
104513: LD_INT 115
104515: PUSH
104516: LD_INT 116
104518: PUSH
104519: LD_INT 117
104521: PUSH
104522: LD_INT 118
104524: PUSH
104525: EMPTY
104526: LIST
104527: LIST
104528: LIST
104529: LIST
104530: LIST
104531: LIST
104532: LIST
104533: LIST
104534: LIST
104535: LIST
104536: LIST
104537: LIST
104538: LIST
104539: LIST
104540: LIST
104541: LIST
104542: LIST
104543: LIST
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: ST_TO_ADDR
104549: GO 104552
104551: POP
// end else
104552: GO 104783
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
104554: LD_ADDR_VAR 0 2
104558: PUSH
104559: LD_INT 1
104561: PUSH
104562: LD_INT 2
104564: PUSH
104565: LD_INT 3
104567: PUSH
104568: LD_INT 4
104570: PUSH
104571: LD_INT 5
104573: PUSH
104574: LD_INT 6
104576: PUSH
104577: LD_INT 7
104579: PUSH
104580: LD_INT 8
104582: PUSH
104583: LD_INT 9
104585: PUSH
104586: LD_INT 10
104588: PUSH
104589: LD_INT 11
104591: PUSH
104592: LD_INT 12
104594: PUSH
104595: LD_INT 13
104597: PUSH
104598: LD_INT 14
104600: PUSH
104601: LD_INT 15
104603: PUSH
104604: LD_INT 16
104606: PUSH
104607: LD_INT 17
104609: PUSH
104610: LD_INT 18
104612: PUSH
104613: LD_INT 19
104615: PUSH
104616: LD_INT 20
104618: PUSH
104619: LD_INT 21
104621: PUSH
104622: LD_INT 22
104624: PUSH
104625: LD_INT 23
104627: PUSH
104628: LD_INT 24
104630: PUSH
104631: LD_INT 25
104633: PUSH
104634: LD_INT 26
104636: PUSH
104637: LD_INT 27
104639: PUSH
104640: LD_INT 28
104642: PUSH
104643: LD_INT 29
104645: PUSH
104646: LD_INT 30
104648: PUSH
104649: LD_INT 31
104651: PUSH
104652: LD_INT 32
104654: PUSH
104655: LD_INT 33
104657: PUSH
104658: LD_INT 34
104660: PUSH
104661: LD_INT 35
104663: PUSH
104664: LD_INT 36
104666: PUSH
104667: EMPTY
104668: LIST
104669: LIST
104670: LIST
104671: LIST
104672: LIST
104673: LIST
104674: LIST
104675: LIST
104676: LIST
104677: LIST
104678: LIST
104679: LIST
104680: LIST
104681: LIST
104682: LIST
104683: LIST
104684: LIST
104685: LIST
104686: LIST
104687: LIST
104688: LIST
104689: LIST
104690: LIST
104691: LIST
104692: LIST
104693: LIST
104694: LIST
104695: LIST
104696: LIST
104697: LIST
104698: LIST
104699: LIST
104700: LIST
104701: LIST
104702: LIST
104703: LIST
104704: PUSH
104705: LD_INT 101
104707: PUSH
104708: LD_INT 102
104710: PUSH
104711: LD_INT 103
104713: PUSH
104714: LD_INT 104
104716: PUSH
104717: LD_INT 105
104719: PUSH
104720: LD_INT 106
104722: PUSH
104723: LD_INT 107
104725: PUSH
104726: LD_INT 108
104728: PUSH
104729: LD_INT 109
104731: PUSH
104732: LD_INT 110
104734: PUSH
104735: LD_INT 111
104737: PUSH
104738: LD_INT 112
104740: PUSH
104741: LD_INT 113
104743: PUSH
104744: LD_INT 114
104746: PUSH
104747: LD_INT 115
104749: PUSH
104750: LD_INT 116
104752: PUSH
104753: LD_INT 117
104755: PUSH
104756: LD_INT 118
104758: PUSH
104759: EMPTY
104760: LIST
104761: LIST
104762: LIST
104763: LIST
104764: LIST
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: LIST
104770: LIST
104771: LIST
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: LIST
104778: PUSH
104779: EMPTY
104780: LIST
104781: LIST
104782: ST_TO_ADDR
// if result then
104783: LD_VAR 0 2
104787: IFFALSE 105573
// begin normal :=  ;
104789: LD_ADDR_VAR 0 5
104793: PUSH
104794: LD_STRING 
104796: ST_TO_ADDR
// hardcore :=  ;
104797: LD_ADDR_VAR 0 6
104801: PUSH
104802: LD_STRING 
104804: ST_TO_ADDR
// active :=  ;
104805: LD_ADDR_VAR 0 7
104809: PUSH
104810: LD_STRING 
104812: ST_TO_ADDR
// for i = 1 to normalCounter do
104813: LD_ADDR_VAR 0 8
104817: PUSH
104818: DOUBLE
104819: LD_INT 1
104821: DEC
104822: ST_TO_ADDR
104823: LD_EXP 80
104827: PUSH
104828: FOR_TO
104829: IFFALSE 104930
// begin tmp := 0 ;
104831: LD_ADDR_VAR 0 3
104835: PUSH
104836: LD_STRING 0
104838: ST_TO_ADDR
// if result [ 1 ] then
104839: LD_VAR 0 2
104843: PUSH
104844: LD_INT 1
104846: ARRAY
104847: IFFALSE 104912
// if result [ 1 ] [ 1 ] = i then
104849: LD_VAR 0 2
104853: PUSH
104854: LD_INT 1
104856: ARRAY
104857: PUSH
104858: LD_INT 1
104860: ARRAY
104861: PUSH
104862: LD_VAR 0 8
104866: EQUAL
104867: IFFALSE 104912
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
104869: LD_ADDR_VAR 0 2
104873: PUSH
104874: LD_VAR 0 2
104878: PPUSH
104879: LD_INT 1
104881: PPUSH
104882: LD_VAR 0 2
104886: PUSH
104887: LD_INT 1
104889: ARRAY
104890: PPUSH
104891: LD_INT 1
104893: PPUSH
104894: CALL_OW 3
104898: PPUSH
104899: CALL_OW 1
104903: ST_TO_ADDR
// tmp := 1 ;
104904: LD_ADDR_VAR 0 3
104908: PUSH
104909: LD_STRING 1
104911: ST_TO_ADDR
// end ; normal := normal & tmp ;
104912: LD_ADDR_VAR 0 5
104916: PUSH
104917: LD_VAR 0 5
104921: PUSH
104922: LD_VAR 0 3
104926: STR
104927: ST_TO_ADDR
// end ;
104928: GO 104828
104930: POP
104931: POP
// for i = 1 to hardcoreCounter do
104932: LD_ADDR_VAR 0 8
104936: PUSH
104937: DOUBLE
104938: LD_INT 1
104940: DEC
104941: ST_TO_ADDR
104942: LD_EXP 81
104946: PUSH
104947: FOR_TO
104948: IFFALSE 105053
// begin tmp := 0 ;
104950: LD_ADDR_VAR 0 3
104954: PUSH
104955: LD_STRING 0
104957: ST_TO_ADDR
// if result [ 2 ] then
104958: LD_VAR 0 2
104962: PUSH
104963: LD_INT 2
104965: ARRAY
104966: IFFALSE 105035
// if result [ 2 ] [ 1 ] = 100 + i then
104968: LD_VAR 0 2
104972: PUSH
104973: LD_INT 2
104975: ARRAY
104976: PUSH
104977: LD_INT 1
104979: ARRAY
104980: PUSH
104981: LD_INT 100
104983: PUSH
104984: LD_VAR 0 8
104988: PLUS
104989: EQUAL
104990: IFFALSE 105035
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
104992: LD_ADDR_VAR 0 2
104996: PUSH
104997: LD_VAR 0 2
105001: PPUSH
105002: LD_INT 2
105004: PPUSH
105005: LD_VAR 0 2
105009: PUSH
105010: LD_INT 2
105012: ARRAY
105013: PPUSH
105014: LD_INT 1
105016: PPUSH
105017: CALL_OW 3
105021: PPUSH
105022: CALL_OW 1
105026: ST_TO_ADDR
// tmp := 1 ;
105027: LD_ADDR_VAR 0 3
105031: PUSH
105032: LD_STRING 1
105034: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
105035: LD_ADDR_VAR 0 6
105039: PUSH
105040: LD_VAR 0 6
105044: PUSH
105045: LD_VAR 0 3
105049: STR
105050: ST_TO_ADDR
// end ;
105051: GO 104947
105053: POP
105054: POP
// if isGameLoad then
105055: LD_VAR 0 1
105059: IFFALSE 105534
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
105061: LD_ADDR_VAR 0 4
105065: PUSH
105066: LD_EXP 84
105070: PUSH
105071: LD_EXP 83
105075: PUSH
105076: LD_EXP 85
105080: PUSH
105081: LD_EXP 82
105085: PUSH
105086: LD_EXP 86
105090: PUSH
105091: LD_EXP 87
105095: PUSH
105096: LD_EXP 88
105100: PUSH
105101: LD_EXP 89
105105: PUSH
105106: LD_EXP 90
105110: PUSH
105111: LD_EXP 91
105115: PUSH
105116: LD_EXP 92
105120: PUSH
105121: LD_EXP 93
105125: PUSH
105126: LD_EXP 94
105130: PUSH
105131: LD_EXP 95
105135: PUSH
105136: LD_EXP 103
105140: PUSH
105141: LD_EXP 104
105145: PUSH
105146: LD_EXP 105
105150: PUSH
105151: LD_EXP 106
105155: PUSH
105156: LD_EXP 108
105160: PUSH
105161: LD_EXP 109
105165: PUSH
105166: LD_EXP 110
105170: PUSH
105171: LD_EXP 113
105175: PUSH
105176: LD_EXP 115
105180: PUSH
105181: LD_EXP 116
105185: PUSH
105186: LD_EXP 117
105190: PUSH
105191: LD_EXP 119
105195: PUSH
105196: LD_EXP 120
105200: PUSH
105201: LD_EXP 123
105205: PUSH
105206: LD_EXP 124
105210: PUSH
105211: LD_EXP 125
105215: PUSH
105216: LD_EXP 126
105220: PUSH
105221: LD_EXP 127
105225: PUSH
105226: LD_EXP 128
105230: PUSH
105231: LD_EXP 129
105235: PUSH
105236: LD_EXP 130
105240: PUSH
105241: LD_EXP 131
105245: PUSH
105246: LD_EXP 96
105250: PUSH
105251: LD_EXP 97
105255: PUSH
105256: LD_EXP 100
105260: PUSH
105261: LD_EXP 101
105265: PUSH
105266: LD_EXP 102
105270: PUSH
105271: LD_EXP 98
105275: PUSH
105276: LD_EXP 99
105280: PUSH
105281: LD_EXP 107
105285: PUSH
105286: LD_EXP 111
105290: PUSH
105291: LD_EXP 112
105295: PUSH
105296: LD_EXP 114
105300: PUSH
105301: LD_EXP 118
105305: PUSH
105306: LD_EXP 121
105310: PUSH
105311: LD_EXP 122
105315: PUSH
105316: LD_EXP 132
105320: PUSH
105321: LD_EXP 133
105325: PUSH
105326: LD_EXP 134
105330: PUSH
105331: LD_EXP 135
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: LIST
105340: LIST
105341: LIST
105342: LIST
105343: LIST
105344: LIST
105345: LIST
105346: LIST
105347: LIST
105348: LIST
105349: LIST
105350: LIST
105351: LIST
105352: LIST
105353: LIST
105354: LIST
105355: LIST
105356: LIST
105357: LIST
105358: LIST
105359: LIST
105360: LIST
105361: LIST
105362: LIST
105363: LIST
105364: LIST
105365: LIST
105366: LIST
105367: LIST
105368: LIST
105369: LIST
105370: LIST
105371: LIST
105372: LIST
105373: LIST
105374: LIST
105375: LIST
105376: LIST
105377: LIST
105378: LIST
105379: LIST
105380: LIST
105381: LIST
105382: LIST
105383: LIST
105384: LIST
105385: LIST
105386: LIST
105387: LIST
105388: LIST
105389: LIST
105390: LIST
105391: ST_TO_ADDR
// tmp :=  ;
105392: LD_ADDR_VAR 0 3
105396: PUSH
105397: LD_STRING 
105399: ST_TO_ADDR
// for i = 1 to normalCounter do
105400: LD_ADDR_VAR 0 8
105404: PUSH
105405: DOUBLE
105406: LD_INT 1
105408: DEC
105409: ST_TO_ADDR
105410: LD_EXP 80
105414: PUSH
105415: FOR_TO
105416: IFFALSE 105452
// begin if flags [ i ] then
105418: LD_VAR 0 4
105422: PUSH
105423: LD_VAR 0 8
105427: ARRAY
105428: IFFALSE 105450
// tmp := tmp & i & ; ;
105430: LD_ADDR_VAR 0 3
105434: PUSH
105435: LD_VAR 0 3
105439: PUSH
105440: LD_VAR 0 8
105444: STR
105445: PUSH
105446: LD_STRING ;
105448: STR
105449: ST_TO_ADDR
// end ;
105450: GO 105415
105452: POP
105453: POP
// for i = 1 to hardcoreCounter do
105454: LD_ADDR_VAR 0 8
105458: PUSH
105459: DOUBLE
105460: LD_INT 1
105462: DEC
105463: ST_TO_ADDR
105464: LD_EXP 81
105468: PUSH
105469: FOR_TO
105470: IFFALSE 105516
// begin if flags [ normalCounter + i ] then
105472: LD_VAR 0 4
105476: PUSH
105477: LD_EXP 80
105481: PUSH
105482: LD_VAR 0 8
105486: PLUS
105487: ARRAY
105488: IFFALSE 105514
// tmp := tmp & ( 100 + i ) & ; ;
105490: LD_ADDR_VAR 0 3
105494: PUSH
105495: LD_VAR 0 3
105499: PUSH
105500: LD_INT 100
105502: PUSH
105503: LD_VAR 0 8
105507: PLUS
105508: STR
105509: PUSH
105510: LD_STRING ;
105512: STR
105513: ST_TO_ADDR
// end ;
105514: GO 105469
105516: POP
105517: POP
// if tmp then
105518: LD_VAR 0 3
105522: IFFALSE 105534
// active := tmp ;
105524: LD_ADDR_VAR 0 7
105528: PUSH
105529: LD_VAR 0 3
105533: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
105534: LD_STRING getStreamItemsFromMission("
105536: PUSH
105537: LD_VAR 0 5
105541: STR
105542: PUSH
105543: LD_STRING ","
105545: STR
105546: PUSH
105547: LD_VAR 0 6
105551: STR
105552: PUSH
105553: LD_STRING ","
105555: STR
105556: PUSH
105557: LD_VAR 0 7
105561: STR
105562: PUSH
105563: LD_STRING ")
105565: STR
105566: PPUSH
105567: CALL_OW 559
// end else
105571: GO 105580
// ToLua ( getStreamItemsFromMission("","","") ) ;
105573: LD_STRING getStreamItemsFromMission("","","")
105575: PPUSH
105576: CALL_OW 559
// end ;
105580: LD_VAR 0 2
105584: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
105585: LD_EXP 79
105589: IFFALSE 105597
105591: PUSH
105592: LD_EXP 84
105596: AND
105597: IFFALSE 105721
105599: GO 105601
105601: DISABLE
105602: LD_INT 0
105604: PPUSH
105605: PPUSH
// begin enable ;
105606: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
105607: LD_ADDR_VAR 0 2
105611: PUSH
105612: LD_INT 22
105614: PUSH
105615: LD_OWVAR 2
105619: PUSH
105620: EMPTY
105621: LIST
105622: LIST
105623: PUSH
105624: LD_INT 2
105626: PUSH
105627: LD_INT 34
105629: PUSH
105630: LD_INT 7
105632: PUSH
105633: EMPTY
105634: LIST
105635: LIST
105636: PUSH
105637: LD_INT 34
105639: PUSH
105640: LD_INT 45
105642: PUSH
105643: EMPTY
105644: LIST
105645: LIST
105646: PUSH
105647: LD_INT 34
105649: PUSH
105650: LD_INT 28
105652: PUSH
105653: EMPTY
105654: LIST
105655: LIST
105656: PUSH
105657: LD_INT 34
105659: PUSH
105660: LD_INT 47
105662: PUSH
105663: EMPTY
105664: LIST
105665: LIST
105666: PUSH
105667: EMPTY
105668: LIST
105669: LIST
105670: LIST
105671: LIST
105672: LIST
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: PPUSH
105678: CALL_OW 69
105682: ST_TO_ADDR
// if not tmp then
105683: LD_VAR 0 2
105687: NOT
105688: IFFALSE 105692
// exit ;
105690: GO 105721
// for i in tmp do
105692: LD_ADDR_VAR 0 1
105696: PUSH
105697: LD_VAR 0 2
105701: PUSH
105702: FOR_IN
105703: IFFALSE 105719
// begin SetLives ( i , 0 ) ;
105705: LD_VAR 0 1
105709: PPUSH
105710: LD_INT 0
105712: PPUSH
105713: CALL_OW 234
// end ;
105717: GO 105702
105719: POP
105720: POP
// end ;
105721: PPOPN 2
105723: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
105724: LD_EXP 79
105728: IFFALSE 105736
105730: PUSH
105731: LD_EXP 85
105735: AND
105736: IFFALSE 105820
105738: GO 105740
105740: DISABLE
105741: LD_INT 0
105743: PPUSH
105744: PPUSH
// begin enable ;
105745: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
105746: LD_ADDR_VAR 0 2
105750: PUSH
105751: LD_INT 22
105753: PUSH
105754: LD_OWVAR 2
105758: PUSH
105759: EMPTY
105760: LIST
105761: LIST
105762: PUSH
105763: LD_INT 32
105765: PUSH
105766: LD_INT 3
105768: PUSH
105769: EMPTY
105770: LIST
105771: LIST
105772: PUSH
105773: EMPTY
105774: LIST
105775: LIST
105776: PPUSH
105777: CALL_OW 69
105781: ST_TO_ADDR
// if not tmp then
105782: LD_VAR 0 2
105786: NOT
105787: IFFALSE 105791
// exit ;
105789: GO 105820
// for i in tmp do
105791: LD_ADDR_VAR 0 1
105795: PUSH
105796: LD_VAR 0 2
105800: PUSH
105801: FOR_IN
105802: IFFALSE 105818
// begin SetLives ( i , 0 ) ;
105804: LD_VAR 0 1
105808: PPUSH
105809: LD_INT 0
105811: PPUSH
105812: CALL_OW 234
// end ;
105816: GO 105801
105818: POP
105819: POP
// end ;
105820: PPOPN 2
105822: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
105823: LD_EXP 79
105827: IFFALSE 105835
105829: PUSH
105830: LD_EXP 82
105834: AND
105835: IFFALSE 105928
105837: GO 105839
105839: DISABLE
105840: LD_INT 0
105842: PPUSH
// begin enable ;
105843: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
105844: LD_ADDR_VAR 0 1
105848: PUSH
105849: LD_INT 22
105851: PUSH
105852: LD_OWVAR 2
105856: PUSH
105857: EMPTY
105858: LIST
105859: LIST
105860: PUSH
105861: LD_INT 2
105863: PUSH
105864: LD_INT 25
105866: PUSH
105867: LD_INT 5
105869: PUSH
105870: EMPTY
105871: LIST
105872: LIST
105873: PUSH
105874: LD_INT 25
105876: PUSH
105877: LD_INT 9
105879: PUSH
105880: EMPTY
105881: LIST
105882: LIST
105883: PUSH
105884: LD_INT 25
105886: PUSH
105887: LD_INT 8
105889: PUSH
105890: EMPTY
105891: LIST
105892: LIST
105893: PUSH
105894: EMPTY
105895: LIST
105896: LIST
105897: LIST
105898: LIST
105899: PUSH
105900: EMPTY
105901: LIST
105902: LIST
105903: PPUSH
105904: CALL_OW 69
105908: PUSH
105909: FOR_IN
105910: IFFALSE 105926
// begin SetClass ( i , 1 ) ;
105912: LD_VAR 0 1
105916: PPUSH
105917: LD_INT 1
105919: PPUSH
105920: CALL_OW 336
// end ;
105924: GO 105909
105926: POP
105927: POP
// end ;
105928: PPOPN 1
105930: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
105931: LD_EXP 79
105935: IFFALSE 105943
105937: PUSH
105938: LD_EXP 83
105942: AND
105943: IFFALSE 105955
105945: PUSH
105946: LD_OWVAR 65
105950: PUSH
105951: LD_INT 7
105953: LESS
105954: AND
105955: IFFALSE 105969
105957: GO 105959
105959: DISABLE
// begin enable ;
105960: ENABLE
// game_speed := 7 ;
105961: LD_ADDR_OWVAR 65
105965: PUSH
105966: LD_INT 7
105968: ST_TO_ADDR
// end ;
105969: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
105970: LD_EXP 79
105974: IFFALSE 105982
105976: PUSH
105977: LD_EXP 86
105981: AND
105982: IFFALSE 106184
105984: GO 105986
105986: DISABLE
105987: LD_INT 0
105989: PPUSH
105990: PPUSH
105991: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
105992: LD_ADDR_VAR 0 3
105996: PUSH
105997: LD_INT 81
105999: PUSH
106000: LD_OWVAR 2
106004: PUSH
106005: EMPTY
106006: LIST
106007: LIST
106008: PUSH
106009: LD_INT 21
106011: PUSH
106012: LD_INT 1
106014: PUSH
106015: EMPTY
106016: LIST
106017: LIST
106018: PUSH
106019: EMPTY
106020: LIST
106021: LIST
106022: PPUSH
106023: CALL_OW 69
106027: ST_TO_ADDR
// if not tmp then
106028: LD_VAR 0 3
106032: NOT
106033: IFFALSE 106037
// exit ;
106035: GO 106184
// if tmp > 5 then
106037: LD_VAR 0 3
106041: PUSH
106042: LD_INT 5
106044: GREATER
106045: IFFALSE 106057
// k := 5 else
106047: LD_ADDR_VAR 0 2
106051: PUSH
106052: LD_INT 5
106054: ST_TO_ADDR
106055: GO 106067
// k := tmp ;
106057: LD_ADDR_VAR 0 2
106061: PUSH
106062: LD_VAR 0 3
106066: ST_TO_ADDR
// for i := 1 to k do
106067: LD_ADDR_VAR 0 1
106071: PUSH
106072: DOUBLE
106073: LD_INT 1
106075: DEC
106076: ST_TO_ADDR
106077: LD_VAR 0 2
106081: PUSH
106082: FOR_TO
106083: IFFALSE 106182
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
106085: LD_VAR 0 3
106089: PUSH
106090: LD_VAR 0 1
106094: ARRAY
106095: PPUSH
106096: LD_VAR 0 1
106100: PUSH
106101: LD_INT 4
106103: MOD
106104: PUSH
106105: LD_INT 1
106107: PLUS
106108: PPUSH
106109: CALL_OW 259
106113: PUSH
106114: LD_INT 10
106116: LESS
106117: IFFALSE 106180
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
106119: LD_VAR 0 3
106123: PUSH
106124: LD_VAR 0 1
106128: ARRAY
106129: PPUSH
106130: LD_VAR 0 1
106134: PUSH
106135: LD_INT 4
106137: MOD
106138: PUSH
106139: LD_INT 1
106141: PLUS
106142: PPUSH
106143: LD_VAR 0 3
106147: PUSH
106148: LD_VAR 0 1
106152: ARRAY
106153: PPUSH
106154: LD_VAR 0 1
106158: PUSH
106159: LD_INT 4
106161: MOD
106162: PUSH
106163: LD_INT 1
106165: PLUS
106166: PPUSH
106167: CALL_OW 259
106171: PUSH
106172: LD_INT 1
106174: PLUS
106175: PPUSH
106176: CALL_OW 237
106180: GO 106082
106182: POP
106183: POP
// end ;
106184: PPOPN 3
106186: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
106187: LD_EXP 79
106191: IFFALSE 106199
106193: PUSH
106194: LD_EXP 87
106198: AND
106199: IFFALSE 106219
106201: GO 106203
106203: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
106204: LD_INT 4
106206: PPUSH
106207: LD_OWVAR 2
106211: PPUSH
106212: LD_INT 0
106214: PPUSH
106215: CALL_OW 324
106219: END
// every 0 0$1 trigger StreamModeActive and sShovel do
106220: LD_EXP 79
106224: IFFALSE 106232
106226: PUSH
106227: LD_EXP 116
106231: AND
106232: IFFALSE 106252
106234: GO 106236
106236: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
106237: LD_INT 19
106239: PPUSH
106240: LD_OWVAR 2
106244: PPUSH
106245: LD_INT 0
106247: PPUSH
106248: CALL_OW 324
106252: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
106253: LD_EXP 79
106257: IFFALSE 106265
106259: PUSH
106260: LD_EXP 88
106264: AND
106265: IFFALSE 106367
106267: GO 106269
106269: DISABLE
106270: LD_INT 0
106272: PPUSH
106273: PPUSH
// begin enable ;
106274: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
106275: LD_ADDR_VAR 0 2
106279: PUSH
106280: LD_INT 22
106282: PUSH
106283: LD_OWVAR 2
106287: PUSH
106288: EMPTY
106289: LIST
106290: LIST
106291: PUSH
106292: LD_INT 2
106294: PUSH
106295: LD_INT 34
106297: PUSH
106298: LD_INT 11
106300: PUSH
106301: EMPTY
106302: LIST
106303: LIST
106304: PUSH
106305: LD_INT 34
106307: PUSH
106308: LD_INT 30
106310: PUSH
106311: EMPTY
106312: LIST
106313: LIST
106314: PUSH
106315: EMPTY
106316: LIST
106317: LIST
106318: LIST
106319: PUSH
106320: EMPTY
106321: LIST
106322: LIST
106323: PPUSH
106324: CALL_OW 69
106328: ST_TO_ADDR
// if not tmp then
106329: LD_VAR 0 2
106333: NOT
106334: IFFALSE 106338
// exit ;
106336: GO 106367
// for i in tmp do
106338: LD_ADDR_VAR 0 1
106342: PUSH
106343: LD_VAR 0 2
106347: PUSH
106348: FOR_IN
106349: IFFALSE 106365
// begin SetLives ( i , 0 ) ;
106351: LD_VAR 0 1
106355: PPUSH
106356: LD_INT 0
106358: PPUSH
106359: CALL_OW 234
// end ;
106363: GO 106348
106365: POP
106366: POP
// end ;
106367: PPOPN 2
106369: END
// every 0 0$1 trigger StreamModeActive and sBunker do
106370: LD_EXP 79
106374: IFFALSE 106382
106376: PUSH
106377: LD_EXP 89
106381: AND
106382: IFFALSE 106402
106384: GO 106386
106386: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
106387: LD_INT 32
106389: PPUSH
106390: LD_OWVAR 2
106394: PPUSH
106395: LD_INT 0
106397: PPUSH
106398: CALL_OW 324
106402: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
106403: LD_EXP 79
106407: IFFALSE 106415
106409: PUSH
106410: LD_EXP 90
106414: AND
106415: IFFALSE 106598
106417: GO 106419
106419: DISABLE
106420: LD_INT 0
106422: PPUSH
106423: PPUSH
106424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
106425: LD_ADDR_VAR 0 2
106429: PUSH
106430: LD_INT 22
106432: PUSH
106433: LD_OWVAR 2
106437: PUSH
106438: EMPTY
106439: LIST
106440: LIST
106441: PUSH
106442: LD_INT 33
106444: PUSH
106445: LD_INT 3
106447: PUSH
106448: EMPTY
106449: LIST
106450: LIST
106451: PUSH
106452: EMPTY
106453: LIST
106454: LIST
106455: PPUSH
106456: CALL_OW 69
106460: ST_TO_ADDR
// if not tmp then
106461: LD_VAR 0 2
106465: NOT
106466: IFFALSE 106470
// exit ;
106468: GO 106598
// side := 0 ;
106470: LD_ADDR_VAR 0 3
106474: PUSH
106475: LD_INT 0
106477: ST_TO_ADDR
// for i := 1 to 8 do
106478: LD_ADDR_VAR 0 1
106482: PUSH
106483: DOUBLE
106484: LD_INT 1
106486: DEC
106487: ST_TO_ADDR
106488: LD_INT 8
106490: PUSH
106491: FOR_TO
106492: IFFALSE 106542
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
106494: LD_OWVAR 2
106498: PUSH
106499: LD_VAR 0 1
106503: NONEQUAL
106504: IFFALSE 106526
106506: PUSH
106507: LD_OWVAR 2
106511: PPUSH
106512: LD_VAR 0 1
106516: PPUSH
106517: CALL_OW 81
106521: PUSH
106522: LD_INT 2
106524: EQUAL
106525: AND
106526: IFFALSE 106540
// begin side := i ;
106528: LD_ADDR_VAR 0 3
106532: PUSH
106533: LD_VAR 0 1
106537: ST_TO_ADDR
// break ;
106538: GO 106542
// end ;
106540: GO 106491
106542: POP
106543: POP
// if not side then
106544: LD_VAR 0 3
106548: NOT
106549: IFFALSE 106553
// exit ;
106551: GO 106598
// for i := 1 to tmp do
106553: LD_ADDR_VAR 0 1
106557: PUSH
106558: DOUBLE
106559: LD_INT 1
106561: DEC
106562: ST_TO_ADDR
106563: LD_VAR 0 2
106567: PUSH
106568: FOR_TO
106569: IFFALSE 106596
// if Prob ( 60 ) then
106571: LD_INT 60
106573: PPUSH
106574: CALL_OW 13
106578: IFFALSE 106594
// SetSide ( i , side ) ;
106580: LD_VAR 0 1
106584: PPUSH
106585: LD_VAR 0 3
106589: PPUSH
106590: CALL_OW 235
106594: GO 106568
106596: POP
106597: POP
// end ;
106598: PPOPN 3
106600: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
106601: LD_EXP 79
106605: IFFALSE 106613
106607: PUSH
106608: LD_EXP 92
106612: AND
106613: IFFALSE 106732
106615: GO 106617
106617: DISABLE
106618: LD_INT 0
106620: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
106621: LD_ADDR_VAR 0 1
106625: PUSH
106626: LD_INT 22
106628: PUSH
106629: LD_OWVAR 2
106633: PUSH
106634: EMPTY
106635: LIST
106636: LIST
106637: PUSH
106638: LD_INT 21
106640: PUSH
106641: LD_INT 1
106643: PUSH
106644: EMPTY
106645: LIST
106646: LIST
106647: PUSH
106648: LD_INT 3
106650: PUSH
106651: LD_INT 23
106653: PUSH
106654: LD_INT 0
106656: PUSH
106657: EMPTY
106658: LIST
106659: LIST
106660: PUSH
106661: EMPTY
106662: LIST
106663: LIST
106664: PUSH
106665: EMPTY
106666: LIST
106667: LIST
106668: LIST
106669: PPUSH
106670: CALL_OW 69
106674: PUSH
106675: FOR_IN
106676: IFFALSE 106730
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
106678: LD_VAR 0 1
106682: PPUSH
106683: CALL_OW 257
106687: PUSH
106688: LD_INT 1
106690: PUSH
106691: LD_INT 2
106693: PUSH
106694: LD_INT 3
106696: PUSH
106697: LD_INT 4
106699: PUSH
106700: EMPTY
106701: LIST
106702: LIST
106703: LIST
106704: LIST
106705: IN
106706: IFFALSE 106728
// SetClass ( un , rand ( 1 , 4 ) ) ;
106708: LD_VAR 0 1
106712: PPUSH
106713: LD_INT 1
106715: PPUSH
106716: LD_INT 4
106718: PPUSH
106719: CALL_OW 12
106723: PPUSH
106724: CALL_OW 336
106728: GO 106675
106730: POP
106731: POP
// end ;
106732: PPOPN 1
106734: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
106735: LD_EXP 79
106739: IFFALSE 106747
106741: PUSH
106742: LD_EXP 91
106746: AND
106747: IFFALSE 106826
106749: GO 106751
106751: DISABLE
106752: LD_INT 0
106754: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
106755: LD_ADDR_VAR 0 1
106759: PUSH
106760: LD_INT 22
106762: PUSH
106763: LD_OWVAR 2
106767: PUSH
106768: EMPTY
106769: LIST
106770: LIST
106771: PUSH
106772: LD_INT 21
106774: PUSH
106775: LD_INT 3
106777: PUSH
106778: EMPTY
106779: LIST
106780: LIST
106781: PUSH
106782: EMPTY
106783: LIST
106784: LIST
106785: PPUSH
106786: CALL_OW 69
106790: ST_TO_ADDR
// if not tmp then
106791: LD_VAR 0 1
106795: NOT
106796: IFFALSE 106800
// exit ;
106798: GO 106826
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
106800: LD_VAR 0 1
106804: PUSH
106805: LD_INT 1
106807: PPUSH
106808: LD_VAR 0 1
106812: PPUSH
106813: CALL_OW 12
106817: ARRAY
106818: PPUSH
106819: LD_INT 100
106821: PPUSH
106822: CALL_OW 234
// end ;
106826: PPOPN 1
106828: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
106829: LD_EXP 79
106833: IFFALSE 106841
106835: PUSH
106836: LD_EXP 93
106840: AND
106841: IFFALSE 106939
106843: GO 106845
106845: DISABLE
106846: LD_INT 0
106848: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
106849: LD_ADDR_VAR 0 1
106853: PUSH
106854: LD_INT 22
106856: PUSH
106857: LD_OWVAR 2
106861: PUSH
106862: EMPTY
106863: LIST
106864: LIST
106865: PUSH
106866: LD_INT 21
106868: PUSH
106869: LD_INT 1
106871: PUSH
106872: EMPTY
106873: LIST
106874: LIST
106875: PUSH
106876: EMPTY
106877: LIST
106878: LIST
106879: PPUSH
106880: CALL_OW 69
106884: ST_TO_ADDR
// if not tmp then
106885: LD_VAR 0 1
106889: NOT
106890: IFFALSE 106894
// exit ;
106892: GO 106939
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
106894: LD_VAR 0 1
106898: PUSH
106899: LD_INT 1
106901: PPUSH
106902: LD_VAR 0 1
106906: PPUSH
106907: CALL_OW 12
106911: ARRAY
106912: PPUSH
106913: LD_INT 1
106915: PPUSH
106916: LD_INT 4
106918: PPUSH
106919: CALL_OW 12
106923: PPUSH
106924: LD_INT 3000
106926: PPUSH
106927: LD_INT 9000
106929: PPUSH
106930: CALL_OW 12
106934: PPUSH
106935: CALL_OW 492
// end ;
106939: PPOPN 1
106941: END
// every 0 0$1 trigger StreamModeActive and sDepot do
106942: LD_EXP 79
106946: IFFALSE 106954
106948: PUSH
106949: LD_EXP 94
106953: AND
106954: IFFALSE 106974
106956: GO 106958
106958: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
106959: LD_INT 1
106961: PPUSH
106962: LD_OWVAR 2
106966: PPUSH
106967: LD_INT 0
106969: PPUSH
106970: CALL_OW 324
106974: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
106975: LD_EXP 79
106979: IFFALSE 106987
106981: PUSH
106982: LD_EXP 95
106986: AND
106987: IFFALSE 107070
106989: GO 106991
106991: DISABLE
106992: LD_INT 0
106994: PPUSH
106995: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
106996: LD_ADDR_VAR 0 2
107000: PUSH
107001: LD_INT 22
107003: PUSH
107004: LD_OWVAR 2
107008: PUSH
107009: EMPTY
107010: LIST
107011: LIST
107012: PUSH
107013: LD_INT 21
107015: PUSH
107016: LD_INT 3
107018: PUSH
107019: EMPTY
107020: LIST
107021: LIST
107022: PUSH
107023: EMPTY
107024: LIST
107025: LIST
107026: PPUSH
107027: CALL_OW 69
107031: ST_TO_ADDR
// if not tmp then
107032: LD_VAR 0 2
107036: NOT
107037: IFFALSE 107041
// exit ;
107039: GO 107070
// for i in tmp do
107041: LD_ADDR_VAR 0 1
107045: PUSH
107046: LD_VAR 0 2
107050: PUSH
107051: FOR_IN
107052: IFFALSE 107068
// SetBLevel ( i , 10 ) ;
107054: LD_VAR 0 1
107058: PPUSH
107059: LD_INT 10
107061: PPUSH
107062: CALL_OW 241
107066: GO 107051
107068: POP
107069: POP
// end ;
107070: PPOPN 2
107072: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
107073: LD_EXP 79
107077: IFFALSE 107085
107079: PUSH
107080: LD_EXP 96
107084: AND
107085: IFFALSE 107196
107087: GO 107089
107089: DISABLE
107090: LD_INT 0
107092: PPUSH
107093: PPUSH
107094: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
107095: LD_ADDR_VAR 0 3
107099: PUSH
107100: LD_INT 22
107102: PUSH
107103: LD_OWVAR 2
107107: PUSH
107108: EMPTY
107109: LIST
107110: LIST
107111: PUSH
107112: LD_INT 25
107114: PUSH
107115: LD_INT 1
107117: PUSH
107118: EMPTY
107119: LIST
107120: LIST
107121: PUSH
107122: EMPTY
107123: LIST
107124: LIST
107125: PPUSH
107126: CALL_OW 69
107130: ST_TO_ADDR
// if not tmp then
107131: LD_VAR 0 3
107135: NOT
107136: IFFALSE 107140
// exit ;
107138: GO 107196
// un := tmp [ rand ( 1 , tmp ) ] ;
107140: LD_ADDR_VAR 0 2
107144: PUSH
107145: LD_VAR 0 3
107149: PUSH
107150: LD_INT 1
107152: PPUSH
107153: LD_VAR 0 3
107157: PPUSH
107158: CALL_OW 12
107162: ARRAY
107163: ST_TO_ADDR
// if Crawls ( un ) then
107164: LD_VAR 0 2
107168: PPUSH
107169: CALL_OW 318
107173: IFFALSE 107184
// ComWalk ( un ) ;
107175: LD_VAR 0 2
107179: PPUSH
107180: CALL_OW 138
// SetClass ( un , class_sniper ) ;
107184: LD_VAR 0 2
107188: PPUSH
107189: LD_INT 5
107191: PPUSH
107192: CALL_OW 336
// end ;
107196: PPOPN 3
107198: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
107199: LD_EXP 79
107203: IFFALSE 107211
107205: PUSH
107206: LD_EXP 97
107210: AND
107211: IFFALSE 107223
107213: PUSH
107214: LD_OWVAR 67
107218: PUSH
107219: LD_INT 4
107221: LESS
107222: AND
107223: IFFALSE 107242
107225: GO 107227
107227: DISABLE
// begin Difficulty := Difficulty + 1 ;
107228: LD_ADDR_OWVAR 67
107232: PUSH
107233: LD_OWVAR 67
107237: PUSH
107238: LD_INT 1
107240: PLUS
107241: ST_TO_ADDR
// end ;
107242: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
107243: LD_EXP 79
107247: IFFALSE 107255
107249: PUSH
107250: LD_EXP 98
107254: AND
107255: IFFALSE 107358
107257: GO 107259
107259: DISABLE
107260: LD_INT 0
107262: PPUSH
// begin for i := 1 to 5 do
107263: LD_ADDR_VAR 0 1
107267: PUSH
107268: DOUBLE
107269: LD_INT 1
107271: DEC
107272: ST_TO_ADDR
107273: LD_INT 5
107275: PUSH
107276: FOR_TO
107277: IFFALSE 107356
// begin uc_nation := nation_nature ;
107279: LD_ADDR_OWVAR 21
107283: PUSH
107284: LD_INT 0
107286: ST_TO_ADDR
// uc_side := 0 ;
107287: LD_ADDR_OWVAR 20
107291: PUSH
107292: LD_INT 0
107294: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107295: LD_ADDR_OWVAR 29
107299: PUSH
107300: LD_INT 12
107302: PUSH
107303: LD_INT 12
107305: PUSH
107306: EMPTY
107307: LIST
107308: LIST
107309: ST_TO_ADDR
// hc_agressivity := 20 ;
107310: LD_ADDR_OWVAR 35
107314: PUSH
107315: LD_INT 20
107317: ST_TO_ADDR
// hc_class := class_tiger ;
107318: LD_ADDR_OWVAR 28
107322: PUSH
107323: LD_INT 14
107325: ST_TO_ADDR
// hc_gallery :=  ;
107326: LD_ADDR_OWVAR 33
107330: PUSH
107331: LD_STRING 
107333: ST_TO_ADDR
// hc_name :=  ;
107334: LD_ADDR_OWVAR 26
107338: PUSH
107339: LD_STRING 
107341: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
107342: CALL_OW 44
107346: PPUSH
107347: LD_INT 0
107349: PPUSH
107350: CALL_OW 51
// end ;
107354: GO 107276
107356: POP
107357: POP
// end ;
107358: PPOPN 1
107360: END
// every 0 0$1 trigger StreamModeActive and sBomb do
107361: LD_EXP 79
107365: IFFALSE 107373
107367: PUSH
107368: LD_EXP 99
107372: AND
107373: IFFALSE 107382
107375: GO 107377
107377: DISABLE
// StreamSibBomb ;
107378: CALL 107383 0 0
107382: END
// export function StreamSibBomb ; var i , x , y ; begin
107383: LD_INT 0
107385: PPUSH
107386: PPUSH
107387: PPUSH
107388: PPUSH
// result := false ;
107389: LD_ADDR_VAR 0 1
107393: PUSH
107394: LD_INT 0
107396: ST_TO_ADDR
// for i := 1 to 16 do
107397: LD_ADDR_VAR 0 2
107401: PUSH
107402: DOUBLE
107403: LD_INT 1
107405: DEC
107406: ST_TO_ADDR
107407: LD_INT 16
107409: PUSH
107410: FOR_TO
107411: IFFALSE 107610
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107413: LD_ADDR_VAR 0 3
107417: PUSH
107418: LD_INT 10
107420: PUSH
107421: LD_INT 20
107423: PUSH
107424: LD_INT 30
107426: PUSH
107427: LD_INT 40
107429: PUSH
107430: LD_INT 50
107432: PUSH
107433: LD_INT 60
107435: PUSH
107436: LD_INT 70
107438: PUSH
107439: LD_INT 80
107441: PUSH
107442: LD_INT 90
107444: PUSH
107445: LD_INT 100
107447: PUSH
107448: LD_INT 110
107450: PUSH
107451: LD_INT 120
107453: PUSH
107454: LD_INT 130
107456: PUSH
107457: LD_INT 140
107459: PUSH
107460: LD_INT 150
107462: PUSH
107463: EMPTY
107464: LIST
107465: LIST
107466: LIST
107467: LIST
107468: LIST
107469: LIST
107470: LIST
107471: LIST
107472: LIST
107473: LIST
107474: LIST
107475: LIST
107476: LIST
107477: LIST
107478: LIST
107479: PUSH
107480: LD_INT 1
107482: PPUSH
107483: LD_INT 15
107485: PPUSH
107486: CALL_OW 12
107490: ARRAY
107491: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
107492: LD_ADDR_VAR 0 4
107496: PUSH
107497: LD_INT 10
107499: PUSH
107500: LD_INT 20
107502: PUSH
107503: LD_INT 30
107505: PUSH
107506: LD_INT 40
107508: PUSH
107509: LD_INT 50
107511: PUSH
107512: LD_INT 60
107514: PUSH
107515: LD_INT 70
107517: PUSH
107518: LD_INT 80
107520: PUSH
107521: LD_INT 90
107523: PUSH
107524: LD_INT 100
107526: PUSH
107527: LD_INT 110
107529: PUSH
107530: LD_INT 120
107532: PUSH
107533: LD_INT 130
107535: PUSH
107536: LD_INT 140
107538: PUSH
107539: LD_INT 150
107541: PUSH
107542: EMPTY
107543: LIST
107544: LIST
107545: LIST
107546: LIST
107547: LIST
107548: LIST
107549: LIST
107550: LIST
107551: LIST
107552: LIST
107553: LIST
107554: LIST
107555: LIST
107556: LIST
107557: LIST
107558: PUSH
107559: LD_INT 1
107561: PPUSH
107562: LD_INT 15
107564: PPUSH
107565: CALL_OW 12
107569: ARRAY
107570: ST_TO_ADDR
// if ValidHex ( x , y ) then
107571: LD_VAR 0 3
107575: PPUSH
107576: LD_VAR 0 4
107580: PPUSH
107581: CALL_OW 488
107585: IFFALSE 107608
// begin result := [ x , y ] ;
107587: LD_ADDR_VAR 0 1
107591: PUSH
107592: LD_VAR 0 3
107596: PUSH
107597: LD_VAR 0 4
107601: PUSH
107602: EMPTY
107603: LIST
107604: LIST
107605: ST_TO_ADDR
// break ;
107606: GO 107610
// end ; end ;
107608: GO 107410
107610: POP
107611: POP
// if result then
107612: LD_VAR 0 1
107616: IFFALSE 107676
// begin ToLua ( playSibBomb() ) ;
107618: LD_STRING playSibBomb()
107620: PPUSH
107621: CALL_OW 559
// wait ( 0 0$14 ) ;
107625: LD_INT 490
107627: PPUSH
107628: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
107632: LD_VAR 0 1
107636: PUSH
107637: LD_INT 1
107639: ARRAY
107640: PPUSH
107641: LD_VAR 0 1
107645: PUSH
107646: LD_INT 2
107648: ARRAY
107649: PPUSH
107650: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
107654: LD_VAR 0 1
107658: PUSH
107659: LD_INT 1
107661: ARRAY
107662: PPUSH
107663: LD_VAR 0 1
107667: PUSH
107668: LD_INT 2
107670: ARRAY
107671: PPUSH
107672: CALL_OW 429
// end ; end ;
107676: LD_VAR 0 1
107680: RET
// every 0 0$1 trigger StreamModeActive and sReset do
107681: LD_EXP 79
107685: IFFALSE 107693
107687: PUSH
107688: LD_EXP 101
107692: AND
107693: IFFALSE 107705
107695: GO 107697
107697: DISABLE
// YouLost (  ) ;
107698: LD_STRING 
107700: PPUSH
107701: CALL_OW 104
107705: END
// every 0 0$1 trigger StreamModeActive and sFog do
107706: LD_EXP 79
107710: IFFALSE 107718
107712: PUSH
107713: LD_EXP 100
107717: AND
107718: IFFALSE 107732
107720: GO 107722
107722: DISABLE
// FogOff ( your_side ) ;
107723: LD_OWVAR 2
107727: PPUSH
107728: CALL_OW 344
107732: END
// every 0 0$1 trigger StreamModeActive and sSun do
107733: LD_EXP 79
107737: IFFALSE 107745
107739: PUSH
107740: LD_EXP 102
107744: AND
107745: IFFALSE 107773
107747: GO 107749
107749: DISABLE
// begin solar_recharge_percent := 0 ;
107750: LD_ADDR_OWVAR 79
107754: PUSH
107755: LD_INT 0
107757: ST_TO_ADDR
// wait ( 5 5$00 ) ;
107758: LD_INT 10500
107760: PPUSH
107761: CALL_OW 67
// solar_recharge_percent := 100 ;
107765: LD_ADDR_OWVAR 79
107769: PUSH
107770: LD_INT 100
107772: ST_TO_ADDR
// end ;
107773: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
107774: LD_EXP 79
107778: IFFALSE 107786
107780: PUSH
107781: LD_EXP 103
107785: AND
107786: IFFALSE 108025
107788: GO 107790
107790: DISABLE
107791: LD_INT 0
107793: PPUSH
107794: PPUSH
107795: PPUSH
// begin tmp := [ ] ;
107796: LD_ADDR_VAR 0 3
107800: PUSH
107801: EMPTY
107802: ST_TO_ADDR
// for i := 1 to 6 do
107803: LD_ADDR_VAR 0 1
107807: PUSH
107808: DOUBLE
107809: LD_INT 1
107811: DEC
107812: ST_TO_ADDR
107813: LD_INT 6
107815: PUSH
107816: FOR_TO
107817: IFFALSE 107922
// begin uc_nation := nation_nature ;
107819: LD_ADDR_OWVAR 21
107823: PUSH
107824: LD_INT 0
107826: ST_TO_ADDR
// uc_side := 0 ;
107827: LD_ADDR_OWVAR 20
107831: PUSH
107832: LD_INT 0
107834: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
107835: LD_ADDR_OWVAR 29
107839: PUSH
107840: LD_INT 12
107842: PUSH
107843: LD_INT 12
107845: PUSH
107846: EMPTY
107847: LIST
107848: LIST
107849: ST_TO_ADDR
// hc_agressivity := 20 ;
107850: LD_ADDR_OWVAR 35
107854: PUSH
107855: LD_INT 20
107857: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
107858: LD_ADDR_OWVAR 28
107862: PUSH
107863: LD_INT 17
107865: ST_TO_ADDR
// hc_gallery :=  ;
107866: LD_ADDR_OWVAR 33
107870: PUSH
107871: LD_STRING 
107873: ST_TO_ADDR
// hc_name :=  ;
107874: LD_ADDR_OWVAR 26
107878: PUSH
107879: LD_STRING 
107881: ST_TO_ADDR
// un := CreateHuman ;
107882: LD_ADDR_VAR 0 2
107886: PUSH
107887: CALL_OW 44
107891: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
107892: LD_VAR 0 2
107896: PPUSH
107897: LD_INT 1
107899: PPUSH
107900: CALL_OW 51
// tmp := tmp ^ un ;
107904: LD_ADDR_VAR 0 3
107908: PUSH
107909: LD_VAR 0 3
107913: PUSH
107914: LD_VAR 0 2
107918: ADD
107919: ST_TO_ADDR
// end ;
107920: GO 107816
107922: POP
107923: POP
// repeat wait ( 0 0$1 ) ;
107924: LD_INT 35
107926: PPUSH
107927: CALL_OW 67
// for un in tmp do
107931: LD_ADDR_VAR 0 2
107935: PUSH
107936: LD_VAR 0 3
107940: PUSH
107941: FOR_IN
107942: IFFALSE 108016
// begin if IsDead ( un ) then
107944: LD_VAR 0 2
107948: PPUSH
107949: CALL_OW 301
107953: IFFALSE 107973
// begin tmp := tmp diff un ;
107955: LD_ADDR_VAR 0 3
107959: PUSH
107960: LD_VAR 0 3
107964: PUSH
107965: LD_VAR 0 2
107969: DIFF
107970: ST_TO_ADDR
// continue ;
107971: GO 107941
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
107973: LD_VAR 0 2
107977: PPUSH
107978: LD_INT 3
107980: PUSH
107981: LD_INT 22
107983: PUSH
107984: LD_INT 0
107986: PUSH
107987: EMPTY
107988: LIST
107989: LIST
107990: PUSH
107991: EMPTY
107992: LIST
107993: LIST
107994: PPUSH
107995: CALL_OW 69
107999: PPUSH
108000: LD_VAR 0 2
108004: PPUSH
108005: CALL_OW 74
108009: PPUSH
108010: CALL_OW 115
// end ;
108014: GO 107941
108016: POP
108017: POP
// until not tmp ;
108018: LD_VAR 0 3
108022: NOT
108023: IFFALSE 107924
// end ;
108025: PPOPN 3
108027: END
// every 0 0$1 trigger StreamModeActive and sTroll do
108028: LD_EXP 79
108032: IFFALSE 108040
108034: PUSH
108035: LD_EXP 104
108039: AND
108040: IFFALSE 108094
108042: GO 108044
108044: DISABLE
// begin ToLua ( displayTroll(); ) ;
108045: LD_STRING displayTroll();
108047: PPUSH
108048: CALL_OW 559
// wait ( 3 3$00 ) ;
108052: LD_INT 6300
108054: PPUSH
108055: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108059: LD_STRING hideTroll();
108061: PPUSH
108062: CALL_OW 559
// wait ( 1 1$00 ) ;
108066: LD_INT 2100
108068: PPUSH
108069: CALL_OW 67
// ToLua ( displayTroll(); ) ;
108073: LD_STRING displayTroll();
108075: PPUSH
108076: CALL_OW 559
// wait ( 1 1$00 ) ;
108080: LD_INT 2100
108082: PPUSH
108083: CALL_OW 67
// ToLua ( hideTroll(); ) ;
108087: LD_STRING hideTroll();
108089: PPUSH
108090: CALL_OW 559
// end ;
108094: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
108095: LD_EXP 79
108099: IFFALSE 108107
108101: PUSH
108102: LD_EXP 105
108106: AND
108107: IFFALSE 108170
108109: GO 108111
108111: DISABLE
108112: LD_INT 0
108114: PPUSH
// begin p := 0 ;
108115: LD_ADDR_VAR 0 1
108119: PUSH
108120: LD_INT 0
108122: ST_TO_ADDR
// repeat game_speed := 1 ;
108123: LD_ADDR_OWVAR 65
108127: PUSH
108128: LD_INT 1
108130: ST_TO_ADDR
// wait ( 0 0$1 ) ;
108131: LD_INT 35
108133: PPUSH
108134: CALL_OW 67
// p := p + 1 ;
108138: LD_ADDR_VAR 0 1
108142: PUSH
108143: LD_VAR 0 1
108147: PUSH
108148: LD_INT 1
108150: PLUS
108151: ST_TO_ADDR
// until p >= 60 ;
108152: LD_VAR 0 1
108156: PUSH
108157: LD_INT 60
108159: GREATEREQUAL
108160: IFFALSE 108123
// game_speed := 4 ;
108162: LD_ADDR_OWVAR 65
108166: PUSH
108167: LD_INT 4
108169: ST_TO_ADDR
// end ;
108170: PPOPN 1
108172: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
108173: LD_EXP 79
108177: IFFALSE 108185
108179: PUSH
108180: LD_EXP 106
108184: AND
108185: IFFALSE 108331
108187: GO 108189
108189: DISABLE
108190: LD_INT 0
108192: PPUSH
108193: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
108194: LD_ADDR_VAR 0 1
108198: PUSH
108199: LD_INT 22
108201: PUSH
108202: LD_OWVAR 2
108206: PUSH
108207: EMPTY
108208: LIST
108209: LIST
108210: PUSH
108211: LD_INT 2
108213: PUSH
108214: LD_INT 30
108216: PUSH
108217: LD_INT 0
108219: PUSH
108220: EMPTY
108221: LIST
108222: LIST
108223: PUSH
108224: LD_INT 30
108226: PUSH
108227: LD_INT 1
108229: PUSH
108230: EMPTY
108231: LIST
108232: LIST
108233: PUSH
108234: EMPTY
108235: LIST
108236: LIST
108237: LIST
108238: PUSH
108239: EMPTY
108240: LIST
108241: LIST
108242: PPUSH
108243: CALL_OW 69
108247: ST_TO_ADDR
// if not depot then
108248: LD_VAR 0 1
108252: NOT
108253: IFFALSE 108257
// exit ;
108255: GO 108331
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
108257: LD_ADDR_VAR 0 2
108261: PUSH
108262: LD_VAR 0 1
108266: PUSH
108267: LD_INT 1
108269: PPUSH
108270: LD_VAR 0 1
108274: PPUSH
108275: CALL_OW 12
108279: ARRAY
108280: PPUSH
108281: CALL_OW 274
108285: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
108286: LD_VAR 0 2
108290: PPUSH
108291: LD_INT 1
108293: PPUSH
108294: LD_INT 0
108296: PPUSH
108297: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
108301: LD_VAR 0 2
108305: PPUSH
108306: LD_INT 2
108308: PPUSH
108309: LD_INT 0
108311: PPUSH
108312: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
108316: LD_VAR 0 2
108320: PPUSH
108321: LD_INT 3
108323: PPUSH
108324: LD_INT 0
108326: PPUSH
108327: CALL_OW 277
// end ;
108331: PPOPN 2
108333: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
108334: LD_EXP 79
108338: IFFALSE 108346
108340: PUSH
108341: LD_EXP 107
108345: AND
108346: IFFALSE 108443
108348: GO 108350
108350: DISABLE
108351: LD_INT 0
108353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
108354: LD_ADDR_VAR 0 1
108358: PUSH
108359: LD_INT 22
108361: PUSH
108362: LD_OWVAR 2
108366: PUSH
108367: EMPTY
108368: LIST
108369: LIST
108370: PUSH
108371: LD_INT 21
108373: PUSH
108374: LD_INT 1
108376: PUSH
108377: EMPTY
108378: LIST
108379: LIST
108380: PUSH
108381: LD_INT 3
108383: PUSH
108384: LD_INT 23
108386: PUSH
108387: LD_INT 0
108389: PUSH
108390: EMPTY
108391: LIST
108392: LIST
108393: PUSH
108394: EMPTY
108395: LIST
108396: LIST
108397: PUSH
108398: EMPTY
108399: LIST
108400: LIST
108401: LIST
108402: PPUSH
108403: CALL_OW 69
108407: ST_TO_ADDR
// if not tmp then
108408: LD_VAR 0 1
108412: NOT
108413: IFFALSE 108417
// exit ;
108415: GO 108443
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
108417: LD_VAR 0 1
108421: PUSH
108422: LD_INT 1
108424: PPUSH
108425: LD_VAR 0 1
108429: PPUSH
108430: CALL_OW 12
108434: ARRAY
108435: PPUSH
108436: LD_INT 200
108438: PPUSH
108439: CALL_OW 234
// end ;
108443: PPOPN 1
108445: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
108446: LD_EXP 79
108450: IFFALSE 108458
108452: PUSH
108453: LD_EXP 108
108457: AND
108458: IFFALSE 108537
108460: GO 108462
108462: DISABLE
108463: LD_INT 0
108465: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
108466: LD_ADDR_VAR 0 1
108470: PUSH
108471: LD_INT 22
108473: PUSH
108474: LD_OWVAR 2
108478: PUSH
108479: EMPTY
108480: LIST
108481: LIST
108482: PUSH
108483: LD_INT 21
108485: PUSH
108486: LD_INT 2
108488: PUSH
108489: EMPTY
108490: LIST
108491: LIST
108492: PUSH
108493: EMPTY
108494: LIST
108495: LIST
108496: PPUSH
108497: CALL_OW 69
108501: ST_TO_ADDR
// if not tmp then
108502: LD_VAR 0 1
108506: NOT
108507: IFFALSE 108511
// exit ;
108509: GO 108537
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
108511: LD_VAR 0 1
108515: PUSH
108516: LD_INT 1
108518: PPUSH
108519: LD_VAR 0 1
108523: PPUSH
108524: CALL_OW 12
108528: ARRAY
108529: PPUSH
108530: LD_INT 60
108532: PPUSH
108533: CALL_OW 234
// end ;
108537: PPOPN 1
108539: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
108540: LD_EXP 79
108544: IFFALSE 108552
108546: PUSH
108547: LD_EXP 109
108551: AND
108552: IFFALSE 108651
108554: GO 108556
108556: DISABLE
108557: LD_INT 0
108559: PPUSH
108560: PPUSH
// begin enable ;
108561: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
108562: LD_ADDR_VAR 0 1
108566: PUSH
108567: LD_INT 22
108569: PUSH
108570: LD_OWVAR 2
108574: PUSH
108575: EMPTY
108576: LIST
108577: LIST
108578: PUSH
108579: LD_INT 61
108581: PUSH
108582: EMPTY
108583: LIST
108584: PUSH
108585: LD_INT 33
108587: PUSH
108588: LD_INT 2
108590: PUSH
108591: EMPTY
108592: LIST
108593: LIST
108594: PUSH
108595: EMPTY
108596: LIST
108597: LIST
108598: LIST
108599: PPUSH
108600: CALL_OW 69
108604: ST_TO_ADDR
// if not tmp then
108605: LD_VAR 0 1
108609: NOT
108610: IFFALSE 108614
// exit ;
108612: GO 108651
// for i in tmp do
108614: LD_ADDR_VAR 0 2
108618: PUSH
108619: LD_VAR 0 1
108623: PUSH
108624: FOR_IN
108625: IFFALSE 108649
// if IsControledBy ( i ) then
108627: LD_VAR 0 2
108631: PPUSH
108632: CALL_OW 312
108636: IFFALSE 108647
// ComUnlink ( i ) ;
108638: LD_VAR 0 2
108642: PPUSH
108643: CALL_OW 136
108647: GO 108624
108649: POP
108650: POP
// end ;
108651: PPOPN 2
108653: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
108654: LD_EXP 79
108658: IFFALSE 108666
108660: PUSH
108661: LD_EXP 110
108665: AND
108666: IFFALSE 108806
108668: GO 108670
108670: DISABLE
108671: LD_INT 0
108673: PPUSH
108674: PPUSH
// begin ToLua ( displayPowell(); ) ;
108675: LD_STRING displayPowell();
108677: PPUSH
108678: CALL_OW 559
// uc_side := 0 ;
108682: LD_ADDR_OWVAR 20
108686: PUSH
108687: LD_INT 0
108689: ST_TO_ADDR
// uc_nation := 2 ;
108690: LD_ADDR_OWVAR 21
108694: PUSH
108695: LD_INT 2
108697: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
108698: LD_ADDR_OWVAR 37
108702: PUSH
108703: LD_INT 14
108705: ST_TO_ADDR
// vc_engine := engine_siberite ;
108706: LD_ADDR_OWVAR 39
108710: PUSH
108711: LD_INT 3
108713: ST_TO_ADDR
// vc_control := control_apeman ;
108714: LD_ADDR_OWVAR 38
108718: PUSH
108719: LD_INT 5
108721: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
108722: LD_ADDR_OWVAR 40
108726: PUSH
108727: LD_INT 29
108729: ST_TO_ADDR
// un := CreateVehicle ;
108730: LD_ADDR_VAR 0 2
108734: PUSH
108735: CALL_OW 45
108739: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
108740: LD_VAR 0 2
108744: PPUSH
108745: LD_INT 1
108747: PPUSH
108748: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
108752: LD_INT 35
108754: PPUSH
108755: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
108759: LD_VAR 0 2
108763: PPUSH
108764: LD_INT 22
108766: PUSH
108767: LD_OWVAR 2
108771: PUSH
108772: EMPTY
108773: LIST
108774: LIST
108775: PPUSH
108776: CALL_OW 69
108780: PPUSH
108781: LD_VAR 0 2
108785: PPUSH
108786: CALL_OW 74
108790: PPUSH
108791: CALL_OW 115
// until IsDead ( un ) ;
108795: LD_VAR 0 2
108799: PPUSH
108800: CALL_OW 301
108804: IFFALSE 108752
// end ;
108806: PPOPN 2
108808: END
// every 0 0$1 trigger StreamModeActive and sStu do
108809: LD_EXP 79
108813: IFFALSE 108821
108815: PUSH
108816: LD_EXP 118
108820: AND
108821: IFFALSE 108837
108823: GO 108825
108825: DISABLE
// begin ToLua ( displayStucuk(); ) ;
108826: LD_STRING displayStucuk();
108828: PPUSH
108829: CALL_OW 559
// ResetFog ;
108833: CALL_OW 335
// end ;
108837: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
108838: LD_EXP 79
108842: IFFALSE 108850
108844: PUSH
108845: LD_EXP 111
108849: AND
108850: IFFALSE 108991
108852: GO 108854
108854: DISABLE
108855: LD_INT 0
108857: PPUSH
108858: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
108859: LD_ADDR_VAR 0 2
108863: PUSH
108864: LD_INT 22
108866: PUSH
108867: LD_OWVAR 2
108871: PUSH
108872: EMPTY
108873: LIST
108874: LIST
108875: PUSH
108876: LD_INT 21
108878: PUSH
108879: LD_INT 1
108881: PUSH
108882: EMPTY
108883: LIST
108884: LIST
108885: PUSH
108886: EMPTY
108887: LIST
108888: LIST
108889: PPUSH
108890: CALL_OW 69
108894: ST_TO_ADDR
// if not tmp then
108895: LD_VAR 0 2
108899: NOT
108900: IFFALSE 108904
// exit ;
108902: GO 108991
// un := tmp [ rand ( 1 , tmp ) ] ;
108904: LD_ADDR_VAR 0 1
108908: PUSH
108909: LD_VAR 0 2
108913: PUSH
108914: LD_INT 1
108916: PPUSH
108917: LD_VAR 0 2
108921: PPUSH
108922: CALL_OW 12
108926: ARRAY
108927: ST_TO_ADDR
// SetSide ( un , 0 ) ;
108928: LD_VAR 0 1
108932: PPUSH
108933: LD_INT 0
108935: PPUSH
108936: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
108940: LD_VAR 0 1
108944: PPUSH
108945: LD_OWVAR 3
108949: PUSH
108950: LD_VAR 0 1
108954: DIFF
108955: PPUSH
108956: LD_VAR 0 1
108960: PPUSH
108961: CALL_OW 74
108965: PPUSH
108966: CALL_OW 115
// wait ( 0 0$20 ) ;
108970: LD_INT 700
108972: PPUSH
108973: CALL_OW 67
// SetSide ( un , your_side ) ;
108977: LD_VAR 0 1
108981: PPUSH
108982: LD_OWVAR 2
108986: PPUSH
108987: CALL_OW 235
// end ;
108991: PPOPN 2
108993: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
108994: LD_EXP 79
108998: IFFALSE 109006
109000: PUSH
109001: LD_EXP 112
109005: AND
109006: IFFALSE 109112
109008: GO 109010
109010: DISABLE
109011: LD_INT 0
109013: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
109014: LD_ADDR_VAR 0 1
109018: PUSH
109019: LD_INT 22
109021: PUSH
109022: LD_OWVAR 2
109026: PUSH
109027: EMPTY
109028: LIST
109029: LIST
109030: PUSH
109031: LD_INT 2
109033: PUSH
109034: LD_INT 30
109036: PUSH
109037: LD_INT 0
109039: PUSH
109040: EMPTY
109041: LIST
109042: LIST
109043: PUSH
109044: LD_INT 30
109046: PUSH
109047: LD_INT 1
109049: PUSH
109050: EMPTY
109051: LIST
109052: LIST
109053: PUSH
109054: EMPTY
109055: LIST
109056: LIST
109057: LIST
109058: PUSH
109059: EMPTY
109060: LIST
109061: LIST
109062: PPUSH
109063: CALL_OW 69
109067: ST_TO_ADDR
// if not depot then
109068: LD_VAR 0 1
109072: NOT
109073: IFFALSE 109077
// exit ;
109075: GO 109112
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
109077: LD_VAR 0 1
109081: PUSH
109082: LD_INT 1
109084: ARRAY
109085: PPUSH
109086: CALL_OW 250
109090: PPUSH
109091: LD_VAR 0 1
109095: PUSH
109096: LD_INT 1
109098: ARRAY
109099: PPUSH
109100: CALL_OW 251
109104: PPUSH
109105: LD_INT 70
109107: PPUSH
109108: CALL_OW 495
// end ;
109112: PPOPN 1
109114: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
109115: LD_EXP 79
109119: IFFALSE 109127
109121: PUSH
109122: LD_EXP 113
109126: AND
109127: IFFALSE 109338
109129: GO 109131
109131: DISABLE
109132: LD_INT 0
109134: PPUSH
109135: PPUSH
109136: PPUSH
109137: PPUSH
109138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
109139: LD_ADDR_VAR 0 5
109143: PUSH
109144: LD_INT 22
109146: PUSH
109147: LD_OWVAR 2
109151: PUSH
109152: EMPTY
109153: LIST
109154: LIST
109155: PUSH
109156: LD_INT 21
109158: PUSH
109159: LD_INT 1
109161: PUSH
109162: EMPTY
109163: LIST
109164: LIST
109165: PUSH
109166: EMPTY
109167: LIST
109168: LIST
109169: PPUSH
109170: CALL_OW 69
109174: ST_TO_ADDR
// if not tmp then
109175: LD_VAR 0 5
109179: NOT
109180: IFFALSE 109184
// exit ;
109182: GO 109338
// for i in tmp do
109184: LD_ADDR_VAR 0 1
109188: PUSH
109189: LD_VAR 0 5
109193: PUSH
109194: FOR_IN
109195: IFFALSE 109336
// begin d := rand ( 0 , 5 ) ;
109197: LD_ADDR_VAR 0 4
109201: PUSH
109202: LD_INT 0
109204: PPUSH
109205: LD_INT 5
109207: PPUSH
109208: CALL_OW 12
109212: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
109213: LD_ADDR_VAR 0 2
109217: PUSH
109218: LD_VAR 0 1
109222: PPUSH
109223: CALL_OW 250
109227: PPUSH
109228: LD_VAR 0 4
109232: PPUSH
109233: LD_INT 3
109235: PPUSH
109236: LD_INT 12
109238: PPUSH
109239: CALL_OW 12
109243: PPUSH
109244: CALL_OW 272
109248: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
109249: LD_ADDR_VAR 0 3
109253: PUSH
109254: LD_VAR 0 1
109258: PPUSH
109259: CALL_OW 251
109263: PPUSH
109264: LD_VAR 0 4
109268: PPUSH
109269: LD_INT 3
109271: PPUSH
109272: LD_INT 12
109274: PPUSH
109275: CALL_OW 12
109279: PPUSH
109280: CALL_OW 273
109284: ST_TO_ADDR
// if ValidHex ( x , y ) then
109285: LD_VAR 0 2
109289: PPUSH
109290: LD_VAR 0 3
109294: PPUSH
109295: CALL_OW 488
109299: IFFALSE 109334
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
109301: LD_VAR 0 1
109305: PPUSH
109306: LD_VAR 0 2
109310: PPUSH
109311: LD_VAR 0 3
109315: PPUSH
109316: LD_INT 3
109318: PPUSH
109319: LD_INT 6
109321: PPUSH
109322: CALL_OW 12
109326: PPUSH
109327: LD_INT 1
109329: PPUSH
109330: CALL_OW 483
// end ;
109334: GO 109194
109336: POP
109337: POP
// end ;
109338: PPOPN 5
109340: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
109341: LD_EXP 79
109345: IFFALSE 109353
109347: PUSH
109348: LD_EXP 114
109352: AND
109353: IFFALSE 109447
109355: GO 109357
109357: DISABLE
109358: LD_INT 0
109360: PPUSH
109361: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
109362: LD_ADDR_VAR 0 2
109366: PUSH
109367: LD_INT 22
109369: PUSH
109370: LD_OWVAR 2
109374: PUSH
109375: EMPTY
109376: LIST
109377: LIST
109378: PUSH
109379: LD_INT 32
109381: PUSH
109382: LD_INT 1
109384: PUSH
109385: EMPTY
109386: LIST
109387: LIST
109388: PUSH
109389: LD_INT 21
109391: PUSH
109392: LD_INT 2
109394: PUSH
109395: EMPTY
109396: LIST
109397: LIST
109398: PUSH
109399: EMPTY
109400: LIST
109401: LIST
109402: LIST
109403: PPUSH
109404: CALL_OW 69
109408: ST_TO_ADDR
// if not tmp then
109409: LD_VAR 0 2
109413: NOT
109414: IFFALSE 109418
// exit ;
109416: GO 109447
// for i in tmp do
109418: LD_ADDR_VAR 0 1
109422: PUSH
109423: LD_VAR 0 2
109427: PUSH
109428: FOR_IN
109429: IFFALSE 109445
// SetFuel ( i , 0 ) ;
109431: LD_VAR 0 1
109435: PPUSH
109436: LD_INT 0
109438: PPUSH
109439: CALL_OW 240
109443: GO 109428
109445: POP
109446: POP
// end ;
109447: PPOPN 2
109449: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
109450: LD_EXP 79
109454: IFFALSE 109462
109456: PUSH
109457: LD_EXP 115
109461: AND
109462: IFFALSE 109528
109464: GO 109466
109466: DISABLE
109467: LD_INT 0
109469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
109470: LD_ADDR_VAR 0 1
109474: PUSH
109475: LD_INT 22
109477: PUSH
109478: LD_OWVAR 2
109482: PUSH
109483: EMPTY
109484: LIST
109485: LIST
109486: PUSH
109487: LD_INT 30
109489: PUSH
109490: LD_INT 29
109492: PUSH
109493: EMPTY
109494: LIST
109495: LIST
109496: PUSH
109497: EMPTY
109498: LIST
109499: LIST
109500: PPUSH
109501: CALL_OW 69
109505: ST_TO_ADDR
// if not tmp then
109506: LD_VAR 0 1
109510: NOT
109511: IFFALSE 109515
// exit ;
109513: GO 109528
// DestroyUnit ( tmp [ 1 ] ) ;
109515: LD_VAR 0 1
109519: PUSH
109520: LD_INT 1
109522: ARRAY
109523: PPUSH
109524: CALL_OW 65
// end ;
109528: PPOPN 1
109530: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
109531: LD_EXP 79
109535: IFFALSE 109543
109537: PUSH
109538: LD_EXP 117
109542: AND
109543: IFFALSE 109672
109545: GO 109547
109547: DISABLE
109548: LD_INT 0
109550: PPUSH
// begin uc_side := 0 ;
109551: LD_ADDR_OWVAR 20
109555: PUSH
109556: LD_INT 0
109558: ST_TO_ADDR
// uc_nation := nation_arabian ;
109559: LD_ADDR_OWVAR 21
109563: PUSH
109564: LD_INT 2
109566: ST_TO_ADDR
// hc_gallery :=  ;
109567: LD_ADDR_OWVAR 33
109571: PUSH
109572: LD_STRING 
109574: ST_TO_ADDR
// hc_name :=  ;
109575: LD_ADDR_OWVAR 26
109579: PUSH
109580: LD_STRING 
109582: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
109583: LD_INT 1
109585: PPUSH
109586: LD_INT 11
109588: PPUSH
109589: LD_INT 10
109591: PPUSH
109592: CALL_OW 380
// un := CreateHuman ;
109596: LD_ADDR_VAR 0 1
109600: PUSH
109601: CALL_OW 44
109605: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
109606: LD_VAR 0 1
109610: PPUSH
109611: LD_INT 1
109613: PPUSH
109614: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
109618: LD_INT 35
109620: PPUSH
109621: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
109625: LD_VAR 0 1
109629: PPUSH
109630: LD_INT 22
109632: PUSH
109633: LD_OWVAR 2
109637: PUSH
109638: EMPTY
109639: LIST
109640: LIST
109641: PPUSH
109642: CALL_OW 69
109646: PPUSH
109647: LD_VAR 0 1
109651: PPUSH
109652: CALL_OW 74
109656: PPUSH
109657: CALL_OW 115
// until IsDead ( un ) ;
109661: LD_VAR 0 1
109665: PPUSH
109666: CALL_OW 301
109670: IFFALSE 109618
// end ;
109672: PPOPN 1
109674: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
109675: LD_EXP 79
109679: IFFALSE 109687
109681: PUSH
109682: LD_EXP 119
109686: AND
109687: IFFALSE 109699
109689: GO 109691
109691: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
109692: LD_STRING earthquake(getX(game), 0, 32)
109694: PPUSH
109695: CALL_OW 559
109699: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
109700: LD_EXP 79
109704: IFFALSE 109712
109706: PUSH
109707: LD_EXP 120
109711: AND
109712: IFFALSE 109803
109714: GO 109716
109716: DISABLE
109717: LD_INT 0
109719: PPUSH
// begin enable ;
109720: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
109721: LD_ADDR_VAR 0 1
109725: PUSH
109726: LD_INT 22
109728: PUSH
109729: LD_OWVAR 2
109733: PUSH
109734: EMPTY
109735: LIST
109736: LIST
109737: PUSH
109738: LD_INT 21
109740: PUSH
109741: LD_INT 2
109743: PUSH
109744: EMPTY
109745: LIST
109746: LIST
109747: PUSH
109748: LD_INT 33
109750: PUSH
109751: LD_INT 3
109753: PUSH
109754: EMPTY
109755: LIST
109756: LIST
109757: PUSH
109758: EMPTY
109759: LIST
109760: LIST
109761: LIST
109762: PPUSH
109763: CALL_OW 69
109767: ST_TO_ADDR
// if not tmp then
109768: LD_VAR 0 1
109772: NOT
109773: IFFALSE 109777
// exit ;
109775: GO 109803
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
109777: LD_VAR 0 1
109781: PUSH
109782: LD_INT 1
109784: PPUSH
109785: LD_VAR 0 1
109789: PPUSH
109790: CALL_OW 12
109794: ARRAY
109795: PPUSH
109796: LD_INT 1
109798: PPUSH
109799: CALL_OW 234
// end ;
109803: PPOPN 1
109805: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
109806: LD_EXP 79
109810: IFFALSE 109818
109812: PUSH
109813: LD_EXP 121
109817: AND
109818: IFFALSE 109959
109820: GO 109822
109822: DISABLE
109823: LD_INT 0
109825: PPUSH
109826: PPUSH
109827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
109828: LD_ADDR_VAR 0 3
109832: PUSH
109833: LD_INT 22
109835: PUSH
109836: LD_OWVAR 2
109840: PUSH
109841: EMPTY
109842: LIST
109843: LIST
109844: PUSH
109845: LD_INT 25
109847: PUSH
109848: LD_INT 1
109850: PUSH
109851: EMPTY
109852: LIST
109853: LIST
109854: PUSH
109855: EMPTY
109856: LIST
109857: LIST
109858: PPUSH
109859: CALL_OW 69
109863: ST_TO_ADDR
// if not tmp then
109864: LD_VAR 0 3
109868: NOT
109869: IFFALSE 109873
// exit ;
109871: GO 109959
// un := tmp [ rand ( 1 , tmp ) ] ;
109873: LD_ADDR_VAR 0 2
109877: PUSH
109878: LD_VAR 0 3
109882: PUSH
109883: LD_INT 1
109885: PPUSH
109886: LD_VAR 0 3
109890: PPUSH
109891: CALL_OW 12
109895: ARRAY
109896: ST_TO_ADDR
// if Crawls ( un ) then
109897: LD_VAR 0 2
109901: PPUSH
109902: CALL_OW 318
109906: IFFALSE 109917
// ComWalk ( un ) ;
109908: LD_VAR 0 2
109912: PPUSH
109913: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
109917: LD_VAR 0 2
109921: PPUSH
109922: LD_INT 9
109924: PPUSH
109925: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
109929: LD_INT 28
109931: PPUSH
109932: LD_OWVAR 2
109936: PPUSH
109937: LD_INT 2
109939: PPUSH
109940: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
109944: LD_INT 29
109946: PPUSH
109947: LD_OWVAR 2
109951: PPUSH
109952: LD_INT 2
109954: PPUSH
109955: CALL_OW 322
// end ;
109959: PPOPN 3
109961: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
109962: LD_EXP 79
109966: IFFALSE 109974
109968: PUSH
109969: LD_EXP 122
109973: AND
109974: IFFALSE 110085
109976: GO 109978
109978: DISABLE
109979: LD_INT 0
109981: PPUSH
109982: PPUSH
109983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
109984: LD_ADDR_VAR 0 3
109988: PUSH
109989: LD_INT 22
109991: PUSH
109992: LD_OWVAR 2
109996: PUSH
109997: EMPTY
109998: LIST
109999: LIST
110000: PUSH
110001: LD_INT 25
110003: PUSH
110004: LD_INT 1
110006: PUSH
110007: EMPTY
110008: LIST
110009: LIST
110010: PUSH
110011: EMPTY
110012: LIST
110013: LIST
110014: PPUSH
110015: CALL_OW 69
110019: ST_TO_ADDR
// if not tmp then
110020: LD_VAR 0 3
110024: NOT
110025: IFFALSE 110029
// exit ;
110027: GO 110085
// un := tmp [ rand ( 1 , tmp ) ] ;
110029: LD_ADDR_VAR 0 2
110033: PUSH
110034: LD_VAR 0 3
110038: PUSH
110039: LD_INT 1
110041: PPUSH
110042: LD_VAR 0 3
110046: PPUSH
110047: CALL_OW 12
110051: ARRAY
110052: ST_TO_ADDR
// if Crawls ( un ) then
110053: LD_VAR 0 2
110057: PPUSH
110058: CALL_OW 318
110062: IFFALSE 110073
// ComWalk ( un ) ;
110064: LD_VAR 0 2
110068: PPUSH
110069: CALL_OW 138
// SetClass ( un , class_mortar ) ;
110073: LD_VAR 0 2
110077: PPUSH
110078: LD_INT 8
110080: PPUSH
110081: CALL_OW 336
// end ;
110085: PPOPN 3
110087: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
110088: LD_EXP 79
110092: IFFALSE 110100
110094: PUSH
110095: LD_EXP 123
110099: AND
110100: IFFALSE 110244
110102: GO 110104
110104: DISABLE
110105: LD_INT 0
110107: PPUSH
110108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
110109: LD_ADDR_VAR 0 2
110113: PUSH
110114: LD_INT 22
110116: PUSH
110117: LD_OWVAR 2
110121: PUSH
110122: EMPTY
110123: LIST
110124: LIST
110125: PUSH
110126: LD_INT 21
110128: PUSH
110129: LD_INT 2
110131: PUSH
110132: EMPTY
110133: LIST
110134: LIST
110135: PUSH
110136: LD_INT 2
110138: PUSH
110139: LD_INT 34
110141: PUSH
110142: LD_INT 12
110144: PUSH
110145: EMPTY
110146: LIST
110147: LIST
110148: PUSH
110149: LD_INT 34
110151: PUSH
110152: LD_INT 51
110154: PUSH
110155: EMPTY
110156: LIST
110157: LIST
110158: PUSH
110159: LD_INT 34
110161: PUSH
110162: LD_INT 32
110164: PUSH
110165: EMPTY
110166: LIST
110167: LIST
110168: PUSH
110169: EMPTY
110170: LIST
110171: LIST
110172: LIST
110173: LIST
110174: PUSH
110175: EMPTY
110176: LIST
110177: LIST
110178: LIST
110179: PPUSH
110180: CALL_OW 69
110184: ST_TO_ADDR
// if not tmp then
110185: LD_VAR 0 2
110189: NOT
110190: IFFALSE 110194
// exit ;
110192: GO 110244
// for i in tmp do
110194: LD_ADDR_VAR 0 1
110198: PUSH
110199: LD_VAR 0 2
110203: PUSH
110204: FOR_IN
110205: IFFALSE 110242
// if GetCargo ( i , mat_artifact ) = 0 then
110207: LD_VAR 0 1
110211: PPUSH
110212: LD_INT 4
110214: PPUSH
110215: CALL_OW 289
110219: PUSH
110220: LD_INT 0
110222: EQUAL
110223: IFFALSE 110240
// SetCargo ( i , mat_siberit , 100 ) ;
110225: LD_VAR 0 1
110229: PPUSH
110230: LD_INT 3
110232: PPUSH
110233: LD_INT 100
110235: PPUSH
110236: CALL_OW 290
110240: GO 110204
110242: POP
110243: POP
// end ;
110244: PPOPN 2
110246: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
110247: LD_EXP 79
110251: IFFALSE 110259
110253: PUSH
110254: LD_EXP 124
110258: AND
110259: IFFALSE 110442
110261: GO 110263
110263: DISABLE
110264: LD_INT 0
110266: PPUSH
110267: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
110268: LD_ADDR_VAR 0 2
110272: PUSH
110273: LD_INT 22
110275: PUSH
110276: LD_OWVAR 2
110280: PUSH
110281: EMPTY
110282: LIST
110283: LIST
110284: PPUSH
110285: CALL_OW 69
110289: ST_TO_ADDR
// if not tmp then
110290: LD_VAR 0 2
110294: NOT
110295: IFFALSE 110299
// exit ;
110297: GO 110442
// for i := 1 to 2 do
110299: LD_ADDR_VAR 0 1
110303: PUSH
110304: DOUBLE
110305: LD_INT 1
110307: DEC
110308: ST_TO_ADDR
110309: LD_INT 2
110311: PUSH
110312: FOR_TO
110313: IFFALSE 110440
// begin uc_side := your_side ;
110315: LD_ADDR_OWVAR 20
110319: PUSH
110320: LD_OWVAR 2
110324: ST_TO_ADDR
// uc_nation := nation_american ;
110325: LD_ADDR_OWVAR 21
110329: PUSH
110330: LD_INT 1
110332: ST_TO_ADDR
// vc_chassis := us_morphling ;
110333: LD_ADDR_OWVAR 37
110337: PUSH
110338: LD_INT 5
110340: ST_TO_ADDR
// vc_engine := engine_siberite ;
110341: LD_ADDR_OWVAR 39
110345: PUSH
110346: LD_INT 3
110348: ST_TO_ADDR
// vc_control := control_computer ;
110349: LD_ADDR_OWVAR 38
110353: PUSH
110354: LD_INT 3
110356: ST_TO_ADDR
// vc_weapon := us_double_laser ;
110357: LD_ADDR_OWVAR 40
110361: PUSH
110362: LD_INT 10
110364: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
110365: LD_VAR 0 2
110369: PUSH
110370: LD_INT 1
110372: ARRAY
110373: PPUSH
110374: CALL_OW 310
110378: NOT
110379: IFFALSE 110426
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
110381: CALL_OW 45
110385: PPUSH
110386: LD_VAR 0 2
110390: PUSH
110391: LD_INT 1
110393: ARRAY
110394: PPUSH
110395: CALL_OW 250
110399: PPUSH
110400: LD_VAR 0 2
110404: PUSH
110405: LD_INT 1
110407: ARRAY
110408: PPUSH
110409: CALL_OW 251
110413: PPUSH
110414: LD_INT 12
110416: PPUSH
110417: LD_INT 1
110419: PPUSH
110420: CALL_OW 50
110424: GO 110438
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
110426: CALL_OW 45
110430: PPUSH
110431: LD_INT 1
110433: PPUSH
110434: CALL_OW 51
// end ;
110438: GO 110312
110440: POP
110441: POP
// end ;
110442: PPOPN 2
110444: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
110445: LD_EXP 79
110449: IFFALSE 110457
110451: PUSH
110452: LD_EXP 125
110456: AND
110457: IFFALSE 110679
110459: GO 110461
110461: DISABLE
110462: LD_INT 0
110464: PPUSH
110465: PPUSH
110466: PPUSH
110467: PPUSH
110468: PPUSH
110469: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
110470: LD_ADDR_VAR 0 6
110474: PUSH
110475: LD_INT 22
110477: PUSH
110478: LD_OWVAR 2
110482: PUSH
110483: EMPTY
110484: LIST
110485: LIST
110486: PUSH
110487: LD_INT 21
110489: PUSH
110490: LD_INT 1
110492: PUSH
110493: EMPTY
110494: LIST
110495: LIST
110496: PUSH
110497: LD_INT 3
110499: PUSH
110500: LD_INT 23
110502: PUSH
110503: LD_INT 0
110505: PUSH
110506: EMPTY
110507: LIST
110508: LIST
110509: PUSH
110510: EMPTY
110511: LIST
110512: LIST
110513: PUSH
110514: EMPTY
110515: LIST
110516: LIST
110517: LIST
110518: PPUSH
110519: CALL_OW 69
110523: ST_TO_ADDR
// if not tmp then
110524: LD_VAR 0 6
110528: NOT
110529: IFFALSE 110533
// exit ;
110531: GO 110679
// s1 := rand ( 1 , 4 ) ;
110533: LD_ADDR_VAR 0 2
110537: PUSH
110538: LD_INT 1
110540: PPUSH
110541: LD_INT 4
110543: PPUSH
110544: CALL_OW 12
110548: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
110549: LD_ADDR_VAR 0 4
110553: PUSH
110554: LD_VAR 0 6
110558: PUSH
110559: LD_INT 1
110561: ARRAY
110562: PPUSH
110563: LD_VAR 0 2
110567: PPUSH
110568: CALL_OW 259
110572: ST_TO_ADDR
// if s1 = 1 then
110573: LD_VAR 0 2
110577: PUSH
110578: LD_INT 1
110580: EQUAL
110581: IFFALSE 110601
// s2 := rand ( 2 , 4 ) else
110583: LD_ADDR_VAR 0 3
110587: PUSH
110588: LD_INT 2
110590: PPUSH
110591: LD_INT 4
110593: PPUSH
110594: CALL_OW 12
110598: ST_TO_ADDR
110599: GO 110609
// s2 := 1 ;
110601: LD_ADDR_VAR 0 3
110605: PUSH
110606: LD_INT 1
110608: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
110609: LD_ADDR_VAR 0 5
110613: PUSH
110614: LD_VAR 0 6
110618: PUSH
110619: LD_INT 1
110621: ARRAY
110622: PPUSH
110623: LD_VAR 0 3
110627: PPUSH
110628: CALL_OW 259
110632: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
110633: LD_VAR 0 6
110637: PUSH
110638: LD_INT 1
110640: ARRAY
110641: PPUSH
110642: LD_VAR 0 2
110646: PPUSH
110647: LD_VAR 0 5
110651: PPUSH
110652: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
110656: LD_VAR 0 6
110660: PUSH
110661: LD_INT 1
110663: ARRAY
110664: PPUSH
110665: LD_VAR 0 3
110669: PPUSH
110670: LD_VAR 0 4
110674: PPUSH
110675: CALL_OW 237
// end ;
110679: PPOPN 6
110681: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
110682: LD_EXP 79
110686: IFFALSE 110694
110688: PUSH
110689: LD_EXP 126
110693: AND
110694: IFFALSE 110773
110696: GO 110698
110698: DISABLE
110699: LD_INT 0
110701: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
110702: LD_ADDR_VAR 0 1
110706: PUSH
110707: LD_INT 22
110709: PUSH
110710: LD_OWVAR 2
110714: PUSH
110715: EMPTY
110716: LIST
110717: LIST
110718: PUSH
110719: LD_INT 30
110721: PUSH
110722: LD_INT 3
110724: PUSH
110725: EMPTY
110726: LIST
110727: LIST
110728: PUSH
110729: EMPTY
110730: LIST
110731: LIST
110732: PPUSH
110733: CALL_OW 69
110737: ST_TO_ADDR
// if not tmp then
110738: LD_VAR 0 1
110742: NOT
110743: IFFALSE 110747
// exit ;
110745: GO 110773
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
110747: LD_VAR 0 1
110751: PUSH
110752: LD_INT 1
110754: PPUSH
110755: LD_VAR 0 1
110759: PPUSH
110760: CALL_OW 12
110764: ARRAY
110765: PPUSH
110766: LD_INT 1
110768: PPUSH
110769: CALL_OW 234
// end ;
110773: PPOPN 1
110775: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
110776: LD_EXP 79
110780: IFFALSE 110788
110782: PUSH
110783: LD_EXP 127
110787: AND
110788: IFFALSE 110900
110790: GO 110792
110792: DISABLE
110793: LD_INT 0
110795: PPUSH
110796: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
110797: LD_ADDR_VAR 0 2
110801: PUSH
110802: LD_INT 22
110804: PUSH
110805: LD_OWVAR 2
110809: PUSH
110810: EMPTY
110811: LIST
110812: LIST
110813: PUSH
110814: LD_INT 2
110816: PUSH
110817: LD_INT 30
110819: PUSH
110820: LD_INT 27
110822: PUSH
110823: EMPTY
110824: LIST
110825: LIST
110826: PUSH
110827: LD_INT 30
110829: PUSH
110830: LD_INT 26
110832: PUSH
110833: EMPTY
110834: LIST
110835: LIST
110836: PUSH
110837: LD_INT 30
110839: PUSH
110840: LD_INT 28
110842: PUSH
110843: EMPTY
110844: LIST
110845: LIST
110846: PUSH
110847: EMPTY
110848: LIST
110849: LIST
110850: LIST
110851: LIST
110852: PUSH
110853: EMPTY
110854: LIST
110855: LIST
110856: PPUSH
110857: CALL_OW 69
110861: ST_TO_ADDR
// if not tmp then
110862: LD_VAR 0 2
110866: NOT
110867: IFFALSE 110871
// exit ;
110869: GO 110900
// for i in tmp do
110871: LD_ADDR_VAR 0 1
110875: PUSH
110876: LD_VAR 0 2
110880: PUSH
110881: FOR_IN
110882: IFFALSE 110898
// SetLives ( i , 1 ) ;
110884: LD_VAR 0 1
110888: PPUSH
110889: LD_INT 1
110891: PPUSH
110892: CALL_OW 234
110896: GO 110881
110898: POP
110899: POP
// end ;
110900: PPOPN 2
110902: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
110903: LD_EXP 79
110907: IFFALSE 110915
110909: PUSH
110910: LD_EXP 128
110914: AND
110915: IFFALSE 111202
110917: GO 110919
110919: DISABLE
110920: LD_INT 0
110922: PPUSH
110923: PPUSH
110924: PPUSH
// begin i := rand ( 1 , 7 ) ;
110925: LD_ADDR_VAR 0 1
110929: PUSH
110930: LD_INT 1
110932: PPUSH
110933: LD_INT 7
110935: PPUSH
110936: CALL_OW 12
110940: ST_TO_ADDR
// case i of 1 :
110941: LD_VAR 0 1
110945: PUSH
110946: LD_INT 1
110948: DOUBLE
110949: EQUAL
110950: IFTRUE 110954
110952: GO 110964
110954: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
110955: LD_STRING earthquake(getX(game), 0, 32)
110957: PPUSH
110958: CALL_OW 559
110962: GO 111202
110964: LD_INT 2
110966: DOUBLE
110967: EQUAL
110968: IFTRUE 110972
110970: GO 110986
110972: POP
// begin ToLua ( displayStucuk(); ) ;
110973: LD_STRING displayStucuk();
110975: PPUSH
110976: CALL_OW 559
// ResetFog ;
110980: CALL_OW 335
// end ; 3 :
110984: GO 111202
110986: LD_INT 3
110988: DOUBLE
110989: EQUAL
110990: IFTRUE 110994
110992: GO 111098
110994: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
110995: LD_ADDR_VAR 0 2
110999: PUSH
111000: LD_INT 22
111002: PUSH
111003: LD_OWVAR 2
111007: PUSH
111008: EMPTY
111009: LIST
111010: LIST
111011: PUSH
111012: LD_INT 25
111014: PUSH
111015: LD_INT 1
111017: PUSH
111018: EMPTY
111019: LIST
111020: LIST
111021: PUSH
111022: EMPTY
111023: LIST
111024: LIST
111025: PPUSH
111026: CALL_OW 69
111030: ST_TO_ADDR
// if not tmp then
111031: LD_VAR 0 2
111035: NOT
111036: IFFALSE 111040
// exit ;
111038: GO 111202
// un := tmp [ rand ( 1 , tmp ) ] ;
111040: LD_ADDR_VAR 0 3
111044: PUSH
111045: LD_VAR 0 2
111049: PUSH
111050: LD_INT 1
111052: PPUSH
111053: LD_VAR 0 2
111057: PPUSH
111058: CALL_OW 12
111062: ARRAY
111063: ST_TO_ADDR
// if Crawls ( un ) then
111064: LD_VAR 0 3
111068: PPUSH
111069: CALL_OW 318
111073: IFFALSE 111084
// ComWalk ( un ) ;
111075: LD_VAR 0 3
111079: PPUSH
111080: CALL_OW 138
// SetClass ( un , class_mortar ) ;
111084: LD_VAR 0 3
111088: PPUSH
111089: LD_INT 8
111091: PPUSH
111092: CALL_OW 336
// end ; 4 :
111096: GO 111202
111098: LD_INT 4
111100: DOUBLE
111101: EQUAL
111102: IFTRUE 111106
111104: GO 111180
111106: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
111107: LD_ADDR_VAR 0 2
111111: PUSH
111112: LD_INT 22
111114: PUSH
111115: LD_OWVAR 2
111119: PUSH
111120: EMPTY
111121: LIST
111122: LIST
111123: PUSH
111124: LD_INT 30
111126: PUSH
111127: LD_INT 29
111129: PUSH
111130: EMPTY
111131: LIST
111132: LIST
111133: PUSH
111134: EMPTY
111135: LIST
111136: LIST
111137: PPUSH
111138: CALL_OW 69
111142: ST_TO_ADDR
// if not tmp then
111143: LD_VAR 0 2
111147: NOT
111148: IFFALSE 111152
// exit ;
111150: GO 111202
// CenterNowOnUnits ( tmp [ 1 ] ) ;
111152: LD_VAR 0 2
111156: PUSH
111157: LD_INT 1
111159: ARRAY
111160: PPUSH
111161: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
111165: LD_VAR 0 2
111169: PUSH
111170: LD_INT 1
111172: ARRAY
111173: PPUSH
111174: CALL_OW 65
// end ; 5 .. 7 :
111178: GO 111202
111180: LD_INT 5
111182: DOUBLE
111183: GREATEREQUAL
111184: IFFALSE 111192
111186: LD_INT 7
111188: DOUBLE
111189: LESSEQUAL
111190: IFTRUE 111194
111192: GO 111201
111194: POP
// StreamSibBomb ; end ;
111195: CALL 107383 0 0
111199: GO 111202
111201: POP
// end ;
111202: PPOPN 3
111204: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
111205: LD_EXP 79
111209: IFFALSE 111217
111211: PUSH
111212: LD_EXP 129
111216: AND
111217: IFFALSE 111373
111219: GO 111221
111221: DISABLE
111222: LD_INT 0
111224: PPUSH
111225: PPUSH
111226: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
111227: LD_ADDR_VAR 0 2
111231: PUSH
111232: LD_INT 81
111234: PUSH
111235: LD_OWVAR 2
111239: PUSH
111240: EMPTY
111241: LIST
111242: LIST
111243: PUSH
111244: LD_INT 2
111246: PUSH
111247: LD_INT 21
111249: PUSH
111250: LD_INT 1
111252: PUSH
111253: EMPTY
111254: LIST
111255: LIST
111256: PUSH
111257: LD_INT 21
111259: PUSH
111260: LD_INT 2
111262: PUSH
111263: EMPTY
111264: LIST
111265: LIST
111266: PUSH
111267: EMPTY
111268: LIST
111269: LIST
111270: LIST
111271: PUSH
111272: EMPTY
111273: LIST
111274: LIST
111275: PPUSH
111276: CALL_OW 69
111280: ST_TO_ADDR
// if not tmp then
111281: LD_VAR 0 2
111285: NOT
111286: IFFALSE 111290
// exit ;
111288: GO 111373
// p := 0 ;
111290: LD_ADDR_VAR 0 3
111294: PUSH
111295: LD_INT 0
111297: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111298: LD_INT 35
111300: PPUSH
111301: CALL_OW 67
// p := p + 1 ;
111305: LD_ADDR_VAR 0 3
111309: PUSH
111310: LD_VAR 0 3
111314: PUSH
111315: LD_INT 1
111317: PLUS
111318: ST_TO_ADDR
// for i in tmp do
111319: LD_ADDR_VAR 0 1
111323: PUSH
111324: LD_VAR 0 2
111328: PUSH
111329: FOR_IN
111330: IFFALSE 111361
// if GetLives ( i ) < 1000 then
111332: LD_VAR 0 1
111336: PPUSH
111337: CALL_OW 256
111341: PUSH
111342: LD_INT 1000
111344: LESS
111345: IFFALSE 111359
// SetLives ( i , 1000 ) ;
111347: LD_VAR 0 1
111351: PPUSH
111352: LD_INT 1000
111354: PPUSH
111355: CALL_OW 234
111359: GO 111329
111361: POP
111362: POP
// until p > 20 ;
111363: LD_VAR 0 3
111367: PUSH
111368: LD_INT 20
111370: GREATER
111371: IFFALSE 111298
// end ;
111373: PPOPN 3
111375: END
// every 0 0$1 trigger StreamModeActive and sTime do
111376: LD_EXP 79
111380: IFFALSE 111388
111382: PUSH
111383: LD_EXP 130
111387: AND
111388: IFFALSE 111423
111390: GO 111392
111392: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
111393: LD_INT 28
111395: PPUSH
111396: LD_OWVAR 2
111400: PPUSH
111401: LD_INT 2
111403: PPUSH
111404: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
111408: LD_INT 30
111410: PPUSH
111411: LD_OWVAR 2
111415: PPUSH
111416: LD_INT 2
111418: PPUSH
111419: CALL_OW 322
// end ;
111423: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
111424: LD_EXP 79
111428: IFFALSE 111436
111430: PUSH
111431: LD_EXP 131
111435: AND
111436: IFFALSE 111557
111438: GO 111440
111440: DISABLE
111441: LD_INT 0
111443: PPUSH
111444: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
111445: LD_ADDR_VAR 0 2
111449: PUSH
111450: LD_INT 22
111452: PUSH
111453: LD_OWVAR 2
111457: PUSH
111458: EMPTY
111459: LIST
111460: LIST
111461: PUSH
111462: LD_INT 21
111464: PUSH
111465: LD_INT 1
111467: PUSH
111468: EMPTY
111469: LIST
111470: LIST
111471: PUSH
111472: LD_INT 3
111474: PUSH
111475: LD_INT 23
111477: PUSH
111478: LD_INT 0
111480: PUSH
111481: EMPTY
111482: LIST
111483: LIST
111484: PUSH
111485: EMPTY
111486: LIST
111487: LIST
111488: PUSH
111489: EMPTY
111490: LIST
111491: LIST
111492: LIST
111493: PPUSH
111494: CALL_OW 69
111498: ST_TO_ADDR
// if not tmp then
111499: LD_VAR 0 2
111503: NOT
111504: IFFALSE 111508
// exit ;
111506: GO 111557
// for i in tmp do
111508: LD_ADDR_VAR 0 1
111512: PUSH
111513: LD_VAR 0 2
111517: PUSH
111518: FOR_IN
111519: IFFALSE 111555
// begin if Crawls ( i ) then
111521: LD_VAR 0 1
111525: PPUSH
111526: CALL_OW 318
111530: IFFALSE 111541
// ComWalk ( i ) ;
111532: LD_VAR 0 1
111536: PPUSH
111537: CALL_OW 138
// SetClass ( i , 2 ) ;
111541: LD_VAR 0 1
111545: PPUSH
111546: LD_INT 2
111548: PPUSH
111549: CALL_OW 336
// end ;
111553: GO 111518
111555: POP
111556: POP
// end ;
111557: PPOPN 2
111559: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
111560: LD_EXP 79
111564: IFFALSE 111572
111566: PUSH
111567: LD_EXP 132
111571: AND
111572: IFFALSE 111862
111574: GO 111576
111576: DISABLE
111577: LD_INT 0
111579: PPUSH
111580: PPUSH
111581: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
111582: LD_OWVAR 2
111586: PPUSH
111587: LD_INT 9
111589: PPUSH
111590: LD_INT 1
111592: PPUSH
111593: LD_INT 1
111595: PPUSH
111596: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
111600: LD_INT 9
111602: PPUSH
111603: LD_OWVAR 2
111607: PPUSH
111608: CALL_OW 343
// uc_side := 9 ;
111612: LD_ADDR_OWVAR 20
111616: PUSH
111617: LD_INT 9
111619: ST_TO_ADDR
// uc_nation := 2 ;
111620: LD_ADDR_OWVAR 21
111624: PUSH
111625: LD_INT 2
111627: ST_TO_ADDR
// hc_name := Dark Warrior ;
111628: LD_ADDR_OWVAR 26
111632: PUSH
111633: LD_STRING Dark Warrior
111635: ST_TO_ADDR
// hc_gallery :=  ;
111636: LD_ADDR_OWVAR 33
111640: PUSH
111641: LD_STRING 
111643: ST_TO_ADDR
// hc_noskilllimit := true ;
111644: LD_ADDR_OWVAR 76
111648: PUSH
111649: LD_INT 1
111651: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
111652: LD_ADDR_OWVAR 31
111656: PUSH
111657: LD_INT 30
111659: PUSH
111660: LD_INT 30
111662: PUSH
111663: LD_INT 30
111665: PUSH
111666: LD_INT 30
111668: PUSH
111669: EMPTY
111670: LIST
111671: LIST
111672: LIST
111673: LIST
111674: ST_TO_ADDR
// un := CreateHuman ;
111675: LD_ADDR_VAR 0 3
111679: PUSH
111680: CALL_OW 44
111684: ST_TO_ADDR
// hc_noskilllimit := false ;
111685: LD_ADDR_OWVAR 76
111689: PUSH
111690: LD_INT 0
111692: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
111693: LD_VAR 0 3
111697: PPUSH
111698: LD_INT 1
111700: PPUSH
111701: CALL_OW 51
// ToLua ( playRanger() ) ;
111705: LD_STRING playRanger()
111707: PPUSH
111708: CALL_OW 559
// p := 0 ;
111712: LD_ADDR_VAR 0 2
111716: PUSH
111717: LD_INT 0
111719: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
111720: LD_INT 35
111722: PPUSH
111723: CALL_OW 67
// p := p + 1 ;
111727: LD_ADDR_VAR 0 2
111731: PUSH
111732: LD_VAR 0 2
111736: PUSH
111737: LD_INT 1
111739: PLUS
111740: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
111741: LD_VAR 0 3
111745: PPUSH
111746: CALL_OW 256
111750: PUSH
111751: LD_INT 1000
111753: LESS
111754: IFFALSE 111768
// SetLives ( un , 1000 ) ;
111756: LD_VAR 0 3
111760: PPUSH
111761: LD_INT 1000
111763: PPUSH
111764: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
111768: LD_VAR 0 3
111772: PPUSH
111773: LD_INT 81
111775: PUSH
111776: LD_OWVAR 2
111780: PUSH
111781: EMPTY
111782: LIST
111783: LIST
111784: PUSH
111785: LD_INT 91
111787: PUSH
111788: LD_VAR 0 3
111792: PUSH
111793: LD_INT 30
111795: PUSH
111796: EMPTY
111797: LIST
111798: LIST
111799: LIST
111800: PUSH
111801: EMPTY
111802: LIST
111803: LIST
111804: PPUSH
111805: CALL_OW 69
111809: PPUSH
111810: LD_VAR 0 3
111814: PPUSH
111815: CALL_OW 74
111819: PPUSH
111820: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
111824: LD_VAR 0 2
111828: PUSH
111829: LD_INT 80
111831: GREATER
111832: IFTRUE 111845
111834: PUSH
111835: LD_VAR 0 3
111839: PPUSH
111840: CALL_OW 301
111844: OR
111845: IFFALSE 111720
// if un then
111847: LD_VAR 0 3
111851: IFFALSE 111862
// RemoveUnit ( un ) ;
111853: LD_VAR 0 3
111857: PPUSH
111858: CALL_OW 64
// end ;
111862: PPOPN 3
111864: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
111865: LD_EXP 133
111869: IFFALSE 111985
111871: GO 111873
111873: DISABLE
111874: LD_INT 0
111876: PPUSH
111877: PPUSH
111878: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
111879: LD_ADDR_VAR 0 2
111883: PUSH
111884: LD_INT 81
111886: PUSH
111887: LD_OWVAR 2
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: PUSH
111896: LD_INT 21
111898: PUSH
111899: LD_INT 1
111901: PUSH
111902: EMPTY
111903: LIST
111904: LIST
111905: PUSH
111906: EMPTY
111907: LIST
111908: LIST
111909: PPUSH
111910: CALL_OW 69
111914: ST_TO_ADDR
// ToLua ( playComputer() ) ;
111915: LD_STRING playComputer()
111917: PPUSH
111918: CALL_OW 559
// if not tmp then
111922: LD_VAR 0 2
111926: NOT
111927: IFFALSE 111931
// exit ;
111929: GO 111985
// for i in tmp do
111931: LD_ADDR_VAR 0 1
111935: PUSH
111936: LD_VAR 0 2
111940: PUSH
111941: FOR_IN
111942: IFFALSE 111983
// for j := 1 to 4 do
111944: LD_ADDR_VAR 0 3
111948: PUSH
111949: DOUBLE
111950: LD_INT 1
111952: DEC
111953: ST_TO_ADDR
111954: LD_INT 4
111956: PUSH
111957: FOR_TO
111958: IFFALSE 111979
// SetSkill ( i , j , 10 ) ;
111960: LD_VAR 0 1
111964: PPUSH
111965: LD_VAR 0 3
111969: PPUSH
111970: LD_INT 10
111972: PPUSH
111973: CALL_OW 237
111977: GO 111957
111979: POP
111980: POP
111981: GO 111941
111983: POP
111984: POP
// end ;
111985: PPOPN 3
111987: END
// every 0 0$1 trigger s30 do var i , tmp ;
111988: LD_EXP 134
111992: IFFALSE 112061
111994: GO 111996
111996: DISABLE
111997: LD_INT 0
111999: PPUSH
112000: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112001: LD_ADDR_VAR 0 2
112005: PUSH
112006: LD_INT 22
112008: PUSH
112009: LD_OWVAR 2
112013: PUSH
112014: EMPTY
112015: LIST
112016: LIST
112017: PPUSH
112018: CALL_OW 69
112022: ST_TO_ADDR
// if not tmp then
112023: LD_VAR 0 2
112027: NOT
112028: IFFALSE 112032
// exit ;
112030: GO 112061
// for i in tmp do
112032: LD_ADDR_VAR 0 1
112036: PUSH
112037: LD_VAR 0 2
112041: PUSH
112042: FOR_IN
112043: IFFALSE 112059
// SetLives ( i , 300 ) ;
112045: LD_VAR 0 1
112049: PPUSH
112050: LD_INT 300
112052: PPUSH
112053: CALL_OW 234
112057: GO 112042
112059: POP
112060: POP
// end ;
112061: PPOPN 2
112063: END
// every 0 0$1 trigger s60 do var i , tmp ;
112064: LD_EXP 135
112068: IFFALSE 112137
112070: GO 112072
112072: DISABLE
112073: LD_INT 0
112075: PPUSH
112076: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
112077: LD_ADDR_VAR 0 2
112081: PUSH
112082: LD_INT 22
112084: PUSH
112085: LD_OWVAR 2
112089: PUSH
112090: EMPTY
112091: LIST
112092: LIST
112093: PPUSH
112094: CALL_OW 69
112098: ST_TO_ADDR
// if not tmp then
112099: LD_VAR 0 2
112103: NOT
112104: IFFALSE 112108
// exit ;
112106: GO 112137
// for i in tmp do
112108: LD_ADDR_VAR 0 1
112112: PUSH
112113: LD_VAR 0 2
112117: PUSH
112118: FOR_IN
112119: IFFALSE 112135
// SetLives ( i , 600 ) ;
112121: LD_VAR 0 1
112125: PPUSH
112126: LD_INT 600
112128: PPUSH
112129: CALL_OW 234
112133: GO 112118
112135: POP
112136: POP
// end ;
112137: PPOPN 2
112139: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
112140: LD_INT 0
112142: PPUSH
// case cmd of 301 :
112143: LD_VAR 0 1
112147: PUSH
112148: LD_INT 301
112150: DOUBLE
112151: EQUAL
112152: IFTRUE 112156
112154: GO 112188
112156: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
112157: LD_VAR 0 6
112161: PPUSH
112162: LD_VAR 0 7
112166: PPUSH
112167: LD_VAR 0 8
112171: PPUSH
112172: LD_VAR 0 4
112176: PPUSH
112177: LD_VAR 0 5
112181: PPUSH
112182: CALL 113401 0 5
112186: GO 112309
112188: LD_INT 302
112190: DOUBLE
112191: EQUAL
112192: IFTRUE 112196
112194: GO 112233
112196: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
112197: LD_VAR 0 6
112201: PPUSH
112202: LD_VAR 0 7
112206: PPUSH
112207: LD_VAR 0 8
112211: PPUSH
112212: LD_VAR 0 9
112216: PPUSH
112217: LD_VAR 0 4
112221: PPUSH
112222: LD_VAR 0 5
112226: PPUSH
112227: CALL 113492 0 6
112231: GO 112309
112233: LD_INT 303
112235: DOUBLE
112236: EQUAL
112237: IFTRUE 112241
112239: GO 112278
112241: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
112242: LD_VAR 0 6
112246: PPUSH
112247: LD_VAR 0 7
112251: PPUSH
112252: LD_VAR 0 8
112256: PPUSH
112257: LD_VAR 0 9
112261: PPUSH
112262: LD_VAR 0 4
112266: PPUSH
112267: LD_VAR 0 5
112271: PPUSH
112272: CALL 112314 0 6
112276: GO 112309
112278: LD_INT 304
112280: DOUBLE
112281: EQUAL
112282: IFTRUE 112286
112284: GO 112308
112286: POP
// hHackTeleport ( unit , x , y ) ; end ;
112287: LD_VAR 0 2
112291: PPUSH
112292: LD_VAR 0 4
112296: PPUSH
112297: LD_VAR 0 5
112301: PPUSH
112302: CALL 114085 0 3
112306: GO 112309
112308: POP
// end ;
112309: LD_VAR 0 12
112313: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
112314: LD_INT 0
112316: PPUSH
112317: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
112318: LD_VAR 0 1
112322: PUSH
112323: LD_INT 1
112325: LESS
112326: IFTRUE 112338
112328: PUSH
112329: LD_VAR 0 1
112333: PUSH
112334: LD_INT 3
112336: GREATER
112337: OR
112338: IFTRUE 112356
112340: PUSH
112341: LD_VAR 0 5
112345: PPUSH
112346: LD_VAR 0 6
112350: PPUSH
112351: CALL_OW 428
112355: OR
112356: IFFALSE 112360
// exit ;
112358: GO 113088
// uc_side := your_side ;
112360: LD_ADDR_OWVAR 20
112364: PUSH
112365: LD_OWVAR 2
112369: ST_TO_ADDR
// uc_nation := nation ;
112370: LD_ADDR_OWVAR 21
112374: PUSH
112375: LD_VAR 0 1
112379: ST_TO_ADDR
// bc_level = 1 ;
112380: LD_ADDR_OWVAR 43
112384: PUSH
112385: LD_INT 1
112387: ST_TO_ADDR
// case btype of 1 :
112388: LD_VAR 0 2
112392: PUSH
112393: LD_INT 1
112395: DOUBLE
112396: EQUAL
112397: IFTRUE 112401
112399: GO 112412
112401: POP
// bc_type := b_depot ; 2 :
112402: LD_ADDR_OWVAR 42
112406: PUSH
112407: LD_INT 0
112409: ST_TO_ADDR
112410: GO 113032
112412: LD_INT 2
112414: DOUBLE
112415: EQUAL
112416: IFTRUE 112420
112418: GO 112431
112420: POP
// bc_type := b_warehouse ; 3 :
112421: LD_ADDR_OWVAR 42
112425: PUSH
112426: LD_INT 1
112428: ST_TO_ADDR
112429: GO 113032
112431: LD_INT 3
112433: DOUBLE
112434: EQUAL
112435: IFTRUE 112439
112437: GO 112450
112439: POP
// bc_type := b_lab ; 4 .. 9 :
112440: LD_ADDR_OWVAR 42
112444: PUSH
112445: LD_INT 6
112447: ST_TO_ADDR
112448: GO 113032
112450: LD_INT 4
112452: DOUBLE
112453: GREATEREQUAL
112454: IFFALSE 112462
112456: LD_INT 9
112458: DOUBLE
112459: LESSEQUAL
112460: IFTRUE 112464
112462: GO 112524
112464: POP
// begin bc_type := b_lab_half ;
112465: LD_ADDR_OWVAR 42
112469: PUSH
112470: LD_INT 7
112472: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
112473: LD_ADDR_OWVAR 44
112477: PUSH
112478: LD_INT 10
112480: PUSH
112481: LD_INT 11
112483: PUSH
112484: LD_INT 12
112486: PUSH
112487: LD_INT 15
112489: PUSH
112490: LD_INT 14
112492: PUSH
112493: LD_INT 13
112495: PUSH
112496: EMPTY
112497: LIST
112498: LIST
112499: LIST
112500: LIST
112501: LIST
112502: LIST
112503: PUSH
112504: LD_VAR 0 2
112508: PUSH
112509: LD_INT 3
112511: MINUS
112512: ARRAY
112513: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
112514: LD_ADDR_OWVAR 45
112518: PUSH
112519: LD_INT 9
112521: ST_TO_ADDR
// end ; 10 .. 13 :
112522: GO 113032
112524: LD_INT 10
112526: DOUBLE
112527: GREATEREQUAL
112528: IFFALSE 112536
112530: LD_INT 13
112532: DOUBLE
112533: LESSEQUAL
112534: IFTRUE 112538
112536: GO 112615
112538: POP
// begin bc_type := b_lab_full ;
112539: LD_ADDR_OWVAR 42
112543: PUSH
112544: LD_INT 8
112546: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
112547: LD_ADDR_OWVAR 44
112551: PUSH
112552: LD_INT 10
112554: PUSH
112555: LD_INT 12
112557: PUSH
112558: LD_INT 14
112560: PUSH
112561: LD_INT 13
112563: PUSH
112564: EMPTY
112565: LIST
112566: LIST
112567: LIST
112568: LIST
112569: PUSH
112570: LD_VAR 0 2
112574: PUSH
112575: LD_INT 9
112577: MINUS
112578: ARRAY
112579: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
112580: LD_ADDR_OWVAR 45
112584: PUSH
112585: LD_INT 11
112587: PUSH
112588: LD_INT 15
112590: PUSH
112591: LD_INT 12
112593: PUSH
112594: LD_INT 15
112596: PUSH
112597: EMPTY
112598: LIST
112599: LIST
112600: LIST
112601: LIST
112602: PUSH
112603: LD_VAR 0 2
112607: PUSH
112608: LD_INT 9
112610: MINUS
112611: ARRAY
112612: ST_TO_ADDR
// end ; 14 :
112613: GO 113032
112615: LD_INT 14
112617: DOUBLE
112618: EQUAL
112619: IFTRUE 112623
112621: GO 112634
112623: POP
// bc_type := b_workshop ; 15 :
112624: LD_ADDR_OWVAR 42
112628: PUSH
112629: LD_INT 2
112631: ST_TO_ADDR
112632: GO 113032
112634: LD_INT 15
112636: DOUBLE
112637: EQUAL
112638: IFTRUE 112642
112640: GO 112653
112642: POP
// bc_type := b_factory ; 16 :
112643: LD_ADDR_OWVAR 42
112647: PUSH
112648: LD_INT 3
112650: ST_TO_ADDR
112651: GO 113032
112653: LD_INT 16
112655: DOUBLE
112656: EQUAL
112657: IFTRUE 112661
112659: GO 112672
112661: POP
// bc_type := b_ext_gun ; 17 :
112662: LD_ADDR_OWVAR 42
112666: PUSH
112667: LD_INT 17
112669: ST_TO_ADDR
112670: GO 113032
112672: LD_INT 17
112674: DOUBLE
112675: EQUAL
112676: IFTRUE 112680
112678: GO 112708
112680: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
112681: LD_ADDR_OWVAR 42
112685: PUSH
112686: LD_INT 19
112688: PUSH
112689: LD_INT 23
112691: PUSH
112692: LD_INT 19
112694: PUSH
112695: EMPTY
112696: LIST
112697: LIST
112698: LIST
112699: PUSH
112700: LD_VAR 0 1
112704: ARRAY
112705: ST_TO_ADDR
112706: GO 113032
112708: LD_INT 18
112710: DOUBLE
112711: EQUAL
112712: IFTRUE 112716
112714: GO 112727
112716: POP
// bc_type := b_ext_radar ; 19 :
112717: LD_ADDR_OWVAR 42
112721: PUSH
112722: LD_INT 20
112724: ST_TO_ADDR
112725: GO 113032
112727: LD_INT 19
112729: DOUBLE
112730: EQUAL
112731: IFTRUE 112735
112733: GO 112746
112735: POP
// bc_type := b_ext_radio ; 20 :
112736: LD_ADDR_OWVAR 42
112740: PUSH
112741: LD_INT 22
112743: ST_TO_ADDR
112744: GO 113032
112746: LD_INT 20
112748: DOUBLE
112749: EQUAL
112750: IFTRUE 112754
112752: GO 112765
112754: POP
// bc_type := b_ext_siberium ; 21 :
112755: LD_ADDR_OWVAR 42
112759: PUSH
112760: LD_INT 21
112762: ST_TO_ADDR
112763: GO 113032
112765: LD_INT 21
112767: DOUBLE
112768: EQUAL
112769: IFTRUE 112773
112771: GO 112784
112773: POP
// bc_type := b_ext_computer ; 22 :
112774: LD_ADDR_OWVAR 42
112778: PUSH
112779: LD_INT 24
112781: ST_TO_ADDR
112782: GO 113032
112784: LD_INT 22
112786: DOUBLE
112787: EQUAL
112788: IFTRUE 112792
112790: GO 112803
112792: POP
// bc_type := b_ext_track ; 23 :
112793: LD_ADDR_OWVAR 42
112797: PUSH
112798: LD_INT 16
112800: ST_TO_ADDR
112801: GO 113032
112803: LD_INT 23
112805: DOUBLE
112806: EQUAL
112807: IFTRUE 112811
112809: GO 112822
112811: POP
// bc_type := b_ext_laser ; 24 :
112812: LD_ADDR_OWVAR 42
112816: PUSH
112817: LD_INT 25
112819: ST_TO_ADDR
112820: GO 113032
112822: LD_INT 24
112824: DOUBLE
112825: EQUAL
112826: IFTRUE 112830
112828: GO 112841
112830: POP
// bc_type := b_control_tower ; 25 :
112831: LD_ADDR_OWVAR 42
112835: PUSH
112836: LD_INT 36
112838: ST_TO_ADDR
112839: GO 113032
112841: LD_INT 25
112843: DOUBLE
112844: EQUAL
112845: IFTRUE 112849
112847: GO 112860
112849: POP
// bc_type := b_breastwork ; 26 :
112850: LD_ADDR_OWVAR 42
112854: PUSH
112855: LD_INT 31
112857: ST_TO_ADDR
112858: GO 113032
112860: LD_INT 26
112862: DOUBLE
112863: EQUAL
112864: IFTRUE 112868
112866: GO 112879
112868: POP
// bc_type := b_bunker ; 27 :
112869: LD_ADDR_OWVAR 42
112873: PUSH
112874: LD_INT 32
112876: ST_TO_ADDR
112877: GO 113032
112879: LD_INT 27
112881: DOUBLE
112882: EQUAL
112883: IFTRUE 112887
112885: GO 112898
112887: POP
// bc_type := b_turret ; 28 :
112888: LD_ADDR_OWVAR 42
112892: PUSH
112893: LD_INT 33
112895: ST_TO_ADDR
112896: GO 113032
112898: LD_INT 28
112900: DOUBLE
112901: EQUAL
112902: IFTRUE 112906
112904: GO 112917
112906: POP
// bc_type := b_armoury ; 29 :
112907: LD_ADDR_OWVAR 42
112911: PUSH
112912: LD_INT 4
112914: ST_TO_ADDR
112915: GO 113032
112917: LD_INT 29
112919: DOUBLE
112920: EQUAL
112921: IFTRUE 112925
112923: GO 112936
112925: POP
// bc_type := b_barracks ; 30 :
112926: LD_ADDR_OWVAR 42
112930: PUSH
112931: LD_INT 5
112933: ST_TO_ADDR
112934: GO 113032
112936: LD_INT 30
112938: DOUBLE
112939: EQUAL
112940: IFTRUE 112944
112942: GO 112955
112944: POP
// bc_type := b_solar_power ; 31 :
112945: LD_ADDR_OWVAR 42
112949: PUSH
112950: LD_INT 27
112952: ST_TO_ADDR
112953: GO 113032
112955: LD_INT 31
112957: DOUBLE
112958: EQUAL
112959: IFTRUE 112963
112961: GO 112974
112963: POP
// bc_type := b_oil_power ; 32 :
112964: LD_ADDR_OWVAR 42
112968: PUSH
112969: LD_INT 26
112971: ST_TO_ADDR
112972: GO 113032
112974: LD_INT 32
112976: DOUBLE
112977: EQUAL
112978: IFTRUE 112982
112980: GO 112993
112982: POP
// bc_type := b_siberite_power ; 33 :
112983: LD_ADDR_OWVAR 42
112987: PUSH
112988: LD_INT 28
112990: ST_TO_ADDR
112991: GO 113032
112993: LD_INT 33
112995: DOUBLE
112996: EQUAL
112997: IFTRUE 113001
112999: GO 113012
113001: POP
// bc_type := b_oil_mine ; 34 :
113002: LD_ADDR_OWVAR 42
113006: PUSH
113007: LD_INT 29
113009: ST_TO_ADDR
113010: GO 113032
113012: LD_INT 34
113014: DOUBLE
113015: EQUAL
113016: IFTRUE 113020
113018: GO 113031
113020: POP
// bc_type := b_siberite_mine ; end ;
113021: LD_ADDR_OWVAR 42
113025: PUSH
113026: LD_INT 30
113028: ST_TO_ADDR
113029: GO 113032
113031: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
113032: LD_ADDR_VAR 0 8
113036: PUSH
113037: LD_VAR 0 5
113041: PPUSH
113042: LD_VAR 0 6
113046: PPUSH
113047: LD_VAR 0 3
113051: PPUSH
113052: CALL_OW 47
113056: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
113057: LD_OWVAR 42
113061: PUSH
113062: LD_INT 32
113064: PUSH
113065: LD_INT 33
113067: PUSH
113068: EMPTY
113069: LIST
113070: LIST
113071: IN
113072: IFFALSE 113088
// PlaceWeaponTurret ( b , weapon ) ;
113074: LD_VAR 0 8
113078: PPUSH
113079: LD_VAR 0 4
113083: PPUSH
113084: CALL_OW 431
// end ;
113088: LD_VAR 0 7
113092: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
113093: LD_INT 0
113095: PPUSH
113096: PPUSH
113097: PPUSH
113098: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113099: LD_ADDR_VAR 0 4
113103: PUSH
113104: LD_INT 22
113106: PUSH
113107: LD_OWVAR 2
113111: PUSH
113112: EMPTY
113113: LIST
113114: LIST
113115: PUSH
113116: LD_INT 2
113118: PUSH
113119: LD_INT 30
113121: PUSH
113122: LD_INT 0
113124: PUSH
113125: EMPTY
113126: LIST
113127: LIST
113128: PUSH
113129: LD_INT 30
113131: PUSH
113132: LD_INT 1
113134: PUSH
113135: EMPTY
113136: LIST
113137: LIST
113138: PUSH
113139: EMPTY
113140: LIST
113141: LIST
113142: LIST
113143: PUSH
113144: EMPTY
113145: LIST
113146: LIST
113147: PPUSH
113148: CALL_OW 69
113152: ST_TO_ADDR
// if not tmp then
113153: LD_VAR 0 4
113157: NOT
113158: IFFALSE 113162
// exit ;
113160: GO 113221
// for i in tmp do
113162: LD_ADDR_VAR 0 2
113166: PUSH
113167: LD_VAR 0 4
113171: PUSH
113172: FOR_IN
113173: IFFALSE 113219
// for j = 1 to 3 do
113175: LD_ADDR_VAR 0 3
113179: PUSH
113180: DOUBLE
113181: LD_INT 1
113183: DEC
113184: ST_TO_ADDR
113185: LD_INT 3
113187: PUSH
113188: FOR_TO
113189: IFFALSE 113215
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
113191: LD_VAR 0 2
113195: PPUSH
113196: CALL_OW 274
113200: PPUSH
113201: LD_VAR 0 3
113205: PPUSH
113206: LD_INT 99999
113208: PPUSH
113209: CALL_OW 277
113213: GO 113188
113215: POP
113216: POP
113217: GO 113172
113219: POP
113220: POP
// end ;
113221: LD_VAR 0 1
113225: RET
// export function hHackSetLevel10 ; var i , j ; begin
113226: LD_INT 0
113228: PPUSH
113229: PPUSH
113230: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
113231: LD_ADDR_VAR 0 2
113235: PUSH
113236: LD_INT 21
113238: PUSH
113239: LD_INT 1
113241: PUSH
113242: EMPTY
113243: LIST
113244: LIST
113245: PPUSH
113246: CALL_OW 69
113250: PUSH
113251: FOR_IN
113252: IFFALSE 113304
// if IsSelected ( i ) then
113254: LD_VAR 0 2
113258: PPUSH
113259: CALL_OW 306
113263: IFFALSE 113302
// begin for j := 1 to 4 do
113265: LD_ADDR_VAR 0 3
113269: PUSH
113270: DOUBLE
113271: LD_INT 1
113273: DEC
113274: ST_TO_ADDR
113275: LD_INT 4
113277: PUSH
113278: FOR_TO
113279: IFFALSE 113300
// SetSkill ( i , j , 10 ) ;
113281: LD_VAR 0 2
113285: PPUSH
113286: LD_VAR 0 3
113290: PPUSH
113291: LD_INT 10
113293: PPUSH
113294: CALL_OW 237
113298: GO 113278
113300: POP
113301: POP
// end ;
113302: GO 113251
113304: POP
113305: POP
// end ;
113306: LD_VAR 0 1
113310: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
113311: LD_INT 0
113313: PPUSH
113314: PPUSH
113315: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
113316: LD_ADDR_VAR 0 2
113320: PUSH
113321: LD_INT 22
113323: PUSH
113324: LD_OWVAR 2
113328: PUSH
113329: EMPTY
113330: LIST
113331: LIST
113332: PUSH
113333: LD_INT 21
113335: PUSH
113336: LD_INT 1
113338: PUSH
113339: EMPTY
113340: LIST
113341: LIST
113342: PUSH
113343: EMPTY
113344: LIST
113345: LIST
113346: PPUSH
113347: CALL_OW 69
113351: PUSH
113352: FOR_IN
113353: IFFALSE 113394
// begin for j := 1 to 4 do
113355: LD_ADDR_VAR 0 3
113359: PUSH
113360: DOUBLE
113361: LD_INT 1
113363: DEC
113364: ST_TO_ADDR
113365: LD_INT 4
113367: PUSH
113368: FOR_TO
113369: IFFALSE 113390
// SetSkill ( i , j , 10 ) ;
113371: LD_VAR 0 2
113375: PPUSH
113376: LD_VAR 0 3
113380: PPUSH
113381: LD_INT 10
113383: PPUSH
113384: CALL_OW 237
113388: GO 113368
113390: POP
113391: POP
// end ;
113392: GO 113352
113394: POP
113395: POP
// end ;
113396: LD_VAR 0 1
113400: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
113401: LD_INT 0
113403: PPUSH
// uc_side := your_side ;
113404: LD_ADDR_OWVAR 20
113408: PUSH
113409: LD_OWVAR 2
113413: ST_TO_ADDR
// uc_nation := nation ;
113414: LD_ADDR_OWVAR 21
113418: PUSH
113419: LD_VAR 0 1
113423: ST_TO_ADDR
// InitHc ;
113424: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
113428: LD_INT 0
113430: PPUSH
113431: LD_VAR 0 2
113435: PPUSH
113436: LD_VAR 0 3
113440: PPUSH
113441: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
113445: LD_VAR 0 4
113449: PPUSH
113450: LD_VAR 0 5
113454: PPUSH
113455: CALL_OW 428
113459: PUSH
113460: LD_INT 0
113462: EQUAL
113463: IFFALSE 113487
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
113465: CALL_OW 44
113469: PPUSH
113470: LD_VAR 0 4
113474: PPUSH
113475: LD_VAR 0 5
113479: PPUSH
113480: LD_INT 1
113482: PPUSH
113483: CALL_OW 48
// end ;
113487: LD_VAR 0 6
113491: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
113492: LD_INT 0
113494: PPUSH
113495: PPUSH
// uc_side := your_side ;
113496: LD_ADDR_OWVAR 20
113500: PUSH
113501: LD_OWVAR 2
113505: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
113506: LD_VAR 0 1
113510: PUSH
113511: LD_INT 1
113513: PUSH
113514: LD_INT 2
113516: PUSH
113517: LD_INT 3
113519: PUSH
113520: LD_INT 4
113522: PUSH
113523: LD_INT 5
113525: PUSH
113526: EMPTY
113527: LIST
113528: LIST
113529: LIST
113530: LIST
113531: LIST
113532: IN
113533: IFFALSE 113545
// uc_nation := nation_american else
113535: LD_ADDR_OWVAR 21
113539: PUSH
113540: LD_INT 1
113542: ST_TO_ADDR
113543: GO 113588
// if chassis in [ 11 , 12 , 13 , 14 ] then
113545: LD_VAR 0 1
113549: PUSH
113550: LD_INT 11
113552: PUSH
113553: LD_INT 12
113555: PUSH
113556: LD_INT 13
113558: PUSH
113559: LD_INT 14
113561: PUSH
113562: EMPTY
113563: LIST
113564: LIST
113565: LIST
113566: LIST
113567: IN
113568: IFFALSE 113580
// uc_nation := nation_arabian else
113570: LD_ADDR_OWVAR 21
113574: PUSH
113575: LD_INT 2
113577: ST_TO_ADDR
113578: GO 113588
// uc_nation := nation_russian ;
113580: LD_ADDR_OWVAR 21
113584: PUSH
113585: LD_INT 3
113587: ST_TO_ADDR
// vc_chassis := chassis ;
113588: LD_ADDR_OWVAR 37
113592: PUSH
113593: LD_VAR 0 1
113597: ST_TO_ADDR
// vc_engine := engine ;
113598: LD_ADDR_OWVAR 39
113602: PUSH
113603: LD_VAR 0 2
113607: ST_TO_ADDR
// vc_control := control ;
113608: LD_ADDR_OWVAR 38
113612: PUSH
113613: LD_VAR 0 3
113617: ST_TO_ADDR
// vc_weapon := weapon ;
113618: LD_ADDR_OWVAR 40
113622: PUSH
113623: LD_VAR 0 4
113627: ST_TO_ADDR
// un := CreateVehicle ;
113628: LD_ADDR_VAR 0 8
113632: PUSH
113633: CALL_OW 45
113637: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
113638: LD_VAR 0 8
113642: PPUSH
113643: LD_INT 0
113645: PPUSH
113646: LD_INT 5
113648: PPUSH
113649: CALL_OW 12
113653: PPUSH
113654: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
113658: LD_VAR 0 8
113662: PPUSH
113663: LD_VAR 0 5
113667: PPUSH
113668: LD_VAR 0 6
113672: PPUSH
113673: LD_INT 1
113675: PPUSH
113676: CALL_OW 48
// end ;
113680: LD_VAR 0 7
113684: RET
// export hInvincible ; every 1 do
113685: GO 113687
113687: DISABLE
// hInvincible := [ ] ;
113688: LD_ADDR_EXP 136
113692: PUSH
113693: EMPTY
113694: ST_TO_ADDR
113695: END
// every 10 do var i ;
113696: GO 113698
113698: DISABLE
113699: LD_INT 0
113701: PPUSH
// begin enable ;
113702: ENABLE
// if not hInvincible then
113703: LD_EXP 136
113707: NOT
113708: IFFALSE 113712
// exit ;
113710: GO 113756
// for i in hInvincible do
113712: LD_ADDR_VAR 0 1
113716: PUSH
113717: LD_EXP 136
113721: PUSH
113722: FOR_IN
113723: IFFALSE 113754
// if GetLives ( i ) < 1000 then
113725: LD_VAR 0 1
113729: PPUSH
113730: CALL_OW 256
113734: PUSH
113735: LD_INT 1000
113737: LESS
113738: IFFALSE 113752
// SetLives ( i , 1000 ) ;
113740: LD_VAR 0 1
113744: PPUSH
113745: LD_INT 1000
113747: PPUSH
113748: CALL_OW 234
113752: GO 113722
113754: POP
113755: POP
// end ;
113756: PPOPN 1
113758: END
// export function hHackInvincible ; var i ; begin
113759: LD_INT 0
113761: PPUSH
113762: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
113763: LD_ADDR_VAR 0 2
113767: PUSH
113768: LD_INT 2
113770: PUSH
113771: LD_INT 21
113773: PUSH
113774: LD_INT 1
113776: PUSH
113777: EMPTY
113778: LIST
113779: LIST
113780: PUSH
113781: LD_INT 21
113783: PUSH
113784: LD_INT 2
113786: PUSH
113787: EMPTY
113788: LIST
113789: LIST
113790: PUSH
113791: EMPTY
113792: LIST
113793: LIST
113794: LIST
113795: PPUSH
113796: CALL_OW 69
113800: PUSH
113801: FOR_IN
113802: IFFALSE 113863
// if IsSelected ( i ) then
113804: LD_VAR 0 2
113808: PPUSH
113809: CALL_OW 306
113813: IFFALSE 113861
// begin if i in hInvincible then
113815: LD_VAR 0 2
113819: PUSH
113820: LD_EXP 136
113824: IN
113825: IFFALSE 113845
// hInvincible := hInvincible diff i else
113827: LD_ADDR_EXP 136
113831: PUSH
113832: LD_EXP 136
113836: PUSH
113837: LD_VAR 0 2
113841: DIFF
113842: ST_TO_ADDR
113843: GO 113861
// hInvincible := hInvincible union i ;
113845: LD_ADDR_EXP 136
113849: PUSH
113850: LD_EXP 136
113854: PUSH
113855: LD_VAR 0 2
113859: UNION
113860: ST_TO_ADDR
// end ;
113861: GO 113801
113863: POP
113864: POP
// end ;
113865: LD_VAR 0 1
113869: RET
// export function hHackInvisible ; var i , j ; begin
113870: LD_INT 0
113872: PPUSH
113873: PPUSH
113874: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
113875: LD_ADDR_VAR 0 2
113879: PUSH
113880: LD_INT 21
113882: PUSH
113883: LD_INT 1
113885: PUSH
113886: EMPTY
113887: LIST
113888: LIST
113889: PPUSH
113890: CALL_OW 69
113894: PUSH
113895: FOR_IN
113896: IFFALSE 113920
// if IsSelected ( i ) then
113898: LD_VAR 0 2
113902: PPUSH
113903: CALL_OW 306
113907: IFFALSE 113918
// ComForceInvisible ( i ) ;
113909: LD_VAR 0 2
113913: PPUSH
113914: CALL_OW 496
113918: GO 113895
113920: POP
113921: POP
// end ;
113922: LD_VAR 0 1
113926: RET
// export function hHackChangeYourSide ; begin
113927: LD_INT 0
113929: PPUSH
// if your_side = 8 then
113930: LD_OWVAR 2
113934: PUSH
113935: LD_INT 8
113937: EQUAL
113938: IFFALSE 113950
// your_side := 0 else
113940: LD_ADDR_OWVAR 2
113944: PUSH
113945: LD_INT 0
113947: ST_TO_ADDR
113948: GO 113964
// your_side := your_side + 1 ;
113950: LD_ADDR_OWVAR 2
113954: PUSH
113955: LD_OWVAR 2
113959: PUSH
113960: LD_INT 1
113962: PLUS
113963: ST_TO_ADDR
// end ;
113964: LD_VAR 0 1
113968: RET
// export function hHackChangeUnitSide ; var i , j ; begin
113969: LD_INT 0
113971: PPUSH
113972: PPUSH
113973: PPUSH
// for i in all_units do
113974: LD_ADDR_VAR 0 2
113978: PUSH
113979: LD_OWVAR 3
113983: PUSH
113984: FOR_IN
113985: IFFALSE 114063
// if IsSelected ( i ) then
113987: LD_VAR 0 2
113991: PPUSH
113992: CALL_OW 306
113996: IFFALSE 114061
// begin j := GetSide ( i ) ;
113998: LD_ADDR_VAR 0 3
114002: PUSH
114003: LD_VAR 0 2
114007: PPUSH
114008: CALL_OW 255
114012: ST_TO_ADDR
// if j = 8 then
114013: LD_VAR 0 3
114017: PUSH
114018: LD_INT 8
114020: EQUAL
114021: IFFALSE 114033
// j := 0 else
114023: LD_ADDR_VAR 0 3
114027: PUSH
114028: LD_INT 0
114030: ST_TO_ADDR
114031: GO 114047
// j := j + 1 ;
114033: LD_ADDR_VAR 0 3
114037: PUSH
114038: LD_VAR 0 3
114042: PUSH
114043: LD_INT 1
114045: PLUS
114046: ST_TO_ADDR
// SetSide ( i , j ) ;
114047: LD_VAR 0 2
114051: PPUSH
114052: LD_VAR 0 3
114056: PPUSH
114057: CALL_OW 235
// end ;
114061: GO 113984
114063: POP
114064: POP
// end ;
114065: LD_VAR 0 1
114069: RET
// export function hHackFog ; begin
114070: LD_INT 0
114072: PPUSH
// FogOff ( true ) ;
114073: LD_INT 1
114075: PPUSH
114076: CALL_OW 344
// end ;
114080: LD_VAR 0 1
114084: RET
// export function hHackTeleport ( unit , x , y ) ; begin
114085: LD_INT 0
114087: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
114088: LD_VAR 0 1
114092: PPUSH
114093: LD_VAR 0 2
114097: PPUSH
114098: LD_VAR 0 3
114102: PPUSH
114103: LD_INT 1
114105: PPUSH
114106: LD_INT 1
114108: PPUSH
114109: CALL_OW 483
// CenterOnXY ( x , y ) ;
114113: LD_VAR 0 2
114117: PPUSH
114118: LD_VAR 0 3
114122: PPUSH
114123: CALL_OW 84
// end ;
114127: LD_VAR 0 4
114131: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
114132: LD_INT 0
114134: PPUSH
114135: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
114136: LD_VAR 0 1
114140: NOT
114141: IFTRUE 114160
114143: PUSH
114144: LD_VAR 0 2
114148: PPUSH
114149: LD_VAR 0 3
114153: PPUSH
114154: CALL_OW 488
114158: NOT
114159: OR
114160: IFTRUE 114195
114162: PUSH
114163: LD_VAR 0 1
114167: PPUSH
114168: CALL_OW 266
114172: PUSH
114173: LD_INT 3
114175: NONEQUAL
114176: IFFALSE 114194
114178: PUSH
114179: LD_VAR 0 1
114183: PPUSH
114184: CALL_OW 247
114188: PUSH
114189: LD_INT 1
114191: EQUAL
114192: NOT
114193: AND
114194: OR
114195: IFFALSE 114199
// exit ;
114197: GO 114481
// if GetType ( factory ) = unit_human then
114199: LD_VAR 0 1
114203: PPUSH
114204: CALL_OW 247
114208: PUSH
114209: LD_INT 1
114211: EQUAL
114212: IFFALSE 114229
// factory := IsInUnit ( factory ) ;
114214: LD_ADDR_VAR 0 1
114218: PUSH
114219: LD_VAR 0 1
114223: PPUSH
114224: CALL_OW 310
114228: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
114229: LD_VAR 0 1
114233: PPUSH
114234: CALL_OW 266
114238: PUSH
114239: LD_INT 3
114241: NONEQUAL
114242: IFFALSE 114246
// exit ;
114244: GO 114481
// for i := 1 to Count ( factoryWaypoints ) do
114246: LD_ADDR_VAR 0 5
114250: PUSH
114251: DOUBLE
114252: LD_INT 1
114254: DEC
114255: ST_TO_ADDR
114256: LD_EXP 137
114260: PPUSH
114261: CALL 13371 0 1
114265: PUSH
114266: FOR_TO
114267: IFFALSE 114429
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
114269: LD_VAR 0 2
114273: PPUSH
114274: LD_VAR 0 3
114278: PPUSH
114279: CALL_OW 428
114283: PUSH
114284: LD_EXP 137
114288: PUSH
114289: LD_VAR 0 5
114293: ARRAY
114294: PUSH
114295: LD_INT 2
114297: ARRAY
114298: EQUAL
114299: IFFALSE 114331
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
114301: LD_ADDR_EXP 137
114305: PUSH
114306: LD_EXP 137
114310: PPUSH
114311: LD_VAR 0 5
114315: PPUSH
114316: CALL_OW 3
114320: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114321: CALL 114486 0 0
// exit ;
114325: POP
114326: POP
114327: GO 114481
// end else
114329: GO 114427
// if factory = factoryWaypoints [ i ] [ 2 ] then
114331: LD_VAR 0 1
114335: PUSH
114336: LD_EXP 137
114340: PUSH
114341: LD_VAR 0 5
114345: ARRAY
114346: PUSH
114347: LD_INT 2
114349: ARRAY
114350: EQUAL
114351: IFFALSE 114427
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
114353: LD_ADDR_EXP 137
114357: PUSH
114358: LD_EXP 137
114362: PPUSH
114363: LD_VAR 0 5
114367: PPUSH
114368: CALL_OW 3
114372: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
114373: LD_ADDR_EXP 137
114377: PUSH
114378: LD_EXP 137
114382: PPUSH
114383: LD_VAR 0 1
114387: PPUSH
114388: CALL_OW 255
114392: PUSH
114393: LD_VAR 0 1
114397: PUSH
114398: LD_VAR 0 2
114402: PUSH
114403: LD_VAR 0 3
114407: PUSH
114408: EMPTY
114409: LIST
114410: LIST
114411: LIST
114412: LIST
114413: PPUSH
114414: CALL 49303 0 2
114418: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114419: CALL 114486 0 0
// exit ;
114423: POP
114424: POP
114425: GO 114481
// end ; end ;
114427: GO 114266
114429: POP
114430: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
114431: LD_ADDR_EXP 137
114435: PUSH
114436: LD_EXP 137
114440: PPUSH
114441: LD_VAR 0 1
114445: PPUSH
114446: CALL_OW 255
114450: PUSH
114451: LD_VAR 0 1
114455: PUSH
114456: LD_VAR 0 2
114460: PUSH
114461: LD_VAR 0 3
114465: PUSH
114466: EMPTY
114467: LIST
114468: LIST
114469: LIST
114470: LIST
114471: PPUSH
114472: CALL 49303 0 2
114476: ST_TO_ADDR
// UpdateFactoryWaypoints ;
114477: CALL 114486 0 0
// end ;
114481: LD_VAR 0 4
114485: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
114486: LD_INT 0
114488: PPUSH
114489: PPUSH
114490: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
114491: LD_STRING resetFactoryWaypoint();
114493: PPUSH
114494: CALL_OW 559
// if factoryWaypoints then
114498: LD_EXP 137
114502: IFFALSE 114623
// begin list := factoryWaypoints ;
114504: LD_ADDR_VAR 0 3
114508: PUSH
114509: LD_EXP 137
114513: ST_TO_ADDR
// for i := 1 to list do
114514: LD_ADDR_VAR 0 2
114518: PUSH
114519: DOUBLE
114520: LD_INT 1
114522: DEC
114523: ST_TO_ADDR
114524: LD_VAR 0 3
114528: PUSH
114529: FOR_TO
114530: IFFALSE 114621
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
114532: LD_STRING setFactoryWaypointXY(
114534: PUSH
114535: LD_VAR 0 3
114539: PUSH
114540: LD_VAR 0 2
114544: ARRAY
114545: PUSH
114546: LD_INT 1
114548: ARRAY
114549: STR
114550: PUSH
114551: LD_STRING ,
114553: STR
114554: PUSH
114555: LD_VAR 0 3
114559: PUSH
114560: LD_VAR 0 2
114564: ARRAY
114565: PUSH
114566: LD_INT 2
114568: ARRAY
114569: STR
114570: PUSH
114571: LD_STRING ,
114573: STR
114574: PUSH
114575: LD_VAR 0 3
114579: PUSH
114580: LD_VAR 0 2
114584: ARRAY
114585: PUSH
114586: LD_INT 3
114588: ARRAY
114589: STR
114590: PUSH
114591: LD_STRING ,
114593: STR
114594: PUSH
114595: LD_VAR 0 3
114599: PUSH
114600: LD_VAR 0 2
114604: ARRAY
114605: PUSH
114606: LD_INT 4
114608: ARRAY
114609: STR
114610: PUSH
114611: LD_STRING )
114613: STR
114614: PPUSH
114615: CALL_OW 559
114619: GO 114529
114621: POP
114622: POP
// end ; end ;
114623: LD_VAR 0 1
114627: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
114628: LD_INT 0
114630: PPUSH
// if HexInfo ( x , y ) = warehouse then
114631: LD_VAR 0 2
114635: PPUSH
114636: LD_VAR 0 3
114640: PPUSH
114641: CALL_OW 428
114645: PUSH
114646: LD_VAR 0 1
114650: EQUAL
114651: IFFALSE 114678
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
114653: LD_ADDR_EXP 139
114657: PUSH
114658: LD_EXP 139
114662: PPUSH
114663: LD_VAR 0 1
114667: PPUSH
114668: LD_INT 0
114670: PPUSH
114671: CALL_OW 1
114675: ST_TO_ADDR
114676: GO 114729
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
114678: LD_ADDR_EXP 139
114682: PUSH
114683: LD_EXP 139
114687: PPUSH
114688: LD_VAR 0 1
114692: PPUSH
114693: LD_VAR 0 1
114697: PPUSH
114698: CALL_OW 255
114702: PUSH
114703: LD_VAR 0 1
114707: PUSH
114708: LD_VAR 0 2
114712: PUSH
114713: LD_VAR 0 3
114717: PUSH
114718: EMPTY
114719: LIST
114720: LIST
114721: LIST
114722: LIST
114723: PPUSH
114724: CALL_OW 1
114728: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
114729: CALL 114738 0 0
// end ;
114733: LD_VAR 0 4
114737: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
114738: LD_INT 0
114740: PPUSH
114741: PPUSH
114742: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
114743: LD_STRING resetWarehouseGatheringPoints();
114745: PPUSH
114746: CALL_OW 559
// if warehouseGatheringPoints then
114750: LD_EXP 139
114754: IFFALSE 114880
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
114756: LD_ADDR_VAR 0 3
114760: PUSH
114761: LD_EXP 139
114765: PPUSH
114766: CALL 53237 0 1
114770: ST_TO_ADDR
// for i := 1 to list do
114771: LD_ADDR_VAR 0 2
114775: PUSH
114776: DOUBLE
114777: LD_INT 1
114779: DEC
114780: ST_TO_ADDR
114781: LD_VAR 0 3
114785: PUSH
114786: FOR_TO
114787: IFFALSE 114878
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
114789: LD_STRING setWarehouseGatheringPointXY(
114791: PUSH
114792: LD_VAR 0 3
114796: PUSH
114797: LD_VAR 0 2
114801: ARRAY
114802: PUSH
114803: LD_INT 1
114805: ARRAY
114806: STR
114807: PUSH
114808: LD_STRING ,
114810: STR
114811: PUSH
114812: LD_VAR 0 3
114816: PUSH
114817: LD_VAR 0 2
114821: ARRAY
114822: PUSH
114823: LD_INT 2
114825: ARRAY
114826: STR
114827: PUSH
114828: LD_STRING ,
114830: STR
114831: PUSH
114832: LD_VAR 0 3
114836: PUSH
114837: LD_VAR 0 2
114841: ARRAY
114842: PUSH
114843: LD_INT 3
114845: ARRAY
114846: STR
114847: PUSH
114848: LD_STRING ,
114850: STR
114851: PUSH
114852: LD_VAR 0 3
114856: PUSH
114857: LD_VAR 0 2
114861: ARRAY
114862: PUSH
114863: LD_INT 4
114865: ARRAY
114866: STR
114867: PUSH
114868: LD_STRING )
114870: STR
114871: PPUSH
114872: CALL_OW 559
114876: GO 114786
114878: POP
114879: POP
// end ; end ;
114880: LD_VAR 0 1
114884: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
114885: LD_EXP 139
114889: IFFALSE 115584
114891: GO 114893
114893: DISABLE
114894: LD_INT 0
114896: PPUSH
114897: PPUSH
114898: PPUSH
114899: PPUSH
114900: PPUSH
114901: PPUSH
114902: PPUSH
114903: PPUSH
114904: PPUSH
// begin enable ;
114905: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
114906: LD_ADDR_VAR 0 3
114910: PUSH
114911: LD_EXP 139
114915: PPUSH
114916: CALL 53237 0 1
114920: ST_TO_ADDR
// if not list then
114921: LD_VAR 0 3
114925: NOT
114926: IFFALSE 114930
// exit ;
114928: GO 115584
// for i := 1 to list do
114930: LD_ADDR_VAR 0 1
114934: PUSH
114935: DOUBLE
114936: LD_INT 1
114938: DEC
114939: ST_TO_ADDR
114940: LD_VAR 0 3
114944: PUSH
114945: FOR_TO
114946: IFFALSE 115582
// begin depot := list [ i ] [ 2 ] ;
114948: LD_ADDR_VAR 0 8
114952: PUSH
114953: LD_VAR 0 3
114957: PUSH
114958: LD_VAR 0 1
114962: ARRAY
114963: PUSH
114964: LD_INT 2
114966: ARRAY
114967: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
114968: LD_ADDR_VAR 0 5
114972: PUSH
114973: LD_VAR 0 3
114977: PUSH
114978: LD_VAR 0 1
114982: ARRAY
114983: PUSH
114984: LD_INT 1
114986: ARRAY
114987: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
114988: LD_VAR 0 8
114992: PPUSH
114993: CALL_OW 301
114997: IFTRUE 115016
114999: PUSH
115000: LD_VAR 0 5
115004: PUSH
115005: LD_VAR 0 8
115009: PPUSH
115010: CALL_OW 255
115014: NONEQUAL
115015: OR
115016: IFFALSE 115045
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
115018: LD_ADDR_EXP 139
115022: PUSH
115023: LD_EXP 139
115027: PPUSH
115028: LD_VAR 0 8
115032: PPUSH
115033: LD_INT 0
115035: PPUSH
115036: CALL_OW 1
115040: ST_TO_ADDR
// exit ;
115041: POP
115042: POP
115043: GO 115584
// end ; x := list [ i ] [ 3 ] ;
115045: LD_ADDR_VAR 0 6
115049: PUSH
115050: LD_VAR 0 3
115054: PUSH
115055: LD_VAR 0 1
115059: ARRAY
115060: PUSH
115061: LD_INT 3
115063: ARRAY
115064: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
115065: LD_ADDR_VAR 0 7
115069: PUSH
115070: LD_VAR 0 3
115074: PUSH
115075: LD_VAR 0 1
115079: ARRAY
115080: PUSH
115081: LD_INT 4
115083: ARRAY
115084: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
115085: LD_ADDR_VAR 0 9
115089: PUSH
115090: LD_VAR 0 6
115094: PPUSH
115095: LD_VAR 0 7
115099: PPUSH
115100: LD_INT 16
115102: PPUSH
115103: CALL 51811 0 3
115107: ST_TO_ADDR
// if not cratesNearbyPoint then
115108: LD_VAR 0 9
115112: NOT
115113: IFFALSE 115119
// exit ;
115115: POP
115116: POP
115117: GO 115584
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
115119: LD_ADDR_VAR 0 4
115123: PUSH
115124: LD_INT 22
115126: PUSH
115127: LD_VAR 0 5
115131: PUSH
115132: EMPTY
115133: LIST
115134: LIST
115135: PUSH
115136: LD_INT 3
115138: PUSH
115139: LD_INT 60
115141: PUSH
115142: EMPTY
115143: LIST
115144: PUSH
115145: EMPTY
115146: LIST
115147: LIST
115148: PUSH
115149: LD_INT 91
115151: PUSH
115152: LD_VAR 0 8
115156: PUSH
115157: LD_INT 6
115159: PUSH
115160: EMPTY
115161: LIST
115162: LIST
115163: LIST
115164: PUSH
115165: LD_INT 2
115167: PUSH
115168: LD_INT 25
115170: PUSH
115171: LD_INT 2
115173: PUSH
115174: EMPTY
115175: LIST
115176: LIST
115177: PUSH
115178: LD_INT 25
115180: PUSH
115181: LD_INT 16
115183: PUSH
115184: EMPTY
115185: LIST
115186: LIST
115187: PUSH
115188: EMPTY
115189: LIST
115190: LIST
115191: LIST
115192: PUSH
115193: EMPTY
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: PPUSH
115199: CALL_OW 69
115203: PUSH
115204: LD_VAR 0 8
115208: PPUSH
115209: CALL_OW 313
115213: PPUSH
115214: LD_INT 3
115216: PUSH
115217: LD_INT 60
115219: PUSH
115220: EMPTY
115221: LIST
115222: PUSH
115223: EMPTY
115224: LIST
115225: LIST
115226: PUSH
115227: LD_INT 2
115229: PUSH
115230: LD_INT 25
115232: PUSH
115233: LD_INT 2
115235: PUSH
115236: EMPTY
115237: LIST
115238: LIST
115239: PUSH
115240: LD_INT 25
115242: PUSH
115243: LD_INT 16
115245: PUSH
115246: EMPTY
115247: LIST
115248: LIST
115249: PUSH
115250: EMPTY
115251: LIST
115252: LIST
115253: LIST
115254: PUSH
115255: EMPTY
115256: LIST
115257: LIST
115258: PPUSH
115259: CALL_OW 72
115263: UNION
115264: ST_TO_ADDR
// if tmp then
115265: LD_VAR 0 4
115269: IFFALSE 115349
// begin tmp := ShrinkArray ( tmp , 3 ) ;
115271: LD_ADDR_VAR 0 4
115275: PUSH
115276: LD_VAR 0 4
115280: PPUSH
115281: LD_INT 3
115283: PPUSH
115284: CALL 49618 0 2
115288: ST_TO_ADDR
// for j in tmp do
115289: LD_ADDR_VAR 0 2
115293: PUSH
115294: LD_VAR 0 4
115298: PUSH
115299: FOR_IN
115300: IFFALSE 115343
// begin if IsInUnit ( j ) then
115302: LD_VAR 0 2
115306: PPUSH
115307: CALL_OW 310
115311: IFFALSE 115322
// ComExit ( j ) ;
115313: LD_VAR 0 2
115317: PPUSH
115318: CALL 49701 0 1
// AddComCollect ( j , x , y ) ;
115322: LD_VAR 0 2
115326: PPUSH
115327: LD_VAR 0 6
115331: PPUSH
115332: LD_VAR 0 7
115336: PPUSH
115337: CALL_OW 177
// end ;
115341: GO 115299
115343: POP
115344: POP
// exit ;
115345: POP
115346: POP
115347: GO 115584
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
115349: LD_ADDR_VAR 0 4
115353: PUSH
115354: LD_INT 22
115356: PUSH
115357: LD_VAR 0 5
115361: PUSH
115362: EMPTY
115363: LIST
115364: LIST
115365: PUSH
115366: LD_INT 91
115368: PUSH
115369: LD_VAR 0 8
115373: PUSH
115374: LD_INT 8
115376: PUSH
115377: EMPTY
115378: LIST
115379: LIST
115380: LIST
115381: PUSH
115382: LD_INT 2
115384: PUSH
115385: LD_INT 34
115387: PUSH
115388: LD_INT 12
115390: PUSH
115391: EMPTY
115392: LIST
115393: LIST
115394: PUSH
115395: LD_INT 34
115397: PUSH
115398: LD_INT 51
115400: PUSH
115401: EMPTY
115402: LIST
115403: LIST
115404: PUSH
115405: LD_INT 34
115407: PUSH
115408: LD_INT 32
115410: PUSH
115411: EMPTY
115412: LIST
115413: LIST
115414: PUSH
115415: LD_INT 34
115417: PUSH
115418: LD_INT 89
115420: PUSH
115421: EMPTY
115422: LIST
115423: LIST
115424: PUSH
115425: EMPTY
115426: LIST
115427: LIST
115428: LIST
115429: LIST
115430: LIST
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: LIST
115436: PPUSH
115437: CALL_OW 69
115441: ST_TO_ADDR
// if tmp then
115442: LD_VAR 0 4
115446: IFFALSE 115580
// begin for j in tmp do
115448: LD_ADDR_VAR 0 2
115452: PUSH
115453: LD_VAR 0 4
115457: PUSH
115458: FOR_IN
115459: IFFALSE 115578
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
115461: LD_VAR 0 2
115465: PPUSH
115466: CALL_OW 262
115470: PUSH
115471: LD_INT 3
115473: EQUAL
115474: IFTRUE 115491
115476: PUSH
115477: LD_VAR 0 2
115481: PPUSH
115482: CALL_OW 261
115486: PUSH
115487: LD_INT 20
115489: GREATER
115490: OR
115491: IFFALSE 115505
115493: PUSH
115494: LD_VAR 0 2
115498: PPUSH
115499: CALL_OW 314
115503: NOT
115504: AND
115505: IFFALSE 115535
115507: PUSH
115508: LD_VAR 0 2
115512: PPUSH
115513: CALL_OW 263
115517: PUSH
115518: LD_INT 1
115520: NONEQUAL
115521: IFTRUE 115534
115523: PUSH
115524: LD_VAR 0 2
115528: PPUSH
115529: CALL_OW 311
115533: OR
115534: AND
115535: IFFALSE 115576
// begin ComCollect ( j , x , y ) ;
115537: LD_VAR 0 2
115541: PPUSH
115542: LD_VAR 0 6
115546: PPUSH
115547: LD_VAR 0 7
115551: PPUSH
115552: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
115556: LD_VAR 0 2
115560: PPUSH
115561: LD_VAR 0 8
115565: PPUSH
115566: CALL_OW 172
// exit ;
115570: POP
115571: POP
115572: POP
115573: POP
115574: GO 115584
// end ;
115576: GO 115458
115578: POP
115579: POP
// end ; end ;
115580: GO 114945
115582: POP
115583: POP
// end ; end_of_file
115584: PPOPN 9
115586: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115587: LD_VAR 0 1
115591: PPUSH
115592: LD_VAR 0 2
115596: PPUSH
115597: LD_VAR 0 3
115601: PPUSH
115602: LD_VAR 0 4
115606: PPUSH
115607: LD_VAR 0 5
115611: PPUSH
115612: LD_VAR 0 6
115616: PPUSH
115617: CALL 99680 0 6
// end ;
115621: PPOPN 6
115623: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115624: LD_INT 0
115626: PPUSH
// begin if not units then
115627: LD_VAR 0 1
115631: NOT
115632: IFFALSE 115636
// exit ;
115634: GO 115670
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
115636: LD_VAR 0 1
115640: PPUSH
115641: LD_VAR 0 2
115645: PPUSH
115646: LD_VAR 0 3
115650: PPUSH
115651: LD_VAR 0 4
115655: PPUSH
115656: LD_VAR 0 5
115660: PPUSH
115661: LD_VAR 0 6
115665: PPUSH
115666: CALL 99318 0 6
// end ;
115670: PPOPN 7
115672: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115673: CALL 99567 0 0
// end ;
115677: PPOPN 1
115679: END
