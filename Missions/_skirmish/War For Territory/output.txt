// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitGlobalVariables ;
  11: CALL 78033 0 0
// InitVariables ;
  15: CALL 214 0 0
// if debug then
  19: LD_EXP 1
  23: IFFALSE 42
// begin FogOff ( 1 ) ;
  25: LD_INT 1
  27: PPUSH
  28: CALL_OW 344
// Difficulty := 2 ;
  32: LD_ADDR_OWVAR 67
  36: PUSH
  37: LD_INT 2
  39: ST_TO_ADDR
// end else
  40: GO 55
// Difficulty := GetMultiplayerSetting ( 0 ) ;
  42: LD_ADDR_OWVAR 67
  46: PUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL_OW 426
  54: ST_TO_ADDR
// ChangeSideFog ( 4 , 1 ) ;
  55: LD_INT 4
  57: PPUSH
  58: LD_INT 1
  60: PPUSH
  61: CALL_OW 343
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , gensher_ape , 0 ) ;
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 0
  70: PPUSH
  71: LD_INT 5
  73: PPUSH
  74: LD_INT 0
  76: PPUSH
  77: LD_INT 0
  79: PPUSH
  80: LD_INT 0
  82: PPUSH
  83: LD_INT 0
  85: PPUSH
  86: LD_INT 7
  88: PPUSH
  89: LD_INT 0
  91: PPUSH
  92: CALL 42438 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , powell_ape , 0 ) ;
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 0
 101: PPUSH
 102: LD_INT 5
 104: PPUSH
 105: LD_INT 0
 107: PPUSH
 108: LD_INT 0
 110: PPUSH
 111: LD_INT 0
 113: PPUSH
 114: LD_INT 0
 116: PPUSH
 117: LD_INT 4
 119: PPUSH
 120: LD_INT 0
 122: PPUSH
 123: CALL 42438 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , popov_ape , 0 ) ;
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 0
 132: PPUSH
 133: LD_INT 5
 135: PPUSH
 136: LD_INT 0
 138: PPUSH
 139: LD_INT 0
 141: PPUSH
 142: LD_INT 0
 144: PPUSH
 145: LD_INT 0
 147: PPUSH
 148: LD_INT 11
 150: PPUSH
 151: LD_INT 0
 153: PPUSH
 154: CALL 42438 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , sikorski_ape , 0 ) ;
 158: LD_INT 0
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: LD_INT 5
 166: PPUSH
 167: LD_INT 0
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: LD_INT 0
 175: PPUSH
 176: LD_INT 0
 178: PPUSH
 179: LD_INT 14
 181: PPUSH
 182: LD_INT 0
 184: PPUSH
 185: CALL 42438 0 9
// PrepareGensher ;
 189: CALL 2085 0 0
// PreparePopov ;
 193: CALL 4783 0 0
// PreparePowell ;
 197: CALL 460 0 0
// PrepareSikorski ;
 201: CALL 7149 0 0
// MC_Start ( ) ;
 205: CALL 49788 0 0
// Action ;
 209: CALL 7556 0 0
// end ;
 213: END
// export debug , game , staticMines , arDestroyed , ruDestroyed , loseCounter , powellLoseCounter , powellInTrouble , sikorskiInTrouble ; function InitVariables ; begin
 214: LD_INT 0
 216: PPUSH
// debug := false ;
 217: LD_ADDR_EXP 1
 221: PUSH
 222: LD_INT 0
 224: ST_TO_ADDR
// game := true ;
 225: LD_ADDR_EXP 2
 229: PUSH
 230: LD_INT 1
 232: ST_TO_ADDR
// staticMines := [ ] ;
 233: LD_ADDR_EXP 3
 237: PUSH
 238: EMPTY
 239: ST_TO_ADDR
// arDestroyed := false ;
 240: LD_ADDR_EXP 4
 244: PUSH
 245: LD_INT 0
 247: ST_TO_ADDR
// ruDestroyed := false ;
 248: LD_ADDR_EXP 5
 252: PUSH
 253: LD_INT 0
 255: ST_TO_ADDR
// powellInTrouble := false ;
 256: LD_ADDR_EXP 8
 260: PUSH
 261: LD_INT 0
 263: ST_TO_ADDR
// sikorskiInTrouble := false ;
 264: LD_ADDR_EXP 9
 268: PUSH
 269: LD_INT 0
 271: ST_TO_ADDR
// end ;
 272: LD_VAR 0 1
 276: RET
// export function CustomInitMacro ; begin
 277: LD_INT 0
 279: PPUSH
// InitMC_Gensher ( ) ;
 280: CALL 2630 0 0
// InitMC_Powell ( ) ;
 284: CALL 682 0 0
// InitMC_Popov ( ) ;
 288: CALL 5116 0 0
// end ;
 292: LD_VAR 0 1
 296: RET
// every 0 0$10 do var cr , time , i ;
 297: GO 299
 299: DISABLE
 300: LD_INT 0
 302: PPUSH
 303: PPUSH
 304: PPUSH
// begin time := 0 0$30 ;
 305: LD_ADDR_VAR 0 2
 309: PUSH
 310: LD_INT 1050
 312: ST_TO_ADDR
// repeat wait ( time ) ;
 313: LD_VAR 0 2
 317: PPUSH
 318: CALL_OW 67
// cr := rand ( 1 , 5 ) ;
 322: LD_ADDR_VAR 0 1
 326: PUSH
 327: LD_INT 1
 329: PPUSH
 330: LD_INT 5
 332: PPUSH
 333: CALL_OW 12
 337: ST_TO_ADDR
// for i in [ powell_crates , gensher_crates , popov_crates , sikorski_crates ] do
 338: LD_ADDR_VAR 0 3
 342: PUSH
 343: LD_INT 5
 345: PUSH
 346: LD_INT 8
 348: PUSH
 349: LD_INT 12
 351: PUSH
 352: LD_INT 13
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: FOR_IN
 362: IFFALSE 416
// begin if GetResourceArea ( i , mat_cans ) < 20 then
 364: LD_VAR 0 3
 368: PPUSH
 369: LD_INT 1
 371: PPUSH
 372: CALL_OW 287
 376: PUSH
 377: LD_INT 20
 379: LESS
 380: IFFALSE 399
// CreateCratesArea ( cr , i , true ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 3
 391: PPUSH
 392: LD_INT 1
 394: PPUSH
 395: CALL_OW 55
// wait ( rand ( 0 0$5 , 0 0$20 ) ) ;
 399: LD_INT 175
 401: PPUSH
 402: LD_INT 700
 404: PPUSH
 405: CALL_OW 12
 409: PPUSH
 410: CALL_OW 67
// end ;
 414: GO 361
 416: POP
 417: POP
// time := time + 0 0$2 ;
 418: LD_ADDR_VAR 0 2
 422: PUSH
 423: LD_VAR 0 2
 427: PUSH
 428: LD_INT 70
 430: PLUS
 431: ST_TO_ADDR
// if time > 1 1$00 then
 432: LD_VAR 0 2
 436: PUSH
 437: LD_INT 2100
 439: GREATER
 440: IFFALSE 450
// time := 0 0$25 ;
 442: LD_ADDR_VAR 0 2
 446: PUSH
 447: LD_INT 875
 449: ST_TO_ADDR
// until not game ;
 450: LD_EXP 2
 454: NOT
 455: IFFALSE 313
// end ; end_of_file
 457: PPOPN 3
 459: END
// export Powell , powell_side , powellAttackGroup ; export function PreparePowell ; var i , tmp ; begin
 460: LD_INT 0
 462: PPUSH
 463: PPUSH
 464: PPUSH
// powell_side := 4 ;
 465: LD_ADDR_EXP 11
 469: PUSH
 470: LD_INT 4
 472: ST_TO_ADDR
// uc_side := powell_side ;
 473: LD_ADDR_OWVAR 20
 477: PUSH
 478: LD_EXP 11
 482: ST_TO_ADDR
// uc_nation := 1 ;
 483: LD_ADDR_OWVAR 21
 487: PUSH
 488: LD_INT 1
 490: ST_TO_ADDR
// Powell := NewCharacter ( Powell ) ;
 491: LD_ADDR_EXP 10
 495: PUSH
 496: LD_STRING Powell
 498: PPUSH
 499: CALL_OW 25
 503: ST_TO_ADDR
// SetSkill ( Powell , 1 , 7 ) ;
 504: LD_EXP 10
 508: PPUSH
 509: LD_INT 1
 511: PPUSH
 512: LD_INT 7
 514: PPUSH
 515: CALL_OW 237
// SetSkill ( Powell , 2 , 5 ) ;
 519: LD_EXP 10
 523: PPUSH
 524: LD_INT 2
 526: PPUSH
 527: LD_INT 5
 529: PPUSH
 530: CALL_OW 237
// SetSkill ( Powell , 3 , 6 ) ;
 534: LD_EXP 10
 538: PPUSH
 539: LD_INT 3
 541: PPUSH
 542: LD_INT 6
 544: PPUSH
 545: CALL_OW 237
// SetSkill ( Powell , 4 , 4 ) ;
 549: LD_EXP 10
 553: PPUSH
 554: LD_INT 4
 556: PPUSH
 557: LD_INT 4
 559: PPUSH
 560: CALL_OW 237
// PlaceHumanInUnit ( Powell , us_depot ) ;
 564: LD_EXP 10
 568: PPUSH
 569: LD_INT 4
 571: PPUSH
 572: CALL_OW 52
// tmp := PrepareBase ( us_depot , powell_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 3500 , 300 , 0 ] , [ 6 , 6 , 6 , 6 ] ) ;
 576: LD_ADDR_VAR 0 3
 580: PUSH
 581: LD_INT 4
 583: PPUSH
 584: LD_INT 1
 586: PPUSH
 587: LD_STRING 
 589: PPUSH
 590: LD_INT 8
 592: PUSH
 593: LD_INT 7
 595: PUSH
 596: LD_INT 6
 598: PUSH
 599: EMPTY
 600: LIST
 601: LIST
 602: LIST
 603: PUSH
 604: LD_OWVAR 67
 608: ARRAY
 609: PPUSH
 610: LD_INT 3500
 612: PUSH
 613: LD_INT 300
 615: PUSH
 616: LD_INT 0
 618: PUSH
 619: EMPTY
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: LD_INT 6
 626: PUSH
 627: LD_INT 6
 629: PUSH
 630: LD_INT 6
 632: PUSH
 633: LD_INT 6
 635: PUSH
 636: EMPTY
 637: LIST
 638: LIST
 639: LIST
 640: LIST
 641: PPUSH
 642: CALL 17385 0 6
 646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , tmp ) ;
 647: LD_ADDR_EXP 23
 651: PUSH
 652: LD_EXP 23
 656: PPUSH
 657: LD_INT 1
 659: PPUSH
 660: LD_VAR 0 3
 664: PPUSH
 665: CALL_OW 1
 669: ST_TO_ADDR
// powellAttackGroup := [ ] ;
 670: LD_ADDR_EXP 12
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// end ;
 677: LD_VAR 0 1
 681: RET
// export function InitMC_Powell ( ) ; begin
 682: LD_INT 0
 684: PPUSH
// MC_SetScanArea ( 1 , powell_base ) ;
 685: LD_INT 1
 687: PPUSH
 688: LD_INT 1
 690: PPUSH
 691: CALL 72900 0 2
// MC_SetParkingArea ( 1 , powell_parking ) ;
 695: LD_INT 1
 697: PPUSH
 698: LD_INT 6
 700: PPUSH
 701: CALL 72844 0 2
// MC_SetDepositsXY ( 1 , [ [ 167 , 102 , 0 ] , [ 173 , 83 , 1 ] , [ 171 , 141 , 0 ] , [ 178 , 148 , 1 ] ] ) ;
 705: LD_INT 1
 707: PPUSH
 708: LD_INT 167
 710: PUSH
 711: LD_INT 102
 713: PUSH
 714: LD_INT 0
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: PUSH
 722: LD_INT 173
 724: PUSH
 725: LD_INT 83
 727: PUSH
 728: LD_INT 1
 730: PUSH
 731: EMPTY
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 171
 738: PUSH
 739: LD_INT 141
 741: PUSH
 742: LD_INT 0
 744: PUSH
 745: EMPTY
 746: LIST
 747: LIST
 748: LIST
 749: PUSH
 750: LD_INT 178
 752: PUSH
 753: LD_INT 148
 755: PUSH
 756: LD_INT 1
 758: PUSH
 759: EMPTY
 760: LIST
 761: LIST
 762: LIST
 763: PUSH
 764: EMPTY
 765: LIST
 766: LIST
 767: LIST
 768: LIST
 769: PPUSH
 770: CALL 71903 0 2
// MC_SetAllowedTurretWeapons ( 1 , [ us_radar , us_heavy_gun , us_rocket_launcher ] ) ;
 774: LD_INT 1
 776: PPUSH
 777: LD_INT 11
 779: PUSH
 780: LD_INT 6
 782: PUSH
 783: LD_INT 7
 785: PUSH
 786: EMPTY
 787: LIST
 788: LIST
 789: LIST
 790: PPUSH
 791: CALL 72732 0 2
// MC_SetCratesArea ( 1 , powell_crates ) ;
 795: LD_INT 1
 797: PPUSH
 798: LD_INT 5
 800: PPUSH
 801: CALL 72414 0 2
// MC_SetTame ( 1 , powell_ape ) ;
 805: LD_INT 1
 807: PPUSH
 808: LD_INT 4
 810: PPUSH
 811: CALL 72145 0 2
// MC_SetDefenderLimit ( 1 , 4 ) ;
 815: LD_INT 1
 817: PPUSH
 818: LD_INT 4
 820: PPUSH
 821: CALL 71764 0 2
// MC_SetProduceList ( 1 , [ [ us_medium_tracked , engine_combustion , control_remote , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] ] ) ;
 825: LD_INT 1
 827: PPUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 1
 833: PUSH
 834: LD_INT 2
 836: PUSH
 837: LD_INT 5
 839: PUSH
 840: EMPTY
 841: LIST
 842: LIST
 843: LIST
 844: LIST
 845: PUSH
 846: LD_INT 4
 848: PUSH
 849: LD_INT 1
 851: PUSH
 852: LD_INT 2
 854: PUSH
 855: LD_INT 6
 857: PUSH
 858: EMPTY
 859: LIST
 860: LIST
 861: LIST
 862: LIST
 863: PUSH
 864: LD_INT 4
 866: PUSH
 867: LD_INT 1
 869: PUSH
 870: LD_INT 2
 872: PUSH
 873: LD_INT 7
 875: PUSH
 876: EMPTY
 877: LIST
 878: LIST
 879: LIST
 880: LIST
 881: PUSH
 882: LD_INT 4
 884: PUSH
 885: LD_INT 1
 887: PUSH
 888: LD_INT 2
 890: PUSH
 891: LD_INT 6
 893: PUSH
 894: EMPTY
 895: LIST
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: EMPTY
 901: LIST
 902: LIST
 903: LIST
 904: LIST
 905: PPUSH
 906: CALL 71579 0 2
// MC_SetBuildingList ( 1 , [ [ b_lab , 200 , 111 , 4 ] , [ b_oil_mine , 167 , 102 , 0 ] , [ b_armoury , 178 , 117 , 2 ] , [ b_workshop , 201 , 140 , 4 ] , [ b_solar_power , 206 , 124 , 3 ] , [ b_solar_power , 209 , 128 , 3 ] , [ b_solar_power , 211 , 132 , 3 ] , [ b_siberite_mine , 173 , 83 , 3 ] , [ b_lab , 186 , 103 , 2 ] , [ b_turret , 173 , 99 , 2 ] , [ b_bunker , 174 , 102 , 2 ] , [ b_bunker , 178 , 100 , 2 ] , [ b_turret , 174 , 108 , 1 ] , [ b_turret , 182 , 122 , 1 ] , [ b_control_tower , 194 , 124 , 5 ] , [ b_turret , 184 , 141 , 1 ] , [ b_turret , 183 , 131 , 2 ] , [ b_turret , 194 , 146 , 4 ] , [ b_turret , 190 , 142 , 4 ] , [ b_siberite_power , 204 , 133 , 3 ] , [ b_solar_power , 201 , 133 , 3 ] , [ b_siberite_power , 199 , 119 , 5 ] ] ) ;
 910: LD_INT 1
 912: PPUSH
 913: LD_INT 6
 915: PUSH
 916: LD_INT 200
 918: PUSH
 919: LD_INT 111
 921: PUSH
 922: LD_INT 4
 924: PUSH
 925: EMPTY
 926: LIST
 927: LIST
 928: LIST
 929: LIST
 930: PUSH
 931: LD_INT 29
 933: PUSH
 934: LD_INT 167
 936: PUSH
 937: LD_INT 102
 939: PUSH
 940: LD_INT 0
 942: PUSH
 943: EMPTY
 944: LIST
 945: LIST
 946: LIST
 947: LIST
 948: PUSH
 949: LD_INT 4
 951: PUSH
 952: LD_INT 178
 954: PUSH
 955: LD_INT 117
 957: PUSH
 958: LD_INT 2
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: LIST
 965: LIST
 966: PUSH
 967: LD_INT 2
 969: PUSH
 970: LD_INT 201
 972: PUSH
 973: LD_INT 140
 975: PUSH
 976: LD_INT 4
 978: PUSH
 979: EMPTY
 980: LIST
 981: LIST
 982: LIST
 983: LIST
 984: PUSH
 985: LD_INT 27
 987: PUSH
 988: LD_INT 206
 990: PUSH
 991: LD_INT 124
 993: PUSH
 994: LD_INT 3
 996: PUSH
 997: EMPTY
 998: LIST
 999: LIST
1000: LIST
1001: LIST
1002: PUSH
1003: LD_INT 27
1005: PUSH
1006: LD_INT 209
1008: PUSH
1009: LD_INT 128
1011: PUSH
1012: LD_INT 3
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: LIST
1019: LIST
1020: PUSH
1021: LD_INT 27
1023: PUSH
1024: LD_INT 211
1026: PUSH
1027: LD_INT 132
1029: PUSH
1030: LD_INT 3
1032: PUSH
1033: EMPTY
1034: LIST
1035: LIST
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 30
1041: PUSH
1042: LD_INT 173
1044: PUSH
1045: LD_INT 83
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: EMPTY
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: PUSH
1057: LD_INT 6
1059: PUSH
1060: LD_INT 186
1062: PUSH
1063: LD_INT 103
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: PUSH
1075: LD_INT 33
1077: PUSH
1078: LD_INT 173
1080: PUSH
1081: LD_INT 99
1083: PUSH
1084: LD_INT 2
1086: PUSH
1087: EMPTY
1088: LIST
1089: LIST
1090: LIST
1091: LIST
1092: PUSH
1093: LD_INT 32
1095: PUSH
1096: LD_INT 174
1098: PUSH
1099: LD_INT 102
1101: PUSH
1102: LD_INT 2
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: LIST
1110: PUSH
1111: LD_INT 32
1113: PUSH
1114: LD_INT 178
1116: PUSH
1117: LD_INT 100
1119: PUSH
1120: LD_INT 2
1122: PUSH
1123: EMPTY
1124: LIST
1125: LIST
1126: LIST
1127: LIST
1128: PUSH
1129: LD_INT 33
1131: PUSH
1132: LD_INT 174
1134: PUSH
1135: LD_INT 108
1137: PUSH
1138: LD_INT 1
1140: PUSH
1141: EMPTY
1142: LIST
1143: LIST
1144: LIST
1145: LIST
1146: PUSH
1147: LD_INT 33
1149: PUSH
1150: LD_INT 182
1152: PUSH
1153: LD_INT 122
1155: PUSH
1156: LD_INT 1
1158: PUSH
1159: EMPTY
1160: LIST
1161: LIST
1162: LIST
1163: LIST
1164: PUSH
1165: LD_INT 36
1167: PUSH
1168: LD_INT 194
1170: PUSH
1171: LD_INT 124
1173: PUSH
1174: LD_INT 5
1176: PUSH
1177: EMPTY
1178: LIST
1179: LIST
1180: LIST
1181: LIST
1182: PUSH
1183: LD_INT 33
1185: PUSH
1186: LD_INT 184
1188: PUSH
1189: LD_INT 141
1191: PUSH
1192: LD_INT 1
1194: PUSH
1195: EMPTY
1196: LIST
1197: LIST
1198: LIST
1199: LIST
1200: PUSH
1201: LD_INT 33
1203: PUSH
1204: LD_INT 183
1206: PUSH
1207: LD_INT 131
1209: PUSH
1210: LD_INT 2
1212: PUSH
1213: EMPTY
1214: LIST
1215: LIST
1216: LIST
1217: LIST
1218: PUSH
1219: LD_INT 33
1221: PUSH
1222: LD_INT 194
1224: PUSH
1225: LD_INT 146
1227: PUSH
1228: LD_INT 4
1230: PUSH
1231: EMPTY
1232: LIST
1233: LIST
1234: LIST
1235: LIST
1236: PUSH
1237: LD_INT 33
1239: PUSH
1240: LD_INT 190
1242: PUSH
1243: LD_INT 142
1245: PUSH
1246: LD_INT 4
1248: PUSH
1249: EMPTY
1250: LIST
1251: LIST
1252: LIST
1253: LIST
1254: PUSH
1255: LD_INT 28
1257: PUSH
1258: LD_INT 204
1260: PUSH
1261: LD_INT 133
1263: PUSH
1264: LD_INT 3
1266: PUSH
1267: EMPTY
1268: LIST
1269: LIST
1270: LIST
1271: LIST
1272: PUSH
1273: LD_INT 27
1275: PUSH
1276: LD_INT 201
1278: PUSH
1279: LD_INT 133
1281: PUSH
1282: LD_INT 3
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PUSH
1291: LD_INT 28
1293: PUSH
1294: LD_INT 199
1296: PUSH
1297: LD_INT 119
1299: PUSH
1300: LD_INT 5
1302: PUSH
1303: EMPTY
1304: LIST
1305: LIST
1306: LIST
1307: LIST
1308: PUSH
1309: EMPTY
1310: LIST
1311: LIST
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: LIST
1329: LIST
1330: LIST
1331: LIST
1332: PPUSH
1333: CALL 71471 0 2
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_opto , b_lab_computer , b_lab_siberium ] ) ;
1337: LD_INT 1
1339: PPUSH
1340: LD_INT 10
1342: PUSH
1343: LD_INT 15
1345: PUSH
1346: LD_INT 12
1348: PUSH
1349: LD_INT 11
1351: PUSH
1352: EMPTY
1353: LIST
1354: LIST
1355: LIST
1356: LIST
1357: PPUSH
1358: CALL 72321 0 2
// MC_SetFactoryExtension ( 1 , 201 , 140 , 4 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
1362: LD_INT 1
1364: PPUSH
1365: LD_INT 201
1367: PPUSH
1368: LD_INT 140
1370: PPUSH
1371: LD_INT 4
1373: PPUSH
1374: LD_INT 19
1376: PUSH
1377: LD_INT 16
1379: PUSH
1380: LD_INT 17
1382: PUSH
1383: LD_INT 18
1385: PUSH
1386: LD_INT 22
1388: PUSH
1389: EMPTY
1390: LIST
1391: LIST
1392: LIST
1393: LIST
1394: LIST
1395: PPUSH
1396: CALL 72526 0 5
// MC_SetUpgradeBuilding ( 1 , b_depot ) ;
1400: LD_INT 1
1402: PPUSH
1403: LD_INT 0
1405: PPUSH
1406: CALL 72194 0 2
// end ;
1410: LD_VAR 0 1
1414: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( us_depot ) do var i , base , tmp , attackers , amount ;
1415: LD_INT 4
1417: PPUSH
1418: CALL_OW 302
1422: IFFALSE 2082
1424: GO 1426
1426: DISABLE
1427: LD_INT 0
1429: PPUSH
1430: PPUSH
1431: PPUSH
1432: PPUSH
1433: PPUSH
// begin enable ;
1434: ENABLE
// base := 1 ;
1435: LD_ADDR_VAR 0 2
1439: PUSH
1440: LD_INT 1
1442: ST_TO_ADDR
// tmp := [ [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_remote , us_heavy_gun ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_remote , us_rocket_launcher ] ] ;
1443: LD_ADDR_VAR 0 3
1447: PUSH
1448: LD_INT 4
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 2
1456: PUSH
1457: LD_INT 6
1459: PUSH
1460: EMPTY
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: PUSH
1466: LD_INT 4
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 2
1474: PUSH
1475: LD_INT 6
1477: PUSH
1478: EMPTY
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: PUSH
1484: LD_INT 3
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 2
1492: PUSH
1493: LD_INT 7
1495: PUSH
1496: EMPTY
1497: LIST
1498: LIST
1499: LIST
1500: LIST
1501: PUSH
1502: LD_INT 3
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 2
1510: PUSH
1511: LD_INT 7
1513: PUSH
1514: EMPTY
1515: LIST
1516: LIST
1517: LIST
1518: LIST
1519: PUSH
1520: EMPTY
1521: LIST
1522: LIST
1523: LIST
1524: LIST
1525: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
1526: LD_ADDR_VAR 0 5
1530: PUSH
1531: LD_VAR 0 5
1535: PUSH
1536: LD_OWVAR 1
1540: PUSH
1541: LD_INT 21000
1543: DIV
1544: PLUS
1545: ST_TO_ADDR
// if amount > 8 then
1546: LD_VAR 0 5
1550: PUSH
1551: LD_INT 8
1553: GREATER
1554: IFFALSE 1564
// amount := 8 ;
1556: LD_ADDR_VAR 0 5
1560: PUSH
1561: LD_INT 8
1563: ST_TO_ADDR
// for i = 1 to amount do
1564: LD_ADDR_VAR 0 1
1568: PUSH
1569: DOUBLE
1570: LD_INT 1
1572: DEC
1573: ST_TO_ADDR
1574: LD_VAR 0 5
1578: PUSH
1579: FOR_TO
1580: IFFALSE 1664
// tmp := Insert ( tmp , tmp + 1 , [ [ us_medium_tracked , us_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ us_rocket_launcher , us_double_gun ] [ rand ( 1 , 2 ) ] ] ) ;
1582: LD_ADDR_VAR 0 3
1586: PUSH
1587: LD_VAR 0 3
1591: PPUSH
1592: LD_VAR 0 3
1596: PUSH
1597: LD_INT 1
1599: PLUS
1600: PPUSH
1601: LD_INT 3
1603: PUSH
1604: LD_INT 4
1606: PUSH
1607: EMPTY
1608: LIST
1609: LIST
1610: PUSH
1611: LD_INT 1
1613: PPUSH
1614: LD_INT 2
1616: PPUSH
1617: CALL_OW 12
1621: ARRAY
1622: PUSH
1623: LD_INT 1
1625: PUSH
1626: LD_INT 2
1628: PUSH
1629: LD_INT 7
1631: PUSH
1632: LD_INT 5
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: LD_INT 1
1641: PPUSH
1642: LD_INT 2
1644: PPUSH
1645: CALL_OW 12
1649: ARRAY
1650: PUSH
1651: EMPTY
1652: LIST
1653: LIST
1654: LIST
1655: LIST
1656: PPUSH
1657: CALL_OW 2
1661: ST_TO_ADDR
1662: GO 1579
1664: POP
1665: POP
// MC_InsertProduceList ( base , tmp ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_VAR 0 3
1675: PPUSH
1676: CALL 71627 0 2
// repeat wait ( 0 0$1 ) ;
1680: LD_INT 35
1682: PPUSH
1683: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
1687: LD_VAR 0 2
1691: PPUSH
1692: LD_INT 1
1694: PPUSH
1695: CALL 73045 0 2
1699: PUSH
1700: LD_VAR 0 5
1704: GREATEREQUAL
1705: IFFALSE 1680
// wait ( 0 0$30 ) ;
1707: LD_INT 1050
1709: PPUSH
1710: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , us_bulldozer ] ] ) ;
1714: LD_ADDR_VAR 0 4
1718: PUSH
1719: LD_EXP 42
1723: PUSH
1724: LD_VAR 0 2
1728: ARRAY
1729: PUSH
1730: LD_EXP 42
1734: PUSH
1735: LD_VAR 0 2
1739: ARRAY
1740: PPUSH
1741: LD_INT 2
1743: PUSH
1744: LD_INT 34
1746: PUSH
1747: LD_INT 12
1749: PUSH
1750: EMPTY
1751: LIST
1752: LIST
1753: PUSH
1754: LD_INT 34
1756: PUSH
1757: LD_INT 13
1759: PUSH
1760: EMPTY
1761: LIST
1762: LIST
1763: PUSH
1764: LD_INT 34
1766: PUSH
1767: LD_INT 14
1769: PUSH
1770: EMPTY
1771: LIST
1772: LIST
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: LIST
1778: LIST
1779: PPUSH
1780: CALL_OW 72
1784: DIFF
1785: ST_TO_ADDR
// if not attackers then
1786: LD_VAR 0 4
1790: NOT
1791: IFFALSE 1795
// exit ;
1793: GO 2082
// DialogPowellsAttack ;
1795: CALL 7687 0 0
// powellAttackGroup := attackers ;
1799: LD_ADDR_EXP 12
1803: PUSH
1804: LD_VAR 0 4
1808: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
1809: LD_ADDR_EXP 42
1813: PUSH
1814: LD_EXP 42
1818: PPUSH
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_EXP 42
1828: PUSH
1829: LD_VAR 0 2
1833: ARRAY
1834: PUSH
1835: LD_VAR 0 4
1839: DIFF
1840: PPUSH
1841: CALL_OW 1
1845: ST_TO_ADDR
// if sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 4 ] ) then
1846: LD_EXP 9
1850: PUSH
1851: LD_INT 16
1853: PPUSH
1854: LD_INT 81
1856: PUSH
1857: LD_INT 4
1859: PUSH
1860: EMPTY
1861: LIST
1862: LIST
1863: PPUSH
1864: CALL_OW 70
1868: AND
1869: IFFALSE 1888
// ComAgressiveMove ( attackers , 135 , 21 ) else
1871: LD_VAR 0 4
1875: PPUSH
1876: LD_INT 135
1878: PPUSH
1879: LD_INT 21
1881: PPUSH
1882: CALL_OW 114
1886: GO 1903
// ComAgressiveMove ( attackers , 146 , 103 ) ;
1888: LD_VAR 0 4
1892: PPUSH
1893: LD_INT 146
1895: PPUSH
1896: LD_INT 103
1898: PPUSH
1899: CALL_OW 114
// wait ( 0 0$5 ) ;
1903: LD_INT 175
1905: PPUSH
1906: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
1910: LD_INT 35
1912: PPUSH
1913: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
1917: LD_VAR 0 4
1921: PPUSH
1922: LD_INT 60
1924: PUSH
1925: EMPTY
1926: LIST
1927: PPUSH
1928: CALL_OW 72
1932: NOT
1933: IFFALSE 1910
// if FilterAllUnits ( [ f_side , 3 ] ) then
1935: LD_INT 22
1937: PUSH
1938: LD_INT 3
1940: PUSH
1941: EMPTY
1942: LIST
1943: LIST
1944: PPUSH
1945: CALL_OW 69
1949: IFFALSE 1968
// ComAgressiveMove ( attackers , 102 , 116 ) else
1951: LD_VAR 0 4
1955: PPUSH
1956: LD_INT 102
1958: PPUSH
1959: LD_INT 116
1961: PPUSH
1962: CALL_OW 114
1966: GO 1983
// ComAgressiveMove ( attackers , 66 , 41 ) ;
1968: LD_VAR 0 4
1972: PPUSH
1973: LD_INT 66
1975: PPUSH
1976: LD_INT 41
1978: PPUSH
1979: CALL_OW 114
// wait ( 0 0$10 ) ;
1983: LD_INT 350
1985: PPUSH
1986: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
1990: LD_INT 35
1992: PPUSH
1993: CALL_OW 67
// for i in attackers do
1997: LD_ADDR_VAR 0 1
2001: PUSH
2002: LD_VAR 0 4
2006: PUSH
2007: FOR_IN
2008: IFFALSE 2058
// if not HasTask ( i ) then
2010: LD_VAR 0 1
2014: PPUSH
2015: CALL_OW 314
2019: NOT
2020: IFFALSE 2056
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 4 ] ) , i ) ) ;
2022: LD_VAR 0 1
2026: PPUSH
2027: LD_INT 81
2029: PUSH
2030: LD_INT 4
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: PPUSH
2037: CALL_OW 69
2041: PPUSH
2042: LD_VAR 0 1
2046: PPUSH
2047: CALL_OW 74
2051: PPUSH
2052: CALL_OW 115
2056: GO 2007
2058: POP
2059: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
2060: LD_VAR 0 4
2064: PPUSH
2065: LD_INT 50
2067: PUSH
2068: EMPTY
2069: LIST
2070: PPUSH
2071: CALL_OW 72
2075: NOT
2076: IFFALSE 1990
// DialogPowellsAttackFailed ;
2078: CALL 7952 0 0
// end ; end_of_file
2082: PPOPN 5
2084: END
// export Gensher , gensher_side , gensherAttackGroup ; export function PrepareGensher ; var i , tmp , un ; begin
2085: LD_INT 0
2087: PPUSH
2088: PPUSH
2089: PPUSH
2090: PPUSH
// gensher_side := 2 ;
2091: LD_ADDR_EXP 14
2095: PUSH
2096: LD_INT 2
2098: ST_TO_ADDR
// uc_side := gensher_side ;
2099: LD_ADDR_OWVAR 20
2103: PUSH
2104: LD_EXP 14
2108: ST_TO_ADDR
// uc_nation := 2 ;
2109: LD_ADDR_OWVAR 21
2113: PUSH
2114: LD_INT 2
2116: ST_TO_ADDR
// tmp := PrepareBase ( ar_depot , gensher_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 4500 , 600 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
2117: LD_ADDR_VAR 0 3
2121: PUSH
2122: LD_INT 7
2124: PPUSH
2125: LD_INT 2
2127: PPUSH
2128: LD_STRING 
2130: PPUSH
2131: LD_INT 8
2133: PUSH
2134: LD_INT 7
2136: PUSH
2137: LD_INT 6
2139: PUSH
2140: EMPTY
2141: LIST
2142: LIST
2143: LIST
2144: PUSH
2145: LD_OWVAR 67
2149: ARRAY
2150: PPUSH
2151: LD_INT 4500
2153: PUSH
2154: LD_INT 600
2156: PUSH
2157: LD_INT 60
2159: PUSH
2160: EMPTY
2161: LIST
2162: LIST
2163: LIST
2164: PPUSH
2165: LD_INT 6
2167: PUSH
2168: LD_INT 6
2170: PUSH
2171: LD_INT 6
2173: PUSH
2174: LD_INT 6
2176: PUSH
2177: EMPTY
2178: LIST
2179: LIST
2180: LIST
2181: LIST
2182: PPUSH
2183: CALL 17385 0 6
2187: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp ) ;
2188: LD_ADDR_EXP 23
2192: PUSH
2193: LD_EXP 23
2197: PPUSH
2198: LD_INT 2
2200: PPUSH
2201: LD_VAR 0 3
2205: PPUSH
2206: CALL_OW 1
2210: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] ] ) ;
2211: LD_ADDR_VAR 0 3
2215: PUSH
2216: LD_INT 22
2218: PUSH
2219: LD_INT 2
2221: PUSH
2222: EMPTY
2223: LIST
2224: LIST
2225: PUSH
2226: LD_INT 30
2228: PUSH
2229: LD_INT 31
2231: PUSH
2232: EMPTY
2233: LIST
2234: LIST
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: CALL_OW 69
2244: ST_TO_ADDR
// for i in tmp do
2245: LD_ADDR_VAR 0 2
2249: PUSH
2250: LD_VAR 0 3
2254: PUSH
2255: FOR_IN
2256: IFFALSE 2326
// begin PrepareHuman ( false , 1 , [ 4 , 3 , 3 ] [ Difficulty ] ) ;
2258: LD_INT 0
2260: PPUSH
2261: LD_INT 1
2263: PPUSH
2264: LD_INT 4
2266: PUSH
2267: LD_INT 3
2269: PUSH
2270: LD_INT 3
2272: PUSH
2273: EMPTY
2274: LIST
2275: LIST
2276: LIST
2277: PUSH
2278: LD_OWVAR 67
2282: ARRAY
2283: PPUSH
2284: CALL_OW 380
// un := CreateHuman ;
2288: LD_ADDR_VAR 0 4
2292: PUSH
2293: CALL_OW 44
2297: ST_TO_ADDR
// SetDir ( un , 1 ) ;
2298: LD_VAR 0 4
2302: PPUSH
2303: LD_INT 1
2305: PPUSH
2306: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
2310: LD_VAR 0 4
2314: PPUSH
2315: LD_VAR 0 2
2319: PPUSH
2320: CALL_OW 52
// end ;
2324: GO 2255
2326: POP
2327: POP
// tmp := AreaToList ( gensher_mines , 0 ) ;
2328: LD_ADDR_VAR 0 3
2332: PUSH
2333: LD_INT 15
2335: PPUSH
2336: LD_INT 0
2338: PPUSH
2339: CALL_OW 517
2343: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
2344: LD_ADDR_VAR 0 2
2348: PUSH
2349: DOUBLE
2350: LD_INT 1
2352: DEC
2353: ST_TO_ADDR
2354: LD_VAR 0 3
2358: PUSH
2359: LD_INT 1
2361: ARRAY
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2466
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
2366: LD_VAR 0 3
2370: PUSH
2371: LD_INT 1
2373: ARRAY
2374: PUSH
2375: LD_VAR 0 2
2379: ARRAY
2380: PPUSH
2381: LD_VAR 0 3
2385: PUSH
2386: LD_INT 2
2388: ARRAY
2389: PUSH
2390: LD_VAR 0 2
2394: ARRAY
2395: PPUSH
2396: LD_INT 2
2398: PPUSH
2399: LD_INT 0
2401: PPUSH
2402: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
2406: LD_ADDR_EXP 3
2410: PUSH
2411: LD_EXP 3
2415: PPUSH
2416: LD_EXP 3
2420: PUSH
2421: LD_INT 1
2423: PLUS
2424: PPUSH
2425: LD_VAR 0 3
2429: PUSH
2430: LD_INT 1
2432: ARRAY
2433: PUSH
2434: LD_VAR 0 2
2438: ARRAY
2439: PUSH
2440: LD_VAR 0 3
2444: PUSH
2445: LD_INT 2
2447: ARRAY
2448: PUSH
2449: LD_VAR 0 2
2453: ARRAY
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 2
2463: ST_TO_ADDR
// end ;
2464: GO 2363
2466: POP
2467: POP
// if Difficulty > 1 then
2468: LD_OWVAR 67
2472: PUSH
2473: LD_INT 1
2475: GREATER
2476: IFFALSE 2618
// begin tmp := AreaToList ( gensher_mines2 , 0 ) ;
2478: LD_ADDR_VAR 0 3
2482: PUSH
2483: LD_INT 19
2485: PPUSH
2486: LD_INT 0
2488: PPUSH
2489: CALL_OW 517
2493: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
2494: LD_ADDR_VAR 0 2
2498: PUSH
2499: DOUBLE
2500: LD_INT 1
2502: DEC
2503: ST_TO_ADDR
2504: LD_VAR 0 3
2508: PUSH
2509: LD_INT 1
2511: ARRAY
2512: PUSH
2513: FOR_TO
2514: IFFALSE 2616
// begin PlaceMine ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 2 , 0 ) ;
2516: LD_VAR 0 3
2520: PUSH
2521: LD_INT 1
2523: ARRAY
2524: PUSH
2525: LD_VAR 0 2
2529: ARRAY
2530: PPUSH
2531: LD_VAR 0 3
2535: PUSH
2536: LD_INT 2
2538: ARRAY
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PPUSH
2546: LD_INT 2
2548: PPUSH
2549: LD_INT 0
2551: PPUSH
2552: CALL_OW 454
// staticMines := Insert ( staticMines , staticMines + 1 , [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ) ;
2556: LD_ADDR_EXP 3
2560: PUSH
2561: LD_EXP 3
2565: PPUSH
2566: LD_EXP 3
2570: PUSH
2571: LD_INT 1
2573: PLUS
2574: PPUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_INT 1
2582: ARRAY
2583: PUSH
2584: LD_VAR 0 2
2588: ARRAY
2589: PUSH
2590: LD_VAR 0 3
2594: PUSH
2595: LD_INT 2
2597: ARRAY
2598: PUSH
2599: LD_VAR 0 2
2603: ARRAY
2604: PUSH
2605: EMPTY
2606: LIST
2607: LIST
2608: PPUSH
2609: CALL_OW 2
2613: ST_TO_ADDR
// end ;
2614: GO 2513
2616: POP
2617: POP
// end ; gensherAttackGroup := [ ] ;
2618: LD_ADDR_EXP 15
2622: PUSH
2623: EMPTY
2624: ST_TO_ADDR
// end ;
2625: LD_VAR 0 1
2629: RET
// export function InitMC_Gensher ( ) ; begin
2630: LD_INT 0
2632: PPUSH
// MC_SetScanArea ( 2 , gensher_base ) ;
2633: LD_INT 2
2635: PPUSH
2636: LD_INT 2
2638: PPUSH
2639: CALL 72900 0 2
// MC_SetParkingArea ( 2 , gensher_parking ) ;
2643: LD_INT 2
2645: PPUSH
2646: LD_INT 9
2648: PPUSH
2649: CALL 72844 0 2
// MC_SetDepositsXY ( 2 , [ [ 56 , 23 , 0 ] , [ 52 , 40 , 1 ] ] ) ;
2653: LD_INT 2
2655: PPUSH
2656: LD_INT 56
2658: PUSH
2659: LD_INT 23
2661: PUSH
2662: LD_INT 0
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: LIST
2669: PUSH
2670: LD_INT 52
2672: PUSH
2673: LD_INT 40
2675: PUSH
2676: LD_INT 1
2678: PUSH
2679: EMPTY
2680: LIST
2681: LIST
2682: LIST
2683: PUSH
2684: EMPTY
2685: LIST
2686: LIST
2687: PPUSH
2688: CALL 71903 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ar_gun , ar_rocket_launcher ] ) ;
2692: LD_INT 2
2694: PPUSH
2695: LD_INT 27
2697: PUSH
2698: LD_INT 28
2700: PUSH
2701: EMPTY
2702: LIST
2703: LIST
2704: PPUSH
2705: CALL 72732 0 2
// MC_SetCratesArea ( 2 , gensher_crates ) ;
2709: LD_INT 2
2711: PPUSH
2712: LD_INT 8
2714: PPUSH
2715: CALL 72414 0 2
// MC_SetTame ( 2 , gensher_ape ) ;
2719: LD_INT 2
2721: PPUSH
2722: LD_INT 7
2724: PPUSH
2725: CALL 72145 0 2
// MC_SetDefenderLimit ( 2 , 4 ) ;
2729: LD_INT 2
2731: PPUSH
2732: LD_INT 4
2734: PPUSH
2735: CALL 71764 0 2
// MC_SetProduceList ( 2 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ) ;
2739: LD_INT 2
2741: PPUSH
2742: LD_INT 13
2744: PUSH
2745: LD_INT 2
2747: PUSH
2748: LD_INT 1
2750: PUSH
2751: LD_INT 31
2753: PUSH
2754: EMPTY
2755: LIST
2756: LIST
2757: LIST
2758: LIST
2759: PUSH
2760: LD_INT 13
2762: PUSH
2763: LD_INT 2
2765: PUSH
2766: LD_INT 1
2768: PUSH
2769: LD_INT 31
2771: PUSH
2772: EMPTY
2773: LIST
2774: LIST
2775: LIST
2776: LIST
2777: PUSH
2778: LD_INT 14
2780: PUSH
2781: LD_INT 1
2783: PUSH
2784: LD_INT 2
2786: PUSH
2787: LD_INT 27
2789: PUSH
2790: EMPTY
2791: LIST
2792: LIST
2793: LIST
2794: LIST
2795: PUSH
2796: LD_INT 14
2798: PUSH
2799: LD_INT 1
2801: PUSH
2802: LD_INT 2
2804: PUSH
2805: LD_INT 27
2807: PUSH
2808: EMPTY
2809: LIST
2810: LIST
2811: LIST
2812: LIST
2813: PUSH
2814: LD_INT 14
2816: PUSH
2817: LD_INT 1
2819: PUSH
2820: LD_INT 2
2822: PUSH
2823: LD_INT 28
2825: PUSH
2826: EMPTY
2827: LIST
2828: LIST
2829: LIST
2830: LIST
2831: PUSH
2832: LD_INT 14
2834: PUSH
2835: LD_INT 1
2837: PUSH
2838: LD_INT 2
2840: PUSH
2841: LD_INT 26
2843: PUSH
2844: EMPTY
2845: LIST
2846: LIST
2847: LIST
2848: LIST
2849: PUSH
2850: EMPTY
2851: LIST
2852: LIST
2853: LIST
2854: LIST
2855: LIST
2856: LIST
2857: PPUSH
2858: CALL 71579 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 13 , 18 , 1 ] , [ b_solar_power , 17 , 3 , 0 ] , [ b_oil_mine , 56 , 23 , 0 ] , [ b_armoury , 42 , 29 , 5 ] , [ b_workshop , 11 , 7 , 2 ] , [ b_solar_power , 20 , 3 , 0 ] , [ b_solar_power , 23 , 3 , 0 ] , [ b_solar_power , 26 , 3 , 0 ] , [ b_lab , 17 , 27 , 1 ] , [ b_bunker , 27 , 44 , 5 ] , [ b_bunker , 41 , 41 , 5 ] , [ b_bunker , 45 , 24 , 5 ] , [ b_bunker , 48 , 19 , 5 ] , [ b_bunker , 41 , 3 , 4 ] , [ b_armoury , 44 , 9 , 4 ] , [ b_siberite_mine , 52 , 40 , 3 ] ] ) ;
2862: LD_INT 2
2864: PPUSH
2865: LD_INT 6
2867: PUSH
2868: LD_INT 13
2870: PUSH
2871: LD_INT 18
2873: PUSH
2874: LD_INT 1
2876: PUSH
2877: EMPTY
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: PUSH
2883: LD_INT 27
2885: PUSH
2886: LD_INT 17
2888: PUSH
2889: LD_INT 3
2891: PUSH
2892: LD_INT 0
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: LIST
2899: LIST
2900: PUSH
2901: LD_INT 29
2903: PUSH
2904: LD_INT 56
2906: PUSH
2907: LD_INT 23
2909: PUSH
2910: LD_INT 0
2912: PUSH
2913: EMPTY
2914: LIST
2915: LIST
2916: LIST
2917: LIST
2918: PUSH
2919: LD_INT 4
2921: PUSH
2922: LD_INT 42
2924: PUSH
2925: LD_INT 29
2927: PUSH
2928: LD_INT 5
2930: PUSH
2931: EMPTY
2932: LIST
2933: LIST
2934: LIST
2935: LIST
2936: PUSH
2937: LD_INT 2
2939: PUSH
2940: LD_INT 11
2942: PUSH
2943: LD_INT 7
2945: PUSH
2946: LD_INT 2
2948: PUSH
2949: EMPTY
2950: LIST
2951: LIST
2952: LIST
2953: LIST
2954: PUSH
2955: LD_INT 27
2957: PUSH
2958: LD_INT 20
2960: PUSH
2961: LD_INT 3
2963: PUSH
2964: LD_INT 0
2966: PUSH
2967: EMPTY
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: PUSH
2973: LD_INT 27
2975: PUSH
2976: LD_INT 23
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 0
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_INT 27
2993: PUSH
2994: LD_INT 26
2996: PUSH
2997: LD_INT 3
2999: PUSH
3000: LD_INT 0
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_INT 6
3011: PUSH
3012: LD_INT 17
3014: PUSH
3015: LD_INT 27
3017: PUSH
3018: LD_INT 1
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: PUSH
3027: LD_INT 32
3029: PUSH
3030: LD_INT 27
3032: PUSH
3033: LD_INT 44
3035: PUSH
3036: LD_INT 5
3038: PUSH
3039: EMPTY
3040: LIST
3041: LIST
3042: LIST
3043: LIST
3044: PUSH
3045: LD_INT 32
3047: PUSH
3048: LD_INT 41
3050: PUSH
3051: LD_INT 41
3053: PUSH
3054: LD_INT 5
3056: PUSH
3057: EMPTY
3058: LIST
3059: LIST
3060: LIST
3061: LIST
3062: PUSH
3063: LD_INT 32
3065: PUSH
3066: LD_INT 45
3068: PUSH
3069: LD_INT 24
3071: PUSH
3072: LD_INT 5
3074: PUSH
3075: EMPTY
3076: LIST
3077: LIST
3078: LIST
3079: LIST
3080: PUSH
3081: LD_INT 32
3083: PUSH
3084: LD_INT 48
3086: PUSH
3087: LD_INT 19
3089: PUSH
3090: LD_INT 5
3092: PUSH
3093: EMPTY
3094: LIST
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 32
3101: PUSH
3102: LD_INT 41
3104: PUSH
3105: LD_INT 3
3107: PUSH
3108: LD_INT 4
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: PUSH
3117: LD_INT 4
3119: PUSH
3120: LD_INT 44
3122: PUSH
3123: LD_INT 9
3125: PUSH
3126: LD_INT 4
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: LIST
3133: LIST
3134: PUSH
3135: LD_INT 30
3137: PUSH
3138: LD_INT 52
3140: PUSH
3141: LD_INT 40
3143: PUSH
3144: LD_INT 3
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: PUSH
3153: EMPTY
3154: LIST
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: LIST
3168: LIST
3169: LIST
3170: PPUSH
3171: CALL 71471 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_opto , b_lab_biological , b_lab_siberium ] ) ;
3175: LD_INT 2
3177: PPUSH
3178: LD_INT 10
3180: PUSH
3181: LD_INT 15
3183: PUSH
3184: LD_INT 13
3186: PUSH
3187: LD_INT 11
3189: PUSH
3190: EMPTY
3191: LIST
3192: LIST
3193: LIST
3194: LIST
3195: PPUSH
3196: CALL 72321 0 2
// MC_SetFactoryExtension ( 2 , 11 , 7 , 2 , [ b_ext_stitch , b_ext_track , b_ext_gun , b_ext_rocket , b_ext_radio ] ) ;
3200: LD_INT 2
3202: PPUSH
3203: LD_INT 11
3205: PPUSH
3206: LD_INT 7
3208: PPUSH
3209: LD_INT 2
3211: PPUSH
3212: LD_INT 23
3214: PUSH
3215: LD_INT 16
3217: PUSH
3218: LD_INT 17
3220: PUSH
3221: LD_INT 18
3223: PUSH
3224: LD_INT 22
3226: PUSH
3227: EMPTY
3228: LIST
3229: LIST
3230: LIST
3231: LIST
3232: LIST
3233: PPUSH
3234: CALL 72526 0 5
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
3238: LD_INT 2
3240: PPUSH
3241: LD_INT 0
3243: PPUSH
3244: CALL 72194 0 2
// end ;
3248: LD_VAR 0 1
3252: RET
// every 10 trigger staticMines and FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) do var i , j , tmp , x , y ;
3253: LD_EXP 3
3257: PUSH
3258: LD_INT 15
3260: PPUSH
3261: LD_INT 81
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PPUSH
3271: CALL_OW 70
3275: AND
3276: IFFALSE 3489
3278: GO 3280
3280: DISABLE
3281: LD_INT 0
3283: PPUSH
3284: PPUSH
3285: PPUSH
3286: PPUSH
3287: PPUSH
// begin enable ;
3288: ENABLE
// tmp := FilterUnitsInArea ( gensher_mines , [ f_enemy , 2 ] ) ;
3289: LD_ADDR_VAR 0 3
3293: PUSH
3294: LD_INT 15
3296: PPUSH
3297: LD_INT 81
3299: PUSH
3300: LD_INT 2
3302: PUSH
3303: EMPTY
3304: LIST
3305: LIST
3306: PPUSH
3307: CALL_OW 70
3311: ST_TO_ADDR
// if not tmp then
3312: LD_VAR 0 3
3316: NOT
3317: IFFALSE 3321
// exit ;
3319: GO 3489
// for i in tmp do
3321: LD_ADDR_VAR 0 1
3325: PUSH
3326: LD_VAR 0 3
3330: PUSH
3331: FOR_IN
3332: IFFALSE 3487
// begin x := GetX ( i ) ;
3334: LD_ADDR_VAR 0 4
3338: PUSH
3339: LD_VAR 0 1
3343: PPUSH
3344: CALL_OW 250
3348: ST_TO_ADDR
// y := GetY ( i ) ;
3349: LD_ADDR_VAR 0 5
3353: PUSH
3354: LD_VAR 0 1
3358: PPUSH
3359: CALL_OW 251
3363: ST_TO_ADDR
// if MineAtPos ( x , y ) then
3364: LD_VAR 0 4
3368: PPUSH
3369: LD_VAR 0 5
3373: PPUSH
3374: CALL_OW 458
3378: IFFALSE 3485
// begin LaunchMineAtPos ( x , y , 2 ) ;
3380: LD_VAR 0 4
3384: PPUSH
3385: LD_VAR 0 5
3389: PPUSH
3390: LD_INT 2
3392: PPUSH
3393: CALL_OW 456
// for j = 1 to staticMines do
3397: LD_ADDR_VAR 0 2
3401: PUSH
3402: DOUBLE
3403: LD_INT 1
3405: DEC
3406: ST_TO_ADDR
3407: LD_EXP 3
3411: PUSH
3412: FOR_TO
3413: IFFALSE 3483
// if staticMines [ j ] [ 1 ] = x and staticMines [ j ] [ 2 ] = y then
3415: LD_EXP 3
3419: PUSH
3420: LD_VAR 0 2
3424: ARRAY
3425: PUSH
3426: LD_INT 1
3428: ARRAY
3429: PUSH
3430: LD_VAR 0 4
3434: EQUAL
3435: PUSH
3436: LD_EXP 3
3440: PUSH
3441: LD_VAR 0 2
3445: ARRAY
3446: PUSH
3447: LD_INT 2
3449: ARRAY
3450: PUSH
3451: LD_VAR 0 5
3455: EQUAL
3456: AND
3457: IFFALSE 3481
// begin staticMines := Delete ( staticMines , j ) ;
3459: LD_ADDR_EXP 3
3463: PUSH
3464: LD_EXP 3
3468: PPUSH
3469: LD_VAR 0 2
3473: PPUSH
3474: CALL_OW 3
3478: ST_TO_ADDR
// break ;
3479: GO 3483
// end ;
3481: GO 3412
3483: POP
3484: POP
// end ; end ;
3485: GO 3331
3487: POP
3488: POP
// end ;
3489: PPOPN 5
3491: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ar_depot ) and not arDestroyed do var i , base , tmp , attackers , amount ;
3492: LD_INT 7
3494: PPUSH
3495: CALL_OW 302
3499: PUSH
3500: LD_EXP 4
3504: NOT
3505: AND
3506: IFFALSE 4110
3508: GO 3510
3510: DISABLE
3511: LD_INT 0
3513: PPUSH
3514: PPUSH
3515: PPUSH
3516: PPUSH
3517: PPUSH
// begin enable ;
3518: ENABLE
// base := 2 ;
3519: LD_ADDR_VAR 0 2
3523: PUSH
3524: LD_INT 2
3526: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_mortar ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] ] ;
3527: LD_ADDR_VAR 0 3
3531: PUSH
3532: LD_INT 14
3534: PUSH
3535: LD_INT 1
3537: PUSH
3538: LD_INT 2
3540: PUSH
3541: LD_INT 27
3543: PUSH
3544: EMPTY
3545: LIST
3546: LIST
3547: LIST
3548: LIST
3549: PUSH
3550: LD_INT 14
3552: PUSH
3553: LD_INT 1
3555: PUSH
3556: LD_INT 2
3558: PUSH
3559: LD_INT 27
3561: PUSH
3562: EMPTY
3563: LIST
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_INT 14
3570: PUSH
3571: LD_INT 1
3573: PUSH
3574: LD_INT 2
3576: PUSH
3577: LD_EXP 72
3581: PUSH
3582: EMPTY
3583: LIST
3584: LIST
3585: LIST
3586: LIST
3587: PUSH
3588: LD_INT 14
3590: PUSH
3591: LD_INT 1
3593: PUSH
3594: LD_INT 2
3596: PUSH
3597: LD_INT 26
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PUSH
3606: EMPTY
3607: LIST
3608: LIST
3609: LIST
3610: LIST
3611: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
3612: LD_ADDR_VAR 0 5
3616: PUSH
3617: LD_VAR 0 5
3621: PUSH
3622: LD_OWVAR 1
3626: PUSH
3627: LD_INT 21000
3629: DIV
3630: PLUS
3631: ST_TO_ADDR
// if amount > 8 then
3632: LD_VAR 0 5
3636: PUSH
3637: LD_INT 8
3639: GREATER
3640: IFFALSE 3650
// amount := 8 ;
3642: LD_ADDR_VAR 0 5
3646: PUSH
3647: LD_INT 8
3649: ST_TO_ADDR
// for i = 1 to amount do
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: DOUBLE
3656: LD_INT 1
3658: DEC
3659: ST_TO_ADDR
3660: LD_VAR 0 5
3664: PUSH
3665: FOR_TO
3666: IFFALSE 3754
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_half_tracked , ar_medium_trike ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_gatling_gun , ar_gun ] [ rand ( 1 , 3 ) ] ] ) ;
3668: LD_ADDR_VAR 0 3
3672: PUSH
3673: LD_VAR 0 3
3677: PPUSH
3678: LD_VAR 0 3
3682: PUSH
3683: LD_INT 1
3685: PLUS
3686: PPUSH
3687: LD_INT 14
3689: PUSH
3690: LD_INT 13
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 1
3699: PPUSH
3700: LD_INT 2
3702: PPUSH
3703: CALL_OW 12
3707: ARRAY
3708: PUSH
3709: LD_INT 1
3711: PUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 28
3717: PUSH
3718: LD_INT 25
3720: PUSH
3721: LD_INT 27
3723: PUSH
3724: EMPTY
3725: LIST
3726: LIST
3727: LIST
3728: PUSH
3729: LD_INT 1
3731: PPUSH
3732: LD_INT 3
3734: PPUSH
3735: CALL_OW 12
3739: ARRAY
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: PPUSH
3747: CALL_OW 2
3751: ST_TO_ADDR
3752: GO 3665
3754: POP
3755: POP
// MC_InsertProduceList ( base , tmp ) ;
3756: LD_VAR 0 2
3760: PPUSH
3761: LD_VAR 0 3
3765: PPUSH
3766: CALL 71627 0 2
// repeat wait ( 0 0$1 ) ;
3770: LD_INT 35
3772: PPUSH
3773: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3777: LD_VAR 0 2
3781: PPUSH
3782: LD_INT 1
3784: PPUSH
3785: CALL 73045 0 2
3789: PUSH
3790: LD_VAR 0 5
3794: GREATEREQUAL
3795: IFFALSE 3770
// wait ( 0 0$30 ) ;
3797: LD_INT 1050
3799: PPUSH
3800: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
3804: LD_ADDR_VAR 0 4
3808: PUSH
3809: LD_EXP 42
3813: PUSH
3814: LD_VAR 0 2
3818: ARRAY
3819: PUSH
3820: LD_EXP 42
3824: PUSH
3825: LD_VAR 0 2
3829: ARRAY
3830: PPUSH
3831: LD_INT 2
3833: PUSH
3834: LD_INT 34
3836: PUSH
3837: LD_INT 31
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: LD_INT 34
3846: PUSH
3847: LD_INT 32
3849: PUSH
3850: EMPTY
3851: LIST
3852: LIST
3853: PUSH
3854: LD_INT 34
3856: PUSH
3857: LD_EXP 73
3861: PUSH
3862: EMPTY
3863: LIST
3864: LIST
3865: PUSH
3866: EMPTY
3867: LIST
3868: LIST
3869: LIST
3870: LIST
3871: PPUSH
3872: CALL_OW 72
3876: DIFF
3877: ST_TO_ADDR
// if not attackers then
3878: LD_VAR 0 4
3882: NOT
3883: IFFALSE 3887
// exit ;
3885: GO 4110
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3887: LD_ADDR_EXP 42
3891: PUSH
3892: LD_EXP 42
3896: PPUSH
3897: LD_VAR 0 2
3901: PPUSH
3902: LD_EXP 42
3906: PUSH
3907: LD_VAR 0 2
3911: ARRAY
3912: PUSH
3913: LD_VAR 0 4
3917: DIFF
3918: PPUSH
3919: CALL_OW 1
3923: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
3924: LD_VAR 0 4
3928: PPUSH
3929: LD_INT 107
3931: PPUSH
3932: LD_INT 74
3934: PPUSH
3935: CALL_OW 114
// wait ( 0 0$5 ) ;
3939: LD_INT 175
3941: PPUSH
3942: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
3946: LD_INT 35
3948: PPUSH
3949: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3953: LD_VAR 0 4
3957: PPUSH
3958: LD_INT 60
3960: PUSH
3961: EMPTY
3962: LIST
3963: PPUSH
3964: CALL_OW 72
3968: NOT
3969: IFFALSE 3946
// if rand ( 0 , 1 ) then
3971: LD_INT 0
3973: PPUSH
3974: LD_INT 1
3976: PPUSH
3977: CALL_OW 12
3981: IFFALSE 4000
// ComAgressiveMove ( attackers , 155 , 108 ) else
3983: LD_VAR 0 4
3987: PPUSH
3988: LD_INT 155
3990: PPUSH
3991: LD_INT 108
3993: PPUSH
3994: CALL_OW 114
3998: GO 4015
// ComAgressiveMove ( attackers , 149 , 55 ) ;
4000: LD_VAR 0 4
4004: PPUSH
4005: LD_INT 149
4007: PPUSH
4008: LD_INT 55
4010: PPUSH
4011: CALL_OW 114
// wait ( 0 0$10 ) ;
4015: LD_INT 350
4017: PPUSH
4018: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
4022: LD_INT 35
4024: PPUSH
4025: CALL_OW 67
// for i in attackers do
4029: LD_ADDR_VAR 0 1
4033: PUSH
4034: LD_VAR 0 4
4038: PUSH
4039: FOR_IN
4040: IFFALSE 4090
// if not HasTask ( i ) then
4042: LD_VAR 0 1
4046: PPUSH
4047: CALL_OW 314
4051: NOT
4052: IFFALSE 4088
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4054: LD_VAR 0 1
4058: PPUSH
4059: LD_INT 81
4061: PUSH
4062: LD_INT 2
4064: PUSH
4065: EMPTY
4066: LIST
4067: LIST
4068: PPUSH
4069: CALL_OW 69
4073: PPUSH
4074: LD_VAR 0 1
4078: PPUSH
4079: CALL_OW 74
4083: PPUSH
4084: CALL_OW 115
4088: GO 4039
4090: POP
4091: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
4092: LD_VAR 0 4
4096: PPUSH
4097: LD_INT 50
4099: PUSH
4100: EMPTY
4101: LIST
4102: PPUSH
4103: CALL_OW 72
4107: NOT
4108: IFFALSE 4022
// end ;
4110: PPOPN 5
4112: END
// every 15 15$00 + 8 8$00 trigger not arDestroyed and tick < 81 81$00 do var i , un , tmp ;
4113: LD_EXP 4
4117: NOT
4118: PUSH
4119: LD_OWVAR 1
4123: PUSH
4124: LD_INT 170100
4126: LESS
4127: AND
4128: IFFALSE 4780
4130: GO 4132
4132: DISABLE
4133: LD_INT 0
4135: PPUSH
4136: PPUSH
4137: PPUSH
// begin enable ;
4138: ENABLE
// tmp := [ ] ;
4139: LD_ADDR_VAR 0 3
4143: PUSH
4144: EMPTY
4145: ST_TO_ADDR
// if tick < 35 35$00 then
4146: LD_OWVAR 1
4150: PUSH
4151: LD_INT 73500
4153: LESS
4154: IFFALSE 4352
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
4156: LD_ADDR_VAR 0 1
4160: PUSH
4161: DOUBLE
4162: LD_INT 1
4164: DEC
4165: ST_TO_ADDR
4166: LD_INT 4
4168: PUSH
4169: LD_INT 5
4171: PUSH
4172: LD_INT 5
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: LD_OWVAR 67
4184: ARRAY
4185: PUSH
4186: FOR_TO
4187: IFFALSE 4348
// begin uc_side := 2 ;
4189: LD_ADDR_OWVAR 20
4193: PUSH
4194: LD_INT 2
4196: ST_TO_ADDR
// uc_nation := 2 ;
4197: LD_ADDR_OWVAR 21
4201: PUSH
4202: LD_INT 2
4204: ST_TO_ADDR
// InitHC_All ( ) ;
4205: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
4209: LD_INT 0
4211: PPUSH
4212: LD_INT 1
4214: PPUSH
4215: LD_INT 5
4217: PUSH
4218: LD_INT 6
4220: PUSH
4221: LD_INT 7
4223: PUSH
4224: EMPTY
4225: LIST
4226: LIST
4227: LIST
4228: PUSH
4229: LD_OWVAR 67
4233: ARRAY
4234: PPUSH
4235: CALL_OW 380
// un := CreateHuman ;
4239: LD_ADDR_VAR 0 2
4243: PUSH
4244: CALL_OW 44
4248: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4249: LD_VAR 0 2
4253: PPUSH
4254: LD_INT 17
4256: PPUSH
4257: LD_INT 0
4259: PPUSH
4260: CALL_OW 49
// SetClass ( un , [ class_soldier , class_mortar ] [ rand ( 1 , 2 ) ] ) ;
4264: LD_VAR 0 2
4268: PPUSH
4269: LD_INT 1
4271: PUSH
4272: LD_INT 8
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 1
4281: PPUSH
4282: LD_INT 2
4284: PPUSH
4285: CALL_OW 12
4289: ARRAY
4290: PPUSH
4291: CALL_OW 336
// ComAgressiveMove ( un , 111 , 34 ) ;
4295: LD_VAR 0 2
4299: PPUSH
4300: LD_INT 111
4302: PPUSH
4303: LD_INT 34
4305: PPUSH
4306: CALL_OW 114
// wait ( 0 0$2 ) ;
4310: LD_INT 70
4312: PPUSH
4313: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
4317: LD_ADDR_VAR 0 3
4321: PUSH
4322: LD_VAR 0 3
4326: PPUSH
4327: LD_VAR 0 3
4331: PUSH
4332: LD_INT 1
4334: PLUS
4335: PPUSH
4336: LD_VAR 0 2
4340: PPUSH
4341: CALL_OW 1
4345: ST_TO_ADDR
// end ;
4346: GO 4186
4348: POP
4349: POP
// end else
4350: GO 4493
// begin for i := 1 to [ 4 , 5 , 5 ] [ Difficulty ] do
4352: LD_ADDR_VAR 0 1
4356: PUSH
4357: DOUBLE
4358: LD_INT 1
4360: DEC
4361: ST_TO_ADDR
4362: LD_INT 4
4364: PUSH
4365: LD_INT 5
4367: PUSH
4368: LD_INT 5
4370: PUSH
4371: EMPTY
4372: LIST
4373: LIST
4374: LIST
4375: PUSH
4376: LD_OWVAR 67
4380: ARRAY
4381: PUSH
4382: FOR_TO
4383: IFFALSE 4491
// begin uc_side := 2 ;
4385: LD_ADDR_OWVAR 20
4389: PUSH
4390: LD_INT 2
4392: ST_TO_ADDR
// uc_nation := 0 ;
4393: LD_ADDR_OWVAR 21
4397: PUSH
4398: LD_INT 0
4400: ST_TO_ADDR
// InitHC_All ( ) ;
4401: CALL_OW 584
// hc_class := class_apeman_kamikaze ;
4405: LD_ADDR_OWVAR 28
4409: PUSH
4410: LD_INT 17
4412: ST_TO_ADDR
// un := CreateHuman ;
4413: LD_ADDR_VAR 0 2
4417: PUSH
4418: CALL_OW 44
4422: ST_TO_ADDR
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4423: LD_VAR 0 2
4427: PPUSH
4428: LD_INT 17
4430: PPUSH
4431: LD_INT 0
4433: PPUSH
4434: CALL_OW 49
// ComAgressiveMove ( un , 110 , 33 ) ;
4438: LD_VAR 0 2
4442: PPUSH
4443: LD_INT 110
4445: PPUSH
4446: LD_INT 33
4448: PPUSH
4449: CALL_OW 114
// wait ( 0 0$2 ) ;
4453: LD_INT 70
4455: PPUSH
4456: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
4460: LD_ADDR_VAR 0 3
4464: PUSH
4465: LD_VAR 0 3
4469: PPUSH
4470: LD_VAR 0 3
4474: PUSH
4475: LD_INT 1
4477: PLUS
4478: PPUSH
4479: LD_VAR 0 2
4483: PPUSH
4484: CALL_OW 1
4488: ST_TO_ADDR
// end ;
4489: GO 4382
4491: POP
4492: POP
// end ; for i := 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
4493: LD_ADDR_VAR 0 1
4497: PUSH
4498: DOUBLE
4499: LD_INT 1
4501: DEC
4502: ST_TO_ADDR
4503: LD_INT 3
4505: PUSH
4506: LD_INT 4
4508: PUSH
4509: LD_INT 5
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: PUSH
4517: LD_OWVAR 67
4521: ARRAY
4522: PUSH
4523: FOR_TO
4524: IFFALSE 4658
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_rocket_launcher , ar_gun ] [ rand ( 1 , 3 ) ] , 90 ) ;
4526: LD_INT 14
4528: PPUSH
4529: LD_INT 3
4531: PPUSH
4532: LD_INT 5
4534: PPUSH
4535: LD_INT 29
4537: PUSH
4538: LD_INT 28
4540: PUSH
4541: LD_INT 27
4543: PUSH
4544: EMPTY
4545: LIST
4546: LIST
4547: LIST
4548: PUSH
4549: LD_INT 1
4551: PPUSH
4552: LD_INT 3
4554: PPUSH
4555: CALL_OW 12
4559: ARRAY
4560: PPUSH
4561: LD_INT 90
4563: PPUSH
4564: CALL 13938 0 5
// un := CreateVehicle ;
4568: LD_ADDR_VAR 0 2
4572: PUSH
4573: CALL_OW 45
4577: ST_TO_ADDR
// SetDir ( un , 2 ) ;
4578: LD_VAR 0 2
4582: PPUSH
4583: LD_INT 2
4585: PPUSH
4586: CALL_OW 233
// PlaceUnitArea ( un , gensher_spawn , false ) ;
4590: LD_VAR 0 2
4594: PPUSH
4595: LD_INT 17
4597: PPUSH
4598: LD_INT 0
4600: PPUSH
4601: CALL_OW 49
// ComMoveXY ( un , 66 , 23 ) ;
4605: LD_VAR 0 2
4609: PPUSH
4610: LD_INT 66
4612: PPUSH
4613: LD_INT 23
4615: PPUSH
4616: CALL_OW 111
// wait ( 0 0$3 ) ;
4620: LD_INT 105
4622: PPUSH
4623: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
4627: LD_ADDR_VAR 0 3
4631: PUSH
4632: LD_VAR 0 3
4636: PPUSH
4637: LD_VAR 0 3
4641: PUSH
4642: LD_INT 1
4644: PLUS
4645: PPUSH
4646: LD_VAR 0 2
4650: PPUSH
4651: CALL_OW 1
4655: ST_TO_ADDR
// end ;
4656: GO 4523
4658: POP
4659: POP
// if not tmp then
4660: LD_VAR 0 3
4664: NOT
4665: IFFALSE 4669
// exit ;
4667: GO 4780
// wait ( 0 0$5 ) ;
4669: LD_INT 175
4671: PPUSH
4672: CALL_OW 67
// repeat wait ( 0 0$3 ) ;
4676: LD_INT 105
4678: PPUSH
4679: CALL_OW 67
// for i in tmp do
4683: LD_ADDR_VAR 0 1
4687: PUSH
4688: LD_VAR 0 3
4692: PUSH
4693: FOR_IN
4694: IFFALSE 4771
// begin if not IsOk ( i ) or IsDead ( i ) then
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 302
4705: NOT
4706: PUSH
4707: LD_VAR 0 1
4711: PPUSH
4712: CALL_OW 301
4716: OR
4717: IFFALSE 4735
// tmp := tmp diff i ;
4719: LD_ADDR_VAR 0 3
4723: PUSH
4724: LD_VAR 0 3
4728: PUSH
4729: LD_VAR 0 1
4733: DIFF
4734: ST_TO_ADDR
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
4735: LD_VAR 0 1
4739: PPUSH
4740: LD_INT 81
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: EMPTY
4747: LIST
4748: LIST
4749: PPUSH
4750: CALL_OW 69
4754: PPUSH
4755: LD_VAR 0 1
4759: PPUSH
4760: CALL_OW 74
4764: PPUSH
4765: CALL_OW 115
// end ;
4769: GO 4693
4771: POP
4772: POP
// until not tmp ;
4773: LD_VAR 0 3
4777: NOT
4778: IFFALSE 4676
// end ; end_of_file
4780: PPOPN 3
4782: END
// export Popov , popov_side , extraPopovForces , popovAttackGroup ; export function PreparePopov ; var i , un , tmp ; begin
4783: LD_INT 0
4785: PPUSH
4786: PPUSH
4787: PPUSH
4788: PPUSH
// popov_side := 3 ;
4789: LD_ADDR_EXP 17
4793: PUSH
4794: LD_INT 3
4796: ST_TO_ADDR
// uc_side := popov_side ;
4797: LD_ADDR_OWVAR 20
4801: PUSH
4802: LD_EXP 17
4806: ST_TO_ADDR
// uc_nation := 3 ;
4807: LD_ADDR_OWVAR 21
4811: PUSH
4812: LD_INT 3
4814: ST_TO_ADDR
// tmp := PrepareBase ( ru_depot , popov_base ,  , [ 8 , 7 , 6 ] [ Difficulty ] , [ 4500 , 600 , 60 ] , [ 6 , 6 , 6 , 6 ] ) ;
4815: LD_ADDR_VAR 0 4
4819: PUSH
4820: LD_INT 9
4822: PPUSH
4823: LD_INT 3
4825: PPUSH
4826: LD_STRING 
4828: PPUSH
4829: LD_INT 8
4831: PUSH
4832: LD_INT 7
4834: PUSH
4835: LD_INT 6
4837: PUSH
4838: EMPTY
4839: LIST
4840: LIST
4841: LIST
4842: PUSH
4843: LD_OWVAR 67
4847: ARRAY
4848: PPUSH
4849: LD_INT 4500
4851: PUSH
4852: LD_INT 600
4854: PUSH
4855: LD_INT 60
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: LIST
4862: PPUSH
4863: LD_INT 6
4865: PUSH
4866: LD_INT 6
4868: PUSH
4869: LD_INT 6
4871: PUSH
4872: LD_INT 6
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: LIST
4880: PPUSH
4881: CALL 17385 0 6
4885: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 3 , tmp ) ;
4886: LD_ADDR_EXP 23
4890: PUSH
4891: LD_EXP 23
4895: PPUSH
4896: LD_INT 3
4898: PPUSH
4899: LD_VAR 0 4
4903: PPUSH
4904: CALL_OW 1
4908: ST_TO_ADDR
// extraPopovForces := [ ] ;
4909: LD_ADDR_EXP 18
4913: PUSH
4914: EMPTY
4915: ST_TO_ADDR
// for i := 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
4916: LD_ADDR_VAR 0 2
4920: PUSH
4921: DOUBLE
4922: LD_INT 1
4924: DEC
4925: ST_TO_ADDR
4926: LD_INT 5
4928: PUSH
4929: LD_INT 6
4931: PUSH
4932: LD_INT 7
4934: PUSH
4935: EMPTY
4936: LIST
4937: LIST
4938: LIST
4939: PUSH
4940: LD_OWVAR 67
4944: ARRAY
4945: PUSH
4946: FOR_TO
4947: IFFALSE 5050
// begin PrepareHuman ( false , 1 , [ 4 , 5 , 6 ] [ Difficulty ] ) ;
4949: LD_INT 0
4951: PPUSH
4952: LD_INT 1
4954: PPUSH
4955: LD_INT 4
4957: PUSH
4958: LD_INT 5
4960: PUSH
4961: LD_INT 6
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: LIST
4968: PUSH
4969: LD_OWVAR 67
4973: ARRAY
4974: PPUSH
4975: CALL_OW 380
// un := CreateHuman ;
4979: LD_ADDR_VAR 0 3
4983: PUSH
4984: CALL_OW 44
4988: ST_TO_ADDR
// PlaceUnitXYR ( un , 131 , 110 , 8 , false ) ;
4989: LD_VAR 0 3
4993: PPUSH
4994: LD_INT 131
4996: PPUSH
4997: LD_INT 110
4999: PPUSH
5000: LD_INT 8
5002: PPUSH
5003: LD_INT 0
5005: PPUSH
5006: CALL_OW 50
// ComHold ( un ) ;
5010: LD_VAR 0 3
5014: PPUSH
5015: CALL_OW 140
// extraPopovForces := Replace ( extraPopovForces , extraPopovForces + 1 , un ) ;
5019: LD_ADDR_EXP 18
5023: PUSH
5024: LD_EXP 18
5028: PPUSH
5029: LD_EXP 18
5033: PUSH
5034: LD_INT 1
5036: PLUS
5037: PPUSH
5038: LD_VAR 0 3
5042: PPUSH
5043: CALL_OW 1
5047: ST_TO_ADDR
// end ;
5048: GO 4946
5050: POP
5051: POP
// PrepareSoldier ( false , 6 ) ;
5052: LD_INT 0
5054: PPUSH
5055: LD_INT 6
5057: PPUSH
5058: CALL_OW 381
// un := CreateHuman ;
5062: LD_ADDR_VAR 0 3
5066: PUSH
5067: CALL_OW 44
5071: ST_TO_ADDR
// SetDir ( un , 1 ) ;
5072: LD_VAR 0 3
5076: PPUSH
5077: LD_INT 1
5079: PPUSH
5080: CALL_OW 233
// PlaceHumanInUnit ( un , HexInfo ( 150 , 158 ) ) ;
5084: LD_VAR 0 3
5088: PPUSH
5089: LD_INT 150
5091: PPUSH
5092: LD_INT 158
5094: PPUSH
5095: CALL_OW 428
5099: PPUSH
5100: CALL_OW 52
// popovAttackGroup := [ ] ;
5104: LD_ADDR_EXP 19
5108: PUSH
5109: EMPTY
5110: ST_TO_ADDR
// end ;
5111: LD_VAR 0 1
5115: RET
// export function InitMC_Popov ( ) ; begin
5116: LD_INT 0
5118: PPUSH
// MC_SetScanArea ( 3 , popov_base ) ;
5119: LD_INT 3
5121: PPUSH
5122: LD_INT 3
5124: PPUSH
5125: CALL 72900 0 2
// MC_SetParkingArea ( 3 , popov_parking ) ;
5129: LD_INT 3
5131: PPUSH
5132: LD_INT 10
5134: PPUSH
5135: CALL 72844 0 2
// MC_SetDepositsXY ( 3 , [ [ 86 , 118 , 0 ] , [ 123 , 151 , 1 ] , [ 98 , 121 , 0 ] ] ) ;
5139: LD_INT 3
5141: PPUSH
5142: LD_INT 86
5144: PUSH
5145: LD_INT 118
5147: PUSH
5148: LD_INT 0
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 123
5158: PUSH
5159: LD_INT 151
5161: PUSH
5162: LD_INT 1
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: PUSH
5170: LD_INT 98
5172: PUSH
5173: LD_INT 121
5175: PUSH
5176: LD_INT 0
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: LIST
5183: PUSH
5184: EMPTY
5185: LIST
5186: LIST
5187: LIST
5188: PPUSH
5189: CALL 71903 0 2
// MC_SetAllowedTurretWeapons ( 3 , [ ru_heavy_gun , ru_rocket_launcher ] ) ;
5193: LD_INT 3
5195: PPUSH
5196: LD_INT 46
5198: PUSH
5199: LD_INT 45
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL 72732 0 2
// MC_SetCratesArea ( 3 , popov_crates ) ;
5210: LD_INT 3
5212: PPUSH
5213: LD_INT 12
5215: PPUSH
5216: CALL 72414 0 2
// MC_SetTame ( 3 , popov_ape ) ;
5220: LD_INT 3
5222: PPUSH
5223: LD_INT 11
5225: PPUSH
5226: CALL 72145 0 2
// MC_SetDefenderLimit ( 3 , 4 ) ;
5230: LD_INT 3
5232: PPUSH
5233: LD_INT 4
5235: PPUSH
5236: CALL 71764 0 2
// MC_SetProduceList ( 3 , [ [ ru_heavy_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_gun ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] ] ) ;
5240: LD_INT 3
5242: PPUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 1
5248: PUSH
5249: LD_INT 3
5251: PUSH
5252: LD_INT 44
5254: PUSH
5255: EMPTY
5256: LIST
5257: LIST
5258: LIST
5259: LIST
5260: PUSH
5261: LD_INT 23
5263: PUSH
5264: LD_INT 1
5266: PUSH
5267: LD_INT 3
5269: PUSH
5270: LD_INT 45
5272: PUSH
5273: EMPTY
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: PUSH
5279: LD_INT 21
5281: PUSH
5282: LD_INT 1
5284: PUSH
5285: LD_INT 3
5287: PUSH
5288: LD_INT 44
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: LIST
5296: PUSH
5297: LD_INT 21
5299: PUSH
5300: LD_INT 1
5302: PUSH
5303: LD_INT 3
5305: PUSH
5306: LD_INT 45
5308: PUSH
5309: EMPTY
5310: LIST
5311: LIST
5312: LIST
5313: LIST
5314: PUSH
5315: EMPTY
5316: LIST
5317: LIST
5318: LIST
5319: LIST
5320: PPUSH
5321: CALL 71579 0 2
// MC_SetBuildingList ( 3 , [ [ b_lab , 76 , 145 , 1 ] , [ b_oil_power , 87 , 144 , 0 ] , [ b_oil_mine , 86 , 118 , 0 ] , [ b_oil_mine , 98 , 121 , 0 ] , [ b_oil_power , 87 , 147 , 1 ] , [ b_workshop , 94 , 161 , 0 ] , [ b_lab , 81 , 155 , 1 ] , [ b_armoury , 103 , 147 , 3 ] , [ b_oil_power , 96 , 152 , 0 ] , [ b_oil_power , 96 , 149 , 3 ] , [ b_bunker , 109 , 142 , 3 ] , [ b_bunker , 112 , 148 , 3 ] , [ b_turret , 120 , 159 , 4 ] , [ b_turret , 122 , 163 , 4 ] , [ b_turret , 123 , 167 , 4 ] , [ b_turret , 59 , 111 , 3 ] , [ b_turret , 65 , 111 , 3 ] , [ b_turret , 76 , 117 , 3 ] , [ b_turret , 80 , 119 , 3 ] , [ b_turret , 87 , 125 , 3 ] , [ b_armoury , 92 , 129 , 3 ] , [ b_siberite_power , 85 , 165 , 0 ] , [ b_siberite_power , 83 , 161 , 4 ] , [ b_siberite_power , 91 , 166 , 3 ] , [ b_siberite_power , 102 , 166 , 2 ] ] ) ;
5325: LD_INT 3
5327: PPUSH
5328: LD_INT 6
5330: PUSH
5331: LD_INT 76
5333: PUSH
5334: LD_INT 145
5336: PUSH
5337: LD_INT 1
5339: PUSH
5340: EMPTY
5341: LIST
5342: LIST
5343: LIST
5344: LIST
5345: PUSH
5346: LD_INT 26
5348: PUSH
5349: LD_INT 87
5351: PUSH
5352: LD_INT 144
5354: PUSH
5355: LD_INT 0
5357: PUSH
5358: EMPTY
5359: LIST
5360: LIST
5361: LIST
5362: LIST
5363: PUSH
5364: LD_INT 29
5366: PUSH
5367: LD_INT 86
5369: PUSH
5370: LD_INT 118
5372: PUSH
5373: LD_INT 0
5375: PUSH
5376: EMPTY
5377: LIST
5378: LIST
5379: LIST
5380: LIST
5381: PUSH
5382: LD_INT 29
5384: PUSH
5385: LD_INT 98
5387: PUSH
5388: LD_INT 121
5390: PUSH
5391: LD_INT 0
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: LD_INT 26
5402: PUSH
5403: LD_INT 87
5405: PUSH
5406: LD_INT 147
5408: PUSH
5409: LD_INT 1
5411: PUSH
5412: EMPTY
5413: LIST
5414: LIST
5415: LIST
5416: LIST
5417: PUSH
5418: LD_INT 2
5420: PUSH
5421: LD_INT 94
5423: PUSH
5424: LD_INT 161
5426: PUSH
5427: LD_INT 0
5429: PUSH
5430: EMPTY
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: PUSH
5436: LD_INT 6
5438: PUSH
5439: LD_INT 81
5441: PUSH
5442: LD_INT 155
5444: PUSH
5445: LD_INT 1
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: PUSH
5454: LD_INT 4
5456: PUSH
5457: LD_INT 103
5459: PUSH
5460: LD_INT 147
5462: PUSH
5463: LD_INT 3
5465: PUSH
5466: EMPTY
5467: LIST
5468: LIST
5469: LIST
5470: LIST
5471: PUSH
5472: LD_INT 26
5474: PUSH
5475: LD_INT 96
5477: PUSH
5478: LD_INT 152
5480: PUSH
5481: LD_INT 0
5483: PUSH
5484: EMPTY
5485: LIST
5486: LIST
5487: LIST
5488: LIST
5489: PUSH
5490: LD_INT 26
5492: PUSH
5493: LD_INT 96
5495: PUSH
5496: LD_INT 149
5498: PUSH
5499: LD_INT 3
5501: PUSH
5502: EMPTY
5503: LIST
5504: LIST
5505: LIST
5506: LIST
5507: PUSH
5508: LD_INT 32
5510: PUSH
5511: LD_INT 109
5513: PUSH
5514: LD_INT 142
5516: PUSH
5517: LD_INT 3
5519: PUSH
5520: EMPTY
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: PUSH
5526: LD_INT 32
5528: PUSH
5529: LD_INT 112
5531: PUSH
5532: LD_INT 148
5534: PUSH
5535: LD_INT 3
5537: PUSH
5538: EMPTY
5539: LIST
5540: LIST
5541: LIST
5542: LIST
5543: PUSH
5544: LD_INT 33
5546: PUSH
5547: LD_INT 120
5549: PUSH
5550: LD_INT 159
5552: PUSH
5553: LD_INT 4
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: LIST
5560: LIST
5561: PUSH
5562: LD_INT 33
5564: PUSH
5565: LD_INT 122
5567: PUSH
5568: LD_INT 163
5570: PUSH
5571: LD_INT 4
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: PUSH
5580: LD_INT 33
5582: PUSH
5583: LD_INT 123
5585: PUSH
5586: LD_INT 167
5588: PUSH
5589: LD_INT 4
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 33
5600: PUSH
5601: LD_INT 59
5603: PUSH
5604: LD_INT 111
5606: PUSH
5607: LD_INT 3
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: PUSH
5616: LD_INT 33
5618: PUSH
5619: LD_INT 65
5621: PUSH
5622: LD_INT 111
5624: PUSH
5625: LD_INT 3
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: PUSH
5634: LD_INT 33
5636: PUSH
5637: LD_INT 76
5639: PUSH
5640: LD_INT 117
5642: PUSH
5643: LD_INT 3
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 33
5654: PUSH
5655: LD_INT 80
5657: PUSH
5658: LD_INT 119
5660: PUSH
5661: LD_INT 3
5663: PUSH
5664: EMPTY
5665: LIST
5666: LIST
5667: LIST
5668: LIST
5669: PUSH
5670: LD_INT 33
5672: PUSH
5673: LD_INT 87
5675: PUSH
5676: LD_INT 125
5678: PUSH
5679: LD_INT 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 4
5690: PUSH
5691: LD_INT 92
5693: PUSH
5694: LD_INT 129
5696: PUSH
5697: LD_INT 3
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: LIST
5705: PUSH
5706: LD_INT 28
5708: PUSH
5709: LD_INT 85
5711: PUSH
5712: LD_INT 165
5714: PUSH
5715: LD_INT 0
5717: PUSH
5718: EMPTY
5719: LIST
5720: LIST
5721: LIST
5722: LIST
5723: PUSH
5724: LD_INT 28
5726: PUSH
5727: LD_INT 83
5729: PUSH
5730: LD_INT 161
5732: PUSH
5733: LD_INT 4
5735: PUSH
5736: EMPTY
5737: LIST
5738: LIST
5739: LIST
5740: LIST
5741: PUSH
5742: LD_INT 28
5744: PUSH
5745: LD_INT 91
5747: PUSH
5748: LD_INT 166
5750: PUSH
5751: LD_INT 3
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: LIST
5758: LIST
5759: PUSH
5760: LD_INT 28
5762: PUSH
5763: LD_INT 102
5765: PUSH
5766: LD_INT 166
5768: PUSH
5769: LD_INT 2
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: LIST
5777: PUSH
5778: EMPTY
5779: LIST
5780: LIST
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: LIST
5791: LIST
5792: LIST
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: LIST
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: LIST
5803: LIST
5804: PPUSH
5805: CALL 71471 0 2
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_siberium ] ) ;
5809: LD_INT 3
5811: PPUSH
5812: LD_INT 10
5814: PUSH
5815: LD_INT 12
5817: PUSH
5818: LD_INT 14
5820: PUSH
5821: LD_INT 11
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: LIST
5829: PPUSH
5830: CALL 72321 0 2
// MC_SetFactoryExtension ( 3 , 94 , 161 , 0 , [ b_ext_noncombat , b_ext_gun , b_ext_rocket , b_ext_computer , b_ext_siberium ] ) ;
5834: LD_INT 3
5836: PPUSH
5837: LD_INT 94
5839: PPUSH
5840: LD_INT 161
5842: PPUSH
5843: LD_INT 0
5845: PPUSH
5846: LD_INT 19
5848: PUSH
5849: LD_INT 17
5851: PUSH
5852: LD_INT 18
5854: PUSH
5855: LD_INT 24
5857: PUSH
5858: LD_INT 21
5860: PUSH
5861: EMPTY
5862: LIST
5863: LIST
5864: LIST
5865: LIST
5866: LIST
5867: PPUSH
5868: CALL 72526 0 5
// MC_SetUpgradeBuilding ( 3 , b_depot ) ;
5872: LD_INT 3
5874: PPUSH
5875: LD_INT 0
5877: PPUSH
5878: CALL 72194 0 2
// MC_InsertProduceList ( 3 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
5882: LD_INT 3
5884: PPUSH
5885: LD_INT 21
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 3
5893: PUSH
5894: LD_INT 51
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: EMPTY
5904: LIST
5905: PPUSH
5906: CALL 71627 0 2
// end ;
5910: LD_VAR 0 1
5914: RET
// every 6 6$00 trigger extraPopovForces and not ruDestroyed do
5915: LD_EXP 18
5919: PUSH
5920: LD_EXP 5
5924: NOT
5925: AND
5926: IFFALSE 5986
5928: GO 5930
5930: DISABLE
// begin ComMoveXY ( extraPopovForces , 106 , 137 ) ;
5931: LD_EXP 18
5935: PPUSH
5936: LD_INT 106
5938: PPUSH
5939: LD_INT 137
5941: PPUSH
5942: CALL_OW 111
// mc_bases := Replace ( mc_bases , 3 , mc_bases [ 3 ] union extraPopovForces ) ;
5946: LD_ADDR_EXP 23
5950: PUSH
5951: LD_EXP 23
5955: PPUSH
5956: LD_INT 3
5958: PPUSH
5959: LD_EXP 23
5963: PUSH
5964: LD_INT 3
5966: ARRAY
5967: PUSH
5968: LD_EXP 18
5972: UNION
5973: PPUSH
5974: CALL_OW 1
5978: ST_TO_ADDR
// extraPopovForces := [ ] ;
5979: LD_ADDR_EXP 18
5983: PUSH
5984: EMPTY
5985: ST_TO_ADDR
// end ;
5986: END
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and not ruDestroyed do var i , base , tmp , attackers , amount ;
5987: LD_INT 9
5989: PPUSH
5990: CALL_OW 302
5994: PUSH
5995: LD_EXP 5
5999: NOT
6000: AND
6001: IFFALSE 6567
6003: GO 6005
6005: DISABLE
6006: LD_INT 0
6008: PPUSH
6009: PPUSH
6010: PPUSH
6011: PPUSH
6012: PPUSH
// begin enable ;
6013: ENABLE
// base := 3 ;
6014: LD_ADDR_VAR 0 2
6018: PUSH
6019: LD_INT 3
6021: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_heavy_gun ] ] ;
6022: LD_ADDR_VAR 0 3
6026: PUSH
6027: LD_INT 22
6029: PUSH
6030: LD_INT 1
6032: PUSH
6033: LD_INT 3
6035: PUSH
6036: LD_INT 44
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 24
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: LD_INT 3
6053: PUSH
6054: LD_INT 46
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: PUSH
6063: LD_INT 24
6065: PUSH
6066: LD_INT 1
6068: PUSH
6069: LD_INT 3
6071: PUSH
6072: LD_INT 46
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: LIST
6079: LIST
6080: PUSH
6081: LD_INT 24
6083: PUSH
6084: LD_INT 1
6086: PUSH
6087: LD_INT 3
6089: PUSH
6090: LD_INT 46
6092: PUSH
6093: EMPTY
6094: LIST
6095: LIST
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: LIST
6104: ST_TO_ADDR
// amount := amount + tick div 10 10$00 ;
6105: LD_ADDR_VAR 0 5
6109: PUSH
6110: LD_VAR 0 5
6114: PUSH
6115: LD_OWVAR 1
6119: PUSH
6120: LD_INT 21000
6122: DIV
6123: PLUS
6124: ST_TO_ADDR
// if amount > 8 then
6125: LD_VAR 0 5
6129: PUSH
6130: LD_INT 8
6132: GREATER
6133: IFFALSE 6143
// amount := 8 ;
6135: LD_ADDR_VAR 0 5
6139: PUSH
6140: LD_INT 8
6142: ST_TO_ADDR
// for i = 1 to amount do
6143: LD_ADDR_VAR 0 1
6147: PUSH
6148: DOUBLE
6149: LD_INT 1
6151: DEC
6152: ST_TO_ADDR
6153: LD_VAR 0 5
6157: PUSH
6158: FOR_TO
6159: IFFALSE 6224
// tmp := Insert ( tmp , tmp + 1 , [ ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
6161: LD_ADDR_VAR 0 3
6165: PUSH
6166: LD_VAR 0 3
6170: PPUSH
6171: LD_VAR 0 3
6175: PUSH
6176: LD_INT 1
6178: PLUS
6179: PPUSH
6180: LD_INT 24
6182: PUSH
6183: LD_INT 1
6185: PUSH
6186: LD_INT 3
6188: PUSH
6189: LD_INT 46
6191: PUSH
6192: LD_INT 45
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: PUSH
6199: LD_INT 1
6201: PPUSH
6202: LD_INT 2
6204: PPUSH
6205: CALL_OW 12
6209: ARRAY
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: LIST
6215: LIST
6216: PPUSH
6217: CALL_OW 2
6221: ST_TO_ADDR
6222: GO 6158
6224: POP
6225: POP
// MC_InsertProduceList ( base , tmp ) ;
6226: LD_VAR 0 2
6230: PPUSH
6231: LD_VAR 0 3
6235: PPUSH
6236: CALL 71627 0 2
// repeat wait ( 0 0$1 ) ;
6240: LD_INT 35
6242: PPUSH
6243: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
6247: LD_VAR 0 2
6251: PPUSH
6252: LD_INT 1
6254: PPUSH
6255: CALL 73045 0 2
6259: PUSH
6260: LD_VAR 0 5
6264: GREATEREQUAL
6265: IFFALSE 6240
// wait ( 0 0$30 ) ;
6267: LD_INT 1050
6269: PPUSH
6270: CALL_OW 67
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
6274: LD_ADDR_VAR 0 4
6278: PUSH
6279: LD_EXP 42
6283: PUSH
6284: LD_VAR 0 2
6288: ARRAY
6289: PUSH
6290: LD_EXP 42
6294: PUSH
6295: LD_VAR 0 2
6299: ARRAY
6300: PPUSH
6301: LD_INT 2
6303: PUSH
6304: LD_INT 34
6306: PUSH
6307: LD_INT 51
6309: PUSH
6310: EMPTY
6311: LIST
6312: LIST
6313: PUSH
6314: LD_INT 34
6316: PUSH
6317: LD_INT 52
6319: PUSH
6320: EMPTY
6321: LIST
6322: LIST
6323: PUSH
6324: EMPTY
6325: LIST
6326: LIST
6327: LIST
6328: PPUSH
6329: CALL_OW 72
6333: DIFF
6334: ST_TO_ADDR
// if not attackers then
6335: LD_VAR 0 4
6339: NOT
6340: IFFALSE 6344
// exit ;
6342: GO 6567
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
6344: LD_ADDR_EXP 42
6348: PUSH
6349: LD_EXP 42
6353: PPUSH
6354: LD_VAR 0 2
6358: PPUSH
6359: LD_EXP 42
6363: PUSH
6364: LD_VAR 0 2
6368: ARRAY
6369: PUSH
6370: LD_VAR 0 4
6374: DIFF
6375: PPUSH
6376: CALL_OW 1
6380: ST_TO_ADDR
// ComAgressiveMove ( attackers , 107 , 74 ) ;
6381: LD_VAR 0 4
6385: PPUSH
6386: LD_INT 107
6388: PPUSH
6389: LD_INT 74
6391: PPUSH
6392: CALL_OW 114
// wait ( 0 0$5 ) ;
6396: LD_INT 175
6398: PPUSH
6399: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
6403: LD_INT 35
6405: PPUSH
6406: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6410: LD_VAR 0 4
6414: PPUSH
6415: LD_INT 60
6417: PUSH
6418: EMPTY
6419: LIST
6420: PPUSH
6421: CALL_OW 72
6425: NOT
6426: IFFALSE 6403
// if rand ( 0 , 1 ) then
6428: LD_INT 0
6430: PPUSH
6431: LD_INT 1
6433: PPUSH
6434: CALL_OW 12
6438: IFFALSE 6457
// ComAgressiveMove ( attackers , 155 , 108 ) else
6440: LD_VAR 0 4
6444: PPUSH
6445: LD_INT 155
6447: PPUSH
6448: LD_INT 108
6450: PPUSH
6451: CALL_OW 114
6455: GO 6472
// ComAgressiveMove ( attackers , 149 , 55 ) ;
6457: LD_VAR 0 4
6461: PPUSH
6462: LD_INT 149
6464: PPUSH
6465: LD_INT 55
6467: PPUSH
6468: CALL_OW 114
// wait ( 0 0$10 ) ;
6472: LD_INT 350
6474: PPUSH
6475: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
6479: LD_INT 35
6481: PPUSH
6482: CALL_OW 67
// for i in attackers do
6486: LD_ADDR_VAR 0 1
6490: PUSH
6491: LD_VAR 0 4
6495: PUSH
6496: FOR_IN
6497: IFFALSE 6547
// if not HasTask ( i ) then
6499: LD_VAR 0 1
6503: PPUSH
6504: CALL_OW 314
6508: NOT
6509: IFFALSE 6545
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
6511: LD_VAR 0 1
6515: PPUSH
6516: LD_INT 81
6518: PUSH
6519: LD_INT 3
6521: PUSH
6522: EMPTY
6523: LIST
6524: LIST
6525: PPUSH
6526: CALL_OW 69
6530: PPUSH
6531: LD_VAR 0 1
6535: PPUSH
6536: CALL_OW 74
6540: PPUSH
6541: CALL_OW 115
6545: GO 6496
6547: POP
6548: POP
// until not UnitFilter ( attackers , [ f_ok ] ) ;
6549: LD_VAR 0 4
6553: PPUSH
6554: LD_INT 50
6556: PUSH
6557: EMPTY
6558: LIST
6559: PPUSH
6560: CALL_OW 72
6564: NOT
6565: IFFALSE 6479
// end ;
6567: PPOPN 5
6569: END
// every 12 12$00 + 10 10$00 trigger not ruDestroyed do var i , un , tmp , amount ;
6570: LD_EXP 5
6574: NOT
6575: IFFALSE 7146
6577: GO 6579
6579: DISABLE
6580: LD_INT 0
6582: PPUSH
6583: PPUSH
6584: PPUSH
6585: PPUSH
// begin enable ;
6586: ENABLE
// if Difficulty = 1 and tick < 30 30$00 then
6587: LD_OWVAR 67
6591: PUSH
6592: LD_INT 1
6594: EQUAL
6595: PUSH
6596: LD_OWVAR 1
6600: PUSH
6601: LD_INT 63000
6603: LESS
6604: AND
6605: IFFALSE 6609
// exit ;
6607: GO 7146
// tmp := [ ] ;
6609: LD_ADDR_VAR 0 3
6613: PUSH
6614: EMPTY
6615: ST_TO_ADDR
// if tick < 45 45$00 then
6616: LD_OWVAR 1
6620: PUSH
6621: LD_INT 94500
6623: LESS
6624: IFFALSE 6801
// begin for i := 1 to [ 2 , 3 , 4 ] [ Difficulty ] do
6626: LD_ADDR_VAR 0 1
6630: PUSH
6631: DOUBLE
6632: LD_INT 1
6634: DEC
6635: ST_TO_ADDR
6636: LD_INT 2
6638: PUSH
6639: LD_INT 3
6641: PUSH
6642: LD_INT 4
6644: PUSH
6645: EMPTY
6646: LIST
6647: LIST
6648: LIST
6649: PUSH
6650: LD_OWVAR 67
6654: ARRAY
6655: PUSH
6656: FOR_TO
6657: IFFALSE 6799
// begin uc_side := 3 ;
6659: LD_ADDR_OWVAR 20
6663: PUSH
6664: LD_INT 3
6666: ST_TO_ADDR
// uc_nation := 3 ;
6667: LD_ADDR_OWVAR 21
6671: PUSH
6672: LD_INT 3
6674: ST_TO_ADDR
// InitHC_All ( ) ;
6675: CALL_OW 584
// PrepareHuman ( false , 1 , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
6679: LD_INT 0
6681: PPUSH
6682: LD_INT 1
6684: PPUSH
6685: LD_INT 5
6687: PUSH
6688: LD_INT 6
6690: PUSH
6691: LD_INT 7
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: LIST
6698: PUSH
6699: LD_OWVAR 67
6703: ARRAY
6704: PPUSH
6705: CALL_OW 380
// un := CreateHuman ;
6709: LD_ADDR_VAR 0 2
6713: PUSH
6714: CALL_OW 44
6718: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
6719: LD_VAR 0 2
6723: PPUSH
6724: LD_INT 18
6726: PPUSH
6727: LD_INT 0
6729: PPUSH
6730: CALL_OW 49
// SetClass ( un , class_bazooker ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 9
6741: PPUSH
6742: CALL_OW 336
// ComMoveXY ( un , 147 , 161 ) ;
6746: LD_VAR 0 2
6750: PPUSH
6751: LD_INT 147
6753: PPUSH
6754: LD_INT 161
6756: PPUSH
6757: CALL_OW 111
// wait ( 0 0$2 ) ;
6761: LD_INT 70
6763: PPUSH
6764: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6768: LD_ADDR_VAR 0 3
6772: PUSH
6773: LD_VAR 0 3
6777: PPUSH
6778: LD_VAR 0 3
6782: PUSH
6783: LD_INT 1
6785: PLUS
6786: PPUSH
6787: LD_VAR 0 2
6791: PPUSH
6792: CALL_OW 1
6796: ST_TO_ADDR
// end ;
6797: GO 6656
6799: POP
6800: POP
// end ; amount := [ 3 , 4 , 5 ] [ Difficulty ] + tick div 10 10$00 ;
6801: LD_ADDR_VAR 0 4
6805: PUSH
6806: LD_INT 3
6808: PUSH
6809: LD_INT 4
6811: PUSH
6812: LD_INT 5
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: PUSH
6820: LD_OWVAR 67
6824: ARRAY
6825: PUSH
6826: LD_OWVAR 1
6830: PUSH
6831: LD_INT 21000
6833: DIV
6834: PLUS
6835: ST_TO_ADDR
// if amount > 15 then
6836: LD_VAR 0 4
6840: PUSH
6841: LD_INT 15
6843: GREATER
6844: IFFALSE 6854
// amount := 15 ;
6846: LD_ADDR_VAR 0 4
6850: PUSH
6851: LD_INT 15
6853: ST_TO_ADDR
// for i := 1 to amount do
6854: LD_ADDR_VAR 0 1
6858: PUSH
6859: DOUBLE
6860: LD_INT 1
6862: DEC
6863: ST_TO_ADDR
6864: LD_VAR 0 4
6868: PUSH
6869: FOR_TO
6870: IFFALSE 7000
// begin PrepareVehicle ( ru_heavy_tracked , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ rand ( 1 , 5 ) ] , 90 ) ;
6872: LD_INT 24
6874: PPUSH
6875: LD_INT 1
6877: PPUSH
6878: LD_INT 3
6880: PPUSH
6881: LD_INT 46
6883: PUSH
6884: LD_INT 45
6886: PUSH
6887: LD_INT 44
6889: PUSH
6890: LD_INT 43
6892: PUSH
6893: LD_INT 42
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: LIST
6900: LIST
6901: LIST
6902: PUSH
6903: LD_INT 1
6905: PPUSH
6906: LD_INT 5
6908: PPUSH
6909: CALL_OW 12
6913: ARRAY
6914: PPUSH
6915: LD_INT 90
6917: PPUSH
6918: CALL 13938 0 5
// un := CreateVehicle ;
6922: LD_ADDR_VAR 0 2
6926: PUSH
6927: CALL_OW 45
6931: ST_TO_ADDR
// PlaceUnitArea ( un , popov_spawn , false ) ;
6932: LD_VAR 0 2
6936: PPUSH
6937: LD_INT 18
6939: PPUSH
6940: LD_INT 0
6942: PPUSH
6943: CALL_OW 49
// ComMoveXY ( un , 147 , 161 ) ;
6947: LD_VAR 0 2
6951: PPUSH
6952: LD_INT 147
6954: PPUSH
6955: LD_INT 161
6957: PPUSH
6958: CALL_OW 111
// wait ( 0 0$3 ) ;
6962: LD_INT 105
6964: PPUSH
6965: CALL_OW 67
// tmp := Replace ( tmp , tmp + 1 , un ) ;
6969: LD_ADDR_VAR 0 3
6973: PUSH
6974: LD_VAR 0 3
6978: PPUSH
6979: LD_VAR 0 3
6983: PUSH
6984: LD_INT 1
6986: PLUS
6987: PPUSH
6988: LD_VAR 0 2
6992: PPUSH
6993: CALL_OW 1
6997: ST_TO_ADDR
// end ;
6998: GO 6869
7000: POP
7001: POP
// if not tmp then
7002: LD_VAR 0 3
7006: NOT
7007: IFFALSE 7011
// exit ;
7009: GO 7146
// wait ( 0 0$5 ) ;
7011: LD_INT 175
7013: PPUSH
7014: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
7018: LD_INT 70
7020: PPUSH
7021: CALL_OW 67
// for i in tmp do
7025: LD_ADDR_VAR 0 1
7029: PUSH
7030: LD_VAR 0 3
7034: PUSH
7035: FOR_IN
7036: IFFALSE 7137
// begin if not IsOk ( i ) or IsDead ( i ) then
7038: LD_VAR 0 1
7042: PPUSH
7043: CALL_OW 302
7047: NOT
7048: PUSH
7049: LD_VAR 0 1
7053: PPUSH
7054: CALL_OW 301
7058: OR
7059: IFFALSE 7077
// tmp := tmp diff i ;
7061: LD_ADDR_VAR 0 3
7065: PUSH
7066: LD_VAR 0 3
7070: PUSH
7071: LD_VAR 0 1
7075: DIFF
7076: ST_TO_ADDR
// if GetClass ( i ) = class_bazooker then
7077: LD_VAR 0 1
7081: PPUSH
7082: CALL_OW 257
7086: PUSH
7087: LD_INT 9
7089: EQUAL
7090: IFFALSE 7101
// ComSpaceTimeShoot ( i ) ;
7092: LD_VAR 0 1
7096: PPUSH
7097: CALL 10021 0 1
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7101: LD_VAR 0 1
7105: PPUSH
7106: LD_INT 81
7108: PUSH
7109: LD_INT 3
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PPUSH
7116: CALL_OW 69
7120: PPUSH
7121: LD_VAR 0 1
7125: PPUSH
7126: CALL_OW 74
7130: PPUSH
7131: CALL_OW 115
// end ;
7135: GO 7035
7137: POP
7138: POP
// until not tmp ;
7139: LD_VAR 0 3
7143: NOT
7144: IFFALSE 7018
// end ; end_of_file
7146: PPOPN 4
7148: END
// export Sikorski ; export function PrepareSikorski ; var i , j , un ; begin
7149: LD_INT 0
7151: PPUSH
7152: PPUSH
7153: PPUSH
7154: PPUSH
// uc_side := 1 ;
7155: LD_ADDR_OWVAR 20
7159: PUSH
7160: LD_INT 1
7162: ST_TO_ADDR
// uc_nation := 1 ;
7163: LD_ADDR_OWVAR 21
7167: PUSH
7168: LD_INT 1
7170: ST_TO_ADDR
// hc_importance := 100 ;
7171: LD_ADDR_OWVAR 32
7175: PUSH
7176: LD_INT 100
7178: ST_TO_ADDR
// hc_name := Jeremy Sikorski ;
7179: LD_ADDR_OWVAR 26
7183: PUSH
7184: LD_STRING Jeremy Sikorski
7186: ST_TO_ADDR
// hc_gallery := us ;
7187: LD_ADDR_OWVAR 33
7191: PUSH
7192: LD_STRING us
7194: ST_TO_ADDR
// hc_face_number := 19 ;
7195: LD_ADDR_OWVAR 34
7199: PUSH
7200: LD_INT 19
7202: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , [ 4 , 4 , 3 ] [ Difficulty ] ) ;
7203: LD_INT 1
7205: PPUSH
7206: LD_INT 1
7208: PPUSH
7209: LD_INT 4
7211: PUSH
7212: LD_INT 4
7214: PUSH
7215: LD_INT 3
7217: PUSH
7218: EMPTY
7219: LIST
7220: LIST
7221: LIST
7222: PUSH
7223: LD_OWVAR 67
7227: ARRAY
7228: PPUSH
7229: CALL_OW 380
// hc_attr := [ 10 , 12 ] ;
7233: LD_ADDR_OWVAR 29
7237: PUSH
7238: LD_INT 10
7240: PUSH
7241: LD_INT 12
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: ST_TO_ADDR
// Sikorski := CreateHuman ;
7248: LD_ADDR_EXP 20
7252: PUSH
7253: CALL_OW 44
7257: ST_TO_ADDR
// PlaceUnitXYR ( Sikorski , 133 , 19 , 2 , false ) ;
7258: LD_EXP 20
7262: PPUSH
7263: LD_INT 133
7265: PPUSH
7266: LD_INT 19
7268: PPUSH
7269: LD_INT 2
7271: PPUSH
7272: LD_INT 0
7274: PPUSH
7275: CALL_OW 50
// InitHc_All ( ) ;
7279: CALL_OW 584
// for i := 1 to [ 4 , 3 , 3 ] [ Difficulty ] do
7283: LD_ADDR_VAR 0 2
7287: PUSH
7288: DOUBLE
7289: LD_INT 1
7291: DEC
7292: ST_TO_ADDR
7293: LD_INT 4
7295: PUSH
7296: LD_INT 3
7298: PUSH
7299: LD_INT 3
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: LIST
7306: PUSH
7307: LD_OWVAR 67
7311: ARRAY
7312: PUSH
7313: FOR_TO
7314: IFFALSE 7430
// for j := 1 to 4 do
7316: LD_ADDR_VAR 0 3
7320: PUSH
7321: DOUBLE
7322: LD_INT 1
7324: DEC
7325: ST_TO_ADDR
7326: LD_INT 4
7328: PUSH
7329: FOR_TO
7330: IFFALSE 7426
// begin PrepareHuman ( false , j , [ 5 , 4 , 3 ] [ Difficulty ] ) ;
7332: LD_INT 0
7334: PPUSH
7335: LD_VAR 0 3
7339: PPUSH
7340: LD_INT 5
7342: PUSH
7343: LD_INT 4
7345: PUSH
7346: LD_INT 3
7348: PUSH
7349: EMPTY
7350: LIST
7351: LIST
7352: LIST
7353: PUSH
7354: LD_OWVAR 67
7358: ARRAY
7359: PPUSH
7360: CALL_OW 380
// un := CreateHuman ;
7364: LD_ADDR_VAR 0 4
7368: PUSH
7369: CALL_OW 44
7373: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
7374: LD_VAR 0 4
7378: PPUSH
7379: LD_INT 0
7381: PPUSH
7382: LD_INT 5
7384: PPUSH
7385: CALL_OW 12
7389: PPUSH
7390: CALL_OW 233
// PlaceUnitXYR ( un , 133 , 19 , 6 , false ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 133
7401: PPUSH
7402: LD_INT 19
7404: PPUSH
7405: LD_INT 6
7407: PPUSH
7408: LD_INT 0
7410: PPUSH
7411: CALL_OW 50
// ComHold ( un ) ;
7415: LD_VAR 0 4
7419: PPUSH
7420: CALL_OW 140
// end ;
7424: GO 7329
7426: POP
7427: POP
7428: GO 7313
7430: POP
7431: POP
// vc_chassis := us_heavy_tracked ;
7432: LD_ADDR_OWVAR 37
7436: PUSH
7437: LD_INT 4
7439: ST_TO_ADDR
// vc_engine := engine_combustion ;
7440: LD_ADDR_OWVAR 39
7444: PUSH
7445: LD_INT 1
7447: ST_TO_ADDR
// vc_control := control_manual ;
7448: LD_ADDR_OWVAR 38
7452: PUSH
7453: LD_INT 1
7455: ST_TO_ADDR
// vc_weapon := us_bulldozer ;
7456: LD_ADDR_OWVAR 40
7460: PUSH
7461: LD_INT 14
7463: ST_TO_ADDR
// vc_fuel_battery := 60 ;
7464: LD_ADDR_OWVAR 41
7468: PUSH
7469: LD_INT 60
7471: ST_TO_ADDR
// un := CreateVehicle ;
7472: LD_ADDR_VAR 0 4
7476: PUSH
7477: CALL_OW 45
7481: ST_TO_ADDR
// SetDir ( un , 2 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: LD_INT 2
7489: PPUSH
7490: CALL_OW 233
// PlaceUnitXY ( un , 128 , 12 , false ) ;
7494: LD_VAR 0 4
7498: PPUSH
7499: LD_INT 128
7501: PPUSH
7502: LD_INT 12
7504: PPUSH
7505: LD_INT 0
7507: PPUSH
7508: CALL_OW 48
// for i := 1 to 3 do
7512: LD_ADDR_VAR 0 2
7516: PUSH
7517: DOUBLE
7518: LD_INT 1
7520: DEC
7521: ST_TO_ADDR
7522: LD_INT 3
7524: PUSH
7525: FOR_TO
7526: IFFALSE 7549
// CreateCratesXYR ( 5 , 133 , 19 , 3 , false ) ;
7528: LD_INT 5
7530: PPUSH
7531: LD_INT 133
7533: PPUSH
7534: LD_INT 19
7536: PPUSH
7537: LD_INT 3
7539: PPUSH
7540: LD_INT 0
7542: PPUSH
7543: CALL_OW 56
7547: GO 7525
7549: POP
7550: POP
// end ; end_of_file
7551: LD_VAR 0 1
7555: RET
// export function Action ; begin
7556: LD_INT 0
7558: PPUSH
// InGameOn ;
7559: CALL_OW 8
// CenterNowOnXY ( 133 , 19 ) ;
7563: LD_INT 133
7565: PPUSH
7566: LD_INT 19
7568: PPUSH
7569: CALL_OW 86
// Say ( Sikorski , WT-DS-1 ) ;
7573: LD_EXP 20
7577: PPUSH
7578: LD_STRING WT-DS-1
7580: PPUSH
7581: CALL_OW 88
// InGameOff ;
7585: CALL_OW 9
// ChangeMissionObjectives ( DestroyEnemy ) ;
7589: LD_STRING DestroyEnemy
7591: PPUSH
7592: CALL_OW 337
// wait ( 0 0$20 ) ;
7596: LD_INT 700
7598: PPUSH
7599: CALL_OW 67
// DialogueOn ;
7603: CALL_OW 6
// PlaceSeeing ( 100 , 37 , 1 , - 30 ) ;
7607: LD_INT 100
7609: PPUSH
7610: LD_INT 37
7612: PPUSH
7613: LD_INT 1
7615: PPUSH
7616: LD_INT 30
7618: NEG
7619: PPUSH
7620: CALL_OW 330
// CenterNowOnXY ( 100 , 37 ) ;
7624: LD_INT 100
7626: PPUSH
7627: LD_INT 37
7629: PPUSH
7630: CALL_OW 86
// SayRadio ( Powell , WT-PL-1 ) ;
7634: LD_EXP 10
7638: PPUSH
7639: LD_STRING WT-PL-1
7641: PPUSH
7642: CALL_OW 94
// Say ( Sikorski , WT-DS-2 ) ;
7646: LD_EXP 20
7650: PPUSH
7651: LD_STRING WT-DS-2
7653: PPUSH
7654: CALL_OW 88
// DialogueOff ;
7658: CALL_OW 7
// wait ( 0 0$2 ) ;
7662: LD_INT 70
7664: PPUSH
7665: CALL_OW 67
// RemoveSeeing ( 100 , 37 , 1 ) ;
7669: LD_INT 100
7671: PPUSH
7672: LD_INT 37
7674: PPUSH
7675: LD_INT 1
7677: PPUSH
7678: CALL_OW 331
// end ;
7682: LD_VAR 0 1
7686: RET
// export function DialogPowellsAttack ; begin
7687: LD_INT 0
7689: PPUSH
// SayRadio ( Powell , WT-PL-8 ) ;
7690: LD_EXP 10
7694: PPUSH
7695: LD_STRING WT-PL-8
7697: PPUSH
7698: CALL_OW 94
// end ;
7702: LD_VAR 0 1
7706: RET
// export function DialogContaminateSib ( x , y ) ; begin
7707: LD_INT 0
7709: PPUSH
// DialogueOn ;
7710: CALL_OW 6
// CenterNowOnXY ( x , y ) ;
7714: LD_VAR 0 1
7718: PPUSH
7719: LD_VAR 0 2
7723: PPUSH
7724: CALL_OW 86
// Say ( Sikorski , WT-DS-3 ) ;
7728: LD_EXP 20
7732: PPUSH
7733: LD_STRING WT-DS-3
7735: PPUSH
7736: CALL_OW 88
// DialogueOff ;
7740: CALL_OW 7
// end ;
7744: LD_VAR 0 3
7748: RET
// every 0 0$3 trigger not powellInTrouble and FilterUnitsInArea ( powell_base , [ f_enemy , 4 ] ) > 3 do
7749: LD_EXP 8
7753: NOT
7754: PUSH
7755: LD_INT 1
7757: PPUSH
7758: LD_INT 81
7760: PUSH
7761: LD_INT 4
7763: PUSH
7764: EMPTY
7765: LIST
7766: LIST
7767: PPUSH
7768: CALL_OW 70
7772: PUSH
7773: LD_INT 3
7775: GREATER
7776: AND
7777: IFFALSE 7849
7779: GO 7781
7781: DISABLE
// begin powellInTrouble := true ;
7782: LD_ADDR_EXP 8
7786: PUSH
7787: LD_INT 1
7789: ST_TO_ADDR
// Say ( Sikorski , WT-DS-6 ) ;
7790: LD_EXP 20
7794: PPUSH
7795: LD_STRING WT-DS-6
7797: PPUSH
7798: CALL_OW 88
// if not FilterUnitsInArea ( powell_base , [ f_side , 1 ] ) then
7802: LD_INT 1
7804: PPUSH
7805: LD_INT 22
7807: PUSH
7808: LD_INT 1
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: PPUSH
7815: CALL_OW 70
7819: NOT
7820: IFFALSE 7834
// SayRadio ( Powell , WT-PL-6 ) ;
7822: LD_EXP 10
7826: PPUSH
7827: LD_STRING WT-PL-6
7829: PPUSH
7830: CALL_OW 94
// wait ( 1 1$30 ) ;
7834: LD_INT 3150
7836: PPUSH
7837: CALL_OW 67
// powellInTrouble := false ;
7841: LD_ADDR_EXP 8
7845: PUSH
7846: LD_INT 0
7848: ST_TO_ADDR
// end ;
7849: END
// every 0 0$3 trigger not sikorskiInTrouble and FilterUnitsInArea ( sikorski_base , [ f_enemy , 1 ] ) > 6 do
7850: LD_EXP 9
7854: NOT
7855: PUSH
7856: LD_INT 16
7858: PPUSH
7859: LD_INT 81
7861: PUSH
7862: LD_INT 1
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: PPUSH
7869: CALL_OW 70
7873: PUSH
7874: LD_INT 6
7876: GREATER
7877: AND
7878: IFFALSE 7951
7880: GO 7882
7882: DISABLE
// begin sikorskiInTrouble := true ;
7883: LD_ADDR_EXP 9
7887: PUSH
7888: LD_INT 1
7890: ST_TO_ADDR
// Say ( Sikorski , WT-DS-7 ) ;
7891: LD_EXP 20
7895: PPUSH
7896: LD_STRING WT-DS-7
7898: PPUSH
7899: CALL_OW 88
// if not powellAttackGroup then
7903: LD_EXP 12
7907: NOT
7908: IFFALSE 7924
// SayRadio ( Powell , WT-PL-7n ) else
7910: LD_EXP 10
7914: PPUSH
7915: LD_STRING WT-PL-7n
7917: PPUSH
7918: CALL_OW 94
7922: GO 7936
// SayRadio ( Powell , WT-PL-7y ) ;
7924: LD_EXP 10
7928: PPUSH
7929: LD_STRING WT-PL-7y
7931: PPUSH
7932: CALL_OW 94
// wait ( 1 1$30 ) ;
7936: LD_INT 3150
7938: PPUSH
7939: CALL_OW 67
// sikorskiInTrouble := false ;
7943: LD_ADDR_EXP 9
7947: PUSH
7948: LD_INT 0
7950: ST_TO_ADDR
// end ;
7951: END
// export function DialogPowellsAttackFailed ; begin
7952: LD_INT 0
7954: PPUSH
// if not ruDestroyed then
7955: LD_EXP 5
7959: NOT
7960: IFFALSE 7976
// SayRadio ( Powell , WT-PL-9 ) else
7962: LD_EXP 10
7966: PPUSH
7967: LD_STRING WT-PL-9
7969: PPUSH
7970: CALL_OW 94
7974: GO 7988
// SayRadio ( Powell , WT-PL-10 ) ;
7976: LD_EXP 10
7980: PPUSH
7981: LD_STRING WT-PL-10
7983: PPUSH
7984: CALL_OW 94
// end ;
7988: LD_VAR 0 1
7992: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
7993: LD_INT 22
7995: PUSH
7996: LD_INT 2
7998: PUSH
7999: EMPTY
8000: LIST
8001: LIST
8002: PUSH
8003: LD_INT 21
8005: PUSH
8006: LD_INT 1
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: EMPTY
8014: LIST
8015: LIST
8016: PPUSH
8017: CALL_OW 69
8021: PUSH
8022: LD_INT 0
8024: EQUAL
8025: IFFALSE 8069
8027: GO 8029
8029: DISABLE
// begin arDestroyed := true ;
8030: LD_ADDR_EXP 4
8034: PUSH
8035: LD_INT 1
8037: ST_TO_ADDR
// MC_Kill ( 2 ) ;
8038: LD_INT 2
8040: PPUSH
8041: CALL 47865 0 1
// Say ( Sikorski , WT-DS-4 ) ;
8045: LD_EXP 20
8049: PPUSH
8050: LD_STRING WT-DS-4
8052: PPUSH
8053: CALL_OW 88
// SayRadio ( Powell , WT-PL-4 ) ;
8057: LD_EXP 10
8061: PPUSH
8062: LD_STRING WT-PL-4
8064: PPUSH
8065: CALL_OW 94
// end ;
8069: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
8070: LD_INT 22
8072: PUSH
8073: LD_INT 3
8075: PUSH
8076: EMPTY
8077: LIST
8078: LIST
8079: PUSH
8080: LD_INT 21
8082: PUSH
8083: LD_INT 1
8085: PUSH
8086: EMPTY
8087: LIST
8088: LIST
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PPUSH
8094: CALL_OW 69
8098: PUSH
8099: LD_INT 0
8101: EQUAL
8102: IFFALSE 8146
8104: GO 8106
8106: DISABLE
// begin ruDestroyed := true ;
8107: LD_ADDR_EXP 5
8111: PUSH
8112: LD_INT 1
8114: ST_TO_ADDR
// MC_Kill ( 3 ) ;
8115: LD_INT 3
8117: PPUSH
8118: CALL 47865 0 1
// Say ( Sikorski , WT-DS-5 ) ;
8122: LD_EXP 20
8126: PPUSH
8127: LD_STRING WT-DS-5
8129: PPUSH
8130: CALL_OW 88
// SayRadio ( Powell , WT-PL-5 ) ;
8134: LD_EXP 10
8138: PPUSH
8139: LD_STRING WT-PL-5
8141: PPUSH
8142: CALL_OW 94
// end ;
8146: END
// every 0 0$1 trigger ruDestroyed and arDestroyed do
8147: LD_EXP 5
8151: PUSH
8152: LD_EXP 4
8156: AND
8157: IFFALSE 8330
8159: GO 8161
8161: DISABLE
// begin wait ( 0 0$3 ) ;
8162: LD_INT 105
8164: PPUSH
8165: CALL_OW 67
// if tick >= [ 60 60$00 , 50 50$00 , 45 45$00 ] [ Difficulty ] then
8169: LD_OWVAR 1
8173: PUSH
8174: LD_INT 126000
8176: PUSH
8177: LD_INT 105000
8179: PUSH
8180: LD_INT 94500
8182: PUSH
8183: EMPTY
8184: LIST
8185: LIST
8186: LIST
8187: PUSH
8188: LD_OWVAR 67
8192: ARRAY
8193: GREATEREQUAL
8194: IFFALSE 8209
// AddMedal ( WoT-med-1 , - 1 ) else
8196: LD_STRING WoT-med-1
8198: PPUSH
8199: LD_INT 1
8201: NEG
8202: PPUSH
8203: CALL_OW 101
8207: GO 8219
// AddMedal ( WoT-med-1 , 1 ) ;
8209: LD_STRING WoT-med-1
8211: PPUSH
8212: LD_INT 1
8214: PPUSH
8215: CALL_OW 101
// if loseCounter >= [ 4 , 3 , 2 ] [ Difficulty ] then
8219: LD_EXP 6
8223: PUSH
8224: LD_INT 4
8226: PUSH
8227: LD_INT 3
8229: PUSH
8230: LD_INT 2
8232: PUSH
8233: EMPTY
8234: LIST
8235: LIST
8236: LIST
8237: PUSH
8238: LD_OWVAR 67
8242: ARRAY
8243: GREATEREQUAL
8244: IFFALSE 8259
// AddMedal ( WoT-med-2 , - 1 ) else
8246: LD_STRING WoT-med-2
8248: PPUSH
8249: LD_INT 1
8251: NEG
8252: PPUSH
8253: CALL_OW 101
8257: GO 8269
// AddMedal ( WoT-med-2 , 1 ) ;
8259: LD_STRING WoT-med-2
8261: PPUSH
8262: LD_INT 1
8264: PPUSH
8265: CALL_OW 101
// if powellLoseCounter >= [ 8 , 6 , 5 ] [ Difficulty ] then
8269: LD_EXP 7
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: LD_INT 6
8279: PUSH
8280: LD_INT 5
8282: PUSH
8283: EMPTY
8284: LIST
8285: LIST
8286: LIST
8287: PUSH
8288: LD_OWVAR 67
8292: ARRAY
8293: GREATEREQUAL
8294: IFFALSE 8309
// AddMedal ( WoT-med-3 , - 1 ) else
8296: LD_STRING WoT-med-3
8298: PPUSH
8299: LD_INT 1
8301: NEG
8302: PPUSH
8303: CALL_OW 101
8307: GO 8319
// AddMedal ( WoT-med-3 , 1 ) ;
8309: LD_STRING WoT-med-3
8311: PPUSH
8312: LD_INT 1
8314: PPUSH
8315: CALL_OW 101
// GiveMedals ( MAIN ) ;
8319: LD_STRING MAIN
8321: PPUSH
8322: CALL_OW 102
// YouWin ;
8326: CALL_OW 103
// end ; end_of_file
8330: END
// export function CustomEvent ( event ) ; begin
8331: LD_INT 0
8333: PPUSH
// end ;
8334: LD_VAR 0 2
8338: RET
// on Command ( com ) do var i , j , temp ;
8339: LD_INT 0
8341: PPUSH
8342: PPUSH
8343: PPUSH
// begin if com = 60 then
8344: LD_VAR 0 1
8348: PUSH
8349: LD_INT 60
8351: EQUAL
8352: IFFALSE 8531
// begin for i in FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_type , unit_human ] , [ f_weapon , us_cargo_bay ] ] ] ) do
8354: LD_ADDR_VAR 0 2
8358: PUSH
8359: LD_INT 22
8361: PUSH
8362: LD_INT 1
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PUSH
8369: LD_INT 2
8371: PUSH
8372: LD_INT 21
8374: PUSH
8375: LD_INT 1
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: LD_INT 34
8384: PUSH
8385: LD_INT 12
8387: PUSH
8388: EMPTY
8389: LIST
8390: LIST
8391: PUSH
8392: EMPTY
8393: LIST
8394: LIST
8395: LIST
8396: PUSH
8397: EMPTY
8398: LIST
8399: LIST
8400: PPUSH
8401: CALL_OW 69
8405: PUSH
8406: FOR_IN
8407: IFFALSE 8529
// begin if GetTaskList ( i ) > 0 then
8409: LD_VAR 0 2
8413: PPUSH
8414: CALL_OW 437
8418: PUSH
8419: LD_INT 0
8421: GREATER
8422: IFFALSE 8527
// for j = 1 to GetTaskList ( i ) do
8424: LD_ADDR_VAR 0 3
8428: PUSH
8429: DOUBLE
8430: LD_INT 1
8432: DEC
8433: ST_TO_ADDR
8434: LD_VAR 0 2
8438: PPUSH
8439: CALL_OW 437
8443: PUSH
8444: FOR_TO
8445: IFFALSE 8525
// begin temp = GetTaskList ( i ) [ j ] [ 4 ] ;
8447: LD_ADDR_VAR 0 4
8451: PUSH
8452: LD_VAR 0 2
8456: PPUSH
8457: CALL_OW 437
8461: PUSH
8462: LD_VAR 0 3
8466: ARRAY
8467: PUSH
8468: LD_INT 4
8470: ARRAY
8471: ST_TO_ADDR
// if GetSide ( temp ) = 4 and GetTaskList ( i ) [ j ] [ 1 ] = < then
8472: LD_VAR 0 4
8476: PPUSH
8477: CALL_OW 255
8481: PUSH
8482: LD_INT 4
8484: EQUAL
8485: PUSH
8486: LD_VAR 0 2
8490: PPUSH
8491: CALL_OW 437
8495: PUSH
8496: LD_VAR 0 3
8500: ARRAY
8501: PUSH
8502: LD_INT 1
8504: ARRAY
8505: PUSH
8506: LD_STRING <
8508: EQUAL
8509: AND
8510: IFFALSE 8523
// SetTaskList ( i , [ ] ) ;
8512: LD_VAR 0 2
8516: PPUSH
8517: EMPTY
8518: PPUSH
8519: CALL_OW 446
// end ;
8523: GO 8444
8525: POP
8526: POP
// end ;
8527: GO 8406
8529: POP
8530: POP
// end ; end ;
8531: PPOPN 4
8533: END
// on SibDepositContaminated ( sci , x , y ) do begin if GetSide ( HexInfo ( x , y ) ) = 1 then
8534: LD_VAR 0 2
8538: PPUSH
8539: LD_VAR 0 3
8543: PPUSH
8544: CALL_OW 428
8548: PPUSH
8549: CALL_OW 255
8553: PUSH
8554: LD_INT 1
8556: EQUAL
8557: IFFALSE 8573
// DialogContaminateSib ( x , y ) ;
8559: LD_VAR 0 2
8563: PPUSH
8564: LD_VAR 0 3
8568: PPUSH
8569: CALL 7707 0 2
// end ;
8573: PPOPN 3
8575: END
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
8576: LD_VAR 0 1
8580: PPUSH
8581: CALL 75047 0 1
// if un = Powell then
8585: LD_VAR 0 1
8589: PUSH
8590: LD_EXP 10
8594: EQUAL
8595: IFFALSE 8604
// YouLost ( Powell ) ;
8597: LD_STRING Powell
8599: PPUSH
8600: CALL_OW 104
// if un = Sikorski then
8604: LD_VAR 0 1
8608: PUSH
8609: LD_EXP 20
8613: EQUAL
8614: IFFALSE 8623
// YouLost ( Sikorski ) ;
8616: LD_STRING Sikorski
8618: PPUSH
8619: CALL_OW 104
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) then
8623: LD_VAR 0 1
8627: PUSH
8628: LD_INT 22
8630: PUSH
8631: LD_INT 1
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 21
8640: PUSH
8641: LD_INT 1
8643: PUSH
8644: EMPTY
8645: LIST
8646: LIST
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PPUSH
8652: CALL_OW 69
8656: IN
8657: IFFALSE 8673
// loseCounter := loseCounter + 1 ;
8659: LD_ADDR_EXP 6
8663: PUSH
8664: LD_EXP 6
8668: PUSH
8669: LD_INT 1
8671: PLUS
8672: ST_TO_ADDR
// if un in FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) then
8673: LD_VAR 0 1
8677: PUSH
8678: LD_INT 22
8680: PUSH
8681: LD_INT 4
8683: PUSH
8684: EMPTY
8685: LIST
8686: LIST
8687: PUSH
8688: LD_INT 21
8690: PUSH
8691: LD_INT 1
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: PUSH
8698: EMPTY
8699: LIST
8700: LIST
8701: PPUSH
8702: CALL_OW 69
8706: IN
8707: IFFALSE 8723
// powellLoseCounter := powellLoseCounter + 1 ;
8709: LD_ADDR_EXP 7
8713: PUSH
8714: LD_EXP 7
8718: PUSH
8719: LD_INT 1
8721: PLUS
8722: ST_TO_ADDR
// if un in powellAttackGroup then
8723: LD_VAR 0 1
8727: PUSH
8728: LD_EXP 12
8732: IN
8733: IFFALSE 8751
// powellAttackGroup := powellAttackGroup diff un ;
8735: LD_ADDR_EXP 12
8739: PUSH
8740: LD_EXP 12
8744: PUSH
8745: LD_VAR 0 1
8749: DIFF
8750: ST_TO_ADDR
// if un in gensherAttackGroup then
8751: LD_VAR 0 1
8755: PUSH
8756: LD_EXP 15
8760: IN
8761: IFFALSE 8779
// gensherAttackGroup := gensherAttackGroup diff un ;
8763: LD_ADDR_EXP 15
8767: PUSH
8768: LD_EXP 15
8772: PUSH
8773: LD_VAR 0 1
8777: DIFF
8778: ST_TO_ADDR
// if un in popovAttackGroup then
8779: LD_VAR 0 1
8783: PUSH
8784: LD_EXP 19
8788: IN
8789: IFFALSE 8807
// popovAttackGroup := popovAttackGroup diff un ;
8791: LD_ADDR_EXP 19
8795: PUSH
8796: LD_EXP 19
8800: PUSH
8801: LD_VAR 0 1
8805: DIFF
8806: ST_TO_ADDR
// end ;
8807: PPOPN 1
8809: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
8810: LD_VAR 0 1
8814: PPUSH
8815: LD_VAR 0 2
8819: PPUSH
8820: CALL 77381 0 2
// end ;
8824: PPOPN 2
8826: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
8827: LD_VAR 0 1
8831: PPUSH
8832: CALL 76449 0 1
// end ;
8836: PPOPN 1
8838: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
8839: LD_VAR 0 1
8843: PPUSH
8844: CALL 76690 0 1
// end ;
8848: PPOPN 1
8850: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
8851: LD_VAR 0 1
8855: PPUSH
8856: LD_VAR 0 2
8860: PPUSH
8861: CALL 74743 0 2
// end ;
8865: PPOPN 2
8867: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
8868: LD_VAR 0 1
8872: PPUSH
8873: LD_VAR 0 2
8877: PPUSH
8878: LD_VAR 0 3
8882: PPUSH
8883: LD_VAR 0 4
8887: PPUSH
8888: LD_VAR 0 5
8892: PPUSH
8893: CALL 74363 0 5
// end ;
8897: PPOPN 5
8899: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
8900: LD_VAR 0 1
8904: PPUSH
8905: LD_VAR 0 2
8909: PPUSH
8910: CALL 73944 0 2
// end ;
8914: PPOPN 2
8916: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
8917: LD_VAR 0 1
8921: PPUSH
8922: LD_VAR 0 2
8926: PPUSH
8927: LD_VAR 0 3
8931: PPUSH
8932: LD_VAR 0 4
8936: PPUSH
8937: CALL 73782 0 4
// end ;
8941: PPOPN 4
8943: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
8944: LD_VAR 0 1
8948: PPUSH
8949: LD_VAR 0 2
8953: PPUSH
8954: LD_VAR 0 3
8958: PPUSH
8959: CALL 73557 0 3
// end ;
8963: PPOPN 3
8965: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
8966: LD_VAR 0 1
8970: PPUSH
8971: LD_VAR 0 2
8975: PPUSH
8976: CALL 73442 0 2
// end ;
8980: PPOPN 2
8982: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
8983: LD_VAR 0 1
8987: PPUSH
8988: LD_VAR 0 2
8992: PPUSH
8993: CALL 77676 0 2
// end ;
8997: PPOPN 2
8999: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
9000: LD_VAR 0 1
9004: PPUSH
9005: LD_VAR 0 2
9009: PPUSH
9010: LD_VAR 0 3
9014: PPUSH
9015: LD_VAR 0 4
9019: PPUSH
9020: CALL 77892 0 4
// end ;
9024: PPOPN 4
9026: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
9027: LD_VAR 0 1
9031: PPUSH
9032: LD_VAR 0 2
9036: PPUSH
9037: CALL 73251 0 2
// end ;
9041: PPOPN 2
9043: END
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 then
9044: LD_VAR 0 1
9048: PUSH
9049: LD_INT 1
9051: EQUAL
9052: PUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 4
9060: EQUAL
9061: AND
9062: IFFALSE 9071
// YouLost ( FriendlyFire ) ;
9064: LD_STRING FriendlyFire
9066: PPUSH
9067: CALL_OW 104
// end ; end_of_file
9071: PPOPN 2
9073: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
9074: LD_INT 0
9076: PPUSH
9077: PPUSH
// if exist_mode then
9078: LD_VAR 0 2
9082: IFFALSE 9107
// unit := CreateCharacter ( prefix & ident ) else
9084: LD_ADDR_VAR 0 5
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: LD_VAR 0 1
9098: STR
9099: PPUSH
9100: CALL_OW 34
9104: ST_TO_ADDR
9105: GO 9122
// unit := NewCharacter ( ident ) ;
9107: LD_ADDR_VAR 0 5
9111: PUSH
9112: LD_VAR 0 1
9116: PPUSH
9117: CALL_OW 25
9121: ST_TO_ADDR
// result := unit ;
9122: LD_ADDR_VAR 0 4
9126: PUSH
9127: LD_VAR 0 5
9131: ST_TO_ADDR
// end ;
9132: LD_VAR 0 4
9136: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
9137: LD_INT 0
9139: PPUSH
9140: PPUSH
// if not side or not nation then
9141: LD_VAR 0 1
9145: NOT
9146: PUSH
9147: LD_VAR 0 2
9151: NOT
9152: OR
9153: IFFALSE 9157
// exit ;
9155: GO 9925
// case nation of nation_american :
9157: LD_VAR 0 2
9161: PUSH
9162: LD_INT 1
9164: DOUBLE
9165: EQUAL
9166: IFTRUE 9170
9168: GO 9384
9170: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
9171: LD_ADDR_VAR 0 4
9175: PUSH
9176: LD_INT 35
9178: PUSH
9179: LD_INT 45
9181: PUSH
9182: LD_INT 46
9184: PUSH
9185: LD_INT 47
9187: PUSH
9188: LD_INT 82
9190: PUSH
9191: LD_INT 83
9193: PUSH
9194: LD_INT 84
9196: PUSH
9197: LD_INT 85
9199: PUSH
9200: LD_INT 86
9202: PUSH
9203: LD_INT 1
9205: PUSH
9206: LD_INT 2
9208: PUSH
9209: LD_INT 6
9211: PUSH
9212: LD_INT 15
9214: PUSH
9215: LD_INT 16
9217: PUSH
9218: LD_INT 7
9220: PUSH
9221: LD_INT 12
9223: PUSH
9224: LD_INT 13
9226: PUSH
9227: LD_INT 10
9229: PUSH
9230: LD_INT 14
9232: PUSH
9233: LD_INT 20
9235: PUSH
9236: LD_INT 21
9238: PUSH
9239: LD_INT 22
9241: PUSH
9242: LD_INT 25
9244: PUSH
9245: LD_INT 32
9247: PUSH
9248: LD_INT 27
9250: PUSH
9251: LD_INT 36
9253: PUSH
9254: LD_INT 69
9256: PUSH
9257: LD_INT 39
9259: PUSH
9260: LD_INT 34
9262: PUSH
9263: LD_INT 40
9265: PUSH
9266: LD_INT 48
9268: PUSH
9269: LD_INT 49
9271: PUSH
9272: LD_INT 50
9274: PUSH
9275: LD_INT 51
9277: PUSH
9278: LD_INT 52
9280: PUSH
9281: LD_INT 53
9283: PUSH
9284: LD_INT 54
9286: PUSH
9287: LD_INT 55
9289: PUSH
9290: LD_INT 56
9292: PUSH
9293: LD_INT 57
9295: PUSH
9296: LD_INT 58
9298: PUSH
9299: LD_INT 59
9301: PUSH
9302: LD_INT 60
9304: PUSH
9305: LD_INT 61
9307: PUSH
9308: LD_INT 62
9310: PUSH
9311: LD_INT 80
9313: PUSH
9314: LD_INT 82
9316: PUSH
9317: LD_INT 83
9319: PUSH
9320: LD_INT 84
9322: PUSH
9323: LD_INT 85
9325: PUSH
9326: LD_INT 86
9328: PUSH
9329: EMPTY
9330: LIST
9331: LIST
9332: LIST
9333: LIST
9334: LIST
9335: LIST
9336: LIST
9337: LIST
9338: LIST
9339: LIST
9340: LIST
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: LIST
9351: LIST
9352: LIST
9353: LIST
9354: LIST
9355: LIST
9356: LIST
9357: LIST
9358: LIST
9359: LIST
9360: LIST
9361: LIST
9362: LIST
9363: LIST
9364: LIST
9365: LIST
9366: LIST
9367: LIST
9368: LIST
9369: LIST
9370: LIST
9371: LIST
9372: LIST
9373: LIST
9374: LIST
9375: LIST
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: LIST
9381: ST_TO_ADDR
9382: GO 9849
9384: LD_INT 2
9386: DOUBLE
9387: EQUAL
9388: IFTRUE 9392
9390: GO 9618
9392: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
9393: LD_ADDR_VAR 0 4
9397: PUSH
9398: LD_INT 35
9400: PUSH
9401: LD_INT 45
9403: PUSH
9404: LD_INT 46
9406: PUSH
9407: LD_INT 47
9409: PUSH
9410: LD_INT 82
9412: PUSH
9413: LD_INT 83
9415: PUSH
9416: LD_INT 84
9418: PUSH
9419: LD_INT 85
9421: PUSH
9422: LD_INT 87
9424: PUSH
9425: LD_INT 70
9427: PUSH
9428: LD_INT 1
9430: PUSH
9431: LD_INT 11
9433: PUSH
9434: LD_INT 3
9436: PUSH
9437: LD_INT 4
9439: PUSH
9440: LD_INT 5
9442: PUSH
9443: LD_INT 6
9445: PUSH
9446: LD_INT 15
9448: PUSH
9449: LD_INT 18
9451: PUSH
9452: LD_INT 7
9454: PUSH
9455: LD_INT 17
9457: PUSH
9458: LD_INT 8
9460: PUSH
9461: LD_INT 20
9463: PUSH
9464: LD_INT 21
9466: PUSH
9467: LD_INT 22
9469: PUSH
9470: LD_INT 72
9472: PUSH
9473: LD_INT 26
9475: PUSH
9476: LD_INT 69
9478: PUSH
9479: LD_INT 39
9481: PUSH
9482: LD_INT 40
9484: PUSH
9485: LD_INT 41
9487: PUSH
9488: LD_INT 42
9490: PUSH
9491: LD_INT 43
9493: PUSH
9494: LD_INT 48
9496: PUSH
9497: LD_INT 49
9499: PUSH
9500: LD_INT 50
9502: PUSH
9503: LD_INT 51
9505: PUSH
9506: LD_INT 52
9508: PUSH
9509: LD_INT 53
9511: PUSH
9512: LD_INT 54
9514: PUSH
9515: LD_INT 55
9517: PUSH
9518: LD_INT 56
9520: PUSH
9521: LD_INT 60
9523: PUSH
9524: LD_INT 61
9526: PUSH
9527: LD_INT 62
9529: PUSH
9530: LD_INT 66
9532: PUSH
9533: LD_INT 67
9535: PUSH
9536: LD_INT 68
9538: PUSH
9539: LD_INT 81
9541: PUSH
9542: LD_INT 82
9544: PUSH
9545: LD_INT 83
9547: PUSH
9548: LD_INT 84
9550: PUSH
9551: LD_INT 85
9553: PUSH
9554: LD_INT 87
9556: PUSH
9557: LD_INT 88
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: LIST
9565: LIST
9566: LIST
9567: LIST
9568: LIST
9569: LIST
9570: LIST
9571: LIST
9572: LIST
9573: LIST
9574: LIST
9575: LIST
9576: LIST
9577: LIST
9578: LIST
9579: LIST
9580: LIST
9581: LIST
9582: LIST
9583: LIST
9584: LIST
9585: LIST
9586: LIST
9587: LIST
9588: LIST
9589: LIST
9590: LIST
9591: LIST
9592: LIST
9593: LIST
9594: LIST
9595: LIST
9596: LIST
9597: LIST
9598: LIST
9599: LIST
9600: LIST
9601: LIST
9602: LIST
9603: LIST
9604: LIST
9605: LIST
9606: LIST
9607: LIST
9608: LIST
9609: LIST
9610: LIST
9611: LIST
9612: LIST
9613: LIST
9614: LIST
9615: ST_TO_ADDR
9616: GO 9849
9618: LD_INT 3
9620: DOUBLE
9621: EQUAL
9622: IFTRUE 9626
9624: GO 9848
9626: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
9627: LD_ADDR_VAR 0 4
9631: PUSH
9632: LD_INT 46
9634: PUSH
9635: LD_INT 47
9637: PUSH
9638: LD_INT 1
9640: PUSH
9641: LD_INT 2
9643: PUSH
9644: LD_INT 82
9646: PUSH
9647: LD_INT 83
9649: PUSH
9650: LD_INT 84
9652: PUSH
9653: LD_INT 85
9655: PUSH
9656: LD_INT 86
9658: PUSH
9659: LD_INT 11
9661: PUSH
9662: LD_INT 9
9664: PUSH
9665: LD_INT 20
9667: PUSH
9668: LD_INT 19
9670: PUSH
9671: LD_INT 21
9673: PUSH
9674: LD_INT 24
9676: PUSH
9677: LD_INT 22
9679: PUSH
9680: LD_INT 25
9682: PUSH
9683: LD_INT 28
9685: PUSH
9686: LD_INT 29
9688: PUSH
9689: LD_INT 30
9691: PUSH
9692: LD_INT 31
9694: PUSH
9695: LD_INT 37
9697: PUSH
9698: LD_INT 38
9700: PUSH
9701: LD_INT 32
9703: PUSH
9704: LD_INT 27
9706: PUSH
9707: LD_INT 33
9709: PUSH
9710: LD_INT 69
9712: PUSH
9713: LD_INT 39
9715: PUSH
9716: LD_INT 34
9718: PUSH
9719: LD_INT 40
9721: PUSH
9722: LD_INT 71
9724: PUSH
9725: LD_INT 23
9727: PUSH
9728: LD_INT 44
9730: PUSH
9731: LD_INT 48
9733: PUSH
9734: LD_INT 49
9736: PUSH
9737: LD_INT 50
9739: PUSH
9740: LD_INT 51
9742: PUSH
9743: LD_INT 52
9745: PUSH
9746: LD_INT 53
9748: PUSH
9749: LD_INT 54
9751: PUSH
9752: LD_INT 55
9754: PUSH
9755: LD_INT 56
9757: PUSH
9758: LD_INT 57
9760: PUSH
9761: LD_INT 58
9763: PUSH
9764: LD_INT 59
9766: PUSH
9767: LD_INT 63
9769: PUSH
9770: LD_INT 64
9772: PUSH
9773: LD_INT 65
9775: PUSH
9776: LD_INT 82
9778: PUSH
9779: LD_INT 83
9781: PUSH
9782: LD_INT 84
9784: PUSH
9785: LD_INT 85
9787: PUSH
9788: LD_INT 86
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: LIST
9795: LIST
9796: LIST
9797: LIST
9798: LIST
9799: LIST
9800: LIST
9801: LIST
9802: LIST
9803: LIST
9804: LIST
9805: LIST
9806: LIST
9807: LIST
9808: LIST
9809: LIST
9810: LIST
9811: LIST
9812: LIST
9813: LIST
9814: LIST
9815: LIST
9816: LIST
9817: LIST
9818: LIST
9819: LIST
9820: LIST
9821: LIST
9822: LIST
9823: LIST
9824: LIST
9825: LIST
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: LIST
9835: LIST
9836: LIST
9837: LIST
9838: LIST
9839: LIST
9840: LIST
9841: LIST
9842: LIST
9843: LIST
9844: LIST
9845: ST_TO_ADDR
9846: GO 9849
9848: POP
// if state > - 1 and state < 3 then
9849: LD_VAR 0 3
9853: PUSH
9854: LD_INT 1
9856: NEG
9857: GREATER
9858: PUSH
9859: LD_VAR 0 3
9863: PUSH
9864: LD_INT 3
9866: LESS
9867: AND
9868: IFFALSE 9925
// for i in result do
9870: LD_ADDR_VAR 0 5
9874: PUSH
9875: LD_VAR 0 4
9879: PUSH
9880: FOR_IN
9881: IFFALSE 9923
// if GetTech ( i , side ) <> state then
9883: LD_VAR 0 5
9887: PPUSH
9888: LD_VAR 0 1
9892: PPUSH
9893: CALL_OW 321
9897: PUSH
9898: LD_VAR 0 3
9902: NONEQUAL
9903: IFFALSE 9921
// result := result diff i ;
9905: LD_ADDR_VAR 0 4
9909: PUSH
9910: LD_VAR 0 4
9914: PUSH
9915: LD_VAR 0 5
9919: DIFF
9920: ST_TO_ADDR
9921: GO 9880
9923: POP
9924: POP
// end ;
9925: LD_VAR 0 4
9929: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
9930: LD_INT 0
9932: PPUSH
9933: PPUSH
9934: PPUSH
// result := true ;
9935: LD_ADDR_VAR 0 3
9939: PUSH
9940: LD_INT 1
9942: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
9943: LD_ADDR_VAR 0 5
9947: PUSH
9948: LD_VAR 0 2
9952: PPUSH
9953: CALL_OW 480
9957: ST_TO_ADDR
// if not tmp then
9958: LD_VAR 0 5
9962: NOT
9963: IFFALSE 9967
// exit ;
9965: GO 10016
// for i in tmp do
9967: LD_ADDR_VAR 0 4
9971: PUSH
9972: LD_VAR 0 5
9976: PUSH
9977: FOR_IN
9978: IFFALSE 10014
// if GetTech ( i , side ) <> state_researched then
9980: LD_VAR 0 4
9984: PPUSH
9985: LD_VAR 0 1
9989: PPUSH
9990: CALL_OW 321
9994: PUSH
9995: LD_INT 2
9997: NONEQUAL
9998: IFFALSE 10012
// begin result := false ;
10000: LD_ADDR_VAR 0 3
10004: PUSH
10005: LD_INT 0
10007: ST_TO_ADDR
// exit ;
10008: POP
10009: POP
10010: GO 10016
// end ;
10012: GO 9977
10014: POP
10015: POP
// end ;
10016: LD_VAR 0 3
10020: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
10025: PPUSH
10026: PPUSH
10027: PPUSH
10028: PPUSH
10029: PPUSH
10030: PPUSH
10031: PPUSH
10032: PPUSH
10033: PPUSH
10034: PPUSH
10035: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
10036: LD_VAR 0 1
10040: NOT
10041: PUSH
10042: LD_VAR 0 1
10046: PPUSH
10047: CALL_OW 257
10051: PUSH
10052: LD_INT 9
10054: NONEQUAL
10055: OR
10056: IFFALSE 10060
// exit ;
10058: GO 10633
// side := GetSide ( unit ) ;
10060: LD_ADDR_VAR 0 9
10064: PUSH
10065: LD_VAR 0 1
10069: PPUSH
10070: CALL_OW 255
10074: ST_TO_ADDR
// tech_space := tech_spacanom ;
10075: LD_ADDR_VAR 0 12
10079: PUSH
10080: LD_INT 29
10082: ST_TO_ADDR
// tech_time := tech_taurad ;
10083: LD_ADDR_VAR 0 13
10087: PUSH
10088: LD_INT 28
10090: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
10091: LD_ADDR_VAR 0 11
10095: PUSH
10096: LD_VAR 0 1
10100: PPUSH
10101: CALL_OW 310
10105: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
10106: LD_VAR 0 11
10110: PPUSH
10111: CALL_OW 247
10115: PUSH
10116: LD_INT 2
10118: EQUAL
10119: IFFALSE 10123
// exit ;
10121: GO 10633
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
10123: LD_ADDR_VAR 0 8
10127: PUSH
10128: LD_INT 81
10130: PUSH
10131: LD_VAR 0 9
10135: PUSH
10136: EMPTY
10137: LIST
10138: LIST
10139: PUSH
10140: LD_INT 3
10142: PUSH
10143: LD_INT 21
10145: PUSH
10146: LD_INT 3
10148: PUSH
10149: EMPTY
10150: LIST
10151: LIST
10152: PUSH
10153: EMPTY
10154: LIST
10155: LIST
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PPUSH
10161: CALL_OW 69
10165: ST_TO_ADDR
// if not tmp then
10166: LD_VAR 0 8
10170: NOT
10171: IFFALSE 10175
// exit ;
10173: GO 10633
// if in_unit then
10175: LD_VAR 0 11
10179: IFFALSE 10203
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
10181: LD_ADDR_VAR 0 10
10185: PUSH
10186: LD_VAR 0 8
10190: PPUSH
10191: LD_VAR 0 11
10195: PPUSH
10196: CALL_OW 74
10200: ST_TO_ADDR
10201: GO 10223
// enemy := NearestUnitToUnit ( tmp , unit ) ;
10203: LD_ADDR_VAR 0 10
10207: PUSH
10208: LD_VAR 0 8
10212: PPUSH
10213: LD_VAR 0 1
10217: PPUSH
10218: CALL_OW 74
10222: ST_TO_ADDR
// if not enemy then
10223: LD_VAR 0 10
10227: NOT
10228: IFFALSE 10232
// exit ;
10230: GO 10633
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
10232: LD_VAR 0 11
10236: PUSH
10237: LD_VAR 0 11
10241: PPUSH
10242: LD_VAR 0 10
10246: PPUSH
10247: CALL_OW 296
10251: PUSH
10252: LD_INT 13
10254: GREATER
10255: AND
10256: PUSH
10257: LD_VAR 0 1
10261: PPUSH
10262: LD_VAR 0 10
10266: PPUSH
10267: CALL_OW 296
10271: PUSH
10272: LD_INT 12
10274: GREATER
10275: OR
10276: IFFALSE 10280
// exit ;
10278: GO 10633
// missile := [ 1 ] ;
10280: LD_ADDR_VAR 0 14
10284: PUSH
10285: LD_INT 1
10287: PUSH
10288: EMPTY
10289: LIST
10290: ST_TO_ADDR
// if Researched ( side , tech_space ) then
10291: LD_VAR 0 9
10295: PPUSH
10296: LD_VAR 0 12
10300: PPUSH
10301: CALL_OW 325
10305: IFFALSE 10334
// missile := Insert ( missile , missile + 1 , 2 ) ;
10307: LD_ADDR_VAR 0 14
10311: PUSH
10312: LD_VAR 0 14
10316: PPUSH
10317: LD_VAR 0 14
10321: PUSH
10322: LD_INT 1
10324: PLUS
10325: PPUSH
10326: LD_INT 2
10328: PPUSH
10329: CALL_OW 2
10333: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
10334: LD_VAR 0 9
10338: PPUSH
10339: LD_VAR 0 13
10343: PPUSH
10344: CALL_OW 325
10348: PUSH
10349: LD_VAR 0 10
10353: PPUSH
10354: CALL_OW 255
10358: PPUSH
10359: LD_VAR 0 13
10363: PPUSH
10364: CALL_OW 325
10368: NOT
10369: AND
10370: IFFALSE 10399
// missile := Insert ( missile , missile + 1 , 3 ) ;
10372: LD_ADDR_VAR 0 14
10376: PUSH
10377: LD_VAR 0 14
10381: PPUSH
10382: LD_VAR 0 14
10386: PUSH
10387: LD_INT 1
10389: PLUS
10390: PPUSH
10391: LD_INT 3
10393: PPUSH
10394: CALL_OW 2
10398: ST_TO_ADDR
// if missile < 2 then
10399: LD_VAR 0 14
10403: PUSH
10404: LD_INT 2
10406: LESS
10407: IFFALSE 10411
// exit ;
10409: GO 10633
// x := GetX ( enemy ) ;
10411: LD_ADDR_VAR 0 4
10415: PUSH
10416: LD_VAR 0 10
10420: PPUSH
10421: CALL_OW 250
10425: ST_TO_ADDR
// y := GetY ( enemy ) ;
10426: LD_ADDR_VAR 0 5
10430: PUSH
10431: LD_VAR 0 10
10435: PPUSH
10436: CALL_OW 251
10440: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
10441: LD_ADDR_VAR 0 6
10445: PUSH
10446: LD_VAR 0 4
10450: PUSH
10451: LD_INT 1
10453: NEG
10454: PPUSH
10455: LD_INT 1
10457: PPUSH
10458: CALL_OW 12
10462: PLUS
10463: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
10464: LD_ADDR_VAR 0 7
10468: PUSH
10469: LD_VAR 0 5
10473: PUSH
10474: LD_INT 1
10476: NEG
10477: PPUSH
10478: LD_INT 1
10480: PPUSH
10481: CALL_OW 12
10485: PLUS
10486: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10487: LD_VAR 0 6
10491: PPUSH
10492: LD_VAR 0 7
10496: PPUSH
10497: CALL_OW 488
10501: NOT
10502: IFFALSE 10524
// begin _x := x ;
10504: LD_ADDR_VAR 0 6
10508: PUSH
10509: LD_VAR 0 4
10513: ST_TO_ADDR
// _y := y ;
10514: LD_ADDR_VAR 0 7
10518: PUSH
10519: LD_VAR 0 5
10523: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
10524: LD_ADDR_VAR 0 3
10528: PUSH
10529: LD_INT 1
10531: PPUSH
10532: LD_VAR 0 14
10536: PPUSH
10537: CALL_OW 12
10541: ST_TO_ADDR
// case i of 1 :
10542: LD_VAR 0 3
10546: PUSH
10547: LD_INT 1
10549: DOUBLE
10550: EQUAL
10551: IFTRUE 10555
10553: GO 10572
10555: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
10556: LD_VAR 0 1
10560: PPUSH
10561: LD_VAR 0 10
10565: PPUSH
10566: CALL_OW 115
10570: GO 10633
10572: LD_INT 2
10574: DOUBLE
10575: EQUAL
10576: IFTRUE 10580
10578: GO 10602
10580: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
10581: LD_VAR 0 1
10585: PPUSH
10586: LD_VAR 0 6
10590: PPUSH
10591: LD_VAR 0 7
10595: PPUSH
10596: CALL_OW 153
10600: GO 10633
10602: LD_INT 3
10604: DOUBLE
10605: EQUAL
10606: IFTRUE 10610
10608: GO 10632
10610: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
10611: LD_VAR 0 1
10615: PPUSH
10616: LD_VAR 0 6
10620: PPUSH
10621: LD_VAR 0 7
10625: PPUSH
10626: CALL_OW 154
10630: GO 10633
10632: POP
// end ;
10633: LD_VAR 0 2
10637: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
10638: LD_INT 0
10640: PPUSH
10641: PPUSH
10642: PPUSH
10643: PPUSH
10644: PPUSH
10645: PPUSH
// if not unit or not building then
10646: LD_VAR 0 1
10650: NOT
10651: PUSH
10652: LD_VAR 0 2
10656: NOT
10657: OR
10658: IFFALSE 10662
// exit ;
10660: GO 10820
// x := GetX ( building ) ;
10662: LD_ADDR_VAR 0 5
10666: PUSH
10667: LD_VAR 0 2
10671: PPUSH
10672: CALL_OW 250
10676: ST_TO_ADDR
// y := GetY ( building ) ;
10677: LD_ADDR_VAR 0 6
10681: PUSH
10682: LD_VAR 0 2
10686: PPUSH
10687: CALL_OW 251
10691: ST_TO_ADDR
// for i = 0 to 5 do
10692: LD_ADDR_VAR 0 4
10696: PUSH
10697: DOUBLE
10698: LD_INT 0
10700: DEC
10701: ST_TO_ADDR
10702: LD_INT 5
10704: PUSH
10705: FOR_TO
10706: IFFALSE 10818
// begin _x := ShiftX ( x , i , 3 ) ;
10708: LD_ADDR_VAR 0 7
10712: PUSH
10713: LD_VAR 0 5
10717: PPUSH
10718: LD_VAR 0 4
10722: PPUSH
10723: LD_INT 3
10725: PPUSH
10726: CALL_OW 272
10730: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
10731: LD_ADDR_VAR 0 8
10735: PUSH
10736: LD_VAR 0 6
10740: PPUSH
10741: LD_VAR 0 4
10745: PPUSH
10746: LD_INT 3
10748: PPUSH
10749: CALL_OW 273
10753: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
10754: LD_VAR 0 7
10758: PPUSH
10759: LD_VAR 0 8
10763: PPUSH
10764: CALL_OW 488
10768: NOT
10769: IFFALSE 10773
// continue ;
10771: GO 10705
// if HexInfo ( _x , _y ) = 0 then
10773: LD_VAR 0 7
10777: PPUSH
10778: LD_VAR 0 8
10782: PPUSH
10783: CALL_OW 428
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: IFFALSE 10816
// begin ComMoveXY ( unit , _x , _y ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_VAR 0 7
10802: PPUSH
10803: LD_VAR 0 8
10807: PPUSH
10808: CALL_OW 111
// exit ;
10812: POP
10813: POP
10814: GO 10820
// end ; end ;
10816: GO 10705
10818: POP
10819: POP
// end ;
10820: LD_VAR 0 3
10824: RET
// export function ScanBase ( side , base_area ) ; begin
10825: LD_INT 0
10827: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
10828: LD_ADDR_VAR 0 3
10832: PUSH
10833: LD_VAR 0 2
10837: PPUSH
10838: LD_INT 81
10840: PUSH
10841: LD_VAR 0 1
10845: PUSH
10846: EMPTY
10847: LIST
10848: LIST
10849: PPUSH
10850: CALL_OW 70
10854: ST_TO_ADDR
// end ;
10855: LD_VAR 0 3
10859: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
10860: LD_INT 0
10862: PPUSH
10863: PPUSH
10864: PPUSH
10865: PPUSH
// result := false ;
10866: LD_ADDR_VAR 0 2
10870: PUSH
10871: LD_INT 0
10873: ST_TO_ADDR
// side := GetSide ( unit ) ;
10874: LD_ADDR_VAR 0 3
10878: PUSH
10879: LD_VAR 0 1
10883: PPUSH
10884: CALL_OW 255
10888: ST_TO_ADDR
// nat := GetNation ( unit ) ;
10889: LD_ADDR_VAR 0 4
10893: PUSH
10894: LD_VAR 0 1
10898: PPUSH
10899: CALL_OW 248
10903: ST_TO_ADDR
// case nat of 1 :
10904: LD_VAR 0 4
10908: PUSH
10909: LD_INT 1
10911: DOUBLE
10912: EQUAL
10913: IFTRUE 10917
10915: GO 10928
10917: POP
// tech := tech_lassight ; 2 :
10918: LD_ADDR_VAR 0 5
10922: PUSH
10923: LD_INT 12
10925: ST_TO_ADDR
10926: GO 10967
10928: LD_INT 2
10930: DOUBLE
10931: EQUAL
10932: IFTRUE 10936
10934: GO 10947
10936: POP
// tech := tech_mortar ; 3 :
10937: LD_ADDR_VAR 0 5
10941: PUSH
10942: LD_INT 41
10944: ST_TO_ADDR
10945: GO 10967
10947: LD_INT 3
10949: DOUBLE
10950: EQUAL
10951: IFTRUE 10955
10953: GO 10966
10955: POP
// tech := tech_bazooka ; end ;
10956: LD_ADDR_VAR 0 5
10960: PUSH
10961: LD_INT 44
10963: ST_TO_ADDR
10964: GO 10967
10966: POP
// if Researched ( side , tech ) then
10967: LD_VAR 0 3
10971: PPUSH
10972: LD_VAR 0 5
10976: PPUSH
10977: CALL_OW 325
10981: IFFALSE 11008
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
10983: LD_ADDR_VAR 0 2
10987: PUSH
10988: LD_INT 5
10990: PUSH
10991: LD_INT 8
10993: PUSH
10994: LD_INT 9
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: LIST
11001: PUSH
11002: LD_VAR 0 4
11006: ARRAY
11007: ST_TO_ADDR
// end ;
11008: LD_VAR 0 2
11012: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
11013: LD_INT 0
11015: PPUSH
11016: PPUSH
11017: PPUSH
// if not mines then
11018: LD_VAR 0 2
11022: NOT
11023: IFFALSE 11027
// exit ;
11025: GO 11171
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
11027: LD_ADDR_VAR 0 5
11031: PUSH
11032: LD_INT 81
11034: PUSH
11035: LD_VAR 0 1
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: PUSH
11044: LD_INT 3
11046: PUSH
11047: LD_INT 21
11049: PUSH
11050: LD_INT 3
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PUSH
11057: EMPTY
11058: LIST
11059: LIST
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: PPUSH
11065: CALL_OW 69
11069: ST_TO_ADDR
// for i in mines do
11070: LD_ADDR_VAR 0 4
11074: PUSH
11075: LD_VAR 0 2
11079: PUSH
11080: FOR_IN
11081: IFFALSE 11169
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
11083: LD_VAR 0 4
11087: PUSH
11088: LD_INT 1
11090: ARRAY
11091: PPUSH
11092: LD_VAR 0 4
11096: PUSH
11097: LD_INT 2
11099: ARRAY
11100: PPUSH
11101: CALL_OW 458
11105: NOT
11106: IFFALSE 11110
// continue ;
11108: GO 11080
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
11110: LD_VAR 0 4
11114: PUSH
11115: LD_INT 1
11117: ARRAY
11118: PPUSH
11119: LD_VAR 0 4
11123: PUSH
11124: LD_INT 2
11126: ARRAY
11127: PPUSH
11128: CALL_OW 428
11132: PUSH
11133: LD_VAR 0 5
11137: IN
11138: IFFALSE 11167
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
11140: LD_VAR 0 4
11144: PUSH
11145: LD_INT 1
11147: ARRAY
11148: PPUSH
11149: LD_VAR 0 4
11153: PUSH
11154: LD_INT 2
11156: ARRAY
11157: PPUSH
11158: LD_VAR 0 1
11162: PPUSH
11163: CALL_OW 456
// end ;
11167: GO 11080
11169: POP
11170: POP
// end ;
11171: LD_VAR 0 3
11175: RET
// export function Count ( array ) ; var i ; begin
11176: LD_INT 0
11178: PPUSH
11179: PPUSH
// result := 0 ;
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 0
11187: ST_TO_ADDR
// for i in array do
11188: LD_ADDR_VAR 0 3
11192: PUSH
11193: LD_VAR 0 1
11197: PUSH
11198: FOR_IN
11199: IFFALSE 11223
// if i then
11201: LD_VAR 0 3
11205: IFFALSE 11221
// result := result + 1 ;
11207: LD_ADDR_VAR 0 2
11211: PUSH
11212: LD_VAR 0 2
11216: PUSH
11217: LD_INT 1
11219: PLUS
11220: ST_TO_ADDR
11221: GO 11198
11223: POP
11224: POP
// end ;
11225: LD_VAR 0 2
11229: RET
// export function IsEmpty ( building ) ; begin
11230: LD_INT 0
11232: PPUSH
// if not building then
11233: LD_VAR 0 1
11237: NOT
11238: IFFALSE 11242
// exit ;
11240: GO 11285
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
11242: LD_ADDR_VAR 0 2
11246: PUSH
11247: LD_VAR 0 1
11251: PUSH
11252: LD_INT 22
11254: PUSH
11255: LD_VAR 0 1
11259: PPUSH
11260: CALL_OW 255
11264: PUSH
11265: EMPTY
11266: LIST
11267: LIST
11268: PUSH
11269: LD_INT 58
11271: PUSH
11272: EMPTY
11273: LIST
11274: PUSH
11275: EMPTY
11276: LIST
11277: LIST
11278: PPUSH
11279: CALL_OW 69
11283: IN
11284: ST_TO_ADDR
// end ;
11285: LD_VAR 0 2
11289: RET
// export function IsNotFull ( building ) ; begin
11290: LD_INT 0
11292: PPUSH
// if not building then
11293: LD_VAR 0 1
11297: NOT
11298: IFFALSE 11302
// exit ;
11300: GO 11321
// result := UnitsInside ( building ) < 6 ;
11302: LD_ADDR_VAR 0 2
11306: PUSH
11307: LD_VAR 0 1
11311: PPUSH
11312: CALL_OW 313
11316: PUSH
11317: LD_INT 6
11319: LESS
11320: ST_TO_ADDR
// end ;
11321: LD_VAR 0 2
11325: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
11326: LD_INT 0
11328: PPUSH
11329: PPUSH
11330: PPUSH
11331: PPUSH
// tmp := [ ] ;
11332: LD_ADDR_VAR 0 3
11336: PUSH
11337: EMPTY
11338: ST_TO_ADDR
// list := [ ] ;
11339: LD_ADDR_VAR 0 5
11343: PUSH
11344: EMPTY
11345: ST_TO_ADDR
// for i = 16 to 25 do
11346: LD_ADDR_VAR 0 4
11350: PUSH
11351: DOUBLE
11352: LD_INT 16
11354: DEC
11355: ST_TO_ADDR
11356: LD_INT 25
11358: PUSH
11359: FOR_TO
11360: IFFALSE 11433
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
11362: LD_ADDR_VAR 0 3
11366: PUSH
11367: LD_VAR 0 3
11371: PUSH
11372: LD_INT 22
11374: PUSH
11375: LD_VAR 0 1
11379: PPUSH
11380: CALL_OW 255
11384: PUSH
11385: EMPTY
11386: LIST
11387: LIST
11388: PUSH
11389: LD_INT 91
11391: PUSH
11392: LD_VAR 0 1
11396: PUSH
11397: LD_INT 6
11399: PUSH
11400: EMPTY
11401: LIST
11402: LIST
11403: LIST
11404: PUSH
11405: LD_INT 30
11407: PUSH
11408: LD_VAR 0 4
11412: PUSH
11413: EMPTY
11414: LIST
11415: LIST
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: LIST
11421: PUSH
11422: EMPTY
11423: LIST
11424: PPUSH
11425: CALL_OW 69
11429: ADD
11430: ST_TO_ADDR
11431: GO 11359
11433: POP
11434: POP
// for i = 1 to tmp do
11435: LD_ADDR_VAR 0 4
11439: PUSH
11440: DOUBLE
11441: LD_INT 1
11443: DEC
11444: ST_TO_ADDR
11445: LD_VAR 0 3
11449: PUSH
11450: FOR_TO
11451: IFFALSE 11539
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
11453: LD_ADDR_VAR 0 5
11457: PUSH
11458: LD_VAR 0 5
11462: PUSH
11463: LD_VAR 0 3
11467: PUSH
11468: LD_VAR 0 4
11472: ARRAY
11473: PPUSH
11474: CALL_OW 266
11478: PUSH
11479: LD_VAR 0 3
11483: PUSH
11484: LD_VAR 0 4
11488: ARRAY
11489: PPUSH
11490: CALL_OW 250
11494: PUSH
11495: LD_VAR 0 3
11499: PUSH
11500: LD_VAR 0 4
11504: ARRAY
11505: PPUSH
11506: CALL_OW 251
11510: PUSH
11511: LD_VAR 0 3
11515: PUSH
11516: LD_VAR 0 4
11520: ARRAY
11521: PPUSH
11522: CALL_OW 254
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: PUSH
11533: EMPTY
11534: LIST
11535: ADD
11536: ST_TO_ADDR
11537: GO 11450
11539: POP
11540: POP
// result := list ;
11541: LD_ADDR_VAR 0 2
11545: PUSH
11546: LD_VAR 0 5
11550: ST_TO_ADDR
// end ;
11551: LD_VAR 0 2
11555: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
11556: LD_INT 0
11558: PPUSH
11559: PPUSH
11560: PPUSH
11561: PPUSH
11562: PPUSH
11563: PPUSH
11564: PPUSH
// if not factory then
11565: LD_VAR 0 1
11569: NOT
11570: IFFALSE 11574
// exit ;
11572: GO 12167
// if control = control_apeman then
11574: LD_VAR 0 4
11578: PUSH
11579: LD_INT 5
11581: EQUAL
11582: IFFALSE 11691
// begin tmp := UnitsInside ( factory ) ;
11584: LD_ADDR_VAR 0 8
11588: PUSH
11589: LD_VAR 0 1
11593: PPUSH
11594: CALL_OW 313
11598: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
11599: LD_VAR 0 8
11603: PPUSH
11604: LD_INT 25
11606: PUSH
11607: LD_INT 12
11609: PUSH
11610: EMPTY
11611: LIST
11612: LIST
11613: PPUSH
11614: CALL_OW 72
11618: NOT
11619: IFFALSE 11629
// control := control_manual ;
11621: LD_ADDR_VAR 0 4
11625: PUSH
11626: LD_INT 1
11628: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
11629: LD_ADDR_VAR 0 8
11633: PUSH
11634: LD_VAR 0 1
11638: PPUSH
11639: CALL 11326 0 1
11643: ST_TO_ADDR
// if tmp then
11644: LD_VAR 0 8
11648: IFFALSE 11691
// begin for i in tmp do
11650: LD_ADDR_VAR 0 7
11654: PUSH
11655: LD_VAR 0 8
11659: PUSH
11660: FOR_IN
11661: IFFALSE 11689
// if i [ 1 ] = b_ext_radio then
11663: LD_VAR 0 7
11667: PUSH
11668: LD_INT 1
11670: ARRAY
11671: PUSH
11672: LD_INT 22
11674: EQUAL
11675: IFFALSE 11687
// begin control := control_remote ;
11677: LD_ADDR_VAR 0 4
11681: PUSH
11682: LD_INT 2
11684: ST_TO_ADDR
// break ;
11685: GO 11689
// end ;
11687: GO 11660
11689: POP
11690: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: LD_VAR 0 3
11705: PPUSH
11706: LD_VAR 0 4
11710: PPUSH
11711: LD_VAR 0 5
11715: PPUSH
11716: CALL_OW 448
11720: IFFALSE 11755
// begin result := [ chassis , engine , control , weapon ] ;
11722: LD_ADDR_VAR 0 6
11726: PUSH
11727: LD_VAR 0 2
11731: PUSH
11732: LD_VAR 0 3
11736: PUSH
11737: LD_VAR 0 4
11741: PUSH
11742: LD_VAR 0 5
11746: PUSH
11747: EMPTY
11748: LIST
11749: LIST
11750: LIST
11751: LIST
11752: ST_TO_ADDR
// exit ;
11753: GO 12167
// end ; _chassis := AvailableChassisList ( factory ) ;
11755: LD_ADDR_VAR 0 9
11759: PUSH
11760: LD_VAR 0 1
11764: PPUSH
11765: CALL_OW 475
11769: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
11770: LD_ADDR_VAR 0 11
11774: PUSH
11775: LD_VAR 0 1
11779: PPUSH
11780: CALL_OW 476
11784: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
11785: LD_ADDR_VAR 0 12
11789: PUSH
11790: LD_VAR 0 1
11794: PPUSH
11795: CALL_OW 477
11799: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
11800: LD_ADDR_VAR 0 10
11804: PUSH
11805: LD_VAR 0 1
11809: PPUSH
11810: CALL_OW 478
11814: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
11815: LD_VAR 0 9
11819: NOT
11820: PUSH
11821: LD_VAR 0 11
11825: NOT
11826: OR
11827: PUSH
11828: LD_VAR 0 12
11832: NOT
11833: OR
11834: PUSH
11835: LD_VAR 0 10
11839: NOT
11840: OR
11841: IFFALSE 11876
// begin result := [ chassis , engine , control , weapon ] ;
11843: LD_ADDR_VAR 0 6
11847: PUSH
11848: LD_VAR 0 2
11852: PUSH
11853: LD_VAR 0 3
11857: PUSH
11858: LD_VAR 0 4
11862: PUSH
11863: LD_VAR 0 5
11867: PUSH
11868: EMPTY
11869: LIST
11870: LIST
11871: LIST
11872: LIST
11873: ST_TO_ADDR
// exit ;
11874: GO 12167
// end ; if not chassis in _chassis then
11876: LD_VAR 0 2
11880: PUSH
11881: LD_VAR 0 9
11885: IN
11886: NOT
11887: IFFALSE 11913
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
11889: LD_ADDR_VAR 0 2
11893: PUSH
11894: LD_VAR 0 9
11898: PUSH
11899: LD_INT 1
11901: PPUSH
11902: LD_VAR 0 9
11906: PPUSH
11907: CALL_OW 12
11911: ARRAY
11912: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
11913: LD_VAR 0 2
11917: PPUSH
11918: LD_VAR 0 3
11922: PPUSH
11923: CALL 12172 0 2
11927: NOT
11928: IFFALSE 11987
// repeat engine := _engine [ 1 ] ;
11930: LD_ADDR_VAR 0 3
11934: PUSH
11935: LD_VAR 0 11
11939: PUSH
11940: LD_INT 1
11942: ARRAY
11943: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
11944: LD_ADDR_VAR 0 11
11948: PUSH
11949: LD_VAR 0 11
11953: PPUSH
11954: LD_INT 1
11956: PPUSH
11957: CALL_OW 3
11961: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
11962: LD_VAR 0 2
11966: PPUSH
11967: LD_VAR 0 3
11971: PPUSH
11972: CALL 12172 0 2
11976: PUSH
11977: LD_VAR 0 11
11981: PUSH
11982: EMPTY
11983: EQUAL
11984: OR
11985: IFFALSE 11930
// if not control in _control then
11987: LD_VAR 0 4
11991: PUSH
11992: LD_VAR 0 12
11996: IN
11997: NOT
11998: IFFALSE 12024
// control := _control [ rand ( 1 , _control ) ] ;
12000: LD_ADDR_VAR 0 4
12004: PUSH
12005: LD_VAR 0 12
12009: PUSH
12010: LD_INT 1
12012: PPUSH
12013: LD_VAR 0 12
12017: PPUSH
12018: CALL_OW 12
12022: ARRAY
12023: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
12024: LD_VAR 0 2
12028: PPUSH
12029: LD_VAR 0 5
12033: PPUSH
12034: CALL 12392 0 2
12038: NOT
12039: IFFALSE 12098
// repeat weapon := _weapon [ 1 ] ;
12041: LD_ADDR_VAR 0 5
12045: PUSH
12046: LD_VAR 0 10
12050: PUSH
12051: LD_INT 1
12053: ARRAY
12054: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
12055: LD_ADDR_VAR 0 10
12059: PUSH
12060: LD_VAR 0 10
12064: PPUSH
12065: LD_INT 1
12067: PPUSH
12068: CALL_OW 3
12072: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
12073: LD_VAR 0 2
12077: PPUSH
12078: LD_VAR 0 5
12082: PPUSH
12083: CALL 12392 0 2
12087: PUSH
12088: LD_VAR 0 10
12092: PUSH
12093: EMPTY
12094: EQUAL
12095: OR
12096: IFFALSE 12041
// result := [ ] ;
12098: LD_ADDR_VAR 0 6
12102: PUSH
12103: EMPTY
12104: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
12105: LD_VAR 0 1
12109: PPUSH
12110: LD_VAR 0 2
12114: PPUSH
12115: LD_VAR 0 3
12119: PPUSH
12120: LD_VAR 0 4
12124: PPUSH
12125: LD_VAR 0 5
12129: PPUSH
12130: CALL_OW 448
12134: IFFALSE 12167
// result := [ chassis , engine , control , weapon ] ;
12136: LD_ADDR_VAR 0 6
12140: PUSH
12141: LD_VAR 0 2
12145: PUSH
12146: LD_VAR 0 3
12150: PUSH
12151: LD_VAR 0 4
12155: PUSH
12156: LD_VAR 0 5
12160: PUSH
12161: EMPTY
12162: LIST
12163: LIST
12164: LIST
12165: LIST
12166: ST_TO_ADDR
// end ;
12167: LD_VAR 0 6
12171: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
12172: LD_INT 0
12174: PPUSH
// if not chassis or not engine then
12175: LD_VAR 0 1
12179: NOT
12180: PUSH
12181: LD_VAR 0 2
12185: NOT
12186: OR
12187: IFFALSE 12191
// exit ;
12189: GO 12387
// case engine of engine_solar :
12191: LD_VAR 0 2
12195: PUSH
12196: LD_INT 2
12198: DOUBLE
12199: EQUAL
12200: IFTRUE 12204
12202: GO 12242
12204: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
12205: LD_ADDR_VAR 0 3
12209: PUSH
12210: LD_INT 11
12212: PUSH
12213: LD_INT 12
12215: PUSH
12216: LD_INT 13
12218: PUSH
12219: LD_INT 14
12221: PUSH
12222: LD_INT 1
12224: PUSH
12225: LD_INT 2
12227: PUSH
12228: LD_INT 3
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: ST_TO_ADDR
12240: GO 12371
12242: LD_INT 1
12244: DOUBLE
12245: EQUAL
12246: IFTRUE 12250
12248: GO 12312
12250: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
12251: LD_ADDR_VAR 0 3
12255: PUSH
12256: LD_INT 11
12258: PUSH
12259: LD_INT 12
12261: PUSH
12262: LD_INT 13
12264: PUSH
12265: LD_INT 14
12267: PUSH
12268: LD_INT 1
12270: PUSH
12271: LD_INT 2
12273: PUSH
12274: LD_INT 3
12276: PUSH
12277: LD_INT 4
12279: PUSH
12280: LD_INT 5
12282: PUSH
12283: LD_INT 21
12285: PUSH
12286: LD_INT 23
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 24
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: ST_TO_ADDR
12310: GO 12371
12312: LD_INT 3
12314: DOUBLE
12315: EQUAL
12316: IFTRUE 12320
12318: GO 12370
12320: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
12321: LD_ADDR_VAR 0 3
12325: PUSH
12326: LD_INT 13
12328: PUSH
12329: LD_INT 14
12331: PUSH
12332: LD_INT 2
12334: PUSH
12335: LD_INT 3
12337: PUSH
12338: LD_INT 4
12340: PUSH
12341: LD_INT 5
12343: PUSH
12344: LD_INT 21
12346: PUSH
12347: LD_INT 22
12349: PUSH
12350: LD_INT 23
12352: PUSH
12353: LD_INT 24
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: LIST
12367: ST_TO_ADDR
12368: GO 12371
12370: POP
// result := ( chassis in result ) ;
12371: LD_ADDR_VAR 0 3
12375: PUSH
12376: LD_VAR 0 1
12380: PUSH
12381: LD_VAR 0 3
12385: IN
12386: ST_TO_ADDR
// end ;
12387: LD_VAR 0 3
12391: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
12392: LD_INT 0
12394: PPUSH
// if not chassis or not weapon then
12395: LD_VAR 0 1
12399: NOT
12400: PUSH
12401: LD_VAR 0 2
12405: NOT
12406: OR
12407: IFFALSE 12411
// exit ;
12409: GO 13473
// case weapon of us_machine_gun :
12411: LD_VAR 0 2
12415: PUSH
12416: LD_INT 2
12418: DOUBLE
12419: EQUAL
12420: IFTRUE 12424
12422: GO 12454
12424: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
12425: LD_ADDR_VAR 0 3
12429: PUSH
12430: LD_INT 1
12432: PUSH
12433: LD_INT 2
12435: PUSH
12436: LD_INT 3
12438: PUSH
12439: LD_INT 4
12441: PUSH
12442: LD_INT 5
12444: PUSH
12445: EMPTY
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: ST_TO_ADDR
12452: GO 13457
12454: LD_INT 3
12456: DOUBLE
12457: EQUAL
12458: IFTRUE 12462
12460: GO 12492
12462: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
12463: LD_ADDR_VAR 0 3
12467: PUSH
12468: LD_INT 1
12470: PUSH
12471: LD_INT 2
12473: PUSH
12474: LD_INT 3
12476: PUSH
12477: LD_INT 4
12479: PUSH
12480: LD_INT 5
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: LIST
12487: LIST
12488: LIST
12489: ST_TO_ADDR
12490: GO 13457
12492: LD_INT 11
12494: DOUBLE
12495: EQUAL
12496: IFTRUE 12500
12498: GO 12530
12500: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
12501: LD_ADDR_VAR 0 3
12505: PUSH
12506: LD_INT 1
12508: PUSH
12509: LD_INT 2
12511: PUSH
12512: LD_INT 3
12514: PUSH
12515: LD_INT 4
12517: PUSH
12518: LD_INT 5
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: LIST
12526: LIST
12527: ST_TO_ADDR
12528: GO 13457
12530: LD_INT 4
12532: DOUBLE
12533: EQUAL
12534: IFTRUE 12538
12536: GO 12564
12538: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_INT 2
12546: PUSH
12547: LD_INT 3
12549: PUSH
12550: LD_INT 4
12552: PUSH
12553: LD_INT 5
12555: PUSH
12556: EMPTY
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: ST_TO_ADDR
12562: GO 13457
12564: LD_INT 5
12566: DOUBLE
12567: EQUAL
12568: IFTRUE 12572
12570: GO 12598
12572: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
12573: LD_ADDR_VAR 0 3
12577: PUSH
12578: LD_INT 2
12580: PUSH
12581: LD_INT 3
12583: PUSH
12584: LD_INT 4
12586: PUSH
12587: LD_INT 5
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: ST_TO_ADDR
12596: GO 13457
12598: LD_INT 9
12600: DOUBLE
12601: EQUAL
12602: IFTRUE 12606
12604: GO 12632
12606: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
12607: LD_ADDR_VAR 0 3
12611: PUSH
12612: LD_INT 2
12614: PUSH
12615: LD_INT 3
12617: PUSH
12618: LD_INT 4
12620: PUSH
12621: LD_INT 5
12623: PUSH
12624: EMPTY
12625: LIST
12626: LIST
12627: LIST
12628: LIST
12629: ST_TO_ADDR
12630: GO 13457
12632: LD_INT 7
12634: DOUBLE
12635: EQUAL
12636: IFTRUE 12640
12638: GO 12666
12640: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
12641: LD_ADDR_VAR 0 3
12645: PUSH
12646: LD_INT 2
12648: PUSH
12649: LD_INT 3
12651: PUSH
12652: LD_INT 4
12654: PUSH
12655: LD_INT 5
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: LIST
12662: LIST
12663: ST_TO_ADDR
12664: GO 13457
12666: LD_INT 12
12668: DOUBLE
12669: EQUAL
12670: IFTRUE 12674
12672: GO 12700
12674: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
12675: LD_ADDR_VAR 0 3
12679: PUSH
12680: LD_INT 2
12682: PUSH
12683: LD_INT 3
12685: PUSH
12686: LD_INT 4
12688: PUSH
12689: LD_INT 5
12691: PUSH
12692: EMPTY
12693: LIST
12694: LIST
12695: LIST
12696: LIST
12697: ST_TO_ADDR
12698: GO 13457
12700: LD_INT 13
12702: DOUBLE
12703: EQUAL
12704: IFTRUE 12708
12706: GO 12734
12708: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
12709: LD_ADDR_VAR 0 3
12713: PUSH
12714: LD_INT 2
12716: PUSH
12717: LD_INT 3
12719: PUSH
12720: LD_INT 4
12722: PUSH
12723: LD_INT 5
12725: PUSH
12726: EMPTY
12727: LIST
12728: LIST
12729: LIST
12730: LIST
12731: ST_TO_ADDR
12732: GO 13457
12734: LD_INT 14
12736: DOUBLE
12737: EQUAL
12738: IFTRUE 12742
12740: GO 12760
12742: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
12743: LD_ADDR_VAR 0 3
12747: PUSH
12748: LD_INT 4
12750: PUSH
12751: LD_INT 5
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: ST_TO_ADDR
12758: GO 13457
12760: LD_INT 6
12762: DOUBLE
12763: EQUAL
12764: IFTRUE 12768
12766: GO 12786
12768: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
12769: LD_ADDR_VAR 0 3
12773: PUSH
12774: LD_INT 4
12776: PUSH
12777: LD_INT 5
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: ST_TO_ADDR
12784: GO 13457
12786: LD_INT 10
12788: DOUBLE
12789: EQUAL
12790: IFTRUE 12794
12792: GO 12812
12794: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
12795: LD_ADDR_VAR 0 3
12799: PUSH
12800: LD_INT 4
12802: PUSH
12803: LD_INT 5
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: ST_TO_ADDR
12810: GO 13457
12812: LD_INT 22
12814: DOUBLE
12815: EQUAL
12816: IFTRUE 12820
12818: GO 12846
12820: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
12821: LD_ADDR_VAR 0 3
12825: PUSH
12826: LD_INT 11
12828: PUSH
12829: LD_INT 12
12831: PUSH
12832: LD_INT 13
12834: PUSH
12835: LD_INT 14
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: ST_TO_ADDR
12844: GO 13457
12846: LD_INT 23
12848: DOUBLE
12849: EQUAL
12850: IFTRUE 12854
12852: GO 12880
12854: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
12855: LD_ADDR_VAR 0 3
12859: PUSH
12860: LD_INT 11
12862: PUSH
12863: LD_INT 12
12865: PUSH
12866: LD_INT 13
12868: PUSH
12869: LD_INT 14
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: LIST
12876: LIST
12877: ST_TO_ADDR
12878: GO 13457
12880: LD_INT 24
12882: DOUBLE
12883: EQUAL
12884: IFTRUE 12888
12886: GO 12914
12888: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
12889: LD_ADDR_VAR 0 3
12893: PUSH
12894: LD_INT 11
12896: PUSH
12897: LD_INT 12
12899: PUSH
12900: LD_INT 13
12902: PUSH
12903: LD_INT 14
12905: PUSH
12906: EMPTY
12907: LIST
12908: LIST
12909: LIST
12910: LIST
12911: ST_TO_ADDR
12912: GO 13457
12914: LD_INT 30
12916: DOUBLE
12917: EQUAL
12918: IFTRUE 12922
12920: GO 12948
12922: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
12923: LD_ADDR_VAR 0 3
12927: PUSH
12928: LD_INT 11
12930: PUSH
12931: LD_INT 12
12933: PUSH
12934: LD_INT 13
12936: PUSH
12937: LD_INT 14
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: ST_TO_ADDR
12946: GO 13457
12948: LD_INT 25
12950: DOUBLE
12951: EQUAL
12952: IFTRUE 12956
12954: GO 12974
12956: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
12957: LD_ADDR_VAR 0 3
12961: PUSH
12962: LD_INT 13
12964: PUSH
12965: LD_INT 14
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: ST_TO_ADDR
12972: GO 13457
12974: LD_INT 27
12976: DOUBLE
12977: EQUAL
12978: IFTRUE 12982
12980: GO 13000
12982: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
12983: LD_ADDR_VAR 0 3
12987: PUSH
12988: LD_INT 13
12990: PUSH
12991: LD_INT 14
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: ST_TO_ADDR
12998: GO 13457
13000: LD_EXP 72
13004: DOUBLE
13005: EQUAL
13006: IFTRUE 13010
13008: GO 13036
13010: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
13011: LD_ADDR_VAR 0 3
13015: PUSH
13016: LD_INT 11
13018: PUSH
13019: LD_INT 12
13021: PUSH
13022: LD_INT 13
13024: PUSH
13025: LD_INT 14
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: ST_TO_ADDR
13034: GO 13457
13036: LD_INT 28
13038: DOUBLE
13039: EQUAL
13040: IFTRUE 13044
13042: GO 13062
13044: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
13045: LD_ADDR_VAR 0 3
13049: PUSH
13050: LD_INT 13
13052: PUSH
13053: LD_INT 14
13055: PUSH
13056: EMPTY
13057: LIST
13058: LIST
13059: ST_TO_ADDR
13060: GO 13457
13062: LD_INT 29
13064: DOUBLE
13065: EQUAL
13066: IFTRUE 13070
13068: GO 13088
13070: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
13071: LD_ADDR_VAR 0 3
13075: PUSH
13076: LD_INT 13
13078: PUSH
13079: LD_INT 14
13081: PUSH
13082: EMPTY
13083: LIST
13084: LIST
13085: ST_TO_ADDR
13086: GO 13457
13088: LD_INT 31
13090: DOUBLE
13091: EQUAL
13092: IFTRUE 13096
13094: GO 13114
13096: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
13097: LD_ADDR_VAR 0 3
13101: PUSH
13102: LD_INT 13
13104: PUSH
13105: LD_INT 14
13107: PUSH
13108: EMPTY
13109: LIST
13110: LIST
13111: ST_TO_ADDR
13112: GO 13457
13114: LD_INT 26
13116: DOUBLE
13117: EQUAL
13118: IFTRUE 13122
13120: GO 13140
13122: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
13123: LD_ADDR_VAR 0 3
13127: PUSH
13128: LD_INT 13
13130: PUSH
13131: LD_INT 14
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: ST_TO_ADDR
13138: GO 13457
13140: LD_INT 42
13142: DOUBLE
13143: EQUAL
13144: IFTRUE 13148
13146: GO 13174
13148: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
13149: LD_ADDR_VAR 0 3
13153: PUSH
13154: LD_INT 21
13156: PUSH
13157: LD_INT 22
13159: PUSH
13160: LD_INT 23
13162: PUSH
13163: LD_INT 24
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: ST_TO_ADDR
13172: GO 13457
13174: LD_INT 43
13176: DOUBLE
13177: EQUAL
13178: IFTRUE 13182
13180: GO 13208
13182: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
13183: LD_ADDR_VAR 0 3
13187: PUSH
13188: LD_INT 21
13190: PUSH
13191: LD_INT 22
13193: PUSH
13194: LD_INT 23
13196: PUSH
13197: LD_INT 24
13199: PUSH
13200: EMPTY
13201: LIST
13202: LIST
13203: LIST
13204: LIST
13205: ST_TO_ADDR
13206: GO 13457
13208: LD_INT 44
13210: DOUBLE
13211: EQUAL
13212: IFTRUE 13216
13214: GO 13242
13216: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
13217: LD_ADDR_VAR 0 3
13221: PUSH
13222: LD_INT 21
13224: PUSH
13225: LD_INT 22
13227: PUSH
13228: LD_INT 23
13230: PUSH
13231: LD_INT 24
13233: PUSH
13234: EMPTY
13235: LIST
13236: LIST
13237: LIST
13238: LIST
13239: ST_TO_ADDR
13240: GO 13457
13242: LD_INT 45
13244: DOUBLE
13245: EQUAL
13246: IFTRUE 13250
13248: GO 13276
13250: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
13251: LD_ADDR_VAR 0 3
13255: PUSH
13256: LD_INT 21
13258: PUSH
13259: LD_INT 22
13261: PUSH
13262: LD_INT 23
13264: PUSH
13265: LD_INT 24
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: LIST
13272: LIST
13273: ST_TO_ADDR
13274: GO 13457
13276: LD_INT 49
13278: DOUBLE
13279: EQUAL
13280: IFTRUE 13284
13282: GO 13310
13284: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
13285: LD_ADDR_VAR 0 3
13289: PUSH
13290: LD_INT 21
13292: PUSH
13293: LD_INT 22
13295: PUSH
13296: LD_INT 23
13298: PUSH
13299: LD_INT 24
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: ST_TO_ADDR
13308: GO 13457
13310: LD_INT 51
13312: DOUBLE
13313: EQUAL
13314: IFTRUE 13318
13316: GO 13344
13318: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
13319: LD_ADDR_VAR 0 3
13323: PUSH
13324: LD_INT 21
13326: PUSH
13327: LD_INT 22
13329: PUSH
13330: LD_INT 23
13332: PUSH
13333: LD_INT 24
13335: PUSH
13336: EMPTY
13337: LIST
13338: LIST
13339: LIST
13340: LIST
13341: ST_TO_ADDR
13342: GO 13457
13344: LD_INT 52
13346: DOUBLE
13347: EQUAL
13348: IFTRUE 13352
13350: GO 13378
13352: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
13353: LD_ADDR_VAR 0 3
13357: PUSH
13358: LD_INT 21
13360: PUSH
13361: LD_INT 22
13363: PUSH
13364: LD_INT 23
13366: PUSH
13367: LD_INT 24
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: ST_TO_ADDR
13376: GO 13457
13378: LD_INT 53
13380: DOUBLE
13381: EQUAL
13382: IFTRUE 13386
13384: GO 13404
13386: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
13387: LD_ADDR_VAR 0 3
13391: PUSH
13392: LD_INT 23
13394: PUSH
13395: LD_INT 24
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: ST_TO_ADDR
13402: GO 13457
13404: LD_INT 46
13406: DOUBLE
13407: EQUAL
13408: IFTRUE 13412
13410: GO 13430
13412: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
13413: LD_ADDR_VAR 0 3
13417: PUSH
13418: LD_INT 23
13420: PUSH
13421: LD_INT 24
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: ST_TO_ADDR
13428: GO 13457
13430: LD_INT 47
13432: DOUBLE
13433: EQUAL
13434: IFTRUE 13438
13436: GO 13456
13438: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
13439: LD_ADDR_VAR 0 3
13443: PUSH
13444: LD_INT 23
13446: PUSH
13447: LD_INT 24
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: ST_TO_ADDR
13454: GO 13457
13456: POP
// result := ( chassis in result ) ;
13457: LD_ADDR_VAR 0 3
13461: PUSH
13462: LD_VAR 0 1
13466: PUSH
13467: LD_VAR 0 3
13471: IN
13472: ST_TO_ADDR
// end ;
13473: LD_VAR 0 3
13477: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
13478: LD_INT 0
13480: PPUSH
13481: PPUSH
13482: PPUSH
13483: PPUSH
13484: PPUSH
13485: PPUSH
13486: PPUSH
// result := array ;
13487: LD_ADDR_VAR 0 5
13491: PUSH
13492: LD_VAR 0 1
13496: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
13497: LD_VAR 0 1
13501: NOT
13502: PUSH
13503: LD_VAR 0 2
13507: NOT
13508: OR
13509: PUSH
13510: LD_VAR 0 3
13514: NOT
13515: OR
13516: PUSH
13517: LD_VAR 0 2
13521: PUSH
13522: LD_VAR 0 1
13526: GREATER
13527: OR
13528: PUSH
13529: LD_VAR 0 3
13533: PUSH
13534: LD_VAR 0 1
13538: GREATER
13539: OR
13540: IFFALSE 13544
// exit ;
13542: GO 13840
// if direction then
13544: LD_VAR 0 4
13548: IFFALSE 13612
// begin d := 1 ;
13550: LD_ADDR_VAR 0 9
13554: PUSH
13555: LD_INT 1
13557: ST_TO_ADDR
// if i_from > i_to then
13558: LD_VAR 0 2
13562: PUSH
13563: LD_VAR 0 3
13567: GREATER
13568: IFFALSE 13594
// length := ( array - i_from ) + i_to else
13570: LD_ADDR_VAR 0 11
13574: PUSH
13575: LD_VAR 0 1
13579: PUSH
13580: LD_VAR 0 2
13584: MINUS
13585: PUSH
13586: LD_VAR 0 3
13590: PLUS
13591: ST_TO_ADDR
13592: GO 13610
// length := i_to - i_from ;
13594: LD_ADDR_VAR 0 11
13598: PUSH
13599: LD_VAR 0 3
13603: PUSH
13604: LD_VAR 0 2
13608: MINUS
13609: ST_TO_ADDR
// end else
13610: GO 13673
// begin d := - 1 ;
13612: LD_ADDR_VAR 0 9
13616: PUSH
13617: LD_INT 1
13619: NEG
13620: ST_TO_ADDR
// if i_from > i_to then
13621: LD_VAR 0 2
13625: PUSH
13626: LD_VAR 0 3
13630: GREATER
13631: IFFALSE 13651
// length := i_from - i_to else
13633: LD_ADDR_VAR 0 11
13637: PUSH
13638: LD_VAR 0 2
13642: PUSH
13643: LD_VAR 0 3
13647: MINUS
13648: ST_TO_ADDR
13649: GO 13673
// length := ( array - i_to ) + i_from ;
13651: LD_ADDR_VAR 0 11
13655: PUSH
13656: LD_VAR 0 1
13660: PUSH
13661: LD_VAR 0 3
13665: MINUS
13666: PUSH
13667: LD_VAR 0 2
13671: PLUS
13672: ST_TO_ADDR
// end ; if not length then
13673: LD_VAR 0 11
13677: NOT
13678: IFFALSE 13682
// exit ;
13680: GO 13840
// tmp := array ;
13682: LD_ADDR_VAR 0 10
13686: PUSH
13687: LD_VAR 0 1
13691: ST_TO_ADDR
// for i = 1 to length do
13692: LD_ADDR_VAR 0 6
13696: PUSH
13697: DOUBLE
13698: LD_INT 1
13700: DEC
13701: ST_TO_ADDR
13702: LD_VAR 0 11
13706: PUSH
13707: FOR_TO
13708: IFFALSE 13828
// begin for j = 1 to array do
13710: LD_ADDR_VAR 0 7
13714: PUSH
13715: DOUBLE
13716: LD_INT 1
13718: DEC
13719: ST_TO_ADDR
13720: LD_VAR 0 1
13724: PUSH
13725: FOR_TO
13726: IFFALSE 13814
// begin k := j + d ;
13728: LD_ADDR_VAR 0 8
13732: PUSH
13733: LD_VAR 0 7
13737: PUSH
13738: LD_VAR 0 9
13742: PLUS
13743: ST_TO_ADDR
// if k > array then
13744: LD_VAR 0 8
13748: PUSH
13749: LD_VAR 0 1
13753: GREATER
13754: IFFALSE 13764
// k := 1 ;
13756: LD_ADDR_VAR 0 8
13760: PUSH
13761: LD_INT 1
13763: ST_TO_ADDR
// if not k then
13764: LD_VAR 0 8
13768: NOT
13769: IFFALSE 13781
// k := array ;
13771: LD_ADDR_VAR 0 8
13775: PUSH
13776: LD_VAR 0 1
13780: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
13781: LD_ADDR_VAR 0 10
13785: PUSH
13786: LD_VAR 0 10
13790: PPUSH
13791: LD_VAR 0 8
13795: PPUSH
13796: LD_VAR 0 1
13800: PUSH
13801: LD_VAR 0 7
13805: ARRAY
13806: PPUSH
13807: CALL_OW 1
13811: ST_TO_ADDR
// end ;
13812: GO 13725
13814: POP
13815: POP
// array := tmp ;
13816: LD_ADDR_VAR 0 1
13820: PUSH
13821: LD_VAR 0 10
13825: ST_TO_ADDR
// end ;
13826: GO 13707
13828: POP
13829: POP
// result := array ;
13830: LD_ADDR_VAR 0 5
13834: PUSH
13835: LD_VAR 0 1
13839: ST_TO_ADDR
// end ;
13840: LD_VAR 0 5
13844: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
13845: LD_INT 0
13847: PPUSH
13848: PPUSH
// result := 0 ;
13849: LD_ADDR_VAR 0 3
13853: PUSH
13854: LD_INT 0
13856: ST_TO_ADDR
// if not array or not value in array then
13857: LD_VAR 0 1
13861: NOT
13862: PUSH
13863: LD_VAR 0 2
13867: PUSH
13868: LD_VAR 0 1
13872: IN
13873: NOT
13874: OR
13875: IFFALSE 13879
// exit ;
13877: GO 13933
// for i = 1 to array do
13879: LD_ADDR_VAR 0 4
13883: PUSH
13884: DOUBLE
13885: LD_INT 1
13887: DEC
13888: ST_TO_ADDR
13889: LD_VAR 0 1
13893: PUSH
13894: FOR_TO
13895: IFFALSE 13931
// if value = array [ i ] then
13897: LD_VAR 0 2
13901: PUSH
13902: LD_VAR 0 1
13906: PUSH
13907: LD_VAR 0 4
13911: ARRAY
13912: EQUAL
13913: IFFALSE 13929
// begin result := i ;
13915: LD_ADDR_VAR 0 3
13919: PUSH
13920: LD_VAR 0 4
13924: ST_TO_ADDR
// exit ;
13925: POP
13926: POP
13927: GO 13933
// end ;
13929: GO 13894
13931: POP
13932: POP
// end ;
13933: LD_VAR 0 3
13937: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
13938: LD_INT 0
13940: PPUSH
// vc_chassis := chassis ;
13941: LD_ADDR_OWVAR 37
13945: PUSH
13946: LD_VAR 0 1
13950: ST_TO_ADDR
// vc_engine := engine ;
13951: LD_ADDR_OWVAR 39
13955: PUSH
13956: LD_VAR 0 2
13960: ST_TO_ADDR
// vc_control := control ;
13961: LD_ADDR_OWVAR 38
13965: PUSH
13966: LD_VAR 0 3
13970: ST_TO_ADDR
// vc_weapon := weapon ;
13971: LD_ADDR_OWVAR 40
13975: PUSH
13976: LD_VAR 0 4
13980: ST_TO_ADDR
// vc_fuel_battery := fuel ;
13981: LD_ADDR_OWVAR 41
13985: PUSH
13986: LD_VAR 0 5
13990: ST_TO_ADDR
// end ;
13991: LD_VAR 0 6
13995: RET
// export function WantPlant ( unit ) ; var task ; begin
13996: LD_INT 0
13998: PPUSH
13999: PPUSH
// result := false ;
14000: LD_ADDR_VAR 0 2
14004: PUSH
14005: LD_INT 0
14007: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: LD_VAR 0 1
14017: PPUSH
14018: CALL_OW 437
14022: ST_TO_ADDR
// if task then
14023: LD_VAR 0 3
14027: IFFALSE 14055
// if task [ 1 ] [ 1 ] = p then
14029: LD_VAR 0 3
14033: PUSH
14034: LD_INT 1
14036: ARRAY
14037: PUSH
14038: LD_INT 1
14040: ARRAY
14041: PUSH
14042: LD_STRING p
14044: EQUAL
14045: IFFALSE 14055
// result := true ;
14047: LD_ADDR_VAR 0 2
14051: PUSH
14052: LD_INT 1
14054: ST_TO_ADDR
// end ;
14055: LD_VAR 0 2
14059: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
14060: LD_INT 0
14062: PPUSH
14063: PPUSH
14064: PPUSH
14065: PPUSH
// if pos < 1 then
14066: LD_VAR 0 2
14070: PUSH
14071: LD_INT 1
14073: LESS
14074: IFFALSE 14078
// exit ;
14076: GO 14381
// if pos = 1 then
14078: LD_VAR 0 2
14082: PUSH
14083: LD_INT 1
14085: EQUAL
14086: IFFALSE 14119
// result := Replace ( arr , pos [ 1 ] , value ) else
14088: LD_ADDR_VAR 0 4
14092: PUSH
14093: LD_VAR 0 1
14097: PPUSH
14098: LD_VAR 0 2
14102: PUSH
14103: LD_INT 1
14105: ARRAY
14106: PPUSH
14107: LD_VAR 0 3
14111: PPUSH
14112: CALL_OW 1
14116: ST_TO_ADDR
14117: GO 14381
// begin tmp := arr ;
14119: LD_ADDR_VAR 0 6
14123: PUSH
14124: LD_VAR 0 1
14128: ST_TO_ADDR
// s_arr := [ tmp ] ;
14129: LD_ADDR_VAR 0 7
14133: PUSH
14134: LD_VAR 0 6
14138: PUSH
14139: EMPTY
14140: LIST
14141: ST_TO_ADDR
// for i = 1 to pos - 1 do
14142: LD_ADDR_VAR 0 5
14146: PUSH
14147: DOUBLE
14148: LD_INT 1
14150: DEC
14151: ST_TO_ADDR
14152: LD_VAR 0 2
14156: PUSH
14157: LD_INT 1
14159: MINUS
14160: PUSH
14161: FOR_TO
14162: IFFALSE 14207
// begin tmp := tmp [ pos [ i ] ] ;
14164: LD_ADDR_VAR 0 6
14168: PUSH
14169: LD_VAR 0 6
14173: PUSH
14174: LD_VAR 0 2
14178: PUSH
14179: LD_VAR 0 5
14183: ARRAY
14184: ARRAY
14185: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
14186: LD_ADDR_VAR 0 7
14190: PUSH
14191: LD_VAR 0 7
14195: PUSH
14196: LD_VAR 0 6
14200: PUSH
14201: EMPTY
14202: LIST
14203: ADD
14204: ST_TO_ADDR
// end ;
14205: GO 14161
14207: POP
14208: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
14209: LD_ADDR_VAR 0 6
14213: PUSH
14214: LD_VAR 0 6
14218: PPUSH
14219: LD_VAR 0 2
14223: PUSH
14224: LD_VAR 0 2
14228: ARRAY
14229: PPUSH
14230: LD_VAR 0 3
14234: PPUSH
14235: CALL_OW 1
14239: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
14240: LD_ADDR_VAR 0 7
14244: PUSH
14245: LD_VAR 0 7
14249: PPUSH
14250: LD_VAR 0 7
14254: PPUSH
14255: LD_VAR 0 6
14259: PPUSH
14260: CALL_OW 1
14264: ST_TO_ADDR
// for i = s_arr downto 2 do
14265: LD_ADDR_VAR 0 5
14269: PUSH
14270: DOUBLE
14271: LD_VAR 0 7
14275: INC
14276: ST_TO_ADDR
14277: LD_INT 2
14279: PUSH
14280: FOR_DOWNTO
14281: IFFALSE 14365
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
14283: LD_ADDR_VAR 0 6
14287: PUSH
14288: LD_VAR 0 7
14292: PUSH
14293: LD_VAR 0 5
14297: PUSH
14298: LD_INT 1
14300: MINUS
14301: ARRAY
14302: PPUSH
14303: LD_VAR 0 2
14307: PUSH
14308: LD_VAR 0 5
14312: PUSH
14313: LD_INT 1
14315: MINUS
14316: ARRAY
14317: PPUSH
14318: LD_VAR 0 7
14322: PUSH
14323: LD_VAR 0 5
14327: ARRAY
14328: PPUSH
14329: CALL_OW 1
14333: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
14334: LD_ADDR_VAR 0 7
14338: PUSH
14339: LD_VAR 0 7
14343: PPUSH
14344: LD_VAR 0 5
14348: PUSH
14349: LD_INT 1
14351: MINUS
14352: PPUSH
14353: LD_VAR 0 6
14357: PPUSH
14358: CALL_OW 1
14362: ST_TO_ADDR
// end ;
14363: GO 14280
14365: POP
14366: POP
// result := s_arr [ 1 ] ;
14367: LD_ADDR_VAR 0 4
14371: PUSH
14372: LD_VAR 0 7
14376: PUSH
14377: LD_INT 1
14379: ARRAY
14380: ST_TO_ADDR
// end ; end ;
14381: LD_VAR 0 4
14385: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
14386: LD_INT 0
14388: PPUSH
14389: PPUSH
// if not list then
14390: LD_VAR 0 1
14394: NOT
14395: IFFALSE 14399
// exit ;
14397: GO 14490
// i := list [ pos1 ] ;
14399: LD_ADDR_VAR 0 5
14403: PUSH
14404: LD_VAR 0 1
14408: PUSH
14409: LD_VAR 0 2
14413: ARRAY
14414: ST_TO_ADDR
// if not i then
14415: LD_VAR 0 5
14419: NOT
14420: IFFALSE 14424
// exit ;
14422: GO 14490
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
14424: LD_ADDR_VAR 0 1
14428: PUSH
14429: LD_VAR 0 1
14433: PPUSH
14434: LD_VAR 0 2
14438: PPUSH
14439: LD_VAR 0 1
14443: PUSH
14444: LD_VAR 0 3
14448: ARRAY
14449: PPUSH
14450: CALL_OW 1
14454: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
14455: LD_ADDR_VAR 0 1
14459: PUSH
14460: LD_VAR 0 1
14464: PPUSH
14465: LD_VAR 0 3
14469: PPUSH
14470: LD_VAR 0 5
14474: PPUSH
14475: CALL_OW 1
14479: ST_TO_ADDR
// result := list ;
14480: LD_ADDR_VAR 0 4
14484: PUSH
14485: LD_VAR 0 1
14489: ST_TO_ADDR
// end ;
14490: LD_VAR 0 4
14494: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
14495: LD_INT 0
14497: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
14498: LD_ADDR_VAR 0 5
14502: PUSH
14503: LD_VAR 0 1
14507: PPUSH
14508: CALL_OW 250
14512: PPUSH
14513: LD_VAR 0 1
14517: PPUSH
14518: CALL_OW 251
14522: PPUSH
14523: LD_VAR 0 2
14527: PPUSH
14528: LD_VAR 0 3
14532: PPUSH
14533: LD_VAR 0 4
14537: PPUSH
14538: CALL 14548 0 5
14542: ST_TO_ADDR
// end ;
14543: LD_VAR 0 5
14547: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
14548: LD_INT 0
14550: PPUSH
14551: PPUSH
14552: PPUSH
14553: PPUSH
// if not list then
14554: LD_VAR 0 3
14558: NOT
14559: IFFALSE 14563
// exit ;
14561: GO 14951
// result := [ ] ;
14563: LD_ADDR_VAR 0 6
14567: PUSH
14568: EMPTY
14569: ST_TO_ADDR
// for i in list do
14570: LD_ADDR_VAR 0 7
14574: PUSH
14575: LD_VAR 0 3
14579: PUSH
14580: FOR_IN
14581: IFFALSE 14783
// begin tmp := GetDistUnitXY ( i , x , y ) ;
14583: LD_ADDR_VAR 0 9
14587: PUSH
14588: LD_VAR 0 7
14592: PPUSH
14593: LD_VAR 0 1
14597: PPUSH
14598: LD_VAR 0 2
14602: PPUSH
14603: CALL_OW 297
14607: ST_TO_ADDR
// if not result then
14608: LD_VAR 0 6
14612: NOT
14613: IFFALSE 14639
// result := [ [ i , tmp ] ] else
14615: LD_ADDR_VAR 0 6
14619: PUSH
14620: LD_VAR 0 7
14624: PUSH
14625: LD_VAR 0 9
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: EMPTY
14635: LIST
14636: ST_TO_ADDR
14637: GO 14781
// begin if result [ result ] [ 2 ] < tmp then
14639: LD_VAR 0 6
14643: PUSH
14644: LD_VAR 0 6
14648: ARRAY
14649: PUSH
14650: LD_INT 2
14652: ARRAY
14653: PUSH
14654: LD_VAR 0 9
14658: LESS
14659: IFFALSE 14701
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
14661: LD_ADDR_VAR 0 6
14665: PUSH
14666: LD_VAR 0 6
14670: PPUSH
14671: LD_VAR 0 6
14675: PUSH
14676: LD_INT 1
14678: PLUS
14679: PPUSH
14680: LD_VAR 0 7
14684: PUSH
14685: LD_VAR 0 9
14689: PUSH
14690: EMPTY
14691: LIST
14692: LIST
14693: PPUSH
14694: CALL_OW 2
14698: ST_TO_ADDR
14699: GO 14781
// for j = 1 to result do
14701: LD_ADDR_VAR 0 8
14705: PUSH
14706: DOUBLE
14707: LD_INT 1
14709: DEC
14710: ST_TO_ADDR
14711: LD_VAR 0 6
14715: PUSH
14716: FOR_TO
14717: IFFALSE 14779
// begin if tmp < result [ j ] [ 2 ] then
14719: LD_VAR 0 9
14723: PUSH
14724: LD_VAR 0 6
14728: PUSH
14729: LD_VAR 0 8
14733: ARRAY
14734: PUSH
14735: LD_INT 2
14737: ARRAY
14738: LESS
14739: IFFALSE 14777
// begin result := Insert ( result , j , [ i , tmp ] ) ;
14741: LD_ADDR_VAR 0 6
14745: PUSH
14746: LD_VAR 0 6
14750: PPUSH
14751: LD_VAR 0 8
14755: PPUSH
14756: LD_VAR 0 7
14760: PUSH
14761: LD_VAR 0 9
14765: PUSH
14766: EMPTY
14767: LIST
14768: LIST
14769: PPUSH
14770: CALL_OW 2
14774: ST_TO_ADDR
// break ;
14775: GO 14779
// end ; end ;
14777: GO 14716
14779: POP
14780: POP
// end ; end ;
14781: GO 14580
14783: POP
14784: POP
// if result and not asc then
14785: LD_VAR 0 6
14789: PUSH
14790: LD_VAR 0 4
14794: NOT
14795: AND
14796: IFFALSE 14871
// begin tmp := result ;
14798: LD_ADDR_VAR 0 9
14802: PUSH
14803: LD_VAR 0 6
14807: ST_TO_ADDR
// for i = tmp downto 1 do
14808: LD_ADDR_VAR 0 7
14812: PUSH
14813: DOUBLE
14814: LD_VAR 0 9
14818: INC
14819: ST_TO_ADDR
14820: LD_INT 1
14822: PUSH
14823: FOR_DOWNTO
14824: IFFALSE 14869
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
14826: LD_ADDR_VAR 0 6
14830: PUSH
14831: LD_VAR 0 6
14835: PPUSH
14836: LD_VAR 0 9
14840: PUSH
14841: LD_VAR 0 7
14845: MINUS
14846: PUSH
14847: LD_INT 1
14849: PLUS
14850: PPUSH
14851: LD_VAR 0 9
14855: PUSH
14856: LD_VAR 0 7
14860: ARRAY
14861: PPUSH
14862: CALL_OW 1
14866: ST_TO_ADDR
14867: GO 14823
14869: POP
14870: POP
// end ; tmp := [ ] ;
14871: LD_ADDR_VAR 0 9
14875: PUSH
14876: EMPTY
14877: ST_TO_ADDR
// if mode then
14878: LD_VAR 0 5
14882: IFFALSE 14951
// begin for i = 1 to result do
14884: LD_ADDR_VAR 0 7
14888: PUSH
14889: DOUBLE
14890: LD_INT 1
14892: DEC
14893: ST_TO_ADDR
14894: LD_VAR 0 6
14898: PUSH
14899: FOR_TO
14900: IFFALSE 14939
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
14902: LD_ADDR_VAR 0 9
14906: PUSH
14907: LD_VAR 0 9
14911: PPUSH
14912: LD_VAR 0 7
14916: PPUSH
14917: LD_VAR 0 6
14921: PUSH
14922: LD_VAR 0 7
14926: ARRAY
14927: PUSH
14928: LD_INT 1
14930: ARRAY
14931: PPUSH
14932: CALL_OW 1
14936: ST_TO_ADDR
14937: GO 14899
14939: POP
14940: POP
// result := tmp ;
14941: LD_ADDR_VAR 0 6
14945: PUSH
14946: LD_VAR 0 9
14950: ST_TO_ADDR
// end ; end ;
14951: LD_VAR 0 6
14955: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
14956: LD_INT 0
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
14962: PPUSH
14963: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
14964: LD_ADDR_VAR 0 5
14968: PUSH
14969: LD_INT 0
14971: PUSH
14972: LD_INT 0
14974: PUSH
14975: LD_INT 0
14977: PUSH
14978: EMPTY
14979: PUSH
14980: EMPTY
14981: LIST
14982: LIST
14983: LIST
14984: LIST
14985: ST_TO_ADDR
// if not x or not y then
14986: LD_VAR 0 2
14990: NOT
14991: PUSH
14992: LD_VAR 0 3
14996: NOT
14997: OR
14998: IFFALSE 15002
// exit ;
15000: GO 16654
// if not range then
15002: LD_VAR 0 4
15006: NOT
15007: IFFALSE 15017
// range := 10 ;
15009: LD_ADDR_VAR 0 4
15013: PUSH
15014: LD_INT 10
15016: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15017: LD_ADDR_VAR 0 8
15021: PUSH
15022: LD_INT 81
15024: PUSH
15025: LD_VAR 0 1
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: PUSH
15034: LD_INT 92
15036: PUSH
15037: LD_VAR 0 2
15041: PUSH
15042: LD_VAR 0 3
15046: PUSH
15047: LD_VAR 0 4
15051: PUSH
15052: EMPTY
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: PUSH
15058: LD_INT 3
15060: PUSH
15061: LD_INT 21
15063: PUSH
15064: LD_INT 3
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: PUSH
15071: EMPTY
15072: LIST
15073: LIST
15074: PUSH
15075: EMPTY
15076: LIST
15077: LIST
15078: LIST
15079: PPUSH
15080: CALL_OW 69
15084: ST_TO_ADDR
// if not tmp then
15085: LD_VAR 0 8
15089: NOT
15090: IFFALSE 15094
// exit ;
15092: GO 16654
// for i in tmp do
15094: LD_ADDR_VAR 0 6
15098: PUSH
15099: LD_VAR 0 8
15103: PUSH
15104: FOR_IN
15105: IFFALSE 16629
// begin points := [ 0 , 0 , 0 ] ;
15107: LD_ADDR_VAR 0 9
15111: PUSH
15112: LD_INT 0
15114: PUSH
15115: LD_INT 0
15117: PUSH
15118: LD_INT 0
15120: PUSH
15121: EMPTY
15122: LIST
15123: LIST
15124: LIST
15125: ST_TO_ADDR
// bpoints := 1 ;
15126: LD_ADDR_VAR 0 10
15130: PUSH
15131: LD_INT 1
15133: ST_TO_ADDR
// case GetType ( i ) of unit_human :
15134: LD_VAR 0 6
15138: PPUSH
15139: CALL_OW 247
15143: PUSH
15144: LD_INT 1
15146: DOUBLE
15147: EQUAL
15148: IFTRUE 15152
15150: GO 15730
15152: POP
// begin if GetClass ( i ) = 1 then
15153: LD_VAR 0 6
15157: PPUSH
15158: CALL_OW 257
15162: PUSH
15163: LD_INT 1
15165: EQUAL
15166: IFFALSE 15187
// points := [ 10 , 5 , 3 ] ;
15168: LD_ADDR_VAR 0 9
15172: PUSH
15173: LD_INT 10
15175: PUSH
15176: LD_INT 5
15178: PUSH
15179: LD_INT 3
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: LIST
15186: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
15187: LD_VAR 0 6
15191: PPUSH
15192: CALL_OW 257
15196: PUSH
15197: LD_INT 2
15199: PUSH
15200: LD_INT 3
15202: PUSH
15203: LD_INT 4
15205: PUSH
15206: EMPTY
15207: LIST
15208: LIST
15209: LIST
15210: IN
15211: IFFALSE 15232
// points := [ 3 , 2 , 1 ] ;
15213: LD_ADDR_VAR 0 9
15217: PUSH
15218: LD_INT 3
15220: PUSH
15221: LD_INT 2
15223: PUSH
15224: LD_INT 1
15226: PUSH
15227: EMPTY
15228: LIST
15229: LIST
15230: LIST
15231: ST_TO_ADDR
// if GetClass ( i ) = 5 then
15232: LD_VAR 0 6
15236: PPUSH
15237: CALL_OW 257
15241: PUSH
15242: LD_INT 5
15244: EQUAL
15245: IFFALSE 15266
// points := [ 130 , 5 , 2 ] ;
15247: LD_ADDR_VAR 0 9
15251: PUSH
15252: LD_INT 130
15254: PUSH
15255: LD_INT 5
15257: PUSH
15258: LD_INT 2
15260: PUSH
15261: EMPTY
15262: LIST
15263: LIST
15264: LIST
15265: ST_TO_ADDR
// if GetClass ( i ) = 8 then
15266: LD_VAR 0 6
15270: PPUSH
15271: CALL_OW 257
15275: PUSH
15276: LD_INT 8
15278: EQUAL
15279: IFFALSE 15300
// points := [ 35 , 35 , 30 ] ;
15281: LD_ADDR_VAR 0 9
15285: PUSH
15286: LD_INT 35
15288: PUSH
15289: LD_INT 35
15291: PUSH
15292: LD_INT 30
15294: PUSH
15295: EMPTY
15296: LIST
15297: LIST
15298: LIST
15299: ST_TO_ADDR
// if GetClass ( i ) = 9 then
15300: LD_VAR 0 6
15304: PPUSH
15305: CALL_OW 257
15309: PUSH
15310: LD_INT 9
15312: EQUAL
15313: IFFALSE 15334
// points := [ 20 , 55 , 40 ] ;
15315: LD_ADDR_VAR 0 9
15319: PUSH
15320: LD_INT 20
15322: PUSH
15323: LD_INT 55
15325: PUSH
15326: LD_INT 40
15328: PUSH
15329: EMPTY
15330: LIST
15331: LIST
15332: LIST
15333: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
15334: LD_VAR 0 6
15338: PPUSH
15339: CALL_OW 257
15343: PUSH
15344: LD_INT 12
15346: PUSH
15347: LD_INT 16
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: IN
15354: IFFALSE 15375
// points := [ 5 , 3 , 2 ] ;
15356: LD_ADDR_VAR 0 9
15360: PUSH
15361: LD_INT 5
15363: PUSH
15364: LD_INT 3
15366: PUSH
15367: LD_INT 2
15369: PUSH
15370: EMPTY
15371: LIST
15372: LIST
15373: LIST
15374: ST_TO_ADDR
// if GetClass ( i ) = 17 then
15375: LD_VAR 0 6
15379: PPUSH
15380: CALL_OW 257
15384: PUSH
15385: LD_INT 17
15387: EQUAL
15388: IFFALSE 15409
// points := [ 100 , 50 , 75 ] ;
15390: LD_ADDR_VAR 0 9
15394: PUSH
15395: LD_INT 100
15397: PUSH
15398: LD_INT 50
15400: PUSH
15401: LD_INT 75
15403: PUSH
15404: EMPTY
15405: LIST
15406: LIST
15407: LIST
15408: ST_TO_ADDR
// if GetClass ( i ) = 15 then
15409: LD_VAR 0 6
15413: PPUSH
15414: CALL_OW 257
15418: PUSH
15419: LD_INT 15
15421: EQUAL
15422: IFFALSE 15443
// points := [ 10 , 5 , 3 ] ;
15424: LD_ADDR_VAR 0 9
15428: PUSH
15429: LD_INT 10
15431: PUSH
15432: LD_INT 5
15434: PUSH
15435: LD_INT 3
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: LIST
15442: ST_TO_ADDR
// if GetClass ( i ) = 14 then
15443: LD_VAR 0 6
15447: PPUSH
15448: CALL_OW 257
15452: PUSH
15453: LD_INT 14
15455: EQUAL
15456: IFFALSE 15477
// points := [ 10 , 0 , 0 ] ;
15458: LD_ADDR_VAR 0 9
15462: PUSH
15463: LD_INT 10
15465: PUSH
15466: LD_INT 0
15468: PUSH
15469: LD_INT 0
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: LIST
15476: ST_TO_ADDR
// if GetClass ( i ) = 11 then
15477: LD_VAR 0 6
15481: PPUSH
15482: CALL_OW 257
15486: PUSH
15487: LD_INT 11
15489: EQUAL
15490: IFFALSE 15511
// points := [ 30 , 10 , 5 ] ;
15492: LD_ADDR_VAR 0 9
15496: PUSH
15497: LD_INT 30
15499: PUSH
15500: LD_INT 10
15502: PUSH
15503: LD_INT 5
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: LIST
15510: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
15511: LD_VAR 0 1
15515: PPUSH
15516: LD_INT 5
15518: PPUSH
15519: CALL_OW 321
15523: PUSH
15524: LD_INT 2
15526: EQUAL
15527: IFFALSE 15544
// bpoints := bpoints * 1.8 ;
15529: LD_ADDR_VAR 0 10
15533: PUSH
15534: LD_VAR 0 10
15538: PUSH
15539: LD_REAL  1.80000000000000E+0000
15542: MUL
15543: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
15544: LD_VAR 0 6
15548: PPUSH
15549: CALL_OW 257
15553: PUSH
15554: LD_INT 1
15556: PUSH
15557: LD_INT 2
15559: PUSH
15560: LD_INT 3
15562: PUSH
15563: LD_INT 4
15565: PUSH
15566: EMPTY
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: IN
15572: PUSH
15573: LD_VAR 0 1
15577: PPUSH
15578: LD_INT 51
15580: PPUSH
15581: CALL_OW 321
15585: PUSH
15586: LD_INT 2
15588: EQUAL
15589: AND
15590: IFFALSE 15607
// bpoints := bpoints * 1.2 ;
15592: LD_ADDR_VAR 0 10
15596: PUSH
15597: LD_VAR 0 10
15601: PUSH
15602: LD_REAL  1.20000000000000E+0000
15605: MUL
15606: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
15607: LD_VAR 0 6
15611: PPUSH
15612: CALL_OW 257
15616: PUSH
15617: LD_INT 5
15619: PUSH
15620: LD_INT 7
15622: PUSH
15623: LD_INT 9
15625: PUSH
15626: EMPTY
15627: LIST
15628: LIST
15629: LIST
15630: IN
15631: PUSH
15632: LD_VAR 0 1
15636: PPUSH
15637: LD_INT 52
15639: PPUSH
15640: CALL_OW 321
15644: PUSH
15645: LD_INT 2
15647: EQUAL
15648: AND
15649: IFFALSE 15666
// bpoints := bpoints * 1.5 ;
15651: LD_ADDR_VAR 0 10
15655: PUSH
15656: LD_VAR 0 10
15660: PUSH
15661: LD_REAL  1.50000000000000E+0000
15664: MUL
15665: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
15666: LD_VAR 0 1
15670: PPUSH
15671: LD_INT 66
15673: PPUSH
15674: CALL_OW 321
15678: PUSH
15679: LD_INT 2
15681: EQUAL
15682: IFFALSE 15699
// bpoints := bpoints * 1.1 ;
15684: LD_ADDR_VAR 0 10
15688: PUSH
15689: LD_VAR 0 10
15693: PUSH
15694: LD_REAL  1.10000000000000E+0000
15697: MUL
15698: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
15699: LD_ADDR_VAR 0 10
15703: PUSH
15704: LD_VAR 0 10
15708: PUSH
15709: LD_VAR 0 6
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: CALL_OW 259
15721: PUSH
15722: LD_REAL  1.15000000000000E+0000
15725: MUL
15726: MUL
15727: ST_TO_ADDR
// end ; unit_vehicle :
15728: GO 16558
15730: LD_INT 2
15732: DOUBLE
15733: EQUAL
15734: IFTRUE 15738
15736: GO 16546
15738: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
15739: LD_VAR 0 6
15743: PPUSH
15744: CALL_OW 264
15748: PUSH
15749: LD_INT 2
15751: PUSH
15752: LD_INT 42
15754: PUSH
15755: LD_INT 24
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: LIST
15762: IN
15763: IFFALSE 15784
// points := [ 25 , 5 , 3 ] ;
15765: LD_ADDR_VAR 0 9
15769: PUSH
15770: LD_INT 25
15772: PUSH
15773: LD_INT 5
15775: PUSH
15776: LD_INT 3
15778: PUSH
15779: EMPTY
15780: LIST
15781: LIST
15782: LIST
15783: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
15784: LD_VAR 0 6
15788: PPUSH
15789: CALL_OW 264
15793: PUSH
15794: LD_INT 4
15796: PUSH
15797: LD_INT 43
15799: PUSH
15800: LD_INT 25
15802: PUSH
15803: EMPTY
15804: LIST
15805: LIST
15806: LIST
15807: IN
15808: IFFALSE 15829
// points := [ 40 , 15 , 5 ] ;
15810: LD_ADDR_VAR 0 9
15814: PUSH
15815: LD_INT 40
15817: PUSH
15818: LD_INT 15
15820: PUSH
15821: LD_INT 5
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: LIST
15828: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
15829: LD_VAR 0 6
15833: PPUSH
15834: CALL_OW 264
15838: PUSH
15839: LD_INT 3
15841: PUSH
15842: LD_INT 23
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: IN
15849: IFFALSE 15870
// points := [ 7 , 25 , 8 ] ;
15851: LD_ADDR_VAR 0 9
15855: PUSH
15856: LD_INT 7
15858: PUSH
15859: LD_INT 25
15861: PUSH
15862: LD_INT 8
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: LIST
15869: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
15870: LD_VAR 0 6
15874: PPUSH
15875: CALL_OW 264
15879: PUSH
15880: LD_INT 5
15882: PUSH
15883: LD_INT 27
15885: PUSH
15886: LD_INT 44
15888: PUSH
15889: EMPTY
15890: LIST
15891: LIST
15892: LIST
15893: IN
15894: IFFALSE 15915
// points := [ 14 , 50 , 16 ] ;
15896: LD_ADDR_VAR 0 9
15900: PUSH
15901: LD_INT 14
15903: PUSH
15904: LD_INT 50
15906: PUSH
15907: LD_INT 16
15909: PUSH
15910: EMPTY
15911: LIST
15912: LIST
15913: LIST
15914: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
15915: LD_VAR 0 6
15919: PPUSH
15920: CALL_OW 264
15924: PUSH
15925: LD_INT 6
15927: PUSH
15928: LD_INT 46
15930: PUSH
15931: EMPTY
15932: LIST
15933: LIST
15934: IN
15935: IFFALSE 15956
// points := [ 32 , 120 , 70 ] ;
15937: LD_ADDR_VAR 0 9
15941: PUSH
15942: LD_INT 32
15944: PUSH
15945: LD_INT 120
15947: PUSH
15948: LD_INT 70
15950: PUSH
15951: EMPTY
15952: LIST
15953: LIST
15954: LIST
15955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
15956: LD_VAR 0 6
15960: PPUSH
15961: CALL_OW 264
15965: PUSH
15966: LD_INT 7
15968: PUSH
15969: LD_INT 28
15971: PUSH
15972: LD_INT 45
15974: PUSH
15975: LD_EXP 72
15979: PUSH
15980: EMPTY
15981: LIST
15982: LIST
15983: LIST
15984: LIST
15985: IN
15986: IFFALSE 16007
// points := [ 35 , 20 , 45 ] ;
15988: LD_ADDR_VAR 0 9
15992: PUSH
15993: LD_INT 35
15995: PUSH
15996: LD_INT 20
15998: PUSH
15999: LD_INT 45
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: LIST
16006: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
16007: LD_VAR 0 6
16011: PPUSH
16012: CALL_OW 264
16016: PUSH
16017: LD_INT 47
16019: PUSH
16020: EMPTY
16021: LIST
16022: IN
16023: IFFALSE 16044
// points := [ 67 , 45 , 75 ] ;
16025: LD_ADDR_VAR 0 9
16029: PUSH
16030: LD_INT 67
16032: PUSH
16033: LD_INT 45
16035: PUSH
16036: LD_INT 75
16038: PUSH
16039: EMPTY
16040: LIST
16041: LIST
16042: LIST
16043: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
16044: LD_VAR 0 6
16048: PPUSH
16049: CALL_OW 264
16053: PUSH
16054: LD_INT 26
16056: PUSH
16057: EMPTY
16058: LIST
16059: IN
16060: IFFALSE 16081
// points := [ 120 , 30 , 80 ] ;
16062: LD_ADDR_VAR 0 9
16066: PUSH
16067: LD_INT 120
16069: PUSH
16070: LD_INT 30
16072: PUSH
16073: LD_INT 80
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: LIST
16080: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
16081: LD_VAR 0 6
16085: PPUSH
16086: CALL_OW 264
16090: PUSH
16091: LD_INT 22
16093: PUSH
16094: EMPTY
16095: LIST
16096: IN
16097: IFFALSE 16118
// points := [ 40 , 1 , 1 ] ;
16099: LD_ADDR_VAR 0 9
16103: PUSH
16104: LD_INT 40
16106: PUSH
16107: LD_INT 1
16109: PUSH
16110: LD_INT 1
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: LIST
16117: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
16118: LD_VAR 0 6
16122: PPUSH
16123: CALL_OW 264
16127: PUSH
16128: LD_INT 29
16130: PUSH
16131: EMPTY
16132: LIST
16133: IN
16134: IFFALSE 16155
// points := [ 70 , 200 , 400 ] ;
16136: LD_ADDR_VAR 0 9
16140: PUSH
16141: LD_INT 70
16143: PUSH
16144: LD_INT 200
16146: PUSH
16147: LD_INT 400
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: LIST
16154: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
16155: LD_VAR 0 6
16159: PPUSH
16160: CALL_OW 264
16164: PUSH
16165: LD_INT 14
16167: PUSH
16168: LD_INT 53
16170: PUSH
16171: EMPTY
16172: LIST
16173: LIST
16174: IN
16175: IFFALSE 16196
// points := [ 40 , 10 , 20 ] ;
16177: LD_ADDR_VAR 0 9
16181: PUSH
16182: LD_INT 40
16184: PUSH
16185: LD_INT 10
16187: PUSH
16188: LD_INT 20
16190: PUSH
16191: EMPTY
16192: LIST
16193: LIST
16194: LIST
16195: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
16196: LD_VAR 0 6
16200: PPUSH
16201: CALL_OW 264
16205: PUSH
16206: LD_INT 9
16208: PUSH
16209: EMPTY
16210: LIST
16211: IN
16212: IFFALSE 16233
// points := [ 5 , 70 , 20 ] ;
16214: LD_ADDR_VAR 0 9
16218: PUSH
16219: LD_INT 5
16221: PUSH
16222: LD_INT 70
16224: PUSH
16225: LD_INT 20
16227: PUSH
16228: EMPTY
16229: LIST
16230: LIST
16231: LIST
16232: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
16233: LD_VAR 0 6
16237: PPUSH
16238: CALL_OW 264
16242: PUSH
16243: LD_INT 10
16245: PUSH
16246: EMPTY
16247: LIST
16248: IN
16249: IFFALSE 16270
// points := [ 35 , 110 , 70 ] ;
16251: LD_ADDR_VAR 0 9
16255: PUSH
16256: LD_INT 35
16258: PUSH
16259: LD_INT 110
16261: PUSH
16262: LD_INT 70
16264: PUSH
16265: EMPTY
16266: LIST
16267: LIST
16268: LIST
16269: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
16270: LD_VAR 0 6
16274: PPUSH
16275: CALL_OW 265
16279: PUSH
16280: LD_INT 25
16282: EQUAL
16283: IFFALSE 16304
// points := [ 80 , 65 , 100 ] ;
16285: LD_ADDR_VAR 0 9
16289: PUSH
16290: LD_INT 80
16292: PUSH
16293: LD_INT 65
16295: PUSH
16296: LD_INT 100
16298: PUSH
16299: EMPTY
16300: LIST
16301: LIST
16302: LIST
16303: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
16304: LD_VAR 0 6
16308: PPUSH
16309: CALL_OW 263
16313: PUSH
16314: LD_INT 1
16316: EQUAL
16317: IFFALSE 16352
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
16319: LD_ADDR_VAR 0 10
16323: PUSH
16324: LD_VAR 0 10
16328: PUSH
16329: LD_VAR 0 6
16333: PPUSH
16334: CALL_OW 311
16338: PPUSH
16339: LD_INT 3
16341: PPUSH
16342: CALL_OW 259
16346: PUSH
16347: LD_INT 4
16349: MUL
16350: MUL
16351: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
16352: LD_VAR 0 6
16356: PPUSH
16357: CALL_OW 263
16361: PUSH
16362: LD_INT 2
16364: EQUAL
16365: IFFALSE 16416
// begin j := IsControledBy ( i ) ;
16367: LD_ADDR_VAR 0 7
16371: PUSH
16372: LD_VAR 0 6
16376: PPUSH
16377: CALL_OW 312
16381: ST_TO_ADDR
// if j then
16382: LD_VAR 0 7
16386: IFFALSE 16416
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
16388: LD_ADDR_VAR 0 10
16392: PUSH
16393: LD_VAR 0 10
16397: PUSH
16398: LD_VAR 0 7
16402: PPUSH
16403: LD_INT 3
16405: PPUSH
16406: CALL_OW 259
16410: PUSH
16411: LD_INT 3
16413: MUL
16414: MUL
16415: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
16416: LD_VAR 0 6
16420: PPUSH
16421: CALL_OW 264
16425: PUSH
16426: LD_INT 5
16428: PUSH
16429: LD_INT 6
16431: PUSH
16432: LD_INT 46
16434: PUSH
16435: LD_INT 44
16437: PUSH
16438: LD_INT 47
16440: PUSH
16441: LD_INT 45
16443: PUSH
16444: LD_INT 28
16446: PUSH
16447: LD_INT 7
16449: PUSH
16450: LD_INT 27
16452: PUSH
16453: LD_INT 29
16455: PUSH
16456: EMPTY
16457: LIST
16458: LIST
16459: LIST
16460: LIST
16461: LIST
16462: LIST
16463: LIST
16464: LIST
16465: LIST
16466: LIST
16467: IN
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: LD_INT 52
16476: PPUSH
16477: CALL_OW 321
16481: PUSH
16482: LD_INT 2
16484: EQUAL
16485: AND
16486: IFFALSE 16503
// bpoints := bpoints * 1.2 ;
16488: LD_ADDR_VAR 0 10
16492: PUSH
16493: LD_VAR 0 10
16497: PUSH
16498: LD_REAL  1.20000000000000E+0000
16501: MUL
16502: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
16503: LD_VAR 0 6
16507: PPUSH
16508: CALL_OW 264
16512: PUSH
16513: LD_INT 6
16515: PUSH
16516: LD_INT 46
16518: PUSH
16519: LD_INT 47
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: LIST
16526: IN
16527: IFFALSE 16544
// bpoints := bpoints * 1.2 ;
16529: LD_ADDR_VAR 0 10
16533: PUSH
16534: LD_VAR 0 10
16538: PUSH
16539: LD_REAL  1.20000000000000E+0000
16542: MUL
16543: ST_TO_ADDR
// end ; unit_building :
16544: GO 16558
16546: LD_INT 3
16548: DOUBLE
16549: EQUAL
16550: IFTRUE 16554
16552: GO 16557
16554: POP
// ; end ;
16555: GO 16558
16557: POP
// for j = 1 to 3 do
16558: LD_ADDR_VAR 0 7
16562: PUSH
16563: DOUBLE
16564: LD_INT 1
16566: DEC
16567: ST_TO_ADDR
16568: LD_INT 3
16570: PUSH
16571: FOR_TO
16572: IFFALSE 16625
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
16574: LD_ADDR_VAR 0 5
16578: PUSH
16579: LD_VAR 0 5
16583: PPUSH
16584: LD_VAR 0 7
16588: PPUSH
16589: LD_VAR 0 5
16593: PUSH
16594: LD_VAR 0 7
16598: ARRAY
16599: PUSH
16600: LD_VAR 0 9
16604: PUSH
16605: LD_VAR 0 7
16609: ARRAY
16610: PUSH
16611: LD_VAR 0 10
16615: MUL
16616: PLUS
16617: PPUSH
16618: CALL_OW 1
16622: ST_TO_ADDR
16623: GO 16571
16625: POP
16626: POP
// end ;
16627: GO 15104
16629: POP
16630: POP
// result := Replace ( result , 4 , tmp ) ;
16631: LD_ADDR_VAR 0 5
16635: PUSH
16636: LD_VAR 0 5
16640: PPUSH
16641: LD_INT 4
16643: PPUSH
16644: LD_VAR 0 8
16648: PPUSH
16649: CALL_OW 1
16653: ST_TO_ADDR
// end ;
16654: LD_VAR 0 5
16658: RET
// export function DangerAtRange ( unit , range ) ; begin
16659: LD_INT 0
16661: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
16662: LD_ADDR_VAR 0 3
16666: PUSH
16667: LD_VAR 0 1
16671: PPUSH
16672: CALL_OW 255
16676: PPUSH
16677: LD_VAR 0 1
16681: PPUSH
16682: CALL_OW 250
16686: PPUSH
16687: LD_VAR 0 1
16691: PPUSH
16692: CALL_OW 251
16696: PPUSH
16697: LD_VAR 0 2
16701: PPUSH
16702: CALL 14956 0 4
16706: ST_TO_ADDR
// end ;
16707: LD_VAR 0 3
16711: RET
// export function DangerInArea ( side , area ) ; begin
16712: LD_INT 0
16714: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
16715: LD_ADDR_VAR 0 3
16719: PUSH
16720: LD_VAR 0 2
16724: PPUSH
16725: LD_INT 81
16727: PUSH
16728: LD_VAR 0 1
16732: PUSH
16733: EMPTY
16734: LIST
16735: LIST
16736: PPUSH
16737: CALL_OW 70
16741: ST_TO_ADDR
// end ;
16742: LD_VAR 0 3
16746: RET
// export function IsExtension ( b ) ; begin
16747: LD_INT 0
16749: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
16750: LD_ADDR_VAR 0 2
16754: PUSH
16755: LD_VAR 0 1
16759: PUSH
16760: LD_INT 23
16762: PUSH
16763: LD_INT 20
16765: PUSH
16766: LD_INT 22
16768: PUSH
16769: LD_INT 17
16771: PUSH
16772: LD_INT 24
16774: PUSH
16775: LD_INT 21
16777: PUSH
16778: LD_INT 19
16780: PUSH
16781: LD_INT 16
16783: PUSH
16784: LD_INT 25
16786: PUSH
16787: LD_INT 18
16789: PUSH
16790: EMPTY
16791: LIST
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: LIST
16797: LIST
16798: LIST
16799: LIST
16800: LIST
16801: IN
16802: ST_TO_ADDR
// end ;
16803: LD_VAR 0 2
16807: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
16808: LD_INT 0
16810: PPUSH
16811: PPUSH
16812: PPUSH
// result := [ ] ;
16813: LD_ADDR_VAR 0 4
16817: PUSH
16818: EMPTY
16819: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
16820: LD_ADDR_VAR 0 5
16824: PUSH
16825: LD_VAR 0 2
16829: PPUSH
16830: LD_INT 21
16832: PUSH
16833: LD_INT 3
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PPUSH
16840: CALL_OW 70
16844: ST_TO_ADDR
// if not tmp then
16845: LD_VAR 0 5
16849: NOT
16850: IFFALSE 16854
// exit ;
16852: GO 16918
// if checkLink then
16854: LD_VAR 0 3
16858: IFFALSE 16908
// begin for i in tmp do
16860: LD_ADDR_VAR 0 6
16864: PUSH
16865: LD_VAR 0 5
16869: PUSH
16870: FOR_IN
16871: IFFALSE 16906
// if GetBase ( i ) <> base then
16873: LD_VAR 0 6
16877: PPUSH
16878: CALL_OW 274
16882: PUSH
16883: LD_VAR 0 1
16887: NONEQUAL
16888: IFFALSE 16904
// ComLinkToBase ( base , i ) ;
16890: LD_VAR 0 1
16894: PPUSH
16895: LD_VAR 0 6
16899: PPUSH
16900: CALL_OW 169
16904: GO 16870
16906: POP
16907: POP
// end ; result := tmp ;
16908: LD_ADDR_VAR 0 4
16912: PUSH
16913: LD_VAR 0 5
16917: ST_TO_ADDR
// end ;
16918: LD_VAR 0 4
16922: RET
// export function ComComplete ( units , b ) ; var i ; begin
16923: LD_INT 0
16925: PPUSH
16926: PPUSH
// if not units then
16927: LD_VAR 0 1
16931: NOT
16932: IFFALSE 16936
// exit ;
16934: GO 17026
// for i in units do
16936: LD_ADDR_VAR 0 4
16940: PUSH
16941: LD_VAR 0 1
16945: PUSH
16946: FOR_IN
16947: IFFALSE 17024
// if BuildingStatus ( b ) = bs_build then
16949: LD_VAR 0 2
16953: PPUSH
16954: CALL_OW 461
16958: PUSH
16959: LD_INT 1
16961: EQUAL
16962: IFFALSE 17022
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
16964: LD_VAR 0 4
16968: PPUSH
16969: LD_STRING h
16971: PUSH
16972: LD_VAR 0 2
16976: PPUSH
16977: CALL_OW 250
16981: PUSH
16982: LD_VAR 0 2
16986: PPUSH
16987: CALL_OW 251
16991: PUSH
16992: LD_VAR 0 2
16996: PUSH
16997: LD_INT 0
16999: PUSH
17000: LD_INT 0
17002: PUSH
17003: LD_INT 0
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: PUSH
17015: EMPTY
17016: LIST
17017: PPUSH
17018: CALL_OW 446
17022: GO 16946
17024: POP
17025: POP
// end ;
17026: LD_VAR 0 3
17030: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
17031: LD_INT 0
17033: PPUSH
17034: PPUSH
17035: PPUSH
17036: PPUSH
17037: PPUSH
17038: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
17039: LD_VAR 0 1
17043: NOT
17044: PUSH
17045: LD_VAR 0 1
17049: PPUSH
17050: CALL_OW 263
17054: PUSH
17055: LD_INT 2
17057: EQUAL
17058: NOT
17059: OR
17060: IFFALSE 17064
// exit ;
17062: GO 17380
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
17064: LD_ADDR_VAR 0 6
17068: PUSH
17069: LD_INT 22
17071: PUSH
17072: LD_VAR 0 1
17076: PPUSH
17077: CALL_OW 255
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: LD_INT 2
17088: PUSH
17089: LD_INT 30
17091: PUSH
17092: LD_INT 36
17094: PUSH
17095: EMPTY
17096: LIST
17097: LIST
17098: PUSH
17099: LD_INT 34
17101: PUSH
17102: LD_INT 31
17104: PUSH
17105: EMPTY
17106: LIST
17107: LIST
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: LIST
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: PPUSH
17118: CALL_OW 69
17122: ST_TO_ADDR
// if not tmp then
17123: LD_VAR 0 6
17127: NOT
17128: IFFALSE 17132
// exit ;
17130: GO 17380
// result := [ ] ;
17132: LD_ADDR_VAR 0 2
17136: PUSH
17137: EMPTY
17138: ST_TO_ADDR
// for i in tmp do
17139: LD_ADDR_VAR 0 3
17143: PUSH
17144: LD_VAR 0 6
17148: PUSH
17149: FOR_IN
17150: IFFALSE 17221
// begin t := UnitsInside ( i ) ;
17152: LD_ADDR_VAR 0 4
17156: PUSH
17157: LD_VAR 0 3
17161: PPUSH
17162: CALL_OW 313
17166: ST_TO_ADDR
// if t then
17167: LD_VAR 0 4
17171: IFFALSE 17219
// for j in t do
17173: LD_ADDR_VAR 0 7
17177: PUSH
17178: LD_VAR 0 4
17182: PUSH
17183: FOR_IN
17184: IFFALSE 17217
// result := Insert ( result , result + 1 , j ) ;
17186: LD_ADDR_VAR 0 2
17190: PUSH
17191: LD_VAR 0 2
17195: PPUSH
17196: LD_VAR 0 2
17200: PUSH
17201: LD_INT 1
17203: PLUS
17204: PPUSH
17205: LD_VAR 0 7
17209: PPUSH
17210: CALL_OW 2
17214: ST_TO_ADDR
17215: GO 17183
17217: POP
17218: POP
// end ;
17219: GO 17149
17221: POP
17222: POP
// if not result then
17223: LD_VAR 0 2
17227: NOT
17228: IFFALSE 17232
// exit ;
17230: GO 17380
// mech := result [ 1 ] ;
17232: LD_ADDR_VAR 0 5
17236: PUSH
17237: LD_VAR 0 2
17241: PUSH
17242: LD_INT 1
17244: ARRAY
17245: ST_TO_ADDR
// if result > 1 then
17246: LD_VAR 0 2
17250: PUSH
17251: LD_INT 1
17253: GREATER
17254: IFFALSE 17366
// for i = 2 to result do
17256: LD_ADDR_VAR 0 3
17260: PUSH
17261: DOUBLE
17262: LD_INT 2
17264: DEC
17265: ST_TO_ADDR
17266: LD_VAR 0 2
17270: PUSH
17271: FOR_TO
17272: IFFALSE 17364
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
17274: LD_ADDR_VAR 0 4
17278: PUSH
17279: LD_VAR 0 2
17283: PUSH
17284: LD_VAR 0 3
17288: ARRAY
17289: PPUSH
17290: LD_INT 3
17292: PPUSH
17293: CALL_OW 259
17297: PUSH
17298: LD_VAR 0 2
17302: PUSH
17303: LD_VAR 0 3
17307: ARRAY
17308: PPUSH
17309: CALL_OW 432
17313: MINUS
17314: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
17315: LD_VAR 0 4
17319: PUSH
17320: LD_VAR 0 5
17324: PPUSH
17325: LD_INT 3
17327: PPUSH
17328: CALL_OW 259
17332: PUSH
17333: LD_VAR 0 5
17337: PPUSH
17338: CALL_OW 432
17342: MINUS
17343: GREATEREQUAL
17344: IFFALSE 17362
// mech := result [ i ] ;
17346: LD_ADDR_VAR 0 5
17350: PUSH
17351: LD_VAR 0 2
17355: PUSH
17356: LD_VAR 0 3
17360: ARRAY
17361: ST_TO_ADDR
// end ;
17362: GO 17271
17364: POP
17365: POP
// ComLinkTo ( vehicle , mech ) ;
17366: LD_VAR 0 1
17370: PPUSH
17371: LD_VAR 0 5
17375: PPUSH
17376: CALL_OW 135
// end ;
17380: LD_VAR 0 2
17384: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
17385: LD_INT 0
17387: PPUSH
17388: PPUSH
17389: PPUSH
17390: PPUSH
17391: PPUSH
17392: PPUSH
17393: PPUSH
17394: PPUSH
17395: PPUSH
17396: PPUSH
17397: PPUSH
17398: PPUSH
17399: PPUSH
// result := [ ] ;
17400: LD_ADDR_VAR 0 7
17404: PUSH
17405: EMPTY
17406: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
17407: LD_VAR 0 1
17411: PPUSH
17412: CALL_OW 266
17416: PUSH
17417: LD_INT 0
17419: PUSH
17420: LD_INT 1
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: IN
17427: NOT
17428: IFFALSE 17432
// exit ;
17430: GO 19066
// if name then
17432: LD_VAR 0 3
17436: IFFALSE 17452
// SetBName ( base_dep , name ) ;
17438: LD_VAR 0 1
17442: PPUSH
17443: LD_VAR 0 3
17447: PPUSH
17448: CALL_OW 500
// base := GetBase ( base_dep ) ;
17452: LD_ADDR_VAR 0 15
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 274
17466: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
17467: LD_ADDR_VAR 0 16
17471: PUSH
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL_OW 255
17481: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
17482: LD_ADDR_VAR 0 17
17486: PUSH
17487: LD_VAR 0 1
17491: PPUSH
17492: CALL_OW 248
17496: ST_TO_ADDR
// if sources then
17497: LD_VAR 0 5
17501: IFFALSE 17548
// for i = 1 to 3 do
17503: LD_ADDR_VAR 0 8
17507: PUSH
17508: DOUBLE
17509: LD_INT 1
17511: DEC
17512: ST_TO_ADDR
17513: LD_INT 3
17515: PUSH
17516: FOR_TO
17517: IFFALSE 17546
// AddResourceType ( base , i , sources [ i ] ) ;
17519: LD_VAR 0 15
17523: PPUSH
17524: LD_VAR 0 8
17528: PPUSH
17529: LD_VAR 0 5
17533: PUSH
17534: LD_VAR 0 8
17538: ARRAY
17539: PPUSH
17540: CALL_OW 276
17544: GO 17516
17546: POP
17547: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
17548: LD_ADDR_VAR 0 18
17552: PUSH
17553: LD_VAR 0 15
17557: PPUSH
17558: LD_VAR 0 2
17562: PPUSH
17563: LD_INT 1
17565: PPUSH
17566: CALL 16808 0 3
17570: ST_TO_ADDR
// InitHc ;
17571: CALL_OW 19
// InitUc ;
17575: CALL_OW 18
// uc_side := side ;
17579: LD_ADDR_OWVAR 20
17583: PUSH
17584: LD_VAR 0 16
17588: ST_TO_ADDR
// uc_nation := nation ;
17589: LD_ADDR_OWVAR 21
17593: PUSH
17594: LD_VAR 0 17
17598: ST_TO_ADDR
// if buildings then
17599: LD_VAR 0 18
17603: IFFALSE 18925
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
17605: LD_ADDR_VAR 0 19
17609: PUSH
17610: LD_VAR 0 18
17614: PPUSH
17615: LD_INT 2
17617: PUSH
17618: LD_INT 30
17620: PUSH
17621: LD_INT 29
17623: PUSH
17624: EMPTY
17625: LIST
17626: LIST
17627: PUSH
17628: LD_INT 30
17630: PUSH
17631: LD_INT 30
17633: PUSH
17634: EMPTY
17635: LIST
17636: LIST
17637: PUSH
17638: EMPTY
17639: LIST
17640: LIST
17641: LIST
17642: PPUSH
17643: CALL_OW 72
17647: ST_TO_ADDR
// if tmp then
17648: LD_VAR 0 19
17652: IFFALSE 17700
// for i in tmp do
17654: LD_ADDR_VAR 0 8
17658: PUSH
17659: LD_VAR 0 19
17663: PUSH
17664: FOR_IN
17665: IFFALSE 17698
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
17667: LD_VAR 0 8
17671: PPUSH
17672: CALL_OW 250
17676: PPUSH
17677: LD_VAR 0 8
17681: PPUSH
17682: CALL_OW 251
17686: PPUSH
17687: LD_VAR 0 16
17691: PPUSH
17692: CALL_OW 441
17696: GO 17664
17698: POP
17699: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
17700: LD_VAR 0 18
17704: PPUSH
17705: LD_INT 2
17707: PUSH
17708: LD_INT 30
17710: PUSH
17711: LD_INT 32
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: PUSH
17718: LD_INT 30
17720: PUSH
17721: LD_INT 33
17723: PUSH
17724: EMPTY
17725: LIST
17726: LIST
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: LIST
17732: PPUSH
17733: CALL_OW 72
17737: IFFALSE 17825
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
17739: LD_ADDR_VAR 0 8
17743: PUSH
17744: LD_VAR 0 18
17748: PPUSH
17749: LD_INT 2
17751: PUSH
17752: LD_INT 30
17754: PUSH
17755: LD_INT 32
17757: PUSH
17758: EMPTY
17759: LIST
17760: LIST
17761: PUSH
17762: LD_INT 30
17764: PUSH
17765: LD_INT 33
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: PUSH
17772: EMPTY
17773: LIST
17774: LIST
17775: LIST
17776: PPUSH
17777: CALL_OW 72
17781: PUSH
17782: FOR_IN
17783: IFFALSE 17823
// begin if not GetBWeapon ( i ) then
17785: LD_VAR 0 8
17789: PPUSH
17790: CALL_OW 269
17794: NOT
17795: IFFALSE 17821
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
17797: LD_VAR 0 8
17801: PPUSH
17802: LD_VAR 0 8
17806: PPUSH
17807: LD_VAR 0 2
17811: PPUSH
17812: CALL 19071 0 2
17816: PPUSH
17817: CALL_OW 431
// end ;
17821: GO 17782
17823: POP
17824: POP
// end ; for i = 1 to personel do
17825: LD_ADDR_VAR 0 8
17829: PUSH
17830: DOUBLE
17831: LD_INT 1
17833: DEC
17834: ST_TO_ADDR
17835: LD_VAR 0 6
17839: PUSH
17840: FOR_TO
17841: IFFALSE 18905
// begin if i > 4 then
17843: LD_VAR 0 8
17847: PUSH
17848: LD_INT 4
17850: GREATER
17851: IFFALSE 17855
// break ;
17853: GO 18905
// case i of 1 :
17855: LD_VAR 0 8
17859: PUSH
17860: LD_INT 1
17862: DOUBLE
17863: EQUAL
17864: IFTRUE 17868
17866: GO 17948
17868: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
17869: LD_ADDR_VAR 0 12
17873: PUSH
17874: LD_VAR 0 18
17878: PPUSH
17879: LD_INT 22
17881: PUSH
17882: LD_VAR 0 16
17886: PUSH
17887: EMPTY
17888: LIST
17889: LIST
17890: PUSH
17891: LD_INT 58
17893: PUSH
17894: EMPTY
17895: LIST
17896: PUSH
17897: LD_INT 2
17899: PUSH
17900: LD_INT 30
17902: PUSH
17903: LD_INT 32
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: PUSH
17910: LD_INT 30
17912: PUSH
17913: LD_INT 4
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: PUSH
17920: LD_INT 30
17922: PUSH
17923: LD_INT 5
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: PUSH
17930: EMPTY
17931: LIST
17932: LIST
17933: LIST
17934: LIST
17935: PUSH
17936: EMPTY
17937: LIST
17938: LIST
17939: LIST
17940: PPUSH
17941: CALL_OW 72
17945: ST_TO_ADDR
17946: GO 18170
17948: LD_INT 2
17950: DOUBLE
17951: EQUAL
17952: IFTRUE 17956
17954: GO 18018
17956: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
17957: LD_ADDR_VAR 0 12
17961: PUSH
17962: LD_VAR 0 18
17966: PPUSH
17967: LD_INT 22
17969: PUSH
17970: LD_VAR 0 16
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: PUSH
17979: LD_INT 2
17981: PUSH
17982: LD_INT 30
17984: PUSH
17985: LD_INT 0
17987: PUSH
17988: EMPTY
17989: LIST
17990: LIST
17991: PUSH
17992: LD_INT 30
17994: PUSH
17995: LD_INT 1
17997: PUSH
17998: EMPTY
17999: LIST
18000: LIST
18001: PUSH
18002: EMPTY
18003: LIST
18004: LIST
18005: LIST
18006: PUSH
18007: EMPTY
18008: LIST
18009: LIST
18010: PPUSH
18011: CALL_OW 72
18015: ST_TO_ADDR
18016: GO 18170
18018: LD_INT 3
18020: DOUBLE
18021: EQUAL
18022: IFTRUE 18026
18024: GO 18088
18026: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
18027: LD_ADDR_VAR 0 12
18031: PUSH
18032: LD_VAR 0 18
18036: PPUSH
18037: LD_INT 22
18039: PUSH
18040: LD_VAR 0 16
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: PUSH
18049: LD_INT 2
18051: PUSH
18052: LD_INT 30
18054: PUSH
18055: LD_INT 2
18057: PUSH
18058: EMPTY
18059: LIST
18060: LIST
18061: PUSH
18062: LD_INT 30
18064: PUSH
18065: LD_INT 3
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: PUSH
18072: EMPTY
18073: LIST
18074: LIST
18075: LIST
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: PPUSH
18081: CALL_OW 72
18085: ST_TO_ADDR
18086: GO 18170
18088: LD_INT 4
18090: DOUBLE
18091: EQUAL
18092: IFTRUE 18096
18094: GO 18169
18096: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
18097: LD_ADDR_VAR 0 12
18101: PUSH
18102: LD_VAR 0 18
18106: PPUSH
18107: LD_INT 22
18109: PUSH
18110: LD_VAR 0 16
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: PUSH
18119: LD_INT 2
18121: PUSH
18122: LD_INT 30
18124: PUSH
18125: LD_INT 6
18127: PUSH
18128: EMPTY
18129: LIST
18130: LIST
18131: PUSH
18132: LD_INT 30
18134: PUSH
18135: LD_INT 7
18137: PUSH
18138: EMPTY
18139: LIST
18140: LIST
18141: PUSH
18142: LD_INT 30
18144: PUSH
18145: LD_INT 8
18147: PUSH
18148: EMPTY
18149: LIST
18150: LIST
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PPUSH
18162: CALL_OW 72
18166: ST_TO_ADDR
18167: GO 18170
18169: POP
// if i = 1 then
18170: LD_VAR 0 8
18174: PUSH
18175: LD_INT 1
18177: EQUAL
18178: IFFALSE 18289
// begin tmp := [ ] ;
18180: LD_ADDR_VAR 0 19
18184: PUSH
18185: EMPTY
18186: ST_TO_ADDR
// for j in f do
18187: LD_ADDR_VAR 0 9
18191: PUSH
18192: LD_VAR 0 12
18196: PUSH
18197: FOR_IN
18198: IFFALSE 18271
// if GetBType ( j ) = b_bunker then
18200: LD_VAR 0 9
18204: PPUSH
18205: CALL_OW 266
18209: PUSH
18210: LD_INT 32
18212: EQUAL
18213: IFFALSE 18240
// tmp := Insert ( tmp , 1 , j ) else
18215: LD_ADDR_VAR 0 19
18219: PUSH
18220: LD_VAR 0 19
18224: PPUSH
18225: LD_INT 1
18227: PPUSH
18228: LD_VAR 0 9
18232: PPUSH
18233: CALL_OW 2
18237: ST_TO_ADDR
18238: GO 18269
// tmp := Insert ( tmp , tmp + 1 , j ) ;
18240: LD_ADDR_VAR 0 19
18244: PUSH
18245: LD_VAR 0 19
18249: PPUSH
18250: LD_VAR 0 19
18254: PUSH
18255: LD_INT 1
18257: PLUS
18258: PPUSH
18259: LD_VAR 0 9
18263: PPUSH
18264: CALL_OW 2
18268: ST_TO_ADDR
18269: GO 18197
18271: POP
18272: POP
// if tmp then
18273: LD_VAR 0 19
18277: IFFALSE 18289
// f := tmp ;
18279: LD_ADDR_VAR 0 12
18283: PUSH
18284: LD_VAR 0 19
18288: ST_TO_ADDR
// end ; x := personel [ i ] ;
18289: LD_ADDR_VAR 0 13
18293: PUSH
18294: LD_VAR 0 6
18298: PUSH
18299: LD_VAR 0 8
18303: ARRAY
18304: ST_TO_ADDR
// if x = - 1 then
18305: LD_VAR 0 13
18309: PUSH
18310: LD_INT 1
18312: NEG
18313: EQUAL
18314: IFFALSE 18523
// begin for j in f do
18316: LD_ADDR_VAR 0 9
18320: PUSH
18321: LD_VAR 0 12
18325: PUSH
18326: FOR_IN
18327: IFFALSE 18519
// repeat InitHc ;
18329: CALL_OW 19
// if GetBType ( j ) = b_barracks then
18333: LD_VAR 0 9
18337: PPUSH
18338: CALL_OW 266
18342: PUSH
18343: LD_INT 5
18345: EQUAL
18346: IFFALSE 18416
// begin if UnitsInside ( j ) < 3 then
18348: LD_VAR 0 9
18352: PPUSH
18353: CALL_OW 313
18357: PUSH
18358: LD_INT 3
18360: LESS
18361: IFFALSE 18397
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18363: LD_INT 0
18365: PPUSH
18366: LD_INT 5
18368: PUSH
18369: LD_INT 8
18371: PUSH
18372: LD_INT 9
18374: PUSH
18375: EMPTY
18376: LIST
18377: LIST
18378: LIST
18379: PUSH
18380: LD_VAR 0 17
18384: ARRAY
18385: PPUSH
18386: LD_VAR 0 4
18390: PPUSH
18391: CALL_OW 380
18395: GO 18414
// PrepareHuman ( false , i , skill ) ;
18397: LD_INT 0
18399: PPUSH
18400: LD_VAR 0 8
18404: PPUSH
18405: LD_VAR 0 4
18409: PPUSH
18410: CALL_OW 380
// end else
18414: GO 18433
// PrepareHuman ( false , i , skill ) ;
18416: LD_INT 0
18418: PPUSH
18419: LD_VAR 0 8
18423: PPUSH
18424: LD_VAR 0 4
18428: PPUSH
18429: CALL_OW 380
// un := CreateHuman ;
18433: LD_ADDR_VAR 0 14
18437: PUSH
18438: CALL_OW 44
18442: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18443: LD_ADDR_VAR 0 7
18447: PUSH
18448: LD_VAR 0 7
18452: PPUSH
18453: LD_INT 1
18455: PPUSH
18456: LD_VAR 0 14
18460: PPUSH
18461: CALL_OW 2
18465: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
18466: LD_VAR 0 14
18470: PPUSH
18471: LD_VAR 0 9
18475: PPUSH
18476: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
18480: LD_VAR 0 9
18484: PPUSH
18485: CALL_OW 313
18489: PUSH
18490: LD_INT 6
18492: EQUAL
18493: PUSH
18494: LD_VAR 0 9
18498: PPUSH
18499: CALL_OW 266
18503: PUSH
18504: LD_INT 32
18506: PUSH
18507: LD_INT 31
18509: PUSH
18510: EMPTY
18511: LIST
18512: LIST
18513: IN
18514: OR
18515: IFFALSE 18329
18517: GO 18326
18519: POP
18520: POP
// end else
18521: GO 18903
// for j = 1 to x do
18523: LD_ADDR_VAR 0 9
18527: PUSH
18528: DOUBLE
18529: LD_INT 1
18531: DEC
18532: ST_TO_ADDR
18533: LD_VAR 0 13
18537: PUSH
18538: FOR_TO
18539: IFFALSE 18901
// begin InitHc ;
18541: CALL_OW 19
// if not f then
18545: LD_VAR 0 12
18549: NOT
18550: IFFALSE 18639
// begin PrepareHuman ( false , i , skill ) ;
18552: LD_INT 0
18554: PPUSH
18555: LD_VAR 0 8
18559: PPUSH
18560: LD_VAR 0 4
18564: PPUSH
18565: CALL_OW 380
// un := CreateHuman ;
18569: LD_ADDR_VAR 0 14
18573: PUSH
18574: CALL_OW 44
18578: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18579: LD_ADDR_VAR 0 7
18583: PUSH
18584: LD_VAR 0 7
18588: PPUSH
18589: LD_INT 1
18591: PPUSH
18592: LD_VAR 0 14
18596: PPUSH
18597: CALL_OW 2
18601: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
18602: LD_VAR 0 14
18606: PPUSH
18607: LD_VAR 0 1
18611: PPUSH
18612: CALL_OW 250
18616: PPUSH
18617: LD_VAR 0 1
18621: PPUSH
18622: CALL_OW 251
18626: PPUSH
18627: LD_INT 10
18629: PPUSH
18630: LD_INT 0
18632: PPUSH
18633: CALL_OW 50
// continue ;
18637: GO 18538
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
18639: LD_VAR 0 12
18643: PUSH
18644: LD_INT 1
18646: ARRAY
18647: PPUSH
18648: CALL_OW 313
18652: PUSH
18653: LD_VAR 0 12
18657: PUSH
18658: LD_INT 1
18660: ARRAY
18661: PPUSH
18662: CALL_OW 266
18666: PUSH
18667: LD_INT 32
18669: PUSH
18670: LD_INT 31
18672: PUSH
18673: EMPTY
18674: LIST
18675: LIST
18676: IN
18677: AND
18678: PUSH
18679: LD_VAR 0 12
18683: PUSH
18684: LD_INT 1
18686: ARRAY
18687: PPUSH
18688: CALL_OW 313
18692: PUSH
18693: LD_INT 6
18695: EQUAL
18696: OR
18697: IFFALSE 18717
// f := Delete ( f , 1 ) ;
18699: LD_ADDR_VAR 0 12
18703: PUSH
18704: LD_VAR 0 12
18708: PPUSH
18709: LD_INT 1
18711: PPUSH
18712: CALL_OW 3
18716: ST_TO_ADDR
// if not f then
18717: LD_VAR 0 12
18721: NOT
18722: IFFALSE 18740
// begin x := x + 2 ;
18724: LD_ADDR_VAR 0 13
18728: PUSH
18729: LD_VAR 0 13
18733: PUSH
18734: LD_INT 2
18736: PLUS
18737: ST_TO_ADDR
// continue ;
18738: GO 18538
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
18740: LD_VAR 0 12
18744: PUSH
18745: LD_INT 1
18747: ARRAY
18748: PPUSH
18749: CALL_OW 266
18753: PUSH
18754: LD_INT 5
18756: EQUAL
18757: IFFALSE 18831
// begin if UnitsInside ( f [ 1 ] ) < 3 then
18759: LD_VAR 0 12
18763: PUSH
18764: LD_INT 1
18766: ARRAY
18767: PPUSH
18768: CALL_OW 313
18772: PUSH
18773: LD_INT 3
18775: LESS
18776: IFFALSE 18812
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
18778: LD_INT 0
18780: PPUSH
18781: LD_INT 5
18783: PUSH
18784: LD_INT 8
18786: PUSH
18787: LD_INT 9
18789: PUSH
18790: EMPTY
18791: LIST
18792: LIST
18793: LIST
18794: PUSH
18795: LD_VAR 0 17
18799: ARRAY
18800: PPUSH
18801: LD_VAR 0 4
18805: PPUSH
18806: CALL_OW 380
18810: GO 18829
// PrepareHuman ( false , i , skill ) ;
18812: LD_INT 0
18814: PPUSH
18815: LD_VAR 0 8
18819: PPUSH
18820: LD_VAR 0 4
18824: PPUSH
18825: CALL_OW 380
// end else
18829: GO 18848
// PrepareHuman ( false , i , skill ) ;
18831: LD_INT 0
18833: PPUSH
18834: LD_VAR 0 8
18838: PPUSH
18839: LD_VAR 0 4
18843: PPUSH
18844: CALL_OW 380
// un := CreateHuman ;
18848: LD_ADDR_VAR 0 14
18852: PUSH
18853: CALL_OW 44
18857: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
18858: LD_ADDR_VAR 0 7
18862: PUSH
18863: LD_VAR 0 7
18867: PPUSH
18868: LD_INT 1
18870: PPUSH
18871: LD_VAR 0 14
18875: PPUSH
18876: CALL_OW 2
18880: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
18881: LD_VAR 0 14
18885: PPUSH
18886: LD_VAR 0 12
18890: PUSH
18891: LD_INT 1
18893: ARRAY
18894: PPUSH
18895: CALL_OW 52
// end ;
18899: GO 18538
18901: POP
18902: POP
// end ;
18903: GO 17840
18905: POP
18906: POP
// result := result ^ buildings ;
18907: LD_ADDR_VAR 0 7
18911: PUSH
18912: LD_VAR 0 7
18916: PUSH
18917: LD_VAR 0 18
18921: ADD
18922: ST_TO_ADDR
// end else
18923: GO 19066
// begin for i = 1 to personel do
18925: LD_ADDR_VAR 0 8
18929: PUSH
18930: DOUBLE
18931: LD_INT 1
18933: DEC
18934: ST_TO_ADDR
18935: LD_VAR 0 6
18939: PUSH
18940: FOR_TO
18941: IFFALSE 19064
// begin if i > 4 then
18943: LD_VAR 0 8
18947: PUSH
18948: LD_INT 4
18950: GREATER
18951: IFFALSE 18955
// break ;
18953: GO 19064
// x := personel [ i ] ;
18955: LD_ADDR_VAR 0 13
18959: PUSH
18960: LD_VAR 0 6
18964: PUSH
18965: LD_VAR 0 8
18969: ARRAY
18970: ST_TO_ADDR
// if x = - 1 then
18971: LD_VAR 0 13
18975: PUSH
18976: LD_INT 1
18978: NEG
18979: EQUAL
18980: IFFALSE 18984
// continue ;
18982: GO 18940
// PrepareHuman ( false , i , skill ) ;
18984: LD_INT 0
18986: PPUSH
18987: LD_VAR 0 8
18991: PPUSH
18992: LD_VAR 0 4
18996: PPUSH
18997: CALL_OW 380
// un := CreateHuman ;
19001: LD_ADDR_VAR 0 14
19005: PUSH
19006: CALL_OW 44
19010: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
19011: LD_VAR 0 14
19015: PPUSH
19016: LD_VAR 0 1
19020: PPUSH
19021: CALL_OW 250
19025: PPUSH
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 251
19035: PPUSH
19036: LD_INT 10
19038: PPUSH
19039: LD_INT 0
19041: PPUSH
19042: CALL_OW 50
// result := result ^ un ;
19046: LD_ADDR_VAR 0 7
19050: PUSH
19051: LD_VAR 0 7
19055: PUSH
19056: LD_VAR 0 14
19060: ADD
19061: ST_TO_ADDR
// end ;
19062: GO 18940
19064: POP
19065: POP
// end ; end ;
19066: LD_VAR 0 7
19070: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
19071: LD_INT 0
19073: PPUSH
19074: PPUSH
19075: PPUSH
19076: PPUSH
19077: PPUSH
19078: PPUSH
19079: PPUSH
19080: PPUSH
19081: PPUSH
19082: PPUSH
19083: PPUSH
19084: PPUSH
19085: PPUSH
19086: PPUSH
19087: PPUSH
19088: PPUSH
// result := false ;
19089: LD_ADDR_VAR 0 3
19093: PUSH
19094: LD_INT 0
19096: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
19097: LD_VAR 0 1
19101: NOT
19102: PUSH
19103: LD_VAR 0 1
19107: PPUSH
19108: CALL_OW 266
19112: PUSH
19113: LD_INT 32
19115: PUSH
19116: LD_INT 33
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: IN
19123: NOT
19124: OR
19125: IFFALSE 19129
// exit ;
19127: GO 20238
// nat := GetNation ( tower ) ;
19129: LD_ADDR_VAR 0 12
19133: PUSH
19134: LD_VAR 0 1
19138: PPUSH
19139: CALL_OW 248
19143: ST_TO_ADDR
// side := GetSide ( tower ) ;
19144: LD_ADDR_VAR 0 16
19148: PUSH
19149: LD_VAR 0 1
19153: PPUSH
19154: CALL_OW 255
19158: ST_TO_ADDR
// x := GetX ( tower ) ;
19159: LD_ADDR_VAR 0 10
19163: PUSH
19164: LD_VAR 0 1
19168: PPUSH
19169: CALL_OW 250
19173: ST_TO_ADDR
// y := GetY ( tower ) ;
19174: LD_ADDR_VAR 0 11
19178: PUSH
19179: LD_VAR 0 1
19183: PPUSH
19184: CALL_OW 251
19188: ST_TO_ADDR
// if not x or not y then
19189: LD_VAR 0 10
19193: NOT
19194: PUSH
19195: LD_VAR 0 11
19199: NOT
19200: OR
19201: IFFALSE 19205
// exit ;
19203: GO 20238
// weapon := 0 ;
19205: LD_ADDR_VAR 0 18
19209: PUSH
19210: LD_INT 0
19212: ST_TO_ADDR
// fac_list := [ ] ;
19213: LD_ADDR_VAR 0 17
19217: PUSH
19218: EMPTY
19219: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
19220: LD_ADDR_VAR 0 6
19224: PUSH
19225: LD_VAR 0 1
19229: PPUSH
19230: CALL_OW 274
19234: PPUSH
19235: LD_VAR 0 2
19239: PPUSH
19240: LD_INT 0
19242: PPUSH
19243: CALL 16808 0 3
19247: PPUSH
19248: LD_INT 30
19250: PUSH
19251: LD_INT 3
19253: PUSH
19254: EMPTY
19255: LIST
19256: LIST
19257: PPUSH
19258: CALL_OW 72
19262: ST_TO_ADDR
// if not factories then
19263: LD_VAR 0 6
19267: NOT
19268: IFFALSE 19272
// exit ;
19270: GO 20238
// for i in factories do
19272: LD_ADDR_VAR 0 8
19276: PUSH
19277: LD_VAR 0 6
19281: PUSH
19282: FOR_IN
19283: IFFALSE 19308
// fac_list := fac_list union AvailableWeaponList ( i ) ;
19285: LD_ADDR_VAR 0 17
19289: PUSH
19290: LD_VAR 0 17
19294: PUSH
19295: LD_VAR 0 8
19299: PPUSH
19300: CALL_OW 478
19304: UNION
19305: ST_TO_ADDR
19306: GO 19282
19308: POP
19309: POP
// if not fac_list then
19310: LD_VAR 0 17
19314: NOT
19315: IFFALSE 19319
// exit ;
19317: GO 20238
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
19319: LD_ADDR_VAR 0 5
19323: PUSH
19324: LD_INT 4
19326: PUSH
19327: LD_INT 5
19329: PUSH
19330: LD_INT 9
19332: PUSH
19333: LD_INT 10
19335: PUSH
19336: LD_INT 6
19338: PUSH
19339: LD_INT 7
19341: PUSH
19342: LD_INT 11
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: LIST
19352: LIST
19353: PUSH
19354: LD_INT 27
19356: PUSH
19357: LD_INT 28
19359: PUSH
19360: LD_INT 26
19362: PUSH
19363: LD_INT 30
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: LIST
19370: LIST
19371: PUSH
19372: LD_INT 43
19374: PUSH
19375: LD_INT 44
19377: PUSH
19378: LD_INT 46
19380: PUSH
19381: LD_INT 45
19383: PUSH
19384: LD_INT 47
19386: PUSH
19387: LD_INT 49
19389: PUSH
19390: EMPTY
19391: LIST
19392: LIST
19393: LIST
19394: LIST
19395: LIST
19396: LIST
19397: PUSH
19398: EMPTY
19399: LIST
19400: LIST
19401: LIST
19402: PUSH
19403: LD_VAR 0 12
19407: ARRAY
19408: ST_TO_ADDR
// list := list isect fac_list ;
19409: LD_ADDR_VAR 0 5
19413: PUSH
19414: LD_VAR 0 5
19418: PUSH
19419: LD_VAR 0 17
19423: ISECT
19424: ST_TO_ADDR
// if not list then
19425: LD_VAR 0 5
19429: NOT
19430: IFFALSE 19434
// exit ;
19432: GO 20238
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
19434: LD_VAR 0 12
19438: PUSH
19439: LD_INT 3
19441: EQUAL
19442: PUSH
19443: LD_INT 49
19445: PUSH
19446: LD_VAR 0 5
19450: IN
19451: AND
19452: PUSH
19453: LD_INT 31
19455: PPUSH
19456: LD_VAR 0 16
19460: PPUSH
19461: CALL_OW 321
19465: PUSH
19466: LD_INT 2
19468: EQUAL
19469: AND
19470: IFFALSE 19530
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
19472: LD_INT 22
19474: PUSH
19475: LD_VAR 0 16
19479: PUSH
19480: EMPTY
19481: LIST
19482: LIST
19483: PUSH
19484: LD_INT 35
19486: PUSH
19487: LD_INT 49
19489: PUSH
19490: EMPTY
19491: LIST
19492: LIST
19493: PUSH
19494: LD_INT 91
19496: PUSH
19497: LD_VAR 0 1
19501: PUSH
19502: LD_INT 10
19504: PUSH
19505: EMPTY
19506: LIST
19507: LIST
19508: LIST
19509: PUSH
19510: EMPTY
19511: LIST
19512: LIST
19513: LIST
19514: PPUSH
19515: CALL_OW 69
19519: NOT
19520: IFFALSE 19530
// weapon := ru_time_lapser ;
19522: LD_ADDR_VAR 0 18
19526: PUSH
19527: LD_INT 49
19529: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
19530: LD_VAR 0 12
19534: PUSH
19535: LD_INT 1
19537: PUSH
19538: LD_INT 2
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: IN
19545: PUSH
19546: LD_INT 11
19548: PUSH
19549: LD_VAR 0 5
19553: IN
19554: PUSH
19555: LD_INT 30
19557: PUSH
19558: LD_VAR 0 5
19562: IN
19563: OR
19564: AND
19565: PUSH
19566: LD_INT 6
19568: PPUSH
19569: LD_VAR 0 16
19573: PPUSH
19574: CALL_OW 321
19578: PUSH
19579: LD_INT 2
19581: EQUAL
19582: AND
19583: IFFALSE 19748
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
19585: LD_INT 22
19587: PUSH
19588: LD_VAR 0 16
19592: PUSH
19593: EMPTY
19594: LIST
19595: LIST
19596: PUSH
19597: LD_INT 2
19599: PUSH
19600: LD_INT 35
19602: PUSH
19603: LD_INT 11
19605: PUSH
19606: EMPTY
19607: LIST
19608: LIST
19609: PUSH
19610: LD_INT 35
19612: PUSH
19613: LD_INT 30
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: LIST
19624: PUSH
19625: LD_INT 91
19627: PUSH
19628: LD_VAR 0 1
19632: PUSH
19633: LD_INT 18
19635: PUSH
19636: EMPTY
19637: LIST
19638: LIST
19639: LIST
19640: PUSH
19641: EMPTY
19642: LIST
19643: LIST
19644: LIST
19645: PPUSH
19646: CALL_OW 69
19650: NOT
19651: PUSH
19652: LD_INT 22
19654: PUSH
19655: LD_VAR 0 16
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: PUSH
19664: LD_INT 2
19666: PUSH
19667: LD_INT 30
19669: PUSH
19670: LD_INT 32
19672: PUSH
19673: EMPTY
19674: LIST
19675: LIST
19676: PUSH
19677: LD_INT 30
19679: PUSH
19680: LD_INT 33
19682: PUSH
19683: EMPTY
19684: LIST
19685: LIST
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: LIST
19691: PUSH
19692: LD_INT 91
19694: PUSH
19695: LD_VAR 0 1
19699: PUSH
19700: LD_INT 12
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: LIST
19707: PUSH
19708: EMPTY
19709: LIST
19710: LIST
19711: LIST
19712: PUSH
19713: EMPTY
19714: LIST
19715: PPUSH
19716: CALL_OW 69
19720: PUSH
19721: LD_INT 2
19723: GREATER
19724: AND
19725: IFFALSE 19748
// weapon := [ us_radar , ar_radar ] [ nat ] ;
19727: LD_ADDR_VAR 0 18
19731: PUSH
19732: LD_INT 11
19734: PUSH
19735: LD_INT 30
19737: PUSH
19738: EMPTY
19739: LIST
19740: LIST
19741: PUSH
19742: LD_VAR 0 12
19746: ARRAY
19747: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
19748: LD_VAR 0 18
19752: NOT
19753: PUSH
19754: LD_INT 40
19756: PPUSH
19757: LD_VAR 0 16
19761: PPUSH
19762: CALL_OW 321
19766: PUSH
19767: LD_INT 2
19769: EQUAL
19770: AND
19771: PUSH
19772: LD_INT 7
19774: PUSH
19775: LD_VAR 0 5
19779: IN
19780: PUSH
19781: LD_INT 28
19783: PUSH
19784: LD_VAR 0 5
19788: IN
19789: OR
19790: PUSH
19791: LD_INT 45
19793: PUSH
19794: LD_VAR 0 5
19798: IN
19799: OR
19800: AND
19801: IFFALSE 20055
// begin hex := GetHexInfo ( x , y ) ;
19803: LD_ADDR_VAR 0 4
19807: PUSH
19808: LD_VAR 0 10
19812: PPUSH
19813: LD_VAR 0 11
19817: PPUSH
19818: CALL_OW 546
19822: ST_TO_ADDR
// if hex [ 1 ] then
19823: LD_VAR 0 4
19827: PUSH
19828: LD_INT 1
19830: ARRAY
19831: IFFALSE 19835
// exit ;
19833: GO 20238
// height := hex [ 2 ] ;
19835: LD_ADDR_VAR 0 15
19839: PUSH
19840: LD_VAR 0 4
19844: PUSH
19845: LD_INT 2
19847: ARRAY
19848: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
19849: LD_ADDR_VAR 0 14
19853: PUSH
19854: LD_INT 0
19856: PUSH
19857: LD_INT 2
19859: PUSH
19860: LD_INT 3
19862: PUSH
19863: LD_INT 5
19865: PUSH
19866: EMPTY
19867: LIST
19868: LIST
19869: LIST
19870: LIST
19871: ST_TO_ADDR
// for i in tmp do
19872: LD_ADDR_VAR 0 8
19876: PUSH
19877: LD_VAR 0 14
19881: PUSH
19882: FOR_IN
19883: IFFALSE 20053
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
19885: LD_ADDR_VAR 0 9
19889: PUSH
19890: LD_VAR 0 10
19894: PPUSH
19895: LD_VAR 0 8
19899: PPUSH
19900: LD_INT 5
19902: PPUSH
19903: CALL_OW 272
19907: PUSH
19908: LD_VAR 0 11
19912: PPUSH
19913: LD_VAR 0 8
19917: PPUSH
19918: LD_INT 5
19920: PPUSH
19921: CALL_OW 273
19925: PUSH
19926: EMPTY
19927: LIST
19928: LIST
19929: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
19930: LD_VAR 0 9
19934: PUSH
19935: LD_INT 1
19937: ARRAY
19938: PPUSH
19939: LD_VAR 0 9
19943: PUSH
19944: LD_INT 2
19946: ARRAY
19947: PPUSH
19948: CALL_OW 488
19952: IFFALSE 20051
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
19954: LD_ADDR_VAR 0 4
19958: PUSH
19959: LD_VAR 0 9
19963: PUSH
19964: LD_INT 1
19966: ARRAY
19967: PPUSH
19968: LD_VAR 0 9
19972: PUSH
19973: LD_INT 2
19975: ARRAY
19976: PPUSH
19977: CALL_OW 546
19981: ST_TO_ADDR
// if hex [ 1 ] then
19982: LD_VAR 0 4
19986: PUSH
19987: LD_INT 1
19989: ARRAY
19990: IFFALSE 19994
// continue ;
19992: GO 19882
// h := hex [ 2 ] ;
19994: LD_ADDR_VAR 0 13
19998: PUSH
19999: LD_VAR 0 4
20003: PUSH
20004: LD_INT 2
20006: ARRAY
20007: ST_TO_ADDR
// if h + 7 < height then
20008: LD_VAR 0 13
20012: PUSH
20013: LD_INT 7
20015: PLUS
20016: PUSH
20017: LD_VAR 0 15
20021: LESS
20022: IFFALSE 20051
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
20024: LD_ADDR_VAR 0 18
20028: PUSH
20029: LD_INT 7
20031: PUSH
20032: LD_INT 28
20034: PUSH
20035: LD_INT 45
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: LIST
20042: PUSH
20043: LD_VAR 0 12
20047: ARRAY
20048: ST_TO_ADDR
// break ;
20049: GO 20053
// end ; end ; end ;
20051: GO 19882
20053: POP
20054: POP
// end ; if not weapon then
20055: LD_VAR 0 18
20059: NOT
20060: IFFALSE 20120
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
20062: LD_ADDR_VAR 0 5
20066: PUSH
20067: LD_VAR 0 5
20071: PUSH
20072: LD_INT 11
20074: PUSH
20075: LD_INT 30
20077: PUSH
20078: LD_INT 49
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: DIFF
20086: ST_TO_ADDR
// if not list then
20087: LD_VAR 0 5
20091: NOT
20092: IFFALSE 20096
// exit ;
20094: GO 20238
// weapon := list [ rand ( 1 , list ) ] ;
20096: LD_ADDR_VAR 0 18
20100: PUSH
20101: LD_VAR 0 5
20105: PUSH
20106: LD_INT 1
20108: PPUSH
20109: LD_VAR 0 5
20113: PPUSH
20114: CALL_OW 12
20118: ARRAY
20119: ST_TO_ADDR
// end ; if weapon then
20120: LD_VAR 0 18
20124: IFFALSE 20238
// begin tmp := CostOfWeapon ( weapon ) ;
20126: LD_ADDR_VAR 0 14
20130: PUSH
20131: LD_VAR 0 18
20135: PPUSH
20136: CALL_OW 451
20140: ST_TO_ADDR
// j := GetBase ( tower ) ;
20141: LD_ADDR_VAR 0 9
20145: PUSH
20146: LD_VAR 0 1
20150: PPUSH
20151: CALL_OW 274
20155: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
20156: LD_VAR 0 9
20160: PPUSH
20161: LD_INT 1
20163: PPUSH
20164: CALL_OW 275
20168: PUSH
20169: LD_VAR 0 14
20173: PUSH
20174: LD_INT 1
20176: ARRAY
20177: GREATEREQUAL
20178: PUSH
20179: LD_VAR 0 9
20183: PPUSH
20184: LD_INT 2
20186: PPUSH
20187: CALL_OW 275
20191: PUSH
20192: LD_VAR 0 14
20196: PUSH
20197: LD_INT 2
20199: ARRAY
20200: GREATEREQUAL
20201: AND
20202: PUSH
20203: LD_VAR 0 9
20207: PPUSH
20208: LD_INT 3
20210: PPUSH
20211: CALL_OW 275
20215: PUSH
20216: LD_VAR 0 14
20220: PUSH
20221: LD_INT 3
20223: ARRAY
20224: GREATEREQUAL
20225: AND
20226: IFFALSE 20238
// result := weapon ;
20228: LD_ADDR_VAR 0 3
20232: PUSH
20233: LD_VAR 0 18
20237: ST_TO_ADDR
// end ; end ;
20238: LD_VAR 0 3
20242: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
20243: LD_INT 0
20245: PPUSH
20246: PPUSH
// result := true ;
20247: LD_ADDR_VAR 0 3
20251: PUSH
20252: LD_INT 1
20254: ST_TO_ADDR
// if array1 = array2 then
20255: LD_VAR 0 1
20259: PUSH
20260: LD_VAR 0 2
20264: EQUAL
20265: IFFALSE 20325
// begin for i = 1 to array1 do
20267: LD_ADDR_VAR 0 4
20271: PUSH
20272: DOUBLE
20273: LD_INT 1
20275: DEC
20276: ST_TO_ADDR
20277: LD_VAR 0 1
20281: PUSH
20282: FOR_TO
20283: IFFALSE 20321
// if array1 [ i ] <> array2 [ i ] then
20285: LD_VAR 0 1
20289: PUSH
20290: LD_VAR 0 4
20294: ARRAY
20295: PUSH
20296: LD_VAR 0 2
20300: PUSH
20301: LD_VAR 0 4
20305: ARRAY
20306: NONEQUAL
20307: IFFALSE 20319
// begin result := false ;
20309: LD_ADDR_VAR 0 3
20313: PUSH
20314: LD_INT 0
20316: ST_TO_ADDR
// break ;
20317: GO 20321
// end ;
20319: GO 20282
20321: POP
20322: POP
// end else
20323: GO 20333
// result := false ;
20325: LD_ADDR_VAR 0 3
20329: PUSH
20330: LD_INT 0
20332: ST_TO_ADDR
// end ;
20333: LD_VAR 0 3
20337: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
20338: LD_INT 0
20340: PPUSH
20341: PPUSH
// if not array1 or not array2 then
20342: LD_VAR 0 1
20346: NOT
20347: PUSH
20348: LD_VAR 0 2
20352: NOT
20353: OR
20354: IFFALSE 20358
// exit ;
20356: GO 20422
// result := true ;
20358: LD_ADDR_VAR 0 3
20362: PUSH
20363: LD_INT 1
20365: ST_TO_ADDR
// for i = 1 to array1 do
20366: LD_ADDR_VAR 0 4
20370: PUSH
20371: DOUBLE
20372: LD_INT 1
20374: DEC
20375: ST_TO_ADDR
20376: LD_VAR 0 1
20380: PUSH
20381: FOR_TO
20382: IFFALSE 20420
// if array1 [ i ] <> array2 [ i ] then
20384: LD_VAR 0 1
20388: PUSH
20389: LD_VAR 0 4
20393: ARRAY
20394: PUSH
20395: LD_VAR 0 2
20399: PUSH
20400: LD_VAR 0 4
20404: ARRAY
20405: NONEQUAL
20406: IFFALSE 20418
// begin result := false ;
20408: LD_ADDR_VAR 0 3
20412: PUSH
20413: LD_INT 0
20415: ST_TO_ADDR
// break ;
20416: GO 20420
// end ;
20418: GO 20381
20420: POP
20421: POP
// end ;
20422: LD_VAR 0 3
20426: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
20427: LD_INT 0
20429: PPUSH
20430: PPUSH
20431: PPUSH
// pom := GetBase ( fac ) ;
20432: LD_ADDR_VAR 0 5
20436: PUSH
20437: LD_VAR 0 1
20441: PPUSH
20442: CALL_OW 274
20446: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
20447: LD_ADDR_VAR 0 4
20451: PUSH
20452: LD_VAR 0 2
20456: PUSH
20457: LD_INT 1
20459: ARRAY
20460: PPUSH
20461: LD_VAR 0 2
20465: PUSH
20466: LD_INT 2
20468: ARRAY
20469: PPUSH
20470: LD_VAR 0 2
20474: PUSH
20475: LD_INT 3
20477: ARRAY
20478: PPUSH
20479: LD_VAR 0 2
20483: PUSH
20484: LD_INT 4
20486: ARRAY
20487: PPUSH
20488: CALL_OW 449
20492: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20493: LD_ADDR_VAR 0 3
20497: PUSH
20498: LD_VAR 0 5
20502: PPUSH
20503: LD_INT 1
20505: PPUSH
20506: CALL_OW 275
20510: PUSH
20511: LD_VAR 0 4
20515: PUSH
20516: LD_INT 1
20518: ARRAY
20519: GREATEREQUAL
20520: PUSH
20521: LD_VAR 0 5
20525: PPUSH
20526: LD_INT 2
20528: PPUSH
20529: CALL_OW 275
20533: PUSH
20534: LD_VAR 0 4
20538: PUSH
20539: LD_INT 2
20541: ARRAY
20542: GREATEREQUAL
20543: AND
20544: PUSH
20545: LD_VAR 0 5
20549: PPUSH
20550: LD_INT 3
20552: PPUSH
20553: CALL_OW 275
20557: PUSH
20558: LD_VAR 0 4
20562: PUSH
20563: LD_INT 3
20565: ARRAY
20566: GREATEREQUAL
20567: AND
20568: ST_TO_ADDR
// end ;
20569: LD_VAR 0 3
20573: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
20574: LD_INT 0
20576: PPUSH
20577: PPUSH
20578: PPUSH
20579: PPUSH
// pom := GetBase ( building ) ;
20580: LD_ADDR_VAR 0 3
20584: PUSH
20585: LD_VAR 0 1
20589: PPUSH
20590: CALL_OW 274
20594: ST_TO_ADDR
// if not pom then
20595: LD_VAR 0 3
20599: NOT
20600: IFFALSE 20604
// exit ;
20602: GO 20774
// btype := GetBType ( building ) ;
20604: LD_ADDR_VAR 0 5
20608: PUSH
20609: LD_VAR 0 1
20613: PPUSH
20614: CALL_OW 266
20618: ST_TO_ADDR
// if btype = b_armoury then
20619: LD_VAR 0 5
20623: PUSH
20624: LD_INT 4
20626: EQUAL
20627: IFFALSE 20637
// btype := b_barracks ;
20629: LD_ADDR_VAR 0 5
20633: PUSH
20634: LD_INT 5
20636: ST_TO_ADDR
// if btype = b_depot then
20637: LD_VAR 0 5
20641: PUSH
20642: LD_INT 0
20644: EQUAL
20645: IFFALSE 20655
// btype := b_warehouse ;
20647: LD_ADDR_VAR 0 5
20651: PUSH
20652: LD_INT 1
20654: ST_TO_ADDR
// if btype = b_workshop then
20655: LD_VAR 0 5
20659: PUSH
20660: LD_INT 2
20662: EQUAL
20663: IFFALSE 20673
// btype := b_factory ;
20665: LD_ADDR_VAR 0 5
20669: PUSH
20670: LD_INT 3
20672: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20673: LD_ADDR_VAR 0 4
20677: PUSH
20678: LD_VAR 0 5
20682: PPUSH
20683: LD_VAR 0 1
20687: PPUSH
20688: CALL_OW 248
20692: PPUSH
20693: CALL_OW 450
20697: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20698: LD_ADDR_VAR 0 2
20702: PUSH
20703: LD_VAR 0 3
20707: PPUSH
20708: LD_INT 1
20710: PPUSH
20711: CALL_OW 275
20715: PUSH
20716: LD_VAR 0 4
20720: PUSH
20721: LD_INT 1
20723: ARRAY
20724: GREATEREQUAL
20725: PUSH
20726: LD_VAR 0 3
20730: PPUSH
20731: LD_INT 2
20733: PPUSH
20734: CALL_OW 275
20738: PUSH
20739: LD_VAR 0 4
20743: PUSH
20744: LD_INT 2
20746: ARRAY
20747: GREATEREQUAL
20748: AND
20749: PUSH
20750: LD_VAR 0 3
20754: PPUSH
20755: LD_INT 3
20757: PPUSH
20758: CALL_OW 275
20762: PUSH
20763: LD_VAR 0 4
20767: PUSH
20768: LD_INT 3
20770: ARRAY
20771: GREATEREQUAL
20772: AND
20773: ST_TO_ADDR
// end ;
20774: LD_VAR 0 2
20778: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
20779: LD_INT 0
20781: PPUSH
20782: PPUSH
20783: PPUSH
// pom := GetBase ( building ) ;
20784: LD_ADDR_VAR 0 4
20788: PUSH
20789: LD_VAR 0 1
20793: PPUSH
20794: CALL_OW 274
20798: ST_TO_ADDR
// if not pom then
20799: LD_VAR 0 4
20803: NOT
20804: IFFALSE 20808
// exit ;
20806: GO 20909
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
20808: LD_ADDR_VAR 0 5
20812: PUSH
20813: LD_VAR 0 2
20817: PPUSH
20818: LD_VAR 0 1
20822: PPUSH
20823: CALL_OW 248
20827: PPUSH
20828: CALL_OW 450
20832: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
20833: LD_ADDR_VAR 0 3
20837: PUSH
20838: LD_VAR 0 4
20842: PPUSH
20843: LD_INT 1
20845: PPUSH
20846: CALL_OW 275
20850: PUSH
20851: LD_VAR 0 5
20855: PUSH
20856: LD_INT 1
20858: ARRAY
20859: GREATEREQUAL
20860: PUSH
20861: LD_VAR 0 4
20865: PPUSH
20866: LD_INT 2
20868: PPUSH
20869: CALL_OW 275
20873: PUSH
20874: LD_VAR 0 5
20878: PUSH
20879: LD_INT 2
20881: ARRAY
20882: GREATEREQUAL
20883: AND
20884: PUSH
20885: LD_VAR 0 4
20889: PPUSH
20890: LD_INT 3
20892: PPUSH
20893: CALL_OW 275
20897: PUSH
20898: LD_VAR 0 5
20902: PUSH
20903: LD_INT 3
20905: ARRAY
20906: GREATEREQUAL
20907: AND
20908: ST_TO_ADDR
// end ;
20909: LD_VAR 0 3
20913: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
20914: LD_INT 0
20916: PPUSH
20917: PPUSH
20918: PPUSH
20919: PPUSH
20920: PPUSH
20921: PPUSH
20922: PPUSH
20923: PPUSH
20924: PPUSH
20925: PPUSH
20926: PPUSH
// result := false ;
20927: LD_ADDR_VAR 0 8
20931: PUSH
20932: LD_INT 0
20934: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
20935: LD_VAR 0 5
20939: NOT
20940: PUSH
20941: LD_VAR 0 1
20945: NOT
20946: OR
20947: PUSH
20948: LD_VAR 0 2
20952: NOT
20953: OR
20954: PUSH
20955: LD_VAR 0 3
20959: NOT
20960: OR
20961: IFFALSE 20965
// exit ;
20963: GO 21779
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
20965: LD_ADDR_VAR 0 14
20969: PUSH
20970: LD_VAR 0 1
20974: PPUSH
20975: LD_VAR 0 2
20979: PPUSH
20980: LD_VAR 0 3
20984: PPUSH
20985: LD_VAR 0 4
20989: PPUSH
20990: LD_VAR 0 5
20994: PUSH
20995: LD_INT 1
20997: ARRAY
20998: PPUSH
20999: CALL_OW 248
21003: PPUSH
21004: LD_INT 0
21006: PPUSH
21007: CALL 23016 0 6
21011: ST_TO_ADDR
// if not hexes then
21012: LD_VAR 0 14
21016: NOT
21017: IFFALSE 21021
// exit ;
21019: GO 21779
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
21021: LD_ADDR_VAR 0 17
21025: PUSH
21026: LD_VAR 0 5
21030: PPUSH
21031: LD_INT 22
21033: PUSH
21034: LD_VAR 0 13
21038: PPUSH
21039: CALL_OW 255
21043: PUSH
21044: EMPTY
21045: LIST
21046: LIST
21047: PUSH
21048: LD_INT 2
21050: PUSH
21051: LD_INT 30
21053: PUSH
21054: LD_INT 0
21056: PUSH
21057: EMPTY
21058: LIST
21059: LIST
21060: PUSH
21061: LD_INT 30
21063: PUSH
21064: LD_INT 1
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: LIST
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: PPUSH
21080: CALL_OW 72
21084: ST_TO_ADDR
// for i = 1 to hexes do
21085: LD_ADDR_VAR 0 9
21089: PUSH
21090: DOUBLE
21091: LD_INT 1
21093: DEC
21094: ST_TO_ADDR
21095: LD_VAR 0 14
21099: PUSH
21100: FOR_TO
21101: IFFALSE 21777
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
21103: LD_ADDR_VAR 0 13
21107: PUSH
21108: LD_VAR 0 14
21112: PUSH
21113: LD_VAR 0 9
21117: ARRAY
21118: PUSH
21119: LD_INT 1
21121: ARRAY
21122: PPUSH
21123: LD_VAR 0 14
21127: PUSH
21128: LD_VAR 0 9
21132: ARRAY
21133: PUSH
21134: LD_INT 2
21136: ARRAY
21137: PPUSH
21138: CALL_OW 428
21142: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
21143: LD_VAR 0 14
21147: PUSH
21148: LD_VAR 0 9
21152: ARRAY
21153: PUSH
21154: LD_INT 1
21156: ARRAY
21157: PPUSH
21158: LD_VAR 0 14
21162: PUSH
21163: LD_VAR 0 9
21167: ARRAY
21168: PUSH
21169: LD_INT 2
21171: ARRAY
21172: PPUSH
21173: CALL_OW 351
21177: PUSH
21178: LD_VAR 0 14
21182: PUSH
21183: LD_VAR 0 9
21187: ARRAY
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PPUSH
21193: LD_VAR 0 14
21197: PUSH
21198: LD_VAR 0 9
21202: ARRAY
21203: PUSH
21204: LD_INT 2
21206: ARRAY
21207: PPUSH
21208: CALL_OW 488
21212: NOT
21213: OR
21214: PUSH
21215: LD_VAR 0 13
21219: PPUSH
21220: CALL_OW 247
21224: PUSH
21225: LD_INT 3
21227: EQUAL
21228: OR
21229: IFFALSE 21235
// exit ;
21231: POP
21232: POP
21233: GO 21779
// if not tmp then
21235: LD_VAR 0 13
21239: NOT
21240: IFFALSE 21244
// continue ;
21242: GO 21100
// result := true ;
21244: LD_ADDR_VAR 0 8
21248: PUSH
21249: LD_INT 1
21251: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
21252: LD_VAR 0 6
21256: PUSH
21257: LD_VAR 0 13
21261: PPUSH
21262: CALL_OW 247
21266: PUSH
21267: LD_INT 2
21269: EQUAL
21270: AND
21271: PUSH
21272: LD_VAR 0 13
21276: PPUSH
21277: CALL_OW 263
21281: PUSH
21282: LD_INT 1
21284: EQUAL
21285: AND
21286: IFFALSE 21450
// begin if IsDrivenBy ( tmp ) then
21288: LD_VAR 0 13
21292: PPUSH
21293: CALL_OW 311
21297: IFFALSE 21301
// continue ;
21299: GO 21100
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
21301: LD_VAR 0 6
21305: PPUSH
21306: LD_INT 3
21308: PUSH
21309: LD_INT 60
21311: PUSH
21312: EMPTY
21313: LIST
21314: PUSH
21315: EMPTY
21316: LIST
21317: LIST
21318: PUSH
21319: LD_INT 3
21321: PUSH
21322: LD_INT 55
21324: PUSH
21325: EMPTY
21326: LIST
21327: PUSH
21328: EMPTY
21329: LIST
21330: LIST
21331: PUSH
21332: EMPTY
21333: LIST
21334: LIST
21335: PPUSH
21336: CALL_OW 72
21340: IFFALSE 21448
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
21342: LD_ADDR_VAR 0 18
21346: PUSH
21347: LD_VAR 0 6
21351: PPUSH
21352: LD_INT 3
21354: PUSH
21355: LD_INT 60
21357: PUSH
21358: EMPTY
21359: LIST
21360: PUSH
21361: EMPTY
21362: LIST
21363: LIST
21364: PUSH
21365: LD_INT 3
21367: PUSH
21368: LD_INT 55
21370: PUSH
21371: EMPTY
21372: LIST
21373: PUSH
21374: EMPTY
21375: LIST
21376: LIST
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PPUSH
21382: CALL_OW 72
21386: PUSH
21387: LD_INT 1
21389: ARRAY
21390: ST_TO_ADDR
// if IsInUnit ( driver ) then
21391: LD_VAR 0 18
21395: PPUSH
21396: CALL_OW 310
21400: IFFALSE 21411
// ComExit ( driver ) ;
21402: LD_VAR 0 18
21406: PPUSH
21407: CALL 46200 0 1
// AddComEnterUnit ( driver , tmp ) ;
21411: LD_VAR 0 18
21415: PPUSH
21416: LD_VAR 0 13
21420: PPUSH
21421: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
21425: LD_VAR 0 18
21429: PPUSH
21430: LD_VAR 0 7
21434: PPUSH
21435: CALL_OW 173
// AddComExitVehicle ( driver ) ;
21439: LD_VAR 0 18
21443: PPUSH
21444: CALL_OW 181
// end ; continue ;
21448: GO 21100
// end ; if not cleaners or not tmp in cleaners then
21450: LD_VAR 0 6
21454: NOT
21455: PUSH
21456: LD_VAR 0 13
21460: PUSH
21461: LD_VAR 0 6
21465: IN
21466: NOT
21467: OR
21468: IFFALSE 21775
// begin if dep then
21470: LD_VAR 0 17
21474: IFFALSE 21610
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
21476: LD_ADDR_VAR 0 16
21480: PUSH
21481: LD_VAR 0 17
21485: PUSH
21486: LD_INT 1
21488: ARRAY
21489: PPUSH
21490: CALL_OW 250
21494: PPUSH
21495: LD_VAR 0 17
21499: PUSH
21500: LD_INT 1
21502: ARRAY
21503: PPUSH
21504: CALL_OW 254
21508: PPUSH
21509: LD_INT 5
21511: PPUSH
21512: CALL_OW 272
21516: PUSH
21517: LD_VAR 0 17
21521: PUSH
21522: LD_INT 1
21524: ARRAY
21525: PPUSH
21526: CALL_OW 251
21530: PPUSH
21531: LD_VAR 0 17
21535: PUSH
21536: LD_INT 1
21538: ARRAY
21539: PPUSH
21540: CALL_OW 254
21544: PPUSH
21545: LD_INT 5
21547: PPUSH
21548: CALL_OW 273
21552: PUSH
21553: EMPTY
21554: LIST
21555: LIST
21556: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
21557: LD_VAR 0 16
21561: PUSH
21562: LD_INT 1
21564: ARRAY
21565: PPUSH
21566: LD_VAR 0 16
21570: PUSH
21571: LD_INT 2
21573: ARRAY
21574: PPUSH
21575: CALL_OW 488
21579: IFFALSE 21610
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
21581: LD_VAR 0 13
21585: PPUSH
21586: LD_VAR 0 16
21590: PUSH
21591: LD_INT 1
21593: ARRAY
21594: PPUSH
21595: LD_VAR 0 16
21599: PUSH
21600: LD_INT 2
21602: ARRAY
21603: PPUSH
21604: CALL_OW 111
// continue ;
21608: GO 21100
// end ; end ; r := GetDir ( tmp ) ;
21610: LD_ADDR_VAR 0 15
21614: PUSH
21615: LD_VAR 0 13
21619: PPUSH
21620: CALL_OW 254
21624: ST_TO_ADDR
// if r = 5 then
21625: LD_VAR 0 15
21629: PUSH
21630: LD_INT 5
21632: EQUAL
21633: IFFALSE 21643
// r := 0 ;
21635: LD_ADDR_VAR 0 15
21639: PUSH
21640: LD_INT 0
21642: ST_TO_ADDR
// for j = r to 5 do
21643: LD_ADDR_VAR 0 10
21647: PUSH
21648: DOUBLE
21649: LD_VAR 0 15
21653: DEC
21654: ST_TO_ADDR
21655: LD_INT 5
21657: PUSH
21658: FOR_TO
21659: IFFALSE 21773
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
21661: LD_ADDR_VAR 0 11
21665: PUSH
21666: LD_VAR 0 13
21670: PPUSH
21671: CALL_OW 250
21675: PPUSH
21676: LD_VAR 0 10
21680: PPUSH
21681: LD_INT 2
21683: PPUSH
21684: CALL_OW 272
21688: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
21689: LD_ADDR_VAR 0 12
21693: PUSH
21694: LD_VAR 0 13
21698: PPUSH
21699: CALL_OW 251
21703: PPUSH
21704: LD_VAR 0 10
21708: PPUSH
21709: LD_INT 2
21711: PPUSH
21712: CALL_OW 273
21716: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
21717: LD_VAR 0 11
21721: PPUSH
21722: LD_VAR 0 12
21726: PPUSH
21727: CALL_OW 488
21731: PUSH
21732: LD_VAR 0 11
21736: PPUSH
21737: LD_VAR 0 12
21741: PPUSH
21742: CALL_OW 428
21746: NOT
21747: AND
21748: IFFALSE 21771
// begin ComMoveXY ( tmp , _x , _y ) ;
21750: LD_VAR 0 13
21754: PPUSH
21755: LD_VAR 0 11
21759: PPUSH
21760: LD_VAR 0 12
21764: PPUSH
21765: CALL_OW 111
// break ;
21769: GO 21773
// end ; end ;
21771: GO 21658
21773: POP
21774: POP
// end ; end ;
21775: GO 21100
21777: POP
21778: POP
// end ;
21779: LD_VAR 0 8
21783: RET
// export function BuildingTechInvented ( side , btype ) ; begin
21784: LD_INT 0
21786: PPUSH
// result := true ;
21787: LD_ADDR_VAR 0 3
21791: PUSH
21792: LD_INT 1
21794: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
21795: LD_VAR 0 2
21799: PUSH
21800: LD_INT 24
21802: DOUBLE
21803: EQUAL
21804: IFTRUE 21814
21806: LD_INT 33
21808: DOUBLE
21809: EQUAL
21810: IFTRUE 21814
21812: GO 21839
21814: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
21815: LD_ADDR_VAR 0 3
21819: PUSH
21820: LD_INT 32
21822: PPUSH
21823: LD_VAR 0 1
21827: PPUSH
21828: CALL_OW 321
21832: PUSH
21833: LD_INT 2
21835: EQUAL
21836: ST_TO_ADDR
21837: GO 22159
21839: LD_INT 20
21841: DOUBLE
21842: EQUAL
21843: IFTRUE 21847
21845: GO 21872
21847: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
21848: LD_ADDR_VAR 0 3
21852: PUSH
21853: LD_INT 6
21855: PPUSH
21856: LD_VAR 0 1
21860: PPUSH
21861: CALL_OW 321
21865: PUSH
21866: LD_INT 2
21868: EQUAL
21869: ST_TO_ADDR
21870: GO 22159
21872: LD_INT 22
21874: DOUBLE
21875: EQUAL
21876: IFTRUE 21886
21878: LD_INT 36
21880: DOUBLE
21881: EQUAL
21882: IFTRUE 21886
21884: GO 21911
21886: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
21887: LD_ADDR_VAR 0 3
21891: PUSH
21892: LD_INT 15
21894: PPUSH
21895: LD_VAR 0 1
21899: PPUSH
21900: CALL_OW 321
21904: PUSH
21905: LD_INT 2
21907: EQUAL
21908: ST_TO_ADDR
21909: GO 22159
21911: LD_INT 30
21913: DOUBLE
21914: EQUAL
21915: IFTRUE 21919
21917: GO 21944
21919: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
21920: LD_ADDR_VAR 0 3
21924: PUSH
21925: LD_INT 20
21927: PPUSH
21928: LD_VAR 0 1
21932: PPUSH
21933: CALL_OW 321
21937: PUSH
21938: LD_INT 2
21940: EQUAL
21941: ST_TO_ADDR
21942: GO 22159
21944: LD_INT 28
21946: DOUBLE
21947: EQUAL
21948: IFTRUE 21958
21950: LD_INT 21
21952: DOUBLE
21953: EQUAL
21954: IFTRUE 21958
21956: GO 21983
21958: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
21959: LD_ADDR_VAR 0 3
21963: PUSH
21964: LD_INT 21
21966: PPUSH
21967: LD_VAR 0 1
21971: PPUSH
21972: CALL_OW 321
21976: PUSH
21977: LD_INT 2
21979: EQUAL
21980: ST_TO_ADDR
21981: GO 22159
21983: LD_INT 16
21985: DOUBLE
21986: EQUAL
21987: IFTRUE 21991
21989: GO 22018
21991: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
21992: LD_ADDR_VAR 0 3
21996: PUSH
21997: LD_EXP 79
22001: PPUSH
22002: LD_VAR 0 1
22006: PPUSH
22007: CALL_OW 321
22011: PUSH
22012: LD_INT 2
22014: EQUAL
22015: ST_TO_ADDR
22016: GO 22159
22018: LD_INT 19
22020: DOUBLE
22021: EQUAL
22022: IFTRUE 22032
22024: LD_INT 23
22026: DOUBLE
22027: EQUAL
22028: IFTRUE 22032
22030: GO 22059
22032: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
22033: LD_ADDR_VAR 0 3
22037: PUSH
22038: LD_EXP 78
22042: PPUSH
22043: LD_VAR 0 1
22047: PPUSH
22048: CALL_OW 321
22052: PUSH
22053: LD_INT 2
22055: EQUAL
22056: ST_TO_ADDR
22057: GO 22159
22059: LD_INT 17
22061: DOUBLE
22062: EQUAL
22063: IFTRUE 22067
22065: GO 22092
22067: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
22068: LD_ADDR_VAR 0 3
22072: PUSH
22073: LD_INT 39
22075: PPUSH
22076: LD_VAR 0 1
22080: PPUSH
22081: CALL_OW 321
22085: PUSH
22086: LD_INT 2
22088: EQUAL
22089: ST_TO_ADDR
22090: GO 22159
22092: LD_INT 18
22094: DOUBLE
22095: EQUAL
22096: IFTRUE 22100
22098: GO 22125
22100: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
22101: LD_ADDR_VAR 0 3
22105: PUSH
22106: LD_INT 40
22108: PPUSH
22109: LD_VAR 0 1
22113: PPUSH
22114: CALL_OW 321
22118: PUSH
22119: LD_INT 2
22121: EQUAL
22122: ST_TO_ADDR
22123: GO 22159
22125: LD_INT 27
22127: DOUBLE
22128: EQUAL
22129: IFTRUE 22133
22131: GO 22158
22133: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
22134: LD_ADDR_VAR 0 3
22138: PUSH
22139: LD_INT 35
22141: PPUSH
22142: LD_VAR 0 1
22146: PPUSH
22147: CALL_OW 321
22151: PUSH
22152: LD_INT 2
22154: EQUAL
22155: ST_TO_ADDR
22156: GO 22159
22158: POP
// end ;
22159: LD_VAR 0 3
22163: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
22164: LD_INT 0
22166: PPUSH
22167: PPUSH
22168: PPUSH
22169: PPUSH
22170: PPUSH
22171: PPUSH
22172: PPUSH
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
// result := false ;
22177: LD_ADDR_VAR 0 6
22181: PUSH
22182: LD_INT 0
22184: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
22185: LD_VAR 0 1
22189: NOT
22190: PUSH
22191: LD_VAR 0 1
22195: PPUSH
22196: CALL_OW 266
22200: PUSH
22201: LD_INT 0
22203: PUSH
22204: LD_INT 1
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: IN
22211: NOT
22212: OR
22213: PUSH
22214: LD_VAR 0 2
22218: NOT
22219: OR
22220: PUSH
22221: LD_VAR 0 5
22225: PUSH
22226: LD_INT 0
22228: PUSH
22229: LD_INT 1
22231: PUSH
22232: LD_INT 2
22234: PUSH
22235: LD_INT 3
22237: PUSH
22238: LD_INT 4
22240: PUSH
22241: LD_INT 5
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: LIST
22248: LIST
22249: LIST
22250: LIST
22251: IN
22252: NOT
22253: OR
22254: PUSH
22255: LD_VAR 0 3
22259: PPUSH
22260: LD_VAR 0 4
22264: PPUSH
22265: CALL_OW 488
22269: NOT
22270: OR
22271: IFFALSE 22275
// exit ;
22273: GO 23011
// side := GetSide ( depot ) ;
22275: LD_ADDR_VAR 0 9
22279: PUSH
22280: LD_VAR 0 1
22284: PPUSH
22285: CALL_OW 255
22289: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
22290: LD_VAR 0 9
22294: PPUSH
22295: LD_VAR 0 2
22299: PPUSH
22300: CALL 21784 0 2
22304: NOT
22305: IFFALSE 22309
// exit ;
22307: GO 23011
// pom := GetBase ( depot ) ;
22309: LD_ADDR_VAR 0 10
22313: PUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: CALL_OW 274
22323: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
22324: LD_ADDR_VAR 0 11
22328: PUSH
22329: LD_VAR 0 2
22333: PPUSH
22334: LD_VAR 0 1
22338: PPUSH
22339: CALL_OW 248
22343: PPUSH
22344: CALL_OW 450
22348: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
22349: LD_VAR 0 10
22353: PPUSH
22354: LD_INT 1
22356: PPUSH
22357: CALL_OW 275
22361: PUSH
22362: LD_VAR 0 11
22366: PUSH
22367: LD_INT 1
22369: ARRAY
22370: GREATEREQUAL
22371: PUSH
22372: LD_VAR 0 10
22376: PPUSH
22377: LD_INT 2
22379: PPUSH
22380: CALL_OW 275
22384: PUSH
22385: LD_VAR 0 11
22389: PUSH
22390: LD_INT 2
22392: ARRAY
22393: GREATEREQUAL
22394: AND
22395: PUSH
22396: LD_VAR 0 10
22400: PPUSH
22401: LD_INT 3
22403: PPUSH
22404: CALL_OW 275
22408: PUSH
22409: LD_VAR 0 11
22413: PUSH
22414: LD_INT 3
22416: ARRAY
22417: GREATEREQUAL
22418: AND
22419: NOT
22420: IFFALSE 22424
// exit ;
22422: GO 23011
// if GetBType ( depot ) = b_depot then
22424: LD_VAR 0 1
22428: PPUSH
22429: CALL_OW 266
22433: PUSH
22434: LD_INT 0
22436: EQUAL
22437: IFFALSE 22449
// dist := 28 else
22439: LD_ADDR_VAR 0 14
22443: PUSH
22444: LD_INT 28
22446: ST_TO_ADDR
22447: GO 22457
// dist := 36 ;
22449: LD_ADDR_VAR 0 14
22453: PUSH
22454: LD_INT 36
22456: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
22457: LD_VAR 0 1
22461: PPUSH
22462: LD_VAR 0 3
22466: PPUSH
22467: LD_VAR 0 4
22471: PPUSH
22472: CALL_OW 297
22476: PUSH
22477: LD_VAR 0 14
22481: GREATER
22482: IFFALSE 22486
// exit ;
22484: GO 23011
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
22486: LD_ADDR_VAR 0 12
22490: PUSH
22491: LD_VAR 0 2
22495: PPUSH
22496: LD_VAR 0 3
22500: PPUSH
22501: LD_VAR 0 4
22505: PPUSH
22506: LD_VAR 0 5
22510: PPUSH
22511: LD_VAR 0 1
22515: PPUSH
22516: CALL_OW 248
22520: PPUSH
22521: LD_INT 0
22523: PPUSH
22524: CALL 23016 0 6
22528: ST_TO_ADDR
// if not hexes then
22529: LD_VAR 0 12
22533: NOT
22534: IFFALSE 22538
// exit ;
22536: GO 23011
// hex := GetHexInfo ( x , y ) ;
22538: LD_ADDR_VAR 0 15
22542: PUSH
22543: LD_VAR 0 3
22547: PPUSH
22548: LD_VAR 0 4
22552: PPUSH
22553: CALL_OW 546
22557: ST_TO_ADDR
// if hex [ 1 ] then
22558: LD_VAR 0 15
22562: PUSH
22563: LD_INT 1
22565: ARRAY
22566: IFFALSE 22570
// exit ;
22568: GO 23011
// height := hex [ 2 ] ;
22570: LD_ADDR_VAR 0 13
22574: PUSH
22575: LD_VAR 0 15
22579: PUSH
22580: LD_INT 2
22582: ARRAY
22583: ST_TO_ADDR
// for i = 1 to hexes do
22584: LD_ADDR_VAR 0 7
22588: PUSH
22589: DOUBLE
22590: LD_INT 1
22592: DEC
22593: ST_TO_ADDR
22594: LD_VAR 0 12
22598: PUSH
22599: FOR_TO
22600: IFFALSE 22930
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
22602: LD_VAR 0 12
22606: PUSH
22607: LD_VAR 0 7
22611: ARRAY
22612: PUSH
22613: LD_INT 1
22615: ARRAY
22616: PPUSH
22617: LD_VAR 0 12
22621: PUSH
22622: LD_VAR 0 7
22626: ARRAY
22627: PUSH
22628: LD_INT 2
22630: ARRAY
22631: PPUSH
22632: CALL_OW 488
22636: NOT
22637: PUSH
22638: LD_VAR 0 12
22642: PUSH
22643: LD_VAR 0 7
22647: ARRAY
22648: PUSH
22649: LD_INT 1
22651: ARRAY
22652: PPUSH
22653: LD_VAR 0 12
22657: PUSH
22658: LD_VAR 0 7
22662: ARRAY
22663: PUSH
22664: LD_INT 2
22666: ARRAY
22667: PPUSH
22668: CALL_OW 428
22672: PUSH
22673: LD_INT 0
22675: GREATER
22676: OR
22677: PUSH
22678: LD_VAR 0 12
22682: PUSH
22683: LD_VAR 0 7
22687: ARRAY
22688: PUSH
22689: LD_INT 1
22691: ARRAY
22692: PPUSH
22693: LD_VAR 0 12
22697: PUSH
22698: LD_VAR 0 7
22702: ARRAY
22703: PUSH
22704: LD_INT 2
22706: ARRAY
22707: PPUSH
22708: CALL_OW 351
22712: OR
22713: IFFALSE 22719
// exit ;
22715: POP
22716: POP
22717: GO 23011
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
22719: LD_ADDR_VAR 0 8
22723: PUSH
22724: LD_VAR 0 12
22728: PUSH
22729: LD_VAR 0 7
22733: ARRAY
22734: PUSH
22735: LD_INT 1
22737: ARRAY
22738: PPUSH
22739: LD_VAR 0 12
22743: PUSH
22744: LD_VAR 0 7
22748: ARRAY
22749: PUSH
22750: LD_INT 2
22752: ARRAY
22753: PPUSH
22754: CALL_OW 546
22758: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
22759: LD_VAR 0 8
22763: PUSH
22764: LD_INT 1
22766: ARRAY
22767: PUSH
22768: LD_VAR 0 8
22772: PUSH
22773: LD_INT 2
22775: ARRAY
22776: PUSH
22777: LD_VAR 0 13
22781: PUSH
22782: LD_INT 2
22784: PLUS
22785: GREATER
22786: OR
22787: PUSH
22788: LD_VAR 0 8
22792: PUSH
22793: LD_INT 2
22795: ARRAY
22796: PUSH
22797: LD_VAR 0 13
22801: PUSH
22802: LD_INT 2
22804: MINUS
22805: LESS
22806: OR
22807: PUSH
22808: LD_VAR 0 8
22812: PUSH
22813: LD_INT 3
22815: ARRAY
22816: PUSH
22817: LD_INT 0
22819: PUSH
22820: LD_INT 8
22822: PUSH
22823: LD_INT 9
22825: PUSH
22826: LD_INT 10
22828: PUSH
22829: LD_INT 11
22831: PUSH
22832: LD_INT 12
22834: PUSH
22835: LD_INT 13
22837: PUSH
22838: LD_INT 16
22840: PUSH
22841: LD_INT 17
22843: PUSH
22844: LD_INT 18
22846: PUSH
22847: LD_INT 19
22849: PUSH
22850: LD_INT 20
22852: PUSH
22853: LD_INT 21
22855: PUSH
22856: EMPTY
22857: LIST
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: LIST
22865: LIST
22866: LIST
22867: LIST
22868: LIST
22869: LIST
22870: IN
22871: NOT
22872: OR
22873: PUSH
22874: LD_VAR 0 8
22878: PUSH
22879: LD_INT 5
22881: ARRAY
22882: NOT
22883: OR
22884: PUSH
22885: LD_VAR 0 8
22889: PUSH
22890: LD_INT 6
22892: ARRAY
22893: PUSH
22894: LD_INT 1
22896: PUSH
22897: LD_INT 2
22899: PUSH
22900: LD_INT 7
22902: PUSH
22903: LD_INT 9
22905: PUSH
22906: LD_INT 10
22908: PUSH
22909: LD_INT 11
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: LIST
22918: LIST
22919: IN
22920: NOT
22921: OR
22922: IFFALSE 22928
// exit ;
22924: POP
22925: POP
22926: GO 23011
// end ;
22928: GO 22599
22930: POP
22931: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
22932: LD_VAR 0 9
22936: PPUSH
22937: LD_VAR 0 3
22941: PPUSH
22942: LD_VAR 0 4
22946: PPUSH
22947: LD_INT 20
22949: PPUSH
22950: CALL 14956 0 4
22954: PUSH
22955: LD_INT 4
22957: ARRAY
22958: IFFALSE 22962
// exit ;
22960: GO 23011
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
22962: LD_VAR 0 2
22966: PUSH
22967: LD_INT 29
22969: PUSH
22970: LD_INT 30
22972: PUSH
22973: EMPTY
22974: LIST
22975: LIST
22976: IN
22977: PUSH
22978: LD_VAR 0 3
22982: PPUSH
22983: LD_VAR 0 4
22987: PPUSH
22988: LD_VAR 0 9
22992: PPUSH
22993: CALL_OW 440
22997: NOT
22998: AND
22999: IFFALSE 23003
// exit ;
23001: GO 23011
// result := true ;
23003: LD_ADDR_VAR 0 6
23007: PUSH
23008: LD_INT 1
23010: ST_TO_ADDR
// end ;
23011: LD_VAR 0 6
23015: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
23016: LD_INT 0
23018: PPUSH
23019: PPUSH
23020: PPUSH
23021: PPUSH
23022: PPUSH
23023: PPUSH
23024: PPUSH
23025: PPUSH
23026: PPUSH
23027: PPUSH
23028: PPUSH
23029: PPUSH
23030: PPUSH
23031: PPUSH
23032: PPUSH
23033: PPUSH
23034: PPUSH
23035: PPUSH
23036: PPUSH
23037: PPUSH
23038: PPUSH
23039: PPUSH
23040: PPUSH
23041: PPUSH
23042: PPUSH
23043: PPUSH
23044: PPUSH
23045: PPUSH
23046: PPUSH
23047: PPUSH
23048: PPUSH
23049: PPUSH
23050: PPUSH
23051: PPUSH
23052: PPUSH
23053: PPUSH
23054: PPUSH
23055: PPUSH
23056: PPUSH
23057: PPUSH
23058: PPUSH
23059: PPUSH
23060: PPUSH
23061: PPUSH
23062: PPUSH
23063: PPUSH
23064: PPUSH
23065: PPUSH
23066: PPUSH
23067: PPUSH
23068: PPUSH
23069: PPUSH
23070: PPUSH
23071: PPUSH
23072: PPUSH
23073: PPUSH
23074: PPUSH
23075: PPUSH
// result = [ ] ;
23076: LD_ADDR_VAR 0 7
23080: PUSH
23081: EMPTY
23082: ST_TO_ADDR
// temp_list = [ ] ;
23083: LD_ADDR_VAR 0 9
23087: PUSH
23088: EMPTY
23089: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
23090: LD_VAR 0 4
23094: PUSH
23095: LD_INT 0
23097: PUSH
23098: LD_INT 1
23100: PUSH
23101: LD_INT 2
23103: PUSH
23104: LD_INT 3
23106: PUSH
23107: LD_INT 4
23109: PUSH
23110: LD_INT 5
23112: PUSH
23113: EMPTY
23114: LIST
23115: LIST
23116: LIST
23117: LIST
23118: LIST
23119: LIST
23120: IN
23121: NOT
23122: PUSH
23123: LD_VAR 0 1
23127: PUSH
23128: LD_INT 0
23130: PUSH
23131: LD_INT 1
23133: PUSH
23134: EMPTY
23135: LIST
23136: LIST
23137: IN
23138: PUSH
23139: LD_VAR 0 5
23143: PUSH
23144: LD_INT 1
23146: PUSH
23147: LD_INT 2
23149: PUSH
23150: LD_INT 3
23152: PUSH
23153: EMPTY
23154: LIST
23155: LIST
23156: LIST
23157: IN
23158: NOT
23159: AND
23160: OR
23161: IFFALSE 23165
// exit ;
23163: GO 41556
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
23165: LD_VAR 0 1
23169: PUSH
23170: LD_INT 6
23172: PUSH
23173: LD_INT 7
23175: PUSH
23176: LD_INT 8
23178: PUSH
23179: LD_INT 13
23181: PUSH
23182: LD_INT 12
23184: PUSH
23185: LD_INT 15
23187: PUSH
23188: LD_INT 11
23190: PUSH
23191: LD_INT 14
23193: PUSH
23194: LD_INT 10
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: LIST
23201: LIST
23202: LIST
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: IN
23208: IFFALSE 23218
// btype = b_lab ;
23210: LD_ADDR_VAR 0 1
23214: PUSH
23215: LD_INT 6
23217: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
23218: LD_VAR 0 6
23222: PUSH
23223: LD_INT 0
23225: PUSH
23226: LD_INT 1
23228: PUSH
23229: LD_INT 2
23231: PUSH
23232: EMPTY
23233: LIST
23234: LIST
23235: LIST
23236: IN
23237: NOT
23238: PUSH
23239: LD_VAR 0 1
23243: PUSH
23244: LD_INT 0
23246: PUSH
23247: LD_INT 1
23249: PUSH
23250: LD_INT 2
23252: PUSH
23253: LD_INT 3
23255: PUSH
23256: LD_INT 6
23258: PUSH
23259: LD_INT 36
23261: PUSH
23262: LD_INT 4
23264: PUSH
23265: LD_INT 5
23267: PUSH
23268: LD_INT 31
23270: PUSH
23271: LD_INT 32
23273: PUSH
23274: LD_INT 33
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: LIST
23281: LIST
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: LIST
23287: LIST
23288: LIST
23289: IN
23290: NOT
23291: PUSH
23292: LD_VAR 0 6
23296: PUSH
23297: LD_INT 1
23299: EQUAL
23300: AND
23301: OR
23302: PUSH
23303: LD_VAR 0 1
23307: PUSH
23308: LD_INT 2
23310: PUSH
23311: LD_INT 3
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: IN
23318: NOT
23319: PUSH
23320: LD_VAR 0 6
23324: PUSH
23325: LD_INT 2
23327: EQUAL
23328: AND
23329: OR
23330: IFFALSE 23340
// mode = 0 ;
23332: LD_ADDR_VAR 0 6
23336: PUSH
23337: LD_INT 0
23339: ST_TO_ADDR
// case mode of 0 :
23340: LD_VAR 0 6
23344: PUSH
23345: LD_INT 0
23347: DOUBLE
23348: EQUAL
23349: IFTRUE 23353
23351: GO 34806
23353: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
23354: LD_ADDR_VAR 0 11
23358: PUSH
23359: LD_INT 0
23361: PUSH
23362: LD_INT 0
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: PUSH
23369: LD_INT 0
23371: PUSH
23372: LD_INT 1
23374: NEG
23375: PUSH
23376: EMPTY
23377: LIST
23378: LIST
23379: PUSH
23380: LD_INT 1
23382: PUSH
23383: LD_INT 0
23385: PUSH
23386: EMPTY
23387: LIST
23388: LIST
23389: PUSH
23390: LD_INT 1
23392: PUSH
23393: LD_INT 1
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: PUSH
23400: LD_INT 0
23402: PUSH
23403: LD_INT 1
23405: PUSH
23406: EMPTY
23407: LIST
23408: LIST
23409: PUSH
23410: LD_INT 1
23412: NEG
23413: PUSH
23414: LD_INT 0
23416: PUSH
23417: EMPTY
23418: LIST
23419: LIST
23420: PUSH
23421: LD_INT 1
23423: NEG
23424: PUSH
23425: LD_INT 1
23427: NEG
23428: PUSH
23429: EMPTY
23430: LIST
23431: LIST
23432: PUSH
23433: LD_INT 1
23435: NEG
23436: PUSH
23437: LD_INT 2
23439: NEG
23440: PUSH
23441: EMPTY
23442: LIST
23443: LIST
23444: PUSH
23445: LD_INT 0
23447: PUSH
23448: LD_INT 2
23450: NEG
23451: PUSH
23452: EMPTY
23453: LIST
23454: LIST
23455: PUSH
23456: LD_INT 1
23458: PUSH
23459: LD_INT 1
23461: NEG
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: PUSH
23467: LD_INT 1
23469: PUSH
23470: LD_INT 2
23472: PUSH
23473: EMPTY
23474: LIST
23475: LIST
23476: PUSH
23477: LD_INT 0
23479: PUSH
23480: LD_INT 2
23482: PUSH
23483: EMPTY
23484: LIST
23485: LIST
23486: PUSH
23487: LD_INT 1
23489: NEG
23490: PUSH
23491: LD_INT 1
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: PUSH
23498: LD_INT 1
23500: PUSH
23501: LD_INT 3
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 0
23510: PUSH
23511: LD_INT 3
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: PUSH
23518: LD_INT 1
23520: NEG
23521: PUSH
23522: LD_INT 2
23524: PUSH
23525: EMPTY
23526: LIST
23527: LIST
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: LIST
23533: LIST
23534: LIST
23535: LIST
23536: LIST
23537: LIST
23538: LIST
23539: LIST
23540: LIST
23541: LIST
23542: LIST
23543: LIST
23544: LIST
23545: LIST
23546: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
23547: LD_ADDR_VAR 0 12
23551: PUSH
23552: LD_INT 0
23554: PUSH
23555: LD_INT 0
23557: PUSH
23558: EMPTY
23559: LIST
23560: LIST
23561: PUSH
23562: LD_INT 0
23564: PUSH
23565: LD_INT 1
23567: NEG
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PUSH
23573: LD_INT 1
23575: PUSH
23576: LD_INT 0
23578: PUSH
23579: EMPTY
23580: LIST
23581: LIST
23582: PUSH
23583: LD_INT 1
23585: PUSH
23586: LD_INT 1
23588: PUSH
23589: EMPTY
23590: LIST
23591: LIST
23592: PUSH
23593: LD_INT 0
23595: PUSH
23596: LD_INT 1
23598: PUSH
23599: EMPTY
23600: LIST
23601: LIST
23602: PUSH
23603: LD_INT 1
23605: NEG
23606: PUSH
23607: LD_INT 0
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: PUSH
23614: LD_INT 1
23616: NEG
23617: PUSH
23618: LD_INT 1
23620: NEG
23621: PUSH
23622: EMPTY
23623: LIST
23624: LIST
23625: PUSH
23626: LD_INT 1
23628: PUSH
23629: LD_INT 1
23631: NEG
23632: PUSH
23633: EMPTY
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 2
23639: PUSH
23640: LD_INT 0
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 2
23649: PUSH
23650: LD_INT 1
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 1
23659: NEG
23660: PUSH
23661: LD_INT 1
23663: PUSH
23664: EMPTY
23665: LIST
23666: LIST
23667: PUSH
23668: LD_INT 2
23670: NEG
23671: PUSH
23672: LD_INT 0
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: PUSH
23679: LD_INT 2
23681: NEG
23682: PUSH
23683: LD_INT 1
23685: NEG
23686: PUSH
23687: EMPTY
23688: LIST
23689: LIST
23690: PUSH
23691: LD_INT 2
23693: NEG
23694: PUSH
23695: LD_INT 1
23697: PUSH
23698: EMPTY
23699: LIST
23700: LIST
23701: PUSH
23702: LD_INT 3
23704: NEG
23705: PUSH
23706: LD_INT 0
23708: PUSH
23709: EMPTY
23710: LIST
23711: LIST
23712: PUSH
23713: LD_INT 3
23715: NEG
23716: PUSH
23717: LD_INT 1
23719: NEG
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: EMPTY
23726: LIST
23727: LIST
23728: LIST
23729: LIST
23730: LIST
23731: LIST
23732: LIST
23733: LIST
23734: LIST
23735: LIST
23736: LIST
23737: LIST
23738: LIST
23739: LIST
23740: LIST
23741: LIST
23742: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
23743: LD_ADDR_VAR 0 13
23747: PUSH
23748: LD_INT 0
23750: PUSH
23751: LD_INT 0
23753: PUSH
23754: EMPTY
23755: LIST
23756: LIST
23757: PUSH
23758: LD_INT 0
23760: PUSH
23761: LD_INT 1
23763: NEG
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 1
23771: PUSH
23772: LD_INT 0
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: LD_INT 1
23781: PUSH
23782: LD_INT 1
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: PUSH
23789: LD_INT 0
23791: PUSH
23792: LD_INT 1
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 1
23801: NEG
23802: PUSH
23803: LD_INT 0
23805: PUSH
23806: EMPTY
23807: LIST
23808: LIST
23809: PUSH
23810: LD_INT 1
23812: NEG
23813: PUSH
23814: LD_INT 1
23816: NEG
23817: PUSH
23818: EMPTY
23819: LIST
23820: LIST
23821: PUSH
23822: LD_INT 1
23824: NEG
23825: PUSH
23826: LD_INT 2
23828: NEG
23829: PUSH
23830: EMPTY
23831: LIST
23832: LIST
23833: PUSH
23834: LD_INT 2
23836: PUSH
23837: LD_INT 1
23839: PUSH
23840: EMPTY
23841: LIST
23842: LIST
23843: PUSH
23844: LD_INT 2
23846: PUSH
23847: LD_INT 2
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: PUSH
23854: LD_INT 1
23856: PUSH
23857: LD_INT 2
23859: PUSH
23860: EMPTY
23861: LIST
23862: LIST
23863: PUSH
23864: LD_INT 2
23866: NEG
23867: PUSH
23868: LD_INT 1
23870: NEG
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: LD_INT 2
23878: NEG
23879: PUSH
23880: LD_INT 2
23882: NEG
23883: PUSH
23884: EMPTY
23885: LIST
23886: LIST
23887: PUSH
23888: LD_INT 2
23890: NEG
23891: PUSH
23892: LD_INT 3
23894: NEG
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 3
23902: NEG
23903: PUSH
23904: LD_INT 2
23906: NEG
23907: PUSH
23908: EMPTY
23909: LIST
23910: LIST
23911: PUSH
23912: LD_INT 3
23914: NEG
23915: PUSH
23916: LD_INT 3
23918: NEG
23919: PUSH
23920: EMPTY
23921: LIST
23922: LIST
23923: PUSH
23924: EMPTY
23925: LIST
23926: LIST
23927: LIST
23928: LIST
23929: LIST
23930: LIST
23931: LIST
23932: LIST
23933: LIST
23934: LIST
23935: LIST
23936: LIST
23937: LIST
23938: LIST
23939: LIST
23940: LIST
23941: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
23942: LD_ADDR_VAR 0 14
23946: PUSH
23947: LD_INT 0
23949: PUSH
23950: LD_INT 0
23952: PUSH
23953: EMPTY
23954: LIST
23955: LIST
23956: PUSH
23957: LD_INT 0
23959: PUSH
23960: LD_INT 1
23962: NEG
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: LD_INT 1
23970: PUSH
23971: LD_INT 0
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PUSH
23978: LD_INT 1
23980: PUSH
23981: LD_INT 1
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: LD_INT 0
23990: PUSH
23991: LD_INT 1
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: PUSH
23998: LD_INT 1
24000: NEG
24001: PUSH
24002: LD_INT 0
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PUSH
24009: LD_INT 1
24011: NEG
24012: PUSH
24013: LD_INT 1
24015: NEG
24016: PUSH
24017: EMPTY
24018: LIST
24019: LIST
24020: PUSH
24021: LD_INT 1
24023: NEG
24024: PUSH
24025: LD_INT 2
24027: NEG
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: PUSH
24033: LD_INT 0
24035: PUSH
24036: LD_INT 2
24038: NEG
24039: PUSH
24040: EMPTY
24041: LIST
24042: LIST
24043: PUSH
24044: LD_INT 1
24046: PUSH
24047: LD_INT 1
24049: NEG
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 1
24057: PUSH
24058: LD_INT 2
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: LD_INT 0
24067: PUSH
24068: LD_INT 2
24070: PUSH
24071: EMPTY
24072: LIST
24073: LIST
24074: PUSH
24075: LD_INT 1
24077: NEG
24078: PUSH
24079: LD_INT 1
24081: PUSH
24082: EMPTY
24083: LIST
24084: LIST
24085: PUSH
24086: LD_INT 1
24088: NEG
24089: PUSH
24090: LD_INT 3
24092: NEG
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: LD_INT 0
24100: PUSH
24101: LD_INT 3
24103: NEG
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: PUSH
24109: LD_INT 1
24111: PUSH
24112: LD_INT 2
24114: NEG
24115: PUSH
24116: EMPTY
24117: LIST
24118: LIST
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: LIST
24124: LIST
24125: LIST
24126: LIST
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: LIST
24132: LIST
24133: LIST
24134: LIST
24135: LIST
24136: LIST
24137: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
24138: LD_ADDR_VAR 0 15
24142: PUSH
24143: LD_INT 0
24145: PUSH
24146: LD_INT 0
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: PUSH
24153: LD_INT 0
24155: PUSH
24156: LD_INT 1
24158: NEG
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: LD_INT 1
24166: PUSH
24167: LD_INT 0
24169: PUSH
24170: EMPTY
24171: LIST
24172: LIST
24173: PUSH
24174: LD_INT 1
24176: PUSH
24177: LD_INT 1
24179: PUSH
24180: EMPTY
24181: LIST
24182: LIST
24183: PUSH
24184: LD_INT 0
24186: PUSH
24187: LD_INT 1
24189: PUSH
24190: EMPTY
24191: LIST
24192: LIST
24193: PUSH
24194: LD_INT 1
24196: NEG
24197: PUSH
24198: LD_INT 0
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: PUSH
24205: LD_INT 1
24207: NEG
24208: PUSH
24209: LD_INT 1
24211: NEG
24212: PUSH
24213: EMPTY
24214: LIST
24215: LIST
24216: PUSH
24217: LD_INT 1
24219: PUSH
24220: LD_INT 1
24222: NEG
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: PUSH
24228: LD_INT 2
24230: PUSH
24231: LD_INT 0
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: PUSH
24238: LD_INT 2
24240: PUSH
24241: LD_INT 1
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: LD_INT 1
24250: NEG
24251: PUSH
24252: LD_INT 1
24254: PUSH
24255: EMPTY
24256: LIST
24257: LIST
24258: PUSH
24259: LD_INT 2
24261: NEG
24262: PUSH
24263: LD_INT 0
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: LD_INT 2
24272: NEG
24273: PUSH
24274: LD_INT 1
24276: NEG
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 2
24284: PUSH
24285: LD_INT 1
24287: NEG
24288: PUSH
24289: EMPTY
24290: LIST
24291: LIST
24292: PUSH
24293: LD_INT 3
24295: PUSH
24296: LD_INT 0
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PUSH
24303: LD_INT 3
24305: PUSH
24306: LD_INT 1
24308: PUSH
24309: EMPTY
24310: LIST
24311: LIST
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: LIST
24317: LIST
24318: LIST
24319: LIST
24320: LIST
24321: LIST
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: LIST
24327: LIST
24328: LIST
24329: LIST
24330: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
24331: LD_ADDR_VAR 0 16
24335: PUSH
24336: LD_INT 0
24338: PUSH
24339: LD_INT 0
24341: PUSH
24342: EMPTY
24343: LIST
24344: LIST
24345: PUSH
24346: LD_INT 0
24348: PUSH
24349: LD_INT 1
24351: NEG
24352: PUSH
24353: EMPTY
24354: LIST
24355: LIST
24356: PUSH
24357: LD_INT 1
24359: PUSH
24360: LD_INT 0
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PUSH
24367: LD_INT 1
24369: PUSH
24370: LD_INT 1
24372: PUSH
24373: EMPTY
24374: LIST
24375: LIST
24376: PUSH
24377: LD_INT 0
24379: PUSH
24380: LD_INT 1
24382: PUSH
24383: EMPTY
24384: LIST
24385: LIST
24386: PUSH
24387: LD_INT 1
24389: NEG
24390: PUSH
24391: LD_INT 0
24393: PUSH
24394: EMPTY
24395: LIST
24396: LIST
24397: PUSH
24398: LD_INT 1
24400: NEG
24401: PUSH
24402: LD_INT 1
24404: NEG
24405: PUSH
24406: EMPTY
24407: LIST
24408: LIST
24409: PUSH
24410: LD_INT 1
24412: NEG
24413: PUSH
24414: LD_INT 2
24416: NEG
24417: PUSH
24418: EMPTY
24419: LIST
24420: LIST
24421: PUSH
24422: LD_INT 2
24424: PUSH
24425: LD_INT 1
24427: PUSH
24428: EMPTY
24429: LIST
24430: LIST
24431: PUSH
24432: LD_INT 2
24434: PUSH
24435: LD_INT 2
24437: PUSH
24438: EMPTY
24439: LIST
24440: LIST
24441: PUSH
24442: LD_INT 1
24444: PUSH
24445: LD_INT 2
24447: PUSH
24448: EMPTY
24449: LIST
24450: LIST
24451: PUSH
24452: LD_INT 2
24454: NEG
24455: PUSH
24456: LD_INT 1
24458: NEG
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: PUSH
24464: LD_INT 2
24466: NEG
24467: PUSH
24468: LD_INT 2
24470: NEG
24471: PUSH
24472: EMPTY
24473: LIST
24474: LIST
24475: PUSH
24476: LD_INT 3
24478: PUSH
24479: LD_INT 2
24481: PUSH
24482: EMPTY
24483: LIST
24484: LIST
24485: PUSH
24486: LD_INT 3
24488: PUSH
24489: LD_INT 3
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PUSH
24496: LD_INT 2
24498: PUSH
24499: LD_INT 3
24501: PUSH
24502: EMPTY
24503: LIST
24504: LIST
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: LIST
24513: LIST
24514: LIST
24515: LIST
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: LIST
24521: LIST
24522: LIST
24523: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24524: LD_ADDR_VAR 0 17
24528: PUSH
24529: LD_INT 0
24531: PUSH
24532: LD_INT 0
24534: PUSH
24535: EMPTY
24536: LIST
24537: LIST
24538: PUSH
24539: LD_INT 0
24541: PUSH
24542: LD_INT 1
24544: NEG
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: PUSH
24550: LD_INT 1
24552: PUSH
24553: LD_INT 0
24555: PUSH
24556: EMPTY
24557: LIST
24558: LIST
24559: PUSH
24560: LD_INT 1
24562: PUSH
24563: LD_INT 1
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: PUSH
24570: LD_INT 0
24572: PUSH
24573: LD_INT 1
24575: PUSH
24576: EMPTY
24577: LIST
24578: LIST
24579: PUSH
24580: LD_INT 1
24582: NEG
24583: PUSH
24584: LD_INT 0
24586: PUSH
24587: EMPTY
24588: LIST
24589: LIST
24590: PUSH
24591: LD_INT 1
24593: NEG
24594: PUSH
24595: LD_INT 1
24597: NEG
24598: PUSH
24599: EMPTY
24600: LIST
24601: LIST
24602: PUSH
24603: LD_INT 1
24605: NEG
24606: PUSH
24607: LD_INT 2
24609: NEG
24610: PUSH
24611: EMPTY
24612: LIST
24613: LIST
24614: PUSH
24615: LD_INT 0
24617: PUSH
24618: LD_INT 2
24620: NEG
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 1
24628: PUSH
24629: LD_INT 1
24631: NEG
24632: PUSH
24633: EMPTY
24634: LIST
24635: LIST
24636: PUSH
24637: LD_INT 2
24639: PUSH
24640: LD_INT 0
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: PUSH
24647: LD_INT 2
24649: PUSH
24650: LD_INT 1
24652: PUSH
24653: EMPTY
24654: LIST
24655: LIST
24656: PUSH
24657: LD_INT 2
24659: PUSH
24660: LD_INT 2
24662: PUSH
24663: EMPTY
24664: LIST
24665: LIST
24666: PUSH
24667: LD_INT 1
24669: PUSH
24670: LD_INT 2
24672: PUSH
24673: EMPTY
24674: LIST
24675: LIST
24676: PUSH
24677: LD_INT 0
24679: PUSH
24680: LD_INT 2
24682: PUSH
24683: EMPTY
24684: LIST
24685: LIST
24686: PUSH
24687: LD_INT 1
24689: NEG
24690: PUSH
24691: LD_INT 1
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: PUSH
24698: LD_INT 2
24700: NEG
24701: PUSH
24702: LD_INT 0
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: PUSH
24709: LD_INT 2
24711: NEG
24712: PUSH
24713: LD_INT 1
24715: NEG
24716: PUSH
24717: EMPTY
24718: LIST
24719: LIST
24720: PUSH
24721: LD_INT 2
24723: NEG
24724: PUSH
24725: LD_INT 2
24727: NEG
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PUSH
24733: EMPTY
24734: LIST
24735: LIST
24736: LIST
24737: LIST
24738: LIST
24739: LIST
24740: LIST
24741: LIST
24742: LIST
24743: LIST
24744: LIST
24745: LIST
24746: LIST
24747: LIST
24748: LIST
24749: LIST
24750: LIST
24751: LIST
24752: LIST
24753: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24754: LD_ADDR_VAR 0 18
24758: PUSH
24759: LD_INT 0
24761: PUSH
24762: LD_INT 0
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: PUSH
24769: LD_INT 0
24771: PUSH
24772: LD_INT 1
24774: NEG
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: PUSH
24780: LD_INT 1
24782: PUSH
24783: LD_INT 0
24785: PUSH
24786: EMPTY
24787: LIST
24788: LIST
24789: PUSH
24790: LD_INT 1
24792: PUSH
24793: LD_INT 1
24795: PUSH
24796: EMPTY
24797: LIST
24798: LIST
24799: PUSH
24800: LD_INT 0
24802: PUSH
24803: LD_INT 1
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: LD_INT 1
24812: NEG
24813: PUSH
24814: LD_INT 0
24816: PUSH
24817: EMPTY
24818: LIST
24819: LIST
24820: PUSH
24821: LD_INT 1
24823: NEG
24824: PUSH
24825: LD_INT 1
24827: NEG
24828: PUSH
24829: EMPTY
24830: LIST
24831: LIST
24832: PUSH
24833: LD_INT 1
24835: NEG
24836: PUSH
24837: LD_INT 2
24839: NEG
24840: PUSH
24841: EMPTY
24842: LIST
24843: LIST
24844: PUSH
24845: LD_INT 0
24847: PUSH
24848: LD_INT 2
24850: NEG
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 1
24858: PUSH
24859: LD_INT 1
24861: NEG
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: PUSH
24867: LD_INT 2
24869: PUSH
24870: LD_INT 0
24872: PUSH
24873: EMPTY
24874: LIST
24875: LIST
24876: PUSH
24877: LD_INT 2
24879: PUSH
24880: LD_INT 1
24882: PUSH
24883: EMPTY
24884: LIST
24885: LIST
24886: PUSH
24887: LD_INT 2
24889: PUSH
24890: LD_INT 2
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: PUSH
24897: LD_INT 1
24899: PUSH
24900: LD_INT 2
24902: PUSH
24903: EMPTY
24904: LIST
24905: LIST
24906: PUSH
24907: LD_INT 0
24909: PUSH
24910: LD_INT 2
24912: PUSH
24913: EMPTY
24914: LIST
24915: LIST
24916: PUSH
24917: LD_INT 1
24919: NEG
24920: PUSH
24921: LD_INT 1
24923: PUSH
24924: EMPTY
24925: LIST
24926: LIST
24927: PUSH
24928: LD_INT 2
24930: NEG
24931: PUSH
24932: LD_INT 0
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: LD_INT 2
24941: NEG
24942: PUSH
24943: LD_INT 1
24945: NEG
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PUSH
24951: LD_INT 2
24953: NEG
24954: PUSH
24955: LD_INT 2
24957: NEG
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: PUSH
24963: EMPTY
24964: LIST
24965: LIST
24966: LIST
24967: LIST
24968: LIST
24969: LIST
24970: LIST
24971: LIST
24972: LIST
24973: LIST
24974: LIST
24975: LIST
24976: LIST
24977: LIST
24978: LIST
24979: LIST
24980: LIST
24981: LIST
24982: LIST
24983: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
24984: LD_ADDR_VAR 0 19
24988: PUSH
24989: LD_INT 0
24991: PUSH
24992: LD_INT 0
24994: PUSH
24995: EMPTY
24996: LIST
24997: LIST
24998: PUSH
24999: LD_INT 0
25001: PUSH
25002: LD_INT 1
25004: NEG
25005: PUSH
25006: EMPTY
25007: LIST
25008: LIST
25009: PUSH
25010: LD_INT 1
25012: PUSH
25013: LD_INT 0
25015: PUSH
25016: EMPTY
25017: LIST
25018: LIST
25019: PUSH
25020: LD_INT 1
25022: PUSH
25023: LD_INT 1
25025: PUSH
25026: EMPTY
25027: LIST
25028: LIST
25029: PUSH
25030: LD_INT 0
25032: PUSH
25033: LD_INT 1
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: PUSH
25040: LD_INT 1
25042: NEG
25043: PUSH
25044: LD_INT 0
25046: PUSH
25047: EMPTY
25048: LIST
25049: LIST
25050: PUSH
25051: LD_INT 1
25053: NEG
25054: PUSH
25055: LD_INT 1
25057: NEG
25058: PUSH
25059: EMPTY
25060: LIST
25061: LIST
25062: PUSH
25063: LD_INT 1
25065: NEG
25066: PUSH
25067: LD_INT 2
25069: NEG
25070: PUSH
25071: EMPTY
25072: LIST
25073: LIST
25074: PUSH
25075: LD_INT 0
25077: PUSH
25078: LD_INT 2
25080: NEG
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: LD_INT 1
25088: PUSH
25089: LD_INT 1
25091: NEG
25092: PUSH
25093: EMPTY
25094: LIST
25095: LIST
25096: PUSH
25097: LD_INT 2
25099: PUSH
25100: LD_INT 0
25102: PUSH
25103: EMPTY
25104: LIST
25105: LIST
25106: PUSH
25107: LD_INT 2
25109: PUSH
25110: LD_INT 1
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: PUSH
25117: LD_INT 2
25119: PUSH
25120: LD_INT 2
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PUSH
25127: LD_INT 1
25129: PUSH
25130: LD_INT 2
25132: PUSH
25133: EMPTY
25134: LIST
25135: LIST
25136: PUSH
25137: LD_INT 0
25139: PUSH
25140: LD_INT 2
25142: PUSH
25143: EMPTY
25144: LIST
25145: LIST
25146: PUSH
25147: LD_INT 1
25149: NEG
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: LD_INT 2
25160: NEG
25161: PUSH
25162: LD_INT 0
25164: PUSH
25165: EMPTY
25166: LIST
25167: LIST
25168: PUSH
25169: LD_INT 2
25171: NEG
25172: PUSH
25173: LD_INT 1
25175: NEG
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: PUSH
25181: LD_INT 2
25183: NEG
25184: PUSH
25185: LD_INT 2
25187: NEG
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: EMPTY
25194: LIST
25195: LIST
25196: LIST
25197: LIST
25198: LIST
25199: LIST
25200: LIST
25201: LIST
25202: LIST
25203: LIST
25204: LIST
25205: LIST
25206: LIST
25207: LIST
25208: LIST
25209: LIST
25210: LIST
25211: LIST
25212: LIST
25213: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25214: LD_ADDR_VAR 0 20
25218: PUSH
25219: LD_INT 0
25221: PUSH
25222: LD_INT 0
25224: PUSH
25225: EMPTY
25226: LIST
25227: LIST
25228: PUSH
25229: LD_INT 0
25231: PUSH
25232: LD_INT 1
25234: NEG
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: LD_INT 1
25242: PUSH
25243: LD_INT 0
25245: PUSH
25246: EMPTY
25247: LIST
25248: LIST
25249: PUSH
25250: LD_INT 1
25252: PUSH
25253: LD_INT 1
25255: PUSH
25256: EMPTY
25257: LIST
25258: LIST
25259: PUSH
25260: LD_INT 0
25262: PUSH
25263: LD_INT 1
25265: PUSH
25266: EMPTY
25267: LIST
25268: LIST
25269: PUSH
25270: LD_INT 1
25272: NEG
25273: PUSH
25274: LD_INT 0
25276: PUSH
25277: EMPTY
25278: LIST
25279: LIST
25280: PUSH
25281: LD_INT 1
25283: NEG
25284: PUSH
25285: LD_INT 1
25287: NEG
25288: PUSH
25289: EMPTY
25290: LIST
25291: LIST
25292: PUSH
25293: LD_INT 1
25295: NEG
25296: PUSH
25297: LD_INT 2
25299: NEG
25300: PUSH
25301: EMPTY
25302: LIST
25303: LIST
25304: PUSH
25305: LD_INT 0
25307: PUSH
25308: LD_INT 2
25310: NEG
25311: PUSH
25312: EMPTY
25313: LIST
25314: LIST
25315: PUSH
25316: LD_INT 1
25318: PUSH
25319: LD_INT 1
25321: NEG
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: PUSH
25327: LD_INT 2
25329: PUSH
25330: LD_INT 0
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 2
25339: PUSH
25340: LD_INT 1
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: PUSH
25347: LD_INT 2
25349: PUSH
25350: LD_INT 2
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: PUSH
25357: LD_INT 1
25359: PUSH
25360: LD_INT 2
25362: PUSH
25363: EMPTY
25364: LIST
25365: LIST
25366: PUSH
25367: LD_INT 0
25369: PUSH
25370: LD_INT 2
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: PUSH
25377: LD_INT 1
25379: NEG
25380: PUSH
25381: LD_INT 1
25383: PUSH
25384: EMPTY
25385: LIST
25386: LIST
25387: PUSH
25388: LD_INT 2
25390: NEG
25391: PUSH
25392: LD_INT 0
25394: PUSH
25395: EMPTY
25396: LIST
25397: LIST
25398: PUSH
25399: LD_INT 2
25401: NEG
25402: PUSH
25403: LD_INT 1
25405: NEG
25406: PUSH
25407: EMPTY
25408: LIST
25409: LIST
25410: PUSH
25411: LD_INT 2
25413: NEG
25414: PUSH
25415: LD_INT 2
25417: NEG
25418: PUSH
25419: EMPTY
25420: LIST
25421: LIST
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: LIST
25427: LIST
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: LIST
25443: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25444: LD_ADDR_VAR 0 21
25448: PUSH
25449: LD_INT 0
25451: PUSH
25452: LD_INT 0
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: PUSH
25459: LD_INT 0
25461: PUSH
25462: LD_INT 1
25464: NEG
25465: PUSH
25466: EMPTY
25467: LIST
25468: LIST
25469: PUSH
25470: LD_INT 1
25472: PUSH
25473: LD_INT 0
25475: PUSH
25476: EMPTY
25477: LIST
25478: LIST
25479: PUSH
25480: LD_INT 1
25482: PUSH
25483: LD_INT 1
25485: PUSH
25486: EMPTY
25487: LIST
25488: LIST
25489: PUSH
25490: LD_INT 0
25492: PUSH
25493: LD_INT 1
25495: PUSH
25496: EMPTY
25497: LIST
25498: LIST
25499: PUSH
25500: LD_INT 1
25502: NEG
25503: PUSH
25504: LD_INT 0
25506: PUSH
25507: EMPTY
25508: LIST
25509: LIST
25510: PUSH
25511: LD_INT 1
25513: NEG
25514: PUSH
25515: LD_INT 1
25517: NEG
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: PUSH
25523: LD_INT 1
25525: NEG
25526: PUSH
25527: LD_INT 2
25529: NEG
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: PUSH
25535: LD_INT 0
25537: PUSH
25538: LD_INT 2
25540: NEG
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: PUSH
25549: LD_INT 1
25551: NEG
25552: PUSH
25553: EMPTY
25554: LIST
25555: LIST
25556: PUSH
25557: LD_INT 2
25559: PUSH
25560: LD_INT 0
25562: PUSH
25563: EMPTY
25564: LIST
25565: LIST
25566: PUSH
25567: LD_INT 2
25569: PUSH
25570: LD_INT 1
25572: PUSH
25573: EMPTY
25574: LIST
25575: LIST
25576: PUSH
25577: LD_INT 2
25579: PUSH
25580: LD_INT 2
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: PUSH
25587: LD_INT 1
25589: PUSH
25590: LD_INT 2
25592: PUSH
25593: EMPTY
25594: LIST
25595: LIST
25596: PUSH
25597: LD_INT 0
25599: PUSH
25600: LD_INT 2
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PUSH
25607: LD_INT 1
25609: NEG
25610: PUSH
25611: LD_INT 1
25613: PUSH
25614: EMPTY
25615: LIST
25616: LIST
25617: PUSH
25618: LD_INT 2
25620: NEG
25621: PUSH
25622: LD_INT 0
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PUSH
25629: LD_INT 2
25631: NEG
25632: PUSH
25633: LD_INT 1
25635: NEG
25636: PUSH
25637: EMPTY
25638: LIST
25639: LIST
25640: PUSH
25641: LD_INT 2
25643: NEG
25644: PUSH
25645: LD_INT 2
25647: NEG
25648: PUSH
25649: EMPTY
25650: LIST
25651: LIST
25652: PUSH
25653: EMPTY
25654: LIST
25655: LIST
25656: LIST
25657: LIST
25658: LIST
25659: LIST
25660: LIST
25661: LIST
25662: LIST
25663: LIST
25664: LIST
25665: LIST
25666: LIST
25667: LIST
25668: LIST
25669: LIST
25670: LIST
25671: LIST
25672: LIST
25673: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
25674: LD_ADDR_VAR 0 22
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: EMPTY
25686: LIST
25687: LIST
25688: PUSH
25689: LD_INT 0
25691: PUSH
25692: LD_INT 1
25694: NEG
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: LD_INT 1
25702: PUSH
25703: LD_INT 0
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: PUSH
25710: LD_INT 1
25712: PUSH
25713: LD_INT 1
25715: PUSH
25716: EMPTY
25717: LIST
25718: LIST
25719: PUSH
25720: LD_INT 0
25722: PUSH
25723: LD_INT 1
25725: PUSH
25726: EMPTY
25727: LIST
25728: LIST
25729: PUSH
25730: LD_INT 1
25732: NEG
25733: PUSH
25734: LD_INT 0
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: PUSH
25741: LD_INT 1
25743: NEG
25744: PUSH
25745: LD_INT 1
25747: NEG
25748: PUSH
25749: EMPTY
25750: LIST
25751: LIST
25752: PUSH
25753: LD_INT 1
25755: NEG
25756: PUSH
25757: LD_INT 2
25759: NEG
25760: PUSH
25761: EMPTY
25762: LIST
25763: LIST
25764: PUSH
25765: LD_INT 0
25767: PUSH
25768: LD_INT 2
25770: NEG
25771: PUSH
25772: EMPTY
25773: LIST
25774: LIST
25775: PUSH
25776: LD_INT 1
25778: PUSH
25779: LD_INT 1
25781: NEG
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 2
25789: PUSH
25790: LD_INT 0
25792: PUSH
25793: EMPTY
25794: LIST
25795: LIST
25796: PUSH
25797: LD_INT 2
25799: PUSH
25800: LD_INT 1
25802: PUSH
25803: EMPTY
25804: LIST
25805: LIST
25806: PUSH
25807: LD_INT 2
25809: PUSH
25810: LD_INT 2
25812: PUSH
25813: EMPTY
25814: LIST
25815: LIST
25816: PUSH
25817: LD_INT 1
25819: PUSH
25820: LD_INT 2
25822: PUSH
25823: EMPTY
25824: LIST
25825: LIST
25826: PUSH
25827: LD_INT 0
25829: PUSH
25830: LD_INT 2
25832: PUSH
25833: EMPTY
25834: LIST
25835: LIST
25836: PUSH
25837: LD_INT 1
25839: NEG
25840: PUSH
25841: LD_INT 1
25843: PUSH
25844: EMPTY
25845: LIST
25846: LIST
25847: PUSH
25848: LD_INT 2
25850: NEG
25851: PUSH
25852: LD_INT 0
25854: PUSH
25855: EMPTY
25856: LIST
25857: LIST
25858: PUSH
25859: LD_INT 2
25861: NEG
25862: PUSH
25863: LD_INT 1
25865: NEG
25866: PUSH
25867: EMPTY
25868: LIST
25869: LIST
25870: PUSH
25871: LD_INT 2
25873: NEG
25874: PUSH
25875: LD_INT 2
25877: NEG
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: LIST
25888: LIST
25889: LIST
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: LIST
25898: LIST
25899: LIST
25900: LIST
25901: LIST
25902: LIST
25903: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
25904: LD_ADDR_VAR 0 23
25908: PUSH
25909: LD_INT 0
25911: PUSH
25912: LD_INT 0
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: PUSH
25919: LD_INT 0
25921: PUSH
25922: LD_INT 1
25924: NEG
25925: PUSH
25926: EMPTY
25927: LIST
25928: LIST
25929: PUSH
25930: LD_INT 1
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: EMPTY
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 1
25942: PUSH
25943: LD_INT 1
25945: PUSH
25946: EMPTY
25947: LIST
25948: LIST
25949: PUSH
25950: LD_INT 0
25952: PUSH
25953: LD_INT 1
25955: PUSH
25956: EMPTY
25957: LIST
25958: LIST
25959: PUSH
25960: LD_INT 1
25962: NEG
25963: PUSH
25964: LD_INT 0
25966: PUSH
25967: EMPTY
25968: LIST
25969: LIST
25970: PUSH
25971: LD_INT 1
25973: NEG
25974: PUSH
25975: LD_INT 1
25977: NEG
25978: PUSH
25979: EMPTY
25980: LIST
25981: LIST
25982: PUSH
25983: LD_INT 1
25985: NEG
25986: PUSH
25987: LD_INT 2
25989: NEG
25990: PUSH
25991: EMPTY
25992: LIST
25993: LIST
25994: PUSH
25995: LD_INT 0
25997: PUSH
25998: LD_INT 2
26000: NEG
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: LD_INT 1
26008: PUSH
26009: LD_INT 1
26011: NEG
26012: PUSH
26013: EMPTY
26014: LIST
26015: LIST
26016: PUSH
26017: LD_INT 2
26019: PUSH
26020: LD_INT 0
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: PUSH
26027: LD_INT 2
26029: PUSH
26030: LD_INT 1
26032: PUSH
26033: EMPTY
26034: LIST
26035: LIST
26036: PUSH
26037: LD_INT 2
26039: PUSH
26040: LD_INT 2
26042: PUSH
26043: EMPTY
26044: LIST
26045: LIST
26046: PUSH
26047: LD_INT 1
26049: PUSH
26050: LD_INT 2
26052: PUSH
26053: EMPTY
26054: LIST
26055: LIST
26056: PUSH
26057: LD_INT 0
26059: PUSH
26060: LD_INT 2
26062: PUSH
26063: EMPTY
26064: LIST
26065: LIST
26066: PUSH
26067: LD_INT 1
26069: NEG
26070: PUSH
26071: LD_INT 1
26073: PUSH
26074: EMPTY
26075: LIST
26076: LIST
26077: PUSH
26078: LD_INT 2
26080: NEG
26081: PUSH
26082: LD_INT 0
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: PUSH
26089: LD_INT 2
26091: NEG
26092: PUSH
26093: LD_INT 1
26095: NEG
26096: PUSH
26097: EMPTY
26098: LIST
26099: LIST
26100: PUSH
26101: LD_INT 2
26103: NEG
26104: PUSH
26105: LD_INT 2
26107: NEG
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PUSH
26113: LD_INT 2
26115: NEG
26116: PUSH
26117: LD_INT 3
26119: NEG
26120: PUSH
26121: EMPTY
26122: LIST
26123: LIST
26124: PUSH
26125: LD_INT 1
26127: NEG
26128: PUSH
26129: LD_INT 3
26131: NEG
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: PUSH
26137: LD_INT 1
26139: PUSH
26140: LD_INT 2
26142: NEG
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: LD_INT 2
26150: PUSH
26151: LD_INT 1
26153: NEG
26154: PUSH
26155: EMPTY
26156: LIST
26157: LIST
26158: PUSH
26159: EMPTY
26160: LIST
26161: LIST
26162: LIST
26163: LIST
26164: LIST
26165: LIST
26166: LIST
26167: LIST
26168: LIST
26169: LIST
26170: LIST
26171: LIST
26172: LIST
26173: LIST
26174: LIST
26175: LIST
26176: LIST
26177: LIST
26178: LIST
26179: LIST
26180: LIST
26181: LIST
26182: LIST
26183: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
26184: LD_ADDR_VAR 0 24
26188: PUSH
26189: LD_INT 0
26191: PUSH
26192: LD_INT 0
26194: PUSH
26195: EMPTY
26196: LIST
26197: LIST
26198: PUSH
26199: LD_INT 0
26201: PUSH
26202: LD_INT 1
26204: NEG
26205: PUSH
26206: EMPTY
26207: LIST
26208: LIST
26209: PUSH
26210: LD_INT 1
26212: PUSH
26213: LD_INT 0
26215: PUSH
26216: EMPTY
26217: LIST
26218: LIST
26219: PUSH
26220: LD_INT 1
26222: PUSH
26223: LD_INT 1
26225: PUSH
26226: EMPTY
26227: LIST
26228: LIST
26229: PUSH
26230: LD_INT 0
26232: PUSH
26233: LD_INT 1
26235: PUSH
26236: EMPTY
26237: LIST
26238: LIST
26239: PUSH
26240: LD_INT 1
26242: NEG
26243: PUSH
26244: LD_INT 0
26246: PUSH
26247: EMPTY
26248: LIST
26249: LIST
26250: PUSH
26251: LD_INT 1
26253: NEG
26254: PUSH
26255: LD_INT 1
26257: NEG
26258: PUSH
26259: EMPTY
26260: LIST
26261: LIST
26262: PUSH
26263: LD_INT 1
26265: NEG
26266: PUSH
26267: LD_INT 2
26269: NEG
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 0
26277: PUSH
26278: LD_INT 2
26280: NEG
26281: PUSH
26282: EMPTY
26283: LIST
26284: LIST
26285: PUSH
26286: LD_INT 1
26288: PUSH
26289: LD_INT 1
26291: NEG
26292: PUSH
26293: EMPTY
26294: LIST
26295: LIST
26296: PUSH
26297: LD_INT 2
26299: PUSH
26300: LD_INT 0
26302: PUSH
26303: EMPTY
26304: LIST
26305: LIST
26306: PUSH
26307: LD_INT 2
26309: PUSH
26310: LD_INT 1
26312: PUSH
26313: EMPTY
26314: LIST
26315: LIST
26316: PUSH
26317: LD_INT 2
26319: PUSH
26320: LD_INT 2
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 1
26329: PUSH
26330: LD_INT 2
26332: PUSH
26333: EMPTY
26334: LIST
26335: LIST
26336: PUSH
26337: LD_INT 0
26339: PUSH
26340: LD_INT 2
26342: PUSH
26343: EMPTY
26344: LIST
26345: LIST
26346: PUSH
26347: LD_INT 1
26349: NEG
26350: PUSH
26351: LD_INT 1
26353: PUSH
26354: EMPTY
26355: LIST
26356: LIST
26357: PUSH
26358: LD_INT 2
26360: NEG
26361: PUSH
26362: LD_INT 0
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: LD_INT 2
26371: NEG
26372: PUSH
26373: LD_INT 1
26375: NEG
26376: PUSH
26377: EMPTY
26378: LIST
26379: LIST
26380: PUSH
26381: LD_INT 2
26383: NEG
26384: PUSH
26385: LD_INT 2
26387: NEG
26388: PUSH
26389: EMPTY
26390: LIST
26391: LIST
26392: PUSH
26393: LD_INT 1
26395: PUSH
26396: LD_INT 2
26398: NEG
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: PUSH
26404: LD_INT 2
26406: PUSH
26407: LD_INT 1
26409: NEG
26410: PUSH
26411: EMPTY
26412: LIST
26413: LIST
26414: PUSH
26415: LD_INT 3
26417: PUSH
26418: LD_INT 1
26420: PUSH
26421: EMPTY
26422: LIST
26423: LIST
26424: PUSH
26425: LD_INT 3
26427: PUSH
26428: LD_INT 2
26430: PUSH
26431: EMPTY
26432: LIST
26433: LIST
26434: PUSH
26435: EMPTY
26436: LIST
26437: LIST
26438: LIST
26439: LIST
26440: LIST
26441: LIST
26442: LIST
26443: LIST
26444: LIST
26445: LIST
26446: LIST
26447: LIST
26448: LIST
26449: LIST
26450: LIST
26451: LIST
26452: LIST
26453: LIST
26454: LIST
26455: LIST
26456: LIST
26457: LIST
26458: LIST
26459: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
26460: LD_ADDR_VAR 0 25
26464: PUSH
26465: LD_INT 0
26467: PUSH
26468: LD_INT 0
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: LD_INT 0
26477: PUSH
26478: LD_INT 1
26480: NEG
26481: PUSH
26482: EMPTY
26483: LIST
26484: LIST
26485: PUSH
26486: LD_INT 1
26488: PUSH
26489: LD_INT 0
26491: PUSH
26492: EMPTY
26493: LIST
26494: LIST
26495: PUSH
26496: LD_INT 1
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 0
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 1
26518: NEG
26519: PUSH
26520: LD_INT 0
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 1
26529: NEG
26530: PUSH
26531: LD_INT 1
26533: NEG
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: LD_INT 1
26541: NEG
26542: PUSH
26543: LD_INT 2
26545: NEG
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 0
26553: PUSH
26554: LD_INT 2
26556: NEG
26557: PUSH
26558: EMPTY
26559: LIST
26560: LIST
26561: PUSH
26562: LD_INT 1
26564: PUSH
26565: LD_INT 1
26567: NEG
26568: PUSH
26569: EMPTY
26570: LIST
26571: LIST
26572: PUSH
26573: LD_INT 2
26575: PUSH
26576: LD_INT 0
26578: PUSH
26579: EMPTY
26580: LIST
26581: LIST
26582: PUSH
26583: LD_INT 2
26585: PUSH
26586: LD_INT 1
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: LD_INT 2
26595: PUSH
26596: LD_INT 2
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: LD_INT 1
26605: PUSH
26606: LD_INT 2
26608: PUSH
26609: EMPTY
26610: LIST
26611: LIST
26612: PUSH
26613: LD_INT 0
26615: PUSH
26616: LD_INT 2
26618: PUSH
26619: EMPTY
26620: LIST
26621: LIST
26622: PUSH
26623: LD_INT 1
26625: NEG
26626: PUSH
26627: LD_INT 1
26629: PUSH
26630: EMPTY
26631: LIST
26632: LIST
26633: PUSH
26634: LD_INT 2
26636: NEG
26637: PUSH
26638: LD_INT 0
26640: PUSH
26641: EMPTY
26642: LIST
26643: LIST
26644: PUSH
26645: LD_INT 2
26647: NEG
26648: PUSH
26649: LD_INT 1
26651: NEG
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 2
26659: NEG
26660: PUSH
26661: LD_INT 2
26663: NEG
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 3
26671: PUSH
26672: LD_INT 1
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PUSH
26679: LD_INT 3
26681: PUSH
26682: LD_INT 2
26684: PUSH
26685: EMPTY
26686: LIST
26687: LIST
26688: PUSH
26689: LD_INT 2
26691: PUSH
26692: LD_INT 3
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: PUSH
26699: LD_INT 1
26701: PUSH
26702: LD_INT 3
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PUSH
26709: EMPTY
26710: LIST
26711: LIST
26712: LIST
26713: LIST
26714: LIST
26715: LIST
26716: LIST
26717: LIST
26718: LIST
26719: LIST
26720: LIST
26721: LIST
26722: LIST
26723: LIST
26724: LIST
26725: LIST
26726: LIST
26727: LIST
26728: LIST
26729: LIST
26730: LIST
26731: LIST
26732: LIST
26733: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
26734: LD_ADDR_VAR 0 26
26738: PUSH
26739: LD_INT 0
26741: PUSH
26742: LD_INT 0
26744: PUSH
26745: EMPTY
26746: LIST
26747: LIST
26748: PUSH
26749: LD_INT 0
26751: PUSH
26752: LD_INT 1
26754: NEG
26755: PUSH
26756: EMPTY
26757: LIST
26758: LIST
26759: PUSH
26760: LD_INT 1
26762: PUSH
26763: LD_INT 0
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: PUSH
26770: LD_INT 1
26772: PUSH
26773: LD_INT 1
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: PUSH
26780: LD_INT 0
26782: PUSH
26783: LD_INT 1
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 1
26792: NEG
26793: PUSH
26794: LD_INT 0
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 1
26803: NEG
26804: PUSH
26805: LD_INT 1
26807: NEG
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 1
26815: NEG
26816: PUSH
26817: LD_INT 2
26819: NEG
26820: PUSH
26821: EMPTY
26822: LIST
26823: LIST
26824: PUSH
26825: LD_INT 0
26827: PUSH
26828: LD_INT 2
26830: NEG
26831: PUSH
26832: EMPTY
26833: LIST
26834: LIST
26835: PUSH
26836: LD_INT 1
26838: PUSH
26839: LD_INT 1
26841: NEG
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PUSH
26847: LD_INT 2
26849: PUSH
26850: LD_INT 0
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: LD_INT 2
26859: PUSH
26860: LD_INT 1
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 2
26869: PUSH
26870: LD_INT 2
26872: PUSH
26873: EMPTY
26874: LIST
26875: LIST
26876: PUSH
26877: LD_INT 1
26879: PUSH
26880: LD_INT 2
26882: PUSH
26883: EMPTY
26884: LIST
26885: LIST
26886: PUSH
26887: LD_INT 0
26889: PUSH
26890: LD_INT 2
26892: PUSH
26893: EMPTY
26894: LIST
26895: LIST
26896: PUSH
26897: LD_INT 1
26899: NEG
26900: PUSH
26901: LD_INT 1
26903: PUSH
26904: EMPTY
26905: LIST
26906: LIST
26907: PUSH
26908: LD_INT 2
26910: NEG
26911: PUSH
26912: LD_INT 0
26914: PUSH
26915: EMPTY
26916: LIST
26917: LIST
26918: PUSH
26919: LD_INT 2
26921: NEG
26922: PUSH
26923: LD_INT 1
26925: NEG
26926: PUSH
26927: EMPTY
26928: LIST
26929: LIST
26930: PUSH
26931: LD_INT 2
26933: NEG
26934: PUSH
26935: LD_INT 2
26937: NEG
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: PUSH
26943: LD_INT 2
26945: PUSH
26946: LD_INT 3
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: PUSH
26953: LD_INT 1
26955: PUSH
26956: LD_INT 3
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 1
26965: NEG
26966: PUSH
26967: LD_INT 2
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PUSH
26974: LD_INT 2
26976: NEG
26977: PUSH
26978: LD_INT 1
26980: PUSH
26981: EMPTY
26982: LIST
26983: LIST
26984: PUSH
26985: EMPTY
26986: LIST
26987: LIST
26988: LIST
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: LIST
26994: LIST
26995: LIST
26996: LIST
26997: LIST
26998: LIST
26999: LIST
27000: LIST
27001: LIST
27002: LIST
27003: LIST
27004: LIST
27005: LIST
27006: LIST
27007: LIST
27008: LIST
27009: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27010: LD_ADDR_VAR 0 27
27014: PUSH
27015: LD_INT 0
27017: PUSH
27018: LD_INT 0
27020: PUSH
27021: EMPTY
27022: LIST
27023: LIST
27024: PUSH
27025: LD_INT 0
27027: PUSH
27028: LD_INT 1
27030: NEG
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: LD_INT 1
27038: PUSH
27039: LD_INT 0
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PUSH
27046: LD_INT 1
27048: PUSH
27049: LD_INT 1
27051: PUSH
27052: EMPTY
27053: LIST
27054: LIST
27055: PUSH
27056: LD_INT 0
27058: PUSH
27059: LD_INT 1
27061: PUSH
27062: EMPTY
27063: LIST
27064: LIST
27065: PUSH
27066: LD_INT 1
27068: NEG
27069: PUSH
27070: LD_INT 0
27072: PUSH
27073: EMPTY
27074: LIST
27075: LIST
27076: PUSH
27077: LD_INT 1
27079: NEG
27080: PUSH
27081: LD_INT 1
27083: NEG
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: PUSH
27089: LD_INT 1
27091: NEG
27092: PUSH
27093: LD_INT 2
27095: NEG
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: PUSH
27101: LD_INT 0
27103: PUSH
27104: LD_INT 2
27106: NEG
27107: PUSH
27108: EMPTY
27109: LIST
27110: LIST
27111: PUSH
27112: LD_INT 1
27114: PUSH
27115: LD_INT 1
27117: NEG
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: LD_INT 2
27125: PUSH
27126: LD_INT 0
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: PUSH
27133: LD_INT 2
27135: PUSH
27136: LD_INT 1
27138: PUSH
27139: EMPTY
27140: LIST
27141: LIST
27142: PUSH
27143: LD_INT 2
27145: PUSH
27146: LD_INT 2
27148: PUSH
27149: EMPTY
27150: LIST
27151: LIST
27152: PUSH
27153: LD_INT 1
27155: PUSH
27156: LD_INT 2
27158: PUSH
27159: EMPTY
27160: LIST
27161: LIST
27162: PUSH
27163: LD_INT 0
27165: PUSH
27166: LD_INT 2
27168: PUSH
27169: EMPTY
27170: LIST
27171: LIST
27172: PUSH
27173: LD_INT 1
27175: NEG
27176: PUSH
27177: LD_INT 1
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PUSH
27184: LD_INT 2
27186: NEG
27187: PUSH
27188: LD_INT 0
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 2
27197: NEG
27198: PUSH
27199: LD_INT 1
27201: NEG
27202: PUSH
27203: EMPTY
27204: LIST
27205: LIST
27206: PUSH
27207: LD_INT 2
27209: NEG
27210: PUSH
27211: LD_INT 2
27213: NEG
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PUSH
27219: LD_INT 1
27221: NEG
27222: PUSH
27223: LD_INT 2
27225: PUSH
27226: EMPTY
27227: LIST
27228: LIST
27229: PUSH
27230: LD_INT 2
27232: NEG
27233: PUSH
27234: LD_INT 1
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 3
27243: NEG
27244: PUSH
27245: LD_INT 1
27247: NEG
27248: PUSH
27249: EMPTY
27250: LIST
27251: LIST
27252: PUSH
27253: LD_INT 3
27255: NEG
27256: PUSH
27257: LD_INT 2
27259: NEG
27260: PUSH
27261: EMPTY
27262: LIST
27263: LIST
27264: PUSH
27265: EMPTY
27266: LIST
27267: LIST
27268: LIST
27269: LIST
27270: LIST
27271: LIST
27272: LIST
27273: LIST
27274: LIST
27275: LIST
27276: LIST
27277: LIST
27278: LIST
27279: LIST
27280: LIST
27281: LIST
27282: LIST
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: LIST
27288: LIST
27289: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
27290: LD_ADDR_VAR 0 28
27294: PUSH
27295: LD_INT 0
27297: PUSH
27298: LD_INT 0
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PUSH
27305: LD_INT 0
27307: PUSH
27308: LD_INT 1
27310: NEG
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 1
27318: PUSH
27319: LD_INT 0
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: PUSH
27326: LD_INT 1
27328: PUSH
27329: LD_INT 1
27331: PUSH
27332: EMPTY
27333: LIST
27334: LIST
27335: PUSH
27336: LD_INT 0
27338: PUSH
27339: LD_INT 1
27341: PUSH
27342: EMPTY
27343: LIST
27344: LIST
27345: PUSH
27346: LD_INT 1
27348: NEG
27349: PUSH
27350: LD_INT 0
27352: PUSH
27353: EMPTY
27354: LIST
27355: LIST
27356: PUSH
27357: LD_INT 1
27359: NEG
27360: PUSH
27361: LD_INT 1
27363: NEG
27364: PUSH
27365: EMPTY
27366: LIST
27367: LIST
27368: PUSH
27369: LD_INT 1
27371: NEG
27372: PUSH
27373: LD_INT 2
27375: NEG
27376: PUSH
27377: EMPTY
27378: LIST
27379: LIST
27380: PUSH
27381: LD_INT 0
27383: PUSH
27384: LD_INT 2
27386: NEG
27387: PUSH
27388: EMPTY
27389: LIST
27390: LIST
27391: PUSH
27392: LD_INT 1
27394: PUSH
27395: LD_INT 1
27397: NEG
27398: PUSH
27399: EMPTY
27400: LIST
27401: LIST
27402: PUSH
27403: LD_INT 2
27405: PUSH
27406: LD_INT 0
27408: PUSH
27409: EMPTY
27410: LIST
27411: LIST
27412: PUSH
27413: LD_INT 2
27415: PUSH
27416: LD_INT 1
27418: PUSH
27419: EMPTY
27420: LIST
27421: LIST
27422: PUSH
27423: LD_INT 2
27425: PUSH
27426: LD_INT 2
27428: PUSH
27429: EMPTY
27430: LIST
27431: LIST
27432: PUSH
27433: LD_INT 1
27435: PUSH
27436: LD_INT 2
27438: PUSH
27439: EMPTY
27440: LIST
27441: LIST
27442: PUSH
27443: LD_INT 0
27445: PUSH
27446: LD_INT 2
27448: PUSH
27449: EMPTY
27450: LIST
27451: LIST
27452: PUSH
27453: LD_INT 1
27455: NEG
27456: PUSH
27457: LD_INT 1
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: LD_INT 2
27466: NEG
27467: PUSH
27468: LD_INT 0
27470: PUSH
27471: EMPTY
27472: LIST
27473: LIST
27474: PUSH
27475: LD_INT 2
27477: NEG
27478: PUSH
27479: LD_INT 1
27481: NEG
27482: PUSH
27483: EMPTY
27484: LIST
27485: LIST
27486: PUSH
27487: LD_INT 2
27489: NEG
27490: PUSH
27491: LD_INT 2
27493: NEG
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: PUSH
27499: LD_INT 2
27501: NEG
27502: PUSH
27503: LD_INT 3
27505: NEG
27506: PUSH
27507: EMPTY
27508: LIST
27509: LIST
27510: PUSH
27511: LD_INT 1
27513: NEG
27514: PUSH
27515: LD_INT 3
27517: NEG
27518: PUSH
27519: EMPTY
27520: LIST
27521: LIST
27522: PUSH
27523: LD_INT 3
27525: NEG
27526: PUSH
27527: LD_INT 1
27529: NEG
27530: PUSH
27531: EMPTY
27532: LIST
27533: LIST
27534: PUSH
27535: LD_INT 3
27537: NEG
27538: PUSH
27539: LD_INT 2
27541: NEG
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: LIST
27551: LIST
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: LIST
27559: LIST
27560: LIST
27561: LIST
27562: LIST
27563: LIST
27564: LIST
27565: LIST
27566: LIST
27567: LIST
27568: LIST
27569: LIST
27570: LIST
27571: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
27572: LD_ADDR_VAR 0 29
27576: PUSH
27577: LD_INT 0
27579: PUSH
27580: LD_INT 0
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: PUSH
27587: LD_INT 0
27589: PUSH
27590: LD_INT 1
27592: NEG
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 1
27600: PUSH
27601: LD_INT 0
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 1
27610: PUSH
27611: LD_INT 1
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: LD_INT 0
27620: PUSH
27621: LD_INT 1
27623: PUSH
27624: EMPTY
27625: LIST
27626: LIST
27627: PUSH
27628: LD_INT 1
27630: NEG
27631: PUSH
27632: LD_INT 0
27634: PUSH
27635: EMPTY
27636: LIST
27637: LIST
27638: PUSH
27639: LD_INT 1
27641: NEG
27642: PUSH
27643: LD_INT 1
27645: NEG
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: PUSH
27651: LD_INT 1
27653: NEG
27654: PUSH
27655: LD_INT 2
27657: NEG
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: LD_INT 0
27665: PUSH
27666: LD_INT 2
27668: NEG
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: LD_INT 1
27676: PUSH
27677: LD_INT 1
27679: NEG
27680: PUSH
27681: EMPTY
27682: LIST
27683: LIST
27684: PUSH
27685: LD_INT 2
27687: PUSH
27688: LD_INT 0
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: PUSH
27695: LD_INT 2
27697: PUSH
27698: LD_INT 1
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: PUSH
27705: LD_INT 1
27707: PUSH
27708: LD_INT 2
27710: PUSH
27711: EMPTY
27712: LIST
27713: LIST
27714: PUSH
27715: LD_INT 0
27717: PUSH
27718: LD_INT 2
27720: PUSH
27721: EMPTY
27722: LIST
27723: LIST
27724: PUSH
27725: LD_INT 1
27727: NEG
27728: PUSH
27729: LD_INT 1
27731: PUSH
27732: EMPTY
27733: LIST
27734: LIST
27735: PUSH
27736: LD_INT 2
27738: NEG
27739: PUSH
27740: LD_INT 1
27742: NEG
27743: PUSH
27744: EMPTY
27745: LIST
27746: LIST
27747: PUSH
27748: LD_INT 2
27750: NEG
27751: PUSH
27752: LD_INT 2
27754: NEG
27755: PUSH
27756: EMPTY
27757: LIST
27758: LIST
27759: PUSH
27760: LD_INT 2
27762: NEG
27763: PUSH
27764: LD_INT 3
27766: NEG
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: PUSH
27772: LD_INT 2
27774: PUSH
27775: LD_INT 1
27777: NEG
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 3
27785: PUSH
27786: LD_INT 1
27788: PUSH
27789: EMPTY
27790: LIST
27791: LIST
27792: PUSH
27793: LD_INT 1
27795: PUSH
27796: LD_INT 3
27798: PUSH
27799: EMPTY
27800: LIST
27801: LIST
27802: PUSH
27803: LD_INT 1
27805: NEG
27806: PUSH
27807: LD_INT 2
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PUSH
27814: LD_INT 3
27816: NEG
27817: PUSH
27818: LD_INT 2
27820: NEG
27821: PUSH
27822: EMPTY
27823: LIST
27824: LIST
27825: PUSH
27826: EMPTY
27827: LIST
27828: LIST
27829: LIST
27830: LIST
27831: LIST
27832: LIST
27833: LIST
27834: LIST
27835: LIST
27836: LIST
27837: LIST
27838: LIST
27839: LIST
27840: LIST
27841: LIST
27842: LIST
27843: LIST
27844: LIST
27845: LIST
27846: LIST
27847: LIST
27848: LIST
27849: LIST
27850: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
27851: LD_ADDR_VAR 0 30
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: LD_INT 0
27861: PUSH
27862: EMPTY
27863: LIST
27864: LIST
27865: PUSH
27866: LD_INT 0
27868: PUSH
27869: LD_INT 1
27871: NEG
27872: PUSH
27873: EMPTY
27874: LIST
27875: LIST
27876: PUSH
27877: LD_INT 1
27879: PUSH
27880: LD_INT 0
27882: PUSH
27883: EMPTY
27884: LIST
27885: LIST
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: LD_INT 1
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: PUSH
27897: LD_INT 0
27899: PUSH
27900: LD_INT 1
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 1
27909: NEG
27910: PUSH
27911: LD_INT 0
27913: PUSH
27914: EMPTY
27915: LIST
27916: LIST
27917: PUSH
27918: LD_INT 1
27920: NEG
27921: PUSH
27922: LD_INT 1
27924: NEG
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: LD_INT 1
27932: NEG
27933: PUSH
27934: LD_INT 2
27936: NEG
27937: PUSH
27938: EMPTY
27939: LIST
27940: LIST
27941: PUSH
27942: LD_INT 0
27944: PUSH
27945: LD_INT 2
27947: NEG
27948: PUSH
27949: EMPTY
27950: LIST
27951: LIST
27952: PUSH
27953: LD_INT 1
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: EMPTY
27961: LIST
27962: LIST
27963: PUSH
27964: LD_INT 2
27966: PUSH
27967: LD_INT 0
27969: PUSH
27970: EMPTY
27971: LIST
27972: LIST
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 1
27979: PUSH
27980: EMPTY
27981: LIST
27982: LIST
27983: PUSH
27984: LD_INT 2
27986: PUSH
27987: LD_INT 2
27989: PUSH
27990: EMPTY
27991: LIST
27992: LIST
27993: PUSH
27994: LD_INT 1
27996: PUSH
27997: LD_INT 2
27999: PUSH
28000: EMPTY
28001: LIST
28002: LIST
28003: PUSH
28004: LD_INT 1
28006: NEG
28007: PUSH
28008: LD_INT 1
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: PUSH
28015: LD_INT 2
28017: NEG
28018: PUSH
28019: LD_INT 0
28021: PUSH
28022: EMPTY
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 2
28028: NEG
28029: PUSH
28030: LD_INT 1
28032: NEG
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: PUSH
28038: LD_INT 1
28040: NEG
28041: PUSH
28042: LD_INT 3
28044: NEG
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PUSH
28050: LD_INT 1
28052: PUSH
28053: LD_INT 2
28055: NEG
28056: PUSH
28057: EMPTY
28058: LIST
28059: LIST
28060: PUSH
28061: LD_INT 3
28063: PUSH
28064: LD_INT 2
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: PUSH
28071: LD_INT 2
28073: PUSH
28074: LD_INT 3
28076: PUSH
28077: EMPTY
28078: LIST
28079: LIST
28080: PUSH
28081: LD_INT 2
28083: NEG
28084: PUSH
28085: LD_INT 1
28087: PUSH
28088: EMPTY
28089: LIST
28090: LIST
28091: PUSH
28092: LD_INT 3
28094: NEG
28095: PUSH
28096: LD_INT 1
28098: NEG
28099: PUSH
28100: EMPTY
28101: LIST
28102: LIST
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: LIST
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: LIST
28113: LIST
28114: LIST
28115: LIST
28116: LIST
28117: LIST
28118: LIST
28119: LIST
28120: LIST
28121: LIST
28122: LIST
28123: LIST
28124: LIST
28125: LIST
28126: LIST
28127: LIST
28128: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28129: LD_ADDR_VAR 0 31
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: LD_INT 0
28139: PUSH
28140: EMPTY
28141: LIST
28142: LIST
28143: PUSH
28144: LD_INT 0
28146: PUSH
28147: LD_INT 1
28149: NEG
28150: PUSH
28151: EMPTY
28152: LIST
28153: LIST
28154: PUSH
28155: LD_INT 1
28157: PUSH
28158: LD_INT 0
28160: PUSH
28161: EMPTY
28162: LIST
28163: LIST
28164: PUSH
28165: LD_INT 1
28167: PUSH
28168: LD_INT 1
28170: PUSH
28171: EMPTY
28172: LIST
28173: LIST
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: LD_INT 1
28180: PUSH
28181: EMPTY
28182: LIST
28183: LIST
28184: PUSH
28185: LD_INT 1
28187: NEG
28188: PUSH
28189: LD_INT 0
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 1
28198: NEG
28199: PUSH
28200: LD_INT 1
28202: NEG
28203: PUSH
28204: EMPTY
28205: LIST
28206: LIST
28207: PUSH
28208: LD_INT 1
28210: NEG
28211: PUSH
28212: LD_INT 2
28214: NEG
28215: PUSH
28216: EMPTY
28217: LIST
28218: LIST
28219: PUSH
28220: LD_INT 1
28222: PUSH
28223: LD_INT 1
28225: NEG
28226: PUSH
28227: EMPTY
28228: LIST
28229: LIST
28230: PUSH
28231: LD_INT 2
28233: PUSH
28234: LD_INT 0
28236: PUSH
28237: EMPTY
28238: LIST
28239: LIST
28240: PUSH
28241: LD_INT 2
28243: PUSH
28244: LD_INT 1
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 2
28253: PUSH
28254: LD_INT 2
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: LD_INT 2
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 0
28273: PUSH
28274: LD_INT 2
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 1
28283: NEG
28284: PUSH
28285: LD_INT 1
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 2
28294: NEG
28295: PUSH
28296: LD_INT 1
28298: NEG
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 2
28306: NEG
28307: PUSH
28308: LD_INT 2
28310: NEG
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 2
28318: NEG
28319: PUSH
28320: LD_INT 3
28322: NEG
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 2
28330: PUSH
28331: LD_INT 1
28333: NEG
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: LD_INT 3
28341: PUSH
28342: LD_INT 1
28344: PUSH
28345: EMPTY
28346: LIST
28347: LIST
28348: PUSH
28349: LD_INT 1
28351: PUSH
28352: LD_INT 3
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: PUSH
28359: LD_INT 1
28361: NEG
28362: PUSH
28363: LD_INT 2
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 3
28372: NEG
28373: PUSH
28374: LD_INT 2
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: EMPTY
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: LIST
28388: LIST
28389: LIST
28390: LIST
28391: LIST
28392: LIST
28393: LIST
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28407: LD_ADDR_VAR 0 32
28411: PUSH
28412: LD_INT 0
28414: PUSH
28415: LD_INT 0
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: PUSH
28422: LD_INT 0
28424: PUSH
28425: LD_INT 1
28427: NEG
28428: PUSH
28429: EMPTY
28430: LIST
28431: LIST
28432: PUSH
28433: LD_INT 1
28435: PUSH
28436: LD_INT 0
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: PUSH
28443: LD_INT 1
28445: PUSH
28446: LD_INT 1
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 0
28455: PUSH
28456: LD_INT 1
28458: PUSH
28459: EMPTY
28460: LIST
28461: LIST
28462: PUSH
28463: LD_INT 1
28465: NEG
28466: PUSH
28467: LD_INT 0
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: LD_INT 1
28476: NEG
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: EMPTY
28483: LIST
28484: LIST
28485: PUSH
28486: LD_INT 1
28488: NEG
28489: PUSH
28490: LD_INT 2
28492: NEG
28493: PUSH
28494: EMPTY
28495: LIST
28496: LIST
28497: PUSH
28498: LD_INT 0
28500: PUSH
28501: LD_INT 2
28503: NEG
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PUSH
28509: LD_INT 1
28511: PUSH
28512: LD_INT 1
28514: NEG
28515: PUSH
28516: EMPTY
28517: LIST
28518: LIST
28519: PUSH
28520: LD_INT 2
28522: PUSH
28523: LD_INT 1
28525: PUSH
28526: EMPTY
28527: LIST
28528: LIST
28529: PUSH
28530: LD_INT 2
28532: PUSH
28533: LD_INT 2
28535: PUSH
28536: EMPTY
28537: LIST
28538: LIST
28539: PUSH
28540: LD_INT 1
28542: PUSH
28543: LD_INT 2
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 0
28552: PUSH
28553: LD_INT 2
28555: PUSH
28556: EMPTY
28557: LIST
28558: LIST
28559: PUSH
28560: LD_INT 1
28562: NEG
28563: PUSH
28564: LD_INT 1
28566: PUSH
28567: EMPTY
28568: LIST
28569: LIST
28570: PUSH
28571: LD_INT 2
28573: NEG
28574: PUSH
28575: LD_INT 0
28577: PUSH
28578: EMPTY
28579: LIST
28580: LIST
28581: PUSH
28582: LD_INT 2
28584: NEG
28585: PUSH
28586: LD_INT 1
28588: NEG
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: PUSH
28594: LD_INT 1
28596: NEG
28597: PUSH
28598: LD_INT 3
28600: NEG
28601: PUSH
28602: EMPTY
28603: LIST
28604: LIST
28605: PUSH
28606: LD_INT 1
28608: PUSH
28609: LD_INT 2
28611: NEG
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: PUSH
28617: LD_INT 3
28619: PUSH
28620: LD_INT 2
28622: PUSH
28623: EMPTY
28624: LIST
28625: LIST
28626: PUSH
28627: LD_INT 2
28629: PUSH
28630: LD_INT 3
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PUSH
28637: LD_INT 2
28639: NEG
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_INT 3
28650: NEG
28651: PUSH
28652: LD_INT 1
28654: NEG
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: EMPTY
28661: LIST
28662: LIST
28663: LIST
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: LIST
28671: LIST
28672: LIST
28673: LIST
28674: LIST
28675: LIST
28676: LIST
28677: LIST
28678: LIST
28679: LIST
28680: LIST
28681: LIST
28682: LIST
28683: LIST
28684: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
28685: LD_ADDR_VAR 0 33
28689: PUSH
28690: LD_INT 0
28692: PUSH
28693: LD_INT 0
28695: PUSH
28696: EMPTY
28697: LIST
28698: LIST
28699: PUSH
28700: LD_INT 0
28702: PUSH
28703: LD_INT 1
28705: NEG
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: LD_INT 0
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: LD_INT 1
28726: PUSH
28727: EMPTY
28728: LIST
28729: LIST
28730: PUSH
28731: LD_INT 0
28733: PUSH
28734: LD_INT 1
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: PUSH
28741: LD_INT 1
28743: NEG
28744: PUSH
28745: LD_INT 0
28747: PUSH
28748: EMPTY
28749: LIST
28750: LIST
28751: PUSH
28752: LD_INT 1
28754: NEG
28755: PUSH
28756: LD_INT 1
28758: NEG
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 1
28766: NEG
28767: PUSH
28768: LD_INT 2
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 1
28778: PUSH
28779: LD_INT 1
28781: NEG
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 2
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 2
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: PUSH
28807: LD_INT 1
28809: PUSH
28810: LD_INT 2
28812: PUSH
28813: EMPTY
28814: LIST
28815: LIST
28816: PUSH
28817: LD_INT 0
28819: PUSH
28820: LD_INT 2
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: PUSH
28827: LD_INT 1
28829: NEG
28830: PUSH
28831: LD_INT 1
28833: PUSH
28834: EMPTY
28835: LIST
28836: LIST
28837: PUSH
28838: LD_INT 2
28840: NEG
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 2
28851: NEG
28852: PUSH
28853: LD_INT 1
28855: NEG
28856: PUSH
28857: EMPTY
28858: LIST
28859: LIST
28860: PUSH
28861: LD_INT 2
28863: NEG
28864: PUSH
28865: LD_INT 2
28867: NEG
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 2
28875: NEG
28876: PUSH
28877: LD_INT 3
28879: NEG
28880: PUSH
28881: EMPTY
28882: LIST
28883: LIST
28884: PUSH
28885: LD_INT 2
28887: PUSH
28888: LD_INT 1
28890: NEG
28891: PUSH
28892: EMPTY
28893: LIST
28894: LIST
28895: PUSH
28896: LD_INT 3
28898: PUSH
28899: LD_INT 1
28901: PUSH
28902: EMPTY
28903: LIST
28904: LIST
28905: PUSH
28906: LD_INT 1
28908: PUSH
28909: LD_INT 3
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 1
28918: NEG
28919: PUSH
28920: LD_INT 2
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: LD_INT 3
28929: NEG
28930: PUSH
28931: LD_INT 2
28933: NEG
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PUSH
28939: EMPTY
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: LIST
28948: LIST
28949: LIST
28950: LIST
28951: LIST
28952: LIST
28953: LIST
28954: LIST
28955: LIST
28956: LIST
28957: LIST
28958: LIST
28959: LIST
28960: LIST
28961: LIST
28962: LIST
28963: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
28964: LD_ADDR_VAR 0 34
28968: PUSH
28969: LD_INT 0
28971: PUSH
28972: LD_INT 0
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: PUSH
28979: LD_INT 0
28981: PUSH
28982: LD_INT 1
28984: NEG
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: LD_INT 0
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 1
29002: PUSH
29003: LD_INT 1
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: LD_INT 1
29015: PUSH
29016: EMPTY
29017: LIST
29018: LIST
29019: PUSH
29020: LD_INT 1
29022: NEG
29023: PUSH
29024: LD_INT 0
29026: PUSH
29027: EMPTY
29028: LIST
29029: LIST
29030: PUSH
29031: LD_INT 1
29033: NEG
29034: PUSH
29035: LD_INT 1
29037: NEG
29038: PUSH
29039: EMPTY
29040: LIST
29041: LIST
29042: PUSH
29043: LD_INT 1
29045: NEG
29046: PUSH
29047: LD_INT 2
29049: NEG
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: LD_INT 2
29060: NEG
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: LD_INT 1
29071: NEG
29072: PUSH
29073: EMPTY
29074: LIST
29075: LIST
29076: PUSH
29077: LD_INT 2
29079: PUSH
29080: LD_INT 1
29082: PUSH
29083: EMPTY
29084: LIST
29085: LIST
29086: PUSH
29087: LD_INT 2
29089: PUSH
29090: LD_INT 2
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: PUSH
29100: LD_INT 2
29102: PUSH
29103: EMPTY
29104: LIST
29105: LIST
29106: PUSH
29107: LD_INT 1
29109: NEG
29110: PUSH
29111: LD_INT 1
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 2
29120: NEG
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 2
29131: NEG
29132: PUSH
29133: LD_INT 1
29135: NEG
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 1
29155: NEG
29156: PUSH
29157: LD_INT 3
29159: NEG
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 1
29167: PUSH
29168: LD_INT 2
29170: NEG
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 3
29178: PUSH
29179: LD_INT 2
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 2
29198: NEG
29199: PUSH
29200: LD_INT 1
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: LD_INT 3
29209: NEG
29210: PUSH
29211: LD_INT 1
29213: NEG
29214: PUSH
29215: EMPTY
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29244: LD_ADDR_VAR 0 35
29248: PUSH
29249: LD_INT 0
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 0
29261: PUSH
29262: LD_INT 1
29264: NEG
29265: PUSH
29266: EMPTY
29267: LIST
29268: LIST
29269: PUSH
29270: LD_INT 1
29272: PUSH
29273: LD_INT 0
29275: PUSH
29276: EMPTY
29277: LIST
29278: LIST
29279: PUSH
29280: LD_INT 1
29282: PUSH
29283: LD_INT 1
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 0
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: EMPTY
29297: LIST
29298: LIST
29299: PUSH
29300: LD_INT 1
29302: NEG
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 1
29313: NEG
29314: PUSH
29315: LD_INT 1
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 2
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 2
29335: NEG
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: EMPTY
29346: LIST
29347: LIST
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29356: LD_ADDR_VAR 0 36
29360: PUSH
29361: LD_INT 0
29363: PUSH
29364: LD_INT 0
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 0
29373: PUSH
29374: LD_INT 1
29376: NEG
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: PUSH
29382: LD_INT 1
29384: PUSH
29385: LD_INT 0
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: PUSH
29395: LD_INT 1
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: PUSH
29402: LD_INT 0
29404: PUSH
29405: LD_INT 1
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: LD_INT 1
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: LD_INT 1
29437: NEG
29438: PUSH
29439: LD_INT 2
29441: NEG
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 1
29449: PUSH
29450: LD_INT 2
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29468: LD_ADDR_VAR 0 37
29472: PUSH
29473: LD_INT 0
29475: PUSH
29476: LD_INT 0
29478: PUSH
29479: EMPTY
29480: LIST
29481: LIST
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: LD_INT 1
29488: NEG
29489: PUSH
29490: EMPTY
29491: LIST
29492: LIST
29493: PUSH
29494: LD_INT 1
29496: PUSH
29497: LD_INT 0
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 1
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 0
29516: PUSH
29517: LD_INT 1
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: LD_INT 0
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: NEG
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: LIST
29573: LIST
29574: LIST
29575: LIST
29576: LIST
29577: LIST
29578: LIST
29579: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
29580: LD_ADDR_VAR 0 38
29584: PUSH
29585: LD_INT 0
29587: PUSH
29588: LD_INT 0
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PUSH
29595: LD_INT 0
29597: PUSH
29598: LD_INT 1
29600: NEG
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: PUSH
29609: LD_INT 0
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: PUSH
29619: LD_INT 1
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 1
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 1
29638: NEG
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: NEG
29650: PUSH
29651: LD_INT 1
29653: NEG
29654: PUSH
29655: EMPTY
29656: LIST
29657: LIST
29658: PUSH
29659: LD_INT 2
29661: PUSH
29662: LD_INT 1
29664: PUSH
29665: EMPTY
29666: LIST
29667: LIST
29668: PUSH
29669: LD_INT 2
29671: NEG
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: LIST
29685: LIST
29686: LIST
29687: LIST
29688: LIST
29689: LIST
29690: LIST
29691: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
29692: LD_ADDR_VAR 0 39
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: LD_INT 0
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 0
29709: PUSH
29710: LD_INT 1
29712: NEG
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 1
29720: PUSH
29721: LD_INT 0
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 1
29730: PUSH
29731: LD_INT 1
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 0
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 1
29750: NEG
29751: PUSH
29752: LD_INT 0
29754: PUSH
29755: EMPTY
29756: LIST
29757: LIST
29758: PUSH
29759: LD_INT 1
29761: NEG
29762: PUSH
29763: LD_INT 1
29765: NEG
29766: PUSH
29767: EMPTY
29768: LIST
29769: LIST
29770: PUSH
29771: LD_INT 1
29773: NEG
29774: PUSH
29775: LD_INT 2
29777: NEG
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: LD_INT 2
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
29804: LD_ADDR_VAR 0 40
29808: PUSH
29809: LD_INT 0
29811: PUSH
29812: LD_INT 0
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 1
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 1
29832: PUSH
29833: LD_INT 0
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 1
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 1
29862: NEG
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: LD_INT 1
29877: NEG
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: PUSH
29886: LD_INT 1
29888: NEG
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 1
29896: NEG
29897: PUSH
29898: LD_INT 1
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: EMPTY
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: LIST
29913: LIST
29914: LIST
29915: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29916: LD_ADDR_VAR 0 41
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: LD_INT 0
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: PUSH
29931: LD_INT 0
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 1
29944: PUSH
29945: LD_INT 0
29947: PUSH
29948: EMPTY
29949: LIST
29950: LIST
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: LD_INT 1
29957: PUSH
29958: EMPTY
29959: LIST
29960: LIST
29961: PUSH
29962: LD_INT 0
29964: PUSH
29965: LD_INT 1
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PUSH
29972: LD_INT 1
29974: NEG
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 1
29985: NEG
29986: PUSH
29987: LD_INT 1
29989: NEG
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 1
29997: NEG
29998: PUSH
29999: LD_INT 2
30001: NEG
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: LD_INT 1
30012: NEG
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 2
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 2
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 2
30040: PUSH
30041: LD_INT 2
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 1
30050: PUSH
30051: LD_INT 2
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: NEG
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 2
30071: NEG
30072: PUSH
30073: LD_INT 0
30075: PUSH
30076: EMPTY
30077: LIST
30078: LIST
30079: PUSH
30080: LD_INT 2
30082: NEG
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: PUSH
30092: LD_INT 2
30094: NEG
30095: PUSH
30096: LD_INT 2
30098: NEG
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 3
30110: NEG
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: LD_INT 1
30121: NEG
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 3
30129: PUSH
30130: LD_INT 0
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 3
30139: PUSH
30140: LD_INT 1
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 3
30149: PUSH
30150: LD_INT 2
30152: PUSH
30153: EMPTY
30154: LIST
30155: LIST
30156: PUSH
30157: LD_INT 3
30159: PUSH
30160: LD_INT 3
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 2
30169: PUSH
30170: LD_INT 3
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 2
30179: NEG
30180: PUSH
30181: LD_INT 1
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 3
30190: NEG
30191: PUSH
30192: LD_INT 0
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 3
30201: NEG
30202: PUSH
30203: LD_INT 1
30205: NEG
30206: PUSH
30207: EMPTY
30208: LIST
30209: LIST
30210: PUSH
30211: LD_INT 3
30213: NEG
30214: PUSH
30215: LD_INT 2
30217: NEG
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 3
30225: NEG
30226: PUSH
30227: LD_INT 3
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: LIST
30265: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30266: LD_ADDR_VAR 0 42
30270: PUSH
30271: LD_INT 0
30273: PUSH
30274: LD_INT 0
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 0
30283: PUSH
30284: LD_INT 1
30286: NEG
30287: PUSH
30288: EMPTY
30289: LIST
30290: LIST
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PUSH
30302: LD_INT 1
30304: PUSH
30305: LD_INT 1
30307: PUSH
30308: EMPTY
30309: LIST
30310: LIST
30311: PUSH
30312: LD_INT 0
30314: PUSH
30315: LD_INT 1
30317: PUSH
30318: EMPTY
30319: LIST
30320: LIST
30321: PUSH
30322: LD_INT 1
30324: NEG
30325: PUSH
30326: LD_INT 0
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: LD_INT 1
30339: NEG
30340: PUSH
30341: EMPTY
30342: LIST
30343: LIST
30344: PUSH
30345: LD_INT 1
30347: NEG
30348: PUSH
30349: LD_INT 2
30351: NEG
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 0
30359: PUSH
30360: LD_INT 2
30362: NEG
30363: PUSH
30364: EMPTY
30365: LIST
30366: LIST
30367: PUSH
30368: LD_INT 1
30370: PUSH
30371: LD_INT 1
30373: NEG
30374: PUSH
30375: EMPTY
30376: LIST
30377: LIST
30378: PUSH
30379: LD_INT 2
30381: PUSH
30382: LD_INT 1
30384: PUSH
30385: EMPTY
30386: LIST
30387: LIST
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: LD_INT 2
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 2
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 0
30411: PUSH
30412: LD_INT 2
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: LD_INT 1
30425: PUSH
30426: EMPTY
30427: LIST
30428: LIST
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 2
30444: NEG
30445: PUSH
30446: LD_INT 2
30448: NEG
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 2
30456: NEG
30457: PUSH
30458: LD_INT 3
30460: NEG
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: PUSH
30466: LD_INT 1
30468: NEG
30469: PUSH
30470: LD_INT 3
30472: NEG
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 0
30480: PUSH
30481: LD_INT 3
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 3
30502: PUSH
30503: LD_INT 2
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 3
30512: PUSH
30513: LD_INT 3
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PUSH
30520: LD_INT 2
30522: PUSH
30523: LD_INT 3
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: LD_INT 3
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 0
30542: PUSH
30543: LD_INT 3
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 1
30552: NEG
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 3
30563: NEG
30564: PUSH
30565: LD_INT 2
30567: NEG
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 3
30575: NEG
30576: PUSH
30577: LD_INT 3
30579: NEG
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: LIST
30594: LIST
30595: LIST
30596: LIST
30597: LIST
30598: LIST
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30616: LD_ADDR_VAR 0 43
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: LD_INT 0
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 0
30633: PUSH
30634: LD_INT 1
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: LD_INT 1
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: LD_INT 1
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: LD_INT 0
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 1
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: LD_INT 2
30701: NEG
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: LD_INT 2
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: PUSH
30721: LD_INT 1
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: LD_INT 2
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 2
30741: PUSH
30742: LD_INT 1
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: LD_INT 2
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 0
30761: PUSH
30762: LD_INT 2
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 2
30782: NEG
30783: PUSH
30784: LD_INT 0
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 3
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 0
30817: PUSH
30818: LD_INT 3
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 1
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 3
30850: PUSH
30851: LD_INT 0
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 3
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: PUSH
30871: LD_INT 3
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 3
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: NEG
30891: PUSH
30892: LD_INT 2
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 2
30901: NEG
30902: PUSH
30903: LD_INT 1
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 3
30912: NEG
30913: PUSH
30914: LD_INT 0
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 3
30923: NEG
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: LIST
30955: LIST
30956: LIST
30957: LIST
30958: LIST
30959: LIST
30960: LIST
30961: LIST
30962: LIST
30963: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30964: LD_ADDR_VAR 0 44
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 0
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 0
30981: PUSH
30982: LD_INT 1
30984: NEG
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: LD_INT 0
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 1
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 1
31022: NEG
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: NEG
31034: PUSH
31035: LD_INT 1
31037: NEG
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: EMPTY
31052: LIST
31053: LIST
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 2
31068: PUSH
31069: LD_INT 0
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 2
31078: PUSH
31079: LD_INT 1
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 2
31088: PUSH
31089: LD_INT 2
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: LD_INT 2
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 1
31108: NEG
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 2
31119: NEG
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 2
31142: NEG
31143: PUSH
31144: LD_INT 2
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: LD_INT 3
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: LD_INT 2
31166: PUSH
31167: LD_INT 1
31169: NEG
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 3
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 3
31187: PUSH
31188: LD_INT 1
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 3
31197: PUSH
31198: LD_INT 2
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 3
31207: PUSH
31208: LD_INT 3
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: LD_INT 3
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: NEG
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 3
31238: NEG
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 3
31249: NEG
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 3
31261: NEG
31262: PUSH
31263: LD_INT 2
31265: NEG
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 3
31273: NEG
31274: PUSH
31275: LD_INT 3
31277: NEG
31278: PUSH
31279: EMPTY
31280: LIST
31281: LIST
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: LIST
31294: LIST
31295: LIST
31296: LIST
31297: LIST
31298: LIST
31299: LIST
31300: LIST
31301: LIST
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
31314: LD_ADDR_VAR 0 45
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: LD_INT 0
31331: PUSH
31332: LD_INT 1
31334: NEG
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: PUSH
31343: LD_INT 0
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 1
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: LD_INT 1
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 1
31372: NEG
31373: PUSH
31374: LD_INT 0
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 1
31383: NEG
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: LD_INT 1
31395: NEG
31396: PUSH
31397: LD_INT 2
31399: NEG
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 0
31407: PUSH
31408: LD_INT 2
31410: NEG
31411: PUSH
31412: EMPTY
31413: LIST
31414: LIST
31415: PUSH
31416: LD_INT 1
31418: PUSH
31419: LD_INT 1
31421: NEG
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 2
31429: PUSH
31430: LD_INT 1
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 2
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: LD_INT 2
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 0
31459: PUSH
31460: LD_INT 2
31462: PUSH
31463: EMPTY
31464: LIST
31465: LIST
31466: PUSH
31467: LD_INT 1
31469: NEG
31470: PUSH
31471: LD_INT 1
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 2
31480: NEG
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: EMPTY
31487: LIST
31488: LIST
31489: PUSH
31490: LD_INT 2
31492: NEG
31493: PUSH
31494: LD_INT 2
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 2
31504: NEG
31505: PUSH
31506: LD_INT 3
31508: NEG
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 3
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 0
31528: PUSH
31529: LD_INT 3
31531: NEG
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 1
31539: PUSH
31540: LD_INT 2
31542: NEG
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 3
31550: PUSH
31551: LD_INT 2
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 3
31560: PUSH
31561: LD_INT 3
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: PUSH
31568: LD_INT 2
31570: PUSH
31571: LD_INT 3
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: PUSH
31581: LD_INT 3
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 0
31590: PUSH
31591: LD_INT 3
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 1
31600: NEG
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: EMPTY
31606: LIST
31607: LIST
31608: PUSH
31609: LD_INT 3
31611: NEG
31612: PUSH
31613: LD_INT 2
31615: NEG
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 3
31623: NEG
31624: PUSH
31625: LD_INT 3
31627: NEG
31628: PUSH
31629: EMPTY
31630: LIST
31631: LIST
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
31664: LD_ADDR_VAR 0 46
31668: PUSH
31669: LD_INT 0
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: LD_INT 1
31684: NEG
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 1
31692: PUSH
31693: LD_INT 0
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 0
31712: PUSH
31713: LD_INT 1
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: PUSH
31720: LD_INT 1
31722: NEG
31723: PUSH
31724: LD_INT 0
31726: PUSH
31727: EMPTY
31728: LIST
31729: LIST
31730: PUSH
31731: LD_INT 1
31733: NEG
31734: PUSH
31735: LD_INT 1
31737: NEG
31738: PUSH
31739: EMPTY
31740: LIST
31741: LIST
31742: PUSH
31743: LD_INT 1
31745: NEG
31746: PUSH
31747: LD_INT 2
31749: NEG
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: LD_INT 2
31760: NEG
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 1
31768: PUSH
31769: LD_INT 1
31771: NEG
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 2
31789: PUSH
31790: LD_INT 1
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 0
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: NEG
31820: PUSH
31821: LD_INT 1
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 2
31830: NEG
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 2
31841: NEG
31842: PUSH
31843: LD_INT 1
31845: NEG
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 1
31853: NEG
31854: PUSH
31855: LD_INT 3
31857: NEG
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 0
31865: PUSH
31866: LD_INT 3
31868: NEG
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 1
31876: PUSH
31877: LD_INT 2
31879: NEG
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 2
31887: PUSH
31888: LD_INT 1
31890: NEG
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 3
31898: PUSH
31899: LD_INT 0
31901: PUSH
31902: EMPTY
31903: LIST
31904: LIST
31905: PUSH
31906: LD_INT 3
31908: PUSH
31909: LD_INT 1
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 1
31918: PUSH
31919: LD_INT 3
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 0
31928: PUSH
31929: LD_INT 3
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 2
31949: NEG
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 3
31960: NEG
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 3
31971: NEG
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: LIST
31985: LIST
31986: LIST
31987: LIST
31988: LIST
31989: LIST
31990: LIST
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32012: LD_ADDR_VAR 0 47
32016: PUSH
32017: LD_INT 0
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 0
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: PUSH
32041: LD_INT 0
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: LD_INT 1
32050: PUSH
32051: LD_INT 1
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: LD_INT 0
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 1
32070: NEG
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 1
32081: NEG
32082: PUSH
32083: LD_INT 1
32085: NEG
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: NEG
32094: PUSH
32095: LD_INT 2
32097: NEG
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 0
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 1
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 2
32127: NEG
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 2
32139: NEG
32140: PUSH
32141: LD_INT 2
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
32163: LD_ADDR_VAR 0 48
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: LD_INT 0
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: LD_INT 1
32183: NEG
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 1
32191: PUSH
32192: LD_INT 0
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 1
32201: PUSH
32202: LD_INT 1
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 1
32221: NEG
32222: PUSH
32223: LD_INT 0
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 1
32232: NEG
32233: PUSH
32234: LD_INT 1
32236: NEG
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: LD_INT 2
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 0
32256: PUSH
32257: LD_INT 2
32259: NEG
32260: PUSH
32261: EMPTY
32262: LIST
32263: LIST
32264: PUSH
32265: LD_INT 1
32267: PUSH
32268: LD_INT 1
32270: NEG
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 2
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: EMPTY
32283: LIST
32284: LIST
32285: PUSH
32286: LD_INT 2
32288: PUSH
32289: LD_INT 1
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
32310: LD_ADDR_VAR 0 49
32314: PUSH
32315: LD_INT 0
32317: PUSH
32318: LD_INT 0
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: LD_INT 0
32327: PUSH
32328: LD_INT 1
32330: NEG
32331: PUSH
32332: EMPTY
32333: LIST
32334: LIST
32335: PUSH
32336: LD_INT 1
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 1
32348: PUSH
32349: LD_INT 1
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 0
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 1
32368: NEG
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 1
32379: NEG
32380: PUSH
32381: LD_INT 1
32383: NEG
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 1
32391: PUSH
32392: LD_INT 1
32394: NEG
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 2
32402: PUSH
32403: LD_INT 0
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 2
32412: PUSH
32413: LD_INT 1
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: LD_INT 2
32422: PUSH
32423: LD_INT 2
32425: PUSH
32426: EMPTY
32427: LIST
32428: LIST
32429: PUSH
32430: LD_INT 1
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
32454: LD_ADDR_VAR 0 50
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: LD_INT 1
32474: NEG
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 0
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 1
32492: PUSH
32493: LD_INT 1
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 0
32502: PUSH
32503: LD_INT 1
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 1
32512: NEG
32513: PUSH
32514: LD_INT 0
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: LD_INT 1
32523: NEG
32524: PUSH
32525: LD_INT 1
32527: NEG
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: LD_INT 2
32545: PUSH
32546: LD_INT 2
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: PUSH
32556: LD_INT 2
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: LD_INT 0
32565: PUSH
32566: LD_INT 2
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 1
32575: NEG
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
32598: LD_ADDR_VAR 0 51
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: PUSH
32680: LD_INT 2
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: LD_INT 2
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 1
32699: NEG
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PUSH
32708: LD_INT 2
32710: NEG
32711: PUSH
32712: LD_INT 0
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 2
32721: NEG
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32745: LD_ADDR_VAR 0 52
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 0
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: LD_INT 0
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 1
32783: PUSH
32784: LD_INT 1
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: NEG
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: NEG
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 1
32838: NEG
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 2
32849: NEG
32850: PUSH
32851: LD_INT 0
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 2
32860: NEG
32861: PUSH
32862: LD_INT 1
32864: NEG
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: LD_INT 2
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32896: LD_ADDR_VAR 0 53
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: LD_INT 0
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 0
32913: PUSH
32914: LD_INT 1
32916: NEG
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 1
32924: PUSH
32925: LD_INT 0
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: LD_INT 1
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 0
32944: PUSH
32945: LD_INT 1
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 1
32965: NEG
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: LD_INT 1
32977: NEG
32978: PUSH
32979: LD_INT 2
32981: NEG
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 0
32989: PUSH
32990: LD_INT 2
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 1
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 2
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 2
33021: PUSH
33022: LD_INT 1
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 2
33031: PUSH
33032: LD_INT 2
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: LD_INT 2
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 0
33051: PUSH
33052: LD_INT 2
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 1
33061: NEG
33062: PUSH
33063: LD_INT 1
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 2
33072: NEG
33073: PUSH
33074: LD_INT 0
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 1
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: NEG
33096: PUSH
33097: LD_INT 2
33099: NEG
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: LIST
33117: LIST
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33126: LD_ADDR_VAR 0 54
33130: PUSH
33131: LD_INT 0
33133: PUSH
33134: LD_INT 0
33136: PUSH
33137: EMPTY
33138: LIST
33139: LIST
33140: PUSH
33141: LD_INT 0
33143: PUSH
33144: LD_INT 1
33146: NEG
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: PUSH
33155: LD_INT 0
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 0
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: NEG
33185: PUSH
33186: LD_INT 0
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: NEG
33208: PUSH
33209: LD_INT 2
33211: NEG
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 0
33219: PUSH
33220: LD_INT 2
33222: NEG
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: LD_INT 1
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 2
33241: PUSH
33242: LD_INT 0
33244: PUSH
33245: EMPTY
33246: LIST
33247: LIST
33248: PUSH
33249: LD_INT 2
33251: PUSH
33252: LD_INT 1
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 2
33261: PUSH
33262: LD_INT 2
33264: PUSH
33265: EMPTY
33266: LIST
33267: LIST
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: LD_INT 2
33274: PUSH
33275: EMPTY
33276: LIST
33277: LIST
33278: PUSH
33279: LD_INT 0
33281: PUSH
33282: LD_INT 2
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 1
33291: NEG
33292: PUSH
33293: LD_INT 1
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 2
33302: NEG
33303: PUSH
33304: LD_INT 0
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 2
33313: NEG
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 2
33325: NEG
33326: PUSH
33327: LD_INT 2
33329: NEG
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33356: LD_ADDR_VAR 0 55
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: LD_INT 0
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 0
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 1
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 1
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 0
33404: PUSH
33405: LD_INT 1
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: LD_INT 0
33418: PUSH
33419: EMPTY
33420: LIST
33421: LIST
33422: PUSH
33423: LD_INT 1
33425: NEG
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: NEG
33438: PUSH
33439: LD_INT 2
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 0
33449: PUSH
33450: LD_INT 2
33452: NEG
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 1
33460: PUSH
33461: LD_INT 1
33463: NEG
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 2
33471: PUSH
33472: LD_INT 0
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 2
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 2
33491: PUSH
33492: LD_INT 2
33494: PUSH
33495: EMPTY
33496: LIST
33497: LIST
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: LD_INT 2
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 0
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 1
33521: NEG
33522: PUSH
33523: LD_INT 1
33525: PUSH
33526: EMPTY
33527: LIST
33528: LIST
33529: PUSH
33530: LD_INT 2
33532: NEG
33533: PUSH
33534: LD_INT 0
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: LD_INT 1
33547: NEG
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 2
33555: NEG
33556: PUSH
33557: LD_INT 2
33559: NEG
33560: PUSH
33561: EMPTY
33562: LIST
33563: LIST
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33586: LD_ADDR_VAR 0 56
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: LD_INT 0
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 0
33603: PUSH
33604: LD_INT 1
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 1
33614: PUSH
33615: LD_INT 0
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: LD_INT 1
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: PUSH
33657: LD_INT 1
33659: NEG
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 1
33667: NEG
33668: PUSH
33669: LD_INT 2
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: LD_INT 2
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 2
33701: PUSH
33702: LD_INT 0
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 2
33711: PUSH
33712: LD_INT 1
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: PUSH
33719: LD_INT 2
33721: PUSH
33722: LD_INT 2
33724: PUSH
33725: EMPTY
33726: LIST
33727: LIST
33728: PUSH
33729: LD_INT 1
33731: PUSH
33732: LD_INT 2
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 0
33741: PUSH
33742: LD_INT 2
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: NEG
33752: PUSH
33753: LD_INT 1
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 2
33762: NEG
33763: PUSH
33764: LD_INT 0
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 2
33773: NEG
33774: PUSH
33775: LD_INT 1
33777: NEG
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 2
33785: NEG
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: LIST
33799: LIST
33800: LIST
33801: LIST
33802: LIST
33803: LIST
33804: LIST
33805: LIST
33806: LIST
33807: LIST
33808: LIST
33809: LIST
33810: LIST
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33816: LD_ADDR_VAR 0 57
33820: PUSH
33821: LD_INT 0
33823: PUSH
33824: LD_INT 0
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: LD_INT 0
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 1
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: LD_INT 1
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: LD_INT 0
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 1
33885: NEG
33886: PUSH
33887: LD_INT 1
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: NEG
33898: PUSH
33899: LD_INT 2
33901: NEG
33902: PUSH
33903: EMPTY
33904: LIST
33905: LIST
33906: PUSH
33907: LD_INT 0
33909: PUSH
33910: LD_INT 2
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: LD_INT 0
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: LD_INT 1
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 2
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 2
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 0
33971: PUSH
33972: LD_INT 2
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 1
33981: NEG
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 2
33992: NEG
33993: PUSH
33994: LD_INT 0
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 2
34003: NEG
34004: PUSH
34005: LD_INT 1
34007: NEG
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: NEG
34016: PUSH
34017: LD_INT 2
34019: NEG
34020: PUSH
34021: EMPTY
34022: LIST
34023: LIST
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: LIST
34029: LIST
34030: LIST
34031: LIST
34032: LIST
34033: LIST
34034: LIST
34035: LIST
34036: LIST
34037: LIST
34038: LIST
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34046: LD_ADDR_VAR 0 58
34050: PUSH
34051: LD_INT 0
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 0
34063: PUSH
34064: LD_INT 1
34066: NEG
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: LD_INT 1
34074: PUSH
34075: LD_INT 0
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 0
34094: PUSH
34095: LD_INT 1
34097: PUSH
34098: EMPTY
34099: LIST
34100: LIST
34101: PUSH
34102: LD_INT 1
34104: NEG
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 1
34115: NEG
34116: PUSH
34117: LD_INT 1
34119: NEG
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: LD_INT 2
34131: NEG
34132: PUSH
34133: EMPTY
34134: LIST
34135: LIST
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 2
34142: NEG
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: PUSH
34151: LD_INT 1
34153: NEG
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: EMPTY
34166: LIST
34167: LIST
34168: PUSH
34169: LD_INT 2
34171: PUSH
34172: LD_INT 1
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: PUSH
34179: LD_INT 2
34181: PUSH
34182: LD_INT 2
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 1
34191: PUSH
34192: LD_INT 2
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 0
34201: PUSH
34202: LD_INT 2
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: LD_INT 2
34222: NEG
34223: PUSH
34224: LD_INT 0
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: PUSH
34231: LD_INT 2
34233: NEG
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: EMPTY
34240: LIST
34241: LIST
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: LD_INT 2
34249: NEG
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34276: LD_ADDR_VAR 0 59
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: LD_INT 1
34296: NEG
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 1
34304: PUSH
34305: LD_INT 0
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: LD_INT 1
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 1
34334: NEG
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: LIST
34359: LIST
34360: LIST
34361: LIST
34362: LIST
34363: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34364: LD_ADDR_VAR 0 60
34368: PUSH
34369: LD_INT 0
34371: PUSH
34372: LD_INT 0
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 0
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: EMPTY
34387: LIST
34388: LIST
34389: PUSH
34390: LD_INT 1
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 1
34402: PUSH
34403: LD_INT 1
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: LD_INT 1
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: LIST
34451: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34452: LD_ADDR_VAR 0 61
34456: PUSH
34457: LD_INT 0
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 0
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: EMPTY
34475: LIST
34476: LIST
34477: PUSH
34478: LD_INT 1
34480: PUSH
34481: LD_INT 0
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 1
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: LD_INT 0
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: EMPTY
34505: LIST
34506: LIST
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: LD_INT 0
34514: PUSH
34515: EMPTY
34516: LIST
34517: LIST
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: LD_INT 1
34525: NEG
34526: PUSH
34527: EMPTY
34528: LIST
34529: LIST
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34540: LD_ADDR_VAR 0 62
34544: PUSH
34545: LD_INT 0
34547: PUSH
34548: LD_INT 0
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: LD_INT 1
34560: NEG
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: LD_INT 0
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 0
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: EMPTY
34604: LIST
34605: LIST
34606: PUSH
34607: LD_INT 1
34609: NEG
34610: PUSH
34611: LD_INT 1
34613: NEG
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34628: LD_ADDR_VAR 0 63
34632: PUSH
34633: LD_INT 0
34635: PUSH
34636: LD_INT 0
34638: PUSH
34639: EMPTY
34640: LIST
34641: LIST
34642: PUSH
34643: LD_INT 0
34645: PUSH
34646: LD_INT 1
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 0
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 1
34666: PUSH
34667: LD_INT 1
34669: PUSH
34670: EMPTY
34671: LIST
34672: LIST
34673: PUSH
34674: LD_INT 0
34676: PUSH
34677: LD_INT 1
34679: PUSH
34680: EMPTY
34681: LIST
34682: LIST
34683: PUSH
34684: LD_INT 1
34686: NEG
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 1
34697: NEG
34698: PUSH
34699: LD_INT 1
34701: NEG
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
34716: LD_ADDR_VAR 0 64
34720: PUSH
34721: LD_INT 0
34723: PUSH
34724: LD_INT 0
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 0
34733: PUSH
34734: LD_INT 1
34736: NEG
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: EMPTY
34749: LIST
34750: LIST
34751: PUSH
34752: LD_INT 1
34754: PUSH
34755: LD_INT 1
34757: PUSH
34758: EMPTY
34759: LIST
34760: LIST
34761: PUSH
34762: LD_INT 0
34764: PUSH
34765: LD_INT 1
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 1
34774: NEG
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 1
34789: NEG
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: EMPTY
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: ST_TO_ADDR
// end ; 1 :
34804: GO 40701
34806: LD_INT 1
34808: DOUBLE
34809: EQUAL
34810: IFTRUE 34814
34812: GO 37437
34814: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
34815: LD_ADDR_VAR 0 11
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: LD_INT 3
34826: NEG
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PUSH
34832: LD_INT 0
34834: PUSH
34835: LD_INT 3
34837: NEG
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 1
34845: PUSH
34846: LD_INT 2
34848: NEG
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: LIST
34858: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
34859: LD_ADDR_VAR 0 12
34863: PUSH
34864: LD_INT 2
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 3
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 3
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: LIST
34899: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
34900: LD_ADDR_VAR 0 13
34904: PUSH
34905: LD_INT 3
34907: PUSH
34908: LD_INT 2
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 3
34917: PUSH
34918: LD_INT 3
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 3
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: EMPTY
34936: LIST
34937: LIST
34938: LIST
34939: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
34940: LD_ADDR_VAR 0 14
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: LD_INT 3
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: LD_INT 3
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: NEG
34968: PUSH
34969: LD_INT 2
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: LIST
34980: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
34981: LD_ADDR_VAR 0 15
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 3
34999: NEG
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 3
35010: NEG
35011: PUSH
35012: LD_INT 1
35014: NEG
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: LIST
35024: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35025: LD_ADDR_VAR 0 16
35029: PUSH
35030: LD_INT 2
35032: NEG
35033: PUSH
35034: LD_INT 3
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: LD_INT 2
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 3
35056: NEG
35057: PUSH
35058: LD_INT 3
35060: NEG
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: LIST
35070: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
35071: LD_ADDR_VAR 0 17
35075: PUSH
35076: LD_INT 1
35078: NEG
35079: PUSH
35080: LD_INT 3
35082: NEG
35083: PUSH
35084: EMPTY
35085: LIST
35086: LIST
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: LD_INT 3
35093: NEG
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: LD_INT 2
35104: NEG
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: LIST
35114: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
35115: LD_ADDR_VAR 0 18
35119: PUSH
35120: LD_INT 2
35122: PUSH
35123: LD_INT 1
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 3
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 3
35143: PUSH
35144: LD_INT 1
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: LIST
35155: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
35156: LD_ADDR_VAR 0 19
35160: PUSH
35161: LD_INT 3
35163: PUSH
35164: LD_INT 2
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 3
35173: PUSH
35174: LD_INT 3
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 2
35183: PUSH
35184: LD_INT 3
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: EMPTY
35192: LIST
35193: LIST
35194: LIST
35195: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
35196: LD_ADDR_VAR 0 20
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 3
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 0
35213: PUSH
35214: LD_INT 3
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: NEG
35224: PUSH
35225: LD_INT 2
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: LIST
35236: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35237: LD_ADDR_VAR 0 21
35241: PUSH
35242: LD_INT 2
35244: NEG
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 3
35255: NEG
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 3
35266: NEG
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35281: LD_ADDR_VAR 0 22
35285: PUSH
35286: LD_INT 2
35288: NEG
35289: PUSH
35290: LD_INT 3
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 3
35300: NEG
35301: PUSH
35302: LD_INT 2
35304: NEG
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 3
35312: NEG
35313: PUSH
35314: LD_INT 3
35316: NEG
35317: PUSH
35318: EMPTY
35319: LIST
35320: LIST
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: LIST
35326: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
35327: LD_ADDR_VAR 0 23
35331: PUSH
35332: LD_INT 0
35334: PUSH
35335: LD_INT 3
35337: NEG
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 4
35349: NEG
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: LD_INT 3
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: LIST
35370: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
35371: LD_ADDR_VAR 0 24
35375: PUSH
35376: LD_INT 3
35378: PUSH
35379: LD_INT 0
35381: PUSH
35382: EMPTY
35383: LIST
35384: LIST
35385: PUSH
35386: LD_INT 3
35388: PUSH
35389: LD_INT 1
35391: NEG
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 4
35399: PUSH
35400: LD_INT 1
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: LIST
35411: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
35412: LD_ADDR_VAR 0 25
35416: PUSH
35417: LD_INT 3
35419: PUSH
35420: LD_INT 3
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: LD_INT 4
35429: PUSH
35430: LD_INT 3
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 3
35439: PUSH
35440: LD_INT 4
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
35452: LD_ADDR_VAR 0 26
35456: PUSH
35457: LD_INT 0
35459: PUSH
35460: LD_INT 3
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: LD_INT 4
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: LD_INT 3
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: LIST
35492: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
35493: LD_ADDR_VAR 0 27
35497: PUSH
35498: LD_INT 3
35500: NEG
35501: PUSH
35502: LD_INT 0
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 3
35511: NEG
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 4
35522: NEG
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: EMPTY
35533: LIST
35534: LIST
35535: LIST
35536: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
35537: LD_ADDR_VAR 0 28
35541: PUSH
35542: LD_INT 3
35544: NEG
35545: PUSH
35546: LD_INT 3
35548: NEG
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 3
35556: NEG
35557: PUSH
35558: LD_INT 4
35560: NEG
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 4
35568: NEG
35569: PUSH
35570: LD_INT 3
35572: NEG
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: EMPTY
35579: LIST
35580: LIST
35581: LIST
35582: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
35583: LD_ADDR_VAR 0 29
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: LD_INT 3
35594: NEG
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 0
35602: PUSH
35603: LD_INT 3
35605: NEG
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 1
35613: PUSH
35614: LD_INT 2
35616: NEG
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: LD_INT 4
35628: NEG
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: LD_INT 4
35639: NEG
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: LD_INT 1
35647: PUSH
35648: LD_INT 3
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: NEG
35659: PUSH
35660: LD_INT 5
35662: NEG
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 0
35670: PUSH
35671: LD_INT 5
35673: NEG
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 1
35681: PUSH
35682: LD_INT 4
35684: NEG
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: NEG
35693: PUSH
35694: LD_INT 6
35696: NEG
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 0
35704: PUSH
35705: LD_INT 6
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: PUSH
35716: LD_INT 5
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
35738: LD_ADDR_VAR 0 30
35742: PUSH
35743: LD_INT 2
35745: PUSH
35746: LD_INT 1
35748: NEG
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: PUSH
35754: LD_INT 3
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 3
35766: PUSH
35767: LD_INT 1
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 3
35776: PUSH
35777: LD_INT 1
35779: NEG
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 4
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 4
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 4
35807: PUSH
35808: LD_INT 1
35810: NEG
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 5
35818: PUSH
35819: LD_INT 0
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 5
35828: PUSH
35829: LD_INT 1
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 5
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 6
35849: PUSH
35850: LD_INT 0
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 6
35859: PUSH
35860: LD_INT 1
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: LIST
35879: LIST
35880: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
35881: LD_ADDR_VAR 0 31
35885: PUSH
35886: LD_INT 3
35888: PUSH
35889: LD_INT 2
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 3
35898: PUSH
35899: LD_INT 3
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 3
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 4
35918: PUSH
35919: LD_INT 3
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 4
35928: PUSH
35929: LD_INT 4
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 3
35938: PUSH
35939: LD_INT 4
35941: PUSH
35942: EMPTY
35943: LIST
35944: LIST
35945: PUSH
35946: LD_INT 5
35948: PUSH
35949: LD_INT 4
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: PUSH
35956: LD_INT 5
35958: PUSH
35959: LD_INT 5
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: LD_INT 4
35968: PUSH
35969: LD_INT 5
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 6
35978: PUSH
35979: LD_INT 5
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 6
35988: PUSH
35989: LD_INT 6
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 5
35998: PUSH
35999: LD_INT 6
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: LIST
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
36020: LD_ADDR_VAR 0 32
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: LD_INT 3
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: LD_INT 3
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 1
36047: NEG
36048: PUSH
36049: LD_INT 2
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 1
36058: PUSH
36059: LD_INT 4
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: LD_INT 4
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 1
36078: NEG
36079: PUSH
36080: LD_INT 3
36082: PUSH
36083: EMPTY
36084: LIST
36085: LIST
36086: PUSH
36087: LD_INT 1
36089: PUSH
36090: LD_INT 5
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: LD_INT 5
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: LD_INT 4
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 6
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: LD_INT 6
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 1
36140: NEG
36141: PUSH
36142: LD_INT 5
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
36163: LD_ADDR_VAR 0 33
36167: PUSH
36168: LD_INT 2
36170: NEG
36171: PUSH
36172: LD_INT 1
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 3
36181: NEG
36182: PUSH
36183: LD_INT 0
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 3
36192: NEG
36193: PUSH
36194: LD_INT 1
36196: NEG
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 3
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 4
36215: NEG
36216: PUSH
36217: LD_INT 0
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 4
36226: NEG
36227: PUSH
36228: LD_INT 1
36230: NEG
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 4
36238: NEG
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 5
36249: NEG
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 5
36260: NEG
36261: PUSH
36262: LD_INT 1
36264: NEG
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 5
36272: NEG
36273: PUSH
36274: LD_INT 1
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 6
36283: NEG
36284: PUSH
36285: LD_INT 0
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 6
36294: NEG
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
36318: LD_ADDR_VAR 0 34
36322: PUSH
36323: LD_INT 2
36325: NEG
36326: PUSH
36327: LD_INT 3
36329: NEG
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: LD_INT 2
36341: NEG
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 3
36349: NEG
36350: PUSH
36351: LD_INT 3
36353: NEG
36354: PUSH
36355: EMPTY
36356: LIST
36357: LIST
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: LD_INT 4
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 4
36373: NEG
36374: PUSH
36375: LD_INT 3
36377: NEG
36378: PUSH
36379: EMPTY
36380: LIST
36381: LIST
36382: PUSH
36383: LD_INT 4
36385: NEG
36386: PUSH
36387: LD_INT 4
36389: NEG
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 4
36397: NEG
36398: PUSH
36399: LD_INT 5
36401: NEG
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 5
36409: NEG
36410: PUSH
36411: LD_INT 4
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 5
36421: NEG
36422: PUSH
36423: LD_INT 5
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 5
36433: NEG
36434: PUSH
36435: LD_INT 6
36437: NEG
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 6
36445: NEG
36446: PUSH
36447: LD_INT 5
36449: NEG
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 6
36457: NEG
36458: PUSH
36459: LD_INT 6
36461: NEG
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
36481: LD_ADDR_VAR 0 41
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 2
36491: NEG
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 1
36499: NEG
36500: PUSH
36501: LD_INT 3
36503: NEG
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: PUSH
36512: LD_INT 2
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: LIST
36524: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
36525: LD_ADDR_VAR 0 42
36529: PUSH
36530: LD_INT 2
36532: PUSH
36533: LD_INT 0
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 2
36542: PUSH
36543: LD_INT 1
36545: NEG
36546: PUSH
36547: EMPTY
36548: LIST
36549: LIST
36550: PUSH
36551: LD_INT 3
36553: PUSH
36554: LD_INT 1
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: EMPTY
36562: LIST
36563: LIST
36564: LIST
36565: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
36566: LD_ADDR_VAR 0 43
36570: PUSH
36571: LD_INT 2
36573: PUSH
36574: LD_INT 2
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 3
36583: PUSH
36584: LD_INT 2
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 2
36593: PUSH
36594: LD_INT 3
36596: PUSH
36597: EMPTY
36598: LIST
36599: LIST
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: LIST
36605: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
36606: LD_ADDR_VAR 0 44
36610: PUSH
36611: LD_INT 0
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: LD_INT 3
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: NEG
36634: PUSH
36635: LD_INT 2
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: LIST
36646: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36647: LD_ADDR_VAR 0 45
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: LD_INT 0
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 2
36665: NEG
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 3
36676: NEG
36677: PUSH
36678: LD_INT 1
36680: NEG
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: LIST
36690: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
36691: LD_ADDR_VAR 0 46
36695: PUSH
36696: LD_INT 2
36698: NEG
36699: PUSH
36700: LD_INT 2
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: NEG
36711: PUSH
36712: LD_INT 3
36714: NEG
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 3
36722: NEG
36723: PUSH
36724: LD_INT 2
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: LIST
36736: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
36737: LD_ADDR_VAR 0 47
36741: PUSH
36742: LD_INT 2
36744: NEG
36745: PUSH
36746: LD_INT 3
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 1
36756: NEG
36757: PUSH
36758: LD_INT 3
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
36770: LD_ADDR_VAR 0 48
36774: PUSH
36775: LD_INT 1
36777: PUSH
36778: LD_INT 2
36780: NEG
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 2
36788: PUSH
36789: LD_INT 1
36791: NEG
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: EMPTY
36798: LIST
36799: LIST
36800: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
36801: LD_ADDR_VAR 0 49
36805: PUSH
36806: LD_INT 3
36808: PUSH
36809: LD_INT 1
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 3
36818: PUSH
36819: LD_INT 2
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
36830: LD_ADDR_VAR 0 50
36834: PUSH
36835: LD_INT 2
36837: PUSH
36838: LD_INT 3
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: LD_INT 3
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
36859: LD_ADDR_VAR 0 51
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 2
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 2
36877: NEG
36878: PUSH
36879: LD_INT 1
36881: PUSH
36882: EMPTY
36883: LIST
36884: LIST
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36890: LD_ADDR_VAR 0 52
36894: PUSH
36895: LD_INT 3
36897: NEG
36898: PUSH
36899: LD_INT 1
36901: NEG
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 3
36909: NEG
36910: PUSH
36911: LD_INT 2
36913: NEG
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
36923: LD_ADDR_VAR 0 53
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: LD_INT 3
36934: NEG
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: LD_INT 3
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 1
36953: PUSH
36954: LD_INT 2
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: LIST
36966: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
36967: LD_ADDR_VAR 0 54
36971: PUSH
36972: LD_INT 2
36974: PUSH
36975: LD_INT 1
36977: NEG
36978: PUSH
36979: EMPTY
36980: LIST
36981: LIST
36982: PUSH
36983: LD_INT 3
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 3
36995: PUSH
36996: LD_INT 1
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
37008: LD_ADDR_VAR 0 55
37012: PUSH
37013: LD_INT 3
37015: PUSH
37016: LD_INT 2
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 3
37025: PUSH
37026: LD_INT 3
37028: PUSH
37029: EMPTY
37030: LIST
37031: LIST
37032: PUSH
37033: LD_INT 2
37035: PUSH
37036: LD_INT 3
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: LIST
37047: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
37048: LD_ADDR_VAR 0 56
37052: PUSH
37053: LD_INT 1
37055: PUSH
37056: LD_INT 3
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: LD_INT 3
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 1
37075: NEG
37076: PUSH
37077: LD_INT 2
37079: PUSH
37080: EMPTY
37081: LIST
37082: LIST
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: LIST
37088: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37089: LD_ADDR_VAR 0 57
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: LD_INT 1
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 3
37107: NEG
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 3
37118: NEG
37119: PUSH
37120: LD_INT 1
37122: NEG
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: LIST
37132: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37133: LD_ADDR_VAR 0 58
37137: PUSH
37138: LD_INT 2
37140: NEG
37141: PUSH
37142: LD_INT 3
37144: NEG
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 3
37152: NEG
37153: PUSH
37154: LD_INT 2
37156: NEG
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 3
37164: NEG
37165: PUSH
37166: LD_INT 3
37168: NEG
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: LIST
37178: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
37179: LD_ADDR_VAR 0 59
37183: PUSH
37184: LD_INT 1
37186: NEG
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PUSH
37196: LD_INT 0
37198: PUSH
37199: LD_INT 2
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: LIST
37222: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37223: LD_ADDR_VAR 0 60
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: LD_INT 1
37233: NEG
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 2
37241: PUSH
37242: LD_INT 0
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 2
37251: PUSH
37252: LD_INT 1
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: LIST
37263: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37264: LD_ADDR_VAR 0 61
37268: PUSH
37269: LD_INT 2
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 2
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 1
37291: PUSH
37292: LD_INT 2
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: LIST
37303: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37304: LD_ADDR_VAR 0 62
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 1
37331: NEG
37332: PUSH
37333: LD_INT 1
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: LIST
37344: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37345: LD_ADDR_VAR 0 63
37349: PUSH
37350: LD_INT 1
37352: NEG
37353: PUSH
37354: LD_INT 1
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 2
37363: NEG
37364: PUSH
37365: LD_INT 0
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 2
37374: NEG
37375: PUSH
37376: LD_INT 1
37378: NEG
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: LIST
37388: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37389: LD_ADDR_VAR 0 64
37393: PUSH
37394: LD_INT 1
37396: NEG
37397: PUSH
37398: LD_INT 2
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: LD_INT 1
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: LD_INT 2
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: LIST
37434: ST_TO_ADDR
// end ; 2 :
37435: GO 40701
37437: LD_INT 2
37439: DOUBLE
37440: EQUAL
37441: IFTRUE 37445
37443: GO 40700
37445: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
37446: LD_ADDR_VAR 0 29
37450: PUSH
37451: LD_INT 4
37453: PUSH
37454: LD_INT 0
37456: PUSH
37457: EMPTY
37458: LIST
37459: LIST
37460: PUSH
37461: LD_INT 4
37463: PUSH
37464: LD_INT 1
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 5
37474: PUSH
37475: LD_INT 0
37477: PUSH
37478: EMPTY
37479: LIST
37480: LIST
37481: PUSH
37482: LD_INT 5
37484: PUSH
37485: LD_INT 1
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 4
37494: PUSH
37495: LD_INT 1
37497: PUSH
37498: EMPTY
37499: LIST
37500: LIST
37501: PUSH
37502: LD_INT 3
37504: PUSH
37505: LD_INT 0
37507: PUSH
37508: EMPTY
37509: LIST
37510: LIST
37511: PUSH
37512: LD_INT 3
37514: PUSH
37515: LD_INT 1
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 3
37525: PUSH
37526: LD_INT 2
37528: NEG
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: PUSH
37534: LD_INT 5
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 3
37546: PUSH
37547: LD_INT 3
37549: PUSH
37550: EMPTY
37551: LIST
37552: LIST
37553: PUSH
37554: LD_INT 3
37556: PUSH
37557: LD_INT 2
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 4
37566: PUSH
37567: LD_INT 3
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 4
37576: PUSH
37577: LD_INT 4
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: LD_INT 4
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 2
37596: PUSH
37597: LD_INT 3
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 2
37606: PUSH
37607: LD_INT 2
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 4
37616: PUSH
37617: LD_INT 2
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 2
37626: PUSH
37627: LD_INT 4
37629: PUSH
37630: EMPTY
37631: LIST
37632: LIST
37633: PUSH
37634: LD_INT 0
37636: PUSH
37637: LD_INT 4
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 0
37646: PUSH
37647: LD_INT 3
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: LD_INT 4
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 1
37666: PUSH
37667: LD_INT 5
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 0
37676: PUSH
37677: LD_INT 5
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 1
37686: NEG
37687: PUSH
37688: LD_INT 4
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 3
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 2
37708: PUSH
37709: LD_INT 5
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: PUSH
37716: LD_INT 2
37718: NEG
37719: PUSH
37720: LD_INT 3
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 3
37729: NEG
37730: PUSH
37731: LD_INT 0
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 3
37740: NEG
37741: PUSH
37742: LD_INT 1
37744: NEG
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 2
37752: NEG
37753: PUSH
37754: LD_INT 0
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 2
37763: NEG
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: EMPTY
37769: LIST
37770: LIST
37771: PUSH
37772: LD_INT 3
37774: NEG
37775: PUSH
37776: LD_INT 1
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 4
37785: NEG
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 4
37796: NEG
37797: PUSH
37798: LD_INT 1
37800: NEG
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 4
37808: NEG
37809: PUSH
37810: LD_INT 2
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 2
37820: NEG
37821: PUSH
37822: LD_INT 2
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 4
37831: NEG
37832: PUSH
37833: LD_INT 4
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 4
37843: NEG
37844: PUSH
37845: LD_INT 5
37847: NEG
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 3
37855: NEG
37856: PUSH
37857: LD_INT 4
37859: NEG
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 3
37867: NEG
37868: PUSH
37869: LD_INT 3
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 4
37879: NEG
37880: PUSH
37881: LD_INT 3
37883: NEG
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 5
37891: NEG
37892: PUSH
37893: LD_INT 4
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 5
37903: NEG
37904: PUSH
37905: LD_INT 5
37907: NEG
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 3
37915: NEG
37916: PUSH
37917: LD_INT 5
37919: NEG
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 5
37927: NEG
37928: PUSH
37929: LD_INT 3
37931: NEG
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: LIST
37970: LIST
37971: LIST
37972: LIST
37973: LIST
37974: LIST
37975: LIST
37976: LIST
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
37984: LD_ADDR_VAR 0 30
37988: PUSH
37989: LD_INT 4
37991: PUSH
37992: LD_INT 4
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 4
38001: PUSH
38002: LD_INT 3
38004: PUSH
38005: EMPTY
38006: LIST
38007: LIST
38008: PUSH
38009: LD_INT 5
38011: PUSH
38012: LD_INT 4
38014: PUSH
38015: EMPTY
38016: LIST
38017: LIST
38018: PUSH
38019: LD_INT 5
38021: PUSH
38022: LD_INT 5
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 4
38031: PUSH
38032: LD_INT 5
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 3
38041: PUSH
38042: LD_INT 4
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 3
38051: PUSH
38052: LD_INT 3
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: LD_INT 5
38061: PUSH
38062: LD_INT 3
38064: PUSH
38065: EMPTY
38066: LIST
38067: LIST
38068: PUSH
38069: LD_INT 3
38071: PUSH
38072: LD_INT 5
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: LD_INT 3
38084: PUSH
38085: EMPTY
38086: LIST
38087: LIST
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: LD_INT 2
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 3
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: LD_INT 1
38111: PUSH
38112: LD_INT 4
38114: PUSH
38115: EMPTY
38116: LIST
38117: LIST
38118: PUSH
38119: LD_INT 0
38121: PUSH
38122: LD_INT 4
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: NEG
38132: PUSH
38133: LD_INT 3
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: LD_INT 2
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 2
38153: PUSH
38154: LD_INT 4
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 4
38174: NEG
38175: PUSH
38176: LD_INT 0
38178: PUSH
38179: EMPTY
38180: LIST
38181: LIST
38182: PUSH
38183: LD_INT 4
38185: NEG
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 3
38197: NEG
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: LD_INT 3
38208: NEG
38209: PUSH
38210: LD_INT 1
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 4
38219: NEG
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 5
38230: NEG
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 5
38241: NEG
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 5
38253: NEG
38254: PUSH
38255: LD_INT 2
38257: NEG
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 3
38265: NEG
38266: PUSH
38267: LD_INT 2
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 3
38276: NEG
38277: PUSH
38278: LD_INT 3
38280: NEG
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 3
38288: NEG
38289: PUSH
38290: LD_INT 4
38292: NEG
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: NEG
38301: PUSH
38302: LD_INT 3
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: LD_INT 2
38316: NEG
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: PUSH
38322: LD_INT 3
38324: NEG
38325: PUSH
38326: LD_INT 2
38328: NEG
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 4
38336: NEG
38337: PUSH
38338: LD_INT 3
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 4
38348: NEG
38349: PUSH
38350: LD_INT 4
38352: NEG
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 2
38360: NEG
38361: PUSH
38362: LD_INT 4
38364: NEG
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 4
38372: NEG
38373: PUSH
38374: LD_INT 2
38376: NEG
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 0
38384: PUSH
38385: LD_INT 4
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 0
38395: PUSH
38396: LD_INT 5
38398: NEG
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 1
38406: PUSH
38407: LD_INT 4
38409: NEG
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 1
38417: PUSH
38418: LD_INT 3
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: LD_INT 3
38431: NEG
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 1
38439: NEG
38440: PUSH
38441: LD_INT 4
38443: NEG
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: PUSH
38449: LD_INT 1
38451: NEG
38452: PUSH
38453: LD_INT 5
38455: NEG
38456: PUSH
38457: EMPTY
38458: LIST
38459: LIST
38460: PUSH
38461: LD_INT 2
38463: PUSH
38464: LD_INT 3
38466: NEG
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 2
38474: NEG
38475: PUSH
38476: LD_INT 5
38478: NEG
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: EMPTY
38485: LIST
38486: LIST
38487: LIST
38488: LIST
38489: LIST
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
38531: LD_ADDR_VAR 0 31
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: LD_INT 4
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 0
38548: PUSH
38549: LD_INT 3
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 4
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 5
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: LD_INT 5
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: LD_INT 4
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 1
38599: NEG
38600: PUSH
38601: LD_INT 3
38603: PUSH
38604: EMPTY
38605: LIST
38606: LIST
38607: PUSH
38608: LD_INT 2
38610: PUSH
38611: LD_INT 5
38613: PUSH
38614: EMPTY
38615: LIST
38616: LIST
38617: PUSH
38618: LD_INT 2
38620: NEG
38621: PUSH
38622: LD_INT 3
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 3
38631: NEG
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 3
38642: NEG
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 2
38654: NEG
38655: PUSH
38656: LD_INT 0
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 2
38665: NEG
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 3
38676: NEG
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 4
38687: NEG
38688: PUSH
38689: LD_INT 0
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 4
38698: NEG
38699: PUSH
38700: LD_INT 1
38702: NEG
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 4
38710: NEG
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: EMPTY
38717: LIST
38718: LIST
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: LD_INT 2
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: PUSH
38731: LD_INT 4
38733: NEG
38734: PUSH
38735: LD_INT 4
38737: NEG
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 4
38745: NEG
38746: PUSH
38747: LD_INT 5
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 3
38757: NEG
38758: PUSH
38759: LD_INT 4
38761: NEG
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 3
38769: NEG
38770: PUSH
38771: LD_INT 3
38773: NEG
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 4
38781: NEG
38782: PUSH
38783: LD_INT 3
38785: NEG
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 5
38793: NEG
38794: PUSH
38795: LD_INT 4
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 5
38805: NEG
38806: PUSH
38807: LD_INT 5
38809: NEG
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 3
38817: NEG
38818: PUSH
38819: LD_INT 5
38821: NEG
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 5
38829: NEG
38830: PUSH
38831: LD_INT 3
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: LD_INT 3
38844: NEG
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 0
38852: PUSH
38853: LD_INT 4
38855: NEG
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 1
38863: PUSH
38864: LD_INT 3
38866: NEG
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: LD_INT 2
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 0
38885: PUSH
38886: LD_INT 2
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: LD_INT 3
38900: NEG
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 4
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 2
38923: NEG
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 2
38931: NEG
38932: PUSH
38933: LD_INT 4
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 4
38943: PUSH
38944: LD_INT 0
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 4
38953: PUSH
38954: LD_INT 1
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 5
38964: PUSH
38965: LD_INT 0
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 5
38974: PUSH
38975: LD_INT 1
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 4
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 3
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 3
39004: PUSH
39005: LD_INT 1
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 3
39015: PUSH
39016: LD_INT 2
39018: NEG
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 5
39026: PUSH
39027: LD_INT 2
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: LIST
39038: LIST
39039: LIST
39040: LIST
39041: LIST
39042: LIST
39043: LIST
39044: LIST
39045: LIST
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
39081: LD_ADDR_VAR 0 32
39085: PUSH
39086: LD_INT 4
39088: NEG
39089: PUSH
39090: LD_INT 0
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 4
39099: NEG
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 3
39111: NEG
39112: PUSH
39113: LD_INT 0
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: PUSH
39120: LD_INT 3
39122: NEG
39123: PUSH
39124: LD_INT 1
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PUSH
39131: LD_INT 4
39133: NEG
39134: PUSH
39135: LD_INT 1
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 5
39144: NEG
39145: PUSH
39146: LD_INT 0
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 5
39155: NEG
39156: PUSH
39157: LD_INT 1
39159: NEG
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 5
39167: NEG
39168: PUSH
39169: LD_INT 2
39171: NEG
39172: PUSH
39173: EMPTY
39174: LIST
39175: LIST
39176: PUSH
39177: LD_INT 3
39179: NEG
39180: PUSH
39181: LD_INT 2
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 3
39190: NEG
39191: PUSH
39192: LD_INT 3
39194: NEG
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 3
39202: NEG
39203: PUSH
39204: LD_INT 4
39206: NEG
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: LD_INT 3
39218: NEG
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: PUSH
39224: LD_INT 2
39226: NEG
39227: PUSH
39228: LD_INT 2
39230: NEG
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 3
39238: NEG
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 4
39250: NEG
39251: PUSH
39252: LD_INT 3
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 4
39262: NEG
39263: PUSH
39264: LD_INT 4
39266: NEG
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 2
39274: NEG
39275: PUSH
39276: LD_INT 4
39278: NEG
39279: PUSH
39280: EMPTY
39281: LIST
39282: LIST
39283: PUSH
39284: LD_INT 4
39286: NEG
39287: PUSH
39288: LD_INT 2
39290: NEG
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 0
39298: PUSH
39299: LD_INT 4
39301: NEG
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: LD_INT 5
39312: NEG
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 1
39320: PUSH
39321: LD_INT 4
39323: NEG
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 1
39331: PUSH
39332: LD_INT 3
39334: NEG
39335: PUSH
39336: EMPTY
39337: LIST
39338: LIST
39339: PUSH
39340: LD_INT 0
39342: PUSH
39343: LD_INT 3
39345: NEG
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 1
39353: NEG
39354: PUSH
39355: LD_INT 4
39357: NEG
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 1
39365: NEG
39366: PUSH
39367: LD_INT 5
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 2
39377: PUSH
39378: LD_INT 3
39380: NEG
39381: PUSH
39382: EMPTY
39383: LIST
39384: LIST
39385: PUSH
39386: LD_INT 2
39388: NEG
39389: PUSH
39390: LD_INT 5
39392: NEG
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 3
39400: PUSH
39401: LD_INT 0
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 3
39410: PUSH
39411: LD_INT 1
39413: NEG
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 4
39421: PUSH
39422: LD_INT 0
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 4
39431: PUSH
39432: LD_INT 1
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 3
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 2
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 2
39472: PUSH
39473: LD_INT 2
39475: NEG
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 4
39483: PUSH
39484: LD_INT 2
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 4
39493: PUSH
39494: LD_INT 4
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 4
39503: PUSH
39504: LD_INT 3
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 5
39513: PUSH
39514: LD_INT 4
39516: PUSH
39517: EMPTY
39518: LIST
39519: LIST
39520: PUSH
39521: LD_INT 5
39523: PUSH
39524: LD_INT 5
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 4
39533: PUSH
39534: LD_INT 5
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 3
39543: PUSH
39544: LD_INT 4
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 3
39553: PUSH
39554: LD_INT 3
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: LD_INT 5
39563: PUSH
39564: LD_INT 3
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 3
39573: PUSH
39574: LD_INT 5
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
39628: LD_ADDR_VAR 0 33
39632: PUSH
39633: LD_INT 4
39635: NEG
39636: PUSH
39637: LD_INT 4
39639: NEG
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 4
39647: NEG
39648: PUSH
39649: LD_INT 5
39651: NEG
39652: PUSH
39653: EMPTY
39654: LIST
39655: LIST
39656: PUSH
39657: LD_INT 3
39659: NEG
39660: PUSH
39661: LD_INT 4
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 3
39671: NEG
39672: PUSH
39673: LD_INT 3
39675: NEG
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 4
39683: NEG
39684: PUSH
39685: LD_INT 3
39687: NEG
39688: PUSH
39689: EMPTY
39690: LIST
39691: LIST
39692: PUSH
39693: LD_INT 5
39695: NEG
39696: PUSH
39697: LD_INT 4
39699: NEG
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 5
39707: NEG
39708: PUSH
39709: LD_INT 5
39711: NEG
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 3
39719: NEG
39720: PUSH
39721: LD_INT 5
39723: NEG
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: PUSH
39729: LD_INT 5
39731: NEG
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: LD_INT 3
39746: NEG
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 0
39754: PUSH
39755: LD_INT 4
39757: NEG
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 1
39765: PUSH
39766: LD_INT 3
39768: NEG
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 1
39776: PUSH
39777: LD_INT 2
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 2
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: NEG
39799: PUSH
39800: LD_INT 3
39802: NEG
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 1
39810: NEG
39811: PUSH
39812: LD_INT 4
39814: NEG
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: PUSH
39820: LD_INT 2
39822: PUSH
39823: LD_INT 2
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 2
39833: NEG
39834: PUSH
39835: LD_INT 4
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 4
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 4
39855: PUSH
39856: LD_INT 1
39858: NEG
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 5
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 5
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 4
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 3
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 3
39906: PUSH
39907: LD_INT 1
39909: NEG
39910: PUSH
39911: EMPTY
39912: LIST
39913: LIST
39914: PUSH
39915: LD_INT 3
39917: PUSH
39918: LD_INT 2
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: LD_INT 5
39928: PUSH
39929: LD_INT 2
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 3
39938: PUSH
39939: LD_INT 3
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 3
39948: PUSH
39949: LD_INT 2
39951: PUSH
39952: EMPTY
39953: LIST
39954: LIST
39955: PUSH
39956: LD_INT 4
39958: PUSH
39959: LD_INT 3
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: LD_INT 4
39968: PUSH
39969: LD_INT 4
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 3
39978: PUSH
39979: LD_INT 4
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 2
39988: PUSH
39989: LD_INT 3
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 2
39998: PUSH
39999: LD_INT 2
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 4
40008: PUSH
40009: LD_INT 2
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 2
40018: PUSH
40019: LD_INT 4
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: LD_INT 4
40031: PUSH
40032: EMPTY
40033: LIST
40034: LIST
40035: PUSH
40036: LD_INT 0
40038: PUSH
40039: LD_INT 3
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: LD_INT 4
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 1
40058: PUSH
40059: LD_INT 5
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: LD_INT 5
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: LD_INT 1
40078: NEG
40079: PUSH
40080: LD_INT 4
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: LD_INT 3
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: PUSH
40101: LD_INT 5
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 2
40110: NEG
40111: PUSH
40112: LD_INT 3
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: LIST
40130: LIST
40131: LIST
40132: LIST
40133: LIST
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: LIST
40162: LIST
40163: LIST
40164: LIST
40165: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
40166: LD_ADDR_VAR 0 34
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: LD_INT 4
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 0
40184: PUSH
40185: LD_INT 5
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: LD_INT 1
40195: PUSH
40196: LD_INT 4
40198: NEG
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: PUSH
40204: LD_INT 1
40206: PUSH
40207: LD_INT 3
40209: NEG
40210: PUSH
40211: EMPTY
40212: LIST
40213: LIST
40214: PUSH
40215: LD_INT 0
40217: PUSH
40218: LD_INT 3
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: NEG
40229: PUSH
40230: LD_INT 4
40232: NEG
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: LD_INT 5
40244: NEG
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 2
40252: PUSH
40253: LD_INT 3
40255: NEG
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 2
40263: NEG
40264: PUSH
40265: LD_INT 5
40267: NEG
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 3
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: EMPTY
40280: LIST
40281: LIST
40282: PUSH
40283: LD_INT 3
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 4
40296: PUSH
40297: LD_INT 0
40299: PUSH
40300: EMPTY
40301: LIST
40302: LIST
40303: PUSH
40304: LD_INT 4
40306: PUSH
40307: LD_INT 1
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: PUSH
40314: LD_INT 3
40316: PUSH
40317: LD_INT 1
40319: PUSH
40320: EMPTY
40321: LIST
40322: LIST
40323: PUSH
40324: LD_INT 2
40326: PUSH
40327: LD_INT 0
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 2
40336: PUSH
40337: LD_INT 1
40339: NEG
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 2
40347: PUSH
40348: LD_INT 2
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 4
40358: PUSH
40359: LD_INT 2
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 4
40368: PUSH
40369: LD_INT 4
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 4
40378: PUSH
40379: LD_INT 3
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 5
40388: PUSH
40389: LD_INT 4
40391: PUSH
40392: EMPTY
40393: LIST
40394: LIST
40395: PUSH
40396: LD_INT 5
40398: PUSH
40399: LD_INT 5
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 4
40408: PUSH
40409: LD_INT 5
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: LD_INT 3
40418: PUSH
40419: LD_INT 4
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 3
40428: PUSH
40429: LD_INT 3
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 5
40438: PUSH
40439: LD_INT 3
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: LD_INT 3
40448: PUSH
40449: LD_INT 5
40451: PUSH
40452: EMPTY
40453: LIST
40454: LIST
40455: PUSH
40456: LD_INT 0
40458: PUSH
40459: LD_INT 3
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: LD_INT 2
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: PUSH
40476: LD_INT 1
40478: PUSH
40479: LD_INT 3
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 1
40488: PUSH
40489: LD_INT 4
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 0
40498: PUSH
40499: LD_INT 4
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 1
40508: NEG
40509: PUSH
40510: LD_INT 3
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 1
40519: NEG
40520: PUSH
40521: LD_INT 2
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: PUSH
40531: LD_INT 4
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 2
40540: NEG
40541: PUSH
40542: LD_INT 2
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 4
40551: NEG
40552: PUSH
40553: LD_INT 0
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 4
40562: NEG
40563: PUSH
40564: LD_INT 1
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 3
40574: NEG
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 3
40585: NEG
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 4
40596: NEG
40597: PUSH
40598: LD_INT 1
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: LD_INT 5
40607: NEG
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 5
40618: NEG
40619: PUSH
40620: LD_INT 1
40622: NEG
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 5
40630: NEG
40631: PUSH
40632: LD_INT 2
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 3
40642: NEG
40643: PUSH
40644: LD_INT 2
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: ST_TO_ADDR
// end ; end ;
40698: GO 40701
40700: POP
// case btype of b_depot , b_warehouse :
40701: LD_VAR 0 1
40705: PUSH
40706: LD_INT 0
40708: DOUBLE
40709: EQUAL
40710: IFTRUE 40720
40712: LD_INT 1
40714: DOUBLE
40715: EQUAL
40716: IFTRUE 40720
40718: GO 40921
40720: POP
// case nation of nation_american :
40721: LD_VAR 0 5
40725: PUSH
40726: LD_INT 1
40728: DOUBLE
40729: EQUAL
40730: IFTRUE 40734
40732: GO 40790
40734: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
40735: LD_ADDR_VAR 0 9
40739: PUSH
40740: LD_VAR 0 11
40744: PUSH
40745: LD_VAR 0 12
40749: PUSH
40750: LD_VAR 0 13
40754: PUSH
40755: LD_VAR 0 14
40759: PUSH
40760: LD_VAR 0 15
40764: PUSH
40765: LD_VAR 0 16
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: LIST
40774: LIST
40775: LIST
40776: LIST
40777: PUSH
40778: LD_VAR 0 4
40782: PUSH
40783: LD_INT 1
40785: PLUS
40786: ARRAY
40787: ST_TO_ADDR
40788: GO 40919
40790: LD_INT 2
40792: DOUBLE
40793: EQUAL
40794: IFTRUE 40798
40796: GO 40854
40798: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
40799: LD_ADDR_VAR 0 9
40803: PUSH
40804: LD_VAR 0 17
40808: PUSH
40809: LD_VAR 0 18
40813: PUSH
40814: LD_VAR 0 19
40818: PUSH
40819: LD_VAR 0 20
40823: PUSH
40824: LD_VAR 0 21
40828: PUSH
40829: LD_VAR 0 22
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: LIST
40838: LIST
40839: LIST
40840: LIST
40841: PUSH
40842: LD_VAR 0 4
40846: PUSH
40847: LD_INT 1
40849: PLUS
40850: ARRAY
40851: ST_TO_ADDR
40852: GO 40919
40854: LD_INT 3
40856: DOUBLE
40857: EQUAL
40858: IFTRUE 40862
40860: GO 40918
40862: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
40863: LD_ADDR_VAR 0 9
40867: PUSH
40868: LD_VAR 0 23
40872: PUSH
40873: LD_VAR 0 24
40877: PUSH
40878: LD_VAR 0 25
40882: PUSH
40883: LD_VAR 0 26
40887: PUSH
40888: LD_VAR 0 27
40892: PUSH
40893: LD_VAR 0 28
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: LIST
40903: LIST
40904: LIST
40905: PUSH
40906: LD_VAR 0 4
40910: PUSH
40911: LD_INT 1
40913: PLUS
40914: ARRAY
40915: ST_TO_ADDR
40916: GO 40919
40918: POP
40919: GO 41474
40921: LD_INT 2
40923: DOUBLE
40924: EQUAL
40925: IFTRUE 40935
40927: LD_INT 3
40929: DOUBLE
40930: EQUAL
40931: IFTRUE 40935
40933: GO 40991
40935: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
40936: LD_ADDR_VAR 0 9
40940: PUSH
40941: LD_VAR 0 29
40945: PUSH
40946: LD_VAR 0 30
40950: PUSH
40951: LD_VAR 0 31
40955: PUSH
40956: LD_VAR 0 32
40960: PUSH
40961: LD_VAR 0 33
40965: PUSH
40966: LD_VAR 0 34
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: LIST
40975: LIST
40976: LIST
40977: LIST
40978: PUSH
40979: LD_VAR 0 4
40983: PUSH
40984: LD_INT 1
40986: PLUS
40987: ARRAY
40988: ST_TO_ADDR
40989: GO 41474
40991: LD_INT 16
40993: DOUBLE
40994: EQUAL
40995: IFTRUE 41053
40997: LD_INT 17
40999: DOUBLE
41000: EQUAL
41001: IFTRUE 41053
41003: LD_INT 18
41005: DOUBLE
41006: EQUAL
41007: IFTRUE 41053
41009: LD_INT 19
41011: DOUBLE
41012: EQUAL
41013: IFTRUE 41053
41015: LD_INT 22
41017: DOUBLE
41018: EQUAL
41019: IFTRUE 41053
41021: LD_INT 20
41023: DOUBLE
41024: EQUAL
41025: IFTRUE 41053
41027: LD_INT 21
41029: DOUBLE
41030: EQUAL
41031: IFTRUE 41053
41033: LD_INT 23
41035: DOUBLE
41036: EQUAL
41037: IFTRUE 41053
41039: LD_INT 24
41041: DOUBLE
41042: EQUAL
41043: IFTRUE 41053
41045: LD_INT 25
41047: DOUBLE
41048: EQUAL
41049: IFTRUE 41053
41051: GO 41109
41053: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
41054: LD_ADDR_VAR 0 9
41058: PUSH
41059: LD_VAR 0 35
41063: PUSH
41064: LD_VAR 0 36
41068: PUSH
41069: LD_VAR 0 37
41073: PUSH
41074: LD_VAR 0 38
41078: PUSH
41079: LD_VAR 0 39
41083: PUSH
41084: LD_VAR 0 40
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: LIST
41093: LIST
41094: LIST
41095: LIST
41096: PUSH
41097: LD_VAR 0 4
41101: PUSH
41102: LD_INT 1
41104: PLUS
41105: ARRAY
41106: ST_TO_ADDR
41107: GO 41474
41109: LD_INT 6
41111: DOUBLE
41112: EQUAL
41113: IFTRUE 41165
41115: LD_INT 7
41117: DOUBLE
41118: EQUAL
41119: IFTRUE 41165
41121: LD_INT 8
41123: DOUBLE
41124: EQUAL
41125: IFTRUE 41165
41127: LD_INT 13
41129: DOUBLE
41130: EQUAL
41131: IFTRUE 41165
41133: LD_INT 12
41135: DOUBLE
41136: EQUAL
41137: IFTRUE 41165
41139: LD_INT 15
41141: DOUBLE
41142: EQUAL
41143: IFTRUE 41165
41145: LD_INT 11
41147: DOUBLE
41148: EQUAL
41149: IFTRUE 41165
41151: LD_INT 14
41153: DOUBLE
41154: EQUAL
41155: IFTRUE 41165
41157: LD_INT 10
41159: DOUBLE
41160: EQUAL
41161: IFTRUE 41165
41163: GO 41221
41165: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
41166: LD_ADDR_VAR 0 9
41170: PUSH
41171: LD_VAR 0 41
41175: PUSH
41176: LD_VAR 0 42
41180: PUSH
41181: LD_VAR 0 43
41185: PUSH
41186: LD_VAR 0 44
41190: PUSH
41191: LD_VAR 0 45
41195: PUSH
41196: LD_VAR 0 46
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: PUSH
41209: LD_VAR 0 4
41213: PUSH
41214: LD_INT 1
41216: PLUS
41217: ARRAY
41218: ST_TO_ADDR
41219: GO 41474
41221: LD_INT 36
41223: DOUBLE
41224: EQUAL
41225: IFTRUE 41229
41227: GO 41285
41229: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
41230: LD_ADDR_VAR 0 9
41234: PUSH
41235: LD_VAR 0 47
41239: PUSH
41240: LD_VAR 0 48
41244: PUSH
41245: LD_VAR 0 49
41249: PUSH
41250: LD_VAR 0 50
41254: PUSH
41255: LD_VAR 0 51
41259: PUSH
41260: LD_VAR 0 52
41264: PUSH
41265: EMPTY
41266: LIST
41267: LIST
41268: LIST
41269: LIST
41270: LIST
41271: LIST
41272: PUSH
41273: LD_VAR 0 4
41277: PUSH
41278: LD_INT 1
41280: PLUS
41281: ARRAY
41282: ST_TO_ADDR
41283: GO 41474
41285: LD_INT 4
41287: DOUBLE
41288: EQUAL
41289: IFTRUE 41311
41291: LD_INT 5
41293: DOUBLE
41294: EQUAL
41295: IFTRUE 41311
41297: LD_INT 34
41299: DOUBLE
41300: EQUAL
41301: IFTRUE 41311
41303: LD_INT 37
41305: DOUBLE
41306: EQUAL
41307: IFTRUE 41311
41309: GO 41367
41311: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
41312: LD_ADDR_VAR 0 9
41316: PUSH
41317: LD_VAR 0 53
41321: PUSH
41322: LD_VAR 0 54
41326: PUSH
41327: LD_VAR 0 55
41331: PUSH
41332: LD_VAR 0 56
41336: PUSH
41337: LD_VAR 0 57
41341: PUSH
41342: LD_VAR 0 58
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: LIST
41351: LIST
41352: LIST
41353: LIST
41354: PUSH
41355: LD_VAR 0 4
41359: PUSH
41360: LD_INT 1
41362: PLUS
41363: ARRAY
41364: ST_TO_ADDR
41365: GO 41474
41367: LD_INT 31
41369: DOUBLE
41370: EQUAL
41371: IFTRUE 41417
41373: LD_INT 32
41375: DOUBLE
41376: EQUAL
41377: IFTRUE 41417
41379: LD_INT 33
41381: DOUBLE
41382: EQUAL
41383: IFTRUE 41417
41385: LD_INT 27
41387: DOUBLE
41388: EQUAL
41389: IFTRUE 41417
41391: LD_INT 26
41393: DOUBLE
41394: EQUAL
41395: IFTRUE 41417
41397: LD_INT 28
41399: DOUBLE
41400: EQUAL
41401: IFTRUE 41417
41403: LD_INT 29
41405: DOUBLE
41406: EQUAL
41407: IFTRUE 41417
41409: LD_INT 30
41411: DOUBLE
41412: EQUAL
41413: IFTRUE 41417
41415: GO 41473
41417: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
41418: LD_ADDR_VAR 0 9
41422: PUSH
41423: LD_VAR 0 59
41427: PUSH
41428: LD_VAR 0 60
41432: PUSH
41433: LD_VAR 0 61
41437: PUSH
41438: LD_VAR 0 62
41442: PUSH
41443: LD_VAR 0 63
41447: PUSH
41448: LD_VAR 0 64
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: PUSH
41461: LD_VAR 0 4
41465: PUSH
41466: LD_INT 1
41468: PLUS
41469: ARRAY
41470: ST_TO_ADDR
41471: GO 41474
41473: POP
// temp_list2 = [ ] ;
41474: LD_ADDR_VAR 0 10
41478: PUSH
41479: EMPTY
41480: ST_TO_ADDR
// for i in temp_list do
41481: LD_ADDR_VAR 0 8
41485: PUSH
41486: LD_VAR 0 9
41490: PUSH
41491: FOR_IN
41492: IFFALSE 41544
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
41494: LD_ADDR_VAR 0 10
41498: PUSH
41499: LD_VAR 0 10
41503: PUSH
41504: LD_VAR 0 8
41508: PUSH
41509: LD_INT 1
41511: ARRAY
41512: PUSH
41513: LD_VAR 0 2
41517: PLUS
41518: PUSH
41519: LD_VAR 0 8
41523: PUSH
41524: LD_INT 2
41526: ARRAY
41527: PUSH
41528: LD_VAR 0 3
41532: PLUS
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: EMPTY
41539: LIST
41540: ADD
41541: ST_TO_ADDR
41542: GO 41491
41544: POP
41545: POP
// result = temp_list2 ;
41546: LD_ADDR_VAR 0 7
41550: PUSH
41551: LD_VAR 0 10
41555: ST_TO_ADDR
// end ;
41556: LD_VAR 0 7
41560: RET
// export function EnemyInRange ( unit , dist ) ; begin
41561: LD_INT 0
41563: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
41564: LD_ADDR_VAR 0 3
41568: PUSH
41569: LD_VAR 0 1
41573: PPUSH
41574: CALL_OW 255
41578: PPUSH
41579: LD_VAR 0 1
41583: PPUSH
41584: CALL_OW 250
41588: PPUSH
41589: LD_VAR 0 1
41593: PPUSH
41594: CALL_OW 251
41598: PPUSH
41599: LD_VAR 0 2
41603: PPUSH
41604: CALL 14956 0 4
41608: PUSH
41609: LD_INT 4
41611: ARRAY
41612: ST_TO_ADDR
// end ;
41613: LD_VAR 0 3
41617: RET
// export function PlayerSeeMe ( unit ) ; begin
41618: LD_INT 0
41620: PPUSH
// result := See ( your_side , unit ) ;
41621: LD_ADDR_VAR 0 2
41625: PUSH
41626: LD_OWVAR 2
41630: PPUSH
41631: LD_VAR 0 1
41635: PPUSH
41636: CALL_OW 292
41640: ST_TO_ADDR
// end ;
41641: LD_VAR 0 2
41645: RET
// export function ReverseDir ( unit ) ; begin
41646: LD_INT 0
41648: PPUSH
// if not unit then
41649: LD_VAR 0 1
41653: NOT
41654: IFFALSE 41658
// exit ;
41656: GO 41681
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
41658: LD_ADDR_VAR 0 2
41662: PUSH
41663: LD_VAR 0 1
41667: PPUSH
41668: CALL_OW 254
41672: PUSH
41673: LD_INT 3
41675: PLUS
41676: PUSH
41677: LD_INT 6
41679: MOD
41680: ST_TO_ADDR
// end ;
41681: LD_VAR 0 2
41685: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
41686: LD_INT 0
41688: PPUSH
41689: PPUSH
41690: PPUSH
41691: PPUSH
41692: PPUSH
// if not hexes then
41693: LD_VAR 0 2
41697: NOT
41698: IFFALSE 41702
// exit ;
41700: GO 41850
// dist := 9999 ;
41702: LD_ADDR_VAR 0 5
41706: PUSH
41707: LD_INT 9999
41709: ST_TO_ADDR
// for i = 1 to hexes do
41710: LD_ADDR_VAR 0 4
41714: PUSH
41715: DOUBLE
41716: LD_INT 1
41718: DEC
41719: ST_TO_ADDR
41720: LD_VAR 0 2
41724: PUSH
41725: FOR_TO
41726: IFFALSE 41838
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
41728: LD_VAR 0 1
41732: PPUSH
41733: LD_VAR 0 2
41737: PUSH
41738: LD_VAR 0 4
41742: ARRAY
41743: PUSH
41744: LD_INT 1
41746: ARRAY
41747: PPUSH
41748: LD_VAR 0 2
41752: PUSH
41753: LD_VAR 0 4
41757: ARRAY
41758: PUSH
41759: LD_INT 2
41761: ARRAY
41762: PPUSH
41763: CALL_OW 297
41767: PUSH
41768: LD_VAR 0 5
41772: LESS
41773: IFFALSE 41836
// begin hex := hexes [ i ] ;
41775: LD_ADDR_VAR 0 7
41779: PUSH
41780: LD_VAR 0 2
41784: PUSH
41785: LD_VAR 0 4
41789: ARRAY
41790: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41791: LD_ADDR_VAR 0 5
41795: PUSH
41796: LD_VAR 0 1
41800: PPUSH
41801: LD_VAR 0 2
41805: PUSH
41806: LD_VAR 0 4
41810: ARRAY
41811: PUSH
41812: LD_INT 1
41814: ARRAY
41815: PPUSH
41816: LD_VAR 0 2
41820: PUSH
41821: LD_VAR 0 4
41825: ARRAY
41826: PUSH
41827: LD_INT 2
41829: ARRAY
41830: PPUSH
41831: CALL_OW 297
41835: ST_TO_ADDR
// end ; end ;
41836: GO 41725
41838: POP
41839: POP
// result := hex ;
41840: LD_ADDR_VAR 0 3
41844: PUSH
41845: LD_VAR 0 7
41849: ST_TO_ADDR
// end ;
41850: LD_VAR 0 3
41854: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
41855: LD_INT 0
41857: PPUSH
41858: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
41859: LD_VAR 0 1
41863: NOT
41864: PUSH
41865: LD_VAR 0 1
41869: PUSH
41870: LD_INT 21
41872: PUSH
41873: LD_INT 2
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 23
41882: PUSH
41883: LD_INT 2
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PPUSH
41894: CALL_OW 69
41898: IN
41899: NOT
41900: OR
41901: IFFALSE 41905
// exit ;
41903: GO 41952
// for i = 1 to 3 do
41905: LD_ADDR_VAR 0 3
41909: PUSH
41910: DOUBLE
41911: LD_INT 1
41913: DEC
41914: ST_TO_ADDR
41915: LD_INT 3
41917: PUSH
41918: FOR_TO
41919: IFFALSE 41950
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
41921: LD_VAR 0 1
41925: PPUSH
41926: CALL_OW 250
41930: PPUSH
41931: LD_VAR 0 1
41935: PPUSH
41936: CALL_OW 251
41940: PPUSH
41941: LD_INT 1
41943: PPUSH
41944: CALL_OW 453
41948: GO 41918
41950: POP
41951: POP
// end ;
41952: LD_VAR 0 2
41956: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
41957: LD_INT 0
41959: PPUSH
41960: PPUSH
41961: PPUSH
41962: PPUSH
41963: PPUSH
41964: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
41965: LD_VAR 0 1
41969: NOT
41970: PUSH
41971: LD_VAR 0 2
41975: NOT
41976: OR
41977: PUSH
41978: LD_VAR 0 1
41982: PPUSH
41983: CALL_OW 314
41987: OR
41988: IFFALSE 41992
// exit ;
41990: GO 42433
// x := GetX ( enemy_unit ) ;
41992: LD_ADDR_VAR 0 7
41996: PUSH
41997: LD_VAR 0 2
42001: PPUSH
42002: CALL_OW 250
42006: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
42007: LD_ADDR_VAR 0 8
42011: PUSH
42012: LD_VAR 0 2
42016: PPUSH
42017: CALL_OW 251
42021: ST_TO_ADDR
// if not x or not y then
42022: LD_VAR 0 7
42026: NOT
42027: PUSH
42028: LD_VAR 0 8
42032: NOT
42033: OR
42034: IFFALSE 42038
// exit ;
42036: GO 42433
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
42038: LD_ADDR_VAR 0 6
42042: PUSH
42043: LD_VAR 0 7
42047: PPUSH
42048: LD_INT 0
42050: PPUSH
42051: LD_INT 4
42053: PPUSH
42054: CALL_OW 272
42058: PUSH
42059: LD_VAR 0 8
42063: PPUSH
42064: LD_INT 0
42066: PPUSH
42067: LD_INT 4
42069: PPUSH
42070: CALL_OW 273
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_VAR 0 7
42083: PPUSH
42084: LD_INT 1
42086: PPUSH
42087: LD_INT 4
42089: PPUSH
42090: CALL_OW 272
42094: PUSH
42095: LD_VAR 0 8
42099: PPUSH
42100: LD_INT 1
42102: PPUSH
42103: LD_INT 4
42105: PPUSH
42106: CALL_OW 273
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_VAR 0 7
42119: PPUSH
42120: LD_INT 2
42122: PPUSH
42123: LD_INT 4
42125: PPUSH
42126: CALL_OW 272
42130: PUSH
42131: LD_VAR 0 8
42135: PPUSH
42136: LD_INT 2
42138: PPUSH
42139: LD_INT 4
42141: PPUSH
42142: CALL_OW 273
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_VAR 0 7
42155: PPUSH
42156: LD_INT 3
42158: PPUSH
42159: LD_INT 4
42161: PPUSH
42162: CALL_OW 272
42166: PUSH
42167: LD_VAR 0 8
42171: PPUSH
42172: LD_INT 3
42174: PPUSH
42175: LD_INT 4
42177: PPUSH
42178: CALL_OW 273
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_VAR 0 7
42191: PPUSH
42192: LD_INT 4
42194: PPUSH
42195: LD_INT 4
42197: PPUSH
42198: CALL_OW 272
42202: PUSH
42203: LD_VAR 0 8
42207: PPUSH
42208: LD_INT 4
42210: PPUSH
42211: LD_INT 4
42213: PPUSH
42214: CALL_OW 273
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_VAR 0 7
42227: PPUSH
42228: LD_INT 5
42230: PPUSH
42231: LD_INT 4
42233: PPUSH
42234: CALL_OW 272
42238: PUSH
42239: LD_VAR 0 8
42243: PPUSH
42244: LD_INT 5
42246: PPUSH
42247: LD_INT 4
42249: PPUSH
42250: CALL_OW 273
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: LIST
42263: LIST
42264: LIST
42265: LIST
42266: ST_TO_ADDR
// for i = tmp downto 1 do
42267: LD_ADDR_VAR 0 4
42271: PUSH
42272: DOUBLE
42273: LD_VAR 0 6
42277: INC
42278: ST_TO_ADDR
42279: LD_INT 1
42281: PUSH
42282: FOR_DOWNTO
42283: IFFALSE 42384
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
42285: LD_VAR 0 6
42289: PUSH
42290: LD_VAR 0 4
42294: ARRAY
42295: PUSH
42296: LD_INT 1
42298: ARRAY
42299: PPUSH
42300: LD_VAR 0 6
42304: PUSH
42305: LD_VAR 0 4
42309: ARRAY
42310: PUSH
42311: LD_INT 2
42313: ARRAY
42314: PPUSH
42315: CALL_OW 488
42319: NOT
42320: PUSH
42321: LD_VAR 0 6
42325: PUSH
42326: LD_VAR 0 4
42330: ARRAY
42331: PUSH
42332: LD_INT 1
42334: ARRAY
42335: PPUSH
42336: LD_VAR 0 6
42340: PUSH
42341: LD_VAR 0 4
42345: ARRAY
42346: PUSH
42347: LD_INT 2
42349: ARRAY
42350: PPUSH
42351: CALL_OW 428
42355: PUSH
42356: LD_INT 0
42358: NONEQUAL
42359: OR
42360: IFFALSE 42382
// tmp := Delete ( tmp , i ) ;
42362: LD_ADDR_VAR 0 6
42366: PUSH
42367: LD_VAR 0 6
42371: PPUSH
42372: LD_VAR 0 4
42376: PPUSH
42377: CALL_OW 3
42381: ST_TO_ADDR
42382: GO 42282
42384: POP
42385: POP
// j := GetClosestHex ( unit , tmp ) ;
42386: LD_ADDR_VAR 0 5
42390: PUSH
42391: LD_VAR 0 1
42395: PPUSH
42396: LD_VAR 0 6
42400: PPUSH
42401: CALL 41686 0 2
42405: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
42406: LD_VAR 0 1
42410: PPUSH
42411: LD_VAR 0 5
42415: PUSH
42416: LD_INT 1
42418: ARRAY
42419: PPUSH
42420: LD_VAR 0 5
42424: PUSH
42425: LD_INT 2
42427: ARRAY
42428: PPUSH
42429: CALL_OW 111
// end ;
42433: LD_VAR 0 3
42437: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
42438: LD_INT 0
42440: PPUSH
42441: PPUSH
42442: PPUSH
// uc_side = 0 ;
42443: LD_ADDR_OWVAR 20
42447: PUSH
42448: LD_INT 0
42450: ST_TO_ADDR
// uc_nation = 0 ;
42451: LD_ADDR_OWVAR 21
42455: PUSH
42456: LD_INT 0
42458: ST_TO_ADDR
// InitHc_All ( ) ;
42459: CALL_OW 584
// InitVc ;
42463: CALL_OW 20
// if mastodonts then
42467: LD_VAR 0 6
42471: IFFALSE 42538
// for i = 1 to mastodonts do
42473: LD_ADDR_VAR 0 11
42477: PUSH
42478: DOUBLE
42479: LD_INT 1
42481: DEC
42482: ST_TO_ADDR
42483: LD_VAR 0 6
42487: PUSH
42488: FOR_TO
42489: IFFALSE 42536
// begin vc_chassis := 31 ;
42491: LD_ADDR_OWVAR 37
42495: PUSH
42496: LD_INT 31
42498: ST_TO_ADDR
// vc_control := control_rider ;
42499: LD_ADDR_OWVAR 38
42503: PUSH
42504: LD_INT 4
42506: ST_TO_ADDR
// animal := CreateVehicle ;
42507: LD_ADDR_VAR 0 12
42511: PUSH
42512: CALL_OW 45
42516: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42517: LD_VAR 0 12
42521: PPUSH
42522: LD_VAR 0 8
42526: PPUSH
42527: LD_INT 0
42529: PPUSH
42530: CALL 44726 0 3
// end ;
42534: GO 42488
42536: POP
42537: POP
// if horses then
42538: LD_VAR 0 5
42542: IFFALSE 42609
// for i = 1 to horses do
42544: LD_ADDR_VAR 0 11
42548: PUSH
42549: DOUBLE
42550: LD_INT 1
42552: DEC
42553: ST_TO_ADDR
42554: LD_VAR 0 5
42558: PUSH
42559: FOR_TO
42560: IFFALSE 42607
// begin hc_class := 21 ;
42562: LD_ADDR_OWVAR 28
42566: PUSH
42567: LD_INT 21
42569: ST_TO_ADDR
// hc_gallery :=  ;
42570: LD_ADDR_OWVAR 33
42574: PUSH
42575: LD_STRING 
42577: ST_TO_ADDR
// animal := CreateHuman ;
42578: LD_ADDR_VAR 0 12
42582: PUSH
42583: CALL_OW 44
42587: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42588: LD_VAR 0 12
42592: PPUSH
42593: LD_VAR 0 8
42597: PPUSH
42598: LD_INT 0
42600: PPUSH
42601: CALL 44726 0 3
// end ;
42605: GO 42559
42607: POP
42608: POP
// if birds then
42609: LD_VAR 0 1
42613: IFFALSE 42680
// for i = 1 to birds do
42615: LD_ADDR_VAR 0 11
42619: PUSH
42620: DOUBLE
42621: LD_INT 1
42623: DEC
42624: ST_TO_ADDR
42625: LD_VAR 0 1
42629: PUSH
42630: FOR_TO
42631: IFFALSE 42678
// begin hc_class = 18 ;
42633: LD_ADDR_OWVAR 28
42637: PUSH
42638: LD_INT 18
42640: ST_TO_ADDR
// hc_gallery =  ;
42641: LD_ADDR_OWVAR 33
42645: PUSH
42646: LD_STRING 
42648: ST_TO_ADDR
// animal := CreateHuman ;
42649: LD_ADDR_VAR 0 12
42653: PUSH
42654: CALL_OW 44
42658: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42659: LD_VAR 0 12
42663: PPUSH
42664: LD_VAR 0 8
42668: PPUSH
42669: LD_INT 0
42671: PPUSH
42672: CALL 44726 0 3
// end ;
42676: GO 42630
42678: POP
42679: POP
// if tigers then
42680: LD_VAR 0 2
42684: IFFALSE 42768
// for i = 1 to tigers do
42686: LD_ADDR_VAR 0 11
42690: PUSH
42691: DOUBLE
42692: LD_INT 1
42694: DEC
42695: ST_TO_ADDR
42696: LD_VAR 0 2
42700: PUSH
42701: FOR_TO
42702: IFFALSE 42766
// begin hc_class = class_tiger ;
42704: LD_ADDR_OWVAR 28
42708: PUSH
42709: LD_INT 14
42711: ST_TO_ADDR
// hc_gallery =  ;
42712: LD_ADDR_OWVAR 33
42716: PUSH
42717: LD_STRING 
42719: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
42720: LD_ADDR_OWVAR 35
42724: PUSH
42725: LD_INT 7
42727: NEG
42728: PPUSH
42729: LD_INT 7
42731: PPUSH
42732: CALL_OW 12
42736: ST_TO_ADDR
// animal := CreateHuman ;
42737: LD_ADDR_VAR 0 12
42741: PUSH
42742: CALL_OW 44
42746: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42747: LD_VAR 0 12
42751: PPUSH
42752: LD_VAR 0 8
42756: PPUSH
42757: LD_INT 0
42759: PPUSH
42760: CALL 44726 0 3
// end ;
42764: GO 42701
42766: POP
42767: POP
// if apemans then
42768: LD_VAR 0 3
42772: IFFALSE 42895
// for i = 1 to apemans do
42774: LD_ADDR_VAR 0 11
42778: PUSH
42779: DOUBLE
42780: LD_INT 1
42782: DEC
42783: ST_TO_ADDR
42784: LD_VAR 0 3
42788: PUSH
42789: FOR_TO
42790: IFFALSE 42893
// begin hc_class = class_apeman ;
42792: LD_ADDR_OWVAR 28
42796: PUSH
42797: LD_INT 12
42799: ST_TO_ADDR
// hc_gallery =  ;
42800: LD_ADDR_OWVAR 33
42804: PUSH
42805: LD_STRING 
42807: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
42808: LD_ADDR_OWVAR 35
42812: PUSH
42813: LD_INT 5
42815: NEG
42816: PPUSH
42817: LD_INT 5
42819: PPUSH
42820: CALL_OW 12
42824: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
42825: LD_ADDR_OWVAR 31
42829: PUSH
42830: LD_INT 1
42832: PPUSH
42833: LD_INT 3
42835: PPUSH
42836: CALL_OW 12
42840: PUSH
42841: LD_INT 1
42843: PPUSH
42844: LD_INT 3
42846: PPUSH
42847: CALL_OW 12
42851: PUSH
42852: LD_INT 0
42854: PUSH
42855: LD_INT 0
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: LIST
42862: LIST
42863: ST_TO_ADDR
// animal := CreateHuman ;
42864: LD_ADDR_VAR 0 12
42868: PUSH
42869: CALL_OW 44
42873: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42874: LD_VAR 0 12
42878: PPUSH
42879: LD_VAR 0 8
42883: PPUSH
42884: LD_INT 0
42886: PPUSH
42887: CALL 44726 0 3
// end ;
42891: GO 42789
42893: POP
42894: POP
// if enchidnas then
42895: LD_VAR 0 4
42899: IFFALSE 42966
// for i = 1 to enchidnas do
42901: LD_ADDR_VAR 0 11
42905: PUSH
42906: DOUBLE
42907: LD_INT 1
42909: DEC
42910: ST_TO_ADDR
42911: LD_VAR 0 4
42915: PUSH
42916: FOR_TO
42917: IFFALSE 42964
// begin hc_class = 13 ;
42919: LD_ADDR_OWVAR 28
42923: PUSH
42924: LD_INT 13
42926: ST_TO_ADDR
// hc_gallery =  ;
42927: LD_ADDR_OWVAR 33
42931: PUSH
42932: LD_STRING 
42934: ST_TO_ADDR
// animal := CreateHuman ;
42935: LD_ADDR_VAR 0 12
42939: PUSH
42940: CALL_OW 44
42944: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
42945: LD_VAR 0 12
42949: PPUSH
42950: LD_VAR 0 8
42954: PPUSH
42955: LD_INT 0
42957: PPUSH
42958: CALL 44726 0 3
// end ;
42962: GO 42916
42964: POP
42965: POP
// if fishes then
42966: LD_VAR 0 7
42970: IFFALSE 43037
// for i = 1 to fishes do
42972: LD_ADDR_VAR 0 11
42976: PUSH
42977: DOUBLE
42978: LD_INT 1
42980: DEC
42981: ST_TO_ADDR
42982: LD_VAR 0 7
42986: PUSH
42987: FOR_TO
42988: IFFALSE 43035
// begin hc_class = 20 ;
42990: LD_ADDR_OWVAR 28
42994: PUSH
42995: LD_INT 20
42997: ST_TO_ADDR
// hc_gallery =  ;
42998: LD_ADDR_OWVAR 33
43002: PUSH
43003: LD_STRING 
43005: ST_TO_ADDR
// animal := CreateHuman ;
43006: LD_ADDR_VAR 0 12
43010: PUSH
43011: CALL_OW 44
43015: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
43016: LD_VAR 0 12
43020: PPUSH
43021: LD_VAR 0 9
43025: PPUSH
43026: LD_INT 0
43028: PPUSH
43029: CALL 44726 0 3
// end ;
43033: GO 42987
43035: POP
43036: POP
// end ;
43037: LD_VAR 0 10
43041: RET
// export function WantHeal ( sci , unit ) ; begin
43042: LD_INT 0
43044: PPUSH
// if GetTaskList ( sci ) > 0 then
43045: LD_VAR 0 1
43049: PPUSH
43050: CALL_OW 437
43054: PUSH
43055: LD_INT 0
43057: GREATER
43058: IFFALSE 43128
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
43060: LD_VAR 0 1
43064: PPUSH
43065: CALL_OW 437
43069: PUSH
43070: LD_INT 1
43072: ARRAY
43073: PUSH
43074: LD_INT 1
43076: ARRAY
43077: PUSH
43078: LD_STRING l
43080: EQUAL
43081: PUSH
43082: LD_VAR 0 1
43086: PPUSH
43087: CALL_OW 437
43091: PUSH
43092: LD_INT 1
43094: ARRAY
43095: PUSH
43096: LD_INT 4
43098: ARRAY
43099: PUSH
43100: LD_VAR 0 2
43104: EQUAL
43105: AND
43106: IFFALSE 43118
// result := true else
43108: LD_ADDR_VAR 0 3
43112: PUSH
43113: LD_INT 1
43115: ST_TO_ADDR
43116: GO 43126
// result := false ;
43118: LD_ADDR_VAR 0 3
43122: PUSH
43123: LD_INT 0
43125: ST_TO_ADDR
// end else
43126: GO 43136
// result := false ;
43128: LD_ADDR_VAR 0 3
43132: PUSH
43133: LD_INT 0
43135: ST_TO_ADDR
// end ;
43136: LD_VAR 0 3
43140: RET
// export function HealTarget ( sci ) ; begin
43141: LD_INT 0
43143: PPUSH
// if not sci then
43144: LD_VAR 0 1
43148: NOT
43149: IFFALSE 43153
// exit ;
43151: GO 43218
// result := 0 ;
43153: LD_ADDR_VAR 0 2
43157: PUSH
43158: LD_INT 0
43160: ST_TO_ADDR
// if GetTaskList ( sci ) then
43161: LD_VAR 0 1
43165: PPUSH
43166: CALL_OW 437
43170: IFFALSE 43218
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
43172: LD_VAR 0 1
43176: PPUSH
43177: CALL_OW 437
43181: PUSH
43182: LD_INT 1
43184: ARRAY
43185: PUSH
43186: LD_INT 1
43188: ARRAY
43189: PUSH
43190: LD_STRING l
43192: EQUAL
43193: IFFALSE 43218
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
43195: LD_ADDR_VAR 0 2
43199: PUSH
43200: LD_VAR 0 1
43204: PPUSH
43205: CALL_OW 437
43209: PUSH
43210: LD_INT 1
43212: ARRAY
43213: PUSH
43214: LD_INT 4
43216: ARRAY
43217: ST_TO_ADDR
// end ;
43218: LD_VAR 0 2
43222: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
43223: LD_INT 0
43225: PPUSH
43226: PPUSH
43227: PPUSH
43228: PPUSH
// if not base_units then
43229: LD_VAR 0 1
43233: NOT
43234: IFFALSE 43238
// exit ;
43236: GO 43325
// result := false ;
43238: LD_ADDR_VAR 0 2
43242: PUSH
43243: LD_INT 0
43245: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
43246: LD_ADDR_VAR 0 5
43250: PUSH
43251: LD_VAR 0 1
43255: PPUSH
43256: LD_INT 21
43258: PUSH
43259: LD_INT 3
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PPUSH
43266: CALL_OW 72
43270: ST_TO_ADDR
// if not tmp then
43271: LD_VAR 0 5
43275: NOT
43276: IFFALSE 43280
// exit ;
43278: GO 43325
// for i in tmp do
43280: LD_ADDR_VAR 0 3
43284: PUSH
43285: LD_VAR 0 5
43289: PUSH
43290: FOR_IN
43291: IFFALSE 43323
// begin result := EnemyInRange ( i , 22 ) ;
43293: LD_ADDR_VAR 0 2
43297: PUSH
43298: LD_VAR 0 3
43302: PPUSH
43303: LD_INT 22
43305: PPUSH
43306: CALL 41561 0 2
43310: ST_TO_ADDR
// if result then
43311: LD_VAR 0 2
43315: IFFALSE 43321
// exit ;
43317: POP
43318: POP
43319: GO 43325
// end ;
43321: GO 43290
43323: POP
43324: POP
// end ;
43325: LD_VAR 0 2
43329: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
43330: LD_INT 0
43332: PPUSH
43333: PPUSH
// if not units then
43334: LD_VAR 0 1
43338: NOT
43339: IFFALSE 43343
// exit ;
43341: GO 43413
// result := [ ] ;
43343: LD_ADDR_VAR 0 3
43347: PUSH
43348: EMPTY
43349: ST_TO_ADDR
// for i in units do
43350: LD_ADDR_VAR 0 4
43354: PUSH
43355: LD_VAR 0 1
43359: PUSH
43360: FOR_IN
43361: IFFALSE 43411
// if GetTag ( i ) = tag then
43363: LD_VAR 0 4
43367: PPUSH
43368: CALL_OW 110
43372: PUSH
43373: LD_VAR 0 2
43377: EQUAL
43378: IFFALSE 43409
// result := Insert ( result , result + 1 , i ) ;
43380: LD_ADDR_VAR 0 3
43384: PUSH
43385: LD_VAR 0 3
43389: PPUSH
43390: LD_VAR 0 3
43394: PUSH
43395: LD_INT 1
43397: PLUS
43398: PPUSH
43399: LD_VAR 0 4
43403: PPUSH
43404: CALL_OW 2
43408: ST_TO_ADDR
43409: GO 43360
43411: POP
43412: POP
// end ;
43413: LD_VAR 0 3
43417: RET
// export function IsDriver ( un ) ; begin
43418: LD_INT 0
43420: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
43421: LD_ADDR_VAR 0 2
43425: PUSH
43426: LD_VAR 0 1
43430: PUSH
43431: LD_INT 55
43433: PUSH
43434: EMPTY
43435: LIST
43436: PPUSH
43437: CALL_OW 69
43441: IN
43442: ST_TO_ADDR
// end ;
43443: LD_VAR 0 2
43447: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
43448: LD_INT 0
43450: PPUSH
43451: PPUSH
// list := [ ] ;
43452: LD_ADDR_VAR 0 5
43456: PUSH
43457: EMPTY
43458: ST_TO_ADDR
// case d of 0 :
43459: LD_VAR 0 3
43463: PUSH
43464: LD_INT 0
43466: DOUBLE
43467: EQUAL
43468: IFTRUE 43472
43470: GO 43605
43472: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
43473: LD_ADDR_VAR 0 5
43477: PUSH
43478: LD_VAR 0 1
43482: PUSH
43483: LD_INT 4
43485: MINUS
43486: PUSH
43487: LD_VAR 0 2
43491: PUSH
43492: LD_INT 4
43494: MINUS
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: LIST
43503: PUSH
43504: LD_VAR 0 1
43508: PUSH
43509: LD_INT 3
43511: MINUS
43512: PUSH
43513: LD_VAR 0 2
43517: PUSH
43518: LD_INT 1
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: LIST
43525: PUSH
43526: LD_VAR 0 1
43530: PUSH
43531: LD_INT 4
43533: PLUS
43534: PUSH
43535: LD_VAR 0 2
43539: PUSH
43540: LD_INT 4
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: LIST
43547: PUSH
43548: LD_VAR 0 1
43552: PUSH
43553: LD_INT 3
43555: PLUS
43556: PUSH
43557: LD_VAR 0 2
43561: PUSH
43562: LD_INT 3
43564: PLUS
43565: PUSH
43566: LD_INT 5
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: LIST
43573: PUSH
43574: LD_VAR 0 1
43578: PUSH
43579: LD_VAR 0 2
43583: PUSH
43584: LD_INT 4
43586: PLUS
43587: PUSH
43588: LD_INT 0
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: LIST
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: LIST
43600: LIST
43601: LIST
43602: ST_TO_ADDR
// end ; 1 :
43603: GO 44303
43605: LD_INT 1
43607: DOUBLE
43608: EQUAL
43609: IFTRUE 43613
43611: GO 43746
43613: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
43614: LD_ADDR_VAR 0 5
43618: PUSH
43619: LD_VAR 0 1
43623: PUSH
43624: LD_VAR 0 2
43628: PUSH
43629: LD_INT 4
43631: MINUS
43632: PUSH
43633: LD_INT 3
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: LIST
43640: PUSH
43641: LD_VAR 0 1
43645: PUSH
43646: LD_INT 3
43648: MINUS
43649: PUSH
43650: LD_VAR 0 2
43654: PUSH
43655: LD_INT 3
43657: MINUS
43658: PUSH
43659: LD_INT 2
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: LIST
43666: PUSH
43667: LD_VAR 0 1
43671: PUSH
43672: LD_INT 4
43674: MINUS
43675: PUSH
43676: LD_VAR 0 2
43680: PUSH
43681: LD_INT 1
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: LIST
43688: PUSH
43689: LD_VAR 0 1
43693: PUSH
43694: LD_VAR 0 2
43698: PUSH
43699: LD_INT 3
43701: PLUS
43702: PUSH
43703: LD_INT 0
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: LIST
43710: PUSH
43711: LD_VAR 0 1
43715: PUSH
43716: LD_INT 4
43718: PLUS
43719: PUSH
43720: LD_VAR 0 2
43724: PUSH
43725: LD_INT 4
43727: PLUS
43728: PUSH
43729: LD_INT 5
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: LIST
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: ST_TO_ADDR
// end ; 2 :
43744: GO 44303
43746: LD_INT 2
43748: DOUBLE
43749: EQUAL
43750: IFTRUE 43754
43752: GO 43883
43754: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
43755: LD_ADDR_VAR 0 5
43759: PUSH
43760: LD_VAR 0 1
43764: PUSH
43765: LD_VAR 0 2
43769: PUSH
43770: LD_INT 3
43772: MINUS
43773: PUSH
43774: LD_INT 3
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: LIST
43781: PUSH
43782: LD_VAR 0 1
43786: PUSH
43787: LD_INT 4
43789: PLUS
43790: PUSH
43791: LD_VAR 0 2
43795: PUSH
43796: LD_INT 4
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: LIST
43803: PUSH
43804: LD_VAR 0 1
43808: PUSH
43809: LD_VAR 0 2
43813: PUSH
43814: LD_INT 4
43816: PLUS
43817: PUSH
43818: LD_INT 0
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: LIST
43825: PUSH
43826: LD_VAR 0 1
43830: PUSH
43831: LD_INT 3
43833: MINUS
43834: PUSH
43835: LD_VAR 0 2
43839: PUSH
43840: LD_INT 1
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: LIST
43847: PUSH
43848: LD_VAR 0 1
43852: PUSH
43853: LD_INT 4
43855: MINUS
43856: PUSH
43857: LD_VAR 0 2
43861: PUSH
43862: LD_INT 4
43864: MINUS
43865: PUSH
43866: LD_INT 2
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: LIST
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: LIST
43878: LIST
43879: LIST
43880: ST_TO_ADDR
// end ; 3 :
43881: GO 44303
43883: LD_INT 3
43885: DOUBLE
43886: EQUAL
43887: IFTRUE 43891
43889: GO 44024
43891: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
43892: LD_ADDR_VAR 0 5
43896: PUSH
43897: LD_VAR 0 1
43901: PUSH
43902: LD_INT 3
43904: PLUS
43905: PUSH
43906: LD_VAR 0 2
43910: PUSH
43911: LD_INT 4
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: LIST
43918: PUSH
43919: LD_VAR 0 1
43923: PUSH
43924: LD_INT 4
43926: PLUS
43927: PUSH
43928: LD_VAR 0 2
43932: PUSH
43933: LD_INT 4
43935: PLUS
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: LIST
43944: PUSH
43945: LD_VAR 0 1
43949: PUSH
43950: LD_INT 4
43952: MINUS
43953: PUSH
43954: LD_VAR 0 2
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: LIST
43966: PUSH
43967: LD_VAR 0 1
43971: PUSH
43972: LD_VAR 0 2
43976: PUSH
43977: LD_INT 4
43979: MINUS
43980: PUSH
43981: LD_INT 3
43983: PUSH
43984: EMPTY
43985: LIST
43986: LIST
43987: LIST
43988: PUSH
43989: LD_VAR 0 1
43993: PUSH
43994: LD_INT 3
43996: MINUS
43997: PUSH
43998: LD_VAR 0 2
44002: PUSH
44003: LD_INT 3
44005: MINUS
44006: PUSH
44007: LD_INT 2
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: LIST
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: ST_TO_ADDR
// end ; 4 :
44022: GO 44303
44024: LD_INT 4
44026: DOUBLE
44027: EQUAL
44028: IFTRUE 44032
44030: GO 44165
44032: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
44033: LD_ADDR_VAR 0 5
44037: PUSH
44038: LD_VAR 0 1
44042: PUSH
44043: LD_VAR 0 2
44047: PUSH
44048: LD_INT 4
44050: PLUS
44051: PUSH
44052: LD_INT 0
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: LIST
44059: PUSH
44060: LD_VAR 0 1
44064: PUSH
44065: LD_INT 3
44067: PLUS
44068: PUSH
44069: LD_VAR 0 2
44073: PUSH
44074: LD_INT 3
44076: PLUS
44077: PUSH
44078: LD_INT 5
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: LIST
44085: PUSH
44086: LD_VAR 0 1
44090: PUSH
44091: LD_INT 4
44093: PLUS
44094: PUSH
44095: LD_VAR 0 2
44099: PUSH
44100: LD_INT 4
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: LIST
44107: PUSH
44108: LD_VAR 0 1
44112: PUSH
44113: LD_VAR 0 2
44117: PUSH
44118: LD_INT 3
44120: MINUS
44121: PUSH
44122: LD_INT 3
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: LIST
44129: PUSH
44130: LD_VAR 0 1
44134: PUSH
44135: LD_INT 4
44137: MINUS
44138: PUSH
44139: LD_VAR 0 2
44143: PUSH
44144: LD_INT 4
44146: MINUS
44147: PUSH
44148: LD_INT 2
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: LIST
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: ST_TO_ADDR
// end ; 5 :
44163: GO 44303
44165: LD_INT 5
44167: DOUBLE
44168: EQUAL
44169: IFTRUE 44173
44171: GO 44302
44173: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
44174: LD_ADDR_VAR 0 5
44178: PUSH
44179: LD_VAR 0 1
44183: PUSH
44184: LD_INT 4
44186: MINUS
44187: PUSH
44188: LD_VAR 0 2
44192: PUSH
44193: LD_INT 1
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: LIST
44200: PUSH
44201: LD_VAR 0 1
44205: PUSH
44206: LD_VAR 0 2
44210: PUSH
44211: LD_INT 4
44213: MINUS
44214: PUSH
44215: LD_INT 3
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: LIST
44222: PUSH
44223: LD_VAR 0 1
44227: PUSH
44228: LD_INT 4
44230: PLUS
44231: PUSH
44232: LD_VAR 0 2
44236: PUSH
44237: LD_INT 4
44239: PLUS
44240: PUSH
44241: LD_INT 5
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: LIST
44248: PUSH
44249: LD_VAR 0 1
44253: PUSH
44254: LD_INT 3
44256: PLUS
44257: PUSH
44258: LD_VAR 0 2
44262: PUSH
44263: LD_INT 4
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: LIST
44270: PUSH
44271: LD_VAR 0 1
44275: PUSH
44276: LD_VAR 0 2
44280: PUSH
44281: LD_INT 3
44283: PLUS
44284: PUSH
44285: LD_INT 0
44287: PUSH
44288: EMPTY
44289: LIST
44290: LIST
44291: LIST
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: LIST
44297: LIST
44298: LIST
44299: ST_TO_ADDR
// end ; end ;
44300: GO 44303
44302: POP
// result := list ;
44303: LD_ADDR_VAR 0 4
44307: PUSH
44308: LD_VAR 0 5
44312: ST_TO_ADDR
// end ;
44313: LD_VAR 0 4
44317: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
44318: LD_INT 0
44320: PPUSH
44321: PPUSH
44322: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
44323: LD_VAR 0 1
44327: NOT
44328: PUSH
44329: LD_VAR 0 2
44333: PUSH
44334: LD_INT 1
44336: PUSH
44337: LD_INT 2
44339: PUSH
44340: LD_INT 3
44342: PUSH
44343: LD_INT 4
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: IN
44352: NOT
44353: OR
44354: IFFALSE 44358
// exit ;
44356: GO 44450
// tmp := [ ] ;
44358: LD_ADDR_VAR 0 5
44362: PUSH
44363: EMPTY
44364: ST_TO_ADDR
// for i in units do
44365: LD_ADDR_VAR 0 4
44369: PUSH
44370: LD_VAR 0 1
44374: PUSH
44375: FOR_IN
44376: IFFALSE 44419
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
44378: LD_ADDR_VAR 0 5
44382: PUSH
44383: LD_VAR 0 5
44387: PPUSH
44388: LD_VAR 0 5
44392: PUSH
44393: LD_INT 1
44395: PLUS
44396: PPUSH
44397: LD_VAR 0 4
44401: PPUSH
44402: LD_VAR 0 2
44406: PPUSH
44407: CALL_OW 259
44411: PPUSH
44412: CALL_OW 2
44416: ST_TO_ADDR
44417: GO 44375
44419: POP
44420: POP
// if not tmp then
44421: LD_VAR 0 5
44425: NOT
44426: IFFALSE 44430
// exit ;
44428: GO 44450
// result := SortListByListDesc ( units , tmp ) ;
44430: LD_ADDR_VAR 0 3
44434: PUSH
44435: LD_VAR 0 1
44439: PPUSH
44440: LD_VAR 0 5
44444: PPUSH
44445: CALL_OW 77
44449: ST_TO_ADDR
// end ;
44450: LD_VAR 0 3
44454: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
44455: LD_INT 0
44457: PPUSH
44458: PPUSH
44459: PPUSH
// result := false ;
44460: LD_ADDR_VAR 0 3
44464: PUSH
44465: LD_INT 0
44467: ST_TO_ADDR
// x := GetX ( building ) ;
44468: LD_ADDR_VAR 0 4
44472: PUSH
44473: LD_VAR 0 2
44477: PPUSH
44478: CALL_OW 250
44482: ST_TO_ADDR
// y := GetY ( building ) ;
44483: LD_ADDR_VAR 0 5
44487: PUSH
44488: LD_VAR 0 2
44492: PPUSH
44493: CALL_OW 251
44497: ST_TO_ADDR
// if not building or not x or not y then
44498: LD_VAR 0 2
44502: NOT
44503: PUSH
44504: LD_VAR 0 4
44508: NOT
44509: OR
44510: PUSH
44511: LD_VAR 0 5
44515: NOT
44516: OR
44517: IFFALSE 44521
// exit ;
44519: GO 44613
// if GetTaskList ( unit ) then
44521: LD_VAR 0 1
44525: PPUSH
44526: CALL_OW 437
44530: IFFALSE 44613
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44532: LD_STRING e
44534: PUSH
44535: LD_VAR 0 1
44539: PPUSH
44540: CALL_OW 437
44544: PUSH
44545: LD_INT 1
44547: ARRAY
44548: PUSH
44549: LD_INT 1
44551: ARRAY
44552: EQUAL
44553: PUSH
44554: LD_VAR 0 4
44558: PUSH
44559: LD_VAR 0 1
44563: PPUSH
44564: CALL_OW 437
44568: PUSH
44569: LD_INT 1
44571: ARRAY
44572: PUSH
44573: LD_INT 2
44575: ARRAY
44576: EQUAL
44577: AND
44578: PUSH
44579: LD_VAR 0 5
44583: PUSH
44584: LD_VAR 0 1
44588: PPUSH
44589: CALL_OW 437
44593: PUSH
44594: LD_INT 1
44596: ARRAY
44597: PUSH
44598: LD_INT 3
44600: ARRAY
44601: EQUAL
44602: AND
44603: IFFALSE 44613
// result := true end ;
44605: LD_ADDR_VAR 0 3
44609: PUSH
44610: LD_INT 1
44612: ST_TO_ADDR
// end ;
44613: LD_VAR 0 3
44617: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
44618: LD_INT 0
44620: PPUSH
// result := false ;
44621: LD_ADDR_VAR 0 4
44625: PUSH
44626: LD_INT 0
44628: ST_TO_ADDR
// if GetTaskList ( unit ) then
44629: LD_VAR 0 1
44633: PPUSH
44634: CALL_OW 437
44638: IFFALSE 44721
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
44640: LD_STRING M
44642: PUSH
44643: LD_VAR 0 1
44647: PPUSH
44648: CALL_OW 437
44652: PUSH
44653: LD_INT 1
44655: ARRAY
44656: PUSH
44657: LD_INT 1
44659: ARRAY
44660: EQUAL
44661: PUSH
44662: LD_VAR 0 2
44666: PUSH
44667: LD_VAR 0 1
44671: PPUSH
44672: CALL_OW 437
44676: PUSH
44677: LD_INT 1
44679: ARRAY
44680: PUSH
44681: LD_INT 2
44683: ARRAY
44684: EQUAL
44685: AND
44686: PUSH
44687: LD_VAR 0 3
44691: PUSH
44692: LD_VAR 0 1
44696: PPUSH
44697: CALL_OW 437
44701: PUSH
44702: LD_INT 1
44704: ARRAY
44705: PUSH
44706: LD_INT 3
44708: ARRAY
44709: EQUAL
44710: AND
44711: IFFALSE 44721
// result := true ;
44713: LD_ADDR_VAR 0 4
44717: PUSH
44718: LD_INT 1
44720: ST_TO_ADDR
// end ; end ;
44721: LD_VAR 0 4
44725: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
44726: LD_INT 0
44728: PPUSH
44729: PPUSH
44730: PPUSH
44731: PPUSH
// if not unit or not area then
44732: LD_VAR 0 1
44736: NOT
44737: PUSH
44738: LD_VAR 0 2
44742: NOT
44743: OR
44744: IFFALSE 44748
// exit ;
44746: GO 44912
// tmp := AreaToList ( area , i ) ;
44748: LD_ADDR_VAR 0 6
44752: PUSH
44753: LD_VAR 0 2
44757: PPUSH
44758: LD_VAR 0 5
44762: PPUSH
44763: CALL_OW 517
44767: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
44768: LD_ADDR_VAR 0 5
44772: PUSH
44773: DOUBLE
44774: LD_INT 1
44776: DEC
44777: ST_TO_ADDR
44778: LD_VAR 0 6
44782: PUSH
44783: LD_INT 1
44785: ARRAY
44786: PUSH
44787: FOR_TO
44788: IFFALSE 44910
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
44790: LD_ADDR_VAR 0 7
44794: PUSH
44795: LD_VAR 0 6
44799: PUSH
44800: LD_INT 1
44802: ARRAY
44803: PUSH
44804: LD_VAR 0 5
44808: ARRAY
44809: PUSH
44810: LD_VAR 0 6
44814: PUSH
44815: LD_INT 2
44817: ARRAY
44818: PUSH
44819: LD_VAR 0 5
44823: ARRAY
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
44829: LD_VAR 0 7
44833: PUSH
44834: LD_INT 1
44836: ARRAY
44837: PPUSH
44838: LD_VAR 0 7
44842: PUSH
44843: LD_INT 2
44845: ARRAY
44846: PPUSH
44847: CALL_OW 428
44851: PUSH
44852: LD_INT 0
44854: EQUAL
44855: IFFALSE 44908
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
44857: LD_VAR 0 1
44861: PPUSH
44862: LD_VAR 0 7
44866: PUSH
44867: LD_INT 1
44869: ARRAY
44870: PPUSH
44871: LD_VAR 0 7
44875: PUSH
44876: LD_INT 2
44878: ARRAY
44879: PPUSH
44880: LD_VAR 0 3
44884: PPUSH
44885: CALL_OW 48
// result := IsPlaced ( unit ) ;
44889: LD_ADDR_VAR 0 4
44893: PUSH
44894: LD_VAR 0 1
44898: PPUSH
44899: CALL_OW 305
44903: ST_TO_ADDR
// exit ;
44904: POP
44905: POP
44906: GO 44912
// end ; end ;
44908: GO 44787
44910: POP
44911: POP
// end ;
44912: LD_VAR 0 4
44916: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
44917: LD_INT 0
44919: PPUSH
44920: PPUSH
44921: PPUSH
// if not side or side > 8 then
44922: LD_VAR 0 1
44926: NOT
44927: PUSH
44928: LD_VAR 0 1
44932: PUSH
44933: LD_INT 8
44935: GREATER
44936: OR
44937: IFFALSE 44941
// exit ;
44939: GO 45128
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
44941: LD_ADDR_VAR 0 4
44945: PUSH
44946: LD_INT 22
44948: PUSH
44949: LD_VAR 0 1
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 21
44960: PUSH
44961: LD_INT 3
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PPUSH
44972: CALL_OW 69
44976: ST_TO_ADDR
// if not tmp then
44977: LD_VAR 0 4
44981: NOT
44982: IFFALSE 44986
// exit ;
44984: GO 45128
// enable_addtolog := true ;
44986: LD_ADDR_OWVAR 81
44990: PUSH
44991: LD_INT 1
44993: ST_TO_ADDR
// AddToLog ( [ ) ;
44994: LD_STRING [
44996: PPUSH
44997: CALL_OW 561
// for i in tmp do
45001: LD_ADDR_VAR 0 3
45005: PUSH
45006: LD_VAR 0 4
45010: PUSH
45011: FOR_IN
45012: IFFALSE 45119
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
45014: LD_STRING [
45016: PUSH
45017: LD_VAR 0 3
45021: PPUSH
45022: CALL_OW 266
45026: STR
45027: PUSH
45028: LD_STRING , 
45030: STR
45031: PUSH
45032: LD_VAR 0 3
45036: PPUSH
45037: CALL_OW 250
45041: STR
45042: PUSH
45043: LD_STRING , 
45045: STR
45046: PUSH
45047: LD_VAR 0 3
45051: PPUSH
45052: CALL_OW 251
45056: STR
45057: PUSH
45058: LD_STRING , 
45060: STR
45061: PUSH
45062: LD_VAR 0 3
45066: PPUSH
45067: CALL_OW 254
45071: STR
45072: PUSH
45073: LD_STRING , 
45075: STR
45076: PUSH
45077: LD_VAR 0 3
45081: PPUSH
45082: LD_INT 1
45084: PPUSH
45085: CALL_OW 268
45089: STR
45090: PUSH
45091: LD_STRING , 
45093: STR
45094: PUSH
45095: LD_VAR 0 3
45099: PPUSH
45100: LD_INT 2
45102: PPUSH
45103: CALL_OW 268
45107: STR
45108: PUSH
45109: LD_STRING ],
45111: STR
45112: PPUSH
45113: CALL_OW 561
// end ;
45117: GO 45011
45119: POP
45120: POP
// AddToLog ( ]; ) ;
45121: LD_STRING ];
45123: PPUSH
45124: CALL_OW 561
// end ;
45128: LD_VAR 0 2
45132: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
45133: LD_INT 0
45135: PPUSH
45136: PPUSH
45137: PPUSH
45138: PPUSH
45139: PPUSH
// if not area or not rate or not max then
45140: LD_VAR 0 1
45144: NOT
45145: PUSH
45146: LD_VAR 0 2
45150: NOT
45151: OR
45152: PUSH
45153: LD_VAR 0 4
45157: NOT
45158: OR
45159: IFFALSE 45163
// exit ;
45161: GO 45355
// while 1 do
45163: LD_INT 1
45165: IFFALSE 45355
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
45167: LD_ADDR_VAR 0 9
45171: PUSH
45172: LD_VAR 0 1
45176: PPUSH
45177: LD_INT 1
45179: PPUSH
45180: CALL_OW 287
45184: PUSH
45185: LD_INT 10
45187: MUL
45188: ST_TO_ADDR
// r := rate / 10 ;
45189: LD_ADDR_VAR 0 7
45193: PUSH
45194: LD_VAR 0 2
45198: PUSH
45199: LD_INT 10
45201: DIVREAL
45202: ST_TO_ADDR
// time := 1 1$00 ;
45203: LD_ADDR_VAR 0 8
45207: PUSH
45208: LD_INT 2100
45210: ST_TO_ADDR
// if amount < min then
45211: LD_VAR 0 9
45215: PUSH
45216: LD_VAR 0 3
45220: LESS
45221: IFFALSE 45239
// r := r * 2 else
45223: LD_ADDR_VAR 0 7
45227: PUSH
45228: LD_VAR 0 7
45232: PUSH
45233: LD_INT 2
45235: MUL
45236: ST_TO_ADDR
45237: GO 45265
// if amount > max then
45239: LD_VAR 0 9
45243: PUSH
45244: LD_VAR 0 4
45248: GREATER
45249: IFFALSE 45265
// r := r / 2 ;
45251: LD_ADDR_VAR 0 7
45255: PUSH
45256: LD_VAR 0 7
45260: PUSH
45261: LD_INT 2
45263: DIVREAL
45264: ST_TO_ADDR
// time := time / r ;
45265: LD_ADDR_VAR 0 8
45269: PUSH
45270: LD_VAR 0 8
45274: PUSH
45275: LD_VAR 0 7
45279: DIVREAL
45280: ST_TO_ADDR
// if time < 0 then
45281: LD_VAR 0 8
45285: PUSH
45286: LD_INT 0
45288: LESS
45289: IFFALSE 45306
// time := time * - 1 ;
45291: LD_ADDR_VAR 0 8
45295: PUSH
45296: LD_VAR 0 8
45300: PUSH
45301: LD_INT 1
45303: NEG
45304: MUL
45305: ST_TO_ADDR
// wait ( time ) ;
45306: LD_VAR 0 8
45310: PPUSH
45311: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
45315: LD_INT 35
45317: PPUSH
45318: LD_INT 875
45320: PPUSH
45321: CALL_OW 12
45325: PPUSH
45326: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
45330: LD_INT 1
45332: PPUSH
45333: LD_INT 5
45335: PPUSH
45336: CALL_OW 12
45340: PPUSH
45341: LD_VAR 0 1
45345: PPUSH
45346: LD_INT 1
45348: PPUSH
45349: CALL_OW 55
// end ;
45353: GO 45163
// end ;
45355: LD_VAR 0 5
45359: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
45360: LD_INT 0
45362: PPUSH
45363: PPUSH
45364: PPUSH
45365: PPUSH
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
// if not turrets or not factories then
45370: LD_VAR 0 1
45374: NOT
45375: PUSH
45376: LD_VAR 0 2
45380: NOT
45381: OR
45382: IFFALSE 45386
// exit ;
45384: GO 45693
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
45386: LD_ADDR_VAR 0 10
45390: PUSH
45391: LD_INT 5
45393: PUSH
45394: LD_INT 6
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 2
45403: PUSH
45404: LD_INT 4
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 3
45413: PUSH
45414: LD_INT 5
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 24
45428: PUSH
45429: LD_INT 25
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 23
45438: PUSH
45439: LD_INT 27
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 42
45452: PUSH
45453: LD_INT 43
45455: PUSH
45456: EMPTY
45457: LIST
45458: LIST
45459: PUSH
45460: LD_INT 44
45462: PUSH
45463: LD_INT 46
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PUSH
45470: LD_INT 45
45472: PUSH
45473: LD_INT 47
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: ST_TO_ADDR
// result := [ ] ;
45490: LD_ADDR_VAR 0 3
45494: PUSH
45495: EMPTY
45496: ST_TO_ADDR
// for i in turrets do
45497: LD_ADDR_VAR 0 4
45501: PUSH
45502: LD_VAR 0 1
45506: PUSH
45507: FOR_IN
45508: IFFALSE 45691
// begin nat := GetNation ( i ) ;
45510: LD_ADDR_VAR 0 7
45514: PUSH
45515: LD_VAR 0 4
45519: PPUSH
45520: CALL_OW 248
45524: ST_TO_ADDR
// weapon := 0 ;
45525: LD_ADDR_VAR 0 8
45529: PUSH
45530: LD_INT 0
45532: ST_TO_ADDR
// if not nat then
45533: LD_VAR 0 7
45537: NOT
45538: IFFALSE 45542
// continue ;
45540: GO 45507
// for j in list [ nat ] do
45542: LD_ADDR_VAR 0 5
45546: PUSH
45547: LD_VAR 0 10
45551: PUSH
45552: LD_VAR 0 7
45556: ARRAY
45557: PUSH
45558: FOR_IN
45559: IFFALSE 45600
// if GetBWeapon ( i ) = j [ 1 ] then
45561: LD_VAR 0 4
45565: PPUSH
45566: CALL_OW 269
45570: PUSH
45571: LD_VAR 0 5
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: EQUAL
45580: IFFALSE 45598
// begin weapon := j [ 2 ] ;
45582: LD_ADDR_VAR 0 8
45586: PUSH
45587: LD_VAR 0 5
45591: PUSH
45592: LD_INT 2
45594: ARRAY
45595: ST_TO_ADDR
// break ;
45596: GO 45600
// end ;
45598: GO 45558
45600: POP
45601: POP
// if not weapon then
45602: LD_VAR 0 8
45606: NOT
45607: IFFALSE 45611
// continue ;
45609: GO 45507
// for k in factories do
45611: LD_ADDR_VAR 0 6
45615: PUSH
45616: LD_VAR 0 2
45620: PUSH
45621: FOR_IN
45622: IFFALSE 45687
// begin weapons := AvailableWeaponList ( k ) ;
45624: LD_ADDR_VAR 0 9
45628: PUSH
45629: LD_VAR 0 6
45633: PPUSH
45634: CALL_OW 478
45638: ST_TO_ADDR
// if not weapons then
45639: LD_VAR 0 9
45643: NOT
45644: IFFALSE 45648
// continue ;
45646: GO 45621
// if weapon in weapons then
45648: LD_VAR 0 8
45652: PUSH
45653: LD_VAR 0 9
45657: IN
45658: IFFALSE 45685
// begin result := [ i , weapon ] ;
45660: LD_ADDR_VAR 0 3
45664: PUSH
45665: LD_VAR 0 4
45669: PUSH
45670: LD_VAR 0 8
45674: PUSH
45675: EMPTY
45676: LIST
45677: LIST
45678: ST_TO_ADDR
// exit ;
45679: POP
45680: POP
45681: POP
45682: POP
45683: GO 45693
// end ; end ;
45685: GO 45621
45687: POP
45688: POP
// end ;
45689: GO 45507
45691: POP
45692: POP
// end ;
45693: LD_VAR 0 3
45697: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
45698: LD_INT 0
45700: PPUSH
// if not side or side > 8 then
45701: LD_VAR 0 3
45705: NOT
45706: PUSH
45707: LD_VAR 0 3
45711: PUSH
45712: LD_INT 8
45714: GREATER
45715: OR
45716: IFFALSE 45720
// exit ;
45718: GO 45779
// if not range then
45720: LD_VAR 0 4
45724: NOT
45725: IFFALSE 45736
// range := - 12 ;
45727: LD_ADDR_VAR 0 4
45731: PUSH
45732: LD_INT 12
45734: NEG
45735: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
45736: LD_VAR 0 1
45740: PPUSH
45741: LD_VAR 0 2
45745: PPUSH
45746: LD_VAR 0 3
45750: PPUSH
45751: LD_VAR 0 4
45755: PPUSH
45756: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
45760: LD_VAR 0 1
45764: PPUSH
45765: LD_VAR 0 2
45769: PPUSH
45770: LD_VAR 0 3
45774: PPUSH
45775: CALL_OW 331
// end ;
45779: LD_VAR 0 5
45783: RET
// export function Video ( mode ) ; begin
45784: LD_INT 0
45786: PPUSH
// ingame_video = mode ;
45787: LD_ADDR_OWVAR 52
45791: PUSH
45792: LD_VAR 0 1
45796: ST_TO_ADDR
// interface_hidden = mode ;
45797: LD_ADDR_OWVAR 54
45801: PUSH
45802: LD_VAR 0 1
45806: ST_TO_ADDR
// end ;
45807: LD_VAR 0 2
45811: RET
// export function Join ( array , element ) ; begin
45812: LD_INT 0
45814: PPUSH
// result := Replace ( array , array + 1 , element ) ;
45815: LD_ADDR_VAR 0 3
45819: PUSH
45820: LD_VAR 0 1
45824: PPUSH
45825: LD_VAR 0 1
45829: PUSH
45830: LD_INT 1
45832: PLUS
45833: PPUSH
45834: LD_VAR 0 2
45838: PPUSH
45839: CALL_OW 1
45843: ST_TO_ADDR
// end ;
45844: LD_VAR 0 3
45848: RET
// export function JoinUnion ( array , element ) ; begin
45849: LD_INT 0
45851: PPUSH
// result := array union element ;
45852: LD_ADDR_VAR 0 3
45856: PUSH
45857: LD_VAR 0 1
45861: PUSH
45862: LD_VAR 0 2
45866: UNION
45867: ST_TO_ADDR
// end ;
45868: LD_VAR 0 3
45872: RET
// export function GetBehemoths ( side ) ; begin
45873: LD_INT 0
45875: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
45876: LD_ADDR_VAR 0 2
45880: PUSH
45881: LD_INT 22
45883: PUSH
45884: LD_VAR 0 1
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 31
45895: PUSH
45896: LD_INT 25
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PPUSH
45907: CALL_OW 69
45911: ST_TO_ADDR
// end ;
45912: LD_VAR 0 2
45916: RET
// export function Shuffle ( array ) ; var i , index ; begin
45917: LD_INT 0
45919: PPUSH
45920: PPUSH
45921: PPUSH
// result := [ ] ;
45922: LD_ADDR_VAR 0 2
45926: PUSH
45927: EMPTY
45928: ST_TO_ADDR
// if not array then
45929: LD_VAR 0 1
45933: NOT
45934: IFFALSE 45938
// exit ;
45936: GO 46037
// Randomize ;
45938: CALL_OW 10
// for i = array downto 1 do
45942: LD_ADDR_VAR 0 3
45946: PUSH
45947: DOUBLE
45948: LD_VAR 0 1
45952: INC
45953: ST_TO_ADDR
45954: LD_INT 1
45956: PUSH
45957: FOR_DOWNTO
45958: IFFALSE 46035
// begin index := rand ( 1 , array ) ;
45960: LD_ADDR_VAR 0 4
45964: PUSH
45965: LD_INT 1
45967: PPUSH
45968: LD_VAR 0 1
45972: PPUSH
45973: CALL_OW 12
45977: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
45978: LD_ADDR_VAR 0 2
45982: PUSH
45983: LD_VAR 0 2
45987: PPUSH
45988: LD_VAR 0 2
45992: PUSH
45993: LD_INT 1
45995: PLUS
45996: PPUSH
45997: LD_VAR 0 1
46001: PUSH
46002: LD_VAR 0 4
46006: ARRAY
46007: PPUSH
46008: CALL_OW 2
46012: ST_TO_ADDR
// array := Delete ( array , index ) ;
46013: LD_ADDR_VAR 0 1
46017: PUSH
46018: LD_VAR 0 1
46022: PPUSH
46023: LD_VAR 0 4
46027: PPUSH
46028: CALL_OW 3
46032: ST_TO_ADDR
// end ;
46033: GO 45957
46035: POP
46036: POP
// end ;
46037: LD_VAR 0 2
46041: RET
// export function GetBaseMaterials ( base ) ; begin
46042: LD_INT 0
46044: PPUSH
// result := [ 0 , 0 , 0 ] ;
46045: LD_ADDR_VAR 0 2
46049: PUSH
46050: LD_INT 0
46052: PUSH
46053: LD_INT 0
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: LIST
46063: ST_TO_ADDR
// if not base then
46064: LD_VAR 0 1
46068: NOT
46069: IFFALSE 46073
// exit ;
46071: GO 46122
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
46073: LD_ADDR_VAR 0 2
46077: PUSH
46078: LD_VAR 0 1
46082: PPUSH
46083: LD_INT 1
46085: PPUSH
46086: CALL_OW 275
46090: PUSH
46091: LD_VAR 0 1
46095: PPUSH
46096: LD_INT 2
46098: PPUSH
46099: CALL_OW 275
46103: PUSH
46104: LD_VAR 0 1
46108: PPUSH
46109: LD_INT 3
46111: PPUSH
46112: CALL_OW 275
46116: PUSH
46117: EMPTY
46118: LIST
46119: LIST
46120: LIST
46121: ST_TO_ADDR
// end ;
46122: LD_VAR 0 2
46126: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
46127: LD_INT 0
46129: PPUSH
46130: PPUSH
// result := array ;
46131: LD_ADDR_VAR 0 3
46135: PUSH
46136: LD_VAR 0 1
46140: ST_TO_ADDR
// if size > 0 then
46141: LD_VAR 0 2
46145: PUSH
46146: LD_INT 0
46148: GREATER
46149: IFFALSE 46195
// for i := array downto size do
46151: LD_ADDR_VAR 0 4
46155: PUSH
46156: DOUBLE
46157: LD_VAR 0 1
46161: INC
46162: ST_TO_ADDR
46163: LD_VAR 0 2
46167: PUSH
46168: FOR_DOWNTO
46169: IFFALSE 46193
// result := Delete ( result , result ) ;
46171: LD_ADDR_VAR 0 3
46175: PUSH
46176: LD_VAR 0 3
46180: PPUSH
46181: LD_VAR 0 3
46185: PPUSH
46186: CALL_OW 3
46190: ST_TO_ADDR
46191: GO 46168
46193: POP
46194: POP
// end ;
46195: LD_VAR 0 3
46199: RET
// export function ComExit ( unit ) ; var tmp ; begin
46200: LD_INT 0
46202: PPUSH
46203: PPUSH
// if not IsInUnit ( unit ) then
46204: LD_VAR 0 1
46208: PPUSH
46209: CALL_OW 310
46213: NOT
46214: IFFALSE 46218
// exit ;
46216: GO 46278
// tmp := IsInUnit ( unit ) ;
46218: LD_ADDR_VAR 0 3
46222: PUSH
46223: LD_VAR 0 1
46227: PPUSH
46228: CALL_OW 310
46232: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
46233: LD_VAR 0 3
46237: PPUSH
46238: CALL_OW 247
46242: PUSH
46243: LD_INT 2
46245: EQUAL
46246: IFFALSE 46259
// ComExitVehicle ( unit ) else
46248: LD_VAR 0 1
46252: PPUSH
46253: CALL_OW 121
46257: GO 46268
// ComExitBuilding ( unit ) ;
46259: LD_VAR 0 1
46263: PPUSH
46264: CALL_OW 122
// result := tmp ;
46268: LD_ADDR_VAR 0 2
46272: PUSH
46273: LD_VAR 0 3
46277: ST_TO_ADDR
// end ;
46278: LD_VAR 0 2
46282: RET
// export function ComExitAll ( units ) ; var i ; begin
46283: LD_INT 0
46285: PPUSH
46286: PPUSH
// if not units then
46287: LD_VAR 0 1
46291: NOT
46292: IFFALSE 46296
// exit ;
46294: GO 46322
// for i in units do
46296: LD_ADDR_VAR 0 3
46300: PUSH
46301: LD_VAR 0 1
46305: PUSH
46306: FOR_IN
46307: IFFALSE 46320
// ComExit ( i ) ;
46309: LD_VAR 0 3
46313: PPUSH
46314: CALL 46200 0 1
46318: GO 46306
46320: POP
46321: POP
// end ;
46322: LD_VAR 0 2
46326: RET
// export function ResetHc ; begin
46327: LD_INT 0
46329: PPUSH
// InitHc ;
46330: CALL_OW 19
// hc_importance := 0 ;
46334: LD_ADDR_OWVAR 32
46338: PUSH
46339: LD_INT 0
46341: ST_TO_ADDR
// end ;
46342: LD_VAR 0 1
46346: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
46347: LD_INT 0
46349: PPUSH
46350: PPUSH
46351: PPUSH
// _x := ( x1 + x2 ) div 2 ;
46352: LD_ADDR_VAR 0 6
46356: PUSH
46357: LD_VAR 0 1
46361: PUSH
46362: LD_VAR 0 3
46366: PLUS
46367: PUSH
46368: LD_INT 2
46370: DIV
46371: ST_TO_ADDR
// if _x < 0 then
46372: LD_VAR 0 6
46376: PUSH
46377: LD_INT 0
46379: LESS
46380: IFFALSE 46397
// _x := _x * - 1 ;
46382: LD_ADDR_VAR 0 6
46386: PUSH
46387: LD_VAR 0 6
46391: PUSH
46392: LD_INT 1
46394: NEG
46395: MUL
46396: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
46397: LD_ADDR_VAR 0 7
46401: PUSH
46402: LD_VAR 0 2
46406: PUSH
46407: LD_VAR 0 4
46411: PLUS
46412: PUSH
46413: LD_INT 2
46415: DIV
46416: ST_TO_ADDR
// if _y < 0 then
46417: LD_VAR 0 7
46421: PUSH
46422: LD_INT 0
46424: LESS
46425: IFFALSE 46442
// _y := _y * - 1 ;
46427: LD_ADDR_VAR 0 7
46431: PUSH
46432: LD_VAR 0 7
46436: PUSH
46437: LD_INT 1
46439: NEG
46440: MUL
46441: ST_TO_ADDR
// result := [ _x , _y ] ;
46442: LD_ADDR_VAR 0 5
46446: PUSH
46447: LD_VAR 0 6
46451: PUSH
46452: LD_VAR 0 7
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: ST_TO_ADDR
// end ;
46461: LD_VAR 0 5
46465: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
46466: LD_INT 0
46468: PPUSH
46469: PPUSH
46470: PPUSH
46471: PPUSH
// task := GetTaskList ( unit ) ;
46472: LD_ADDR_VAR 0 7
46476: PUSH
46477: LD_VAR 0 1
46481: PPUSH
46482: CALL_OW 437
46486: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
46487: LD_VAR 0 7
46491: NOT
46492: PUSH
46493: LD_VAR 0 1
46497: PPUSH
46498: LD_VAR 0 2
46502: PPUSH
46503: CALL_OW 308
46507: NOT
46508: AND
46509: IFFALSE 46513
// exit ;
46511: GO 46631
// if IsInArea ( unit , area ) then
46513: LD_VAR 0 1
46517: PPUSH
46518: LD_VAR 0 2
46522: PPUSH
46523: CALL_OW 308
46527: IFFALSE 46545
// begin ComMoveToArea ( unit , goAway ) ;
46529: LD_VAR 0 1
46533: PPUSH
46534: LD_VAR 0 3
46538: PPUSH
46539: CALL_OW 113
// exit ;
46543: GO 46631
// end ; if task [ 1 ] [ 1 ] <> M then
46545: LD_VAR 0 7
46549: PUSH
46550: LD_INT 1
46552: ARRAY
46553: PUSH
46554: LD_INT 1
46556: ARRAY
46557: PUSH
46558: LD_STRING M
46560: NONEQUAL
46561: IFFALSE 46565
// exit ;
46563: GO 46631
// x := task [ 1 ] [ 2 ] ;
46565: LD_ADDR_VAR 0 5
46569: PUSH
46570: LD_VAR 0 7
46574: PUSH
46575: LD_INT 1
46577: ARRAY
46578: PUSH
46579: LD_INT 2
46581: ARRAY
46582: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
46583: LD_ADDR_VAR 0 6
46587: PUSH
46588: LD_VAR 0 7
46592: PUSH
46593: LD_INT 1
46595: ARRAY
46596: PUSH
46597: LD_INT 3
46599: ARRAY
46600: ST_TO_ADDR
// if InArea ( x , y , area ) then
46601: LD_VAR 0 5
46605: PPUSH
46606: LD_VAR 0 6
46610: PPUSH
46611: LD_VAR 0 2
46615: PPUSH
46616: CALL_OW 309
46620: IFFALSE 46631
// ComStop ( unit ) ;
46622: LD_VAR 0 1
46626: PPUSH
46627: CALL_OW 141
// end ;
46631: LD_VAR 0 4
46635: RET
// export function Abs ( value ) ; begin
46636: LD_INT 0
46638: PPUSH
// result := value ;
46639: LD_ADDR_VAR 0 2
46643: PUSH
46644: LD_VAR 0 1
46648: ST_TO_ADDR
// if value < 0 then
46649: LD_VAR 0 1
46653: PUSH
46654: LD_INT 0
46656: LESS
46657: IFFALSE 46674
// result := value * - 1 ;
46659: LD_ADDR_VAR 0 2
46663: PUSH
46664: LD_VAR 0 1
46668: PUSH
46669: LD_INT 1
46671: NEG
46672: MUL
46673: ST_TO_ADDR
// end ;
46674: LD_VAR 0 2
46678: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
46679: LD_INT 0
46681: PPUSH
46682: PPUSH
46683: PPUSH
46684: PPUSH
46685: PPUSH
46686: PPUSH
46687: PPUSH
46688: PPUSH
// if not unit or not building then
46689: LD_VAR 0 1
46693: NOT
46694: PUSH
46695: LD_VAR 0 2
46699: NOT
46700: OR
46701: IFFALSE 46705
// exit ;
46703: GO 46931
// x := GetX ( building ) ;
46705: LD_ADDR_VAR 0 4
46709: PUSH
46710: LD_VAR 0 2
46714: PPUSH
46715: CALL_OW 250
46719: ST_TO_ADDR
// y := GetY ( building ) ;
46720: LD_ADDR_VAR 0 6
46724: PUSH
46725: LD_VAR 0 2
46729: PPUSH
46730: CALL_OW 251
46734: ST_TO_ADDR
// d := GetDir ( building ) ;
46735: LD_ADDR_VAR 0 8
46739: PUSH
46740: LD_VAR 0 2
46744: PPUSH
46745: CALL_OW 254
46749: ST_TO_ADDR
// r := 4 ;
46750: LD_ADDR_VAR 0 9
46754: PUSH
46755: LD_INT 4
46757: ST_TO_ADDR
// for i := 1 to 5 do
46758: LD_ADDR_VAR 0 10
46762: PUSH
46763: DOUBLE
46764: LD_INT 1
46766: DEC
46767: ST_TO_ADDR
46768: LD_INT 5
46770: PUSH
46771: FOR_TO
46772: IFFALSE 46929
// begin _x := ShiftX ( x , d , r + i ) ;
46774: LD_ADDR_VAR 0 5
46778: PUSH
46779: LD_VAR 0 4
46783: PPUSH
46784: LD_VAR 0 8
46788: PPUSH
46789: LD_VAR 0 9
46793: PUSH
46794: LD_VAR 0 10
46798: PLUS
46799: PPUSH
46800: CALL_OW 272
46804: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
46805: LD_ADDR_VAR 0 7
46809: PUSH
46810: LD_VAR 0 6
46814: PPUSH
46815: LD_VAR 0 8
46819: PPUSH
46820: LD_VAR 0 9
46824: PUSH
46825: LD_VAR 0 10
46829: PLUS
46830: PPUSH
46831: CALL_OW 273
46835: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
46836: LD_VAR 0 5
46840: PPUSH
46841: LD_VAR 0 7
46845: PPUSH
46846: CALL_OW 488
46850: PUSH
46851: LD_VAR 0 5
46855: PPUSH
46856: LD_VAR 0 7
46860: PPUSH
46861: CALL_OW 428
46865: PPUSH
46866: CALL_OW 247
46870: PUSH
46871: LD_INT 3
46873: PUSH
46874: LD_INT 2
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: IN
46881: NOT
46882: AND
46883: IFFALSE 46927
// begin ComMoveXY ( unit , _x , _y ) ;
46885: LD_VAR 0 1
46889: PPUSH
46890: LD_VAR 0 5
46894: PPUSH
46895: LD_VAR 0 7
46899: PPUSH
46900: CALL_OW 111
// result := [ _x , _y ] ;
46904: LD_ADDR_VAR 0 3
46908: PUSH
46909: LD_VAR 0 5
46913: PUSH
46914: LD_VAR 0 7
46918: PUSH
46919: EMPTY
46920: LIST
46921: LIST
46922: ST_TO_ADDR
// exit ;
46923: POP
46924: POP
46925: GO 46931
// end ; end ;
46927: GO 46771
46929: POP
46930: POP
// end ;
46931: LD_VAR 0 3
46935: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
46936: LD_INT 0
46938: PPUSH
46939: PPUSH
46940: PPUSH
// result := 0 ;
46941: LD_ADDR_VAR 0 3
46945: PUSH
46946: LD_INT 0
46948: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
46949: LD_VAR 0 1
46953: PUSH
46954: LD_INT 0
46956: LESS
46957: PUSH
46958: LD_VAR 0 1
46962: PUSH
46963: LD_INT 8
46965: GREATER
46966: OR
46967: PUSH
46968: LD_VAR 0 2
46972: PUSH
46973: LD_INT 0
46975: LESS
46976: OR
46977: PUSH
46978: LD_VAR 0 2
46982: PUSH
46983: LD_INT 8
46985: GREATER
46986: OR
46987: IFFALSE 46991
// exit ;
46989: GO 47066
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
46991: LD_ADDR_VAR 0 4
46995: PUSH
46996: LD_INT 22
46998: PUSH
46999: LD_VAR 0 2
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: PPUSH
47008: CALL_OW 69
47012: PUSH
47013: FOR_IN
47014: IFFALSE 47064
// begin un := UnitShoot ( i ) ;
47016: LD_ADDR_VAR 0 5
47020: PUSH
47021: LD_VAR 0 4
47025: PPUSH
47026: CALL_OW 504
47030: ST_TO_ADDR
// if GetSide ( un ) = side1 then
47031: LD_VAR 0 5
47035: PPUSH
47036: CALL_OW 255
47040: PUSH
47041: LD_VAR 0 1
47045: EQUAL
47046: IFFALSE 47062
// begin result := un ;
47048: LD_ADDR_VAR 0 3
47052: PUSH
47053: LD_VAR 0 5
47057: ST_TO_ADDR
// exit ;
47058: POP
47059: POP
47060: GO 47066
// end ; end ;
47062: GO 47013
47064: POP
47065: POP
// end ;
47066: LD_VAR 0 3
47070: RET
// export function GetCargoBay ( units ) ; begin
47071: LD_INT 0
47073: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
47074: LD_ADDR_VAR 0 2
47078: PUSH
47079: LD_VAR 0 1
47083: PPUSH
47084: LD_INT 2
47086: PUSH
47087: LD_INT 34
47089: PUSH
47090: LD_INT 12
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: LD_INT 34
47099: PUSH
47100: LD_INT 51
47102: PUSH
47103: EMPTY
47104: LIST
47105: LIST
47106: PUSH
47107: LD_INT 34
47109: PUSH
47110: LD_INT 32
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PUSH
47117: LD_INT 34
47119: PUSH
47120: LD_EXP 68
47124: PUSH
47125: EMPTY
47126: LIST
47127: LIST
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: LIST
47133: LIST
47134: LIST
47135: PPUSH
47136: CALL_OW 72
47140: ST_TO_ADDR
// end ;
47141: LD_VAR 0 2
47145: RET
// export function Negate ( value ) ; begin
47146: LD_INT 0
47148: PPUSH
// result := not value ;
47149: LD_ADDR_VAR 0 2
47153: PUSH
47154: LD_VAR 0 1
47158: NOT
47159: ST_TO_ADDR
// end ;
47160: LD_VAR 0 2
47164: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
47165: LD_INT 0
47167: PPUSH
// if x1 = x2 then
47168: LD_VAR 0 1
47172: PUSH
47173: LD_VAR 0 3
47177: EQUAL
47178: IFFALSE 47212
// begin if y1 > y2 then
47180: LD_VAR 0 2
47184: PUSH
47185: LD_VAR 0 4
47189: GREATER
47190: IFFALSE 47202
// result := 0 else
47192: LD_ADDR_VAR 0 5
47196: PUSH
47197: LD_INT 0
47199: ST_TO_ADDR
47200: GO 47210
// result := 3 ;
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: LD_INT 3
47209: ST_TO_ADDR
// exit ;
47210: GO 47298
// end ; if y1 = y2 then
47212: LD_VAR 0 2
47216: PUSH
47217: LD_VAR 0 4
47221: EQUAL
47222: IFFALSE 47256
// begin if x1 > x2 then
47224: LD_VAR 0 1
47228: PUSH
47229: LD_VAR 0 3
47233: GREATER
47234: IFFALSE 47246
// result := 1 else
47236: LD_ADDR_VAR 0 5
47240: PUSH
47241: LD_INT 1
47243: ST_TO_ADDR
47244: GO 47254
// result := 4 ;
47246: LD_ADDR_VAR 0 5
47250: PUSH
47251: LD_INT 4
47253: ST_TO_ADDR
// exit ;
47254: GO 47298
// end ; if x1 > x2 and y1 > y2 then
47256: LD_VAR 0 1
47260: PUSH
47261: LD_VAR 0 3
47265: GREATER
47266: PUSH
47267: LD_VAR 0 2
47271: PUSH
47272: LD_VAR 0 4
47276: GREATER
47277: AND
47278: IFFALSE 47290
// result := 2 else
47280: LD_ADDR_VAR 0 5
47284: PUSH
47285: LD_INT 2
47287: ST_TO_ADDR
47288: GO 47298
// result := 5 ;
47290: LD_ADDR_VAR 0 5
47294: PUSH
47295: LD_INT 5
47297: ST_TO_ADDR
// end ;
47298: LD_VAR 0 5
47302: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
47303: LD_INT 0
47305: PPUSH
47306: PPUSH
// if not driver or not IsInUnit ( driver ) then
47307: LD_VAR 0 1
47311: NOT
47312: PUSH
47313: LD_VAR 0 1
47317: PPUSH
47318: CALL_OW 310
47322: NOT
47323: OR
47324: IFFALSE 47328
// exit ;
47326: GO 47418
// vehicle := IsInUnit ( driver ) ;
47328: LD_ADDR_VAR 0 3
47332: PUSH
47333: LD_VAR 0 1
47337: PPUSH
47338: CALL_OW 310
47342: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
47343: LD_VAR 0 1
47347: PPUSH
47348: LD_STRING \
47350: PUSH
47351: LD_INT 0
47353: PUSH
47354: LD_INT 0
47356: PUSH
47357: LD_INT 0
47359: PUSH
47360: LD_INT 0
47362: PUSH
47363: LD_INT 0
47365: PUSH
47366: LD_INT 0
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: LIST
47373: LIST
47374: LIST
47375: LIST
47376: LIST
47377: PUSH
47378: LD_STRING E
47380: PUSH
47381: LD_INT 0
47383: PUSH
47384: LD_INT 0
47386: PUSH
47387: LD_VAR 0 3
47391: PUSH
47392: LD_INT 0
47394: PUSH
47395: LD_INT 0
47397: PUSH
47398: LD_INT 0
47400: PUSH
47401: EMPTY
47402: LIST
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: LIST
47413: PPUSH
47414: CALL_OW 446
// end ;
47418: LD_VAR 0 2
47422: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
47423: LD_INT 0
47425: PPUSH
47426: PPUSH
47427: PPUSH
// tmp := [ ] ;
47428: LD_ADDR_VAR 0 5
47432: PUSH
47433: EMPTY
47434: ST_TO_ADDR
// for i in units do
47435: LD_ADDR_VAR 0 4
47439: PUSH
47440: LD_VAR 0 1
47444: PUSH
47445: FOR_IN
47446: IFFALSE 47484
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
47448: LD_ADDR_VAR 0 5
47452: PUSH
47453: LD_VAR 0 5
47457: PPUSH
47458: LD_VAR 0 5
47462: PUSH
47463: LD_INT 1
47465: PLUS
47466: PPUSH
47467: LD_VAR 0 4
47471: PPUSH
47472: CALL_OW 256
47476: PPUSH
47477: CALL_OW 2
47481: ST_TO_ADDR
47482: GO 47445
47484: POP
47485: POP
// if not tmp then
47486: LD_VAR 0 5
47490: NOT
47491: IFFALSE 47495
// exit ;
47493: GO 47543
// if asc then
47495: LD_VAR 0 2
47499: IFFALSE 47523
// result := SortListByListAsc ( units , tmp ) else
47501: LD_ADDR_VAR 0 3
47505: PUSH
47506: LD_VAR 0 1
47510: PPUSH
47511: LD_VAR 0 5
47515: PPUSH
47516: CALL_OW 76
47520: ST_TO_ADDR
47521: GO 47543
// result := SortListByListDesc ( units , tmp ) ;
47523: LD_ADDR_VAR 0 3
47527: PUSH
47528: LD_VAR 0 1
47532: PPUSH
47533: LD_VAR 0 5
47537: PPUSH
47538: CALL_OW 77
47542: ST_TO_ADDR
// end ;
47543: LD_VAR 0 3
47547: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
47548: LD_INT 0
47550: PPUSH
47551: PPUSH
// task := GetTaskList ( mech ) ;
47552: LD_ADDR_VAR 0 4
47556: PUSH
47557: LD_VAR 0 1
47561: PPUSH
47562: CALL_OW 437
47566: ST_TO_ADDR
// if not task then
47567: LD_VAR 0 4
47571: NOT
47572: IFFALSE 47576
// exit ;
47574: GO 47618
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
47576: LD_ADDR_VAR 0 3
47580: PUSH
47581: LD_VAR 0 4
47585: PUSH
47586: LD_INT 1
47588: ARRAY
47589: PUSH
47590: LD_INT 1
47592: ARRAY
47593: PUSH
47594: LD_STRING r
47596: EQUAL
47597: PUSH
47598: LD_VAR 0 4
47602: PUSH
47603: LD_INT 1
47605: ARRAY
47606: PUSH
47607: LD_INT 4
47609: ARRAY
47610: PUSH
47611: LD_VAR 0 2
47615: EQUAL
47616: AND
47617: ST_TO_ADDR
// end ; end_of_file
47618: LD_VAR 0 3
47622: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
47623: LD_INT 0
47625: PPUSH
47626: PPUSH
// skirmish := false ;
47627: LD_ADDR_EXP 21
47631: PUSH
47632: LD_INT 0
47634: ST_TO_ADDR
// debug_mc := false ;
47635: LD_ADDR_EXP 22
47639: PUSH
47640: LD_INT 0
47642: ST_TO_ADDR
// mc_bases := [ ] ;
47643: LD_ADDR_EXP 23
47647: PUSH
47648: EMPTY
47649: ST_TO_ADDR
// mc_sides := [ ] ;
47650: LD_ADDR_EXP 49
47654: PUSH
47655: EMPTY
47656: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
47657: LD_ADDR_EXP 24
47661: PUSH
47662: EMPTY
47663: ST_TO_ADDR
// mc_building_repairs := [ ] ;
47664: LD_ADDR_EXP 25
47668: PUSH
47669: EMPTY
47670: ST_TO_ADDR
// mc_need_heal := [ ] ;
47671: LD_ADDR_EXP 26
47675: PUSH
47676: EMPTY
47677: ST_TO_ADDR
// mc_healers := [ ] ;
47678: LD_ADDR_EXP 27
47682: PUSH
47683: EMPTY
47684: ST_TO_ADDR
// mc_build_list := [ ] ;
47685: LD_ADDR_EXP 28
47689: PUSH
47690: EMPTY
47691: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
47692: LD_ADDR_EXP 55
47696: PUSH
47697: EMPTY
47698: ST_TO_ADDR
// mc_builders := [ ] ;
47699: LD_ADDR_EXP 29
47703: PUSH
47704: EMPTY
47705: ST_TO_ADDR
// mc_construct_list := [ ] ;
47706: LD_ADDR_EXP 30
47710: PUSH
47711: EMPTY
47712: ST_TO_ADDR
// mc_turret_list := [ ] ;
47713: LD_ADDR_EXP 31
47717: PUSH
47718: EMPTY
47719: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
47720: LD_ADDR_EXP 32
47724: PUSH
47725: EMPTY
47726: ST_TO_ADDR
// mc_miners := [ ] ;
47727: LD_ADDR_EXP 37
47731: PUSH
47732: EMPTY
47733: ST_TO_ADDR
// mc_mines := [ ] ;
47734: LD_ADDR_EXP 36
47738: PUSH
47739: EMPTY
47740: ST_TO_ADDR
// mc_minefields := [ ] ;
47741: LD_ADDR_EXP 38
47745: PUSH
47746: EMPTY
47747: ST_TO_ADDR
// mc_crates := [ ] ;
47748: LD_ADDR_EXP 39
47752: PUSH
47753: EMPTY
47754: ST_TO_ADDR
// mc_crates_collector := [ ] ;
47755: LD_ADDR_EXP 40
47759: PUSH
47760: EMPTY
47761: ST_TO_ADDR
// mc_crates_area := [ ] ;
47762: LD_ADDR_EXP 41
47766: PUSH
47767: EMPTY
47768: ST_TO_ADDR
// mc_vehicles := [ ] ;
47769: LD_ADDR_EXP 42
47773: PUSH
47774: EMPTY
47775: ST_TO_ADDR
// mc_attack := [ ] ;
47776: LD_ADDR_EXP 43
47780: PUSH
47781: EMPTY
47782: ST_TO_ADDR
// mc_produce := [ ] ;
47783: LD_ADDR_EXP 44
47787: PUSH
47788: EMPTY
47789: ST_TO_ADDR
// mc_defender := [ ] ;
47790: LD_ADDR_EXP 45
47794: PUSH
47795: EMPTY
47796: ST_TO_ADDR
// mc_parking := [ ] ;
47797: LD_ADDR_EXP 47
47801: PUSH
47802: EMPTY
47803: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
47804: LD_ADDR_EXP 33
47808: PUSH
47809: EMPTY
47810: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
47811: LD_ADDR_EXP 35
47815: PUSH
47816: EMPTY
47817: ST_TO_ADDR
// mc_scan := [ ] ;
47818: LD_ADDR_EXP 46
47822: PUSH
47823: EMPTY
47824: ST_TO_ADDR
// mc_scan_area := [ ] ;
47825: LD_ADDR_EXP 48
47829: PUSH
47830: EMPTY
47831: ST_TO_ADDR
// mc_tech := [ ] ;
47832: LD_ADDR_EXP 50
47836: PUSH
47837: EMPTY
47838: ST_TO_ADDR
// mc_class := [ ] ;
47839: LD_ADDR_EXP 64
47843: PUSH
47844: EMPTY
47845: ST_TO_ADDR
// mc_class_case_use := [ ] ;
47846: LD_ADDR_EXP 65
47850: PUSH
47851: EMPTY
47852: ST_TO_ADDR
// mc_is_defending := [ ] ;
47853: LD_ADDR_EXP 66
47857: PUSH
47858: EMPTY
47859: ST_TO_ADDR
// end ;
47860: LD_VAR 0 1
47864: RET
// export function MC_Kill ( base ) ; begin
47865: LD_INT 0
47867: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
47868: LD_ADDR_EXP 23
47872: PUSH
47873: LD_EXP 23
47877: PPUSH
47878: LD_VAR 0 1
47882: PPUSH
47883: EMPTY
47884: PPUSH
47885: CALL_OW 1
47889: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
47890: LD_ADDR_EXP 24
47894: PUSH
47895: LD_EXP 24
47899: PPUSH
47900: LD_VAR 0 1
47904: PPUSH
47905: EMPTY
47906: PPUSH
47907: CALL_OW 1
47911: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
47912: LD_ADDR_EXP 25
47916: PUSH
47917: LD_EXP 25
47921: PPUSH
47922: LD_VAR 0 1
47926: PPUSH
47927: EMPTY
47928: PPUSH
47929: CALL_OW 1
47933: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
47934: LD_ADDR_EXP 26
47938: PUSH
47939: LD_EXP 26
47943: PPUSH
47944: LD_VAR 0 1
47948: PPUSH
47949: EMPTY
47950: PPUSH
47951: CALL_OW 1
47955: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
47956: LD_ADDR_EXP 27
47960: PUSH
47961: LD_EXP 27
47965: PPUSH
47966: LD_VAR 0 1
47970: PPUSH
47971: EMPTY
47972: PPUSH
47973: CALL_OW 1
47977: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
47978: LD_ADDR_EXP 28
47982: PUSH
47983: LD_EXP 28
47987: PPUSH
47988: LD_VAR 0 1
47992: PPUSH
47993: EMPTY
47994: PPUSH
47995: CALL_OW 1
47999: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48000: LD_ADDR_EXP 29
48004: PUSH
48005: LD_EXP 29
48009: PPUSH
48010: LD_VAR 0 1
48014: PPUSH
48015: EMPTY
48016: PPUSH
48017: CALL_OW 1
48021: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
48022: LD_ADDR_EXP 30
48026: PUSH
48027: LD_EXP 30
48031: PPUSH
48032: LD_VAR 0 1
48036: PPUSH
48037: EMPTY
48038: PPUSH
48039: CALL_OW 1
48043: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
48044: LD_ADDR_EXP 31
48048: PUSH
48049: LD_EXP 31
48053: PPUSH
48054: LD_VAR 0 1
48058: PPUSH
48059: EMPTY
48060: PPUSH
48061: CALL_OW 1
48065: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
48066: LD_ADDR_EXP 32
48070: PUSH
48071: LD_EXP 32
48075: PPUSH
48076: LD_VAR 0 1
48080: PPUSH
48081: EMPTY
48082: PPUSH
48083: CALL_OW 1
48087: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
48088: LD_ADDR_EXP 33
48092: PUSH
48093: LD_EXP 33
48097: PPUSH
48098: LD_VAR 0 1
48102: PPUSH
48103: EMPTY
48104: PPUSH
48105: CALL_OW 1
48109: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
48110: LD_ADDR_EXP 34
48114: PUSH
48115: LD_EXP 34
48119: PPUSH
48120: LD_VAR 0 1
48124: PPUSH
48125: LD_INT 0
48127: PPUSH
48128: CALL_OW 1
48132: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
48133: LD_ADDR_EXP 35
48137: PUSH
48138: LD_EXP 35
48142: PPUSH
48143: LD_VAR 0 1
48147: PPUSH
48148: EMPTY
48149: PPUSH
48150: CALL_OW 1
48154: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
48155: LD_ADDR_EXP 36
48159: PUSH
48160: LD_EXP 36
48164: PPUSH
48165: LD_VAR 0 1
48169: PPUSH
48170: EMPTY
48171: PPUSH
48172: CALL_OW 1
48176: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
48177: LD_ADDR_EXP 37
48181: PUSH
48182: LD_EXP 37
48186: PPUSH
48187: LD_VAR 0 1
48191: PPUSH
48192: EMPTY
48193: PPUSH
48194: CALL_OW 1
48198: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
48199: LD_ADDR_EXP 38
48203: PUSH
48204: LD_EXP 38
48208: PPUSH
48209: LD_VAR 0 1
48213: PPUSH
48214: EMPTY
48215: PPUSH
48216: CALL_OW 1
48220: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
48221: LD_ADDR_EXP 39
48225: PUSH
48226: LD_EXP 39
48230: PPUSH
48231: LD_VAR 0 1
48235: PPUSH
48236: EMPTY
48237: PPUSH
48238: CALL_OW 1
48242: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
48243: LD_ADDR_EXP 40
48247: PUSH
48248: LD_EXP 40
48252: PPUSH
48253: LD_VAR 0 1
48257: PPUSH
48258: EMPTY
48259: PPUSH
48260: CALL_OW 1
48264: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
48265: LD_ADDR_EXP 41
48269: PUSH
48270: LD_EXP 41
48274: PPUSH
48275: LD_VAR 0 1
48279: PPUSH
48280: EMPTY
48281: PPUSH
48282: CALL_OW 1
48286: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
48287: LD_ADDR_EXP 42
48291: PUSH
48292: LD_EXP 42
48296: PPUSH
48297: LD_VAR 0 1
48301: PPUSH
48302: EMPTY
48303: PPUSH
48304: CALL_OW 1
48308: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
48309: LD_ADDR_EXP 43
48313: PUSH
48314: LD_EXP 43
48318: PPUSH
48319: LD_VAR 0 1
48323: PPUSH
48324: EMPTY
48325: PPUSH
48326: CALL_OW 1
48330: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
48331: LD_ADDR_EXP 44
48335: PUSH
48336: LD_EXP 44
48340: PPUSH
48341: LD_VAR 0 1
48345: PPUSH
48346: EMPTY
48347: PPUSH
48348: CALL_OW 1
48352: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
48353: LD_ADDR_EXP 45
48357: PUSH
48358: LD_EXP 45
48362: PPUSH
48363: LD_VAR 0 1
48367: PPUSH
48368: EMPTY
48369: PPUSH
48370: CALL_OW 1
48374: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
48375: LD_ADDR_EXP 46
48379: PUSH
48380: LD_EXP 46
48384: PPUSH
48385: LD_VAR 0 1
48389: PPUSH
48390: EMPTY
48391: PPUSH
48392: CALL_OW 1
48396: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
48397: LD_ADDR_EXP 47
48401: PUSH
48402: LD_EXP 47
48406: PPUSH
48407: LD_VAR 0 1
48411: PPUSH
48412: EMPTY
48413: PPUSH
48414: CALL_OW 1
48418: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
48419: LD_ADDR_EXP 48
48423: PUSH
48424: LD_EXP 48
48428: PPUSH
48429: LD_VAR 0 1
48433: PPUSH
48434: EMPTY
48435: PPUSH
48436: CALL_OW 1
48440: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
48441: LD_ADDR_EXP 50
48445: PUSH
48446: LD_EXP 50
48450: PPUSH
48451: LD_VAR 0 1
48455: PPUSH
48456: EMPTY
48457: PPUSH
48458: CALL_OW 1
48462: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
48463: LD_ADDR_EXP 52
48467: PUSH
48468: LD_EXP 52
48472: PPUSH
48473: LD_VAR 0 1
48477: PPUSH
48478: EMPTY
48479: PPUSH
48480: CALL_OW 1
48484: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
48485: LD_ADDR_EXP 53
48489: PUSH
48490: LD_EXP 53
48494: PPUSH
48495: LD_VAR 0 1
48499: PPUSH
48500: EMPTY
48501: PPUSH
48502: CALL_OW 1
48506: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
48507: LD_ADDR_EXP 54
48511: PUSH
48512: LD_EXP 54
48516: PPUSH
48517: LD_VAR 0 1
48521: PPUSH
48522: EMPTY
48523: PPUSH
48524: CALL_OW 1
48528: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
48529: LD_ADDR_EXP 55
48533: PUSH
48534: LD_EXP 55
48538: PPUSH
48539: LD_VAR 0 1
48543: PPUSH
48544: EMPTY
48545: PPUSH
48546: CALL_OW 1
48550: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
48551: LD_ADDR_EXP 56
48555: PUSH
48556: LD_EXP 56
48560: PPUSH
48561: LD_VAR 0 1
48565: PPUSH
48566: EMPTY
48567: PPUSH
48568: CALL_OW 1
48572: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
48573: LD_ADDR_EXP 57
48577: PUSH
48578: LD_EXP 57
48582: PPUSH
48583: LD_VAR 0 1
48587: PPUSH
48588: EMPTY
48589: PPUSH
48590: CALL_OW 1
48594: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
48595: LD_ADDR_EXP 58
48599: PUSH
48600: LD_EXP 58
48604: PPUSH
48605: LD_VAR 0 1
48609: PPUSH
48610: EMPTY
48611: PPUSH
48612: CALL_OW 1
48616: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
48617: LD_ADDR_EXP 59
48621: PUSH
48622: LD_EXP 59
48626: PPUSH
48627: LD_VAR 0 1
48631: PPUSH
48632: EMPTY
48633: PPUSH
48634: CALL_OW 1
48638: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
48639: LD_ADDR_EXP 60
48643: PUSH
48644: LD_EXP 60
48648: PPUSH
48649: LD_VAR 0 1
48653: PPUSH
48654: EMPTY
48655: PPUSH
48656: CALL_OW 1
48660: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
48661: LD_ADDR_EXP 61
48665: PUSH
48666: LD_EXP 61
48670: PPUSH
48671: LD_VAR 0 1
48675: PPUSH
48676: EMPTY
48677: PPUSH
48678: CALL_OW 1
48682: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
48683: LD_ADDR_EXP 62
48687: PUSH
48688: LD_EXP 62
48692: PPUSH
48693: LD_VAR 0 1
48697: PPUSH
48698: EMPTY
48699: PPUSH
48700: CALL_OW 1
48704: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
48705: LD_ADDR_EXP 63
48709: PUSH
48710: LD_EXP 63
48714: PPUSH
48715: LD_VAR 0 1
48719: PPUSH
48720: EMPTY
48721: PPUSH
48722: CALL_OW 1
48726: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
48727: LD_ADDR_EXP 64
48731: PUSH
48732: LD_EXP 64
48736: PPUSH
48737: LD_VAR 0 1
48741: PPUSH
48742: EMPTY
48743: PPUSH
48744: CALL_OW 1
48748: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
48749: LD_ADDR_EXP 65
48753: PUSH
48754: LD_EXP 65
48758: PPUSH
48759: LD_VAR 0 1
48763: PPUSH
48764: LD_INT 0
48766: PPUSH
48767: CALL_OW 1
48771: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
48772: LD_ADDR_EXP 66
48776: PUSH
48777: LD_EXP 66
48781: PPUSH
48782: LD_VAR 0 1
48786: PPUSH
48787: LD_INT 0
48789: PPUSH
48790: CALL_OW 1
48794: ST_TO_ADDR
// end ;
48795: LD_VAR 0 2
48799: RET
// export function MC_Add ( side , units ) ; var base ; begin
48800: LD_INT 0
48802: PPUSH
48803: PPUSH
// base := mc_bases + 1 ;
48804: LD_ADDR_VAR 0 4
48808: PUSH
48809: LD_EXP 23
48813: PUSH
48814: LD_INT 1
48816: PLUS
48817: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
48818: LD_ADDR_EXP 49
48822: PUSH
48823: LD_EXP 49
48827: PPUSH
48828: LD_VAR 0 4
48832: PPUSH
48833: LD_VAR 0 1
48837: PPUSH
48838: CALL_OW 1
48842: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
48843: LD_ADDR_EXP 23
48847: PUSH
48848: LD_EXP 23
48852: PPUSH
48853: LD_VAR 0 4
48857: PPUSH
48858: LD_VAR 0 2
48862: PPUSH
48863: CALL_OW 1
48867: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
48868: LD_ADDR_EXP 24
48872: PUSH
48873: LD_EXP 24
48877: PPUSH
48878: LD_VAR 0 4
48882: PPUSH
48883: EMPTY
48884: PPUSH
48885: CALL_OW 1
48889: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
48890: LD_ADDR_EXP 25
48894: PUSH
48895: LD_EXP 25
48899: PPUSH
48900: LD_VAR 0 4
48904: PPUSH
48905: EMPTY
48906: PPUSH
48907: CALL_OW 1
48911: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
48912: LD_ADDR_EXP 26
48916: PUSH
48917: LD_EXP 26
48921: PPUSH
48922: LD_VAR 0 4
48926: PPUSH
48927: EMPTY
48928: PPUSH
48929: CALL_OW 1
48933: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
48934: LD_ADDR_EXP 27
48938: PUSH
48939: LD_EXP 27
48943: PPUSH
48944: LD_VAR 0 4
48948: PPUSH
48949: EMPTY
48950: PPUSH
48951: CALL_OW 1
48955: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
48956: LD_ADDR_EXP 28
48960: PUSH
48961: LD_EXP 28
48965: PPUSH
48966: LD_VAR 0 4
48970: PPUSH
48971: EMPTY
48972: PPUSH
48973: CALL_OW 1
48977: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
48978: LD_ADDR_EXP 29
48982: PUSH
48983: LD_EXP 29
48987: PPUSH
48988: LD_VAR 0 4
48992: PPUSH
48993: EMPTY
48994: PPUSH
48995: CALL_OW 1
48999: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
49000: LD_ADDR_EXP 30
49004: PUSH
49005: LD_EXP 30
49009: PPUSH
49010: LD_VAR 0 4
49014: PPUSH
49015: EMPTY
49016: PPUSH
49017: CALL_OW 1
49021: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
49022: LD_ADDR_EXP 31
49026: PUSH
49027: LD_EXP 31
49031: PPUSH
49032: LD_VAR 0 4
49036: PPUSH
49037: EMPTY
49038: PPUSH
49039: CALL_OW 1
49043: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
49044: LD_ADDR_EXP 32
49048: PUSH
49049: LD_EXP 32
49053: PPUSH
49054: LD_VAR 0 4
49058: PPUSH
49059: EMPTY
49060: PPUSH
49061: CALL_OW 1
49065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
49066: LD_ADDR_EXP 33
49070: PUSH
49071: LD_EXP 33
49075: PPUSH
49076: LD_VAR 0 4
49080: PPUSH
49081: EMPTY
49082: PPUSH
49083: CALL_OW 1
49087: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
49088: LD_ADDR_EXP 34
49092: PUSH
49093: LD_EXP 34
49097: PPUSH
49098: LD_VAR 0 4
49102: PPUSH
49103: LD_INT 0
49105: PPUSH
49106: CALL_OW 1
49110: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
49111: LD_ADDR_EXP 35
49115: PUSH
49116: LD_EXP 35
49120: PPUSH
49121: LD_VAR 0 4
49125: PPUSH
49126: EMPTY
49127: PPUSH
49128: CALL_OW 1
49132: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
49133: LD_ADDR_EXP 36
49137: PUSH
49138: LD_EXP 36
49142: PPUSH
49143: LD_VAR 0 4
49147: PPUSH
49148: EMPTY
49149: PPUSH
49150: CALL_OW 1
49154: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
49155: LD_ADDR_EXP 37
49159: PUSH
49160: LD_EXP 37
49164: PPUSH
49165: LD_VAR 0 4
49169: PPUSH
49170: EMPTY
49171: PPUSH
49172: CALL_OW 1
49176: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
49177: LD_ADDR_EXP 38
49181: PUSH
49182: LD_EXP 38
49186: PPUSH
49187: LD_VAR 0 4
49191: PPUSH
49192: EMPTY
49193: PPUSH
49194: CALL_OW 1
49198: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
49199: LD_ADDR_EXP 39
49203: PUSH
49204: LD_EXP 39
49208: PPUSH
49209: LD_VAR 0 4
49213: PPUSH
49214: EMPTY
49215: PPUSH
49216: CALL_OW 1
49220: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
49221: LD_ADDR_EXP 40
49225: PUSH
49226: LD_EXP 40
49230: PPUSH
49231: LD_VAR 0 4
49235: PPUSH
49236: EMPTY
49237: PPUSH
49238: CALL_OW 1
49242: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
49243: LD_ADDR_EXP 41
49247: PUSH
49248: LD_EXP 41
49252: PPUSH
49253: LD_VAR 0 4
49257: PPUSH
49258: EMPTY
49259: PPUSH
49260: CALL_OW 1
49264: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
49265: LD_ADDR_EXP 42
49269: PUSH
49270: LD_EXP 42
49274: PPUSH
49275: LD_VAR 0 4
49279: PPUSH
49280: EMPTY
49281: PPUSH
49282: CALL_OW 1
49286: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
49287: LD_ADDR_EXP 43
49291: PUSH
49292: LD_EXP 43
49296: PPUSH
49297: LD_VAR 0 4
49301: PPUSH
49302: EMPTY
49303: PPUSH
49304: CALL_OW 1
49308: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
49309: LD_ADDR_EXP 44
49313: PUSH
49314: LD_EXP 44
49318: PPUSH
49319: LD_VAR 0 4
49323: PPUSH
49324: EMPTY
49325: PPUSH
49326: CALL_OW 1
49330: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
49331: LD_ADDR_EXP 45
49335: PUSH
49336: LD_EXP 45
49340: PPUSH
49341: LD_VAR 0 4
49345: PPUSH
49346: EMPTY
49347: PPUSH
49348: CALL_OW 1
49352: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
49353: LD_ADDR_EXP 46
49357: PUSH
49358: LD_EXP 46
49362: PPUSH
49363: LD_VAR 0 4
49367: PPUSH
49368: EMPTY
49369: PPUSH
49370: CALL_OW 1
49374: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
49375: LD_ADDR_EXP 47
49379: PUSH
49380: LD_EXP 47
49384: PPUSH
49385: LD_VAR 0 4
49389: PPUSH
49390: EMPTY
49391: PPUSH
49392: CALL_OW 1
49396: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
49397: LD_ADDR_EXP 48
49401: PUSH
49402: LD_EXP 48
49406: PPUSH
49407: LD_VAR 0 4
49411: PPUSH
49412: EMPTY
49413: PPUSH
49414: CALL_OW 1
49418: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
49419: LD_ADDR_EXP 50
49423: PUSH
49424: LD_EXP 50
49428: PPUSH
49429: LD_VAR 0 4
49433: PPUSH
49434: EMPTY
49435: PPUSH
49436: CALL_OW 1
49440: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
49441: LD_ADDR_EXP 52
49445: PUSH
49446: LD_EXP 52
49450: PPUSH
49451: LD_VAR 0 4
49455: PPUSH
49456: EMPTY
49457: PPUSH
49458: CALL_OW 1
49462: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
49463: LD_ADDR_EXP 53
49467: PUSH
49468: LD_EXP 53
49472: PPUSH
49473: LD_VAR 0 4
49477: PPUSH
49478: EMPTY
49479: PPUSH
49480: CALL_OW 1
49484: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
49485: LD_ADDR_EXP 54
49489: PUSH
49490: LD_EXP 54
49494: PPUSH
49495: LD_VAR 0 4
49499: PPUSH
49500: EMPTY
49501: PPUSH
49502: CALL_OW 1
49506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
49507: LD_ADDR_EXP 55
49511: PUSH
49512: LD_EXP 55
49516: PPUSH
49517: LD_VAR 0 4
49521: PPUSH
49522: EMPTY
49523: PPUSH
49524: CALL_OW 1
49528: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
49529: LD_ADDR_EXP 56
49533: PUSH
49534: LD_EXP 56
49538: PPUSH
49539: LD_VAR 0 4
49543: PPUSH
49544: EMPTY
49545: PPUSH
49546: CALL_OW 1
49550: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
49551: LD_ADDR_EXP 57
49555: PUSH
49556: LD_EXP 57
49560: PPUSH
49561: LD_VAR 0 4
49565: PPUSH
49566: EMPTY
49567: PPUSH
49568: CALL_OW 1
49572: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
49573: LD_ADDR_EXP 58
49577: PUSH
49578: LD_EXP 58
49582: PPUSH
49583: LD_VAR 0 4
49587: PPUSH
49588: EMPTY
49589: PPUSH
49590: CALL_OW 1
49594: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
49595: LD_ADDR_EXP 59
49599: PUSH
49600: LD_EXP 59
49604: PPUSH
49605: LD_VAR 0 4
49609: PPUSH
49610: EMPTY
49611: PPUSH
49612: CALL_OW 1
49616: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
49617: LD_ADDR_EXP 60
49621: PUSH
49622: LD_EXP 60
49626: PPUSH
49627: LD_VAR 0 4
49631: PPUSH
49632: EMPTY
49633: PPUSH
49634: CALL_OW 1
49638: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
49639: LD_ADDR_EXP 61
49643: PUSH
49644: LD_EXP 61
49648: PPUSH
49649: LD_VAR 0 4
49653: PPUSH
49654: EMPTY
49655: PPUSH
49656: CALL_OW 1
49660: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
49661: LD_ADDR_EXP 62
49665: PUSH
49666: LD_EXP 62
49670: PPUSH
49671: LD_VAR 0 4
49675: PPUSH
49676: EMPTY
49677: PPUSH
49678: CALL_OW 1
49682: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
49683: LD_ADDR_EXP 63
49687: PUSH
49688: LD_EXP 63
49692: PPUSH
49693: LD_VAR 0 4
49697: PPUSH
49698: EMPTY
49699: PPUSH
49700: CALL_OW 1
49704: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
49705: LD_ADDR_EXP 64
49709: PUSH
49710: LD_EXP 64
49714: PPUSH
49715: LD_VAR 0 4
49719: PPUSH
49720: EMPTY
49721: PPUSH
49722: CALL_OW 1
49726: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
49727: LD_ADDR_EXP 65
49731: PUSH
49732: LD_EXP 65
49736: PPUSH
49737: LD_VAR 0 4
49741: PPUSH
49742: LD_INT 0
49744: PPUSH
49745: CALL_OW 1
49749: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
49750: LD_ADDR_EXP 66
49754: PUSH
49755: LD_EXP 66
49759: PPUSH
49760: LD_VAR 0 4
49764: PPUSH
49765: LD_INT 0
49767: PPUSH
49768: CALL_OW 1
49772: ST_TO_ADDR
// result := base ;
49773: LD_ADDR_VAR 0 3
49777: PUSH
49778: LD_VAR 0 4
49782: ST_TO_ADDR
// end ;
49783: LD_VAR 0 3
49787: RET
// export function MC_Start ( ) ; var i ; begin
49788: LD_INT 0
49790: PPUSH
49791: PPUSH
// for i = 1 to mc_bases do
49792: LD_ADDR_VAR 0 2
49796: PUSH
49797: DOUBLE
49798: LD_INT 1
49800: DEC
49801: ST_TO_ADDR
49802: LD_EXP 23
49806: PUSH
49807: FOR_TO
49808: IFFALSE 50908
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
49810: LD_ADDR_EXP 23
49814: PUSH
49815: LD_EXP 23
49819: PPUSH
49820: LD_VAR 0 2
49824: PPUSH
49825: LD_EXP 23
49829: PUSH
49830: LD_VAR 0 2
49834: ARRAY
49835: PUSH
49836: LD_INT 0
49838: DIFF
49839: PPUSH
49840: CALL_OW 1
49844: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
49845: LD_ADDR_EXP 24
49849: PUSH
49850: LD_EXP 24
49854: PPUSH
49855: LD_VAR 0 2
49859: PPUSH
49860: EMPTY
49861: PPUSH
49862: CALL_OW 1
49866: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49867: LD_ADDR_EXP 25
49871: PUSH
49872: LD_EXP 25
49876: PPUSH
49877: LD_VAR 0 2
49881: PPUSH
49882: EMPTY
49883: PPUSH
49884: CALL_OW 1
49888: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
49889: LD_ADDR_EXP 26
49893: PUSH
49894: LD_EXP 26
49898: PPUSH
49899: LD_VAR 0 2
49903: PPUSH
49904: EMPTY
49905: PPUSH
49906: CALL_OW 1
49910: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
49911: LD_ADDR_EXP 27
49915: PUSH
49916: LD_EXP 27
49920: PPUSH
49921: LD_VAR 0 2
49925: PPUSH
49926: EMPTY
49927: PUSH
49928: EMPTY
49929: PUSH
49930: EMPTY
49931: LIST
49932: LIST
49933: PPUSH
49934: CALL_OW 1
49938: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
49939: LD_ADDR_EXP 28
49943: PUSH
49944: LD_EXP 28
49948: PPUSH
49949: LD_VAR 0 2
49953: PPUSH
49954: EMPTY
49955: PPUSH
49956: CALL_OW 1
49960: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
49961: LD_ADDR_EXP 55
49965: PUSH
49966: LD_EXP 55
49970: PPUSH
49971: LD_VAR 0 2
49975: PPUSH
49976: EMPTY
49977: PPUSH
49978: CALL_OW 1
49982: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
49983: LD_ADDR_EXP 29
49987: PUSH
49988: LD_EXP 29
49992: PPUSH
49993: LD_VAR 0 2
49997: PPUSH
49998: EMPTY
49999: PPUSH
50000: CALL_OW 1
50004: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
50005: LD_ADDR_EXP 30
50009: PUSH
50010: LD_EXP 30
50014: PPUSH
50015: LD_VAR 0 2
50019: PPUSH
50020: EMPTY
50021: PPUSH
50022: CALL_OW 1
50026: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
50027: LD_ADDR_EXP 31
50031: PUSH
50032: LD_EXP 31
50036: PPUSH
50037: LD_VAR 0 2
50041: PPUSH
50042: LD_EXP 23
50046: PUSH
50047: LD_VAR 0 2
50051: ARRAY
50052: PPUSH
50053: LD_INT 2
50055: PUSH
50056: LD_INT 30
50058: PUSH
50059: LD_INT 32
50061: PUSH
50062: EMPTY
50063: LIST
50064: LIST
50065: PUSH
50066: LD_INT 30
50068: PUSH
50069: LD_INT 33
50071: PUSH
50072: EMPTY
50073: LIST
50074: LIST
50075: PUSH
50076: EMPTY
50077: LIST
50078: LIST
50079: LIST
50080: PPUSH
50081: CALL_OW 72
50085: PPUSH
50086: CALL_OW 1
50090: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
50091: LD_ADDR_EXP 32
50095: PUSH
50096: LD_EXP 32
50100: PPUSH
50101: LD_VAR 0 2
50105: PPUSH
50106: LD_EXP 23
50110: PUSH
50111: LD_VAR 0 2
50115: ARRAY
50116: PPUSH
50117: LD_INT 2
50119: PUSH
50120: LD_INT 30
50122: PUSH
50123: LD_INT 32
50125: PUSH
50126: EMPTY
50127: LIST
50128: LIST
50129: PUSH
50130: LD_INT 30
50132: PUSH
50133: LD_INT 31
50135: PUSH
50136: EMPTY
50137: LIST
50138: LIST
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: LIST
50144: PUSH
50145: LD_INT 58
50147: PUSH
50148: EMPTY
50149: LIST
50150: PUSH
50151: EMPTY
50152: LIST
50153: LIST
50154: PPUSH
50155: CALL_OW 72
50159: PPUSH
50160: CALL_OW 1
50164: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
50165: LD_ADDR_EXP 33
50169: PUSH
50170: LD_EXP 33
50174: PPUSH
50175: LD_VAR 0 2
50179: PPUSH
50180: EMPTY
50181: PPUSH
50182: CALL_OW 1
50186: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
50187: LD_ADDR_EXP 37
50191: PUSH
50192: LD_EXP 37
50196: PPUSH
50197: LD_VAR 0 2
50201: PPUSH
50202: EMPTY
50203: PPUSH
50204: CALL_OW 1
50208: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
50209: LD_ADDR_EXP 36
50213: PUSH
50214: LD_EXP 36
50218: PPUSH
50219: LD_VAR 0 2
50223: PPUSH
50224: EMPTY
50225: PPUSH
50226: CALL_OW 1
50230: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
50231: LD_ADDR_EXP 38
50235: PUSH
50236: LD_EXP 38
50240: PPUSH
50241: LD_VAR 0 2
50245: PPUSH
50246: EMPTY
50247: PPUSH
50248: CALL_OW 1
50252: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
50253: LD_ADDR_EXP 39
50257: PUSH
50258: LD_EXP 39
50262: PPUSH
50263: LD_VAR 0 2
50267: PPUSH
50268: EMPTY
50269: PPUSH
50270: CALL_OW 1
50274: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
50275: LD_ADDR_EXP 40
50279: PUSH
50280: LD_EXP 40
50284: PPUSH
50285: LD_VAR 0 2
50289: PPUSH
50290: EMPTY
50291: PPUSH
50292: CALL_OW 1
50296: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
50297: LD_ADDR_EXP 41
50301: PUSH
50302: LD_EXP 41
50306: PPUSH
50307: LD_VAR 0 2
50311: PPUSH
50312: EMPTY
50313: PPUSH
50314: CALL_OW 1
50318: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
50319: LD_ADDR_EXP 42
50323: PUSH
50324: LD_EXP 42
50328: PPUSH
50329: LD_VAR 0 2
50333: PPUSH
50334: EMPTY
50335: PPUSH
50336: CALL_OW 1
50340: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50341: LD_ADDR_EXP 43
50345: PUSH
50346: LD_EXP 43
50350: PPUSH
50351: LD_VAR 0 2
50355: PPUSH
50356: EMPTY
50357: PPUSH
50358: CALL_OW 1
50362: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
50363: LD_ADDR_EXP 44
50367: PUSH
50368: LD_EXP 44
50372: PPUSH
50373: LD_VAR 0 2
50377: PPUSH
50378: EMPTY
50379: PPUSH
50380: CALL_OW 1
50384: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
50385: LD_ADDR_EXP 45
50389: PUSH
50390: LD_EXP 45
50394: PPUSH
50395: LD_VAR 0 2
50399: PPUSH
50400: EMPTY
50401: PPUSH
50402: CALL_OW 1
50406: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
50407: LD_ADDR_EXP 34
50411: PUSH
50412: LD_EXP 34
50416: PPUSH
50417: LD_VAR 0 2
50421: PPUSH
50422: LD_INT 0
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
50430: LD_ADDR_EXP 47
50434: PUSH
50435: LD_EXP 47
50439: PPUSH
50440: LD_VAR 0 2
50444: PPUSH
50445: LD_INT 0
50447: PPUSH
50448: CALL_OW 1
50452: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
50453: LD_ADDR_EXP 35
50457: PUSH
50458: LD_EXP 35
50462: PPUSH
50463: LD_VAR 0 2
50467: PPUSH
50468: EMPTY
50469: PPUSH
50470: CALL_OW 1
50474: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
50475: LD_ADDR_EXP 46
50479: PUSH
50480: LD_EXP 46
50484: PPUSH
50485: LD_VAR 0 2
50489: PPUSH
50490: LD_INT 0
50492: PPUSH
50493: CALL_OW 1
50497: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
50498: LD_ADDR_EXP 48
50502: PUSH
50503: LD_EXP 48
50507: PPUSH
50508: LD_VAR 0 2
50512: PPUSH
50513: EMPTY
50514: PPUSH
50515: CALL_OW 1
50519: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
50520: LD_ADDR_EXP 51
50524: PUSH
50525: LD_EXP 51
50529: PPUSH
50530: LD_VAR 0 2
50534: PPUSH
50535: LD_INT 0
50537: PPUSH
50538: CALL_OW 1
50542: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
50543: LD_ADDR_EXP 52
50547: PUSH
50548: LD_EXP 52
50552: PPUSH
50553: LD_VAR 0 2
50557: PPUSH
50558: EMPTY
50559: PPUSH
50560: CALL_OW 1
50564: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
50565: LD_ADDR_EXP 53
50569: PUSH
50570: LD_EXP 53
50574: PPUSH
50575: LD_VAR 0 2
50579: PPUSH
50580: EMPTY
50581: PPUSH
50582: CALL_OW 1
50586: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50587: LD_ADDR_EXP 54
50591: PUSH
50592: LD_EXP 54
50596: PPUSH
50597: LD_VAR 0 2
50601: PPUSH
50602: EMPTY
50603: PPUSH
50604: CALL_OW 1
50608: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
50609: LD_ADDR_EXP 56
50613: PUSH
50614: LD_EXP 56
50618: PPUSH
50619: LD_VAR 0 2
50623: PPUSH
50624: LD_EXP 23
50628: PUSH
50629: LD_VAR 0 2
50633: ARRAY
50634: PPUSH
50635: LD_INT 2
50637: PUSH
50638: LD_INT 30
50640: PUSH
50641: LD_INT 6
50643: PUSH
50644: EMPTY
50645: LIST
50646: LIST
50647: PUSH
50648: LD_INT 30
50650: PUSH
50651: LD_INT 7
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 30
50660: PUSH
50661: LD_INT 8
50663: PUSH
50664: EMPTY
50665: LIST
50666: LIST
50667: PUSH
50668: EMPTY
50669: LIST
50670: LIST
50671: LIST
50672: LIST
50673: PPUSH
50674: CALL_OW 72
50678: PPUSH
50679: CALL_OW 1
50683: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
50684: LD_ADDR_EXP 57
50688: PUSH
50689: LD_EXP 57
50693: PPUSH
50694: LD_VAR 0 2
50698: PPUSH
50699: EMPTY
50700: PPUSH
50701: CALL_OW 1
50705: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
50706: LD_ADDR_EXP 58
50710: PUSH
50711: LD_EXP 58
50715: PPUSH
50716: LD_VAR 0 2
50720: PPUSH
50721: EMPTY
50722: PPUSH
50723: CALL_OW 1
50727: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
50728: LD_ADDR_EXP 59
50732: PUSH
50733: LD_EXP 59
50737: PPUSH
50738: LD_VAR 0 2
50742: PPUSH
50743: EMPTY
50744: PPUSH
50745: CALL_OW 1
50749: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
50750: LD_ADDR_EXP 60
50754: PUSH
50755: LD_EXP 60
50759: PPUSH
50760: LD_VAR 0 2
50764: PPUSH
50765: EMPTY
50766: PPUSH
50767: CALL_OW 1
50771: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50772: LD_ADDR_EXP 61
50776: PUSH
50777: LD_EXP 61
50781: PPUSH
50782: LD_VAR 0 2
50786: PPUSH
50787: EMPTY
50788: PPUSH
50789: CALL_OW 1
50793: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
50794: LD_ADDR_EXP 62
50798: PUSH
50799: LD_EXP 62
50803: PPUSH
50804: LD_VAR 0 2
50808: PPUSH
50809: EMPTY
50810: PPUSH
50811: CALL_OW 1
50815: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
50816: LD_ADDR_EXP 63
50820: PUSH
50821: LD_EXP 63
50825: PPUSH
50826: LD_VAR 0 2
50830: PPUSH
50831: EMPTY
50832: PPUSH
50833: CALL_OW 1
50837: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
50838: LD_ADDR_EXP 64
50842: PUSH
50843: LD_EXP 64
50847: PPUSH
50848: LD_VAR 0 2
50852: PPUSH
50853: EMPTY
50854: PPUSH
50855: CALL_OW 1
50859: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
50860: LD_ADDR_EXP 65
50864: PUSH
50865: LD_EXP 65
50869: PPUSH
50870: LD_VAR 0 2
50874: PPUSH
50875: LD_INT 0
50877: PPUSH
50878: CALL_OW 1
50882: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
50883: LD_ADDR_EXP 66
50887: PUSH
50888: LD_EXP 66
50892: PPUSH
50893: LD_VAR 0 2
50897: PPUSH
50898: LD_INT 0
50900: PPUSH
50901: CALL_OW 1
50905: ST_TO_ADDR
// end ;
50906: GO 49807
50908: POP
50909: POP
// MC_InitSides ( ) ;
50910: CALL 51196 0 0
// MC_InitResearch ( ) ;
50914: CALL 50935 0 0
// CustomInitMacro ( ) ;
50918: CALL 277 0 0
// skirmish := true ;
50922: LD_ADDR_EXP 21
50926: PUSH
50927: LD_INT 1
50929: ST_TO_ADDR
// end ;
50930: LD_VAR 0 1
50934: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
50935: LD_INT 0
50937: PPUSH
50938: PPUSH
50939: PPUSH
50940: PPUSH
50941: PPUSH
50942: PPUSH
// if not mc_bases then
50943: LD_EXP 23
50947: NOT
50948: IFFALSE 50952
// exit ;
50950: GO 51191
// for i = 1 to 8 do
50952: LD_ADDR_VAR 0 2
50956: PUSH
50957: DOUBLE
50958: LD_INT 1
50960: DEC
50961: ST_TO_ADDR
50962: LD_INT 8
50964: PUSH
50965: FOR_TO
50966: IFFALSE 50992
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
50968: LD_ADDR_EXP 50
50972: PUSH
50973: LD_EXP 50
50977: PPUSH
50978: LD_VAR 0 2
50982: PPUSH
50983: EMPTY
50984: PPUSH
50985: CALL_OW 1
50989: ST_TO_ADDR
50990: GO 50965
50992: POP
50993: POP
// tmp := [ ] ;
50994: LD_ADDR_VAR 0 5
50998: PUSH
50999: EMPTY
51000: ST_TO_ADDR
// for i = 1 to mc_sides do
51001: LD_ADDR_VAR 0 2
51005: PUSH
51006: DOUBLE
51007: LD_INT 1
51009: DEC
51010: ST_TO_ADDR
51011: LD_EXP 49
51015: PUSH
51016: FOR_TO
51017: IFFALSE 51075
// if not mc_sides [ i ] in tmp then
51019: LD_EXP 49
51023: PUSH
51024: LD_VAR 0 2
51028: ARRAY
51029: PUSH
51030: LD_VAR 0 5
51034: IN
51035: NOT
51036: IFFALSE 51073
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
51038: LD_ADDR_VAR 0 5
51042: PUSH
51043: LD_VAR 0 5
51047: PPUSH
51048: LD_VAR 0 5
51052: PUSH
51053: LD_INT 1
51055: PLUS
51056: PPUSH
51057: LD_EXP 49
51061: PUSH
51062: LD_VAR 0 2
51066: ARRAY
51067: PPUSH
51068: CALL_OW 2
51072: ST_TO_ADDR
51073: GO 51016
51075: POP
51076: POP
// if not tmp then
51077: LD_VAR 0 5
51081: NOT
51082: IFFALSE 51086
// exit ;
51084: GO 51191
// for j in tmp do
51086: LD_ADDR_VAR 0 3
51090: PUSH
51091: LD_VAR 0 5
51095: PUSH
51096: FOR_IN
51097: IFFALSE 51189
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
51099: LD_ADDR_VAR 0 6
51103: PUSH
51104: LD_INT 22
51106: PUSH
51107: LD_VAR 0 3
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PPUSH
51116: CALL_OW 69
51120: ST_TO_ADDR
// if not un then
51121: LD_VAR 0 6
51125: NOT
51126: IFFALSE 51130
// continue ;
51128: GO 51096
// nation := GetNation ( un [ 1 ] ) ;
51130: LD_ADDR_VAR 0 4
51134: PUSH
51135: LD_VAR 0 6
51139: PUSH
51140: LD_INT 1
51142: ARRAY
51143: PPUSH
51144: CALL_OW 248
51148: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
51149: LD_ADDR_EXP 50
51153: PUSH
51154: LD_EXP 50
51158: PPUSH
51159: LD_VAR 0 3
51163: PPUSH
51164: LD_VAR 0 3
51168: PPUSH
51169: LD_VAR 0 4
51173: PPUSH
51174: LD_INT 1
51176: PPUSH
51177: CALL 9137 0 3
51181: PPUSH
51182: CALL_OW 1
51186: ST_TO_ADDR
// end ;
51187: GO 51096
51189: POP
51190: POP
// end ;
51191: LD_VAR 0 1
51195: RET
// export function MC_InitSides ( ) ; var i ; begin
51196: LD_INT 0
51198: PPUSH
51199: PPUSH
// if not mc_bases then
51200: LD_EXP 23
51204: NOT
51205: IFFALSE 51209
// exit ;
51207: GO 51283
// for i = 1 to mc_bases do
51209: LD_ADDR_VAR 0 2
51213: PUSH
51214: DOUBLE
51215: LD_INT 1
51217: DEC
51218: ST_TO_ADDR
51219: LD_EXP 23
51223: PUSH
51224: FOR_TO
51225: IFFALSE 51281
// if mc_bases [ i ] then
51227: LD_EXP 23
51231: PUSH
51232: LD_VAR 0 2
51236: ARRAY
51237: IFFALSE 51279
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
51239: LD_ADDR_EXP 49
51243: PUSH
51244: LD_EXP 49
51248: PPUSH
51249: LD_VAR 0 2
51253: PPUSH
51254: LD_EXP 23
51258: PUSH
51259: LD_VAR 0 2
51263: ARRAY
51264: PUSH
51265: LD_INT 1
51267: ARRAY
51268: PPUSH
51269: CALL_OW 255
51273: PPUSH
51274: CALL_OW 1
51278: ST_TO_ADDR
51279: GO 51224
51281: POP
51282: POP
// end ;
51283: LD_VAR 0 1
51287: RET
// every 0 0$03 trigger skirmish do
51288: LD_EXP 21
51292: IFFALSE 51446
51294: GO 51296
51296: DISABLE
// begin enable ;
51297: ENABLE
// MC_CheckBuildings ( ) ;
51298: CALL 55944 0 0
// MC_CheckPeopleLife ( ) ;
51302: CALL 56069 0 0
// RaiseSailEvent ( 100 ) ;
51306: LD_INT 100
51308: PPUSH
51309: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
51313: LD_INT 103
51315: PPUSH
51316: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
51320: LD_INT 104
51322: PPUSH
51323: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
51327: LD_INT 105
51329: PPUSH
51330: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
51334: LD_INT 106
51336: PPUSH
51337: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
51341: LD_INT 107
51343: PPUSH
51344: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
51348: LD_INT 108
51350: PPUSH
51351: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
51355: LD_INT 109
51357: PPUSH
51358: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
51362: LD_INT 110
51364: PPUSH
51365: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
51369: LD_INT 111
51371: PPUSH
51372: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
51376: LD_INT 112
51378: PPUSH
51379: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
51383: LD_INT 113
51385: PPUSH
51386: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
51390: LD_INT 120
51392: PPUSH
51393: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
51397: LD_INT 121
51399: PPUSH
51400: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
51404: LD_INT 122
51406: PPUSH
51407: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
51411: LD_INT 123
51413: PPUSH
51414: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
51418: LD_INT 124
51420: PPUSH
51421: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
51425: LD_INT 125
51427: PPUSH
51428: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
51432: LD_INT 126
51434: PPUSH
51435: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
51439: LD_INT 200
51441: PPUSH
51442: CALL_OW 427
// end ;
51446: END
// on SailEvent ( event ) do begin if event < 100 then
51447: LD_VAR 0 1
51451: PUSH
51452: LD_INT 100
51454: LESS
51455: IFFALSE 51466
// CustomEvent ( event ) ;
51457: LD_VAR 0 1
51461: PPUSH
51462: CALL 8331 0 1
// if event = 100 then
51466: LD_VAR 0 1
51470: PUSH
51471: LD_INT 100
51473: EQUAL
51474: IFFALSE 51480
// MC_ClassManager ( ) ;
51476: CALL 51872 0 0
// if event = 101 then
51480: LD_VAR 0 1
51484: PUSH
51485: LD_INT 101
51487: EQUAL
51488: IFFALSE 51494
// MC_RepairBuildings ( ) ;
51490: CALL 56654 0 0
// if event = 102 then
51494: LD_VAR 0 1
51498: PUSH
51499: LD_INT 102
51501: EQUAL
51502: IFFALSE 51508
// MC_Heal ( ) ;
51504: CALL 57539 0 0
// if event = 103 then
51508: LD_VAR 0 1
51512: PUSH
51513: LD_INT 103
51515: EQUAL
51516: IFFALSE 51522
// MC_Build ( ) ;
51518: CALL 57961 0 0
// if event = 104 then
51522: LD_VAR 0 1
51526: PUSH
51527: LD_INT 104
51529: EQUAL
51530: IFFALSE 51536
// MC_TurretWeapon ( ) ;
51532: CALL 59602 0 0
// if event = 105 then
51536: LD_VAR 0 1
51540: PUSH
51541: LD_INT 105
51543: EQUAL
51544: IFFALSE 51550
// MC_BuildUpgrade ( ) ;
51546: CALL 59153 0 0
// if event = 106 then
51550: LD_VAR 0 1
51554: PUSH
51555: LD_INT 106
51557: EQUAL
51558: IFFALSE 51564
// MC_PlantMines ( ) ;
51560: CALL 60032 0 0
// if event = 107 then
51564: LD_VAR 0 1
51568: PUSH
51569: LD_INT 107
51571: EQUAL
51572: IFFALSE 51578
// MC_CollectCrates ( ) ;
51574: CALL 60823 0 0
// if event = 108 then
51578: LD_VAR 0 1
51582: PUSH
51583: LD_INT 108
51585: EQUAL
51586: IFFALSE 51592
// MC_LinkRemoteControl ( ) ;
51588: CALL 62673 0 0
// if event = 109 then
51592: LD_VAR 0 1
51596: PUSH
51597: LD_INT 109
51599: EQUAL
51600: IFFALSE 51606
// MC_ProduceVehicle ( ) ;
51602: CALL 62854 0 0
// if event = 110 then
51606: LD_VAR 0 1
51610: PUSH
51611: LD_INT 110
51613: EQUAL
51614: IFFALSE 51620
// MC_SendAttack ( ) ;
51616: CALL 63320 0 0
// if event = 111 then
51620: LD_VAR 0 1
51624: PUSH
51625: LD_INT 111
51627: EQUAL
51628: IFFALSE 51634
// MC_Defend ( ) ;
51630: CALL 63428 0 0
// if event = 112 then
51634: LD_VAR 0 1
51638: PUSH
51639: LD_INT 112
51641: EQUAL
51642: IFFALSE 51648
// MC_Research ( ) ;
51644: CALL 64150 0 0
// if event = 113 then
51648: LD_VAR 0 1
51652: PUSH
51653: LD_INT 113
51655: EQUAL
51656: IFFALSE 51662
// MC_MinesTrigger ( ) ;
51658: CALL 65264 0 0
// if event = 120 then
51662: LD_VAR 0 1
51666: PUSH
51667: LD_INT 120
51669: EQUAL
51670: IFFALSE 51676
// MC_RepairVehicle ( ) ;
51672: CALL 65363 0 0
// if event = 121 then
51676: LD_VAR 0 1
51680: PUSH
51681: LD_INT 121
51683: EQUAL
51684: IFFALSE 51690
// MC_TameApe ( ) ;
51686: CALL 66104 0 0
// if event = 122 then
51690: LD_VAR 0 1
51694: PUSH
51695: LD_INT 122
51697: EQUAL
51698: IFFALSE 51704
// MC_ChangeApeClass ( ) ;
51700: CALL 66933 0 0
// if event = 123 then
51704: LD_VAR 0 1
51708: PUSH
51709: LD_INT 123
51711: EQUAL
51712: IFFALSE 51718
// MC_Bazooka ( ) ;
51714: CALL 67583 0 0
// if event = 124 then
51718: LD_VAR 0 1
51722: PUSH
51723: LD_INT 124
51725: EQUAL
51726: IFFALSE 51732
// MC_TeleportExit ( ) ;
51728: CALL 67781 0 0
// if event = 125 then
51732: LD_VAR 0 1
51736: PUSH
51737: LD_INT 125
51739: EQUAL
51740: IFFALSE 51746
// MC_Deposits ( ) ;
51742: CALL 68428 0 0
// if event = 126 then
51746: LD_VAR 0 1
51750: PUSH
51751: LD_INT 126
51753: EQUAL
51754: IFFALSE 51760
// MC_RemoteDriver ( ) ;
51756: CALL 69053 0 0
// if event = 200 then
51760: LD_VAR 0 1
51764: PUSH
51765: LD_INT 200
51767: EQUAL
51768: IFFALSE 51774
// MC_Idle ( ) ;
51770: CALL 71002 0 0
// end ;
51774: PPOPN 1
51776: END
// export function MC_Reset ( base , tag ) ; var i ; begin
51777: LD_INT 0
51779: PPUSH
51780: PPUSH
// if not mc_bases [ base ] or not tag then
51781: LD_EXP 23
51785: PUSH
51786: LD_VAR 0 1
51790: ARRAY
51791: NOT
51792: PUSH
51793: LD_VAR 0 2
51797: NOT
51798: OR
51799: IFFALSE 51803
// exit ;
51801: GO 51867
// for i in mc_bases [ base ] union mc_ape [ base ] do
51803: LD_ADDR_VAR 0 4
51807: PUSH
51808: LD_EXP 23
51812: PUSH
51813: LD_VAR 0 1
51817: ARRAY
51818: PUSH
51819: LD_EXP 52
51823: PUSH
51824: LD_VAR 0 1
51828: ARRAY
51829: UNION
51830: PUSH
51831: FOR_IN
51832: IFFALSE 51865
// if GetTag ( i ) = tag then
51834: LD_VAR 0 4
51838: PPUSH
51839: CALL_OW 110
51843: PUSH
51844: LD_VAR 0 2
51848: EQUAL
51849: IFFALSE 51863
// SetTag ( i , 0 ) ;
51851: LD_VAR 0 4
51855: PPUSH
51856: LD_INT 0
51858: PPUSH
51859: CALL_OW 109
51863: GO 51831
51865: POP
51866: POP
// end ;
51867: LD_VAR 0 3
51871: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
51872: LD_INT 0
51874: PPUSH
51875: PPUSH
51876: PPUSH
51877: PPUSH
51878: PPUSH
51879: PPUSH
51880: PPUSH
51881: PPUSH
// if not mc_bases then
51882: LD_EXP 23
51886: NOT
51887: IFFALSE 51891
// exit ;
51889: GO 52349
// for i = 1 to mc_bases do
51891: LD_ADDR_VAR 0 2
51895: PUSH
51896: DOUBLE
51897: LD_INT 1
51899: DEC
51900: ST_TO_ADDR
51901: LD_EXP 23
51905: PUSH
51906: FOR_TO
51907: IFFALSE 52347
// begin tmp := MC_ClassCheckReq ( i ) ;
51909: LD_ADDR_VAR 0 4
51913: PUSH
51914: LD_VAR 0 2
51918: PPUSH
51919: CALL 52354 0 1
51923: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
51924: LD_ADDR_EXP 64
51928: PUSH
51929: LD_EXP 64
51933: PPUSH
51934: LD_VAR 0 2
51938: PPUSH
51939: LD_VAR 0 4
51943: PPUSH
51944: CALL_OW 1
51948: ST_TO_ADDR
// if not tmp then
51949: LD_VAR 0 4
51953: NOT
51954: IFFALSE 51958
// continue ;
51956: GO 51906
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
51958: LD_ADDR_VAR 0 6
51962: PUSH
51963: LD_EXP 23
51967: PUSH
51968: LD_VAR 0 2
51972: ARRAY
51973: PPUSH
51974: LD_INT 2
51976: PUSH
51977: LD_INT 30
51979: PUSH
51980: LD_INT 4
51982: PUSH
51983: EMPTY
51984: LIST
51985: LIST
51986: PUSH
51987: LD_INT 30
51989: PUSH
51990: LD_INT 5
51992: PUSH
51993: EMPTY
51994: LIST
51995: LIST
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: LIST
52001: PPUSH
52002: CALL_OW 72
52006: PUSH
52007: LD_EXP 23
52011: PUSH
52012: LD_VAR 0 2
52016: ARRAY
52017: PPUSH
52018: LD_INT 2
52020: PUSH
52021: LD_INT 30
52023: PUSH
52024: LD_INT 0
52026: PUSH
52027: EMPTY
52028: LIST
52029: LIST
52030: PUSH
52031: LD_INT 30
52033: PUSH
52034: LD_INT 1
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: PUSH
52041: EMPTY
52042: LIST
52043: LIST
52044: LIST
52045: PPUSH
52046: CALL_OW 72
52050: PUSH
52051: LD_EXP 23
52055: PUSH
52056: LD_VAR 0 2
52060: ARRAY
52061: PPUSH
52062: LD_INT 30
52064: PUSH
52065: LD_INT 3
52067: PUSH
52068: EMPTY
52069: LIST
52070: LIST
52071: PPUSH
52072: CALL_OW 72
52076: PUSH
52077: LD_EXP 23
52081: PUSH
52082: LD_VAR 0 2
52086: ARRAY
52087: PPUSH
52088: LD_INT 2
52090: PUSH
52091: LD_INT 30
52093: PUSH
52094: LD_INT 6
52096: PUSH
52097: EMPTY
52098: LIST
52099: LIST
52100: PUSH
52101: LD_INT 30
52103: PUSH
52104: LD_INT 7
52106: PUSH
52107: EMPTY
52108: LIST
52109: LIST
52110: PUSH
52111: LD_INT 30
52113: PUSH
52114: LD_INT 8
52116: PUSH
52117: EMPTY
52118: LIST
52119: LIST
52120: PUSH
52121: EMPTY
52122: LIST
52123: LIST
52124: LIST
52125: LIST
52126: PPUSH
52127: CALL_OW 72
52131: PUSH
52132: EMPTY
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: ST_TO_ADDR
// for j = 1 to 4 do
52138: LD_ADDR_VAR 0 3
52142: PUSH
52143: DOUBLE
52144: LD_INT 1
52146: DEC
52147: ST_TO_ADDR
52148: LD_INT 4
52150: PUSH
52151: FOR_TO
52152: IFFALSE 52343
// begin if not tmp [ j ] then
52154: LD_VAR 0 4
52158: PUSH
52159: LD_VAR 0 3
52163: ARRAY
52164: NOT
52165: IFFALSE 52169
// continue ;
52167: GO 52151
// for p in tmp [ j ] do
52169: LD_ADDR_VAR 0 5
52173: PUSH
52174: LD_VAR 0 4
52178: PUSH
52179: LD_VAR 0 3
52183: ARRAY
52184: PUSH
52185: FOR_IN
52186: IFFALSE 52339
// begin if not b [ j ] then
52188: LD_VAR 0 6
52192: PUSH
52193: LD_VAR 0 3
52197: ARRAY
52198: NOT
52199: IFFALSE 52203
// break ;
52201: GO 52339
// e := 0 ;
52203: LD_ADDR_VAR 0 7
52207: PUSH
52208: LD_INT 0
52210: ST_TO_ADDR
// for k in b [ j ] do
52211: LD_ADDR_VAR 0 8
52215: PUSH
52216: LD_VAR 0 6
52220: PUSH
52221: LD_VAR 0 3
52225: ARRAY
52226: PUSH
52227: FOR_IN
52228: IFFALSE 52255
// if IsNotFull ( k ) then
52230: LD_VAR 0 8
52234: PPUSH
52235: CALL 11290 0 1
52239: IFFALSE 52253
// begin e := k ;
52241: LD_ADDR_VAR 0 7
52245: PUSH
52246: LD_VAR 0 8
52250: ST_TO_ADDR
// break ;
52251: GO 52255
// end ;
52253: GO 52227
52255: POP
52256: POP
// if e and not UnitGoingToBuilding ( p , e ) then
52257: LD_VAR 0 7
52261: PUSH
52262: LD_VAR 0 5
52266: PPUSH
52267: LD_VAR 0 7
52271: PPUSH
52272: CALL 44455 0 2
52276: NOT
52277: AND
52278: IFFALSE 52337
// begin if IsInUnit ( p ) then
52280: LD_VAR 0 5
52284: PPUSH
52285: CALL_OW 310
52289: IFFALSE 52300
// ComExitBuilding ( p ) ;
52291: LD_VAR 0 5
52295: PPUSH
52296: CALL_OW 122
// ComEnterUnit ( p , e ) ;
52300: LD_VAR 0 5
52304: PPUSH
52305: LD_VAR 0 7
52309: PPUSH
52310: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
52314: LD_VAR 0 5
52318: PPUSH
52319: LD_VAR 0 3
52323: PPUSH
52324: CALL_OW 183
// AddComExitBuilding ( p ) ;
52328: LD_VAR 0 5
52332: PPUSH
52333: CALL_OW 182
// end ; end ;
52337: GO 52185
52339: POP
52340: POP
// end ;
52341: GO 52151
52343: POP
52344: POP
// end ;
52345: GO 51906
52347: POP
52348: POP
// end ;
52349: LD_VAR 0 1
52353: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
52354: LD_INT 0
52356: PPUSH
52357: PPUSH
52358: PPUSH
52359: PPUSH
52360: PPUSH
52361: PPUSH
52362: PPUSH
52363: PPUSH
52364: PPUSH
52365: PPUSH
52366: PPUSH
52367: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
52368: LD_VAR 0 1
52372: NOT
52373: PUSH
52374: LD_EXP 23
52378: PUSH
52379: LD_VAR 0 1
52383: ARRAY
52384: NOT
52385: OR
52386: PUSH
52387: LD_EXP 23
52391: PUSH
52392: LD_VAR 0 1
52396: ARRAY
52397: PPUSH
52398: LD_INT 2
52400: PUSH
52401: LD_INT 30
52403: PUSH
52404: LD_INT 0
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: PUSH
52411: LD_INT 30
52413: PUSH
52414: LD_INT 1
52416: PUSH
52417: EMPTY
52418: LIST
52419: LIST
52420: PUSH
52421: EMPTY
52422: LIST
52423: LIST
52424: LIST
52425: PPUSH
52426: CALL_OW 72
52430: NOT
52431: OR
52432: IFFALSE 52436
// exit ;
52434: GO 55939
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52436: LD_ADDR_VAR 0 4
52440: PUSH
52441: LD_EXP 23
52445: PUSH
52446: LD_VAR 0 1
52450: ARRAY
52451: PPUSH
52452: LD_INT 2
52454: PUSH
52455: LD_INT 25
52457: PUSH
52458: LD_INT 1
52460: PUSH
52461: EMPTY
52462: LIST
52463: LIST
52464: PUSH
52465: LD_INT 25
52467: PUSH
52468: LD_INT 2
52470: PUSH
52471: EMPTY
52472: LIST
52473: LIST
52474: PUSH
52475: LD_INT 25
52477: PUSH
52478: LD_INT 3
52480: PUSH
52481: EMPTY
52482: LIST
52483: LIST
52484: PUSH
52485: LD_INT 25
52487: PUSH
52488: LD_INT 4
52490: PUSH
52491: EMPTY
52492: LIST
52493: LIST
52494: PUSH
52495: LD_INT 25
52497: PUSH
52498: LD_INT 5
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: PUSH
52505: LD_INT 25
52507: PUSH
52508: LD_INT 8
52510: PUSH
52511: EMPTY
52512: LIST
52513: LIST
52514: PUSH
52515: LD_INT 25
52517: PUSH
52518: LD_INT 9
52520: PUSH
52521: EMPTY
52522: LIST
52523: LIST
52524: PUSH
52525: EMPTY
52526: LIST
52527: LIST
52528: LIST
52529: LIST
52530: LIST
52531: LIST
52532: LIST
52533: LIST
52534: PPUSH
52535: CALL_OW 72
52539: ST_TO_ADDR
// if not tmp then
52540: LD_VAR 0 4
52544: NOT
52545: IFFALSE 52549
// exit ;
52547: GO 55939
// for i in tmp do
52549: LD_ADDR_VAR 0 3
52553: PUSH
52554: LD_VAR 0 4
52558: PUSH
52559: FOR_IN
52560: IFFALSE 52591
// if GetTag ( i ) then
52562: LD_VAR 0 3
52566: PPUSH
52567: CALL_OW 110
52571: IFFALSE 52589
// tmp := tmp diff i ;
52573: LD_ADDR_VAR 0 4
52577: PUSH
52578: LD_VAR 0 4
52582: PUSH
52583: LD_VAR 0 3
52587: DIFF
52588: ST_TO_ADDR
52589: GO 52559
52591: POP
52592: POP
// if not tmp then
52593: LD_VAR 0 4
52597: NOT
52598: IFFALSE 52602
// exit ;
52600: GO 55939
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
52602: LD_ADDR_VAR 0 5
52606: PUSH
52607: LD_EXP 23
52611: PUSH
52612: LD_VAR 0 1
52616: ARRAY
52617: PPUSH
52618: LD_INT 2
52620: PUSH
52621: LD_INT 25
52623: PUSH
52624: LD_INT 1
52626: PUSH
52627: EMPTY
52628: LIST
52629: LIST
52630: PUSH
52631: LD_INT 25
52633: PUSH
52634: LD_INT 5
52636: PUSH
52637: EMPTY
52638: LIST
52639: LIST
52640: PUSH
52641: LD_INT 25
52643: PUSH
52644: LD_INT 8
52646: PUSH
52647: EMPTY
52648: LIST
52649: LIST
52650: PUSH
52651: LD_INT 25
52653: PUSH
52654: LD_INT 9
52656: PUSH
52657: EMPTY
52658: LIST
52659: LIST
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: LIST
52665: LIST
52666: LIST
52667: PPUSH
52668: CALL_OW 72
52672: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
52673: LD_ADDR_VAR 0 6
52677: PUSH
52678: LD_EXP 23
52682: PUSH
52683: LD_VAR 0 1
52687: ARRAY
52688: PPUSH
52689: LD_INT 25
52691: PUSH
52692: LD_INT 2
52694: PUSH
52695: EMPTY
52696: LIST
52697: LIST
52698: PPUSH
52699: CALL_OW 72
52703: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
52704: LD_ADDR_VAR 0 7
52708: PUSH
52709: LD_EXP 23
52713: PUSH
52714: LD_VAR 0 1
52718: ARRAY
52719: PPUSH
52720: LD_INT 25
52722: PUSH
52723: LD_INT 3
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PPUSH
52730: CALL_OW 72
52734: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
52735: LD_ADDR_VAR 0 8
52739: PUSH
52740: LD_EXP 23
52744: PUSH
52745: LD_VAR 0 1
52749: ARRAY
52750: PPUSH
52751: LD_INT 25
52753: PUSH
52754: LD_INT 4
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: PUSH
52761: LD_INT 24
52763: PUSH
52764: LD_INT 251
52766: PUSH
52767: EMPTY
52768: LIST
52769: LIST
52770: PUSH
52771: EMPTY
52772: LIST
52773: LIST
52774: PPUSH
52775: CALL_OW 72
52779: ST_TO_ADDR
// if mc_scan [ base ] then
52780: LD_EXP 46
52784: PUSH
52785: LD_VAR 0 1
52789: ARRAY
52790: IFFALSE 53251
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
52792: LD_ADDR_EXP 65
52796: PUSH
52797: LD_EXP 65
52801: PPUSH
52802: LD_VAR 0 1
52806: PPUSH
52807: LD_INT 4
52809: PPUSH
52810: CALL_OW 1
52814: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52815: LD_ADDR_VAR 0 12
52819: PUSH
52820: LD_EXP 23
52824: PUSH
52825: LD_VAR 0 1
52829: ARRAY
52830: PPUSH
52831: LD_INT 2
52833: PUSH
52834: LD_INT 30
52836: PUSH
52837: LD_INT 4
52839: PUSH
52840: EMPTY
52841: LIST
52842: LIST
52843: PUSH
52844: LD_INT 30
52846: PUSH
52847: LD_INT 5
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PUSH
52854: EMPTY
52855: LIST
52856: LIST
52857: LIST
52858: PPUSH
52859: CALL_OW 72
52863: ST_TO_ADDR
// if not b then
52864: LD_VAR 0 12
52868: NOT
52869: IFFALSE 52873
// exit ;
52871: GO 55939
// p := [ ] ;
52873: LD_ADDR_VAR 0 11
52877: PUSH
52878: EMPTY
52879: ST_TO_ADDR
// if sci >= 2 then
52880: LD_VAR 0 8
52884: PUSH
52885: LD_INT 2
52887: GREATEREQUAL
52888: IFFALSE 52919
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
52890: LD_ADDR_VAR 0 8
52894: PUSH
52895: LD_VAR 0 8
52899: PUSH
52900: LD_INT 1
52902: ARRAY
52903: PUSH
52904: LD_VAR 0 8
52908: PUSH
52909: LD_INT 2
52911: ARRAY
52912: PUSH
52913: EMPTY
52914: LIST
52915: LIST
52916: ST_TO_ADDR
52917: GO 52980
// if sci = 1 then
52919: LD_VAR 0 8
52923: PUSH
52924: LD_INT 1
52926: EQUAL
52927: IFFALSE 52948
// sci := [ sci [ 1 ] ] else
52929: LD_ADDR_VAR 0 8
52933: PUSH
52934: LD_VAR 0 8
52938: PUSH
52939: LD_INT 1
52941: ARRAY
52942: PUSH
52943: EMPTY
52944: LIST
52945: ST_TO_ADDR
52946: GO 52980
// if sci = 0 then
52948: LD_VAR 0 8
52952: PUSH
52953: LD_INT 0
52955: EQUAL
52956: IFFALSE 52980
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
52958: LD_ADDR_VAR 0 11
52962: PUSH
52963: LD_VAR 0 4
52967: PPUSH
52968: LD_INT 4
52970: PPUSH
52971: CALL 44318 0 2
52975: PUSH
52976: LD_INT 1
52978: ARRAY
52979: ST_TO_ADDR
// if eng > 4 then
52980: LD_VAR 0 6
52984: PUSH
52985: LD_INT 4
52987: GREATER
52988: IFFALSE 53034
// for i = eng downto 4 do
52990: LD_ADDR_VAR 0 3
52994: PUSH
52995: DOUBLE
52996: LD_VAR 0 6
53000: INC
53001: ST_TO_ADDR
53002: LD_INT 4
53004: PUSH
53005: FOR_DOWNTO
53006: IFFALSE 53032
// eng := eng diff eng [ i ] ;
53008: LD_ADDR_VAR 0 6
53012: PUSH
53013: LD_VAR 0 6
53017: PUSH
53018: LD_VAR 0 6
53022: PUSH
53023: LD_VAR 0 3
53027: ARRAY
53028: DIFF
53029: ST_TO_ADDR
53030: GO 53005
53032: POP
53033: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
53034: LD_ADDR_VAR 0 4
53038: PUSH
53039: LD_VAR 0 4
53043: PUSH
53044: LD_VAR 0 5
53048: PUSH
53049: LD_VAR 0 6
53053: UNION
53054: PUSH
53055: LD_VAR 0 7
53059: UNION
53060: PUSH
53061: LD_VAR 0 8
53065: UNION
53066: DIFF
53067: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
53068: LD_ADDR_VAR 0 13
53072: PUSH
53073: LD_EXP 23
53077: PUSH
53078: LD_VAR 0 1
53082: ARRAY
53083: PPUSH
53084: LD_INT 2
53086: PUSH
53087: LD_INT 30
53089: PUSH
53090: LD_INT 32
53092: PUSH
53093: EMPTY
53094: LIST
53095: LIST
53096: PUSH
53097: LD_INT 30
53099: PUSH
53100: LD_INT 31
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: LIST
53111: PPUSH
53112: CALL_OW 72
53116: PUSH
53117: LD_EXP 23
53121: PUSH
53122: LD_VAR 0 1
53126: ARRAY
53127: PPUSH
53128: LD_INT 2
53130: PUSH
53131: LD_INT 30
53133: PUSH
53134: LD_INT 4
53136: PUSH
53137: EMPTY
53138: LIST
53139: LIST
53140: PUSH
53141: LD_INT 30
53143: PUSH
53144: LD_INT 5
53146: PUSH
53147: EMPTY
53148: LIST
53149: LIST
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: LIST
53155: PPUSH
53156: CALL_OW 72
53160: PUSH
53161: LD_INT 6
53163: MUL
53164: PLUS
53165: ST_TO_ADDR
// if bcount < tmp then
53166: LD_VAR 0 13
53170: PUSH
53171: LD_VAR 0 4
53175: LESS
53176: IFFALSE 53222
// for i = tmp downto bcount do
53178: LD_ADDR_VAR 0 3
53182: PUSH
53183: DOUBLE
53184: LD_VAR 0 4
53188: INC
53189: ST_TO_ADDR
53190: LD_VAR 0 13
53194: PUSH
53195: FOR_DOWNTO
53196: IFFALSE 53220
// tmp := Delete ( tmp , tmp ) ;
53198: LD_ADDR_VAR 0 4
53202: PUSH
53203: LD_VAR 0 4
53207: PPUSH
53208: LD_VAR 0 4
53212: PPUSH
53213: CALL_OW 3
53217: ST_TO_ADDR
53218: GO 53195
53220: POP
53221: POP
// result := [ tmp , 0 , 0 , p ] ;
53222: LD_ADDR_VAR 0 2
53226: PUSH
53227: LD_VAR 0 4
53231: PUSH
53232: LD_INT 0
53234: PUSH
53235: LD_INT 0
53237: PUSH
53238: LD_VAR 0 11
53242: PUSH
53243: EMPTY
53244: LIST
53245: LIST
53246: LIST
53247: LIST
53248: ST_TO_ADDR
// exit ;
53249: GO 55939
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53251: LD_EXP 23
53255: PUSH
53256: LD_VAR 0 1
53260: ARRAY
53261: PPUSH
53262: LD_INT 2
53264: PUSH
53265: LD_INT 30
53267: PUSH
53268: LD_INT 6
53270: PUSH
53271: EMPTY
53272: LIST
53273: LIST
53274: PUSH
53275: LD_INT 30
53277: PUSH
53278: LD_INT 7
53280: PUSH
53281: EMPTY
53282: LIST
53283: LIST
53284: PUSH
53285: LD_INT 30
53287: PUSH
53288: LD_INT 8
53290: PUSH
53291: EMPTY
53292: LIST
53293: LIST
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: LIST
53300: PPUSH
53301: CALL_OW 72
53305: NOT
53306: PUSH
53307: LD_EXP 23
53311: PUSH
53312: LD_VAR 0 1
53316: ARRAY
53317: PPUSH
53318: LD_INT 30
53320: PUSH
53321: LD_INT 3
53323: PUSH
53324: EMPTY
53325: LIST
53326: LIST
53327: PPUSH
53328: CALL_OW 72
53332: NOT
53333: AND
53334: IFFALSE 53406
// begin if eng = tmp then
53336: LD_VAR 0 6
53340: PUSH
53341: LD_VAR 0 4
53345: EQUAL
53346: IFFALSE 53350
// exit ;
53348: GO 55939
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
53350: LD_ADDR_EXP 65
53354: PUSH
53355: LD_EXP 65
53359: PPUSH
53360: LD_VAR 0 1
53364: PPUSH
53365: LD_INT 1
53367: PPUSH
53368: CALL_OW 1
53372: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
53373: LD_ADDR_VAR 0 2
53377: PUSH
53378: LD_INT 0
53380: PUSH
53381: LD_VAR 0 4
53385: PUSH
53386: LD_VAR 0 6
53390: DIFF
53391: PUSH
53392: LD_INT 0
53394: PUSH
53395: LD_INT 0
53397: PUSH
53398: EMPTY
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: ST_TO_ADDR
// exit ;
53404: GO 55939
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53406: LD_EXP 50
53410: PUSH
53411: LD_EXP 49
53415: PUSH
53416: LD_VAR 0 1
53420: ARRAY
53421: ARRAY
53422: PUSH
53423: LD_EXP 23
53427: PUSH
53428: LD_VAR 0 1
53432: ARRAY
53433: PPUSH
53434: LD_INT 2
53436: PUSH
53437: LD_INT 30
53439: PUSH
53440: LD_INT 6
53442: PUSH
53443: EMPTY
53444: LIST
53445: LIST
53446: PUSH
53447: LD_INT 30
53449: PUSH
53450: LD_INT 7
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: PUSH
53457: LD_INT 30
53459: PUSH
53460: LD_INT 8
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: LIST
53471: LIST
53472: PPUSH
53473: CALL_OW 72
53477: AND
53478: PUSH
53479: LD_EXP 23
53483: PUSH
53484: LD_VAR 0 1
53488: ARRAY
53489: PPUSH
53490: LD_INT 30
53492: PUSH
53493: LD_INT 3
53495: PUSH
53496: EMPTY
53497: LIST
53498: LIST
53499: PPUSH
53500: CALL_OW 72
53504: NOT
53505: AND
53506: IFFALSE 53720
// begin if sci >= 6 then
53508: LD_VAR 0 8
53512: PUSH
53513: LD_INT 6
53515: GREATEREQUAL
53516: IFFALSE 53520
// exit ;
53518: GO 55939
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
53520: LD_ADDR_EXP 65
53524: PUSH
53525: LD_EXP 65
53529: PPUSH
53530: LD_VAR 0 1
53534: PPUSH
53535: LD_INT 2
53537: PPUSH
53538: CALL_OW 1
53542: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
53543: LD_ADDR_VAR 0 9
53547: PUSH
53548: LD_VAR 0 4
53552: PUSH
53553: LD_VAR 0 8
53557: DIFF
53558: PPUSH
53559: LD_INT 4
53561: PPUSH
53562: CALL 44318 0 2
53566: ST_TO_ADDR
// p := [ ] ;
53567: LD_ADDR_VAR 0 11
53571: PUSH
53572: EMPTY
53573: ST_TO_ADDR
// if sci < 6 and sort > 6 then
53574: LD_VAR 0 8
53578: PUSH
53579: LD_INT 6
53581: LESS
53582: PUSH
53583: LD_VAR 0 9
53587: PUSH
53588: LD_INT 6
53590: GREATER
53591: AND
53592: IFFALSE 53673
// begin for i = 1 to 6 - sci do
53594: LD_ADDR_VAR 0 3
53598: PUSH
53599: DOUBLE
53600: LD_INT 1
53602: DEC
53603: ST_TO_ADDR
53604: LD_INT 6
53606: PUSH
53607: LD_VAR 0 8
53611: MINUS
53612: PUSH
53613: FOR_TO
53614: IFFALSE 53669
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
53616: LD_ADDR_VAR 0 11
53620: PUSH
53621: LD_VAR 0 11
53625: PPUSH
53626: LD_VAR 0 11
53630: PUSH
53631: LD_INT 1
53633: PLUS
53634: PPUSH
53635: LD_VAR 0 9
53639: PUSH
53640: LD_INT 1
53642: ARRAY
53643: PPUSH
53644: CALL_OW 2
53648: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
53649: LD_ADDR_VAR 0 9
53653: PUSH
53654: LD_VAR 0 9
53658: PPUSH
53659: LD_INT 1
53661: PPUSH
53662: CALL_OW 3
53666: ST_TO_ADDR
// end ;
53667: GO 53613
53669: POP
53670: POP
// end else
53671: GO 53693
// if sort then
53673: LD_VAR 0 9
53677: IFFALSE 53693
// p := sort [ 1 ] ;
53679: LD_ADDR_VAR 0 11
53683: PUSH
53684: LD_VAR 0 9
53688: PUSH
53689: LD_INT 1
53691: ARRAY
53692: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
53693: LD_ADDR_VAR 0 2
53697: PUSH
53698: LD_INT 0
53700: PUSH
53701: LD_INT 0
53703: PUSH
53704: LD_INT 0
53706: PUSH
53707: LD_VAR 0 11
53711: PUSH
53712: EMPTY
53713: LIST
53714: LIST
53715: LIST
53716: LIST
53717: ST_TO_ADDR
// exit ;
53718: GO 55939
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
53720: LD_EXP 50
53724: PUSH
53725: LD_EXP 49
53729: PUSH
53730: LD_VAR 0 1
53734: ARRAY
53735: ARRAY
53736: PUSH
53737: LD_EXP 23
53741: PUSH
53742: LD_VAR 0 1
53746: ARRAY
53747: PPUSH
53748: LD_INT 2
53750: PUSH
53751: LD_INT 30
53753: PUSH
53754: LD_INT 6
53756: PUSH
53757: EMPTY
53758: LIST
53759: LIST
53760: PUSH
53761: LD_INT 30
53763: PUSH
53764: LD_INT 7
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PUSH
53771: LD_INT 30
53773: PUSH
53774: LD_INT 8
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: EMPTY
53782: LIST
53783: LIST
53784: LIST
53785: LIST
53786: PPUSH
53787: CALL_OW 72
53791: AND
53792: PUSH
53793: LD_EXP 23
53797: PUSH
53798: LD_VAR 0 1
53802: ARRAY
53803: PPUSH
53804: LD_INT 30
53806: PUSH
53807: LD_INT 3
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PPUSH
53814: CALL_OW 72
53818: AND
53819: IFFALSE 54553
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
53821: LD_ADDR_EXP 65
53825: PUSH
53826: LD_EXP 65
53830: PPUSH
53831: LD_VAR 0 1
53835: PPUSH
53836: LD_INT 3
53838: PPUSH
53839: CALL_OW 1
53843: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
53844: LD_ADDR_VAR 0 2
53848: PUSH
53849: LD_INT 0
53851: PUSH
53852: LD_INT 0
53854: PUSH
53855: LD_INT 0
53857: PUSH
53858: LD_INT 0
53860: PUSH
53861: EMPTY
53862: LIST
53863: LIST
53864: LIST
53865: LIST
53866: ST_TO_ADDR
// if not eng then
53867: LD_VAR 0 6
53871: NOT
53872: IFFALSE 53935
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
53874: LD_ADDR_VAR 0 11
53878: PUSH
53879: LD_VAR 0 4
53883: PPUSH
53884: LD_INT 2
53886: PPUSH
53887: CALL 44318 0 2
53891: PUSH
53892: LD_INT 1
53894: ARRAY
53895: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
53896: LD_ADDR_VAR 0 2
53900: PUSH
53901: LD_VAR 0 2
53905: PPUSH
53906: LD_INT 2
53908: PPUSH
53909: LD_VAR 0 11
53913: PPUSH
53914: CALL_OW 1
53918: ST_TO_ADDR
// tmp := tmp diff p ;
53919: LD_ADDR_VAR 0 4
53923: PUSH
53924: LD_VAR 0 4
53928: PUSH
53929: LD_VAR 0 11
53933: DIFF
53934: ST_TO_ADDR
// end ; if tmp and sci < 6 then
53935: LD_VAR 0 4
53939: PUSH
53940: LD_VAR 0 8
53944: PUSH
53945: LD_INT 6
53947: LESS
53948: AND
53949: IFFALSE 54137
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
53951: LD_ADDR_VAR 0 9
53955: PUSH
53956: LD_VAR 0 4
53960: PUSH
53961: LD_VAR 0 8
53965: PUSH
53966: LD_VAR 0 7
53970: UNION
53971: DIFF
53972: PPUSH
53973: LD_INT 4
53975: PPUSH
53976: CALL 44318 0 2
53980: ST_TO_ADDR
// p := [ ] ;
53981: LD_ADDR_VAR 0 11
53985: PUSH
53986: EMPTY
53987: ST_TO_ADDR
// if sort then
53988: LD_VAR 0 9
53992: IFFALSE 54108
// for i = 1 to 6 - sci do
53994: LD_ADDR_VAR 0 3
53998: PUSH
53999: DOUBLE
54000: LD_INT 1
54002: DEC
54003: ST_TO_ADDR
54004: LD_INT 6
54006: PUSH
54007: LD_VAR 0 8
54011: MINUS
54012: PUSH
54013: FOR_TO
54014: IFFALSE 54106
// begin if i = sort then
54016: LD_VAR 0 3
54020: PUSH
54021: LD_VAR 0 9
54025: EQUAL
54026: IFFALSE 54030
// break ;
54028: GO 54106
// if GetClass ( i ) = 4 then
54030: LD_VAR 0 3
54034: PPUSH
54035: CALL_OW 257
54039: PUSH
54040: LD_INT 4
54042: EQUAL
54043: IFFALSE 54047
// continue ;
54045: GO 54013
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54047: LD_ADDR_VAR 0 11
54051: PUSH
54052: LD_VAR 0 11
54056: PPUSH
54057: LD_VAR 0 11
54061: PUSH
54062: LD_INT 1
54064: PLUS
54065: PPUSH
54066: LD_VAR 0 9
54070: PUSH
54071: LD_VAR 0 3
54075: ARRAY
54076: PPUSH
54077: CALL_OW 2
54081: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54082: LD_ADDR_VAR 0 4
54086: PUSH
54087: LD_VAR 0 4
54091: PUSH
54092: LD_VAR 0 9
54096: PUSH
54097: LD_VAR 0 3
54101: ARRAY
54102: DIFF
54103: ST_TO_ADDR
// end ;
54104: GO 54013
54106: POP
54107: POP
// if p then
54108: LD_VAR 0 11
54112: IFFALSE 54137
// result := Replace ( result , 4 , p ) ;
54114: LD_ADDR_VAR 0 2
54118: PUSH
54119: LD_VAR 0 2
54123: PPUSH
54124: LD_INT 4
54126: PPUSH
54127: LD_VAR 0 11
54131: PPUSH
54132: CALL_OW 1
54136: ST_TO_ADDR
// end ; if tmp and mech < 6 then
54137: LD_VAR 0 4
54141: PUSH
54142: LD_VAR 0 7
54146: PUSH
54147: LD_INT 6
54149: LESS
54150: AND
54151: IFFALSE 54339
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54153: LD_ADDR_VAR 0 9
54157: PUSH
54158: LD_VAR 0 4
54162: PUSH
54163: LD_VAR 0 8
54167: PUSH
54168: LD_VAR 0 7
54172: UNION
54173: DIFF
54174: PPUSH
54175: LD_INT 3
54177: PPUSH
54178: CALL 44318 0 2
54182: ST_TO_ADDR
// p := [ ] ;
54183: LD_ADDR_VAR 0 11
54187: PUSH
54188: EMPTY
54189: ST_TO_ADDR
// if sort then
54190: LD_VAR 0 9
54194: IFFALSE 54310
// for i = 1 to 6 - mech do
54196: LD_ADDR_VAR 0 3
54200: PUSH
54201: DOUBLE
54202: LD_INT 1
54204: DEC
54205: ST_TO_ADDR
54206: LD_INT 6
54208: PUSH
54209: LD_VAR 0 7
54213: MINUS
54214: PUSH
54215: FOR_TO
54216: IFFALSE 54308
// begin if i = sort then
54218: LD_VAR 0 3
54222: PUSH
54223: LD_VAR 0 9
54227: EQUAL
54228: IFFALSE 54232
// break ;
54230: GO 54308
// if GetClass ( i ) = 3 then
54232: LD_VAR 0 3
54236: PPUSH
54237: CALL_OW 257
54241: PUSH
54242: LD_INT 3
54244: EQUAL
54245: IFFALSE 54249
// continue ;
54247: GO 54215
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54249: LD_ADDR_VAR 0 11
54253: PUSH
54254: LD_VAR 0 11
54258: PPUSH
54259: LD_VAR 0 11
54263: PUSH
54264: LD_INT 1
54266: PLUS
54267: PPUSH
54268: LD_VAR 0 9
54272: PUSH
54273: LD_VAR 0 3
54277: ARRAY
54278: PPUSH
54279: CALL_OW 2
54283: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54284: LD_ADDR_VAR 0 4
54288: PUSH
54289: LD_VAR 0 4
54293: PUSH
54294: LD_VAR 0 9
54298: PUSH
54299: LD_VAR 0 3
54303: ARRAY
54304: DIFF
54305: ST_TO_ADDR
// end ;
54306: GO 54215
54308: POP
54309: POP
// if p then
54310: LD_VAR 0 11
54314: IFFALSE 54339
// result := Replace ( result , 3 , p ) ;
54316: LD_ADDR_VAR 0 2
54320: PUSH
54321: LD_VAR 0 2
54325: PPUSH
54326: LD_INT 3
54328: PPUSH
54329: LD_VAR 0 11
54333: PPUSH
54334: CALL_OW 1
54338: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
54339: LD_VAR 0 4
54343: PUSH
54344: LD_INT 6
54346: GREATER
54347: PUSH
54348: LD_VAR 0 6
54352: PUSH
54353: LD_INT 6
54355: LESS
54356: AND
54357: IFFALSE 54551
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
54359: LD_ADDR_VAR 0 9
54363: PUSH
54364: LD_VAR 0 4
54368: PUSH
54369: LD_VAR 0 8
54373: PUSH
54374: LD_VAR 0 7
54378: UNION
54379: PUSH
54380: LD_VAR 0 6
54384: UNION
54385: DIFF
54386: PPUSH
54387: LD_INT 2
54389: PPUSH
54390: CALL 44318 0 2
54394: ST_TO_ADDR
// p := [ ] ;
54395: LD_ADDR_VAR 0 11
54399: PUSH
54400: EMPTY
54401: ST_TO_ADDR
// if sort then
54402: LD_VAR 0 9
54406: IFFALSE 54522
// for i = 1 to 6 - eng do
54408: LD_ADDR_VAR 0 3
54412: PUSH
54413: DOUBLE
54414: LD_INT 1
54416: DEC
54417: ST_TO_ADDR
54418: LD_INT 6
54420: PUSH
54421: LD_VAR 0 6
54425: MINUS
54426: PUSH
54427: FOR_TO
54428: IFFALSE 54520
// begin if i = sort then
54430: LD_VAR 0 3
54434: PUSH
54435: LD_VAR 0 9
54439: EQUAL
54440: IFFALSE 54444
// break ;
54442: GO 54520
// if GetClass ( i ) = 2 then
54444: LD_VAR 0 3
54448: PPUSH
54449: CALL_OW 257
54453: PUSH
54454: LD_INT 2
54456: EQUAL
54457: IFFALSE 54461
// continue ;
54459: GO 54427
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54461: LD_ADDR_VAR 0 11
54465: PUSH
54466: LD_VAR 0 11
54470: PPUSH
54471: LD_VAR 0 11
54475: PUSH
54476: LD_INT 1
54478: PLUS
54479: PPUSH
54480: LD_VAR 0 9
54484: PUSH
54485: LD_VAR 0 3
54489: ARRAY
54490: PPUSH
54491: CALL_OW 2
54495: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54496: LD_ADDR_VAR 0 4
54500: PUSH
54501: LD_VAR 0 4
54505: PUSH
54506: LD_VAR 0 9
54510: PUSH
54511: LD_VAR 0 3
54515: ARRAY
54516: DIFF
54517: ST_TO_ADDR
// end ;
54518: GO 54427
54520: POP
54521: POP
// if p then
54522: LD_VAR 0 11
54526: IFFALSE 54551
// result := Replace ( result , 2 , p ) ;
54528: LD_ADDR_VAR 0 2
54532: PUSH
54533: LD_VAR 0 2
54537: PPUSH
54538: LD_INT 2
54540: PPUSH
54541: LD_VAR 0 11
54545: PPUSH
54546: CALL_OW 1
54550: ST_TO_ADDR
// end ; exit ;
54551: GO 55939
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
54553: LD_EXP 50
54557: PUSH
54558: LD_EXP 49
54562: PUSH
54563: LD_VAR 0 1
54567: ARRAY
54568: ARRAY
54569: NOT
54570: PUSH
54571: LD_EXP 23
54575: PUSH
54576: LD_VAR 0 1
54580: ARRAY
54581: PPUSH
54582: LD_INT 30
54584: PUSH
54585: LD_INT 3
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: PPUSH
54592: CALL_OW 72
54596: AND
54597: PUSH
54598: LD_EXP 28
54602: PUSH
54603: LD_VAR 0 1
54607: ARRAY
54608: AND
54609: IFFALSE 55217
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
54611: LD_ADDR_EXP 65
54615: PUSH
54616: LD_EXP 65
54620: PPUSH
54621: LD_VAR 0 1
54625: PPUSH
54626: LD_INT 5
54628: PPUSH
54629: CALL_OW 1
54633: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
54634: LD_ADDR_VAR 0 2
54638: PUSH
54639: LD_INT 0
54641: PUSH
54642: LD_INT 0
54644: PUSH
54645: LD_INT 0
54647: PUSH
54648: LD_INT 0
54650: PUSH
54651: EMPTY
54652: LIST
54653: LIST
54654: LIST
54655: LIST
54656: ST_TO_ADDR
// if sci > 1 then
54657: LD_VAR 0 8
54661: PUSH
54662: LD_INT 1
54664: GREATER
54665: IFFALSE 54693
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
54667: LD_ADDR_VAR 0 4
54671: PUSH
54672: LD_VAR 0 4
54676: PUSH
54677: LD_VAR 0 8
54681: PUSH
54682: LD_VAR 0 8
54686: PUSH
54687: LD_INT 1
54689: ARRAY
54690: DIFF
54691: DIFF
54692: ST_TO_ADDR
// if tmp and not sci then
54693: LD_VAR 0 4
54697: PUSH
54698: LD_VAR 0 8
54702: NOT
54703: AND
54704: IFFALSE 54773
// begin sort := SortBySkill ( tmp , 4 ) ;
54706: LD_ADDR_VAR 0 9
54710: PUSH
54711: LD_VAR 0 4
54715: PPUSH
54716: LD_INT 4
54718: PPUSH
54719: CALL 44318 0 2
54723: ST_TO_ADDR
// if sort then
54724: LD_VAR 0 9
54728: IFFALSE 54744
// p := sort [ 1 ] ;
54730: LD_ADDR_VAR 0 11
54734: PUSH
54735: LD_VAR 0 9
54739: PUSH
54740: LD_INT 1
54742: ARRAY
54743: ST_TO_ADDR
// if p then
54744: LD_VAR 0 11
54748: IFFALSE 54773
// result := Replace ( result , 4 , p ) ;
54750: LD_ADDR_VAR 0 2
54754: PUSH
54755: LD_VAR 0 2
54759: PPUSH
54760: LD_INT 4
54762: PPUSH
54763: LD_VAR 0 11
54767: PPUSH
54768: CALL_OW 1
54772: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
54773: LD_ADDR_VAR 0 4
54777: PUSH
54778: LD_VAR 0 4
54782: PUSH
54783: LD_VAR 0 7
54787: DIFF
54788: ST_TO_ADDR
// if tmp and mech < 6 then
54789: LD_VAR 0 4
54793: PUSH
54794: LD_VAR 0 7
54798: PUSH
54799: LD_INT 6
54801: LESS
54802: AND
54803: IFFALSE 54991
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
54805: LD_ADDR_VAR 0 9
54809: PUSH
54810: LD_VAR 0 4
54814: PUSH
54815: LD_VAR 0 8
54819: PUSH
54820: LD_VAR 0 7
54824: UNION
54825: DIFF
54826: PPUSH
54827: LD_INT 3
54829: PPUSH
54830: CALL 44318 0 2
54834: ST_TO_ADDR
// p := [ ] ;
54835: LD_ADDR_VAR 0 11
54839: PUSH
54840: EMPTY
54841: ST_TO_ADDR
// if sort then
54842: LD_VAR 0 9
54846: IFFALSE 54962
// for i = 1 to 6 - mech do
54848: LD_ADDR_VAR 0 3
54852: PUSH
54853: DOUBLE
54854: LD_INT 1
54856: DEC
54857: ST_TO_ADDR
54858: LD_INT 6
54860: PUSH
54861: LD_VAR 0 7
54865: MINUS
54866: PUSH
54867: FOR_TO
54868: IFFALSE 54960
// begin if i = sort then
54870: LD_VAR 0 3
54874: PUSH
54875: LD_VAR 0 9
54879: EQUAL
54880: IFFALSE 54884
// break ;
54882: GO 54960
// if GetClass ( i ) = 3 then
54884: LD_VAR 0 3
54888: PPUSH
54889: CALL_OW 257
54893: PUSH
54894: LD_INT 3
54896: EQUAL
54897: IFFALSE 54901
// continue ;
54899: GO 54867
// p := Insert ( p , p + 1 , sort [ i ] ) ;
54901: LD_ADDR_VAR 0 11
54905: PUSH
54906: LD_VAR 0 11
54910: PPUSH
54911: LD_VAR 0 11
54915: PUSH
54916: LD_INT 1
54918: PLUS
54919: PPUSH
54920: LD_VAR 0 9
54924: PUSH
54925: LD_VAR 0 3
54929: ARRAY
54930: PPUSH
54931: CALL_OW 2
54935: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
54936: LD_ADDR_VAR 0 4
54940: PUSH
54941: LD_VAR 0 4
54945: PUSH
54946: LD_VAR 0 9
54950: PUSH
54951: LD_VAR 0 3
54955: ARRAY
54956: DIFF
54957: ST_TO_ADDR
// end ;
54958: GO 54867
54960: POP
54961: POP
// if p then
54962: LD_VAR 0 11
54966: IFFALSE 54991
// result := Replace ( result , 3 , p ) ;
54968: LD_ADDR_VAR 0 2
54972: PUSH
54973: LD_VAR 0 2
54977: PPUSH
54978: LD_INT 3
54980: PPUSH
54981: LD_VAR 0 11
54985: PPUSH
54986: CALL_OW 1
54990: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
54991: LD_ADDR_VAR 0 4
54995: PUSH
54996: LD_VAR 0 4
55000: PUSH
55001: LD_VAR 0 6
55005: DIFF
55006: ST_TO_ADDR
// if tmp and eng < 6 then
55007: LD_VAR 0 4
55011: PUSH
55012: LD_VAR 0 6
55016: PUSH
55017: LD_INT 6
55019: LESS
55020: AND
55021: IFFALSE 55215
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
55023: LD_ADDR_VAR 0 9
55027: PUSH
55028: LD_VAR 0 4
55032: PUSH
55033: LD_VAR 0 8
55037: PUSH
55038: LD_VAR 0 7
55042: UNION
55043: PUSH
55044: LD_VAR 0 6
55048: UNION
55049: DIFF
55050: PPUSH
55051: LD_INT 2
55053: PPUSH
55054: CALL 44318 0 2
55058: ST_TO_ADDR
// p := [ ] ;
55059: LD_ADDR_VAR 0 11
55063: PUSH
55064: EMPTY
55065: ST_TO_ADDR
// if sort then
55066: LD_VAR 0 9
55070: IFFALSE 55186
// for i = 1 to 6 - eng do
55072: LD_ADDR_VAR 0 3
55076: PUSH
55077: DOUBLE
55078: LD_INT 1
55080: DEC
55081: ST_TO_ADDR
55082: LD_INT 6
55084: PUSH
55085: LD_VAR 0 6
55089: MINUS
55090: PUSH
55091: FOR_TO
55092: IFFALSE 55184
// begin if i = sort then
55094: LD_VAR 0 3
55098: PUSH
55099: LD_VAR 0 9
55103: EQUAL
55104: IFFALSE 55108
// break ;
55106: GO 55184
// if GetClass ( i ) = 2 then
55108: LD_VAR 0 3
55112: PPUSH
55113: CALL_OW 257
55117: PUSH
55118: LD_INT 2
55120: EQUAL
55121: IFFALSE 55125
// continue ;
55123: GO 55091
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55125: LD_ADDR_VAR 0 11
55129: PUSH
55130: LD_VAR 0 11
55134: PPUSH
55135: LD_VAR 0 11
55139: PUSH
55140: LD_INT 1
55142: PLUS
55143: PPUSH
55144: LD_VAR 0 9
55148: PUSH
55149: LD_VAR 0 3
55153: ARRAY
55154: PPUSH
55155: CALL_OW 2
55159: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55160: LD_ADDR_VAR 0 4
55164: PUSH
55165: LD_VAR 0 4
55169: PUSH
55170: LD_VAR 0 9
55174: PUSH
55175: LD_VAR 0 3
55179: ARRAY
55180: DIFF
55181: ST_TO_ADDR
// end ;
55182: GO 55091
55184: POP
55185: POP
// if p then
55186: LD_VAR 0 11
55190: IFFALSE 55215
// result := Replace ( result , 2 , p ) ;
55192: LD_ADDR_VAR 0 2
55196: PUSH
55197: LD_VAR 0 2
55201: PPUSH
55202: LD_INT 2
55204: PPUSH
55205: LD_VAR 0 11
55209: PPUSH
55210: CALL_OW 1
55214: ST_TO_ADDR
// end ; exit ;
55215: GO 55939
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
55217: LD_EXP 50
55221: PUSH
55222: LD_EXP 49
55226: PUSH
55227: LD_VAR 0 1
55231: ARRAY
55232: ARRAY
55233: NOT
55234: PUSH
55235: LD_EXP 23
55239: PUSH
55240: LD_VAR 0 1
55244: ARRAY
55245: PPUSH
55246: LD_INT 30
55248: PUSH
55249: LD_INT 3
55251: PUSH
55252: EMPTY
55253: LIST
55254: LIST
55255: PPUSH
55256: CALL_OW 72
55260: AND
55261: PUSH
55262: LD_EXP 28
55266: PUSH
55267: LD_VAR 0 1
55271: ARRAY
55272: NOT
55273: AND
55274: IFFALSE 55939
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
55276: LD_ADDR_EXP 65
55280: PUSH
55281: LD_EXP 65
55285: PPUSH
55286: LD_VAR 0 1
55290: PPUSH
55291: LD_INT 6
55293: PPUSH
55294: CALL_OW 1
55298: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
55299: LD_ADDR_VAR 0 2
55303: PUSH
55304: LD_INT 0
55306: PUSH
55307: LD_INT 0
55309: PUSH
55310: LD_INT 0
55312: PUSH
55313: LD_INT 0
55315: PUSH
55316: EMPTY
55317: LIST
55318: LIST
55319: LIST
55320: LIST
55321: ST_TO_ADDR
// if sci >= 1 then
55322: LD_VAR 0 8
55326: PUSH
55327: LD_INT 1
55329: GREATEREQUAL
55330: IFFALSE 55352
// tmp := tmp diff sci [ 1 ] ;
55332: LD_ADDR_VAR 0 4
55336: PUSH
55337: LD_VAR 0 4
55341: PUSH
55342: LD_VAR 0 8
55346: PUSH
55347: LD_INT 1
55349: ARRAY
55350: DIFF
55351: ST_TO_ADDR
// if tmp and not sci then
55352: LD_VAR 0 4
55356: PUSH
55357: LD_VAR 0 8
55361: NOT
55362: AND
55363: IFFALSE 55432
// begin sort := SortBySkill ( tmp , 4 ) ;
55365: LD_ADDR_VAR 0 9
55369: PUSH
55370: LD_VAR 0 4
55374: PPUSH
55375: LD_INT 4
55377: PPUSH
55378: CALL 44318 0 2
55382: ST_TO_ADDR
// if sort then
55383: LD_VAR 0 9
55387: IFFALSE 55403
// p := sort [ 1 ] ;
55389: LD_ADDR_VAR 0 11
55393: PUSH
55394: LD_VAR 0 9
55398: PUSH
55399: LD_INT 1
55401: ARRAY
55402: ST_TO_ADDR
// if p then
55403: LD_VAR 0 11
55407: IFFALSE 55432
// result := Replace ( result , 4 , p ) ;
55409: LD_ADDR_VAR 0 2
55413: PUSH
55414: LD_VAR 0 2
55418: PPUSH
55419: LD_INT 4
55421: PPUSH
55422: LD_VAR 0 11
55426: PPUSH
55427: CALL_OW 1
55431: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
55432: LD_ADDR_VAR 0 4
55436: PUSH
55437: LD_VAR 0 4
55441: PUSH
55442: LD_VAR 0 7
55446: DIFF
55447: ST_TO_ADDR
// if tmp and mech < 6 then
55448: LD_VAR 0 4
55452: PUSH
55453: LD_VAR 0 7
55457: PUSH
55458: LD_INT 6
55460: LESS
55461: AND
55462: IFFALSE 55644
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
55464: LD_ADDR_VAR 0 9
55468: PUSH
55469: LD_VAR 0 4
55473: PUSH
55474: LD_VAR 0 7
55478: DIFF
55479: PPUSH
55480: LD_INT 3
55482: PPUSH
55483: CALL 44318 0 2
55487: ST_TO_ADDR
// p := [ ] ;
55488: LD_ADDR_VAR 0 11
55492: PUSH
55493: EMPTY
55494: ST_TO_ADDR
// if sort then
55495: LD_VAR 0 9
55499: IFFALSE 55615
// for i = 1 to 6 - mech do
55501: LD_ADDR_VAR 0 3
55505: PUSH
55506: DOUBLE
55507: LD_INT 1
55509: DEC
55510: ST_TO_ADDR
55511: LD_INT 6
55513: PUSH
55514: LD_VAR 0 7
55518: MINUS
55519: PUSH
55520: FOR_TO
55521: IFFALSE 55613
// begin if i = sort then
55523: LD_VAR 0 3
55527: PUSH
55528: LD_VAR 0 9
55532: EQUAL
55533: IFFALSE 55537
// break ;
55535: GO 55613
// if GetClass ( i ) = 3 then
55537: LD_VAR 0 3
55541: PPUSH
55542: CALL_OW 257
55546: PUSH
55547: LD_INT 3
55549: EQUAL
55550: IFFALSE 55554
// continue ;
55552: GO 55520
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55554: LD_ADDR_VAR 0 11
55558: PUSH
55559: LD_VAR 0 11
55563: PPUSH
55564: LD_VAR 0 11
55568: PUSH
55569: LD_INT 1
55571: PLUS
55572: PPUSH
55573: LD_VAR 0 9
55577: PUSH
55578: LD_VAR 0 3
55582: ARRAY
55583: PPUSH
55584: CALL_OW 2
55588: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55589: LD_ADDR_VAR 0 4
55593: PUSH
55594: LD_VAR 0 4
55598: PUSH
55599: LD_VAR 0 9
55603: PUSH
55604: LD_VAR 0 3
55608: ARRAY
55609: DIFF
55610: ST_TO_ADDR
// end ;
55611: GO 55520
55613: POP
55614: POP
// if p then
55615: LD_VAR 0 11
55619: IFFALSE 55644
// result := Replace ( result , 3 , p ) ;
55621: LD_ADDR_VAR 0 2
55625: PUSH
55626: LD_VAR 0 2
55630: PPUSH
55631: LD_INT 3
55633: PPUSH
55634: LD_VAR 0 11
55638: PPUSH
55639: CALL_OW 1
55643: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
55644: LD_ADDR_VAR 0 4
55648: PUSH
55649: LD_VAR 0 4
55653: PUSH
55654: LD_VAR 0 6
55658: DIFF
55659: ST_TO_ADDR
// if tmp and eng < 4 then
55660: LD_VAR 0 4
55664: PUSH
55665: LD_VAR 0 6
55669: PUSH
55670: LD_INT 4
55672: LESS
55673: AND
55674: IFFALSE 55864
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
55676: LD_ADDR_VAR 0 9
55680: PUSH
55681: LD_VAR 0 4
55685: PUSH
55686: LD_VAR 0 7
55690: PUSH
55691: LD_VAR 0 6
55695: UNION
55696: DIFF
55697: PPUSH
55698: LD_INT 2
55700: PPUSH
55701: CALL 44318 0 2
55705: ST_TO_ADDR
// p := [ ] ;
55706: LD_ADDR_VAR 0 11
55710: PUSH
55711: EMPTY
55712: ST_TO_ADDR
// if sort then
55713: LD_VAR 0 9
55717: IFFALSE 55833
// for i = 1 to 4 - eng do
55719: LD_ADDR_VAR 0 3
55723: PUSH
55724: DOUBLE
55725: LD_INT 1
55727: DEC
55728: ST_TO_ADDR
55729: LD_INT 4
55731: PUSH
55732: LD_VAR 0 6
55736: MINUS
55737: PUSH
55738: FOR_TO
55739: IFFALSE 55831
// begin if i = sort then
55741: LD_VAR 0 3
55745: PUSH
55746: LD_VAR 0 9
55750: EQUAL
55751: IFFALSE 55755
// break ;
55753: GO 55831
// if GetClass ( i ) = 2 then
55755: LD_VAR 0 3
55759: PPUSH
55760: CALL_OW 257
55764: PUSH
55765: LD_INT 2
55767: EQUAL
55768: IFFALSE 55772
// continue ;
55770: GO 55738
// p := Insert ( p , p + 1 , sort [ i ] ) ;
55772: LD_ADDR_VAR 0 11
55776: PUSH
55777: LD_VAR 0 11
55781: PPUSH
55782: LD_VAR 0 11
55786: PUSH
55787: LD_INT 1
55789: PLUS
55790: PPUSH
55791: LD_VAR 0 9
55795: PUSH
55796: LD_VAR 0 3
55800: ARRAY
55801: PPUSH
55802: CALL_OW 2
55806: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
55807: LD_ADDR_VAR 0 4
55811: PUSH
55812: LD_VAR 0 4
55816: PUSH
55817: LD_VAR 0 9
55821: PUSH
55822: LD_VAR 0 3
55826: ARRAY
55827: DIFF
55828: ST_TO_ADDR
// end ;
55829: GO 55738
55831: POP
55832: POP
// if p then
55833: LD_VAR 0 11
55837: IFFALSE 55862
// result := Replace ( result , 2 , p ) ;
55839: LD_ADDR_VAR 0 2
55843: PUSH
55844: LD_VAR 0 2
55848: PPUSH
55849: LD_INT 2
55851: PPUSH
55852: LD_VAR 0 11
55856: PPUSH
55857: CALL_OW 1
55861: ST_TO_ADDR
// end else
55862: GO 55908
// for i = eng downto 5 do
55864: LD_ADDR_VAR 0 3
55868: PUSH
55869: DOUBLE
55870: LD_VAR 0 6
55874: INC
55875: ST_TO_ADDR
55876: LD_INT 5
55878: PUSH
55879: FOR_DOWNTO
55880: IFFALSE 55906
// tmp := tmp union eng [ i ] ;
55882: LD_ADDR_VAR 0 4
55886: PUSH
55887: LD_VAR 0 4
55891: PUSH
55892: LD_VAR 0 6
55896: PUSH
55897: LD_VAR 0 3
55901: ARRAY
55902: UNION
55903: ST_TO_ADDR
55904: GO 55879
55906: POP
55907: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
55908: LD_ADDR_VAR 0 2
55912: PUSH
55913: LD_VAR 0 2
55917: PPUSH
55918: LD_INT 1
55920: PPUSH
55921: LD_VAR 0 4
55925: PUSH
55926: LD_VAR 0 5
55930: DIFF
55931: PPUSH
55932: CALL_OW 1
55936: ST_TO_ADDR
// exit ;
55937: GO 55939
// end ; end ;
55939: LD_VAR 0 2
55943: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
55944: LD_INT 0
55946: PPUSH
55947: PPUSH
55948: PPUSH
// if not mc_bases then
55949: LD_EXP 23
55953: NOT
55954: IFFALSE 55958
// exit ;
55956: GO 56064
// for i = 1 to mc_bases do
55958: LD_ADDR_VAR 0 2
55962: PUSH
55963: DOUBLE
55964: LD_INT 1
55966: DEC
55967: ST_TO_ADDR
55968: LD_EXP 23
55972: PUSH
55973: FOR_TO
55974: IFFALSE 56055
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
55976: LD_ADDR_VAR 0 3
55980: PUSH
55981: LD_EXP 23
55985: PUSH
55986: LD_VAR 0 2
55990: ARRAY
55991: PPUSH
55992: LD_INT 21
55994: PUSH
55995: LD_INT 3
55997: PUSH
55998: EMPTY
55999: LIST
56000: LIST
56001: PUSH
56002: LD_INT 3
56004: PUSH
56005: LD_INT 24
56007: PUSH
56008: LD_INT 1000
56010: PUSH
56011: EMPTY
56012: LIST
56013: LIST
56014: PUSH
56015: EMPTY
56016: LIST
56017: LIST
56018: PUSH
56019: EMPTY
56020: LIST
56021: LIST
56022: PPUSH
56023: CALL_OW 72
56027: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
56028: LD_ADDR_EXP 24
56032: PUSH
56033: LD_EXP 24
56037: PPUSH
56038: LD_VAR 0 2
56042: PPUSH
56043: LD_VAR 0 3
56047: PPUSH
56048: CALL_OW 1
56052: ST_TO_ADDR
// end ;
56053: GO 55973
56055: POP
56056: POP
// RaiseSailEvent ( 101 ) ;
56057: LD_INT 101
56059: PPUSH
56060: CALL_OW 427
// end ;
56064: LD_VAR 0 1
56068: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
56069: LD_INT 0
56071: PPUSH
56072: PPUSH
56073: PPUSH
56074: PPUSH
56075: PPUSH
56076: PPUSH
56077: PPUSH
// if not mc_bases then
56078: LD_EXP 23
56082: NOT
56083: IFFALSE 56087
// exit ;
56085: GO 56649
// for i = 1 to mc_bases do
56087: LD_ADDR_VAR 0 2
56091: PUSH
56092: DOUBLE
56093: LD_INT 1
56095: DEC
56096: ST_TO_ADDR
56097: LD_EXP 23
56101: PUSH
56102: FOR_TO
56103: IFFALSE 56640
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
56105: LD_ADDR_VAR 0 5
56109: PUSH
56110: LD_EXP 23
56114: PUSH
56115: LD_VAR 0 2
56119: ARRAY
56120: PUSH
56121: LD_EXP 52
56125: PUSH
56126: LD_VAR 0 2
56130: ARRAY
56131: UNION
56132: PPUSH
56133: LD_INT 21
56135: PUSH
56136: LD_INT 1
56138: PUSH
56139: EMPTY
56140: LIST
56141: LIST
56142: PUSH
56143: LD_INT 1
56145: PUSH
56146: LD_INT 3
56148: PUSH
56149: LD_INT 54
56151: PUSH
56152: EMPTY
56153: LIST
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: PUSH
56159: LD_INT 3
56161: PUSH
56162: LD_INT 24
56164: PUSH
56165: LD_INT 1000
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PUSH
56172: EMPTY
56173: LIST
56174: LIST
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: LIST
56180: PUSH
56181: EMPTY
56182: LIST
56183: LIST
56184: PPUSH
56185: CALL_OW 72
56189: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
56190: LD_ADDR_VAR 0 6
56194: PUSH
56195: LD_EXP 23
56199: PUSH
56200: LD_VAR 0 2
56204: ARRAY
56205: PPUSH
56206: LD_INT 21
56208: PUSH
56209: LD_INT 1
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: PUSH
56216: LD_INT 1
56218: PUSH
56219: LD_INT 3
56221: PUSH
56222: LD_INT 54
56224: PUSH
56225: EMPTY
56226: LIST
56227: PUSH
56228: EMPTY
56229: LIST
56230: LIST
56231: PUSH
56232: LD_INT 3
56234: PUSH
56235: LD_INT 24
56237: PUSH
56238: LD_INT 250
56240: PUSH
56241: EMPTY
56242: LIST
56243: LIST
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: PUSH
56254: EMPTY
56255: LIST
56256: LIST
56257: PPUSH
56258: CALL_OW 72
56262: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
56263: LD_ADDR_VAR 0 7
56267: PUSH
56268: LD_VAR 0 5
56272: PUSH
56273: LD_VAR 0 6
56277: DIFF
56278: ST_TO_ADDR
// if not need_heal_1 then
56279: LD_VAR 0 6
56283: NOT
56284: IFFALSE 56317
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
56286: LD_ADDR_EXP 26
56290: PUSH
56291: LD_EXP 26
56295: PPUSH
56296: LD_VAR 0 2
56300: PUSH
56301: LD_INT 1
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PPUSH
56308: EMPTY
56309: PPUSH
56310: CALL 14060 0 3
56314: ST_TO_ADDR
56315: GO 56387
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
56317: LD_ADDR_EXP 26
56321: PUSH
56322: LD_EXP 26
56326: PPUSH
56327: LD_VAR 0 2
56331: PUSH
56332: LD_INT 1
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: PPUSH
56339: LD_EXP 26
56343: PUSH
56344: LD_VAR 0 2
56348: ARRAY
56349: PUSH
56350: LD_INT 1
56352: ARRAY
56353: PPUSH
56354: LD_INT 3
56356: PUSH
56357: LD_INT 24
56359: PUSH
56360: LD_INT 1000
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: PPUSH
56371: CALL_OW 72
56375: PUSH
56376: LD_VAR 0 6
56380: UNION
56381: PPUSH
56382: CALL 14060 0 3
56386: ST_TO_ADDR
// if not need_heal_2 then
56387: LD_VAR 0 7
56391: NOT
56392: IFFALSE 56425
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
56394: LD_ADDR_EXP 26
56398: PUSH
56399: LD_EXP 26
56403: PPUSH
56404: LD_VAR 0 2
56408: PUSH
56409: LD_INT 2
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PPUSH
56416: EMPTY
56417: PPUSH
56418: CALL 14060 0 3
56422: ST_TO_ADDR
56423: GO 56457
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
56425: LD_ADDR_EXP 26
56429: PUSH
56430: LD_EXP 26
56434: PPUSH
56435: LD_VAR 0 2
56439: PUSH
56440: LD_INT 2
56442: PUSH
56443: EMPTY
56444: LIST
56445: LIST
56446: PPUSH
56447: LD_VAR 0 7
56451: PPUSH
56452: CALL 14060 0 3
56456: ST_TO_ADDR
// if need_heal_2 then
56457: LD_VAR 0 7
56461: IFFALSE 56622
// for j in need_heal_2 do
56463: LD_ADDR_VAR 0 3
56467: PUSH
56468: LD_VAR 0 7
56472: PUSH
56473: FOR_IN
56474: IFFALSE 56620
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56476: LD_ADDR_VAR 0 5
56480: PUSH
56481: LD_EXP 23
56485: PUSH
56486: LD_VAR 0 2
56490: ARRAY
56491: PPUSH
56492: LD_INT 2
56494: PUSH
56495: LD_INT 30
56497: PUSH
56498: LD_INT 6
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: PUSH
56505: LD_INT 30
56507: PUSH
56508: LD_INT 7
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: LD_INT 30
56517: PUSH
56518: LD_INT 8
56520: PUSH
56521: EMPTY
56522: LIST
56523: LIST
56524: PUSH
56525: LD_INT 30
56527: PUSH
56528: LD_INT 0
56530: PUSH
56531: EMPTY
56532: LIST
56533: LIST
56534: PUSH
56535: LD_INT 30
56537: PUSH
56538: LD_INT 1
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: PUSH
56545: EMPTY
56546: LIST
56547: LIST
56548: LIST
56549: LIST
56550: LIST
56551: LIST
56552: PPUSH
56553: CALL_OW 72
56557: ST_TO_ADDR
// if tmp then
56558: LD_VAR 0 5
56562: IFFALSE 56618
// begin k := NearestUnitToUnit ( tmp , j ) ;
56564: LD_ADDR_VAR 0 4
56568: PUSH
56569: LD_VAR 0 5
56573: PPUSH
56574: LD_VAR 0 3
56578: PPUSH
56579: CALL_OW 74
56583: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
56584: LD_VAR 0 3
56588: PPUSH
56589: LD_VAR 0 4
56593: PPUSH
56594: CALL_OW 296
56598: PUSH
56599: LD_INT 5
56601: GREATER
56602: IFFALSE 56618
// ComMoveToNearbyEntrance ( j , k ) ;
56604: LD_VAR 0 3
56608: PPUSH
56609: LD_VAR 0 4
56613: PPUSH
56614: CALL 46679 0 2
// end ; end ;
56618: GO 56473
56620: POP
56621: POP
// if not need_heal_1 and not need_heal_2 then
56622: LD_VAR 0 6
56626: NOT
56627: PUSH
56628: LD_VAR 0 7
56632: NOT
56633: AND
56634: IFFALSE 56638
// continue ;
56636: GO 56102
// end ;
56638: GO 56102
56640: POP
56641: POP
// RaiseSailEvent ( 102 ) ;
56642: LD_INT 102
56644: PPUSH
56645: CALL_OW 427
// end ;
56649: LD_VAR 0 1
56653: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
56654: LD_INT 0
56656: PPUSH
56657: PPUSH
56658: PPUSH
56659: PPUSH
56660: PPUSH
56661: PPUSH
56662: PPUSH
56663: PPUSH
// if not mc_bases then
56664: LD_EXP 23
56668: NOT
56669: IFFALSE 56673
// exit ;
56671: GO 57534
// for i = 1 to mc_bases do
56673: LD_ADDR_VAR 0 2
56677: PUSH
56678: DOUBLE
56679: LD_INT 1
56681: DEC
56682: ST_TO_ADDR
56683: LD_EXP 23
56687: PUSH
56688: FOR_TO
56689: IFFALSE 57532
// begin if not mc_building_need_repair [ i ] then
56691: LD_EXP 24
56695: PUSH
56696: LD_VAR 0 2
56700: ARRAY
56701: NOT
56702: IFFALSE 56889
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
56704: LD_ADDR_VAR 0 6
56708: PUSH
56709: LD_EXP 42
56713: PUSH
56714: LD_VAR 0 2
56718: ARRAY
56719: PPUSH
56720: LD_INT 3
56722: PUSH
56723: LD_INT 24
56725: PUSH
56726: LD_INT 1000
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: PUSH
56737: LD_INT 2
56739: PUSH
56740: LD_INT 34
56742: PUSH
56743: LD_INT 13
56745: PUSH
56746: EMPTY
56747: LIST
56748: LIST
56749: PUSH
56750: LD_INT 34
56752: PUSH
56753: LD_INT 52
56755: PUSH
56756: EMPTY
56757: LIST
56758: LIST
56759: PUSH
56760: LD_INT 34
56762: PUSH
56763: LD_EXP 73
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: EMPTY
56773: LIST
56774: LIST
56775: LIST
56776: LIST
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: PPUSH
56782: CALL_OW 72
56786: ST_TO_ADDR
// if cranes then
56787: LD_VAR 0 6
56791: IFFALSE 56853
// for j in cranes do
56793: LD_ADDR_VAR 0 3
56797: PUSH
56798: LD_VAR 0 6
56802: PUSH
56803: FOR_IN
56804: IFFALSE 56851
// if not IsInArea ( j , mc_parking [ i ] ) then
56806: LD_VAR 0 3
56810: PPUSH
56811: LD_EXP 47
56815: PUSH
56816: LD_VAR 0 2
56820: ARRAY
56821: PPUSH
56822: CALL_OW 308
56826: NOT
56827: IFFALSE 56849
// ComMoveToArea ( j , mc_parking [ i ] ) ;
56829: LD_VAR 0 3
56833: PPUSH
56834: LD_EXP 47
56838: PUSH
56839: LD_VAR 0 2
56843: ARRAY
56844: PPUSH
56845: CALL_OW 113
56849: GO 56803
56851: POP
56852: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56853: LD_ADDR_EXP 25
56857: PUSH
56858: LD_EXP 25
56862: PPUSH
56863: LD_VAR 0 2
56867: PPUSH
56868: EMPTY
56869: PPUSH
56870: CALL_OW 1
56874: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
56875: LD_VAR 0 2
56879: PPUSH
56880: LD_INT 101
56882: PPUSH
56883: CALL 51777 0 2
// continue ;
56887: GO 56688
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
56889: LD_ADDR_EXP 29
56893: PUSH
56894: LD_EXP 29
56898: PPUSH
56899: LD_VAR 0 2
56903: PPUSH
56904: EMPTY
56905: PPUSH
56906: CALL_OW 1
56910: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
56911: LD_VAR 0 2
56915: PPUSH
56916: LD_INT 103
56918: PPUSH
56919: CALL 51777 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
56923: LD_ADDR_VAR 0 5
56927: PUSH
56928: LD_EXP 23
56932: PUSH
56933: LD_VAR 0 2
56937: ARRAY
56938: PUSH
56939: LD_EXP 52
56943: PUSH
56944: LD_VAR 0 2
56948: ARRAY
56949: UNION
56950: PPUSH
56951: LD_INT 2
56953: PUSH
56954: LD_INT 25
56956: PUSH
56957: LD_INT 2
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: PUSH
56964: LD_INT 25
56966: PUSH
56967: LD_INT 16
56969: PUSH
56970: EMPTY
56971: LIST
56972: LIST
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: LIST
56978: PUSH
56979: EMPTY
56980: LIST
56981: PPUSH
56982: CALL_OW 72
56986: PUSH
56987: LD_EXP 26
56991: PUSH
56992: LD_VAR 0 2
56996: ARRAY
56997: PUSH
56998: LD_INT 1
57000: ARRAY
57001: PUSH
57002: LD_EXP 26
57006: PUSH
57007: LD_VAR 0 2
57011: ARRAY
57012: PUSH
57013: LD_INT 2
57015: ARRAY
57016: UNION
57017: DIFF
57018: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
57019: LD_ADDR_VAR 0 6
57023: PUSH
57024: LD_EXP 42
57028: PUSH
57029: LD_VAR 0 2
57033: ARRAY
57034: PPUSH
57035: LD_INT 2
57037: PUSH
57038: LD_INT 34
57040: PUSH
57041: LD_INT 13
57043: PUSH
57044: EMPTY
57045: LIST
57046: LIST
57047: PUSH
57048: LD_INT 34
57050: PUSH
57051: LD_INT 52
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: PUSH
57058: LD_INT 34
57060: PUSH
57061: LD_EXP 73
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PUSH
57070: EMPTY
57071: LIST
57072: LIST
57073: LIST
57074: LIST
57075: PPUSH
57076: CALL_OW 72
57080: ST_TO_ADDR
// if cranes then
57081: LD_VAR 0 6
57085: IFFALSE 57221
// begin for j in cranes do
57087: LD_ADDR_VAR 0 3
57091: PUSH
57092: LD_VAR 0 6
57096: PUSH
57097: FOR_IN
57098: IFFALSE 57219
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
57100: LD_VAR 0 3
57104: PPUSH
57105: CALL_OW 256
57109: PUSH
57110: LD_INT 1000
57112: EQUAL
57113: PUSH
57114: LD_VAR 0 3
57118: PPUSH
57119: CALL_OW 314
57123: NOT
57124: AND
57125: IFFALSE 57159
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
57127: LD_VAR 0 3
57131: PPUSH
57132: LD_EXP 24
57136: PUSH
57137: LD_VAR 0 2
57141: ARRAY
57142: PPUSH
57143: LD_VAR 0 3
57147: PPUSH
57148: CALL_OW 74
57152: PPUSH
57153: CALL_OW 130
57157: GO 57217
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
57159: LD_VAR 0 3
57163: PPUSH
57164: CALL_OW 256
57168: PUSH
57169: LD_INT 500
57171: LESS
57172: PUSH
57173: LD_VAR 0 3
57177: PPUSH
57178: LD_EXP 47
57182: PUSH
57183: LD_VAR 0 2
57187: ARRAY
57188: PPUSH
57189: CALL_OW 308
57193: NOT
57194: AND
57195: IFFALSE 57217
// ComMoveToArea ( j , mc_parking [ i ] ) ;
57197: LD_VAR 0 3
57201: PPUSH
57202: LD_EXP 47
57206: PUSH
57207: LD_VAR 0 2
57211: ARRAY
57212: PPUSH
57213: CALL_OW 113
// end ;
57217: GO 57097
57219: POP
57220: POP
// end ; if tmp > 3 then
57221: LD_VAR 0 5
57225: PUSH
57226: LD_INT 3
57228: GREATER
57229: IFFALSE 57249
// tmp := ShrinkArray ( tmp , 4 ) ;
57231: LD_ADDR_VAR 0 5
57235: PUSH
57236: LD_VAR 0 5
57240: PPUSH
57241: LD_INT 4
57243: PPUSH
57244: CALL 46127 0 2
57248: ST_TO_ADDR
// if not tmp then
57249: LD_VAR 0 5
57253: NOT
57254: IFFALSE 57258
// continue ;
57256: GO 56688
// for j in tmp do
57258: LD_ADDR_VAR 0 3
57262: PUSH
57263: LD_VAR 0 5
57267: PUSH
57268: FOR_IN
57269: IFFALSE 57528
// begin if IsInUnit ( j ) then
57271: LD_VAR 0 3
57275: PPUSH
57276: CALL_OW 310
57280: IFFALSE 57291
// ComExitBuilding ( j ) ;
57282: LD_VAR 0 3
57286: PPUSH
57287: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
57291: LD_VAR 0 3
57295: PUSH
57296: LD_EXP 25
57300: PUSH
57301: LD_VAR 0 2
57305: ARRAY
57306: IN
57307: NOT
57308: IFFALSE 57366
// begin SetTag ( j , 101 ) ;
57310: LD_VAR 0 3
57314: PPUSH
57315: LD_INT 101
57317: PPUSH
57318: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
57322: LD_ADDR_EXP 25
57326: PUSH
57327: LD_EXP 25
57331: PPUSH
57332: LD_VAR 0 2
57336: PUSH
57337: LD_EXP 25
57341: PUSH
57342: LD_VAR 0 2
57346: ARRAY
57347: PUSH
57348: LD_INT 1
57350: PLUS
57351: PUSH
57352: EMPTY
57353: LIST
57354: LIST
57355: PPUSH
57356: LD_VAR 0 3
57360: PPUSH
57361: CALL 14060 0 3
57365: ST_TO_ADDR
// end ; wait ( 1 ) ;
57366: LD_INT 1
57368: PPUSH
57369: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
57373: LD_ADDR_VAR 0 7
57377: PUSH
57378: LD_EXP 24
57382: PUSH
57383: LD_VAR 0 2
57387: ARRAY
57388: ST_TO_ADDR
// if mc_scan [ i ] then
57389: LD_EXP 46
57393: PUSH
57394: LD_VAR 0 2
57398: ARRAY
57399: IFFALSE 57461
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
57401: LD_ADDR_VAR 0 7
57405: PUSH
57406: LD_EXP 24
57410: PUSH
57411: LD_VAR 0 2
57415: ARRAY
57416: PPUSH
57417: LD_INT 3
57419: PUSH
57420: LD_INT 30
57422: PUSH
57423: LD_INT 32
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: PUSH
57430: LD_INT 30
57432: PUSH
57433: LD_INT 33
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: PUSH
57440: LD_INT 30
57442: PUSH
57443: LD_INT 31
57445: PUSH
57446: EMPTY
57447: LIST
57448: LIST
57449: PUSH
57450: EMPTY
57451: LIST
57452: LIST
57453: LIST
57454: LIST
57455: PPUSH
57456: CALL_OW 72
57460: ST_TO_ADDR
// if not to_repair_tmp then
57461: LD_VAR 0 7
57465: NOT
57466: IFFALSE 57470
// continue ;
57468: GO 57268
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
57470: LD_ADDR_VAR 0 8
57474: PUSH
57475: LD_VAR 0 7
57479: PPUSH
57480: LD_VAR 0 3
57484: PPUSH
57485: CALL_OW 74
57489: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
57490: LD_VAR 0 8
57494: PPUSH
57495: LD_INT 16
57497: PPUSH
57498: CALL 16659 0 2
57502: PUSH
57503: LD_INT 4
57505: ARRAY
57506: PUSH
57507: LD_INT 10
57509: LESS
57510: IFFALSE 57526
// ComRepairBuilding ( j , to_repair ) ;
57512: LD_VAR 0 3
57516: PPUSH
57517: LD_VAR 0 8
57521: PPUSH
57522: CALL_OW 130
// end ;
57526: GO 57268
57528: POP
57529: POP
// end ;
57530: GO 56688
57532: POP
57533: POP
// end ;
57534: LD_VAR 0 1
57538: RET
// export function MC_Heal ; var i , j , tmp ; begin
57539: LD_INT 0
57541: PPUSH
57542: PPUSH
57543: PPUSH
57544: PPUSH
// if not mc_bases then
57545: LD_EXP 23
57549: NOT
57550: IFFALSE 57554
// exit ;
57552: GO 57956
// for i = 1 to mc_bases do
57554: LD_ADDR_VAR 0 2
57558: PUSH
57559: DOUBLE
57560: LD_INT 1
57562: DEC
57563: ST_TO_ADDR
57564: LD_EXP 23
57568: PUSH
57569: FOR_TO
57570: IFFALSE 57954
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
57572: LD_EXP 26
57576: PUSH
57577: LD_VAR 0 2
57581: ARRAY
57582: PUSH
57583: LD_INT 1
57585: ARRAY
57586: NOT
57587: PUSH
57588: LD_EXP 26
57592: PUSH
57593: LD_VAR 0 2
57597: ARRAY
57598: PUSH
57599: LD_INT 2
57601: ARRAY
57602: NOT
57603: AND
57604: IFFALSE 57642
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
57606: LD_ADDR_EXP 27
57610: PUSH
57611: LD_EXP 27
57615: PPUSH
57616: LD_VAR 0 2
57620: PPUSH
57621: EMPTY
57622: PPUSH
57623: CALL_OW 1
57627: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
57628: LD_VAR 0 2
57632: PPUSH
57633: LD_INT 102
57635: PPUSH
57636: CALL 51777 0 2
// continue ;
57640: GO 57569
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
57642: LD_ADDR_VAR 0 4
57646: PUSH
57647: LD_EXP 23
57651: PUSH
57652: LD_VAR 0 2
57656: ARRAY
57657: PPUSH
57658: LD_INT 25
57660: PUSH
57661: LD_INT 4
57663: PUSH
57664: EMPTY
57665: LIST
57666: LIST
57667: PPUSH
57668: CALL_OW 72
57672: ST_TO_ADDR
// if not tmp then
57673: LD_VAR 0 4
57677: NOT
57678: IFFALSE 57682
// continue ;
57680: GO 57569
// if mc_taming [ i ] then
57682: LD_EXP 54
57686: PUSH
57687: LD_VAR 0 2
57691: ARRAY
57692: IFFALSE 57716
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57694: LD_ADDR_EXP 54
57698: PUSH
57699: LD_EXP 54
57703: PPUSH
57704: LD_VAR 0 2
57708: PPUSH
57709: EMPTY
57710: PPUSH
57711: CALL_OW 1
57715: ST_TO_ADDR
// for j in tmp do
57716: LD_ADDR_VAR 0 3
57720: PUSH
57721: LD_VAR 0 4
57725: PUSH
57726: FOR_IN
57727: IFFALSE 57950
// begin if IsInUnit ( j ) then
57729: LD_VAR 0 3
57733: PPUSH
57734: CALL_OW 310
57738: IFFALSE 57749
// ComExitBuilding ( j ) ;
57740: LD_VAR 0 3
57744: PPUSH
57745: CALL_OW 122
// if not j in mc_healers [ i ] then
57749: LD_VAR 0 3
57753: PUSH
57754: LD_EXP 27
57758: PUSH
57759: LD_VAR 0 2
57763: ARRAY
57764: IN
57765: NOT
57766: IFFALSE 57812
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
57768: LD_ADDR_EXP 27
57772: PUSH
57773: LD_EXP 27
57777: PPUSH
57778: LD_VAR 0 2
57782: PUSH
57783: LD_EXP 27
57787: PUSH
57788: LD_VAR 0 2
57792: ARRAY
57793: PUSH
57794: LD_INT 1
57796: PLUS
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: PPUSH
57802: LD_VAR 0 3
57806: PPUSH
57807: CALL 14060 0 3
57811: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
57812: LD_VAR 0 3
57816: PPUSH
57817: CALL_OW 110
57821: PUSH
57822: LD_INT 102
57824: NONEQUAL
57825: IFFALSE 57839
// SetTag ( j , 102 ) ;
57827: LD_VAR 0 3
57831: PPUSH
57832: LD_INT 102
57834: PPUSH
57835: CALL_OW 109
// Wait ( 3 ) ;
57839: LD_INT 3
57841: PPUSH
57842: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
57846: LD_EXP 26
57850: PUSH
57851: LD_VAR 0 2
57855: ARRAY
57856: PUSH
57857: LD_INT 1
57859: ARRAY
57860: IFFALSE 57892
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
57862: LD_VAR 0 3
57866: PPUSH
57867: LD_EXP 26
57871: PUSH
57872: LD_VAR 0 2
57876: ARRAY
57877: PUSH
57878: LD_INT 1
57880: ARRAY
57881: PUSH
57882: LD_INT 1
57884: ARRAY
57885: PPUSH
57886: CALL_OW 128
57890: GO 57948
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
57892: LD_VAR 0 3
57896: PPUSH
57897: CALL_OW 314
57901: NOT
57902: PUSH
57903: LD_EXP 26
57907: PUSH
57908: LD_VAR 0 2
57912: ARRAY
57913: PUSH
57914: LD_INT 2
57916: ARRAY
57917: AND
57918: IFFALSE 57948
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
57920: LD_VAR 0 3
57924: PPUSH
57925: LD_EXP 26
57929: PUSH
57930: LD_VAR 0 2
57934: ARRAY
57935: PUSH
57936: LD_INT 2
57938: ARRAY
57939: PUSH
57940: LD_INT 1
57942: ARRAY
57943: PPUSH
57944: CALL_OW 128
// end ;
57948: GO 57726
57950: POP
57951: POP
// end ;
57952: GO 57569
57954: POP
57955: POP
// end ;
57956: LD_VAR 0 1
57960: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
57961: LD_INT 0
57963: PPUSH
57964: PPUSH
57965: PPUSH
57966: PPUSH
57967: PPUSH
// if not mc_bases then
57968: LD_EXP 23
57972: NOT
57973: IFFALSE 57977
// exit ;
57975: GO 59148
// for i = 1 to mc_bases do
57977: LD_ADDR_VAR 0 2
57981: PUSH
57982: DOUBLE
57983: LD_INT 1
57985: DEC
57986: ST_TO_ADDR
57987: LD_EXP 23
57991: PUSH
57992: FOR_TO
57993: IFFALSE 59146
// begin if mc_scan [ i ] then
57995: LD_EXP 46
57999: PUSH
58000: LD_VAR 0 2
58004: ARRAY
58005: IFFALSE 58009
// continue ;
58007: GO 57992
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
58009: LD_EXP 28
58013: PUSH
58014: LD_VAR 0 2
58018: ARRAY
58019: NOT
58020: PUSH
58021: LD_EXP 30
58025: PUSH
58026: LD_VAR 0 2
58030: ARRAY
58031: NOT
58032: AND
58033: PUSH
58034: LD_EXP 29
58038: PUSH
58039: LD_VAR 0 2
58043: ARRAY
58044: AND
58045: IFFALSE 58083
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
58047: LD_ADDR_EXP 29
58051: PUSH
58052: LD_EXP 29
58056: PPUSH
58057: LD_VAR 0 2
58061: PPUSH
58062: EMPTY
58063: PPUSH
58064: CALL_OW 1
58068: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
58069: LD_VAR 0 2
58073: PPUSH
58074: LD_INT 103
58076: PPUSH
58077: CALL 51777 0 2
// continue ;
58081: GO 57992
// end ; if mc_construct_list [ i ] then
58083: LD_EXP 30
58087: PUSH
58088: LD_VAR 0 2
58092: ARRAY
58093: IFFALSE 58313
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58095: LD_ADDR_VAR 0 4
58099: PUSH
58100: LD_EXP 23
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: PPUSH
58111: LD_INT 25
58113: PUSH
58114: LD_INT 2
58116: PUSH
58117: EMPTY
58118: LIST
58119: LIST
58120: PPUSH
58121: CALL_OW 72
58125: PUSH
58126: LD_EXP 25
58130: PUSH
58131: LD_VAR 0 2
58135: ARRAY
58136: DIFF
58137: ST_TO_ADDR
// if not tmp then
58138: LD_VAR 0 4
58142: NOT
58143: IFFALSE 58147
// continue ;
58145: GO 57992
// for j in tmp do
58147: LD_ADDR_VAR 0 3
58151: PUSH
58152: LD_VAR 0 4
58156: PUSH
58157: FOR_IN
58158: IFFALSE 58309
// begin if not mc_builders [ i ] then
58160: LD_EXP 29
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: NOT
58171: IFFALSE 58229
// begin SetTag ( j , 103 ) ;
58173: LD_VAR 0 3
58177: PPUSH
58178: LD_INT 103
58180: PPUSH
58181: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58185: LD_ADDR_EXP 29
58189: PUSH
58190: LD_EXP 29
58194: PPUSH
58195: LD_VAR 0 2
58199: PUSH
58200: LD_EXP 29
58204: PUSH
58205: LD_VAR 0 2
58209: ARRAY
58210: PUSH
58211: LD_INT 1
58213: PLUS
58214: PUSH
58215: EMPTY
58216: LIST
58217: LIST
58218: PPUSH
58219: LD_VAR 0 3
58223: PPUSH
58224: CALL 14060 0 3
58228: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58229: LD_VAR 0 3
58233: PPUSH
58234: CALL_OW 310
58238: IFFALSE 58249
// ComExitBuilding ( j ) ;
58240: LD_VAR 0 3
58244: PPUSH
58245: CALL_OW 122
// wait ( 3 ) ;
58249: LD_INT 3
58251: PPUSH
58252: CALL_OW 67
// if not mc_construct_list [ i ] then
58256: LD_EXP 30
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: NOT
58267: IFFALSE 58271
// break ;
58269: GO 58309
// if not HasTask ( j ) then
58271: LD_VAR 0 3
58275: PPUSH
58276: CALL_OW 314
58280: NOT
58281: IFFALSE 58307
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
58283: LD_VAR 0 3
58287: PPUSH
58288: LD_EXP 30
58292: PUSH
58293: LD_VAR 0 2
58297: ARRAY
58298: PUSH
58299: LD_INT 1
58301: ARRAY
58302: PPUSH
58303: CALL 16923 0 2
// end ;
58307: GO 58157
58309: POP
58310: POP
// end else
58311: GO 59144
// if mc_build_list [ i ] then
58313: LD_EXP 28
58317: PUSH
58318: LD_VAR 0 2
58322: ARRAY
58323: IFFALSE 59144
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58325: LD_ADDR_VAR 0 5
58329: PUSH
58330: LD_EXP 23
58334: PUSH
58335: LD_VAR 0 2
58339: ARRAY
58340: PPUSH
58341: LD_INT 2
58343: PUSH
58344: LD_INT 30
58346: PUSH
58347: LD_INT 0
58349: PUSH
58350: EMPTY
58351: LIST
58352: LIST
58353: PUSH
58354: LD_INT 30
58356: PUSH
58357: LD_INT 1
58359: PUSH
58360: EMPTY
58361: LIST
58362: LIST
58363: PUSH
58364: EMPTY
58365: LIST
58366: LIST
58367: LIST
58368: PPUSH
58369: CALL_OW 72
58373: ST_TO_ADDR
// if depot then
58374: LD_VAR 0 5
58378: IFFALSE 58396
// depot := depot [ 1 ] else
58380: LD_ADDR_VAR 0 5
58384: PUSH
58385: LD_VAR 0 5
58389: PUSH
58390: LD_INT 1
58392: ARRAY
58393: ST_TO_ADDR
58394: GO 58404
// depot := 0 ;
58396: LD_ADDR_VAR 0 5
58400: PUSH
58401: LD_INT 0
58403: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
58404: LD_EXP 28
58408: PUSH
58409: LD_VAR 0 2
58413: ARRAY
58414: PUSH
58415: LD_INT 1
58417: ARRAY
58418: PUSH
58419: LD_INT 1
58421: ARRAY
58422: PPUSH
58423: CALL 16747 0 1
58427: PUSH
58428: LD_EXP 23
58432: PUSH
58433: LD_VAR 0 2
58437: ARRAY
58438: PPUSH
58439: LD_INT 2
58441: PUSH
58442: LD_INT 30
58444: PUSH
58445: LD_INT 2
58447: PUSH
58448: EMPTY
58449: LIST
58450: LIST
58451: PUSH
58452: LD_INT 30
58454: PUSH
58455: LD_INT 3
58457: PUSH
58458: EMPTY
58459: LIST
58460: LIST
58461: PUSH
58462: EMPTY
58463: LIST
58464: LIST
58465: LIST
58466: PPUSH
58467: CALL_OW 72
58471: NOT
58472: AND
58473: IFFALSE 58578
// begin for j = 1 to mc_build_list [ i ] do
58475: LD_ADDR_VAR 0 3
58479: PUSH
58480: DOUBLE
58481: LD_INT 1
58483: DEC
58484: ST_TO_ADDR
58485: LD_EXP 28
58489: PUSH
58490: LD_VAR 0 2
58494: ARRAY
58495: PUSH
58496: FOR_TO
58497: IFFALSE 58576
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
58499: LD_EXP 28
58503: PUSH
58504: LD_VAR 0 2
58508: ARRAY
58509: PUSH
58510: LD_VAR 0 3
58514: ARRAY
58515: PUSH
58516: LD_INT 1
58518: ARRAY
58519: PUSH
58520: LD_INT 2
58522: EQUAL
58523: IFFALSE 58574
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
58525: LD_ADDR_EXP 28
58529: PUSH
58530: LD_EXP 28
58534: PPUSH
58535: LD_VAR 0 2
58539: PPUSH
58540: LD_EXP 28
58544: PUSH
58545: LD_VAR 0 2
58549: ARRAY
58550: PPUSH
58551: LD_VAR 0 3
58555: PPUSH
58556: LD_INT 1
58558: PPUSH
58559: LD_INT 0
58561: PPUSH
58562: CALL 13478 0 4
58566: PPUSH
58567: CALL_OW 1
58571: ST_TO_ADDR
// break ;
58572: GO 58576
// end ;
58574: GO 58496
58576: POP
58577: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
58578: LD_EXP 28
58582: PUSH
58583: LD_VAR 0 2
58587: ARRAY
58588: PUSH
58589: LD_INT 1
58591: ARRAY
58592: PUSH
58593: LD_INT 1
58595: ARRAY
58596: PUSH
58597: LD_INT 0
58599: EQUAL
58600: PUSH
58601: LD_VAR 0 5
58605: PUSH
58606: LD_VAR 0 5
58610: PPUSH
58611: LD_EXP 28
58615: PUSH
58616: LD_VAR 0 2
58620: ARRAY
58621: PUSH
58622: LD_INT 1
58624: ARRAY
58625: PUSH
58626: LD_INT 1
58628: ARRAY
58629: PPUSH
58630: LD_EXP 28
58634: PUSH
58635: LD_VAR 0 2
58639: ARRAY
58640: PUSH
58641: LD_INT 1
58643: ARRAY
58644: PUSH
58645: LD_INT 2
58647: ARRAY
58648: PPUSH
58649: LD_EXP 28
58653: PUSH
58654: LD_VAR 0 2
58658: ARRAY
58659: PUSH
58660: LD_INT 1
58662: ARRAY
58663: PUSH
58664: LD_INT 3
58666: ARRAY
58667: PPUSH
58668: LD_EXP 28
58672: PUSH
58673: LD_VAR 0 2
58677: ARRAY
58678: PUSH
58679: LD_INT 1
58681: ARRAY
58682: PUSH
58683: LD_INT 4
58685: ARRAY
58686: PPUSH
58687: CALL 22164 0 5
58691: AND
58692: OR
58693: IFFALSE 58974
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
58695: LD_ADDR_VAR 0 4
58699: PUSH
58700: LD_EXP 23
58704: PUSH
58705: LD_VAR 0 2
58709: ARRAY
58710: PPUSH
58711: LD_INT 25
58713: PUSH
58714: LD_INT 2
58716: PUSH
58717: EMPTY
58718: LIST
58719: LIST
58720: PPUSH
58721: CALL_OW 72
58725: PUSH
58726: LD_EXP 25
58730: PUSH
58731: LD_VAR 0 2
58735: ARRAY
58736: DIFF
58737: ST_TO_ADDR
// if not tmp then
58738: LD_VAR 0 4
58742: NOT
58743: IFFALSE 58747
// continue ;
58745: GO 57992
// for j in tmp do
58747: LD_ADDR_VAR 0 3
58751: PUSH
58752: LD_VAR 0 4
58756: PUSH
58757: FOR_IN
58758: IFFALSE 58970
// begin if not mc_builders [ i ] then
58760: LD_EXP 29
58764: PUSH
58765: LD_VAR 0 2
58769: ARRAY
58770: NOT
58771: IFFALSE 58829
// begin SetTag ( j , 103 ) ;
58773: LD_VAR 0 3
58777: PPUSH
58778: LD_INT 103
58780: PPUSH
58781: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
58785: LD_ADDR_EXP 29
58789: PUSH
58790: LD_EXP 29
58794: PPUSH
58795: LD_VAR 0 2
58799: PUSH
58800: LD_EXP 29
58804: PUSH
58805: LD_VAR 0 2
58809: ARRAY
58810: PUSH
58811: LD_INT 1
58813: PLUS
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PPUSH
58819: LD_VAR 0 3
58823: PPUSH
58824: CALL 14060 0 3
58828: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
58829: LD_VAR 0 3
58833: PPUSH
58834: CALL_OW 310
58838: IFFALSE 58849
// ComExitBuilding ( j ) ;
58840: LD_VAR 0 3
58844: PPUSH
58845: CALL_OW 122
// wait ( 3 ) ;
58849: LD_INT 3
58851: PPUSH
58852: CALL_OW 67
// if not mc_build_list [ i ] then
58856: LD_EXP 28
58860: PUSH
58861: LD_VAR 0 2
58865: ARRAY
58866: NOT
58867: IFFALSE 58871
// break ;
58869: GO 58970
// if not HasTask ( j ) then
58871: LD_VAR 0 3
58875: PPUSH
58876: CALL_OW 314
58880: NOT
58881: IFFALSE 58968
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
58883: LD_VAR 0 3
58887: PPUSH
58888: LD_EXP 28
58892: PUSH
58893: LD_VAR 0 2
58897: ARRAY
58898: PUSH
58899: LD_INT 1
58901: ARRAY
58902: PUSH
58903: LD_INT 1
58905: ARRAY
58906: PPUSH
58907: LD_EXP 28
58911: PUSH
58912: LD_VAR 0 2
58916: ARRAY
58917: PUSH
58918: LD_INT 1
58920: ARRAY
58921: PUSH
58922: LD_INT 2
58924: ARRAY
58925: PPUSH
58926: LD_EXP 28
58930: PUSH
58931: LD_VAR 0 2
58935: ARRAY
58936: PUSH
58937: LD_INT 1
58939: ARRAY
58940: PUSH
58941: LD_INT 3
58943: ARRAY
58944: PPUSH
58945: LD_EXP 28
58949: PUSH
58950: LD_VAR 0 2
58954: ARRAY
58955: PUSH
58956: LD_INT 1
58958: ARRAY
58959: PUSH
58960: LD_INT 4
58962: ARRAY
58963: PPUSH
58964: CALL_OW 145
// end ;
58968: GO 58757
58970: POP
58971: POP
// end else
58972: GO 59144
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
58974: LD_EXP 23
58978: PUSH
58979: LD_VAR 0 2
58983: ARRAY
58984: PPUSH
58985: LD_EXP 28
58989: PUSH
58990: LD_VAR 0 2
58994: ARRAY
58995: PUSH
58996: LD_INT 1
58998: ARRAY
58999: PUSH
59000: LD_INT 1
59002: ARRAY
59003: PPUSH
59004: LD_EXP 28
59008: PUSH
59009: LD_VAR 0 2
59013: ARRAY
59014: PUSH
59015: LD_INT 1
59017: ARRAY
59018: PUSH
59019: LD_INT 2
59021: ARRAY
59022: PPUSH
59023: LD_EXP 28
59027: PUSH
59028: LD_VAR 0 2
59032: ARRAY
59033: PUSH
59034: LD_INT 1
59036: ARRAY
59037: PUSH
59038: LD_INT 3
59040: ARRAY
59041: PPUSH
59042: LD_EXP 28
59046: PUSH
59047: LD_VAR 0 2
59051: ARRAY
59052: PUSH
59053: LD_INT 1
59055: ARRAY
59056: PUSH
59057: LD_INT 4
59059: ARRAY
59060: PPUSH
59061: LD_EXP 23
59065: PUSH
59066: LD_VAR 0 2
59070: ARRAY
59071: PPUSH
59072: LD_INT 21
59074: PUSH
59075: LD_INT 3
59077: PUSH
59078: EMPTY
59079: LIST
59080: LIST
59081: PPUSH
59082: CALL_OW 72
59086: PPUSH
59087: EMPTY
59088: PPUSH
59089: CALL 20914 0 7
59093: NOT
59094: IFFALSE 59144
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
59096: LD_ADDR_EXP 28
59100: PUSH
59101: LD_EXP 28
59105: PPUSH
59106: LD_VAR 0 2
59110: PPUSH
59111: LD_EXP 28
59115: PUSH
59116: LD_VAR 0 2
59120: ARRAY
59121: PPUSH
59122: LD_INT 1
59124: PPUSH
59125: LD_INT 1
59127: NEG
59128: PPUSH
59129: LD_INT 0
59131: PPUSH
59132: CALL 13478 0 4
59136: PPUSH
59137: CALL_OW 1
59141: ST_TO_ADDR
// continue ;
59142: GO 57992
// end ; end ; end ;
59144: GO 57992
59146: POP
59147: POP
// end ;
59148: LD_VAR 0 1
59152: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
59153: LD_INT 0
59155: PPUSH
59156: PPUSH
59157: PPUSH
59158: PPUSH
59159: PPUSH
59160: PPUSH
// if not mc_bases then
59161: LD_EXP 23
59165: NOT
59166: IFFALSE 59170
// exit ;
59168: GO 59597
// for i = 1 to mc_bases do
59170: LD_ADDR_VAR 0 2
59174: PUSH
59175: DOUBLE
59176: LD_INT 1
59178: DEC
59179: ST_TO_ADDR
59180: LD_EXP 23
59184: PUSH
59185: FOR_TO
59186: IFFALSE 59595
// begin tmp := mc_build_upgrade [ i ] ;
59188: LD_ADDR_VAR 0 4
59192: PUSH
59193: LD_EXP 55
59197: PUSH
59198: LD_VAR 0 2
59202: ARRAY
59203: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
59204: LD_ADDR_VAR 0 6
59208: PUSH
59209: LD_EXP 56
59213: PUSH
59214: LD_VAR 0 2
59218: ARRAY
59219: PPUSH
59220: LD_INT 2
59222: PUSH
59223: LD_INT 30
59225: PUSH
59226: LD_INT 6
59228: PUSH
59229: EMPTY
59230: LIST
59231: LIST
59232: PUSH
59233: LD_INT 30
59235: PUSH
59236: LD_INT 7
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: PUSH
59243: EMPTY
59244: LIST
59245: LIST
59246: LIST
59247: PPUSH
59248: CALL_OW 72
59252: ST_TO_ADDR
// if not tmp and not lab then
59253: LD_VAR 0 4
59257: NOT
59258: PUSH
59259: LD_VAR 0 6
59263: NOT
59264: AND
59265: IFFALSE 59269
// continue ;
59267: GO 59185
// if tmp then
59269: LD_VAR 0 4
59273: IFFALSE 59393
// for j in tmp do
59275: LD_ADDR_VAR 0 3
59279: PUSH
59280: LD_VAR 0 4
59284: PUSH
59285: FOR_IN
59286: IFFALSE 59391
// begin if UpgradeCost ( j ) then
59288: LD_VAR 0 3
59292: PPUSH
59293: CALL 20574 0 1
59297: IFFALSE 59389
// begin ComUpgrade ( j ) ;
59299: LD_VAR 0 3
59303: PPUSH
59304: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
59308: LD_ADDR_EXP 55
59312: PUSH
59313: LD_EXP 55
59317: PPUSH
59318: LD_VAR 0 2
59322: PPUSH
59323: LD_EXP 55
59327: PUSH
59328: LD_VAR 0 2
59332: ARRAY
59333: PUSH
59334: LD_VAR 0 3
59338: DIFF
59339: PPUSH
59340: CALL_OW 1
59344: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59345: LD_ADDR_EXP 30
59349: PUSH
59350: LD_EXP 30
59354: PPUSH
59355: LD_VAR 0 2
59359: PUSH
59360: LD_EXP 30
59364: PUSH
59365: LD_VAR 0 2
59369: ARRAY
59370: PUSH
59371: LD_INT 1
59373: PLUS
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: PPUSH
59379: LD_VAR 0 3
59383: PPUSH
59384: CALL 14060 0 3
59388: ST_TO_ADDR
// end ; end ;
59389: GO 59285
59391: POP
59392: POP
// if not lab or not mc_lab_upgrade [ i ] then
59393: LD_VAR 0 6
59397: NOT
59398: PUSH
59399: LD_EXP 57
59403: PUSH
59404: LD_VAR 0 2
59408: ARRAY
59409: NOT
59410: OR
59411: IFFALSE 59415
// continue ;
59413: GO 59185
// for j in lab do
59415: LD_ADDR_VAR 0 3
59419: PUSH
59420: LD_VAR 0 6
59424: PUSH
59425: FOR_IN
59426: IFFALSE 59591
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
59428: LD_VAR 0 3
59432: PPUSH
59433: CALL_OW 266
59437: PUSH
59438: LD_INT 6
59440: PUSH
59441: LD_INT 7
59443: PUSH
59444: EMPTY
59445: LIST
59446: LIST
59447: IN
59448: PUSH
59449: LD_VAR 0 3
59453: PPUSH
59454: CALL_OW 461
59458: PUSH
59459: LD_INT 1
59461: NONEQUAL
59462: AND
59463: IFFALSE 59589
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
59465: LD_VAR 0 3
59469: PPUSH
59470: LD_EXP 57
59474: PUSH
59475: LD_VAR 0 2
59479: ARRAY
59480: PUSH
59481: LD_INT 1
59483: ARRAY
59484: PPUSH
59485: CALL 20779 0 2
59489: IFFALSE 59589
// begin ComCancel ( j ) ;
59491: LD_VAR 0 3
59495: PPUSH
59496: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
59500: LD_VAR 0 3
59504: PPUSH
59505: LD_EXP 57
59509: PUSH
59510: LD_VAR 0 2
59514: ARRAY
59515: PUSH
59516: LD_INT 1
59518: ARRAY
59519: PPUSH
59520: CALL_OW 207
// if not j in mc_construct_list [ i ] then
59524: LD_VAR 0 3
59528: PUSH
59529: LD_EXP 30
59533: PUSH
59534: LD_VAR 0 2
59538: ARRAY
59539: IN
59540: NOT
59541: IFFALSE 59587
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
59543: LD_ADDR_EXP 30
59547: PUSH
59548: LD_EXP 30
59552: PPUSH
59553: LD_VAR 0 2
59557: PUSH
59558: LD_EXP 30
59562: PUSH
59563: LD_VAR 0 2
59567: ARRAY
59568: PUSH
59569: LD_INT 1
59571: PLUS
59572: PUSH
59573: EMPTY
59574: LIST
59575: LIST
59576: PPUSH
59577: LD_VAR 0 3
59581: PPUSH
59582: CALL 14060 0 3
59586: ST_TO_ADDR
// break ;
59587: GO 59591
// end ; end ; end ;
59589: GO 59425
59591: POP
59592: POP
// end ;
59593: GO 59185
59595: POP
59596: POP
// end ;
59597: LD_VAR 0 1
59601: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
59602: LD_INT 0
59604: PPUSH
59605: PPUSH
59606: PPUSH
59607: PPUSH
59608: PPUSH
59609: PPUSH
59610: PPUSH
59611: PPUSH
59612: PPUSH
// if not mc_bases then
59613: LD_EXP 23
59617: NOT
59618: IFFALSE 59622
// exit ;
59620: GO 60027
// for i = 1 to mc_bases do
59622: LD_ADDR_VAR 0 2
59626: PUSH
59627: DOUBLE
59628: LD_INT 1
59630: DEC
59631: ST_TO_ADDR
59632: LD_EXP 23
59636: PUSH
59637: FOR_TO
59638: IFFALSE 60025
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
59640: LD_EXP 31
59644: PUSH
59645: LD_VAR 0 2
59649: ARRAY
59650: NOT
59651: PUSH
59652: LD_EXP 23
59656: PUSH
59657: LD_VAR 0 2
59661: ARRAY
59662: PPUSH
59663: LD_INT 30
59665: PUSH
59666: LD_INT 3
59668: PUSH
59669: EMPTY
59670: LIST
59671: LIST
59672: PPUSH
59673: CALL_OW 72
59677: NOT
59678: OR
59679: IFFALSE 59683
// continue ;
59681: GO 59637
// busy := false ;
59683: LD_ADDR_VAR 0 8
59687: PUSH
59688: LD_INT 0
59690: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
59691: LD_ADDR_VAR 0 4
59695: PUSH
59696: LD_EXP 23
59700: PUSH
59701: LD_VAR 0 2
59705: ARRAY
59706: PPUSH
59707: LD_INT 30
59709: PUSH
59710: LD_INT 3
59712: PUSH
59713: EMPTY
59714: LIST
59715: LIST
59716: PPUSH
59717: CALL_OW 72
59721: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
59722: LD_ADDR_VAR 0 6
59726: PUSH
59727: LD_EXP 31
59731: PUSH
59732: LD_VAR 0 2
59736: ARRAY
59737: PPUSH
59738: LD_INT 2
59740: PUSH
59741: LD_INT 30
59743: PUSH
59744: LD_INT 32
59746: PUSH
59747: EMPTY
59748: LIST
59749: LIST
59750: PUSH
59751: LD_INT 30
59753: PUSH
59754: LD_INT 33
59756: PUSH
59757: EMPTY
59758: LIST
59759: LIST
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: LIST
59765: PPUSH
59766: CALL_OW 72
59770: ST_TO_ADDR
// if not t then
59771: LD_VAR 0 6
59775: NOT
59776: IFFALSE 59780
// continue ;
59778: GO 59637
// for j in tmp do
59780: LD_ADDR_VAR 0 3
59784: PUSH
59785: LD_VAR 0 4
59789: PUSH
59790: FOR_IN
59791: IFFALSE 59821
// if not BuildingStatus ( j ) = bs_idle then
59793: LD_VAR 0 3
59797: PPUSH
59798: CALL_OW 461
59802: PUSH
59803: LD_INT 2
59805: EQUAL
59806: NOT
59807: IFFALSE 59819
// begin busy := true ;
59809: LD_ADDR_VAR 0 8
59813: PUSH
59814: LD_INT 1
59816: ST_TO_ADDR
// break ;
59817: GO 59821
// end ;
59819: GO 59790
59821: POP
59822: POP
// if busy then
59823: LD_VAR 0 8
59827: IFFALSE 59831
// continue ;
59829: GO 59637
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
59831: LD_ADDR_VAR 0 7
59835: PUSH
59836: LD_VAR 0 6
59840: PPUSH
59841: LD_INT 35
59843: PUSH
59844: LD_INT 0
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PPUSH
59851: CALL_OW 72
59855: ST_TO_ADDR
// if tw then
59856: LD_VAR 0 7
59860: IFFALSE 59937
// begin tw := tw [ 1 ] ;
59862: LD_ADDR_VAR 0 7
59866: PUSH
59867: LD_VAR 0 7
59871: PUSH
59872: LD_INT 1
59874: ARRAY
59875: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
59876: LD_ADDR_VAR 0 9
59880: PUSH
59881: LD_VAR 0 7
59885: PPUSH
59886: LD_EXP 48
59890: PUSH
59891: LD_VAR 0 2
59895: ARRAY
59896: PPUSH
59897: CALL 19071 0 2
59901: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
59902: LD_EXP 62
59906: PUSH
59907: LD_VAR 0 2
59911: ARRAY
59912: IFFALSE 59935
// if not weapon in mc_allowed_tower_weapons [ i ] then
59914: LD_VAR 0 9
59918: PUSH
59919: LD_EXP 62
59923: PUSH
59924: LD_VAR 0 2
59928: ARRAY
59929: IN
59930: NOT
59931: IFFALSE 59935
// continue ;
59933: GO 59637
// end else
59935: GO 60000
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
59937: LD_ADDR_VAR 0 5
59941: PUSH
59942: LD_EXP 31
59946: PUSH
59947: LD_VAR 0 2
59951: ARRAY
59952: PPUSH
59953: LD_VAR 0 4
59957: PPUSH
59958: CALL 45360 0 2
59962: ST_TO_ADDR
// if not tmp2 then
59963: LD_VAR 0 5
59967: NOT
59968: IFFALSE 59972
// continue ;
59970: GO 59637
// tw := tmp2 [ 1 ] ;
59972: LD_ADDR_VAR 0 7
59976: PUSH
59977: LD_VAR 0 5
59981: PUSH
59982: LD_INT 1
59984: ARRAY
59985: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
59986: LD_ADDR_VAR 0 9
59990: PUSH
59991: LD_VAR 0 5
59995: PUSH
59996: LD_INT 2
59998: ARRAY
59999: ST_TO_ADDR
// end ; if not weapon then
60000: LD_VAR 0 9
60004: NOT
60005: IFFALSE 60009
// continue ;
60007: GO 59637
// ComPlaceWeapon ( tw , weapon ) ;
60009: LD_VAR 0 7
60013: PPUSH
60014: LD_VAR 0 9
60018: PPUSH
60019: CALL_OW 148
// end ;
60023: GO 59637
60025: POP
60026: POP
// end ;
60027: LD_VAR 0 1
60031: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
60032: LD_INT 0
60034: PPUSH
60035: PPUSH
60036: PPUSH
60037: PPUSH
60038: PPUSH
60039: PPUSH
60040: PPUSH
// if not mc_bases then
60041: LD_EXP 23
60045: NOT
60046: IFFALSE 60050
// exit ;
60048: GO 60818
// for i = 1 to mc_bases do
60050: LD_ADDR_VAR 0 2
60054: PUSH
60055: DOUBLE
60056: LD_INT 1
60058: DEC
60059: ST_TO_ADDR
60060: LD_EXP 23
60064: PUSH
60065: FOR_TO
60066: IFFALSE 60816
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
60068: LD_EXP 36
60072: PUSH
60073: LD_VAR 0 2
60077: ARRAY
60078: NOT
60079: PUSH
60080: LD_EXP 36
60084: PUSH
60085: LD_VAR 0 2
60089: ARRAY
60090: PUSH
60091: LD_EXP 37
60095: PUSH
60096: LD_VAR 0 2
60100: ARRAY
60101: EQUAL
60102: OR
60103: PUSH
60104: LD_EXP 46
60108: PUSH
60109: LD_VAR 0 2
60113: ARRAY
60114: OR
60115: IFFALSE 60119
// continue ;
60117: GO 60065
// if mc_miners [ i ] then
60119: LD_EXP 37
60123: PUSH
60124: LD_VAR 0 2
60128: ARRAY
60129: IFFALSE 60503
// begin for j = mc_miners [ i ] downto 1 do
60131: LD_ADDR_VAR 0 3
60135: PUSH
60136: DOUBLE
60137: LD_EXP 37
60141: PUSH
60142: LD_VAR 0 2
60146: ARRAY
60147: INC
60148: ST_TO_ADDR
60149: LD_INT 1
60151: PUSH
60152: FOR_DOWNTO
60153: IFFALSE 60501
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
60155: LD_EXP 37
60159: PUSH
60160: LD_VAR 0 2
60164: ARRAY
60165: PUSH
60166: LD_VAR 0 3
60170: ARRAY
60171: PPUSH
60172: CALL_OW 301
60176: PUSH
60177: LD_EXP 37
60181: PUSH
60182: LD_VAR 0 2
60186: ARRAY
60187: PUSH
60188: LD_VAR 0 3
60192: ARRAY
60193: PPUSH
60194: CALL_OW 257
60198: PUSH
60199: LD_INT 1
60201: NONEQUAL
60202: OR
60203: IFFALSE 60266
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
60205: LD_ADDR_VAR 0 5
60209: PUSH
60210: LD_EXP 37
60214: PUSH
60215: LD_VAR 0 2
60219: ARRAY
60220: PUSH
60221: LD_EXP 37
60225: PUSH
60226: LD_VAR 0 2
60230: ARRAY
60231: PUSH
60232: LD_VAR 0 3
60236: ARRAY
60237: DIFF
60238: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
60239: LD_ADDR_EXP 37
60243: PUSH
60244: LD_EXP 37
60248: PPUSH
60249: LD_VAR 0 2
60253: PPUSH
60254: LD_VAR 0 5
60258: PPUSH
60259: CALL_OW 1
60263: ST_TO_ADDR
// continue ;
60264: GO 60152
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
60266: LD_EXP 37
60270: PUSH
60271: LD_VAR 0 2
60275: ARRAY
60276: PUSH
60277: LD_VAR 0 3
60281: ARRAY
60282: PPUSH
60283: CALL_OW 257
60287: PUSH
60288: LD_INT 1
60290: EQUAL
60291: PUSH
60292: LD_EXP 37
60296: PUSH
60297: LD_VAR 0 2
60301: ARRAY
60302: PUSH
60303: LD_VAR 0 3
60307: ARRAY
60308: PPUSH
60309: CALL_OW 459
60313: NOT
60314: AND
60315: PUSH
60316: LD_EXP 37
60320: PUSH
60321: LD_VAR 0 2
60325: ARRAY
60326: PUSH
60327: LD_VAR 0 3
60331: ARRAY
60332: PPUSH
60333: CALL_OW 314
60337: NOT
60338: AND
60339: IFFALSE 60499
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
60341: LD_EXP 37
60345: PUSH
60346: LD_VAR 0 2
60350: ARRAY
60351: PUSH
60352: LD_VAR 0 3
60356: ARRAY
60357: PPUSH
60358: CALL_OW 310
60362: IFFALSE 60385
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
60364: LD_EXP 37
60368: PUSH
60369: LD_VAR 0 2
60373: ARRAY
60374: PUSH
60375: LD_VAR 0 3
60379: ARRAY
60380: PPUSH
60381: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
60385: LD_EXP 37
60389: PUSH
60390: LD_VAR 0 2
60394: ARRAY
60395: PUSH
60396: LD_VAR 0 3
60400: ARRAY
60401: PPUSH
60402: CALL_OW 314
60406: NOT
60407: IFFALSE 60499
// begin r := rand ( 1 , mc_mines [ i ] ) ;
60409: LD_ADDR_VAR 0 7
60413: PUSH
60414: LD_INT 1
60416: PPUSH
60417: LD_EXP 36
60421: PUSH
60422: LD_VAR 0 2
60426: ARRAY
60427: PPUSH
60428: CALL_OW 12
60432: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
60433: LD_EXP 37
60437: PUSH
60438: LD_VAR 0 2
60442: ARRAY
60443: PUSH
60444: LD_VAR 0 3
60448: ARRAY
60449: PPUSH
60450: LD_EXP 36
60454: PUSH
60455: LD_VAR 0 2
60459: ARRAY
60460: PUSH
60461: LD_VAR 0 7
60465: ARRAY
60466: PUSH
60467: LD_INT 1
60469: ARRAY
60470: PPUSH
60471: LD_EXP 36
60475: PUSH
60476: LD_VAR 0 2
60480: ARRAY
60481: PUSH
60482: LD_VAR 0 7
60486: ARRAY
60487: PUSH
60488: LD_INT 2
60490: ARRAY
60491: PPUSH
60492: LD_INT 0
60494: PPUSH
60495: CALL_OW 193
// end ; end ; end ;
60499: GO 60152
60501: POP
60502: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
60503: LD_ADDR_VAR 0 5
60507: PUSH
60508: LD_EXP 23
60512: PUSH
60513: LD_VAR 0 2
60517: ARRAY
60518: PPUSH
60519: LD_INT 2
60521: PUSH
60522: LD_INT 30
60524: PUSH
60525: LD_INT 4
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: PUSH
60532: LD_INT 30
60534: PUSH
60535: LD_INT 5
60537: PUSH
60538: EMPTY
60539: LIST
60540: LIST
60541: PUSH
60542: LD_INT 30
60544: PUSH
60545: LD_INT 32
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: LIST
60556: LIST
60557: PPUSH
60558: CALL_OW 72
60562: ST_TO_ADDR
// if not tmp then
60563: LD_VAR 0 5
60567: NOT
60568: IFFALSE 60572
// continue ;
60570: GO 60065
// list := [ ] ;
60572: LD_ADDR_VAR 0 6
60576: PUSH
60577: EMPTY
60578: ST_TO_ADDR
// for j in tmp do
60579: LD_ADDR_VAR 0 3
60583: PUSH
60584: LD_VAR 0 5
60588: PUSH
60589: FOR_IN
60590: IFFALSE 60659
// begin for k in UnitsInside ( j ) do
60592: LD_ADDR_VAR 0 4
60596: PUSH
60597: LD_VAR 0 3
60601: PPUSH
60602: CALL_OW 313
60606: PUSH
60607: FOR_IN
60608: IFFALSE 60655
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
60610: LD_VAR 0 4
60614: PPUSH
60615: CALL_OW 257
60619: PUSH
60620: LD_INT 1
60622: EQUAL
60623: PUSH
60624: LD_VAR 0 4
60628: PPUSH
60629: CALL_OW 459
60633: NOT
60634: AND
60635: IFFALSE 60653
// list := list ^ k ;
60637: LD_ADDR_VAR 0 6
60641: PUSH
60642: LD_VAR 0 6
60646: PUSH
60647: LD_VAR 0 4
60651: ADD
60652: ST_TO_ADDR
60653: GO 60607
60655: POP
60656: POP
// end ;
60657: GO 60589
60659: POP
60660: POP
// list := list diff mc_miners [ i ] ;
60661: LD_ADDR_VAR 0 6
60665: PUSH
60666: LD_VAR 0 6
60670: PUSH
60671: LD_EXP 37
60675: PUSH
60676: LD_VAR 0 2
60680: ARRAY
60681: DIFF
60682: ST_TO_ADDR
// if not list then
60683: LD_VAR 0 6
60687: NOT
60688: IFFALSE 60692
// continue ;
60690: GO 60065
// k := mc_mines [ i ] - mc_miners [ i ] ;
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: LD_EXP 36
60701: PUSH
60702: LD_VAR 0 2
60706: ARRAY
60707: PUSH
60708: LD_EXP 37
60712: PUSH
60713: LD_VAR 0 2
60717: ARRAY
60718: MINUS
60719: ST_TO_ADDR
// if k > list then
60720: LD_VAR 0 4
60724: PUSH
60725: LD_VAR 0 6
60729: GREATER
60730: IFFALSE 60742
// k := list ;
60732: LD_ADDR_VAR 0 4
60736: PUSH
60737: LD_VAR 0 6
60741: ST_TO_ADDR
// for j = 1 to k do
60742: LD_ADDR_VAR 0 3
60746: PUSH
60747: DOUBLE
60748: LD_INT 1
60750: DEC
60751: ST_TO_ADDR
60752: LD_VAR 0 4
60756: PUSH
60757: FOR_TO
60758: IFFALSE 60812
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
60760: LD_ADDR_EXP 37
60764: PUSH
60765: LD_EXP 37
60769: PPUSH
60770: LD_VAR 0 2
60774: PUSH
60775: LD_EXP 37
60779: PUSH
60780: LD_VAR 0 2
60784: ARRAY
60785: PUSH
60786: LD_INT 1
60788: PLUS
60789: PUSH
60790: EMPTY
60791: LIST
60792: LIST
60793: PPUSH
60794: LD_VAR 0 6
60798: PUSH
60799: LD_VAR 0 3
60803: ARRAY
60804: PPUSH
60805: CALL 14060 0 3
60809: ST_TO_ADDR
60810: GO 60757
60812: POP
60813: POP
// end ;
60814: GO 60065
60816: POP
60817: POP
// end ;
60818: LD_VAR 0 1
60822: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
60823: LD_INT 0
60825: PPUSH
60826: PPUSH
60827: PPUSH
60828: PPUSH
60829: PPUSH
60830: PPUSH
60831: PPUSH
60832: PPUSH
60833: PPUSH
60834: PPUSH
60835: PPUSH
// if not mc_bases then
60836: LD_EXP 23
60840: NOT
60841: IFFALSE 60845
// exit ;
60843: GO 62668
// for i = 1 to mc_bases do
60845: LD_ADDR_VAR 0 2
60849: PUSH
60850: DOUBLE
60851: LD_INT 1
60853: DEC
60854: ST_TO_ADDR
60855: LD_EXP 23
60859: PUSH
60860: FOR_TO
60861: IFFALSE 62666
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
60863: LD_EXP 23
60867: PUSH
60868: LD_VAR 0 2
60872: ARRAY
60873: NOT
60874: PUSH
60875: LD_EXP 30
60879: PUSH
60880: LD_VAR 0 2
60884: ARRAY
60885: OR
60886: IFFALSE 60890
// continue ;
60888: GO 60860
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
60890: LD_EXP 39
60894: PUSH
60895: LD_VAR 0 2
60899: ARRAY
60900: NOT
60901: PUSH
60902: LD_EXP 40
60906: PUSH
60907: LD_VAR 0 2
60911: ARRAY
60912: AND
60913: IFFALSE 60951
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
60915: LD_ADDR_EXP 40
60919: PUSH
60920: LD_EXP 40
60924: PPUSH
60925: LD_VAR 0 2
60929: PPUSH
60930: EMPTY
60931: PPUSH
60932: CALL_OW 1
60936: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
60937: LD_VAR 0 2
60941: PPUSH
60942: LD_INT 107
60944: PPUSH
60945: CALL 51777 0 2
// continue ;
60949: GO 60860
// end ; target := [ ] ;
60951: LD_ADDR_VAR 0 7
60955: PUSH
60956: EMPTY
60957: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
60958: LD_ADDR_VAR 0 6
60962: PUSH
60963: LD_EXP 23
60967: PUSH
60968: LD_VAR 0 2
60972: ARRAY
60973: PUSH
60974: LD_INT 1
60976: ARRAY
60977: PPUSH
60978: CALL_OW 255
60982: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60983: LD_ADDR_VAR 0 9
60987: PUSH
60988: LD_EXP 23
60992: PUSH
60993: LD_VAR 0 2
60997: ARRAY
60998: PPUSH
60999: LD_INT 2
61001: PUSH
61002: LD_INT 30
61004: PUSH
61005: LD_INT 0
61007: PUSH
61008: EMPTY
61009: LIST
61010: LIST
61011: PUSH
61012: LD_INT 30
61014: PUSH
61015: LD_INT 1
61017: PUSH
61018: EMPTY
61019: LIST
61020: LIST
61021: PUSH
61022: EMPTY
61023: LIST
61024: LIST
61025: LIST
61026: PPUSH
61027: CALL_OW 72
61031: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
61032: LD_ADDR_VAR 0 3
61036: PUSH
61037: DOUBLE
61038: LD_EXP 39
61042: PUSH
61043: LD_VAR 0 2
61047: ARRAY
61048: INC
61049: ST_TO_ADDR
61050: LD_INT 1
61052: PUSH
61053: FOR_DOWNTO
61054: IFFALSE 61299
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
61056: LD_EXP 39
61060: PUSH
61061: LD_VAR 0 2
61065: ARRAY
61066: PUSH
61067: LD_VAR 0 3
61071: ARRAY
61072: PUSH
61073: LD_INT 2
61075: ARRAY
61076: PPUSH
61077: LD_EXP 39
61081: PUSH
61082: LD_VAR 0 2
61086: ARRAY
61087: PUSH
61088: LD_VAR 0 3
61092: ARRAY
61093: PUSH
61094: LD_INT 3
61096: ARRAY
61097: PPUSH
61098: CALL_OW 488
61102: PUSH
61103: LD_EXP 39
61107: PUSH
61108: LD_VAR 0 2
61112: ARRAY
61113: PUSH
61114: LD_VAR 0 3
61118: ARRAY
61119: PUSH
61120: LD_INT 2
61122: ARRAY
61123: PPUSH
61124: LD_EXP 39
61128: PUSH
61129: LD_VAR 0 2
61133: ARRAY
61134: PUSH
61135: LD_VAR 0 3
61139: ARRAY
61140: PUSH
61141: LD_INT 3
61143: ARRAY
61144: PPUSH
61145: CALL_OW 284
61149: PUSH
61150: LD_INT 0
61152: EQUAL
61153: AND
61154: IFFALSE 61209
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
61156: LD_ADDR_VAR 0 5
61160: PUSH
61161: LD_EXP 39
61165: PUSH
61166: LD_VAR 0 2
61170: ARRAY
61171: PPUSH
61172: LD_VAR 0 3
61176: PPUSH
61177: CALL_OW 3
61181: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
61182: LD_ADDR_EXP 39
61186: PUSH
61187: LD_EXP 39
61191: PPUSH
61192: LD_VAR 0 2
61196: PPUSH
61197: LD_VAR 0 5
61201: PPUSH
61202: CALL_OW 1
61206: ST_TO_ADDR
// continue ;
61207: GO 61053
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
61209: LD_VAR 0 6
61213: PPUSH
61214: LD_EXP 39
61218: PUSH
61219: LD_VAR 0 2
61223: ARRAY
61224: PUSH
61225: LD_VAR 0 3
61229: ARRAY
61230: PUSH
61231: LD_INT 2
61233: ARRAY
61234: PPUSH
61235: LD_EXP 39
61239: PUSH
61240: LD_VAR 0 2
61244: ARRAY
61245: PUSH
61246: LD_VAR 0 3
61250: ARRAY
61251: PUSH
61252: LD_INT 3
61254: ARRAY
61255: PPUSH
61256: LD_INT 30
61258: PPUSH
61259: CALL 14956 0 4
61263: PUSH
61264: LD_INT 4
61266: ARRAY
61267: PUSH
61268: LD_INT 0
61270: EQUAL
61271: IFFALSE 61297
// begin target := mc_crates [ i ] [ j ] ;
61273: LD_ADDR_VAR 0 7
61277: PUSH
61278: LD_EXP 39
61282: PUSH
61283: LD_VAR 0 2
61287: ARRAY
61288: PUSH
61289: LD_VAR 0 3
61293: ARRAY
61294: ST_TO_ADDR
// break ;
61295: GO 61299
// end ; end ;
61297: GO 61053
61299: POP
61300: POP
// if not target then
61301: LD_VAR 0 7
61305: NOT
61306: IFFALSE 61310
// continue ;
61308: GO 60860
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
61310: LD_ADDR_VAR 0 8
61314: PUSH
61315: LD_EXP 42
61319: PUSH
61320: LD_VAR 0 2
61324: ARRAY
61325: PPUSH
61326: LD_INT 2
61328: PUSH
61329: LD_INT 3
61331: PUSH
61332: LD_INT 58
61334: PUSH
61335: EMPTY
61336: LIST
61337: PUSH
61338: EMPTY
61339: LIST
61340: LIST
61341: PUSH
61342: LD_INT 61
61344: PUSH
61345: EMPTY
61346: LIST
61347: PUSH
61348: LD_INT 33
61350: PUSH
61351: LD_INT 5
61353: PUSH
61354: EMPTY
61355: LIST
61356: LIST
61357: PUSH
61358: LD_INT 33
61360: PUSH
61361: LD_INT 3
61363: PUSH
61364: EMPTY
61365: LIST
61366: LIST
61367: PUSH
61368: EMPTY
61369: LIST
61370: LIST
61371: LIST
61372: LIST
61373: LIST
61374: PUSH
61375: LD_INT 2
61377: PUSH
61378: LD_INT 34
61380: PUSH
61381: LD_INT 32
61383: PUSH
61384: EMPTY
61385: LIST
61386: LIST
61387: PUSH
61388: LD_INT 34
61390: PUSH
61391: LD_INT 51
61393: PUSH
61394: EMPTY
61395: LIST
61396: LIST
61397: PUSH
61398: LD_INT 34
61400: PUSH
61401: LD_INT 12
61403: PUSH
61404: EMPTY
61405: LIST
61406: LIST
61407: PUSH
61408: EMPTY
61409: LIST
61410: LIST
61411: LIST
61412: LIST
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PPUSH
61418: CALL_OW 72
61422: ST_TO_ADDR
// if not cargo then
61423: LD_VAR 0 8
61427: NOT
61428: IFFALSE 62134
// begin if mc_crates_collector [ i ] < 5 then
61430: LD_EXP 40
61434: PUSH
61435: LD_VAR 0 2
61439: ARRAY
61440: PUSH
61441: LD_INT 5
61443: LESS
61444: IFFALSE 61810
// begin if mc_ape [ i ] then
61446: LD_EXP 52
61450: PUSH
61451: LD_VAR 0 2
61455: ARRAY
61456: IFFALSE 61503
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
61458: LD_ADDR_VAR 0 5
61462: PUSH
61463: LD_EXP 52
61467: PUSH
61468: LD_VAR 0 2
61472: ARRAY
61473: PPUSH
61474: LD_INT 25
61476: PUSH
61477: LD_INT 16
61479: PUSH
61480: EMPTY
61481: LIST
61482: LIST
61483: PUSH
61484: LD_INT 24
61486: PUSH
61487: LD_INT 750
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PUSH
61494: EMPTY
61495: LIST
61496: LIST
61497: PPUSH
61498: CALL_OW 72
61502: ST_TO_ADDR
// if not tmp then
61503: LD_VAR 0 5
61507: NOT
61508: IFFALSE 61555
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
61510: LD_ADDR_VAR 0 5
61514: PUSH
61515: LD_EXP 23
61519: PUSH
61520: LD_VAR 0 2
61524: ARRAY
61525: PPUSH
61526: LD_INT 25
61528: PUSH
61529: LD_INT 2
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: PUSH
61536: LD_INT 24
61538: PUSH
61539: LD_INT 750
61541: PUSH
61542: EMPTY
61543: LIST
61544: LIST
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PPUSH
61550: CALL_OW 72
61554: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
61555: LD_EXP 52
61559: PUSH
61560: LD_VAR 0 2
61564: ARRAY
61565: PUSH
61566: LD_EXP 23
61570: PUSH
61571: LD_VAR 0 2
61575: ARRAY
61576: PPUSH
61577: LD_INT 25
61579: PUSH
61580: LD_INT 2
61582: PUSH
61583: EMPTY
61584: LIST
61585: LIST
61586: PUSH
61587: LD_INT 24
61589: PUSH
61590: LD_INT 750
61592: PUSH
61593: EMPTY
61594: LIST
61595: LIST
61596: PUSH
61597: EMPTY
61598: LIST
61599: LIST
61600: PPUSH
61601: CALL_OW 72
61605: AND
61606: PUSH
61607: LD_VAR 0 5
61611: PUSH
61612: LD_INT 5
61614: LESS
61615: AND
61616: IFFALSE 61698
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
61618: LD_ADDR_VAR 0 3
61622: PUSH
61623: LD_EXP 23
61627: PUSH
61628: LD_VAR 0 2
61632: ARRAY
61633: PPUSH
61634: LD_INT 25
61636: PUSH
61637: LD_INT 2
61639: PUSH
61640: EMPTY
61641: LIST
61642: LIST
61643: PUSH
61644: LD_INT 24
61646: PUSH
61647: LD_INT 750
61649: PUSH
61650: EMPTY
61651: LIST
61652: LIST
61653: PUSH
61654: EMPTY
61655: LIST
61656: LIST
61657: PPUSH
61658: CALL_OW 72
61662: PUSH
61663: FOR_IN
61664: IFFALSE 61696
// begin tmp := tmp union j ;
61666: LD_ADDR_VAR 0 5
61670: PUSH
61671: LD_VAR 0 5
61675: PUSH
61676: LD_VAR 0 3
61680: UNION
61681: ST_TO_ADDR
// if tmp >= 5 then
61682: LD_VAR 0 5
61686: PUSH
61687: LD_INT 5
61689: GREATEREQUAL
61690: IFFALSE 61694
// break ;
61692: GO 61696
// end ;
61694: GO 61663
61696: POP
61697: POP
// end ; if not tmp then
61698: LD_VAR 0 5
61702: NOT
61703: IFFALSE 61707
// continue ;
61705: GO 60860
// for j in tmp do
61707: LD_ADDR_VAR 0 3
61711: PUSH
61712: LD_VAR 0 5
61716: PUSH
61717: FOR_IN
61718: IFFALSE 61808
// if not GetTag ( j ) then
61720: LD_VAR 0 3
61724: PPUSH
61725: CALL_OW 110
61729: NOT
61730: IFFALSE 61806
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
61732: LD_ADDR_EXP 40
61736: PUSH
61737: LD_EXP 40
61741: PPUSH
61742: LD_VAR 0 2
61746: PUSH
61747: LD_EXP 40
61751: PUSH
61752: LD_VAR 0 2
61756: ARRAY
61757: PUSH
61758: LD_INT 1
61760: PLUS
61761: PUSH
61762: EMPTY
61763: LIST
61764: LIST
61765: PPUSH
61766: LD_VAR 0 3
61770: PPUSH
61771: CALL 14060 0 3
61775: ST_TO_ADDR
// SetTag ( j , 107 ) ;
61776: LD_VAR 0 3
61780: PPUSH
61781: LD_INT 107
61783: PPUSH
61784: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
61788: LD_EXP 40
61792: PUSH
61793: LD_VAR 0 2
61797: ARRAY
61798: PUSH
61799: LD_INT 5
61801: GREATEREQUAL
61802: IFFALSE 61806
// break ;
61804: GO 61808
// end ;
61806: GO 61717
61808: POP
61809: POP
// end ; if mc_crates_collector [ i ] and target then
61810: LD_EXP 40
61814: PUSH
61815: LD_VAR 0 2
61819: ARRAY
61820: PUSH
61821: LD_VAR 0 7
61825: AND
61826: IFFALSE 62132
// begin if mc_crates_collector [ i ] < target [ 1 ] then
61828: LD_EXP 40
61832: PUSH
61833: LD_VAR 0 2
61837: ARRAY
61838: PUSH
61839: LD_VAR 0 7
61843: PUSH
61844: LD_INT 1
61846: ARRAY
61847: LESS
61848: IFFALSE 61868
// tmp := mc_crates_collector [ i ] else
61850: LD_ADDR_VAR 0 5
61854: PUSH
61855: LD_EXP 40
61859: PUSH
61860: LD_VAR 0 2
61864: ARRAY
61865: ST_TO_ADDR
61866: GO 61882
// tmp := target [ 1 ] ;
61868: LD_ADDR_VAR 0 5
61872: PUSH
61873: LD_VAR 0 7
61877: PUSH
61878: LD_INT 1
61880: ARRAY
61881: ST_TO_ADDR
// k := 0 ;
61882: LD_ADDR_VAR 0 4
61886: PUSH
61887: LD_INT 0
61889: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
61890: LD_ADDR_VAR 0 3
61894: PUSH
61895: LD_EXP 40
61899: PUSH
61900: LD_VAR 0 2
61904: ARRAY
61905: PUSH
61906: FOR_IN
61907: IFFALSE 62130
// begin k := k + 1 ;
61909: LD_ADDR_VAR 0 4
61913: PUSH
61914: LD_VAR 0 4
61918: PUSH
61919: LD_INT 1
61921: PLUS
61922: ST_TO_ADDR
// if k > tmp then
61923: LD_VAR 0 4
61927: PUSH
61928: LD_VAR 0 5
61932: GREATER
61933: IFFALSE 61937
// break ;
61935: GO 62130
// if not GetClass ( j ) in [ 2 , 16 ] then
61937: LD_VAR 0 3
61941: PPUSH
61942: CALL_OW 257
61946: PUSH
61947: LD_INT 2
61949: PUSH
61950: LD_INT 16
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: IN
61957: NOT
61958: IFFALSE 62011
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
61960: LD_ADDR_EXP 40
61964: PUSH
61965: LD_EXP 40
61969: PPUSH
61970: LD_VAR 0 2
61974: PPUSH
61975: LD_EXP 40
61979: PUSH
61980: LD_VAR 0 2
61984: ARRAY
61985: PUSH
61986: LD_VAR 0 3
61990: DIFF
61991: PPUSH
61992: CALL_OW 1
61996: ST_TO_ADDR
// SetTag ( j , 0 ) ;
61997: LD_VAR 0 3
62001: PPUSH
62002: LD_INT 0
62004: PPUSH
62005: CALL_OW 109
// continue ;
62009: GO 61906
// end ; if IsInUnit ( j ) then
62011: LD_VAR 0 3
62015: PPUSH
62016: CALL_OW 310
62020: IFFALSE 62031
// ComExitBuilding ( j ) ;
62022: LD_VAR 0 3
62026: PPUSH
62027: CALL_OW 122
// wait ( 3 ) ;
62031: LD_INT 3
62033: PPUSH
62034: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
62038: LD_VAR 0 3
62042: PPUSH
62043: CALL_OW 314
62047: PUSH
62048: LD_VAR 0 6
62052: PPUSH
62053: LD_VAR 0 7
62057: PUSH
62058: LD_INT 2
62060: ARRAY
62061: PPUSH
62062: LD_VAR 0 7
62066: PUSH
62067: LD_INT 3
62069: ARRAY
62070: PPUSH
62071: LD_INT 30
62073: PPUSH
62074: CALL 14956 0 4
62078: PUSH
62079: LD_INT 4
62081: ARRAY
62082: AND
62083: IFFALSE 62101
// ComStandNearbyBuilding ( j , depot ) else
62085: LD_VAR 0 3
62089: PPUSH
62090: LD_VAR 0 9
62094: PPUSH
62095: CALL 10638 0 2
62099: GO 62128
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
62101: LD_VAR 0 3
62105: PPUSH
62106: LD_VAR 0 7
62110: PUSH
62111: LD_INT 2
62113: ARRAY
62114: PPUSH
62115: LD_VAR 0 7
62119: PUSH
62120: LD_INT 3
62122: ARRAY
62123: PPUSH
62124: CALL_OW 117
// end ;
62128: GO 61906
62130: POP
62131: POP
// end ; end else
62132: GO 62664
// begin for j in cargo do
62134: LD_ADDR_VAR 0 3
62138: PUSH
62139: LD_VAR 0 8
62143: PUSH
62144: FOR_IN
62145: IFFALSE 62662
// begin if GetTag ( j ) <> 0 then
62147: LD_VAR 0 3
62151: PPUSH
62152: CALL_OW 110
62156: PUSH
62157: LD_INT 0
62159: NONEQUAL
62160: IFFALSE 62164
// continue ;
62162: GO 62144
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
62164: LD_VAR 0 3
62168: PPUSH
62169: CALL_OW 256
62173: PUSH
62174: LD_INT 1000
62176: LESS
62177: PUSH
62178: LD_VAR 0 3
62182: PPUSH
62183: LD_EXP 47
62187: PUSH
62188: LD_VAR 0 2
62192: ARRAY
62193: PPUSH
62194: CALL_OW 308
62198: NOT
62199: AND
62200: IFFALSE 62222
// ComMoveToArea ( j , mc_parking [ i ] ) ;
62202: LD_VAR 0 3
62206: PPUSH
62207: LD_EXP 47
62211: PUSH
62212: LD_VAR 0 2
62216: ARRAY
62217: PPUSH
62218: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
62222: LD_VAR 0 3
62226: PPUSH
62227: CALL_OW 256
62231: PUSH
62232: LD_INT 1000
62234: LESS
62235: PUSH
62236: LD_VAR 0 3
62240: PPUSH
62241: LD_EXP 47
62245: PUSH
62246: LD_VAR 0 2
62250: ARRAY
62251: PPUSH
62252: CALL_OW 308
62256: AND
62257: IFFALSE 62261
// continue ;
62259: GO 62144
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
62261: LD_VAR 0 3
62265: PPUSH
62266: CALL_OW 262
62270: PUSH
62271: LD_INT 2
62273: EQUAL
62274: PUSH
62275: LD_VAR 0 3
62279: PPUSH
62280: CALL_OW 261
62284: PUSH
62285: LD_INT 15
62287: LESS
62288: AND
62289: IFFALSE 62293
// continue ;
62291: GO 62144
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
62293: LD_VAR 0 3
62297: PPUSH
62298: CALL_OW 262
62302: PUSH
62303: LD_INT 1
62305: EQUAL
62306: PUSH
62307: LD_VAR 0 3
62311: PPUSH
62312: CALL_OW 261
62316: PUSH
62317: LD_INT 10
62319: LESS
62320: AND
62321: IFFALSE 62601
// begin if not depot then
62323: LD_VAR 0 9
62327: NOT
62328: IFFALSE 62332
// continue ;
62330: GO 62144
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
62332: LD_VAR 0 3
62336: PPUSH
62337: LD_VAR 0 9
62341: PPUSH
62342: LD_VAR 0 3
62346: PPUSH
62347: CALL_OW 74
62351: PPUSH
62352: CALL_OW 296
62356: PUSH
62357: LD_INT 6
62359: LESS
62360: IFFALSE 62376
// SetFuel ( j , 100 ) else
62362: LD_VAR 0 3
62366: PPUSH
62367: LD_INT 100
62369: PPUSH
62370: CALL_OW 240
62374: GO 62601
// if GetFuel ( j ) = 0 then
62376: LD_VAR 0 3
62380: PPUSH
62381: CALL_OW 261
62385: PUSH
62386: LD_INT 0
62388: EQUAL
62389: IFFALSE 62601
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
62391: LD_ADDR_EXP 42
62395: PUSH
62396: LD_EXP 42
62400: PPUSH
62401: LD_VAR 0 2
62405: PPUSH
62406: LD_EXP 42
62410: PUSH
62411: LD_VAR 0 2
62415: ARRAY
62416: PUSH
62417: LD_VAR 0 3
62421: DIFF
62422: PPUSH
62423: CALL_OW 1
62427: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
62428: LD_VAR 0 3
62432: PPUSH
62433: CALL_OW 263
62437: PUSH
62438: LD_INT 1
62440: EQUAL
62441: IFFALSE 62457
// ComExitVehicle ( IsInUnit ( j ) ) ;
62443: LD_VAR 0 3
62447: PPUSH
62448: CALL_OW 310
62452: PPUSH
62453: CALL_OW 121
// if GetControl ( j ) = control_remote then
62457: LD_VAR 0 3
62461: PPUSH
62462: CALL_OW 263
62466: PUSH
62467: LD_INT 2
62469: EQUAL
62470: IFFALSE 62481
// ComUnlink ( j ) ;
62472: LD_VAR 0 3
62476: PPUSH
62477: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
62481: LD_ADDR_VAR 0 10
62485: PUSH
62486: LD_VAR 0 2
62490: PPUSH
62491: LD_INT 3
62493: PPUSH
62494: CALL 72082 0 2
62498: ST_TO_ADDR
// if fac then
62499: LD_VAR 0 10
62503: IFFALSE 62599
// begin for k in fac do
62505: LD_ADDR_VAR 0 4
62509: PUSH
62510: LD_VAR 0 10
62514: PUSH
62515: FOR_IN
62516: IFFALSE 62597
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
62518: LD_ADDR_VAR 0 11
62522: PUSH
62523: LD_VAR 0 10
62527: PPUSH
62528: LD_VAR 0 3
62532: PPUSH
62533: CALL_OW 265
62537: PPUSH
62538: LD_VAR 0 3
62542: PPUSH
62543: CALL_OW 262
62547: PPUSH
62548: LD_VAR 0 3
62552: PPUSH
62553: CALL_OW 263
62557: PPUSH
62558: LD_VAR 0 3
62562: PPUSH
62563: CALL_OW 264
62567: PPUSH
62568: CALL 11556 0 5
62572: ST_TO_ADDR
// if components then
62573: LD_VAR 0 11
62577: IFFALSE 62595
// begin MC_InsertProduceList ( i , components ) ;
62579: LD_VAR 0 2
62583: PPUSH
62584: LD_VAR 0 11
62588: PPUSH
62589: CALL 71627 0 2
// break ;
62593: GO 62597
// end ; end ;
62595: GO 62515
62597: POP
62598: POP
// end ; continue ;
62599: GO 62144
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
62601: LD_VAR 0 3
62605: PPUSH
62606: LD_INT 1
62608: PPUSH
62609: CALL_OW 289
62613: PUSH
62614: LD_INT 100
62616: LESS
62617: PUSH
62618: LD_VAR 0 3
62622: PPUSH
62623: CALL_OW 314
62627: NOT
62628: AND
62629: IFFALSE 62658
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
62631: LD_VAR 0 3
62635: PPUSH
62636: LD_VAR 0 7
62640: PUSH
62641: LD_INT 2
62643: ARRAY
62644: PPUSH
62645: LD_VAR 0 7
62649: PUSH
62650: LD_INT 3
62652: ARRAY
62653: PPUSH
62654: CALL_OW 117
// break ;
62658: GO 62662
// end ;
62660: GO 62144
62662: POP
62663: POP
// end ; end ;
62664: GO 60860
62666: POP
62667: POP
// end ;
62668: LD_VAR 0 1
62672: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
62673: LD_INT 0
62675: PPUSH
62676: PPUSH
62677: PPUSH
62678: PPUSH
// if not mc_bases then
62679: LD_EXP 23
62683: NOT
62684: IFFALSE 62688
// exit ;
62686: GO 62849
// for i = 1 to mc_bases do
62688: LD_ADDR_VAR 0 2
62692: PUSH
62693: DOUBLE
62694: LD_INT 1
62696: DEC
62697: ST_TO_ADDR
62698: LD_EXP 23
62702: PUSH
62703: FOR_TO
62704: IFFALSE 62847
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
62706: LD_ADDR_VAR 0 4
62710: PUSH
62711: LD_EXP 42
62715: PUSH
62716: LD_VAR 0 2
62720: ARRAY
62721: PUSH
62722: LD_EXP 45
62726: PUSH
62727: LD_VAR 0 2
62731: ARRAY
62732: UNION
62733: PPUSH
62734: LD_INT 33
62736: PUSH
62737: LD_INT 2
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PPUSH
62744: CALL_OW 72
62748: ST_TO_ADDR
// if tmp then
62749: LD_VAR 0 4
62753: IFFALSE 62845
// for j in tmp do
62755: LD_ADDR_VAR 0 3
62759: PUSH
62760: LD_VAR 0 4
62764: PUSH
62765: FOR_IN
62766: IFFALSE 62843
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
62768: LD_VAR 0 3
62772: PPUSH
62773: CALL_OW 312
62777: NOT
62778: PUSH
62779: LD_VAR 0 3
62783: PPUSH
62784: CALL_OW 256
62788: PUSH
62789: LD_INT 250
62791: GREATEREQUAL
62792: AND
62793: IFFALSE 62806
// Connect ( j ) else
62795: LD_VAR 0 3
62799: PPUSH
62800: CALL 17031 0 1
62804: GO 62841
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
62806: LD_VAR 0 3
62810: PPUSH
62811: CALL_OW 256
62815: PUSH
62816: LD_INT 250
62818: LESS
62819: PUSH
62820: LD_VAR 0 3
62824: PPUSH
62825: CALL_OW 312
62829: AND
62830: IFFALSE 62841
// ComUnlink ( j ) ;
62832: LD_VAR 0 3
62836: PPUSH
62837: CALL_OW 136
62841: GO 62765
62843: POP
62844: POP
// end ;
62845: GO 62703
62847: POP
62848: POP
// end ;
62849: LD_VAR 0 1
62853: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
62854: LD_INT 0
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
// if not mc_bases then
62861: LD_EXP 23
62865: NOT
62866: IFFALSE 62870
// exit ;
62868: GO 63315
// for i = 1 to mc_bases do
62870: LD_ADDR_VAR 0 2
62874: PUSH
62875: DOUBLE
62876: LD_INT 1
62878: DEC
62879: ST_TO_ADDR
62880: LD_EXP 23
62884: PUSH
62885: FOR_TO
62886: IFFALSE 63313
// begin if not mc_produce [ i ] then
62888: LD_EXP 44
62892: PUSH
62893: LD_VAR 0 2
62897: ARRAY
62898: NOT
62899: IFFALSE 62903
// continue ;
62901: GO 62885
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62903: LD_ADDR_VAR 0 5
62907: PUSH
62908: LD_EXP 23
62912: PUSH
62913: LD_VAR 0 2
62917: ARRAY
62918: PPUSH
62919: LD_INT 30
62921: PUSH
62922: LD_INT 3
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PPUSH
62929: CALL_OW 72
62933: ST_TO_ADDR
// if not fac then
62934: LD_VAR 0 5
62938: NOT
62939: IFFALSE 62943
// continue ;
62941: GO 62885
// for j in fac do
62943: LD_ADDR_VAR 0 3
62947: PUSH
62948: LD_VAR 0 5
62952: PUSH
62953: FOR_IN
62954: IFFALSE 63309
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
62956: LD_VAR 0 3
62960: PPUSH
62961: CALL_OW 461
62965: PUSH
62966: LD_INT 2
62968: NONEQUAL
62969: PUSH
62970: LD_VAR 0 3
62974: PPUSH
62975: LD_INT 15
62977: PPUSH
62978: CALL 16659 0 2
62982: PUSH
62983: LD_INT 4
62985: ARRAY
62986: OR
62987: IFFALSE 62991
// continue ;
62989: GO 62953
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
62991: LD_VAR 0 3
62995: PPUSH
62996: LD_EXP 44
63000: PUSH
63001: LD_VAR 0 2
63005: ARRAY
63006: PUSH
63007: LD_INT 1
63009: ARRAY
63010: PUSH
63011: LD_INT 1
63013: ARRAY
63014: PPUSH
63015: LD_EXP 44
63019: PUSH
63020: LD_VAR 0 2
63024: ARRAY
63025: PUSH
63026: LD_INT 1
63028: ARRAY
63029: PUSH
63030: LD_INT 2
63032: ARRAY
63033: PPUSH
63034: LD_EXP 44
63038: PUSH
63039: LD_VAR 0 2
63043: ARRAY
63044: PUSH
63045: LD_INT 1
63047: ARRAY
63048: PUSH
63049: LD_INT 3
63051: ARRAY
63052: PPUSH
63053: LD_EXP 44
63057: PUSH
63058: LD_VAR 0 2
63062: ARRAY
63063: PUSH
63064: LD_INT 1
63066: ARRAY
63067: PUSH
63068: LD_INT 4
63070: ARRAY
63071: PPUSH
63072: CALL_OW 448
63076: PUSH
63077: LD_VAR 0 3
63081: PPUSH
63082: LD_EXP 44
63086: PUSH
63087: LD_VAR 0 2
63091: ARRAY
63092: PUSH
63093: LD_INT 1
63095: ARRAY
63096: PUSH
63097: LD_INT 1
63099: ARRAY
63100: PUSH
63101: LD_EXP 44
63105: PUSH
63106: LD_VAR 0 2
63110: ARRAY
63111: PUSH
63112: LD_INT 1
63114: ARRAY
63115: PUSH
63116: LD_INT 2
63118: ARRAY
63119: PUSH
63120: LD_EXP 44
63124: PUSH
63125: LD_VAR 0 2
63129: ARRAY
63130: PUSH
63131: LD_INT 1
63133: ARRAY
63134: PUSH
63135: LD_INT 3
63137: ARRAY
63138: PUSH
63139: LD_EXP 44
63143: PUSH
63144: LD_VAR 0 2
63148: ARRAY
63149: PUSH
63150: LD_INT 1
63152: ARRAY
63153: PUSH
63154: LD_INT 4
63156: ARRAY
63157: PUSH
63158: EMPTY
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: PPUSH
63164: CALL 20427 0 2
63168: AND
63169: IFFALSE 63307
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
63171: LD_VAR 0 3
63175: PPUSH
63176: LD_EXP 44
63180: PUSH
63181: LD_VAR 0 2
63185: ARRAY
63186: PUSH
63187: LD_INT 1
63189: ARRAY
63190: PUSH
63191: LD_INT 1
63193: ARRAY
63194: PPUSH
63195: LD_EXP 44
63199: PUSH
63200: LD_VAR 0 2
63204: ARRAY
63205: PUSH
63206: LD_INT 1
63208: ARRAY
63209: PUSH
63210: LD_INT 2
63212: ARRAY
63213: PPUSH
63214: LD_EXP 44
63218: PUSH
63219: LD_VAR 0 2
63223: ARRAY
63224: PUSH
63225: LD_INT 1
63227: ARRAY
63228: PUSH
63229: LD_INT 3
63231: ARRAY
63232: PPUSH
63233: LD_EXP 44
63237: PUSH
63238: LD_VAR 0 2
63242: ARRAY
63243: PUSH
63244: LD_INT 1
63246: ARRAY
63247: PUSH
63248: LD_INT 4
63250: ARRAY
63251: PPUSH
63252: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
63256: LD_ADDR_VAR 0 4
63260: PUSH
63261: LD_EXP 44
63265: PUSH
63266: LD_VAR 0 2
63270: ARRAY
63271: PPUSH
63272: LD_INT 1
63274: PPUSH
63275: CALL_OW 3
63279: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63280: LD_ADDR_EXP 44
63284: PUSH
63285: LD_EXP 44
63289: PPUSH
63290: LD_VAR 0 2
63294: PPUSH
63295: LD_VAR 0 4
63299: PPUSH
63300: CALL_OW 1
63304: ST_TO_ADDR
// break ;
63305: GO 63309
// end ; end ;
63307: GO 62953
63309: POP
63310: POP
// end ;
63311: GO 62885
63313: POP
63314: POP
// end ;
63315: LD_VAR 0 1
63319: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
63320: LD_INT 0
63322: PPUSH
63323: PPUSH
63324: PPUSH
// if not mc_bases then
63325: LD_EXP 23
63329: NOT
63330: IFFALSE 63334
// exit ;
63332: GO 63423
// for i = 1 to mc_bases do
63334: LD_ADDR_VAR 0 2
63338: PUSH
63339: DOUBLE
63340: LD_INT 1
63342: DEC
63343: ST_TO_ADDR
63344: LD_EXP 23
63348: PUSH
63349: FOR_TO
63350: IFFALSE 63421
// begin if mc_attack [ i ] then
63352: LD_EXP 43
63356: PUSH
63357: LD_VAR 0 2
63361: ARRAY
63362: IFFALSE 63419
// begin tmp := mc_attack [ i ] [ 1 ] ;
63364: LD_ADDR_VAR 0 3
63368: PUSH
63369: LD_EXP 43
63373: PUSH
63374: LD_VAR 0 2
63378: ARRAY
63379: PUSH
63380: LD_INT 1
63382: ARRAY
63383: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63384: LD_ADDR_EXP 43
63388: PUSH
63389: LD_EXP 43
63393: PPUSH
63394: LD_VAR 0 2
63398: PPUSH
63399: EMPTY
63400: PPUSH
63401: CALL_OW 1
63405: ST_TO_ADDR
// Attack ( tmp ) ;
63406: LD_VAR 0 3
63410: PPUSH
63411: CALL 78201 0 1
// exit ;
63415: POP
63416: POP
63417: GO 63423
// end ; end ;
63419: GO 63349
63421: POP
63422: POP
// end ;
63423: LD_VAR 0 1
63427: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
63428: LD_INT 0
63430: PPUSH
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
63435: PPUSH
63436: PPUSH
// if not mc_bases then
63437: LD_EXP 23
63441: NOT
63442: IFFALSE 63446
// exit ;
63444: GO 64145
// for i = 1 to mc_bases do
63446: LD_ADDR_VAR 0 2
63450: PUSH
63451: DOUBLE
63452: LD_INT 1
63454: DEC
63455: ST_TO_ADDR
63456: LD_EXP 23
63460: PUSH
63461: FOR_TO
63462: IFFALSE 64143
// begin if not mc_bases [ i ] then
63464: LD_EXP 23
63468: PUSH
63469: LD_VAR 0 2
63473: ARRAY
63474: NOT
63475: IFFALSE 63479
// continue ;
63477: GO 63461
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
63479: LD_ADDR_VAR 0 7
63483: PUSH
63484: LD_EXP 23
63488: PUSH
63489: LD_VAR 0 2
63493: ARRAY
63494: PUSH
63495: LD_INT 1
63497: ARRAY
63498: PPUSH
63499: CALL 10860 0 1
63503: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
63504: LD_ADDR_EXP 46
63508: PUSH
63509: LD_EXP 46
63513: PPUSH
63514: LD_VAR 0 2
63518: PPUSH
63519: LD_EXP 23
63523: PUSH
63524: LD_VAR 0 2
63528: ARRAY
63529: PUSH
63530: LD_INT 1
63532: ARRAY
63533: PPUSH
63534: CALL_OW 255
63538: PPUSH
63539: LD_EXP 48
63543: PUSH
63544: LD_VAR 0 2
63548: ARRAY
63549: PPUSH
63550: CALL 10825 0 2
63554: PPUSH
63555: CALL_OW 1
63559: ST_TO_ADDR
// if not mc_scan [ i ] then
63560: LD_EXP 46
63564: PUSH
63565: LD_VAR 0 2
63569: ARRAY
63570: NOT
63571: IFFALSE 63749
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63573: LD_ADDR_VAR 0 4
63577: PUSH
63578: LD_EXP 23
63582: PUSH
63583: LD_VAR 0 2
63587: ARRAY
63588: PPUSH
63589: LD_INT 2
63591: PUSH
63592: LD_INT 25
63594: PUSH
63595: LD_INT 5
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 25
63604: PUSH
63605: LD_INT 8
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 25
63614: PUSH
63615: LD_INT 9
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: EMPTY
63623: LIST
63624: LIST
63625: LIST
63626: LIST
63627: PPUSH
63628: CALL_OW 72
63632: ST_TO_ADDR
// if not tmp then
63633: LD_VAR 0 4
63637: NOT
63638: IFFALSE 63642
// continue ;
63640: GO 63461
// for j in tmp do
63642: LD_ADDR_VAR 0 3
63646: PUSH
63647: LD_VAR 0 4
63651: PUSH
63652: FOR_IN
63653: IFFALSE 63724
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
63655: LD_VAR 0 3
63659: PPUSH
63660: CALL_OW 310
63664: PPUSH
63665: CALL_OW 266
63669: PUSH
63670: LD_INT 5
63672: EQUAL
63673: PUSH
63674: LD_VAR 0 3
63678: PPUSH
63679: CALL_OW 257
63683: PUSH
63684: LD_INT 1
63686: EQUAL
63687: AND
63688: PUSH
63689: LD_VAR 0 3
63693: PPUSH
63694: CALL_OW 459
63698: NOT
63699: AND
63700: PUSH
63701: LD_VAR 0 7
63705: AND
63706: IFFALSE 63722
// ComChangeProfession ( j , class ) ;
63708: LD_VAR 0 3
63712: PPUSH
63713: LD_VAR 0 7
63717: PPUSH
63718: CALL_OW 123
63722: GO 63652
63724: POP
63725: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63726: LD_ADDR_EXP 66
63730: PUSH
63731: LD_EXP 66
63735: PPUSH
63736: LD_VAR 0 2
63740: PPUSH
63741: LD_INT 0
63743: PPUSH
63744: CALL_OW 1
63748: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
63749: LD_EXP 46
63753: PUSH
63754: LD_VAR 0 2
63758: ARRAY
63759: PUSH
63760: LD_EXP 66
63764: PUSH
63765: LD_VAR 0 2
63769: ARRAY
63770: NOT
63771: AND
63772: PUSH
63773: LD_EXP 45
63777: PUSH
63778: LD_VAR 0 2
63782: ARRAY
63783: NOT
63784: AND
63785: PUSH
63786: LD_EXP 23
63790: PUSH
63791: LD_VAR 0 2
63795: ARRAY
63796: PPUSH
63797: LD_INT 30
63799: PUSH
63800: LD_INT 32
63802: PUSH
63803: EMPTY
63804: LIST
63805: LIST
63806: PPUSH
63807: CALL_OW 72
63811: NOT
63812: AND
63813: PUSH
63814: LD_EXP 23
63818: PUSH
63819: LD_VAR 0 2
63823: ARRAY
63824: PPUSH
63825: LD_INT 2
63827: PUSH
63828: LD_INT 30
63830: PUSH
63831: LD_INT 4
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: PUSH
63838: LD_INT 30
63840: PUSH
63841: LD_INT 5
63843: PUSH
63844: EMPTY
63845: LIST
63846: LIST
63847: PUSH
63848: EMPTY
63849: LIST
63850: LIST
63851: LIST
63852: PPUSH
63853: CALL_OW 72
63857: NOT
63858: AND
63859: IFFALSE 64014
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
63861: LD_ADDR_VAR 0 4
63865: PUSH
63866: LD_EXP 23
63870: PUSH
63871: LD_VAR 0 2
63875: ARRAY
63876: PPUSH
63877: LD_INT 2
63879: PUSH
63880: LD_INT 25
63882: PUSH
63883: LD_INT 1
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 25
63892: PUSH
63893: LD_INT 5
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 25
63902: PUSH
63903: LD_INT 8
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: LD_INT 25
63912: PUSH
63913: LD_INT 9
63915: PUSH
63916: EMPTY
63917: LIST
63918: LIST
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: PPUSH
63927: CALL_OW 72
63931: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
63932: LD_ADDR_VAR 0 4
63936: PUSH
63937: LD_VAR 0 4
63941: PUSH
63942: LD_VAR 0 4
63946: PPUSH
63947: LD_INT 18
63949: PPUSH
63950: CALL 43330 0 2
63954: DIFF
63955: ST_TO_ADDR
// if tmp then
63956: LD_VAR 0 4
63960: IFFALSE 64014
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
63962: LD_ADDR_EXP 66
63966: PUSH
63967: LD_EXP 66
63971: PPUSH
63972: LD_VAR 0 2
63976: PPUSH
63977: LD_INT 1
63979: PPUSH
63980: CALL_OW 1
63984: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
63985: LD_VAR 0 2
63989: PPUSH
63990: LD_VAR 0 4
63994: PPUSH
63995: LD_EXP 48
63999: PUSH
64000: LD_VAR 0 2
64004: ARRAY
64005: PPUSH
64006: CALL 82910 0 3
// exit ;
64010: POP
64011: POP
64012: GO 64145
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
64014: LD_EXP 46
64018: PUSH
64019: LD_VAR 0 2
64023: ARRAY
64024: PUSH
64025: LD_EXP 66
64029: PUSH
64030: LD_VAR 0 2
64034: ARRAY
64035: NOT
64036: AND
64037: PUSH
64038: LD_EXP 45
64042: PUSH
64043: LD_VAR 0 2
64047: ARRAY
64048: AND
64049: IFFALSE 64141
// begin tmp := mc_defender [ i ] ;
64051: LD_ADDR_VAR 0 4
64055: PUSH
64056: LD_EXP 45
64060: PUSH
64061: LD_VAR 0 2
64065: ARRAY
64066: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
64067: LD_ADDR_EXP 45
64071: PUSH
64072: LD_EXP 45
64076: PPUSH
64077: LD_VAR 0 2
64081: PPUSH
64082: EMPTY
64083: PPUSH
64084: CALL_OW 1
64088: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
64089: LD_ADDR_EXP 66
64093: PUSH
64094: LD_EXP 66
64098: PPUSH
64099: LD_VAR 0 2
64103: PPUSH
64104: LD_INT 1
64106: PPUSH
64107: CALL_OW 1
64111: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
64112: LD_VAR 0 2
64116: PPUSH
64117: LD_VAR 0 4
64121: PPUSH
64122: LD_EXP 46
64126: PUSH
64127: LD_VAR 0 2
64131: ARRAY
64132: PPUSH
64133: CALL 83471 0 3
// exit ;
64137: POP
64138: POP
64139: GO 64145
// end ; end ;
64141: GO 63461
64143: POP
64144: POP
// end ;
64145: LD_VAR 0 1
64149: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
64150: LD_INT 0
64152: PPUSH
64153: PPUSH
64154: PPUSH
64155: PPUSH
64156: PPUSH
64157: PPUSH
64158: PPUSH
64159: PPUSH
64160: PPUSH
64161: PPUSH
64162: PPUSH
// if not mc_bases then
64163: LD_EXP 23
64167: NOT
64168: IFFALSE 64172
// exit ;
64170: GO 65259
// for i = 1 to mc_bases do
64172: LD_ADDR_VAR 0 2
64176: PUSH
64177: DOUBLE
64178: LD_INT 1
64180: DEC
64181: ST_TO_ADDR
64182: LD_EXP 23
64186: PUSH
64187: FOR_TO
64188: IFFALSE 65257
// begin tmp := mc_lab [ i ] ;
64190: LD_ADDR_VAR 0 6
64194: PUSH
64195: LD_EXP 56
64199: PUSH
64200: LD_VAR 0 2
64204: ARRAY
64205: ST_TO_ADDR
// if not tmp then
64206: LD_VAR 0 6
64210: NOT
64211: IFFALSE 64215
// continue ;
64213: GO 64187
// idle_lab := 0 ;
64215: LD_ADDR_VAR 0 11
64219: PUSH
64220: LD_INT 0
64222: ST_TO_ADDR
// for j in tmp do
64223: LD_ADDR_VAR 0 3
64227: PUSH
64228: LD_VAR 0 6
64232: PUSH
64233: FOR_IN
64234: IFFALSE 65253
// begin researching := false ;
64236: LD_ADDR_VAR 0 10
64240: PUSH
64241: LD_INT 0
64243: ST_TO_ADDR
// side := GetSide ( j ) ;
64244: LD_ADDR_VAR 0 4
64248: PUSH
64249: LD_VAR 0 3
64253: PPUSH
64254: CALL_OW 255
64258: ST_TO_ADDR
// if not mc_tech [ side ] then
64259: LD_EXP 50
64263: PUSH
64264: LD_VAR 0 4
64268: ARRAY
64269: NOT
64270: IFFALSE 64274
// continue ;
64272: GO 64233
// if BuildingStatus ( j ) = bs_idle then
64274: LD_VAR 0 3
64278: PPUSH
64279: CALL_OW 461
64283: PUSH
64284: LD_INT 2
64286: EQUAL
64287: IFFALSE 64475
// begin if idle_lab and UnitsInside ( j ) < 6 then
64289: LD_VAR 0 11
64293: PUSH
64294: LD_VAR 0 3
64298: PPUSH
64299: CALL_OW 313
64303: PUSH
64304: LD_INT 6
64306: LESS
64307: AND
64308: IFFALSE 64379
// begin tmp2 := UnitsInside ( idle_lab ) ;
64310: LD_ADDR_VAR 0 9
64314: PUSH
64315: LD_VAR 0 11
64319: PPUSH
64320: CALL_OW 313
64324: ST_TO_ADDR
// if tmp2 then
64325: LD_VAR 0 9
64329: IFFALSE 64371
// for x in tmp2 do
64331: LD_ADDR_VAR 0 7
64335: PUSH
64336: LD_VAR 0 9
64340: PUSH
64341: FOR_IN
64342: IFFALSE 64369
// begin ComExitBuilding ( x ) ;
64344: LD_VAR 0 7
64348: PPUSH
64349: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
64353: LD_VAR 0 7
64357: PPUSH
64358: LD_VAR 0 3
64362: PPUSH
64363: CALL_OW 180
// end ;
64367: GO 64341
64369: POP
64370: POP
// idle_lab := 0 ;
64371: LD_ADDR_VAR 0 11
64375: PUSH
64376: LD_INT 0
64378: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
64379: LD_ADDR_VAR 0 5
64383: PUSH
64384: LD_EXP 50
64388: PUSH
64389: LD_VAR 0 4
64393: ARRAY
64394: PUSH
64395: FOR_IN
64396: IFFALSE 64456
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
64398: LD_VAR 0 3
64402: PPUSH
64403: LD_VAR 0 5
64407: PPUSH
64408: CALL_OW 430
64412: PUSH
64413: LD_VAR 0 4
64417: PPUSH
64418: LD_VAR 0 5
64422: PPUSH
64423: CALL 9930 0 2
64427: AND
64428: IFFALSE 64454
// begin researching := true ;
64430: LD_ADDR_VAR 0 10
64434: PUSH
64435: LD_INT 1
64437: ST_TO_ADDR
// ComResearch ( j , t ) ;
64438: LD_VAR 0 3
64442: PPUSH
64443: LD_VAR 0 5
64447: PPUSH
64448: CALL_OW 124
// break ;
64452: GO 64456
// end ;
64454: GO 64395
64456: POP
64457: POP
// if not researching then
64458: LD_VAR 0 10
64462: NOT
64463: IFFALSE 64475
// idle_lab := j ;
64465: LD_ADDR_VAR 0 11
64469: PUSH
64470: LD_VAR 0 3
64474: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
64475: LD_VAR 0 3
64479: PPUSH
64480: CALL_OW 461
64484: PUSH
64485: LD_INT 10
64487: EQUAL
64488: IFFALSE 65076
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
64490: LD_EXP 52
64494: PUSH
64495: LD_VAR 0 2
64499: ARRAY
64500: NOT
64501: PUSH
64502: LD_EXP 53
64506: PUSH
64507: LD_VAR 0 2
64511: ARRAY
64512: NOT
64513: AND
64514: PUSH
64515: LD_EXP 50
64519: PUSH
64520: LD_VAR 0 4
64524: ARRAY
64525: PUSH
64526: LD_INT 1
64528: GREATER
64529: AND
64530: IFFALSE 64661
// begin ComCancel ( j ) ;
64532: LD_VAR 0 3
64536: PPUSH
64537: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
64541: LD_ADDR_EXP 50
64545: PUSH
64546: LD_EXP 50
64550: PPUSH
64551: LD_VAR 0 4
64555: PPUSH
64556: LD_EXP 50
64560: PUSH
64561: LD_VAR 0 4
64565: ARRAY
64566: PPUSH
64567: LD_EXP 50
64571: PUSH
64572: LD_VAR 0 4
64576: ARRAY
64577: PUSH
64578: LD_INT 1
64580: MINUS
64581: PPUSH
64582: LD_EXP 50
64586: PUSH
64587: LD_VAR 0 4
64591: ARRAY
64592: PPUSH
64593: LD_INT 0
64595: PPUSH
64596: CALL 13478 0 4
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
64606: LD_ADDR_EXP 50
64610: PUSH
64611: LD_EXP 50
64615: PPUSH
64616: LD_VAR 0 4
64620: PPUSH
64621: LD_EXP 50
64625: PUSH
64626: LD_VAR 0 4
64630: ARRAY
64631: PPUSH
64632: LD_EXP 50
64636: PUSH
64637: LD_VAR 0 4
64641: ARRAY
64642: PPUSH
64643: LD_INT 1
64645: PPUSH
64646: LD_INT 0
64648: PPUSH
64649: CALL 13478 0 4
64653: PPUSH
64654: CALL_OW 1
64658: ST_TO_ADDR
// continue ;
64659: GO 64233
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
64661: LD_EXP 52
64665: PUSH
64666: LD_VAR 0 2
64670: ARRAY
64671: PUSH
64672: LD_EXP 53
64676: PUSH
64677: LD_VAR 0 2
64681: ARRAY
64682: NOT
64683: AND
64684: IFFALSE 64811
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
64686: LD_ADDR_EXP 53
64690: PUSH
64691: LD_EXP 53
64695: PPUSH
64696: LD_VAR 0 2
64700: PUSH
64701: LD_EXP 53
64705: PUSH
64706: LD_VAR 0 2
64710: ARRAY
64711: PUSH
64712: LD_INT 1
64714: PLUS
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PPUSH
64720: LD_EXP 52
64724: PUSH
64725: LD_VAR 0 2
64729: ARRAY
64730: PUSH
64731: LD_INT 1
64733: ARRAY
64734: PPUSH
64735: CALL 14060 0 3
64739: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
64740: LD_EXP 52
64744: PUSH
64745: LD_VAR 0 2
64749: ARRAY
64750: PUSH
64751: LD_INT 1
64753: ARRAY
64754: PPUSH
64755: LD_INT 112
64757: PPUSH
64758: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
64762: LD_ADDR_VAR 0 9
64766: PUSH
64767: LD_EXP 52
64771: PUSH
64772: LD_VAR 0 2
64776: ARRAY
64777: PPUSH
64778: LD_INT 1
64780: PPUSH
64781: CALL_OW 3
64785: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
64786: LD_ADDR_EXP 52
64790: PUSH
64791: LD_EXP 52
64795: PPUSH
64796: LD_VAR 0 2
64800: PPUSH
64801: LD_VAR 0 9
64805: PPUSH
64806: CALL_OW 1
64810: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
64811: LD_EXP 52
64815: PUSH
64816: LD_VAR 0 2
64820: ARRAY
64821: PUSH
64822: LD_EXP 53
64826: PUSH
64827: LD_VAR 0 2
64831: ARRAY
64832: AND
64833: PUSH
64834: LD_EXP 53
64838: PUSH
64839: LD_VAR 0 2
64843: ARRAY
64844: PUSH
64845: LD_INT 1
64847: ARRAY
64848: PPUSH
64849: CALL_OW 310
64853: NOT
64854: AND
64855: PUSH
64856: LD_VAR 0 3
64860: PPUSH
64861: CALL_OW 313
64865: PUSH
64866: LD_INT 6
64868: EQUAL
64869: AND
64870: IFFALSE 64926
// begin tmp2 := UnitsInside ( j ) ;
64872: LD_ADDR_VAR 0 9
64876: PUSH
64877: LD_VAR 0 3
64881: PPUSH
64882: CALL_OW 313
64886: ST_TO_ADDR
// if tmp2 = 6 then
64887: LD_VAR 0 9
64891: PUSH
64892: LD_INT 6
64894: EQUAL
64895: IFFALSE 64926
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
64897: LD_VAR 0 9
64901: PUSH
64902: LD_INT 1
64904: ARRAY
64905: PPUSH
64906: LD_INT 112
64908: PPUSH
64909: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
64913: LD_VAR 0 9
64917: PUSH
64918: LD_INT 1
64920: ARRAY
64921: PPUSH
64922: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
64926: LD_EXP 53
64930: PUSH
64931: LD_VAR 0 2
64935: ARRAY
64936: PUSH
64937: LD_EXP 53
64941: PUSH
64942: LD_VAR 0 2
64946: ARRAY
64947: PUSH
64948: LD_INT 1
64950: ARRAY
64951: PPUSH
64952: CALL_OW 314
64956: NOT
64957: AND
64958: PUSH
64959: LD_EXP 53
64963: PUSH
64964: LD_VAR 0 2
64968: ARRAY
64969: PUSH
64970: LD_INT 1
64972: ARRAY
64973: PPUSH
64974: CALL_OW 310
64978: NOT
64979: AND
64980: IFFALSE 65006
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
64982: LD_EXP 53
64986: PUSH
64987: LD_VAR 0 2
64991: ARRAY
64992: PUSH
64993: LD_INT 1
64995: ARRAY
64996: PPUSH
64997: LD_VAR 0 3
65001: PPUSH
65002: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
65006: LD_EXP 53
65010: PUSH
65011: LD_VAR 0 2
65015: ARRAY
65016: PUSH
65017: LD_INT 1
65019: ARRAY
65020: PPUSH
65021: CALL_OW 310
65025: PUSH
65026: LD_EXP 53
65030: PUSH
65031: LD_VAR 0 2
65035: ARRAY
65036: PUSH
65037: LD_INT 1
65039: ARRAY
65040: PPUSH
65041: CALL_OW 310
65045: PPUSH
65046: CALL_OW 461
65050: PUSH
65051: LD_INT 3
65053: NONEQUAL
65054: AND
65055: IFFALSE 65076
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
65057: LD_EXP 53
65061: PUSH
65062: LD_VAR 0 2
65066: ARRAY
65067: PUSH
65068: LD_INT 1
65070: ARRAY
65071: PPUSH
65072: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
65076: LD_VAR 0 3
65080: PPUSH
65081: CALL_OW 461
65085: PUSH
65086: LD_INT 6
65088: EQUAL
65089: PUSH
65090: LD_VAR 0 6
65094: PUSH
65095: LD_INT 1
65097: GREATER
65098: AND
65099: IFFALSE 65251
// begin sci := [ ] ;
65101: LD_ADDR_VAR 0 8
65105: PUSH
65106: EMPTY
65107: ST_TO_ADDR
// for x in ( tmp diff j ) do
65108: LD_ADDR_VAR 0 7
65112: PUSH
65113: LD_VAR 0 6
65117: PUSH
65118: LD_VAR 0 3
65122: DIFF
65123: PUSH
65124: FOR_IN
65125: IFFALSE 65177
// begin if sci = 6 then
65127: LD_VAR 0 8
65131: PUSH
65132: LD_INT 6
65134: EQUAL
65135: IFFALSE 65139
// break ;
65137: GO 65177
// if BuildingStatus ( x ) = bs_idle then
65139: LD_VAR 0 7
65143: PPUSH
65144: CALL_OW 461
65148: PUSH
65149: LD_INT 2
65151: EQUAL
65152: IFFALSE 65175
// sci := sci ^ UnitsInside ( x ) ;
65154: LD_ADDR_VAR 0 8
65158: PUSH
65159: LD_VAR 0 8
65163: PUSH
65164: LD_VAR 0 7
65168: PPUSH
65169: CALL_OW 313
65173: ADD
65174: ST_TO_ADDR
// end ;
65175: GO 65124
65177: POP
65178: POP
// if not sci then
65179: LD_VAR 0 8
65183: NOT
65184: IFFALSE 65188
// continue ;
65186: GO 64233
// for x in sci do
65188: LD_ADDR_VAR 0 7
65192: PUSH
65193: LD_VAR 0 8
65197: PUSH
65198: FOR_IN
65199: IFFALSE 65249
// if IsInUnit ( x ) and not HasTask ( x ) then
65201: LD_VAR 0 7
65205: PPUSH
65206: CALL_OW 310
65210: PUSH
65211: LD_VAR 0 7
65215: PPUSH
65216: CALL_OW 314
65220: NOT
65221: AND
65222: IFFALSE 65247
// begin ComExitBuilding ( x ) ;
65224: LD_VAR 0 7
65228: PPUSH
65229: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
65233: LD_VAR 0 7
65237: PPUSH
65238: LD_VAR 0 3
65242: PPUSH
65243: CALL_OW 180
// end ;
65247: GO 65198
65249: POP
65250: POP
// end ; end ;
65251: GO 64233
65253: POP
65254: POP
// end ;
65255: GO 64187
65257: POP
65258: POP
// end ;
65259: LD_VAR 0 1
65263: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
65264: LD_INT 0
65266: PPUSH
65267: PPUSH
// if not mc_bases then
65268: LD_EXP 23
65272: NOT
65273: IFFALSE 65277
// exit ;
65275: GO 65358
// for i = 1 to mc_bases do
65277: LD_ADDR_VAR 0 2
65281: PUSH
65282: DOUBLE
65283: LD_INT 1
65285: DEC
65286: ST_TO_ADDR
65287: LD_EXP 23
65291: PUSH
65292: FOR_TO
65293: IFFALSE 65356
// if mc_mines [ i ] and mc_miners [ i ] then
65295: LD_EXP 36
65299: PUSH
65300: LD_VAR 0 2
65304: ARRAY
65305: PUSH
65306: LD_EXP 37
65310: PUSH
65311: LD_VAR 0 2
65315: ARRAY
65316: AND
65317: IFFALSE 65354
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
65319: LD_EXP 37
65323: PUSH
65324: LD_VAR 0 2
65328: ARRAY
65329: PUSH
65330: LD_INT 1
65332: ARRAY
65333: PPUSH
65334: CALL_OW 255
65338: PPUSH
65339: LD_EXP 36
65343: PUSH
65344: LD_VAR 0 2
65348: ARRAY
65349: PPUSH
65350: CALL 11013 0 2
65354: GO 65292
65356: POP
65357: POP
// end ;
65358: LD_VAR 0 1
65362: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
65363: LD_INT 0
65365: PPUSH
65366: PPUSH
65367: PPUSH
65368: PPUSH
65369: PPUSH
65370: PPUSH
65371: PPUSH
65372: PPUSH
// if not mc_bases or not mc_parking then
65373: LD_EXP 23
65377: NOT
65378: PUSH
65379: LD_EXP 47
65383: NOT
65384: OR
65385: IFFALSE 65389
// exit ;
65387: GO 66099
// for i = 1 to mc_bases do
65389: LD_ADDR_VAR 0 2
65393: PUSH
65394: DOUBLE
65395: LD_INT 1
65397: DEC
65398: ST_TO_ADDR
65399: LD_EXP 23
65403: PUSH
65404: FOR_TO
65405: IFFALSE 66097
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
65407: LD_EXP 23
65411: PUSH
65412: LD_VAR 0 2
65416: ARRAY
65417: NOT
65418: PUSH
65419: LD_EXP 47
65423: PUSH
65424: LD_VAR 0 2
65428: ARRAY
65429: NOT
65430: OR
65431: IFFALSE 65435
// continue ;
65433: GO 65404
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
65435: LD_ADDR_VAR 0 5
65439: PUSH
65440: LD_EXP 23
65444: PUSH
65445: LD_VAR 0 2
65449: ARRAY
65450: PUSH
65451: LD_INT 1
65453: ARRAY
65454: PPUSH
65455: CALL_OW 255
65459: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65460: LD_ADDR_VAR 0 6
65464: PUSH
65465: LD_EXP 23
65469: PUSH
65470: LD_VAR 0 2
65474: ARRAY
65475: PPUSH
65476: LD_INT 30
65478: PUSH
65479: LD_INT 3
65481: PUSH
65482: EMPTY
65483: LIST
65484: LIST
65485: PPUSH
65486: CALL_OW 72
65490: ST_TO_ADDR
// if not fac then
65491: LD_VAR 0 6
65495: NOT
65496: IFFALSE 65547
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65498: LD_ADDR_VAR 0 6
65502: PUSH
65503: LD_EXP 23
65507: PUSH
65508: LD_VAR 0 2
65512: ARRAY
65513: PPUSH
65514: LD_INT 2
65516: PUSH
65517: LD_INT 30
65519: PUSH
65520: LD_INT 0
65522: PUSH
65523: EMPTY
65524: LIST
65525: LIST
65526: PUSH
65527: LD_INT 30
65529: PUSH
65530: LD_INT 1
65532: PUSH
65533: EMPTY
65534: LIST
65535: LIST
65536: PUSH
65537: EMPTY
65538: LIST
65539: LIST
65540: LIST
65541: PPUSH
65542: CALL_OW 72
65546: ST_TO_ADDR
// if not fac then
65547: LD_VAR 0 6
65551: NOT
65552: IFFALSE 65556
// continue ;
65554: GO 65404
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65556: LD_ADDR_VAR 0 7
65560: PUSH
65561: LD_EXP 47
65565: PUSH
65566: LD_VAR 0 2
65570: ARRAY
65571: PPUSH
65572: LD_INT 22
65574: PUSH
65575: LD_VAR 0 5
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 21
65586: PUSH
65587: LD_INT 2
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 3
65596: PUSH
65597: LD_INT 24
65599: PUSH
65600: LD_INT 1000
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: EMPTY
65612: LIST
65613: LIST
65614: LIST
65615: PPUSH
65616: CALL_OW 70
65620: ST_TO_ADDR
// for j in fac do
65621: LD_ADDR_VAR 0 3
65625: PUSH
65626: LD_VAR 0 6
65630: PUSH
65631: FOR_IN
65632: IFFALSE 65713
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65634: LD_ADDR_VAR 0 7
65638: PUSH
65639: LD_VAR 0 7
65643: PUSH
65644: LD_INT 22
65646: PUSH
65647: LD_VAR 0 5
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 91
65658: PUSH
65659: LD_VAR 0 3
65663: PUSH
65664: LD_INT 15
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: LIST
65671: PUSH
65672: LD_INT 21
65674: PUSH
65675: LD_INT 2
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 3
65684: PUSH
65685: LD_INT 24
65687: PUSH
65688: LD_INT 1000
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: PPUSH
65705: CALL_OW 69
65709: UNION
65710: ST_TO_ADDR
65711: GO 65631
65713: POP
65714: POP
// if not vehs then
65715: LD_VAR 0 7
65719: NOT
65720: IFFALSE 65746
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
65722: LD_ADDR_EXP 35
65726: PUSH
65727: LD_EXP 35
65731: PPUSH
65732: LD_VAR 0 2
65736: PPUSH
65737: EMPTY
65738: PPUSH
65739: CALL_OW 1
65743: ST_TO_ADDR
// continue ;
65744: GO 65404
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65746: LD_ADDR_VAR 0 8
65750: PUSH
65751: LD_EXP 23
65755: PUSH
65756: LD_VAR 0 2
65760: ARRAY
65761: PPUSH
65762: LD_INT 30
65764: PUSH
65765: LD_INT 3
65767: PUSH
65768: EMPTY
65769: LIST
65770: LIST
65771: PPUSH
65772: CALL_OW 72
65776: ST_TO_ADDR
// if tmp then
65777: LD_VAR 0 8
65781: IFFALSE 65884
// begin for j in tmp do
65783: LD_ADDR_VAR 0 3
65787: PUSH
65788: LD_VAR 0 8
65792: PUSH
65793: FOR_IN
65794: IFFALSE 65882
// for k in UnitsInside ( j ) do
65796: LD_ADDR_VAR 0 4
65800: PUSH
65801: LD_VAR 0 3
65805: PPUSH
65806: CALL_OW 313
65810: PUSH
65811: FOR_IN
65812: IFFALSE 65878
// if k then
65814: LD_VAR 0 4
65818: IFFALSE 65876
// if not k in mc_repair_vehicle [ i ] then
65820: LD_VAR 0 4
65824: PUSH
65825: LD_EXP 35
65829: PUSH
65830: LD_VAR 0 2
65834: ARRAY
65835: IN
65836: NOT
65837: IFFALSE 65876
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
65839: LD_ADDR_EXP 35
65843: PUSH
65844: LD_EXP 35
65848: PPUSH
65849: LD_VAR 0 2
65853: PPUSH
65854: LD_EXP 35
65858: PUSH
65859: LD_VAR 0 2
65863: ARRAY
65864: PUSH
65865: LD_VAR 0 4
65869: UNION
65870: PPUSH
65871: CALL_OW 1
65875: ST_TO_ADDR
65876: GO 65811
65878: POP
65879: POP
65880: GO 65793
65882: POP
65883: POP
// end ; if not mc_repair_vehicle [ i ] then
65884: LD_EXP 35
65888: PUSH
65889: LD_VAR 0 2
65893: ARRAY
65894: NOT
65895: IFFALSE 65899
// continue ;
65897: GO 65404
// for j in mc_repair_vehicle [ i ] do
65899: LD_ADDR_VAR 0 3
65903: PUSH
65904: LD_EXP 35
65908: PUSH
65909: LD_VAR 0 2
65913: ARRAY
65914: PUSH
65915: FOR_IN
65916: IFFALSE 66093
// begin if GetClass ( j ) <> 3 then
65918: LD_VAR 0 3
65922: PPUSH
65923: CALL_OW 257
65927: PUSH
65928: LD_INT 3
65930: NONEQUAL
65931: IFFALSE 65972
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
65933: LD_ADDR_EXP 35
65937: PUSH
65938: LD_EXP 35
65942: PPUSH
65943: LD_VAR 0 2
65947: PPUSH
65948: LD_EXP 35
65952: PUSH
65953: LD_VAR 0 2
65957: ARRAY
65958: PUSH
65959: LD_VAR 0 3
65963: DIFF
65964: PPUSH
65965: CALL_OW 1
65969: ST_TO_ADDR
// continue ;
65970: GO 65915
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
65972: LD_VAR 0 3
65976: PPUSH
65977: CALL_OW 311
65981: NOT
65982: PUSH
65983: LD_VAR 0 3
65987: PUSH
65988: LD_EXP 26
65992: PUSH
65993: LD_VAR 0 2
65997: ARRAY
65998: PUSH
65999: LD_INT 1
66001: ARRAY
66002: IN
66003: NOT
66004: AND
66005: PUSH
66006: LD_VAR 0 3
66010: PUSH
66011: LD_EXP 26
66015: PUSH
66016: LD_VAR 0 2
66020: ARRAY
66021: PUSH
66022: LD_INT 2
66024: ARRAY
66025: IN
66026: NOT
66027: AND
66028: IFFALSE 66091
// begin if IsInUnit ( j ) then
66030: LD_VAR 0 3
66034: PPUSH
66035: CALL_OW 310
66039: IFFALSE 66052
// ComExitBuilding ( j ) else
66041: LD_VAR 0 3
66045: PPUSH
66046: CALL_OW 122
66050: GO 66091
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
66052: LD_VAR 0 3
66056: PPUSH
66057: LD_VAR 0 7
66061: PUSH
66062: LD_INT 1
66064: ARRAY
66065: PPUSH
66066: CALL 47548 0 2
66070: NOT
66071: IFFALSE 66091
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
66073: LD_VAR 0 3
66077: PPUSH
66078: LD_VAR 0 7
66082: PUSH
66083: LD_INT 1
66085: ARRAY
66086: PPUSH
66087: CALL_OW 129
// end ; end ;
66091: GO 65915
66093: POP
66094: POP
// end ;
66095: GO 65404
66097: POP
66098: POP
// end ;
66099: LD_VAR 0 1
66103: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
66104: LD_INT 0
66106: PPUSH
66107: PPUSH
66108: PPUSH
66109: PPUSH
66110: PPUSH
66111: PPUSH
66112: PPUSH
66113: PPUSH
66114: PPUSH
66115: PPUSH
66116: PPUSH
// if not mc_bases then
66117: LD_EXP 23
66121: NOT
66122: IFFALSE 66126
// exit ;
66124: GO 66928
// for i = 1 to mc_bases do
66126: LD_ADDR_VAR 0 2
66130: PUSH
66131: DOUBLE
66132: LD_INT 1
66134: DEC
66135: ST_TO_ADDR
66136: LD_EXP 23
66140: PUSH
66141: FOR_TO
66142: IFFALSE 66926
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
66144: LD_EXP 51
66148: PUSH
66149: LD_VAR 0 2
66153: ARRAY
66154: NOT
66155: PUSH
66156: LD_EXP 26
66160: PUSH
66161: LD_VAR 0 2
66165: ARRAY
66166: PUSH
66167: LD_INT 1
66169: ARRAY
66170: OR
66171: PUSH
66172: LD_EXP 26
66176: PUSH
66177: LD_VAR 0 2
66181: ARRAY
66182: PUSH
66183: LD_INT 2
66185: ARRAY
66186: OR
66187: PUSH
66188: LD_EXP 49
66192: PUSH
66193: LD_VAR 0 2
66197: ARRAY
66198: PPUSH
66199: LD_INT 1
66201: PPUSH
66202: CALL_OW 325
66206: NOT
66207: OR
66208: PUSH
66209: LD_EXP 46
66213: PUSH
66214: LD_VAR 0 2
66218: ARRAY
66219: OR
66220: IFFALSE 66224
// continue ;
66222: GO 66141
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
66224: LD_ADDR_VAR 0 8
66228: PUSH
66229: LD_EXP 23
66233: PUSH
66234: LD_VAR 0 2
66238: ARRAY
66239: PPUSH
66240: LD_INT 25
66242: PUSH
66243: LD_INT 4
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: LD_INT 50
66252: PUSH
66253: EMPTY
66254: LIST
66255: PUSH
66256: LD_INT 3
66258: PUSH
66259: LD_INT 60
66261: PUSH
66262: EMPTY
66263: LIST
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: LIST
66273: PPUSH
66274: CALL_OW 72
66278: PUSH
66279: LD_EXP 27
66283: PUSH
66284: LD_VAR 0 2
66288: ARRAY
66289: DIFF
66290: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66291: LD_ADDR_VAR 0 9
66295: PUSH
66296: LD_EXP 23
66300: PUSH
66301: LD_VAR 0 2
66305: ARRAY
66306: PPUSH
66307: LD_INT 2
66309: PUSH
66310: LD_INT 30
66312: PUSH
66313: LD_INT 0
66315: PUSH
66316: EMPTY
66317: LIST
66318: LIST
66319: PUSH
66320: LD_INT 30
66322: PUSH
66323: LD_INT 1
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: EMPTY
66331: LIST
66332: LIST
66333: LIST
66334: PPUSH
66335: CALL_OW 72
66339: ST_TO_ADDR
// if not tmp or not dep then
66340: LD_VAR 0 8
66344: NOT
66345: PUSH
66346: LD_VAR 0 9
66350: NOT
66351: OR
66352: IFFALSE 66356
// continue ;
66354: GO 66141
// side := GetSide ( tmp [ 1 ] ) ;
66356: LD_ADDR_VAR 0 11
66360: PUSH
66361: LD_VAR 0 8
66365: PUSH
66366: LD_INT 1
66368: ARRAY
66369: PPUSH
66370: CALL_OW 255
66374: ST_TO_ADDR
// dep := dep [ 1 ] ;
66375: LD_ADDR_VAR 0 9
66379: PUSH
66380: LD_VAR 0 9
66384: PUSH
66385: LD_INT 1
66387: ARRAY
66388: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
66389: LD_ADDR_VAR 0 7
66393: PUSH
66394: LD_EXP 51
66398: PUSH
66399: LD_VAR 0 2
66403: ARRAY
66404: PPUSH
66405: LD_INT 22
66407: PUSH
66408: LD_INT 0
66410: PUSH
66411: EMPTY
66412: LIST
66413: LIST
66414: PUSH
66415: LD_INT 25
66417: PUSH
66418: LD_INT 12
66420: PUSH
66421: EMPTY
66422: LIST
66423: LIST
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PPUSH
66429: CALL_OW 70
66433: PUSH
66434: LD_INT 22
66436: PUSH
66437: LD_INT 0
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 25
66446: PUSH
66447: LD_INT 12
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 91
66456: PUSH
66457: LD_VAR 0 9
66461: PUSH
66462: LD_INT 20
66464: PUSH
66465: EMPTY
66466: LIST
66467: LIST
66468: LIST
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: LIST
66474: PPUSH
66475: CALL_OW 69
66479: UNION
66480: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
66481: LD_ADDR_VAR 0 10
66485: PUSH
66486: LD_EXP 51
66490: PUSH
66491: LD_VAR 0 2
66495: ARRAY
66496: PPUSH
66497: LD_INT 81
66499: PUSH
66500: LD_VAR 0 11
66504: PUSH
66505: EMPTY
66506: LIST
66507: LIST
66508: PPUSH
66509: CALL_OW 70
66513: ST_TO_ADDR
// if not apes or danger_at_area then
66514: LD_VAR 0 7
66518: NOT
66519: PUSH
66520: LD_VAR 0 10
66524: OR
66525: IFFALSE 66575
// begin if mc_taming [ i ] then
66527: LD_EXP 54
66531: PUSH
66532: LD_VAR 0 2
66536: ARRAY
66537: IFFALSE 66573
// begin MC_Reset ( i , 121 ) ;
66539: LD_VAR 0 2
66543: PPUSH
66544: LD_INT 121
66546: PPUSH
66547: CALL 51777 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66551: LD_ADDR_EXP 54
66555: PUSH
66556: LD_EXP 54
66560: PPUSH
66561: LD_VAR 0 2
66565: PPUSH
66566: EMPTY
66567: PPUSH
66568: CALL_OW 1
66572: ST_TO_ADDR
// end ; continue ;
66573: GO 66141
// end ; for j in tmp do
66575: LD_ADDR_VAR 0 3
66579: PUSH
66580: LD_VAR 0 8
66584: PUSH
66585: FOR_IN
66586: IFFALSE 66922
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
66588: LD_VAR 0 3
66592: PUSH
66593: LD_EXP 54
66597: PUSH
66598: LD_VAR 0 2
66602: ARRAY
66603: IN
66604: NOT
66605: PUSH
66606: LD_EXP 54
66610: PUSH
66611: LD_VAR 0 2
66615: ARRAY
66616: PUSH
66617: LD_INT 3
66619: LESS
66620: AND
66621: IFFALSE 66679
// begin SetTag ( j , 121 ) ;
66623: LD_VAR 0 3
66627: PPUSH
66628: LD_INT 121
66630: PPUSH
66631: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
66635: LD_ADDR_EXP 54
66639: PUSH
66640: LD_EXP 54
66644: PPUSH
66645: LD_VAR 0 2
66649: PUSH
66650: LD_EXP 54
66654: PUSH
66655: LD_VAR 0 2
66659: ARRAY
66660: PUSH
66661: LD_INT 1
66663: PLUS
66664: PUSH
66665: EMPTY
66666: LIST
66667: LIST
66668: PPUSH
66669: LD_VAR 0 3
66673: PPUSH
66674: CALL 14060 0 3
66678: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
66679: LD_VAR 0 3
66683: PUSH
66684: LD_EXP 54
66688: PUSH
66689: LD_VAR 0 2
66693: ARRAY
66694: IN
66695: IFFALSE 66920
// begin if GetClass ( j ) <> 4 then
66697: LD_VAR 0 3
66701: PPUSH
66702: CALL_OW 257
66706: PUSH
66707: LD_INT 4
66709: NONEQUAL
66710: IFFALSE 66763
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
66712: LD_ADDR_EXP 54
66716: PUSH
66717: LD_EXP 54
66721: PPUSH
66722: LD_VAR 0 2
66726: PPUSH
66727: LD_EXP 54
66731: PUSH
66732: LD_VAR 0 2
66736: ARRAY
66737: PUSH
66738: LD_VAR 0 3
66742: DIFF
66743: PPUSH
66744: CALL_OW 1
66748: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66749: LD_VAR 0 3
66753: PPUSH
66754: LD_INT 0
66756: PPUSH
66757: CALL_OW 109
// continue ;
66761: GO 66585
// end ; if IsInUnit ( j ) then
66763: LD_VAR 0 3
66767: PPUSH
66768: CALL_OW 310
66772: IFFALSE 66783
// ComExitBuilding ( j ) ;
66774: LD_VAR 0 3
66778: PPUSH
66779: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
66783: LD_ADDR_VAR 0 6
66787: PUSH
66788: LD_VAR 0 7
66792: PPUSH
66793: LD_VAR 0 3
66797: PPUSH
66798: CALL_OW 74
66802: ST_TO_ADDR
// if not ape then
66803: LD_VAR 0 6
66807: NOT
66808: IFFALSE 66812
// break ;
66810: GO 66922
// x := GetX ( ape ) ;
66812: LD_ADDR_VAR 0 4
66816: PUSH
66817: LD_VAR 0 6
66821: PPUSH
66822: CALL_OW 250
66826: ST_TO_ADDR
// y := GetY ( ape ) ;
66827: LD_ADDR_VAR 0 5
66831: PUSH
66832: LD_VAR 0 6
66836: PPUSH
66837: CALL_OW 251
66841: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
66842: LD_VAR 0 4
66846: PPUSH
66847: LD_VAR 0 5
66851: PPUSH
66852: CALL_OW 488
66856: NOT
66857: PUSH
66858: LD_VAR 0 11
66862: PPUSH
66863: LD_VAR 0 4
66867: PPUSH
66868: LD_VAR 0 5
66872: PPUSH
66873: LD_INT 20
66875: PPUSH
66876: CALL 14956 0 4
66880: PUSH
66881: LD_INT 4
66883: ARRAY
66884: OR
66885: IFFALSE 66889
// break ;
66887: GO 66922
// if not HasTask ( j ) then
66889: LD_VAR 0 3
66893: PPUSH
66894: CALL_OW 314
66898: NOT
66899: IFFALSE 66920
// ComTameXY ( j , x , y ) ;
66901: LD_VAR 0 3
66905: PPUSH
66906: LD_VAR 0 4
66910: PPUSH
66911: LD_VAR 0 5
66915: PPUSH
66916: CALL_OW 131
// end ; end ;
66920: GO 66585
66922: POP
66923: POP
// end ;
66924: GO 66141
66926: POP
66927: POP
// end ;
66928: LD_VAR 0 1
66932: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
66933: LD_INT 0
66935: PPUSH
66936: PPUSH
66937: PPUSH
66938: PPUSH
66939: PPUSH
66940: PPUSH
66941: PPUSH
66942: PPUSH
// if not mc_bases then
66943: LD_EXP 23
66947: NOT
66948: IFFALSE 66952
// exit ;
66950: GO 67578
// for i = 1 to mc_bases do
66952: LD_ADDR_VAR 0 2
66956: PUSH
66957: DOUBLE
66958: LD_INT 1
66960: DEC
66961: ST_TO_ADDR
66962: LD_EXP 23
66966: PUSH
66967: FOR_TO
66968: IFFALSE 67576
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
66970: LD_EXP 52
66974: PUSH
66975: LD_VAR 0 2
66979: ARRAY
66980: NOT
66981: PUSH
66982: LD_EXP 52
66986: PUSH
66987: LD_VAR 0 2
66991: ARRAY
66992: PPUSH
66993: LD_INT 25
66995: PUSH
66996: LD_INT 12
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PPUSH
67003: CALL_OW 72
67007: NOT
67008: OR
67009: IFFALSE 67013
// continue ;
67011: GO 66967
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
67013: LD_ADDR_VAR 0 5
67017: PUSH
67018: LD_EXP 52
67022: PUSH
67023: LD_VAR 0 2
67027: ARRAY
67028: PUSH
67029: LD_INT 1
67031: ARRAY
67032: PPUSH
67033: CALL_OW 255
67037: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
67038: LD_VAR 0 5
67042: PPUSH
67043: LD_INT 2
67045: PPUSH
67046: CALL_OW 325
67050: IFFALSE 67303
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
67052: LD_ADDR_VAR 0 4
67056: PUSH
67057: LD_EXP 52
67061: PUSH
67062: LD_VAR 0 2
67066: ARRAY
67067: PPUSH
67068: LD_INT 25
67070: PUSH
67071: LD_INT 16
67073: PUSH
67074: EMPTY
67075: LIST
67076: LIST
67077: PPUSH
67078: CALL_OW 72
67082: ST_TO_ADDR
// if tmp < 6 then
67083: LD_VAR 0 4
67087: PUSH
67088: LD_INT 6
67090: LESS
67091: IFFALSE 67303
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67093: LD_ADDR_VAR 0 6
67097: PUSH
67098: LD_EXP 23
67102: PUSH
67103: LD_VAR 0 2
67107: ARRAY
67108: PPUSH
67109: LD_INT 2
67111: PUSH
67112: LD_INT 30
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 30
67124: PUSH
67125: LD_INT 1
67127: PUSH
67128: EMPTY
67129: LIST
67130: LIST
67131: PUSH
67132: EMPTY
67133: LIST
67134: LIST
67135: LIST
67136: PPUSH
67137: CALL_OW 72
67141: ST_TO_ADDR
// if depot then
67142: LD_VAR 0 6
67146: IFFALSE 67303
// begin selected := 0 ;
67148: LD_ADDR_VAR 0 7
67152: PUSH
67153: LD_INT 0
67155: ST_TO_ADDR
// for j in depot do
67156: LD_ADDR_VAR 0 3
67160: PUSH
67161: LD_VAR 0 6
67165: PUSH
67166: FOR_IN
67167: IFFALSE 67198
// begin if UnitsInside ( j ) < 6 then
67169: LD_VAR 0 3
67173: PPUSH
67174: CALL_OW 313
67178: PUSH
67179: LD_INT 6
67181: LESS
67182: IFFALSE 67196
// begin selected := j ;
67184: LD_ADDR_VAR 0 7
67188: PUSH
67189: LD_VAR 0 3
67193: ST_TO_ADDR
// break ;
67194: GO 67198
// end ; end ;
67196: GO 67166
67198: POP
67199: POP
// if selected then
67200: LD_VAR 0 7
67204: IFFALSE 67303
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
67206: LD_ADDR_VAR 0 3
67210: PUSH
67211: LD_EXP 52
67215: PUSH
67216: LD_VAR 0 2
67220: ARRAY
67221: PPUSH
67222: LD_INT 25
67224: PUSH
67225: LD_INT 12
67227: PUSH
67228: EMPTY
67229: LIST
67230: LIST
67231: PPUSH
67232: CALL_OW 72
67236: PUSH
67237: FOR_IN
67238: IFFALSE 67301
// if not HasTask ( j ) then
67240: LD_VAR 0 3
67244: PPUSH
67245: CALL_OW 314
67249: NOT
67250: IFFALSE 67299
// begin if not IsInUnit ( j ) then
67252: LD_VAR 0 3
67256: PPUSH
67257: CALL_OW 310
67261: NOT
67262: IFFALSE 67278
// ComEnterUnit ( j , selected ) ;
67264: LD_VAR 0 3
67268: PPUSH
67269: LD_VAR 0 7
67273: PPUSH
67274: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
67278: LD_VAR 0 3
67282: PPUSH
67283: LD_INT 16
67285: PPUSH
67286: CALL_OW 183
// AddComExitBuilding ( j ) ;
67290: LD_VAR 0 3
67294: PPUSH
67295: CALL_OW 182
// end ;
67299: GO 67237
67301: POP
67302: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
67303: LD_VAR 0 5
67307: PPUSH
67308: LD_INT 11
67310: PPUSH
67311: CALL_OW 325
67315: IFFALSE 67574
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
67317: LD_ADDR_VAR 0 4
67321: PUSH
67322: LD_EXP 52
67326: PUSH
67327: LD_VAR 0 2
67331: ARRAY
67332: PPUSH
67333: LD_INT 25
67335: PUSH
67336: LD_INT 16
67338: PUSH
67339: EMPTY
67340: LIST
67341: LIST
67342: PPUSH
67343: CALL_OW 72
67347: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
67348: LD_VAR 0 4
67352: PUSH
67353: LD_INT 6
67355: GREATEREQUAL
67356: PUSH
67357: LD_VAR 0 5
67361: PPUSH
67362: LD_INT 2
67364: PPUSH
67365: CALL_OW 325
67369: NOT
67370: OR
67371: IFFALSE 67574
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
67373: LD_ADDR_VAR 0 8
67377: PUSH
67378: LD_EXP 23
67382: PUSH
67383: LD_VAR 0 2
67387: ARRAY
67388: PPUSH
67389: LD_INT 2
67391: PUSH
67392: LD_INT 30
67394: PUSH
67395: LD_INT 4
67397: PUSH
67398: EMPTY
67399: LIST
67400: LIST
67401: PUSH
67402: LD_INT 30
67404: PUSH
67405: LD_INT 5
67407: PUSH
67408: EMPTY
67409: LIST
67410: LIST
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: LIST
67416: PPUSH
67417: CALL_OW 72
67421: ST_TO_ADDR
// if barracks then
67422: LD_VAR 0 8
67426: IFFALSE 67574
// begin selected := 0 ;
67428: LD_ADDR_VAR 0 7
67432: PUSH
67433: LD_INT 0
67435: ST_TO_ADDR
// for j in barracks do
67436: LD_ADDR_VAR 0 3
67440: PUSH
67441: LD_VAR 0 8
67445: PUSH
67446: FOR_IN
67447: IFFALSE 67478
// begin if UnitsInside ( j ) < 6 then
67449: LD_VAR 0 3
67453: PPUSH
67454: CALL_OW 313
67458: PUSH
67459: LD_INT 6
67461: LESS
67462: IFFALSE 67476
// begin selected := j ;
67464: LD_ADDR_VAR 0 7
67468: PUSH
67469: LD_VAR 0 3
67473: ST_TO_ADDR
// break ;
67474: GO 67478
// end ; end ;
67476: GO 67446
67478: POP
67479: POP
// if selected then
67480: LD_VAR 0 7
67484: IFFALSE 67574
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
67486: LD_ADDR_VAR 0 3
67490: PUSH
67491: LD_EXP 52
67495: PUSH
67496: LD_VAR 0 2
67500: ARRAY
67501: PPUSH
67502: LD_INT 25
67504: PUSH
67505: LD_INT 12
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PPUSH
67512: CALL_OW 72
67516: PUSH
67517: FOR_IN
67518: IFFALSE 67572
// if not IsInUnit ( j ) and not HasTask ( j ) then
67520: LD_VAR 0 3
67524: PPUSH
67525: CALL_OW 310
67529: NOT
67530: PUSH
67531: LD_VAR 0 3
67535: PPUSH
67536: CALL_OW 314
67540: NOT
67541: AND
67542: IFFALSE 67570
// begin ComEnterUnit ( j , selected ) ;
67544: LD_VAR 0 3
67548: PPUSH
67549: LD_VAR 0 7
67553: PPUSH
67554: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
67558: LD_VAR 0 3
67562: PPUSH
67563: LD_INT 15
67565: PPUSH
67566: CALL_OW 183
// end ;
67570: GO 67517
67572: POP
67573: POP
// end ; end ; end ; end ; end ;
67574: GO 66967
67576: POP
67577: POP
// end ;
67578: LD_VAR 0 1
67582: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
67583: LD_INT 0
67585: PPUSH
67586: PPUSH
67587: PPUSH
67588: PPUSH
// if not mc_bases then
67589: LD_EXP 23
67593: NOT
67594: IFFALSE 67598
// exit ;
67596: GO 67776
// for i = 1 to mc_bases do
67598: LD_ADDR_VAR 0 2
67602: PUSH
67603: DOUBLE
67604: LD_INT 1
67606: DEC
67607: ST_TO_ADDR
67608: LD_EXP 23
67612: PUSH
67613: FOR_TO
67614: IFFALSE 67774
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
67616: LD_ADDR_VAR 0 4
67620: PUSH
67621: LD_EXP 23
67625: PUSH
67626: LD_VAR 0 2
67630: ARRAY
67631: PPUSH
67632: LD_INT 25
67634: PUSH
67635: LD_INT 9
67637: PUSH
67638: EMPTY
67639: LIST
67640: LIST
67641: PPUSH
67642: CALL_OW 72
67646: ST_TO_ADDR
// if not tmp then
67647: LD_VAR 0 4
67651: NOT
67652: IFFALSE 67656
// continue ;
67654: GO 67613
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
67656: LD_EXP 49
67660: PUSH
67661: LD_VAR 0 2
67665: ARRAY
67666: PPUSH
67667: LD_INT 29
67669: PPUSH
67670: CALL_OW 325
67674: NOT
67675: PUSH
67676: LD_EXP 49
67680: PUSH
67681: LD_VAR 0 2
67685: ARRAY
67686: PPUSH
67687: LD_INT 28
67689: PPUSH
67690: CALL_OW 325
67694: NOT
67695: AND
67696: IFFALSE 67700
// continue ;
67698: GO 67613
// for j in tmp do
67700: LD_ADDR_VAR 0 3
67704: PUSH
67705: LD_VAR 0 4
67709: PUSH
67710: FOR_IN
67711: IFFALSE 67770
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
67713: LD_VAR 0 3
67717: PUSH
67718: LD_EXP 26
67722: PUSH
67723: LD_VAR 0 2
67727: ARRAY
67728: PUSH
67729: LD_INT 1
67731: ARRAY
67732: IN
67733: NOT
67734: PUSH
67735: LD_VAR 0 3
67739: PUSH
67740: LD_EXP 26
67744: PUSH
67745: LD_VAR 0 2
67749: ARRAY
67750: PUSH
67751: LD_INT 2
67753: ARRAY
67754: IN
67755: NOT
67756: AND
67757: IFFALSE 67768
// ComSpaceTimeShoot ( j ) ;
67759: LD_VAR 0 3
67763: PPUSH
67764: CALL 10021 0 1
67768: GO 67710
67770: POP
67771: POP
// end ;
67772: GO 67613
67774: POP
67775: POP
// end ;
67776: LD_VAR 0 1
67780: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
67781: LD_INT 0
67783: PPUSH
67784: PPUSH
67785: PPUSH
67786: PPUSH
67787: PPUSH
67788: PPUSH
67789: PPUSH
67790: PPUSH
67791: PPUSH
// if not mc_bases then
67792: LD_EXP 23
67796: NOT
67797: IFFALSE 67801
// exit ;
67799: GO 68423
// for i = 1 to mc_bases do
67801: LD_ADDR_VAR 0 2
67805: PUSH
67806: DOUBLE
67807: LD_INT 1
67809: DEC
67810: ST_TO_ADDR
67811: LD_EXP 23
67815: PUSH
67816: FOR_TO
67817: IFFALSE 68421
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
67819: LD_EXP 58
67823: PUSH
67824: LD_VAR 0 2
67828: ARRAY
67829: NOT
67830: PUSH
67831: LD_INT 38
67833: PPUSH
67834: LD_EXP 49
67838: PUSH
67839: LD_VAR 0 2
67843: ARRAY
67844: PPUSH
67845: CALL_OW 321
67849: PUSH
67850: LD_INT 2
67852: NONEQUAL
67853: OR
67854: IFFALSE 67858
// continue ;
67856: GO 67816
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
67858: LD_ADDR_VAR 0 8
67862: PUSH
67863: LD_EXP 23
67867: PUSH
67868: LD_VAR 0 2
67872: ARRAY
67873: PPUSH
67874: LD_INT 30
67876: PUSH
67877: LD_INT 34
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PPUSH
67884: CALL_OW 72
67888: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
67889: LD_ADDR_VAR 0 9
67893: PUSH
67894: LD_EXP 23
67898: PUSH
67899: LD_VAR 0 2
67903: ARRAY
67904: PPUSH
67905: LD_INT 25
67907: PUSH
67908: LD_INT 4
67910: PUSH
67911: EMPTY
67912: LIST
67913: LIST
67914: PPUSH
67915: CALL_OW 72
67919: PPUSH
67920: LD_INT 0
67922: PPUSH
67923: CALL 43330 0 2
67927: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
67928: LD_VAR 0 9
67932: NOT
67933: PUSH
67934: LD_VAR 0 8
67938: NOT
67939: OR
67940: PUSH
67941: LD_EXP 23
67945: PUSH
67946: LD_VAR 0 2
67950: ARRAY
67951: PPUSH
67952: LD_INT 124
67954: PPUSH
67955: CALL 43330 0 2
67959: OR
67960: IFFALSE 67964
// continue ;
67962: GO 67816
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
67964: LD_EXP 59
67968: PUSH
67969: LD_VAR 0 2
67973: ARRAY
67974: PUSH
67975: LD_EXP 58
67979: PUSH
67980: LD_VAR 0 2
67984: ARRAY
67985: LESS
67986: PUSH
67987: LD_EXP 59
67991: PUSH
67992: LD_VAR 0 2
67996: ARRAY
67997: PUSH
67998: LD_VAR 0 8
68002: LESS
68003: AND
68004: IFFALSE 68419
// begin tmp := sci [ 1 ] ;
68006: LD_ADDR_VAR 0 7
68010: PUSH
68011: LD_VAR 0 9
68015: PUSH
68016: LD_INT 1
68018: ARRAY
68019: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
68020: LD_VAR 0 7
68024: PPUSH
68025: LD_INT 124
68027: PPUSH
68028: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
68032: LD_ADDR_VAR 0 3
68036: PUSH
68037: DOUBLE
68038: LD_EXP 58
68042: PUSH
68043: LD_VAR 0 2
68047: ARRAY
68048: INC
68049: ST_TO_ADDR
68050: LD_EXP 58
68054: PUSH
68055: LD_VAR 0 2
68059: ARRAY
68060: PUSH
68061: FOR_DOWNTO
68062: IFFALSE 68405
// begin if IsInUnit ( tmp ) then
68064: LD_VAR 0 7
68068: PPUSH
68069: CALL_OW 310
68073: IFFALSE 68084
// ComExitBuilding ( tmp ) ;
68075: LD_VAR 0 7
68079: PPUSH
68080: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
68084: LD_INT 35
68086: PPUSH
68087: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
68091: LD_VAR 0 7
68095: PPUSH
68096: CALL_OW 310
68100: NOT
68101: PUSH
68102: LD_VAR 0 7
68106: PPUSH
68107: CALL_OW 314
68111: NOT
68112: AND
68113: IFFALSE 68084
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
68115: LD_ADDR_VAR 0 6
68119: PUSH
68120: LD_VAR 0 7
68124: PPUSH
68125: CALL_OW 250
68129: PUSH
68130: LD_VAR 0 7
68134: PPUSH
68135: CALL_OW 251
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
68144: LD_INT 35
68146: PPUSH
68147: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
68151: LD_ADDR_VAR 0 4
68155: PUSH
68156: LD_EXP 58
68160: PUSH
68161: LD_VAR 0 2
68165: ARRAY
68166: PUSH
68167: LD_VAR 0 3
68171: ARRAY
68172: PUSH
68173: LD_INT 1
68175: ARRAY
68176: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
68177: LD_ADDR_VAR 0 5
68181: PUSH
68182: LD_EXP 58
68186: PUSH
68187: LD_VAR 0 2
68191: ARRAY
68192: PUSH
68193: LD_VAR 0 3
68197: ARRAY
68198: PUSH
68199: LD_INT 2
68201: ARRAY
68202: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
68203: LD_VAR 0 7
68207: PPUSH
68208: LD_INT 10
68210: PPUSH
68211: CALL 16659 0 2
68215: PUSH
68216: LD_INT 4
68218: ARRAY
68219: IFFALSE 68257
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
68221: LD_VAR 0 7
68225: PPUSH
68226: LD_VAR 0 6
68230: PUSH
68231: LD_INT 1
68233: ARRAY
68234: PPUSH
68235: LD_VAR 0 6
68239: PUSH
68240: LD_INT 2
68242: ARRAY
68243: PPUSH
68244: CALL_OW 111
// wait ( 0 0$10 ) ;
68248: LD_INT 350
68250: PPUSH
68251: CALL_OW 67
// end else
68255: GO 68283
// begin ComMoveXY ( tmp , x , y ) ;
68257: LD_VAR 0 7
68261: PPUSH
68262: LD_VAR 0 4
68266: PPUSH
68267: LD_VAR 0 5
68271: PPUSH
68272: CALL_OW 111
// wait ( 0 0$3 ) ;
68276: LD_INT 105
68278: PPUSH
68279: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
68283: LD_VAR 0 7
68287: PPUSH
68288: LD_VAR 0 4
68292: PPUSH
68293: LD_VAR 0 5
68297: PPUSH
68298: CALL_OW 307
68302: IFFALSE 68144
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
68304: LD_VAR 0 7
68308: PPUSH
68309: LD_VAR 0 4
68313: PPUSH
68314: LD_VAR 0 5
68318: PPUSH
68319: LD_VAR 0 8
68323: PUSH
68324: LD_VAR 0 3
68328: ARRAY
68329: PPUSH
68330: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
68334: LD_INT 35
68336: PPUSH
68337: CALL_OW 67
// until not HasTask ( tmp ) ;
68341: LD_VAR 0 7
68345: PPUSH
68346: CALL_OW 314
68350: NOT
68351: IFFALSE 68334
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
68353: LD_ADDR_EXP 59
68357: PUSH
68358: LD_EXP 59
68362: PPUSH
68363: LD_VAR 0 2
68367: PUSH
68368: LD_EXP 59
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: PUSH
68379: LD_INT 1
68381: PLUS
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: PPUSH
68387: LD_VAR 0 8
68391: PUSH
68392: LD_VAR 0 3
68396: ARRAY
68397: PPUSH
68398: CALL 14060 0 3
68402: ST_TO_ADDR
// end ;
68403: GO 68061
68405: POP
68406: POP
// MC_Reset ( i , 124 ) ;
68407: LD_VAR 0 2
68411: PPUSH
68412: LD_INT 124
68414: PPUSH
68415: CALL 51777 0 2
// end ; end ;
68419: GO 67816
68421: POP
68422: POP
// end ;
68423: LD_VAR 0 1
68427: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
68428: LD_INT 0
68430: PPUSH
68431: PPUSH
68432: PPUSH
// if not mc_bases then
68433: LD_EXP 23
68437: NOT
68438: IFFALSE 68442
// exit ;
68440: GO 69048
// for i = 1 to mc_bases do
68442: LD_ADDR_VAR 0 2
68446: PUSH
68447: DOUBLE
68448: LD_INT 1
68450: DEC
68451: ST_TO_ADDR
68452: LD_EXP 23
68456: PUSH
68457: FOR_TO
68458: IFFALSE 69046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
68460: LD_ADDR_VAR 0 3
68464: PUSH
68465: LD_EXP 23
68469: PUSH
68470: LD_VAR 0 2
68474: ARRAY
68475: PPUSH
68476: LD_INT 25
68478: PUSH
68479: LD_INT 4
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PPUSH
68486: CALL_OW 72
68490: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68491: LD_VAR 0 3
68495: NOT
68496: PUSH
68497: LD_EXP 60
68501: PUSH
68502: LD_VAR 0 2
68506: ARRAY
68507: NOT
68508: OR
68509: PUSH
68510: LD_EXP 23
68514: PUSH
68515: LD_VAR 0 2
68519: ARRAY
68520: PPUSH
68521: LD_INT 2
68523: PUSH
68524: LD_INT 30
68526: PUSH
68527: LD_INT 0
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 30
68536: PUSH
68537: LD_INT 1
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: LIST
68548: PPUSH
68549: CALL_OW 72
68553: NOT
68554: OR
68555: IFFALSE 68605
// begin if mc_deposits_finder [ i ] then
68557: LD_EXP 61
68561: PUSH
68562: LD_VAR 0 2
68566: ARRAY
68567: IFFALSE 68603
// begin MC_Reset ( i , 125 ) ;
68569: LD_VAR 0 2
68573: PPUSH
68574: LD_INT 125
68576: PPUSH
68577: CALL 51777 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68581: LD_ADDR_EXP 61
68585: PUSH
68586: LD_EXP 61
68590: PPUSH
68591: LD_VAR 0 2
68595: PPUSH
68596: EMPTY
68597: PPUSH
68598: CALL_OW 1
68602: ST_TO_ADDR
// end ; continue ;
68603: GO 68457
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
68605: LD_EXP 60
68609: PUSH
68610: LD_VAR 0 2
68614: ARRAY
68615: PUSH
68616: LD_INT 1
68618: ARRAY
68619: PUSH
68620: LD_INT 3
68622: ARRAY
68623: PUSH
68624: LD_INT 1
68626: EQUAL
68627: PUSH
68628: LD_INT 20
68630: PPUSH
68631: LD_EXP 49
68635: PUSH
68636: LD_VAR 0 2
68640: ARRAY
68641: PPUSH
68642: CALL_OW 321
68646: PUSH
68647: LD_INT 2
68649: NONEQUAL
68650: AND
68651: IFFALSE 68701
// begin if mc_deposits_finder [ i ] then
68653: LD_EXP 61
68657: PUSH
68658: LD_VAR 0 2
68662: ARRAY
68663: IFFALSE 68699
// begin MC_Reset ( i , 125 ) ;
68665: LD_VAR 0 2
68669: PPUSH
68670: LD_INT 125
68672: PPUSH
68673: CALL 51777 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
68677: LD_ADDR_EXP 61
68681: PUSH
68682: LD_EXP 61
68686: PPUSH
68687: LD_VAR 0 2
68691: PPUSH
68692: EMPTY
68693: PPUSH
68694: CALL_OW 1
68698: ST_TO_ADDR
// end ; continue ;
68699: GO 68457
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
68701: LD_EXP 60
68705: PUSH
68706: LD_VAR 0 2
68710: ARRAY
68711: PUSH
68712: LD_INT 1
68714: ARRAY
68715: PUSH
68716: LD_INT 1
68718: ARRAY
68719: PPUSH
68720: LD_EXP 60
68724: PUSH
68725: LD_VAR 0 2
68729: ARRAY
68730: PUSH
68731: LD_INT 1
68733: ARRAY
68734: PUSH
68735: LD_INT 2
68737: ARRAY
68738: PPUSH
68739: LD_EXP 49
68743: PUSH
68744: LD_VAR 0 2
68748: ARRAY
68749: PPUSH
68750: CALL_OW 440
68754: IFFALSE 68797
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
68756: LD_ADDR_EXP 60
68760: PUSH
68761: LD_EXP 60
68765: PPUSH
68766: LD_VAR 0 2
68770: PPUSH
68771: LD_EXP 60
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PPUSH
68782: LD_INT 1
68784: PPUSH
68785: CALL_OW 3
68789: PPUSH
68790: CALL_OW 1
68794: ST_TO_ADDR
68795: GO 69044
// begin if not mc_deposits_finder [ i ] then
68797: LD_EXP 61
68801: PUSH
68802: LD_VAR 0 2
68806: ARRAY
68807: NOT
68808: IFFALSE 68860
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
68810: LD_ADDR_EXP 61
68814: PUSH
68815: LD_EXP 61
68819: PPUSH
68820: LD_VAR 0 2
68824: PPUSH
68825: LD_VAR 0 3
68829: PUSH
68830: LD_INT 1
68832: ARRAY
68833: PUSH
68834: EMPTY
68835: LIST
68836: PPUSH
68837: CALL_OW 1
68841: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
68842: LD_VAR 0 3
68846: PUSH
68847: LD_INT 1
68849: ARRAY
68850: PPUSH
68851: LD_INT 125
68853: PPUSH
68854: CALL_OW 109
// end else
68858: GO 69044
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
68860: LD_EXP 61
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PUSH
68871: LD_INT 1
68873: ARRAY
68874: PPUSH
68875: CALL_OW 310
68879: IFFALSE 68902
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
68881: LD_EXP 61
68885: PUSH
68886: LD_VAR 0 2
68890: ARRAY
68891: PUSH
68892: LD_INT 1
68894: ARRAY
68895: PPUSH
68896: CALL_OW 122
68900: GO 69044
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
68902: LD_EXP 61
68906: PUSH
68907: LD_VAR 0 2
68911: ARRAY
68912: PUSH
68913: LD_INT 1
68915: ARRAY
68916: PPUSH
68917: CALL_OW 314
68921: NOT
68922: PUSH
68923: LD_EXP 61
68927: PUSH
68928: LD_VAR 0 2
68932: ARRAY
68933: PUSH
68934: LD_INT 1
68936: ARRAY
68937: PPUSH
68938: LD_EXP 60
68942: PUSH
68943: LD_VAR 0 2
68947: ARRAY
68948: PUSH
68949: LD_INT 1
68951: ARRAY
68952: PUSH
68953: LD_INT 1
68955: ARRAY
68956: PPUSH
68957: LD_EXP 60
68961: PUSH
68962: LD_VAR 0 2
68966: ARRAY
68967: PUSH
68968: LD_INT 1
68970: ARRAY
68971: PUSH
68972: LD_INT 2
68974: ARRAY
68975: PPUSH
68976: CALL_OW 297
68980: PUSH
68981: LD_INT 6
68983: GREATER
68984: AND
68985: IFFALSE 69044
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
68987: LD_EXP 61
68991: PUSH
68992: LD_VAR 0 2
68996: ARRAY
68997: PUSH
68998: LD_INT 1
69000: ARRAY
69001: PPUSH
69002: LD_EXP 60
69006: PUSH
69007: LD_VAR 0 2
69011: ARRAY
69012: PUSH
69013: LD_INT 1
69015: ARRAY
69016: PUSH
69017: LD_INT 1
69019: ARRAY
69020: PPUSH
69021: LD_EXP 60
69025: PUSH
69026: LD_VAR 0 2
69030: ARRAY
69031: PUSH
69032: LD_INT 1
69034: ARRAY
69035: PUSH
69036: LD_INT 2
69038: ARRAY
69039: PPUSH
69040: CALL_OW 111
// end ; end ; end ;
69044: GO 68457
69046: POP
69047: POP
// end ;
69048: LD_VAR 0 1
69052: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
69053: LD_INT 0
69055: PPUSH
69056: PPUSH
69057: PPUSH
69058: PPUSH
69059: PPUSH
69060: PPUSH
69061: PPUSH
69062: PPUSH
69063: PPUSH
69064: PPUSH
69065: PPUSH
// if not mc_bases then
69066: LD_EXP 23
69070: NOT
69071: IFFALSE 69075
// exit ;
69073: GO 70015
// for i = 1 to mc_bases do
69075: LD_ADDR_VAR 0 2
69079: PUSH
69080: DOUBLE
69081: LD_INT 1
69083: DEC
69084: ST_TO_ADDR
69085: LD_EXP 23
69089: PUSH
69090: FOR_TO
69091: IFFALSE 70013
// begin if not mc_bases [ i ] or mc_scan [ i ] then
69093: LD_EXP 23
69097: PUSH
69098: LD_VAR 0 2
69102: ARRAY
69103: NOT
69104: PUSH
69105: LD_EXP 46
69109: PUSH
69110: LD_VAR 0 2
69114: ARRAY
69115: OR
69116: IFFALSE 69120
// continue ;
69118: GO 69090
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
69120: LD_ADDR_VAR 0 7
69124: PUSH
69125: LD_EXP 23
69129: PUSH
69130: LD_VAR 0 2
69134: ARRAY
69135: PUSH
69136: LD_INT 1
69138: ARRAY
69139: PPUSH
69140: CALL_OW 248
69144: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
69145: LD_VAR 0 7
69149: PUSH
69150: LD_INT 3
69152: EQUAL
69153: PUSH
69154: LD_EXP 42
69158: PUSH
69159: LD_VAR 0 2
69163: ARRAY
69164: PUSH
69165: LD_EXP 45
69169: PUSH
69170: LD_VAR 0 2
69174: ARRAY
69175: UNION
69176: PPUSH
69177: LD_INT 33
69179: PUSH
69180: LD_INT 2
69182: PUSH
69183: EMPTY
69184: LIST
69185: LIST
69186: PPUSH
69187: CALL_OW 72
69191: NOT
69192: OR
69193: IFFALSE 69197
// continue ;
69195: GO 69090
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
69197: LD_ADDR_VAR 0 9
69201: PUSH
69202: LD_EXP 23
69206: PUSH
69207: LD_VAR 0 2
69211: ARRAY
69212: PPUSH
69213: LD_INT 30
69215: PUSH
69216: LD_INT 36
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PPUSH
69223: CALL_OW 72
69227: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
69228: LD_ADDR_VAR 0 10
69232: PUSH
69233: LD_EXP 42
69237: PUSH
69238: LD_VAR 0 2
69242: ARRAY
69243: PPUSH
69244: LD_INT 34
69246: PUSH
69247: LD_INT 31
69249: PUSH
69250: EMPTY
69251: LIST
69252: LIST
69253: PPUSH
69254: CALL_OW 72
69258: ST_TO_ADDR
// if not cts and not mcts then
69259: LD_VAR 0 9
69263: NOT
69264: PUSH
69265: LD_VAR 0 10
69269: NOT
69270: AND
69271: IFFALSE 69275
// continue ;
69273: GO 69090
// x := cts ;
69275: LD_ADDR_VAR 0 11
69279: PUSH
69280: LD_VAR 0 9
69284: ST_TO_ADDR
// if not x then
69285: LD_VAR 0 11
69289: NOT
69290: IFFALSE 69302
// x := mcts ;
69292: LD_ADDR_VAR 0 11
69296: PUSH
69297: LD_VAR 0 10
69301: ST_TO_ADDR
// if not x then
69302: LD_VAR 0 11
69306: NOT
69307: IFFALSE 69311
// continue ;
69309: GO 69090
// if mc_remote_driver [ i ] then
69311: LD_EXP 63
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: IFFALSE 69708
// for j in mc_remote_driver [ i ] do
69323: LD_ADDR_VAR 0 3
69327: PUSH
69328: LD_EXP 63
69332: PUSH
69333: LD_VAR 0 2
69337: ARRAY
69338: PUSH
69339: FOR_IN
69340: IFFALSE 69706
// begin if GetClass ( j ) <> 3 then
69342: LD_VAR 0 3
69346: PPUSH
69347: CALL_OW 257
69351: PUSH
69352: LD_INT 3
69354: NONEQUAL
69355: IFFALSE 69408
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
69357: LD_ADDR_EXP 63
69361: PUSH
69362: LD_EXP 63
69366: PPUSH
69367: LD_VAR 0 2
69371: PPUSH
69372: LD_EXP 63
69376: PUSH
69377: LD_VAR 0 2
69381: ARRAY
69382: PUSH
69383: LD_VAR 0 3
69387: DIFF
69388: PPUSH
69389: CALL_OW 1
69393: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69394: LD_VAR 0 3
69398: PPUSH
69399: LD_INT 0
69401: PPUSH
69402: CALL_OW 109
// continue ;
69406: GO 69339
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
69408: LD_EXP 42
69412: PUSH
69413: LD_VAR 0 2
69417: ARRAY
69418: PPUSH
69419: LD_INT 34
69421: PUSH
69422: LD_INT 31
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 58
69431: PUSH
69432: EMPTY
69433: LIST
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PPUSH
69439: CALL_OW 72
69443: PUSH
69444: LD_VAR 0 3
69448: PPUSH
69449: CALL 43418 0 1
69453: NOT
69454: AND
69455: IFFALSE 69526
// begin if IsInUnit ( j ) then
69457: LD_VAR 0 3
69461: PPUSH
69462: CALL_OW 310
69466: IFFALSE 69477
// ComExitBuilding ( j ) ;
69468: LD_VAR 0 3
69472: PPUSH
69473: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
69477: LD_VAR 0 3
69481: PPUSH
69482: LD_EXP 42
69486: PUSH
69487: LD_VAR 0 2
69491: ARRAY
69492: PPUSH
69493: LD_INT 34
69495: PUSH
69496: LD_INT 31
69498: PUSH
69499: EMPTY
69500: LIST
69501: LIST
69502: PUSH
69503: LD_INT 58
69505: PUSH
69506: EMPTY
69507: LIST
69508: PUSH
69509: EMPTY
69510: LIST
69511: LIST
69512: PPUSH
69513: CALL_OW 72
69517: PUSH
69518: LD_INT 1
69520: ARRAY
69521: PPUSH
69522: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
69526: LD_VAR 0 3
69530: PPUSH
69531: CALL_OW 310
69535: NOT
69536: PUSH
69537: LD_VAR 0 3
69541: PPUSH
69542: CALL_OW 310
69546: PPUSH
69547: CALL_OW 266
69551: PUSH
69552: LD_INT 36
69554: NONEQUAL
69555: PUSH
69556: LD_VAR 0 3
69560: PPUSH
69561: CALL 43418 0 1
69565: NOT
69566: AND
69567: OR
69568: IFFALSE 69704
// begin if IsInUnit ( j ) then
69570: LD_VAR 0 3
69574: PPUSH
69575: CALL_OW 310
69579: IFFALSE 69590
// ComExitBuilding ( j ) ;
69581: LD_VAR 0 3
69585: PPUSH
69586: CALL_OW 122
// ct := 0 ;
69590: LD_ADDR_VAR 0 8
69594: PUSH
69595: LD_INT 0
69597: ST_TO_ADDR
// for k in x do
69598: LD_ADDR_VAR 0 4
69602: PUSH
69603: LD_VAR 0 11
69607: PUSH
69608: FOR_IN
69609: IFFALSE 69682
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
69611: LD_VAR 0 4
69615: PPUSH
69616: CALL_OW 264
69620: PUSH
69621: LD_INT 31
69623: EQUAL
69624: PUSH
69625: LD_VAR 0 4
69629: PPUSH
69630: CALL_OW 311
69634: NOT
69635: AND
69636: PUSH
69637: LD_VAR 0 4
69641: PPUSH
69642: CALL_OW 266
69646: PUSH
69647: LD_INT 36
69649: EQUAL
69650: PUSH
69651: LD_VAR 0 4
69655: PPUSH
69656: CALL_OW 313
69660: PUSH
69661: LD_INT 3
69663: LESS
69664: AND
69665: OR
69666: IFFALSE 69680
// begin ct := k ;
69668: LD_ADDR_VAR 0 8
69672: PUSH
69673: LD_VAR 0 4
69677: ST_TO_ADDR
// break ;
69678: GO 69682
// end ;
69680: GO 69608
69682: POP
69683: POP
// if ct then
69684: LD_VAR 0 8
69688: IFFALSE 69704
// ComEnterUnit ( j , ct ) ;
69690: LD_VAR 0 3
69694: PPUSH
69695: LD_VAR 0 8
69699: PPUSH
69700: CALL_OW 120
// end ; end ;
69704: GO 69339
69706: POP
69707: POP
// places := 0 ;
69708: LD_ADDR_VAR 0 5
69712: PUSH
69713: LD_INT 0
69715: ST_TO_ADDR
// for j = 1 to x do
69716: LD_ADDR_VAR 0 3
69720: PUSH
69721: DOUBLE
69722: LD_INT 1
69724: DEC
69725: ST_TO_ADDR
69726: LD_VAR 0 11
69730: PUSH
69731: FOR_TO
69732: IFFALSE 69808
// if GetWeapon ( x [ j ] ) = ar_control_tower then
69734: LD_VAR 0 11
69738: PUSH
69739: LD_VAR 0 3
69743: ARRAY
69744: PPUSH
69745: CALL_OW 264
69749: PUSH
69750: LD_INT 31
69752: EQUAL
69753: IFFALSE 69771
// places := places + 1 else
69755: LD_ADDR_VAR 0 5
69759: PUSH
69760: LD_VAR 0 5
69764: PUSH
69765: LD_INT 1
69767: PLUS
69768: ST_TO_ADDR
69769: GO 69806
// if GetBType ( x [ j ] ) = b_control_tower then
69771: LD_VAR 0 11
69775: PUSH
69776: LD_VAR 0 3
69780: ARRAY
69781: PPUSH
69782: CALL_OW 266
69786: PUSH
69787: LD_INT 36
69789: EQUAL
69790: IFFALSE 69806
// places := places + 3 ;
69792: LD_ADDR_VAR 0 5
69796: PUSH
69797: LD_VAR 0 5
69801: PUSH
69802: LD_INT 3
69804: PLUS
69805: ST_TO_ADDR
69806: GO 69731
69808: POP
69809: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
69810: LD_VAR 0 5
69814: PUSH
69815: LD_INT 0
69817: EQUAL
69818: PUSH
69819: LD_VAR 0 5
69823: PUSH
69824: LD_EXP 63
69828: PUSH
69829: LD_VAR 0 2
69833: ARRAY
69834: LESSEQUAL
69835: OR
69836: IFFALSE 69840
// continue ;
69838: GO 69090
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
69840: LD_ADDR_VAR 0 6
69844: PUSH
69845: LD_EXP 23
69849: PUSH
69850: LD_VAR 0 2
69854: ARRAY
69855: PPUSH
69856: LD_INT 25
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: EMPTY
69863: LIST
69864: LIST
69865: PPUSH
69866: CALL_OW 72
69870: PUSH
69871: LD_EXP 63
69875: PUSH
69876: LD_VAR 0 2
69880: ARRAY
69881: DIFF
69882: PPUSH
69883: LD_INT 3
69885: PPUSH
69886: CALL 44318 0 2
69890: ST_TO_ADDR
// for j in tmp do
69891: LD_ADDR_VAR 0 3
69895: PUSH
69896: LD_VAR 0 6
69900: PUSH
69901: FOR_IN
69902: IFFALSE 69937
// if GetTag ( j ) > 0 then
69904: LD_VAR 0 3
69908: PPUSH
69909: CALL_OW 110
69913: PUSH
69914: LD_INT 0
69916: GREATER
69917: IFFALSE 69935
// tmp := tmp diff j ;
69919: LD_ADDR_VAR 0 6
69923: PUSH
69924: LD_VAR 0 6
69928: PUSH
69929: LD_VAR 0 3
69933: DIFF
69934: ST_TO_ADDR
69935: GO 69901
69937: POP
69938: POP
// if not tmp then
69939: LD_VAR 0 6
69943: NOT
69944: IFFALSE 69948
// continue ;
69946: GO 69090
// if places then
69948: LD_VAR 0 5
69952: IFFALSE 70011
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
69954: LD_ADDR_EXP 63
69958: PUSH
69959: LD_EXP 63
69963: PPUSH
69964: LD_VAR 0 2
69968: PPUSH
69969: LD_EXP 63
69973: PUSH
69974: LD_VAR 0 2
69978: ARRAY
69979: PUSH
69980: LD_VAR 0 6
69984: PUSH
69985: LD_INT 1
69987: ARRAY
69988: UNION
69989: PPUSH
69990: CALL_OW 1
69994: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
69995: LD_VAR 0 6
69999: PUSH
70000: LD_INT 1
70002: ARRAY
70003: PPUSH
70004: LD_INT 126
70006: PPUSH
70007: CALL_OW 109
// end ; end ;
70011: GO 69090
70013: POP
70014: POP
// end ;
70015: LD_VAR 0 1
70019: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
70020: LD_INT 0
70022: PPUSH
70023: PPUSH
70024: PPUSH
70025: PPUSH
70026: PPUSH
70027: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
70028: LD_VAR 0 1
70032: NOT
70033: PUSH
70034: LD_VAR 0 2
70038: NOT
70039: OR
70040: PUSH
70041: LD_VAR 0 3
70045: NOT
70046: OR
70047: PUSH
70048: LD_VAR 0 4
70052: PUSH
70053: LD_INT 1
70055: PUSH
70056: LD_INT 2
70058: PUSH
70059: LD_INT 3
70061: PUSH
70062: LD_INT 4
70064: PUSH
70065: LD_INT 5
70067: PUSH
70068: LD_INT 8
70070: PUSH
70071: LD_INT 9
70073: PUSH
70074: LD_INT 15
70076: PUSH
70077: LD_INT 16
70079: PUSH
70080: EMPTY
70081: LIST
70082: LIST
70083: LIST
70084: LIST
70085: LIST
70086: LIST
70087: LIST
70088: LIST
70089: LIST
70090: IN
70091: NOT
70092: OR
70093: IFFALSE 70097
// exit ;
70095: GO 70997
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
70097: LD_ADDR_VAR 0 2
70101: PUSH
70102: LD_VAR 0 2
70106: PPUSH
70107: LD_INT 21
70109: PUSH
70110: LD_INT 3
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: LD_INT 24
70119: PUSH
70120: LD_INT 250
70122: PUSH
70123: EMPTY
70124: LIST
70125: LIST
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PPUSH
70131: CALL_OW 72
70135: ST_TO_ADDR
// case class of 1 , 15 :
70136: LD_VAR 0 4
70140: PUSH
70141: LD_INT 1
70143: DOUBLE
70144: EQUAL
70145: IFTRUE 70155
70147: LD_INT 15
70149: DOUBLE
70150: EQUAL
70151: IFTRUE 70155
70153: GO 70240
70155: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
70156: LD_ADDR_VAR 0 8
70160: PUSH
70161: LD_VAR 0 2
70165: PPUSH
70166: LD_INT 2
70168: PUSH
70169: LD_INT 30
70171: PUSH
70172: LD_INT 32
70174: PUSH
70175: EMPTY
70176: LIST
70177: LIST
70178: PUSH
70179: LD_INT 30
70181: PUSH
70182: LD_INT 31
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: LIST
70193: PPUSH
70194: CALL_OW 72
70198: PUSH
70199: LD_VAR 0 2
70203: PPUSH
70204: LD_INT 2
70206: PUSH
70207: LD_INT 30
70209: PUSH
70210: LD_INT 4
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 30
70219: PUSH
70220: LD_INT 5
70222: PUSH
70223: EMPTY
70224: LIST
70225: LIST
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: LIST
70231: PPUSH
70232: CALL_OW 72
70236: ADD
70237: ST_TO_ADDR
70238: GO 70486
70240: LD_INT 2
70242: DOUBLE
70243: EQUAL
70244: IFTRUE 70254
70246: LD_INT 16
70248: DOUBLE
70249: EQUAL
70250: IFTRUE 70254
70252: GO 70300
70254: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
70255: LD_ADDR_VAR 0 8
70259: PUSH
70260: LD_VAR 0 2
70264: PPUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 0
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 30
70280: PUSH
70281: LD_INT 1
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: PPUSH
70293: CALL_OW 72
70297: ST_TO_ADDR
70298: GO 70486
70300: LD_INT 3
70302: DOUBLE
70303: EQUAL
70304: IFTRUE 70308
70306: GO 70354
70308: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
70309: LD_ADDR_VAR 0 8
70313: PUSH
70314: LD_VAR 0 2
70318: PPUSH
70319: LD_INT 2
70321: PUSH
70322: LD_INT 30
70324: PUSH
70325: LD_INT 2
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: PUSH
70332: LD_INT 30
70334: PUSH
70335: LD_INT 3
70337: PUSH
70338: EMPTY
70339: LIST
70340: LIST
70341: PUSH
70342: EMPTY
70343: LIST
70344: LIST
70345: LIST
70346: PPUSH
70347: CALL_OW 72
70351: ST_TO_ADDR
70352: GO 70486
70354: LD_INT 4
70356: DOUBLE
70357: EQUAL
70358: IFTRUE 70362
70360: GO 70419
70362: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
70363: LD_ADDR_VAR 0 8
70367: PUSH
70368: LD_VAR 0 2
70372: PPUSH
70373: LD_INT 2
70375: PUSH
70376: LD_INT 30
70378: PUSH
70379: LD_INT 6
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 30
70388: PUSH
70389: LD_INT 7
70391: PUSH
70392: EMPTY
70393: LIST
70394: LIST
70395: PUSH
70396: LD_INT 30
70398: PUSH
70399: LD_INT 8
70401: PUSH
70402: EMPTY
70403: LIST
70404: LIST
70405: PUSH
70406: EMPTY
70407: LIST
70408: LIST
70409: LIST
70410: LIST
70411: PPUSH
70412: CALL_OW 72
70416: ST_TO_ADDR
70417: GO 70486
70419: LD_INT 5
70421: DOUBLE
70422: EQUAL
70423: IFTRUE 70439
70425: LD_INT 8
70427: DOUBLE
70428: EQUAL
70429: IFTRUE 70439
70431: LD_INT 9
70433: DOUBLE
70434: EQUAL
70435: IFTRUE 70439
70437: GO 70485
70439: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
70440: LD_ADDR_VAR 0 8
70444: PUSH
70445: LD_VAR 0 2
70449: PPUSH
70450: LD_INT 2
70452: PUSH
70453: LD_INT 30
70455: PUSH
70456: LD_INT 4
70458: PUSH
70459: EMPTY
70460: LIST
70461: LIST
70462: PUSH
70463: LD_INT 30
70465: PUSH
70466: LD_INT 5
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PUSH
70473: EMPTY
70474: LIST
70475: LIST
70476: LIST
70477: PPUSH
70478: CALL_OW 72
70482: ST_TO_ADDR
70483: GO 70486
70485: POP
// if not tmp then
70486: LD_VAR 0 8
70490: NOT
70491: IFFALSE 70495
// exit ;
70493: GO 70997
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
70495: LD_VAR 0 4
70499: PUSH
70500: LD_INT 1
70502: PUSH
70503: LD_INT 15
70505: PUSH
70506: EMPTY
70507: LIST
70508: LIST
70509: IN
70510: PUSH
70511: LD_EXP 32
70515: PUSH
70516: LD_VAR 0 1
70520: ARRAY
70521: AND
70522: IFFALSE 70678
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
70524: LD_ADDR_VAR 0 9
70528: PUSH
70529: LD_EXP 32
70533: PUSH
70534: LD_VAR 0 1
70538: ARRAY
70539: PUSH
70540: LD_INT 1
70542: ARRAY
70543: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
70544: LD_VAR 0 9
70548: PUSH
70549: LD_EXP 33
70553: PUSH
70554: LD_VAR 0 1
70558: ARRAY
70559: IN
70560: NOT
70561: IFFALSE 70676
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
70563: LD_ADDR_EXP 33
70567: PUSH
70568: LD_EXP 33
70572: PPUSH
70573: LD_VAR 0 1
70577: PUSH
70578: LD_EXP 33
70582: PUSH
70583: LD_VAR 0 1
70587: ARRAY
70588: PUSH
70589: LD_INT 1
70591: PLUS
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PPUSH
70597: LD_VAR 0 9
70601: PPUSH
70602: CALL 14060 0 3
70606: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
70607: LD_ADDR_EXP 32
70611: PUSH
70612: LD_EXP 32
70616: PPUSH
70617: LD_VAR 0 1
70621: PPUSH
70622: LD_EXP 32
70626: PUSH
70627: LD_VAR 0 1
70631: ARRAY
70632: PUSH
70633: LD_VAR 0 9
70637: DIFF
70638: PPUSH
70639: CALL_OW 1
70643: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
70644: LD_VAR 0 3
70648: PPUSH
70649: LD_EXP 33
70653: PUSH
70654: LD_VAR 0 1
70658: ARRAY
70659: PUSH
70660: LD_EXP 33
70664: PUSH
70665: LD_VAR 0 1
70669: ARRAY
70670: ARRAY
70671: PPUSH
70672: CALL_OW 120
// end ; exit ;
70676: GO 70997
// end ; if tmp > 1 then
70678: LD_VAR 0 8
70682: PUSH
70683: LD_INT 1
70685: GREATER
70686: IFFALSE 70790
// for i = 2 to tmp do
70688: LD_ADDR_VAR 0 6
70692: PUSH
70693: DOUBLE
70694: LD_INT 2
70696: DEC
70697: ST_TO_ADDR
70698: LD_VAR 0 8
70702: PUSH
70703: FOR_TO
70704: IFFALSE 70788
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
70706: LD_VAR 0 8
70710: PUSH
70711: LD_VAR 0 6
70715: ARRAY
70716: PPUSH
70717: CALL_OW 461
70721: PUSH
70722: LD_INT 6
70724: EQUAL
70725: IFFALSE 70786
// begin x := tmp [ i ] ;
70727: LD_ADDR_VAR 0 9
70731: PUSH
70732: LD_VAR 0 8
70736: PUSH
70737: LD_VAR 0 6
70741: ARRAY
70742: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
70743: LD_ADDR_VAR 0 8
70747: PUSH
70748: LD_VAR 0 8
70752: PPUSH
70753: LD_VAR 0 6
70757: PPUSH
70758: CALL_OW 3
70762: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
70763: LD_ADDR_VAR 0 8
70767: PUSH
70768: LD_VAR 0 8
70772: PPUSH
70773: LD_INT 1
70775: PPUSH
70776: LD_VAR 0 9
70780: PPUSH
70781: CALL_OW 2
70785: ST_TO_ADDR
// end ;
70786: GO 70703
70788: POP
70789: POP
// for i in tmp do
70790: LD_ADDR_VAR 0 6
70794: PUSH
70795: LD_VAR 0 8
70799: PUSH
70800: FOR_IN
70801: IFFALSE 70870
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
70803: LD_VAR 0 6
70807: PPUSH
70808: CALL_OW 313
70812: PUSH
70813: LD_INT 6
70815: LESS
70816: PUSH
70817: LD_VAR 0 6
70821: PPUSH
70822: CALL_OW 266
70826: PUSH
70827: LD_INT 31
70829: PUSH
70830: LD_INT 32
70832: PUSH
70833: EMPTY
70834: LIST
70835: LIST
70836: IN
70837: NOT
70838: AND
70839: PUSH
70840: LD_VAR 0 6
70844: PPUSH
70845: CALL_OW 313
70849: PUSH
70850: LD_INT 0
70852: EQUAL
70853: OR
70854: IFFALSE 70868
// begin j := i ;
70856: LD_ADDR_VAR 0 7
70860: PUSH
70861: LD_VAR 0 6
70865: ST_TO_ADDR
// break ;
70866: GO 70870
// end ; end ;
70868: GO 70800
70870: POP
70871: POP
// if j then
70872: LD_VAR 0 7
70876: IFFALSE 70894
// ComEnterUnit ( unit , j ) else
70878: LD_VAR 0 3
70882: PPUSH
70883: LD_VAR 0 7
70887: PPUSH
70888: CALL_OW 120
70892: GO 70997
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70894: LD_ADDR_VAR 0 10
70898: PUSH
70899: LD_VAR 0 2
70903: PPUSH
70904: LD_INT 2
70906: PUSH
70907: LD_INT 30
70909: PUSH
70910: LD_INT 0
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 30
70919: PUSH
70920: LD_INT 1
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: LIST
70931: PPUSH
70932: CALL_OW 72
70936: ST_TO_ADDR
// if depot then
70937: LD_VAR 0 10
70941: IFFALSE 70997
// begin depot := NearestUnitToUnit ( depot , unit ) ;
70943: LD_ADDR_VAR 0 10
70947: PUSH
70948: LD_VAR 0 10
70952: PPUSH
70953: LD_VAR 0 3
70957: PPUSH
70958: CALL_OW 74
70962: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
70963: LD_VAR 0 3
70967: PPUSH
70968: LD_VAR 0 10
70972: PPUSH
70973: CALL_OW 296
70977: PUSH
70978: LD_INT 10
70980: GREATER
70981: IFFALSE 70997
// ComStandNearbyBuilding ( unit , depot ) ;
70983: LD_VAR 0 3
70987: PPUSH
70988: LD_VAR 0 10
70992: PPUSH
70993: CALL 10638 0 2
// end ; end ; end ;
70997: LD_VAR 0 5
71001: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
71002: LD_INT 0
71004: PPUSH
71005: PPUSH
71006: PPUSH
71007: PPUSH
// if not mc_bases then
71008: LD_EXP 23
71012: NOT
71013: IFFALSE 71017
// exit ;
71015: GO 71256
// for i = 1 to mc_bases do
71017: LD_ADDR_VAR 0 2
71021: PUSH
71022: DOUBLE
71023: LD_INT 1
71025: DEC
71026: ST_TO_ADDR
71027: LD_EXP 23
71031: PUSH
71032: FOR_TO
71033: IFFALSE 71254
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
71035: LD_ADDR_VAR 0 4
71039: PUSH
71040: LD_EXP 23
71044: PUSH
71045: LD_VAR 0 2
71049: ARRAY
71050: PPUSH
71051: LD_INT 21
71053: PUSH
71054: LD_INT 1
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PPUSH
71061: CALL_OW 72
71065: PUSH
71066: LD_EXP 52
71070: PUSH
71071: LD_VAR 0 2
71075: ARRAY
71076: UNION
71077: ST_TO_ADDR
// if not tmp then
71078: LD_VAR 0 4
71082: NOT
71083: IFFALSE 71087
// continue ;
71085: GO 71032
// for j in tmp do
71087: LD_ADDR_VAR 0 3
71091: PUSH
71092: LD_VAR 0 4
71096: PUSH
71097: FOR_IN
71098: IFFALSE 71250
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
71100: LD_VAR 0 3
71104: PPUSH
71105: CALL_OW 110
71109: NOT
71110: PUSH
71111: LD_VAR 0 3
71115: PPUSH
71116: CALL_OW 314
71120: NOT
71121: AND
71122: PUSH
71123: LD_VAR 0 3
71127: PPUSH
71128: CALL_OW 311
71132: NOT
71133: AND
71134: PUSH
71135: LD_VAR 0 3
71139: PPUSH
71140: CALL_OW 310
71144: NOT
71145: AND
71146: PUSH
71147: LD_VAR 0 3
71151: PUSH
71152: LD_EXP 26
71156: PUSH
71157: LD_VAR 0 2
71161: ARRAY
71162: PUSH
71163: LD_INT 1
71165: ARRAY
71166: IN
71167: NOT
71168: AND
71169: PUSH
71170: LD_VAR 0 3
71174: PUSH
71175: LD_EXP 26
71179: PUSH
71180: LD_VAR 0 2
71184: ARRAY
71185: PUSH
71186: LD_INT 2
71188: ARRAY
71189: IN
71190: NOT
71191: AND
71192: PUSH
71193: LD_VAR 0 3
71197: PUSH
71198: LD_EXP 35
71202: PUSH
71203: LD_VAR 0 2
71207: ARRAY
71208: IN
71209: NOT
71210: AND
71211: IFFALSE 71248
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
71213: LD_VAR 0 2
71217: PPUSH
71218: LD_EXP 23
71222: PUSH
71223: LD_VAR 0 2
71227: ARRAY
71228: PPUSH
71229: LD_VAR 0 3
71233: PPUSH
71234: LD_VAR 0 3
71238: PPUSH
71239: CALL_OW 257
71243: PPUSH
71244: CALL 70020 0 4
// end ;
71248: GO 71097
71250: POP
71251: POP
// end ;
71252: GO 71032
71254: POP
71255: POP
// end ;
71256: LD_VAR 0 1
71260: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
71261: LD_INT 0
71263: PPUSH
71264: PPUSH
71265: PPUSH
71266: PPUSH
71267: PPUSH
71268: PPUSH
// if not mc_bases [ base ] then
71269: LD_EXP 23
71273: PUSH
71274: LD_VAR 0 1
71278: ARRAY
71279: NOT
71280: IFFALSE 71284
// exit ;
71282: GO 71466
// tmp := [ ] ;
71284: LD_ADDR_VAR 0 6
71288: PUSH
71289: EMPTY
71290: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
71291: LD_ADDR_VAR 0 7
71295: PUSH
71296: LD_VAR 0 3
71300: PPUSH
71301: LD_INT 0
71303: PPUSH
71304: CALL_OW 517
71308: ST_TO_ADDR
// if not list then
71309: LD_VAR 0 7
71313: NOT
71314: IFFALSE 71318
// exit ;
71316: GO 71466
// for i = 1 to amount do
71318: LD_ADDR_VAR 0 5
71322: PUSH
71323: DOUBLE
71324: LD_INT 1
71326: DEC
71327: ST_TO_ADDR
71328: LD_VAR 0 2
71332: PUSH
71333: FOR_TO
71334: IFFALSE 71414
// begin x := rand ( 1 , list [ 1 ] ) ;
71336: LD_ADDR_VAR 0 8
71340: PUSH
71341: LD_INT 1
71343: PPUSH
71344: LD_VAR 0 7
71348: PUSH
71349: LD_INT 1
71351: ARRAY
71352: PPUSH
71353: CALL_OW 12
71357: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
71358: LD_ADDR_VAR 0 6
71362: PUSH
71363: LD_VAR 0 6
71367: PPUSH
71368: LD_VAR 0 5
71372: PPUSH
71373: LD_VAR 0 7
71377: PUSH
71378: LD_INT 1
71380: ARRAY
71381: PUSH
71382: LD_VAR 0 8
71386: ARRAY
71387: PUSH
71388: LD_VAR 0 7
71392: PUSH
71393: LD_INT 2
71395: ARRAY
71396: PUSH
71397: LD_VAR 0 8
71401: ARRAY
71402: PUSH
71403: EMPTY
71404: LIST
71405: LIST
71406: PPUSH
71407: CALL_OW 1
71411: ST_TO_ADDR
// end ;
71412: GO 71333
71414: POP
71415: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
71416: LD_ADDR_EXP 36
71420: PUSH
71421: LD_EXP 36
71425: PPUSH
71426: LD_VAR 0 1
71430: PPUSH
71431: LD_VAR 0 6
71435: PPUSH
71436: CALL_OW 1
71440: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
71441: LD_ADDR_EXP 38
71445: PUSH
71446: LD_EXP 38
71450: PPUSH
71451: LD_VAR 0 1
71455: PPUSH
71456: LD_VAR 0 3
71460: PPUSH
71461: CALL_OW 1
71465: ST_TO_ADDR
// end ;
71466: LD_VAR 0 4
71470: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
71471: LD_INT 0
71473: PPUSH
// if not mc_bases [ base ] then
71474: LD_EXP 23
71478: PUSH
71479: LD_VAR 0 1
71483: ARRAY
71484: NOT
71485: IFFALSE 71489
// exit ;
71487: GO 71514
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
71489: LD_ADDR_EXP 28
71493: PUSH
71494: LD_EXP 28
71498: PPUSH
71499: LD_VAR 0 1
71503: PPUSH
71504: LD_VAR 0 2
71508: PPUSH
71509: CALL_OW 1
71513: ST_TO_ADDR
// end ;
71514: LD_VAR 0 3
71518: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
71519: LD_INT 0
71521: PPUSH
// if not mc_bases [ base ] then
71522: LD_EXP 23
71526: PUSH
71527: LD_VAR 0 1
71531: ARRAY
71532: NOT
71533: IFFALSE 71537
// exit ;
71535: GO 71574
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
71537: LD_ADDR_EXP 28
71541: PUSH
71542: LD_EXP 28
71546: PPUSH
71547: LD_VAR 0 1
71551: PPUSH
71552: LD_EXP 28
71556: PUSH
71557: LD_VAR 0 1
71561: ARRAY
71562: PUSH
71563: LD_VAR 0 2
71567: UNION
71568: PPUSH
71569: CALL_OW 1
71573: ST_TO_ADDR
// end ;
71574: LD_VAR 0 3
71578: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
71579: LD_INT 0
71581: PPUSH
// if not mc_bases [ base ] then
71582: LD_EXP 23
71586: PUSH
71587: LD_VAR 0 1
71591: ARRAY
71592: NOT
71593: IFFALSE 71597
// exit ;
71595: GO 71622
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
71597: LD_ADDR_EXP 44
71601: PUSH
71602: LD_EXP 44
71606: PPUSH
71607: LD_VAR 0 1
71611: PPUSH
71612: LD_VAR 0 2
71616: PPUSH
71617: CALL_OW 1
71621: ST_TO_ADDR
// end ;
71622: LD_VAR 0 3
71626: RET
// export function MC_InsertProduceList ( base , components ) ; begin
71627: LD_INT 0
71629: PPUSH
// if not mc_bases [ base ] then
71630: LD_EXP 23
71634: PUSH
71635: LD_VAR 0 1
71639: ARRAY
71640: NOT
71641: IFFALSE 71645
// exit ;
71643: GO 71682
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
71645: LD_ADDR_EXP 44
71649: PUSH
71650: LD_EXP 44
71654: PPUSH
71655: LD_VAR 0 1
71659: PPUSH
71660: LD_EXP 44
71664: PUSH
71665: LD_VAR 0 1
71669: ARRAY
71670: PUSH
71671: LD_VAR 0 2
71675: ADD
71676: PPUSH
71677: CALL_OW 1
71681: ST_TO_ADDR
// end ;
71682: LD_VAR 0 3
71686: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
71687: LD_INT 0
71689: PPUSH
// if not mc_bases [ base ] then
71690: LD_EXP 23
71694: PUSH
71695: LD_VAR 0 1
71699: ARRAY
71700: NOT
71701: IFFALSE 71705
// exit ;
71703: GO 71759
// mc_defender := Replace ( mc_defender , base , deflist ) ;
71705: LD_ADDR_EXP 45
71709: PUSH
71710: LD_EXP 45
71714: PPUSH
71715: LD_VAR 0 1
71719: PPUSH
71720: LD_VAR 0 2
71724: PPUSH
71725: CALL_OW 1
71729: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
71730: LD_ADDR_EXP 34
71734: PUSH
71735: LD_EXP 34
71739: PPUSH
71740: LD_VAR 0 1
71744: PPUSH
71745: LD_VAR 0 2
71749: PUSH
71750: LD_INT 0
71752: PLUS
71753: PPUSH
71754: CALL_OW 1
71758: ST_TO_ADDR
// end ;
71759: LD_VAR 0 3
71763: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
71764: LD_INT 0
71766: PPUSH
// if not mc_bases [ base ] then
71767: LD_EXP 23
71771: PUSH
71772: LD_VAR 0 1
71776: ARRAY
71777: NOT
71778: IFFALSE 71782
// exit ;
71780: GO 71807
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
71782: LD_ADDR_EXP 34
71786: PUSH
71787: LD_EXP 34
71791: PPUSH
71792: LD_VAR 0 1
71796: PPUSH
71797: LD_VAR 0 2
71801: PPUSH
71802: CALL_OW 1
71806: ST_TO_ADDR
// end ;
71807: LD_VAR 0 3
71811: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
71812: LD_INT 0
71814: PPUSH
71815: PPUSH
71816: PPUSH
71817: PPUSH
// if not mc_bases [ base ] then
71818: LD_EXP 23
71822: PUSH
71823: LD_VAR 0 1
71827: ARRAY
71828: NOT
71829: IFFALSE 71833
// exit ;
71831: GO 71898
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
71833: LD_ADDR_EXP 43
71837: PUSH
71838: LD_EXP 43
71842: PPUSH
71843: LD_VAR 0 1
71847: PUSH
71848: LD_EXP 43
71852: PUSH
71853: LD_VAR 0 1
71857: ARRAY
71858: PUSH
71859: LD_INT 1
71861: PLUS
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: PPUSH
71867: LD_VAR 0 1
71871: PUSH
71872: LD_VAR 0 2
71876: PUSH
71877: LD_VAR 0 3
71881: PUSH
71882: LD_VAR 0 4
71886: PUSH
71887: EMPTY
71888: LIST
71889: LIST
71890: LIST
71891: LIST
71892: PPUSH
71893: CALL 14060 0 3
71897: ST_TO_ADDR
// end ;
71898: LD_VAR 0 5
71902: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
71903: LD_INT 0
71905: PPUSH
// if not mc_bases [ base ] then
71906: LD_EXP 23
71910: PUSH
71911: LD_VAR 0 1
71915: ARRAY
71916: NOT
71917: IFFALSE 71921
// exit ;
71919: GO 71946
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
71921: LD_ADDR_EXP 60
71925: PUSH
71926: LD_EXP 60
71930: PPUSH
71931: LD_VAR 0 1
71935: PPUSH
71936: LD_VAR 0 2
71940: PPUSH
71941: CALL_OW 1
71945: ST_TO_ADDR
// end ;
71946: LD_VAR 0 3
71950: RET
// export function MC_GetMinesField ( base ) ; begin
71951: LD_INT 0
71953: PPUSH
// result := mc_mines [ base ] ;
71954: LD_ADDR_VAR 0 2
71958: PUSH
71959: LD_EXP 36
71963: PUSH
71964: LD_VAR 0 1
71968: ARRAY
71969: ST_TO_ADDR
// end ;
71970: LD_VAR 0 2
71974: RET
// export function MC_GetProduceList ( base ) ; begin
71975: LD_INT 0
71977: PPUSH
// result := mc_produce [ base ] ;
71978: LD_ADDR_VAR 0 2
71982: PUSH
71983: LD_EXP 44
71987: PUSH
71988: LD_VAR 0 1
71992: ARRAY
71993: ST_TO_ADDR
// end ;
71994: LD_VAR 0 2
71998: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
71999: LD_INT 0
72001: PPUSH
72002: PPUSH
// if not mc_bases then
72003: LD_EXP 23
72007: NOT
72008: IFFALSE 72012
// exit ;
72010: GO 72077
// if mc_bases [ base ] then
72012: LD_EXP 23
72016: PUSH
72017: LD_VAR 0 1
72021: ARRAY
72022: IFFALSE 72077
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
72024: LD_ADDR_VAR 0 3
72028: PUSH
72029: LD_EXP 23
72033: PUSH
72034: LD_VAR 0 1
72038: ARRAY
72039: PPUSH
72040: LD_INT 30
72042: PUSH
72043: LD_VAR 0 2
72047: PUSH
72048: EMPTY
72049: LIST
72050: LIST
72051: PPUSH
72052: CALL_OW 72
72056: ST_TO_ADDR
// if result then
72057: LD_VAR 0 3
72061: IFFALSE 72077
// result := result [ 1 ] ;
72063: LD_ADDR_VAR 0 3
72067: PUSH
72068: LD_VAR 0 3
72072: PUSH
72073: LD_INT 1
72075: ARRAY
72076: ST_TO_ADDR
// end ; end ;
72077: LD_VAR 0 3
72081: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
72082: LD_INT 0
72084: PPUSH
72085: PPUSH
// if not mc_bases then
72086: LD_EXP 23
72090: NOT
72091: IFFALSE 72095
// exit ;
72093: GO 72140
// if mc_bases [ base ] then
72095: LD_EXP 23
72099: PUSH
72100: LD_VAR 0 1
72104: ARRAY
72105: IFFALSE 72140
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
72107: LD_ADDR_VAR 0 3
72111: PUSH
72112: LD_EXP 23
72116: PUSH
72117: LD_VAR 0 1
72121: ARRAY
72122: PPUSH
72123: LD_INT 30
72125: PUSH
72126: LD_VAR 0 2
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PPUSH
72135: CALL_OW 72
72139: ST_TO_ADDR
// end ;
72140: LD_VAR 0 3
72144: RET
// export function MC_SetTame ( base , area ) ; begin
72145: LD_INT 0
72147: PPUSH
// if not mc_bases or not base then
72148: LD_EXP 23
72152: NOT
72153: PUSH
72154: LD_VAR 0 1
72158: NOT
72159: OR
72160: IFFALSE 72164
// exit ;
72162: GO 72189
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
72164: LD_ADDR_EXP 51
72168: PUSH
72169: LD_EXP 51
72173: PPUSH
72174: LD_VAR 0 1
72178: PPUSH
72179: LD_VAR 0 2
72183: PPUSH
72184: CALL_OW 1
72188: ST_TO_ADDR
// end ;
72189: LD_VAR 0 3
72193: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
72194: LD_INT 0
72196: PPUSH
72197: PPUSH
// if not mc_bases or not base then
72198: LD_EXP 23
72202: NOT
72203: PUSH
72204: LD_VAR 0 1
72208: NOT
72209: OR
72210: IFFALSE 72214
// exit ;
72212: GO 72316
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
72214: LD_ADDR_VAR 0 4
72218: PUSH
72219: LD_EXP 23
72223: PUSH
72224: LD_VAR 0 1
72228: ARRAY
72229: PPUSH
72230: LD_INT 30
72232: PUSH
72233: LD_VAR 0 2
72237: PUSH
72238: EMPTY
72239: LIST
72240: LIST
72241: PPUSH
72242: CALL_OW 72
72246: ST_TO_ADDR
// if not tmp then
72247: LD_VAR 0 4
72251: NOT
72252: IFFALSE 72256
// exit ;
72254: GO 72316
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
72256: LD_ADDR_EXP 55
72260: PUSH
72261: LD_EXP 55
72265: PPUSH
72266: LD_VAR 0 1
72270: PPUSH
72271: LD_EXP 55
72275: PUSH
72276: LD_VAR 0 1
72280: ARRAY
72281: PPUSH
72282: LD_EXP 55
72286: PUSH
72287: LD_VAR 0 1
72291: ARRAY
72292: PUSH
72293: LD_INT 1
72295: PLUS
72296: PPUSH
72297: LD_VAR 0 4
72301: PUSH
72302: LD_INT 1
72304: ARRAY
72305: PPUSH
72306: CALL_OW 2
72310: PPUSH
72311: CALL_OW 1
72315: ST_TO_ADDR
// end ;
72316: LD_VAR 0 3
72320: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
72321: LD_INT 0
72323: PPUSH
72324: PPUSH
// if not mc_bases or not base or not kinds then
72325: LD_EXP 23
72329: NOT
72330: PUSH
72331: LD_VAR 0 1
72335: NOT
72336: OR
72337: PUSH
72338: LD_VAR 0 2
72342: NOT
72343: OR
72344: IFFALSE 72348
// exit ;
72346: GO 72409
// for i in kinds do
72348: LD_ADDR_VAR 0 4
72352: PUSH
72353: LD_VAR 0 2
72357: PUSH
72358: FOR_IN
72359: IFFALSE 72407
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
72361: LD_ADDR_EXP 57
72365: PUSH
72366: LD_EXP 57
72370: PPUSH
72371: LD_VAR 0 1
72375: PUSH
72376: LD_EXP 57
72380: PUSH
72381: LD_VAR 0 1
72385: ARRAY
72386: PUSH
72387: LD_INT 1
72389: PLUS
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PPUSH
72395: LD_VAR 0 4
72399: PPUSH
72400: CALL 14060 0 3
72404: ST_TO_ADDR
72405: GO 72358
72407: POP
72408: POP
// end ;
72409: LD_VAR 0 3
72413: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
72414: LD_INT 0
72416: PPUSH
// if not mc_bases or not base or not areas then
72417: LD_EXP 23
72421: NOT
72422: PUSH
72423: LD_VAR 0 1
72427: NOT
72428: OR
72429: PUSH
72430: LD_VAR 0 2
72434: NOT
72435: OR
72436: IFFALSE 72440
// exit ;
72438: GO 72465
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
72440: LD_ADDR_EXP 41
72444: PUSH
72445: LD_EXP 41
72449: PPUSH
72450: LD_VAR 0 1
72454: PPUSH
72455: LD_VAR 0 2
72459: PPUSH
72460: CALL_OW 1
72464: ST_TO_ADDR
// end ;
72465: LD_VAR 0 3
72469: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
72470: LD_INT 0
72472: PPUSH
// if not mc_bases or not base or not teleports_exit then
72473: LD_EXP 23
72477: NOT
72478: PUSH
72479: LD_VAR 0 1
72483: NOT
72484: OR
72485: PUSH
72486: LD_VAR 0 2
72490: NOT
72491: OR
72492: IFFALSE 72496
// exit ;
72494: GO 72521
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
72496: LD_ADDR_EXP 58
72500: PUSH
72501: LD_EXP 58
72505: PPUSH
72506: LD_VAR 0 1
72510: PPUSH
72511: LD_VAR 0 2
72515: PPUSH
72516: CALL_OW 1
72520: ST_TO_ADDR
// end ;
72521: LD_VAR 0 3
72525: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
72526: LD_INT 0
72528: PPUSH
72529: PPUSH
72530: PPUSH
// if not mc_bases or not base or not ext_list then
72531: LD_EXP 23
72535: NOT
72536: PUSH
72537: LD_VAR 0 1
72541: NOT
72542: OR
72543: PUSH
72544: LD_VAR 0 5
72548: NOT
72549: OR
72550: IFFALSE 72554
// exit ;
72552: GO 72727
// tmp := GetFacExtXYD ( x , y , d ) ;
72554: LD_ADDR_VAR 0 8
72558: PUSH
72559: LD_VAR 0 2
72563: PPUSH
72564: LD_VAR 0 3
72568: PPUSH
72569: LD_VAR 0 4
72573: PPUSH
72574: CALL 43448 0 3
72578: ST_TO_ADDR
// if not tmp then
72579: LD_VAR 0 8
72583: NOT
72584: IFFALSE 72588
// exit ;
72586: GO 72727
// for i in tmp do
72588: LD_ADDR_VAR 0 7
72592: PUSH
72593: LD_VAR 0 8
72597: PUSH
72598: FOR_IN
72599: IFFALSE 72725
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
72601: LD_ADDR_EXP 28
72605: PUSH
72606: LD_EXP 28
72610: PPUSH
72611: LD_VAR 0 1
72615: PPUSH
72616: LD_EXP 28
72620: PUSH
72621: LD_VAR 0 1
72625: ARRAY
72626: PPUSH
72627: LD_EXP 28
72631: PUSH
72632: LD_VAR 0 1
72636: ARRAY
72637: PUSH
72638: LD_INT 1
72640: PLUS
72641: PPUSH
72642: LD_VAR 0 5
72646: PUSH
72647: LD_INT 1
72649: ARRAY
72650: PUSH
72651: LD_VAR 0 7
72655: PUSH
72656: LD_INT 1
72658: ARRAY
72659: PUSH
72660: LD_VAR 0 7
72664: PUSH
72665: LD_INT 2
72667: ARRAY
72668: PUSH
72669: LD_VAR 0 7
72673: PUSH
72674: LD_INT 3
72676: ARRAY
72677: PUSH
72678: EMPTY
72679: LIST
72680: LIST
72681: LIST
72682: LIST
72683: PPUSH
72684: CALL_OW 2
72688: PPUSH
72689: CALL_OW 1
72693: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
72694: LD_ADDR_VAR 0 5
72698: PUSH
72699: LD_VAR 0 5
72703: PPUSH
72704: LD_INT 1
72706: PPUSH
72707: CALL_OW 3
72711: ST_TO_ADDR
// if not ext_list then
72712: LD_VAR 0 5
72716: NOT
72717: IFFALSE 72723
// exit ;
72719: POP
72720: POP
72721: GO 72727
// end ;
72723: GO 72598
72725: POP
72726: POP
// end ;
72727: LD_VAR 0 6
72731: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
72732: LD_INT 0
72734: PPUSH
// if not mc_bases or not base or not weapon_list then
72735: LD_EXP 23
72739: NOT
72740: PUSH
72741: LD_VAR 0 1
72745: NOT
72746: OR
72747: PUSH
72748: LD_VAR 0 2
72752: NOT
72753: OR
72754: IFFALSE 72758
// exit ;
72756: GO 72783
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
72758: LD_ADDR_EXP 62
72762: PUSH
72763: LD_EXP 62
72767: PPUSH
72768: LD_VAR 0 1
72772: PPUSH
72773: LD_VAR 0 2
72777: PPUSH
72778: CALL_OW 1
72782: ST_TO_ADDR
// end ;
72783: LD_VAR 0 3
72787: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
72788: LD_INT 0
72790: PPUSH
// if not mc_bases or not base or not tech_list then
72791: LD_EXP 23
72795: NOT
72796: PUSH
72797: LD_VAR 0 1
72801: NOT
72802: OR
72803: PUSH
72804: LD_VAR 0 2
72808: NOT
72809: OR
72810: IFFALSE 72814
// exit ;
72812: GO 72839
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
72814: LD_ADDR_EXP 50
72818: PUSH
72819: LD_EXP 50
72823: PPUSH
72824: LD_VAR 0 1
72828: PPUSH
72829: LD_VAR 0 2
72833: PPUSH
72834: CALL_OW 1
72838: ST_TO_ADDR
// end ;
72839: LD_VAR 0 3
72843: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
72844: LD_INT 0
72846: PPUSH
// if not mc_bases or not parking_area or not base then
72847: LD_EXP 23
72851: NOT
72852: PUSH
72853: LD_VAR 0 2
72857: NOT
72858: OR
72859: PUSH
72860: LD_VAR 0 1
72864: NOT
72865: OR
72866: IFFALSE 72870
// exit ;
72868: GO 72895
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
72870: LD_ADDR_EXP 47
72874: PUSH
72875: LD_EXP 47
72879: PPUSH
72880: LD_VAR 0 1
72884: PPUSH
72885: LD_VAR 0 2
72889: PPUSH
72890: CALL_OW 1
72894: ST_TO_ADDR
// end ;
72895: LD_VAR 0 3
72899: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
72900: LD_INT 0
72902: PPUSH
// if not mc_bases or not base or not scan_area then
72903: LD_EXP 23
72907: NOT
72908: PUSH
72909: LD_VAR 0 1
72913: NOT
72914: OR
72915: PUSH
72916: LD_VAR 0 2
72920: NOT
72921: OR
72922: IFFALSE 72926
// exit ;
72924: GO 72951
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
72926: LD_ADDR_EXP 48
72930: PUSH
72931: LD_EXP 48
72935: PPUSH
72936: LD_VAR 0 1
72940: PPUSH
72941: LD_VAR 0 2
72945: PPUSH
72946: CALL_OW 1
72950: ST_TO_ADDR
// end ;
72951: LD_VAR 0 3
72955: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
72956: LD_INT 0
72958: PPUSH
72959: PPUSH
// if not mc_bases or not base then
72960: LD_EXP 23
72964: NOT
72965: PUSH
72966: LD_VAR 0 1
72970: NOT
72971: OR
72972: IFFALSE 72976
// exit ;
72974: GO 73040
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
72976: LD_ADDR_VAR 0 3
72980: PUSH
72981: LD_INT 1
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: LD_INT 3
72989: PUSH
72990: LD_INT 4
72992: PUSH
72993: LD_INT 11
72995: PUSH
72996: EMPTY
72997: LIST
72998: LIST
72999: LIST
73000: LIST
73001: LIST
73002: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
73003: LD_ADDR_EXP 50
73007: PUSH
73008: LD_EXP 50
73012: PPUSH
73013: LD_VAR 0 1
73017: PPUSH
73018: LD_EXP 50
73022: PUSH
73023: LD_VAR 0 1
73027: ARRAY
73028: PUSH
73029: LD_VAR 0 3
73033: DIFF
73034: PPUSH
73035: CALL_OW 1
73039: ST_TO_ADDR
// end ;
73040: LD_VAR 0 2
73044: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
73045: LD_INT 0
73047: PPUSH
// result := mc_vehicles [ base ] ;
73048: LD_ADDR_VAR 0 3
73052: PUSH
73053: LD_EXP 42
73057: PUSH
73058: LD_VAR 0 1
73062: ARRAY
73063: ST_TO_ADDR
// if onlyCombat then
73064: LD_VAR 0 2
73068: IFFALSE 73246
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
73070: LD_ADDR_VAR 0 3
73074: PUSH
73075: LD_VAR 0 3
73079: PUSH
73080: LD_VAR 0 3
73084: PPUSH
73085: LD_INT 2
73087: PUSH
73088: LD_INT 34
73090: PUSH
73091: LD_INT 12
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PUSH
73098: LD_INT 34
73100: PUSH
73101: LD_INT 51
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 34
73110: PUSH
73111: LD_EXP 68
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: PUSH
73120: LD_INT 34
73122: PUSH
73123: LD_INT 32
73125: PUSH
73126: EMPTY
73127: LIST
73128: LIST
73129: PUSH
73130: LD_INT 34
73132: PUSH
73133: LD_INT 13
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: PUSH
73140: LD_INT 34
73142: PUSH
73143: LD_INT 52
73145: PUSH
73146: EMPTY
73147: LIST
73148: LIST
73149: PUSH
73150: LD_INT 34
73152: PUSH
73153: LD_EXP 73
73157: PUSH
73158: EMPTY
73159: LIST
73160: LIST
73161: PUSH
73162: LD_INT 34
73164: PUSH
73165: LD_INT 14
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PUSH
73172: LD_INT 34
73174: PUSH
73175: LD_INT 53
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 34
73184: PUSH
73185: LD_EXP 67
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: LD_INT 34
73196: PUSH
73197: LD_INT 31
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 34
73206: PUSH
73207: LD_INT 48
73209: PUSH
73210: EMPTY
73211: LIST
73212: LIST
73213: PUSH
73214: LD_INT 34
73216: PUSH
73217: LD_INT 8
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: LIST
73228: LIST
73229: LIST
73230: LIST
73231: LIST
73232: LIST
73233: LIST
73234: LIST
73235: LIST
73236: LIST
73237: LIST
73238: LIST
73239: PPUSH
73240: CALL_OW 72
73244: DIFF
73245: ST_TO_ADDR
// end ; end_of_file
73246: LD_VAR 0 3
73250: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
73251: LD_INT 0
73253: PPUSH
73254: PPUSH
73255: PPUSH
// if not mc_bases or not skirmish then
73256: LD_EXP 23
73260: NOT
73261: PUSH
73262: LD_EXP 21
73266: NOT
73267: OR
73268: IFFALSE 73272
// exit ;
73270: GO 73437
// for i = 1 to mc_bases do
73272: LD_ADDR_VAR 0 4
73276: PUSH
73277: DOUBLE
73278: LD_INT 1
73280: DEC
73281: ST_TO_ADDR
73282: LD_EXP 23
73286: PUSH
73287: FOR_TO
73288: IFFALSE 73435
// begin if sci in mc_bases [ i ] then
73290: LD_VAR 0 2
73294: PUSH
73295: LD_EXP 23
73299: PUSH
73300: LD_VAR 0 4
73304: ARRAY
73305: IN
73306: IFFALSE 73433
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
73308: LD_ADDR_EXP 52
73312: PUSH
73313: LD_EXP 52
73317: PPUSH
73318: LD_VAR 0 4
73322: PUSH
73323: LD_EXP 52
73327: PUSH
73328: LD_VAR 0 4
73332: ARRAY
73333: PUSH
73334: LD_INT 1
73336: PLUS
73337: PUSH
73338: EMPTY
73339: LIST
73340: LIST
73341: PPUSH
73342: LD_VAR 0 1
73346: PPUSH
73347: CALL 14060 0 3
73351: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
73352: LD_ADDR_VAR 0 5
73356: PUSH
73357: LD_EXP 23
73361: PUSH
73362: LD_VAR 0 4
73366: ARRAY
73367: PPUSH
73368: LD_INT 2
73370: PUSH
73371: LD_INT 30
73373: PUSH
73374: LD_INT 0
73376: PUSH
73377: EMPTY
73378: LIST
73379: LIST
73380: PUSH
73381: LD_INT 30
73383: PUSH
73384: LD_INT 1
73386: PUSH
73387: EMPTY
73388: LIST
73389: LIST
73390: PUSH
73391: EMPTY
73392: LIST
73393: LIST
73394: LIST
73395: PPUSH
73396: CALL_OW 72
73400: PPUSH
73401: LD_VAR 0 1
73405: PPUSH
73406: CALL_OW 74
73410: ST_TO_ADDR
// if tmp then
73411: LD_VAR 0 5
73415: IFFALSE 73431
// ComStandNearbyBuilding ( ape , tmp ) ;
73417: LD_VAR 0 1
73421: PPUSH
73422: LD_VAR 0 5
73426: PPUSH
73427: CALL 10638 0 2
// break ;
73431: GO 73435
// end ; end ;
73433: GO 73287
73435: POP
73436: POP
// end ;
73437: LD_VAR 0 3
73441: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
73442: LD_INT 0
73444: PPUSH
73445: PPUSH
73446: PPUSH
// if not mc_bases or not skirmish then
73447: LD_EXP 23
73451: NOT
73452: PUSH
73453: LD_EXP 21
73457: NOT
73458: OR
73459: IFFALSE 73463
// exit ;
73461: GO 73552
// for i = 1 to mc_bases do
73463: LD_ADDR_VAR 0 4
73467: PUSH
73468: DOUBLE
73469: LD_INT 1
73471: DEC
73472: ST_TO_ADDR
73473: LD_EXP 23
73477: PUSH
73478: FOR_TO
73479: IFFALSE 73550
// begin if building in mc_busy_turret_list [ i ] then
73481: LD_VAR 0 1
73485: PUSH
73486: LD_EXP 33
73490: PUSH
73491: LD_VAR 0 4
73495: ARRAY
73496: IN
73497: IFFALSE 73548
// begin tmp := mc_busy_turret_list [ i ] diff building ;
73499: LD_ADDR_VAR 0 5
73503: PUSH
73504: LD_EXP 33
73508: PUSH
73509: LD_VAR 0 4
73513: ARRAY
73514: PUSH
73515: LD_VAR 0 1
73519: DIFF
73520: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
73521: LD_ADDR_EXP 33
73525: PUSH
73526: LD_EXP 33
73530: PPUSH
73531: LD_VAR 0 4
73535: PPUSH
73536: LD_VAR 0 5
73540: PPUSH
73541: CALL_OW 1
73545: ST_TO_ADDR
// break ;
73546: GO 73550
// end ; end ;
73548: GO 73478
73550: POP
73551: POP
// end ;
73552: LD_VAR 0 3
73556: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
73557: LD_INT 0
73559: PPUSH
73560: PPUSH
73561: PPUSH
// if not mc_bases or not skirmish then
73562: LD_EXP 23
73566: NOT
73567: PUSH
73568: LD_EXP 21
73572: NOT
73573: OR
73574: IFFALSE 73578
// exit ;
73576: GO 73777
// for i = 1 to mc_bases do
73578: LD_ADDR_VAR 0 5
73582: PUSH
73583: DOUBLE
73584: LD_INT 1
73586: DEC
73587: ST_TO_ADDR
73588: LD_EXP 23
73592: PUSH
73593: FOR_TO
73594: IFFALSE 73775
// if building in mc_bases [ i ] then
73596: LD_VAR 0 1
73600: PUSH
73601: LD_EXP 23
73605: PUSH
73606: LD_VAR 0 5
73610: ARRAY
73611: IN
73612: IFFALSE 73773
// begin tmp := mc_bases [ i ] diff building ;
73614: LD_ADDR_VAR 0 6
73618: PUSH
73619: LD_EXP 23
73623: PUSH
73624: LD_VAR 0 5
73628: ARRAY
73629: PUSH
73630: LD_VAR 0 1
73634: DIFF
73635: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
73636: LD_ADDR_EXP 23
73640: PUSH
73641: LD_EXP 23
73645: PPUSH
73646: LD_VAR 0 5
73650: PPUSH
73651: LD_VAR 0 6
73655: PPUSH
73656: CALL_OW 1
73660: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
73661: LD_VAR 0 1
73665: PUSH
73666: LD_EXP 31
73670: PUSH
73671: LD_VAR 0 5
73675: ARRAY
73676: IN
73677: IFFALSE 73716
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
73679: LD_ADDR_EXP 31
73683: PUSH
73684: LD_EXP 31
73688: PPUSH
73689: LD_VAR 0 5
73693: PPUSH
73694: LD_EXP 31
73698: PUSH
73699: LD_VAR 0 5
73703: ARRAY
73704: PUSH
73705: LD_VAR 0 1
73709: DIFF
73710: PPUSH
73711: CALL_OW 1
73715: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
73716: LD_VAR 0 1
73720: PUSH
73721: LD_EXP 32
73725: PUSH
73726: LD_VAR 0 5
73730: ARRAY
73731: IN
73732: IFFALSE 73771
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
73734: LD_ADDR_EXP 32
73738: PUSH
73739: LD_EXP 32
73743: PPUSH
73744: LD_VAR 0 5
73748: PPUSH
73749: LD_EXP 32
73753: PUSH
73754: LD_VAR 0 5
73758: ARRAY
73759: PUSH
73760: LD_VAR 0 1
73764: DIFF
73765: PPUSH
73766: CALL_OW 1
73770: ST_TO_ADDR
// break ;
73771: GO 73775
// end ;
73773: GO 73593
73775: POP
73776: POP
// end ;
73777: LD_VAR 0 4
73781: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
73782: LD_INT 0
73784: PPUSH
73785: PPUSH
73786: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
73787: LD_EXP 23
73791: NOT
73792: PUSH
73793: LD_EXP 21
73797: NOT
73798: OR
73799: PUSH
73800: LD_VAR 0 3
73804: PUSH
73805: LD_EXP 49
73809: IN
73810: NOT
73811: OR
73812: IFFALSE 73816
// exit ;
73814: GO 73939
// for i = 1 to mc_vehicles do
73816: LD_ADDR_VAR 0 6
73820: PUSH
73821: DOUBLE
73822: LD_INT 1
73824: DEC
73825: ST_TO_ADDR
73826: LD_EXP 42
73830: PUSH
73831: FOR_TO
73832: IFFALSE 73937
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
73834: LD_VAR 0 2
73838: PUSH
73839: LD_EXP 42
73843: PUSH
73844: LD_VAR 0 6
73848: ARRAY
73849: IN
73850: PUSH
73851: LD_VAR 0 1
73855: PUSH
73856: LD_EXP 42
73860: PUSH
73861: LD_VAR 0 6
73865: ARRAY
73866: IN
73867: OR
73868: IFFALSE 73935
// begin tmp := mc_vehicles [ i ] diff old ;
73870: LD_ADDR_VAR 0 7
73874: PUSH
73875: LD_EXP 42
73879: PUSH
73880: LD_VAR 0 6
73884: ARRAY
73885: PUSH
73886: LD_VAR 0 2
73890: DIFF
73891: ST_TO_ADDR
// tmp := tmp diff new ;
73892: LD_ADDR_VAR 0 7
73896: PUSH
73897: LD_VAR 0 7
73901: PUSH
73902: LD_VAR 0 1
73906: DIFF
73907: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
73908: LD_ADDR_EXP 42
73912: PUSH
73913: LD_EXP 42
73917: PPUSH
73918: LD_VAR 0 6
73922: PPUSH
73923: LD_VAR 0 7
73927: PPUSH
73928: CALL_OW 1
73932: ST_TO_ADDR
// break ;
73933: GO 73937
// end ;
73935: GO 73831
73937: POP
73938: POP
// end ;
73939: LD_VAR 0 5
73943: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
73944: LD_INT 0
73946: PPUSH
73947: PPUSH
73948: PPUSH
73949: PPUSH
// if not mc_bases or not skirmish then
73950: LD_EXP 23
73954: NOT
73955: PUSH
73956: LD_EXP 21
73960: NOT
73961: OR
73962: IFFALSE 73966
// exit ;
73964: GO 74358
// side := GetSide ( vehicle ) ;
73966: LD_ADDR_VAR 0 5
73970: PUSH
73971: LD_VAR 0 1
73975: PPUSH
73976: CALL_OW 255
73980: ST_TO_ADDR
// for i = 1 to mc_bases do
73981: LD_ADDR_VAR 0 4
73985: PUSH
73986: DOUBLE
73987: LD_INT 1
73989: DEC
73990: ST_TO_ADDR
73991: LD_EXP 23
73995: PUSH
73996: FOR_TO
73997: IFFALSE 74356
// begin if factory in mc_bases [ i ] then
73999: LD_VAR 0 2
74003: PUSH
74004: LD_EXP 23
74008: PUSH
74009: LD_VAR 0 4
74013: ARRAY
74014: IN
74015: IFFALSE 74354
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
74017: LD_EXP 45
74021: PUSH
74022: LD_VAR 0 4
74026: ARRAY
74027: PUSH
74028: LD_EXP 34
74032: PUSH
74033: LD_VAR 0 4
74037: ARRAY
74038: LESS
74039: PUSH
74040: LD_VAR 0 1
74044: PPUSH
74045: CALL_OW 264
74049: PUSH
74050: LD_INT 31
74052: PUSH
74053: LD_INT 32
74055: PUSH
74056: LD_INT 51
74058: PUSH
74059: LD_EXP 68
74063: PUSH
74064: LD_INT 12
74066: PUSH
74067: LD_INT 30
74069: PUSH
74070: LD_EXP 67
74074: PUSH
74075: LD_INT 11
74077: PUSH
74078: LD_INT 53
74080: PUSH
74081: LD_INT 14
74083: PUSH
74084: LD_EXP 71
74088: PUSH
74089: LD_INT 29
74091: PUSH
74092: LD_EXP 69
74096: PUSH
74097: LD_INT 13
74099: PUSH
74100: LD_INT 52
74102: PUSH
74103: LD_EXP 73
74107: PUSH
74108: LD_INT 48
74110: PUSH
74111: LD_INT 8
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: LIST
74118: LIST
74119: LIST
74120: LIST
74121: LIST
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: LIST
74130: LIST
74131: LIST
74132: LIST
74133: IN
74134: NOT
74135: AND
74136: IFFALSE 74184
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
74138: LD_ADDR_EXP 45
74142: PUSH
74143: LD_EXP 45
74147: PPUSH
74148: LD_VAR 0 4
74152: PUSH
74153: LD_EXP 45
74157: PUSH
74158: LD_VAR 0 4
74162: ARRAY
74163: PUSH
74164: LD_INT 1
74166: PLUS
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PPUSH
74172: LD_VAR 0 1
74176: PPUSH
74177: CALL 14060 0 3
74181: ST_TO_ADDR
74182: GO 74228
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
74184: LD_ADDR_EXP 42
74188: PUSH
74189: LD_EXP 42
74193: PPUSH
74194: LD_VAR 0 4
74198: PUSH
74199: LD_EXP 42
74203: PUSH
74204: LD_VAR 0 4
74208: ARRAY
74209: PUSH
74210: LD_INT 1
74212: PLUS
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PPUSH
74218: LD_VAR 0 1
74222: PPUSH
74223: CALL 14060 0 3
74227: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
74228: LD_VAR 0 1
74232: PPUSH
74233: CALL_OW 263
74237: PUSH
74238: LD_INT 2
74240: EQUAL
74241: IFFALSE 74270
// begin repeat Connect ( vehicle ) ;
74243: LD_VAR 0 1
74247: PPUSH
74248: CALL 17031 0 1
// wait ( 0 0$1 ) ;
74252: LD_INT 35
74254: PPUSH
74255: CALL_OW 67
// until IsControledBy ( vehicle ) ;
74259: LD_VAR 0 1
74263: PPUSH
74264: CALL_OW 312
74268: IFFALSE 74243
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
74270: LD_VAR 0 1
74274: PPUSH
74275: LD_EXP 47
74279: PUSH
74280: LD_VAR 0 4
74284: ARRAY
74285: PPUSH
74286: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
74290: LD_VAR 0 1
74294: PPUSH
74295: CALL_OW 263
74299: PUSH
74300: LD_INT 1
74302: NONEQUAL
74303: IFFALSE 74307
// break ;
74305: GO 74356
// repeat wait ( 0 0$1 ) ;
74307: LD_INT 35
74309: PPUSH
74310: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
74314: LD_VAR 0 1
74318: PPUSH
74319: LD_EXP 47
74323: PUSH
74324: LD_VAR 0 4
74328: ARRAY
74329: PPUSH
74330: CALL_OW 308
74334: IFFALSE 74307
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
74336: LD_VAR 0 1
74340: PPUSH
74341: CALL_OW 311
74345: PPUSH
74346: CALL_OW 121
// exit ;
74350: POP
74351: POP
74352: GO 74358
// end ; end ;
74354: GO 73996
74356: POP
74357: POP
// end ;
74358: LD_VAR 0 3
74362: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
74363: LD_INT 0
74365: PPUSH
74366: PPUSH
74367: PPUSH
74368: PPUSH
// if not mc_bases or not skirmish then
74369: LD_EXP 23
74373: NOT
74374: PUSH
74375: LD_EXP 21
74379: NOT
74380: OR
74381: IFFALSE 74385
// exit ;
74383: GO 74738
// repeat wait ( 0 0$1 ) ;
74385: LD_INT 35
74387: PPUSH
74388: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
74392: LD_VAR 0 2
74396: PPUSH
74397: LD_VAR 0 3
74401: PPUSH
74402: CALL_OW 284
74406: IFFALSE 74385
// if GetResourceTypeXY ( x , y ) = mat_artefact then
74408: LD_VAR 0 2
74412: PPUSH
74413: LD_VAR 0 3
74417: PPUSH
74418: CALL_OW 283
74422: PUSH
74423: LD_INT 4
74425: EQUAL
74426: IFFALSE 74430
// exit ;
74428: GO 74738
// for i = 1 to mc_bases do
74430: LD_ADDR_VAR 0 7
74434: PUSH
74435: DOUBLE
74436: LD_INT 1
74438: DEC
74439: ST_TO_ADDR
74440: LD_EXP 23
74444: PUSH
74445: FOR_TO
74446: IFFALSE 74736
// begin if mc_crates_area [ i ] then
74448: LD_EXP 41
74452: PUSH
74453: LD_VAR 0 7
74457: ARRAY
74458: IFFALSE 74569
// for j in mc_crates_area [ i ] do
74460: LD_ADDR_VAR 0 8
74464: PUSH
74465: LD_EXP 41
74469: PUSH
74470: LD_VAR 0 7
74474: ARRAY
74475: PUSH
74476: FOR_IN
74477: IFFALSE 74567
// if InArea ( x , y , j ) then
74479: LD_VAR 0 2
74483: PPUSH
74484: LD_VAR 0 3
74488: PPUSH
74489: LD_VAR 0 8
74493: PPUSH
74494: CALL_OW 309
74498: IFFALSE 74565
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74500: LD_ADDR_EXP 39
74504: PUSH
74505: LD_EXP 39
74509: PPUSH
74510: LD_VAR 0 7
74514: PUSH
74515: LD_EXP 39
74519: PUSH
74520: LD_VAR 0 7
74524: ARRAY
74525: PUSH
74526: LD_INT 1
74528: PLUS
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: PPUSH
74534: LD_VAR 0 4
74538: PUSH
74539: LD_VAR 0 2
74543: PUSH
74544: LD_VAR 0 3
74548: PUSH
74549: EMPTY
74550: LIST
74551: LIST
74552: LIST
74553: PPUSH
74554: CALL 14060 0 3
74558: ST_TO_ADDR
// exit ;
74559: POP
74560: POP
74561: POP
74562: POP
74563: GO 74738
// end ;
74565: GO 74476
74567: POP
74568: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74569: LD_ADDR_VAR 0 9
74573: PUSH
74574: LD_EXP 23
74578: PUSH
74579: LD_VAR 0 7
74583: ARRAY
74584: PPUSH
74585: LD_INT 2
74587: PUSH
74588: LD_INT 30
74590: PUSH
74591: LD_INT 0
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 30
74600: PUSH
74601: LD_INT 1
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: EMPTY
74609: LIST
74610: LIST
74611: LIST
74612: PPUSH
74613: CALL_OW 72
74617: ST_TO_ADDR
// if not depot then
74618: LD_VAR 0 9
74622: NOT
74623: IFFALSE 74627
// continue ;
74625: GO 74445
// for j in depot do
74627: LD_ADDR_VAR 0 8
74631: PUSH
74632: LD_VAR 0 9
74636: PUSH
74637: FOR_IN
74638: IFFALSE 74732
// if GetDistUnitXY ( j , x , y ) < 30 then
74640: LD_VAR 0 8
74644: PPUSH
74645: LD_VAR 0 2
74649: PPUSH
74650: LD_VAR 0 3
74654: PPUSH
74655: CALL_OW 297
74659: PUSH
74660: LD_INT 30
74662: LESS
74663: IFFALSE 74730
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
74665: LD_ADDR_EXP 39
74669: PUSH
74670: LD_EXP 39
74674: PPUSH
74675: LD_VAR 0 7
74679: PUSH
74680: LD_EXP 39
74684: PUSH
74685: LD_VAR 0 7
74689: ARRAY
74690: PUSH
74691: LD_INT 1
74693: PLUS
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PPUSH
74699: LD_VAR 0 4
74703: PUSH
74704: LD_VAR 0 2
74708: PUSH
74709: LD_VAR 0 3
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: LIST
74718: PPUSH
74719: CALL 14060 0 3
74723: ST_TO_ADDR
// exit ;
74724: POP
74725: POP
74726: POP
74727: POP
74728: GO 74738
// end ;
74730: GO 74637
74732: POP
74733: POP
// end ;
74734: GO 74445
74736: POP
74737: POP
// end ;
74738: LD_VAR 0 6
74742: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
74743: LD_INT 0
74745: PPUSH
74746: PPUSH
74747: PPUSH
74748: PPUSH
// if not mc_bases or not skirmish then
74749: LD_EXP 23
74753: NOT
74754: PUSH
74755: LD_EXP 21
74759: NOT
74760: OR
74761: IFFALSE 74765
// exit ;
74763: GO 75042
// side := GetSide ( lab ) ;
74765: LD_ADDR_VAR 0 4
74769: PUSH
74770: LD_VAR 0 2
74774: PPUSH
74775: CALL_OW 255
74779: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
74780: LD_VAR 0 4
74784: PUSH
74785: LD_EXP 49
74789: IN
74790: NOT
74791: PUSH
74792: LD_EXP 50
74796: NOT
74797: OR
74798: PUSH
74799: LD_EXP 23
74803: NOT
74804: OR
74805: IFFALSE 74809
// exit ;
74807: GO 75042
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
74809: LD_ADDR_EXP 50
74813: PUSH
74814: LD_EXP 50
74818: PPUSH
74819: LD_VAR 0 4
74823: PPUSH
74824: LD_EXP 50
74828: PUSH
74829: LD_VAR 0 4
74833: ARRAY
74834: PUSH
74835: LD_VAR 0 1
74839: DIFF
74840: PPUSH
74841: CALL_OW 1
74845: ST_TO_ADDR
// for i = 1 to mc_bases do
74846: LD_ADDR_VAR 0 5
74850: PUSH
74851: DOUBLE
74852: LD_INT 1
74854: DEC
74855: ST_TO_ADDR
74856: LD_EXP 23
74860: PUSH
74861: FOR_TO
74862: IFFALSE 75040
// begin if lab in mc_bases [ i ] then
74864: LD_VAR 0 2
74868: PUSH
74869: LD_EXP 23
74873: PUSH
74874: LD_VAR 0 5
74878: ARRAY
74879: IN
74880: IFFALSE 75038
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
74882: LD_VAR 0 1
74886: PUSH
74887: LD_INT 11
74889: PUSH
74890: LD_INT 4
74892: PUSH
74893: LD_INT 3
74895: PUSH
74896: LD_INT 2
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: LIST
74903: LIST
74904: IN
74905: PUSH
74906: LD_EXP 53
74910: PUSH
74911: LD_VAR 0 5
74915: ARRAY
74916: AND
74917: IFFALSE 75038
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
74919: LD_ADDR_VAR 0 6
74923: PUSH
74924: LD_EXP 53
74928: PUSH
74929: LD_VAR 0 5
74933: ARRAY
74934: PUSH
74935: LD_INT 1
74937: ARRAY
74938: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
74939: LD_ADDR_EXP 53
74943: PUSH
74944: LD_EXP 53
74948: PPUSH
74949: LD_VAR 0 5
74953: PPUSH
74954: EMPTY
74955: PPUSH
74956: CALL_OW 1
74960: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
74961: LD_VAR 0 6
74965: PPUSH
74966: LD_INT 0
74968: PPUSH
74969: CALL_OW 109
// ComExitBuilding ( tmp ) ;
74973: LD_VAR 0 6
74977: PPUSH
74978: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
74982: LD_ADDR_EXP 52
74986: PUSH
74987: LD_EXP 52
74991: PPUSH
74992: LD_VAR 0 5
74996: PPUSH
74997: LD_EXP 52
75001: PUSH
75002: LD_VAR 0 5
75006: ARRAY
75007: PPUSH
75008: LD_INT 1
75010: PPUSH
75011: LD_VAR 0 6
75015: PPUSH
75016: CALL_OW 2
75020: PPUSH
75021: CALL_OW 1
75025: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
75026: LD_VAR 0 5
75030: PPUSH
75031: LD_INT 112
75033: PPUSH
75034: CALL 51777 0 2
// end ; end ; end ;
75038: GO 74861
75040: POP
75041: POP
// end ;
75042: LD_VAR 0 3
75046: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
75047: LD_INT 0
75049: PPUSH
75050: PPUSH
75051: PPUSH
75052: PPUSH
75053: PPUSH
75054: PPUSH
75055: PPUSH
75056: PPUSH
// if not mc_bases or not skirmish then
75057: LD_EXP 23
75061: NOT
75062: PUSH
75063: LD_EXP 21
75067: NOT
75068: OR
75069: IFFALSE 75073
// exit ;
75071: GO 76444
// for i = 1 to mc_bases do
75073: LD_ADDR_VAR 0 3
75077: PUSH
75078: DOUBLE
75079: LD_INT 1
75081: DEC
75082: ST_TO_ADDR
75083: LD_EXP 23
75087: PUSH
75088: FOR_TO
75089: IFFALSE 76442
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
75091: LD_VAR 0 1
75095: PUSH
75096: LD_EXP 23
75100: PUSH
75101: LD_VAR 0 3
75105: ARRAY
75106: IN
75107: PUSH
75108: LD_VAR 0 1
75112: PUSH
75113: LD_EXP 30
75117: PUSH
75118: LD_VAR 0 3
75122: ARRAY
75123: IN
75124: OR
75125: PUSH
75126: LD_VAR 0 1
75130: PUSH
75131: LD_EXP 45
75135: PUSH
75136: LD_VAR 0 3
75140: ARRAY
75141: IN
75142: OR
75143: PUSH
75144: LD_VAR 0 1
75148: PUSH
75149: LD_EXP 42
75153: PUSH
75154: LD_VAR 0 3
75158: ARRAY
75159: IN
75160: OR
75161: PUSH
75162: LD_VAR 0 1
75166: PUSH
75167: LD_EXP 52
75171: PUSH
75172: LD_VAR 0 3
75176: ARRAY
75177: IN
75178: OR
75179: PUSH
75180: LD_VAR 0 1
75184: PUSH
75185: LD_EXP 53
75189: PUSH
75190: LD_VAR 0 3
75194: ARRAY
75195: IN
75196: OR
75197: IFFALSE 76440
// begin if un in mc_ape [ i ] then
75199: LD_VAR 0 1
75203: PUSH
75204: LD_EXP 52
75208: PUSH
75209: LD_VAR 0 3
75213: ARRAY
75214: IN
75215: IFFALSE 75254
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
75217: LD_ADDR_EXP 52
75221: PUSH
75222: LD_EXP 52
75226: PPUSH
75227: LD_VAR 0 3
75231: PPUSH
75232: LD_EXP 52
75236: PUSH
75237: LD_VAR 0 3
75241: ARRAY
75242: PUSH
75243: LD_VAR 0 1
75247: DIFF
75248: PPUSH
75249: CALL_OW 1
75253: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
75254: LD_VAR 0 1
75258: PUSH
75259: LD_EXP 53
75263: PUSH
75264: LD_VAR 0 3
75268: ARRAY
75269: IN
75270: IFFALSE 75294
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
75272: LD_ADDR_EXP 53
75276: PUSH
75277: LD_EXP 53
75281: PPUSH
75282: LD_VAR 0 3
75286: PPUSH
75287: EMPTY
75288: PPUSH
75289: CALL_OW 1
75293: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
75294: LD_VAR 0 1
75298: PPUSH
75299: CALL_OW 247
75303: PUSH
75304: LD_INT 2
75306: EQUAL
75307: PUSH
75308: LD_VAR 0 1
75312: PPUSH
75313: CALL_OW 110
75317: PUSH
75318: LD_INT 20
75320: EQUAL
75321: PUSH
75322: LD_VAR 0 1
75326: PUSH
75327: LD_EXP 45
75331: PUSH
75332: LD_VAR 0 3
75336: ARRAY
75337: IN
75338: OR
75339: PUSH
75340: LD_VAR 0 1
75344: PPUSH
75345: CALL_OW 264
75349: PUSH
75350: LD_INT 12
75352: PUSH
75353: LD_INT 51
75355: PUSH
75356: LD_EXP 68
75360: PUSH
75361: LD_INT 32
75363: PUSH
75364: LD_INT 13
75366: PUSH
75367: LD_INT 52
75369: PUSH
75370: LD_INT 31
75372: PUSH
75373: EMPTY
75374: LIST
75375: LIST
75376: LIST
75377: LIST
75378: LIST
75379: LIST
75380: LIST
75381: IN
75382: OR
75383: AND
75384: IFFALSE 75692
// begin if un in mc_defender [ i ] then
75386: LD_VAR 0 1
75390: PUSH
75391: LD_EXP 45
75395: PUSH
75396: LD_VAR 0 3
75400: ARRAY
75401: IN
75402: IFFALSE 75441
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
75404: LD_ADDR_EXP 45
75408: PUSH
75409: LD_EXP 45
75413: PPUSH
75414: LD_VAR 0 3
75418: PPUSH
75419: LD_EXP 45
75423: PUSH
75424: LD_VAR 0 3
75428: ARRAY
75429: PUSH
75430: LD_VAR 0 1
75434: DIFF
75435: PPUSH
75436: CALL_OW 1
75440: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
75441: LD_ADDR_VAR 0 8
75445: PUSH
75446: LD_VAR 0 3
75450: PPUSH
75451: LD_INT 3
75453: PPUSH
75454: CALL 72082 0 2
75458: ST_TO_ADDR
// if fac then
75459: LD_VAR 0 8
75463: IFFALSE 75692
// begin for j in fac do
75465: LD_ADDR_VAR 0 4
75469: PUSH
75470: LD_VAR 0 8
75474: PUSH
75475: FOR_IN
75476: IFFALSE 75690
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
75478: LD_ADDR_VAR 0 9
75482: PUSH
75483: LD_VAR 0 8
75487: PPUSH
75488: LD_VAR 0 1
75492: PPUSH
75493: CALL_OW 265
75497: PPUSH
75498: LD_VAR 0 1
75502: PPUSH
75503: CALL_OW 262
75507: PPUSH
75508: LD_VAR 0 1
75512: PPUSH
75513: CALL_OW 263
75517: PPUSH
75518: LD_VAR 0 1
75522: PPUSH
75523: CALL_OW 264
75527: PPUSH
75528: CALL 11556 0 5
75532: ST_TO_ADDR
// if components then
75533: LD_VAR 0 9
75537: IFFALSE 75688
// begin if GetWeapon ( un ) = ar_control_tower then
75539: LD_VAR 0 1
75543: PPUSH
75544: CALL_OW 264
75548: PUSH
75549: LD_INT 31
75551: EQUAL
75552: IFFALSE 75669
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
75554: LD_VAR 0 1
75558: PPUSH
75559: CALL_OW 311
75563: PPUSH
75564: LD_INT 0
75566: PPUSH
75567: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
75571: LD_ADDR_EXP 63
75575: PUSH
75576: LD_EXP 63
75580: PPUSH
75581: LD_VAR 0 3
75585: PPUSH
75586: LD_EXP 63
75590: PUSH
75591: LD_VAR 0 3
75595: ARRAY
75596: PUSH
75597: LD_VAR 0 1
75601: PPUSH
75602: CALL_OW 311
75606: DIFF
75607: PPUSH
75608: CALL_OW 1
75612: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
75613: LD_ADDR_VAR 0 7
75617: PUSH
75618: LD_EXP 44
75622: PUSH
75623: LD_VAR 0 3
75627: ARRAY
75628: PPUSH
75629: LD_INT 1
75631: PPUSH
75632: LD_VAR 0 9
75636: PPUSH
75637: CALL_OW 2
75641: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75642: LD_ADDR_EXP 44
75646: PUSH
75647: LD_EXP 44
75651: PPUSH
75652: LD_VAR 0 3
75656: PPUSH
75657: LD_VAR 0 7
75661: PPUSH
75662: CALL_OW 1
75666: ST_TO_ADDR
// end else
75667: GO 75686
// MC_InsertProduceList ( i , [ components ] ) ;
75669: LD_VAR 0 3
75673: PPUSH
75674: LD_VAR 0 9
75678: PUSH
75679: EMPTY
75680: LIST
75681: PPUSH
75682: CALL 71627 0 2
// break ;
75686: GO 75690
// end ; end ;
75688: GO 75475
75690: POP
75691: POP
// end ; end ; if GetType ( un ) = unit_building then
75692: LD_VAR 0 1
75696: PPUSH
75697: CALL_OW 247
75701: PUSH
75702: LD_INT 3
75704: EQUAL
75705: IFFALSE 76108
// begin btype := GetBType ( un ) ;
75707: LD_ADDR_VAR 0 5
75711: PUSH
75712: LD_VAR 0 1
75716: PPUSH
75717: CALL_OW 266
75721: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
75722: LD_VAR 0 5
75726: PUSH
75727: LD_INT 29
75729: PUSH
75730: LD_INT 30
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: IN
75737: IFFALSE 75810
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
75739: LD_VAR 0 1
75743: PPUSH
75744: CALL_OW 250
75748: PPUSH
75749: LD_VAR 0 1
75753: PPUSH
75754: CALL_OW 251
75758: PPUSH
75759: LD_VAR 0 1
75763: PPUSH
75764: CALL_OW 255
75768: PPUSH
75769: CALL_OW 440
75773: NOT
75774: IFFALSE 75810
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
75776: LD_VAR 0 1
75780: PPUSH
75781: CALL_OW 250
75785: PPUSH
75786: LD_VAR 0 1
75790: PPUSH
75791: CALL_OW 251
75795: PPUSH
75796: LD_VAR 0 1
75800: PPUSH
75801: CALL_OW 255
75805: PPUSH
75806: CALL_OW 441
// end ; if btype = b_warehouse then
75810: LD_VAR 0 5
75814: PUSH
75815: LD_INT 1
75817: EQUAL
75818: IFFALSE 75836
// begin btype := b_depot ;
75820: LD_ADDR_VAR 0 5
75824: PUSH
75825: LD_INT 0
75827: ST_TO_ADDR
// pos := 1 ;
75828: LD_ADDR_VAR 0 6
75832: PUSH
75833: LD_INT 1
75835: ST_TO_ADDR
// end ; if btype = b_factory then
75836: LD_VAR 0 5
75840: PUSH
75841: LD_INT 3
75843: EQUAL
75844: IFFALSE 75862
// begin btype := b_workshop ;
75846: LD_ADDR_VAR 0 5
75850: PUSH
75851: LD_INT 2
75853: ST_TO_ADDR
// pos := 1 ;
75854: LD_ADDR_VAR 0 6
75858: PUSH
75859: LD_INT 1
75861: ST_TO_ADDR
// end ; if btype = b_barracks then
75862: LD_VAR 0 5
75866: PUSH
75867: LD_INT 5
75869: EQUAL
75870: IFFALSE 75880
// btype := b_armoury ;
75872: LD_ADDR_VAR 0 5
75876: PUSH
75877: LD_INT 4
75879: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
75880: LD_VAR 0 5
75884: PUSH
75885: LD_INT 7
75887: PUSH
75888: LD_INT 8
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: IN
75895: IFFALSE 75905
// btype := b_lab ;
75897: LD_ADDR_VAR 0 5
75901: PUSH
75902: LD_INT 6
75904: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
75905: LD_ADDR_EXP 28
75909: PUSH
75910: LD_EXP 28
75914: PPUSH
75915: LD_VAR 0 3
75919: PUSH
75920: LD_EXP 28
75924: PUSH
75925: LD_VAR 0 3
75929: ARRAY
75930: PUSH
75931: LD_INT 1
75933: PLUS
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PPUSH
75939: LD_VAR 0 5
75943: PUSH
75944: LD_VAR 0 1
75948: PPUSH
75949: CALL_OW 250
75953: PUSH
75954: LD_VAR 0 1
75958: PPUSH
75959: CALL_OW 251
75963: PUSH
75964: LD_VAR 0 1
75968: PPUSH
75969: CALL_OW 254
75973: PUSH
75974: EMPTY
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: PPUSH
75980: CALL 14060 0 3
75984: ST_TO_ADDR
// if pos = 1 then
75985: LD_VAR 0 6
75989: PUSH
75990: LD_INT 1
75992: EQUAL
75993: IFFALSE 76108
// begin tmp := mc_build_list [ i ] ;
75995: LD_ADDR_VAR 0 7
75999: PUSH
76000: LD_EXP 28
76004: PUSH
76005: LD_VAR 0 3
76009: ARRAY
76010: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76011: LD_VAR 0 7
76015: PPUSH
76016: LD_INT 2
76018: PUSH
76019: LD_INT 30
76021: PUSH
76022: LD_INT 0
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: PUSH
76029: LD_INT 30
76031: PUSH
76032: LD_INT 1
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: LIST
76043: PPUSH
76044: CALL_OW 72
76048: IFFALSE 76058
// pos := 2 ;
76050: LD_ADDR_VAR 0 6
76054: PUSH
76055: LD_INT 2
76057: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
76058: LD_ADDR_VAR 0 7
76062: PUSH
76063: LD_VAR 0 7
76067: PPUSH
76068: LD_VAR 0 6
76072: PPUSH
76073: LD_VAR 0 7
76077: PPUSH
76078: CALL 14386 0 3
76082: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
76083: LD_ADDR_EXP 28
76087: PUSH
76088: LD_EXP 28
76092: PPUSH
76093: LD_VAR 0 3
76097: PPUSH
76098: LD_VAR 0 7
76102: PPUSH
76103: CALL_OW 1
76107: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
76108: LD_VAR 0 1
76112: PUSH
76113: LD_EXP 23
76117: PUSH
76118: LD_VAR 0 3
76122: ARRAY
76123: IN
76124: IFFALSE 76163
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
76126: LD_ADDR_EXP 23
76130: PUSH
76131: LD_EXP 23
76135: PPUSH
76136: LD_VAR 0 3
76140: PPUSH
76141: LD_EXP 23
76145: PUSH
76146: LD_VAR 0 3
76150: ARRAY
76151: PUSH
76152: LD_VAR 0 1
76156: DIFF
76157: PPUSH
76158: CALL_OW 1
76162: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
76163: LD_VAR 0 1
76167: PUSH
76168: LD_EXP 30
76172: PUSH
76173: LD_VAR 0 3
76177: ARRAY
76178: IN
76179: IFFALSE 76218
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
76181: LD_ADDR_EXP 30
76185: PUSH
76186: LD_EXP 30
76190: PPUSH
76191: LD_VAR 0 3
76195: PPUSH
76196: LD_EXP 30
76200: PUSH
76201: LD_VAR 0 3
76205: ARRAY
76206: PUSH
76207: LD_VAR 0 1
76211: DIFF
76212: PPUSH
76213: CALL_OW 1
76217: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
76218: LD_VAR 0 1
76222: PUSH
76223: LD_EXP 42
76227: PUSH
76228: LD_VAR 0 3
76232: ARRAY
76233: IN
76234: IFFALSE 76273
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
76236: LD_ADDR_EXP 42
76240: PUSH
76241: LD_EXP 42
76245: PPUSH
76246: LD_VAR 0 3
76250: PPUSH
76251: LD_EXP 42
76255: PUSH
76256: LD_VAR 0 3
76260: ARRAY
76261: PUSH
76262: LD_VAR 0 1
76266: DIFF
76267: PPUSH
76268: CALL_OW 1
76272: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
76273: LD_VAR 0 1
76277: PUSH
76278: LD_EXP 45
76282: PUSH
76283: LD_VAR 0 3
76287: ARRAY
76288: IN
76289: IFFALSE 76328
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
76291: LD_ADDR_EXP 45
76295: PUSH
76296: LD_EXP 45
76300: PPUSH
76301: LD_VAR 0 3
76305: PPUSH
76306: LD_EXP 45
76310: PUSH
76311: LD_VAR 0 3
76315: ARRAY
76316: PUSH
76317: LD_VAR 0 1
76321: DIFF
76322: PPUSH
76323: CALL_OW 1
76327: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
76328: LD_VAR 0 1
76332: PUSH
76333: LD_EXP 32
76337: PUSH
76338: LD_VAR 0 3
76342: ARRAY
76343: IN
76344: IFFALSE 76383
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
76346: LD_ADDR_EXP 32
76350: PUSH
76351: LD_EXP 32
76355: PPUSH
76356: LD_VAR 0 3
76360: PPUSH
76361: LD_EXP 32
76365: PUSH
76366: LD_VAR 0 3
76370: ARRAY
76371: PUSH
76372: LD_VAR 0 1
76376: DIFF
76377: PPUSH
76378: CALL_OW 1
76382: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
76383: LD_VAR 0 1
76387: PUSH
76388: LD_EXP 31
76392: PUSH
76393: LD_VAR 0 3
76397: ARRAY
76398: IN
76399: IFFALSE 76438
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
76401: LD_ADDR_EXP 31
76405: PUSH
76406: LD_EXP 31
76410: PPUSH
76411: LD_VAR 0 3
76415: PPUSH
76416: LD_EXP 31
76420: PUSH
76421: LD_VAR 0 3
76425: ARRAY
76426: PUSH
76427: LD_VAR 0 1
76431: DIFF
76432: PPUSH
76433: CALL_OW 1
76437: ST_TO_ADDR
// end ; break ;
76438: GO 76442
// end ;
76440: GO 75088
76442: POP
76443: POP
// end ;
76444: LD_VAR 0 2
76448: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
76449: LD_INT 0
76451: PPUSH
76452: PPUSH
76453: PPUSH
// if not mc_bases or not skirmish then
76454: LD_EXP 23
76458: NOT
76459: PUSH
76460: LD_EXP 21
76464: NOT
76465: OR
76466: IFFALSE 76470
// exit ;
76468: GO 76685
// for i = 1 to mc_bases do
76470: LD_ADDR_VAR 0 3
76474: PUSH
76475: DOUBLE
76476: LD_INT 1
76478: DEC
76479: ST_TO_ADDR
76480: LD_EXP 23
76484: PUSH
76485: FOR_TO
76486: IFFALSE 76683
// begin if building in mc_construct_list [ i ] then
76488: LD_VAR 0 1
76492: PUSH
76493: LD_EXP 30
76497: PUSH
76498: LD_VAR 0 3
76502: ARRAY
76503: IN
76504: IFFALSE 76681
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76506: LD_ADDR_EXP 30
76510: PUSH
76511: LD_EXP 30
76515: PPUSH
76516: LD_VAR 0 3
76520: PPUSH
76521: LD_EXP 30
76525: PUSH
76526: LD_VAR 0 3
76530: ARRAY
76531: PUSH
76532: LD_VAR 0 1
76536: DIFF
76537: PPUSH
76538: CALL_OW 1
76542: ST_TO_ADDR
// if building in mc_lab [ i ] then
76543: LD_VAR 0 1
76547: PUSH
76548: LD_EXP 56
76552: PUSH
76553: LD_VAR 0 3
76557: ARRAY
76558: IN
76559: IFFALSE 76614
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
76561: LD_ADDR_EXP 57
76565: PUSH
76566: LD_EXP 57
76570: PPUSH
76571: LD_VAR 0 3
76575: PPUSH
76576: LD_EXP 57
76580: PUSH
76581: LD_VAR 0 3
76585: ARRAY
76586: PPUSH
76587: LD_INT 1
76589: PPUSH
76590: LD_EXP 57
76594: PUSH
76595: LD_VAR 0 3
76599: ARRAY
76600: PPUSH
76601: LD_INT 0
76603: PPUSH
76604: CALL 13478 0 4
76608: PPUSH
76609: CALL_OW 1
76613: ST_TO_ADDR
// if not building in mc_bases [ i ] then
76614: LD_VAR 0 1
76618: PUSH
76619: LD_EXP 23
76623: PUSH
76624: LD_VAR 0 3
76628: ARRAY
76629: IN
76630: NOT
76631: IFFALSE 76677
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76633: LD_ADDR_EXP 23
76637: PUSH
76638: LD_EXP 23
76642: PPUSH
76643: LD_VAR 0 3
76647: PUSH
76648: LD_EXP 23
76652: PUSH
76653: LD_VAR 0 3
76657: ARRAY
76658: PUSH
76659: LD_INT 1
76661: PLUS
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PPUSH
76667: LD_VAR 0 1
76671: PPUSH
76672: CALL 14060 0 3
76676: ST_TO_ADDR
// exit ;
76677: POP
76678: POP
76679: GO 76685
// end ; end ;
76681: GO 76485
76683: POP
76684: POP
// end ;
76685: LD_VAR 0 2
76689: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
76690: LD_INT 0
76692: PPUSH
76693: PPUSH
76694: PPUSH
76695: PPUSH
76696: PPUSH
76697: PPUSH
76698: PPUSH
// if not mc_bases or not skirmish then
76699: LD_EXP 23
76703: NOT
76704: PUSH
76705: LD_EXP 21
76709: NOT
76710: OR
76711: IFFALSE 76715
// exit ;
76713: GO 77376
// for i = 1 to mc_bases do
76715: LD_ADDR_VAR 0 3
76719: PUSH
76720: DOUBLE
76721: LD_INT 1
76723: DEC
76724: ST_TO_ADDR
76725: LD_EXP 23
76729: PUSH
76730: FOR_TO
76731: IFFALSE 77374
// begin if building in mc_construct_list [ i ] then
76733: LD_VAR 0 1
76737: PUSH
76738: LD_EXP 30
76742: PUSH
76743: LD_VAR 0 3
76747: ARRAY
76748: IN
76749: IFFALSE 77372
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
76751: LD_ADDR_EXP 30
76755: PUSH
76756: LD_EXP 30
76760: PPUSH
76761: LD_VAR 0 3
76765: PPUSH
76766: LD_EXP 30
76770: PUSH
76771: LD_VAR 0 3
76775: ARRAY
76776: PUSH
76777: LD_VAR 0 1
76781: DIFF
76782: PPUSH
76783: CALL_OW 1
76787: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
76788: LD_ADDR_EXP 23
76792: PUSH
76793: LD_EXP 23
76797: PPUSH
76798: LD_VAR 0 3
76802: PUSH
76803: LD_EXP 23
76807: PUSH
76808: LD_VAR 0 3
76812: ARRAY
76813: PUSH
76814: LD_INT 1
76816: PLUS
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PPUSH
76822: LD_VAR 0 1
76826: PPUSH
76827: CALL 14060 0 3
76831: ST_TO_ADDR
// btype := GetBType ( building ) ;
76832: LD_ADDR_VAR 0 5
76836: PUSH
76837: LD_VAR 0 1
76841: PPUSH
76842: CALL_OW 266
76846: ST_TO_ADDR
// side := GetSide ( building ) ;
76847: LD_ADDR_VAR 0 8
76851: PUSH
76852: LD_VAR 0 1
76856: PPUSH
76857: CALL_OW 255
76861: ST_TO_ADDR
// if btype = b_lab then
76862: LD_VAR 0 5
76866: PUSH
76867: LD_INT 6
76869: EQUAL
76870: IFFALSE 76920
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
76872: LD_ADDR_EXP 56
76876: PUSH
76877: LD_EXP 56
76881: PPUSH
76882: LD_VAR 0 3
76886: PUSH
76887: LD_EXP 56
76891: PUSH
76892: LD_VAR 0 3
76896: ARRAY
76897: PUSH
76898: LD_INT 1
76900: PLUS
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PPUSH
76906: LD_VAR 0 1
76910: PPUSH
76911: CALL 14060 0 3
76915: ST_TO_ADDR
// exit ;
76916: POP
76917: POP
76918: GO 77376
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
76920: LD_VAR 0 5
76924: PUSH
76925: LD_INT 0
76927: PUSH
76928: LD_INT 2
76930: PUSH
76931: LD_INT 4
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: LIST
76938: IN
76939: IFFALSE 77063
// begin if btype = b_armoury then
76941: LD_VAR 0 5
76945: PUSH
76946: LD_INT 4
76948: EQUAL
76949: IFFALSE 76959
// btype := b_barracks ;
76951: LD_ADDR_VAR 0 5
76955: PUSH
76956: LD_INT 5
76958: ST_TO_ADDR
// if btype = b_depot then
76959: LD_VAR 0 5
76963: PUSH
76964: LD_INT 0
76966: EQUAL
76967: IFFALSE 76977
// btype := b_warehouse ;
76969: LD_ADDR_VAR 0 5
76973: PUSH
76974: LD_INT 1
76976: ST_TO_ADDR
// if btype = b_workshop then
76977: LD_VAR 0 5
76981: PUSH
76982: LD_INT 2
76984: EQUAL
76985: IFFALSE 76995
// btype := b_factory ;
76987: LD_ADDR_VAR 0 5
76991: PUSH
76992: LD_INT 3
76994: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
76995: LD_VAR 0 5
76999: PPUSH
77000: LD_VAR 0 8
77004: PPUSH
77005: CALL_OW 323
77009: PUSH
77010: LD_INT 1
77012: EQUAL
77013: IFFALSE 77059
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
77015: LD_ADDR_EXP 55
77019: PUSH
77020: LD_EXP 55
77024: PPUSH
77025: LD_VAR 0 3
77029: PUSH
77030: LD_EXP 55
77034: PUSH
77035: LD_VAR 0 3
77039: ARRAY
77040: PUSH
77041: LD_INT 1
77043: PLUS
77044: PUSH
77045: EMPTY
77046: LIST
77047: LIST
77048: PPUSH
77049: LD_VAR 0 1
77053: PPUSH
77054: CALL 14060 0 3
77058: ST_TO_ADDR
// exit ;
77059: POP
77060: POP
77061: GO 77376
// end ; if btype in [ b_bunker , b_turret ] then
77063: LD_VAR 0 5
77067: PUSH
77068: LD_INT 32
77070: PUSH
77071: LD_INT 33
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: IN
77078: IFFALSE 77368
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
77080: LD_ADDR_EXP 31
77084: PUSH
77085: LD_EXP 31
77089: PPUSH
77090: LD_VAR 0 3
77094: PUSH
77095: LD_EXP 31
77099: PUSH
77100: LD_VAR 0 3
77104: ARRAY
77105: PUSH
77106: LD_INT 1
77108: PLUS
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: PPUSH
77114: LD_VAR 0 1
77118: PPUSH
77119: CALL 14060 0 3
77123: ST_TO_ADDR
// if btype = b_bunker then
77124: LD_VAR 0 5
77128: PUSH
77129: LD_INT 32
77131: EQUAL
77132: IFFALSE 77368
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
77134: LD_ADDR_EXP 32
77138: PUSH
77139: LD_EXP 32
77143: PPUSH
77144: LD_VAR 0 3
77148: PUSH
77149: LD_EXP 32
77153: PUSH
77154: LD_VAR 0 3
77158: ARRAY
77159: PUSH
77160: LD_INT 1
77162: PLUS
77163: PUSH
77164: EMPTY
77165: LIST
77166: LIST
77167: PPUSH
77168: LD_VAR 0 1
77172: PPUSH
77173: CALL 14060 0 3
77177: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
77178: LD_ADDR_VAR 0 6
77182: PUSH
77183: LD_EXP 23
77187: PUSH
77188: LD_VAR 0 3
77192: ARRAY
77193: PPUSH
77194: LD_INT 25
77196: PUSH
77197: LD_INT 1
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 3
77206: PUSH
77207: LD_INT 54
77209: PUSH
77210: EMPTY
77211: LIST
77212: PUSH
77213: EMPTY
77214: LIST
77215: LIST
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: PPUSH
77221: CALL_OW 72
77225: ST_TO_ADDR
// if tmp then
77226: LD_VAR 0 6
77230: IFFALSE 77236
// exit ;
77232: POP
77233: POP
77234: GO 77376
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77236: LD_ADDR_VAR 0 6
77240: PUSH
77241: LD_EXP 23
77245: PUSH
77246: LD_VAR 0 3
77250: ARRAY
77251: PPUSH
77252: LD_INT 2
77254: PUSH
77255: LD_INT 30
77257: PUSH
77258: LD_INT 4
77260: PUSH
77261: EMPTY
77262: LIST
77263: LIST
77264: PUSH
77265: LD_INT 30
77267: PUSH
77268: LD_INT 5
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: LIST
77279: PPUSH
77280: CALL_OW 72
77284: ST_TO_ADDR
// if not tmp then
77285: LD_VAR 0 6
77289: NOT
77290: IFFALSE 77296
// exit ;
77292: POP
77293: POP
77294: GO 77376
// for j in tmp do
77296: LD_ADDR_VAR 0 4
77300: PUSH
77301: LD_VAR 0 6
77305: PUSH
77306: FOR_IN
77307: IFFALSE 77366
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
77309: LD_ADDR_VAR 0 7
77313: PUSH
77314: LD_VAR 0 4
77318: PPUSH
77319: CALL_OW 313
77323: PPUSH
77324: LD_INT 25
77326: PUSH
77327: LD_INT 1
77329: PUSH
77330: EMPTY
77331: LIST
77332: LIST
77333: PPUSH
77334: CALL_OW 72
77338: ST_TO_ADDR
// if units then
77339: LD_VAR 0 7
77343: IFFALSE 77364
// begin ComExitBuilding ( units [ 1 ] ) ;
77345: LD_VAR 0 7
77349: PUSH
77350: LD_INT 1
77352: ARRAY
77353: PPUSH
77354: CALL_OW 122
// exit ;
77358: POP
77359: POP
77360: POP
77361: POP
77362: GO 77376
// end ; end ;
77364: GO 77306
77366: POP
77367: POP
// end ; end ; exit ;
77368: POP
77369: POP
77370: GO 77376
// end ; end ;
77372: GO 76730
77374: POP
77375: POP
// end ;
77376: LD_VAR 0 2
77380: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
77381: LD_INT 0
77383: PPUSH
77384: PPUSH
77385: PPUSH
77386: PPUSH
77387: PPUSH
77388: PPUSH
77389: PPUSH
// if not mc_bases or not skirmish then
77390: LD_EXP 23
77394: NOT
77395: PUSH
77396: LD_EXP 21
77400: NOT
77401: OR
77402: IFFALSE 77406
// exit ;
77404: GO 77671
// btype := GetBType ( building ) ;
77406: LD_ADDR_VAR 0 6
77410: PUSH
77411: LD_VAR 0 1
77415: PPUSH
77416: CALL_OW 266
77420: ST_TO_ADDR
// x := GetX ( building ) ;
77421: LD_ADDR_VAR 0 7
77425: PUSH
77426: LD_VAR 0 1
77430: PPUSH
77431: CALL_OW 250
77435: ST_TO_ADDR
// y := GetY ( building ) ;
77436: LD_ADDR_VAR 0 8
77440: PUSH
77441: LD_VAR 0 1
77445: PPUSH
77446: CALL_OW 251
77450: ST_TO_ADDR
// d := GetDir ( building ) ;
77451: LD_ADDR_VAR 0 9
77455: PUSH
77456: LD_VAR 0 1
77460: PPUSH
77461: CALL_OW 254
77465: ST_TO_ADDR
// for i = 1 to mc_bases do
77466: LD_ADDR_VAR 0 4
77470: PUSH
77471: DOUBLE
77472: LD_INT 1
77474: DEC
77475: ST_TO_ADDR
77476: LD_EXP 23
77480: PUSH
77481: FOR_TO
77482: IFFALSE 77669
// begin if not mc_build_list [ i ] then
77484: LD_EXP 28
77488: PUSH
77489: LD_VAR 0 4
77493: ARRAY
77494: NOT
77495: IFFALSE 77499
// continue ;
77497: GO 77481
// for j := 1 to mc_build_list [ i ] do
77499: LD_ADDR_VAR 0 5
77503: PUSH
77504: DOUBLE
77505: LD_INT 1
77507: DEC
77508: ST_TO_ADDR
77509: LD_EXP 28
77513: PUSH
77514: LD_VAR 0 4
77518: ARRAY
77519: PUSH
77520: FOR_TO
77521: IFFALSE 77665
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
77523: LD_VAR 0 6
77527: PUSH
77528: LD_VAR 0 7
77532: PUSH
77533: LD_VAR 0 8
77537: PUSH
77538: LD_VAR 0 9
77542: PUSH
77543: EMPTY
77544: LIST
77545: LIST
77546: LIST
77547: LIST
77548: PPUSH
77549: LD_EXP 28
77553: PUSH
77554: LD_VAR 0 4
77558: ARRAY
77559: PUSH
77560: LD_VAR 0 5
77564: ARRAY
77565: PPUSH
77566: CALL 20243 0 2
77570: IFFALSE 77663
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
77572: LD_ADDR_EXP 28
77576: PUSH
77577: LD_EXP 28
77581: PPUSH
77582: LD_VAR 0 4
77586: PPUSH
77587: LD_EXP 28
77591: PUSH
77592: LD_VAR 0 4
77596: ARRAY
77597: PPUSH
77598: LD_VAR 0 5
77602: PPUSH
77603: CALL_OW 3
77607: PPUSH
77608: CALL_OW 1
77612: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
77613: LD_ADDR_EXP 30
77617: PUSH
77618: LD_EXP 30
77622: PPUSH
77623: LD_VAR 0 4
77627: PUSH
77628: LD_EXP 30
77632: PUSH
77633: LD_VAR 0 4
77637: ARRAY
77638: PUSH
77639: LD_INT 1
77641: PLUS
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PPUSH
77647: LD_VAR 0 1
77651: PPUSH
77652: CALL 14060 0 3
77656: ST_TO_ADDR
// exit ;
77657: POP
77658: POP
77659: POP
77660: POP
77661: GO 77671
// end ;
77663: GO 77520
77665: POP
77666: POP
// end ;
77667: GO 77481
77669: POP
77670: POP
// end ;
77671: LD_VAR 0 3
77675: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
77676: LD_INT 0
77678: PPUSH
77679: PPUSH
77680: PPUSH
// if not mc_bases or not skirmish then
77681: LD_EXP 23
77685: NOT
77686: PUSH
77687: LD_EXP 21
77691: NOT
77692: OR
77693: IFFALSE 77697
// exit ;
77695: GO 77887
// for i = 1 to mc_bases do
77697: LD_ADDR_VAR 0 4
77701: PUSH
77702: DOUBLE
77703: LD_INT 1
77705: DEC
77706: ST_TO_ADDR
77707: LD_EXP 23
77711: PUSH
77712: FOR_TO
77713: IFFALSE 77800
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
77715: LD_VAR 0 1
77719: PUSH
77720: LD_EXP 31
77724: PUSH
77725: LD_VAR 0 4
77729: ARRAY
77730: IN
77731: PUSH
77732: LD_VAR 0 1
77736: PUSH
77737: LD_EXP 32
77741: PUSH
77742: LD_VAR 0 4
77746: ARRAY
77747: IN
77748: NOT
77749: AND
77750: IFFALSE 77798
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
77752: LD_ADDR_EXP 32
77756: PUSH
77757: LD_EXP 32
77761: PPUSH
77762: LD_VAR 0 4
77766: PUSH
77767: LD_EXP 32
77771: PUSH
77772: LD_VAR 0 4
77776: ARRAY
77777: PUSH
77778: LD_INT 1
77780: PLUS
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PPUSH
77786: LD_VAR 0 1
77790: PPUSH
77791: CALL 14060 0 3
77795: ST_TO_ADDR
// break ;
77796: GO 77800
// end ; end ;
77798: GO 77712
77800: POP
77801: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
77802: LD_VAR 0 1
77806: PPUSH
77807: CALL_OW 257
77811: PUSH
77812: LD_EXP 49
77816: IN
77817: PUSH
77818: LD_VAR 0 1
77822: PPUSH
77823: CALL_OW 266
77827: PUSH
77828: LD_INT 5
77830: EQUAL
77831: AND
77832: PUSH
77833: LD_VAR 0 2
77837: PPUSH
77838: CALL_OW 110
77842: PUSH
77843: LD_INT 18
77845: NONEQUAL
77846: AND
77847: IFFALSE 77887
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
77849: LD_VAR 0 2
77853: PPUSH
77854: CALL_OW 257
77858: PUSH
77859: LD_INT 5
77861: PUSH
77862: LD_INT 8
77864: PUSH
77865: LD_INT 9
77867: PUSH
77868: EMPTY
77869: LIST
77870: LIST
77871: LIST
77872: IN
77873: IFFALSE 77887
// SetClass ( unit , 1 ) ;
77875: LD_VAR 0 2
77879: PPUSH
77880: LD_INT 1
77882: PPUSH
77883: CALL_OW 336
// end ;
77887: LD_VAR 0 3
77891: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
77892: LD_INT 0
77894: PPUSH
77895: PPUSH
// if not mc_bases or not skirmish then
77896: LD_EXP 23
77900: NOT
77901: PUSH
77902: LD_EXP 21
77906: NOT
77907: OR
77908: IFFALSE 77912
// exit ;
77910: GO 78028
// if GetLives ( abandoned_vehicle ) > 250 then
77912: LD_VAR 0 2
77916: PPUSH
77917: CALL_OW 256
77921: PUSH
77922: LD_INT 250
77924: GREATER
77925: IFFALSE 77929
// exit ;
77927: GO 78028
// for i = 1 to mc_bases do
77929: LD_ADDR_VAR 0 6
77933: PUSH
77934: DOUBLE
77935: LD_INT 1
77937: DEC
77938: ST_TO_ADDR
77939: LD_EXP 23
77943: PUSH
77944: FOR_TO
77945: IFFALSE 78026
// begin if driver in mc_bases [ i ] then
77947: LD_VAR 0 1
77951: PUSH
77952: LD_EXP 23
77956: PUSH
77957: LD_VAR 0 6
77961: ARRAY
77962: IN
77963: IFFALSE 78024
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
77965: LD_VAR 0 1
77969: PPUSH
77970: LD_EXP 23
77974: PUSH
77975: LD_VAR 0 6
77979: ARRAY
77980: PPUSH
77981: LD_INT 2
77983: PUSH
77984: LD_INT 30
77986: PUSH
77987: LD_INT 0
77989: PUSH
77990: EMPTY
77991: LIST
77992: LIST
77993: PUSH
77994: LD_INT 30
77996: PUSH
77997: LD_INT 1
77999: PUSH
78000: EMPTY
78001: LIST
78002: LIST
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: LIST
78008: PPUSH
78009: CALL_OW 72
78013: PUSH
78014: LD_INT 1
78016: ARRAY
78017: PPUSH
78018: CALL 46679 0 2
// break ;
78022: GO 78026
// end ; end ;
78024: GO 77944
78026: POP
78027: POP
// end ; end_of_file
78028: LD_VAR 0 5
78032: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
78033: LD_INT 0
78035: PPUSH
// ar_miner := 81 ;
78036: LD_ADDR_EXP 74
78040: PUSH
78041: LD_INT 81
78043: ST_TO_ADDR
// ar_crane := 88 ;
78044: LD_ADDR_EXP 73
78048: PUSH
78049: LD_INT 88
78051: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
78052: LD_ADDR_EXP 68
78056: PUSH
78057: LD_INT 89
78059: ST_TO_ADDR
// us_hack := 99 ;
78060: LD_ADDR_EXP 69
78064: PUSH
78065: LD_INT 99
78067: ST_TO_ADDR
// us_artillery := 97 ;
78068: LD_ADDR_EXP 70
78072: PUSH
78073: LD_INT 97
78075: ST_TO_ADDR
// ar_bio_bomb := 91 ;
78076: LD_ADDR_EXP 71
78080: PUSH
78081: LD_INT 91
78083: ST_TO_ADDR
// ar_mortar := 92 ;
78084: LD_ADDR_EXP 72
78088: PUSH
78089: LD_INT 92
78091: ST_TO_ADDR
// ru_radar := 98 ;
78092: LD_ADDR_EXP 67
78096: PUSH
78097: LD_INT 98
78099: ST_TO_ADDR
// tech_Artillery := 80 ;
78100: LD_ADDR_EXP 75
78104: PUSH
78105: LD_INT 80
78107: ST_TO_ADDR
// tech_RadMat := 81 ;
78108: LD_ADDR_EXP 76
78112: PUSH
78113: LD_INT 81
78115: ST_TO_ADDR
// tech_BasicTools := 82 ;
78116: LD_ADDR_EXP 77
78120: PUSH
78121: LD_INT 82
78123: ST_TO_ADDR
// tech_Cargo := 83 ;
78124: LD_ADDR_EXP 78
78128: PUSH
78129: LD_INT 83
78131: ST_TO_ADDR
// tech_Track := 84 ;
78132: LD_ADDR_EXP 79
78136: PUSH
78137: LD_INT 84
78139: ST_TO_ADDR
// tech_Crane := 85 ;
78140: LD_ADDR_EXP 80
78144: PUSH
78145: LD_INT 85
78147: ST_TO_ADDR
// tech_Bulldozer := 86 ;
78148: LD_ADDR_EXP 81
78152: PUSH
78153: LD_INT 86
78155: ST_TO_ADDR
// tech_Hovercraft := 87 ;
78156: LD_ADDR_EXP 82
78160: PUSH
78161: LD_INT 87
78163: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
78164: LD_ADDR_EXP 83
78168: PUSH
78169: LD_INT 88
78171: ST_TO_ADDR
// class_mastodont := 31 ;
78172: LD_ADDR_EXP 84
78176: PUSH
78177: LD_INT 31
78179: ST_TO_ADDR
// class_horse := 21 ;
78180: LD_ADDR_EXP 85
78184: PUSH
78185: LD_INT 21
78187: ST_TO_ADDR
// end ;
78188: LD_VAR 0 1
78192: RET
// every 1 do
78193: GO 78195
78195: DISABLE
// InitGlobalVariables ; end_of_file
78196: CALL 78033 0 0
78200: END
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
78201: LD_INT 0
78203: PPUSH
78204: PPUSH
78205: PPUSH
78206: PPUSH
78207: PPUSH
78208: PPUSH
78209: PPUSH
78210: PPUSH
78211: PPUSH
78212: PPUSH
78213: PPUSH
78214: PPUSH
78215: PPUSH
78216: PPUSH
78217: PPUSH
78218: PPUSH
78219: PPUSH
78220: PPUSH
78221: PPUSH
78222: PPUSH
78223: PPUSH
78224: PPUSH
78225: PPUSH
78226: PPUSH
78227: PPUSH
78228: PPUSH
78229: PPUSH
78230: PPUSH
78231: PPUSH
78232: PPUSH
78233: PPUSH
78234: PPUSH
78235: PPUSH
78236: PPUSH
// if not list then
78237: LD_VAR 0 1
78241: NOT
78242: IFFALSE 78246
// exit ;
78244: GO 82905
// base := list [ 1 ] ;
78246: LD_ADDR_VAR 0 3
78250: PUSH
78251: LD_VAR 0 1
78255: PUSH
78256: LD_INT 1
78258: ARRAY
78259: ST_TO_ADDR
// group := list [ 2 ] ;
78260: LD_ADDR_VAR 0 4
78264: PUSH
78265: LD_VAR 0 1
78269: PUSH
78270: LD_INT 2
78272: ARRAY
78273: ST_TO_ADDR
// path := list [ 3 ] ;
78274: LD_ADDR_VAR 0 5
78278: PUSH
78279: LD_VAR 0 1
78283: PUSH
78284: LD_INT 3
78286: ARRAY
78287: ST_TO_ADDR
// flags := list [ 4 ] ;
78288: LD_ADDR_VAR 0 6
78292: PUSH
78293: LD_VAR 0 1
78297: PUSH
78298: LD_INT 4
78300: ARRAY
78301: ST_TO_ADDR
// mined := [ ] ;
78302: LD_ADDR_VAR 0 27
78306: PUSH
78307: EMPTY
78308: ST_TO_ADDR
// bombed := [ ] ;
78309: LD_ADDR_VAR 0 28
78313: PUSH
78314: EMPTY
78315: ST_TO_ADDR
// healers := [ ] ;
78316: LD_ADDR_VAR 0 31
78320: PUSH
78321: EMPTY
78322: ST_TO_ADDR
// to_heal := [ ] ;
78323: LD_ADDR_VAR 0 30
78327: PUSH
78328: EMPTY
78329: ST_TO_ADDR
// repairs := [ ] ;
78330: LD_ADDR_VAR 0 33
78334: PUSH
78335: EMPTY
78336: ST_TO_ADDR
// to_repair := [ ] ;
78337: LD_ADDR_VAR 0 32
78341: PUSH
78342: EMPTY
78343: ST_TO_ADDR
// if not group or not path then
78344: LD_VAR 0 4
78348: NOT
78349: PUSH
78350: LD_VAR 0 5
78354: NOT
78355: OR
78356: IFFALSE 78360
// exit ;
78358: GO 82905
// side := GetSide ( group [ 1 ] ) ;
78360: LD_ADDR_VAR 0 35
78364: PUSH
78365: LD_VAR 0 4
78369: PUSH
78370: LD_INT 1
78372: ARRAY
78373: PPUSH
78374: CALL_OW 255
78378: ST_TO_ADDR
// if flags then
78379: LD_VAR 0 6
78383: IFFALSE 78527
// begin f_ignore_area := flags [ 1 ] ;
78385: LD_ADDR_VAR 0 17
78389: PUSH
78390: LD_VAR 0 6
78394: PUSH
78395: LD_INT 1
78397: ARRAY
78398: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
78399: LD_ADDR_VAR 0 18
78403: PUSH
78404: LD_VAR 0 6
78408: PUSH
78409: LD_INT 2
78411: ARRAY
78412: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
78413: LD_ADDR_VAR 0 19
78417: PUSH
78418: LD_VAR 0 6
78422: PUSH
78423: LD_INT 3
78425: ARRAY
78426: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
78427: LD_ADDR_VAR 0 20
78431: PUSH
78432: LD_VAR 0 6
78436: PUSH
78437: LD_INT 4
78439: ARRAY
78440: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
78441: LD_ADDR_VAR 0 21
78445: PUSH
78446: LD_VAR 0 6
78450: PUSH
78451: LD_INT 5
78453: ARRAY
78454: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
78455: LD_ADDR_VAR 0 22
78459: PUSH
78460: LD_VAR 0 6
78464: PUSH
78465: LD_INT 6
78467: ARRAY
78468: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
78469: LD_ADDR_VAR 0 23
78473: PUSH
78474: LD_VAR 0 6
78478: PUSH
78479: LD_INT 7
78481: ARRAY
78482: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
78483: LD_ADDR_VAR 0 24
78487: PUSH
78488: LD_VAR 0 6
78492: PUSH
78493: LD_INT 8
78495: ARRAY
78496: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
78497: LD_ADDR_VAR 0 25
78501: PUSH
78502: LD_VAR 0 6
78506: PUSH
78507: LD_INT 9
78509: ARRAY
78510: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
78511: LD_ADDR_VAR 0 26
78515: PUSH
78516: LD_VAR 0 6
78520: PUSH
78521: LD_INT 10
78523: ARRAY
78524: ST_TO_ADDR
// end else
78525: GO 78607
// begin f_ignore_area := false ;
78527: LD_ADDR_VAR 0 17
78531: PUSH
78532: LD_INT 0
78534: ST_TO_ADDR
// f_capture := false ;
78535: LD_ADDR_VAR 0 18
78539: PUSH
78540: LD_INT 0
78542: ST_TO_ADDR
// f_ignore_civ := false ;
78543: LD_ADDR_VAR 0 19
78547: PUSH
78548: LD_INT 0
78550: ST_TO_ADDR
// f_murder := false ;
78551: LD_ADDR_VAR 0 20
78555: PUSH
78556: LD_INT 0
78558: ST_TO_ADDR
// f_mines := false ;
78559: LD_ADDR_VAR 0 21
78563: PUSH
78564: LD_INT 0
78566: ST_TO_ADDR
// f_repair := false ;
78567: LD_ADDR_VAR 0 22
78571: PUSH
78572: LD_INT 0
78574: ST_TO_ADDR
// f_heal := false ;
78575: LD_ADDR_VAR 0 23
78579: PUSH
78580: LD_INT 0
78582: ST_TO_ADDR
// f_spacetime := false ;
78583: LD_ADDR_VAR 0 24
78587: PUSH
78588: LD_INT 0
78590: ST_TO_ADDR
// f_attack_depot := false ;
78591: LD_ADDR_VAR 0 25
78595: PUSH
78596: LD_INT 0
78598: ST_TO_ADDR
// f_crawl := false ;
78599: LD_ADDR_VAR 0 26
78603: PUSH
78604: LD_INT 0
78606: ST_TO_ADDR
// end ; if f_heal then
78607: LD_VAR 0 23
78611: IFFALSE 78638
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
78613: LD_ADDR_VAR 0 31
78617: PUSH
78618: LD_VAR 0 4
78622: PPUSH
78623: LD_INT 25
78625: PUSH
78626: LD_INT 4
78628: PUSH
78629: EMPTY
78630: LIST
78631: LIST
78632: PPUSH
78633: CALL_OW 72
78637: ST_TO_ADDR
// if f_repair then
78638: LD_VAR 0 22
78642: IFFALSE 78669
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
78644: LD_ADDR_VAR 0 33
78648: PUSH
78649: LD_VAR 0 4
78653: PPUSH
78654: LD_INT 25
78656: PUSH
78657: LD_INT 3
78659: PUSH
78660: EMPTY
78661: LIST
78662: LIST
78663: PPUSH
78664: CALL_OW 72
78668: ST_TO_ADDR
// units_path := [ ] ;
78669: LD_ADDR_VAR 0 16
78673: PUSH
78674: EMPTY
78675: ST_TO_ADDR
// for i = 1 to group do
78676: LD_ADDR_VAR 0 7
78680: PUSH
78681: DOUBLE
78682: LD_INT 1
78684: DEC
78685: ST_TO_ADDR
78686: LD_VAR 0 4
78690: PUSH
78691: FOR_TO
78692: IFFALSE 78721
// units_path := Replace ( units_path , i , path ) ;
78694: LD_ADDR_VAR 0 16
78698: PUSH
78699: LD_VAR 0 16
78703: PPUSH
78704: LD_VAR 0 7
78708: PPUSH
78709: LD_VAR 0 5
78713: PPUSH
78714: CALL_OW 1
78718: ST_TO_ADDR
78719: GO 78691
78721: POP
78722: POP
// repeat for i = group downto 1 do
78723: LD_ADDR_VAR 0 7
78727: PUSH
78728: DOUBLE
78729: LD_VAR 0 4
78733: INC
78734: ST_TO_ADDR
78735: LD_INT 1
78737: PUSH
78738: FOR_DOWNTO
78739: IFFALSE 82861
// begin wait ( 5 ) ;
78741: LD_INT 5
78743: PPUSH
78744: CALL_OW 67
// tmp := [ ] ;
78748: LD_ADDR_VAR 0 14
78752: PUSH
78753: EMPTY
78754: ST_TO_ADDR
// attacking := false ;
78755: LD_ADDR_VAR 0 29
78759: PUSH
78760: LD_INT 0
78762: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
78763: LD_VAR 0 4
78767: PUSH
78768: LD_VAR 0 7
78772: ARRAY
78773: PPUSH
78774: CALL_OW 301
78778: PUSH
78779: LD_VAR 0 4
78783: PUSH
78784: LD_VAR 0 7
78788: ARRAY
78789: NOT
78790: OR
78791: IFFALSE 78900
// begin if GetType ( group [ i ] ) = unit_human then
78793: LD_VAR 0 4
78797: PUSH
78798: LD_VAR 0 7
78802: ARRAY
78803: PPUSH
78804: CALL_OW 247
78808: PUSH
78809: LD_INT 1
78811: EQUAL
78812: IFFALSE 78858
// begin to_heal := to_heal diff group [ i ] ;
78814: LD_ADDR_VAR 0 30
78818: PUSH
78819: LD_VAR 0 30
78823: PUSH
78824: LD_VAR 0 4
78828: PUSH
78829: LD_VAR 0 7
78833: ARRAY
78834: DIFF
78835: ST_TO_ADDR
// healers := healers diff group [ i ] ;
78836: LD_ADDR_VAR 0 31
78840: PUSH
78841: LD_VAR 0 31
78845: PUSH
78846: LD_VAR 0 4
78850: PUSH
78851: LD_VAR 0 7
78855: ARRAY
78856: DIFF
78857: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
78858: LD_ADDR_VAR 0 4
78862: PUSH
78863: LD_VAR 0 4
78867: PPUSH
78868: LD_VAR 0 7
78872: PPUSH
78873: CALL_OW 3
78877: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
78878: LD_ADDR_VAR 0 16
78882: PUSH
78883: LD_VAR 0 16
78887: PPUSH
78888: LD_VAR 0 7
78892: PPUSH
78893: CALL_OW 3
78897: ST_TO_ADDR
// continue ;
78898: GO 78738
// end ; if f_repair then
78900: LD_VAR 0 22
78904: IFFALSE 79393
// begin if GetType ( group [ i ] ) = unit_vehicle then
78906: LD_VAR 0 4
78910: PUSH
78911: LD_VAR 0 7
78915: ARRAY
78916: PPUSH
78917: CALL_OW 247
78921: PUSH
78922: LD_INT 2
78924: EQUAL
78925: IFFALSE 79115
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
78927: LD_VAR 0 4
78931: PUSH
78932: LD_VAR 0 7
78936: ARRAY
78937: PPUSH
78938: CALL_OW 256
78942: PUSH
78943: LD_INT 700
78945: LESS
78946: PUSH
78947: LD_VAR 0 4
78951: PUSH
78952: LD_VAR 0 7
78956: ARRAY
78957: PUSH
78958: LD_VAR 0 32
78962: IN
78963: NOT
78964: AND
78965: IFFALSE 78989
// to_repair := to_repair union group [ i ] ;
78967: LD_ADDR_VAR 0 32
78971: PUSH
78972: LD_VAR 0 32
78976: PUSH
78977: LD_VAR 0 4
78981: PUSH
78982: LD_VAR 0 7
78986: ARRAY
78987: UNION
78988: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
78989: LD_VAR 0 4
78993: PUSH
78994: LD_VAR 0 7
78998: ARRAY
78999: PPUSH
79000: CALL_OW 256
79004: PUSH
79005: LD_INT 1000
79007: EQUAL
79008: PUSH
79009: LD_VAR 0 4
79013: PUSH
79014: LD_VAR 0 7
79018: ARRAY
79019: PUSH
79020: LD_VAR 0 32
79024: IN
79025: AND
79026: IFFALSE 79050
// to_repair := to_repair diff group [ i ] ;
79028: LD_ADDR_VAR 0 32
79032: PUSH
79033: LD_VAR 0 32
79037: PUSH
79038: LD_VAR 0 4
79042: PUSH
79043: LD_VAR 0 7
79047: ARRAY
79048: DIFF
79049: ST_TO_ADDR
// if group [ i ] in to_repair then
79050: LD_VAR 0 4
79054: PUSH
79055: LD_VAR 0 7
79059: ARRAY
79060: PUSH
79061: LD_VAR 0 32
79065: IN
79066: IFFALSE 79113
// begin if not IsInArea ( group [ i ] , f_repair ) then
79068: LD_VAR 0 4
79072: PUSH
79073: LD_VAR 0 7
79077: ARRAY
79078: PPUSH
79079: LD_VAR 0 22
79083: PPUSH
79084: CALL_OW 308
79088: NOT
79089: IFFALSE 79111
// ComMoveToArea ( group [ i ] , f_repair ) ;
79091: LD_VAR 0 4
79095: PUSH
79096: LD_VAR 0 7
79100: ARRAY
79101: PPUSH
79102: LD_VAR 0 22
79106: PPUSH
79107: CALL_OW 113
// continue ;
79111: GO 78738
// end ; end else
79113: GO 79393
// if group [ i ] in repairs then
79115: LD_VAR 0 4
79119: PUSH
79120: LD_VAR 0 7
79124: ARRAY
79125: PUSH
79126: LD_VAR 0 33
79130: IN
79131: IFFALSE 79393
// begin if IsInUnit ( group [ i ] ) then
79133: LD_VAR 0 4
79137: PUSH
79138: LD_VAR 0 7
79142: ARRAY
79143: PPUSH
79144: CALL_OW 310
79148: IFFALSE 79216
// begin z := IsInUnit ( group [ i ] ) ;
79150: LD_ADDR_VAR 0 13
79154: PUSH
79155: LD_VAR 0 4
79159: PUSH
79160: LD_VAR 0 7
79164: ARRAY
79165: PPUSH
79166: CALL_OW 310
79170: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
79171: LD_VAR 0 13
79175: PUSH
79176: LD_VAR 0 32
79180: IN
79181: PUSH
79182: LD_VAR 0 13
79186: PPUSH
79187: LD_VAR 0 22
79191: PPUSH
79192: CALL_OW 308
79196: AND
79197: IFFALSE 79214
// ComExitVehicle ( group [ i ] ) ;
79199: LD_VAR 0 4
79203: PUSH
79204: LD_VAR 0 7
79208: ARRAY
79209: PPUSH
79210: CALL_OW 121
// end else
79214: GO 79393
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
79216: LD_ADDR_VAR 0 13
79220: PUSH
79221: LD_VAR 0 4
79225: PPUSH
79226: LD_INT 95
79228: PUSH
79229: LD_VAR 0 22
79233: PUSH
79234: EMPTY
79235: LIST
79236: LIST
79237: PUSH
79238: LD_INT 58
79240: PUSH
79241: EMPTY
79242: LIST
79243: PUSH
79244: EMPTY
79245: LIST
79246: LIST
79247: PPUSH
79248: CALL_OW 72
79252: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
79253: LD_VAR 0 4
79257: PUSH
79258: LD_VAR 0 7
79262: ARRAY
79263: PPUSH
79264: CALL_OW 314
79268: NOT
79269: IFFALSE 79391
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
79271: LD_ADDR_VAR 0 10
79275: PUSH
79276: LD_VAR 0 13
79280: PPUSH
79281: LD_VAR 0 4
79285: PUSH
79286: LD_VAR 0 7
79290: ARRAY
79291: PPUSH
79292: CALL_OW 74
79296: ST_TO_ADDR
// if not x then
79297: LD_VAR 0 10
79301: NOT
79302: IFFALSE 79306
// continue ;
79304: GO 78738
// if GetLives ( x ) < 1000 then
79306: LD_VAR 0 10
79310: PPUSH
79311: CALL_OW 256
79315: PUSH
79316: LD_INT 1000
79318: LESS
79319: IFFALSE 79343
// ComRepairVehicle ( group [ i ] , x ) else
79321: LD_VAR 0 4
79325: PUSH
79326: LD_VAR 0 7
79330: ARRAY
79331: PPUSH
79332: LD_VAR 0 10
79336: PPUSH
79337: CALL_OW 129
79341: GO 79391
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
79343: LD_VAR 0 23
79347: PUSH
79348: LD_VAR 0 4
79352: PUSH
79353: LD_VAR 0 7
79357: ARRAY
79358: PPUSH
79359: CALL_OW 256
79363: PUSH
79364: LD_INT 1000
79366: LESS
79367: AND
79368: NOT
79369: IFFALSE 79391
// ComEnterUnit ( group [ i ] , x ) ;
79371: LD_VAR 0 4
79375: PUSH
79376: LD_VAR 0 7
79380: ARRAY
79381: PPUSH
79382: LD_VAR 0 10
79386: PPUSH
79387: CALL_OW 120
// end ; continue ;
79391: GO 78738
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
79393: LD_VAR 0 23
79397: PUSH
79398: LD_VAR 0 4
79402: PUSH
79403: LD_VAR 0 7
79407: ARRAY
79408: PPUSH
79409: CALL_OW 247
79413: PUSH
79414: LD_INT 1
79416: EQUAL
79417: AND
79418: IFFALSE 79896
// begin if group [ i ] in healers then
79420: LD_VAR 0 4
79424: PUSH
79425: LD_VAR 0 7
79429: ARRAY
79430: PUSH
79431: LD_VAR 0 31
79435: IN
79436: IFFALSE 79709
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
79438: LD_VAR 0 4
79442: PUSH
79443: LD_VAR 0 7
79447: ARRAY
79448: PPUSH
79449: LD_VAR 0 23
79453: PPUSH
79454: CALL_OW 308
79458: NOT
79459: PUSH
79460: LD_VAR 0 4
79464: PUSH
79465: LD_VAR 0 7
79469: ARRAY
79470: PPUSH
79471: CALL_OW 314
79475: NOT
79476: AND
79477: IFFALSE 79501
// ComMoveToArea ( group [ i ] , f_heal ) else
79479: LD_VAR 0 4
79483: PUSH
79484: LD_VAR 0 7
79488: ARRAY
79489: PPUSH
79490: LD_VAR 0 23
79494: PPUSH
79495: CALL_OW 113
79499: GO 79707
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
79501: LD_VAR 0 4
79505: PUSH
79506: LD_VAR 0 7
79510: ARRAY
79511: PPUSH
79512: CALL 43141 0 1
79516: PPUSH
79517: CALL_OW 256
79521: PUSH
79522: LD_INT 1000
79524: EQUAL
79525: IFFALSE 79544
// ComStop ( group [ i ] ) else
79527: LD_VAR 0 4
79531: PUSH
79532: LD_VAR 0 7
79536: ARRAY
79537: PPUSH
79538: CALL_OW 141
79542: GO 79707
// if not HasTask ( group [ i ] ) and to_heal then
79544: LD_VAR 0 4
79548: PUSH
79549: LD_VAR 0 7
79553: ARRAY
79554: PPUSH
79555: CALL_OW 314
79559: NOT
79560: PUSH
79561: LD_VAR 0 30
79565: AND
79566: IFFALSE 79707
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
79568: LD_ADDR_VAR 0 13
79572: PUSH
79573: LD_VAR 0 30
79577: PPUSH
79578: LD_INT 3
79580: PUSH
79581: LD_INT 54
79583: PUSH
79584: EMPTY
79585: LIST
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PPUSH
79591: CALL_OW 72
79595: PPUSH
79596: LD_VAR 0 4
79600: PUSH
79601: LD_VAR 0 7
79605: ARRAY
79606: PPUSH
79607: CALL_OW 74
79611: ST_TO_ADDR
// if z then
79612: LD_VAR 0 13
79616: IFFALSE 79707
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
79618: LD_INT 91
79620: PUSH
79621: LD_VAR 0 13
79625: PUSH
79626: LD_INT 10
79628: PUSH
79629: EMPTY
79630: LIST
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 81
79636: PUSH
79637: LD_VAR 0 13
79641: PPUSH
79642: CALL_OW 255
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: EMPTY
79652: LIST
79653: LIST
79654: PPUSH
79655: CALL_OW 69
79659: PUSH
79660: LD_INT 0
79662: EQUAL
79663: IFFALSE 79687
// ComHeal ( group [ i ] , z ) else
79665: LD_VAR 0 4
79669: PUSH
79670: LD_VAR 0 7
79674: ARRAY
79675: PPUSH
79676: LD_VAR 0 13
79680: PPUSH
79681: CALL_OW 128
79685: GO 79707
// ComMoveToArea ( group [ i ] , f_heal ) ;
79687: LD_VAR 0 4
79691: PUSH
79692: LD_VAR 0 7
79696: ARRAY
79697: PPUSH
79698: LD_VAR 0 23
79702: PPUSH
79703: CALL_OW 113
// end ; continue ;
79707: GO 78738
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
79709: LD_VAR 0 4
79713: PUSH
79714: LD_VAR 0 7
79718: ARRAY
79719: PPUSH
79720: CALL_OW 256
79724: PUSH
79725: LD_INT 700
79727: LESS
79728: PUSH
79729: LD_VAR 0 4
79733: PUSH
79734: LD_VAR 0 7
79738: ARRAY
79739: PUSH
79740: LD_VAR 0 30
79744: IN
79745: NOT
79746: AND
79747: IFFALSE 79771
// to_heal := to_heal union group [ i ] ;
79749: LD_ADDR_VAR 0 30
79753: PUSH
79754: LD_VAR 0 30
79758: PUSH
79759: LD_VAR 0 4
79763: PUSH
79764: LD_VAR 0 7
79768: ARRAY
79769: UNION
79770: ST_TO_ADDR
// if group [ i ] in to_heal then
79771: LD_VAR 0 4
79775: PUSH
79776: LD_VAR 0 7
79780: ARRAY
79781: PUSH
79782: LD_VAR 0 30
79786: IN
79787: IFFALSE 79896
// begin if GetLives ( group [ i ] ) = 1000 then
79789: LD_VAR 0 4
79793: PUSH
79794: LD_VAR 0 7
79798: ARRAY
79799: PPUSH
79800: CALL_OW 256
79804: PUSH
79805: LD_INT 1000
79807: EQUAL
79808: IFFALSE 79834
// to_heal := to_heal diff group [ i ] else
79810: LD_ADDR_VAR 0 30
79814: PUSH
79815: LD_VAR 0 30
79819: PUSH
79820: LD_VAR 0 4
79824: PUSH
79825: LD_VAR 0 7
79829: ARRAY
79830: DIFF
79831: ST_TO_ADDR
79832: GO 79896
// begin if not IsInArea ( group [ i ] , to_heal ) then
79834: LD_VAR 0 4
79838: PUSH
79839: LD_VAR 0 7
79843: ARRAY
79844: PPUSH
79845: LD_VAR 0 30
79849: PPUSH
79850: CALL_OW 308
79854: NOT
79855: IFFALSE 79879
// ComMoveToArea ( group [ i ] , f_heal ) else
79857: LD_VAR 0 4
79861: PUSH
79862: LD_VAR 0 7
79866: ARRAY
79867: PPUSH
79868: LD_VAR 0 23
79872: PPUSH
79873: CALL_OW 113
79877: GO 79894
// ComHold ( group [ i ] ) ;
79879: LD_VAR 0 4
79883: PUSH
79884: LD_VAR 0 7
79888: ARRAY
79889: PPUSH
79890: CALL_OW 140
// continue ;
79894: GO 78738
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
79896: LD_VAR 0 4
79900: PUSH
79901: LD_VAR 0 7
79905: ARRAY
79906: PPUSH
79907: LD_INT 10
79909: PPUSH
79910: CALL 41561 0 2
79914: NOT
79915: PUSH
79916: LD_VAR 0 16
79920: PUSH
79921: LD_VAR 0 7
79925: ARRAY
79926: PUSH
79927: EMPTY
79928: EQUAL
79929: NOT
79930: AND
79931: IFFALSE 80197
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
79933: LD_VAR 0 4
79937: PUSH
79938: LD_VAR 0 7
79942: ARRAY
79943: PPUSH
79944: CALL_OW 262
79948: PUSH
79949: LD_INT 1
79951: PUSH
79952: LD_INT 2
79954: PUSH
79955: EMPTY
79956: LIST
79957: LIST
79958: IN
79959: IFFALSE 80000
// if GetFuel ( group [ i ] ) < 10 then
79961: LD_VAR 0 4
79965: PUSH
79966: LD_VAR 0 7
79970: ARRAY
79971: PPUSH
79972: CALL_OW 261
79976: PUSH
79977: LD_INT 10
79979: LESS
79980: IFFALSE 80000
// SetFuel ( group [ i ] , 12 ) ;
79982: LD_VAR 0 4
79986: PUSH
79987: LD_VAR 0 7
79991: ARRAY
79992: PPUSH
79993: LD_INT 12
79995: PPUSH
79996: CALL_OW 240
// if units_path [ i ] then
80000: LD_VAR 0 16
80004: PUSH
80005: LD_VAR 0 7
80009: ARRAY
80010: IFFALSE 80195
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
80012: LD_VAR 0 4
80016: PUSH
80017: LD_VAR 0 7
80021: ARRAY
80022: PPUSH
80023: LD_VAR 0 16
80027: PUSH
80028: LD_VAR 0 7
80032: ARRAY
80033: PUSH
80034: LD_INT 1
80036: ARRAY
80037: PUSH
80038: LD_INT 1
80040: ARRAY
80041: PPUSH
80042: LD_VAR 0 16
80046: PUSH
80047: LD_VAR 0 7
80051: ARRAY
80052: PUSH
80053: LD_INT 1
80055: ARRAY
80056: PUSH
80057: LD_INT 2
80059: ARRAY
80060: PPUSH
80061: CALL_OW 297
80065: PUSH
80066: LD_INT 6
80068: GREATER
80069: IFFALSE 80144
// begin if not HasTask ( group [ i ] ) then
80071: LD_VAR 0 4
80075: PUSH
80076: LD_VAR 0 7
80080: ARRAY
80081: PPUSH
80082: CALL_OW 314
80086: NOT
80087: IFFALSE 80142
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
80089: LD_VAR 0 4
80093: PUSH
80094: LD_VAR 0 7
80098: ARRAY
80099: PPUSH
80100: LD_VAR 0 16
80104: PUSH
80105: LD_VAR 0 7
80109: ARRAY
80110: PUSH
80111: LD_INT 1
80113: ARRAY
80114: PUSH
80115: LD_INT 1
80117: ARRAY
80118: PPUSH
80119: LD_VAR 0 16
80123: PUSH
80124: LD_VAR 0 7
80128: ARRAY
80129: PUSH
80130: LD_INT 1
80132: ARRAY
80133: PUSH
80134: LD_INT 2
80136: ARRAY
80137: PPUSH
80138: CALL_OW 114
// end else
80142: GO 80195
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
80144: LD_ADDR_VAR 0 15
80148: PUSH
80149: LD_VAR 0 16
80153: PUSH
80154: LD_VAR 0 7
80158: ARRAY
80159: PPUSH
80160: LD_INT 1
80162: PPUSH
80163: CALL_OW 3
80167: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
80168: LD_ADDR_VAR 0 16
80172: PUSH
80173: LD_VAR 0 16
80177: PPUSH
80178: LD_VAR 0 7
80182: PPUSH
80183: LD_VAR 0 15
80187: PPUSH
80188: CALL_OW 1
80192: ST_TO_ADDR
// continue ;
80193: GO 78738
// end ; end ; end else
80195: GO 82859
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
80197: LD_ADDR_VAR 0 14
80201: PUSH
80202: LD_INT 81
80204: PUSH
80205: LD_VAR 0 4
80209: PUSH
80210: LD_VAR 0 7
80214: ARRAY
80215: PPUSH
80216: CALL_OW 255
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PPUSH
80225: CALL_OW 69
80229: ST_TO_ADDR
// if not tmp then
80230: LD_VAR 0 14
80234: NOT
80235: IFFALSE 80239
// continue ;
80237: GO 78738
// if f_ignore_area then
80239: LD_VAR 0 17
80243: IFFALSE 80331
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
80245: LD_ADDR_VAR 0 15
80249: PUSH
80250: LD_VAR 0 14
80254: PPUSH
80255: LD_INT 3
80257: PUSH
80258: LD_INT 92
80260: PUSH
80261: LD_VAR 0 17
80265: PUSH
80266: LD_INT 1
80268: ARRAY
80269: PUSH
80270: LD_VAR 0 17
80274: PUSH
80275: LD_INT 2
80277: ARRAY
80278: PUSH
80279: LD_VAR 0 17
80283: PUSH
80284: LD_INT 3
80286: ARRAY
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: PUSH
80294: EMPTY
80295: LIST
80296: LIST
80297: PPUSH
80298: CALL_OW 72
80302: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80303: LD_VAR 0 14
80307: PUSH
80308: LD_VAR 0 15
80312: DIFF
80313: IFFALSE 80331
// tmp := tmp diff tmp2 ;
80315: LD_ADDR_VAR 0 14
80319: PUSH
80320: LD_VAR 0 14
80324: PUSH
80325: LD_VAR 0 15
80329: DIFF
80330: ST_TO_ADDR
// end ; if not f_murder then
80331: LD_VAR 0 20
80335: NOT
80336: IFFALSE 80394
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
80338: LD_ADDR_VAR 0 15
80342: PUSH
80343: LD_VAR 0 14
80347: PPUSH
80348: LD_INT 3
80350: PUSH
80351: LD_INT 50
80353: PUSH
80354: EMPTY
80355: LIST
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PPUSH
80361: CALL_OW 72
80365: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
80366: LD_VAR 0 14
80370: PUSH
80371: LD_VAR 0 15
80375: DIFF
80376: IFFALSE 80394
// tmp := tmp diff tmp2 ;
80378: LD_ADDR_VAR 0 14
80382: PUSH
80383: LD_VAR 0 14
80387: PUSH
80388: LD_VAR 0 15
80392: DIFF
80393: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
80394: LD_ADDR_VAR 0 14
80398: PUSH
80399: LD_VAR 0 4
80403: PUSH
80404: LD_VAR 0 7
80408: ARRAY
80409: PPUSH
80410: LD_VAR 0 14
80414: PPUSH
80415: LD_INT 1
80417: PPUSH
80418: LD_INT 1
80420: PPUSH
80421: CALL 14495 0 4
80425: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
80426: LD_VAR 0 4
80430: PUSH
80431: LD_VAR 0 7
80435: ARRAY
80436: PPUSH
80437: CALL_OW 257
80441: PUSH
80442: LD_INT 1
80444: EQUAL
80445: IFFALSE 80893
// begin if WantPlant ( group [ i ] ) then
80447: LD_VAR 0 4
80451: PUSH
80452: LD_VAR 0 7
80456: ARRAY
80457: PPUSH
80458: CALL 13996 0 1
80462: IFFALSE 80466
// continue ;
80464: GO 78738
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
80466: LD_VAR 0 18
80470: PUSH
80471: LD_VAR 0 4
80475: PUSH
80476: LD_VAR 0 7
80480: ARRAY
80481: PPUSH
80482: CALL_OW 310
80486: NOT
80487: AND
80488: PUSH
80489: LD_VAR 0 14
80493: PUSH
80494: LD_INT 1
80496: ARRAY
80497: PUSH
80498: LD_VAR 0 14
80502: PPUSH
80503: LD_INT 21
80505: PUSH
80506: LD_INT 2
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 58
80515: PUSH
80516: EMPTY
80517: LIST
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PPUSH
80523: CALL_OW 72
80527: IN
80528: AND
80529: IFFALSE 80565
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
80531: LD_VAR 0 4
80535: PUSH
80536: LD_VAR 0 7
80540: ARRAY
80541: PPUSH
80542: LD_VAR 0 14
80546: PUSH
80547: LD_INT 1
80549: ARRAY
80550: PPUSH
80551: CALL_OW 120
// attacking := true ;
80555: LD_ADDR_VAR 0 29
80559: PUSH
80560: LD_INT 1
80562: ST_TO_ADDR
// continue ;
80563: GO 78738
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
80565: LD_VAR 0 26
80569: PUSH
80570: LD_VAR 0 4
80574: PUSH
80575: LD_VAR 0 7
80579: ARRAY
80580: PPUSH
80581: CALL_OW 257
80585: PUSH
80586: LD_INT 1
80588: EQUAL
80589: AND
80590: PUSH
80591: LD_VAR 0 4
80595: PUSH
80596: LD_VAR 0 7
80600: ARRAY
80601: PPUSH
80602: CALL_OW 256
80606: PUSH
80607: LD_INT 800
80609: LESS
80610: AND
80611: PUSH
80612: LD_VAR 0 4
80616: PUSH
80617: LD_VAR 0 7
80621: ARRAY
80622: PPUSH
80623: CALL_OW 318
80627: NOT
80628: AND
80629: IFFALSE 80646
// ComCrawl ( group [ i ] ) ;
80631: LD_VAR 0 4
80635: PUSH
80636: LD_VAR 0 7
80640: ARRAY
80641: PPUSH
80642: CALL_OW 137
// if f_mines then
80646: LD_VAR 0 21
80650: IFFALSE 80893
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
80652: LD_VAR 0 14
80656: PUSH
80657: LD_INT 1
80659: ARRAY
80660: PPUSH
80661: CALL_OW 247
80665: PUSH
80666: LD_INT 3
80668: EQUAL
80669: PUSH
80670: LD_VAR 0 14
80674: PUSH
80675: LD_INT 1
80677: ARRAY
80678: PUSH
80679: LD_VAR 0 27
80683: IN
80684: NOT
80685: AND
80686: IFFALSE 80893
// begin x := GetX ( tmp [ 1 ] ) ;
80688: LD_ADDR_VAR 0 10
80692: PUSH
80693: LD_VAR 0 14
80697: PUSH
80698: LD_INT 1
80700: ARRAY
80701: PPUSH
80702: CALL_OW 250
80706: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
80707: LD_ADDR_VAR 0 11
80711: PUSH
80712: LD_VAR 0 14
80716: PUSH
80717: LD_INT 1
80719: ARRAY
80720: PPUSH
80721: CALL_OW 251
80725: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
80726: LD_ADDR_VAR 0 12
80730: PUSH
80731: LD_VAR 0 4
80735: PUSH
80736: LD_VAR 0 7
80740: ARRAY
80741: PPUSH
80742: CALL 41646 0 1
80746: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
80747: LD_VAR 0 4
80751: PUSH
80752: LD_VAR 0 7
80756: ARRAY
80757: PPUSH
80758: LD_VAR 0 10
80762: PPUSH
80763: LD_VAR 0 11
80767: PPUSH
80768: LD_VAR 0 14
80772: PUSH
80773: LD_INT 1
80775: ARRAY
80776: PPUSH
80777: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
80781: LD_VAR 0 4
80785: PUSH
80786: LD_VAR 0 7
80790: ARRAY
80791: PPUSH
80792: LD_VAR 0 10
80796: PPUSH
80797: LD_VAR 0 12
80801: PPUSH
80802: LD_INT 7
80804: PPUSH
80805: CALL_OW 272
80809: PPUSH
80810: LD_VAR 0 11
80814: PPUSH
80815: LD_VAR 0 12
80819: PPUSH
80820: LD_INT 7
80822: PPUSH
80823: CALL_OW 273
80827: PPUSH
80828: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
80832: LD_VAR 0 4
80836: PUSH
80837: LD_VAR 0 7
80841: ARRAY
80842: PPUSH
80843: LD_INT 71
80845: PPUSH
80846: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
80850: LD_ADDR_VAR 0 27
80854: PUSH
80855: LD_VAR 0 27
80859: PPUSH
80860: LD_VAR 0 27
80864: PUSH
80865: LD_INT 1
80867: PLUS
80868: PPUSH
80869: LD_VAR 0 14
80873: PUSH
80874: LD_INT 1
80876: ARRAY
80877: PPUSH
80878: CALL_OW 1
80882: ST_TO_ADDR
// attacking := true ;
80883: LD_ADDR_VAR 0 29
80887: PUSH
80888: LD_INT 1
80890: ST_TO_ADDR
// continue ;
80891: GO 78738
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
80893: LD_VAR 0 4
80897: PUSH
80898: LD_VAR 0 7
80902: ARRAY
80903: PPUSH
80904: CALL_OW 257
80908: PUSH
80909: LD_INT 17
80911: EQUAL
80912: PUSH
80913: LD_VAR 0 4
80917: PUSH
80918: LD_VAR 0 7
80922: ARRAY
80923: PPUSH
80924: CALL_OW 110
80928: PUSH
80929: LD_INT 71
80931: EQUAL
80932: NOT
80933: AND
80934: IFFALSE 81080
// begin attacking := false ;
80936: LD_ADDR_VAR 0 29
80940: PUSH
80941: LD_INT 0
80943: ST_TO_ADDR
// k := 5 ;
80944: LD_ADDR_VAR 0 9
80948: PUSH
80949: LD_INT 5
80951: ST_TO_ADDR
// if tmp < k then
80952: LD_VAR 0 14
80956: PUSH
80957: LD_VAR 0 9
80961: LESS
80962: IFFALSE 80974
// k := tmp ;
80964: LD_ADDR_VAR 0 9
80968: PUSH
80969: LD_VAR 0 14
80973: ST_TO_ADDR
// for j = 1 to k do
80974: LD_ADDR_VAR 0 8
80978: PUSH
80979: DOUBLE
80980: LD_INT 1
80982: DEC
80983: ST_TO_ADDR
80984: LD_VAR 0 9
80988: PUSH
80989: FOR_TO
80990: IFFALSE 81078
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
80992: LD_VAR 0 14
80996: PUSH
80997: LD_VAR 0 8
81001: ARRAY
81002: PUSH
81003: LD_VAR 0 14
81007: PPUSH
81008: LD_INT 58
81010: PUSH
81011: EMPTY
81012: LIST
81013: PPUSH
81014: CALL_OW 72
81018: IN
81019: NOT
81020: IFFALSE 81076
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81022: LD_VAR 0 4
81026: PUSH
81027: LD_VAR 0 7
81031: ARRAY
81032: PPUSH
81033: LD_VAR 0 14
81037: PUSH
81038: LD_VAR 0 8
81042: ARRAY
81043: PPUSH
81044: CALL_OW 115
// attacking := true ;
81048: LD_ADDR_VAR 0 29
81052: PUSH
81053: LD_INT 1
81055: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
81056: LD_VAR 0 4
81060: PUSH
81061: LD_VAR 0 7
81065: ARRAY
81066: PPUSH
81067: LD_INT 71
81069: PPUSH
81070: CALL_OW 109
// continue ;
81074: GO 80989
// end ; end ;
81076: GO 80989
81078: POP
81079: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
81080: LD_VAR 0 4
81084: PUSH
81085: LD_VAR 0 7
81089: ARRAY
81090: PPUSH
81091: CALL_OW 257
81095: PUSH
81096: LD_INT 8
81098: EQUAL
81099: PUSH
81100: LD_VAR 0 4
81104: PUSH
81105: LD_VAR 0 7
81109: ARRAY
81110: PPUSH
81111: CALL_OW 264
81115: PUSH
81116: LD_INT 28
81118: PUSH
81119: LD_INT 45
81121: PUSH
81122: LD_INT 7
81124: PUSH
81125: LD_INT 47
81127: PUSH
81128: EMPTY
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: IN
81134: OR
81135: IFFALSE 81391
// begin attacking := false ;
81137: LD_ADDR_VAR 0 29
81141: PUSH
81142: LD_INT 0
81144: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
81145: LD_VAR 0 14
81149: PUSH
81150: LD_INT 1
81152: ARRAY
81153: PPUSH
81154: CALL_OW 266
81158: PUSH
81159: LD_INT 32
81161: PUSH
81162: LD_INT 31
81164: PUSH
81165: LD_INT 33
81167: PUSH
81168: LD_INT 4
81170: PUSH
81171: LD_INT 5
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: IN
81181: IFFALSE 81367
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
81183: LD_ADDR_VAR 0 9
81187: PUSH
81188: LD_VAR 0 14
81192: PUSH
81193: LD_INT 1
81195: ARRAY
81196: PPUSH
81197: CALL_OW 266
81201: PPUSH
81202: LD_VAR 0 14
81206: PUSH
81207: LD_INT 1
81209: ARRAY
81210: PPUSH
81211: CALL_OW 250
81215: PPUSH
81216: LD_VAR 0 14
81220: PUSH
81221: LD_INT 1
81223: ARRAY
81224: PPUSH
81225: CALL_OW 251
81229: PPUSH
81230: LD_VAR 0 14
81234: PUSH
81235: LD_INT 1
81237: ARRAY
81238: PPUSH
81239: CALL_OW 254
81243: PPUSH
81244: LD_VAR 0 14
81248: PUSH
81249: LD_INT 1
81251: ARRAY
81252: PPUSH
81253: CALL_OW 248
81257: PPUSH
81258: LD_INT 0
81260: PPUSH
81261: CALL 23016 0 6
81265: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
81266: LD_ADDR_VAR 0 8
81270: PUSH
81271: LD_VAR 0 4
81275: PUSH
81276: LD_VAR 0 7
81280: ARRAY
81281: PPUSH
81282: LD_VAR 0 9
81286: PPUSH
81287: CALL 41686 0 2
81291: ST_TO_ADDR
// if j then
81292: LD_VAR 0 8
81296: IFFALSE 81365
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
81298: LD_VAR 0 8
81302: PUSH
81303: LD_INT 1
81305: ARRAY
81306: PPUSH
81307: LD_VAR 0 8
81311: PUSH
81312: LD_INT 2
81314: ARRAY
81315: PPUSH
81316: CALL_OW 488
81320: IFFALSE 81365
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
81322: LD_VAR 0 4
81326: PUSH
81327: LD_VAR 0 7
81331: ARRAY
81332: PPUSH
81333: LD_VAR 0 8
81337: PUSH
81338: LD_INT 1
81340: ARRAY
81341: PPUSH
81342: LD_VAR 0 8
81346: PUSH
81347: LD_INT 2
81349: ARRAY
81350: PPUSH
81351: CALL_OW 116
// attacking := true ;
81355: LD_ADDR_VAR 0 29
81359: PUSH
81360: LD_INT 1
81362: ST_TO_ADDR
// continue ;
81363: GO 78738
// end ; end else
81365: GO 81391
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81367: LD_VAR 0 4
81371: PUSH
81372: LD_VAR 0 7
81376: ARRAY
81377: PPUSH
81378: LD_VAR 0 14
81382: PUSH
81383: LD_INT 1
81385: ARRAY
81386: PPUSH
81387: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
81391: LD_VAR 0 4
81395: PUSH
81396: LD_VAR 0 7
81400: ARRAY
81401: PPUSH
81402: CALL_OW 265
81406: PUSH
81407: LD_INT 11
81409: EQUAL
81410: IFFALSE 81688
// begin k := 10 ;
81412: LD_ADDR_VAR 0 9
81416: PUSH
81417: LD_INT 10
81419: ST_TO_ADDR
// x := 0 ;
81420: LD_ADDR_VAR 0 10
81424: PUSH
81425: LD_INT 0
81427: ST_TO_ADDR
// if tmp < k then
81428: LD_VAR 0 14
81432: PUSH
81433: LD_VAR 0 9
81437: LESS
81438: IFFALSE 81450
// k := tmp ;
81440: LD_ADDR_VAR 0 9
81444: PUSH
81445: LD_VAR 0 14
81449: ST_TO_ADDR
// for j = k downto 1 do
81450: LD_ADDR_VAR 0 8
81454: PUSH
81455: DOUBLE
81456: LD_VAR 0 9
81460: INC
81461: ST_TO_ADDR
81462: LD_INT 1
81464: PUSH
81465: FOR_DOWNTO
81466: IFFALSE 81541
// begin if GetType ( tmp [ j ] ) = unit_human then
81468: LD_VAR 0 14
81472: PUSH
81473: LD_VAR 0 8
81477: ARRAY
81478: PPUSH
81479: CALL_OW 247
81483: PUSH
81484: LD_INT 1
81486: EQUAL
81487: IFFALSE 81539
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
81489: LD_VAR 0 4
81493: PUSH
81494: LD_VAR 0 7
81498: ARRAY
81499: PPUSH
81500: LD_VAR 0 14
81504: PUSH
81505: LD_VAR 0 8
81509: ARRAY
81510: PPUSH
81511: CALL 41957 0 2
// x := tmp [ j ] ;
81515: LD_ADDR_VAR 0 10
81519: PUSH
81520: LD_VAR 0 14
81524: PUSH
81525: LD_VAR 0 8
81529: ARRAY
81530: ST_TO_ADDR
// attacking := true ;
81531: LD_ADDR_VAR 0 29
81535: PUSH
81536: LD_INT 1
81538: ST_TO_ADDR
// end ; end ;
81539: GO 81465
81541: POP
81542: POP
// if not x then
81543: LD_VAR 0 10
81547: NOT
81548: IFFALSE 81688
// begin attacking := true ;
81550: LD_ADDR_VAR 0 29
81554: PUSH
81555: LD_INT 1
81557: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
81558: LD_VAR 0 4
81562: PUSH
81563: LD_VAR 0 7
81567: ARRAY
81568: PPUSH
81569: CALL_OW 250
81573: PPUSH
81574: LD_VAR 0 4
81578: PUSH
81579: LD_VAR 0 7
81583: ARRAY
81584: PPUSH
81585: CALL_OW 251
81589: PPUSH
81590: CALL_OW 546
81594: PUSH
81595: LD_INT 2
81597: ARRAY
81598: PUSH
81599: LD_VAR 0 14
81603: PUSH
81604: LD_INT 1
81606: ARRAY
81607: PPUSH
81608: CALL_OW 250
81612: PPUSH
81613: LD_VAR 0 14
81617: PUSH
81618: LD_INT 1
81620: ARRAY
81621: PPUSH
81622: CALL_OW 251
81626: PPUSH
81627: CALL_OW 546
81631: PUSH
81632: LD_INT 2
81634: ARRAY
81635: EQUAL
81636: IFFALSE 81664
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
81638: LD_VAR 0 4
81642: PUSH
81643: LD_VAR 0 7
81647: ARRAY
81648: PPUSH
81649: LD_VAR 0 14
81653: PUSH
81654: LD_INT 1
81656: ARRAY
81657: PPUSH
81658: CALL 41957 0 2
81662: GO 81688
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
81664: LD_VAR 0 4
81668: PUSH
81669: LD_VAR 0 7
81673: ARRAY
81674: PPUSH
81675: LD_VAR 0 14
81679: PUSH
81680: LD_INT 1
81682: ARRAY
81683: PPUSH
81684: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
81688: LD_VAR 0 4
81692: PUSH
81693: LD_VAR 0 7
81697: ARRAY
81698: PPUSH
81699: CALL_OW 264
81703: PUSH
81704: LD_INT 29
81706: EQUAL
81707: IFFALSE 82073
// begin if WantsToAttack ( group [ i ] ) in bombed then
81709: LD_VAR 0 4
81713: PUSH
81714: LD_VAR 0 7
81718: ARRAY
81719: PPUSH
81720: CALL_OW 319
81724: PUSH
81725: LD_VAR 0 28
81729: IN
81730: IFFALSE 81734
// continue ;
81732: GO 78738
// k := 8 ;
81734: LD_ADDR_VAR 0 9
81738: PUSH
81739: LD_INT 8
81741: ST_TO_ADDR
// x := 0 ;
81742: LD_ADDR_VAR 0 10
81746: PUSH
81747: LD_INT 0
81749: ST_TO_ADDR
// if tmp < k then
81750: LD_VAR 0 14
81754: PUSH
81755: LD_VAR 0 9
81759: LESS
81760: IFFALSE 81772
// k := tmp ;
81762: LD_ADDR_VAR 0 9
81766: PUSH
81767: LD_VAR 0 14
81771: ST_TO_ADDR
// for j = 1 to k do
81772: LD_ADDR_VAR 0 8
81776: PUSH
81777: DOUBLE
81778: LD_INT 1
81780: DEC
81781: ST_TO_ADDR
81782: LD_VAR 0 9
81786: PUSH
81787: FOR_TO
81788: IFFALSE 81920
// begin if GetType ( tmp [ j ] ) = unit_building then
81790: LD_VAR 0 14
81794: PUSH
81795: LD_VAR 0 8
81799: ARRAY
81800: PPUSH
81801: CALL_OW 247
81805: PUSH
81806: LD_INT 3
81808: EQUAL
81809: IFFALSE 81918
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
81811: LD_VAR 0 14
81815: PUSH
81816: LD_VAR 0 8
81820: ARRAY
81821: PUSH
81822: LD_VAR 0 28
81826: IN
81827: NOT
81828: PUSH
81829: LD_VAR 0 14
81833: PUSH
81834: LD_VAR 0 8
81838: ARRAY
81839: PPUSH
81840: CALL_OW 313
81844: AND
81845: IFFALSE 81918
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
81847: LD_VAR 0 4
81851: PUSH
81852: LD_VAR 0 7
81856: ARRAY
81857: PPUSH
81858: LD_VAR 0 14
81862: PUSH
81863: LD_VAR 0 8
81867: ARRAY
81868: PPUSH
81869: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
81873: LD_ADDR_VAR 0 28
81877: PUSH
81878: LD_VAR 0 28
81882: PPUSH
81883: LD_VAR 0 28
81887: PUSH
81888: LD_INT 1
81890: PLUS
81891: PPUSH
81892: LD_VAR 0 14
81896: PUSH
81897: LD_VAR 0 8
81901: ARRAY
81902: PPUSH
81903: CALL_OW 1
81907: ST_TO_ADDR
// attacking := true ;
81908: LD_ADDR_VAR 0 29
81912: PUSH
81913: LD_INT 1
81915: ST_TO_ADDR
// break ;
81916: GO 81920
// end ; end ;
81918: GO 81787
81920: POP
81921: POP
// if not attacking and f_attack_depot then
81922: LD_VAR 0 29
81926: NOT
81927: PUSH
81928: LD_VAR 0 25
81932: AND
81933: IFFALSE 82028
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81935: LD_ADDR_VAR 0 13
81939: PUSH
81940: LD_VAR 0 14
81944: PPUSH
81945: LD_INT 2
81947: PUSH
81948: LD_INT 30
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: EMPTY
81955: LIST
81956: LIST
81957: PUSH
81958: LD_INT 30
81960: PUSH
81961: LD_INT 1
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: LIST
81972: PPUSH
81973: CALL_OW 72
81977: ST_TO_ADDR
// if z then
81978: LD_VAR 0 13
81982: IFFALSE 82028
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
81984: LD_VAR 0 4
81988: PUSH
81989: LD_VAR 0 7
81993: ARRAY
81994: PPUSH
81995: LD_VAR 0 13
81999: PPUSH
82000: LD_VAR 0 4
82004: PUSH
82005: LD_VAR 0 7
82009: ARRAY
82010: PPUSH
82011: CALL_OW 74
82015: PPUSH
82016: CALL_OW 115
// attacking := true ;
82020: LD_ADDR_VAR 0 29
82024: PUSH
82025: LD_INT 1
82027: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
82028: LD_VAR 0 4
82032: PUSH
82033: LD_VAR 0 7
82037: ARRAY
82038: PPUSH
82039: CALL_OW 256
82043: PUSH
82044: LD_INT 500
82046: LESS
82047: IFFALSE 82073
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82049: LD_VAR 0 4
82053: PUSH
82054: LD_VAR 0 7
82058: ARRAY
82059: PPUSH
82060: LD_VAR 0 14
82064: PUSH
82065: LD_INT 1
82067: ARRAY
82068: PPUSH
82069: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
82073: LD_VAR 0 4
82077: PUSH
82078: LD_VAR 0 7
82082: ARRAY
82083: PPUSH
82084: CALL_OW 264
82088: PUSH
82089: LD_INT 49
82091: EQUAL
82092: IFFALSE 82213
// begin if not HasTask ( group [ i ] ) then
82094: LD_VAR 0 4
82098: PUSH
82099: LD_VAR 0 7
82103: ARRAY
82104: PPUSH
82105: CALL_OW 314
82109: NOT
82110: IFFALSE 82213
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
82112: LD_ADDR_VAR 0 9
82116: PUSH
82117: LD_INT 81
82119: PUSH
82120: LD_VAR 0 4
82124: PUSH
82125: LD_VAR 0 7
82129: ARRAY
82130: PPUSH
82131: CALL_OW 255
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PPUSH
82140: CALL_OW 69
82144: PPUSH
82145: LD_VAR 0 4
82149: PUSH
82150: LD_VAR 0 7
82154: ARRAY
82155: PPUSH
82156: CALL_OW 74
82160: ST_TO_ADDR
// if k then
82161: LD_VAR 0 9
82165: IFFALSE 82213
// if GetDistUnits ( group [ i ] , k ) > 10 then
82167: LD_VAR 0 4
82171: PUSH
82172: LD_VAR 0 7
82176: ARRAY
82177: PPUSH
82178: LD_VAR 0 9
82182: PPUSH
82183: CALL_OW 296
82187: PUSH
82188: LD_INT 10
82190: GREATER
82191: IFFALSE 82213
// ComMoveUnit ( group [ i ] , k ) ;
82193: LD_VAR 0 4
82197: PUSH
82198: LD_VAR 0 7
82202: ARRAY
82203: PPUSH
82204: LD_VAR 0 9
82208: PPUSH
82209: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82213: LD_VAR 0 4
82217: PUSH
82218: LD_VAR 0 7
82222: ARRAY
82223: PPUSH
82224: CALL_OW 256
82228: PUSH
82229: LD_INT 250
82231: LESS
82232: PUSH
82233: LD_VAR 0 4
82237: PUSH
82238: LD_VAR 0 7
82242: ARRAY
82243: PUSH
82244: LD_INT 21
82246: PUSH
82247: LD_INT 2
82249: PUSH
82250: EMPTY
82251: LIST
82252: LIST
82253: PUSH
82254: LD_INT 23
82256: PUSH
82257: LD_INT 2
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PPUSH
82268: CALL_OW 69
82272: IN
82273: AND
82274: IFFALSE 82399
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
82276: LD_ADDR_VAR 0 9
82280: PUSH
82281: LD_OWVAR 3
82285: PUSH
82286: LD_VAR 0 4
82290: PUSH
82291: LD_VAR 0 7
82295: ARRAY
82296: DIFF
82297: PPUSH
82298: LD_VAR 0 4
82302: PUSH
82303: LD_VAR 0 7
82307: ARRAY
82308: PPUSH
82309: CALL_OW 74
82313: ST_TO_ADDR
// if not k then
82314: LD_VAR 0 9
82318: NOT
82319: IFFALSE 82323
// continue ;
82321: GO 78738
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
82323: LD_VAR 0 9
82327: PUSH
82328: LD_INT 81
82330: PUSH
82331: LD_VAR 0 4
82335: PUSH
82336: LD_VAR 0 7
82340: ARRAY
82341: PPUSH
82342: CALL_OW 255
82346: PUSH
82347: EMPTY
82348: LIST
82349: LIST
82350: PPUSH
82351: CALL_OW 69
82355: IN
82356: PUSH
82357: LD_VAR 0 9
82361: PPUSH
82362: LD_VAR 0 4
82366: PUSH
82367: LD_VAR 0 7
82371: ARRAY
82372: PPUSH
82373: CALL_OW 296
82377: PUSH
82378: LD_INT 5
82380: LESS
82381: AND
82382: IFFALSE 82399
// ComAutodestruct ( group [ i ] ) ;
82384: LD_VAR 0 4
82388: PUSH
82389: LD_VAR 0 7
82393: ARRAY
82394: PPUSH
82395: CALL 41855 0 1
// end ; if f_attack_depot then
82399: LD_VAR 0 25
82403: IFFALSE 82515
// begin k := 6 ;
82405: LD_ADDR_VAR 0 9
82409: PUSH
82410: LD_INT 6
82412: ST_TO_ADDR
// if tmp < k then
82413: LD_VAR 0 14
82417: PUSH
82418: LD_VAR 0 9
82422: LESS
82423: IFFALSE 82435
// k := tmp ;
82425: LD_ADDR_VAR 0 9
82429: PUSH
82430: LD_VAR 0 14
82434: ST_TO_ADDR
// for j = 1 to k do
82435: LD_ADDR_VAR 0 8
82439: PUSH
82440: DOUBLE
82441: LD_INT 1
82443: DEC
82444: ST_TO_ADDR
82445: LD_VAR 0 9
82449: PUSH
82450: FOR_TO
82451: IFFALSE 82513
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
82453: LD_VAR 0 8
82457: PPUSH
82458: CALL_OW 266
82462: PUSH
82463: LD_INT 0
82465: PUSH
82466: LD_INT 1
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: IN
82473: IFFALSE 82511
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
82475: LD_VAR 0 4
82479: PUSH
82480: LD_VAR 0 7
82484: ARRAY
82485: PPUSH
82486: LD_VAR 0 14
82490: PUSH
82491: LD_VAR 0 8
82495: ARRAY
82496: PPUSH
82497: CALL_OW 115
// attacking := true ;
82501: LD_ADDR_VAR 0 29
82505: PUSH
82506: LD_INT 1
82508: ST_TO_ADDR
// break ;
82509: GO 82513
// end ;
82511: GO 82450
82513: POP
82514: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
82515: LD_VAR 0 4
82519: PUSH
82520: LD_VAR 0 7
82524: ARRAY
82525: PPUSH
82526: CALL_OW 302
82530: PUSH
82531: LD_VAR 0 29
82535: NOT
82536: AND
82537: IFFALSE 82859
// begin if GetTag ( group [ i ] ) = 71 then
82539: LD_VAR 0 4
82543: PUSH
82544: LD_VAR 0 7
82548: ARRAY
82549: PPUSH
82550: CALL_OW 110
82554: PUSH
82555: LD_INT 71
82557: EQUAL
82558: IFFALSE 82599
// begin if HasTask ( group [ i ] ) then
82560: LD_VAR 0 4
82564: PUSH
82565: LD_VAR 0 7
82569: ARRAY
82570: PPUSH
82571: CALL_OW 314
82575: IFFALSE 82581
// continue else
82577: GO 78738
82579: GO 82599
// SetTag ( group [ i ] , 0 ) ;
82581: LD_VAR 0 4
82585: PUSH
82586: LD_VAR 0 7
82590: ARRAY
82591: PPUSH
82592: LD_INT 0
82594: PPUSH
82595: CALL_OW 109
// end ; k := 8 ;
82599: LD_ADDR_VAR 0 9
82603: PUSH
82604: LD_INT 8
82606: ST_TO_ADDR
// x := 0 ;
82607: LD_ADDR_VAR 0 10
82611: PUSH
82612: LD_INT 0
82614: ST_TO_ADDR
// if tmp < k then
82615: LD_VAR 0 14
82619: PUSH
82620: LD_VAR 0 9
82624: LESS
82625: IFFALSE 82637
// k := tmp ;
82627: LD_ADDR_VAR 0 9
82631: PUSH
82632: LD_VAR 0 14
82636: ST_TO_ADDR
// for j = 1 to k do
82637: LD_ADDR_VAR 0 8
82641: PUSH
82642: DOUBLE
82643: LD_INT 1
82645: DEC
82646: ST_TO_ADDR
82647: LD_VAR 0 9
82651: PUSH
82652: FOR_TO
82653: IFFALSE 82751
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
82655: LD_VAR 0 14
82659: PUSH
82660: LD_VAR 0 8
82664: ARRAY
82665: PPUSH
82666: CALL_OW 247
82670: PUSH
82671: LD_INT 1
82673: EQUAL
82674: PUSH
82675: LD_VAR 0 14
82679: PUSH
82680: LD_VAR 0 8
82684: ARRAY
82685: PPUSH
82686: CALL_OW 256
82690: PUSH
82691: LD_INT 250
82693: LESS
82694: PUSH
82695: LD_VAR 0 20
82699: AND
82700: PUSH
82701: LD_VAR 0 20
82705: NOT
82706: PUSH
82707: LD_VAR 0 14
82711: PUSH
82712: LD_VAR 0 8
82716: ARRAY
82717: PPUSH
82718: CALL_OW 256
82722: PUSH
82723: LD_INT 250
82725: GREATEREQUAL
82726: AND
82727: OR
82728: AND
82729: IFFALSE 82749
// begin x := tmp [ j ] ;
82731: LD_ADDR_VAR 0 10
82735: PUSH
82736: LD_VAR 0 14
82740: PUSH
82741: LD_VAR 0 8
82745: ARRAY
82746: ST_TO_ADDR
// break ;
82747: GO 82751
// end ;
82749: GO 82652
82751: POP
82752: POP
// if x then
82753: LD_VAR 0 10
82757: IFFALSE 82781
// ComAttackUnit ( group [ i ] , x ) else
82759: LD_VAR 0 4
82763: PUSH
82764: LD_VAR 0 7
82768: ARRAY
82769: PPUSH
82770: LD_VAR 0 10
82774: PPUSH
82775: CALL_OW 115
82779: GO 82805
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
82781: LD_VAR 0 4
82785: PUSH
82786: LD_VAR 0 7
82790: ARRAY
82791: PPUSH
82792: LD_VAR 0 14
82796: PUSH
82797: LD_INT 1
82799: ARRAY
82800: PPUSH
82801: CALL_OW 115
// if not HasTask ( group [ i ] ) then
82805: LD_VAR 0 4
82809: PUSH
82810: LD_VAR 0 7
82814: ARRAY
82815: PPUSH
82816: CALL_OW 314
82820: NOT
82821: IFFALSE 82859
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
82823: LD_VAR 0 4
82827: PUSH
82828: LD_VAR 0 7
82832: ARRAY
82833: PPUSH
82834: LD_VAR 0 14
82838: PPUSH
82839: LD_VAR 0 4
82843: PUSH
82844: LD_VAR 0 7
82848: ARRAY
82849: PPUSH
82850: CALL_OW 74
82854: PPUSH
82855: CALL_OW 115
// end ; end ; end ;
82859: GO 78738
82861: POP
82862: POP
// wait ( 0 0$2 ) ;
82863: LD_INT 70
82865: PPUSH
82866: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
82870: LD_VAR 0 4
82874: NOT
82875: PUSH
82876: LD_VAR 0 4
82880: PUSH
82881: EMPTY
82882: EQUAL
82883: OR
82884: PUSH
82885: LD_INT 81
82887: PUSH
82888: LD_VAR 0 35
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PPUSH
82897: CALL_OW 69
82901: NOT
82902: OR
82903: IFFALSE 78723
// end ;
82905: LD_VAR 0 2
82909: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
82910: LD_INT 0
82912: PPUSH
82913: PPUSH
82914: PPUSH
82915: PPUSH
82916: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
82917: LD_VAR 0 1
82921: NOT
82922: PUSH
82923: LD_EXP 23
82927: PUSH
82928: LD_VAR 0 1
82932: ARRAY
82933: NOT
82934: OR
82935: PUSH
82936: LD_VAR 0 2
82940: NOT
82941: OR
82942: PUSH
82943: LD_VAR 0 3
82947: NOT
82948: OR
82949: IFFALSE 82953
// exit ;
82951: GO 83466
// side := mc_sides [ base ] ;
82953: LD_ADDR_VAR 0 6
82957: PUSH
82958: LD_EXP 49
82962: PUSH
82963: LD_VAR 0 1
82967: ARRAY
82968: ST_TO_ADDR
// if not side then
82969: LD_VAR 0 6
82973: NOT
82974: IFFALSE 82978
// exit ;
82976: GO 83466
// for i in solds do
82978: LD_ADDR_VAR 0 7
82982: PUSH
82983: LD_VAR 0 2
82987: PUSH
82988: FOR_IN
82989: IFFALSE 83050
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
82991: LD_VAR 0 7
82995: PPUSH
82996: CALL_OW 310
83000: PPUSH
83001: CALL_OW 266
83005: PUSH
83006: LD_INT 32
83008: PUSH
83009: LD_INT 31
83011: PUSH
83012: EMPTY
83013: LIST
83014: LIST
83015: IN
83016: IFFALSE 83036
// solds := solds diff i else
83018: LD_ADDR_VAR 0 2
83022: PUSH
83023: LD_VAR 0 2
83027: PUSH
83028: LD_VAR 0 7
83032: DIFF
83033: ST_TO_ADDR
83034: GO 83048
// SetTag ( i , 18 ) ;
83036: LD_VAR 0 7
83040: PPUSH
83041: LD_INT 18
83043: PPUSH
83044: CALL_OW 109
83048: GO 82988
83050: POP
83051: POP
// if not solds then
83052: LD_VAR 0 2
83056: NOT
83057: IFFALSE 83061
// exit ;
83059: GO 83466
// repeat wait ( 0 0$2 ) ;
83061: LD_INT 70
83063: PPUSH
83064: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
83068: LD_ADDR_VAR 0 5
83072: PUSH
83073: LD_VAR 0 6
83077: PPUSH
83078: LD_VAR 0 3
83082: PPUSH
83083: CALL 10825 0 2
83087: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83088: LD_EXP 23
83092: PUSH
83093: LD_VAR 0 1
83097: ARRAY
83098: NOT
83099: PUSH
83100: LD_EXP 23
83104: PUSH
83105: LD_VAR 0 1
83109: ARRAY
83110: PUSH
83111: EMPTY
83112: EQUAL
83113: OR
83114: IFFALSE 83151
// begin for i in solds do
83116: LD_ADDR_VAR 0 7
83120: PUSH
83121: LD_VAR 0 2
83125: PUSH
83126: FOR_IN
83127: IFFALSE 83140
// ComStop ( i ) ;
83129: LD_VAR 0 7
83133: PPUSH
83134: CALL_OW 141
83138: GO 83126
83140: POP
83141: POP
// solds := [ ] ;
83142: LD_ADDR_VAR 0 2
83146: PUSH
83147: EMPTY
83148: ST_TO_ADDR
// exit ;
83149: GO 83466
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
83151: LD_VAR 0 5
83155: NOT
83156: PUSH
83157: LD_VAR 0 5
83161: PUSH
83162: LD_INT 3
83164: GREATER
83165: OR
83166: PUSH
83167: LD_EXP 45
83171: PUSH
83172: LD_VAR 0 1
83176: ARRAY
83177: OR
83178: IFFALSE 83219
// begin for i in solds do
83180: LD_ADDR_VAR 0 7
83184: PUSH
83185: LD_VAR 0 2
83189: PUSH
83190: FOR_IN
83191: IFFALSE 83215
// if HasTask ( i ) then
83193: LD_VAR 0 7
83197: PPUSH
83198: CALL_OW 314
83202: IFFALSE 83213
// ComStop ( i ) ;
83204: LD_VAR 0 7
83208: PPUSH
83209: CALL_OW 141
83213: GO 83190
83215: POP
83216: POP
// break ;
83217: GO 83454
// end ; for i in solds do
83219: LD_ADDR_VAR 0 7
83223: PUSH
83224: LD_VAR 0 2
83228: PUSH
83229: FOR_IN
83230: IFFALSE 83446
// begin if IsInUnit ( i ) then
83232: LD_VAR 0 7
83236: PPUSH
83237: CALL_OW 310
83241: IFFALSE 83252
// ComExitBuilding ( i ) ;
83243: LD_VAR 0 7
83247: PPUSH
83248: CALL_OW 122
// if GetLives ( i ) > 333 then
83252: LD_VAR 0 7
83256: PPUSH
83257: CALL_OW 256
83261: PUSH
83262: LD_INT 333
83264: GREATER
83265: IFFALSE 83293
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
83267: LD_VAR 0 7
83271: PPUSH
83272: LD_VAR 0 5
83276: PPUSH
83277: LD_VAR 0 7
83281: PPUSH
83282: CALL_OW 74
83286: PPUSH
83287: CALL_OW 115
83291: GO 83444
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
83293: LD_ADDR_VAR 0 8
83297: PUSH
83298: LD_EXP 23
83302: PUSH
83303: LD_VAR 0 1
83307: ARRAY
83308: PPUSH
83309: LD_INT 2
83311: PUSH
83312: LD_INT 30
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: LD_INT 30
83324: PUSH
83325: LD_INT 1
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: PUSH
83332: LD_INT 30
83334: PUSH
83335: LD_INT 6
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: PPUSH
83348: CALL_OW 72
83352: PPUSH
83353: LD_VAR 0 7
83357: PPUSH
83358: CALL_OW 74
83362: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
83363: LD_VAR 0 7
83367: PPUSH
83368: LD_VAR 0 8
83372: PPUSH
83373: CALL_OW 250
83377: PPUSH
83378: LD_INT 3
83380: PPUSH
83381: LD_INT 5
83383: PPUSH
83384: CALL_OW 272
83388: PPUSH
83389: LD_VAR 0 8
83393: PPUSH
83394: CALL_OW 251
83398: PPUSH
83399: LD_INT 3
83401: PPUSH
83402: LD_INT 5
83404: PPUSH
83405: CALL_OW 273
83409: PPUSH
83410: CALL_OW 111
// SetTag ( i , 0 ) ;
83414: LD_VAR 0 7
83418: PPUSH
83419: LD_INT 0
83421: PPUSH
83422: CALL_OW 109
// solds := solds diff i ;
83426: LD_ADDR_VAR 0 2
83430: PUSH
83431: LD_VAR 0 2
83435: PUSH
83436: LD_VAR 0 7
83440: DIFF
83441: ST_TO_ADDR
// continue ;
83442: GO 83229
// end ; end ;
83444: GO 83229
83446: POP
83447: POP
// until solds ;
83448: LD_VAR 0 2
83452: IFFALSE 83061
// MC_Reset ( base , 18 ) ;
83454: LD_VAR 0 1
83458: PPUSH
83459: LD_INT 18
83461: PPUSH
83462: CALL 51777 0 2
// end ;
83466: LD_VAR 0 4
83470: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class ; begin
83471: LD_INT 0
83473: PPUSH
83474: PPUSH
83475: PPUSH
83476: PPUSH
83477: PPUSH
83478: PPUSH
83479: PPUSH
83480: PPUSH
83481: PPUSH
83482: PPUSH
83483: PPUSH
83484: PPUSH
83485: PPUSH
83486: PPUSH
83487: PPUSH
83488: PPUSH
83489: PPUSH
83490: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
83491: LD_ADDR_VAR 0 13
83495: PUSH
83496: LD_EXP 23
83500: PUSH
83501: LD_VAR 0 1
83505: ARRAY
83506: PPUSH
83507: LD_INT 25
83509: PUSH
83510: LD_INT 3
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PPUSH
83517: CALL_OW 72
83521: ST_TO_ADDR
// if mc_remote_driver [ base ] then
83522: LD_EXP 63
83526: PUSH
83527: LD_VAR 0 1
83531: ARRAY
83532: IFFALSE 83556
// mechs := mechs diff mc_remote_driver [ base ] ;
83534: LD_ADDR_VAR 0 13
83538: PUSH
83539: LD_VAR 0 13
83543: PUSH
83544: LD_EXP 63
83548: PUSH
83549: LD_VAR 0 1
83553: ARRAY
83554: DIFF
83555: ST_TO_ADDR
// for i in mechs do
83556: LD_ADDR_VAR 0 5
83560: PUSH
83561: LD_VAR 0 13
83565: PUSH
83566: FOR_IN
83567: IFFALSE 83602
// if GetTag ( i ) > 0 then
83569: LD_VAR 0 5
83573: PPUSH
83574: CALL_OW 110
83578: PUSH
83579: LD_INT 0
83581: GREATER
83582: IFFALSE 83600
// mechs := mechs diff i ;
83584: LD_ADDR_VAR 0 13
83588: PUSH
83589: LD_VAR 0 13
83593: PUSH
83594: LD_VAR 0 5
83598: DIFF
83599: ST_TO_ADDR
83600: GO 83566
83602: POP
83603: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
83604: LD_ADDR_VAR 0 9
83608: PUSH
83609: LD_EXP 23
83613: PUSH
83614: LD_VAR 0 1
83618: ARRAY
83619: PPUSH
83620: LD_INT 2
83622: PUSH
83623: LD_INT 25
83625: PUSH
83626: LD_INT 1
83628: PUSH
83629: EMPTY
83630: LIST
83631: LIST
83632: PUSH
83633: LD_INT 25
83635: PUSH
83636: LD_INT 5
83638: PUSH
83639: EMPTY
83640: LIST
83641: LIST
83642: PUSH
83643: LD_INT 25
83645: PUSH
83646: LD_INT 8
83648: PUSH
83649: EMPTY
83650: LIST
83651: LIST
83652: PUSH
83653: LD_INT 25
83655: PUSH
83656: LD_INT 9
83658: PUSH
83659: EMPTY
83660: LIST
83661: LIST
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: LIST
83667: LIST
83668: LIST
83669: PPUSH
83670: CALL_OW 72
83674: ST_TO_ADDR
// if not defenders and not solds then
83675: LD_VAR 0 2
83679: NOT
83680: PUSH
83681: LD_VAR 0 9
83685: NOT
83686: AND
83687: IFFALSE 83691
// exit ;
83689: GO 85461
// depot_under_attack := false ;
83691: LD_ADDR_VAR 0 17
83695: PUSH
83696: LD_INT 0
83698: ST_TO_ADDR
// sold_defenders := [ ] ;
83699: LD_ADDR_VAR 0 18
83703: PUSH
83704: EMPTY
83705: ST_TO_ADDR
// if mechs then
83706: LD_VAR 0 13
83710: IFFALSE 83863
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
83712: LD_ADDR_VAR 0 5
83716: PUSH
83717: LD_VAR 0 2
83721: PPUSH
83722: LD_INT 21
83724: PUSH
83725: LD_INT 2
83727: PUSH
83728: EMPTY
83729: LIST
83730: LIST
83731: PPUSH
83732: CALL_OW 72
83736: PUSH
83737: FOR_IN
83738: IFFALSE 83861
// begin if GetTag ( i ) <> 20 then
83740: LD_VAR 0 5
83744: PPUSH
83745: CALL_OW 110
83749: PUSH
83750: LD_INT 20
83752: NONEQUAL
83753: IFFALSE 83767
// SetTag ( i , 20 ) ;
83755: LD_VAR 0 5
83759: PPUSH
83760: LD_INT 20
83762: PPUSH
83763: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
83767: LD_VAR 0 5
83771: PPUSH
83772: CALL_OW 263
83776: PUSH
83777: LD_INT 1
83779: EQUAL
83780: PUSH
83781: LD_VAR 0 5
83785: PPUSH
83786: CALL_OW 311
83790: NOT
83791: AND
83792: IFFALSE 83859
// begin un := mechs [ 1 ] ;
83794: LD_ADDR_VAR 0 11
83798: PUSH
83799: LD_VAR 0 13
83803: PUSH
83804: LD_INT 1
83806: ARRAY
83807: ST_TO_ADDR
// ComExit ( un ) ;
83808: LD_VAR 0 11
83812: PPUSH
83813: CALL 46200 0 1
// AddComEnterUnit ( un , i ) ;
83817: LD_VAR 0 11
83821: PPUSH
83822: LD_VAR 0 5
83826: PPUSH
83827: CALL_OW 180
// SetTag ( un , 19 ) ;
83831: LD_VAR 0 11
83835: PPUSH
83836: LD_INT 19
83838: PPUSH
83839: CALL_OW 109
// mechs := mechs diff un ;
83843: LD_ADDR_VAR 0 13
83847: PUSH
83848: LD_VAR 0 13
83852: PUSH
83853: LD_VAR 0 11
83857: DIFF
83858: ST_TO_ADDR
// end ; end ;
83859: GO 83737
83861: POP
83862: POP
// if solds then
83863: LD_VAR 0 9
83867: IFFALSE 83926
// for i in solds do
83869: LD_ADDR_VAR 0 5
83873: PUSH
83874: LD_VAR 0 9
83878: PUSH
83879: FOR_IN
83880: IFFALSE 83924
// if not GetTag ( i ) then
83882: LD_VAR 0 5
83886: PPUSH
83887: CALL_OW 110
83891: NOT
83892: IFFALSE 83922
// begin defenders := defenders union i ;
83894: LD_ADDR_VAR 0 2
83898: PUSH
83899: LD_VAR 0 2
83903: PUSH
83904: LD_VAR 0 5
83908: UNION
83909: ST_TO_ADDR
// SetTag ( i , 18 ) ;
83910: LD_VAR 0 5
83914: PPUSH
83915: LD_INT 18
83917: PPUSH
83918: CALL_OW 109
// end ;
83922: GO 83879
83924: POP
83925: POP
// repeat wait ( 0 0$2 ) ;
83926: LD_INT 70
83928: PPUSH
83929: CALL_OW 67
// enemy := mc_scan [ base ] ;
83933: LD_ADDR_VAR 0 3
83937: PUSH
83938: LD_EXP 46
83942: PUSH
83943: LD_VAR 0 1
83947: ARRAY
83948: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
83949: LD_EXP 23
83953: PUSH
83954: LD_VAR 0 1
83958: ARRAY
83959: NOT
83960: PUSH
83961: LD_EXP 23
83965: PUSH
83966: LD_VAR 0 1
83970: ARRAY
83971: PUSH
83972: EMPTY
83973: EQUAL
83974: OR
83975: IFFALSE 84012
// begin for i in defenders do
83977: LD_ADDR_VAR 0 5
83981: PUSH
83982: LD_VAR 0 2
83986: PUSH
83987: FOR_IN
83988: IFFALSE 84001
// ComStop ( i ) ;
83990: LD_VAR 0 5
83994: PPUSH
83995: CALL_OW 141
83999: GO 83987
84001: POP
84002: POP
// defenders := [ ] ;
84003: LD_ADDR_VAR 0 2
84007: PUSH
84008: EMPTY
84009: ST_TO_ADDR
// exit ;
84010: GO 85461
// end ; for i in defenders do
84012: LD_ADDR_VAR 0 5
84016: PUSH
84017: LD_VAR 0 2
84021: PUSH
84022: FOR_IN
84023: IFFALSE 84921
// begin e := NearestUnitToUnit ( enemy , i ) ;
84025: LD_ADDR_VAR 0 14
84029: PUSH
84030: LD_VAR 0 3
84034: PPUSH
84035: LD_VAR 0 5
84039: PPUSH
84040: CALL_OW 74
84044: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84045: LD_ADDR_VAR 0 8
84049: PUSH
84050: LD_EXP 23
84054: PUSH
84055: LD_VAR 0 1
84059: ARRAY
84060: PPUSH
84061: LD_INT 2
84063: PUSH
84064: LD_INT 30
84066: PUSH
84067: LD_INT 0
84069: PUSH
84070: EMPTY
84071: LIST
84072: LIST
84073: PUSH
84074: LD_INT 30
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: PUSH
84084: EMPTY
84085: LIST
84086: LIST
84087: LIST
84088: PPUSH
84089: CALL_OW 72
84093: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
84094: LD_ADDR_VAR 0 17
84098: PUSH
84099: LD_VAR 0 8
84103: NOT
84104: PUSH
84105: LD_VAR 0 8
84109: PPUSH
84110: LD_INT 3
84112: PUSH
84113: LD_INT 24
84115: PUSH
84116: LD_INT 600
84118: PUSH
84119: EMPTY
84120: LIST
84121: LIST
84122: PUSH
84123: EMPTY
84124: LIST
84125: LIST
84126: PPUSH
84127: CALL_OW 72
84131: OR
84132: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
84133: LD_VAR 0 5
84137: PPUSH
84138: CALL_OW 247
84142: PUSH
84143: LD_INT 2
84145: DOUBLE
84146: EQUAL
84147: IFTRUE 84151
84149: GO 84547
84151: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
84152: LD_VAR 0 5
84156: PPUSH
84157: CALL_OW 256
84161: PUSH
84162: LD_INT 1000
84164: EQUAL
84165: PUSH
84166: LD_VAR 0 5
84170: PPUSH
84171: LD_VAR 0 14
84175: PPUSH
84176: CALL_OW 296
84180: PUSH
84181: LD_INT 40
84183: LESS
84184: PUSH
84185: LD_VAR 0 14
84189: PPUSH
84190: LD_EXP 48
84194: PUSH
84195: LD_VAR 0 1
84199: ARRAY
84200: PPUSH
84201: CALL_OW 308
84205: OR
84206: AND
84207: IFFALSE 84329
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
84209: LD_VAR 0 5
84213: PPUSH
84214: CALL_OW 262
84218: PUSH
84219: LD_INT 1
84221: EQUAL
84222: PUSH
84223: LD_VAR 0 5
84227: PPUSH
84228: CALL_OW 261
84232: PUSH
84233: LD_INT 30
84235: LESS
84236: AND
84237: PUSH
84238: LD_VAR 0 8
84242: AND
84243: IFFALSE 84313
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
84245: LD_VAR 0 5
84249: PPUSH
84250: LD_VAR 0 8
84254: PPUSH
84255: LD_VAR 0 5
84259: PPUSH
84260: CALL_OW 74
84264: PPUSH
84265: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
84269: LD_VAR 0 5
84273: PPUSH
84274: LD_VAR 0 8
84278: PPUSH
84279: LD_VAR 0 5
84283: PPUSH
84284: CALL_OW 74
84288: PPUSH
84289: CALL_OW 296
84293: PUSH
84294: LD_INT 6
84296: LESS
84297: IFFALSE 84311
// SetFuel ( i , 100 ) ;
84299: LD_VAR 0 5
84303: PPUSH
84304: LD_INT 100
84306: PPUSH
84307: CALL_OW 240
// end else
84311: GO 84327
// ComAttackUnit ( i , e ) ;
84313: LD_VAR 0 5
84317: PPUSH
84318: LD_VAR 0 14
84322: PPUSH
84323: CALL_OW 115
// end else
84327: GO 84430
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
84329: LD_VAR 0 14
84333: PPUSH
84334: LD_EXP 48
84338: PUSH
84339: LD_VAR 0 1
84343: ARRAY
84344: PPUSH
84345: CALL_OW 308
84349: NOT
84350: PUSH
84351: LD_VAR 0 5
84355: PPUSH
84356: LD_VAR 0 14
84360: PPUSH
84361: CALL_OW 296
84365: PUSH
84366: LD_INT 40
84368: GREATEREQUAL
84369: AND
84370: PUSH
84371: LD_VAR 0 5
84375: PPUSH
84376: CALL_OW 256
84380: PUSH
84381: LD_INT 650
84383: LESSEQUAL
84384: OR
84385: PUSH
84386: LD_VAR 0 5
84390: PPUSH
84391: LD_EXP 47
84395: PUSH
84396: LD_VAR 0 1
84400: ARRAY
84401: PPUSH
84402: CALL_OW 308
84406: NOT
84407: AND
84408: IFFALSE 84430
// ComMoveToArea ( i , mc_parking [ base ] ) ;
84410: LD_VAR 0 5
84414: PPUSH
84415: LD_EXP 47
84419: PUSH
84420: LD_VAR 0 1
84424: ARRAY
84425: PPUSH
84426: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
84430: LD_VAR 0 5
84434: PPUSH
84435: CALL_OW 256
84439: PUSH
84440: LD_INT 1000
84442: LESS
84443: PUSH
84444: LD_VAR 0 5
84448: PPUSH
84449: CALL_OW 263
84453: PUSH
84454: LD_INT 1
84456: EQUAL
84457: AND
84458: PUSH
84459: LD_VAR 0 5
84463: PPUSH
84464: CALL_OW 311
84468: AND
84469: PUSH
84470: LD_VAR 0 5
84474: PPUSH
84475: LD_EXP 47
84479: PUSH
84480: LD_VAR 0 1
84484: ARRAY
84485: PPUSH
84486: CALL_OW 308
84490: AND
84491: IFFALSE 84545
// begin mech := IsDrivenBy ( i ) ;
84493: LD_ADDR_VAR 0 10
84497: PUSH
84498: LD_VAR 0 5
84502: PPUSH
84503: CALL_OW 311
84507: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
84508: LD_VAR 0 10
84512: PPUSH
84513: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
84517: LD_VAR 0 10
84521: PPUSH
84522: LD_VAR 0 5
84526: PPUSH
84527: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
84531: LD_VAR 0 10
84535: PPUSH
84536: LD_VAR 0 5
84540: PPUSH
84541: CALL_OW 180
// end ; end ; unit_human :
84545: GO 84892
84547: LD_INT 1
84549: DOUBLE
84550: EQUAL
84551: IFTRUE 84555
84553: GO 84891
84555: POP
// begin b := IsInUnit ( i ) ;
84556: LD_ADDR_VAR 0 19
84560: PUSH
84561: LD_VAR 0 5
84565: PPUSH
84566: CALL_OW 310
84570: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
84571: LD_ADDR_VAR 0 20
84575: PUSH
84576: LD_VAR 0 19
84580: NOT
84581: PUSH
84582: LD_VAR 0 19
84586: PPUSH
84587: CALL_OW 266
84591: PUSH
84592: LD_INT 32
84594: PUSH
84595: LD_INT 31
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: IN
84602: OR
84603: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
84604: LD_VAR 0 19
84608: PPUSH
84609: CALL_OW 266
84613: PUSH
84614: LD_INT 5
84616: EQUAL
84617: PUSH
84618: LD_VAR 0 5
84622: PPUSH
84623: CALL_OW 257
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: LD_INT 2
84633: PUSH
84634: LD_INT 3
84636: PUSH
84637: LD_INT 4
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: IN
84646: AND
84647: IFFALSE 84684
// begin class := AllowSpecClass ( i ) ;
84649: LD_ADDR_VAR 0 21
84653: PUSH
84654: LD_VAR 0 5
84658: PPUSH
84659: CALL 10860 0 1
84663: ST_TO_ADDR
// if class then
84664: LD_VAR 0 21
84668: IFFALSE 84684
// ComChangeProfession ( i , class ) ;
84670: LD_VAR 0 5
84674: PPUSH
84675: LD_VAR 0 21
84679: PPUSH
84680: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
84684: LD_VAR 0 17
84688: PUSH
84689: LD_VAR 0 2
84693: PPUSH
84694: LD_INT 21
84696: PUSH
84697: LD_INT 2
84699: PUSH
84700: EMPTY
84701: LIST
84702: LIST
84703: PPUSH
84704: CALL_OW 72
84708: PUSH
84709: LD_INT 1
84711: LESSEQUAL
84712: OR
84713: PUSH
84714: LD_VAR 0 20
84718: AND
84719: PUSH
84720: LD_VAR 0 5
84724: PUSH
84725: LD_VAR 0 18
84729: IN
84730: NOT
84731: AND
84732: IFFALSE 84825
// begin if b then
84734: LD_VAR 0 19
84738: IFFALSE 84787
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
84740: LD_VAR 0 19
84744: PPUSH
84745: LD_VAR 0 3
84749: PPUSH
84750: LD_VAR 0 19
84754: PPUSH
84755: CALL_OW 74
84759: PPUSH
84760: CALL_OW 296
84764: PUSH
84765: LD_INT 10
84767: LESS
84768: PUSH
84769: LD_VAR 0 19
84773: PPUSH
84774: CALL_OW 461
84778: PUSH
84779: LD_INT 7
84781: NONEQUAL
84782: AND
84783: IFFALSE 84787
// continue ;
84785: GO 84022
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
84787: LD_ADDR_VAR 0 18
84791: PUSH
84792: LD_VAR 0 18
84796: PPUSH
84797: LD_VAR 0 18
84801: PUSH
84802: LD_INT 1
84804: PLUS
84805: PPUSH
84806: LD_VAR 0 5
84810: PPUSH
84811: CALL_OW 1
84815: ST_TO_ADDR
// ComExitBuilding ( i ) ;
84816: LD_VAR 0 5
84820: PPUSH
84821: CALL_OW 122
// end ; if sold_defenders then
84825: LD_VAR 0 18
84829: IFFALSE 84889
// if i in sold_defenders then
84831: LD_VAR 0 5
84835: PUSH
84836: LD_VAR 0 18
84840: IN
84841: IFFALSE 84889
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
84843: LD_VAR 0 5
84847: PPUSH
84848: CALL_OW 314
84852: NOT
84853: PUSH
84854: LD_VAR 0 5
84858: PPUSH
84859: LD_VAR 0 14
84863: PPUSH
84864: CALL_OW 296
84868: PUSH
84869: LD_INT 30
84871: LESS
84872: AND
84873: IFFALSE 84889
// ComAttackUnit ( i , e ) ;
84875: LD_VAR 0 5
84879: PPUSH
84880: LD_VAR 0 14
84884: PPUSH
84885: CALL_OW 115
// end ; end ; end ;
84889: GO 84892
84891: POP
// if IsDead ( i ) then
84892: LD_VAR 0 5
84896: PPUSH
84897: CALL_OW 301
84901: IFFALSE 84919
// defenders := defenders diff i ;
84903: LD_ADDR_VAR 0 2
84907: PUSH
84908: LD_VAR 0 2
84912: PUSH
84913: LD_VAR 0 5
84917: DIFF
84918: ST_TO_ADDR
// end ;
84919: GO 84022
84921: POP
84922: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
84923: LD_VAR 0 3
84927: NOT
84928: PUSH
84929: LD_VAR 0 2
84933: NOT
84934: OR
84935: PUSH
84936: LD_EXP 23
84940: PUSH
84941: LD_VAR 0 1
84945: ARRAY
84946: NOT
84947: OR
84948: IFFALSE 83926
// MC_Reset ( base , 18 ) ;
84950: LD_VAR 0 1
84954: PPUSH
84955: LD_INT 18
84957: PPUSH
84958: CALL 51777 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
84962: LD_ADDR_VAR 0 2
84966: PUSH
84967: LD_VAR 0 2
84971: PUSH
84972: LD_VAR 0 2
84976: PPUSH
84977: LD_INT 2
84979: PUSH
84980: LD_INT 25
84982: PUSH
84983: LD_INT 1
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 25
84992: PUSH
84993: LD_INT 5
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 25
85002: PUSH
85003: LD_INT 8
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 25
85012: PUSH
85013: LD_INT 9
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: EMPTY
85021: LIST
85022: LIST
85023: LIST
85024: LIST
85025: LIST
85026: PPUSH
85027: CALL_OW 72
85031: DIFF
85032: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
85033: LD_VAR 0 3
85037: NOT
85038: PUSH
85039: LD_VAR 0 2
85043: PPUSH
85044: LD_INT 21
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: EMPTY
85051: LIST
85052: LIST
85053: PPUSH
85054: CALL_OW 72
85058: AND
85059: IFFALSE 85397
// begin tmp := FilterByTag ( defenders , 19 ) ;
85061: LD_ADDR_VAR 0 12
85065: PUSH
85066: LD_VAR 0 2
85070: PPUSH
85071: LD_INT 19
85073: PPUSH
85074: CALL 43330 0 2
85078: ST_TO_ADDR
// if tmp then
85079: LD_VAR 0 12
85083: IFFALSE 85153
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
85085: LD_ADDR_VAR 0 12
85089: PUSH
85090: LD_VAR 0 12
85094: PPUSH
85095: LD_INT 25
85097: PUSH
85098: LD_INT 3
85100: PUSH
85101: EMPTY
85102: LIST
85103: LIST
85104: PPUSH
85105: CALL_OW 72
85109: ST_TO_ADDR
// if tmp then
85110: LD_VAR 0 12
85114: IFFALSE 85153
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
85116: LD_ADDR_EXP 35
85120: PUSH
85121: LD_EXP 35
85125: PPUSH
85126: LD_VAR 0 1
85130: PPUSH
85131: LD_EXP 35
85135: PUSH
85136: LD_VAR 0 1
85140: ARRAY
85141: PUSH
85142: LD_VAR 0 12
85146: UNION
85147: PPUSH
85148: CALL_OW 1
85152: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
85153: LD_VAR 0 1
85157: PPUSH
85158: LD_INT 19
85160: PPUSH
85161: CALL 51777 0 2
// repeat wait ( 0 0$1 ) ;
85165: LD_INT 35
85167: PPUSH
85168: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
85172: LD_EXP 23
85176: PUSH
85177: LD_VAR 0 1
85181: ARRAY
85182: NOT
85183: PUSH
85184: LD_EXP 23
85188: PUSH
85189: LD_VAR 0 1
85193: ARRAY
85194: PUSH
85195: EMPTY
85196: EQUAL
85197: OR
85198: IFFALSE 85235
// begin for i in defenders do
85200: LD_ADDR_VAR 0 5
85204: PUSH
85205: LD_VAR 0 2
85209: PUSH
85210: FOR_IN
85211: IFFALSE 85224
// ComStop ( i ) ;
85213: LD_VAR 0 5
85217: PPUSH
85218: CALL_OW 141
85222: GO 85210
85224: POP
85225: POP
// defenders := [ ] ;
85226: LD_ADDR_VAR 0 2
85230: PUSH
85231: EMPTY
85232: ST_TO_ADDR
// exit ;
85233: GO 85461
// end ; for i in defenders do
85235: LD_ADDR_VAR 0 5
85239: PUSH
85240: LD_VAR 0 2
85244: PUSH
85245: FOR_IN
85246: IFFALSE 85335
// begin if not IsInArea ( i , mc_parking [ base ] ) then
85248: LD_VAR 0 5
85252: PPUSH
85253: LD_EXP 47
85257: PUSH
85258: LD_VAR 0 1
85262: ARRAY
85263: PPUSH
85264: CALL_OW 308
85268: NOT
85269: IFFALSE 85293
// ComMoveToArea ( i , mc_parking [ base ] ) else
85271: LD_VAR 0 5
85275: PPUSH
85276: LD_EXP 47
85280: PUSH
85281: LD_VAR 0 1
85285: ARRAY
85286: PPUSH
85287: CALL_OW 113
85291: GO 85333
// if GetControl ( i ) = control_manual then
85293: LD_VAR 0 5
85297: PPUSH
85298: CALL_OW 263
85302: PUSH
85303: LD_INT 1
85305: EQUAL
85306: IFFALSE 85333
// if IsDrivenBy ( i ) then
85308: LD_VAR 0 5
85312: PPUSH
85313: CALL_OW 311
85317: IFFALSE 85333
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
85319: LD_VAR 0 5
85323: PPUSH
85324: CALL_OW 311
85328: PPUSH
85329: CALL_OW 121
// end ;
85333: GO 85245
85335: POP
85336: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
85337: LD_VAR 0 2
85341: PPUSH
85342: LD_INT 95
85344: PUSH
85345: LD_EXP 47
85349: PUSH
85350: LD_VAR 0 1
85354: ARRAY
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PPUSH
85360: CALL_OW 72
85364: PUSH
85365: LD_VAR 0 2
85369: EQUAL
85370: PUSH
85371: LD_EXP 46
85375: PUSH
85376: LD_VAR 0 1
85380: ARRAY
85381: OR
85382: PUSH
85383: LD_EXP 23
85387: PUSH
85388: LD_VAR 0 1
85392: ARRAY
85393: NOT
85394: OR
85395: IFFALSE 85165
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
85397: LD_ADDR_EXP 45
85401: PUSH
85402: LD_EXP 45
85406: PPUSH
85407: LD_VAR 0 1
85411: PPUSH
85412: LD_VAR 0 2
85416: PPUSH
85417: LD_INT 21
85419: PUSH
85420: LD_INT 2
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PPUSH
85427: CALL_OW 72
85431: PPUSH
85432: CALL_OW 1
85436: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
85437: LD_VAR 0 1
85441: PPUSH
85442: LD_INT 19
85444: PPUSH
85445: CALL 51777 0 2
// MC_Reset ( base , 20 ) ;
85449: LD_VAR 0 1
85453: PPUSH
85454: LD_INT 20
85456: PPUSH
85457: CALL 51777 0 2
// end ; end_of_file
85461: LD_VAR 0 4
85465: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
85466: LD_INT 0
85468: PPUSH
85469: PPUSH
85470: PPUSH
85471: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
85472: LD_VAR 0 1
85476: PPUSH
85477: CALL_OW 264
85481: PUSH
85482: LD_EXP 71
85486: EQUAL
85487: IFFALSE 85559
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
85489: LD_INT 68
85491: PPUSH
85492: LD_VAR 0 1
85496: PPUSH
85497: CALL_OW 255
85501: PPUSH
85502: CALL_OW 321
85506: PUSH
85507: LD_INT 2
85509: EQUAL
85510: IFFALSE 85522
// eff := 70 else
85512: LD_ADDR_VAR 0 4
85516: PUSH
85517: LD_INT 70
85519: ST_TO_ADDR
85520: GO 85530
// eff := 30 ;
85522: LD_ADDR_VAR 0 4
85526: PUSH
85527: LD_INT 30
85529: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
85530: LD_VAR 0 1
85534: PPUSH
85535: CALL_OW 250
85539: PPUSH
85540: LD_VAR 0 1
85544: PPUSH
85545: CALL_OW 251
85549: PPUSH
85550: LD_VAR 0 4
85554: PPUSH
85555: CALL_OW 495
// end ; end ;
85559: LD_VAR 0 2
85563: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
85564: LD_INT 0
85566: PPUSH
// end ;
85567: LD_VAR 0 4
85571: RET
// export function SOS_Command ( cmd ) ; begin
85572: LD_INT 0
85574: PPUSH
// end ;
85575: LD_VAR 0 2
85579: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
85580: LD_INT 0
85582: PPUSH
// if cmd = 121 then
85583: LD_VAR 0 1
85587: PUSH
85588: LD_INT 121
85590: EQUAL
85591: IFFALSE 85593
// end ;
85593: LD_VAR 0 6
85597: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
85598: LD_INT 0
85600: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
85601: LD_VAR 0 1
85605: PUSH
85606: LD_INT 250
85608: EQUAL
85609: PUSH
85610: LD_VAR 0 2
85614: PPUSH
85615: CALL_OW 264
85619: PUSH
85620: LD_EXP 74
85624: EQUAL
85625: AND
85626: IFFALSE 85647
// MinerPlaceMine ( unit , x , y ) ;
85628: LD_VAR 0 2
85632: PPUSH
85633: LD_VAR 0 4
85637: PPUSH
85638: LD_VAR 0 5
85642: PPUSH
85643: CALL 87996 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
85647: LD_VAR 0 1
85651: PUSH
85652: LD_INT 251
85654: EQUAL
85655: PUSH
85656: LD_VAR 0 2
85660: PPUSH
85661: CALL_OW 264
85665: PUSH
85666: LD_EXP 74
85670: EQUAL
85671: AND
85672: IFFALSE 85693
// MinerDetonateMine ( unit , x , y ) ;
85674: LD_VAR 0 2
85678: PPUSH
85679: LD_VAR 0 4
85683: PPUSH
85684: LD_VAR 0 5
85688: PPUSH
85689: CALL 88273 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
85693: LD_VAR 0 1
85697: PUSH
85698: LD_INT 252
85700: EQUAL
85701: PUSH
85702: LD_VAR 0 2
85706: PPUSH
85707: CALL_OW 264
85711: PUSH
85712: LD_EXP 74
85716: EQUAL
85717: AND
85718: IFFALSE 85739
// MinerCreateMinefield ( unit , x , y ) ;
85720: LD_VAR 0 2
85724: PPUSH
85725: LD_VAR 0 4
85729: PPUSH
85730: LD_VAR 0 5
85734: PPUSH
85735: CALL 88690 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
85739: LD_VAR 0 1
85743: PUSH
85744: LD_INT 253
85746: EQUAL
85747: PUSH
85748: LD_VAR 0 2
85752: PPUSH
85753: CALL_OW 257
85757: PUSH
85758: LD_INT 5
85760: EQUAL
85761: AND
85762: IFFALSE 85783
// ComBinocular ( unit , x , y ) ;
85764: LD_VAR 0 2
85768: PPUSH
85769: LD_VAR 0 4
85773: PPUSH
85774: LD_VAR 0 5
85778: PPUSH
85779: CALL 89061 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
85783: LD_VAR 0 1
85787: PUSH
85788: LD_INT 254
85790: EQUAL
85791: PUSH
85792: LD_VAR 0 2
85796: PPUSH
85797: CALL_OW 264
85801: PUSH
85802: LD_EXP 69
85806: EQUAL
85807: AND
85808: PUSH
85809: LD_VAR 0 3
85813: PPUSH
85814: CALL_OW 263
85818: PUSH
85819: LD_INT 3
85821: EQUAL
85822: AND
85823: IFFALSE 85839
// HackDestroyVehicle ( unit , selectedUnit ) ;
85825: LD_VAR 0 2
85829: PPUSH
85830: LD_VAR 0 3
85834: PPUSH
85835: CALL 87356 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
85839: LD_VAR 0 1
85843: PUSH
85844: LD_INT 255
85846: EQUAL
85847: PUSH
85848: LD_VAR 0 2
85852: PPUSH
85853: CALL_OW 264
85857: PUSH
85858: LD_INT 14
85860: PUSH
85861: LD_INT 53
85863: PUSH
85864: EMPTY
85865: LIST
85866: LIST
85867: IN
85868: AND
85869: PUSH
85870: LD_VAR 0 4
85874: PPUSH
85875: LD_VAR 0 5
85879: PPUSH
85880: CALL_OW 488
85884: AND
85885: IFFALSE 85909
// CutTreeXYR ( unit , x , y , 12 ) ;
85887: LD_VAR 0 2
85891: PPUSH
85892: LD_VAR 0 4
85896: PPUSH
85897: LD_VAR 0 5
85901: PPUSH
85902: LD_INT 12
85904: PPUSH
85905: CALL 85922 0 4
// end ;
85909: LD_VAR 0 6
85913: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
85914: LD_INT 0
85916: PPUSH
// end ;
85917: LD_VAR 0 4
85921: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
85922: LD_INT 0
85924: PPUSH
85925: PPUSH
85926: PPUSH
85927: PPUSH
85928: PPUSH
85929: PPUSH
85930: PPUSH
85931: PPUSH
85932: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
85933: LD_VAR 0 1
85937: NOT
85938: PUSH
85939: LD_VAR 0 2
85943: PPUSH
85944: LD_VAR 0 3
85948: PPUSH
85949: CALL_OW 488
85953: NOT
85954: OR
85955: PUSH
85956: LD_VAR 0 4
85960: NOT
85961: OR
85962: IFFALSE 85966
// exit ;
85964: GO 86306
// list := [ ] ;
85966: LD_ADDR_VAR 0 13
85970: PUSH
85971: EMPTY
85972: ST_TO_ADDR
// if x - r < 0 then
85973: LD_VAR 0 2
85977: PUSH
85978: LD_VAR 0 4
85982: MINUS
85983: PUSH
85984: LD_INT 0
85986: LESS
85987: IFFALSE 85999
// min_x := 0 else
85989: LD_ADDR_VAR 0 7
85993: PUSH
85994: LD_INT 0
85996: ST_TO_ADDR
85997: GO 86015
// min_x := x - r ;
85999: LD_ADDR_VAR 0 7
86003: PUSH
86004: LD_VAR 0 2
86008: PUSH
86009: LD_VAR 0 4
86013: MINUS
86014: ST_TO_ADDR
// if y - r < 0 then
86015: LD_VAR 0 3
86019: PUSH
86020: LD_VAR 0 4
86024: MINUS
86025: PUSH
86026: LD_INT 0
86028: LESS
86029: IFFALSE 86041
// min_y := 0 else
86031: LD_ADDR_VAR 0 8
86035: PUSH
86036: LD_INT 0
86038: ST_TO_ADDR
86039: GO 86057
// min_y := y - r ;
86041: LD_ADDR_VAR 0 8
86045: PUSH
86046: LD_VAR 0 3
86050: PUSH
86051: LD_VAR 0 4
86055: MINUS
86056: ST_TO_ADDR
// max_x := x + r ;
86057: LD_ADDR_VAR 0 9
86061: PUSH
86062: LD_VAR 0 2
86066: PUSH
86067: LD_VAR 0 4
86071: PLUS
86072: ST_TO_ADDR
// max_y := y + r ;
86073: LD_ADDR_VAR 0 10
86077: PUSH
86078: LD_VAR 0 3
86082: PUSH
86083: LD_VAR 0 4
86087: PLUS
86088: ST_TO_ADDR
// for _x = min_x to max_x do
86089: LD_ADDR_VAR 0 11
86093: PUSH
86094: DOUBLE
86095: LD_VAR 0 7
86099: DEC
86100: ST_TO_ADDR
86101: LD_VAR 0 9
86105: PUSH
86106: FOR_TO
86107: IFFALSE 86224
// for _y = min_y to max_y do
86109: LD_ADDR_VAR 0 12
86113: PUSH
86114: DOUBLE
86115: LD_VAR 0 8
86119: DEC
86120: ST_TO_ADDR
86121: LD_VAR 0 10
86125: PUSH
86126: FOR_TO
86127: IFFALSE 86220
// begin if not ValidHex ( _x , _y ) then
86129: LD_VAR 0 11
86133: PPUSH
86134: LD_VAR 0 12
86138: PPUSH
86139: CALL_OW 488
86143: NOT
86144: IFFALSE 86148
// continue ;
86146: GO 86126
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
86148: LD_VAR 0 11
86152: PPUSH
86153: LD_VAR 0 12
86157: PPUSH
86158: CALL_OW 351
86162: PUSH
86163: LD_VAR 0 11
86167: PPUSH
86168: LD_VAR 0 12
86172: PPUSH
86173: CALL_OW 554
86177: AND
86178: IFFALSE 86218
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
86180: LD_ADDR_VAR 0 13
86184: PUSH
86185: LD_VAR 0 13
86189: PPUSH
86190: LD_VAR 0 13
86194: PUSH
86195: LD_INT 1
86197: PLUS
86198: PPUSH
86199: LD_VAR 0 11
86203: PUSH
86204: LD_VAR 0 12
86208: PUSH
86209: EMPTY
86210: LIST
86211: LIST
86212: PPUSH
86213: CALL_OW 2
86217: ST_TO_ADDR
// end ;
86218: GO 86126
86220: POP
86221: POP
86222: GO 86106
86224: POP
86225: POP
// if not list then
86226: LD_VAR 0 13
86230: NOT
86231: IFFALSE 86235
// exit ;
86233: GO 86306
// for i in list do
86235: LD_ADDR_VAR 0 6
86239: PUSH
86240: LD_VAR 0 13
86244: PUSH
86245: FOR_IN
86246: IFFALSE 86304
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
86248: LD_VAR 0 1
86252: PPUSH
86253: LD_STRING M
86255: PUSH
86256: LD_VAR 0 6
86260: PUSH
86261: LD_INT 1
86263: ARRAY
86264: PUSH
86265: LD_VAR 0 6
86269: PUSH
86270: LD_INT 2
86272: ARRAY
86273: PUSH
86274: LD_INT 0
86276: PUSH
86277: LD_INT 0
86279: PUSH
86280: LD_INT 0
86282: PUSH
86283: LD_INT 0
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: LIST
86290: LIST
86291: LIST
86292: LIST
86293: LIST
86294: PUSH
86295: EMPTY
86296: LIST
86297: PPUSH
86298: CALL_OW 447
86302: GO 86245
86304: POP
86305: POP
// end ;
86306: LD_VAR 0 5
86310: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
86311: LD_EXP 88
86315: NOT
86316: IFFALSE 86366
86318: GO 86320
86320: DISABLE
// begin initHack := true ;
86321: LD_ADDR_EXP 88
86325: PUSH
86326: LD_INT 1
86328: ST_TO_ADDR
// hackTanks := [ ] ;
86329: LD_ADDR_EXP 89
86333: PUSH
86334: EMPTY
86335: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
86336: LD_ADDR_EXP 90
86340: PUSH
86341: EMPTY
86342: ST_TO_ADDR
// hackLimit := 3 ;
86343: LD_ADDR_EXP 91
86347: PUSH
86348: LD_INT 3
86350: ST_TO_ADDR
// hackDist := 12 ;
86351: LD_ADDR_EXP 92
86355: PUSH
86356: LD_INT 12
86358: ST_TO_ADDR
// hackCounter := [ ] ;
86359: LD_ADDR_EXP 93
86363: PUSH
86364: EMPTY
86365: ST_TO_ADDR
// end ;
86366: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
86367: LD_EXP 88
86371: PUSH
86372: LD_INT 34
86374: PUSH
86375: LD_EXP 69
86379: PUSH
86380: EMPTY
86381: LIST
86382: LIST
86383: PPUSH
86384: CALL_OW 69
86388: AND
86389: IFFALSE 86644
86391: GO 86393
86393: DISABLE
86394: LD_INT 0
86396: PPUSH
86397: PPUSH
// begin enable ;
86398: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
86399: LD_ADDR_VAR 0 1
86403: PUSH
86404: LD_INT 34
86406: PUSH
86407: LD_EXP 69
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PPUSH
86416: CALL_OW 69
86420: PUSH
86421: FOR_IN
86422: IFFALSE 86642
// begin if not i in hackTanks then
86424: LD_VAR 0 1
86428: PUSH
86429: LD_EXP 89
86433: IN
86434: NOT
86435: IFFALSE 86518
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
86437: LD_ADDR_EXP 89
86441: PUSH
86442: LD_EXP 89
86446: PPUSH
86447: LD_EXP 89
86451: PUSH
86452: LD_INT 1
86454: PLUS
86455: PPUSH
86456: LD_VAR 0 1
86460: PPUSH
86461: CALL_OW 1
86465: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
86466: LD_ADDR_EXP 90
86470: PUSH
86471: LD_EXP 90
86475: PPUSH
86476: LD_EXP 90
86480: PUSH
86481: LD_INT 1
86483: PLUS
86484: PPUSH
86485: EMPTY
86486: PPUSH
86487: CALL_OW 1
86491: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
86492: LD_ADDR_EXP 93
86496: PUSH
86497: LD_EXP 93
86501: PPUSH
86502: LD_EXP 93
86506: PUSH
86507: LD_INT 1
86509: PLUS
86510: PPUSH
86511: EMPTY
86512: PPUSH
86513: CALL_OW 1
86517: ST_TO_ADDR
// end ; if not IsOk ( i ) then
86518: LD_VAR 0 1
86522: PPUSH
86523: CALL_OW 302
86527: NOT
86528: IFFALSE 86541
// begin HackUnlinkAll ( i ) ;
86530: LD_VAR 0 1
86534: PPUSH
86535: CALL 86647 0 1
// continue ;
86539: GO 86421
// end ; HackCheckCapturedStatus ( i ) ;
86541: LD_VAR 0 1
86545: PPUSH
86546: CALL 87090 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
86550: LD_ADDR_VAR 0 2
86554: PUSH
86555: LD_INT 81
86557: PUSH
86558: LD_VAR 0 1
86562: PPUSH
86563: CALL_OW 255
86567: PUSH
86568: EMPTY
86569: LIST
86570: LIST
86571: PUSH
86572: LD_INT 33
86574: PUSH
86575: LD_INT 3
86577: PUSH
86578: EMPTY
86579: LIST
86580: LIST
86581: PUSH
86582: LD_INT 91
86584: PUSH
86585: LD_VAR 0 1
86589: PUSH
86590: LD_EXP 92
86594: PUSH
86595: EMPTY
86596: LIST
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 50
86602: PUSH
86603: EMPTY
86604: LIST
86605: PUSH
86606: EMPTY
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: PPUSH
86612: CALL_OW 69
86616: ST_TO_ADDR
// if not tmp then
86617: LD_VAR 0 2
86621: NOT
86622: IFFALSE 86626
// continue ;
86624: GO 86421
// HackLink ( i , tmp ) ;
86626: LD_VAR 0 1
86630: PPUSH
86631: LD_VAR 0 2
86635: PPUSH
86636: CALL 86783 0 2
// end ;
86640: GO 86421
86642: POP
86643: POP
// end ;
86644: PPOPN 2
86646: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
86647: LD_INT 0
86649: PPUSH
86650: PPUSH
86651: PPUSH
// if not hack in hackTanks then
86652: LD_VAR 0 1
86656: PUSH
86657: LD_EXP 89
86661: IN
86662: NOT
86663: IFFALSE 86667
// exit ;
86665: GO 86778
// index := GetElementIndex ( hackTanks , hack ) ;
86667: LD_ADDR_VAR 0 4
86671: PUSH
86672: LD_EXP 89
86676: PPUSH
86677: LD_VAR 0 1
86681: PPUSH
86682: CALL 13845 0 2
86686: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
86687: LD_EXP 90
86691: PUSH
86692: LD_VAR 0 4
86696: ARRAY
86697: IFFALSE 86778
// begin for i in hackTanksCaptured [ index ] do
86699: LD_ADDR_VAR 0 3
86703: PUSH
86704: LD_EXP 90
86708: PUSH
86709: LD_VAR 0 4
86713: ARRAY
86714: PUSH
86715: FOR_IN
86716: IFFALSE 86742
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
86718: LD_VAR 0 3
86722: PUSH
86723: LD_INT 1
86725: ARRAY
86726: PPUSH
86727: LD_VAR 0 3
86731: PUSH
86732: LD_INT 2
86734: ARRAY
86735: PPUSH
86736: CALL_OW 235
86740: GO 86715
86742: POP
86743: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
86744: LD_ADDR_EXP 90
86748: PUSH
86749: LD_EXP 90
86753: PPUSH
86754: LD_VAR 0 4
86758: PPUSH
86759: EMPTY
86760: PPUSH
86761: CALL_OW 1
86765: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
86766: LD_VAR 0 1
86770: PPUSH
86771: LD_INT 0
86773: PPUSH
86774: CALL_OW 505
// end ; end ;
86778: LD_VAR 0 2
86782: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
86783: LD_INT 0
86785: PPUSH
86786: PPUSH
86787: PPUSH
// if not hack in hackTanks or not vehicles then
86788: LD_VAR 0 1
86792: PUSH
86793: LD_EXP 89
86797: IN
86798: NOT
86799: PUSH
86800: LD_VAR 0 2
86804: NOT
86805: OR
86806: IFFALSE 86810
// exit ;
86808: GO 87085
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
86810: LD_ADDR_VAR 0 2
86814: PUSH
86815: LD_VAR 0 1
86819: PPUSH
86820: LD_VAR 0 2
86824: PPUSH
86825: LD_INT 1
86827: PPUSH
86828: LD_INT 1
86830: PPUSH
86831: CALL 14495 0 4
86835: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
86836: LD_ADDR_VAR 0 5
86840: PUSH
86841: LD_EXP 89
86845: PPUSH
86846: LD_VAR 0 1
86850: PPUSH
86851: CALL 13845 0 2
86855: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
86856: LD_EXP 90
86860: PUSH
86861: LD_VAR 0 5
86865: ARRAY
86866: PUSH
86867: LD_EXP 91
86871: LESS
86872: IFFALSE 87061
// begin for i := 1 to vehicles do
86874: LD_ADDR_VAR 0 4
86878: PUSH
86879: DOUBLE
86880: LD_INT 1
86882: DEC
86883: ST_TO_ADDR
86884: LD_VAR 0 2
86888: PUSH
86889: FOR_TO
86890: IFFALSE 87059
// begin if hackTanksCaptured [ index ] = hackLimit then
86892: LD_EXP 90
86896: PUSH
86897: LD_VAR 0 5
86901: ARRAY
86902: PUSH
86903: LD_EXP 91
86907: EQUAL
86908: IFFALSE 86912
// break ;
86910: GO 87059
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
86912: LD_ADDR_EXP 93
86916: PUSH
86917: LD_EXP 93
86921: PPUSH
86922: LD_VAR 0 5
86926: PPUSH
86927: LD_EXP 93
86931: PUSH
86932: LD_VAR 0 5
86936: ARRAY
86937: PUSH
86938: LD_INT 1
86940: PLUS
86941: PPUSH
86942: CALL_OW 1
86946: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
86947: LD_ADDR_EXP 90
86951: PUSH
86952: LD_EXP 90
86956: PPUSH
86957: LD_VAR 0 5
86961: PUSH
86962: LD_EXP 90
86966: PUSH
86967: LD_VAR 0 5
86971: ARRAY
86972: PUSH
86973: LD_INT 1
86975: PLUS
86976: PUSH
86977: EMPTY
86978: LIST
86979: LIST
86980: PPUSH
86981: LD_VAR 0 2
86985: PUSH
86986: LD_VAR 0 4
86990: ARRAY
86991: PUSH
86992: LD_VAR 0 2
86996: PUSH
86997: LD_VAR 0 4
87001: ARRAY
87002: PPUSH
87003: CALL_OW 255
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PPUSH
87012: CALL 14060 0 3
87016: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
87017: LD_VAR 0 2
87021: PUSH
87022: LD_VAR 0 4
87026: ARRAY
87027: PPUSH
87028: LD_VAR 0 1
87032: PPUSH
87033: CALL_OW 255
87037: PPUSH
87038: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
87042: LD_VAR 0 2
87046: PUSH
87047: LD_VAR 0 4
87051: ARRAY
87052: PPUSH
87053: CALL_OW 141
// end ;
87057: GO 86889
87059: POP
87060: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
87061: LD_VAR 0 1
87065: PPUSH
87066: LD_EXP 90
87070: PUSH
87071: LD_VAR 0 5
87075: ARRAY
87076: PUSH
87077: LD_INT 0
87079: PLUS
87080: PPUSH
87081: CALL_OW 505
// end ;
87085: LD_VAR 0 3
87089: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
87090: LD_INT 0
87092: PPUSH
87093: PPUSH
87094: PPUSH
87095: PPUSH
// if not hack in hackTanks then
87096: LD_VAR 0 1
87100: PUSH
87101: LD_EXP 89
87105: IN
87106: NOT
87107: IFFALSE 87111
// exit ;
87109: GO 87351
// index := GetElementIndex ( hackTanks , hack ) ;
87111: LD_ADDR_VAR 0 4
87115: PUSH
87116: LD_EXP 89
87120: PPUSH
87121: LD_VAR 0 1
87125: PPUSH
87126: CALL 13845 0 2
87130: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
87131: LD_ADDR_VAR 0 3
87135: PUSH
87136: DOUBLE
87137: LD_EXP 90
87141: PUSH
87142: LD_VAR 0 4
87146: ARRAY
87147: INC
87148: ST_TO_ADDR
87149: LD_INT 1
87151: PUSH
87152: FOR_DOWNTO
87153: IFFALSE 87325
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
87155: LD_ADDR_VAR 0 5
87159: PUSH
87160: LD_EXP 90
87164: PUSH
87165: LD_VAR 0 4
87169: ARRAY
87170: PUSH
87171: LD_VAR 0 3
87175: ARRAY
87176: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
87177: LD_VAR 0 5
87181: PUSH
87182: LD_INT 1
87184: ARRAY
87185: PPUSH
87186: CALL_OW 302
87190: NOT
87191: PUSH
87192: LD_VAR 0 5
87196: PUSH
87197: LD_INT 1
87199: ARRAY
87200: PPUSH
87201: CALL_OW 255
87205: PUSH
87206: LD_VAR 0 1
87210: PPUSH
87211: CALL_OW 255
87215: NONEQUAL
87216: OR
87217: IFFALSE 87323
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
87219: LD_VAR 0 5
87223: PUSH
87224: LD_INT 1
87226: ARRAY
87227: PPUSH
87228: CALL_OW 305
87232: PUSH
87233: LD_VAR 0 5
87237: PUSH
87238: LD_INT 1
87240: ARRAY
87241: PPUSH
87242: CALL_OW 255
87246: PUSH
87247: LD_VAR 0 1
87251: PPUSH
87252: CALL_OW 255
87256: EQUAL
87257: AND
87258: IFFALSE 87282
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
87260: LD_VAR 0 5
87264: PUSH
87265: LD_INT 1
87267: ARRAY
87268: PPUSH
87269: LD_VAR 0 5
87273: PUSH
87274: LD_INT 2
87276: ARRAY
87277: PPUSH
87278: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
87282: LD_ADDR_EXP 90
87286: PUSH
87287: LD_EXP 90
87291: PPUSH
87292: LD_VAR 0 4
87296: PPUSH
87297: LD_EXP 90
87301: PUSH
87302: LD_VAR 0 4
87306: ARRAY
87307: PPUSH
87308: LD_VAR 0 3
87312: PPUSH
87313: CALL_OW 3
87317: PPUSH
87318: CALL_OW 1
87322: ST_TO_ADDR
// end ; end ;
87323: GO 87152
87325: POP
87326: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
87327: LD_VAR 0 1
87331: PPUSH
87332: LD_EXP 90
87336: PUSH
87337: LD_VAR 0 4
87341: ARRAY
87342: PUSH
87343: LD_INT 0
87345: PLUS
87346: PPUSH
87347: CALL_OW 505
// end ;
87351: LD_VAR 0 2
87355: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
87356: LD_INT 0
87358: PPUSH
87359: PPUSH
87360: PPUSH
87361: PPUSH
// if not hack in hackTanks then
87362: LD_VAR 0 1
87366: PUSH
87367: LD_EXP 89
87371: IN
87372: NOT
87373: IFFALSE 87377
// exit ;
87375: GO 87462
// index := GetElementIndex ( hackTanks , hack ) ;
87377: LD_ADDR_VAR 0 5
87381: PUSH
87382: LD_EXP 89
87386: PPUSH
87387: LD_VAR 0 1
87391: PPUSH
87392: CALL 13845 0 2
87396: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
87397: LD_ADDR_VAR 0 4
87401: PUSH
87402: DOUBLE
87403: LD_INT 1
87405: DEC
87406: ST_TO_ADDR
87407: LD_EXP 90
87411: PUSH
87412: LD_VAR 0 5
87416: ARRAY
87417: PUSH
87418: FOR_TO
87419: IFFALSE 87460
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
87421: LD_EXP 90
87425: PUSH
87426: LD_VAR 0 5
87430: ARRAY
87431: PUSH
87432: LD_VAR 0 4
87436: ARRAY
87437: PUSH
87438: LD_INT 1
87440: ARRAY
87441: PUSH
87442: LD_VAR 0 2
87446: EQUAL
87447: IFFALSE 87458
// KillUnit ( vehicle ) ;
87449: LD_VAR 0 2
87453: PPUSH
87454: CALL_OW 66
87458: GO 87418
87460: POP
87461: POP
// end ;
87462: LD_VAR 0 3
87466: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
87467: LD_EXP 94
87471: NOT
87472: IFFALSE 87507
87474: GO 87476
87476: DISABLE
// begin initMiner := true ;
87477: LD_ADDR_EXP 94
87481: PUSH
87482: LD_INT 1
87484: ST_TO_ADDR
// minersList := [ ] ;
87485: LD_ADDR_EXP 95
87489: PUSH
87490: EMPTY
87491: ST_TO_ADDR
// minerMinesList := [ ] ;
87492: LD_ADDR_EXP 96
87496: PUSH
87497: EMPTY
87498: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
87499: LD_ADDR_EXP 97
87503: PUSH
87504: LD_INT 5
87506: ST_TO_ADDR
// end ;
87507: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
87508: LD_EXP 94
87512: PUSH
87513: LD_INT 34
87515: PUSH
87516: LD_EXP 74
87520: PUSH
87521: EMPTY
87522: LIST
87523: LIST
87524: PPUSH
87525: CALL_OW 69
87529: AND
87530: IFFALSE 87993
87532: GO 87534
87534: DISABLE
87535: LD_INT 0
87537: PPUSH
87538: PPUSH
87539: PPUSH
87540: PPUSH
// begin enable ;
87541: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
87542: LD_ADDR_VAR 0 1
87546: PUSH
87547: LD_INT 34
87549: PUSH
87550: LD_EXP 74
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PPUSH
87559: CALL_OW 69
87563: PUSH
87564: FOR_IN
87565: IFFALSE 87637
// begin if not i in minersList then
87567: LD_VAR 0 1
87571: PUSH
87572: LD_EXP 95
87576: IN
87577: NOT
87578: IFFALSE 87635
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
87580: LD_ADDR_EXP 95
87584: PUSH
87585: LD_EXP 95
87589: PPUSH
87590: LD_EXP 95
87594: PUSH
87595: LD_INT 1
87597: PLUS
87598: PPUSH
87599: LD_VAR 0 1
87603: PPUSH
87604: CALL_OW 1
87608: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
87609: LD_ADDR_EXP 96
87613: PUSH
87614: LD_EXP 96
87618: PPUSH
87619: LD_EXP 96
87623: PUSH
87624: LD_INT 1
87626: PLUS
87627: PPUSH
87628: EMPTY
87629: PPUSH
87630: CALL_OW 1
87634: ST_TO_ADDR
// end end ;
87635: GO 87564
87637: POP
87638: POP
// for i := minerMinesList downto 1 do
87639: LD_ADDR_VAR 0 1
87643: PUSH
87644: DOUBLE
87645: LD_EXP 96
87649: INC
87650: ST_TO_ADDR
87651: LD_INT 1
87653: PUSH
87654: FOR_DOWNTO
87655: IFFALSE 87991
// begin if IsLive ( minersList [ i ] ) then
87657: LD_EXP 95
87661: PUSH
87662: LD_VAR 0 1
87666: ARRAY
87667: PPUSH
87668: CALL_OW 300
87672: IFFALSE 87700
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
87674: LD_EXP 95
87678: PUSH
87679: LD_VAR 0 1
87683: ARRAY
87684: PPUSH
87685: LD_EXP 96
87689: PUSH
87690: LD_VAR 0 1
87694: ARRAY
87695: PPUSH
87696: CALL_OW 505
// if not minerMinesList [ i ] then
87700: LD_EXP 96
87704: PUSH
87705: LD_VAR 0 1
87709: ARRAY
87710: NOT
87711: IFFALSE 87715
// continue ;
87713: GO 87654
// for j := minerMinesList [ i ] downto 1 do
87715: LD_ADDR_VAR 0 2
87719: PUSH
87720: DOUBLE
87721: LD_EXP 96
87725: PUSH
87726: LD_VAR 0 1
87730: ARRAY
87731: INC
87732: ST_TO_ADDR
87733: LD_INT 1
87735: PUSH
87736: FOR_DOWNTO
87737: IFFALSE 87987
// begin side := GetSide ( minersList [ i ] ) ;
87739: LD_ADDR_VAR 0 3
87743: PUSH
87744: LD_EXP 95
87748: PUSH
87749: LD_VAR 0 1
87753: ARRAY
87754: PPUSH
87755: CALL_OW 255
87759: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
87760: LD_ADDR_VAR 0 4
87764: PUSH
87765: LD_EXP 96
87769: PUSH
87770: LD_VAR 0 1
87774: ARRAY
87775: PUSH
87776: LD_VAR 0 2
87780: ARRAY
87781: PUSH
87782: LD_INT 1
87784: ARRAY
87785: PPUSH
87786: LD_EXP 96
87790: PUSH
87791: LD_VAR 0 1
87795: ARRAY
87796: PUSH
87797: LD_VAR 0 2
87801: ARRAY
87802: PUSH
87803: LD_INT 2
87805: ARRAY
87806: PPUSH
87807: CALL_OW 428
87811: ST_TO_ADDR
// if not tmp then
87812: LD_VAR 0 4
87816: NOT
87817: IFFALSE 87821
// continue ;
87819: GO 87736
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
87821: LD_VAR 0 4
87825: PUSH
87826: LD_INT 81
87828: PUSH
87829: LD_VAR 0 3
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PPUSH
87838: CALL_OW 69
87842: IN
87843: PUSH
87844: LD_EXP 96
87848: PUSH
87849: LD_VAR 0 1
87853: ARRAY
87854: PUSH
87855: LD_VAR 0 2
87859: ARRAY
87860: PUSH
87861: LD_INT 1
87863: ARRAY
87864: PPUSH
87865: LD_EXP 96
87869: PUSH
87870: LD_VAR 0 1
87874: ARRAY
87875: PUSH
87876: LD_VAR 0 2
87880: ARRAY
87881: PUSH
87882: LD_INT 2
87884: ARRAY
87885: PPUSH
87886: CALL_OW 458
87890: AND
87891: IFFALSE 87985
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
87893: LD_EXP 96
87897: PUSH
87898: LD_VAR 0 1
87902: ARRAY
87903: PUSH
87904: LD_VAR 0 2
87908: ARRAY
87909: PUSH
87910: LD_INT 1
87912: ARRAY
87913: PPUSH
87914: LD_EXP 96
87918: PUSH
87919: LD_VAR 0 1
87923: ARRAY
87924: PUSH
87925: LD_VAR 0 2
87929: ARRAY
87930: PUSH
87931: LD_INT 2
87933: ARRAY
87934: PPUSH
87935: LD_VAR 0 3
87939: PPUSH
87940: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
87944: LD_ADDR_EXP 96
87948: PUSH
87949: LD_EXP 96
87953: PPUSH
87954: LD_VAR 0 1
87958: PPUSH
87959: LD_EXP 96
87963: PUSH
87964: LD_VAR 0 1
87968: ARRAY
87969: PPUSH
87970: LD_VAR 0 2
87974: PPUSH
87975: CALL_OW 3
87979: PPUSH
87980: CALL_OW 1
87984: ST_TO_ADDR
// end ; end ;
87985: GO 87736
87987: POP
87988: POP
// end ;
87989: GO 87654
87991: POP
87992: POP
// end ;
87993: PPOPN 4
87995: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
87996: LD_INT 0
87998: PPUSH
87999: PPUSH
// result := false ;
88000: LD_ADDR_VAR 0 4
88004: PUSH
88005: LD_INT 0
88007: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
88008: LD_VAR 0 1
88012: PPUSH
88013: CALL_OW 264
88017: PUSH
88018: LD_EXP 74
88022: EQUAL
88023: NOT
88024: IFFALSE 88028
// exit ;
88026: GO 88268
// index := GetElementIndex ( minersList , unit ) ;
88028: LD_ADDR_VAR 0 5
88032: PUSH
88033: LD_EXP 95
88037: PPUSH
88038: LD_VAR 0 1
88042: PPUSH
88043: CALL 13845 0 2
88047: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
88048: LD_EXP 96
88052: PUSH
88053: LD_VAR 0 5
88057: ARRAY
88058: PUSH
88059: LD_EXP 97
88063: GREATEREQUAL
88064: IFFALSE 88068
// exit ;
88066: GO 88268
// ComMoveXY ( unit , x , y ) ;
88068: LD_VAR 0 1
88072: PPUSH
88073: LD_VAR 0 2
88077: PPUSH
88078: LD_VAR 0 3
88082: PPUSH
88083: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
88087: LD_INT 35
88089: PPUSH
88090: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
88094: LD_VAR 0 1
88098: PPUSH
88099: LD_VAR 0 2
88103: PPUSH
88104: LD_VAR 0 3
88108: PPUSH
88109: CALL 44618 0 3
88113: NOT
88114: PUSH
88115: LD_VAR 0 1
88119: PPUSH
88120: CALL_OW 314
88124: AND
88125: IFFALSE 88129
// exit ;
88127: GO 88268
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
88129: LD_VAR 0 2
88133: PPUSH
88134: LD_VAR 0 3
88138: PPUSH
88139: CALL_OW 428
88143: PUSH
88144: LD_VAR 0 1
88148: EQUAL
88149: PUSH
88150: LD_VAR 0 1
88154: PPUSH
88155: CALL_OW 314
88159: NOT
88160: AND
88161: IFFALSE 88087
// PlaySoundXY ( x , y , PlantMine ) ;
88163: LD_VAR 0 2
88167: PPUSH
88168: LD_VAR 0 3
88172: PPUSH
88173: LD_STRING PlantMine
88175: PPUSH
88176: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
88180: LD_VAR 0 2
88184: PPUSH
88185: LD_VAR 0 3
88189: PPUSH
88190: LD_VAR 0 1
88194: PPUSH
88195: CALL_OW 255
88199: PPUSH
88200: LD_INT 0
88202: PPUSH
88203: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
88207: LD_ADDR_EXP 96
88211: PUSH
88212: LD_EXP 96
88216: PPUSH
88217: LD_VAR 0 5
88221: PUSH
88222: LD_EXP 96
88226: PUSH
88227: LD_VAR 0 5
88231: ARRAY
88232: PUSH
88233: LD_INT 1
88235: PLUS
88236: PUSH
88237: EMPTY
88238: LIST
88239: LIST
88240: PPUSH
88241: LD_VAR 0 2
88245: PUSH
88246: LD_VAR 0 3
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PPUSH
88255: CALL 14060 0 3
88259: ST_TO_ADDR
// result := true ;
88260: LD_ADDR_VAR 0 4
88264: PUSH
88265: LD_INT 1
88267: ST_TO_ADDR
// end ;
88268: LD_VAR 0 4
88272: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
88273: LD_INT 0
88275: PPUSH
88276: PPUSH
88277: PPUSH
// if not unit in minersList then
88278: LD_VAR 0 1
88282: PUSH
88283: LD_EXP 95
88287: IN
88288: NOT
88289: IFFALSE 88293
// exit ;
88291: GO 88685
// index := GetElementIndex ( minersList , unit ) ;
88293: LD_ADDR_VAR 0 6
88297: PUSH
88298: LD_EXP 95
88302: PPUSH
88303: LD_VAR 0 1
88307: PPUSH
88308: CALL 13845 0 2
88312: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
88313: LD_ADDR_VAR 0 5
88317: PUSH
88318: DOUBLE
88319: LD_EXP 96
88323: PUSH
88324: LD_VAR 0 6
88328: ARRAY
88329: INC
88330: ST_TO_ADDR
88331: LD_INT 1
88333: PUSH
88334: FOR_DOWNTO
88335: IFFALSE 88496
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
88337: LD_EXP 96
88341: PUSH
88342: LD_VAR 0 6
88346: ARRAY
88347: PUSH
88348: LD_VAR 0 5
88352: ARRAY
88353: PUSH
88354: LD_INT 1
88356: ARRAY
88357: PUSH
88358: LD_VAR 0 2
88362: EQUAL
88363: PUSH
88364: LD_EXP 96
88368: PUSH
88369: LD_VAR 0 6
88373: ARRAY
88374: PUSH
88375: LD_VAR 0 5
88379: ARRAY
88380: PUSH
88381: LD_INT 2
88383: ARRAY
88384: PUSH
88385: LD_VAR 0 3
88389: EQUAL
88390: AND
88391: IFFALSE 88494
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
88393: LD_EXP 96
88397: PUSH
88398: LD_VAR 0 6
88402: ARRAY
88403: PUSH
88404: LD_VAR 0 5
88408: ARRAY
88409: PUSH
88410: LD_INT 1
88412: ARRAY
88413: PPUSH
88414: LD_EXP 96
88418: PUSH
88419: LD_VAR 0 6
88423: ARRAY
88424: PUSH
88425: LD_VAR 0 5
88429: ARRAY
88430: PUSH
88431: LD_INT 2
88433: ARRAY
88434: PPUSH
88435: LD_VAR 0 1
88439: PPUSH
88440: CALL_OW 255
88444: PPUSH
88445: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
88449: LD_ADDR_EXP 96
88453: PUSH
88454: LD_EXP 96
88458: PPUSH
88459: LD_VAR 0 6
88463: PPUSH
88464: LD_EXP 96
88468: PUSH
88469: LD_VAR 0 6
88473: ARRAY
88474: PPUSH
88475: LD_VAR 0 5
88479: PPUSH
88480: CALL_OW 3
88484: PPUSH
88485: CALL_OW 1
88489: ST_TO_ADDR
// exit ;
88490: POP
88491: POP
88492: GO 88685
// end ; end ;
88494: GO 88334
88496: POP
88497: POP
// for i := minerMinesList [ index ] downto 1 do
88498: LD_ADDR_VAR 0 5
88502: PUSH
88503: DOUBLE
88504: LD_EXP 96
88508: PUSH
88509: LD_VAR 0 6
88513: ARRAY
88514: INC
88515: ST_TO_ADDR
88516: LD_INT 1
88518: PUSH
88519: FOR_DOWNTO
88520: IFFALSE 88683
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
88522: LD_EXP 96
88526: PUSH
88527: LD_VAR 0 6
88531: ARRAY
88532: PUSH
88533: LD_VAR 0 5
88537: ARRAY
88538: PUSH
88539: LD_INT 1
88541: ARRAY
88542: PPUSH
88543: LD_EXP 96
88547: PUSH
88548: LD_VAR 0 6
88552: ARRAY
88553: PUSH
88554: LD_VAR 0 5
88558: ARRAY
88559: PUSH
88560: LD_INT 2
88562: ARRAY
88563: PPUSH
88564: LD_VAR 0 2
88568: PPUSH
88569: LD_VAR 0 3
88573: PPUSH
88574: CALL_OW 298
88578: PUSH
88579: LD_INT 6
88581: LESS
88582: IFFALSE 88681
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
88584: LD_EXP 96
88588: PUSH
88589: LD_VAR 0 6
88593: ARRAY
88594: PUSH
88595: LD_VAR 0 5
88599: ARRAY
88600: PUSH
88601: LD_INT 1
88603: ARRAY
88604: PPUSH
88605: LD_EXP 96
88609: PUSH
88610: LD_VAR 0 6
88614: ARRAY
88615: PUSH
88616: LD_VAR 0 5
88620: ARRAY
88621: PUSH
88622: LD_INT 2
88624: ARRAY
88625: PPUSH
88626: LD_VAR 0 1
88630: PPUSH
88631: CALL_OW 255
88635: PPUSH
88636: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
88640: LD_ADDR_EXP 96
88644: PUSH
88645: LD_EXP 96
88649: PPUSH
88650: LD_VAR 0 6
88654: PPUSH
88655: LD_EXP 96
88659: PUSH
88660: LD_VAR 0 6
88664: ARRAY
88665: PPUSH
88666: LD_VAR 0 5
88670: PPUSH
88671: CALL_OW 3
88675: PPUSH
88676: CALL_OW 1
88680: ST_TO_ADDR
// end ; end ;
88681: GO 88519
88683: POP
88684: POP
// end ;
88685: LD_VAR 0 4
88689: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
88690: LD_INT 0
88692: PPUSH
88693: PPUSH
88694: PPUSH
88695: PPUSH
88696: PPUSH
88697: PPUSH
88698: PPUSH
88699: PPUSH
88700: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
88701: LD_VAR 0 1
88705: PPUSH
88706: CALL_OW 264
88710: PUSH
88711: LD_EXP 74
88715: EQUAL
88716: NOT
88717: PUSH
88718: LD_VAR 0 1
88722: PUSH
88723: LD_EXP 95
88727: IN
88728: NOT
88729: OR
88730: IFFALSE 88734
// exit ;
88732: GO 89056
// index := GetElementIndex ( minersList , unit ) ;
88734: LD_ADDR_VAR 0 6
88738: PUSH
88739: LD_EXP 95
88743: PPUSH
88744: LD_VAR 0 1
88748: PPUSH
88749: CALL 13845 0 2
88753: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
88754: LD_ADDR_VAR 0 8
88758: PUSH
88759: LD_EXP 97
88763: PUSH
88764: LD_EXP 96
88768: PUSH
88769: LD_VAR 0 6
88773: ARRAY
88774: MINUS
88775: ST_TO_ADDR
// if not minesFreeAmount then
88776: LD_VAR 0 8
88780: NOT
88781: IFFALSE 88785
// exit ;
88783: GO 89056
// tmp := [ ] ;
88785: LD_ADDR_VAR 0 7
88789: PUSH
88790: EMPTY
88791: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
88792: LD_ADDR_VAR 0 5
88796: PUSH
88797: DOUBLE
88798: LD_INT 1
88800: DEC
88801: ST_TO_ADDR
88802: LD_VAR 0 8
88806: PUSH
88807: FOR_TO
88808: IFFALSE 89003
// begin _d := rand ( 0 , 5 ) ;
88810: LD_ADDR_VAR 0 11
88814: PUSH
88815: LD_INT 0
88817: PPUSH
88818: LD_INT 5
88820: PPUSH
88821: CALL_OW 12
88825: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
88826: LD_ADDR_VAR 0 12
88830: PUSH
88831: LD_INT 2
88833: PPUSH
88834: LD_INT 6
88836: PPUSH
88837: CALL_OW 12
88841: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
88842: LD_ADDR_VAR 0 9
88846: PUSH
88847: LD_VAR 0 2
88851: PPUSH
88852: LD_VAR 0 11
88856: PPUSH
88857: LD_VAR 0 12
88861: PPUSH
88862: CALL_OW 272
88866: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
88867: LD_ADDR_VAR 0 10
88871: PUSH
88872: LD_VAR 0 3
88876: PPUSH
88877: LD_VAR 0 11
88881: PPUSH
88882: LD_VAR 0 12
88886: PPUSH
88887: CALL_OW 273
88891: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
88892: LD_VAR 0 9
88896: PPUSH
88897: LD_VAR 0 10
88901: PPUSH
88902: CALL_OW 488
88906: PUSH
88907: LD_VAR 0 9
88911: PUSH
88912: LD_VAR 0 10
88916: PUSH
88917: EMPTY
88918: LIST
88919: LIST
88920: PUSH
88921: LD_VAR 0 7
88925: IN
88926: NOT
88927: AND
88928: PUSH
88929: LD_VAR 0 9
88933: PPUSH
88934: LD_VAR 0 10
88938: PPUSH
88939: CALL_OW 458
88943: NOT
88944: AND
88945: IFFALSE 88987
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
88947: LD_ADDR_VAR 0 7
88951: PUSH
88952: LD_VAR 0 7
88956: PPUSH
88957: LD_VAR 0 7
88961: PUSH
88962: LD_INT 1
88964: PLUS
88965: PPUSH
88966: LD_VAR 0 9
88970: PUSH
88971: LD_VAR 0 10
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PPUSH
88980: CALL_OW 1
88984: ST_TO_ADDR
88985: GO 89001
// i := i - 1 ;
88987: LD_ADDR_VAR 0 5
88991: PUSH
88992: LD_VAR 0 5
88996: PUSH
88997: LD_INT 1
88999: MINUS
89000: ST_TO_ADDR
// end ;
89001: GO 88807
89003: POP
89004: POP
// for i in tmp do
89005: LD_ADDR_VAR 0 5
89009: PUSH
89010: LD_VAR 0 7
89014: PUSH
89015: FOR_IN
89016: IFFALSE 89054
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
89018: LD_VAR 0 1
89022: PPUSH
89023: LD_VAR 0 5
89027: PUSH
89028: LD_INT 1
89030: ARRAY
89031: PPUSH
89032: LD_VAR 0 5
89036: PUSH
89037: LD_INT 2
89039: ARRAY
89040: PPUSH
89041: CALL 87996 0 3
89045: NOT
89046: IFFALSE 89052
// exit ;
89048: POP
89049: POP
89050: GO 89056
89052: GO 89015
89054: POP
89055: POP
// end ;
89056: LD_VAR 0 4
89060: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
89061: LD_INT 0
89063: PPUSH
89064: PPUSH
89065: PPUSH
89066: PPUSH
89067: PPUSH
89068: PPUSH
89069: PPUSH
// if not GetClass ( unit ) = class_sniper then
89070: LD_VAR 0 1
89074: PPUSH
89075: CALL_OW 257
89079: PUSH
89080: LD_INT 5
89082: EQUAL
89083: NOT
89084: IFFALSE 89088
// exit ;
89086: GO 89476
// dist := 8 ;
89088: LD_ADDR_VAR 0 5
89092: PUSH
89093: LD_INT 8
89095: ST_TO_ADDR
// viewRange := 12 ;
89096: LD_ADDR_VAR 0 7
89100: PUSH
89101: LD_INT 12
89103: ST_TO_ADDR
// side := GetSide ( unit ) ;
89104: LD_ADDR_VAR 0 6
89108: PUSH
89109: LD_VAR 0 1
89113: PPUSH
89114: CALL_OW 255
89118: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
89119: LD_INT 61
89121: PPUSH
89122: LD_VAR 0 6
89126: PPUSH
89127: CALL_OW 321
89131: PUSH
89132: LD_INT 2
89134: EQUAL
89135: IFFALSE 89145
// viewRange := 16 ;
89137: LD_ADDR_VAR 0 7
89141: PUSH
89142: LD_INT 16
89144: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
89145: LD_VAR 0 1
89149: PPUSH
89150: LD_VAR 0 2
89154: PPUSH
89155: LD_VAR 0 3
89159: PPUSH
89160: CALL_OW 297
89164: PUSH
89165: LD_VAR 0 5
89169: GREATER
89170: IFFALSE 89249
// begin ComMoveXY ( unit , x , y ) ;
89172: LD_VAR 0 1
89176: PPUSH
89177: LD_VAR 0 2
89181: PPUSH
89182: LD_VAR 0 3
89186: PPUSH
89187: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
89191: LD_INT 35
89193: PPUSH
89194: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
89198: LD_VAR 0 1
89202: PPUSH
89203: LD_VAR 0 2
89207: PPUSH
89208: LD_VAR 0 3
89212: PPUSH
89213: CALL 44618 0 3
89217: NOT
89218: IFFALSE 89222
// exit ;
89220: GO 89476
// until GetDistUnitXY ( unit , x , y ) < dist ;
89222: LD_VAR 0 1
89226: PPUSH
89227: LD_VAR 0 2
89231: PPUSH
89232: LD_VAR 0 3
89236: PPUSH
89237: CALL_OW 297
89241: PUSH
89242: LD_VAR 0 5
89246: LESS
89247: IFFALSE 89191
// end ; ComTurnXY ( unit , x , y ) ;
89249: LD_VAR 0 1
89253: PPUSH
89254: LD_VAR 0 2
89258: PPUSH
89259: LD_VAR 0 3
89263: PPUSH
89264: CALL_OW 118
// wait ( 5 ) ;
89268: LD_INT 5
89270: PPUSH
89271: CALL_OW 67
// _d := GetDir ( unit ) ;
89275: LD_ADDR_VAR 0 10
89279: PUSH
89280: LD_VAR 0 1
89284: PPUSH
89285: CALL_OW 254
89289: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
89290: LD_ADDR_VAR 0 8
89294: PUSH
89295: LD_VAR 0 1
89299: PPUSH
89300: CALL_OW 250
89304: PPUSH
89305: LD_VAR 0 10
89309: PPUSH
89310: LD_VAR 0 5
89314: PPUSH
89315: CALL_OW 272
89319: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
89320: LD_ADDR_VAR 0 9
89324: PUSH
89325: LD_VAR 0 1
89329: PPUSH
89330: CALL_OW 251
89334: PPUSH
89335: LD_VAR 0 10
89339: PPUSH
89340: LD_VAR 0 5
89344: PPUSH
89345: CALL_OW 273
89349: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
89350: LD_VAR 0 8
89354: PPUSH
89355: LD_VAR 0 9
89359: PPUSH
89360: CALL_OW 488
89364: NOT
89365: IFFALSE 89369
// exit ;
89367: GO 89476
// ComAnimCustom ( unit , 1 ) ;
89369: LD_VAR 0 1
89373: PPUSH
89374: LD_INT 1
89376: PPUSH
89377: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
89381: LD_VAR 0 8
89385: PPUSH
89386: LD_VAR 0 9
89390: PPUSH
89391: LD_VAR 0 6
89395: PPUSH
89396: LD_VAR 0 7
89400: PPUSH
89401: CALL_OW 330
// repeat wait ( 1 ) ;
89405: LD_INT 1
89407: PPUSH
89408: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
89412: LD_VAR 0 1
89416: PPUSH
89417: CALL_OW 316
89421: PUSH
89422: LD_VAR 0 1
89426: PPUSH
89427: CALL_OW 314
89431: OR
89432: PUSH
89433: LD_VAR 0 1
89437: PPUSH
89438: CALL_OW 302
89442: NOT
89443: OR
89444: PUSH
89445: LD_VAR 0 1
89449: PPUSH
89450: CALL_OW 301
89454: OR
89455: IFFALSE 89405
// RemoveSeeing ( _x , _y , side ) ;
89457: LD_VAR 0 8
89461: PPUSH
89462: LD_VAR 0 9
89466: PPUSH
89467: LD_VAR 0 6
89471: PPUSH
89472: CALL_OW 331
// end ; end_of_file end_of_file
89476: LD_VAR 0 4
89480: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
89481: LD_VAR 0 1
89485: PUSH
89486: LD_INT 200
89488: DOUBLE
89489: GREATEREQUAL
89490: IFFALSE 89498
89492: LD_INT 299
89494: DOUBLE
89495: LESSEQUAL
89496: IFTRUE 89500
89498: GO 89532
89500: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
89501: LD_VAR 0 1
89505: PPUSH
89506: LD_VAR 0 2
89510: PPUSH
89511: LD_VAR 0 3
89515: PPUSH
89516: LD_VAR 0 4
89520: PPUSH
89521: LD_VAR 0 5
89525: PPUSH
89526: CALL 85598 0 5
89530: GO 89609
89532: LD_INT 300
89534: DOUBLE
89535: GREATEREQUAL
89536: IFFALSE 89544
89538: LD_INT 399
89540: DOUBLE
89541: LESSEQUAL
89542: IFTRUE 89546
89544: GO 89608
89546: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
89547: LD_VAR 0 1
89551: PPUSH
89552: LD_VAR 0 2
89556: PPUSH
89557: LD_VAR 0 3
89561: PPUSH
89562: LD_VAR 0 4
89566: PPUSH
89567: LD_VAR 0 5
89571: PPUSH
89572: LD_VAR 0 6
89576: PPUSH
89577: LD_VAR 0 7
89581: PPUSH
89582: LD_VAR 0 8
89586: PPUSH
89587: LD_VAR 0 9
89591: PPUSH
89592: LD_VAR 0 10
89596: PPUSH
89597: LD_VAR 0 11
89601: PPUSH
89602: CALL 100836 0 11
89606: GO 89609
89608: POP
// end ;
89609: PPOPN 11
89611: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
89612: LD_VAR 0 1
89616: PPUSH
89617: LD_VAR 0 2
89621: PPUSH
89622: LD_VAR 0 3
89626: PPUSH
89627: LD_VAR 0 4
89631: PPUSH
89632: LD_VAR 0 5
89636: PPUSH
89637: CALL 85580 0 5
// end ; end_of_file
89641: PPOPN 5
89643: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
89644: LD_INT 0
89646: PPUSH
// if p2 = 100 then
89647: LD_VAR 0 2
89651: PUSH
89652: LD_INT 100
89654: EQUAL
89655: IFFALSE 90604
// begin if not StreamModeActive then
89657: LD_EXP 98
89661: NOT
89662: IFFALSE 89672
// StreamModeActive := true ;
89664: LD_ADDR_EXP 98
89668: PUSH
89669: LD_INT 1
89671: ST_TO_ADDR
// if p3 = 0 then
89672: LD_VAR 0 3
89676: PUSH
89677: LD_INT 0
89679: EQUAL
89680: IFFALSE 89686
// InitStreamMode ;
89682: CALL 90764 0 0
// if p3 = 1 then
89686: LD_VAR 0 3
89690: PUSH
89691: LD_INT 1
89693: EQUAL
89694: IFFALSE 89704
// sRocket := true ;
89696: LD_ADDR_EXP 103
89700: PUSH
89701: LD_INT 1
89703: ST_TO_ADDR
// if p3 = 2 then
89704: LD_VAR 0 3
89708: PUSH
89709: LD_INT 2
89711: EQUAL
89712: IFFALSE 89722
// sSpeed := true ;
89714: LD_ADDR_EXP 102
89718: PUSH
89719: LD_INT 1
89721: ST_TO_ADDR
// if p3 = 3 then
89722: LD_VAR 0 3
89726: PUSH
89727: LD_INT 3
89729: EQUAL
89730: IFFALSE 89740
// sEngine := true ;
89732: LD_ADDR_EXP 104
89736: PUSH
89737: LD_INT 1
89739: ST_TO_ADDR
// if p3 = 4 then
89740: LD_VAR 0 3
89744: PUSH
89745: LD_INT 4
89747: EQUAL
89748: IFFALSE 89758
// sSpec := true ;
89750: LD_ADDR_EXP 101
89754: PUSH
89755: LD_INT 1
89757: ST_TO_ADDR
// if p3 = 5 then
89758: LD_VAR 0 3
89762: PUSH
89763: LD_INT 5
89765: EQUAL
89766: IFFALSE 89776
// sLevel := true ;
89768: LD_ADDR_EXP 105
89772: PUSH
89773: LD_INT 1
89775: ST_TO_ADDR
// if p3 = 6 then
89776: LD_VAR 0 3
89780: PUSH
89781: LD_INT 6
89783: EQUAL
89784: IFFALSE 89794
// sArmoury := true ;
89786: LD_ADDR_EXP 106
89790: PUSH
89791: LD_INT 1
89793: ST_TO_ADDR
// if p3 = 7 then
89794: LD_VAR 0 3
89798: PUSH
89799: LD_INT 7
89801: EQUAL
89802: IFFALSE 89812
// sRadar := true ;
89804: LD_ADDR_EXP 107
89808: PUSH
89809: LD_INT 1
89811: ST_TO_ADDR
// if p3 = 8 then
89812: LD_VAR 0 3
89816: PUSH
89817: LD_INT 8
89819: EQUAL
89820: IFFALSE 89830
// sBunker := true ;
89822: LD_ADDR_EXP 108
89826: PUSH
89827: LD_INT 1
89829: ST_TO_ADDR
// if p3 = 9 then
89830: LD_VAR 0 3
89834: PUSH
89835: LD_INT 9
89837: EQUAL
89838: IFFALSE 89848
// sHack := true ;
89840: LD_ADDR_EXP 109
89844: PUSH
89845: LD_INT 1
89847: ST_TO_ADDR
// if p3 = 10 then
89848: LD_VAR 0 3
89852: PUSH
89853: LD_INT 10
89855: EQUAL
89856: IFFALSE 89866
// sFire := true ;
89858: LD_ADDR_EXP 110
89862: PUSH
89863: LD_INT 1
89865: ST_TO_ADDR
// if p3 = 11 then
89866: LD_VAR 0 3
89870: PUSH
89871: LD_INT 11
89873: EQUAL
89874: IFFALSE 89884
// sRefresh := true ;
89876: LD_ADDR_EXP 111
89880: PUSH
89881: LD_INT 1
89883: ST_TO_ADDR
// if p3 = 12 then
89884: LD_VAR 0 3
89888: PUSH
89889: LD_INT 12
89891: EQUAL
89892: IFFALSE 89902
// sExp := true ;
89894: LD_ADDR_EXP 112
89898: PUSH
89899: LD_INT 1
89901: ST_TO_ADDR
// if p3 = 13 then
89902: LD_VAR 0 3
89906: PUSH
89907: LD_INT 13
89909: EQUAL
89910: IFFALSE 89920
// sDepot := true ;
89912: LD_ADDR_EXP 113
89916: PUSH
89917: LD_INT 1
89919: ST_TO_ADDR
// if p3 = 14 then
89920: LD_VAR 0 3
89924: PUSH
89925: LD_INT 14
89927: EQUAL
89928: IFFALSE 89938
// sFlag := true ;
89930: LD_ADDR_EXP 114
89934: PUSH
89935: LD_INT 1
89937: ST_TO_ADDR
// if p3 = 15 then
89938: LD_VAR 0 3
89942: PUSH
89943: LD_INT 15
89945: EQUAL
89946: IFFALSE 89956
// sKamikadze := true ;
89948: LD_ADDR_EXP 122
89952: PUSH
89953: LD_INT 1
89955: ST_TO_ADDR
// if p3 = 16 then
89956: LD_VAR 0 3
89960: PUSH
89961: LD_INT 16
89963: EQUAL
89964: IFFALSE 89974
// sTroll := true ;
89966: LD_ADDR_EXP 123
89970: PUSH
89971: LD_INT 1
89973: ST_TO_ADDR
// if p3 = 17 then
89974: LD_VAR 0 3
89978: PUSH
89979: LD_INT 17
89981: EQUAL
89982: IFFALSE 89992
// sSlow := true ;
89984: LD_ADDR_EXP 124
89988: PUSH
89989: LD_INT 1
89991: ST_TO_ADDR
// if p3 = 18 then
89992: LD_VAR 0 3
89996: PUSH
89997: LD_INT 18
89999: EQUAL
90000: IFFALSE 90010
// sLack := true ;
90002: LD_ADDR_EXP 125
90006: PUSH
90007: LD_INT 1
90009: ST_TO_ADDR
// if p3 = 19 then
90010: LD_VAR 0 3
90014: PUSH
90015: LD_INT 19
90017: EQUAL
90018: IFFALSE 90028
// sTank := true ;
90020: LD_ADDR_EXP 127
90024: PUSH
90025: LD_INT 1
90027: ST_TO_ADDR
// if p3 = 20 then
90028: LD_VAR 0 3
90032: PUSH
90033: LD_INT 20
90035: EQUAL
90036: IFFALSE 90046
// sRemote := true ;
90038: LD_ADDR_EXP 128
90042: PUSH
90043: LD_INT 1
90045: ST_TO_ADDR
// if p3 = 21 then
90046: LD_VAR 0 3
90050: PUSH
90051: LD_INT 21
90053: EQUAL
90054: IFFALSE 90064
// sPowell := true ;
90056: LD_ADDR_EXP 129
90060: PUSH
90061: LD_INT 1
90063: ST_TO_ADDR
// if p3 = 22 then
90064: LD_VAR 0 3
90068: PUSH
90069: LD_INT 22
90071: EQUAL
90072: IFFALSE 90082
// sTeleport := true ;
90074: LD_ADDR_EXP 132
90078: PUSH
90079: LD_INT 1
90081: ST_TO_ADDR
// if p3 = 23 then
90082: LD_VAR 0 3
90086: PUSH
90087: LD_INT 23
90089: EQUAL
90090: IFFALSE 90100
// sOilTower := true ;
90092: LD_ADDR_EXP 134
90096: PUSH
90097: LD_INT 1
90099: ST_TO_ADDR
// if p3 = 24 then
90100: LD_VAR 0 3
90104: PUSH
90105: LD_INT 24
90107: EQUAL
90108: IFFALSE 90118
// sShovel := true ;
90110: LD_ADDR_EXP 135
90114: PUSH
90115: LD_INT 1
90117: ST_TO_ADDR
// if p3 = 25 then
90118: LD_VAR 0 3
90122: PUSH
90123: LD_INT 25
90125: EQUAL
90126: IFFALSE 90136
// sSheik := true ;
90128: LD_ADDR_EXP 136
90132: PUSH
90133: LD_INT 1
90135: ST_TO_ADDR
// if p3 = 26 then
90136: LD_VAR 0 3
90140: PUSH
90141: LD_INT 26
90143: EQUAL
90144: IFFALSE 90154
// sEarthquake := true ;
90146: LD_ADDR_EXP 138
90150: PUSH
90151: LD_INT 1
90153: ST_TO_ADDR
// if p3 = 27 then
90154: LD_VAR 0 3
90158: PUSH
90159: LD_INT 27
90161: EQUAL
90162: IFFALSE 90172
// sAI := true ;
90164: LD_ADDR_EXP 139
90168: PUSH
90169: LD_INT 1
90171: ST_TO_ADDR
// if p3 = 28 then
90172: LD_VAR 0 3
90176: PUSH
90177: LD_INT 28
90179: EQUAL
90180: IFFALSE 90190
// sCargo := true ;
90182: LD_ADDR_EXP 142
90186: PUSH
90187: LD_INT 1
90189: ST_TO_ADDR
// if p3 = 29 then
90190: LD_VAR 0 3
90194: PUSH
90195: LD_INT 29
90197: EQUAL
90198: IFFALSE 90208
// sDLaser := true ;
90200: LD_ADDR_EXP 143
90204: PUSH
90205: LD_INT 1
90207: ST_TO_ADDR
// if p3 = 30 then
90208: LD_VAR 0 3
90212: PUSH
90213: LD_INT 30
90215: EQUAL
90216: IFFALSE 90226
// sExchange := true ;
90218: LD_ADDR_EXP 144
90222: PUSH
90223: LD_INT 1
90225: ST_TO_ADDR
// if p3 = 31 then
90226: LD_VAR 0 3
90230: PUSH
90231: LD_INT 31
90233: EQUAL
90234: IFFALSE 90244
// sFac := true ;
90236: LD_ADDR_EXP 145
90240: PUSH
90241: LD_INT 1
90243: ST_TO_ADDR
// if p3 = 32 then
90244: LD_VAR 0 3
90248: PUSH
90249: LD_INT 32
90251: EQUAL
90252: IFFALSE 90262
// sPower := true ;
90254: LD_ADDR_EXP 146
90258: PUSH
90259: LD_INT 1
90261: ST_TO_ADDR
// if p3 = 33 then
90262: LD_VAR 0 3
90266: PUSH
90267: LD_INT 33
90269: EQUAL
90270: IFFALSE 90280
// sRandom := true ;
90272: LD_ADDR_EXP 147
90276: PUSH
90277: LD_INT 1
90279: ST_TO_ADDR
// if p3 = 34 then
90280: LD_VAR 0 3
90284: PUSH
90285: LD_INT 34
90287: EQUAL
90288: IFFALSE 90298
// sShield := true ;
90290: LD_ADDR_EXP 148
90294: PUSH
90295: LD_INT 1
90297: ST_TO_ADDR
// if p3 = 35 then
90298: LD_VAR 0 3
90302: PUSH
90303: LD_INT 35
90305: EQUAL
90306: IFFALSE 90316
// sTime := true ;
90308: LD_ADDR_EXP 149
90312: PUSH
90313: LD_INT 1
90315: ST_TO_ADDR
// if p3 = 36 then
90316: LD_VAR 0 3
90320: PUSH
90321: LD_INT 36
90323: EQUAL
90324: IFFALSE 90334
// sTools := true ;
90326: LD_ADDR_EXP 150
90330: PUSH
90331: LD_INT 1
90333: ST_TO_ADDR
// if p3 = 101 then
90334: LD_VAR 0 3
90338: PUSH
90339: LD_INT 101
90341: EQUAL
90342: IFFALSE 90352
// sSold := true ;
90344: LD_ADDR_EXP 115
90348: PUSH
90349: LD_INT 1
90351: ST_TO_ADDR
// if p3 = 102 then
90352: LD_VAR 0 3
90356: PUSH
90357: LD_INT 102
90359: EQUAL
90360: IFFALSE 90370
// sDiff := true ;
90362: LD_ADDR_EXP 116
90366: PUSH
90367: LD_INT 1
90369: ST_TO_ADDR
// if p3 = 103 then
90370: LD_VAR 0 3
90374: PUSH
90375: LD_INT 103
90377: EQUAL
90378: IFFALSE 90388
// sFog := true ;
90380: LD_ADDR_EXP 119
90384: PUSH
90385: LD_INT 1
90387: ST_TO_ADDR
// if p3 = 104 then
90388: LD_VAR 0 3
90392: PUSH
90393: LD_INT 104
90395: EQUAL
90396: IFFALSE 90406
// sReset := true ;
90398: LD_ADDR_EXP 120
90402: PUSH
90403: LD_INT 1
90405: ST_TO_ADDR
// if p3 = 105 then
90406: LD_VAR 0 3
90410: PUSH
90411: LD_INT 105
90413: EQUAL
90414: IFFALSE 90424
// sSun := true ;
90416: LD_ADDR_EXP 121
90420: PUSH
90421: LD_INT 1
90423: ST_TO_ADDR
// if p3 = 106 then
90424: LD_VAR 0 3
90428: PUSH
90429: LD_INT 106
90431: EQUAL
90432: IFFALSE 90442
// sTiger := true ;
90434: LD_ADDR_EXP 117
90438: PUSH
90439: LD_INT 1
90441: ST_TO_ADDR
// if p3 = 107 then
90442: LD_VAR 0 3
90446: PUSH
90447: LD_INT 107
90449: EQUAL
90450: IFFALSE 90460
// sBomb := true ;
90452: LD_ADDR_EXP 118
90456: PUSH
90457: LD_INT 1
90459: ST_TO_ADDR
// if p3 = 108 then
90460: LD_VAR 0 3
90464: PUSH
90465: LD_INT 108
90467: EQUAL
90468: IFFALSE 90478
// sWound := true ;
90470: LD_ADDR_EXP 126
90474: PUSH
90475: LD_INT 1
90477: ST_TO_ADDR
// if p3 = 109 then
90478: LD_VAR 0 3
90482: PUSH
90483: LD_INT 109
90485: EQUAL
90486: IFFALSE 90496
// sBetray := true ;
90488: LD_ADDR_EXP 130
90492: PUSH
90493: LD_INT 1
90495: ST_TO_ADDR
// if p3 = 110 then
90496: LD_VAR 0 3
90500: PUSH
90501: LD_INT 110
90503: EQUAL
90504: IFFALSE 90514
// sContamin := true ;
90506: LD_ADDR_EXP 131
90510: PUSH
90511: LD_INT 1
90513: ST_TO_ADDR
// if p3 = 111 then
90514: LD_VAR 0 3
90518: PUSH
90519: LD_INT 111
90521: EQUAL
90522: IFFALSE 90532
// sOil := true ;
90524: LD_ADDR_EXP 133
90528: PUSH
90529: LD_INT 1
90531: ST_TO_ADDR
// if p3 = 112 then
90532: LD_VAR 0 3
90536: PUSH
90537: LD_INT 112
90539: EQUAL
90540: IFFALSE 90550
// sStu := true ;
90542: LD_ADDR_EXP 137
90546: PUSH
90547: LD_INT 1
90549: ST_TO_ADDR
// if p3 = 113 then
90550: LD_VAR 0 3
90554: PUSH
90555: LD_INT 113
90557: EQUAL
90558: IFFALSE 90568
// sBazooka := true ;
90560: LD_ADDR_EXP 140
90564: PUSH
90565: LD_INT 1
90567: ST_TO_ADDR
// if p3 = 114 then
90568: LD_VAR 0 3
90572: PUSH
90573: LD_INT 114
90575: EQUAL
90576: IFFALSE 90586
// sMortar := true ;
90578: LD_ADDR_EXP 141
90582: PUSH
90583: LD_INT 1
90585: ST_TO_ADDR
// if p3 = 115 then
90586: LD_VAR 0 3
90590: PUSH
90591: LD_INT 115
90593: EQUAL
90594: IFFALSE 90604
// sRanger := true ;
90596: LD_ADDR_EXP 151
90600: PUSH
90601: LD_INT 1
90603: ST_TO_ADDR
// end ; if p2 = 101 then
90604: LD_VAR 0 2
90608: PUSH
90609: LD_INT 101
90611: EQUAL
90612: IFFALSE 90740
// begin case p3 of 1 :
90614: LD_VAR 0 3
90618: PUSH
90619: LD_INT 1
90621: DOUBLE
90622: EQUAL
90623: IFTRUE 90627
90625: GO 90634
90627: POP
// hHackUnlimitedResources ; 2 :
90628: CALL 101777 0 0
90632: GO 90740
90634: LD_INT 2
90636: DOUBLE
90637: EQUAL
90638: IFTRUE 90642
90640: GO 90649
90642: POP
// hHackSetLevel10 ; 3 :
90643: CALL 101910 0 0
90647: GO 90740
90649: LD_INT 3
90651: DOUBLE
90652: EQUAL
90653: IFTRUE 90657
90655: GO 90664
90657: POP
// hHackSetLevel10YourUnits ; 4 :
90658: CALL 101995 0 0
90662: GO 90740
90664: LD_INT 4
90666: DOUBLE
90667: EQUAL
90668: IFTRUE 90672
90670: GO 90679
90672: POP
// hHackInvincible ; 5 :
90673: CALL 102443 0 0
90677: GO 90740
90679: LD_INT 5
90681: DOUBLE
90682: EQUAL
90683: IFTRUE 90687
90685: GO 90694
90687: POP
// hHackInvisible ; 6 :
90688: CALL 102554 0 0
90692: GO 90740
90694: LD_INT 6
90696: DOUBLE
90697: EQUAL
90698: IFTRUE 90702
90700: GO 90709
90702: POP
// hHackChangeYourSide ; 7 :
90703: CALL 102611 0 0
90707: GO 90740
90709: LD_INT 7
90711: DOUBLE
90712: EQUAL
90713: IFTRUE 90717
90715: GO 90724
90717: POP
// hHackChangeUnitSide ; 8 :
90718: CALL 102653 0 0
90722: GO 90740
90724: LD_INT 8
90726: DOUBLE
90727: EQUAL
90728: IFTRUE 90732
90730: GO 90739
90732: POP
// hHackFog ; end ;
90733: CALL 102754 0 0
90737: GO 90740
90739: POP
// end ; end ;
90740: LD_VAR 0 7
90744: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
90745: GO 90747
90747: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
90748: LD_STRING initStreamRollete();
90750: PPUSH
90751: CALL_OW 559
// InitStreamMode ;
90755: CALL 90764 0 0
// DefineStreamItems ( ) ;
90759: CALL 91204 0 0
// end ;
90763: END
// function InitStreamMode ; begin
90764: LD_INT 0
90766: PPUSH
// streamModeActive := false ;
90767: LD_ADDR_EXP 98
90771: PUSH
90772: LD_INT 0
90774: ST_TO_ADDR
// normalCounter := 36 ;
90775: LD_ADDR_EXP 99
90779: PUSH
90780: LD_INT 36
90782: ST_TO_ADDR
// hardcoreCounter := 16 ;
90783: LD_ADDR_EXP 100
90787: PUSH
90788: LD_INT 16
90790: ST_TO_ADDR
// sRocket := false ;
90791: LD_ADDR_EXP 103
90795: PUSH
90796: LD_INT 0
90798: ST_TO_ADDR
// sSpeed := false ;
90799: LD_ADDR_EXP 102
90803: PUSH
90804: LD_INT 0
90806: ST_TO_ADDR
// sEngine := false ;
90807: LD_ADDR_EXP 104
90811: PUSH
90812: LD_INT 0
90814: ST_TO_ADDR
// sSpec := false ;
90815: LD_ADDR_EXP 101
90819: PUSH
90820: LD_INT 0
90822: ST_TO_ADDR
// sLevel := false ;
90823: LD_ADDR_EXP 105
90827: PUSH
90828: LD_INT 0
90830: ST_TO_ADDR
// sArmoury := false ;
90831: LD_ADDR_EXP 106
90835: PUSH
90836: LD_INT 0
90838: ST_TO_ADDR
// sRadar := false ;
90839: LD_ADDR_EXP 107
90843: PUSH
90844: LD_INT 0
90846: ST_TO_ADDR
// sBunker := false ;
90847: LD_ADDR_EXP 108
90851: PUSH
90852: LD_INT 0
90854: ST_TO_ADDR
// sHack := false ;
90855: LD_ADDR_EXP 109
90859: PUSH
90860: LD_INT 0
90862: ST_TO_ADDR
// sFire := false ;
90863: LD_ADDR_EXP 110
90867: PUSH
90868: LD_INT 0
90870: ST_TO_ADDR
// sRefresh := false ;
90871: LD_ADDR_EXP 111
90875: PUSH
90876: LD_INT 0
90878: ST_TO_ADDR
// sExp := false ;
90879: LD_ADDR_EXP 112
90883: PUSH
90884: LD_INT 0
90886: ST_TO_ADDR
// sDepot := false ;
90887: LD_ADDR_EXP 113
90891: PUSH
90892: LD_INT 0
90894: ST_TO_ADDR
// sFlag := false ;
90895: LD_ADDR_EXP 114
90899: PUSH
90900: LD_INT 0
90902: ST_TO_ADDR
// sKamikadze := false ;
90903: LD_ADDR_EXP 122
90907: PUSH
90908: LD_INT 0
90910: ST_TO_ADDR
// sTroll := false ;
90911: LD_ADDR_EXP 123
90915: PUSH
90916: LD_INT 0
90918: ST_TO_ADDR
// sSlow := false ;
90919: LD_ADDR_EXP 124
90923: PUSH
90924: LD_INT 0
90926: ST_TO_ADDR
// sLack := false ;
90927: LD_ADDR_EXP 125
90931: PUSH
90932: LD_INT 0
90934: ST_TO_ADDR
// sTank := false ;
90935: LD_ADDR_EXP 127
90939: PUSH
90940: LD_INT 0
90942: ST_TO_ADDR
// sRemote := false ;
90943: LD_ADDR_EXP 128
90947: PUSH
90948: LD_INT 0
90950: ST_TO_ADDR
// sPowell := false ;
90951: LD_ADDR_EXP 129
90955: PUSH
90956: LD_INT 0
90958: ST_TO_ADDR
// sTeleport := false ;
90959: LD_ADDR_EXP 132
90963: PUSH
90964: LD_INT 0
90966: ST_TO_ADDR
// sOilTower := false ;
90967: LD_ADDR_EXP 134
90971: PUSH
90972: LD_INT 0
90974: ST_TO_ADDR
// sShovel := false ;
90975: LD_ADDR_EXP 135
90979: PUSH
90980: LD_INT 0
90982: ST_TO_ADDR
// sSheik := false ;
90983: LD_ADDR_EXP 136
90987: PUSH
90988: LD_INT 0
90990: ST_TO_ADDR
// sEarthquake := false ;
90991: LD_ADDR_EXP 138
90995: PUSH
90996: LD_INT 0
90998: ST_TO_ADDR
// sAI := false ;
90999: LD_ADDR_EXP 139
91003: PUSH
91004: LD_INT 0
91006: ST_TO_ADDR
// sCargo := false ;
91007: LD_ADDR_EXP 142
91011: PUSH
91012: LD_INT 0
91014: ST_TO_ADDR
// sDLaser := false ;
91015: LD_ADDR_EXP 143
91019: PUSH
91020: LD_INT 0
91022: ST_TO_ADDR
// sExchange := false ;
91023: LD_ADDR_EXP 144
91027: PUSH
91028: LD_INT 0
91030: ST_TO_ADDR
// sFac := false ;
91031: LD_ADDR_EXP 145
91035: PUSH
91036: LD_INT 0
91038: ST_TO_ADDR
// sPower := false ;
91039: LD_ADDR_EXP 146
91043: PUSH
91044: LD_INT 0
91046: ST_TO_ADDR
// sRandom := false ;
91047: LD_ADDR_EXP 147
91051: PUSH
91052: LD_INT 0
91054: ST_TO_ADDR
// sShield := false ;
91055: LD_ADDR_EXP 148
91059: PUSH
91060: LD_INT 0
91062: ST_TO_ADDR
// sTime := false ;
91063: LD_ADDR_EXP 149
91067: PUSH
91068: LD_INT 0
91070: ST_TO_ADDR
// sTools := false ;
91071: LD_ADDR_EXP 150
91075: PUSH
91076: LD_INT 0
91078: ST_TO_ADDR
// sSold := false ;
91079: LD_ADDR_EXP 115
91083: PUSH
91084: LD_INT 0
91086: ST_TO_ADDR
// sDiff := false ;
91087: LD_ADDR_EXP 116
91091: PUSH
91092: LD_INT 0
91094: ST_TO_ADDR
// sFog := false ;
91095: LD_ADDR_EXP 119
91099: PUSH
91100: LD_INT 0
91102: ST_TO_ADDR
// sReset := false ;
91103: LD_ADDR_EXP 120
91107: PUSH
91108: LD_INT 0
91110: ST_TO_ADDR
// sSun := false ;
91111: LD_ADDR_EXP 121
91115: PUSH
91116: LD_INT 0
91118: ST_TO_ADDR
// sTiger := false ;
91119: LD_ADDR_EXP 117
91123: PUSH
91124: LD_INT 0
91126: ST_TO_ADDR
// sBomb := false ;
91127: LD_ADDR_EXP 118
91131: PUSH
91132: LD_INT 0
91134: ST_TO_ADDR
// sWound := false ;
91135: LD_ADDR_EXP 126
91139: PUSH
91140: LD_INT 0
91142: ST_TO_ADDR
// sBetray := false ;
91143: LD_ADDR_EXP 130
91147: PUSH
91148: LD_INT 0
91150: ST_TO_ADDR
// sContamin := false ;
91151: LD_ADDR_EXP 131
91155: PUSH
91156: LD_INT 0
91158: ST_TO_ADDR
// sOil := false ;
91159: LD_ADDR_EXP 133
91163: PUSH
91164: LD_INT 0
91166: ST_TO_ADDR
// sStu := false ;
91167: LD_ADDR_EXP 137
91171: PUSH
91172: LD_INT 0
91174: ST_TO_ADDR
// sBazooka := false ;
91175: LD_ADDR_EXP 140
91179: PUSH
91180: LD_INT 0
91182: ST_TO_ADDR
// sMortar := false ;
91183: LD_ADDR_EXP 141
91187: PUSH
91188: LD_INT 0
91190: ST_TO_ADDR
// sRanger := false ;
91191: LD_ADDR_EXP 151
91195: PUSH
91196: LD_INT 0
91198: ST_TO_ADDR
// end ;
91199: LD_VAR 0 1
91203: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
91204: LD_INT 0
91206: PPUSH
91207: PPUSH
91208: PPUSH
91209: PPUSH
91210: PPUSH
// result := [ ] ;
91211: LD_ADDR_VAR 0 1
91215: PUSH
91216: EMPTY
91217: ST_TO_ADDR
// if campaign_id = 1 then
91218: LD_OWVAR 69
91222: PUSH
91223: LD_INT 1
91225: EQUAL
91226: IFFALSE 94164
// begin case mission_number of 1 :
91228: LD_OWVAR 70
91232: PUSH
91233: LD_INT 1
91235: DOUBLE
91236: EQUAL
91237: IFTRUE 91241
91239: GO 91305
91241: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
91242: LD_ADDR_VAR 0 1
91246: PUSH
91247: LD_INT 2
91249: PUSH
91250: LD_INT 4
91252: PUSH
91253: LD_INT 11
91255: PUSH
91256: LD_INT 12
91258: PUSH
91259: LD_INT 15
91261: PUSH
91262: LD_INT 16
91264: PUSH
91265: LD_INT 22
91267: PUSH
91268: LD_INT 23
91270: PUSH
91271: LD_INT 26
91273: PUSH
91274: EMPTY
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 101
91287: PUSH
91288: LD_INT 102
91290: PUSH
91291: LD_INT 106
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: LIST
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: ST_TO_ADDR
91303: GO 94162
91305: LD_INT 2
91307: DOUBLE
91308: EQUAL
91309: IFTRUE 91313
91311: GO 91385
91313: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
91314: LD_ADDR_VAR 0 1
91318: PUSH
91319: LD_INT 2
91321: PUSH
91322: LD_INT 4
91324: PUSH
91325: LD_INT 11
91327: PUSH
91328: LD_INT 12
91330: PUSH
91331: LD_INT 15
91333: PUSH
91334: LD_INT 16
91336: PUSH
91337: LD_INT 22
91339: PUSH
91340: LD_INT 23
91342: PUSH
91343: LD_INT 26
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: PUSH
91357: LD_INT 101
91359: PUSH
91360: LD_INT 102
91362: PUSH
91363: LD_INT 105
91365: PUSH
91366: LD_INT 106
91368: PUSH
91369: LD_INT 108
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: PUSH
91379: EMPTY
91380: LIST
91381: LIST
91382: ST_TO_ADDR
91383: GO 94162
91385: LD_INT 3
91387: DOUBLE
91388: EQUAL
91389: IFTRUE 91393
91391: GO 91469
91393: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
91394: LD_ADDR_VAR 0 1
91398: PUSH
91399: LD_INT 2
91401: PUSH
91402: LD_INT 4
91404: PUSH
91405: LD_INT 5
91407: PUSH
91408: LD_INT 11
91410: PUSH
91411: LD_INT 12
91413: PUSH
91414: LD_INT 15
91416: PUSH
91417: LD_INT 16
91419: PUSH
91420: LD_INT 22
91422: PUSH
91423: LD_INT 26
91425: PUSH
91426: LD_INT 36
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: PUSH
91441: LD_INT 101
91443: PUSH
91444: LD_INT 102
91446: PUSH
91447: LD_INT 105
91449: PUSH
91450: LD_INT 106
91452: PUSH
91453: LD_INT 108
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: ST_TO_ADDR
91467: GO 94162
91469: LD_INT 4
91471: DOUBLE
91472: EQUAL
91473: IFTRUE 91477
91475: GO 91561
91477: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
91478: LD_ADDR_VAR 0 1
91482: PUSH
91483: LD_INT 2
91485: PUSH
91486: LD_INT 4
91488: PUSH
91489: LD_INT 5
91491: PUSH
91492: LD_INT 8
91494: PUSH
91495: LD_INT 11
91497: PUSH
91498: LD_INT 12
91500: PUSH
91501: LD_INT 15
91503: PUSH
91504: LD_INT 16
91506: PUSH
91507: LD_INT 22
91509: PUSH
91510: LD_INT 23
91512: PUSH
91513: LD_INT 26
91515: PUSH
91516: LD_INT 36
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 101
91535: PUSH
91536: LD_INT 102
91538: PUSH
91539: LD_INT 105
91541: PUSH
91542: LD_INT 106
91544: PUSH
91545: LD_INT 108
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: ST_TO_ADDR
91559: GO 94162
91561: LD_INT 5
91563: DOUBLE
91564: EQUAL
91565: IFTRUE 91569
91567: GO 91669
91569: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
91570: LD_ADDR_VAR 0 1
91574: PUSH
91575: LD_INT 2
91577: PUSH
91578: LD_INT 4
91580: PUSH
91581: LD_INT 5
91583: PUSH
91584: LD_INT 6
91586: PUSH
91587: LD_INT 8
91589: PUSH
91590: LD_INT 11
91592: PUSH
91593: LD_INT 12
91595: PUSH
91596: LD_INT 15
91598: PUSH
91599: LD_INT 16
91601: PUSH
91602: LD_INT 22
91604: PUSH
91605: LD_INT 23
91607: PUSH
91608: LD_INT 25
91610: PUSH
91611: LD_INT 26
91613: PUSH
91614: LD_INT 36
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: PUSH
91633: LD_INT 101
91635: PUSH
91636: LD_INT 102
91638: PUSH
91639: LD_INT 105
91641: PUSH
91642: LD_INT 106
91644: PUSH
91645: LD_INT 108
91647: PUSH
91648: LD_INT 109
91650: PUSH
91651: LD_INT 112
91653: PUSH
91654: EMPTY
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: ST_TO_ADDR
91667: GO 94162
91669: LD_INT 6
91671: DOUBLE
91672: EQUAL
91673: IFTRUE 91677
91675: GO 91797
91677: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
91678: LD_ADDR_VAR 0 1
91682: PUSH
91683: LD_INT 2
91685: PUSH
91686: LD_INT 4
91688: PUSH
91689: LD_INT 5
91691: PUSH
91692: LD_INT 6
91694: PUSH
91695: LD_INT 8
91697: PUSH
91698: LD_INT 11
91700: PUSH
91701: LD_INT 12
91703: PUSH
91704: LD_INT 15
91706: PUSH
91707: LD_INT 16
91709: PUSH
91710: LD_INT 20
91712: PUSH
91713: LD_INT 21
91715: PUSH
91716: LD_INT 22
91718: PUSH
91719: LD_INT 23
91721: PUSH
91722: LD_INT 25
91724: PUSH
91725: LD_INT 26
91727: PUSH
91728: LD_INT 30
91730: PUSH
91731: LD_INT 31
91733: PUSH
91734: LD_INT 32
91736: PUSH
91737: LD_INT 36
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: LIST
91744: LIST
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: PUSH
91761: LD_INT 101
91763: PUSH
91764: LD_INT 102
91766: PUSH
91767: LD_INT 105
91769: PUSH
91770: LD_INT 106
91772: PUSH
91773: LD_INT 108
91775: PUSH
91776: LD_INT 109
91778: PUSH
91779: LD_INT 112
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: ST_TO_ADDR
91795: GO 94162
91797: LD_INT 7
91799: DOUBLE
91800: EQUAL
91801: IFTRUE 91805
91803: GO 91905
91805: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
91806: LD_ADDR_VAR 0 1
91810: PUSH
91811: LD_INT 2
91813: PUSH
91814: LD_INT 4
91816: PUSH
91817: LD_INT 5
91819: PUSH
91820: LD_INT 7
91822: PUSH
91823: LD_INT 11
91825: PUSH
91826: LD_INT 12
91828: PUSH
91829: LD_INT 15
91831: PUSH
91832: LD_INT 16
91834: PUSH
91835: LD_INT 20
91837: PUSH
91838: LD_INT 21
91840: PUSH
91841: LD_INT 22
91843: PUSH
91844: LD_INT 23
91846: PUSH
91847: LD_INT 25
91849: PUSH
91850: LD_INT 26
91852: PUSH
91853: EMPTY
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: PUSH
91869: LD_INT 101
91871: PUSH
91872: LD_INT 102
91874: PUSH
91875: LD_INT 103
91877: PUSH
91878: LD_INT 105
91880: PUSH
91881: LD_INT 106
91883: PUSH
91884: LD_INT 108
91886: PUSH
91887: LD_INT 112
91889: PUSH
91890: EMPTY
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: ST_TO_ADDR
91903: GO 94162
91905: LD_INT 8
91907: DOUBLE
91908: EQUAL
91909: IFTRUE 91913
91911: GO 92041
91913: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
91914: LD_ADDR_VAR 0 1
91918: PUSH
91919: LD_INT 2
91921: PUSH
91922: LD_INT 4
91924: PUSH
91925: LD_INT 5
91927: PUSH
91928: LD_INT 6
91930: PUSH
91931: LD_INT 7
91933: PUSH
91934: LD_INT 8
91936: PUSH
91937: LD_INT 11
91939: PUSH
91940: LD_INT 12
91942: PUSH
91943: LD_INT 15
91945: PUSH
91946: LD_INT 16
91948: PUSH
91949: LD_INT 20
91951: PUSH
91952: LD_INT 21
91954: PUSH
91955: LD_INT 22
91957: PUSH
91958: LD_INT 23
91960: PUSH
91961: LD_INT 25
91963: PUSH
91964: LD_INT 26
91966: PUSH
91967: LD_INT 30
91969: PUSH
91970: LD_INT 31
91972: PUSH
91973: LD_INT 32
91975: PUSH
91976: LD_INT 36
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: PUSH
92001: LD_INT 101
92003: PUSH
92004: LD_INT 102
92006: PUSH
92007: LD_INT 103
92009: PUSH
92010: LD_INT 105
92012: PUSH
92013: LD_INT 106
92015: PUSH
92016: LD_INT 108
92018: PUSH
92019: LD_INT 109
92021: PUSH
92022: LD_INT 112
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: PUSH
92035: EMPTY
92036: LIST
92037: LIST
92038: ST_TO_ADDR
92039: GO 94162
92041: LD_INT 9
92043: DOUBLE
92044: EQUAL
92045: IFTRUE 92049
92047: GO 92185
92049: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
92050: LD_ADDR_VAR 0 1
92054: PUSH
92055: LD_INT 2
92057: PUSH
92058: LD_INT 4
92060: PUSH
92061: LD_INT 5
92063: PUSH
92064: LD_INT 6
92066: PUSH
92067: LD_INT 7
92069: PUSH
92070: LD_INT 8
92072: PUSH
92073: LD_INT 11
92075: PUSH
92076: LD_INT 12
92078: PUSH
92079: LD_INT 15
92081: PUSH
92082: LD_INT 16
92084: PUSH
92085: LD_INT 20
92087: PUSH
92088: LD_INT 21
92090: PUSH
92091: LD_INT 22
92093: PUSH
92094: LD_INT 23
92096: PUSH
92097: LD_INT 25
92099: PUSH
92100: LD_INT 26
92102: PUSH
92103: LD_INT 28
92105: PUSH
92106: LD_INT 30
92108: PUSH
92109: LD_INT 31
92111: PUSH
92112: LD_INT 32
92114: PUSH
92115: LD_INT 36
92117: PUSH
92118: EMPTY
92119: LIST
92120: LIST
92121: LIST
92122: LIST
92123: LIST
92124: LIST
92125: LIST
92126: LIST
92127: LIST
92128: LIST
92129: LIST
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: PUSH
92141: LD_INT 101
92143: PUSH
92144: LD_INT 102
92146: PUSH
92147: LD_INT 103
92149: PUSH
92150: LD_INT 105
92152: PUSH
92153: LD_INT 106
92155: PUSH
92156: LD_INT 108
92158: PUSH
92159: LD_INT 109
92161: PUSH
92162: LD_INT 112
92164: PUSH
92165: LD_INT 114
92167: PUSH
92168: EMPTY
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: ST_TO_ADDR
92183: GO 94162
92185: LD_INT 10
92187: DOUBLE
92188: EQUAL
92189: IFTRUE 92193
92191: GO 92377
92193: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
92194: LD_ADDR_VAR 0 1
92198: PUSH
92199: LD_INT 2
92201: PUSH
92202: LD_INT 4
92204: PUSH
92205: LD_INT 5
92207: PUSH
92208: LD_INT 6
92210: PUSH
92211: LD_INT 7
92213: PUSH
92214: LD_INT 8
92216: PUSH
92217: LD_INT 9
92219: PUSH
92220: LD_INT 10
92222: PUSH
92223: LD_INT 11
92225: PUSH
92226: LD_INT 12
92228: PUSH
92229: LD_INT 13
92231: PUSH
92232: LD_INT 14
92234: PUSH
92235: LD_INT 15
92237: PUSH
92238: LD_INT 16
92240: PUSH
92241: LD_INT 17
92243: PUSH
92244: LD_INT 18
92246: PUSH
92247: LD_INT 19
92249: PUSH
92250: LD_INT 20
92252: PUSH
92253: LD_INT 21
92255: PUSH
92256: LD_INT 22
92258: PUSH
92259: LD_INT 23
92261: PUSH
92262: LD_INT 24
92264: PUSH
92265: LD_INT 25
92267: PUSH
92268: LD_INT 26
92270: PUSH
92271: LD_INT 28
92273: PUSH
92274: LD_INT 30
92276: PUSH
92277: LD_INT 31
92279: PUSH
92280: LD_INT 32
92282: PUSH
92283: LD_INT 36
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: LIST
92306: LIST
92307: LIST
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: PUSH
92317: LD_INT 101
92319: PUSH
92320: LD_INT 102
92322: PUSH
92323: LD_INT 103
92325: PUSH
92326: LD_INT 104
92328: PUSH
92329: LD_INT 105
92331: PUSH
92332: LD_INT 106
92334: PUSH
92335: LD_INT 107
92337: PUSH
92338: LD_INT 108
92340: PUSH
92341: LD_INT 109
92343: PUSH
92344: LD_INT 110
92346: PUSH
92347: LD_INT 111
92349: PUSH
92350: LD_INT 112
92352: PUSH
92353: LD_INT 114
92355: PUSH
92356: EMPTY
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: ST_TO_ADDR
92375: GO 94162
92377: LD_INT 11
92379: DOUBLE
92380: EQUAL
92381: IFTRUE 92385
92383: GO 92577
92385: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
92386: LD_ADDR_VAR 0 1
92390: PUSH
92391: LD_INT 2
92393: PUSH
92394: LD_INT 3
92396: PUSH
92397: LD_INT 4
92399: PUSH
92400: LD_INT 5
92402: PUSH
92403: LD_INT 6
92405: PUSH
92406: LD_INT 7
92408: PUSH
92409: LD_INT 8
92411: PUSH
92412: LD_INT 9
92414: PUSH
92415: LD_INT 10
92417: PUSH
92418: LD_INT 11
92420: PUSH
92421: LD_INT 12
92423: PUSH
92424: LD_INT 13
92426: PUSH
92427: LD_INT 14
92429: PUSH
92430: LD_INT 15
92432: PUSH
92433: LD_INT 16
92435: PUSH
92436: LD_INT 17
92438: PUSH
92439: LD_INT 18
92441: PUSH
92442: LD_INT 19
92444: PUSH
92445: LD_INT 20
92447: PUSH
92448: LD_INT 21
92450: PUSH
92451: LD_INT 22
92453: PUSH
92454: LD_INT 23
92456: PUSH
92457: LD_INT 24
92459: PUSH
92460: LD_INT 25
92462: PUSH
92463: LD_INT 26
92465: PUSH
92466: LD_INT 28
92468: PUSH
92469: LD_INT 30
92471: PUSH
92472: LD_INT 31
92474: PUSH
92475: LD_INT 32
92477: PUSH
92478: LD_INT 34
92480: PUSH
92481: LD_INT 36
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: LIST
92503: LIST
92504: LIST
92505: LIST
92506: LIST
92507: LIST
92508: LIST
92509: LIST
92510: LIST
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 101
92519: PUSH
92520: LD_INT 102
92522: PUSH
92523: LD_INT 103
92525: PUSH
92526: LD_INT 104
92528: PUSH
92529: LD_INT 105
92531: PUSH
92532: LD_INT 106
92534: PUSH
92535: LD_INT 107
92537: PUSH
92538: LD_INT 108
92540: PUSH
92541: LD_INT 109
92543: PUSH
92544: LD_INT 110
92546: PUSH
92547: LD_INT 111
92549: PUSH
92550: LD_INT 112
92552: PUSH
92553: LD_INT 114
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: ST_TO_ADDR
92575: GO 94162
92577: LD_INT 12
92579: DOUBLE
92580: EQUAL
92581: IFTRUE 92585
92583: GO 92793
92585: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
92586: LD_ADDR_VAR 0 1
92590: PUSH
92591: LD_INT 1
92593: PUSH
92594: LD_INT 2
92596: PUSH
92597: LD_INT 3
92599: PUSH
92600: LD_INT 4
92602: PUSH
92603: LD_INT 5
92605: PUSH
92606: LD_INT 6
92608: PUSH
92609: LD_INT 7
92611: PUSH
92612: LD_INT 8
92614: PUSH
92615: LD_INT 9
92617: PUSH
92618: LD_INT 10
92620: PUSH
92621: LD_INT 11
92623: PUSH
92624: LD_INT 12
92626: PUSH
92627: LD_INT 13
92629: PUSH
92630: LD_INT 14
92632: PUSH
92633: LD_INT 15
92635: PUSH
92636: LD_INT 16
92638: PUSH
92639: LD_INT 17
92641: PUSH
92642: LD_INT 18
92644: PUSH
92645: LD_INT 19
92647: PUSH
92648: LD_INT 20
92650: PUSH
92651: LD_INT 21
92653: PUSH
92654: LD_INT 22
92656: PUSH
92657: LD_INT 23
92659: PUSH
92660: LD_INT 24
92662: PUSH
92663: LD_INT 25
92665: PUSH
92666: LD_INT 26
92668: PUSH
92669: LD_INT 27
92671: PUSH
92672: LD_INT 28
92674: PUSH
92675: LD_INT 30
92677: PUSH
92678: LD_INT 31
92680: PUSH
92681: LD_INT 32
92683: PUSH
92684: LD_INT 33
92686: PUSH
92687: LD_INT 34
92689: PUSH
92690: LD_INT 36
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: LIST
92721: LIST
92722: LIST
92723: LIST
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: PUSH
92729: LD_INT 101
92731: PUSH
92732: LD_INT 102
92734: PUSH
92735: LD_INT 103
92737: PUSH
92738: LD_INT 104
92740: PUSH
92741: LD_INT 105
92743: PUSH
92744: LD_INT 106
92746: PUSH
92747: LD_INT 107
92749: PUSH
92750: LD_INT 108
92752: PUSH
92753: LD_INT 109
92755: PUSH
92756: LD_INT 110
92758: PUSH
92759: LD_INT 111
92761: PUSH
92762: LD_INT 112
92764: PUSH
92765: LD_INT 113
92767: PUSH
92768: LD_INT 114
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: ST_TO_ADDR
92791: GO 94162
92793: LD_INT 13
92795: DOUBLE
92796: EQUAL
92797: IFTRUE 92801
92799: GO 92997
92801: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
92802: LD_ADDR_VAR 0 1
92806: PUSH
92807: LD_INT 1
92809: PUSH
92810: LD_INT 2
92812: PUSH
92813: LD_INT 3
92815: PUSH
92816: LD_INT 4
92818: PUSH
92819: LD_INT 5
92821: PUSH
92822: LD_INT 8
92824: PUSH
92825: LD_INT 9
92827: PUSH
92828: LD_INT 10
92830: PUSH
92831: LD_INT 11
92833: PUSH
92834: LD_INT 12
92836: PUSH
92837: LD_INT 14
92839: PUSH
92840: LD_INT 15
92842: PUSH
92843: LD_INT 16
92845: PUSH
92846: LD_INT 17
92848: PUSH
92849: LD_INT 18
92851: PUSH
92852: LD_INT 19
92854: PUSH
92855: LD_INT 20
92857: PUSH
92858: LD_INT 21
92860: PUSH
92861: LD_INT 22
92863: PUSH
92864: LD_INT 23
92866: PUSH
92867: LD_INT 24
92869: PUSH
92870: LD_INT 25
92872: PUSH
92873: LD_INT 26
92875: PUSH
92876: LD_INT 27
92878: PUSH
92879: LD_INT 28
92881: PUSH
92882: LD_INT 30
92884: PUSH
92885: LD_INT 31
92887: PUSH
92888: LD_INT 32
92890: PUSH
92891: LD_INT 33
92893: PUSH
92894: LD_INT 34
92896: PUSH
92897: LD_INT 36
92899: PUSH
92900: EMPTY
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: PUSH
92933: LD_INT 101
92935: PUSH
92936: LD_INT 102
92938: PUSH
92939: LD_INT 103
92941: PUSH
92942: LD_INT 104
92944: PUSH
92945: LD_INT 105
92947: PUSH
92948: LD_INT 106
92950: PUSH
92951: LD_INT 107
92953: PUSH
92954: LD_INT 108
92956: PUSH
92957: LD_INT 109
92959: PUSH
92960: LD_INT 110
92962: PUSH
92963: LD_INT 111
92965: PUSH
92966: LD_INT 112
92968: PUSH
92969: LD_INT 113
92971: PUSH
92972: LD_INT 114
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: PUSH
92991: EMPTY
92992: LIST
92993: LIST
92994: ST_TO_ADDR
92995: GO 94162
92997: LD_INT 14
92999: DOUBLE
93000: EQUAL
93001: IFTRUE 93005
93003: GO 93217
93005: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
93006: LD_ADDR_VAR 0 1
93010: PUSH
93011: LD_INT 1
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: LD_INT 3
93019: PUSH
93020: LD_INT 4
93022: PUSH
93023: LD_INT 5
93025: PUSH
93026: LD_INT 6
93028: PUSH
93029: LD_INT 7
93031: PUSH
93032: LD_INT 8
93034: PUSH
93035: LD_INT 9
93037: PUSH
93038: LD_INT 10
93040: PUSH
93041: LD_INT 11
93043: PUSH
93044: LD_INT 12
93046: PUSH
93047: LD_INT 13
93049: PUSH
93050: LD_INT 14
93052: PUSH
93053: LD_INT 15
93055: PUSH
93056: LD_INT 16
93058: PUSH
93059: LD_INT 17
93061: PUSH
93062: LD_INT 18
93064: PUSH
93065: LD_INT 19
93067: PUSH
93068: LD_INT 20
93070: PUSH
93071: LD_INT 21
93073: PUSH
93074: LD_INT 22
93076: PUSH
93077: LD_INT 23
93079: PUSH
93080: LD_INT 24
93082: PUSH
93083: LD_INT 25
93085: PUSH
93086: LD_INT 26
93088: PUSH
93089: LD_INT 27
93091: PUSH
93092: LD_INT 28
93094: PUSH
93095: LD_INT 29
93097: PUSH
93098: LD_INT 30
93100: PUSH
93101: LD_INT 31
93103: PUSH
93104: LD_INT 32
93106: PUSH
93107: LD_INT 33
93109: PUSH
93110: LD_INT 34
93112: PUSH
93113: LD_INT 36
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: PUSH
93153: LD_INT 101
93155: PUSH
93156: LD_INT 102
93158: PUSH
93159: LD_INT 103
93161: PUSH
93162: LD_INT 104
93164: PUSH
93165: LD_INT 105
93167: PUSH
93168: LD_INT 106
93170: PUSH
93171: LD_INT 107
93173: PUSH
93174: LD_INT 108
93176: PUSH
93177: LD_INT 109
93179: PUSH
93180: LD_INT 110
93182: PUSH
93183: LD_INT 111
93185: PUSH
93186: LD_INT 112
93188: PUSH
93189: LD_INT 113
93191: PUSH
93192: LD_INT 114
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: ST_TO_ADDR
93215: GO 94162
93217: LD_INT 15
93219: DOUBLE
93220: EQUAL
93221: IFTRUE 93225
93223: GO 93437
93225: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
93226: LD_ADDR_VAR 0 1
93230: PUSH
93231: LD_INT 1
93233: PUSH
93234: LD_INT 2
93236: PUSH
93237: LD_INT 3
93239: PUSH
93240: LD_INT 4
93242: PUSH
93243: LD_INT 5
93245: PUSH
93246: LD_INT 6
93248: PUSH
93249: LD_INT 7
93251: PUSH
93252: LD_INT 8
93254: PUSH
93255: LD_INT 9
93257: PUSH
93258: LD_INT 10
93260: PUSH
93261: LD_INT 11
93263: PUSH
93264: LD_INT 12
93266: PUSH
93267: LD_INT 13
93269: PUSH
93270: LD_INT 14
93272: PUSH
93273: LD_INT 15
93275: PUSH
93276: LD_INT 16
93278: PUSH
93279: LD_INT 17
93281: PUSH
93282: LD_INT 18
93284: PUSH
93285: LD_INT 19
93287: PUSH
93288: LD_INT 20
93290: PUSH
93291: LD_INT 21
93293: PUSH
93294: LD_INT 22
93296: PUSH
93297: LD_INT 23
93299: PUSH
93300: LD_INT 24
93302: PUSH
93303: LD_INT 25
93305: PUSH
93306: LD_INT 26
93308: PUSH
93309: LD_INT 27
93311: PUSH
93312: LD_INT 28
93314: PUSH
93315: LD_INT 29
93317: PUSH
93318: LD_INT 30
93320: PUSH
93321: LD_INT 31
93323: PUSH
93324: LD_INT 32
93326: PUSH
93327: LD_INT 33
93329: PUSH
93330: LD_INT 34
93332: PUSH
93333: LD_INT 36
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: PUSH
93373: LD_INT 101
93375: PUSH
93376: LD_INT 102
93378: PUSH
93379: LD_INT 103
93381: PUSH
93382: LD_INT 104
93384: PUSH
93385: LD_INT 105
93387: PUSH
93388: LD_INT 106
93390: PUSH
93391: LD_INT 107
93393: PUSH
93394: LD_INT 108
93396: PUSH
93397: LD_INT 109
93399: PUSH
93400: LD_INT 110
93402: PUSH
93403: LD_INT 111
93405: PUSH
93406: LD_INT 112
93408: PUSH
93409: LD_INT 113
93411: PUSH
93412: LD_INT 114
93414: PUSH
93415: EMPTY
93416: LIST
93417: LIST
93418: LIST
93419: LIST
93420: LIST
93421: LIST
93422: LIST
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: ST_TO_ADDR
93435: GO 94162
93437: LD_INT 16
93439: DOUBLE
93440: EQUAL
93441: IFTRUE 93445
93443: GO 93569
93445: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
93446: LD_ADDR_VAR 0 1
93450: PUSH
93451: LD_INT 2
93453: PUSH
93454: LD_INT 4
93456: PUSH
93457: LD_INT 5
93459: PUSH
93460: LD_INT 7
93462: PUSH
93463: LD_INT 11
93465: PUSH
93466: LD_INT 12
93468: PUSH
93469: LD_INT 15
93471: PUSH
93472: LD_INT 16
93474: PUSH
93475: LD_INT 20
93477: PUSH
93478: LD_INT 21
93480: PUSH
93481: LD_INT 22
93483: PUSH
93484: LD_INT 23
93486: PUSH
93487: LD_INT 25
93489: PUSH
93490: LD_INT 26
93492: PUSH
93493: LD_INT 30
93495: PUSH
93496: LD_INT 31
93498: PUSH
93499: LD_INT 32
93501: PUSH
93502: LD_INT 33
93504: PUSH
93505: LD_INT 34
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: PUSH
93529: LD_INT 101
93531: PUSH
93532: LD_INT 102
93534: PUSH
93535: LD_INT 103
93537: PUSH
93538: LD_INT 106
93540: PUSH
93541: LD_INT 108
93543: PUSH
93544: LD_INT 112
93546: PUSH
93547: LD_INT 113
93549: PUSH
93550: LD_INT 114
93552: PUSH
93553: EMPTY
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: PUSH
93563: EMPTY
93564: LIST
93565: LIST
93566: ST_TO_ADDR
93567: GO 94162
93569: LD_INT 17
93571: DOUBLE
93572: EQUAL
93573: IFTRUE 93577
93575: GO 93789
93577: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
93578: LD_ADDR_VAR 0 1
93582: PUSH
93583: LD_INT 1
93585: PUSH
93586: LD_INT 2
93588: PUSH
93589: LD_INT 3
93591: PUSH
93592: LD_INT 4
93594: PUSH
93595: LD_INT 5
93597: PUSH
93598: LD_INT 6
93600: PUSH
93601: LD_INT 7
93603: PUSH
93604: LD_INT 8
93606: PUSH
93607: LD_INT 9
93609: PUSH
93610: LD_INT 10
93612: PUSH
93613: LD_INT 11
93615: PUSH
93616: LD_INT 12
93618: PUSH
93619: LD_INT 13
93621: PUSH
93622: LD_INT 14
93624: PUSH
93625: LD_INT 15
93627: PUSH
93628: LD_INT 16
93630: PUSH
93631: LD_INT 17
93633: PUSH
93634: LD_INT 18
93636: PUSH
93637: LD_INT 19
93639: PUSH
93640: LD_INT 20
93642: PUSH
93643: LD_INT 21
93645: PUSH
93646: LD_INT 22
93648: PUSH
93649: LD_INT 23
93651: PUSH
93652: LD_INT 24
93654: PUSH
93655: LD_INT 25
93657: PUSH
93658: LD_INT 26
93660: PUSH
93661: LD_INT 27
93663: PUSH
93664: LD_INT 28
93666: PUSH
93667: LD_INT 29
93669: PUSH
93670: LD_INT 30
93672: PUSH
93673: LD_INT 31
93675: PUSH
93676: LD_INT 32
93678: PUSH
93679: LD_INT 33
93681: PUSH
93682: LD_INT 34
93684: PUSH
93685: LD_INT 36
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: LIST
93708: LIST
93709: LIST
93710: LIST
93711: LIST
93712: LIST
93713: LIST
93714: LIST
93715: LIST
93716: LIST
93717: LIST
93718: LIST
93719: LIST
93720: LIST
93721: LIST
93722: LIST
93723: LIST
93724: PUSH
93725: LD_INT 101
93727: PUSH
93728: LD_INT 102
93730: PUSH
93731: LD_INT 103
93733: PUSH
93734: LD_INT 104
93736: PUSH
93737: LD_INT 105
93739: PUSH
93740: LD_INT 106
93742: PUSH
93743: LD_INT 107
93745: PUSH
93746: LD_INT 108
93748: PUSH
93749: LD_INT 109
93751: PUSH
93752: LD_INT 110
93754: PUSH
93755: LD_INT 111
93757: PUSH
93758: LD_INT 112
93760: PUSH
93761: LD_INT 113
93763: PUSH
93764: LD_INT 114
93766: PUSH
93767: EMPTY
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: LIST
93779: LIST
93780: LIST
93781: LIST
93782: PUSH
93783: EMPTY
93784: LIST
93785: LIST
93786: ST_TO_ADDR
93787: GO 94162
93789: LD_INT 18
93791: DOUBLE
93792: EQUAL
93793: IFTRUE 93797
93795: GO 93933
93797: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
93798: LD_ADDR_VAR 0 1
93802: PUSH
93803: LD_INT 2
93805: PUSH
93806: LD_INT 4
93808: PUSH
93809: LD_INT 5
93811: PUSH
93812: LD_INT 7
93814: PUSH
93815: LD_INT 11
93817: PUSH
93818: LD_INT 12
93820: PUSH
93821: LD_INT 15
93823: PUSH
93824: LD_INT 16
93826: PUSH
93827: LD_INT 20
93829: PUSH
93830: LD_INT 21
93832: PUSH
93833: LD_INT 22
93835: PUSH
93836: LD_INT 23
93838: PUSH
93839: LD_INT 25
93841: PUSH
93842: LD_INT 26
93844: PUSH
93845: LD_INT 30
93847: PUSH
93848: LD_INT 31
93850: PUSH
93851: LD_INT 32
93853: PUSH
93854: LD_INT 33
93856: PUSH
93857: LD_INT 34
93859: PUSH
93860: LD_INT 35
93862: PUSH
93863: LD_INT 36
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: PUSH
93889: LD_INT 101
93891: PUSH
93892: LD_INT 102
93894: PUSH
93895: LD_INT 103
93897: PUSH
93898: LD_INT 106
93900: PUSH
93901: LD_INT 108
93903: PUSH
93904: LD_INT 112
93906: PUSH
93907: LD_INT 113
93909: PUSH
93910: LD_INT 114
93912: PUSH
93913: LD_INT 115
93915: PUSH
93916: EMPTY
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: ST_TO_ADDR
93931: GO 94162
93933: LD_INT 19
93935: DOUBLE
93936: EQUAL
93937: IFTRUE 93941
93939: GO 94161
93941: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
93942: LD_ADDR_VAR 0 1
93946: PUSH
93947: LD_INT 1
93949: PUSH
93950: LD_INT 2
93952: PUSH
93953: LD_INT 3
93955: PUSH
93956: LD_INT 4
93958: PUSH
93959: LD_INT 5
93961: PUSH
93962: LD_INT 6
93964: PUSH
93965: LD_INT 7
93967: PUSH
93968: LD_INT 8
93970: PUSH
93971: LD_INT 9
93973: PUSH
93974: LD_INT 10
93976: PUSH
93977: LD_INT 11
93979: PUSH
93980: LD_INT 12
93982: PUSH
93983: LD_INT 13
93985: PUSH
93986: LD_INT 14
93988: PUSH
93989: LD_INT 15
93991: PUSH
93992: LD_INT 16
93994: PUSH
93995: LD_INT 17
93997: PUSH
93998: LD_INT 18
94000: PUSH
94001: LD_INT 19
94003: PUSH
94004: LD_INT 20
94006: PUSH
94007: LD_INT 21
94009: PUSH
94010: LD_INT 22
94012: PUSH
94013: LD_INT 23
94015: PUSH
94016: LD_INT 24
94018: PUSH
94019: LD_INT 25
94021: PUSH
94022: LD_INT 26
94024: PUSH
94025: LD_INT 27
94027: PUSH
94028: LD_INT 28
94030: PUSH
94031: LD_INT 29
94033: PUSH
94034: LD_INT 30
94036: PUSH
94037: LD_INT 31
94039: PUSH
94040: LD_INT 32
94042: PUSH
94043: LD_INT 33
94045: PUSH
94046: LD_INT 34
94048: PUSH
94049: LD_INT 35
94051: PUSH
94052: LD_INT 36
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: LIST
94073: LIST
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 101
94095: PUSH
94096: LD_INT 102
94098: PUSH
94099: LD_INT 103
94101: PUSH
94102: LD_INT 104
94104: PUSH
94105: LD_INT 105
94107: PUSH
94108: LD_INT 106
94110: PUSH
94111: LD_INT 107
94113: PUSH
94114: LD_INT 108
94116: PUSH
94117: LD_INT 109
94119: PUSH
94120: LD_INT 110
94122: PUSH
94123: LD_INT 111
94125: PUSH
94126: LD_INT 112
94128: PUSH
94129: LD_INT 113
94131: PUSH
94132: LD_INT 114
94134: PUSH
94135: LD_INT 115
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: PUSH
94155: EMPTY
94156: LIST
94157: LIST
94158: ST_TO_ADDR
94159: GO 94162
94161: POP
// end else
94162: GO 94381
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
94164: LD_ADDR_VAR 0 1
94168: PUSH
94169: LD_INT 1
94171: PUSH
94172: LD_INT 2
94174: PUSH
94175: LD_INT 3
94177: PUSH
94178: LD_INT 4
94180: PUSH
94181: LD_INT 5
94183: PUSH
94184: LD_INT 6
94186: PUSH
94187: LD_INT 7
94189: PUSH
94190: LD_INT 8
94192: PUSH
94193: LD_INT 9
94195: PUSH
94196: LD_INT 10
94198: PUSH
94199: LD_INT 11
94201: PUSH
94202: LD_INT 12
94204: PUSH
94205: LD_INT 13
94207: PUSH
94208: LD_INT 14
94210: PUSH
94211: LD_INT 15
94213: PUSH
94214: LD_INT 16
94216: PUSH
94217: LD_INT 17
94219: PUSH
94220: LD_INT 18
94222: PUSH
94223: LD_INT 19
94225: PUSH
94226: LD_INT 20
94228: PUSH
94229: LD_INT 21
94231: PUSH
94232: LD_INT 22
94234: PUSH
94235: LD_INT 23
94237: PUSH
94238: LD_INT 24
94240: PUSH
94241: LD_INT 25
94243: PUSH
94244: LD_INT 26
94246: PUSH
94247: LD_INT 27
94249: PUSH
94250: LD_INT 28
94252: PUSH
94253: LD_INT 29
94255: PUSH
94256: LD_INT 30
94258: PUSH
94259: LD_INT 31
94261: PUSH
94262: LD_INT 32
94264: PUSH
94265: LD_INT 33
94267: PUSH
94268: LD_INT 34
94270: PUSH
94271: LD_INT 35
94273: PUSH
94274: LD_INT 36
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: LIST
94305: LIST
94306: LIST
94307: LIST
94308: LIST
94309: LIST
94310: LIST
94311: LIST
94312: LIST
94313: LIST
94314: PUSH
94315: LD_INT 101
94317: PUSH
94318: LD_INT 102
94320: PUSH
94321: LD_INT 103
94323: PUSH
94324: LD_INT 104
94326: PUSH
94327: LD_INT 105
94329: PUSH
94330: LD_INT 106
94332: PUSH
94333: LD_INT 107
94335: PUSH
94336: LD_INT 108
94338: PUSH
94339: LD_INT 109
94341: PUSH
94342: LD_INT 110
94344: PUSH
94345: LD_INT 111
94347: PUSH
94348: LD_INT 112
94350: PUSH
94351: LD_INT 113
94353: PUSH
94354: LD_INT 114
94356: PUSH
94357: LD_INT 115
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: ST_TO_ADDR
// if result then
94381: LD_VAR 0 1
94385: IFFALSE 94674
// begin normal :=  ;
94387: LD_ADDR_VAR 0 3
94391: PUSH
94392: LD_STRING 
94394: ST_TO_ADDR
// hardcore :=  ;
94395: LD_ADDR_VAR 0 4
94399: PUSH
94400: LD_STRING 
94402: ST_TO_ADDR
// for i = 1 to normalCounter do
94403: LD_ADDR_VAR 0 5
94407: PUSH
94408: DOUBLE
94409: LD_INT 1
94411: DEC
94412: ST_TO_ADDR
94413: LD_EXP 99
94417: PUSH
94418: FOR_TO
94419: IFFALSE 94520
// begin tmp := 0 ;
94421: LD_ADDR_VAR 0 2
94425: PUSH
94426: LD_STRING 0
94428: ST_TO_ADDR
// if result [ 1 ] then
94429: LD_VAR 0 1
94433: PUSH
94434: LD_INT 1
94436: ARRAY
94437: IFFALSE 94502
// if result [ 1 ] [ 1 ] = i then
94439: LD_VAR 0 1
94443: PUSH
94444: LD_INT 1
94446: ARRAY
94447: PUSH
94448: LD_INT 1
94450: ARRAY
94451: PUSH
94452: LD_VAR 0 5
94456: EQUAL
94457: IFFALSE 94502
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
94459: LD_ADDR_VAR 0 1
94463: PUSH
94464: LD_VAR 0 1
94468: PPUSH
94469: LD_INT 1
94471: PPUSH
94472: LD_VAR 0 1
94476: PUSH
94477: LD_INT 1
94479: ARRAY
94480: PPUSH
94481: LD_INT 1
94483: PPUSH
94484: CALL_OW 3
94488: PPUSH
94489: CALL_OW 1
94493: ST_TO_ADDR
// tmp := 1 ;
94494: LD_ADDR_VAR 0 2
94498: PUSH
94499: LD_STRING 1
94501: ST_TO_ADDR
// end ; normal := normal & tmp ;
94502: LD_ADDR_VAR 0 3
94506: PUSH
94507: LD_VAR 0 3
94511: PUSH
94512: LD_VAR 0 2
94516: STR
94517: ST_TO_ADDR
// end ;
94518: GO 94418
94520: POP
94521: POP
// for i = 1 to hardcoreCounter do
94522: LD_ADDR_VAR 0 5
94526: PUSH
94527: DOUBLE
94528: LD_INT 1
94530: DEC
94531: ST_TO_ADDR
94532: LD_EXP 100
94536: PUSH
94537: FOR_TO
94538: IFFALSE 94643
// begin tmp := 0 ;
94540: LD_ADDR_VAR 0 2
94544: PUSH
94545: LD_STRING 0
94547: ST_TO_ADDR
// if result [ 2 ] then
94548: LD_VAR 0 1
94552: PUSH
94553: LD_INT 2
94555: ARRAY
94556: IFFALSE 94625
// if result [ 2 ] [ 1 ] = 100 + i then
94558: LD_VAR 0 1
94562: PUSH
94563: LD_INT 2
94565: ARRAY
94566: PUSH
94567: LD_INT 1
94569: ARRAY
94570: PUSH
94571: LD_INT 100
94573: PUSH
94574: LD_VAR 0 5
94578: PLUS
94579: EQUAL
94580: IFFALSE 94625
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
94582: LD_ADDR_VAR 0 1
94586: PUSH
94587: LD_VAR 0 1
94591: PPUSH
94592: LD_INT 2
94594: PPUSH
94595: LD_VAR 0 1
94599: PUSH
94600: LD_INT 2
94602: ARRAY
94603: PPUSH
94604: LD_INT 1
94606: PPUSH
94607: CALL_OW 3
94611: PPUSH
94612: CALL_OW 1
94616: ST_TO_ADDR
// tmp := 1 ;
94617: LD_ADDR_VAR 0 2
94621: PUSH
94622: LD_STRING 1
94624: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
94625: LD_ADDR_VAR 0 4
94629: PUSH
94630: LD_VAR 0 4
94634: PUSH
94635: LD_VAR 0 2
94639: STR
94640: ST_TO_ADDR
// end ;
94641: GO 94537
94643: POP
94644: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
94645: LD_STRING getStreamItemsFromMission("
94647: PUSH
94648: LD_VAR 0 3
94652: STR
94653: PUSH
94654: LD_STRING ","
94656: STR
94657: PUSH
94658: LD_VAR 0 4
94662: STR
94663: PUSH
94664: LD_STRING ")
94666: STR
94667: PPUSH
94668: CALL_OW 559
// end else
94672: GO 94681
// ToLua ( getStreamItemsFromMission("","") ) ;
94674: LD_STRING getStreamItemsFromMission("","")
94676: PPUSH
94677: CALL_OW 559
// end ;
94681: LD_VAR 0 1
94685: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
94686: LD_EXP 98
94690: PUSH
94691: LD_EXP 103
94695: AND
94696: IFFALSE 94820
94698: GO 94700
94700: DISABLE
94701: LD_INT 0
94703: PPUSH
94704: PPUSH
// begin enable ;
94705: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
94706: LD_ADDR_VAR 0 2
94710: PUSH
94711: LD_INT 22
94713: PUSH
94714: LD_OWVAR 2
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 2
94725: PUSH
94726: LD_INT 34
94728: PUSH
94729: LD_INT 7
94731: PUSH
94732: EMPTY
94733: LIST
94734: LIST
94735: PUSH
94736: LD_INT 34
94738: PUSH
94739: LD_INT 45
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: PUSH
94746: LD_INT 34
94748: PUSH
94749: LD_INT 28
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: PUSH
94756: LD_INT 34
94758: PUSH
94759: LD_INT 47
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: PUSH
94773: EMPTY
94774: LIST
94775: LIST
94776: PPUSH
94777: CALL_OW 69
94781: ST_TO_ADDR
// if not tmp then
94782: LD_VAR 0 2
94786: NOT
94787: IFFALSE 94791
// exit ;
94789: GO 94820
// for i in tmp do
94791: LD_ADDR_VAR 0 1
94795: PUSH
94796: LD_VAR 0 2
94800: PUSH
94801: FOR_IN
94802: IFFALSE 94818
// begin SetLives ( i , 0 ) ;
94804: LD_VAR 0 1
94808: PPUSH
94809: LD_INT 0
94811: PPUSH
94812: CALL_OW 234
// end ;
94816: GO 94801
94818: POP
94819: POP
// end ;
94820: PPOPN 2
94822: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
94823: LD_EXP 98
94827: PUSH
94828: LD_EXP 104
94832: AND
94833: IFFALSE 94917
94835: GO 94837
94837: DISABLE
94838: LD_INT 0
94840: PPUSH
94841: PPUSH
// begin enable ;
94842: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
94843: LD_ADDR_VAR 0 2
94847: PUSH
94848: LD_INT 22
94850: PUSH
94851: LD_OWVAR 2
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: LD_INT 32
94862: PUSH
94863: LD_INT 3
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: EMPTY
94871: LIST
94872: LIST
94873: PPUSH
94874: CALL_OW 69
94878: ST_TO_ADDR
// if not tmp then
94879: LD_VAR 0 2
94883: NOT
94884: IFFALSE 94888
// exit ;
94886: GO 94917
// for i in tmp do
94888: LD_ADDR_VAR 0 1
94892: PUSH
94893: LD_VAR 0 2
94897: PUSH
94898: FOR_IN
94899: IFFALSE 94915
// begin SetLives ( i , 0 ) ;
94901: LD_VAR 0 1
94905: PPUSH
94906: LD_INT 0
94908: PPUSH
94909: CALL_OW 234
// end ;
94913: GO 94898
94915: POP
94916: POP
// end ;
94917: PPOPN 2
94919: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94920: LD_EXP 98
94924: PUSH
94925: LD_EXP 101
94929: AND
94930: IFFALSE 95023
94932: GO 94934
94934: DISABLE
94935: LD_INT 0
94937: PPUSH
// begin enable ;
94938: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94939: LD_ADDR_VAR 0 1
94943: PUSH
94944: LD_INT 22
94946: PUSH
94947: LD_OWVAR 2
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 2
94958: PUSH
94959: LD_INT 25
94961: PUSH
94962: LD_INT 5
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 25
94971: PUSH
94972: LD_INT 9
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: LD_INT 25
94981: PUSH
94982: LD_INT 8
94984: PUSH
94985: EMPTY
94986: LIST
94987: LIST
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: LIST
94993: LIST
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PPUSH
94999: CALL_OW 69
95003: PUSH
95004: FOR_IN
95005: IFFALSE 95021
// begin SetClass ( i , 1 ) ;
95007: LD_VAR 0 1
95011: PPUSH
95012: LD_INT 1
95014: PPUSH
95015: CALL_OW 336
// end ;
95019: GO 95004
95021: POP
95022: POP
// end ;
95023: PPOPN 1
95025: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
95026: LD_EXP 98
95030: PUSH
95031: LD_EXP 102
95035: AND
95036: PUSH
95037: LD_OWVAR 65
95041: PUSH
95042: LD_INT 7
95044: LESS
95045: AND
95046: IFFALSE 95060
95048: GO 95050
95050: DISABLE
// begin enable ;
95051: ENABLE
// game_speed := 7 ;
95052: LD_ADDR_OWVAR 65
95056: PUSH
95057: LD_INT 7
95059: ST_TO_ADDR
// end ;
95060: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
95061: LD_EXP 98
95065: PUSH
95066: LD_EXP 105
95070: AND
95071: IFFALSE 95273
95073: GO 95075
95075: DISABLE
95076: LD_INT 0
95078: PPUSH
95079: PPUSH
95080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
95081: LD_ADDR_VAR 0 3
95085: PUSH
95086: LD_INT 81
95088: PUSH
95089: LD_OWVAR 2
95093: PUSH
95094: EMPTY
95095: LIST
95096: LIST
95097: PUSH
95098: LD_INT 21
95100: PUSH
95101: LD_INT 1
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: EMPTY
95109: LIST
95110: LIST
95111: PPUSH
95112: CALL_OW 69
95116: ST_TO_ADDR
// if not tmp then
95117: LD_VAR 0 3
95121: NOT
95122: IFFALSE 95126
// exit ;
95124: GO 95273
// if tmp > 5 then
95126: LD_VAR 0 3
95130: PUSH
95131: LD_INT 5
95133: GREATER
95134: IFFALSE 95146
// k := 5 else
95136: LD_ADDR_VAR 0 2
95140: PUSH
95141: LD_INT 5
95143: ST_TO_ADDR
95144: GO 95156
// k := tmp ;
95146: LD_ADDR_VAR 0 2
95150: PUSH
95151: LD_VAR 0 3
95155: ST_TO_ADDR
// for i := 1 to k do
95156: LD_ADDR_VAR 0 1
95160: PUSH
95161: DOUBLE
95162: LD_INT 1
95164: DEC
95165: ST_TO_ADDR
95166: LD_VAR 0 2
95170: PUSH
95171: FOR_TO
95172: IFFALSE 95271
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
95174: LD_VAR 0 3
95178: PUSH
95179: LD_VAR 0 1
95183: ARRAY
95184: PPUSH
95185: LD_VAR 0 1
95189: PUSH
95190: LD_INT 4
95192: MOD
95193: PUSH
95194: LD_INT 1
95196: PLUS
95197: PPUSH
95198: CALL_OW 259
95202: PUSH
95203: LD_INT 10
95205: LESS
95206: IFFALSE 95269
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
95208: LD_VAR 0 3
95212: PUSH
95213: LD_VAR 0 1
95217: ARRAY
95218: PPUSH
95219: LD_VAR 0 1
95223: PUSH
95224: LD_INT 4
95226: MOD
95227: PUSH
95228: LD_INT 1
95230: PLUS
95231: PPUSH
95232: LD_VAR 0 3
95236: PUSH
95237: LD_VAR 0 1
95241: ARRAY
95242: PPUSH
95243: LD_VAR 0 1
95247: PUSH
95248: LD_INT 4
95250: MOD
95251: PUSH
95252: LD_INT 1
95254: PLUS
95255: PPUSH
95256: CALL_OW 259
95260: PUSH
95261: LD_INT 1
95263: PLUS
95264: PPUSH
95265: CALL_OW 237
95269: GO 95171
95271: POP
95272: POP
// end ;
95273: PPOPN 3
95275: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
95276: LD_EXP 98
95280: PUSH
95281: LD_EXP 106
95285: AND
95286: IFFALSE 95306
95288: GO 95290
95290: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
95291: LD_INT 4
95293: PPUSH
95294: LD_OWVAR 2
95298: PPUSH
95299: LD_INT 0
95301: PPUSH
95302: CALL_OW 324
95306: END
// every 0 0$1 trigger StreamModeActive and sShovel do
95307: LD_EXP 98
95311: PUSH
95312: LD_EXP 135
95316: AND
95317: IFFALSE 95337
95319: GO 95321
95321: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
95322: LD_INT 19
95324: PPUSH
95325: LD_OWVAR 2
95329: PPUSH
95330: LD_INT 0
95332: PPUSH
95333: CALL_OW 324
95337: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
95338: LD_EXP 98
95342: PUSH
95343: LD_EXP 107
95347: AND
95348: IFFALSE 95450
95350: GO 95352
95352: DISABLE
95353: LD_INT 0
95355: PPUSH
95356: PPUSH
// begin enable ;
95357: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
95358: LD_ADDR_VAR 0 2
95362: PUSH
95363: LD_INT 22
95365: PUSH
95366: LD_OWVAR 2
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 2
95377: PUSH
95378: LD_INT 34
95380: PUSH
95381: LD_INT 11
95383: PUSH
95384: EMPTY
95385: LIST
95386: LIST
95387: PUSH
95388: LD_INT 34
95390: PUSH
95391: LD_INT 30
95393: PUSH
95394: EMPTY
95395: LIST
95396: LIST
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: LIST
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PPUSH
95407: CALL_OW 69
95411: ST_TO_ADDR
// if not tmp then
95412: LD_VAR 0 2
95416: NOT
95417: IFFALSE 95421
// exit ;
95419: GO 95450
// for i in tmp do
95421: LD_ADDR_VAR 0 1
95425: PUSH
95426: LD_VAR 0 2
95430: PUSH
95431: FOR_IN
95432: IFFALSE 95448
// begin SetLives ( i , 0 ) ;
95434: LD_VAR 0 1
95438: PPUSH
95439: LD_INT 0
95441: PPUSH
95442: CALL_OW 234
// end ;
95446: GO 95431
95448: POP
95449: POP
// end ;
95450: PPOPN 2
95452: END
// every 0 0$1 trigger StreamModeActive and sBunker do
95453: LD_EXP 98
95457: PUSH
95458: LD_EXP 108
95462: AND
95463: IFFALSE 95483
95465: GO 95467
95467: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
95468: LD_INT 32
95470: PPUSH
95471: LD_OWVAR 2
95475: PPUSH
95476: LD_INT 0
95478: PPUSH
95479: CALL_OW 324
95483: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
95484: LD_EXP 98
95488: PUSH
95489: LD_EXP 109
95493: AND
95494: IFFALSE 95675
95496: GO 95498
95498: DISABLE
95499: LD_INT 0
95501: PPUSH
95502: PPUSH
95503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
95504: LD_ADDR_VAR 0 2
95508: PUSH
95509: LD_INT 22
95511: PUSH
95512: LD_OWVAR 2
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 33
95523: PUSH
95524: LD_INT 3
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: PPUSH
95535: CALL_OW 69
95539: ST_TO_ADDR
// if not tmp then
95540: LD_VAR 0 2
95544: NOT
95545: IFFALSE 95549
// exit ;
95547: GO 95675
// side := 0 ;
95549: LD_ADDR_VAR 0 3
95553: PUSH
95554: LD_INT 0
95556: ST_TO_ADDR
// for i := 1 to 8 do
95557: LD_ADDR_VAR 0 1
95561: PUSH
95562: DOUBLE
95563: LD_INT 1
95565: DEC
95566: ST_TO_ADDR
95567: LD_INT 8
95569: PUSH
95570: FOR_TO
95571: IFFALSE 95619
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
95573: LD_OWVAR 2
95577: PUSH
95578: LD_VAR 0 1
95582: NONEQUAL
95583: PUSH
95584: LD_OWVAR 2
95588: PPUSH
95589: LD_VAR 0 1
95593: PPUSH
95594: CALL_OW 81
95598: PUSH
95599: LD_INT 2
95601: EQUAL
95602: AND
95603: IFFALSE 95617
// begin side := i ;
95605: LD_ADDR_VAR 0 3
95609: PUSH
95610: LD_VAR 0 1
95614: ST_TO_ADDR
// break ;
95615: GO 95619
// end ;
95617: GO 95570
95619: POP
95620: POP
// if not side then
95621: LD_VAR 0 3
95625: NOT
95626: IFFALSE 95630
// exit ;
95628: GO 95675
// for i := 1 to tmp do
95630: LD_ADDR_VAR 0 1
95634: PUSH
95635: DOUBLE
95636: LD_INT 1
95638: DEC
95639: ST_TO_ADDR
95640: LD_VAR 0 2
95644: PUSH
95645: FOR_TO
95646: IFFALSE 95673
// if Prob ( 60 ) then
95648: LD_INT 60
95650: PPUSH
95651: CALL_OW 13
95655: IFFALSE 95671
// SetSide ( i , side ) ;
95657: LD_VAR 0 1
95661: PPUSH
95662: LD_VAR 0 3
95666: PPUSH
95667: CALL_OW 235
95671: GO 95645
95673: POP
95674: POP
// end ;
95675: PPOPN 3
95677: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
95678: LD_EXP 98
95682: PUSH
95683: LD_EXP 111
95687: AND
95688: IFFALSE 95807
95690: GO 95692
95692: DISABLE
95693: LD_INT 0
95695: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
95696: LD_ADDR_VAR 0 1
95700: PUSH
95701: LD_INT 22
95703: PUSH
95704: LD_OWVAR 2
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 21
95715: PUSH
95716: LD_INT 1
95718: PUSH
95719: EMPTY
95720: LIST
95721: LIST
95722: PUSH
95723: LD_INT 3
95725: PUSH
95726: LD_INT 23
95728: PUSH
95729: LD_INT 0
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: LIST
95744: PPUSH
95745: CALL_OW 69
95749: PUSH
95750: FOR_IN
95751: IFFALSE 95805
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
95753: LD_VAR 0 1
95757: PPUSH
95758: CALL_OW 257
95762: PUSH
95763: LD_INT 1
95765: PUSH
95766: LD_INT 2
95768: PUSH
95769: LD_INT 3
95771: PUSH
95772: LD_INT 4
95774: PUSH
95775: EMPTY
95776: LIST
95777: LIST
95778: LIST
95779: LIST
95780: IN
95781: IFFALSE 95803
// SetClass ( un , rand ( 1 , 4 ) ) ;
95783: LD_VAR 0 1
95787: PPUSH
95788: LD_INT 1
95790: PPUSH
95791: LD_INT 4
95793: PPUSH
95794: CALL_OW 12
95798: PPUSH
95799: CALL_OW 336
95803: GO 95750
95805: POP
95806: POP
// end ;
95807: PPOPN 1
95809: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
95810: LD_EXP 98
95814: PUSH
95815: LD_EXP 110
95819: AND
95820: IFFALSE 95899
95822: GO 95824
95824: DISABLE
95825: LD_INT 0
95827: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95828: LD_ADDR_VAR 0 1
95832: PUSH
95833: LD_INT 22
95835: PUSH
95836: LD_OWVAR 2
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 21
95847: PUSH
95848: LD_INT 3
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PPUSH
95859: CALL_OW 69
95863: ST_TO_ADDR
// if not tmp then
95864: LD_VAR 0 1
95868: NOT
95869: IFFALSE 95873
// exit ;
95871: GO 95899
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
95873: LD_VAR 0 1
95877: PUSH
95878: LD_INT 1
95880: PPUSH
95881: LD_VAR 0 1
95885: PPUSH
95886: CALL_OW 12
95890: ARRAY
95891: PPUSH
95892: LD_INT 100
95894: PPUSH
95895: CALL_OW 234
// end ;
95899: PPOPN 1
95901: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95902: LD_EXP 98
95906: PUSH
95907: LD_EXP 112
95911: AND
95912: IFFALSE 96010
95914: GO 95916
95916: DISABLE
95917: LD_INT 0
95919: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95920: LD_ADDR_VAR 0 1
95924: PUSH
95925: LD_INT 22
95927: PUSH
95928: LD_OWVAR 2
95932: PUSH
95933: EMPTY
95934: LIST
95935: LIST
95936: PUSH
95937: LD_INT 21
95939: PUSH
95940: LD_INT 1
95942: PUSH
95943: EMPTY
95944: LIST
95945: LIST
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PPUSH
95951: CALL_OW 69
95955: ST_TO_ADDR
// if not tmp then
95956: LD_VAR 0 1
95960: NOT
95961: IFFALSE 95965
// exit ;
95963: GO 96010
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95965: LD_VAR 0 1
95969: PUSH
95970: LD_INT 1
95972: PPUSH
95973: LD_VAR 0 1
95977: PPUSH
95978: CALL_OW 12
95982: ARRAY
95983: PPUSH
95984: LD_INT 1
95986: PPUSH
95987: LD_INT 4
95989: PPUSH
95990: CALL_OW 12
95994: PPUSH
95995: LD_INT 3000
95997: PPUSH
95998: LD_INT 9000
96000: PPUSH
96001: CALL_OW 12
96005: PPUSH
96006: CALL_OW 492
// end ;
96010: PPOPN 1
96012: END
// every 0 0$1 trigger StreamModeActive and sDepot do
96013: LD_EXP 98
96017: PUSH
96018: LD_EXP 113
96022: AND
96023: IFFALSE 96043
96025: GO 96027
96027: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
96028: LD_INT 1
96030: PPUSH
96031: LD_OWVAR 2
96035: PPUSH
96036: LD_INT 0
96038: PPUSH
96039: CALL_OW 324
96043: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
96044: LD_EXP 98
96048: PUSH
96049: LD_EXP 114
96053: AND
96054: IFFALSE 96137
96056: GO 96058
96058: DISABLE
96059: LD_INT 0
96061: PPUSH
96062: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
96063: LD_ADDR_VAR 0 2
96067: PUSH
96068: LD_INT 22
96070: PUSH
96071: LD_OWVAR 2
96075: PUSH
96076: EMPTY
96077: LIST
96078: LIST
96079: PUSH
96080: LD_INT 21
96082: PUSH
96083: LD_INT 3
96085: PUSH
96086: EMPTY
96087: LIST
96088: LIST
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PPUSH
96094: CALL_OW 69
96098: ST_TO_ADDR
// if not tmp then
96099: LD_VAR 0 2
96103: NOT
96104: IFFALSE 96108
// exit ;
96106: GO 96137
// for i in tmp do
96108: LD_ADDR_VAR 0 1
96112: PUSH
96113: LD_VAR 0 2
96117: PUSH
96118: FOR_IN
96119: IFFALSE 96135
// SetBLevel ( i , 10 ) ;
96121: LD_VAR 0 1
96125: PPUSH
96126: LD_INT 10
96128: PPUSH
96129: CALL_OW 241
96133: GO 96118
96135: POP
96136: POP
// end ;
96137: PPOPN 2
96139: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
96140: LD_EXP 98
96144: PUSH
96145: LD_EXP 115
96149: AND
96150: IFFALSE 96261
96152: GO 96154
96154: DISABLE
96155: LD_INT 0
96157: PPUSH
96158: PPUSH
96159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96160: LD_ADDR_VAR 0 3
96164: PUSH
96165: LD_INT 22
96167: PUSH
96168: LD_OWVAR 2
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 25
96179: PUSH
96180: LD_INT 1
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PPUSH
96191: CALL_OW 69
96195: ST_TO_ADDR
// if not tmp then
96196: LD_VAR 0 3
96200: NOT
96201: IFFALSE 96205
// exit ;
96203: GO 96261
// un := tmp [ rand ( 1 , tmp ) ] ;
96205: LD_ADDR_VAR 0 2
96209: PUSH
96210: LD_VAR 0 3
96214: PUSH
96215: LD_INT 1
96217: PPUSH
96218: LD_VAR 0 3
96222: PPUSH
96223: CALL_OW 12
96227: ARRAY
96228: ST_TO_ADDR
// if Crawls ( un ) then
96229: LD_VAR 0 2
96233: PPUSH
96234: CALL_OW 318
96238: IFFALSE 96249
// ComWalk ( un ) ;
96240: LD_VAR 0 2
96244: PPUSH
96245: CALL_OW 138
// SetClass ( un , class_sniper ) ;
96249: LD_VAR 0 2
96253: PPUSH
96254: LD_INT 5
96256: PPUSH
96257: CALL_OW 336
// end ;
96261: PPOPN 3
96263: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
96264: LD_EXP 98
96268: PUSH
96269: LD_EXP 116
96273: AND
96274: PUSH
96275: LD_OWVAR 67
96279: PUSH
96280: LD_INT 3
96282: LESS
96283: AND
96284: IFFALSE 96303
96286: GO 96288
96288: DISABLE
// Difficulty := Difficulty + 1 ;
96289: LD_ADDR_OWVAR 67
96293: PUSH
96294: LD_OWVAR 67
96298: PUSH
96299: LD_INT 1
96301: PLUS
96302: ST_TO_ADDR
96303: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
96304: LD_EXP 98
96308: PUSH
96309: LD_EXP 117
96313: AND
96314: IFFALSE 96417
96316: GO 96318
96318: DISABLE
96319: LD_INT 0
96321: PPUSH
// begin for i := 1 to 5 do
96322: LD_ADDR_VAR 0 1
96326: PUSH
96327: DOUBLE
96328: LD_INT 1
96330: DEC
96331: ST_TO_ADDR
96332: LD_INT 5
96334: PUSH
96335: FOR_TO
96336: IFFALSE 96415
// begin uc_nation := nation_nature ;
96338: LD_ADDR_OWVAR 21
96342: PUSH
96343: LD_INT 0
96345: ST_TO_ADDR
// uc_side := 0 ;
96346: LD_ADDR_OWVAR 20
96350: PUSH
96351: LD_INT 0
96353: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96354: LD_ADDR_OWVAR 29
96358: PUSH
96359: LD_INT 12
96361: PUSH
96362: LD_INT 12
96364: PUSH
96365: EMPTY
96366: LIST
96367: LIST
96368: ST_TO_ADDR
// hc_agressivity := 20 ;
96369: LD_ADDR_OWVAR 35
96373: PUSH
96374: LD_INT 20
96376: ST_TO_ADDR
// hc_class := class_tiger ;
96377: LD_ADDR_OWVAR 28
96381: PUSH
96382: LD_INT 14
96384: ST_TO_ADDR
// hc_gallery :=  ;
96385: LD_ADDR_OWVAR 33
96389: PUSH
96390: LD_STRING 
96392: ST_TO_ADDR
// hc_name :=  ;
96393: LD_ADDR_OWVAR 26
96397: PUSH
96398: LD_STRING 
96400: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
96401: CALL_OW 44
96405: PPUSH
96406: LD_INT 0
96408: PPUSH
96409: CALL_OW 51
// end ;
96413: GO 96335
96415: POP
96416: POP
// end ;
96417: PPOPN 1
96419: END
// every 0 0$1 trigger StreamModeActive and sBomb do
96420: LD_EXP 98
96424: PUSH
96425: LD_EXP 118
96429: AND
96430: IFFALSE 96439
96432: GO 96434
96434: DISABLE
// StreamSibBomb ;
96435: CALL 96440 0 0
96439: END
// export function StreamSibBomb ; var i , x , y ; begin
96440: LD_INT 0
96442: PPUSH
96443: PPUSH
96444: PPUSH
96445: PPUSH
// result := false ;
96446: LD_ADDR_VAR 0 1
96450: PUSH
96451: LD_INT 0
96453: ST_TO_ADDR
// for i := 1 to 16 do
96454: LD_ADDR_VAR 0 2
96458: PUSH
96459: DOUBLE
96460: LD_INT 1
96462: DEC
96463: ST_TO_ADDR
96464: LD_INT 16
96466: PUSH
96467: FOR_TO
96468: IFFALSE 96667
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96470: LD_ADDR_VAR 0 3
96474: PUSH
96475: LD_INT 10
96477: PUSH
96478: LD_INT 20
96480: PUSH
96481: LD_INT 30
96483: PUSH
96484: LD_INT 40
96486: PUSH
96487: LD_INT 50
96489: PUSH
96490: LD_INT 60
96492: PUSH
96493: LD_INT 70
96495: PUSH
96496: LD_INT 80
96498: PUSH
96499: LD_INT 90
96501: PUSH
96502: LD_INT 100
96504: PUSH
96505: LD_INT 110
96507: PUSH
96508: LD_INT 120
96510: PUSH
96511: LD_INT 130
96513: PUSH
96514: LD_INT 140
96516: PUSH
96517: LD_INT 150
96519: PUSH
96520: EMPTY
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: PUSH
96537: LD_INT 1
96539: PPUSH
96540: LD_INT 15
96542: PPUSH
96543: CALL_OW 12
96547: ARRAY
96548: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
96549: LD_ADDR_VAR 0 4
96553: PUSH
96554: LD_INT 10
96556: PUSH
96557: LD_INT 20
96559: PUSH
96560: LD_INT 30
96562: PUSH
96563: LD_INT 40
96565: PUSH
96566: LD_INT 50
96568: PUSH
96569: LD_INT 60
96571: PUSH
96572: LD_INT 70
96574: PUSH
96575: LD_INT 80
96577: PUSH
96578: LD_INT 90
96580: PUSH
96581: LD_INT 100
96583: PUSH
96584: LD_INT 110
96586: PUSH
96587: LD_INT 120
96589: PUSH
96590: LD_INT 130
96592: PUSH
96593: LD_INT 140
96595: PUSH
96596: LD_INT 150
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: PUSH
96616: LD_INT 1
96618: PPUSH
96619: LD_INT 15
96621: PPUSH
96622: CALL_OW 12
96626: ARRAY
96627: ST_TO_ADDR
// if ValidHex ( x , y ) then
96628: LD_VAR 0 3
96632: PPUSH
96633: LD_VAR 0 4
96637: PPUSH
96638: CALL_OW 488
96642: IFFALSE 96665
// begin result := [ x , y ] ;
96644: LD_ADDR_VAR 0 1
96648: PUSH
96649: LD_VAR 0 3
96653: PUSH
96654: LD_VAR 0 4
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: ST_TO_ADDR
// break ;
96663: GO 96667
// end ; end ;
96665: GO 96467
96667: POP
96668: POP
// if result then
96669: LD_VAR 0 1
96673: IFFALSE 96733
// begin ToLua ( playSibBomb() ) ;
96675: LD_STRING playSibBomb()
96677: PPUSH
96678: CALL_OW 559
// wait ( 0 0$14 ) ;
96682: LD_INT 490
96684: PPUSH
96685: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
96689: LD_VAR 0 1
96693: PUSH
96694: LD_INT 1
96696: ARRAY
96697: PPUSH
96698: LD_VAR 0 1
96702: PUSH
96703: LD_INT 2
96705: ARRAY
96706: PPUSH
96707: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
96711: LD_VAR 0 1
96715: PUSH
96716: LD_INT 1
96718: ARRAY
96719: PPUSH
96720: LD_VAR 0 1
96724: PUSH
96725: LD_INT 2
96727: ARRAY
96728: PPUSH
96729: CALL_OW 429
// end ; end ;
96733: LD_VAR 0 1
96737: RET
// every 0 0$1 trigger StreamModeActive and sReset do
96738: LD_EXP 98
96742: PUSH
96743: LD_EXP 120
96747: AND
96748: IFFALSE 96760
96750: GO 96752
96752: DISABLE
// YouLost (  ) ;
96753: LD_STRING 
96755: PPUSH
96756: CALL_OW 104
96760: END
// every 0 0$1 trigger StreamModeActive and sFog do
96761: LD_EXP 98
96765: PUSH
96766: LD_EXP 119
96770: AND
96771: IFFALSE 96785
96773: GO 96775
96775: DISABLE
// FogOff ( your_side ) ;
96776: LD_OWVAR 2
96780: PPUSH
96781: CALL_OW 344
96785: END
// every 0 0$1 trigger StreamModeActive and sSun do
96786: LD_EXP 98
96790: PUSH
96791: LD_EXP 121
96795: AND
96796: IFFALSE 96824
96798: GO 96800
96800: DISABLE
// begin solar_recharge_percent := 0 ;
96801: LD_ADDR_OWVAR 79
96805: PUSH
96806: LD_INT 0
96808: ST_TO_ADDR
// wait ( 5 5$00 ) ;
96809: LD_INT 10500
96811: PPUSH
96812: CALL_OW 67
// solar_recharge_percent := 100 ;
96816: LD_ADDR_OWVAR 79
96820: PUSH
96821: LD_INT 100
96823: ST_TO_ADDR
// end ;
96824: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
96825: LD_EXP 98
96829: PUSH
96830: LD_EXP 122
96834: AND
96835: IFFALSE 97074
96837: GO 96839
96839: DISABLE
96840: LD_INT 0
96842: PPUSH
96843: PPUSH
96844: PPUSH
// begin tmp := [ ] ;
96845: LD_ADDR_VAR 0 3
96849: PUSH
96850: EMPTY
96851: ST_TO_ADDR
// for i := 1 to 6 do
96852: LD_ADDR_VAR 0 1
96856: PUSH
96857: DOUBLE
96858: LD_INT 1
96860: DEC
96861: ST_TO_ADDR
96862: LD_INT 6
96864: PUSH
96865: FOR_TO
96866: IFFALSE 96971
// begin uc_nation := nation_nature ;
96868: LD_ADDR_OWVAR 21
96872: PUSH
96873: LD_INT 0
96875: ST_TO_ADDR
// uc_side := 0 ;
96876: LD_ADDR_OWVAR 20
96880: PUSH
96881: LD_INT 0
96883: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96884: LD_ADDR_OWVAR 29
96888: PUSH
96889: LD_INT 12
96891: PUSH
96892: LD_INT 12
96894: PUSH
96895: EMPTY
96896: LIST
96897: LIST
96898: ST_TO_ADDR
// hc_agressivity := 20 ;
96899: LD_ADDR_OWVAR 35
96903: PUSH
96904: LD_INT 20
96906: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96907: LD_ADDR_OWVAR 28
96911: PUSH
96912: LD_INT 17
96914: ST_TO_ADDR
// hc_gallery :=  ;
96915: LD_ADDR_OWVAR 33
96919: PUSH
96920: LD_STRING 
96922: ST_TO_ADDR
// hc_name :=  ;
96923: LD_ADDR_OWVAR 26
96927: PUSH
96928: LD_STRING 
96930: ST_TO_ADDR
// un := CreateHuman ;
96931: LD_ADDR_VAR 0 2
96935: PUSH
96936: CALL_OW 44
96940: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96941: LD_VAR 0 2
96945: PPUSH
96946: LD_INT 1
96948: PPUSH
96949: CALL_OW 51
// tmp := tmp ^ un ;
96953: LD_ADDR_VAR 0 3
96957: PUSH
96958: LD_VAR 0 3
96962: PUSH
96963: LD_VAR 0 2
96967: ADD
96968: ST_TO_ADDR
// end ;
96969: GO 96865
96971: POP
96972: POP
// repeat wait ( 0 0$1 ) ;
96973: LD_INT 35
96975: PPUSH
96976: CALL_OW 67
// for un in tmp do
96980: LD_ADDR_VAR 0 2
96984: PUSH
96985: LD_VAR 0 3
96989: PUSH
96990: FOR_IN
96991: IFFALSE 97065
// begin if IsDead ( un ) then
96993: LD_VAR 0 2
96997: PPUSH
96998: CALL_OW 301
97002: IFFALSE 97022
// begin tmp := tmp diff un ;
97004: LD_ADDR_VAR 0 3
97008: PUSH
97009: LD_VAR 0 3
97013: PUSH
97014: LD_VAR 0 2
97018: DIFF
97019: ST_TO_ADDR
// continue ;
97020: GO 96990
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
97022: LD_VAR 0 2
97026: PPUSH
97027: LD_INT 3
97029: PUSH
97030: LD_INT 22
97032: PUSH
97033: LD_INT 0
97035: PUSH
97036: EMPTY
97037: LIST
97038: LIST
97039: PUSH
97040: EMPTY
97041: LIST
97042: LIST
97043: PPUSH
97044: CALL_OW 69
97048: PPUSH
97049: LD_VAR 0 2
97053: PPUSH
97054: CALL_OW 74
97058: PPUSH
97059: CALL_OW 115
// end ;
97063: GO 96990
97065: POP
97066: POP
// until not tmp ;
97067: LD_VAR 0 3
97071: NOT
97072: IFFALSE 96973
// end ;
97074: PPOPN 3
97076: END
// every 0 0$1 trigger StreamModeActive and sTroll do
97077: LD_EXP 98
97081: PUSH
97082: LD_EXP 123
97086: AND
97087: IFFALSE 97141
97089: GO 97091
97091: DISABLE
// begin ToLua ( displayTroll(); ) ;
97092: LD_STRING displayTroll();
97094: PPUSH
97095: CALL_OW 559
// wait ( 3 3$00 ) ;
97099: LD_INT 6300
97101: PPUSH
97102: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97106: LD_STRING hideTroll();
97108: PPUSH
97109: CALL_OW 559
// wait ( 1 1$00 ) ;
97113: LD_INT 2100
97115: PPUSH
97116: CALL_OW 67
// ToLua ( displayTroll(); ) ;
97120: LD_STRING displayTroll();
97122: PPUSH
97123: CALL_OW 559
// wait ( 1 1$00 ) ;
97127: LD_INT 2100
97129: PPUSH
97130: CALL_OW 67
// ToLua ( hideTroll(); ) ;
97134: LD_STRING hideTroll();
97136: PPUSH
97137: CALL_OW 559
// end ;
97141: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
97142: LD_EXP 98
97146: PUSH
97147: LD_EXP 124
97151: AND
97152: IFFALSE 97215
97154: GO 97156
97156: DISABLE
97157: LD_INT 0
97159: PPUSH
// begin p := 0 ;
97160: LD_ADDR_VAR 0 1
97164: PUSH
97165: LD_INT 0
97167: ST_TO_ADDR
// repeat game_speed := 1 ;
97168: LD_ADDR_OWVAR 65
97172: PUSH
97173: LD_INT 1
97175: ST_TO_ADDR
// wait ( 0 0$1 ) ;
97176: LD_INT 35
97178: PPUSH
97179: CALL_OW 67
// p := p + 1 ;
97183: LD_ADDR_VAR 0 1
97187: PUSH
97188: LD_VAR 0 1
97192: PUSH
97193: LD_INT 1
97195: PLUS
97196: ST_TO_ADDR
// until p >= 60 ;
97197: LD_VAR 0 1
97201: PUSH
97202: LD_INT 60
97204: GREATEREQUAL
97205: IFFALSE 97168
// game_speed := 4 ;
97207: LD_ADDR_OWVAR 65
97211: PUSH
97212: LD_INT 4
97214: ST_TO_ADDR
// end ;
97215: PPOPN 1
97217: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
97218: LD_EXP 98
97222: PUSH
97223: LD_EXP 125
97227: AND
97228: IFFALSE 97374
97230: GO 97232
97232: DISABLE
97233: LD_INT 0
97235: PPUSH
97236: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97237: LD_ADDR_VAR 0 1
97241: PUSH
97242: LD_INT 22
97244: PUSH
97245: LD_OWVAR 2
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 2
97256: PUSH
97257: LD_INT 30
97259: PUSH
97260: LD_INT 0
97262: PUSH
97263: EMPTY
97264: LIST
97265: LIST
97266: PUSH
97267: LD_INT 30
97269: PUSH
97270: LD_INT 1
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: PUSH
97277: EMPTY
97278: LIST
97279: LIST
97280: LIST
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PPUSH
97286: CALL_OW 69
97290: ST_TO_ADDR
// if not depot then
97291: LD_VAR 0 1
97295: NOT
97296: IFFALSE 97300
// exit ;
97298: GO 97374
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
97300: LD_ADDR_VAR 0 2
97304: PUSH
97305: LD_VAR 0 1
97309: PUSH
97310: LD_INT 1
97312: PPUSH
97313: LD_VAR 0 1
97317: PPUSH
97318: CALL_OW 12
97322: ARRAY
97323: PPUSH
97324: CALL_OW 274
97328: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
97329: LD_VAR 0 2
97333: PPUSH
97334: LD_INT 1
97336: PPUSH
97337: LD_INT 0
97339: PPUSH
97340: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
97344: LD_VAR 0 2
97348: PPUSH
97349: LD_INT 2
97351: PPUSH
97352: LD_INT 0
97354: PPUSH
97355: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
97359: LD_VAR 0 2
97363: PPUSH
97364: LD_INT 3
97366: PPUSH
97367: LD_INT 0
97369: PPUSH
97370: CALL_OW 277
// end ;
97374: PPOPN 2
97376: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
97377: LD_EXP 98
97381: PUSH
97382: LD_EXP 126
97386: AND
97387: IFFALSE 97484
97389: GO 97391
97391: DISABLE
97392: LD_INT 0
97394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97395: LD_ADDR_VAR 0 1
97399: PUSH
97400: LD_INT 22
97402: PUSH
97403: LD_OWVAR 2
97407: PUSH
97408: EMPTY
97409: LIST
97410: LIST
97411: PUSH
97412: LD_INT 21
97414: PUSH
97415: LD_INT 1
97417: PUSH
97418: EMPTY
97419: LIST
97420: LIST
97421: PUSH
97422: LD_INT 3
97424: PUSH
97425: LD_INT 23
97427: PUSH
97428: LD_INT 0
97430: PUSH
97431: EMPTY
97432: LIST
97433: LIST
97434: PUSH
97435: EMPTY
97436: LIST
97437: LIST
97438: PUSH
97439: EMPTY
97440: LIST
97441: LIST
97442: LIST
97443: PPUSH
97444: CALL_OW 69
97448: ST_TO_ADDR
// if not tmp then
97449: LD_VAR 0 1
97453: NOT
97454: IFFALSE 97458
// exit ;
97456: GO 97484
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
97458: LD_VAR 0 1
97462: PUSH
97463: LD_INT 1
97465: PPUSH
97466: LD_VAR 0 1
97470: PPUSH
97471: CALL_OW 12
97475: ARRAY
97476: PPUSH
97477: LD_INT 200
97479: PPUSH
97480: CALL_OW 234
// end ;
97484: PPOPN 1
97486: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
97487: LD_EXP 98
97491: PUSH
97492: LD_EXP 127
97496: AND
97497: IFFALSE 97576
97499: GO 97501
97501: DISABLE
97502: LD_INT 0
97504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
97505: LD_ADDR_VAR 0 1
97509: PUSH
97510: LD_INT 22
97512: PUSH
97513: LD_OWVAR 2
97517: PUSH
97518: EMPTY
97519: LIST
97520: LIST
97521: PUSH
97522: LD_INT 21
97524: PUSH
97525: LD_INT 2
97527: PUSH
97528: EMPTY
97529: LIST
97530: LIST
97531: PUSH
97532: EMPTY
97533: LIST
97534: LIST
97535: PPUSH
97536: CALL_OW 69
97540: ST_TO_ADDR
// if not tmp then
97541: LD_VAR 0 1
97545: NOT
97546: IFFALSE 97550
// exit ;
97548: GO 97576
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
97550: LD_VAR 0 1
97554: PUSH
97555: LD_INT 1
97557: PPUSH
97558: LD_VAR 0 1
97562: PPUSH
97563: CALL_OW 12
97567: ARRAY
97568: PPUSH
97569: LD_INT 60
97571: PPUSH
97572: CALL_OW 234
// end ;
97576: PPOPN 1
97578: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
97579: LD_EXP 98
97583: PUSH
97584: LD_EXP 128
97588: AND
97589: IFFALSE 97688
97591: GO 97593
97593: DISABLE
97594: LD_INT 0
97596: PPUSH
97597: PPUSH
// begin enable ;
97598: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
97599: LD_ADDR_VAR 0 1
97603: PUSH
97604: LD_INT 22
97606: PUSH
97607: LD_OWVAR 2
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: PUSH
97616: LD_INT 61
97618: PUSH
97619: EMPTY
97620: LIST
97621: PUSH
97622: LD_INT 33
97624: PUSH
97625: LD_INT 2
97627: PUSH
97628: EMPTY
97629: LIST
97630: LIST
97631: PUSH
97632: EMPTY
97633: LIST
97634: LIST
97635: LIST
97636: PPUSH
97637: CALL_OW 69
97641: ST_TO_ADDR
// if not tmp then
97642: LD_VAR 0 1
97646: NOT
97647: IFFALSE 97651
// exit ;
97649: GO 97688
// for i in tmp do
97651: LD_ADDR_VAR 0 2
97655: PUSH
97656: LD_VAR 0 1
97660: PUSH
97661: FOR_IN
97662: IFFALSE 97686
// if IsControledBy ( i ) then
97664: LD_VAR 0 2
97668: PPUSH
97669: CALL_OW 312
97673: IFFALSE 97684
// ComUnlink ( i ) ;
97675: LD_VAR 0 2
97679: PPUSH
97680: CALL_OW 136
97684: GO 97661
97686: POP
97687: POP
// end ;
97688: PPOPN 2
97690: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
97691: LD_EXP 98
97695: PUSH
97696: LD_EXP 129
97700: AND
97701: IFFALSE 97841
97703: GO 97705
97705: DISABLE
97706: LD_INT 0
97708: PPUSH
97709: PPUSH
// begin ToLua ( displayPowell(); ) ;
97710: LD_STRING displayPowell();
97712: PPUSH
97713: CALL_OW 559
// uc_side := 0 ;
97717: LD_ADDR_OWVAR 20
97721: PUSH
97722: LD_INT 0
97724: ST_TO_ADDR
// uc_nation := 2 ;
97725: LD_ADDR_OWVAR 21
97729: PUSH
97730: LD_INT 2
97732: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
97733: LD_ADDR_OWVAR 37
97737: PUSH
97738: LD_INT 14
97740: ST_TO_ADDR
// vc_engine := engine_siberite ;
97741: LD_ADDR_OWVAR 39
97745: PUSH
97746: LD_INT 3
97748: ST_TO_ADDR
// vc_control := control_apeman ;
97749: LD_ADDR_OWVAR 38
97753: PUSH
97754: LD_INT 5
97756: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
97757: LD_ADDR_OWVAR 40
97761: PUSH
97762: LD_INT 29
97764: ST_TO_ADDR
// un := CreateVehicle ;
97765: LD_ADDR_VAR 0 2
97769: PUSH
97770: CALL_OW 45
97774: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97775: LD_VAR 0 2
97779: PPUSH
97780: LD_INT 1
97782: PPUSH
97783: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97787: LD_INT 35
97789: PPUSH
97790: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97794: LD_VAR 0 2
97798: PPUSH
97799: LD_INT 22
97801: PUSH
97802: LD_OWVAR 2
97806: PUSH
97807: EMPTY
97808: LIST
97809: LIST
97810: PPUSH
97811: CALL_OW 69
97815: PPUSH
97816: LD_VAR 0 2
97820: PPUSH
97821: CALL_OW 74
97825: PPUSH
97826: CALL_OW 115
// until IsDead ( un ) ;
97830: LD_VAR 0 2
97834: PPUSH
97835: CALL_OW 301
97839: IFFALSE 97787
// end ;
97841: PPOPN 2
97843: END
// every 0 0$1 trigger StreamModeActive and sStu do
97844: LD_EXP 98
97848: PUSH
97849: LD_EXP 137
97853: AND
97854: IFFALSE 97870
97856: GO 97858
97858: DISABLE
// begin ToLua ( displayStucuk(); ) ;
97859: LD_STRING displayStucuk();
97861: PPUSH
97862: CALL_OW 559
// ResetFog ;
97866: CALL_OW 335
// end ;
97870: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
97871: LD_EXP 98
97875: PUSH
97876: LD_EXP 130
97880: AND
97881: IFFALSE 98022
97883: GO 97885
97885: DISABLE
97886: LD_INT 0
97888: PPUSH
97889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97890: LD_ADDR_VAR 0 2
97894: PUSH
97895: LD_INT 22
97897: PUSH
97898: LD_OWVAR 2
97902: PUSH
97903: EMPTY
97904: LIST
97905: LIST
97906: PUSH
97907: LD_INT 21
97909: PUSH
97910: LD_INT 1
97912: PUSH
97913: EMPTY
97914: LIST
97915: LIST
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PPUSH
97921: CALL_OW 69
97925: ST_TO_ADDR
// if not tmp then
97926: LD_VAR 0 2
97930: NOT
97931: IFFALSE 97935
// exit ;
97933: GO 98022
// un := tmp [ rand ( 1 , tmp ) ] ;
97935: LD_ADDR_VAR 0 1
97939: PUSH
97940: LD_VAR 0 2
97944: PUSH
97945: LD_INT 1
97947: PPUSH
97948: LD_VAR 0 2
97952: PPUSH
97953: CALL_OW 12
97957: ARRAY
97958: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97959: LD_VAR 0 1
97963: PPUSH
97964: LD_INT 0
97966: PPUSH
97967: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97971: LD_VAR 0 1
97975: PPUSH
97976: LD_OWVAR 3
97980: PUSH
97981: LD_VAR 0 1
97985: DIFF
97986: PPUSH
97987: LD_VAR 0 1
97991: PPUSH
97992: CALL_OW 74
97996: PPUSH
97997: CALL_OW 115
// wait ( 0 0$20 ) ;
98001: LD_INT 700
98003: PPUSH
98004: CALL_OW 67
// SetSide ( un , your_side ) ;
98008: LD_VAR 0 1
98012: PPUSH
98013: LD_OWVAR 2
98017: PPUSH
98018: CALL_OW 235
// end ;
98022: PPOPN 2
98024: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
98025: LD_EXP 98
98029: PUSH
98030: LD_EXP 131
98034: AND
98035: IFFALSE 98141
98037: GO 98039
98039: DISABLE
98040: LD_INT 0
98042: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98043: LD_ADDR_VAR 0 1
98047: PUSH
98048: LD_INT 22
98050: PUSH
98051: LD_OWVAR 2
98055: PUSH
98056: EMPTY
98057: LIST
98058: LIST
98059: PUSH
98060: LD_INT 2
98062: PUSH
98063: LD_INT 30
98065: PUSH
98066: LD_INT 0
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: LD_INT 30
98075: PUSH
98076: LD_INT 1
98078: PUSH
98079: EMPTY
98080: LIST
98081: LIST
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: LIST
98087: PUSH
98088: EMPTY
98089: LIST
98090: LIST
98091: PPUSH
98092: CALL_OW 69
98096: ST_TO_ADDR
// if not depot then
98097: LD_VAR 0 1
98101: NOT
98102: IFFALSE 98106
// exit ;
98104: GO 98141
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
98106: LD_VAR 0 1
98110: PUSH
98111: LD_INT 1
98113: ARRAY
98114: PPUSH
98115: CALL_OW 250
98119: PPUSH
98120: LD_VAR 0 1
98124: PUSH
98125: LD_INT 1
98127: ARRAY
98128: PPUSH
98129: CALL_OW 251
98133: PPUSH
98134: LD_INT 70
98136: PPUSH
98137: CALL_OW 495
// end ;
98141: PPOPN 1
98143: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
98144: LD_EXP 98
98148: PUSH
98149: LD_EXP 132
98153: AND
98154: IFFALSE 98365
98156: GO 98158
98158: DISABLE
98159: LD_INT 0
98161: PPUSH
98162: PPUSH
98163: PPUSH
98164: PPUSH
98165: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98166: LD_ADDR_VAR 0 5
98170: PUSH
98171: LD_INT 22
98173: PUSH
98174: LD_OWVAR 2
98178: PUSH
98179: EMPTY
98180: LIST
98181: LIST
98182: PUSH
98183: LD_INT 21
98185: PUSH
98186: LD_INT 1
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PPUSH
98197: CALL_OW 69
98201: ST_TO_ADDR
// if not tmp then
98202: LD_VAR 0 5
98206: NOT
98207: IFFALSE 98211
// exit ;
98209: GO 98365
// for i in tmp do
98211: LD_ADDR_VAR 0 1
98215: PUSH
98216: LD_VAR 0 5
98220: PUSH
98221: FOR_IN
98222: IFFALSE 98363
// begin d := rand ( 0 , 5 ) ;
98224: LD_ADDR_VAR 0 4
98228: PUSH
98229: LD_INT 0
98231: PPUSH
98232: LD_INT 5
98234: PPUSH
98235: CALL_OW 12
98239: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
98240: LD_ADDR_VAR 0 2
98244: PUSH
98245: LD_VAR 0 1
98249: PPUSH
98250: CALL_OW 250
98254: PPUSH
98255: LD_VAR 0 4
98259: PPUSH
98260: LD_INT 3
98262: PPUSH
98263: LD_INT 12
98265: PPUSH
98266: CALL_OW 12
98270: PPUSH
98271: CALL_OW 272
98275: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
98276: LD_ADDR_VAR 0 3
98280: PUSH
98281: LD_VAR 0 1
98285: PPUSH
98286: CALL_OW 251
98290: PPUSH
98291: LD_VAR 0 4
98295: PPUSH
98296: LD_INT 3
98298: PPUSH
98299: LD_INT 12
98301: PPUSH
98302: CALL_OW 12
98306: PPUSH
98307: CALL_OW 273
98311: ST_TO_ADDR
// if ValidHex ( x , y ) then
98312: LD_VAR 0 2
98316: PPUSH
98317: LD_VAR 0 3
98321: PPUSH
98322: CALL_OW 488
98326: IFFALSE 98361
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
98328: LD_VAR 0 1
98332: PPUSH
98333: LD_VAR 0 2
98337: PPUSH
98338: LD_VAR 0 3
98342: PPUSH
98343: LD_INT 3
98345: PPUSH
98346: LD_INT 6
98348: PPUSH
98349: CALL_OW 12
98353: PPUSH
98354: LD_INT 1
98356: PPUSH
98357: CALL_OW 483
// end ;
98361: GO 98221
98363: POP
98364: POP
// end ;
98365: PPOPN 5
98367: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
98368: LD_EXP 98
98372: PUSH
98373: LD_EXP 133
98377: AND
98378: IFFALSE 98472
98380: GO 98382
98382: DISABLE
98383: LD_INT 0
98385: PPUSH
98386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
98387: LD_ADDR_VAR 0 2
98391: PUSH
98392: LD_INT 22
98394: PUSH
98395: LD_OWVAR 2
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: PUSH
98404: LD_INT 32
98406: PUSH
98407: LD_INT 1
98409: PUSH
98410: EMPTY
98411: LIST
98412: LIST
98413: PUSH
98414: LD_INT 21
98416: PUSH
98417: LD_INT 2
98419: PUSH
98420: EMPTY
98421: LIST
98422: LIST
98423: PUSH
98424: EMPTY
98425: LIST
98426: LIST
98427: LIST
98428: PPUSH
98429: CALL_OW 69
98433: ST_TO_ADDR
// if not tmp then
98434: LD_VAR 0 2
98438: NOT
98439: IFFALSE 98443
// exit ;
98441: GO 98472
// for i in tmp do
98443: LD_ADDR_VAR 0 1
98447: PUSH
98448: LD_VAR 0 2
98452: PUSH
98453: FOR_IN
98454: IFFALSE 98470
// SetFuel ( i , 0 ) ;
98456: LD_VAR 0 1
98460: PPUSH
98461: LD_INT 0
98463: PPUSH
98464: CALL_OW 240
98468: GO 98453
98470: POP
98471: POP
// end ;
98472: PPOPN 2
98474: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
98475: LD_EXP 98
98479: PUSH
98480: LD_EXP 134
98484: AND
98485: IFFALSE 98551
98487: GO 98489
98489: DISABLE
98490: LD_INT 0
98492: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98493: LD_ADDR_VAR 0 1
98497: PUSH
98498: LD_INT 22
98500: PUSH
98501: LD_OWVAR 2
98505: PUSH
98506: EMPTY
98507: LIST
98508: LIST
98509: PUSH
98510: LD_INT 30
98512: PUSH
98513: LD_INT 29
98515: PUSH
98516: EMPTY
98517: LIST
98518: LIST
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PPUSH
98524: CALL_OW 69
98528: ST_TO_ADDR
// if not tmp then
98529: LD_VAR 0 1
98533: NOT
98534: IFFALSE 98538
// exit ;
98536: GO 98551
// DestroyUnit ( tmp [ 1 ] ) ;
98538: LD_VAR 0 1
98542: PUSH
98543: LD_INT 1
98545: ARRAY
98546: PPUSH
98547: CALL_OW 65
// end ;
98551: PPOPN 1
98553: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
98554: LD_EXP 98
98558: PUSH
98559: LD_EXP 136
98563: AND
98564: IFFALSE 98693
98566: GO 98568
98568: DISABLE
98569: LD_INT 0
98571: PPUSH
// begin uc_side := 0 ;
98572: LD_ADDR_OWVAR 20
98576: PUSH
98577: LD_INT 0
98579: ST_TO_ADDR
// uc_nation := nation_arabian ;
98580: LD_ADDR_OWVAR 21
98584: PUSH
98585: LD_INT 2
98587: ST_TO_ADDR
// hc_gallery :=  ;
98588: LD_ADDR_OWVAR 33
98592: PUSH
98593: LD_STRING 
98595: ST_TO_ADDR
// hc_name :=  ;
98596: LD_ADDR_OWVAR 26
98600: PUSH
98601: LD_STRING 
98603: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
98604: LD_INT 1
98606: PPUSH
98607: LD_INT 11
98609: PPUSH
98610: LD_INT 10
98612: PPUSH
98613: CALL_OW 380
// un := CreateHuman ;
98617: LD_ADDR_VAR 0 1
98621: PUSH
98622: CALL_OW 44
98626: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98627: LD_VAR 0 1
98631: PPUSH
98632: LD_INT 1
98634: PPUSH
98635: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
98639: LD_INT 35
98641: PPUSH
98642: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
98646: LD_VAR 0 1
98650: PPUSH
98651: LD_INT 22
98653: PUSH
98654: LD_OWVAR 2
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: PPUSH
98663: CALL_OW 69
98667: PPUSH
98668: LD_VAR 0 1
98672: PPUSH
98673: CALL_OW 74
98677: PPUSH
98678: CALL_OW 115
// until IsDead ( un ) ;
98682: LD_VAR 0 1
98686: PPUSH
98687: CALL_OW 301
98691: IFFALSE 98639
// end ;
98693: PPOPN 1
98695: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
98696: LD_EXP 98
98700: PUSH
98701: LD_EXP 138
98705: AND
98706: IFFALSE 98718
98708: GO 98710
98710: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
98711: LD_STRING earthquake(getX(game), 0, 32)
98713: PPUSH
98714: CALL_OW 559
98718: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
98719: LD_EXP 98
98723: PUSH
98724: LD_EXP 139
98728: AND
98729: IFFALSE 98820
98731: GO 98733
98733: DISABLE
98734: LD_INT 0
98736: PPUSH
// begin enable ;
98737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
98738: LD_ADDR_VAR 0 1
98742: PUSH
98743: LD_INT 22
98745: PUSH
98746: LD_OWVAR 2
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: LD_INT 21
98757: PUSH
98758: LD_INT 2
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 33
98767: PUSH
98768: LD_INT 3
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: LIST
98779: PPUSH
98780: CALL_OW 69
98784: ST_TO_ADDR
// if not tmp then
98785: LD_VAR 0 1
98789: NOT
98790: IFFALSE 98794
// exit ;
98792: GO 98820
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98794: LD_VAR 0 1
98798: PUSH
98799: LD_INT 1
98801: PPUSH
98802: LD_VAR 0 1
98806: PPUSH
98807: CALL_OW 12
98811: ARRAY
98812: PPUSH
98813: LD_INT 1
98815: PPUSH
98816: CALL_OW 234
// end ;
98820: PPOPN 1
98822: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
98823: LD_EXP 98
98827: PUSH
98828: LD_EXP 140
98832: AND
98833: IFFALSE 98974
98835: GO 98837
98837: DISABLE
98838: LD_INT 0
98840: PPUSH
98841: PPUSH
98842: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98843: LD_ADDR_VAR 0 3
98847: PUSH
98848: LD_INT 22
98850: PUSH
98851: LD_OWVAR 2
98855: PUSH
98856: EMPTY
98857: LIST
98858: LIST
98859: PUSH
98860: LD_INT 25
98862: PUSH
98863: LD_INT 1
98865: PUSH
98866: EMPTY
98867: LIST
98868: LIST
98869: PUSH
98870: EMPTY
98871: LIST
98872: LIST
98873: PPUSH
98874: CALL_OW 69
98878: ST_TO_ADDR
// if not tmp then
98879: LD_VAR 0 3
98883: NOT
98884: IFFALSE 98888
// exit ;
98886: GO 98974
// un := tmp [ rand ( 1 , tmp ) ] ;
98888: LD_ADDR_VAR 0 2
98892: PUSH
98893: LD_VAR 0 3
98897: PUSH
98898: LD_INT 1
98900: PPUSH
98901: LD_VAR 0 3
98905: PPUSH
98906: CALL_OW 12
98910: ARRAY
98911: ST_TO_ADDR
// if Crawls ( un ) then
98912: LD_VAR 0 2
98916: PPUSH
98917: CALL_OW 318
98921: IFFALSE 98932
// ComWalk ( un ) ;
98923: LD_VAR 0 2
98927: PPUSH
98928: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98932: LD_VAR 0 2
98936: PPUSH
98937: LD_INT 9
98939: PPUSH
98940: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98944: LD_INT 28
98946: PPUSH
98947: LD_OWVAR 2
98951: PPUSH
98952: LD_INT 2
98954: PPUSH
98955: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98959: LD_INT 29
98961: PPUSH
98962: LD_OWVAR 2
98966: PPUSH
98967: LD_INT 2
98969: PPUSH
98970: CALL_OW 322
// end ;
98974: PPOPN 3
98976: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98977: LD_EXP 98
98981: PUSH
98982: LD_EXP 141
98986: AND
98987: IFFALSE 99098
98989: GO 98991
98991: DISABLE
98992: LD_INT 0
98994: PPUSH
98995: PPUSH
98996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98997: LD_ADDR_VAR 0 3
99001: PUSH
99002: LD_INT 22
99004: PUSH
99005: LD_OWVAR 2
99009: PUSH
99010: EMPTY
99011: LIST
99012: LIST
99013: PUSH
99014: LD_INT 25
99016: PUSH
99017: LD_INT 1
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: PUSH
99024: EMPTY
99025: LIST
99026: LIST
99027: PPUSH
99028: CALL_OW 69
99032: ST_TO_ADDR
// if not tmp then
99033: LD_VAR 0 3
99037: NOT
99038: IFFALSE 99042
// exit ;
99040: GO 99098
// un := tmp [ rand ( 1 , tmp ) ] ;
99042: LD_ADDR_VAR 0 2
99046: PUSH
99047: LD_VAR 0 3
99051: PUSH
99052: LD_INT 1
99054: PPUSH
99055: LD_VAR 0 3
99059: PPUSH
99060: CALL_OW 12
99064: ARRAY
99065: ST_TO_ADDR
// if Crawls ( un ) then
99066: LD_VAR 0 2
99070: PPUSH
99071: CALL_OW 318
99075: IFFALSE 99086
// ComWalk ( un ) ;
99077: LD_VAR 0 2
99081: PPUSH
99082: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99086: LD_VAR 0 2
99090: PPUSH
99091: LD_INT 8
99093: PPUSH
99094: CALL_OW 336
// end ;
99098: PPOPN 3
99100: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
99101: LD_EXP 98
99105: PUSH
99106: LD_EXP 142
99110: AND
99111: IFFALSE 99255
99113: GO 99115
99115: DISABLE
99116: LD_INT 0
99118: PPUSH
99119: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
99120: LD_ADDR_VAR 0 2
99124: PUSH
99125: LD_INT 22
99127: PUSH
99128: LD_OWVAR 2
99132: PUSH
99133: EMPTY
99134: LIST
99135: LIST
99136: PUSH
99137: LD_INT 21
99139: PUSH
99140: LD_INT 2
99142: PUSH
99143: EMPTY
99144: LIST
99145: LIST
99146: PUSH
99147: LD_INT 2
99149: PUSH
99150: LD_INT 34
99152: PUSH
99153: LD_INT 12
99155: PUSH
99156: EMPTY
99157: LIST
99158: LIST
99159: PUSH
99160: LD_INT 34
99162: PUSH
99163: LD_INT 51
99165: PUSH
99166: EMPTY
99167: LIST
99168: LIST
99169: PUSH
99170: LD_INT 34
99172: PUSH
99173: LD_INT 32
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: PUSH
99180: EMPTY
99181: LIST
99182: LIST
99183: LIST
99184: LIST
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: LIST
99190: PPUSH
99191: CALL_OW 69
99195: ST_TO_ADDR
// if not tmp then
99196: LD_VAR 0 2
99200: NOT
99201: IFFALSE 99205
// exit ;
99203: GO 99255
// for i in tmp do
99205: LD_ADDR_VAR 0 1
99209: PUSH
99210: LD_VAR 0 2
99214: PUSH
99215: FOR_IN
99216: IFFALSE 99253
// if GetCargo ( i , mat_artifact ) = 0 then
99218: LD_VAR 0 1
99222: PPUSH
99223: LD_INT 4
99225: PPUSH
99226: CALL_OW 289
99230: PUSH
99231: LD_INT 0
99233: EQUAL
99234: IFFALSE 99251
// SetCargo ( i , mat_siberit , 100 ) ;
99236: LD_VAR 0 1
99240: PPUSH
99241: LD_INT 3
99243: PPUSH
99244: LD_INT 100
99246: PPUSH
99247: CALL_OW 290
99251: GO 99215
99253: POP
99254: POP
// end ;
99255: PPOPN 2
99257: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
99258: LD_EXP 98
99262: PUSH
99263: LD_EXP 143
99267: AND
99268: IFFALSE 99451
99270: GO 99272
99272: DISABLE
99273: LD_INT 0
99275: PPUSH
99276: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99277: LD_ADDR_VAR 0 2
99281: PUSH
99282: LD_INT 22
99284: PUSH
99285: LD_OWVAR 2
99289: PUSH
99290: EMPTY
99291: LIST
99292: LIST
99293: PPUSH
99294: CALL_OW 69
99298: ST_TO_ADDR
// if not tmp then
99299: LD_VAR 0 2
99303: NOT
99304: IFFALSE 99308
// exit ;
99306: GO 99451
// for i := 1 to 2 do
99308: LD_ADDR_VAR 0 1
99312: PUSH
99313: DOUBLE
99314: LD_INT 1
99316: DEC
99317: ST_TO_ADDR
99318: LD_INT 2
99320: PUSH
99321: FOR_TO
99322: IFFALSE 99449
// begin uc_side := your_side ;
99324: LD_ADDR_OWVAR 20
99328: PUSH
99329: LD_OWVAR 2
99333: ST_TO_ADDR
// uc_nation := nation_american ;
99334: LD_ADDR_OWVAR 21
99338: PUSH
99339: LD_INT 1
99341: ST_TO_ADDR
// vc_chassis := us_morphling ;
99342: LD_ADDR_OWVAR 37
99346: PUSH
99347: LD_INT 5
99349: ST_TO_ADDR
// vc_engine := engine_siberite ;
99350: LD_ADDR_OWVAR 39
99354: PUSH
99355: LD_INT 3
99357: ST_TO_ADDR
// vc_control := control_computer ;
99358: LD_ADDR_OWVAR 38
99362: PUSH
99363: LD_INT 3
99365: ST_TO_ADDR
// vc_weapon := us_double_laser ;
99366: LD_ADDR_OWVAR 40
99370: PUSH
99371: LD_INT 10
99373: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
99374: LD_VAR 0 2
99378: PUSH
99379: LD_INT 1
99381: ARRAY
99382: PPUSH
99383: CALL_OW 310
99387: NOT
99388: IFFALSE 99435
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
99390: CALL_OW 45
99394: PPUSH
99395: LD_VAR 0 2
99399: PUSH
99400: LD_INT 1
99402: ARRAY
99403: PPUSH
99404: CALL_OW 250
99408: PPUSH
99409: LD_VAR 0 2
99413: PUSH
99414: LD_INT 1
99416: ARRAY
99417: PPUSH
99418: CALL_OW 251
99422: PPUSH
99423: LD_INT 12
99425: PPUSH
99426: LD_INT 1
99428: PPUSH
99429: CALL_OW 50
99433: GO 99447
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
99435: CALL_OW 45
99439: PPUSH
99440: LD_INT 1
99442: PPUSH
99443: CALL_OW 51
// end ;
99447: GO 99321
99449: POP
99450: POP
// end ;
99451: PPOPN 2
99453: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
99454: LD_EXP 98
99458: PUSH
99459: LD_EXP 144
99463: AND
99464: IFFALSE 99686
99466: GO 99468
99468: DISABLE
99469: LD_INT 0
99471: PPUSH
99472: PPUSH
99473: PPUSH
99474: PPUSH
99475: PPUSH
99476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99477: LD_ADDR_VAR 0 6
99481: PUSH
99482: LD_INT 22
99484: PUSH
99485: LD_OWVAR 2
99489: PUSH
99490: EMPTY
99491: LIST
99492: LIST
99493: PUSH
99494: LD_INT 21
99496: PUSH
99497: LD_INT 1
99499: PUSH
99500: EMPTY
99501: LIST
99502: LIST
99503: PUSH
99504: LD_INT 3
99506: PUSH
99507: LD_INT 23
99509: PUSH
99510: LD_INT 0
99512: PUSH
99513: EMPTY
99514: LIST
99515: LIST
99516: PUSH
99517: EMPTY
99518: LIST
99519: LIST
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: LIST
99525: PPUSH
99526: CALL_OW 69
99530: ST_TO_ADDR
// if not tmp then
99531: LD_VAR 0 6
99535: NOT
99536: IFFALSE 99540
// exit ;
99538: GO 99686
// s1 := rand ( 1 , 4 ) ;
99540: LD_ADDR_VAR 0 2
99544: PUSH
99545: LD_INT 1
99547: PPUSH
99548: LD_INT 4
99550: PPUSH
99551: CALL_OW 12
99555: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
99556: LD_ADDR_VAR 0 4
99560: PUSH
99561: LD_VAR 0 6
99565: PUSH
99566: LD_INT 1
99568: ARRAY
99569: PPUSH
99570: LD_VAR 0 2
99574: PPUSH
99575: CALL_OW 259
99579: ST_TO_ADDR
// if s1 = 1 then
99580: LD_VAR 0 2
99584: PUSH
99585: LD_INT 1
99587: EQUAL
99588: IFFALSE 99608
// s2 := rand ( 2 , 4 ) else
99590: LD_ADDR_VAR 0 3
99594: PUSH
99595: LD_INT 2
99597: PPUSH
99598: LD_INT 4
99600: PPUSH
99601: CALL_OW 12
99605: ST_TO_ADDR
99606: GO 99616
// s2 := 1 ;
99608: LD_ADDR_VAR 0 3
99612: PUSH
99613: LD_INT 1
99615: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
99616: LD_ADDR_VAR 0 5
99620: PUSH
99621: LD_VAR 0 6
99625: PUSH
99626: LD_INT 1
99628: ARRAY
99629: PPUSH
99630: LD_VAR 0 3
99634: PPUSH
99635: CALL_OW 259
99639: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
99640: LD_VAR 0 6
99644: PUSH
99645: LD_INT 1
99647: ARRAY
99648: PPUSH
99649: LD_VAR 0 2
99653: PPUSH
99654: LD_VAR 0 5
99658: PPUSH
99659: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
99663: LD_VAR 0 6
99667: PUSH
99668: LD_INT 1
99670: ARRAY
99671: PPUSH
99672: LD_VAR 0 3
99676: PPUSH
99677: LD_VAR 0 4
99681: PPUSH
99682: CALL_OW 237
// end ;
99686: PPOPN 6
99688: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
99689: LD_EXP 98
99693: PUSH
99694: LD_EXP 145
99698: AND
99699: IFFALSE 99778
99701: GO 99703
99703: DISABLE
99704: LD_INT 0
99706: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
99707: LD_ADDR_VAR 0 1
99711: PUSH
99712: LD_INT 22
99714: PUSH
99715: LD_OWVAR 2
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PUSH
99724: LD_INT 30
99726: PUSH
99727: LD_INT 3
99729: PUSH
99730: EMPTY
99731: LIST
99732: LIST
99733: PUSH
99734: EMPTY
99735: LIST
99736: LIST
99737: PPUSH
99738: CALL_OW 69
99742: ST_TO_ADDR
// if not tmp then
99743: LD_VAR 0 1
99747: NOT
99748: IFFALSE 99752
// exit ;
99750: GO 99778
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
99752: LD_VAR 0 1
99756: PUSH
99757: LD_INT 1
99759: PPUSH
99760: LD_VAR 0 1
99764: PPUSH
99765: CALL_OW 12
99769: ARRAY
99770: PPUSH
99771: LD_INT 1
99773: PPUSH
99774: CALL_OW 234
// end ;
99778: PPOPN 1
99780: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
99781: LD_EXP 98
99785: PUSH
99786: LD_EXP 146
99790: AND
99791: IFFALSE 99903
99793: GO 99795
99795: DISABLE
99796: LD_INT 0
99798: PPUSH
99799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
99800: LD_ADDR_VAR 0 2
99804: PUSH
99805: LD_INT 22
99807: PUSH
99808: LD_OWVAR 2
99812: PUSH
99813: EMPTY
99814: LIST
99815: LIST
99816: PUSH
99817: LD_INT 2
99819: PUSH
99820: LD_INT 30
99822: PUSH
99823: LD_INT 27
99825: PUSH
99826: EMPTY
99827: LIST
99828: LIST
99829: PUSH
99830: LD_INT 30
99832: PUSH
99833: LD_INT 26
99835: PUSH
99836: EMPTY
99837: LIST
99838: LIST
99839: PUSH
99840: LD_INT 30
99842: PUSH
99843: LD_INT 28
99845: PUSH
99846: EMPTY
99847: LIST
99848: LIST
99849: PUSH
99850: EMPTY
99851: LIST
99852: LIST
99853: LIST
99854: LIST
99855: PUSH
99856: EMPTY
99857: LIST
99858: LIST
99859: PPUSH
99860: CALL_OW 69
99864: ST_TO_ADDR
// if not tmp then
99865: LD_VAR 0 2
99869: NOT
99870: IFFALSE 99874
// exit ;
99872: GO 99903
// for i in tmp do
99874: LD_ADDR_VAR 0 1
99878: PUSH
99879: LD_VAR 0 2
99883: PUSH
99884: FOR_IN
99885: IFFALSE 99901
// SetLives ( i , 1 ) ;
99887: LD_VAR 0 1
99891: PPUSH
99892: LD_INT 1
99894: PPUSH
99895: CALL_OW 234
99899: GO 99884
99901: POP
99902: POP
// end ;
99903: PPOPN 2
99905: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99906: LD_EXP 98
99910: PUSH
99911: LD_EXP 147
99915: AND
99916: IFFALSE 100190
99918: GO 99920
99920: DISABLE
99921: LD_INT 0
99923: PPUSH
99924: PPUSH
99925: PPUSH
// begin i := rand ( 1 , 7 ) ;
99926: LD_ADDR_VAR 0 1
99930: PUSH
99931: LD_INT 1
99933: PPUSH
99934: LD_INT 7
99936: PPUSH
99937: CALL_OW 12
99941: ST_TO_ADDR
// case i of 1 :
99942: LD_VAR 0 1
99946: PUSH
99947: LD_INT 1
99949: DOUBLE
99950: EQUAL
99951: IFTRUE 99955
99953: GO 99965
99955: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99956: LD_STRING earthquake(getX(game), 0, 32)
99958: PPUSH
99959: CALL_OW 559
99963: GO 100190
99965: LD_INT 2
99967: DOUBLE
99968: EQUAL
99969: IFTRUE 99973
99971: GO 99987
99973: POP
// begin ToLua ( displayStucuk(); ) ;
99974: LD_STRING displayStucuk();
99976: PPUSH
99977: CALL_OW 559
// ResetFog ;
99981: CALL_OW 335
// end ; 3 :
99985: GO 100190
99987: LD_INT 3
99989: DOUBLE
99990: EQUAL
99991: IFTRUE 99995
99993: GO 100099
99995: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99996: LD_ADDR_VAR 0 2
100000: PUSH
100001: LD_INT 22
100003: PUSH
100004: LD_OWVAR 2
100008: PUSH
100009: EMPTY
100010: LIST
100011: LIST
100012: PUSH
100013: LD_INT 25
100015: PUSH
100016: LD_INT 1
100018: PUSH
100019: EMPTY
100020: LIST
100021: LIST
100022: PUSH
100023: EMPTY
100024: LIST
100025: LIST
100026: PPUSH
100027: CALL_OW 69
100031: ST_TO_ADDR
// if not tmp then
100032: LD_VAR 0 2
100036: NOT
100037: IFFALSE 100041
// exit ;
100039: GO 100190
// un := tmp [ rand ( 1 , tmp ) ] ;
100041: LD_ADDR_VAR 0 3
100045: PUSH
100046: LD_VAR 0 2
100050: PUSH
100051: LD_INT 1
100053: PPUSH
100054: LD_VAR 0 2
100058: PPUSH
100059: CALL_OW 12
100063: ARRAY
100064: ST_TO_ADDR
// if Crawls ( un ) then
100065: LD_VAR 0 3
100069: PPUSH
100070: CALL_OW 318
100074: IFFALSE 100085
// ComWalk ( un ) ;
100076: LD_VAR 0 3
100080: PPUSH
100081: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100085: LD_VAR 0 3
100089: PPUSH
100090: LD_INT 8
100092: PPUSH
100093: CALL_OW 336
// end ; 4 :
100097: GO 100190
100099: LD_INT 4
100101: DOUBLE
100102: EQUAL
100103: IFTRUE 100107
100105: GO 100168
100107: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100108: LD_ADDR_VAR 0 2
100112: PUSH
100113: LD_INT 22
100115: PUSH
100116: LD_OWVAR 2
100120: PUSH
100121: EMPTY
100122: LIST
100123: LIST
100124: PUSH
100125: LD_INT 30
100127: PUSH
100128: LD_INT 29
100130: PUSH
100131: EMPTY
100132: LIST
100133: LIST
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: PPUSH
100139: CALL_OW 69
100143: ST_TO_ADDR
// if not tmp then
100144: LD_VAR 0 2
100148: NOT
100149: IFFALSE 100153
// exit ;
100151: GO 100190
// DestroyUnit ( tmp [ 1 ] ) ;
100153: LD_VAR 0 2
100157: PUSH
100158: LD_INT 1
100160: ARRAY
100161: PPUSH
100162: CALL_OW 65
// end ; 5 .. 7 :
100166: GO 100190
100168: LD_INT 5
100170: DOUBLE
100171: GREATEREQUAL
100172: IFFALSE 100180
100174: LD_INT 7
100176: DOUBLE
100177: LESSEQUAL
100178: IFTRUE 100182
100180: GO 100189
100182: POP
// StreamSibBomb ; end ;
100183: CALL 96440 0 0
100187: GO 100190
100189: POP
// end ;
100190: PPOPN 3
100192: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
100193: LD_EXP 98
100197: PUSH
100198: LD_EXP 148
100202: AND
100203: IFFALSE 100359
100205: GO 100207
100207: DISABLE
100208: LD_INT 0
100210: PPUSH
100211: PPUSH
100212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
100213: LD_ADDR_VAR 0 2
100217: PUSH
100218: LD_INT 81
100220: PUSH
100221: LD_OWVAR 2
100225: PUSH
100226: EMPTY
100227: LIST
100228: LIST
100229: PUSH
100230: LD_INT 2
100232: PUSH
100233: LD_INT 21
100235: PUSH
100236: LD_INT 1
100238: PUSH
100239: EMPTY
100240: LIST
100241: LIST
100242: PUSH
100243: LD_INT 21
100245: PUSH
100246: LD_INT 2
100248: PUSH
100249: EMPTY
100250: LIST
100251: LIST
100252: PUSH
100253: EMPTY
100254: LIST
100255: LIST
100256: LIST
100257: PUSH
100258: EMPTY
100259: LIST
100260: LIST
100261: PPUSH
100262: CALL_OW 69
100266: ST_TO_ADDR
// if not tmp then
100267: LD_VAR 0 2
100271: NOT
100272: IFFALSE 100276
// exit ;
100274: GO 100359
// p := 0 ;
100276: LD_ADDR_VAR 0 3
100280: PUSH
100281: LD_INT 0
100283: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100284: LD_INT 35
100286: PPUSH
100287: CALL_OW 67
// p := p + 1 ;
100291: LD_ADDR_VAR 0 3
100295: PUSH
100296: LD_VAR 0 3
100300: PUSH
100301: LD_INT 1
100303: PLUS
100304: ST_TO_ADDR
// for i in tmp do
100305: LD_ADDR_VAR 0 1
100309: PUSH
100310: LD_VAR 0 2
100314: PUSH
100315: FOR_IN
100316: IFFALSE 100347
// if GetLives ( i ) < 1000 then
100318: LD_VAR 0 1
100322: PPUSH
100323: CALL_OW 256
100327: PUSH
100328: LD_INT 1000
100330: LESS
100331: IFFALSE 100345
// SetLives ( i , 1000 ) ;
100333: LD_VAR 0 1
100337: PPUSH
100338: LD_INT 1000
100340: PPUSH
100341: CALL_OW 234
100345: GO 100315
100347: POP
100348: POP
// until p > 20 ;
100349: LD_VAR 0 3
100353: PUSH
100354: LD_INT 20
100356: GREATER
100357: IFFALSE 100284
// end ;
100359: PPOPN 3
100361: END
// every 0 0$1 trigger StreamModeActive and sTime do
100362: LD_EXP 98
100366: PUSH
100367: LD_EXP 149
100371: AND
100372: IFFALSE 100407
100374: GO 100376
100376: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
100377: LD_INT 28
100379: PPUSH
100380: LD_OWVAR 2
100384: PPUSH
100385: LD_INT 2
100387: PPUSH
100388: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
100392: LD_INT 30
100394: PPUSH
100395: LD_OWVAR 2
100399: PPUSH
100400: LD_INT 2
100402: PPUSH
100403: CALL_OW 322
// end ;
100407: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
100408: LD_EXP 98
100412: PUSH
100413: LD_EXP 150
100417: AND
100418: IFFALSE 100539
100420: GO 100422
100422: DISABLE
100423: LD_INT 0
100425: PPUSH
100426: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: LD_INT 22
100434: PUSH
100435: LD_OWVAR 2
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: LD_INT 21
100446: PUSH
100447: LD_INT 1
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: PUSH
100454: LD_INT 3
100456: PUSH
100457: LD_INT 23
100459: PUSH
100460: LD_INT 0
100462: PUSH
100463: EMPTY
100464: LIST
100465: LIST
100466: PUSH
100467: EMPTY
100468: LIST
100469: LIST
100470: PUSH
100471: EMPTY
100472: LIST
100473: LIST
100474: LIST
100475: PPUSH
100476: CALL_OW 69
100480: ST_TO_ADDR
// if not tmp then
100481: LD_VAR 0 2
100485: NOT
100486: IFFALSE 100490
// exit ;
100488: GO 100539
// for i in tmp do
100490: LD_ADDR_VAR 0 1
100494: PUSH
100495: LD_VAR 0 2
100499: PUSH
100500: FOR_IN
100501: IFFALSE 100537
// begin if Crawls ( i ) then
100503: LD_VAR 0 1
100507: PPUSH
100508: CALL_OW 318
100512: IFFALSE 100523
// ComWalk ( i ) ;
100514: LD_VAR 0 1
100518: PPUSH
100519: CALL_OW 138
// SetClass ( i , 2 ) ;
100523: LD_VAR 0 1
100527: PPUSH
100528: LD_INT 2
100530: PPUSH
100531: CALL_OW 336
// end ;
100535: GO 100500
100537: POP
100538: POP
// end ;
100539: PPOPN 2
100541: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
100542: LD_EXP 98
100546: PUSH
100547: LD_EXP 151
100551: AND
100552: IFFALSE 100833
100554: GO 100556
100556: DISABLE
100557: LD_INT 0
100559: PPUSH
100560: PPUSH
100561: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
100562: LD_OWVAR 2
100566: PPUSH
100567: LD_INT 9
100569: PPUSH
100570: LD_INT 1
100572: PPUSH
100573: LD_INT 1
100575: PPUSH
100576: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
100580: LD_INT 9
100582: PPUSH
100583: LD_OWVAR 2
100587: PPUSH
100588: CALL_OW 343
// uc_side := 9 ;
100592: LD_ADDR_OWVAR 20
100596: PUSH
100597: LD_INT 9
100599: ST_TO_ADDR
// uc_nation := 2 ;
100600: LD_ADDR_OWVAR 21
100604: PUSH
100605: LD_INT 2
100607: ST_TO_ADDR
// hc_name := Dark Warrior ;
100608: LD_ADDR_OWVAR 26
100612: PUSH
100613: LD_STRING Dark Warrior
100615: ST_TO_ADDR
// hc_gallery :=  ;
100616: LD_ADDR_OWVAR 33
100620: PUSH
100621: LD_STRING 
100623: ST_TO_ADDR
// hc_noskilllimit := true ;
100624: LD_ADDR_OWVAR 76
100628: PUSH
100629: LD_INT 1
100631: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
100632: LD_ADDR_OWVAR 31
100636: PUSH
100637: LD_INT 30
100639: PUSH
100640: LD_INT 30
100642: PUSH
100643: LD_INT 30
100645: PUSH
100646: LD_INT 30
100648: PUSH
100649: EMPTY
100650: LIST
100651: LIST
100652: LIST
100653: LIST
100654: ST_TO_ADDR
// un := CreateHuman ;
100655: LD_ADDR_VAR 0 3
100659: PUSH
100660: CALL_OW 44
100664: ST_TO_ADDR
// hc_noskilllimit := false ;
100665: LD_ADDR_OWVAR 76
100669: PUSH
100670: LD_INT 0
100672: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100673: LD_VAR 0 3
100677: PPUSH
100678: LD_INT 1
100680: PPUSH
100681: CALL_OW 51
// p := 0 ;
100685: LD_ADDR_VAR 0 2
100689: PUSH
100690: LD_INT 0
100692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
100693: LD_INT 35
100695: PPUSH
100696: CALL_OW 67
// p := p + 1 ;
100700: LD_ADDR_VAR 0 2
100704: PUSH
100705: LD_VAR 0 2
100709: PUSH
100710: LD_INT 1
100712: PLUS
100713: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
100714: LD_VAR 0 3
100718: PPUSH
100719: CALL_OW 256
100723: PUSH
100724: LD_INT 1000
100726: LESS
100727: IFFALSE 100741
// SetLives ( un , 1000 ) ;
100729: LD_VAR 0 3
100733: PPUSH
100734: LD_INT 1000
100736: PPUSH
100737: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
100741: LD_VAR 0 3
100745: PPUSH
100746: LD_INT 81
100748: PUSH
100749: LD_OWVAR 2
100753: PUSH
100754: EMPTY
100755: LIST
100756: LIST
100757: PUSH
100758: LD_INT 91
100760: PUSH
100761: LD_VAR 0 3
100765: PUSH
100766: LD_INT 30
100768: PUSH
100769: EMPTY
100770: LIST
100771: LIST
100772: LIST
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: PPUSH
100778: CALL_OW 69
100782: PPUSH
100783: LD_VAR 0 3
100787: PPUSH
100788: CALL_OW 74
100792: PPUSH
100793: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
100797: LD_VAR 0 2
100801: PUSH
100802: LD_INT 60
100804: GREATER
100805: PUSH
100806: LD_VAR 0 3
100810: PPUSH
100811: CALL_OW 301
100815: OR
100816: IFFALSE 100693
// if un then
100818: LD_VAR 0 3
100822: IFFALSE 100833
// RemoveUnit ( un ) ;
100824: LD_VAR 0 3
100828: PPUSH
100829: CALL_OW 64
// end ;
100833: PPOPN 3
100835: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100836: LD_INT 0
100838: PPUSH
// case cmd of 301 :
100839: LD_VAR 0 1
100843: PUSH
100844: LD_INT 301
100846: DOUBLE
100847: EQUAL
100848: IFTRUE 100852
100850: GO 100884
100852: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100853: LD_VAR 0 6
100857: PPUSH
100858: LD_VAR 0 7
100862: PPUSH
100863: LD_VAR 0 8
100867: PPUSH
100868: LD_VAR 0 4
100872: PPUSH
100873: LD_VAR 0 5
100877: PPUSH
100878: CALL 102085 0 5
100882: GO 101005
100884: LD_INT 302
100886: DOUBLE
100887: EQUAL
100888: IFTRUE 100892
100890: GO 100929
100892: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100893: LD_VAR 0 6
100897: PPUSH
100898: LD_VAR 0 7
100902: PPUSH
100903: LD_VAR 0 8
100907: PPUSH
100908: LD_VAR 0 9
100912: PPUSH
100913: LD_VAR 0 4
100917: PPUSH
100918: LD_VAR 0 5
100922: PPUSH
100923: CALL 102176 0 6
100927: GO 101005
100929: LD_INT 303
100931: DOUBLE
100932: EQUAL
100933: IFTRUE 100937
100935: GO 100974
100937: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100938: LD_VAR 0 6
100942: PPUSH
100943: LD_VAR 0 7
100947: PPUSH
100948: LD_VAR 0 8
100952: PPUSH
100953: LD_VAR 0 9
100957: PPUSH
100958: LD_VAR 0 4
100962: PPUSH
100963: LD_VAR 0 5
100967: PPUSH
100968: CALL 101010 0 6
100972: GO 101005
100974: LD_INT 304
100976: DOUBLE
100977: EQUAL
100978: IFTRUE 100982
100980: GO 101004
100982: POP
// hHackTeleport ( unit , x , y ) ; end ;
100983: LD_VAR 0 2
100987: PPUSH
100988: LD_VAR 0 4
100992: PPUSH
100993: LD_VAR 0 5
100997: PPUSH
100998: CALL 102769 0 3
101002: GO 101005
101004: POP
// end ;
101005: LD_VAR 0 12
101009: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
101010: LD_INT 0
101012: PPUSH
101013: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
101014: LD_VAR 0 1
101018: PUSH
101019: LD_INT 1
101021: LESS
101022: PUSH
101023: LD_VAR 0 1
101027: PUSH
101028: LD_INT 3
101030: GREATER
101031: OR
101032: PUSH
101033: LD_VAR 0 5
101037: PPUSH
101038: LD_VAR 0 6
101042: PPUSH
101043: CALL_OW 428
101047: OR
101048: IFFALSE 101052
// exit ;
101050: GO 101772
// uc_side := your_side ;
101052: LD_ADDR_OWVAR 20
101056: PUSH
101057: LD_OWVAR 2
101061: ST_TO_ADDR
// uc_nation := nation ;
101062: LD_ADDR_OWVAR 21
101066: PUSH
101067: LD_VAR 0 1
101071: ST_TO_ADDR
// bc_level = 1 ;
101072: LD_ADDR_OWVAR 43
101076: PUSH
101077: LD_INT 1
101079: ST_TO_ADDR
// case btype of 1 :
101080: LD_VAR 0 2
101084: PUSH
101085: LD_INT 1
101087: DOUBLE
101088: EQUAL
101089: IFTRUE 101093
101091: GO 101104
101093: POP
// bc_type := b_depot ; 2 :
101094: LD_ADDR_OWVAR 42
101098: PUSH
101099: LD_INT 0
101101: ST_TO_ADDR
101102: GO 101716
101104: LD_INT 2
101106: DOUBLE
101107: EQUAL
101108: IFTRUE 101112
101110: GO 101123
101112: POP
// bc_type := b_warehouse ; 3 :
101113: LD_ADDR_OWVAR 42
101117: PUSH
101118: LD_INT 1
101120: ST_TO_ADDR
101121: GO 101716
101123: LD_INT 3
101125: DOUBLE
101126: EQUAL
101127: IFTRUE 101131
101129: GO 101142
101131: POP
// bc_type := b_lab ; 4 .. 9 :
101132: LD_ADDR_OWVAR 42
101136: PUSH
101137: LD_INT 6
101139: ST_TO_ADDR
101140: GO 101716
101142: LD_INT 4
101144: DOUBLE
101145: GREATEREQUAL
101146: IFFALSE 101154
101148: LD_INT 9
101150: DOUBLE
101151: LESSEQUAL
101152: IFTRUE 101156
101154: GO 101208
101156: POP
// begin bc_type := b_lab_half ;
101157: LD_ADDR_OWVAR 42
101161: PUSH
101162: LD_INT 7
101164: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
101165: LD_ADDR_OWVAR 44
101169: PUSH
101170: LD_INT 10
101172: PUSH
101173: LD_INT 11
101175: PUSH
101176: LD_INT 12
101178: PUSH
101179: LD_INT 15
101181: PUSH
101182: LD_INT 14
101184: PUSH
101185: LD_INT 13
101187: PUSH
101188: EMPTY
101189: LIST
101190: LIST
101191: LIST
101192: LIST
101193: LIST
101194: LIST
101195: PUSH
101196: LD_VAR 0 2
101200: PUSH
101201: LD_INT 3
101203: MINUS
101204: ARRAY
101205: ST_TO_ADDR
// end ; 10 .. 13 :
101206: GO 101716
101208: LD_INT 10
101210: DOUBLE
101211: GREATEREQUAL
101212: IFFALSE 101220
101214: LD_INT 13
101216: DOUBLE
101217: LESSEQUAL
101218: IFTRUE 101222
101220: GO 101299
101222: POP
// begin bc_type := b_lab_full ;
101223: LD_ADDR_OWVAR 42
101227: PUSH
101228: LD_INT 8
101230: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
101231: LD_ADDR_OWVAR 44
101235: PUSH
101236: LD_INT 10
101238: PUSH
101239: LD_INT 12
101241: PUSH
101242: LD_INT 14
101244: PUSH
101245: LD_INT 13
101247: PUSH
101248: EMPTY
101249: LIST
101250: LIST
101251: LIST
101252: LIST
101253: PUSH
101254: LD_VAR 0 2
101258: PUSH
101259: LD_INT 9
101261: MINUS
101262: ARRAY
101263: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
101264: LD_ADDR_OWVAR 45
101268: PUSH
101269: LD_INT 11
101271: PUSH
101272: LD_INT 15
101274: PUSH
101275: LD_INT 12
101277: PUSH
101278: LD_INT 15
101280: PUSH
101281: EMPTY
101282: LIST
101283: LIST
101284: LIST
101285: LIST
101286: PUSH
101287: LD_VAR 0 2
101291: PUSH
101292: LD_INT 9
101294: MINUS
101295: ARRAY
101296: ST_TO_ADDR
// end ; 14 :
101297: GO 101716
101299: LD_INT 14
101301: DOUBLE
101302: EQUAL
101303: IFTRUE 101307
101305: GO 101318
101307: POP
// bc_type := b_workshop ; 15 :
101308: LD_ADDR_OWVAR 42
101312: PUSH
101313: LD_INT 2
101315: ST_TO_ADDR
101316: GO 101716
101318: LD_INT 15
101320: DOUBLE
101321: EQUAL
101322: IFTRUE 101326
101324: GO 101337
101326: POP
// bc_type := b_factory ; 16 :
101327: LD_ADDR_OWVAR 42
101331: PUSH
101332: LD_INT 3
101334: ST_TO_ADDR
101335: GO 101716
101337: LD_INT 16
101339: DOUBLE
101340: EQUAL
101341: IFTRUE 101345
101343: GO 101356
101345: POP
// bc_type := b_ext_gun ; 17 :
101346: LD_ADDR_OWVAR 42
101350: PUSH
101351: LD_INT 17
101353: ST_TO_ADDR
101354: GO 101716
101356: LD_INT 17
101358: DOUBLE
101359: EQUAL
101360: IFTRUE 101364
101362: GO 101392
101364: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
101365: LD_ADDR_OWVAR 42
101369: PUSH
101370: LD_INT 19
101372: PUSH
101373: LD_INT 23
101375: PUSH
101376: LD_INT 19
101378: PUSH
101379: EMPTY
101380: LIST
101381: LIST
101382: LIST
101383: PUSH
101384: LD_VAR 0 1
101388: ARRAY
101389: ST_TO_ADDR
101390: GO 101716
101392: LD_INT 18
101394: DOUBLE
101395: EQUAL
101396: IFTRUE 101400
101398: GO 101411
101400: POP
// bc_type := b_ext_radar ; 19 :
101401: LD_ADDR_OWVAR 42
101405: PUSH
101406: LD_INT 20
101408: ST_TO_ADDR
101409: GO 101716
101411: LD_INT 19
101413: DOUBLE
101414: EQUAL
101415: IFTRUE 101419
101417: GO 101430
101419: POP
// bc_type := b_ext_radio ; 20 :
101420: LD_ADDR_OWVAR 42
101424: PUSH
101425: LD_INT 22
101427: ST_TO_ADDR
101428: GO 101716
101430: LD_INT 20
101432: DOUBLE
101433: EQUAL
101434: IFTRUE 101438
101436: GO 101449
101438: POP
// bc_type := b_ext_siberium ; 21 :
101439: LD_ADDR_OWVAR 42
101443: PUSH
101444: LD_INT 21
101446: ST_TO_ADDR
101447: GO 101716
101449: LD_INT 21
101451: DOUBLE
101452: EQUAL
101453: IFTRUE 101457
101455: GO 101468
101457: POP
// bc_type := b_ext_computer ; 22 :
101458: LD_ADDR_OWVAR 42
101462: PUSH
101463: LD_INT 24
101465: ST_TO_ADDR
101466: GO 101716
101468: LD_INT 22
101470: DOUBLE
101471: EQUAL
101472: IFTRUE 101476
101474: GO 101487
101476: POP
// bc_type := b_ext_track ; 23 :
101477: LD_ADDR_OWVAR 42
101481: PUSH
101482: LD_INT 16
101484: ST_TO_ADDR
101485: GO 101716
101487: LD_INT 23
101489: DOUBLE
101490: EQUAL
101491: IFTRUE 101495
101493: GO 101506
101495: POP
// bc_type := b_ext_laser ; 24 :
101496: LD_ADDR_OWVAR 42
101500: PUSH
101501: LD_INT 25
101503: ST_TO_ADDR
101504: GO 101716
101506: LD_INT 24
101508: DOUBLE
101509: EQUAL
101510: IFTRUE 101514
101512: GO 101525
101514: POP
// bc_type := b_control_tower ; 25 :
101515: LD_ADDR_OWVAR 42
101519: PUSH
101520: LD_INT 36
101522: ST_TO_ADDR
101523: GO 101716
101525: LD_INT 25
101527: DOUBLE
101528: EQUAL
101529: IFTRUE 101533
101531: GO 101544
101533: POP
// bc_type := b_breastwork ; 26 :
101534: LD_ADDR_OWVAR 42
101538: PUSH
101539: LD_INT 31
101541: ST_TO_ADDR
101542: GO 101716
101544: LD_INT 26
101546: DOUBLE
101547: EQUAL
101548: IFTRUE 101552
101550: GO 101563
101552: POP
// bc_type := b_bunker ; 27 :
101553: LD_ADDR_OWVAR 42
101557: PUSH
101558: LD_INT 32
101560: ST_TO_ADDR
101561: GO 101716
101563: LD_INT 27
101565: DOUBLE
101566: EQUAL
101567: IFTRUE 101571
101569: GO 101582
101571: POP
// bc_type := b_turret ; 28 :
101572: LD_ADDR_OWVAR 42
101576: PUSH
101577: LD_INT 33
101579: ST_TO_ADDR
101580: GO 101716
101582: LD_INT 28
101584: DOUBLE
101585: EQUAL
101586: IFTRUE 101590
101588: GO 101601
101590: POP
// bc_type := b_armoury ; 29 :
101591: LD_ADDR_OWVAR 42
101595: PUSH
101596: LD_INT 4
101598: ST_TO_ADDR
101599: GO 101716
101601: LD_INT 29
101603: DOUBLE
101604: EQUAL
101605: IFTRUE 101609
101607: GO 101620
101609: POP
// bc_type := b_barracks ; 30 :
101610: LD_ADDR_OWVAR 42
101614: PUSH
101615: LD_INT 5
101617: ST_TO_ADDR
101618: GO 101716
101620: LD_INT 30
101622: DOUBLE
101623: EQUAL
101624: IFTRUE 101628
101626: GO 101639
101628: POP
// bc_type := b_solar_power ; 31 :
101629: LD_ADDR_OWVAR 42
101633: PUSH
101634: LD_INT 27
101636: ST_TO_ADDR
101637: GO 101716
101639: LD_INT 31
101641: DOUBLE
101642: EQUAL
101643: IFTRUE 101647
101645: GO 101658
101647: POP
// bc_type := b_oil_power ; 32 :
101648: LD_ADDR_OWVAR 42
101652: PUSH
101653: LD_INT 26
101655: ST_TO_ADDR
101656: GO 101716
101658: LD_INT 32
101660: DOUBLE
101661: EQUAL
101662: IFTRUE 101666
101664: GO 101677
101666: POP
// bc_type := b_siberite_power ; 33 :
101667: LD_ADDR_OWVAR 42
101671: PUSH
101672: LD_INT 28
101674: ST_TO_ADDR
101675: GO 101716
101677: LD_INT 33
101679: DOUBLE
101680: EQUAL
101681: IFTRUE 101685
101683: GO 101696
101685: POP
// bc_type := b_oil_mine ; 34 :
101686: LD_ADDR_OWVAR 42
101690: PUSH
101691: LD_INT 29
101693: ST_TO_ADDR
101694: GO 101716
101696: LD_INT 34
101698: DOUBLE
101699: EQUAL
101700: IFTRUE 101704
101702: GO 101715
101704: POP
// bc_type := b_siberite_mine ; end ;
101705: LD_ADDR_OWVAR 42
101709: PUSH
101710: LD_INT 30
101712: ST_TO_ADDR
101713: GO 101716
101715: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101716: LD_ADDR_VAR 0 8
101720: PUSH
101721: LD_VAR 0 5
101725: PPUSH
101726: LD_VAR 0 6
101730: PPUSH
101731: LD_VAR 0 3
101735: PPUSH
101736: CALL_OW 47
101740: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101741: LD_OWVAR 42
101745: PUSH
101746: LD_INT 32
101748: PUSH
101749: LD_INT 33
101751: PUSH
101752: EMPTY
101753: LIST
101754: LIST
101755: IN
101756: IFFALSE 101772
// PlaceWeaponTurret ( b , weapon ) ;
101758: LD_VAR 0 8
101762: PPUSH
101763: LD_VAR 0 4
101767: PPUSH
101768: CALL_OW 431
// end ;
101772: LD_VAR 0 7
101776: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101777: LD_INT 0
101779: PPUSH
101780: PPUSH
101781: PPUSH
101782: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101783: LD_ADDR_VAR 0 4
101787: PUSH
101788: LD_INT 22
101790: PUSH
101791: LD_OWVAR 2
101795: PUSH
101796: EMPTY
101797: LIST
101798: LIST
101799: PUSH
101800: LD_INT 2
101802: PUSH
101803: LD_INT 30
101805: PUSH
101806: LD_INT 0
101808: PUSH
101809: EMPTY
101810: LIST
101811: LIST
101812: PUSH
101813: LD_INT 30
101815: PUSH
101816: LD_INT 1
101818: PUSH
101819: EMPTY
101820: LIST
101821: LIST
101822: PUSH
101823: EMPTY
101824: LIST
101825: LIST
101826: LIST
101827: PUSH
101828: EMPTY
101829: LIST
101830: LIST
101831: PPUSH
101832: CALL_OW 69
101836: ST_TO_ADDR
// if not tmp then
101837: LD_VAR 0 4
101841: NOT
101842: IFFALSE 101846
// exit ;
101844: GO 101905
// for i in tmp do
101846: LD_ADDR_VAR 0 2
101850: PUSH
101851: LD_VAR 0 4
101855: PUSH
101856: FOR_IN
101857: IFFALSE 101903
// for j = 1 to 3 do
101859: LD_ADDR_VAR 0 3
101863: PUSH
101864: DOUBLE
101865: LD_INT 1
101867: DEC
101868: ST_TO_ADDR
101869: LD_INT 3
101871: PUSH
101872: FOR_TO
101873: IFFALSE 101899
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101875: LD_VAR 0 2
101879: PPUSH
101880: CALL_OW 274
101884: PPUSH
101885: LD_VAR 0 3
101889: PPUSH
101890: LD_INT 99999
101892: PPUSH
101893: CALL_OW 277
101897: GO 101872
101899: POP
101900: POP
101901: GO 101856
101903: POP
101904: POP
// end ;
101905: LD_VAR 0 1
101909: RET
// export function hHackSetLevel10 ; var i , j ; begin
101910: LD_INT 0
101912: PPUSH
101913: PPUSH
101914: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101915: LD_ADDR_VAR 0 2
101919: PUSH
101920: LD_INT 21
101922: PUSH
101923: LD_INT 1
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: PPUSH
101930: CALL_OW 69
101934: PUSH
101935: FOR_IN
101936: IFFALSE 101988
// if IsSelected ( i ) then
101938: LD_VAR 0 2
101942: PPUSH
101943: CALL_OW 306
101947: IFFALSE 101986
// begin for j := 1 to 4 do
101949: LD_ADDR_VAR 0 3
101953: PUSH
101954: DOUBLE
101955: LD_INT 1
101957: DEC
101958: ST_TO_ADDR
101959: LD_INT 4
101961: PUSH
101962: FOR_TO
101963: IFFALSE 101984
// SetSkill ( i , j , 10 ) ;
101965: LD_VAR 0 2
101969: PPUSH
101970: LD_VAR 0 3
101974: PPUSH
101975: LD_INT 10
101977: PPUSH
101978: CALL_OW 237
101982: GO 101962
101984: POP
101985: POP
// end ;
101986: GO 101935
101988: POP
101989: POP
// end ;
101990: LD_VAR 0 1
101994: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101995: LD_INT 0
101997: PPUSH
101998: PPUSH
101999: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
102000: LD_ADDR_VAR 0 2
102004: PUSH
102005: LD_INT 22
102007: PUSH
102008: LD_OWVAR 2
102012: PUSH
102013: EMPTY
102014: LIST
102015: LIST
102016: PUSH
102017: LD_INT 21
102019: PUSH
102020: LD_INT 1
102022: PUSH
102023: EMPTY
102024: LIST
102025: LIST
102026: PUSH
102027: EMPTY
102028: LIST
102029: LIST
102030: PPUSH
102031: CALL_OW 69
102035: PUSH
102036: FOR_IN
102037: IFFALSE 102078
// begin for j := 1 to 4 do
102039: LD_ADDR_VAR 0 3
102043: PUSH
102044: DOUBLE
102045: LD_INT 1
102047: DEC
102048: ST_TO_ADDR
102049: LD_INT 4
102051: PUSH
102052: FOR_TO
102053: IFFALSE 102074
// SetSkill ( i , j , 10 ) ;
102055: LD_VAR 0 2
102059: PPUSH
102060: LD_VAR 0 3
102064: PPUSH
102065: LD_INT 10
102067: PPUSH
102068: CALL_OW 237
102072: GO 102052
102074: POP
102075: POP
// end ;
102076: GO 102036
102078: POP
102079: POP
// end ;
102080: LD_VAR 0 1
102084: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
102085: LD_INT 0
102087: PPUSH
// uc_side := your_side ;
102088: LD_ADDR_OWVAR 20
102092: PUSH
102093: LD_OWVAR 2
102097: ST_TO_ADDR
// uc_nation := nation ;
102098: LD_ADDR_OWVAR 21
102102: PUSH
102103: LD_VAR 0 1
102107: ST_TO_ADDR
// InitHc ;
102108: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
102112: LD_INT 0
102114: PPUSH
102115: LD_VAR 0 2
102119: PPUSH
102120: LD_VAR 0 3
102124: PPUSH
102125: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
102129: LD_VAR 0 4
102133: PPUSH
102134: LD_VAR 0 5
102138: PPUSH
102139: CALL_OW 428
102143: PUSH
102144: LD_INT 0
102146: EQUAL
102147: IFFALSE 102171
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
102149: CALL_OW 44
102153: PPUSH
102154: LD_VAR 0 4
102158: PPUSH
102159: LD_VAR 0 5
102163: PPUSH
102164: LD_INT 1
102166: PPUSH
102167: CALL_OW 48
// end ;
102171: LD_VAR 0 6
102175: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
102176: LD_INT 0
102178: PPUSH
102179: PPUSH
// uc_side := your_side ;
102180: LD_ADDR_OWVAR 20
102184: PUSH
102185: LD_OWVAR 2
102189: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
102190: LD_VAR 0 1
102194: PUSH
102195: LD_INT 1
102197: PUSH
102198: LD_INT 2
102200: PUSH
102201: LD_INT 3
102203: PUSH
102204: LD_INT 4
102206: PUSH
102207: LD_INT 5
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: LIST
102214: LIST
102215: LIST
102216: IN
102217: IFFALSE 102229
// uc_nation := nation_american else
102219: LD_ADDR_OWVAR 21
102223: PUSH
102224: LD_INT 1
102226: ST_TO_ADDR
102227: GO 102272
// if chassis in [ 11 , 12 , 13 , 14 ] then
102229: LD_VAR 0 1
102233: PUSH
102234: LD_INT 11
102236: PUSH
102237: LD_INT 12
102239: PUSH
102240: LD_INT 13
102242: PUSH
102243: LD_INT 14
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: LIST
102250: LIST
102251: IN
102252: IFFALSE 102264
// uc_nation := nation_arabian else
102254: LD_ADDR_OWVAR 21
102258: PUSH
102259: LD_INT 2
102261: ST_TO_ADDR
102262: GO 102272
// uc_nation := nation_russian ;
102264: LD_ADDR_OWVAR 21
102268: PUSH
102269: LD_INT 3
102271: ST_TO_ADDR
// vc_chassis := chassis ;
102272: LD_ADDR_OWVAR 37
102276: PUSH
102277: LD_VAR 0 1
102281: ST_TO_ADDR
// vc_engine := engine ;
102282: LD_ADDR_OWVAR 39
102286: PUSH
102287: LD_VAR 0 2
102291: ST_TO_ADDR
// vc_control := control ;
102292: LD_ADDR_OWVAR 38
102296: PUSH
102297: LD_VAR 0 3
102301: ST_TO_ADDR
// vc_weapon := weapon ;
102302: LD_ADDR_OWVAR 40
102306: PUSH
102307: LD_VAR 0 4
102311: ST_TO_ADDR
// un := CreateVehicle ;
102312: LD_ADDR_VAR 0 8
102316: PUSH
102317: CALL_OW 45
102321: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
102322: LD_VAR 0 8
102326: PPUSH
102327: LD_INT 0
102329: PPUSH
102330: LD_INT 5
102332: PPUSH
102333: CALL_OW 12
102337: PPUSH
102338: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
102342: LD_VAR 0 8
102346: PPUSH
102347: LD_VAR 0 5
102351: PPUSH
102352: LD_VAR 0 6
102356: PPUSH
102357: LD_INT 1
102359: PPUSH
102360: CALL_OW 48
// end ;
102364: LD_VAR 0 7
102368: RET
// export hInvincible ; every 1 do
102369: GO 102371
102371: DISABLE
// hInvincible := [ ] ;
102372: LD_ADDR_EXP 152
102376: PUSH
102377: EMPTY
102378: ST_TO_ADDR
102379: END
// every 10 do var i ;
102380: GO 102382
102382: DISABLE
102383: LD_INT 0
102385: PPUSH
// begin enable ;
102386: ENABLE
// if not hInvincible then
102387: LD_EXP 152
102391: NOT
102392: IFFALSE 102396
// exit ;
102394: GO 102440
// for i in hInvincible do
102396: LD_ADDR_VAR 0 1
102400: PUSH
102401: LD_EXP 152
102405: PUSH
102406: FOR_IN
102407: IFFALSE 102438
// if GetLives ( i ) < 1000 then
102409: LD_VAR 0 1
102413: PPUSH
102414: CALL_OW 256
102418: PUSH
102419: LD_INT 1000
102421: LESS
102422: IFFALSE 102436
// SetLives ( i , 1000 ) ;
102424: LD_VAR 0 1
102428: PPUSH
102429: LD_INT 1000
102431: PPUSH
102432: CALL_OW 234
102436: GO 102406
102438: POP
102439: POP
// end ;
102440: PPOPN 1
102442: END
// export function hHackInvincible ; var i ; begin
102443: LD_INT 0
102445: PPUSH
102446: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
102447: LD_ADDR_VAR 0 2
102451: PUSH
102452: LD_INT 2
102454: PUSH
102455: LD_INT 21
102457: PUSH
102458: LD_INT 1
102460: PUSH
102461: EMPTY
102462: LIST
102463: LIST
102464: PUSH
102465: LD_INT 21
102467: PUSH
102468: LD_INT 2
102470: PUSH
102471: EMPTY
102472: LIST
102473: LIST
102474: PUSH
102475: EMPTY
102476: LIST
102477: LIST
102478: LIST
102479: PPUSH
102480: CALL_OW 69
102484: PUSH
102485: FOR_IN
102486: IFFALSE 102547
// if IsSelected ( i ) then
102488: LD_VAR 0 2
102492: PPUSH
102493: CALL_OW 306
102497: IFFALSE 102545
// begin if i in hInvincible then
102499: LD_VAR 0 2
102503: PUSH
102504: LD_EXP 152
102508: IN
102509: IFFALSE 102529
// hInvincible := hInvincible diff i else
102511: LD_ADDR_EXP 152
102515: PUSH
102516: LD_EXP 152
102520: PUSH
102521: LD_VAR 0 2
102525: DIFF
102526: ST_TO_ADDR
102527: GO 102545
// hInvincible := hInvincible union i ;
102529: LD_ADDR_EXP 152
102533: PUSH
102534: LD_EXP 152
102538: PUSH
102539: LD_VAR 0 2
102543: UNION
102544: ST_TO_ADDR
// end ;
102545: GO 102485
102547: POP
102548: POP
// end ;
102549: LD_VAR 0 1
102553: RET
// export function hHackInvisible ; var i , j ; begin
102554: LD_INT 0
102556: PPUSH
102557: PPUSH
102558: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
102559: LD_ADDR_VAR 0 2
102563: PUSH
102564: LD_INT 21
102566: PUSH
102567: LD_INT 1
102569: PUSH
102570: EMPTY
102571: LIST
102572: LIST
102573: PPUSH
102574: CALL_OW 69
102578: PUSH
102579: FOR_IN
102580: IFFALSE 102604
// if IsSelected ( i ) then
102582: LD_VAR 0 2
102586: PPUSH
102587: CALL_OW 306
102591: IFFALSE 102602
// ComForceInvisible ( i ) ;
102593: LD_VAR 0 2
102597: PPUSH
102598: CALL_OW 496
102602: GO 102579
102604: POP
102605: POP
// end ;
102606: LD_VAR 0 1
102610: RET
// export function hHackChangeYourSide ; begin
102611: LD_INT 0
102613: PPUSH
// if your_side = 8 then
102614: LD_OWVAR 2
102618: PUSH
102619: LD_INT 8
102621: EQUAL
102622: IFFALSE 102634
// your_side := 0 else
102624: LD_ADDR_OWVAR 2
102628: PUSH
102629: LD_INT 0
102631: ST_TO_ADDR
102632: GO 102648
// your_side := your_side + 1 ;
102634: LD_ADDR_OWVAR 2
102638: PUSH
102639: LD_OWVAR 2
102643: PUSH
102644: LD_INT 1
102646: PLUS
102647: ST_TO_ADDR
// end ;
102648: LD_VAR 0 1
102652: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102653: LD_INT 0
102655: PPUSH
102656: PPUSH
102657: PPUSH
// for i in all_units do
102658: LD_ADDR_VAR 0 2
102662: PUSH
102663: LD_OWVAR 3
102667: PUSH
102668: FOR_IN
102669: IFFALSE 102747
// if IsSelected ( i ) then
102671: LD_VAR 0 2
102675: PPUSH
102676: CALL_OW 306
102680: IFFALSE 102745
// begin j := GetSide ( i ) ;
102682: LD_ADDR_VAR 0 3
102686: PUSH
102687: LD_VAR 0 2
102691: PPUSH
102692: CALL_OW 255
102696: ST_TO_ADDR
// if j = 8 then
102697: LD_VAR 0 3
102701: PUSH
102702: LD_INT 8
102704: EQUAL
102705: IFFALSE 102717
// j := 0 else
102707: LD_ADDR_VAR 0 3
102711: PUSH
102712: LD_INT 0
102714: ST_TO_ADDR
102715: GO 102731
// j := j + 1 ;
102717: LD_ADDR_VAR 0 3
102721: PUSH
102722: LD_VAR 0 3
102726: PUSH
102727: LD_INT 1
102729: PLUS
102730: ST_TO_ADDR
// SetSide ( i , j ) ;
102731: LD_VAR 0 2
102735: PPUSH
102736: LD_VAR 0 3
102740: PPUSH
102741: CALL_OW 235
// end ;
102745: GO 102668
102747: POP
102748: POP
// end ;
102749: LD_VAR 0 1
102753: RET
// export function hHackFog ; begin
102754: LD_INT 0
102756: PPUSH
// FogOff ( true ) ;
102757: LD_INT 1
102759: PPUSH
102760: CALL_OW 344
// end ;
102764: LD_VAR 0 1
102768: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102769: LD_INT 0
102771: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102772: LD_VAR 0 1
102776: PPUSH
102777: LD_VAR 0 2
102781: PPUSH
102782: LD_VAR 0 3
102786: PPUSH
102787: LD_INT 1
102789: PPUSH
102790: LD_INT 1
102792: PPUSH
102793: CALL_OW 483
// CenterOnXY ( x , y ) ;
102797: LD_VAR 0 2
102801: PPUSH
102802: LD_VAR 0 3
102806: PPUSH
102807: CALL_OW 84
// end ; end_of_file
102811: LD_VAR 0 4
102815: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
102816: LD_VAR 0 1
102820: PPUSH
102821: LD_VAR 0 2
102825: PPUSH
102826: LD_VAR 0 3
102830: PPUSH
102831: LD_VAR 0 4
102835: PPUSH
102836: LD_VAR 0 5
102840: PPUSH
102841: LD_VAR 0 6
102845: PPUSH
102846: CALL 89644 0 6
// end ;
102850: PPOPN 6
102852: END
